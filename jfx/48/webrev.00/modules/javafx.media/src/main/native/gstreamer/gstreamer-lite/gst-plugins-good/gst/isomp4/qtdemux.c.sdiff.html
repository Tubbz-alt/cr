<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/isomp4/qtdemux.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="properties.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="qtdemux.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/isomp4/qtdemux.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   81 
   82 /* max. size considered &#39;sane&#39; for non-mdat atoms */
   83 #define QTDEMUX_MAX_ATOM_SIZE (25*1024*1024)
   84 
   85 /* if the sample index is larger than this, something is likely wrong */
   86 #ifdef GSTREAMER_LITE
   87 // relaxing the limitation since some long files has more than 50Mb sample index
   88 #define QTDEMUX_MAX_SAMPLE_INDEX_SIZE (500*1024*1024)
   89 #else
   90 #define QTDEMUX_MAX_SAMPLE_INDEX_SIZE (200*1024*1024)
   91 #endif // GSTREAMER_LITE
   92 
   93 /* For converting qt creation times to unix epoch times */
   94 #define QTDEMUX_SECONDS_PER_DAY (60 * 60 * 24)
   95 #define QTDEMUX_LEAP_YEARS_FROM_1904_TO_1970 17
   96 #define QTDEMUX_SECONDS_FROM_1904_TO_1970 (((1970 - 1904) * (guint64) 365 + \
   97     QTDEMUX_LEAP_YEARS_FROM_1904_TO_1970) * QTDEMUX_SECONDS_PER_DAY)
   98 
   99 #define QTDEMUX_TREE_NODE_FOURCC(n) (QT_FOURCC(((guint8 *) (n)-&gt;data) + 4))
  100 
<span class="line-modified">  101 #define STREAM_IS_EOS(s) (s-&gt;time_position == GST_CLOCK_TIME_NONE)</span>
  102 
  103 #define ABSDIFF(x, y) ( (x) &gt; (y) ? ((x) - (y)) : ((y) - (x)) )
  104 







  105 GST_DEBUG_CATEGORY (qtdemux_debug);
  106 #define GST_CAT_DEFAULT qtdemux_debug
  107 
  108 typedef struct _QtDemuxSegment QtDemuxSegment;
  109 typedef struct _QtDemuxSample QtDemuxSample;
  110 
  111 typedef struct _QtDemuxCencSampleSetInfo QtDemuxCencSampleSetInfo;
  112 
  113 struct _QtDemuxSample
  114 {
  115   guint32 size;
  116   gint32 pts_offset;            /* Add this value to timestamp to get the pts */
  117   guint64 offset;
  118   guint64 timestamp;            /* DTS In mov time */
  119   guint32 duration;             /* In mov time */
  120   gboolean keyframe;            /* TRUE when this packet is a keyframe */
  121 };
  122 
  123 /* Macros for converting to/from timescale */
  124 #define QTSTREAMTIME_TO_GSTTIME(stream, value) (gst_util_uint64_scale((value), GST_SECOND, (stream)-&gt;timescale))
  125 #define GSTTIME_TO_QTSTREAMTIME(stream, value) (gst_util_uint64_scale((value), (stream)-&gt;timescale, GST_SECOND))
  126 
  127 #define QTTIME_TO_GSTTIME(qtdemux, value) (gst_util_uint64_scale((value), GST_SECOND, (qtdemux)-&gt;timescale))
  128 #define GSTTIME_TO_QTTIME(qtdemux, value) (gst_util_uint64_scale((value), (qtdemux)-&gt;timescale, GST_SECOND))
  129 
  130 /* timestamp is the DTS */
  131 #define QTSAMPLE_DTS(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)-&gt;timestamp))
  132 /* timestamp + offset + cslg_shift is the outgoing PTS */
  133 #define QTSAMPLE_PTS(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)-&gt;timestamp + (stream)-&gt;cslg_shift + (sample)-&gt;pts_offset))
  134 /* timestamp + offset is the PTS used for internal seek calcuations */
  135 #define QTSAMPLE_PTS_NO_CSLG(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)-&gt;timestamp + (sample)-&gt;pts_offset))
  136 /* timestamp + duration - dts is the duration */
  137 #define QTSAMPLE_DUR_DTS(stream, sample, dts) (QTSTREAMTIME_TO_GSTTIME ((stream), (sample)-&gt;timestamp + (sample)-&gt;duration) - (dts))
  138 
  139 #define QTSAMPLE_KEYFRAME(stream,sample) ((stream)-&gt;all_keyframe || (sample)-&gt;keyframe)
  140 












  141 /*
  142  * Quicktime has tracks and segments. A track is a continuous piece of
  143  * multimedia content. The track is not always played from start to finish but
  144  * instead, pieces of the track are &#39;cut out&#39; and played in sequence. This is
  145  * what the segments do.
  146  *
  147  * Inside the track we have keyframes (K) and delta frames. The track has its
  148  * own timing, which starts from 0 and extends to end. The position in the track
  149  * is called the media_time.
  150  *
  151  * The segments now describe the pieces that should be played from this track
  152  * and are basically tuples of media_time/duration/rate entries. We can have
  153  * multiple segments and they are all played after one another. An example:
  154  *
  155  * segment 1: media_time: 1 second, duration: 1 second, rate 1
  156  * segment 2: media_time: 3 second, duration: 2 second, rate 2
  157  *
  158  * To correctly play back this track, one must play: 1 second of media starting
  159  * from media_time 1 followed by 2 seconds of media starting from media_time 3
  160  * at a rate of 2.
</pre>
<hr />
<pre>
  245   gint n_channels;
  246   guint samples_per_packet;
  247   guint samples_per_frame;
  248   guint bytes_per_packet;
  249   guint bytes_per_sample;
  250   guint bytes_per_frame;
  251   guint compression;
  252 
  253   /* if we use chunks or samples */
  254   gboolean sampled;
  255   guint padding;
  256 
  257 } QtDemuxStreamStsdEntry;
  258 
  259 #define CUR_STREAM(s) (&amp;((s)-&gt;stsd_entries[(s)-&gt;cur_stsd_entry_index]))
  260 
  261 struct _QtDemuxStream
  262 {
  263   GstPad *pad;
  264 



  265   QtDemuxStreamStsdEntry *stsd_entries;
  266   guint stsd_entries_length;
  267   guint cur_stsd_entry_index;
  268 
  269   /* stream type */
  270   guint32 subtype;
  271 
  272   gboolean new_caps;            /* If TRUE, caps need to be generated (by
  273                                  * calling _configure_stream()) This happens
  274                                  * for MSS and fragmented streams */
  275 
  276   gboolean new_stream;          /* signals that a stream_start is required */
  277   gboolean on_keyframe;         /* if this stream last pushed buffer was a
  278                                  * keyframe. This is important to identify
  279                                  * where to stop pushing buffers after a
  280                                  * segment stop time */
  281 
  282   /* if the stream has a redirect URI in its headers, we store it here */
  283   gchar *redirect_uri;
  284 
  285   /* track id */
  286   guint track_id;
  287 #ifdef GSTREAMER_LITE
  288   gboolean track_enabled;
  289 #endif // GSTREAMER_LITE
  290 
  291   /* duration/scale */
  292   guint64 duration;             /* in timescale units */
  293   guint32 timescale;
  294 
  295   /* language */
  296   gchar lang_id[4];             /* ISO 639-2T language code */
  297 
  298   /* our samples */
  299   guint32 n_samples;
  300   QtDemuxSample *samples;
  301   gboolean all_keyframe;        /* TRUE when all samples are keyframes (no stss) */
<span class="line-removed">  302   guint32 first_duration;       /* duration in timescale of first sample, used for figuring out</span>
<span class="line-removed">  303                                    the framerate */</span>
  304   guint32 n_samples_moof;       /* sample count in a moof */
  305   guint64 duration_moof;        /* duration in timescale of a moof, used for figure out
  306                                  * the framerate of fragmented format stream */
  307   guint64 duration_last_moof;
  308 
  309   guint32 offset_in_sample;     /* Offset in the current sample, used for
  310                                  * streams which have got exceedingly big
  311                                  * sample size (such as 24s of raw audio).
  312                                  * Only used when max_buffer_size is non-NULL */
  313   guint32 max_buffer_size;      /* Maximum allowed size for output buffers.
  314                                  * Currently only set for raw audio streams*/
  315 
  316   /* video info */
  317   /* aspect ratio */
  318   gint display_width;
  319   gint display_height;
  320 
  321   /* allocation */
  322   gboolean use_allocator;
  323   GstAllocator *allocator;
  324   GstAllocationParams params;
  325 
  326   gsize alignment;
  327 
  328   /* when a discontinuity is pending */
  329   gboolean discont;
  330 
  331   /* list of buffers to push first */
  332   GSList *buffers;
  333 
  334   /* if we need to clip this buffer. This is only needed for uncompressed
  335    * data */
  336   gboolean need_clip;
  337 
  338   /* buffer needs some custom processing, e.g. subtitles */
  339   gboolean need_process;


  340 
  341   /* current position */
  342   guint32 segment_index;
  343   guint32 sample_index;
  344   GstClockTime time_position;   /* in gst time */
  345   guint64 accumulated_base;
  346 
  347   /* the Gst segment we are processing out, used for clipping */
  348   GstSegment segment;
  349 
  350   /* quicktime segments */
  351   guint32 n_segments;
  352   QtDemuxSegment *segments;
  353   gboolean dummy_segment;
  354   guint32 from_sample;
  355   guint32 to_sample;
  356 
  357   gboolean sent_eos;
  358   GstTagList *stream_tags;
  359   gboolean send_global_tags;
</pre>
<hr />
<pre>
  420 
  421   /* fragmented */
  422   gboolean parsed_trex;
  423   guint32 def_sample_description_index; /* index is 1-based */
  424   guint32 def_sample_duration;
  425   guint32 def_sample_size;
  426   guint32 def_sample_flags;
  427 
  428   gboolean disabled;
  429 
  430   /* stereoscopic video streams */
  431   GstVideoMultiviewMode multiview_mode;
  432   GstVideoMultiviewFlags multiview_flags;
  433 
  434   /* protected streams */
  435   gboolean protected;
  436   guint32 protection_scheme_type;
  437   guint32 protection_scheme_version;
  438   gpointer protection_scheme_info;      /* specific to the protection scheme */
  439   GQueue protection_scheme_event_queue;


  440 };
  441 
  442 /* Contains properties and cryptographic info for a set of samples from a
  443  * track protected using Common Encryption (cenc) */
  444 struct _QtDemuxCencSampleSetInfo
  445 {
  446   GstStructure *default_properties;
  447 
  448   /* @crypto_info holds one GstStructure per sample */
  449   GPtrArray *crypto_info;
  450 };
  451 
  452 static const gchar *
  453 qt_demux_state_string (enum QtDemuxState state)
  454 {
  455   switch (state) {
  456     case QTDEMUX_STATE_INITIAL:
  457       return &quot;&lt;INITIAL&gt;&quot;;
  458     case QTDEMUX_STATE_HEADER:
  459       return &quot;&lt;HEADER&gt;&quot;;
  460     case QTDEMUX_STATE_MOVIE:
  461       return &quot;&lt;MOVIE&gt;&quot;;
  462     case QTDEMUX_STATE_BUFFER_MDAT:
  463       return &quot;&lt;BUFFER_MDAT&gt;&quot;;
  464     default:
  465       return &quot;&lt;UNKNOWN&gt;&quot;;
  466   }
  467 }
  468 
  469 static GNode *qtdemux_tree_get_child_by_type (GNode * node, guint32 fourcc);
  470 static GNode *qtdemux_tree_get_child_by_type_full (GNode * node,
  471     guint32 fourcc, GstByteReader * parser);
  472 static GNode *qtdemux_tree_get_sibling_by_type (GNode * node, guint32 fourcc);
  473 static GNode *qtdemux_tree_get_sibling_by_type_full (GNode * node,
  474     guint32 fourcc, GstByteReader * parser);
  475 
  476 static GstFlowReturn qtdemux_add_fragmented_samples (GstQTDemux * qtdemux);
  477 


  478 static GstStaticPadTemplate gst_qtdemux_sink_template =
  479     GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
  480     GST_PAD_SINK,
  481     GST_PAD_ALWAYS,
  482     GST_STATIC_CAPS (&quot;video/quicktime; video/mj2; audio/x-m4a; &quot;
  483         &quot;application/x-3gp&quot;)
  484     );
  485 
  486 static GstStaticPadTemplate gst_qtdemux_videosrc_template =
  487 GST_STATIC_PAD_TEMPLATE (&quot;video_%u&quot;,
  488     GST_PAD_SRC,
  489     GST_PAD_SOMETIMES,
  490     GST_STATIC_CAPS_ANY);
  491 
  492 static GstStaticPadTemplate gst_qtdemux_audiosrc_template =
  493 GST_STATIC_PAD_TEMPLATE (&quot;audio_%u&quot;,
  494     GST_PAD_SRC,
  495     GST_PAD_SOMETIMES,
  496     GST_STATIC_CAPS_ANY);
  497 
</pre>
<hr />
<pre>
  502     GST_STATIC_CAPS_ANY);
  503 
  504 #define gst_qtdemux_parent_class parent_class
  505 G_DEFINE_TYPE (GstQTDemux, gst_qtdemux, GST_TYPE_ELEMENT);
  506 
  507 static void gst_qtdemux_dispose (GObject * object);
  508 
  509 static guint32
  510 gst_qtdemux_find_index_linear (GstQTDemux * qtdemux, QtDemuxStream * str,
  511     GstClockTime media_time);
  512 static guint32
  513 gst_qtdemux_find_index_for_given_media_offset_linear (GstQTDemux * qtdemux,
  514     QtDemuxStream * str, gint64 media_offset);
  515 
  516 #if 0
  517 static void gst_qtdemux_set_index (GstElement * element, GstIndex * index);
  518 static GstIndex *gst_qtdemux_get_index (GstElement * element);
  519 #endif
  520 static GstStateChangeReturn gst_qtdemux_change_state (GstElement * element,
  521     GstStateChange transition);


  522 static gboolean qtdemux_sink_activate (GstPad * sinkpad, GstObject * parent);
  523 static gboolean qtdemux_sink_activate_mode (GstPad * sinkpad,
  524     GstObject * parent, GstPadMode mode, gboolean active);
  525 
  526 static void gst_qtdemux_loop (GstPad * pad);
  527 static GstFlowReturn gst_qtdemux_chain (GstPad * sinkpad, GstObject * parent,
  528     GstBuffer * inbuf);
  529 static gboolean gst_qtdemux_handle_sink_event (GstPad * pad, GstObject * parent,
  530     GstEvent * event);


  531 static gboolean gst_qtdemux_setcaps (GstQTDemux * qtdemux, GstCaps * caps);
  532 static gboolean gst_qtdemux_configure_stream (GstQTDemux * qtdemux,
  533     QtDemuxStream * stream);
  534 static void gst_qtdemux_stream_check_and_change_stsd_index (GstQTDemux * demux,
  535     QtDemuxStream * stream);
  536 static GstFlowReturn gst_qtdemux_process_adapter (GstQTDemux * demux,
  537     gboolean force);
  538 


  539 static gboolean qtdemux_parse_moov (GstQTDemux * qtdemux,
  540     const guint8 * buffer, guint length);
  541 static gboolean qtdemux_parse_node (GstQTDemux * qtdemux, GNode * node,
  542     const guint8 * buffer, guint length);
  543 static gboolean qtdemux_parse_tree (GstQTDemux * qtdemux);
  544 static void qtdemux_parse_udta (GstQTDemux * qtdemux, GstTagList * taglist,
  545     GNode * udta);
  546 
  547 #ifdef GSTREAMER_LITE
  548 static gboolean gst_qtdemux_handle_esds (GstQTDemux * qtdemux,
  549     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, GNode * esds,
  550     GstTagList * list);
  551 #else
  552 static void gst_qtdemux_handle_esds (GstQTDemux * qtdemux,
  553     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, GNode * esds,
  554     GstTagList * list);
  555 #endif // GSTREAMER_LITE
  556 static GstCaps *qtdemux_video_caps (GstQTDemux * qtdemux,
  557     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, guint32 fourcc,
  558     const guint8 * stsd_entry_data, gchar ** codec_name);
  559 static GstCaps *qtdemux_audio_caps (GstQTDemux * qtdemux,
  560     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, guint32 fourcc,
  561     const guint8 * data, int len, gchar ** codec_name);
  562 static GstCaps *qtdemux_sub_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
  563     QtDemuxStreamStsdEntry * entry, guint32 fourcc, const guint8 * data,
  564     gchar ** codec_name);
  565 static GstCaps *qtdemux_generic_caps (GstQTDemux * qtdemux,
  566     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, guint32 fourcc,
  567     const guint8 * stsd_entry_data, gchar ** codec_name);
  568 
  569 static gboolean qtdemux_parse_samples (GstQTDemux * qtdemux,
  570     QtDemuxStream * stream, guint32 n);
  571 static GstFlowReturn qtdemux_expose_streams (GstQTDemux * qtdemux);
<span class="line-modified">  572 static void gst_qtdemux_stream_free (GstQTDemux * qtdemux,</span>
<span class="line-modified">  573     QtDemuxStream * stream);</span>
<span class="line-modified">  574 static void gst_qtdemux_stream_clear (GstQTDemux * qtdemux,</span>
<span class="line-removed">  575     QtDemuxStream * stream);</span>
<span class="line-removed">  576 static void gst_qtdemux_remove_stream (GstQTDemux * qtdemux, int index);</span>
  577 static GstFlowReturn qtdemux_prepare_streams (GstQTDemux * qtdemux);
<span class="line-modified">  578 static void qtdemux_do_allocation (GstQTDemux * qtdemux,</span>
<span class="line-modified">  579     QtDemuxStream * stream);</span>
  580 static gboolean gst_qtdemux_activate_segment (GstQTDemux * qtdemux,
  581     QtDemuxStream * stream, guint32 seg_idx, GstClockTime offset);
  582 static gboolean gst_qtdemux_stream_update_segment (GstQTDemux * qtdemux,
  583     QtDemuxStream * stream, gint seg_idx, GstClockTime offset,
  584     GstClockTime * _start, GstClockTime * _stop);
  585 static void gst_qtdemux_send_gap_for_segment (GstQTDemux * demux,
  586     QtDemuxStream * stream, gint segment_index, GstClockTime pos);
  587 
  588 static gboolean qtdemux_pull_mfro_mfra (GstQTDemux * qtdemux);
  589 static void check_update_duration (GstQTDemux * qtdemux, GstClockTime duration);
  590 
  591 static gchar *qtdemux_uuid_bytes_to_string (gconstpointer uuid_bytes);
  592 
  593 static GstStructure *qtdemux_get_cenc_sample_properties (GstQTDemux * qtdemux,
  594     QtDemuxStream * stream, guint sample_index);
  595 static void gst_qtdemux_append_protection_system_id (GstQTDemux * qtdemux,
  596     const gchar * id);
  597 static void qtdemux_gst_structure_free (GstStructure * gststructure);

  598 
  599 static void
  600 gst_qtdemux_class_init (GstQTDemuxClass * klass)
  601 {
  602   GObjectClass *gobject_class;
  603   GstElementClass *gstelement_class;
  604 
  605   gobject_class = (GObjectClass *) klass;
  606   gstelement_class = (GstElementClass *) klass;
  607 
  608   parent_class = g_type_class_peek_parent (klass);
  609 
  610   gobject_class-&gt;dispose = gst_qtdemux_dispose;
  611 
  612   gstelement_class-&gt;change_state = GST_DEBUG_FUNCPTR (gst_qtdemux_change_state);
  613 #if 0
  614   gstelement_class-&gt;set_index = GST_DEBUG_FUNCPTR (gst_qtdemux_set_index);
  615   gstelement_class-&gt;get_index = GST_DEBUG_FUNCPTR (gst_qtdemux_get_index);
  616 #endif

  617 
  618   gst_tag_register_musicbrainz_tags ();
  619 
  620   gst_element_class_add_static_pad_template (gstelement_class,
  621       &amp;gst_qtdemux_sink_template);
  622   gst_element_class_add_static_pad_template (gstelement_class,
  623       &amp;gst_qtdemux_videosrc_template);
  624   gst_element_class_add_static_pad_template (gstelement_class,
  625       &amp;gst_qtdemux_audiosrc_template);
  626   gst_element_class_add_static_pad_template (gstelement_class,
  627       &amp;gst_qtdemux_subsrc_template);
  628   gst_element_class_set_static_metadata (gstelement_class, &quot;QuickTime demuxer&quot;,
  629       &quot;Codec/Demuxer&quot;,
  630       &quot;Demultiplex a QuickTime file into audio and video streams&quot;,
  631       &quot;David Schleef &lt;ds@schleef.org&gt;, Wim Taymans &lt;wim@fluendo.com&gt;&quot;);
  632 
  633   GST_DEBUG_CATEGORY_INIT (qtdemux_debug, &quot;qtdemux&quot;, 0, &quot;qtdemux plugin&quot;);
  634   gst_riff_init ();
  635 }
  636 
  637 static void
  638 gst_qtdemux_init (GstQTDemux * qtdemux)
  639 {
  640   qtdemux-&gt;sinkpad =
  641       gst_pad_new_from_static_template (&amp;gst_qtdemux_sink_template, &quot;sink&quot;);
  642   gst_pad_set_activate_function (qtdemux-&gt;sinkpad, qtdemux_sink_activate);
  643   gst_pad_set_activatemode_function (qtdemux-&gt;sinkpad,
  644       qtdemux_sink_activate_mode);
  645   gst_pad_set_chain_function (qtdemux-&gt;sinkpad, gst_qtdemux_chain);
  646   gst_pad_set_event_function (qtdemux-&gt;sinkpad, gst_qtdemux_handle_sink_event);

  647   gst_element_add_pad (GST_ELEMENT_CAST (qtdemux), qtdemux-&gt;sinkpad);
  648 
<span class="line-removed">  649   qtdemux-&gt;state = QTDEMUX_STATE_INITIAL;</span>
<span class="line-removed">  650   qtdemux-&gt;pullbased = FALSE;</span>
<span class="line-removed">  651   qtdemux-&gt;posted_redirect = FALSE;</span>
<span class="line-removed">  652   qtdemux-&gt;neededbytes = 16;</span>
<span class="line-removed">  653   qtdemux-&gt;todrop = 0;</span>
  654   qtdemux-&gt;adapter = gst_adapter_new ();
<span class="line-removed">  655   qtdemux-&gt;offset = 0;</span>
<span class="line-removed">  656   qtdemux-&gt;first_mdat = -1;</span>
<span class="line-removed">  657   qtdemux-&gt;got_moov = FALSE;</span>
<span class="line-removed">  658   qtdemux-&gt;mdatoffset = -1;</span>
<span class="line-removed">  659   qtdemux-&gt;mdatbuffer = NULL;</span>
<span class="line-removed">  660   qtdemux-&gt;restoredata_buffer = NULL;</span>
<span class="line-removed">  661   qtdemux-&gt;restoredata_offset = -1;</span>
<span class="line-removed">  662   qtdemux-&gt;fragment_start = -1;</span>
<span class="line-removed">  663   qtdemux-&gt;fragment_start_offset = -1;</span>
<span class="line-removed">  664   qtdemux-&gt;media_caps = NULL;</span>
<span class="line-removed">  665   qtdemux-&gt;exposed = FALSE;</span>
<span class="line-removed">  666   qtdemux-&gt;mss_mode = FALSE;</span>
<span class="line-removed">  667   qtdemux-&gt;pending_newsegment = NULL;</span>
<span class="line-removed">  668   qtdemux-&gt;upstream_format_is_time = FALSE;</span>
<span class="line-removed">  669   qtdemux-&gt;have_group_id = FALSE;</span>
<span class="line-removed">  670   qtdemux-&gt;group_id = G_MAXUINT;</span>
<span class="line-removed">  671   qtdemux-&gt;cenc_aux_info_offset = 0;</span>
<span class="line-removed">  672   qtdemux-&gt;cenc_aux_info_sizes = NULL;</span>
<span class="line-removed">  673   qtdemux-&gt;cenc_aux_sample_count = 0;</span>
<span class="line-removed">  674   qtdemux-&gt;protection_system_ids = NULL;</span>
  675   g_queue_init (&amp;qtdemux-&gt;protection_event_queue);
<span class="line-removed">  676   gst_segment_init (&amp;qtdemux-&gt;segment, GST_FORMAT_TIME);</span>
<span class="line-removed">  677   qtdemux-&gt;tag_list = gst_tag_list_new_empty ();</span>
<span class="line-removed">  678   gst_tag_list_set_scope (qtdemux-&gt;tag_list, GST_TAG_SCOPE_GLOBAL);</span>
  679   qtdemux-&gt;flowcombiner = gst_flow_combiner_new ();






  680 
  681   GST_OBJECT_FLAG_SET (qtdemux, GST_ELEMENT_FLAG_INDEXABLE);


  682 }
  683 
  684 static void
  685 gst_qtdemux_dispose (GObject * object)
  686 {
  687   GstQTDemux *qtdemux = GST_QTDEMUX (object);
  688 
  689   if (qtdemux-&gt;adapter) {
  690     g_object_unref (G_OBJECT (qtdemux-&gt;adapter));
  691     qtdemux-&gt;adapter = NULL;
  692   }
  693   gst_tag_list_unref (qtdemux-&gt;tag_list);
  694   gst_flow_combiner_free (qtdemux-&gt;flowcombiner);
  695   g_queue_foreach (&amp;qtdemux-&gt;protection_event_queue, (GFunc) gst_event_unref,
  696       NULL);
  697   g_queue_clear (&amp;qtdemux-&gt;protection_event_queue);
  698 
  699   g_free (qtdemux-&gt;cenc_aux_info_sizes);
  700   qtdemux-&gt;cenc_aux_info_sizes = NULL;




  701 
  702   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
  703 }
  704 
  705 static void
  706 gst_qtdemux_post_no_playable_stream_error (GstQTDemux * qtdemux)
  707 {
  708   if (qtdemux-&gt;posted_redirect) {
  709     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
  710         (_(&quot;This file contains no playable streams.&quot;)),
  711         (&quot;no known streams found, a redirect message has been posted&quot;));
  712   } else {
  713     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
  714         (_(&quot;This file contains no playable streams.&quot;)),
  715         (&quot;no known streams found&quot;));
  716   }
  717 }
  718 
  719 static GstBuffer *
  720 _gst_buffer_new_wrapped (gpointer mem, gsize size, GFreeFunc free_func)
</pre>
<hr />
<pre>
  849   }
  850 
  851 done:
  852   return res;
  853 }
  854 #endif
  855 
  856 static gboolean
  857 gst_qtdemux_get_duration (GstQTDemux * qtdemux, GstClockTime * duration)
  858 {
  859   gboolean res = FALSE;
  860 
  861   *duration = GST_CLOCK_TIME_NONE;
  862 
  863   if (qtdemux-&gt;duration != 0 &amp;&amp;
  864       qtdemux-&gt;duration != G_MAXINT64 &amp;&amp; qtdemux-&gt;timescale != 0) {
  865     *duration = QTTIME_TO_GSTTIME (qtdemux, qtdemux-&gt;duration);
  866     res = TRUE;
  867   } else {
  868     *duration = GST_CLOCK_TIME_NONE;
<span class="line-modified">  869     }</span>
  870 
  871   return res;
  872 }
  873 
  874 static gboolean
  875 gst_qtdemux_handle_src_query (GstPad * pad, GstObject * parent,
  876     GstQuery * query)
  877 {
  878   gboolean res = FALSE;
  879   GstQTDemux *qtdemux = GST_QTDEMUX (parent);
  880 
  881   GST_LOG_OBJECT (pad, &quot;%s query&quot;, GST_QUERY_TYPE_NAME (query));
  882 
  883   switch (GST_QUERY_TYPE (query)) {
  884     case GST_QUERY_POSITION:{
  885       GstFormat fmt;
  886 
  887       gst_query_parse_position (query, &amp;fmt, NULL);
  888       if (fmt == GST_FORMAT_TIME
  889           &amp;&amp; GST_CLOCK_TIME_IS_VALID (qtdemux-&gt;segment.position)) {
  890         gst_query_set_position (query, GST_FORMAT_TIME,
  891             qtdemux-&gt;segment.position);
  892         res = TRUE;
  893       }
  894     }
  895       break;
  896     case GST_QUERY_DURATION:{
  897       GstFormat fmt;
  898 
  899       gst_query_parse_duration (query, &amp;fmt, NULL);
  900       if (fmt == GST_FORMAT_TIME) {
  901         /* First try to query upstream */
  902         res = gst_pad_query_default (pad, parent, query);
  903         if (!res) {
  904           GstClockTime duration;
  905           if (gst_qtdemux_get_duration (qtdemux, &amp;duration) &amp;&amp; duration &gt; 0) {
<span class="line-modified">  906           gst_query_set_duration (query, GST_FORMAT_TIME, duration);</span>
<span class="line-modified">  907           res = TRUE;</span>

  908         }
  909       }
<span class="line-removed">  910       }</span>
  911       break;
  912     }
  913     case GST_QUERY_CONVERT:{
  914       GstFormat src_fmt, dest_fmt;
  915       gint64 src_value, dest_value = 0;
  916 
  917       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_value, &amp;dest_fmt, NULL);
  918 
  919       res = gst_qtdemux_src_convert (qtdemux, pad,
  920           src_fmt, src_value, dest_fmt, &amp;dest_value);
  921       if (res)
  922         gst_query_set_convert (query, src_fmt, src_value, dest_fmt, dest_value);
  923 
  924       break;
  925     }
  926     case GST_QUERY_FORMATS:
  927       gst_query_set_formats (query, 2, GST_FORMAT_TIME, GST_FORMAT_BYTES);
  928       res = TRUE;
  929       break;
  930     case GST_QUERY_SEEKING:{
  931       GstFormat fmt;
  932       gboolean seekable;
  933 
  934       /* try upstream first */
  935       res = gst_pad_query_default (pad, parent, query);
  936 
  937       if (!res) {
<span class="line-modified">  938       gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);</span>
<span class="line-modified">  939       if (fmt == GST_FORMAT_TIME) {</span>
  940           GstClockTime duration;
  941 
<span class="line-modified">  942         gst_qtdemux_get_duration (qtdemux, &amp;duration);</span>
<span class="line-modified">  943         seekable = TRUE;</span>
<span class="line-modified">  944         if (!qtdemux-&gt;pullbased) {</span>
<span class="line-modified">  945           GstQuery *q;</span>
<span class="line-modified">  946 </span>
<span class="line-modified">  947           /* we might be able with help from upstream */</span>
<span class="line-modified">  948           seekable = FALSE;</span>
<span class="line-modified">  949           q = gst_query_new_seeking (GST_FORMAT_BYTES);</span>
<span class="line-modified">  950           if (gst_pad_peer_query (qtdemux-&gt;sinkpad, q)) {</span>
<span class="line-modified">  951             gst_query_parse_seeking (q, &amp;fmt, &amp;seekable, NULL, NULL);</span>
<span class="line-modified">  952             GST_LOG_OBJECT (qtdemux, &quot;upstream BYTE seekable %d&quot;, seekable);</span>


  953           }
<span class="line-modified">  954           gst_query_unref (q);</span>

  955         }
<span class="line-removed">  956         gst_query_set_seeking (query, GST_FORMAT_TIME, seekable, 0, duration);</span>
<span class="line-removed">  957         res = TRUE;</span>
<span class="line-removed">  958       }</span>
  959       }
  960       break;
  961     }
  962     case GST_QUERY_SEGMENT:
  963     {
  964       GstFormat format;
  965       gint64 start, stop;
  966 
  967       format = qtdemux-&gt;segment.format;
  968 
  969       start =
  970           gst_segment_to_stream_time (&amp;qtdemux-&gt;segment, format,
  971           qtdemux-&gt;segment.start);
  972       if ((stop = qtdemux-&gt;segment.stop) == -1)
  973         stop = qtdemux-&gt;segment.duration;
  974       else
  975         stop = gst_segment_to_stream_time (&amp;qtdemux-&gt;segment, format, stop);
  976 
  977       gst_query_set_segment (query, qtdemux-&gt;segment.rate, format, start, stop);
  978       res = TRUE;
</pre>
<hr />
<pre>
 1002       GST_DEBUG_OBJECT (qtdemux, &quot;Sending tags %&quot; GST_PTR_FORMAT,
 1003           stream-&gt;stream_tags);
 1004       gst_pad_push_event (stream-&gt;pad,
 1005           gst_event_new_tag (gst_tag_list_ref (stream-&gt;stream_tags)));
 1006     }
 1007 
 1008     if (G_UNLIKELY (stream-&gt;send_global_tags)) {
 1009       GST_DEBUG_OBJECT (qtdemux, &quot;Sending global tags %&quot; GST_PTR_FORMAT,
 1010           qtdemux-&gt;tag_list);
 1011       gst_pad_push_event (stream-&gt;pad,
 1012           gst_event_new_tag (gst_tag_list_ref (qtdemux-&gt;tag_list)));
 1013       stream-&gt;send_global_tags = FALSE;
 1014     }
 1015   }
 1016 }
 1017 
 1018 /* push event on all source pads; takes ownership of the event */
 1019 static void
 1020 gst_qtdemux_push_event (GstQTDemux * qtdemux, GstEvent * event)
 1021 {
<span class="line-removed"> 1022   guint n;</span>
 1023   gboolean has_valid_stream = FALSE;
 1024   GstEventType etype = GST_EVENT_TYPE (event);

 1025 
 1026   GST_DEBUG_OBJECT (qtdemux, &quot;pushing %s event on all source pads&quot;,
 1027       GST_EVENT_TYPE_NAME (event));
 1028 
<span class="line-modified"> 1029   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
 1030     GstPad *pad;
<span class="line-modified"> 1031     QtDemuxStream *stream = qtdemux-&gt;streams[n];</span>
<span class="line-modified"> 1032     GST_DEBUG_OBJECT (qtdemux, &quot;pushing on pad %i&quot;, n);</span>
 1033 
 1034     if ((pad = stream-&gt;pad)) {
 1035       has_valid_stream = TRUE;
 1036 
 1037       if (etype == GST_EVENT_EOS) {
 1038         /* let&#39;s not send twice */
 1039         if (stream-&gt;sent_eos)
 1040           continue;
 1041         stream-&gt;sent_eos = TRUE;
 1042       }
 1043 
 1044       gst_pad_push_event (pad, gst_event_ref (event));
 1045     }
 1046   }
 1047 
 1048   gst_event_unref (event);
 1049 
 1050   /* if it is EOS and there are no pads, post an error */
 1051   if (!has_valid_stream &amp;&amp; etype == GST_EVENT_EOS) {
 1052     gst_qtdemux_post_no_playable_stream_error (qtdemux);
 1053   }
 1054 }
 1055 
<span class="line-removed"> 1056 /* push a pending newsegment event, if any from the streaming thread */</span>
<span class="line-removed"> 1057 static void</span>
<span class="line-removed"> 1058 gst_qtdemux_push_pending_newsegment (GstQTDemux * qtdemux)</span>
<span class="line-removed"> 1059 {</span>
<span class="line-removed"> 1060   if (qtdemux-&gt;pending_newsegment) {</span>
<span class="line-removed"> 1061     gst_qtdemux_push_event (qtdemux, qtdemux-&gt;pending_newsegment);</span>
<span class="line-removed"> 1062     qtdemux-&gt;pending_newsegment = NULL;</span>
<span class="line-removed"> 1063   }</span>
<span class="line-removed"> 1064 }</span>
<span class="line-removed"> 1065 </span>
 1066 typedef struct
 1067 {
 1068   guint64 media_time;
 1069 } FindData;
 1070 
 1071 static gint
 1072 find_func (QtDemuxSample * s1, gint64 * media_time, gpointer user_data)
 1073 {
<span class="line-modified"> 1074   if ((gint64) s1-&gt;timestamp + s1-&gt;pts_offset &gt; *media_time)</span>
 1075     return 1;
<span class="line-modified"> 1076   if ((gint64) s1-&gt;timestamp + s1-&gt;pts_offset == *media_time)</span>
 1077     return 0;
 1078 
 1079   return -1;
 1080 }
 1081 
 1082 /* find the index of the sample that includes the data for @media_time using a
 1083  * binary search.  Only to be called in optimized cases of linear search below.
 1084  *
<span class="line-modified"> 1085  * Returns the index of the sample.</span>
 1086  */
 1087 static guint32
 1088 gst_qtdemux_find_index (GstQTDemux * qtdemux, QtDemuxStream * str,
 1089     guint64 media_time)
 1090 {
 1091   QtDemuxSample *result;
 1092   guint32 index;
 1093 
 1094   /* convert media_time to mov format */
 1095   media_time =
 1096       gst_util_uint64_scale_ceil (media_time, str-&gt;timescale, GST_SECOND);
 1097 
 1098   result = gst_util_array_binary_search (str-&gt;samples, str-&gt;stbl_index + 1,
 1099       sizeof (QtDemuxSample), (GCompareDataFunc) find_func,
 1100       GST_SEARCH_MODE_BEFORE, &amp;media_time, NULL);
 1101 
 1102   if (G_LIKELY (result))
 1103     index = result - str-&gt;samples;
 1104   else
 1105     index = 0;
</pre>
<hr />
<pre>
 1155  * Returns the index of the sample.
 1156  */
 1157 static guint32
 1158 gst_qtdemux_find_index_linear (GstQTDemux * qtdemux, QtDemuxStream * str,
 1159     GstClockTime media_time)
 1160 {
 1161   guint32 index = 0;
 1162   guint64 mov_time;
 1163   QtDemuxSample *sample;
 1164 
 1165   /* convert media_time to mov format */
 1166   mov_time =
 1167       gst_util_uint64_scale_ceil (media_time, str-&gt;timescale, GST_SECOND);
 1168 
 1169   sample = str-&gt;samples;
 1170   if (mov_time == sample-&gt;timestamp + sample-&gt;pts_offset)
 1171     return index;
 1172 
 1173   /* use faster search if requested time in already parsed range */
 1174   sample = str-&gt;samples + str-&gt;stbl_index;
<span class="line-modified"> 1175   if (str-&gt;stbl_index &gt;= 0 &amp;&amp;</span>
<span class="line-modified"> 1176       mov_time &lt;= (sample-&gt;timestamp + sample-&gt;pts_offset))</span>
<span class="line-modified"> 1177     return gst_qtdemux_find_index (qtdemux, str, media_time);</span>




 1178 
<span class="line-modified"> 1179   while (index &lt; str-&gt;n_samples - 1) {</span>
<span class="line-modified"> 1180     if (!qtdemux_parse_samples (qtdemux, str, index + 1))</span>
<span class="line-modified"> 1181       goto parse_failed;</span>


 1182 
<span class="line-modified"> 1183     sample = str-&gt;samples + index + 1;</span>
<span class="line-modified"> 1184     if (mov_time &lt; (sample-&gt;timestamp + sample-&gt;pts_offset))</span>
<span class="line-modified"> 1185       break;</span>
 1186 
<span class="line-modified"> 1187     index++;</span>




 1188   }

 1189   return index;
 1190 
 1191   /* ERRORS */
 1192 parse_failed:
 1193   {
 1194     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;, index + 1);
 1195     return -1;
 1196   }
 1197 }
 1198 
 1199 /* find the index of the keyframe needed to decode the sample at @index
 1200  * of stream @str, or of a subsequent keyframe (depending on @next)
 1201  *
 1202  * Returns the index of the keyframe.
 1203  */
 1204 static guint32
 1205 gst_qtdemux_find_keyframe (GstQTDemux * qtdemux, QtDemuxStream * str,
 1206     guint32 index, gboolean next)
 1207 {
 1208   guint32 new_index = index;
</pre>
<hr />
<pre>
 1215   /* all keyframes, return index */
 1216   if (str-&gt;all_keyframe) {
 1217     new_index = index;
 1218     goto beach;
 1219   }
 1220 
 1221   /* else search until we have a keyframe */
 1222   while (new_index &lt; str-&gt;n_samples) {
 1223     if (next &amp;&amp; !qtdemux_parse_samples (qtdemux, str, new_index))
 1224       goto parse_failed;
 1225 
 1226     if (str-&gt;samples[new_index].keyframe)
 1227       break;
 1228 
 1229     if (new_index == 0)
 1230       break;
 1231 
 1232     if (next)
 1233       new_index++;
 1234     else
<span class="line-modified"> 1235     new_index--;</span>
 1236   }
 1237 
 1238   if (new_index == str-&gt;n_samples) {
 1239     GST_DEBUG_OBJECT (qtdemux, &quot;no next keyframe&quot;);
 1240     new_index = -1;
 1241   }
 1242 
 1243 beach:
 1244   GST_DEBUG_OBJECT (qtdemux, &quot;searching for keyframe index %s index %u &quot;
 1245       &quot;gave %u&quot;, next ? &quot;after&quot; : &quot;before&quot;, index, new_index);
 1246 
 1247   return new_index;
 1248 
 1249   /* ERRORS */
 1250 parse_failed:
 1251   {
 1252     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;, new_index);
 1253     return -1;
<span class="line-modified"> 1254 }</span>
 1255 }
 1256 
 1257 /* find the segment for @time_position for @stream
 1258  *
 1259  * Returns the index of the segment containing @time_position.
 1260  * Returns the last segment and sets the @eos variable to TRUE
 1261  * if the time is beyond the end. @eos may be NULL
 1262  */
 1263 static guint32
 1264 gst_qtdemux_find_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
 1265     GstClockTime time_position)
 1266 {
 1267   gint i;
 1268   guint32 seg_idx;
 1269 
 1270   GST_LOG_OBJECT (stream-&gt;pad, &quot;finding segment for %&quot; GST_TIME_FORMAT,
 1271       GST_TIME_ARGS (time_position));
 1272 
 1273   seg_idx = -1;
 1274   for (i = 0; i &lt; stream-&gt;n_segments; i++) {
 1275     QtDemuxSegment *segment = &amp;stream-&gt;segments[i];
 1276 
 1277     GST_LOG_OBJECT (stream-&gt;pad,
 1278         &quot;looking at segment %&quot; GST_TIME_FORMAT &quot;-%&quot; GST_TIME_FORMAT,
 1279         GST_TIME_ARGS (segment-&gt;time), GST_TIME_ARGS (segment-&gt;stop_time));
 1280 
 1281     /* For the last segment we include stop_time in the last segment */
 1282     if (i &lt; stream-&gt;n_segments - 1) {
 1283       if (segment-&gt;time &lt;= time_position &amp;&amp; time_position &lt; segment-&gt;stop_time) {
 1284         GST_LOG_OBJECT (stream-&gt;pad, &quot;segment %d matches&quot;, i);
 1285         seg_idx = i;
 1286         break;
 1287       }
 1288     } else {
 1289       /* Last segment always matches */
<span class="line-modified"> 1290         seg_idx = i;</span>
<span class="line-modified"> 1291         break;</span>
<span class="line-removed"> 1292       }</span>
 1293     }

 1294   return seg_idx;
 1295 }
 1296 
 1297 /* move the stream @str to the sample position @index.
 1298  *
 1299  * Updates @str-&gt;sample_index and marks discontinuity if needed.
 1300  */
 1301 static void
 1302 gst_qtdemux_move_stream (GstQTDemux * qtdemux, QtDemuxStream * str,
 1303     guint32 index)
 1304 {
 1305   /* no change needed */
 1306   if (index == str-&gt;sample_index)
 1307     return;
 1308 
 1309   GST_DEBUG_OBJECT (qtdemux, &quot;moving to sample %u of %u&quot;, index,
 1310       str-&gt;n_samples);
 1311 
 1312   /* position changed, we have a discont */
 1313   str-&gt;sample_index = index;
 1314   str-&gt;offset_in_sample = 0;
 1315   /* Each time we move in the stream we store the position where we are
 1316    * starting from */
 1317   str-&gt;from_sample = index;
 1318   str-&gt;discont = TRUE;
 1319 }
 1320 
 1321 static void
 1322 gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
 1323     gboolean use_sparse, gboolean next, gint64 * key_time, gint64 * key_offset)
 1324 {
 1325   guint64 min_offset;
 1326   gint64 min_byte_offset = -1;
<span class="line-modified"> 1327   gint n;</span>
 1328 
 1329   min_offset = desired_time;
 1330 
 1331   /* for each stream, find the index of the sample in the segment
 1332    * and move back to the previous keyframe. */
<span class="line-modified"> 1333   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
 1334     QtDemuxStream *str;
 1335     guint32 index, kindex;
 1336     guint32 seg_idx;
 1337     GstClockTime media_start;
 1338     GstClockTime media_time;
 1339     GstClockTime seg_time;
 1340     QtDemuxSegment *seg;
 1341     gboolean empty_segment = FALSE;
 1342 
<span class="line-modified"> 1343     str = qtdemux-&gt;streams[n];</span>
 1344 
 1345     if (CUR_STREAM (str)-&gt;sparse &amp;&amp; !use_sparse)
 1346       continue;
 1347 
 1348     seg_idx = gst_qtdemux_find_segment (qtdemux, str, desired_time);
 1349     GST_DEBUG_OBJECT (qtdemux, &quot;align segment %d&quot;, seg_idx);
 1350 
 1351     /* get segment and time in the segment */
 1352     seg = &amp;str-&gt;segments[seg_idx];
 1353     seg_time = (desired_time - seg-&gt;time) * seg-&gt;rate;
 1354 
 1355     while (QTSEGMENT_IS_EMPTY (seg)) {
 1356       seg_time = 0;
 1357       empty_segment = TRUE;
 1358       GST_DEBUG_OBJECT (str-&gt;pad, &quot;Segment %d is empty, moving to next one&quot;,
 1359           seg_idx);
 1360       seg_idx++;
 1361       if (seg_idx == str-&gt;n_segments)
 1362         break;
 1363       seg = &amp;str-&gt;segments[seg_idx];
</pre>
<hr />
<pre>
 1368        * happens we better handle it */
 1369       continue;
 1370     }
 1371 
 1372     /* get the media time in the segment */
 1373     media_start = seg-&gt;media_start + seg_time;
 1374 
 1375     /* get the index of the sample with media time */
 1376     index = gst_qtdemux_find_index_linear (qtdemux, str, media_start);
 1377     GST_DEBUG_OBJECT (qtdemux, &quot;sample for %&quot; GST_TIME_FORMAT &quot; at %u&quot;
 1378         &quot; at offset %&quot; G_GUINT64_FORMAT &quot; (empty segment: %d)&quot;,
 1379         GST_TIME_ARGS (media_start), index, str-&gt;samples[index].offset,
 1380         empty_segment);
 1381 
 1382     /* shift to next frame if we are looking for next keyframe */
 1383     if (next &amp;&amp; QTSAMPLE_PTS_NO_CSLG (str, &amp;str-&gt;samples[index]) &lt; media_start
 1384         &amp;&amp; index &lt; str-&gt;stbl_index)
 1385       index++;
 1386 
 1387     if (!empty_segment) {
<span class="line-modified"> 1388     /* find previous keyframe */</span>
 1389       kindex = gst_qtdemux_find_keyframe (qtdemux, str, index, next);
 1390 
 1391       /* we will settle for one before if none found after */
 1392       if (next &amp;&amp; kindex == -1)
 1393         kindex = gst_qtdemux_find_keyframe (qtdemux, str, index, FALSE);
 1394 
<span class="line-modified"> 1395     /* if the keyframe is at a different position, we need to update the</span>
<span class="line-modified"> 1396      * requested seek time */</span>
<span class="line-modified"> 1397     if (index != kindex) {</span>
<span class="line-modified"> 1398       index = kindex;</span>
 1399 
<span class="line-modified"> 1400       /* get timestamp of keyframe */</span>
 1401         media_time = QTSAMPLE_PTS_NO_CSLG (str, &amp;str-&gt;samples[kindex]);
 1402         GST_DEBUG_OBJECT (qtdemux,
 1403             &quot;keyframe at %u with time %&quot; GST_TIME_FORMAT &quot; at offset %&quot;
 1404             G_GUINT64_FORMAT, kindex, GST_TIME_ARGS (media_time),
 1405             str-&gt;samples[kindex].offset);
 1406 
<span class="line-modified"> 1407       /* keyframes in the segment get a chance to change the</span>
<span class="line-modified"> 1408        * desired_offset. keyframes out of the segment are</span>
<span class="line-modified"> 1409        * ignored. */</span>
<span class="line-modified"> 1410       if (media_time &gt;= seg-&gt;media_start) {</span>
 1411           GstClockTime seg_time;
 1412 
<span class="line-modified"> 1413         /* this keyframe is inside the segment, convert back to</span>
<span class="line-modified"> 1414          * segment time */</span>
<span class="line-modified"> 1415         seg_time = (media_time - seg-&gt;media_start) + seg-&gt;time;</span>
 1416           if ((!next &amp;&amp; (seg_time &lt; min_offset)) ||
 1417               (next &amp;&amp; (seg_time &gt; min_offset)))
<span class="line-modified"> 1418           min_offset = seg_time;</span>

 1419       }
 1420     }
<span class="line-removed"> 1421     }</span>
 1422 
 1423     if (min_byte_offset &lt; 0 || str-&gt;samples[index].offset &lt; min_byte_offset)
 1424       min_byte_offset = str-&gt;samples[index].offset;
 1425   }
 1426 
 1427   if (key_time)
 1428     *key_time = min_offset;
 1429   if (key_offset)
 1430     *key_offset = min_byte_offset;
 1431 }
 1432 
 1433 static gboolean
 1434 gst_qtdemux_convert_seek (GstPad * pad, GstFormat * format,
 1435     GstSeekType cur_type, gint64 * cur, GstSeekType stop_type, gint64 * stop)
 1436 {
 1437   gboolean res;
 1438 
 1439   g_return_val_if_fail (format != NULL, FALSE);
 1440   g_return_val_if_fail (cur != NULL, FALSE);
 1441   g_return_val_if_fail (stop != NULL, FALSE);
</pre>
<hr />
<pre>
 1492   /* Upstream seek in bytes will have undefined stop, but qtdemux stores
 1493    * the original stop position to use when upstream pushes the new segment
 1494    * for this seek */
 1495   original_stop = stop;
 1496   stop = -1;
 1497 
 1498   /* find reasonable corresponding BYTE position,
 1499    * also try to mind about keyframes, since we can not go back a bit for them
 1500    * later on */
 1501   /* determining @next here based on SNAP_BEFORE/SNAP_AFTER should
 1502    * mostly just work, but let&#39;s not yet boldly go there  ... */
 1503   gst_qtdemux_adjust_seek (qtdemux, cur, FALSE, FALSE, &amp;key_cur, &amp;byte_cur);
 1504 
 1505   if (byte_cur == -1)
 1506     goto abort_seek;
 1507 
 1508   GST_DEBUG_OBJECT (qtdemux, &quot;Pushing BYTE seek rate %g, &quot;
 1509       &quot;start %&quot; G_GINT64_FORMAT &quot;, stop %&quot; G_GINT64_FORMAT, rate, byte_cur,
 1510       stop);
 1511 
<span class="line-modified"> 1512     GST_OBJECT_LOCK (qtdemux);</span>
<span class="line-modified"> 1513     qtdemux-&gt;seek_offset = byte_cur;</span>
 1514   if (!(flags &amp; GST_SEEK_FLAG_KEY_UNIT)) {
 1515     qtdemux-&gt;push_seek_start = cur;
 1516   } else {
 1517     qtdemux-&gt;push_seek_start = key_cur;
 1518   }
 1519 
 1520   if (stop_type == GST_SEEK_TYPE_NONE) {
 1521     qtdemux-&gt;push_seek_stop = qtdemux-&gt;segment.stop;
 1522   } else {
 1523     qtdemux-&gt;push_seek_stop = original_stop;
 1524   }
 1525   GST_OBJECT_UNLOCK (qtdemux);
 1526 

 1527   /* BYTE seek event */
 1528 #ifdef GSTREAMER_LITE
 1529   new_event = gst_event_new_seek(rate, GST_FORMAT_BYTES, flags, cur_type, byte_cur,
 1530       stop_type, stop);
 1531   gst_event_set_seqnum(new_event, seqnum);
 1532   res = gst_pad_push_event(qtdemux-&gt;sinkpad, new_event);
 1533   if (res) {
 1534     gst_event_unref(event);
 1535   }
 1536 #else // GSTREAMER_LITE
 1537   event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags, cur_type, byte_cur,
 1538       stop_type, stop);
 1539   gst_event_set_seqnum (event, seqnum);
 1540   res = gst_pad_push_event (qtdemux-&gt;sinkpad, event);
 1541 #endif // GSTREAMER_LITE
 1542 
 1543   return res;
 1544 
 1545   /* ERRORS */
 1546 abort_seek:
</pre>
<hr />
<pre>
 1565  *
 1566  * We set all segment_indexes in the streams to unknown and
 1567  * adjust the time_position to the desired position. this is enough
 1568  * to trigger a segment switch in the streaming thread to start
 1569  * streaming from the desired position.
 1570  *
 1571  * Keyframe seeking is a little more complicated when dealing with
 1572  * segments. Ideally we want to move to the previous keyframe in
 1573  * the segment but there might not be a keyframe in the segment. In
 1574  * fact, none of the segments could contain a keyframe. We take a
 1575  * practical approach: seek to the previous keyframe in the segment,
 1576  * if there is none, seek to the beginning of the segment.
 1577  *
 1578  * Called with STREAM_LOCK
 1579  */
 1580 static gboolean
 1581 gst_qtdemux_perform_seek (GstQTDemux * qtdemux, GstSegment * segment,
 1582     guint32 seqnum, GstSeekFlags flags)
 1583 {
 1584   gint64 desired_offset;
<span class="line-modified"> 1585   gint n;</span>
 1586 
 1587   desired_offset = segment-&gt;position;
 1588 
 1589   GST_DEBUG_OBJECT (qtdemux, &quot;seeking to %&quot; GST_TIME_FORMAT,
 1590       GST_TIME_ARGS (desired_offset));
 1591 
 1592   /* may not have enough fragmented info to do this adjustment,
 1593    * and we can&#39;t scan (and probably should not) at this time with
 1594    * possibly flushing upstream */
 1595   if ((flags &amp; GST_SEEK_FLAG_KEY_UNIT) &amp;&amp; !qtdemux-&gt;fragmented) {
 1596     gint64 min_offset;
 1597     gboolean next, before, after;
 1598 
 1599     before = ! !(flags &amp; GST_SEEK_FLAG_SNAP_BEFORE);
 1600     after = ! !(flags &amp; GST_SEEK_FLAG_SNAP_AFTER);
 1601     next = after &amp;&amp; !before;
 1602     if (segment-&gt;rate &lt; 0)
 1603       next = !next;
 1604 
 1605     gst_qtdemux_adjust_seek (qtdemux, desired_offset, TRUE, next, &amp;min_offset,
 1606         NULL);
 1607     GST_DEBUG_OBJECT (qtdemux, &quot;keyframe seek, align to %&quot;
 1608         GST_TIME_FORMAT, GST_TIME_ARGS (min_offset));
 1609     desired_offset = min_offset;
 1610   }
 1611 
 1612   /* and set all streams to the final position */
 1613   gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
 1614   qtdemux-&gt;segment_seqnum = seqnum;
<span class="line-modified"> 1615   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
<span class="line-modified"> 1616     QtDemuxStream *stream = qtdemux-&gt;streams[n];</span>
 1617 
 1618     stream-&gt;time_position = desired_offset;
 1619     stream-&gt;accumulated_base = 0;
 1620     stream-&gt;sample_index = -1;
 1621     stream-&gt;offset_in_sample = 0;
 1622     stream-&gt;segment_index = -1;
 1623     stream-&gt;sent_eos = FALSE;
 1624 
 1625     if (segment-&gt;flags &amp; GST_SEEK_FLAG_FLUSH)
 1626       gst_segment_init (&amp;stream-&gt;segment, GST_FORMAT_TIME);
 1627   }
 1628   segment-&gt;position = desired_offset;
 1629   segment-&gt;time = desired_offset;
 1630   if (segment-&gt;rate &gt;= 0) {
 1631     segment-&gt;start = desired_offset;
 1632 
<span class="line-modified"> 1633   /* we stop at the end */</span>
<span class="line-modified"> 1634   if (segment-&gt;stop == -1)</span>
<span class="line-modified"> 1635     segment-&gt;stop = segment-&gt;duration;</span>
 1636   } else {
 1637     segment-&gt;stop = desired_offset;
 1638   }
 1639 
 1640   if (qtdemux-&gt;fragmented)
 1641     qtdemux-&gt;fragmented_seek_pending = TRUE;
 1642 
 1643   return TRUE;
 1644 }
 1645 
 1646 /* do a seek in pull based mode */
 1647 static gboolean
 1648 gst_qtdemux_do_seek (GstQTDemux * qtdemux, GstPad * pad, GstEvent * event)
 1649 {
 1650   gdouble rate;
 1651   GstFormat format;
 1652   GstSeekFlags flags;
 1653   GstSeekType cur_type, stop_type;
 1654   gint64 cur, stop;
 1655   gboolean flush;
</pre>
<hr />
<pre>
 1694     gst_pad_pause_task (qtdemux-&gt;sinkpad);
 1695   }
 1696 
 1697   /* wait for streaming to finish */
 1698   GST_PAD_STREAM_LOCK (qtdemux-&gt;sinkpad);
 1699 
 1700   /* copy segment, we need this because we still need the old
 1701    * segment when we close the current segment. */
 1702   memcpy (&amp;seeksegment, &amp;qtdemux-&gt;segment, sizeof (GstSegment));
 1703 
 1704   if (event) {
 1705     /* configure the segment with the seek variables */
 1706     GST_DEBUG_OBJECT (qtdemux, &quot;configuring seek&quot;);
 1707     if (!gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
 1708             cur_type, cur, stop_type, stop, &amp;update)) {
 1709       ret = FALSE;
 1710       GST_ERROR_OBJECT (qtdemux, &quot;inconsistent seek values, doing nothing&quot;);
 1711     } else {
 1712       /* now do the seek */
 1713       ret = gst_qtdemux_perform_seek (qtdemux, &amp;seeksegment, seqnum, flags);
<span class="line-modified"> 1714   }</span>
 1715   } else {
 1716     /* now do the seek */
 1717     ret = gst_qtdemux_perform_seek (qtdemux, &amp;seeksegment, seqnum, flags);
 1718   }
 1719 
 1720   /* prepare for streaming again */
 1721   if (flush) {
 1722     flush_event = gst_event_new_flush_stop (TRUE);
 1723     if (seqnum != GST_SEQNUM_INVALID)
 1724       gst_event_set_seqnum (flush_event, seqnum);
 1725 
 1726     gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (flush_event));
 1727     gst_qtdemux_push_event (qtdemux, flush_event);
<span class="line-modified"> 1728     }</span>
 1729 
 1730   /* commit the new segment */
 1731   memcpy (&amp;qtdemux-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 1732 
 1733   if (qtdemux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 1734     GstMessage *msg = gst_message_new_segment_start (GST_OBJECT_CAST (qtdemux),
 1735         qtdemux-&gt;segment.format, qtdemux-&gt;segment.position);
 1736     if (seqnum != GST_SEQNUM_INVALID)
 1737       gst_message_set_seqnum (msg, seqnum);
 1738     gst_element_post_message (GST_ELEMENT_CAST (qtdemux), msg);
 1739   }
 1740 
 1741   /* restart streaming, NEWSEGMENT will be sent from the streaming thread. */
 1742   gst_pad_start_task (qtdemux-&gt;sinkpad, (GstTaskFunction) gst_qtdemux_loop,
 1743       qtdemux-&gt;sinkpad, NULL);
 1744 
 1745   GST_PAD_STREAM_UNLOCK (qtdemux-&gt;sinkpad);
 1746 
 1747   return ret;
 1748 
 1749   /* ERRORS */
 1750 no_format:
 1751   {
 1752     GST_DEBUG_OBJECT (qtdemux, &quot;unsupported format given, seek aborted.&quot;);
 1753     return FALSE;
 1754   }
 1755 }
 1756 
 1757 static gboolean
 1758 qtdemux_ensure_index (GstQTDemux * qtdemux)
 1759 {
 1760   guint i;
 1761 
 1762   GST_DEBUG_OBJECT (qtdemux, &quot;collecting all metadata for all streams&quot;);
 1763 
 1764   /* Build complete index */
<span class="line-modified"> 1765   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified"> 1766     QtDemuxStream *stream = qtdemux-&gt;streams[i];</span>
 1767 
<span class="line-modified"> 1768     if (!qtdemux_parse_samples (qtdemux, stream, stream-&gt;n_samples - 1))</span>
<span class="line-modified"> 1769       goto parse_error;</span>




 1770   }
<span class="line-removed"> 1771   return TRUE;</span>
 1772 
<span class="line-modified"> 1773   /* ERRORS */</span>
<span class="line-removed"> 1774 parse_error:</span>
<span class="line-removed"> 1775   {</span>
<span class="line-removed"> 1776     GST_LOG_OBJECT (qtdemux,</span>
<span class="line-removed"> 1777         &quot;Building complete index of stream %u for seeking failed!&quot;, i);</span>
<span class="line-removed"> 1778     return FALSE;</span>
<span class="line-removed"> 1779   }</span>
 1780 }
 1781 
 1782 static gboolean
 1783 gst_qtdemux_handle_src_event (GstPad * pad, GstObject * parent,
 1784     GstEvent * event)
 1785 {
 1786   gboolean res = TRUE;
 1787   GstQTDemux *qtdemux = GST_QTDEMUX (parent);
 1788 
 1789   switch (GST_EVENT_TYPE (event)) {
 1790     case GST_EVENT_SEEK:
 1791     {
 1792 #ifndef GST_DISABLE_GST_DEBUG
 1793       GstClockTime ts = gst_util_get_timestamp ();
 1794 #endif
 1795       guint32 seqnum = gst_event_get_seqnum (event);
 1796 


 1797       if (seqnum == qtdemux-&gt;segment_seqnum) {
 1798         GST_LOG_OBJECT (pad,
 1799             &quot;Drop duplicated SEEK event seqnum %&quot; G_GUINT32_FORMAT, seqnum);
 1800         gst_event_unref (event);
 1801         return TRUE;
 1802       }
 1803 
 1804       if (qtdemux-&gt;upstream_format_is_time &amp;&amp; qtdemux-&gt;fragmented) {
 1805         /* seek should be handled by upstream, we might need to re-download fragments */
 1806         GST_DEBUG_OBJECT (qtdemux,
 1807             &quot;let upstream handle seek for fragmented playback&quot;);
 1808         goto upstream;
 1809       }
 1810 
 1811       /* Build complete index for seeking;
 1812        * if not a fragmented file at least */
 1813       if (!qtdemux-&gt;fragmented)
 1814         if (!qtdemux_ensure_index (qtdemux))
 1815           goto index_failed;
 1816 #ifndef GST_DISABLE_GST_DEBUG
 1817       ts = gst_util_get_timestamp () - ts;
 1818       GST_INFO_OBJECT (qtdemux,
 1819           &quot;Time taken to parse index %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (ts));
 1820 #endif
 1821     }
 1822       if (qtdemux-&gt;pullbased) {
 1823         res = gst_qtdemux_do_seek (qtdemux, pad, event);
 1824       } else if (gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (event))) {
 1825         GST_DEBUG_OBJECT (qtdemux, &quot;Upstream successfully seeked&quot;);
 1826         res = TRUE;
<span class="line-modified"> 1827       } else if (qtdemux-&gt;state == QTDEMUX_STATE_MOVIE &amp;&amp; qtdemux-&gt;n_streams</span>

 1828           &amp;&amp; !qtdemux-&gt;fragmented) {
 1829         res = gst_qtdemux_do_push_seek (qtdemux, pad, event);
 1830       } else {
 1831         GST_DEBUG_OBJECT (qtdemux,
 1832             &quot;ignoring seek in push mode in current state&quot;);
 1833         res = FALSE;
 1834       }
 1835       gst_event_unref (event);
 1836       break;
 1837     default:
 1838     upstream:
 1839       res = gst_pad_event_default (pad, parent, event);
 1840       break;
 1841   }
 1842 
 1843 done:
 1844   return res;
 1845 
 1846   /* ERRORS */
 1847 index_failed:
</pre>
<hr />
<pre>
 1853   }
 1854 }
 1855 
 1856 /* Find, for each track, the first sample in coding order that has a file offset &gt;= @byte_pos.
 1857  *
 1858  * If @fw is false, the coding order is explored backwards.
 1859  *
 1860  * If @set is true, each stream will be moved to its matched sample, or EOS if no matching
 1861  * sample is found for that track.
 1862  *
 1863  * The stream and sample index of the sample with the minimum offset in the direction explored
 1864  * (see @fw) is returned in the output parameters @_stream and @_index respectively.
 1865  *
 1866  * @_time is set to the QTSAMPLE_PTS of the matched sample with the minimum QTSAMPLE_PTS in the
 1867  * direction explored, which may not always match the QTSAMPLE_PTS of the sample returned in
 1868  * @_stream and @_index. */
 1869 static void
 1870 gst_qtdemux_find_sample (GstQTDemux * qtdemux, gint64 byte_pos, gboolean fw,
 1871     gboolean set, QtDemuxStream ** _stream, gint * _index, gint64 * _time)
 1872 {
<span class="line-modified"> 1873   gint i, n, index;</span>
 1874   gint64 time, min_time;
 1875   QtDemuxStream *stream;

 1876 
 1877   min_time = -1;
 1878   stream = NULL;
 1879   index = -1;
 1880 
<span class="line-modified"> 1881   for (n = 0; n &lt; qtdemux-&gt;n_streams; ++n) {</span>
 1882     QtDemuxStream *str;
 1883     gint inc;
 1884     gboolean set_sample;
 1885 
<span class="line-modified"> 1886     str = qtdemux-&gt;streams[n];</span>
 1887     set_sample = !set;
 1888 
 1889     if (fw) {
 1890       i = 0;
 1891       inc = 1;
 1892     } else {
 1893       i = str-&gt;n_samples - 1;
 1894       inc = -1;
 1895     }
 1896 
 1897     for (; (i &gt;= 0) &amp;&amp; (i &lt; str-&gt;n_samples); i += inc) {
 1898       if (str-&gt;samples[i].size == 0)
 1899         continue;
 1900 
 1901       if (fw &amp;&amp; (str-&gt;samples[i].offset &lt; byte_pos))
 1902         continue;
 1903 
 1904       if (!fw &amp;&amp; (str-&gt;samples[i].offset + str-&gt;samples[i].size &gt; byte_pos))
 1905         continue;
 1906 
<span class="line-modified"> 1907         /* move stream to first available sample */</span>
<span class="line-modified"> 1908         if (set) {</span>
<span class="line-modified"> 1909           gst_qtdemux_move_stream (qtdemux, str, i);</span>
<span class="line-modified"> 1910           set_sample = TRUE;</span>
<span class="line-modified"> 1911         }</span>
 1912 
 1913       /* avoid index from sparse streams since they might be far away */
 1914       if (!CUR_STREAM (str)-&gt;sparse) {
 1915         /* determine min/max time */
 1916         time = QTSAMPLE_PTS (str, &amp;str-&gt;samples[i]);
 1917         if (min_time == -1 || (!fw &amp;&amp; time &gt; min_time) ||
 1918             (fw &amp;&amp; time &lt; min_time)) {
 1919           min_time = time;
 1920         }
 1921 
 1922         /* determine stream with leading sample, to get its position */
 1923         if (!stream ||
 1924             (fw &amp;&amp; (str-&gt;samples[i].offset &lt; stream-&gt;samples[index].offset)) ||
 1925             (!fw &amp;&amp; (str-&gt;samples[i].offset &gt; stream-&gt;samples[index].offset))) {
 1926           stream = str;
 1927           index = i;
 1928         }
 1929       }
<span class="line-modified"> 1930         break;</span>
<span class="line-modified"> 1931       }</span>
 1932 
 1933     /* no sample for this stream, mark eos */
 1934     if (!set_sample)
 1935       gst_qtdemux_move_stream (qtdemux, str, str-&gt;n_samples);
 1936   }
 1937 
 1938   if (_time)
 1939     *_time = min_time;
 1940   if (_stream)
 1941     *_stream = stream;
 1942   if (_index)
 1943     *_index = index;
 1944 }
 1945 










































 1946 static QtDemuxStream *
<span class="line-modified"> 1947 _create_stream (void)</span>
 1948 {
 1949   QtDemuxStream *stream;

 1950 
 1951   stream = g_new0 (QtDemuxStream, 1);





 1952   /* new streams always need a discont */
 1953   stream-&gt;discont = TRUE;
 1954   /* we enable clipping for raw audio/video streams */
 1955   stream-&gt;need_clip = FALSE;
 1956   stream-&gt;need_process = FALSE;
 1957   stream-&gt;segment_index = -1;
 1958   stream-&gt;time_position = 0;
 1959   stream-&gt;sample_index = -1;
 1960   stream-&gt;offset_in_sample = 0;
 1961   stream-&gt;new_stream = TRUE;
 1962   stream-&gt;multiview_mode = GST_VIDEO_MULTIVIEW_MODE_NONE;
 1963   stream-&gt;multiview_flags = GST_VIDEO_MULTIVIEW_FLAGS_NONE;
 1964   stream-&gt;protected = FALSE;
 1965   stream-&gt;protection_scheme_type = 0;
 1966   stream-&gt;protection_scheme_version = 0;
 1967   stream-&gt;protection_scheme_info = NULL;
 1968   stream-&gt;n_samples_moof = 0;
 1969   stream-&gt;duration_moof = 0;
 1970   stream-&gt;duration_last_moof = 0;
 1971   stream-&gt;alignment = 1;
 1972   stream-&gt;stream_tags = gst_tag_list_new_empty ();
 1973   gst_tag_list_set_scope (stream-&gt;stream_tags, GST_TAG_SCOPE_STREAM);
 1974   g_queue_init (&amp;stream-&gt;protection_scheme_event_queue);



 1975   return stream;
 1976 }
 1977 
 1978 static gboolean
 1979 gst_qtdemux_setcaps (GstQTDemux * demux, GstCaps * caps)
 1980 {
 1981   GstStructure *structure;
 1982   const gchar *variant;
 1983   const GstCaps *mediacaps = NULL;
 1984 
 1985   GST_DEBUG_OBJECT (demux, &quot;Sink set caps: %&quot; GST_PTR_FORMAT, caps);
 1986 
 1987   structure = gst_caps_get_structure (caps, 0);
 1988   variant = gst_structure_get_string (structure, &quot;variant&quot;);
 1989 
 1990   if (variant &amp;&amp; strcmp (variant, &quot;mss-fragmented&quot;) == 0) {
 1991     QtDemuxStream *stream;
 1992     const GValue *value;
 1993 
 1994     demux-&gt;fragmented = TRUE;
 1995     demux-&gt;mss_mode = TRUE;
 1996 
<span class="line-modified"> 1997     if (demux-&gt;n_streams &gt; 1) {</span>
 1998       /* can&#39;t do this, we can only renegotiate for another mss format */
 1999       return FALSE;
 2000     }
 2001 
 2002     value = gst_structure_get_value (structure, &quot;media-caps&quot;);
 2003     /* create stream */
 2004     if (value) {
 2005       const GValue *timescale_v;
 2006 
 2007       /* TODO update when stream changes during playback */
 2008 
<span class="line-modified"> 2009       if (demux-&gt;n_streams == 0) {</span>
<span class="line-modified"> 2010         stream = _create_stream ();</span>
<span class="line-modified"> 2011         demux-&gt;streams[demux-&gt;n_streams] = stream;</span>
<span class="line-removed"> 2012         demux-&gt;n_streams = 1;</span>
 2013         /* mss has no stsd/stsd entry, use id 0 as default */
 2014         stream-&gt;stsd_entries_length = 1;
 2015         stream-&gt;stsd_sample_description_id = stream-&gt;cur_stsd_entry_index = 0;
 2016         stream-&gt;stsd_entries = g_new0 (QtDemuxStreamStsdEntry, 1);
 2017       } else {
<span class="line-modified"> 2018         stream = demux-&gt;streams[0];</span>
 2019       }
 2020 
 2021       timescale_v = gst_structure_get_value (structure, &quot;timescale&quot;);
 2022       if (timescale_v) {
 2023         stream-&gt;timescale = g_value_get_uint64 (timescale_v);
 2024       } else {
 2025         /* default mss timescale */
 2026         stream-&gt;timescale = 10000000;
 2027       }
 2028       demux-&gt;timescale = stream-&gt;timescale;
 2029 
 2030       mediacaps = gst_value_get_caps (value);
 2031       if (!CUR_STREAM (stream)-&gt;caps
 2032           || !gst_caps_is_equal_fixed (mediacaps, CUR_STREAM (stream)-&gt;caps)) {
 2033         GST_DEBUG_OBJECT (demux, &quot;We have a new caps %&quot; GST_PTR_FORMAT,
 2034             mediacaps);
 2035         stream-&gt;new_caps = TRUE;
 2036       }
 2037       gst_caps_replace (&amp;CUR_STREAM (stream)-&gt;caps, (GstCaps *) mediacaps);
 2038       structure = gst_caps_get_structure (mediacaps, 0);
</pre>
<hr />
<pre>
 2047       } else if (g_str_has_prefix (gst_structure_get_name (structure), &quot;audio&quot;)) {
 2048         gint rate = 0;
 2049         stream-&gt;subtype = FOURCC_soun;
 2050         gst_structure_get_int (structure, &quot;channels&quot;,
 2051             &amp;CUR_STREAM (stream)-&gt;n_channels);
 2052         gst_structure_get_int (structure, &quot;rate&quot;, &amp;rate);
 2053         CUR_STREAM (stream)-&gt;rate = rate;
 2054       }
 2055     }
 2056     gst_caps_replace (&amp;demux-&gt;media_caps, (GstCaps *) mediacaps);
 2057   } else {
 2058     demux-&gt;mss_mode = FALSE;
 2059   }
 2060 
 2061   return TRUE;
 2062 }
 2063 
 2064 static void
 2065 gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
 2066 {
<span class="line-modified"> 2067   gint n;</span>
 2068 
 2069   GST_DEBUG_OBJECT (qtdemux, &quot;Resetting demux&quot;);
 2070   gst_pad_stop_task (qtdemux-&gt;sinkpad);
 2071 
 2072   if (hard || qtdemux-&gt;upstream_format_is_time) {
 2073     qtdemux-&gt;state = QTDEMUX_STATE_INITIAL;
 2074     qtdemux-&gt;neededbytes = 16;
 2075     qtdemux-&gt;todrop = 0;
 2076     qtdemux-&gt;pullbased = FALSE;
 2077     qtdemux-&gt;posted_redirect = FALSE;
 2078     qtdemux-&gt;first_mdat = -1;
 2079     qtdemux-&gt;header_size = 0;
 2080     qtdemux-&gt;mdatoffset = -1;
 2081     qtdemux-&gt;restoredata_offset = -1;
 2082     if (qtdemux-&gt;mdatbuffer)
 2083       gst_buffer_unref (qtdemux-&gt;mdatbuffer);
 2084     if (qtdemux-&gt;restoredata_buffer)
 2085       gst_buffer_unref (qtdemux-&gt;restoredata_buffer);
 2086     qtdemux-&gt;mdatbuffer = NULL;
 2087     qtdemux-&gt;restoredata_buffer = NULL;
 2088     qtdemux-&gt;mdatleft = 0;
 2089     qtdemux-&gt;mdatsize = 0;
 2090     if (qtdemux-&gt;comp_brands)
 2091       gst_buffer_unref (qtdemux-&gt;comp_brands);
 2092     qtdemux-&gt;comp_brands = NULL;
 2093     qtdemux-&gt;last_moov_offset = -1;
 2094     if (qtdemux-&gt;moov_node_compressed) {
 2095       g_node_destroy (qtdemux-&gt;moov_node_compressed);
<span class="line-modified"> 2096     if (qtdemux-&gt;moov_node)</span>
 2097         g_free (qtdemux-&gt;moov_node-&gt;data);
 2098     }
 2099     qtdemux-&gt;moov_node_compressed = NULL;
 2100     if (qtdemux-&gt;moov_node)
 2101       g_node_destroy (qtdemux-&gt;moov_node);
 2102     qtdemux-&gt;moov_node = NULL;
 2103     if (qtdemux-&gt;tag_list)
 2104       gst_mini_object_unref (GST_MINI_OBJECT_CAST (qtdemux-&gt;tag_list));
 2105     qtdemux-&gt;tag_list = gst_tag_list_new_empty ();
 2106     gst_tag_list_set_scope (qtdemux-&gt;tag_list, GST_TAG_SCOPE_GLOBAL);
 2107 #if 0
 2108     if (qtdemux-&gt;element_index)
 2109       gst_object_unref (qtdemux-&gt;element_index);
 2110     qtdemux-&gt;element_index = NULL;
 2111 #endif
 2112     qtdemux-&gt;major_brand = 0;
<span class="line-removed"> 2113     if (qtdemux-&gt;pending_newsegment)</span>
<span class="line-removed"> 2114       gst_event_unref (qtdemux-&gt;pending_newsegment);</span>
<span class="line-removed"> 2115     qtdemux-&gt;pending_newsegment = NULL;</span>
 2116     qtdemux-&gt;upstream_format_is_time = FALSE;
 2117     qtdemux-&gt;upstream_seekable = FALSE;
 2118     qtdemux-&gt;upstream_size = 0;
 2119 
 2120     qtdemux-&gt;fragment_start = -1;
 2121     qtdemux-&gt;fragment_start_offset = -1;
 2122     qtdemux-&gt;duration = 0;
 2123     qtdemux-&gt;moof_offset = 0;
 2124     qtdemux-&gt;chapters_track_id = 0;
 2125     qtdemux-&gt;have_group_id = FALSE;
 2126     qtdemux-&gt;group_id = G_MAXUINT;
 2127 
 2128     g_queue_foreach (&amp;qtdemux-&gt;protection_event_queue, (GFunc) gst_event_unref,
 2129         NULL);
 2130     g_queue_clear (&amp;qtdemux-&gt;protection_event_queue);



 2131   }
 2132   qtdemux-&gt;offset = 0;
 2133   gst_adapter_clear (qtdemux-&gt;adapter);
 2134   gst_segment_init (&amp;qtdemux-&gt;segment, GST_FORMAT_TIME);
<span class="line-modified"> 2135   qtdemux-&gt;segment_seqnum = GST_SEQNUM_INVALID;</span>
 2136 
 2137   if (hard) {
<span class="line-modified"> 2138     for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
<span class="line-modified"> 2139       gst_qtdemux_stream_free (qtdemux, qtdemux-&gt;streams[n]);</span>
<span class="line-modified"> 2140       qtdemux-&gt;streams[n] = NULL;</span>
<span class="line-removed"> 2141     }</span>
<span class="line-removed"> 2142     qtdemux-&gt;n_streams = 0;</span>
 2143     qtdemux-&gt;n_video_streams = 0;
 2144     qtdemux-&gt;n_audio_streams = 0;
 2145     qtdemux-&gt;n_sub_streams = 0;
 2146     qtdemux-&gt;exposed = FALSE;
 2147     qtdemux-&gt;fragmented = FALSE;
 2148     qtdemux-&gt;mss_mode = FALSE;
 2149     gst_caps_replace (&amp;qtdemux-&gt;media_caps, NULL);
 2150     qtdemux-&gt;timescale = 0;
 2151     qtdemux-&gt;got_moov = FALSE;



 2152     if (qtdemux-&gt;protection_system_ids) {
 2153       g_ptr_array_free (qtdemux-&gt;protection_system_ids, TRUE);
 2154       qtdemux-&gt;protection_system_ids = NULL;
 2155     }








 2156   } else if (qtdemux-&gt;mss_mode) {
 2157     gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
<span class="line-modified"> 2158     for (n = 0; n &lt; qtdemux-&gt;n_streams; n++)</span>
<span class="line-modified"> 2159       gst_qtdemux_stream_clear (qtdemux, qtdemux-&gt;streams[n]);</span>
 2160   } else {
 2161     gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
<span class="line-modified"> 2162     for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
<span class="line-modified"> 2163       qtdemux-&gt;streams[n]-&gt;sent_eos = FALSE;</span>
<span class="line-modified"> 2164       qtdemux-&gt;streams[n]-&gt;time_position = 0;</span>
<span class="line-modified"> 2165       qtdemux-&gt;streams[n]-&gt;accumulated_base = 0;</span>

 2166     }
<span class="line-removed"> 2167     if (!qtdemux-&gt;pending_newsegment) {</span>
<span class="line-removed"> 2168       qtdemux-&gt;pending_newsegment = gst_event_new_segment (&amp;qtdemux-&gt;segment);</span>
<span class="line-removed"> 2169       if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-removed"> 2170         gst_event_set_seqnum (qtdemux-&gt;pending_newsegment,</span>
<span class="line-removed"> 2171             qtdemux-&gt;segment_seqnum);</span>
 2172   }
 2173 }
<span class="line-removed"> 2174 }</span>
 2175 
 2176 
 2177 /* Maps the @segment to the qt edts internal segments and pushes
 2178  * the correspnding segment event.
 2179  *
 2180  * If it ends up being at a empty segment, a gap will be pushed and the next
 2181  * edts segment will be activated in sequence.
 2182  *
 2183  * To be used in push-mode only */
 2184 static void
 2185 gst_qtdemux_map_and_push_segments (GstQTDemux * qtdemux, GstSegment * segment)
 2186 {
<span class="line-modified"> 2187   gint n, i;</span>
 2188 
<span class="line-modified"> 2189   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
<span class="line-modified"> 2190     QtDemuxStream *stream = qtdemux-&gt;streams[n];</span>
 2191 
 2192     stream-&gt;time_position = segment-&gt;start;
 2193 
 2194     /* in push mode we should be guaranteed that we will have empty segments
 2195      * at the beginning and then one segment after, other scenarios are not
 2196      * supported and are discarded when parsing the edts */
 2197     for (i = 0; i &lt; stream-&gt;n_segments; i++) {
 2198       if (stream-&gt;segments[i].stop_time &gt; segment-&gt;start) {

 2199         gst_qtdemux_activate_segment (qtdemux, stream, i,
 2200             stream-&gt;time_position);
 2201         if (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;segments[i])) {
<span class="line-removed"> 2202           /* push the empty segment and move to the next one */</span>
 2203           gst_qtdemux_send_gap_for_segment (qtdemux, stream, i,
 2204               stream-&gt;time_position);






 2205           continue;
 2206         }
 2207 
 2208         g_assert (i == stream-&gt;n_segments - 1);
 2209       }
 2210     }
 2211   }
 2212 }
 2213 

























 2214 static gboolean
 2215 gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
 2216     GstEvent * event)
 2217 {
 2218   GstQTDemux *demux = GST_QTDEMUX (parent);
 2219   gboolean res = TRUE;
 2220 
 2221   GST_LOG_OBJECT (demux, &quot;handling %s event&quot;, GST_EVENT_TYPE_NAME (event));
 2222 
 2223   switch (GST_EVENT_TYPE (event)) {
 2224     case GST_EVENT_SEGMENT:
 2225     {
 2226       gint64 offset = 0;
 2227       QtDemuxStream *stream;
 2228       gint idx;
 2229       GstSegment segment;
 2230 
 2231       /* some debug output */
 2232       gst_event_copy_segment (event, &amp;segment);
 2233       GST_DEBUG_OBJECT (demux, &quot;received newsegment %&quot; GST_SEGMENT_FORMAT,
 2234           &amp;segment);
 2235 
<span class="line-removed"> 2236       /* erase any previously set segment */</span>
<span class="line-removed"> 2237       gst_event_replace (&amp;demux-&gt;pending_newsegment, NULL);</span>
<span class="line-removed"> 2238 </span>
 2239       if (segment.format == GST_FORMAT_TIME) {
<span class="line-removed"> 2240         GST_DEBUG_OBJECT (demux, &quot;new pending_newsegment&quot;);</span>
<span class="line-removed"> 2241         gst_event_replace (&amp;demux-&gt;pending_newsegment, event);</span>
 2242         demux-&gt;upstream_format_is_time = TRUE;

 2243       } else {
 2244         GST_DEBUG_OBJECT (demux, &quot;Not storing upstream newsegment, &quot;
 2245             &quot;not in time format&quot;);
 2246 
<span class="line-modified"> 2247       /* chain will send initial newsegment after pads have been added */</span>
<span class="line-modified"> 2248       if (demux-&gt;state != QTDEMUX_STATE_MOVIE || !demux-&gt;n_streams) {</span>
<span class="line-modified"> 2249         GST_DEBUG_OBJECT (demux, &quot;still starting, eating event&quot;);</span>
<span class="line-modified"> 2250         goto exit;</span>
<span class="line-modified"> 2251       }</span>
 2252       }
 2253 
 2254       /* check if this matches a time seek we received previously
 2255        * FIXME for backwards compatibility reasons we use the
 2256        * seek_offset here to compare. In the future we might want to
 2257        * change this to use the seqnum as it uniquely should identify
 2258        * the segment that corresponds to the seek. */
 2259       GST_DEBUG_OBJECT (demux, &quot;Stored seek offset: %&quot; G_GINT64_FORMAT
 2260           &quot;, received segment offset %&quot; G_GINT64_FORMAT,
 2261           demux-&gt;seek_offset, segment.start);
 2262       if (segment.format == GST_FORMAT_BYTES
 2263           &amp;&amp; demux-&gt;seek_offset == segment.start) {
 2264         GST_OBJECT_LOCK (demux);
 2265         offset = segment.start;
 2266 
 2267         segment.format = GST_FORMAT_TIME;
 2268         segment.start = demux-&gt;push_seek_start;
 2269         segment.stop = demux-&gt;push_seek_stop;
 2270         GST_DEBUG_OBJECT (demux, &quot;Replaced segment with stored seek &quot;
 2271             &quot;segment %&quot; GST_TIME_FORMAT &quot; - %&quot; GST_TIME_FORMAT,
 2272             GST_TIME_ARGS (segment.start), GST_TIME_ARGS (segment.stop));
<span class="line-modified"> 2273           GST_OBJECT_UNLOCK (demux);</span>
 2274       }
 2275 
 2276       /* we only expect a BYTE segment, e.g. following a seek */
 2277       if (segment.format == GST_FORMAT_BYTES) {
 2278         if (GST_CLOCK_TIME_IS_VALID (segment.start)) {
 2279           offset = segment.start;
 2280 
 2281           gst_qtdemux_find_sample (demux, segment.start, TRUE, FALSE, NULL,
 2282               NULL, (gint64 *) &amp; segment.start);
 2283           if ((gint64) segment.start &lt; 0)
 2284             segment.start = 0;
<span class="line-modified"> 2285           }</span>
 2286         if (GST_CLOCK_TIME_IS_VALID (segment.stop)) {
 2287           gst_qtdemux_find_sample (demux, segment.stop, FALSE, FALSE, NULL,
 2288               NULL, (gint64 *) &amp; segment.stop);
 2289           /* keyframe seeking should already arrange for start &gt;= stop,
 2290            * but make sure in other rare cases */
 2291           segment.stop = MAX (segment.stop, segment.start);
 2292         }
 2293       } else if (segment.format == GST_FORMAT_TIME) {
 2294         /* push all data on the adapter before starting this
 2295          * new segment */
 2296         gst_qtdemux_process_adapter (demux, TRUE);
 2297       } else {
 2298         GST_DEBUG_OBJECT (demux, &quot;unsupported segment format, ignoring&quot;);
 2299         goto exit;
 2300       }
 2301 
 2302       /* We shouldn&#39;t modify upstream driven TIME FORMAT segment */
 2303       if (!demux-&gt;upstream_format_is_time) {
<span class="line-modified"> 2304       /* accept upstream&#39;s notion of segment and distribute along */</span>
<span class="line-modified"> 2305       segment.format = GST_FORMAT_TIME;</span>
<span class="line-modified"> 2306       segment.position = segment.time = segment.start;</span>
<span class="line-modified"> 2307       segment.duration = demux-&gt;segment.duration;</span>
<span class="line-modified"> 2308       segment.base = gst_segment_to_running_time (&amp;demux-&gt;segment,</span>
<span class="line-modified"> 2309           GST_FORMAT_TIME, demux-&gt;segment.position);</span>
 2310       }
 2311 
 2312       gst_segment_copy_into (&amp;segment, &amp;demux-&gt;segment);
 2313       GST_DEBUG_OBJECT (demux, &quot;Pushing newseg %&quot; GST_SEGMENT_FORMAT, &amp;segment);
 2314 
 2315       /* map segment to internal qt segments and push on each stream */
<span class="line-modified"> 2316       if (demux-&gt;n_streams) {</span>
<span class="line-modified"> 2317         if (demux-&gt;fragmented) {</span>
<span class="line-modified"> 2318           GstEvent *segment_event = gst_event_new_segment (&amp;segment);</span>
<span class="line-removed"> 2319 </span>
<span class="line-removed"> 2320           gst_event_replace (&amp;demux-&gt;pending_newsegment, NULL);</span>
<span class="line-removed"> 2321           gst_event_set_seqnum (segment_event, demux-&gt;segment_seqnum);</span>
<span class="line-removed"> 2322       gst_qtdemux_push_event (demux, segment_event);</span>
<span class="line-removed"> 2323         } else {</span>
<span class="line-removed"> 2324           gst_event_replace (&amp;demux-&gt;pending_newsegment, NULL);</span>
<span class="line-removed"> 2325           gst_qtdemux_map_and_push_segments (demux, &amp;segment);</span>
<span class="line-removed"> 2326         }</span>
 2327       }
 2328 
 2329       /* clear leftover in current segment, if any */
 2330       gst_adapter_clear (demux-&gt;adapter);
 2331 
 2332       /* set up streaming thread */
 2333       demux-&gt;offset = offset;
 2334       if (demux-&gt;upstream_format_is_time) {
 2335         GST_DEBUG_OBJECT (demux, &quot;Upstream is driving in time format, &quot;
 2336             &quot;set values to restart reading from a new atom&quot;);
 2337         demux-&gt;neededbytes = 16;
 2338         demux-&gt;todrop = 0;
 2339       } else {
 2340         gst_qtdemux_find_sample (demux, offset, TRUE, TRUE, &amp;stream, &amp;idx,
 2341             NULL);
<span class="line-modified"> 2342       if (stream) {</span>
<span class="line-modified"> 2343         demux-&gt;todrop = stream-&gt;samples[idx].offset - offset;</span>
<span class="line-modified"> 2344         demux-&gt;neededbytes = demux-&gt;todrop + stream-&gt;samples[idx].size;</span>
<span class="line-modified"> 2345       } else {</span>
<span class="line-modified"> 2346         /* set up for EOS */</span>
<span class="line-modified"> 2347         demux-&gt;neededbytes = -1;</span>
<span class="line-modified"> 2348         demux-&gt;todrop = 0;</span>
<span class="line-modified"> 2349       }</span>
 2350       }
 2351     exit:
 2352       gst_event_unref (event);
 2353       res = TRUE;
 2354       goto drop;
 2355     }
 2356     case GST_EVENT_FLUSH_START:
 2357     {
 2358       if (gst_event_get_seqnum (event) == demux-&gt;offset_seek_seqnum) {
 2359         gst_event_unref (event);
 2360         goto drop;
 2361       }
<span class="line-modified"> 2362       break;</span>



 2363     }
 2364     case GST_EVENT_FLUSH_STOP:
 2365     {
 2366       guint64 dur;
 2367 
 2368       dur = demux-&gt;segment.duration;
 2369       gst_qtdemux_reset (demux, FALSE);
 2370       demux-&gt;segment.duration = dur;
 2371 
 2372       if (gst_event_get_seqnum (event) == demux-&gt;offset_seek_seqnum) {
 2373         gst_event_unref (event);
 2374         goto drop;
 2375       }
 2376       break;
 2377     }
 2378     case GST_EVENT_EOS:
 2379       /* If we are in push mode, and get an EOS before we&#39;ve seen any streams,
 2380        * then error out - we have nowhere to send the EOS */
 2381       if (!demux-&gt;pullbased) {
 2382         gint i;
 2383         gboolean has_valid_stream = FALSE;
<span class="line-modified"> 2384         for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified"> 2385           if (demux-&gt;streams[i]-&gt;pad != NULL) {</span>
 2386             has_valid_stream = TRUE;
 2387             break;
 2388           }
 2389         }
 2390         if (!has_valid_stream)
 2391           gst_qtdemux_post_no_playable_stream_error (demux);
 2392         else {
 2393           GST_DEBUG_OBJECT (demux, &quot;Data still available after EOS: %u&quot;,
 2394               (guint) gst_adapter_available (demux-&gt;adapter));
 2395           if (gst_qtdemux_process_adapter (demux, TRUE) != GST_FLOW_OK) {
 2396             res = FALSE;
<span class="line-modified"> 2397       }</span>
 2398         }
 2399       }
 2400       break;
 2401     case GST_EVENT_CAPS:{
 2402       GstCaps *caps = NULL;
 2403 
 2404       gst_event_parse_caps (event, &amp;caps);
 2405       gst_qtdemux_setcaps (demux, caps);
 2406       res = TRUE;
 2407       gst_event_unref (event);
 2408       goto drop;
 2409     }
 2410     case GST_EVENT_PROTECTION:
 2411     {
 2412       const gchar *system_id = NULL;
 2413 
 2414       gst_event_parse_protection (event, &amp;system_id, NULL, NULL);
 2415       GST_DEBUG_OBJECT (demux, &quot;Received protection event for system ID %s&quot;,
 2416           system_id);
 2417       gst_qtdemux_append_protection_system_id (demux, system_id);
 2418       /* save the event for later, for source pads that have not been created */
 2419       g_queue_push_tail (&amp;demux-&gt;protection_event_queue, gst_event_ref (event));
 2420       /* send it to all pads that already exist */
 2421       gst_qtdemux_push_event (demux, event);
 2422       res = TRUE;
 2423       goto drop;
 2424     }
















 2425     default:
 2426       break;
 2427   }
 2428 
 2429   res = gst_pad_event_default (demux-&gt;sinkpad, parent, event) &amp; res;
 2430 
 2431 drop:
 2432   return res;
 2433 }
 2434 








































 2435 #if 0
 2436 static void
 2437 gst_qtdemux_set_index (GstElement * element, GstIndex * index)
 2438 {
 2439   GstQTDemux *demux = GST_QTDEMUX (element);
 2440 
 2441   GST_OBJECT_LOCK (demux);
 2442   if (demux-&gt;element_index)
 2443     gst_object_unref (demux-&gt;element_index);
 2444   if (index) {
 2445     demux-&gt;element_index = gst_object_ref (index);
 2446   } else {
 2447     demux-&gt;element_index = NULL;
 2448   }
 2449   GST_OBJECT_UNLOCK (demux);
 2450   /* object lock might be taken again */
 2451   if (index)
 2452     gst_index_get_writer_id (index, GST_OBJECT (element), &amp;demux-&gt;index_id);
 2453   GST_DEBUG_OBJECT (demux, &quot;Set index %&quot; GST_PTR_FORMAT &quot;for writer id %d&quot;,
 2454       demux-&gt;element_index, demux-&gt;index_id);
</pre>
<hr />
<pre>
 2474 static void
 2475 gst_qtdemux_stbl_free (QtDemuxStream * stream)
 2476 {
 2477   g_free ((gpointer) stream-&gt;stco.data);
 2478   stream-&gt;stco.data = NULL;
 2479   g_free ((gpointer) stream-&gt;stsz.data);
 2480   stream-&gt;stsz.data = NULL;
 2481   g_free ((gpointer) stream-&gt;stsc.data);
 2482   stream-&gt;stsc.data = NULL;
 2483   g_free ((gpointer) stream-&gt;stts.data);
 2484   stream-&gt;stts.data = NULL;
 2485   g_free ((gpointer) stream-&gt;stss.data);
 2486   stream-&gt;stss.data = NULL;
 2487   g_free ((gpointer) stream-&gt;stps.data);
 2488   stream-&gt;stps.data = NULL;
 2489   g_free ((gpointer) stream-&gt;ctts.data);
 2490   stream-&gt;ctts.data = NULL;
 2491 }
 2492 
 2493 static void
<span class="line-modified"> 2494 gst_qtdemux_stream_flush_segments_data (GstQTDemux * qtdemux,</span>
<span class="line-removed"> 2495     QtDemuxStream * stream)</span>
 2496 {
 2497   g_free (stream-&gt;segments);
 2498   stream-&gt;segments = NULL;
 2499   stream-&gt;segment_index = -1;
 2500   stream-&gt;accumulated_base = 0;
 2501 }
 2502 
 2503 static void
<span class="line-modified"> 2504 gst_qtdemux_stream_flush_samples_data (GstQTDemux * qtdemux,</span>
<span class="line-removed"> 2505     QtDemuxStream * stream)</span>
 2506 {
 2507   g_free (stream-&gt;samples);
 2508   stream-&gt;samples = NULL;
 2509   gst_qtdemux_stbl_free (stream);
 2510 
 2511   /* fragments */
 2512   g_free (stream-&gt;ra_entries);
 2513   stream-&gt;ra_entries = NULL;
 2514   stream-&gt;n_ra_entries = 0;
 2515 
 2516   stream-&gt;sample_index = -1;
 2517   stream-&gt;stbl_index = -1;
 2518   stream-&gt;n_samples = 0;
 2519   stream-&gt;time_position = 0;
 2520 
 2521   stream-&gt;n_samples_moof = 0;
 2522   stream-&gt;duration_moof = 0;
 2523   stream-&gt;duration_last_moof = 0;
 2524 }
 2525 
 2526 static void
<span class="line-modified"> 2527 gst_qtdemux_stream_clear (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
 2528 {
 2529   gint i;
 2530   if (stream-&gt;allocator)
 2531     gst_object_unref (stream-&gt;allocator);
 2532   while (stream-&gt;buffers) {
 2533     gst_buffer_unref (GST_BUFFER_CAST (stream-&gt;buffers-&gt;data));
 2534     stream-&gt;buffers = g_slist_delete_link (stream-&gt;buffers, stream-&gt;buffers);
 2535   }
 2536   for (i = 0; i &lt; stream-&gt;stsd_entries_length; i++) {
 2537     QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[i];
 2538     if (entry-&gt;rgb8_palette) {
 2539       gst_memory_unref (entry-&gt;rgb8_palette);
 2540       entry-&gt;rgb8_palette = NULL;
<span class="line-modified"> 2541   }</span>
 2542     entry-&gt;sparse = FALSE;
 2543   }
 2544 
<span class="line-modified"> 2545   gst_tag_list_unref (stream-&gt;stream_tags);</span>


 2546   stream-&gt;stream_tags = gst_tag_list_new_empty ();
 2547   gst_tag_list_set_scope (stream-&gt;stream_tags, GST_TAG_SCOPE_STREAM);
 2548   g_free (stream-&gt;redirect_uri);
 2549   stream-&gt;redirect_uri = NULL;
 2550   stream-&gt;sent_eos = FALSE;
 2551   stream-&gt;protected = FALSE;
 2552   if (stream-&gt;protection_scheme_info) {
 2553     if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
 2554       QtDemuxCencSampleSetInfo *info =
 2555           (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
 2556       if (info-&gt;default_properties)
 2557         gst_structure_free (info-&gt;default_properties);
 2558       if (info-&gt;crypto_info)
 2559         g_ptr_array_free (info-&gt;crypto_info, TRUE);
<span class="line-modified"> 2560 }</span>
 2561     g_free (stream-&gt;protection_scheme_info);
 2562     stream-&gt;protection_scheme_info = NULL;
 2563   }
 2564   stream-&gt;protection_scheme_type = 0;
 2565   stream-&gt;protection_scheme_version = 0;
 2566   g_queue_foreach (&amp;stream-&gt;protection_scheme_event_queue,
 2567       (GFunc) gst_event_unref, NULL);
 2568   g_queue_clear (&amp;stream-&gt;protection_scheme_event_queue);
<span class="line-modified"> 2569   gst_qtdemux_stream_flush_segments_data (qtdemux, stream);</span>
<span class="line-modified"> 2570   gst_qtdemux_stream_flush_samples_data (qtdemux, stream);</span>
 2571 }
 2572 
 2573 static void
<span class="line-modified"> 2574 gst_qtdemux_stream_reset (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
 2575 {
 2576   gint i;
<span class="line-modified"> 2577   gst_qtdemux_stream_clear (qtdemux, stream);</span>
 2578   for (i = 0; i &lt; stream-&gt;stsd_entries_length; i++) {
 2579     QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[i];
 2580     if (entry-&gt;caps) {
 2581       gst_caps_unref (entry-&gt;caps);
 2582       entry-&gt;caps = NULL;
 2583     }
 2584   }
 2585   g_free (stream-&gt;stsd_entries);
 2586   stream-&gt;stsd_entries = NULL;
 2587   stream-&gt;stsd_entries_length = 0;
 2588 }
 2589 
<span class="line-modified"> 2590 </span>
<span class="line-modified"> 2591 static void</span>
<span class="line-removed"> 2592 gst_qtdemux_stream_free (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
 2593 {
<span class="line-modified"> 2594   gst_qtdemux_stream_reset (qtdemux, stream);</span>
<span class="line-modified"> 2595   gst_tag_list_unref (stream-&gt;stream_tags);</span>
<span class="line-modified"> 2596   if (stream-&gt;pad) {</span>
<span class="line-removed"> 2597     gst_element_remove_pad (GST_ELEMENT_CAST (qtdemux), stream-&gt;pad);</span>
<span class="line-removed"> 2598     gst_flow_combiner_remove_pad (qtdemux-&gt;flowcombiner, stream-&gt;pad);</span>
<span class="line-removed"> 2599   }</span>
<span class="line-removed"> 2600   g_free (stream);</span>
 2601 }
 2602 
 2603 static void
<span class="line-modified"> 2604 gst_qtdemux_remove_stream (GstQTDemux * qtdemux, int i)</span>
 2605 {
<span class="line-modified"> 2606   g_assert (i &gt;= 0 &amp;&amp; i &lt; qtdemux-&gt;n_streams &amp;&amp; qtdemux-&gt;streams[i] != NULL);</span>
<span class="line-modified"> 2607 </span>
<span class="line-modified"> 2608   gst_qtdemux_stream_free (qtdemux, qtdemux-&gt;streams[i]);</span>
<span class="line-modified"> 2609   qtdemux-&gt;streams[i] = qtdemux-&gt;streams[qtdemux-&gt;n_streams - 1];</span>
<span class="line-modified"> 2610   qtdemux-&gt;streams[qtdemux-&gt;n_streams - 1] = NULL;</span>
<span class="line-modified"> 2611   qtdemux-&gt;n_streams--;</span>





 2612 }
 2613 
 2614 static GstStateChangeReturn
 2615 gst_qtdemux_change_state (GstElement * element, GstStateChange transition)
 2616 {
 2617   GstQTDemux *qtdemux = GST_QTDEMUX (element);
 2618   GstStateChangeReturn result = GST_STATE_CHANGE_FAILURE;
 2619 
 2620   switch (transition) {
<span class="line-modified"> 2621     case GST_STATE_CHANGE_PAUSED_TO_READY:</span>

 2622       break;
 2623     default:
 2624       break;
 2625   }
 2626 
 2627   result = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
 2628 
 2629   switch (transition) {
 2630     case GST_STATE_CHANGE_PAUSED_TO_READY:{
 2631       gst_qtdemux_reset (qtdemux, TRUE);
 2632       break;
 2633     }
 2634     default:
 2635       break;
 2636   }
 2637 
 2638   return result;
 2639 }
 2640 






















 2641 static void
 2642 qtdemux_parse_ftyp (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
 2643 {
 2644   /* counts as header data */
 2645   qtdemux-&gt;header_size += length;
 2646 
 2647   /* only consider at least a sufficiently complete ftyp atom */
 2648   if (length &gt;= 20) {
 2649     GstBuffer *buf;
 2650 
 2651     qtdemux-&gt;major_brand = QT_FOURCC (buffer + 8);
 2652     GST_DEBUG_OBJECT (qtdemux, &quot;major brand: %&quot; GST_FOURCC_FORMAT,
 2653         GST_FOURCC_ARGS (qtdemux-&gt;major_brand));
 2654     if (qtdemux-&gt;comp_brands)
 2655       gst_buffer_unref (qtdemux-&gt;comp_brands);
 2656     buf = qtdemux-&gt;comp_brands = gst_buffer_new_and_alloc (length - 16);
 2657     gst_buffer_fill (buf, 0, buffer + 16, length - 16);
 2658   }
 2659 }
 2660 
 2661 static void
 2662 qtdemux_handle_xmp_taglist (GstQTDemux * qtdemux, GstTagList * taglist,
 2663     GstTagList * xmptaglist)
 2664 {
 2665   /* Strip out bogus fields */
 2666   if (xmptaglist) {
 2667     if (gst_tag_list_get_scope (taglist) == GST_TAG_SCOPE_GLOBAL) {
 2668       gst_tag_list_remove_tag (xmptaglist, GST_TAG_VIDEO_CODEC);
 2669       gst_tag_list_remove_tag (xmptaglist, GST_TAG_AUDIO_CODEC);
 2670     } else {
 2671       gst_tag_list_remove_tag (xmptaglist, GST_TAG_CONTAINER_FORMAT);
 2672     }
 2673 
 2674     GST_DEBUG_OBJECT (qtdemux, &quot;Found XMP tags %&quot; GST_PTR_FORMAT, xmptaglist);
 2675 
<span class="line-modified"> 2676       /* prioritize native tags using _KEEP mode */</span>
 2677     gst_tag_list_insert (taglist, xmptaglist, GST_TAG_MERGE_KEEP);
 2678     gst_tag_list_unref (xmptaglist);
 2679   }
 2680 }
 2681 
























































 2682 static void
 2683 qtdemux_parse_piff (GstQTDemux * qtdemux, const guint8 * buffer, gint length,
 2684     guint offset)
 2685 {
 2686   GstByteReader br;
 2687   guint8 version;
 2688   guint32 flags = 0;
 2689   guint i;
<span class="line-modified"> 2690   guint8 iv_size = 8;</span>
 2691   QtDemuxStream *stream;
 2692   GstStructure *structure;
 2693   QtDemuxCencSampleSetInfo *ss_info = NULL;
 2694   const gchar *system_id;
 2695   gboolean uses_sub_sample_encryption = FALSE;
 2696   guint32 sample_count;
 2697 
<span class="line-modified"> 2698   if (qtdemux-&gt;n_streams == 0)</span>
 2699     return;
 2700 
<span class="line-modified"> 2701   stream = qtdemux-&gt;streams[0];</span>
 2702 
 2703   structure = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);
 2704   if (!gst_structure_has_name (structure, &quot;application/x-cenc&quot;)) {
 2705     GST_WARNING_OBJECT (qtdemux,
 2706         &quot;Attempting PIFF box parsing on an unencrypted stream.&quot;);
 2707     return;
 2708   }
 2709 
 2710   gst_structure_get (structure, GST_PROTECTION_SYSTEM_ID_CAPS_FIELD,
 2711       G_TYPE_STRING, &amp;system_id, NULL);
 2712   gst_qtdemux_append_protection_system_id (qtdemux, system_id);
 2713 
 2714   stream-&gt;protected = TRUE;
 2715   stream-&gt;protection_scheme_type = FOURCC_cenc;
 2716 
 2717   if (!stream-&gt;protection_scheme_info)
 2718     stream-&gt;protection_scheme_info = g_new0 (QtDemuxCencSampleSetInfo, 1);
 2719 
 2720   ss_info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;





 2721 
<span class="line-modified"> 2722   if (ss_info-&gt;default_properties)</span>
<span class="line-removed"> 2723     gst_structure_free (ss_info-&gt;default_properties);</span>
<span class="line-removed"> 2724 </span>
<span class="line-removed"> 2725   ss_info-&gt;default_properties =</span>
<span class="line-removed"> 2726       gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-removed"> 2727       &quot;iv_size&quot;, G_TYPE_UINT, iv_size, &quot;encrypted&quot;, G_TYPE_BOOLEAN, TRUE, NULL);</span>
 2728 
 2729   if (ss_info-&gt;crypto_info) {
 2730     GST_LOG_OBJECT (qtdemux, &quot;unreffing existing crypto_info&quot;);
 2731     g_ptr_array_free (ss_info-&gt;crypto_info, TRUE);
 2732     ss_info-&gt;crypto_info = NULL;
 2733   }
 2734 
 2735   /* skip UUID */
 2736   gst_byte_reader_init (&amp;br, buffer + offset + 16, length - offset - 16);
 2737 
 2738   if (!gst_byte_reader_get_uint8 (&amp;br, &amp;version)) {
 2739     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s version field&quot;);
 2740     return;
 2741   }
 2742 
 2743   if (!gst_byte_reader_get_uint24_be (&amp;br, &amp;flags)) {
 2744     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s flags field&quot;);
 2745     return;
 2746   }
 2747 
 2748   if ((flags &amp; 0x000001)) {
<span class="line-modified"> 2749     guint32 algorithm_id = 0;</span>
<span class="line-modified"> 2750     const guint8 *kid;</span>
<span class="line-removed"> 2751     GstBuffer *kid_buf;</span>
<span class="line-removed"> 2752     gboolean is_encrypted = TRUE;</span>
<span class="line-removed"> 2753 </span>
<span class="line-removed"> 2754     if (!gst_byte_reader_get_uint24_le (&amp;br, &amp;algorithm_id)) {</span>
<span class="line-removed"> 2755       GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s algorithm ID field&quot;);</span>
<span class="line-removed"> 2756       return;</span>
<span class="line-removed"> 2757     }</span>
<span class="line-removed"> 2758 </span>
<span class="line-removed"> 2759     algorithm_id &gt;&gt;= 8;</span>
<span class="line-removed"> 2760     if (algorithm_id == 0) {</span>
<span class="line-removed"> 2761       is_encrypted = FALSE;</span>
<span class="line-removed"> 2762     } else if (algorithm_id == 1) {</span>
<span class="line-removed"> 2763       /* FIXME: maybe store this in properties? */</span>
<span class="line-removed"> 2764       GST_DEBUG_OBJECT (qtdemux, &quot;AES 128-bits CTR encrypted stream&quot;);</span>
<span class="line-removed"> 2765     } else if (algorithm_id == 2) {</span>
<span class="line-removed"> 2766       /* FIXME: maybe store this in properties? */</span>
<span class="line-removed"> 2767       GST_DEBUG_OBJECT (qtdemux, &quot;AES 128-bits CBC encrypted stream&quot;);</span>
<span class="line-removed"> 2768     }</span>
<span class="line-removed"> 2769 </span>
<span class="line-removed"> 2770     if (!gst_byte_reader_get_uint8 (&amp;br, &amp;iv_size))</span>
<span class="line-removed"> 2771       return;</span>
<span class="line-removed"> 2772 </span>
<span class="line-removed"> 2773     if (!gst_byte_reader_get_data (&amp;br, 16, &amp;kid))</span>
 2774       return;
<span class="line-removed"> 2775 </span>
<span class="line-removed"> 2776     kid_buf = gst_buffer_new_allocate (NULL, 16, NULL);</span>
<span class="line-removed"> 2777     gst_buffer_fill (kid_buf, 0, kid, 16);</span>
<span class="line-removed"> 2778     if (ss_info-&gt;default_properties)</span>
<span class="line-removed"> 2779       gst_structure_free (ss_info-&gt;default_properties);</span>
<span class="line-removed"> 2780     ss_info-&gt;default_properties =</span>
<span class="line-removed"> 2781         gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-removed"> 2782         &quot;iv_size&quot;, G_TYPE_UINT, iv_size,</span>
<span class="line-removed"> 2783         &quot;encrypted&quot;, G_TYPE_BOOLEAN, is_encrypted,</span>
<span class="line-removed"> 2784         &quot;kid&quot;, GST_TYPE_BUFFER, kid_buf, NULL);</span>
<span class="line-removed"> 2785     GST_DEBUG_OBJECT (qtdemux, &quot;default sample properties: &quot;</span>
<span class="line-removed"> 2786         &quot;is_encrypted=%u, iv_size=%u&quot;, is_encrypted, iv_size);</span>
<span class="line-removed"> 2787     gst_buffer_unref (kid_buf);</span>
 2788   } else if ((flags &amp; 0x000002)) {
 2789     uses_sub_sample_encryption = TRUE;
 2790   }
 2791 






 2792   if (!gst_byte_reader_get_uint32_be (&amp;br, &amp;sample_count)) {
 2793     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s sample count field&quot;);
 2794     return;
 2795   }
 2796 
 2797   ss_info-&gt;crypto_info =
 2798       g_ptr_array_new_full (sample_count,
 2799       (GDestroyNotify) qtdemux_gst_structure_free);
 2800 
 2801   for (i = 0; i &lt; sample_count; ++i) {
 2802     GstStructure *properties;
 2803     guint8 *data;
 2804     GstBuffer *buf;
 2805 
 2806     properties = qtdemux_get_cenc_sample_properties (qtdemux, stream, i);
 2807     if (properties == NULL) {
 2808       GST_ERROR_OBJECT (qtdemux, &quot;failed to get properties for sample %u&quot;, i);
 2809       qtdemux-&gt;cenc_aux_sample_count = i;
 2810       return;
 2811     }
 2812 
 2813     if (!gst_byte_reader_dup_data (&amp;br, iv_size, &amp;data)) {
 2814       GST_ERROR_OBJECT (qtdemux, &quot;IV data not present for sample %u&quot;, i);
 2815       gst_structure_free (properties);
 2816       qtdemux-&gt;cenc_aux_sample_count = i;
 2817       return;
 2818     }
 2819     buf = gst_buffer_new_wrapped (data, iv_size);
 2820     gst_structure_set (properties, &quot;iv&quot;, GST_TYPE_BUFFER, buf, NULL);
 2821     gst_buffer_unref (buf);
 2822 
 2823     if (uses_sub_sample_encryption) {
 2824       guint16 n_subsamples;

 2825 
 2826       if (!gst_byte_reader_get_uint16_be (&amp;br, &amp;n_subsamples)
 2827           || n_subsamples == 0) {
 2828         GST_ERROR_OBJECT (qtdemux,
 2829             &quot;failed to get subsample count for sample %u&quot;, i);
 2830         gst_structure_free (properties);
 2831         qtdemux-&gt;cenc_aux_sample_count = i;
 2832         return;
 2833       }
 2834       GST_LOG_OBJECT (qtdemux, &quot;subsample count: %u&quot;, n_subsamples);
 2835       if (!gst_byte_reader_dup_data (&amp;br, n_subsamples * 6, &amp;data)) {
 2836         GST_ERROR_OBJECT (qtdemux, &quot;failed to get subsample data for sample %u&quot;,
 2837             i);
 2838         gst_structure_free (properties);
 2839         qtdemux-&gt;cenc_aux_sample_count = i;
 2840         return;
 2841       }
 2842       buf = gst_buffer_new_wrapped (data, n_subsamples * 6);




 2843       gst_structure_set (properties,
 2844           &quot;subsample_count&quot;, G_TYPE_UINT, n_subsamples,
 2845           &quot;subsamples&quot;, GST_TYPE_BUFFER, buf, NULL);

 2846       gst_buffer_unref (buf);
 2847     } else {
 2848       gst_structure_set (properties, &quot;subsample_count&quot;, G_TYPE_UINT, 0, NULL);
 2849     }
 2850 
 2851     g_ptr_array_add (ss_info-&gt;crypto_info, properties);
 2852   }
 2853 
 2854   qtdemux-&gt;cenc_aux_sample_count = sample_count;
 2855 }
 2856 
 2857 static void
 2858 qtdemux_parse_uuid (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
 2859 {
 2860   static const guint8 xmp_uuid[] = { 0xBE, 0x7A, 0xCF, 0xCB,
 2861     0x97, 0xA9, 0x42, 0xE8,
 2862     0x9C, 0x71, 0x99, 0x94,
 2863     0x91, 0xE3, 0xAF, 0xAC
 2864   };
 2865   static const guint8 playready_uuid[] = {
</pre>
<hr />
<pre>
 3085     prevdur = QTTIME_TO_GSTTIME (qtdemux, qtdemux-&gt;duration);
 3086     GST_DEBUG_OBJECT (qtdemux,
 3087         &quot;Updating total duration to %&quot; GST_TIME_FORMAT &quot; was %&quot; GST_TIME_FORMAT,
 3088         GST_TIME_ARGS (duration), GST_TIME_ARGS (prevdur));
 3089     qtdemux-&gt;duration = movdur;
 3090     GST_DEBUG_OBJECT (qtdemux,
 3091         &quot;qtdemux-&gt;segment.duration: %&quot; GST_TIME_FORMAT &quot; .stop: %&quot;
 3092         GST_TIME_FORMAT, GST_TIME_ARGS (qtdemux-&gt;segment.duration),
 3093         GST_TIME_ARGS (qtdemux-&gt;segment.stop));
 3094     if (qtdemux-&gt;segment.duration == prevdur) {
 3095       /* If the current segment has duration/stop identical to previous duration
 3096        * update them also (because they were set at that point in time with
 3097        * the wrong duration */
 3098       /* We convert the value *from* the timescale version to avoid rounding errors */
 3099       GstClockTime fixeddur = QTTIME_TO_GSTTIME (qtdemux, movdur);
 3100       GST_DEBUG_OBJECT (qtdemux, &quot;Updated segment.duration and segment.stop&quot;);
 3101       qtdemux-&gt;segment.duration = fixeddur;
 3102       qtdemux-&gt;segment.stop = fixeddur;
 3103     }
 3104   }
<span class="line-removed"> 3105   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-removed"> 3106     QtDemuxStream *stream = qtdemux-&gt;streams[i];</span>
<span class="line-removed"> 3107     if (stream) {</span>
<span class="line-removed"> 3108       movdur = GSTTIME_TO_QTSTREAMTIME (stream, duration);</span>
<span class="line-removed"> 3109       if (movdur &gt; stream-&gt;duration) {</span>
<span class="line-removed"> 3110         GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-removed"> 3111             &quot;Updating stream #%d duration to %&quot; GST_TIME_FORMAT, i,</span>
<span class="line-removed"> 3112             GST_TIME_ARGS (duration));</span>
<span class="line-removed"> 3113         stream-&gt;duration = movdur;</span>
<span class="line-removed"> 3114         /* internal duration tracking state has been updated above, so */</span>
<span class="line-removed"> 3115         /* preserve an open-ended dummy segment rather than repeatedly updating</span>
<span class="line-removed"> 3116          * it and spamming downstream accordingly with segment events */</span>
<span class="line-removed"> 3117         if (stream-&gt;dummy_segment &amp;&amp;</span>
<span class="line-removed"> 3118             GST_CLOCK_TIME_IS_VALID (stream-&gt;segments[0].duration)) {</span>
<span class="line-removed"> 3119           /* Update all dummy values to new duration */</span>
<span class="line-removed"> 3120           stream-&gt;segments[0].stop_time = duration;</span>
<span class="line-removed"> 3121           stream-&gt;segments[0].duration = duration;</span>
<span class="line-removed"> 3122           stream-&gt;segments[0].media_stop = duration;</span>
<span class="line-removed"> 3123 </span>
<span class="line-removed"> 3124           /* let downstream know we possibly have a new stop time */</span>
<span class="line-removed"> 3125           if (stream-&gt;segment_index != -1) {</span>
<span class="line-removed"> 3126             GstClockTime pos;</span>
<span class="line-removed"> 3127 </span>
<span class="line-removed"> 3128             if (qtdemux-&gt;segment.rate &gt;= 0) {</span>
<span class="line-removed"> 3129               pos = stream-&gt;segment.start;</span>
<span class="line-removed"> 3130             } else {</span>
<span class="line-removed"> 3131               pos = stream-&gt;segment.stop;</span>
<span class="line-removed"> 3132             }</span>
 3133 
<span class="line-modified"> 3134             gst_qtdemux_stream_update_segment (qtdemux, stream,</span>
<span class="line-modified"> 3135                 stream-&gt;segment_index, pos, NULL, NULL);</span>

























 3136           }



 3137         }
 3138       }
 3139     }
 3140   }
 3141 }
 3142 
 3143 static gboolean
 3144 qtdemux_parse_trun (GstQTDemux * qtdemux, GstByteReader * trun,
 3145     QtDemuxStream * stream, guint32 d_sample_duration, guint32 d_sample_size,
 3146     guint32 d_sample_flags, gint64 moof_offset, gint64 moof_length,
 3147     gint64 * base_offset, gint64 * running_offset, gint64 decode_ts,
 3148     gboolean has_tfdt)
 3149 {
 3150   GstClockTime gst_ts = GST_CLOCK_TIME_NONE;
 3151   guint64 timestamp;
 3152   gint32 data_offset = 0;
 3153   guint32 flags = 0, first_flags = 0, samples_count = 0;
 3154   gint i;
 3155   guint8 *data;
 3156   guint entry_size, dur_offset, size_offset, flags_offset = 0, ct_offset = 0;
 3157   QtDemuxSample *sample;
 3158   gboolean ismv = FALSE;
 3159   gint64 initial_offset;
 3160 
<span class="line-modified"> 3161   GST_LOG_OBJECT (qtdemux, &quot;parsing trun stream %d; &quot;</span>
 3162       &quot;default dur %d, size %d, flags 0x%x, base offset %&quot; G_GINT64_FORMAT &quot;, &quot;
 3163       &quot;decode ts %&quot; G_GINT64_FORMAT, stream-&gt;track_id, d_sample_duration,
 3164       d_sample_size, d_sample_flags, *base_offset, decode_ts);
 3165 
 3166   if (stream-&gt;pending_seek &amp;&amp; moof_offset &lt; stream-&gt;pending_seek-&gt;moof_offset) {
 3167     GST_INFO_OBJECT (stream-&gt;pad, &quot;skipping trun before seek target fragment&quot;);
 3168     return TRUE;
 3169   }
 3170 
 3171   /* presence of stss or not can&#39;t really tell us much,
 3172    * and flags and so on tend to be marginally reliable in these files */
 3173   if (stream-&gt;subtype == FOURCC_soun) {
 3174     GST_DEBUG_OBJECT (qtdemux,
 3175         &quot;sound track in fragmented file; marking all keyframes&quot;);
 3176     stream-&gt;all_keyframe = TRUE;
 3177   }
 3178 
 3179   if (!gst_byte_reader_skip (trun, 1) ||
 3180       !gst_byte_reader_get_uint24_be (trun, &amp;flags))
 3181     goto fail;
</pre>
<hr />
<pre>
 3249     entry_size += 4;
 3250   }
 3251 
 3252   if (!qt_atom_parser_has_chunks (trun, samples_count, entry_size))
 3253     goto fail;
 3254   data = (guint8 *) gst_byte_reader_peek_data_unchecked (trun);
 3255 
 3256   if (stream-&gt;n_samples + samples_count &gt;=
 3257       QTDEMUX_MAX_SAMPLE_INDEX_SIZE / sizeof (QtDemuxSample))
 3258     goto index_too_big;
 3259 
 3260   GST_DEBUG_OBJECT (qtdemux, &quot;allocating n_samples %u * %u (%.2f MB)&quot;,
 3261       stream-&gt;n_samples + samples_count, (guint) sizeof (QtDemuxSample),
 3262       (stream-&gt;n_samples + samples_count) *
 3263       sizeof (QtDemuxSample) / (1024.0 * 1024.0));
 3264 
 3265   /* create a new array of samples if it&#39;s the first sample parsed */
 3266   if (stream-&gt;n_samples == 0) {
 3267     g_assert (stream-&gt;samples == NULL);
 3268     stream-&gt;samples = g_try_new0 (QtDemuxSample, samples_count);
<span class="line-modified"> 3269   /* or try to reallocate it with space enough to insert the new samples */</span>
 3270   } else
 3271     stream-&gt;samples = g_try_renew (QtDemuxSample, stream-&gt;samples,
 3272         stream-&gt;n_samples + samples_count);
 3273   if (stream-&gt;samples == NULL)
 3274     goto out_of_memory;
 3275 
 3276   if (qtdemux-&gt;fragment_start != -1) {
 3277     timestamp = GSTTIME_TO_QTSTREAMTIME (stream, qtdemux-&gt;fragment_start);
 3278     qtdemux-&gt;fragment_start = -1;
 3279   } else {
 3280     if (stream-&gt;n_samples == 0) {
 3281       if (decode_ts &gt; 0) {
 3282         timestamp = decode_ts;
 3283       } else if (stream-&gt;pending_seek != NULL) {
 3284         /* if we don&#39;t have a timestamp from a tfdt box, we&#39;ll use the one
 3285          * from the mfra seek table */
 3286         GST_INFO_OBJECT (stream-&gt;pad, &quot;pending seek ts = %&quot; GST_TIME_FORMAT,
 3287             GST_TIME_ARGS (stream-&gt;pending_seek-&gt;ts));
 3288 
 3289         /* FIXME: this is not fully correct, the timestamp refers to the random
 3290          * access sample refered to in the tfra entry, which may not necessarily
 3291          * be the first sample in the tfrag/trun (but hopefully/usually is) */
 3292         timestamp = GSTTIME_TO_QTSTREAMTIME (stream, stream-&gt;pending_seek-&gt;ts);
 3293       } else {
<span class="line-modified"> 3294     timestamp = 0;</span>
 3295       }
 3296 
 3297       gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
 3298       GST_INFO_OBJECT (stream-&gt;pad, &quot;first sample ts %&quot; GST_TIME_FORMAT,
 3299           GST_TIME_ARGS (gst_ts));
<span class="line-modified"> 3300   } else {</span>
<span class="line-modified"> 3301     /* subsequent fragments extend stream */</span>
<span class="line-modified"> 3302     timestamp =</span>
<span class="line-modified"> 3303         stream-&gt;samples[stream-&gt;n_samples - 1].timestamp +</span>
<span class="line-modified"> 3304         stream-&gt;samples[stream-&gt;n_samples - 1].duration;</span>
 3305 
 3306       /* If this is a GST_FORMAT_BYTES stream and there&#39;s a significant
 3307        * difference (1 sec.) between decode_ts and timestamp, prefer the
 3308        * former */
 3309       if (has_tfdt &amp;&amp; !qtdemux-&gt;upstream_format_is_time
 3310           &amp;&amp; ABSDIFF (decode_ts, timestamp) &gt;
 3311           MAX (stream-&gt;duration_last_moof / 2,
 3312               GSTTIME_TO_QTSTREAMTIME (stream, GST_SECOND))) {
 3313         GST_INFO_OBJECT (qtdemux,
 3314             &quot;decode_ts (%&quot; GST_TIME_FORMAT &quot;) and timestamp (%&quot; GST_TIME_FORMAT
 3315             &quot;) are significantly different (more than %&quot; GST_TIME_FORMAT
 3316             &quot;), using decode_ts&quot;,
 3317             GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, decode_ts)),
 3318             GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, timestamp)),
 3319             GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream,
 3320                     MAX (stream-&gt;duration_last_moof / 2,
 3321                         GSTTIME_TO_QTSTREAMTIME (stream, GST_SECOND)))));
 3322         timestamp = decode_ts;
<span class="line-modified"> 3323   }</span>
 3324 
 3325       gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
 3326       GST_INFO_OBJECT (qtdemux, &quot;first sample ts %&quot; GST_TIME_FORMAT
 3327           &quot; (extends previous samples)&quot;, GST_TIME_ARGS (gst_ts));
<span class="line-modified"> 3328   }</span>
 3329   }
 3330 
 3331   initial_offset = *running_offset;
 3332 
 3333   sample = stream-&gt;samples + stream-&gt;n_samples;
 3334   for (i = 0; i &lt; samples_count; i++) {
 3335     guint32 dur, size, sflags, ct;
 3336 
 3337     /* first read sample data */
 3338     if (flags &amp; TR_SAMPLE_DURATION) {
 3339       dur = QT_UINT32 (data + dur_offset);
 3340     } else {
 3341       dur = d_sample_duration;
 3342     }
 3343     if (flags &amp; TR_SAMPLE_SIZE) {
 3344       size = QT_UINT32 (data + size_offset);
 3345     } else {
 3346       size = d_sample_size;
 3347     }
 3348     if (flags &amp; TR_FIRST_SAMPLE_FLAGS) {
</pre>
<hr />
<pre>
 3414     GST_WARNING_OBJECT (qtdemux, &quot;not allocating index of %d samples, would &quot;
 3415         &quot;be larger than %uMB (broken file?)&quot;, stream-&gt;n_samples,
 3416         QTDEMUX_MAX_SAMPLE_INDEX_SIZE &gt;&gt; 20);
 3417     return FALSE;
 3418   }
 3419 }
 3420 
 3421 /* find stream with @id */
 3422 static inline QtDemuxStream *
 3423 qtdemux_find_stream (GstQTDemux * qtdemux, guint32 id)
 3424 {
 3425   QtDemuxStream *stream;
 3426   gint i;
 3427 
 3428   /* check */
 3429   if (G_UNLIKELY (!id)) {
 3430     GST_DEBUG_OBJECT (qtdemux, &quot;invalid track id 0&quot;);
 3431     return NULL;
 3432   }
 3433 
<span class="line-modified"> 3434   /* try to get it fast and simple */</span>
<span class="line-modified"> 3435   if (G_LIKELY (id &lt;= qtdemux-&gt;n_streams)) {</span>
<span class="line-removed"> 3436     stream = qtdemux-&gt;streams[id - 1];</span>
<span class="line-removed"> 3437     if (G_LIKELY (stream-&gt;track_id == id))</span>
<span class="line-removed"> 3438       return stream;</span>
<span class="line-removed"> 3439   }</span>
<span class="line-removed"> 3440 </span>
<span class="line-removed"> 3441   /* linear search otherwise */</span>
<span class="line-removed"> 3442   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-removed"> 3443     stream = qtdemux-&gt;streams[i];</span>
 3444     if (stream-&gt;track_id == id)
 3445       return stream;
 3446   }
 3447   if (qtdemux-&gt;mss_mode) {
 3448     /* mss should have only 1 stream anyway */
<span class="line-modified"> 3449     return qtdemux-&gt;streams[0];</span>
 3450   }
 3451 
 3452   return NULL;
 3453 }
 3454 
 3455 static gboolean
 3456 qtdemux_parse_mfhd (GstQTDemux * qtdemux, GstByteReader * mfhd,
 3457     guint32 * fragment_number)
 3458 {
 3459   if (!gst_byte_reader_skip (mfhd, 4))
 3460     goto fail;
 3461   if (!gst_byte_reader_get_uint32_be (mfhd, fragment_number))
 3462     goto fail;
 3463   return TRUE;
 3464 fail:
 3465   {
 3466     GST_WARNING_OBJECT (qtdemux, &quot;Failed to parse mfhd atom&quot;);
 3467     return FALSE;
 3468   }
 3469 }
</pre>
<hr />
<pre>
 3863 
 3864   if (G_UNLIKELY (pssh_size &lt; 32U)) {
 3865     GST_ERROR_OBJECT (qtdemux, &quot;invalid box size&quot;);
 3866     return FALSE;
 3867   }
 3868 
 3869   sysid_string =
 3870       qtdemux_uuid_bytes_to_string ((const guint8 *) node-&gt;data + 12);
 3871 
 3872   gst_qtdemux_append_protection_system_id (qtdemux, sysid_string);
 3873 
 3874   pssh = gst_buffer_new_wrapped (g_memdup (node-&gt;data, pssh_size), pssh_size);
 3875   GST_LOG_OBJECT (qtdemux, &quot;cenc pssh size: %&quot; G_GSIZE_FORMAT,
 3876       gst_buffer_get_size (pssh));
 3877 
 3878   parent_box_type = QT_FOURCC ((const guint8 *) node-&gt;parent-&gt;data + 4);
 3879 
 3880   /* Push an event containing the pssh box onto the queues of all streams. */
 3881   event = gst_event_new_protection (sysid_string, pssh,
 3882       (parent_box_type == FOURCC_moov) ? &quot;isobmff/moov&quot; : &quot;isobmff/moof&quot;);
<span class="line-modified"> 3883   for (i = 0; i &lt; qtdemux-&gt;n_streams; ++i) {</span>
<span class="line-modified"> 3884     g_queue_push_tail (&amp;qtdemux-&gt;streams[i]-&gt;protection_scheme_event_queue,</span>




 3885         gst_event_ref (event));
 3886   }
 3887   g_free (sysid_string);
 3888   gst_event_unref (event);
 3889   gst_buffer_unref (pssh);
 3890   return TRUE;
 3891 }
 3892 
 3893 static gboolean
 3894 qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
 3895     guint64 moof_offset, QtDemuxStream * stream)
 3896 {
 3897   GNode *moof_node, *traf_node, *tfhd_node, *trun_node, *tfdt_node, *mfhd_node;
 3898   GNode *uuid_node;
 3899   GstByteReader mfhd_data, trun_data, tfhd_data, tfdt_data;
 3900   GNode *saiz_node, *saio_node, *pssh_node;
 3901   GstByteReader saiz_data, saio_data;
 3902   guint32 ds_size = 0, ds_duration = 0, ds_flags = 0;
 3903   gint64 base_offset, running_offset;
 3904   guint32 frag_num;

 3905 
 3906   /* NOTE @stream ignored */
 3907 
 3908   moof_node = g_node_new ((guint8 *) buffer);
 3909   qtdemux_parse_node (qtdemux, moof_node, buffer, length);
 3910   qtdemux_node_dump (qtdemux, moof_node);
 3911 
 3912   /* Get fragment number from mfhd and check it&#39;s valid */
 3913   mfhd_node =
 3914       qtdemux_tree_get_child_by_type_full (moof_node, FOURCC_mfhd, &amp;mfhd_data);
 3915   if (mfhd_node == NULL)
 3916     goto missing_mfhd;
 3917   if (!qtdemux_parse_mfhd (qtdemux, &amp;mfhd_data, &amp;frag_num))
 3918     goto fail;
 3919   GST_DEBUG_OBJECT (qtdemux, &quot;Fragment #%d&quot;, frag_num);
 3920 
 3921   /* unknown base_offset to start with */
 3922   base_offset = running_offset = -1;
 3923   traf_node = qtdemux_tree_get_child_by_type (moof_node, FOURCC_traf);
 3924   while (traf_node) {
</pre>
<hr />
<pre>
 4005           &quot; (%&quot; GST_TIME_FORMAT &quot;)&quot;, decode_time,
 4006           GST_TIME_ARGS (stream ? QTSTREAMTIME_TO_GSTTIME (stream,
 4007                   decode_time) : GST_CLOCK_TIME_NONE));
 4008 
 4009       /* Discard the fragment buffer timestamp info to avoid using it.
 4010        * Rely on tfdt instead as it is more accurate than the timestamp
 4011        * that is fetched from a manifest/playlist and is usually
 4012        * less accurate. */
 4013       qtdemux-&gt;fragment_start = -1;
 4014     }
 4015 
 4016     if (G_UNLIKELY (!stream)) {
 4017       /* we lost track of offset, we&#39;ll need to regain it,
 4018        * but can delay complaining until later or avoid doing so altogether */
 4019       base_offset = -2;
 4020       goto next;
 4021     }
 4022     if (G_UNLIKELY (base_offset &lt; -1))
 4023       goto lost_offset;
 4024 
<span class="line-modified"> 4025     if (qtdemux-&gt;upstream_format_is_time)</span>
<span class="line-modified"> 4026       gst_qtdemux_stream_flush_samples_data (qtdemux, stream);</span>











 4027 
 4028     /* initialise moof sample data */
 4029     stream-&gt;n_samples_moof = 0;
 4030     stream-&gt;duration_last_moof = stream-&gt;duration_moof;
 4031     stream-&gt;duration_moof = 0;
 4032 
 4033     /* Track Run node */
 4034     trun_node =
 4035         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_trun,
 4036         &amp;trun_data);
 4037     while (trun_node) {
 4038       qtdemux_parse_trun (qtdemux, &amp;trun_data, stream,
 4039           ds_duration, ds_size, ds_flags, moof_offset, length, &amp;base_offset,
 4040           &amp;running_offset, decode_time, (tfdt_node != NULL));
 4041       /* iterate all siblings */
 4042       trun_node = qtdemux_tree_get_sibling_by_type_full (trun_node, FOURCC_trun,
 4043           &amp;trun_data);
 4044     }
 4045 
 4046     uuid_node = qtdemux_tree_get_child_by_type (traf_node, FOURCC_uuid);
</pre>
<hr />
<pre>
 4055      * base is end of current traf */
 4056     base_offset = running_offset;
 4057     running_offset = -1;
 4058 
 4059     if (stream-&gt;n_samples_moof &amp;&amp; stream-&gt;duration_moof)
 4060       stream-&gt;new_caps = TRUE;
 4061 
 4062   next:
 4063     /* iterate all siblings */
 4064     traf_node = qtdemux_tree_get_sibling_by_type (traf_node, FOURCC_traf);
 4065   }
 4066 
 4067   /* parse any protection system info */
 4068   pssh_node = qtdemux_tree_get_child_by_type (moof_node, FOURCC_pssh);
 4069   while (pssh_node) {
 4070     GST_LOG_OBJECT (qtdemux, &quot;Parsing pssh box.&quot;);
 4071     qtdemux_parse_pssh (qtdemux, pssh_node);
 4072     pssh_node = qtdemux_tree_get_sibling_by_type (pssh_node, FOURCC_pssh);
 4073   }
 4074 
































 4075   g_node_destroy (moof_node);
 4076   return TRUE;
 4077 
 4078 missing_tfhd:
 4079   {
 4080     GST_DEBUG_OBJECT (qtdemux, &quot;missing tfhd box&quot;);
 4081     goto fail;
 4082   }
 4083 missing_mfhd:
 4084   {
 4085     GST_DEBUG_OBJECT (qtdemux, &quot;Missing mfhd box&quot;);
 4086     goto fail;
 4087   }
 4088 lost_offset:
 4089   {
 4090     GST_DEBUG_OBJECT (qtdemux, &quot;lost offset&quot;);
 4091     goto fail;
 4092   }
 4093 fail:
 4094   {
</pre>
<hr />
<pre>
 4262     qtdemux_parse_tfra (qtdemux, tfra_node);
 4263     /* iterate all siblings */
 4264     tfra_node = qtdemux_tree_get_sibling_by_type (tfra_node, FOURCC_tfra);
 4265   }
 4266   g_node_destroy (mfra_node);
 4267 
 4268   GST_INFO_OBJECT (qtdemux, &quot;parsed movie fragment random access box (mfra)&quot;);
 4269   ret = TRUE;
 4270 
 4271 exit:
 4272 
 4273   if (mfro) {
 4274     if (mfro_map.memory != NULL)
 4275       gst_buffer_unmap (mfro, &amp;mfro_map);
 4276     gst_buffer_unref (mfro);
 4277   }
 4278   if (mfra) {
 4279     if (mfra_map.memory != NULL)
 4280       gst_buffer_unmap (mfra, &amp;mfra_map);
 4281     gst_buffer_unref (mfra);
<span class="line-modified"> 4282 }</span>
 4283   return ret;
 4284 
 4285 /* ERRORS */
 4286 size_query_failed:
<span class="line-modified"> 4287 {</span>
 4288     GST_WARNING_OBJECT (qtdemux, &quot;could not query upstream size&quot;);
 4289     goto exit;
 4290   }
 4291 invalid_mfro_size:
 4292   {
 4293     GST_WARNING_OBJECT (qtdemux, &quot;mfro size is too small&quot;);
 4294     goto exit;
 4295   }
 4296 invalid_mfra_size:
 4297   {
 4298     GST_WARNING_OBJECT (qtdemux, &quot;mfra_size in mfro box is invalid&quot;);
 4299     goto exit;
 4300   }
 4301 broken_file:
 4302   {
 4303     GST_WARNING_OBJECT (qtdemux, &quot;bogus mfra offset or size, broken file&quot;);
<span class="line-modified"> 4304       goto exit;</span>
<span class="line-removed"> 4305     }</span>
 4306   }

 4307 
 4308 static guint64
 4309 add_offset (guint64 offset, guint64 advance)
 4310 {
 4311   /* Avoid 64-bit overflow by clamping */
 4312   if (offset &gt; G_MAXUINT64 - advance)
 4313     return G_MAXUINT64;
 4314   return offset + advance;
<span class="line-modified"> 4315   }</span>
 4316 
 4317 static GstFlowReturn
 4318 gst_qtdemux_loop_state_header (GstQTDemux * qtdemux)
 4319 {
 4320   guint64 length = 0;
 4321   guint32 fourcc = 0;
 4322   GstBuffer *buf = NULL;
 4323   GstFlowReturn ret = GST_FLOW_OK;
 4324   guint64 cur_offset = qtdemux-&gt;offset;
 4325   GstMapInfo map;
 4326 
 4327   ret = gst_pad_pull_range (qtdemux-&gt;sinkpad, cur_offset, 16, &amp;buf);
 4328   if (G_UNLIKELY (ret != GST_FLOW_OK))
 4329     goto beach;
 4330   gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 4331   if (G_LIKELY (map.size &gt;= 8))
 4332     extract_initial_length_and_fourcc (map.data, map.size, &amp;length, &amp;fourcc);
 4333   gst_buffer_unmap (buf, &amp;map);
 4334   gst_buffer_unref (buf);
 4335 
</pre>
<hr />
<pre>
 4501       GST_LOG_OBJECT (qtdemux,
 4502           &quot;unknown %08x &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39; of size %&quot; G_GUINT64_FORMAT
 4503           &quot; at %&quot; G_GUINT64_FORMAT, fourcc, GST_FOURCC_ARGS (fourcc), length,
 4504           cur_offset);
 4505       ret = gst_qtdemux_pull_atom (qtdemux, cur_offset, length, &amp;unknown);
 4506       if (ret != GST_FLOW_OK)
 4507         goto beach;
 4508       gst_buffer_map (unknown, &amp;map, GST_MAP_READ);
 4509       GST_MEMDUMP (&quot;Unknown tag&quot;, map.data, map.size);
 4510       gst_buffer_unmap (unknown, &amp;map);
 4511       gst_buffer_unref (unknown);
 4512       qtdemux-&gt;offset += length;
 4513       break;
 4514     }
 4515   }
 4516 
 4517 beach:
 4518   if (ret == GST_FLOW_EOS &amp;&amp; (qtdemux-&gt;got_moov || qtdemux-&gt;media_caps)) {
 4519     /* digested all data, show what we have */
 4520     qtdemux_prepare_streams (qtdemux);

 4521     ret = qtdemux_expose_streams (qtdemux);

 4522 
 4523     qtdemux-&gt;state = QTDEMUX_STATE_MOVIE;
 4524     GST_DEBUG_OBJECT (qtdemux, &quot;switching state to STATE_MOVIE (%d)&quot;,
 4525         qtdemux-&gt;state);
 4526     return ret;
 4527   }
 4528   return ret;
 4529 }
 4530 
 4531 /* Seeks to the previous keyframe of the indexed stream and
 4532  * aligns other streams with respect to the keyframe timestamp
 4533  * of indexed stream. Only called in case of Reverse Playback
 4534  */
 4535 static GstFlowReturn
 4536 gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
 4537 {
<span class="line-removed"> 4538   guint8 n = 0;</span>
 4539   guint32 seg_idx = 0, k_index = 0;
 4540   guint32 ref_seg_idx, ref_k_index;
 4541   GstClockTime k_pos = 0, last_stop = 0;
 4542   QtDemuxSegment *seg = NULL;
 4543   QtDemuxStream *ref_str = NULL;
 4544   guint64 seg_media_start_mov;  /* segment media start time in mov format */
 4545   guint64 target_ts;

 4546 
 4547   /* Now we choose an arbitrary stream, get the previous keyframe timestamp
 4548    * and finally align all the other streams on that timestamp with their
 4549    * respective keyframes */
<span class="line-modified"> 4550   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
<span class="line-modified"> 4551     QtDemuxStream *str = qtdemux-&gt;streams[n];</span>
 4552 
 4553     /* No candidate yet, take the first stream */
 4554     if (!ref_str) {
 4555       ref_str = str;
 4556       continue;
 4557     }
 4558 
 4559     /* So that stream has a segment, we prefer video streams */
 4560     if (str-&gt;subtype == FOURCC_vide) {
 4561       ref_str = str;
 4562       break;
 4563     }
 4564   }
 4565 
 4566   if (G_UNLIKELY (!ref_str)) {
 4567     GST_DEBUG_OBJECT (qtdemux, &quot;couldn&#39;t find any stream&quot;);
 4568     goto eos;
 4569   }
 4570 
 4571   if (G_UNLIKELY (!ref_str-&gt;from_sample)) {
</pre>
<hr />
<pre>
 4579   if (ref_str-&gt;subtype == FOURCC_vide) {
 4580     k_index = gst_qtdemux_find_keyframe (qtdemux, ref_str,
 4581         ref_str-&gt;from_sample - 1, FALSE);
 4582   } else {
 4583     if (ref_str-&gt;from_sample &gt;= 10)
 4584       k_index = ref_str-&gt;from_sample - 10;
 4585     else
 4586       k_index = 0;
 4587   }
 4588 
 4589   target_ts =
 4590       ref_str-&gt;samples[k_index].timestamp +
 4591       ref_str-&gt;samples[k_index].pts_offset;
 4592 
 4593   /* get current segment for that stream */
 4594   seg = &amp;ref_str-&gt;segments[ref_str-&gt;segment_index];
 4595   /* Use segment start in original timescale for comparisons */
 4596   seg_media_start_mov = seg-&gt;trak_media_start;
 4597 
 4598   GST_LOG_OBJECT (qtdemux, &quot;keyframe index %u ts %&quot; G_GUINT64_FORMAT
<span class="line-modified"> 4599       &quot; seg start %&quot; G_GUINT64_FORMAT &quot; %&quot; GST_TIME_FORMAT &quot;\n&quot;,</span>
 4600       k_index, target_ts, seg_media_start_mov,
 4601       GST_TIME_ARGS (seg-&gt;media_start));
 4602 
 4603   /* Crawl back through segments to find the one containing this I frame */
 4604   while (target_ts &lt; seg_media_start_mov) {
 4605     GST_DEBUG_OBJECT (qtdemux,
 4606         &quot;keyframe position (sample %u) is out of segment %u &quot; &quot; target %&quot;
 4607         G_GUINT64_FORMAT &quot; seg start %&quot; G_GUINT64_FORMAT, k_index,
 4608         ref_str-&gt;segment_index, target_ts, seg_media_start_mov);
 4609 
 4610     if (G_UNLIKELY (!ref_str-&gt;segment_index)) {
 4611       /* Reached first segment, let&#39;s consider it&#39;s EOS */
 4612       goto eos;
 4613     }
 4614     ref_str-&gt;segment_index--;
 4615     seg = &amp;ref_str-&gt;segments[ref_str-&gt;segment_index];
 4616     /* Use segment start in original timescale for comparisons */
 4617     seg_media_start_mov = seg-&gt;trak_media_start;
 4618   }
 4619   /* Calculate time position of the keyframe and where we should stop */
</pre>
<hr />
<pre>
 4626       seg-&gt;trak_media_start) + seg-&gt;time;
 4627 
 4628   GST_DEBUG_OBJECT (qtdemux, &quot;preferred stream played from sample %u, &quot;
 4629       &quot;now going to sample %u (pts %&quot; GST_TIME_FORMAT &quot;)&quot;, ref_str-&gt;from_sample,
 4630       k_index, GST_TIME_ARGS (k_pos));
 4631 
 4632   /* Set last_stop with the keyframe timestamp we pushed of that stream */
 4633   qtdemux-&gt;segment.position = last_stop;
 4634   GST_DEBUG_OBJECT (qtdemux, &quot;last_stop now is %&quot; GST_TIME_FORMAT,
 4635       GST_TIME_ARGS (last_stop));
 4636 
 4637   if (G_UNLIKELY (last_stop &lt; qtdemux-&gt;segment.start)) {
 4638     GST_DEBUG_OBJECT (qtdemux, &quot;reached the beginning of segment&quot;);
 4639     goto eos;
 4640   }
 4641 
 4642   ref_seg_idx = ref_str-&gt;segment_index;
 4643   ref_k_index = k_index;
 4644 
 4645   /* Align them all on this */
<span class="line-modified"> 4646   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
 4647     guint32 index = 0;
 4648     GstClockTime seg_time = 0;
<span class="line-modified"> 4649     QtDemuxStream *str = qtdemux-&gt;streams[n];</span>
 4650 
 4651     /* aligning reference stream again might lead to backing up to yet another
 4652      * keyframe (due to timestamp rounding issues),
 4653      * potentially putting more load on downstream; so let&#39;s try to avoid */
 4654     if (str == ref_str) {
 4655       seg_idx = ref_seg_idx;
 4656       seg = &amp;str-&gt;segments[seg_idx];
 4657       k_index = ref_k_index;
<span class="line-modified"> 4658       GST_DEBUG_OBJECT (qtdemux, &quot;reference stream %d segment %d, &quot;</span>
<span class="line-modified"> 4659           &quot;sample at index %d&quot;, n, ref_str-&gt;segment_index, k_index);</span>
 4660     } else {
 4661       seg_idx = gst_qtdemux_find_segment (qtdemux, str, k_pos);
 4662       GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified"> 4663           &quot;stream %d align segment %d for keyframe pos %&quot; GST_TIME_FORMAT, n,</span>
<span class="line-modified"> 4664           seg_idx, GST_TIME_ARGS (k_pos));</span>
 4665 
 4666       /* get segment and time in the segment */
 4667       seg = &amp;str-&gt;segments[seg_idx];
 4668       seg_time = k_pos - seg-&gt;time;
 4669 
 4670       /* get the media time in the segment.
 4671        * No adjustment for empty &quot;filler&quot; segments */
 4672       if (seg-&gt;media_start != GST_CLOCK_TIME_NONE)
 4673         seg_time += seg-&gt;media_start;
 4674 
 4675       /* get the index of the sample with media time */
 4676       index = gst_qtdemux_find_index_linear (qtdemux, str, seg_time);
 4677       GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified"> 4678           &quot;stream %d sample for %&quot; GST_TIME_FORMAT &quot; at %u&quot;, n,</span>
 4679           GST_TIME_ARGS (seg_time), index);
 4680 
 4681       /* find previous keyframe */
 4682       k_index = gst_qtdemux_find_keyframe (qtdemux, str, index, FALSE);
 4683     }
 4684 
 4685     /* Remember until where we want to go */
 4686     str-&gt;to_sample = str-&gt;from_sample - 1;
 4687     /* Define our time position */
 4688     target_ts =
 4689         str-&gt;samples[k_index].timestamp + str-&gt;samples[k_index].pts_offset;
 4690     str-&gt;time_position = QTSTREAMTIME_TO_GSTTIME (str, target_ts) + seg-&gt;time;
 4691     if (seg-&gt;media_start != GST_CLOCK_TIME_NONE)
 4692       str-&gt;time_position -= seg-&gt;media_start;
 4693 
 4694     /* Now seek back in time */
 4695     gst_qtdemux_move_stream (qtdemux, str, k_index);
<span class="line-modified"> 4696     GST_DEBUG_OBJECT (qtdemux, &quot;stream %d keyframe at %u, time position %&quot;</span>
<span class="line-modified"> 4697         GST_TIME_FORMAT &quot; playing from sample %u to %u&quot;, n, k_index,</span>
 4698         GST_TIME_ARGS (str-&gt;time_position), str-&gt;from_sample, str-&gt;to_sample);
 4699   }
 4700 
 4701   return GST_FLOW_OK;
 4702 
 4703 eos:
 4704   return GST_FLOW_EOS;
 4705 }
 4706 
 4707 /*
 4708  * Gets the current qt segment start, stop and position for the
 4709  * given time offset. This is used in update_segment()
 4710  */
 4711 static void
 4712 gst_qtdemux_stream_segment_get_boundaries (GstQTDemux * qtdemux,
 4713     QtDemuxStream * stream, GstClockTime offset,
 4714     GstClockTime * _start, GstClockTime * _stop, GstClockTime * _time)
 4715 {
 4716   GstClockTime seg_time;
 4717   GstClockTime start, stop, time;
</pre>
<hr />
<pre>
 4887    * tfra entries tells us which trun/sample the key unit is in, but we don&#39;t
 4888    * make use of this additional information at the moment) */
 4889   if (qtdemux-&gt;fragmented &amp;&amp; !qtdemux-&gt;fragmented_seek_pending) {
 4890     stream-&gt;to_sample = G_MAXUINT32;
 4891     return TRUE;
 4892   } else {
 4893     /* well, it will be taken care of below */
 4894     qtdemux-&gt;fragmented_seek_pending = FALSE;
 4895     /* FIXME ideally the do_fragmented_seek can be done right here,
 4896      * rather than at loop level
 4897      * (which might even allow handling edit lists in a fragmented file) */
 4898   }
 4899 
 4900   /* We don&#39;t need to look for a sample in push-based */
 4901   if (!qtdemux-&gt;pullbased)
 4902     return TRUE;
 4903 
 4904   /* and move to the keyframe before the indicated media time of the
 4905    * segment */
 4906   if (G_LIKELY (!QTSEGMENT_IS_EMPTY (segment))) {
<span class="line-modified"> 4907   if (qtdemux-&gt;segment.rate &gt;= 0) {</span>
<span class="line-modified"> 4908     index = gst_qtdemux_find_index_linear (qtdemux, stream, start);</span>
<span class="line-modified"> 4909     stream-&gt;to_sample = G_MAXUINT32;</span>
 4910       GST_DEBUG_OBJECT (stream-&gt;pad,
 4911           &quot;moving data pointer to %&quot; GST_TIME_FORMAT &quot;, index: %u, pts %&quot;
 4912           GST_TIME_FORMAT, GST_TIME_ARGS (start), index,
 4913           GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[index])));
<span class="line-modified"> 4914   } else {</span>
<span class="line-modified"> 4915     index = gst_qtdemux_find_index_linear (qtdemux, stream, stop);</span>
<span class="line-modified"> 4916     stream-&gt;to_sample = index;</span>
 4917       GST_DEBUG_OBJECT (stream-&gt;pad,
 4918           &quot;moving data pointer to %&quot; GST_TIME_FORMAT &quot;, index: %u, pts %&quot;
 4919           GST_TIME_FORMAT, GST_TIME_ARGS (stop), index,
 4920           GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[index])));
<span class="line-modified"> 4921   }</span>
 4922   } else {
 4923     GST_DEBUG_OBJECT (stream-&gt;pad, &quot;No need to look for keyframe, &quot;
 4924         &quot;this is an empty segment&quot;);
 4925     return TRUE;
 4926   }
 4927 
 4928   /* gst_qtdemux_parse_sample () called from gst_qtdemux_find_index_linear ()
 4929    * encountered an error and printed a message so we return appropriately */
 4930   if (index == -1)
 4931     return FALSE;
 4932 
 4933   /* we&#39;re at the right spot */
 4934   if (index == stream-&gt;sample_index) {
 4935     GST_DEBUG_OBJECT (stream-&gt;pad, &quot;we are at the right index&quot;);
 4936     return TRUE;
 4937   }
 4938 
 4939   /* find keyframe of the target index */
 4940   kf_index = gst_qtdemux_find_keyframe (qtdemux, stream, index, FALSE);
 4941 
</pre>
<hr />
<pre>
 4990   GstClockTime time_position;
 4991   guint32 seg_idx;
 4992 
 4993   g_return_val_if_fail (stream != NULL, FALSE);
 4994 
 4995   time_position = stream-&gt;time_position;
 4996   if (G_UNLIKELY (time_position == GST_CLOCK_TIME_NONE))
 4997     goto eos;
 4998 
 4999   seg_idx = stream-&gt;segment_index;
 5000   if (G_UNLIKELY (seg_idx == -1)) {
 5001     /* find segment corresponding to time_position if we are looking
 5002      * for a segment. */
 5003     seg_idx = gst_qtdemux_find_segment (qtdemux, stream, time_position);
 5004   }
 5005 
 5006   /* different segment, activate it, sample_index will be set. */
 5007   if (G_UNLIKELY (stream-&gt;segment_index != seg_idx))
 5008     gst_qtdemux_activate_segment (qtdemux, stream, seg_idx, time_position);
 5009 
<span class="line-modified"> 5010   if (G_UNLIKELY (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;segments[stream-&gt;</span>
<span class="line-modified"> 5011                   segment_index]))) {</span>
 5012     QtDemuxSegment *seg = &amp;stream-&gt;segments[stream-&gt;segment_index];
 5013 
 5014     GST_LOG_OBJECT (qtdemux, &quot;Empty segment activated,&quot;
 5015         &quot; prepare empty sample&quot;);
 5016 
 5017     *empty = TRUE;
 5018     *pts = *dts = time_position;
 5019     *duration = seg-&gt;duration - (time_position - seg-&gt;time);
 5020 
 5021     return TRUE;
 5022   }
 5023 
 5024   *empty = FALSE;
 5025 
 5026   if (stream-&gt;sample_index == -1)
 5027     stream-&gt;sample_index = 0;
 5028 
 5029   GST_LOG_OBJECT (qtdemux, &quot;segment active, index = %u of %u&quot;,
 5030       stream-&gt;sample_index, stream-&gt;n_samples);
 5031 
 5032   if (G_UNLIKELY (stream-&gt;sample_index &gt;= stream-&gt;n_samples)) {
 5033     if (!qtdemux-&gt;fragmented)
<span class="line-modified"> 5034     goto eos;</span>
 5035 
 5036     GST_INFO_OBJECT (qtdemux, &quot;out of samples, trying to add more&quot;);
 5037     do {
 5038       GstFlowReturn flow;
 5039 
 5040       GST_OBJECT_LOCK (qtdemux);
 5041       flow = qtdemux_add_fragmented_samples (qtdemux);
 5042       GST_OBJECT_UNLOCK (qtdemux);
 5043 
 5044       if (flow != GST_FLOW_OK)
 5045         goto eos;
 5046     }
 5047     while (stream-&gt;sample_index &gt;= stream-&gt;n_samples);
 5048   }
 5049 
 5050   if (!qtdemux_parse_samples (qtdemux, stream, stream-&gt;sample_index)) {
 5051     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;,
 5052         stream-&gt;sample_index);
 5053     return FALSE;
 5054   }
</pre>
<hr />
<pre>
 5145       /* else we&#39;re only at the end of the current segment */
 5146       stream-&gt;time_position = segment-&gt;stop_time;
 5147     }
 5148     /* make sure we select a new segment */
 5149 
 5150     /* accumulate previous segments */
 5151     if (GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.stop))
 5152       stream-&gt;accumulated_base +=
 5153           (stream-&gt;segment.stop -
 5154           stream-&gt;segment.start) / ABS (stream-&gt;segment.rate);
 5155 
 5156     stream-&gt;segment_index = -1;
 5157   }
 5158 }
 5159 
 5160 static void
 5161 gst_qtdemux_sync_streams (GstQTDemux * demux)
 5162 {
 5163   gint i;
 5164 
<span class="line-modified"> 5165   if (demux-&gt;n_streams &lt;= 1)</span>
 5166     return;
 5167 
<span class="line-modified"> 5168   for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
 5169     QtDemuxStream *stream;
 5170     GstClockTime end_time;
 5171 
<span class="line-modified"> 5172     stream = demux-&gt;streams[i];</span>
 5173 
 5174     if (!stream-&gt;pad)
 5175       continue;
 5176 
 5177     /* TODO advance time on subtitle streams here, if any some day */
 5178 
 5179     /* some clips/trailers may have unbalanced streams at the end,
 5180      * so send EOS on shorter stream to prevent stalling others */
 5181 
 5182     /* do not mess with EOS if SEGMENT seeking */
 5183     if (demux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT)
 5184       continue;
 5185 
 5186     if (demux-&gt;pullbased) {
 5187       /* loop mode is sample time based */
 5188       if (!STREAM_IS_EOS (stream))
 5189         continue;
 5190     } else {
 5191       /* push mode is byte position based */
 5192       if (stream-&gt;n_samples &amp;&amp;
</pre>
<hr />
<pre>
 5215       gst_pad_push_event (stream-&gt;pad, event);
 5216     }
 5217   }
 5218 }
 5219 
 5220 /* EOS and NOT_LINKED need to be combined. This means that we return:
 5221  *
 5222  *  GST_FLOW_NOT_LINKED: when all pads NOT_LINKED.
 5223  *  GST_FLOW_EOS: when all pads EOS or NOT_LINKED.
 5224  */
 5225 static GstFlowReturn
 5226 gst_qtdemux_combine_flows (GstQTDemux * demux, QtDemuxStream * stream,
 5227     GstFlowReturn ret)
 5228 {
 5229   GST_LOG_OBJECT (demux, &quot;flow return: %s&quot;, gst_flow_get_name (ret));
 5230 
 5231   if (stream-&gt;pad)
 5232     ret = gst_flow_combiner_update_pad_flow (demux-&gt;flowcombiner, stream-&gt;pad,
 5233         ret);
 5234   else
<span class="line-modified"> 5235   ret = gst_flow_combiner_update_flow (demux-&gt;flowcombiner, ret);</span>
 5236 
 5237   GST_LOG_OBJECT (demux, &quot;combined flow return: %s&quot;, gst_flow_get_name (ret));
 5238   return ret;
 5239 }
 5240 
 5241 /* the input buffer metadata must be writable. Returns NULL when the buffer is
 5242  * completely clipped
 5243  *
 5244  * Should be used only with raw buffers */
 5245 static GstBuffer *
 5246 gst_qtdemux_clip_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
 5247     GstBuffer * buf)
 5248 {
 5249   guint64 start, stop, cstart, cstop, diff;
 5250   GstClockTime pts, duration;
 5251   gsize size, osize;
 5252   gint num_rate, denom_rate;
 5253   gint frame_size;
 5254   gboolean clip_data;
 5255   guint offset;
</pre>
<hr />
<pre>
 5262     frame_size = CUR_STREAM (stream)-&gt;bytes_per_frame;
 5263     num_rate = GST_SECOND;
 5264     denom_rate = (gint) CUR_STREAM (stream)-&gt;rate;
 5265     clip_data = TRUE;
 5266   } else if (stream-&gt;subtype == FOURCC_vide) {
 5267     frame_size = size;
 5268     num_rate = CUR_STREAM (stream)-&gt;fps_n;
 5269     denom_rate = CUR_STREAM (stream)-&gt;fps_d;
 5270     clip_data = FALSE;
 5271   } else
 5272     goto wrong_type;
 5273 
 5274   if (frame_size &lt;= 0)
 5275     goto bad_frame_size;
 5276 
 5277   /* we can only clip if we have a valid pts */
 5278   pts = GST_BUFFER_PTS (buf);
 5279   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pts)))
 5280     goto no_pts;
 5281 
<span class="line-modified"> 5282     duration = GST_BUFFER_DURATION (buf);</span>
 5283 
 5284   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (duration))) {
 5285     duration =
 5286         gst_util_uint64_scale_int (size / frame_size, num_rate, denom_rate);
 5287   }
 5288 
 5289   start = pts;
 5290   stop = start + duration;
 5291 
 5292   if (G_UNLIKELY (!gst_segment_clip (&amp;stream-&gt;segment,
 5293               GST_FORMAT_TIME, start, stop, &amp;cstart, &amp;cstop)))
 5294     goto clipped;
 5295 
 5296   /* see if some clipping happened */
 5297   diff = cstart - start;
 5298   if (diff &gt; 0) {
 5299     pts += diff;
 5300     duration -= diff;
 5301 
 5302     if (clip_data) {
</pre>
<hr />
<pre>
 5381         gst_buffer_get_size (buffer), &amp;params);
 5382 
 5383     /* Copy data &quot;by hand&quot;, so ensure alignment is kept: */
 5384     gst_buffer_fill (new_buffer, 0, map.data, map.size);
 5385 
 5386     gst_buffer_copy_into (new_buffer, buffer, GST_BUFFER_COPY_METADATA, 0, -1);
 5387     GST_DEBUG_OBJECT (demux,
 5388         &quot;We want output aligned on %&quot; G_GSIZE_FORMAT &quot;, reallocated&quot;,
 5389         alignment);
 5390 
 5391     gst_buffer_unmap (buffer, &amp;map);
 5392     gst_buffer_unref (buffer);
 5393 
 5394     return new_buffer;
 5395   }
 5396 
 5397   gst_buffer_unmap (buffer, &amp;map);
 5398   return buffer;
 5399 }
 5400 































































































































 5401 /* the input buffer metadata must be writable,
 5402  * but time/duration etc not yet set and need not be preserved */
 5403 static GstBuffer *
 5404 gst_qtdemux_process_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
 5405     GstBuffer * buf)
 5406 {
 5407   GstMapInfo map;
 5408   guint nsize = 0;
 5409   gchar *str;
 5410 
 5411   /* not many cases for now */
 5412   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;fourcc == FOURCC_mp4s)) {
 5413     /* send a one time dvd clut event */
 5414     if (stream-&gt;pending_event &amp;&amp; stream-&gt;pad)
 5415       gst_pad_push_event (stream-&gt;pad, stream-&gt;pending_event);
 5416     stream-&gt;pending_event = NULL;
 5417   }
 5418 
 5419   if (G_UNLIKELY (stream-&gt;subtype != FOURCC_text
 5420           &amp;&amp; stream-&gt;subtype != FOURCC_sbtl &amp;&amp;
<span class="line-modified"> 5421           stream-&gt;subtype != FOURCC_subp)) {</span>
 5422     return buf;
 5423   }
 5424 
 5425   gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 5426 
 5427   /* empty buffer is sent to terminate previous subtitle */
 5428   if (map.size &lt;= 2) {
 5429     gst_buffer_unmap (buf, &amp;map);
 5430     gst_buffer_unref (buf);
 5431     return NULL;
 5432   }
 5433   if (stream-&gt;subtype == FOURCC_subp) {
 5434     /* That&#39;s all the processing needed for subpictures */
 5435     gst_buffer_unmap (buf, &amp;map);
 5436     return buf;
 5437   }
 5438 

















 5439   nsize = GST_READ_UINT16_BE (map.data);
 5440   nsize = MIN (nsize, map.size - 2);
 5441 
 5442   GST_LOG_OBJECT (qtdemux, &quot;3GPP timed text subtitle: %d/%&quot; G_GSIZE_FORMAT &quot;&quot;,
 5443       nsize, map.size);
 5444 
 5445   /* takes care of UTF-8 validation or UTF-16 recognition,
 5446    * no other encoding expected */
 5447   str = gst_tag_freeform_string_to_utf8 ((gchar *) map.data + 2, nsize, NULL);
 5448   gst_buffer_unmap (buf, &amp;map);
 5449   if (str) {
 5450     gst_buffer_unref (buf);
 5451     buf = _gst_buffer_new_wrapped (str, strlen (str), g_free);
 5452   } else {
 5453     /* this should not really happen unless the subtitle is corrupted */
 5454     gst_buffer_unref (buf);
 5455     buf = NULL;
 5456   }
 5457 
 5458   /* FIXME ? convert optional subsequent style info to markup */
 5459 
 5460   return buf;
 5461 }
 5462 












































































































































































































 5463 /* Sets a buffer&#39;s attributes properly and pushes it downstream.
 5464  * Also checks for additional actions and custom processing that may
 5465  * need to be done first.
 5466  */
 5467 static GstFlowReturn
 5468 gst_qtdemux_decorate_and_push_buffer (GstQTDemux * qtdemux,
 5469     QtDemuxStream * stream, GstBuffer * buf,
 5470     GstClockTime dts, GstClockTime pts, GstClockTime duration,
 5471     gboolean keyframe, GstClockTime position, guint64 byte_position)
 5472 {
 5473   GstFlowReturn ret = GST_FLOW_OK;
 5474 
 5475   /* offset the timestamps according to the edit list */
 5476 
 5477   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;fourcc == FOURCC_rtsp)) {
 5478     gchar *url;
 5479     GstMapInfo map;
 5480 
 5481     gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 5482     url = g_strndup ((gchar *) map.data, map.size);
</pre>
<hr />
<pre>
 5525 
 5526     stream-&gt;buffers = g_slist_delete_link (stream-&gt;buffers, stream-&gt;buffers);
 5527   }
 5528 
 5529   /* we&#39;re going to modify the metadata */
 5530   buf = gst_buffer_make_writable (buf);
 5531 
 5532   if (G_UNLIKELY (stream-&gt;need_process))
 5533     buf = gst_qtdemux_process_buffer (qtdemux, stream, buf);
 5534 
 5535   if (!buf) {
 5536     goto exit;
 5537   }
 5538 
 5539   GST_BUFFER_DTS (buf) = dts;
 5540   GST_BUFFER_PTS (buf) = pts;
 5541   GST_BUFFER_DURATION (buf) = duration;
 5542   GST_BUFFER_OFFSET (buf) = -1;
 5543   GST_BUFFER_OFFSET_END (buf) = -1;
 5544 







 5545   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;rgb8_palette))
 5546     gst_buffer_append_memory (buf,
 5547         gst_memory_ref (CUR_STREAM (stream)-&gt;rgb8_palette));
 5548 
 5549   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;padding)) {
 5550     gst_buffer_resize (buf, CUR_STREAM (stream)-&gt;padding, -1);
 5551   }
 5552 #if 0
 5553   if (G_UNLIKELY (qtdemux-&gt;element_index)) {
 5554     GstClockTime stream_time;
 5555 
 5556     stream_time =
 5557         gst_segment_to_stream_time (&amp;stream-&gt;segment, GST_FORMAT_TIME,
 5558         timestamp);
 5559     if (GST_CLOCK_TIME_IS_VALID (stream_time)) {
 5560       GST_LOG_OBJECT (qtdemux,
 5561           &quot;adding association %&quot; GST_TIME_FORMAT &quot;-&gt; %&quot;
 5562           G_GUINT64_FORMAT, GST_TIME_ARGS (stream_time), byte_position);
 5563       gst_index_add_association (qtdemux-&gt;element_index,
 5564           qtdemux-&gt;index_id,
 5565           keyframe ? GST_ASSOCIATION_FLAG_KEY_UNIT :
 5566           GST_ASSOCIATION_FLAG_DELTA_UNIT, GST_FORMAT_TIME, stream_time,
 5567           GST_FORMAT_BYTES, byte_position, NULL);
 5568     }
 5569   }
 5570 #endif
 5571 
<span class="line-modified"> 5572   if (stream-&gt;need_clip)</span>
<span class="line-removed"> 5573     buf = gst_qtdemux_clip_buffer (qtdemux, stream, buf);</span>
<span class="line-removed"> 5574 </span>
<span class="line-removed"> 5575   if (G_UNLIKELY (buf == NULL))</span>
<span class="line-removed"> 5576     goto exit;</span>
<span class="line-removed"> 5577 </span>
<span class="line-removed"> 5578   if (G_UNLIKELY (stream-&gt;discont)) {</span>
<span class="line-removed"> 5579     GST_LOG_OBJECT (qtdemux, &quot;marking discont buffer&quot;);</span>
<span class="line-removed"> 5580     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-removed"> 5581     stream-&gt;discont = FALSE;</span>
<span class="line-removed"> 5582   } else {</span>
<span class="line-removed"> 5583     GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-removed"> 5584   }</span>
<span class="line-removed"> 5585 </span>
<span class="line-removed"> 5586   if (!keyframe) {</span>
<span class="line-removed"> 5587     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);</span>
<span class="line-removed"> 5588     stream-&gt;on_keyframe = FALSE;</span>
<span class="line-removed"> 5589   } else {</span>
<span class="line-removed"> 5590     stream-&gt;on_keyframe = TRUE;</span>
<span class="line-removed"> 5591   }</span>
<span class="line-removed"> 5592 </span>
<span class="line-removed"> 5593 </span>
<span class="line-removed"> 5594   GST_LOG_OBJECT (qtdemux,</span>
<span class="line-removed"> 5595       &quot;Pushing buffer with dts %&quot; GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT</span>
<span class="line-removed"> 5596       &quot;, duration %&quot; GST_TIME_FORMAT &quot; on pad %s&quot;, GST_TIME_ARGS (dts),</span>
<span class="line-removed"> 5597       GST_TIME_ARGS (pts), GST_TIME_ARGS (duration),</span>
<span class="line-removed"> 5598       GST_PAD_NAME (stream-&gt;pad));</span>
<span class="line-removed"> 5599 </span>
<span class="line-removed"> 5600   if (stream-&gt;protected &amp;&amp; stream-&gt;protection_scheme_type == FOURCC_cenc) {</span>
<span class="line-removed"> 5601     GstStructure *crypto_info;</span>
<span class="line-removed"> 5602     QtDemuxCencSampleSetInfo *info =</span>
<span class="line-removed"> 5603         (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;</span>
<span class="line-removed"> 5604     gint index;</span>
<span class="line-removed"> 5605     GstEvent *event;</span>
<span class="line-removed"> 5606 </span>
<span class="line-removed"> 5607     while ((event = g_queue_pop_head (&amp;stream-&gt;protection_scheme_event_queue))) {</span>
<span class="line-removed"> 5608       gst_pad_push_event (stream-&gt;pad, event);</span>
<span class="line-removed"> 5609     }</span>
<span class="line-removed"> 5610 </span>
<span class="line-removed"> 5611     if (info-&gt;crypto_info == NULL) {</span>
<span class="line-removed"> 5612       GST_DEBUG_OBJECT (qtdemux, &quot;cenc metadata hasn&#39;t been parsed yet&quot;);</span>
<span class="line-removed"> 5613       gst_buffer_unref (buf);</span>
<span class="line-removed"> 5614       goto exit;</span>
<span class="line-removed"> 5615     }</span>
<span class="line-removed"> 5616 </span>
<span class="line-removed"> 5617     /* The end of the crypto_info array matches our n_samples position,</span>
<span class="line-removed"> 5618      * so count backward from there */</span>
<span class="line-removed"> 5619     index = stream-&gt;sample_index - stream-&gt;n_samples + info-&gt;crypto_info-&gt;len;</span>
<span class="line-removed"> 5620     if (G_LIKELY (index &gt;= 0 &amp;&amp; index &lt; info-&gt;crypto_info-&gt;len)) {</span>
<span class="line-removed"> 5621       /* steal structure from array */</span>
<span class="line-removed"> 5622       crypto_info = g_ptr_array_index (info-&gt;crypto_info, index);</span>
<span class="line-removed"> 5623       g_ptr_array_index (info-&gt;crypto_info, index) = NULL;</span>
<span class="line-removed"> 5624       GST_LOG_OBJECT (qtdemux, &quot;attaching cenc metadata [%u/%u]&quot;, index,</span>
<span class="line-removed"> 5625           info-&gt;crypto_info-&gt;len);</span>
<span class="line-removed"> 5626       if (!crypto_info || !gst_buffer_add_protection_meta (buf, crypto_info))</span>
<span class="line-removed"> 5627         GST_ERROR_OBJECT (qtdemux, &quot;failed to attach cenc metadata to buffer&quot;);</span>
<span class="line-removed"> 5628     } else {</span>
<span class="line-removed"> 5629       GST_INFO_OBJECT (qtdemux, &quot;No crypto info with index %d and sample %d&quot;,</span>
<span class="line-removed"> 5630           index, stream-&gt;sample_index);</span>
<span class="line-removed"> 5631     }</span>
<span class="line-removed"> 5632   }</span>
<span class="line-removed"> 5633 </span>
<span class="line-removed"> 5634   if (stream-&gt;alignment &gt; 1)</span>
<span class="line-removed"> 5635     buf = gst_qtdemux_align_buffer (qtdemux, buf, stream-&gt;alignment);</span>
<span class="line-removed"> 5636 </span>
<span class="line-removed"> 5637   ret = gst_pad_push (stream-&gt;pad, buf);</span>
<span class="line-removed"> 5638 </span>
<span class="line-removed"> 5639   if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; GST_CLOCK_TIME_IS_VALID (duration)) {</span>
<span class="line-removed"> 5640     /* mark position in stream, we&#39;ll need this to know when to send GAP event */</span>
<span class="line-removed"> 5641     stream-&gt;segment.position = pts + duration;</span>
<span class="line-removed"> 5642   }</span>
 5643 
 5644 exit:
 5645   return ret;
 5646 }
 5647 
 5648 static const QtDemuxRandomAccessEntry *
 5649 gst_qtdemux_stream_seek_fragment (GstQTDemux * qtdemux, QtDemuxStream * stream,
 5650     GstClockTime pos, gboolean after)
 5651 {
 5652   QtDemuxRandomAccessEntry *entries = stream-&gt;ra_entries;
 5653   guint n_entries = stream-&gt;n_ra_entries;
 5654   guint i;
 5655 
 5656   /* we assume the table is sorted */
 5657   for (i = 0; i &lt; n_entries; ++i) {
 5658     if (entries[i].ts &gt; pos)
 5659       break;
 5660   }
 5661 
 5662   /* FIXME: maybe save first moof_offset somewhere instead, but for now it&#39;s
 5663    * probably okay to assume that the index lists the very first fragment */
 5664   if (i == 0)
 5665     return &amp;entries[0];
 5666 
 5667   if (after)
 5668     return &amp;entries[i];
 5669   else
 5670     return &amp;entries[i - 1];
 5671 }
 5672 
 5673 static gboolean
 5674 gst_qtdemux_do_fragmented_seek (GstQTDemux * qtdemux)
 5675 {
 5676   const QtDemuxRandomAccessEntry *best_entry = NULL;
<span class="line-modified"> 5677   guint i;</span>
 5678 
 5679   GST_OBJECT_LOCK (qtdemux);
 5680 
<span class="line-modified"> 5681   g_assert (qtdemux-&gt;n_streams &gt; 0);</span>
 5682 
 5683   /* first see if we can determine where to go to using mfra,
 5684    * before we start clearing things */
<span class="line-modified"> 5685   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
 5686     const QtDemuxRandomAccessEntry *entry;
 5687     QtDemuxStream *stream;
 5688     gboolean is_audio_or_video;
 5689 
<span class="line-modified"> 5690     stream = qtdemux-&gt;streams[i];</span>
 5691 
 5692     if (stream-&gt;ra_entries == NULL)
 5693       continue;
 5694 
 5695     if (stream-&gt;subtype == FOURCC_vide || stream-&gt;subtype == FOURCC_soun)
 5696       is_audio_or_video = TRUE;
 5697     else
 5698       is_audio_or_video = FALSE;
 5699 
 5700     entry =
 5701         gst_qtdemux_stream_seek_fragment (qtdemux, stream,
 5702         stream-&gt;time_position, !is_audio_or_video);
 5703 
 5704     GST_INFO_OBJECT (stream-&gt;pad, &quot;%&quot; GST_TIME_FORMAT &quot; at offset &quot;
 5705         &quot;%&quot; G_GUINT64_FORMAT, GST_TIME_ARGS (entry-&gt;ts), entry-&gt;moof_offset);
 5706 
 5707     stream-&gt;pending_seek = entry;
 5708 
 5709     /* decide position to jump to just based on audio/video tracks, not subs */
 5710     if (!is_audio_or_video)
 5711       continue;
 5712 
 5713     if (best_entry == NULL || entry-&gt;moof_offset &lt; best_entry-&gt;moof_offset)
 5714       best_entry = entry;
 5715   }
 5716 
 5717   /* no luck, will handle seek otherwise */
 5718   if (best_entry == NULL) {
 5719     GST_OBJECT_UNLOCK (qtdemux);
 5720     return FALSE;
 5721   }
 5722 
 5723   /* ok, now we can prepare for processing as of located moof */
<span class="line-modified"> 5724   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
 5725     QtDemuxStream *stream;
 5726 
<span class="line-modified"> 5727     stream = qtdemux-&gt;streams[i];</span>
 5728 
 5729     g_free (stream-&gt;samples);
 5730     stream-&gt;samples = NULL;
 5731     stream-&gt;n_samples = 0;
 5732     stream-&gt;stbl_index = -1;    /* no samples have yet been parsed */
 5733     stream-&gt;sample_index = -1;
 5734 
 5735     if (stream-&gt;protection_scheme_info) {
 5736       /* Clear out any old cenc crypto info entries as we&#39;ll move to a new moof */
 5737       if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
 5738         QtDemuxCencSampleSetInfo *info =
 5739             (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
 5740         if (info-&gt;crypto_info) {
 5741           g_ptr_array_free (info-&gt;crypto_info, TRUE);
 5742           info-&gt;crypto_info = NULL;
 5743         }
 5744       }
 5745     }
 5746   }
 5747 
 5748   GST_INFO_OBJECT (qtdemux, &quot;seek to %&quot; GST_TIME_FORMAT &quot;, best fragment &quot;
 5749       &quot;moof offset: %&quot; G_GUINT64_FORMAT &quot;, ts %&quot; GST_TIME_FORMAT,
<span class="line-modified"> 5750       GST_TIME_ARGS (qtdemux-&gt;streams[0]-&gt;time_position),</span>
 5751       best_entry-&gt;moof_offset, GST_TIME_ARGS (best_entry-&gt;ts));
 5752 
 5753   qtdemux-&gt;moof_offset = best_entry-&gt;moof_offset;
 5754 
 5755   qtdemux_add_fragmented_samples (qtdemux);
 5756 
 5757   GST_OBJECT_UNLOCK (qtdemux);
 5758   return TRUE;
 5759 }
 5760 
 5761 static GstFlowReturn
 5762 gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
 5763 {
 5764   GstFlowReturn ret = GST_FLOW_OK;
 5765   GstBuffer *buf = NULL;
<span class="line-modified"> 5766   QtDemuxStream *stream;</span>
 5767   GstClockTime min_time;
 5768   guint64 offset = 0;
 5769   GstClockTime dts = GST_CLOCK_TIME_NONE;
 5770   GstClockTime pts = GST_CLOCK_TIME_NONE;
 5771   GstClockTime duration = 0;
 5772   gboolean keyframe = FALSE;
 5773   guint sample_size = 0;
 5774   gboolean empty = 0;
 5775   guint size;
<span class="line-removed"> 5776   gint index;</span>
 5777   gint i;
 5778 
<span class="line-removed"> 5779   gst_qtdemux_push_pending_newsegment (qtdemux);</span>
<span class="line-removed"> 5780 </span>
 5781   if (qtdemux-&gt;fragmented_seek_pending) {
 5782     GST_INFO_OBJECT (qtdemux, &quot;pending fragmented seek&quot;);
 5783     if (gst_qtdemux_do_fragmented_seek (qtdemux)) {
 5784       GST_INFO_OBJECT (qtdemux, &quot;fragmented seek done!&quot;);
 5785       qtdemux-&gt;fragmented_seek_pending = FALSE;
 5786     } else {
 5787       GST_INFO_OBJECT (qtdemux, &quot;fragmented seek still pending&quot;);
 5788     }
 5789   }
 5790 
 5791   /* Figure out the next stream sample to output, min_time is expressed in
 5792    * global time and runs over the edit list segments. */
 5793   min_time = G_MAXUINT64;
<span class="line-modified"> 5794   index = -1;</span>
<span class="line-removed"> 5795   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
 5796     GstClockTime position;
 5797 
<span class="line-modified"> 5798     stream = qtdemux-&gt;streams[i];</span>
 5799     position = stream-&gt;time_position;
 5800 
 5801     /* position of -1 is EOS */
 5802     if (position != GST_CLOCK_TIME_NONE &amp;&amp; position &lt; min_time) {
 5803       min_time = position;
<span class="line-modified"> 5804       index = i;</span>
 5805     }
 5806   }
 5807   /* all are EOS */
<span class="line-modified"> 5808   if (G_UNLIKELY (index == -1)) {</span>
 5809     GST_DEBUG_OBJECT (qtdemux, &quot;all streams are EOS&quot;);
 5810     goto eos;
 5811   }
 5812 
 5813   /* check for segment end */
 5814   if (G_UNLIKELY (qtdemux-&gt;segment.stop != -1
 5815           &amp;&amp; ((qtdemux-&gt;segment.rate &gt;= 0 &amp;&amp; qtdemux-&gt;segment.stop &lt;= min_time)
 5816               || (qtdemux-&gt;segment.rate &lt; 0
 5817                   &amp;&amp; qtdemux-&gt;segment.start &gt; min_time))
<span class="line-modified"> 5818           &amp;&amp; qtdemux-&gt;streams[index]-&gt;on_keyframe)) {</span>
 5819     GST_DEBUG_OBJECT (qtdemux, &quot;we reached the end of our segment.&quot;);
<span class="line-modified"> 5820     qtdemux-&gt;streams[index]-&gt;time_position = GST_CLOCK_TIME_NONE;</span>
 5821     goto eos_stream;
 5822   }
 5823 
 5824   /* gap events for subtitle streams */
<span class="line-modified"> 5825   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified"> 5826     stream = qtdemux-&gt;streams[i];</span>
 5827     if (stream-&gt;pad &amp;&amp; (stream-&gt;subtype == FOURCC_subp
 5828             || stream-&gt;subtype == FOURCC_text
 5829             || stream-&gt;subtype == FOURCC_sbtl)) {
 5830       /* send one second gap events until the stream catches up */
 5831       /* gaps can only be sent after segment is activated (segment.stop is no longer -1) */
 5832       while (GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.stop) &amp;&amp;
 5833           GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.position) &amp;&amp;
 5834           stream-&gt;segment.position + GST_SECOND &lt; min_time) {
 5835         GstEvent *gap =
 5836             gst_event_new_gap (stream-&gt;segment.position, GST_SECOND);
 5837         gst_pad_push_event (stream-&gt;pad, gap);
 5838         stream-&gt;segment.position += GST_SECOND;
 5839       }
 5840     }
 5841   }
 5842 
<span class="line-modified"> 5843   stream = qtdemux-&gt;streams[index];</span>
 5844   /* fetch info for the current sample of this stream */
 5845   if (G_UNLIKELY (!gst_qtdemux_prepare_current_sample (qtdemux, stream, &amp;empty,
 5846               &amp;offset, &amp;sample_size, &amp;dts, &amp;pts, &amp;duration, &amp;keyframe)))
 5847     goto eos_stream;
 5848 
 5849   gst_qtdemux_stream_check_and_change_stsd_index (qtdemux, stream);
 5850   if (stream-&gt;new_caps) {
 5851     gst_qtdemux_configure_stream (qtdemux, stream);
<span class="line-modified"> 5852     qtdemux_do_allocation (qtdemux, stream);</span>
 5853   }
 5854 
 5855   /* If we&#39;re doing a keyframe-only trickmode, only push keyframes on video streams */
<span class="line-modified"> 5856   if (G_UNLIKELY (qtdemux-&gt;</span>
<span class="line-modified"> 5857           segment.flags &amp; GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS)) {</span>
 5858     if (stream-&gt;subtype == FOURCC_vide &amp;&amp; !keyframe) {
<span class="line-modified"> 5859       GST_LOG_OBJECT (qtdemux, &quot;Skipping non-keyframe on stream %d&quot;, index);</span>

 5860       goto next;
 5861     }
 5862   }
 5863 
 5864   GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified"> 5865       &quot;pushing from stream %d, empty %d offset %&quot; G_GUINT64_FORMAT</span>
 5866       &quot;, size %d, dts=%&quot; GST_TIME_FORMAT &quot;, pts=%&quot; GST_TIME_FORMAT
<span class="line-modified"> 5867       &quot;, duration %&quot; GST_TIME_FORMAT, index, empty, offset, sample_size,</span>
<span class="line-modified"> 5868       GST_TIME_ARGS (dts), GST_TIME_ARGS (pts), GST_TIME_ARGS (duration));</span>

 5869 
 5870   if (G_UNLIKELY (empty)) {
 5871     /* empty segment, push a gap if there&#39;s a second or more
 5872      * difference and move to the next one */
 5873     if ((pts + duration - stream-&gt;segment.position) &gt;= GST_SECOND)
<span class="line-modified"> 5874     gst_pad_push_event (stream-&gt;pad, gst_event_new_gap (pts, duration));</span>
 5875     stream-&gt;segment.position = pts + duration;
 5876     goto next;
 5877   }
 5878 
 5879   /* hmm, empty sample, skip and move to next sample */
 5880   if (G_UNLIKELY (sample_size &lt;= 0))
 5881     goto next;
 5882 
 5883   /* last pushed sample was out of boundary, goto next sample */
 5884   if (G_UNLIKELY (GST_PAD_LAST_FLOW_RETURN (stream-&gt;pad) == GST_FLOW_EOS))
 5885     goto next;
 5886 
 5887   if (stream-&gt;max_buffer_size == 0 || sample_size &lt;= stream-&gt;max_buffer_size) {
 5888     size = sample_size;
 5889   } else {
 5890     GST_DEBUG_OBJECT (qtdemux,
 5891         &quot;size %d larger than stream max_buffer_size %d, trimming&quot;,
 5892         sample_size, stream-&gt;max_buffer_size);
 5893     size =
 5894         MIN (sample_size - stream-&gt;offset_in_sample, stream-&gt;max_buffer_size);
</pre>
<hr />
<pre>
 6044   /* ERRORS */
 6045 invalid_state:
 6046   {
 6047     GST_ELEMENT_ERROR (qtdemux, STREAM, FAILED,
 6048         (NULL), (&quot;streaming stopped, invalid state&quot;));
 6049     gst_pad_pause_task (pad);
 6050     gst_qtdemux_push_event (qtdemux, gst_event_new_eos ());
 6051     goto done;
 6052   }
 6053 pause:
 6054   {
 6055     const gchar *reason = gst_flow_get_name (ret);
 6056 
 6057     GST_LOG_OBJECT (qtdemux, &quot;pausing task, reason %s&quot;, reason);
 6058 
 6059     gst_pad_pause_task (pad);
 6060 
 6061     /* fatal errors need special actions */
 6062     /* check EOS */
 6063     if (ret == GST_FLOW_EOS) {
<span class="line-modified"> 6064       if (qtdemux-&gt;n_streams == 0) {</span>
 6065         /* we have no streams, post an error */
 6066         gst_qtdemux_post_no_playable_stream_error (qtdemux);
 6067       }
 6068       if (qtdemux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 6069         gint64 stop;
 6070 
 6071         if ((stop = qtdemux-&gt;segment.stop) == -1)
 6072           stop = qtdemux-&gt;segment.duration;
 6073 
 6074         if (qtdemux-&gt;segment.rate &gt;= 0) {
 6075           GstMessage *message;
 6076           GstEvent *event;
 6077 
 6078           GST_LOG_OBJECT (qtdemux, &quot;Sending segment done, at end of segment&quot;);
 6079           message = gst_message_new_segment_done (GST_OBJECT_CAST (qtdemux),
 6080               GST_FORMAT_TIME, stop);
 6081           event = gst_event_new_segment_done (GST_FORMAT_TIME, stop);
 6082           if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID) {
 6083             gst_message_set_seqnum (message, qtdemux-&gt;segment_seqnum);
 6084             gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
 6085           }
 6086           gst_element_post_message (GST_ELEMENT_CAST (qtdemux), message);
 6087           gst_qtdemux_push_event (qtdemux, event);
 6088         } else {
 6089           GstMessage *message;
 6090           GstEvent *event;
 6091 
 6092           /*  For Reverse Playback */
 6093           GST_LOG_OBJECT (qtdemux, &quot;Sending segment done, at start of segment&quot;);
 6094           message = gst_message_new_segment_done (GST_OBJECT_CAST (qtdemux),
 6095               GST_FORMAT_TIME, qtdemux-&gt;segment.start);
 6096           event = gst_event_new_segment_done (GST_FORMAT_TIME,
 6097               qtdemux-&gt;segment.start);
 6098           if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID) {
 6099             gst_message_set_seqnum (message, qtdemux-&gt;segment_seqnum);
 6100             gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
<span class="line-modified"> 6101         }</span>
 6102           gst_element_post_message (GST_ELEMENT_CAST (qtdemux), message);
 6103           gst_qtdemux_push_event (qtdemux, event);
 6104         }
 6105       } else {
 6106         GstEvent *event;
 6107 
 6108         GST_LOG_OBJECT (qtdemux, &quot;Sending EOS at end of segment&quot;);
 6109         event = gst_event_new_eos ();
 6110         if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID)
 6111           gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
 6112         gst_qtdemux_push_event (qtdemux, event);
 6113       }
 6114     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
 6115       GST_ELEMENT_FLOW_ERROR (qtdemux, ret);
 6116       gst_qtdemux_push_event (qtdemux, gst_event_new_eos ());
 6117     }
 6118     goto done;
 6119   }
 6120 }
 6121 
 6122 /*
 6123  * has_next_entry
 6124  *
 6125  * Returns if there are samples to be played.
 6126  */
 6127 static gboolean
 6128 has_next_entry (GstQTDemux * demux)
 6129 {
 6130   QtDemuxStream *stream;
<span class="line-modified"> 6131   int i;</span>
 6132 
 6133   GST_DEBUG_OBJECT (demux, &quot;Checking if there are samples not played yet&quot;);
 6134 
<span class="line-modified"> 6135   for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified"> 6136     stream = demux-&gt;streams[i];</span>
 6137 
 6138     if (stream-&gt;sample_index == -1) {
 6139       stream-&gt;sample_index = 0;
 6140       stream-&gt;offset_in_sample = 0;
 6141     }
 6142 
 6143     if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {
<span class="line-modified"> 6144       GST_LOG_OBJECT (demux, &quot;stream %d samples exhausted&quot;, i);</span>
 6145       continue;
 6146     }
 6147     GST_DEBUG_OBJECT (demux, &quot;Found a sample&quot;);
 6148     return TRUE;
 6149   }
 6150 
 6151   GST_DEBUG_OBJECT (demux, &quot;There wasn&#39;t any next sample&quot;);
 6152   return FALSE;
 6153 }
 6154 
 6155 /*
 6156  * next_entry_size
 6157  *
 6158  * Returns the size of the first entry at the current offset.
 6159  * If -1, there are none (which means EOS or empty file).
 6160  */
 6161 static guint64
 6162 next_entry_size (GstQTDemux * demux)
 6163 {
<span class="line-modified"> 6164   QtDemuxStream *stream;</span>
<span class="line-removed"> 6165   int i;</span>
<span class="line-removed"> 6166   int smallidx = -1;</span>
 6167   guint64 smalloffs = (guint64) - 1;
 6168   QtDemuxSample *sample;

 6169 
 6170   GST_LOG_OBJECT (demux, &quot;Finding entry at offset %&quot; G_GUINT64_FORMAT,
 6171       demux-&gt;offset);
 6172 
<span class="line-modified"> 6173   for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified"> 6174     stream = demux-&gt;streams[i];</span>
 6175 
 6176     if (stream-&gt;sample_index == -1) {
 6177       stream-&gt;sample_index = 0;
 6178       stream-&gt;offset_in_sample = 0;
 6179     }
 6180 
 6181     if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {
<span class="line-modified"> 6182       GST_LOG_OBJECT (demux, &quot;stream %d samples exhausted&quot;, i);</span>
 6183       continue;
 6184     }
 6185 
 6186     if (!qtdemux_parse_samples (demux, stream, stream-&gt;sample_index)) {
 6187       GST_LOG_OBJECT (demux, &quot;Parsing of index %u from stbl atom failed!&quot;,
 6188           stream-&gt;sample_index);
 6189       return -1;
 6190     }
 6191 
 6192     sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 6193 
 6194     GST_LOG_OBJECT (demux,
<span class="line-modified"> 6195         &quot;Checking Stream %d (sample_index:%d / offset:%&quot; G_GUINT64_FORMAT</span>
<span class="line-modified"> 6196         &quot; / size:%&quot; G_GUINT32_FORMAT &quot;)&quot;, i, stream-&gt;sample_index,</span>
<span class="line-modified"> 6197         sample-&gt;offset, sample-&gt;size);</span>
 6198 
 6199     if (((smalloffs == -1)
 6200             || (sample-&gt;offset &lt; smalloffs)) &amp;&amp; (sample-&gt;size)) {
<span class="line-removed"> 6201       smallidx = i;</span>
 6202       smalloffs = sample-&gt;offset;

 6203     }
 6204   }
 6205 
<span class="line-modified"> 6206   GST_LOG_OBJECT (demux,</span>
<span class="line-removed"> 6207       &quot;stream %d offset %&quot; G_GUINT64_FORMAT &quot; demux-&gt;offset :%&quot;</span>
<span class="line-removed"> 6208       G_GUINT64_FORMAT, smallidx, smalloffs, demux-&gt;offset);</span>
<span class="line-removed"> 6209 </span>
<span class="line-removed"> 6210   if (smallidx == -1)</span>
 6211     return -1;
 6212 
<span class="line-modified"> 6213   stream = demux-&gt;streams[smallidx];</span>




 6214   sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 6215 
 6216   if (sample-&gt;offset &gt;= demux-&gt;offset) {
 6217     demux-&gt;todrop = sample-&gt;offset - demux-&gt;offset;
 6218     return sample-&gt;size + demux-&gt;todrop;
 6219   }
 6220 
 6221   GST_DEBUG_OBJECT (demux,
 6222       &quot;There wasn&#39;t any entry at offset %&quot; G_GUINT64_FORMAT, demux-&gt;offset);
 6223   return -1;
 6224 }
 6225 
 6226 static void
 6227 gst_qtdemux_post_progress (GstQTDemux * demux, gint num, gint denom)
 6228 {
 6229   gint perc = (gint) ((gdouble) num * 100.0 / (gdouble) denom);
 6230 
 6231   gst_element_post_message (GST_ELEMENT_CAST (demux),
 6232       gst_message_new_element (GST_OBJECT_CAST (demux),
 6233           gst_structure_new (&quot;progress&quot;, &quot;percent&quot;, G_TYPE_INT, perc, NULL)));
</pre>
<hr />
<pre>
 6293   gst_query_unref (query);
 6294 
 6295   GST_DEBUG_OBJECT (demux, &quot;seekable: %d (%&quot; G_GUINT64_FORMAT &quot; - %&quot;
 6296       G_GUINT64_FORMAT &quot;)&quot;, seekable, start, stop);
 6297   demux-&gt;upstream_seekable = seekable;
 6298   demux-&gt;upstream_size = seekable ? stop : -1;
 6299 }
 6300 
 6301 static void
 6302 gst_qtdemux_drop_data (GstQTDemux * demux, gint bytes)
 6303 {
 6304   g_return_if_fail (bytes &lt;= demux-&gt;todrop);
 6305 
 6306   GST_LOG_OBJECT (demux, &quot;Dropping %d bytes&quot;, bytes);
 6307   gst_adapter_flush (demux-&gt;adapter, bytes);
 6308   demux-&gt;neededbytes -= bytes;
 6309   demux-&gt;offset += bytes;
 6310   demux-&gt;todrop -= bytes;
 6311 }
 6312 

 6313 static void
 6314 gst_qtdemux_check_send_pending_segment (GstQTDemux * demux)
 6315 {
<span class="line-modified"> 6316   if (G_UNLIKELY (demux-&gt;pending_newsegment)) {</span>
 6317     gint i;
 6318 
<span class="line-modified"> 6319     gst_qtdemux_push_pending_newsegment (demux);</span>











 6320     /* clear to send tags on all streams */
<span class="line-modified"> 6321     for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified"> 6322       QtDemuxStream *stream;</span>
<span class="line-removed"> 6323       stream = demux-&gt;streams[i];</span>
 6324       gst_qtdemux_push_tags (demux, stream);
 6325       if (CUR_STREAM (stream)-&gt;sparse) {
 6326         GST_INFO_OBJECT (demux, &quot;Sending gap event on stream %d&quot;, i);
 6327         gst_pad_push_event (stream-&gt;pad,
 6328             gst_event_new_gap (stream-&gt;segment.position, GST_CLOCK_TIME_NONE));
 6329       }
 6330     }
 6331   }
 6332 }
 6333 

 6334 static void
 6335 gst_qtdemux_send_gap_for_segment (GstQTDemux * demux,
 6336     QtDemuxStream * stream, gint segment_index, GstClockTime pos)
 6337 {
 6338   GstClockTime ts, dur;
<span class="line-removed"> 6339   GstEvent *gap;</span>
 6340 
 6341   ts = pos;
 6342   dur =
 6343       stream-&gt;segments[segment_index].duration - (pos -
 6344       stream-&gt;segments[segment_index].time);
<span class="line-removed"> 6345   gap = gst_event_new_gap (ts, dur);</span>
 6346   stream-&gt;time_position += dur;
 6347 
<span class="line-modified"> 6348   GST_DEBUG_OBJECT (stream-&gt;pad, &quot;Pushing gap for empty &quot;</span>
<span class="line-modified"> 6349       &quot;segment: %&quot; GST_PTR_FORMAT, gap);</span>
<span class="line-modified"> 6350   gst_pad_push_event (stream-&gt;pad, gap);</span>
<span class="line-modified"> 6351 }</span>
<span class="line-modified"> 6352 </span>
<span class="line-modified"> 6353 static void</span>
<span class="line-removed"> 6354 gst_qtdemux_stream_send_initial_gap_segments (GstQTDemux * demux,</span>
<span class="line-removed"> 6355     QtDemuxStream * stream)</span>
<span class="line-removed"> 6356 {</span>
<span class="line-removed"> 6357   gint i;</span>
<span class="line-removed"> 6358 </span>
<span class="line-removed"> 6359   /* Push any initial gap segments before proceeding to the</span>
<span class="line-removed"> 6360    * &#39;real&#39; data */</span>
<span class="line-removed"> 6361   for (i = 0; i &lt; stream-&gt;n_segments; i++) {</span>
<span class="line-removed"> 6362     gst_qtdemux_activate_segment (demux, stream, i, stream-&gt;time_position);</span>
 6363 
<span class="line-modified"> 6364     if (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;segments[i])) {</span>
<span class="line-modified"> 6365       gst_qtdemux_send_gap_for_segment (demux, stream, i,</span>
<span class="line-modified"> 6366           stream-&gt;time_position);</span>
<span class="line-removed"> 6367     } else {</span>
<span class="line-removed"> 6368       /* Only support empty segment at the beginning followed by</span>
<span class="line-removed"> 6369        * one non-empty segment, this was checked when parsing the</span>
<span class="line-removed"> 6370        * edts atom, arriving here is unexpected */</span>
<span class="line-removed"> 6371       g_assert (i + 1 == stream-&gt;n_segments);</span>
<span class="line-removed"> 6372       break;</span>
<span class="line-removed"> 6373     }</span>
 6374   }
 6375 }
 6376 
 6377 static GstFlowReturn
 6378 gst_qtdemux_chain (GstPad * sinkpad, GstObject * parent, GstBuffer * inbuf)
 6379 {
 6380   GstQTDemux *demux;
 6381 
 6382   demux = GST_QTDEMUX (parent);
 6383 
 6384   GST_DEBUG_OBJECT (demux,
 6385       &quot;Received buffer pts:%&quot; GST_TIME_FORMAT &quot; dts:%&quot; GST_TIME_FORMAT
 6386       &quot; offset:%&quot; G_GUINT64_FORMAT &quot; size:%&quot; G_GSIZE_FORMAT &quot; demux offset:%&quot;
 6387       G_GUINT64_FORMAT, GST_TIME_ARGS (GST_BUFFER_PTS (inbuf)),
 6388       GST_TIME_ARGS (GST_BUFFER_DTS (inbuf)), GST_BUFFER_OFFSET (inbuf),
 6389       gst_buffer_get_size (inbuf), demux-&gt;offset);
 6390 
 6391   if (GST_BUFFER_FLAG_IS_SET (inbuf, GST_BUFFER_FLAG_DISCONT)) {
 6392     gboolean is_gap_input = FALSE;
 6393     gint i;
 6394 
 6395     GST_DEBUG_OBJECT (demux, &quot;Got DISCONT, marking all streams as DISCONT&quot;);
 6396 
<span class="line-modified"> 6397     for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified"> 6398       demux-&gt;streams[i]-&gt;discont = TRUE;</span>
 6399     }
 6400 
 6401     /* Check if we can land back on our feet in the case where upstream is
 6402      * handling the seeking/pushing of samples with gaps in between (like
 6403      * in the case of trick-mode DASH for example) */
 6404     if (demux-&gt;upstream_format_is_time
 6405         &amp;&amp; GST_BUFFER_OFFSET (inbuf) != GST_BUFFER_OFFSET_NONE) {
<span class="line-modified"> 6406       gint i;</span>
<span class="line-removed"> 6407       for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
 6408         guint32 res;

 6409         GST_LOG_OBJECT (demux,
<span class="line-modified"> 6410             &quot;Stream #%d , checking if offset %&quot; G_GUINT64_FORMAT</span>
<span class="line-modified"> 6411             &quot; is a sample start&quot;, i, GST_BUFFER_OFFSET (inbuf));</span>
 6412         res =
 6413             gst_qtdemux_find_index_for_given_media_offset_linear (demux,
<span class="line-modified"> 6414             demux-&gt;streams[i], GST_BUFFER_OFFSET (inbuf));</span>
 6415         if (res != -1) {
<span class="line-modified"> 6416           QtDemuxSample *sample = &amp;demux-&gt;streams[i]-&gt;samples[res];</span>
 6417           GST_LOG_OBJECT (demux,
<span class="line-modified"> 6418               &quot;Checking if sample %d from stream %d is valid (offset:%&quot;</span>
<span class="line-modified"> 6419               G_GUINT64_FORMAT &quot; size:%&quot; G_GUINT32_FORMAT &quot;)&quot;, res, i,</span>
<span class="line-modified"> 6420               sample-&gt;offset, sample-&gt;size);</span>
 6421           if (sample-&gt;offset == GST_BUFFER_OFFSET (inbuf)) {
 6422             GST_LOG_OBJECT (demux,
 6423                 &quot;new buffer corresponds to a valid sample : %&quot; G_GUINT32_FORMAT,
 6424                 res);
 6425             is_gap_input = TRUE;
 6426             /* We can go back to standard playback mode */
 6427             demux-&gt;state = QTDEMUX_STATE_MOVIE;
 6428             /* Remember which sample this stream is at */
<span class="line-modified"> 6429             demux-&gt;streams[i]-&gt;sample_index = res;</span>
 6430             /* Finally update all push-based values to the expected values */
<span class="line-modified"> 6431             demux-&gt;neededbytes = demux-&gt;streams[i]-&gt;samples[res].size;</span>
 6432             demux-&gt;offset = GST_BUFFER_OFFSET (inbuf);
 6433             demux-&gt;mdatleft =
 6434                 demux-&gt;mdatsize - demux-&gt;offset + demux-&gt;mdatoffset;
 6435             demux-&gt;todrop = 0;
 6436           }
 6437         }
 6438       }
 6439       if (!is_gap_input) {
 6440         GST_DEBUG_OBJECT (demux, &quot;Resetting, actual DISCONT&quot;);
 6441         /* Reset state if it&#39;s a real discont */
 6442         demux-&gt;neededbytes = 16;
 6443         demux-&gt;state = QTDEMUX_STATE_INITIAL;
 6444         demux-&gt;offset = GST_BUFFER_OFFSET (inbuf);
 6445         gst_adapter_clear (demux-&gt;adapter);
 6446       }
 6447     }
 6448     /* Reverse fragmented playback, need to flush all we have before
 6449      * consuming a new fragment.
 6450      * The samples array have the timestamps calculated by accumulating the
 6451      * durations but this won&#39;t work for reverse playback of fragments as
 6452      * the timestamps of a subsequent fragment should be smaller than the
 6453      * previously received one. */
 6454     if (!is_gap_input &amp;&amp; demux-&gt;fragmented &amp;&amp; demux-&gt;segment.rate &lt; 0) {
 6455       gst_qtdemux_process_adapter (demux, TRUE);
<span class="line-modified"> 6456       for (i = 0; i &lt; demux-&gt;n_streams; i++)</span>
<span class="line-modified"> 6457         gst_qtdemux_stream_flush_samples_data (demux, demux-&gt;streams[i]);</span>
 6458     }
 6459   }
 6460 
 6461   gst_adapter_push (demux-&gt;adapter, inbuf);
 6462 
 6463   GST_DEBUG_OBJECT (demux,
 6464       &quot;pushing in inbuf %p, neededbytes:%u, available:%&quot; G_GSIZE_FORMAT, inbuf,
 6465       demux-&gt;neededbytes, gst_adapter_available (demux-&gt;adapter));
 6466 
 6467   return gst_qtdemux_process_adapter (demux, FALSE);
 6468 }
 6469 
 6470 static GstFlowReturn
 6471 gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
 6472 {
 6473   GstFlowReturn ret = GST_FLOW_OK;
 6474 
 6475   /* we never really mean to buffer that much */
 6476   if (demux-&gt;neededbytes == -1) {
 6477     goto eos;
 6478   }
 6479 
 6480   while (((gst_adapter_available (demux-&gt;adapter)) &gt;= demux-&gt;neededbytes) &amp;&amp;
 6481       (ret == GST_FLOW_OK || (ret == GST_FLOW_NOT_LINKED &amp;&amp; force))) {
 6482 
 6483 #ifndef GST_DISABLE_GST_DEBUG
 6484     {
 6485       guint64 discont_offset, distance_from_discont;
 6486 
 6487       discont_offset = gst_adapter_offset_at_discont (demux-&gt;adapter);
 6488       distance_from_discont =
 6489           gst_adapter_distance_from_discont (demux-&gt;adapter);
 6490 
<span class="line-modified"> 6491     GST_DEBUG_OBJECT (demux,</span>
 6492           &quot;state:%s , demux-&gt;neededbytes:%d, demux-&gt;offset:%&quot; G_GUINT64_FORMAT
 6493           &quot; adapter offset :%&quot; G_GUINT64_FORMAT &quot; (+ %&quot; G_GUINT64_FORMAT
 6494           &quot; bytes)&quot;, qt_demux_state_string (demux-&gt;state), demux-&gt;neededbytes,
 6495           demux-&gt;offset, discont_offset, distance_from_discont);
 6496     }
 6497 #endif
 6498 
 6499     switch (demux-&gt;state) {
 6500       case QTDEMUX_STATE_INITIAL:{
 6501         const guint8 *data;
 6502         guint32 fourcc;
 6503         guint64 size;
 6504 
 6505         gst_qtdemux_check_seekability (demux);
 6506 
 6507         data = gst_adapter_map (demux-&gt;adapter, demux-&gt;neededbytes);
 6508 
 6509         /* get fourcc/length, set neededbytes */
 6510         extract_initial_length_and_fourcc ((guint8 *) data, demux-&gt;neededbytes,
 6511             &amp;size, &amp;fourcc);
 6512         gst_adapter_unmap (demux-&gt;adapter);
 6513         data = NULL;
 6514         GST_DEBUG_OBJECT (demux, &quot;Peeking found [%&quot; GST_FOURCC_FORMAT &quot;] &quot;
 6515             &quot;size: %&quot; G_GUINT64_FORMAT, GST_FOURCC_ARGS (fourcc), size);
 6516         if (size == 0) {
 6517           GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
 6518               (_(&quot;This file is invalid and cannot be played.&quot;)),
 6519               (&quot;initial atom &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39; has empty length&quot;,
 6520                   GST_FOURCC_ARGS (fourcc)));
 6521           ret = GST_FLOW_ERROR;
 6522           break;
 6523         }
 6524         if (fourcc == FOURCC_mdat) {
 6525           gint next_entry = next_entry_size (demux);
<span class="line-modified"> 6526           if (demux-&gt;n_streams &gt; 0 &amp;&amp; (next_entry != -1 || !demux-&gt;fragmented)) {</span>

 6527             /* we have the headers, start playback */
 6528             demux-&gt;state = QTDEMUX_STATE_MOVIE;
 6529             demux-&gt;neededbytes = next_entry;
 6530             demux-&gt;mdatleft = size;
 6531             demux-&gt;mdatsize = demux-&gt;mdatleft;
 6532           } else {
 6533             /* no headers yet, try to get them */
 6534             guint bs;
 6535             gboolean res;
 6536             guint64 old, target;
 6537 
 6538           buffer_data:
 6539             old = demux-&gt;offset;
 6540             target = old + size;
 6541 
 6542             /* try to jump over the atom with a seek */
 6543             /* only bother if it seems worth doing so,
 6544              * and avoids possible upstream/server problems */
 6545             if (demux-&gt;upstream_seekable &amp;&amp;
 6546                 demux-&gt;upstream_size &gt; 4 * (1 &lt;&lt; 20)) {
<span class="line-modified"> 6547             res = qtdemux_seek_offset (demux, target);</span>
 6548             } else {
 6549               GST_DEBUG_OBJECT (demux, &quot;skipping seek&quot;);
 6550               res = FALSE;
 6551             }
 6552 
 6553             if (res) {
 6554               GST_DEBUG_OBJECT (demux, &quot;seek success&quot;);
 6555               /* remember the offset fo the first mdat so we can seek back to it
 6556                * after we have the headers */
 6557               if (fourcc == FOURCC_mdat &amp;&amp; demux-&gt;first_mdat == -1) {
 6558                 demux-&gt;first_mdat = old;
 6559                 GST_DEBUG_OBJECT (demux, &quot;first mdat at %&quot; G_GUINT64_FORMAT,
 6560                     demux-&gt;first_mdat);
 6561               }
 6562               /* seek worked, continue reading */
 6563               demux-&gt;offset = target;
 6564               demux-&gt;neededbytes = 16;
 6565               demux-&gt;state = QTDEMUX_STATE_INITIAL;
 6566             } else {
 6567               /* seek failed, need to buffer */
</pre>
<hr />
<pre>
 6594           if (demux-&gt;mdatbuffer &amp;&amp; !(fourcc == FOURCC_moov
 6595                   || fourcc == FOURCC_moof))
 6596             goto buffer_data;
 6597           demux-&gt;neededbytes = size;
 6598           demux-&gt;state = QTDEMUX_STATE_HEADER;
 6599         }
 6600         break;
 6601       }
 6602       case QTDEMUX_STATE_HEADER:{
 6603         const guint8 *data;
 6604         guint32 fourcc;
 6605 
 6606         GST_DEBUG_OBJECT (demux, &quot;In header&quot;);
 6607 
 6608         data = gst_adapter_map (demux-&gt;adapter, demux-&gt;neededbytes);
 6609 
 6610         /* parse the header */
 6611         extract_initial_length_and_fourcc (data, demux-&gt;neededbytes, NULL,
 6612             &amp;fourcc);
 6613         if (fourcc == FOURCC_moov) {
<span class="line-removed"> 6614           gint n;</span>
<span class="line-removed"> 6615 </span>
 6616           /* in usual fragmented setup we could try to scan for more
 6617            * and end up at the the moov (after mdat) again */
<span class="line-modified"> 6618           if (demux-&gt;got_moov &amp;&amp; demux-&gt;n_streams &gt; 0 &amp;&amp;</span>
 6619               (!demux-&gt;fragmented
 6620                   || demux-&gt;last_moov_offset == demux-&gt;offset)) {
 6621             GST_DEBUG_OBJECT (demux,
 6622                 &quot;Skipping moov atom as we have (this) one already&quot;);
 6623           } else {
<span class="line-modified"> 6624           GST_DEBUG_OBJECT (demux, &quot;Parsing [moov]&quot;);</span>
 6625 
 6626             if (demux-&gt;got_moov &amp;&amp; demux-&gt;fragmented) {
 6627               GST_DEBUG_OBJECT (demux,
 6628                   &quot;Got a second moov, clean up data from old one&quot;);
 6629               if (demux-&gt;moov_node_compressed) {
 6630                 g_node_destroy (demux-&gt;moov_node_compressed);
<span class="line-modified"> 6631               if (demux-&gt;moov_node)</span>
 6632                   g_free (demux-&gt;moov_node-&gt;data);
 6633               }
 6634               demux-&gt;moov_node_compressed = NULL;
 6635               if (demux-&gt;moov_node)
 6636                 g_node_destroy (demux-&gt;moov_node);
 6637               demux-&gt;moov_node = NULL;
<span class="line-removed"> 6638             } else {</span>
<span class="line-removed"> 6639           /* prepare newsegment to send when streaming actually starts */</span>
<span class="line-removed"> 6640               if (!demux-&gt;pending_newsegment) {</span>
<span class="line-removed"> 6641             demux-&gt;pending_newsegment =</span>
<span class="line-removed"> 6642                     gst_event_new_segment (&amp;demux-&gt;segment);</span>
<span class="line-removed"> 6643                 if (demux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-removed"> 6644                   gst_event_set_seqnum (demux-&gt;pending_newsegment,</span>
<span class="line-removed"> 6645                       demux-&gt;segment_seqnum);</span>
<span class="line-removed"> 6646           }</span>
 6647             }
 6648 
 6649             demux-&gt;last_moov_offset = demux-&gt;offset;
 6650 
<span class="line-modified"> 6651           qtdemux_parse_moov (demux, data, demux-&gt;neededbytes);</span>
<span class="line-modified"> 6652           qtdemux_node_dump (demux, demux-&gt;moov_node);</span>




 6653 #ifdef GSTREAMER_LITE
 6654           if (!qtdemux_parse_tree (demux))
 6655           {
 6656               g_node_destroy (demux-&gt;moov_node);
 6657               demux-&gt;moov_node = NULL;
 6658               ret = GST_FLOW_ERROR;
 6659               goto done;
 6660           }
 6661 #else
<span class="line-modified"> 6662           qtdemux_parse_tree (demux);</span>
 6663 #endif //GSTREAMER_LITE
<span class="line-modified"> 6664           qtdemux_prepare_streams (demux);</span>
<span class="line-modified"> 6665           if (!demux-&gt;got_moov)</span>
 6666             qtdemux_expose_streams (demux);
<span class="line-modified"> 6667             else {</span>
<span class="line-removed"> 6668 </span>
<span class="line-removed"> 6669               for (n = 0; n &lt; demux-&gt;n_streams; n++) {</span>
<span class="line-removed"> 6670                 QtDemuxStream *stream = demux-&gt;streams[n];</span>
<span class="line-removed"> 6671 </span>
<span class="line-removed"> 6672                 gst_qtdemux_configure_stream (demux, stream);</span>
<span class="line-removed"> 6673               }</span>
<span class="line-removed"> 6674             }</span>
 6675 
 6676             demux-&gt;got_moov = TRUE;
<span class="line-removed"> 6677             gst_qtdemux_check_send_pending_segment (demux);</span>
 6678 
<span class="line-modified"> 6679             /* fragmented streams headers shouldn&#39;t contain edts atoms */</span>
<span class="line-removed"> 6680             if (!demux-&gt;fragmented) {</span>
<span class="line-removed"> 6681               for (n = 0; n &lt; demux-&gt;n_streams; n++) {</span>
<span class="line-removed"> 6682                 gst_qtdemux_stream_send_initial_gap_segments (demux,</span>
<span class="line-removed"> 6683                     demux-&gt;streams[n]);</span>
<span class="line-removed"> 6684               }</span>
<span class="line-removed"> 6685             }</span>
 6686 
 6687             if (demux-&gt;moov_node_compressed) {
 6688               g_node_destroy (demux-&gt;moov_node_compressed);
 6689               g_free (demux-&gt;moov_node-&gt;data);
 6690             }
 6691             demux-&gt;moov_node_compressed = NULL;
<span class="line-modified"> 6692           g_node_destroy (demux-&gt;moov_node);</span>
<span class="line-modified"> 6693           demux-&gt;moov_node = NULL;</span>
<span class="line-modified"> 6694           GST_DEBUG_OBJECT (demux, &quot;Finished parsing the header&quot;);</span>
 6695           }
 6696         } else if (fourcc == FOURCC_moof) {
 6697           if ((demux-&gt;got_moov || demux-&gt;media_caps) &amp;&amp; demux-&gt;fragmented) {
 6698             guint64 dist = 0;
 6699             GstClockTime prev_pts;
 6700             guint64 prev_offset;
 6701             guint64 adapter_discont_offset, adapter_discont_dist;
 6702 
 6703             GST_DEBUG_OBJECT (demux, &quot;Parsing [moof]&quot;);
 6704 
 6705             /*
 6706              * The timestamp of the moof buffer is relevant as some scenarios
 6707              * won&#39;t have the initial timestamp in the atoms. Whenever a new
 6708              * buffer has started, we get that buffer&#39;s PTS and use it as a base
 6709              * timestamp for the trun entries.
 6710              *
 6711              * To keep track of the current buffer timestamp and starting point
 6712              * we use gst_adapter_prev_pts that gives us the PTS and the distance
 6713              * from the beggining of the buffer, with the distance and demux-&gt;offset
 6714              * we know if it is still the same buffer or not.
</pre>
<hr />
<pre>
 6748                 &quot;demux offset %&quot; G_GUINT64_FORMAT &quot; adapter offset %&quot;
 6749                 G_GUINT64_FORMAT &quot; (+ %&quot; G_GUINT64_FORMAT &quot; bytes)&quot;,
 6750                 demux-&gt;offset, adapter_discont_offset, adapter_discont_dist);
 6751 
 6752             if (demux-&gt;upstream_format_is_time) {
 6753               demux-&gt;moof_offset = adapter_discont_offset;
 6754               if (demux-&gt;moof_offset != GST_BUFFER_OFFSET_NONE)
 6755                 demux-&gt;moof_offset += adapter_discont_dist;
 6756               if (demux-&gt;moof_offset == GST_BUFFER_OFFSET_NONE)
 6757                 demux-&gt;moof_offset = demux-&gt;offset;
 6758             } else {
 6759               demux-&gt;moof_offset = demux-&gt;offset;
 6760             }
 6761 
 6762             if (!qtdemux_parse_moof (demux, data, demux-&gt;neededbytes,
 6763                     demux-&gt;moof_offset, NULL)) {
 6764               gst_adapter_unmap (demux-&gt;adapter);
 6765               ret = GST_FLOW_ERROR;
 6766               goto done;
 6767             }

 6768             /* in MSS we need to expose the pads after the first moof as we won&#39;t get a moov */
 6769             if (demux-&gt;mss_mode &amp;&amp; !demux-&gt;exposed) {
<span class="line-modified"> 6770               if (!demux-&gt;pending_newsegment) {</span>
<span class="line-removed"> 6771                 GST_DEBUG_OBJECT (demux, &quot;new pending_newsegment&quot;);</span>
<span class="line-removed"> 6772                 demux-&gt;pending_newsegment =</span>
<span class="line-removed"> 6773                     gst_event_new_segment (&amp;demux-&gt;segment);</span>
<span class="line-removed"> 6774                 if (demux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-removed"> 6775                   gst_event_set_seqnum (demux-&gt;pending_newsegment,</span>
<span class="line-removed"> 6776                       demux-&gt;segment_seqnum);</span>
<span class="line-removed"> 6777               }</span>
 6778               qtdemux_expose_streams (demux);

 6779             }


 6780           } else {
 6781             GST_DEBUG_OBJECT (demux, &quot;Discarding [moof]&quot;);
 6782           }
 6783         } else if (fourcc == FOURCC_ftyp) {
 6784           GST_DEBUG_OBJECT (demux, &quot;Parsing [ftyp]&quot;);
 6785           qtdemux_parse_ftyp (demux, data, demux-&gt;neededbytes);
 6786         } else if (fourcc == FOURCC_uuid) {
 6787           GST_DEBUG_OBJECT (demux, &quot;Parsing [uuid]&quot;);
 6788           qtdemux_parse_uuid (demux, data, demux-&gt;neededbytes);
 6789         } else if (fourcc == FOURCC_sidx) {
 6790           GST_DEBUG_OBJECT (demux, &quot;Parsing [sidx]&quot;);
 6791           qtdemux_parse_sidx (demux, data, demux-&gt;neededbytes);
 6792         } else {
 6793           switch (fourcc) {
 6794             case FOURCC_styp:
 6795               /* [styp] is like a [ftyp], but in fragment header. We ignore it for now
 6796                * FALLTHROUGH */
 6797             case FOURCC_skip:
 6798             case FOURCC_free:
 6799               /* [free] and [skip] are padding atoms */
 6800               GST_DEBUG_OBJECT (demux,
 6801                   &quot;Skipping fourcc while parsing header : %&quot; GST_FOURCC_FORMAT,
 6802                   GST_FOURCC_ARGS (fourcc));
 6803               break;
 6804             default:
<span class="line-modified"> 6805           GST_WARNING_OBJECT (demux,</span>
<span class="line-modified"> 6806               &quot;Unknown fourcc while parsing header : %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified"> 6807               GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified"> 6808           /* Let&#39;s jump that one and go back to initial state */</span>
 6809               break;
<span class="line-modified"> 6810         }</span>
 6811         }
 6812         gst_adapter_unmap (demux-&gt;adapter);
 6813         data = NULL;
 6814 
<span class="line-modified"> 6815         if (demux-&gt;mdatbuffer &amp;&amp; demux-&gt;n_streams) {</span>
 6816           gsize remaining_data_size = 0;
 6817 
 6818           /* the mdat was before the header */
 6819           GST_DEBUG_OBJECT (demux, &quot;We have n_streams:%d and mdatbuffer:%p&quot;,
<span class="line-modified"> 6820               demux-&gt;n_streams, demux-&gt;mdatbuffer);</span>
 6821           /* restore our adapter/offset view of things with upstream;
 6822            * put preceding buffered data ahead of current moov data.
 6823            * This should also handle evil mdat, moov, mdat cases and alike */
 6824           gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
 6825 
 6826           /* Store any remaining data after the mdat for later usage */
 6827           remaining_data_size = gst_adapter_available (demux-&gt;adapter);
 6828           if (remaining_data_size &gt; 0) {
 6829             g_assert (demux-&gt;restoredata_buffer == NULL);
 6830             demux-&gt;restoredata_buffer =
 6831                 gst_adapter_take_buffer (demux-&gt;adapter, remaining_data_size);
 6832             demux-&gt;restoredata_offset = demux-&gt;offset + demux-&gt;neededbytes;
 6833             GST_DEBUG_OBJECT (demux,
 6834                 &quot;Stored %&quot; G_GSIZE_FORMAT &quot; post mdat bytes at offset %&quot;
 6835                 G_GUINT64_FORMAT, remaining_data_size,
 6836                 demux-&gt;restoredata_offset);
 6837           }
 6838 
 6839           gst_adapter_push (demux-&gt;adapter, demux-&gt;mdatbuffer);
 6840           demux-&gt;mdatbuffer = NULL;
</pre>
<hr />
<pre>
 6875         GST_DEBUG_OBJECT (demux, &quot;Got our buffer at offset %&quot; G_GUINT64_FORMAT,
 6876             demux-&gt;offset);
 6877         buf = gst_adapter_take_buffer (demux-&gt;adapter, demux-&gt;neededbytes);
 6878         gst_buffer_extract (buf, 0, fourcc, 4);
 6879         GST_DEBUG_OBJECT (demux, &quot;mdatbuffer starts with %&quot; GST_FOURCC_FORMAT,
 6880             GST_FOURCC_ARGS (QT_FOURCC (fourcc)));
 6881         if (demux-&gt;mdatbuffer)
 6882           demux-&gt;mdatbuffer = gst_buffer_append (demux-&gt;mdatbuffer, buf);
 6883         else
 6884           demux-&gt;mdatbuffer = buf;
 6885         demux-&gt;offset += demux-&gt;neededbytes;
 6886         demux-&gt;neededbytes = 16;
 6887         demux-&gt;state = QTDEMUX_STATE_INITIAL;
 6888         gst_qtdemux_post_progress (demux, 1, 1);
 6889 
 6890         break;
 6891       }
 6892       case QTDEMUX_STATE_MOVIE:{
 6893         QtDemuxStream *stream = NULL;
 6894         QtDemuxSample *sample;
<span class="line-removed"> 6895         int i = -1;</span>
 6896         GstClockTime dts, pts, duration;
 6897         gboolean keyframe;

 6898 
 6899         GST_DEBUG_OBJECT (demux,
 6900             &quot;BEGIN // in MOVIE for offset %&quot; G_GUINT64_FORMAT, demux-&gt;offset);
 6901 
 6902         if (demux-&gt;fragmented) {
 6903           GST_DEBUG_OBJECT (demux, &quot;mdat remaining %&quot; G_GUINT64_FORMAT,
 6904               demux-&gt;mdatleft);
 6905           if (G_LIKELY (demux-&gt;todrop &lt; demux-&gt;mdatleft)) {
 6906             /* if needed data starts within this atom,
 6907              * then it should not exceed this atom */
 6908             if (G_UNLIKELY (demux-&gt;neededbytes &gt; demux-&gt;mdatleft)) {
 6909               GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
 6910                   (_(&quot;This file is invalid and cannot be played.&quot;)),
 6911                   (&quot;sample data crosses atom boundary&quot;));
 6912               ret = GST_FLOW_ERROR;
 6913               break;
 6914             }
 6915             demux-&gt;mdatleft -= demux-&gt;neededbytes;
 6916           } else {
 6917             GST_DEBUG_OBJECT (demux, &quot;data atom emptied; resuming atom scan&quot;);
</pre>
<hr />
<pre>
 6927             if (demux-&gt;restoredata_buffer) {
 6928               g_assert (gst_adapter_available (demux-&gt;adapter) == 0);
 6929 
 6930               gst_adapter_push (demux-&gt;adapter, demux-&gt;restoredata_buffer);
 6931               demux-&gt;restoredata_buffer = NULL;
 6932               demux-&gt;offset = demux-&gt;restoredata_offset;
 6933             }
 6934 
 6935             break;
 6936           }
 6937         }
 6938 
 6939         if (demux-&gt;todrop) {
 6940           if (demux-&gt;cenc_aux_info_offset &gt; 0) {
 6941             GstByteReader br;
 6942             const guint8 *data;
 6943 
 6944             GST_DEBUG_OBJECT (demux, &quot;parsing cenc auxiliary info&quot;);
 6945             data = gst_adapter_map (demux-&gt;adapter, demux-&gt;todrop);
 6946             gst_byte_reader_init (&amp;br, data + 8, demux-&gt;todrop);
<span class="line-modified"> 6947             if (!qtdemux_parse_cenc_aux_info (demux, demux-&gt;streams[0], &amp;br,</span>

 6948                     demux-&gt;cenc_aux_info_sizes, demux-&gt;cenc_aux_sample_count)) {
 6949               GST_ERROR_OBJECT (demux, &quot;failed to parse cenc auxiliary info&quot;);
 6950               ret = GST_FLOW_ERROR;
 6951               gst_adapter_unmap (demux-&gt;adapter);
 6952               g_free (demux-&gt;cenc_aux_info_sizes);
 6953               demux-&gt;cenc_aux_info_sizes = NULL;
 6954               goto done;
<span class="line-modified"> 6955         }</span>
 6956             demux-&gt;cenc_aux_info_offset = 0;
 6957             g_free (demux-&gt;cenc_aux_info_sizes);
 6958             demux-&gt;cenc_aux_info_sizes = NULL;
 6959             gst_adapter_unmap (demux-&gt;adapter);
 6960           }
 6961           gst_qtdemux_drop_data (demux, demux-&gt;todrop);
 6962         }
 6963 
 6964         /* first buffer? */
 6965         /* initial newsegment sent here after having added pads,
 6966          * possible others in sink_event */
 6967         gst_qtdemux_check_send_pending_segment (demux);
 6968 
 6969         /* Figure out which stream this packet belongs to */
<span class="line-modified"> 6970         for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified"> 6971           stream = demux-&gt;streams[i];</span>
<span class="line-modified"> 6972           if (stream-&gt;sample_index &gt;= stream-&gt;n_samples)</span>


 6973             continue;

 6974           GST_LOG_OBJECT (demux,
<span class="line-modified"> 6975               &quot;Checking stream %d (sample_index:%d / offset:%&quot; G_GUINT64_FORMAT</span>
<span class="line-modified"> 6976               &quot; / size:%d)&quot;, i, stream-&gt;sample_index,</span>

 6977               stream-&gt;samples[stream-&gt;sample_index].offset,
 6978               stream-&gt;samples[stream-&gt;sample_index].size);
 6979 
 6980           if (stream-&gt;samples[stream-&gt;sample_index].offset == demux-&gt;offset)
 6981             break;
 6982         }
 6983 
<span class="line-modified"> 6984         if (G_UNLIKELY (stream == NULL || i == demux-&gt;n_streams))</span>
 6985           goto unknown_stream;
 6986 
 6987         gst_qtdemux_stream_check_and_change_stsd_index (demux, stream);
 6988 
 6989         if (stream-&gt;new_caps) {
 6990           gst_qtdemux_configure_stream (demux, stream);
 6991         }
 6992 
 6993         /* Put data in a buffer, set timestamps, caps, ... */
 6994         sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 6995 
 6996         if (G_LIKELY (!(STREAM_IS_EOS (stream)))) {
<span class="line-modified"> 6997         GST_DEBUG_OBJECT (demux, &quot;stream : %&quot; GST_FOURCC_FORMAT,</span>
 6998               GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));
 6999 
 7000           dts = QTSAMPLE_DTS (stream, sample);
 7001           pts = QTSAMPLE_PTS (stream, sample);
 7002           duration = QTSAMPLE_DUR_DTS (stream, sample, dts);
<span class="line-modified"> 7003         keyframe = QTSAMPLE_KEYFRAME (stream, sample);</span>
 7004 
 7005           /* check for segment end */
 7006           if (G_UNLIKELY (demux-&gt;segment.stop != -1
<span class="line-modified"> 7007                   &amp;&amp; demux-&gt;segment.stop &lt;= pts &amp;&amp; stream-&gt;on_keyframe)) {</span>

 7008             GST_DEBUG_OBJECT (demux, &quot;we reached the end of our segment.&quot;);
 7009             stream-&gt;time_position = GST_CLOCK_TIME_NONE;        /* this means EOS */
 7010 
 7011             /* skip this data, stream is EOS */
 7012             gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
 7013             demux-&gt;offset += demux-&gt;neededbytes;
 7014 
 7015             /* check if all streams are eos */
 7016             ret = GST_FLOW_EOS;
<span class="line-modified"> 7017             for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified"> 7018               if (!STREAM_IS_EOS (demux-&gt;streams[i])) {</span>
 7019                 ret = GST_FLOW_OK;
 7020                 break;
 7021               }
 7022             }
 7023           } else {
 7024             GstBuffer *outbuf;
 7025 
 7026             outbuf =
 7027                 gst_adapter_take_buffer (demux-&gt;adapter, demux-&gt;neededbytes);
 7028 
 7029             /* FIXME: should either be an assert or a plain check */
 7030             g_return_val_if_fail (outbuf != NULL, GST_FLOW_ERROR);
 7031 
<span class="line-modified"> 7032         ret = gst_qtdemux_decorate_and_push_buffer (demux, stream, outbuf,</span>
 7033                 dts, pts, duration, keyframe, dts, demux-&gt;offset);
 7034           }
 7035 
<span class="line-modified"> 7036         /* combine flows */</span>
 7037           ret = gst_qtdemux_combine_flows (demux, stream, ret);
 7038         } else {
 7039           /* skip this data, stream is EOS */
 7040           gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
 7041         }
 7042 
 7043         stream-&gt;sample_index++;
 7044         stream-&gt;offset_in_sample = 0;
 7045 
 7046         /* update current offset and figure out size of next buffer */
 7047         GST_LOG_OBJECT (demux, &quot;increasing offset %&quot; G_GUINT64_FORMAT &quot; by %u&quot;,
 7048             demux-&gt;offset, demux-&gt;neededbytes);
 7049         demux-&gt;offset += demux-&gt;neededbytes;
 7050         GST_LOG_OBJECT (demux, &quot;offset is now %&quot; G_GUINT64_FORMAT,
 7051             demux-&gt;offset);
 7052 
 7053 
 7054         if (ret == GST_FLOW_EOS) {
 7055           GST_DEBUG_OBJECT (demux, &quot;All streams are EOS, signal upstream&quot;);
 7056           demux-&gt;neededbytes = -1;
</pre>
<hr />
<pre>
 7144 
 7145   GST_DEBUG_OBJECT (sinkpad, &quot;activating pull&quot;);
 7146   return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE);
 7147 
 7148 activate_push:
 7149   {
 7150     GST_DEBUG_OBJECT (sinkpad, &quot;activating push&quot;);
 7151     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
 7152   }
 7153 }
 7154 
 7155 static gboolean
 7156 qtdemux_sink_activate_mode (GstPad * sinkpad, GstObject * parent,
 7157     GstPadMode mode, gboolean active)
 7158 {
 7159   gboolean res;
 7160   GstQTDemux *demux = GST_QTDEMUX (parent);
 7161 
 7162   switch (mode) {
 7163     case GST_PAD_MODE_PUSH:
<span class="line-modified"> 7164   demux-&gt;pullbased = FALSE;</span>
 7165       res = TRUE;
 7166       break;
 7167     case GST_PAD_MODE_PULL:
 7168       if (active) {
 7169         demux-&gt;pullbased = TRUE;
 7170         res = gst_pad_start_task (sinkpad, (GstTaskFunction) gst_qtdemux_loop,
 7171             sinkpad, NULL);
 7172       } else {
 7173         res = gst_pad_stop_task (sinkpad);
 7174       }
 7175       break;
 7176     default:
 7177       res = FALSE;
 7178       break;
 7179   }
 7180   return res;
 7181 }
 7182 
 7183 #ifdef HAVE_ZLIB
 7184 static void *
</pre>
<hr />
<pre>
 7194   z.opaque = NULL;
 7195 
 7196   if ((ret = inflateInit (&amp;z)) != Z_OK) {
 7197     GST_ERROR (&quot;inflateInit() returned %d&quot;, ret);
 7198     return NULL;
 7199   }
 7200 
 7201   z.next_in = z_buffer;
 7202   z.avail_in = z_length;
 7203 
 7204   buffer = (guint8 *) g_malloc (*length);
 7205   z.avail_out = *length;
 7206   z.next_out = (Bytef *) buffer;
 7207   do {
 7208     ret = inflate (&amp;z, Z_NO_FLUSH);
 7209     if (ret == Z_STREAM_END) {
 7210       break;
 7211     } else if (ret != Z_OK) {
 7212       GST_WARNING (&quot;inflate() returned %d&quot;, ret);
 7213       break;
<span class="line-modified"> 7214   }</span>
 7215 
 7216     *length += 4096;
 7217     buffer = (guint8 *) g_realloc (buffer, *length);
 7218     z.next_out = (Bytef *) (buffer + z.total_out);
 7219     z.avail_out += 4096;
 7220   } while (z.avail_in &gt; 0);
 7221 
 7222   if (ret != Z_STREAM_END) {
 7223     g_free (buffer);
 7224     buffer = NULL;
 7225     *length = 0;
 7226   } else {
 7227     *length = z.total_out;
 7228   }
 7229 
 7230   inflateEnd (&amp;z);
 7231 
 7232   return buffer;
 7233 }
 7234 #endif /* HAVE_ZLIB */
</pre>
<hr />
<pre>
 7267 #ifdef HAVE_ZLIB
 7268       case FOURCC_zlib:{
 7269         guint uncompressed_length;
 7270         guint compressed_length;
 7271         guint8 *buf;
 7272         guint32 cmvd_len;
 7273 
 7274         cmvd_len = QT_UINT32 ((guint8 *) cmvd-&gt;data);
 7275         if (cmvd_len &lt; 12)
 7276           goto invalid_compression;
 7277 
 7278         uncompressed_length = QT_UINT32 ((guint8 *) cmvd-&gt;data + 8);
 7279         compressed_length = cmvd_len - 12;
 7280         GST_LOG (&quot;length = %u&quot;, uncompressed_length);
 7281 
 7282         buf =
 7283             (guint8 *) qtdemux_inflate ((guint8 *) cmvd-&gt;data + 12,
 7284             compressed_length, &amp;uncompressed_length);
 7285 
 7286         if (buf) {
<span class="line-modified"> 7287         qtdemux-&gt;moov_node_compressed = qtdemux-&gt;moov_node;</span>
<span class="line-modified"> 7288         qtdemux-&gt;moov_node = g_node_new (buf);</span>
 7289 
<span class="line-modified"> 7290         qtdemux_parse_node (qtdemux, qtdemux-&gt;moov_node, buf,</span>
<span class="line-modified"> 7291             uncompressed_length);</span>
 7292         }
 7293         break;
 7294       }
 7295 #endif /* HAVE_ZLIB */
 7296       default:
 7297         GST_WARNING_OBJECT (qtdemux, &quot;unknown or unhandled header compression &quot;
 7298             &quot;type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (method));
 7299         break;
 7300     }
 7301   }
 7302   return TRUE;
 7303 
 7304   /* ERRORS */
 7305 invalid_compression:
 7306   {
 7307     GST_ERROR_OBJECT (qtdemux, &quot;invalid compressed header&quot;);
 7308     return FALSE;
 7309   }
 7310 }
 7311 
</pre>
<hr />
<pre>
 7578       {
 7579         GST_DEBUG_OBJECT (qtdemux, &quot;parsing meta atom&quot;);
 7580 
 7581         /* You are reading this correctly. QTFF specifies that the
 7582          * metadata atom is a short atom, whereas ISO BMFF specifies
 7583          * it&#39;s a full atom. But since so many people are doing things
 7584          * differently, we actually peek into the atom to see which
 7585          * variant it is */
 7586         if (length &lt; 16) {
 7587           GST_LOG_OBJECT (qtdemux, &quot;skipping small %&quot; GST_FOURCC_FORMAT &quot; box&quot;,
 7588               GST_FOURCC_ARGS (fourcc));
 7589           break;
 7590         }
 7591         if (QT_FOURCC (buffer + 12) == FOURCC_hdlr) {
 7592           /* Variant 1: What QTFF specifies. &#39;meta&#39; is a short header which
 7593            * starts with a &#39;hdlr&#39; atom */
 7594           qtdemux_parse_container (qtdemux, node, buffer + 8, end);
 7595         } else if (QT_UINT32 (buffer + 8) == 0x00000000) {
 7596           /* Variant 2: What ISO BMFF specifies. &#39;meta&#39; is a _full_ atom
 7597            * with version/flags both set to zero */
<span class="line-modified"> 7598         qtdemux_parse_container (qtdemux, node, buffer + 12, end);</span>
 7599         } else
 7600           GST_WARNING_OBJECT (qtdemux, &quot;Unknown &#39;meta&#39; atom format&quot;);
 7601         break;
 7602       }
 7603       case FOURCC_mp4s:
 7604       {
 7605         GST_MEMDUMP_OBJECT (qtdemux, &quot;mp4s&quot;, buffer, end - buffer);
 7606         /* Skip 8 byte header, plus 8 byte version + flags + entry_count */
 7607         qtdemux_parse_container (qtdemux, node, buffer + 16, end);
 7608         break;
 7609       }
 7610       case FOURCC_XiTh:
 7611       {
 7612         guint32 version;
 7613         guint32 offset;
 7614 
 7615         if (length &lt; 16) {
 7616           GST_LOG_OBJECT (qtdemux, &quot;skipping small %&quot; GST_FOURCC_FORMAT &quot; box&quot;,
 7617               GST_FOURCC_ARGS (fourcc));
 7618           break;
</pre>
<hr />
<pre>
 7755       if (parser) {
 7756         child_len = QT_UINT32 (buffer);
 7757         if (G_UNLIKELY (child_len &lt; (4 + 4)))
 7758           return NULL;
 7759         /* FIXME: must verify if atom length &lt; parent atom length */
 7760         gst_byte_reader_init (parser, buffer + (4 + 4), child_len - (4 + 4));
 7761       }
 7762       return child;
 7763     }
 7764   }
 7765   return NULL;
 7766 }
 7767 
 7768 static GNode *
 7769 qtdemux_tree_get_sibling_by_type (GNode * node, guint32 fourcc)
 7770 {
 7771   return qtdemux_tree_get_sibling_by_type_full (node, fourcc, NULL);
 7772 }
 7773 
 7774 static void
<span class="line-modified"> 7775 qtdemux_do_allocation (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
 7776 {
 7777 /* FIXME: This can only reliably work if demuxers have a
 7778  * separate streaming thread per srcpad. This should be
 7779  * done in a demuxer base class, which integrates parts
 7780  * of multiqueue
 7781  *
 7782  * https://bugzilla.gnome.org/show_bug.cgi?id=701856
 7783  */
 7784 #if 0
 7785   GstQuery *query;
 7786 
 7787   query = gst_query_new_allocation (stream-&gt;caps, FALSE);
 7788 
 7789   if (!gst_pad_peer_query (stream-&gt;pad, query)) {
 7790     /* not a problem, just debug a little */
 7791     GST_DEBUG_OBJECT (qtdemux, &quot;peer ALLOCATION query failed&quot;);
 7792   }
 7793 
 7794   if (stream-&gt;allocator)
 7795     gst_object_unref (stream-&gt;allocator);
 7796 
 7797   if (gst_query_get_n_allocation_params (query) &gt; 0) {
 7798     /* try the allocator */
 7799     gst_query_parse_nth_allocation_param (query, 0, &amp;stream-&gt;allocator,
 7800         &amp;stream-&gt;params);
 7801     stream-&gt;use_allocator = TRUE;
 7802   } else {
 7803     stream-&gt;allocator = NULL;
 7804     gst_allocation_params_init (&amp;stream-&gt;params);
 7805     stream-&gt;use_allocator = FALSE;
 7806   }
 7807   gst_query_unref (query);
 7808 #endif
 7809 }
 7810 








































































































































 7811 static gboolean
 7812 gst_qtdemux_configure_protected_caps (GstQTDemux * qtdemux,
 7813     QtDemuxStream * stream)
 7814 {
 7815   GstStructure *s;
<span class="line-modified"> 7816   const gchar *selected_system;</span>
 7817 
 7818   g_return_val_if_fail (qtdemux != NULL, FALSE);
 7819   g_return_val_if_fail (stream != NULL, FALSE);
 7820   g_return_val_if_fail (gst_caps_get_size (CUR_STREAM (stream)-&gt;caps) == 1,
 7821       FALSE);
 7822 
 7823   if (stream-&gt;protection_scheme_type != FOURCC_cenc) {
<span class="line-modified"> 7824     GST_ERROR_OBJECT (qtdemux, &quot;unsupported protection scheme&quot;);</span>


 7825     return FALSE;
 7826   }
 7827   if (qtdemux-&gt;protection_system_ids == NULL) {
 7828     GST_ERROR_OBJECT (qtdemux, &quot;stream is protected using cenc, but no &quot;
 7829         &quot;cenc protection system information has been found&quot;);
 7830     return FALSE;
 7831   }
<span class="line-modified"> 7832   g_ptr_array_add (qtdemux-&gt;protection_system_ids, NULL);</span>
<span class="line-modified"> 7833   selected_system = gst_protection_select_system ((const gchar **)</span>
<span class="line-modified"> 7834       qtdemux-&gt;protection_system_ids-&gt;pdata);</span>
<span class="line-modified"> 7835   g_ptr_array_remove_index (qtdemux-&gt;protection_system_ids,</span>
<span class="line-modified"> 7836       qtdemux-&gt;protection_system_ids-&gt;len - 1);</span>





















 7837   if (!selected_system) {
 7838     GST_ERROR_OBJECT (qtdemux, &quot;stream is protected, but no &quot;
 7839         &quot;suitable decryptor element has been found&quot;);
 7840     return FALSE;
 7841   }
 7842 



 7843   s = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);
 7844   if (!gst_structure_has_name (s, &quot;application/x-cenc&quot;)) {
 7845     gst_structure_set (s,
 7846         &quot;original-media-type&quot;, G_TYPE_STRING, gst_structure_get_name (s),
 7847         GST_PROTECTION_SYSTEM_ID_CAPS_FIELD, G_TYPE_STRING, selected_system,
 7848         NULL);
 7849     gst_structure_set_name (s, &quot;application/x-cenc&quot;);
 7850   }
 7851   return TRUE;
 7852 }
 7853 
 7854 static gboolean
<span class="line-modified"> 7855 gst_qtdemux_configure_stream (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
 7856 {
<span class="line-modified"> 7857   if (stream-&gt;subtype == FOURCC_vide) {</span>
<span class="line-modified"> 7858     /* fps is calculated base on the duration of the average framerate since</span>
<span class="line-modified"> 7859      * qt does not have a fixed framerate. */</span>
<span class="line-modified"> 7860     gboolean fps_available = TRUE;</span>
<span class="line-modified"> 7861 </span>
<span class="line-modified"> 7862     if ((stream-&gt;n_samples == 1 &amp;&amp; stream-&gt;first_duration == 0)</span>
<span class="line-modified"> 7863         || (qtdemux-&gt;fragmented &amp;&amp; stream-&gt;n_samples_moof == 1)) {</span>
<span class="line-modified"> 7864       /* still frame */</span>
<span class="line-modified"> 7865       CUR_STREAM (stream)-&gt;fps_n = 0;</span>







 7866       CUR_STREAM (stream)-&gt;fps_d = 1;

 7867     } else {
<span class="line-modified"> 7868       if (stream-&gt;duration == 0 || stream-&gt;n_samples &lt; 2) {</span>
<span class="line-modified"> 7869         CUR_STREAM (stream)-&gt;fps_n = stream-&gt;timescale;</span>
<span class="line-modified"> 7870         CUR_STREAM (stream)-&gt;fps_d = 1;</span>
<span class="line-modified"> 7871         fps_available = FALSE;</span>






 7872       } else {
<span class="line-modified"> 7873         GstClockTime avg_duration;</span>
<span class="line-modified"> 7874         guint64 duration;</span>
<span class="line-modified"> 7875         guint32 n_samples;</span>
<span class="line-removed"> 7876 </span>
<span class="line-removed"> 7877         /* duration and n_samples can be updated for fragmented format</span>
<span class="line-removed"> 7878          * so, framerate of fragmented format is calculated using data in a moof */</span>
<span class="line-removed"> 7879         if (qtdemux-&gt;fragmented &amp;&amp; stream-&gt;n_samples_moof &gt; 0</span>
<span class="line-removed"> 7880             &amp;&amp; stream-&gt;duration_moof &gt; 0) {</span>
<span class="line-removed"> 7881           n_samples = stream-&gt;n_samples_moof;</span>
<span class="line-removed"> 7882           duration = stream-&gt;duration_moof;</span>
<span class="line-removed"> 7883         } else {</span>
<span class="line-removed"> 7884           n_samples = stream-&gt;n_samples;</span>
<span class="line-removed"> 7885           duration = stream-&gt;duration;</span>
<span class="line-removed"> 7886         }</span>
 7887 
<span class="line-modified"> 7888         /* Calculate a framerate, ignoring the first sample which is sometimes truncated */</span>
<span class="line-modified"> 7889         /* stream-&gt;duration is guint64, timescale, n_samples are guint32 */</span>
<span class="line-modified"> 7890         avg_duration =</span>
<span class="line-modified"> 7891             gst_util_uint64_scale_round (duration -</span>
<span class="line-modified"> 7892             stream-&gt;first_duration, GST_SECOND,</span>
<span class="line-modified"> 7893             (guint64) (stream-&gt;timescale) * (n_samples - 1));</span>
 7894 
<span class="line-modified"> 7895         GST_LOG_OBJECT (qtdemux,</span>
<span class="line-modified"> 7896             &quot;Calculating avg sample duration based on stream (or moof) duration %&quot;</span>
<span class="line-modified"> 7897             G_GUINT64_FORMAT</span>
<span class="line-modified"> 7898             &quot; minus first sample %u, leaving %d samples gives %&quot;</span>
<span class="line-modified"> 7899             GST_TIME_FORMAT, duration, stream-&gt;first_duration,</span>
<span class="line-modified"> 7900             n_samples - 1, GST_TIME_ARGS (avg_duration));</span>
 7901 
<span class="line-modified"> 7902         gst_video_guess_framerate (avg_duration, &amp;CUR_STREAM (stream)-&gt;fps_n,</span>
<span class="line-modified"> 7903             &amp;CUR_STREAM (stream)-&gt;fps_d);</span>

 7904 
<span class="line-modified"> 7905         GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified"> 7906             &quot;Calculating framerate, timescale %u gave fps_n %d fps_d %d&quot;,</span>
<span class="line-modified"> 7907             stream-&gt;timescale, CUR_STREAM (stream)-&gt;fps_n,</span>
<span class="line-modified"> 7908             CUR_STREAM (stream)-&gt;fps_d);</span>
<span class="line-removed"> 7909     }</span>
 7910     }










 7911 
 7912     if (CUR_STREAM (stream)-&gt;caps) {
 7913       CUR_STREAM (stream)-&gt;caps =
 7914           gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);
 7915 
<span class="line-modified"> 7916       gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,</span>
<span class="line-modified"> 7917           &quot;width&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;width,</span>
<span class="line-modified"> 7918           &quot;height&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;height, NULL);</span>

 7919 
 7920       /* set framerate if calculated framerate is reliable */
 7921       if (fps_available) {
 7922         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 7923             &quot;framerate&quot;, GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;fps_n,
 7924             CUR_STREAM (stream)-&gt;fps_d, NULL);
 7925       }
 7926 
 7927       /* calculate pixel-aspect-ratio using display width and height */
 7928       GST_DEBUG_OBJECT (qtdemux,
 7929           &quot;video size %dx%d, target display size %dx%d&quot;,
 7930           CUR_STREAM (stream)-&gt;width, CUR_STREAM (stream)-&gt;height,
 7931           stream-&gt;display_width, stream-&gt;display_height);
 7932       /* qt file might have pasp atom */
 7933       if (CUR_STREAM (stream)-&gt;par_w &gt; 0 &amp;&amp; CUR_STREAM (stream)-&gt;par_h &gt; 0) {
 7934         GST_DEBUG_OBJECT (qtdemux, &quot;par %d:%d&quot;, CUR_STREAM (stream)-&gt;par_w,
 7935             CUR_STREAM (stream)-&gt;par_h);
 7936         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;pixel-aspect-ratio&quot;,
 7937             GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;par_w,
 7938             CUR_STREAM (stream)-&gt;par_h, NULL);
</pre>
<hr />
<pre>
 7950         CUR_STREAM (stream)-&gt;par_w = n;
 7951         CUR_STREAM (stream)-&gt;par_h = d;
 7952         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;pixel-aspect-ratio&quot;,
 7953             GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;par_w,
 7954             CUR_STREAM (stream)-&gt;par_h, NULL);
 7955       }
 7956 
 7957       if (CUR_STREAM (stream)-&gt;interlace_mode &gt; 0) {
 7958         if (CUR_STREAM (stream)-&gt;interlace_mode == 1) {
 7959           gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;interlace-mode&quot;,
 7960               G_TYPE_STRING, &quot;progressive&quot;, NULL);
 7961         } else if (CUR_STREAM (stream)-&gt;interlace_mode == 2) {
 7962           gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;interlace-mode&quot;,
 7963               G_TYPE_STRING, &quot;interleaved&quot;, NULL);
 7964           if (CUR_STREAM (stream)-&gt;field_order == 9) {
 7965             gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;field-order&quot;,
 7966                 G_TYPE_STRING, &quot;top-field-first&quot;, NULL);
 7967           } else if (CUR_STREAM (stream)-&gt;field_order == 14) {
 7968             gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;field-order&quot;,
 7969                 G_TYPE_STRING, &quot;bottom-field-first&quot;, NULL);
<span class="line-modified"> 7970       }</span>
<span class="line-modified"> 7971     }</span>
 7972       }
 7973 
 7974       /* Create incomplete colorimetry here if needed */
 7975       if (CUR_STREAM (stream)-&gt;colorimetry.range ||
 7976           CUR_STREAM (stream)-&gt;colorimetry.matrix ||
 7977           CUR_STREAM (stream)-&gt;colorimetry.transfer
 7978           || CUR_STREAM (stream)-&gt;colorimetry.primaries) {
 7979         gchar *colorimetry =
 7980             gst_video_colorimetry_to_string (&amp;CUR_STREAM (stream)-&gt;colorimetry);
 7981         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;colorimetry&quot;,
 7982             G_TYPE_STRING, colorimetry, NULL);
 7983         g_free (colorimetry);
 7984       }
 7985 
 7986       if (stream-&gt;multiview_mode != GST_VIDEO_MULTIVIEW_MODE_NONE) {
 7987         guint par_w = 1, par_h = 1;
 7988 
 7989         if (CUR_STREAM (stream)-&gt;par_w &gt; 0 &amp;&amp; CUR_STREAM (stream)-&gt;par_h &gt; 0) {
 7990           par_w = CUR_STREAM (stream)-&gt;par_w;
 7991           par_h = CUR_STREAM (stream)-&gt;par_h;
</pre>
<hr />
<pre>
 8009   else if (stream-&gt;subtype == FOURCC_soun) {
 8010     if (CUR_STREAM (stream)-&gt;caps) {
 8011       CUR_STREAM (stream)-&gt;caps =
 8012           gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);
 8013       if (CUR_STREAM (stream)-&gt;rate &gt; 0)
 8014         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8015             &quot;rate&quot;, G_TYPE_INT, (int) CUR_STREAM (stream)-&gt;rate, NULL);
 8016       if (CUR_STREAM (stream)-&gt;n_channels &gt; 0)
 8017         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8018             &quot;channels&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;n_channels, NULL);
 8019       if (CUR_STREAM (stream)-&gt;n_channels &gt; 2) {
 8020         /* FIXME: Need to parse the &#39;chan&#39; atom to get channel layouts
 8021          * correctly; this is just the minimum we can do - assume
 8022          * we don&#39;t actually have any channel positions. */
 8023         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8024             &quot;channel-mask&quot;, GST_TYPE_BITMASK, G_GUINT64_CONSTANT (0), NULL);
 8025       }
 8026     }
 8027   }
 8028 


















































 8029   if (stream-&gt;pad) {
 8030     GstCaps *prev_caps = NULL;
 8031 
 8032     GST_PAD_ELEMENT_PRIVATE (stream-&gt;pad) = stream;
 8033     gst_pad_set_event_function (stream-&gt;pad, gst_qtdemux_handle_src_event);
 8034     gst_pad_set_query_function (stream-&gt;pad, gst_qtdemux_handle_src_query);
 8035     gst_pad_set_active (stream-&gt;pad, TRUE);
 8036 
 8037     gst_pad_use_fixed_caps (stream-&gt;pad);
 8038 
 8039     if (stream-&gt;protected) {
 8040       if (!gst_qtdemux_configure_protected_caps (qtdemux, stream)) {
 8041         GST_ERROR_OBJECT (qtdemux,
 8042             &quot;Failed to configure protected stream caps.&quot;);
 8043         return FALSE;
 8044       }
 8045     }
 8046 
 8047     GST_DEBUG_OBJECT (qtdemux, &quot;setting caps %&quot; GST_PTR_FORMAT,
 8048         CUR_STREAM (stream)-&gt;caps);
 8049     if (stream-&gt;new_stream) {
<span class="line-removed"> 8050       gchar *stream_id;</span>
 8051       GstEvent *event;
 8052       GstStreamFlags stream_flags = GST_STREAM_FLAG_NONE;
 8053 
 8054       event =
 8055           gst_pad_get_sticky_event (qtdemux-&gt;sinkpad, GST_EVENT_STREAM_START,
 8056           0);
 8057       if (event) {
 8058         gst_event_parse_stream_flags (event, &amp;stream_flags);
 8059         if (gst_event_parse_group_id (event, &amp;qtdemux-&gt;group_id))
 8060           qtdemux-&gt;have_group_id = TRUE;
<span class="line-modified"> 8061           else</span>
 8062           qtdemux-&gt;have_group_id = FALSE;
 8063         gst_event_unref (event);
 8064       } else if (!qtdemux-&gt;have_group_id) {
 8065         qtdemux-&gt;have_group_id = TRUE;
 8066         qtdemux-&gt;group_id = gst_util_group_id_next ();
 8067       }
 8068 
 8069       stream-&gt;new_stream = FALSE;
<span class="line-modified"> 8070       stream_id =</span>
<span class="line-removed"> 8071           gst_pad_create_stream_id_printf (stream-&gt;pad,</span>
<span class="line-removed"> 8072           GST_ELEMENT_CAST (qtdemux), &quot;%03u&quot;, stream-&gt;track_id);</span>
<span class="line-removed"> 8073       event = gst_event_new_stream_start (stream_id);</span>
 8074       if (qtdemux-&gt;have_group_id)
 8075         gst_event_set_group_id (event, qtdemux-&gt;group_id);
 8076       if (stream-&gt;disabled)
 8077         stream_flags |= GST_STREAM_FLAG_UNSELECT;
 8078       if (CUR_STREAM (stream)-&gt;sparse) {
 8079         stream_flags |= GST_STREAM_FLAG_SPARSE;
 8080       } else {
 8081         stream_flags &amp;= ~GST_STREAM_FLAG_SPARSE;
 8082       }
 8083       gst_event_set_stream_flags (event, stream_flags);
 8084       gst_pad_push_event (stream-&gt;pad, event);
<span class="line-removed"> 8085       g_free (stream_id);</span>
 8086     }
 8087 
 8088     prev_caps = gst_pad_get_current_caps (stream-&gt;pad);
 8089 
 8090     if (CUR_STREAM (stream)-&gt;caps) {
 8091       if (!prev_caps
 8092           || !gst_caps_is_equal_fixed (prev_caps, CUR_STREAM (stream)-&gt;caps)) {
 8093         GST_DEBUG_OBJECT (qtdemux, &quot;setting caps %&quot; GST_PTR_FORMAT,
 8094             CUR_STREAM (stream)-&gt;caps);
 8095         gst_pad_set_caps (stream-&gt;pad, CUR_STREAM (stream)-&gt;caps);
 8096       } else {
 8097         GST_DEBUG_OBJECT (qtdemux, &quot;ignore duplicated caps&quot;);
 8098       }
 8099     } else {
 8100       GST_WARNING_OBJECT (qtdemux, &quot;stream without caps&quot;);
 8101     }
 8102 
 8103     if (prev_caps)
 8104       gst_caps_unref (prev_caps);
 8105     stream-&gt;new_caps = FALSE;
</pre>
<hr />
<pre>
 8116 
 8117   GST_DEBUG_OBJECT (stream-&gt;pad, &quot;Changing stsd index from &#39;%u&#39; to &#39;%u&#39;&quot;,
 8118       stream-&gt;cur_stsd_entry_index, stream-&gt;stsd_sample_description_id);
 8119   if (G_UNLIKELY (stream-&gt;stsd_sample_description_id &gt;=
 8120           stream-&gt;stsd_entries_length)) {
 8121     GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
 8122         (_(&quot;This file is invalid and cannot be played.&quot;)),
 8123         (&quot;New sample description id is out of bounds (%d &gt;= %d)&quot;,
 8124             stream-&gt;stsd_sample_description_id, stream-&gt;stsd_entries_length));
 8125   } else {
 8126     stream-&gt;cur_stsd_entry_index = stream-&gt;stsd_sample_description_id;
 8127     stream-&gt;new_caps = TRUE;
 8128   }
 8129 }
 8130 
 8131 static gboolean
 8132 gst_qtdemux_add_stream (GstQTDemux * qtdemux,
 8133     QtDemuxStream * stream, GstTagList * list)
 8134 {
 8135   gboolean ret = TRUE;
<span class="line-removed"> 8136   /* consistent default for push based mode */</span>
<span class="line-removed"> 8137   gst_segment_init (&amp;stream-&gt;segment, GST_FORMAT_TIME);</span>
 8138 
 8139   if (stream-&gt;subtype == FOURCC_vide) {
 8140     gchar *name = g_strdup_printf (&quot;video_%u&quot;, qtdemux-&gt;n_video_streams);
 8141 
 8142     stream-&gt;pad =
 8143         gst_pad_new_from_static_template (&amp;gst_qtdemux_videosrc_template, name);
 8144     g_free (name);
 8145 
 8146     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8147       gst_object_unref (stream-&gt;pad);
 8148       stream-&gt;pad = NULL;
 8149       ret = FALSE;
 8150       goto done;
 8151     }
 8152 
 8153     qtdemux-&gt;n_video_streams++;
 8154   } else if (stream-&gt;subtype == FOURCC_soun) {
 8155     gchar *name = g_strdup_printf (&quot;audio_%u&quot;, qtdemux-&gt;n_audio_streams);
 8156 
 8157     stream-&gt;pad =
 8158         gst_pad_new_from_static_template (&amp;gst_qtdemux_audiosrc_template, name);
 8159     g_free (name);
 8160     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8161       gst_object_unref (stream-&gt;pad);
 8162       stream-&gt;pad = NULL;
 8163       ret = FALSE;
 8164       goto done;
 8165     }
 8166     qtdemux-&gt;n_audio_streams++;
 8167   } else if (stream-&gt;subtype == FOURCC_strm) {
 8168     GST_DEBUG_OBJECT (qtdemux, &quot;stream type, not creating pad&quot;);
 8169   } else if (stream-&gt;subtype == FOURCC_subp || stream-&gt;subtype == FOURCC_text
<span class="line-modified"> 8170       || stream-&gt;subtype == FOURCC_sbtl || stream-&gt;subtype == FOURCC_subt) {</span>

 8171     gchar *name = g_strdup_printf (&quot;subtitle_%u&quot;, qtdemux-&gt;n_sub_streams);
 8172 
 8173     stream-&gt;pad =
 8174         gst_pad_new_from_static_template (&amp;gst_qtdemux_subsrc_template, name);
 8175     g_free (name);
 8176     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8177       gst_object_unref (stream-&gt;pad);
 8178       stream-&gt;pad = NULL;
 8179       ret = FALSE;
 8180       goto done;
 8181     }
 8182     qtdemux-&gt;n_sub_streams++;
 8183   } else if (CUR_STREAM (stream)-&gt;caps) {
 8184     gchar *name = g_strdup_printf (&quot;video_%u&quot;, qtdemux-&gt;n_video_streams);
 8185 
 8186     stream-&gt;pad =
 8187         gst_pad_new_from_static_template (&amp;gst_qtdemux_videosrc_template, name);
 8188     g_free (name);
 8189     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8190       gst_object_unref (stream-&gt;pad);
</pre>
<hr />
<pre>
 8376 
 8377   /* time-to-sample atom */
 8378   if (!qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stts, &amp;stream-&gt;stts))
 8379     goto corrupt_file;
 8380 
 8381   /* copy atom data into a new buffer for later use */
 8382   stream-&gt;stts.data = g_memdup (stream-&gt;stts.data, stream-&gt;stts.size);
 8383 
 8384   /* skip version + flags */
 8385   if (!gst_byte_reader_skip (&amp;stream-&gt;stts, 1 + 3) ||
 8386       !gst_byte_reader_get_uint32_be (&amp;stream-&gt;stts, &amp;stream-&gt;n_sample_times))
 8387     goto corrupt_file;
 8388   GST_LOG_OBJECT (qtdemux, &quot;%u timestamp blocks&quot;, stream-&gt;n_sample_times);
 8389 
 8390   /* make sure there&#39;s enough data */
 8391   if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stts, stream-&gt;n_sample_times, 8)) {
 8392     stream-&gt;n_sample_times = gst_byte_reader_get_remaining (&amp;stream-&gt;stts) / 8;
 8393     GST_LOG_OBJECT (qtdemux, &quot;overriding to %u timestamp blocks&quot;,
 8394         stream-&gt;n_sample_times);
 8395     if (!stream-&gt;n_sample_times)
<span class="line-modified"> 8396     goto corrupt_file;</span>
 8397   }
 8398 
 8399   /* sync sample atom */
 8400   stream-&gt;stps_present = FALSE;
 8401   if ((stream-&gt;stss_present =
 8402           ! !qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stss,
 8403               &amp;stream-&gt;stss) ? TRUE : FALSE) == TRUE) {
 8404     /* copy atom data into a new buffer for later use */
 8405     stream-&gt;stss.data = g_memdup (stream-&gt;stss.data, stream-&gt;stss.size);
 8406 
 8407     /* skip version + flags */
 8408     if (!gst_byte_reader_skip (&amp;stream-&gt;stss, 1 + 3) ||
 8409         !gst_byte_reader_get_uint32_be (&amp;stream-&gt;stss, &amp;stream-&gt;n_sample_syncs))
 8410       goto corrupt_file;
 8411 
 8412     if (stream-&gt;n_sample_syncs) {
 8413       /* make sure there&#39;s enough data */
 8414       if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stss, stream-&gt;n_sample_syncs, 4))
 8415         goto corrupt_file;
 8416     }
</pre>
<hr />
<pre>
 8544     /* copy atom data into a new buffer for later use */
 8545     stream-&gt;ctts.data = g_memdup (stream-&gt;ctts.data, stream-&gt;ctts.size);
 8546 
 8547     /* skip version + flags */
 8548     if (!gst_byte_reader_skip (&amp;stream-&gt;ctts, 1 + 3)
 8549         || !gst_byte_reader_get_uint32_be (&amp;stream-&gt;ctts,
 8550             &amp;stream-&gt;n_composition_times))
 8551       goto corrupt_file;
 8552 
 8553     /* make sure there&#39;s enough data */
 8554     if (!qt_atom_parser_has_chunks (&amp;stream-&gt;ctts, stream-&gt;n_composition_times,
 8555             4 + 4))
 8556       goto corrupt_file;
 8557 
 8558     /* This is optional, if missing we iterate the ctts */
 8559     if (qtdemux_tree_get_child_by_type_full (stbl, FOURCC_cslg, &amp;cslg)) {
 8560       if (!gst_byte_reader_skip (&amp;cslg, 1 + 3)
 8561           || !gst_byte_reader_get_uint32_be (&amp;cslg, &amp;stream-&gt;cslg_shift)) {
 8562         g_free ((gpointer) cslg.data);
 8563         goto corrupt_file;
<span class="line-modified"> 8564   }</span>
 8565     } else {
 8566       gint32 cslg_least = 0;
 8567       guint num_entries, pos;
 8568       gint i;
 8569 
 8570       pos = gst_byte_reader_get_pos (&amp;stream-&gt;ctts);
 8571       num_entries = stream-&gt;n_composition_times;
 8572 
 8573       stream-&gt;cslg_shift = 0;
 8574 
 8575       for (i = 0; i &lt; num_entries; i++) {
 8576         gint32 offset;
 8577 
 8578         gst_byte_reader_skip_unchecked (&amp;stream-&gt;ctts, 4);
 8579         offset = gst_byte_reader_get_int32_be_unchecked (&amp;stream-&gt;ctts);












 8580 
 8581         if (offset &lt; cslg_least)
 8582           cslg_least = offset;
 8583       }
 8584 
 8585       if (cslg_least &lt; 0)
 8586         stream-&gt;cslg_shift = ABS (cslg_least);
 8587       else
 8588         stream-&gt;cslg_shift = 0;
 8589 
 8590       /* reset the reader so we can generate sample table */
 8591       gst_byte_reader_set_pos (&amp;stream-&gt;ctts, pos);
 8592     }
 8593   } else {
 8594     /* Ensure the cslg_shift value is consistent so we can use it
 8595      * unconditionnally to produce TS and Segment */
 8596     stream-&gt;cslg_shift = 0;
 8597   }
 8598 
 8599   return TRUE;
</pre>
<hr />
<pre>
 8796           goto corrupt_file;
 8797 
 8798         samples_per_chunk = stream-&gt;samples_per_chunk;
 8799         chunk_offset = stream-&gt;chunk_offset;
 8800 
 8801         for (k = stream-&gt;stsc_sample_index; k &lt; samples_per_chunk; k++) {
 8802           GST_LOG_OBJECT (qtdemux, &quot;creating entry %d with offset %&quot;
 8803               G_GUINT64_FORMAT &quot; and size %d&quot;,
 8804               (guint) (cur - samples), chunk_offset, cur-&gt;size);
 8805 
 8806           cur-&gt;offset = chunk_offset;
 8807           chunk_offset += cur-&gt;size;
 8808           cur++;
 8809 
 8810           if (G_UNLIKELY (cur &gt; last)) {
 8811             /* save state */
 8812             stream-&gt;stsc_sample_index = k + 1;
 8813             stream-&gt;chunk_offset = chunk_offset;
 8814             stream-&gt;stsc_chunk_index = j;
 8815             goto done2;
<span class="line-modified"> 8816     }</span>
 8817         }
 8818         stream-&gt;stsc_sample_index = 0;
 8819       }
 8820       stream-&gt;stsc_chunk_index = j;
 8821     }
 8822     stream-&gt;stsc_index++;
 8823   }
 8824 
 8825   if (stream-&gt;chunks_are_samples)
 8826     goto ctts;
 8827 done2:
 8828   {
 8829     guint32 n_sample_times;
 8830 
 8831     n_sample_times = stream-&gt;n_sample_times;
 8832     cur = first;
 8833 
 8834     for (i = stream-&gt;stts_index; i &lt; n_sample_times; i++) {
 8835       guint32 stts_samples;
 8836       gint32 stts_duration;
</pre>
<hr />
<pre>
 8993         cur++;
 8994 
 8995         if (G_UNLIKELY (cur &gt; last)) {
 8996           /* save state */
 8997           stream-&gt;ctts_sample_index = j + 1;
 8998           goto done;
 8999         }
 9000       }
 9001       stream-&gt;ctts_sample_index = 0;
 9002       stream-&gt;ctts_index++;
 9003     }
 9004   }
 9005 done:
 9006   stream-&gt;stbl_index = n;
 9007   /* if index has been completely parsed, free data that is no-longer needed */
 9008   if (n + 1 == stream-&gt;n_samples) {
 9009     gst_qtdemux_stbl_free (stream);
 9010     GST_DEBUG_OBJECT (qtdemux, &quot;parsed all available samples;&quot;);
 9011     if (qtdemux-&gt;pullbased) {
 9012       GST_DEBUG_OBJECT (qtdemux, &quot;checking for more samples&quot;);
<span class="line-modified"> 9013     while (n + 1 == stream-&gt;n_samples)</span>
<span class="line-modified"> 9014       if (qtdemux_add_fragmented_samples (qtdemux) != GST_FLOW_OK)</span>
<span class="line-modified"> 9015         break;</span>
<span class="line-modified"> 9016   }</span>
 9017   }
 9018   GST_OBJECT_UNLOCK (qtdemux);
 9019 
 9020   return TRUE;
 9021 
 9022   /* SUCCESS */
 9023 already_parsed:
 9024   {
 9025     GST_LOG_OBJECT (qtdemux,
 9026         &quot;Tried to parse up to sample %u but this sample has already been parsed&quot;,
 9027         n);
 9028     /* if fragmented, there may be more */
 9029     if (qtdemux-&gt;fragmented &amp;&amp; n == stream-&gt;stbl_index)
 9030       goto done;
 9031     GST_OBJECT_UNLOCK (qtdemux);
 9032     return TRUE;
 9033   }
 9034   /* ERRORS */
 9035 out_of_samples:
 9036   {
</pre>
<hr />
<pre>
 9052 
 9053 /* collect all segment info for @stream.
 9054  */
 9055 static gboolean
 9056 qtdemux_parse_segments (GstQTDemux * qtdemux, QtDemuxStream * stream,
 9057     GNode * trak)
 9058 {
 9059   GNode *edts;
 9060   /* accept edts if they contain gaps at start and there is only
 9061    * one media segment */
 9062   gboolean allow_pushbased_edts = TRUE;
 9063   gint media_segments_count = 0;
 9064 
 9065   /* parse and prepare segment info from the edit list */
 9066   GST_DEBUG_OBJECT (qtdemux, &quot;looking for edit list container&quot;);
 9067   stream-&gt;n_segments = 0;
 9068   stream-&gt;segments = NULL;
 9069   if ((edts = qtdemux_tree_get_child_by_type (trak, FOURCC_edts))) {
 9070     GNode *elst;
 9071     gint n_segments;
<span class="line-modified"> 9072     gint i, count, entry_size;</span>
 9073     guint64 time;
 9074     GstClockTime stime;
 9075     const guint8 *buffer;
 9076     guint8 version;
 9077     guint32 size;
 9078 
 9079     GST_DEBUG_OBJECT (qtdemux, &quot;looking for edit list&quot;);
 9080     if (!(elst = qtdemux_tree_get_child_by_type (edts, FOURCC_elst)))
 9081       goto done;
 9082 
 9083     buffer = elst-&gt;data;
 9084 
 9085     size = QT_UINT32 (buffer);
 9086     /* version, flags, n_segments */
 9087     if (size &lt; 16) {
 9088       GST_WARNING_OBJECT (qtdemux, &quot;Invalid edit list&quot;);
 9089       goto done;
 9090     }
 9091     version = QT_UINT8 (buffer + 8);
 9092     entry_size = (version == 1) ? 20 : 12;
 9093 
 9094     n_segments = QT_UINT32 (buffer + 12);
 9095 
 9096     if (n_segments &gt; 100000 || size &lt; 16 + n_segments * entry_size) {
 9097       GST_WARNING_OBJECT (qtdemux, &quot;Invalid edit list&quot;);
 9098       goto done;
 9099     }
 9100 
 9101     /* we might allocate a bit too much, at least allocate 1 segment */
 9102     stream-&gt;segments = g_new (QtDemuxSegment, MAX (n_segments, 1));
 9103 
 9104     /* segments always start from 0 */
 9105     time = 0;
 9106     stime = 0;
<span class="line-removed"> 9107     count = 0;</span>
 9108     buffer += 16;
<span class="line-modified"> 9109     for (i = 0; i &lt; n_segments; i++) {</span>
 9110       guint64 duration;
 9111       guint64 media_time;
<span class="line-modified"> 9112       gboolean time_valid = TRUE;</span>
 9113       QtDemuxSegment *segment;
 9114       guint32 rate_int;
 9115       GstClockTime media_start = GST_CLOCK_TIME_NONE;
 9116 
<span class="line-modified"> 9117      if (version == 1) {</span>
 9118         media_time = QT_UINT64 (buffer + 8);
 9119         duration = QT_UINT64 (buffer);
 9120         if (media_time == G_MAXUINT64)
<span class="line-modified"> 9121           time_valid = FALSE;</span>
 9122       } else {
 9123         media_time = QT_UINT32 (buffer + 4);
 9124         duration = QT_UINT32 (buffer);
 9125         if (media_time == G_MAXUINT32)
<span class="line-modified"> 9126           time_valid = FALSE;</span>
 9127       }
 9128 
<span class="line-modified"> 9129       if (time_valid)</span>
 9130         media_start = QTSTREAMTIME_TO_GSTTIME (stream, media_time);
 9131 
<span class="line-modified"> 9132       segment = &amp;stream-&gt;segments[count++];</span>
 9133 
 9134       /* time and duration expressed in global timescale */
 9135       segment-&gt;time = stime;
<span class="line-modified"> 9136       /* add non scaled values so we don&#39;t cause roundoff errors */</span>
<span class="line-modified"> 9137       if (duration || media_start == GST_CLOCK_TIME_NONE) {</span>
<span class="line-modified"> 9138       time += duration;</span>



 9139         stime = QTTIME_TO_GSTTIME (qtdemux, time);
 9140         segment-&gt;duration = stime - segment-&gt;time;
 9141       } else {
 9142         /* zero duration does not imply media_start == media_stop
<span class="line-modified"> 9143          * but, only specify media_start.*/</span>
<span class="line-modified"> 9144         stime = QTTIME_TO_GSTTIME (qtdemux, qtdemux-&gt;duration);</span>
<span class="line-modified"> 9145         if (GST_CLOCK_TIME_IS_VALID (stime) &amp;&amp; time_valid</span>
<span class="line-modified"> 9146             &amp;&amp; stime &gt;= media_start) {</span>
<span class="line-removed"> 9147           segment-&gt;duration = stime - media_start;</span>
<span class="line-removed"> 9148         } else {</span>
<span class="line-removed"> 9149           segment-&gt;duration = GST_CLOCK_TIME_NONE;</span>
<span class="line-removed"> 9150         }</span>
 9151       }
 9152       segment-&gt;stop_time = stime;
 9153 
 9154       segment-&gt;trak_media_start = media_time;
 9155       /* media_time expressed in stream timescale */
<span class="line-modified"> 9156       if (time_valid) {</span>
 9157         segment-&gt;media_start = media_start;
<span class="line-modified"> 9158         segment-&gt;media_stop = segment-&gt;media_start + segment-&gt;duration;</span>

 9159         media_segments_count++;
 9160       } else {
 9161         segment-&gt;media_start = GST_CLOCK_TIME_NONE;
 9162         segment-&gt;media_stop = GST_CLOCK_TIME_NONE;
 9163       }
 9164       rate_int = QT_UINT32 (buffer + ((version == 1) ? 16 : 8));
 9165 
 9166       if (rate_int &lt;= 1) {
 9167         /* 0 is not allowed, some programs write 1 instead of the floating point
 9168          * value */
 9169         GST_WARNING_OBJECT (qtdemux, &quot;found suspicious rate %&quot; G_GUINT32_FORMAT,
 9170             rate_int);
 9171         segment-&gt;rate = 1;
 9172       } else {
 9173         segment-&gt;rate = rate_int / 65536.0;
 9174       }
 9175 
 9176       GST_DEBUG_OBJECT (qtdemux, &quot;created segment %d time %&quot; GST_TIME_FORMAT
 9177           &quot;, duration %&quot; GST_TIME_FORMAT &quot;, media_start %&quot; GST_TIME_FORMAT
 9178           &quot; (%&quot; G_GUINT64_FORMAT &quot;) , media_stop %&quot; GST_TIME_FORMAT
 9179           &quot; stop_time %&quot; GST_TIME_FORMAT &quot; rate %g, (%d) timescale %u&quot;,
<span class="line-modified"> 9180           i, GST_TIME_ARGS (segment-&gt;time),</span>
 9181           GST_TIME_ARGS (segment-&gt;duration),
 9182           GST_TIME_ARGS (segment-&gt;media_start), media_time,
 9183           GST_TIME_ARGS (segment-&gt;media_stop),
 9184           GST_TIME_ARGS (segment-&gt;stop_time), segment-&gt;rate, rate_int,
 9185           stream-&gt;timescale);
<span class="line-modified"> 9186       if (segment-&gt;stop_time &gt; qtdemux-&gt;segment.stop) {</span>

 9187         GST_WARNING_OBJECT (qtdemux, &quot;Segment %d &quot;
 9188             &quot; extends to %&quot; GST_TIME_FORMAT
<span class="line-modified"> 9189             &quot; past the end of the file duration %&quot; GST_TIME_FORMAT</span>
<span class="line-modified"> 9190             &quot; it will be truncated&quot;, i, GST_TIME_ARGS (segment-&gt;stop_time),</span>

 9191             GST_TIME_ARGS (qtdemux-&gt;segment.stop));
<span class="line-modified"> 9192         qtdemux-&gt;segment.stop = segment-&gt;stop_time;</span>
<span class="line-modified"> 9193     }</span>
 9194 
 9195       buffer += entry_size;
 9196     }
<span class="line-modified"> 9197     GST_DEBUG_OBJECT (qtdemux, &quot;found %d segments&quot;, count);</span>
<span class="line-modified"> 9198     stream-&gt;n_segments = count;</span>
 9199     if (media_segments_count != 1)
 9200       allow_pushbased_edts = FALSE;
 9201   }
 9202 done:
 9203 
 9204   /* push based does not handle segments, so act accordingly here,
 9205    * and warn if applicable */
 9206   if (!qtdemux-&gt;pullbased &amp;&amp; !allow_pushbased_edts) {
 9207     GST_WARNING_OBJECT (qtdemux, &quot;streaming; discarding edit list segments&quot;);
 9208     /* remove and use default one below, we stream like it anyway */
 9209     g_free (stream-&gt;segments);
 9210     stream-&gt;segments = NULL;
 9211     stream-&gt;n_segments = 0;
 9212   }
 9213 
 9214   /* no segments, create one to play the complete trak */
 9215   if (stream-&gt;n_segments == 0) {
 9216     GstClockTime stream_duration =
 9217         QTSTREAMTIME_TO_GSTTIME (stream, stream-&gt;duration);
 9218 
</pre>
<hr />
<pre>
 9571   } else {
 9572     GST_FIXME_OBJECT (qtdemux, &quot;Unhandled transformation matrix values&quot;);
 9573   }
 9574 }
 9575 
 9576 /* Parses the boxes defined in ISO/IEC 14496-12 that enable support for
 9577  * protected streams (sinf, frma, schm and schi); if the protection scheme is
 9578  * Common Encryption (cenc), the function will also parse the tenc box (defined
 9579  * in ISO/IEC 23001-7). @container points to the node that contains these boxes
 9580  * (typically an enc[v|a|t|s] sample entry); the function will set
 9581  * @original_fmt to the fourcc of the original unencrypted stream format.
 9582  * Returns TRUE if successful; FALSE otherwise. */
 9583 static gboolean
 9584 qtdemux_parse_protection_scheme_info (GstQTDemux * qtdemux,
 9585     QtDemuxStream * stream, GNode * container, guint32 * original_fmt)
 9586 {
 9587   GNode *sinf;
 9588   GNode *frma;
 9589   GNode *schm;
 9590   GNode *schi;



 9591 
 9592   g_return_val_if_fail (qtdemux != NULL, FALSE);
 9593   g_return_val_if_fail (stream != NULL, FALSE);
 9594   g_return_val_if_fail (container != NULL, FALSE);
 9595   g_return_val_if_fail (original_fmt != NULL, FALSE);
 9596 
 9597   sinf = qtdemux_tree_get_child_by_type (container, FOURCC_sinf);
 9598   if (G_UNLIKELY (!sinf)) {
 9599     if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
 9600       GST_ERROR_OBJECT (qtdemux, &quot;sinf box does not contain schi box, which is &quot;
 9601           &quot;mandatory for Common Encryption&quot;);
 9602       return FALSE;
 9603     }
 9604     return TRUE;
 9605   }
 9606 
 9607   frma = qtdemux_tree_get_child_by_type (sinf, FOURCC_frma);
 9608   if (G_UNLIKELY (!frma)) {
 9609     GST_ERROR_OBJECT (qtdemux, &quot;sinf box does not contain mandatory frma box&quot;);
 9610     return FALSE;
</pre>
<hr />
<pre>
 9617   schm = qtdemux_tree_get_child_by_type (sinf, FOURCC_schm);
 9618   if (!schm) {
 9619     GST_DEBUG_OBJECT (qtdemux, &quot;sinf box does not contain schm box&quot;);
 9620     return FALSE;
 9621   }
 9622   stream-&gt;protection_scheme_type = QT_FOURCC ((const guint8 *) schm-&gt;data + 12);
 9623   stream-&gt;protection_scheme_version =
 9624       QT_UINT32 ((const guint8 *) schm-&gt;data + 16);
 9625 
 9626   GST_DEBUG_OBJECT (qtdemux,
 9627       &quot;protection_scheme_type: %&quot; GST_FOURCC_FORMAT &quot;, &quot;
 9628       &quot;protection_scheme_version: %#010x&quot;,
 9629       GST_FOURCC_ARGS (stream-&gt;protection_scheme_type),
 9630       stream-&gt;protection_scheme_version);
 9631 
 9632   schi = qtdemux_tree_get_child_by_type (sinf, FOURCC_schi);
 9633   if (!schi) {
 9634     GST_DEBUG_OBJECT (qtdemux, &quot;sinf box does not contain schi box&quot;);
 9635     return FALSE;
 9636   }














 9637   if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
<span class="line-modified"> 9638     QtDemuxCencSampleSetInfo *info;</span>
<span class="line-removed"> 9639     GNode *tenc;</span>
<span class="line-removed"> 9640     const guint8 *tenc_data;</span>
<span class="line-removed"> 9641     guint32 isEncrypted;</span>
 9642     guint8 iv_size;
 9643     const guint8 *default_kid;
<span class="line-removed"> 9644     GstBuffer *kid_buf;</span>
<span class="line-removed"> 9645 </span>
<span class="line-removed"> 9646     if (G_UNLIKELY (!stream-&gt;protection_scheme_info))</span>
<span class="line-removed"> 9647       stream-&gt;protection_scheme_info =</span>
<span class="line-removed"> 9648           g_malloc0 (sizeof (QtDemuxCencSampleSetInfo));</span>
<span class="line-removed"> 9649 </span>
<span class="line-removed"> 9650     info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;</span>
 9651 
 9652     tenc = qtdemux_tree_get_child_by_type (schi, FOURCC_tenc);
 9653     if (!tenc) {
 9654       GST_ERROR_OBJECT (qtdemux, &quot;schi box does not contain tenc box, &quot;
 9655           &quot;which is mandatory for Common Encryption&quot;);
 9656       return FALSE;
 9657     }
 9658     tenc_data = (const guint8 *) tenc-&gt;data + 12;
<span class="line-modified"> 9659     isEncrypted = QT_UINT24 (tenc_data);</span>
 9660     iv_size = QT_UINT8 (tenc_data + 3);
 9661     default_kid = (tenc_data + 4);
<span class="line-modified"> 9662     kid_buf = gst_buffer_new_allocate (NULL, 16, NULL);</span>
<span class="line-modified"> 9663     gst_buffer_fill (kid_buf, 0, default_kid, 16);</span>
<span class="line-modified"> 9664     if (info-&gt;default_properties)</span>
<span class="line-modified"> 9665       gst_structure_free (info-&gt;default_properties);</span>
<span class="line-modified"> 9666     info-&gt;default_properties =</span>
<span class="line-modified"> 9667         gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-modified"> 9668         &quot;iv_size&quot;, G_TYPE_UINT, iv_size,</span>
<span class="line-modified"> 9669         &quot;encrypted&quot;, G_TYPE_BOOLEAN, (isEncrypted == 1),</span>
<span class="line-modified"> 9670         &quot;kid&quot;, GST_TYPE_BUFFER, kid_buf, NULL);</span>
<span class="line-modified"> 9671     GST_DEBUG_OBJECT (qtdemux, &quot;default sample properties: &quot;</span>
<span class="line-modified"> 9672         &quot;is_encrypted=%u, iv_size=%u&quot;, isEncrypted, iv_size);</span>
<span class="line-modified"> 9673     gst_buffer_unref (kid_buf);</span>



















 9674   }

 9675   return TRUE;
 9676 }
 9677 







 9678 /* parse the traks.
 9679  * With each track we associate a new QtDemuxStream that contains all the info
 9680  * about the trak.
 9681  * traks that do not decode to something (like strm traks) will not have a pad.
 9682  */
 9683 static gboolean
 9684 qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
 9685 {
 9686   GstByteReader tkhd;
 9687   int offset;
 9688   GNode *mdia;
 9689   GNode *mdhd;
 9690   GNode *hdlr;
 9691   GNode *minf;
 9692   GNode *stbl;
 9693   GNode *stsd;
 9694   GNode *mp4a;
 9695   GNode *mp4v;
 9696   GNode *esds;
 9697   GNode *tref;
 9698   GNode *udta;
 9699   GNode *svmi;
 9700 
 9701   QtDemuxStream *stream = NULL;
<span class="line-removed"> 9702   gboolean new_stream = FALSE;</span>
 9703   const guint8 *stsd_data;
 9704   const guint8 *stsd_entry_data;
 9705   guint remaining_stsd_len;
 9706   guint stsd_entry_count;
 9707   guint stsd_index;
 9708   guint16 lang_code;            /* quicktime lang code or packed iso code */
 9709   guint32 version;
 9710   guint32 tkhd_flags = 0;
 9711   guint8 tkhd_version = 0;
 9712   guint32 w = 0, h = 0;
 9713   guint value_size, stsd_len, len;
 9714   guint32 track_id;
 9715   guint32 dummy;
 9716 
 9717   GST_DEBUG_OBJECT (qtdemux, &quot;parse_trak&quot;);
 9718 
 9719   if (!qtdemux_tree_get_child_by_type_full (trak, FOURCC_tkhd, &amp;tkhd)
 9720       || !gst_byte_reader_get_uint8 (&amp;tkhd, &amp;tkhd_version)
 9721       || !gst_byte_reader_get_uint24_be (&amp;tkhd, &amp;tkhd_flags))
 9722     goto corrupt_file;
 9723 
 9724   /* pick between 64 or 32 bits */
 9725   value_size = tkhd_version == 1 ? 8 : 4;
 9726   if (!gst_byte_reader_skip (&amp;tkhd, value_size * 2) ||
 9727       !gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;track_id))
 9728     goto corrupt_file;
 9729 
<span class="line-modified"> 9730   if (!qtdemux-&gt;got_moov) {</span>
<span class="line-modified"> 9731     if (qtdemux_find_stream (qtdemux, track_id))</span>
<span class="line-modified"> 9732       goto existing_stream;</span>
<span class="line-modified"> 9733     stream = _create_stream ();</span>
<span class="line-modified"> 9734     stream-&gt;track_id = track_id;</span>
<span class="line-modified"> 9735     new_stream = TRUE;</span>
<span class="line-removed"> 9736   } else {</span>
<span class="line-removed"> 9737     stream = qtdemux_find_stream (qtdemux, track_id);</span>
<span class="line-removed"> 9738     if (!stream) {</span>
<span class="line-removed"> 9739       GST_WARNING_OBJECT (qtdemux, &quot;Stream not found, going to ignore it&quot;);</span>
<span class="line-removed"> 9740       goto skip_track;</span>
<span class="line-removed"> 9741     }</span>
 9742 
<span class="line-removed"> 9743     /* reset reused stream */</span>
<span class="line-removed"> 9744     gst_qtdemux_stream_reset (qtdemux, stream);</span>
<span class="line-removed"> 9745   }</span>
 9746   /* need defaults for fragments */
 9747   qtdemux_parse_trex (qtdemux, stream, &amp;dummy, &amp;dummy, &amp;dummy);
 9748 
 9749   if ((tkhd_flags &amp; 1) == 0)
 9750     stream-&gt;disabled = TRUE;
 9751 
 9752 #ifdef GSTREAMER_LITE
 9753   // set track_enabled based on bit 0 of flags
 9754   stream-&gt;track_enabled = (gboolean)(tkhd_flags &amp; 0x000001);
 9755 #endif // GSTREAMER_LITE
 9756 
 9757   GST_LOG_OBJECT (qtdemux, &quot;track[tkhd] version/flags/id: 0x%02x/%06x/%u&quot;,
 9758       tkhd_version, tkhd_flags, stream-&gt;track_id);
 9759 
 9760   if (!(mdia = qtdemux_tree_get_child_by_type (trak, FOURCC_mdia)))
 9761     goto corrupt_file;
 9762 
 9763   if (!(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mdhd))) {
 9764     /* be nice for some crooked mjp2 files that use mhdr for mdhd */
 9765     if (qtdemux-&gt;major_brand != FOURCC_mjp2 ||
 9766         !(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mhdr)))
 9767       goto corrupt_file;
 9768   }
 9769 
 9770   len = QT_UINT32 ((guint8 *) mdhd-&gt;data);
 9771   version = QT_UINT32 ((guint8 *) mdhd-&gt;data + 8);
 9772   GST_LOG_OBJECT (qtdemux, &quot;track version/flags: %08x&quot;, version);
 9773   if (version == 0x01000000) {
<span class="line-modified"> 9774     if (len &lt; 38)</span>
 9775       goto corrupt_file;
 9776     stream-&gt;timescale = QT_UINT32 ((guint8 *) mdhd-&gt;data + 28);
 9777     stream-&gt;duration = QT_UINT64 ((guint8 *) mdhd-&gt;data + 32);
<span class="line-modified"> 9778     lang_code = QT_UINT16 ((guint8 *) mdhd-&gt;data + 36);</span>
 9779   } else {
 9780     if (len &lt; 30)
 9781       goto corrupt_file;
 9782     stream-&gt;timescale = QT_UINT32 ((guint8 *) mdhd-&gt;data + 20);
 9783     stream-&gt;duration = QT_UINT32 ((guint8 *) mdhd-&gt;data + 24);
 9784     lang_code = QT_UINT16 ((guint8 *) mdhd-&gt;data + 28);
 9785   }
 9786 
 9787   if (lang_code &lt; 0x400) {
 9788     qtdemux_lang_map_qt_code_to_iso (stream-&gt;lang_id, lang_code);
 9789   } else if (lang_code == 0x7fff) {
 9790     stream-&gt;lang_id[0] = 0;     /* unspecified */
 9791   } else {
 9792     stream-&gt;lang_id[0] = 0x60 + ((lang_code &gt;&gt; 10) &amp; 0x1F);
 9793     stream-&gt;lang_id[1] = 0x60 + ((lang_code &gt;&gt; 5) &amp; 0x1F);
 9794     stream-&gt;lang_id[2] = 0x60 + (lang_code &amp; 0x1F);
 9795     stream-&gt;lang_id[3] = 0;
 9796   }
 9797 
 9798   GST_LOG_OBJECT (qtdemux, &quot;track timescale: %&quot; G_GUINT32_FORMAT,
</pre>
<hr />
<pre>
 9823   /* fragmented files may have bogus duration in moov */
 9824   if (!qtdemux-&gt;fragmented &amp;&amp;
 9825       qtdemux-&gt;duration != G_MAXINT64 &amp;&amp; stream-&gt;duration != G_MAXINT32) {
 9826     guint64 tdur1, tdur2;
 9827 
 9828     /* don&#39;t overflow */
 9829     tdur1 = stream-&gt;timescale * (guint64) qtdemux-&gt;duration;
 9830     tdur2 = qtdemux-&gt;timescale * (guint64) stream-&gt;duration;
 9831 
 9832     /* HACK:
 9833      * some of those trailers, nowadays, have prologue images that are
 9834      * themselves video tracks as well. I haven&#39;t really found a way to
 9835      * identify those yet, except for just looking at their duration. */
 9836     if (tdur1 != 0 &amp;&amp; (tdur2 * 10 / tdur1) &lt; 2) {
 9837       GST_WARNING_OBJECT (qtdemux,
 9838           &quot;Track shorter than 20%% (%&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT32_FORMAT
 9839           &quot; vs. %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT32_FORMAT &quot;) of the stream &quot;
 9840           &quot;found, assuming preview image or something; skipping track&quot;,
 9841           stream-&gt;duration, stream-&gt;timescale, qtdemux-&gt;duration,
 9842           qtdemux-&gt;timescale);
<span class="line-modified"> 9843       if (new_stream)</span>
<span class="line-removed"> 9844         gst_qtdemux_stream_free (qtdemux, stream);</span>
 9845       return TRUE;
 9846     }
 9847   }
 9848 
 9849   if (!(hdlr = qtdemux_tree_get_child_by_type (mdia, FOURCC_hdlr)))
 9850     goto corrupt_file;
 9851 
 9852   GST_LOG_OBJECT (qtdemux, &quot;track type: %&quot; GST_FOURCC_FORMAT,
 9853       GST_FOURCC_ARGS (QT_FOURCC ((guint8 *) hdlr-&gt;data + 12)));
 9854 
 9855   len = QT_UINT32 ((guint8 *) hdlr-&gt;data);
 9856   if (len &gt;= 20)
 9857     stream-&gt;subtype = QT_FOURCC ((guint8 *) hdlr-&gt;data + 16);
 9858   GST_LOG_OBJECT (qtdemux, &quot;track subtype: %&quot; GST_FOURCC_FORMAT,
 9859       GST_FOURCC_ARGS (stream-&gt;subtype));
 9860 
 9861   if (!(minf = qtdemux_tree_get_child_by_type (mdia, FOURCC_minf)))
 9862     goto corrupt_file;
 9863 
 9864   if (!(stbl = qtdemux_tree_get_child_by_type (minf, FOURCC_stbl)))
</pre>
<hr />
<pre>
 9921       goto corrupt_file;
 9922 
 9923     if (!gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;w)
 9924         || !gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;h))
 9925       goto corrupt_file;
 9926 
 9927     qtdemux_inspect_transformation_matrix (qtdemux, stream, matrix,
 9928         &amp;stream-&gt;stream_tags);
 9929   }
 9930 
 9931   /* parse stsd */
 9932   if (!(stsd = qtdemux_tree_get_child_by_type (stbl, FOURCC_stsd)))
 9933     goto corrupt_file;
 9934   stsd_data = (const guint8 *) stsd-&gt;data;
 9935 
 9936   /* stsd should at least have one entry */
 9937   stsd_len = QT_UINT32 (stsd_data);
 9938   if (stsd_len &lt; 24) {
 9939     /* .. but skip stream with empty stsd produced by some Vivotek cameras */
 9940     if (stream-&gt;subtype == FOURCC_vivo) {
<span class="line-modified"> 9941       if (new_stream)</span>
<span class="line-removed"> 9942         gst_qtdemux_stream_free (qtdemux, stream);</span>
 9943       return TRUE;
 9944     } else {
<span class="line-modified"> 9945     goto corrupt_file;</span>
 9946     }
 9947   }
 9948 
 9949   stream-&gt;stsd_entries_length = stsd_entry_count = QT_UINT32 (stsd_data + 12);
 9950   stream-&gt;stsd_entries = g_new0 (QtDemuxStreamStsdEntry, stsd_entry_count);
 9951 #ifdef GSTREAMER_LITE
 9952   // Even if we check stsd header length (stsd_len) to make sure we have at least
 9953   // one entry, we still might have actual entry count set to 0. g_new0() will
 9954   // return NULL if fail or count is 0.
 9955   if (stream-&gt;stsd_entries == NULL) {
 9956     goto corrupt_file;
 9957   }
 9958 #endif // GSTREAMER_LITE
 9959   GST_LOG_OBJECT (qtdemux, &quot;stsd len:           %d&quot;, stsd_len);
 9960   GST_LOG_OBJECT (qtdemux, &quot;stsd entry count:   %u&quot;, stsd_entry_count);
 9961 
 9962   stsd_entry_data = stsd_data + 16;
 9963   remaining_stsd_len = stsd_len - 16;
 9964   for (stsd_index = 0; stsd_index &lt; stsd_entry_count; stsd_index++) {
 9965     guint32 fourcc;
 9966     gchar *codec = NULL;
 9967     QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[stsd_index];
 9968 
<span class="line-modified"> 9969   /* and that entry should fit within stsd */</span>
 9970     len = QT_UINT32 (stsd_entry_data);
 9971     if (len &gt; remaining_stsd_len)
<span class="line-modified"> 9972     goto corrupt_file;</span>
 9973 
 9974     entry-&gt;fourcc = fourcc = QT_FOURCC (stsd_entry_data + 4);
<span class="line-modified"> 9975   GST_LOG_OBJECT (qtdemux, &quot;stsd type:          %&quot; GST_FOURCC_FORMAT,</span>
 9976         GST_FOURCC_ARGS (entry-&gt;fourcc));
<span class="line-modified"> 9977   GST_LOG_OBJECT (qtdemux, &quot;stsd type len:      %d&quot;, len);</span>
 9978 
 9979     if ((fourcc == FOURCC_drms) || (fourcc == FOURCC_drmi))
<span class="line-modified"> 9980     goto error_encrypted;</span>
 9981 
 9982     if (fourcc == FOURCC_encv || fourcc == FOURCC_enca) {
 9983       /* FIXME this looks wrong, there might be multiple children
 9984        * with the same type */
 9985       GNode *enc = qtdemux_tree_get_child_by_type (stsd, fourcc);
 9986       stream-&gt;protected = TRUE;
 9987       if (!qtdemux_parse_protection_scheme_info (qtdemux, stream, enc, &amp;fourcc))
 9988         GST_ERROR_OBJECT (qtdemux, &quot;Failed to parse protection scheme info&quot;);
 9989     }
 9990 
<span class="line-modified"> 9991   if (stream-&gt;subtype == FOURCC_vide) {</span>
 9992       GNode *colr;
 9993       GNode *fiel;
 9994       GNode *pasp;
<span class="line-modified"> 9995     gboolean gray;</span>
<span class="line-modified"> 9996     gint depth, palette_size, palette_count;</span>
<span class="line-modified"> 9997     guint32 *palette_data = NULL;</span>
 9998 
 9999       entry-&gt;sampled = TRUE;
10000 
<span class="line-modified">10001     stream-&gt;display_width = w &gt;&gt; 16;</span>
<span class="line-modified">10002     stream-&gt;display_height = h &gt;&gt; 16;</span>
10003 
<span class="line-modified">10004     offset = 16;</span>
10005       if (len &lt; 86)             /* TODO verify */
<span class="line-modified">10006       goto corrupt_file;</span>
10007 
10008       entry-&gt;width = QT_UINT16 (stsd_entry_data + offset + 16);
10009       entry-&gt;height = QT_UINT16 (stsd_entry_data + offset + 18);
10010       entry-&gt;fps_n = 0;         /* this is filled in later */
10011       entry-&gt;fps_d = 0;         /* this is filled in later */
10012       entry-&gt;bits_per_sample = QT_UINT16 (stsd_entry_data + offset + 66);
10013       entry-&gt;color_table_id = QT_UINT16 (stsd_entry_data + offset + 68);
10014 
10015       /* if color_table_id is 0, ctab atom must follow; however some files
10016        * produced by TMPEGEnc have color_table_id = 0 and no ctab atom, so
10017        * if color table is not present we&#39;ll correct the value */
10018       if (entry-&gt;color_table_id == 0 &amp;&amp;
10019           (len &lt; 90
10020               || QT_FOURCC (stsd_entry_data + offset + 70) != FOURCC_ctab)) {
10021         entry-&gt;color_table_id = -1;
10022       }
10023 
<span class="line-modified">10024     GST_LOG_OBJECT (qtdemux, &quot;width %d, height %d, bps %d, color table id %d&quot;,</span>
10025           entry-&gt;width, entry-&gt;height, entry-&gt;bits_per_sample,
10026           entry-&gt;color_table_id);
10027 
10028       depth = entry-&gt;bits_per_sample;
10029 
<span class="line-modified">10030     /* more than 32 bits means grayscale */</span>
<span class="line-modified">10031     gray = (depth &gt; 32);</span>
<span class="line-modified">10032     /* low 32 bits specify the depth  */</span>
<span class="line-modified">10033     depth &amp;= 0x1F;</span>
10034 
<span class="line-modified">10035     /* different number of palette entries is determined by depth. */</span>
<span class="line-modified">10036     palette_count = 0;</span>
<span class="line-modified">10037     if ((depth == 1) || (depth == 2) || (depth == 4) || (depth == 8))</span>
<span class="line-modified">10038       palette_count = (1 &lt;&lt; depth);</span>
<span class="line-modified">10039     palette_size = palette_count * 4;</span>
10040 
10041       if (entry-&gt;color_table_id) {
<span class="line-modified">10042       switch (palette_count) {</span>
<span class="line-modified">10043         case 0:</span>
<span class="line-modified">10044           break;</span>
<span class="line-modified">10045         case 2:</span>
<span class="line-modified">10046           palette_data = g_memdup (ff_qt_default_palette_2, palette_size);</span>
<span class="line-modified">10047           break;</span>
<span class="line-modified">10048         case 4:</span>
<span class="line-modified">10049           palette_data = g_memdup (ff_qt_default_palette_4, palette_size);</span>
<span class="line-modified">10050           break;</span>
<span class="line-modified">10051         case 16:</span>
<span class="line-modified">10052           if (gray)</span>
10053               palette_data =
10054                   g_memdup (ff_qt_grayscale_palette_16, palette_size);
<span class="line-modified">10055           else</span>
<span class="line-modified">10056             palette_data = g_memdup (ff_qt_default_palette_16, palette_size);</span>
<span class="line-modified">10057           break;</span>
<span class="line-modified">10058         case 256:</span>
<span class="line-modified">10059           if (gray)</span>
10060               palette_data =
10061                   g_memdup (ff_qt_grayscale_palette_256, palette_size);
<span class="line-modified">10062           else</span>
<span class="line-modified">10063             palette_data = g_memdup (ff_qt_default_palette_256, palette_size);</span>
<span class="line-modified">10064           break;</span>
<span class="line-modified">10065         default:</span>
<span class="line-modified">10066           GST_ELEMENT_WARNING (qtdemux, STREAM, DEMUX,</span>
<span class="line-modified">10067               (_(&quot;The video in this file might not play correctly.&quot;)),</span>
<span class="line-modified">10068               (&quot;unsupported palette depth %d&quot;, depth));</span>
<span class="line-modified">10069           break;</span>
<span class="line-modified">10070       }</span>
<span class="line-modified">10071     } else {</span>
<span class="line-modified">10072       gint i, j, start, end;</span>
10073 
<span class="line-modified">10074       if (len &lt; 94)</span>
<span class="line-modified">10075         goto corrupt_file;</span>
10076 
<span class="line-modified">10077       /* read table */</span>
10078         start = QT_UINT32 (stsd_entry_data + offset + 70);
10079         palette_count = QT_UINT16 (stsd_entry_data + offset + 74);
10080         end = QT_UINT16 (stsd_entry_data + offset + 76);
10081 
<span class="line-modified">10082       GST_LOG_OBJECT (qtdemux, &quot;start %d, end %d, palette_count %d&quot;,</span>
<span class="line-modified">10083           start, end, palette_count);</span>
10084 
<span class="line-modified">10085       if (end &gt; 255)</span>
<span class="line-modified">10086         end = 255;</span>
<span class="line-modified">10087       if (start &gt; end)</span>
<span class="line-modified">10088         start = end;</span>
10089 
<span class="line-modified">10090       if (len &lt; 94 + (end - start) * 8)</span>
<span class="line-modified">10091         goto corrupt_file;</span>
10092 
<span class="line-modified">10093       /* palette is always the same size */</span>
<span class="line-modified">10094       palette_data = g_malloc0 (256 * 4);</span>
<span class="line-modified">10095       palette_size = 256 * 4;</span>
10096 
<span class="line-modified">10097       for (j = 0, i = start; i &lt;= end; j++, i++) {</span>
<span class="line-modified">10098         guint32 a, r, g, b;</span>
10099 
10100           a = QT_UINT16 (stsd_entry_data + offset + 78 + (j * 8));
10101           r = QT_UINT16 (stsd_entry_data + offset + 80 + (j * 8));
10102           g = QT_UINT16 (stsd_entry_data + offset + 82 + (j * 8));
10103           b = QT_UINT16 (stsd_entry_data + offset + 84 + (j * 8));
10104 
<span class="line-modified">10105         palette_data[i] = ((a &amp; 0xff00) &lt;&lt; 16) | ((r &amp; 0xff00) &lt;&lt; 8) |</span>
<span class="line-modified">10106             (g &amp; 0xff00) | (b &gt;&gt; 8);</span>

10107       }
<span class="line-removed">10108     }</span>
10109 
10110       if (entry-&gt;caps)
10111         gst_caps_unref (entry-&gt;caps);
10112 
10113       entry-&gt;caps =
10114           qtdemux_video_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
10115           &amp;codec);
10116       if (G_UNLIKELY (!entry-&gt;caps)) {
<span class="line-modified">10117       g_free (palette_data);</span>
<span class="line-modified">10118       goto unknown_stream;</span>
<span class="line-modified">10119     }</span>
10120 
<span class="line-modified">10121     if (codec) {</span>
10122         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">10123           GST_TAG_VIDEO_CODEC, codec, NULL);</span>
<span class="line-modified">10124       g_free (codec);</span>
<span class="line-modified">10125       codec = NULL;</span>
<span class="line-modified">10126     }</span>
10127 
<span class="line-modified">10128     if (palette_data) {</span>
<span class="line-modified">10129       GstStructure *s;</span>
10130 
10131         if (entry-&gt;rgb8_palette)
10132           gst_memory_unref (entry-&gt;rgb8_palette);
10133         entry-&gt;rgb8_palette = gst_memory_new_wrapped (GST_MEMORY_FLAG_READONLY,
<span class="line-modified">10134           palette_data, palette_size, 0, palette_size, palette_data, g_free);</span>
10135 
10136         s = gst_caps_get_structure (entry-&gt;caps, 0);
10137 
<span class="line-modified">10138       /* non-raw video has a palette_data property. raw video has the palette as</span>
<span class="line-modified">10139        * an extra plane that we append to the output buffers before we push</span>
<span class="line-modified">10140        * them*/</span>
<span class="line-modified">10141       if (!gst_structure_has_name (s, &quot;video/x-raw&quot;)) {</span>
<span class="line-modified">10142         GstBuffer *palette;</span>
10143 
<span class="line-modified">10144         palette = gst_buffer_new ();</span>
10145           gst_buffer_append_memory (palette, entry-&gt;rgb8_palette);
10146           entry-&gt;rgb8_palette = NULL;
10147 
10148           gst_caps_set_simple (entry-&gt;caps, &quot;palette_data&quot;,
<span class="line-modified">10149             GST_TYPE_BUFFER, palette, NULL);</span>
<span class="line-modified">10150         gst_buffer_unref (palette);</span>




10151       }
<span class="line-removed">10152     } else if (palette_count != 0) {</span>
<span class="line-removed">10153       GST_ELEMENT_WARNING (qtdemux, STREAM, NOT_IMPLEMENTED,</span>
<span class="line-removed">10154           (NULL), (&quot;Unsupported palette depth %d&quot;, depth));</span>
<span class="line-removed">10155     }</span>
10156 
<span class="line-modified">10157     GST_LOG_OBJECT (qtdemux, &quot;frame count:   %u&quot;,</span>
10158           QT_UINT16 (stsd_entry_data + offset + 32));
10159 
<span class="line-modified">10160     esds = NULL;</span>
<span class="line-modified">10161     pasp = NULL;</span>
10162       colr = NULL;
10163       fiel = NULL;
<span class="line-modified">10164     /* pick &#39;the&#39; stsd child */</span>
10165       mp4v = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">10166       if (!stream-&gt;protected) {</span>
<span class="line-modified">10167         if (QTDEMUX_TREE_NODE_FOURCC (mp4v) != fourcc) {</span>






10168           mp4v = NULL;
<span class="line-modified">10169         }</span>
<span class="line-removed">10170       } else {</span>
<span class="line-removed">10171         if (QTDEMUX_TREE_NODE_FOURCC (mp4v) != FOURCC_encv) {</span>
10172           mp4v = NULL;
<span class="line-removed">10173         }</span>
10174       }
10175 
<span class="line-modified">10176     if (mp4v) {</span>
<span class="line-modified">10177       esds = qtdemux_tree_get_child_by_type (mp4v, FOURCC_esds);</span>
<span class="line-modified">10178       pasp = qtdemux_tree_get_child_by_type (mp4v, FOURCC_pasp);</span>
10179         colr = qtdemux_tree_get_child_by_type (mp4v, FOURCC_colr);
10180         fiel = qtdemux_tree_get_child_by_type (mp4v, FOURCC_fiel);
<span class="line-modified">10181     }</span>
10182 
<span class="line-modified">10183     if (pasp) {</span>
<span class="line-modified">10184       const guint8 *pasp_data = (const guint8 *) pasp-&gt;data;</span>
10185         gint len = QT_UINT32 (pasp_data);
10186 
10187         if (len == 16) {
10188           CUR_STREAM (stream)-&gt;par_w = QT_UINT32 (pasp_data + 8);
10189           CUR_STREAM (stream)-&gt;par_h = QT_UINT32 (pasp_data + 12);
<span class="line-modified">10190     } else {</span>
10191           CUR_STREAM (stream)-&gt;par_w = 0;
10192           CUR_STREAM (stream)-&gt;par_h = 0;
<span class="line-modified">10193     }</span>
10194       } else {
10195         CUR_STREAM (stream)-&gt;par_w = 0;
10196         CUR_STREAM (stream)-&gt;par_h = 0;
10197       }
10198 
10199       if (fiel) {
10200         const guint8 *fiel_data = (const guint8 *) fiel-&gt;data;
10201         gint len = QT_UINT32 (fiel_data);
10202 
10203         if (len == 10) {
10204           CUR_STREAM (stream)-&gt;interlace_mode = GST_READ_UINT8 (fiel_data + 8);
10205           CUR_STREAM (stream)-&gt;field_order = GST_READ_UINT8 (fiel_data + 9);
10206         }
10207       }
10208 
10209       if (colr) {
10210         const guint8 *colr_data = (const guint8 *) colr-&gt;data;
10211         gint len = QT_UINT32 (colr_data);
10212 
10213         if (len == 19 || len == 18) {
</pre>
<hr />
<pre>
10268                 break;
10269               case 9:
10270                 CUR_STREAM (stream)-&gt;colorimetry.matrix =
10271                     GST_VIDEO_COLOR_MATRIX_BT2020;
10272                 break;
10273               default:
10274                 break;
10275             }
10276 
10277             CUR_STREAM (stream)-&gt;colorimetry.range =
10278                 full_range ? GST_VIDEO_COLOR_RANGE_0_255 :
10279                 GST_VIDEO_COLOR_RANGE_16_235;
10280           } else {
10281             GST_DEBUG_OBJECT (qtdemux, &quot;Unsupported color type&quot;);
10282           }
10283         } else {
10284           GST_WARNING_OBJECT (qtdemux, &quot;Invalid colr atom size&quot;);
10285         }
10286       }
10287 
<span class="line-modified">10288     if (esds) {</span>
10289 #ifdef GSTREAMER_LITE
10290         if (!gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
10291                                       stream-&gt;stream_tags))
10292             goto corrupt_file;
10293 #else
10294         gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
10295             stream-&gt;stream_tags);
10296 #endif // GSTREAMER_LITE
<span class="line-modified">10297     } else {</span>
<span class="line-modified">10298       switch (fourcc) {</span>
<span class="line-modified">10299         case FOURCC_H264:</span>
<span class="line-modified">10300         case FOURCC_avc1:</span>
<span class="line-modified">10301         case FOURCC_avc3:</span>
<span class="line-modified">10302         {</span>
10303             gint len = QT_UINT32 (stsd_entry_data) - 0x56;
10304             const guint8 *avc_data = stsd_entry_data + 0x56;
10305 
<span class="line-modified">10306           /* find avcC */</span>
<span class="line-modified">10307           while (len &gt;= 0x8) {</span>
<span class="line-modified">10308             gint size;</span>
10309 
<span class="line-modified">10310             if (QT_UINT32 (avc_data) &lt;= len)</span>
<span class="line-modified">10311               size = QT_UINT32 (avc_data) - 0x8;</span>
<span class="line-modified">10312             else</span>
<span class="line-modified">10313               size = len - 0x8;</span>
10314 
<span class="line-modified">10315             if (size &lt; 1)</span>
<span class="line-modified">10316               /* No real data, so break out */</span>
<span class="line-modified">10317               break;</span>
10318 
<span class="line-modified">10319             switch (QT_FOURCC (avc_data + 0x4)) {</span>
<span class="line-modified">10320               case FOURCC_avcC:</span>
<span class="line-modified">10321               {</span>
<span class="line-modified">10322                 /* parse, if found */</span>
<span class="line-modified">10323                 GstBuffer *buf;</span>
10324 
<span class="line-modified">10325                 GST_DEBUG_OBJECT (qtdemux, &quot;found avcC codec_data in stsd&quot;);</span>
10326 
<span class="line-modified">10327                 /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">10328                  * are the fourcc, the next 1 byte is the version, and the</span>
<span class="line-modified">10329                  * subsequent bytes are profile_tier_level structure like data. */</span>
10330                   gst_codec_utils_h264_caps_set_level_and_profile (entry-&gt;caps,
<span class="line-modified">10331                     avc_data + 8 + 1, size - 1);</span>
<span class="line-modified">10332                 buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">10333                 gst_buffer_fill (buf, 0, avc_data + 0x8, size);</span>
10334                   gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">10335                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">10336                 gst_buffer_unref (buf);</span>
10337 
<span class="line-modified">10338                 break;</span>
<span class="line-modified">10339               }</span>
<span class="line-modified">10340               case FOURCC_strf:</span>
<span class="line-modified">10341               {</span>
<span class="line-modified">10342                 GstBuffer *buf;</span>
10343 
<span class="line-modified">10344                 GST_DEBUG_OBJECT (qtdemux, &quot;found strf codec_data in stsd&quot;);</span>
10345 
<span class="line-modified">10346                 /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">10347                  * are the fourcc, next 40 bytes are BITMAPINFOHEADER,</span>
<span class="line-modified">10348                  * next 1 byte is the version, and the</span>
<span class="line-modified">10349                  * subsequent bytes are sequence parameter set like data. */</span>
10350 
10351                   size -= 40;   /* we&#39;ll be skipping BITMAPINFOHEADER */
<span class="line-modified">10352                 if (size &gt; 1) {</span>
10353                     gst_codec_utils_h264_caps_set_level_and_profile
10354                         (entry-&gt;caps, avc_data + 8 + 40 + 1, size - 1);
10355 
<span class="line-modified">10356                   buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">10357                   gst_buffer_fill (buf, 0, avc_data + 8 + 40, size);</span>
10358                     gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">10359                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">10360                   gst_buffer_unref (buf);</span>


10361                 }
<span class="line-modified">10362                 break;</span>
<span class="line-modified">10363               }</span>
<span class="line-modified">10364               case FOURCC_btrt:</span>
<span class="line-removed">10365               {</span>
<span class="line-removed">10366                 guint avg_bitrate, max_bitrate;</span>
10367 
<span class="line-modified">10368                 /* bufferSizeDB, maxBitrate and avgBitrate - 4 bytes each */</span>
<span class="line-modified">10369                 if (size &lt; 12)</span>
<span class="line-modified">10370                   break;</span>
10371 
<span class="line-modified">10372                 max_bitrate = QT_UINT32 (avc_data + 0xc);</span>
<span class="line-modified">10373                 avg_bitrate = QT_UINT32 (avc_data + 0x10);</span>
10374 
<span class="line-modified">10375                 if (!max_bitrate &amp;&amp; !avg_bitrate)</span>
<span class="line-modified">10376                   break;</span>
10377 
<span class="line-modified">10378                 /* Some muxers seem to swap the average and maximum bitrates</span>
<span class="line-modified">10379                  * (I&#39;m looking at you, YouTube), so we swap for sanity. */</span>
<span class="line-modified">10380                 if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; avg_bitrate) {</span>
<span class="line-modified">10381                   guint temp = avg_bitrate;</span>
10382 
<span class="line-modified">10383                   avg_bitrate = max_bitrate;</span>
<span class="line-modified">10384                   max_bitrate = temp;</span>
<span class="line-modified">10385                 }</span>
10386 
<span class="line-modified">10387                 if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; G_MAXUINT32) {</span>
10388                     gst_tag_list_add (stream-&gt;stream_tags,
10389                         GST_TAG_MERGE_REPLACE, GST_TAG_MAXIMUM_BITRATE,
10390                         max_bitrate, NULL);
<span class="line-modified">10391                 }</span>
<span class="line-modified">10392                 if (avg_bitrate &gt; 0 &amp;&amp; avg_bitrate &lt; G_MAXUINT32) {</span>
10393                     gst_tag_list_add (stream-&gt;stream_tags,
10394                         GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE, avg_bitrate,
10395                         NULL);



10396                 }
10397 
<span class="line-modified">10398                 break;</span>

10399               }
10400 
<span class="line-modified">10401               default:</span>
<span class="line-modified">10402                 break;</span>
10403             }
10404 
<span class="line-modified">10405             len -= size + 8;</span>
<span class="line-removed">10406             avc_data += size + 8;</span>
10407           }
<span class="line-modified">10408 </span>
<span class="line-modified">10409           break;</span>
<span class="line-modified">10410         }</span>
<span class="line-modified">10411         case FOURCC_H265:</span>
<span class="line-removed">10412         case FOURCC_hvc1:</span>
<span class="line-removed">10413         case FOURCC_hev1:</span>
<span class="line-removed">10414         {</span>
10415             gint len = QT_UINT32 (stsd_entry_data) - 0x56;
10416             const guint8 *hevc_data = stsd_entry_data + 0x56;
10417 
<span class="line-modified">10418           /* find hevc */</span>
<span class="line-modified">10419           while (len &gt;= 0x8) {</span>
<span class="line-modified">10420             gint size;</span>
10421 
<span class="line-modified">10422             if (QT_UINT32 (hevc_data) &lt;= len)</span>
<span class="line-modified">10423               size = QT_UINT32 (hevc_data) - 0x8;</span>
<span class="line-modified">10424             else</span>
<span class="line-modified">10425               size = len - 0x8;</span>
10426 
<span class="line-modified">10427             if (size &lt; 1)</span>
<span class="line-modified">10428               /* No real data, so break out */</span>
<span class="line-modified">10429               break;</span>
10430 
<span class="line-modified">10431             switch (QT_FOURCC (hevc_data + 0x4)) {</span>
<span class="line-modified">10432               case FOURCC_hvcC:</span>
<span class="line-modified">10433               {</span>
<span class="line-modified">10434                 /* parse, if found */</span>
<span class="line-modified">10435                 GstBuffer *buf;</span>
10436 
10437                   GST_DEBUG_OBJECT (qtdemux, &quot;found hvcC codec_data in stsd&quot;);
10438 
<span class="line-modified">10439                 /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">10440                  * are the fourcc, the next 1 byte is the version, and the</span>
<span class="line-modified">10441                  * subsequent bytes are sequence parameter set like data. */</span>
<span class="line-modified">10442                 gst_codec_utils_h265_caps_set_level_tier_and_profile</span>
10443                       (entry-&gt;caps, hevc_data + 8 + 1, size - 1);
10444 
<span class="line-modified">10445                 buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">10446                 gst_buffer_fill (buf, 0, hevc_data + 0x8, size);</span>
10447                   gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">10448                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">10449                 gst_buffer_unref (buf);</span>
<span class="line-modified">10450                 break;</span>



10451               }
<span class="line-modified">10452               default:</span>
<span class="line-modified">10453                 break;</span>
10454             }
<span class="line-modified">10455             len -= size + 8;</span>
<span class="line-removed">10456             hevc_data += size + 8;</span>
10457           }
<span class="line-modified">10458           break;</span>
<span class="line-modified">10459         }</span>
<span class="line-modified">10460         case FOURCC_mp4v:</span>
<span class="line-modified">10461         case FOURCC_MP4V:</span>
<span class="line-removed">10462         case FOURCC_fmp4:</span>
<span class="line-removed">10463         case FOURCC_FMP4:</span>
10464           case FOURCC_xvid:
10465           case FOURCC_XVID:
<span class="line-modified">10466         {</span>
<span class="line-modified">10467           GNode *glbl;</span>
10468 
<span class="line-modified">10469           GST_DEBUG_OBJECT (qtdemux, &quot;found %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">10470               GST_FOURCC_ARGS (fourcc));</span>
10471 
<span class="line-modified">10472           /* codec data might be in glbl extension atom */</span>
<span class="line-modified">10473           glbl = mp4v ?</span>
<span class="line-modified">10474               qtdemux_tree_get_child_by_type (mp4v, FOURCC_glbl) : NULL;</span>
<span class="line-modified">10475           if (glbl) {</span>
<span class="line-modified">10476             guint8 *data;</span>
<span class="line-modified">10477             GstBuffer *buf;</span>
<span class="line-modified">10478             gint len;</span>
<span class="line-modified">10479 </span>
<span class="line-modified">10480             GST_DEBUG_OBJECT (qtdemux, &quot;found glbl data in stsd&quot;);</span>
<span class="line-modified">10481             data = glbl-&gt;data;</span>
<span class="line-modified">10482             len = QT_UINT32 (data);</span>
<span class="line-modified">10483             if (len &gt; 0x8) {</span>
<span class="line-modified">10484               len -= 0x8;</span>
<span class="line-modified">10485               buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">10486               gst_buffer_fill (buf, 0, data + 8, len);</span>
10487                 gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">10488                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">10489               gst_buffer_unref (buf);</span>

10490             }

10491           }
<span class="line-modified">10492           break;</span>
<span class="line-modified">10493         }</span>
<span class="line-modified">10494         case FOURCC_mjp2:</span>
<span class="line-modified">10495         {</span>
<span class="line-modified">10496           /* see annex I of the jpeg2000 spec */</span>
<span class="line-modified">10497           GNode *jp2h, *ihdr, *colr, *mjp2, *field, *prefix, *cmap, *cdef;</span>
<span class="line-modified">10498           const guint8 *data;</span>
<span class="line-modified">10499           const gchar *colorspace = NULL;</span>
<span class="line-modified">10500           gint ncomp = 0;</span>
<span class="line-modified">10501           guint32 ncomp_map = 0;</span>
<span class="line-modified">10502           gint32 *comp_map = NULL;</span>
<span class="line-modified">10503           guint32 nchan_def = 0;</span>
<span class="line-modified">10504           gint32 *chan_def = NULL;</span>
<span class="line-modified">10505 </span>
<span class="line-removed">10506           GST_DEBUG_OBJECT (qtdemux, &quot;found mjp2&quot;);</span>
<span class="line-removed">10507           /* some required atoms */</span>
10508             mjp2 = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">10509           if (!mjp2)</span>
<span class="line-modified">10510             break;</span>
<span class="line-modified">10511           jp2h = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2h);</span>
<span class="line-modified">10512           if (!jp2h)</span>
<span class="line-modified">10513             break;</span>
10514 
<span class="line-modified">10515           /* number of components; redundant with info in codestream, but useful</span>
<span class="line-modified">10516              to a muxer */</span>
<span class="line-modified">10517           ihdr = qtdemux_tree_get_child_by_type (jp2h, FOURCC_ihdr);</span>
<span class="line-modified">10518           if (!ihdr || QT_UINT32 (ihdr-&gt;data) != 22)</span>
<span class="line-modified">10519             break;</span>
<span class="line-modified">10520           ncomp = QT_UINT16 (((guint8 *) ihdr-&gt;data) + 16);</span>
10521 
<span class="line-modified">10522           colr = qtdemux_tree_get_child_by_type (jp2h, FOURCC_colr);</span>
<span class="line-modified">10523           if (!colr)</span>
<span class="line-modified">10524             break;</span>
<span class="line-modified">10525           GST_DEBUG_OBJECT (qtdemux, &quot;found colr&quot;);</span>
<span class="line-modified">10526           /* extract colour space info */</span>
<span class="line-modified">10527           if (QT_UINT8 ((guint8 *) colr-&gt;data + 8) == 1) {</span>
<span class="line-modified">10528             switch (QT_UINT32 ((guint8 *) colr-&gt;data + 11)) {</span>
<span class="line-modified">10529               case 16:</span>
<span class="line-modified">10530                 colorspace = &quot;sRGB&quot;;</span>
<span class="line-modified">10531                 break;</span>
<span class="line-modified">10532               case 17:</span>
<span class="line-modified">10533                 colorspace = &quot;GRAY&quot;;</span>
<span class="line-modified">10534                 break;</span>
<span class="line-modified">10535               case 18:</span>
<span class="line-modified">10536                 colorspace = &quot;sYUV&quot;;</span>
<span class="line-modified">10537                 break;</span>
<span class="line-modified">10538               default:</span>
<span class="line-modified">10539                 colorspace = NULL;</span>
<span class="line-modified">10540                 break;</span>

10541             }
<span class="line-modified">10542           }</span>
<span class="line-modified">10543           if (!colorspace)</span>
<span class="line-modified">10544             /* colr is required, and only values 16, 17, and 18 are specified,</span>
<span class="line-modified">10545                so error if we have no colorspace */</span>
<span class="line-removed">10546             break;</span>
10547 
<span class="line-modified">10548           /* extract component mapping */</span>
<span class="line-modified">10549           cmap = qtdemux_tree_get_child_by_type (jp2h, FOURCC_cmap);</span>
<span class="line-modified">10550           if (cmap) {</span>
<span class="line-modified">10551             guint32 cmap_len = 0;</span>
<span class="line-modified">10552             int i;</span>
<span class="line-modified">10553             cmap_len = QT_UINT32 (cmap-&gt;data);</span>
<span class="line-modified">10554             if (cmap_len &gt;= 8) {</span>
<span class="line-modified">10555               /* normal box, subtract off header */</span>
<span class="line-modified">10556               cmap_len -= 8;</span>
<span class="line-modified">10557               /* cmap: { u16 cmp; u8 mtyp; u8 pcol; }* */</span>
<span class="line-modified">10558               if (cmap_len % 4 == 0) {</span>
<span class="line-modified">10559                 ncomp_map = (cmap_len / 4);</span>
<span class="line-modified">10560                 comp_map = g_new0 (gint32, ncomp_map);</span>
<span class="line-modified">10561                 for (i = 0; i &lt; ncomp_map; i++) {</span>
<span class="line-modified">10562                   guint16 cmp;</span>
<span class="line-modified">10563                   guint8 mtyp, pcol;</span>
<span class="line-modified">10564                   cmp = QT_UINT16 (((guint8 *) cmap-&gt;data) + 8 + i * 4);</span>
<span class="line-modified">10565                   mtyp = QT_UINT8 (((guint8 *) cmap-&gt;data) + 8 + i * 4 + 2);</span>
<span class="line-modified">10566                   pcol = QT_UINT8 (((guint8 *) cmap-&gt;data) + 8 + i * 4 + 3);</span>
<span class="line-modified">10567                   comp_map[i] = (mtyp &lt;&lt; 24) | (pcol &lt;&lt; 16) | cmp;</span>

10568                 }
10569               }
10570             }
<span class="line-modified">10571           }</span>
<span class="line-modified">10572           /* extract channel definitions */</span>
<span class="line-modified">10573           cdef = qtdemux_tree_get_child_by_type (jp2h, FOURCC_cdef);</span>
<span class="line-modified">10574           if (cdef) {</span>
<span class="line-modified">10575             guint32 cdef_len = 0;</span>
<span class="line-modified">10576             int i;</span>
<span class="line-modified">10577             cdef_len = QT_UINT32 (cdef-&gt;data);</span>
<span class="line-modified">10578             if (cdef_len &gt;= 10) {</span>
<span class="line-modified">10579               /* normal box, subtract off header and len */</span>
<span class="line-modified">10580               cdef_len -= 10;</span>
<span class="line-modified">10581               /* cdef: u16 n; { u16 cn; u16 typ; u16 asoc; }* */</span>
<span class="line-modified">10582               if (cdef_len % 6 == 0) {</span>
<span class="line-modified">10583                 nchan_def = (cdef_len / 6);</span>
<span class="line-modified">10584                 chan_def = g_new0 (gint32, nchan_def);</span>
<span class="line-modified">10585                 for (i = 0; i &lt; nchan_def; i++)</span>
<span class="line-modified">10586                   chan_def[i] = -1;</span>
<span class="line-modified">10587                 for (i = 0; i &lt; nchan_def; i++) {</span>
<span class="line-modified">10588                   guint16 cn, typ, asoc;</span>
<span class="line-modified">10589                   cn = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6);</span>
<span class="line-modified">10590                   typ = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6 + 2);</span>
<span class="line-modified">10591                   asoc = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6 + 4);</span>
<span class="line-modified">10592                   if (cn &lt; nchan_def) {</span>
<span class="line-modified">10593                     switch (typ) {</span>
<span class="line-modified">10594                       case 0:</span>
<span class="line-modified">10595                         chan_def[cn] = asoc;</span>
<span class="line-modified">10596                         break;</span>
<span class="line-removed">10597                       case 1:</span>
10598                           chan_def[cn] = 0;     /* alpha */
<span class="line-modified">10599                         break;</span>
<span class="line-modified">10600                       default:</span>
<span class="line-modified">10601                         chan_def[cn] = -typ;</span>

10602                     }
10603                   }
10604                 }
10605               }
10606             }
<span class="line-removed">10607           }</span>
10608 
10609             gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">10610               &quot;num-components&quot;, G_TYPE_INT, ncomp, NULL);</span>
10611             gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">10612               &quot;colorspace&quot;, G_TYPE_STRING, colorspace, NULL);</span>
<span class="line-modified">10613 </span>
<span class="line-modified">10614           if (comp_map) {</span>
<span class="line-modified">10615             GValue arr = { 0, };</span>
<span class="line-modified">10616             GValue elt = { 0, };</span>
<span class="line-modified">10617             int i;</span>
<span class="line-modified">10618             g_value_init (&amp;arr, GST_TYPE_ARRAY);</span>
<span class="line-modified">10619             g_value_init (&amp;elt, G_TYPE_INT);</span>
<span class="line-modified">10620             for (i = 0; i &lt; ncomp_map; i++) {</span>
<span class="line-modified">10621               g_value_set_int (&amp;elt, comp_map[i]);</span>
<span class="line-modified">10622               gst_value_array_append_value (&amp;arr, &amp;elt);</span>
<span class="line-modified">10623             }</span>
10624               gst_structure_set_value (gst_caps_get_structure (entry-&gt;caps, 0),
<span class="line-modified">10625                 &quot;component-map&quot;, &amp;arr);</span>
<span class="line-modified">10626             g_value_unset (&amp;elt);</span>
<span class="line-modified">10627             g_value_unset (&amp;arr);</span>
<span class="line-modified">10628             g_free (comp_map);</span>
<span class="line-removed">10629           }</span>
<span class="line-removed">10630 </span>
<span class="line-removed">10631           if (chan_def) {</span>
<span class="line-removed">10632             GValue arr = { 0, };</span>
<span class="line-removed">10633             GValue elt = { 0, };</span>
<span class="line-removed">10634             int i;</span>
<span class="line-removed">10635             g_value_init (&amp;arr, GST_TYPE_ARRAY);</span>
<span class="line-removed">10636             g_value_init (&amp;elt, G_TYPE_INT);</span>
<span class="line-removed">10637             for (i = 0; i &lt; nchan_def; i++) {</span>
<span class="line-removed">10638               g_value_set_int (&amp;elt, chan_def[i]);</span>
<span class="line-removed">10639               gst_value_array_append_value (&amp;arr, &amp;elt);</span>
10640             }











10641               gst_structure_set_value (gst_caps_get_structure (entry-&gt;caps, 0),
<span class="line-modified">10642                 &quot;channel-definitions&quot;, &amp;arr);</span>
<span class="line-modified">10643             g_value_unset (&amp;elt);</span>
<span class="line-modified">10644             g_value_unset (&amp;arr);</span>
<span class="line-modified">10645             g_free (chan_def);</span>
<span class="line-modified">10646           }</span>
10647 
<span class="line-modified">10648           /* some optional atoms */</span>
<span class="line-modified">10649           field = qtdemux_tree_get_child_by_type (mjp2, FOURCC_fiel);</span>
<span class="line-modified">10650           prefix = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2x);</span>
10651 
<span class="line-modified">10652           /* indicate possible fields in caps */</span>
<span class="line-modified">10653           if (field) {</span>
<span class="line-modified">10654             data = (guint8 *) field-&gt;data + 8;</span>
<span class="line-modified">10655             if (*data != 1)</span>
10656                 gst_caps_set_simple (entry-&gt;caps, &quot;fields&quot;, G_TYPE_INT,
<span class="line-modified">10657                   (gint) * data, NULL);</span>
<span class="line-modified">10658           }</span>
<span class="line-modified">10659           /* add codec_data if provided */</span>
<span class="line-modified">10660           if (prefix) {</span>
<span class="line-modified">10661             GstBuffer *buf;</span>
<span class="line-modified">10662             gint len;</span>
<span class="line-modified">10663 </span>
<span class="line-modified">10664             GST_DEBUG_OBJECT (qtdemux, &quot;found prefix data in stsd&quot;);</span>
<span class="line-modified">10665             data = prefix-&gt;data;</span>
<span class="line-modified">10666             len = QT_UINT32 (data);</span>
<span class="line-modified">10667             if (len &gt; 0x8) {</span>
<span class="line-modified">10668               len -= 0x8;</span>
<span class="line-modified">10669               buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">10670               gst_buffer_fill (buf, 0, data + 8, len);</span>
10671                 gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">10672                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">10673               gst_buffer_unref (buf);</span>

10674             }

10675           }
<span class="line-modified">10676           break;</span>
<span class="line-modified">10677         }</span>
<span class="line-modified">10678         case FOURCC_SVQ3:</span>
<span class="line-modified">10679         case FOURCC_VP31:</span>
<span class="line-modified">10680         {</span>
<span class="line-removed">10681           GstBuffer *buf;</span>
<span class="line-removed">10682           GstBuffer *seqh = NULL;</span>
10683             const guint8 *gamma_data = NULL;
10684             gint len = QT_UINT32 (stsd_data);   /* FIXME review - why put the whole stsd in codec data? */
10685 
10686             qtdemux_parse_svq3_stsd_data (qtdemux, stsd_entry_data, &amp;gamma_data,
10687                 &amp;seqh);
<span class="line-modified">10688           if (gamma_data) {</span>
10689               gst_caps_set_simple (entry-&gt;caps, &quot;applied-gamma&quot;, G_TYPE_DOUBLE,
<span class="line-modified">10690                 QT_FP32 (gamma_data), NULL);</span>
<span class="line-modified">10691           }</span>
<span class="line-modified">10692           if (seqh) {</span>
<span class="line-modified">10693             /* sorry for the bad name, but we don&#39;t know what this is, other</span>
<span class="line-modified">10694              * than its own fourcc */</span>
10695               gst_caps_set_simple (entry-&gt;caps, &quot;seqh&quot;, GST_TYPE_BUFFER, seqh,
<span class="line-modified">10696                 NULL);</span>
10697               gst_buffer_unref (seqh);
<span class="line-modified">10698           }</span>
10699 
<span class="line-modified">10700           GST_DEBUG_OBJECT (qtdemux, &quot;found codec_data in stsd&quot;);</span>
<span class="line-modified">10701           buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">10702           gst_buffer_fill (buf, 0, stsd_data, len);</span>
10703             gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">10704               &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">10705           gst_buffer_unref (buf);</span>
<span class="line-modified">10706           break;</span>
<span class="line-modified">10707         }</span>
10708           case FOURCC_jpeg:
10709           {
10710             /* https://developer.apple.com/standards/qtff-2001.pdf,
10711              * page 92, &quot;Video Sample Description&quot;, under table 3.1 */
10712             GstByteReader br;
10713 
10714             const gint compressor_offset =
10715                 16 + 4 + 4 * 3 + 2 * 2 + 2 * 4 + 4 + 2;
10716             const gint min_size = compressor_offset + 32 + 2 + 2;
10717             GNode *jpeg;
10718             guint32 len;
10719             guint16 color_table_id = 0;
10720             gboolean ok;
10721 
10722             GST_DEBUG_OBJECT (qtdemux, &quot;found jpeg&quot;);
10723 
10724             /* recover information on interlaced/progressive */
10725             jpeg = qtdemux_tree_get_child_by_type (stsd, FOURCC_jpeg);
10726             if (!jpeg)
10727               break;
</pre>
<hr />
<pre>
10763                             &quot;interlace-mode&quot;, G_TYPE_STRING, &quot;interleaved&quot;,
10764                             NULL);
10765                     } else {
10766                       GST_WARNING_OBJECT (qtdemux,
10767                           &quot;Found fiel tag with invalid fields (%u)&quot;, n_fields);
10768                     }
10769                   }
10770                   offset += size;
10771                 }
10772               } else {
10773                 GST_DEBUG_OBJECT (qtdemux,
10774                     &quot;Color table ID is 0, not trying to get interlacedness&quot;);
10775               }
10776             } else {
10777               GST_WARNING_OBJECT (qtdemux,
10778                   &quot;Length of jpeg chunk is too small, not trying to get interlacedness&quot;);
10779             }
10780 
10781             break;
10782           }
<span class="line-modified">10783         case FOURCC_rle_:</span>
<span class="line-modified">10784         case FOURCC_WRLE:</span>
<span class="line-modified">10785         {</span>
10786             gst_caps_set_simple (entry-&gt;caps,
10787                 &quot;depth&quot;, G_TYPE_INT, QT_UINT16 (stsd_entry_data + offset + 66),
10788                 NULL);
<span class="line-modified">10789           break;</span>
<span class="line-modified">10790         }</span>
<span class="line-modified">10791         case FOURCC_XiTh:</span>
<span class="line-modified">10792         {</span>
<span class="line-modified">10793           GNode *xith, *xdxt;</span>
10794 
<span class="line-modified">10795           GST_DEBUG_OBJECT (qtdemux, &quot;found XiTh&quot;);</span>
10796             xith = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">10797           if (!xith)</span>
<span class="line-modified">10798             break;</span>
10799 
<span class="line-modified">10800           xdxt = qtdemux_tree_get_child_by_type (xith, FOURCC_XdxT);</span>
<span class="line-modified">10801           if (!xdxt)</span>
<span class="line-modified">10802             break;</span>
10803 
<span class="line-modified">10804           GST_DEBUG_OBJECT (qtdemux, &quot;found XdxT node&quot;);</span>
<span class="line-modified">10805           /* collect the headers and store them in a stream list so that we can</span>
<span class="line-modified">10806            * send them out first */</span>
<span class="line-modified">10807           qtdemux_parse_theora_extension (qtdemux, stream, xdxt);</span>
<span class="line-modified">10808           break;</span>
<span class="line-modified">10809         }</span>
<span class="line-modified">10810         case FOURCC_ovc1:</span>
<span class="line-modified">10811         {</span>
<span class="line-modified">10812           GNode *ovc1;</span>
<span class="line-modified">10813           guint8 *ovc1_data;</span>
<span class="line-modified">10814           guint ovc1_len;</span>
<span class="line-modified">10815           GstBuffer *buf;</span>
10816 
<span class="line-modified">10817           GST_DEBUG_OBJECT (qtdemux, &quot;parse ovc1 header&quot;);</span>
10818             ovc1 = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">10819           if (!ovc1)</span>
<span class="line-modified">10820             break;</span>
<span class="line-modified">10821           ovc1_data = ovc1-&gt;data;</span>
<span class="line-modified">10822           ovc1_len = QT_UINT32 (ovc1_data);</span>
<span class="line-modified">10823           if (ovc1_len &lt;= 198) {</span>
<span class="line-modified">10824             GST_WARNING_OBJECT (qtdemux, &quot;Too small ovc1 header, skipping&quot;);</span>







10825             break;
10826           }
<span class="line-removed">10827           buf = gst_buffer_new_and_alloc (ovc1_len - 198);</span>
<span class="line-removed">10828           gst_buffer_fill (buf, 0, ovc1_data + 198, ovc1_len - 198);</span>
<span class="line-removed">10829             gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-removed">10830               &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-removed">10831           gst_buffer_unref (buf);</span>
<span class="line-removed">10832           break;</span>
<span class="line-removed">10833         }</span>
10834           case FOURCC_vc_1:
10835           {
10836             gint len = QT_UINT32 (stsd_entry_data) - 0x56;
10837             const guint8 *vc1_data = stsd_entry_data + 0x56;
10838 
10839             /* find dvc1 */
10840             while (len &gt;= 8) {
10841               gint size;
10842 
10843               if (QT_UINT32 (vc1_data) &lt;= len)
10844                 size = QT_UINT32 (vc1_data) - 8;
10845               else
10846                 size = len - 8;
10847 
10848               if (size &lt; 1)
10849                 /* No real data, so break out */
10850                 break;
10851 
10852               switch (QT_FOURCC (vc1_data + 0x4)) {
10853                 case GST_MAKE_FOURCC (&#39;d&#39;, &#39;v&#39;, &#39;c&#39;, &#39;1&#39;):
10854                 {
10855                   GstBuffer *buf;
10856 
10857                   GST_DEBUG_OBJECT (qtdemux, &quot;found dvc1 codec_data in stsd&quot;);
10858                   buf = gst_buffer_new_and_alloc (size);
10859                   gst_buffer_fill (buf, 0, vc1_data + 8, size);
10860                   gst_caps_set_simple (entry-&gt;caps,
10861                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
10862                   gst_buffer_unref (buf);
10863                   break;
10864                 }
<span class="line-modified">10865         default:</span>
<span class="line-modified">10866           break;</span>
<span class="line-modified">10867       }</span>
10868               len -= size + 8;
10869               vc1_data += size + 8;
<span class="line-modified">10870     }</span>











































































10871             break;
10872           }
10873           default:
10874             break;
10875         }
10876       }
10877 
<span class="line-modified">10878     GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">10879         &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
10880           GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
10881 
<span class="line-modified">10882   } else if (stream-&gt;subtype == FOURCC_soun) {</span>
10883       GNode *wave;
<span class="line-modified">10884     int version, samplesize;</span>
<span class="line-modified">10885     guint16 compression_id;</span>
<span class="line-modified">10886     gboolean amrwb = FALSE;</span>
10887 
10888       offset = 16;
<span class="line-modified">10889     /* sample description entry (16) + sound sample description v0 (20) */</span>
<span class="line-modified">10890     if (len &lt; 36)</span>
<span class="line-modified">10891       goto corrupt_file;</span>
10892 
10893       version = QT_UINT32 (stsd_entry_data + offset);
10894       entry-&gt;n_channels = QT_UINT16 (stsd_entry_data + offset + 8);
10895       samplesize = QT_UINT16 (stsd_entry_data + offset + 10);
10896       compression_id = QT_UINT16 (stsd_entry_data + offset + 12);
10897       entry-&gt;rate = QT_FP32 (stsd_entry_data + offset + 16);
10898 
<span class="line-modified">10899     GST_LOG_OBJECT (qtdemux, &quot;version/rev:      %08x&quot;, version);</span>
<span class="line-modified">10900     GST_LOG_OBJECT (qtdemux, &quot;vendor:           %08x&quot;,</span>
10901           QT_UINT32 (stsd_entry_data + offset + 4));
10902       GST_LOG_OBJECT (qtdemux, &quot;n_channels:       %d&quot;, entry-&gt;n_channels);
<span class="line-modified">10903     GST_LOG_OBJECT (qtdemux, &quot;sample_size:      %d&quot;, samplesize);</span>
<span class="line-modified">10904     GST_LOG_OBJECT (qtdemux, &quot;compression_id:   %d&quot;, compression_id);</span>
<span class="line-modified">10905     GST_LOG_OBJECT (qtdemux, &quot;packet size:      %d&quot;,</span>
10906           QT_UINT16 (stsd_entry_data + offset + 14));
10907       GST_LOG_OBJECT (qtdemux, &quot;sample rate:      %g&quot;, entry-&gt;rate);
10908 
<span class="line-modified">10909     if (compression_id == 0xfffe)</span>
10910         entry-&gt;sampled = TRUE;
10911 
<span class="line-modified">10912     /* first assume uncompressed audio */</span>
10913       entry-&gt;bytes_per_sample = samplesize / 8;
10914       entry-&gt;samples_per_frame = entry-&gt;n_channels;
10915       entry-&gt;bytes_per_frame = entry-&gt;n_channels * entry-&gt;bytes_per_sample;
10916       entry-&gt;samples_per_packet = entry-&gt;samples_per_frame;
10917       entry-&gt;bytes_per_packet = entry-&gt;bytes_per_sample;
10918 
10919       offset = 36;
<span class="line-modified">10920     switch (fourcc) {</span>
<span class="line-modified">10921         /* Yes, these have to be hard-coded */</span>
<span class="line-modified">10922       case FOURCC_MAC6:</span>
<span class="line-modified">10923       {</span>
10924           entry-&gt;samples_per_packet = 6;
10925           entry-&gt;bytes_per_packet = 1;
10926           entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
10927           entry-&gt;bytes_per_sample = 1;
10928           entry-&gt;samples_per_frame = 6 * entry-&gt;n_channels;
<span class="line-modified">10929         break;</span>
<span class="line-modified">10930       }</span>
<span class="line-modified">10931       case FOURCC_MAC3:</span>
<span class="line-modified">10932       {</span>
10933           entry-&gt;samples_per_packet = 3;
10934           entry-&gt;bytes_per_packet = 1;
10935           entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
10936           entry-&gt;bytes_per_sample = 1;
10937           entry-&gt;samples_per_frame = 3 * entry-&gt;n_channels;
<span class="line-modified">10938         break;</span>
<span class="line-modified">10939       }</span>
<span class="line-modified">10940       case FOURCC_ima4:</span>
<span class="line-modified">10941       {</span>
10942           entry-&gt;samples_per_packet = 64;
10943           entry-&gt;bytes_per_packet = 34;
10944           entry-&gt;bytes_per_frame = 34 * entry-&gt;n_channels;
10945           entry-&gt;bytes_per_sample = 2;
10946           entry-&gt;samples_per_frame = 64 * entry-&gt;n_channels;
<span class="line-modified">10947         break;</span>
<span class="line-modified">10948       }</span>
<span class="line-modified">10949       case FOURCC_ulaw:</span>
<span class="line-modified">10950       case FOURCC_alaw:</span>
<span class="line-modified">10951       {</span>
10952           entry-&gt;samples_per_packet = 1;
10953           entry-&gt;bytes_per_packet = 1;
10954           entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
10955           entry-&gt;bytes_per_sample = 1;
10956           entry-&gt;samples_per_frame = 1 * entry-&gt;n_channels;
<span class="line-modified">10957         break;</span>
<span class="line-modified">10958       }</span>
<span class="line-modified">10959       case FOURCC_agsm:</span>
<span class="line-modified">10960       {</span>
10961           entry-&gt;samples_per_packet = 160;
10962           entry-&gt;bytes_per_packet = 33;
10963           entry-&gt;bytes_per_frame = 33 * entry-&gt;n_channels;
10964           entry-&gt;bytes_per_sample = 2;
10965           entry-&gt;samples_per_frame = 160 * entry-&gt;n_channels;
<span class="line-modified">10966         break;</span>



10967       }
<span class="line-removed">10968       default:</span>
<span class="line-removed">10969         break;</span>
<span class="line-removed">10970     }</span>
10971 
<span class="line-modified">10972     if (version == 0x00010000) {</span>
<span class="line-modified">10973       /* sample description entry (16) + sound sample description v1 (20+16) */</span>
<span class="line-modified">10974       if (len &lt; 52)</span>
<span class="line-modified">10975         goto corrupt_file;</span>
10976 
<span class="line-modified">10977       switch (fourcc) {</span>
<span class="line-modified">10978         case FOURCC_twos:</span>
<span class="line-modified">10979         case FOURCC_sowt:</span>
<span class="line-modified">10980         case FOURCC_raw_:</span>
10981           case FOURCC_lpcm:
<span class="line-modified">10982           break;</span>
<span class="line-modified">10983         default:</span>
<span class="line-modified">10984         {</span>
<span class="line-modified">10985           /* only parse extra decoding config for non-pcm audio */</span>
10986             entry-&gt;samples_per_packet = QT_UINT32 (stsd_entry_data + offset);
10987             entry-&gt;bytes_per_packet = QT_UINT32 (stsd_entry_data + offset + 4);
10988             entry-&gt;bytes_per_frame = QT_UINT32 (stsd_entry_data + offset + 8);
10989             entry-&gt;bytes_per_sample = QT_UINT32 (stsd_entry_data + offset + 12);
10990 
<span class="line-modified">10991           GST_LOG_OBJECT (qtdemux, &quot;samples/packet:   %d&quot;,</span>
10992                 entry-&gt;samples_per_packet);
<span class="line-modified">10993           GST_LOG_OBJECT (qtdemux, &quot;bytes/packet:     %d&quot;,</span>
10994                 entry-&gt;bytes_per_packet);
<span class="line-modified">10995           GST_LOG_OBJECT (qtdemux, &quot;bytes/frame:      %d&quot;,</span>
10996                 entry-&gt;bytes_per_frame);
<span class="line-modified">10997           GST_LOG_OBJECT (qtdemux, &quot;bytes/sample:     %d&quot;,</span>
10998                 entry-&gt;bytes_per_sample);
10999 
11000             if (!entry-&gt;sampled &amp;&amp; entry-&gt;bytes_per_packet) {
11001               entry-&gt;samples_per_frame = (entry-&gt;bytes_per_frame /
11002                   entry-&gt;bytes_per_packet) * entry-&gt;samples_per_packet;
<span class="line-modified">11003             GST_LOG_OBJECT (qtdemux, &quot;samples/frame:    %d&quot;,</span>
11004                   entry-&gt;samples_per_frame);


11005           }
<span class="line-removed">11006           break;</span>
11007         }
<span class="line-modified">11008       }</span>
<span class="line-modified">11009     } else if (version == 0x00020000) {</span>
<span class="line-modified">11010       union</span>
<span class="line-modified">11011       {</span>
<span class="line-modified">11012         gdouble fp;</span>
<span class="line-modified">11013         guint64 val;</span>
<span class="line-removed">11014       } qtfp;</span>
11015 
<span class="line-modified">11016       /* sample description entry (16) + sound sample description v2 (56) */</span>
<span class="line-modified">11017       if (len &lt; 72)</span>
<span class="line-modified">11018         goto corrupt_file;</span>
11019 
11020         qtfp.val = QT_UINT64 (stsd_entry_data + offset + 4);
11021         entry-&gt;rate = qtfp.fp;
11022         entry-&gt;n_channels = QT_UINT32 (stsd_entry_data + offset + 12);
11023 
<span class="line-modified">11024       GST_LOG_OBJECT (qtdemux, &quot;Sound sample description Version 2&quot;);</span>
11025         GST_LOG_OBJECT (qtdemux, &quot;sample rate:        %g&quot;, entry-&gt;rate);
11026         GST_LOG_OBJECT (qtdemux, &quot;n_channels:         %d&quot;, entry-&gt;n_channels);
<span class="line-modified">11027       GST_LOG_OBJECT (qtdemux, &quot;bits/channel:       %d&quot;,</span>
11028             QT_UINT32 (stsd_entry_data + offset + 20));
<span class="line-modified">11029       GST_LOG_OBJECT (qtdemux, &quot;format flags:       %X&quot;,</span>
11030             QT_UINT32 (stsd_entry_data + offset + 24));
<span class="line-modified">11031       GST_LOG_OBJECT (qtdemux, &quot;bytes/packet:       %d&quot;,</span>
11032             QT_UINT32 (stsd_entry_data + offset + 28));
<span class="line-modified">11033       GST_LOG_OBJECT (qtdemux, &quot;LPCM frames/packet: %d&quot;,</span>
11034             QT_UINT32 (stsd_entry_data + offset + 32));
<span class="line-modified">11035     } else if (version != 0x00000) {</span>
11036         GST_WARNING_OBJECT (qtdemux, &quot;unknown audio STSD version %08x&quot;,
11037             version);
<span class="line-modified">11038     }</span>
11039 
11040       if (entry-&gt;caps)
11041         gst_caps_unref (entry-&gt;caps);
11042 
11043       entry-&gt;caps = qtdemux_audio_caps (qtdemux, stream, entry, fourcc,
11044           stsd_entry_data + 32, len - 16, &amp;codec);
11045 
<span class="line-modified">11046     switch (fourcc) {</span>
<span class="line-modified">11047       case FOURCC_in24:</span>
<span class="line-modified">11048       {</span>
<span class="line-modified">11049         GNode *enda;</span>
<span class="line-modified">11050         GNode *in24;</span>
11051 
<span class="line-modified">11052         in24 = qtdemux_tree_get_child_by_type (stsd, FOURCC_in24);</span>
11053 
<span class="line-modified">11054         enda = qtdemux_tree_get_child_by_type (in24, FOURCC_enda);</span>
<span class="line-modified">11055         if (!enda) {</span>
<span class="line-modified">11056           wave = qtdemux_tree_get_child_by_type (in24, FOURCC_wave);</span>
<span class="line-modified">11057           if (wave)</span>
<span class="line-modified">11058             enda = qtdemux_tree_get_child_by_type (wave, FOURCC_enda);</span>
<span class="line-modified">11059         }</span>
<span class="line-modified">11060         if (enda) {</span>
<span class="line-modified">11061           int enda_value = QT_UINT16 ((guint8 *) enda-&gt;data + 8);</span>
11062             gst_caps_set_simple (entry-&gt;caps,
11063                 &quot;format&quot;, G_TYPE_STRING, (enda_value) ? &quot;S24LE&quot; : &quot;S24BE&quot;,
11064                 NULL);


11065         }
<span class="line-modified">11066         break;</span>
<span class="line-removed">11067       }</span>
<span class="line-removed">11068       case FOURCC_owma:</span>
<span class="line-removed">11069       {</span>
<span class="line-removed">11070         const guint8 *owma_data;</span>
<span class="line-removed">11071         const gchar *codec_name = NULL;</span>
<span class="line-removed">11072         guint owma_len;</span>
<span class="line-removed">11073         GstBuffer *buf;</span>
<span class="line-removed">11074         gint version = 1;</span>
<span class="line-removed">11075         /* from http://msdn.microsoft.com/en-us/library/dd757720(VS.85).aspx */</span>
<span class="line-removed">11076         /* FIXME this should also be gst_riff_strf_auds,</span>
<span class="line-removed">11077          * but the latter one is actually missing bits-per-sample :( */</span>
<span class="line-removed">11078         typedef struct</span>
11079         {
<span class="line-modified">11080           gint16 wFormatTag;</span>
<span class="line-modified">11081           gint16 nChannels;</span>
<span class="line-modified">11082           gint32 nSamplesPerSec;</span>
<span class="line-modified">11083           gint32 nAvgBytesPerSec;</span>
<span class="line-modified">11084           gint16 nBlockAlign;</span>
<span class="line-modified">11085           gint16 wBitsPerSample;</span>
<span class="line-modified">11086           gint16 cbSize;</span>
<span class="line-modified">11087         } WAVEFORMATEX;</span>
<span class="line-modified">11088         WAVEFORMATEX *wfex;</span>
<span class="line-modified">11089 </span>
<span class="line-modified">11090         GST_DEBUG_OBJECT (qtdemux, &quot;parse owma&quot;);</span>










11091           owma_data = stsd_entry_data;
<span class="line-modified">11092         owma_len = QT_UINT32 (owma_data);</span>
<span class="line-modified">11093         if (owma_len &lt;= 54) {</span>
<span class="line-modified">11094           GST_WARNING_OBJECT (qtdemux, &quot;Too small owma header, skipping&quot;);</span>
<span class="line-modified">11095           break;</span>
<span class="line-modified">11096         }</span>
<span class="line-modified">11097         wfex = (WAVEFORMATEX *) (owma_data + 36);</span>
<span class="line-modified">11098         buf = gst_buffer_new_and_alloc (owma_len - 54);</span>
<span class="line-modified">11099         gst_buffer_fill (buf, 0, owma_data + 54, owma_len - 54);</span>
<span class="line-modified">11100         if (wfex-&gt;wFormatTag == 0x0161) {</span>
<span class="line-modified">11101           codec_name = &quot;Windows Media Audio&quot;;</span>
<span class="line-modified">11102           version = 2;</span>
<span class="line-modified">11103         } else if (wfex-&gt;wFormatTag == 0x0162) {</span>
<span class="line-modified">11104           codec_name = &quot;Windows Media Audio 9 Pro&quot;;</span>
<span class="line-modified">11105           version = 3;</span>
<span class="line-modified">11106         } else if (wfex-&gt;wFormatTag == 0x0163) {</span>
<span class="line-modified">11107           codec_name = &quot;Windows Media Audio 9 Lossless&quot;;</span>
<span class="line-modified">11108           /* is that correct? gstffmpegcodecmap.c is missing it, but</span>
<span class="line-modified">11109            * fluendo codec seems to support it */</span>
<span class="line-modified">11110           version = 4;</span>
<span class="line-modified">11111         }</span>
11112 
11113           gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11114             &quot;codec_data&quot;, GST_TYPE_BUFFER, buf,</span>
<span class="line-modified">11115             &quot;wmaversion&quot;, G_TYPE_INT, version,</span>
11116               &quot;block_align&quot;, G_TYPE_INT,
11117               GST_READ_UINT16_LE (&amp;wfex-&gt;nBlockAlign), &quot;bitrate&quot;, G_TYPE_INT,
11118               GST_READ_UINT32_LE (&amp;wfex-&gt;nAvgBytesPerSec), &quot;width&quot;, G_TYPE_INT,
11119               GST_READ_UINT16_LE (&amp;wfex-&gt;wBitsPerSample), &quot;depth&quot;, G_TYPE_INT,
11120               GST_READ_UINT16_LE (&amp;wfex-&gt;wBitsPerSample), NULL);
<span class="line-modified">11121         gst_buffer_unref (buf);</span>
11122 
<span class="line-modified">11123         if (codec_name) {</span>
<span class="line-modified">11124           g_free (codec);</span>
<span class="line-modified">11125           codec = g_strdup (codec_name);</span>


11126         }
<span class="line-removed">11127         break;</span>
<span class="line-removed">11128       }</span>
11129         case FOURCC_wma_:
11130         {
11131           gint len = QT_UINT32 (stsd_entry_data) - offset;
11132           const guint8 *wfex_data = stsd_entry_data + offset;
11133           const gchar *codec_name = NULL;
11134           gint version = 1;
11135           /* from http://msdn.microsoft.com/en-us/library/dd757720(VS.85).aspx */
11136           /* FIXME this should also be gst_riff_strf_auds,
11137            * but the latter one is actually missing bits-per-sample :( */
11138           typedef struct
11139           {
11140             gint16 wFormatTag;
11141             gint16 nChannels;
11142             gint32 nSamplesPerSec;
11143             gint32 nAvgBytesPerSec;
11144             gint16 nBlockAlign;
11145             gint16 wBitsPerSample;
11146             gint16 cbSize;
11147           } WAVEFORMATEX;
11148           WAVEFORMATEX wfex;
</pre>
<hr />
<pre>
11208 
11209                 if (size &gt; wfex.cbSize) {
11210                   GstBuffer *buf;
11211 
11212                   buf = gst_buffer_new_and_alloc (size - wfex.cbSize);
11213                   gst_buffer_fill (buf, 0, wfex_data + 8 + wfex.cbSize,
11214                       size - wfex.cbSize);
11215                   gst_caps_set_simple (entry-&gt;caps,
11216                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
11217                   gst_buffer_unref (buf);
11218                 } else {
11219                   GST_WARNING_OBJECT (qtdemux, &quot;no codec data&quot;);
11220                 }
11221 
11222                 if (codec_name) {
11223                   g_free (codec);
11224                   codec = g_strdup (codec_name);
11225                 }
11226                 break;
11227               }
<span class="line-modified">11228       default:</span>
<span class="line-modified">11229         break;</span>
<span class="line-modified">11230     }</span>
11231             len -= size + 8;
11232             wfex_data += size + 8;
11233           }
11234           break;
11235         }
11236 #ifndef GSTREAMER_LITE
11237         case FOURCC_opus:
11238         {
11239           const guint8 *opus_data;
11240           guint8 *channel_mapping = NULL;
11241           guint32 rate;
11242           guint8 channels;
11243           guint8 channel_mapping_family;
11244           guint8 stream_count;
11245           guint8 coupled_count;
11246           guint8 i;
11247 
11248           opus_data = stsd_entry_data;
11249 
11250           channels = GST_READ_UINT8 (opus_data + 45);
</pre>
<hr />
<pre>
11252           channel_mapping_family = GST_READ_UINT8 (opus_data + 54);
11253           stream_count = GST_READ_UINT8 (opus_data + 55);
11254           coupled_count = GST_READ_UINT8 (opus_data + 56);
11255 
11256           if (channels &gt; 0) {
11257             channel_mapping = g_malloc (channels * sizeof (guint8));
11258             for (i = 0; i &lt; channels; i++)
11259               channel_mapping[i] = GST_READ_UINT8 (opus_data + i + 57);
11260           }
11261 
11262           entry-&gt;caps = gst_codec_utils_opus_create_caps (rate, channels,
11263               channel_mapping_family, stream_count, coupled_count,
11264               channel_mapping);
11265           break;
11266         }
11267 #endif // GSTREAMER_LITE
11268         default:
11269           break;
11270       }
11271 
<span class="line-modified">11272     if (codec) {</span>
<span class="line-modified">11273       GstStructure *s;</span>
<span class="line-modified">11274       gint bitrate = 0;</span>
11275 
11276         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">11277           GST_TAG_AUDIO_CODEC, codec, NULL);</span>
<span class="line-modified">11278       g_free (codec);</span>
<span class="line-modified">11279       codec = NULL;</span>
11280 
<span class="line-modified">11281       /* some bitrate info may have ended up in caps */</span>
11282         s = gst_caps_get_structure (entry-&gt;caps, 0);
<span class="line-modified">11283       gst_structure_get_int (s, &quot;bitrate&quot;, &amp;bitrate);</span>
<span class="line-modified">11284       if (bitrate &gt; 0)</span>
11285           gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
11286               GST_TAG_BITRATE, bitrate, NULL);
<span class="line-modified">11287     }</span>
11288 
11289       mp4a = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">11290       if (!stream-&gt;protected) {</span>
<span class="line-modified">11291       } else {</span>
<span class="line-removed">11292         if (QTDEMUX_TREE_NODE_FOURCC (mp4v) != FOURCC_encv) {</span>
<span class="line-removed">11293           mp4v = NULL;</span>
<span class="line-removed">11294         }</span>
<span class="line-removed">11295       }</span>
<span class="line-removed">11296       if (stream-&gt;protected &amp;&amp; fourcc == FOURCC_mp4a) {</span>
<span class="line-removed">11297         if (QTDEMUX_TREE_NODE_FOURCC (mp4a) != FOURCC_enca) {</span>
11298           mp4a = NULL;
<span class="line-modified">11299         }</span>
<span class="line-removed">11300       } else {</span>
<span class="line-removed">11301         if (QTDEMUX_TREE_NODE_FOURCC (mp4a) != FOURCC_mp4a) {</span>
11302           mp4a = NULL;
<span class="line-removed">11303         }</span>
11304       }
11305 
<span class="line-modified">11306     wave = NULL;</span>
<span class="line-modified">11307     esds = NULL;</span>
<span class="line-modified">11308     if (mp4a) {</span>
<span class="line-modified">11309       wave = qtdemux_tree_get_child_by_type (mp4a, FOURCC_wave);</span>
<span class="line-modified">11310       if (wave)</span>
<span class="line-modified">11311         esds = qtdemux_tree_get_child_by_type (wave, FOURCC_esds);</span>
<span class="line-modified">11312       if (!esds)</span>
<span class="line-modified">11313         esds = qtdemux_tree_get_child_by_type (mp4a, FOURCC_esds);</span>
<span class="line-modified">11314     }</span>
11315 
11316 
<span class="line-modified">11317     /* If the fourcc&#39;s bottom 16 bits gives &#39;sm&#39;, then the top</span>
<span class="line-modified">11318        16 bits is a byte-swapped wave-style codec identifier,</span>
<span class="line-modified">11319        and we can find a WAVE header internally to a &#39;wave&#39; atom here.</span>
<span class="line-modified">11320        This can more clearly be thought of as &#39;ms&#39; as the top 16 bits, and a</span>
<span class="line-modified">11321        codec id as the bottom 16 bits - but byte-swapped to store in QT (which</span>
<span class="line-modified">11322        is big-endian).</span>
<span class="line-modified">11323      */</span>
<span class="line-modified">11324     if ((fourcc &amp; 0xffff) == ((&#39;s&#39; &lt;&lt; 8) | &#39;m&#39;)) {</span>
<span class="line-modified">11325       if (len &lt; offset + 20) {</span>
<span class="line-modified">11326         GST_WARNING_OBJECT (qtdemux, &quot;No wave atom in MS-style audio&quot;);</span>
<span class="line-modified">11327       } else {</span>
11328           guint32 datalen = QT_UINT32 (stsd_entry_data + offset + 16);
11329           const guint8 *data = stsd_entry_data + offset + 16;
<span class="line-modified">11330         GNode *wavenode;</span>
<span class="line-modified">11331         GNode *waveheadernode;</span>
11332 
<span class="line-modified">11333         wavenode = g_node_new ((guint8 *) data);</span>
<span class="line-modified">11334         if (qtdemux_parse_node (qtdemux, wavenode, data, datalen)) {</span>
<span class="line-modified">11335           const guint8 *waveheader;</span>
<span class="line-modified">11336           guint32 headerlen;</span>
11337 
<span class="line-modified">11338           waveheadernode = qtdemux_tree_get_child_by_type (wavenode, fourcc);</span>
<span class="line-modified">11339           if (waveheadernode) {</span>
<span class="line-modified">11340             waveheader = (const guint8 *) waveheadernode-&gt;data;</span>
<span class="line-modified">11341             headerlen = QT_UINT32 (waveheader);</span>
11342 
<span class="line-modified">11343             if (headerlen &gt; 8) {</span>
<span class="line-modified">11344               gst_riff_strf_auds *header = NULL;</span>
<span class="line-modified">11345               GstBuffer *headerbuf;</span>
<span class="line-modified">11346               GstBuffer *extra;</span>
11347 
<span class="line-modified">11348               waveheader += 8;</span>
<span class="line-modified">11349               headerlen -= 8;</span>
11350 
<span class="line-modified">11351               headerbuf = gst_buffer_new_and_alloc (headerlen);</span>
<span class="line-modified">11352               gst_buffer_fill (headerbuf, 0, waveheader, headerlen);</span>
11353 
<span class="line-modified">11354               if (gst_riff_parse_strf_auds (GST_ELEMENT_CAST (qtdemux),</span>
<span class="line-modified">11355                       headerbuf, &amp;header, &amp;extra)) {</span>
11356                   gst_caps_unref (entry-&gt;caps);
<span class="line-modified">11357                 /* FIXME: Need to do something with the channel reorder map */</span>
11358                   entry-&gt;caps =
11359                       gst_riff_create_audio_caps (header-&gt;format, NULL, header,
11360                       extra, NULL, NULL, NULL);
11361 
<span class="line-modified">11362                 if (extra)</span>
<span class="line-modified">11363                   gst_buffer_unref (extra);</span>
<span class="line-modified">11364                 g_free (header);</span>

11365               }
<span class="line-modified">11366             }</span>
<span class="line-modified">11367           } else</span>
<span class="line-modified">11368             GST_DEBUG (&quot;Didn&#39;t find waveheadernode for this codec&quot;);</span>

11369         }
<span class="line-modified">11370         g_node_destroy (wavenode);</span>
<span class="line-removed">11371       }</span>
<span class="line-removed">11372     } else if (esds) {</span>
11373 #ifdef GSTREAMER_LITE
11374         if (!gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
11375                                       stream-&gt;stream_tags))
11376             goto corrupt_file;
11377 #else
11378         gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
11379             stream-&gt;stream_tags);
11380 #endif // GSTREAMER_LITE
<span class="line-modified">11381     } else {</span>
<span class="line-modified">11382       switch (fourcc) {</span>
11383 #if 0
<span class="line-modified">11384           /* FIXME: what is in the chunk? */</span>
<span class="line-modified">11385         case FOURCC_QDMC:</span>
<span class="line-modified">11386         {</span>
<span class="line-modified">11387           gint len = QT_UINT32 (stsd_data);</span>
11388 
<span class="line-modified">11389           /* seems to be always = 116 = 0x74 */</span>
<span class="line-modified">11390           break;</span>
<span class="line-modified">11391         }</span>
11392 #endif
<span class="line-modified">11393         case FOURCC_QDM2:</span>
<span class="line-modified">11394         {</span>
11395             gint len = QT_UINT32 (stsd_entry_data);
11396 
11397             if (len &gt; 0x3C) {
11398               GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x3C);
11399 
11400               gst_buffer_fill (buf, 0, stsd_entry_data + 0x3C, len - 0x3C);
11401               gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11402                 &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11403             gst_buffer_unref (buf);</span>
<span class="line-modified">11404           }</span>
11405             gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11406               &quot;samplesize&quot;, G_TYPE_INT, samplesize, NULL);</span>
<span class="line-modified">11407           break;</span>
<span class="line-removed">11408         }</span>
<span class="line-removed">11409         case FOURCC_alac:</span>
<span class="line-removed">11410         {</span>
<span class="line-removed">11411           GNode *alac, *wave = NULL;</span>
<span class="line-removed">11412 </span>
<span class="line-removed">11413           /* apparently, m4a has this atom appended directly in the stsd entry,</span>
<span class="line-removed">11414            * while mov has it in a wave atom */</span>
<span class="line-removed">11415           alac = qtdemux_tree_get_child_by_type (stsd, FOURCC_alac);</span>
<span class="line-removed">11416           if (alac) {</span>
<span class="line-removed">11417             /* alac now refers to stsd entry atom */</span>
<span class="line-removed">11418             wave = qtdemux_tree_get_child_by_type (alac, FOURCC_wave);</span>
<span class="line-removed">11419             if (wave)</span>
<span class="line-removed">11420               alac = qtdemux_tree_get_child_by_type (wave, FOURCC_alac);</span>
<span class="line-removed">11421             else</span>
<span class="line-removed">11422               alac = qtdemux_tree_get_child_by_type (alac, FOURCC_alac);</span>
11423           }
<span class="line-modified">11424           if (alac) {</span>
<span class="line-modified">11425             const guint8 *alac_data = alac-&gt;data;</span>
<span class="line-modified">11426             gint len = QT_UINT32 (alac-&gt;data);</span>
<span class="line-modified">11427             GstBuffer *buf;</span>















11428 
<span class="line-modified">11429             if (len &lt; 36) {</span>
<span class="line-modified">11430               GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">11431                   &quot;discarding alac atom with unexpected len %d&quot;, len);</span>
<span class="line-modified">11432             } else {</span>
<span class="line-modified">11433               /* codec-data contains alac atom size and prefix,</span>
<span class="line-modified">11434                * ffmpeg likes it that way, not quite gst-ish though ...*/</span>
<span class="line-modified">11435               buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">11436               gst_buffer_fill (buf, 0, alac-&gt;data, len);</span>
11437                 gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11438                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11439               gst_buffer_unref (buf);</span>
11440 
11441                 entry-&gt;bytes_per_frame = QT_UINT32 (alac_data + 12);
11442                 entry-&gt;n_channels = QT_UINT8 (alac_data + 21);
11443                 entry-&gt;rate = QT_UINT32 (alac_data + 32);

11444             }
<span class="line-removed">11445           }</span>
11446             gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11447               &quot;samplesize&quot;, G_TYPE_INT, samplesize, NULL);</span>
<span class="line-modified">11448           break;</span>
<span class="line-modified">11449         }</span>
11450           case FOURCC_fLaC:
11451           {
11452             /* The codingname of the sample entry is &#39;fLaC&#39; */
11453             GNode *flac = qtdemux_tree_get_child_by_type (stsd, FOURCC_fLaC);
11454 
11455             if (flac) {
11456               /* The &#39;dfLa&#39; box is added to the sample entry to convey
11457                  initializing information for the decoder. */
11458               const GNode *dfla =
11459                   qtdemux_tree_get_child_by_type (flac, FOURCC_dfLa);
11460 
11461               if (dfla) {
11462                 const guint32 len = QT_UINT32 (dfla-&gt;data);
11463 
11464                 /* Must contain at least dfLa box header (12),
11465                  * METADATA_BLOCK_HEADER (4), METADATA_BLOCK_STREAMINFO (34) */
11466                 if (len &lt; 50) {
11467                   GST_DEBUG_OBJECT (qtdemux,
11468                       &quot;discarding dfla atom with unexpected len %d&quot;, len);
11469                 } else {
</pre>
<hr />
<pre>
11532                     GST_WARNING_OBJECT (qtdemux,
11533                         &quot;discarding all METADATA_BLOCKs due to invalid &quot;
11534                         &quot;block_size %d at idx %d, rem %d&quot;, block_size, index,
11535                         remainder);
11536                   }
11537 
11538                   g_value_unset (&amp;value);
11539                   g_value_unset (&amp;array);
11540 
11541                   /* The sample rate obtained from the stsd may not be accurate
11542                    * since it cannot represent rates greater than 65535Hz, so
11543                    * override that value with the sample rate from the
11544                    * METADATA_BLOCK_STREAMINFO block */
11545                   CUR_STREAM (stream)-&gt;rate =
11546                       (QT_UINT32 (metadata_blocks + 14) &gt;&gt; 12) &amp; 0xFFFFF;
11547                 }
11548               }
11549             }
11550             break;
11551           }
<span class="line-modified">11552         case FOURCC_sawb:</span>
<span class="line-modified">11553           /* Fallthrough! */</span>
<span class="line-modified">11554           amrwb = TRUE;</span>
<span class="line-modified">11555         case FOURCC_samr:</span>
<span class="line-modified">11556         {</span>
11557             gint len = QT_UINT32 (stsd_entry_data);
11558 
11559             if (len &gt; 0x24) {
11560               GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x24);
<span class="line-modified">11561             guint bitrate;</span>
11562 
11563               gst_buffer_fill (buf, 0, stsd_entry_data + 0x24, len - 0x24);
11564 
<span class="line-modified">11565             /* If we have enough data, let&#39;s try to get the &#39;damr&#39; atom. See</span>
<span class="line-modified">11566              * the 3GPP container spec (26.244) for more details. */</span>
<span class="line-modified">11567             if ((len - 0x34) &gt; 8 &amp;&amp;</span>
<span class="line-modified">11568                 (bitrate = qtdemux_parse_amr_bitrate (buf, amrwb))) {</span>
11569                 gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">11570                   GST_TAG_MAXIMUM_BITRATE, bitrate, NULL);</span>
<span class="line-modified">11571             }</span>
11572 
11573               gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11574                 &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11575             gst_buffer_unref (buf);</span>


11576           }
<span class="line-removed">11577           break;</span>
<span class="line-removed">11578         }</span>
11579           case FOURCC_mp4a:
11580           {
11581             /* mp4a atom withtout ESDS; Attempt to build codec data from atom */
11582             gint len = QT_UINT32 (stsd_entry_data);
11583 
11584             if (len &gt;= 34) {
11585               guint16 sound_version = QT_UINT16 (stsd_entry_data + 16);
11586 
11587               if (sound_version == 1) {
11588                 guint16 channels = QT_UINT16 (stsd_entry_data + 24);
11589                 guint32 time_scale = QT_UINT32 (stsd_entry_data + 30);
11590                 guint8 codec_data[2];
11591                 GstBuffer *buf;
11592                 gint profile = 2;       /* FIXME: Can this be determined somehow? There doesn&#39;t seem to be anything in mp4a atom that specifis compression */
11593 
11594                 gint sample_rate_index =
11595                     gst_codec_utils_aac_get_index_from_sample_rate (time_scale);
11596 
11597                 /* build AAC codec data */
11598                 codec_data[0] = profile &lt;&lt; 3;
11599                 codec_data[0] |= ((sample_rate_index &gt;&gt; 1) &amp; 0x7);
11600                 codec_data[1] = (sample_rate_index &amp; 0x01) &lt;&lt; 7;
11601                 codec_data[1] |= (channels &amp; 0xF) &lt;&lt; 3;
11602 
11603                 buf = gst_buffer_new_and_alloc (2);
11604                 gst_buffer_fill (buf, 0, codec_data, 2);
11605                 gst_caps_set_simple (entry-&gt;caps,
11606                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
11607                 gst_buffer_unref (buf);
11608               }
11609             }
11610             break;
11611           }
11612           case FOURCC_lpcm:
11613             /* Fully handled elsewhere */
11614             break;
<span class="line-modified">11615         default:</span>
<span class="line-modified">11616           GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">11617               &quot;unhandled type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">11618           break;</span>

11619       }
<span class="line-modified">11620     }</span>
<span class="line-modified">11621     GST_INFO_OBJECT (qtdemux,</span>
<span class="line-removed">11622         &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
11623           GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
11624 
<span class="line-modified">11625   } else if (stream-&gt;subtype == FOURCC_strm) {</span>
<span class="line-modified">11626     if (fourcc == FOURCC_rtsp) {</span>
<span class="line-modified">11627       stream-&gt;redirect_uri = qtdemux_get_rtsp_uri_from_hndl (qtdemux, minf);</span>
<span class="line-modified">11628     } else {</span>
<span class="line-modified">11629       GST_INFO_OBJECT (qtdemux, &quot;unhandled stream type %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">11630           GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">11631       goto unknown_stream;</span>
<span class="line-modified">11632     }</span>
11633       entry-&gt;sampled = TRUE;
<span class="line-modified">11634   } else if (stream-&gt;subtype == FOURCC_subp || stream-&gt;subtype == FOURCC_text</span>
<span class="line-modified">11635         || stream-&gt;subtype == FOURCC_sbtl || stream-&gt;subtype == FOURCC_subt) {</span>

11636 
11637       entry-&gt;sampled = TRUE;
11638       entry-&gt;sparse = TRUE;
11639 
11640       entry-&gt;caps =
11641           qtdemux_sub_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
11642           &amp;codec);
<span class="line-modified">11643     if (codec) {</span>
11644         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">11645           GST_TAG_SUBTITLE_CODEC, codec, NULL);</span>
<span class="line-modified">11646       g_free (codec);</span>
<span class="line-modified">11647       codec = NULL;</span>
<span class="line-modified">11648     }</span>
11649 
<span class="line-modified">11650     /* hunt for sort-of codec data */</span>
<span class="line-modified">11651     switch (fourcc) {</span>
<span class="line-modified">11652       case FOURCC_mp4s:</span>
<span class="line-modified">11653       {</span>
<span class="line-modified">11654         GNode *mp4s = NULL;</span>
<span class="line-modified">11655         GNode *esds = NULL;</span>
<span class="line-modified">11656 </span>
<span class="line-modified">11657         /* look for palette in a stsd-&gt;mp4s-&gt;esds sub-atom */</span>
<span class="line-modified">11658         mp4s = qtdemux_tree_get_child_by_type (stsd, FOURCC_mp4s);</span>
<span class="line-modified">11659         if (mp4s)</span>
<span class="line-modified">11660           esds = qtdemux_tree_get_child_by_type (mp4s, FOURCC_esds);</span>
<span class="line-modified">11661         if (esds == NULL) {</span>
<span class="line-modified">11662           /* Invalid STSD */</span>
<span class="line-modified">11663           GST_LOG_OBJECT (qtdemux, &quot;Skipping invalid stsd: no esds child&quot;);</span>
<span class="line-modified">11664           break;</span>
11665           }
11666 
11667           gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
11668               stream-&gt;stream_tags);
<span class="line-modified">11669         break;</span>





11670       }
<span class="line-modified">11671       default:</span>
<span class="line-modified">11672         GST_INFO_OBJECT (qtdemux,</span>
<span class="line-removed">11673             &quot;unhandled type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));</span>
<span class="line-removed">11674         break;</span>
<span class="line-removed">11675     }</span>
<span class="line-removed">11676     GST_INFO_OBJECT (qtdemux,</span>
<span class="line-removed">11677         &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
11678           GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
<span class="line-modified">11679   } else {</span>
<span class="line-modified">11680     /* everything in 1 sample */</span>
11681       entry-&gt;sampled = TRUE;
11682 
11683       entry-&gt;caps =
11684           qtdemux_generic_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
11685           &amp;codec);
11686 
11687       if (entry-&gt;caps == NULL)
<span class="line-modified">11688     goto unknown_stream;</span>
11689 
<span class="line-modified">11690     if (codec) {</span>
11691         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">11692           GST_TAG_SUBTITLE_CODEC, codec, NULL);</span>
<span class="line-modified">11693       g_free (codec);</span>
<span class="line-modified">11694       codec = NULL;</span>
<span class="line-modified">11695   }</span>
<span class="line-modified">11696   }</span>
11697 
<span class="line-modified">11698   /* promote to sampled format */</span>
11699     if (entry-&gt;fourcc == FOURCC_samr) {
<span class="line-modified">11700     /* force mono 8000 Hz for AMR */</span>
11701       entry-&gt;sampled = TRUE;
11702       entry-&gt;n_channels = 1;
11703       entry-&gt;rate = 8000;
11704     } else if (entry-&gt;fourcc == FOURCC_sawb) {
<span class="line-modified">11705     /* force mono 16000 Hz for AMR-WB */</span>
11706       entry-&gt;sampled = TRUE;
11707       entry-&gt;n_channels = 1;
11708       entry-&gt;rate = 16000;
11709     } else if (entry-&gt;fourcc == FOURCC_mp4a) {
11710       entry-&gt;sampled = TRUE;
<span class="line-modified">11711   }</span>
11712 
11713 
11714     stsd_entry_data += len;
11715     remaining_stsd_len -= len;
11716 
11717   }
11718 
11719   /* collect sample information */
11720   if (!qtdemux_stbl_init (qtdemux, stream, stbl))
11721     goto samples_failed;
11722 
11723   if (qtdemux-&gt;fragmented) {
11724     guint64 offset;
11725 
11726     /* need all moov samples as basis; probably not many if any at all */
11727     /* prevent moof parsing taking of at this time */
11728     offset = qtdemux-&gt;moof_offset;
11729     qtdemux-&gt;moof_offset = 0;
11730     if (stream-&gt;n_samples &amp;&amp;
11731         !qtdemux_parse_samples (qtdemux, stream, stream-&gt;n_samples - 1)) {
</pre>
<hr />
<pre>
11743   /* configure segments */
11744   if (!qtdemux_parse_segments (qtdemux, stream, trak))
11745     goto segments_failed;
11746 
11747   /* add some language tag, if useful */
11748   if (stream-&gt;lang_id[0] != &#39;\0&#39; &amp;&amp; strcmp (stream-&gt;lang_id, &quot;unk&quot;) &amp;&amp;
11749       strcmp (stream-&gt;lang_id, &quot;und&quot;)) {
11750     const gchar *lang_code;
11751 
11752     /* convert ISO 639-2 code to ISO 639-1 */
11753     lang_code = gst_tag_get_language_code (stream-&gt;lang_id);
11754     gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
11755         GST_TAG_LANGUAGE_CODE, (lang_code) ? lang_code : stream-&gt;lang_id, NULL);
11756   }
11757 
11758   /* Check for UDTA tags */
11759   if ((udta = qtdemux_tree_get_child_by_type (trak, FOURCC_udta))) {
11760     qtdemux_parse_udta (qtdemux, stream-&gt;stream_tags, udta);
11761   }
11762 
<span class="line-modified">11763   /* now we are ready to add the stream */</span>
<span class="line-modified">11764   if (qtdemux-&gt;n_streams &gt;= GST_QTDEMUX_MAX_STREAMS)</span>
<span class="line-modified">11765     goto too_many_streams;</span>
<span class="line-modified">11766 </span>
<span class="line-modified">11767   if (!qtdemux-&gt;got_moov) {</span>
<span class="line-modified">11768     qtdemux-&gt;streams[qtdemux-&gt;n_streams] = stream;</span>
<span class="line-modified">11769     qtdemux-&gt;n_streams++;</span>
<span class="line-removed">11770     GST_DEBUG_OBJECT (qtdemux, &quot;n_streams is now %d&quot;, qtdemux-&gt;n_streams);</span>
<span class="line-removed">11771   }</span>
11772 
11773   return TRUE;
11774 
11775 /* ERRORS */
<span class="line-removed">11776 skip_track:</span>
<span class="line-removed">11777   {</span>
<span class="line-removed">11778     GST_INFO_OBJECT (qtdemux, &quot;skip disabled track&quot;);</span>
<span class="line-removed">11779     if (new_stream)</span>
<span class="line-removed">11780       gst_qtdemux_stream_free (qtdemux, stream);</span>
<span class="line-removed">11781     return TRUE;</span>
<span class="line-removed">11782   }</span>
11783 corrupt_file:
11784   {
11785     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
11786         (_(&quot;This file is corrupt and cannot be played.&quot;)), (NULL));
<span class="line-modified">11787     if (new_stream)</span>
<span class="line-modified">11788       gst_qtdemux_stream_free (qtdemux, stream);</span>
11789     return FALSE;
11790   }
11791 error_encrypted:
11792   {
11793     GST_ELEMENT_ERROR (qtdemux, STREAM, DECRYPT, (NULL), (NULL));
<span class="line-modified">11794     if (new_stream)</span>
<span class="line-removed">11795       gst_qtdemux_stream_free (qtdemux, stream);</span>
11796     return FALSE;
11797   }
11798 samples_failed:
11799 segments_failed:
11800   {
11801     /* we posted an error already */
11802     /* free stbl sub-atoms */
11803     gst_qtdemux_stbl_free (stream);
<span class="line-modified">11804     if (new_stream)</span>
<span class="line-removed">11805       gst_qtdemux_stream_free (qtdemux, stream);</span>
11806     return FALSE;
11807   }
11808 existing_stream:
11809   {
11810     GST_INFO_OBJECT (qtdemux, &quot;stream with track id %i already exists&quot;,
11811         track_id);
<span class="line-removed">11812     if (new_stream)</span>
<span class="line-removed">11813       gst_qtdemux_stream_free (qtdemux, stream);</span>
11814     return TRUE;
11815   }
11816 unknown_stream:
11817   {
11818     GST_INFO_OBJECT (qtdemux, &quot;unknown subtype %&quot; GST_FOURCC_FORMAT,
11819         GST_FOURCC_ARGS (stream-&gt;subtype));
<span class="line-modified">11820     if (new_stream)</span>
<span class="line-removed">11821       gst_qtdemux_stream_free (qtdemux, stream);</span>
<span class="line-removed">11822     return TRUE;</span>
<span class="line-removed">11823   }</span>
<span class="line-removed">11824 too_many_streams:</span>
<span class="line-removed">11825   {</span>
<span class="line-removed">11826     GST_ELEMENT_WARNING (qtdemux, STREAM, DEMUX,</span>
<span class="line-removed">11827         (_(&quot;This file contains too many streams. Only playing first %d&quot;),</span>
<span class="line-removed">11828             GST_QTDEMUX_MAX_STREAMS), (NULL));</span>
11829     return TRUE;
11830   }
11831 }
11832 
11833 /* If we can estimate the overall bitrate, and don&#39;t have information about the
11834  * stream bitrate for exactly one stream, this guesses the stream bitrate as
11835  * the overall bitrate minus the sum of the bitrates of all other streams. This
11836  * should be useful for the common case where we have one audio and one video
11837  * stream and can estimate the bitrate of one, but not the other. */
11838 static void
11839 gst_qtdemux_guess_bitrate (GstQTDemux * qtdemux)
11840 {
11841   QtDemuxStream *stream = NULL;
11842   gint64 size, sys_bitrate, sum_bitrate = 0;
11843   GstClockTime duration;
<span class="line-removed">11844   gint i;</span>
11845   guint bitrate;

11846 
11847   if (qtdemux-&gt;fragmented)
11848     return;
11849 
11850   GST_DEBUG_OBJECT (qtdemux, &quot;Looking for streams with unknown bitrate&quot;);
11851 
11852   if (!gst_pad_peer_query_duration (qtdemux-&gt;sinkpad, GST_FORMAT_BYTES, &amp;size)
11853       || size &lt;= 0) {
11854     GST_DEBUG_OBJECT (qtdemux,
11855         &quot;Size in bytes of the stream not known - bailing&quot;);
11856     return;
11857   }
11858 
11859   /* Subtract the header size */
11860   GST_DEBUG_OBJECT (qtdemux, &quot;Total size %&quot; G_GINT64_FORMAT &quot;, header size %u&quot;,
11861       size, qtdemux-&gt;header_size);
11862 
11863   if (size &lt; qtdemux-&gt;header_size)
11864     return;
11865 
11866   size = size - qtdemux-&gt;header_size;
11867 
11868   if (!gst_qtdemux_get_duration (qtdemux, &amp;duration)) {
11869     GST_DEBUG_OBJECT (qtdemux, &quot;Stream duration not known - bailing&quot;);
11870     return;
11871   }
11872 
<span class="line-modified">11873   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified">11874     switch (qtdemux-&gt;streams[i]-&gt;subtype) {</span>

11875       case FOURCC_soun:
11876       case FOURCC_vide:
11877         GST_DEBUG_OBJECT (qtdemux, &quot;checking bitrate for %&quot; GST_PTR_FORMAT,
<span class="line-modified">11878             CUR_STREAM (qtdemux-&gt;streams[i])-&gt;caps);</span>
11879         /* retrieve bitrate, prefer avg then max */
11880         bitrate = 0;
<span class="line-modified">11881         if (qtdemux-&gt;streams[i]-&gt;stream_tags) {</span>
<span class="line-modified">11882           if (gst_tag_list_get_uint (qtdemux-&gt;streams[i]-&gt;stream_tags,</span>
11883                   GST_TAG_MAXIMUM_BITRATE, &amp;bitrate))
<span class="line-modified">11884           GST_DEBUG_OBJECT (qtdemux, &quot;max-bitrate: %u&quot;, bitrate);</span>
<span class="line-modified">11885           if (gst_tag_list_get_uint (qtdemux-&gt;streams[i]-&gt;stream_tags,</span>
11886                   GST_TAG_NOMINAL_BITRATE, &amp;bitrate))
<span class="line-modified">11887           GST_DEBUG_OBJECT (qtdemux, &quot;nominal-bitrate: %u&quot;, bitrate);</span>
<span class="line-modified">11888           if (gst_tag_list_get_uint (qtdemux-&gt;streams[i]-&gt;stream_tags,</span>
11889                   GST_TAG_BITRATE, &amp;bitrate))
<span class="line-modified">11890           GST_DEBUG_OBJECT (qtdemux, &quot;bitrate: %u&quot;, bitrate);</span>
11891         }
11892         if (bitrate)
11893           sum_bitrate += bitrate;
11894         else {
11895           if (stream) {
11896             GST_DEBUG_OBJECT (qtdemux,
11897                 &quot;&gt;1 stream with unknown bitrate - bailing&quot;);
11898             return;
11899           } else
<span class="line-modified">11900             stream = qtdemux-&gt;streams[i];</span>
11901         }
11902 
11903       default:
11904         /* For other subtypes, we assume no significant impact on bitrate */
11905         break;
11906     }
11907   }
11908 
11909   if (!stream) {
11910     GST_DEBUG_OBJECT (qtdemux, &quot;All stream bitrates are known&quot;);
11911     return;
11912   }
11913 
11914   sys_bitrate = gst_util_uint64_scale (size, GST_SECOND * 8, duration);
11915 
11916   if (sys_bitrate &lt; sum_bitrate) {
11917     /* This can happen, since sum_bitrate might be derived from maximum
11918      * bitrates and not average bitrates */
11919     GST_DEBUG_OBJECT (qtdemux,
11920         &quot;System bitrate less than sum bitrate - bailing&quot;);
11921     return;
11922   }
11923 
11924   bitrate = sys_bitrate - sum_bitrate;
11925   GST_DEBUG_OBJECT (qtdemux, &quot;System bitrate = %&quot; G_GINT64_FORMAT
11926       &quot;, Stream bitrate = %u&quot;, sys_bitrate, bitrate);
11927 
11928   if (!stream-&gt;stream_tags)
11929     stream-&gt;stream_tags = gst_tag_list_new_empty ();
11930   else
11931     stream-&gt;stream_tags = gst_tag_list_make_writable (stream-&gt;stream_tags);
11932 
11933   gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
11934       GST_TAG_BITRATE, bitrate, NULL);
11935 }
11936 
11937 static GstFlowReturn
11938 qtdemux_prepare_streams (GstQTDemux * qtdemux)
11939 {
<span class="line-removed">11940   gint i;</span>
11941   GstFlowReturn ret = GST_FLOW_OK;

11942 
11943   GST_DEBUG_OBJECT (qtdemux, &quot;prepare streams&quot;);
11944 
<span class="line-modified">11945   for (i = 0; ret == GST_FLOW_OK &amp;&amp; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified">11946     QtDemuxStream *stream = qtdemux-&gt;streams[i];</span>
11947     guint32 sample_num = 0;
11948 
<span class="line-modified">11949     GST_DEBUG_OBJECT (qtdemux, &quot;stream %d, id %d, fourcc %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">11950         i, stream-&gt;track_id, GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));</span>
11951 
11952     if (qtdemux-&gt;fragmented) {
11953       /* need all moov samples first */
11954       GST_OBJECT_LOCK (qtdemux);
11955       while (stream-&gt;n_samples == 0)
11956         if ((ret = qtdemux_add_fragmented_samples (qtdemux)) != GST_FLOW_OK)
11957           break;
11958       GST_OBJECT_UNLOCK (qtdemux);
11959     } else {
11960       /* discard any stray moof */
11961       qtdemux-&gt;moof_offset = 0;
11962     }
11963 
11964     /* prepare braking */
11965     if (ret != GST_FLOW_ERROR)
11966       ret = GST_FLOW_OK;
11967 
11968     /* in pull mode, we should have parsed some sample info by now;
11969      * and quite some code will not handle no samples.
11970      * in push mode, we&#39;ll just have to deal with it */
11971     if (G_UNLIKELY (qtdemux-&gt;pullbased &amp;&amp; !stream-&gt;n_samples)) {
11972       GST_DEBUG_OBJECT (qtdemux, &quot;no samples for stream; discarding&quot;);
<span class="line-modified">11973       gst_qtdemux_remove_stream (qtdemux, i);</span>







11974       i--;
11975       continue;
11976     }
11977 
11978     /* parse the initial sample for use in setting the frame rate cap */
11979     while (sample_num == 0 &amp;&amp; sample_num &lt; stream-&gt;n_samples) {
11980       if (!qtdemux_parse_samples (qtdemux, stream, sample_num))
11981         break;
11982       ++sample_num;
11983     }
<span class="line-modified">11984     if (stream-&gt;n_samples &gt; 0 &amp;&amp; stream-&gt;stbl_index &gt;= 0) {</span>
<span class="line-removed">11985       stream-&gt;first_duration = stream-&gt;samples[0].duration;</span>
<span class="line-removed">11986       GST_LOG_OBJECT (qtdemux, &quot;stream %d first duration %u&quot;,</span>
<span class="line-removed">11987           stream-&gt;track_id, stream-&gt;first_duration);</span>
<span class="line-removed">11988       }</span>
<span class="line-removed">11989     }</span>
11990 
11991   return ret;
11992 }
11993 


























































































































11994 static GstFlowReturn
11995 qtdemux_expose_streams (GstQTDemux * qtdemux)
11996 {
11997   gint i;
<span class="line-removed">11998   GSList *oldpads = NULL;</span>
<span class="line-removed">11999   GSList *iter;</span>
12000 
12001   GST_DEBUG_OBJECT (qtdemux, &quot;exposing streams&quot;);
12002 
<span class="line-modified">12003   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified">12004     QtDemuxStream *stream = qtdemux-&gt;streams[i];</span>
<span class="line-modified">12005     GstPad *oldpad = stream-&gt;pad;</span>
<span class="line-modified">12006     GstTagList *list;</span>




12007 
<span class="line-modified">12008     GST_DEBUG_OBJECT (qtdemux, &quot;stream %d, id %d, fourcc %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">12009         i, stream-&gt;track_id, GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));</span>
12010 
<span class="line-modified">12011     if ((stream-&gt;subtype == FOURCC_text || stream-&gt;subtype == FOURCC_sbtl) &amp;&amp;</span>
<span class="line-modified">12012         stream-&gt;track_id == qtdemux-&gt;chapters_track_id) {</span>
<span class="line-removed">12013       /* TODO - parse chapters track and expose it as GstToc; For now just ignore it</span>
<span class="line-removed">12014          so that it doesn&#39;t look like a subtitle track */</span>
<span class="line-removed">12015       gst_qtdemux_remove_stream (qtdemux, i);</span>
<span class="line-removed">12016       i--;</span>
<span class="line-removed">12017       continue;</span>
<span class="line-removed">12018     }</span>
12019 
<span class="line-modified">12020     /* now we have all info and can expose */</span>
<span class="line-modified">12021     list = stream-&gt;stream_tags;</span>
<span class="line-removed">12022     stream-&gt;stream_tags = NULL;</span>
<span class="line-removed">12023     if (oldpad)</span>
<span class="line-removed">12024       oldpads = g_slist_prepend (oldpads, oldpad);</span>
<span class="line-removed">12025     if (!gst_qtdemux_add_stream (qtdemux, stream, list))</span>
12026       return GST_FLOW_ERROR;












12027   }
12028 
12029   gst_qtdemux_guess_bitrate (qtdemux);
12030 
12031   gst_element_no_more_pads (GST_ELEMENT_CAST (qtdemux));
12032 
<span class="line-modified">12033   for (iter = oldpads; iter; iter = g_slist_next (iter)) {</span>
<span class="line-modified">12034     GstPad *oldpad = iter-&gt;data;</span>
<span class="line-modified">12035     GstEvent *event;</span>
12036 
<span class="line-modified">12037     event = gst_event_new_eos ();</span>
<span class="line-modified">12038     if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-modified">12039       gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);</span>



12040 
<span class="line-modified">12041     gst_pad_push_event (oldpad, event);</span>
<span class="line-modified">12042     gst_pad_set_active (oldpad, FALSE);</span>
<span class="line-removed">12043     gst_element_remove_pad (GST_ELEMENT (qtdemux), oldpad);</span>
<span class="line-removed">12044     gst_flow_combiner_remove_pad (qtdemux-&gt;flowcombiner, oldpad);</span>
<span class="line-removed">12045     gst_object_unref (oldpad);</span>
12046   }
12047 


12048   /* check if we should post a redirect in case there is a single trak
12049    * and it is a redirecting trak */
<span class="line-modified">12050   if (qtdemux-&gt;n_streams == 1 &amp;&amp; qtdemux-&gt;streams[0]-&gt;redirect_uri != NULL) {</span>

12051     GstMessage *m;
12052 
12053     GST_INFO_OBJECT (qtdemux, &quot;Issuing a redirect due to a single track with &quot;
12054         &quot;an external content&quot;);
12055     m = gst_message_new_element (GST_OBJECT_CAST (qtdemux),
12056         gst_structure_new (&quot;redirect&quot;,
<span class="line-modified">12057             &quot;new-location&quot;, G_TYPE_STRING, qtdemux-&gt;streams[0]-&gt;redirect_uri,</span>
<span class="line-modified">12058             NULL));</span>
12059     gst_element_post_message (GST_ELEMENT_CAST (qtdemux), m);
12060     qtdemux-&gt;posted_redirect = TRUE;
12061   }
12062 
<span class="line-modified">12063   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified">12064     QtDemuxStream *stream = qtdemux-&gt;streams[i];</span>
12065 
<span class="line-modified">12066     qtdemux_do_allocation (qtdemux, stream);</span>
<span class="line-removed">12067   }</span>
12068 
12069   qtdemux-&gt;exposed = TRUE;
12070   return GST_FLOW_OK;
12071 }
12072 
12073 /* check if major or compatible brand is 3GP */
12074 static inline gboolean
12075 qtdemux_is_brand_3gp (GstQTDemux * qtdemux, gboolean major)
12076 {
12077   if (major) {
12078     return ((qtdemux-&gt;major_brand &amp; GST_MAKE_FOURCC (255, 255, 0, 0)) ==
12079         FOURCC_3g__);
12080   } else if (qtdemux-&gt;comp_brands != NULL) {
12081     GstMapInfo map;
12082     guint8 *data;
12083     gsize size;
12084     gboolean res = FALSE;
12085 
12086     gst_buffer_map (qtdemux-&gt;comp_brands, &amp;map, GST_MAP_READ);
12087     data = map.data;
</pre>
<hr />
<pre>
12330         goto normal;
12331       }
12332     } else {
12333     normal:
12334       offset = 8;
12335       GST_DEBUG_OBJECT (qtdemux, &quot;found normal text tag&quot;);
12336       ret = FALSE;              /* may have to fallback */
12337     }
12338     if (charset) {
12339       GError *err = NULL;
12340 
12341       s = g_convert ((gchar *) node-&gt;data + offset, len - offset, &quot;utf8&quot;,
12342           charset, NULL, NULL, &amp;err);
12343       if (err) {
12344         GST_DEBUG_OBJECT (qtdemux, &quot;Failed to convert string from charset %s:&quot;
12345             &quot; %s(%d): %s&quot;, charset, g_quark_to_string (err-&gt;domain), err-&gt;code,
12346             err-&gt;message);
12347         g_error_free (err);
12348       }
12349     } else {
<span class="line-modified">12350     s = gst_tag_freeform_string_to_utf8 ((char *) node-&gt;data + offset,</span>
<span class="line-modified">12351         len - offset, env_vars);</span>
12352     }
12353     if (s) {
12354       GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %s&quot;, GST_STR_NULL (s));
12355       gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, s, NULL);
12356       g_free (s);
12357       ret = TRUE;
12358     } else {
12359       GST_DEBUG_OBJECT (qtdemux, &quot;failed to convert %s tag to UTF-8&quot;, tag);
12360     }
12361   }
12362   return ret;
12363 }
12364 
12365 static void
12366 qtdemux_tag_add_str (GstQTDemux * qtdemux, GstTagList * taglist,
12367     const char *tag, const char *dummy, GNode * node)
12368 {
12369   qtdemux_tag_add_str_full (qtdemux, taglist, tag, dummy, node);
12370 }
12371 
</pre>
<hr />
<pre>
12548         image_type = GST_TAG_IMAGE_TYPE_FRONT_COVER;
12549       else
12550         image_type = GST_TAG_IMAGE_TYPE_NONE;
12551 
12552       if ((sample =
12553               gst_tag_image_data_to_image_sample ((guint8 *) data-&gt;data + 16,
12554                   len - 16, image_type))) {
12555         GST_DEBUG_OBJECT (qtdemux, &quot;adding tag size %d&quot;, len - 16);
12556         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag1, sample, NULL);
12557         gst_sample_unref (sample);
12558       }
12559     }
12560   }
12561 }
12562 
12563 static void
12564 qtdemux_tag_add_date (GstQTDemux * qtdemux, GstTagList * taglist,
12565     const char *tag, const char *dummy, GNode * node)
12566 {
12567   GNode *data;

12568   char *s;
12569   int len;
12570   int type;
12571 
12572   data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
12573   if (data) {
12574     len = QT_UINT32 (data-&gt;data);
12575     type = QT_UINT32 ((guint8 *) data-&gt;data + 8);
12576     if (type == 0x00000001 &amp;&amp; len &gt; 16) {
12577       guint y, m = 1, d = 1;
12578       gint ret;
12579 
12580       s = g_strndup ((char *) data-&gt;data + 16, len - 16);
12581       GST_DEBUG_OBJECT (qtdemux, &quot;adding date &#39;%s&#39;&quot;, s);







12582       ret = sscanf (s, &quot;%u-%u-%u&quot;, &amp;y, &amp;m, &amp;d);
12583       if (ret &gt;= 1 &amp;&amp; y &gt; 1500 &amp;&amp; y &lt; 3000) {
12584         GDate *date;
12585 
12586         date = g_date_new_dmy (d, m, y);
12587         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, date, NULL);
12588         g_date_free (date);
12589       } else {
12590         GST_DEBUG_OBJECT (qtdemux, &quot;could not parse date string &#39;%s&#39;&quot;, s);
12591       }
12592       g_free (s);
12593     }
12594   }
12595 }
12596 
12597 static void
12598 qtdemux_tag_add_gnre (GstQTDemux * qtdemux, GstTagList * taglist,
12599     const char *tag, const char *dummy, GNode * node)
12600 {
12601   GNode *data;
</pre>
<hr />
<pre>
12765 
12766   return;
12767 
12768 /* errors */
12769 unknown_tag:
12770 #ifndef GST_DISABLE_GST_DEBUG
12771   {
12772     gchar *namestr_dbg;
12773     gchar *meanstr_dbg;
12774 
12775     meanstr_dbg = g_strndup (meanstr, meansize);
12776     namestr_dbg = g_strndup (namestr, namesize);
12777 
12778     GST_WARNING_OBJECT (demux, &quot;This tag %s:%s type:%u is not mapped, &quot;
12779         &quot;file a bug at bugzilla.gnome.org&quot;, meanstr_dbg, namestr_dbg, datatype);
12780 
12781     g_free (namestr_dbg);
12782     g_free (meanstr_dbg);
12783   }
12784 #endif
<span class="line-modified">12785     return;</span>
12786 }
12787 
12788 static void
12789 qtdemux_tag_add_id32 (GstQTDemux * demux, GstTagList * taglist, const char *tag,
12790     const char *tag_bis, GNode * node)
12791 {
12792   guint8 *data;
12793   GstBuffer *buf;
12794   guint len;
12795   GstTagList *id32_taglist = NULL;
12796 
12797   GST_LOG_OBJECT (demux, &quot;parsing ID32&quot;);
12798 
12799   data = node-&gt;data;
12800   len = GST_READ_UINT32_BE (data);
12801 
12802   /* need at least full box and language tag */
12803   if (len &lt; 12 + 2)
12804     return;
12805 
</pre>
<hr />
<pre>
13142 #endif
13143         guint check_type = QT_UINT16 ((guint8 *) rmvc-&gt;data + 24);
13144 
13145         GST_LOG_OBJECT (qtdemux,
13146             &quot;version check atom [%&quot; GST_FOURCC_FORMAT &quot;], version=0x%08x&quot;
13147             &quot;, mask=%08x, check_type=%u&quot;, GST_FOURCC_ARGS (package), version,
13148             bitmask, check_type);
13149         if (package == FOURCC_qtim &amp;&amp; check_type == 0) {
13150           ref.min_req_qt_version = version;
13151         }
13152       }
13153 
13154       rdrf = qtdemux_tree_get_child_by_type (rmda, FOURCC_rdrf);
13155       if (rdrf) {
13156         guint32 ref_type;
13157         guint8 *ref_data;
13158         guint ref_len;
13159 
13160         ref_len = QT_UINT32 ((guint8 *) rdrf-&gt;data);
13161         if (ref_len &gt; 20) {
<span class="line-modified">13162         ref_type = QT_FOURCC ((guint8 *) rdrf-&gt;data + 12);</span>
<span class="line-modified">13163         ref_data = (guint8 *) rdrf-&gt;data + 20;</span>
<span class="line-modified">13164         if (ref_type == FOURCC_alis) {</span>
<span class="line-modified">13165           guint record_len, record_version, fn_len;</span>
13166 
13167             if (ref_len &gt; 70) {
<span class="line-modified">13168           /* MacOSX alias record, google for alias-layout.txt */</span>
<span class="line-modified">13169           record_len = QT_UINT16 (ref_data + 4);</span>
<span class="line-modified">13170           record_version = QT_UINT16 (ref_data + 4 + 2);</span>
<span class="line-modified">13171           fn_len = QT_UINT8 (ref_data + 50);</span>
<span class="line-modified">13172           if (record_len &gt; 50 &amp;&amp; record_version == 2 &amp;&amp; fn_len &gt; 0) {</span>
<span class="line-modified">13173             ref.location = g_strndup ((gchar *) ref_data + 51, fn_len);</span>
<span class="line-modified">13174           }</span>
13175             } else {
13176               GST_WARNING_OBJECT (qtdemux, &quot;Invalid rdrf/alis size (%u &lt; 70)&quot;,
13177                   ref_len);
13178             }
<span class="line-modified">13179         } else if (ref_type == FOURCC_url_) {</span>
13180             ref.location = g_strndup ((gchar *) ref_data, ref_len - 8);
<span class="line-modified">13181         } else {</span>
<span class="line-modified">13182           GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">13183               &quot;unknown rdrf reference type %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">13184               GST_FOURCC_ARGS (ref_type));</span>
<span class="line-modified">13185         }</span>
<span class="line-modified">13186         if (ref.location != NULL) {</span>
<span class="line-modified">13187           GST_INFO_OBJECT (qtdemux, &quot;New location: %s&quot;, ref.location);</span>
13188             redirects =
13189                 g_list_prepend (redirects, g_memdup (&amp;ref, sizeof (ref)));
<span class="line-modified">13190         } else {</span>
<span class="line-modified">13191           GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-modified">13192               &quot;Failed to extract redirect location from rdrf atom&quot;);</span>
<span class="line-modified">13193         }</span>
13194         } else {
13195           GST_WARNING_OBJECT (qtdemux, &quot;Invalid rdrf size (%u &lt; 20)&quot;, ref_len);
<span class="line-modified">13196       }</span>
13197       }
13198 
13199       /* look for others */
13200       rmda = qtdemux_tree_get_sibling_by_type (rmda, FOURCC_rmda);
13201     }
13202 
13203     if (redirects != NULL) {
13204       qtdemux_process_redirects (qtdemux, redirects);
13205     }
13206   }
13207   return TRUE;
13208 }
13209 
13210 static GstTagList *
13211 qtdemux_add_container_format (GstQTDemux * qtdemux, GstTagList * tags)
13212 {
13213   const gchar *fmt;
13214 
13215   if (tags == NULL) {
13216     tags = gst_tag_list_new_empty ();
</pre>
<hr />
<pre>
13231   GST_LOG_OBJECT (qtdemux, &quot;mapped %&quot; GST_FOURCC_FORMAT &quot; to &#39;%s&#39;&quot;,
13232       GST_FOURCC_ARGS (qtdemux-&gt;major_brand), fmt);
13233 
13234   gst_tag_list_add (tags, GST_TAG_MERGE_REPLACE, GST_TAG_CONTAINER_FORMAT,
13235       fmt, NULL);
13236 
13237   return tags;
13238 }
13239 
13240 /* we have read the complete moov node now.
13241  * This function parses all of the relevant info, creates the traks and
13242  * prepares all data structures for playback
13243  */
13244 static gboolean
13245 qtdemux_parse_tree (GstQTDemux * qtdemux)
13246 {
13247   GNode *mvhd;
13248   GNode *trak;
13249   GNode *udta;
13250   GNode *mvex;
<span class="line-removed">13251   GstClockTime duration;</span>
13252   GNode *pssh;
13253   guint64 creation_time;
13254   GstDateTime *datetime = NULL;
13255   gint version;
13256 
13257   /* make sure we have a usable taglist */
<span class="line-modified">13258     qtdemux-&gt;tag_list = gst_tag_list_make_writable (qtdemux-&gt;tag_list);</span>
13259 
13260   mvhd = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_mvhd);
13261   if (mvhd == NULL) {
13262     GST_LOG_OBJECT (qtdemux, &quot;No mvhd node found, looking for redirects.&quot;);
13263     return qtdemux_parse_redirects (qtdemux);
13264   }
13265 
13266   version = QT_UINT8 ((guint8 *) mvhd-&gt;data + 8);
13267   if (version == 1) {
13268     creation_time = QT_UINT64 ((guint8 *) mvhd-&gt;data + 12);
13269     qtdemux-&gt;timescale = QT_UINT32 ((guint8 *) mvhd-&gt;data + 28);
13270     qtdemux-&gt;duration = QT_UINT64 ((guint8 *) mvhd-&gt;data + 32);
13271   } else if (version == 0) {
13272     creation_time = QT_UINT32 ((guint8 *) mvhd-&gt;data + 12);
13273     qtdemux-&gt;timescale = QT_UINT32 ((guint8 *) mvhd-&gt;data + 20);
13274     qtdemux-&gt;duration = QT_UINT32 ((guint8 *) mvhd-&gt;data + 24);
13275   } else {
13276     GST_WARNING_OBJECT (qtdemux, &quot;Unhandled mvhd version %d&quot;, version);
13277     return FALSE;
13278   }
13279 
13280   /* Moving qt creation time (secs since 1904) to unix time */
13281   if (creation_time != 0) {
13282     /* Try to use epoch first as it should be faster and more commonly found */
13283     if (creation_time &gt;= QTDEMUX_SECONDS_FROM_1904_TO_1970) {
13284       GTimeVal now;
13285 
13286       creation_time -= QTDEMUX_SECONDS_FROM_1904_TO_1970;
13287       /* some data cleansing sanity */
13288       g_get_current_time (&amp;now);
13289       if (now.tv_sec + 24 * 3600 &lt; creation_time) {
13290         GST_DEBUG_OBJECT (qtdemux, &quot;discarding bogus future creation time&quot;);
<span class="line-modified">13291     } else {</span>
13292         datetime = gst_date_time_new_from_unix_epoch_utc (creation_time);
<span class="line-modified">13293     }</span>
13294     } else {
13295       GDateTime *base_dt = g_date_time_new_utc (1904, 1, 1, 0, 0, 0);
13296       GDateTime *dt, *dt_local;
13297 
13298       dt = g_date_time_add_seconds (base_dt, creation_time);
13299       dt_local = g_date_time_to_local (dt);
13300       datetime = gst_date_time_new_from_g_date_time (dt_local);
13301 
13302       g_date_time_unref (base_dt);
13303       g_date_time_unref (dt);
<span class="line-modified">13304   }</span>
13305   }
13306   if (datetime) {
13307     /* Use KEEP as explicit tags should have a higher priority than mvhd tag */
13308     gst_tag_list_add (qtdemux-&gt;tag_list, GST_TAG_MERGE_KEEP, GST_TAG_DATE_TIME,
13309         datetime, NULL);
13310     gst_date_time_unref (datetime);
13311   }
13312 
13313   GST_INFO_OBJECT (qtdemux, &quot;timescale: %u&quot;, qtdemux-&gt;timescale);
13314   GST_INFO_OBJECT (qtdemux, &quot;duration: %&quot; G_GUINT64_FORMAT, qtdemux-&gt;duration);
13315 
13316   /* check for fragmented file and get some (default) data */
13317   mvex = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_mvex);
13318   if (mvex) {
13319     GNode *mehd;
13320     GstByteReader mehd_data;
13321 
13322     /* let track parsing or anyone know weird stuff might happen ... */
13323     qtdemux-&gt;fragmented = TRUE;
13324 
13325     /* compensate for total duration */
13326     mehd = qtdemux_tree_get_child_by_type_full (mvex, FOURCC_mehd, &amp;mehd_data);
13327     if (mehd)
13328       qtdemux_parse_mehd (qtdemux, &amp;mehd_data);
13329   }
13330 
<span class="line-modified">13331   /* set duration in the segment info */</span>
<span class="line-modified">13332   gst_qtdemux_get_duration (qtdemux, &amp;duration);</span>
<span class="line-modified">13333   if (duration) {</span>




13334     qtdemux-&gt;segment.duration = duration;
13335     /* also do not exceed duration; stop is set that way post seek anyway,
13336      * and segment activation falls back to duration,
13337      * whereas loop only checks stop, so let&#39;s align this here as well */
13338     qtdemux-&gt;segment.stop = duration;
13339   }
13340 
13341   /* parse all traks */
13342   trak = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_trak);
13343   while (trak) {
13344 #ifdef GSTREAMER_LITE
13345       if (!qtdemux_parse_trak (qtdemux, trak))
13346         return FALSE;
13347 #else
13348     qtdemux_parse_trak (qtdemux, trak);
13349 #endif // GSTREAMER_LITE
13350     /* iterate all siblings */
13351     trak = qtdemux_tree_get_sibling_by_type (trak, FOURCC_trak);
13352   }
13353 
</pre>
<hr />
<pre>
13388 read_descr_size (guint8 * ptr, guint8 * end, guint8 ** end_out)
13389 {
13390   int count = 4;
13391   int len = 0;
13392 
13393   while (count--) {
13394     int c;
13395 
13396     if (ptr &gt;= end)
13397       return -1;
13398 
13399     c = *ptr++;
13400     len = (len &lt;&lt; 7) | (c &amp; 0x7f);
13401     if (!(c &amp; 0x80))
13402       break;
13403   }
13404   *end_out = ptr;
13405   return len;
13406 }
13407 











































































13408 /* this can change the codec originally present in @list */
13409 #ifdef GSTREAMER_LITE
13410 static gboolean
13411 #else
13412 static void
13413 #endif // GSTREAMER_LITE
13414 gst_qtdemux_handle_esds (GstQTDemux * qtdemux, QtDemuxStream * stream,
13415     QtDemuxStreamStsdEntry * entry, GNode * esds, GstTagList * list)
13416 {
13417   int len = QT_UINT32 (esds-&gt;data);
13418   guint8 *ptr = esds-&gt;data;
13419   guint8 *end = ptr + len;
13420   int tag;
13421   guint8 *data_ptr = NULL;
13422   int data_len = 0;
13423   guint8 object_type_id = 0;

13424   const char *codec_name = NULL;
13425   GstCaps *caps = NULL;
13426 
13427   GST_MEMDUMP_OBJECT (qtdemux, &quot;esds&quot;, ptr, len);
13428   ptr += 8;
13429   GST_DEBUG_OBJECT (qtdemux, &quot;version/flags = %08x&quot;, QT_UINT32 (ptr));
13430   ptr += 4;
13431   while (ptr + 1 &lt; end) {
13432     tag = QT_UINT8 (ptr);
13433     GST_DEBUG_OBJECT (qtdemux, &quot;tag = %02x&quot;, tag);
13434     ptr++;
13435     len = read_descr_size (ptr, end, &amp;ptr);
13436     GST_DEBUG_OBJECT (qtdemux, &quot;len = %d&quot;, len);
13437 
13438     /* Check the stated amount of data is available for reading */
13439     if (len &lt; 0 || ptr + len &gt; end)
13440       break;
13441 
13442     switch (tag) {
13443       case ES_DESCRIPTOR_TAG:
<span class="line-modified">13444         GST_DEBUG_OBJECT (qtdemux, &quot;ID %04x&quot;, QT_UINT16 (ptr));</span>
<span class="line-modified">13445         GST_DEBUG_OBJECT (qtdemux, &quot;priority %04x&quot;, QT_UINT8 (ptr + 2));</span>
13446         ptr += 3;
13447         break;
13448       case DECODER_CONFIG_DESC_TAG:{
13449         guint max_bitrate, avg_bitrate;
13450 
13451         object_type_id = QT_UINT8 (ptr);

13452         max_bitrate = QT_UINT32 (ptr + 5);
13453         avg_bitrate = QT_UINT32 (ptr + 9);
13454         GST_DEBUG_OBJECT (qtdemux, &quot;object_type_id %02x&quot;, object_type_id);
<span class="line-modified">13455         GST_DEBUG_OBJECT (qtdemux, &quot;stream_type %02x&quot;, QT_UINT8 (ptr + 1));</span>
13456         GST_DEBUG_OBJECT (qtdemux, &quot;buffer_size_db %02x&quot;, QT_UINT24 (ptr + 2));
13457         GST_DEBUG_OBJECT (qtdemux, &quot;max bitrate %u&quot;, max_bitrate);
13458         GST_DEBUG_OBJECT (qtdemux, &quot;avg bitrate %u&quot;, avg_bitrate);
13459         if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; G_MAXUINT32) {
13460           gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
13461               GST_TAG_MAXIMUM_BITRATE, max_bitrate, NULL);
13462         }
13463         if (avg_bitrate &gt; 0 &amp;&amp; avg_bitrate &lt; G_MAXUINT32) {
13464           gst_tag_list_add (list, GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE,
13465               avg_bitrate, NULL);
13466         }
13467         ptr += 13;
13468         break;
13469       }
13470       case DECODER_SPECIFIC_INFO_TAG:
13471         GST_MEMDUMP_OBJECT (qtdemux, &quot;data&quot;, ptr, len);
13472 #ifdef GSTREAMER_LITE
13473         if (end - len &lt; ptr)
13474             return FALSE;
13475 #endif // GSTREAMER_LITE
</pre>
<hr />
<pre>
13585         rate_idx =
13586             gst_codec_utils_aac_get_index_from_sample_rate (CUR_STREAM
13587             (stream)-&gt;rate);
13588 
13589         switch (object_type_id) {
13590           case 0x66:
13591             profile_str = &quot;main&quot;;
13592             profile = 0;
13593             break;
13594           case 0x67:
13595             profile_str = &quot;lc&quot;;
13596             profile = 1;
13597             break;
13598           case 0x68:
13599             profile_str = &quot;ssr&quot;;
13600             profile = 2;
13601             break;
13602           default:
13603             profile = 3;
13604             break;
<span class="line-modified">13605       }</span>
13606 
13607         codec_data[0] = ((profile + 1) &lt;&lt; 3) | ((rate_idx &amp; 0xE) &gt;&gt; 1);
13608         codec_data[1] =
13609             ((rate_idx &amp; 0x1) &lt;&lt; 7) | (CUR_STREAM (stream)-&gt;n_channels &lt;&lt; 3);
13610 
13611         gst_buffer_unmap (buffer, &amp;map);
13612         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;codec_data&quot;,
13613             GST_TYPE_BUFFER, buffer, NULL);
13614         gst_buffer_unref (buffer);
13615 
13616         if (profile_str) {
13617           gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;profile&quot;,
13618               G_TYPE_STRING, profile_str, NULL);
13619         }
13620       }
13621       break;
13622     case 0x60:                 /* MPEG-2, various profiles */
13623     case 0x61:
13624     case 0x62:
13625     case 0x63:
</pre>
<hr />
<pre>
13655       codec_name = &quot;PNG still images&quot;;
13656       break;
13657     case 0x6E:                 /* JPEG2000 */
13658       codec_name = &quot;JPEG-2000&quot;;
13659       caps = gst_caps_new_simple (&quot;image/x-j2c&quot;, &quot;fields&quot;, G_TYPE_INT, 1, NULL);
13660       break;
13661     case 0xA4:                 /* Dirac */
13662       codec_name = &quot;Dirac&quot;;
13663       caps = gst_caps_new_empty_simple (&quot;video/x-dirac&quot;);
13664       break;
13665     case 0xA5:                 /* AC3 */
13666       codec_name = &quot;AC-3 audio&quot;;
13667       caps = gst_caps_new_simple (&quot;audio/x-ac3&quot;,
13668           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
13669       break;
13670     case 0xA9:                 /* AC3 */
13671       codec_name = &quot;DTS audio&quot;;
13672       caps = gst_caps_new_simple (&quot;audio/x-dts&quot;,
13673           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
13674       break;





























13675     case 0xE1:                 /* QCELP */
13676       /* QCELP, the codec_data is a riff tag (little endian) with
13677        * more info (http://ftp.3gpp2.org/TSGC/Working/2003/2003-05-SanDiego/TSG-C-2003-05-San%20Diego/WG1/SWG12/C12-20030512-006%20=%20C12-20030217-015_Draft_Baseline%20Text%20of%20FFMS_R2.doc). */
13678       caps = gst_caps_new_empty_simple (&quot;audio/qcelp&quot;);
13679       codec_name = &quot;QCELP&quot;;
13680       break;
13681     default:
13682       break;
13683   }
13684 
13685   /* If we have a replacement caps, then change our caps for this stream */
13686   if (caps) {
13687     gst_caps_unref (entry-&gt;caps);
13688     entry-&gt;caps = caps;
13689   }
13690 
13691   if (codec_name &amp;&amp; list)
13692     gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
13693         GST_TAG_AUDIO_CODEC, codec_name, NULL);
13694 
</pre>
<hr />
<pre>
13714           case 0x68:                 /* AAC SSR */
13715           {
13716               GstMapInfo info;
13717               int esds_len = QT_UINT32 (esds-&gt;data);
13718               GstBuffer* esds_buffer = gst_buffer_new_allocate (NULL, esds_len, NULL);
13719               if (esds_buffer)
13720               {
13721                   if (gst_buffer_map(esds_buffer, &amp;info, GST_MAP_WRITE))
13722                   {
13723                       memcpy (info.data, esds-&gt;data, esds_len);
13724                       gst_buffer_unmap(esds_buffer, &amp;info);
13725 
13726                       GST_DEBUG_OBJECT (qtdemux, &quot;setting esds_data from esds&quot;);
13727                       GST_MEMDUMP_OBJECT (qtdemux, &quot;esds_data from esds&quot;, esds-&gt;data, esds_len);
13728 
13729                       gst_caps_set_simple (entry-&gt;caps, &quot;esds_data&quot;, GST_TYPE_BUFFER,
13730                                    esds_buffer, NULL);
13731                   }
13732 
13733                   gst_buffer_unref (esds_buffer);
<span class="line-modified">13734               }</span>
13735           }
13736               break;
13737           default:
13738               break;
13739       }
<span class="line-modified">13740 #endif</span>
13741 
13742   }
13743 
13744 #ifdef GSTREAMER_LITE
13745     return TRUE;
13746 #endif
13747 }
13748 
13749 static inline GstCaps *
13750 _get_unknown_codec_name (const gchar * type, guint32 fourcc)
13751 {
13752   GstCaps *caps;
13753   guint i;
13754   char *s, fourstr[5];
13755 
13756   g_snprintf (fourstr, 5, &quot;%&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));
13757   for (i = 0; i &lt; 4; i++) {
13758     if (!g_ascii_isalnum (fourstr[i]))
13759       fourstr[i] = &#39;_&#39;;
13760   }
</pre>
<hr />
<pre>
14158       caps =
14159           gst_caps_new_simple (&quot;video/x-prores&quot;, &quot;variant&quot;, G_TYPE_STRING,
14160           &quot;4444&quot;, NULL);
14161       break;
14162     case FOURCC_ap4x:
14163       _codec (&quot;Apple ProRes 4444 XQ&quot;);
14164       caps =
14165           gst_caps_new_simple (&quot;video/x-prores&quot;, &quot;variant&quot;, G_TYPE_STRING,
14166           &quot;4444xq&quot;, NULL);
14167       break;
14168     case FOURCC_cfhd:
14169       _codec (&quot;GoPro CineForm&quot;);
14170       caps = gst_caps_from_string (&quot;video/x-cineform&quot;);
14171       break;
14172     case FOURCC_vc_1:
14173     case FOURCC_ovc1:
14174       _codec (&quot;VC-1&quot;);
14175       caps = gst_caps_new_simple (&quot;video/x-wmv&quot;,
14176           &quot;wmvversion&quot;, G_TYPE_INT, 3, &quot;format&quot;, G_TYPE_STRING, &quot;WVC1&quot;, NULL);
14177       break;




14178     case GST_MAKE_FOURCC (&#39;k&#39;, &#39;p&#39;, &#39;c&#39;, &#39;d&#39;):
14179     default:
14180     {
14181       caps = _get_unknown_codec_name (&quot;video&quot;, fourcc);
14182       break;
14183     }
14184   }
14185 
14186   if (format != GST_VIDEO_FORMAT_UNKNOWN) {
14187     GstVideoInfo info;
14188 
14189     gst_video_info_init (&amp;info);
14190     gst_video_info_set_format (&amp;info, format, entry-&gt;width, entry-&gt;height);
14191 
14192     caps = gst_video_info_to_caps (&amp;info);
14193     *codec_name = gst_pb_utils_get_codec_description (caps);
14194 
<span class="line-modified">14195   /* enable clipping for raw video streams */</span>
14196     stream-&gt;need_clip = TRUE;
14197     stream-&gt;alignment = 32;
14198   }
14199 
14200   return caps;
14201 }
14202 
14203 static guint
14204 round_up_pow2 (guint n)
14205 {
14206   n = n - 1;
14207   n = n | (n &gt;&gt; 1);
14208   n = n | (n &gt;&gt; 2);
14209   n = n | (n &gt;&gt; 4);
14210   n = n | (n &gt;&gt; 8);
14211   n = n | (n &gt;&gt; 16);
14212   return n + 1;
14213 }
14214 
14215 static GstCaps *
</pre>
<hr />
<pre>
14229   depth = entry-&gt;bytes_per_packet * 8;
14230 
14231   switch (fourcc) {
14232     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;O&#39;, &#39;N&#39;, &#39;E&#39;):
14233     case FOURCC_raw_:
14234       /* 8-bit audio is unsigned */
14235       if (depth == 8)
14236         format = GST_AUDIO_FORMAT_U8;
14237       /* otherwise it&#39;s signed and big-endian just like &#39;twos&#39; */
14238     case FOURCC_twos:
14239       endian = G_BIG_ENDIAN;
14240       /* fall-through */
14241     case FOURCC_sowt:
14242     {
14243       gchar *str;
14244 
14245       if (!endian)
14246         endian = G_LITTLE_ENDIAN;
14247 
14248       if (!format)
<span class="line-modified">14249       format = gst_audio_format_build_integer (TRUE, endian, depth, depth);</span>
14250 
14251       str = g_strdup_printf (&quot;Raw %d-bit PCM audio&quot;, depth);
14252       _codec (str);
14253       g_free (str);
14254 
14255       caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
14256           &quot;format&quot;, G_TYPE_STRING, gst_audio_format_to_string (format),
14257           &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;, NULL);
14258       stream-&gt;alignment = GST_ROUND_UP_8 (depth);
14259       stream-&gt;alignment = round_up_pow2 (stream-&gt;alignment);
14260       break;
14261     }
14262     case GST_MAKE_FOURCC (&#39;f&#39;, &#39;l&#39;, &#39;6&#39;, &#39;4&#39;):
14263       _codec (&quot;Raw 64-bit floating-point audio&quot;);
14264       caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
14265           &quot;format&quot;, G_TYPE_STRING, &quot;F64BE&quot;,
14266           &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;, NULL);
14267       stream-&gt;alignment = 8;
14268       break;
14269     case GST_MAKE_FOURCC (&#39;f&#39;, &#39;l&#39;, &#39;3&#39;, &#39;2&#39;):
</pre>
<hr />
<pre>
14552     case FOURCC_mp4s:
14553       _codec (&quot;DVD subtitle&quot;);
14554       caps = gst_caps_new_empty_simple (&quot;subpicture/x-dvd&quot;);
14555       stream-&gt;need_process = TRUE;
14556       break;
14557     case FOURCC_text:
14558       _codec (&quot;Quicktime timed text&quot;);
14559       goto text;
14560     case FOURCC_tx3g:
14561       _codec (&quot;3GPP timed text&quot;);
14562     text:
14563       caps = gst_caps_new_simple (&quot;text/x-raw&quot;, &quot;format&quot;, G_TYPE_STRING,
14564           &quot;utf8&quot;, NULL);
14565       /* actual text piece needs to be extracted */
14566       stream-&gt;need_process = TRUE;
14567       break;
14568     case FOURCC_stpp:
14569       _codec (&quot;XML subtitles&quot;);
14570       caps = gst_caps_new_empty_simple (&quot;application/ttml+xml&quot;);
14571       break;
















14572     default:
14573     {
14574       caps = _get_unknown_codec_name (&quot;text&quot;, fourcc);
14575       break;
14576     }
14577   }
14578   return caps;
14579 }
14580 
14581 static GstCaps *
14582 qtdemux_generic_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
14583     QtDemuxStreamStsdEntry * entry, guint32 fourcc,
14584     const guint8 * stsd_entry_data, gchar ** codec_name)
14585 {
14586   GstCaps *caps;
14587 
14588   switch (fourcc) {
14589     case FOURCC_m1v:
14590       _codec (&quot;MPEG 1 video&quot;);
14591       caps = gst_caps_new_simple (&quot;video/mpeg&quot;, &quot;mpegversion&quot;, G_TYPE_INT, 1,
</pre>
</td>
<td>
<hr />
<pre>
   81 
   82 /* max. size considered &#39;sane&#39; for non-mdat atoms */
   83 #define QTDEMUX_MAX_ATOM_SIZE (25*1024*1024)
   84 
   85 /* if the sample index is larger than this, something is likely wrong */
   86 #ifdef GSTREAMER_LITE
   87 // relaxing the limitation since some long files has more than 50Mb sample index
   88 #define QTDEMUX_MAX_SAMPLE_INDEX_SIZE (500*1024*1024)
   89 #else
   90 #define QTDEMUX_MAX_SAMPLE_INDEX_SIZE (200*1024*1024)
   91 #endif // GSTREAMER_LITE
   92 
   93 /* For converting qt creation times to unix epoch times */
   94 #define QTDEMUX_SECONDS_PER_DAY (60 * 60 * 24)
   95 #define QTDEMUX_LEAP_YEARS_FROM_1904_TO_1970 17
   96 #define QTDEMUX_SECONDS_FROM_1904_TO_1970 (((1970 - 1904) * (guint64) 365 + \
   97     QTDEMUX_LEAP_YEARS_FROM_1904_TO_1970) * QTDEMUX_SECONDS_PER_DAY)
   98 
   99 #define QTDEMUX_TREE_NODE_FOURCC(n) (QT_FOURCC(((guint8 *) (n)-&gt;data) + 4))
  100 
<span class="line-modified">  101 #define STREAM_IS_EOS(s) ((s)-&gt;time_position == GST_CLOCK_TIME_NONE)</span>
  102 
  103 #define ABSDIFF(x, y) ( (x) &gt; (y) ? ((x) - (y)) : ((y) - (x)) )
  104 
<span class="line-added">  105 #define QTDEMUX_STREAM(s) ((QtDemuxStream *)(s))</span>
<span class="line-added">  106 #define QTDEMUX_N_STREAMS(demux) ((demux)-&gt;active_streams-&gt;len)</span>
<span class="line-added">  107 #define QTDEMUX_NTH_STREAM(demux,idx) \</span>
<span class="line-added">  108    QTDEMUX_STREAM(g_ptr_array_index((demux)-&gt;active_streams,idx))</span>
<span class="line-added">  109 #define QTDEMUX_NTH_OLD_STREAM(demux,idx) \</span>
<span class="line-added">  110    QTDEMUX_STREAM(g_ptr_array_index((demux)-&gt;old_streams,idx))</span>
<span class="line-added">  111 </span>
  112 GST_DEBUG_CATEGORY (qtdemux_debug);
  113 #define GST_CAT_DEFAULT qtdemux_debug
  114 
  115 typedef struct _QtDemuxSegment QtDemuxSegment;
  116 typedef struct _QtDemuxSample QtDemuxSample;
  117 
  118 typedef struct _QtDemuxCencSampleSetInfo QtDemuxCencSampleSetInfo;
  119 
  120 struct _QtDemuxSample
  121 {
  122   guint32 size;
  123   gint32 pts_offset;            /* Add this value to timestamp to get the pts */
  124   guint64 offset;
  125   guint64 timestamp;            /* DTS In mov time */
  126   guint32 duration;             /* In mov time */
  127   gboolean keyframe;            /* TRUE when this packet is a keyframe */
  128 };
  129 
  130 /* Macros for converting to/from timescale */
  131 #define QTSTREAMTIME_TO_GSTTIME(stream, value) (gst_util_uint64_scale((value), GST_SECOND, (stream)-&gt;timescale))
  132 #define GSTTIME_TO_QTSTREAMTIME(stream, value) (gst_util_uint64_scale((value), (stream)-&gt;timescale, GST_SECOND))
  133 
  134 #define QTTIME_TO_GSTTIME(qtdemux, value) (gst_util_uint64_scale((value), GST_SECOND, (qtdemux)-&gt;timescale))
  135 #define GSTTIME_TO_QTTIME(qtdemux, value) (gst_util_uint64_scale((value), (qtdemux)-&gt;timescale, GST_SECOND))
  136 
  137 /* timestamp is the DTS */
  138 #define QTSAMPLE_DTS(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)-&gt;timestamp))
  139 /* timestamp + offset + cslg_shift is the outgoing PTS */
  140 #define QTSAMPLE_PTS(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)-&gt;timestamp + (stream)-&gt;cslg_shift + (sample)-&gt;pts_offset))
  141 /* timestamp + offset is the PTS used for internal seek calcuations */
  142 #define QTSAMPLE_PTS_NO_CSLG(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)-&gt;timestamp + (sample)-&gt;pts_offset))
  143 /* timestamp + duration - dts is the duration */
  144 #define QTSAMPLE_DUR_DTS(stream, sample, dts) (QTSTREAMTIME_TO_GSTTIME ((stream), (sample)-&gt;timestamp + (sample)-&gt;duration) - (dts))
  145 
  146 #define QTSAMPLE_KEYFRAME(stream,sample) ((stream)-&gt;all_keyframe || (sample)-&gt;keyframe)
  147 
<span class="line-added">  148 #define QTDEMUX_EXPOSE_GET_LOCK(demux) (&amp;((demux)-&gt;expose_lock))</span>
<span class="line-added">  149 #define QTDEMUX_EXPOSE_LOCK(demux) G_STMT_START { \</span>
<span class="line-added">  150     GST_TRACE(&quot;Locking from thread %p&quot;, g_thread_self()); \</span>
<span class="line-added">  151     g_mutex_lock (QTDEMUX_EXPOSE_GET_LOCK (demux)); \</span>
<span class="line-added">  152     GST_TRACE(&quot;Locked from thread %p&quot;, g_thread_self()); \</span>
<span class="line-added">  153  } G_STMT_END</span>
<span class="line-added">  154 </span>
<span class="line-added">  155 #define QTDEMUX_EXPOSE_UNLOCK(demux) G_STMT_START { \</span>
<span class="line-added">  156     GST_TRACE(&quot;Unlocking from thread %p&quot;, g_thread_self()); \</span>
<span class="line-added">  157     g_mutex_unlock (QTDEMUX_EXPOSE_GET_LOCK (demux)); \</span>
<span class="line-added">  158  } G_STMT_END</span>
<span class="line-added">  159 </span>
  160 /*
  161  * Quicktime has tracks and segments. A track is a continuous piece of
  162  * multimedia content. The track is not always played from start to finish but
  163  * instead, pieces of the track are &#39;cut out&#39; and played in sequence. This is
  164  * what the segments do.
  165  *
  166  * Inside the track we have keyframes (K) and delta frames. The track has its
  167  * own timing, which starts from 0 and extends to end. The position in the track
  168  * is called the media_time.
  169  *
  170  * The segments now describe the pieces that should be played from this track
  171  * and are basically tuples of media_time/duration/rate entries. We can have
  172  * multiple segments and they are all played after one another. An example:
  173  *
  174  * segment 1: media_time: 1 second, duration: 1 second, rate 1
  175  * segment 2: media_time: 3 second, duration: 2 second, rate 2
  176  *
  177  * To correctly play back this track, one must play: 1 second of media starting
  178  * from media_time 1 followed by 2 seconds of media starting from media_time 3
  179  * at a rate of 2.
</pre>
<hr />
<pre>
  264   gint n_channels;
  265   guint samples_per_packet;
  266   guint samples_per_frame;
  267   guint bytes_per_packet;
  268   guint bytes_per_sample;
  269   guint bytes_per_frame;
  270   guint compression;
  271 
  272   /* if we use chunks or samples */
  273   gboolean sampled;
  274   guint padding;
  275 
  276 } QtDemuxStreamStsdEntry;
  277 
  278 #define CUR_STREAM(s) (&amp;((s)-&gt;stsd_entries[(s)-&gt;cur_stsd_entry_index]))
  279 
  280 struct _QtDemuxStream
  281 {
  282   GstPad *pad;
  283 
<span class="line-added">  284   GstQTDemux *demux;</span>
<span class="line-added">  285   gchar *stream_id;</span>
<span class="line-added">  286 </span>
  287   QtDemuxStreamStsdEntry *stsd_entries;
  288   guint stsd_entries_length;
  289   guint cur_stsd_entry_index;
  290 
  291   /* stream type */
  292   guint32 subtype;
  293 
  294   gboolean new_caps;            /* If TRUE, caps need to be generated (by
  295                                  * calling _configure_stream()) This happens
  296                                  * for MSS and fragmented streams */
  297 
  298   gboolean new_stream;          /* signals that a stream_start is required */
  299   gboolean on_keyframe;         /* if this stream last pushed buffer was a
  300                                  * keyframe. This is important to identify
  301                                  * where to stop pushing buffers after a
  302                                  * segment stop time */
  303 
  304   /* if the stream has a redirect URI in its headers, we store it here */
  305   gchar *redirect_uri;
  306 
  307   /* track id */
  308   guint track_id;
  309 #ifdef GSTREAMER_LITE
  310   gboolean track_enabled;
  311 #endif // GSTREAMER_LITE
  312 
  313   /* duration/scale */
  314   guint64 duration;             /* in timescale units */
  315   guint32 timescale;
  316 
  317   /* language */
  318   gchar lang_id[4];             /* ISO 639-2T language code */
  319 
  320   /* our samples */
  321   guint32 n_samples;
  322   QtDemuxSample *samples;
  323   gboolean all_keyframe;        /* TRUE when all samples are keyframes (no stss) */


  324   guint32 n_samples_moof;       /* sample count in a moof */
  325   guint64 duration_moof;        /* duration in timescale of a moof, used for figure out
  326                                  * the framerate of fragmented format stream */
  327   guint64 duration_last_moof;
  328 
  329   guint32 offset_in_sample;     /* Offset in the current sample, used for
  330                                  * streams which have got exceedingly big
  331                                  * sample size (such as 24s of raw audio).
  332                                  * Only used when max_buffer_size is non-NULL */
  333   guint32 max_buffer_size;      /* Maximum allowed size for output buffers.
  334                                  * Currently only set for raw audio streams*/
  335 
  336   /* video info */
  337   /* aspect ratio */
  338   gint display_width;
  339   gint display_height;
  340 
  341   /* allocation */
  342   gboolean use_allocator;
  343   GstAllocator *allocator;
  344   GstAllocationParams params;
  345 
  346   gsize alignment;
  347 
  348   /* when a discontinuity is pending */
  349   gboolean discont;
  350 
  351   /* list of buffers to push first */
  352   GSList *buffers;
  353 
  354   /* if we need to clip this buffer. This is only needed for uncompressed
  355    * data */
  356   gboolean need_clip;
  357 
  358   /* buffer needs some custom processing, e.g. subtitles */
  359   gboolean need_process;
<span class="line-added">  360   /* buffer needs potentially be split, e.g. CEA608 subtitles */</span>
<span class="line-added">  361   gboolean need_split;</span>
  362 
  363   /* current position */
  364   guint32 segment_index;
  365   guint32 sample_index;
  366   GstClockTime time_position;   /* in gst time */
  367   guint64 accumulated_base;
  368 
  369   /* the Gst segment we are processing out, used for clipping */
  370   GstSegment segment;
  371 
  372   /* quicktime segments */
  373   guint32 n_segments;
  374   QtDemuxSegment *segments;
  375   gboolean dummy_segment;
  376   guint32 from_sample;
  377   guint32 to_sample;
  378 
  379   gboolean sent_eos;
  380   GstTagList *stream_tags;
  381   gboolean send_global_tags;
</pre>
<hr />
<pre>
  442 
  443   /* fragmented */
  444   gboolean parsed_trex;
  445   guint32 def_sample_description_index; /* index is 1-based */
  446   guint32 def_sample_duration;
  447   guint32 def_sample_size;
  448   guint32 def_sample_flags;
  449 
  450   gboolean disabled;
  451 
  452   /* stereoscopic video streams */
  453   GstVideoMultiviewMode multiview_mode;
  454   GstVideoMultiviewFlags multiview_flags;
  455 
  456   /* protected streams */
  457   gboolean protected;
  458   guint32 protection_scheme_type;
  459   guint32 protection_scheme_version;
  460   gpointer protection_scheme_info;      /* specific to the protection scheme */
  461   GQueue protection_scheme_event_queue;
<span class="line-added">  462 </span>
<span class="line-added">  463   gint ref_count;               /* atomic */</span>
  464 };
  465 
  466 /* Contains properties and cryptographic info for a set of samples from a
  467  * track protected using Common Encryption (cenc) */
  468 struct _QtDemuxCencSampleSetInfo
  469 {
  470   GstStructure *default_properties;
  471 
  472   /* @crypto_info holds one GstStructure per sample */
  473   GPtrArray *crypto_info;
  474 };
  475 
  476 static const gchar *
  477 qt_demux_state_string (enum QtDemuxState state)
  478 {
  479   switch (state) {
  480     case QTDEMUX_STATE_INITIAL:
  481       return &quot;&lt;INITIAL&gt;&quot;;
  482     case QTDEMUX_STATE_HEADER:
  483       return &quot;&lt;HEADER&gt;&quot;;
  484     case QTDEMUX_STATE_MOVIE:
  485       return &quot;&lt;MOVIE&gt;&quot;;
  486     case QTDEMUX_STATE_BUFFER_MDAT:
  487       return &quot;&lt;BUFFER_MDAT&gt;&quot;;
  488     default:
  489       return &quot;&lt;UNKNOWN&gt;&quot;;
  490   }
  491 }
  492 
  493 static GNode *qtdemux_tree_get_child_by_type (GNode * node, guint32 fourcc);
  494 static GNode *qtdemux_tree_get_child_by_type_full (GNode * node,
  495     guint32 fourcc, GstByteReader * parser);
  496 static GNode *qtdemux_tree_get_sibling_by_type (GNode * node, guint32 fourcc);
  497 static GNode *qtdemux_tree_get_sibling_by_type_full (GNode * node,
  498     guint32 fourcc, GstByteReader * parser);
  499 
  500 static GstFlowReturn qtdemux_add_fragmented_samples (GstQTDemux * qtdemux);
  501 
<span class="line-added">  502 static void gst_qtdemux_check_send_pending_segment (GstQTDemux * demux);</span>
<span class="line-added">  503 </span>
  504 static GstStaticPadTemplate gst_qtdemux_sink_template =
  505     GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
  506     GST_PAD_SINK,
  507     GST_PAD_ALWAYS,
  508     GST_STATIC_CAPS (&quot;video/quicktime; video/mj2; audio/x-m4a; &quot;
  509         &quot;application/x-3gp&quot;)
  510     );
  511 
  512 static GstStaticPadTemplate gst_qtdemux_videosrc_template =
  513 GST_STATIC_PAD_TEMPLATE (&quot;video_%u&quot;,
  514     GST_PAD_SRC,
  515     GST_PAD_SOMETIMES,
  516     GST_STATIC_CAPS_ANY);
  517 
  518 static GstStaticPadTemplate gst_qtdemux_audiosrc_template =
  519 GST_STATIC_PAD_TEMPLATE (&quot;audio_%u&quot;,
  520     GST_PAD_SRC,
  521     GST_PAD_SOMETIMES,
  522     GST_STATIC_CAPS_ANY);
  523 
</pre>
<hr />
<pre>
  528     GST_STATIC_CAPS_ANY);
  529 
  530 #define gst_qtdemux_parent_class parent_class
  531 G_DEFINE_TYPE (GstQTDemux, gst_qtdemux, GST_TYPE_ELEMENT);
  532 
  533 static void gst_qtdemux_dispose (GObject * object);
  534 
  535 static guint32
  536 gst_qtdemux_find_index_linear (GstQTDemux * qtdemux, QtDemuxStream * str,
  537     GstClockTime media_time);
  538 static guint32
  539 gst_qtdemux_find_index_for_given_media_offset_linear (GstQTDemux * qtdemux,
  540     QtDemuxStream * str, gint64 media_offset);
  541 
  542 #if 0
  543 static void gst_qtdemux_set_index (GstElement * element, GstIndex * index);
  544 static GstIndex *gst_qtdemux_get_index (GstElement * element);
  545 #endif
  546 static GstStateChangeReturn gst_qtdemux_change_state (GstElement * element,
  547     GstStateChange transition);
<span class="line-added">  548 static void gst_qtdemux_set_context (GstElement * element,</span>
<span class="line-added">  549     GstContext * context);</span>
  550 static gboolean qtdemux_sink_activate (GstPad * sinkpad, GstObject * parent);
  551 static gboolean qtdemux_sink_activate_mode (GstPad * sinkpad,
  552     GstObject * parent, GstPadMode mode, gboolean active);
  553 
  554 static void gst_qtdemux_loop (GstPad * pad);
  555 static GstFlowReturn gst_qtdemux_chain (GstPad * sinkpad, GstObject * parent,
  556     GstBuffer * inbuf);
  557 static gboolean gst_qtdemux_handle_sink_event (GstPad * pad, GstObject * parent,
  558     GstEvent * event);
<span class="line-added">  559 static gboolean gst_qtdemux_handle_sink_query (GstPad * pad, GstObject * parent,</span>
<span class="line-added">  560     GstQuery * query);</span>
  561 static gboolean gst_qtdemux_setcaps (GstQTDemux * qtdemux, GstCaps * caps);
  562 static gboolean gst_qtdemux_configure_stream (GstQTDemux * qtdemux,
  563     QtDemuxStream * stream);
  564 static void gst_qtdemux_stream_check_and_change_stsd_index (GstQTDemux * demux,
  565     QtDemuxStream * stream);
  566 static GstFlowReturn gst_qtdemux_process_adapter (GstQTDemux * demux,
  567     gboolean force);
  568 
<span class="line-added">  569 static void gst_qtdemux_check_seekability (GstQTDemux * demux);</span>
<span class="line-added">  570 </span>
  571 static gboolean qtdemux_parse_moov (GstQTDemux * qtdemux,
  572     const guint8 * buffer, guint length);
  573 static gboolean qtdemux_parse_node (GstQTDemux * qtdemux, GNode * node,
  574     const guint8 * buffer, guint length);
  575 static gboolean qtdemux_parse_tree (GstQTDemux * qtdemux);
  576 static void qtdemux_parse_udta (GstQTDemux * qtdemux, GstTagList * taglist,
  577     GNode * udta);
  578 
  579 #ifdef GSTREAMER_LITE
  580 static gboolean gst_qtdemux_handle_esds (GstQTDemux * qtdemux,
  581     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, GNode * esds,
  582     GstTagList * list);
  583 #else
  584 static void gst_qtdemux_handle_esds (GstQTDemux * qtdemux,
  585     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, GNode * esds,
  586     GstTagList * list);
  587 #endif // GSTREAMER_LITE
  588 static GstCaps *qtdemux_video_caps (GstQTDemux * qtdemux,
  589     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, guint32 fourcc,
  590     const guint8 * stsd_entry_data, gchar ** codec_name);
  591 static GstCaps *qtdemux_audio_caps (GstQTDemux * qtdemux,
  592     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, guint32 fourcc,
  593     const guint8 * data, int len, gchar ** codec_name);
  594 static GstCaps *qtdemux_sub_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
  595     QtDemuxStreamStsdEntry * entry, guint32 fourcc, const guint8 * data,
  596     gchar ** codec_name);
  597 static GstCaps *qtdemux_generic_caps (GstQTDemux * qtdemux,
  598     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, guint32 fourcc,
  599     const guint8 * stsd_entry_data, gchar ** codec_name);
  600 
  601 static gboolean qtdemux_parse_samples (GstQTDemux * qtdemux,
  602     QtDemuxStream * stream, guint32 n);
  603 static GstFlowReturn qtdemux_expose_streams (GstQTDemux * qtdemux);
<span class="line-modified">  604 static QtDemuxStream *gst_qtdemux_stream_ref (QtDemuxStream * stream);</span>
<span class="line-modified">  605 static void gst_qtdemux_stream_unref (QtDemuxStream * stream);</span>
<span class="line-modified">  606 static void gst_qtdemux_stream_clear (QtDemuxStream * stream);</span>


  607 static GstFlowReturn qtdemux_prepare_streams (GstQTDemux * qtdemux);
<span class="line-modified">  608 static void qtdemux_do_allocation (QtDemuxStream * stream,</span>
<span class="line-modified">  609     GstQTDemux * qtdemux);</span>
  610 static gboolean gst_qtdemux_activate_segment (GstQTDemux * qtdemux,
  611     QtDemuxStream * stream, guint32 seg_idx, GstClockTime offset);
  612 static gboolean gst_qtdemux_stream_update_segment (GstQTDemux * qtdemux,
  613     QtDemuxStream * stream, gint seg_idx, GstClockTime offset,
  614     GstClockTime * _start, GstClockTime * _stop);
  615 static void gst_qtdemux_send_gap_for_segment (GstQTDemux * demux,
  616     QtDemuxStream * stream, gint segment_index, GstClockTime pos);
  617 
  618 static gboolean qtdemux_pull_mfro_mfra (GstQTDemux * qtdemux);
  619 static void check_update_duration (GstQTDemux * qtdemux, GstClockTime duration);
  620 
  621 static gchar *qtdemux_uuid_bytes_to_string (gconstpointer uuid_bytes);
  622 
  623 static GstStructure *qtdemux_get_cenc_sample_properties (GstQTDemux * qtdemux,
  624     QtDemuxStream * stream, guint sample_index);
  625 static void gst_qtdemux_append_protection_system_id (GstQTDemux * qtdemux,
  626     const gchar * id);
  627 static void qtdemux_gst_structure_free (GstStructure * gststructure);
<span class="line-added">  628 static void gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard);</span>
  629 
  630 static void
  631 gst_qtdemux_class_init (GstQTDemuxClass * klass)
  632 {
  633   GObjectClass *gobject_class;
  634   GstElementClass *gstelement_class;
  635 
  636   gobject_class = (GObjectClass *) klass;
  637   gstelement_class = (GstElementClass *) klass;
  638 
  639   parent_class = g_type_class_peek_parent (klass);
  640 
  641   gobject_class-&gt;dispose = gst_qtdemux_dispose;
  642 
  643   gstelement_class-&gt;change_state = GST_DEBUG_FUNCPTR (gst_qtdemux_change_state);
  644 #if 0
  645   gstelement_class-&gt;set_index = GST_DEBUG_FUNCPTR (gst_qtdemux_set_index);
  646   gstelement_class-&gt;get_index = GST_DEBUG_FUNCPTR (gst_qtdemux_get_index);
  647 #endif
<span class="line-added">  648   gstelement_class-&gt;set_context = GST_DEBUG_FUNCPTR (gst_qtdemux_set_context);</span>
  649 
  650   gst_tag_register_musicbrainz_tags ();
  651 
  652   gst_element_class_add_static_pad_template (gstelement_class,
  653       &amp;gst_qtdemux_sink_template);
  654   gst_element_class_add_static_pad_template (gstelement_class,
  655       &amp;gst_qtdemux_videosrc_template);
  656   gst_element_class_add_static_pad_template (gstelement_class,
  657       &amp;gst_qtdemux_audiosrc_template);
  658   gst_element_class_add_static_pad_template (gstelement_class,
  659       &amp;gst_qtdemux_subsrc_template);
  660   gst_element_class_set_static_metadata (gstelement_class, &quot;QuickTime demuxer&quot;,
  661       &quot;Codec/Demuxer&quot;,
  662       &quot;Demultiplex a QuickTime file into audio and video streams&quot;,
  663       &quot;David Schleef &lt;ds@schleef.org&gt;, Wim Taymans &lt;wim@fluendo.com&gt;&quot;);
  664 
  665   GST_DEBUG_CATEGORY_INIT (qtdemux_debug, &quot;qtdemux&quot;, 0, &quot;qtdemux plugin&quot;);
  666   gst_riff_init ();
  667 }
  668 
  669 static void
  670 gst_qtdemux_init (GstQTDemux * qtdemux)
  671 {
  672   qtdemux-&gt;sinkpad =
  673       gst_pad_new_from_static_template (&amp;gst_qtdemux_sink_template, &quot;sink&quot;);
  674   gst_pad_set_activate_function (qtdemux-&gt;sinkpad, qtdemux_sink_activate);
  675   gst_pad_set_activatemode_function (qtdemux-&gt;sinkpad,
  676       qtdemux_sink_activate_mode);
  677   gst_pad_set_chain_function (qtdemux-&gt;sinkpad, gst_qtdemux_chain);
  678   gst_pad_set_event_function (qtdemux-&gt;sinkpad, gst_qtdemux_handle_sink_event);
<span class="line-added">  679   gst_pad_set_query_function (qtdemux-&gt;sinkpad, gst_qtdemux_handle_sink_query);</span>
  680   gst_element_add_pad (GST_ELEMENT_CAST (qtdemux), qtdemux-&gt;sinkpad);
  681 





  682   qtdemux-&gt;adapter = gst_adapter_new ();




















  683   g_queue_init (&amp;qtdemux-&gt;protection_event_queue);



  684   qtdemux-&gt;flowcombiner = gst_flow_combiner_new ();
<span class="line-added">  685   g_mutex_init (&amp;qtdemux-&gt;expose_lock);</span>
<span class="line-added">  686 </span>
<span class="line-added">  687   qtdemux-&gt;active_streams = g_ptr_array_new_with_free_func</span>
<span class="line-added">  688       ((GDestroyNotify) gst_qtdemux_stream_unref);</span>
<span class="line-added">  689   qtdemux-&gt;old_streams = g_ptr_array_new_with_free_func</span>
<span class="line-added">  690       ((GDestroyNotify) gst_qtdemux_stream_unref);</span>
  691 
  692   GST_OBJECT_FLAG_SET (qtdemux, GST_ELEMENT_FLAG_INDEXABLE);
<span class="line-added">  693 </span>
<span class="line-added">  694   gst_qtdemux_reset (qtdemux, TRUE);</span>
  695 }
  696 
  697 static void
  698 gst_qtdemux_dispose (GObject * object)
  699 {
  700   GstQTDemux *qtdemux = GST_QTDEMUX (object);
  701 
  702   if (qtdemux-&gt;adapter) {
  703     g_object_unref (G_OBJECT (qtdemux-&gt;adapter));
  704     qtdemux-&gt;adapter = NULL;
  705   }
  706   gst_tag_list_unref (qtdemux-&gt;tag_list);
  707   gst_flow_combiner_free (qtdemux-&gt;flowcombiner);
  708   g_queue_foreach (&amp;qtdemux-&gt;protection_event_queue, (GFunc) gst_event_unref,
  709       NULL);
  710   g_queue_clear (&amp;qtdemux-&gt;protection_event_queue);
  711 
  712   g_free (qtdemux-&gt;cenc_aux_info_sizes);
  713   qtdemux-&gt;cenc_aux_info_sizes = NULL;
<span class="line-added">  714   g_mutex_clear (&amp;qtdemux-&gt;expose_lock);</span>
<span class="line-added">  715 </span>
<span class="line-added">  716   g_ptr_array_free (qtdemux-&gt;active_streams, TRUE);</span>
<span class="line-added">  717   g_ptr_array_free (qtdemux-&gt;old_streams, TRUE);</span>
  718 
  719   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
  720 }
  721 
  722 static void
  723 gst_qtdemux_post_no_playable_stream_error (GstQTDemux * qtdemux)
  724 {
  725   if (qtdemux-&gt;posted_redirect) {
  726     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
  727         (_(&quot;This file contains no playable streams.&quot;)),
  728         (&quot;no known streams found, a redirect message has been posted&quot;));
  729   } else {
  730     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
  731         (_(&quot;This file contains no playable streams.&quot;)),
  732         (&quot;no known streams found&quot;));
  733   }
  734 }
  735 
  736 static GstBuffer *
  737 _gst_buffer_new_wrapped (gpointer mem, gsize size, GFreeFunc free_func)
</pre>
<hr />
<pre>
  866   }
  867 
  868 done:
  869   return res;
  870 }
  871 #endif
  872 
  873 static gboolean
  874 gst_qtdemux_get_duration (GstQTDemux * qtdemux, GstClockTime * duration)
  875 {
  876   gboolean res = FALSE;
  877 
  878   *duration = GST_CLOCK_TIME_NONE;
  879 
  880   if (qtdemux-&gt;duration != 0 &amp;&amp;
  881       qtdemux-&gt;duration != G_MAXINT64 &amp;&amp; qtdemux-&gt;timescale != 0) {
  882     *duration = QTTIME_TO_GSTTIME (qtdemux, qtdemux-&gt;duration);
  883     res = TRUE;
  884   } else {
  885     *duration = GST_CLOCK_TIME_NONE;
<span class="line-modified">  886   }</span>
  887 
  888   return res;
  889 }
  890 
  891 static gboolean
  892 gst_qtdemux_handle_src_query (GstPad * pad, GstObject * parent,
  893     GstQuery * query)
  894 {
  895   gboolean res = FALSE;
  896   GstQTDemux *qtdemux = GST_QTDEMUX (parent);
  897 
  898   GST_LOG_OBJECT (pad, &quot;%s query&quot;, GST_QUERY_TYPE_NAME (query));
  899 
  900   switch (GST_QUERY_TYPE (query)) {
  901     case GST_QUERY_POSITION:{
  902       GstFormat fmt;
  903 
  904       gst_query_parse_position (query, &amp;fmt, NULL);
  905       if (fmt == GST_FORMAT_TIME
  906           &amp;&amp; GST_CLOCK_TIME_IS_VALID (qtdemux-&gt;segment.position)) {
  907         gst_query_set_position (query, GST_FORMAT_TIME,
  908             qtdemux-&gt;segment.position);
  909         res = TRUE;
  910       }
  911     }
  912       break;
  913     case GST_QUERY_DURATION:{
  914       GstFormat fmt;
  915 
  916       gst_query_parse_duration (query, &amp;fmt, NULL);
  917       if (fmt == GST_FORMAT_TIME) {
  918         /* First try to query upstream */
  919         res = gst_pad_query_default (pad, parent, query);
  920         if (!res) {
  921           GstClockTime duration;
  922           if (gst_qtdemux_get_duration (qtdemux, &amp;duration) &amp;&amp; duration &gt; 0) {
<span class="line-modified">  923             gst_query_set_duration (query, GST_FORMAT_TIME, duration);</span>
<span class="line-modified">  924             res = TRUE;</span>
<span class="line-added">  925           }</span>
  926         }
  927       }

  928       break;
  929     }
  930     case GST_QUERY_CONVERT:{
  931       GstFormat src_fmt, dest_fmt;
  932       gint64 src_value, dest_value = 0;
  933 
  934       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_value, &amp;dest_fmt, NULL);
  935 
  936       res = gst_qtdemux_src_convert (qtdemux, pad,
  937           src_fmt, src_value, dest_fmt, &amp;dest_value);
  938       if (res)
  939         gst_query_set_convert (query, src_fmt, src_value, dest_fmt, dest_value);
  940 
  941       break;
  942     }
  943     case GST_QUERY_FORMATS:
  944       gst_query_set_formats (query, 2, GST_FORMAT_TIME, GST_FORMAT_BYTES);
  945       res = TRUE;
  946       break;
  947     case GST_QUERY_SEEKING:{
  948       GstFormat fmt;
  949       gboolean seekable;
  950 
  951       /* try upstream first */
  952       res = gst_pad_query_default (pad, parent, query);
  953 
  954       if (!res) {
<span class="line-modified">  955         gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);</span>
<span class="line-modified">  956         if (fmt == GST_FORMAT_TIME) {</span>
  957           GstClockTime duration;
  958 
<span class="line-modified">  959           gst_qtdemux_get_duration (qtdemux, &amp;duration);</span>
<span class="line-modified">  960           seekable = TRUE;</span>
<span class="line-modified">  961           if (!qtdemux-&gt;pullbased) {</span>
<span class="line-modified">  962             GstQuery *q;</span>
<span class="line-modified">  963 </span>
<span class="line-modified">  964             /* we might be able with help from upstream */</span>
<span class="line-modified">  965             seekable = FALSE;</span>
<span class="line-modified">  966             q = gst_query_new_seeking (GST_FORMAT_BYTES);</span>
<span class="line-modified">  967             if (gst_pad_peer_query (qtdemux-&gt;sinkpad, q)) {</span>
<span class="line-modified">  968               gst_query_parse_seeking (q, &amp;fmt, &amp;seekable, NULL, NULL);</span>
<span class="line-modified">  969               GST_LOG_OBJECT (qtdemux, &quot;upstream BYTE seekable %d&quot;, seekable);</span>
<span class="line-added">  970             }</span>
<span class="line-added">  971             gst_query_unref (q);</span>
  972           }
<span class="line-modified">  973           gst_query_set_seeking (query, GST_FORMAT_TIME, seekable, 0, duration);</span>
<span class="line-added">  974           res = TRUE;</span>
  975         }



  976       }
  977       break;
  978     }
  979     case GST_QUERY_SEGMENT:
  980     {
  981       GstFormat format;
  982       gint64 start, stop;
  983 
  984       format = qtdemux-&gt;segment.format;
  985 
  986       start =
  987           gst_segment_to_stream_time (&amp;qtdemux-&gt;segment, format,
  988           qtdemux-&gt;segment.start);
  989       if ((stop = qtdemux-&gt;segment.stop) == -1)
  990         stop = qtdemux-&gt;segment.duration;
  991       else
  992         stop = gst_segment_to_stream_time (&amp;qtdemux-&gt;segment, format, stop);
  993 
  994       gst_query_set_segment (query, qtdemux-&gt;segment.rate, format, start, stop);
  995       res = TRUE;
</pre>
<hr />
<pre>
 1019       GST_DEBUG_OBJECT (qtdemux, &quot;Sending tags %&quot; GST_PTR_FORMAT,
 1020           stream-&gt;stream_tags);
 1021       gst_pad_push_event (stream-&gt;pad,
 1022           gst_event_new_tag (gst_tag_list_ref (stream-&gt;stream_tags)));
 1023     }
 1024 
 1025     if (G_UNLIKELY (stream-&gt;send_global_tags)) {
 1026       GST_DEBUG_OBJECT (qtdemux, &quot;Sending global tags %&quot; GST_PTR_FORMAT,
 1027           qtdemux-&gt;tag_list);
 1028       gst_pad_push_event (stream-&gt;pad,
 1029           gst_event_new_tag (gst_tag_list_ref (qtdemux-&gt;tag_list)));
 1030       stream-&gt;send_global_tags = FALSE;
 1031     }
 1032   }
 1033 }
 1034 
 1035 /* push event on all source pads; takes ownership of the event */
 1036 static void
 1037 gst_qtdemux_push_event (GstQTDemux * qtdemux, GstEvent * event)
 1038 {

 1039   gboolean has_valid_stream = FALSE;
 1040   GstEventType etype = GST_EVENT_TYPE (event);
<span class="line-added"> 1041   guint i;</span>
 1042 
 1043   GST_DEBUG_OBJECT (qtdemux, &quot;pushing %s event on all source pads&quot;,
 1044       GST_EVENT_TYPE_NAME (event));
 1045 
<span class="line-modified"> 1046   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
 1047     GstPad *pad;
<span class="line-modified"> 1048     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-modified"> 1049     GST_DEBUG_OBJECT (qtdemux, &quot;pushing on track-id %u&quot;, stream-&gt;track_id);</span>
 1050 
 1051     if ((pad = stream-&gt;pad)) {
 1052       has_valid_stream = TRUE;
 1053 
 1054       if (etype == GST_EVENT_EOS) {
 1055         /* let&#39;s not send twice */
 1056         if (stream-&gt;sent_eos)
 1057           continue;
 1058         stream-&gt;sent_eos = TRUE;
 1059       }
 1060 
 1061       gst_pad_push_event (pad, gst_event_ref (event));
 1062     }
 1063   }
 1064 
 1065   gst_event_unref (event);
 1066 
 1067   /* if it is EOS and there are no pads, post an error */
 1068   if (!has_valid_stream &amp;&amp; etype == GST_EVENT_EOS) {
 1069     gst_qtdemux_post_no_playable_stream_error (qtdemux);
 1070   }
 1071 }
 1072 










 1073 typedef struct
 1074 {
 1075   guint64 media_time;
 1076 } FindData;
 1077 
 1078 static gint
 1079 find_func (QtDemuxSample * s1, gint64 * media_time, gpointer user_data)
 1080 {
<span class="line-modified"> 1081   if ((gint64) s1-&gt;timestamp &gt; *media_time)</span>
 1082     return 1;
<span class="line-modified"> 1083   if ((gint64) s1-&gt;timestamp == *media_time)</span>
 1084     return 0;
 1085 
 1086   return -1;
 1087 }
 1088 
 1089 /* find the index of the sample that includes the data for @media_time using a
 1090  * binary search.  Only to be called in optimized cases of linear search below.
 1091  *
<span class="line-modified"> 1092  * Returns the index of the sample with the corresponding *DTS*.</span>
 1093  */
 1094 static guint32
 1095 gst_qtdemux_find_index (GstQTDemux * qtdemux, QtDemuxStream * str,
 1096     guint64 media_time)
 1097 {
 1098   QtDemuxSample *result;
 1099   guint32 index;
 1100 
 1101   /* convert media_time to mov format */
 1102   media_time =
 1103       gst_util_uint64_scale_ceil (media_time, str-&gt;timescale, GST_SECOND);
 1104 
 1105   result = gst_util_array_binary_search (str-&gt;samples, str-&gt;stbl_index + 1,
 1106       sizeof (QtDemuxSample), (GCompareDataFunc) find_func,
 1107       GST_SEARCH_MODE_BEFORE, &amp;media_time, NULL);
 1108 
 1109   if (G_LIKELY (result))
 1110     index = result - str-&gt;samples;
 1111   else
 1112     index = 0;
</pre>
<hr />
<pre>
 1162  * Returns the index of the sample.
 1163  */
 1164 static guint32
 1165 gst_qtdemux_find_index_linear (GstQTDemux * qtdemux, QtDemuxStream * str,
 1166     GstClockTime media_time)
 1167 {
 1168   guint32 index = 0;
 1169   guint64 mov_time;
 1170   QtDemuxSample *sample;
 1171 
 1172   /* convert media_time to mov format */
 1173   mov_time =
 1174       gst_util_uint64_scale_ceil (media_time, str-&gt;timescale, GST_SECOND);
 1175 
 1176   sample = str-&gt;samples;
 1177   if (mov_time == sample-&gt;timestamp + sample-&gt;pts_offset)
 1178     return index;
 1179 
 1180   /* use faster search if requested time in already parsed range */
 1181   sample = str-&gt;samples + str-&gt;stbl_index;
<span class="line-modified"> 1182   if (str-&gt;stbl_index &gt;= 0 &amp;&amp; mov_time &lt;= sample-&gt;timestamp) {</span>
<span class="line-modified"> 1183     index = gst_qtdemux_find_index (qtdemux, str, media_time);</span>
<span class="line-modified"> 1184     sample = str-&gt;samples + index;</span>
<span class="line-added"> 1185   } else {</span>
<span class="line-added"> 1186     while (index &lt; str-&gt;n_samples - 1) {</span>
<span class="line-added"> 1187       if (!qtdemux_parse_samples (qtdemux, str, index + 1))</span>
<span class="line-added"> 1188         goto parse_failed;</span>
 1189 
<span class="line-modified"> 1190       sample = str-&gt;samples + index + 1;</span>
<span class="line-modified"> 1191       if (mov_time &lt; sample-&gt;timestamp) {</span>
<span class="line-modified"> 1192         sample = str-&gt;samples + index;</span>
<span class="line-added"> 1193         break;</span>
<span class="line-added"> 1194       }</span>
 1195 
<span class="line-modified"> 1196       index++;</span>
<span class="line-modified"> 1197     }</span>
<span class="line-modified"> 1198   }</span>
 1199 
<span class="line-modified"> 1200   /* sample-&gt;timestamp is now &lt;= media_time, need to find the corresponding</span>
<span class="line-added"> 1201    * PTS now by looking backwards */</span>
<span class="line-added"> 1202   while (index &gt; 0 &amp;&amp; sample-&gt;timestamp + sample-&gt;pts_offset &gt; mov_time) {</span>
<span class="line-added"> 1203     index--;</span>
<span class="line-added"> 1204     sample = str-&gt;samples + index;</span>
 1205   }
<span class="line-added"> 1206 </span>
 1207   return index;
 1208 
 1209   /* ERRORS */
 1210 parse_failed:
 1211   {
 1212     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;, index + 1);
 1213     return -1;
 1214   }
 1215 }
 1216 
 1217 /* find the index of the keyframe needed to decode the sample at @index
 1218  * of stream @str, or of a subsequent keyframe (depending on @next)
 1219  *
 1220  * Returns the index of the keyframe.
 1221  */
 1222 static guint32
 1223 gst_qtdemux_find_keyframe (GstQTDemux * qtdemux, QtDemuxStream * str,
 1224     guint32 index, gboolean next)
 1225 {
 1226   guint32 new_index = index;
</pre>
<hr />
<pre>
 1233   /* all keyframes, return index */
 1234   if (str-&gt;all_keyframe) {
 1235     new_index = index;
 1236     goto beach;
 1237   }
 1238 
 1239   /* else search until we have a keyframe */
 1240   while (new_index &lt; str-&gt;n_samples) {
 1241     if (next &amp;&amp; !qtdemux_parse_samples (qtdemux, str, new_index))
 1242       goto parse_failed;
 1243 
 1244     if (str-&gt;samples[new_index].keyframe)
 1245       break;
 1246 
 1247     if (new_index == 0)
 1248       break;
 1249 
 1250     if (next)
 1251       new_index++;
 1252     else
<span class="line-modified"> 1253       new_index--;</span>
 1254   }
 1255 
 1256   if (new_index == str-&gt;n_samples) {
 1257     GST_DEBUG_OBJECT (qtdemux, &quot;no next keyframe&quot;);
 1258     new_index = -1;
 1259   }
 1260 
 1261 beach:
 1262   GST_DEBUG_OBJECT (qtdemux, &quot;searching for keyframe index %s index %u &quot;
 1263       &quot;gave %u&quot;, next ? &quot;after&quot; : &quot;before&quot;, index, new_index);
 1264 
 1265   return new_index;
 1266 
 1267   /* ERRORS */
 1268 parse_failed:
 1269   {
 1270     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;, new_index);
 1271     return -1;
<span class="line-modified"> 1272   }</span>
 1273 }
 1274 
 1275 /* find the segment for @time_position for @stream
 1276  *
 1277  * Returns the index of the segment containing @time_position.
 1278  * Returns the last segment and sets the @eos variable to TRUE
 1279  * if the time is beyond the end. @eos may be NULL
 1280  */
 1281 static guint32
 1282 gst_qtdemux_find_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
 1283     GstClockTime time_position)
 1284 {
 1285   gint i;
 1286   guint32 seg_idx;
 1287 
 1288   GST_LOG_OBJECT (stream-&gt;pad, &quot;finding segment for %&quot; GST_TIME_FORMAT,
 1289       GST_TIME_ARGS (time_position));
 1290 
 1291   seg_idx = -1;
 1292   for (i = 0; i &lt; stream-&gt;n_segments; i++) {
 1293     QtDemuxSegment *segment = &amp;stream-&gt;segments[i];
 1294 
 1295     GST_LOG_OBJECT (stream-&gt;pad,
 1296         &quot;looking at segment %&quot; GST_TIME_FORMAT &quot;-%&quot; GST_TIME_FORMAT,
 1297         GST_TIME_ARGS (segment-&gt;time), GST_TIME_ARGS (segment-&gt;stop_time));
 1298 
 1299     /* For the last segment we include stop_time in the last segment */
 1300     if (i &lt; stream-&gt;n_segments - 1) {
 1301       if (segment-&gt;time &lt;= time_position &amp;&amp; time_position &lt; segment-&gt;stop_time) {
 1302         GST_LOG_OBJECT (stream-&gt;pad, &quot;segment %d matches&quot;, i);
 1303         seg_idx = i;
 1304         break;
 1305       }
 1306     } else {
 1307       /* Last segment always matches */
<span class="line-modified"> 1308       seg_idx = i;</span>
<span class="line-modified"> 1309       break;</span>

 1310     }
<span class="line-added"> 1311   }</span>
 1312   return seg_idx;
 1313 }
 1314 
 1315 /* move the stream @str to the sample position @index.
 1316  *
 1317  * Updates @str-&gt;sample_index and marks discontinuity if needed.
 1318  */
 1319 static void
 1320 gst_qtdemux_move_stream (GstQTDemux * qtdemux, QtDemuxStream * str,
 1321     guint32 index)
 1322 {
 1323   /* no change needed */
 1324   if (index == str-&gt;sample_index)
 1325     return;
 1326 
 1327   GST_DEBUG_OBJECT (qtdemux, &quot;moving to sample %u of %u&quot;, index,
 1328       str-&gt;n_samples);
 1329 
 1330   /* position changed, we have a discont */
 1331   str-&gt;sample_index = index;
 1332   str-&gt;offset_in_sample = 0;
 1333   /* Each time we move in the stream we store the position where we are
 1334    * starting from */
 1335   str-&gt;from_sample = index;
 1336   str-&gt;discont = TRUE;
 1337 }
 1338 
 1339 static void
 1340 gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
 1341     gboolean use_sparse, gboolean next, gint64 * key_time, gint64 * key_offset)
 1342 {
 1343   guint64 min_offset;
 1344   gint64 min_byte_offset = -1;
<span class="line-modified"> 1345   guint i;</span>
 1346 
 1347   min_offset = desired_time;
 1348 
 1349   /* for each stream, find the index of the sample in the segment
 1350    * and move back to the previous keyframe. */
<span class="line-modified"> 1351   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
 1352     QtDemuxStream *str;
 1353     guint32 index, kindex;
 1354     guint32 seg_idx;
 1355     GstClockTime media_start;
 1356     GstClockTime media_time;
 1357     GstClockTime seg_time;
 1358     QtDemuxSegment *seg;
 1359     gboolean empty_segment = FALSE;
 1360 
<span class="line-modified"> 1361     str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 1362 
 1363     if (CUR_STREAM (str)-&gt;sparse &amp;&amp; !use_sparse)
 1364       continue;
 1365 
 1366     seg_idx = gst_qtdemux_find_segment (qtdemux, str, desired_time);
 1367     GST_DEBUG_OBJECT (qtdemux, &quot;align segment %d&quot;, seg_idx);
 1368 
 1369     /* get segment and time in the segment */
 1370     seg = &amp;str-&gt;segments[seg_idx];
 1371     seg_time = (desired_time - seg-&gt;time) * seg-&gt;rate;
 1372 
 1373     while (QTSEGMENT_IS_EMPTY (seg)) {
 1374       seg_time = 0;
 1375       empty_segment = TRUE;
 1376       GST_DEBUG_OBJECT (str-&gt;pad, &quot;Segment %d is empty, moving to next one&quot;,
 1377           seg_idx);
 1378       seg_idx++;
 1379       if (seg_idx == str-&gt;n_segments)
 1380         break;
 1381       seg = &amp;str-&gt;segments[seg_idx];
</pre>
<hr />
<pre>
 1386        * happens we better handle it */
 1387       continue;
 1388     }
 1389 
 1390     /* get the media time in the segment */
 1391     media_start = seg-&gt;media_start + seg_time;
 1392 
 1393     /* get the index of the sample with media time */
 1394     index = gst_qtdemux_find_index_linear (qtdemux, str, media_start);
 1395     GST_DEBUG_OBJECT (qtdemux, &quot;sample for %&quot; GST_TIME_FORMAT &quot; at %u&quot;
 1396         &quot; at offset %&quot; G_GUINT64_FORMAT &quot; (empty segment: %d)&quot;,
 1397         GST_TIME_ARGS (media_start), index, str-&gt;samples[index].offset,
 1398         empty_segment);
 1399 
 1400     /* shift to next frame if we are looking for next keyframe */
 1401     if (next &amp;&amp; QTSAMPLE_PTS_NO_CSLG (str, &amp;str-&gt;samples[index]) &lt; media_start
 1402         &amp;&amp; index &lt; str-&gt;stbl_index)
 1403       index++;
 1404 
 1405     if (!empty_segment) {
<span class="line-modified"> 1406       /* find previous keyframe */</span>
 1407       kindex = gst_qtdemux_find_keyframe (qtdemux, str, index, next);
 1408 
 1409       /* we will settle for one before if none found after */
 1410       if (next &amp;&amp; kindex == -1)
 1411         kindex = gst_qtdemux_find_keyframe (qtdemux, str, index, FALSE);
 1412 
<span class="line-modified"> 1413       /* if the keyframe is at a different position, we need to update the</span>
<span class="line-modified"> 1414        * requested seek time */</span>
<span class="line-modified"> 1415       if (index != kindex) {</span>
<span class="line-modified"> 1416         index = kindex;</span>
 1417 
<span class="line-modified"> 1418         /* get timestamp of keyframe */</span>
 1419         media_time = QTSAMPLE_PTS_NO_CSLG (str, &amp;str-&gt;samples[kindex]);
 1420         GST_DEBUG_OBJECT (qtdemux,
 1421             &quot;keyframe at %u with time %&quot; GST_TIME_FORMAT &quot; at offset %&quot;
 1422             G_GUINT64_FORMAT, kindex, GST_TIME_ARGS (media_time),
 1423             str-&gt;samples[kindex].offset);
 1424 
<span class="line-modified"> 1425         /* keyframes in the segment get a chance to change the</span>
<span class="line-modified"> 1426          * desired_offset. keyframes out of the segment are</span>
<span class="line-modified"> 1427          * ignored. */</span>
<span class="line-modified"> 1428         if (media_time &gt;= seg-&gt;media_start) {</span>
 1429           GstClockTime seg_time;
 1430 
<span class="line-modified"> 1431           /* this keyframe is inside the segment, convert back to</span>
<span class="line-modified"> 1432            * segment time */</span>
<span class="line-modified"> 1433           seg_time = (media_time - seg-&gt;media_start) + seg-&gt;time;</span>
 1434           if ((!next &amp;&amp; (seg_time &lt; min_offset)) ||
 1435               (next &amp;&amp; (seg_time &gt; min_offset)))
<span class="line-modified"> 1436             min_offset = seg_time;</span>
<span class="line-added"> 1437         }</span>
 1438       }
 1439     }

 1440 
 1441     if (min_byte_offset &lt; 0 || str-&gt;samples[index].offset &lt; min_byte_offset)
 1442       min_byte_offset = str-&gt;samples[index].offset;
 1443   }
 1444 
 1445   if (key_time)
 1446     *key_time = min_offset;
 1447   if (key_offset)
 1448     *key_offset = min_byte_offset;
 1449 }
 1450 
 1451 static gboolean
 1452 gst_qtdemux_convert_seek (GstPad * pad, GstFormat * format,
 1453     GstSeekType cur_type, gint64 * cur, GstSeekType stop_type, gint64 * stop)
 1454 {
 1455   gboolean res;
 1456 
 1457   g_return_val_if_fail (format != NULL, FALSE);
 1458   g_return_val_if_fail (cur != NULL, FALSE);
 1459   g_return_val_if_fail (stop != NULL, FALSE);
</pre>
<hr />
<pre>
 1510   /* Upstream seek in bytes will have undefined stop, but qtdemux stores
 1511    * the original stop position to use when upstream pushes the new segment
 1512    * for this seek */
 1513   original_stop = stop;
 1514   stop = -1;
 1515 
 1516   /* find reasonable corresponding BYTE position,
 1517    * also try to mind about keyframes, since we can not go back a bit for them
 1518    * later on */
 1519   /* determining @next here based on SNAP_BEFORE/SNAP_AFTER should
 1520    * mostly just work, but let&#39;s not yet boldly go there  ... */
 1521   gst_qtdemux_adjust_seek (qtdemux, cur, FALSE, FALSE, &amp;key_cur, &amp;byte_cur);
 1522 
 1523   if (byte_cur == -1)
 1524     goto abort_seek;
 1525 
 1526   GST_DEBUG_OBJECT (qtdemux, &quot;Pushing BYTE seek rate %g, &quot;
 1527       &quot;start %&quot; G_GINT64_FORMAT &quot;, stop %&quot; G_GINT64_FORMAT, rate, byte_cur,
 1528       stop);
 1529 
<span class="line-modified"> 1530   GST_OBJECT_LOCK (qtdemux);</span>
<span class="line-modified"> 1531   qtdemux-&gt;seek_offset = byte_cur;</span>
 1532   if (!(flags &amp; GST_SEEK_FLAG_KEY_UNIT)) {
 1533     qtdemux-&gt;push_seek_start = cur;
 1534   } else {
 1535     qtdemux-&gt;push_seek_start = key_cur;
 1536   }
 1537 
 1538   if (stop_type == GST_SEEK_TYPE_NONE) {
 1539     qtdemux-&gt;push_seek_stop = qtdemux-&gt;segment.stop;
 1540   } else {
 1541     qtdemux-&gt;push_seek_stop = original_stop;
 1542   }
 1543   GST_OBJECT_UNLOCK (qtdemux);
 1544 
<span class="line-added"> 1545   qtdemux-&gt;segment_seqnum = seqnum;</span>
 1546   /* BYTE seek event */
 1547 #ifdef GSTREAMER_LITE
 1548   new_event = gst_event_new_seek(rate, GST_FORMAT_BYTES, flags, cur_type, byte_cur,
 1549       stop_type, stop);
 1550   gst_event_set_seqnum(new_event, seqnum);
 1551   res = gst_pad_push_event(qtdemux-&gt;sinkpad, new_event);
 1552   if (res) {
 1553     gst_event_unref(event);
 1554   }
 1555 #else // GSTREAMER_LITE
 1556   event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags, cur_type, byte_cur,
 1557       stop_type, stop);
 1558   gst_event_set_seqnum (event, seqnum);
 1559   res = gst_pad_push_event (qtdemux-&gt;sinkpad, event);
 1560 #endif // GSTREAMER_LITE
 1561 
 1562   return res;
 1563 
 1564   /* ERRORS */
 1565 abort_seek:
</pre>
<hr />
<pre>
 1584  *
 1585  * We set all segment_indexes in the streams to unknown and
 1586  * adjust the time_position to the desired position. this is enough
 1587  * to trigger a segment switch in the streaming thread to start
 1588  * streaming from the desired position.
 1589  *
 1590  * Keyframe seeking is a little more complicated when dealing with
 1591  * segments. Ideally we want to move to the previous keyframe in
 1592  * the segment but there might not be a keyframe in the segment. In
 1593  * fact, none of the segments could contain a keyframe. We take a
 1594  * practical approach: seek to the previous keyframe in the segment,
 1595  * if there is none, seek to the beginning of the segment.
 1596  *
 1597  * Called with STREAM_LOCK
 1598  */
 1599 static gboolean
 1600 gst_qtdemux_perform_seek (GstQTDemux * qtdemux, GstSegment * segment,
 1601     guint32 seqnum, GstSeekFlags flags)
 1602 {
 1603   gint64 desired_offset;
<span class="line-modified"> 1604   guint i;</span>
 1605 
 1606   desired_offset = segment-&gt;position;
 1607 
 1608   GST_DEBUG_OBJECT (qtdemux, &quot;seeking to %&quot; GST_TIME_FORMAT,
 1609       GST_TIME_ARGS (desired_offset));
 1610 
 1611   /* may not have enough fragmented info to do this adjustment,
 1612    * and we can&#39;t scan (and probably should not) at this time with
 1613    * possibly flushing upstream */
 1614   if ((flags &amp; GST_SEEK_FLAG_KEY_UNIT) &amp;&amp; !qtdemux-&gt;fragmented) {
 1615     gint64 min_offset;
 1616     gboolean next, before, after;
 1617 
 1618     before = ! !(flags &amp; GST_SEEK_FLAG_SNAP_BEFORE);
 1619     after = ! !(flags &amp; GST_SEEK_FLAG_SNAP_AFTER);
 1620     next = after &amp;&amp; !before;
 1621     if (segment-&gt;rate &lt; 0)
 1622       next = !next;
 1623 
 1624     gst_qtdemux_adjust_seek (qtdemux, desired_offset, TRUE, next, &amp;min_offset,
 1625         NULL);
 1626     GST_DEBUG_OBJECT (qtdemux, &quot;keyframe seek, align to %&quot;
 1627         GST_TIME_FORMAT, GST_TIME_ARGS (min_offset));
 1628     desired_offset = min_offset;
 1629   }
 1630 
 1631   /* and set all streams to the final position */
 1632   gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
 1633   qtdemux-&gt;segment_seqnum = seqnum;
<span class="line-modified"> 1634   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 1635     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 1636 
 1637     stream-&gt;time_position = desired_offset;
 1638     stream-&gt;accumulated_base = 0;
 1639     stream-&gt;sample_index = -1;
 1640     stream-&gt;offset_in_sample = 0;
 1641     stream-&gt;segment_index = -1;
 1642     stream-&gt;sent_eos = FALSE;
 1643 
 1644     if (segment-&gt;flags &amp; GST_SEEK_FLAG_FLUSH)
 1645       gst_segment_init (&amp;stream-&gt;segment, GST_FORMAT_TIME);
 1646   }
 1647   segment-&gt;position = desired_offset;
 1648   segment-&gt;time = desired_offset;
 1649   if (segment-&gt;rate &gt;= 0) {
 1650     segment-&gt;start = desired_offset;
 1651 
<span class="line-modified"> 1652     /* we stop at the end */</span>
<span class="line-modified"> 1653     if (segment-&gt;stop == -1)</span>
<span class="line-modified"> 1654       segment-&gt;stop = segment-&gt;duration;</span>
 1655   } else {
 1656     segment-&gt;stop = desired_offset;
 1657   }
 1658 
 1659   if (qtdemux-&gt;fragmented)
 1660     qtdemux-&gt;fragmented_seek_pending = TRUE;
 1661 
 1662   return TRUE;
 1663 }
 1664 
 1665 /* do a seek in pull based mode */
 1666 static gboolean
 1667 gst_qtdemux_do_seek (GstQTDemux * qtdemux, GstPad * pad, GstEvent * event)
 1668 {
 1669   gdouble rate;
 1670   GstFormat format;
 1671   GstSeekFlags flags;
 1672   GstSeekType cur_type, stop_type;
 1673   gint64 cur, stop;
 1674   gboolean flush;
</pre>
<hr />
<pre>
 1713     gst_pad_pause_task (qtdemux-&gt;sinkpad);
 1714   }
 1715 
 1716   /* wait for streaming to finish */
 1717   GST_PAD_STREAM_LOCK (qtdemux-&gt;sinkpad);
 1718 
 1719   /* copy segment, we need this because we still need the old
 1720    * segment when we close the current segment. */
 1721   memcpy (&amp;seeksegment, &amp;qtdemux-&gt;segment, sizeof (GstSegment));
 1722 
 1723   if (event) {
 1724     /* configure the segment with the seek variables */
 1725     GST_DEBUG_OBJECT (qtdemux, &quot;configuring seek&quot;);
 1726     if (!gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
 1727             cur_type, cur, stop_type, stop, &amp;update)) {
 1728       ret = FALSE;
 1729       GST_ERROR_OBJECT (qtdemux, &quot;inconsistent seek values, doing nothing&quot;);
 1730     } else {
 1731       /* now do the seek */
 1732       ret = gst_qtdemux_perform_seek (qtdemux, &amp;seeksegment, seqnum, flags);
<span class="line-modified"> 1733     }</span>
 1734   } else {
 1735     /* now do the seek */
 1736     ret = gst_qtdemux_perform_seek (qtdemux, &amp;seeksegment, seqnum, flags);
 1737   }
 1738 
 1739   /* prepare for streaming again */
 1740   if (flush) {
 1741     flush_event = gst_event_new_flush_stop (TRUE);
 1742     if (seqnum != GST_SEQNUM_INVALID)
 1743       gst_event_set_seqnum (flush_event, seqnum);
 1744 
 1745     gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (flush_event));
 1746     gst_qtdemux_push_event (qtdemux, flush_event);
<span class="line-modified"> 1747   }</span>
 1748 
 1749   /* commit the new segment */
 1750   memcpy (&amp;qtdemux-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 1751 
 1752   if (qtdemux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 1753     GstMessage *msg = gst_message_new_segment_start (GST_OBJECT_CAST (qtdemux),
 1754         qtdemux-&gt;segment.format, qtdemux-&gt;segment.position);
 1755     if (seqnum != GST_SEQNUM_INVALID)
 1756       gst_message_set_seqnum (msg, seqnum);
 1757     gst_element_post_message (GST_ELEMENT_CAST (qtdemux), msg);
 1758   }
 1759 
 1760   /* restart streaming, NEWSEGMENT will be sent from the streaming thread. */
 1761   gst_pad_start_task (qtdemux-&gt;sinkpad, (GstTaskFunction) gst_qtdemux_loop,
 1762       qtdemux-&gt;sinkpad, NULL);
 1763 
 1764   GST_PAD_STREAM_UNLOCK (qtdemux-&gt;sinkpad);
 1765 
 1766   return ret;
 1767 
 1768   /* ERRORS */
 1769 no_format:
 1770   {
 1771     GST_DEBUG_OBJECT (qtdemux, &quot;unsupported format given, seek aborted.&quot;);
 1772     return FALSE;
 1773   }
 1774 }
 1775 
 1776 static gboolean
 1777 qtdemux_ensure_index (GstQTDemux * qtdemux)
 1778 {
 1779   guint i;
 1780 
 1781   GST_DEBUG_OBJECT (qtdemux, &quot;collecting all metadata for all streams&quot;);
 1782 
 1783   /* Build complete index */
<span class="line-modified"> 1784   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 1785     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 1786 
<span class="line-modified"> 1787     if (!qtdemux_parse_samples (qtdemux, stream, stream-&gt;n_samples - 1)) {</span>
<span class="line-modified"> 1788       GST_LOG_OBJECT (qtdemux,</span>
<span class="line-added"> 1789           &quot;Building complete index of track-id %u for seeking failed!&quot;,</span>
<span class="line-added"> 1790           stream-&gt;track_id);</span>
<span class="line-added"> 1791       return FALSE;</span>
<span class="line-added"> 1792     }</span>
 1793   }

 1794 
<span class="line-modified"> 1795   return TRUE;</span>






 1796 }
 1797 
 1798 static gboolean
 1799 gst_qtdemux_handle_src_event (GstPad * pad, GstObject * parent,
 1800     GstEvent * event)
 1801 {
 1802   gboolean res = TRUE;
 1803   GstQTDemux *qtdemux = GST_QTDEMUX (parent);
 1804 
 1805   switch (GST_EVENT_TYPE (event)) {
 1806     case GST_EVENT_SEEK:
 1807     {
 1808 #ifndef GST_DISABLE_GST_DEBUG
 1809       GstClockTime ts = gst_util_get_timestamp ();
 1810 #endif
 1811       guint32 seqnum = gst_event_get_seqnum (event);
 1812 
<span class="line-added"> 1813       qtdemux-&gt;received_seek = TRUE;</span>
<span class="line-added"> 1814 </span>
 1815       if (seqnum == qtdemux-&gt;segment_seqnum) {
 1816         GST_LOG_OBJECT (pad,
 1817             &quot;Drop duplicated SEEK event seqnum %&quot; G_GUINT32_FORMAT, seqnum);
 1818         gst_event_unref (event);
 1819         return TRUE;
 1820       }
 1821 
 1822       if (qtdemux-&gt;upstream_format_is_time &amp;&amp; qtdemux-&gt;fragmented) {
 1823         /* seek should be handled by upstream, we might need to re-download fragments */
 1824         GST_DEBUG_OBJECT (qtdemux,
 1825             &quot;let upstream handle seek for fragmented playback&quot;);
 1826         goto upstream;
 1827       }
 1828 
 1829       /* Build complete index for seeking;
 1830        * if not a fragmented file at least */
 1831       if (!qtdemux-&gt;fragmented)
 1832         if (!qtdemux_ensure_index (qtdemux))
 1833           goto index_failed;
 1834 #ifndef GST_DISABLE_GST_DEBUG
 1835       ts = gst_util_get_timestamp () - ts;
 1836       GST_INFO_OBJECT (qtdemux,
 1837           &quot;Time taken to parse index %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (ts));
 1838 #endif
 1839     }
 1840       if (qtdemux-&gt;pullbased) {
 1841         res = gst_qtdemux_do_seek (qtdemux, pad, event);
 1842       } else if (gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (event))) {
 1843         GST_DEBUG_OBJECT (qtdemux, &quot;Upstream successfully seeked&quot;);
 1844         res = TRUE;
<span class="line-modified"> 1845       } else if (qtdemux-&gt;state == QTDEMUX_STATE_MOVIE</span>
<span class="line-added"> 1846           &amp;&amp; QTDEMUX_N_STREAMS (qtdemux)</span>
 1847           &amp;&amp; !qtdemux-&gt;fragmented) {
 1848         res = gst_qtdemux_do_push_seek (qtdemux, pad, event);
 1849       } else {
 1850         GST_DEBUG_OBJECT (qtdemux,
 1851             &quot;ignoring seek in push mode in current state&quot;);
 1852         res = FALSE;
 1853       }
 1854       gst_event_unref (event);
 1855       break;
 1856     default:
 1857     upstream:
 1858       res = gst_pad_event_default (pad, parent, event);
 1859       break;
 1860   }
 1861 
 1862 done:
 1863   return res;
 1864 
 1865   /* ERRORS */
 1866 index_failed:
</pre>
<hr />
<pre>
 1872   }
 1873 }
 1874 
 1875 /* Find, for each track, the first sample in coding order that has a file offset &gt;= @byte_pos.
 1876  *
 1877  * If @fw is false, the coding order is explored backwards.
 1878  *
 1879  * If @set is true, each stream will be moved to its matched sample, or EOS if no matching
 1880  * sample is found for that track.
 1881  *
 1882  * The stream and sample index of the sample with the minimum offset in the direction explored
 1883  * (see @fw) is returned in the output parameters @_stream and @_index respectively.
 1884  *
 1885  * @_time is set to the QTSAMPLE_PTS of the matched sample with the minimum QTSAMPLE_PTS in the
 1886  * direction explored, which may not always match the QTSAMPLE_PTS of the sample returned in
 1887  * @_stream and @_index. */
 1888 static void
 1889 gst_qtdemux_find_sample (GstQTDemux * qtdemux, gint64 byte_pos, gboolean fw,
 1890     gboolean set, QtDemuxStream ** _stream, gint * _index, gint64 * _time)
 1891 {
<span class="line-modified"> 1892   gint i, index;</span>
 1893   gint64 time, min_time;
 1894   QtDemuxStream *stream;
<span class="line-added"> 1895   gint iter;</span>
 1896 
 1897   min_time = -1;
 1898   stream = NULL;
 1899   index = -1;
 1900 
<span class="line-modified"> 1901   for (iter = 0; iter &lt; QTDEMUX_N_STREAMS (qtdemux); iter++) {</span>
 1902     QtDemuxStream *str;
 1903     gint inc;
 1904     gboolean set_sample;
 1905 
<span class="line-modified"> 1906     str = QTDEMUX_NTH_STREAM (qtdemux, iter);</span>
 1907     set_sample = !set;
 1908 
 1909     if (fw) {
 1910       i = 0;
 1911       inc = 1;
 1912     } else {
 1913       i = str-&gt;n_samples - 1;
 1914       inc = -1;
 1915     }
 1916 
 1917     for (; (i &gt;= 0) &amp;&amp; (i &lt; str-&gt;n_samples); i += inc) {
 1918       if (str-&gt;samples[i].size == 0)
 1919         continue;
 1920 
 1921       if (fw &amp;&amp; (str-&gt;samples[i].offset &lt; byte_pos))
 1922         continue;
 1923 
 1924       if (!fw &amp;&amp; (str-&gt;samples[i].offset + str-&gt;samples[i].size &gt; byte_pos))
 1925         continue;
 1926 
<span class="line-modified"> 1927       /* move stream to first available sample */</span>
<span class="line-modified"> 1928       if (set) {</span>
<span class="line-modified"> 1929         gst_qtdemux_move_stream (qtdemux, str, i);</span>
<span class="line-modified"> 1930         set_sample = TRUE;</span>
<span class="line-modified"> 1931       }</span>
 1932 
 1933       /* avoid index from sparse streams since they might be far away */
 1934       if (!CUR_STREAM (str)-&gt;sparse) {
 1935         /* determine min/max time */
 1936         time = QTSAMPLE_PTS (str, &amp;str-&gt;samples[i]);
 1937         if (min_time == -1 || (!fw &amp;&amp; time &gt; min_time) ||
 1938             (fw &amp;&amp; time &lt; min_time)) {
 1939           min_time = time;
 1940         }
 1941 
 1942         /* determine stream with leading sample, to get its position */
 1943         if (!stream ||
 1944             (fw &amp;&amp; (str-&gt;samples[i].offset &lt; stream-&gt;samples[index].offset)) ||
 1945             (!fw &amp;&amp; (str-&gt;samples[i].offset &gt; stream-&gt;samples[index].offset))) {
 1946           stream = str;
 1947           index = i;
 1948         }
 1949       }
<span class="line-modified"> 1950       break;</span>
<span class="line-modified"> 1951     }</span>
 1952 
 1953     /* no sample for this stream, mark eos */
 1954     if (!set_sample)
 1955       gst_qtdemux_move_stream (qtdemux, str, str-&gt;n_samples);
 1956   }
 1957 
 1958   if (_time)
 1959     *_time = min_time;
 1960   if (_stream)
 1961     *_stream = stream;
 1962   if (_index)
 1963     *_index = index;
 1964 }
 1965 
<span class="line-added"> 1966 /* Copied from mpegtsbase code */</span>
<span class="line-added"> 1967 /* FIXME: replace this function when we add new util function for stream-id creation */</span>
<span class="line-added"> 1968 static gchar *</span>
<span class="line-added"> 1969 _get_upstream_id (GstQTDemux * demux)</span>
<span class="line-added"> 1970 {</span>
<span class="line-added"> 1971   gchar *upstream_id = gst_pad_get_stream_id (demux-&gt;sinkpad);</span>
<span class="line-added"> 1972 </span>
<span class="line-added"> 1973   if (!upstream_id) {</span>
<span class="line-added"> 1974     /* Try to create one from the upstream URI, else use a randome number */</span>
<span class="line-added"> 1975     GstQuery *query;</span>
<span class="line-added"> 1976     gchar *uri = NULL;</span>
<span class="line-added"> 1977 </span>
<span class="line-added"> 1978     /* Try to generate one from the URI query and</span>
<span class="line-added"> 1979      * if it fails take a random number instead */</span>
<span class="line-added"> 1980     query = gst_query_new_uri ();</span>
<span class="line-added"> 1981     if (gst_element_query (GST_ELEMENT_CAST (demux), query)) {</span>
<span class="line-added"> 1982       gst_query_parse_uri (query, &amp;uri);</span>
<span class="line-added"> 1983     }</span>
<span class="line-added"> 1984 </span>
<span class="line-added"> 1985     if (uri) {</span>
<span class="line-added"> 1986       GChecksum *cs;</span>
<span class="line-added"> 1987 </span>
<span class="line-added"> 1988       /* And then generate an SHA256 sum of the URI */</span>
<span class="line-added"> 1989       cs = g_checksum_new (G_CHECKSUM_SHA256);</span>
<span class="line-added"> 1990       g_checksum_update (cs, (const guchar *) uri, strlen (uri));</span>
<span class="line-added"> 1991       g_free (uri);</span>
<span class="line-added"> 1992       upstream_id = g_strdup (g_checksum_get_string (cs));</span>
<span class="line-added"> 1993       g_checksum_free (cs);</span>
<span class="line-added"> 1994     } else {</span>
<span class="line-added"> 1995       /* Just get some random number if the URI query fails */</span>
<span class="line-added"> 1996       GST_FIXME_OBJECT (demux, &quot;Creating random stream-id, consider &quot;</span>
<span class="line-added"> 1997           &quot;implementing a deterministic way of creating a stream-id&quot;);</span>
<span class="line-added"> 1998       upstream_id =</span>
<span class="line-added"> 1999           g_strdup_printf (&quot;%08x%08x%08x%08x&quot;, g_random_int (), g_random_int (),</span>
<span class="line-added"> 2000           g_random_int (), g_random_int ());</span>
<span class="line-added"> 2001     }</span>
<span class="line-added"> 2002 </span>
<span class="line-added"> 2003     gst_query_unref (query);</span>
<span class="line-added"> 2004   }</span>
<span class="line-added"> 2005   return upstream_id;</span>
<span class="line-added"> 2006 }</span>
<span class="line-added"> 2007 </span>
 2008 static QtDemuxStream *
<span class="line-modified"> 2009 _create_stream (GstQTDemux * demux, guint32 track_id)</span>
 2010 {
 2011   QtDemuxStream *stream;
<span class="line-added"> 2012   gchar *upstream_id;</span>
 2013 
 2014   stream = g_new0 (QtDemuxStream, 1);
<span class="line-added"> 2015   stream-&gt;demux = demux;</span>
<span class="line-added"> 2016   stream-&gt;track_id = track_id;</span>
<span class="line-added"> 2017   upstream_id = _get_upstream_id (demux);</span>
<span class="line-added"> 2018   stream-&gt;stream_id = g_strdup_printf (&quot;%s/%03u&quot;, upstream_id, track_id);</span>
<span class="line-added"> 2019   g_free (upstream_id);</span>
 2020   /* new streams always need a discont */
 2021   stream-&gt;discont = TRUE;
 2022   /* we enable clipping for raw audio/video streams */
 2023   stream-&gt;need_clip = FALSE;
 2024   stream-&gt;need_process = FALSE;
 2025   stream-&gt;segment_index = -1;
 2026   stream-&gt;time_position = 0;
 2027   stream-&gt;sample_index = -1;
 2028   stream-&gt;offset_in_sample = 0;
 2029   stream-&gt;new_stream = TRUE;
 2030   stream-&gt;multiview_mode = GST_VIDEO_MULTIVIEW_MODE_NONE;
 2031   stream-&gt;multiview_flags = GST_VIDEO_MULTIVIEW_FLAGS_NONE;
 2032   stream-&gt;protected = FALSE;
 2033   stream-&gt;protection_scheme_type = 0;
 2034   stream-&gt;protection_scheme_version = 0;
 2035   stream-&gt;protection_scheme_info = NULL;
 2036   stream-&gt;n_samples_moof = 0;
 2037   stream-&gt;duration_moof = 0;
 2038   stream-&gt;duration_last_moof = 0;
 2039   stream-&gt;alignment = 1;
 2040   stream-&gt;stream_tags = gst_tag_list_new_empty ();
 2041   gst_tag_list_set_scope (stream-&gt;stream_tags, GST_TAG_SCOPE_STREAM);
 2042   g_queue_init (&amp;stream-&gt;protection_scheme_event_queue);
<span class="line-added"> 2043   stream-&gt;ref_count = 1;</span>
<span class="line-added"> 2044   /* consistent default for push based mode */</span>
<span class="line-added"> 2045   gst_segment_init (&amp;stream-&gt;segment, GST_FORMAT_TIME);</span>
 2046   return stream;
 2047 }
 2048 
 2049 static gboolean
 2050 gst_qtdemux_setcaps (GstQTDemux * demux, GstCaps * caps)
 2051 {
 2052   GstStructure *structure;
 2053   const gchar *variant;
 2054   const GstCaps *mediacaps = NULL;
 2055 
 2056   GST_DEBUG_OBJECT (demux, &quot;Sink set caps: %&quot; GST_PTR_FORMAT, caps);
 2057 
 2058   structure = gst_caps_get_structure (caps, 0);
 2059   variant = gst_structure_get_string (structure, &quot;variant&quot;);
 2060 
 2061   if (variant &amp;&amp; strcmp (variant, &quot;mss-fragmented&quot;) == 0) {
 2062     QtDemuxStream *stream;
 2063     const GValue *value;
 2064 
 2065     demux-&gt;fragmented = TRUE;
 2066     demux-&gt;mss_mode = TRUE;
 2067 
<span class="line-modified"> 2068     if (QTDEMUX_N_STREAMS (demux) &gt; 1) {</span>
 2069       /* can&#39;t do this, we can only renegotiate for another mss format */
 2070       return FALSE;
 2071     }
 2072 
 2073     value = gst_structure_get_value (structure, &quot;media-caps&quot;);
 2074     /* create stream */
 2075     if (value) {
 2076       const GValue *timescale_v;
 2077 
 2078       /* TODO update when stream changes during playback */
 2079 
<span class="line-modified"> 2080       if (QTDEMUX_N_STREAMS (demux) == 0) {</span>
<span class="line-modified"> 2081         stream = _create_stream (demux, 1);</span>
<span class="line-modified"> 2082         g_ptr_array_add (demux-&gt;active_streams, stream);</span>

 2083         /* mss has no stsd/stsd entry, use id 0 as default */
 2084         stream-&gt;stsd_entries_length = 1;
 2085         stream-&gt;stsd_sample_description_id = stream-&gt;cur_stsd_entry_index = 0;
 2086         stream-&gt;stsd_entries = g_new0 (QtDemuxStreamStsdEntry, 1);
 2087       } else {
<span class="line-modified"> 2088         stream = QTDEMUX_NTH_STREAM (demux, 0);</span>
 2089       }
 2090 
 2091       timescale_v = gst_structure_get_value (structure, &quot;timescale&quot;);
 2092       if (timescale_v) {
 2093         stream-&gt;timescale = g_value_get_uint64 (timescale_v);
 2094       } else {
 2095         /* default mss timescale */
 2096         stream-&gt;timescale = 10000000;
 2097       }
 2098       demux-&gt;timescale = stream-&gt;timescale;
 2099 
 2100       mediacaps = gst_value_get_caps (value);
 2101       if (!CUR_STREAM (stream)-&gt;caps
 2102           || !gst_caps_is_equal_fixed (mediacaps, CUR_STREAM (stream)-&gt;caps)) {
 2103         GST_DEBUG_OBJECT (demux, &quot;We have a new caps %&quot; GST_PTR_FORMAT,
 2104             mediacaps);
 2105         stream-&gt;new_caps = TRUE;
 2106       }
 2107       gst_caps_replace (&amp;CUR_STREAM (stream)-&gt;caps, (GstCaps *) mediacaps);
 2108       structure = gst_caps_get_structure (mediacaps, 0);
</pre>
<hr />
<pre>
 2117       } else if (g_str_has_prefix (gst_structure_get_name (structure), &quot;audio&quot;)) {
 2118         gint rate = 0;
 2119         stream-&gt;subtype = FOURCC_soun;
 2120         gst_structure_get_int (structure, &quot;channels&quot;,
 2121             &amp;CUR_STREAM (stream)-&gt;n_channels);
 2122         gst_structure_get_int (structure, &quot;rate&quot;, &amp;rate);
 2123         CUR_STREAM (stream)-&gt;rate = rate;
 2124       }
 2125     }
 2126     gst_caps_replace (&amp;demux-&gt;media_caps, (GstCaps *) mediacaps);
 2127   } else {
 2128     demux-&gt;mss_mode = FALSE;
 2129   }
 2130 
 2131   return TRUE;
 2132 }
 2133 
 2134 static void
 2135 gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
 2136 {
<span class="line-modified"> 2137   gint i;</span>
 2138 
 2139   GST_DEBUG_OBJECT (qtdemux, &quot;Resetting demux&quot;);
 2140   gst_pad_stop_task (qtdemux-&gt;sinkpad);
 2141 
 2142   if (hard || qtdemux-&gt;upstream_format_is_time) {
 2143     qtdemux-&gt;state = QTDEMUX_STATE_INITIAL;
 2144     qtdemux-&gt;neededbytes = 16;
 2145     qtdemux-&gt;todrop = 0;
 2146     qtdemux-&gt;pullbased = FALSE;
 2147     qtdemux-&gt;posted_redirect = FALSE;
 2148     qtdemux-&gt;first_mdat = -1;
 2149     qtdemux-&gt;header_size = 0;
 2150     qtdemux-&gt;mdatoffset = -1;
 2151     qtdemux-&gt;restoredata_offset = -1;
 2152     if (qtdemux-&gt;mdatbuffer)
 2153       gst_buffer_unref (qtdemux-&gt;mdatbuffer);
 2154     if (qtdemux-&gt;restoredata_buffer)
 2155       gst_buffer_unref (qtdemux-&gt;restoredata_buffer);
 2156     qtdemux-&gt;mdatbuffer = NULL;
 2157     qtdemux-&gt;restoredata_buffer = NULL;
 2158     qtdemux-&gt;mdatleft = 0;
 2159     qtdemux-&gt;mdatsize = 0;
 2160     if (qtdemux-&gt;comp_brands)
 2161       gst_buffer_unref (qtdemux-&gt;comp_brands);
 2162     qtdemux-&gt;comp_brands = NULL;
 2163     qtdemux-&gt;last_moov_offset = -1;
 2164     if (qtdemux-&gt;moov_node_compressed) {
 2165       g_node_destroy (qtdemux-&gt;moov_node_compressed);
<span class="line-modified"> 2166       if (qtdemux-&gt;moov_node)</span>
 2167         g_free (qtdemux-&gt;moov_node-&gt;data);
 2168     }
 2169     qtdemux-&gt;moov_node_compressed = NULL;
 2170     if (qtdemux-&gt;moov_node)
 2171       g_node_destroy (qtdemux-&gt;moov_node);
 2172     qtdemux-&gt;moov_node = NULL;
 2173     if (qtdemux-&gt;tag_list)
 2174       gst_mini_object_unref (GST_MINI_OBJECT_CAST (qtdemux-&gt;tag_list));
 2175     qtdemux-&gt;tag_list = gst_tag_list_new_empty ();
 2176     gst_tag_list_set_scope (qtdemux-&gt;tag_list, GST_TAG_SCOPE_GLOBAL);
 2177 #if 0
 2178     if (qtdemux-&gt;element_index)
 2179       gst_object_unref (qtdemux-&gt;element_index);
 2180     qtdemux-&gt;element_index = NULL;
 2181 #endif
 2182     qtdemux-&gt;major_brand = 0;



 2183     qtdemux-&gt;upstream_format_is_time = FALSE;
 2184     qtdemux-&gt;upstream_seekable = FALSE;
 2185     qtdemux-&gt;upstream_size = 0;
 2186 
 2187     qtdemux-&gt;fragment_start = -1;
 2188     qtdemux-&gt;fragment_start_offset = -1;
 2189     qtdemux-&gt;duration = 0;
 2190     qtdemux-&gt;moof_offset = 0;
 2191     qtdemux-&gt;chapters_track_id = 0;
 2192     qtdemux-&gt;have_group_id = FALSE;
 2193     qtdemux-&gt;group_id = G_MAXUINT;
 2194 
 2195     g_queue_foreach (&amp;qtdemux-&gt;protection_event_queue, (GFunc) gst_event_unref,
 2196         NULL);
 2197     g_queue_clear (&amp;qtdemux-&gt;protection_event_queue);
<span class="line-added"> 2198 </span>
<span class="line-added"> 2199     qtdemux-&gt;received_seek = FALSE;</span>
<span class="line-added"> 2200     qtdemux-&gt;first_moof_already_parsed = FALSE;</span>
 2201   }
 2202   qtdemux-&gt;offset = 0;
 2203   gst_adapter_clear (qtdemux-&gt;adapter);
 2204   gst_segment_init (&amp;qtdemux-&gt;segment, GST_FORMAT_TIME);
<span class="line-modified"> 2205   qtdemux-&gt;need_segment = TRUE;</span>
 2206 
 2207   if (hard) {
<span class="line-modified"> 2208     qtdemux-&gt;segment_seqnum = GST_SEQNUM_INVALID;</span>
<span class="line-modified"> 2209     g_ptr_array_set_size (qtdemux-&gt;active_streams, 0);</span>
<span class="line-modified"> 2210     g_ptr_array_set_size (qtdemux-&gt;old_streams, 0);</span>


 2211     qtdemux-&gt;n_video_streams = 0;
 2212     qtdemux-&gt;n_audio_streams = 0;
 2213     qtdemux-&gt;n_sub_streams = 0;
 2214     qtdemux-&gt;exposed = FALSE;
 2215     qtdemux-&gt;fragmented = FALSE;
 2216     qtdemux-&gt;mss_mode = FALSE;
 2217     gst_caps_replace (&amp;qtdemux-&gt;media_caps, NULL);
 2218     qtdemux-&gt;timescale = 0;
 2219     qtdemux-&gt;got_moov = FALSE;
<span class="line-added"> 2220     qtdemux-&gt;cenc_aux_info_offset = 0;</span>
<span class="line-added"> 2221     qtdemux-&gt;cenc_aux_info_sizes = NULL;</span>
<span class="line-added"> 2222     qtdemux-&gt;cenc_aux_sample_count = 0;</span>
 2223     if (qtdemux-&gt;protection_system_ids) {
 2224       g_ptr_array_free (qtdemux-&gt;protection_system_ids, TRUE);
 2225       qtdemux-&gt;protection_system_ids = NULL;
 2226     }
<span class="line-added"> 2227     qtdemux-&gt;streams_aware = GST_OBJECT_PARENT (qtdemux)</span>
<span class="line-added"> 2228         &amp;&amp; GST_OBJECT_FLAG_IS_SET (GST_OBJECT_PARENT (qtdemux),</span>
<span class="line-added"> 2229         GST_BIN_FLAG_STREAMS_AWARE);</span>
<span class="line-added"> 2230 </span>
<span class="line-added"> 2231     if (qtdemux-&gt;preferred_protection_system_id) {</span>
<span class="line-added"> 2232       g_free (qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added"> 2233       qtdemux-&gt;preferred_protection_system_id = NULL;</span>
<span class="line-added"> 2234     }</span>
 2235   } else if (qtdemux-&gt;mss_mode) {
 2236     gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
<span class="line-modified"> 2237     g_ptr_array_foreach (qtdemux-&gt;active_streams,</span>
<span class="line-modified"> 2238         (GFunc) gst_qtdemux_stream_clear, NULL);</span>
 2239   } else {
 2240     gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
<span class="line-modified"> 2241     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 2242       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-modified"> 2243       stream-&gt;sent_eos = FALSE;</span>
<span class="line-modified"> 2244       stream-&gt;time_position = 0;</span>
<span class="line-added"> 2245       stream-&gt;accumulated_base = 0;</span>
 2246     }





 2247   }
 2248 }

 2249 
 2250 
 2251 /* Maps the @segment to the qt edts internal segments and pushes
 2252  * the correspnding segment event.
 2253  *
 2254  * If it ends up being at a empty segment, a gap will be pushed and the next
 2255  * edts segment will be activated in sequence.
 2256  *
 2257  * To be used in push-mode only */
 2258 static void
 2259 gst_qtdemux_map_and_push_segments (GstQTDemux * qtdemux, GstSegment * segment)
 2260 {
<span class="line-modified"> 2261   gint i, iter;</span>
 2262 
<span class="line-modified"> 2263   for (iter = 0; iter &lt; QTDEMUX_N_STREAMS (qtdemux); iter++) {</span>
<span class="line-modified"> 2264     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, iter);</span>
 2265 
 2266     stream-&gt;time_position = segment-&gt;start;
 2267 
 2268     /* in push mode we should be guaranteed that we will have empty segments
 2269      * at the beginning and then one segment after, other scenarios are not
 2270      * supported and are discarded when parsing the edts */
 2271     for (i = 0; i &lt; stream-&gt;n_segments; i++) {
 2272       if (stream-&gt;segments[i].stop_time &gt; segment-&gt;start) {
<span class="line-added"> 2273         /* push the empty segment and move to the next one */</span>
 2274         gst_qtdemux_activate_segment (qtdemux, stream, i,
 2275             stream-&gt;time_position);
 2276         if (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;segments[i])) {

 2277           gst_qtdemux_send_gap_for_segment (qtdemux, stream, i,
 2278               stream-&gt;time_position);
<span class="line-added"> 2279 </span>
<span class="line-added"> 2280           /* accumulate previous segments */</span>
<span class="line-added"> 2281           if (GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.stop))</span>
<span class="line-added"> 2282             stream-&gt;accumulated_base +=</span>
<span class="line-added"> 2283                 (stream-&gt;segment.stop -</span>
<span class="line-added"> 2284                 stream-&gt;segment.start) / ABS (stream-&gt;segment.rate);</span>
 2285           continue;
 2286         }
 2287 
 2288         g_assert (i == stream-&gt;n_segments - 1);
 2289       }
 2290     }
 2291   }
 2292 }
 2293 
<span class="line-added"> 2294 static void</span>
<span class="line-added"> 2295 gst_qtdemux_stream_concat (GstQTDemux * qtdemux, GPtrArray * dest,</span>
<span class="line-added"> 2296     GPtrArray * src)</span>
<span class="line-added"> 2297 {</span>
<span class="line-added"> 2298   guint i;</span>
<span class="line-added"> 2299   guint len;</span>
<span class="line-added"> 2300 </span>
<span class="line-added"> 2301   len = src-&gt;len;</span>
<span class="line-added"> 2302 </span>
<span class="line-added"> 2303   if (len == 0)</span>
<span class="line-added"> 2304     return;</span>
<span class="line-added"> 2305 </span>
<span class="line-added"> 2306   for (i = 0; i &lt; len; i++) {</span>
<span class="line-added"> 2307     QtDemuxStream *stream = g_ptr_array_index (src, i);</span>
<span class="line-added"> 2308 </span>
<span class="line-added"> 2309 #ifndef GST_DISABLE_GST_DEBUG</span>
<span class="line-added"> 2310     GST_DEBUG_OBJECT (qtdemux, &quot;Move stream %p (stream-id %s) to %p&quot;,</span>
<span class="line-added"> 2311         stream, GST_STR_NULL (stream-&gt;stream_id), dest);</span>
<span class="line-added"> 2312 #endif</span>
<span class="line-added"> 2313     g_ptr_array_add (dest, gst_qtdemux_stream_ref (stream));</span>
<span class="line-added"> 2314   }</span>
<span class="line-added"> 2315 </span>
<span class="line-added"> 2316   g_ptr_array_set_size (src, 0);</span>
<span class="line-added"> 2317 }</span>
<span class="line-added"> 2318 </span>
 2319 static gboolean
 2320 gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
 2321     GstEvent * event)
 2322 {
 2323   GstQTDemux *demux = GST_QTDEMUX (parent);
 2324   gboolean res = TRUE;
 2325 
 2326   GST_LOG_OBJECT (demux, &quot;handling %s event&quot;, GST_EVENT_TYPE_NAME (event));
 2327 
 2328   switch (GST_EVENT_TYPE (event)) {
 2329     case GST_EVENT_SEGMENT:
 2330     {
 2331       gint64 offset = 0;
 2332       QtDemuxStream *stream;
 2333       gint idx;
 2334       GstSegment segment;
 2335 
 2336       /* some debug output */
 2337       gst_event_copy_segment (event, &amp;segment);
 2338       GST_DEBUG_OBJECT (demux, &quot;received newsegment %&quot; GST_SEGMENT_FORMAT,
 2339           &amp;segment);
 2340 



 2341       if (segment.format == GST_FORMAT_TIME) {


 2342         demux-&gt;upstream_format_is_time = TRUE;
<span class="line-added"> 2343         demux-&gt;segment_seqnum = gst_event_get_seqnum (event);</span>
 2344       } else {
 2345         GST_DEBUG_OBJECT (demux, &quot;Not storing upstream newsegment, &quot;
 2346             &quot;not in time format&quot;);
 2347 
<span class="line-modified"> 2348         /* chain will send initial newsegment after pads have been added */</span>
<span class="line-modified"> 2349         if (demux-&gt;state != QTDEMUX_STATE_MOVIE || !QTDEMUX_N_STREAMS (demux)) {</span>
<span class="line-modified"> 2350           GST_DEBUG_OBJECT (demux, &quot;still starting, eating event&quot;);</span>
<span class="line-modified"> 2351           goto exit;</span>
<span class="line-modified"> 2352         }</span>
 2353       }
 2354 
 2355       /* check if this matches a time seek we received previously
 2356        * FIXME for backwards compatibility reasons we use the
 2357        * seek_offset here to compare. In the future we might want to
 2358        * change this to use the seqnum as it uniquely should identify
 2359        * the segment that corresponds to the seek. */
 2360       GST_DEBUG_OBJECT (demux, &quot;Stored seek offset: %&quot; G_GINT64_FORMAT
 2361           &quot;, received segment offset %&quot; G_GINT64_FORMAT,
 2362           demux-&gt;seek_offset, segment.start);
 2363       if (segment.format == GST_FORMAT_BYTES
 2364           &amp;&amp; demux-&gt;seek_offset == segment.start) {
 2365         GST_OBJECT_LOCK (demux);
 2366         offset = segment.start;
 2367 
 2368         segment.format = GST_FORMAT_TIME;
 2369         segment.start = demux-&gt;push_seek_start;
 2370         segment.stop = demux-&gt;push_seek_stop;
 2371         GST_DEBUG_OBJECT (demux, &quot;Replaced segment with stored seek &quot;
 2372             &quot;segment %&quot; GST_TIME_FORMAT &quot; - %&quot; GST_TIME_FORMAT,
 2373             GST_TIME_ARGS (segment.start), GST_TIME_ARGS (segment.stop));
<span class="line-modified"> 2374         GST_OBJECT_UNLOCK (demux);</span>
 2375       }
 2376 
 2377       /* we only expect a BYTE segment, e.g. following a seek */
 2378       if (segment.format == GST_FORMAT_BYTES) {
 2379         if (GST_CLOCK_TIME_IS_VALID (segment.start)) {
 2380           offset = segment.start;
 2381 
 2382           gst_qtdemux_find_sample (demux, segment.start, TRUE, FALSE, NULL,
 2383               NULL, (gint64 *) &amp; segment.start);
 2384           if ((gint64) segment.start &lt; 0)
 2385             segment.start = 0;
<span class="line-modified"> 2386         }</span>
 2387         if (GST_CLOCK_TIME_IS_VALID (segment.stop)) {
 2388           gst_qtdemux_find_sample (demux, segment.stop, FALSE, FALSE, NULL,
 2389               NULL, (gint64 *) &amp; segment.stop);
 2390           /* keyframe seeking should already arrange for start &gt;= stop,
 2391            * but make sure in other rare cases */
 2392           segment.stop = MAX (segment.stop, segment.start);
 2393         }
 2394       } else if (segment.format == GST_FORMAT_TIME) {
 2395         /* push all data on the adapter before starting this
 2396          * new segment */
 2397         gst_qtdemux_process_adapter (demux, TRUE);
 2398       } else {
 2399         GST_DEBUG_OBJECT (demux, &quot;unsupported segment format, ignoring&quot;);
 2400         goto exit;
 2401       }
 2402 
 2403       /* We shouldn&#39;t modify upstream driven TIME FORMAT segment */
 2404       if (!demux-&gt;upstream_format_is_time) {
<span class="line-modified"> 2405         /* accept upstream&#39;s notion of segment and distribute along */</span>
<span class="line-modified"> 2406         segment.format = GST_FORMAT_TIME;</span>
<span class="line-modified"> 2407         segment.position = segment.time = segment.start;</span>
<span class="line-modified"> 2408         segment.duration = demux-&gt;segment.duration;</span>
<span class="line-modified"> 2409         segment.base = gst_segment_to_running_time (&amp;demux-&gt;segment,</span>
<span class="line-modified"> 2410             GST_FORMAT_TIME, demux-&gt;segment.position);</span>
 2411       }
 2412 
 2413       gst_segment_copy_into (&amp;segment, &amp;demux-&gt;segment);
 2414       GST_DEBUG_OBJECT (demux, &quot;Pushing newseg %&quot; GST_SEGMENT_FORMAT, &amp;segment);
 2415 
 2416       /* map segment to internal qt segments and push on each stream */
<span class="line-modified"> 2417       if (QTDEMUX_N_STREAMS (demux)) {</span>
<span class="line-modified"> 2418         demux-&gt;need_segment = TRUE;</span>
<span class="line-modified"> 2419         gst_qtdemux_check_send_pending_segment (demux);</span>








 2420       }
 2421 
 2422       /* clear leftover in current segment, if any */
 2423       gst_adapter_clear (demux-&gt;adapter);
 2424 
 2425       /* set up streaming thread */
 2426       demux-&gt;offset = offset;
 2427       if (demux-&gt;upstream_format_is_time) {
 2428         GST_DEBUG_OBJECT (demux, &quot;Upstream is driving in time format, &quot;
 2429             &quot;set values to restart reading from a new atom&quot;);
 2430         demux-&gt;neededbytes = 16;
 2431         demux-&gt;todrop = 0;
 2432       } else {
 2433         gst_qtdemux_find_sample (demux, offset, TRUE, TRUE, &amp;stream, &amp;idx,
 2434             NULL);
<span class="line-modified"> 2435         if (stream) {</span>
<span class="line-modified"> 2436           demux-&gt;todrop = stream-&gt;samples[idx].offset - offset;</span>
<span class="line-modified"> 2437           demux-&gt;neededbytes = demux-&gt;todrop + stream-&gt;samples[idx].size;</span>
<span class="line-modified"> 2438         } else {</span>
<span class="line-modified"> 2439           /* set up for EOS */</span>
<span class="line-modified"> 2440           demux-&gt;neededbytes = -1;</span>
<span class="line-modified"> 2441           demux-&gt;todrop = 0;</span>
<span class="line-modified"> 2442         }</span>
 2443       }
 2444     exit:
 2445       gst_event_unref (event);
 2446       res = TRUE;
 2447       goto drop;
 2448     }
 2449     case GST_EVENT_FLUSH_START:
 2450     {
 2451       if (gst_event_get_seqnum (event) == demux-&gt;offset_seek_seqnum) {
 2452         gst_event_unref (event);
 2453         goto drop;
 2454       }
<span class="line-modified"> 2455       QTDEMUX_EXPOSE_LOCK (demux);</span>
<span class="line-added"> 2456       res = gst_pad_event_default (demux-&gt;sinkpad, parent, event);</span>
<span class="line-added"> 2457       QTDEMUX_EXPOSE_UNLOCK (demux);</span>
<span class="line-added"> 2458       goto drop;</span>
 2459     }
 2460     case GST_EVENT_FLUSH_STOP:
 2461     {
 2462       guint64 dur;
 2463 
 2464       dur = demux-&gt;segment.duration;
 2465       gst_qtdemux_reset (demux, FALSE);
 2466       demux-&gt;segment.duration = dur;
 2467 
 2468       if (gst_event_get_seqnum (event) == demux-&gt;offset_seek_seqnum) {
 2469         gst_event_unref (event);
 2470         goto drop;
 2471       }
 2472       break;
 2473     }
 2474     case GST_EVENT_EOS:
 2475       /* If we are in push mode, and get an EOS before we&#39;ve seen any streams,
 2476        * then error out - we have nowhere to send the EOS */
 2477       if (!demux-&gt;pullbased) {
 2478         gint i;
 2479         gboolean has_valid_stream = FALSE;
<span class="line-modified"> 2480         for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 2481           if (QTDEMUX_NTH_STREAM (demux, i)-&gt;pad != NULL) {</span>
 2482             has_valid_stream = TRUE;
 2483             break;
 2484           }
 2485         }
 2486         if (!has_valid_stream)
 2487           gst_qtdemux_post_no_playable_stream_error (demux);
 2488         else {
 2489           GST_DEBUG_OBJECT (demux, &quot;Data still available after EOS: %u&quot;,
 2490               (guint) gst_adapter_available (demux-&gt;adapter));
 2491           if (gst_qtdemux_process_adapter (demux, TRUE) != GST_FLOW_OK) {
 2492             res = FALSE;
<span class="line-modified"> 2493           }</span>
 2494         }
 2495       }
 2496       break;
 2497     case GST_EVENT_CAPS:{
 2498       GstCaps *caps = NULL;
 2499 
 2500       gst_event_parse_caps (event, &amp;caps);
 2501       gst_qtdemux_setcaps (demux, caps);
 2502       res = TRUE;
 2503       gst_event_unref (event);
 2504       goto drop;
 2505     }
 2506     case GST_EVENT_PROTECTION:
 2507     {
 2508       const gchar *system_id = NULL;
 2509 
 2510       gst_event_parse_protection (event, &amp;system_id, NULL, NULL);
 2511       GST_DEBUG_OBJECT (demux, &quot;Received protection event for system ID %s&quot;,
 2512           system_id);
 2513       gst_qtdemux_append_protection_system_id (demux, system_id);
 2514       /* save the event for later, for source pads that have not been created */
 2515       g_queue_push_tail (&amp;demux-&gt;protection_event_queue, gst_event_ref (event));
 2516       /* send it to all pads that already exist */
 2517       gst_qtdemux_push_event (demux, event);
 2518       res = TRUE;
 2519       goto drop;
 2520     }
<span class="line-added"> 2521     case GST_EVENT_STREAM_START:</span>
<span class="line-added"> 2522     {</span>
<span class="line-added"> 2523       res = TRUE;</span>
<span class="line-added"> 2524       gst_event_unref (event);</span>
<span class="line-added"> 2525 </span>
<span class="line-added"> 2526       /* Drain all the buffers */</span>
<span class="line-added"> 2527       gst_qtdemux_process_adapter (demux, TRUE);</span>
<span class="line-added"> 2528       gst_qtdemux_reset (demux, FALSE);</span>
<span class="line-added"> 2529       /* We expect new moov box after new stream-start event */</span>
<span class="line-added"> 2530       if (demux-&gt;exposed) {</span>
<span class="line-added"> 2531         gst_qtdemux_stream_concat (demux,</span>
<span class="line-added"> 2532             demux-&gt;old_streams, demux-&gt;active_streams);</span>
<span class="line-added"> 2533       }</span>
<span class="line-added"> 2534 </span>
<span class="line-added"> 2535       goto drop;</span>
<span class="line-added"> 2536     }</span>
 2537     default:
 2538       break;
 2539   }
 2540 
 2541   res = gst_pad_event_default (demux-&gt;sinkpad, parent, event) &amp; res;
 2542 
 2543 drop:
 2544   return res;
 2545 }
 2546 
<span class="line-added"> 2547 static gboolean</span>
<span class="line-added"> 2548 gst_qtdemux_handle_sink_query (GstPad * pad, GstObject * parent,</span>
<span class="line-added"> 2549     GstQuery * query)</span>
<span class="line-added"> 2550 {</span>
<span class="line-added"> 2551   GstQTDemux *demux = GST_QTDEMUX (parent);</span>
<span class="line-added"> 2552   gboolean res = FALSE;</span>
<span class="line-added"> 2553 </span>
<span class="line-added"> 2554   switch (GST_QUERY_TYPE (query)) {</span>
<span class="line-added"> 2555     case GST_QUERY_BITRATE:</span>
<span class="line-added"> 2556     {</span>
<span class="line-added"> 2557       GstClockTime duration;</span>
<span class="line-added"> 2558 </span>
<span class="line-added"> 2559       /* populate demux-&gt;upstream_size if not done yet */</span>
<span class="line-added"> 2560       gst_qtdemux_check_seekability (demux);</span>
<span class="line-added"> 2561 </span>
<span class="line-added"> 2562       if (demux-&gt;upstream_size != -1</span>
<span class="line-added"> 2563           &amp;&amp; gst_qtdemux_get_duration (demux, &amp;duration)) {</span>
<span class="line-added"> 2564         guint bitrate =</span>
<span class="line-added"> 2565             gst_util_uint64_scale (8 * demux-&gt;upstream_size, GST_SECOND,</span>
<span class="line-added"> 2566             duration);</span>
<span class="line-added"> 2567 </span>
<span class="line-added"> 2568         GST_LOG_OBJECT (demux, &quot;bitrate query byte length: %&quot; G_GUINT64_FORMAT</span>
<span class="line-added"> 2569             &quot; duration %&quot; GST_TIME_FORMAT &quot; resulting a bitrate of %u&quot;,</span>
<span class="line-added"> 2570             demux-&gt;upstream_size, GST_TIME_ARGS (duration), bitrate);</span>
<span class="line-added"> 2571 </span>
<span class="line-added"> 2572         /* TODO: better results based on ranges/index tables */</span>
<span class="line-added"> 2573         gst_query_set_bitrate (query, bitrate);</span>
<span class="line-added"> 2574         res = TRUE;</span>
<span class="line-added"> 2575       }</span>
<span class="line-added"> 2576       break;</span>
<span class="line-added"> 2577     }</span>
<span class="line-added"> 2578     default:</span>
<span class="line-added"> 2579       res = gst_pad_query_default (pad, (GstObject *) demux, query);</span>
<span class="line-added"> 2580       break;</span>
<span class="line-added"> 2581   }</span>
<span class="line-added"> 2582 </span>
<span class="line-added"> 2583   return res;</span>
<span class="line-added"> 2584 }</span>
<span class="line-added"> 2585 </span>
<span class="line-added"> 2586 </span>
 2587 #if 0
 2588 static void
 2589 gst_qtdemux_set_index (GstElement * element, GstIndex * index)
 2590 {
 2591   GstQTDemux *demux = GST_QTDEMUX (element);
 2592 
 2593   GST_OBJECT_LOCK (demux);
 2594   if (demux-&gt;element_index)
 2595     gst_object_unref (demux-&gt;element_index);
 2596   if (index) {
 2597     demux-&gt;element_index = gst_object_ref (index);
 2598   } else {
 2599     demux-&gt;element_index = NULL;
 2600   }
 2601   GST_OBJECT_UNLOCK (demux);
 2602   /* object lock might be taken again */
 2603   if (index)
 2604     gst_index_get_writer_id (index, GST_OBJECT (element), &amp;demux-&gt;index_id);
 2605   GST_DEBUG_OBJECT (demux, &quot;Set index %&quot; GST_PTR_FORMAT &quot;for writer id %d&quot;,
 2606       demux-&gt;element_index, demux-&gt;index_id);
</pre>
<hr />
<pre>
 2626 static void
 2627 gst_qtdemux_stbl_free (QtDemuxStream * stream)
 2628 {
 2629   g_free ((gpointer) stream-&gt;stco.data);
 2630   stream-&gt;stco.data = NULL;
 2631   g_free ((gpointer) stream-&gt;stsz.data);
 2632   stream-&gt;stsz.data = NULL;
 2633   g_free ((gpointer) stream-&gt;stsc.data);
 2634   stream-&gt;stsc.data = NULL;
 2635   g_free ((gpointer) stream-&gt;stts.data);
 2636   stream-&gt;stts.data = NULL;
 2637   g_free ((gpointer) stream-&gt;stss.data);
 2638   stream-&gt;stss.data = NULL;
 2639   g_free ((gpointer) stream-&gt;stps.data);
 2640   stream-&gt;stps.data = NULL;
 2641   g_free ((gpointer) stream-&gt;ctts.data);
 2642   stream-&gt;ctts.data = NULL;
 2643 }
 2644 
 2645 static void
<span class="line-modified"> 2646 gst_qtdemux_stream_flush_segments_data (QtDemuxStream * stream)</span>

 2647 {
 2648   g_free (stream-&gt;segments);
 2649   stream-&gt;segments = NULL;
 2650   stream-&gt;segment_index = -1;
 2651   stream-&gt;accumulated_base = 0;
 2652 }
 2653 
 2654 static void
<span class="line-modified"> 2655 gst_qtdemux_stream_flush_samples_data (QtDemuxStream * stream)</span>

 2656 {
 2657   g_free (stream-&gt;samples);
 2658   stream-&gt;samples = NULL;
 2659   gst_qtdemux_stbl_free (stream);
 2660 
 2661   /* fragments */
 2662   g_free (stream-&gt;ra_entries);
 2663   stream-&gt;ra_entries = NULL;
 2664   stream-&gt;n_ra_entries = 0;
 2665 
 2666   stream-&gt;sample_index = -1;
 2667   stream-&gt;stbl_index = -1;
 2668   stream-&gt;n_samples = 0;
 2669   stream-&gt;time_position = 0;
 2670 
 2671   stream-&gt;n_samples_moof = 0;
 2672   stream-&gt;duration_moof = 0;
 2673   stream-&gt;duration_last_moof = 0;
 2674 }
 2675 
 2676 static void
<span class="line-modified"> 2677 gst_qtdemux_stream_clear (QtDemuxStream * stream)</span>
 2678 {
 2679   gint i;
 2680   if (stream-&gt;allocator)
 2681     gst_object_unref (stream-&gt;allocator);
 2682   while (stream-&gt;buffers) {
 2683     gst_buffer_unref (GST_BUFFER_CAST (stream-&gt;buffers-&gt;data));
 2684     stream-&gt;buffers = g_slist_delete_link (stream-&gt;buffers, stream-&gt;buffers);
 2685   }
 2686   for (i = 0; i &lt; stream-&gt;stsd_entries_length; i++) {
 2687     QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[i];
 2688     if (entry-&gt;rgb8_palette) {
 2689       gst_memory_unref (entry-&gt;rgb8_palette);
 2690       entry-&gt;rgb8_palette = NULL;
<span class="line-modified"> 2691     }</span>
 2692     entry-&gt;sparse = FALSE;
 2693   }
 2694 
<span class="line-modified"> 2695   if (stream-&gt;stream_tags)</span>
<span class="line-added"> 2696     gst_tag_list_unref (stream-&gt;stream_tags);</span>
<span class="line-added"> 2697 </span>
 2698   stream-&gt;stream_tags = gst_tag_list_new_empty ();
 2699   gst_tag_list_set_scope (stream-&gt;stream_tags, GST_TAG_SCOPE_STREAM);
 2700   g_free (stream-&gt;redirect_uri);
 2701   stream-&gt;redirect_uri = NULL;
 2702   stream-&gt;sent_eos = FALSE;
 2703   stream-&gt;protected = FALSE;
 2704   if (stream-&gt;protection_scheme_info) {
 2705     if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
 2706       QtDemuxCencSampleSetInfo *info =
 2707           (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
 2708       if (info-&gt;default_properties)
 2709         gst_structure_free (info-&gt;default_properties);
 2710       if (info-&gt;crypto_info)
 2711         g_ptr_array_free (info-&gt;crypto_info, TRUE);
<span class="line-modified"> 2712     }</span>
 2713     g_free (stream-&gt;protection_scheme_info);
 2714     stream-&gt;protection_scheme_info = NULL;
 2715   }
 2716   stream-&gt;protection_scheme_type = 0;
 2717   stream-&gt;protection_scheme_version = 0;
 2718   g_queue_foreach (&amp;stream-&gt;protection_scheme_event_queue,
 2719       (GFunc) gst_event_unref, NULL);
 2720   g_queue_clear (&amp;stream-&gt;protection_scheme_event_queue);
<span class="line-modified"> 2721   gst_qtdemux_stream_flush_segments_data (stream);</span>
<span class="line-modified"> 2722   gst_qtdemux_stream_flush_samples_data (stream);</span>
 2723 }
 2724 
 2725 static void
<span class="line-modified"> 2726 gst_qtdemux_stream_reset (QtDemuxStream * stream)</span>
 2727 {
 2728   gint i;
<span class="line-modified"> 2729   gst_qtdemux_stream_clear (stream);</span>
 2730   for (i = 0; i &lt; stream-&gt;stsd_entries_length; i++) {
 2731     QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[i];
 2732     if (entry-&gt;caps) {
 2733       gst_caps_unref (entry-&gt;caps);
 2734       entry-&gt;caps = NULL;
 2735     }
 2736   }
 2737   g_free (stream-&gt;stsd_entries);
 2738   stream-&gt;stsd_entries = NULL;
 2739   stream-&gt;stsd_entries_length = 0;
 2740 }
 2741 
<span class="line-modified"> 2742 static QtDemuxStream *</span>
<span class="line-modified"> 2743 gst_qtdemux_stream_ref (QtDemuxStream * stream)</span>

 2744 {
<span class="line-modified"> 2745   g_atomic_int_add (&amp;stream-&gt;ref_count, 1);</span>
<span class="line-modified"> 2746 </span>
<span class="line-modified"> 2747   return stream;</span>




 2748 }
 2749 
 2750 static void
<span class="line-modified"> 2751 gst_qtdemux_stream_unref (QtDemuxStream * stream)</span>
 2752 {
<span class="line-modified"> 2753   if (g_atomic_int_dec_and_test (&amp;stream-&gt;ref_count)) {</span>
<span class="line-modified"> 2754     gst_qtdemux_stream_reset (stream);</span>
<span class="line-modified"> 2755     gst_tag_list_unref (stream-&gt;stream_tags);</span>
<span class="line-modified"> 2756     if (stream-&gt;pad) {</span>
<span class="line-modified"> 2757       GstQTDemux *demux = stream-&gt;demux;</span>
<span class="line-modified"> 2758       gst_element_remove_pad (GST_ELEMENT_CAST (demux), stream-&gt;pad);</span>
<span class="line-added"> 2759       gst_flow_combiner_remove_pad (demux-&gt;flowcombiner, stream-&gt;pad);</span>
<span class="line-added"> 2760     }</span>
<span class="line-added"> 2761     g_free (stream-&gt;stream_id);</span>
<span class="line-added"> 2762     g_free (stream);</span>
<span class="line-added"> 2763   }</span>
 2764 }
 2765 
 2766 static GstStateChangeReturn
 2767 gst_qtdemux_change_state (GstElement * element, GstStateChange transition)
 2768 {
 2769   GstQTDemux *qtdemux = GST_QTDEMUX (element);
 2770   GstStateChangeReturn result = GST_STATE_CHANGE_FAILURE;
 2771 
 2772   switch (transition) {
<span class="line-modified"> 2773     case GST_STATE_CHANGE_READY_TO_PAUSED:</span>
<span class="line-added"> 2774       gst_qtdemux_reset (qtdemux, TRUE);</span>
 2775       break;
 2776     default:
 2777       break;
 2778   }
 2779 
 2780   result = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
 2781 
 2782   switch (transition) {
 2783     case GST_STATE_CHANGE_PAUSED_TO_READY:{
 2784       gst_qtdemux_reset (qtdemux, TRUE);
 2785       break;
 2786     }
 2787     default:
 2788       break;
 2789   }
 2790 
 2791   return result;
 2792 }
 2793 
<span class="line-added"> 2794 static void</span>
<span class="line-added"> 2795 gst_qtdemux_set_context (GstElement * element, GstContext * context)</span>
<span class="line-added"> 2796 {</span>
<span class="line-added"> 2797   GstQTDemux *qtdemux = GST_QTDEMUX (element);</span>
<span class="line-added"> 2798 </span>
<span class="line-added"> 2799   g_return_if_fail (GST_IS_CONTEXT (context));</span>
<span class="line-added"> 2800 </span>
<span class="line-added"> 2801   if (gst_context_has_context_type (context,</span>
<span class="line-added"> 2802           &quot;drm-preferred-decryption-system-id&quot;)) {</span>
<span class="line-added"> 2803     const GstStructure *s;</span>
<span class="line-added"> 2804 </span>
<span class="line-added"> 2805     s = gst_context_get_structure (context);</span>
<span class="line-added"> 2806     g_free (qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added"> 2807     qtdemux-&gt;preferred_protection_system_id =</span>
<span class="line-added"> 2808         g_strdup (gst_structure_get_string (s, &quot;decryption-system-id&quot;));</span>
<span class="line-added"> 2809     GST_DEBUG_OBJECT (element, &quot;set preferred decryption system to %s&quot;,</span>
<span class="line-added"> 2810         qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added"> 2811   }</span>
<span class="line-added"> 2812 </span>
<span class="line-added"> 2813   GST_ELEMENT_CLASS (parent_class)-&gt;set_context (element, context);</span>
<span class="line-added"> 2814 }</span>
<span class="line-added"> 2815 </span>
 2816 static void
 2817 qtdemux_parse_ftyp (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
 2818 {
 2819   /* counts as header data */
 2820   qtdemux-&gt;header_size += length;
 2821 
 2822   /* only consider at least a sufficiently complete ftyp atom */
 2823   if (length &gt;= 20) {
 2824     GstBuffer *buf;
 2825 
 2826     qtdemux-&gt;major_brand = QT_FOURCC (buffer + 8);
 2827     GST_DEBUG_OBJECT (qtdemux, &quot;major brand: %&quot; GST_FOURCC_FORMAT,
 2828         GST_FOURCC_ARGS (qtdemux-&gt;major_brand));
 2829     if (qtdemux-&gt;comp_brands)
 2830       gst_buffer_unref (qtdemux-&gt;comp_brands);
 2831     buf = qtdemux-&gt;comp_brands = gst_buffer_new_and_alloc (length - 16);
 2832     gst_buffer_fill (buf, 0, buffer + 16, length - 16);
 2833   }
 2834 }
 2835 
 2836 static void
 2837 qtdemux_handle_xmp_taglist (GstQTDemux * qtdemux, GstTagList * taglist,
 2838     GstTagList * xmptaglist)
 2839 {
 2840   /* Strip out bogus fields */
 2841   if (xmptaglist) {
 2842     if (gst_tag_list_get_scope (taglist) == GST_TAG_SCOPE_GLOBAL) {
 2843       gst_tag_list_remove_tag (xmptaglist, GST_TAG_VIDEO_CODEC);
 2844       gst_tag_list_remove_tag (xmptaglist, GST_TAG_AUDIO_CODEC);
 2845     } else {
 2846       gst_tag_list_remove_tag (xmptaglist, GST_TAG_CONTAINER_FORMAT);
 2847     }
 2848 
 2849     GST_DEBUG_OBJECT (qtdemux, &quot;Found XMP tags %&quot; GST_PTR_FORMAT, xmptaglist);
 2850 
<span class="line-modified"> 2851     /* prioritize native tags using _KEEP mode */</span>
 2852     gst_tag_list_insert (taglist, xmptaglist, GST_TAG_MERGE_KEEP);
 2853     gst_tag_list_unref (xmptaglist);
 2854   }
 2855 }
 2856 
<span class="line-added"> 2857 static void</span>
<span class="line-added"> 2858 qtdemux_update_default_sample_encryption_settings (GstQTDemux * qtdemux,</span>
<span class="line-added"> 2859     QtDemuxCencSampleSetInfo * info, guint32 is_encrypted, guint8 iv_size,</span>
<span class="line-added"> 2860     const guint8 * kid)</span>
<span class="line-added"> 2861 {</span>
<span class="line-added"> 2862   GstBuffer *kid_buf = gst_buffer_new_allocate (NULL, 16, NULL);</span>
<span class="line-added"> 2863   gst_buffer_fill (kid_buf, 0, kid, 16);</span>
<span class="line-added"> 2864   if (info-&gt;default_properties)</span>
<span class="line-added"> 2865     gst_structure_free (info-&gt;default_properties);</span>
<span class="line-added"> 2866   info-&gt;default_properties =</span>
<span class="line-added"> 2867       gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-added"> 2868       &quot;iv_size&quot;, G_TYPE_UINT, iv_size,</span>
<span class="line-added"> 2869       &quot;encrypted&quot;, G_TYPE_BOOLEAN, (is_encrypted == 1),</span>
<span class="line-added"> 2870       &quot;kid&quot;, GST_TYPE_BUFFER, kid_buf, NULL);</span>
<span class="line-added"> 2871   GST_DEBUG_OBJECT (qtdemux, &quot;default sample properties: &quot;</span>
<span class="line-added"> 2872       &quot;is_encrypted=%u, iv_size=%u&quot;, is_encrypted, iv_size);</span>
<span class="line-added"> 2873   gst_buffer_unref (kid_buf);</span>
<span class="line-added"> 2874 }</span>
<span class="line-added"> 2875 </span>
<span class="line-added"> 2876 static gboolean</span>
<span class="line-added"> 2877 qtdemux_update_default_piff_encryption_settings (GstQTDemux * qtdemux,</span>
<span class="line-added"> 2878     QtDemuxCencSampleSetInfo * info, GstByteReader * br)</span>
<span class="line-added"> 2879 {</span>
<span class="line-added"> 2880   guint32 algorithm_id = 0;</span>
<span class="line-added"> 2881   const guint8 *kid;</span>
<span class="line-added"> 2882   gboolean is_encrypted = TRUE;</span>
<span class="line-added"> 2883   guint8 iv_size = 8;</span>
<span class="line-added"> 2884 </span>
<span class="line-added"> 2885   if (!gst_byte_reader_get_uint24_le (br, &amp;algorithm_id)) {</span>
<span class="line-added"> 2886     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s algorithm ID field&quot;);</span>
<span class="line-added"> 2887     return FALSE;</span>
<span class="line-added"> 2888   }</span>
<span class="line-added"> 2889 </span>
<span class="line-added"> 2890   algorithm_id &gt;&gt;= 8;</span>
<span class="line-added"> 2891   if (algorithm_id == 0) {</span>
<span class="line-added"> 2892     is_encrypted = FALSE;</span>
<span class="line-added"> 2893   } else if (algorithm_id == 1) {</span>
<span class="line-added"> 2894     GST_DEBUG_OBJECT (qtdemux, &quot;AES 128-bits CTR encrypted stream&quot;);</span>
<span class="line-added"> 2895   } else if (algorithm_id == 2) {</span>
<span class="line-added"> 2896     GST_DEBUG_OBJECT (qtdemux, &quot;AES 128-bits CBC encrypted stream&quot;);</span>
<span class="line-added"> 2897   }</span>
<span class="line-added"> 2898 </span>
<span class="line-added"> 2899   if (!gst_byte_reader_get_uint8 (br, &amp;iv_size))</span>
<span class="line-added"> 2900     return FALSE;</span>
<span class="line-added"> 2901 </span>
<span class="line-added"> 2902   if (!gst_byte_reader_get_data (br, 16, &amp;kid))</span>
<span class="line-added"> 2903     return FALSE;</span>
<span class="line-added"> 2904 </span>
<span class="line-added"> 2905   qtdemux_update_default_sample_encryption_settings (qtdemux, info,</span>
<span class="line-added"> 2906       is_encrypted, iv_size, kid);</span>
<span class="line-added"> 2907   gst_structure_set (info-&gt;default_properties, &quot;piff_algorithm_id&quot;,</span>
<span class="line-added"> 2908       G_TYPE_UINT, algorithm_id, NULL);</span>
<span class="line-added"> 2909   return TRUE;</span>
<span class="line-added"> 2910 }</span>
<span class="line-added"> 2911 </span>
<span class="line-added"> 2912 </span>
 2913 static void
 2914 qtdemux_parse_piff (GstQTDemux * qtdemux, const guint8 * buffer, gint length,
 2915     guint offset)
 2916 {
 2917   GstByteReader br;
 2918   guint8 version;
 2919   guint32 flags = 0;
 2920   guint i;
<span class="line-modified"> 2921   guint iv_size = 8;</span>
 2922   QtDemuxStream *stream;
 2923   GstStructure *structure;
 2924   QtDemuxCencSampleSetInfo *ss_info = NULL;
 2925   const gchar *system_id;
 2926   gboolean uses_sub_sample_encryption = FALSE;
 2927   guint32 sample_count;
 2928 
<span class="line-modified"> 2929   if (QTDEMUX_N_STREAMS (qtdemux) == 0)</span>
 2930     return;
 2931 
<span class="line-modified"> 2932   stream = QTDEMUX_NTH_STREAM (qtdemux, 0);</span>
 2933 
 2934   structure = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);
 2935   if (!gst_structure_has_name (structure, &quot;application/x-cenc&quot;)) {
 2936     GST_WARNING_OBJECT (qtdemux,
 2937         &quot;Attempting PIFF box parsing on an unencrypted stream.&quot;);
 2938     return;
 2939   }
 2940 
 2941   gst_structure_get (structure, GST_PROTECTION_SYSTEM_ID_CAPS_FIELD,
 2942       G_TYPE_STRING, &amp;system_id, NULL);
 2943   gst_qtdemux_append_protection_system_id (qtdemux, system_id);
 2944 
 2945   stream-&gt;protected = TRUE;
 2946   stream-&gt;protection_scheme_type = FOURCC_cenc;
 2947 
 2948   if (!stream-&gt;protection_scheme_info)
 2949     stream-&gt;protection_scheme_info = g_new0 (QtDemuxCencSampleSetInfo, 1);
 2950 
 2951   ss_info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
<span class="line-added"> 2952   if (!ss_info-&gt;default_properties) {</span>
<span class="line-added"> 2953     ss_info-&gt;default_properties =</span>
<span class="line-added"> 2954         gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-added"> 2955         &quot;iv_size&quot;, G_TYPE_UINT, iv_size, &quot;encrypted&quot;, G_TYPE_BOOLEAN, TRUE,</span>
<span class="line-added"> 2956         NULL);</span>
 2957 
<span class="line-modified"> 2958   }</span>





 2959 
 2960   if (ss_info-&gt;crypto_info) {
 2961     GST_LOG_OBJECT (qtdemux, &quot;unreffing existing crypto_info&quot;);
 2962     g_ptr_array_free (ss_info-&gt;crypto_info, TRUE);
 2963     ss_info-&gt;crypto_info = NULL;
 2964   }
 2965 
 2966   /* skip UUID */
 2967   gst_byte_reader_init (&amp;br, buffer + offset + 16, length - offset - 16);
 2968 
 2969   if (!gst_byte_reader_get_uint8 (&amp;br, &amp;version)) {
 2970     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s version field&quot;);
 2971     return;
 2972   }
 2973 
 2974   if (!gst_byte_reader_get_uint24_be (&amp;br, &amp;flags)) {
 2975     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s flags field&quot;);
 2976     return;
 2977   }
 2978 
 2979   if ((flags &amp; 0x000001)) {
<span class="line-modified"> 2980     if (!qtdemux_update_default_piff_encryption_settings (qtdemux, ss_info,</span>
<span class="line-modified"> 2981             &amp;br))</span>























 2982       return;













 2983   } else if ((flags &amp; 0x000002)) {
 2984     uses_sub_sample_encryption = TRUE;
 2985   }
 2986 
<span class="line-added"> 2987   if (!gst_structure_get_uint (ss_info-&gt;default_properties, &quot;iv_size&quot;,</span>
<span class="line-added"> 2988           &amp;iv_size)) {</span>
<span class="line-added"> 2989     GST_ERROR_OBJECT (qtdemux, &quot;Error getting encryption IV size field&quot;);</span>
<span class="line-added"> 2990     return;</span>
<span class="line-added"> 2991   }</span>
<span class="line-added"> 2992 </span>
 2993   if (!gst_byte_reader_get_uint32_be (&amp;br, &amp;sample_count)) {
 2994     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s sample count field&quot;);
 2995     return;
 2996   }
 2997 
 2998   ss_info-&gt;crypto_info =
 2999       g_ptr_array_new_full (sample_count,
 3000       (GDestroyNotify) qtdemux_gst_structure_free);
 3001 
 3002   for (i = 0; i &lt; sample_count; ++i) {
 3003     GstStructure *properties;
 3004     guint8 *data;
 3005     GstBuffer *buf;
 3006 
 3007     properties = qtdemux_get_cenc_sample_properties (qtdemux, stream, i);
 3008     if (properties == NULL) {
 3009       GST_ERROR_OBJECT (qtdemux, &quot;failed to get properties for sample %u&quot;, i);
 3010       qtdemux-&gt;cenc_aux_sample_count = i;
 3011       return;
 3012     }
 3013 
 3014     if (!gst_byte_reader_dup_data (&amp;br, iv_size, &amp;data)) {
 3015       GST_ERROR_OBJECT (qtdemux, &quot;IV data not present for sample %u&quot;, i);
 3016       gst_structure_free (properties);
 3017       qtdemux-&gt;cenc_aux_sample_count = i;
 3018       return;
 3019     }
 3020     buf = gst_buffer_new_wrapped (data, iv_size);
 3021     gst_structure_set (properties, &quot;iv&quot;, GST_TYPE_BUFFER, buf, NULL);
 3022     gst_buffer_unref (buf);
 3023 
 3024     if (uses_sub_sample_encryption) {
 3025       guint16 n_subsamples;
<span class="line-added"> 3026       const GValue *kid_buf_value;</span>
 3027 
 3028       if (!gst_byte_reader_get_uint16_be (&amp;br, &amp;n_subsamples)
 3029           || n_subsamples == 0) {
 3030         GST_ERROR_OBJECT (qtdemux,
 3031             &quot;failed to get subsample count for sample %u&quot;, i);
 3032         gst_structure_free (properties);
 3033         qtdemux-&gt;cenc_aux_sample_count = i;
 3034         return;
 3035       }
 3036       GST_LOG_OBJECT (qtdemux, &quot;subsample count: %u&quot;, n_subsamples);
 3037       if (!gst_byte_reader_dup_data (&amp;br, n_subsamples * 6, &amp;data)) {
 3038         GST_ERROR_OBJECT (qtdemux, &quot;failed to get subsample data for sample %u&quot;,
 3039             i);
 3040         gst_structure_free (properties);
 3041         qtdemux-&gt;cenc_aux_sample_count = i;
 3042         return;
 3043       }
 3044       buf = gst_buffer_new_wrapped (data, n_subsamples * 6);
<span class="line-added"> 3045 </span>
<span class="line-added"> 3046       kid_buf_value =</span>
<span class="line-added"> 3047           gst_structure_get_value (ss_info-&gt;default_properties, &quot;kid&quot;);</span>
<span class="line-added"> 3048 </span>
 3049       gst_structure_set (properties,
 3050           &quot;subsample_count&quot;, G_TYPE_UINT, n_subsamples,
 3051           &quot;subsamples&quot;, GST_TYPE_BUFFER, buf, NULL);
<span class="line-added"> 3052       gst_structure_set_value (properties, &quot;kid&quot;, kid_buf_value);</span>
 3053       gst_buffer_unref (buf);
 3054     } else {
 3055       gst_structure_set (properties, &quot;subsample_count&quot;, G_TYPE_UINT, 0, NULL);
 3056     }
 3057 
 3058     g_ptr_array_add (ss_info-&gt;crypto_info, properties);
 3059   }
 3060 
 3061   qtdemux-&gt;cenc_aux_sample_count = sample_count;
 3062 }
 3063 
 3064 static void
 3065 qtdemux_parse_uuid (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
 3066 {
 3067   static const guint8 xmp_uuid[] = { 0xBE, 0x7A, 0xCF, 0xCB,
 3068     0x97, 0xA9, 0x42, 0xE8,
 3069     0x9C, 0x71, 0x99, 0x94,
 3070     0x91, 0xE3, 0xAF, 0xAC
 3071   };
 3072   static const guint8 playready_uuid[] = {
</pre>
<hr />
<pre>
 3292     prevdur = QTTIME_TO_GSTTIME (qtdemux, qtdemux-&gt;duration);
 3293     GST_DEBUG_OBJECT (qtdemux,
 3294         &quot;Updating total duration to %&quot; GST_TIME_FORMAT &quot; was %&quot; GST_TIME_FORMAT,
 3295         GST_TIME_ARGS (duration), GST_TIME_ARGS (prevdur));
 3296     qtdemux-&gt;duration = movdur;
 3297     GST_DEBUG_OBJECT (qtdemux,
 3298         &quot;qtdemux-&gt;segment.duration: %&quot; GST_TIME_FORMAT &quot; .stop: %&quot;
 3299         GST_TIME_FORMAT, GST_TIME_ARGS (qtdemux-&gt;segment.duration),
 3300         GST_TIME_ARGS (qtdemux-&gt;segment.stop));
 3301     if (qtdemux-&gt;segment.duration == prevdur) {
 3302       /* If the current segment has duration/stop identical to previous duration
 3303        * update them also (because they were set at that point in time with
 3304        * the wrong duration */
 3305       /* We convert the value *from* the timescale version to avoid rounding errors */
 3306       GstClockTime fixeddur = QTTIME_TO_GSTTIME (qtdemux, movdur);
 3307       GST_DEBUG_OBJECT (qtdemux, &quot;Updated segment.duration and segment.stop&quot;);
 3308       qtdemux-&gt;segment.duration = fixeddur;
 3309       qtdemux-&gt;segment.stop = fixeddur;
 3310     }
 3311   }




























 3312 
<span class="line-modified"> 3313   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 3314     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added"> 3315 </span>
<span class="line-added"> 3316     movdur = GSTTIME_TO_QTSTREAMTIME (stream, duration);</span>
<span class="line-added"> 3317     if (movdur &gt; stream-&gt;duration) {</span>
<span class="line-added"> 3318       GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added"> 3319           &quot;Updating stream #%d duration to %&quot; GST_TIME_FORMAT, i,</span>
<span class="line-added"> 3320           GST_TIME_ARGS (duration));</span>
<span class="line-added"> 3321       stream-&gt;duration = movdur;</span>
<span class="line-added"> 3322       /* internal duration tracking state has been updated above, so */</span>
<span class="line-added"> 3323       /* preserve an open-ended dummy segment rather than repeatedly updating</span>
<span class="line-added"> 3324        * it and spamming downstream accordingly with segment events */</span>
<span class="line-added"> 3325       if (stream-&gt;dummy_segment &amp;&amp;</span>
<span class="line-added"> 3326           GST_CLOCK_TIME_IS_VALID (stream-&gt;segments[0].duration)) {</span>
<span class="line-added"> 3327         /* Update all dummy values to new duration */</span>
<span class="line-added"> 3328         stream-&gt;segments[0].stop_time = duration;</span>
<span class="line-added"> 3329         stream-&gt;segments[0].duration = duration;</span>
<span class="line-added"> 3330         stream-&gt;segments[0].media_stop = duration;</span>
<span class="line-added"> 3331 </span>
<span class="line-added"> 3332         /* let downstream know we possibly have a new stop time */</span>
<span class="line-added"> 3333         if (stream-&gt;segment_index != -1) {</span>
<span class="line-added"> 3334           GstClockTime pos;</span>
<span class="line-added"> 3335 </span>
<span class="line-added"> 3336           if (qtdemux-&gt;segment.rate &gt;= 0) {</span>
<span class="line-added"> 3337             pos = stream-&gt;segment.start;</span>
<span class="line-added"> 3338           } else {</span>
<span class="line-added"> 3339             pos = stream-&gt;segment.stop;</span>
 3340           }
<span class="line-added"> 3341 </span>
<span class="line-added"> 3342           gst_qtdemux_stream_update_segment (qtdemux, stream,</span>
<span class="line-added"> 3343               stream-&gt;segment_index, pos, NULL, NULL);</span>
 3344         }
 3345       }
 3346     }
 3347   }
 3348 }
 3349 
 3350 static gboolean
 3351 qtdemux_parse_trun (GstQTDemux * qtdemux, GstByteReader * trun,
 3352     QtDemuxStream * stream, guint32 d_sample_duration, guint32 d_sample_size,
 3353     guint32 d_sample_flags, gint64 moof_offset, gint64 moof_length,
 3354     gint64 * base_offset, gint64 * running_offset, gint64 decode_ts,
 3355     gboolean has_tfdt)
 3356 {
 3357   GstClockTime gst_ts = GST_CLOCK_TIME_NONE;
 3358   guint64 timestamp;
 3359   gint32 data_offset = 0;
 3360   guint32 flags = 0, first_flags = 0, samples_count = 0;
 3361   gint i;
 3362   guint8 *data;
 3363   guint entry_size, dur_offset, size_offset, flags_offset = 0, ct_offset = 0;
 3364   QtDemuxSample *sample;
 3365   gboolean ismv = FALSE;
 3366   gint64 initial_offset;
 3367 
<span class="line-modified"> 3368   GST_LOG_OBJECT (qtdemux, &quot;parsing trun track-id %d; &quot;</span>
 3369       &quot;default dur %d, size %d, flags 0x%x, base offset %&quot; G_GINT64_FORMAT &quot;, &quot;
 3370       &quot;decode ts %&quot; G_GINT64_FORMAT, stream-&gt;track_id, d_sample_duration,
 3371       d_sample_size, d_sample_flags, *base_offset, decode_ts);
 3372 
 3373   if (stream-&gt;pending_seek &amp;&amp; moof_offset &lt; stream-&gt;pending_seek-&gt;moof_offset) {
 3374     GST_INFO_OBJECT (stream-&gt;pad, &quot;skipping trun before seek target fragment&quot;);
 3375     return TRUE;
 3376   }
 3377 
 3378   /* presence of stss or not can&#39;t really tell us much,
 3379    * and flags and so on tend to be marginally reliable in these files */
 3380   if (stream-&gt;subtype == FOURCC_soun) {
 3381     GST_DEBUG_OBJECT (qtdemux,
 3382         &quot;sound track in fragmented file; marking all keyframes&quot;);
 3383     stream-&gt;all_keyframe = TRUE;
 3384   }
 3385 
 3386   if (!gst_byte_reader_skip (trun, 1) ||
 3387       !gst_byte_reader_get_uint24_be (trun, &amp;flags))
 3388     goto fail;
</pre>
<hr />
<pre>
 3456     entry_size += 4;
 3457   }
 3458 
 3459   if (!qt_atom_parser_has_chunks (trun, samples_count, entry_size))
 3460     goto fail;
 3461   data = (guint8 *) gst_byte_reader_peek_data_unchecked (trun);
 3462 
 3463   if (stream-&gt;n_samples + samples_count &gt;=
 3464       QTDEMUX_MAX_SAMPLE_INDEX_SIZE / sizeof (QtDemuxSample))
 3465     goto index_too_big;
 3466 
 3467   GST_DEBUG_OBJECT (qtdemux, &quot;allocating n_samples %u * %u (%.2f MB)&quot;,
 3468       stream-&gt;n_samples + samples_count, (guint) sizeof (QtDemuxSample),
 3469       (stream-&gt;n_samples + samples_count) *
 3470       sizeof (QtDemuxSample) / (1024.0 * 1024.0));
 3471 
 3472   /* create a new array of samples if it&#39;s the first sample parsed */
 3473   if (stream-&gt;n_samples == 0) {
 3474     g_assert (stream-&gt;samples == NULL);
 3475     stream-&gt;samples = g_try_new0 (QtDemuxSample, samples_count);
<span class="line-modified"> 3476     /* or try to reallocate it with space enough to insert the new samples */</span>
 3477   } else
 3478     stream-&gt;samples = g_try_renew (QtDemuxSample, stream-&gt;samples,
 3479         stream-&gt;n_samples + samples_count);
 3480   if (stream-&gt;samples == NULL)
 3481     goto out_of_memory;
 3482 
 3483   if (qtdemux-&gt;fragment_start != -1) {
 3484     timestamp = GSTTIME_TO_QTSTREAMTIME (stream, qtdemux-&gt;fragment_start);
 3485     qtdemux-&gt;fragment_start = -1;
 3486   } else {
 3487     if (stream-&gt;n_samples == 0) {
 3488       if (decode_ts &gt; 0) {
 3489         timestamp = decode_ts;
 3490       } else if (stream-&gt;pending_seek != NULL) {
 3491         /* if we don&#39;t have a timestamp from a tfdt box, we&#39;ll use the one
 3492          * from the mfra seek table */
 3493         GST_INFO_OBJECT (stream-&gt;pad, &quot;pending seek ts = %&quot; GST_TIME_FORMAT,
 3494             GST_TIME_ARGS (stream-&gt;pending_seek-&gt;ts));
 3495 
 3496         /* FIXME: this is not fully correct, the timestamp refers to the random
 3497          * access sample refered to in the tfra entry, which may not necessarily
 3498          * be the first sample in the tfrag/trun (but hopefully/usually is) */
 3499         timestamp = GSTTIME_TO_QTSTREAMTIME (stream, stream-&gt;pending_seek-&gt;ts);
 3500       } else {
<span class="line-modified"> 3501         timestamp = 0;</span>
 3502       }
 3503 
 3504       gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
 3505       GST_INFO_OBJECT (stream-&gt;pad, &quot;first sample ts %&quot; GST_TIME_FORMAT,
 3506           GST_TIME_ARGS (gst_ts));
<span class="line-modified"> 3507     } else {</span>
<span class="line-modified"> 3508       /* subsequent fragments extend stream */</span>
<span class="line-modified"> 3509       timestamp =</span>
<span class="line-modified"> 3510           stream-&gt;samples[stream-&gt;n_samples - 1].timestamp +</span>
<span class="line-modified"> 3511           stream-&gt;samples[stream-&gt;n_samples - 1].duration;</span>
 3512 
 3513       /* If this is a GST_FORMAT_BYTES stream and there&#39;s a significant
 3514        * difference (1 sec.) between decode_ts and timestamp, prefer the
 3515        * former */
 3516       if (has_tfdt &amp;&amp; !qtdemux-&gt;upstream_format_is_time
 3517           &amp;&amp; ABSDIFF (decode_ts, timestamp) &gt;
 3518           MAX (stream-&gt;duration_last_moof / 2,
 3519               GSTTIME_TO_QTSTREAMTIME (stream, GST_SECOND))) {
 3520         GST_INFO_OBJECT (qtdemux,
 3521             &quot;decode_ts (%&quot; GST_TIME_FORMAT &quot;) and timestamp (%&quot; GST_TIME_FORMAT
 3522             &quot;) are significantly different (more than %&quot; GST_TIME_FORMAT
 3523             &quot;), using decode_ts&quot;,
 3524             GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, decode_ts)),
 3525             GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, timestamp)),
 3526             GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream,
 3527                     MAX (stream-&gt;duration_last_moof / 2,
 3528                         GSTTIME_TO_QTSTREAMTIME (stream, GST_SECOND)))));
 3529         timestamp = decode_ts;
<span class="line-modified"> 3530       }</span>
 3531 
 3532       gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
 3533       GST_INFO_OBJECT (qtdemux, &quot;first sample ts %&quot; GST_TIME_FORMAT
 3534           &quot; (extends previous samples)&quot;, GST_TIME_ARGS (gst_ts));
<span class="line-modified"> 3535     }</span>
 3536   }
 3537 
 3538   initial_offset = *running_offset;
 3539 
 3540   sample = stream-&gt;samples + stream-&gt;n_samples;
 3541   for (i = 0; i &lt; samples_count; i++) {
 3542     guint32 dur, size, sflags, ct;
 3543 
 3544     /* first read sample data */
 3545     if (flags &amp; TR_SAMPLE_DURATION) {
 3546       dur = QT_UINT32 (data + dur_offset);
 3547     } else {
 3548       dur = d_sample_duration;
 3549     }
 3550     if (flags &amp; TR_SAMPLE_SIZE) {
 3551       size = QT_UINT32 (data + size_offset);
 3552     } else {
 3553       size = d_sample_size;
 3554     }
 3555     if (flags &amp; TR_FIRST_SAMPLE_FLAGS) {
</pre>
<hr />
<pre>
 3621     GST_WARNING_OBJECT (qtdemux, &quot;not allocating index of %d samples, would &quot;
 3622         &quot;be larger than %uMB (broken file?)&quot;, stream-&gt;n_samples,
 3623         QTDEMUX_MAX_SAMPLE_INDEX_SIZE &gt;&gt; 20);
 3624     return FALSE;
 3625   }
 3626 }
 3627 
 3628 /* find stream with @id */
 3629 static inline QtDemuxStream *
 3630 qtdemux_find_stream (GstQTDemux * qtdemux, guint32 id)
 3631 {
 3632   QtDemuxStream *stream;
 3633   gint i;
 3634 
 3635   /* check */
 3636   if (G_UNLIKELY (!id)) {
 3637     GST_DEBUG_OBJECT (qtdemux, &quot;invalid track id 0&quot;);
 3638     return NULL;
 3639   }
 3640 
<span class="line-modified"> 3641   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 3642     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>








 3643     if (stream-&gt;track_id == id)
 3644       return stream;
 3645   }
 3646   if (qtdemux-&gt;mss_mode) {
 3647     /* mss should have only 1 stream anyway */
<span class="line-modified"> 3648     return QTDEMUX_NTH_STREAM (qtdemux, 0);</span>
 3649   }
 3650 
 3651   return NULL;
 3652 }
 3653 
 3654 static gboolean
 3655 qtdemux_parse_mfhd (GstQTDemux * qtdemux, GstByteReader * mfhd,
 3656     guint32 * fragment_number)
 3657 {
 3658   if (!gst_byte_reader_skip (mfhd, 4))
 3659     goto fail;
 3660   if (!gst_byte_reader_get_uint32_be (mfhd, fragment_number))
 3661     goto fail;
 3662   return TRUE;
 3663 fail:
 3664   {
 3665     GST_WARNING_OBJECT (qtdemux, &quot;Failed to parse mfhd atom&quot;);
 3666     return FALSE;
 3667   }
 3668 }
</pre>
<hr />
<pre>
 4062 
 4063   if (G_UNLIKELY (pssh_size &lt; 32U)) {
 4064     GST_ERROR_OBJECT (qtdemux, &quot;invalid box size&quot;);
 4065     return FALSE;
 4066   }
 4067 
 4068   sysid_string =
 4069       qtdemux_uuid_bytes_to_string ((const guint8 *) node-&gt;data + 12);
 4070 
 4071   gst_qtdemux_append_protection_system_id (qtdemux, sysid_string);
 4072 
 4073   pssh = gst_buffer_new_wrapped (g_memdup (node-&gt;data, pssh_size), pssh_size);
 4074   GST_LOG_OBJECT (qtdemux, &quot;cenc pssh size: %&quot; G_GSIZE_FORMAT,
 4075       gst_buffer_get_size (pssh));
 4076 
 4077   parent_box_type = QT_FOURCC ((const guint8 *) node-&gt;parent-&gt;data + 4);
 4078 
 4079   /* Push an event containing the pssh box onto the queues of all streams. */
 4080   event = gst_event_new_protection (sysid_string, pssh,
 4081       (parent_box_type == FOURCC_moov) ? &quot;isobmff/moov&quot; : &quot;isobmff/moof&quot;);
<span class="line-modified"> 4082   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 4083     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added"> 4084     GST_TRACE_OBJECT (qtdemux,</span>
<span class="line-added"> 4085         &quot;adding protection event for stream %s and system %s&quot;,</span>
<span class="line-added"> 4086         stream-&gt;stream_id, sysid_string);</span>
<span class="line-added"> 4087     g_queue_push_tail (&amp;stream-&gt;protection_scheme_event_queue,</span>
 4088         gst_event_ref (event));
 4089   }
 4090   g_free (sysid_string);
 4091   gst_event_unref (event);
 4092   gst_buffer_unref (pssh);
 4093   return TRUE;
 4094 }
 4095 
 4096 static gboolean
 4097 qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
 4098     guint64 moof_offset, QtDemuxStream * stream)
 4099 {
 4100   GNode *moof_node, *traf_node, *tfhd_node, *trun_node, *tfdt_node, *mfhd_node;
 4101   GNode *uuid_node;
 4102   GstByteReader mfhd_data, trun_data, tfhd_data, tfdt_data;
 4103   GNode *saiz_node, *saio_node, *pssh_node;
 4104   GstByteReader saiz_data, saio_data;
 4105   guint32 ds_size = 0, ds_duration = 0, ds_flags = 0;
 4106   gint64 base_offset, running_offset;
 4107   guint32 frag_num;
<span class="line-added"> 4108   GstClockTime min_dts = GST_CLOCK_TIME_NONE;</span>
 4109 
 4110   /* NOTE @stream ignored */
 4111 
 4112   moof_node = g_node_new ((guint8 *) buffer);
 4113   qtdemux_parse_node (qtdemux, moof_node, buffer, length);
 4114   qtdemux_node_dump (qtdemux, moof_node);
 4115 
 4116   /* Get fragment number from mfhd and check it&#39;s valid */
 4117   mfhd_node =
 4118       qtdemux_tree_get_child_by_type_full (moof_node, FOURCC_mfhd, &amp;mfhd_data);
 4119   if (mfhd_node == NULL)
 4120     goto missing_mfhd;
 4121   if (!qtdemux_parse_mfhd (qtdemux, &amp;mfhd_data, &amp;frag_num))
 4122     goto fail;
 4123   GST_DEBUG_OBJECT (qtdemux, &quot;Fragment #%d&quot;, frag_num);
 4124 
 4125   /* unknown base_offset to start with */
 4126   base_offset = running_offset = -1;
 4127   traf_node = qtdemux_tree_get_child_by_type (moof_node, FOURCC_traf);
 4128   while (traf_node) {
</pre>
<hr />
<pre>
 4209           &quot; (%&quot; GST_TIME_FORMAT &quot;)&quot;, decode_time,
 4210           GST_TIME_ARGS (stream ? QTSTREAMTIME_TO_GSTTIME (stream,
 4211                   decode_time) : GST_CLOCK_TIME_NONE));
 4212 
 4213       /* Discard the fragment buffer timestamp info to avoid using it.
 4214        * Rely on tfdt instead as it is more accurate than the timestamp
 4215        * that is fetched from a manifest/playlist and is usually
 4216        * less accurate. */
 4217       qtdemux-&gt;fragment_start = -1;
 4218     }
 4219 
 4220     if (G_UNLIKELY (!stream)) {
 4221       /* we lost track of offset, we&#39;ll need to regain it,
 4222        * but can delay complaining until later or avoid doing so altogether */
 4223       base_offset = -2;
 4224       goto next;
 4225     }
 4226     if (G_UNLIKELY (base_offset &lt; -1))
 4227       goto lost_offset;
 4228 
<span class="line-modified"> 4229     min_dts = MIN (min_dts, QTSTREAMTIME_TO_GSTTIME (stream, decode_time));</span>
<span class="line-modified"> 4230 </span>
<span class="line-added"> 4231     if (!qtdemux-&gt;pullbased) {</span>
<span class="line-added"> 4232       /* Sample tables can grow enough to be problematic if the system memory</span>
<span class="line-added"> 4233        * is very low (e.g. embedded devices) and the videos very long</span>
<span class="line-added"> 4234        * (~8 MiB/hour for 25-30 fps video + typical AAC audio frames).</span>
<span class="line-added"> 4235        * Fortunately, we can easily discard them for each new fragment when</span>
<span class="line-added"> 4236        * we know qtdemux will not receive seeks outside of the current fragment.</span>
<span class="line-added"> 4237        * adaptivedemux honors this assumption.</span>
<span class="line-added"> 4238        * This optimization is also useful for applications that use qtdemux as</span>
<span class="line-added"> 4239        * a push-based simple demuxer, like Media Source Extensions. */</span>
<span class="line-added"> 4240       gst_qtdemux_stream_flush_samples_data (stream);</span>
<span class="line-added"> 4241     }</span>
 4242 
 4243     /* initialise moof sample data */
 4244     stream-&gt;n_samples_moof = 0;
 4245     stream-&gt;duration_last_moof = stream-&gt;duration_moof;
 4246     stream-&gt;duration_moof = 0;
 4247 
 4248     /* Track Run node */
 4249     trun_node =
 4250         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_trun,
 4251         &amp;trun_data);
 4252     while (trun_node) {
 4253       qtdemux_parse_trun (qtdemux, &amp;trun_data, stream,
 4254           ds_duration, ds_size, ds_flags, moof_offset, length, &amp;base_offset,
 4255           &amp;running_offset, decode_time, (tfdt_node != NULL));
 4256       /* iterate all siblings */
 4257       trun_node = qtdemux_tree_get_sibling_by_type_full (trun_node, FOURCC_trun,
 4258           &amp;trun_data);
 4259     }
 4260 
 4261     uuid_node = qtdemux_tree_get_child_by_type (traf_node, FOURCC_uuid);
</pre>
<hr />
<pre>
 4270      * base is end of current traf */
 4271     base_offset = running_offset;
 4272     running_offset = -1;
 4273 
 4274     if (stream-&gt;n_samples_moof &amp;&amp; stream-&gt;duration_moof)
 4275       stream-&gt;new_caps = TRUE;
 4276 
 4277   next:
 4278     /* iterate all siblings */
 4279     traf_node = qtdemux_tree_get_sibling_by_type (traf_node, FOURCC_traf);
 4280   }
 4281 
 4282   /* parse any protection system info */
 4283   pssh_node = qtdemux_tree_get_child_by_type (moof_node, FOURCC_pssh);
 4284   while (pssh_node) {
 4285     GST_LOG_OBJECT (qtdemux, &quot;Parsing pssh box.&quot;);
 4286     qtdemux_parse_pssh (qtdemux, pssh_node);
 4287     pssh_node = qtdemux_tree_get_sibling_by_type (pssh_node, FOURCC_pssh);
 4288   }
 4289 
<span class="line-added"> 4290   if (!qtdemux-&gt;upstream_format_is_time &amp;&amp; !qtdemux-&gt;first_moof_already_parsed</span>
<span class="line-added"> 4291       &amp;&amp; !qtdemux-&gt;received_seek &amp;&amp; GST_CLOCK_TIME_IS_VALID (min_dts)</span>
<span class="line-added"> 4292       &amp;&amp; min_dts != 0) {</span>
<span class="line-added"> 4293     /* Unless the user has explictly requested another seek, perform an</span>
<span class="line-added"> 4294      * internal seek to the time specified in the tfdt.</span>
<span class="line-added"> 4295      *</span>
<span class="line-added"> 4296      * This way if the user opens a file where the first tfdt is 1 hour</span>
<span class="line-added"> 4297      * into the presentation, they will not have to wait 1 hour for run</span>
<span class="line-added"> 4298      * time to catch up and actual playback to start. */</span>
<span class="line-added"> 4299     gint i;</span>
<span class="line-added"> 4300 </span>
<span class="line-added"> 4301     GST_DEBUG_OBJECT (qtdemux, &quot;First fragment has a non-zero tfdt, &quot;</span>
<span class="line-added"> 4302         &quot;performing an internal seek to %&quot; GST_TIME_FORMAT,</span>
<span class="line-added"> 4303         GST_TIME_ARGS (min_dts));</span>
<span class="line-added"> 4304 </span>
<span class="line-added"> 4305     qtdemux-&gt;segment.start = min_dts;</span>
<span class="line-added"> 4306     qtdemux-&gt;segment.time = qtdemux-&gt;segment.position = min_dts;</span>
<span class="line-added"> 4307 </span>
<span class="line-added"> 4308     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added"> 4309       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added"> 4310       stream-&gt;time_position = min_dts;</span>
<span class="line-added"> 4311     }</span>
<span class="line-added"> 4312 </span>
<span class="line-added"> 4313     /* Before this code was run a segment was already sent when the moov was</span>
<span class="line-added"> 4314      * parsed... which is OK -- some apps (mostly tests) expect a segment to</span>
<span class="line-added"> 4315      * be emitted after a moov, and we can emit a second segment anyway for</span>
<span class="line-added"> 4316      * special cases like this. */</span>
<span class="line-added"> 4317     qtdemux-&gt;need_segment = TRUE;</span>
<span class="line-added"> 4318   }</span>
<span class="line-added"> 4319 </span>
<span class="line-added"> 4320   qtdemux-&gt;first_moof_already_parsed = TRUE;</span>
<span class="line-added"> 4321 </span>
 4322   g_node_destroy (moof_node);
 4323   return TRUE;
 4324 
 4325 missing_tfhd:
 4326   {
 4327     GST_DEBUG_OBJECT (qtdemux, &quot;missing tfhd box&quot;);
 4328     goto fail;
 4329   }
 4330 missing_mfhd:
 4331   {
 4332     GST_DEBUG_OBJECT (qtdemux, &quot;Missing mfhd box&quot;);
 4333     goto fail;
 4334   }
 4335 lost_offset:
 4336   {
 4337     GST_DEBUG_OBJECT (qtdemux, &quot;lost offset&quot;);
 4338     goto fail;
 4339   }
 4340 fail:
 4341   {
</pre>
<hr />
<pre>
 4509     qtdemux_parse_tfra (qtdemux, tfra_node);
 4510     /* iterate all siblings */
 4511     tfra_node = qtdemux_tree_get_sibling_by_type (tfra_node, FOURCC_tfra);
 4512   }
 4513   g_node_destroy (mfra_node);
 4514 
 4515   GST_INFO_OBJECT (qtdemux, &quot;parsed movie fragment random access box (mfra)&quot;);
 4516   ret = TRUE;
 4517 
 4518 exit:
 4519 
 4520   if (mfro) {
 4521     if (mfro_map.memory != NULL)
 4522       gst_buffer_unmap (mfro, &amp;mfro_map);
 4523     gst_buffer_unref (mfro);
 4524   }
 4525   if (mfra) {
 4526     if (mfra_map.memory != NULL)
 4527       gst_buffer_unmap (mfra, &amp;mfra_map);
 4528     gst_buffer_unref (mfra);
<span class="line-modified"> 4529   }</span>
 4530   return ret;
 4531 
 4532 /* ERRORS */
 4533 size_query_failed:
<span class="line-modified"> 4534   {</span>
 4535     GST_WARNING_OBJECT (qtdemux, &quot;could not query upstream size&quot;);
 4536     goto exit;
 4537   }
 4538 invalid_mfro_size:
 4539   {
 4540     GST_WARNING_OBJECT (qtdemux, &quot;mfro size is too small&quot;);
 4541     goto exit;
 4542   }
 4543 invalid_mfra_size:
 4544   {
 4545     GST_WARNING_OBJECT (qtdemux, &quot;mfra_size in mfro box is invalid&quot;);
 4546     goto exit;
 4547   }
 4548 broken_file:
 4549   {
 4550     GST_WARNING_OBJECT (qtdemux, &quot;bogus mfra offset or size, broken file&quot;);
<span class="line-modified"> 4551     goto exit;</span>

 4552   }
<span class="line-added"> 4553 }</span>
 4554 
 4555 static guint64
 4556 add_offset (guint64 offset, guint64 advance)
 4557 {
 4558   /* Avoid 64-bit overflow by clamping */
 4559   if (offset &gt; G_MAXUINT64 - advance)
 4560     return G_MAXUINT64;
 4561   return offset + advance;
<span class="line-modified"> 4562 }</span>
 4563 
 4564 static GstFlowReturn
 4565 gst_qtdemux_loop_state_header (GstQTDemux * qtdemux)
 4566 {
 4567   guint64 length = 0;
 4568   guint32 fourcc = 0;
 4569   GstBuffer *buf = NULL;
 4570   GstFlowReturn ret = GST_FLOW_OK;
 4571   guint64 cur_offset = qtdemux-&gt;offset;
 4572   GstMapInfo map;
 4573 
 4574   ret = gst_pad_pull_range (qtdemux-&gt;sinkpad, cur_offset, 16, &amp;buf);
 4575   if (G_UNLIKELY (ret != GST_FLOW_OK))
 4576     goto beach;
 4577   gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 4578   if (G_LIKELY (map.size &gt;= 8))
 4579     extract_initial_length_and_fourcc (map.data, map.size, &amp;length, &amp;fourcc);
 4580   gst_buffer_unmap (buf, &amp;map);
 4581   gst_buffer_unref (buf);
 4582 
</pre>
<hr />
<pre>
 4748       GST_LOG_OBJECT (qtdemux,
 4749           &quot;unknown %08x &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39; of size %&quot; G_GUINT64_FORMAT
 4750           &quot; at %&quot; G_GUINT64_FORMAT, fourcc, GST_FOURCC_ARGS (fourcc), length,
 4751           cur_offset);
 4752       ret = gst_qtdemux_pull_atom (qtdemux, cur_offset, length, &amp;unknown);
 4753       if (ret != GST_FLOW_OK)
 4754         goto beach;
 4755       gst_buffer_map (unknown, &amp;map, GST_MAP_READ);
 4756       GST_MEMDUMP (&quot;Unknown tag&quot;, map.data, map.size);
 4757       gst_buffer_unmap (unknown, &amp;map);
 4758       gst_buffer_unref (unknown);
 4759       qtdemux-&gt;offset += length;
 4760       break;
 4761     }
 4762   }
 4763 
 4764 beach:
 4765   if (ret == GST_FLOW_EOS &amp;&amp; (qtdemux-&gt;got_moov || qtdemux-&gt;media_caps)) {
 4766     /* digested all data, show what we have */
 4767     qtdemux_prepare_streams (qtdemux);
<span class="line-added"> 4768     QTDEMUX_EXPOSE_LOCK (qtdemux);</span>
 4769     ret = qtdemux_expose_streams (qtdemux);
<span class="line-added"> 4770     QTDEMUX_EXPOSE_UNLOCK (qtdemux);</span>
 4771 
 4772     qtdemux-&gt;state = QTDEMUX_STATE_MOVIE;
 4773     GST_DEBUG_OBJECT (qtdemux, &quot;switching state to STATE_MOVIE (%d)&quot;,
 4774         qtdemux-&gt;state);
 4775     return ret;
 4776   }
 4777   return ret;
 4778 }
 4779 
 4780 /* Seeks to the previous keyframe of the indexed stream and
 4781  * aligns other streams with respect to the keyframe timestamp
 4782  * of indexed stream. Only called in case of Reverse Playback
 4783  */
 4784 static GstFlowReturn
 4785 gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
 4786 {

 4787   guint32 seg_idx = 0, k_index = 0;
 4788   guint32 ref_seg_idx, ref_k_index;
 4789   GstClockTime k_pos = 0, last_stop = 0;
 4790   QtDemuxSegment *seg = NULL;
 4791   QtDemuxStream *ref_str = NULL;
 4792   guint64 seg_media_start_mov;  /* segment media start time in mov format */
 4793   guint64 target_ts;
<span class="line-added"> 4794   gint i;</span>
 4795 
 4796   /* Now we choose an arbitrary stream, get the previous keyframe timestamp
 4797    * and finally align all the other streams on that timestamp with their
 4798    * respective keyframes */
<span class="line-modified"> 4799   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 4800     QtDemuxStream *str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 4801 
 4802     /* No candidate yet, take the first stream */
 4803     if (!ref_str) {
 4804       ref_str = str;
 4805       continue;
 4806     }
 4807 
 4808     /* So that stream has a segment, we prefer video streams */
 4809     if (str-&gt;subtype == FOURCC_vide) {
 4810       ref_str = str;
 4811       break;
 4812     }
 4813   }
 4814 
 4815   if (G_UNLIKELY (!ref_str)) {
 4816     GST_DEBUG_OBJECT (qtdemux, &quot;couldn&#39;t find any stream&quot;);
 4817     goto eos;
 4818   }
 4819 
 4820   if (G_UNLIKELY (!ref_str-&gt;from_sample)) {
</pre>
<hr />
<pre>
 4828   if (ref_str-&gt;subtype == FOURCC_vide) {
 4829     k_index = gst_qtdemux_find_keyframe (qtdemux, ref_str,
 4830         ref_str-&gt;from_sample - 1, FALSE);
 4831   } else {
 4832     if (ref_str-&gt;from_sample &gt;= 10)
 4833       k_index = ref_str-&gt;from_sample - 10;
 4834     else
 4835       k_index = 0;
 4836   }
 4837 
 4838   target_ts =
 4839       ref_str-&gt;samples[k_index].timestamp +
 4840       ref_str-&gt;samples[k_index].pts_offset;
 4841 
 4842   /* get current segment for that stream */
 4843   seg = &amp;ref_str-&gt;segments[ref_str-&gt;segment_index];
 4844   /* Use segment start in original timescale for comparisons */
 4845   seg_media_start_mov = seg-&gt;trak_media_start;
 4846 
 4847   GST_LOG_OBJECT (qtdemux, &quot;keyframe index %u ts %&quot; G_GUINT64_FORMAT
<span class="line-modified"> 4848       &quot; seg start %&quot; G_GUINT64_FORMAT &quot; %&quot; GST_TIME_FORMAT,</span>
 4849       k_index, target_ts, seg_media_start_mov,
 4850       GST_TIME_ARGS (seg-&gt;media_start));
 4851 
 4852   /* Crawl back through segments to find the one containing this I frame */
 4853   while (target_ts &lt; seg_media_start_mov) {
 4854     GST_DEBUG_OBJECT (qtdemux,
 4855         &quot;keyframe position (sample %u) is out of segment %u &quot; &quot; target %&quot;
 4856         G_GUINT64_FORMAT &quot; seg start %&quot; G_GUINT64_FORMAT, k_index,
 4857         ref_str-&gt;segment_index, target_ts, seg_media_start_mov);
 4858 
 4859     if (G_UNLIKELY (!ref_str-&gt;segment_index)) {
 4860       /* Reached first segment, let&#39;s consider it&#39;s EOS */
 4861       goto eos;
 4862     }
 4863     ref_str-&gt;segment_index--;
 4864     seg = &amp;ref_str-&gt;segments[ref_str-&gt;segment_index];
 4865     /* Use segment start in original timescale for comparisons */
 4866     seg_media_start_mov = seg-&gt;trak_media_start;
 4867   }
 4868   /* Calculate time position of the keyframe and where we should stop */
</pre>
<hr />
<pre>
 4875       seg-&gt;trak_media_start) + seg-&gt;time;
 4876 
 4877   GST_DEBUG_OBJECT (qtdemux, &quot;preferred stream played from sample %u, &quot;
 4878       &quot;now going to sample %u (pts %&quot; GST_TIME_FORMAT &quot;)&quot;, ref_str-&gt;from_sample,
 4879       k_index, GST_TIME_ARGS (k_pos));
 4880 
 4881   /* Set last_stop with the keyframe timestamp we pushed of that stream */
 4882   qtdemux-&gt;segment.position = last_stop;
 4883   GST_DEBUG_OBJECT (qtdemux, &quot;last_stop now is %&quot; GST_TIME_FORMAT,
 4884       GST_TIME_ARGS (last_stop));
 4885 
 4886   if (G_UNLIKELY (last_stop &lt; qtdemux-&gt;segment.start)) {
 4887     GST_DEBUG_OBJECT (qtdemux, &quot;reached the beginning of segment&quot;);
 4888     goto eos;
 4889   }
 4890 
 4891   ref_seg_idx = ref_str-&gt;segment_index;
 4892   ref_k_index = k_index;
 4893 
 4894   /* Align them all on this */
<span class="line-modified"> 4895   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
 4896     guint32 index = 0;
 4897     GstClockTime seg_time = 0;
<span class="line-modified"> 4898     QtDemuxStream *str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 4899 
 4900     /* aligning reference stream again might lead to backing up to yet another
 4901      * keyframe (due to timestamp rounding issues),
 4902      * potentially putting more load on downstream; so let&#39;s try to avoid */
 4903     if (str == ref_str) {
 4904       seg_idx = ref_seg_idx;
 4905       seg = &amp;str-&gt;segments[seg_idx];
 4906       k_index = ref_k_index;
<span class="line-modified"> 4907       GST_DEBUG_OBJECT (qtdemux, &quot;reference track-id %u segment %d, &quot;</span>
<span class="line-modified"> 4908           &quot;sample at index %d&quot;, str-&gt;track_id, ref_str-&gt;segment_index, k_index);</span>
 4909     } else {
 4910       seg_idx = gst_qtdemux_find_segment (qtdemux, str, k_pos);
 4911       GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified"> 4912           &quot;track-id %u align segment %d for keyframe pos %&quot; GST_TIME_FORMAT,</span>
<span class="line-modified"> 4913           str-&gt;track_id, seg_idx, GST_TIME_ARGS (k_pos));</span>
 4914 
 4915       /* get segment and time in the segment */
 4916       seg = &amp;str-&gt;segments[seg_idx];
 4917       seg_time = k_pos - seg-&gt;time;
 4918 
 4919       /* get the media time in the segment.
 4920        * No adjustment for empty &quot;filler&quot; segments */
 4921       if (seg-&gt;media_start != GST_CLOCK_TIME_NONE)
 4922         seg_time += seg-&gt;media_start;
 4923 
 4924       /* get the index of the sample with media time */
 4925       index = gst_qtdemux_find_index_linear (qtdemux, str, seg_time);
 4926       GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified"> 4927           &quot;track-id %u sample for %&quot; GST_TIME_FORMAT &quot; at %u&quot;, str-&gt;track_id,</span>
 4928           GST_TIME_ARGS (seg_time), index);
 4929 
 4930       /* find previous keyframe */
 4931       k_index = gst_qtdemux_find_keyframe (qtdemux, str, index, FALSE);
 4932     }
 4933 
 4934     /* Remember until where we want to go */
 4935     str-&gt;to_sample = str-&gt;from_sample - 1;
 4936     /* Define our time position */
 4937     target_ts =
 4938         str-&gt;samples[k_index].timestamp + str-&gt;samples[k_index].pts_offset;
 4939     str-&gt;time_position = QTSTREAMTIME_TO_GSTTIME (str, target_ts) + seg-&gt;time;
 4940     if (seg-&gt;media_start != GST_CLOCK_TIME_NONE)
 4941       str-&gt;time_position -= seg-&gt;media_start;
 4942 
 4943     /* Now seek back in time */
 4944     gst_qtdemux_move_stream (qtdemux, str, k_index);
<span class="line-modified"> 4945     GST_DEBUG_OBJECT (qtdemux, &quot;track-id %u keyframe at %u, time position %&quot;</span>
<span class="line-modified"> 4946         GST_TIME_FORMAT &quot; playing from sample %u to %u&quot;, str-&gt;track_id, k_index,</span>
 4947         GST_TIME_ARGS (str-&gt;time_position), str-&gt;from_sample, str-&gt;to_sample);
 4948   }
 4949 
 4950   return GST_FLOW_OK;
 4951 
 4952 eos:
 4953   return GST_FLOW_EOS;
 4954 }
 4955 
 4956 /*
 4957  * Gets the current qt segment start, stop and position for the
 4958  * given time offset. This is used in update_segment()
 4959  */
 4960 static void
 4961 gst_qtdemux_stream_segment_get_boundaries (GstQTDemux * qtdemux,
 4962     QtDemuxStream * stream, GstClockTime offset,
 4963     GstClockTime * _start, GstClockTime * _stop, GstClockTime * _time)
 4964 {
 4965   GstClockTime seg_time;
 4966   GstClockTime start, stop, time;
</pre>
<hr />
<pre>
 5136    * tfra entries tells us which trun/sample the key unit is in, but we don&#39;t
 5137    * make use of this additional information at the moment) */
 5138   if (qtdemux-&gt;fragmented &amp;&amp; !qtdemux-&gt;fragmented_seek_pending) {
 5139     stream-&gt;to_sample = G_MAXUINT32;
 5140     return TRUE;
 5141   } else {
 5142     /* well, it will be taken care of below */
 5143     qtdemux-&gt;fragmented_seek_pending = FALSE;
 5144     /* FIXME ideally the do_fragmented_seek can be done right here,
 5145      * rather than at loop level
 5146      * (which might even allow handling edit lists in a fragmented file) */
 5147   }
 5148 
 5149   /* We don&#39;t need to look for a sample in push-based */
 5150   if (!qtdemux-&gt;pullbased)
 5151     return TRUE;
 5152 
 5153   /* and move to the keyframe before the indicated media time of the
 5154    * segment */
 5155   if (G_LIKELY (!QTSEGMENT_IS_EMPTY (segment))) {
<span class="line-modified"> 5156     if (qtdemux-&gt;segment.rate &gt;= 0) {</span>
<span class="line-modified"> 5157       index = gst_qtdemux_find_index_linear (qtdemux, stream, start);</span>
<span class="line-modified"> 5158       stream-&gt;to_sample = G_MAXUINT32;</span>
 5159       GST_DEBUG_OBJECT (stream-&gt;pad,
 5160           &quot;moving data pointer to %&quot; GST_TIME_FORMAT &quot;, index: %u, pts %&quot;
 5161           GST_TIME_FORMAT, GST_TIME_ARGS (start), index,
 5162           GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[index])));
<span class="line-modified"> 5163     } else {</span>
<span class="line-modified"> 5164       index = gst_qtdemux_find_index_linear (qtdemux, stream, stop);</span>
<span class="line-modified"> 5165       stream-&gt;to_sample = index;</span>
 5166       GST_DEBUG_OBJECT (stream-&gt;pad,
 5167           &quot;moving data pointer to %&quot; GST_TIME_FORMAT &quot;, index: %u, pts %&quot;
 5168           GST_TIME_FORMAT, GST_TIME_ARGS (stop), index,
 5169           GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[index])));
<span class="line-modified"> 5170     }</span>
 5171   } else {
 5172     GST_DEBUG_OBJECT (stream-&gt;pad, &quot;No need to look for keyframe, &quot;
 5173         &quot;this is an empty segment&quot;);
 5174     return TRUE;
 5175   }
 5176 
 5177   /* gst_qtdemux_parse_sample () called from gst_qtdemux_find_index_linear ()
 5178    * encountered an error and printed a message so we return appropriately */
 5179   if (index == -1)
 5180     return FALSE;
 5181 
 5182   /* we&#39;re at the right spot */
 5183   if (index == stream-&gt;sample_index) {
 5184     GST_DEBUG_OBJECT (stream-&gt;pad, &quot;we are at the right index&quot;);
 5185     return TRUE;
 5186   }
 5187 
 5188   /* find keyframe of the target index */
 5189   kf_index = gst_qtdemux_find_keyframe (qtdemux, stream, index, FALSE);
 5190 
</pre>
<hr />
<pre>
 5239   GstClockTime time_position;
 5240   guint32 seg_idx;
 5241 
 5242   g_return_val_if_fail (stream != NULL, FALSE);
 5243 
 5244   time_position = stream-&gt;time_position;
 5245   if (G_UNLIKELY (time_position == GST_CLOCK_TIME_NONE))
 5246     goto eos;
 5247 
 5248   seg_idx = stream-&gt;segment_index;
 5249   if (G_UNLIKELY (seg_idx == -1)) {
 5250     /* find segment corresponding to time_position if we are looking
 5251      * for a segment. */
 5252     seg_idx = gst_qtdemux_find_segment (qtdemux, stream, time_position);
 5253   }
 5254 
 5255   /* different segment, activate it, sample_index will be set. */
 5256   if (G_UNLIKELY (stream-&gt;segment_index != seg_idx))
 5257     gst_qtdemux_activate_segment (qtdemux, stream, seg_idx, time_position);
 5258 
<span class="line-modified"> 5259   if (G_UNLIKELY (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;</span>
<span class="line-modified"> 5260               segments[stream-&gt;segment_index]))) {</span>
 5261     QtDemuxSegment *seg = &amp;stream-&gt;segments[stream-&gt;segment_index];
 5262 
 5263     GST_LOG_OBJECT (qtdemux, &quot;Empty segment activated,&quot;
 5264         &quot; prepare empty sample&quot;);
 5265 
 5266     *empty = TRUE;
 5267     *pts = *dts = time_position;
 5268     *duration = seg-&gt;duration - (time_position - seg-&gt;time);
 5269 
 5270     return TRUE;
 5271   }
 5272 
 5273   *empty = FALSE;
 5274 
 5275   if (stream-&gt;sample_index == -1)
 5276     stream-&gt;sample_index = 0;
 5277 
 5278   GST_LOG_OBJECT (qtdemux, &quot;segment active, index = %u of %u&quot;,
 5279       stream-&gt;sample_index, stream-&gt;n_samples);
 5280 
 5281   if (G_UNLIKELY (stream-&gt;sample_index &gt;= stream-&gt;n_samples)) {
 5282     if (!qtdemux-&gt;fragmented)
<span class="line-modified"> 5283       goto eos;</span>
 5284 
 5285     GST_INFO_OBJECT (qtdemux, &quot;out of samples, trying to add more&quot;);
 5286     do {
 5287       GstFlowReturn flow;
 5288 
 5289       GST_OBJECT_LOCK (qtdemux);
 5290       flow = qtdemux_add_fragmented_samples (qtdemux);
 5291       GST_OBJECT_UNLOCK (qtdemux);
 5292 
 5293       if (flow != GST_FLOW_OK)
 5294         goto eos;
 5295     }
 5296     while (stream-&gt;sample_index &gt;= stream-&gt;n_samples);
 5297   }
 5298 
 5299   if (!qtdemux_parse_samples (qtdemux, stream, stream-&gt;sample_index)) {
 5300     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;,
 5301         stream-&gt;sample_index);
 5302     return FALSE;
 5303   }
</pre>
<hr />
<pre>
 5394       /* else we&#39;re only at the end of the current segment */
 5395       stream-&gt;time_position = segment-&gt;stop_time;
 5396     }
 5397     /* make sure we select a new segment */
 5398 
 5399     /* accumulate previous segments */
 5400     if (GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.stop))
 5401       stream-&gt;accumulated_base +=
 5402           (stream-&gt;segment.stop -
 5403           stream-&gt;segment.start) / ABS (stream-&gt;segment.rate);
 5404 
 5405     stream-&gt;segment_index = -1;
 5406   }
 5407 }
 5408 
 5409 static void
 5410 gst_qtdemux_sync_streams (GstQTDemux * demux)
 5411 {
 5412   gint i;
 5413 
<span class="line-modified"> 5414   if (QTDEMUX_N_STREAMS (demux) &lt;= 1)</span>
 5415     return;
 5416 
<span class="line-modified"> 5417   for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
 5418     QtDemuxStream *stream;
 5419     GstClockTime end_time;
 5420 
<span class="line-modified"> 5421     stream = QTDEMUX_NTH_STREAM (demux, i);</span>
 5422 
 5423     if (!stream-&gt;pad)
 5424       continue;
 5425 
 5426     /* TODO advance time on subtitle streams here, if any some day */
 5427 
 5428     /* some clips/trailers may have unbalanced streams at the end,
 5429      * so send EOS on shorter stream to prevent stalling others */
 5430 
 5431     /* do not mess with EOS if SEGMENT seeking */
 5432     if (demux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT)
 5433       continue;
 5434 
 5435     if (demux-&gt;pullbased) {
 5436       /* loop mode is sample time based */
 5437       if (!STREAM_IS_EOS (stream))
 5438         continue;
 5439     } else {
 5440       /* push mode is byte position based */
 5441       if (stream-&gt;n_samples &amp;&amp;
</pre>
<hr />
<pre>
 5464       gst_pad_push_event (stream-&gt;pad, event);
 5465     }
 5466   }
 5467 }
 5468 
 5469 /* EOS and NOT_LINKED need to be combined. This means that we return:
 5470  *
 5471  *  GST_FLOW_NOT_LINKED: when all pads NOT_LINKED.
 5472  *  GST_FLOW_EOS: when all pads EOS or NOT_LINKED.
 5473  */
 5474 static GstFlowReturn
 5475 gst_qtdemux_combine_flows (GstQTDemux * demux, QtDemuxStream * stream,
 5476     GstFlowReturn ret)
 5477 {
 5478   GST_LOG_OBJECT (demux, &quot;flow return: %s&quot;, gst_flow_get_name (ret));
 5479 
 5480   if (stream-&gt;pad)
 5481     ret = gst_flow_combiner_update_pad_flow (demux-&gt;flowcombiner, stream-&gt;pad,
 5482         ret);
 5483   else
<span class="line-modified"> 5484     ret = gst_flow_combiner_update_flow (demux-&gt;flowcombiner, ret);</span>
 5485 
 5486   GST_LOG_OBJECT (demux, &quot;combined flow return: %s&quot;, gst_flow_get_name (ret));
 5487   return ret;
 5488 }
 5489 
 5490 /* the input buffer metadata must be writable. Returns NULL when the buffer is
 5491  * completely clipped
 5492  *
 5493  * Should be used only with raw buffers */
 5494 static GstBuffer *
 5495 gst_qtdemux_clip_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
 5496     GstBuffer * buf)
 5497 {
 5498   guint64 start, stop, cstart, cstop, diff;
 5499   GstClockTime pts, duration;
 5500   gsize size, osize;
 5501   gint num_rate, denom_rate;
 5502   gint frame_size;
 5503   gboolean clip_data;
 5504   guint offset;
</pre>
<hr />
<pre>
 5511     frame_size = CUR_STREAM (stream)-&gt;bytes_per_frame;
 5512     num_rate = GST_SECOND;
 5513     denom_rate = (gint) CUR_STREAM (stream)-&gt;rate;
 5514     clip_data = TRUE;
 5515   } else if (stream-&gt;subtype == FOURCC_vide) {
 5516     frame_size = size;
 5517     num_rate = CUR_STREAM (stream)-&gt;fps_n;
 5518     denom_rate = CUR_STREAM (stream)-&gt;fps_d;
 5519     clip_data = FALSE;
 5520   } else
 5521     goto wrong_type;
 5522 
 5523   if (frame_size &lt;= 0)
 5524     goto bad_frame_size;
 5525 
 5526   /* we can only clip if we have a valid pts */
 5527   pts = GST_BUFFER_PTS (buf);
 5528   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pts)))
 5529     goto no_pts;
 5530 
<span class="line-modified"> 5531   duration = GST_BUFFER_DURATION (buf);</span>
 5532 
 5533   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (duration))) {
 5534     duration =
 5535         gst_util_uint64_scale_int (size / frame_size, num_rate, denom_rate);
 5536   }
 5537 
 5538   start = pts;
 5539   stop = start + duration;
 5540 
 5541   if (G_UNLIKELY (!gst_segment_clip (&amp;stream-&gt;segment,
 5542               GST_FORMAT_TIME, start, stop, &amp;cstart, &amp;cstop)))
 5543     goto clipped;
 5544 
 5545   /* see if some clipping happened */
 5546   diff = cstart - start;
 5547   if (diff &gt; 0) {
 5548     pts += diff;
 5549     duration -= diff;
 5550 
 5551     if (clip_data) {
</pre>
<hr />
<pre>
 5630         gst_buffer_get_size (buffer), &amp;params);
 5631 
 5632     /* Copy data &quot;by hand&quot;, so ensure alignment is kept: */
 5633     gst_buffer_fill (new_buffer, 0, map.data, map.size);
 5634 
 5635     gst_buffer_copy_into (new_buffer, buffer, GST_BUFFER_COPY_METADATA, 0, -1);
 5636     GST_DEBUG_OBJECT (demux,
 5637         &quot;We want output aligned on %&quot; G_GSIZE_FORMAT &quot;, reallocated&quot;,
 5638         alignment);
 5639 
 5640     gst_buffer_unmap (buffer, &amp;map);
 5641     gst_buffer_unref (buffer);
 5642 
 5643     return new_buffer;
 5644   }
 5645 
 5646   gst_buffer_unmap (buffer, &amp;map);
 5647   return buffer;
 5648 }
 5649 
<span class="line-added"> 5650 static guint8 *</span>
<span class="line-added"> 5651 convert_to_s334_1a (const guint8 * ccpair, guint8 ccpair_size, guint field,</span>
<span class="line-added"> 5652     gsize * res)</span>
<span class="line-added"> 5653 {</span>
<span class="line-added"> 5654   guint8 *storage;</span>
<span class="line-added"> 5655   gsize i;</span>
<span class="line-added"> 5656 </span>
<span class="line-added"> 5657   /* We are converting from pairs to triplets */</span>
<span class="line-added"> 5658   *res = ccpair_size / 2 * 3;</span>
<span class="line-added"> 5659   storage = g_malloc (*res);</span>
<span class="line-added"> 5660   for (i = 0; i * 2 &lt; ccpair_size; i += 1) {</span>
<span class="line-added"> 5661     /* FIXME: Use line offset 0 as we simply can&#39;t know here */</span>
<span class="line-added"> 5662     if (field == 1)</span>
<span class="line-added"> 5663       storage[i * 3] = 0x80 | 0x00;</span>
<span class="line-added"> 5664     else</span>
<span class="line-added"> 5665       storage[i * 3] = 0x00 | 0x00;</span>
<span class="line-added"> 5666     storage[i * 3 + 1] = ccpair[i * 2];</span>
<span class="line-added"> 5667     storage[i * 3 + 2] = ccpair[i * 2 + 1];</span>
<span class="line-added"> 5668   }</span>
<span class="line-added"> 5669 </span>
<span class="line-added"> 5670   return storage;</span>
<span class="line-added"> 5671 }</span>
<span class="line-added"> 5672 </span>
<span class="line-added"> 5673 static guint8 *</span>
<span class="line-added"> 5674 extract_cc_from_data (QtDemuxStream * stream, const guint8 * data, gsize size,</span>
<span class="line-added"> 5675     gsize * cclen)</span>
<span class="line-added"> 5676 {</span>
<span class="line-added"> 5677   guint8 *res = NULL;</span>
<span class="line-added"> 5678   guint32 atom_length, fourcc;</span>
<span class="line-added"> 5679   QtDemuxStreamStsdEntry *stsd_entry;</span>
<span class="line-added"> 5680 </span>
<span class="line-added"> 5681   GST_MEMDUMP (&quot;caption atom&quot;, data, size);</span>
<span class="line-added"> 5682 </span>
<span class="line-added"> 5683   /* There might be multiple atoms */</span>
<span class="line-added"> 5684 </span>
<span class="line-added"> 5685   *cclen = 0;</span>
<span class="line-added"> 5686   if (size &lt; 8)</span>
<span class="line-added"> 5687     goto invalid_cdat;</span>
<span class="line-added"> 5688   atom_length = QT_UINT32 (data);</span>
<span class="line-added"> 5689   fourcc = QT_FOURCC (data + 4);</span>
<span class="line-added"> 5690   if (G_UNLIKELY (atom_length &gt; size || atom_length == 8))</span>
<span class="line-added"> 5691     goto invalid_cdat;</span>
<span class="line-added"> 5692 </span>
<span class="line-added"> 5693   GST_DEBUG_OBJECT (stream-&gt;pad, &quot;here&quot;);</span>
<span class="line-added"> 5694 </span>
<span class="line-added"> 5695   /* Check if we have somethig compatible */</span>
<span class="line-added"> 5696   stsd_entry = CUR_STREAM (stream);</span>
<span class="line-added"> 5697   switch (stsd_entry-&gt;fourcc) {</span>
<span class="line-added"> 5698     case FOURCC_c608:{</span>
<span class="line-added"> 5699       guint8 *cdat = NULL, *cdt2 = NULL;</span>
<span class="line-added"> 5700       gsize cdat_size = 0, cdt2_size = 0;</span>
<span class="line-added"> 5701       /* Should be cdat or cdt2 */</span>
<span class="line-added"> 5702       if (fourcc != FOURCC_cdat &amp;&amp; fourcc != FOURCC_cdt2) {</span>
<span class="line-added"> 5703         GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added"> 5704             &quot;Unknown data atom (%&quot; GST_FOURCC_FORMAT &quot;) for CEA608&quot;,</span>
<span class="line-added"> 5705             GST_FOURCC_ARGS (fourcc));</span>
<span class="line-added"> 5706         goto invalid_cdat;</span>
<span class="line-added"> 5707       }</span>
<span class="line-added"> 5708 </span>
<span class="line-added"> 5709       /* Convert to S334-1 Annex A byte triplet */</span>
<span class="line-added"> 5710       if (fourcc == FOURCC_cdat)</span>
<span class="line-added"> 5711         cdat = convert_to_s334_1a (data + 8, atom_length - 8, 1, &amp;cdat_size);</span>
<span class="line-added"> 5712       else</span>
<span class="line-added"> 5713         cdt2 = convert_to_s334_1a (data + 8, atom_length - 8, 2, &amp;cdt2_size);</span>
<span class="line-added"> 5714       GST_DEBUG_OBJECT (stream-&gt;pad, &quot;size:%&quot; G_GSIZE_FORMAT &quot; atom_length:%u&quot;,</span>
<span class="line-added"> 5715           size, atom_length);</span>
<span class="line-added"> 5716 </span>
<span class="line-added"> 5717       /* Check for another atom ? */</span>
<span class="line-added"> 5718       if (size &gt; atom_length + 8) {</span>
<span class="line-added"> 5719         guint32 new_atom_length = QT_UINT32 (data + atom_length);</span>
<span class="line-added"> 5720         if (size &gt;= atom_length + new_atom_length) {</span>
<span class="line-added"> 5721           fourcc = QT_FOURCC (data + atom_length + 4);</span>
<span class="line-added"> 5722           if (fourcc == FOURCC_cdat) {</span>
<span class="line-added"> 5723             if (cdat == NULL)</span>
<span class="line-added"> 5724               cdat =</span>
<span class="line-added"> 5725                   convert_to_s334_1a (data + atom_length + 8,</span>
<span class="line-added"> 5726                   new_atom_length - 8, 1, &amp;cdat_size);</span>
<span class="line-added"> 5727             else</span>
<span class="line-added"> 5728               GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added"> 5729                   &quot;Got multiple [cdat] atoms in a c608 sample. This is unsupported for now. Please file a bug&quot;);</span>
<span class="line-added"> 5730           } else {</span>
<span class="line-added"> 5731             if (cdt2 == NULL)</span>
<span class="line-added"> 5732               cdt2 =</span>
<span class="line-added"> 5733                   convert_to_s334_1a (data + atom_length + 8,</span>
<span class="line-added"> 5734                   new_atom_length - 8, 2, &amp;cdt2_size);</span>
<span class="line-added"> 5735             else</span>
<span class="line-added"> 5736               GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added"> 5737                   &quot;Got multiple [cdt2] atoms in a c608 sample. This is unsupported for now. Please file a bug&quot;);</span>
<span class="line-added"> 5738           }</span>
<span class="line-added"> 5739         }</span>
<span class="line-added"> 5740       }</span>
<span class="line-added"> 5741 </span>
<span class="line-added"> 5742       *cclen = cdat_size + cdt2_size;</span>
<span class="line-added"> 5743       res = g_malloc (*cclen);</span>
<span class="line-added"> 5744       if (cdat_size)</span>
<span class="line-added"> 5745         memcpy (res, cdat, cdat_size);</span>
<span class="line-added"> 5746       if (cdt2_size)</span>
<span class="line-added"> 5747         memcpy (res + cdat_size, cdt2, cdt2_size);</span>
<span class="line-added"> 5748       g_free (cdat);</span>
<span class="line-added"> 5749       g_free (cdt2);</span>
<span class="line-added"> 5750     }</span>
<span class="line-added"> 5751       break;</span>
<span class="line-added"> 5752     case FOURCC_c708:</span>
<span class="line-added"> 5753       if (fourcc != FOURCC_ccdp) {</span>
<span class="line-added"> 5754         GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added"> 5755             &quot;Unknown data atom (%&quot; GST_FOURCC_FORMAT &quot;) for CEA708&quot;,</span>
<span class="line-added"> 5756             GST_FOURCC_ARGS (fourcc));</span>
<span class="line-added"> 5757         goto invalid_cdat;</span>
<span class="line-added"> 5758       }</span>
<span class="line-added"> 5759       *cclen = atom_length - 8;</span>
<span class="line-added"> 5760       res = g_memdup (data + 8, *cclen);</span>
<span class="line-added"> 5761       break;</span>
<span class="line-added"> 5762     default:</span>
<span class="line-added"> 5763       /* Keep this here in case other closed caption formats are added */</span>
<span class="line-added"> 5764       g_assert_not_reached ();</span>
<span class="line-added"> 5765       break;</span>
<span class="line-added"> 5766   }</span>
<span class="line-added"> 5767 </span>
<span class="line-added"> 5768   GST_MEMDUMP (&quot;Output&quot;, res, *cclen);</span>
<span class="line-added"> 5769   return res;</span>
<span class="line-added"> 5770 </span>
<span class="line-added"> 5771   /* Errors */</span>
<span class="line-added"> 5772 invalid_cdat:</span>
<span class="line-added"> 5773   GST_WARNING (&quot;[cdat] atom is too small or invalid&quot;);</span>
<span class="line-added"> 5774   return NULL;</span>
<span class="line-added"> 5775 }</span>
<span class="line-added"> 5776 </span>
 5777 /* the input buffer metadata must be writable,
 5778  * but time/duration etc not yet set and need not be preserved */
 5779 static GstBuffer *
 5780 gst_qtdemux_process_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
 5781     GstBuffer * buf)
 5782 {
 5783   GstMapInfo map;
 5784   guint nsize = 0;
 5785   gchar *str;
 5786 
 5787   /* not many cases for now */
 5788   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;fourcc == FOURCC_mp4s)) {
 5789     /* send a one time dvd clut event */
 5790     if (stream-&gt;pending_event &amp;&amp; stream-&gt;pad)
 5791       gst_pad_push_event (stream-&gt;pad, stream-&gt;pending_event);
 5792     stream-&gt;pending_event = NULL;
 5793   }
 5794 
 5795   if (G_UNLIKELY (stream-&gt;subtype != FOURCC_text
 5796           &amp;&amp; stream-&gt;subtype != FOURCC_sbtl &amp;&amp;
<span class="line-modified"> 5797           stream-&gt;subtype != FOURCC_subp &amp;&amp; stream-&gt;subtype != FOURCC_clcp)) {</span>
 5798     return buf;
 5799   }
 5800 
 5801   gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 5802 
 5803   /* empty buffer is sent to terminate previous subtitle */
 5804   if (map.size &lt;= 2) {
 5805     gst_buffer_unmap (buf, &amp;map);
 5806     gst_buffer_unref (buf);
 5807     return NULL;
 5808   }
 5809   if (stream-&gt;subtype == FOURCC_subp) {
 5810     /* That&#39;s all the processing needed for subpictures */
 5811     gst_buffer_unmap (buf, &amp;map);
 5812     return buf;
 5813   }
 5814 
<span class="line-added"> 5815   if (stream-&gt;subtype == FOURCC_clcp) {</span>
<span class="line-added"> 5816     guint8 *cc;</span>
<span class="line-added"> 5817     gsize cclen = 0;</span>
<span class="line-added"> 5818     /* For closed caption, we need to extract the information from the</span>
<span class="line-added"> 5819      * [cdat],[cdt2] or [ccdp] atom */</span>
<span class="line-added"> 5820     cc = extract_cc_from_data (stream, map.data, map.size, &amp;cclen);</span>
<span class="line-added"> 5821     gst_buffer_unmap (buf, &amp;map);</span>
<span class="line-added"> 5822     gst_buffer_unref (buf);</span>
<span class="line-added"> 5823     if (cc) {</span>
<span class="line-added"> 5824       buf = _gst_buffer_new_wrapped (cc, cclen, g_free);</span>
<span class="line-added"> 5825     } else {</span>
<span class="line-added"> 5826       /* Conversion failed or there&#39;s nothing */</span>
<span class="line-added"> 5827       buf = NULL;</span>
<span class="line-added"> 5828     }</span>
<span class="line-added"> 5829     return buf;</span>
<span class="line-added"> 5830   }</span>
<span class="line-added"> 5831 </span>
 5832   nsize = GST_READ_UINT16_BE (map.data);
 5833   nsize = MIN (nsize, map.size - 2);
 5834 
 5835   GST_LOG_OBJECT (qtdemux, &quot;3GPP timed text subtitle: %d/%&quot; G_GSIZE_FORMAT &quot;&quot;,
 5836       nsize, map.size);
 5837 
 5838   /* takes care of UTF-8 validation or UTF-16 recognition,
 5839    * no other encoding expected */
 5840   str = gst_tag_freeform_string_to_utf8 ((gchar *) map.data + 2, nsize, NULL);
 5841   gst_buffer_unmap (buf, &amp;map);
 5842   if (str) {
 5843     gst_buffer_unref (buf);
 5844     buf = _gst_buffer_new_wrapped (str, strlen (str), g_free);
 5845   } else {
 5846     /* this should not really happen unless the subtitle is corrupted */
 5847     gst_buffer_unref (buf);
 5848     buf = NULL;
 5849   }
 5850 
 5851   /* FIXME ? convert optional subsequent style info to markup */
 5852 
 5853   return buf;
 5854 }
 5855 
<span class="line-added"> 5856 static GstFlowReturn</span>
<span class="line-added"> 5857 gst_qtdemux_push_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,</span>
<span class="line-added"> 5858     GstBuffer * buf)</span>
<span class="line-added"> 5859 {</span>
<span class="line-added"> 5860   GstFlowReturn ret = GST_FLOW_OK;</span>
<span class="line-added"> 5861   GstClockTime pts, duration;</span>
<span class="line-added"> 5862 </span>
<span class="line-added"> 5863   if (stream-&gt;need_clip)</span>
<span class="line-added"> 5864     buf = gst_qtdemux_clip_buffer (qtdemux, stream, buf);</span>
<span class="line-added"> 5865 </span>
<span class="line-added"> 5866   if (G_UNLIKELY (buf == NULL))</span>
<span class="line-added"> 5867     goto exit;</span>
<span class="line-added"> 5868 </span>
<span class="line-added"> 5869   if (G_UNLIKELY (stream-&gt;discont)) {</span>
<span class="line-added"> 5870     GST_LOG_OBJECT (qtdemux, &quot;marking discont buffer&quot;);</span>
<span class="line-added"> 5871     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-added"> 5872     stream-&gt;discont = FALSE;</span>
<span class="line-added"> 5873   } else {</span>
<span class="line-added"> 5874     GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-added"> 5875   }</span>
<span class="line-added"> 5876 </span>
<span class="line-added"> 5877   GST_LOG_OBJECT (qtdemux,</span>
<span class="line-added"> 5878       &quot;Pushing buffer with dts %&quot; GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT</span>
<span class="line-added"> 5879       &quot;, duration %&quot; GST_TIME_FORMAT &quot; on pad %s&quot;,</span>
<span class="line-added"> 5880       GST_TIME_ARGS (GST_BUFFER_DTS (buf)),</span>
<span class="line-added"> 5881       GST_TIME_ARGS (GST_BUFFER_PTS (buf)),</span>
<span class="line-added"> 5882       GST_TIME_ARGS (GST_BUFFER_DURATION (buf)), GST_PAD_NAME (stream-&gt;pad));</span>
<span class="line-added"> 5883 </span>
<span class="line-added"> 5884   if (stream-&gt;protected &amp;&amp; stream-&gt;protection_scheme_type == FOURCC_cenc) {</span>
<span class="line-added"> 5885     GstStructure *crypto_info;</span>
<span class="line-added"> 5886     QtDemuxCencSampleSetInfo *info =</span>
<span class="line-added"> 5887         (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;</span>
<span class="line-added"> 5888     gint index;</span>
<span class="line-added"> 5889     GstEvent *event;</span>
<span class="line-added"> 5890 </span>
<span class="line-added"> 5891     while ((event = g_queue_pop_head (&amp;stream-&gt;protection_scheme_event_queue))) {</span>
<span class="line-added"> 5892       GST_TRACE_OBJECT (stream-&gt;pad, &quot;pushing protection event: %&quot;</span>
<span class="line-added"> 5893           GST_PTR_FORMAT, event);</span>
<span class="line-added"> 5894       gst_pad_push_event (stream-&gt;pad, event);</span>
<span class="line-added"> 5895     }</span>
<span class="line-added"> 5896 </span>
<span class="line-added"> 5897     if (info-&gt;crypto_info == NULL) {</span>
<span class="line-added"> 5898       GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added"> 5899           &quot;cenc metadata hasn&#39;t been parsed yet, pushing buffer as if it wasn&#39;t encrypted&quot;);</span>
<span class="line-added"> 5900     } else {</span>
<span class="line-added"> 5901       /* The end of the crypto_info array matches our n_samples position,</span>
<span class="line-added"> 5902        * so count backward from there */</span>
<span class="line-added"> 5903       index = stream-&gt;sample_index - stream-&gt;n_samples + info-&gt;crypto_info-&gt;len;</span>
<span class="line-added"> 5904       if (G_LIKELY (index &gt;= 0 &amp;&amp; index &lt; info-&gt;crypto_info-&gt;len)) {</span>
<span class="line-added"> 5905         /* steal structure from array */</span>
<span class="line-added"> 5906         crypto_info = g_ptr_array_index (info-&gt;crypto_info, index);</span>
<span class="line-added"> 5907         g_ptr_array_index (info-&gt;crypto_info, index) = NULL;</span>
<span class="line-added"> 5908         GST_LOG_OBJECT (qtdemux, &quot;attaching cenc metadata [%u/%u]&quot;, index,</span>
<span class="line-added"> 5909             info-&gt;crypto_info-&gt;len);</span>
<span class="line-added"> 5910         if (!crypto_info || !gst_buffer_add_protection_meta (buf, crypto_info))</span>
<span class="line-added"> 5911           GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added"> 5912               &quot;failed to attach cenc metadata to buffer&quot;);</span>
<span class="line-added"> 5913       } else {</span>
<span class="line-added"> 5914         GST_INFO_OBJECT (qtdemux, &quot;No crypto info with index %d and sample %d&quot;,</span>
<span class="line-added"> 5915             index, stream-&gt;sample_index);</span>
<span class="line-added"> 5916       }</span>
<span class="line-added"> 5917     }</span>
<span class="line-added"> 5918   }</span>
<span class="line-added"> 5919 </span>
<span class="line-added"> 5920   if (stream-&gt;alignment &gt; 1)</span>
<span class="line-added"> 5921     buf = gst_qtdemux_align_buffer (qtdemux, buf, stream-&gt;alignment);</span>
<span class="line-added"> 5922 </span>
<span class="line-added"> 5923   pts = GST_BUFFER_PTS (buf);</span>
<span class="line-added"> 5924   duration = GST_BUFFER_DURATION (buf);</span>
<span class="line-added"> 5925 </span>
<span class="line-added"> 5926   ret = gst_pad_push (stream-&gt;pad, buf);</span>
<span class="line-added"> 5927 </span>
<span class="line-added"> 5928   if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; GST_CLOCK_TIME_IS_VALID (duration)) {</span>
<span class="line-added"> 5929     /* mark position in stream, we&#39;ll need this to know when to send GAP event */</span>
<span class="line-added"> 5930     stream-&gt;segment.position = pts + duration;</span>
<span class="line-added"> 5931   }</span>
<span class="line-added"> 5932 </span>
<span class="line-added"> 5933 exit:</span>
<span class="line-added"> 5934 </span>
<span class="line-added"> 5935   return ret;</span>
<span class="line-added"> 5936 }</span>
<span class="line-added"> 5937 </span>
<span class="line-added"> 5938 static GstFlowReturn</span>
<span class="line-added"> 5939 gst_qtdemux_split_and_push_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,</span>
<span class="line-added"> 5940     GstBuffer * buf)</span>
<span class="line-added"> 5941 {</span>
<span class="line-added"> 5942   GstFlowReturn ret = GST_FLOW_OK;</span>
<span class="line-added"> 5943 </span>
<span class="line-added"> 5944   if (stream-&gt;subtype == FOURCC_clcp</span>
<span class="line-added"> 5945       &amp;&amp; CUR_STREAM (stream)-&gt;fourcc == FOURCC_c608 &amp;&amp; stream-&gt;need_split) {</span>
<span class="line-added"> 5946     GstMapInfo map;</span>
<span class="line-added"> 5947     guint n_output_buffers, n_field1 = 0, n_field2 = 0;</span>
<span class="line-added"> 5948     guint n_triplets, i;</span>
<span class="line-added"> 5949     guint field1_off = 0, field2_off = 0;</span>
<span class="line-added"> 5950 </span>
<span class="line-added"> 5951     /* We have to split CEA608 buffers so that each outgoing buffer contains</span>
<span class="line-added"> 5952      * one byte pair per field according to the framerate of the video track.</span>
<span class="line-added"> 5953      *</span>
<span class="line-added"> 5954      * If there is only a single byte pair per field we don&#39;t have to do</span>
<span class="line-added"> 5955      * anything</span>
<span class="line-added"> 5956      */</span>
<span class="line-added"> 5957 </span>
<span class="line-added"> 5958     gst_buffer_map (buf, &amp;map, GST_MAP_READ);</span>
<span class="line-added"> 5959 </span>
<span class="line-added"> 5960     n_triplets = map.size / 3;</span>
<span class="line-added"> 5961     for (i = 0; i &lt; n_triplets; i++) {</span>
<span class="line-added"> 5962       if (map.data[3 * i] &amp; 0x80)</span>
<span class="line-added"> 5963         n_field1++;</span>
<span class="line-added"> 5964       else</span>
<span class="line-added"> 5965         n_field2++;</span>
<span class="line-added"> 5966     }</span>
<span class="line-added"> 5967 </span>
<span class="line-added"> 5968     g_assert (n_field1 || n_field2);</span>
<span class="line-added"> 5969 </span>
<span class="line-added"> 5970     /* If there&#39;s more than 1 frame we have to split, otherwise we can just</span>
<span class="line-added"> 5971      * pass through */</span>
<span class="line-added"> 5972     if (n_field1 &gt; 1 || n_field2 &gt; 1) {</span>
<span class="line-added"> 5973       n_output_buffers =</span>
<span class="line-added"> 5974           gst_util_uint64_scale (GST_BUFFER_DURATION (buf),</span>
<span class="line-added"> 5975           CUR_STREAM (stream)-&gt;fps_n, GST_SECOND * CUR_STREAM (stream)-&gt;fps_d);</span>
<span class="line-added"> 5976 </span>
<span class="line-added"> 5977       for (i = 0; i &lt; n_output_buffers; i++) {</span>
<span class="line-added"> 5978         GstBuffer *outbuf =</span>
<span class="line-added"> 5979             gst_buffer_new_and_alloc ((n_field1 ? 3 : 0) + (n_field2 ? 3 : 0));</span>
<span class="line-added"> 5980         GstMapInfo outmap;</span>
<span class="line-added"> 5981         guint8 *outptr;</span>
<span class="line-added"> 5982 </span>
<span class="line-added"> 5983         gst_buffer_map (outbuf, &amp;outmap, GST_MAP_WRITE);</span>
<span class="line-added"> 5984         outptr = outmap.data;</span>
<span class="line-added"> 5985 </span>
<span class="line-added"> 5986         if (n_field1) {</span>
<span class="line-added"> 5987           gboolean found = FALSE;</span>
<span class="line-added"> 5988 </span>
<span class="line-added"> 5989           while (map.data + field1_off &lt; map.data + map.size) {</span>
<span class="line-added"> 5990             if (map.data[field1_off] &amp; 0x80) {</span>
<span class="line-added"> 5991               memcpy (outptr, &amp;map.data[field1_off], 3);</span>
<span class="line-added"> 5992               field1_off += 3;</span>
<span class="line-added"> 5993               found = TRUE;</span>
<span class="line-added"> 5994               break;</span>
<span class="line-added"> 5995             }</span>
<span class="line-added"> 5996             field1_off += 3;</span>
<span class="line-added"> 5997           }</span>
<span class="line-added"> 5998 </span>
<span class="line-added"> 5999           if (!found) {</span>
<span class="line-added"> 6000             const guint8 empty[] = { 0x80, 0x80, 0x80 };</span>
<span class="line-added"> 6001 </span>
<span class="line-added"> 6002             memcpy (outptr, empty, 3);</span>
<span class="line-added"> 6003           }</span>
<span class="line-added"> 6004 </span>
<span class="line-added"> 6005           outptr += 3;</span>
<span class="line-added"> 6006         }</span>
<span class="line-added"> 6007 </span>
<span class="line-added"> 6008         if (n_field2) {</span>
<span class="line-added"> 6009           gboolean found = FALSE;</span>
<span class="line-added"> 6010 </span>
<span class="line-added"> 6011           while (map.data + field2_off &lt; map.data + map.size) {</span>
<span class="line-added"> 6012             if ((map.data[field2_off] &amp; 0x80) == 0) {</span>
<span class="line-added"> 6013               memcpy (outptr, &amp;map.data[field2_off], 3);</span>
<span class="line-added"> 6014               field2_off += 3;</span>
<span class="line-added"> 6015               found = TRUE;</span>
<span class="line-added"> 6016               break;</span>
<span class="line-added"> 6017             }</span>
<span class="line-added"> 6018             field2_off += 3;</span>
<span class="line-added"> 6019           }</span>
<span class="line-added"> 6020 </span>
<span class="line-added"> 6021           if (!found) {</span>
<span class="line-added"> 6022             const guint8 empty[] = { 0x00, 0x80, 0x80 };</span>
<span class="line-added"> 6023 </span>
<span class="line-added"> 6024             memcpy (outptr, empty, 3);</span>
<span class="line-added"> 6025           }</span>
<span class="line-added"> 6026 </span>
<span class="line-added"> 6027           outptr += 3;</span>
<span class="line-added"> 6028         }</span>
<span class="line-added"> 6029 </span>
<span class="line-added"> 6030         gst_buffer_unmap (outbuf, &amp;outmap);</span>
<span class="line-added"> 6031 </span>
<span class="line-added"> 6032         GST_BUFFER_PTS (outbuf) =</span>
<span class="line-added"> 6033             GST_BUFFER_PTS (buf) + gst_util_uint64_scale (i,</span>
<span class="line-added"> 6034             GST_SECOND * CUR_STREAM (stream)-&gt;fps_d,</span>
<span class="line-added"> 6035             CUR_STREAM (stream)-&gt;fps_n);</span>
<span class="line-added"> 6036         GST_BUFFER_DURATION (outbuf) =</span>
<span class="line-added"> 6037             gst_util_uint64_scale (GST_SECOND, CUR_STREAM (stream)-&gt;fps_d,</span>
<span class="line-added"> 6038             CUR_STREAM (stream)-&gt;fps_n);</span>
<span class="line-added"> 6039         GST_BUFFER_OFFSET (outbuf) = -1;</span>
<span class="line-added"> 6040         GST_BUFFER_OFFSET_END (outbuf) = -1;</span>
<span class="line-added"> 6041 </span>
<span class="line-added"> 6042         ret = gst_qtdemux_push_buffer (qtdemux, stream, outbuf);</span>
<span class="line-added"> 6043 </span>
<span class="line-added"> 6044         if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_NOT_LINKED)</span>
<span class="line-added"> 6045           break;</span>
<span class="line-added"> 6046       }</span>
<span class="line-added"> 6047       gst_buffer_unmap (buf, &amp;map);</span>
<span class="line-added"> 6048       gst_buffer_unref (buf);</span>
<span class="line-added"> 6049     } else {</span>
<span class="line-added"> 6050       gst_buffer_unmap (buf, &amp;map);</span>
<span class="line-added"> 6051       ret = gst_qtdemux_push_buffer (qtdemux, stream, buf);</span>
<span class="line-added"> 6052     }</span>
<span class="line-added"> 6053   } else {</span>
<span class="line-added"> 6054     ret = gst_qtdemux_push_buffer (qtdemux, stream, buf);</span>
<span class="line-added"> 6055   }</span>
<span class="line-added"> 6056 </span>
<span class="line-added"> 6057   return ret;</span>
<span class="line-added"> 6058 }</span>
<span class="line-added"> 6059 </span>
 6060 /* Sets a buffer&#39;s attributes properly and pushes it downstream.
 6061  * Also checks for additional actions and custom processing that may
 6062  * need to be done first.
 6063  */
 6064 static GstFlowReturn
 6065 gst_qtdemux_decorate_and_push_buffer (GstQTDemux * qtdemux,
 6066     QtDemuxStream * stream, GstBuffer * buf,
 6067     GstClockTime dts, GstClockTime pts, GstClockTime duration,
 6068     gboolean keyframe, GstClockTime position, guint64 byte_position)
 6069 {
 6070   GstFlowReturn ret = GST_FLOW_OK;
 6071 
 6072   /* offset the timestamps according to the edit list */
 6073 
 6074   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;fourcc == FOURCC_rtsp)) {
 6075     gchar *url;
 6076     GstMapInfo map;
 6077 
 6078     gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 6079     url = g_strndup ((gchar *) map.data, map.size);
</pre>
<hr />
<pre>
 6122 
 6123     stream-&gt;buffers = g_slist_delete_link (stream-&gt;buffers, stream-&gt;buffers);
 6124   }
 6125 
 6126   /* we&#39;re going to modify the metadata */
 6127   buf = gst_buffer_make_writable (buf);
 6128 
 6129   if (G_UNLIKELY (stream-&gt;need_process))
 6130     buf = gst_qtdemux_process_buffer (qtdemux, stream, buf);
 6131 
 6132   if (!buf) {
 6133     goto exit;
 6134   }
 6135 
 6136   GST_BUFFER_DTS (buf) = dts;
 6137   GST_BUFFER_PTS (buf) = pts;
 6138   GST_BUFFER_DURATION (buf) = duration;
 6139   GST_BUFFER_OFFSET (buf) = -1;
 6140   GST_BUFFER_OFFSET_END (buf) = -1;
 6141 
<span class="line-added"> 6142   if (!keyframe) {</span>
<span class="line-added"> 6143     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);</span>
<span class="line-added"> 6144     stream-&gt;on_keyframe = FALSE;</span>
<span class="line-added"> 6145   } else {</span>
<span class="line-added"> 6146     stream-&gt;on_keyframe = TRUE;</span>
<span class="line-added"> 6147   }</span>
<span class="line-added"> 6148 </span>
 6149   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;rgb8_palette))
 6150     gst_buffer_append_memory (buf,
 6151         gst_memory_ref (CUR_STREAM (stream)-&gt;rgb8_palette));
 6152 
 6153   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;padding)) {
 6154     gst_buffer_resize (buf, CUR_STREAM (stream)-&gt;padding, -1);
 6155   }
 6156 #if 0
 6157   if (G_UNLIKELY (qtdemux-&gt;element_index)) {
 6158     GstClockTime stream_time;
 6159 
 6160     stream_time =
 6161         gst_segment_to_stream_time (&amp;stream-&gt;segment, GST_FORMAT_TIME,
 6162         timestamp);
 6163     if (GST_CLOCK_TIME_IS_VALID (stream_time)) {
 6164       GST_LOG_OBJECT (qtdemux,
 6165           &quot;adding association %&quot; GST_TIME_FORMAT &quot;-&gt; %&quot;
 6166           G_GUINT64_FORMAT, GST_TIME_ARGS (stream_time), byte_position);
 6167       gst_index_add_association (qtdemux-&gt;element_index,
 6168           qtdemux-&gt;index_id,
 6169           keyframe ? GST_ASSOCIATION_FLAG_KEY_UNIT :
 6170           GST_ASSOCIATION_FLAG_DELTA_UNIT, GST_FORMAT_TIME, stream_time,
 6171           GST_FORMAT_BYTES, byte_position, NULL);
 6172     }
 6173   }
 6174 #endif
 6175 
<span class="line-modified"> 6176   ret = gst_qtdemux_split_and_push_buffer (qtdemux, stream, buf);</span>






































































 6177 
 6178 exit:
 6179   return ret;
 6180 }
 6181 
 6182 static const QtDemuxRandomAccessEntry *
 6183 gst_qtdemux_stream_seek_fragment (GstQTDemux * qtdemux, QtDemuxStream * stream,
 6184     GstClockTime pos, gboolean after)
 6185 {
 6186   QtDemuxRandomAccessEntry *entries = stream-&gt;ra_entries;
 6187   guint n_entries = stream-&gt;n_ra_entries;
 6188   guint i;
 6189 
 6190   /* we assume the table is sorted */
 6191   for (i = 0; i &lt; n_entries; ++i) {
 6192     if (entries[i].ts &gt; pos)
 6193       break;
 6194   }
 6195 
 6196   /* FIXME: maybe save first moof_offset somewhere instead, but for now it&#39;s
 6197    * probably okay to assume that the index lists the very first fragment */
 6198   if (i == 0)
 6199     return &amp;entries[0];
 6200 
 6201   if (after)
 6202     return &amp;entries[i];
 6203   else
 6204     return &amp;entries[i - 1];
 6205 }
 6206 
 6207 static gboolean
 6208 gst_qtdemux_do_fragmented_seek (GstQTDemux * qtdemux)
 6209 {
 6210   const QtDemuxRandomAccessEntry *best_entry = NULL;
<span class="line-modified"> 6211   gint i;</span>
 6212 
 6213   GST_OBJECT_LOCK (qtdemux);
 6214 
<span class="line-modified"> 6215   g_assert (QTDEMUX_N_STREAMS (qtdemux) &gt; 0);</span>
 6216 
 6217   /* first see if we can determine where to go to using mfra,
 6218    * before we start clearing things */
<span class="line-modified"> 6219   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
 6220     const QtDemuxRandomAccessEntry *entry;
 6221     QtDemuxStream *stream;
 6222     gboolean is_audio_or_video;
 6223 
<span class="line-modified"> 6224     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 6225 
 6226     if (stream-&gt;ra_entries == NULL)
 6227       continue;
 6228 
 6229     if (stream-&gt;subtype == FOURCC_vide || stream-&gt;subtype == FOURCC_soun)
 6230       is_audio_or_video = TRUE;
 6231     else
 6232       is_audio_or_video = FALSE;
 6233 
 6234     entry =
 6235         gst_qtdemux_stream_seek_fragment (qtdemux, stream,
 6236         stream-&gt;time_position, !is_audio_or_video);
 6237 
 6238     GST_INFO_OBJECT (stream-&gt;pad, &quot;%&quot; GST_TIME_FORMAT &quot; at offset &quot;
 6239         &quot;%&quot; G_GUINT64_FORMAT, GST_TIME_ARGS (entry-&gt;ts), entry-&gt;moof_offset);
 6240 
 6241     stream-&gt;pending_seek = entry;
 6242 
 6243     /* decide position to jump to just based on audio/video tracks, not subs */
 6244     if (!is_audio_or_video)
 6245       continue;
 6246 
 6247     if (best_entry == NULL || entry-&gt;moof_offset &lt; best_entry-&gt;moof_offset)
 6248       best_entry = entry;
 6249   }
 6250 
 6251   /* no luck, will handle seek otherwise */
 6252   if (best_entry == NULL) {
 6253     GST_OBJECT_UNLOCK (qtdemux);
 6254     return FALSE;
 6255   }
 6256 
 6257   /* ok, now we can prepare for processing as of located moof */
<span class="line-modified"> 6258   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
 6259     QtDemuxStream *stream;
 6260 
<span class="line-modified"> 6261     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 6262 
 6263     g_free (stream-&gt;samples);
 6264     stream-&gt;samples = NULL;
 6265     stream-&gt;n_samples = 0;
 6266     stream-&gt;stbl_index = -1;    /* no samples have yet been parsed */
 6267     stream-&gt;sample_index = -1;
 6268 
 6269     if (stream-&gt;protection_scheme_info) {
 6270       /* Clear out any old cenc crypto info entries as we&#39;ll move to a new moof */
 6271       if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
 6272         QtDemuxCencSampleSetInfo *info =
 6273             (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
 6274         if (info-&gt;crypto_info) {
 6275           g_ptr_array_free (info-&gt;crypto_info, TRUE);
 6276           info-&gt;crypto_info = NULL;
 6277         }
 6278       }
 6279     }
 6280   }
 6281 
 6282   GST_INFO_OBJECT (qtdemux, &quot;seek to %&quot; GST_TIME_FORMAT &quot;, best fragment &quot;
 6283       &quot;moof offset: %&quot; G_GUINT64_FORMAT &quot;, ts %&quot; GST_TIME_FORMAT,
<span class="line-modified"> 6284       GST_TIME_ARGS (QTDEMUX_NTH_STREAM (qtdemux, 0)-&gt;time_position),</span>
 6285       best_entry-&gt;moof_offset, GST_TIME_ARGS (best_entry-&gt;ts));
 6286 
 6287   qtdemux-&gt;moof_offset = best_entry-&gt;moof_offset;
 6288 
 6289   qtdemux_add_fragmented_samples (qtdemux);
 6290 
 6291   GST_OBJECT_UNLOCK (qtdemux);
 6292   return TRUE;
 6293 }
 6294 
 6295 static GstFlowReturn
 6296 gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
 6297 {
 6298   GstFlowReturn ret = GST_FLOW_OK;
 6299   GstBuffer *buf = NULL;
<span class="line-modified"> 6300   QtDemuxStream *stream, *target_stream = NULL;</span>
 6301   GstClockTime min_time;
 6302   guint64 offset = 0;
 6303   GstClockTime dts = GST_CLOCK_TIME_NONE;
 6304   GstClockTime pts = GST_CLOCK_TIME_NONE;
 6305   GstClockTime duration = 0;
 6306   gboolean keyframe = FALSE;
 6307   guint sample_size = 0;
 6308   gboolean empty = 0;
 6309   guint size;

 6310   gint i;
 6311 


 6312   if (qtdemux-&gt;fragmented_seek_pending) {
 6313     GST_INFO_OBJECT (qtdemux, &quot;pending fragmented seek&quot;);
 6314     if (gst_qtdemux_do_fragmented_seek (qtdemux)) {
 6315       GST_INFO_OBJECT (qtdemux, &quot;fragmented seek done!&quot;);
 6316       qtdemux-&gt;fragmented_seek_pending = FALSE;
 6317     } else {
 6318       GST_INFO_OBJECT (qtdemux, &quot;fragmented seek still pending&quot;);
 6319     }
 6320   }
 6321 
 6322   /* Figure out the next stream sample to output, min_time is expressed in
 6323    * global time and runs over the edit list segments. */
 6324   min_time = G_MAXUINT64;
<span class="line-modified"> 6325   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>

 6326     GstClockTime position;
 6327 
<span class="line-modified"> 6328     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 6329     position = stream-&gt;time_position;
 6330 
 6331     /* position of -1 is EOS */
 6332     if (position != GST_CLOCK_TIME_NONE &amp;&amp; position &lt; min_time) {
 6333       min_time = position;
<span class="line-modified"> 6334       target_stream = stream;</span>
 6335     }
 6336   }
 6337   /* all are EOS */
<span class="line-modified"> 6338   if (G_UNLIKELY (target_stream == NULL)) {</span>
 6339     GST_DEBUG_OBJECT (qtdemux, &quot;all streams are EOS&quot;);
 6340     goto eos;
 6341   }
 6342 
 6343   /* check for segment end */
 6344   if (G_UNLIKELY (qtdemux-&gt;segment.stop != -1
 6345           &amp;&amp; ((qtdemux-&gt;segment.rate &gt;= 0 &amp;&amp; qtdemux-&gt;segment.stop &lt;= min_time)
 6346               || (qtdemux-&gt;segment.rate &lt; 0
 6347                   &amp;&amp; qtdemux-&gt;segment.start &gt; min_time))
<span class="line-modified"> 6348           &amp;&amp; target_stream-&gt;on_keyframe)) {</span>
 6349     GST_DEBUG_OBJECT (qtdemux, &quot;we reached the end of our segment.&quot;);
<span class="line-modified"> 6350     target_stream-&gt;time_position = GST_CLOCK_TIME_NONE;</span>
 6351     goto eos_stream;
 6352   }
 6353 
 6354   /* gap events for subtitle streams */
<span class="line-modified"> 6355   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 6356     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 6357     if (stream-&gt;pad &amp;&amp; (stream-&gt;subtype == FOURCC_subp
 6358             || stream-&gt;subtype == FOURCC_text
 6359             || stream-&gt;subtype == FOURCC_sbtl)) {
 6360       /* send one second gap events until the stream catches up */
 6361       /* gaps can only be sent after segment is activated (segment.stop is no longer -1) */
 6362       while (GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.stop) &amp;&amp;
 6363           GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.position) &amp;&amp;
 6364           stream-&gt;segment.position + GST_SECOND &lt; min_time) {
 6365         GstEvent *gap =
 6366             gst_event_new_gap (stream-&gt;segment.position, GST_SECOND);
 6367         gst_pad_push_event (stream-&gt;pad, gap);
 6368         stream-&gt;segment.position += GST_SECOND;
 6369       }
 6370     }
 6371   }
 6372 
<span class="line-modified"> 6373   stream = target_stream;</span>
 6374   /* fetch info for the current sample of this stream */
 6375   if (G_UNLIKELY (!gst_qtdemux_prepare_current_sample (qtdemux, stream, &amp;empty,
 6376               &amp;offset, &amp;sample_size, &amp;dts, &amp;pts, &amp;duration, &amp;keyframe)))
 6377     goto eos_stream;
 6378 
 6379   gst_qtdemux_stream_check_and_change_stsd_index (qtdemux, stream);
 6380   if (stream-&gt;new_caps) {
 6381     gst_qtdemux_configure_stream (qtdemux, stream);
<span class="line-modified"> 6382     qtdemux_do_allocation (stream, qtdemux);</span>
 6383   }
 6384 
 6385   /* If we&#39;re doing a keyframe-only trickmode, only push keyframes on video streams */
<span class="line-modified"> 6386   if (G_UNLIKELY (qtdemux-&gt;segment.</span>
<span class="line-modified"> 6387           flags &amp; GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS)) {</span>
 6388     if (stream-&gt;subtype == FOURCC_vide &amp;&amp; !keyframe) {
<span class="line-modified"> 6389       GST_LOG_OBJECT (qtdemux, &quot;Skipping non-keyframe on track-id %u&quot;,</span>
<span class="line-added"> 6390           stream-&gt;track_id);</span>
 6391       goto next;
 6392     }
 6393   }
 6394 
 6395   GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified"> 6396       &quot;pushing from track-id %u, empty %d offset %&quot; G_GUINT64_FORMAT</span>
 6397       &quot;, size %d, dts=%&quot; GST_TIME_FORMAT &quot;, pts=%&quot; GST_TIME_FORMAT
<span class="line-modified"> 6398       &quot;, duration %&quot; GST_TIME_FORMAT, stream-&gt;track_id, empty, offset,</span>
<span class="line-modified"> 6399       sample_size, GST_TIME_ARGS (dts), GST_TIME_ARGS (pts),</span>
<span class="line-added"> 6400       GST_TIME_ARGS (duration));</span>
 6401 
 6402   if (G_UNLIKELY (empty)) {
 6403     /* empty segment, push a gap if there&#39;s a second or more
 6404      * difference and move to the next one */
 6405     if ((pts + duration - stream-&gt;segment.position) &gt;= GST_SECOND)
<span class="line-modified"> 6406       gst_pad_push_event (stream-&gt;pad, gst_event_new_gap (pts, duration));</span>
 6407     stream-&gt;segment.position = pts + duration;
 6408     goto next;
 6409   }
 6410 
 6411   /* hmm, empty sample, skip and move to next sample */
 6412   if (G_UNLIKELY (sample_size &lt;= 0))
 6413     goto next;
 6414 
 6415   /* last pushed sample was out of boundary, goto next sample */
 6416   if (G_UNLIKELY (GST_PAD_LAST_FLOW_RETURN (stream-&gt;pad) == GST_FLOW_EOS))
 6417     goto next;
 6418 
 6419   if (stream-&gt;max_buffer_size == 0 || sample_size &lt;= stream-&gt;max_buffer_size) {
 6420     size = sample_size;
 6421   } else {
 6422     GST_DEBUG_OBJECT (qtdemux,
 6423         &quot;size %d larger than stream max_buffer_size %d, trimming&quot;,
 6424         sample_size, stream-&gt;max_buffer_size);
 6425     size =
 6426         MIN (sample_size - stream-&gt;offset_in_sample, stream-&gt;max_buffer_size);
</pre>
<hr />
<pre>
 6576   /* ERRORS */
 6577 invalid_state:
 6578   {
 6579     GST_ELEMENT_ERROR (qtdemux, STREAM, FAILED,
 6580         (NULL), (&quot;streaming stopped, invalid state&quot;));
 6581     gst_pad_pause_task (pad);
 6582     gst_qtdemux_push_event (qtdemux, gst_event_new_eos ());
 6583     goto done;
 6584   }
 6585 pause:
 6586   {
 6587     const gchar *reason = gst_flow_get_name (ret);
 6588 
 6589     GST_LOG_OBJECT (qtdemux, &quot;pausing task, reason %s&quot;, reason);
 6590 
 6591     gst_pad_pause_task (pad);
 6592 
 6593     /* fatal errors need special actions */
 6594     /* check EOS */
 6595     if (ret == GST_FLOW_EOS) {
<span class="line-modified"> 6596       if (QTDEMUX_N_STREAMS (qtdemux) == 0) {</span>
 6597         /* we have no streams, post an error */
 6598         gst_qtdemux_post_no_playable_stream_error (qtdemux);
 6599       }
 6600       if (qtdemux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 6601         gint64 stop;
 6602 
 6603         if ((stop = qtdemux-&gt;segment.stop) == -1)
 6604           stop = qtdemux-&gt;segment.duration;
 6605 
 6606         if (qtdemux-&gt;segment.rate &gt;= 0) {
 6607           GstMessage *message;
 6608           GstEvent *event;
 6609 
 6610           GST_LOG_OBJECT (qtdemux, &quot;Sending segment done, at end of segment&quot;);
 6611           message = gst_message_new_segment_done (GST_OBJECT_CAST (qtdemux),
 6612               GST_FORMAT_TIME, stop);
 6613           event = gst_event_new_segment_done (GST_FORMAT_TIME, stop);
 6614           if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID) {
 6615             gst_message_set_seqnum (message, qtdemux-&gt;segment_seqnum);
 6616             gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
 6617           }
 6618           gst_element_post_message (GST_ELEMENT_CAST (qtdemux), message);
 6619           gst_qtdemux_push_event (qtdemux, event);
 6620         } else {
 6621           GstMessage *message;
 6622           GstEvent *event;
 6623 
 6624           /*  For Reverse Playback */
 6625           GST_LOG_OBJECT (qtdemux, &quot;Sending segment done, at start of segment&quot;);
 6626           message = gst_message_new_segment_done (GST_OBJECT_CAST (qtdemux),
 6627               GST_FORMAT_TIME, qtdemux-&gt;segment.start);
 6628           event = gst_event_new_segment_done (GST_FORMAT_TIME,
 6629               qtdemux-&gt;segment.start);
 6630           if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID) {
 6631             gst_message_set_seqnum (message, qtdemux-&gt;segment_seqnum);
 6632             gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
<span class="line-modified"> 6633           }</span>
 6634           gst_element_post_message (GST_ELEMENT_CAST (qtdemux), message);
 6635           gst_qtdemux_push_event (qtdemux, event);
 6636         }
 6637       } else {
 6638         GstEvent *event;
 6639 
 6640         GST_LOG_OBJECT (qtdemux, &quot;Sending EOS at end of segment&quot;);
 6641         event = gst_event_new_eos ();
 6642         if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID)
 6643           gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
 6644         gst_qtdemux_push_event (qtdemux, event);
 6645       }
 6646     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
 6647       GST_ELEMENT_FLOW_ERROR (qtdemux, ret);
 6648       gst_qtdemux_push_event (qtdemux, gst_event_new_eos ());
 6649     }
 6650     goto done;
 6651   }
 6652 }
 6653 
 6654 /*
 6655  * has_next_entry
 6656  *
 6657  * Returns if there are samples to be played.
 6658  */
 6659 static gboolean
 6660 has_next_entry (GstQTDemux * demux)
 6661 {
 6662   QtDemuxStream *stream;
<span class="line-modified"> 6663   gint i;</span>
 6664 
 6665   GST_DEBUG_OBJECT (demux, &quot;Checking if there are samples not played yet&quot;);
 6666 
<span class="line-modified"> 6667   for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 6668     stream = QTDEMUX_NTH_STREAM (demux, i);</span>
 6669 
 6670     if (stream-&gt;sample_index == -1) {
 6671       stream-&gt;sample_index = 0;
 6672       stream-&gt;offset_in_sample = 0;
 6673     }
 6674 
 6675     if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {
<span class="line-modified"> 6676       GST_LOG_OBJECT (demux, &quot;track-id %u samples exhausted&quot;, stream-&gt;track_id);</span>
 6677       continue;
 6678     }
 6679     GST_DEBUG_OBJECT (demux, &quot;Found a sample&quot;);
 6680     return TRUE;
 6681   }
 6682 
 6683   GST_DEBUG_OBJECT (demux, &quot;There wasn&#39;t any next sample&quot;);
 6684   return FALSE;
 6685 }
 6686 
 6687 /*
 6688  * next_entry_size
 6689  *
 6690  * Returns the size of the first entry at the current offset.
 6691  * If -1, there are none (which means EOS or empty file).
 6692  */
 6693 static guint64
 6694 next_entry_size (GstQTDemux * demux)
 6695 {
<span class="line-modified"> 6696   QtDemuxStream *stream, *target_stream = NULL;</span>


 6697   guint64 smalloffs = (guint64) - 1;
 6698   QtDemuxSample *sample;
<span class="line-added"> 6699   gint i;</span>
 6700 
 6701   GST_LOG_OBJECT (demux, &quot;Finding entry at offset %&quot; G_GUINT64_FORMAT,
 6702       demux-&gt;offset);
 6703 
<span class="line-modified"> 6704   for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 6705     stream = QTDEMUX_NTH_STREAM (demux, i);</span>
 6706 
 6707     if (stream-&gt;sample_index == -1) {
 6708       stream-&gt;sample_index = 0;
 6709       stream-&gt;offset_in_sample = 0;
 6710     }
 6711 
 6712     if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {
<span class="line-modified"> 6713       GST_LOG_OBJECT (demux, &quot;track-id %u samples exhausted&quot;, stream-&gt;track_id);</span>
 6714       continue;
 6715     }
 6716 
 6717     if (!qtdemux_parse_samples (demux, stream, stream-&gt;sample_index)) {
 6718       GST_LOG_OBJECT (demux, &quot;Parsing of index %u from stbl atom failed!&quot;,
 6719           stream-&gt;sample_index);
 6720       return -1;
 6721     }
 6722 
 6723     sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 6724 
 6725     GST_LOG_OBJECT (demux,
<span class="line-modified"> 6726         &quot;Checking track-id %u (sample_index:%d / offset:%&quot; G_GUINT64_FORMAT</span>
<span class="line-modified"> 6727         &quot; / size:%&quot; G_GUINT32_FORMAT &quot;)&quot;, stream-&gt;track_id,</span>
<span class="line-modified"> 6728         stream-&gt;sample_index, sample-&gt;offset, sample-&gt;size);</span>
 6729 
 6730     if (((smalloffs == -1)
 6731             || (sample-&gt;offset &lt; smalloffs)) &amp;&amp; (sample-&gt;size)) {

 6732       smalloffs = sample-&gt;offset;
<span class="line-added"> 6733       target_stream = stream;</span>
 6734     }
 6735   }
 6736 
<span class="line-modified"> 6737   if (!target_stream)</span>




 6738     return -1;
 6739 
<span class="line-modified"> 6740   GST_LOG_OBJECT (demux,</span>
<span class="line-added"> 6741       &quot;track-id %u offset %&quot; G_GUINT64_FORMAT &quot; demux-&gt;offset :%&quot;</span>
<span class="line-added"> 6742       G_GUINT64_FORMAT, target_stream-&gt;track_id, smalloffs, demux-&gt;offset);</span>
<span class="line-added"> 6743 </span>
<span class="line-added"> 6744   stream = target_stream;</span>
 6745   sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 6746 
 6747   if (sample-&gt;offset &gt;= demux-&gt;offset) {
 6748     demux-&gt;todrop = sample-&gt;offset - demux-&gt;offset;
 6749     return sample-&gt;size + demux-&gt;todrop;
 6750   }
 6751 
 6752   GST_DEBUG_OBJECT (demux,
 6753       &quot;There wasn&#39;t any entry at offset %&quot; G_GUINT64_FORMAT, demux-&gt;offset);
 6754   return -1;
 6755 }
 6756 
 6757 static void
 6758 gst_qtdemux_post_progress (GstQTDemux * demux, gint num, gint denom)
 6759 {
 6760   gint perc = (gint) ((gdouble) num * 100.0 / (gdouble) denom);
 6761 
 6762   gst_element_post_message (GST_ELEMENT_CAST (demux),
 6763       gst_message_new_element (GST_OBJECT_CAST (demux),
 6764           gst_structure_new (&quot;progress&quot;, &quot;percent&quot;, G_TYPE_INT, perc, NULL)));
</pre>
<hr />
<pre>
 6824   gst_query_unref (query);
 6825 
 6826   GST_DEBUG_OBJECT (demux, &quot;seekable: %d (%&quot; G_GUINT64_FORMAT &quot; - %&quot;
 6827       G_GUINT64_FORMAT &quot;)&quot;, seekable, start, stop);
 6828   demux-&gt;upstream_seekable = seekable;
 6829   demux-&gt;upstream_size = seekable ? stop : -1;
 6830 }
 6831 
 6832 static void
 6833 gst_qtdemux_drop_data (GstQTDemux * demux, gint bytes)
 6834 {
 6835   g_return_if_fail (bytes &lt;= demux-&gt;todrop);
 6836 
 6837   GST_LOG_OBJECT (demux, &quot;Dropping %d bytes&quot;, bytes);
 6838   gst_adapter_flush (demux-&gt;adapter, bytes);
 6839   demux-&gt;neededbytes -= bytes;
 6840   demux-&gt;offset += bytes;
 6841   demux-&gt;todrop -= bytes;
 6842 }
 6843 
<span class="line-added"> 6844 /* PUSH-MODE only: Send a segment, if not done already. */</span>
 6845 static void
 6846 gst_qtdemux_check_send_pending_segment (GstQTDemux * demux)
 6847 {
<span class="line-modified"> 6848   if (G_UNLIKELY (demux-&gt;need_segment)) {</span>
 6849     gint i;
 6850 
<span class="line-modified"> 6851     if (!demux-&gt;upstream_format_is_time) {</span>
<span class="line-added"> 6852       gst_qtdemux_map_and_push_segments (demux, &amp;demux-&gt;segment);</span>
<span class="line-added"> 6853     } else {</span>
<span class="line-added"> 6854       GstEvent *segment_event;</span>
<span class="line-added"> 6855       segment_event = gst_event_new_segment (&amp;demux-&gt;segment);</span>
<span class="line-added"> 6856       if (demux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added"> 6857         gst_event_set_seqnum (segment_event, demux-&gt;segment_seqnum);</span>
<span class="line-added"> 6858       gst_qtdemux_push_event (demux, segment_event);</span>
<span class="line-added"> 6859     }</span>
<span class="line-added"> 6860 </span>
<span class="line-added"> 6861     demux-&gt;need_segment = FALSE;</span>
<span class="line-added"> 6862 </span>
 6863     /* clear to send tags on all streams */
<span class="line-modified"> 6864     for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 6865       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (demux, i);</span>

 6866       gst_qtdemux_push_tags (demux, stream);
 6867       if (CUR_STREAM (stream)-&gt;sparse) {
 6868         GST_INFO_OBJECT (demux, &quot;Sending gap event on stream %d&quot;, i);
 6869         gst_pad_push_event (stream-&gt;pad,
 6870             gst_event_new_gap (stream-&gt;segment.position, GST_CLOCK_TIME_NONE));
 6871       }
 6872     }
 6873   }
 6874 }
 6875 
<span class="line-added"> 6876 /* Used for push mode only. */</span>
 6877 static void
 6878 gst_qtdemux_send_gap_for_segment (GstQTDemux * demux,
 6879     QtDemuxStream * stream, gint segment_index, GstClockTime pos)
 6880 {
 6881   GstClockTime ts, dur;

 6882 
 6883   ts = pos;
 6884   dur =
 6885       stream-&gt;segments[segment_index].duration - (pos -
 6886       stream-&gt;segments[segment_index].time);

 6887   stream-&gt;time_position += dur;
 6888 
<span class="line-modified"> 6889   /* Only gaps with a duration of at least one second are propagated.</span>
<span class="line-modified"> 6890    * Same workaround as in pull mode.</span>
<span class="line-modified"> 6891    * (See 2e45926a96ec5298c6ef29bf912e5e6a06dc3e0e) */</span>
<span class="line-modified"> 6892   if (dur &gt;= GST_SECOND) {</span>
<span class="line-modified"> 6893     GstEvent *gap;</span>
<span class="line-modified"> 6894     gap = gst_event_new_gap (ts, dur);</span>









 6895 
<span class="line-modified"> 6896     GST_DEBUG_OBJECT (stream-&gt;pad, &quot;Pushing gap for empty &quot;</span>
<span class="line-modified"> 6897         &quot;segment: %&quot; GST_PTR_FORMAT, gap);</span>
<span class="line-modified"> 6898     gst_pad_push_event (stream-&gt;pad, gap);</span>







 6899   }
 6900 }
 6901 
 6902 static GstFlowReturn
 6903 gst_qtdemux_chain (GstPad * sinkpad, GstObject * parent, GstBuffer * inbuf)
 6904 {
 6905   GstQTDemux *demux;
 6906 
 6907   demux = GST_QTDEMUX (parent);
 6908 
 6909   GST_DEBUG_OBJECT (demux,
 6910       &quot;Received buffer pts:%&quot; GST_TIME_FORMAT &quot; dts:%&quot; GST_TIME_FORMAT
 6911       &quot; offset:%&quot; G_GUINT64_FORMAT &quot; size:%&quot; G_GSIZE_FORMAT &quot; demux offset:%&quot;
 6912       G_GUINT64_FORMAT, GST_TIME_ARGS (GST_BUFFER_PTS (inbuf)),
 6913       GST_TIME_ARGS (GST_BUFFER_DTS (inbuf)), GST_BUFFER_OFFSET (inbuf),
 6914       gst_buffer_get_size (inbuf), demux-&gt;offset);
 6915 
 6916   if (GST_BUFFER_FLAG_IS_SET (inbuf, GST_BUFFER_FLAG_DISCONT)) {
 6917     gboolean is_gap_input = FALSE;
 6918     gint i;
 6919 
 6920     GST_DEBUG_OBJECT (demux, &quot;Got DISCONT, marking all streams as DISCONT&quot;);
 6921 
<span class="line-modified"> 6922     for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 6923       QTDEMUX_NTH_STREAM (demux, i)-&gt;discont = TRUE;</span>
 6924     }
 6925 
 6926     /* Check if we can land back on our feet in the case where upstream is
 6927      * handling the seeking/pushing of samples with gaps in between (like
 6928      * in the case of trick-mode DASH for example) */
 6929     if (demux-&gt;upstream_format_is_time
 6930         &amp;&amp; GST_BUFFER_OFFSET (inbuf) != GST_BUFFER_OFFSET_NONE) {
<span class="line-modified"> 6931       for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>

 6932         guint32 res;
<span class="line-added"> 6933         QtDemuxStream *stream = QTDEMUX_NTH_STREAM (demux, i);</span>
 6934         GST_LOG_OBJECT (demux,
<span class="line-modified"> 6935             &quot;track-id #%u , checking if offset %&quot; G_GUINT64_FORMAT</span>
<span class="line-modified"> 6936             &quot; is a sample start&quot;, stream-&gt;track_id, GST_BUFFER_OFFSET (inbuf));</span>
 6937         res =
 6938             gst_qtdemux_find_index_for_given_media_offset_linear (demux,
<span class="line-modified"> 6939             stream, GST_BUFFER_OFFSET (inbuf));</span>
 6940         if (res != -1) {
<span class="line-modified"> 6941           QtDemuxSample *sample = &amp;stream-&gt;samples[res];</span>
 6942           GST_LOG_OBJECT (demux,
<span class="line-modified"> 6943               &quot;Checking if sample %d from track-id %u is valid (offset:%&quot;</span>
<span class="line-modified"> 6944               G_GUINT64_FORMAT &quot; size:%&quot; G_GUINT32_FORMAT &quot;)&quot;, res,</span>
<span class="line-modified"> 6945               stream-&gt;track_id, sample-&gt;offset, sample-&gt;size);</span>
 6946           if (sample-&gt;offset == GST_BUFFER_OFFSET (inbuf)) {
 6947             GST_LOG_OBJECT (demux,
 6948                 &quot;new buffer corresponds to a valid sample : %&quot; G_GUINT32_FORMAT,
 6949                 res);
 6950             is_gap_input = TRUE;
 6951             /* We can go back to standard playback mode */
 6952             demux-&gt;state = QTDEMUX_STATE_MOVIE;
 6953             /* Remember which sample this stream is at */
<span class="line-modified"> 6954             stream-&gt;sample_index = res;</span>
 6955             /* Finally update all push-based values to the expected values */
<span class="line-modified"> 6956             demux-&gt;neededbytes = stream-&gt;samples[res].size;</span>
 6957             demux-&gt;offset = GST_BUFFER_OFFSET (inbuf);
 6958             demux-&gt;mdatleft =
 6959                 demux-&gt;mdatsize - demux-&gt;offset + demux-&gt;mdatoffset;
 6960             demux-&gt;todrop = 0;
 6961           }
 6962         }
 6963       }
 6964       if (!is_gap_input) {
 6965         GST_DEBUG_OBJECT (demux, &quot;Resetting, actual DISCONT&quot;);
 6966         /* Reset state if it&#39;s a real discont */
 6967         demux-&gt;neededbytes = 16;
 6968         demux-&gt;state = QTDEMUX_STATE_INITIAL;
 6969         demux-&gt;offset = GST_BUFFER_OFFSET (inbuf);
 6970         gst_adapter_clear (demux-&gt;adapter);
 6971       }
 6972     }
 6973     /* Reverse fragmented playback, need to flush all we have before
 6974      * consuming a new fragment.
 6975      * The samples array have the timestamps calculated by accumulating the
 6976      * durations but this won&#39;t work for reverse playback of fragments as
 6977      * the timestamps of a subsequent fragment should be smaller than the
 6978      * previously received one. */
 6979     if (!is_gap_input &amp;&amp; demux-&gt;fragmented &amp;&amp; demux-&gt;segment.rate &lt; 0) {
 6980       gst_qtdemux_process_adapter (demux, TRUE);
<span class="line-modified"> 6981       g_ptr_array_foreach (demux-&gt;active_streams,</span>
<span class="line-modified"> 6982           (GFunc) gst_qtdemux_stream_flush_samples_data, NULL);</span>
 6983     }
 6984   }
 6985 
 6986   gst_adapter_push (demux-&gt;adapter, inbuf);
 6987 
 6988   GST_DEBUG_OBJECT (demux,
 6989       &quot;pushing in inbuf %p, neededbytes:%u, available:%&quot; G_GSIZE_FORMAT, inbuf,
 6990       demux-&gt;neededbytes, gst_adapter_available (demux-&gt;adapter));
 6991 
 6992   return gst_qtdemux_process_adapter (demux, FALSE);
 6993 }
 6994 
 6995 static GstFlowReturn
 6996 gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
 6997 {
 6998   GstFlowReturn ret = GST_FLOW_OK;
 6999 
 7000   /* we never really mean to buffer that much */
 7001   if (demux-&gt;neededbytes == -1) {
 7002     goto eos;
 7003   }
 7004 
 7005   while (((gst_adapter_available (demux-&gt;adapter)) &gt;= demux-&gt;neededbytes) &amp;&amp;
 7006       (ret == GST_FLOW_OK || (ret == GST_FLOW_NOT_LINKED &amp;&amp; force))) {
 7007 
 7008 #ifndef GST_DISABLE_GST_DEBUG
 7009     {
 7010       guint64 discont_offset, distance_from_discont;
 7011 
 7012       discont_offset = gst_adapter_offset_at_discont (demux-&gt;adapter);
 7013       distance_from_discont =
 7014           gst_adapter_distance_from_discont (demux-&gt;adapter);
 7015 
<span class="line-modified"> 7016       GST_DEBUG_OBJECT (demux,</span>
 7017           &quot;state:%s , demux-&gt;neededbytes:%d, demux-&gt;offset:%&quot; G_GUINT64_FORMAT
 7018           &quot; adapter offset :%&quot; G_GUINT64_FORMAT &quot; (+ %&quot; G_GUINT64_FORMAT
 7019           &quot; bytes)&quot;, qt_demux_state_string (demux-&gt;state), demux-&gt;neededbytes,
 7020           demux-&gt;offset, discont_offset, distance_from_discont);
 7021     }
 7022 #endif
 7023 
 7024     switch (demux-&gt;state) {
 7025       case QTDEMUX_STATE_INITIAL:{
 7026         const guint8 *data;
 7027         guint32 fourcc;
 7028         guint64 size;
 7029 
 7030         gst_qtdemux_check_seekability (demux);
 7031 
 7032         data = gst_adapter_map (demux-&gt;adapter, demux-&gt;neededbytes);
 7033 
 7034         /* get fourcc/length, set neededbytes */
 7035         extract_initial_length_and_fourcc ((guint8 *) data, demux-&gt;neededbytes,
 7036             &amp;size, &amp;fourcc);
 7037         gst_adapter_unmap (demux-&gt;adapter);
 7038         data = NULL;
 7039         GST_DEBUG_OBJECT (demux, &quot;Peeking found [%&quot; GST_FOURCC_FORMAT &quot;] &quot;
 7040             &quot;size: %&quot; G_GUINT64_FORMAT, GST_FOURCC_ARGS (fourcc), size);
 7041         if (size == 0) {
 7042           GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
 7043               (_(&quot;This file is invalid and cannot be played.&quot;)),
 7044               (&quot;initial atom &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39; has empty length&quot;,
 7045                   GST_FOURCC_ARGS (fourcc)));
 7046           ret = GST_FLOW_ERROR;
 7047           break;
 7048         }
 7049         if (fourcc == FOURCC_mdat) {
 7050           gint next_entry = next_entry_size (demux);
<span class="line-modified"> 7051           if (QTDEMUX_N_STREAMS (demux) &gt; 0 &amp;&amp; (next_entry != -1</span>
<span class="line-added"> 7052                   || !demux-&gt;fragmented)) {</span>
 7053             /* we have the headers, start playback */
 7054             demux-&gt;state = QTDEMUX_STATE_MOVIE;
 7055             demux-&gt;neededbytes = next_entry;
 7056             demux-&gt;mdatleft = size;
 7057             demux-&gt;mdatsize = demux-&gt;mdatleft;
 7058           } else {
 7059             /* no headers yet, try to get them */
 7060             guint bs;
 7061             gboolean res;
 7062             guint64 old, target;
 7063 
 7064           buffer_data:
 7065             old = demux-&gt;offset;
 7066             target = old + size;
 7067 
 7068             /* try to jump over the atom with a seek */
 7069             /* only bother if it seems worth doing so,
 7070              * and avoids possible upstream/server problems */
 7071             if (demux-&gt;upstream_seekable &amp;&amp;
 7072                 demux-&gt;upstream_size &gt; 4 * (1 &lt;&lt; 20)) {
<span class="line-modified"> 7073               res = qtdemux_seek_offset (demux, target);</span>
 7074             } else {
 7075               GST_DEBUG_OBJECT (demux, &quot;skipping seek&quot;);
 7076               res = FALSE;
 7077             }
 7078 
 7079             if (res) {
 7080               GST_DEBUG_OBJECT (demux, &quot;seek success&quot;);
 7081               /* remember the offset fo the first mdat so we can seek back to it
 7082                * after we have the headers */
 7083               if (fourcc == FOURCC_mdat &amp;&amp; demux-&gt;first_mdat == -1) {
 7084                 demux-&gt;first_mdat = old;
 7085                 GST_DEBUG_OBJECT (demux, &quot;first mdat at %&quot; G_GUINT64_FORMAT,
 7086                     demux-&gt;first_mdat);
 7087               }
 7088               /* seek worked, continue reading */
 7089               demux-&gt;offset = target;
 7090               demux-&gt;neededbytes = 16;
 7091               demux-&gt;state = QTDEMUX_STATE_INITIAL;
 7092             } else {
 7093               /* seek failed, need to buffer */
</pre>
<hr />
<pre>
 7120           if (demux-&gt;mdatbuffer &amp;&amp; !(fourcc == FOURCC_moov
 7121                   || fourcc == FOURCC_moof))
 7122             goto buffer_data;
 7123           demux-&gt;neededbytes = size;
 7124           demux-&gt;state = QTDEMUX_STATE_HEADER;
 7125         }
 7126         break;
 7127       }
 7128       case QTDEMUX_STATE_HEADER:{
 7129         const guint8 *data;
 7130         guint32 fourcc;
 7131 
 7132         GST_DEBUG_OBJECT (demux, &quot;In header&quot;);
 7133 
 7134         data = gst_adapter_map (demux-&gt;adapter, demux-&gt;neededbytes);
 7135 
 7136         /* parse the header */
 7137         extract_initial_length_and_fourcc (data, demux-&gt;neededbytes, NULL,
 7138             &amp;fourcc);
 7139         if (fourcc == FOURCC_moov) {


 7140           /* in usual fragmented setup we could try to scan for more
 7141            * and end up at the the moov (after mdat) again */
<span class="line-modified"> 7142           if (demux-&gt;got_moov &amp;&amp; QTDEMUX_N_STREAMS (demux) &gt; 0 &amp;&amp;</span>
 7143               (!demux-&gt;fragmented
 7144                   || demux-&gt;last_moov_offset == demux-&gt;offset)) {
 7145             GST_DEBUG_OBJECT (demux,
 7146                 &quot;Skipping moov atom as we have (this) one already&quot;);
 7147           } else {
<span class="line-modified"> 7148             GST_DEBUG_OBJECT (demux, &quot;Parsing [moov]&quot;);</span>
 7149 
 7150             if (demux-&gt;got_moov &amp;&amp; demux-&gt;fragmented) {
 7151               GST_DEBUG_OBJECT (demux,
 7152                   &quot;Got a second moov, clean up data from old one&quot;);
 7153               if (demux-&gt;moov_node_compressed) {
 7154                 g_node_destroy (demux-&gt;moov_node_compressed);
<span class="line-modified"> 7155                 if (demux-&gt;moov_node)</span>
 7156                   g_free (demux-&gt;moov_node-&gt;data);
 7157               }
 7158               demux-&gt;moov_node_compressed = NULL;
 7159               if (demux-&gt;moov_node)
 7160                 g_node_destroy (demux-&gt;moov_node);
 7161               demux-&gt;moov_node = NULL;









 7162             }
 7163 
 7164             demux-&gt;last_moov_offset = demux-&gt;offset;
 7165 
<span class="line-modified"> 7166             /* Update streams with new moov */</span>
<span class="line-modified"> 7167             gst_qtdemux_stream_concat (demux,</span>
<span class="line-added"> 7168                 demux-&gt;old_streams, demux-&gt;active_streams);</span>
<span class="line-added"> 7169 </span>
<span class="line-added"> 7170             qtdemux_parse_moov (demux, data, demux-&gt;neededbytes);</span>
<span class="line-added"> 7171             qtdemux_node_dump (demux, demux-&gt;moov_node);</span>
 7172 #ifdef GSTREAMER_LITE
 7173           if (!qtdemux_parse_tree (demux))
 7174           {
 7175               g_node_destroy (demux-&gt;moov_node);
 7176               demux-&gt;moov_node = NULL;
 7177               ret = GST_FLOW_ERROR;
 7178               goto done;
 7179           }
 7180 #else
<span class="line-modified"> 7181             qtdemux_parse_tree (demux);</span>
 7182 #endif //GSTREAMER_LITE
<span class="line-modified"> 7183             qtdemux_prepare_streams (demux);</span>
<span class="line-modified"> 7184             QTDEMUX_EXPOSE_LOCK (demux);</span>
 7185             qtdemux_expose_streams (demux);
<span class="line-modified"> 7186             QTDEMUX_EXPOSE_UNLOCK (demux);</span>







 7187 
 7188             demux-&gt;got_moov = TRUE;

 7189 
<span class="line-modified"> 7190             gst_qtdemux_check_send_pending_segment (demux);</span>






 7191 
 7192             if (demux-&gt;moov_node_compressed) {
 7193               g_node_destroy (demux-&gt;moov_node_compressed);
 7194               g_free (demux-&gt;moov_node-&gt;data);
 7195             }
 7196             demux-&gt;moov_node_compressed = NULL;
<span class="line-modified"> 7197             g_node_destroy (demux-&gt;moov_node);</span>
<span class="line-modified"> 7198             demux-&gt;moov_node = NULL;</span>
<span class="line-modified"> 7199             GST_DEBUG_OBJECT (demux, &quot;Finished parsing the header&quot;);</span>
 7200           }
 7201         } else if (fourcc == FOURCC_moof) {
 7202           if ((demux-&gt;got_moov || demux-&gt;media_caps) &amp;&amp; demux-&gt;fragmented) {
 7203             guint64 dist = 0;
 7204             GstClockTime prev_pts;
 7205             guint64 prev_offset;
 7206             guint64 adapter_discont_offset, adapter_discont_dist;
 7207 
 7208             GST_DEBUG_OBJECT (demux, &quot;Parsing [moof]&quot;);
 7209 
 7210             /*
 7211              * The timestamp of the moof buffer is relevant as some scenarios
 7212              * won&#39;t have the initial timestamp in the atoms. Whenever a new
 7213              * buffer has started, we get that buffer&#39;s PTS and use it as a base
 7214              * timestamp for the trun entries.
 7215              *
 7216              * To keep track of the current buffer timestamp and starting point
 7217              * we use gst_adapter_prev_pts that gives us the PTS and the distance
 7218              * from the beggining of the buffer, with the distance and demux-&gt;offset
 7219              * we know if it is still the same buffer or not.
</pre>
<hr />
<pre>
 7253                 &quot;demux offset %&quot; G_GUINT64_FORMAT &quot; adapter offset %&quot;
 7254                 G_GUINT64_FORMAT &quot; (+ %&quot; G_GUINT64_FORMAT &quot; bytes)&quot;,
 7255                 demux-&gt;offset, adapter_discont_offset, adapter_discont_dist);
 7256 
 7257             if (demux-&gt;upstream_format_is_time) {
 7258               demux-&gt;moof_offset = adapter_discont_offset;
 7259               if (demux-&gt;moof_offset != GST_BUFFER_OFFSET_NONE)
 7260                 demux-&gt;moof_offset += adapter_discont_dist;
 7261               if (demux-&gt;moof_offset == GST_BUFFER_OFFSET_NONE)
 7262                 demux-&gt;moof_offset = demux-&gt;offset;
 7263             } else {
 7264               demux-&gt;moof_offset = demux-&gt;offset;
 7265             }
 7266 
 7267             if (!qtdemux_parse_moof (demux, data, demux-&gt;neededbytes,
 7268                     demux-&gt;moof_offset, NULL)) {
 7269               gst_adapter_unmap (demux-&gt;adapter);
 7270               ret = GST_FLOW_ERROR;
 7271               goto done;
 7272             }
<span class="line-added"> 7273 </span>
 7274             /* in MSS we need to expose the pads after the first moof as we won&#39;t get a moov */
 7275             if (demux-&gt;mss_mode &amp;&amp; !demux-&gt;exposed) {
<span class="line-modified"> 7276               QTDEMUX_EXPOSE_LOCK (demux);</span>







 7277               qtdemux_expose_streams (demux);
<span class="line-added"> 7278               QTDEMUX_EXPOSE_UNLOCK (demux);</span>
 7279             }
<span class="line-added"> 7280 </span>
<span class="line-added"> 7281             gst_qtdemux_check_send_pending_segment (demux);</span>
 7282           } else {
 7283             GST_DEBUG_OBJECT (demux, &quot;Discarding [moof]&quot;);
 7284           }
 7285         } else if (fourcc == FOURCC_ftyp) {
 7286           GST_DEBUG_OBJECT (demux, &quot;Parsing [ftyp]&quot;);
 7287           qtdemux_parse_ftyp (demux, data, demux-&gt;neededbytes);
 7288         } else if (fourcc == FOURCC_uuid) {
 7289           GST_DEBUG_OBJECT (demux, &quot;Parsing [uuid]&quot;);
 7290           qtdemux_parse_uuid (demux, data, demux-&gt;neededbytes);
 7291         } else if (fourcc == FOURCC_sidx) {
 7292           GST_DEBUG_OBJECT (demux, &quot;Parsing [sidx]&quot;);
 7293           qtdemux_parse_sidx (demux, data, demux-&gt;neededbytes);
 7294         } else {
 7295           switch (fourcc) {
 7296             case FOURCC_styp:
 7297               /* [styp] is like a [ftyp], but in fragment header. We ignore it for now
 7298                * FALLTHROUGH */
 7299             case FOURCC_skip:
 7300             case FOURCC_free:
 7301               /* [free] and [skip] are padding atoms */
 7302               GST_DEBUG_OBJECT (demux,
 7303                   &quot;Skipping fourcc while parsing header : %&quot; GST_FOURCC_FORMAT,
 7304                   GST_FOURCC_ARGS (fourcc));
 7305               break;
 7306             default:
<span class="line-modified"> 7307               GST_WARNING_OBJECT (demux,</span>
<span class="line-modified"> 7308                   &quot;Unknown fourcc while parsing header : %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified"> 7309                   GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified"> 7310               /* Let&#39;s jump that one and go back to initial state */</span>
 7311               break;
<span class="line-modified"> 7312           }</span>
 7313         }
 7314         gst_adapter_unmap (demux-&gt;adapter);
 7315         data = NULL;
 7316 
<span class="line-modified"> 7317         if (demux-&gt;mdatbuffer &amp;&amp; QTDEMUX_N_STREAMS (demux)) {</span>
 7318           gsize remaining_data_size = 0;
 7319 
 7320           /* the mdat was before the header */
 7321           GST_DEBUG_OBJECT (demux, &quot;We have n_streams:%d and mdatbuffer:%p&quot;,
<span class="line-modified"> 7322               QTDEMUX_N_STREAMS (demux), demux-&gt;mdatbuffer);</span>
 7323           /* restore our adapter/offset view of things with upstream;
 7324            * put preceding buffered data ahead of current moov data.
 7325            * This should also handle evil mdat, moov, mdat cases and alike */
 7326           gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
 7327 
 7328           /* Store any remaining data after the mdat for later usage */
 7329           remaining_data_size = gst_adapter_available (demux-&gt;adapter);
 7330           if (remaining_data_size &gt; 0) {
 7331             g_assert (demux-&gt;restoredata_buffer == NULL);
 7332             demux-&gt;restoredata_buffer =
 7333                 gst_adapter_take_buffer (demux-&gt;adapter, remaining_data_size);
 7334             demux-&gt;restoredata_offset = demux-&gt;offset + demux-&gt;neededbytes;
 7335             GST_DEBUG_OBJECT (demux,
 7336                 &quot;Stored %&quot; G_GSIZE_FORMAT &quot; post mdat bytes at offset %&quot;
 7337                 G_GUINT64_FORMAT, remaining_data_size,
 7338                 demux-&gt;restoredata_offset);
 7339           }
 7340 
 7341           gst_adapter_push (demux-&gt;adapter, demux-&gt;mdatbuffer);
 7342           demux-&gt;mdatbuffer = NULL;
</pre>
<hr />
<pre>
 7377         GST_DEBUG_OBJECT (demux, &quot;Got our buffer at offset %&quot; G_GUINT64_FORMAT,
 7378             demux-&gt;offset);
 7379         buf = gst_adapter_take_buffer (demux-&gt;adapter, demux-&gt;neededbytes);
 7380         gst_buffer_extract (buf, 0, fourcc, 4);
 7381         GST_DEBUG_OBJECT (demux, &quot;mdatbuffer starts with %&quot; GST_FOURCC_FORMAT,
 7382             GST_FOURCC_ARGS (QT_FOURCC (fourcc)));
 7383         if (demux-&gt;mdatbuffer)
 7384           demux-&gt;mdatbuffer = gst_buffer_append (demux-&gt;mdatbuffer, buf);
 7385         else
 7386           demux-&gt;mdatbuffer = buf;
 7387         demux-&gt;offset += demux-&gt;neededbytes;
 7388         demux-&gt;neededbytes = 16;
 7389         demux-&gt;state = QTDEMUX_STATE_INITIAL;
 7390         gst_qtdemux_post_progress (demux, 1, 1);
 7391 
 7392         break;
 7393       }
 7394       case QTDEMUX_STATE_MOVIE:{
 7395         QtDemuxStream *stream = NULL;
 7396         QtDemuxSample *sample;

 7397         GstClockTime dts, pts, duration;
 7398         gboolean keyframe;
<span class="line-added"> 7399         gint i;</span>
 7400 
 7401         GST_DEBUG_OBJECT (demux,
 7402             &quot;BEGIN // in MOVIE for offset %&quot; G_GUINT64_FORMAT, demux-&gt;offset);
 7403 
 7404         if (demux-&gt;fragmented) {
 7405           GST_DEBUG_OBJECT (demux, &quot;mdat remaining %&quot; G_GUINT64_FORMAT,
 7406               demux-&gt;mdatleft);
 7407           if (G_LIKELY (demux-&gt;todrop &lt; demux-&gt;mdatleft)) {
 7408             /* if needed data starts within this atom,
 7409              * then it should not exceed this atom */
 7410             if (G_UNLIKELY (demux-&gt;neededbytes &gt; demux-&gt;mdatleft)) {
 7411               GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
 7412                   (_(&quot;This file is invalid and cannot be played.&quot;)),
 7413                   (&quot;sample data crosses atom boundary&quot;));
 7414               ret = GST_FLOW_ERROR;
 7415               break;
 7416             }
 7417             demux-&gt;mdatleft -= demux-&gt;neededbytes;
 7418           } else {
 7419             GST_DEBUG_OBJECT (demux, &quot;data atom emptied; resuming atom scan&quot;);
</pre>
<hr />
<pre>
 7429             if (demux-&gt;restoredata_buffer) {
 7430               g_assert (gst_adapter_available (demux-&gt;adapter) == 0);
 7431 
 7432               gst_adapter_push (demux-&gt;adapter, demux-&gt;restoredata_buffer);
 7433               demux-&gt;restoredata_buffer = NULL;
 7434               demux-&gt;offset = demux-&gt;restoredata_offset;
 7435             }
 7436 
 7437             break;
 7438           }
 7439         }
 7440 
 7441         if (demux-&gt;todrop) {
 7442           if (demux-&gt;cenc_aux_info_offset &gt; 0) {
 7443             GstByteReader br;
 7444             const guint8 *data;
 7445 
 7446             GST_DEBUG_OBJECT (demux, &quot;parsing cenc auxiliary info&quot;);
 7447             data = gst_adapter_map (demux-&gt;adapter, demux-&gt;todrop);
 7448             gst_byte_reader_init (&amp;br, data + 8, demux-&gt;todrop);
<span class="line-modified"> 7449             if (!qtdemux_parse_cenc_aux_info (demux,</span>
<span class="line-added"> 7450                     QTDEMUX_NTH_STREAM (demux, 0), &amp;br,</span>
 7451                     demux-&gt;cenc_aux_info_sizes, demux-&gt;cenc_aux_sample_count)) {
 7452               GST_ERROR_OBJECT (demux, &quot;failed to parse cenc auxiliary info&quot;);
 7453               ret = GST_FLOW_ERROR;
 7454               gst_adapter_unmap (demux-&gt;adapter);
 7455               g_free (demux-&gt;cenc_aux_info_sizes);
 7456               demux-&gt;cenc_aux_info_sizes = NULL;
 7457               goto done;
<span class="line-modified"> 7458             }</span>
 7459             demux-&gt;cenc_aux_info_offset = 0;
 7460             g_free (demux-&gt;cenc_aux_info_sizes);
 7461             demux-&gt;cenc_aux_info_sizes = NULL;
 7462             gst_adapter_unmap (demux-&gt;adapter);
 7463           }
 7464           gst_qtdemux_drop_data (demux, demux-&gt;todrop);
 7465         }
 7466 
 7467         /* first buffer? */
 7468         /* initial newsegment sent here after having added pads,
 7469          * possible others in sink_event */
 7470         gst_qtdemux_check_send_pending_segment (demux);
 7471 
 7472         /* Figure out which stream this packet belongs to */
<span class="line-modified"> 7473         for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 7474           stream = QTDEMUX_NTH_STREAM (demux, i);</span>
<span class="line-modified"> 7475           if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {</span>
<span class="line-added"> 7476             /* reset to be checked below G_UNLIKELY (stream == NULL) */</span>
<span class="line-added"> 7477             stream = NULL;</span>
 7478             continue;
<span class="line-added"> 7479           }</span>
 7480           GST_LOG_OBJECT (demux,
<span class="line-modified"> 7481               &quot;Checking track-id %u (sample_index:%d / offset:%&quot;</span>
<span class="line-modified"> 7482               G_GUINT64_FORMAT &quot; / size:%d)&quot;, stream-&gt;track_id,</span>
<span class="line-added"> 7483               stream-&gt;sample_index,</span>
 7484               stream-&gt;samples[stream-&gt;sample_index].offset,
 7485               stream-&gt;samples[stream-&gt;sample_index].size);
 7486 
 7487           if (stream-&gt;samples[stream-&gt;sample_index].offset == demux-&gt;offset)
 7488             break;
 7489         }
 7490 
<span class="line-modified"> 7491         if (G_UNLIKELY (stream == NULL))</span>
 7492           goto unknown_stream;
 7493 
 7494         gst_qtdemux_stream_check_and_change_stsd_index (demux, stream);
 7495 
 7496         if (stream-&gt;new_caps) {
 7497           gst_qtdemux_configure_stream (demux, stream);
 7498         }
 7499 
 7500         /* Put data in a buffer, set timestamps, caps, ... */
 7501         sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 7502 
 7503         if (G_LIKELY (!(STREAM_IS_EOS (stream)))) {
<span class="line-modified"> 7504           GST_DEBUG_OBJECT (demux, &quot;stream : %&quot; GST_FOURCC_FORMAT,</span>
 7505               GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));
 7506 
 7507           dts = QTSAMPLE_DTS (stream, sample);
 7508           pts = QTSAMPLE_PTS (stream, sample);
 7509           duration = QTSAMPLE_DUR_DTS (stream, sample, dts);
<span class="line-modified"> 7510           keyframe = QTSAMPLE_KEYFRAME (stream, sample);</span>
 7511 
 7512           /* check for segment end */
 7513           if (G_UNLIKELY (demux-&gt;segment.stop != -1
<span class="line-modified"> 7514                   &amp;&amp; demux-&gt;segment.stop &lt;= pts &amp;&amp; stream-&gt;on_keyframe)</span>
<span class="line-added"> 7515               &amp;&amp; !(demux-&gt;upstream_format_is_time &amp;&amp; demux-&gt;segment.rate &lt; 0)) {</span>
 7516             GST_DEBUG_OBJECT (demux, &quot;we reached the end of our segment.&quot;);
 7517             stream-&gt;time_position = GST_CLOCK_TIME_NONE;        /* this means EOS */
 7518 
 7519             /* skip this data, stream is EOS */
 7520             gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
 7521             demux-&gt;offset += demux-&gt;neededbytes;
 7522 
 7523             /* check if all streams are eos */
 7524             ret = GST_FLOW_EOS;
<span class="line-modified"> 7525             for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 7526               if (!STREAM_IS_EOS (QTDEMUX_NTH_STREAM (demux, i))) {</span>
 7527                 ret = GST_FLOW_OK;
 7528                 break;
 7529               }
 7530             }
 7531           } else {
 7532             GstBuffer *outbuf;
 7533 
 7534             outbuf =
 7535                 gst_adapter_take_buffer (demux-&gt;adapter, demux-&gt;neededbytes);
 7536 
 7537             /* FIXME: should either be an assert or a plain check */
 7538             g_return_val_if_fail (outbuf != NULL, GST_FLOW_ERROR);
 7539 
<span class="line-modified"> 7540             ret = gst_qtdemux_decorate_and_push_buffer (demux, stream, outbuf,</span>
 7541                 dts, pts, duration, keyframe, dts, demux-&gt;offset);
 7542           }
 7543 
<span class="line-modified"> 7544           /* combine flows */</span>
 7545           ret = gst_qtdemux_combine_flows (demux, stream, ret);
 7546         } else {
 7547           /* skip this data, stream is EOS */
 7548           gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
 7549         }
 7550 
 7551         stream-&gt;sample_index++;
 7552         stream-&gt;offset_in_sample = 0;
 7553 
 7554         /* update current offset and figure out size of next buffer */
 7555         GST_LOG_OBJECT (demux, &quot;increasing offset %&quot; G_GUINT64_FORMAT &quot; by %u&quot;,
 7556             demux-&gt;offset, demux-&gt;neededbytes);
 7557         demux-&gt;offset += demux-&gt;neededbytes;
 7558         GST_LOG_OBJECT (demux, &quot;offset is now %&quot; G_GUINT64_FORMAT,
 7559             demux-&gt;offset);
 7560 
 7561 
 7562         if (ret == GST_FLOW_EOS) {
 7563           GST_DEBUG_OBJECT (demux, &quot;All streams are EOS, signal upstream&quot;);
 7564           demux-&gt;neededbytes = -1;
</pre>
<hr />
<pre>
 7652 
 7653   GST_DEBUG_OBJECT (sinkpad, &quot;activating pull&quot;);
 7654   return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE);
 7655 
 7656 activate_push:
 7657   {
 7658     GST_DEBUG_OBJECT (sinkpad, &quot;activating push&quot;);
 7659     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
 7660   }
 7661 }
 7662 
 7663 static gboolean
 7664 qtdemux_sink_activate_mode (GstPad * sinkpad, GstObject * parent,
 7665     GstPadMode mode, gboolean active)
 7666 {
 7667   gboolean res;
 7668   GstQTDemux *demux = GST_QTDEMUX (parent);
 7669 
 7670   switch (mode) {
 7671     case GST_PAD_MODE_PUSH:
<span class="line-modified"> 7672       demux-&gt;pullbased = FALSE;</span>
 7673       res = TRUE;
 7674       break;
 7675     case GST_PAD_MODE_PULL:
 7676       if (active) {
 7677         demux-&gt;pullbased = TRUE;
 7678         res = gst_pad_start_task (sinkpad, (GstTaskFunction) gst_qtdemux_loop,
 7679             sinkpad, NULL);
 7680       } else {
 7681         res = gst_pad_stop_task (sinkpad);
 7682       }
 7683       break;
 7684     default:
 7685       res = FALSE;
 7686       break;
 7687   }
 7688   return res;
 7689 }
 7690 
 7691 #ifdef HAVE_ZLIB
 7692 static void *
</pre>
<hr />
<pre>
 7702   z.opaque = NULL;
 7703 
 7704   if ((ret = inflateInit (&amp;z)) != Z_OK) {
 7705     GST_ERROR (&quot;inflateInit() returned %d&quot;, ret);
 7706     return NULL;
 7707   }
 7708 
 7709   z.next_in = z_buffer;
 7710   z.avail_in = z_length;
 7711 
 7712   buffer = (guint8 *) g_malloc (*length);
 7713   z.avail_out = *length;
 7714   z.next_out = (Bytef *) buffer;
 7715   do {
 7716     ret = inflate (&amp;z, Z_NO_FLUSH);
 7717     if (ret == Z_STREAM_END) {
 7718       break;
 7719     } else if (ret != Z_OK) {
 7720       GST_WARNING (&quot;inflate() returned %d&quot;, ret);
 7721       break;
<span class="line-modified"> 7722     }</span>
 7723 
 7724     *length += 4096;
 7725     buffer = (guint8 *) g_realloc (buffer, *length);
 7726     z.next_out = (Bytef *) (buffer + z.total_out);
 7727     z.avail_out += 4096;
 7728   } while (z.avail_in &gt; 0);
 7729 
 7730   if (ret != Z_STREAM_END) {
 7731     g_free (buffer);
 7732     buffer = NULL;
 7733     *length = 0;
 7734   } else {
 7735     *length = z.total_out;
 7736   }
 7737 
 7738   inflateEnd (&amp;z);
 7739 
 7740   return buffer;
 7741 }
 7742 #endif /* HAVE_ZLIB */
</pre>
<hr />
<pre>
 7775 #ifdef HAVE_ZLIB
 7776       case FOURCC_zlib:{
 7777         guint uncompressed_length;
 7778         guint compressed_length;
 7779         guint8 *buf;
 7780         guint32 cmvd_len;
 7781 
 7782         cmvd_len = QT_UINT32 ((guint8 *) cmvd-&gt;data);
 7783         if (cmvd_len &lt; 12)
 7784           goto invalid_compression;
 7785 
 7786         uncompressed_length = QT_UINT32 ((guint8 *) cmvd-&gt;data + 8);
 7787         compressed_length = cmvd_len - 12;
 7788         GST_LOG (&quot;length = %u&quot;, uncompressed_length);
 7789 
 7790         buf =
 7791             (guint8 *) qtdemux_inflate ((guint8 *) cmvd-&gt;data + 12,
 7792             compressed_length, &amp;uncompressed_length);
 7793 
 7794         if (buf) {
<span class="line-modified"> 7795           qtdemux-&gt;moov_node_compressed = qtdemux-&gt;moov_node;</span>
<span class="line-modified"> 7796           qtdemux-&gt;moov_node = g_node_new (buf);</span>
 7797 
<span class="line-modified"> 7798           qtdemux_parse_node (qtdemux, qtdemux-&gt;moov_node, buf,</span>
<span class="line-modified"> 7799               uncompressed_length);</span>
 7800         }
 7801         break;
 7802       }
 7803 #endif /* HAVE_ZLIB */
 7804       default:
 7805         GST_WARNING_OBJECT (qtdemux, &quot;unknown or unhandled header compression &quot;
 7806             &quot;type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (method));
 7807         break;
 7808     }
 7809   }
 7810   return TRUE;
 7811 
 7812   /* ERRORS */
 7813 invalid_compression:
 7814   {
 7815     GST_ERROR_OBJECT (qtdemux, &quot;invalid compressed header&quot;);
 7816     return FALSE;
 7817   }
 7818 }
 7819 
</pre>
<hr />
<pre>
 8086       {
 8087         GST_DEBUG_OBJECT (qtdemux, &quot;parsing meta atom&quot;);
 8088 
 8089         /* You are reading this correctly. QTFF specifies that the
 8090          * metadata atom is a short atom, whereas ISO BMFF specifies
 8091          * it&#39;s a full atom. But since so many people are doing things
 8092          * differently, we actually peek into the atom to see which
 8093          * variant it is */
 8094         if (length &lt; 16) {
 8095           GST_LOG_OBJECT (qtdemux, &quot;skipping small %&quot; GST_FOURCC_FORMAT &quot; box&quot;,
 8096               GST_FOURCC_ARGS (fourcc));
 8097           break;
 8098         }
 8099         if (QT_FOURCC (buffer + 12) == FOURCC_hdlr) {
 8100           /* Variant 1: What QTFF specifies. &#39;meta&#39; is a short header which
 8101            * starts with a &#39;hdlr&#39; atom */
 8102           qtdemux_parse_container (qtdemux, node, buffer + 8, end);
 8103         } else if (QT_UINT32 (buffer + 8) == 0x00000000) {
 8104           /* Variant 2: What ISO BMFF specifies. &#39;meta&#39; is a _full_ atom
 8105            * with version/flags both set to zero */
<span class="line-modified"> 8106           qtdemux_parse_container (qtdemux, node, buffer + 12, end);</span>
 8107         } else
 8108           GST_WARNING_OBJECT (qtdemux, &quot;Unknown &#39;meta&#39; atom format&quot;);
 8109         break;
 8110       }
 8111       case FOURCC_mp4s:
 8112       {
 8113         GST_MEMDUMP_OBJECT (qtdemux, &quot;mp4s&quot;, buffer, end - buffer);
 8114         /* Skip 8 byte header, plus 8 byte version + flags + entry_count */
 8115         qtdemux_parse_container (qtdemux, node, buffer + 16, end);
 8116         break;
 8117       }
 8118       case FOURCC_XiTh:
 8119       {
 8120         guint32 version;
 8121         guint32 offset;
 8122 
 8123         if (length &lt; 16) {
 8124           GST_LOG_OBJECT (qtdemux, &quot;skipping small %&quot; GST_FOURCC_FORMAT &quot; box&quot;,
 8125               GST_FOURCC_ARGS (fourcc));
 8126           break;
</pre>
<hr />
<pre>
 8263       if (parser) {
 8264         child_len = QT_UINT32 (buffer);
 8265         if (G_UNLIKELY (child_len &lt; (4 + 4)))
 8266           return NULL;
 8267         /* FIXME: must verify if atom length &lt; parent atom length */
 8268         gst_byte_reader_init (parser, buffer + (4 + 4), child_len - (4 + 4));
 8269       }
 8270       return child;
 8271     }
 8272   }
 8273   return NULL;
 8274 }
 8275 
 8276 static GNode *
 8277 qtdemux_tree_get_sibling_by_type (GNode * node, guint32 fourcc)
 8278 {
 8279   return qtdemux_tree_get_sibling_by_type_full (node, fourcc, NULL);
 8280 }
 8281 
 8282 static void
<span class="line-modified"> 8283 qtdemux_do_allocation (QtDemuxStream * stream, GstQTDemux * qtdemux)</span>
 8284 {
 8285 /* FIXME: This can only reliably work if demuxers have a
 8286  * separate streaming thread per srcpad. This should be
 8287  * done in a demuxer base class, which integrates parts
 8288  * of multiqueue
 8289  *
 8290  * https://bugzilla.gnome.org/show_bug.cgi?id=701856
 8291  */
 8292 #if 0
 8293   GstQuery *query;
 8294 
 8295   query = gst_query_new_allocation (stream-&gt;caps, FALSE);
 8296 
 8297   if (!gst_pad_peer_query (stream-&gt;pad, query)) {
 8298     /* not a problem, just debug a little */
 8299     GST_DEBUG_OBJECT (qtdemux, &quot;peer ALLOCATION query failed&quot;);
 8300   }
 8301 
 8302   if (stream-&gt;allocator)
 8303     gst_object_unref (stream-&gt;allocator);
 8304 
 8305   if (gst_query_get_n_allocation_params (query) &gt; 0) {
 8306     /* try the allocator */
 8307     gst_query_parse_nth_allocation_param (query, 0, &amp;stream-&gt;allocator,
 8308         &amp;stream-&gt;params);
 8309     stream-&gt;use_allocator = TRUE;
 8310   } else {
 8311     stream-&gt;allocator = NULL;
 8312     gst_allocation_params_init (&amp;stream-&gt;params);
 8313     stream-&gt;use_allocator = FALSE;
 8314   }
 8315   gst_query_unref (query);
 8316 #endif
 8317 }
 8318 
<span class="line-added"> 8319 static gboolean</span>
<span class="line-added"> 8320 pad_query (const GValue * item, GValue * value, gpointer user_data)</span>
<span class="line-added"> 8321 {</span>
<span class="line-added"> 8322   GstPad *pad = g_value_get_object (item);</span>
<span class="line-added"> 8323   GstQuery *query = user_data;</span>
<span class="line-added"> 8324   gboolean res;</span>
<span class="line-added"> 8325 </span>
<span class="line-added"> 8326   res = gst_pad_peer_query (pad, query);</span>
<span class="line-added"> 8327 </span>
<span class="line-added"> 8328   if (res) {</span>
<span class="line-added"> 8329     g_value_set_boolean (value, TRUE);</span>
<span class="line-added"> 8330     return FALSE;</span>
<span class="line-added"> 8331   }</span>
<span class="line-added"> 8332 </span>
<span class="line-added"> 8333   GST_INFO_OBJECT (pad, &quot;pad peer query failed&quot;);</span>
<span class="line-added"> 8334   return TRUE;</span>
<span class="line-added"> 8335 }</span>
<span class="line-added"> 8336 </span>
<span class="line-added"> 8337 static gboolean</span>
<span class="line-added"> 8338 gst_qtdemux_run_query (GstElement * element, GstQuery * query,</span>
<span class="line-added"> 8339     GstPadDirection direction)</span>
<span class="line-added"> 8340 {</span>
<span class="line-added"> 8341   GstIterator *it;</span>
<span class="line-added"> 8342   GstIteratorFoldFunction func = pad_query;</span>
<span class="line-added"> 8343   GValue res = { 0, };</span>
<span class="line-added"> 8344 </span>
<span class="line-added"> 8345   g_value_init (&amp;res, G_TYPE_BOOLEAN);</span>
<span class="line-added"> 8346   g_value_set_boolean (&amp;res, FALSE);</span>
<span class="line-added"> 8347 </span>
<span class="line-added"> 8348   /* Ask neighbor */</span>
<span class="line-added"> 8349   if (direction == GST_PAD_SRC)</span>
<span class="line-added"> 8350     it = gst_element_iterate_src_pads (element);</span>
<span class="line-added"> 8351   else</span>
<span class="line-added"> 8352     it = gst_element_iterate_sink_pads (element);</span>
<span class="line-added"> 8353 </span>
<span class="line-added"> 8354   while (gst_iterator_fold (it, func, &amp;res, query) == GST_ITERATOR_RESYNC)</span>
<span class="line-added"> 8355     gst_iterator_resync (it);</span>
<span class="line-added"> 8356 </span>
<span class="line-added"> 8357   gst_iterator_free (it);</span>
<span class="line-added"> 8358 </span>
<span class="line-added"> 8359   return g_value_get_boolean (&amp;res);</span>
<span class="line-added"> 8360 }</span>
<span class="line-added"> 8361 </span>
<span class="line-added"> 8362 static void</span>
<span class="line-added"> 8363 gst_qtdemux_request_protection_context (GstQTDemux * qtdemux,</span>
<span class="line-added"> 8364     QtDemuxStream * stream)</span>
<span class="line-added"> 8365 {</span>
<span class="line-added"> 8366   GstQuery *query;</span>
<span class="line-added"> 8367   GstContext *ctxt;</span>
<span class="line-added"> 8368   GstElement *element = GST_ELEMENT (qtdemux);</span>
<span class="line-added"> 8369   GstStructure *st;</span>
<span class="line-added"> 8370   gchar **filtered_sys_ids;</span>
<span class="line-added"> 8371   GValue event_list = G_VALUE_INIT;</span>
<span class="line-added"> 8372   GList *walk;</span>
<span class="line-added"> 8373 </span>
<span class="line-added"> 8374   /* 1. Check if we already have the context. */</span>
<span class="line-added"> 8375   if (qtdemux-&gt;preferred_protection_system_id != NULL) {</span>
<span class="line-added"> 8376     GST_LOG_OBJECT (element,</span>
<span class="line-added"> 8377         &quot;already have the protection context, no need to request it again&quot;);</span>
<span class="line-added"> 8378     return;</span>
<span class="line-added"> 8379   }</span>
<span class="line-added"> 8380 </span>
<span class="line-added"> 8381   g_ptr_array_add (qtdemux-&gt;protection_system_ids, NULL);</span>
<span class="line-added"> 8382   filtered_sys_ids = gst_protection_filter_systems_by_available_decryptors (</span>
<span class="line-added"> 8383       (const gchar **) qtdemux-&gt;protection_system_ids-&gt;pdata);</span>
<span class="line-added"> 8384 </span>
<span class="line-added"> 8385   g_ptr_array_remove_index (qtdemux-&gt;protection_system_ids,</span>
<span class="line-added"> 8386       qtdemux-&gt;protection_system_ids-&gt;len - 1);</span>
<span class="line-added"> 8387   GST_TRACE_OBJECT (qtdemux, &quot;detected %u protection systems, we have &quot;</span>
<span class="line-added"> 8388       &quot;decryptors for %u of them, running context request&quot;,</span>
<span class="line-added"> 8389       qtdemux-&gt;protection_system_ids-&gt;len,</span>
<span class="line-added"> 8390       filtered_sys_ids ? g_strv_length (filtered_sys_ids) : 0);</span>
<span class="line-added"> 8391 </span>
<span class="line-added"> 8392 </span>
<span class="line-added"> 8393   if (stream-&gt;protection_scheme_event_queue.length) {</span>
<span class="line-added"> 8394     GST_TRACE_OBJECT (qtdemux, &quot;using stream event queue, length %u&quot;,</span>
<span class="line-added"> 8395         stream-&gt;protection_scheme_event_queue.length);</span>
<span class="line-added"> 8396     walk = stream-&gt;protection_scheme_event_queue.tail;</span>
<span class="line-added"> 8397   } else {</span>
<span class="line-added"> 8398     GST_TRACE_OBJECT (qtdemux, &quot;using demuxer event queue, length %u&quot;,</span>
<span class="line-added"> 8399         qtdemux-&gt;protection_event_queue.length);</span>
<span class="line-added"> 8400     walk = qtdemux-&gt;protection_event_queue.tail;</span>
<span class="line-added"> 8401   }</span>
<span class="line-added"> 8402 </span>
<span class="line-added"> 8403   g_value_init (&amp;event_list, GST_TYPE_LIST);</span>
<span class="line-added"> 8404   for (; walk; walk = g_list_previous (walk)) {</span>
<span class="line-added"> 8405     GValue *event_value = g_new0 (GValue, 1);</span>
<span class="line-added"> 8406     g_value_init (event_value, GST_TYPE_EVENT);</span>
<span class="line-added"> 8407     g_value_set_boxed (event_value, walk-&gt;data);</span>
<span class="line-added"> 8408     gst_value_list_append_and_take_value (&amp;event_list, event_value);</span>
<span class="line-added"> 8409   }</span>
<span class="line-added"> 8410 </span>
<span class="line-added"> 8411   /*  2a) Query downstream with GST_QUERY_CONTEXT for the context and</span>
<span class="line-added"> 8412    *      check if downstream already has a context of the specific type</span>
<span class="line-added"> 8413    *  2b) Query upstream as above.</span>
<span class="line-added"> 8414    */</span>
<span class="line-added"> 8415   query = gst_query_new_context (&quot;drm-preferred-decryption-system-id&quot;);</span>
<span class="line-added"> 8416   st = gst_query_writable_structure (query);</span>
<span class="line-added"> 8417   gst_structure_set (st, &quot;track-id&quot;, G_TYPE_UINT, stream-&gt;track_id,</span>
<span class="line-added"> 8418       &quot;available-stream-encryption-systems&quot;, G_TYPE_STRV, filtered_sys_ids,</span>
<span class="line-added"> 8419       NULL);</span>
<span class="line-added"> 8420   gst_structure_set_value (st, &quot;stream-encryption-events&quot;, &amp;event_list);</span>
<span class="line-added"> 8421   if (gst_qtdemux_run_query (element, query, GST_PAD_SRC)) {</span>
<span class="line-added"> 8422     gst_query_parse_context (query, &amp;ctxt);</span>
<span class="line-added"> 8423     GST_INFO_OBJECT (element, &quot;found context (%p) in downstream query&quot;, ctxt);</span>
<span class="line-added"> 8424     gst_element_set_context (element, ctxt);</span>
<span class="line-added"> 8425   } else if (gst_qtdemux_run_query (element, query, GST_PAD_SINK)) {</span>
<span class="line-added"> 8426     gst_query_parse_context (query, &amp;ctxt);</span>
<span class="line-added"> 8427     GST_INFO_OBJECT (element, &quot;found context (%p) in upstream query&quot;, ctxt);</span>
<span class="line-added"> 8428     gst_element_set_context (element, ctxt);</span>
<span class="line-added"> 8429   } else {</span>
<span class="line-added"> 8430     /* 3) Post a GST_MESSAGE_NEED_CONTEXT message on the bus with</span>
<span class="line-added"> 8431      *    the required context type and afterwards check if a</span>
<span class="line-added"> 8432      *    usable context was set now as in 1). The message could</span>
<span class="line-added"> 8433      *    be handled by the parent bins of the element and the</span>
<span class="line-added"> 8434      *    application.</span>
<span class="line-added"> 8435      */</span>
<span class="line-added"> 8436     GstMessage *msg;</span>
<span class="line-added"> 8437 </span>
<span class="line-added"> 8438     GST_INFO_OBJECT (element, &quot;posting need context message&quot;);</span>
<span class="line-added"> 8439     msg = gst_message_new_need_context (GST_OBJECT_CAST (element),</span>
<span class="line-added"> 8440         &quot;drm-preferred-decryption-system-id&quot;);</span>
<span class="line-added"> 8441     st = (GstStructure *) gst_message_get_structure (msg);</span>
<span class="line-added"> 8442     gst_structure_set (st, &quot;track-id&quot;, G_TYPE_UINT, stream-&gt;track_id,</span>
<span class="line-added"> 8443         &quot;available-stream-encryption-systems&quot;, G_TYPE_STRV, filtered_sys_ids,</span>
<span class="line-added"> 8444         NULL);</span>
<span class="line-added"> 8445 </span>
<span class="line-added"> 8446     gst_structure_set_value (st, &quot;stream-encryption-events&quot;, &amp;event_list);</span>
<span class="line-added"> 8447     gst_element_post_message (element, msg);</span>
<span class="line-added"> 8448   }</span>
<span class="line-added"> 8449 </span>
<span class="line-added"> 8450   g_strfreev (filtered_sys_ids);</span>
<span class="line-added"> 8451   g_value_unset (&amp;event_list);</span>
<span class="line-added"> 8452   gst_query_unref (query);</span>
<span class="line-added"> 8453 }</span>
<span class="line-added"> 8454 </span>
 8455 static gboolean
 8456 gst_qtdemux_configure_protected_caps (GstQTDemux * qtdemux,
 8457     QtDemuxStream * stream)
 8458 {
 8459   GstStructure *s;
<span class="line-modified"> 8460   const gchar *selected_system = NULL;</span>
 8461 
 8462   g_return_val_if_fail (qtdemux != NULL, FALSE);
 8463   g_return_val_if_fail (stream != NULL, FALSE);
 8464   g_return_val_if_fail (gst_caps_get_size (CUR_STREAM (stream)-&gt;caps) == 1,
 8465       FALSE);
 8466 
 8467   if (stream-&gt;protection_scheme_type != FOURCC_cenc) {
<span class="line-modified"> 8468     GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added"> 8469         &quot;unsupported protection scheme: %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added"> 8470         GST_FOURCC_ARGS (stream-&gt;protection_scheme_type));</span>
 8471     return FALSE;
 8472   }
 8473   if (qtdemux-&gt;protection_system_ids == NULL) {
 8474     GST_ERROR_OBJECT (qtdemux, &quot;stream is protected using cenc, but no &quot;
 8475         &quot;cenc protection system information has been found&quot;);
 8476     return FALSE;
 8477   }
<span class="line-modified"> 8478 </span>
<span class="line-modified"> 8479   gst_qtdemux_request_protection_context (qtdemux, stream);</span>
<span class="line-modified"> 8480   if (qtdemux-&gt;preferred_protection_system_id != NULL) {</span>
<span class="line-modified"> 8481     const gchar *preferred_system_array[] =</span>
<span class="line-modified"> 8482         { qtdemux-&gt;preferred_protection_system_id, NULL };</span>
<span class="line-added"> 8483 </span>
<span class="line-added"> 8484     selected_system = gst_protection_select_system (preferred_system_array);</span>
<span class="line-added"> 8485 </span>
<span class="line-added"> 8486     if (selected_system) {</span>
<span class="line-added"> 8487       GST_TRACE_OBJECT (qtdemux, &quot;selected preferred system %s&quot;,</span>
<span class="line-added"> 8488           qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added"> 8489     } else {</span>
<span class="line-added"> 8490       GST_WARNING_OBJECT (qtdemux, &quot;could not select preferred system %s &quot;</span>
<span class="line-added"> 8491           &quot;because there is no available decryptor&quot;,</span>
<span class="line-added"> 8492           qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added"> 8493     }</span>
<span class="line-added"> 8494   }</span>
<span class="line-added"> 8495 </span>
<span class="line-added"> 8496   if (!selected_system) {</span>
<span class="line-added"> 8497     g_ptr_array_add (qtdemux-&gt;protection_system_ids, NULL);</span>
<span class="line-added"> 8498     selected_system = gst_protection_select_system ((const gchar **)</span>
<span class="line-added"> 8499         qtdemux-&gt;protection_system_ids-&gt;pdata);</span>
<span class="line-added"> 8500     g_ptr_array_remove_index (qtdemux-&gt;protection_system_ids,</span>
<span class="line-added"> 8501         qtdemux-&gt;protection_system_ids-&gt;len - 1);</span>
<span class="line-added"> 8502   }</span>
<span class="line-added"> 8503 </span>
 8504   if (!selected_system) {
 8505     GST_ERROR_OBJECT (qtdemux, &quot;stream is protected, but no &quot;
 8506         &quot;suitable decryptor element has been found&quot;);
 8507     return FALSE;
 8508   }
 8509 
<span class="line-added"> 8510   GST_DEBUG_OBJECT (qtdemux, &quot;selected protection system is %s&quot;,</span>
<span class="line-added"> 8511       selected_system);</span>
<span class="line-added"> 8512 </span>
 8513   s = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);
 8514   if (!gst_structure_has_name (s, &quot;application/x-cenc&quot;)) {
 8515     gst_structure_set (s,
 8516         &quot;original-media-type&quot;, G_TYPE_STRING, gst_structure_get_name (s),
 8517         GST_PROTECTION_SYSTEM_ID_CAPS_FIELD, G_TYPE_STRING, selected_system,
 8518         NULL);
 8519     gst_structure_set_name (s, &quot;application/x-cenc&quot;);
 8520   }
 8521   return TRUE;
 8522 }
 8523 
 8524 static gboolean
<span class="line-modified"> 8525 gst_qtdemux_guess_framerate (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
 8526 {
<span class="line-modified"> 8527   /* fps is calculated base on the duration of the average framerate since</span>
<span class="line-modified"> 8528    * qt does not have a fixed framerate. */</span>
<span class="line-modified"> 8529   gboolean fps_available = TRUE;</span>
<span class="line-modified"> 8530   guint32 first_duration = 0;</span>
<span class="line-modified"> 8531 </span>
<span class="line-modified"> 8532   if (stream-&gt;n_samples &gt; 0)</span>
<span class="line-modified"> 8533     first_duration = stream-&gt;samples[0].duration;</span>
<span class="line-modified"> 8534 </span>
<span class="line-modified"> 8535   if ((stream-&gt;n_samples == 1 &amp;&amp; first_duration == 0)</span>
<span class="line-added"> 8536       || (qtdemux-&gt;fragmented &amp;&amp; stream-&gt;n_samples_moof == 1)) {</span>
<span class="line-added"> 8537     /* still frame */</span>
<span class="line-added"> 8538     CUR_STREAM (stream)-&gt;fps_n = 0;</span>
<span class="line-added"> 8539     CUR_STREAM (stream)-&gt;fps_d = 1;</span>
<span class="line-added"> 8540   } else {</span>
<span class="line-added"> 8541     if (stream-&gt;duration == 0 || stream-&gt;n_samples &lt; 2) {</span>
<span class="line-added"> 8542       CUR_STREAM (stream)-&gt;fps_n = stream-&gt;timescale;</span>
 8543       CUR_STREAM (stream)-&gt;fps_d = 1;
<span class="line-added"> 8544       fps_available = FALSE;</span>
 8545     } else {
<span class="line-modified"> 8546       GstClockTime avg_duration;</span>
<span class="line-modified"> 8547       guint64 duration;</span>
<span class="line-modified"> 8548       guint32 n_samples;</span>
<span class="line-modified"> 8549 </span>
<span class="line-added"> 8550       /* duration and n_samples can be updated for fragmented format</span>
<span class="line-added"> 8551        * so, framerate of fragmented format is calculated using data in a moof */</span>
<span class="line-added"> 8552       if (qtdemux-&gt;fragmented &amp;&amp; stream-&gt;n_samples_moof &gt; 0</span>
<span class="line-added"> 8553           &amp;&amp; stream-&gt;duration_moof &gt; 0) {</span>
<span class="line-added"> 8554         n_samples = stream-&gt;n_samples_moof;</span>
<span class="line-added"> 8555         duration = stream-&gt;duration_moof;</span>
 8556       } else {
<span class="line-modified"> 8557         n_samples = stream-&gt;n_samples;</span>
<span class="line-modified"> 8558         duration = stream-&gt;duration;</span>
<span class="line-modified"> 8559       }</span>











 8560 
<span class="line-modified"> 8561       /* Calculate a framerate, ignoring the first sample which is sometimes truncated */</span>
<span class="line-modified"> 8562       /* stream-&gt;duration is guint64, timescale, n_samples are guint32 */</span>
<span class="line-modified"> 8563       avg_duration =</span>
<span class="line-modified"> 8564           gst_util_uint64_scale_round (duration -</span>
<span class="line-modified"> 8565           first_duration, GST_SECOND,</span>
<span class="line-modified"> 8566           (guint64) (stream-&gt;timescale) * (n_samples - 1));</span>
 8567 
<span class="line-modified"> 8568       GST_LOG_OBJECT (qtdemux,</span>
<span class="line-modified"> 8569           &quot;Calculating avg sample duration based on stream (or moof) duration %&quot;</span>
<span class="line-modified"> 8570           G_GUINT64_FORMAT</span>
<span class="line-modified"> 8571           &quot; minus first sample %u, leaving %d samples gives %&quot;</span>
<span class="line-modified"> 8572           GST_TIME_FORMAT, duration, first_duration,</span>
<span class="line-modified"> 8573           n_samples - 1, GST_TIME_ARGS (avg_duration));</span>
 8574 
<span class="line-modified"> 8575       fps_available =</span>
<span class="line-modified"> 8576           gst_video_guess_framerate (avg_duration,</span>
<span class="line-added"> 8577           &amp;CUR_STREAM (stream)-&gt;fps_n, &amp;CUR_STREAM (stream)-&gt;fps_d);</span>
 8578 
<span class="line-modified"> 8579       GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified"> 8580           &quot;Calculating framerate, timescale %u gave fps_n %d fps_d %d&quot;,</span>
<span class="line-modified"> 8581           stream-&gt;timescale, CUR_STREAM (stream)-&gt;fps_n,</span>
<span class="line-modified"> 8582           CUR_STREAM (stream)-&gt;fps_d);</span>

 8583     }
<span class="line-added"> 8584   }</span>
<span class="line-added"> 8585 </span>
<span class="line-added"> 8586   return fps_available;</span>
<span class="line-added"> 8587 }</span>
<span class="line-added"> 8588 </span>
<span class="line-added"> 8589 static gboolean</span>
<span class="line-added"> 8590 gst_qtdemux_configure_stream (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
<span class="line-added"> 8591 {</span>
<span class="line-added"> 8592   if (stream-&gt;subtype == FOURCC_vide) {</span>
<span class="line-added"> 8593     gboolean fps_available = gst_qtdemux_guess_framerate (qtdemux, stream);</span>
 8594 
 8595     if (CUR_STREAM (stream)-&gt;caps) {
 8596       CUR_STREAM (stream)-&gt;caps =
 8597           gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);
 8598 
<span class="line-modified"> 8599       if (CUR_STREAM (stream)-&gt;width &amp;&amp; CUR_STREAM (stream)-&gt;height)</span>
<span class="line-modified"> 8600         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,</span>
<span class="line-modified"> 8601             &quot;width&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;width,</span>
<span class="line-added"> 8602             &quot;height&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;height, NULL);</span>
 8603 
 8604       /* set framerate if calculated framerate is reliable */
 8605       if (fps_available) {
 8606         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8607             &quot;framerate&quot;, GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;fps_n,
 8608             CUR_STREAM (stream)-&gt;fps_d, NULL);
 8609       }
 8610 
 8611       /* calculate pixel-aspect-ratio using display width and height */
 8612       GST_DEBUG_OBJECT (qtdemux,
 8613           &quot;video size %dx%d, target display size %dx%d&quot;,
 8614           CUR_STREAM (stream)-&gt;width, CUR_STREAM (stream)-&gt;height,
 8615           stream-&gt;display_width, stream-&gt;display_height);
 8616       /* qt file might have pasp atom */
 8617       if (CUR_STREAM (stream)-&gt;par_w &gt; 0 &amp;&amp; CUR_STREAM (stream)-&gt;par_h &gt; 0) {
 8618         GST_DEBUG_OBJECT (qtdemux, &quot;par %d:%d&quot;, CUR_STREAM (stream)-&gt;par_w,
 8619             CUR_STREAM (stream)-&gt;par_h);
 8620         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;pixel-aspect-ratio&quot;,
 8621             GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;par_w,
 8622             CUR_STREAM (stream)-&gt;par_h, NULL);
</pre>
<hr />
<pre>
 8634         CUR_STREAM (stream)-&gt;par_w = n;
 8635         CUR_STREAM (stream)-&gt;par_h = d;
 8636         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;pixel-aspect-ratio&quot;,
 8637             GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;par_w,
 8638             CUR_STREAM (stream)-&gt;par_h, NULL);
 8639       }
 8640 
 8641       if (CUR_STREAM (stream)-&gt;interlace_mode &gt; 0) {
 8642         if (CUR_STREAM (stream)-&gt;interlace_mode == 1) {
 8643           gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;interlace-mode&quot;,
 8644               G_TYPE_STRING, &quot;progressive&quot;, NULL);
 8645         } else if (CUR_STREAM (stream)-&gt;interlace_mode == 2) {
 8646           gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;interlace-mode&quot;,
 8647               G_TYPE_STRING, &quot;interleaved&quot;, NULL);
 8648           if (CUR_STREAM (stream)-&gt;field_order == 9) {
 8649             gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;field-order&quot;,
 8650                 G_TYPE_STRING, &quot;top-field-first&quot;, NULL);
 8651           } else if (CUR_STREAM (stream)-&gt;field_order == 14) {
 8652             gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;field-order&quot;,
 8653                 G_TYPE_STRING, &quot;bottom-field-first&quot;, NULL);
<span class="line-modified"> 8654           }</span>
<span class="line-modified"> 8655         }</span>
 8656       }
 8657 
 8658       /* Create incomplete colorimetry here if needed */
 8659       if (CUR_STREAM (stream)-&gt;colorimetry.range ||
 8660           CUR_STREAM (stream)-&gt;colorimetry.matrix ||
 8661           CUR_STREAM (stream)-&gt;colorimetry.transfer
 8662           || CUR_STREAM (stream)-&gt;colorimetry.primaries) {
 8663         gchar *colorimetry =
 8664             gst_video_colorimetry_to_string (&amp;CUR_STREAM (stream)-&gt;colorimetry);
 8665         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;colorimetry&quot;,
 8666             G_TYPE_STRING, colorimetry, NULL);
 8667         g_free (colorimetry);
 8668       }
 8669 
 8670       if (stream-&gt;multiview_mode != GST_VIDEO_MULTIVIEW_MODE_NONE) {
 8671         guint par_w = 1, par_h = 1;
 8672 
 8673         if (CUR_STREAM (stream)-&gt;par_w &gt; 0 &amp;&amp; CUR_STREAM (stream)-&gt;par_h &gt; 0) {
 8674           par_w = CUR_STREAM (stream)-&gt;par_w;
 8675           par_h = CUR_STREAM (stream)-&gt;par_h;
</pre>
<hr />
<pre>
 8693   else if (stream-&gt;subtype == FOURCC_soun) {
 8694     if (CUR_STREAM (stream)-&gt;caps) {
 8695       CUR_STREAM (stream)-&gt;caps =
 8696           gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);
 8697       if (CUR_STREAM (stream)-&gt;rate &gt; 0)
 8698         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8699             &quot;rate&quot;, G_TYPE_INT, (int) CUR_STREAM (stream)-&gt;rate, NULL);
 8700       if (CUR_STREAM (stream)-&gt;n_channels &gt; 0)
 8701         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8702             &quot;channels&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;n_channels, NULL);
 8703       if (CUR_STREAM (stream)-&gt;n_channels &gt; 2) {
 8704         /* FIXME: Need to parse the &#39;chan&#39; atom to get channel layouts
 8705          * correctly; this is just the minimum we can do - assume
 8706          * we don&#39;t actually have any channel positions. */
 8707         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8708             &quot;channel-mask&quot;, GST_TYPE_BITMASK, G_GUINT64_CONSTANT (0), NULL);
 8709       }
 8710     }
 8711   }
 8712 
<span class="line-added"> 8713   else if (stream-&gt;subtype == FOURCC_clcp &amp;&amp; CUR_STREAM (stream)-&gt;caps) {</span>
<span class="line-added"> 8714     const GstStructure *s;</span>
<span class="line-added"> 8715     QtDemuxStream *fps_stream = NULL;</span>
<span class="line-added"> 8716     gboolean fps_available = FALSE;</span>
<span class="line-added"> 8717 </span>
<span class="line-added"> 8718     /* CEA608 closed caption tracks are a bit special in that each sample</span>
<span class="line-added"> 8719      * can contain CCs for multiple frames, and CCs can be omitted and have to</span>
<span class="line-added"> 8720      * be inferred from the duration of the sample then.</span>
<span class="line-added"> 8721      *</span>
<span class="line-added"> 8722      * As such we take the framerate from the (first) video track here for</span>
<span class="line-added"> 8723      * CEA608 as there must be one CC byte pair for every video frame</span>
<span class="line-added"> 8724      * according to the spec.</span>
<span class="line-added"> 8725      *</span>
<span class="line-added"> 8726      * For CEA708 all is fine and there is one sample per frame.</span>
<span class="line-added"> 8727      */</span>
<span class="line-added"> 8728 </span>
<span class="line-added"> 8729     s = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);</span>
<span class="line-added"> 8730     if (gst_structure_has_name (s, &quot;closedcaption/x-cea-608&quot;)) {</span>
<span class="line-added"> 8731       gint i;</span>
<span class="line-added"> 8732 </span>
<span class="line-added"> 8733       for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added"> 8734         QtDemuxStream *tmp = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added"> 8735 </span>
<span class="line-added"> 8736         if (tmp-&gt;subtype == FOURCC_vide) {</span>
<span class="line-added"> 8737           fps_stream = tmp;</span>
<span class="line-added"> 8738           break;</span>
<span class="line-added"> 8739         }</span>
<span class="line-added"> 8740       }</span>
<span class="line-added"> 8741 </span>
<span class="line-added"> 8742       if (fps_stream) {</span>
<span class="line-added"> 8743         fps_available = gst_qtdemux_guess_framerate (qtdemux, fps_stream);</span>
<span class="line-added"> 8744         CUR_STREAM (stream)-&gt;fps_n = CUR_STREAM (fps_stream)-&gt;fps_n;</span>
<span class="line-added"> 8745         CUR_STREAM (stream)-&gt;fps_d = CUR_STREAM (fps_stream)-&gt;fps_d;</span>
<span class="line-added"> 8746       }</span>
<span class="line-added"> 8747     } else {</span>
<span class="line-added"> 8748       fps_available = gst_qtdemux_guess_framerate (qtdemux, stream);</span>
<span class="line-added"> 8749       fps_stream = stream;</span>
<span class="line-added"> 8750     }</span>
<span class="line-added"> 8751 </span>
<span class="line-added"> 8752     CUR_STREAM (stream)-&gt;caps =</span>
<span class="line-added"> 8753         gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);</span>
<span class="line-added"> 8754 </span>
<span class="line-added"> 8755     /* set framerate if calculated framerate is reliable */</span>
<span class="line-added"> 8756     if (fps_available) {</span>
<span class="line-added"> 8757       gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,</span>
<span class="line-added"> 8758           &quot;framerate&quot;, GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;fps_n,</span>
<span class="line-added"> 8759           CUR_STREAM (stream)-&gt;fps_d, NULL);</span>
<span class="line-added"> 8760     }</span>
<span class="line-added"> 8761   }</span>
<span class="line-added"> 8762 </span>
 8763   if (stream-&gt;pad) {
 8764     GstCaps *prev_caps = NULL;
 8765 
 8766     GST_PAD_ELEMENT_PRIVATE (stream-&gt;pad) = stream;
 8767     gst_pad_set_event_function (stream-&gt;pad, gst_qtdemux_handle_src_event);
 8768     gst_pad_set_query_function (stream-&gt;pad, gst_qtdemux_handle_src_query);
 8769     gst_pad_set_active (stream-&gt;pad, TRUE);
 8770 
 8771     gst_pad_use_fixed_caps (stream-&gt;pad);
 8772 
 8773     if (stream-&gt;protected) {
 8774       if (!gst_qtdemux_configure_protected_caps (qtdemux, stream)) {
 8775         GST_ERROR_OBJECT (qtdemux,
 8776             &quot;Failed to configure protected stream caps.&quot;);
 8777         return FALSE;
 8778       }
 8779     }
 8780 
 8781     GST_DEBUG_OBJECT (qtdemux, &quot;setting caps %&quot; GST_PTR_FORMAT,
 8782         CUR_STREAM (stream)-&gt;caps);
 8783     if (stream-&gt;new_stream) {

 8784       GstEvent *event;
 8785       GstStreamFlags stream_flags = GST_STREAM_FLAG_NONE;
 8786 
 8787       event =
 8788           gst_pad_get_sticky_event (qtdemux-&gt;sinkpad, GST_EVENT_STREAM_START,
 8789           0);
 8790       if (event) {
 8791         gst_event_parse_stream_flags (event, &amp;stream_flags);
 8792         if (gst_event_parse_group_id (event, &amp;qtdemux-&gt;group_id))
 8793           qtdemux-&gt;have_group_id = TRUE;
<span class="line-modified"> 8794         else</span>
 8795           qtdemux-&gt;have_group_id = FALSE;
 8796         gst_event_unref (event);
 8797       } else if (!qtdemux-&gt;have_group_id) {
 8798         qtdemux-&gt;have_group_id = TRUE;
 8799         qtdemux-&gt;group_id = gst_util_group_id_next ();
 8800       }
 8801 
 8802       stream-&gt;new_stream = FALSE;
<span class="line-modified"> 8803       event = gst_event_new_stream_start (stream-&gt;stream_id);</span>



 8804       if (qtdemux-&gt;have_group_id)
 8805         gst_event_set_group_id (event, qtdemux-&gt;group_id);
 8806       if (stream-&gt;disabled)
 8807         stream_flags |= GST_STREAM_FLAG_UNSELECT;
 8808       if (CUR_STREAM (stream)-&gt;sparse) {
 8809         stream_flags |= GST_STREAM_FLAG_SPARSE;
 8810       } else {
 8811         stream_flags &amp;= ~GST_STREAM_FLAG_SPARSE;
 8812       }
 8813       gst_event_set_stream_flags (event, stream_flags);
 8814       gst_pad_push_event (stream-&gt;pad, event);

 8815     }
 8816 
 8817     prev_caps = gst_pad_get_current_caps (stream-&gt;pad);
 8818 
 8819     if (CUR_STREAM (stream)-&gt;caps) {
 8820       if (!prev_caps
 8821           || !gst_caps_is_equal_fixed (prev_caps, CUR_STREAM (stream)-&gt;caps)) {
 8822         GST_DEBUG_OBJECT (qtdemux, &quot;setting caps %&quot; GST_PTR_FORMAT,
 8823             CUR_STREAM (stream)-&gt;caps);
 8824         gst_pad_set_caps (stream-&gt;pad, CUR_STREAM (stream)-&gt;caps);
 8825       } else {
 8826         GST_DEBUG_OBJECT (qtdemux, &quot;ignore duplicated caps&quot;);
 8827       }
 8828     } else {
 8829       GST_WARNING_OBJECT (qtdemux, &quot;stream without caps&quot;);
 8830     }
 8831 
 8832     if (prev_caps)
 8833       gst_caps_unref (prev_caps);
 8834     stream-&gt;new_caps = FALSE;
</pre>
<hr />
<pre>
 8845 
 8846   GST_DEBUG_OBJECT (stream-&gt;pad, &quot;Changing stsd index from &#39;%u&#39; to &#39;%u&#39;&quot;,
 8847       stream-&gt;cur_stsd_entry_index, stream-&gt;stsd_sample_description_id);
 8848   if (G_UNLIKELY (stream-&gt;stsd_sample_description_id &gt;=
 8849           stream-&gt;stsd_entries_length)) {
 8850     GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
 8851         (_(&quot;This file is invalid and cannot be played.&quot;)),
 8852         (&quot;New sample description id is out of bounds (%d &gt;= %d)&quot;,
 8853             stream-&gt;stsd_sample_description_id, stream-&gt;stsd_entries_length));
 8854   } else {
 8855     stream-&gt;cur_stsd_entry_index = stream-&gt;stsd_sample_description_id;
 8856     stream-&gt;new_caps = TRUE;
 8857   }
 8858 }
 8859 
 8860 static gboolean
 8861 gst_qtdemux_add_stream (GstQTDemux * qtdemux,
 8862     QtDemuxStream * stream, GstTagList * list)
 8863 {
 8864   gboolean ret = TRUE;


 8865 
 8866   if (stream-&gt;subtype == FOURCC_vide) {
 8867     gchar *name = g_strdup_printf (&quot;video_%u&quot;, qtdemux-&gt;n_video_streams);
 8868 
 8869     stream-&gt;pad =
 8870         gst_pad_new_from_static_template (&amp;gst_qtdemux_videosrc_template, name);
 8871     g_free (name);
 8872 
 8873     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8874       gst_object_unref (stream-&gt;pad);
 8875       stream-&gt;pad = NULL;
 8876       ret = FALSE;
 8877       goto done;
 8878     }
 8879 
 8880     qtdemux-&gt;n_video_streams++;
 8881   } else if (stream-&gt;subtype == FOURCC_soun) {
 8882     gchar *name = g_strdup_printf (&quot;audio_%u&quot;, qtdemux-&gt;n_audio_streams);
 8883 
 8884     stream-&gt;pad =
 8885         gst_pad_new_from_static_template (&amp;gst_qtdemux_audiosrc_template, name);
 8886     g_free (name);
 8887     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8888       gst_object_unref (stream-&gt;pad);
 8889       stream-&gt;pad = NULL;
 8890       ret = FALSE;
 8891       goto done;
 8892     }
 8893     qtdemux-&gt;n_audio_streams++;
 8894   } else if (stream-&gt;subtype == FOURCC_strm) {
 8895     GST_DEBUG_OBJECT (qtdemux, &quot;stream type, not creating pad&quot;);
 8896   } else if (stream-&gt;subtype == FOURCC_subp || stream-&gt;subtype == FOURCC_text
<span class="line-modified"> 8897       || stream-&gt;subtype == FOURCC_sbtl || stream-&gt;subtype == FOURCC_subt</span>
<span class="line-added"> 8898       || stream-&gt;subtype == FOURCC_clcp) {</span>
 8899     gchar *name = g_strdup_printf (&quot;subtitle_%u&quot;, qtdemux-&gt;n_sub_streams);
 8900 
 8901     stream-&gt;pad =
 8902         gst_pad_new_from_static_template (&amp;gst_qtdemux_subsrc_template, name);
 8903     g_free (name);
 8904     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8905       gst_object_unref (stream-&gt;pad);
 8906       stream-&gt;pad = NULL;
 8907       ret = FALSE;
 8908       goto done;
 8909     }
 8910     qtdemux-&gt;n_sub_streams++;
 8911   } else if (CUR_STREAM (stream)-&gt;caps) {
 8912     gchar *name = g_strdup_printf (&quot;video_%u&quot;, qtdemux-&gt;n_video_streams);
 8913 
 8914     stream-&gt;pad =
 8915         gst_pad_new_from_static_template (&amp;gst_qtdemux_videosrc_template, name);
 8916     g_free (name);
 8917     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8918       gst_object_unref (stream-&gt;pad);
</pre>
<hr />
<pre>
 9104 
 9105   /* time-to-sample atom */
 9106   if (!qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stts, &amp;stream-&gt;stts))
 9107     goto corrupt_file;
 9108 
 9109   /* copy atom data into a new buffer for later use */
 9110   stream-&gt;stts.data = g_memdup (stream-&gt;stts.data, stream-&gt;stts.size);
 9111 
 9112   /* skip version + flags */
 9113   if (!gst_byte_reader_skip (&amp;stream-&gt;stts, 1 + 3) ||
 9114       !gst_byte_reader_get_uint32_be (&amp;stream-&gt;stts, &amp;stream-&gt;n_sample_times))
 9115     goto corrupt_file;
 9116   GST_LOG_OBJECT (qtdemux, &quot;%u timestamp blocks&quot;, stream-&gt;n_sample_times);
 9117 
 9118   /* make sure there&#39;s enough data */
 9119   if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stts, stream-&gt;n_sample_times, 8)) {
 9120     stream-&gt;n_sample_times = gst_byte_reader_get_remaining (&amp;stream-&gt;stts) / 8;
 9121     GST_LOG_OBJECT (qtdemux, &quot;overriding to %u timestamp blocks&quot;,
 9122         stream-&gt;n_sample_times);
 9123     if (!stream-&gt;n_sample_times)
<span class="line-modified"> 9124       goto corrupt_file;</span>
 9125   }
 9126 
 9127   /* sync sample atom */
 9128   stream-&gt;stps_present = FALSE;
 9129   if ((stream-&gt;stss_present =
 9130           ! !qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stss,
 9131               &amp;stream-&gt;stss) ? TRUE : FALSE) == TRUE) {
 9132     /* copy atom data into a new buffer for later use */
 9133     stream-&gt;stss.data = g_memdup (stream-&gt;stss.data, stream-&gt;stss.size);
 9134 
 9135     /* skip version + flags */
 9136     if (!gst_byte_reader_skip (&amp;stream-&gt;stss, 1 + 3) ||
 9137         !gst_byte_reader_get_uint32_be (&amp;stream-&gt;stss, &amp;stream-&gt;n_sample_syncs))
 9138       goto corrupt_file;
 9139 
 9140     if (stream-&gt;n_sample_syncs) {
 9141       /* make sure there&#39;s enough data */
 9142       if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stss, stream-&gt;n_sample_syncs, 4))
 9143         goto corrupt_file;
 9144     }
</pre>
<hr />
<pre>
 9272     /* copy atom data into a new buffer for later use */
 9273     stream-&gt;ctts.data = g_memdup (stream-&gt;ctts.data, stream-&gt;ctts.size);
 9274 
 9275     /* skip version + flags */
 9276     if (!gst_byte_reader_skip (&amp;stream-&gt;ctts, 1 + 3)
 9277         || !gst_byte_reader_get_uint32_be (&amp;stream-&gt;ctts,
 9278             &amp;stream-&gt;n_composition_times))
 9279       goto corrupt_file;
 9280 
 9281     /* make sure there&#39;s enough data */
 9282     if (!qt_atom_parser_has_chunks (&amp;stream-&gt;ctts, stream-&gt;n_composition_times,
 9283             4 + 4))
 9284       goto corrupt_file;
 9285 
 9286     /* This is optional, if missing we iterate the ctts */
 9287     if (qtdemux_tree_get_child_by_type_full (stbl, FOURCC_cslg, &amp;cslg)) {
 9288       if (!gst_byte_reader_skip (&amp;cslg, 1 + 3)
 9289           || !gst_byte_reader_get_uint32_be (&amp;cslg, &amp;stream-&gt;cslg_shift)) {
 9290         g_free ((gpointer) cslg.data);
 9291         goto corrupt_file;
<span class="line-modified"> 9292       }</span>
 9293     } else {
 9294       gint32 cslg_least = 0;
 9295       guint num_entries, pos;
 9296       gint i;
 9297 
 9298       pos = gst_byte_reader_get_pos (&amp;stream-&gt;ctts);
 9299       num_entries = stream-&gt;n_composition_times;
 9300 
 9301       stream-&gt;cslg_shift = 0;
 9302 
 9303       for (i = 0; i &lt; num_entries; i++) {
 9304         gint32 offset;
 9305 
 9306         gst_byte_reader_skip_unchecked (&amp;stream-&gt;ctts, 4);
 9307         offset = gst_byte_reader_get_int32_be_unchecked (&amp;stream-&gt;ctts);
<span class="line-added"> 9308         /* HACK: if sample_offset is larger than 2 * duration, ignore the box.</span>
<span class="line-added"> 9309          * slightly inaccurate PTS could be more usable than corrupted one */</span>
<span class="line-added"> 9310         if (G_UNLIKELY ((ABS (offset) / 2) &gt; stream-&gt;duration)) {</span>
<span class="line-added"> 9311           GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-added"> 9312               &quot;Ignore corrupted ctts, sample_offset %&quot; G_GINT32_FORMAT</span>
<span class="line-added"> 9313               &quot; larger than duration %&quot; G_GUINT64_FORMAT,</span>
<span class="line-added"> 9314               offset, stream-&gt;duration);</span>
<span class="line-added"> 9315 </span>
<span class="line-added"> 9316           stream-&gt;cslg_shift = 0;</span>
<span class="line-added"> 9317           stream-&gt;ctts_present = FALSE;</span>
<span class="line-added"> 9318           return TRUE;</span>
<span class="line-added"> 9319         }</span>
 9320 
 9321         if (offset &lt; cslg_least)
 9322           cslg_least = offset;
 9323       }
 9324 
 9325       if (cslg_least &lt; 0)
 9326         stream-&gt;cslg_shift = ABS (cslg_least);
 9327       else
 9328         stream-&gt;cslg_shift = 0;
 9329 
 9330       /* reset the reader so we can generate sample table */
 9331       gst_byte_reader_set_pos (&amp;stream-&gt;ctts, pos);
 9332     }
 9333   } else {
 9334     /* Ensure the cslg_shift value is consistent so we can use it
 9335      * unconditionnally to produce TS and Segment */
 9336     stream-&gt;cslg_shift = 0;
 9337   }
 9338 
 9339   return TRUE;
</pre>
<hr />
<pre>
 9536           goto corrupt_file;
 9537 
 9538         samples_per_chunk = stream-&gt;samples_per_chunk;
 9539         chunk_offset = stream-&gt;chunk_offset;
 9540 
 9541         for (k = stream-&gt;stsc_sample_index; k &lt; samples_per_chunk; k++) {
 9542           GST_LOG_OBJECT (qtdemux, &quot;creating entry %d with offset %&quot;
 9543               G_GUINT64_FORMAT &quot; and size %d&quot;,
 9544               (guint) (cur - samples), chunk_offset, cur-&gt;size);
 9545 
 9546           cur-&gt;offset = chunk_offset;
 9547           chunk_offset += cur-&gt;size;
 9548           cur++;
 9549 
 9550           if (G_UNLIKELY (cur &gt; last)) {
 9551             /* save state */
 9552             stream-&gt;stsc_sample_index = k + 1;
 9553             stream-&gt;chunk_offset = chunk_offset;
 9554             stream-&gt;stsc_chunk_index = j;
 9555             goto done2;
<span class="line-modified"> 9556           }</span>
 9557         }
 9558         stream-&gt;stsc_sample_index = 0;
 9559       }
 9560       stream-&gt;stsc_chunk_index = j;
 9561     }
 9562     stream-&gt;stsc_index++;
 9563   }
 9564 
 9565   if (stream-&gt;chunks_are_samples)
 9566     goto ctts;
 9567 done2:
 9568   {
 9569     guint32 n_sample_times;
 9570 
 9571     n_sample_times = stream-&gt;n_sample_times;
 9572     cur = first;
 9573 
 9574     for (i = stream-&gt;stts_index; i &lt; n_sample_times; i++) {
 9575       guint32 stts_samples;
 9576       gint32 stts_duration;
</pre>
<hr />
<pre>
 9733         cur++;
 9734 
 9735         if (G_UNLIKELY (cur &gt; last)) {
 9736           /* save state */
 9737           stream-&gt;ctts_sample_index = j + 1;
 9738           goto done;
 9739         }
 9740       }
 9741       stream-&gt;ctts_sample_index = 0;
 9742       stream-&gt;ctts_index++;
 9743     }
 9744   }
 9745 done:
 9746   stream-&gt;stbl_index = n;
 9747   /* if index has been completely parsed, free data that is no-longer needed */
 9748   if (n + 1 == stream-&gt;n_samples) {
 9749     gst_qtdemux_stbl_free (stream);
 9750     GST_DEBUG_OBJECT (qtdemux, &quot;parsed all available samples;&quot;);
 9751     if (qtdemux-&gt;pullbased) {
 9752       GST_DEBUG_OBJECT (qtdemux, &quot;checking for more samples&quot;);
<span class="line-modified"> 9753       while (n + 1 == stream-&gt;n_samples)</span>
<span class="line-modified"> 9754         if (qtdemux_add_fragmented_samples (qtdemux) != GST_FLOW_OK)</span>
<span class="line-modified"> 9755           break;</span>
<span class="line-modified"> 9756     }</span>
 9757   }
 9758   GST_OBJECT_UNLOCK (qtdemux);
 9759 
 9760   return TRUE;
 9761 
 9762   /* SUCCESS */
 9763 already_parsed:
 9764   {
 9765     GST_LOG_OBJECT (qtdemux,
 9766         &quot;Tried to parse up to sample %u but this sample has already been parsed&quot;,
 9767         n);
 9768     /* if fragmented, there may be more */
 9769     if (qtdemux-&gt;fragmented &amp;&amp; n == stream-&gt;stbl_index)
 9770       goto done;
 9771     GST_OBJECT_UNLOCK (qtdemux);
 9772     return TRUE;
 9773   }
 9774   /* ERRORS */
 9775 out_of_samples:
 9776   {
</pre>
<hr />
<pre>
 9792 
 9793 /* collect all segment info for @stream.
 9794  */
 9795 static gboolean
 9796 qtdemux_parse_segments (GstQTDemux * qtdemux, QtDemuxStream * stream,
 9797     GNode * trak)
 9798 {
 9799   GNode *edts;
 9800   /* accept edts if they contain gaps at start and there is only
 9801    * one media segment */
 9802   gboolean allow_pushbased_edts = TRUE;
 9803   gint media_segments_count = 0;
 9804 
 9805   /* parse and prepare segment info from the edit list */
 9806   GST_DEBUG_OBJECT (qtdemux, &quot;looking for edit list container&quot;);
 9807   stream-&gt;n_segments = 0;
 9808   stream-&gt;segments = NULL;
 9809   if ((edts = qtdemux_tree_get_child_by_type (trak, FOURCC_edts))) {
 9810     GNode *elst;
 9811     gint n_segments;
<span class="line-modified"> 9812     gint segment_number, entry_size;</span>
 9813     guint64 time;
 9814     GstClockTime stime;
 9815     const guint8 *buffer;
 9816     guint8 version;
 9817     guint32 size;
 9818 
 9819     GST_DEBUG_OBJECT (qtdemux, &quot;looking for edit list&quot;);
 9820     if (!(elst = qtdemux_tree_get_child_by_type (edts, FOURCC_elst)))
 9821       goto done;
 9822 
 9823     buffer = elst-&gt;data;
 9824 
 9825     size = QT_UINT32 (buffer);
 9826     /* version, flags, n_segments */
 9827     if (size &lt; 16) {
 9828       GST_WARNING_OBJECT (qtdemux, &quot;Invalid edit list&quot;);
 9829       goto done;
 9830     }
 9831     version = QT_UINT8 (buffer + 8);
 9832     entry_size = (version == 1) ? 20 : 12;
 9833 
 9834     n_segments = QT_UINT32 (buffer + 12);
 9835 
 9836     if (n_segments &gt; 100000 || size &lt; 16 + n_segments * entry_size) {
 9837       GST_WARNING_OBJECT (qtdemux, &quot;Invalid edit list&quot;);
 9838       goto done;
 9839     }
 9840 
 9841     /* we might allocate a bit too much, at least allocate 1 segment */
 9842     stream-&gt;segments = g_new (QtDemuxSegment, MAX (n_segments, 1));
 9843 
 9844     /* segments always start from 0 */
 9845     time = 0;
 9846     stime = 0;

 9847     buffer += 16;
<span class="line-modified"> 9848     for (segment_number = 0; segment_number &lt; n_segments; segment_number++) {</span>
 9849       guint64 duration;
 9850       guint64 media_time;
<span class="line-modified"> 9851       gboolean empty_edit = FALSE;</span>
 9852       QtDemuxSegment *segment;
 9853       guint32 rate_int;
 9854       GstClockTime media_start = GST_CLOCK_TIME_NONE;
 9855 
<span class="line-modified"> 9856       if (version == 1) {</span>
 9857         media_time = QT_UINT64 (buffer + 8);
 9858         duration = QT_UINT64 (buffer);
 9859         if (media_time == G_MAXUINT64)
<span class="line-modified"> 9860           empty_edit = TRUE;</span>
 9861       } else {
 9862         media_time = QT_UINT32 (buffer + 4);
 9863         duration = QT_UINT32 (buffer);
 9864         if (media_time == G_MAXUINT32)
<span class="line-modified"> 9865           empty_edit = TRUE;</span>
 9866       }
 9867 
<span class="line-modified"> 9868       if (!empty_edit)</span>
 9869         media_start = QTSTREAMTIME_TO_GSTTIME (stream, media_time);
 9870 
<span class="line-modified"> 9871       segment = &amp;stream-&gt;segments[segment_number];</span>
 9872 
 9873       /* time and duration expressed in global timescale */
 9874       segment-&gt;time = stime;
<span class="line-modified"> 9875       if (duration != 0 || empty_edit) {</span>
<span class="line-modified"> 9876         /* edge case: empty edits with duration=zero are treated here.</span>
<span class="line-modified"> 9877          * (files should not have these anyway). */</span>
<span class="line-added"> 9878 </span>
<span class="line-added"> 9879         /* add non scaled values so we don&#39;t cause roundoff errors */</span>
<span class="line-added"> 9880         time += duration;</span>
 9881         stime = QTTIME_TO_GSTTIME (qtdemux, time);
 9882         segment-&gt;duration = stime - segment-&gt;time;
 9883       } else {
 9884         /* zero duration does not imply media_start == media_stop
<span class="line-modified"> 9885          * but, only specify media_start. The edit ends with the track. */</span>
<span class="line-modified"> 9886         stime = segment-&gt;duration = GST_CLOCK_TIME_NONE;</span>
<span class="line-modified"> 9887         /* Don&#39;t allow more edits after this one. */</span>
<span class="line-modified"> 9888         n_segments = segment_number + 1;</span>




 9889       }
 9890       segment-&gt;stop_time = stime;
 9891 
 9892       segment-&gt;trak_media_start = media_time;
 9893       /* media_time expressed in stream timescale */
<span class="line-modified"> 9894       if (!empty_edit) {</span>
 9895         segment-&gt;media_start = media_start;
<span class="line-modified"> 9896         segment-&gt;media_stop = GST_CLOCK_TIME_IS_VALID (segment-&gt;duration)</span>
<span class="line-added"> 9897             ? segment-&gt;media_start + segment-&gt;duration : GST_CLOCK_TIME_NONE;</span>
 9898         media_segments_count++;
 9899       } else {
 9900         segment-&gt;media_start = GST_CLOCK_TIME_NONE;
 9901         segment-&gt;media_stop = GST_CLOCK_TIME_NONE;
 9902       }
 9903       rate_int = QT_UINT32 (buffer + ((version == 1) ? 16 : 8));
 9904 
 9905       if (rate_int &lt;= 1) {
 9906         /* 0 is not allowed, some programs write 1 instead of the floating point
 9907          * value */
 9908         GST_WARNING_OBJECT (qtdemux, &quot;found suspicious rate %&quot; G_GUINT32_FORMAT,
 9909             rate_int);
 9910         segment-&gt;rate = 1;
 9911       } else {
 9912         segment-&gt;rate = rate_int / 65536.0;
 9913       }
 9914 
 9915       GST_DEBUG_OBJECT (qtdemux, &quot;created segment %d time %&quot; GST_TIME_FORMAT
 9916           &quot;, duration %&quot; GST_TIME_FORMAT &quot;, media_start %&quot; GST_TIME_FORMAT
 9917           &quot; (%&quot; G_GUINT64_FORMAT &quot;) , media_stop %&quot; GST_TIME_FORMAT
 9918           &quot; stop_time %&quot; GST_TIME_FORMAT &quot; rate %g, (%d) timescale %u&quot;,
<span class="line-modified"> 9919           segment_number, GST_TIME_ARGS (segment-&gt;time),</span>
 9920           GST_TIME_ARGS (segment-&gt;duration),
 9921           GST_TIME_ARGS (segment-&gt;media_start), media_time,
 9922           GST_TIME_ARGS (segment-&gt;media_stop),
 9923           GST_TIME_ARGS (segment-&gt;stop_time), segment-&gt;rate, rate_int,
 9924           stream-&gt;timescale);
<span class="line-modified"> 9925       if (segment-&gt;stop_time &gt; qtdemux-&gt;segment.stop &amp;&amp;</span>
<span class="line-added"> 9926           !qtdemux-&gt;upstream_format_is_time) {</span>
 9927         GST_WARNING_OBJECT (qtdemux, &quot;Segment %d &quot;
 9928             &quot; extends to %&quot; GST_TIME_FORMAT
<span class="line-modified"> 9929             &quot; past the end of the declared movie duration %&quot; GST_TIME_FORMAT</span>
<span class="line-modified"> 9930             &quot; movie segment will be extended&quot;, segment_number,</span>
<span class="line-added"> 9931             GST_TIME_ARGS (segment-&gt;stop_time),</span>
 9932             GST_TIME_ARGS (qtdemux-&gt;segment.stop));
<span class="line-modified"> 9933         qtdemux-&gt;segment.stop = qtdemux-&gt;segment.duration = segment-&gt;stop_time;</span>
<span class="line-modified"> 9934       }</span>
 9935 
 9936       buffer += entry_size;
 9937     }
<span class="line-modified"> 9938     GST_DEBUG_OBJECT (qtdemux, &quot;found %d segments&quot;, n_segments);</span>
<span class="line-modified"> 9939     stream-&gt;n_segments = n_segments;</span>
 9940     if (media_segments_count != 1)
 9941       allow_pushbased_edts = FALSE;
 9942   }
 9943 done:
 9944 
 9945   /* push based does not handle segments, so act accordingly here,
 9946    * and warn if applicable */
 9947   if (!qtdemux-&gt;pullbased &amp;&amp; !allow_pushbased_edts) {
 9948     GST_WARNING_OBJECT (qtdemux, &quot;streaming; discarding edit list segments&quot;);
 9949     /* remove and use default one below, we stream like it anyway */
 9950     g_free (stream-&gt;segments);
 9951     stream-&gt;segments = NULL;
 9952     stream-&gt;n_segments = 0;
 9953   }
 9954 
 9955   /* no segments, create one to play the complete trak */
 9956   if (stream-&gt;n_segments == 0) {
 9957     GstClockTime stream_duration =
 9958         QTSTREAMTIME_TO_GSTTIME (stream, stream-&gt;duration);
 9959 
</pre>
<hr />
<pre>
10312   } else {
10313     GST_FIXME_OBJECT (qtdemux, &quot;Unhandled transformation matrix values&quot;);
10314   }
10315 }
10316 
10317 /* Parses the boxes defined in ISO/IEC 14496-12 that enable support for
10318  * protected streams (sinf, frma, schm and schi); if the protection scheme is
10319  * Common Encryption (cenc), the function will also parse the tenc box (defined
10320  * in ISO/IEC 23001-7). @container points to the node that contains these boxes
10321  * (typically an enc[v|a|t|s] sample entry); the function will set
10322  * @original_fmt to the fourcc of the original unencrypted stream format.
10323  * Returns TRUE if successful; FALSE otherwise. */
10324 static gboolean
10325 qtdemux_parse_protection_scheme_info (GstQTDemux * qtdemux,
10326     QtDemuxStream * stream, GNode * container, guint32 * original_fmt)
10327 {
10328   GNode *sinf;
10329   GNode *frma;
10330   GNode *schm;
10331   GNode *schi;
<span class="line-added">10332   QtDemuxCencSampleSetInfo *info;</span>
<span class="line-added">10333   GNode *tenc;</span>
<span class="line-added">10334   const guint8 *tenc_data;</span>
10335 
10336   g_return_val_if_fail (qtdemux != NULL, FALSE);
10337   g_return_val_if_fail (stream != NULL, FALSE);
10338   g_return_val_if_fail (container != NULL, FALSE);
10339   g_return_val_if_fail (original_fmt != NULL, FALSE);
10340 
10341   sinf = qtdemux_tree_get_child_by_type (container, FOURCC_sinf);
10342   if (G_UNLIKELY (!sinf)) {
10343     if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
10344       GST_ERROR_OBJECT (qtdemux, &quot;sinf box does not contain schi box, which is &quot;
10345           &quot;mandatory for Common Encryption&quot;);
10346       return FALSE;
10347     }
10348     return TRUE;
10349   }
10350 
10351   frma = qtdemux_tree_get_child_by_type (sinf, FOURCC_frma);
10352   if (G_UNLIKELY (!frma)) {
10353     GST_ERROR_OBJECT (qtdemux, &quot;sinf box does not contain mandatory frma box&quot;);
10354     return FALSE;
</pre>
<hr />
<pre>
10361   schm = qtdemux_tree_get_child_by_type (sinf, FOURCC_schm);
10362   if (!schm) {
10363     GST_DEBUG_OBJECT (qtdemux, &quot;sinf box does not contain schm box&quot;);
10364     return FALSE;
10365   }
10366   stream-&gt;protection_scheme_type = QT_FOURCC ((const guint8 *) schm-&gt;data + 12);
10367   stream-&gt;protection_scheme_version =
10368       QT_UINT32 ((const guint8 *) schm-&gt;data + 16);
10369 
10370   GST_DEBUG_OBJECT (qtdemux,
10371       &quot;protection_scheme_type: %&quot; GST_FOURCC_FORMAT &quot;, &quot;
10372       &quot;protection_scheme_version: %#010x&quot;,
10373       GST_FOURCC_ARGS (stream-&gt;protection_scheme_type),
10374       stream-&gt;protection_scheme_version);
10375 
10376   schi = qtdemux_tree_get_child_by_type (sinf, FOURCC_schi);
10377   if (!schi) {
10378     GST_DEBUG_OBJECT (qtdemux, &quot;sinf box does not contain schi box&quot;);
10379     return FALSE;
10380   }
<span class="line-added">10381   if (stream-&gt;protection_scheme_type != FOURCC_cenc &amp;&amp;</span>
<span class="line-added">10382       stream-&gt;protection_scheme_type != FOURCC_piff) {</span>
<span class="line-added">10383     GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added">10384         &quot;Invalid protection_scheme_type: %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added">10385         GST_FOURCC_ARGS (stream-&gt;protection_scheme_type));</span>
<span class="line-added">10386     return FALSE;</span>
<span class="line-added">10387   }</span>
<span class="line-added">10388 </span>
<span class="line-added">10389   if (G_UNLIKELY (!stream-&gt;protection_scheme_info))</span>
<span class="line-added">10390     stream-&gt;protection_scheme_info =</span>
<span class="line-added">10391         g_malloc0 (sizeof (QtDemuxCencSampleSetInfo));</span>
<span class="line-added">10392 </span>
<span class="line-added">10393   info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;</span>
<span class="line-added">10394 </span>
10395   if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
<span class="line-modified">10396     guint32 is_encrypted;</span>



10397     guint8 iv_size;
10398     const guint8 *default_kid;







10399 
10400     tenc = qtdemux_tree_get_child_by_type (schi, FOURCC_tenc);
10401     if (!tenc) {
10402       GST_ERROR_OBJECT (qtdemux, &quot;schi box does not contain tenc box, &quot;
10403           &quot;which is mandatory for Common Encryption&quot;);
10404       return FALSE;
10405     }
10406     tenc_data = (const guint8 *) tenc-&gt;data + 12;
<span class="line-modified">10407     is_encrypted = QT_UINT24 (tenc_data);</span>
10408     iv_size = QT_UINT8 (tenc_data + 3);
10409     default_kid = (tenc_data + 4);
<span class="line-modified">10410     qtdemux_update_default_sample_encryption_settings (qtdemux, info,</span>
<span class="line-modified">10411         is_encrypted, iv_size, default_kid);</span>
<span class="line-modified">10412   } else if (stream-&gt;protection_scheme_type == FOURCC_piff) {</span>
<span class="line-modified">10413     GstByteReader br;</span>
<span class="line-modified">10414     static const guint8 piff_track_encryption_uuid[] = {</span>
<span class="line-modified">10415       0x89, 0x74, 0xdb, 0xce, 0x7b, 0xe7, 0x4c, 0x51,</span>
<span class="line-modified">10416       0x84, 0xf9, 0x71, 0x48, 0xf9, 0x88, 0x25, 0x54</span>
<span class="line-modified">10417     };</span>
<span class="line-modified">10418 </span>
<span class="line-modified">10419     tenc = qtdemux_tree_get_child_by_type (schi, FOURCC_uuid);</span>
<span class="line-modified">10420     if (!tenc) {</span>
<span class="line-modified">10421       GST_ERROR_OBJECT (qtdemux, &quot;schi box does not contain tenc box, &quot;</span>
<span class="line-added">10422           &quot;which is mandatory for Common Encryption&quot;);</span>
<span class="line-added">10423       return FALSE;</span>
<span class="line-added">10424     }</span>
<span class="line-added">10425 </span>
<span class="line-added">10426     tenc_data = (const guint8 *) tenc-&gt;data + 8;</span>
<span class="line-added">10427     if (memcmp (tenc_data, piff_track_encryption_uuid, 16) != 0) {</span>
<span class="line-added">10428       gchar *box_uuid = qtdemux_uuid_bytes_to_string (tenc_data);</span>
<span class="line-added">10429       GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added">10430           &quot;Unsupported track encryption box with uuid: %s&quot;, box_uuid);</span>
<span class="line-added">10431       g_free (box_uuid);</span>
<span class="line-added">10432       return FALSE;</span>
<span class="line-added">10433     }</span>
<span class="line-added">10434     tenc_data = (const guint8 *) tenc-&gt;data + 16 + 12;</span>
<span class="line-added">10435     gst_byte_reader_init (&amp;br, tenc_data, 20);</span>
<span class="line-added">10436     if (!qtdemux_update_default_piff_encryption_settings (qtdemux, info, &amp;br)) {</span>
<span class="line-added">10437       GST_ERROR_OBJECT (qtdemux, &quot;PIFF track box parsing error&quot;);</span>
<span class="line-added">10438       return FALSE;</span>
<span class="line-added">10439     }</span>
<span class="line-added">10440     stream-&gt;protection_scheme_type = FOURCC_cenc;</span>
10441   }
<span class="line-added">10442 </span>
10443   return TRUE;
10444 }
10445 
<span class="line-added">10446 static gint</span>
<span class="line-added">10447 qtdemux_track_id_compare_func (QtDemuxStream ** stream1,</span>
<span class="line-added">10448     QtDemuxStream ** stream2)</span>
<span class="line-added">10449 {</span>
<span class="line-added">10450   return (gint) (*stream1)-&gt;track_id - (gint) (*stream2)-&gt;track_id;</span>
<span class="line-added">10451 }</span>
<span class="line-added">10452 </span>
10453 /* parse the traks.
10454  * With each track we associate a new QtDemuxStream that contains all the info
10455  * about the trak.
10456  * traks that do not decode to something (like strm traks) will not have a pad.
10457  */
10458 static gboolean
10459 qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
10460 {
10461   GstByteReader tkhd;
10462   int offset;
10463   GNode *mdia;
10464   GNode *mdhd;
10465   GNode *hdlr;
10466   GNode *minf;
10467   GNode *stbl;
10468   GNode *stsd;
10469   GNode *mp4a;
10470   GNode *mp4v;
10471   GNode *esds;
10472   GNode *tref;
10473   GNode *udta;
10474   GNode *svmi;
10475 
10476   QtDemuxStream *stream = NULL;

10477   const guint8 *stsd_data;
10478   const guint8 *stsd_entry_data;
10479   guint remaining_stsd_len;
10480   guint stsd_entry_count;
10481   guint stsd_index;
10482   guint16 lang_code;            /* quicktime lang code or packed iso code */
10483   guint32 version;
10484   guint32 tkhd_flags = 0;
10485   guint8 tkhd_version = 0;
10486   guint32 w = 0, h = 0;
10487   guint value_size, stsd_len, len;
10488   guint32 track_id;
10489   guint32 dummy;
10490 
10491   GST_DEBUG_OBJECT (qtdemux, &quot;parse_trak&quot;);
10492 
10493   if (!qtdemux_tree_get_child_by_type_full (trak, FOURCC_tkhd, &amp;tkhd)
10494       || !gst_byte_reader_get_uint8 (&amp;tkhd, &amp;tkhd_version)
10495       || !gst_byte_reader_get_uint24_be (&amp;tkhd, &amp;tkhd_flags))
10496     goto corrupt_file;
10497 
10498   /* pick between 64 or 32 bits */
10499   value_size = tkhd_version == 1 ? 8 : 4;
10500   if (!gst_byte_reader_skip (&amp;tkhd, value_size * 2) ||
10501       !gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;track_id))
10502     goto corrupt_file;
10503 
<span class="line-modified">10504   /* Check if current moov has duplicated track_id */</span>
<span class="line-modified">10505   if (qtdemux_find_stream (qtdemux, track_id))</span>
<span class="line-modified">10506     goto existing_stream;</span>
<span class="line-modified">10507 </span>
<span class="line-modified">10508   stream = _create_stream (qtdemux, track_id);</span>
<span class="line-modified">10509   stream-&gt;stream_tags = gst_tag_list_make_writable (stream-&gt;stream_tags);</span>






10510 



10511   /* need defaults for fragments */
10512   qtdemux_parse_trex (qtdemux, stream, &amp;dummy, &amp;dummy, &amp;dummy);
10513 
10514   if ((tkhd_flags &amp; 1) == 0)
10515     stream-&gt;disabled = TRUE;
10516 
10517 #ifdef GSTREAMER_LITE
10518   // set track_enabled based on bit 0 of flags
10519   stream-&gt;track_enabled = (gboolean)(tkhd_flags &amp; 0x000001);
10520 #endif // GSTREAMER_LITE
10521 
10522   GST_LOG_OBJECT (qtdemux, &quot;track[tkhd] version/flags/id: 0x%02x/%06x/%u&quot;,
10523       tkhd_version, tkhd_flags, stream-&gt;track_id);
10524 
10525   if (!(mdia = qtdemux_tree_get_child_by_type (trak, FOURCC_mdia)))
10526     goto corrupt_file;
10527 
10528   if (!(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mdhd))) {
10529     /* be nice for some crooked mjp2 files that use mhdr for mdhd */
10530     if (qtdemux-&gt;major_brand != FOURCC_mjp2 ||
10531         !(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mhdr)))
10532       goto corrupt_file;
10533   }
10534 
10535   len = QT_UINT32 ((guint8 *) mdhd-&gt;data);
10536   version = QT_UINT32 ((guint8 *) mdhd-&gt;data + 8);
10537   GST_LOG_OBJECT (qtdemux, &quot;track version/flags: %08x&quot;, version);
10538   if (version == 0x01000000) {
<span class="line-modified">10539     if (len &lt; 42)</span>
10540       goto corrupt_file;
10541     stream-&gt;timescale = QT_UINT32 ((guint8 *) mdhd-&gt;data + 28);
10542     stream-&gt;duration = QT_UINT64 ((guint8 *) mdhd-&gt;data + 32);
<span class="line-modified">10543     lang_code = QT_UINT16 ((guint8 *) mdhd-&gt;data + 40);</span>
10544   } else {
10545     if (len &lt; 30)
10546       goto corrupt_file;
10547     stream-&gt;timescale = QT_UINT32 ((guint8 *) mdhd-&gt;data + 20);
10548     stream-&gt;duration = QT_UINT32 ((guint8 *) mdhd-&gt;data + 24);
10549     lang_code = QT_UINT16 ((guint8 *) mdhd-&gt;data + 28);
10550   }
10551 
10552   if (lang_code &lt; 0x400) {
10553     qtdemux_lang_map_qt_code_to_iso (stream-&gt;lang_id, lang_code);
10554   } else if (lang_code == 0x7fff) {
10555     stream-&gt;lang_id[0] = 0;     /* unspecified */
10556   } else {
10557     stream-&gt;lang_id[0] = 0x60 + ((lang_code &gt;&gt; 10) &amp; 0x1F);
10558     stream-&gt;lang_id[1] = 0x60 + ((lang_code &gt;&gt; 5) &amp; 0x1F);
10559     stream-&gt;lang_id[2] = 0x60 + (lang_code &amp; 0x1F);
10560     stream-&gt;lang_id[3] = 0;
10561   }
10562 
10563   GST_LOG_OBJECT (qtdemux, &quot;track timescale: %&quot; G_GUINT32_FORMAT,
</pre>
<hr />
<pre>
10588   /* fragmented files may have bogus duration in moov */
10589   if (!qtdemux-&gt;fragmented &amp;&amp;
10590       qtdemux-&gt;duration != G_MAXINT64 &amp;&amp; stream-&gt;duration != G_MAXINT32) {
10591     guint64 tdur1, tdur2;
10592 
10593     /* don&#39;t overflow */
10594     tdur1 = stream-&gt;timescale * (guint64) qtdemux-&gt;duration;
10595     tdur2 = qtdemux-&gt;timescale * (guint64) stream-&gt;duration;
10596 
10597     /* HACK:
10598      * some of those trailers, nowadays, have prologue images that are
10599      * themselves video tracks as well. I haven&#39;t really found a way to
10600      * identify those yet, except for just looking at their duration. */
10601     if (tdur1 != 0 &amp;&amp; (tdur2 * 10 / tdur1) &lt; 2) {
10602       GST_WARNING_OBJECT (qtdemux,
10603           &quot;Track shorter than 20%% (%&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT32_FORMAT
10604           &quot; vs. %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT32_FORMAT &quot;) of the stream &quot;
10605           &quot;found, assuming preview image or something; skipping track&quot;,
10606           stream-&gt;duration, stream-&gt;timescale, qtdemux-&gt;duration,
10607           qtdemux-&gt;timescale);
<span class="line-modified">10608       gst_qtdemux_stream_unref (stream);</span>

10609       return TRUE;
10610     }
10611   }
10612 
10613   if (!(hdlr = qtdemux_tree_get_child_by_type (mdia, FOURCC_hdlr)))
10614     goto corrupt_file;
10615 
10616   GST_LOG_OBJECT (qtdemux, &quot;track type: %&quot; GST_FOURCC_FORMAT,
10617       GST_FOURCC_ARGS (QT_FOURCC ((guint8 *) hdlr-&gt;data + 12)));
10618 
10619   len = QT_UINT32 ((guint8 *) hdlr-&gt;data);
10620   if (len &gt;= 20)
10621     stream-&gt;subtype = QT_FOURCC ((guint8 *) hdlr-&gt;data + 16);
10622   GST_LOG_OBJECT (qtdemux, &quot;track subtype: %&quot; GST_FOURCC_FORMAT,
10623       GST_FOURCC_ARGS (stream-&gt;subtype));
10624 
10625   if (!(minf = qtdemux_tree_get_child_by_type (mdia, FOURCC_minf)))
10626     goto corrupt_file;
10627 
10628   if (!(stbl = qtdemux_tree_get_child_by_type (minf, FOURCC_stbl)))
</pre>
<hr />
<pre>
10685       goto corrupt_file;
10686 
10687     if (!gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;w)
10688         || !gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;h))
10689       goto corrupt_file;
10690 
10691     qtdemux_inspect_transformation_matrix (qtdemux, stream, matrix,
10692         &amp;stream-&gt;stream_tags);
10693   }
10694 
10695   /* parse stsd */
10696   if (!(stsd = qtdemux_tree_get_child_by_type (stbl, FOURCC_stsd)))
10697     goto corrupt_file;
10698   stsd_data = (const guint8 *) stsd-&gt;data;
10699 
10700   /* stsd should at least have one entry */
10701   stsd_len = QT_UINT32 (stsd_data);
10702   if (stsd_len &lt; 24) {
10703     /* .. but skip stream with empty stsd produced by some Vivotek cameras */
10704     if (stream-&gt;subtype == FOURCC_vivo) {
<span class="line-modified">10705       gst_qtdemux_stream_unref (stream);</span>

10706       return TRUE;
10707     } else {
<span class="line-modified">10708       goto corrupt_file;</span>
10709     }
10710   }
10711 
10712   stream-&gt;stsd_entries_length = stsd_entry_count = QT_UINT32 (stsd_data + 12);
10713   stream-&gt;stsd_entries = g_new0 (QtDemuxStreamStsdEntry, stsd_entry_count);
10714 #ifdef GSTREAMER_LITE
10715   // Even if we check stsd header length (stsd_len) to make sure we have at least
10716   // one entry, we still might have actual entry count set to 0. g_new0() will
10717   // return NULL if fail or count is 0.
10718   if (stream-&gt;stsd_entries == NULL) {
10719     goto corrupt_file;
10720   }
10721 #endif // GSTREAMER_LITE
10722   GST_LOG_OBJECT (qtdemux, &quot;stsd len:           %d&quot;, stsd_len);
10723   GST_LOG_OBJECT (qtdemux, &quot;stsd entry count:   %u&quot;, stsd_entry_count);
10724 
10725   stsd_entry_data = stsd_data + 16;
10726   remaining_stsd_len = stsd_len - 16;
10727   for (stsd_index = 0; stsd_index &lt; stsd_entry_count; stsd_index++) {
10728     guint32 fourcc;
10729     gchar *codec = NULL;
10730     QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[stsd_index];
10731 
<span class="line-modified">10732     /* and that entry should fit within stsd */</span>
10733     len = QT_UINT32 (stsd_entry_data);
10734     if (len &gt; remaining_stsd_len)
<span class="line-modified">10735       goto corrupt_file;</span>
10736 
10737     entry-&gt;fourcc = fourcc = QT_FOURCC (stsd_entry_data + 4);
<span class="line-modified">10738     GST_LOG_OBJECT (qtdemux, &quot;stsd type:          %&quot; GST_FOURCC_FORMAT,</span>
10739         GST_FOURCC_ARGS (entry-&gt;fourcc));
<span class="line-modified">10740     GST_LOG_OBJECT (qtdemux, &quot;stsd type len:      %d&quot;, len);</span>
10741 
10742     if ((fourcc == FOURCC_drms) || (fourcc == FOURCC_drmi))
<span class="line-modified">10743       goto error_encrypted;</span>
10744 
10745     if (fourcc == FOURCC_encv || fourcc == FOURCC_enca) {
10746       /* FIXME this looks wrong, there might be multiple children
10747        * with the same type */
10748       GNode *enc = qtdemux_tree_get_child_by_type (stsd, fourcc);
10749       stream-&gt;protected = TRUE;
10750       if (!qtdemux_parse_protection_scheme_info (qtdemux, stream, enc, &amp;fourcc))
10751         GST_ERROR_OBJECT (qtdemux, &quot;Failed to parse protection scheme info&quot;);
10752     }
10753 
<span class="line-modified">10754     if (stream-&gt;subtype == FOURCC_vide) {</span>
10755       GNode *colr;
10756       GNode *fiel;
10757       GNode *pasp;
<span class="line-modified">10758       gboolean gray;</span>
<span class="line-modified">10759       gint depth, palette_size, palette_count;</span>
<span class="line-modified">10760       guint32 *palette_data = NULL;</span>
10761 
10762       entry-&gt;sampled = TRUE;
10763 
<span class="line-modified">10764       stream-&gt;display_width = w &gt;&gt; 16;</span>
<span class="line-modified">10765       stream-&gt;display_height = h &gt;&gt; 16;</span>
10766 
<span class="line-modified">10767       offset = 16;</span>
10768       if (len &lt; 86)             /* TODO verify */
<span class="line-modified">10769         goto corrupt_file;</span>
10770 
10771       entry-&gt;width = QT_UINT16 (stsd_entry_data + offset + 16);
10772       entry-&gt;height = QT_UINT16 (stsd_entry_data + offset + 18);
10773       entry-&gt;fps_n = 0;         /* this is filled in later */
10774       entry-&gt;fps_d = 0;         /* this is filled in later */
10775       entry-&gt;bits_per_sample = QT_UINT16 (stsd_entry_data + offset + 66);
10776       entry-&gt;color_table_id = QT_UINT16 (stsd_entry_data + offset + 68);
10777 
10778       /* if color_table_id is 0, ctab atom must follow; however some files
10779        * produced by TMPEGEnc have color_table_id = 0 and no ctab atom, so
10780        * if color table is not present we&#39;ll correct the value */
10781       if (entry-&gt;color_table_id == 0 &amp;&amp;
10782           (len &lt; 90
10783               || QT_FOURCC (stsd_entry_data + offset + 70) != FOURCC_ctab)) {
10784         entry-&gt;color_table_id = -1;
10785       }
10786 
<span class="line-modified">10787       GST_LOG_OBJECT (qtdemux, &quot;width %d, height %d, bps %d, color table id %d&quot;,</span>
10788           entry-&gt;width, entry-&gt;height, entry-&gt;bits_per_sample,
10789           entry-&gt;color_table_id);
10790 
10791       depth = entry-&gt;bits_per_sample;
10792 
<span class="line-modified">10793       /* more than 32 bits means grayscale */</span>
<span class="line-modified">10794       gray = (depth &gt; 32);</span>
<span class="line-modified">10795       /* low 32 bits specify the depth  */</span>
<span class="line-modified">10796       depth &amp;= 0x1F;</span>
10797 
<span class="line-modified">10798       /* different number of palette entries is determined by depth. */</span>
<span class="line-modified">10799       palette_count = 0;</span>
<span class="line-modified">10800       if ((depth == 1) || (depth == 2) || (depth == 4) || (depth == 8))</span>
<span class="line-modified">10801         palette_count = (1 &lt;&lt; depth);</span>
<span class="line-modified">10802       palette_size = palette_count * 4;</span>
10803 
10804       if (entry-&gt;color_table_id) {
<span class="line-modified">10805         switch (palette_count) {</span>
<span class="line-modified">10806           case 0:</span>
<span class="line-modified">10807             break;</span>
<span class="line-modified">10808           case 2:</span>
<span class="line-modified">10809             palette_data = g_memdup (ff_qt_default_palette_2, palette_size);</span>
<span class="line-modified">10810             break;</span>
<span class="line-modified">10811           case 4:</span>
<span class="line-modified">10812             palette_data = g_memdup (ff_qt_default_palette_4, palette_size);</span>
<span class="line-modified">10813             break;</span>
<span class="line-modified">10814           case 16:</span>
<span class="line-modified">10815             if (gray)</span>
10816               palette_data =
10817                   g_memdup (ff_qt_grayscale_palette_16, palette_size);
<span class="line-modified">10818             else</span>
<span class="line-modified">10819               palette_data = g_memdup (ff_qt_default_palette_16, palette_size);</span>
<span class="line-modified">10820             break;</span>
<span class="line-modified">10821           case 256:</span>
<span class="line-modified">10822             if (gray)</span>
10823               palette_data =
10824                   g_memdup (ff_qt_grayscale_palette_256, palette_size);
<span class="line-modified">10825             else</span>
<span class="line-modified">10826               palette_data = g_memdup (ff_qt_default_palette_256, palette_size);</span>
<span class="line-modified">10827             break;</span>
<span class="line-modified">10828           default:</span>
<span class="line-modified">10829             GST_ELEMENT_WARNING (qtdemux, STREAM, DEMUX,</span>
<span class="line-modified">10830                 (_(&quot;The video in this file might not play correctly.&quot;)),</span>
<span class="line-modified">10831                 (&quot;unsupported palette depth %d&quot;, depth));</span>
<span class="line-modified">10832             break;</span>
<span class="line-modified">10833         }</span>
<span class="line-modified">10834       } else {</span>
<span class="line-modified">10835         gint i, j, start, end;</span>
10836 
<span class="line-modified">10837         if (len &lt; 94)</span>
<span class="line-modified">10838           goto corrupt_file;</span>
10839 
<span class="line-modified">10840         /* read table */</span>
10841         start = QT_UINT32 (stsd_entry_data + offset + 70);
10842         palette_count = QT_UINT16 (stsd_entry_data + offset + 74);
10843         end = QT_UINT16 (stsd_entry_data + offset + 76);
10844 
<span class="line-modified">10845         GST_LOG_OBJECT (qtdemux, &quot;start %d, end %d, palette_count %d&quot;,</span>
<span class="line-modified">10846             start, end, palette_count);</span>
10847 
<span class="line-modified">10848         if (end &gt; 255)</span>
<span class="line-modified">10849           end = 255;</span>
<span class="line-modified">10850         if (start &gt; end)</span>
<span class="line-modified">10851           start = end;</span>
10852 
<span class="line-modified">10853         if (len &lt; 94 + (end - start) * 8)</span>
<span class="line-modified">10854           goto corrupt_file;</span>
10855 
<span class="line-modified">10856         /* palette is always the same size */</span>
<span class="line-modified">10857         palette_data = g_malloc0 (256 * 4);</span>
<span class="line-modified">10858         palette_size = 256 * 4;</span>
10859 
<span class="line-modified">10860         for (j = 0, i = start; i &lt;= end; j++, i++) {</span>
<span class="line-modified">10861           guint32 a, r, g, b;</span>
10862 
10863           a = QT_UINT16 (stsd_entry_data + offset + 78 + (j * 8));
10864           r = QT_UINT16 (stsd_entry_data + offset + 80 + (j * 8));
10865           g = QT_UINT16 (stsd_entry_data + offset + 82 + (j * 8));
10866           b = QT_UINT16 (stsd_entry_data + offset + 84 + (j * 8));
10867 
<span class="line-modified">10868           palette_data[i] = ((a &amp; 0xff00) &lt;&lt; 16) | ((r &amp; 0xff00) &lt;&lt; 8) |</span>
<span class="line-modified">10869               (g &amp; 0xff00) | (b &gt;&gt; 8);</span>
<span class="line-added">10870         }</span>
10871       }

10872 
10873       if (entry-&gt;caps)
10874         gst_caps_unref (entry-&gt;caps);
10875 
10876       entry-&gt;caps =
10877           qtdemux_video_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
10878           &amp;codec);
10879       if (G_UNLIKELY (!entry-&gt;caps)) {
<span class="line-modified">10880         g_free (palette_data);</span>
<span class="line-modified">10881         goto unknown_stream;</span>
<span class="line-modified">10882       }</span>
10883 
<span class="line-modified">10884       if (codec) {</span>
10885         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">10886             GST_TAG_VIDEO_CODEC, codec, NULL);</span>
<span class="line-modified">10887         g_free (codec);</span>
<span class="line-modified">10888         codec = NULL;</span>
<span class="line-modified">10889       }</span>
10890 
<span class="line-modified">10891       if (palette_data) {</span>
<span class="line-modified">10892         GstStructure *s;</span>
10893 
10894         if (entry-&gt;rgb8_palette)
10895           gst_memory_unref (entry-&gt;rgb8_palette);
10896         entry-&gt;rgb8_palette = gst_memory_new_wrapped (GST_MEMORY_FLAG_READONLY,
<span class="line-modified">10897             palette_data, palette_size, 0, palette_size, palette_data, g_free);</span>
10898 
10899         s = gst_caps_get_structure (entry-&gt;caps, 0);
10900 
<span class="line-modified">10901         /* non-raw video has a palette_data property. raw video has the palette as</span>
<span class="line-modified">10902          * an extra plane that we append to the output buffers before we push</span>
<span class="line-modified">10903          * them*/</span>
<span class="line-modified">10904         if (!gst_structure_has_name (s, &quot;video/x-raw&quot;)) {</span>
<span class="line-modified">10905           GstBuffer *palette;</span>
10906 
<span class="line-modified">10907           palette = gst_buffer_new ();</span>
10908           gst_buffer_append_memory (palette, entry-&gt;rgb8_palette);
10909           entry-&gt;rgb8_palette = NULL;
10910 
10911           gst_caps_set_simple (entry-&gt;caps, &quot;palette_data&quot;,
<span class="line-modified">10912               GST_TYPE_BUFFER, palette, NULL);</span>
<span class="line-modified">10913           gst_buffer_unref (palette);</span>
<span class="line-added">10914         }</span>
<span class="line-added">10915       } else if (palette_count != 0) {</span>
<span class="line-added">10916         GST_ELEMENT_WARNING (qtdemux, STREAM, NOT_IMPLEMENTED,</span>
<span class="line-added">10917             (NULL), (&quot;Unsupported palette depth %d&quot;, depth));</span>
10918       }




10919 
<span class="line-modified">10920       GST_LOG_OBJECT (qtdemux, &quot;frame count:   %u&quot;,</span>
10921           QT_UINT16 (stsd_entry_data + offset + 32));
10922 
<span class="line-modified">10923       esds = NULL;</span>
<span class="line-modified">10924       pasp = NULL;</span>
10925       colr = NULL;
10926       fiel = NULL;
<span class="line-modified">10927       /* pick &#39;the&#39; stsd child */</span>
10928       mp4v = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">10929       // We should skip parsing the stsd for non-protected streams if</span>
<span class="line-modified">10930       // the entry doesn&#39;t match the fourcc, since they don&#39;t change</span>
<span class="line-added">10931       // format. However, for protected streams we can have partial</span>
<span class="line-added">10932       // encryption, where parts of the stream are encrypted and parts</span>
<span class="line-added">10933       // not. For both parts of such streams, we should ensure the</span>
<span class="line-added">10934       // esds overrides are parsed for both from the stsd.</span>
<span class="line-added">10935       if (QTDEMUX_TREE_NODE_FOURCC (mp4v) != fourcc) {</span>
<span class="line-added">10936         if (stream-&gt;protected &amp;&amp; QTDEMUX_TREE_NODE_FOURCC (mp4v) != FOURCC_encv)</span>
10937           mp4v = NULL;
<span class="line-modified">10938         else if (!stream-&gt;protected)</span>


10939           mp4v = NULL;

10940       }
10941 
<span class="line-modified">10942       if (mp4v) {</span>
<span class="line-modified">10943         esds = qtdemux_tree_get_child_by_type (mp4v, FOURCC_esds);</span>
<span class="line-modified">10944         pasp = qtdemux_tree_get_child_by_type (mp4v, FOURCC_pasp);</span>
10945         colr = qtdemux_tree_get_child_by_type (mp4v, FOURCC_colr);
10946         fiel = qtdemux_tree_get_child_by_type (mp4v, FOURCC_fiel);
<span class="line-modified">10947       }</span>
10948 
<span class="line-modified">10949       if (pasp) {</span>
<span class="line-modified">10950         const guint8 *pasp_data = (const guint8 *) pasp-&gt;data;</span>
10951         gint len = QT_UINT32 (pasp_data);
10952 
10953         if (len == 16) {
10954           CUR_STREAM (stream)-&gt;par_w = QT_UINT32 (pasp_data + 8);
10955           CUR_STREAM (stream)-&gt;par_h = QT_UINT32 (pasp_data + 12);
<span class="line-modified">10956         } else {</span>
10957           CUR_STREAM (stream)-&gt;par_w = 0;
10958           CUR_STREAM (stream)-&gt;par_h = 0;
<span class="line-modified">10959         }</span>
10960       } else {
10961         CUR_STREAM (stream)-&gt;par_w = 0;
10962         CUR_STREAM (stream)-&gt;par_h = 0;
10963       }
10964 
10965       if (fiel) {
10966         const guint8 *fiel_data = (const guint8 *) fiel-&gt;data;
10967         gint len = QT_UINT32 (fiel_data);
10968 
10969         if (len == 10) {
10970           CUR_STREAM (stream)-&gt;interlace_mode = GST_READ_UINT8 (fiel_data + 8);
10971           CUR_STREAM (stream)-&gt;field_order = GST_READ_UINT8 (fiel_data + 9);
10972         }
10973       }
10974 
10975       if (colr) {
10976         const guint8 *colr_data = (const guint8 *) colr-&gt;data;
10977         gint len = QT_UINT32 (colr_data);
10978 
10979         if (len == 19 || len == 18) {
</pre>
<hr />
<pre>
11034                 break;
11035               case 9:
11036                 CUR_STREAM (stream)-&gt;colorimetry.matrix =
11037                     GST_VIDEO_COLOR_MATRIX_BT2020;
11038                 break;
11039               default:
11040                 break;
11041             }
11042 
11043             CUR_STREAM (stream)-&gt;colorimetry.range =
11044                 full_range ? GST_VIDEO_COLOR_RANGE_0_255 :
11045                 GST_VIDEO_COLOR_RANGE_16_235;
11046           } else {
11047             GST_DEBUG_OBJECT (qtdemux, &quot;Unsupported color type&quot;);
11048           }
11049         } else {
11050           GST_WARNING_OBJECT (qtdemux, &quot;Invalid colr atom size&quot;);
11051         }
11052       }
11053 
<span class="line-modified">11054       if (esds) {</span>
11055 #ifdef GSTREAMER_LITE
11056         if (!gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
11057                                       stream-&gt;stream_tags))
11058             goto corrupt_file;
11059 #else
11060         gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
11061             stream-&gt;stream_tags);
11062 #endif // GSTREAMER_LITE
<span class="line-modified">11063       } else {</span>
<span class="line-modified">11064         switch (fourcc) {</span>
<span class="line-modified">11065           case FOURCC_H264:</span>
<span class="line-modified">11066           case FOURCC_avc1:</span>
<span class="line-modified">11067           case FOURCC_avc3:</span>
<span class="line-modified">11068           {</span>
11069             gint len = QT_UINT32 (stsd_entry_data) - 0x56;
11070             const guint8 *avc_data = stsd_entry_data + 0x56;
11071 
<span class="line-modified">11072             /* find avcC */</span>
<span class="line-modified">11073             while (len &gt;= 0x8) {</span>
<span class="line-modified">11074               gint size;</span>
11075 
<span class="line-modified">11076               if (QT_UINT32 (avc_data) &lt;= len)</span>
<span class="line-modified">11077                 size = QT_UINT32 (avc_data) - 0x8;</span>
<span class="line-modified">11078               else</span>
<span class="line-modified">11079                 size = len - 0x8;</span>
11080 
<span class="line-modified">11081               if (size &lt; 1)</span>
<span class="line-modified">11082                 /* No real data, so break out */</span>
<span class="line-modified">11083                 break;</span>
11084 
<span class="line-modified">11085               switch (QT_FOURCC (avc_data + 0x4)) {</span>
<span class="line-modified">11086                 case FOURCC_avcC:</span>
<span class="line-modified">11087                 {</span>
<span class="line-modified">11088                   /* parse, if found */</span>
<span class="line-modified">11089                   GstBuffer *buf;</span>
11090 
<span class="line-modified">11091                   GST_DEBUG_OBJECT (qtdemux, &quot;found avcC codec_data in stsd&quot;);</span>
11092 
<span class="line-modified">11093                   /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">11094                    * are the fourcc, the next 1 byte is the version, and the</span>
<span class="line-modified">11095                    * subsequent bytes are profile_tier_level structure like data. */</span>
11096                   gst_codec_utils_h264_caps_set_level_and_profile (entry-&gt;caps,
<span class="line-modified">11097                       avc_data + 8 + 1, size - 1);</span>
<span class="line-modified">11098                   buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">11099                   gst_buffer_fill (buf, 0, avc_data + 0x8, size);</span>
11100                   gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11101                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11102                   gst_buffer_unref (buf);</span>
11103 
<span class="line-modified">11104                   break;</span>
<span class="line-modified">11105                 }</span>
<span class="line-modified">11106                 case FOURCC_strf:</span>
<span class="line-modified">11107                 {</span>
<span class="line-modified">11108                   GstBuffer *buf;</span>
11109 
<span class="line-modified">11110                   GST_DEBUG_OBJECT (qtdemux, &quot;found strf codec_data in stsd&quot;);</span>
11111 
<span class="line-modified">11112                   /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">11113                    * are the fourcc, next 40 bytes are BITMAPINFOHEADER,</span>
<span class="line-modified">11114                    * next 1 byte is the version, and the</span>
<span class="line-modified">11115                    * subsequent bytes are sequence parameter set like data. */</span>
11116 
11117                   size -= 40;   /* we&#39;ll be skipping BITMAPINFOHEADER */
<span class="line-modified">11118                   if (size &gt; 1) {</span>
11119                     gst_codec_utils_h264_caps_set_level_and_profile
11120                         (entry-&gt;caps, avc_data + 8 + 40 + 1, size - 1);
11121 
<span class="line-modified">11122                     buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">11123                     gst_buffer_fill (buf, 0, avc_data + 8 + 40, size);</span>
11124                     gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11125                         &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11126                     gst_buffer_unref (buf);</span>
<span class="line-added">11127                   }</span>
<span class="line-added">11128                   break;</span>
11129                 }
<span class="line-modified">11130                 case FOURCC_btrt:</span>
<span class="line-modified">11131                 {</span>
<span class="line-modified">11132                   guint avg_bitrate, max_bitrate;</span>


11133 
<span class="line-modified">11134                   /* bufferSizeDB, maxBitrate and avgBitrate - 4 bytes each */</span>
<span class="line-modified">11135                   if (size &lt; 12)</span>
<span class="line-modified">11136                     break;</span>
11137 
<span class="line-modified">11138                   max_bitrate = QT_UINT32 (avc_data + 0xc);</span>
<span class="line-modified">11139                   avg_bitrate = QT_UINT32 (avc_data + 0x10);</span>
11140 
<span class="line-modified">11141                   if (!max_bitrate &amp;&amp; !avg_bitrate)</span>
<span class="line-modified">11142                     break;</span>
11143 
<span class="line-modified">11144                   /* Some muxers seem to swap the average and maximum bitrates</span>
<span class="line-modified">11145                    * (I&#39;m looking at you, YouTube), so we swap for sanity. */</span>
<span class="line-modified">11146                   if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; avg_bitrate) {</span>
<span class="line-modified">11147                     guint temp = avg_bitrate;</span>
11148 
<span class="line-modified">11149                     avg_bitrate = max_bitrate;</span>
<span class="line-modified">11150                     max_bitrate = temp;</span>
<span class="line-modified">11151                   }</span>
11152 
<span class="line-modified">11153                   if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; G_MAXUINT32) {</span>
11154                     gst_tag_list_add (stream-&gt;stream_tags,
11155                         GST_TAG_MERGE_REPLACE, GST_TAG_MAXIMUM_BITRATE,
11156                         max_bitrate, NULL);
<span class="line-modified">11157                   }</span>
<span class="line-modified">11158                   if (avg_bitrate &gt; 0 &amp;&amp; avg_bitrate &lt; G_MAXUINT32) {</span>
11159                     gst_tag_list_add (stream-&gt;stream_tags,
11160                         GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE, avg_bitrate,
11161                         NULL);
<span class="line-added">11162                   }</span>
<span class="line-added">11163 </span>
<span class="line-added">11164                   break;</span>
11165                 }
11166 
<span class="line-modified">11167                 default:</span>
<span class="line-added">11168                   break;</span>
11169               }
11170 
<span class="line-modified">11171               len -= size + 8;</span>
<span class="line-modified">11172               avc_data += size + 8;</span>
11173             }
11174 
<span class="line-modified">11175             break;</span>

11176           }
<span class="line-modified">11177           case FOURCC_H265:</span>
<span class="line-modified">11178           case FOURCC_hvc1:</span>
<span class="line-modified">11179           case FOURCC_hev1:</span>
<span class="line-modified">11180           {</span>



11181             gint len = QT_UINT32 (stsd_entry_data) - 0x56;
11182             const guint8 *hevc_data = stsd_entry_data + 0x56;
11183 
<span class="line-modified">11184             /* find hevc */</span>
<span class="line-modified">11185             while (len &gt;= 0x8) {</span>
<span class="line-modified">11186               gint size;</span>
11187 
<span class="line-modified">11188               if (QT_UINT32 (hevc_data) &lt;= len)</span>
<span class="line-modified">11189                 size = QT_UINT32 (hevc_data) - 0x8;</span>
<span class="line-modified">11190               else</span>
<span class="line-modified">11191                 size = len - 0x8;</span>
11192 
<span class="line-modified">11193               if (size &lt; 1)</span>
<span class="line-modified">11194                 /* No real data, so break out */</span>
<span class="line-modified">11195                 break;</span>
11196 
<span class="line-modified">11197               switch (QT_FOURCC (hevc_data + 0x4)) {</span>
<span class="line-modified">11198                 case FOURCC_hvcC:</span>
<span class="line-modified">11199                 {</span>
<span class="line-modified">11200                   /* parse, if found */</span>
<span class="line-modified">11201                   GstBuffer *buf;</span>
11202 
11203                   GST_DEBUG_OBJECT (qtdemux, &quot;found hvcC codec_data in stsd&quot;);
11204 
<span class="line-modified">11205                   /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">11206                    * are the fourcc, the next 1 byte is the version, and the</span>
<span class="line-modified">11207                    * subsequent bytes are sequence parameter set like data. */</span>
<span class="line-modified">11208                   gst_codec_utils_h265_caps_set_level_tier_and_profile</span>
11209                       (entry-&gt;caps, hevc_data + 8 + 1, size - 1);
11210 
<span class="line-modified">11211                   buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">11212                   gst_buffer_fill (buf, 0, hevc_data + 0x8, size);</span>
11213                   gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11214                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11215                   gst_buffer_unref (buf);</span>
<span class="line-modified">11216                   break;</span>
<span class="line-added">11217                 }</span>
<span class="line-added">11218                 default:</span>
<span class="line-added">11219                   break;</span>
11220               }
<span class="line-modified">11221               len -= size + 8;</span>
<span class="line-modified">11222               hevc_data += size + 8;</span>
11223             }
<span class="line-modified">11224             break;</span>

11225           }
<span class="line-modified">11226           case FOURCC_mp4v:</span>
<span class="line-modified">11227           case FOURCC_MP4V:</span>
<span class="line-modified">11228           case FOURCC_fmp4:</span>
<span class="line-modified">11229           case FOURCC_FMP4:</span>


11230           case FOURCC_xvid:
11231           case FOURCC_XVID:
<span class="line-modified">11232           {</span>
<span class="line-modified">11233             GNode *glbl;</span>
11234 
<span class="line-modified">11235             GST_DEBUG_OBJECT (qtdemux, &quot;found %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">11236                 GST_FOURCC_ARGS (fourcc));</span>
11237 
<span class="line-modified">11238             /* codec data might be in glbl extension atom */</span>
<span class="line-modified">11239             glbl = mp4v ?</span>
<span class="line-modified">11240                 qtdemux_tree_get_child_by_type (mp4v, FOURCC_glbl) : NULL;</span>
<span class="line-modified">11241             if (glbl) {</span>
<span class="line-modified">11242               guint8 *data;</span>
<span class="line-modified">11243               GstBuffer *buf;</span>
<span class="line-modified">11244               gint len;</span>
<span class="line-modified">11245 </span>
<span class="line-modified">11246               GST_DEBUG_OBJECT (qtdemux, &quot;found glbl data in stsd&quot;);</span>
<span class="line-modified">11247               data = glbl-&gt;data;</span>
<span class="line-modified">11248               len = QT_UINT32 (data);</span>
<span class="line-modified">11249               if (len &gt; 0x8) {</span>
<span class="line-modified">11250                 len -= 0x8;</span>
<span class="line-modified">11251                 buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">11252                 gst_buffer_fill (buf, 0, data + 8, len);</span>
11253                 gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11254                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11255                 gst_buffer_unref (buf);</span>
<span class="line-added">11256               }</span>
11257             }
<span class="line-added">11258             break;</span>
11259           }
<span class="line-modified">11260           case FOURCC_mjp2:</span>
<span class="line-modified">11261           {</span>
<span class="line-modified">11262             /* see annex I of the jpeg2000 spec */</span>
<span class="line-modified">11263             GNode *jp2h, *ihdr, *colr, *mjp2, *field, *prefix, *cmap, *cdef;</span>
<span class="line-modified">11264             const guint8 *data;</span>
<span class="line-modified">11265             const gchar *colorspace = NULL;</span>
<span class="line-modified">11266             gint ncomp = 0;</span>
<span class="line-modified">11267             guint32 ncomp_map = 0;</span>
<span class="line-modified">11268             gint32 *comp_map = NULL;</span>
<span class="line-modified">11269             guint32 nchan_def = 0;</span>
<span class="line-modified">11270             gint32 *chan_def = NULL;</span>
<span class="line-modified">11271 </span>
<span class="line-modified">11272             GST_DEBUG_OBJECT (qtdemux, &quot;found mjp2&quot;);</span>
<span class="line-modified">11273             /* some required atoms */</span>


11274             mjp2 = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">11275             if (!mjp2)</span>
<span class="line-modified">11276               break;</span>
<span class="line-modified">11277             jp2h = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2h);</span>
<span class="line-modified">11278             if (!jp2h)</span>
<span class="line-modified">11279               break;</span>
11280 
<span class="line-modified">11281             /* number of components; redundant with info in codestream, but useful</span>
<span class="line-modified">11282                to a muxer */</span>
<span class="line-modified">11283             ihdr = qtdemux_tree_get_child_by_type (jp2h, FOURCC_ihdr);</span>
<span class="line-modified">11284             if (!ihdr || QT_UINT32 (ihdr-&gt;data) != 22)</span>
<span class="line-modified">11285               break;</span>
<span class="line-modified">11286             ncomp = QT_UINT16 (((guint8 *) ihdr-&gt;data) + 16);</span>
11287 
<span class="line-modified">11288             colr = qtdemux_tree_get_child_by_type (jp2h, FOURCC_colr);</span>
<span class="line-modified">11289             if (!colr)</span>
<span class="line-modified">11290               break;</span>
<span class="line-modified">11291             GST_DEBUG_OBJECT (qtdemux, &quot;found colr&quot;);</span>
<span class="line-modified">11292             /* extract colour space info */</span>
<span class="line-modified">11293             if (QT_UINT8 ((guint8 *) colr-&gt;data + 8) == 1) {</span>
<span class="line-modified">11294               switch (QT_UINT32 ((guint8 *) colr-&gt;data + 11)) {</span>
<span class="line-modified">11295                 case 16:</span>
<span class="line-modified">11296                   colorspace = &quot;sRGB&quot;;</span>
<span class="line-modified">11297                   break;</span>
<span class="line-modified">11298                 case 17:</span>
<span class="line-modified">11299                   colorspace = &quot;GRAY&quot;;</span>
<span class="line-modified">11300                   break;</span>
<span class="line-modified">11301                 case 18:</span>
<span class="line-modified">11302                   colorspace = &quot;sYUV&quot;;</span>
<span class="line-modified">11303                   break;</span>
<span class="line-modified">11304                 default:</span>
<span class="line-modified">11305                   colorspace = NULL;</span>
<span class="line-modified">11306                   break;</span>
<span class="line-added">11307               }</span>
11308             }
<span class="line-modified">11309             if (!colorspace)</span>
<span class="line-modified">11310               /* colr is required, and only values 16, 17, and 18 are specified,</span>
<span class="line-modified">11311                  so error if we have no colorspace */</span>
<span class="line-modified">11312               break;</span>

11313 
<span class="line-modified">11314             /* extract component mapping */</span>
<span class="line-modified">11315             cmap = qtdemux_tree_get_child_by_type (jp2h, FOURCC_cmap);</span>
<span class="line-modified">11316             if (cmap) {</span>
<span class="line-modified">11317               guint32 cmap_len = 0;</span>
<span class="line-modified">11318               int i;</span>
<span class="line-modified">11319               cmap_len = QT_UINT32 (cmap-&gt;data);</span>
<span class="line-modified">11320               if (cmap_len &gt;= 8) {</span>
<span class="line-modified">11321                 /* normal box, subtract off header */</span>
<span class="line-modified">11322                 cmap_len -= 8;</span>
<span class="line-modified">11323                 /* cmap: { u16 cmp; u8 mtyp; u8 pcol; }* */</span>
<span class="line-modified">11324                 if (cmap_len % 4 == 0) {</span>
<span class="line-modified">11325                   ncomp_map = (cmap_len / 4);</span>
<span class="line-modified">11326                   comp_map = g_new0 (gint32, ncomp_map);</span>
<span class="line-modified">11327                   for (i = 0; i &lt; ncomp_map; i++) {</span>
<span class="line-modified">11328                     guint16 cmp;</span>
<span class="line-modified">11329                     guint8 mtyp, pcol;</span>
<span class="line-modified">11330                     cmp = QT_UINT16 (((guint8 *) cmap-&gt;data) + 8 + i * 4);</span>
<span class="line-modified">11331                     mtyp = QT_UINT8 (((guint8 *) cmap-&gt;data) + 8 + i * 4 + 2);</span>
<span class="line-modified">11332                     pcol = QT_UINT8 (((guint8 *) cmap-&gt;data) + 8 + i * 4 + 3);</span>
<span class="line-modified">11333                     comp_map[i] = (mtyp &lt;&lt; 24) | (pcol &lt;&lt; 16) | cmp;</span>
<span class="line-added">11334                   }</span>
11335                 }
11336               }
11337             }
<span class="line-modified">11338             /* extract channel definitions */</span>
<span class="line-modified">11339             cdef = qtdemux_tree_get_child_by_type (jp2h, FOURCC_cdef);</span>
<span class="line-modified">11340             if (cdef) {</span>
<span class="line-modified">11341               guint32 cdef_len = 0;</span>
<span class="line-modified">11342               int i;</span>
<span class="line-modified">11343               cdef_len = QT_UINT32 (cdef-&gt;data);</span>
<span class="line-modified">11344               if (cdef_len &gt;= 10) {</span>
<span class="line-modified">11345                 /* normal box, subtract off header and len */</span>
<span class="line-modified">11346                 cdef_len -= 10;</span>
<span class="line-modified">11347                 /* cdef: u16 n; { u16 cn; u16 typ; u16 asoc; }* */</span>
<span class="line-modified">11348                 if (cdef_len % 6 == 0) {</span>
<span class="line-modified">11349                   nchan_def = (cdef_len / 6);</span>
<span class="line-modified">11350                   chan_def = g_new0 (gint32, nchan_def);</span>
<span class="line-modified">11351                   for (i = 0; i &lt; nchan_def; i++)</span>
<span class="line-modified">11352                     chan_def[i] = -1;</span>
<span class="line-modified">11353                   for (i = 0; i &lt; nchan_def; i++) {</span>
<span class="line-modified">11354                     guint16 cn, typ, asoc;</span>
<span class="line-modified">11355                     cn = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6);</span>
<span class="line-modified">11356                     typ = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6 + 2);</span>
<span class="line-modified">11357                     asoc = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6 + 4);</span>
<span class="line-modified">11358                     if (cn &lt; nchan_def) {</span>
<span class="line-modified">11359                       switch (typ) {</span>
<span class="line-modified">11360                         case 0:</span>
<span class="line-modified">11361                           chan_def[cn] = asoc;</span>
<span class="line-modified">11362                           break;</span>
<span class="line-modified">11363                         case 1:</span>

11364                           chan_def[cn] = 0;     /* alpha */
<span class="line-modified">11365                           break;</span>
<span class="line-modified">11366                         default:</span>
<span class="line-modified">11367                           chan_def[cn] = -typ;</span>
<span class="line-added">11368                       }</span>
11369                     }
11370                   }
11371                 }
11372               }
11373             }

11374 
11375             gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11376                 &quot;num-components&quot;, G_TYPE_INT, ncomp, NULL);</span>
11377             gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11378                 &quot;colorspace&quot;, G_TYPE_STRING, colorspace, NULL);</span>
<span class="line-modified">11379 </span>
<span class="line-modified">11380             if (comp_map) {</span>
<span class="line-modified">11381               GValue arr = { 0, };</span>
<span class="line-modified">11382               GValue elt = { 0, };</span>
<span class="line-modified">11383               int i;</span>
<span class="line-modified">11384               g_value_init (&amp;arr, GST_TYPE_ARRAY);</span>
<span class="line-modified">11385               g_value_init (&amp;elt, G_TYPE_INT);</span>
<span class="line-modified">11386               for (i = 0; i &lt; ncomp_map; i++) {</span>
<span class="line-modified">11387                 g_value_set_int (&amp;elt, comp_map[i]);</span>
<span class="line-modified">11388                 gst_value_array_append_value (&amp;arr, &amp;elt);</span>
<span class="line-modified">11389               }</span>
11390               gst_structure_set_value (gst_caps_get_structure (entry-&gt;caps, 0),
<span class="line-modified">11391                   &quot;component-map&quot;, &amp;arr);</span>
<span class="line-modified">11392               g_value_unset (&amp;elt);</span>
<span class="line-modified">11393               g_value_unset (&amp;arr);</span>
<span class="line-modified">11394               g_free (comp_map);</span>











11395             }
<span class="line-added">11396 </span>
<span class="line-added">11397             if (chan_def) {</span>
<span class="line-added">11398               GValue arr = { 0, };</span>
<span class="line-added">11399               GValue elt = { 0, };</span>
<span class="line-added">11400               int i;</span>
<span class="line-added">11401               g_value_init (&amp;arr, GST_TYPE_ARRAY);</span>
<span class="line-added">11402               g_value_init (&amp;elt, G_TYPE_INT);</span>
<span class="line-added">11403               for (i = 0; i &lt; nchan_def; i++) {</span>
<span class="line-added">11404                 g_value_set_int (&amp;elt, chan_def[i]);</span>
<span class="line-added">11405                 gst_value_array_append_value (&amp;arr, &amp;elt);</span>
<span class="line-added">11406               }</span>
11407               gst_structure_set_value (gst_caps_get_structure (entry-&gt;caps, 0),
<span class="line-modified">11408                   &quot;channel-definitions&quot;, &amp;arr);</span>
<span class="line-modified">11409               g_value_unset (&amp;elt);</span>
<span class="line-modified">11410               g_value_unset (&amp;arr);</span>
<span class="line-modified">11411               g_free (chan_def);</span>
<span class="line-modified">11412             }</span>
11413 
<span class="line-modified">11414             /* some optional atoms */</span>
<span class="line-modified">11415             field = qtdemux_tree_get_child_by_type (mjp2, FOURCC_fiel);</span>
<span class="line-modified">11416             prefix = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2x);</span>
11417 
<span class="line-modified">11418             /* indicate possible fields in caps */</span>
<span class="line-modified">11419             if (field) {</span>
<span class="line-modified">11420               data = (guint8 *) field-&gt;data + 8;</span>
<span class="line-modified">11421               if (*data != 1)</span>
11422                 gst_caps_set_simple (entry-&gt;caps, &quot;fields&quot;, G_TYPE_INT,
<span class="line-modified">11423                     (gint) * data, NULL);</span>
<span class="line-modified">11424             }</span>
<span class="line-modified">11425             /* add codec_data if provided */</span>
<span class="line-modified">11426             if (prefix) {</span>
<span class="line-modified">11427               GstBuffer *buf;</span>
<span class="line-modified">11428               gint len;</span>
<span class="line-modified">11429 </span>
<span class="line-modified">11430               GST_DEBUG_OBJECT (qtdemux, &quot;found prefix data in stsd&quot;);</span>
<span class="line-modified">11431               data = prefix-&gt;data;</span>
<span class="line-modified">11432               len = QT_UINT32 (data);</span>
<span class="line-modified">11433               if (len &gt; 0x8) {</span>
<span class="line-modified">11434                 len -= 0x8;</span>
<span class="line-modified">11435                 buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">11436                 gst_buffer_fill (buf, 0, data + 8, len);</span>
11437                 gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11438                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11439                 gst_buffer_unref (buf);</span>
<span class="line-added">11440               }</span>
11441             }
<span class="line-added">11442             break;</span>
11443           }
<span class="line-modified">11444           case FOURCC_SVQ3:</span>
<span class="line-modified">11445           case FOURCC_VP31:</span>
<span class="line-modified">11446           {</span>
<span class="line-modified">11447             GstBuffer *buf;</span>
<span class="line-modified">11448             GstBuffer *seqh = NULL;</span>


11449             const guint8 *gamma_data = NULL;
11450             gint len = QT_UINT32 (stsd_data);   /* FIXME review - why put the whole stsd in codec data? */
11451 
11452             qtdemux_parse_svq3_stsd_data (qtdemux, stsd_entry_data, &amp;gamma_data,
11453                 &amp;seqh);
<span class="line-modified">11454             if (gamma_data) {</span>
11455               gst_caps_set_simple (entry-&gt;caps, &quot;applied-gamma&quot;, G_TYPE_DOUBLE,
<span class="line-modified">11456                   QT_FP32 (gamma_data), NULL);</span>
<span class="line-modified">11457             }</span>
<span class="line-modified">11458             if (seqh) {</span>
<span class="line-modified">11459               /* sorry for the bad name, but we don&#39;t know what this is, other</span>
<span class="line-modified">11460                * than its own fourcc */</span>
11461               gst_caps_set_simple (entry-&gt;caps, &quot;seqh&quot;, GST_TYPE_BUFFER, seqh,
<span class="line-modified">11462                   NULL);</span>
11463               gst_buffer_unref (seqh);
<span class="line-modified">11464             }</span>
11465 
<span class="line-modified">11466             GST_DEBUG_OBJECT (qtdemux, &quot;found codec_data in stsd&quot;);</span>
<span class="line-modified">11467             buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">11468             gst_buffer_fill (buf, 0, stsd_data, len);</span>
11469             gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11470                 &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11471             gst_buffer_unref (buf);</span>
<span class="line-modified">11472             break;</span>
<span class="line-modified">11473           }</span>
11474           case FOURCC_jpeg:
11475           {
11476             /* https://developer.apple.com/standards/qtff-2001.pdf,
11477              * page 92, &quot;Video Sample Description&quot;, under table 3.1 */
11478             GstByteReader br;
11479 
11480             const gint compressor_offset =
11481                 16 + 4 + 4 * 3 + 2 * 2 + 2 * 4 + 4 + 2;
11482             const gint min_size = compressor_offset + 32 + 2 + 2;
11483             GNode *jpeg;
11484             guint32 len;
11485             guint16 color_table_id = 0;
11486             gboolean ok;
11487 
11488             GST_DEBUG_OBJECT (qtdemux, &quot;found jpeg&quot;);
11489 
11490             /* recover information on interlaced/progressive */
11491             jpeg = qtdemux_tree_get_child_by_type (stsd, FOURCC_jpeg);
11492             if (!jpeg)
11493               break;
</pre>
<hr />
<pre>
11529                             &quot;interlace-mode&quot;, G_TYPE_STRING, &quot;interleaved&quot;,
11530                             NULL);
11531                     } else {
11532                       GST_WARNING_OBJECT (qtdemux,
11533                           &quot;Found fiel tag with invalid fields (%u)&quot;, n_fields);
11534                     }
11535                   }
11536                   offset += size;
11537                 }
11538               } else {
11539                 GST_DEBUG_OBJECT (qtdemux,
11540                     &quot;Color table ID is 0, not trying to get interlacedness&quot;);
11541               }
11542             } else {
11543               GST_WARNING_OBJECT (qtdemux,
11544                   &quot;Length of jpeg chunk is too small, not trying to get interlacedness&quot;);
11545             }
11546 
11547             break;
11548           }
<span class="line-modified">11549           case FOURCC_rle_:</span>
<span class="line-modified">11550           case FOURCC_WRLE:</span>
<span class="line-modified">11551           {</span>
11552             gst_caps_set_simple (entry-&gt;caps,
11553                 &quot;depth&quot;, G_TYPE_INT, QT_UINT16 (stsd_entry_data + offset + 66),
11554                 NULL);
<span class="line-modified">11555             break;</span>
<span class="line-modified">11556           }</span>
<span class="line-modified">11557           case FOURCC_XiTh:</span>
<span class="line-modified">11558           {</span>
<span class="line-modified">11559             GNode *xith, *xdxt;</span>
11560 
<span class="line-modified">11561             GST_DEBUG_OBJECT (qtdemux, &quot;found XiTh&quot;);</span>
11562             xith = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">11563             if (!xith)</span>
<span class="line-modified">11564               break;</span>
11565 
<span class="line-modified">11566             xdxt = qtdemux_tree_get_child_by_type (xith, FOURCC_XdxT);</span>
<span class="line-modified">11567             if (!xdxt)</span>
<span class="line-modified">11568               break;</span>
11569 
<span class="line-modified">11570             GST_DEBUG_OBJECT (qtdemux, &quot;found XdxT node&quot;);</span>
<span class="line-modified">11571             /* collect the headers and store them in a stream list so that we can</span>
<span class="line-modified">11572              * send them out first */</span>
<span class="line-modified">11573             qtdemux_parse_theora_extension (qtdemux, stream, xdxt);</span>
<span class="line-modified">11574             break;</span>
<span class="line-modified">11575           }</span>
<span class="line-modified">11576           case FOURCC_ovc1:</span>
<span class="line-modified">11577           {</span>
<span class="line-modified">11578             GNode *ovc1;</span>
<span class="line-modified">11579             guint8 *ovc1_data;</span>
<span class="line-modified">11580             guint ovc1_len;</span>
<span class="line-modified">11581             GstBuffer *buf;</span>
11582 
<span class="line-modified">11583             GST_DEBUG_OBJECT (qtdemux, &quot;parse ovc1 header&quot;);</span>
11584             ovc1 = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">11585             if (!ovc1)</span>
<span class="line-modified">11586               break;</span>
<span class="line-modified">11587             ovc1_data = ovc1-&gt;data;</span>
<span class="line-modified">11588             ovc1_len = QT_UINT32 (ovc1_data);</span>
<span class="line-modified">11589             if (ovc1_len &lt;= 198) {</span>
<span class="line-modified">11590               GST_WARNING_OBJECT (qtdemux, &quot;Too small ovc1 header, skipping&quot;);</span>
<span class="line-added">11591               break;</span>
<span class="line-added">11592             }</span>
<span class="line-added">11593             buf = gst_buffer_new_and_alloc (ovc1_len - 198);</span>
<span class="line-added">11594             gst_buffer_fill (buf, 0, ovc1_data + 198, ovc1_len - 198);</span>
<span class="line-added">11595             gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-added">11596                 &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-added">11597             gst_buffer_unref (buf);</span>
11598             break;
11599           }







11600           case FOURCC_vc_1:
11601           {
11602             gint len = QT_UINT32 (stsd_entry_data) - 0x56;
11603             const guint8 *vc1_data = stsd_entry_data + 0x56;
11604 
11605             /* find dvc1 */
11606             while (len &gt;= 8) {
11607               gint size;
11608 
11609               if (QT_UINT32 (vc1_data) &lt;= len)
11610                 size = QT_UINT32 (vc1_data) - 8;
11611               else
11612                 size = len - 8;
11613 
11614               if (size &lt; 1)
11615                 /* No real data, so break out */
11616                 break;
11617 
11618               switch (QT_FOURCC (vc1_data + 0x4)) {
11619                 case GST_MAKE_FOURCC (&#39;d&#39;, &#39;v&#39;, &#39;c&#39;, &#39;1&#39;):
11620                 {
11621                   GstBuffer *buf;
11622 
11623                   GST_DEBUG_OBJECT (qtdemux, &quot;found dvc1 codec_data in stsd&quot;);
11624                   buf = gst_buffer_new_and_alloc (size);
11625                   gst_buffer_fill (buf, 0, vc1_data + 8, size);
11626                   gst_caps_set_simple (entry-&gt;caps,
11627                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
11628                   gst_buffer_unref (buf);
11629                   break;
11630                 }
<span class="line-modified">11631                 default:</span>
<span class="line-modified">11632                   break;</span>
<span class="line-modified">11633               }</span>
11634               len -= size + 8;
11635               vc1_data += size + 8;
<span class="line-modified">11636             }</span>
<span class="line-added">11637             break;</span>
<span class="line-added">11638           }</span>
<span class="line-added">11639           case FOURCC_av01:</span>
<span class="line-added">11640           {</span>
<span class="line-added">11641             gint len = QT_UINT32 (stsd_entry_data) - 0x56;</span>
<span class="line-added">11642             const guint8 *av1_data = stsd_entry_data + 0x56;</span>
<span class="line-added">11643 </span>
<span class="line-added">11644             /* find av1C */</span>
<span class="line-added">11645             while (len &gt;= 0x8) {</span>
<span class="line-added">11646               gint size;</span>
<span class="line-added">11647 </span>
<span class="line-added">11648               if (QT_UINT32 (av1_data) &lt;= len)</span>
<span class="line-added">11649                 size = QT_UINT32 (av1_data) - 0x8;</span>
<span class="line-added">11650               else</span>
<span class="line-added">11651                 size = len - 0x8;</span>
<span class="line-added">11652 </span>
<span class="line-added">11653               if (size &lt; 1)</span>
<span class="line-added">11654                 /* No real data, so break out */</span>
<span class="line-added">11655                 break;</span>
<span class="line-added">11656 </span>
<span class="line-added">11657               switch (QT_FOURCC (av1_data + 0x4)) {</span>
<span class="line-added">11658                 case FOURCC_av1C:</span>
<span class="line-added">11659                 {</span>
<span class="line-added">11660                   /* parse, if found */</span>
<span class="line-added">11661                   GstBuffer *buf;</span>
<span class="line-added">11662                   guint8 pres_delay_field;</span>
<span class="line-added">11663 </span>
<span class="line-added">11664                   GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added">11665                       &quot;found av1C codec_data in stsd of size %d&quot;, size);</span>
<span class="line-added">11666 </span>
<span class="line-added">11667                   /* not enough data, just ignore and hope for the best */</span>
<span class="line-added">11668                   if (size &lt; 5)</span>
<span class="line-added">11669                     break;</span>
<span class="line-added">11670 </span>
<span class="line-added">11671                   /* Content is:</span>
<span class="line-added">11672                    * 4 bytes: atom length</span>
<span class="line-added">11673                    * 4 bytes: fourcc</span>
<span class="line-added">11674                    * 1 byte: version</span>
<span class="line-added">11675                    * 3 bytes: flags</span>
<span class="line-added">11676                    * 3 bits: reserved</span>
<span class="line-added">11677                    * 1 bits:  initial_presentation_delay_present</span>
<span class="line-added">11678                    * 4 bits: initial_presentation_delay (if present else reserved</span>
<span class="line-added">11679                    * rest: OBUs.</span>
<span class="line-added">11680                    */</span>
<span class="line-added">11681 </span>
<span class="line-added">11682                   if (av1_data[9] != 0) {</span>
<span class="line-added">11683                     GST_WARNING (&quot;Unknown version %d of av1C box&quot;, av1_data[9]);</span>
<span class="line-added">11684                     break;</span>
<span class="line-added">11685                   }</span>
<span class="line-added">11686 </span>
<span class="line-added">11687                   /* We skip initial_presentation_delay* for now */</span>
<span class="line-added">11688                   pres_delay_field = *(av1_data + 12);</span>
<span class="line-added">11689                   if (pres_delay_field &amp; (1 &lt;&lt; 5)) {</span>
<span class="line-added">11690                     gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-added">11691                         &quot;presentation-delay&quot;, G_TYPE_INT,</span>
<span class="line-added">11692                         (gint) (pres_delay_field &amp; 0x0F) + 1, NULL);</span>
<span class="line-added">11693                   }</span>
<span class="line-added">11694                   if (size &gt; 5) {</span>
<span class="line-added">11695                     buf = gst_buffer_new_and_alloc (size - 5);</span>
<span class="line-added">11696                     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_HEADER);</span>
<span class="line-added">11697                     gst_buffer_fill (buf, 0, av1_data + 13, size - 5);</span>
<span class="line-added">11698                     gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-added">11699                         &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-added">11700                     gst_buffer_unref (buf);</span>
<span class="line-added">11701                   }</span>
<span class="line-added">11702                   break;</span>
<span class="line-added">11703                 }</span>
<span class="line-added">11704                 default:</span>
<span class="line-added">11705                   break;</span>
<span class="line-added">11706               }</span>
<span class="line-added">11707 </span>
<span class="line-added">11708               len -= size + 8;</span>
<span class="line-added">11709               av1_data += size + 8;</span>
<span class="line-added">11710             }</span>
<span class="line-added">11711 </span>
11712             break;
11713           }
11714           default:
11715             break;
11716         }
11717       }
11718 
<span class="line-modified">11719       GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">11720           &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
11721           GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
11722 
<span class="line-modified">11723     } else if (stream-&gt;subtype == FOURCC_soun) {</span>
11724       GNode *wave;
<span class="line-modified">11725       int version, samplesize;</span>
<span class="line-modified">11726       guint16 compression_id;</span>
<span class="line-modified">11727       gboolean amrwb = FALSE;</span>
11728 
11729       offset = 16;
<span class="line-modified">11730       /* sample description entry (16) + sound sample description v0 (20) */</span>
<span class="line-modified">11731       if (len &lt; 36)</span>
<span class="line-modified">11732         goto corrupt_file;</span>
11733 
11734       version = QT_UINT32 (stsd_entry_data + offset);
11735       entry-&gt;n_channels = QT_UINT16 (stsd_entry_data + offset + 8);
11736       samplesize = QT_UINT16 (stsd_entry_data + offset + 10);
11737       compression_id = QT_UINT16 (stsd_entry_data + offset + 12);
11738       entry-&gt;rate = QT_FP32 (stsd_entry_data + offset + 16);
11739 
<span class="line-modified">11740       GST_LOG_OBJECT (qtdemux, &quot;version/rev:      %08x&quot;, version);</span>
<span class="line-modified">11741       GST_LOG_OBJECT (qtdemux, &quot;vendor:           %08x&quot;,</span>
11742           QT_UINT32 (stsd_entry_data + offset + 4));
11743       GST_LOG_OBJECT (qtdemux, &quot;n_channels:       %d&quot;, entry-&gt;n_channels);
<span class="line-modified">11744       GST_LOG_OBJECT (qtdemux, &quot;sample_size:      %d&quot;, samplesize);</span>
<span class="line-modified">11745       GST_LOG_OBJECT (qtdemux, &quot;compression_id:   %d&quot;, compression_id);</span>
<span class="line-modified">11746       GST_LOG_OBJECT (qtdemux, &quot;packet size:      %d&quot;,</span>
11747           QT_UINT16 (stsd_entry_data + offset + 14));
11748       GST_LOG_OBJECT (qtdemux, &quot;sample rate:      %g&quot;, entry-&gt;rate);
11749 
<span class="line-modified">11750       if (compression_id == 0xfffe)</span>
11751         entry-&gt;sampled = TRUE;
11752 
<span class="line-modified">11753       /* first assume uncompressed audio */</span>
11754       entry-&gt;bytes_per_sample = samplesize / 8;
11755       entry-&gt;samples_per_frame = entry-&gt;n_channels;
11756       entry-&gt;bytes_per_frame = entry-&gt;n_channels * entry-&gt;bytes_per_sample;
11757       entry-&gt;samples_per_packet = entry-&gt;samples_per_frame;
11758       entry-&gt;bytes_per_packet = entry-&gt;bytes_per_sample;
11759 
11760       offset = 36;
<span class="line-modified">11761       switch (fourcc) {</span>
<span class="line-modified">11762           /* Yes, these have to be hard-coded */</span>
<span class="line-modified">11763         case FOURCC_MAC6:</span>
<span class="line-modified">11764         {</span>
11765           entry-&gt;samples_per_packet = 6;
11766           entry-&gt;bytes_per_packet = 1;
11767           entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
11768           entry-&gt;bytes_per_sample = 1;
11769           entry-&gt;samples_per_frame = 6 * entry-&gt;n_channels;
<span class="line-modified">11770           break;</span>
<span class="line-modified">11771         }</span>
<span class="line-modified">11772         case FOURCC_MAC3:</span>
<span class="line-modified">11773         {</span>
11774           entry-&gt;samples_per_packet = 3;
11775           entry-&gt;bytes_per_packet = 1;
11776           entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
11777           entry-&gt;bytes_per_sample = 1;
11778           entry-&gt;samples_per_frame = 3 * entry-&gt;n_channels;
<span class="line-modified">11779           break;</span>
<span class="line-modified">11780         }</span>
<span class="line-modified">11781         case FOURCC_ima4:</span>
<span class="line-modified">11782         {</span>
11783           entry-&gt;samples_per_packet = 64;
11784           entry-&gt;bytes_per_packet = 34;
11785           entry-&gt;bytes_per_frame = 34 * entry-&gt;n_channels;
11786           entry-&gt;bytes_per_sample = 2;
11787           entry-&gt;samples_per_frame = 64 * entry-&gt;n_channels;
<span class="line-modified">11788           break;</span>
<span class="line-modified">11789         }</span>
<span class="line-modified">11790         case FOURCC_ulaw:</span>
<span class="line-modified">11791         case FOURCC_alaw:</span>
<span class="line-modified">11792         {</span>
11793           entry-&gt;samples_per_packet = 1;
11794           entry-&gt;bytes_per_packet = 1;
11795           entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
11796           entry-&gt;bytes_per_sample = 1;
11797           entry-&gt;samples_per_frame = 1 * entry-&gt;n_channels;
<span class="line-modified">11798           break;</span>
<span class="line-modified">11799         }</span>
<span class="line-modified">11800         case FOURCC_agsm:</span>
<span class="line-modified">11801         {</span>
11802           entry-&gt;samples_per_packet = 160;
11803           entry-&gt;bytes_per_packet = 33;
11804           entry-&gt;bytes_per_frame = 33 * entry-&gt;n_channels;
11805           entry-&gt;bytes_per_sample = 2;
11806           entry-&gt;samples_per_frame = 160 * entry-&gt;n_channels;
<span class="line-modified">11807           break;</span>
<span class="line-added">11808         }</span>
<span class="line-added">11809         default:</span>
<span class="line-added">11810           break;</span>
11811       }



11812 
<span class="line-modified">11813       if (version == 0x00010000) {</span>
<span class="line-modified">11814         /* sample description entry (16) + sound sample description v1 (20+16) */</span>
<span class="line-modified">11815         if (len &lt; 52)</span>
<span class="line-modified">11816           goto corrupt_file;</span>
11817 
<span class="line-modified">11818         switch (fourcc) {</span>
<span class="line-modified">11819           case FOURCC_twos:</span>
<span class="line-modified">11820           case FOURCC_sowt:</span>
<span class="line-modified">11821           case FOURCC_raw_:</span>
11822           case FOURCC_lpcm:
<span class="line-modified">11823             break;</span>
<span class="line-modified">11824           default:</span>
<span class="line-modified">11825           {</span>
<span class="line-modified">11826             /* only parse extra decoding config for non-pcm audio */</span>
11827             entry-&gt;samples_per_packet = QT_UINT32 (stsd_entry_data + offset);
11828             entry-&gt;bytes_per_packet = QT_UINT32 (stsd_entry_data + offset + 4);
11829             entry-&gt;bytes_per_frame = QT_UINT32 (stsd_entry_data + offset + 8);
11830             entry-&gt;bytes_per_sample = QT_UINT32 (stsd_entry_data + offset + 12);
11831 
<span class="line-modified">11832             GST_LOG_OBJECT (qtdemux, &quot;samples/packet:   %d&quot;,</span>
11833                 entry-&gt;samples_per_packet);
<span class="line-modified">11834             GST_LOG_OBJECT (qtdemux, &quot;bytes/packet:     %d&quot;,</span>
11835                 entry-&gt;bytes_per_packet);
<span class="line-modified">11836             GST_LOG_OBJECT (qtdemux, &quot;bytes/frame:      %d&quot;,</span>
11837                 entry-&gt;bytes_per_frame);
<span class="line-modified">11838             GST_LOG_OBJECT (qtdemux, &quot;bytes/sample:     %d&quot;,</span>
11839                 entry-&gt;bytes_per_sample);
11840 
11841             if (!entry-&gt;sampled &amp;&amp; entry-&gt;bytes_per_packet) {
11842               entry-&gt;samples_per_frame = (entry-&gt;bytes_per_frame /
11843                   entry-&gt;bytes_per_packet) * entry-&gt;samples_per_packet;
<span class="line-modified">11844               GST_LOG_OBJECT (qtdemux, &quot;samples/frame:    %d&quot;,</span>
11845                   entry-&gt;samples_per_frame);
<span class="line-added">11846             }</span>
<span class="line-added">11847             break;</span>
11848           }

11849         }
<span class="line-modified">11850       } else if (version == 0x00020000) {</span>
<span class="line-modified">11851         union</span>
<span class="line-modified">11852         {</span>
<span class="line-modified">11853           gdouble fp;</span>
<span class="line-modified">11854           guint64 val;</span>
<span class="line-modified">11855         } qtfp;</span>

11856 
<span class="line-modified">11857         /* sample description entry (16) + sound sample description v2 (56) */</span>
<span class="line-modified">11858         if (len &lt; 72)</span>
<span class="line-modified">11859           goto corrupt_file;</span>
11860 
11861         qtfp.val = QT_UINT64 (stsd_entry_data + offset + 4);
11862         entry-&gt;rate = qtfp.fp;
11863         entry-&gt;n_channels = QT_UINT32 (stsd_entry_data + offset + 12);
11864 
<span class="line-modified">11865         GST_LOG_OBJECT (qtdemux, &quot;Sound sample description Version 2&quot;);</span>
11866         GST_LOG_OBJECT (qtdemux, &quot;sample rate:        %g&quot;, entry-&gt;rate);
11867         GST_LOG_OBJECT (qtdemux, &quot;n_channels:         %d&quot;, entry-&gt;n_channels);
<span class="line-modified">11868         GST_LOG_OBJECT (qtdemux, &quot;bits/channel:       %d&quot;,</span>
11869             QT_UINT32 (stsd_entry_data + offset + 20));
<span class="line-modified">11870         GST_LOG_OBJECT (qtdemux, &quot;format flags:       %X&quot;,</span>
11871             QT_UINT32 (stsd_entry_data + offset + 24));
<span class="line-modified">11872         GST_LOG_OBJECT (qtdemux, &quot;bytes/packet:       %d&quot;,</span>
11873             QT_UINT32 (stsd_entry_data + offset + 28));
<span class="line-modified">11874         GST_LOG_OBJECT (qtdemux, &quot;LPCM frames/packet: %d&quot;,</span>
11875             QT_UINT32 (stsd_entry_data + offset + 32));
<span class="line-modified">11876       } else if (version != 0x00000) {</span>
11877         GST_WARNING_OBJECT (qtdemux, &quot;unknown audio STSD version %08x&quot;,
11878             version);
<span class="line-modified">11879       }</span>
11880 
11881       if (entry-&gt;caps)
11882         gst_caps_unref (entry-&gt;caps);
11883 
11884       entry-&gt;caps = qtdemux_audio_caps (qtdemux, stream, entry, fourcc,
11885           stsd_entry_data + 32, len - 16, &amp;codec);
11886 
<span class="line-modified">11887       switch (fourcc) {</span>
<span class="line-modified">11888         case FOURCC_in24:</span>
<span class="line-modified">11889         {</span>
<span class="line-modified">11890           GNode *enda;</span>
<span class="line-modified">11891           GNode *in24;</span>
11892 
<span class="line-modified">11893           in24 = qtdemux_tree_get_child_by_type (stsd, FOURCC_in24);</span>
11894 
<span class="line-modified">11895           enda = qtdemux_tree_get_child_by_type (in24, FOURCC_enda);</span>
<span class="line-modified">11896           if (!enda) {</span>
<span class="line-modified">11897             wave = qtdemux_tree_get_child_by_type (in24, FOURCC_wave);</span>
<span class="line-modified">11898             if (wave)</span>
<span class="line-modified">11899               enda = qtdemux_tree_get_child_by_type (wave, FOURCC_enda);</span>
<span class="line-modified">11900           }</span>
<span class="line-modified">11901           if (enda) {</span>
<span class="line-modified">11902             int enda_value = QT_UINT16 ((guint8 *) enda-&gt;data + 8);</span>
11903             gst_caps_set_simple (entry-&gt;caps,
11904                 &quot;format&quot;, G_TYPE_STRING, (enda_value) ? &quot;S24LE&quot; : &quot;S24BE&quot;,
11905                 NULL);
<span class="line-added">11906           }</span>
<span class="line-added">11907           break;</span>
11908         }
<span class="line-modified">11909         case FOURCC_owma:</span>












11910         {
<span class="line-modified">11911           const guint8 *owma_data;</span>
<span class="line-modified">11912           const gchar *codec_name = NULL;</span>
<span class="line-modified">11913           guint owma_len;</span>
<span class="line-modified">11914           GstBuffer *buf;</span>
<span class="line-modified">11915           gint version = 1;</span>
<span class="line-modified">11916           /* from http://msdn.microsoft.com/en-us/library/dd757720(VS.85).aspx */</span>
<span class="line-modified">11917           /* FIXME this should also be gst_riff_strf_auds,</span>
<span class="line-modified">11918            * but the latter one is actually missing bits-per-sample :( */</span>
<span class="line-modified">11919           typedef struct</span>
<span class="line-modified">11920           {</span>
<span class="line-modified">11921             gint16 wFormatTag;</span>
<span class="line-added">11922             gint16 nChannels;</span>
<span class="line-added">11923             gint32 nSamplesPerSec;</span>
<span class="line-added">11924             gint32 nAvgBytesPerSec;</span>
<span class="line-added">11925             gint16 nBlockAlign;</span>
<span class="line-added">11926             gint16 wBitsPerSample;</span>
<span class="line-added">11927             gint16 cbSize;</span>
<span class="line-added">11928           } WAVEFORMATEX;</span>
<span class="line-added">11929           WAVEFORMATEX *wfex;</span>
<span class="line-added">11930 </span>
<span class="line-added">11931           GST_DEBUG_OBJECT (qtdemux, &quot;parse owma&quot;);</span>
11932           owma_data = stsd_entry_data;
<span class="line-modified">11933           owma_len = QT_UINT32 (owma_data);</span>
<span class="line-modified">11934           if (owma_len &lt;= 54) {</span>
<span class="line-modified">11935             GST_WARNING_OBJECT (qtdemux, &quot;Too small owma header, skipping&quot;);</span>
<span class="line-modified">11936             break;</span>
<span class="line-modified">11937           }</span>
<span class="line-modified">11938           wfex = (WAVEFORMATEX *) (owma_data + 36);</span>
<span class="line-modified">11939           buf = gst_buffer_new_and_alloc (owma_len - 54);</span>
<span class="line-modified">11940           gst_buffer_fill (buf, 0, owma_data + 54, owma_len - 54);</span>
<span class="line-modified">11941           if (wfex-&gt;wFormatTag == 0x0161) {</span>
<span class="line-modified">11942             codec_name = &quot;Windows Media Audio&quot;;</span>
<span class="line-modified">11943             version = 2;</span>
<span class="line-modified">11944           } else if (wfex-&gt;wFormatTag == 0x0162) {</span>
<span class="line-modified">11945             codec_name = &quot;Windows Media Audio 9 Pro&quot;;</span>
<span class="line-modified">11946             version = 3;</span>
<span class="line-modified">11947           } else if (wfex-&gt;wFormatTag == 0x0163) {</span>
<span class="line-modified">11948             codec_name = &quot;Windows Media Audio 9 Lossless&quot;;</span>
<span class="line-modified">11949             /* is that correct? gstffmpegcodecmap.c is missing it, but</span>
<span class="line-modified">11950              * fluendo codec seems to support it */</span>
<span class="line-modified">11951             version = 4;</span>
<span class="line-modified">11952           }</span>
11953 
11954           gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">11955               &quot;codec_data&quot;, GST_TYPE_BUFFER, buf,</span>
<span class="line-modified">11956               &quot;wmaversion&quot;, G_TYPE_INT, version,</span>
11957               &quot;block_align&quot;, G_TYPE_INT,
11958               GST_READ_UINT16_LE (&amp;wfex-&gt;nBlockAlign), &quot;bitrate&quot;, G_TYPE_INT,
11959               GST_READ_UINT32_LE (&amp;wfex-&gt;nAvgBytesPerSec), &quot;width&quot;, G_TYPE_INT,
11960               GST_READ_UINT16_LE (&amp;wfex-&gt;wBitsPerSample), &quot;depth&quot;, G_TYPE_INT,
11961               GST_READ_UINT16_LE (&amp;wfex-&gt;wBitsPerSample), NULL);
<span class="line-modified">11962           gst_buffer_unref (buf);</span>
11963 
<span class="line-modified">11964           if (codec_name) {</span>
<span class="line-modified">11965             g_free (codec);</span>
<span class="line-modified">11966             codec = g_strdup (codec_name);</span>
<span class="line-added">11967           }</span>
<span class="line-added">11968           break;</span>
11969         }


11970         case FOURCC_wma_:
11971         {
11972           gint len = QT_UINT32 (stsd_entry_data) - offset;
11973           const guint8 *wfex_data = stsd_entry_data + offset;
11974           const gchar *codec_name = NULL;
11975           gint version = 1;
11976           /* from http://msdn.microsoft.com/en-us/library/dd757720(VS.85).aspx */
11977           /* FIXME this should also be gst_riff_strf_auds,
11978            * but the latter one is actually missing bits-per-sample :( */
11979           typedef struct
11980           {
11981             gint16 wFormatTag;
11982             gint16 nChannels;
11983             gint32 nSamplesPerSec;
11984             gint32 nAvgBytesPerSec;
11985             gint16 nBlockAlign;
11986             gint16 wBitsPerSample;
11987             gint16 cbSize;
11988           } WAVEFORMATEX;
11989           WAVEFORMATEX wfex;
</pre>
<hr />
<pre>
12049 
12050                 if (size &gt; wfex.cbSize) {
12051                   GstBuffer *buf;
12052 
12053                   buf = gst_buffer_new_and_alloc (size - wfex.cbSize);
12054                   gst_buffer_fill (buf, 0, wfex_data + 8 + wfex.cbSize,
12055                       size - wfex.cbSize);
12056                   gst_caps_set_simple (entry-&gt;caps,
12057                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
12058                   gst_buffer_unref (buf);
12059                 } else {
12060                   GST_WARNING_OBJECT (qtdemux, &quot;no codec data&quot;);
12061                 }
12062 
12063                 if (codec_name) {
12064                   g_free (codec);
12065                   codec = g_strdup (codec_name);
12066                 }
12067                 break;
12068               }
<span class="line-modified">12069               default:</span>
<span class="line-modified">12070                 break;</span>
<span class="line-modified">12071             }</span>
12072             len -= size + 8;
12073             wfex_data += size + 8;
12074           }
12075           break;
12076         }
12077 #ifndef GSTREAMER_LITE
12078         case FOURCC_opus:
12079         {
12080           const guint8 *opus_data;
12081           guint8 *channel_mapping = NULL;
12082           guint32 rate;
12083           guint8 channels;
12084           guint8 channel_mapping_family;
12085           guint8 stream_count;
12086           guint8 coupled_count;
12087           guint8 i;
12088 
12089           opus_data = stsd_entry_data;
12090 
12091           channels = GST_READ_UINT8 (opus_data + 45);
</pre>
<hr />
<pre>
12093           channel_mapping_family = GST_READ_UINT8 (opus_data + 54);
12094           stream_count = GST_READ_UINT8 (opus_data + 55);
12095           coupled_count = GST_READ_UINT8 (opus_data + 56);
12096 
12097           if (channels &gt; 0) {
12098             channel_mapping = g_malloc (channels * sizeof (guint8));
12099             for (i = 0; i &lt; channels; i++)
12100               channel_mapping[i] = GST_READ_UINT8 (opus_data + i + 57);
12101           }
12102 
12103           entry-&gt;caps = gst_codec_utils_opus_create_caps (rate, channels,
12104               channel_mapping_family, stream_count, coupled_count,
12105               channel_mapping);
12106           break;
12107         }
12108 #endif // GSTREAMER_LITE
12109         default:
12110           break;
12111       }
12112 
<span class="line-modified">12113       if (codec) {</span>
<span class="line-modified">12114         GstStructure *s;</span>
<span class="line-modified">12115         gint bitrate = 0;</span>
12116 
12117         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">12118             GST_TAG_AUDIO_CODEC, codec, NULL);</span>
<span class="line-modified">12119         g_free (codec);</span>
<span class="line-modified">12120         codec = NULL;</span>
12121 
<span class="line-modified">12122         /* some bitrate info may have ended up in caps */</span>
12123         s = gst_caps_get_structure (entry-&gt;caps, 0);
<span class="line-modified">12124         gst_structure_get_int (s, &quot;bitrate&quot;, &amp;bitrate);</span>
<span class="line-modified">12125         if (bitrate &gt; 0)</span>
12126           gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
12127               GST_TAG_BITRATE, bitrate, NULL);
<span class="line-modified">12128       }</span>
12129 
12130       mp4a = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">12131       if (QTDEMUX_TREE_NODE_FOURCC (mp4a) != fourcc) {</span>
<span class="line-modified">12132         if (stream-&gt;protected &amp;&amp; QTDEMUX_TREE_NODE_FOURCC (mp4a) != FOURCC_enca)</span>






12133           mp4a = NULL;
<span class="line-modified">12134         else if (!stream-&gt;protected)</span>


12135           mp4a = NULL;

12136       }
12137 
<span class="line-modified">12138       wave = NULL;</span>
<span class="line-modified">12139       esds = NULL;</span>
<span class="line-modified">12140       if (mp4a) {</span>
<span class="line-modified">12141         wave = qtdemux_tree_get_child_by_type (mp4a, FOURCC_wave);</span>
<span class="line-modified">12142         if (wave)</span>
<span class="line-modified">12143           esds = qtdemux_tree_get_child_by_type (wave, FOURCC_esds);</span>
<span class="line-modified">12144         if (!esds)</span>
<span class="line-modified">12145           esds = qtdemux_tree_get_child_by_type (mp4a, FOURCC_esds);</span>
<span class="line-modified">12146       }</span>
12147 
12148 
<span class="line-modified">12149       /* If the fourcc&#39;s bottom 16 bits gives &#39;sm&#39;, then the top</span>
<span class="line-modified">12150          16 bits is a byte-swapped wave-style codec identifier,</span>
<span class="line-modified">12151          and we can find a WAVE header internally to a &#39;wave&#39; atom here.</span>
<span class="line-modified">12152          This can more clearly be thought of as &#39;ms&#39; as the top 16 bits, and a</span>
<span class="line-modified">12153          codec id as the bottom 16 bits - but byte-swapped to store in QT (which</span>
<span class="line-modified">12154          is big-endian).</span>
<span class="line-modified">12155        */</span>
<span class="line-modified">12156       if ((fourcc &amp; 0xffff) == ((&#39;s&#39; &lt;&lt; 8) | &#39;m&#39;)) {</span>
<span class="line-modified">12157         if (len &lt; offset + 20) {</span>
<span class="line-modified">12158           GST_WARNING_OBJECT (qtdemux, &quot;No wave atom in MS-style audio&quot;);</span>
<span class="line-modified">12159         } else {</span>
12160           guint32 datalen = QT_UINT32 (stsd_entry_data + offset + 16);
12161           const guint8 *data = stsd_entry_data + offset + 16;
<span class="line-modified">12162           GNode *wavenode;</span>
<span class="line-modified">12163           GNode *waveheadernode;</span>
12164 
<span class="line-modified">12165           wavenode = g_node_new ((guint8 *) data);</span>
<span class="line-modified">12166           if (qtdemux_parse_node (qtdemux, wavenode, data, datalen)) {</span>
<span class="line-modified">12167             const guint8 *waveheader;</span>
<span class="line-modified">12168             guint32 headerlen;</span>
12169 
<span class="line-modified">12170             waveheadernode = qtdemux_tree_get_child_by_type (wavenode, fourcc);</span>
<span class="line-modified">12171             if (waveheadernode) {</span>
<span class="line-modified">12172               waveheader = (const guint8 *) waveheadernode-&gt;data;</span>
<span class="line-modified">12173               headerlen = QT_UINT32 (waveheader);</span>
12174 
<span class="line-modified">12175               if (headerlen &gt; 8) {</span>
<span class="line-modified">12176                 gst_riff_strf_auds *header = NULL;</span>
<span class="line-modified">12177                 GstBuffer *headerbuf;</span>
<span class="line-modified">12178                 GstBuffer *extra;</span>
12179 
<span class="line-modified">12180                 waveheader += 8;</span>
<span class="line-modified">12181                 headerlen -= 8;</span>
12182 
<span class="line-modified">12183                 headerbuf = gst_buffer_new_and_alloc (headerlen);</span>
<span class="line-modified">12184                 gst_buffer_fill (headerbuf, 0, waveheader, headerlen);</span>
12185 
<span class="line-modified">12186                 if (gst_riff_parse_strf_auds (GST_ELEMENT_CAST (qtdemux),</span>
<span class="line-modified">12187                         headerbuf, &amp;header, &amp;extra)) {</span>
12188                   gst_caps_unref (entry-&gt;caps);
<span class="line-modified">12189                   /* FIXME: Need to do something with the channel reorder map */</span>
12190                   entry-&gt;caps =
12191                       gst_riff_create_audio_caps (header-&gt;format, NULL, header,
12192                       extra, NULL, NULL, NULL);
12193 
<span class="line-modified">12194                   if (extra)</span>
<span class="line-modified">12195                     gst_buffer_unref (extra);</span>
<span class="line-modified">12196                   g_free (header);</span>
<span class="line-added">12197                 }</span>
12198               }
<span class="line-modified">12199             } else</span>
<span class="line-modified">12200               GST_DEBUG (&quot;Didn&#39;t find waveheadernode for this codec&quot;);</span>
<span class="line-modified">12201           }</span>
<span class="line-added">12202           g_node_destroy (wavenode);</span>
12203         }
<span class="line-modified">12204       } else if (esds) {</span>


12205 #ifdef GSTREAMER_LITE
12206         if (!gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
12207                                       stream-&gt;stream_tags))
12208             goto corrupt_file;
12209 #else
12210         gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
12211             stream-&gt;stream_tags);
12212 #endif // GSTREAMER_LITE
<span class="line-modified">12213       } else {</span>
<span class="line-modified">12214         switch (fourcc) {</span>
12215 #if 0
<span class="line-modified">12216             /* FIXME: what is in the chunk? */</span>
<span class="line-modified">12217           case FOURCC_QDMC:</span>
<span class="line-modified">12218           {</span>
<span class="line-modified">12219             gint len = QT_UINT32 (stsd_data);</span>
12220 
<span class="line-modified">12221             /* seems to be always = 116 = 0x74 */</span>
<span class="line-modified">12222             break;</span>
<span class="line-modified">12223           }</span>
12224 #endif
<span class="line-modified">12225           case FOURCC_QDM2:</span>
<span class="line-modified">12226           {</span>
12227             gint len = QT_UINT32 (stsd_entry_data);
12228 
12229             if (len &gt; 0x3C) {
12230               GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x3C);
12231 
12232               gst_buffer_fill (buf, 0, stsd_entry_data + 0x3C, len - 0x3C);
12233               gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">12234                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">12235               gst_buffer_unref (buf);</span>
<span class="line-modified">12236             }</span>
12237             gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">12238                 &quot;samplesize&quot;, G_TYPE_INT, samplesize, NULL);</span>
<span class="line-modified">12239             break;</span>















12240           }
<span class="line-modified">12241           case FOURCC_alac:</span>
<span class="line-modified">12242           {</span>
<span class="line-modified">12243             GNode *alac, *wave = NULL;</span>
<span class="line-modified">12244 </span>
<span class="line-added">12245             /* apparently, m4a has this atom appended directly in the stsd entry,</span>
<span class="line-added">12246              * while mov has it in a wave atom */</span>
<span class="line-added">12247             alac = qtdemux_tree_get_child_by_type (stsd, FOURCC_alac);</span>
<span class="line-added">12248             if (alac) {</span>
<span class="line-added">12249               /* alac now refers to stsd entry atom */</span>
<span class="line-added">12250               wave = qtdemux_tree_get_child_by_type (alac, FOURCC_wave);</span>
<span class="line-added">12251               if (wave)</span>
<span class="line-added">12252                 alac = qtdemux_tree_get_child_by_type (wave, FOURCC_alac);</span>
<span class="line-added">12253               else</span>
<span class="line-added">12254                 alac = qtdemux_tree_get_child_by_type (alac, FOURCC_alac);</span>
<span class="line-added">12255             }</span>
<span class="line-added">12256             if (alac) {</span>
<span class="line-added">12257               const guint8 *alac_data = alac-&gt;data;</span>
<span class="line-added">12258               gint len = QT_UINT32 (alac-&gt;data);</span>
<span class="line-added">12259               GstBuffer *buf;</span>
12260 
<span class="line-modified">12261               if (len &lt; 36) {</span>
<span class="line-modified">12262                 GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">12263                     &quot;discarding alac atom with unexpected len %d&quot;, len);</span>
<span class="line-modified">12264               } else {</span>
<span class="line-modified">12265                 /* codec-data contains alac atom size and prefix,</span>
<span class="line-modified">12266                  * ffmpeg likes it that way, not quite gst-ish though ...*/</span>
<span class="line-modified">12267                 buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">12268                 gst_buffer_fill (buf, 0, alac-&gt;data, len);</span>
12269                 gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">12270                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">12271                 gst_buffer_unref (buf);</span>
12272 
12273                 entry-&gt;bytes_per_frame = QT_UINT32 (alac_data + 12);
12274                 entry-&gt;n_channels = QT_UINT8 (alac_data + 21);
12275                 entry-&gt;rate = QT_UINT32 (alac_data + 32);
<span class="line-added">12276               }</span>
12277             }

12278             gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">12279                 &quot;samplesize&quot;, G_TYPE_INT, samplesize, NULL);</span>
<span class="line-modified">12280             break;</span>
<span class="line-modified">12281           }</span>
12282           case FOURCC_fLaC:
12283           {
12284             /* The codingname of the sample entry is &#39;fLaC&#39; */
12285             GNode *flac = qtdemux_tree_get_child_by_type (stsd, FOURCC_fLaC);
12286 
12287             if (flac) {
12288               /* The &#39;dfLa&#39; box is added to the sample entry to convey
12289                  initializing information for the decoder. */
12290               const GNode *dfla =
12291                   qtdemux_tree_get_child_by_type (flac, FOURCC_dfLa);
12292 
12293               if (dfla) {
12294                 const guint32 len = QT_UINT32 (dfla-&gt;data);
12295 
12296                 /* Must contain at least dfLa box header (12),
12297                  * METADATA_BLOCK_HEADER (4), METADATA_BLOCK_STREAMINFO (34) */
12298                 if (len &lt; 50) {
12299                   GST_DEBUG_OBJECT (qtdemux,
12300                       &quot;discarding dfla atom with unexpected len %d&quot;, len);
12301                 } else {
</pre>
<hr />
<pre>
12364                     GST_WARNING_OBJECT (qtdemux,
12365                         &quot;discarding all METADATA_BLOCKs due to invalid &quot;
12366                         &quot;block_size %d at idx %d, rem %d&quot;, block_size, index,
12367                         remainder);
12368                   }
12369 
12370                   g_value_unset (&amp;value);
12371                   g_value_unset (&amp;array);
12372 
12373                   /* The sample rate obtained from the stsd may not be accurate
12374                    * since it cannot represent rates greater than 65535Hz, so
12375                    * override that value with the sample rate from the
12376                    * METADATA_BLOCK_STREAMINFO block */
12377                   CUR_STREAM (stream)-&gt;rate =
12378                       (QT_UINT32 (metadata_blocks + 14) &gt;&gt; 12) &amp; 0xFFFFF;
12379                 }
12380               }
12381             }
12382             break;
12383           }
<span class="line-modified">12384           case FOURCC_sawb:</span>
<span class="line-modified">12385             /* Fallthrough! */</span>
<span class="line-modified">12386             amrwb = TRUE;</span>
<span class="line-modified">12387           case FOURCC_samr:</span>
<span class="line-modified">12388           {</span>
12389             gint len = QT_UINT32 (stsd_entry_data);
12390 
12391             if (len &gt; 0x24) {
12392               GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x24);
<span class="line-modified">12393               guint bitrate;</span>
12394 
12395               gst_buffer_fill (buf, 0, stsd_entry_data + 0x24, len - 0x24);
12396 
<span class="line-modified">12397               /* If we have enough data, let&#39;s try to get the &#39;damr&#39; atom. See</span>
<span class="line-modified">12398                * the 3GPP container spec (26.244) for more details. */</span>
<span class="line-modified">12399               if ((len - 0x34) &gt; 8 &amp;&amp;</span>
<span class="line-modified">12400                   (bitrate = qtdemux_parse_amr_bitrate (buf, amrwb))) {</span>
12401                 gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">12402                     GST_TAG_MAXIMUM_BITRATE, bitrate, NULL);</span>
<span class="line-modified">12403               }</span>
12404 
12405               gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">12406                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">12407               gst_buffer_unref (buf);</span>
<span class="line-added">12408             }</span>
<span class="line-added">12409             break;</span>
12410           }


12411           case FOURCC_mp4a:
12412           {
12413             /* mp4a atom withtout ESDS; Attempt to build codec data from atom */
12414             gint len = QT_UINT32 (stsd_entry_data);
12415 
12416             if (len &gt;= 34) {
12417               guint16 sound_version = QT_UINT16 (stsd_entry_data + 16);
12418 
12419               if (sound_version == 1) {
12420                 guint16 channels = QT_UINT16 (stsd_entry_data + 24);
12421                 guint32 time_scale = QT_UINT32 (stsd_entry_data + 30);
12422                 guint8 codec_data[2];
12423                 GstBuffer *buf;
12424                 gint profile = 2;       /* FIXME: Can this be determined somehow? There doesn&#39;t seem to be anything in mp4a atom that specifis compression */
12425 
12426                 gint sample_rate_index =
12427                     gst_codec_utils_aac_get_index_from_sample_rate (time_scale);
12428 
12429                 /* build AAC codec data */
12430                 codec_data[0] = profile &lt;&lt; 3;
12431                 codec_data[0] |= ((sample_rate_index &gt;&gt; 1) &amp; 0x7);
12432                 codec_data[1] = (sample_rate_index &amp; 0x01) &lt;&lt; 7;
12433                 codec_data[1] |= (channels &amp; 0xF) &lt;&lt; 3;
12434 
12435                 buf = gst_buffer_new_and_alloc (2);
12436                 gst_buffer_fill (buf, 0, codec_data, 2);
12437                 gst_caps_set_simple (entry-&gt;caps,
12438                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
12439                 gst_buffer_unref (buf);
12440               }
12441             }
12442             break;
12443           }
12444           case FOURCC_lpcm:
12445             /* Fully handled elsewhere */
12446             break;
<span class="line-modified">12447           default:</span>
<span class="line-modified">12448             GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">12449                 &quot;unhandled type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">12450             break;</span>
<span class="line-added">12451         }</span>
12452       }
<span class="line-modified">12453       GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">12454           &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>

12455           GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
12456 
<span class="line-modified">12457     } else if (stream-&gt;subtype == FOURCC_strm) {</span>
<span class="line-modified">12458       if (fourcc == FOURCC_rtsp) {</span>
<span class="line-modified">12459         stream-&gt;redirect_uri = qtdemux_get_rtsp_uri_from_hndl (qtdemux, minf);</span>
<span class="line-modified">12460       } else {</span>
<span class="line-modified">12461         GST_INFO_OBJECT (qtdemux, &quot;unhandled stream type %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">12462             GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">12463         goto unknown_stream;</span>
<span class="line-modified">12464       }</span>
12465       entry-&gt;sampled = TRUE;
<span class="line-modified">12466     } else if (stream-&gt;subtype == FOURCC_subp || stream-&gt;subtype == FOURCC_text</span>
<span class="line-modified">12467         || stream-&gt;subtype == FOURCC_sbtl || stream-&gt;subtype == FOURCC_subt</span>
<span class="line-added">12468         || stream-&gt;subtype == FOURCC_clcp) {</span>
12469 
12470       entry-&gt;sampled = TRUE;
12471       entry-&gt;sparse = TRUE;
12472 
12473       entry-&gt;caps =
12474           qtdemux_sub_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
12475           &amp;codec);
<span class="line-modified">12476       if (codec) {</span>
12477         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">12478             GST_TAG_SUBTITLE_CODEC, codec, NULL);</span>
<span class="line-modified">12479         g_free (codec);</span>
<span class="line-modified">12480         codec = NULL;</span>
<span class="line-modified">12481       }</span>
12482 
<span class="line-modified">12483       /* hunt for sort-of codec data */</span>
<span class="line-modified">12484       switch (fourcc) {</span>
<span class="line-modified">12485         case FOURCC_mp4s:</span>
<span class="line-modified">12486         {</span>
<span class="line-modified">12487           GNode *mp4s = NULL;</span>
<span class="line-modified">12488           GNode *esds = NULL;</span>
<span class="line-modified">12489 </span>
<span class="line-modified">12490           /* look for palette in a stsd-&gt;mp4s-&gt;esds sub-atom */</span>
<span class="line-modified">12491           mp4s = qtdemux_tree_get_child_by_type (stsd, FOURCC_mp4s);</span>
<span class="line-modified">12492           if (mp4s)</span>
<span class="line-modified">12493             esds = qtdemux_tree_get_child_by_type (mp4s, FOURCC_esds);</span>
<span class="line-modified">12494           if (esds == NULL) {</span>
<span class="line-modified">12495             /* Invalid STSD */</span>
<span class="line-modified">12496             GST_LOG_OBJECT (qtdemux, &quot;Skipping invalid stsd: no esds child&quot;);</span>
<span class="line-modified">12497             break;</span>
12498           }
12499 
12500           gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
12501               stream-&gt;stream_tags);
<span class="line-modified">12502           break;</span>
<span class="line-added">12503         }</span>
<span class="line-added">12504         default:</span>
<span class="line-added">12505           GST_INFO_OBJECT (qtdemux,</span>
<span class="line-added">12506               &quot;unhandled type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));</span>
<span class="line-added">12507           break;</span>
12508       }
<span class="line-modified">12509       GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">12510           &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>





12511           GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
<span class="line-modified">12512     } else {</span>
<span class="line-modified">12513       /* everything in 1 sample */</span>
12514       entry-&gt;sampled = TRUE;
12515 
12516       entry-&gt;caps =
12517           qtdemux_generic_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
12518           &amp;codec);
12519 
12520       if (entry-&gt;caps == NULL)
<span class="line-modified">12521         goto unknown_stream;</span>
12522 
<span class="line-modified">12523       if (codec) {</span>
12524         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">12525             GST_TAG_SUBTITLE_CODEC, codec, NULL);</span>
<span class="line-modified">12526         g_free (codec);</span>
<span class="line-modified">12527         codec = NULL;</span>
<span class="line-modified">12528       }</span>
<span class="line-modified">12529     }</span>
12530 
<span class="line-modified">12531     /* promote to sampled format */</span>
12532     if (entry-&gt;fourcc == FOURCC_samr) {
<span class="line-modified">12533       /* force mono 8000 Hz for AMR */</span>
12534       entry-&gt;sampled = TRUE;
12535       entry-&gt;n_channels = 1;
12536       entry-&gt;rate = 8000;
12537     } else if (entry-&gt;fourcc == FOURCC_sawb) {
<span class="line-modified">12538       /* force mono 16000 Hz for AMR-WB */</span>
12539       entry-&gt;sampled = TRUE;
12540       entry-&gt;n_channels = 1;
12541       entry-&gt;rate = 16000;
12542     } else if (entry-&gt;fourcc == FOURCC_mp4a) {
12543       entry-&gt;sampled = TRUE;
<span class="line-modified">12544     }</span>
12545 
12546 
12547     stsd_entry_data += len;
12548     remaining_stsd_len -= len;
12549 
12550   }
12551 
12552   /* collect sample information */
12553   if (!qtdemux_stbl_init (qtdemux, stream, stbl))
12554     goto samples_failed;
12555 
12556   if (qtdemux-&gt;fragmented) {
12557     guint64 offset;
12558 
12559     /* need all moov samples as basis; probably not many if any at all */
12560     /* prevent moof parsing taking of at this time */
12561     offset = qtdemux-&gt;moof_offset;
12562     qtdemux-&gt;moof_offset = 0;
12563     if (stream-&gt;n_samples &amp;&amp;
12564         !qtdemux_parse_samples (qtdemux, stream, stream-&gt;n_samples - 1)) {
</pre>
<hr />
<pre>
12576   /* configure segments */
12577   if (!qtdemux_parse_segments (qtdemux, stream, trak))
12578     goto segments_failed;
12579 
12580   /* add some language tag, if useful */
12581   if (stream-&gt;lang_id[0] != &#39;\0&#39; &amp;&amp; strcmp (stream-&gt;lang_id, &quot;unk&quot;) &amp;&amp;
12582       strcmp (stream-&gt;lang_id, &quot;und&quot;)) {
12583     const gchar *lang_code;
12584 
12585     /* convert ISO 639-2 code to ISO 639-1 */
12586     lang_code = gst_tag_get_language_code (stream-&gt;lang_id);
12587     gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
12588         GST_TAG_LANGUAGE_CODE, (lang_code) ? lang_code : stream-&gt;lang_id, NULL);
12589   }
12590 
12591   /* Check for UDTA tags */
12592   if ((udta = qtdemux_tree_get_child_by_type (trak, FOURCC_udta))) {
12593     qtdemux_parse_udta (qtdemux, stream-&gt;stream_tags, udta);
12594   }
12595 
<span class="line-modified">12596   /* Insert and sort new stream in track-id order.</span>
<span class="line-modified">12597    * This will help in comparing old/new streams during stream update check */</span>
<span class="line-modified">12598   g_ptr_array_add (qtdemux-&gt;active_streams, stream);</span>
<span class="line-modified">12599   g_ptr_array_sort (qtdemux-&gt;active_streams,</span>
<span class="line-modified">12600       (GCompareFunc) qtdemux_track_id_compare_func);</span>
<span class="line-modified">12601   GST_DEBUG_OBJECT (qtdemux, &quot;n_streams is now %d&quot;,</span>
<span class="line-modified">12602       QTDEMUX_N_STREAMS (qtdemux));</span>


12603 
12604   return TRUE;
12605 
12606 /* ERRORS */







12607 corrupt_file:
12608   {
12609     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
12610         (_(&quot;This file is corrupt and cannot be played.&quot;)), (NULL));
<span class="line-modified">12611     if (stream)</span>
<span class="line-modified">12612       gst_qtdemux_stream_unref (stream);</span>
12613     return FALSE;
12614   }
12615 error_encrypted:
12616   {
12617     GST_ELEMENT_ERROR (qtdemux, STREAM, DECRYPT, (NULL), (NULL));
<span class="line-modified">12618     gst_qtdemux_stream_unref (stream);</span>

12619     return FALSE;
12620   }
12621 samples_failed:
12622 segments_failed:
12623   {
12624     /* we posted an error already */
12625     /* free stbl sub-atoms */
12626     gst_qtdemux_stbl_free (stream);
<span class="line-modified">12627     gst_qtdemux_stream_unref (stream);</span>

12628     return FALSE;
12629   }
12630 existing_stream:
12631   {
12632     GST_INFO_OBJECT (qtdemux, &quot;stream with track id %i already exists&quot;,
12633         track_id);


12634     return TRUE;
12635   }
12636 unknown_stream:
12637   {
12638     GST_INFO_OBJECT (qtdemux, &quot;unknown subtype %&quot; GST_FOURCC_FORMAT,
12639         GST_FOURCC_ARGS (stream-&gt;subtype));
<span class="line-modified">12640     gst_qtdemux_stream_unref (stream);</span>








12641     return TRUE;
12642   }
12643 }
12644 
12645 /* If we can estimate the overall bitrate, and don&#39;t have information about the
12646  * stream bitrate for exactly one stream, this guesses the stream bitrate as
12647  * the overall bitrate minus the sum of the bitrates of all other streams. This
12648  * should be useful for the common case where we have one audio and one video
12649  * stream and can estimate the bitrate of one, but not the other. */
12650 static void
12651 gst_qtdemux_guess_bitrate (GstQTDemux * qtdemux)
12652 {
12653   QtDemuxStream *stream = NULL;
12654   gint64 size, sys_bitrate, sum_bitrate = 0;
12655   GstClockTime duration;

12656   guint bitrate;
<span class="line-added">12657   gint i;</span>
12658 
12659   if (qtdemux-&gt;fragmented)
12660     return;
12661 
12662   GST_DEBUG_OBJECT (qtdemux, &quot;Looking for streams with unknown bitrate&quot;);
12663 
12664   if (!gst_pad_peer_query_duration (qtdemux-&gt;sinkpad, GST_FORMAT_BYTES, &amp;size)
12665       || size &lt;= 0) {
12666     GST_DEBUG_OBJECT (qtdemux,
12667         &quot;Size in bytes of the stream not known - bailing&quot;);
12668     return;
12669   }
12670 
12671   /* Subtract the header size */
12672   GST_DEBUG_OBJECT (qtdemux, &quot;Total size %&quot; G_GINT64_FORMAT &quot;, header size %u&quot;,
12673       size, qtdemux-&gt;header_size);
12674 
12675   if (size &lt; qtdemux-&gt;header_size)
12676     return;
12677 
12678   size = size - qtdemux-&gt;header_size;
12679 
12680   if (!gst_qtdemux_get_duration (qtdemux, &amp;duration)) {
12681     GST_DEBUG_OBJECT (qtdemux, &quot;Stream duration not known - bailing&quot;);
12682     return;
12683   }
12684 
<span class="line-modified">12685   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">12686     QtDemuxStream *str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">12687     switch (str-&gt;subtype) {</span>
12688       case FOURCC_soun:
12689       case FOURCC_vide:
12690         GST_DEBUG_OBJECT (qtdemux, &quot;checking bitrate for %&quot; GST_PTR_FORMAT,
<span class="line-modified">12691             CUR_STREAM (str)-&gt;caps);</span>
12692         /* retrieve bitrate, prefer avg then max */
12693         bitrate = 0;
<span class="line-modified">12694         if (str-&gt;stream_tags) {</span>
<span class="line-modified">12695           if (gst_tag_list_get_uint (str-&gt;stream_tags,</span>
12696                   GST_TAG_MAXIMUM_BITRATE, &amp;bitrate))
<span class="line-modified">12697             GST_DEBUG_OBJECT (qtdemux, &quot;max-bitrate: %u&quot;, bitrate);</span>
<span class="line-modified">12698           if (gst_tag_list_get_uint (str-&gt;stream_tags,</span>
12699                   GST_TAG_NOMINAL_BITRATE, &amp;bitrate))
<span class="line-modified">12700             GST_DEBUG_OBJECT (qtdemux, &quot;nominal-bitrate: %u&quot;, bitrate);</span>
<span class="line-modified">12701           if (gst_tag_list_get_uint (str-&gt;stream_tags,</span>
12702                   GST_TAG_BITRATE, &amp;bitrate))
<span class="line-modified">12703             GST_DEBUG_OBJECT (qtdemux, &quot;bitrate: %u&quot;, bitrate);</span>
12704         }
12705         if (bitrate)
12706           sum_bitrate += bitrate;
12707         else {
12708           if (stream) {
12709             GST_DEBUG_OBJECT (qtdemux,
12710                 &quot;&gt;1 stream with unknown bitrate - bailing&quot;);
12711             return;
12712           } else
<span class="line-modified">12713             stream = str;</span>
12714         }
12715 
12716       default:
12717         /* For other subtypes, we assume no significant impact on bitrate */
12718         break;
12719     }
12720   }
12721 
12722   if (!stream) {
12723     GST_DEBUG_OBJECT (qtdemux, &quot;All stream bitrates are known&quot;);
12724     return;
12725   }
12726 
12727   sys_bitrate = gst_util_uint64_scale (size, GST_SECOND * 8, duration);
12728 
12729   if (sys_bitrate &lt; sum_bitrate) {
12730     /* This can happen, since sum_bitrate might be derived from maximum
12731      * bitrates and not average bitrates */
12732     GST_DEBUG_OBJECT (qtdemux,
12733         &quot;System bitrate less than sum bitrate - bailing&quot;);
12734     return;
12735   }
12736 
12737   bitrate = sys_bitrate - sum_bitrate;
12738   GST_DEBUG_OBJECT (qtdemux, &quot;System bitrate = %&quot; G_GINT64_FORMAT
12739       &quot;, Stream bitrate = %u&quot;, sys_bitrate, bitrate);
12740 
12741   if (!stream-&gt;stream_tags)
12742     stream-&gt;stream_tags = gst_tag_list_new_empty ();
12743   else
12744     stream-&gt;stream_tags = gst_tag_list_make_writable (stream-&gt;stream_tags);
12745 
12746   gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
12747       GST_TAG_BITRATE, bitrate, NULL);
12748 }
12749 
12750 static GstFlowReturn
12751 qtdemux_prepare_streams (GstQTDemux * qtdemux)
12752 {

12753   GstFlowReturn ret = GST_FLOW_OK;
<span class="line-added">12754   gint i;</span>
12755 
12756   GST_DEBUG_OBJECT (qtdemux, &quot;prepare streams&quot;);
12757 
<span class="line-modified">12758   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">12759     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
12760     guint32 sample_num = 0;
12761 
<span class="line-modified">12762     GST_DEBUG_OBJECT (qtdemux, &quot;track-id %u, fourcc %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">12763         stream-&gt;track_id, GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));</span>
12764 
12765     if (qtdemux-&gt;fragmented) {
12766       /* need all moov samples first */
12767       GST_OBJECT_LOCK (qtdemux);
12768       while (stream-&gt;n_samples == 0)
12769         if ((ret = qtdemux_add_fragmented_samples (qtdemux)) != GST_FLOW_OK)
12770           break;
12771       GST_OBJECT_UNLOCK (qtdemux);
12772     } else {
12773       /* discard any stray moof */
12774       qtdemux-&gt;moof_offset = 0;
12775     }
12776 
12777     /* prepare braking */
12778     if (ret != GST_FLOW_ERROR)
12779       ret = GST_FLOW_OK;
12780 
12781     /* in pull mode, we should have parsed some sample info by now;
12782      * and quite some code will not handle no samples.
12783      * in push mode, we&#39;ll just have to deal with it */
12784     if (G_UNLIKELY (qtdemux-&gt;pullbased &amp;&amp; !stream-&gt;n_samples)) {
12785       GST_DEBUG_OBJECT (qtdemux, &quot;no samples for stream; discarding&quot;);
<span class="line-modified">12786       g_ptr_array_remove_index (qtdemux-&gt;active_streams, i);</span>
<span class="line-added">12787       i--;</span>
<span class="line-added">12788       continue;</span>
<span class="line-added">12789     } else if (stream-&gt;track_id == qtdemux-&gt;chapters_track_id &amp;&amp;</span>
<span class="line-added">12790         (stream-&gt;subtype == FOURCC_text || stream-&gt;subtype == FOURCC_sbtl)) {</span>
<span class="line-added">12791       /* TODO - parse chapters track and expose it as GstToc; For now just ignore it</span>
<span class="line-added">12792          so that it doesn&#39;t look like a subtitle track */</span>
<span class="line-added">12793       g_ptr_array_remove_index (qtdemux-&gt;active_streams, i);</span>
12794       i--;
12795       continue;
12796     }
12797 
12798     /* parse the initial sample for use in setting the frame rate cap */
12799     while (sample_num == 0 &amp;&amp; sample_num &lt; stream-&gt;n_samples) {
12800       if (!qtdemux_parse_samples (qtdemux, stream, sample_num))
12801         break;
12802       ++sample_num;
12803     }
<span class="line-modified">12804   }</span>





12805 
12806   return ret;
12807 }
12808 
<span class="line-added">12809 static gboolean</span>
<span class="line-added">12810 _stream_equal_func (const QtDemuxStream * stream, const gchar * stream_id)</span>
<span class="line-added">12811 {</span>
<span class="line-added">12812   return g_strcmp0 (stream-&gt;stream_id, stream_id) == 0;</span>
<span class="line-added">12813 }</span>
<span class="line-added">12814 </span>
<span class="line-added">12815 static gboolean</span>
<span class="line-added">12816 qtdemux_is_streams_update (GstQTDemux * qtdemux)</span>
<span class="line-added">12817 {</span>
<span class="line-added">12818   gint i;</span>
<span class="line-added">12819 </span>
<span class="line-added">12820   /* Different length, updated */</span>
<span class="line-added">12821   if (QTDEMUX_N_STREAMS (qtdemux) != qtdemux-&gt;old_streams-&gt;len)</span>
<span class="line-added">12822     return TRUE;</span>
<span class="line-added">12823 </span>
<span class="line-added">12824   /* streams in list are sorted in track-id order */</span>
<span class="line-added">12825   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">12826     /* Different stream-id, updated */</span>
<span class="line-added">12827     if (g_strcmp0 (QTDEMUX_NTH_STREAM (qtdemux, i)-&gt;stream_id,</span>
<span class="line-added">12828             QTDEMUX_NTH_OLD_STREAM (qtdemux, i)-&gt;stream_id))</span>
<span class="line-added">12829       return TRUE;</span>
<span class="line-added">12830   }</span>
<span class="line-added">12831 </span>
<span class="line-added">12832   return FALSE;</span>
<span class="line-added">12833 }</span>
<span class="line-added">12834 </span>
<span class="line-added">12835 static gboolean</span>
<span class="line-added">12836 qtdemux_reuse_and_configure_stream (GstQTDemux * qtdemux,</span>
<span class="line-added">12837     QtDemuxStream * oldstream, QtDemuxStream * newstream)</span>
<span class="line-added">12838 {</span>
<span class="line-added">12839   /* Connect old stream&#39;s srcpad to new stream */</span>
<span class="line-added">12840   newstream-&gt;pad = oldstream-&gt;pad;</span>
<span class="line-added">12841   oldstream-&gt;pad = NULL;</span>
<span class="line-added">12842 </span>
<span class="line-added">12843   /* unset new_stream to prevent stream-start event */</span>
<span class="line-added">12844   newstream-&gt;new_stream = FALSE;</span>
<span class="line-added">12845 </span>
<span class="line-added">12846   return gst_qtdemux_configure_stream (qtdemux, newstream);</span>
<span class="line-added">12847 }</span>
<span class="line-added">12848 </span>
<span class="line-added">12849 /* g_ptr_array_find_with_equal_func is available since 2.54,</span>
<span class="line-added">12850  * replacement until we can depend unconditionally on the real one in GLib */</span>
<span class="line-added">12851 #if !GLIB_CHECK_VERSION(2,54,0)</span>
<span class="line-added">12852 #define g_ptr_array_find_with_equal_func qtdemux_ptr_array_find_with_equal_func</span>
<span class="line-added">12853 static gboolean</span>
<span class="line-added">12854 qtdemux_ptr_array_find_with_equal_func (GPtrArray * haystack,</span>
<span class="line-added">12855     gconstpointer needle, GEqualFunc equal_func, guint * index_)</span>
<span class="line-added">12856 {</span>
<span class="line-added">12857   guint i;</span>
<span class="line-added">12858 </span>
<span class="line-added">12859   g_return_val_if_fail (haystack != NULL, FALSE);</span>
<span class="line-added">12860 </span>
<span class="line-added">12861   if (equal_func == NULL)</span>
<span class="line-added">12862     equal_func = g_direct_equal;</span>
<span class="line-added">12863 </span>
<span class="line-added">12864   for (i = 0; i &lt; haystack-&gt;len; i++) {</span>
<span class="line-added">12865     if (equal_func (g_ptr_array_index (haystack, i), needle)) {</span>
<span class="line-added">12866       if (index_ != NULL)</span>
<span class="line-added">12867         *index_ = i;</span>
<span class="line-added">12868       return TRUE;</span>
<span class="line-added">12869     }</span>
<span class="line-added">12870   }</span>
<span class="line-added">12871 </span>
<span class="line-added">12872   return FALSE;</span>
<span class="line-added">12873 }</span>
<span class="line-added">12874 #endif</span>
<span class="line-added">12875 </span>
<span class="line-added">12876 static gboolean</span>
<span class="line-added">12877 qtdemux_update_streams (GstQTDemux * qtdemux)</span>
<span class="line-added">12878 {</span>
<span class="line-added">12879   gint i;</span>
<span class="line-added">12880   g_assert (qtdemux-&gt;streams_aware);</span>
<span class="line-added">12881 </span>
<span class="line-added">12882   /* At below, figure out which stream in active_streams has identical stream-id</span>
<span class="line-added">12883    * with that of in old_streams. If there is matching stream-id,</span>
<span class="line-added">12884    * corresponding newstream will not be exposed again,</span>
<span class="line-added">12885    * but demux will reuse srcpad of matched old stream</span>
<span class="line-added">12886    *</span>
<span class="line-added">12887    * active_streams : newly created streams from the latest moov</span>
<span class="line-added">12888    * old_streams : existing streams (belong to previous moov)</span>
<span class="line-added">12889    */</span>
<span class="line-added">12890 </span>
<span class="line-added">12891   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">12892     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">12893     QtDemuxStream *oldstream = NULL;</span>
<span class="line-added">12894     guint target;</span>
<span class="line-added">12895 </span>
<span class="line-added">12896     GST_DEBUG_OBJECT (qtdemux, &quot;track-id %u, fourcc %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added">12897         stream-&gt;track_id, GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));</span>
<span class="line-added">12898 </span>
<span class="line-added">12899     if (g_ptr_array_find_with_equal_func (qtdemux-&gt;old_streams,</span>
<span class="line-added">12900             stream-&gt;stream_id, (GEqualFunc) _stream_equal_func, &amp;target)) {</span>
<span class="line-added">12901       oldstream = QTDEMUX_NTH_OLD_STREAM (qtdemux, target);</span>
<span class="line-added">12902 </span>
<span class="line-added">12903       /* null pad stream cannot be reused */</span>
<span class="line-added">12904       if (oldstream-&gt;pad == NULL)</span>
<span class="line-added">12905         oldstream = NULL;</span>
<span class="line-added">12906     }</span>
<span class="line-added">12907 </span>
<span class="line-added">12908     if (oldstream) {</span>
<span class="line-added">12909       GST_DEBUG_OBJECT (qtdemux, &quot;Reuse track-id %d&quot;, oldstream-&gt;track_id);</span>
<span class="line-added">12910 </span>
<span class="line-added">12911       if (!qtdemux_reuse_and_configure_stream (qtdemux, oldstream, stream))</span>
<span class="line-added">12912         return FALSE;</span>
<span class="line-added">12913 </span>
<span class="line-added">12914       /* we don&#39;t need to preserve order of old streams */</span>
<span class="line-added">12915       g_ptr_array_remove_fast (qtdemux-&gt;old_streams, oldstream);</span>
<span class="line-added">12916     } else {</span>
<span class="line-added">12917       GstTagList *list;</span>
<span class="line-added">12918 </span>
<span class="line-added">12919       /* now we have all info and can expose */</span>
<span class="line-added">12920       list = stream-&gt;stream_tags;</span>
<span class="line-added">12921       stream-&gt;stream_tags = NULL;</span>
<span class="line-added">12922       if (!gst_qtdemux_add_stream (qtdemux, stream, list))</span>
<span class="line-added">12923         return FALSE;</span>
<span class="line-added">12924     }</span>
<span class="line-added">12925   }</span>
<span class="line-added">12926 </span>
<span class="line-added">12927   return TRUE;</span>
<span class="line-added">12928 }</span>
<span class="line-added">12929 </span>
<span class="line-added">12930 /* Must be called with expose lock */</span>
12931 static GstFlowReturn
12932 qtdemux_expose_streams (GstQTDemux * qtdemux)
12933 {
12934   gint i;


12935 
12936   GST_DEBUG_OBJECT (qtdemux, &quot;exposing streams&quot;);
12937 
<span class="line-modified">12938   if (!qtdemux_is_streams_update (qtdemux)) {</span>
<span class="line-modified">12939     GST_DEBUG_OBJECT (qtdemux, &quot;Reuse all streams&quot;);</span>
<span class="line-modified">12940     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">12941       QtDemuxStream *new_stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">12942       QtDemuxStream *old_stream = QTDEMUX_NTH_OLD_STREAM (qtdemux, i);</span>
<span class="line-added">12943       if (!qtdemux_reuse_and_configure_stream (qtdemux, old_stream, new_stream))</span>
<span class="line-added">12944         return GST_FLOW_ERROR;</span>
<span class="line-added">12945     }</span>
12946 
<span class="line-modified">12947     g_ptr_array_set_size (qtdemux-&gt;old_streams, 0);</span>
<span class="line-modified">12948     qtdemux-&gt;need_segment = TRUE;</span>
12949 
<span class="line-modified">12950     return GST_FLOW_OK;</span>
<span class="line-modified">12951   }</span>






12952 
<span class="line-modified">12953   if (qtdemux-&gt;streams_aware) {</span>
<span class="line-modified">12954     if (!qtdemux_update_streams (qtdemux))</span>




12955       return GST_FLOW_ERROR;
<span class="line-added">12956   } else {</span>
<span class="line-added">12957     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">12958       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">12959       GstTagList *list;</span>
<span class="line-added">12960 </span>
<span class="line-added">12961       /* now we have all info and can expose */</span>
<span class="line-added">12962       list = stream-&gt;stream_tags;</span>
<span class="line-added">12963       stream-&gt;stream_tags = NULL;</span>
<span class="line-added">12964       if (!gst_qtdemux_add_stream (qtdemux, stream, list))</span>
<span class="line-added">12965         return GST_FLOW_ERROR;</span>
<span class="line-added">12966 </span>
<span class="line-added">12967     }</span>
12968   }
12969 
12970   gst_qtdemux_guess_bitrate (qtdemux);
12971 
12972   gst_element_no_more_pads (GST_ELEMENT_CAST (qtdemux));
12973 
<span class="line-modified">12974   /* If we have still old_streams, it&#39;s no more used stream */</span>
<span class="line-modified">12975   for (i = 0; i &lt; qtdemux-&gt;old_streams-&gt;len; i++) {</span>
<span class="line-modified">12976     QtDemuxStream *stream = QTDEMUX_NTH_OLD_STREAM (qtdemux, i);</span>
12977 
<span class="line-modified">12978     if (stream-&gt;pad) {</span>
<span class="line-modified">12979       GstEvent *event;</span>
<span class="line-modified">12980 </span>
<span class="line-added">12981       event = gst_event_new_eos ();</span>
<span class="line-added">12982       if (qtdemux-&gt;segment_seqnum)</span>
<span class="line-added">12983         gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);</span>
12984 
<span class="line-modified">12985       gst_pad_push_event (stream-&gt;pad, event);</span>
<span class="line-modified">12986     }</span>



12987   }
12988 
<span class="line-added">12989   g_ptr_array_set_size (qtdemux-&gt;old_streams, 0);</span>
<span class="line-added">12990 </span>
12991   /* check if we should post a redirect in case there is a single trak
12992    * and it is a redirecting trak */
<span class="line-modified">12993   if (QTDEMUX_N_STREAMS (qtdemux) == 1 &amp;&amp;</span>
<span class="line-added">12994       QTDEMUX_NTH_STREAM (qtdemux, 0)-&gt;redirect_uri != NULL) {</span>
12995     GstMessage *m;
12996 
12997     GST_INFO_OBJECT (qtdemux, &quot;Issuing a redirect due to a single track with &quot;
12998         &quot;an external content&quot;);
12999     m = gst_message_new_element (GST_OBJECT_CAST (qtdemux),
13000         gst_structure_new (&quot;redirect&quot;,
<span class="line-modified">13001             &quot;new-location&quot;, G_TYPE_STRING,</span>
<span class="line-modified">13002             QTDEMUX_NTH_STREAM (qtdemux, 0)-&gt;redirect_uri, NULL));</span>
13003     gst_element_post_message (GST_ELEMENT_CAST (qtdemux), m);
13004     qtdemux-&gt;posted_redirect = TRUE;
13005   }
13006 
<span class="line-modified">13007   g_ptr_array_foreach (qtdemux-&gt;active_streams,</span>
<span class="line-modified">13008       (GFunc) qtdemux_do_allocation, qtdemux);</span>
13009 
<span class="line-modified">13010   qtdemux-&gt;need_segment = TRUE;</span>

13011 
13012   qtdemux-&gt;exposed = TRUE;
13013   return GST_FLOW_OK;
13014 }
13015 
13016 /* check if major or compatible brand is 3GP */
13017 static inline gboolean
13018 qtdemux_is_brand_3gp (GstQTDemux * qtdemux, gboolean major)
13019 {
13020   if (major) {
13021     return ((qtdemux-&gt;major_brand &amp; GST_MAKE_FOURCC (255, 255, 0, 0)) ==
13022         FOURCC_3g__);
13023   } else if (qtdemux-&gt;comp_brands != NULL) {
13024     GstMapInfo map;
13025     guint8 *data;
13026     gsize size;
13027     gboolean res = FALSE;
13028 
13029     gst_buffer_map (qtdemux-&gt;comp_brands, &amp;map, GST_MAP_READ);
13030     data = map.data;
</pre>
<hr />
<pre>
13273         goto normal;
13274       }
13275     } else {
13276     normal:
13277       offset = 8;
13278       GST_DEBUG_OBJECT (qtdemux, &quot;found normal text tag&quot;);
13279       ret = FALSE;              /* may have to fallback */
13280     }
13281     if (charset) {
13282       GError *err = NULL;
13283 
13284       s = g_convert ((gchar *) node-&gt;data + offset, len - offset, &quot;utf8&quot;,
13285           charset, NULL, NULL, &amp;err);
13286       if (err) {
13287         GST_DEBUG_OBJECT (qtdemux, &quot;Failed to convert string from charset %s:&quot;
13288             &quot; %s(%d): %s&quot;, charset, g_quark_to_string (err-&gt;domain), err-&gt;code,
13289             err-&gt;message);
13290         g_error_free (err);
13291       }
13292     } else {
<span class="line-modified">13293       s = gst_tag_freeform_string_to_utf8 ((char *) node-&gt;data + offset,</span>
<span class="line-modified">13294           len - offset, env_vars);</span>
13295     }
13296     if (s) {
13297       GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %s&quot;, GST_STR_NULL (s));
13298       gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, s, NULL);
13299       g_free (s);
13300       ret = TRUE;
13301     } else {
13302       GST_DEBUG_OBJECT (qtdemux, &quot;failed to convert %s tag to UTF-8&quot;, tag);
13303     }
13304   }
13305   return ret;
13306 }
13307 
13308 static void
13309 qtdemux_tag_add_str (GstQTDemux * qtdemux, GstTagList * taglist,
13310     const char *tag, const char *dummy, GNode * node)
13311 {
13312   qtdemux_tag_add_str_full (qtdemux, taglist, tag, dummy, node);
13313 }
13314 
</pre>
<hr />
<pre>
13491         image_type = GST_TAG_IMAGE_TYPE_FRONT_COVER;
13492       else
13493         image_type = GST_TAG_IMAGE_TYPE_NONE;
13494 
13495       if ((sample =
13496               gst_tag_image_data_to_image_sample ((guint8 *) data-&gt;data + 16,
13497                   len - 16, image_type))) {
13498         GST_DEBUG_OBJECT (qtdemux, &quot;adding tag size %d&quot;, len - 16);
13499         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag1, sample, NULL);
13500         gst_sample_unref (sample);
13501       }
13502     }
13503   }
13504 }
13505 
13506 static void
13507 qtdemux_tag_add_date (GstQTDemux * qtdemux, GstTagList * taglist,
13508     const char *tag, const char *dummy, GNode * node)
13509 {
13510   GNode *data;
<span class="line-added">13511   GstDateTime *datetime = NULL;</span>
13512   char *s;
13513   int len;
13514   int type;
13515 
13516   data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
13517   if (data) {
13518     len = QT_UINT32 (data-&gt;data);
13519     type = QT_UINT32 ((guint8 *) data-&gt;data + 8);
13520     if (type == 0x00000001 &amp;&amp; len &gt; 16) {
13521       guint y, m = 1, d = 1;
13522       gint ret;
13523 
13524       s = g_strndup ((char *) data-&gt;data + 16, len - 16);
13525       GST_DEBUG_OBJECT (qtdemux, &quot;adding date &#39;%s&#39;&quot;, s);
<span class="line-added">13526       datetime = gst_date_time_new_from_iso8601_string (s);</span>
<span class="line-added">13527       if (datetime != NULL) {</span>
<span class="line-added">13528         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, GST_TAG_DATE_TIME,</span>
<span class="line-added">13529             datetime, NULL);</span>
<span class="line-added">13530         gst_date_time_unref (datetime);</span>
<span class="line-added">13531       }</span>
<span class="line-added">13532 </span>
13533       ret = sscanf (s, &quot;%u-%u-%u&quot;, &amp;y, &amp;m, &amp;d);
13534       if (ret &gt;= 1 &amp;&amp; y &gt; 1500 &amp;&amp; y &lt; 3000) {
13535         GDate *date;
13536 
13537         date = g_date_new_dmy (d, m, y);
13538         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, date, NULL);
13539         g_date_free (date);
13540       } else {
13541         GST_DEBUG_OBJECT (qtdemux, &quot;could not parse date string &#39;%s&#39;&quot;, s);
13542       }
13543       g_free (s);
13544     }
13545   }
13546 }
13547 
13548 static void
13549 qtdemux_tag_add_gnre (GstQTDemux * qtdemux, GstTagList * taglist,
13550     const char *tag, const char *dummy, GNode * node)
13551 {
13552   GNode *data;
</pre>
<hr />
<pre>
13716 
13717   return;
13718 
13719 /* errors */
13720 unknown_tag:
13721 #ifndef GST_DISABLE_GST_DEBUG
13722   {
13723     gchar *namestr_dbg;
13724     gchar *meanstr_dbg;
13725 
13726     meanstr_dbg = g_strndup (meanstr, meansize);
13727     namestr_dbg = g_strndup (namestr, namesize);
13728 
13729     GST_WARNING_OBJECT (demux, &quot;This tag %s:%s type:%u is not mapped, &quot;
13730         &quot;file a bug at bugzilla.gnome.org&quot;, meanstr_dbg, namestr_dbg, datatype);
13731 
13732     g_free (namestr_dbg);
13733     g_free (meanstr_dbg);
13734   }
13735 #endif
<span class="line-modified">13736   return;</span>
13737 }
13738 
13739 static void
13740 qtdemux_tag_add_id32 (GstQTDemux * demux, GstTagList * taglist, const char *tag,
13741     const char *tag_bis, GNode * node)
13742 {
13743   guint8 *data;
13744   GstBuffer *buf;
13745   guint len;
13746   GstTagList *id32_taglist = NULL;
13747 
13748   GST_LOG_OBJECT (demux, &quot;parsing ID32&quot;);
13749 
13750   data = node-&gt;data;
13751   len = GST_READ_UINT32_BE (data);
13752 
13753   /* need at least full box and language tag */
13754   if (len &lt; 12 + 2)
13755     return;
13756 
</pre>
<hr />
<pre>
14093 #endif
14094         guint check_type = QT_UINT16 ((guint8 *) rmvc-&gt;data + 24);
14095 
14096         GST_LOG_OBJECT (qtdemux,
14097             &quot;version check atom [%&quot; GST_FOURCC_FORMAT &quot;], version=0x%08x&quot;
14098             &quot;, mask=%08x, check_type=%u&quot;, GST_FOURCC_ARGS (package), version,
14099             bitmask, check_type);
14100         if (package == FOURCC_qtim &amp;&amp; check_type == 0) {
14101           ref.min_req_qt_version = version;
14102         }
14103       }
14104 
14105       rdrf = qtdemux_tree_get_child_by_type (rmda, FOURCC_rdrf);
14106       if (rdrf) {
14107         guint32 ref_type;
14108         guint8 *ref_data;
14109         guint ref_len;
14110 
14111         ref_len = QT_UINT32 ((guint8 *) rdrf-&gt;data);
14112         if (ref_len &gt; 20) {
<span class="line-modified">14113           ref_type = QT_FOURCC ((guint8 *) rdrf-&gt;data + 12);</span>
<span class="line-modified">14114           ref_data = (guint8 *) rdrf-&gt;data + 20;</span>
<span class="line-modified">14115           if (ref_type == FOURCC_alis) {</span>
<span class="line-modified">14116             guint record_len, record_version, fn_len;</span>
14117 
14118             if (ref_len &gt; 70) {
<span class="line-modified">14119               /* MacOSX alias record, google for alias-layout.txt */</span>
<span class="line-modified">14120               record_len = QT_UINT16 (ref_data + 4);</span>
<span class="line-modified">14121               record_version = QT_UINT16 (ref_data + 4 + 2);</span>
<span class="line-modified">14122               fn_len = QT_UINT8 (ref_data + 50);</span>
<span class="line-modified">14123               if (record_len &gt; 50 &amp;&amp; record_version == 2 &amp;&amp; fn_len &gt; 0) {</span>
<span class="line-modified">14124                 ref.location = g_strndup ((gchar *) ref_data + 51, fn_len);</span>
<span class="line-modified">14125               }</span>
14126             } else {
14127               GST_WARNING_OBJECT (qtdemux, &quot;Invalid rdrf/alis size (%u &lt; 70)&quot;,
14128                   ref_len);
14129             }
<span class="line-modified">14130           } else if (ref_type == FOURCC_url_) {</span>
14131             ref.location = g_strndup ((gchar *) ref_data, ref_len - 8);
<span class="line-modified">14132           } else {</span>
<span class="line-modified">14133             GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">14134                 &quot;unknown rdrf reference type %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">14135                 GST_FOURCC_ARGS (ref_type));</span>
<span class="line-modified">14136           }</span>
<span class="line-modified">14137           if (ref.location != NULL) {</span>
<span class="line-modified">14138             GST_INFO_OBJECT (qtdemux, &quot;New location: %s&quot;, ref.location);</span>
14139             redirects =
14140                 g_list_prepend (redirects, g_memdup (&amp;ref, sizeof (ref)));
<span class="line-modified">14141           } else {</span>
<span class="line-modified">14142             GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-modified">14143                 &quot;Failed to extract redirect location from rdrf atom&quot;);</span>
<span class="line-modified">14144           }</span>
14145         } else {
14146           GST_WARNING_OBJECT (qtdemux, &quot;Invalid rdrf size (%u &lt; 20)&quot;, ref_len);
<span class="line-modified">14147         }</span>
14148       }
14149 
14150       /* look for others */
14151       rmda = qtdemux_tree_get_sibling_by_type (rmda, FOURCC_rmda);
14152     }
14153 
14154     if (redirects != NULL) {
14155       qtdemux_process_redirects (qtdemux, redirects);
14156     }
14157   }
14158   return TRUE;
14159 }
14160 
14161 static GstTagList *
14162 qtdemux_add_container_format (GstQTDemux * qtdemux, GstTagList * tags)
14163 {
14164   const gchar *fmt;
14165 
14166   if (tags == NULL) {
14167     tags = gst_tag_list_new_empty ();
</pre>
<hr />
<pre>
14182   GST_LOG_OBJECT (qtdemux, &quot;mapped %&quot; GST_FOURCC_FORMAT &quot; to &#39;%s&#39;&quot;,
14183       GST_FOURCC_ARGS (qtdemux-&gt;major_brand), fmt);
14184 
14185   gst_tag_list_add (tags, GST_TAG_MERGE_REPLACE, GST_TAG_CONTAINER_FORMAT,
14186       fmt, NULL);
14187 
14188   return tags;
14189 }
14190 
14191 /* we have read the complete moov node now.
14192  * This function parses all of the relevant info, creates the traks and
14193  * prepares all data structures for playback
14194  */
14195 static gboolean
14196 qtdemux_parse_tree (GstQTDemux * qtdemux)
14197 {
14198   GNode *mvhd;
14199   GNode *trak;
14200   GNode *udta;
14201   GNode *mvex;

14202   GNode *pssh;
14203   guint64 creation_time;
14204   GstDateTime *datetime = NULL;
14205   gint version;
14206 
14207   /* make sure we have a usable taglist */
<span class="line-modified">14208   qtdemux-&gt;tag_list = gst_tag_list_make_writable (qtdemux-&gt;tag_list);</span>
14209 
14210   mvhd = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_mvhd);
14211   if (mvhd == NULL) {
14212     GST_LOG_OBJECT (qtdemux, &quot;No mvhd node found, looking for redirects.&quot;);
14213     return qtdemux_parse_redirects (qtdemux);
14214   }
14215 
14216   version = QT_UINT8 ((guint8 *) mvhd-&gt;data + 8);
14217   if (version == 1) {
14218     creation_time = QT_UINT64 ((guint8 *) mvhd-&gt;data + 12);
14219     qtdemux-&gt;timescale = QT_UINT32 ((guint8 *) mvhd-&gt;data + 28);
14220     qtdemux-&gt;duration = QT_UINT64 ((guint8 *) mvhd-&gt;data + 32);
14221   } else if (version == 0) {
14222     creation_time = QT_UINT32 ((guint8 *) mvhd-&gt;data + 12);
14223     qtdemux-&gt;timescale = QT_UINT32 ((guint8 *) mvhd-&gt;data + 20);
14224     qtdemux-&gt;duration = QT_UINT32 ((guint8 *) mvhd-&gt;data + 24);
14225   } else {
14226     GST_WARNING_OBJECT (qtdemux, &quot;Unhandled mvhd version %d&quot;, version);
14227     return FALSE;
14228   }
14229 
14230   /* Moving qt creation time (secs since 1904) to unix time */
14231   if (creation_time != 0) {
14232     /* Try to use epoch first as it should be faster and more commonly found */
14233     if (creation_time &gt;= QTDEMUX_SECONDS_FROM_1904_TO_1970) {
14234       GTimeVal now;
14235 
14236       creation_time -= QTDEMUX_SECONDS_FROM_1904_TO_1970;
14237       /* some data cleansing sanity */
14238       g_get_current_time (&amp;now);
14239       if (now.tv_sec + 24 * 3600 &lt; creation_time) {
14240         GST_DEBUG_OBJECT (qtdemux, &quot;discarding bogus future creation time&quot;);
<span class="line-modified">14241       } else {</span>
14242         datetime = gst_date_time_new_from_unix_epoch_utc (creation_time);
<span class="line-modified">14243       }</span>
14244     } else {
14245       GDateTime *base_dt = g_date_time_new_utc (1904, 1, 1, 0, 0, 0);
14246       GDateTime *dt, *dt_local;
14247 
14248       dt = g_date_time_add_seconds (base_dt, creation_time);
14249       dt_local = g_date_time_to_local (dt);
14250       datetime = gst_date_time_new_from_g_date_time (dt_local);
14251 
14252       g_date_time_unref (base_dt);
14253       g_date_time_unref (dt);
<span class="line-modified">14254     }</span>
14255   }
14256   if (datetime) {
14257     /* Use KEEP as explicit tags should have a higher priority than mvhd tag */
14258     gst_tag_list_add (qtdemux-&gt;tag_list, GST_TAG_MERGE_KEEP, GST_TAG_DATE_TIME,
14259         datetime, NULL);
14260     gst_date_time_unref (datetime);
14261   }
14262 
14263   GST_INFO_OBJECT (qtdemux, &quot;timescale: %u&quot;, qtdemux-&gt;timescale);
14264   GST_INFO_OBJECT (qtdemux, &quot;duration: %&quot; G_GUINT64_FORMAT, qtdemux-&gt;duration);
14265 
14266   /* check for fragmented file and get some (default) data */
14267   mvex = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_mvex);
14268   if (mvex) {
14269     GNode *mehd;
14270     GstByteReader mehd_data;
14271 
14272     /* let track parsing or anyone know weird stuff might happen ... */
14273     qtdemux-&gt;fragmented = TRUE;
14274 
14275     /* compensate for total duration */
14276     mehd = qtdemux_tree_get_child_by_type_full (mvex, FOURCC_mehd, &amp;mehd_data);
14277     if (mehd)
14278       qtdemux_parse_mehd (qtdemux, &amp;mehd_data);
14279   }
14280 
<span class="line-modified">14281   /* Update the movie segment duration, unless it was directly given to us</span>
<span class="line-modified">14282    * by upstream. Otherwise let it as is, as we don&#39;t want to mangle the</span>
<span class="line-modified">14283    * duration provided by upstream that may come e.g. from a MPD file. */</span>
<span class="line-added">14284   if (!qtdemux-&gt;upstream_format_is_time) {</span>
<span class="line-added">14285     GstClockTime duration;</span>
<span class="line-added">14286     /* set duration in the segment info */</span>
<span class="line-added">14287     gst_qtdemux_get_duration (qtdemux, &amp;duration);</span>
14288     qtdemux-&gt;segment.duration = duration;
14289     /* also do not exceed duration; stop is set that way post seek anyway,
14290      * and segment activation falls back to duration,
14291      * whereas loop only checks stop, so let&#39;s align this here as well */
14292     qtdemux-&gt;segment.stop = duration;
14293   }
14294 
14295   /* parse all traks */
14296   trak = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_trak);
14297   while (trak) {
14298 #ifdef GSTREAMER_LITE
14299       if (!qtdemux_parse_trak (qtdemux, trak))
14300         return FALSE;
14301 #else
14302     qtdemux_parse_trak (qtdemux, trak);
14303 #endif // GSTREAMER_LITE
14304     /* iterate all siblings */
14305     trak = qtdemux_tree_get_sibling_by_type (trak, FOURCC_trak);
14306   }
14307 
</pre>
<hr />
<pre>
14342 read_descr_size (guint8 * ptr, guint8 * end, guint8 ** end_out)
14343 {
14344   int count = 4;
14345   int len = 0;
14346 
14347   while (count--) {
14348     int c;
14349 
14350     if (ptr &gt;= end)
14351       return -1;
14352 
14353     c = *ptr++;
14354     len = (len &lt;&lt; 7) | (c &amp; 0x7f);
14355     if (!(c &amp; 0x80))
14356       break;
14357   }
14358   *end_out = ptr;
14359   return len;
14360 }
14361 
<span class="line-added">14362 static GList *</span>
<span class="line-added">14363 parse_xiph_stream_headers (GstQTDemux * qtdemux, gpointer codec_data,</span>
<span class="line-added">14364     gsize codec_data_size)</span>
<span class="line-added">14365 {</span>
<span class="line-added">14366   GList *list = NULL;</span>
<span class="line-added">14367   guint8 *p = codec_data;</span>
<span class="line-added">14368   gint i, offset, num_packets;</span>
<span class="line-added">14369   guint *length, last;</span>
<span class="line-added">14370 </span>
<span class="line-added">14371   GST_MEMDUMP_OBJECT (qtdemux, &quot;xiph codec data&quot;, codec_data, codec_data_size);</span>
<span class="line-added">14372 </span>
<span class="line-added">14373   if (codec_data == NULL || codec_data_size == 0)</span>
<span class="line-added">14374     goto error;</span>
<span class="line-added">14375 </span>
<span class="line-added">14376   /* start of the stream and vorbis audio or theora video, need to</span>
<span class="line-added">14377    * send the codec_priv data as first three packets */</span>
<span class="line-added">14378   num_packets = p[0] + 1;</span>
<span class="line-added">14379   GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added">14380       &quot;%u stream headers, total length=%&quot; G_GSIZE_FORMAT &quot; bytes&quot;,</span>
<span class="line-added">14381       (guint) num_packets, codec_data_size);</span>
<span class="line-added">14382 </span>
<span class="line-added">14383   /* Let&#39;s put some limits, Don&#39;t think there even is a xiph codec</span>
<span class="line-added">14384    * with more than 3-4 headers */</span>
<span class="line-added">14385   if (G_UNLIKELY (num_packets &gt; 16)) {</span>
<span class="line-added">14386     GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-added">14387         &quot;Unlikely number of xiph headers, most likely not valid&quot;);</span>
<span class="line-added">14388     goto error;</span>
<span class="line-added">14389   }</span>
<span class="line-added">14390 </span>
<span class="line-added">14391   length = g_alloca (num_packets * sizeof (guint));</span>
<span class="line-added">14392   last = 0;</span>
<span class="line-added">14393   offset = 1;</span>
<span class="line-added">14394 </span>
<span class="line-added">14395   /* first packets, read length values */</span>
<span class="line-added">14396   for (i = 0; i &lt; num_packets - 1; i++) {</span>
<span class="line-added">14397     length[i] = 0;</span>
<span class="line-added">14398     while (offset &lt; codec_data_size) {</span>
<span class="line-added">14399       length[i] += p[offset];</span>
<span class="line-added">14400       if (p[offset++] != 0xff)</span>
<span class="line-added">14401         break;</span>
<span class="line-added">14402     }</span>
<span class="line-added">14403     last += length[i];</span>
<span class="line-added">14404   }</span>
<span class="line-added">14405   if (offset + last &gt; codec_data_size)</span>
<span class="line-added">14406     goto error;</span>
<span class="line-added">14407 </span>
<span class="line-added">14408   /* last packet is the remaining size */</span>
<span class="line-added">14409   length[i] = codec_data_size - offset - last;</span>
<span class="line-added">14410 </span>
<span class="line-added">14411   for (i = 0; i &lt; num_packets; i++) {</span>
<span class="line-added">14412     GstBuffer *hdr;</span>
<span class="line-added">14413 </span>
<span class="line-added">14414     GST_DEBUG_OBJECT (qtdemux, &quot;buffer %d: %u bytes&quot;, i, (guint) length[i]);</span>
<span class="line-added">14415 </span>
<span class="line-added">14416     if (offset + length[i] &gt; codec_data_size)</span>
<span class="line-added">14417       goto error;</span>
<span class="line-added">14418 </span>
<span class="line-added">14419     hdr = gst_buffer_new_wrapped (g_memdup (p + offset, length[i]), length[i]);</span>
<span class="line-added">14420     list = g_list_append (list, hdr);</span>
<span class="line-added">14421 </span>
<span class="line-added">14422     offset += length[i];</span>
<span class="line-added">14423   }</span>
<span class="line-added">14424 </span>
<span class="line-added">14425   return list;</span>
<span class="line-added">14426 </span>
<span class="line-added">14427   /* ERRORS */</span>
<span class="line-added">14428 error:</span>
<span class="line-added">14429   {</span>
<span class="line-added">14430     if (list != NULL)</span>
<span class="line-added">14431       g_list_free_full (list, (GDestroyNotify) gst_buffer_unref);</span>
<span class="line-added">14432     return NULL;</span>
<span class="line-added">14433   }</span>
<span class="line-added">14434 </span>
<span class="line-added">14435 }</span>
<span class="line-added">14436 </span>
14437 /* this can change the codec originally present in @list */
14438 #ifdef GSTREAMER_LITE
14439 static gboolean
14440 #else
14441 static void
14442 #endif // GSTREAMER_LITE
14443 gst_qtdemux_handle_esds (GstQTDemux * qtdemux, QtDemuxStream * stream,
14444     QtDemuxStreamStsdEntry * entry, GNode * esds, GstTagList * list)
14445 {
14446   int len = QT_UINT32 (esds-&gt;data);
14447   guint8 *ptr = esds-&gt;data;
14448   guint8 *end = ptr + len;
14449   int tag;
14450   guint8 *data_ptr = NULL;
14451   int data_len = 0;
14452   guint8 object_type_id = 0;
<span class="line-added">14453   guint8 stream_type = 0;</span>
14454   const char *codec_name = NULL;
14455   GstCaps *caps = NULL;
14456 
14457   GST_MEMDUMP_OBJECT (qtdemux, &quot;esds&quot;, ptr, len);
14458   ptr += 8;
14459   GST_DEBUG_OBJECT (qtdemux, &quot;version/flags = %08x&quot;, QT_UINT32 (ptr));
14460   ptr += 4;
14461   while (ptr + 1 &lt; end) {
14462     tag = QT_UINT8 (ptr);
14463     GST_DEBUG_OBJECT (qtdemux, &quot;tag = %02x&quot;, tag);
14464     ptr++;
14465     len = read_descr_size (ptr, end, &amp;ptr);
14466     GST_DEBUG_OBJECT (qtdemux, &quot;len = %d&quot;, len);
14467 
14468     /* Check the stated amount of data is available for reading */
14469     if (len &lt; 0 || ptr + len &gt; end)
14470       break;
14471 
14472     switch (tag) {
14473       case ES_DESCRIPTOR_TAG:
<span class="line-modified">14474         GST_DEBUG_OBJECT (qtdemux, &quot;ID 0x%04x&quot;, QT_UINT16 (ptr));</span>
<span class="line-modified">14475         GST_DEBUG_OBJECT (qtdemux, &quot;priority 0x%04x&quot;, QT_UINT8 (ptr + 2));</span>
14476         ptr += 3;
14477         break;
14478       case DECODER_CONFIG_DESC_TAG:{
14479         guint max_bitrate, avg_bitrate;
14480 
14481         object_type_id = QT_UINT8 (ptr);
<span class="line-added">14482         stream_type = QT_UINT8 (ptr + 1) &gt;&gt; 2;</span>
14483         max_bitrate = QT_UINT32 (ptr + 5);
14484         avg_bitrate = QT_UINT32 (ptr + 9);
14485         GST_DEBUG_OBJECT (qtdemux, &quot;object_type_id %02x&quot;, object_type_id);
<span class="line-modified">14486         GST_DEBUG_OBJECT (qtdemux, &quot;stream_type %02x&quot;, stream_type);</span>
14487         GST_DEBUG_OBJECT (qtdemux, &quot;buffer_size_db %02x&quot;, QT_UINT24 (ptr + 2));
14488         GST_DEBUG_OBJECT (qtdemux, &quot;max bitrate %u&quot;, max_bitrate);
14489         GST_DEBUG_OBJECT (qtdemux, &quot;avg bitrate %u&quot;, avg_bitrate);
14490         if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; G_MAXUINT32) {
14491           gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
14492               GST_TAG_MAXIMUM_BITRATE, max_bitrate, NULL);
14493         }
14494         if (avg_bitrate &gt; 0 &amp;&amp; avg_bitrate &lt; G_MAXUINT32) {
14495           gst_tag_list_add (list, GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE,
14496               avg_bitrate, NULL);
14497         }
14498         ptr += 13;
14499         break;
14500       }
14501       case DECODER_SPECIFIC_INFO_TAG:
14502         GST_MEMDUMP_OBJECT (qtdemux, &quot;data&quot;, ptr, len);
14503 #ifdef GSTREAMER_LITE
14504         if (end - len &lt; ptr)
14505             return FALSE;
14506 #endif // GSTREAMER_LITE
</pre>
<hr />
<pre>
14616         rate_idx =
14617             gst_codec_utils_aac_get_index_from_sample_rate (CUR_STREAM
14618             (stream)-&gt;rate);
14619 
14620         switch (object_type_id) {
14621           case 0x66:
14622             profile_str = &quot;main&quot;;
14623             profile = 0;
14624             break;
14625           case 0x67:
14626             profile_str = &quot;lc&quot;;
14627             profile = 1;
14628             break;
14629           case 0x68:
14630             profile_str = &quot;ssr&quot;;
14631             profile = 2;
14632             break;
14633           default:
14634             profile = 3;
14635             break;
<span class="line-modified">14636         }</span>
14637 
14638         codec_data[0] = ((profile + 1) &lt;&lt; 3) | ((rate_idx &amp; 0xE) &gt;&gt; 1);
14639         codec_data[1] =
14640             ((rate_idx &amp; 0x1) &lt;&lt; 7) | (CUR_STREAM (stream)-&gt;n_channels &lt;&lt; 3);
14641 
14642         gst_buffer_unmap (buffer, &amp;map);
14643         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;codec_data&quot;,
14644             GST_TYPE_BUFFER, buffer, NULL);
14645         gst_buffer_unref (buffer);
14646 
14647         if (profile_str) {
14648           gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;profile&quot;,
14649               G_TYPE_STRING, profile_str, NULL);
14650         }
14651       }
14652       break;
14653     case 0x60:                 /* MPEG-2, various profiles */
14654     case 0x61:
14655     case 0x62:
14656     case 0x63:
</pre>
<hr />
<pre>
14686       codec_name = &quot;PNG still images&quot;;
14687       break;
14688     case 0x6E:                 /* JPEG2000 */
14689       codec_name = &quot;JPEG-2000&quot;;
14690       caps = gst_caps_new_simple (&quot;image/x-j2c&quot;, &quot;fields&quot;, G_TYPE_INT, 1, NULL);
14691       break;
14692     case 0xA4:                 /* Dirac */
14693       codec_name = &quot;Dirac&quot;;
14694       caps = gst_caps_new_empty_simple (&quot;video/x-dirac&quot;);
14695       break;
14696     case 0xA5:                 /* AC3 */
14697       codec_name = &quot;AC-3 audio&quot;;
14698       caps = gst_caps_new_simple (&quot;audio/x-ac3&quot;,
14699           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
14700       break;
14701     case 0xA9:                 /* AC3 */
14702       codec_name = &quot;DTS audio&quot;;
14703       caps = gst_caps_new_simple (&quot;audio/x-dts&quot;,
14704           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
14705       break;
<span class="line-added">14706     case 0xDD:</span>
<span class="line-added">14707       if (stream_type == 0x05 &amp;&amp; data_ptr) {</span>
<span class="line-added">14708         GList *headers =</span>
<span class="line-added">14709             parse_xiph_stream_headers (qtdemux, data_ptr, data_len);</span>
<span class="line-added">14710         if (headers) {</span>
<span class="line-added">14711           GList *tmp;</span>
<span class="line-added">14712           GValue arr_val = G_VALUE_INIT;</span>
<span class="line-added">14713           GValue buf_val = G_VALUE_INIT;</span>
<span class="line-added">14714           GstStructure *s;</span>
<span class="line-added">14715 </span>
<span class="line-added">14716           /* Let&#39;s assume it&#39;s vorbis if it&#39;s an audio stream of type 0xdd and we have codec data that extracts properly */</span>
<span class="line-added">14717           codec_name = &quot;Vorbis&quot;;</span>
<span class="line-added">14718           caps = gst_caps_new_empty_simple (&quot;audio/x-vorbis&quot;);</span>
<span class="line-added">14719           g_value_init (&amp;arr_val, GST_TYPE_ARRAY);</span>
<span class="line-added">14720           g_value_init (&amp;buf_val, GST_TYPE_BUFFER);</span>
<span class="line-added">14721           for (tmp = headers; tmp; tmp = tmp-&gt;next) {</span>
<span class="line-added">14722             g_value_set_boxed (&amp;buf_val, (GstBuffer *) tmp-&gt;data);</span>
<span class="line-added">14723             gst_value_array_append_value (&amp;arr_val, &amp;buf_val);</span>
<span class="line-added">14724           }</span>
<span class="line-added">14725           s = gst_caps_get_structure (caps, 0);</span>
<span class="line-added">14726           gst_structure_take_value (s, &quot;streamheader&quot;, &amp;arr_val);</span>
<span class="line-added">14727           g_value_unset (&amp;buf_val);</span>
<span class="line-added">14728           g_list_free (headers);</span>
<span class="line-added">14729 </span>
<span class="line-added">14730           data_ptr = NULL;</span>
<span class="line-added">14731           data_len = 0;</span>
<span class="line-added">14732         }</span>
<span class="line-added">14733       }</span>
<span class="line-added">14734       break;</span>
14735     case 0xE1:                 /* QCELP */
14736       /* QCELP, the codec_data is a riff tag (little endian) with
14737        * more info (http://ftp.3gpp2.org/TSGC/Working/2003/2003-05-SanDiego/TSG-C-2003-05-San%20Diego/WG1/SWG12/C12-20030512-006%20=%20C12-20030217-015_Draft_Baseline%20Text%20of%20FFMS_R2.doc). */
14738       caps = gst_caps_new_empty_simple (&quot;audio/qcelp&quot;);
14739       codec_name = &quot;QCELP&quot;;
14740       break;
14741     default:
14742       break;
14743   }
14744 
14745   /* If we have a replacement caps, then change our caps for this stream */
14746   if (caps) {
14747     gst_caps_unref (entry-&gt;caps);
14748     entry-&gt;caps = caps;
14749   }
14750 
14751   if (codec_name &amp;&amp; list)
14752     gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
14753         GST_TAG_AUDIO_CODEC, codec_name, NULL);
14754 
</pre>
<hr />
<pre>
14774           case 0x68:                 /* AAC SSR */
14775           {
14776               GstMapInfo info;
14777               int esds_len = QT_UINT32 (esds-&gt;data);
14778               GstBuffer* esds_buffer = gst_buffer_new_allocate (NULL, esds_len, NULL);
14779               if (esds_buffer)
14780               {
14781                   if (gst_buffer_map(esds_buffer, &amp;info, GST_MAP_WRITE))
14782                   {
14783                       memcpy (info.data, esds-&gt;data, esds_len);
14784                       gst_buffer_unmap(esds_buffer, &amp;info);
14785 
14786                       GST_DEBUG_OBJECT (qtdemux, &quot;setting esds_data from esds&quot;);
14787                       GST_MEMDUMP_OBJECT (qtdemux, &quot;esds_data from esds&quot;, esds-&gt;data, esds_len);
14788 
14789                       gst_caps_set_simple (entry-&gt;caps, &quot;esds_data&quot;, GST_TYPE_BUFFER,
14790                                    esds_buffer, NULL);
14791                   }
14792 
14793                   gst_buffer_unref (esds_buffer);
<span class="line-modified">14794                }</span>
14795           }
14796               break;
14797           default:
14798               break;
14799       }
<span class="line-modified">14800 #endif // GSTREAMER_LITE</span>
14801 
14802   }
14803 
14804 #ifdef GSTREAMER_LITE
14805     return TRUE;
14806 #endif
14807 }
14808 
14809 static inline GstCaps *
14810 _get_unknown_codec_name (const gchar * type, guint32 fourcc)
14811 {
14812   GstCaps *caps;
14813   guint i;
14814   char *s, fourstr[5];
14815 
14816   g_snprintf (fourstr, 5, &quot;%&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));
14817   for (i = 0; i &lt; 4; i++) {
14818     if (!g_ascii_isalnum (fourstr[i]))
14819       fourstr[i] = &#39;_&#39;;
14820   }
</pre>
<hr />
<pre>
15218       caps =
15219           gst_caps_new_simple (&quot;video/x-prores&quot;, &quot;variant&quot;, G_TYPE_STRING,
15220           &quot;4444&quot;, NULL);
15221       break;
15222     case FOURCC_ap4x:
15223       _codec (&quot;Apple ProRes 4444 XQ&quot;);
15224       caps =
15225           gst_caps_new_simple (&quot;video/x-prores&quot;, &quot;variant&quot;, G_TYPE_STRING,
15226           &quot;4444xq&quot;, NULL);
15227       break;
15228     case FOURCC_cfhd:
15229       _codec (&quot;GoPro CineForm&quot;);
15230       caps = gst_caps_from_string (&quot;video/x-cineform&quot;);
15231       break;
15232     case FOURCC_vc_1:
15233     case FOURCC_ovc1:
15234       _codec (&quot;VC-1&quot;);
15235       caps = gst_caps_new_simple (&quot;video/x-wmv&quot;,
15236           &quot;wmvversion&quot;, G_TYPE_INT, 3, &quot;format&quot;, G_TYPE_STRING, &quot;WVC1&quot;, NULL);
15237       break;
<span class="line-added">15238     case FOURCC_av01:</span>
<span class="line-added">15239       _codec (&quot;AV1&quot;);</span>
<span class="line-added">15240       caps = gst_caps_new_empty_simple (&quot;video/x-av1&quot;);</span>
<span class="line-added">15241       break;</span>
15242     case GST_MAKE_FOURCC (&#39;k&#39;, &#39;p&#39;, &#39;c&#39;, &#39;d&#39;):
15243     default:
15244     {
15245       caps = _get_unknown_codec_name (&quot;video&quot;, fourcc);
15246       break;
15247     }
15248   }
15249 
15250   if (format != GST_VIDEO_FORMAT_UNKNOWN) {
15251     GstVideoInfo info;
15252 
15253     gst_video_info_init (&amp;info);
15254     gst_video_info_set_format (&amp;info, format, entry-&gt;width, entry-&gt;height);
15255 
15256     caps = gst_video_info_to_caps (&amp;info);
15257     *codec_name = gst_pb_utils_get_codec_description (caps);
15258 
<span class="line-modified">15259     /* enable clipping for raw video streams */</span>
15260     stream-&gt;need_clip = TRUE;
15261     stream-&gt;alignment = 32;
15262   }
15263 
15264   return caps;
15265 }
15266 
15267 static guint
15268 round_up_pow2 (guint n)
15269 {
15270   n = n - 1;
15271   n = n | (n &gt;&gt; 1);
15272   n = n | (n &gt;&gt; 2);
15273   n = n | (n &gt;&gt; 4);
15274   n = n | (n &gt;&gt; 8);
15275   n = n | (n &gt;&gt; 16);
15276   return n + 1;
15277 }
15278 
15279 static GstCaps *
</pre>
<hr />
<pre>
15293   depth = entry-&gt;bytes_per_packet * 8;
15294 
15295   switch (fourcc) {
15296     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;O&#39;, &#39;N&#39;, &#39;E&#39;):
15297     case FOURCC_raw_:
15298       /* 8-bit audio is unsigned */
15299       if (depth == 8)
15300         format = GST_AUDIO_FORMAT_U8;
15301       /* otherwise it&#39;s signed and big-endian just like &#39;twos&#39; */
15302     case FOURCC_twos:
15303       endian = G_BIG_ENDIAN;
15304       /* fall-through */
15305     case FOURCC_sowt:
15306     {
15307       gchar *str;
15308 
15309       if (!endian)
15310         endian = G_LITTLE_ENDIAN;
15311 
15312       if (!format)
<span class="line-modified">15313         format = gst_audio_format_build_integer (TRUE, endian, depth, depth);</span>
15314 
15315       str = g_strdup_printf (&quot;Raw %d-bit PCM audio&quot;, depth);
15316       _codec (str);
15317       g_free (str);
15318 
15319       caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
15320           &quot;format&quot;, G_TYPE_STRING, gst_audio_format_to_string (format),
15321           &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;, NULL);
15322       stream-&gt;alignment = GST_ROUND_UP_8 (depth);
15323       stream-&gt;alignment = round_up_pow2 (stream-&gt;alignment);
15324       break;
15325     }
15326     case GST_MAKE_FOURCC (&#39;f&#39;, &#39;l&#39;, &#39;6&#39;, &#39;4&#39;):
15327       _codec (&quot;Raw 64-bit floating-point audio&quot;);
15328       caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
15329           &quot;format&quot;, G_TYPE_STRING, &quot;F64BE&quot;,
15330           &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;, NULL);
15331       stream-&gt;alignment = 8;
15332       break;
15333     case GST_MAKE_FOURCC (&#39;f&#39;, &#39;l&#39;, &#39;3&#39;, &#39;2&#39;):
</pre>
<hr />
<pre>
15616     case FOURCC_mp4s:
15617       _codec (&quot;DVD subtitle&quot;);
15618       caps = gst_caps_new_empty_simple (&quot;subpicture/x-dvd&quot;);
15619       stream-&gt;need_process = TRUE;
15620       break;
15621     case FOURCC_text:
15622       _codec (&quot;Quicktime timed text&quot;);
15623       goto text;
15624     case FOURCC_tx3g:
15625       _codec (&quot;3GPP timed text&quot;);
15626     text:
15627       caps = gst_caps_new_simple (&quot;text/x-raw&quot;, &quot;format&quot;, G_TYPE_STRING,
15628           &quot;utf8&quot;, NULL);
15629       /* actual text piece needs to be extracted */
15630       stream-&gt;need_process = TRUE;
15631       break;
15632     case FOURCC_stpp:
15633       _codec (&quot;XML subtitles&quot;);
15634       caps = gst_caps_new_empty_simple (&quot;application/ttml+xml&quot;);
15635       break;
<span class="line-added">15636     case FOURCC_c608:</span>
<span class="line-added">15637       _codec (&quot;CEA 608 Closed Caption&quot;);</span>
<span class="line-added">15638       caps =</span>
<span class="line-added">15639           gst_caps_new_simple (&quot;closedcaption/x-cea-608&quot;, &quot;format&quot;,</span>
<span class="line-added">15640           G_TYPE_STRING, &quot;s334-1a&quot;, NULL);</span>
<span class="line-added">15641       stream-&gt;need_process = TRUE;</span>
<span class="line-added">15642       stream-&gt;need_split = TRUE;</span>
<span class="line-added">15643       break;</span>
<span class="line-added">15644     case FOURCC_c708:</span>
<span class="line-added">15645       _codec (&quot;CEA 708 Closed Caption&quot;);</span>
<span class="line-added">15646       caps =</span>
<span class="line-added">15647           gst_caps_new_simple (&quot;closedcaption/x-cea-708&quot;, &quot;format&quot;,</span>
<span class="line-added">15648           G_TYPE_STRING, &quot;cdp&quot;, NULL);</span>
<span class="line-added">15649       stream-&gt;need_process = TRUE;</span>
<span class="line-added">15650       break;</span>
<span class="line-added">15651 </span>
15652     default:
15653     {
15654       caps = _get_unknown_codec_name (&quot;text&quot;, fourcc);
15655       break;
15656     }
15657   }
15658   return caps;
15659 }
15660 
15661 static GstCaps *
15662 qtdemux_generic_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
15663     QtDemuxStreamStsdEntry * entry, guint32 fourcc,
15664     const guint8 * stsd_entry_data, gchar ** codec_name)
15665 {
15666   GstCaps *caps;
15667 
15668   switch (fourcc) {
15669     case FOURCC_m1v:
15670       _codec (&quot;MPEG 1 video&quot;);
15671       caps = gst_caps_new_simple (&quot;video/mpeg&quot;, &quot;mpegversion&quot;, G_TYPE_INT, 1,
</pre>
</td>
</tr>
</table>
<center><a href="properties.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="qtdemux.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>