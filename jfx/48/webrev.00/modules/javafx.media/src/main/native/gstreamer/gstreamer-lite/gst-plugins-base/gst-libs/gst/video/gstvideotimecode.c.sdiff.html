<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/gstvideotimecode.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstvideosink.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstvideotimecode.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/gstvideotimecode.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /* GStreamer
   2  * Copyright (C) &lt;2016&gt; Vivia Nikolaidou &lt;vivia@toolsonair.com&gt;
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Library General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public
  15  * License along with this library; if not, write to the
  16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */



  19 
  20 #include &lt;stdio.h&gt;
  21 #include &quot;gstvideotimecode.h&quot;
  22 
  23 static void
  24 gst_video_time_code_gvalue_to_string (const GValue * tc_val, GValue * str_val);
  25 static void
  26 gst_video_time_code_gvalue_from_string (const GValue * str_val,
  27     GValue * tc_val);
  28 static gboolean gst_video_time_code_deserialize (GValue * dest,
  29     const gchar * tc_str);
  30 static gchar *gst_video_time_code_serialize (const GValue * val);
  31 
  32 static void
  33 _init (GType type)
  34 {
  35   static GstValueTable table =
  36       { 0, (GstValueCompareFunc) gst_video_time_code_compare,
  37     (GstValueSerializeFunc) gst_video_time_code_serialize,
  38     (GstValueDeserializeFunc) gst_video_time_code_deserialize
</pre>
<hr />
<pre>
  49 G_DEFINE_BOXED_TYPE_WITH_CODE (GstVideoTimeCode, gst_video_time_code,
  50     (GBoxedCopyFunc) gst_video_time_code_copy,
  51     (GBoxedFreeFunc) gst_video_time_code_free, _init (g_define_type_id));
  52 
  53 /**
  54  * gst_video_time_code_is_valid:
  55  * @tc: #GstVideoTimeCode to check
  56  *
  57  * Returns: whether @tc is a valid timecode (supported frame rate,
  58  * hours/minutes/seconds/frames not overflowing)
  59  *
  60  * Since: 1.10
  61  */
  62 gboolean
  63 gst_video_time_code_is_valid (const GstVideoTimeCode * tc)
  64 {
  65   guint fr;
  66 
  67   g_return_val_if_fail (tc != NULL, FALSE);
  68 
<span class="line-modified">  69   fr = (tc-&gt;config.fps_n + (tc-&gt;config.fps_d &gt;&gt; 1)) / tc-&gt;config.fps_d;</span>

  70 
  71   if (tc-&gt;hours &gt;= 24)
  72     return FALSE;
  73   if (tc-&gt;minutes &gt;= 60)
  74     return FALSE;
  75   if (tc-&gt;seconds &gt;= 60)
  76     return FALSE;
<span class="line-modified">  77   if (tc-&gt;config.fps_d == 0)</span>
<span class="line-modified">  78     return FALSE;</span>

  79   if (tc-&gt;frames &gt;= fr &amp;&amp; (tc-&gt;config.fps_n != 0 || tc-&gt;config.fps_d != 1))
  80     return FALSE;



  81   if (tc-&gt;config.fps_d == 1001) {
  82     if (tc-&gt;config.fps_n != 30000 &amp;&amp; tc-&gt;config.fps_n != 60000 &amp;&amp;
  83         tc-&gt;config.fps_n != 24000)
  84       return FALSE;
  85   } else if (tc-&gt;config.fps_n % tc-&gt;config.fps_d != 0) {
  86     return FALSE;
  87   }












  88   if ((tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) &amp;&amp;
  89       tc-&gt;minutes % 10 &amp;&amp; tc-&gt;seconds == 0 &amp;&amp; tc-&gt;frames &lt; fr / 15) {
  90     return FALSE;
  91   }
  92 
  93   return TRUE;
  94 }
  95 
  96 /**
  97  * gst_video_time_code_to_string:
<span class="line-modified">  98  * @tc: #GstVideoTimeCode to convert</span>
  99  *
 100  * Returns: the SMPTE ST 2059-1:2015 string representation of @tc. That will
<span class="line-modified"> 101  * take the form hh:mm:ss:ff . The last separator (between seconds and frames)</span>
 102  * may vary:
 103  *
 104  * &#39;;&#39; for drop-frame, non-interlaced content and for drop-frame interlaced
 105  * field 2
 106  * &#39;,&#39; for drop-frame interlaced field 1
 107  * &#39;:&#39; for non-drop-frame, non-interlaced content and for non-drop-frame
 108  * interlaced field 2
 109  * &#39;.&#39; for non-drop-frame interlaced field 1
 110  *
 111  * Since: 1.10
 112  */
 113 gchar *
 114 gst_video_time_code_to_string (const GstVideoTimeCode * tc)
 115 {
 116   gchar *ret;
 117   gboolean top_dot_present;
 118   gchar sep;
 119 
 120   /* Top dot is present for non-interlaced content, and for field 2 in
 121    * interlaced content */
</pre>
<hr />
<pre>
 124       &amp;&amp; tc-&gt;field_count == 1);
 125 
 126   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME)
 127     sep = top_dot_present ? &#39;;&#39; : &#39;,&#39;;
 128   else
 129     sep = top_dot_present ? &#39;:&#39; : &#39;.&#39;;
 130 
 131   ret =
 132       g_strdup_printf (&quot;%02d:%02d:%02d%c%02d&quot;, tc-&gt;hours, tc-&gt;minutes,
 133       tc-&gt;seconds, sep, tc-&gt;frames);
 134 
 135   return ret;
 136 }
 137 
 138 /**
 139  * gst_video_time_code_to_date_time:
 140  * @tc: A valid #GstVideoTimeCode to convert
 141  *
 142  * The @tc.config-&gt;latest_daily_jam is required to be non-NULL.
 143  *
<span class="line-modified"> 144  * Returns: the #GDateTime representation of @tc.</span>

 145  *
 146  * Since: 1.10
 147  */
 148 GDateTime *
 149 gst_video_time_code_to_date_time (const GstVideoTimeCode * tc)
 150 {
 151   GDateTime *ret;
 152   GDateTime *ret2;
 153   gdouble add_us;
 154 
 155   g_return_val_if_fail (gst_video_time_code_is_valid (tc), NULL);
<span class="line-removed"> 156   g_return_val_if_fail (tc-&gt;config.latest_daily_jam != NULL, NULL);</span>
 157 
<span class="line-modified"> 158   ret = g_date_time_ref (tc-&gt;config.latest_daily_jam);</span>
<span class="line-removed"> 159 </span>
<span class="line-removed"> 160   if (ret == NULL) {</span>
 161     gchar *tc_str = gst_video_time_code_to_string (tc);
 162     GST_WARNING
 163         (&quot;Asked to convert time code %s to GDateTime, but its latest daily jam is NULL&quot;,
 164         tc_str);
 165     g_free (tc_str);
<span class="line-removed"> 166     g_date_time_unref (ret);</span>
 167     return NULL;
 168   }
 169 
<span class="line-modified"> 170   if (tc-&gt;config.fps_n == 0 &amp;&amp; tc-&gt;config.fps_d == 1) {</span>
<span class="line-removed"> 171     gchar *tc_str = gst_video_time_code_to_string (tc);</span>
<span class="line-removed"> 172     GST_WARNING</span>
<span class="line-removed"> 173         (&quot;Asked to convert time code %s to GDateTime, but its framerate is unknown&quot;,</span>
<span class="line-removed"> 174         tc_str);</span>
<span class="line-removed"> 175     g_free (tc_str);</span>
<span class="line-removed"> 176     g_date_time_unref (ret);</span>
<span class="line-removed"> 177     return NULL;</span>
<span class="line-removed"> 178   }</span>
 179 
 180   gst_util_fraction_to_double (tc-&gt;frames * tc-&gt;config.fps_d, tc-&gt;config.fps_n,
 181       &amp;add_us);
 182   if ((tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_INTERLACED)
 183       &amp;&amp; tc-&gt;field_count == 1) {
 184     gdouble sub_us;
 185 
 186     gst_util_fraction_to_double (tc-&gt;config.fps_d, 2 * tc-&gt;config.fps_n,
 187         &amp;sub_us);
 188     add_us -= sub_us;
 189   }
 190 
 191   ret2 = g_date_time_add_seconds (ret, add_us + tc-&gt;seconds);
 192   g_date_time_unref (ret);
 193   ret = g_date_time_add_minutes (ret2, tc-&gt;minutes);
 194   g_date_time_unref (ret2);
 195   ret2 = g_date_time_add_hours (ret, tc-&gt;hours);
 196   g_date_time_unref (ret);
 197 
 198   return ret2;
 199 }
 200 
 201 /**
 202  * gst_video_time_code_init_from_date_time:
<span class="line-modified"> 203  * @tc: a #GstVideoTimeCode</span>
 204  * @fps_n: Numerator of the frame rate
 205  * @fps_d: Denominator of the frame rate
 206  * @dt: #GDateTime to convert
 207  * @flags: #GstVideoTimeCodeFlags
 208  * @field_count: Interlaced video field count
 209  *
<span class="line-modified"> 210  * The resulting config-&gt;latest_daily_jam is set to</span>
<span class="line-modified"> 211  * midnight, and timecode is set to the given time.</span>



 212  *
 213  * Since: 1.12
 214  */
<span class="line-removed"> 215 </span>
 216 void
 217 gst_video_time_code_init_from_date_time (GstVideoTimeCode * tc,
 218     guint fps_n, guint fps_d,
 219     GDateTime * dt, GstVideoTimeCodeFlags flags, guint field_count)


























 220 {
 221   GDateTime *jam;
 222   guint64 frames;
 223   gboolean add_a_frame = FALSE;
 224 






 225   jam = g_date_time_new_local (g_date_time_get_year (dt),
 226       g_date_time_get_month (dt), g_date_time_get_day_of_month (dt), 0, 0, 0.0);
 227 
 228   /* Note: This might be inaccurate for 1 frame
 229    * in case we have a drop frame timecode */
 230   frames =
 231       gst_util_uint64_scale_round (g_date_time_get_microsecond (dt) *
 232       G_GINT64_CONSTANT (1000), fps_n, fps_d * GST_SECOND);
 233   if (G_UNLIKELY (((frames == fps_n) &amp;&amp; (fps_d == 1)) ||
 234           ((frames == fps_n / 1000) &amp;&amp; (fps_d == 1001)))) {
 235     /* Avoid invalid timecodes */
 236     frames--;
 237     add_a_frame = TRUE;
 238   }
 239 
 240   gst_video_time_code_init (tc, fps_n, fps_d, jam, flags,
 241       g_date_time_get_hour (dt), g_date_time_get_minute (dt),
 242       g_date_time_get_second (dt), frames, field_count);
 243 
 244   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) {
 245     guint df = (tc-&gt;config.fps_n + (tc-&gt;config.fps_d &gt;&gt; 1)) /
 246         (15 * tc-&gt;config.fps_d);
 247     if (tc-&gt;minutes % 10 &amp;&amp; tc-&gt;seconds == 0 &amp;&amp; tc-&gt;frames &lt; df) {
 248       tc-&gt;frames = df;
 249     }
 250   }
 251   if (add_a_frame)
 252     gst_video_time_code_increment_frame (tc);
 253 
 254   g_date_time_unref (jam);
 255 
<span class="line-modified"> 256   g_return_if_fail (gst_video_time_code_is_valid (tc));</span>
 257 }
 258 
 259 /**
 260  * gst_video_time_code_nsec_since_daily_jam:
 261  * @tc: a valid #GstVideoTimeCode
 262  *
<span class="line-modified"> 263  * Returns: how many nsec have passed since the daily jam of @tc .</span>
 264  *
 265  * Since: 1.10
 266  */
 267 guint64
 268 gst_video_time_code_nsec_since_daily_jam (const GstVideoTimeCode * tc)
 269 {
 270   guint64 frames, nsec;
 271 
 272   g_return_val_if_fail (gst_video_time_code_is_valid (tc), -1);
 273 
<span class="line-removed"> 274   if (tc-&gt;config.fps_n == 0 &amp;&amp; tc-&gt;config.fps_d == 1) {</span>
<span class="line-removed"> 275     gchar *tc_str = gst_video_time_code_to_string (tc);</span>
<span class="line-removed"> 276     GST_WARNING</span>
<span class="line-removed"> 277         (&quot;Asked to calculate nsec since daily jam of time code %s, but its framerate is unknown&quot;,</span>
<span class="line-removed"> 278         tc_str);</span>
<span class="line-removed"> 279     g_free (tc_str);</span>
<span class="line-removed"> 280     return -1;</span>
<span class="line-removed"> 281   }</span>
<span class="line-removed"> 282 </span>
 283   frames = gst_video_time_code_frames_since_daily_jam (tc);
 284   nsec =
 285       gst_util_uint64_scale (frames, GST_SECOND * tc-&gt;config.fps_d,
 286       tc-&gt;config.fps_n);
 287 
 288   return nsec;
 289 }
 290 
 291 /**
 292  * gst_video_time_code_frames_since_daily_jam:
 293  * @tc: a valid #GstVideoTimeCode
 294  *
<span class="line-modified"> 295  * Returns: how many frames have passed since the daily jam of @tc .</span>
 296  *
 297  * Since: 1.10
 298  */
 299 guint64
 300 gst_video_time_code_frames_since_daily_jam (const GstVideoTimeCode * tc)
 301 {
 302   guint ff_nom;
 303   gdouble ff;
 304 
 305   g_return_val_if_fail (gst_video_time_code_is_valid (tc), -1);
 306 
 307   gst_util_fraction_to_double (tc-&gt;config.fps_n, tc-&gt;config.fps_d, &amp;ff);
 308   if (tc-&gt;config.fps_d == 1001) {
 309     ff_nom = tc-&gt;config.fps_n / 1000;
 310   } else {
 311     ff_nom = ff;
 312   }
 313   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) {
 314     /* these need to be truncated to integer: side effect, code looks cleaner
 315      * */
 316     guint ff_minutes = 60 * ff;
 317     guint ff_hours = 3600 * ff;
 318     /* for 30000/1001 we drop the first 2 frames per minute, for 60000/1001 we
 319      * drop the first 4 : so we use this number */
 320     guint dropframe_multiplier;
 321 
 322     if (tc-&gt;config.fps_n == 30000) {
 323       dropframe_multiplier = 2;
 324     } else if (tc-&gt;config.fps_n == 60000) {
 325       dropframe_multiplier = 4;
 326     } else {
<span class="line-modified"> 327       GST_ERROR (&quot;Unsupported drop frame rate %u/%u&quot;, tc-&gt;config.fps_n,</span>
<span class="line-modified"> 328           tc-&gt;config.fps_d);</span>
<span class="line-removed"> 329       return -1;</span>
 330     }
 331 
 332     return tc-&gt;frames + (ff_nom * tc-&gt;seconds) +
 333         (ff_minutes * tc-&gt;minutes) +
 334         dropframe_multiplier * ((gint) (tc-&gt;minutes / 10)) +
 335         (ff_hours * tc-&gt;hours);
 336   } else {
 337     return tc-&gt;frames + (ff_nom * (tc-&gt;seconds + (60 * (tc-&gt;minutes +
 338                     (60 * tc-&gt;hours)))));
 339   }
 340 
 341 }
 342 
 343 /**
 344  * gst_video_time_code_increment_frame:
 345  * @tc: a valid #GstVideoTimeCode
 346  *
<span class="line-modified"> 347  * Adds one frame to @tc .</span>
 348  *
 349  * Since: 1.10
 350  */
 351 void
 352 gst_video_time_code_increment_frame (GstVideoTimeCode * tc)
 353 {
 354   gst_video_time_code_add_frames (tc, 1);
 355 }
 356 
 357 /**
 358  * gst_video_time_code_add_frames:
 359  * @tc: a valid #GstVideoTimeCode
 360  * @frames: How many frames to add or subtract
 361  *
 362  * Adds or subtracts @frames amount of frames to @tc. tc needs to
<span class="line-modified"> 363  * contain valid data, as verified by #gst_video_time_code_is_valid.</span>
 364  *
 365  * Since: 1.10
 366  */
 367 void
 368 gst_video_time_code_add_frames (GstVideoTimeCode * tc, gint64 frames)
 369 {
 370   guint64 framecount;
 371   guint64 h_notmod24;
 372   guint64 h_new, min_new, sec_new, frames_new;
 373   gdouble ff;
 374   guint ff_nom;
 375   /* This allows for better readability than putting G_GUINT64_CONSTANT(60)
 376    * into a long calculation line */
 377   const guint64 sixty = 60;
 378   /* formulas found in SMPTE ST 2059-1:2015 section 9.4.3
 379    * and adapted for 60/1.001 as well as 30/1.001 */
 380 
 381   g_return_if_fail (gst_video_time_code_is_valid (tc));
 382 
 383   gst_util_fraction_to_double (tc-&gt;config.fps_n, tc-&gt;config.fps_d, &amp;ff);
 384   if (tc-&gt;config.fps_d == 1001) {
 385     ff_nom = tc-&gt;config.fps_n / 1000;
 386   } else {
 387     ff_nom = ff;
<span class="line-removed"> 388     if (tc-&gt;config.fps_d != 1)</span>
<span class="line-removed"> 389       GST_WARNING (&quot;Unsupported frame rate %u/%u, results may be wrong&quot;,</span>
<span class="line-removed"> 390           tc-&gt;config.fps_n, tc-&gt;config.fps_d);</span>
 391   }

 392   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) {
 393     /* these need to be truncated to integer: side effect, code looks cleaner
 394      * */
 395     guint ff_minutes = 60 * ff;
 396     guint ff_hours = 3600 * ff;
 397     /* a bunch of intermediate variables, to avoid monster code with possible
 398      * integer overflows */
 399     guint64 min_new_tmp1, min_new_tmp2, min_new_tmp3, min_new_denom;
 400     /* for 30000/1001 we drop the first 2 frames per minute, for 60000/1001 we
 401      * drop the first 4 : so we use this number */
 402     guint dropframe_multiplier;
 403 
<span class="line-modified"> 404     if (tc-&gt;config.fps_n == 30000)</span>
 405       dropframe_multiplier = 2;
<span class="line-modified"> 406     else if (tc-&gt;config.fps_n == 60000)</span>
 407       dropframe_multiplier = 4;
<span class="line-modified"> 408     else {</span>
<span class="line-modified"> 409       GST_ERROR (&quot;Unsupported drop frame rate %u/%u&quot;, tc-&gt;config.fps_n,</span>
<span class="line-modified"> 410           tc-&gt;config.fps_d);</span>
<span class="line-removed"> 411       return;</span>
 412     }
 413 
 414     framecount =
 415         frames + tc-&gt;frames + (ff_nom * tc-&gt;seconds) +
 416         (ff_minutes * tc-&gt;minutes) +
 417         dropframe_multiplier * ((gint) (tc-&gt;minutes / 10)) +
 418         (ff_hours * tc-&gt;hours);
 419     h_notmod24 = gst_util_uint64_scale_int (framecount, 1, ff_hours);
 420 
 421     min_new_denom = sixty * ff_nom;
 422     min_new_tmp1 = (framecount - (h_notmod24 * ff_hours)) / min_new_denom;
 423     min_new_tmp2 = framecount + dropframe_multiplier * min_new_tmp1;
 424     min_new_tmp1 =
 425         (framecount - (h_notmod24 * ff_hours)) / (sixty * 10 * ff_nom);
 426     min_new_tmp3 =
 427         dropframe_multiplier * min_new_tmp1 + (h_notmod24 * ff_hours);
 428     min_new =
 429         gst_util_uint64_scale_int (min_new_tmp2 - min_new_tmp3, 1,
 430         min_new_denom);
 431 
</pre>
<hr />
<pre>
 439         (dropframe_multiplier * ((gint) (min_new / 10))) -
 440         (ff_hours * h_notmod24);
 441   } else {
 442     framecount =
 443         frames + tc-&gt;frames + (ff_nom * (tc-&gt;seconds + (sixty * (tc-&gt;minutes +
 444                     (sixty * tc-&gt;hours)))));
 445     h_notmod24 =
 446         gst_util_uint64_scale_int (framecount, 1, ff_nom * sixty * sixty);
 447     min_new =
 448         gst_util_uint64_scale_int ((framecount -
 449             (ff_nom * sixty * sixty * h_notmod24)), 1, (ff_nom * sixty));
 450     sec_new =
 451         gst_util_uint64_scale_int ((framecount - (ff_nom * sixty * (min_new +
 452                     (sixty * h_notmod24)))), 1, ff_nom);
 453     frames_new =
 454         framecount - (ff_nom * (sec_new + sixty * (min_new +
 455                 (sixty * h_notmod24))));
 456     if (frames_new &gt; ff_nom)
 457       frames_new = 0;
 458   }

 459   h_new = h_notmod24 % 24;
 460 

 461   g_assert (min_new &lt; 60);
 462   g_assert (sec_new &lt; 60);
 463   g_assert (frames_new &lt; ff_nom);

 464   tc-&gt;hours = h_new;
 465   tc-&gt;minutes = min_new;
 466   tc-&gt;seconds = sec_new;
 467   tc-&gt;frames = frames_new;
 468 }
 469 
 470 /**
 471  * gst_video_time_code_compare:
<span class="line-modified"> 472  * @tc1: a #GstVideoTimeCode</span>
<span class="line-modified"> 473  * @tc2: another #GstVideoTimeCode</span>
 474  *
<span class="line-modified"> 475  * Compares @tc1 and @tc2 . If both have latest daily jam information, it is</span>
 476  * taken into account. Otherwise, it is assumed that the daily jam of both
 477  * @tc1 and @tc2 was at the same time. Both time codes must be valid.
 478  *
 479  * Returns: 1 if @tc1 is after @tc2, -1 if @tc1 is before @tc2, 0 otherwise.
 480  *
 481  * Since: 1.10
 482  */
 483 gint
 484 gst_video_time_code_compare (const GstVideoTimeCode * tc1,
 485     const GstVideoTimeCode * tc2)
 486 {
 487   g_return_val_if_fail (gst_video_time_code_is_valid (tc1), -1);
 488   g_return_val_if_fail (gst_video_time_code_is_valid (tc2), -1);
 489 
 490   if (tc1-&gt;config.latest_daily_jam == NULL
 491       || tc2-&gt;config.latest_daily_jam == NULL) {
 492     guint64 nsec1, nsec2;
 493 #ifndef GST_DISABLE_GST_DEBUG
 494     gchar *str1, *str2;
 495 
</pre>
<hr />
<pre>
 552   }
 553 }
 554 
 555 /**
 556  * gst_video_time_code_new:
 557  * @fps_n: Numerator of the frame rate
 558  * @fps_d: Denominator of the frame rate
 559  * @latest_daily_jam: The latest daily jam of the #GstVideoTimeCode
 560  * @flags: #GstVideoTimeCodeFlags
 561  * @hours: the hours field of #GstVideoTimeCode
 562  * @minutes: the minutes field of #GstVideoTimeCode
 563  * @seconds: the seconds field of #GstVideoTimeCode
 564  * @frames: the frames field of #GstVideoTimeCode
 565  * @field_count: Interlaced video field count
 566  *
 567  * @field_count is 0 for progressive, 1 or 2 for interlaced.
 568  * @latest_daiy_jam reference is stolen from caller.
 569  *
 570  * Returns: a new #GstVideoTimeCode with the given values.
 571  * The values are not checked for being in a valid range. To see if your
<span class="line-modified"> 572  * timecode actually has valid content, use #gst_video_time_code_is_valid.</span>
 573  *
 574  * Since: 1.10
 575  */
 576 GstVideoTimeCode *
 577 gst_video_time_code_new (guint fps_n, guint fps_d, GDateTime * latest_daily_jam,
 578     GstVideoTimeCodeFlags flags, guint hours, guint minutes, guint seconds,
 579     guint frames, guint field_count)
 580 {
 581   GstVideoTimeCode *tc;
 582 
 583   tc = g_new0 (GstVideoTimeCode, 1);
 584   gst_video_time_code_init (tc, fps_n, fps_d, latest_daily_jam, flags, hours,
 585       minutes, seconds, frames, field_count);
 586   return tc;
 587 }
 588 
 589 /**
 590  * gst_video_time_code_new_empty:
 591  *
<span class="line-modified"> 592  * Returns: a new empty #GstVideoTimeCode</span>
 593  *
 594  * Since: 1.10
 595  */
 596 GstVideoTimeCode *
 597 gst_video_time_code_new_empty (void)
 598 {
 599   GstVideoTimeCode *tc;
 600 
 601   tc = g_new0 (GstVideoTimeCode, 1);
 602   gst_video_time_code_clear (tc);
 603   return tc;
 604 }
 605 
 606 static void
 607 gst_video_time_code_gvalue_from_string (const GValue * str_val, GValue * tc_val)
 608 {
 609   const gchar *tc_str = g_value_get_string (str_val);
 610   GstVideoTimeCode *tc;
 611 
 612   tc = gst_video_time_code_new_from_string (tc_str);
</pre>
<hr />
<pre>
 618 {
 619   const GstVideoTimeCode *tc = g_value_get_boxed (tc_val);
 620   gchar *tc_str;
 621 
 622   tc_str = gst_video_time_code_to_string (tc);
 623   g_value_take_string (str_val, tc_str);
 624 }
 625 
 626 static gchar *
 627 gst_video_time_code_serialize (const GValue * val)
 628 {
 629   GstVideoTimeCode *tc = g_value_get_boxed (val);
 630   return gst_video_time_code_to_string (tc);
 631 }
 632 
 633 static gboolean
 634 gst_video_time_code_deserialize (GValue * dest, const gchar * tc_str)
 635 {
 636   GstVideoTimeCode *tc = gst_video_time_code_new_from_string (tc_str);
 637 
<span class="line-modified"> 638   if (tc == NULL || !gst_video_time_code_is_valid (tc))</span>
 639     return FALSE;

 640 
 641   g_value_take_boxed (dest, tc);
 642   return TRUE;
 643 }
 644 
 645 /**
 646  * gst_video_time_code_new_from_string:
 647  * @tc_str: The string that represents the #GstVideoTimeCode
 648  *
<span class="line-modified"> 649  * Returns: a new #GstVideoTimeCode from the given string</span>

 650  *
 651  * Since: 1.12
 652  */
 653 GstVideoTimeCode *
 654 gst_video_time_code_new_from_string (const gchar * tc_str)
 655 {
 656   GstVideoTimeCode *tc;
 657   guint hours, minutes, seconds, frames;
 658 
 659   if (sscanf (tc_str, &quot;%02u:%02u:%02u:%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
 660           &amp;frames)
 661       == 4
<span class="line-removed"> 662       || sscanf (tc_str, &quot;%02u:%02u:%02u;%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,</span>
<span class="line-removed"> 663           &amp;frames)</span>
<span class="line-removed"> 664       == 4</span>
 665       || sscanf (tc_str, &quot;%02u:%02u:%02u.%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
 666           &amp;frames)
<span class="line-removed"> 667       == 4</span>
<span class="line-removed"> 668       || sscanf (tc_str, &quot;%02u:%02u:%02u,%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,</span>
<span class="line-removed"> 669           &amp;frames)</span>
 670       == 4) {
 671     tc = gst_video_time_code_new (0, 1, NULL, GST_VIDEO_TIME_CODE_FLAGS_NONE,
 672         hours, minutes, seconds, frames, 0);
 673 










 674     return tc;
 675   } else {
 676     GST_ERROR (&quot;Warning: Could not parse timecode %s. &quot;
 677         &quot;Please input a timecode in the form 00:00:00:00&quot;, tc_str);
 678     return NULL;
 679   }
 680 }
 681 
 682 /**
 683  * gst_video_time_code_new_from_date_time:
 684  * @fps_n: Numerator of the frame rate
 685  * @fps_d: Denominator of the frame rate
 686  * @dt: #GDateTime to convert
 687  * @flags: #GstVideoTimeCodeFlags
 688  * @field_count: Interlaced video field count
 689  *
 690  * The resulting config-&gt;latest_daily_jam is set to
 691  * midnight, and timecode is set to the given time.
 692  *
<span class="line-modified"> 693  * Returns: the #GVideoTimeCode representation of @dt.</span>




 694  *
 695  * Since: 1.12
 696  */
 697 GstVideoTimeCode *
 698 gst_video_time_code_new_from_date_time (guint fps_n, guint fps_d,
 699     GDateTime * dt, GstVideoTimeCodeFlags flags, guint field_count)
 700 {
 701   GstVideoTimeCode *tc;
 702   tc = gst_video_time_code_new_empty ();
<span class="line-modified"> 703   gst_video_time_code_init_from_date_time (tc, fps_n, fps_d, dt, flags,</span>
 704       field_count);
 705   return tc;
 706 }
 707 






























 708 /**
 709  * gst_video_time_code_init:
 710  * @tc: a #GstVideoTimeCode
 711  * @fps_n: Numerator of the frame rate
 712  * @fps_d: Denominator of the frame rate
 713  * @latest_daily_jam: The latest daily jam of the #GstVideoTimeCode
 714  * @flags: #GstVideoTimeCodeFlags
 715  * @hours: the hours field of #GstVideoTimeCode
 716  * @minutes: the minutes field of #GstVideoTimeCode
 717  * @seconds: the seconds field of #GstVideoTimeCode
 718  * @frames: the frames field of #GstVideoTimeCode
 719  * @field_count: Interlaced video field count
 720  *
 721  * @field_count is 0 for progressive, 1 or 2 for interlaced.
 722  * @latest_daiy_jam reference is stolen from caller.
 723  *
 724  * Initializes @tc with the given values.
 725  * The values are not checked for being in a valid range. To see if your
<span class="line-modified"> 726  * timecode actually has valid content, use #gst_video_time_code_is_valid.</span>
 727  *
 728  * Since: 1.10
 729  */
 730 void
 731 gst_video_time_code_init (GstVideoTimeCode * tc, guint fps_n, guint fps_d,
 732     GDateTime * latest_daily_jam, GstVideoTimeCodeFlags flags, guint hours,
 733     guint minutes, guint seconds, guint frames, guint field_count)
 734 {
 735   tc-&gt;hours = hours;
 736   tc-&gt;minutes = minutes;
 737   tc-&gt;seconds = seconds;
 738   tc-&gt;frames = frames;
 739   tc-&gt;field_count = field_count;
 740   tc-&gt;config.fps_n = fps_n;
 741   tc-&gt;config.fps_d = fps_d;
 742   if (latest_daily_jam != NULL)
 743     tc-&gt;config.latest_daily_jam = g_date_time_ref (latest_daily_jam);
 744   else
 745     tc-&gt;config.latest_daily_jam = NULL;
 746   tc-&gt;config.flags = flags;
 747 }
 748 
 749 /**
 750  * gst_video_time_code_clear:
 751  * @tc: a #GstVideoTimeCode
 752  *
<span class="line-modified"> 753  * Initializes @tc with empty/zero/NULL values.</span>

 754  *
 755  * Since: 1.10
 756  */
 757 void
 758 gst_video_time_code_clear (GstVideoTimeCode * tc)
 759 {
 760   tc-&gt;hours = 0;
 761   tc-&gt;minutes = 0;
 762   tc-&gt;seconds = 0;
 763   tc-&gt;frames = 0;
 764   tc-&gt;field_count = 0;
 765   tc-&gt;config.fps_n = 0;
 766   tc-&gt;config.fps_d = 1;
 767   if (tc-&gt;config.latest_daily_jam != NULL)
 768     g_date_time_unref (tc-&gt;config.latest_daily_jam);
 769   tc-&gt;config.latest_daily_jam = NULL;
 770   tc-&gt;config.flags = 0;
 771 }
 772 
 773 /**
 774  * gst_video_time_code_copy:
 775  * @tc: a #GstVideoTimeCode
 776  *
<span class="line-modified"> 777  * Returns: a new #GstVideoTimeCode with the same values as @tc .</span>
 778  *
 779  * Since: 1.10
 780  */
 781 GstVideoTimeCode *
 782 gst_video_time_code_copy (const GstVideoTimeCode * tc)
 783 {
 784   return gst_video_time_code_new (tc-&gt;config.fps_n, tc-&gt;config.fps_d,
 785       tc-&gt;config.latest_daily_jam, tc-&gt;config.flags, tc-&gt;hours, tc-&gt;minutes,
 786       tc-&gt;seconds, tc-&gt;frames, tc-&gt;field_count);
 787 }
 788 
 789 /**
 790  * gst_video_time_code_free:
 791  * @tc: a #GstVideoTimeCode
 792  *
<span class="line-modified"> 793  * Frees @tc .</span>
 794  *
 795  * Since: 1.10
 796  */
 797 void
 798 gst_video_time_code_free (GstVideoTimeCode * tc)
 799 {
 800   if (tc-&gt;config.latest_daily_jam != NULL)
 801     g_date_time_unref (tc-&gt;config.latest_daily_jam);
 802 
 803   g_free (tc);
 804 }
 805 
 806 /**
 807  * gst_video_time_code_add_interval:
 808  * @tc: The #GstVideoTimeCode where the diff should be added. This
 809  * must contain valid timecode values.
 810  * @tc_inter: The #GstVideoTimeCodeInterval to add to @tc.
 811  * The interval must contain valid values, except that for drop-frame
 812  * timecode, it may also contain timecodes which would normally
 813  * be dropped. These are then corrected to the next reasonable timecode.
 814  *
 815  * This makes a component-wise addition of @tc_inter to @tc. For example,
 816  * adding (&quot;01:02:03:04&quot;, &quot;00:01:00:00&quot;) will return &quot;01:03:03:04&quot;.
 817  * When it comes to drop-frame timecodes,
 818  * adding (&quot;00:00:00;00&quot;, &quot;00:01:00:00&quot;) will return &quot;00:01:00;02&quot;
 819  * because of drop-frame oddities. However,
 820  * adding (&quot;00:09:00;02&quot;, &quot;00:01:00:00&quot;) will return &quot;00:10:00;00&quot;
 821  * because this time we can have an exact minute.
 822  *
<span class="line-modified"> 823  * Returns: A new #GstVideoTimeCode with @tc_inter added.</span>

 824  *
 825  * Since: 1.12
 826  */
 827 GstVideoTimeCode *
 828 gst_video_time_code_add_interval (const GstVideoTimeCode * tc,
 829     const GstVideoTimeCodeInterval * tc_inter)
 830 {
 831   GstVideoTimeCode *ret;
 832   guint frames_to_add;
 833   guint df;
 834   gboolean needs_correction;
 835 
 836   g_return_val_if_fail (gst_video_time_code_is_valid (tc), NULL);
 837 
 838   ret = gst_video_time_code_new (tc-&gt;config.fps_n, tc-&gt;config.fps_d,
 839       tc-&gt;config.latest_daily_jam, tc-&gt;config.flags, tc_inter-&gt;hours,
 840       tc_inter-&gt;minutes, tc_inter-&gt;seconds, tc_inter-&gt;frames, 0);
 841 
 842   df = (tc-&gt;config.fps_n + (tc-&gt;config.fps_d &gt;&gt; 1)) / (tc-&gt;config.fps_d * 15);
 843 
</pre>
<hr />
<pre>
 893  *
 894  * Since: 1.12
 895  */
 896 GstVideoTimeCodeInterval *
 897 gst_video_time_code_interval_new (guint hours, guint minutes, guint seconds,
 898     guint frames)
 899 {
 900   GstVideoTimeCodeInterval *tc;
 901 
 902   tc = g_new0 (GstVideoTimeCodeInterval, 1);
 903   gst_video_time_code_interval_init (tc, hours, minutes, seconds, frames);
 904   return tc;
 905 }
 906 
 907 /**
 908  * gst_video_time_code_interval_new_from_string:
 909  * @tc_inter_str: The string that represents the #GstVideoTimeCodeInterval
 910  *
 911  * @tc_inter_str must only have &quot;:&quot; as separators.
 912  *
<span class="line-modified"> 913  * Returns: a new #GstVideoTimeCodeInterval from the given string</span>

 914  *
 915  * Since: 1.12
 916  */
 917 GstVideoTimeCodeInterval *
 918 gst_video_time_code_interval_new_from_string (const gchar * tc_inter_str)
 919 {
 920   GstVideoTimeCodeInterval *tc;
 921   guint hours, minutes, seconds, frames;
 922 
 923   if (sscanf (tc_inter_str, &quot;%02u:%02u:%02u:%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
 924           &amp;frames)
 925       == 4
 926       || sscanf (tc_inter_str, &quot;%02u:%02u:%02u;%02u&quot;, &amp;hours, &amp;minutes,
 927           &amp;seconds, &amp;frames)
 928       == 4
 929       || sscanf (tc_inter_str, &quot;%02u:%02u:%02u.%02u&quot;, &amp;hours, &amp;minutes,
 930           &amp;seconds, &amp;frames)
 931       == 4
 932       || sscanf (tc_inter_str, &quot;%02u:%02u:%02u,%02u&quot;, &amp;hours, &amp;minutes,
 933           &amp;seconds, &amp;frames)
</pre>
<hr />
<pre>
 969  * gst_video_time_code_interval_clear:
 970  * @tc: a #GstVideoTimeCodeInterval
 971  *
 972  * Initializes @tc with empty/zero/NULL values.
 973  *
 974  * Since: 1.12
 975  */
 976 void
 977 gst_video_time_code_interval_clear (GstVideoTimeCodeInterval * tc)
 978 {
 979   tc-&gt;hours = 0;
 980   tc-&gt;minutes = 0;
 981   tc-&gt;seconds = 0;
 982   tc-&gt;frames = 0;
 983 }
 984 
 985 /**
 986  * gst_video_time_code_interval_copy:
 987  * @tc: a #GstVideoTimeCodeInterval
 988  *
<span class="line-modified"> 989  * Returns: a new #GstVideoTimeCodeInterval with the same values as @tc .</span>
 990  *
 991  * Since: 1.12
 992  */
 993 GstVideoTimeCodeInterval *
 994 gst_video_time_code_interval_copy (const GstVideoTimeCodeInterval * tc)
 995 {
 996   return gst_video_time_code_interval_new (tc-&gt;hours, tc-&gt;minutes,
 997       tc-&gt;seconds, tc-&gt;frames);
 998 }
 999 
1000 /**
1001  * gst_video_time_code_interval_free:
1002  * @tc: a #GstVideoTimeCodeInterval
1003  *
<span class="line-modified">1004  * Frees @tc .</span>
1005  *
1006  * Since: 1.12
1007  */
1008 void
1009 gst_video_time_code_interval_free (GstVideoTimeCodeInterval * tc)
1010 {
1011   g_free (tc);
1012 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /* GStreamer
   2  * Copyright (C) &lt;2016&gt; Vivia Nikolaidou &lt;vivia@toolsonair.com&gt;
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Library General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public
  15  * License along with this library; if not, write to the
  16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
<span class="line-added">  19 #ifdef HAVE_CONFIG_H</span>
<span class="line-added">  20 #include &quot;config.h&quot;</span>
<span class="line-added">  21 #endif</span>
  22 
  23 #include &lt;stdio.h&gt;
  24 #include &quot;gstvideotimecode.h&quot;
  25 
  26 static void
  27 gst_video_time_code_gvalue_to_string (const GValue * tc_val, GValue * str_val);
  28 static void
  29 gst_video_time_code_gvalue_from_string (const GValue * str_val,
  30     GValue * tc_val);
  31 static gboolean gst_video_time_code_deserialize (GValue * dest,
  32     const gchar * tc_str);
  33 static gchar *gst_video_time_code_serialize (const GValue * val);
  34 
  35 static void
  36 _init (GType type)
  37 {
  38   static GstValueTable table =
  39       { 0, (GstValueCompareFunc) gst_video_time_code_compare,
  40     (GstValueSerializeFunc) gst_video_time_code_serialize,
  41     (GstValueDeserializeFunc) gst_video_time_code_deserialize
</pre>
<hr />
<pre>
  52 G_DEFINE_BOXED_TYPE_WITH_CODE (GstVideoTimeCode, gst_video_time_code,
  53     (GBoxedCopyFunc) gst_video_time_code_copy,
  54     (GBoxedFreeFunc) gst_video_time_code_free, _init (g_define_type_id));
  55 
  56 /**
  57  * gst_video_time_code_is_valid:
  58  * @tc: #GstVideoTimeCode to check
  59  *
  60  * Returns: whether @tc is a valid timecode (supported frame rate,
  61  * hours/minutes/seconds/frames not overflowing)
  62  *
  63  * Since: 1.10
  64  */
  65 gboolean
  66 gst_video_time_code_is_valid (const GstVideoTimeCode * tc)
  67 {
  68   guint fr;
  69 
  70   g_return_val_if_fail (tc != NULL, FALSE);
  71 
<span class="line-modified">  72   if (tc-&gt;config.fps_n == 0 || tc-&gt;config.fps_d == 0)</span>
<span class="line-added">  73     return FALSE;</span>
  74 
  75   if (tc-&gt;hours &gt;= 24)
  76     return FALSE;
  77   if (tc-&gt;minutes &gt;= 60)
  78     return FALSE;
  79   if (tc-&gt;seconds &gt;= 60)
  80     return FALSE;
<span class="line-modified">  81 </span>
<span class="line-modified">  82   /* We can&#39;t have more frames than rounded up frames per second */</span>
<span class="line-added">  83   fr = (tc-&gt;config.fps_n + (tc-&gt;config.fps_d &gt;&gt; 1)) / tc-&gt;config.fps_d;</span>
  84   if (tc-&gt;frames &gt;= fr &amp;&amp; (tc-&gt;config.fps_n != 0 || tc-&gt;config.fps_d != 1))
  85     return FALSE;
<span class="line-added">  86 </span>
<span class="line-added">  87   /* We either need a specific X/1001 framerate or otherwise an integer</span>
<span class="line-added">  88    * framerate */</span>
  89   if (tc-&gt;config.fps_d == 1001) {
  90     if (tc-&gt;config.fps_n != 30000 &amp;&amp; tc-&gt;config.fps_n != 60000 &amp;&amp;
  91         tc-&gt;config.fps_n != 24000)
  92       return FALSE;
  93   } else if (tc-&gt;config.fps_n % tc-&gt;config.fps_d != 0) {
  94     return FALSE;
  95   }
<span class="line-added">  96 </span>
<span class="line-added">  97   /* We only support 30000/1001 and 60000/1001 as drop-frame framerates.</span>
<span class="line-added">  98    * 24000/1001 is *not* a drop-frame framerate! */</span>
<span class="line-added">  99   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) {</span>
<span class="line-added"> 100     if (tc-&gt;config.fps_d != 1001 || (tc-&gt;config.fps_n != 30000</span>
<span class="line-added"> 101             &amp;&amp; tc-&gt;config.fps_n != 60000))</span>
<span class="line-added"> 102       return FALSE;</span>
<span class="line-added"> 103   }</span>
<span class="line-added"> 104 </span>
<span class="line-added"> 105   /* Drop-frame framerates require skipping over the first two</span>
<span class="line-added"> 106    * timecodes every minutes except for every tenth minute in case</span>
<span class="line-added"> 107    * of 30000/1001 and the first four timecodes for 60000/1001 */</span>
 108   if ((tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) &amp;&amp;
 109       tc-&gt;minutes % 10 &amp;&amp; tc-&gt;seconds == 0 &amp;&amp; tc-&gt;frames &lt; fr / 15) {
 110     return FALSE;
 111   }
 112 
 113   return TRUE;
 114 }
 115 
 116 /**
 117  * gst_video_time_code_to_string:
<span class="line-modified"> 118  * @tc: A #GstVideoTimeCode to convert</span>
 119  *
 120  * Returns: the SMPTE ST 2059-1:2015 string representation of @tc. That will
<span class="line-modified"> 121  * take the form hh:mm:ss:ff. The last separator (between seconds and frames)</span>
 122  * may vary:
 123  *
 124  * &#39;;&#39; for drop-frame, non-interlaced content and for drop-frame interlaced
 125  * field 2
 126  * &#39;,&#39; for drop-frame interlaced field 1
 127  * &#39;:&#39; for non-drop-frame, non-interlaced content and for non-drop-frame
 128  * interlaced field 2
 129  * &#39;.&#39; for non-drop-frame interlaced field 1
 130  *
 131  * Since: 1.10
 132  */
 133 gchar *
 134 gst_video_time_code_to_string (const GstVideoTimeCode * tc)
 135 {
 136   gchar *ret;
 137   gboolean top_dot_present;
 138   gchar sep;
 139 
 140   /* Top dot is present for non-interlaced content, and for field 2 in
 141    * interlaced content */
</pre>
<hr />
<pre>
 144       &amp;&amp; tc-&gt;field_count == 1);
 145 
 146   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME)
 147     sep = top_dot_present ? &#39;;&#39; : &#39;,&#39;;
 148   else
 149     sep = top_dot_present ? &#39;:&#39; : &#39;.&#39;;
 150 
 151   ret =
 152       g_strdup_printf (&quot;%02d:%02d:%02d%c%02d&quot;, tc-&gt;hours, tc-&gt;minutes,
 153       tc-&gt;seconds, sep, tc-&gt;frames);
 154 
 155   return ret;
 156 }
 157 
 158 /**
 159  * gst_video_time_code_to_date_time:
 160  * @tc: A valid #GstVideoTimeCode to convert
 161  *
 162  * The @tc.config-&gt;latest_daily_jam is required to be non-NULL.
 163  *
<span class="line-modified"> 164  * Returns: (nullable): the #GDateTime representation of @tc or %NULL if @tc</span>
<span class="line-added"> 165  *   has no daily jam.</span>
 166  *
 167  * Since: 1.10
 168  */
 169 GDateTime *
 170 gst_video_time_code_to_date_time (const GstVideoTimeCode * tc)
 171 {
 172   GDateTime *ret;
 173   GDateTime *ret2;
 174   gdouble add_us;
 175 
 176   g_return_val_if_fail (gst_video_time_code_is_valid (tc), NULL);

 177 
<span class="line-modified"> 178   if (tc-&gt;config.latest_daily_jam == NULL) {</span>


 179     gchar *tc_str = gst_video_time_code_to_string (tc);
 180     GST_WARNING
 181         (&quot;Asked to convert time code %s to GDateTime, but its latest daily jam is NULL&quot;,
 182         tc_str);
 183     g_free (tc_str);

 184     return NULL;
 185   }
 186 
<span class="line-modified"> 187   ret = g_date_time_ref (tc-&gt;config.latest_daily_jam);</span>








 188 
 189   gst_util_fraction_to_double (tc-&gt;frames * tc-&gt;config.fps_d, tc-&gt;config.fps_n,
 190       &amp;add_us);
 191   if ((tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_INTERLACED)
 192       &amp;&amp; tc-&gt;field_count == 1) {
 193     gdouble sub_us;
 194 
 195     gst_util_fraction_to_double (tc-&gt;config.fps_d, 2 * tc-&gt;config.fps_n,
 196         &amp;sub_us);
 197     add_us -= sub_us;
 198   }
 199 
 200   ret2 = g_date_time_add_seconds (ret, add_us + tc-&gt;seconds);
 201   g_date_time_unref (ret);
 202   ret = g_date_time_add_minutes (ret2, tc-&gt;minutes);
 203   g_date_time_unref (ret2);
 204   ret2 = g_date_time_add_hours (ret, tc-&gt;hours);
 205   g_date_time_unref (ret);
 206 
 207   return ret2;
 208 }
 209 
 210 /**
 211  * gst_video_time_code_init_from_date_time:
<span class="line-modified"> 212  * @tc: an uninitialized #GstVideoTimeCode</span>
 213  * @fps_n: Numerator of the frame rate
 214  * @fps_d: Denominator of the frame rate
 215  * @dt: #GDateTime to convert
 216  * @flags: #GstVideoTimeCodeFlags
 217  * @field_count: Interlaced video field count
 218  *
<span class="line-modified"> 219  * The resulting config-&gt;latest_daily_jam is set to midnight, and timecode is</span>
<span class="line-modified"> 220  * set to the given time.</span>
<span class="line-added"> 221  *</span>
<span class="line-added"> 222  * Will assert on invalid parameters, use gst_video_time_code_init_from_date_time_full()</span>
<span class="line-added"> 223  * for being able to handle invalid parameters.</span>
 224  *
 225  * Since: 1.12
 226  */

 227 void
 228 gst_video_time_code_init_from_date_time (GstVideoTimeCode * tc,
 229     guint fps_n, guint fps_d,
 230     GDateTime * dt, GstVideoTimeCodeFlags flags, guint field_count)
<span class="line-added"> 231 {</span>
<span class="line-added"> 232   if (!gst_video_time_code_init_from_date_time_full (tc, fps_n, fps_d, dt,</span>
<span class="line-added"> 233           flags, field_count))</span>
<span class="line-added"> 234     g_return_if_fail (gst_video_time_code_is_valid (tc));</span>
<span class="line-added"> 235 }</span>
<span class="line-added"> 236 </span>
<span class="line-added"> 237 /**</span>
<span class="line-added"> 238  * gst_video_time_code_init_from_date_time_full:</span>
<span class="line-added"> 239  * @tc: a #GstVideoTimeCode</span>
<span class="line-added"> 240  * @fps_n: Numerator of the frame rate</span>
<span class="line-added"> 241  * @fps_d: Denominator of the frame rate</span>
<span class="line-added"> 242  * @dt: #GDateTime to convert</span>
<span class="line-added"> 243  * @flags: #GstVideoTimeCodeFlags</span>
<span class="line-added"> 244  * @field_count: Interlaced video field count</span>
<span class="line-added"> 245  *</span>
<span class="line-added"> 246  * The resulting config-&gt;latest_daily_jam is set to</span>
<span class="line-added"> 247  * midnight, and timecode is set to the given time.</span>
<span class="line-added"> 248  *</span>
<span class="line-added"> 249  * Returns: %TRUE if @tc could be correctly initialized to a valid timecode</span>
<span class="line-added"> 250  *</span>
<span class="line-added"> 251  * Since: 1.16</span>
<span class="line-added"> 252  */</span>
<span class="line-added"> 253 gboolean</span>
<span class="line-added"> 254 gst_video_time_code_init_from_date_time_full (GstVideoTimeCode * tc,</span>
<span class="line-added"> 255     guint fps_n, guint fps_d,</span>
<span class="line-added"> 256     GDateTime * dt, GstVideoTimeCodeFlags flags, guint field_count)</span>
 257 {
 258   GDateTime *jam;
 259   guint64 frames;
 260   gboolean add_a_frame = FALSE;
 261 
<span class="line-added"> 262   g_return_val_if_fail (tc != NULL, FALSE);</span>
<span class="line-added"> 263   g_return_val_if_fail (dt != NULL, FALSE);</span>
<span class="line-added"> 264   g_return_val_if_fail (fps_n != 0 &amp;&amp; fps_d != 0, FALSE);</span>
<span class="line-added"> 265 </span>
<span class="line-added"> 266   gst_video_time_code_clear (tc);</span>
<span class="line-added"> 267 </span>
 268   jam = g_date_time_new_local (g_date_time_get_year (dt),
 269       g_date_time_get_month (dt), g_date_time_get_day_of_month (dt), 0, 0, 0.0);
 270 
 271   /* Note: This might be inaccurate for 1 frame
 272    * in case we have a drop frame timecode */
 273   frames =
 274       gst_util_uint64_scale_round (g_date_time_get_microsecond (dt) *
 275       G_GINT64_CONSTANT (1000), fps_n, fps_d * GST_SECOND);
 276   if (G_UNLIKELY (((frames == fps_n) &amp;&amp; (fps_d == 1)) ||
 277           ((frames == fps_n / 1000) &amp;&amp; (fps_d == 1001)))) {
 278     /* Avoid invalid timecodes */
 279     frames--;
 280     add_a_frame = TRUE;
 281   }
 282 
 283   gst_video_time_code_init (tc, fps_n, fps_d, jam, flags,
 284       g_date_time_get_hour (dt), g_date_time_get_minute (dt),
 285       g_date_time_get_second (dt), frames, field_count);
 286 
 287   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) {
 288     guint df = (tc-&gt;config.fps_n + (tc-&gt;config.fps_d &gt;&gt; 1)) /
 289         (15 * tc-&gt;config.fps_d);
 290     if (tc-&gt;minutes % 10 &amp;&amp; tc-&gt;seconds == 0 &amp;&amp; tc-&gt;frames &lt; df) {
 291       tc-&gt;frames = df;
 292     }
 293   }
 294   if (add_a_frame)
 295     gst_video_time_code_increment_frame (tc);
 296 
 297   g_date_time_unref (jam);
 298 
<span class="line-modified"> 299   return gst_video_time_code_is_valid (tc);</span>
 300 }
 301 
 302 /**
 303  * gst_video_time_code_nsec_since_daily_jam:
 304  * @tc: a valid #GstVideoTimeCode
 305  *
<span class="line-modified"> 306  * Returns: how many nsec have passed since the daily jam of @tc.</span>
 307  *
 308  * Since: 1.10
 309  */
 310 guint64
 311 gst_video_time_code_nsec_since_daily_jam (const GstVideoTimeCode * tc)
 312 {
 313   guint64 frames, nsec;
 314 
 315   g_return_val_if_fail (gst_video_time_code_is_valid (tc), -1);
 316 









 317   frames = gst_video_time_code_frames_since_daily_jam (tc);
 318   nsec =
 319       gst_util_uint64_scale (frames, GST_SECOND * tc-&gt;config.fps_d,
 320       tc-&gt;config.fps_n);
 321 
 322   return nsec;
 323 }
 324 
 325 /**
 326  * gst_video_time_code_frames_since_daily_jam:
 327  * @tc: a valid #GstVideoTimeCode
 328  *
<span class="line-modified"> 329  * Returns: how many frames have passed since the daily jam of @tc.</span>
 330  *
 331  * Since: 1.10
 332  */
 333 guint64
 334 gst_video_time_code_frames_since_daily_jam (const GstVideoTimeCode * tc)
 335 {
 336   guint ff_nom;
 337   gdouble ff;
 338 
 339   g_return_val_if_fail (gst_video_time_code_is_valid (tc), -1);
 340 
 341   gst_util_fraction_to_double (tc-&gt;config.fps_n, tc-&gt;config.fps_d, &amp;ff);
 342   if (tc-&gt;config.fps_d == 1001) {
 343     ff_nom = tc-&gt;config.fps_n / 1000;
 344   } else {
 345     ff_nom = ff;
 346   }
 347   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) {
 348     /* these need to be truncated to integer: side effect, code looks cleaner
 349      * */
 350     guint ff_minutes = 60 * ff;
 351     guint ff_hours = 3600 * ff;
 352     /* for 30000/1001 we drop the first 2 frames per minute, for 60000/1001 we
 353      * drop the first 4 : so we use this number */
 354     guint dropframe_multiplier;
 355 
 356     if (tc-&gt;config.fps_n == 30000) {
 357       dropframe_multiplier = 2;
 358     } else if (tc-&gt;config.fps_n == 60000) {
 359       dropframe_multiplier = 4;
 360     } else {
<span class="line-modified"> 361       /* already checked by gst_video_time_code_is_valid() */</span>
<span class="line-modified"> 362       g_assert_not_reached ();</span>

 363     }
 364 
 365     return tc-&gt;frames + (ff_nom * tc-&gt;seconds) +
 366         (ff_minutes * tc-&gt;minutes) +
 367         dropframe_multiplier * ((gint) (tc-&gt;minutes / 10)) +
 368         (ff_hours * tc-&gt;hours);
 369   } else {
 370     return tc-&gt;frames + (ff_nom * (tc-&gt;seconds + (60 * (tc-&gt;minutes +
 371                     (60 * tc-&gt;hours)))));
 372   }
 373 
 374 }
 375 
 376 /**
 377  * gst_video_time_code_increment_frame:
 378  * @tc: a valid #GstVideoTimeCode
 379  *
<span class="line-modified"> 380  * Adds one frame to @tc.</span>
 381  *
 382  * Since: 1.10
 383  */
 384 void
 385 gst_video_time_code_increment_frame (GstVideoTimeCode * tc)
 386 {
 387   gst_video_time_code_add_frames (tc, 1);
 388 }
 389 
 390 /**
 391  * gst_video_time_code_add_frames:
 392  * @tc: a valid #GstVideoTimeCode
 393  * @frames: How many frames to add or subtract
 394  *
 395  * Adds or subtracts @frames amount of frames to @tc. tc needs to
<span class="line-modified"> 396  * contain valid data, as verified by gst_video_time_code_is_valid().</span>
 397  *
 398  * Since: 1.10
 399  */
 400 void
 401 gst_video_time_code_add_frames (GstVideoTimeCode * tc, gint64 frames)
 402 {
 403   guint64 framecount;
 404   guint64 h_notmod24;
 405   guint64 h_new, min_new, sec_new, frames_new;
 406   gdouble ff;
 407   guint ff_nom;
 408   /* This allows for better readability than putting G_GUINT64_CONSTANT(60)
 409    * into a long calculation line */
 410   const guint64 sixty = 60;
 411   /* formulas found in SMPTE ST 2059-1:2015 section 9.4.3
 412    * and adapted for 60/1.001 as well as 30/1.001 */
 413 
 414   g_return_if_fail (gst_video_time_code_is_valid (tc));
 415 
 416   gst_util_fraction_to_double (tc-&gt;config.fps_n, tc-&gt;config.fps_d, &amp;ff);
 417   if (tc-&gt;config.fps_d == 1001) {
 418     ff_nom = tc-&gt;config.fps_n / 1000;
 419   } else {
 420     ff_nom = ff;



 421   }
<span class="line-added"> 422 </span>
 423   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) {
 424     /* these need to be truncated to integer: side effect, code looks cleaner
 425      * */
 426     guint ff_minutes = 60 * ff;
 427     guint ff_hours = 3600 * ff;
 428     /* a bunch of intermediate variables, to avoid monster code with possible
 429      * integer overflows */
 430     guint64 min_new_tmp1, min_new_tmp2, min_new_tmp3, min_new_denom;
 431     /* for 30000/1001 we drop the first 2 frames per minute, for 60000/1001 we
 432      * drop the first 4 : so we use this number */
 433     guint dropframe_multiplier;
 434 
<span class="line-modified"> 435     if (tc-&gt;config.fps_n == 30000) {</span>
 436       dropframe_multiplier = 2;
<span class="line-modified"> 437     } else if (tc-&gt;config.fps_n == 60000) {</span>
 438       dropframe_multiplier = 4;
<span class="line-modified"> 439     } else {</span>
<span class="line-modified"> 440       /* already checked by gst_video_time_code_is_valid() */</span>
<span class="line-modified"> 441       g_assert_not_reached ();</span>

 442     }
 443 
 444     framecount =
 445         frames + tc-&gt;frames + (ff_nom * tc-&gt;seconds) +
 446         (ff_minutes * tc-&gt;minutes) +
 447         dropframe_multiplier * ((gint) (tc-&gt;minutes / 10)) +
 448         (ff_hours * tc-&gt;hours);
 449     h_notmod24 = gst_util_uint64_scale_int (framecount, 1, ff_hours);
 450 
 451     min_new_denom = sixty * ff_nom;
 452     min_new_tmp1 = (framecount - (h_notmod24 * ff_hours)) / min_new_denom;
 453     min_new_tmp2 = framecount + dropframe_multiplier * min_new_tmp1;
 454     min_new_tmp1 =
 455         (framecount - (h_notmod24 * ff_hours)) / (sixty * 10 * ff_nom);
 456     min_new_tmp3 =
 457         dropframe_multiplier * min_new_tmp1 + (h_notmod24 * ff_hours);
 458     min_new =
 459         gst_util_uint64_scale_int (min_new_tmp2 - min_new_tmp3, 1,
 460         min_new_denom);
 461 
</pre>
<hr />
<pre>
 469         (dropframe_multiplier * ((gint) (min_new / 10))) -
 470         (ff_hours * h_notmod24);
 471   } else {
 472     framecount =
 473         frames + tc-&gt;frames + (ff_nom * (tc-&gt;seconds + (sixty * (tc-&gt;minutes +
 474                     (sixty * tc-&gt;hours)))));
 475     h_notmod24 =
 476         gst_util_uint64_scale_int (framecount, 1, ff_nom * sixty * sixty);
 477     min_new =
 478         gst_util_uint64_scale_int ((framecount -
 479             (ff_nom * sixty * sixty * h_notmod24)), 1, (ff_nom * sixty));
 480     sec_new =
 481         gst_util_uint64_scale_int ((framecount - (ff_nom * sixty * (min_new +
 482                     (sixty * h_notmod24)))), 1, ff_nom);
 483     frames_new =
 484         framecount - (ff_nom * (sec_new + sixty * (min_new +
 485                 (sixty * h_notmod24))));
 486     if (frames_new &gt; ff_nom)
 487       frames_new = 0;
 488   }
<span class="line-added"> 489 </span>
 490   h_new = h_notmod24 % 24;
 491 
<span class="line-added"> 492   /* The calculations above should always give correct results */</span>
 493   g_assert (min_new &lt; 60);
 494   g_assert (sec_new &lt; 60);
 495   g_assert (frames_new &lt; ff_nom);
<span class="line-added"> 496 </span>
 497   tc-&gt;hours = h_new;
 498   tc-&gt;minutes = min_new;
 499   tc-&gt;seconds = sec_new;
 500   tc-&gt;frames = frames_new;
 501 }
 502 
 503 /**
 504  * gst_video_time_code_compare:
<span class="line-modified"> 505  * @tc1: a valid #GstVideoTimeCode</span>
<span class="line-modified"> 506  * @tc2: another valid #GstVideoTimeCode</span>
 507  *
<span class="line-modified"> 508  * Compares @tc1 and @tc2. If both have latest daily jam information, it is</span>
 509  * taken into account. Otherwise, it is assumed that the daily jam of both
 510  * @tc1 and @tc2 was at the same time. Both time codes must be valid.
 511  *
 512  * Returns: 1 if @tc1 is after @tc2, -1 if @tc1 is before @tc2, 0 otherwise.
 513  *
 514  * Since: 1.10
 515  */
 516 gint
 517 gst_video_time_code_compare (const GstVideoTimeCode * tc1,
 518     const GstVideoTimeCode * tc2)
 519 {
 520   g_return_val_if_fail (gst_video_time_code_is_valid (tc1), -1);
 521   g_return_val_if_fail (gst_video_time_code_is_valid (tc2), -1);
 522 
 523   if (tc1-&gt;config.latest_daily_jam == NULL
 524       || tc2-&gt;config.latest_daily_jam == NULL) {
 525     guint64 nsec1, nsec2;
 526 #ifndef GST_DISABLE_GST_DEBUG
 527     gchar *str1, *str2;
 528 
</pre>
<hr />
<pre>
 585   }
 586 }
 587 
 588 /**
 589  * gst_video_time_code_new:
 590  * @fps_n: Numerator of the frame rate
 591  * @fps_d: Denominator of the frame rate
 592  * @latest_daily_jam: The latest daily jam of the #GstVideoTimeCode
 593  * @flags: #GstVideoTimeCodeFlags
 594  * @hours: the hours field of #GstVideoTimeCode
 595  * @minutes: the minutes field of #GstVideoTimeCode
 596  * @seconds: the seconds field of #GstVideoTimeCode
 597  * @frames: the frames field of #GstVideoTimeCode
 598  * @field_count: Interlaced video field count
 599  *
 600  * @field_count is 0 for progressive, 1 or 2 for interlaced.
 601  * @latest_daiy_jam reference is stolen from caller.
 602  *
 603  * Returns: a new #GstVideoTimeCode with the given values.
 604  * The values are not checked for being in a valid range. To see if your
<span class="line-modified"> 605  * timecode actually has valid content, use gst_video_time_code_is_valid().</span>
 606  *
 607  * Since: 1.10
 608  */
 609 GstVideoTimeCode *
 610 gst_video_time_code_new (guint fps_n, guint fps_d, GDateTime * latest_daily_jam,
 611     GstVideoTimeCodeFlags flags, guint hours, guint minutes, guint seconds,
 612     guint frames, guint field_count)
 613 {
 614   GstVideoTimeCode *tc;
 615 
 616   tc = g_new0 (GstVideoTimeCode, 1);
 617   gst_video_time_code_init (tc, fps_n, fps_d, latest_daily_jam, flags, hours,
 618       minutes, seconds, frames, field_count);
 619   return tc;
 620 }
 621 
 622 /**
 623  * gst_video_time_code_new_empty:
 624  *
<span class="line-modified"> 625  * Returns: a new empty, invalid #GstVideoTimeCode</span>
 626  *
 627  * Since: 1.10
 628  */
 629 GstVideoTimeCode *
 630 gst_video_time_code_new_empty (void)
 631 {
 632   GstVideoTimeCode *tc;
 633 
 634   tc = g_new0 (GstVideoTimeCode, 1);
 635   gst_video_time_code_clear (tc);
 636   return tc;
 637 }
 638 
 639 static void
 640 gst_video_time_code_gvalue_from_string (const GValue * str_val, GValue * tc_val)
 641 {
 642   const gchar *tc_str = g_value_get_string (str_val);
 643   GstVideoTimeCode *tc;
 644 
 645   tc = gst_video_time_code_new_from_string (tc_str);
</pre>
<hr />
<pre>
 651 {
 652   const GstVideoTimeCode *tc = g_value_get_boxed (tc_val);
 653   gchar *tc_str;
 654 
 655   tc_str = gst_video_time_code_to_string (tc);
 656   g_value_take_string (str_val, tc_str);
 657 }
 658 
 659 static gchar *
 660 gst_video_time_code_serialize (const GValue * val)
 661 {
 662   GstVideoTimeCode *tc = g_value_get_boxed (val);
 663   return gst_video_time_code_to_string (tc);
 664 }
 665 
 666 static gboolean
 667 gst_video_time_code_deserialize (GValue * dest, const gchar * tc_str)
 668 {
 669   GstVideoTimeCode *tc = gst_video_time_code_new_from_string (tc_str);
 670 
<span class="line-modified"> 671   if (tc == NULL) {</span>
 672     return FALSE;
<span class="line-added"> 673   }</span>
 674 
 675   g_value_take_boxed (dest, tc);
 676   return TRUE;
 677 }
 678 
 679 /**
 680  * gst_video_time_code_new_from_string:
 681  * @tc_str: The string that represents the #GstVideoTimeCode
 682  *
<span class="line-modified"> 683  * Returns: (nullable): a new #GstVideoTimeCode from the given string or %NULL</span>
<span class="line-added"> 684  *   if the string could not be passed.</span>
 685  *
 686  * Since: 1.12
 687  */
 688 GstVideoTimeCode *
 689 gst_video_time_code_new_from_string (const gchar * tc_str)
 690 {
 691   GstVideoTimeCode *tc;
 692   guint hours, minutes, seconds, frames;
 693 
 694   if (sscanf (tc_str, &quot;%02u:%02u:%02u:%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
 695           &amp;frames)
 696       == 4



 697       || sscanf (tc_str, &quot;%02u:%02u:%02u.%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
 698           &amp;frames)



 699       == 4) {
 700     tc = gst_video_time_code_new (0, 1, NULL, GST_VIDEO_TIME_CODE_FLAGS_NONE,
 701         hours, minutes, seconds, frames, 0);
 702 
<span class="line-added"> 703     return tc;</span>
<span class="line-added"> 704   } else if (sscanf (tc_str, &quot;%02u:%02u:%02u;%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,</span>
<span class="line-added"> 705           &amp;frames)</span>
<span class="line-added"> 706       == 4 || sscanf (tc_str, &quot;%02u:%02u:%02u,%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,</span>
<span class="line-added"> 707           &amp;frames)</span>
<span class="line-added"> 708       == 4) {</span>
<span class="line-added"> 709     tc = gst_video_time_code_new (0, 1, NULL,</span>
<span class="line-added"> 710         GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME, hours, minutes, seconds, frames,</span>
<span class="line-added"> 711         0);</span>
<span class="line-added"> 712 </span>
 713     return tc;
 714   } else {
 715     GST_ERROR (&quot;Warning: Could not parse timecode %s. &quot;
 716         &quot;Please input a timecode in the form 00:00:00:00&quot;, tc_str);
 717     return NULL;
 718   }
 719 }
 720 
 721 /**
 722  * gst_video_time_code_new_from_date_time:
 723  * @fps_n: Numerator of the frame rate
 724  * @fps_d: Denominator of the frame rate
 725  * @dt: #GDateTime to convert
 726  * @flags: #GstVideoTimeCodeFlags
 727  * @field_count: Interlaced video field count
 728  *
 729  * The resulting config-&gt;latest_daily_jam is set to
 730  * midnight, and timecode is set to the given time.
 731  *
<span class="line-modified"> 732  * This might return a completely invalid timecode, use</span>
<span class="line-added"> 733  * gst_video_time_code_new_from_date_time_full() to ensure</span>
<span class="line-added"> 734  * that you would get %NULL instead in that case.</span>
<span class="line-added"> 735  *</span>
<span class="line-added"> 736  * Returns: the #GstVideoTimeCode representation of @dt.</span>
 737  *
 738  * Since: 1.12
 739  */
 740 GstVideoTimeCode *
 741 gst_video_time_code_new_from_date_time (guint fps_n, guint fps_d,
 742     GDateTime * dt, GstVideoTimeCodeFlags flags, guint field_count)
 743 {
 744   GstVideoTimeCode *tc;
 745   tc = gst_video_time_code_new_empty ();
<span class="line-modified"> 746   gst_video_time_code_init_from_date_time_full (tc, fps_n, fps_d, dt, flags,</span>
 747       field_count);
 748   return tc;
 749 }
 750 
<span class="line-added"> 751 /**</span>
<span class="line-added"> 752  * gst_video_time_code_new_from_date_time_full:</span>
<span class="line-added"> 753  * @fps_n: Numerator of the frame rate</span>
<span class="line-added"> 754  * @fps_d: Denominator of the frame rate</span>
<span class="line-added"> 755  * @dt: #GDateTime to convert</span>
<span class="line-added"> 756  * @flags: #GstVideoTimeCodeFlags</span>
<span class="line-added"> 757  * @field_count: Interlaced video field count</span>
<span class="line-added"> 758  *</span>
<span class="line-added"> 759  * The resulting config-&gt;latest_daily_jam is set to</span>
<span class="line-added"> 760  * midnight, and timecode is set to the given time.</span>
<span class="line-added"> 761  *</span>
<span class="line-added"> 762  * Returns: the #GstVideoTimeCode representation of @dt, or %NULL if</span>
<span class="line-added"> 763  *   no valid timecode could be created.</span>
<span class="line-added"> 764  *</span>
<span class="line-added"> 765  * Since: 1.16</span>
<span class="line-added"> 766  */</span>
<span class="line-added"> 767 GstVideoTimeCode *</span>
<span class="line-added"> 768 gst_video_time_code_new_from_date_time_full (guint fps_n, guint fps_d,</span>
<span class="line-added"> 769     GDateTime * dt, GstVideoTimeCodeFlags flags, guint field_count)</span>
<span class="line-added"> 770 {</span>
<span class="line-added"> 771   GstVideoTimeCode *tc;</span>
<span class="line-added"> 772   tc = gst_video_time_code_new_empty ();</span>
<span class="line-added"> 773   if (!gst_video_time_code_init_from_date_time_full (tc, fps_n, fps_d, dt,</span>
<span class="line-added"> 774           flags, field_count)) {</span>
<span class="line-added"> 775     gst_video_time_code_free (tc);</span>
<span class="line-added"> 776     return NULL;</span>
<span class="line-added"> 777   }</span>
<span class="line-added"> 778   return tc;</span>
<span class="line-added"> 779 }</span>
<span class="line-added"> 780 </span>
 781 /**
 782  * gst_video_time_code_init:
 783  * @tc: a #GstVideoTimeCode
 784  * @fps_n: Numerator of the frame rate
 785  * @fps_d: Denominator of the frame rate
 786  * @latest_daily_jam: The latest daily jam of the #GstVideoTimeCode
 787  * @flags: #GstVideoTimeCodeFlags
 788  * @hours: the hours field of #GstVideoTimeCode
 789  * @minutes: the minutes field of #GstVideoTimeCode
 790  * @seconds: the seconds field of #GstVideoTimeCode
 791  * @frames: the frames field of #GstVideoTimeCode
 792  * @field_count: Interlaced video field count
 793  *
 794  * @field_count is 0 for progressive, 1 or 2 for interlaced.
 795  * @latest_daiy_jam reference is stolen from caller.
 796  *
 797  * Initializes @tc with the given values.
 798  * The values are not checked for being in a valid range. To see if your
<span class="line-modified"> 799  * timecode actually has valid content, use gst_video_time_code_is_valid().</span>
 800  *
 801  * Since: 1.10
 802  */
 803 void
 804 gst_video_time_code_init (GstVideoTimeCode * tc, guint fps_n, guint fps_d,
 805     GDateTime * latest_daily_jam, GstVideoTimeCodeFlags flags, guint hours,
 806     guint minutes, guint seconds, guint frames, guint field_count)
 807 {
 808   tc-&gt;hours = hours;
 809   tc-&gt;minutes = minutes;
 810   tc-&gt;seconds = seconds;
 811   tc-&gt;frames = frames;
 812   tc-&gt;field_count = field_count;
 813   tc-&gt;config.fps_n = fps_n;
 814   tc-&gt;config.fps_d = fps_d;
 815   if (latest_daily_jam != NULL)
 816     tc-&gt;config.latest_daily_jam = g_date_time_ref (latest_daily_jam);
 817   else
 818     tc-&gt;config.latest_daily_jam = NULL;
 819   tc-&gt;config.flags = flags;
 820 }
 821 
 822 /**
 823  * gst_video_time_code_clear:
 824  * @tc: a #GstVideoTimeCode
 825  *
<span class="line-modified"> 826  * Initializes @tc with empty/zero/NULL values and frees any memory</span>
<span class="line-added"> 827  * it might currently use.</span>
 828  *
 829  * Since: 1.10
 830  */
 831 void
 832 gst_video_time_code_clear (GstVideoTimeCode * tc)
 833 {
 834   tc-&gt;hours = 0;
 835   tc-&gt;minutes = 0;
 836   tc-&gt;seconds = 0;
 837   tc-&gt;frames = 0;
 838   tc-&gt;field_count = 0;
 839   tc-&gt;config.fps_n = 0;
 840   tc-&gt;config.fps_d = 1;
 841   if (tc-&gt;config.latest_daily_jam != NULL)
 842     g_date_time_unref (tc-&gt;config.latest_daily_jam);
 843   tc-&gt;config.latest_daily_jam = NULL;
 844   tc-&gt;config.flags = 0;
 845 }
 846 
 847 /**
 848  * gst_video_time_code_copy:
 849  * @tc: a #GstVideoTimeCode
 850  *
<span class="line-modified"> 851  * Returns: a new #GstVideoTimeCode with the same values as @tc.</span>
 852  *
 853  * Since: 1.10
 854  */
 855 GstVideoTimeCode *
 856 gst_video_time_code_copy (const GstVideoTimeCode * tc)
 857 {
 858   return gst_video_time_code_new (tc-&gt;config.fps_n, tc-&gt;config.fps_d,
 859       tc-&gt;config.latest_daily_jam, tc-&gt;config.flags, tc-&gt;hours, tc-&gt;minutes,
 860       tc-&gt;seconds, tc-&gt;frames, tc-&gt;field_count);
 861 }
 862 
 863 /**
 864  * gst_video_time_code_free:
 865  * @tc: a #GstVideoTimeCode
 866  *
<span class="line-modified"> 867  * Frees @tc.</span>
 868  *
 869  * Since: 1.10
 870  */
 871 void
 872 gst_video_time_code_free (GstVideoTimeCode * tc)
 873 {
 874   if (tc-&gt;config.latest_daily_jam != NULL)
 875     g_date_time_unref (tc-&gt;config.latest_daily_jam);
 876 
 877   g_free (tc);
 878 }
 879 
 880 /**
 881  * gst_video_time_code_add_interval:
 882  * @tc: The #GstVideoTimeCode where the diff should be added. This
 883  * must contain valid timecode values.
 884  * @tc_inter: The #GstVideoTimeCodeInterval to add to @tc.
 885  * The interval must contain valid values, except that for drop-frame
 886  * timecode, it may also contain timecodes which would normally
 887  * be dropped. These are then corrected to the next reasonable timecode.
 888  *
 889  * This makes a component-wise addition of @tc_inter to @tc. For example,
 890  * adding (&quot;01:02:03:04&quot;, &quot;00:01:00:00&quot;) will return &quot;01:03:03:04&quot;.
 891  * When it comes to drop-frame timecodes,
 892  * adding (&quot;00:00:00;00&quot;, &quot;00:01:00:00&quot;) will return &quot;00:01:00;02&quot;
 893  * because of drop-frame oddities. However,
 894  * adding (&quot;00:09:00;02&quot;, &quot;00:01:00:00&quot;) will return &quot;00:10:00;00&quot;
 895  * because this time we can have an exact minute.
 896  *
<span class="line-modified"> 897  * Returns: (nullable): A new #GstVideoTimeCode with @tc_inter added or %NULL</span>
<span class="line-added"> 898  *   if the interval can&#39;t be added.</span>
 899  *
 900  * Since: 1.12
 901  */
 902 GstVideoTimeCode *
 903 gst_video_time_code_add_interval (const GstVideoTimeCode * tc,
 904     const GstVideoTimeCodeInterval * tc_inter)
 905 {
 906   GstVideoTimeCode *ret;
 907   guint frames_to_add;
 908   guint df;
 909   gboolean needs_correction;
 910 
 911   g_return_val_if_fail (gst_video_time_code_is_valid (tc), NULL);
 912 
 913   ret = gst_video_time_code_new (tc-&gt;config.fps_n, tc-&gt;config.fps_d,
 914       tc-&gt;config.latest_daily_jam, tc-&gt;config.flags, tc_inter-&gt;hours,
 915       tc_inter-&gt;minutes, tc_inter-&gt;seconds, tc_inter-&gt;frames, 0);
 916 
 917   df = (tc-&gt;config.fps_n + (tc-&gt;config.fps_d &gt;&gt; 1)) / (tc-&gt;config.fps_d * 15);
 918 
</pre>
<hr />
<pre>
 968  *
 969  * Since: 1.12
 970  */
 971 GstVideoTimeCodeInterval *
 972 gst_video_time_code_interval_new (guint hours, guint minutes, guint seconds,
 973     guint frames)
 974 {
 975   GstVideoTimeCodeInterval *tc;
 976 
 977   tc = g_new0 (GstVideoTimeCodeInterval, 1);
 978   gst_video_time_code_interval_init (tc, hours, minutes, seconds, frames);
 979   return tc;
 980 }
 981 
 982 /**
 983  * gst_video_time_code_interval_new_from_string:
 984  * @tc_inter_str: The string that represents the #GstVideoTimeCodeInterval
 985  *
 986  * @tc_inter_str must only have &quot;:&quot; as separators.
 987  *
<span class="line-modified"> 988  * Returns: (nullable): a new #GstVideoTimeCodeInterval from the given string</span>
<span class="line-added"> 989  *   or %NULL if the string could not be passed.</span>
 990  *
 991  * Since: 1.12
 992  */
 993 GstVideoTimeCodeInterval *
 994 gst_video_time_code_interval_new_from_string (const gchar * tc_inter_str)
 995 {
 996   GstVideoTimeCodeInterval *tc;
 997   guint hours, minutes, seconds, frames;
 998 
 999   if (sscanf (tc_inter_str, &quot;%02u:%02u:%02u:%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
1000           &amp;frames)
1001       == 4
1002       || sscanf (tc_inter_str, &quot;%02u:%02u:%02u;%02u&quot;, &amp;hours, &amp;minutes,
1003           &amp;seconds, &amp;frames)
1004       == 4
1005       || sscanf (tc_inter_str, &quot;%02u:%02u:%02u.%02u&quot;, &amp;hours, &amp;minutes,
1006           &amp;seconds, &amp;frames)
1007       == 4
1008       || sscanf (tc_inter_str, &quot;%02u:%02u:%02u,%02u&quot;, &amp;hours, &amp;minutes,
1009           &amp;seconds, &amp;frames)
</pre>
<hr />
<pre>
1045  * gst_video_time_code_interval_clear:
1046  * @tc: a #GstVideoTimeCodeInterval
1047  *
1048  * Initializes @tc with empty/zero/NULL values.
1049  *
1050  * Since: 1.12
1051  */
1052 void
1053 gst_video_time_code_interval_clear (GstVideoTimeCodeInterval * tc)
1054 {
1055   tc-&gt;hours = 0;
1056   tc-&gt;minutes = 0;
1057   tc-&gt;seconds = 0;
1058   tc-&gt;frames = 0;
1059 }
1060 
1061 /**
1062  * gst_video_time_code_interval_copy:
1063  * @tc: a #GstVideoTimeCodeInterval
1064  *
<span class="line-modified">1065  * Returns: a new #GstVideoTimeCodeInterval with the same values as @tc.</span>
1066  *
1067  * Since: 1.12
1068  */
1069 GstVideoTimeCodeInterval *
1070 gst_video_time_code_interval_copy (const GstVideoTimeCodeInterval * tc)
1071 {
1072   return gst_video_time_code_interval_new (tc-&gt;hours, tc-&gt;minutes,
1073       tc-&gt;seconds, tc-&gt;frames);
1074 }
1075 
1076 /**
1077  * gst_video_time_code_interval_free:
1078  * @tc: a #GstVideoTimeCodeInterval
1079  *
<span class="line-modified">1080  * Frees @tc.</span>
1081  *
1082  * Since: 1.12
1083  */
1084 void
1085 gst_video_time_code_interval_free (GstVideoTimeCodeInterval * tc)
1086 {
1087   g_free (tc);
1088 }
</pre>
</td>
</tr>
</table>
<center><a href="gstvideosink.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstvideotimecode.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>