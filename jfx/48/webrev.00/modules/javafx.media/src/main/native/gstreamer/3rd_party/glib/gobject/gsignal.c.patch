diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.c
@@ -124,11 +124,11 @@
  * effective memory leaks of the user data if the signal handler is never
  * disconnected for some reason.
  */
 
 
-#define REPORT_BUG      "please report occurrence circumstances to gtk-devel-list@gnome.org"
+#define REPORT_BUG      "please report occurrence circumstances to https://gitlab.gnome.org/GNOME/glib/issues/new"
 
 /* --- typedefs --- */
 typedef struct _SignalNode   SignalNode;
 typedef struct _SignalKey    SignalKey;
 typedef struct _Emission     Emission;
@@ -143,66 +143,66 @@
   EMISSION_RESTART
 } EmissionState;
 
 
 /* --- prototypes --- */
-static inline guint     signal_id_lookup    (GQuark       quark,
-                             GType        itype);
-static        void      signal_destroy_R    (SignalNode  *signal_node);
-static inline HandlerList*  handler_list_ensure (guint        signal_id,
-                             gpointer     instance);
-static inline HandlerList*  handler_list_lookup (guint        signal_id,
-                             gpointer     instance);
-static inline Handler*      handler_new     (guint            signal_id,
-                             gpointer         instance,
-                                                         gboolean     after);
-static        void      handler_insert      (guint        signal_id,
-                             gpointer     instance,
-                             Handler     *handler);
-static        Handler*      handler_lookup      (gpointer     instance,
-                             gulong       handler_id,
-                             GClosure        *closure,
-                             guint       *signal_id_p);
-static inline HandlerMatch* handler_match_prepend   (HandlerMatch    *list,
-                             Handler     *handler,
-                             guint        signal_id);
-static inline HandlerMatch* handler_match_free1_R   (HandlerMatch    *node,
-                             gpointer     instance);
-static        HandlerMatch* handlers_find       (gpointer     instance,
-                             GSignalMatchType mask,
-                             guint        signal_id,
-                             GQuark       detail,
-                             GClosure    *closure,
-                             gpointer     func,
-                             gpointer     data,
-                             gboolean     one_and_only);
-static inline void      handler_ref     (Handler     *handler);
-static inline void      handler_unref_R     (guint        signal_id,
-                             gpointer     instance,
-                             Handler     *handler);
-static gint         handler_lists_cmp   (gconstpointer    node1,
-                             gconstpointer    node2);
-static inline void      emission_push       (Emission    *emission);
-static inline void      emission_pop        (Emission    *emission);
-static inline Emission*     emission_find       (guint        signal_id,
-                             GQuark       detail,
-                             gpointer     instance);
-static gint         class_closures_cmp  (gconstpointer    node1,
-                             gconstpointer    node2);
-static gint         signal_key_cmp      (gconstpointer    node1,
-                             gconstpointer    node2);
-static        gboolean      signal_emit_unlocked_R  (SignalNode  *node,
-                             GQuark       detail,
-                             gpointer     instance,
-                             GValue      *return_value,
-                             const GValue    *instance_and_params);
+static inline guint   signal_id_lookup  (GQuark     quark,
+               GType      itype);
+static        void    signal_destroy_R  (SignalNode  *signal_node);
+static inline HandlerList*  handler_list_ensure (guint      signal_id,
+               gpointer   instance);
+static inline HandlerList*  handler_list_lookup (guint      signal_id,
+               gpointer   instance);
+static inline Handler*    handler_new   (guint            signal_id,
+               gpointer         instance,
+                                                         gboolean   after);
+static        void    handler_insert    (guint      signal_id,
+               gpointer   instance,
+               Handler   *handler);
+static        Handler*    handler_lookup    (gpointer   instance,
+               gulong     handler_id,
+               GClosure        *closure,
+               guint     *signal_id_p);
+static inline HandlerMatch* handler_match_prepend (HandlerMatch  *list,
+               Handler   *handler,
+               guint      signal_id);
+static inline HandlerMatch* handler_match_free1_R (HandlerMatch  *node,
+               gpointer   instance);
+static        HandlerMatch* handlers_find   (gpointer   instance,
+               GSignalMatchType mask,
+               guint      signal_id,
+               GQuark     detail,
+               GClosure  *closure,
+               gpointer   func,
+               gpointer   data,
+               gboolean   one_and_only);
+static inline void    handler_ref   (Handler   *handler);
+static inline void    handler_unref_R   (guint      signal_id,
+               gpointer   instance,
+               Handler   *handler);
+static gint     handler_lists_cmp (gconstpointer    node1,
+               gconstpointer    node2);
+static inline void    emission_push   (Emission  *emission);
+static inline void    emission_pop    (Emission  *emission);
+static inline Emission*   emission_find   (guint      signal_id,
+               GQuark     detail,
+               gpointer   instance);
+static gint     class_closures_cmp  (gconstpointer    node1,
+               gconstpointer    node2);
+static gint     signal_key_cmp    (gconstpointer    node1,
+               gconstpointer    node2);
+static        gboolean    signal_emit_unlocked_R  (SignalNode  *node,
+               GQuark     detail,
+               gpointer   instance,
+               GValue    *return_value,
+               const GValue  *instance_and_params);
 static       void               add_invalid_closure_notify    (Handler         *handler,
-                                   gpointer         instance);
+                     gpointer         instance);
 static       void               remove_invalid_closure_notify (Handler         *handler,
-                                   gpointer         instance);
+                     gpointer         instance);
 static       void               invalid_closure_notify  (gpointer         data,
-                             GClosure        *closure);
+               GClosure        *closure);
 static const gchar *            type_debug_name         (GType            type);
 static void                     node_check_deprecated   (const SignalNode *node);
 static void                     node_update_single_va_closure (SignalNode *node);
 
 
@@ -215,11 +215,11 @@
 typedef struct
 {
   GHook hook;
   GQuark detail;
 } SignalHook;
-#define SIGNAL_HOOK(hook)   ((SignalHook*) (hook))
+#define SIGNAL_HOOK(hook) ((SignalHook*) (hook))
 
 struct _SignalNode
 {
   /* permanent portion */
   guint              signal_id;
@@ -230,22 +230,22 @@
   /* reinitializable portion */
   guint              flags : 9;
   guint              n_params : 8;
   guint              single_va_closure_is_valid : 1;
   guint              single_va_closure_is_after : 1;
-  GType         *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
-  GType          return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
+  GType       *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
+  GType        return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
   GBSearchArray     *class_closure_bsa;
   SignalAccumulator *accumulator;
   GSignalCMarshaller c_marshaller;
   GSignalCVaMarshaller va_marshaller;
   GHookList         *emission_hooks;
 
   GClosure *single_va_closure;
 };
 
-#define SINGLE_VA_CLOSURE_EMPTY_MAGIC GINT_TO_POINTER(1)    /* indicates single_va_closure is valid but empty */
+#define SINGLE_VA_CLOSURE_EMPTY_MAGIC GINT_TO_POINTER(1)  /* indicates single_va_closure is valid but empty */
 
 struct _SignalKey
 {
   GType  itype;
   GQuark quark;
@@ -256,11 +256,11 @@
 {
   Emission             *next;
   gpointer              instance;
   GSignalInvocationHint ihint;
   EmissionState         state;
-  GType         chain_type;
+  GType     chain_type;
 };
 
 struct _HandlerList
 {
   guint    signal_id;
@@ -272,11 +272,11 @@
 struct _Handler
 {
   gulong        sequential_number;
   Handler      *next;
   Handler      *prev;
-  GQuark    detail;
+  GQuark  detail;
   guint         signal_id;
   guint         ref_count;
   guint         block_count : 16;
 #define HANDLER_MAX_BLOCK_COUNT (1 << 16)
   guint         after : 1;
@@ -319,12 +319,12 @@
 static Emission      *g_emissions = NULL;
 static gulong         g_handler_sequential_number = 1;
 static GHashTable    *g_handlers = NULL;
 
 G_LOCK_DEFINE_STATIC (g_signal_mutex);
-#define SIGNAL_LOCK()       G_LOCK (g_signal_mutex)
-#define SIGNAL_UNLOCK()     G_UNLOCK (g_signal_mutex)
+#define SIGNAL_LOCK()   G_LOCK (g_signal_mutex)
+#define SIGNAL_UNLOCK()   G_UNLOCK (g_signal_mutex)
 
 
 /* --- signal nodes --- */
 static guint          g_n_signal_nodes = 0;
 static SignalNode   **g_signal_nodes = NULL;
@@ -340,11 +340,11 @@
 
 
 /* --- functions --- */
 static inline guint
 signal_id_lookup (GQuark quark,
-          GType  itype)
+      GType  itype)
 {
   GType *ifaces, type = itype;
   SignalKey key;
   guint n_ifaces;
 
@@ -357,11 +357,11 @@
 
       key.itype = type;
       signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &g_signal_key_bconfig, &key);
 
       if (signal_key)
-    return signal_key->signal_id;
+  return signal_key->signal_id;
 
       type = g_type_parent (type);
     }
   while (type);
 
@@ -373,23 +373,23 @@
 
       key.itype = ifaces[n_ifaces];
       signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &g_signal_key_bconfig, &key);
 
       if (signal_key)
-    {
-      g_free (ifaces);
-      return signal_key->signal_id;
-    }
+  {
+    g_free (ifaces);
+    return signal_key->signal_id;
+  }
     }
   g_free (ifaces);
 
   return 0;
 }
 
 static gint
 class_closures_cmp (gconstpointer node1,
-            gconstpointer node2)
+        gconstpointer node2)
 {
   const ClassClosure *c1 = node1, *c2 = node2;
 
   return G_BSEARCH_ARRAY_CMP (c1->instance_type, c2->instance_type);
 }
@@ -403,11 +403,11 @@
   return G_BSEARCH_ARRAY_CMP (hlist1->signal_id, hlist2->signal_id);
 }
 
 static inline HandlerList*
 handler_list_ensure (guint    signal_id,
-             gpointer instance)
+         gpointer instance)
 {
   GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
   HandlerList key;
 
   key.signal_id = signal_id;
@@ -424,18 +424,18 @@
     {
       GBSearchArray *o = hlbsa;
 
       hlbsa = g_bsearch_array_insert (o, &g_signal_hlbsa_bconfig, &key);
       if (hlbsa != o)
-    g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);
+  g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);
     }
   return g_bsearch_array_lookup (hlbsa, &g_signal_hlbsa_bconfig, &key);
 }
 
 static inline HandlerList*
 handler_list_lookup (guint    signal_id,
-             gpointer instance)
+         gpointer instance)
 {
   GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
   HandlerList key;
 
   key.signal_id = signal_id;
@@ -458,13 +458,13 @@
       (ha->instance  == hb->instance);
 }
 
 static Handler*
 handler_lookup (gpointer  instance,
-        gulong    handler_id,
-        GClosure *closure,
-        guint    *signal_id_p)
+    gulong    handler_id,
+    GClosure *closure,
+    guint    *signal_id_p)
 {
   GBSearchArray *hlbsa;
 
   if (handler_id)
     {
@@ -500,12 +500,12 @@
   return NULL;
 }
 
 static inline HandlerMatch*
 handler_match_prepend (HandlerMatch *list,
-                       Handler      *handler,
-               guint         signal_id)
+           Handler      *handler,
+           guint       signal_id)
 {
   HandlerMatch *node;
 
   node = g_slice_new (HandlerMatch);
 #ifdef GSTREAMER_LITE
@@ -520,11 +520,11 @@
 
   return node;
 }
 static inline HandlerMatch*
 handler_match_free1_R (HandlerMatch *node,
-               gpointer      instance)
+           gpointer      instance)
 {
   HandlerMatch *next = node->next;
 
   handler_unref_R (node->signal_id, instance, node->handler);
   g_slice_free (HandlerMatch, node);
@@ -532,48 +532,48 @@
   return next;
 }
 
 static HandlerMatch*
 handlers_find (gpointer         instance,
-           GSignalMatchType mask,
-           guint            signal_id,
-           GQuark           detail,
-           GClosure        *closure,
-           gpointer         func,
-           gpointer         data,
-           gboolean         one_and_only)
+         GSignalMatchType mask,
+         guint            signal_id,
+         GQuark           detail,
+         GClosure        *closure,
+         gpointer         func,
+         gpointer         data,
+         gboolean         one_and_only)
 {
   HandlerMatch *mlist = NULL;
 
   if (mask & G_SIGNAL_MATCH_ID)
     {
       HandlerList *hlist = handler_list_lookup (signal_id, instance);
       Handler *handler;
       SignalNode *node = NULL;
 
       if (mask & G_SIGNAL_MATCH_FUNC)
-    {
-      node = LOOKUP_SIGNAL_NODE (signal_id);
-      if (!node || !node->c_marshaller)
-        return NULL;
-    }
+  {
+    node = LOOKUP_SIGNAL_NODE (signal_id);
+    if (!node || !node->c_marshaller)
+      return NULL;
+  }
 
       mask = ~mask;
       for (handler = hlist ? hlist->handlers : NULL; handler; handler = handler->next)
         if (handler->sequential_number &&
-        ((mask & G_SIGNAL_MATCH_DETAIL) || handler->detail == detail) &&
-        ((mask & G_SIGNAL_MATCH_CLOSURE) || handler->closure == closure) &&
+      ((mask & G_SIGNAL_MATCH_DETAIL) || handler->detail == detail) &&
+      ((mask & G_SIGNAL_MATCH_CLOSURE) || handler->closure == closure) &&
             ((mask & G_SIGNAL_MATCH_DATA) || handler->closure->data == data) &&
-        ((mask & G_SIGNAL_MATCH_UNBLOCKED) || handler->block_count == 0) &&
-        ((mask & G_SIGNAL_MATCH_FUNC) || (handler->closure->marshal == node->c_marshaller &&
-                          G_REAL_CLOSURE (handler->closure)->meta_marshal == NULL &&
-                          ((GCClosure*) handler->closure)->callback == func)))
-      {
-        mlist = handler_match_prepend (mlist, handler, signal_id);
-        if (one_and_only)
-          return mlist;
-      }
+      ((mask & G_SIGNAL_MATCH_UNBLOCKED) || handler->block_count == 0) &&
+      ((mask & G_SIGNAL_MATCH_FUNC) || (handler->closure->marshal == node->c_marshaller &&
+                G_REAL_CLOSURE (handler->closure)->meta_marshal == NULL &&
+                ((GCClosure*) handler->closure)->callback == func)))
+    {
+      mlist = handler_match_prepend (mlist, handler, signal_id);
+      if (one_and_only)
+        return mlist;
+    }
     }
   else
     {
       GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
 
@@ -583,38 +583,38 @@
           guint i;
 
           for (i = 0; i < hlbsa->n_nodes; i++)
             {
               HandlerList *hlist = g_bsearch_array_get_nth (hlbsa, &g_signal_hlbsa_bconfig, i);
-          SignalNode *node = NULL;
+        SignalNode *node = NULL;
               Handler *handler;
 
-          if (!(mask & G_SIGNAL_MATCH_FUNC))
-        {
-          node = LOOKUP_SIGNAL_NODE (hlist->signal_id);
+        if (!(mask & G_SIGNAL_MATCH_FUNC))
+    {
+      node = LOOKUP_SIGNAL_NODE (hlist->signal_id);
 #ifndef GSTREAMER_LITE
-          if (!node->c_marshaller)
+      if (!node->c_marshaller)
 #else // GSTREAMER_LITE
           if (!node || !node->c_marshaller)
 #endif // GSTREAMER_LITE
-            continue;
-        }
+        continue;
+    }
 
               for (handler = hlist->handlers; handler; handler = handler->next)
-        if (handler->sequential_number &&
-            ((mask & G_SIGNAL_MATCH_DETAIL) || handler->detail == detail) &&
+    if (handler->sequential_number &&
+        ((mask & G_SIGNAL_MATCH_DETAIL) || handler->detail == detail) &&
                     ((mask & G_SIGNAL_MATCH_CLOSURE) || handler->closure == closure) &&
                     ((mask & G_SIGNAL_MATCH_DATA) || handler->closure->data == data) &&
-            ((mask & G_SIGNAL_MATCH_UNBLOCKED) || handler->block_count == 0) &&
-            ((mask & G_SIGNAL_MATCH_FUNC) || (handler->closure->marshal == node->c_marshaller &&
-                              G_REAL_CLOSURE (handler->closure)->meta_marshal == NULL &&
-                              ((GCClosure*) handler->closure)->callback == func)))
-          {
-            mlist = handler_match_prepend (mlist, handler, hlist->signal_id);
-            if (one_and_only)
-              return mlist;
-          }
+        ((mask & G_SIGNAL_MATCH_UNBLOCKED) || handler->block_count == 0) &&
+        ((mask & G_SIGNAL_MATCH_FUNC) || (handler->closure->marshal == node->c_marshaller &&
+                  G_REAL_CLOSURE (handler->closure)->meta_marshal == NULL &&
+                  ((GCClosure*) handler->closure)->callback == func)))
+      {
+        mlist = handler_match_prepend (mlist, handler, hlist->signal_id);
+        if (one_and_only)
+          return mlist;
+      }
             }
         }
     }
 
   return mlist;
@@ -654,12 +654,12 @@
   handler->ref_count++;
 }
 
 static inline void
 handler_unref_R (guint    signal_id,
-         gpointer instance,
-         Handler *handler)
+     gpointer instance,
+     Handler *handler)
 {
   g_return_if_fail (handler->ref_count > 0);
 
   handler->ref_count--;
 
@@ -712,12 +712,12 @@
     }
 }
 
 static void
 handler_insert (guint    signal_id,
-        gpointer instance,
-        Handler  *handler)
+    gpointer instance,
+    Handler  *handler)
 {
   HandlerList *hlist;
 
   g_assert (handler->prev == NULL && handler->next == NULL); /* paranoid */
 
@@ -771,28 +771,28 @@
       GSignalFlags run_type;
       ClassClosure * cc;
       GBSearchArray *bsa = node->class_closure_bsa;
 
       if (bsa == NULL || bsa->n_nodes == 0)
-    closure = SINGLE_VA_CLOSURE_EMPTY_MAGIC;
+  closure = SINGLE_VA_CLOSURE_EMPTY_MAGIC;
       else if (bsa->n_nodes == 1)
+  {
+    /* Look for default class closure (can't support non-default as it
+       chains up using GValues */
+    cc = g_bsearch_array_get_nth (bsa, &g_class_closure_bconfig, 0);
+    if (cc->instance_type == 0)
+      {
+        run_type = node->flags & (G_SIGNAL_RUN_FIRST|G_SIGNAL_RUN_LAST|G_SIGNAL_RUN_CLEANUP);
+        /* Only support *one* of run-first or run-last, not multiple or cleanup */
+        if (run_type == G_SIGNAL_RUN_FIRST ||
+      run_type == G_SIGNAL_RUN_LAST)
     {
-      /* Look for default class closure (can't support non-default as it
-         chains up using GValues */
-      cc = g_bsearch_array_get_nth (bsa, &g_class_closure_bconfig, 0);
-      if (cc->instance_type == 0)
-        {
-          run_type = node->flags & (G_SIGNAL_RUN_FIRST|G_SIGNAL_RUN_LAST|G_SIGNAL_RUN_CLEANUP);
-          /* Only support *one* of run-first or run-last, not multiple or cleanup */
-          if (run_type == G_SIGNAL_RUN_FIRST ||
-          run_type == G_SIGNAL_RUN_LAST)
-        {
-          closure = cc->closure;
-          is_after = (run_type == G_SIGNAL_RUN_LAST);
-        }
-        }
+      closure = cc->closure;
+      is_after = (run_type == G_SIGNAL_RUN_LAST);
     }
+      }
+  }
     }
 
   node->single_va_closure_is_valid = TRUE;
   node->single_va_closure = closure;
   node->single_va_closure_is_after = is_after;
@@ -811,30 +811,30 @@
   Emission *node, *last = NULL;
 
   for (node = g_emissions; node; last = node, node = last->next)
     if (node == emission)
       {
-    if (last)
-      last->next = node->next;
-    else
-      g_emissions = node->next;
-    return;
+  if (last)
+    last->next = node->next;
+  else
+    g_emissions = node->next;
+  return;
       }
   g_assert_not_reached ();
 }
 
 static inline Emission*
 emission_find (guint     signal_id,
-           GQuark    detail,
-           gpointer  instance)
+         GQuark    detail,
+         gpointer  instance)
 {
   Emission *emission;
 
   for (emission = g_emissions; emission; emission = emission->next)
     if (emission->instance == instance &&
-    emission->ihint.signal_id == signal_id &&
-    emission->ihint.detail == detail)
+  emission->ihint.signal_id == signal_id &&
+  emission->ihint.detail == detail)
       return emission;
   return NULL;
 }
 
 static inline Emission*
@@ -845,11 +845,11 @@
   for (emission = g_emissions; emission; emission = emission->next)
     if (emission->instance == instance)
       return emission;
 
   return NULL;
-      }
+}
 
 static gint
 signal_key_cmp (gconstpointer node1,
                 gconstpointer node2)
 {
@@ -895,11 +895,11 @@
           if (node->destroyed)
             g_warning (G_STRLOC ": signal \"%s\" of type '%s' already destroyed",
                        node->name,
                        type_debug_name (node->itype));
           else
-        signal_destroy_R (node);
+      signal_destroy_R (node);
         }
     }
   SIGNAL_UNLOCK ();
 }
 
@@ -918,11 +918,11 @@
  * Prints a warning if used on a signal which isn't being emitted.
  */
 void
 g_signal_stop_emission (gpointer instance,
                         guint    signal_id,
-            GQuark   detail)
+      GQuark   detail)
 {
   SignalNode *node;
 
   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
   g_return_if_fail (signal_id > 0);
@@ -956,11 +956,11 @@
   SIGNAL_UNLOCK ();
 }
 
 static void
 signal_finalize_hook (GHookList *hook_list,
-              GHook     *hook)
+          GHook     *hook)
 {
   GDestroyNotify destroy = hook->destroy;
 
   if (destroy)
     {
@@ -985,14 +985,14 @@
  *
  * Returns: the hook id, for later use with g_signal_remove_emission_hook().
  */
 gulong
 g_signal_add_emission_hook (guint               signal_id,
-                GQuark              detail,
-                GSignalEmissionHook hook_func,
-                gpointer            hook_data,
-                GDestroyNotify      data_destroy)
+          GQuark              detail,
+          GSignalEmissionHook hook_func,
+          gpointer            hook_data,
+          GDestroyNotify      data_destroy)
 {
   static gulong seq_hook_id = 1;
   SignalNode *node;
   GHook *hook;
   SignalHook *signal_hook;
@@ -1053,11 +1053,11 @@
  *
  * Deletes an emission hook.
  */
 void
 g_signal_remove_emission_hook (guint  signal_id,
-                   gulong hook_id)
+             gulong hook_id)
 {
   SignalNode *node;
 
   g_return_if_fail (signal_id > 0);
   g_return_if_fail (hook_id > 0);
@@ -1078,46 +1078,46 @@
   SIGNAL_UNLOCK ();
 }
 
 static inline guint
 signal_parse_name (const gchar *name,
-           GType        itype,
-           GQuark      *detail_p,
-           gboolean     force_quark)
+       GType        itype,
+       GQuark      *detail_p,
+       gboolean     force_quark)
 {
   const gchar *colon = strchr (name, ':');
   guint signal_id;
 
   if (!colon)
     {
       signal_id = signal_id_lookup (g_quark_try_string (name), itype);
       if (signal_id && detail_p)
-    *detail_p = 0;
+  *detail_p = 0;
     }
   else if (colon[1] == ':')
     {
       gchar buffer[32];
       guint l = colon - name;
 
       if (l < 32)
-    {
-      memcpy (buffer, name, l);
-      buffer[l] = 0;
-      signal_id = signal_id_lookup (g_quark_try_string (buffer), itype);
-    }
+  {
+    memcpy (buffer, name, l);
+    buffer[l] = 0;
+    signal_id = signal_id_lookup (g_quark_try_string (buffer), itype);
+  }
       else
-    {
-      gchar *signal = g_new (gchar, l + 1);
+  {
+    gchar *signal = g_new (gchar, l + 1);
 
-      memcpy (signal, name, l);
-      signal[l] = 0;
-      signal_id = signal_id_lookup (g_quark_try_string (signal), itype);
-      g_free (signal);
-    }
+    memcpy (signal, name, l);
+    signal[l] = 0;
+    signal_id = signal_id_lookup (g_quark_try_string (signal), itype);
+    g_free (signal);
+  }
 
       if (signal_id && detail_p)
-    *detail_p = colon[2] ? (force_quark ? g_quark_from_string : g_quark_try_string) (colon + 2) : 0;
+  *detail_p = colon[2] ? (force_quark ? g_quark_from_string : g_quark_try_string) (colon + 2) : 0;
     }
   else
     signal_id = 0;
   return signal_id;
 }
@@ -1135,14 +1135,14 @@
  *
  * Returns: Whether the signal name could successfully be parsed and @signal_id_p and @detail_p contain valid return values.
  */
 gboolean
 g_signal_parse_name (const gchar *detailed_signal,
-                     GType        itype,
-                     guint       *signal_id_p,
-                     GQuark      *detail_p,
-             gboolean     force_detail_quark)
+         GType        itype,
+         guint       *signal_id_p,
+         GQuark      *detail_p,
+         gboolean   force_detail_quark)
 {
   SignalNode *node;
   GQuark detail = 0;
   guint signal_id;
 
@@ -1176,11 +1176,11 @@
  * This is just like g_signal_stop_emission() except it will look up the
  * signal id for you.
  */
 void
 g_signal_stop_emission_by_name (gpointer     instance,
-                const gchar *detailed_signal)
+        const gchar *detailed_signal)
 {
   guint signal_id;
   GQuark detail = 0;
   GType itype;
 
@@ -1193,30 +1193,30 @@
   if (signal_id)
     {
       SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
 
       if (detail && !(node->flags & G_SIGNAL_DETAILED))
-    g_warning ("%s: signal '%s' does not support details", G_STRLOC, detailed_signal);
+  g_warning ("%s: signal '%s' does not support details", G_STRLOC, detailed_signal);
       else if (!g_type_is_a (itype, node->itype))
         g_warning ("%s: signal '%s' is invalid for instance '%p' of type '%s'",
                    G_STRLOC, detailed_signal, instance, g_type_name (itype));
       else
-    {
-      Emission *emission = emission_find (signal_id, detail, instance);
+  {
+    Emission *emission = emission_find (signal_id, detail, instance);
 
-      if (emission)
-        {
-          if (emission->state == EMISSION_HOOK)
-        g_warning (G_STRLOC ": emission of signal \"%s\" for instance '%p' cannot be stopped from emission hook",
-               node->name, instance);
-          else if (emission->state == EMISSION_RUN)
-        emission->state = EMISSION_STOP;
-        }
-      else
-        g_warning (G_STRLOC ": no emission of signal \"%s\" to stop for instance '%p'",
-               node->name, instance);
-    }
+    if (emission)
+      {
+        if (emission->state == EMISSION_HOOK)
+    g_warning (G_STRLOC ": emission of signal \"%s\" for instance '%p' cannot be stopped from emission hook",
+         node->name, instance);
+        else if (emission->state == EMISSION_RUN)
+    emission->state = EMISSION_STOP;
+      }
+    else
+      g_warning (G_STRLOC ": no emission of signal \"%s\" to stop for instance '%p'",
+           node->name, instance);
+  }
     }
   else
     g_warning ("%s: signal '%s' is invalid for instance '%p' of type '%s'",
                G_STRLOC, detailed_signal, instance, g_type_name (itype));
   SIGNAL_UNLOCK ();
@@ -1250,18 +1250,18 @@
   SIGNAL_UNLOCK ();
   if (!signal_id)
     {
       /* give elaborate warnings */
       if (!g_type_name (itype))
-    g_warning (G_STRLOC ": unable to lookup signal \"%s\" for invalid type id '%"G_GSIZE_FORMAT"'",
-           name, itype);
+  g_warning (G_STRLOC ": unable to look up signal \"%s\" for invalid type id '%"G_GSIZE_FORMAT"'",
+       name, itype);
       else if (!G_TYPE_IS_INSTANTIATABLE (itype))
-    g_warning (G_STRLOC ": unable to lookup signal \"%s\" for non instantiatable type '%s'",
-           name, g_type_name (itype));
+  g_warning (G_STRLOC ": unable to look up signal \"%s\" for non instantiatable type '%s'",
+       name, g_type_name (itype));
       else if (!g_type_class_peek (itype))
-    g_warning (G_STRLOC ": unable to lookup signal \"%s\" of unloaded type '%s'",
-           name, g_type_name (itype));
+  g_warning (G_STRLOC ": unable to look up signal \"%s\" of unloaded type '%s'",
+       name, g_type_name (itype));
     }
 
   return signal_id;
 }
 
@@ -1276,11 +1276,11 @@
  *
  * Returns: (array length=n_ids) (transfer full): Newly allocated array of signal IDs.
  */
 guint*
 g_signal_list_ids (GType  itype,
-           guint *n_ids)
+       guint *n_ids)
 {
   SignalKey *keys;
   GArray *result;
   guint n_nodes;
   guint i;
@@ -1300,32 +1300,32 @@
 #endif // GSTREAMER_LITE
 
   for (i = 0; i < n_nodes; i++)
     if (keys[i].itype == itype)
       {
-    const gchar *name = g_quark_to_string (keys[i].quark);
+  const gchar *name = g_quark_to_string (keys[i].quark);
 
-    /* Signal names with "_" in them are aliases to the same
-     * name with "-" instead of "_".
-     */
-    if (!strchr (name, '_'))
-      g_array_append_val (result, keys[i].signal_id);
+  /* Signal names with "_" in them are aliases to the same
+   * name with "-" instead of "_".
+   */
+  if (!strchr (name, '_'))
+    g_array_append_val (result, keys[i].signal_id);
       }
   *n_ids = result->len;
   SIGNAL_UNLOCK ();
   if (!n_nodes)
     {
       /* give elaborate warnings */
       if (!g_type_name (itype))
-    g_warning (G_STRLOC ": unable to list signals for invalid type id '%"G_GSIZE_FORMAT"'",
-           itype);
+  g_warning (G_STRLOC ": unable to list signals for invalid type id '%"G_GSIZE_FORMAT"'",
+       itype);
       else if (!G_TYPE_IS_INSTANTIATABLE (itype) && !G_TYPE_IS_INTERFACE (itype))
-    g_warning (G_STRLOC ": unable to list signals of non instantiatable type '%s'",
-           g_type_name (itype));
+  g_warning (G_STRLOC ": unable to list signals of non instantiatable type '%s'",
+       g_type_name (itype));
       else if (!g_type_class_peek (itype) && !G_TYPE_IS_INTERFACE (itype))
-    g_warning (G_STRLOC ": unable to list signals of unloaded type '%s'",
-           g_type_name (itype));
+  g_warning (G_STRLOC ": unable to list signals of unloaded type '%s'",
+       g_type_name (itype));
     }
 
   return (guint*) g_array_free (result, FALSE);
 }
 
@@ -1366,11 +1366,11 @@
  * is 0. All members filled into the #GSignalQuery structure should
  * be considered constant and have to be left untouched.
  */
 void
 g_signal_query (guint         signal_id,
-        GSignalQuery *query)
+    GSignalQuery *query)
 {
   SignalNode *node;
 
   g_return_if_fail (query != NULL);
 
@@ -1423,37 +1423,43 @@
  *
  * If 0 is used for @class_offset subclasses cannot override the class handler
  * in their class_init method by doing super_class->signal_handler = my_signal_handler.
  * Instead they will have to use g_signal_override_class_handler().
  *
- * If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
- * the marshaller for this signal.
+ * If @c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
+ * the marshaller for this signal. In some simple cases, g_signal_new()
+ * will use a more optimized c_marshaller and va_marshaller for the signal
+ * instead of g_cclosure_marshal_generic().
+ *
+ * If @c_marshaller is non-%NULL, you need to also specify a va_marshaller
+ * using g_signal_set_va_marshaller() or the generic va_marshaller will
+ * be used.
  *
  * Returns: the signal id
  */
 guint
-g_signal_new (const gchar    *signal_name,
-          GType       itype,
-          GSignalFlags    signal_flags,
-              guint               class_offset,
-              GSignalAccumulator  accumulator,
-          gpointer        accu_data,
-              GSignalCMarshaller  c_marshaller,
-          GType       return_type,
-          guint       n_params,
-              ...)
+g_signal_new (const gchar  *signal_name,
+        GType     itype,
+        GSignalFlags    signal_flags,
+        guint               class_offset,
+        GSignalAccumulator  accumulator,
+        gpointer      accu_data,
+        GSignalCMarshaller  c_marshaller,
+        GType     return_type,
+        guint     n_params,
+        ...)
 {
   va_list args;
   guint signal_id;
 
   g_return_val_if_fail (signal_name != NULL, 0);
 
   va_start (args, n_params);
 
   signal_id = g_signal_new_valist (signal_name, itype, signal_flags,
                                    class_offset ? g_signal_type_cclosure_new (itype, class_offset) : NULL,
-                   accumulator, accu_data, c_marshaller,
+           accumulator, accu_data, c_marshaller,
                                    return_type, n_params, args);
 
   va_end (args);
 
   return signal_id;
@@ -1529,11 +1535,11 @@
   return signal_id;
 }
 
 static inline ClassClosure*
 signal_find_class_closure (SignalNode *node,
-               GType       itype)
+         GType       itype)
 {
   GBSearchArray *bsa = node->class_closure_bsa;
   ClassClosure *cc;
 
   if (bsa)
@@ -1550,52 +1556,52 @@
         }
 
       key.instance_type = itype;
       cc = g_bsearch_array_lookup (bsa, &g_class_closure_bconfig, &key);
       while (!cc && key.instance_type)
-    {
-      key.instance_type = g_type_parent (key.instance_type);
-      cc = g_bsearch_array_lookup (bsa, &g_class_closure_bconfig, &key);
-    }
+  {
+    key.instance_type = g_type_parent (key.instance_type);
+    cc = g_bsearch_array_lookup (bsa, &g_class_closure_bconfig, &key);
+  }
     }
   else
     cc = NULL;
   return cc;
 }
 
 static inline GClosure*
 signal_lookup_closure (SignalNode    *node,
-               GTypeInstance *instance)
+           GTypeInstance *instance)
 {
   ClassClosure *cc;
 
   cc = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
   return cc ? cc->closure : NULL;
 }
 
 static void
 signal_add_class_closure (SignalNode *node,
-              GType       itype,
-              GClosure   *closure)
+        GType       itype,
+        GClosure   *closure)
 {
   ClassClosure key;
 
   node->single_va_closure_is_valid = FALSE;
 
   if (!node->class_closure_bsa)
     node->class_closure_bsa = g_bsearch_array_create (&g_class_closure_bconfig);
   key.instance_type = itype;
   key.closure = g_closure_ref (closure);
   node->class_closure_bsa = g_bsearch_array_insert (node->class_closure_bsa,
-                            &g_class_closure_bconfig,
-                            &key);
+                &g_class_closure_bconfig,
+                &key);
   g_closure_sink (closure);
   if (node->c_marshaller && closure && G_CLOSURE_NEEDS_MARSHAL (closure))
     {
       g_closure_set_marshal (closure, node->c_marshaller);
       if (node->va_marshaller)
-    _g_closure_set_va_marshal (closure, node->va_marshaller);
+  _g_closure_set_va_marshal (closure, node->va_marshaller);
     }
 }
 
 /**
  * g_signal_newv:
@@ -1631,15 +1637,15 @@
 g_signal_newv (const gchar       *signal_name,
                GType              itype,
                GSignalFlags       signal_flags,
                GClosure          *class_closure,
                GSignalAccumulator accumulator,
-           gpointer       accu_data,
+         gpointer     accu_data,
                GSignalCMarshaller c_marshaller,
-               GType          return_type,
+               GType      return_type,
                guint              n_params,
-               GType         *param_types)
+               GType     *param_types)
 {
   gchar *name;
   guint signal_id, i;
   SignalNode *node;
   GSignalCMarshaller builtin_c_marshaller;
@@ -1684,29 +1690,29 @@
       return 0;
     }
   for (i = 0; i < n_params; i++)
     if (!G_TYPE_IS_VALUE (param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE))
       {
-    g_warning (G_STRLOC ": parameter %d of type '%s' for signal \"%s::%s\" is not a value type",
-           i + 1, type_debug_name (param_types[i]), type_debug_name (itype), name);
-    g_free (name);
-    SIGNAL_UNLOCK ();
-    return 0;
+  g_warning (G_STRLOC ": parameter %d of type '%s' for signal \"%s::%s\" is not a value type",
+       i + 1, type_debug_name (param_types[i]), type_debug_name (itype), name);
+  g_free (name);
+  SIGNAL_UNLOCK ();
+  return 0;
       }
   if (return_type != G_TYPE_NONE && !G_TYPE_IS_VALUE (return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE))
     {
       g_warning (G_STRLOC ": return value of type '%s' for signal \"%s::%s\" is not a value type",
-         type_debug_name (return_type), type_debug_name (itype), name);
+     type_debug_name (return_type), type_debug_name (itype), name);
       g_free (name);
       SIGNAL_UNLOCK ();
       return 0;
     }
   if (return_type != G_TYPE_NONE &&
       (signal_flags & (G_SIGNAL_RUN_FIRST | G_SIGNAL_RUN_LAST | G_SIGNAL_RUN_CLEANUP)) == G_SIGNAL_RUN_FIRST)
     {
       g_warning (G_STRLOC ": signal \"%s::%s\" has return type '%s' and is only G_SIGNAL_RUN_FIRST",
-         type_debug_name (itype), name, type_debug_name (return_type));
+     type_debug_name (itype), name, type_debug_name (return_type));
       g_free (name);
       SIGNAL_UNLOCK ();
       return 0;
     }
 
@@ -1763,14 +1769,14 @@
     }
   else if (n_params == 1 && return_type == G_TYPE_NONE)
     {
 #define ADD_CHECK(__type__) \
       else if (g_type_is_a (param_types[0] & ~G_SIGNAL_TYPE_STATIC_SCOPE, G_TYPE_ ##__type__))         \
-    {                                                                \
-      builtin_c_marshaller = g_cclosure_marshal_VOID__ ## __type__;  \
-      builtin_va_marshaller = g_cclosure_marshal_VOID__ ## __type__ ##v;     \
-    }
+  {                                                                \
+    builtin_c_marshaller = g_cclosure_marshal_VOID__ ## __type__;  \
+    builtin_va_marshaller = g_cclosure_marshal_VOID__ ## __type__ ##v;     \
+  }
 
       if (0) {}
       ADD_CHECK (BOOLEAN)
       ADD_CHECK (CHAR)
       ADD_CHECK (UCHAR)
@@ -1796,14 +1802,14 @@
         {
     c_marshaller = builtin_c_marshaller;
           va_marshaller = builtin_va_marshaller;
         }
       else
-    {
-      c_marshaller = g_cclosure_marshal_generic;
-      va_marshaller = g_cclosure_marshal_generic_va;
-    }
+  {
+    c_marshaller = g_cclosure_marshal_generic;
+    va_marshaller = g_cclosure_marshal_generic_va;
+  }
     }
   else
     va_marshaller = NULL;
 
   node->c_marshaller = c_marshaller;
@@ -1832,12 +1838,12 @@
  *
  * Since: 2.32
  */
 void
 g_signal_set_va_marshaller (guint              signal_id,
-                GType              instance_type,
-                GSignalCVaMarshaller va_marshaller)
+          GType              instance_type,
+          GSignalCVaMarshaller va_marshaller)
 {
   SignalNode *node;
 
   g_return_if_fail (signal_id > 0);
   g_return_if_fail (va_marshaller != NULL);
@@ -1846,15 +1852,15 @@
   node = LOOKUP_SIGNAL_NODE (signal_id);
   if (node)
     {
       node->va_marshaller = va_marshaller;
       if (node->class_closure_bsa)
-    {
-      ClassClosure *cc = g_bsearch_array_get_nth (node->class_closure_bsa, &g_class_closure_bconfig, 0);
-      if (cc->closure->marshal == node->c_marshaller)
-        _g_closure_set_va_marshal (cc->closure, va_marshaller);
-    }
+  {
+    ClassClosure *cc = g_bsearch_array_get_nth (node->class_closure_bsa, &g_class_closure_bconfig, 0);
+    if (cc->closure->marshal == node->c_marshaller)
+      _g_closure_set_va_marshal (cc->closure, va_marshaller);
+  }
 
       node->single_va_closure_is_valid = FALSE;
     }
 
   SIGNAL_UNLOCK ();
@@ -1892,11 +1898,11 @@
 g_signal_new_valist (const gchar       *signal_name,
                      GType              itype,
                      GSignalFlags       signal_flags,
                      GClosure          *class_closure,
                      GSignalAccumulator accumulator,
-             gpointer       accu_data,
+         gpointer   accu_data,
                      GSignalCMarshaller c_marshaller,
                      GType              return_type,
                      guint              n_params,
                      va_list            args)
 {
@@ -1907,18 +1913,18 @@
   if (n_params > 0)
     {
       param_types = g_new (GType, n_params);
 
       for (i = 0; i < n_params; i++)
-    param_types[i] = va_arg (args, GType);
+  param_types[i] = va_arg (args, GType);
     }
   else
     param_types = NULL;
 
   signal_id = g_signal_newv (signal_name, itype, signal_flags,
-                 class_closure, accumulator, accu_data, c_marshaller,
-                 return_type, n_params, param_types);
+           class_closure, accumulator, accu_data, c_marshaller,
+           return_type, n_params, param_types);
   g_free (param_types);
 
   return signal_id;
 }
 
@@ -1959,15 +1965,15 @@
   if (node.class_closure_bsa)
     {
       guint i;
 
       for (i = 0; i < node.class_closure_bsa->n_nodes; i++)
-    {
-      ClassClosure *cc = g_bsearch_array_get_nth (node.class_closure_bsa, &g_class_closure_bconfig, i);
+  {
+    ClassClosure *cc = g_bsearch_array_get_nth (node.class_closure_bsa, &g_class_closure_bconfig, i);
 
-      g_closure_unref (cc->closure);
-    }
+    g_closure_unref (cc->closure);
+  }
       g_bsearch_array_free (node.class_closure_bsa, &g_class_closure_bconfig);
     }
   g_free (node.accumulator);
   if (node.emission_hooks)
     {
@@ -1992,12 +1998,12 @@
  * g_signal_chain_from_overridden_handler() for how to chain up to the
  * parent class closure from inside the overridden one.
  */
 void
 g_signal_override_class_closure (guint     signal_id,
-                 GType     instance_type,
-                 GClosure *class_closure)
+         GType     instance_type,
+         GClosure *class_closure)
 {
   SignalNode *node;
 
   g_return_if_fail (signal_id > 0);
   g_return_if_fail (class_closure != NULL);
@@ -2014,13 +2020,13 @@
   else
     {
       ClassClosure *cc = signal_find_class_closure (node, instance_type);
 
       if (cc && cc->instance_type == instance_type)
-    g_warning ("%s: type '%s' is already overridden for signal id '%u'", G_STRLOC, type_debug_name (instance_type), signal_id);
+  g_warning ("%s: type '%s' is already overridden for signal id '%u'", G_STRLOC, type_debug_name (instance_type), signal_id);
       else
-    signal_add_class_closure (node, instance_type, class_closure);
+  signal_add_class_closure (node, instance_type, class_closure);
     }
   SIGNAL_UNLOCK ();
 }
 
 /**
@@ -2041,12 +2047,12 @@
  *
  * Since: 2.18
  */
 void
 g_signal_override_class_handler (const gchar *signal_name,
-                 GType        instance_type,
-                 GCallback    class_handler)
+         GType        instance_type,
+         GCallback    class_handler)
 {
   guint signal_id;
 
   g_return_if_fail (signal_name != NULL);
   g_return_if_fail (instance_type != G_TYPE_NONE);
@@ -2075,11 +2081,11 @@
  * g_signal_override_class_closure() and
  * g_signal_override_class_handler().
  */
 void
 g_signal_chain_from_overridden (const GValue *instance_and_params,
-                GValue       *return_value)
+        GValue       *return_value)
 {
   GType chain_type = 0, restore_type = 0;
   Emission *emission = NULL;
   GClosure *closure = NULL;
   guint n_params = 0;
@@ -2098,39 +2104,39 @@
       g_assert (node != NULL);  /* paranoid */
 
       /* we should probably do the same parameter checks as g_signal_emit() here.
        */
       if (emission->chain_type != G_TYPE_NONE)
-    {
-      ClassClosure *cc = signal_find_class_closure (node, emission->chain_type);
+  {
+    ClassClosure *cc = signal_find_class_closure (node, emission->chain_type);
 
-      g_assert (cc != NULL);    /* closure currently in call stack */
+    g_assert (cc != NULL);  /* closure currently in call stack */
 
-      n_params = node->n_params;
-      restore_type = cc->instance_type;
-      cc = signal_find_class_closure (node, g_type_parent (cc->instance_type));
-      if (cc && cc->instance_type != restore_type)
-        {
-          closure = cc->closure;
-          chain_type = cc->instance_type;
-        }
-    }
+    n_params = node->n_params;
+    restore_type = cc->instance_type;
+    cc = signal_find_class_closure (node, g_type_parent (cc->instance_type));
+    if (cc && cc->instance_type != restore_type)
+      {
+        closure = cc->closure;
+        chain_type = cc->instance_type;
+      }
+  }
       else
-    g_warning ("%s: signal id '%u' cannot be chained from current emission stage for instance '%p'", G_STRLOC, node->signal_id, instance);
+  g_warning ("%s: signal id '%u' cannot be chained from current emission stage for instance '%p'", G_STRLOC, node->signal_id, instance);
     }
   else
     g_warning ("%s: no signal is currently being emitted for instance '%p'", G_STRLOC, instance);
 
   if (closure)
     {
       emission->chain_type = chain_type;
       SIGNAL_UNLOCK ();
       g_closure_invoke (closure,
-            return_value,
-            n_params + 1,
-            instance_and_params,
-            &emission->ihint);
+      return_value,
+      n_params + 1,
+      instance_and_params,
+      &emission->ihint);
       SIGNAL_LOCK ();
       emission->chain_type = restore_type;
     }
   SIGNAL_UNLOCK ();
 }
@@ -2171,26 +2177,26 @@
       g_assert (node != NULL);  /* paranoid */
 
       /* we should probably do the same parameter checks as g_signal_emit() here.
        */
       if (emission->chain_type != G_TYPE_NONE)
-    {
-      ClassClosure *cc = signal_find_class_closure (node, emission->chain_type);
+  {
+    ClassClosure *cc = signal_find_class_closure (node, emission->chain_type);
 
-      g_assert (cc != NULL);    /* closure currently in call stack */
+    g_assert (cc != NULL);  /* closure currently in call stack */
 
-      n_params = node->n_params;
-      restore_type = cc->instance_type;
-      cc = signal_find_class_closure (node, g_type_parent (cc->instance_type));
-      if (cc && cc->instance_type != restore_type)
-        {
-          closure = cc->closure;
-          chain_type = cc->instance_type;
-        }
-    }
+    n_params = node->n_params;
+    restore_type = cc->instance_type;
+    cc = signal_find_class_closure (node, g_type_parent (cc->instance_type));
+    if (cc && cc->instance_type != restore_type)
+      {
+        closure = cc->closure;
+        chain_type = cc->instance_type;
+      }
+  }
       else
-    g_warning ("%s: signal id '%u' cannot be chained from current emission stage for instance '%p'", G_STRLOC, node->signal_id, instance);
+  g_warning ("%s: signal id '%u' cannot be chained from current emission stage for instance '%p'", G_STRLOC, node->signal_id, instance);
     }
   else
     g_warning ("%s: no signal is currently being emitted for instance '%p'", G_STRLOC, instance);
 
   if (closure)
@@ -2214,13 +2220,13 @@
           GType ptype = node->param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE;
           gboolean static_scope = node->param_types[i] & G_SIGNAL_TYPE_STATIC_SCOPE;
 
           SIGNAL_UNLOCK ();
           G_VALUE_COLLECT_INIT (param_values + i, ptype,
-                var_args,
-                static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
-                &error);
+        var_args,
+        static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
+        &error);
           if (error)
             {
               g_warning ("%s: %s", G_STRLOC, error);
               g_free (error);
 
@@ -2333,14 +2339,14 @@
  *
  * Returns: the handler ID (always greater than 0 for successful connections)
  */
 gulong
 g_signal_connect_closure_by_id (gpointer  instance,
-                guint     signal_id,
-                GQuark    detail,
-                GClosure *closure,
-                gboolean  after)
+        guint     signal_id,
+        GQuark    detail,
+        GClosure *closure,
+        gboolean  after)
 {
   SignalNode *node;
   gulong handler_seq_no = 0;
 
   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
@@ -2350,30 +2356,30 @@
   SIGNAL_LOCK ();
   node = LOOKUP_SIGNAL_NODE (signal_id);
   if (node)
     {
       if (detail && !(node->flags & G_SIGNAL_DETAILED))
-    g_warning ("%s: signal id '%u' does not support detail (%u)", G_STRLOC, signal_id, detail);
+  g_warning ("%s: signal id '%u' does not support detail (%u)", G_STRLOC, signal_id, detail);
       else if (!g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node->itype))
-    g_warning ("%s: signal id '%u' is invalid for instance '%p'", G_STRLOC, signal_id, instance);
+  g_warning ("%s: signal id '%u' is invalid for instance '%p'", G_STRLOC, signal_id, instance);
       else
-    {
-      Handler *handler = handler_new (signal_id, instance, after);
-
-      handler_seq_no = handler->sequential_number;
-      handler->detail = detail;
-      handler->closure = g_closure_ref (closure);
-      g_closure_sink (closure);
-      add_invalid_closure_notify (handler, instance);
-      handler_insert (signal_id, instance, handler);
-      if (node->c_marshaller && G_CLOSURE_NEEDS_MARSHAL (closure))
-        {
-          g_closure_set_marshal (closure, node->c_marshaller);
-          if (node->va_marshaller)
-        _g_closure_set_va_marshal (closure, node->va_marshaller);
-        }
-    }
+  {
+    Handler *handler = handler_new (signal_id, instance, after);
+
+    handler_seq_no = handler->sequential_number;
+    handler->detail = detail;
+    handler->closure = g_closure_ref (closure);
+    g_closure_sink (closure);
+    add_invalid_closure_notify (handler, instance);
+    handler_insert (signal_id, instance, handler);
+    if (node->c_marshaller && G_CLOSURE_NEEDS_MARSHAL (closure))
+      {
+        g_closure_set_marshal (closure, node->c_marshaller);
+        if (node->va_marshaller)
+    _g_closure_set_va_marshal (closure, node->va_marshaller);
+      }
+  }
     }
   else
     g_warning ("%s: signal id '%u' is invalid for instance '%p'", G_STRLOC, signal_id, instance);
   SIGNAL_UNLOCK ();
 
@@ -2392,13 +2398,13 @@
  *
  * Returns: the handler ID (always greater than 0 for successful connections)
  */
 gulong
 g_signal_connect_closure (gpointer     instance,
-              const gchar *detailed_signal,
-              GClosure    *closure,
-              gboolean     after)
+        const gchar *detailed_signal,
+        GClosure    *closure,
+        gboolean     after)
 {
   guint signal_id;
   gulong handler_seq_no = 0;
   GQuark detail = 0;
   GType itype;
@@ -2413,31 +2419,31 @@
   if (signal_id)
     {
       SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
 
       if (detail && !(node->flags & G_SIGNAL_DETAILED))
-    g_warning ("%s: signal '%s' does not support details", G_STRLOC, detailed_signal);
+  g_warning ("%s: signal '%s' does not support details", G_STRLOC, detailed_signal);
       else if (!g_type_is_a (itype, node->itype))
         g_warning ("%s: signal '%s' is invalid for instance '%p' of type '%s'",
                    G_STRLOC, detailed_signal, instance, g_type_name (itype));
       else
-    {
-      Handler *handler = handler_new (signal_id, instance, after);
-
-      handler_seq_no = handler->sequential_number;
-      handler->detail = detail;
-      handler->closure = g_closure_ref (closure);
-      g_closure_sink (closure);
-      add_invalid_closure_notify (handler, instance);
-      handler_insert (signal_id, instance, handler);
-      if (node->c_marshaller && G_CLOSURE_NEEDS_MARSHAL (handler->closure))
-        {
-          g_closure_set_marshal (handler->closure, node->c_marshaller);
-          if (node->va_marshaller)
-        _g_closure_set_va_marshal (handler->closure, node->va_marshaller);
-        }
-    }
+  {
+    Handler *handler = handler_new (signal_id, instance, after);
+
+    handler_seq_no = handler->sequential_number;
+    handler->detail = detail;
+    handler->closure = g_closure_ref (closure);
+    g_closure_sink (closure);
+    add_invalid_closure_notify (handler, instance);
+    handler_insert (signal_id, instance, handler);
+    if (node->c_marshaller && G_CLOSURE_NEEDS_MARSHAL (handler->closure))
+      {
+        g_closure_set_marshal (handler->closure, node->c_marshaller);
+        if (node->va_marshaller)
+    _g_closure_set_va_marshal (handler->closure, node->va_marshaller);
+      }
+  }
     }
   else
     g_warning ("%s: signal '%s' is invalid for instance '%p' of type '%s'",
                G_STRLOC, detailed_signal, instance, g_type_name (itype));
   SIGNAL_UNLOCK ();
@@ -2485,15 +2491,15 @@
  *
  * Returns: the handler ID (always greater than 0 for successful connections)
  */
 gulong
 g_signal_connect_data (gpointer       instance,
-               const gchar   *detailed_signal,
-               GCallback      c_handler,
-               gpointer       data,
-               GClosureNotify destroy_data,
-               GConnectFlags  connect_flags)
+           const gchar   *detailed_signal,
+           GCallback      c_handler,
+           gpointer       data,
+           GClosureNotify destroy_data,
+           GConnectFlags  connect_flags)
 {
   guint signal_id;
   gulong handler_seq_no = 0;
   GQuark detail = 0;
   GType itype;
@@ -2514,29 +2520,29 @@
       SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
 
       node_check_deprecated (node);
 
       if (detail && !(node->flags & G_SIGNAL_DETAILED))
-    g_warning ("%s: signal '%s' does not support details", G_STRLOC, detailed_signal);
+  g_warning ("%s: signal '%s' does not support details", G_STRLOC, detailed_signal);
       else if (!g_type_is_a (itype, node->itype))
         g_warning ("%s: signal '%s' is invalid for instance '%p' of type '%s'",
                    G_STRLOC, detailed_signal, instance, g_type_name (itype));
       else
-    {
-      Handler *handler = handler_new (signal_id, instance, after);
-
-      handler_seq_no = handler->sequential_number;
-      handler->detail = detail;
-      handler->closure = g_closure_ref ((swapped ? g_cclosure_new_swap : g_cclosure_new) (c_handler, data, destroy_data));
-      g_closure_sink (handler->closure);
-      handler_insert (signal_id, instance, handler);
-      if (node->c_marshaller && G_CLOSURE_NEEDS_MARSHAL (handler->closure))
-        {
-          g_closure_set_marshal (handler->closure, node->c_marshaller);
-          if (node->va_marshaller)
-        _g_closure_set_va_marshal (handler->closure, node->va_marshaller);
-        }
+  {
+    Handler *handler = handler_new (signal_id, instance, after);
+
+    handler_seq_no = handler->sequential_number;
+    handler->detail = detail;
+    handler->closure = g_closure_ref ((swapped ? g_cclosure_new_swap : g_cclosure_new) (c_handler, data, destroy_data));
+    g_closure_sink (handler->closure);
+    handler_insert (signal_id, instance, handler);
+    if (node->c_marshaller && G_CLOSURE_NEEDS_MARSHAL (handler->closure))
+      {
+        g_closure_set_marshal (handler->closure, node->c_marshaller);
+        if (node->va_marshaller)
+    _g_closure_set_va_marshal (handler->closure, node->va_marshaller);
+      }
         }
     }
   else
     g_warning ("%s: signal '%s' is invalid for instance '%p' of type '%s'",
                G_STRLOC, detailed_signal, instance, g_type_name (itype));
@@ -2670,11 +2676,11 @@
  *
  * Returns: whether @handler_id identifies a handler connected to @instance.
  */
 gboolean
 g_signal_handler_is_connected (gpointer instance,
-                   gulong   handler_id)
+             gulong   handler_id)
 {
   Handler *handler;
   gboolean connected;
 
   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), FALSE);
@@ -2724,16 +2730,16 @@
               tmp->block_count = 1;
               /* cruel unlink, this works because _all_ handlers vanish */
               tmp->next = NULL;
               tmp->prev = tmp;
               if (tmp->sequential_number)
-        {
+    {
                   g_hash_table_remove (g_handlers, tmp);
-          remove_invalid_closure_notify (tmp, instance);
-          tmp->sequential_number = 0;
-          handler_unref_R (0, NULL, tmp);
-        }
+      remove_invalid_closure_notify (tmp, instance);
+      tmp->sequential_number = 0;
+      handler_unref_R (0, NULL, tmp);
+    }
             }
         }
       g_bsearch_array_free (hlbsa, &g_signal_hlbsa_bconfig);
     }
   SIGNAL_UNLOCK ();
@@ -2760,11 +2766,11 @@
  */
 gulong
 g_signal_handler_find (gpointer         instance,
                        GSignalMatchType mask,
                        guint            signal_id,
-               GQuark       detail,
+           GQuark   detail,
                        GClosure        *closure,
                        gpointer         func,
                        gpointer         data)
 {
   gulong handler_seq_no = 0;
@@ -2777,44 +2783,44 @@
       HandlerMatch *mlist;
 
       SIGNAL_LOCK ();
       mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, TRUE);
       if (mlist)
-    {
-      handler_seq_no = mlist->handler->sequential_number;
-      handler_match_free1_R (mlist, instance);
-    }
+  {
+    handler_seq_no = mlist->handler->sequential_number;
+    handler_match_free1_R (mlist, instance);
+  }
       SIGNAL_UNLOCK ();
     }
 
   return handler_seq_no;
 }
 
 static guint
 signal_handlers_foreach_matched_R (gpointer         instance,
-                                   GSignalMatchType mask,
-                                   guint            signal_id,
-                                   GQuark           detail,
-                                   GClosure        *closure,
-                                   gpointer         func,
-                                   gpointer         data,
-                   void       (*callback) (gpointer instance,
-                                   gulong   handler_seq_no))
+           GSignalMatchType mask,
+           guint            signal_id,
+           GQuark           detail,
+           GClosure        *closure,
+           gpointer         func,
+           gpointer         data,
+           void     (*callback) (gpointer instance,
+                     gulong   handler_seq_no))
 {
   HandlerMatch *mlist;
   guint n_handlers = 0;
 
   mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, FALSE);
   while (mlist)
     {
       n_handlers++;
       if (mlist->handler->sequential_number)
-    {
-      SIGNAL_UNLOCK ();
-      callback (instance, mlist->handler->sequential_number);
-      SIGNAL_LOCK ();
-    }
+  {
+    SIGNAL_UNLOCK ();
+    callback (instance, mlist->handler->sequential_number);
+    SIGNAL_LOCK ();
+  }
       mlist = handler_match_free1_R (mlist, instance);
     }
 
   return n_handlers;
 }
@@ -2840,28 +2846,28 @@
  *
  * Returns: The number of handlers that matched.
  */
 guint
 g_signal_handlers_block_matched (gpointer         instance,
-                 GSignalMatchType mask,
-                 guint            signal_id,
-                 GQuark           detail,
-                 GClosure        *closure,
-                 gpointer         func,
-                 gpointer         data)
+         GSignalMatchType mask,
+         guint            signal_id,
+         GQuark           detail,
+         GClosure        *closure,
+         gpointer         func,
+         gpointer         data)
 {
   guint n_handlers = 0;
 
   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
   g_return_val_if_fail ((mask & ~G_SIGNAL_MATCH_MASK) == 0, 0);
 
   if (mask & (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
     {
       SIGNAL_LOCK ();
       n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
-                              closure, func, data,
-                              g_signal_handler_block);
+                  closure, func, data,
+                  g_signal_handler_block);
       SIGNAL_UNLOCK ();
     }
 
   return n_handlers;
 }
@@ -2888,28 +2894,28 @@
  *
  * Returns: The number of handlers that matched.
  */
 guint
 g_signal_handlers_unblock_matched (gpointer         instance,
-                   GSignalMatchType mask,
-                   guint            signal_id,
-                   GQuark           detail,
-                   GClosure        *closure,
-                   gpointer         func,
-                   gpointer         data)
+           GSignalMatchType mask,
+           guint            signal_id,
+           GQuark           detail,
+           GClosure        *closure,
+           gpointer         func,
+           gpointer         data)
 {
   guint n_handlers = 0;
 
   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
   g_return_val_if_fail ((mask & ~G_SIGNAL_MATCH_MASK) == 0, 0);
 
   if (mask & (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
     {
       SIGNAL_LOCK ();
       n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
-                              closure, func, data,
-                              g_signal_handler_unblock);
+                  closure, func, data,
+                  g_signal_handler_unblock);
       SIGNAL_UNLOCK ();
     }
 
   return n_handlers;
 }
@@ -2936,28 +2942,28 @@
  *
  * Returns: The number of handlers that matched.
  */
 guint
 g_signal_handlers_disconnect_matched (gpointer         instance,
-                      GSignalMatchType mask,
-                      guint            signal_id,
-                      GQuark           detail,
-                      GClosure        *closure,
-                      gpointer         func,
-                      gpointer         data)
+              GSignalMatchType mask,
+              guint            signal_id,
+              GQuark           detail,
+              GClosure        *closure,
+              gpointer         func,
+              gpointer         data)
 {
   guint n_handlers = 0;
 
   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
   g_return_val_if_fail ((mask & ~G_SIGNAL_MATCH_MASK) == 0, 0);
 
   if (mask & (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
     {
       SIGNAL_LOCK ();
       n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
-                              closure, func, data,
-                              g_signal_handler_disconnect);
+                  closure, func, data,
+                  g_signal_handler_disconnect);
       SIGNAL_UNLOCK ();
     }
 
   return n_handlers;
 }
@@ -2989,13 +2995,13 @@
  * Returns: %TRUE if a handler is connected to the signal, %FALSE
  *          otherwise.
  */
 gboolean
 g_signal_has_handler_pending (gpointer instance,
-                  guint    signal_id,
-                  GQuark   detail,
-                  gboolean may_be_blocked)
+            guint    signal_id,
+            GQuark   detail,
+            gboolean may_be_blocked)
 {
   HandlerMatch *mlist;
   gboolean has_pending;
   SignalNode *node;
 
@@ -3010,19 +3016,19 @@
 #ifndef GSTREAMER_LITE
       if (!(node->flags & G_SIGNAL_DETAILED))
 #else // GSTREAMER_LITE
       if (node == NULL || !(node->flags & G_SIGNAL_DETAILED))
 #endif // GSTREAMER_LITE
-    {
-      g_warning ("%s: signal id '%u' does not support detail (%u)", G_STRLOC, signal_id, detail);
-      SIGNAL_UNLOCK ();
-      return FALSE;
-    }
+  {
+    g_warning ("%s: signal id '%u' does not support detail (%u)", G_STRLOC, signal_id, detail);
+    SIGNAL_UNLOCK ();
+    return FALSE;
+  }
     }
   mlist = handlers_find (instance,
-             (G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | (may_be_blocked ? 0 : G_SIGNAL_MATCH_UNBLOCKED)),
-             signal_id, detail, NULL, NULL, NULL, TRUE);
+       (G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | (may_be_blocked ? 0 : G_SIGNAL_MATCH_UNBLOCKED)),
+       signal_id, detail, NULL, NULL, NULL, TRUE);
   if (mlist)
     {
       has_pending = TRUE;
       handler_match_free1_R (mlist, instance);
     }
@@ -3030,11 +3036,11 @@
     {
       ClassClosure *class_closure = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
       if (class_closure != NULL && class_closure->instance_type != 0)
         has_pending = TRUE;
       else
-    has_pending = FALSE;
+        has_pending = FALSE;
     }
   SIGNAL_UNLOCK ();
 
   return has_pending;
 }
@@ -3055,13 +3061,13 @@
  * Note that g_signal_emitv() doesn't change @return_value if no handlers are
  * connected, in contrast to g_signal_emit() and g_signal_emit_valist().
  */
 void
 g_signal_emitv (const GValue *instance_and_params,
-                guint         signal_id,
-        GQuark        detail,
-                GValue       *return_value)
+    guint         signal_id,
+    GQuark        detail,
+    GValue       *return_value)
 {
   gpointer instance;
   SignalNode *node;
 #ifdef G_ENABLE_DEBUG
   const GValue *param_values;
@@ -3093,40 +3099,40 @@
       return;
     }
   for (i = 0; i < node->n_params; i++)
     if (!G_TYPE_CHECK_VALUE_TYPE (param_values + i, node->param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE))
       {
-    g_critical ("%s: value for '%s' parameter %u for signal \"%s\" is of type '%s'",
-            G_STRLOC,
-            type_debug_name (node->param_types[i]),
-            i,
-            node->name,
-            G_VALUE_TYPE_NAME (param_values + i));
-    SIGNAL_UNLOCK ();
-    return;
+  g_critical ("%s: value for '%s' parameter %u for signal \"%s\" is of type '%s'",
+        G_STRLOC,
+        type_debug_name (node->param_types[i]),
+        i,
+        node->name,
+        G_VALUE_TYPE_NAME (param_values + i));
+  SIGNAL_UNLOCK ();
+  return;
       }
   if (node->return_type != G_TYPE_NONE)
     {
       if (!return_value)
-    {
-      g_critical ("%s: return value '%s' for signal \"%s\" is (NULL)",
-              G_STRLOC,
-              type_debug_name (node->return_type),
-              node->name);
-      SIGNAL_UNLOCK ();
-      return;
-    }
+  {
+    g_critical ("%s: return value '%s' for signal \"%s\" is (NULL)",
+          G_STRLOC,
+          type_debug_name (node->return_type),
+          node->name);
+    SIGNAL_UNLOCK ();
+    return;
+  }
       else if (!node->accumulator && !G_TYPE_CHECK_VALUE_TYPE (return_value, node->return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE))
-    {
-      g_critical ("%s: return value '%s' for signal \"%s\" is of type '%s'",
-              G_STRLOC,
-              type_debug_name (node->return_type),
-              node->name,
-              G_VALUE_TYPE_NAME (return_value));
-      SIGNAL_UNLOCK ();
-      return;
-    }
+  {
+    g_critical ("%s: return value '%s' for signal \"%s\" is of type '%s'",
+          G_STRLOC,
+          type_debug_name (node->return_type),
+          node->name,
+          G_VALUE_TYPE_NAME (return_value));
+    SIGNAL_UNLOCK ();
+    return;
+  }
     }
   else
     return_value = NULL;
 #endif  /* G_ENABLE_DEBUG */
 
@@ -3138,27 +3144,27 @@
       (node->single_va_closure == SINGLE_VA_CLOSURE_EMPTY_MAGIC ||
        _g_closure_is_void (node->single_va_closure, instance)))
     {
       HandlerList* hlist = handler_list_lookup (node->signal_id, instance);
       if (hlist == NULL || hlist->handlers == NULL)
-    {
-      /* nothing to do to emit this signal */
-      SIGNAL_UNLOCK ();
-      /* g_printerr ("omitting emission of \"%s\"\n", node->name); */
-      return;
-    }
+  {
+    /* nothing to do to emit this signal */
+    SIGNAL_UNLOCK ();
+    /* g_printerr ("omitting emission of \"%s\"\n", node->name); */
+    return;
+  }
     }
 
   SIGNAL_UNLOCK ();
   signal_emit_unlocked_R (node, detail, instance, return_value, instance_and_params);
 }
 
 static inline gboolean
 accumulate (GSignalInvocationHint *ihint,
-            GValue                *return_accu,
-        GValue            *handler_return,
-            SignalAccumulator     *accumulator)
+      GValue                *return_accu,
+      GValue            *handler_return,
+      SignalAccumulator     *accumulator)
 {
   gboolean continue_emission;
 
   if (!accumulator)
     return TRUE;
@@ -3184,13 +3190,13 @@
  * Note that g_signal_emit_valist() resets the return value to the default
  * if no handlers are connected, in contrast to g_signal_emitv().
  */
 void
 g_signal_emit_valist (gpointer instance,
-              guint    signal_id,
-              GQuark   detail,
-              va_list  var_args)
+          guint    signal_id,
+          GQuark   detail,
+          va_list  var_args)
 {
   GValue *instance_and_params;
   GType signal_return_type;
   GValue *param_values;
   SignalNode *node;
@@ -3227,155 +3233,155 @@
       GClosure *closure = NULL;
       gboolean fastpath = TRUE;
       GSignalFlags run_type = G_SIGNAL_RUN_FIRST;
 
       if (node->single_va_closure != SINGLE_VA_CLOSURE_EMPTY_MAGIC &&
-      !_g_closure_is_void (node->single_va_closure, instance))
-    {
-      if (_g_closure_supports_invoke_va (node->single_va_closure))
-        {
-          closure = node->single_va_closure;
-          if (node->single_va_closure_is_after)
-        run_type = G_SIGNAL_RUN_LAST;
-          else
-        run_type = G_SIGNAL_RUN_FIRST;
-        }
-      else
-        fastpath = FALSE;
-    }
+    !_g_closure_is_void (node->single_va_closure, instance))
+  {
+    if (_g_closure_supports_invoke_va (node->single_va_closure))
+      {
+        closure = node->single_va_closure;
+        if (node->single_va_closure_is_after)
+    run_type = G_SIGNAL_RUN_LAST;
+        else
+    run_type = G_SIGNAL_RUN_FIRST;
+      }
+    else
+      fastpath = FALSE;
+  }
 
       for (l = hlist ? hlist->handlers : NULL; fastpath && l != NULL; l = l->next)
+  {
+    if (!l->block_count &&
+        (!l->detail || l->detail == detail))
+      {
+        if (closure != NULL || !_g_closure_supports_invoke_va (l->closure))
+    {
+      fastpath = FALSE;
+      break;
+    }
+        else
     {
-      if (!l->block_count &&
-          (!l->detail || l->detail == detail))
-        {
-          if (closure != NULL || !_g_closure_supports_invoke_va (l->closure))
-        {
-          fastpath = FALSE;
-          break;
-        }
-          else
-        {
                   fastpath_handler = l;
-          closure = l->closure;
-          if (l->after)
-            run_type = G_SIGNAL_RUN_LAST;
-          else
-            run_type = G_SIGNAL_RUN_FIRST;
-        }
-        }
+      closure = l->closure;
+      if (l->after)
+        run_type = G_SIGNAL_RUN_LAST;
+      else
+        run_type = G_SIGNAL_RUN_FIRST;
     }
+      }
+  }
 
       if (fastpath && closure == NULL && node->return_type == G_TYPE_NONE)
-    {
-      SIGNAL_UNLOCK ();
-      return;
-    }
+  {
+    SIGNAL_UNLOCK ();
+    return;
+  }
 
       /* Don't allow no-recurse emission as we might have to restart, which means
-     we will run multiple handlers and thus must ref all arguments */
+   we will run multiple handlers and thus must ref all arguments */
       if (closure != NULL && (node->flags & (G_SIGNAL_NO_RECURSE)) != 0)
-    fastpath = FALSE;
+  fastpath = FALSE;
 
       if (fastpath)
-    {
-      SignalAccumulator *accumulator;
-      Emission emission;
-      GValue *return_accu, accu = G_VALUE_INIT;
-      guint signal_id;
-      GType instance_type = G_TYPE_FROM_INSTANCE (instance);
-      GValue emission_return = G_VALUE_INIT;
+  {
+    SignalAccumulator *accumulator;
+    Emission emission;
+    GValue *return_accu, accu = G_VALUE_INIT;
+    guint signal_id;
+    GType instance_type = G_TYPE_FROM_INSTANCE (instance);
+    GValue emission_return = G_VALUE_INIT;
           GType rtype = node->return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE;
-      gboolean static_scope = node->return_type & G_SIGNAL_TYPE_STATIC_SCOPE;
-
-      signal_id = node->signal_id;
-      accumulator = node->accumulator;
-      if (rtype == G_TYPE_NONE)
-        return_accu = NULL;
-      else if (accumulator)
-        return_accu = &accu;
-      else
-        return_accu = &emission_return;
+    gboolean static_scope = node->return_type & G_SIGNAL_TYPE_STATIC_SCOPE;
 
-      emission.instance = instance;
-      emission.ihint.signal_id = signal_id;
-      emission.ihint.detail = detail;
-      emission.ihint.run_type = run_type;
-      emission.state = EMISSION_RUN;
-      emission.chain_type = instance_type;
-      emission_push (&emission);
+    signal_id = node->signal_id;
+    accumulator = node->accumulator;
+    if (rtype == G_TYPE_NONE)
+      return_accu = NULL;
+    else if (accumulator)
+      return_accu = &accu;
+    else
+      return_accu = &emission_return;
+
+    emission.instance = instance;
+    emission.ihint.signal_id = signal_id;
+    emission.ihint.detail = detail;
+    emission.ihint.run_type = run_type;
+    emission.state = EMISSION_RUN;
+    emission.chain_type = instance_type;
+    emission_push (&emission);
 
           if (fastpath_handler)
             handler_ref (fastpath_handler);
 
-      SIGNAL_UNLOCK ();
+    SIGNAL_UNLOCK ();
 
-      TRACE(GOBJECT_SIGNAL_EMIT(signal_id, detail, instance, instance_type));
+    TRACE(GOBJECT_SIGNAL_EMIT(signal_id, detail, instance, instance_type));
 
-      if (rtype != G_TYPE_NONE)
-        g_value_init (&emission_return, rtype);
+    if (rtype != G_TYPE_NONE)
+      g_value_init (&emission_return, rtype);
 
-      if (accumulator)
-        g_value_init (&accu, rtype);
+    if (accumulator)
+      g_value_init (&accu, rtype);
 
-      if (closure != NULL)
-        {
-          g_object_ref (instance);
-          _g_closure_invoke_va (closure,
-                    return_accu,
-                    instance,
-                    var_args,
-                    node->n_params,
-                    node->param_types);
-          accumulate (&emission.ihint, &emission_return, &accu, accumulator);
-        }
+    if (closure != NULL)
+      {
+        g_object_ref (instance);
+        _g_closure_invoke_va (closure,
+            return_accu,
+            instance,
+            var_args,
+            node->n_params,
+            node->param_types);
+        accumulate (&emission.ihint, &emission_return, &accu, accumulator);
+      }
 
-      SIGNAL_LOCK ();
+    SIGNAL_LOCK ();
 
-      emission.chain_type = G_TYPE_NONE;
-      emission_pop (&emission);
+    emission.chain_type = G_TYPE_NONE;
+    emission_pop (&emission);
 
           if (fastpath_handler)
             handler_unref_R (signal_id, instance, fastpath_handler);
 
-      SIGNAL_UNLOCK ();
+    SIGNAL_UNLOCK ();
 
-      if (accumulator)
-        g_value_unset (&accu);
+    if (accumulator)
+      g_value_unset (&accu);
 
-      if (rtype != G_TYPE_NONE)
-        {
-          gchar *error = NULL;
-          for (i = 0; i < node->n_params; i++)
-        {
-          GType ptype = node->param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE;
-          G_VALUE_COLLECT_SKIP (ptype, var_args);
-        }
+    if (rtype != G_TYPE_NONE)
+      {
+        gchar *error = NULL;
+        for (i = 0; i < node->n_params; i++)
+    {
+      GType ptype = node->param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE;
+      G_VALUE_COLLECT_SKIP (ptype, var_args);
+    }
 
-          G_VALUE_LCOPY (&emission_return,
-                 var_args,
-                 static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
-                 &error);
-          if (!error)
-        g_value_unset (&emission_return);
-          else
-        {
-          g_warning ("%s: %s", G_STRLOC, error);
-          g_free (error);
-          /* we purposely leak the value here, it might not be
-           * in a sane state if an error condition occurred
-           */
-        }
-        }
+        G_VALUE_LCOPY (&emission_return,
+           var_args,
+           static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
+           &error);
+        if (!error)
+    g_value_unset (&emission_return);
+        else
+    {
+      g_warning ("%s: %s", G_STRLOC, error);
+      g_free (error);
+      /* we purposely leak the value here, it might not be
+       * in a sane state if an error condition occurred
+       */
+    }
+      }
 
-      TRACE(GOBJECT_SIGNAL_EMIT_END(signal_id, detail, instance, instance_type));
+    TRACE(GOBJECT_SIGNAL_EMIT_END(signal_id, detail, instance, instance_type));
 
           if (closure != NULL)
             g_object_unref (instance);
 
-      return;
-    }
+    return;
+  }
     }
   SIGNAL_UNLOCK ();
 
   n_params = node->n_params;
   signal_return_type = node->return_type;
@@ -3388,26 +3394,26 @@
       gchar *error;
       GType ptype = node->param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE;
       gboolean static_scope = node->param_types[i] & G_SIGNAL_TYPE_STATIC_SCOPE;
 
       G_VALUE_COLLECT_INIT (param_values + i, ptype,
-                var_args,
-                static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
-                &error);
+          var_args,
+          static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
+          &error);
       if (error)
-    {
-      g_warning ("%s: %s", G_STRLOC, error);
-      g_free (error);
+  {
+    g_warning ("%s: %s", G_STRLOC, error);
+    g_free (error);
 
-      /* we purposely leak the value here, it might not be
-       * in a sane state if an error condition occoured
-       */
-      while (i--)
-        g_value_unset (param_values + i);
+    /* we purposely leak the value here, it might not be
+     * in a sane state if an error condition occoured
+     */
+    while (i--)
+      g_value_unset (param_values + i);
 
-      return;
-    }
+    return;
+  }
     }
 
   instance_and_params->g_type = 0;
   g_value_init_from_instance (instance_and_params, instance);
   if (signal_return_type == G_TYPE_NONE)
@@ -3422,24 +3428,24 @@
       g_value_init (&return_value, rtype);
 
       signal_emit_unlocked_R (node, detail, instance, &return_value, instance_and_params);
 
       G_VALUE_LCOPY (&return_value,
-             var_args,
-             static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
-             &error);
+         var_args,
+         static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
+         &error);
       if (!error)
-    g_value_unset (&return_value);
+  g_value_unset (&return_value);
       else
-    {
-      g_warning ("%s: %s", G_STRLOC, error);
-      g_free (error);
+  {
+    g_warning ("%s: %s", G_STRLOC, error);
+    g_free (error);
 
-      /* we purposely leak the value here, it might not be
-       * in a sane state if an error condition occurred
-       */
-    }
+    /* we purposely leak the value here, it might not be
+     * in a sane state if an error condition occurred
+     */
+  }
     }
   for (i = 0; i < n_params; i++)
     g_value_unset (param_values + i);
   g_value_unset (instance_and_params);
 }
@@ -3458,13 +3464,13 @@
  * Note that g_signal_emit() resets the return value to the default
  * if no handlers are connected, in contrast to g_signal_emitv().
  */
 void
 g_signal_emit (gpointer instance,
-           guint    signal_id,
-           GQuark   detail,
-           ...)
+         guint    signal_id,
+         GQuark   detail,
+         ...)
 {
   va_list var_args;
 
   va_start (var_args, detail);
   g_signal_emit_valist (instance, signal_id, detail, var_args);
@@ -3484,12 +3490,12 @@
  * Note that g_signal_emit_by_name() resets the return value to the default
  * if no handlers are connected, in contrast to g_signal_emitv().
  */
 void
 g_signal_emit_by_name (gpointer     instance,
-               const gchar *detailed_signal,
-               ...)
+           const gchar *detailed_signal,
+           ...)
 {
   GQuark detail = 0;
   guint signal_id;
   GType itype;
 
@@ -3515,14 +3521,14 @@
                G_STRLOC, detailed_signal, instance, g_type_name (itype));
 }
 
 static gboolean
 signal_emit_unlocked_R (SignalNode   *node,
-            GQuark        detail,
-                        gpointer      instance,
-            GValue       *emission_return,
-                        const GValue *instance_and_params)
+      GQuark        detail,
+      gpointer      instance,
+      GValue       *emission_return,
+      const GValue *instance_and_params)
 {
   SignalAccumulator *accumulator;
   Emission emission;
   GClosure *class_closure;
   HandlerList *hlist;
@@ -3540,15 +3546,15 @@
   if (node->flags & G_SIGNAL_NO_RECURSE)
     {
       Emission *node = emission_find (signal_id, detail, instance);
 
       if (node)
-    {
-      node->state = EMISSION_RESTART;
-      SIGNAL_UNLOCK ();
-      return return_value_altered;
-    }
+  {
+    node->state = EMISSION_RESTART;
+    SIGNAL_UNLOCK ();
+    return return_value_altered;
+  }
     }
   accumulator = node->accumulator;
   if (accumulator)
     {
       SIGNAL_UNLOCK ();
@@ -3584,107 +3590,107 @@
       emission.state = EMISSION_RUN;
 
       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
       SIGNAL_UNLOCK ();
       g_closure_invoke (class_closure,
-            return_accu,
-            node->n_params + 1,
-            instance_and_params,
-            &emission.ihint);
+      return_accu,
+      node->n_params + 1,
+      instance_and_params,
+      &emission.ihint);
       if (!accumulate (&emission.ihint, emission_return, &accu, accumulator) &&
-      emission.state == EMISSION_RUN)
-    emission.state = EMISSION_STOP;
+    emission.state == EMISSION_RUN)
+  emission.state = EMISSION_STOP;
       SIGNAL_LOCK ();
       emission.chain_type = G_TYPE_NONE;
       return_value_altered = TRUE;
 
       if (emission.state == EMISSION_STOP)
-    goto EMIT_CLEANUP;
+  goto EMIT_CLEANUP;
       else if (emission.state == EMISSION_RESTART)
-    goto EMIT_RESTART;
+  goto EMIT_RESTART;
     }
 
   if (node->emission_hooks)
     {
       gboolean need_destroy, was_in_call, may_recurse = TRUE;
       GHook *hook;
 
       emission.state = EMISSION_HOOK;
       hook = g_hook_first_valid (node->emission_hooks, may_recurse);
       while (hook)
-    {
-      SignalHook *signal_hook = SIGNAL_HOOK (hook);
+  {
+    SignalHook *signal_hook = SIGNAL_HOOK (hook);
 
-      if (!signal_hook->detail || signal_hook->detail == detail)
-        {
-          GSignalEmissionHook hook_func = (GSignalEmissionHook) hook->func;
+    if (!signal_hook->detail || signal_hook->detail == detail)
+      {
+        GSignalEmissionHook hook_func = (GSignalEmissionHook) hook->func;
 
-          was_in_call = G_HOOK_IN_CALL (hook);
-          hook->flags |= G_HOOK_FLAG_IN_CALL;
+        was_in_call = G_HOOK_IN_CALL (hook);
+        hook->flags |= G_HOOK_FLAG_IN_CALL;
               SIGNAL_UNLOCK ();
-          need_destroy = !hook_func (&emission.ihint, node->n_params + 1, instance_and_params, hook->data);
-          SIGNAL_LOCK ();
-          if (!was_in_call)
-        hook->flags &= ~G_HOOK_FLAG_IN_CALL;
-          if (need_destroy)
-        g_hook_destroy_link (node->emission_hooks, hook);
-        }
-      hook = g_hook_next_valid (node->emission_hooks, hook, may_recurse);
-    }
+        need_destroy = !hook_func (&emission.ihint, node->n_params + 1, instance_and_params, hook->data);
+        SIGNAL_LOCK ();
+        if (!was_in_call)
+    hook->flags &= ~G_HOOK_FLAG_IN_CALL;
+        if (need_destroy)
+    g_hook_destroy_link (node->emission_hooks, hook);
+      }
+    hook = g_hook_next_valid (node->emission_hooks, hook, may_recurse);
+  }
 
       if (emission.state == EMISSION_RESTART)
-    goto EMIT_RESTART;
+  goto EMIT_RESTART;
     }
 
   if (handler_list)
     {
       Handler *handler = handler_list;
 
       emission.state = EMISSION_RUN;
       handler_ref (handler);
       do
-    {
-      Handler *tmp;
+  {
+    Handler *tmp;
 
-      if (handler->after)
-        {
-          handler_unref_R (signal_id, instance, handler_list);
-          handler_list = handler;
-          break;
-        }
-      else if (!handler->block_count && (!handler->detail || handler->detail == detail) &&
-           handler->sequential_number < max_sequential_handler_number)
-        {
-          SIGNAL_UNLOCK ();
-          g_closure_invoke (handler->closure,
-                return_accu,
-                node->n_params + 1,
-                instance_and_params,
-                &emission.ihint);
-          if (!accumulate (&emission.ihint, emission_return, &accu, accumulator) &&
-          emission.state == EMISSION_RUN)
-        emission.state = EMISSION_STOP;
-          SIGNAL_LOCK ();
-          return_value_altered = TRUE;
+    if (handler->after)
+      {
+        handler_unref_R (signal_id, instance, handler_list);
+        handler_list = handler;
+        break;
+      }
+    else if (!handler->block_count && (!handler->detail || handler->detail == detail) &&
+       handler->sequential_number < max_sequential_handler_number)
+      {
+        SIGNAL_UNLOCK ();
+        g_closure_invoke (handler->closure,
+        return_accu,
+        node->n_params + 1,
+        instance_and_params,
+        &emission.ihint);
+        if (!accumulate (&emission.ihint, emission_return, &accu, accumulator) &&
+      emission.state == EMISSION_RUN)
+    emission.state = EMISSION_STOP;
+        SIGNAL_LOCK ();
+        return_value_altered = TRUE;
 
-          tmp = emission.state == EMISSION_RUN ? handler->next : NULL;
-        }
-      else
-        tmp = handler->next;
+        tmp = emission.state == EMISSION_RUN ? handler->next : NULL;
+      }
+    else
+      tmp = handler->next;
 
-      if (tmp)
-        handler_ref (tmp);
-      handler_unref_R (signal_id, instance, handler_list);
-      handler_list = handler;
-      handler = tmp;
-    }
+    if (tmp)
+      handler_ref (tmp);
+    handler_unref_R (signal_id, instance, handler_list);
+    handler_list = handler;
+    handler = tmp;
+  }
       while (handler);
 
       if (emission.state == EMISSION_STOP)
-    goto EMIT_CLEANUP;
+  goto EMIT_CLEANUP;
       else if (emission.state == EMISSION_RESTART)
-    goto EMIT_RESTART;
+  goto EMIT_RESTART;
     }
 
   emission.ihint.run_type = G_SIGNAL_RUN_LAST;
 
   if ((node->flags & G_SIGNAL_RUN_LAST) && class_closure)
@@ -3692,68 +3698,68 @@
       emission.state = EMISSION_RUN;
 
       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
       SIGNAL_UNLOCK ();
       g_closure_invoke (class_closure,
-            return_accu,
-            node->n_params + 1,
-            instance_and_params,
-            &emission.ihint);
+      return_accu,
+      node->n_params + 1,
+      instance_and_params,
+      &emission.ihint);
       if (!accumulate (&emission.ihint, emission_return, &accu, accumulator) &&
-      emission.state == EMISSION_RUN)
-    emission.state = EMISSION_STOP;
+    emission.state == EMISSION_RUN)
+  emission.state = EMISSION_STOP;
       SIGNAL_LOCK ();
       emission.chain_type = G_TYPE_NONE;
       return_value_altered = TRUE;
 
       if (emission.state == EMISSION_STOP)
-    goto EMIT_CLEANUP;
+  goto EMIT_CLEANUP;
       else if (emission.state == EMISSION_RESTART)
-    goto EMIT_RESTART;
+  goto EMIT_RESTART;
     }
 
   if (handler_list)
     {
       Handler *handler = handler_list;
 
       emission.state = EMISSION_RUN;
       handler_ref (handler);
       do
-    {
-      Handler *tmp;
+  {
+    Handler *tmp;
 
-      if (handler->after && !handler->block_count && (!handler->detail || handler->detail == detail) &&
-          handler->sequential_number < max_sequential_handler_number)
-        {
-          SIGNAL_UNLOCK ();
-          g_closure_invoke (handler->closure,
-                return_accu,
-                node->n_params + 1,
-                instance_and_params,
-                &emission.ihint);
-          if (!accumulate (&emission.ihint, emission_return, &accu, accumulator) &&
-          emission.state == EMISSION_RUN)
-        emission.state = EMISSION_STOP;
-          SIGNAL_LOCK ();
-          return_value_altered = TRUE;
+    if (handler->after && !handler->block_count && (!handler->detail || handler->detail == detail) &&
+        handler->sequential_number < max_sequential_handler_number)
+      {
+        SIGNAL_UNLOCK ();
+        g_closure_invoke (handler->closure,
+        return_accu,
+        node->n_params + 1,
+        instance_and_params,
+        &emission.ihint);
+        if (!accumulate (&emission.ihint, emission_return, &accu, accumulator) &&
+      emission.state == EMISSION_RUN)
+    emission.state = EMISSION_STOP;
+        SIGNAL_LOCK ();
+        return_value_altered = TRUE;
 
-          tmp = emission.state == EMISSION_RUN ? handler->next : NULL;
-        }
-      else
-        tmp = handler->next;
+        tmp = emission.state == EMISSION_RUN ? handler->next : NULL;
+      }
+    else
+      tmp = handler->next;
 
-      if (tmp)
-        handler_ref (tmp);
-      handler_unref_R (signal_id, instance, handler);
-      handler = tmp;
-    }
+    if (tmp)
+      handler_ref (tmp);
+    handler_unref_R (signal_id, instance, handler);
+    handler = tmp;
+  }
       while (handler);
 
       if (emission.state == EMISSION_STOP)
-    goto EMIT_CLEANUP;
+  goto EMIT_CLEANUP;
       else if (emission.state == EMISSION_RESTART)
-    goto EMIT_RESTART;
+  goto EMIT_RESTART;
     }
 
  EMIT_CLEANUP:
 
   emission.ihint.run_type = G_SIGNAL_RUN_CLEANUP;
@@ -3765,26 +3771,31 @@
       emission.state = EMISSION_STOP;
 
       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
       SIGNAL_UNLOCK ();
       if (node->return_type != G_TYPE_NONE && !accumulator)
-    {
-      g_value_init (&accu, node->return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE);
-      need_unset = TRUE;
-    }
+  {
+    g_value_init (&accu, node->return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE);
+    need_unset = TRUE;
+  }
       g_closure_invoke (class_closure,
-            node->return_type != G_TYPE_NONE ? &accu : NULL,
-            node->n_params + 1,
-            instance_and_params,
-            &emission.ihint);
+      node->return_type != G_TYPE_NONE ? &accu : NULL,
+      node->n_params + 1,
+      instance_and_params,
+      &emission.ihint);
+      if (!accumulate (&emission.ihint, emission_return, &accu, accumulator) &&
+          emission.state == EMISSION_RUN)
+        emission.state = EMISSION_STOP;
       if (need_unset)
-    g_value_unset (&accu);
+  g_value_unset (&accu);
       SIGNAL_LOCK ();
+      return_value_altered = TRUE;
+
       emission.chain_type = G_TYPE_NONE;
 
       if (emission.state == EMISSION_RESTART)
-    goto EMIT_RESTART;
+  goto EMIT_RESTART;
     }
 
   if (handler_list)
     handler_unref_R (signal_id, instance, handler_list);
 
@@ -3798,30 +3809,30 @@
   return return_value_altered;
 }
 
 static void
 add_invalid_closure_notify (Handler  *handler,
-                gpointer  instance)
+          gpointer  instance)
 {
   g_closure_add_invalidate_notifier (handler->closure, instance, invalid_closure_notify);
   handler->has_invalid_closure_notify = 1;
 }
 
 static void
 remove_invalid_closure_notify (Handler  *handler,
-                   gpointer  instance)
+             gpointer  instance)
 {
   if (handler->has_invalid_closure_notify)
     {
       g_closure_remove_invalidate_notifier (handler->closure, instance, invalid_closure_notify);
       handler->has_invalid_closure_notify = 0;
     }
 }
 
 static void
 invalid_closure_notify (gpointer  instance,
-                GClosure *closure)
+            GClosure *closure)
 {
   Handler *handler;
   guint signal_id;
 
   SIGNAL_LOCK ();
@@ -3873,13 +3884,13 @@
  *
  * Returns: standard #GSignalAccumulator result
  */
 gboolean
 g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
-                   GValue                *return_accu,
-                   const GValue          *handler_return,
-                   gpointer               dummy)
+           GValue                *return_accu,
+           const GValue          *handler_return,
+           gpointer               dummy)
 {
   gboolean continue_emission;
   gboolean signal_handled;
 
   signal_handled = g_value_get_boolean (handler_return);
@@ -3918,5 +3929,35 @@
                                  gpointer               dummy)
 {
   g_value_copy (handler_return, return_accu);
   return FALSE;
 }
+
+/**
+ * g_clear_signal_handler:
+ * @handler_id_ptr: A pointer to a handler ID (of type #gulong) of the handler to be disconnected.
+ * @instance: (type GObject.Object): The instance to remove the signal handler from.
+ *
+ * Disconnects a handler from @instance so it will not be called during
+ * any future or currently ongoing emissions of the signal it has been
+ * connected to. The @handler_id_ptr is then set to zero, which is never a valid handler ID value (see g_signal_connect()).
+ *
+ * If the handler ID is 0 then this function does nothing.
+ *
+ * A macro is also included that allows this function to be used without
+ * pointer casts.
+ *
+ * Since: 2.62
+ */
+#undef g_clear_signal_handler
+void
+g_clear_signal_handler (gulong   *handler_id_ptr,
+                        gpointer  instance)
+{
+  g_return_if_fail (handler_id_ptr != NULL);
+
+  if (*handler_id_ptr != 0)
+    {
+      g_signal_handler_disconnect (instance, *handler_id_ptr);
+      *handler_id_ptr = 0;
+    }
+}
