<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gspawn-win32-helper.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  50 #include &quot;gthread.h&quot;
  51 
  52 #include &lt;string.h&gt;
  53 #include &lt;stdlib.h&gt;
  54 #include &lt;stdio.h&gt;
  55 
  56 #include &lt;windows.h&gt;
  57 #include &lt;errno.h&gt;
  58 #include &lt;fcntl.h&gt;
  59 #include &lt;io.h&gt;
  60 #include &lt;process.h&gt;
  61 #include &lt;direct.h&gt;
  62 #include &lt;wchar.h&gt;
  63 
  64 #ifndef GSPAWN_HELPER
  65 #ifdef G_SPAWN_WIN32_DEBUG
  66   static int debug = 1;
  67   #define SETUP_DEBUG() /* empty */
  68 #else
  69   static int debug = -1;
<span class="line-modified">  70   #define SETUP_DEBUG()                 \</span>
<span class="line-modified">  71     G_STMT_START                    \</span>
<span class="line-modified">  72       {                         \</span>
<span class="line-modified">  73     if (debug == -1)                \</span>
<span class="line-modified">  74       {                     \</span>
<span class="line-modified">  75         if (getenv (&quot;G_SPAWN_WIN32_DEBUG&quot;) != NULL) \</span>
<span class="line-modified">  76           debug = 1;                \</span>
<span class="line-modified">  77         else                    \</span>
<span class="line-modified">  78           debug = 0;                \</span>
<span class="line-modified">  79       }                     \</span>
<span class="line-modified">  80       }                         \</span>
  81     G_STMT_END
  82 #endif
  83 #endif
  84 
  85 enum
  86 {
  87   CHILD_NO_ERROR,
  88   CHILD_CHDIR_FAILED,
  89   CHILD_SPAWN_FAILED,
  90   CHILD_SPAWN_NOENT,
  91 };
  92 
  93 enum {
  94   ARG_CHILD_ERR_REPORT = 1,
  95   ARG_HELPER_SYNC,
  96   ARG_STDIN,
  97   ARG_STDOUT,
  98   ARG_STDERR,
  99   ARG_WORKING_DIRECTORY,
 100   ARG_CLOSE_DESCRIPTORS,
 101   ARG_USE_PATH,
 102   ARG_WAIT,
 103   ARG_PROGRAM,
 104   ARG_COUNT = ARG_PROGRAM
 105 };
 106 
 107 static int
<span class="line-modified"> 108 dup_noninherited (int fd,</span>
<span class="line-modified"> 109           int mode)</span>
 110 {
 111   HANDLE filehandle;
 112 
 113   DuplicateHandle (GetCurrentProcess (), (LPHANDLE) _get_osfhandle (fd),
<span class="line-modified"> 114            GetCurrentProcess (), &amp;filehandle,</span>
<span class="line-modified"> 115            0, FALSE, DUPLICATE_SAME_ACCESS);</span>
 116   close (fd);
 117   return _open_osfhandle ((gintptr) filehandle, mode | _O_NOINHERIT);
 118 }
 119 
 120 #ifndef GSPAWN_HELPER
 121 
 122 #ifdef _WIN64
 123 #define HELPER_PROCESS &quot;gspawn-win64-helper&quot;
 124 #else
 125 #define HELPER_PROCESS &quot;gspawn-win32-helper&quot;
 126 #endif
 127 

 128 static gchar *
 129 protect_argv_string (const gchar *string)
 130 {
 131   const gchar *p = string;
 132   gchar *retval, *q;
 133   gint len = 0;

 134   gboolean need_dblquotes = FALSE;
 135   while (*p)
 136     {
 137       if (*p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="line-modified"> 138     need_dblquotes = TRUE;</span>
<span class="line-modified"> 139       else if (*p == &#39;&quot;&#39;)</span>
<span class="line-modified"> 140     len++;</span>
<span class="line-modified"> 141       else if (*p == &#39;\\&#39;)</span>
<span class="line-modified"> 142     {</span>
<span class="line-modified"> 143       const gchar *pp = p;</span>
<span class="line-removed"> 144       while (*pp &amp;&amp; *pp == &#39;\\&#39;)</span>
<span class="line-removed"> 145         pp++;</span>
<span class="line-removed"> 146       if (*pp == &#39;&quot;&#39;)</span>
<span class="line-removed"> 147         len++;</span>
<span class="line-removed"> 148     }</span>
<span class="line-removed"> 149       len++;</span>
 150       p++;
 151     }
 152 
 153   q = retval = g_malloc (len + need_dblquotes*2 + 1);
 154   p = string;
 155 
 156   if (need_dblquotes)
 157     *q++ = &#39;&quot;&#39;;
<span class="line-modified"> 158 </span>



 159   while (*p)
 160     {
 161       if (*p == &#39;&quot;&#39;)


 162     *q++ = &#39;\\&#39;;
<span class="line-modified"> 163       else if (*p == &#39;\\&#39;)</span>
<span class="line-modified"> 164     {</span>
<span class="line-modified"> 165       const gchar *pp = p;</span>
<span class="line-modified"> 166       while (*pp &amp;&amp; *pp == &#39;\\&#39;)</span>
<span class="line-modified"> 167         pp++;</span>
<span class="line-modified"> 168       if (*pp == &#39;&quot;&#39;)</span>
<span class="line-modified"> 169         *q++ = &#39;\\&#39;;</span>
<span class="line-modified"> 170     }</span>



 171       *q++ = *p;
 172       p++;
 173     }
 174 
 175   if (need_dblquotes)
<span class="line-modified"> 176     *q++ = &#39;&quot;&#39;;</span>







 177   *q++ = &#39;\0&#39;;
 178 
 179   return retval;
 180 }
 181 
 182 static gint
 183 protect_argv (gchar  **argv,
<span class="line-modified"> 184           gchar ***new_argv)</span>
 185 {
 186   gint i;
 187   gint argc = 0;
 188 
 189   while (argv[argc])
 190     ++argc;
 191   *new_argv = g_new (gchar *, argc+1);
 192 
 193   /* Quote each argv element if necessary, so that it will get
 194    * reconstructed correctly in the C runtime startup code.  Note that
 195    * the unquoting algorithm in the C runtime is really weird, and
 196    * rather different than what Unix shells do. See stdargv.c in the C
 197    * runtime sources (in the Platform SDK, in src/crt).
 198    *
<span class="line-modified"> 199    * Note that an new_argv[0] constructed by this function should</span>
 200    * *not* be passed as the filename argument to a spawn* or exec*
 201    * family function. That argument should be the real file name
 202    * without any quoting.
 203    */
 204   for (i = 0; i &lt; argc; i++)
 205     (*new_argv)[i] = protect_argv_string (argv[i]);
 206 
 207   (*new_argv)[argc] = NULL;
 208 
 209   return argc;
 210 }
 211 
 212 G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)
 213 G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)
 214 
 215 gboolean
 216 g_spawn_async (const gchar          *working_directory,
<span class="line-modified"> 217             gchar               **argv,</span>
<span class="line-modified"> 218             gchar               **envp,</span>
<span class="line-modified"> 219             GSpawnFlags           flags,</span>
<span class="line-modified"> 220             GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 221             gpointer              user_data,</span>
<span class="line-modified"> 222             GPid                 *child_handle,</span>
<span class="line-modified"> 223             GError              **error)</span>
 224 {
 225   g_return_val_if_fail (argv != NULL, FALSE);
 226 
 227   return g_spawn_async_with_pipes (working_directory,
<span class="line-modified"> 228                     argv, envp,</span>
<span class="line-modified"> 229                     flags,</span>
<span class="line-modified"> 230                     child_setup,</span>
<span class="line-modified"> 231                     user_data,</span>
<span class="line-modified"> 232                     child_handle,</span>
<span class="line-modified"> 233                     NULL, NULL, NULL,</span>
<span class="line-modified"> 234                     error);</span>
 235 }
 236 
 237 /* Avoids a danger in threaded situations (calling close()
 238  * on a file descriptor twice, and another thread has
 239  * re-opened it since the first close)
 240  */
 241 static void
 242 close_and_invalidate (gint *fd)
 243 {
 244   if (*fd &lt; 0)
 245     return;
 246 
 247   close (*fd);
 248   *fd = -1;
 249 }
 250 
 251 typedef enum
 252 {
 253   READ_FAILED = 0, /* FALSE */
 254   READ_OK,
</pre>
<hr />
<pre>
 293            GError **error)
 294 {
 295   if (_pipe (p, 4096, _O_BINARY) &lt; 0)
 296     {
 297       int errsv = errno;
 298 
 299       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 300                    _(&quot;Failed to create pipe for communicating with child process (%s)&quot;),
 301                    g_strerror (errsv));
 302       return FALSE;
 303     }
 304   else
 305     return TRUE;
 306 }
 307 
 308 /* The helper process writes a status report back to us, through a
 309  * pipe, consisting of two ints.
 310  */
 311 static gboolean
 312 read_helper_report (int      fd,
<span class="line-modified"> 313             gintptr  report[2],</span>
<span class="line-modified"> 314             GError **error)</span>
 315 {
 316   gint bytes = 0;
 317 
 318   while (bytes &lt; sizeof(gintptr)*2)
 319     {
 320       gint chunk;
 321       int errsv;
 322 
 323       if (debug)
<span class="line-modified"> 324     g_print (&quot;%s:read_helper_report: read %&quot; G_GSIZE_FORMAT &quot;...\n&quot;,</span>
<span class="line-modified"> 325          __FILE__,</span>
<span class="line-modified"> 326          sizeof(gintptr)*2 - bytes);</span>
 327 
 328       chunk = read (fd, ((gchar*)report) + bytes,
<span class="line-modified"> 329             sizeof(gintptr)*2 - bytes);</span>
 330       errsv = errno;
 331 
 332       if (debug)
<span class="line-modified"> 333     g_print (&quot;...got %d bytes\n&quot;, chunk);</span>
 334 
 335       if (chunk &lt; 0)
 336         {
 337           /* Some weird shit happened, bail out */
 338           g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 339                        _(&quot;Failed to read from child pipe (%s)&quot;),
 340                        g_strerror (errsv));
 341 
 342           return FALSE;
 343         }
 344       else if (chunk == 0)
<span class="line-modified"> 345     {</span>
<span class="line-modified"> 346       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,</span>
<span class="line-modified"> 347                _(&quot;Failed to read from child pipe (%s)&quot;),</span>
<span class="line-modified"> 348                &quot;EOF&quot;);</span>
<span class="line-modified"> 349       break; /* EOF */</span>
<span class="line-modified"> 350     }</span>
 351       else
<span class="line-modified"> 352     bytes += chunk;</span>
 353     }
 354 
 355   if (bytes &lt; sizeof(gintptr)*2)
 356     return FALSE;
 357 
 358   return TRUE;
 359 }
 360 
 361 static void
 362 set_child_error (gintptr      report[2],
<span class="line-modified"> 363          const gchar *working_directory,</span>
<span class="line-modified"> 364          GError     **error)</span>
 365 {
 366   switch (report[0])
 367     {
 368     case CHILD_CHDIR_FAILED:
 369       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,
<span class="line-modified"> 370            _(&quot;Failed to change to directory &#39;%s&#39; (%s)&quot;),</span>
<span class="line-modified"> 371            working_directory,</span>
<span class="line-modified"> 372            g_strerror (report[1]));</span>
 373       break;
 374     case CHILD_SPAWN_FAILED:
 375       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 376            _(&quot;Failed to execute child process (%s)&quot;),</span>
<span class="line-modified"> 377            g_strerror (report[1]));</span>
 378       break;
 379     case CHILD_SPAWN_NOENT:
 380       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT,
 381                    _(&quot;Failed to execute child process (%s)&quot;),
 382                    g_strerror (report[1]));
 383       break;
 384     default:
 385       g_assert_not_reached ();
 386     }
 387 }
 388 
 389 static gboolean
 390 utf8_charv_to_wcharv (char     **utf8_charv,
<span class="line-modified"> 391               wchar_t ***wcharv,</span>
<span class="line-modified"> 392               int       *error_index,</span>
<span class="line-modified"> 393               GError   **error)</span>
 394 {
 395   wchar_t **retval = NULL;
 396 
 397   *wcharv = NULL;
 398   if (utf8_charv != NULL)
 399     {
 400       int n = 0, i;
 401 
 402       while (utf8_charv[n])
<span class="line-modified"> 403     n++;</span>
 404       retval = g_new (wchar_t *, n + 1);
 405 
 406       for (i = 0; i &lt; n; i++)
<span class="line-modified"> 407     {</span>
<span class="line-modified"> 408       retval[i] = g_utf8_to_utf16 (utf8_charv[i], -1, NULL, NULL, error);</span>
<span class="line-modified"> 409       if (retval[i] == NULL)</span>
<span class="line-modified"> 410         {</span>
<span class="line-modified"> 411           if (error_index)</span>
<span class="line-modified"> 412         *error_index = i;</span>
<span class="line-modified"> 413           while (i)</span>
<span class="line-modified"> 414         g_free (retval[--i]);</span>
<span class="line-modified"> 415           g_free (retval);</span>
<span class="line-modified"> 416           return FALSE;</span>
<span class="line-modified"> 417         }</span>
<span class="line-modified"> 418     }</span>
 419 
 420       retval[n] = NULL;
 421     }
 422   *wcharv = retval;
 423   return TRUE;
 424 }
 425 
 426 static gboolean
 427 do_spawn_directly (gint                 *exit_status,
<span class="line-modified"> 428            gboolean      do_return_handle,</span>
<span class="line-modified"> 429                    GSpawnFlags           flags,</span>
<span class="line-modified"> 430                    gchar               **argv,</span>
<span class="line-modified"> 431                    char                **envp,</span>
<span class="line-modified"> 432                    char                **protected_argv,</span>
<span class="line-modified"> 433                    GPid                 *child_handle,</span>
<span class="line-modified"> 434                    GError              **error)</span>
 435 {
 436   const int mode = (exit_status == NULL) ? P_NOWAIT : P_WAIT;
 437   char **new_argv;
 438   gintptr rc = -1;
 439   int errsv;
 440   GError *conv_error = NULL;
 441   gint conv_error_index;
 442   wchar_t *wargv0, **wargv, **wenvp;
 443 
 444   new_argv = (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO) ? protected_argv + 1 : protected_argv;
 445 
 446   wargv0 = g_utf8_to_utf16 (argv[0], -1, NULL, NULL, &amp;conv_error);
 447   if (wargv0 == NULL)
 448     {
 449       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 450            _(&quot;Invalid program name: %s&quot;),</span>
<span class="line-modified"> 451            conv_error-&gt;message);</span>
 452       g_error_free (conv_error);
 453 
 454       return FALSE;
 455     }
 456 
 457   if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
 458     {
 459       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 460            _(&quot;Invalid string in argument vector at %d: %s&quot;),</span>
<span class="line-modified"> 461            conv_error_index, conv_error-&gt;message);</span>
 462       g_error_free (conv_error);
 463       g_free (wargv0);
 464 
 465       return FALSE;
 466     }
 467 
 468   if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
 469     {
 470       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 471            _(&quot;Invalid string in environment: %s&quot;),</span>
<span class="line-modified"> 472            conv_error-&gt;message);</span>
 473       g_error_free (conv_error);
 474       g_free (wargv0);
 475       g_strfreev ((gchar **) wargv);
 476 
 477       return FALSE;
 478     }
 479 
 480   if (flags &amp; G_SPAWN_SEARCH_PATH)
 481     if (wenvp != NULL)
 482       rc = _wspawnvpe (mode, wargv0, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 483     else
 484       rc = _wspawnvp (mode, wargv0, (const wchar_t **) wargv);
 485   else
 486     if (wenvp != NULL)
 487       rc = _wspawnve (mode, wargv0, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 488     else
 489       rc = _wspawnv (mode, wargv0, (const wchar_t **) wargv);
 490 
 491   errsv = errno;
 492 
 493   g_free (wargv0);
 494   g_strfreev ((gchar **) wargv);
 495   g_strfreev ((gchar **) wenvp);
 496 
 497   if (rc == -1 &amp;&amp; errsv != 0)
 498     {
 499       g_set_error (error, G_SPAWN_ERROR, _g_spawn_exec_err_to_g_error (errsv),
<span class="line-modified"> 500                    _(&quot;Failed to execute child process (%s)&quot;),</span>
<span class="line-modified"> 501            g_strerror (errsv));</span>
 502       return FALSE;
 503     }
 504 
 505   if (exit_status == NULL)
 506     {
 507       if (child_handle &amp;&amp; do_return_handle)
<span class="line-modified"> 508     *child_handle = (GPid) rc;</span>
 509       else
<span class="line-modified"> 510     {</span>
<span class="line-modified"> 511       CloseHandle ((HANDLE) rc);</span>
<span class="line-modified"> 512       if (child_handle)</span>
<span class="line-modified"> 513         *child_handle = 0;</span>
<span class="line-modified"> 514     }</span>
 515     }
 516   else
 517     *exit_status = rc;
 518 
 519   return TRUE;
 520 }
 521 
 522 static gboolean
 523 do_spawn_with_fds (gint                 *exit_status,
<span class="line-modified"> 524            gboolean        do_return_handle,</span>
<span class="line-modified"> 525                    const gchar          *working_directory,</span>
<span class="line-modified"> 526                    gchar               **argv,</span>
<span class="line-modified"> 527                    char                **envp,</span>
<span class="line-modified"> 528                    GSpawnFlags           flags,</span>
<span class="line-modified"> 529                    GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 530                    GPid                 *child_handle,</span>
<span class="line-modified"> 531            gint                  stdin_fd,</span>
<span class="line-modified"> 532            gint                  stdout_fd,</span>
<span class="line-modified"> 533            gint                  stderr_fd,</span>
<span class="line-modified"> 534            gint       *err_report,</span>
<span class="line-modified"> 535                    GError              **error)</span>
 536 {
 537   char **protected_argv;
 538   char args[ARG_COUNT][10];
 539   char **new_argv;
 540   int i;
 541   gintptr rc = -1;
 542   int errsv;
 543   int argc;
 544   int child_err_report_pipe[2] = { -1, -1 };
 545   int helper_sync_pipe[2] = { -1, -1 };
 546   gintptr helper_report[2];
 547   static gboolean warned_about_child_setup = FALSE;
 548   GError *conv_error = NULL;
 549   gint conv_error_index;
 550   gchar *helper_process;
 551   wchar_t *whelper, **wargv, **wenvp;
 552   gchar *glib_dll_directory;
 553 
 554   if (child_setup &amp;&amp; !warned_about_child_setup)
 555     {
 556       warned_about_child_setup = TRUE;
 557       g_warning (&quot;passing a child setup function to the g_spawn functions is pointless on Windows and it is ignored&quot;);
 558     }
 559 
 560   argc = protect_argv (argv, &amp;protected_argv);
 561 
 562   if (stdin_fd == -1 &amp;&amp; stdout_fd == -1 &amp;&amp; stderr_fd == -1 &amp;&amp;
 563       (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN) &amp;&amp;
 564       !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL) &amp;&amp;
 565       !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL) &amp;&amp;
 566       (working_directory == NULL || !*working_directory) &amp;&amp;
 567       (flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
 568     {
 569       /* We can do without the helper process */
 570       gboolean retval =
<span class="line-modified"> 571     do_spawn_directly (exit_status, do_return_handle, flags,</span>
<span class="line-modified"> 572                argv, envp, protected_argv,</span>
<span class="line-modified"> 573                child_handle, error);</span>
 574       g_strfreev (protected_argv);
 575       return retval;
 576     }
 577 
 578   if (!make_pipe (child_err_report_pipe, error))
 579     goto cleanup_and_fail;
 580 
 581   if (!make_pipe (helper_sync_pipe, error))
 582     goto cleanup_and_fail;
 583 
 584   new_argv = g_new (char *, argc + 1 + ARG_COUNT);
 585   if (GetConsoleWindow () != NULL)
 586     helper_process = HELPER_PROCESS &quot;-console.exe&quot;;
 587   else
 588     helper_process = HELPER_PROCESS &quot;.exe&quot;;
 589 
 590   glib_dll_directory = _glib_get_dll_directory ();
 591   if (glib_dll_directory != NULL)
 592     {
 593       helper_process = g_build_filename (glib_dll_directory, helper_process, NULL);
 594       g_free (glib_dll_directory);
 595     }
 596   else
 597     helper_process = g_strdup (helper_process);
 598 
 599   new_argv[0] = protect_argv_string (helper_process);
 600 
 601   _g_sprintf (args[ARG_CHILD_ERR_REPORT], &quot;%d&quot;, child_err_report_pipe[1]);
 602   new_argv[ARG_CHILD_ERR_REPORT] = args[ARG_CHILD_ERR_REPORT];
 603 
 604   /* Make the read end of the child error report pipe
 605    * noninherited. Otherwise it will needlessly be inherited by the
 606    * helper process, and the started actual user process. As such that
 607    * shouldn&#39;t harm, but it is unnecessary.
 608    */
<span class="line-modified"> 609   child_err_report_pipe[0] = dup_noninherited (child_err_report_pipe[0], _O_RDONLY);</span>
 610 
 611   if (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO)
 612     {
 613       /* Overload ARG_CHILD_ERR_REPORT to also encode the
 614        * G_SPAWN_FILE_AND_ARGV_ZERO functionality.
 615        */
 616       strcat (args[ARG_CHILD_ERR_REPORT], &quot;#&quot;);
 617     }
 618 
 619   _g_sprintf (args[ARG_HELPER_SYNC], &quot;%d&quot;, helper_sync_pipe[0]);
 620   new_argv[ARG_HELPER_SYNC] = args[ARG_HELPER_SYNC];
 621 
 622   /* Make the write end of the sync pipe noninherited. Otherwise the
 623    * helper process will inherit it, and thus if this process happens
 624    * to crash before writing the sync byte to the pipe, the helper
 625    * process won&#39;t read but won&#39;t get any EOF either, as it has the
 626    * write end open itself.
 627    */
<span class="line-modified"> 628   helper_sync_pipe[1] = dup_noninherited (helper_sync_pipe[1], _O_WRONLY);</span>
 629 
 630   if (stdin_fd != -1)
 631     {
 632       _g_sprintf (args[ARG_STDIN], &quot;%d&quot;, stdin_fd);
 633       new_argv[ARG_STDIN] = args[ARG_STDIN];
 634     }
 635   else if (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN)
 636     {
 637       /* Let stdin be alone */
 638       new_argv[ARG_STDIN] = &quot;-&quot;;
 639     }
 640   else
 641     {
 642       /* Keep process from blocking on a read of stdin */
 643       new_argv[ARG_STDIN] = &quot;z&quot;;
 644     }
 645 
 646   if (stdout_fd != -1)
 647     {
 648       _g_sprintf (args[ARG_STDOUT], &quot;%d&quot;, stdout_fd);
 649       new_argv[ARG_STDOUT] = args[ARG_STDOUT];
 650     }
 651   else if (flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL)
 652     {
 653       new_argv[ARG_STDOUT] = &quot;z&quot;;
 654     }
 655   else
 656     {
 657       new_argv[ARG_STDOUT] = &quot;-&quot;;
 658     }
 659 
<span class="line-modified"> 660   if (stdout_fd != -1)</span>
 661     {
 662       _g_sprintf (args[ARG_STDERR], &quot;%d&quot;, stderr_fd);
 663       new_argv[ARG_STDERR] = args[ARG_STDERR];
 664     }
 665   else if (flags &amp; G_SPAWN_STDERR_TO_DEV_NULL)
 666     {
 667       new_argv[ARG_STDERR] = &quot;z&quot;;
 668     }
 669   else
 670     {
 671       new_argv[ARG_STDERR] = &quot;-&quot;;
 672     }
 673 
 674   if (working_directory &amp;&amp; *working_directory)
 675     new_argv[ARG_WORKING_DIRECTORY] = protect_argv_string (working_directory);
 676   else
 677     new_argv[ARG_WORKING_DIRECTORY] = g_strdup (&quot;-&quot;);
 678 
 679   if (!(flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
 680     new_argv[ARG_CLOSE_DESCRIPTORS] = &quot;y&quot;;
</pre>
<hr />
<pre>
 683 
 684   if (flags &amp; G_SPAWN_SEARCH_PATH)
 685     new_argv[ARG_USE_PATH] = &quot;y&quot;;
 686   else
 687     new_argv[ARG_USE_PATH] = &quot;-&quot;;
 688 
 689   if (exit_status == NULL)
 690     new_argv[ARG_WAIT] = &quot;-&quot;;
 691   else
 692     new_argv[ARG_WAIT] = &quot;w&quot;;
 693 
 694   for (i = 0; i &lt;= argc; i++)
 695     new_argv[ARG_PROGRAM + i] = protected_argv[i];
 696 
 697   SETUP_DEBUG();
 698 
 699   if (debug)
 700     {
 701       g_print (&quot;calling %s with argv:\n&quot;, helper_process);
 702       for (i = 0; i &lt; argc + 1 + ARG_COUNT; i++)
<span class="line-modified"> 703     g_print (&quot;argv[%d]: %s\n&quot;, i, (new_argv[i] ? new_argv[i] : &quot;NULL&quot;));</span>
 704     }
 705 
 706   if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
 707     {
 708       if (conv_error_index == ARG_WORKING_DIRECTORY)
<span class="line-modified"> 709     g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,</span>
<span class="line-modified"> 710              _(&quot;Invalid working directory: %s&quot;),</span>
<span class="line-modified"> 711              conv_error-&gt;message);</span>
 712       else
<span class="line-modified"> 713     g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,</span>
<span class="line-modified"> 714              _(&quot;Invalid string in argument vector at %d: %s&quot;),</span>
<span class="line-modified"> 715              conv_error_index - ARG_PROGRAM, conv_error-&gt;message);</span>
 716       g_error_free (conv_error);
 717       g_strfreev (protected_argv);
 718       g_free (new_argv[0]);
 719       g_free (new_argv[ARG_WORKING_DIRECTORY]);
 720       g_free (new_argv);
 721       g_free (helper_process);
 722 
 723       goto cleanup_and_fail;
 724     }
 725 
 726   if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
 727     {
 728       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 729            _(&quot;Invalid string in environment: %s&quot;),</span>
<span class="line-modified"> 730            conv_error-&gt;message);</span>
 731       g_error_free (conv_error);
 732       g_strfreev (protected_argv);
 733       g_free (new_argv[0]);
 734       g_free (new_argv[ARG_WORKING_DIRECTORY]);
 735       g_free (new_argv);
 736       g_free (helper_process);
 737       g_strfreev ((gchar **) wargv);
 738 
 739       goto cleanup_and_fail;
 740     }
 741 
 742   whelper = g_utf8_to_utf16 (helper_process, -1, NULL, NULL, NULL);
 743   g_free (helper_process);
 744 
 745   if (wenvp != NULL)
 746     rc = _wspawnvpe (P_NOWAIT, whelper, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 747   else
 748     rc = _wspawnvp (P_NOWAIT, whelper, (const wchar_t **) wargv);
 749 
 750   errsv = errno;
</pre>
<hr />
<pre>
 752   g_free (whelper);
 753   g_strfreev ((gchar **) wargv);
 754   g_strfreev ((gchar **) wenvp);
 755 
 756   /* Close the other process&#39;s ends of the pipes in this process,
 757    * otherwise the reader will never get EOF.
 758    */
 759   close_and_invalidate (&amp;child_err_report_pipe[1]);
 760   close_and_invalidate (&amp;helper_sync_pipe[0]);
 761 
 762   g_strfreev (protected_argv);
 763 
 764   g_free (new_argv[0]);
 765   g_free (new_argv[ARG_WORKING_DIRECTORY]);
 766   g_free (new_argv);
 767 
 768   /* Check if gspawn-win32-helper couldn&#39;t be run */
 769   if (rc == -1 &amp;&amp; errsv != 0)
 770     {
 771       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 772                    _(&quot;Failed to execute helper program (%s)&quot;),</span>
<span class="line-modified"> 773            g_strerror (errsv));</span>
 774       goto cleanup_and_fail;
 775     }
 776 
 777   if (exit_status != NULL)
 778     {
 779       /* Synchronous case. Pass helper&#39;s report pipe back to caller,
 780        * which takes care of reading it after the grandchild has
 781        * finished.
 782        */
 783       g_assert (err_report != NULL);
 784       *err_report = child_err_report_pipe[0];
 785       write (helper_sync_pipe[1], &quot; &quot;, 1);
 786       close_and_invalidate (&amp;helper_sync_pipe[1]);
 787     }
 788   else
 789     {
 790       /* Asynchronous case. We read the helper&#39;s report right away. */
 791       if (!read_helper_report (child_err_report_pipe[0], helper_report, error))
<span class="line-modified"> 792     goto cleanup_and_fail;</span>
 793 
 794       close_and_invalidate (&amp;child_err_report_pipe[0]);
 795 
 796       switch (helper_report[0])











 797     {
<span class="line-modified"> 798     case CHILD_NO_ERROR:</span>
<span class="line-modified"> 799       if (child_handle &amp;&amp; do_return_handle)</span>
<span class="line-modified"> 800         {</span>
<span class="line-removed"> 801           /* rc is our HANDLE for gspawn-win32-helper. It has</span>
<span class="line-removed"> 802            * told us the HANDLE of its child. Duplicate that into</span>
<span class="line-removed"> 803            * a HANDLE valid in this process.</span>
<span class="line-removed"> 804            */</span>
<span class="line-removed"> 805           if (!DuplicateHandle ((HANDLE) rc, (HANDLE) helper_report[1],</span>
<span class="line-removed"> 806                     GetCurrentProcess (), (LPHANDLE) child_handle,</span>
<span class="line-removed"> 807                     0, TRUE, DUPLICATE_SAME_ACCESS))</span>
<span class="line-removed"> 808         {</span>
<span class="line-removed"> 809           char *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-removed"> 810           g_print(&quot;%s\n&quot;, emsg);</span>
<span class="line-removed"> 811           *child_handle = 0;</span>
<span class="line-removed"> 812         }</span>
<span class="line-removed"> 813         }</span>
<span class="line-removed"> 814       else if (child_handle)</span>
<span class="line-removed"> 815         *child_handle = 0;</span>
<span class="line-removed"> 816       write (helper_sync_pipe[1], &quot; &quot;, 1);</span>
<span class="line-removed"> 817       close_and_invalidate (&amp;helper_sync_pipe[1]);</span>
<span class="line-removed"> 818       break;</span>
<span class="line-removed"> 819 </span>
<span class="line-removed"> 820     default:</span>
<span class="line-removed"> 821       write (helper_sync_pipe[1], &quot; &quot;, 1);</span>
<span class="line-removed"> 822       close_and_invalidate (&amp;helper_sync_pipe[1]);</span>
<span class="line-removed"> 823       set_child_error (helper_report, working_directory, error);</span>
<span class="line-removed"> 824       goto cleanup_and_fail;</span>
 825     }













 826     }
 827 
 828   /* Success against all odds! return the information */
 829 
 830   if (rc != -1)
 831     CloseHandle ((HANDLE) rc);
 832 
 833   return TRUE;
 834 
 835  cleanup_and_fail:
 836 
 837   if (rc != -1)
 838     CloseHandle ((HANDLE) rc);
 839   if (child_err_report_pipe[0] != -1)
 840     close (child_err_report_pipe[0]);
 841   if (child_err_report_pipe[1] != -1)
 842     close (child_err_report_pipe[1]);
 843   if (helper_sync_pipe[0] != -1)
 844     close (helper_sync_pipe[0]);
 845   if (helper_sync_pipe[1] != -1)
 846     close (helper_sync_pipe[1]);
 847 
 848   return FALSE;
 849 }
 850 
 851 static gboolean
 852 do_spawn_with_pipes (gint                 *exit_status,
<span class="line-modified"> 853              gboolean          do_return_handle,</span>
<span class="line-modified"> 854              const gchar          *working_directory,</span>
<span class="line-modified"> 855              gchar               **argv,</span>
<span class="line-modified"> 856              char                **envp,</span>
<span class="line-modified"> 857              GSpawnFlags           flags,</span>
<span class="line-modified"> 858              GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 859              GPid                 *child_handle,</span>
<span class="line-modified"> 860              gint                 *standard_input,</span>
<span class="line-modified"> 861              gint                 *standard_output,</span>
<span class="line-modified"> 862              gint                 *standard_error,</span>
<span class="line-modified"> 863              gint         *err_report,</span>
<span class="line-modified"> 864              GError              **error)</span>
 865 {
 866   int stdin_pipe[2] = { -1, -1 };
 867   int stdout_pipe[2] = { -1, -1 };
 868   int stderr_pipe[2] = { -1, -1 };
 869 
 870   if (standard_input &amp;&amp; !make_pipe (stdin_pipe, error))
 871     goto cleanup_and_fail;
 872 
 873   if (standard_output &amp;&amp; !make_pipe (stdout_pipe, error))
 874     goto cleanup_and_fail;
 875 
 876   if (standard_error &amp;&amp; !make_pipe (stderr_pipe, error))
 877     goto cleanup_and_fail;
 878 
 879   if (!do_spawn_with_fds (exit_status,
<span class="line-modified"> 880               do_return_handle,</span>
<span class="line-modified"> 881               working_directory,</span>
<span class="line-modified"> 882               argv,</span>
<span class="line-modified"> 883               envp,</span>
<span class="line-modified"> 884               flags,</span>
<span class="line-modified"> 885               child_setup,</span>
<span class="line-modified"> 886               child_handle,</span>
<span class="line-modified"> 887               stdin_pipe[0],</span>
<span class="line-modified"> 888               stdout_pipe[1],</span>
<span class="line-modified"> 889               stderr_pipe[1],</span>
<span class="line-modified"> 890               err_report,</span>
<span class="line-modified"> 891               error))</span>
 892     goto cleanup_and_fail;
 893 
 894   /* Close the other process&#39;s ends of the pipes in this process,
 895    * otherwise the reader will never get EOF.
 896    */
 897   close_and_invalidate (&amp;stdin_pipe[0]);
 898   close_and_invalidate (&amp;stdout_pipe[1]);
 899   close_and_invalidate (&amp;stderr_pipe[1]);
 900 
 901   if (standard_input)
 902     *standard_input = stdin_pipe[1];
 903   if (standard_output)
 904     *standard_output = stdout_pipe[0];
 905   if (standard_error)
 906     *standard_error = stderr_pipe[0];
 907 
 908   return TRUE;
 909 
 910  cleanup_and_fail:
 911 
 912   if (stdin_pipe[0] != -1)
 913     close (stdin_pipe[0]);
 914   if (stdin_pipe[1] != -1)
 915     close (stdin_pipe[1]);
 916   if (stdout_pipe[0] != -1)
 917     close (stdout_pipe[0]);
 918   if (stdout_pipe[1] != -1)
 919     close (stdout_pipe[1]);
 920   if (stderr_pipe[0] != -1)
 921     close (stderr_pipe[0]);
 922   if (stderr_pipe[1] != -1)
 923     close (stderr_pipe[1]);
 924 
 925   return FALSE;
 926 }
 927 
 928 gboolean
 929 g_spawn_sync (const gchar          *working_directory,
<span class="line-modified"> 930            gchar               **argv,</span>
<span class="line-modified"> 931            gchar               **envp,</span>
<span class="line-modified"> 932            GSpawnFlags           flags,</span>
<span class="line-modified"> 933            GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 934            gpointer              user_data,</span>
<span class="line-modified"> 935            gchar               **standard_output,</span>
<span class="line-modified"> 936            gchar               **standard_error,</span>
<span class="line-modified"> 937            gint                 *exit_status,</span>
<span class="line-modified"> 938            GError              **error)</span>
 939 {
 940   gint outpipe = -1;
 941   gint errpipe = -1;
 942   gint reportpipe = -1;
 943   GIOChannel *outchannel = NULL;
 944   GIOChannel *errchannel = NULL;
 945   GPollFD outfd, errfd;
 946   GPollFD fds[2];
 947   gint nfds;
 948   gint outindex = -1;
 949   gint errindex = -1;
 950   gint ret;
 951   GString *outstr = NULL;
 952   GString *errstr = NULL;
 953   gboolean failed;
 954   gint status;
 955 
 956   g_return_val_if_fail (argv != NULL, FALSE);
 957   g_return_val_if_fail (!(flags &amp; G_SPAWN_DO_NOT_REAP_CHILD), FALSE);
 958   g_return_val_if_fail (standard_output == NULL ||
 959                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
 960   g_return_val_if_fail (standard_error == NULL ||
 961                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
 962 
 963   /* Just to ensure segfaults if callers try to use
 964    * these when an error is reported.
 965    */
 966   if (standard_output)
 967     *standard_output = NULL;
 968 
 969   if (standard_error)
 970     *standard_error = NULL;
 971 
 972   if (!do_spawn_with_pipes (&amp;status,
<span class="line-modified"> 973                 FALSE,</span>
<span class="line-modified"> 974                 working_directory,</span>
<span class="line-modified"> 975                 argv,</span>
<span class="line-modified"> 976                 envp,</span>
<span class="line-modified"> 977                 flags,</span>
<span class="line-modified"> 978                 child_setup,</span>
<span class="line-modified"> 979                 NULL,</span>
<span class="line-modified"> 980                 NULL,</span>
<span class="line-modified"> 981                 standard_output ? &amp;outpipe : NULL,</span>
<span class="line-modified"> 982                 standard_error ? &amp;errpipe : NULL,</span>
<span class="line-modified"> 983                 &amp;reportpipe,</span>
<span class="line-modified"> 984                 error))</span>
 985     return FALSE;
 986 
 987   /* Read data from child. */
 988 
 989   failed = FALSE;
 990 
 991   if (outpipe &gt;= 0)
 992     {
 993       outstr = g_string_new (NULL);
 994       outchannel = g_io_channel_win32_new_fd (outpipe);
 995       g_io_channel_set_encoding (outchannel, NULL, NULL);
 996       g_io_channel_set_buffered (outchannel, FALSE);
 997       g_io_channel_win32_make_pollfd (outchannel,
<span class="line-modified"> 998                       G_IO_IN | G_IO_ERR | G_IO_HUP,</span>
<span class="line-modified"> 999                       &amp;outfd);</span>
1000       if (debug)
<span class="line-modified">1001     g_print (&quot;outfd=%p\n&quot;, (HANDLE) outfd.fd);</span>
1002     }
1003 
1004   if (errpipe &gt;= 0)
1005     {
1006       errstr = g_string_new (NULL);
1007       errchannel = g_io_channel_win32_new_fd (errpipe);
1008       g_io_channel_set_encoding (errchannel, NULL, NULL);
1009       g_io_channel_set_buffered (errchannel, FALSE);
1010       g_io_channel_win32_make_pollfd (errchannel,
<span class="line-modified">1011                       G_IO_IN | G_IO_ERR | G_IO_HUP,</span>
<span class="line-modified">1012                       &amp;errfd);</span>
1013       if (debug)
<span class="line-modified">1014     g_print (&quot;errfd=%p\n&quot;, (HANDLE) errfd.fd);</span>
1015     }
1016 
1017   /* Read data until we get EOF on all pipes. */
1018   while (!failed &amp;&amp; (outpipe &gt;= 0 || errpipe &gt;= 0))
1019     {
1020       nfds = 0;
1021       if (outpipe &gt;= 0)
<span class="line-modified">1022     {</span>
<span class="line-modified">1023       fds[nfds] = outfd;</span>
<span class="line-modified">1024       outindex = nfds;</span>
<span class="line-modified">1025       nfds++;</span>
<span class="line-modified">1026     }</span>
1027       if (errpipe &gt;= 0)
<span class="line-modified">1028     {</span>
<span class="line-modified">1029       fds[nfds] = errfd;</span>
<span class="line-modified">1030       errindex = nfds;</span>
<span class="line-modified">1031       nfds++;</span>
<span class="line-modified">1032     }</span>
1033 
1034       if (debug)
<span class="line-modified">1035     g_print (&quot;g_spawn_sync: calling g_io_channel_win32_poll, nfds=%d\n&quot;,</span>
<span class="line-modified">1036          nfds);</span>
1037 
1038       ret = g_io_channel_win32_poll (fds, nfds, -1);
1039 
1040       if (ret &lt; 0)
1041         {
1042           failed = TRUE;
1043 
1044           g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_READ,
1045                                _(&quot;Unexpected error in g_io_channel_win32_poll() reading data from a child process&quot;));
1046 
1047           break;
1048         }
1049 
1050       if (outpipe &gt;= 0 &amp;&amp; (fds[outindex].revents &amp; G_IO_IN))
1051         {
1052           switch (read_data (outstr, outchannel, error))
1053             {
1054             case READ_FAILED:
<span class="line-modified">1055           if (debug)</span>
<span class="line-modified">1056         g_print (&quot;g_spawn_sync: outchannel: READ_FAILED\n&quot;);</span>
1057               failed = TRUE;
1058               break;
1059             case READ_EOF:
<span class="line-modified">1060           if (debug)</span>
<span class="line-modified">1061         g_print (&quot;g_spawn_sync: outchannel: READ_EOF\n&quot;);</span>
1062               g_io_channel_unref (outchannel);
<span class="line-modified">1063           outchannel = NULL;</span>
1064               close_and_invalidate (&amp;outpipe);
1065               break;
1066             default:
<span class="line-modified">1067           if (debug)</span>
<span class="line-modified">1068         g_print (&quot;g_spawn_sync: outchannel: OK\n&quot;);</span>
1069               break;
1070             }
1071 
1072           if (failed)
1073             break;
1074         }
1075 
1076       if (errpipe &gt;= 0 &amp;&amp; (fds[errindex].revents &amp; G_IO_IN))
1077         {
1078           switch (read_data (errstr, errchannel, error))
1079             {
1080             case READ_FAILED:
<span class="line-modified">1081           if (debug)</span>
<span class="line-modified">1082         g_print (&quot;g_spawn_sync: errchannel: READ_FAILED\n&quot;);</span>
1083               failed = TRUE;
1084               break;
1085             case READ_EOF:
<span class="line-modified">1086           if (debug)</span>
<span class="line-modified">1087         g_print (&quot;g_spawn_sync: errchannel: READ_EOF\n&quot;);</span>
<span class="line-modified">1088           g_io_channel_unref (errchannel);</span>
<span class="line-modified">1089           errchannel = NULL;</span>
1090               close_and_invalidate (&amp;errpipe);
1091               break;
1092             default:
<span class="line-modified">1093           if (debug)</span>
<span class="line-modified">1094         g_print (&quot;g_spawn_sync: errchannel: OK\n&quot;);</span>
1095               break;
1096             }
1097 
1098           if (failed)
1099             break;
1100         }
1101     }
1102 
1103   if (reportpipe == -1)
1104     {
1105       /* No helper process, exit status of actual spawned process
1106        * already available.
1107        */
1108       if (exit_status)
1109         *exit_status = status;
1110     }
1111   else
1112     {
1113       /* Helper process was involved. Read its report now after the
1114        * grandchild has finished.
1115        */
1116       gintptr helper_report[2];
1117 
1118       if (!read_helper_report (reportpipe, helper_report, error))
<span class="line-modified">1119     failed = TRUE;</span>
1120       else
<span class="line-modified">1121     {</span>
<span class="line-modified">1122       switch (helper_report[0])</span>
<span class="line-modified">1123         {</span>
<span class="line-modified">1124         case CHILD_NO_ERROR:</span>
<span class="line-modified">1125           if (exit_status)</span>
<span class="line-modified">1126         *exit_status = helper_report[1];</span>
<span class="line-modified">1127           break;</span>
<span class="line-modified">1128         default:</span>
<span class="line-modified">1129           set_child_error (helper_report, working_directory, error);</span>
<span class="line-modified">1130           failed = TRUE;</span>
<span class="line-modified">1131           break;</span>
<span class="line-modified">1132         }</span>
<span class="line-modified">1133     }</span>
1134       close_and_invalidate (&amp;reportpipe);
1135     }
1136 
1137 
1138   /* These should only be open still if we had an error.  */
1139 
1140   if (outchannel != NULL)
1141     g_io_channel_unref (outchannel);
1142   if (errchannel != NULL)
1143     g_io_channel_unref (errchannel);
1144   if (outpipe &gt;= 0)
1145     close_and_invalidate (&amp;outpipe);
1146   if (errpipe &gt;= 0)
1147     close_and_invalidate (&amp;errpipe);
1148 
1149   if (failed)
1150     {
1151       if (outstr)
1152         g_string_free (outstr, TRUE);
1153       if (errstr)
1154         g_string_free (errstr, TRUE);
1155 
1156       return FALSE;
1157     }
1158   else
1159     {
1160       if (standard_output)
1161         *standard_output = g_string_free (outstr, FALSE);
1162 
1163       if (standard_error)
1164         *standard_error = g_string_free (errstr, FALSE);
1165 
1166       return TRUE;
1167     }
1168 }
1169 
1170 gboolean
1171 g_spawn_async_with_pipes (const gchar          *working_directory,
<span class="line-modified">1172                    gchar               **argv,</span>
<span class="line-modified">1173                    gchar               **envp,</span>
<span class="line-modified">1174                    GSpawnFlags           flags,</span>
<span class="line-modified">1175                    GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1176                    gpointer              user_data,</span>
<span class="line-modified">1177                    GPid                 *child_handle,</span>
<span class="line-modified">1178                    gint                 *standard_input,</span>
<span class="line-modified">1179                    gint                 *standard_output,</span>
<span class="line-modified">1180                    gint                 *standard_error,</span>
<span class="line-modified">1181                    GError              **error)</span>
1182 {
1183   g_return_val_if_fail (argv != NULL, FALSE);
1184   g_return_val_if_fail (standard_output == NULL ||
1185                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
1186   g_return_val_if_fail (standard_error == NULL ||
1187                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
1188   /* can&#39;t inherit stdin if we have an input pipe. */
1189   g_return_val_if_fail (standard_input == NULL ||
1190                         !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
1191 
1192   return do_spawn_with_pipes (NULL,
<span class="line-modified">1193                   (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),</span>
<span class="line-modified">1194                   working_directory,</span>
<span class="line-modified">1195                   argv,</span>
<span class="line-modified">1196                   envp,</span>
<span class="line-modified">1197                   flags,</span>
<span class="line-modified">1198                   child_setup,</span>
<span class="line-modified">1199                   child_handle,</span>
<span class="line-modified">1200                   standard_input,</span>
<span class="line-modified">1201                   standard_output,</span>
<span class="line-modified">1202                   standard_error,</span>
<span class="line-modified">1203                   NULL,</span>
<span class="line-modified">1204                   error);</span>
1205 }
1206 
1207 gboolean
1208 g_spawn_async_with_fds (const gchar          *working_directory,
1209                         gchar               **argv,
1210                         gchar               **envp,
1211                         GSpawnFlags           flags,
1212                         GSpawnChildSetupFunc  child_setup,
1213                         gpointer              user_data,
1214                         GPid                 *child_handle,
1215                         gint                  stdin_fd,
1216                         gint                  stdout_fd,
1217                         gint                  stderr_fd,
1218                         GError              **error)
1219 {
1220   g_return_val_if_fail (argv != NULL, FALSE);
1221   g_return_val_if_fail (stdin_fd == -1 ||
1222                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
1223   g_return_val_if_fail (stderr_fd == -1 ||
1224                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
1225   /* can&#39;t inherit stdin if we have an input pipe. */
1226   g_return_val_if_fail (stdin_fd == -1 ||
1227                         !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
1228 
1229   return do_spawn_with_fds (NULL,
<span class="line-modified">1230                 (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),</span>
<span class="line-modified">1231                 working_directory,</span>
<span class="line-modified">1232                 argv,</span>
<span class="line-modified">1233                 envp,</span>
<span class="line-modified">1234                 flags,</span>
<span class="line-modified">1235                 child_setup,</span>
<span class="line-modified">1236                 child_handle,</span>
<span class="line-modified">1237                 stdin_fd,</span>
<span class="line-modified">1238                 stdout_fd,</span>
<span class="line-modified">1239                 stderr_fd,</span>
<span class="line-modified">1240                 NULL,</span>
<span class="line-modified">1241                 error);</span>
1242 }
1243 
1244 gboolean
1245 g_spawn_command_line_sync (const gchar  *command_line,
<span class="line-modified">1246                 gchar       **standard_output,</span>
<span class="line-modified">1247                 gchar       **standard_error,</span>
<span class="line-modified">1248                 gint         *exit_status,</span>
<span class="line-modified">1249                 GError      **error)</span>
1250 {
1251   gboolean retval;
1252   gchar **argv = 0;
1253 
1254   g_return_val_if_fail (command_line != NULL, FALSE);
1255 
1256   if (!g_shell_parse_argv (command_line,
1257                            NULL, &amp;argv,
1258                            error))
1259     return FALSE;
1260 
1261   retval = g_spawn_sync (NULL,
<span class="line-modified">1262                   argv,</span>
<span class="line-modified">1263                   NULL,</span>
<span class="line-modified">1264                   G_SPAWN_SEARCH_PATH,</span>
<span class="line-modified">1265                   NULL,</span>
<span class="line-modified">1266                   NULL,</span>
<span class="line-modified">1267                   standard_output,</span>
<span class="line-modified">1268                   standard_error,</span>
<span class="line-modified">1269                   exit_status,</span>
<span class="line-modified">1270                   error);</span>
1271   g_strfreev (argv);
1272 
1273   return retval;
1274 }
1275 
1276 gboolean
1277 g_spawn_command_line_async (const gchar *command_line,
<span class="line-modified">1278                  GError     **error)</span>
1279 {
1280   gboolean retval;
1281   gchar **argv = 0;
1282 
1283   g_return_val_if_fail (command_line != NULL, FALSE);
1284 
1285   if (!g_shell_parse_argv (command_line,
1286                            NULL, &amp;argv,
1287                            error))
1288     return FALSE;
1289 
1290   retval = g_spawn_async (NULL,
<span class="line-modified">1291                    argv,</span>
<span class="line-modified">1292                    NULL,</span>
<span class="line-modified">1293                    G_SPAWN_SEARCH_PATH,</span>
<span class="line-modified">1294                    NULL,</span>
<span class="line-modified">1295                    NULL,</span>
<span class="line-modified">1296                    NULL,</span>
<span class="line-modified">1297                    error);</span>
1298   g_strfreev (argv);
1299 
1300   return retval;
1301 }
1302 
1303 void
1304 g_spawn_close_pid (GPid pid)
1305 {
1306     CloseHandle (pid);
1307 }
1308 
1309 gboolean
1310 g_spawn_check_exit_status (gint      exit_status,
<span class="line-modified">1311                GError  **error)</span>
1312 {
1313   gboolean ret = FALSE;
1314 
1315   if (exit_status != 0)
1316     {
1317       g_set_error (error, G_SPAWN_EXIT_ERROR, exit_status,
<span class="line-modified">1318            _(&quot;Child process exited with code %ld&quot;),</span>
<span class="line-modified">1319            (long) exit_status);</span>
1320       goto out;
1321     }
1322 
1323   ret = TRUE;
1324  out:
1325   return ret;
1326 }
1327 
1328 #ifndef GSTREAMER_LITE
1329 #ifdef G_OS_WIN32
1330 
1331 /* Binary compatibility versions. Not for newly compiled code. */
1332 
1333 _GLIB_EXTERN gboolean g_spawn_async_utf8              (const gchar           *working_directory,
1334                                                        gchar                **argv,
1335                                                        gchar                **envp,
1336                                                        GSpawnFlags            flags,
1337                                                        GSpawnChildSetupFunc   child_setup,
1338                                                        gpointer               user_data,
1339                                                        GPid                  *child_pid,
</pre>
<hr />
<pre>
1352 _GLIB_EXTERN gboolean g_spawn_sync_utf8               (const gchar           *working_directory,
1353                                                        gchar                **argv,
1354                                                        gchar                **envp,
1355                                                        GSpawnFlags            flags,
1356                                                        GSpawnChildSetupFunc   child_setup,
1357                                                        gpointer               user_data,
1358                                                        gchar                **standard_output,
1359                                                        gchar                **standard_error,
1360                                                        gint                  *exit_status,
1361                                                        GError               **error);
1362 _GLIB_EXTERN gboolean g_spawn_command_line_sync_utf8  (const gchar           *command_line,
1363                                                        gchar                **standard_output,
1364                                                        gchar                **standard_error,
1365                                                        gint                  *exit_status,
1366                                                        GError               **error);
1367 _GLIB_EXTERN gboolean g_spawn_command_line_async_utf8 (const gchar           *command_line,
1368                                                        GError               **error);
1369 
1370 gboolean
1371 g_spawn_async_utf8 (const gchar          *working_directory,
<span class="line-modified">1372                           gchar               **argv,</span>
<span class="line-modified">1373                           gchar               **envp,</span>
<span class="line-modified">1374                           GSpawnFlags           flags,</span>
<span class="line-modified">1375                           GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1376                           gpointer              user_data,</span>
<span class="line-modified">1377                           GPid                 *child_handle,</span>
<span class="line-modified">1378                           GError              **error)</span>
1379 {
1380   return g_spawn_async (working_directory,
1381                         argv,
1382                         envp,
1383                         flags,
1384                         child_setup,
1385                         user_data,
<span class="line-modified">1386                       child_handle,</span>
<span class="line-modified">1387                       error);</span>
1388 }
1389 
1390 gboolean
1391 g_spawn_async_with_pipes_utf8 (const gchar          *working_directory,
<span class="line-modified">1392            gchar               **argv,</span>
<span class="line-modified">1393            gchar               **envp,</span>
<span class="line-modified">1394            GSpawnFlags           flags,</span>
<span class="line-modified">1395            GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1396            gpointer              user_data,</span>
<span class="line-modified">1397            GPid                 *child_handle,</span>
1398                                gint                 *standard_input,
1399                                gint                 *standard_output,
1400                                gint                 *standard_error,
<span class="line-modified">1401            GError              **error)</span>
1402 {
1403   return g_spawn_async_with_pipes (working_directory,
1404                                    argv,
1405                                    envp,
<span class="line-modified">1406                    flags,</span>
<span class="line-modified">1407                    child_setup,</span>
<span class="line-modified">1408                    user_data,</span>
<span class="line-modified">1409                    child_handle,</span>
1410                                    standard_input,
1411                                    standard_output,
1412                                    standard_error,
<span class="line-modified">1413                    error);</span>
1414 }
1415 
1416 gboolean
1417 g_spawn_sync_utf8 (const gchar          *working_directory,
<span class="line-modified">1418           gchar               **argv,</span>
<span class="line-modified">1419           gchar               **envp,</span>
<span class="line-modified">1420           GSpawnFlags           flags,</span>
<span class="line-modified">1421           GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1422           gpointer              user_data,</span>
<span class="line-modified">1423           gchar               **standard_output,</span>
<span class="line-modified">1424           gchar               **standard_error,</span>
<span class="line-modified">1425           gint                 *exit_status,</span>
<span class="line-modified">1426           GError              **error)</span>
1427 {
1428   return g_spawn_sync (working_directory,
1429                        argv,
1430                        envp,
1431                        flags,
1432                        child_setup,
1433                        user_data,
1434                        standard_output,
1435                        standard_error,
1436                        exit_status,
<span class="line-modified">1437                   error);</span>
1438 }
1439 
1440 gboolean
1441 g_spawn_command_line_sync_utf8 (const gchar  *command_line,
<span class="line-modified">1442                gchar       **standard_output,</span>
<span class="line-modified">1443                gchar       **standard_error,</span>
<span class="line-modified">1444                gint         *exit_status,</span>
<span class="line-modified">1445                GError      **error)</span>
1446 {
1447   return g_spawn_command_line_sync (command_line,
<span class="line-modified">1448                          standard_output,</span>
<span class="line-modified">1449                          standard_error,</span>
<span class="line-modified">1450                          exit_status,</span>
<span class="line-modified">1451                          error);</span>
1452 }
1453 
1454 gboolean
1455 g_spawn_command_line_async_utf8 (const gchar *command_line,
<span class="line-modified">1456                 GError     **error)</span>
1457 {
1458   return g_spawn_command_line_async (command_line, error);
1459 }
1460 
1461 #endif /* G_OS_WIN32 */
1462 #endif // GSTREAMER_LITE
1463 
1464 #endif /* !GSPAWN_HELPER */
</pre>
</td>
<td>
<hr />
<pre>
  50 #include &quot;gthread.h&quot;
  51 
  52 #include &lt;string.h&gt;
  53 #include &lt;stdlib.h&gt;
  54 #include &lt;stdio.h&gt;
  55 
  56 #include &lt;windows.h&gt;
  57 #include &lt;errno.h&gt;
  58 #include &lt;fcntl.h&gt;
  59 #include &lt;io.h&gt;
  60 #include &lt;process.h&gt;
  61 #include &lt;direct.h&gt;
  62 #include &lt;wchar.h&gt;
  63 
  64 #ifndef GSPAWN_HELPER
  65 #ifdef G_SPAWN_WIN32_DEBUG
  66   static int debug = 1;
  67   #define SETUP_DEBUG() /* empty */
  68 #else
  69   static int debug = -1;
<span class="line-modified">  70   #define SETUP_DEBUG()         \</span>
<span class="line-modified">  71     G_STMT_START          \</span>
<span class="line-modified">  72       {             \</span>
<span class="line-modified">  73   if (debug == -1)        \</span>
<span class="line-modified">  74     {           \</span>
<span class="line-modified">  75       if (getenv (&quot;G_SPAWN_WIN32_DEBUG&quot;) != NULL) \</span>
<span class="line-modified">  76         debug = 1;        \</span>
<span class="line-modified">  77       else          \</span>
<span class="line-modified">  78         debug = 0;        \</span>
<span class="line-modified">  79     }           \</span>
<span class="line-modified">  80       }             \</span>
  81     G_STMT_END
  82 #endif
  83 #endif
  84 
  85 enum
  86 {
  87   CHILD_NO_ERROR,
  88   CHILD_CHDIR_FAILED,
  89   CHILD_SPAWN_FAILED,
  90   CHILD_SPAWN_NOENT,
  91 };
  92 
  93 enum {
  94   ARG_CHILD_ERR_REPORT = 1,
  95   ARG_HELPER_SYNC,
  96   ARG_STDIN,
  97   ARG_STDOUT,
  98   ARG_STDERR,
  99   ARG_WORKING_DIRECTORY,
 100   ARG_CLOSE_DESCRIPTORS,
 101   ARG_USE_PATH,
 102   ARG_WAIT,
 103   ARG_PROGRAM,
 104   ARG_COUNT = ARG_PROGRAM
 105 };
 106 
 107 static int
<span class="line-modified"> 108 reopen_noninherited (int fd,</span>
<span class="line-modified"> 109          int mode)</span>
 110 {
 111   HANDLE filehandle;
 112 
 113   DuplicateHandle (GetCurrentProcess (), (LPHANDLE) _get_osfhandle (fd),
<span class="line-modified"> 114        GetCurrentProcess (), &amp;filehandle,</span>
<span class="line-modified"> 115        0, FALSE, DUPLICATE_SAME_ACCESS);</span>
 116   close (fd);
 117   return _open_osfhandle ((gintptr) filehandle, mode | _O_NOINHERIT);
 118 }
 119 
 120 #ifndef GSPAWN_HELPER
 121 
 122 #ifdef _WIN64
 123 #define HELPER_PROCESS &quot;gspawn-win64-helper&quot;
 124 #else
 125 #define HELPER_PROCESS &quot;gspawn-win32-helper&quot;
 126 #endif
 127 
<span class="line-added"> 128 /* This logic has a copy for wchar_t in gspawn-win32-helper.c, protect_wargv() */</span>
 129 static gchar *
 130 protect_argv_string (const gchar *string)
 131 {
 132   const gchar *p = string;
 133   gchar *retval, *q;
 134   gint len = 0;
<span class="line-added"> 135   gint pre_bslash = 0;</span>
 136   gboolean need_dblquotes = FALSE;
 137   while (*p)
 138     {
 139       if (*p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="line-modified"> 140   need_dblquotes = TRUE;</span>
<span class="line-modified"> 141       /* estimate max len, assuming that all escapable chracters will be escaped */</span>
<span class="line-modified"> 142       if (*p == &#39;&quot;&#39; || *p == &#39;\\&#39;)</span>
<span class="line-modified"> 143   len += 2;</span>
<span class="line-modified"> 144       else</span>
<span class="line-modified"> 145   len += 1;</span>






 146       p++;
 147     }
 148 
 149   q = retval = g_malloc (len + need_dblquotes*2 + 1);
 150   p = string;
 151 
 152   if (need_dblquotes)
 153     *q++ = &#39;&quot;&#39;;
<span class="line-modified"> 154   /* Only quotes and backslashes preceeding quotes are escaped:</span>
<span class="line-added"> 155    * see &quot;Parsing C Command-Line Arguments&quot; at</span>
<span class="line-added"> 156    * https://docs.microsoft.com/en-us/cpp/c-language/parsing-c-command-line-arguments</span>
<span class="line-added"> 157    */</span>
 158   while (*p)
 159     {
 160       if (*p == &#39;&quot;&#39;)
<span class="line-added"> 161   {</span>
<span class="line-added"> 162     /* Add backslash for escaping quote itself */</span>
 163     *q++ = &#39;\\&#39;;
<span class="line-modified"> 164     /* Add backslash for every preceeding backslash for escaping it */</span>
<span class="line-modified"> 165     for (;pre_bslash &gt; 0; --pre_bslash)</span>
<span class="line-modified"> 166       *q++ = &#39;\\&#39;;</span>
<span class="line-modified"> 167   }</span>
<span class="line-modified"> 168 </span>
<span class="line-modified"> 169       /* Count length of continuous sequence of preceeding backslashes. */</span>
<span class="line-modified"> 170       if (*p == &#39;\\&#39;)</span>
<span class="line-modified"> 171   ++pre_bslash;</span>
<span class="line-added"> 172       else</span>
<span class="line-added"> 173   pre_bslash = 0;</span>
<span class="line-added"> 174 </span>
 175       *q++ = *p;
 176       p++;
 177     }
 178 
 179   if (need_dblquotes)
<span class="line-modified"> 180     {</span>
<span class="line-added"> 181       /* Add backslash for every preceeding backslash for escaping it,</span>
<span class="line-added"> 182        * do NOT escape quote itself.</span>
<span class="line-added"> 183        */</span>
<span class="line-added"> 184       for (;pre_bslash &gt; 0; --pre_bslash)</span>
<span class="line-added"> 185   *q++ = &#39;\\&#39;;</span>
<span class="line-added"> 186       *q++ = &#39;&quot;&#39;;</span>
<span class="line-added"> 187     }</span>
 188   *q++ = &#39;\0&#39;;
 189 
 190   return retval;
 191 }
 192 
 193 static gint
 194 protect_argv (gchar  **argv,
<span class="line-modified"> 195         gchar ***new_argv)</span>
 196 {
 197   gint i;
 198   gint argc = 0;
 199 
 200   while (argv[argc])
 201     ++argc;
 202   *new_argv = g_new (gchar *, argc+1);
 203 
 204   /* Quote each argv element if necessary, so that it will get
 205    * reconstructed correctly in the C runtime startup code.  Note that
 206    * the unquoting algorithm in the C runtime is really weird, and
 207    * rather different than what Unix shells do. See stdargv.c in the C
 208    * runtime sources (in the Platform SDK, in src/crt).
 209    *
<span class="line-modified"> 210    * Note that a new_argv[0] constructed by this function should</span>
 211    * *not* be passed as the filename argument to a spawn* or exec*
 212    * family function. That argument should be the real file name
 213    * without any quoting.
 214    */
 215   for (i = 0; i &lt; argc; i++)
 216     (*new_argv)[i] = protect_argv_string (argv[i]);
 217 
 218   (*new_argv)[argc] = NULL;
 219 
 220   return argc;
 221 }
 222 
 223 G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)
 224 G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)
 225 
 226 gboolean
 227 g_spawn_async (const gchar          *working_directory,
<span class="line-modified"> 228                gchar               **argv,</span>
<span class="line-modified"> 229                gchar               **envp,</span>
<span class="line-modified"> 230                GSpawnFlags           flags,</span>
<span class="line-modified"> 231                GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 232                gpointer              user_data,</span>
<span class="line-modified"> 233                GPid                 *child_handle,</span>
<span class="line-modified"> 234                GError              **error)</span>
 235 {
 236   g_return_val_if_fail (argv != NULL, FALSE);
 237 
 238   return g_spawn_async_with_pipes (working_directory,
<span class="line-modified"> 239                                    argv, envp,</span>
<span class="line-modified"> 240                                    flags,</span>
<span class="line-modified"> 241                                    child_setup,</span>
<span class="line-modified"> 242                                    user_data,</span>
<span class="line-modified"> 243                                    child_handle,</span>
<span class="line-modified"> 244                                    NULL, NULL, NULL,</span>
<span class="line-modified"> 245                                    error);</span>
 246 }
 247 
 248 /* Avoids a danger in threaded situations (calling close()
 249  * on a file descriptor twice, and another thread has
 250  * re-opened it since the first close)
 251  */
 252 static void
 253 close_and_invalidate (gint *fd)
 254 {
 255   if (*fd &lt; 0)
 256     return;
 257 
 258   close (*fd);
 259   *fd = -1;
 260 }
 261 
 262 typedef enum
 263 {
 264   READ_FAILED = 0, /* FALSE */
 265   READ_OK,
</pre>
<hr />
<pre>
 304            GError **error)
 305 {
 306   if (_pipe (p, 4096, _O_BINARY) &lt; 0)
 307     {
 308       int errsv = errno;
 309 
 310       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 311                    _(&quot;Failed to create pipe for communicating with child process (%s)&quot;),
 312                    g_strerror (errsv));
 313       return FALSE;
 314     }
 315   else
 316     return TRUE;
 317 }
 318 
 319 /* The helper process writes a status report back to us, through a
 320  * pipe, consisting of two ints.
 321  */
 322 static gboolean
 323 read_helper_report (int      fd,
<span class="line-modified"> 324         gintptr  report[2],</span>
<span class="line-modified"> 325         GError **error)</span>
 326 {
 327   gint bytes = 0;
 328 
 329   while (bytes &lt; sizeof(gintptr)*2)
 330     {
 331       gint chunk;
 332       int errsv;
 333 
 334       if (debug)
<span class="line-modified"> 335   g_print (&quot;%s:read_helper_report: read %&quot; G_GSIZE_FORMAT &quot;...\n&quot;,</span>
<span class="line-modified"> 336      __FILE__,</span>
<span class="line-modified"> 337      sizeof(gintptr)*2 - bytes);</span>
 338 
 339       chunk = read (fd, ((gchar*)report) + bytes,
<span class="line-modified"> 340         sizeof(gintptr)*2 - bytes);</span>
 341       errsv = errno;
 342 
 343       if (debug)
<span class="line-modified"> 344   g_print (&quot;...got %d bytes\n&quot;, chunk);</span>
 345 
 346       if (chunk &lt; 0)
 347         {
 348           /* Some weird shit happened, bail out */
 349           g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 350                        _(&quot;Failed to read from child pipe (%s)&quot;),
 351                        g_strerror (errsv));
 352 
 353           return FALSE;
 354         }
 355       else if (chunk == 0)
<span class="line-modified"> 356   {</span>
<span class="line-modified"> 357     g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,</span>
<span class="line-modified"> 358            _(&quot;Failed to read from child pipe (%s)&quot;),</span>
<span class="line-modified"> 359            &quot;EOF&quot;);</span>
<span class="line-modified"> 360     break; /* EOF */</span>
<span class="line-modified"> 361   }</span>
 362       else
<span class="line-modified"> 363   bytes += chunk;</span>
 364     }
 365 
 366   if (bytes &lt; sizeof(gintptr)*2)
 367     return FALSE;
 368 
 369   return TRUE;
 370 }
 371 
 372 static void
 373 set_child_error (gintptr      report[2],
<span class="line-modified"> 374      const gchar *working_directory,</span>
<span class="line-modified"> 375      GError     **error)</span>
 376 {
 377   switch (report[0])
 378     {
 379     case CHILD_CHDIR_FAILED:
 380       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,
<span class="line-modified"> 381        _(&quot;Failed to change to directory &#39;%s&#39; (%s)&quot;),</span>
<span class="line-modified"> 382        working_directory,</span>
<span class="line-modified"> 383        g_strerror (report[1]));</span>
 384       break;
 385     case CHILD_SPAWN_FAILED:
 386       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 387        _(&quot;Failed to execute child process (%s)&quot;),</span>
<span class="line-modified"> 388        g_strerror (report[1]));</span>
 389       break;
 390     case CHILD_SPAWN_NOENT:
 391       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT,
 392                    _(&quot;Failed to execute child process (%s)&quot;),
 393                    g_strerror (report[1]));
 394       break;
 395     default:
 396       g_assert_not_reached ();
 397     }
 398 }
 399 
 400 static gboolean
 401 utf8_charv_to_wcharv (char     **utf8_charv,
<span class="line-modified"> 402           wchar_t ***wcharv,</span>
<span class="line-modified"> 403           int       *error_index,</span>
<span class="line-modified"> 404           GError   **error)</span>
 405 {
 406   wchar_t **retval = NULL;
 407 
 408   *wcharv = NULL;
 409   if (utf8_charv != NULL)
 410     {
 411       int n = 0, i;
 412 
 413       while (utf8_charv[n])
<span class="line-modified"> 414   n++;</span>
 415       retval = g_new (wchar_t *, n + 1);
 416 
 417       for (i = 0; i &lt; n; i++)
<span class="line-modified"> 418   {</span>
<span class="line-modified"> 419     retval[i] = g_utf8_to_utf16 (utf8_charv[i], -1, NULL, NULL, error);</span>
<span class="line-modified"> 420     if (retval[i] == NULL)</span>
<span class="line-modified"> 421       {</span>
<span class="line-modified"> 422         if (error_index)</span>
<span class="line-modified"> 423     *error_index = i;</span>
<span class="line-modified"> 424         while (i)</span>
<span class="line-modified"> 425     g_free (retval[--i]);</span>
<span class="line-modified"> 426         g_free (retval);</span>
<span class="line-modified"> 427         return FALSE;</span>
<span class="line-modified"> 428       }</span>
<span class="line-modified"> 429   }</span>
 430 
 431       retval[n] = NULL;
 432     }
 433   *wcharv = retval;
 434   return TRUE;
 435 }
 436 
 437 static gboolean
 438 do_spawn_directly (gint                 *exit_status,
<span class="line-modified"> 439        gboolean    do_return_handle,</span>
<span class="line-modified"> 440        GSpawnFlags           flags,</span>
<span class="line-modified"> 441        gchar               **argv,</span>
<span class="line-modified"> 442        char                **envp,</span>
<span class="line-modified"> 443        char                **protected_argv,</span>
<span class="line-modified"> 444        GPid                 *child_handle,</span>
<span class="line-modified"> 445        GError              **error)</span>
 446 {
 447   const int mode = (exit_status == NULL) ? P_NOWAIT : P_WAIT;
 448   char **new_argv;
 449   gintptr rc = -1;
 450   int errsv;
 451   GError *conv_error = NULL;
 452   gint conv_error_index;
 453   wchar_t *wargv0, **wargv, **wenvp;
 454 
 455   new_argv = (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO) ? protected_argv + 1 : protected_argv;
 456 
 457   wargv0 = g_utf8_to_utf16 (argv[0], -1, NULL, NULL, &amp;conv_error);
 458   if (wargv0 == NULL)
 459     {
 460       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 461        _(&quot;Invalid program name: %s&quot;),</span>
<span class="line-modified"> 462        conv_error-&gt;message);</span>
 463       g_error_free (conv_error);
 464 
 465       return FALSE;
 466     }
 467 
 468   if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
 469     {
 470       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 471        _(&quot;Invalid string in argument vector at %d: %s&quot;),</span>
<span class="line-modified"> 472        conv_error_index, conv_error-&gt;message);</span>
 473       g_error_free (conv_error);
 474       g_free (wargv0);
 475 
 476       return FALSE;
 477     }
 478 
 479   if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
 480     {
 481       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 482        _(&quot;Invalid string in environment: %s&quot;),</span>
<span class="line-modified"> 483        conv_error-&gt;message);</span>
 484       g_error_free (conv_error);
 485       g_free (wargv0);
 486       g_strfreev ((gchar **) wargv);
 487 
 488       return FALSE;
 489     }
 490 
 491   if (flags &amp; G_SPAWN_SEARCH_PATH)
 492     if (wenvp != NULL)
 493       rc = _wspawnvpe (mode, wargv0, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 494     else
 495       rc = _wspawnvp (mode, wargv0, (const wchar_t **) wargv);
 496   else
 497     if (wenvp != NULL)
 498       rc = _wspawnve (mode, wargv0, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 499     else
 500       rc = _wspawnv (mode, wargv0, (const wchar_t **) wargv);
 501 
 502   errsv = errno;
 503 
 504   g_free (wargv0);
 505   g_strfreev ((gchar **) wargv);
 506   g_strfreev ((gchar **) wenvp);
 507 
 508   if (rc == -1 &amp;&amp; errsv != 0)
 509     {
 510       g_set_error (error, G_SPAWN_ERROR, _g_spawn_exec_err_to_g_error (errsv),
<span class="line-modified"> 511        _(&quot;Failed to execute child process (%s)&quot;),</span>
<span class="line-modified"> 512        g_strerror (errsv));</span>
 513       return FALSE;
 514     }
 515 
 516   if (exit_status == NULL)
 517     {
 518       if (child_handle &amp;&amp; do_return_handle)
<span class="line-modified"> 519   *child_handle = (GPid) rc;</span>
 520       else
<span class="line-modified"> 521   {</span>
<span class="line-modified"> 522     CloseHandle ((HANDLE) rc);</span>
<span class="line-modified"> 523     if (child_handle)</span>
<span class="line-modified"> 524       *child_handle = 0;</span>
<span class="line-modified"> 525   }</span>
 526     }
 527   else
 528     *exit_status = rc;
 529 
 530   return TRUE;
 531 }
 532 
 533 static gboolean
 534 do_spawn_with_fds (gint                 *exit_status,
<span class="line-modified"> 535        gboolean      do_return_handle,</span>
<span class="line-modified"> 536        const gchar          *working_directory,</span>
<span class="line-modified"> 537        gchar               **argv,</span>
<span class="line-modified"> 538        char                **envp,</span>
<span class="line-modified"> 539        GSpawnFlags           flags,</span>
<span class="line-modified"> 540        GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 541        GPid                 *child_handle,</span>
<span class="line-modified"> 542        gint                  stdin_fd,</span>
<span class="line-modified"> 543        gint                  stdout_fd,</span>
<span class="line-modified"> 544        gint                  stderr_fd,</span>
<span class="line-modified"> 545        gint     *err_report,</span>
<span class="line-modified"> 546        GError              **error)</span>
 547 {
 548   char **protected_argv;
 549   char args[ARG_COUNT][10];
 550   char **new_argv;
 551   int i;
 552   gintptr rc = -1;
 553   int errsv;
 554   int argc;
 555   int child_err_report_pipe[2] = { -1, -1 };
 556   int helper_sync_pipe[2] = { -1, -1 };
 557   gintptr helper_report[2];
 558   static gboolean warned_about_child_setup = FALSE;
 559   GError *conv_error = NULL;
 560   gint conv_error_index;
 561   gchar *helper_process;
 562   wchar_t *whelper, **wargv, **wenvp;
 563   gchar *glib_dll_directory;
 564 
 565   if (child_setup &amp;&amp; !warned_about_child_setup)
 566     {
 567       warned_about_child_setup = TRUE;
 568       g_warning (&quot;passing a child setup function to the g_spawn functions is pointless on Windows and it is ignored&quot;);
 569     }
 570 
 571   argc = protect_argv (argv, &amp;protected_argv);
 572 
 573   if (stdin_fd == -1 &amp;&amp; stdout_fd == -1 &amp;&amp; stderr_fd == -1 &amp;&amp;
 574       (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN) &amp;&amp;
 575       !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL) &amp;&amp;
 576       !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL) &amp;&amp;
 577       (working_directory == NULL || !*working_directory) &amp;&amp;
 578       (flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
 579     {
 580       /* We can do without the helper process */
 581       gboolean retval =
<span class="line-modified"> 582   do_spawn_directly (exit_status, do_return_handle, flags,</span>
<span class="line-modified"> 583          argv, envp, protected_argv,</span>
<span class="line-modified"> 584          child_handle, error);</span>
 585       g_strfreev (protected_argv);
 586       return retval;
 587     }
 588 
 589   if (!make_pipe (child_err_report_pipe, error))
 590     goto cleanup_and_fail;
 591 
 592   if (!make_pipe (helper_sync_pipe, error))
 593     goto cleanup_and_fail;
 594 
 595   new_argv = g_new (char *, argc + 1 + ARG_COUNT);
 596   if (GetConsoleWindow () != NULL)
 597     helper_process = HELPER_PROCESS &quot;-console.exe&quot;;
 598   else
 599     helper_process = HELPER_PROCESS &quot;.exe&quot;;
 600 
 601   glib_dll_directory = _glib_get_dll_directory ();
 602   if (glib_dll_directory != NULL)
 603     {
 604       helper_process = g_build_filename (glib_dll_directory, helper_process, NULL);
 605       g_free (glib_dll_directory);
 606     }
 607   else
 608     helper_process = g_strdup (helper_process);
 609 
 610   new_argv[0] = protect_argv_string (helper_process);
 611 
 612   _g_sprintf (args[ARG_CHILD_ERR_REPORT], &quot;%d&quot;, child_err_report_pipe[1]);
 613   new_argv[ARG_CHILD_ERR_REPORT] = args[ARG_CHILD_ERR_REPORT];
 614 
 615   /* Make the read end of the child error report pipe
 616    * noninherited. Otherwise it will needlessly be inherited by the
 617    * helper process, and the started actual user process. As such that
 618    * shouldn&#39;t harm, but it is unnecessary.
 619    */
<span class="line-modified"> 620   child_err_report_pipe[0] = reopen_noninherited (child_err_report_pipe[0], _O_RDONLY);</span>
 621 
 622   if (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO)
 623     {
 624       /* Overload ARG_CHILD_ERR_REPORT to also encode the
 625        * G_SPAWN_FILE_AND_ARGV_ZERO functionality.
 626        */
 627       strcat (args[ARG_CHILD_ERR_REPORT], &quot;#&quot;);
 628     }
 629 
 630   _g_sprintf (args[ARG_HELPER_SYNC], &quot;%d&quot;, helper_sync_pipe[0]);
 631   new_argv[ARG_HELPER_SYNC] = args[ARG_HELPER_SYNC];
 632 
 633   /* Make the write end of the sync pipe noninherited. Otherwise the
 634    * helper process will inherit it, and thus if this process happens
 635    * to crash before writing the sync byte to the pipe, the helper
 636    * process won&#39;t read but won&#39;t get any EOF either, as it has the
 637    * write end open itself.
 638    */
<span class="line-modified"> 639   helper_sync_pipe[1] = reopen_noninherited (helper_sync_pipe[1], _O_WRONLY);</span>
 640 
 641   if (stdin_fd != -1)
 642     {
 643       _g_sprintf (args[ARG_STDIN], &quot;%d&quot;, stdin_fd);
 644       new_argv[ARG_STDIN] = args[ARG_STDIN];
 645     }
 646   else if (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN)
 647     {
 648       /* Let stdin be alone */
 649       new_argv[ARG_STDIN] = &quot;-&quot;;
 650     }
 651   else
 652     {
 653       /* Keep process from blocking on a read of stdin */
 654       new_argv[ARG_STDIN] = &quot;z&quot;;
 655     }
 656 
 657   if (stdout_fd != -1)
 658     {
 659       _g_sprintf (args[ARG_STDOUT], &quot;%d&quot;, stdout_fd);
 660       new_argv[ARG_STDOUT] = args[ARG_STDOUT];
 661     }
 662   else if (flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL)
 663     {
 664       new_argv[ARG_STDOUT] = &quot;z&quot;;
 665     }
 666   else
 667     {
 668       new_argv[ARG_STDOUT] = &quot;-&quot;;
 669     }
 670 
<span class="line-modified"> 671   if (stderr_fd != -1)</span>
 672     {
 673       _g_sprintf (args[ARG_STDERR], &quot;%d&quot;, stderr_fd);
 674       new_argv[ARG_STDERR] = args[ARG_STDERR];
 675     }
 676   else if (flags &amp; G_SPAWN_STDERR_TO_DEV_NULL)
 677     {
 678       new_argv[ARG_STDERR] = &quot;z&quot;;
 679     }
 680   else
 681     {
 682       new_argv[ARG_STDERR] = &quot;-&quot;;
 683     }
 684 
 685   if (working_directory &amp;&amp; *working_directory)
 686     new_argv[ARG_WORKING_DIRECTORY] = protect_argv_string (working_directory);
 687   else
 688     new_argv[ARG_WORKING_DIRECTORY] = g_strdup (&quot;-&quot;);
 689 
 690   if (!(flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
 691     new_argv[ARG_CLOSE_DESCRIPTORS] = &quot;y&quot;;
</pre>
<hr />
<pre>
 694 
 695   if (flags &amp; G_SPAWN_SEARCH_PATH)
 696     new_argv[ARG_USE_PATH] = &quot;y&quot;;
 697   else
 698     new_argv[ARG_USE_PATH] = &quot;-&quot;;
 699 
 700   if (exit_status == NULL)
 701     new_argv[ARG_WAIT] = &quot;-&quot;;
 702   else
 703     new_argv[ARG_WAIT] = &quot;w&quot;;
 704 
 705   for (i = 0; i &lt;= argc; i++)
 706     new_argv[ARG_PROGRAM + i] = protected_argv[i];
 707 
 708   SETUP_DEBUG();
 709 
 710   if (debug)
 711     {
 712       g_print (&quot;calling %s with argv:\n&quot;, helper_process);
 713       for (i = 0; i &lt; argc + 1 + ARG_COUNT; i++)
<span class="line-modified"> 714   g_print (&quot;argv[%d]: %s\n&quot;, i, (new_argv[i] ? new_argv[i] : &quot;NULL&quot;));</span>
 715     }
 716 
 717   if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
 718     {
 719       if (conv_error_index == ARG_WORKING_DIRECTORY)
<span class="line-modified"> 720   g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,</span>
<span class="line-modified"> 721          _(&quot;Invalid working directory: %s&quot;),</span>
<span class="line-modified"> 722          conv_error-&gt;message);</span>
 723       else
<span class="line-modified"> 724   g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,</span>
<span class="line-modified"> 725          _(&quot;Invalid string in argument vector at %d: %s&quot;),</span>
<span class="line-modified"> 726          conv_error_index - ARG_PROGRAM, conv_error-&gt;message);</span>
 727       g_error_free (conv_error);
 728       g_strfreev (protected_argv);
 729       g_free (new_argv[0]);
 730       g_free (new_argv[ARG_WORKING_DIRECTORY]);
 731       g_free (new_argv);
 732       g_free (helper_process);
 733 
 734       goto cleanup_and_fail;
 735     }
 736 
 737   if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
 738     {
 739       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 740        _(&quot;Invalid string in environment: %s&quot;),</span>
<span class="line-modified"> 741        conv_error-&gt;message);</span>
 742       g_error_free (conv_error);
 743       g_strfreev (protected_argv);
 744       g_free (new_argv[0]);
 745       g_free (new_argv[ARG_WORKING_DIRECTORY]);
 746       g_free (new_argv);
 747       g_free (helper_process);
 748       g_strfreev ((gchar **) wargv);
 749 
 750       goto cleanup_and_fail;
 751     }
 752 
 753   whelper = g_utf8_to_utf16 (helper_process, -1, NULL, NULL, NULL);
 754   g_free (helper_process);
 755 
 756   if (wenvp != NULL)
 757     rc = _wspawnvpe (P_NOWAIT, whelper, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 758   else
 759     rc = _wspawnvp (P_NOWAIT, whelper, (const wchar_t **) wargv);
 760 
 761   errsv = errno;
</pre>
<hr />
<pre>
 763   g_free (whelper);
 764   g_strfreev ((gchar **) wargv);
 765   g_strfreev ((gchar **) wenvp);
 766 
 767   /* Close the other process&#39;s ends of the pipes in this process,
 768    * otherwise the reader will never get EOF.
 769    */
 770   close_and_invalidate (&amp;child_err_report_pipe[1]);
 771   close_and_invalidate (&amp;helper_sync_pipe[0]);
 772 
 773   g_strfreev (protected_argv);
 774 
 775   g_free (new_argv[0]);
 776   g_free (new_argv[ARG_WORKING_DIRECTORY]);
 777   g_free (new_argv);
 778 
 779   /* Check if gspawn-win32-helper couldn&#39;t be run */
 780   if (rc == -1 &amp;&amp; errsv != 0)
 781     {
 782       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified"> 783        _(&quot;Failed to execute helper program (%s)&quot;),</span>
<span class="line-modified"> 784        g_strerror (errsv));</span>
 785       goto cleanup_and_fail;
 786     }
 787 
 788   if (exit_status != NULL)
 789     {
 790       /* Synchronous case. Pass helper&#39;s report pipe back to caller,
 791        * which takes care of reading it after the grandchild has
 792        * finished.
 793        */
 794       g_assert (err_report != NULL);
 795       *err_report = child_err_report_pipe[0];
 796       write (helper_sync_pipe[1], &quot; &quot;, 1);
 797       close_and_invalidate (&amp;helper_sync_pipe[1]);
 798     }
 799   else
 800     {
 801       /* Asynchronous case. We read the helper&#39;s report right away. */
 802       if (!read_helper_report (child_err_report_pipe[0], helper_report, error))
<span class="line-modified"> 803   goto cleanup_and_fail;</span>
 804 
 805       close_and_invalidate (&amp;child_err_report_pipe[0]);
 806 
 807       switch (helper_report[0])
<span class="line-added"> 808   {</span>
<span class="line-added"> 809   case CHILD_NO_ERROR:</span>
<span class="line-added"> 810     if (child_handle &amp;&amp; do_return_handle)</span>
<span class="line-added"> 811       {</span>
<span class="line-added"> 812         /* rc is our HANDLE for gspawn-win32-helper. It has</span>
<span class="line-added"> 813          * told us the HANDLE of its child. Duplicate that into</span>
<span class="line-added"> 814          * a HANDLE valid in this process.</span>
<span class="line-added"> 815          */</span>
<span class="line-added"> 816         if (!DuplicateHandle ((HANDLE) rc, (HANDLE) helper_report[1],</span>
<span class="line-added"> 817             GetCurrentProcess (), (LPHANDLE) child_handle,</span>
<span class="line-added"> 818             0, TRUE, DUPLICATE_SAME_ACCESS))</span>
 819     {
<span class="line-modified"> 820       char *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified"> 821       g_print(&quot;%s\n&quot;, emsg);</span>
<span class="line-modified"> 822       *child_handle = 0;</span>
























 823     }
<span class="line-added"> 824       }</span>
<span class="line-added"> 825     else if (child_handle)</span>
<span class="line-added"> 826       *child_handle = 0;</span>
<span class="line-added"> 827     write (helper_sync_pipe[1], &quot; &quot;, 1);</span>
<span class="line-added"> 828     close_and_invalidate (&amp;helper_sync_pipe[1]);</span>
<span class="line-added"> 829     break;</span>
<span class="line-added"> 830 </span>
<span class="line-added"> 831   default:</span>
<span class="line-added"> 832     write (helper_sync_pipe[1], &quot; &quot;, 1);</span>
<span class="line-added"> 833     close_and_invalidate (&amp;helper_sync_pipe[1]);</span>
<span class="line-added"> 834     set_child_error (helper_report, working_directory, error);</span>
<span class="line-added"> 835     goto cleanup_and_fail;</span>
<span class="line-added"> 836   }</span>
 837     }
 838 
 839   /* Success against all odds! return the information */
 840 
 841   if (rc != -1)
 842     CloseHandle ((HANDLE) rc);
 843 
 844   return TRUE;
 845 
 846  cleanup_and_fail:
 847 
 848   if (rc != -1)
 849     CloseHandle ((HANDLE) rc);
 850   if (child_err_report_pipe[0] != -1)
 851     close (child_err_report_pipe[0]);
 852   if (child_err_report_pipe[1] != -1)
 853     close (child_err_report_pipe[1]);
 854   if (helper_sync_pipe[0] != -1)
 855     close (helper_sync_pipe[0]);
 856   if (helper_sync_pipe[1] != -1)
 857     close (helper_sync_pipe[1]);
 858 
 859   return FALSE;
 860 }
 861 
 862 static gboolean
 863 do_spawn_with_pipes (gint                 *exit_status,
<span class="line-modified"> 864          gboolean      do_return_handle,</span>
<span class="line-modified"> 865          const gchar          *working_directory,</span>
<span class="line-modified"> 866          gchar               **argv,</span>
<span class="line-modified"> 867          char                **envp,</span>
<span class="line-modified"> 868          GSpawnFlags           flags,</span>
<span class="line-modified"> 869          GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 870          GPid                 *child_handle,</span>
<span class="line-modified"> 871          gint                 *standard_input,</span>
<span class="line-modified"> 872          gint                 *standard_output,</span>
<span class="line-modified"> 873          gint                 *standard_error,</span>
<span class="line-modified"> 874          gint     *err_report,</span>
<span class="line-modified"> 875          GError              **error)</span>
 876 {
 877   int stdin_pipe[2] = { -1, -1 };
 878   int stdout_pipe[2] = { -1, -1 };
 879   int stderr_pipe[2] = { -1, -1 };
 880 
 881   if (standard_input &amp;&amp; !make_pipe (stdin_pipe, error))
 882     goto cleanup_and_fail;
 883 
 884   if (standard_output &amp;&amp; !make_pipe (stdout_pipe, error))
 885     goto cleanup_and_fail;
 886 
 887   if (standard_error &amp;&amp; !make_pipe (stderr_pipe, error))
 888     goto cleanup_and_fail;
 889 
 890   if (!do_spawn_with_fds (exit_status,
<span class="line-modified"> 891         do_return_handle,</span>
<span class="line-modified"> 892         working_directory,</span>
<span class="line-modified"> 893         argv,</span>
<span class="line-modified"> 894         envp,</span>
<span class="line-modified"> 895         flags,</span>
<span class="line-modified"> 896         child_setup,</span>
<span class="line-modified"> 897         child_handle,</span>
<span class="line-modified"> 898         stdin_pipe[0],</span>
<span class="line-modified"> 899         stdout_pipe[1],</span>
<span class="line-modified"> 900         stderr_pipe[1],</span>
<span class="line-modified"> 901         err_report,</span>
<span class="line-modified"> 902         error))</span>
 903     goto cleanup_and_fail;
 904 
 905   /* Close the other process&#39;s ends of the pipes in this process,
 906    * otherwise the reader will never get EOF.
 907    */
 908   close_and_invalidate (&amp;stdin_pipe[0]);
 909   close_and_invalidate (&amp;stdout_pipe[1]);
 910   close_and_invalidate (&amp;stderr_pipe[1]);
 911 
 912   if (standard_input)
 913     *standard_input = stdin_pipe[1];
 914   if (standard_output)
 915     *standard_output = stdout_pipe[0];
 916   if (standard_error)
 917     *standard_error = stderr_pipe[0];
 918 
 919   return TRUE;
 920 
 921  cleanup_and_fail:
 922 
 923   if (stdin_pipe[0] != -1)
 924     close (stdin_pipe[0]);
 925   if (stdin_pipe[1] != -1)
 926     close (stdin_pipe[1]);
 927   if (stdout_pipe[0] != -1)
 928     close (stdout_pipe[0]);
 929   if (stdout_pipe[1] != -1)
 930     close (stdout_pipe[1]);
 931   if (stderr_pipe[0] != -1)
 932     close (stderr_pipe[0]);
 933   if (stderr_pipe[1] != -1)
 934     close (stderr_pipe[1]);
 935 
 936   return FALSE;
 937 }
 938 
 939 gboolean
 940 g_spawn_sync (const gchar          *working_directory,
<span class="line-modified"> 941               gchar               **argv,</span>
<span class="line-modified"> 942               gchar               **envp,</span>
<span class="line-modified"> 943               GSpawnFlags           flags,</span>
<span class="line-modified"> 944               GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 945               gpointer              user_data,</span>
<span class="line-modified"> 946               gchar               **standard_output,</span>
<span class="line-modified"> 947               gchar               **standard_error,</span>
<span class="line-modified"> 948               gint                 *exit_status,</span>
<span class="line-modified"> 949               GError              **error)</span>
 950 {
 951   gint outpipe = -1;
 952   gint errpipe = -1;
 953   gint reportpipe = -1;
 954   GIOChannel *outchannel = NULL;
 955   GIOChannel *errchannel = NULL;
 956   GPollFD outfd, errfd;
 957   GPollFD fds[2];
 958   gint nfds;
 959   gint outindex = -1;
 960   gint errindex = -1;
 961   gint ret;
 962   GString *outstr = NULL;
 963   GString *errstr = NULL;
 964   gboolean failed;
 965   gint status;
 966 
 967   g_return_val_if_fail (argv != NULL, FALSE);
 968   g_return_val_if_fail (!(flags &amp; G_SPAWN_DO_NOT_REAP_CHILD), FALSE);
 969   g_return_val_if_fail (standard_output == NULL ||
 970                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
 971   g_return_val_if_fail (standard_error == NULL ||
 972                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
 973 
 974   /* Just to ensure segfaults if callers try to use
 975    * these when an error is reported.
 976    */
 977   if (standard_output)
 978     *standard_output = NULL;
 979 
 980   if (standard_error)
 981     *standard_error = NULL;
 982 
 983   if (!do_spawn_with_pipes (&amp;status,
<span class="line-modified"> 984           FALSE,</span>
<span class="line-modified"> 985           working_directory,</span>
<span class="line-modified"> 986           argv,</span>
<span class="line-modified"> 987           envp,</span>
<span class="line-modified"> 988           flags,</span>
<span class="line-modified"> 989           child_setup,</span>
<span class="line-modified"> 990           NULL,</span>
<span class="line-modified"> 991           NULL,</span>
<span class="line-modified"> 992           standard_output ? &amp;outpipe : NULL,</span>
<span class="line-modified"> 993           standard_error ? &amp;errpipe : NULL,</span>
<span class="line-modified"> 994           &amp;reportpipe,</span>
<span class="line-modified"> 995           error))</span>
 996     return FALSE;
 997 
 998   /* Read data from child. */
 999 
1000   failed = FALSE;
1001 
1002   if (outpipe &gt;= 0)
1003     {
1004       outstr = g_string_new (NULL);
1005       outchannel = g_io_channel_win32_new_fd (outpipe);
1006       g_io_channel_set_encoding (outchannel, NULL, NULL);
1007       g_io_channel_set_buffered (outchannel, FALSE);
1008       g_io_channel_win32_make_pollfd (outchannel,
<span class="line-modified">1009               G_IO_IN | G_IO_ERR | G_IO_HUP,</span>
<span class="line-modified">1010               &amp;outfd);</span>
1011       if (debug)
<span class="line-modified">1012   g_print (&quot;outfd=%p\n&quot;, (HANDLE) outfd.fd);</span>
1013     }
1014 
1015   if (errpipe &gt;= 0)
1016     {
1017       errstr = g_string_new (NULL);
1018       errchannel = g_io_channel_win32_new_fd (errpipe);
1019       g_io_channel_set_encoding (errchannel, NULL, NULL);
1020       g_io_channel_set_buffered (errchannel, FALSE);
1021       g_io_channel_win32_make_pollfd (errchannel,
<span class="line-modified">1022               G_IO_IN | G_IO_ERR | G_IO_HUP,</span>
<span class="line-modified">1023               &amp;errfd);</span>
1024       if (debug)
<span class="line-modified">1025   g_print (&quot;errfd=%p\n&quot;, (HANDLE) errfd.fd);</span>
1026     }
1027 
1028   /* Read data until we get EOF on all pipes. */
1029   while (!failed &amp;&amp; (outpipe &gt;= 0 || errpipe &gt;= 0))
1030     {
1031       nfds = 0;
1032       if (outpipe &gt;= 0)
<span class="line-modified">1033   {</span>
<span class="line-modified">1034     fds[nfds] = outfd;</span>
<span class="line-modified">1035     outindex = nfds;</span>
<span class="line-modified">1036     nfds++;</span>
<span class="line-modified">1037   }</span>
1038       if (errpipe &gt;= 0)
<span class="line-modified">1039   {</span>
<span class="line-modified">1040     fds[nfds] = errfd;</span>
<span class="line-modified">1041     errindex = nfds;</span>
<span class="line-modified">1042     nfds++;</span>
<span class="line-modified">1043   }</span>
1044 
1045       if (debug)
<span class="line-modified">1046   g_print (&quot;g_spawn_sync: calling g_io_channel_win32_poll, nfds=%d\n&quot;,</span>
<span class="line-modified">1047      nfds);</span>
1048 
1049       ret = g_io_channel_win32_poll (fds, nfds, -1);
1050 
1051       if (ret &lt; 0)
1052         {
1053           failed = TRUE;
1054 
1055           g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_READ,
1056                                _(&quot;Unexpected error in g_io_channel_win32_poll() reading data from a child process&quot;));
1057 
1058           break;
1059         }
1060 
1061       if (outpipe &gt;= 0 &amp;&amp; (fds[outindex].revents &amp; G_IO_IN))
1062         {
1063           switch (read_data (outstr, outchannel, error))
1064             {
1065             case READ_FAILED:
<span class="line-modified">1066         if (debug)</span>
<span class="line-modified">1067     g_print (&quot;g_spawn_sync: outchannel: READ_FAILED\n&quot;);</span>
1068               failed = TRUE;
1069               break;
1070             case READ_EOF:
<span class="line-modified">1071         if (debug)</span>
<span class="line-modified">1072     g_print (&quot;g_spawn_sync: outchannel: READ_EOF\n&quot;);</span>
1073               g_io_channel_unref (outchannel);
<span class="line-modified">1074         outchannel = NULL;</span>
1075               close_and_invalidate (&amp;outpipe);
1076               break;
1077             default:
<span class="line-modified">1078         if (debug)</span>
<span class="line-modified">1079     g_print (&quot;g_spawn_sync: outchannel: OK\n&quot;);</span>
1080               break;
1081             }
1082 
1083           if (failed)
1084             break;
1085         }
1086 
1087       if (errpipe &gt;= 0 &amp;&amp; (fds[errindex].revents &amp; G_IO_IN))
1088         {
1089           switch (read_data (errstr, errchannel, error))
1090             {
1091             case READ_FAILED:
<span class="line-modified">1092         if (debug)</span>
<span class="line-modified">1093     g_print (&quot;g_spawn_sync: errchannel: READ_FAILED\n&quot;);</span>
1094               failed = TRUE;
1095               break;
1096             case READ_EOF:
<span class="line-modified">1097         if (debug)</span>
<span class="line-modified">1098     g_print (&quot;g_spawn_sync: errchannel: READ_EOF\n&quot;);</span>
<span class="line-modified">1099         g_io_channel_unref (errchannel);</span>
<span class="line-modified">1100         errchannel = NULL;</span>
1101               close_and_invalidate (&amp;errpipe);
1102               break;
1103             default:
<span class="line-modified">1104         if (debug)</span>
<span class="line-modified">1105     g_print (&quot;g_spawn_sync: errchannel: OK\n&quot;);</span>
1106               break;
1107             }
1108 
1109           if (failed)
1110             break;
1111         }
1112     }
1113 
1114   if (reportpipe == -1)
1115     {
1116       /* No helper process, exit status of actual spawned process
1117        * already available.
1118        */
1119       if (exit_status)
1120         *exit_status = status;
1121     }
1122   else
1123     {
1124       /* Helper process was involved. Read its report now after the
1125        * grandchild has finished.
1126        */
1127       gintptr helper_report[2];
1128 
1129       if (!read_helper_report (reportpipe, helper_report, error))
<span class="line-modified">1130   failed = TRUE;</span>
1131       else
<span class="line-modified">1132   {</span>
<span class="line-modified">1133     switch (helper_report[0])</span>
<span class="line-modified">1134       {</span>
<span class="line-modified">1135       case CHILD_NO_ERROR:</span>
<span class="line-modified">1136         if (exit_status)</span>
<span class="line-modified">1137     *exit_status = helper_report[1];</span>
<span class="line-modified">1138         break;</span>
<span class="line-modified">1139       default:</span>
<span class="line-modified">1140         set_child_error (helper_report, working_directory, error);</span>
<span class="line-modified">1141         failed = TRUE;</span>
<span class="line-modified">1142         break;</span>
<span class="line-modified">1143       }</span>
<span class="line-modified">1144   }</span>
1145       close_and_invalidate (&amp;reportpipe);
1146     }
1147 
1148 
1149   /* These should only be open still if we had an error.  */
1150 
1151   if (outchannel != NULL)
1152     g_io_channel_unref (outchannel);
1153   if (errchannel != NULL)
1154     g_io_channel_unref (errchannel);
1155   if (outpipe &gt;= 0)
1156     close_and_invalidate (&amp;outpipe);
1157   if (errpipe &gt;= 0)
1158     close_and_invalidate (&amp;errpipe);
1159 
1160   if (failed)
1161     {
1162       if (outstr)
1163         g_string_free (outstr, TRUE);
1164       if (errstr)
1165         g_string_free (errstr, TRUE);
1166 
1167       return FALSE;
1168     }
1169   else
1170     {
1171       if (standard_output)
1172         *standard_output = g_string_free (outstr, FALSE);
1173 
1174       if (standard_error)
1175         *standard_error = g_string_free (errstr, FALSE);
1176 
1177       return TRUE;
1178     }
1179 }
1180 
1181 gboolean
1182 g_spawn_async_with_pipes (const gchar          *working_directory,
<span class="line-modified">1183                           gchar               **argv,</span>
<span class="line-modified">1184                           gchar               **envp,</span>
<span class="line-modified">1185                           GSpawnFlags           flags,</span>
<span class="line-modified">1186                           GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1187                           gpointer              user_data,</span>
<span class="line-modified">1188                           GPid                 *child_handle,</span>
<span class="line-modified">1189                           gint                 *standard_input,</span>
<span class="line-modified">1190                           gint                 *standard_output,</span>
<span class="line-modified">1191                           gint                 *standard_error,</span>
<span class="line-modified">1192                           GError              **error)</span>
1193 {
1194   g_return_val_if_fail (argv != NULL, FALSE);
1195   g_return_val_if_fail (standard_output == NULL ||
1196                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
1197   g_return_val_if_fail (standard_error == NULL ||
1198                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
1199   /* can&#39;t inherit stdin if we have an input pipe. */
1200   g_return_val_if_fail (standard_input == NULL ||
1201                         !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
1202 
1203   return do_spawn_with_pipes (NULL,
<span class="line-modified">1204             (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),</span>
<span class="line-modified">1205             working_directory,</span>
<span class="line-modified">1206             argv,</span>
<span class="line-modified">1207             envp,</span>
<span class="line-modified">1208             flags,</span>
<span class="line-modified">1209             child_setup,</span>
<span class="line-modified">1210             child_handle,</span>
<span class="line-modified">1211             standard_input,</span>
<span class="line-modified">1212             standard_output,</span>
<span class="line-modified">1213             standard_error,</span>
<span class="line-modified">1214             NULL,</span>
<span class="line-modified">1215             error);</span>
1216 }
1217 
1218 gboolean
1219 g_spawn_async_with_fds (const gchar          *working_directory,
1220                         gchar               **argv,
1221                         gchar               **envp,
1222                         GSpawnFlags           flags,
1223                         GSpawnChildSetupFunc  child_setup,
1224                         gpointer              user_data,
1225                         GPid                 *child_handle,
1226                         gint                  stdin_fd,
1227                         gint                  stdout_fd,
1228                         gint                  stderr_fd,
1229                         GError              **error)
1230 {
1231   g_return_val_if_fail (argv != NULL, FALSE);
1232   g_return_val_if_fail (stdin_fd == -1 ||
1233                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
1234   g_return_val_if_fail (stderr_fd == -1 ||
1235                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
1236   /* can&#39;t inherit stdin if we have an input pipe. */
1237   g_return_val_if_fail (stdin_fd == -1 ||
1238                         !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
1239 
1240   return do_spawn_with_fds (NULL,
<span class="line-modified">1241           (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),</span>
<span class="line-modified">1242           working_directory,</span>
<span class="line-modified">1243           argv,</span>
<span class="line-modified">1244           envp,</span>
<span class="line-modified">1245           flags,</span>
<span class="line-modified">1246           child_setup,</span>
<span class="line-modified">1247           child_handle,</span>
<span class="line-modified">1248           stdin_fd,</span>
<span class="line-modified">1249           stdout_fd,</span>
<span class="line-modified">1250           stderr_fd,</span>
<span class="line-modified">1251           NULL,</span>
<span class="line-modified">1252           error);</span>
1253 }
1254 
1255 gboolean
1256 g_spawn_command_line_sync (const gchar  *command_line,
<span class="line-modified">1257                            gchar       **standard_output,</span>
<span class="line-modified">1258                            gchar       **standard_error,</span>
<span class="line-modified">1259                            gint         *exit_status,</span>
<span class="line-modified">1260                            GError      **error)</span>
1261 {
1262   gboolean retval;
1263   gchar **argv = 0;
1264 
1265   g_return_val_if_fail (command_line != NULL, FALSE);
1266 
1267   if (!g_shell_parse_argv (command_line,
1268                            NULL, &amp;argv,
1269                            error))
1270     return FALSE;
1271 
1272   retval = g_spawn_sync (NULL,
<span class="line-modified">1273                          argv,</span>
<span class="line-modified">1274                          NULL,</span>
<span class="line-modified">1275                          G_SPAWN_SEARCH_PATH,</span>
<span class="line-modified">1276                          NULL,</span>
<span class="line-modified">1277                          NULL,</span>
<span class="line-modified">1278                          standard_output,</span>
<span class="line-modified">1279                          standard_error,</span>
<span class="line-modified">1280                          exit_status,</span>
<span class="line-modified">1281                          error);</span>
1282   g_strfreev (argv);
1283 
1284   return retval;
1285 }
1286 
1287 gboolean
1288 g_spawn_command_line_async (const gchar *command_line,
<span class="line-modified">1289                             GError     **error)</span>
1290 {
1291   gboolean retval;
1292   gchar **argv = 0;
1293 
1294   g_return_val_if_fail (command_line != NULL, FALSE);
1295 
1296   if (!g_shell_parse_argv (command_line,
1297                            NULL, &amp;argv,
1298                            error))
1299     return FALSE;
1300 
1301   retval = g_spawn_async (NULL,
<span class="line-modified">1302                           argv,</span>
<span class="line-modified">1303                           NULL,</span>
<span class="line-modified">1304                           G_SPAWN_SEARCH_PATH,</span>
<span class="line-modified">1305                           NULL,</span>
<span class="line-modified">1306                           NULL,</span>
<span class="line-modified">1307                           NULL,</span>
<span class="line-modified">1308                           error);</span>
1309   g_strfreev (argv);
1310 
1311   return retval;
1312 }
1313 
1314 void
1315 g_spawn_close_pid (GPid pid)
1316 {
1317     CloseHandle (pid);
1318 }
1319 
1320 gboolean
1321 g_spawn_check_exit_status (gint      exit_status,
<span class="line-modified">1322          GError  **error)</span>
1323 {
1324   gboolean ret = FALSE;
1325 
1326   if (exit_status != 0)
1327     {
1328       g_set_error (error, G_SPAWN_EXIT_ERROR, exit_status,
<span class="line-modified">1329        _(&quot;Child process exited with code %ld&quot;),</span>
<span class="line-modified">1330        (long) exit_status);</span>
1331       goto out;
1332     }
1333 
1334   ret = TRUE;
1335  out:
1336   return ret;
1337 }
1338 
1339 #ifndef GSTREAMER_LITE
1340 #ifdef G_OS_WIN32
1341 
1342 /* Binary compatibility versions. Not for newly compiled code. */
1343 
1344 _GLIB_EXTERN gboolean g_spawn_async_utf8              (const gchar           *working_directory,
1345                                                        gchar                **argv,
1346                                                        gchar                **envp,
1347                                                        GSpawnFlags            flags,
1348                                                        GSpawnChildSetupFunc   child_setup,
1349                                                        gpointer               user_data,
1350                                                        GPid                  *child_pid,
</pre>
<hr />
<pre>
1363 _GLIB_EXTERN gboolean g_spawn_sync_utf8               (const gchar           *working_directory,
1364                                                        gchar                **argv,
1365                                                        gchar                **envp,
1366                                                        GSpawnFlags            flags,
1367                                                        GSpawnChildSetupFunc   child_setup,
1368                                                        gpointer               user_data,
1369                                                        gchar                **standard_output,
1370                                                        gchar                **standard_error,
1371                                                        gint                  *exit_status,
1372                                                        GError               **error);
1373 _GLIB_EXTERN gboolean g_spawn_command_line_sync_utf8  (const gchar           *command_line,
1374                                                        gchar                **standard_output,
1375                                                        gchar                **standard_error,
1376                                                        gint                  *exit_status,
1377                                                        GError               **error);
1378 _GLIB_EXTERN gboolean g_spawn_command_line_async_utf8 (const gchar           *command_line,
1379                                                        GError               **error);
1380 
1381 gboolean
1382 g_spawn_async_utf8 (const gchar          *working_directory,
<span class="line-modified">1383                     gchar               **argv,</span>
<span class="line-modified">1384                     gchar               **envp,</span>
<span class="line-modified">1385                     GSpawnFlags           flags,</span>
<span class="line-modified">1386                     GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1387                     gpointer              user_data,</span>
<span class="line-modified">1388                     GPid                 *child_handle,</span>
<span class="line-modified">1389                     GError              **error)</span>
1390 {
1391   return g_spawn_async (working_directory,
1392                         argv,
1393                         envp,
1394                         flags,
1395                         child_setup,
1396                         user_data,
<span class="line-modified">1397                         child_handle,</span>
<span class="line-modified">1398                         error);</span>
1399 }
1400 
1401 gboolean
1402 g_spawn_async_with_pipes_utf8 (const gchar          *working_directory,
<span class="line-modified">1403                                gchar               **argv,</span>
<span class="line-modified">1404                                gchar               **envp,</span>
<span class="line-modified">1405                                GSpawnFlags           flags,</span>
<span class="line-modified">1406                                GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1407                                gpointer              user_data,</span>
<span class="line-modified">1408                                GPid                 *child_handle,</span>
1409                                gint                 *standard_input,
1410                                gint                 *standard_output,
1411                                gint                 *standard_error,
<span class="line-modified">1412                                GError              **error)</span>
1413 {
1414   return g_spawn_async_with_pipes (working_directory,
1415                                    argv,
1416                                    envp,
<span class="line-modified">1417                                    flags,</span>
<span class="line-modified">1418                                    child_setup,</span>
<span class="line-modified">1419                                    user_data,</span>
<span class="line-modified">1420                                    child_handle,</span>
1421                                    standard_input,
1422                                    standard_output,
1423                                    standard_error,
<span class="line-modified">1424                                    error);</span>
1425 }
1426 
1427 gboolean
1428 g_spawn_sync_utf8 (const gchar          *working_directory,
<span class="line-modified">1429                    gchar               **argv,</span>
<span class="line-modified">1430                    gchar               **envp,</span>
<span class="line-modified">1431                    GSpawnFlags           flags,</span>
<span class="line-modified">1432                    GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1433                    gpointer              user_data,</span>
<span class="line-modified">1434                    gchar               **standard_output,</span>
<span class="line-modified">1435                    gchar               **standard_error,</span>
<span class="line-modified">1436                    gint                 *exit_status,</span>
<span class="line-modified">1437                    GError              **error)</span>
1438 {
1439   return g_spawn_sync (working_directory,
1440                        argv,
1441                        envp,
1442                        flags,
1443                        child_setup,
1444                        user_data,
1445                        standard_output,
1446                        standard_error,
1447                        exit_status,
<span class="line-modified">1448                        error);</span>
1449 }
1450 
1451 gboolean
1452 g_spawn_command_line_sync_utf8 (const gchar  *command_line,
<span class="line-modified">1453                                 gchar       **standard_output,</span>
<span class="line-modified">1454                                 gchar       **standard_error,</span>
<span class="line-modified">1455                                 gint         *exit_status,</span>
<span class="line-modified">1456                                 GError      **error)</span>
1457 {
1458   return g_spawn_command_line_sync (command_line,
<span class="line-modified">1459                                     standard_output,</span>
<span class="line-modified">1460                                     standard_error,</span>
<span class="line-modified">1461                                     exit_status,</span>
<span class="line-modified">1462                                     error);</span>
1463 }
1464 
1465 gboolean
1466 g_spawn_command_line_async_utf8 (const gchar *command_line,
<span class="line-modified">1467                                  GError     **error)</span>
1468 {
1469   return g_spawn_command_line_async (command_line, error);
1470 }
1471 
1472 #endif /* G_OS_WIN32 */
1473 #endif // GSTREAMER_LITE
1474 
1475 #endif /* !GSPAWN_HELPER */
</pre>
</td>
</tr>
</table>
<center><a href="gspawn-win32-helper.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>