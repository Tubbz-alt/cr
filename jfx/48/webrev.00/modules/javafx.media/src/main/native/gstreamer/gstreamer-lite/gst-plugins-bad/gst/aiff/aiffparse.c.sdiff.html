<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-bad/gst/aiff/aiffparse.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../3rd_party/glib/gobject/gvaluetypes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="aiffparse.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-bad/gst/aiff/aiffparse.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 626  *
 627  * Returns: %TRUE if duration is available.
 628  */
 629 static gboolean
 630 gst_aiff_parse_calculate_duration (GstAiffParse * aiff)
 631 {
 632   if (aiff-&gt;duration &gt; 0)
 633     return TRUE;
 634 
 635   if (aiff-&gt;datasize &gt; 0 &amp;&amp; aiff-&gt;bps &gt; 0) {
 636     aiff-&gt;duration =
 637         gst_util_uint64_scale_ceil (aiff-&gt;datasize, GST_SECOND,
 638         (guint64) aiff-&gt;bps);
 639     GST_INFO_OBJECT (aiff, &quot;Got duration %&quot; GST_TIME_FORMAT,
 640         GST_TIME_ARGS (aiff-&gt;duration));
 641     return TRUE;
 642   }
 643   return FALSE;
 644 }
 645 
<span class="line-modified"> 646 static void</span>
 647 gst_aiff_parse_ignore_chunk (GstAiffParse * aiff, guint32 tag, guint32 size)
 648 {
 649 #ifdef GSTREAMER_LITE
 650     guint64 flush;
 651 #else
 652     guint flush;
 653 #endif
 654 
 655   if (aiff-&gt;streaming) {
<span class="line-modified"> 656     if (!gst_aiff_parse_peek_chunk (aiff, &amp;tag, &amp;size))</span>
<span class="line-modified"> 657       return;</span>



 658   }
 659   GST_WARNING_OBJECT (aiff, &quot;Ignoring tag %&quot; GST_FOURCC_FORMAT,
 660       GST_FOURCC_ARGS (tag));
 661 #ifdef GSTREAMER_LITE
 662   flush = 8 + (((guint64)size + 1) &amp; ~1);
 663 #else
 664   flush = 8 + ((size + 1) &amp; ~1);
 665 #endif
 666   aiff-&gt;offset += flush;
 667   if (aiff-&gt;streaming) {
 668     gst_adapter_flush (aiff-&gt;adapter, flush);
 669   }

 670 }
 671 
 672 static double
 673 gst_aiff_parse_read_IEEE80 (guint8 * buf)
 674 {
 675   int s = buf[0] &amp; 0xff;
 676   int e = ((buf[0] &amp; 0x7f) &lt;&lt; 8) | (buf[1] &amp; 0xff);
 677   double f = ((unsigned long) (buf[2] &amp; 0xff) &lt;&lt; 24) |
 678       ((buf[3] &amp; 0xff) &lt;&lt; 16) | ((buf[4] &amp; 0xff) &lt;&lt; 8) | (buf[5] &amp; 0xff);
 679 
 680   if (e == 32767) {
 681     if (buf[2] &amp; 0x80)
 682       return HUGE_VAL;          /* Really NaN, but this won&#39;t happen in reality */
 683     else {
 684       if (s)
 685         return -HUGE_VAL;
 686       else
 687         return HUGE_VAL;
 688     }
 689   }
</pre>
<hr />
<pre>
1107         }
1108 
1109         GST_LOG_OBJECT (aiff, &quot;ID3 chunk of size %&quot; G_GSIZE_FORMAT,
1110             gst_buffer_get_size (buf));
1111 
1112         tags = gst_tag_list_from_id3v2_tag (buf);
1113         gst_buffer_unref (buf);
1114 
1115         GST_INFO_OBJECT (aiff, &quot;ID3 tags: %&quot; GST_PTR_FORMAT, tags);
1116 
1117         if (aiff-&gt;tags == NULL) {
1118           aiff-&gt;tags = tags;
1119         } else {
1120           gst_tag_list_insert (aiff-&gt;tags, tags, GST_TAG_MERGE_APPEND);
1121           gst_tag_list_unref (tags);
1122         }
1123         break;
1124       }
1125       case GST_MAKE_FOURCC (&#39;C&#39;, &#39;H&#39;, &#39;A&#39;, &#39;N&#39;):{
1126         GST_FIXME_OBJECT (aiff, &quot;Handle CHAN chunk with channel layouts&quot;);
<span class="line-modified">1127         gst_aiff_parse_ignore_chunk (aiff, tag, size);</span>


1128         break;
1129       }
1130       default:
<span class="line-modified">1131         gst_aiff_parse_ignore_chunk (aiff, tag, size);</span>


1132     }
1133 
1134     buf = NULL;
1135 
1136     if (upstream_size &amp;&amp; (aiff-&gt;offset &gt;= upstream_size)) {
1137       /* Now we have gone through the whole file */
1138       done = TRUE;
1139     }
1140   }
1141 
1142   /* We read all the chunks (in pull mode) or reached the SSND chunk
1143    * (in push mode). We must have both COMM and SSND now; error out
1144    * otherwise.
1145    */
1146   if (!aiff-&gt;got_comm) {
1147     GST_WARNING_OBJECT (aiff, &quot;Failed to find COMM chunk&quot;);
1148     goto no_header;
1149   }
1150   if (!gotdata) {
1151     GST_WARNING_OBJECT (aiff, &quot;Failed to find SSND chunk&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 626  *
 627  * Returns: %TRUE if duration is available.
 628  */
 629 static gboolean
 630 gst_aiff_parse_calculate_duration (GstAiffParse * aiff)
 631 {
 632   if (aiff-&gt;duration &gt; 0)
 633     return TRUE;
 634 
 635   if (aiff-&gt;datasize &gt; 0 &amp;&amp; aiff-&gt;bps &gt; 0) {
 636     aiff-&gt;duration =
 637         gst_util_uint64_scale_ceil (aiff-&gt;datasize, GST_SECOND,
 638         (guint64) aiff-&gt;bps);
 639     GST_INFO_OBJECT (aiff, &quot;Got duration %&quot; GST_TIME_FORMAT,
 640         GST_TIME_ARGS (aiff-&gt;duration));
 641     return TRUE;
 642   }
 643   return FALSE;
 644 }
 645 
<span class="line-modified"> 646 static gboolean</span>
 647 gst_aiff_parse_ignore_chunk (GstAiffParse * aiff, guint32 tag, guint32 size)
 648 {
 649 #ifdef GSTREAMER_LITE
 650     guint64 flush;
 651 #else
 652     guint flush;
 653 #endif
 654 
 655   if (aiff-&gt;streaming) {
<span class="line-modified"> 656     if (!gst_aiff_parse_peek_chunk (aiff, &amp;tag, &amp;size)) {</span>
<span class="line-modified"> 657       GST_LOG_OBJECT (aiff, &quot;Not enough data to skip tag %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added"> 658           GST_FOURCC_ARGS (tag));</span>
<span class="line-added"> 659       return FALSE;</span>
<span class="line-added"> 660     }</span>
 661   }
 662   GST_WARNING_OBJECT (aiff, &quot;Ignoring tag %&quot; GST_FOURCC_FORMAT,
 663       GST_FOURCC_ARGS (tag));
 664 #ifdef GSTREAMER_LITE
 665   flush = 8 + (((guint64)size + 1) &amp; ~1);
 666 #else
 667   flush = 8 + ((size + 1) &amp; ~1);
 668 #endif
 669   aiff-&gt;offset += flush;
 670   if (aiff-&gt;streaming) {
 671     gst_adapter_flush (aiff-&gt;adapter, flush);
 672   }
<span class="line-added"> 673   return TRUE;</span>
 674 }
 675 
 676 static double
 677 gst_aiff_parse_read_IEEE80 (guint8 * buf)
 678 {
 679   int s = buf[0] &amp; 0xff;
 680   int e = ((buf[0] &amp; 0x7f) &lt;&lt; 8) | (buf[1] &amp; 0xff);
 681   double f = ((unsigned long) (buf[2] &amp; 0xff) &lt;&lt; 24) |
 682       ((buf[3] &amp; 0xff) &lt;&lt; 16) | ((buf[4] &amp; 0xff) &lt;&lt; 8) | (buf[5] &amp; 0xff);
 683 
 684   if (e == 32767) {
 685     if (buf[2] &amp; 0x80)
 686       return HUGE_VAL;          /* Really NaN, but this won&#39;t happen in reality */
 687     else {
 688       if (s)
 689         return -HUGE_VAL;
 690       else
 691         return HUGE_VAL;
 692     }
 693   }
</pre>
<hr />
<pre>
1111         }
1112 
1113         GST_LOG_OBJECT (aiff, &quot;ID3 chunk of size %&quot; G_GSIZE_FORMAT,
1114             gst_buffer_get_size (buf));
1115 
1116         tags = gst_tag_list_from_id3v2_tag (buf);
1117         gst_buffer_unref (buf);
1118 
1119         GST_INFO_OBJECT (aiff, &quot;ID3 tags: %&quot; GST_PTR_FORMAT, tags);
1120 
1121         if (aiff-&gt;tags == NULL) {
1122           aiff-&gt;tags = tags;
1123         } else {
1124           gst_tag_list_insert (aiff-&gt;tags, tags, GST_TAG_MERGE_APPEND);
1125           gst_tag_list_unref (tags);
1126         }
1127         break;
1128       }
1129       case GST_MAKE_FOURCC (&#39;C&#39;, &#39;H&#39;, &#39;A&#39;, &#39;N&#39;):{
1130         GST_FIXME_OBJECT (aiff, &quot;Handle CHAN chunk with channel layouts&quot;);
<span class="line-modified">1131         if (!gst_aiff_parse_ignore_chunk (aiff, tag, size)) {</span>
<span class="line-added">1132           return GST_FLOW_OK;</span>
<span class="line-added">1133         }</span>
1134         break;
1135       }
1136       default:
<span class="line-modified">1137         if (!gst_aiff_parse_ignore_chunk (aiff, tag, size)) {</span>
<span class="line-added">1138           return GST_FLOW_OK;</span>
<span class="line-added">1139         }</span>
1140     }
1141 
1142     buf = NULL;
1143 
1144     if (upstream_size &amp;&amp; (aiff-&gt;offset &gt;= upstream_size)) {
1145       /* Now we have gone through the whole file */
1146       done = TRUE;
1147     }
1148   }
1149 
1150   /* We read all the chunks (in pull mode) or reached the SSND chunk
1151    * (in push mode). We must have both COMM and SSND now; error out
1152    * otherwise.
1153    */
1154   if (!aiff-&gt;got_comm) {
1155     GST_WARNING_OBJECT (aiff, &quot;Failed to find COMM chunk&quot;);
1156     goto no_header;
1157   }
1158   if (!gotdata) {
1159     GST_WARNING_OBJECT (aiff, &quot;Failed to find SSND chunk&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../3rd_party/glib/gobject/gvaluetypes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="aiffparse.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>