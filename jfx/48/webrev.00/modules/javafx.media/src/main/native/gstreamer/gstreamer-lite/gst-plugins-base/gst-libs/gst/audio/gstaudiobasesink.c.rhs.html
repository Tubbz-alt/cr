<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiobasesink.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2005 Wim Taymans &lt;wim@fluendo.com&gt;
   4  *
   5  * gstaudiobasesink.c:
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gstaudiobasesink
  25  * @title: GstAudioBaseSink
  26  * @short_description: Base class for audio sinks
  27  * @see_also: #GstAudioSink, #GstAudioRingBuffer.
  28  *
  29  * This is the base class for audio sinks. Subclasses need to implement the
  30  * ::create_ringbuffer vmethod. This base class will then take care of
  31  * writing samples to the ringbuffer, synchronisation, clipping and flushing.
  32  */
<a name="1" id="anc1"></a><span class="line-added">  33 #ifdef HAVE_CONFIG_H</span>
<span class="line-added">  34 #include &quot;config.h&quot;</span>
<span class="line-added">  35 #endif</span>
  36 
  37 #include &lt;string.h&gt;
  38 
  39 #include &lt;gst/audio/audio.h&gt;
  40 #include &quot;gstaudiobasesink.h&quot;
  41 
  42 GST_DEBUG_CATEGORY_STATIC (gst_audio_base_sink_debug);
  43 #define GST_CAT_DEFAULT gst_audio_base_sink_debug
  44 
<a name="2" id="anc2"></a>


  45 struct _GstAudioBaseSinkPrivate
  46 {
  47   /* upstream latency */
  48   GstClockTime us_latency;
  49   /* the clock slaving algorithm in use */
  50   GstAudioBaseSinkSlaveMethod slave_method;
  51   /* running average of clock skew */
  52   GstClockTimeDiff avg_skew;
  53   /* the number of samples we aligned last time */
  54   gint64 last_align;
  55 
  56   gboolean sync_latency;
  57 
  58   GstClockTime eos_time;
  59 
  60   /* number of microseconds we allow clock slaving to drift
  61    * before resyncing */
  62   guint64 drift_tolerance;
  63 
  64   /* number of nanoseconds we allow timestamps to drift
  65    * before resyncing */
  66   GstClockTime alignment_threshold;
  67 
  68   /* time of the previous detected discont candidate */
  69   GstClockTime discont_time;
  70 
  71   /* number of nanoseconds to wait until creating a discontinuity */
  72   GstClockTime discont_wait;
  73 
  74   /* custom slaving algorithm callback */
  75   GstAudioBaseSinkCustomSlavingCallback custom_slaving_callback;
  76   gpointer custom_slaving_cb_data;
  77   GDestroyNotify custom_slaving_cb_notify;
  78 };
  79 
  80 /* BaseAudioSink signals and args */
  81 enum
  82 {
  83   /* FILL ME */
  84   LAST_SIGNAL
  85 };
  86 
  87 /* FIXME: 2.0, store the buffer_time and latency_time in nanoseconds */
  88 #define DEFAULT_BUFFER_TIME     ((200 * GST_MSECOND) / GST_USECOND)
  89 #ifdef GSTREAMER_LITE
  90 #define DEFAULT_LATENCY_TIME    ((40 * GST_MSECOND) / GST_USECOND)
  91 #else // GSTREAMER_LITE
  92 #define DEFAULT_LATENCY_TIME    ((10 * GST_MSECOND) / GST_USECOND)
  93 #endif // GSTREAMER_LITE
  94 #define DEFAULT_PROVIDE_CLOCK   TRUE
  95 #define DEFAULT_SLAVE_METHOD    GST_AUDIO_BASE_SINK_SLAVE_SKEW
  96 
  97 /* FIXME, enable pull mode when clock slaving and trick modes are figured out */
  98 #define DEFAULT_CAN_ACTIVATE_PULL FALSE
  99 
 100 /* when timestamps drift for more than 40ms we resync. This should
 101  * be enough to compensate for timestamp rounding errors. */
 102 #define DEFAULT_ALIGNMENT_THRESHOLD   (40 * GST_MSECOND)
 103 
 104 /* when clock slaving drift for more than 40ms we resync. This is
 105  * a reasonable default */
 106 #define DEFAULT_DRIFT_TOLERANCE   ((40 * GST_MSECOND) / GST_USECOND)
 107 
 108 /* allow for one second before resyncing to see if the timestamps drift will
 109  * fix itself, or is a permanent offset */
 110 #define DEFAULT_DISCONT_WAIT        (1 * GST_SECOND)
 111 
 112 enum
 113 {
 114   PROP_0,
 115 
 116   PROP_BUFFER_TIME,
 117   PROP_LATENCY_TIME,
 118   PROP_PROVIDE_CLOCK,
 119   PROP_SLAVE_METHOD,
 120   PROP_CAN_ACTIVATE_PULL,
 121   PROP_ALIGNMENT_THRESHOLD,
 122   PROP_DRIFT_TOLERANCE,
 123   PROP_DISCONT_WAIT,
 124 
 125   PROP_LAST
 126 };
 127 
 128 #define _do_init \
 129     GST_DEBUG_CATEGORY_INIT (gst_audio_base_sink_debug, &quot;audiobasesink&quot;, 0, &quot;audiobasesink element&quot;);
 130 #define gst_audio_base_sink_parent_class parent_class
 131 G_DEFINE_TYPE_WITH_CODE (GstAudioBaseSink, gst_audio_base_sink,
<a name="3" id="anc3"></a><span class="line-modified"> 132     GST_TYPE_BASE_SINK, G_ADD_PRIVATE (GstAudioBaseSink) _do_init);</span>
 133 
 134 static void gst_audio_base_sink_dispose (GObject * object);
 135 
 136 static void gst_audio_base_sink_set_property (GObject * object, guint prop_id,
 137     const GValue * value, GParamSpec * pspec);
 138 static void gst_audio_base_sink_get_property (GObject * object, guint prop_id,
 139     GValue * value, GParamSpec * pspec);
 140 
 141 static GstStateChangeReturn gst_audio_base_sink_change_state (GstElement *
 142     element, GstStateChange transition);
 143 static gboolean gst_audio_base_sink_activate_pull (GstBaseSink * basesink,
 144     gboolean active);
 145 static gboolean gst_audio_base_sink_query (GstElement * element, GstQuery *
 146     query);
 147 
 148 static GstClock *gst_audio_base_sink_provide_clock (GstElement * elem);
 149 static inline void gst_audio_base_sink_reset_sync (GstAudioBaseSink * sink);
 150 static GstClockTime gst_audio_base_sink_get_time (GstClock * clock,
 151     GstAudioBaseSink * sink);
 152 static void gst_audio_base_sink_callback (GstAudioRingBuffer * rbuf,
 153     guint8 * data, guint len, gpointer user_data);
 154 
 155 static GstFlowReturn gst_audio_base_sink_preroll (GstBaseSink * bsink,
 156     GstBuffer * buffer);
 157 static GstFlowReturn gst_audio_base_sink_render (GstBaseSink * bsink,
 158     GstBuffer * buffer);
 159 static gboolean gst_audio_base_sink_event (GstBaseSink * bsink,
 160     GstEvent * event);
 161 static GstFlowReturn gst_audio_base_sink_wait_event (GstBaseSink * bsink,
 162     GstEvent * event);
 163 static void gst_audio_base_sink_get_times (GstBaseSink * bsink,
 164     GstBuffer * buffer, GstClockTime * start, GstClockTime * end);
 165 static gboolean gst_audio_base_sink_setcaps (GstBaseSink * bsink,
 166     GstCaps * caps);
 167 static GstCaps *gst_audio_base_sink_fixate (GstBaseSink * bsink,
 168     GstCaps * caps);
 169 
 170 static gboolean gst_audio_base_sink_query_pad (GstBaseSink * bsink,
 171     GstQuery * query);
 172 
 173 
 174 /* static guint gst_audio_base_sink_signals[LAST_SIGNAL] = { 0 }; */
 175 
 176 static void
 177 gst_audio_base_sink_class_init (GstAudioBaseSinkClass * klass)
 178 {
 179   GObjectClass *gobject_class;
 180   GstElementClass *gstelement_class;
 181   GstBaseSinkClass *gstbasesink_class;
 182 
 183   gobject_class = (GObjectClass *) klass;
 184   gstelement_class = (GstElementClass *) klass;
 185   gstbasesink_class = (GstBaseSinkClass *) klass;
 186 
<a name="4" id="anc4"></a>

 187   gobject_class-&gt;set_property = gst_audio_base_sink_set_property;
 188   gobject_class-&gt;get_property = gst_audio_base_sink_get_property;
 189   gobject_class-&gt;dispose = gst_audio_base_sink_dispose;
 190 
 191   g_object_class_install_property (gobject_class, PROP_BUFFER_TIME,
 192       g_param_spec_int64 (&quot;buffer-time&quot;, &quot;Buffer Time&quot;,
 193           &quot;Size of audio buffer in microseconds, this is the minimum &quot;
 194           &quot;latency that the sink reports&quot;, 1, G_MAXINT64, DEFAULT_BUFFER_TIME,
 195           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 196 
 197   g_object_class_install_property (gobject_class, PROP_LATENCY_TIME,
 198       g_param_spec_int64 (&quot;latency-time&quot;, &quot;Latency Time&quot;,
 199           &quot;The minimum amount of data to write in each iteration &quot;
 200           &quot;in microseconds&quot;, 1, G_MAXINT64, DEFAULT_LATENCY_TIME,
 201           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 202 
 203   g_object_class_install_property (gobject_class, PROP_PROVIDE_CLOCK,
 204       g_param_spec_boolean (&quot;provide-clock&quot;, &quot;Provide Clock&quot;,
 205           &quot;Provide a clock to be used as the global pipeline clock&quot;,
 206           DEFAULT_PROVIDE_CLOCK, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 207 
 208   g_object_class_install_property (gobject_class, PROP_SLAVE_METHOD,
 209       g_param_spec_enum (&quot;slave-method&quot;, &quot;Slave Method&quot;,
 210           &quot;Algorithm used to match the rate of the masterclock&quot;,
 211           GST_TYPE_AUDIO_BASE_SINK_SLAVE_METHOD, DEFAULT_SLAVE_METHOD,
 212           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 213 
 214   g_object_class_install_property (gobject_class, PROP_CAN_ACTIVATE_PULL,
 215       g_param_spec_boolean (&quot;can-activate-pull&quot;, &quot;Allow Pull Scheduling&quot;,
 216           &quot;Allow pull-based scheduling&quot;, DEFAULT_CAN_ACTIVATE_PULL,
 217           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 218   /**
 219    * GstAudioBaseSink:drift-tolerance:
 220    *
 221    * Controls the amount of time in microseconds that clocks are allowed
 222    * to drift before resynchronisation happens.
 223    */
 224   g_object_class_install_property (gobject_class, PROP_DRIFT_TOLERANCE,
 225       g_param_spec_int64 (&quot;drift-tolerance&quot;, &quot;Drift Tolerance&quot;,
 226           &quot;Tolerance for clock drift in microseconds&quot;, 1,
 227           G_MAXINT64, DEFAULT_DRIFT_TOLERANCE,
 228           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 229   /**
 230    * GstAudioBaseSink:alignment_threshold:
 231    *
 232    * Controls the amount of time in nanoseconds that timestamps are allowed
 233    * to drift from their ideal time before choosing not to align them.
 234    */
 235   g_object_class_install_property (gobject_class, PROP_ALIGNMENT_THRESHOLD,
 236       g_param_spec_uint64 (&quot;alignment-threshold&quot;, &quot;Alignment Threshold&quot;,
 237           &quot;Timestamp alignment threshold in nanoseconds&quot;, 1,
 238           G_MAXUINT64 - 1, DEFAULT_ALIGNMENT_THRESHOLD,
 239           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 240 
 241   /**
 242    * GstAudioBaseSink:discont-wait:
 243    *
 244    * A window of time in nanoseconds to wait before creating a discontinuity as
 245    * a result of breaching the drift-tolerance.
 246    */
 247   g_object_class_install_property (gobject_class, PROP_DISCONT_WAIT,
 248       g_param_spec_uint64 (&quot;discont-wait&quot;, &quot;Discont Wait&quot;,
 249           &quot;Window of time in nanoseconds to wait before &quot;
 250           &quot;creating a discontinuity&quot;, 0,
 251           G_MAXUINT64 - 1, DEFAULT_DISCONT_WAIT,
 252           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 253 
 254   gstelement_class-&gt;change_state =
 255       GST_DEBUG_FUNCPTR (gst_audio_base_sink_change_state);
 256   gstelement_class-&gt;provide_clock =
 257       GST_DEBUG_FUNCPTR (gst_audio_base_sink_provide_clock);
 258   gstelement_class-&gt;query = GST_DEBUG_FUNCPTR (gst_audio_base_sink_query);
 259 
 260   gstbasesink_class-&gt;fixate = GST_DEBUG_FUNCPTR (gst_audio_base_sink_fixate);
 261   gstbasesink_class-&gt;set_caps = GST_DEBUG_FUNCPTR (gst_audio_base_sink_setcaps);
 262   gstbasesink_class-&gt;event = GST_DEBUG_FUNCPTR (gst_audio_base_sink_event);
 263   gstbasesink_class-&gt;wait_event =
 264       GST_DEBUG_FUNCPTR (gst_audio_base_sink_wait_event);
 265   gstbasesink_class-&gt;get_times =
 266       GST_DEBUG_FUNCPTR (gst_audio_base_sink_get_times);
 267   gstbasesink_class-&gt;preroll = GST_DEBUG_FUNCPTR (gst_audio_base_sink_preroll);
 268   gstbasesink_class-&gt;render = GST_DEBUG_FUNCPTR (gst_audio_base_sink_render);
 269   gstbasesink_class-&gt;query = GST_DEBUG_FUNCPTR (gst_audio_base_sink_query_pad);
 270   gstbasesink_class-&gt;activate_pull =
 271       GST_DEBUG_FUNCPTR (gst_audio_base_sink_activate_pull);
 272 
 273   /* ref class from a thread-safe context to work around missing bit of
 274    * thread-safety in GObject */
 275   g_type_class_ref (GST_TYPE_AUDIO_CLOCK);
 276   g_type_class_ref (GST_TYPE_AUDIO_RING_BUFFER);
 277 
 278 }
 279 
 280 static void
 281 gst_audio_base_sink_init (GstAudioBaseSink * audiobasesink)
 282 {
<a name="5" id="anc5"></a><span class="line-modified"> 283   GstBaseSink *basesink = GST_BASE_SINK_CAST (audiobasesink);</span>
 284 
<a name="6" id="anc6"></a><span class="line-modified"> 285   audiobasesink-&gt;priv =</span>
<span class="line-added"> 286       gst_audio_base_sink_get_instance_private (audiobasesink);</span>
 287 
 288   audiobasesink-&gt;buffer_time = DEFAULT_BUFFER_TIME;
 289   audiobasesink-&gt;latency_time = DEFAULT_LATENCY_TIME;
 290   audiobasesink-&gt;priv-&gt;slave_method = DEFAULT_SLAVE_METHOD;
 291   audiobasesink-&gt;priv-&gt;drift_tolerance = DEFAULT_DRIFT_TOLERANCE;
 292   audiobasesink-&gt;priv-&gt;alignment_threshold = DEFAULT_ALIGNMENT_THRESHOLD;
 293   audiobasesink-&gt;priv-&gt;discont_wait = DEFAULT_DISCONT_WAIT;
 294   audiobasesink-&gt;priv-&gt;custom_slaving_callback = NULL;
 295   audiobasesink-&gt;priv-&gt;custom_slaving_cb_data = NULL;
 296   audiobasesink-&gt;priv-&gt;custom_slaving_cb_notify = NULL;
 297 
 298   audiobasesink-&gt;provided_clock = gst_audio_clock_new (&quot;GstAudioSinkClock&quot;,
 299       (GstAudioClockGetTimeFunc) gst_audio_base_sink_get_time, audiobasesink,
 300       NULL);
 301 
<a name="7" id="anc7"></a>
 302   basesink-&gt;can_activate_push = TRUE;
 303   basesink-&gt;can_activate_pull = DEFAULT_CAN_ACTIVATE_PULL;
 304 
 305   gst_base_sink_set_last_sample_enabled (basesink, FALSE);
 306   if (DEFAULT_PROVIDE_CLOCK)
 307     GST_OBJECT_FLAG_SET (basesink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 308   else
 309     GST_OBJECT_FLAG_UNSET (basesink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 310 }
 311 
 312 static void
 313 gst_audio_base_sink_dispose (GObject * object)
 314 {
 315   GstAudioBaseSink *sink;
 316 
 317   sink = GST_AUDIO_BASE_SINK (object);
 318 
 319   if (sink-&gt;priv-&gt;custom_slaving_cb_notify)
 320     sink-&gt;priv-&gt;custom_slaving_cb_notify (sink-&gt;priv-&gt;custom_slaving_cb_data);
 321 
 322   if (sink-&gt;provided_clock) {
 323     gst_audio_clock_invalidate (GST_AUDIO_CLOCK (sink-&gt;provided_clock));
 324     gst_object_unref (sink-&gt;provided_clock);
 325     sink-&gt;provided_clock = NULL;
 326   }
 327 
 328   if (sink-&gt;ringbuffer) {
 329     gst_object_unparent (GST_OBJECT_CAST (sink-&gt;ringbuffer));
 330     sink-&gt;ringbuffer = NULL;
 331   }
 332 
 333   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 334 }
 335 
 336 
 337 static GstClock *
 338 gst_audio_base_sink_provide_clock (GstElement * elem)
 339 {
 340   GstAudioBaseSink *sink;
 341   GstClock *clock;
 342 
 343   sink = GST_AUDIO_BASE_SINK (elem);
 344 
 345 #ifdef GSTREAMER_LITE
 346   GST_OBJECT_LOCK (sink);
 347 #endif // GSTREAMER_LITE
 348 
 349   /* we have no ringbuffer (must be NULL state) */
 350   if (sink-&gt;ringbuffer == NULL)
 351     goto wrong_state;
 352 
 353   if (!gst_audio_ring_buffer_is_acquired (sink-&gt;ringbuffer))
 354     goto wrong_state;
 355 
 356 #ifndef GSTREAMER_LITE
 357   GST_OBJECT_LOCK (sink);
 358 #endif // GSTREAMER_LITE
 359 
 360   if (!GST_OBJECT_FLAG_IS_SET (sink, GST_ELEMENT_FLAG_PROVIDE_CLOCK))
 361     goto clock_disabled;
 362 
 363   clock = GST_CLOCK_CAST (gst_object_ref (sink-&gt;provided_clock));
 364   GST_OBJECT_UNLOCK (sink);
 365 
 366   return clock;
 367 
 368   /* ERRORS */
 369 wrong_state:
 370   {
 371     GST_DEBUG_OBJECT (sink, &quot;ringbuffer not acquired&quot;);
 372 #ifdef GSTREAMER_LITE
 373     GST_OBJECT_UNLOCK (sink);
 374 #endif // GSTREAMER_LITE
 375     return NULL;
 376   }
 377 clock_disabled:
 378   {
 379     GST_DEBUG_OBJECT (sink, &quot;clock provide disabled&quot;);
 380     GST_OBJECT_UNLOCK (sink);
 381     return NULL;
 382   }
 383 }
 384 
 385 static gboolean
 386 gst_audio_base_sink_is_self_provided_clock (GstAudioBaseSink * sink)
 387 {
 388   return (sink-&gt;provided_clock &amp;&amp; GST_IS_AUDIO_CLOCK (sink-&gt;provided_clock) &amp;&amp;
 389       GST_AUDIO_CLOCK_CAST (sink-&gt;provided_clock)-&gt;func ==
 390       (GstAudioClockGetTimeFunc) gst_audio_base_sink_get_time);
 391 }
 392 
 393 static gboolean
 394 gst_audio_base_sink_query_pad (GstBaseSink * bsink, GstQuery * query)
 395 {
 396   gboolean res = FALSE;
 397   GstAudioBaseSink *basesink;
 398 
 399   basesink = GST_AUDIO_BASE_SINK (bsink);
 400 
 401   switch (GST_QUERY_TYPE (query)) {
 402     case GST_QUERY_CONVERT:
 403     {
 404       GstFormat src_fmt, dest_fmt;
 405       gint64 src_val, dest_val;
 406 
 407       GST_LOG_OBJECT (basesink, &quot;query convert&quot;);
 408 
 409       if (basesink-&gt;ringbuffer) {
 410         gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, NULL);
 411         res =
 412             gst_audio_ring_buffer_convert (basesink-&gt;ringbuffer, src_fmt,
 413             src_val, dest_fmt, &amp;dest_val);
 414         if (res) {
 415           gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
 416         }
 417       }
 418       break;
 419     }
 420     default:
 421       res = GST_BASE_SINK_CLASS (parent_class)-&gt;query (bsink, query);
 422       break;
 423   }
 424   return res;
 425 }
 426 
 427 static gboolean
 428 gst_audio_base_sink_query (GstElement * element, GstQuery * query)
 429 {
 430   gboolean res = FALSE;
 431   GstAudioBaseSink *basesink;
 432 
 433   basesink = GST_AUDIO_BASE_SINK (element);
 434 
 435   switch (GST_QUERY_TYPE (query)) {
 436     case GST_QUERY_LATENCY:
 437     {
 438       gboolean live, us_live;
 439       GstClockTime min_l, max_l;
 440 
 441       GST_DEBUG_OBJECT (basesink, &quot;latency query&quot;);
 442 
 443       /* ask parent first, it will do an upstream query for us. */
 444       if ((res =
 445               gst_base_sink_query_latency (GST_BASE_SINK_CAST (basesink), &amp;live,
 446                   &amp;us_live, &amp;min_l, &amp;max_l))) {
 447         GstClockTime base_latency, min_latency, max_latency;
 448 
 449         /* we and upstream are both live, adjust the min_latency */
 450         if (live &amp;&amp; us_live) {
 451           GstAudioRingBufferSpec *spec;
 452 
 453           GST_OBJECT_LOCK (basesink);
 454           if (!basesink-&gt;ringbuffer || !basesink-&gt;ringbuffer-&gt;spec.info.rate) {
 455             GST_OBJECT_UNLOCK (basesink);
 456 
 457             GST_DEBUG_OBJECT (basesink,
 458                 &quot;we are not negotiated, can&#39;t report latency yet&quot;);
 459             res = FALSE;
 460             goto done;
 461           }
 462           spec = &amp;basesink-&gt;ringbuffer-&gt;spec;
 463 
 464           basesink-&gt;priv-&gt;us_latency = min_l;
 465 
 466           base_latency =
 467               gst_util_uint64_scale_int (spec-&gt;seglatency * spec-&gt;segsize,
 468               GST_SECOND, spec-&gt;info.rate * spec-&gt;info.bpf);
 469           GST_OBJECT_UNLOCK (basesink);
 470 
 471           /* we cannot go lower than the buffer size and the min peer latency */
 472           min_latency = base_latency + min_l;
 473           /* the max latency is the max of the peer, we can delay an infinite
 474            * amount of time. */
 475           max_latency = (max_l == -1) ? -1 : (base_latency + max_l);
 476 
 477           GST_DEBUG_OBJECT (basesink,
 478               &quot;peer min %&quot; GST_TIME_FORMAT &quot;, our min latency: %&quot;
 479               GST_TIME_FORMAT, GST_TIME_ARGS (min_l),
 480               GST_TIME_ARGS (min_latency));
 481           GST_DEBUG_OBJECT (basesink,
 482               &quot;peer max %&quot; GST_TIME_FORMAT &quot;, our max latency: %&quot;
 483               GST_TIME_FORMAT, GST_TIME_ARGS (max_l),
 484               GST_TIME_ARGS (max_latency));
 485         } else {
 486           GST_DEBUG_OBJECT (basesink,
 487               &quot;peer or we are not live, don&#39;t care about latency&quot;);
 488           min_latency = min_l;
 489           max_latency = max_l;
 490         }
 491         gst_query_set_latency (query, live, min_latency, max_latency);
 492       }
 493       break;
 494     }
 495     case GST_QUERY_CONVERT:
 496     {
 497       GstFormat src_fmt, dest_fmt;
 498       gint64 src_val, dest_val;
 499 
 500       GST_LOG_OBJECT (basesink, &quot;query convert&quot;);
 501 
 502       if (basesink-&gt;ringbuffer) {
 503         gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, NULL);
 504         res =
 505             gst_audio_ring_buffer_convert (basesink-&gt;ringbuffer, src_fmt,
 506             src_val, dest_fmt, &amp;dest_val);
 507         if (res) {
 508           gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
 509         }
 510       }
 511       break;
 512     }
 513     default:
 514       res = GST_ELEMENT_CLASS (parent_class)-&gt;query (element, query);
 515       break;
 516   }
 517 
 518 done:
 519   return res;
 520 }
 521 
 522 
 523 /* we call this function without holding the lock on sink for performance
 524  * reasons. Try hard to not deal with and invalid ringbuffer and rate. */
 525 static GstClockTime
 526 gst_audio_base_sink_get_time (GstClock * clock, GstAudioBaseSink * sink)
 527 {
 528   guint64 raw, samples;
 529   guint delay;
 530   GstClockTime result;
 531   GstAudioRingBuffer *ringbuffer;
 532   gint rate;
 533 
 534   if ((ringbuffer = sink-&gt;ringbuffer) == NULL)
 535     return GST_CLOCK_TIME_NONE;
 536 
 537   if ((rate = ringbuffer-&gt;spec.info.rate) == 0)
 538     return GST_CLOCK_TIME_NONE;
 539 
 540   /* our processed samples are always increasing */
 541   raw = samples = gst_audio_ring_buffer_samples_done (ringbuffer);
 542 
 543   /* the number of samples not yet processed, this is still queued in the
 544    * device (not played for playback). */
 545   delay = gst_audio_ring_buffer_delay (ringbuffer);
 546 
 547   if (G_LIKELY (samples &gt;= delay))
 548     samples -= delay;
 549   else
 550     samples = 0;
 551 
 552   result = gst_util_uint64_scale_int (samples, GST_SECOND, rate);
 553 
 554   GST_DEBUG_OBJECT (sink,
 555       &quot;processed samples: raw %&quot; G_GUINT64_FORMAT &quot;, delay %u, real %&quot;
 556       G_GUINT64_FORMAT &quot;, time %&quot; GST_TIME_FORMAT,
 557       raw, delay, samples, GST_TIME_ARGS (result));
 558 
 559   return result;
 560 }
 561 
 562 /**
 563  * gst_audio_base_sink_set_provide_clock:
 564  * @sink: a #GstAudioBaseSink
 565  * @provide: new state
 566  *
 567  * Controls whether @sink will provide a clock or not. If @provide is %TRUE,
 568  * gst_element_provide_clock() will return a clock that reflects the datarate
 569  * of @sink. If @provide is %FALSE, gst_element_provide_clock() will return
 570  * NULL.
 571  */
 572 void
 573 gst_audio_base_sink_set_provide_clock (GstAudioBaseSink * sink,
 574     gboolean provide)
 575 {
 576   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 577 
 578   GST_OBJECT_LOCK (sink);
 579   if (provide)
 580     GST_OBJECT_FLAG_SET (sink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 581   else
 582     GST_OBJECT_FLAG_UNSET (sink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 583   GST_OBJECT_UNLOCK (sink);
 584 }
 585 
 586 /**
 587  * gst_audio_base_sink_get_provide_clock:
 588  * @sink: a #GstAudioBaseSink
 589  *
 590  * Queries whether @sink will provide a clock or not. See also
 591  * gst_audio_base_sink_set_provide_clock.
 592  *
 593  * Returns: %TRUE if @sink will provide a clock.
 594  */
 595 gboolean
 596 gst_audio_base_sink_get_provide_clock (GstAudioBaseSink * sink)
 597 {
 598   gboolean result;
 599 
 600   g_return_val_if_fail (GST_IS_AUDIO_BASE_SINK (sink), FALSE);
 601 
 602   GST_OBJECT_LOCK (sink);
 603   result = GST_OBJECT_FLAG_IS_SET (sink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 604   GST_OBJECT_UNLOCK (sink);
 605 
 606   return result;
 607 }
 608 
 609 /**
 610  * gst_audio_base_sink_set_slave_method:
 611  * @sink: a #GstAudioBaseSink
 612  * @method: the new slave method
 613  *
 614  * Controls how clock slaving will be performed in @sink.
 615  */
 616 void
 617 gst_audio_base_sink_set_slave_method (GstAudioBaseSink * sink,
 618     GstAudioBaseSinkSlaveMethod method)
 619 {
 620   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 621 
 622   GST_OBJECT_LOCK (sink);
 623   sink-&gt;priv-&gt;slave_method = method;
 624   GST_OBJECT_UNLOCK (sink);
 625 }
 626 
 627 /**
 628  * gst_audio_base_sink_get_slave_method:
 629  * @sink: a #GstAudioBaseSink
 630  *
 631  * Get the current slave method used by @sink.
 632  *
 633  * Returns: The current slave method used by @sink.
 634  */
 635 GstAudioBaseSinkSlaveMethod
 636 gst_audio_base_sink_get_slave_method (GstAudioBaseSink * sink)
 637 {
 638   GstAudioBaseSinkSlaveMethod result;
 639 
 640   g_return_val_if_fail (GST_IS_AUDIO_BASE_SINK (sink), -1);
 641 
 642   GST_OBJECT_LOCK (sink);
 643   result = sink-&gt;priv-&gt;slave_method;
 644   GST_OBJECT_UNLOCK (sink);
 645 
 646   return result;
 647 }
 648 
 649 
 650 /**
 651  * gst_audio_base_sink_set_drift_tolerance:
 652  * @sink: a #GstAudioBaseSink
 653  * @drift_tolerance: the new drift tolerance in microseconds
 654  *
 655  * Controls the sink&#39;s drift tolerance.
 656  */
 657 void
 658 gst_audio_base_sink_set_drift_tolerance (GstAudioBaseSink * sink,
 659     gint64 drift_tolerance)
 660 {
 661   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 662 
 663   GST_OBJECT_LOCK (sink);
 664   sink-&gt;priv-&gt;drift_tolerance = drift_tolerance;
 665   GST_OBJECT_UNLOCK (sink);
 666 }
 667 
 668 /**
 669  * gst_audio_base_sink_get_drift_tolerance:
 670  * @sink: a #GstAudioBaseSink
 671  *
 672  * Get the current drift tolerance, in microseconds, used by @sink.
 673  *
 674  * Returns: The current drift tolerance used by @sink.
 675  */
 676 gint64
 677 gst_audio_base_sink_get_drift_tolerance (GstAudioBaseSink * sink)
 678 {
 679   gint64 result;
 680 
 681   g_return_val_if_fail (GST_IS_AUDIO_BASE_SINK (sink), -1);
 682 
 683   GST_OBJECT_LOCK (sink);
 684   result = sink-&gt;priv-&gt;drift_tolerance;
 685   GST_OBJECT_UNLOCK (sink);
 686 
 687   return result;
 688 }
 689 
 690 /**
 691  * gst_audio_base_sink_set_alignment_threshold:
 692  * @sink: a #GstAudioBaseSink
 693  * @alignment_threshold: the new alignment threshold in nanoseconds
 694  *
 695  * Controls the sink&#39;s alignment threshold.
 696  */
 697 void
 698 gst_audio_base_sink_set_alignment_threshold (GstAudioBaseSink * sink,
 699     GstClockTime alignment_threshold)
 700 {
 701   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 702 
 703   GST_OBJECT_LOCK (sink);
 704   sink-&gt;priv-&gt;alignment_threshold = alignment_threshold;
 705   GST_OBJECT_UNLOCK (sink);
 706 }
 707 
 708 /**
 709  * gst_audio_base_sink_get_alignment_threshold:
 710  * @sink: a #GstAudioBaseSink
 711  *
 712  * Get the current alignment threshold, in nanoseconds, used by @sink.
 713  *
 714  * Returns: The current alignment threshold used by @sink.
 715  */
 716 GstClockTime
 717 gst_audio_base_sink_get_alignment_threshold (GstAudioBaseSink * sink)
 718 {
 719   GstClockTime result;
 720 
 721   g_return_val_if_fail (GST_IS_AUDIO_BASE_SINK (sink), GST_CLOCK_TIME_NONE);
 722 
 723   GST_OBJECT_LOCK (sink);
 724   result = sink-&gt;priv-&gt;alignment_threshold;
 725   GST_OBJECT_UNLOCK (sink);
 726 
 727   return result;
 728 }
 729 
 730 /**
 731  * gst_audio_base_sink_set_discont_wait:
 732  * @sink: a #GstAudioBaseSink
 733  * @discont_wait: the new discont wait in nanoseconds
 734  *
 735  * Controls how long the sink will wait before creating a discontinuity.
 736  */
 737 void
 738 gst_audio_base_sink_set_discont_wait (GstAudioBaseSink * sink,
 739     GstClockTime discont_wait)
 740 {
 741   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 742 
 743   GST_OBJECT_LOCK (sink);
 744   sink-&gt;priv-&gt;discont_wait = discont_wait;
 745   GST_OBJECT_UNLOCK (sink);
 746 }
 747 
 748 /**
 749  * gst_audio_base_sink_set_custom_slaving_callback:
 750  * @sink: a #GstAudioBaseSink
 751  * @callback: a #GstAudioBaseSinkCustomSlavingCallback
 752  * @user_data: user data passed to the callback
 753  * @notify : called when user_data becomes unused
 754  *
 755  * Sets the custom slaving callback. This callback will
 756  * be invoked if the slave-method property is set to
 757  * GST_AUDIO_BASE_SINK_SLAVE_CUSTOM and the audio sink
 758  * receives and plays samples.
 759  *
 760  * Setting the callback to NULL causes the sink to
 761  * behave as if the GST_AUDIO_BASE_SINK_SLAVE_NONE
 762  * method were used.
 763  *
 764  * Since: 1.6
 765  */
 766 void
 767 gst_audio_base_sink_set_custom_slaving_callback (GstAudioBaseSink * sink,
 768     GstAudioBaseSinkCustomSlavingCallback callback,
 769     gpointer user_data, GDestroyNotify notify)
 770 {
 771   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 772 
 773   GST_OBJECT_LOCK (sink);
 774   sink-&gt;priv-&gt;custom_slaving_callback = callback;
 775   sink-&gt;priv-&gt;custom_slaving_cb_data = user_data;
 776   sink-&gt;priv-&gt;custom_slaving_cb_notify = notify;
 777   GST_OBJECT_UNLOCK (sink);
 778 }
 779 
 780 static void
 781 gst_audio_base_sink_custom_cb_report_discont (GstAudioBaseSink * sink,
 782     GstAudioBaseSinkDiscontReason discont_reason)
 783 {
 784   if ((sink-&gt;priv-&gt;custom_slaving_callback != NULL) &amp;&amp;
 785       (sink-&gt;priv-&gt;slave_method == GST_AUDIO_BASE_SINK_SLAVE_CUSTOM)) {
 786     sink-&gt;priv-&gt;custom_slaving_callback (sink, GST_CLOCK_TIME_NONE,
 787         GST_CLOCK_TIME_NONE, NULL, discont_reason,
 788         sink-&gt;priv-&gt;custom_slaving_cb_data);
 789   }
 790 }
 791 
 792 /**
 793  * gst_audio_base_sink_report_device_failure:
 794  * @sink: a #GstAudioBaseSink
 795  *
 796  * Informs this base class that the audio output device has failed for
 797  * some reason, causing a discontinuity (for example, because the device
 798  * recovered from the error, but lost all contents of its ring buffer).
 799  * This function is typically called by derived classes, and is useful
 800  * for the custom slave method.
 801  *
 802  * Since: 1.6
 803  */
 804 void
 805 gst_audio_base_sink_report_device_failure (GstAudioBaseSink * sink)
 806 {
 807   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 808 
 809   GST_OBJECT_LOCK (sink);
 810   gst_audio_base_sink_custom_cb_report_discont (sink,
 811       GST_AUDIO_BASE_SINK_DISCONT_REASON_DEVICE_FAILURE);
 812   GST_OBJECT_UNLOCK (sink);
 813 }
 814 
 815 /**
 816  * gst_audio_base_sink_get_discont_wait:
 817  * @sink: a #GstAudioBaseSink
 818  *
 819  * Get the current discont wait, in nanoseconds, used by @sink.
 820  *
 821  * Returns: The current discont wait used by @sink.
 822  */
 823 GstClockTime
 824 gst_audio_base_sink_get_discont_wait (GstAudioBaseSink * sink)
 825 {
 826   GstClockTime result;
 827 
 828   g_return_val_if_fail (GST_IS_AUDIO_BASE_SINK (sink), -1);
 829 
 830   GST_OBJECT_LOCK (sink);
 831   result = sink-&gt;priv-&gt;discont_wait;
 832   GST_OBJECT_UNLOCK (sink);
 833 
 834   return result;
 835 }
 836 
 837 static void
 838 gst_audio_base_sink_set_property (GObject * object, guint prop_id,
 839     const GValue * value, GParamSpec * pspec)
 840 {
 841   GstAudioBaseSink *sink;
 842 
 843   sink = GST_AUDIO_BASE_SINK (object);
 844 
 845   switch (prop_id) {
 846     case PROP_BUFFER_TIME:
 847       sink-&gt;buffer_time = g_value_get_int64 (value);
 848       break;
 849     case PROP_LATENCY_TIME:
 850       sink-&gt;latency_time = g_value_get_int64 (value);
 851       break;
 852     case PROP_PROVIDE_CLOCK:
 853       gst_audio_base_sink_set_provide_clock (sink, g_value_get_boolean (value));
 854       break;
 855     case PROP_SLAVE_METHOD:
 856       gst_audio_base_sink_set_slave_method (sink, g_value_get_enum (value));
 857       break;
 858     case PROP_CAN_ACTIVATE_PULL:
 859       GST_BASE_SINK (sink)-&gt;can_activate_pull = g_value_get_boolean (value);
 860       break;
 861     case PROP_DRIFT_TOLERANCE:
 862       gst_audio_base_sink_set_drift_tolerance (sink, g_value_get_int64 (value));
 863       break;
 864     case PROP_ALIGNMENT_THRESHOLD:
 865       gst_audio_base_sink_set_alignment_threshold (sink,
 866           g_value_get_uint64 (value));
 867       break;
 868     case PROP_DISCONT_WAIT:
 869       gst_audio_base_sink_set_discont_wait (sink, g_value_get_uint64 (value));
 870       break;
 871     default:
 872       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 873       break;
 874   }
 875 }
 876 
 877 static void
 878 gst_audio_base_sink_get_property (GObject * object, guint prop_id,
 879     GValue * value, GParamSpec * pspec)
 880 {
 881   GstAudioBaseSink *sink;
 882 
 883   sink = GST_AUDIO_BASE_SINK (object);
 884 
 885   switch (prop_id) {
 886     case PROP_BUFFER_TIME:
 887       g_value_set_int64 (value, sink-&gt;buffer_time);
 888       break;
 889     case PROP_LATENCY_TIME:
 890       g_value_set_int64 (value, sink-&gt;latency_time);
 891       break;
 892     case PROP_PROVIDE_CLOCK:
 893       g_value_set_boolean (value, gst_audio_base_sink_get_provide_clock (sink));
 894       break;
 895     case PROP_SLAVE_METHOD:
 896       g_value_set_enum (value, gst_audio_base_sink_get_slave_method (sink));
 897       break;
 898     case PROP_CAN_ACTIVATE_PULL:
 899       g_value_set_boolean (value, GST_BASE_SINK (sink)-&gt;can_activate_pull);
 900       break;
 901     case PROP_DRIFT_TOLERANCE:
 902       g_value_set_int64 (value, gst_audio_base_sink_get_drift_tolerance (sink));
 903       break;
 904     case PROP_ALIGNMENT_THRESHOLD:
 905       g_value_set_uint64 (value,
 906           gst_audio_base_sink_get_alignment_threshold (sink));
 907       break;
 908     case PROP_DISCONT_WAIT:
 909       g_value_set_uint64 (value, gst_audio_base_sink_get_discont_wait (sink));
 910       break;
 911     default:
 912       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 913       break;
 914   }
 915 }
 916 
 917 static gboolean
 918 gst_audio_base_sink_setcaps (GstBaseSink * bsink, GstCaps * caps)
 919 {
 920   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (bsink);
 921   GstAudioRingBufferSpec *spec;
 922   GstClockTime now, internal_time;
 923   GstClockTime crate_num, crate_denom;
 924 
 925   if (!sink-&gt;ringbuffer)
 926     return FALSE;
 927 
 928   spec = &amp;sink-&gt;ringbuffer-&gt;spec;
 929 
 930   if (G_UNLIKELY (spec-&gt;caps &amp;&amp; gst_caps_is_equal (spec-&gt;caps, caps))) {
 931     GST_DEBUG_OBJECT (sink,
 932         &quot;Ringbuffer caps haven&#39;t changed, skipping reconfiguration&quot;);
 933     return TRUE;
 934   }
 935 
 936   GST_DEBUG_OBJECT (sink, &quot;release old ringbuffer&quot;);
 937 
 938   /* get current time, updates the last_time. When the subclass has a clock that
 939    * restarts from 0 when a new format is negotiated, it will call
 940    * gst_audio_clock_reset() which will use this last_time to create an offset
 941    * so that time from the clock keeps on increasing monotonically. */
 942   now = gst_clock_get_time (sink-&gt;provided_clock);
 943   internal_time = gst_clock_get_internal_time (sink-&gt;provided_clock);
 944 
 945   GST_DEBUG_OBJECT (sink, &quot;time was %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (now));
 946 
 947   /* release old ringbuffer */
 948   gst_audio_ring_buffer_pause (sink-&gt;ringbuffer);
 949   gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, FALSE);
 950   gst_audio_ring_buffer_release (sink-&gt;ringbuffer);
 951 
 952   GST_DEBUG_OBJECT (sink, &quot;parse caps&quot;);
 953 
 954   spec-&gt;buffer_time = sink-&gt;buffer_time;
 955   spec-&gt;latency_time = sink-&gt;latency_time;
 956 
 957   /* parse new caps */
 958   if (!gst_audio_ring_buffer_parse_caps (spec, caps))
 959     goto parse_error;
 960 
 961   gst_audio_ring_buffer_debug_spec_buff (spec);
 962 
 963   GST_DEBUG_OBJECT (sink, &quot;acquire ringbuffer&quot;);
 964   if (!gst_audio_ring_buffer_acquire (sink-&gt;ringbuffer, spec))
 965     goto acquire_error;
 966 
 967   /* If we use our own clock, we need to adjust the offset since it will now
 968    * restart from zero */
 969   if (gst_audio_base_sink_is_self_provided_clock (sink))
 970     gst_audio_clock_reset (GST_AUDIO_CLOCK (sink-&gt;provided_clock), 0);
 971 
 972   /* We need to resync since the ringbuffer restarted */
 973   gst_audio_base_sink_reset_sync (sink);
 974 
 975   gst_audio_base_sink_custom_cb_report_discont (sink,
 976       GST_AUDIO_BASE_SINK_DISCONT_REASON_NEW_CAPS);
 977 
 978   if (bsink-&gt;pad_mode == GST_PAD_MODE_PUSH) {
 979     GST_DEBUG_OBJECT (sink, &quot;activate ringbuffer&quot;);
 980     gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, TRUE);
 981   }
 982 
 983   /* due to possible changes in the spec file we should recalibrate the clock */
 984   gst_clock_get_calibration (sink-&gt;provided_clock, NULL, NULL,
 985       &amp;crate_num, &amp;crate_denom);
 986   gst_clock_set_calibration (sink-&gt;provided_clock,
 987       internal_time, now, crate_num, crate_denom);
 988 
 989   /* calculate actual latency and buffer times.
 990    * FIXME: In 2.0, store the latency_time internally in ns */
 991   spec-&gt;latency_time = gst_util_uint64_scale (spec-&gt;segsize,
 992       (GST_SECOND / GST_USECOND), spec-&gt;info.rate * spec-&gt;info.bpf);
 993 
 994   spec-&gt;buffer_time = spec-&gt;segtotal * spec-&gt;latency_time;
 995 
 996   gst_audio_ring_buffer_debug_spec_buff (spec);
 997 
 998   gst_element_post_message (GST_ELEMENT_CAST (bsink),
 999       gst_message_new_latency (GST_OBJECT (bsink)));
1000 
1001   return TRUE;
1002 
1003   /* ERRORS */
1004 parse_error:
1005   {
1006     GST_DEBUG_OBJECT (sink, &quot;could not parse caps&quot;);
1007     GST_ELEMENT_ERROR (sink, STREAM, FORMAT,
1008         (NULL), (&quot;cannot parse audio format.&quot;));
1009     return FALSE;
1010   }
1011 acquire_error:
1012   {
1013     GST_DEBUG_OBJECT (sink, &quot;could not acquire ringbuffer&quot;);
1014     return FALSE;
1015   }
1016 }
1017 
1018 static GstCaps *
1019 gst_audio_base_sink_fixate (GstBaseSink * bsink, GstCaps * caps)
1020 {
1021   GstStructure *s;
1022   gint width, depth;
1023 
1024   caps = gst_caps_make_writable (caps);
1025 
1026   s = gst_caps_get_structure (caps, 0);
1027 
1028   /* fields for all formats */
1029   gst_structure_fixate_field_nearest_int (s, &quot;rate&quot;, 44100);
1030   gst_structure_fixate_field_nearest_int (s, &quot;channels&quot;, 2);
1031   gst_structure_fixate_field_nearest_int (s, &quot;width&quot;, 16);
1032 
1033   /* fields for int */
1034   if (gst_structure_has_field (s, &quot;depth&quot;)) {
1035     gst_structure_get_int (s, &quot;width&quot;, &amp;width);
1036     /* round width to nearest multiple of 8 for the depth */
1037     depth = GST_ROUND_UP_8 (width);
1038     gst_structure_fixate_field_nearest_int (s, &quot;depth&quot;, depth);
1039   }
1040   if (gst_structure_has_field (s, &quot;signed&quot;))
1041     gst_structure_fixate_field_boolean (s, &quot;signed&quot;, TRUE);
1042   if (gst_structure_has_field (s, &quot;endianness&quot;))
1043     gst_structure_fixate_field_nearest_int (s, &quot;endianness&quot;, G_BYTE_ORDER);
1044 
1045   caps = GST_BASE_SINK_CLASS (parent_class)-&gt;fixate (bsink, caps);
1046 
1047   return caps;
1048 }
1049 
1050 static inline void
1051 gst_audio_base_sink_reset_sync (GstAudioBaseSink * sink)
1052 {
1053   sink-&gt;next_sample = -1;
1054   sink-&gt;priv-&gt;eos_time = -1;
1055   sink-&gt;priv-&gt;discont_time = -1;
1056   sink-&gt;priv-&gt;avg_skew = -1;
1057   sink-&gt;priv-&gt;last_align = 0;
1058 }
1059 
1060 static void
1061 gst_audio_base_sink_get_times (GstBaseSink * bsink, GstBuffer * buffer,
1062     GstClockTime * start, GstClockTime * end)
1063 {
1064   /* our clock sync is a bit too much for the base class to handle so
1065    * we implement it ourselves. */
1066   *start = GST_CLOCK_TIME_NONE;
1067   *end = GST_CLOCK_TIME_NONE;
1068 }
1069 
1070 static void
1071 gst_audio_base_sink_force_start (GstAudioBaseSink * sink)
1072 {
1073   /* Set the eos_rendering flag so sub-classes definitely start the clock.
1074    * FIXME 2.0: Pass this as a flag to gst_audio_ring_buffer_start() */
1075   g_atomic_int_set (&amp;sink-&gt;eos_rendering, 1);
1076   gst_audio_ring_buffer_start (sink-&gt;ringbuffer);
1077   g_atomic_int_set (&amp;sink-&gt;eos_rendering, 0);
1078 }
1079 
1080 /* This waits for the drain to happen and can be canceled */
1081 static GstFlowReturn
1082 gst_audio_base_sink_drain (GstAudioBaseSink * sink)
1083 {
1084   GstFlowReturn ret = GST_FLOW_OK;
1085   if (!sink-&gt;ringbuffer)
1086     return ret;
1087   if (!sink-&gt;ringbuffer-&gt;spec.info.rate)
1088     return ret;
1089 
1090   /* if PLAYING is interrupted,
1091    * arrange to have clock running when going to PLAYING again */
1092   g_atomic_int_set (&amp;sink-&gt;eos_rendering, 1);
1093 
1094   /* need to start playback before we can drain, but only when
1095    * we have successfully negotiated a format and thus acquired the
1096    * ringbuffer. */
1097   if (gst_audio_ring_buffer_is_acquired (sink-&gt;ringbuffer))
1098     gst_audio_ring_buffer_start (sink-&gt;ringbuffer);
1099 
1100   if (sink-&gt;priv-&gt;eos_time != -1) {
1101     GST_DEBUG_OBJECT (sink,
1102         &quot;last sample time %&quot; GST_TIME_FORMAT,
1103         GST_TIME_ARGS (sink-&gt;priv-&gt;eos_time));
1104 
1105     /* wait for the EOS time to be reached, this is the time when the last
1106      * sample is played. */
1107     ret = gst_base_sink_wait (GST_BASE_SINK (sink), sink-&gt;priv-&gt;eos_time, NULL);
1108 
1109     GST_DEBUG_OBJECT (sink, &quot;drained audio&quot;);
1110   }
1111   g_atomic_int_set (&amp;sink-&gt;eos_rendering, 0);
1112   return ret;
1113 }
1114 
1115 static GstFlowReturn
1116 gst_audio_base_sink_wait_event (GstBaseSink * bsink, GstEvent * event)
1117 {
1118   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (bsink);
1119   GstFlowReturn ret = GST_FLOW_OK;
1120   gboolean clear_force_start_flag = FALSE;
1121 
1122   /* For both gap and EOS events, make sure the ringbuffer is running
1123    * before trying to wait on the event! */
1124   switch (GST_EVENT_TYPE (event)) {
1125     case GST_EVENT_EOS:
1126     case GST_EVENT_GAP:
1127       /* We must have a negotiated format before starting the ringbuffer */
1128       if (G_UNLIKELY (!gst_audio_ring_buffer_is_acquired (sink-&gt;ringbuffer))) {
1129         GST_ELEMENT_ERROR (sink, STREAM, FORMAT, (NULL),
1130             (&quot;Sink not negotiated before %s event.&quot;,
1131                 GST_EVENT_TYPE_NAME (event)));
1132         return GST_FLOW_ERROR;
1133       }
1134 
1135       gst_audio_base_sink_force_start (sink);
1136       /* Make sure the ringbuffer will start again if interrupted during event_wait() */
1137       g_atomic_int_set (&amp;sink-&gt;eos_rendering, 1);
1138       clear_force_start_flag = TRUE;
<a name="8" id="anc8"></a><span class="line-modified">1139       break;</span>
1140     default:
1141       break;
<a name="9" id="anc9"></a><span class="line-modified">1142   }</span>
1143 
1144   ret = GST_BASE_SINK_CLASS (parent_class)-&gt;wait_event (bsink, event);
1145   if (ret != GST_FLOW_OK)
1146     goto done;
1147 
1148   switch (GST_EVENT_TYPE (event)) {
1149     case GST_EVENT_EOS:
1150       /* now wait till we played everything */
1151       ret = gst_audio_base_sink_drain (sink);
1152       break;
1153     default:
1154       break;
1155   }
1156 
1157 done:
1158   if (clear_force_start_flag)
1159     g_atomic_int_set (&amp;sink-&gt;eos_rendering, 0);
1160   return ret;
1161 }
1162 
1163 static gboolean
1164 gst_audio_base_sink_event (GstBaseSink * bsink, GstEvent * event)
1165 {
1166   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (bsink);
1167 
1168   switch (GST_EVENT_TYPE (event)) {
1169     case GST_EVENT_FLUSH_START:
1170       if (sink-&gt;ringbuffer)
1171         gst_audio_ring_buffer_set_flushing (sink-&gt;ringbuffer, TRUE);
1172       break;
1173     case GST_EVENT_FLUSH_STOP:
1174       /* always resync on sample after a flush */
1175       gst_audio_base_sink_reset_sync (sink);
1176 
1177       gst_audio_base_sink_custom_cb_report_discont (sink,
1178           GST_AUDIO_BASE_SINK_DISCONT_REASON_FLUSH);
1179 
1180       if (sink-&gt;ringbuffer)
1181         gst_audio_ring_buffer_set_flushing (sink-&gt;ringbuffer, FALSE);
1182       break;
1183     default:
1184       break;
1185   }
1186   return GST_BASE_SINK_CLASS (parent_class)-&gt;event (bsink, event);
1187 }
1188 
1189 static GstFlowReturn
1190 gst_audio_base_sink_preroll (GstBaseSink * bsink, GstBuffer * buffer)
1191 {
1192   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (bsink);
1193 
1194   if (!gst_audio_ring_buffer_is_acquired (sink-&gt;ringbuffer))
1195     goto wrong_state;
1196 
1197   /* we don&#39;t really do anything when prerolling. We could make a
1198    * property to play this buffer to have some sort of scrubbing
1199    * support. */
1200   return GST_FLOW_OK;
1201 
1202 wrong_state:
1203   {
1204     GST_DEBUG_OBJECT (sink, &quot;ringbuffer in wrong state&quot;);
1205     GST_ELEMENT_ERROR (sink, STREAM, FORMAT, (NULL), (&quot;sink not negotiated.&quot;));
1206     return GST_FLOW_NOT_NEGOTIATED;
1207   }
1208 }
1209 
1210 static guint64
1211 gst_audio_base_sink_get_offset (GstAudioBaseSink * sink)
1212 {
1213   guint64 sample, sps;
1214   gint writeseg, segdone;
1215   gint diff;
1216 
1217   /* assume we can append to the previous sample */
1218   sample = sink-&gt;next_sample;
1219   /* no previous sample, try to insert at position 0 */
1220   if (sample == -1)
1221     sample = 0;
1222 
1223   sps = sink-&gt;ringbuffer-&gt;samples_per_seg;
1224 
1225   /* figure out the segment and the offset inside the segment where
1226    * the sample should be written. */
1227   writeseg = sample / sps;
1228 
1229   /* get the currently processed segment */
1230   segdone = g_atomic_int_get (&amp;sink-&gt;ringbuffer-&gt;segdone)
1231       - sink-&gt;ringbuffer-&gt;segbase;
1232 
1233   /* see how far away it is from the write segment */
1234   diff = writeseg - segdone;
1235   if (diff &lt; 0) {
1236     /* sample would be dropped, position to next playable position */
1237     sample = (segdone + 1) * sps;
1238   }
1239 
1240   return sample;
1241 }
1242 
1243 static GstClockTime
1244 clock_convert_external (GstClockTime external, GstClockTime cinternal,
1245     GstClockTime cexternal, GstClockTime crate_num, GstClockTime crate_denom)
1246 {
1247   /* adjust for rate and speed */
1248   if (external &gt;= cexternal) {
1249     external =
1250         gst_util_uint64_scale (external - cexternal, crate_denom, crate_num);
1251     external += cinternal;
1252   } else {
1253     external =
1254         gst_util_uint64_scale (cexternal - external, crate_denom, crate_num);
1255     if (cinternal &gt; external)
1256       external = cinternal - external;
1257     else
1258       external = 0;
1259   }
1260   return external;
1261 }
1262 
1263 
1264 /* apply the clock offset and invoke a custom callback
1265  * which might also request changes to the playout pointer
1266  *
1267  * this reuses code from the skewing algorithm, but leaves
1268  * decision on whether or not to skew (and how much to skew)
1269  * up to the callback */
1270 static void
1271 gst_audio_base_sink_custom_slaving (GstAudioBaseSink * sink,
1272     GstClockTime render_start, GstClockTime render_stop,
1273     GstClockTime * srender_start, GstClockTime * srender_stop)
1274 {
1275   GstClockTime cinternal, cexternal, crate_num, crate_denom;
1276   GstClockTime etime, itime;
1277   GstClockTimeDiff requested_skew;
1278   gint driftsamples;
1279   gint64 last_align;
1280 
1281   /* get calibration parameters to compensate for offsets */
1282   gst_clock_get_calibration (sink-&gt;provided_clock, &amp;cinternal, &amp;cexternal,
1283       &amp;crate_num, &amp;crate_denom);
1284 
1285   /* sample clocks and figure out clock skew */
1286   etime = gst_clock_get_time (GST_ELEMENT_CLOCK (sink));
1287   itime = gst_audio_clock_get_time (GST_AUDIO_CLOCK (sink-&gt;provided_clock));
1288   itime =
1289       gst_audio_clock_adjust (GST_AUDIO_CLOCK (sink-&gt;provided_clock), itime);
1290 
1291   GST_DEBUG_OBJECT (sink,
1292       &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot; GST_TIME_FORMAT
1293       &quot; cinternal %&quot; GST_TIME_FORMAT &quot; cexternal %&quot; GST_TIME_FORMAT,
1294       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime),
1295       GST_TIME_ARGS (cinternal), GST_TIME_ARGS (cexternal));
1296 
1297   /* make sure we never go below 0 */
1298   etime = etime &gt; cexternal ? etime - cexternal : 0;
1299   itime = itime &gt; cinternal ? itime - cinternal : 0;
1300 
1301   /* don&#39;t do any skewing unless the callback explicitely requests one */
1302   requested_skew = 0;
1303 
1304   if (sink-&gt;priv-&gt;custom_slaving_callback != NULL) {
1305     sink-&gt;priv-&gt;custom_slaving_callback (sink, etime, itime, &amp;requested_skew,
1306         FALSE, sink-&gt;priv-&gt;custom_slaving_cb_data);
1307     GST_DEBUG_OBJECT (sink, &quot;custom slaving requested skew %&quot; GST_STIME_FORMAT,
1308         GST_STIME_ARGS (requested_skew));
1309   } else {
1310     GST_DEBUG_OBJECT (sink,
1311         &quot;no custom slaving callback set - clock drift will not be compensated&quot;);
1312   }
1313 
1314   if (requested_skew &gt; 0) {
1315     cexternal = (cexternal &gt; requested_skew) ? (cexternal - requested_skew) : 0;
1316 
1317     driftsamples =
1318         (sink-&gt;ringbuffer-&gt;spec.info.rate * requested_skew) / GST_SECOND;
1319     last_align = sink-&gt;priv-&gt;last_align;
1320 
1321     /* if we were aligning in the wrong direction or we aligned more than what we
1322      * will correct, resync */
1323     if ((last_align &lt; 0) || (last_align &gt; driftsamples))
1324       sink-&gt;next_sample = -1;
1325 
1326     GST_DEBUG_OBJECT (sink,
1327         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1328         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1329 
1330     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1331         crate_num, crate_denom);
1332   } else if (requested_skew &lt; 0) {
1333     cexternal += ABS (requested_skew);
1334 
1335     driftsamples =
1336         (sink-&gt;ringbuffer-&gt;spec.info.rate * ABS (requested_skew)) / GST_SECOND;
1337     last_align = sink-&gt;priv-&gt;last_align;
1338 
1339     /* if we were aligning in the wrong direction or we aligned more than what we
1340      * will correct, resync */
1341     if ((last_align &gt; 0) || (-last_align &gt; driftsamples))
1342       sink-&gt;next_sample = -1;
1343 
1344     GST_DEBUG_OBJECT (sink,
1345         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1346         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1347 
1348     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1349         crate_num, crate_denom);
1350   }
1351 
1352   /* convert, ignoring speed */
1353   render_start = clock_convert_external (render_start, cinternal, cexternal,
1354       crate_num, crate_denom);
1355   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1356       crate_num, crate_denom);
1357 
1358   *srender_start = render_start;
1359   *srender_stop = render_stop;
1360 }
1361 
1362 /* algorithm to calculate sample positions that will result in resampling to
1363  * match the clock rate of the master */
1364 static void
1365 gst_audio_base_sink_resample_slaving (GstAudioBaseSink * sink,
1366     GstClockTime render_start, GstClockTime render_stop,
1367     GstClockTime * srender_start, GstClockTime * srender_stop)
1368 {
1369   GstClockTime cinternal, cexternal;
1370   GstClockTime crate_num, crate_denom;
1371 
1372   /* FIXME, we can sample and add observations here or use the timeouts on the
1373    * clock. No idea which one is better or more stable. The timeout seems more
1374    * arbitrary but this one seems more demanding and does not work when there is
1375    * no data comming in to the sink. */
1376 #if 0
1377   GstClockTime etime, itime;
1378   gdouble r_squared;
1379 
1380   /* sample clocks and figure out clock skew */
1381   etime = gst_clock_get_time (GST_ELEMENT_CLOCK (sink));
1382   itime = gst_audio_clock_get_time (sink-&gt;provided_clock);
1383 
1384   /* add new observation */
1385   gst_clock_add_observation (sink-&gt;provided_clock, itime, etime, &amp;r_squared);
1386 #endif
1387 
1388   /* get calibration parameters to compensate for speed and offset differences
1389    * when we are slaved */
1390   gst_clock_get_calibration (sink-&gt;provided_clock, &amp;cinternal, &amp;cexternal,
1391       &amp;crate_num, &amp;crate_denom);
1392 
1393   GST_DEBUG_OBJECT (sink, &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot;
1394       GST_TIME_FORMAT &quot; %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT64_FORMAT &quot; = %f&quot;,
1395       GST_TIME_ARGS (cinternal), GST_TIME_ARGS (cexternal), crate_num,
1396       crate_denom, gst_guint64_to_gdouble (crate_num) /
1397       gst_guint64_to_gdouble (crate_denom));
1398 
1399   if (crate_num == 0)
1400     crate_denom = crate_num = 1;
1401 
1402   /* bring external time to internal time */
1403   render_start = clock_convert_external (render_start, cinternal, cexternal,
1404       crate_num, crate_denom);
1405   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1406       crate_num, crate_denom);
1407 
1408   GST_DEBUG_OBJECT (sink,
1409       &quot;after slaving: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
1410       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
1411 
1412   *srender_start = render_start;
1413   *srender_stop = render_stop;
1414 }
1415 
1416 /* algorithm to calculate sample positions that will result in changing the
1417  * playout pointer to match the clock rate of the master */
1418 static void
1419 gst_audio_base_sink_skew_slaving (GstAudioBaseSink * sink,
1420     GstClockTime render_start, GstClockTime render_stop,
1421     GstClockTime * srender_start, GstClockTime * srender_stop)
1422 {
1423   GstClockTime cinternal, cexternal, crate_num, crate_denom;
1424   GstClockTime etime, itime;
<a name="10" id="anc10"></a><span class="line-modified">1425   GstClockTimeDiff skew, drift, mdrift2;</span>
1426   gint driftsamples;
1427   gint64 last_align;
1428 
1429   /* get calibration parameters to compensate for offsets */
1430   gst_clock_get_calibration (sink-&gt;provided_clock, &amp;cinternal, &amp;cexternal,
1431       &amp;crate_num, &amp;crate_denom);
1432 
1433   /* sample clocks and figure out clock skew */
1434   etime = gst_clock_get_time (GST_ELEMENT_CLOCK (sink));
1435   itime = gst_audio_clock_get_time (GST_AUDIO_CLOCK (sink-&gt;provided_clock));
1436   itime =
1437       gst_audio_clock_adjust (GST_AUDIO_CLOCK (sink-&gt;provided_clock), itime);
1438 
1439   GST_DEBUG_OBJECT (sink,
1440       &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot; GST_TIME_FORMAT
1441       &quot; cinternal %&quot; GST_TIME_FORMAT &quot; cexternal %&quot; GST_TIME_FORMAT,
1442       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime),
1443       GST_TIME_ARGS (cinternal), GST_TIME_ARGS (cexternal));
1444 
1445   /* make sure we never go below 0 */
1446   etime = etime &gt; cexternal ? etime - cexternal : 0;
1447   itime = itime &gt; cinternal ? itime - cinternal : 0;
1448 
1449   /* do itime - etime.
1450    * positive value means external clock goes slower
1451    * negative value means external clock goes faster */
1452   skew = GST_CLOCK_DIFF (etime, itime);
1453   if (sink-&gt;priv-&gt;avg_skew == -1) {
1454     /* first observation */
1455     sink-&gt;priv-&gt;avg_skew = skew;
1456   } else {
1457     /* next observations use a moving average */
1458     sink-&gt;priv-&gt;avg_skew = (31 * sink-&gt;priv-&gt;avg_skew + skew) / 32;
1459   }
1460 
1461   GST_DEBUG_OBJECT (sink, &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot;
1462       GST_TIME_FORMAT &quot; skew %&quot; GST_STIME_FORMAT &quot; avg %&quot; GST_STIME_FORMAT,
1463       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime), GST_STIME_ARGS (skew),
1464       GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew));
1465 
1466   /* the max drift we allow */
<a name="11" id="anc11"></a><span class="line-modified">1467   mdrift2 = (sink-&gt;priv-&gt;drift_tolerance * 1000) / 2;</span>

1468 
1469   /* adjust playout pointer based on skew */
1470   if (sink-&gt;priv-&gt;avg_skew &gt; mdrift2) {
<a name="12" id="anc12"></a><span class="line-modified">1471     /* master is running slower, move external time backwards */</span>
1472     GST_WARNING_OBJECT (sink,
1473         &quot;correct clock skew %&quot; GST_STIME_FORMAT &quot; &gt; %&quot; GST_STIME_FORMAT,
1474         GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew), GST_STIME_ARGS (mdrift2));
1475 
<a name="13" id="anc13"></a><span class="line-modified">1476     /* Move the external time backward by the average skew, but don&#39;t ever</span>
<span class="line-modified">1477      * go negative.  Moving the average skew by the same distance defines</span>
<span class="line-modified">1478      * the new clock skew window center point.  This allows the clock to</span>
<span class="line-modified">1479      * drift equally into either direction after the correction. */</span>
<span class="line-modified">1480     if (G_LIKELY (cexternal &gt; sink-&gt;priv-&gt;avg_skew))</span>
<span class="line-modified">1481       drift = sink-&gt;priv-&gt;avg_skew;</span>
<span class="line-modified">1482     else</span>
<span class="line-added">1483       drift = cexternal;</span>
<span class="line-added">1484     cexternal -= drift;</span>
<span class="line-added">1485     sink-&gt;priv-&gt;avg_skew -= drift;</span>
1486 
<a name="14" id="anc14"></a><span class="line-modified">1487     driftsamples = (sink-&gt;ringbuffer-&gt;spec.info.rate * drift) / GST_SECOND;</span>
1488     last_align = sink-&gt;priv-&gt;last_align;
1489 
1490     /* if we were aligning in the wrong direction or we aligned more than what
1491      * we will correct, resync */
1492     if (last_align &lt; 0 || last_align &gt; driftsamples)
1493       sink-&gt;next_sample = -1;
1494 
1495     GST_DEBUG_OBJECT (sink,
1496         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1497         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1498 
1499     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1500         crate_num, crate_denom);
1501   } else if (sink-&gt;priv-&gt;avg_skew &lt; -mdrift2) {
1502     /* master is running faster, move external time forwards */
1503     GST_WARNING_OBJECT (sink,
1504         &quot;correct clock skew %&quot; GST_STIME_FORMAT &quot; &lt; -%&quot; GST_STIME_FORMAT,
1505         GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew), GST_STIME_ARGS (mdrift2));
1506 
<a name="15" id="anc15"></a><span class="line-modified">1507     /* Move the external time forward by the average skew, and move the</span>
<span class="line-modified">1508      * average skew by the same distance (which equals a reset to 0). This</span>
<span class="line-modified">1509      * defines the new clock skew window center point.  This allows the</span>
<span class="line-modified">1510      * clock to drift equally into either direction after the correction. */</span>
<span class="line-modified">1511     drift = -sink-&gt;priv-&gt;avg_skew;</span>
<span class="line-modified">1512     cexternal += drift;</span>
<span class="line-modified">1513     sink-&gt;priv-&gt;avg_skew = 0;</span>
1514 
<a name="16" id="anc16"></a><span class="line-modified">1515     driftsamples = (sink-&gt;ringbuffer-&gt;spec.info.rate * drift) / GST_SECOND;</span>
1516     last_align = sink-&gt;priv-&gt;last_align;
1517 
1518     /* if we were aligning in the wrong direction or we aligned more than what
1519      * we will correct, resync */
1520     if (last_align &gt; 0 || -last_align &gt; driftsamples)
1521       sink-&gt;next_sample = -1;
1522 
1523     GST_DEBUG_OBJECT (sink,
1524         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1525         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1526 
1527     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1528         crate_num, crate_denom);
1529   }
1530 
1531   /* convert, ignoring speed */
1532   render_start = clock_convert_external (render_start, cinternal, cexternal,
1533       crate_num, crate_denom);
1534   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1535       crate_num, crate_denom);
1536 
1537   *srender_start = render_start;
1538   *srender_stop = render_stop;
1539 }
1540 
1541 /* apply the clock offset but do no slaving otherwise */
1542 static void
1543 gst_audio_base_sink_none_slaving (GstAudioBaseSink * sink,
1544     GstClockTime render_start, GstClockTime render_stop,
1545     GstClockTime * srender_start, GstClockTime * srender_stop)
1546 {
1547   GstClockTime cinternal, cexternal, crate_num, crate_denom;
1548 
1549   /* get calibration parameters to compensate for offsets */
1550   gst_clock_get_calibration (sink-&gt;provided_clock, &amp;cinternal, &amp;cexternal,
1551       &amp;crate_num, &amp;crate_denom);
1552 
1553   /* convert, ignoring speed */
1554   render_start = clock_convert_external (render_start, cinternal, cexternal,
1555       crate_num, crate_denom);
1556   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1557       crate_num, crate_denom);
1558 
1559   *srender_start = render_start;
1560   *srender_stop = render_stop;
1561 }
1562 
1563 /* converts render_start and render_stop to their slaved values */
1564 static void
1565 gst_audio_base_sink_handle_slaving (GstAudioBaseSink * sink,
1566     GstClockTime render_start, GstClockTime render_stop,
1567     GstClockTime * srender_start, GstClockTime * srender_stop)
1568 {
1569   switch (sink-&gt;priv-&gt;slave_method) {
1570     case GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE:
1571       gst_audio_base_sink_resample_slaving (sink, render_start, render_stop,
1572           srender_start, srender_stop);
1573       break;
1574     case GST_AUDIO_BASE_SINK_SLAVE_SKEW:
1575       gst_audio_base_sink_skew_slaving (sink, render_start, render_stop,
1576           srender_start, srender_stop);
1577       break;
1578     case GST_AUDIO_BASE_SINK_SLAVE_NONE:
1579       gst_audio_base_sink_none_slaving (sink, render_start, render_stop,
1580           srender_start, srender_stop);
1581       break;
1582     case GST_AUDIO_BASE_SINK_SLAVE_CUSTOM:
1583       gst_audio_base_sink_custom_slaving (sink, render_start, render_stop,
1584           srender_start, srender_stop);
1585       break;
1586     default:
1587       g_warning (&quot;unknown slaving method %d&quot;, sink-&gt;priv-&gt;slave_method);
1588       break;
1589   }
1590 }
1591 
1592 /* must be called with LOCK */
1593 static GstFlowReturn
1594 gst_audio_base_sink_sync_latency (GstBaseSink * bsink, GstMiniObject * obj)
1595 {
1596   GstClock *clock;
1597   GstClockReturn status;
1598   GstClockTime time, render_delay;
1599   GstFlowReturn ret;
1600   GstAudioBaseSink *sink;
1601   GstClockTime itime, etime;
1602   GstClockTime rate_num, rate_denom;
1603   GstClockTimeDiff jitter;
1604 
1605   sink = GST_AUDIO_BASE_SINK (bsink);
1606 
1607   clock = GST_ELEMENT_CLOCK (sink);
1608   if (G_UNLIKELY (clock == NULL))
1609     goto no_clock;
1610 
1611   /* we provided the global clock, don&#39;t need to do anything special */
1612   if (clock == sink-&gt;provided_clock)
1613     goto no_slaving;
1614 
1615   GST_OBJECT_UNLOCK (sink);
1616 
1617   do {
1618     GST_DEBUG_OBJECT (sink, &quot;checking preroll&quot;);
1619 
1620     ret = gst_base_sink_do_preroll (bsink, obj);
1621     if (ret != GST_FLOW_OK)
1622       goto flushing;
1623 
1624     GST_OBJECT_LOCK (sink);
1625     time = sink-&gt;priv-&gt;us_latency;
1626     GST_OBJECT_UNLOCK (sink);
1627 
1628     /* Renderdelay is added onto our own latency, and needs
1629      * to be subtracted as well */
1630     render_delay = gst_base_sink_get_render_delay (bsink);
1631 
1632     if (G_LIKELY (time &gt; render_delay))
1633       time -= render_delay;
1634     else
1635       time = 0;
1636 
1637     /* preroll done, we can sync since we are in PLAYING now. */
1638     GST_DEBUG_OBJECT (sink, &quot;possibly waiting for clock to reach %&quot;
1639         GST_TIME_FORMAT, GST_TIME_ARGS (time));
1640 
1641     /* wait for the clock, this can be interrupted because we got shut down or
1642      * we PAUSED. */
1643     status = gst_base_sink_wait_clock (bsink, time, &amp;jitter);
1644 
1645     GST_DEBUG_OBJECT (sink, &quot;clock returned %d %&quot; GST_TIME_FORMAT, status,
1646         GST_TIME_ARGS (jitter));
1647 
1648     /* invalid time, no clock or sync disabled, just continue then */
1649     if (status == GST_CLOCK_BADTIME)
1650       break;
1651 
1652     /* waiting could have been interrupted and we can be flushing now */
1653     if (G_UNLIKELY (bsink-&gt;flushing))
1654       goto flushing;
1655 
1656     /* retry if we got unscheduled, which means we did not reach the timeout
1657      * yet. if some other error occures, we continue. */
1658   } while (status == GST_CLOCK_UNSCHEDULED);
1659 
1660   GST_DEBUG_OBJECT (sink, &quot;latency synced&quot;);
1661 
1662   /* We might need to take the object lock within gst_audio_clock_get_time(),
1663    * so call that before we take it again */
1664   itime = gst_audio_clock_get_time (GST_AUDIO_CLOCK (sink-&gt;provided_clock));
1665   itime =
1666       gst_audio_clock_adjust (GST_AUDIO_CLOCK (sink-&gt;provided_clock), itime);
1667 
1668   GST_OBJECT_LOCK (sink);
1669 
1670   /* when we prerolled in time, we can accurately set the calibration,
1671    * our internal clock should exactly have been the latency (== the running
1672    * time of the external clock) */
1673   etime = GST_ELEMENT_CAST (sink)-&gt;base_time + time;
1674 
1675   if (status == GST_CLOCK_EARLY) {
1676     /* when we prerolled late, we have to take into account the lateness */
1677     GST_DEBUG_OBJECT (sink, &quot;late preroll, adding jitter&quot;);
1678     etime += jitter;
1679   }
1680 
1681   /* start ringbuffer so we can start slaving right away when we need to */
1682   gst_audio_base_sink_force_start (sink);
1683 
1684   GST_DEBUG_OBJECT (sink,
1685       &quot;internal time: %&quot; GST_TIME_FORMAT &quot; external time: %&quot; GST_TIME_FORMAT,
1686       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime));
1687 
1688   /* copy the original calibrated rate but update the internal and external
1689    * times. */
1690   gst_clock_get_calibration (sink-&gt;provided_clock, NULL, NULL, &amp;rate_num,
1691       &amp;rate_denom);
1692   gst_clock_set_calibration (sink-&gt;provided_clock, itime, etime,
1693       rate_num, rate_denom);
1694 
1695   switch (sink-&gt;priv-&gt;slave_method) {
1696     case GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE:
1697       /* only set as master when we are resampling */
1698       GST_DEBUG_OBJECT (sink, &quot;Setting clock as master&quot;);
1699       gst_clock_set_master (sink-&gt;provided_clock, clock);
1700       break;
1701     case GST_AUDIO_BASE_SINK_SLAVE_SKEW:
1702     case GST_AUDIO_BASE_SINK_SLAVE_NONE:
1703     case GST_AUDIO_BASE_SINK_SLAVE_CUSTOM:
1704     default:
1705       break;
1706   }
1707 
1708   gst_audio_base_sink_reset_sync (sink);
1709 
1710   gst_audio_base_sink_custom_cb_report_discont (sink,
1711       GST_AUDIO_BASE_SINK_DISCONT_REASON_SYNC_LATENCY);
1712 
1713   return GST_FLOW_OK;
1714 
1715   /* ERRORS */
1716 no_clock:
1717   {
1718     GST_DEBUG_OBJECT (sink, &quot;we have no clock&quot;);
1719     return GST_FLOW_OK;
1720   }
1721 no_slaving:
1722   {
1723     GST_DEBUG_OBJECT (sink, &quot;we are not slaved&quot;);
1724     return GST_FLOW_OK;
1725   }
1726 flushing:
1727   {
1728     GST_DEBUG_OBJECT (sink, &quot;we are flushing&quot;);
1729     GST_OBJECT_LOCK (sink);
1730     return GST_FLOW_FLUSHING;
1731   }
1732 }
1733 
1734 static gint64
1735 gst_audio_base_sink_get_alignment (GstAudioBaseSink * sink,
1736     GstClockTime sample_offset)
1737 {
1738   GstAudioRingBuffer *ringbuf = sink-&gt;ringbuffer;
1739   gint64 align;
1740   gint64 sample_diff;
1741   gint64 max_sample_diff;
1742   gint segdone = g_atomic_int_get (&amp;ringbuf-&gt;segdone) - ringbuf-&gt;segbase;
1743   gint64 samples_done = segdone * (gint64) ringbuf-&gt;samples_per_seg;
1744   gint64 headroom = sample_offset - samples_done;
1745   gboolean allow_align = TRUE;
1746   gboolean discont = FALSE;
1747   gint rate;
1748 
1749   /* now try to align the sample to the previous one. */
1750 
1751   /* calc align with previous sample and determine how big the
1752    * difference is. */
1753   align = sink-&gt;next_sample - sample_offset;
1754   sample_diff = ABS (align);
1755 
1756   /* calculate the max allowed drift in units of samples. */
1757   rate = GST_AUDIO_INFO_RATE (&amp;ringbuf-&gt;spec.info);
1758   max_sample_diff = gst_util_uint64_scale_int (sink-&gt;priv-&gt;alignment_threshold,
1759       rate, GST_SECOND);
1760 
1761   /* don&#39;t align if it means writing behind the read-segment */
1762   if (sample_diff &gt; headroom &amp;&amp; align &lt; 0)
1763     allow_align = FALSE;
1764 
1765   if (G_UNLIKELY (sample_diff &gt;= max_sample_diff)) {
1766     /* wait before deciding to make a discontinuity */
1767     if (sink-&gt;priv-&gt;discont_wait &gt; 0) {
1768       GstClockTime time = gst_util_uint64_scale_int (sample_offset,
1769           GST_SECOND, rate);
1770       if (sink-&gt;priv-&gt;discont_time == -1) {
1771         /* discont candidate */
1772         sink-&gt;priv-&gt;discont_time = time;
1773       } else if (time - sink-&gt;priv-&gt;discont_time &gt;= sink-&gt;priv-&gt;discont_wait) {
1774         /* discont_wait expired, discontinuity detected */
1775         discont = TRUE;
1776         sink-&gt;priv-&gt;discont_time = -1;
1777       }
1778     } else {
1779       discont = TRUE;
1780     }
1781   } else if (G_UNLIKELY (sink-&gt;priv-&gt;discont_time != -1)) {
1782     /* we have had a discont, but are now back on track! */
1783     sink-&gt;priv-&gt;discont_time = -1;
1784   }
1785 
1786   if (G_LIKELY (!discont &amp;&amp; allow_align)) {
1787     GST_DEBUG_OBJECT (sink,
1788         &quot;align with prev sample, ABS (%&quot; G_GINT64_FORMAT &quot;) &lt; %&quot;
1789         G_GINT64_FORMAT, align, max_sample_diff);
1790   } else {
1791     gint64 diff_s G_GNUC_UNUSED;
1792 
1793     /* calculate sample diff in seconds for error message */
1794     diff_s = gst_util_uint64_scale_int (sample_diff, GST_SECOND, rate);
1795 
1796     /* timestamps drifted apart from previous samples too much, we need to
1797      * resync. We log this as an element warning. */
1798     GST_WARNING_OBJECT (sink,
1799         &quot;Unexpected discontinuity in audio timestamps of &quot;
1800         &quot;%s%&quot; GST_TIME_FORMAT &quot;, resyncing&quot;,
1801         sample_offset &gt; sink-&gt;next_sample ? &quot;+&quot; : &quot;-&quot;, GST_TIME_ARGS (diff_s));
1802     align = 0;
1803 
1804     gst_audio_base_sink_custom_cb_report_discont (sink,
1805         GST_AUDIO_BASE_SINK_DISCONT_REASON_ALIGNMENT);
1806   }
1807 
1808   return align;
1809 }
1810 
1811 static GstFlowReturn
1812 gst_audio_base_sink_render (GstBaseSink * bsink, GstBuffer * buf)
1813 {
1814   GstClockTime time, stop, render_start, render_stop, sample_offset;
1815   GstClockTimeDiff sync_offset, ts_offset;
1816   GstAudioBaseSinkClass *bclass;
1817   GstAudioBaseSink *sink;
1818   GstAudioRingBuffer *ringbuf;
1819   gint64 diff, align;
1820   guint64 ctime, cstop;
1821   gsize offset;
1822   GstMapInfo info;
1823   gsize size;
1824   guint samples, written;
1825   gint bpf, rate;
1826   gint accum;
1827   gint out_samples;
1828   GstClockTime base_time, render_delay, latency;
1829   GstClock *clock;
1830   gboolean sync, slaved, align_next;
1831   GstFlowReturn ret;
1832   GstSegment clip_seg;
1833   gint64 time_offset;
1834   GstBuffer *out = NULL;
1835 
1836   sink = GST_AUDIO_BASE_SINK (bsink);
1837   bclass = GST_AUDIO_BASE_SINK_GET_CLASS (sink);
1838 
1839   ringbuf = sink-&gt;ringbuffer;
1840 
1841   /* can&#39;t do anything when we don&#39;t have the device */
1842   if (G_UNLIKELY (!gst_audio_ring_buffer_is_acquired (ringbuf)))
1843     goto wrong_state;
1844 
1845   /* Wait for upstream latency before starting the ringbuffer, we do this so
1846    * that we can align the first sample of the ringbuffer to the base_time +
1847    * latency. */
1848   GST_OBJECT_LOCK (sink);
1849   base_time = GST_ELEMENT_CAST (sink)-&gt;base_time;
1850   if (G_UNLIKELY (sink-&gt;priv-&gt;sync_latency)) {
1851     ret = gst_audio_base_sink_sync_latency (bsink, GST_MINI_OBJECT_CAST (buf));
1852     GST_OBJECT_UNLOCK (sink);
1853     if (G_UNLIKELY (ret != GST_FLOW_OK))
1854       goto sync_latency_failed;
1855     /* only do this once until we are set back to PLAYING */
1856     sink-&gt;priv-&gt;sync_latency = FALSE;
1857   } else {
1858     GST_OBJECT_UNLOCK (sink);
1859   }
1860 
1861   /* Before we go on, let&#39;s see if we need to payload the data. If yes, we also
1862    * need to unref the output buffer before leaving. */
1863   if (bclass-&gt;payload) {
1864     out = bclass-&gt;payload (sink, buf);
1865 
1866     if (!out)
1867       goto payload_failed;
1868 
1869     buf = out;
1870   }
1871 
1872   bpf = GST_AUDIO_INFO_BPF (&amp;ringbuf-&gt;spec.info);
1873   rate = GST_AUDIO_INFO_RATE (&amp;ringbuf-&gt;spec.info);
1874 
1875   size = gst_buffer_get_size (buf);
1876   if (G_UNLIKELY (size % bpf) != 0)
1877     goto wrong_size;
1878 
1879   samples = size / bpf;
<a name="17" id="anc17"></a>
1880 
1881   time = GST_BUFFER_TIMESTAMP (buf);
1882 
1883   /* Last ditch attempt to ensure that we only play silence if
1884    * we are in trickmode no-audio mode (or if a buffer is marked as a GAP)
1885    * by dropping the buffer contents and rendering as a gap event instead */
1886   if (G_UNLIKELY ((bsink-&gt;segment.flags &amp; GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO)
1887           || (buf &amp;&amp; GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_GAP)))) {
1888     GstClockTime duration;
1889     GstEvent *event;
1890     GstBaseSinkClass *bclass;
1891     GST_DEBUG_OBJECT (bsink,
1892         &quot;Received GAP or ignoring audio for trickplay. Dropping contents&quot;);
1893 
1894     duration = gst_util_uint64_scale_int (samples, GST_SECOND, rate);
1895     event = gst_event_new_gap (time, duration);
1896 
1897     bclass = GST_BASE_SINK_GET_CLASS (bsink);
1898     ret = bclass-&gt;wait_event (bsink, event);
1899     gst_event_unref (event);
1900 
1901     /* Ensure we&#39;ll resync on the next buffer as if discont */
1902     sink-&gt;next_sample = -1;
1903     goto done;
1904   }
1905 
1906   GST_DEBUG_OBJECT (sink,
1907       &quot;time %&quot; GST_TIME_FORMAT &quot;, start %&quot;
1908       GST_TIME_FORMAT &quot;, samples %u&quot;, GST_TIME_ARGS (time),
1909       GST_TIME_ARGS (bsink-&gt;segment.start), samples);
1910 
1911   offset = 0;
1912 
1913   /* if not valid timestamp or we can&#39;t clip or sync, try to play
1914    * sample ASAP */
1915   if (!GST_CLOCK_TIME_IS_VALID (time)) {
1916     render_start = gst_audio_base_sink_get_offset (sink);
1917     render_stop = render_start + samples;
1918     GST_DEBUG_OBJECT (sink, &quot;Buffer of size %&quot; G_GSIZE_FORMAT &quot; has no time.&quot;
1919         &quot; Using render_start=%&quot; G_GUINT64_FORMAT, size, render_start);
1920     /* we don&#39;t have a start so we don&#39;t know stop either */
1921     stop = -1;
1922     goto no_align;
1923   }
1924 
1925   /* let&#39;s calc stop based on the number of samples in the buffer instead
1926    * of trusting the DURATION */
1927   stop = time + gst_util_uint64_scale_int (samples, GST_SECOND, rate);
1928 
1929   /* prepare the clipping segment. Since we will be subtracting ts-offset and
1930    * device-delay later we scale the start and stop with those values so that we
1931    * can correctly clip them */
1932   clip_seg.format = GST_FORMAT_TIME;
1933   clip_seg.start = bsink-&gt;segment.start;
1934   clip_seg.stop = bsink-&gt;segment.stop;
1935   clip_seg.duration = -1;
1936 
1937   /* the sync offset is the combination of ts-offset and device-delay */
1938   latency = gst_base_sink_get_latency (bsink);
1939   ts_offset = gst_base_sink_get_ts_offset (bsink);
1940   render_delay = gst_base_sink_get_render_delay (bsink);
1941   sync_offset = ts_offset - render_delay + latency;
1942 
1943   GST_DEBUG_OBJECT (sink,
1944       &quot;sync-offset %&quot; GST_STIME_FORMAT &quot;, render-delay %&quot; GST_TIME_FORMAT
1945       &quot;, ts-offset %&quot; GST_STIME_FORMAT, GST_STIME_ARGS (sync_offset),
1946       GST_TIME_ARGS (render_delay), GST_STIME_ARGS (ts_offset));
1947 
1948   /* compensate for ts-offset and device-delay when negative we need to
1949    * clip. */
1950   if (G_UNLIKELY (sync_offset &lt; 0)) {
1951     clip_seg.start += -sync_offset;
1952     if (clip_seg.stop != -1)
1953       clip_seg.stop += -sync_offset;
1954   }
1955 
1956   /* samples should be rendered based on their timestamp. All samples
1957    * arriving before the segment.start or after segment.stop are to be
1958    * thrown away. All samples should also be clipped to the segment
1959    * boundaries */
1960   if (G_UNLIKELY (!gst_segment_clip (&amp;clip_seg, GST_FORMAT_TIME, time, stop,
1961               &amp;ctime, &amp;cstop)))
1962     goto out_of_segment;
1963 
1964   /* see if some clipping happened */
1965   diff = ctime - time;
1966   if (G_UNLIKELY (diff &gt; 0)) {
1967     /* bring clipped time to samples */
1968     diff = gst_util_uint64_scale_int (diff, rate, GST_SECOND);
1969     GST_DEBUG_OBJECT (sink, &quot;clipping start to %&quot; GST_TIME_FORMAT &quot; %&quot;
1970         G_GUINT64_FORMAT &quot; samples&quot;, GST_TIME_ARGS (ctime), diff);
1971     samples -= diff;
1972     offset += diff * bpf;
1973     time = ctime;
1974   }
1975   diff = stop - cstop;
1976   if (G_UNLIKELY (diff &gt; 0)) {
1977     /* bring clipped time to samples */
1978     diff = gst_util_uint64_scale_int (diff, rate, GST_SECOND);
1979     GST_DEBUG_OBJECT (sink, &quot;clipping stop to %&quot; GST_TIME_FORMAT &quot; %&quot;
1980         G_GUINT64_FORMAT &quot; samples&quot;, GST_TIME_ARGS (cstop), diff);
1981     samples -= diff;
1982     stop = cstop;
1983   }
1984 
1985   /* figure out how to sync */
1986   if (G_LIKELY ((clock = GST_ELEMENT_CLOCK (bsink))))
1987     sync = bsink-&gt;sync;
1988   else
1989     sync = FALSE;
1990 
1991   if (G_UNLIKELY (!sync)) {
1992     /* no sync needed, play sample ASAP */
1993     render_start = gst_audio_base_sink_get_offset (sink);
1994     render_stop = render_start + samples;
1995     GST_DEBUG_OBJECT (sink,
1996         &quot;no sync needed. Using render_start=%&quot; G_GUINT64_FORMAT, render_start);
1997     goto no_align;
1998   }
1999 
2000   /* bring buffer start and stop times to running time */
2001   render_start =
2002       gst_segment_to_running_time (&amp;bsink-&gt;segment, GST_FORMAT_TIME, time);
2003   render_stop =
2004       gst_segment_to_running_time (&amp;bsink-&gt;segment, GST_FORMAT_TIME, stop);
2005 
2006   GST_DEBUG_OBJECT (sink,
2007       &quot;running: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
2008       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
2009 
2010   /* store the time of the last sample, we&#39;ll use this to perform sync on the
2011    * last sample when draining the buffer */
2012   if (G_LIKELY (bsink-&gt;segment.rate &gt;= 0.0)) {
2013     sink-&gt;priv-&gt;eos_time = render_stop;
2014   } else {
2015     sink-&gt;priv-&gt;eos_time = render_start;
2016   }
2017 
2018   if (G_UNLIKELY (sync_offset != 0)) {
2019     /* compensate for ts-offset and delay. We know this will not underflow
2020      * because we clipped above. */
<a name="18" id="anc18"></a><span class="line-modified">2021     GST_DEBUG_OBJECT (sink,</span>
<span class="line-modified">2022         &quot;compensating for sync-offset %&quot; GST_TIME_FORMAT,</span>
<span class="line-modified">2023         GST_TIME_ARGS (sync_offset));</span>
<span class="line-modified">2024     render_start += sync_offset;</span>
<span class="line-modified">2025     render_stop += sync_offset;</span>
2026   }
2027 
2028   if (base_time != 0) {
2029     GST_DEBUG_OBJECT (sink, &quot;adding base_time %&quot; GST_TIME_FORMAT,
<a name="19" id="anc19"></a><span class="line-modified">2030         GST_TIME_ARGS (base_time));</span>
2031 
<a name="20" id="anc20"></a><span class="line-modified">2032     /* add base time to sync against the clock */</span>
<span class="line-modified">2033     render_start += base_time;</span>
<span class="line-modified">2034     render_stop += base_time;</span>
2035   }
2036 
2037   if (G_UNLIKELY ((slaved = (clock != sink-&gt;provided_clock)))) {
2038     /* handle clock slaving */
2039     gst_audio_base_sink_handle_slaving (sink, render_start, render_stop,
2040         &amp;render_start, &amp;render_stop);
2041   } else {
2042     /* no slaving needed but we need to adapt to the clock calibration
2043      * parameters */
2044     gst_audio_base_sink_none_slaving (sink, render_start, render_stop,
2045         &amp;render_start, &amp;render_stop);
2046   }
2047 
2048   GST_DEBUG_OBJECT (sink,
2049       &quot;final timestamps: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
2050       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
2051 
2052   /* bring to position in the ringbuffer */
2053   time_offset = GST_AUDIO_CLOCK_CAST (sink-&gt;provided_clock)-&gt;time_offset;
2054 
2055   if (G_UNLIKELY (time_offset != 0)) {
2056     GST_DEBUG_OBJECT (sink,
2057         &quot;apply time offset %&quot; GST_STIME_FORMAT, GST_STIME_ARGS (time_offset));
2058 
2059     if (render_start &gt; time_offset)
2060       render_start -= time_offset;
2061     else
2062       render_start = 0;
2063     if (render_stop &gt; time_offset)
2064       render_stop -= time_offset;
2065     else
2066       render_stop = 0;
2067   }
2068 
2069   /* in some clock slaving cases, all late samples end up at 0 first,
2070    * and subsequent ones align with that until threshold exceeded,
2071    * and then sync back to 0 and so on, so avoid that altogether */
2072   if (G_UNLIKELY (render_start == 0 &amp;&amp; render_stop == 0))
2073     goto too_late;
2074 
2075   /* and bring the time to the rate corrected offset in the buffer */
2076   render_start = gst_util_uint64_scale_int (render_start, rate, GST_SECOND);
2077   render_stop = gst_util_uint64_scale_int (render_stop, rate, GST_SECOND);
2078 
2079   /* If the slaving got us an interval spanning 0, render_start will
2080      have been set to 0. So if render_start is 0, we check whether
2081      render_stop is set to contain all samples. If not, we need to
2082      drop samples to match. */
2083   if (render_start == 0) {
2084     guint nsamples = render_stop - render_start;
2085     if (nsamples &lt; samples) {
2086       guint diff;
2087 
2088       diff = samples - nsamples;
2089       GST_DEBUG_OBJECT (bsink, &quot;Clipped start: %u/%u samples&quot;, nsamples,
2090           samples);
2091       samples -= diff;
2092       offset += diff * bpf;
2093     }
2094   }
2095 
2096   /* positive playback rate, first sample is render_start, negative rate, first
2097    * sample is render_stop. When no rate conversion is active, render exactly
2098    * the amount of input samples to avoid aligning to rounding errors. */
2099   if (G_LIKELY (bsink-&gt;segment.rate &gt;= 0.0)) {
2100     sample_offset = render_start;
2101     if (G_LIKELY (bsink-&gt;segment.rate == 1.0))
2102       render_stop = sample_offset + samples;
2103   } else {
2104     sample_offset = render_stop;
2105     if (bsink-&gt;segment.rate == -1.0)
2106       render_start = sample_offset + samples;
2107   }
2108 
2109   /* always resync after a discont */
2110   if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT) ||
2111           GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_RESYNC))) {
2112     GST_DEBUG_OBJECT (sink, &quot;resync after discont/resync&quot;);
2113     goto no_align;
2114   }
2115 
2116   /* resync when we don&#39;t know what to align the sample with */
2117   if (G_UNLIKELY (sink-&gt;next_sample == -1)) {
2118     GST_DEBUG_OBJECT (sink,
2119         &quot;no align possible: no previous sample position known&quot;);
2120     goto no_align;
2121   }
2122 
2123   align = gst_audio_base_sink_get_alignment (sink, sample_offset);
2124   sink-&gt;priv-&gt;last_align = align;
2125 
2126   /* apply alignment */
2127   render_start += align;
2128 
2129   /* only align stop if we are not slaved to resample */
2130   if (G_UNLIKELY (slaved
2131           &amp;&amp; sink-&gt;priv-&gt;slave_method == GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE)) {
2132     GST_DEBUG_OBJECT (sink, &quot;no stop time align needed: we are slaved&quot;);
2133     goto no_align;
2134   }
2135   render_stop += align;
2136 
2137 no_align:
2138   /* number of target samples is difference between start and stop */
2139   out_samples = render_stop - render_start;
2140 
2141   /* we render the first or last sample first, depending on the rate */
2142   if (G_LIKELY (bsink-&gt;segment.rate &gt;= 0.0))
2143     sample_offset = render_start;
2144   else
2145     sample_offset = render_stop;
2146 
2147   GST_DEBUG_OBJECT (sink, &quot;rendering at %&quot; G_GUINT64_FORMAT &quot; %d/%d&quot;,
2148       sample_offset, samples, out_samples);
2149 
2150   /* we need to accumulate over different runs for when we get interrupted */
2151   accum = 0;
2152   align_next = TRUE;
2153   gst_buffer_map (buf, &amp;info, GST_MAP_READ);
2154   do {
2155     written =
2156         gst_audio_ring_buffer_commit (ringbuf, &amp;sample_offset,
2157         info.data + offset, samples, out_samples, &amp;accum);
2158 
2159     GST_DEBUG_OBJECT (sink, &quot;wrote %u of %u&quot;, written, samples);
2160     /* if we wrote all, we&#39;re done */
2161     if (G_LIKELY (written == samples))
2162       break;
2163 
2164 #ifdef GSTREAMER_LITE
2165     memset(info.data + offset, 0x00, samples*bpf);
2166 #endif // GSTREAMER_LITE
2167 
2168     /* else something interrupted us and we wait for preroll. */
2169     if ((ret = gst_base_sink_wait_preroll (bsink)) != GST_FLOW_OK)
2170       goto stopping;
2171 
2172     /* if we got interrupted, we cannot assume that the next sample should
2173      * be aligned to this one */
2174     align_next = FALSE;
2175 
2176     /* update the output samples. FIXME, this will just skip them when pausing
2177      * during trick mode */
2178     if (out_samples &gt; written) {
2179       out_samples -= written;
2180       accum = 0;
2181     } else
2182       break;
2183 
2184     samples -= written;
2185     offset += written * bpf;
2186   } while (TRUE);
2187   gst_buffer_unmap (buf, &amp;info);
2188 
2189   if (G_LIKELY (align_next))
2190     sink-&gt;next_sample = sample_offset;
2191   else
2192     sink-&gt;next_sample = -1;
2193 
2194   GST_DEBUG_OBJECT (sink, &quot;next sample expected at %&quot; G_GUINT64_FORMAT,
2195       sink-&gt;next_sample);
2196 
2197   if (G_UNLIKELY (GST_CLOCK_TIME_IS_VALID (stop)
2198           &amp;&amp; stop &gt;= bsink-&gt;segment.stop)) {
2199     GST_DEBUG_OBJECT (sink,
2200         &quot;start playback because we are at the end of segment&quot;);
2201     gst_audio_base_sink_force_start (sink);
2202   }
2203 
2204   ret = GST_FLOW_OK;
2205 
2206 done:
2207   if (out)
2208     gst_buffer_unref (out);
2209 
2210   return ret;
2211 
2212   /* SPECIAL cases */
2213 out_of_segment:
2214   {
2215     GST_DEBUG_OBJECT (sink,
2216         &quot;dropping sample out of segment time %&quot; GST_TIME_FORMAT &quot;, start %&quot;
2217         GST_TIME_FORMAT, GST_TIME_ARGS (time),
2218         GST_TIME_ARGS (bsink-&gt;segment.start));
2219     ret = GST_FLOW_OK;
2220     goto done;
2221   }
2222 too_late:
2223   {
2224     GST_DEBUG_OBJECT (sink, &quot;dropping late sample&quot;);
2225     ret = GST_FLOW_OK;
2226     goto done;
2227   }
2228   /* ERRORS */
2229 payload_failed:
2230   {
2231     GST_ELEMENT_ERROR (sink, STREAM, FORMAT, (NULL), (&quot;failed to payload.&quot;));
2232     ret = GST_FLOW_ERROR;
2233     goto done;
2234   }
2235 wrong_state:
2236   {
2237     GST_DEBUG_OBJECT (sink, &quot;ringbuffer not negotiated&quot;);
2238     GST_ELEMENT_ERROR (sink, STREAM, FORMAT, (NULL), (&quot;sink not negotiated.&quot;));
2239     ret = GST_FLOW_NOT_NEGOTIATED;
2240     goto done;
2241   }
2242 wrong_size:
2243   {
2244     GST_DEBUG_OBJECT (sink, &quot;wrong size&quot;);
2245     GST_ELEMENT_ERROR (sink, STREAM, WRONG_TYPE,
2246         (NULL), (&quot;sink received buffer of wrong size.&quot;));
2247     ret = GST_FLOW_ERROR;
2248     goto done;
2249   }
2250 stopping:
2251   {
2252     GST_DEBUG_OBJECT (sink, &quot;preroll got interrupted: %d (%s)&quot;, ret,
2253         gst_flow_get_name (ret));
2254     gst_buffer_unmap (buf, &amp;info);
2255     goto done;
2256   }
2257 sync_latency_failed:
2258   {
2259     GST_DEBUG_OBJECT (sink, &quot;failed waiting for latency&quot;);
2260     goto done;
2261   }
2262 }
2263 
2264 /**
2265  * gst_audio_base_sink_create_ringbuffer:
2266  * @sink: a #GstAudioBaseSink.
2267  *
2268  * Create and return the #GstAudioRingBuffer for @sink. This function will
2269  * call the ::create_ringbuffer vmethod and will set @sink as the parent of
2270  * the returned buffer (see gst_object_set_parent()).
2271  *
2272  * Returns: (transfer none): The new ringbuffer of @sink.
2273  */
2274 GstAudioRingBuffer *
2275 gst_audio_base_sink_create_ringbuffer (GstAudioBaseSink * sink)
2276 {
2277   GstAudioBaseSinkClass *bclass;
2278   GstAudioRingBuffer *buffer = NULL;
2279 
2280   bclass = GST_AUDIO_BASE_SINK_GET_CLASS (sink);
2281   if (bclass-&gt;create_ringbuffer)
2282     buffer = bclass-&gt;create_ringbuffer (sink);
2283 
2284   if (buffer)
2285     gst_object_set_parent (GST_OBJECT (buffer), GST_OBJECT (sink));
2286 
2287   return buffer;
2288 }
2289 
2290 static void
2291 gst_audio_base_sink_callback (GstAudioRingBuffer * rbuf, guint8 * data,
2292     guint len, gpointer user_data)
2293 {
2294   GstBaseSink *basesink;
2295   GstAudioBaseSink *sink;
2296   GstBuffer *buf = NULL;
2297   GstFlowReturn ret;
2298   gsize size;
2299 
2300   basesink = GST_BASE_SINK (user_data);
2301   sink = GST_AUDIO_BASE_SINK (user_data);
2302 
2303   GST_PAD_STREAM_LOCK (basesink-&gt;sinkpad);
2304 
2305   /* would be nice to arrange for pad_alloc_buffer to return data -- as it is we
2306    * will copy twice, once into data, once into DMA */
2307   GST_LOG_OBJECT (basesink, &quot;pulling %u bytes offset %&quot; G_GUINT64_FORMAT
2308       &quot; to fill audio buffer&quot;, len, basesink-&gt;offset);
2309   ret =
2310       gst_pad_pull_range (basesink-&gt;sinkpad, basesink-&gt;segment.position, len,
2311       &amp;buf);
2312 
2313   if (ret != GST_FLOW_OK) {
2314     if (ret == GST_FLOW_EOS)
2315       goto eos;
2316     else
2317       goto error;
2318   }
2319 
2320   GST_BASE_SINK_PREROLL_LOCK (basesink);
2321   if (basesink-&gt;flushing)
2322     goto flushing;
2323 
2324   /* complete preroll and wait for PLAYING */
2325   ret = gst_base_sink_do_preroll (basesink, GST_MINI_OBJECT_CAST (buf));
2326   if (ret != GST_FLOW_OK)
2327     goto preroll_error;
2328 
2329   size = gst_buffer_get_size (buf);
2330 
2331   if (len != size) {
2332     GST_INFO_OBJECT (basesink,
2333         &quot;got different size than requested from sink pad: %u&quot;
2334         &quot; != %&quot; G_GSIZE_FORMAT, len, size);
2335     len = MIN (size, len);
2336   }
2337 
2338   basesink-&gt;segment.position += len;
2339 
2340   gst_buffer_extract (buf, 0, data, len);
2341   GST_BASE_SINK_PREROLL_UNLOCK (basesink);
2342 
2343   GST_PAD_STREAM_UNLOCK (basesink-&gt;sinkpad);
2344 
2345   return;
2346 
2347 error:
2348   {
2349     GST_WARNING_OBJECT (basesink, &quot;Got flow &#39;%s&#39; but can&#39;t return it: %d&quot;,
2350         gst_flow_get_name (ret), ret);
2351     gst_audio_ring_buffer_pause (rbuf);
2352     GST_PAD_STREAM_UNLOCK (basesink-&gt;sinkpad);
2353     return;
2354   }
2355 eos:
2356   {
2357     /* FIXME: this is not quite correct; we&#39;ll be called endlessly until
2358      * the sink gets shut down; maybe we should set a flag somewhere, or
2359      * set segment.stop and segment.duration to the last sample or so */
2360     GST_DEBUG_OBJECT (sink, &quot;EOS&quot;);
2361     gst_audio_base_sink_drain (sink);
2362     gst_audio_ring_buffer_pause (rbuf);
2363     gst_element_post_message (GST_ELEMENT_CAST (sink),
2364         gst_message_new_eos (GST_OBJECT_CAST (sink)));
2365     GST_PAD_STREAM_UNLOCK (basesink-&gt;sinkpad);
2366   }
2367 flushing:
2368   {
2369     GST_DEBUG_OBJECT (sink, &quot;we are flushing&quot;);
2370     gst_audio_ring_buffer_pause (rbuf);
2371     GST_BASE_SINK_PREROLL_UNLOCK (basesink);
2372     GST_PAD_STREAM_UNLOCK (basesink-&gt;sinkpad);
2373     return;
2374   }
2375 preroll_error:
2376   {
2377     GST_DEBUG_OBJECT (sink, &quot;error %s&quot;, gst_flow_get_name (ret));
2378     gst_audio_ring_buffer_pause (rbuf);
2379     GST_BASE_SINK_PREROLL_UNLOCK (basesink);
2380     GST_PAD_STREAM_UNLOCK (basesink-&gt;sinkpad);
2381     return;
2382   }
2383 }
2384 
2385 static gboolean
2386 gst_audio_base_sink_activate_pull (GstBaseSink * basesink, gboolean active)
2387 {
2388   gboolean ret;
2389   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (basesink);
2390 
2391   if (active) {
2392     GST_DEBUG_OBJECT (basesink, &quot;activating pull&quot;);
2393 
2394     gst_audio_ring_buffer_set_callback (sink-&gt;ringbuffer,
2395         gst_audio_base_sink_callback, sink);
2396 
2397     ret = gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, TRUE);
2398   } else {
2399     GST_DEBUG_OBJECT (basesink, &quot;deactivating pull&quot;);
2400     gst_audio_ring_buffer_set_callback (sink-&gt;ringbuffer, NULL, NULL);
2401     ret = gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, FALSE);
2402   }
2403 
2404   return ret;
2405 }
2406 
2407 static GstStateChangeReturn
2408 gst_audio_base_sink_change_state (GstElement * element,
2409     GstStateChange transition)
2410 {
2411   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
2412   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (element);
2413 
2414   switch (transition) {
2415     case GST_STATE_CHANGE_NULL_TO_READY:{
2416       GstAudioRingBuffer *rb;
2417 
<a name="21" id="anc21"></a><span class="line-modified">2418       gst_audio_clock_reset (GST_AUDIO_CLOCK (sink-&gt;provided_clock), 0);</span>
2419       rb = gst_audio_base_sink_create_ringbuffer (sink);
2420       if (rb == NULL)
2421         goto create_failed;
2422 
2423       GST_OBJECT_LOCK (sink);
2424       sink-&gt;ringbuffer = rb;
2425       GST_OBJECT_UNLOCK (sink);
2426 
2427       if (!gst_audio_ring_buffer_open_device (sink-&gt;ringbuffer)) {
2428         GST_OBJECT_LOCK (sink);
2429         gst_object_unparent (GST_OBJECT_CAST (sink-&gt;ringbuffer));
2430         sink-&gt;ringbuffer = NULL;
2431         GST_OBJECT_UNLOCK (sink);
2432         goto open_failed;
2433       }
2434       break;
2435     }
2436     case GST_STATE_CHANGE_READY_TO_PAUSED:
2437       gst_audio_base_sink_reset_sync (sink);
2438       gst_audio_ring_buffer_set_flushing (sink-&gt;ringbuffer, FALSE);
2439       gst_audio_ring_buffer_may_start (sink-&gt;ringbuffer, FALSE);
2440 
2441       /* Only post clock-provide messages if this is the clock that
2442        * we&#39;ve created. If the subclass has overriden it the subclass
2443        * should post this messages whenever necessary */
2444       if (gst_audio_base_sink_is_self_provided_clock (sink))
2445         gst_element_post_message (element,
2446             gst_message_new_clock_provide (GST_OBJECT_CAST (element),
2447                 sink-&gt;provided_clock, TRUE));
2448       break;
2449     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
2450     {
2451       gboolean eos;
2452 
2453       GST_OBJECT_LOCK (sink);
2454       GST_DEBUG_OBJECT (sink, &quot;ringbuffer may start now&quot;);
2455       sink-&gt;priv-&gt;sync_latency = TRUE;
2456       eos = GST_BASE_SINK (sink)-&gt;eos;
2457       GST_OBJECT_UNLOCK (sink);
2458 
2459 #ifdef GSTREAMER_LITE
2460       gst_audio_ring_buffer_clear_all(sink-&gt;ringbuffer);
2461 #endif // GSTREAMER_LITE
2462 
2463       gst_audio_ring_buffer_may_start (sink-&gt;ringbuffer, TRUE);
2464       if (GST_BASE_SINK_CAST (sink)-&gt;pad_mode == GST_PAD_MODE_PULL ||
2465           g_atomic_int_get (&amp;sink-&gt;eos_rendering) || eos) {
2466         /* we always start the ringbuffer in pull mode immediatly */
2467         /* sync rendering on eos needs running clock,
2468          * and others need running clock when finished rendering eos */
2469         gst_audio_ring_buffer_start (sink-&gt;ringbuffer);
2470       }
2471       break;
2472     }
2473     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
2474       /* ringbuffer cannot start anymore */
2475       gst_audio_ring_buffer_may_start (sink-&gt;ringbuffer, FALSE);
2476       gst_audio_ring_buffer_pause (sink-&gt;ringbuffer);
2477 
2478       GST_OBJECT_LOCK (sink);
2479       sink-&gt;priv-&gt;sync_latency = FALSE;
2480       GST_OBJECT_UNLOCK (sink);
2481       break;
2482     case GST_STATE_CHANGE_PAUSED_TO_READY:
2483       /* Only post clock-lost messages if this is the clock that
2484        * we&#39;ve created. If the subclass has overriden it the subclass
2485        * should post this messages whenever necessary */
2486       if (gst_audio_base_sink_is_self_provided_clock (sink))
2487         gst_element_post_message (element,
2488             gst_message_new_clock_lost (GST_OBJECT_CAST (element),
2489                 sink-&gt;provided_clock));
2490 
2491       /* make sure we unblock before calling the parent state change
2492        * so it can grab the STREAM_LOCK */
2493       gst_audio_ring_buffer_set_flushing (sink-&gt;ringbuffer, TRUE);
2494       break;
2495     default:
2496       break;
2497   }
2498 
2499   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
2500 
2501   switch (transition) {
2502     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
2503       /* stop slaving ourselves to the master, if any */
2504       gst_clock_set_master (sink-&gt;provided_clock, NULL);
2505       break;
2506     case GST_STATE_CHANGE_PAUSED_TO_READY:
2507       gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, FALSE);
2508       gst_audio_ring_buffer_release (sink-&gt;ringbuffer);
2509       break;
2510     case GST_STATE_CHANGE_READY_TO_NULL:
2511       /* we release again here because the acquire happens when setting the
2512        * caps, which happens before we commit the state to PAUSED and thus the
2513        * PAUSED-&gt;READY state change (see above, where we release the ringbuffer)
2514        * might not be called when we get here. */
2515       gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, FALSE);
2516       gst_audio_ring_buffer_release (sink-&gt;ringbuffer);
2517       gst_audio_ring_buffer_close_device (sink-&gt;ringbuffer);
2518       GST_OBJECT_LOCK (sink);
2519       gst_object_unparent (GST_OBJECT_CAST (sink-&gt;ringbuffer));
2520       sink-&gt;ringbuffer = NULL;
2521       GST_OBJECT_UNLOCK (sink);
2522       break;
2523     default:
2524       break;
2525   }
2526 
2527   return ret;
2528 
2529   /* ERRORS */
2530 create_failed:
2531   {
2532     /* subclass must post a meaningful error message */
2533     GST_DEBUG_OBJECT (sink, &quot;create failed&quot;);
2534     return GST_STATE_CHANGE_FAILURE;
2535   }
2536 open_failed:
2537   {
2538     /* subclass must post a meaningful error message */
2539     GST_DEBUG_OBJECT (sink, &quot;open failed&quot;);
2540     return GST_STATE_CHANGE_FAILURE;
2541   }
2542 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>