<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbufferpool.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2010 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   3  *
   4  * gstbufferpool.c: GstBufferPool baseclass
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gstbufferpool
  24  * @title: GstBufferPool
  25  * @short_description: Pool for buffers
  26  * @see_also: #GstBuffer
  27  *
  28  * A #GstBufferPool is an object that can be used to pre-allocate and recycle
  29  * buffers of the same size and with the same properties.
  30  *
  31  * A #GstBufferPool is created with gst_buffer_pool_new().
  32  *
  33  * Once a pool is created, it needs to be configured. A call to
  34  * gst_buffer_pool_get_config() returns the current configuration structure from
  35  * the pool. With gst_buffer_pool_config_set_params() and
  36  * gst_buffer_pool_config_set_allocator() the bufferpool parameters and
  37  * allocator can be configured. Other properties can be configured in the pool
  38  * depending on the pool implementation.
  39  *
  40  * A bufferpool can have extra options that can be enabled with
  41  * gst_buffer_pool_config_add_option(). The available options can be retrieved
  42  * with gst_buffer_pool_get_options(). Some options allow for additional
  43  * configuration properties to be set.
  44  *
  45  * After the configuration structure has been configured,
  46  * gst_buffer_pool_set_config() updates the configuration in the pool. This can
  47  * fail when the configuration structure is not accepted.
  48  *
  49  * After the a pool has been configured, it can be activated with
  50  * gst_buffer_pool_set_active(). This will preallocate the configured resources
  51  * in the pool.
  52  *
  53  * When the pool is active, gst_buffer_pool_acquire_buffer() can be used to
  54  * retrieve a buffer from the pool.
  55  *
  56  * Buffers allocated from a bufferpool will automatically be returned to the
  57  * pool with gst_buffer_pool_release_buffer() when their refcount drops to 0.
  58  *
  59  * The bufferpool can be deactivated again with gst_buffer_pool_set_active().
  60  * All further gst_buffer_pool_acquire_buffer() calls will return an error. When
  61  * all buffers are returned to the pool they will be freed.
  62  *
  63  * Use gst_object_unref() to release the reference to a bufferpool. If the
  64  * refcount of the pool reaches 0, the pool will be freed.
  65  */
  66 
  67 #include &quot;gst_private.h&quot;
  68 #include &quot;glib-compat-private.h&quot;
  69 
  70 #include &lt;errno.h&gt;
  71 #ifdef HAVE_UNISTD_H
  72 #  include &lt;unistd.h&gt;
  73 #endif
  74 #include &lt;sys/types.h&gt;
  75 
  76 #include &quot;gstatomicqueue.h&quot;
  77 #include &quot;gstpoll.h&quot;
  78 #include &quot;gstinfo.h&quot;
  79 #include &quot;gstquark.h&quot;
  80 #include &quot;gstvalue.h&quot;
  81 
  82 #include &quot;gstbufferpool.h&quot;
  83 
  84 #ifdef G_OS_WIN32
  85 #  ifndef EWOULDBLOCK
  86 #  define EWOULDBLOCK EAGAIN    /* This is just to placate gcc */
  87 #  endif
  88 #endif /* G_OS_WIN32 */
  89 
  90 GST_DEBUG_CATEGORY_STATIC (gst_buffer_pool_debug);
  91 #define GST_CAT_DEFAULT gst_buffer_pool_debug
  92 
  93 #define GST_BUFFER_POOL_LOCK(pool)   (g_rec_mutex_lock(&amp;pool-&gt;priv-&gt;rec_lock))
  94 #define GST_BUFFER_POOL_UNLOCK(pool) (g_rec_mutex_unlock(&amp;pool-&gt;priv-&gt;rec_lock))
  95 
  96 struct _GstBufferPoolPrivate
  97 {
  98   GstAtomicQueue *queue;
  99   GstPoll *poll;
 100 
 101   GRecMutex rec_lock;
 102 
 103   gboolean started;
 104   gboolean active;
 105   gint outstanding;             /* number of buffers that are in use */
 106 
 107   gboolean configured;
 108   GstStructure *config;
 109 
 110   guint size;
 111   guint min_buffers;
 112   guint max_buffers;
 113   guint cur_buffers;
 114   GstAllocator *allocator;
 115   GstAllocationParams params;
 116 };
 117 
 118 static void gst_buffer_pool_finalize (GObject * object);
 119 
 120 G_DEFINE_TYPE_WITH_PRIVATE (GstBufferPool, gst_buffer_pool, GST_TYPE_OBJECT);
 121 
 122 static gboolean default_start (GstBufferPool * pool);
 123 static gboolean default_stop (GstBufferPool * pool);
 124 static gboolean default_set_config (GstBufferPool * pool,
 125     GstStructure * config);
 126 static GstFlowReturn default_alloc_buffer (GstBufferPool * pool,
 127     GstBuffer ** buffer, GstBufferPoolAcquireParams * params);
 128 static GstFlowReturn default_acquire_buffer (GstBufferPool * pool,
 129     GstBuffer ** buffer, GstBufferPoolAcquireParams * params);
 130 static void default_reset_buffer (GstBufferPool * pool, GstBuffer * buffer);
 131 static void default_free_buffer (GstBufferPool * pool, GstBuffer * buffer);
 132 static void default_release_buffer (GstBufferPool * pool, GstBuffer * buffer);
 133 
 134 static void
 135 gst_buffer_pool_class_init (GstBufferPoolClass * klass)
 136 {
 137   GObjectClass *gobject_class = (GObjectClass *) klass;
 138 
 139   gobject_class-&gt;finalize = gst_buffer_pool_finalize;
 140 
 141   klass-&gt;start = default_start;
 142   klass-&gt;stop = default_stop;
 143   klass-&gt;set_config = default_set_config;
 144   klass-&gt;acquire_buffer = default_acquire_buffer;
 145   klass-&gt;reset_buffer = default_reset_buffer;
 146   klass-&gt;alloc_buffer = default_alloc_buffer;
 147   klass-&gt;release_buffer = default_release_buffer;
 148   klass-&gt;free_buffer = default_free_buffer;
 149 
 150   GST_DEBUG_CATEGORY_INIT (gst_buffer_pool_debug, &quot;bufferpool&quot;, 0,
 151       &quot;bufferpool debug&quot;);
 152 }
 153 
 154 static void
 155 gst_buffer_pool_init (GstBufferPool * pool)
 156 {
 157   GstBufferPoolPrivate *priv;
 158 
 159   priv = pool-&gt;priv = gst_buffer_pool_get_instance_private (pool);
 160 
 161   g_rec_mutex_init (&amp;priv-&gt;rec_lock);
 162 
 163   priv-&gt;poll = gst_poll_new_timer ();
 164   priv-&gt;queue = gst_atomic_queue_new (16);
 165   pool-&gt;flushing = 1;
 166   priv-&gt;active = FALSE;
 167   priv-&gt;configured = FALSE;
 168   priv-&gt;started = FALSE;
 169   priv-&gt;config = gst_structure_new_id_empty (GST_QUARK (BUFFER_POOL_CONFIG));
 170   gst_buffer_pool_config_set_params (priv-&gt;config, NULL, 0, 0, 0);
 171   priv-&gt;allocator = NULL;
 172   gst_allocation_params_init (&amp;priv-&gt;params);
 173   gst_buffer_pool_config_set_allocator (priv-&gt;config, priv-&gt;allocator,
 174       &amp;priv-&gt;params);
 175   /* 1 control write for flushing - the flush token */
 176   gst_poll_write_control (priv-&gt;poll);
 177   /* 1 control write for marking that we are not waiting for poll - the wait token */
 178   gst_poll_write_control (priv-&gt;poll);
 179 
 180   GST_DEBUG_OBJECT (pool, &quot;created&quot;);
 181 }
 182 
 183 static void
 184 gst_buffer_pool_finalize (GObject * object)
 185 {
 186   GstBufferPool *pool;
 187   GstBufferPoolPrivate *priv;
 188 
 189   pool = GST_BUFFER_POOL_CAST (object);
 190   priv = pool-&gt;priv;
 191 
 192   GST_DEBUG_OBJECT (pool, &quot;%p finalize&quot;, pool);
 193 
 194   gst_buffer_pool_set_active (pool, FALSE);
 195   gst_atomic_queue_unref (priv-&gt;queue);
 196   gst_poll_free (priv-&gt;poll);
 197   gst_structure_free (priv-&gt;config);
 198   g_rec_mutex_clear (&amp;priv-&gt;rec_lock);
 199   if (priv-&gt;allocator)
 200     gst_object_unref (priv-&gt;allocator);
 201 
 202   G_OBJECT_CLASS (gst_buffer_pool_parent_class)-&gt;finalize (object);
 203 }
 204 
 205 /**
 206  * gst_buffer_pool_new:
 207  *
 208  * Creates a new #GstBufferPool instance.
 209  *
 210  * Returns: (transfer full): a new #GstBufferPool instance
 211  */
 212 GstBufferPool *
 213 gst_buffer_pool_new (void)
 214 {
 215   GstBufferPool *result;
 216 
 217   result = g_object_new (GST_TYPE_BUFFER_POOL, NULL);
 218   GST_DEBUG_OBJECT (result, &quot;created new buffer pool&quot;);
 219 
 220   /* Clear floating flag */
 221   gst_object_ref_sink (result);
 222 
 223   return result;
 224 }
 225 
 226 static GstFlowReturn
 227 default_alloc_buffer (GstBufferPool * pool, GstBuffer ** buffer,
 228     GstBufferPoolAcquireParams * params)
 229 {
 230   GstBufferPoolPrivate *priv = pool-&gt;priv;
 231 
 232   *buffer =
 233       gst_buffer_new_allocate (priv-&gt;allocator, priv-&gt;size, &amp;priv-&gt;params);
 234 
 235   if (!*buffer)
 236     return GST_FLOW_ERROR;
 237 
 238   return GST_FLOW_OK;
 239 }
 240 
 241 static gboolean
 242 mark_meta_pooled (GstBuffer * buffer, GstMeta ** meta, gpointer user_data)
 243 {
 244   GST_DEBUG_OBJECT (GST_BUFFER_POOL (user_data),
 245       &quot;marking meta %p as POOLED in buffer %p&quot;, *meta, buffer);
 246   GST_META_FLAG_SET (*meta, GST_META_FLAG_POOLED);
 247   GST_META_FLAG_SET (*meta, GST_META_FLAG_LOCKED);
 248 
 249   return TRUE;
 250 }
 251 
 252 static GstFlowReturn
 253 do_alloc_buffer (GstBufferPool * pool, GstBuffer ** buffer,
 254     GstBufferPoolAcquireParams * params)
 255 {
 256   GstBufferPoolPrivate *priv = pool-&gt;priv;
 257   GstFlowReturn result;
 258   gint cur_buffers, max_buffers;
 259   GstBufferPoolClass *pclass;
 260 
 261   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 262 
 263   if (G_UNLIKELY (!pclass-&gt;alloc_buffer))
 264     goto no_function;
 265 
 266   max_buffers = priv-&gt;max_buffers;
 267 
 268   /* increment the allocation counter */
 269   cur_buffers = g_atomic_int_add (&amp;priv-&gt;cur_buffers, 1);
 270   if (max_buffers &amp;&amp; cur_buffers &gt;= max_buffers)
 271     goto max_reached;
 272 
 273   result = pclass-&gt;alloc_buffer (pool, buffer, params);
 274   if (G_UNLIKELY (result != GST_FLOW_OK))
 275     goto alloc_failed;
 276 
 277   /* lock all metadata and mark as pooled, we want this to remain on
 278    * the buffer and we want to remove any other metadata that gets added
 279    * later */
 280   gst_buffer_foreach_meta (*buffer, mark_meta_pooled, pool);
 281 
 282   /* un-tag memory, this is how we expect the buffer when it is
 283    * released again */
 284   GST_BUFFER_FLAG_UNSET (*buffer, GST_BUFFER_FLAG_TAG_MEMORY);
 285 
 286   GST_LOG_OBJECT (pool, &quot;allocated buffer %d/%d, %p&quot;, cur_buffers,
 287       max_buffers, *buffer);
 288 
 289   return result;
 290 
 291   /* ERRORS */
 292 no_function:
 293   {
 294     GST_ERROR_OBJECT (pool, &quot;no alloc function&quot;);
 295     return GST_FLOW_NOT_SUPPORTED;
 296   }
 297 max_reached:
 298   {
 299     GST_DEBUG_OBJECT (pool, &quot;max buffers reached&quot;);
 300     g_atomic_int_add (&amp;priv-&gt;cur_buffers, -1);
 301     return GST_FLOW_EOS;
 302   }
 303 alloc_failed:
 304   {
 305     GST_WARNING_OBJECT (pool, &quot;alloc function failed&quot;);
 306     g_atomic_int_add (&amp;priv-&gt;cur_buffers, -1);
 307     return result;
 308   }
 309 }
 310 
 311 /* the default implementation for preallocating the buffers in the pool */
 312 static gboolean
 313 default_start (GstBufferPool * pool)
 314 {
 315   guint i;
 316   GstBufferPoolPrivate *priv = pool-&gt;priv;
 317   GstBufferPoolClass *pclass;
 318 
 319   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 320 
 321   /* we need to prealloc buffers */
 322   for (i = 0; i &lt; priv-&gt;min_buffers; i++) {
 323     GstBuffer *buffer;
 324 
 325     if (do_alloc_buffer (pool, &amp;buffer, NULL) != GST_FLOW_OK)
 326       goto alloc_failed;
 327 
 328     /* release to the queue, we call the vmethod directly, we don&#39;t need to do
 329      * the other refcount handling right now. */
 330     if (G_LIKELY (pclass-&gt;release_buffer))
 331       pclass-&gt;release_buffer (pool, buffer);
 332   }
 333   return TRUE;
 334 
 335   /* ERRORS */
 336 alloc_failed:
 337   {
 338     GST_WARNING_OBJECT (pool, &quot;failed to allocate buffer&quot;);
 339     return FALSE;
 340   }
 341 }
 342 
 343 /* must be called with the lock */
 344 static gboolean
 345 do_start (GstBufferPool * pool)
 346 {
 347   GstBufferPoolPrivate *priv = pool-&gt;priv;
 348 
 349   if (!priv-&gt;started) {
 350     GstBufferPoolClass *pclass;
 351 
 352     pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 353 
 354     GST_LOG_OBJECT (pool, &quot;starting&quot;);
 355     /* start the pool, subclasses should allocate buffers and put them
 356      * in the queue */
 357     if (G_LIKELY (pclass-&gt;start)) {
 358       if (!pclass-&gt;start (pool))
 359         return FALSE;
 360     }
 361     priv-&gt;started = TRUE;
 362   }
 363   return TRUE;
 364 }
 365 
 366 static void
 367 default_free_buffer (GstBufferPool * pool, GstBuffer * buffer)
 368 {
 369   gst_buffer_unref (buffer);
 370 }
 371 
 372 static void
 373 do_free_buffer (GstBufferPool * pool, GstBuffer * buffer)
 374 {
 375   GstBufferPoolPrivate *priv;
 376   GstBufferPoolClass *pclass;
 377 
 378   priv = pool-&gt;priv;
 379   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 380 
 381   g_atomic_int_add (&amp;priv-&gt;cur_buffers, -1);
 382   GST_LOG_OBJECT (pool, &quot;freeing buffer %p (%u left)&quot;, buffer,
 383       priv-&gt;cur_buffers);
 384 
 385   if (G_LIKELY (pclass-&gt;free_buffer))
 386     pclass-&gt;free_buffer (pool, buffer);
 387 }
 388 
 389 /* must be called with the lock */
 390 static gboolean
 391 default_stop (GstBufferPool * pool)
 392 {
 393   GstBufferPoolPrivate *priv = pool-&gt;priv;
 394   GstBuffer *buffer;
 395 
 396   /* clear the pool */
 397   while ((buffer = gst_atomic_queue_pop (priv-&gt;queue))) {
 398     while (!gst_poll_read_control (priv-&gt;poll)) {
 399       if (errno == EWOULDBLOCK) {
 400         /* We put the buffer into the queue but did not finish writing control
 401          * yet, let&#39;s wait a bit and retry */
 402         g_thread_yield ();
 403         continue;
 404       } else {
 405         /* Critical error but GstPoll already complained */
 406         break;
 407       }
 408     }
 409     do_free_buffer (pool, buffer);
 410   }
 411   return priv-&gt;cur_buffers == 0;
 412 }
 413 
 414 /* must be called with the lock */
 415 static gboolean
 416 do_stop (GstBufferPool * pool)
 417 {
 418   GstBufferPoolPrivate *priv = pool-&gt;priv;
 419 
 420   if (priv-&gt;started) {
 421     GstBufferPoolClass *pclass;
 422 
 423     pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 424 
 425     GST_LOG_OBJECT (pool, &quot;stopping&quot;);
 426     if (G_LIKELY (pclass-&gt;stop)) {
 427       if (!pclass-&gt;stop (pool))
 428         return FALSE;
 429     }
 430     priv-&gt;started = FALSE;
 431   }
 432   return TRUE;
 433 }
 434 
 435 /* must be called with the lock */
 436 static void
 437 do_set_flushing (GstBufferPool * pool, gboolean flushing)
 438 {
 439   GstBufferPoolPrivate *priv = pool-&gt;priv;
 440   GstBufferPoolClass *pclass;
 441 
 442   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 443 
 444   if (GST_BUFFER_POOL_IS_FLUSHING (pool) == flushing)
 445     return;
 446 
 447   if (flushing) {
 448     g_atomic_int_set (&amp;pool-&gt;flushing, 1);
 449     /* Write the flush token to wake up any waiters */
 450     gst_poll_write_control (priv-&gt;poll);
 451 
 452     if (pclass-&gt;flush_start)
 453       pclass-&gt;flush_start (pool);
 454   } else {
 455     if (pclass-&gt;flush_stop)
 456       pclass-&gt;flush_stop (pool);
 457 
 458     while (!gst_poll_read_control (priv-&gt;poll)) {
 459       if (errno == EWOULDBLOCK) {
 460         /* This should not really happen unless flushing and unflushing
 461          * happens on different threads. Let&#39;s wait a bit to get back flush
 462          * token from the thread that was setting it to flushing */
 463         g_thread_yield ();
 464         continue;
 465       } else {
 466         /* Critical error but GstPoll already complained */
 467         break;
 468       }
 469     }
 470 
 471     g_atomic_int_set (&amp;pool-&gt;flushing, 0);
 472   }
 473 }
 474 
 475 /**
 476  * gst_buffer_pool_set_active:
 477  * @pool: a #GstBufferPool
 478  * @active: the new active state
 479  *
 480  * Control the active state of @pool. When the pool is inactive, new calls to
 481  * gst_buffer_pool_acquire_buffer() will return with %GST_FLOW_FLUSHING.
 482  *
 483  * Activating the bufferpool will preallocate all resources in the pool based on
 484  * the configuration of the pool.
 485  *
 486  * Deactivating will free the resources again when there are no outstanding
 487  * buffers. When there are outstanding buffers, they will be freed as soon as
 488  * they are all returned to the pool.
 489  *
 490  * Returns: %FALSE when the pool was not configured or when preallocation of the
 491  * buffers failed.
 492  */
 493 gboolean
 494 gst_buffer_pool_set_active (GstBufferPool * pool, gboolean active)
 495 {
 496   gboolean res = TRUE;
 497   GstBufferPoolPrivate *priv;
 498 
 499   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), FALSE);
 500 
 501   GST_LOG_OBJECT (pool, &quot;active %d&quot;, active);
 502 
 503   priv = pool-&gt;priv;
 504 
 505   GST_BUFFER_POOL_LOCK (pool);
 506   /* just return if we are already in the right state */
 507   if (priv-&gt;active == active)
 508     goto was_ok;
 509 
 510   /* we need to be configured */
 511   if (!priv-&gt;configured)
 512     goto not_configured;
 513 
 514   if (active) {
 515     if (!do_start (pool))
 516       goto start_failed;
 517 
 518     /* flush_stop my release buffers, setting to active to avoid running
 519      * do_stop while activating the pool */
 520     priv-&gt;active = TRUE;
 521 
 522     /* unset the flushing state now */
 523     do_set_flushing (pool, FALSE);
 524   } else {
 525     gint outstanding;
 526 
 527     /* set to flushing first */
 528     do_set_flushing (pool, TRUE);
 529 
 530     /* when all buffers are in the pool, free them. Else they will be
 531      * freed when they are released */
 532     outstanding = g_atomic_int_get (&amp;priv-&gt;outstanding);
 533     GST_LOG_OBJECT (pool, &quot;outstanding buffers %d&quot;, outstanding);
 534     if (outstanding == 0) {
 535       if (!do_stop (pool))
 536         goto stop_failed;
 537     }
 538 
 539     priv-&gt;active = FALSE;
 540   }
 541   GST_BUFFER_POOL_UNLOCK (pool);
 542 
 543   return res;
 544 
 545 was_ok:
 546   {
 547     GST_DEBUG_OBJECT (pool, &quot;pool was in the right state&quot;);
 548     GST_BUFFER_POOL_UNLOCK (pool);
 549     return TRUE;
 550   }
 551 not_configured:
 552   {
 553     GST_ERROR_OBJECT (pool, &quot;pool was not configured&quot;);
 554     GST_BUFFER_POOL_UNLOCK (pool);
 555     return FALSE;
 556   }
 557 start_failed:
 558   {
 559     GST_ERROR_OBJECT (pool, &quot;start failed&quot;);
 560     GST_BUFFER_POOL_UNLOCK (pool);
 561     return FALSE;
 562   }
 563 stop_failed:
 564   {
 565     GST_WARNING_OBJECT (pool, &quot;stop failed&quot;);
 566     GST_BUFFER_POOL_UNLOCK (pool);
 567     return FALSE;
 568   }
 569 }
 570 
 571 /**
 572  * gst_buffer_pool_is_active:
 573  * @pool: a #GstBufferPool
 574  *
 575  * Check if @pool is active. A pool can be activated with the
 576  * gst_buffer_pool_set_active() call.
 577  *
 578  * Returns: %TRUE when the pool is active.
 579  */
 580 gboolean
 581 gst_buffer_pool_is_active (GstBufferPool * pool)
 582 {
 583   gboolean res;
 584 
 585   GST_BUFFER_POOL_LOCK (pool);
 586   res = pool-&gt;priv-&gt;active;
 587   GST_BUFFER_POOL_UNLOCK (pool);
 588 
 589   return res;
 590 }
 591 
 592 static gboolean
 593 default_set_config (GstBufferPool * pool, GstStructure * config)
 594 {
 595   GstBufferPoolPrivate *priv = pool-&gt;priv;
 596   GstCaps *caps;
 597   guint size, min_buffers, max_buffers;
 598   GstAllocator *allocator;
 599   GstAllocationParams params;
 600 
 601   /* parse the config and keep around */
 602   if (!gst_buffer_pool_config_get_params (config, &amp;caps, &amp;size, &amp;min_buffers,
 603           &amp;max_buffers))
 604     goto wrong_config;
 605 
 606   if (!gst_buffer_pool_config_get_allocator (config, &amp;allocator, &amp;params))
 607     goto wrong_config;
 608 
 609   GST_DEBUG_OBJECT (pool, &quot;config %&quot; GST_PTR_FORMAT, config);
 610 
 611   priv-&gt;size = size;
 612   priv-&gt;min_buffers = min_buffers;
 613   priv-&gt;max_buffers = max_buffers;
 614   priv-&gt;cur_buffers = 0;
 615 
 616   if (priv-&gt;allocator)
 617     gst_object_unref (priv-&gt;allocator);
 618   if ((priv-&gt;allocator = allocator))
 619     gst_object_ref (allocator);
 620   priv-&gt;params = params;
 621 
 622   return TRUE;
 623 
 624 wrong_config:
 625   {
 626     GST_WARNING_OBJECT (pool, &quot;invalid config %&quot; GST_PTR_FORMAT, config);
 627     return FALSE;
 628   }
 629 }
 630 
 631 /**
 632  * gst_buffer_pool_set_config:
 633  * @pool: a #GstBufferPool
 634  * @config: (transfer full): a #GstStructure
 635  *
 636  * Set the configuration of the pool. If the pool is already configured, and
 637  * the configuration haven&#39;t change, this function will return %TRUE. If the
 638  * pool is active, this method will return %FALSE and active configuration
 639  * will remain. Buffers allocated form this pool must be returned or else this
 640  * function will do nothing and return %FALSE.
 641  *
 642  * @config is a #GstStructure that contains the configuration parameters for
 643  * the pool. A default and mandatory set of parameters can be configured with
 644  * gst_buffer_pool_config_set_params(), gst_buffer_pool_config_set_allocator()
 645  * and gst_buffer_pool_config_add_option().
 646  *
 647  * If the parameters in @config can not be set exactly, this function returns
 648  * %FALSE and will try to update as much state as possible. The new state can
 649  * then be retrieved and refined with gst_buffer_pool_get_config().
 650  *
 651  * This function takes ownership of @config.
 652  *
 653  * Returns: %TRUE when the configuration could be set.
 654  */
 655 gboolean
 656 gst_buffer_pool_set_config (GstBufferPool * pool, GstStructure * config)
 657 {
 658   gboolean result;
 659   GstBufferPoolClass *pclass;
 660   GstBufferPoolPrivate *priv;
 661 
 662   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), FALSE);
 663   g_return_val_if_fail (config != NULL, FALSE);
 664 
 665   priv = pool-&gt;priv;
 666 
 667   GST_BUFFER_POOL_LOCK (pool);
 668 
 669   /* nothing to do if config is unchanged */
 670   if (priv-&gt;configured &amp;&amp; gst_structure_is_equal (config, priv-&gt;config))
 671     goto config_unchanged;
 672 
 673   /* can&#39;t change the settings when active */
 674   if (priv-&gt;active)
 675     goto was_active;
 676 
 677   /* we can&#39;t change when outstanding buffers */
 678   if (g_atomic_int_get (&amp;priv-&gt;outstanding) != 0)
 679     goto have_outstanding;
 680 
 681   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 682 
 683   /* set the new config */
 684   if (G_LIKELY (pclass-&gt;set_config))
 685     result = pclass-&gt;set_config (pool, config);
 686   else
 687     result = FALSE;
 688 
 689   /* save the config regardless of the result so user can read back the
 690    * modified config and evaluate if the changes are acceptable */
 691   if (priv-&gt;config)
 692     gst_structure_free (priv-&gt;config);
 693   priv-&gt;config = config;
 694 
 695   if (result) {
 696     /* now we are configured */
 697     priv-&gt;configured = TRUE;
 698   }
 699   GST_BUFFER_POOL_UNLOCK (pool);
 700 
 701   return result;
 702 
 703 config_unchanged:
 704   {
 705     gst_structure_free (config);
 706     GST_BUFFER_POOL_UNLOCK (pool);
 707     return TRUE;
 708   }
 709   /* ERRORS */
 710 was_active:
 711   {
 712     gst_structure_free (config);
 713     GST_INFO_OBJECT (pool, &quot;can&#39;t change config, we are active&quot;);
 714     GST_BUFFER_POOL_UNLOCK (pool);
 715     return FALSE;
 716   }
 717 have_outstanding:
 718   {
 719     gst_structure_free (config);
 720     GST_WARNING_OBJECT (pool, &quot;can&#39;t change config, have outstanding buffers&quot;);
 721     GST_BUFFER_POOL_UNLOCK (pool);
 722     return FALSE;
 723   }
 724 }
 725 
 726 /**
 727  * gst_buffer_pool_get_config:
 728  * @pool: a #GstBufferPool
 729  *
 730  * Get a copy of the current configuration of the pool. This configuration
 731  * can either be modified and used for the gst_buffer_pool_set_config() call
 732  * or it must be freed after usage.
 733  *
 734  * Returns: (transfer full): a copy of the current configuration of @pool. use
 735  * gst_structure_free() after usage or gst_buffer_pool_set_config().
 736  */
 737 GstStructure *
 738 gst_buffer_pool_get_config (GstBufferPool * pool)
 739 {
 740   GstStructure *result;
 741 
 742   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), NULL);
 743 
 744   GST_BUFFER_POOL_LOCK (pool);
 745   result = gst_structure_copy (pool-&gt;priv-&gt;config);
 746   GST_BUFFER_POOL_UNLOCK (pool);
 747 
 748   return result;
 749 }
 750 
 751 static const gchar *empty_option[] = { NULL };
 752 
 753 /**
 754  * gst_buffer_pool_get_options:
 755  * @pool: a #GstBufferPool
 756  *
 757  * Get a %NULL terminated array of string with supported bufferpool options for
 758  * @pool. An option would typically be enabled with
 759  * gst_buffer_pool_config_add_option().
 760  *
 761  * Returns: (array zero-terminated=1) (transfer none): a %NULL terminated array
 762  *          of strings.
 763  */
 764 const gchar **
 765 gst_buffer_pool_get_options (GstBufferPool * pool)
 766 {
 767   GstBufferPoolClass *pclass;
 768   const gchar **result;
 769 
 770   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), NULL);
 771 
 772   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 773 
 774   if (G_LIKELY (pclass-&gt;get_options)) {
 775     if ((result = pclass-&gt;get_options (pool)) == NULL)
 776       goto invalid_result;
 777   } else
 778     result = empty_option;
 779 
 780   return result;
 781 
 782   /* ERROR */
 783 invalid_result:
 784   {
 785     g_warning (&quot;bufferpool subclass returned NULL options&quot;);
 786     return empty_option;
 787   }
 788 }
 789 
 790 /**
 791  * gst_buffer_pool_has_option:
 792  * @pool: a #GstBufferPool
 793  * @option: an option
 794  *
 795  * Check if the bufferpool supports @option.
 796  *
 797  * Returns: %TRUE if the buffer pool contains @option.
 798  */
 799 gboolean
 800 gst_buffer_pool_has_option (GstBufferPool * pool, const gchar * option)
 801 {
 802   guint i;
 803   const gchar **options;
 804 
 805   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), FALSE);
 806   g_return_val_if_fail (option != NULL, FALSE);
 807 
 808   options = gst_buffer_pool_get_options (pool);
 809 
 810   for (i = 0; options[i]; i++) {
 811     if (g_str_equal (options[i], option))
 812       return TRUE;
 813   }
 814   return FALSE;
 815 }
 816 
 817 /**
 818  * gst_buffer_pool_config_set_params:
 819  * @config: a #GstBufferPool configuration
 820  * @caps: caps for the buffers
 821  * @size: the size of each buffer, not including prefix and padding
 822  * @min_buffers: the minimum amount of buffers to allocate.
 823  * @max_buffers: the maximum amount of buffers to allocate or 0 for unlimited.
 824  *
 825  * Configure @config with the given parameters.
 826  */
 827 void
 828 gst_buffer_pool_config_set_params (GstStructure * config, GstCaps * caps,
 829     guint size, guint min_buffers, guint max_buffers)
 830 {
 831   g_return_if_fail (config != NULL);
 832   g_return_if_fail (max_buffers == 0 || min_buffers &lt;= max_buffers);
 833   g_return_if_fail (caps == NULL || gst_caps_is_fixed (caps));
 834 
 835   gst_structure_id_set (config,
 836       GST_QUARK (CAPS), GST_TYPE_CAPS, caps,
 837       GST_QUARK (SIZE), G_TYPE_UINT, size,
 838       GST_QUARK (MIN_BUFFERS), G_TYPE_UINT, min_buffers,
 839       GST_QUARK (MAX_BUFFERS), G_TYPE_UINT, max_buffers, NULL);
 840 }
 841 
 842 /**
 843  * gst_buffer_pool_config_set_allocator:
 844  * @config: a #GstBufferPool configuration
 845  * @allocator: (allow-none): a #GstAllocator
 846  * @params: (allow-none): #GstAllocationParams
 847  *
 848  * Set the @allocator and @params on @config.
 849  *
 850  * One of @allocator and @params can be %NULL, but not both. When @allocator
 851  * is %NULL, the default allocator of the pool will use the values in @param
 852  * to perform its allocation. When @param is %NULL, the pool will use the
 853  * provided @allocator with its default #GstAllocationParams.
 854  *
 855  * A call to gst_buffer_pool_set_config() can update the allocator and params
 856  * with the values that it is able to do. Some pools are, for example, not able
 857  * to operate with different allocators or cannot allocate with the values
 858  * specified in @params. Use gst_buffer_pool_get_config() to get the currently
 859  * used values.
 860  */
 861 void
 862 gst_buffer_pool_config_set_allocator (GstStructure * config,
 863     GstAllocator * allocator, const GstAllocationParams * params)
 864 {
 865   g_return_if_fail (config != NULL);
 866   g_return_if_fail (allocator != NULL || params != NULL);
 867 
 868   gst_structure_id_set (config,
 869       GST_QUARK (ALLOCATOR), GST_TYPE_ALLOCATOR, allocator,
 870       GST_QUARK (PARAMS), GST_TYPE_ALLOCATION_PARAMS, params, NULL);
 871 }
 872 
 873 /**
 874  * gst_buffer_pool_config_add_option:
 875  * @config: a #GstBufferPool configuration
 876  * @option: an option to add
 877  *
 878  * Enabled the option in @config. This will instruct the @bufferpool to enable
 879  * the specified option on the buffers that it allocates.
 880  *
 881  * The supported options by @pool can be retrieved with gst_buffer_pool_get_options().
 882  */
 883 void
 884 gst_buffer_pool_config_add_option (GstStructure * config, const gchar * option)
 885 {
 886   const GValue *value;
 887   GValue option_value = { 0, };
 888   guint i, len;
 889 
 890   g_return_if_fail (config != NULL);
 891 
 892   value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));
 893   if (value) {
 894     len = gst_value_array_get_size (value);
 895     for (i = 0; i &lt; len; ++i) {
 896       const GValue *nth_val = gst_value_array_get_value (value, i);
 897 
 898       if (g_str_equal (option, g_value_get_string (nth_val)))
 899         return;
 900     }
 901   } else {
 902     GValue new_array_val = { 0, };
 903 
 904     g_value_init (&amp;new_array_val, GST_TYPE_ARRAY);
 905     gst_structure_id_take_value (config, GST_QUARK (OPTIONS), &amp;new_array_val);
 906     value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));
 907   }
 908   g_value_init (&amp;option_value, G_TYPE_STRING);
 909   g_value_set_string (&amp;option_value, option);
 910   gst_value_array_append_and_take_value ((GValue *) value, &amp;option_value);
 911 }
 912 
 913 /**
 914  * gst_buffer_pool_config_n_options:
 915  * @config: a #GstBufferPool configuration
 916  *
 917  * Retrieve the number of values currently stored in the options array of the
 918  * @config structure.
 919  *
 920  * Returns: the options array size as a #guint.
 921  */
 922 guint
 923 gst_buffer_pool_config_n_options (GstStructure * config)
 924 {
 925   const GValue *value;
 926   guint size = 0;
 927 
 928   g_return_val_if_fail (config != NULL, 0);
 929 
 930   value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));
 931   if (value) {
 932     size = gst_value_array_get_size (value);
 933   }
 934   return size;
 935 }
 936 
 937 /**
 938  * gst_buffer_pool_config_get_option:
 939  * @config: a #GstBufferPool configuration
 940  * @index: position in the option array to read
 941  *
 942  * Parse an available @config and get the option at @index of the options API
 943  * array.
 944  *
 945  * Returns: a #gchar of the option at @index.
 946  */
 947 const gchar *
 948 gst_buffer_pool_config_get_option (GstStructure * config, guint index)
 949 {
 950   const GValue *value;
 951   const gchar *ret = NULL;
 952 
 953   g_return_val_if_fail (config != NULL, 0);
 954 
 955   value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));
 956   if (value) {
 957     const GValue *option_value;
 958 
 959     option_value = gst_value_array_get_value (value, index);
 960     if (option_value)
 961       ret = g_value_get_string (option_value);
 962   }
 963   return ret;
 964 }
 965 
 966 /**
 967  * gst_buffer_pool_config_has_option:
 968  * @config: a #GstBufferPool configuration
 969  * @option: an option
 970  *
 971  * Check if @config contains @option.
 972  *
 973  * Returns: %TRUE if the options array contains @option.
 974  */
 975 gboolean
 976 gst_buffer_pool_config_has_option (GstStructure * config, const gchar * option)
 977 {
 978   const GValue *value;
 979   guint i, len;
 980 
 981   g_return_val_if_fail (config != NULL, 0);
 982 
 983   value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));
 984   if (value) {
 985     len = gst_value_array_get_size (value);
 986     for (i = 0; i &lt; len; ++i) {
 987       const GValue *nth_val = gst_value_array_get_value (value, i);
 988 
 989       if (g_str_equal (option, g_value_get_string (nth_val)))
 990         return TRUE;
 991     }
 992   }
 993   return FALSE;
 994 }
 995 
 996 /**
 997  * gst_buffer_pool_config_get_params:
 998  * @config: (transfer none): a #GstBufferPool configuration
 999  * @caps: (out) (transfer none) (allow-none): the caps of buffers
1000  * @size: (out) (allow-none): the size of each buffer, not including prefix and padding
1001  * @min_buffers: (out) (allow-none): the minimum amount of buffers to allocate.
1002  * @max_buffers: (out) (allow-none): the maximum amount of buffers to allocate or 0 for unlimited.
1003  *
1004  * Get the configuration values from @config.
1005  *
1006  * Returns: %TRUE if all parameters could be fetched.
1007  */
1008 gboolean
1009 gst_buffer_pool_config_get_params (GstStructure * config, GstCaps ** caps,
1010     guint * size, guint * min_buffers, guint * max_buffers)
1011 {
1012   g_return_val_if_fail (config != NULL, FALSE);
1013 
1014   if (caps) {
1015     *caps = g_value_get_boxed (gst_structure_id_get_value (config,
1016             GST_QUARK (CAPS)));
1017   }
1018   return gst_structure_id_get (config,
1019       GST_QUARK (SIZE), G_TYPE_UINT, size,
1020       GST_QUARK (MIN_BUFFERS), G_TYPE_UINT, min_buffers,
1021       GST_QUARK (MAX_BUFFERS), G_TYPE_UINT, max_buffers, NULL);
1022 }
1023 
1024 /**
1025  * gst_buffer_pool_config_get_allocator:
1026  * @config: (transfer none): a #GstBufferPool configuration
1027  * @allocator: (out) (allow-none) (transfer none): a #GstAllocator, or %NULL
1028  * @params: (out) (allow-none): #GstAllocationParams, or %NULL
1029  *
1030  * Get the @allocator and @params from @config.
1031  *
1032  * Returns: %TRUE, if the values are set.
1033  */
1034 gboolean
1035 gst_buffer_pool_config_get_allocator (GstStructure * config,
1036     GstAllocator ** allocator, GstAllocationParams * params)
1037 {
1038   g_return_val_if_fail (config != NULL, FALSE);
1039 
1040   if (allocator)
1041     *allocator = g_value_get_object (gst_structure_id_get_value (config,
1042             GST_QUARK (ALLOCATOR)));
1043   if (params) {
1044     GstAllocationParams *p;
1045 
1046     p = g_value_get_boxed (gst_structure_id_get_value (config,
1047             GST_QUARK (PARAMS)));
1048     if (p) {
1049       *params = *p;
1050     } else {
1051       gst_allocation_params_init (params);
1052     }
1053   }
1054   return TRUE;
1055 }
1056 
1057 /**
1058  * gst_buffer_pool_config_validate_params:
1059  * @config: (transfer none): a #GstBufferPool configuration
1060  * @caps: (transfer none): the excepted caps of buffers
1061  * @size: the expected size of each buffer, not including prefix and padding
1062  * @min_buffers: the expected minimum amount of buffers to allocate.
1063  * @max_buffers: the expect maximum amount of buffers to allocate or 0 for unlimited.
1064  *
1065  * Validate that changes made to @config are still valid in the context of the
1066  * expected parameters. This function is a helper that can be used to validate
1067  * changes made by a pool to a config when gst_buffer_pool_set_config()
1068  * returns %FALSE. This expects that @caps haven&#39;t changed and that
1069  * @min_buffers aren&#39;t lower then what we initially expected.
1070  * This does not check if options or allocator parameters are still valid,
1071  * won&#39;t check if size have changed, since changing the size is valid to adapt
1072  * padding.
1073  *
1074  * Since: 1.4
1075  *
1076  * Returns: %TRUE, if the parameters are valid in this context.
1077  */
1078 gboolean
1079 gst_buffer_pool_config_validate_params (GstStructure * config, GstCaps * caps,
1080     guint size, guint min_buffers, G_GNUC_UNUSED guint max_buffers)
1081 {
1082   GstCaps *newcaps;
1083   guint newsize, newmin;
1084   gboolean ret = FALSE;
1085 
1086   g_return_val_if_fail (config != NULL, FALSE);
1087 
1088   gst_buffer_pool_config_get_params (config, &amp;newcaps, &amp;newsize, &amp;newmin, NULL);
1089 
1090   if (gst_caps_is_equal (caps, newcaps) &amp;&amp; (newsize &gt;= size)
1091       &amp;&amp; (newmin &gt;= min_buffers))
1092     ret = TRUE;
1093 
1094   return ret;
1095 }
1096 
1097 static GstFlowReturn
1098 default_acquire_buffer (GstBufferPool * pool, GstBuffer ** buffer,
1099     GstBufferPoolAcquireParams * params)
1100 {
1101   GstFlowReturn result;
1102   GstBufferPoolPrivate *priv = pool-&gt;priv;
1103 
1104   while (TRUE) {
1105     if (G_UNLIKELY (GST_BUFFER_POOL_IS_FLUSHING (pool)))
1106       goto flushing;
1107 
1108     /* try to get a buffer from the queue */
1109     *buffer = gst_atomic_queue_pop (priv-&gt;queue);
1110     if (G_LIKELY (*buffer)) {
1111       while (!gst_poll_read_control (priv-&gt;poll)) {
1112         if (errno == EWOULDBLOCK) {
1113           /* We put the buffer into the queue but did not finish writing control
1114            * yet, let&#39;s wait a bit and retry */
1115           g_thread_yield ();
1116           continue;
1117         } else {
1118           /* Critical error but GstPoll already complained */
1119           break;
1120         }
1121       }
1122       result = GST_FLOW_OK;
1123       GST_LOG_OBJECT (pool, &quot;acquired buffer %p&quot;, *buffer);
1124       break;
1125     }
1126 
1127     /* no buffer, try to allocate some more */
1128     GST_LOG_OBJECT (pool, &quot;no buffer, trying to allocate&quot;);
1129     result = do_alloc_buffer (pool, buffer, params);
1130     if (G_LIKELY (result == GST_FLOW_OK))
1131       /* we have a buffer, return it */
1132       break;
1133 
1134     if (G_UNLIKELY (result != GST_FLOW_EOS))
1135       /* something went wrong, return error */
1136       break;
1137 
1138     /* check if we need to wait */
1139     if (params &amp;&amp; (params-&gt;flags &amp; GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT)) {
1140       GST_LOG_OBJECT (pool, &quot;no more buffers&quot;);
1141       break;
1142     }
1143 
1144     /* now we release the control socket, we wait for a buffer release or
1145      * flushing */
1146     if (!gst_poll_read_control (pool-&gt;priv-&gt;poll)) {
1147       if (errno == EWOULDBLOCK) {
1148         /* This means that we have two threads trying to allocate buffers
1149          * already, and the other one already got the wait token. This
1150          * means that we only have to wait for the poll now and not write the
1151          * token afterwards: we will be woken up once the other thread is
1152          * woken up and that one will write the wait token it removed */
1153         GST_LOG_OBJECT (pool, &quot;waiting for free buffers or flushing&quot;);
1154         gst_poll_wait (priv-&gt;poll, GST_CLOCK_TIME_NONE);
1155       } else {
1156         /* This is a critical error, GstPoll already gave a warning */
1157         result = GST_FLOW_ERROR;
1158         break;
1159       }
1160     } else {
1161       /* We&#39;re the first thread waiting, we got the wait token and have to
1162        * write it again later
1163        * OR
1164        * We&#39;re a second thread and just consumed the flush token and block all
1165        * other threads, in which case we must not wait and give it back
1166        * immediately */
1167       if (!GST_BUFFER_POOL_IS_FLUSHING (pool)) {
1168         GST_LOG_OBJECT (pool, &quot;waiting for free buffers or flushing&quot;);
1169         gst_poll_wait (priv-&gt;poll, GST_CLOCK_TIME_NONE);
1170       }
1171       gst_poll_write_control (pool-&gt;priv-&gt;poll);
1172     }
1173   }
1174 
1175   return result;
1176 
1177   /* ERRORS */
1178 flushing:
1179   {
1180     GST_DEBUG_OBJECT (pool, &quot;we are flushing&quot;);
1181     return GST_FLOW_FLUSHING;
1182   }
1183 }
1184 
1185 static inline void
1186 dec_outstanding (GstBufferPool * pool)
1187 {
1188   if (g_atomic_int_dec_and_test (&amp;pool-&gt;priv-&gt;outstanding)) {
1189     /* all buffers are returned to the pool, see if we need to free them */
1190     if (GST_BUFFER_POOL_IS_FLUSHING (pool)) {
1191       /* take the lock so that set_active is not run concurrently */
1192       GST_BUFFER_POOL_LOCK (pool);
1193       /* now that we have the lock, check if we have been de-activated with
1194        * outstanding buffers */
1195       if (!pool-&gt;priv-&gt;active)
1196         do_stop (pool);
1197 
1198       GST_BUFFER_POOL_UNLOCK (pool);
1199     }
1200   }
1201 }
1202 
1203 static gboolean
1204 remove_meta_unpooled (GstBuffer * buffer, GstMeta ** meta, gpointer user_data)
1205 {
1206   if (!GST_META_FLAG_IS_SET (*meta, GST_META_FLAG_POOLED)) {
1207     GST_META_FLAG_UNSET (*meta, GST_META_FLAG_LOCKED);
1208     *meta = NULL;
1209   }
1210   return TRUE;
1211 }
1212 
1213 static void
1214 default_reset_buffer (GstBufferPool * pool, GstBuffer * buffer)
1215 {
1216   GST_BUFFER_FLAGS (buffer) &amp;= GST_BUFFER_FLAG_TAG_MEMORY;
1217 
1218   GST_BUFFER_PTS (buffer) = GST_CLOCK_TIME_NONE;
1219   GST_BUFFER_DTS (buffer) = GST_CLOCK_TIME_NONE;
1220   GST_BUFFER_DURATION (buffer) = GST_CLOCK_TIME_NONE;
1221   GST_BUFFER_OFFSET (buffer) = GST_BUFFER_OFFSET_NONE;
1222   GST_BUFFER_OFFSET_END (buffer) = GST_BUFFER_OFFSET_NONE;
1223 
1224   /* if the memory is intact reset the size to the full size */
1225   if (!GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY)) {
1226     gsize offset;
1227     gst_buffer_get_sizes (buffer, &amp;offset, NULL);
1228     gst_buffer_resize (buffer, -offset, pool-&gt;priv-&gt;size);
1229   }
1230 
1231   /* remove all metadata without the POOLED flag */
1232   gst_buffer_foreach_meta (buffer, remove_meta_unpooled, pool);
1233 }
1234 
1235 /**
1236  * gst_buffer_pool_acquire_buffer:
1237  * @pool: a #GstBufferPool
1238  * @buffer: (out): a location for a #GstBuffer
1239  * @params: (transfer none) (allow-none): parameters.
1240  *
1241  * Acquire a buffer from @pool. @buffer should point to a memory location that
1242  * can hold a pointer to the new buffer.
1243  *
1244  * @params can be %NULL or contain optional parameters to influence the
1245  * allocation.
1246  *
1247  * Returns: a #GstFlowReturn such as %GST_FLOW_FLUSHING when the pool is
1248  * inactive.
1249  */
1250 GstFlowReturn
1251 gst_buffer_pool_acquire_buffer (GstBufferPool * pool, GstBuffer ** buffer,
1252     GstBufferPoolAcquireParams * params)
1253 {
1254   GstBufferPoolClass *pclass;
1255   GstFlowReturn result;
1256 
1257   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), GST_FLOW_ERROR);
1258   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
1259 
1260   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
1261 
1262   /* assume we&#39;ll have one more outstanding buffer we need to do that so
1263    * that concurrent set_active doesn&#39;t clear the buffers */
1264   g_atomic_int_inc (&amp;pool-&gt;priv-&gt;outstanding);
1265 
1266   if (G_LIKELY (pclass-&gt;acquire_buffer))
1267     result = pclass-&gt;acquire_buffer (pool, buffer, params);
1268   else
1269     result = GST_FLOW_NOT_SUPPORTED;
1270 
1271   if (G_LIKELY (result == GST_FLOW_OK)) {
1272     /* all buffers from the pool point to the pool and have the refcount of the
1273      * pool incremented */
1274     (*buffer)-&gt;pool = gst_object_ref (pool);
1275   } else {
1276     dec_outstanding (pool);
1277   }
1278 
1279   return result;
1280 }
1281 
1282 static void
1283 default_release_buffer (GstBufferPool * pool, GstBuffer * buffer)
1284 {
1285   GST_LOG_OBJECT (pool, &quot;released buffer %p %d&quot;, buffer,
1286       GST_MINI_OBJECT_FLAGS (buffer));
1287 
1288   /* memory should be untouched */
1289   if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY)))
1290     goto memory_tagged;
1291 
1292   /* size should have been reset. This is not a catch all, pool with
1293    * size requirement per memory should do their own check. */
1294   if (G_UNLIKELY (gst_buffer_get_size (buffer) != pool-&gt;priv-&gt;size))
1295     goto size_changed;
1296 
1297   /* all memory should be exclusive to this buffer (and thus be writable) */
1298   if (G_UNLIKELY (!gst_buffer_is_all_memory_writable (buffer)))
1299     goto not_writable;
1300 
1301   /* keep it around in our queue */
1302   gst_atomic_queue_push (pool-&gt;priv-&gt;queue, buffer);
1303   gst_poll_write_control (pool-&gt;priv-&gt;poll);
1304 
1305   return;
1306 
1307 memory_tagged:
1308   {
1309     GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pool,
1310         &quot;discarding buffer %p: memory tag set&quot;, buffer);
1311     goto discard;
1312   }
1313 size_changed:
1314   {
1315     GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pool,
1316         &quot;discarding buffer %p: size %&quot; G_GSIZE_FORMAT &quot; != %u&quot;,
1317         buffer, gst_buffer_get_size (buffer), pool-&gt;priv-&gt;size);
1318     goto discard;
1319   }
1320 not_writable:
1321   {
1322     GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pool,
1323         &quot;discarding buffer %p: memory not writable&quot;, buffer);
1324     goto discard;
1325   }
1326 discard:
1327   {
1328     do_free_buffer (pool, buffer);
1329     return;
1330   }
1331 }
1332 
1333 /**
1334  * gst_buffer_pool_release_buffer:
1335  * @pool: a #GstBufferPool
1336  * @buffer: (transfer full): a #GstBuffer
1337  *
1338  * Release @buffer to @pool. @buffer should have previously been allocated from
1339  * @pool with gst_buffer_pool_acquire_buffer().
1340  *
1341  * This function is usually called automatically when the last ref on @buffer
1342  * disappears.
1343  */
1344 void
1345 gst_buffer_pool_release_buffer (GstBufferPool * pool, GstBuffer * buffer)
1346 {
1347   GstBufferPoolClass *pclass;
1348 
1349   g_return_if_fail (GST_IS_BUFFER_POOL (pool));
1350   g_return_if_fail (buffer != NULL);
1351 
1352   /* check that the buffer is ours, all buffers returned to the pool have the
1353    * pool member set to NULL and the pool refcount decreased */
1354   if (!g_atomic_pointer_compare_and_exchange (&amp;buffer-&gt;pool, pool, NULL))
1355     return;
1356 
1357   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
1358 
1359   /* reset the buffer when needed */
1360   if (G_LIKELY (pclass-&gt;reset_buffer))
1361     pclass-&gt;reset_buffer (pool, buffer);
1362 
1363   if (G_LIKELY (pclass-&gt;release_buffer))
1364     pclass-&gt;release_buffer (pool, buffer);
1365 
1366   dec_outstanding (pool);
1367 
1368   /* decrease the refcount that the buffer had to us */
1369   gst_object_unref (pool);
1370 }
1371 
1372 /**
1373  * gst_buffer_pool_set_flushing:
1374  * @pool: a #GstBufferPool
1375  * @flushing: whether to start or stop flushing
1376  *
1377  * Enable or disable the flushing state of a @pool without freeing or
1378  * allocating buffers.
1379  *
1380  * Since: 1.4
1381  */
1382 void
1383 gst_buffer_pool_set_flushing (GstBufferPool * pool, gboolean flushing)
1384 {
1385   GstBufferPoolPrivate *priv;
1386 
1387   g_return_if_fail (GST_IS_BUFFER_POOL (pool));
1388 
1389   GST_LOG_OBJECT (pool, &quot;flushing %d&quot;, flushing);
1390 
1391   priv = pool-&gt;priv;
1392 
1393   GST_BUFFER_POOL_LOCK (pool);
1394 
1395   if (!priv-&gt;active) {
1396     GST_WARNING_OBJECT (pool, &quot;can&#39;t change flushing state of inactive pool&quot;);
1397     goto done;
1398   }
1399 
1400   do_set_flushing (pool, flushing);
1401 
1402 done:
1403   GST_BUFFER_POOL_UNLOCK (pool);
1404 }
    </pre>
  </body>
</html>