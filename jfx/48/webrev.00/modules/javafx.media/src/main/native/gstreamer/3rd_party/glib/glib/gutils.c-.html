<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1998  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe for the unix part, FIXME: make the win32 part MT safe as well.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &quot;gutils.h&quot;
  32 
  33 #include &lt;stdarg.h&gt;
  34 #include &lt;stdlib.h&gt;
  35 #include &lt;stdio.h&gt;
  36 #include &lt;locale.h&gt;
  37 #include &lt;string.h&gt;
  38 #include &lt;ctype.h&gt;      /* For tolower() */
  39 #include &lt;errno.h&gt;
  40 #include &lt;sys/types.h&gt;
  41 #include &lt;sys/stat.h&gt;
  42 #ifdef G_OS_UNIX
  43 #include &lt;pwd.h&gt;
  44 #include &lt;unistd.h&gt;
  45 #endif
  46 #include &lt;sys/types.h&gt;
  47 #ifdef HAVE_SYS_PARAM_H
  48 #include &lt;sys/param.h&gt;
  49 #endif
  50 #ifdef HAVE_CRT_EXTERNS_H
  51 #include &lt;crt_externs.h&gt; /* for _NSGetEnviron */
  52 #endif
  53 #ifdef HAVE_SYS_AUXV_H
  54 #include &lt;sys/auxv.h&gt;
  55 #endif
  56 
  57 #include &quot;glib-init.h&quot;
  58 #include &quot;glib-private.h&quot;
  59 #include &quot;genviron.h&quot;
  60 #include &quot;gfileutils.h&quot;
  61 #include &quot;ggettext.h&quot;
  62 #include &quot;ghash.h&quot;
  63 #include &quot;gthread.h&quot;
  64 #include &quot;gtestutils.h&quot;
  65 #include &quot;gunicode.h&quot;
  66 #include &quot;gstrfuncs.h&quot;
  67 #include &quot;garray.h&quot;
  68 #include &quot;glibintl.h&quot;
  69 #include &quot;gstdio.h&quot;
  70 
  71 #ifdef G_PLATFORM_WIN32
  72 #include &quot;gconvert.h&quot;
  73 #include &quot;gwin32.h&quot;
  74 #endif
  75 
  76 
  77 /**
  78  * SECTION:misc_utils
  79  * @title: Miscellaneous Utility Functions
  80  * @short_description: a selection of portable utility functions
  81  *
  82  * These are portable utility functions.
  83  */
  84 
  85 #ifdef G_PLATFORM_WIN32
  86 #  include &lt;windows.h&gt;
  87 #  ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
  88 #    define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 2
  89 #    define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS 4
  90 #  endif
  91 #  include &lt;lmcons.h&gt;       /* For UNLEN */
  92 #endif /* G_PLATFORM_WIN32 */
  93 
  94 #ifdef G_OS_WIN32
  95 #  include &lt;direct.h&gt;
  96 #  include &lt;shlobj.h&gt;
  97    /* older SDK (e.g. msvc 5.0) does not have these*/
  98 #  ifndef CSIDL_MYMUSIC
  99 #    define CSIDL_MYMUSIC 13
 100 #  endif
 101 #  ifndef CSIDL_MYVIDEO
 102 #    define CSIDL_MYVIDEO 14
 103 #  endif
 104 #  ifndef CSIDL_INTERNET_CACHE
 105 #    define CSIDL_INTERNET_CACHE 32
 106 #  endif
 107 #  ifndef CSIDL_COMMON_APPDATA
 108 #    define CSIDL_COMMON_APPDATA 35
 109 #  endif
 110 #  ifndef CSIDL_MYPICTURES
 111 #    define CSIDL_MYPICTURES 0x27
 112 #  endif
 113 #  ifndef CSIDL_COMMON_DOCUMENTS
 114 #    define CSIDL_COMMON_DOCUMENTS 46
 115 #  endif
 116 #  ifndef CSIDL_PROFILE
 117 #    define CSIDL_PROFILE 40
 118 #  endif
 119 #  include &lt;process.h&gt;
 120 #endif
 121 
 122 #ifdef HAVE_CARBON
 123 #include &lt;CoreServices/CoreServices.h&gt;
 124 #endif
 125 
 126 #ifdef HAVE_CODESET
 127 #include &lt;langinfo.h&gt;
 128 #endif
 129 
 130 #ifdef G_PLATFORM_WIN32
 131 
 132 gchar *
 133 _glib_get_dll_directory (void)
 134 {
 135   gchar *retval;
 136   gchar *p;
 137   wchar_t wc_fn[MAX_PATH];
 138 
 139 #ifdef DLL_EXPORT
 140   if (glib_dll == NULL)
 141     return NULL;
 142 #endif
 143 
 144   /* This code is different from that in
 145    * g_win32_get_package_installation_directory_of_module() in that
 146    * here we return the actual folder where the GLib DLL is. We don&#39;t
 147    * do the check for it being in a &quot;bin&quot; or &quot;lib&quot; subfolder and then
 148    * returning the parent of that.
 149    *
 150    * In a statically built GLib, glib_dll will be NULL and we will
 151    * thus look up the application&#39;s .exe file&#39;s location.
 152    */
 153   if (!GetModuleFileNameW (glib_dll, wc_fn, MAX_PATH))
 154     return NULL;
 155 
 156   retval = g_utf16_to_utf8 (wc_fn, -1, NULL, NULL, NULL);
 157 
 158   p = strrchr (retval, G_DIR_SEPARATOR);
 159   if (p == NULL)
 160     {
 161       /* Wtf? */
 162       return NULL;
 163     }
 164   *p = &#39;\0&#39;;
 165 
 166   return retval;
 167 }
 168 
 169 #endif
 170 
 171 /**
 172  * g_memmove:
 173  * @dest: the destination address to copy the bytes to.
 174  * @src: the source address to copy the bytes from.
 175  * @len: the number of bytes to copy.
 176  *
 177  * Copies a block of memory @len bytes long, from @src to @dest.
 178  * The source and destination areas may overlap.
 179  *
 180  * Deprecated:2.40: Just use memmove().
 181  */
 182 
 183 #ifndef GSTREAMER_LITE
 184 
 185 #ifdef G_OS_WIN32
 186 #undef g_atexit
 187 #endif
 188 
 189 /**
 190  * g_atexit:
 191  * @func: (scope async): the function to call on normal program termination.
 192  *
 193  * Specifies a function to be called at normal program termination.
 194  *
 195  * Since GLib 2.8.2, on Windows g_atexit() actually is a preprocessor
 196  * macro that maps to a call to the atexit() function in the C
 197  * library. This means that in case the code that calls g_atexit(),
 198  * i.e. atexit(), is in a DLL, the function will be called when the
 199  * DLL is detached from the program. This typically makes more sense
 200  * than that the function is called when the GLib DLL is detached,
 201  * which happened earlier when g_atexit() was a function in the GLib
 202  * DLL.
 203  *
 204  * The behaviour of atexit() in the context of dynamically loaded
 205  * modules is not formally specified and varies wildly.
 206  *
 207  * On POSIX systems, calling g_atexit() (or atexit()) in a dynamically
 208  * loaded module which is unloaded before the program terminates might
 209  * well cause a crash at program exit.
 210  *
 211  * Some POSIX systems implement atexit() like Windows, and have each
 212  * dynamically loaded module maintain an own atexit chain that is
 213  * called when the module is unloaded.
 214  *
 215  * On other POSIX systems, before a dynamically loaded module is
 216  * unloaded, the registered atexit functions (if any) residing in that
 217  * module are called, regardless where the code that registered them
 218  * resided. This is presumably the most robust approach.
 219  *
 220  * As can be seen from the above, for portability it&#39;s best to avoid
 221  * calling g_atexit() (or atexit()) except in the main executable of a
 222  * program.
 223  *
 224  * Deprecated:2.32: It is best to avoid g_atexit().
 225  */
 226 void
 227 g_atexit (GVoidFunc func)
 228 {
 229   gint result;
 230   int errsv;
 231 
 232   result = atexit ((void (*)(void)) func);
 233   errsv = errno;
 234   if (result)
 235     {
 236       g_error (&quot;Could not register atexit() function: %s&quot;,
 237                g_strerror (errsv));
 238     }
 239 }
 240 
 241 #endif // GSTREAMER_LITE
 242 
 243 /* Based on execvp() from GNU Libc.
 244  * Some of this code is cut-and-pasted into gspawn.c
 245  */
 246 
 247 static gchar*
 248 my_strchrnul (const gchar *str,
 249           gchar        c)
 250 {
 251   gchar *p = (gchar*)str;
 252   while (*p &amp;&amp; (*p != c))
 253     ++p;
 254 
 255   return p;
 256 }
 257 
 258 #ifdef G_OS_WIN32
 259 
 260 static gchar *inner_find_program_in_path (const gchar *program);
 261 
 262 gchar*
 263 g_find_program_in_path (const gchar *program)
 264 {
 265   const gchar *last_dot = strrchr (program, &#39;.&#39;);
 266 
 267   if (last_dot == NULL ||
 268       strchr (last_dot, &#39;\\&#39;) != NULL ||
 269       strchr (last_dot, &#39;/&#39;) != NULL)
 270     {
 271       const gint program_length = strlen (program);
 272       gchar *pathext = g_build_path (&quot;;&quot;,
 273                      &quot;.exe;.cmd;.bat;.com&quot;,
 274                      g_getenv (&quot;PATHEXT&quot;),
 275                      NULL);
 276       gchar *p;
 277       gchar *decorated_program;
 278       gchar *retval;
 279 
 280       p = pathext;
 281       do
 282     {
 283       gchar *q = my_strchrnul (p, &#39;;&#39;);
 284 
 285       decorated_program = g_malloc (program_length + (q-p) + 1);
 286       memcpy (decorated_program, program, program_length);
 287       memcpy (decorated_program+program_length, p, q-p);
 288       decorated_program [program_length + (q-p)] = &#39;\0&#39;;
 289 
 290       retval = inner_find_program_in_path (decorated_program);
 291       g_free (decorated_program);
 292 
 293       if (retval != NULL)
 294         {
 295           g_free (pathext);
 296           return retval;
 297         }
 298       p = q;
 299     } while (*p++ != &#39;\0&#39;);
 300       g_free (pathext);
 301       return NULL;
 302     }
 303   else
 304     return inner_find_program_in_path (program);
 305 }
 306 
 307 #endif
 308 
 309 /**
 310  * g_find_program_in_path:
 311  * @program: (type filename): a program name in the GLib file name encoding
 312  *
 313  * Locates the first executable named @program in the user&#39;s path, in the
 314  * same way that execvp() would locate it. Returns an allocated string
 315  * with the absolute path name, or %NULL if the program is not found in
 316  * the path. If @program is already an absolute path, returns a copy of
 317  * @program if @program exists and is executable, and %NULL otherwise.
 318  *
 319  * On Windows, if @program does not have a file type suffix, tries
 320  * with the suffixes .exe, .cmd, .bat and .com, and the suffixes in
 321  * the `PATHEXT` environment variable.
 322  *
 323  * On Windows, it looks for the file in the same way as CreateProcess()
 324  * would. This means first in the directory where the executing
 325  * program was loaded from, then in the current directory, then in the
 326  * Windows 32-bit system directory, then in the Windows directory, and
 327  * finally in the directories in the `PATH` environment variable. If
 328  * the program is found, the return value contains the full name
 329  * including the type suffix.
 330  *
 331  * Returns: (type filename): a newly-allocated string with the absolute path,
 332  *     or %NULL
 333  **/
 334 #ifdef G_OS_WIN32
 335 static gchar *
 336 inner_find_program_in_path (const gchar *program)
 337 #else
 338 gchar*
 339 g_find_program_in_path (const gchar *program)
 340 #endif
 341 {
 342   const gchar *path, *p;
 343   gchar *name, *freeme;
 344 #ifdef G_OS_WIN32
 345   const gchar *path_copy;
 346   gchar *filename = NULL, *appdir = NULL;
 347   gchar *sysdir = NULL, *windir = NULL;
 348   int n;
 349   wchar_t wfilename[MAXPATHLEN], wsysdir[MAXPATHLEN],
 350     wwindir[MAXPATHLEN];
 351 #endif
 352   gsize len;
 353   gsize pathlen;
 354 
 355   g_return_val_if_fail (program != NULL, NULL);
 356 
 357   /* If it is an absolute path, or a relative path including subdirectories,
 358    * don&#39;t look in PATH.
 359    */
 360   if (g_path_is_absolute (program)
 361       || strchr (program, G_DIR_SEPARATOR) != NULL
 362 #ifdef G_OS_WIN32
 363       || strchr (program, &#39;/&#39;) != NULL
 364 #endif
 365       )
 366     {
 367       if (g_file_test (program, G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
 368       !g_file_test (program, G_FILE_TEST_IS_DIR))
 369         return g_strdup (program);
 370       else
 371         return NULL;
 372     }
 373 
 374   path = g_getenv (&quot;PATH&quot;);
 375 #if defined(G_OS_UNIX)
 376   if (path == NULL)
 377     {
 378       /* There is no &#39;PATH&#39; in the environment.  The default
 379        * search path in GNU libc is the current directory followed by
 380        * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.
 381        */
 382 
 383       /* In GLib we put . last, for security, and don&#39;t use the
 384        * unportable confstr(); UNIX98 does not actually specify
 385        * what to search if PATH is unset. POSIX may, dunno.
 386        */
 387 
 388       path = &quot;/bin:/usr/bin:.&quot;;
 389     }
 390 #else
 391   n = GetModuleFileNameW (NULL, wfilename, MAXPATHLEN);
 392   if (n &gt; 0 &amp;&amp; n &lt; MAXPATHLEN)
 393     filename = g_utf16_to_utf8 (wfilename, -1, NULL, NULL, NULL);
 394 
 395   n = GetSystemDirectoryW (wsysdir, MAXPATHLEN);
 396   if (n &gt; 0 &amp;&amp; n &lt; MAXPATHLEN)
 397     sysdir = g_utf16_to_utf8 (wsysdir, -1, NULL, NULL, NULL);
 398 
 399   n = GetWindowsDirectoryW (wwindir, MAXPATHLEN);
 400   if (n &gt; 0 &amp;&amp; n &lt; MAXPATHLEN)
 401     windir = g_utf16_to_utf8 (wwindir, -1, NULL, NULL, NULL);
 402 
 403   if (filename)
 404     {
 405       appdir = g_path_get_dirname (filename);
 406       g_free (filename);
 407     }
 408 
 409   path = g_strdup (path);
 410 
 411   if (windir)
 412     {
 413       const gchar *tem = path;
 414       path = g_strconcat (windir, &quot;;&quot;, path, NULL);
 415       g_free ((gchar *) tem);
 416       g_free (windir);
 417     }
 418 
 419   if (sysdir)
 420     {
 421       const gchar *tem = path;
 422       path = g_strconcat (sysdir, &quot;;&quot;, path, NULL);
 423       g_free ((gchar *) tem);
 424       g_free (sysdir);
 425     }
 426 
 427   {
 428     const gchar *tem = path;
 429     path = g_strconcat (&quot;.;&quot;, path, NULL);
 430     g_free ((gchar *) tem);
 431   }
 432 
 433   if (appdir)
 434     {
 435       const gchar *tem = path;
 436       path = g_strconcat (appdir, &quot;;&quot;, path, NULL);
 437       g_free ((gchar *) tem);
 438       g_free (appdir);
 439     }
 440 
 441   path_copy = path;
 442 #endif
 443 
 444   len = strlen (program) + 1;
 445   pathlen = strlen (path);
 446   freeme = name = g_malloc (pathlen + len + 1);
 447 #ifdef GSTREAMER_LITE
 448   if (freeme == NULL)
 449       return NULL;
 450 #endif // GSTREAMER_LITE
 451 
 452   /* Copy the file name at the top, including &#39;\0&#39;  */
 453   memcpy (name + pathlen + 1, program, len);
 454   name = name + pathlen;
 455   /* And add the slash before the filename  */
 456   *name = G_DIR_SEPARATOR;
 457 
 458   p = path;
 459   do
 460     {
 461       char *startp;
 462 
 463       path = p;
 464       p = my_strchrnul (path, G_SEARCHPATH_SEPARATOR);
 465 
 466       if (p == path)
 467         /* Two adjacent colons, or a colon at the beginning or the end
 468          * of &#39;PATH&#39; means to search the current directory.
 469          */
 470         startp = name + 1;
 471       else
 472         startp = memcpy (name - (p - path), path, p - path);
 473 
 474       if (g_file_test (startp, G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
 475       !g_file_test (startp, G_FILE_TEST_IS_DIR))
 476         {
 477           gchar *ret;
 478           ret = g_strdup (startp);
 479           g_free (freeme);
 480 #ifdef G_OS_WIN32
 481       g_free ((gchar *) path_copy);
 482 #endif
 483           return ret;
 484         }
 485     }
 486   while (*p++ != &#39;\0&#39;);
 487 
 488   g_free (freeme);
 489 #ifdef G_OS_WIN32
 490   g_free ((gchar *) path_copy);
 491 #endif
 492 
 493   return NULL;
 494 }
 495 
 496 /* The functions below are defined this way for compatibility reasons.
 497  * See the note in gutils.h.
 498  */
 499 
 500 /**
 501  * g_bit_nth_lsf:
 502  * @mask: a #gulong containing flags
 503  * @nth_bit: the index of the bit to start the search from
 504  *
 505  * Find the position of the first bit set in @mask, searching
 506  * from (but not including) @nth_bit upwards. Bits are numbered
 507  * from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
 508  * usually). To start searching from the 0th bit, set @nth_bit to -1.
 509  *
 510  * Returns: the index of the first bit set which is higher than @nth_bit, or -1
 511  *    if no higher bits are set
 512  */
 513 gint
 514 (g_bit_nth_lsf) (gulong mask,
 515                  gint   nth_bit)
 516 {
 517   return g_bit_nth_lsf_impl (mask, nth_bit);
 518 }
 519 
 520 /**
 521  * g_bit_nth_msf:
 522  * @mask: a #gulong containing flags
 523  * @nth_bit: the index of the bit to start the search from
 524  *
 525  * Find the position of the first bit set in @mask, searching
 526  * from (but not including) @nth_bit downwards. Bits are numbered
 527  * from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
 528  * usually). To start searching from the last bit, set @nth_bit to
 529  * -1 or GLIB_SIZEOF_LONG * 8.
 530  *
 531  * Returns: the index of the first bit set which is lower than @nth_bit, or -1
 532  *    if no lower bits are set
 533  */
 534 gint
 535 (g_bit_nth_msf) (gulong mask,
 536                  gint   nth_bit)
 537 {
 538   return g_bit_nth_msf_impl (mask, nth_bit);
 539 }
 540 
 541 
 542 /**
 543  * g_bit_storage:
 544  * @number: a #guint
 545  *
 546  * Gets the number of bits used to hold @number,
 547  * e.g. if @number is 4, 3 bits are needed.
 548  *
 549  * Returns: the number of bits used to hold @number
 550  */
 551 guint
 552 (g_bit_storage) (gulong number)
 553 {
 554   return g_bit_storage_impl (number);
 555 }
 556 
 557 G_LOCK_DEFINE_STATIC (g_utils_global);
 558 
 559 typedef struct
 560 {
 561   gchar *user_name;
 562   gchar *real_name;
 563   gchar *home_dir;
 564 } UserDatabaseEntry;
 565 
 566 static  gchar   *g_user_data_dir = NULL;
 567 static  gchar  **g_system_data_dirs = NULL;
 568 static  gchar   *g_user_cache_dir = NULL;
 569 static  gchar   *g_user_config_dir = NULL;
 570 static  gchar  **g_system_config_dirs = NULL;
 571 
 572 static  gchar  **g_user_special_dirs = NULL;
 573 
 574 /* fifteen minutes of fame for everybody */
 575 #define G_USER_DIRS_EXPIRE      15 * 60
 576 
 577 #ifdef G_OS_WIN32
 578 
 579 static gchar *
 580 get_special_folder (int csidl)
 581 {
 582   wchar_t path[MAX_PATH+1];
 583   HRESULT hr;
 584   LPITEMIDLIST pidl = NULL;
 585   BOOL b;
 586   gchar *retval = NULL;
 587 
 588   hr = SHGetSpecialFolderLocation (NULL, csidl, &amp;pidl);
 589   if (hr == S_OK)
 590     {
 591       b = SHGetPathFromIDListW (pidl, path);
 592       if (b)
 593     retval = g_utf16_to_utf8 (path, -1, NULL, NULL, NULL);
 594       CoTaskMemFree (pidl);
 595     }
 596   return retval;
 597 }
 598 
 599 static char *
 600 get_windows_directory_root (void)
 601 {
 602   wchar_t wwindowsdir[MAX_PATH];
 603 
 604   if (GetWindowsDirectoryW (wwindowsdir, G_N_ELEMENTS (wwindowsdir)))
 605     {
 606       /* Usually X:\Windows, but in terminal server environments
 607        * might be an UNC path, AFAIK.
 608        */
 609       char *windowsdir = g_utf16_to_utf8 (wwindowsdir, -1, NULL, NULL, NULL);
 610       char *p;
 611 
 612       if (windowsdir == NULL)
 613     return g_strdup (&quot;C:\\&quot;);
 614 
 615       p = (char *) g_path_skip_root (windowsdir);
 616       if (G_IS_DIR_SEPARATOR (p[-1]) &amp;&amp; p[-2] != &#39;:&#39;)
 617     p--;
 618       *p = &#39;\0&#39;;
 619       return windowsdir;
 620     }
 621   else
 622     return g_strdup (&quot;C:\\&quot;);
 623 }
 624 
 625 #endif
 626 
 627 /* HOLDS: g_utils_global_lock */
 628 static UserDatabaseEntry *
 629 g_get_user_database_entry (void)
 630 {
 631   static UserDatabaseEntry *entry;
 632 
 633   if (g_once_init_enter (&amp;entry))
 634     {
 635       static UserDatabaseEntry e;
 636 
 637 #ifdef G_OS_UNIX
 638       {
 639         struct passwd *pw = NULL;
 640         gpointer buffer = NULL;
 641         gint error;
 642         gchar *logname;
 643 
 644 #  if defined (HAVE_GETPWUID_R)
 645         struct passwd pwd;
 646 #    ifdef _SC_GETPW_R_SIZE_MAX
 647         /* This reurns the maximum length */
 648         glong bufsize = sysconf (_SC_GETPW_R_SIZE_MAX);
 649 
 650         if (bufsize &lt; 0)
 651           bufsize = 64;
 652 #    else /* _SC_GETPW_R_SIZE_MAX */
 653         glong bufsize = 64;
 654 #    endif /* _SC_GETPW_R_SIZE_MAX */
 655 
 656         logname = (gchar *) g_getenv (&quot;LOGNAME&quot;);
 657 
 658         do
 659           {
 660             g_free (buffer);
 661             /* we allocate 6 extra bytes to work around a bug in
 662              * Mac OS &lt; 10.3. See #156446
 663              */
 664             buffer = g_malloc (bufsize + 6);
 665             errno = 0;
 666 
 667             if (logname) {
 668               error = getpwnam_r (logname, &amp;pwd, buffer, bufsize, &amp;pw);
 669               if (!pw || (pw-&gt;pw_uid != getuid ())) {
 670                 /* LOGNAME is lying, fall back to looking up the uid */
 671                 error = getpwuid_r (getuid (), &amp;pwd, buffer, bufsize, &amp;pw);
 672               }
 673             } else {
 674               error = getpwuid_r (getuid (), &amp;pwd, buffer, bufsize, &amp;pw);
 675             }
 676             error = error &lt; 0 ? errno : error;
 677 
 678             if (!pw)
 679               {
 680                 /* we bail out prematurely if the user id can&#39;t be found
 681                  * (should be pretty rare case actually), or if the buffer
 682                  * should be sufficiently big and lookups are still not
 683                  * successful.
 684                  */
 685                 if (error == 0 || error == ENOENT)
 686                   {
 687                     g_warning (&quot;getpwuid_r(): failed due to unknown user id (%lu)&quot;,
 688                                (gulong) getuid ());
 689                     break;
 690                   }
 691                 if (bufsize &gt; 32 * 1024)
 692                   {
 693                     g_warning (&quot;getpwuid_r(): failed due to: %s.&quot;,
 694                                g_strerror (error));
 695                     break;
 696                   }
 697 
 698                 bufsize *= 2;
 699               }
 700           }
 701         while (!pw);
 702 #  endif /* HAVE_GETPWUID_R */
 703 
 704         if (!pw)
 705           {
 706             pw = getpwuid (getuid ());
 707           }
 708         if (pw)
 709           {
 710             e.user_name = g_strdup (pw-&gt;pw_name);
 711 
 712 #ifndef __BIONIC__
 713             if (pw-&gt;pw_gecos &amp;&amp; *pw-&gt;pw_gecos != &#39;\0&#39;)
 714               {
 715                 gchar **gecos_fields;
 716                 gchar **name_parts;
 717 
 718                 /* split the gecos field and substitute &#39;&amp;&#39; */
 719                 gecos_fields = g_strsplit (pw-&gt;pw_gecos, &quot;,&quot;, 0);
 720                 name_parts = g_strsplit (gecos_fields[0], &quot;&amp;&quot;, 0);
 721                 pw-&gt;pw_name[0] = g_ascii_toupper (pw-&gt;pw_name[0]);
 722                 e.real_name = g_strjoinv (pw-&gt;pw_name, name_parts);
 723                 g_strfreev (gecos_fields);
 724                 g_strfreev (name_parts);
 725               }
 726 #endif
 727 
 728             if (!e.home_dir)
 729               e.home_dir = g_strdup (pw-&gt;pw_dir);
 730           }
 731         g_free (buffer);
 732       }
 733 
 734 #endif /* G_OS_UNIX */
 735 
 736 #ifdef G_OS_WIN32
 737       {
 738         guint len = UNLEN+1;
 739         wchar_t buffer[UNLEN+1];
 740 
 741         if (GetUserNameW (buffer, (LPDWORD) &amp;len))
 742           {
 743             e.user_name = g_utf16_to_utf8 (buffer, -1, NULL, NULL, NULL);
 744             e.real_name = g_strdup (e.user_name);
 745           }
 746       }
 747 #endif /* G_OS_WIN32 */
 748 
 749       if (!e.user_name)
 750         e.user_name = g_strdup (&quot;somebody&quot;);
 751       if (!e.real_name)
 752         e.real_name = g_strdup (&quot;Unknown&quot;);
 753 
 754       g_once_init_leave (&amp;entry, &amp;e);
 755     }
 756 
 757   return entry;
 758 }
 759 
 760 /**
 761  * g_get_user_name:
 762  *
 763  * Gets the user name of the current user. The encoding of the returned
 764  * string is system-defined. On UNIX, it might be the preferred file name
 765  * encoding, or something else, and there is no guarantee that it is even
 766  * consistent on a machine. On Windows, it is always UTF-8.
 767  *
 768  * Returns: (type filename): the user name of the current user.
 769  */
 770 const gchar *
 771 g_get_user_name (void)
 772 {
 773   UserDatabaseEntry *entry;
 774 
 775   entry = g_get_user_database_entry ();
 776 
 777   return entry-&gt;user_name;
 778 }
 779 
 780 /**
 781  * g_get_real_name:
 782  *
 783  * Gets the real name of the user. This usually comes from the user&#39;s
 784  * entry in the `passwd` file. The encoding of the returned string is
 785  * system-defined. (On Windows, it is, however, always UTF-8.) If the
 786  * real user name cannot be determined, the string &quot;Unknown&quot; is
 787  * returned.
 788  *
 789  * Returns: (type filename): the user&#39;s real name.
 790  */
 791 const gchar *
 792 g_get_real_name (void)
 793 {
 794   UserDatabaseEntry *entry;
 795 
 796   entry = g_get_user_database_entry ();
 797 
 798   return entry-&gt;real_name;
 799 }
 800 
 801 /**
 802  * g_get_home_dir:
 803  *
 804  * Gets the current user&#39;s home directory.
 805  *
 806  * As with most UNIX tools, this function will return the value of the
 807  * `HOME` environment variable if it is set to an existing absolute path
 808  * name, falling back to the `passwd` file in the case that it is unset.
 809  *
 810  * If the path given in `HOME` is non-absolute, does not exist, or is
 811  * not a directory, the result is undefined.
 812  *
 813  * Before version 2.36 this function would ignore the `HOME` environment
 814  * variable, taking the value from the `passwd` database instead. This was
 815  * changed to increase the compatibility of GLib with other programs (and
 816  * the XDG basedir specification) and to increase testability of programs
 817  * based on GLib (by making it easier to run them from test frameworks).
 818  *
 819  * If your program has a strong requirement for either the new or the
 820  * old behaviour (and if you don&#39;t wish to increase your GLib
 821  * dependency to ensure that the new behaviour is in effect) then you
 822  * should either directly check the `HOME` environment variable yourself
 823  * or unset it before calling any functions in GLib.
 824  *
 825  * Returns: (type filename): the current user&#39;s home directory
 826  */
 827 const gchar *
 828 g_get_home_dir (void)
 829 {
 830   static gchar *home_dir;
 831 
 832   if (g_once_init_enter (&amp;home_dir))
 833     {
 834       gchar *tmp;
 835 
 836       /* We first check HOME and use it if it is set */
 837       tmp = g_strdup (g_getenv (&quot;HOME&quot;));
 838 
 839 #ifdef G_OS_WIN32
 840       /* Only believe HOME if it is an absolute path and exists.
 841        *
 842        * We only do this check on Windows for a couple of reasons.
 843        * Historically, we only did it there because we used to ignore $HOME
 844        * on UNIX.  There are concerns about enabling it now on UNIX because
 845        * of things like autofs.  In short, if the user has a bogus value in
 846        * $HOME then they get what they pay for...
 847        */
 848       if (tmp)
 849         {
 850           if (!(g_path_is_absolute (tmp) &amp;&amp;
 851                 g_file_test (tmp, G_FILE_TEST_IS_DIR)))
 852             {
 853               g_free (tmp);
 854               tmp = NULL;
 855             }
 856         }
 857 
 858       /* In case HOME is Unix-style (it happens), convert it to
 859        * Windows style.
 860        */
 861       if (tmp)
 862         {
 863           gchar *p;
 864           while ((p = strchr (tmp, &#39;/&#39;)) != NULL)
 865             *p = &#39;\\&#39;;
 866         }
 867 
 868       if (!tmp)
 869         {
 870           /* USERPROFILE is probably the closest equivalent to $HOME? */
 871           if (g_getenv (&quot;USERPROFILE&quot;) != NULL)
 872             tmp = g_strdup (g_getenv (&quot;USERPROFILE&quot;));
 873         }
 874 
 875       if (!tmp)
 876         tmp = get_special_folder (CSIDL_PROFILE);
 877 
 878       if (!tmp)
 879         tmp = get_windows_directory_root ();
 880 #endif /* G_OS_WIN32 */
 881 
 882       if (!tmp)
 883         {
 884           /* If we didn&#39;t get it from any of those methods, we will have
 885            * to read the user database entry.
 886            */
 887           UserDatabaseEntry *entry;
 888 
 889           entry = g_get_user_database_entry ();
 890 
 891           /* Strictly speaking, we should copy this, but we know that
 892            * neither will ever be freed, so don&#39;t bother...
 893            */
 894           tmp = entry-&gt;home_dir;
 895         }
 896 
 897       /* If we have been denied access to /etc/passwd (for example, by an
 898        * overly-zealous LSM), make up a junk value. The return value at this
 899        * point is explicitly documented as �?undefined’. Memory management is as
 900        * immediately above: strictly this should be copied, but we know not
 901        * copying it is OK. */
 902       if (tmp == NULL)
 903         {
 904           g_warning (&quot;Could not find home directory: $HOME is not set, and &quot;
 905                      &quot;user database could not be read.&quot;);
 906           tmp = &quot;/&quot;;
 907         }
 908 
 909       g_once_init_leave (&amp;home_dir, tmp);
 910     }
 911 
 912   return home_dir;
 913 }
 914 
 915 /**
 916  * g_get_tmp_dir:
 917  *
 918  * Gets the directory to use for temporary files.
 919  *
 920  * On UNIX, this is taken from the `TMPDIR` environment variable.
 921  * If the variable is not set, `P_tmpdir` is
 922  * used, as defined by the system C library. Failing that, a
 923  * hard-coded default of &quot;/tmp&quot; is returned.
 924  *
 925  * On Windows, the `TEMP` environment variable is used, with the
 926  * root directory of the Windows installation (eg: &quot;C:\&quot;) used
 927  * as a default.
 928  *
 929  * The encoding of the returned string is system-defined. On Windows,
 930  * it is always UTF-8. The return value is never %NULL or the empty
 931  * string.
 932  *
 933  * Returns: (type filename): the directory to use for temporary files.
 934  */
 935 const gchar *
 936 g_get_tmp_dir (void)
 937 {
 938   static gchar *tmp_dir;
 939 
 940   if (g_once_init_enter (&amp;tmp_dir))
 941     {
 942       gchar *tmp;
 943 
 944 #ifdef G_OS_WIN32
 945       tmp = g_strdup (g_getenv (&quot;TEMP&quot;));
 946 
 947       if (tmp == NULL || *tmp == &#39;\0&#39;)
 948         {
 949           g_free (tmp);
 950           tmp = get_windows_directory_root ();
 951         }
 952 #else /* G_OS_WIN32 */
 953       tmp = g_strdup (g_getenv (&quot;TMPDIR&quot;));
 954 
 955 #ifdef P_tmpdir
 956       if (tmp == NULL || *tmp == &#39;\0&#39;)
 957         {
 958           gsize k;
 959           g_free (tmp);
 960           tmp = g_strdup (P_tmpdir);
 961           k = strlen (tmp);
 962           if (k &gt; 1 &amp;&amp; G_IS_DIR_SEPARATOR (tmp[k - 1]))
 963             tmp[k - 1] = &#39;\0&#39;;
 964         }
 965 #endif /* P_tmpdir */
 966 
 967       if (tmp == NULL || *tmp == &#39;\0&#39;)
 968         {
 969           g_free (tmp);
 970           tmp = g_strdup (&quot;/tmp&quot;);
 971         }
 972 #endif /* !G_OS_WIN32 */
 973 
 974       g_once_init_leave (&amp;tmp_dir, tmp);
 975     }
 976 
 977   return tmp_dir;
 978 }
 979 
 980 /**
 981  * g_get_host_name:
 982  *
 983  * Return a name for the machine.
 984  *
 985  * The returned name is not necessarily a fully-qualified domain name,
 986  * or even present in DNS or some other name service at all. It need
 987  * not even be unique on your local network or site, but usually it
 988  * is. Callers should not rely on the return value having any specific
 989  * properties like uniqueness for security purposes. Even if the name
 990  * of the machine is changed while an application is running, the
 991  * return value from this function does not change. The returned
 992  * string is owned by GLib and should not be modified or freed. If no
 993  * name can be determined, a default fixed string &quot;localhost&quot; is
 994  * returned.
 995  *
 996  * The encoding of the returned string is UTF-8.
 997  *
 998  * Returns: the host name of the machine.
 999  *
1000  * Since: 2.8
1001  */
1002 const gchar *
1003 g_get_host_name (void)
1004 {
1005   static gchar *hostname;
1006 
1007   if (g_once_init_enter (&amp;hostname))
1008     {
1009       gboolean failed;
1010       gchar *utmp;
1011 
1012 #ifndef G_OS_WIN32
1013       gchar *tmp = g_malloc (sizeof (gchar) * 100);
1014       failed = (gethostname (tmp, sizeof (gchar) * 100) == -1);
1015       if (failed)
1016         g_clear_pointer (&amp;tmp, g_free);
1017       utmp = tmp;
1018 #else
1019       wchar_t tmp[MAX_COMPUTERNAME_LENGTH + 1];
1020       DWORD size = sizeof (tmp) / sizeof (tmp[0]);
1021       failed = (!GetComputerNameW (tmp, &amp;size));
1022       if (!failed)
1023         utmp = g_utf16_to_utf8 (tmp, size, NULL, NULL, NULL);
1024       if (utmp == NULL)
1025         failed = TRUE;
1026 #endif
1027 
1028       g_once_init_leave (&amp;hostname, failed ? g_strdup (&quot;localhost&quot;) : utmp);
1029     }
1030 
1031   return hostname;
1032 }
1033 
1034 G_LOCK_DEFINE_STATIC (g_prgname);
1035 static gchar *g_prgname = NULL;
1036 
1037 /**
1038  * g_get_prgname:
1039  *
1040  * Gets the name of the program. This name should not be localized,
1041  * in contrast to g_get_application_name().
1042  *
1043  * If you are using #GApplication the program name is set in
1044  * g_application_run(). In case of GDK or GTK+ it is set in
1045  * gdk_init(), which is called by gtk_init() and the
1046  * #GtkApplication::startup handler. The program name is found by
1047  * taking the last component of @argv[0].
1048  *
1049  * Returns: the name of the program. The returned string belongs
1050  *     to GLib and must not be modified or freed.
1051  */
1052 const gchar*
1053 g_get_prgname (void)
1054 {
1055   gchar* retval;
1056 
1057   G_LOCK (g_prgname);
1058 #ifdef G_OS_WIN32
1059   if (g_prgname == NULL)
1060     {
1061       static gboolean beenhere = FALSE;
1062 
1063       if (!beenhere)
1064     {
1065       gchar *utf8_buf = NULL;
1066       wchar_t buf[MAX_PATH+1];
1067 
1068       beenhere = TRUE;
1069       if (GetModuleFileNameW (GetModuleHandle (NULL),
1070                   buf, G_N_ELEMENTS (buf)) &gt; 0)
1071         utf8_buf = g_utf16_to_utf8 (buf, -1, NULL, NULL, NULL);
1072 
1073       if (utf8_buf)
1074         {
1075           g_prgname = g_path_get_basename (utf8_buf);
1076           g_free (utf8_buf);
1077         }
1078     }
1079     }
1080 #endif
1081   retval = g_prgname;
1082   G_UNLOCK (g_prgname);
1083 
1084   return retval;
1085 }
1086 
1087 /**
1088  * g_set_prgname:
1089  * @prgname: the name of the program.
1090  *
1091  * Sets the name of the program. This name should not be localized,
1092  * in contrast to g_set_application_name().
1093  *
1094  * If you are using #GApplication the program name is set in
1095  * g_application_run(). In case of GDK or GTK+ it is set in
1096  * gdk_init(), which is called by gtk_init() and the
1097  * #GtkApplication::startup handler. The program name is found by
1098  * taking the last component of @argv[0].
1099  *
1100  * Note that for thread-safety reasons this function can only be called once.
1101  */
1102 void
1103 g_set_prgname (const gchar *prgname)
1104 {
1105   G_LOCK (g_prgname);
1106   g_free (g_prgname);
1107   g_prgname = g_strdup (prgname);
1108   G_UNLOCK (g_prgname);
1109 }
1110 
1111 G_LOCK_DEFINE_STATIC (g_application_name);
1112 static gchar *g_application_name = NULL;
1113 
1114 /**
1115  * g_get_application_name:
1116  *
1117  * Gets a human-readable name for the application, as set by
1118  * g_set_application_name(). This name should be localized if
1119  * possible, and is intended for display to the user.  Contrast with
1120  * g_get_prgname(), which gets a non-localized name. If
1121  * g_set_application_name() has not been called, returns the result of
1122  * g_get_prgname() (which may be %NULL if g_set_prgname() has also not
1123  * been called).
1124  *
1125  * Returns: human-readable application name. may return %NULL
1126  *
1127  * Since: 2.2
1128  **/
1129 const gchar *
1130 g_get_application_name (void)
1131 {
1132   gchar* retval;
1133 
1134   G_LOCK (g_application_name);
1135   retval = g_application_name;
1136   G_UNLOCK (g_application_name);
1137 
1138   if (retval == NULL)
1139     return g_get_prgname ();
1140 
1141   return retval;
1142 }
1143 
1144 /**
1145  * g_set_application_name:
1146  * @application_name: localized name of the application
1147  *
1148  * Sets a human-readable name for the application. This name should be
1149  * localized if possible, and is intended for display to the user.
1150  * Contrast with g_set_prgname(), which sets a non-localized name.
1151  * g_set_prgname() will be called automatically by gtk_init(),
1152  * but g_set_application_name() will not.
1153  *
1154  * Note that for thread safety reasons, this function can only
1155  * be called once.
1156  *
1157  * The application name will be used in contexts such as error messages,
1158  * or when displaying an application&#39;s name in the task list.
1159  *
1160  * Since: 2.2
1161  **/
1162 void
1163 g_set_application_name (const gchar *application_name)
1164 {
1165   gboolean already_set = FALSE;
1166 
1167   G_LOCK (g_application_name);
1168   if (g_application_name)
1169     already_set = TRUE;
1170   else
1171     g_application_name = g_strdup (application_name);
1172   G_UNLOCK (g_application_name);
1173 
1174   if (already_set)
1175     g_warning (&quot;g_set_application_name() called multiple times&quot;);
1176 }
1177 
1178 /**
1179  * g_get_user_data_dir:
1180  *
1181  * Returns a base directory in which to access application data such
1182  * as icons that is customized for a particular user.
1183  *
1184  * On UNIX platforms this is determined using the mechanisms described
1185  * in the
1186  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1187  * In this case the directory retrieved will be `XDG_DATA_HOME`.
1188  *
1189  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME`
1190  * is defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
1191  * opposed to roaming) application data is used instead. See the
1192  * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
1193  * Note that in this case on Windows it will be the same
1194  * as what g_get_user_config_dir() returns.
1195  *
1196  * Returns: (type filename): a string owned by GLib that must not be modified
1197  *               or freed.
1198  * Since: 2.6
1199  **/
1200 const gchar *
1201 g_get_user_data_dir (void)
1202 {
1203   gchar *data_dir = NULL;
1204 
1205   G_LOCK (g_utils_global);
1206 
1207   if (!g_user_data_dir)
1208     {
1209       const gchar *data_dir_env = g_getenv (&quot;XDG_DATA_HOME&quot;);
1210 
1211       if (data_dir_env &amp;&amp; data_dir_env[0])
1212         data_dir = g_strdup (data_dir_env);
1213 #ifdef G_OS_WIN32
1214       else
1215       data_dir = get_special_folder (CSIDL_LOCAL_APPDATA);
1216 #endif
1217       if (!data_dir || !data_dir[0])
1218     {
1219           const gchar *home_dir = g_get_home_dir ();
1220 
1221           if (home_dir)
1222             data_dir = g_build_filename (home_dir, &quot;.local&quot;, &quot;share&quot;, NULL);
1223       else
1224             data_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), &quot;.local&quot;, &quot;share&quot;, NULL);
1225     }
1226 
1227       g_user_data_dir = data_dir;
1228     }
1229   else
1230     data_dir = g_user_data_dir;
1231 
1232   G_UNLOCK (g_utils_global);
1233 
1234   return data_dir;
1235 }
1236 
1237 static void
1238 g_init_user_config_dir (void)
1239 {
1240   gchar *config_dir = NULL;
1241 
1242   if (!g_user_config_dir)
1243     {
1244       const gchar *config_dir_env = g_getenv (&quot;XDG_CONFIG_HOME&quot;);
1245 
1246       if (config_dir_env &amp;&amp; config_dir_env[0])
1247     config_dir = g_strdup (config_dir_env);
1248 #ifdef G_OS_WIN32
1249       else
1250       config_dir = get_special_folder (CSIDL_LOCAL_APPDATA);
1251 #endif
1252       if (!config_dir || !config_dir[0])
1253     {
1254           const gchar *home_dir = g_get_home_dir ();
1255 
1256           if (home_dir)
1257             config_dir = g_build_filename (home_dir, &quot;.config&quot;, NULL);
1258       else
1259             config_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), &quot;.config&quot;, NULL);
1260     }
1261 
1262       g_user_config_dir = config_dir;
1263     }
1264 }
1265 
1266 /**
1267  * g_get_user_config_dir:
1268  *
1269  * Returns a base directory in which to store user-specific application
1270  * configuration information such as user preferences and settings.
1271  *
1272  * On UNIX platforms this is determined using the mechanisms described
1273  * in the
1274  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1275  * In this case the directory retrieved will be `XDG_CONFIG_HOME`.
1276  *
1277  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME` is defined.
1278  * If `XDG_CONFIG_HOME` is undefined, the folder to use for local (as opposed
1279  * to roaming) application data is used instead. See the
1280  * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
1281  * Note that in this case on Windows it will be  the same
1282  * as what g_get_user_data_dir() returns.
1283  *
1284  * Returns: (type filename): a string owned by GLib that must not be modified
1285  *               or freed.
1286  * Since: 2.6
1287  **/
1288 const gchar *
1289 g_get_user_config_dir (void)
1290 {
1291   G_LOCK (g_utils_global);
1292 
1293   g_init_user_config_dir ();
1294 
1295   G_UNLOCK (g_utils_global);
1296 
1297   return g_user_config_dir;
1298 }
1299 
1300 /**
1301  * g_get_user_cache_dir:
1302  *
1303  * Returns a base directory in which to store non-essential, cached
1304  * data specific to particular user.
1305  *
1306  * On UNIX platforms this is determined using the mechanisms described
1307  * in the
1308  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1309  * In this case the directory retrieved will be `XDG_CACHE_HOME`.
1310  *
1311  * On Windows it follows XDG Base Directory Specification if `XDG_CACHE_HOME` is defined.
1312  * If `XDG_CACHE_HOME` is undefined, the directory that serves as a common
1313  * repository for temporary Internet files is used instead. A typical path is
1314  * `C:\Documents and Settings\username\Local Settings\Temporary Internet Files`.
1315  * See the [documentation for `CSIDL_INTERNET_CACHE`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_internet_cache).
1316  *
1317  * Returns: (type filename): a string owned by GLib that must not be modified
1318  *               or freed.
1319  * Since: 2.6
1320  **/
1321 const gchar *
1322 g_get_user_cache_dir (void)
1323 {
1324   gchar *cache_dir = NULL;
1325 
1326   G_LOCK (g_utils_global);
1327 
1328   if (!g_user_cache_dir)
1329     {
1330       const gchar *cache_dir_env = g_getenv (&quot;XDG_CACHE_HOME&quot;);
1331 
1332       if (cache_dir_env &amp;&amp; cache_dir_env[0])
1333         cache_dir = g_strdup (cache_dir_env);
1334 #ifdef G_OS_WIN32
1335       else
1336         cache_dir = get_special_folder (CSIDL_INTERNET_CACHE);
1337 #endif
1338       if (!cache_dir || !cache_dir[0])
1339     {
1340           const gchar *home_dir = g_get_home_dir ();
1341 
1342           if (home_dir)
1343             cache_dir = g_build_filename (home_dir, &quot;.cache&quot;, NULL);
1344       else
1345             cache_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), &quot;.cache&quot;, NULL);
1346     }
1347       g_user_cache_dir = cache_dir;
1348     }
1349   else
1350     cache_dir = g_user_cache_dir;
1351 
1352   G_UNLOCK (g_utils_global);
1353 
1354   return cache_dir;
1355 }
1356 
1357 /**
1358  * g_get_user_runtime_dir:
1359  *
1360  * Returns a directory that is unique to the current user on the local
1361  * system.
1362  *
1363  * This is determined using the mechanisms described
1364  * in the
1365  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1366  * This is the directory
1367  * specified in the `XDG_RUNTIME_DIR` environment variable.
1368  * In the case that this variable is not set, we return the value of
1369  * g_get_user_cache_dir(), after verifying that it exists.
1370  *
1371  * Returns: (type filename): a string owned by GLib that must not be
1372  *     modified or freed.
1373  *
1374  * Since: 2.28
1375  **/
1376 const gchar *
1377 g_get_user_runtime_dir (void)
1378 {
1379   static const gchar *runtime_dir;
1380 
1381   if (g_once_init_enter (&amp;runtime_dir))
1382     {
1383       const gchar *dir;
1384 
1385       dir = g_strdup (getenv (&quot;XDG_RUNTIME_DIR&quot;));
1386 
1387       if (dir == NULL)
1388         {
1389           /* No need to strdup this one since it is valid forever. */
1390           dir = g_get_user_cache_dir ();
1391 
1392           /* The user should be able to rely on the directory existing
1393            * when the function returns.  Probably it already does, but
1394            * let&#39;s make sure.  Just do mkdir() directly since it will be
1395            * no more expensive than a stat() in the case that the
1396            * directory already exists and is a lot easier.
1397            *
1398            * $XDG_CACHE_HOME is probably ~/.cache/ so as long as $HOME
1399            * exists this will work.  If the user changed $XDG_CACHE_HOME
1400            * then they can make sure that it exists...
1401    */
1402           (void) g_mkdir (dir, 0700);
1403         }
1404 
1405       g_assert (dir != NULL);
1406 
1407       g_once_init_leave (&amp;runtime_dir, dir);
1408 }
1409 
1410   return runtime_dir;
1411 }
1412 
1413 #ifdef HAVE_CARBON
1414 
1415 static gchar *
1416 find_folder (OSType type)
1417 {
1418   gchar *filename = NULL;
1419   FSRef  found;
1420 
1421   if (FSFindFolder (kUserDomain, type, kDontCreateFolder, &amp;found) == noErr)
1422     {
1423       CFURLRef url = CFURLCreateFromFSRef (kCFAllocatorSystemDefault, &amp;found);
1424 
1425       if (url)
1426     {
1427       CFStringRef path = CFURLCopyFileSystemPath (url, kCFURLPOSIXPathStyle);
1428 
1429       if (path)
1430         {
1431           filename = g_strdup (CFStringGetCStringPtr (path, kCFStringEncodingUTF8));
1432 
1433           if (! filename)
1434         {
1435           filename = g_new0 (gchar, CFStringGetLength (path) * 3 + 1);
1436 
1437           CFStringGetCString (path, filename,
1438                       CFStringGetLength (path) * 3 + 1,
1439                       kCFStringEncodingUTF8);
1440         }
1441 
1442           CFRelease (path);
1443         }
1444 
1445       CFRelease (url);
1446     }
1447     }
1448 
1449   return filename;
1450 }
1451 
1452 static void
1453 load_user_special_dirs (void)
1454 {
1455   g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = find_folder (kDesktopFolderType);
1456   g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = find_folder (kDocumentsFolderType);
1457   g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = find_folder (kDesktopFolderType); /* XXX correct ? */
1458   g_user_special_dirs[G_USER_DIRECTORY_MUSIC] = find_folder (kMusicDocumentsFolderType);
1459   g_user_special_dirs[G_USER_DIRECTORY_PICTURES] = find_folder (kPictureDocumentsFolderType);
1460   g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = NULL;
1461   g_user_special_dirs[G_USER_DIRECTORY_TEMPLATES] = NULL;
1462   g_user_special_dirs[G_USER_DIRECTORY_VIDEOS] = find_folder (kMovieDocumentsFolderType);
1463 }
1464 
1465 #elif defined(G_OS_WIN32)
1466 
1467 static void
1468 load_user_special_dirs (void)
1469 {
1470   typedef HRESULT (WINAPI *t_SHGetKnownFolderPath) (const GUID *rfid,
1471                             DWORD dwFlags,
1472                             HANDLE hToken,
1473                             PWSTR *ppszPath);
1474   t_SHGetKnownFolderPath p_SHGetKnownFolderPath;
1475 
1476   static const GUID FOLDERID_Downloads =
1477     { 0x374de290, 0x123f, 0x4565, { 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b } };
1478   static const GUID FOLDERID_Public =
1479     { 0xDFDF76A2, 0xC82A, 0x4D63, { 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85 } };
1480 
1481   wchar_t *wcp;
1482 
1483   p_SHGetKnownFolderPath = (t_SHGetKnownFolderPath) GetProcAddress (GetModuleHandle (&quot;shell32.dll&quot;),
1484                                     &quot;SHGetKnownFolderPath&quot;);
1485 
1486   g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1487   g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = get_special_folder (CSIDL_PERSONAL);
1488 
1489   if (p_SHGetKnownFolderPath == NULL)
1490     {
1491       g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1492     }
1493   else
1494     {
1495       wcp = NULL;
1496       (*p_SHGetKnownFolderPath) (&amp;FOLDERID_Downloads, 0, NULL, &amp;wcp);
1497       if (wcp)
1498         {
1499           g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
1500           if (g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] == NULL)
1501               g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1502           CoTaskMemFree (wcp);
1503         }
1504       else
1505           g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1506     }
1507 
1508   g_user_special_dirs[G_USER_DIRECTORY_MUSIC] = get_special_folder (CSIDL_MYMUSIC);
1509   g_user_special_dirs[G_USER_DIRECTORY_PICTURES] = get_special_folder (CSIDL_MYPICTURES);
1510 
1511   if (p_SHGetKnownFolderPath == NULL)
1512     {
1513       /* XXX */
1514       g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1515     }
1516   else
1517     {
1518       wcp = NULL;
1519       (*p_SHGetKnownFolderPath) (&amp;FOLDERID_Public, 0, NULL, &amp;wcp);
1520       if (wcp)
1521         {
1522           g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
1523           if (g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] == NULL)
1524               g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1525           CoTaskMemFree (wcp);
1526         }
1527       else
1528           g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1529     }
1530 
1531   g_user_special_dirs[G_USER_DIRECTORY_TEMPLATES] = get_special_folder (CSIDL_TEMPLATES);
1532   g_user_special_dirs[G_USER_DIRECTORY_VIDEOS] = get_special_folder (CSIDL_MYVIDEO);
1533 }
1534 
1535 #else /* default is unix */
1536 
1537 /* adapted from xdg-user-dir-lookup.c
1538  *
1539  * Copyright (C) 2007 Red Hat Inc.
1540  *
1541  * Permission is hereby granted, free of charge, to any person
1542  * obtaining a copy of this software and associated documentation files
1543  * (the &quot;Software&quot;), to deal in the Software without restriction,
1544  * including without limitation the rights to use, copy, modify, merge,
1545  * publish, distribute, sublicense, and/or sell copies of the Software,
1546  * and to permit persons to whom the Software is furnished to do so,
1547  * subject to the following conditions:
1548  *
1549  * The above copyright notice and this permission notice shall be
1550  * included in all copies or substantial portions of the Software.
1551  *
1552  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
1553  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
1554  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
1555  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
1556  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
1557  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
1558  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
1559  * SOFTWARE.
1560  */
1561 static void
1562 load_user_special_dirs (void)
1563 {
1564   gchar *config_file;
1565   gchar *data;
1566   gchar **lines;
1567   gint n_lines, i;
1568 
1569   g_init_user_config_dir ();
1570   config_file = g_build_filename (g_user_config_dir,
1571                                   &quot;user-dirs.dirs&quot;,
1572                                   NULL);
1573 
1574   if (!g_file_get_contents (config_file, &amp;data, NULL, NULL))
1575     {
1576       g_free (config_file);
1577       return;
1578     }
1579 
1580   lines = g_strsplit (data, &quot;\n&quot;, -1);
1581   n_lines = g_strv_length (lines);
1582   g_free (data);
1583 
1584   for (i = 0; i &lt; n_lines; i++)
1585     {
1586       gchar *buffer = lines[i];
1587       gchar *d, *p;
1588       gint len;
1589       gboolean is_relative = FALSE;
1590       GUserDirectory directory;
1591 
1592       /* Remove newline at end */
1593       len = strlen (buffer);
1594       if (len &gt; 0 &amp;&amp; buffer[len - 1] == &#39;\n&#39;)
1595     buffer[len - 1] = 0;
1596 
1597       p = buffer;
1598       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
1599     p++;
1600 
1601       if (strncmp (p, &quot;XDG_DESKTOP_DIR&quot;, strlen (&quot;XDG_DESKTOP_DIR&quot;)) == 0)
1602         {
1603           directory = G_USER_DIRECTORY_DESKTOP;
1604           p += strlen (&quot;XDG_DESKTOP_DIR&quot;);
1605         }
1606       else if (strncmp (p, &quot;XDG_DOCUMENTS_DIR&quot;, strlen (&quot;XDG_DOCUMENTS_DIR&quot;)) == 0)
1607         {
1608           directory = G_USER_DIRECTORY_DOCUMENTS;
1609           p += strlen (&quot;XDG_DOCUMENTS_DIR&quot;);
1610         }
1611       else if (strncmp (p, &quot;XDG_DOWNLOAD_DIR&quot;, strlen (&quot;XDG_DOWNLOAD_DIR&quot;)) == 0)
1612         {
1613           directory = G_USER_DIRECTORY_DOWNLOAD;
1614           p += strlen (&quot;XDG_DOWNLOAD_DIR&quot;);
1615         }
1616       else if (strncmp (p, &quot;XDG_MUSIC_DIR&quot;, strlen (&quot;XDG_MUSIC_DIR&quot;)) == 0)
1617         {
1618           directory = G_USER_DIRECTORY_MUSIC;
1619           p += strlen (&quot;XDG_MUSIC_DIR&quot;);
1620         }
1621       else if (strncmp (p, &quot;XDG_PICTURES_DIR&quot;, strlen (&quot;XDG_PICTURES_DIR&quot;)) == 0)
1622         {
1623           directory = G_USER_DIRECTORY_PICTURES;
1624           p += strlen (&quot;XDG_PICTURES_DIR&quot;);
1625         }
1626       else if (strncmp (p, &quot;XDG_PUBLICSHARE_DIR&quot;, strlen (&quot;XDG_PUBLICSHARE_DIR&quot;)) == 0)
1627         {
1628           directory = G_USER_DIRECTORY_PUBLIC_SHARE;
1629           p += strlen (&quot;XDG_PUBLICSHARE_DIR&quot;);
1630         }
1631       else if (strncmp (p, &quot;XDG_TEMPLATES_DIR&quot;, strlen (&quot;XDG_TEMPLATES_DIR&quot;)) == 0)
1632         {
1633           directory = G_USER_DIRECTORY_TEMPLATES;
1634           p += strlen (&quot;XDG_TEMPLATES_DIR&quot;);
1635         }
1636       else if (strncmp (p, &quot;XDG_VIDEOS_DIR&quot;, strlen (&quot;XDG_VIDEOS_DIR&quot;)) == 0)
1637         {
1638           directory = G_USER_DIRECTORY_VIDEOS;
1639           p += strlen (&quot;XDG_VIDEOS_DIR&quot;);
1640         }
1641       else
1642     continue;
1643 
1644       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
1645     p++;
1646 
1647       if (*p != &#39;=&#39;)
1648     continue;
1649       p++;
1650 
1651       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
1652     p++;
1653 
1654       if (*p != &#39;&quot;&#39;)
1655     continue;
1656       p++;
1657 
1658       if (strncmp (p, &quot;$HOME&quot;, 5) == 0)
1659     {
1660       p += 5;
1661       is_relative = TRUE;
1662     }
1663       else if (*p != &#39;/&#39;)
1664     continue;
1665 
1666       d = strrchr (p, &#39;&quot;&#39;);
1667       if (!d)
1668         continue;
1669       *d = 0;
1670 
1671       d = p;
1672 
1673       /* remove trailing slashes */
1674       len = strlen (d);
1675       if (d[len - 1] == &#39;/&#39;)
1676         d[len - 1] = 0;
1677 
1678       if (is_relative)
1679         {
1680           g_user_special_dirs[directory] = g_build_filename (g_get_home_dir (), d, NULL);
1681         }
1682       else
1683     g_user_special_dirs[directory] = g_strdup (d);
1684     }
1685 
1686   g_strfreev (lines);
1687   g_free (config_file);
1688 }
1689 
1690 #endif /* platform-specific load_user_special_dirs implementations */
1691 
1692 
1693 /**
1694  * g_reload_user_special_dirs_cache:
1695  *
1696  * Resets the cache used for g_get_user_special_dir(), so
1697  * that the latest on-disk version is used. Call this only
1698  * if you just changed the data on disk yourself.
1699  *
1700  * Due to threadsafety issues this may cause leaking of strings
1701  * that were previously returned from g_get_user_special_dir()
1702  * that can&#39;t be freed. We ensure to only leak the data for
1703  * the directories that actually changed value though.
1704  *
1705  * Since: 2.22
1706  */
1707 void
1708 g_reload_user_special_dirs_cache (void)
1709 {
1710   int i;
1711 
1712   G_LOCK (g_utils_global);
1713 
1714   if (g_user_special_dirs != NULL)
1715     {
1716       /* save a copy of the pointer, to check if some memory can be preserved */
1717       char **old_g_user_special_dirs = g_user_special_dirs;
1718       char *old_val;
1719 
1720       /* recreate and reload our cache */
1721       g_user_special_dirs = g_new0 (gchar *, G_USER_N_DIRECTORIES);
1722       load_user_special_dirs ();
1723 
1724       /* only leak changed directories */
1725       for (i = 0; i &lt; G_USER_N_DIRECTORIES; i++)
1726         {
1727           old_val = old_g_user_special_dirs[i];
1728           if (g_user_special_dirs[i] == NULL)
1729             {
1730               g_user_special_dirs[i] = old_val;
1731             }
1732           else if (g_strcmp0 (old_val, g_user_special_dirs[i]) == 0)
1733             {
1734               /* don&#39;t leak */
1735               g_free (g_user_special_dirs[i]);
1736               g_user_special_dirs[i] = old_val;
1737             }
1738           else
1739             g_free (old_val);
1740         }
1741 
1742       /* free the old array */
1743       g_free (old_g_user_special_dirs);
1744     }
1745 
1746   G_UNLOCK (g_utils_global);
1747 }
1748 
1749 /**
1750  * g_get_user_special_dir:
1751  * @directory: the logical id of special directory
1752  *
1753  * Returns the full path of a special directory using its logical id.
1754  *
1755  * On UNIX this is done using the XDG special user directories.
1756  * For compatibility with existing practise, %G_USER_DIRECTORY_DESKTOP
1757  * falls back to `$HOME/Desktop` when XDG special user directories have
1758  * not been set up.
1759  *
1760  * Depending on the platform, the user might be able to change the path
1761  * of the special directory without requiring the session to restart; GLib
1762  * will not reflect any change once the special directories are loaded.
1763  *
1764  * Returns: (type filename): the path to the specified special directory, or
1765  *   %NULL if the logical id was not found. The returned string is owned by
1766  *   GLib and should not be modified or freed.
1767  *
1768  * Since: 2.14
1769  */
1770 const gchar *
1771 g_get_user_special_dir (GUserDirectory directory)
1772 {
1773   g_return_val_if_fail (directory &gt;= G_USER_DIRECTORY_DESKTOP &amp;&amp;
1774                         directory &lt; G_USER_N_DIRECTORIES, NULL);
1775 
1776   G_LOCK (g_utils_global);
1777 
1778   if (G_UNLIKELY (g_user_special_dirs == NULL))
1779     {
1780       g_user_special_dirs = g_new0 (gchar *, G_USER_N_DIRECTORIES);
1781 
1782       load_user_special_dirs ();
1783 
1784       /* Special-case desktop for historical compatibility */
1785       if (g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] == NULL)
1786         g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = g_build_filename (g_get_home_dir (), &quot;Desktop&quot;, NULL);
1787     }
1788 
1789   G_UNLOCK (g_utils_global);
1790 
1791   return g_user_special_dirs[directory];
1792 }
1793 
1794 #ifdef G_OS_WIN32
1795 
1796 #undef g_get_system_data_dirs
1797 
1798 static HMODULE
1799 get_module_for_address (gconstpointer address)
1800 {
1801   /* Holds the g_utils_global lock */
1802 
1803   static gboolean beenhere = FALSE;
1804   typedef BOOL (WINAPI *t_GetModuleHandleExA) (DWORD, LPCTSTR, HMODULE *);
1805   static t_GetModuleHandleExA p_GetModuleHandleExA = NULL;
1806   HMODULE hmodule = NULL;
1807 
1808   if (!address)
1809     return NULL;
1810 
1811   if (!beenhere)
1812     {
1813       p_GetModuleHandleExA =
1814     (t_GetModuleHandleExA) GetProcAddress (GetModuleHandle (&quot;kernel32.dll&quot;),
1815                            &quot;GetModuleHandleExA&quot;);
1816       beenhere = TRUE;
1817     }
1818 
1819   if (p_GetModuleHandleExA == NULL ||
1820       !(*p_GetModuleHandleExA) (GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT |
1821                 GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
1822                 address, &amp;hmodule))
1823     {
1824       MEMORY_BASIC_INFORMATION mbi;
1825       VirtualQuery (address, &amp;mbi, sizeof (mbi));
1826       hmodule = (HMODULE) mbi.AllocationBase;
1827     }
1828 
1829   return hmodule;
1830 }
1831 
1832 static gchar *
1833 get_module_share_dir (gconstpointer address)
1834 {
1835   HMODULE hmodule;
1836   gchar *filename;
1837   gchar *retval;
1838 
1839   hmodule = get_module_for_address (address);
1840   if (hmodule == NULL)
1841     return NULL;
1842 
1843   filename = g_win32_get_package_installation_directory_of_module (hmodule);
1844   retval = g_build_filename (filename, &quot;share&quot;, NULL);
1845   g_free (filename);
1846 
1847   return retval;
1848 }
1849 
1850 static const gchar * const *
1851 g_win32_get_system_data_dirs_for_module_real (void (*address_of_function)(void))
1852 {
1853   GArray *data_dirs;
1854   HMODULE hmodule;
1855   static GHashTable *per_module_data_dirs = NULL;
1856   gchar **retval;
1857   gchar *p;
1858   gchar *exe_root;
1859 
1860   hmodule = NULL;
1861   if (address_of_function)
1862     {
1863       G_LOCK (g_utils_global);
1864       hmodule = get_module_for_address (address_of_function);
1865       if (hmodule != NULL)
1866     {
1867       if (per_module_data_dirs == NULL)
1868         per_module_data_dirs = g_hash_table_new (NULL, NULL);
1869       else
1870         {
1871           retval = g_hash_table_lookup (per_module_data_dirs, hmodule);
1872 
1873           if (retval != NULL)
1874         {
1875           G_UNLOCK (g_utils_global);
1876           return (const gchar * const *) retval;
1877         }
1878         }
1879     }
1880     }
1881 
1882   data_dirs = g_array_new (TRUE, TRUE, sizeof (char *));
1883 
1884   /* Documents and Settings\All Users\Application Data */
1885   p = get_special_folder (CSIDL_COMMON_APPDATA);
1886   if (p)
1887     g_array_append_val (data_dirs, p);
1888 
1889   /* Documents and Settings\All Users\Documents */
1890   p = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1891   if (p)
1892     g_array_append_val (data_dirs, p);
1893 
1894   /* Using the above subfolders of Documents and Settings perhaps
1895    * makes sense from a Windows perspective.
1896    *
1897    * But looking at the actual use cases of this function in GTK+
1898    * and GNOME software, what we really want is the &quot;share&quot;
1899    * subdirectory of the installation directory for the package
1900    * our caller is a part of.
1901    *
1902    * The address_of_function parameter, if non-NULL, points to a
1903    * function in the calling module. Use that to determine that
1904    * module&#39;s installation folder, and use its &quot;share&quot; subfolder.
1905    *
1906    * Additionally, also use the &quot;share&quot; subfolder of the installation
1907    * locations of GLib and the .exe file being run.
1908    *
1909    * To guard against none of the above being what is really wanted,
1910    * callers of this function should have Win32-specific code to look
1911    * up their installation folder themselves, and handle a subfolder
1912    * &quot;share&quot; of it in the same way as the folders returned from this
1913    * function.
1914    */
1915 
1916   p = get_module_share_dir (address_of_function);
1917   if (p)
1918     g_array_append_val (data_dirs, p);
1919 
1920   if (glib_dll != NULL)
1921     {
1922       gchar *glib_root = g_win32_get_package_installation_directory_of_module (glib_dll);
1923       p = g_build_filename (glib_root, &quot;share&quot;, NULL);
1924       if (p)
1925     g_array_append_val (data_dirs, p);
1926       g_free (glib_root);
1927     }
1928 
1929   exe_root = g_win32_get_package_installation_directory_of_module (NULL);
1930   p = g_build_filename (exe_root, &quot;share&quot;, NULL);
1931   if (p)
1932     g_array_append_val (data_dirs, p);
1933   g_free (exe_root);
1934 
1935   retval = (gchar **) g_array_free (data_dirs, FALSE);
1936 
1937   if (address_of_function)
1938     {
1939       if (hmodule != NULL)
1940     g_hash_table_insert (per_module_data_dirs, hmodule, retval);
1941       G_UNLOCK (g_utils_global);
1942     }
1943 
1944   return (const gchar * const *) retval;
1945 }
1946 
1947 const gchar * const *
1948 g_win32_get_system_data_dirs_for_module (void (*address_of_function)(void))
1949 {
1950   gboolean should_call_g_get_system_data_dirs;
1951 
1952   should_call_g_get_system_data_dirs = TRUE;
1953   /* These checks are the same as the ones that g_get_system_data_dirs() does.
1954    * Please keep them in sync.
1955    */
1956   G_LOCK (g_utils_global);
1957 
1958   if (!g_system_data_dirs)
1959     {
1960       const gchar *data_dirs = g_getenv (&quot;XDG_DATA_DIRS&quot;);
1961 
1962       if (!data_dirs || !data_dirs[0])
1963         should_call_g_get_system_data_dirs = FALSE;
1964     }
1965 
1966   G_UNLOCK (g_utils_global);
1967 
1968   /* There is a subtle difference between g_win32_get_system_data_dirs_for_module (NULL),
1969    * which is what GLib code can normally call,
1970    * and g_win32_get_system_data_dirs_for_module (&amp;_g_win32_get_system_data_dirs),
1971    * which is what the inline function used by non-GLib code calls.
1972    * The former gets prefix relative to currently-running executable,
1973    * the latter - relative to the module that calls _g_win32_get_system_data_dirs()
1974    * (disguised as g_get_system_data_dirs()), which could be an executable or
1975    * a DLL that is located somewhere else.
1976    * This is why that inline function in gutils.h exists, and why we can&#39;t just
1977    * call g_get_system_data_dirs() from there - because we need to get the address
1978    * local to the non-GLib caller-module.
1979    */
1980 
1981   /*
1982    * g_get_system_data_dirs() will fall back to calling
1983    * g_win32_get_system_data_dirs_for_module_real(NULL) if XDG_DATA_DIRS is NULL
1984    * or an empty string. The checks above ensure that we do not call it in such
1985    * cases and use the address_of_function that we&#39;ve been given by the inline function.
1986    * The reason we&#39;re calling g_get_system_data_dirs /at all/ is to give
1987    * XDG_DATA_DIRS precedence (if it is set).
1988    */
1989   if (should_call_g_get_system_data_dirs)
1990     return g_get_system_data_dirs ();
1991 
1992   return g_win32_get_system_data_dirs_for_module_real (address_of_function);
1993 }
1994 
1995 #endif
1996 
1997 /**
1998  * g_get_system_data_dirs:
1999  *
2000  * Returns an ordered list of base directories in which to access
2001  * system-wide application data.
2002  *
2003  * On UNIX platforms this is determined using the mechanisms described
2004  * in the
2005  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec)
2006  * In this case the list of directories retrieved will be `XDG_DATA_DIRS`.
2007  *
2008  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_DIRS` is defined.
2009  * If `XDG_DATA_DIRS` is undefined,
2010  * the first elements in the list are the Application Data
2011  * and Documents folders for All Users. (These can be determined only
2012  * on Windows 2000 or later and are not present in the list on other
2013  * Windows versions.) See documentation for CSIDL_COMMON_APPDATA and
2014  * CSIDL_COMMON_DOCUMENTS.
2015  *
2016  * Then follows the &quot;share&quot; subfolder in the installation folder for
2017  * the package containing the DLL that calls this function, if it can
2018  * be determined.
2019  *
2020  * Finally the list contains the &quot;share&quot; subfolder in the installation
2021  * folder for GLib, and in the installation folder for the package the
2022  * application&#39;s .exe file belongs to.
2023  *
2024  * The installation folders above are determined by looking up the
2025  * folder where the module (DLL or EXE) in question is located. If the
2026  * folder&#39;s name is &quot;bin&quot;, its parent is used, otherwise the folder
2027  * itself.
2028  *
2029  * Note that on Windows the returned list can vary depending on where
2030  * this function is called.
2031  *
2032  * Returns: (array zero-terminated=1) (element-type filename) (transfer none):
2033  *     a %NULL-terminated array of strings owned by GLib that must not be
2034  *     modified or freed.
2035  *
2036  * Since: 2.6
2037  **/
2038 const gchar * const *
2039 g_get_system_data_dirs (void)
2040 {
2041   gchar **data_dir_vector;
2042 
2043   /* These checks are the same as the ones that g_win32_get_system_data_dirs_for_module()
2044    * does. Please keep them in sync.
2045    */
2046   G_LOCK (g_utils_global);
2047 
2048   if (!g_system_data_dirs)
2049     {
2050       gchar *data_dirs = (gchar *) g_getenv (&quot;XDG_DATA_DIRS&quot;);
2051 
2052 #ifndef G_OS_WIN32
2053       if (!data_dirs || !data_dirs[0])
2054           data_dirs = &quot;/usr/local/share/:/usr/share/&quot;;
2055 
2056       data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
2057 #else
2058       if (!data_dirs || !data_dirs[0])
2059         data_dir_vector = g_strdupv ((gchar **) g_win32_get_system_data_dirs_for_module_real (NULL));
2060       else
2061         data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
2062 #endif
2063 
2064       g_system_data_dirs = data_dir_vector;
2065     }
2066   else
2067     data_dir_vector = g_system_data_dirs;
2068 
2069   G_UNLOCK (g_utils_global);
2070 
2071   return (const gchar * const *) data_dir_vector;
2072 }
2073 
2074 /**
2075  * g_get_system_config_dirs:
2076  *
2077  * Returns an ordered list of base directories in which to access
2078  * system-wide configuration information.
2079  *
2080  * On UNIX platforms this is determined using the mechanisms described
2081  * in the
2082  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
2083  * In this case the list of directories retrieved will be `XDG_CONFIG_DIRS`.
2084  *
2085  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_DIRS` is defined.
2086  * If `XDG_CONFIG_DIRS` is undefined, the directory that contains application
2087  * data for all users is used instead. A typical path is
2088  * `C:\Documents and Settings\All Users\Application Data`.
2089  * This folder is used for application data
2090  * that is not user specific. For example, an application can store
2091  * a spell-check dictionary, a database of clip art, or a log file in the
2092  * CSIDL_COMMON_APPDATA folder. This information will not roam and is available
2093  * to anyone using the computer.
2094  *
2095  * Returns: (array zero-terminated=1) (element-type filename) (transfer none):
2096  *     a %NULL-terminated array of strings owned by GLib that must not be
2097  *     modified or freed.
2098  *
2099  * Since: 2.6
2100  **/
2101 const gchar * const *
2102 g_get_system_config_dirs (void)
2103 {
2104   gchar **conf_dir_vector;
2105 
2106   G_LOCK (g_utils_global);
2107 
2108   if (!g_system_config_dirs)
2109     {
2110       const gchar *conf_dirs = g_getenv (&quot;XDG_CONFIG_DIRS&quot;);
2111 #ifdef G_OS_WIN32
2112       if (conf_dirs)
2113     {
2114       conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
2115     }
2116       else
2117     {
2118       gchar *special_conf_dirs = get_special_folder (CSIDL_COMMON_APPDATA);
2119 
2120       if (special_conf_dirs)
2121         conf_dir_vector = g_strsplit (special_conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
2122       else
2123       /* Return empty list */
2124       conf_dir_vector = g_strsplit (&quot;&quot;, G_SEARCHPATH_SEPARATOR_S, 0);
2125 
2126       g_free (special_conf_dirs);
2127     }
2128 #else
2129       if (!conf_dirs || !conf_dirs[0])
2130           conf_dirs = &quot;/etc/xdg&quot;;
2131 
2132       conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
2133 #endif
2134 
2135       g_system_config_dirs = conf_dir_vector;
2136     }
2137   else
2138     conf_dir_vector = g_system_config_dirs;
2139   G_UNLOCK (g_utils_global);
2140 
2141   return (const gchar * const *) conf_dir_vector;
2142 }
2143 
2144 /**
2145  * g_nullify_pointer:
2146  * @nullify_location: (not nullable): the memory address of the pointer.
2147  *
2148  * Set the pointer at the specified location to %NULL.
2149  **/
2150 void
2151 g_nullify_pointer (gpointer *nullify_location)
2152 {
2153   g_return_if_fail (nullify_location != NULL);
2154 
2155   *nullify_location = NULL;
2156 }
2157 
2158 #define KILOBYTE_FACTOR (G_GOFFSET_CONSTANT (1000))
2159 #define MEGABYTE_FACTOR (KILOBYTE_FACTOR * KILOBYTE_FACTOR)
2160 #define GIGABYTE_FACTOR (MEGABYTE_FACTOR * KILOBYTE_FACTOR)
2161 #define TERABYTE_FACTOR (GIGABYTE_FACTOR * KILOBYTE_FACTOR)
2162 #define PETABYTE_FACTOR (TERABYTE_FACTOR * KILOBYTE_FACTOR)
2163 #define EXABYTE_FACTOR  (PETABYTE_FACTOR * KILOBYTE_FACTOR)
2164 
2165 #define KIBIBYTE_FACTOR (G_GOFFSET_CONSTANT (1024))
2166 #define MEBIBYTE_FACTOR (KIBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2167 #define GIBIBYTE_FACTOR (MEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2168 #define TEBIBYTE_FACTOR (GIBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2169 #define PEBIBYTE_FACTOR (TEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2170 #define EXBIBYTE_FACTOR (PEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2171 
2172 /**
2173  * g_format_size:
2174  * @size: a size in bytes
2175  *
2176  * Formats a size (for example the size of a file) into a human readable
2177  * string.  Sizes are rounded to the nearest size prefix (kB, MB, GB)
2178  * and are displayed rounded to the nearest tenth. E.g. the file size
2179  * 3292528 bytes will be converted into the string &quot;3.2 MB&quot;.
2180  *
2181  * The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
2182  *
2183  * This string should be freed with g_free() when not needed any longer.
2184  *
2185  * See g_format_size_full() for more options about how the size might be
2186  * formatted.
2187  *
2188  * Returns: a newly-allocated formatted string containing a human readable
2189  *     file size
2190  *
2191  * Since: 2.30
2192  */
2193 gchar *
2194 g_format_size (guint64 size)
2195 {
2196   return g_format_size_full (size, G_FORMAT_SIZE_DEFAULT);
2197 }
2198 
2199 /**
2200  * GFormatSizeFlags:
2201  * @G_FORMAT_SIZE_DEFAULT: behave the same as g_format_size()
2202  * @G_FORMAT_SIZE_LONG_FORMAT: include the exact number of bytes as part
2203  *     of the returned string.  For example, &quot;45.6 kB (45,612 bytes)&quot;.
2204  * @G_FORMAT_SIZE_IEC_UNITS: use IEC (base 1024) units with &quot;KiB&quot;-style
2205  *     suffixes. IEC units should only be used for reporting things with
2206  *     a strong &quot;power of 2&quot; basis, like RAM sizes or RAID stripe sizes.
2207  *     Network and storage sizes should be reported in the normal SI units.
2208  * @G_FORMAT_SIZE_BITS: set the size as a quantity in bits, rather than
2209  *     bytes, and return units in bits. For example, rather than .
2210  *
2211  * Flags to modify the format of the string returned by g_format_size_full().
2212  */
2213 
2214 #ifdef GSTREAMER_LITE
2215 #ifndef G_OS_WIN32
2216 #pragma GCC diagnostic push
2217 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2218 #endif // G_OS_WIN32
2219 #else // GSTREAMER_LITE
2220 #pragma GCC diagnostic push
2221 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2222 #endif // GSTREAMER_LITE
2223 
2224 /**
2225  * g_format_size_full:
2226  * @size: a size in bytes
2227  * @flags: #GFormatSizeFlags to modify the output
2228  *
2229  * Formats a size.
2230  *
2231  * This function is similar to g_format_size() but allows for flags
2232  * that modify the output. See #GFormatSizeFlags.
2233  *
2234  * Returns: a newly-allocated formatted string containing a human
2235  *     readable file size
2236  *
2237  * Since: 2.30
2238  */
2239 gchar *
2240 g_format_size_full (guint64          size,
2241                     GFormatSizeFlags flags)
2242 {
2243   struct Format
2244   {
2245     guint64 factor;
2246     char string[9];
2247   };
2248 
2249   typedef enum
2250   {
2251     FORMAT_BYTES,
2252     FORMAT_BYTES_IEC,
2253     FORMAT_BITS,
2254     FORMAT_BITS_IEC
2255   } FormatIndex;
2256 
2257   const struct Format formats[4][6] = {
2258     {
2259       { KILOBYTE_FACTOR, N_(&quot;%.1f kB&quot;) },
2260       { MEGABYTE_FACTOR, N_(&quot;%.1f MB&quot;) },
2261       { GIGABYTE_FACTOR, N_(&quot;%.1f GB&quot;) },
2262       { TERABYTE_FACTOR, N_(&quot;%.1f TB&quot;) },
2263       { PETABYTE_FACTOR, N_(&quot;%.1f PB&quot;) },
2264       { EXABYTE_FACTOR,  N_(&quot;%.1f EB&quot;) }
2265     },
2266         {
2267       { KIBIBYTE_FACTOR, N_(&quot;%.1f KiB&quot;) },
2268       { MEBIBYTE_FACTOR, N_(&quot;%.1f MiB&quot;) },
2269       { GIBIBYTE_FACTOR, N_(&quot;%.1f GiB&quot;) },
2270       { TEBIBYTE_FACTOR, N_(&quot;%.1f TiB&quot;) },
2271       { PEBIBYTE_FACTOR, N_(&quot;%.1f PiB&quot;) },
2272       { EXBIBYTE_FACTOR, N_(&quot;%.1f EiB&quot;) }
2273     },
2274     {
2275       { KILOBYTE_FACTOR, N_(&quot;%.1f kb&quot;) },
2276       { MEGABYTE_FACTOR, N_(&quot;%.1f Mb&quot;) },
2277       { GIGABYTE_FACTOR, N_(&quot;%.1f Gb&quot;) },
2278       { TERABYTE_FACTOR, N_(&quot;%.1f Tb&quot;) },
2279       { PETABYTE_FACTOR, N_(&quot;%.1f Pb&quot;) },
2280       { EXABYTE_FACTOR,  N_(&quot;%.1f Eb&quot;) }
2281     },
2282     {
2283       { KIBIBYTE_FACTOR, N_(&quot;%.1f Kib&quot;) },
2284       { MEBIBYTE_FACTOR, N_(&quot;%.1f Mib&quot;) },
2285       { GIBIBYTE_FACTOR, N_(&quot;%.1f Gib&quot;) },
2286       { TEBIBYTE_FACTOR, N_(&quot;%.1f Tib&quot;) },
2287       { PEBIBYTE_FACTOR, N_(&quot;%.1f Pib&quot;) },
2288       { EXBIBYTE_FACTOR, N_(&quot;%.1f Eib&quot;) }
2289         }
2290   };
2291 
2292   GString *string;
2293   FormatIndex index;
2294 
2295   string = g_string_new (NULL);
2296 
2297   switch (flags &amp; ~G_FORMAT_SIZE_LONG_FORMAT)
2298     {
2299     case G_FORMAT_SIZE_DEFAULT:
2300       index = FORMAT_BYTES;
2301       break;
2302     case (G_FORMAT_SIZE_DEFAULT | G_FORMAT_SIZE_IEC_UNITS):
2303       index = FORMAT_BYTES_IEC;
2304       break;
2305     case G_FORMAT_SIZE_BITS:
2306       index = FORMAT_BITS;
2307       break;
2308     case (G_FORMAT_SIZE_BITS | G_FORMAT_SIZE_IEC_UNITS):
2309       index = FORMAT_BITS_IEC;
2310       break;
2311     default:
2312       g_assert_not_reached ();
2313     }
2314 
2315 
2316   if (size &lt; formats[index][0].factor)
2317     {
2318       const char * format;
2319 
2320       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
2321         {
2322           format = g_dngettext (GETTEXT_PACKAGE, &quot;%u byte&quot;, &quot;%u bytes&quot;, (guint) size);
2323     }
2324   else
2325     {
2326           format = g_dngettext (GETTEXT_PACKAGE, &quot;%u bit&quot;, &quot;%u bits&quot;, (guint) size);
2327         }
2328 
2329       g_string_printf (string, format, (guint) size);
2330 
2331       flags &amp;= ~G_FORMAT_SIZE_LONG_FORMAT;
2332     }
2333   else
2334     {
2335       const gsize n = G_N_ELEMENTS (formats[index]);
2336       gsize i;
2337 
2338       /*
2339        * Point the last format (the highest unit) by default
2340        * and then then scan all formats, starting with the 2nd one
2341        * because the 1st is already managed by with the plural form
2342        */
2343       const struct Format * f = &amp;formats[index][n - 1];
2344 
2345       for (i = 1; i &lt; n; i++)
2346         {
2347           if (size &lt; formats[index][i].factor)
2348             {
2349               f = &amp;formats[index][i - 1];
2350               break;
2351             }
2352         }
2353 
2354       g_string_printf (string, _(f-&gt;string), (gdouble) size / (gdouble) f-&gt;factor);
2355     }
2356 
2357   if (flags &amp; G_FORMAT_SIZE_LONG_FORMAT)
2358     {
2359       /* First problem: we need to use the number of bytes to decide on
2360        * the plural form that is used for display, but the number of
2361        * bytes potentially exceeds the size of a guint (which is what
2362        * ngettext() takes).
2363        *
2364        * From a pragmatic standpoint, it seems that all known languages
2365        * base plural forms on one or both of the following:
2366        *
2367        *   - the lowest digits of the number
2368        *
2369        *   - if the number if greater than some small value
2370        *
2371        * Here&#39;s how we fake it:  Draw an arbitrary line at one thousand.
2372        * If the number is below that, then fine.  If it is above it,
2373        * then we take the modulus of the number by one thousand (in
2374        * order to keep the lowest digits) and add one thousand to that
2375        * (in order to ensure that 1001 is not treated the same as 1).
2376        */
2377       guint plural_form = size &lt; 1000 ? size : size % 1000 + 1000;
2378 
2379       /* Second problem: we need to translate the string &quot;%u byte/bit&quot; and
2380        * &quot;%u bytes/bits&quot; for pluralisation, but the correct number format to
2381        * use for a gsize is different depending on which architecture
2382        * we&#39;re on.
2383        *
2384        * Solution: format the number separately and use &quot;%s bytes/bits&quot; on
2385        * all platforms.
2386        */
2387       const gchar *translated_format;
2388       gchar *formatted_number;
2389 
2390       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
2391         {
2392       /* Translators: the %s in &quot;%s bytes&quot; will always be replaced by a number. */
2393           translated_format = g_dngettext (GETTEXT_PACKAGE, &quot;%s byte&quot;, &quot;%s bytes&quot;, plural_form);
2394         }
2395       else
2396         {
2397           /* Translators: the %s in &quot;%s bits&quot; will always be replaced by a number. */
2398           translated_format = g_dngettext (GETTEXT_PACKAGE, &quot;%s bit&quot;, &quot;%s bits&quot;, plural_form);
2399         }
2400       /* XXX: Windows doesn&#39;t support the &quot;&#39;&quot; format modifier, so we
2401        * must not use it there.  Instead, just display the number
2402        * without separation.  Bug #655336 is open until a solution is
2403        * found.
2404        */
2405 #ifndef G_OS_WIN32
2406       formatted_number = g_strdup_printf (&quot;%&#39;&quot;G_GUINT64_FORMAT, size);
2407 #else
2408       formatted_number = g_strdup_printf (&quot;%&quot;G_GUINT64_FORMAT, size);
2409 #endif
2410 
2411       g_string_append (string, &quot; (&quot;);
2412       g_string_append_printf (string, translated_format, formatted_number);
2413       g_free (formatted_number);
2414       g_string_append (string, &quot;)&quot;);
2415     }
2416 
2417   return g_string_free (string, FALSE);
2418 }
2419 
2420 #ifdef GSTREAMER_LITE
2421 #ifndef G_OS_WIN32
2422 #pragma GCC diagnostic pop
2423 #endif // G_OS_WIN32
2424 #else // GSTREAMER_LITE
2425 #pragma GCC diagnostic pop
2426 #endif // GSTREAMER_LITE
2427 
2428 /**
2429  * g_format_size_for_display:
2430  * @size: a size in bytes
2431  *
2432  * Formats a size (for example the size of a file) into a human
2433  * readable string. Sizes are rounded to the nearest size prefix
2434  * (KB, MB, GB) and are displayed rounded to the nearest tenth.
2435  * E.g. the file size 3292528 bytes will be converted into the
2436  * string &quot;3.1 MB&quot;.
2437  *
2438  * The prefix units base is 1024 (i.e. 1 KB is 1024 bytes).
2439  *
2440  * This string should be freed with g_free() when not needed any longer.
2441  *
2442  * Returns: a newly-allocated formatted string containing a human
2443  *     readable file size
2444  *
2445  * Since: 2.16
2446  *
2447  * Deprecated:2.30: This function is broken due to its use of SI
2448  *     suffixes to denote IEC units. Use g_format_size() instead.
2449  */
2450 gchar *
2451 g_format_size_for_display (goffset size)
2452 {
2453   if (size &lt; (goffset) KIBIBYTE_FACTOR)
2454     return g_strdup_printf (g_dngettext(GETTEXT_PACKAGE, &quot;%u byte&quot;, &quot;%u bytes&quot;,(guint) size), (guint) size);
2455   else
2456     {
2457       gdouble displayed_size;
2458 
2459       if (size &lt; (goffset) MEBIBYTE_FACTOR)
2460         {
2461           displayed_size = (gdouble) size / (gdouble) KIBIBYTE_FACTOR;
2462           /* Translators: this is from the deprecated function g_format_size_for_display() which uses &#39;KB&#39; to
2463            * mean 1024 bytes.  I am aware that &#39;KB&#39; is not correct, but it has been preserved for reasons of
2464            * compatibility.  Users will not see this string unless a program is using this deprecated function.
2465            * Please translate as literally as possible.
2466            */
2467           return g_strdup_printf (_(&quot;%.1f KB&quot;), displayed_size);
2468         }
2469       else if (size &lt; (goffset) GIBIBYTE_FACTOR)
2470         {
2471           displayed_size = (gdouble) size / (gdouble) MEBIBYTE_FACTOR;
2472           return g_strdup_printf (_(&quot;%.1f MB&quot;), displayed_size);
2473         }
2474       else if (size &lt; (goffset) TEBIBYTE_FACTOR)
2475         {
2476           displayed_size = (gdouble) size / (gdouble) GIBIBYTE_FACTOR;
2477           return g_strdup_printf (_(&quot;%.1f GB&quot;), displayed_size);
2478         }
2479       else if (size &lt; (goffset) PEBIBYTE_FACTOR)
2480         {
2481           displayed_size = (gdouble) size / (gdouble) TEBIBYTE_FACTOR;
2482           return g_strdup_printf (_(&quot;%.1f TB&quot;), displayed_size);
2483         }
2484       else if (size &lt; (goffset) EXBIBYTE_FACTOR)
2485         {
2486           displayed_size = (gdouble) size / (gdouble) PEBIBYTE_FACTOR;
2487           return g_strdup_printf (_(&quot;%.1f PB&quot;), displayed_size);
2488         }
2489       else
2490         {
2491           displayed_size = (gdouble) size / (gdouble) EXBIBYTE_FACTOR;
2492           return g_strdup_printf (_(&quot;%.1f EB&quot;), displayed_size);
2493         }
2494     }
2495 }
2496 
2497 #if defined (G_OS_WIN32) &amp;&amp; !defined (_WIN64)
2498 
2499 /* Binary compatibility versions. Not for newly compiled code. */
2500 
2501 _GLIB_EXTERN const gchar *g_get_user_name_utf8        (void);
2502 _GLIB_EXTERN const gchar *g_get_real_name_utf8        (void);
2503 _GLIB_EXTERN const gchar *g_get_home_dir_utf8         (void);
2504 _GLIB_EXTERN const gchar *g_get_tmp_dir_utf8          (void);
2505 _GLIB_EXTERN gchar       *g_find_program_in_path_utf8 (const gchar *program);
2506 
2507 gchar *
2508 g_find_program_in_path_utf8 (const gchar *program)
2509 {
2510   return g_find_program_in_path (program);
2511 }
2512 
2513 const gchar *g_get_user_name_utf8 (void) { return g_get_user_name (); }
2514 const gchar *g_get_real_name_utf8 (void) { return g_get_real_name (); }
2515 const gchar *g_get_home_dir_utf8 (void) { return g_get_home_dir (); }
2516 const gchar *g_get_tmp_dir_utf8 (void) { return g_get_tmp_dir (); }
2517 
2518 #endif
2519 
2520 /* Private API:
2521  *
2522  * Returns %TRUE if the current process was executed as setuid
2523  */
2524 gboolean
2525 g_check_setuid (void)
2526 {
2527 #if defined(HAVE_SYS_AUXV_H)
2528   unsigned long value;
2529   int errsv;
2530 
2531   errno = 0;
2532   value = getauxval (AT_SECURE);
2533   errsv = errno;
2534   if (errsv)
2535     g_error (&quot;getauxval () failed: %s&quot;, g_strerror (errsv));
2536   return value;
2537 #elif defined(HAVE_ISSETUGID) &amp;&amp; !defined(__BIONIC__)
2538   /* BSD: http://www.freebsd.org/cgi/man.cgi?query=issetugid&amp;sektion=2 */
2539 
2540   /* Android had it in older versions but the new 64 bit ABI does not
2541    * have it anymore, and some versions of the 32 bit ABI neither.
2542    * https://code.google.com/p/android-developer-preview/issues/detail?id=168
2543    */
2544   return issetugid ();
2545 #elif defined(G_OS_UNIX)
2546   uid_t ruid, euid, suid; /* Real, effective and saved user ID&#39;s */
2547   gid_t rgid, egid, sgid; /* Real, effective and saved group ID&#39;s */
2548 
2549   static gsize check_setuid_initialised;
2550   static gboolean is_setuid;
2551 
2552   if (g_once_init_enter (&amp;check_setuid_initialised))
2553     {
2554 #ifdef HAVE_GETRESUID
2555       /* These aren&#39;t in the header files, so we prototype them here.
2556        */
2557       int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
2558       int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);
2559 
2560       if (getresuid (&amp;ruid, &amp;euid, &amp;suid) != 0 ||
2561           getresgid (&amp;rgid, &amp;egid, &amp;sgid) != 0)
2562 #endif /* HAVE_GETRESUID */
2563         {
2564           suid = ruid = getuid ();
2565           sgid = rgid = getgid ();
2566           euid = geteuid ();
2567           egid = getegid ();
2568         }
2569 
2570       is_setuid = (ruid != euid || ruid != suid ||
2571                    rgid != egid || rgid != sgid);
2572 
2573       g_once_init_leave (&amp;check_setuid_initialised, 1);
2574     }
2575   return is_setuid;
2576 #else
2577   return FALSE;
2578 #endif
2579 }
2580 
2581 #ifdef G_OS_WIN32
2582 /**
2583  * g_abort:
2584  *
2585  * A wrapper for the POSIX abort() function.
2586  *
2587  * On Windows it is a function that makes extra effort (including a call
2588  * to abort()) to ensure that a debugger-catchable exception is thrown
2589  * before the program terminates.
2590  *
2591  * See your C library manual for more details about abort().
2592  *
2593  * Since: 2.50
2594  */
2595 void
2596 g_abort (void)
2597 {
2598   /* One call to break the debugger */
2599   DebugBreak ();
2600   /* One call in case CRT does get saner about abort() behaviour */
2601   abort ();
2602   /* And one call to bind them all and terminate the program for sure */
2603   ExitProcess (127);
2604 }
2605 #endif
    </pre>
  </body>
</html>