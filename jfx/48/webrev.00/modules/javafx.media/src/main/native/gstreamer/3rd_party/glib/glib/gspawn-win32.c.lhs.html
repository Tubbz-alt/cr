<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* gspawn-win32.c - Process launching on Win32
   2  *
   3  *  Copyright 2000 Red Hat, Inc.
   4  *  Copyright 2003 Tor Lillqvist
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Lesser General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2.1 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Lesser General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Lesser General Public License
  17  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  18  */
  19 
  20 /*
  21  * Implementation details on Win32.
  22  *
  23  * - There is no way to set the no-inherit flag for
  24  *   a &quot;file descriptor&quot; in the MS C runtime. The flag is there,
  25  *   and the dospawn() function uses it, but unfortunately
  26  *   this flag can only be set when opening the file.
  27  * - As there is no fork(), we cannot reliably change directory
  28  *   before starting the child process. (There might be several threads
  29  *   running, and the current directory is common for all threads.)
  30  *
  31  * Thus, we must in many cases use a helper program to handle closing
  32  * of (inherited) file descriptors and changing of directory. The
  33  * helper process is also needed if the standard input, standard
  34  * output, or standard error of the process to be run are supposed to
  35  * be redirected somewhere.
  36  *
  37  * The structure of the source code in this file is a mess, I know.
  38  */
  39 
  40 /* Define this to get some logging all the time */
  41 /* #define G_SPAWN_WIN32_DEBUG */
  42 
  43 #include &quot;config.h&quot;
  44 
  45 #include &quot;glib.h&quot;
  46 #include &quot;glib-private.h&quot;
  47 #include &quot;gprintfint.h&quot;
  48 #include &quot;glibintl.h&quot;
  49 #include &quot;gspawn-private.h&quot;
  50 #include &quot;gthread.h&quot;
  51 
  52 #include &lt;string.h&gt;
  53 #include &lt;stdlib.h&gt;
  54 #include &lt;stdio.h&gt;
  55 
  56 #include &lt;windows.h&gt;
  57 #include &lt;errno.h&gt;
  58 #include &lt;fcntl.h&gt;
  59 #include &lt;io.h&gt;
  60 #include &lt;process.h&gt;
  61 #include &lt;direct.h&gt;
  62 #include &lt;wchar.h&gt;
  63 
  64 #ifndef GSPAWN_HELPER
  65 #ifdef G_SPAWN_WIN32_DEBUG
  66   static int debug = 1;
  67   #define SETUP_DEBUG() /* empty */
  68 #else
  69   static int debug = -1;
<a name="1" id="anc1"></a><span class="line-modified">  70   #define SETUP_DEBUG()                 \</span>
<span class="line-modified">  71     G_STMT_START                    \</span>
<span class="line-modified">  72       {                         \</span>
<span class="line-modified">  73     if (debug == -1)                \</span>
<span class="line-modified">  74       {                     \</span>
<span class="line-modified">  75         if (getenv (&quot;G_SPAWN_WIN32_DEBUG&quot;) != NULL) \</span>
<span class="line-modified">  76           debug = 1;                \</span>
<span class="line-modified">  77         else                    \</span>
<span class="line-modified">  78           debug = 0;                \</span>
<span class="line-modified">  79       }                     \</span>
<span class="line-modified">  80       }                         \</span>
  81     G_STMT_END
  82 #endif
  83 #endif
  84 
  85 enum
  86 {
  87   CHILD_NO_ERROR,
  88   CHILD_CHDIR_FAILED,
  89   CHILD_SPAWN_FAILED,
  90   CHILD_SPAWN_NOENT,
  91 };
  92 
  93 enum {
  94   ARG_CHILD_ERR_REPORT = 1,
  95   ARG_HELPER_SYNC,
  96   ARG_STDIN,
  97   ARG_STDOUT,
  98   ARG_STDERR,
  99   ARG_WORKING_DIRECTORY,
 100   ARG_CLOSE_DESCRIPTORS,
 101   ARG_USE_PATH,
 102   ARG_WAIT,
 103   ARG_PROGRAM,
 104   ARG_COUNT = ARG_PROGRAM
 105 };
 106 
 107 static int
<a name="2" id="anc2"></a><span class="line-modified"> 108 dup_noninherited (int fd,</span>
<span class="line-modified"> 109           int mode)</span>
 110 {
 111   HANDLE filehandle;
 112 
 113   DuplicateHandle (GetCurrentProcess (), (LPHANDLE) _get_osfhandle (fd),
<a name="3" id="anc3"></a><span class="line-modified"> 114            GetCurrentProcess (), &amp;filehandle,</span>
<span class="line-modified"> 115            0, FALSE, DUPLICATE_SAME_ACCESS);</span>
 116   close (fd);
 117   return _open_osfhandle ((gintptr) filehandle, mode | _O_NOINHERIT);
 118 }
 119 
 120 #ifndef GSPAWN_HELPER
 121 
 122 #ifdef _WIN64
 123 #define HELPER_PROCESS &quot;gspawn-win64-helper&quot;
 124 #else
 125 #define HELPER_PROCESS &quot;gspawn-win32-helper&quot;
 126 #endif
 127 
<a name="4" id="anc4"></a>
 128 static gchar *
 129 protect_argv_string (const gchar *string)
 130 {
 131   const gchar *p = string;
 132   gchar *retval, *q;
 133   gint len = 0;
<a name="5" id="anc5"></a>
 134   gboolean need_dblquotes = FALSE;
 135   while (*p)
 136     {
 137       if (*p == &#39; &#39; || *p == &#39;\t&#39;)
<a name="6" id="anc6"></a><span class="line-modified"> 138     need_dblquotes = TRUE;</span>
<span class="line-modified"> 139       else if (*p == &#39;&quot;&#39;)</span>
<span class="line-modified"> 140     len++;</span>
<span class="line-modified"> 141       else if (*p == &#39;\\&#39;)</span>
<span class="line-modified"> 142     {</span>
<span class="line-modified"> 143       const gchar *pp = p;</span>
<span class="line-removed"> 144       while (*pp &amp;&amp; *pp == &#39;\\&#39;)</span>
<span class="line-removed"> 145         pp++;</span>
<span class="line-removed"> 146       if (*pp == &#39;&quot;&#39;)</span>
<span class="line-removed"> 147         len++;</span>
<span class="line-removed"> 148     }</span>
<span class="line-removed"> 149       len++;</span>
 150       p++;
 151     }
 152 
 153   q = retval = g_malloc (len + need_dblquotes*2 + 1);
 154   p = string;
 155 
 156   if (need_dblquotes)
 157     *q++ = &#39;&quot;&#39;;
<a name="7" id="anc7"></a><span class="line-modified"> 158 </span>



 159   while (*p)
 160     {
 161       if (*p == &#39;&quot;&#39;)
<a name="8" id="anc8"></a>

 162     *q++ = &#39;\\&#39;;
<a name="9" id="anc9"></a><span class="line-modified"> 163       else if (*p == &#39;\\&#39;)</span>
<span class="line-modified"> 164     {</span>
<span class="line-modified"> 165       const gchar *pp = p;</span>
<span class="line-modified"> 166       while (*pp &amp;&amp; *pp == &#39;\\&#39;)</span>
<span class="line-modified"> 167         pp++;</span>
<span class="line-modified"> 168       if (*pp == &#39;&quot;&#39;)</span>
<span class="line-modified"> 169         *q++ = &#39;\\&#39;;</span>
<span class="line-modified"> 170     }</span>



 171       *q++ = *p;
 172       p++;
 173     }
 174 
 175   if (need_dblquotes)
<a name="10" id="anc10"></a><span class="line-modified"> 176     *q++ = &#39;&quot;&#39;;</span>







 177   *q++ = &#39;\0&#39;;
 178 
 179   return retval;
 180 }
 181 
 182 static gint
 183 protect_argv (gchar  **argv,
<a name="11" id="anc11"></a><span class="line-modified"> 184           gchar ***new_argv)</span>
 185 {
 186   gint i;
 187   gint argc = 0;
 188 
 189   while (argv[argc])
 190     ++argc;
 191   *new_argv = g_new (gchar *, argc+1);
 192 
 193   /* Quote each argv element if necessary, so that it will get
 194    * reconstructed correctly in the C runtime startup code.  Note that
 195    * the unquoting algorithm in the C runtime is really weird, and
 196    * rather different than what Unix shells do. See stdargv.c in the C
 197    * runtime sources (in the Platform SDK, in src/crt).
 198    *
<a name="12" id="anc12"></a><span class="line-modified"> 199    * Note that an new_argv[0] constructed by this function should</span>
 200    * *not* be passed as the filename argument to a spawn* or exec*
 201    * family function. That argument should be the real file name
 202    * without any quoting.
 203    */
 204   for (i = 0; i &lt; argc; i++)
 205     (*new_argv)[i] = protect_argv_string (argv[i]);
 206 
 207   (*new_argv)[argc] = NULL;
 208 
 209   return argc;
 210 }
 211 
 212 G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)
 213 G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)
 214 
 215 gboolean
 216 g_spawn_async (const gchar          *working_directory,
<a name="13" id="anc13"></a><span class="line-modified"> 217             gchar               **argv,</span>
<span class="line-modified"> 218             gchar               **envp,</span>
<span class="line-modified"> 219             GSpawnFlags           flags,</span>
<span class="line-modified"> 220             GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 221             gpointer              user_data,</span>
<span class="line-modified"> 222             GPid                 *child_handle,</span>
<span class="line-modified"> 223             GError              **error)</span>
 224 {
 225   g_return_val_if_fail (argv != NULL, FALSE);
 226 
 227   return g_spawn_async_with_pipes (working_directory,
<a name="14" id="anc14"></a><span class="line-modified"> 228                     argv, envp,</span>
<span class="line-modified"> 229                     flags,</span>
<span class="line-modified"> 230                     child_setup,</span>
<span class="line-modified"> 231                     user_data,</span>
<span class="line-modified"> 232                     child_handle,</span>
<span class="line-modified"> 233                     NULL, NULL, NULL,</span>
<span class="line-modified"> 234                     error);</span>
 235 }
 236 
 237 /* Avoids a danger in threaded situations (calling close()
 238  * on a file descriptor twice, and another thread has
 239  * re-opened it since the first close)
 240  */
 241 static void
 242 close_and_invalidate (gint *fd)
 243 {
 244   if (*fd &lt; 0)
 245     return;
 246 
 247   close (*fd);
 248   *fd = -1;
 249 }
 250 
 251 typedef enum
 252 {
 253   READ_FAILED = 0, /* FALSE */
 254   READ_OK,
 255   READ_EOF
 256 } ReadResult;
 257 
 258 static ReadResult
 259 read_data (GString     *str,
 260            GIOChannel  *iochannel,
 261            GError     **error)
 262 {
 263   GIOStatus giostatus;
 264   gsize bytes;
 265   gchar buf[4096];
 266 
 267  again:
 268 
 269   giostatus = g_io_channel_read_chars (iochannel, buf, sizeof (buf), &amp;bytes, NULL);
 270 
 271   if (bytes == 0)
 272     return READ_EOF;
 273   else if (bytes &gt; 0)
 274     {
 275       g_string_append_len (str, buf, bytes);
 276       return READ_OK;
 277     }
 278   else if (giostatus == G_IO_STATUS_AGAIN)
 279     goto again;
 280   else if (giostatus == G_IO_STATUS_ERROR)
 281     {
 282       g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_READ,
 283                            _(&quot;Failed to read data from child process&quot;));
 284 
 285       return READ_FAILED;
 286     }
 287   else
 288     return READ_OK;
 289 }
 290 
 291 static gboolean
 292 make_pipe (gint     p[2],
 293            GError **error)
 294 {
 295   if (_pipe (p, 4096, _O_BINARY) &lt; 0)
 296     {
 297       int errsv = errno;
 298 
 299       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 300                    _(&quot;Failed to create pipe for communicating with child process (%s)&quot;),
 301                    g_strerror (errsv));
 302       return FALSE;
 303     }
 304   else
 305     return TRUE;
 306 }
 307 
 308 /* The helper process writes a status report back to us, through a
 309  * pipe, consisting of two ints.
 310  */
 311 static gboolean
 312 read_helper_report (int      fd,
<a name="15" id="anc15"></a><span class="line-modified"> 313             gintptr  report[2],</span>
<span class="line-modified"> 314             GError **error)</span>
 315 {
 316   gint bytes = 0;
 317 
 318   while (bytes &lt; sizeof(gintptr)*2)
 319     {
 320       gint chunk;
 321       int errsv;
 322 
 323       if (debug)
<a name="16" id="anc16"></a><span class="line-modified"> 324     g_print (&quot;%s:read_helper_report: read %&quot; G_GSIZE_FORMAT &quot;...\n&quot;,</span>
<span class="line-modified"> 325          __FILE__,</span>
<span class="line-modified"> 326          sizeof(gintptr)*2 - bytes);</span>
 327 
 328       chunk = read (fd, ((gchar*)report) + bytes,
<a name="17" id="anc17"></a><span class="line-modified"> 329             sizeof(gintptr)*2 - bytes);</span>
 330       errsv = errno;
 331 
 332       if (debug)
<a name="18" id="anc18"></a><span class="line-modified"> 333     g_print (&quot;...got %d bytes\n&quot;, chunk);</span>
 334 
 335       if (chunk &lt; 0)
 336         {
 337           /* Some weird shit happened, bail out */
 338           g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 339                        _(&quot;Failed to read from child pipe (%s)&quot;),
 340                        g_strerror (errsv));
 341 
 342           return FALSE;
 343         }
 344       else if (chunk == 0)
<a name="19" id="anc19"></a><span class="line-modified"> 345     {</span>
<span class="line-modified"> 346       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,</span>
<span class="line-modified"> 347                _(&quot;Failed to read from child pipe (%s)&quot;),</span>
<span class="line-modified"> 348                &quot;EOF&quot;);</span>
<span class="line-modified"> 349       break; /* EOF */</span>
<span class="line-modified"> 350     }</span>
 351       else
<a name="20" id="anc20"></a><span class="line-modified"> 352     bytes += chunk;</span>
 353     }
 354 
 355   if (bytes &lt; sizeof(gintptr)*2)
 356     return FALSE;
 357 
 358   return TRUE;
 359 }
 360 
 361 static void
 362 set_child_error (gintptr      report[2],
<a name="21" id="anc21"></a><span class="line-modified"> 363          const gchar *working_directory,</span>
<span class="line-modified"> 364          GError     **error)</span>
 365 {
 366   switch (report[0])
 367     {
 368     case CHILD_CHDIR_FAILED:
 369       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,
<a name="22" id="anc22"></a><span class="line-modified"> 370            _(&quot;Failed to change to directory &#39;%s&#39; (%s)&quot;),</span>
<span class="line-modified"> 371            working_directory,</span>
<span class="line-modified"> 372            g_strerror (report[1]));</span>
 373       break;
 374     case CHILD_SPAWN_FAILED:
 375       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<a name="23" id="anc23"></a><span class="line-modified"> 376            _(&quot;Failed to execute child process (%s)&quot;),</span>
<span class="line-modified"> 377            g_strerror (report[1]));</span>
 378       break;
 379     case CHILD_SPAWN_NOENT:
 380       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT,
 381                    _(&quot;Failed to execute child process (%s)&quot;),
 382                    g_strerror (report[1]));
 383       break;
 384     default:
 385       g_assert_not_reached ();
 386     }
 387 }
 388 
 389 static gboolean
 390 utf8_charv_to_wcharv (char     **utf8_charv,
<a name="24" id="anc24"></a><span class="line-modified"> 391               wchar_t ***wcharv,</span>
<span class="line-modified"> 392               int       *error_index,</span>
<span class="line-modified"> 393               GError   **error)</span>
 394 {
 395   wchar_t **retval = NULL;
 396 
 397   *wcharv = NULL;
 398   if (utf8_charv != NULL)
 399     {
 400       int n = 0, i;
 401 
 402       while (utf8_charv[n])
<a name="25" id="anc25"></a><span class="line-modified"> 403     n++;</span>
 404       retval = g_new (wchar_t *, n + 1);
 405 
 406       for (i = 0; i &lt; n; i++)
<a name="26" id="anc26"></a><span class="line-modified"> 407     {</span>
<span class="line-modified"> 408       retval[i] = g_utf8_to_utf16 (utf8_charv[i], -1, NULL, NULL, error);</span>
<span class="line-modified"> 409       if (retval[i] == NULL)</span>
<span class="line-modified"> 410         {</span>
<span class="line-modified"> 411           if (error_index)</span>
<span class="line-modified"> 412         *error_index = i;</span>
<span class="line-modified"> 413           while (i)</span>
<span class="line-modified"> 414         g_free (retval[--i]);</span>
<span class="line-modified"> 415           g_free (retval);</span>
<span class="line-modified"> 416           return FALSE;</span>
<span class="line-modified"> 417         }</span>
<span class="line-modified"> 418     }</span>
 419 
 420       retval[n] = NULL;
 421     }
 422   *wcharv = retval;
 423   return TRUE;
 424 }
 425 
 426 static gboolean
 427 do_spawn_directly (gint                 *exit_status,
<a name="27" id="anc27"></a><span class="line-modified"> 428            gboolean      do_return_handle,</span>
<span class="line-modified"> 429                    GSpawnFlags           flags,</span>
<span class="line-modified"> 430                    gchar               **argv,</span>
<span class="line-modified"> 431                    char                **envp,</span>
<span class="line-modified"> 432                    char                **protected_argv,</span>
<span class="line-modified"> 433                    GPid                 *child_handle,</span>
<span class="line-modified"> 434                    GError              **error)</span>
 435 {
 436   const int mode = (exit_status == NULL) ? P_NOWAIT : P_WAIT;
 437   char **new_argv;
 438   gintptr rc = -1;
 439   int errsv;
 440   GError *conv_error = NULL;
 441   gint conv_error_index;
 442   wchar_t *wargv0, **wargv, **wenvp;
 443 
 444   new_argv = (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO) ? protected_argv + 1 : protected_argv;
 445 
 446   wargv0 = g_utf8_to_utf16 (argv[0], -1, NULL, NULL, &amp;conv_error);
 447   if (wargv0 == NULL)
 448     {
 449       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<a name="28" id="anc28"></a><span class="line-modified"> 450            _(&quot;Invalid program name: %s&quot;),</span>
<span class="line-modified"> 451            conv_error-&gt;message);</span>
 452       g_error_free (conv_error);
 453 
 454       return FALSE;
 455     }
 456 
 457   if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
 458     {
 459       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<a name="29" id="anc29"></a><span class="line-modified"> 460            _(&quot;Invalid string in argument vector at %d: %s&quot;),</span>
<span class="line-modified"> 461            conv_error_index, conv_error-&gt;message);</span>
 462       g_error_free (conv_error);
 463       g_free (wargv0);
 464 
 465       return FALSE;
 466     }
 467 
 468   if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
 469     {
 470       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<a name="30" id="anc30"></a><span class="line-modified"> 471            _(&quot;Invalid string in environment: %s&quot;),</span>
<span class="line-modified"> 472            conv_error-&gt;message);</span>
 473       g_error_free (conv_error);
 474       g_free (wargv0);
 475       g_strfreev ((gchar **) wargv);
 476 
 477       return FALSE;
 478     }
 479 
 480   if (flags &amp; G_SPAWN_SEARCH_PATH)
 481     if (wenvp != NULL)
 482       rc = _wspawnvpe (mode, wargv0, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 483     else
 484       rc = _wspawnvp (mode, wargv0, (const wchar_t **) wargv);
 485   else
 486     if (wenvp != NULL)
 487       rc = _wspawnve (mode, wargv0, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 488     else
 489       rc = _wspawnv (mode, wargv0, (const wchar_t **) wargv);
 490 
 491   errsv = errno;
 492 
 493   g_free (wargv0);
 494   g_strfreev ((gchar **) wargv);
 495   g_strfreev ((gchar **) wenvp);
 496 
 497   if (rc == -1 &amp;&amp; errsv != 0)
 498     {
 499       g_set_error (error, G_SPAWN_ERROR, _g_spawn_exec_err_to_g_error (errsv),
<a name="31" id="anc31"></a><span class="line-modified"> 500                    _(&quot;Failed to execute child process (%s)&quot;),</span>
<span class="line-modified"> 501            g_strerror (errsv));</span>
 502       return FALSE;
 503     }
 504 
 505   if (exit_status == NULL)
 506     {
 507       if (child_handle &amp;&amp; do_return_handle)
<a name="32" id="anc32"></a><span class="line-modified"> 508     *child_handle = (GPid) rc;</span>
 509       else
<a name="33" id="anc33"></a><span class="line-modified"> 510     {</span>
<span class="line-modified"> 511       CloseHandle ((HANDLE) rc);</span>
<span class="line-modified"> 512       if (child_handle)</span>
<span class="line-modified"> 513         *child_handle = 0;</span>
<span class="line-modified"> 514     }</span>
 515     }
 516   else
 517     *exit_status = rc;
 518 
 519   return TRUE;
 520 }
 521 
 522 static gboolean
 523 do_spawn_with_fds (gint                 *exit_status,
<a name="34" id="anc34"></a><span class="line-modified"> 524            gboolean        do_return_handle,</span>
<span class="line-modified"> 525                    const gchar          *working_directory,</span>
<span class="line-modified"> 526                    gchar               **argv,</span>
<span class="line-modified"> 527                    char                **envp,</span>
<span class="line-modified"> 528                    GSpawnFlags           flags,</span>
<span class="line-modified"> 529                    GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 530                    GPid                 *child_handle,</span>
<span class="line-modified"> 531            gint                  stdin_fd,</span>
<span class="line-modified"> 532            gint                  stdout_fd,</span>
<span class="line-modified"> 533            gint                  stderr_fd,</span>
<span class="line-modified"> 534            gint       *err_report,</span>
<span class="line-modified"> 535                    GError              **error)</span>
 536 {
 537   char **protected_argv;
 538   char args[ARG_COUNT][10];
 539   char **new_argv;
 540   int i;
 541   gintptr rc = -1;
 542   int errsv;
 543   int argc;
 544   int child_err_report_pipe[2] = { -1, -1 };
 545   int helper_sync_pipe[2] = { -1, -1 };
 546   gintptr helper_report[2];
 547   static gboolean warned_about_child_setup = FALSE;
 548   GError *conv_error = NULL;
 549   gint conv_error_index;
 550   gchar *helper_process;
 551   wchar_t *whelper, **wargv, **wenvp;
 552   gchar *glib_dll_directory;
 553 
 554   if (child_setup &amp;&amp; !warned_about_child_setup)
 555     {
 556       warned_about_child_setup = TRUE;
 557       g_warning (&quot;passing a child setup function to the g_spawn functions is pointless on Windows and it is ignored&quot;);
 558     }
 559 
 560   argc = protect_argv (argv, &amp;protected_argv);
 561 
 562   if (stdin_fd == -1 &amp;&amp; stdout_fd == -1 &amp;&amp; stderr_fd == -1 &amp;&amp;
 563       (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN) &amp;&amp;
 564       !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL) &amp;&amp;
 565       !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL) &amp;&amp;
 566       (working_directory == NULL || !*working_directory) &amp;&amp;
 567       (flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
 568     {
 569       /* We can do without the helper process */
 570       gboolean retval =
<a name="35" id="anc35"></a><span class="line-modified"> 571     do_spawn_directly (exit_status, do_return_handle, flags,</span>
<span class="line-modified"> 572                argv, envp, protected_argv,</span>
<span class="line-modified"> 573                child_handle, error);</span>
 574       g_strfreev (protected_argv);
 575       return retval;
 576     }
 577 
 578   if (!make_pipe (child_err_report_pipe, error))
 579     goto cleanup_and_fail;
 580 
 581   if (!make_pipe (helper_sync_pipe, error))
 582     goto cleanup_and_fail;
 583 
 584   new_argv = g_new (char *, argc + 1 + ARG_COUNT);
 585   if (GetConsoleWindow () != NULL)
 586     helper_process = HELPER_PROCESS &quot;-console.exe&quot;;
 587   else
 588     helper_process = HELPER_PROCESS &quot;.exe&quot;;
 589 
 590   glib_dll_directory = _glib_get_dll_directory ();
 591   if (glib_dll_directory != NULL)
 592     {
 593       helper_process = g_build_filename (glib_dll_directory, helper_process, NULL);
 594       g_free (glib_dll_directory);
 595     }
 596   else
 597     helper_process = g_strdup (helper_process);
 598 
 599   new_argv[0] = protect_argv_string (helper_process);
 600 
 601   _g_sprintf (args[ARG_CHILD_ERR_REPORT], &quot;%d&quot;, child_err_report_pipe[1]);
 602   new_argv[ARG_CHILD_ERR_REPORT] = args[ARG_CHILD_ERR_REPORT];
 603 
 604   /* Make the read end of the child error report pipe
 605    * noninherited. Otherwise it will needlessly be inherited by the
 606    * helper process, and the started actual user process. As such that
 607    * shouldn&#39;t harm, but it is unnecessary.
 608    */
<a name="36" id="anc36"></a><span class="line-modified"> 609   child_err_report_pipe[0] = dup_noninherited (child_err_report_pipe[0], _O_RDONLY);</span>
 610 
 611   if (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO)
 612     {
 613       /* Overload ARG_CHILD_ERR_REPORT to also encode the
 614        * G_SPAWN_FILE_AND_ARGV_ZERO functionality.
 615        */
 616       strcat (args[ARG_CHILD_ERR_REPORT], &quot;#&quot;);
 617     }
 618 
 619   _g_sprintf (args[ARG_HELPER_SYNC], &quot;%d&quot;, helper_sync_pipe[0]);
 620   new_argv[ARG_HELPER_SYNC] = args[ARG_HELPER_SYNC];
 621 
 622   /* Make the write end of the sync pipe noninherited. Otherwise the
 623    * helper process will inherit it, and thus if this process happens
 624    * to crash before writing the sync byte to the pipe, the helper
 625    * process won&#39;t read but won&#39;t get any EOF either, as it has the
 626    * write end open itself.
 627    */
<a name="37" id="anc37"></a><span class="line-modified"> 628   helper_sync_pipe[1] = dup_noninherited (helper_sync_pipe[1], _O_WRONLY);</span>
 629 
 630   if (stdin_fd != -1)
 631     {
 632       _g_sprintf (args[ARG_STDIN], &quot;%d&quot;, stdin_fd);
 633       new_argv[ARG_STDIN] = args[ARG_STDIN];
 634     }
 635   else if (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN)
 636     {
 637       /* Let stdin be alone */
 638       new_argv[ARG_STDIN] = &quot;-&quot;;
 639     }
 640   else
 641     {
 642       /* Keep process from blocking on a read of stdin */
 643       new_argv[ARG_STDIN] = &quot;z&quot;;
 644     }
 645 
 646   if (stdout_fd != -1)
 647     {
 648       _g_sprintf (args[ARG_STDOUT], &quot;%d&quot;, stdout_fd);
 649       new_argv[ARG_STDOUT] = args[ARG_STDOUT];
 650     }
 651   else if (flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL)
 652     {
 653       new_argv[ARG_STDOUT] = &quot;z&quot;;
 654     }
 655   else
 656     {
 657       new_argv[ARG_STDOUT] = &quot;-&quot;;
 658     }
 659 
<a name="38" id="anc38"></a><span class="line-modified"> 660   if (stdout_fd != -1)</span>
 661     {
 662       _g_sprintf (args[ARG_STDERR], &quot;%d&quot;, stderr_fd);
 663       new_argv[ARG_STDERR] = args[ARG_STDERR];
 664     }
 665   else if (flags &amp; G_SPAWN_STDERR_TO_DEV_NULL)
 666     {
 667       new_argv[ARG_STDERR] = &quot;z&quot;;
 668     }
 669   else
 670     {
 671       new_argv[ARG_STDERR] = &quot;-&quot;;
 672     }
 673 
 674   if (working_directory &amp;&amp; *working_directory)
 675     new_argv[ARG_WORKING_DIRECTORY] = protect_argv_string (working_directory);
 676   else
 677     new_argv[ARG_WORKING_DIRECTORY] = g_strdup (&quot;-&quot;);
 678 
 679   if (!(flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
 680     new_argv[ARG_CLOSE_DESCRIPTORS] = &quot;y&quot;;
 681   else
 682     new_argv[ARG_CLOSE_DESCRIPTORS] = &quot;-&quot;;
 683 
 684   if (flags &amp; G_SPAWN_SEARCH_PATH)
 685     new_argv[ARG_USE_PATH] = &quot;y&quot;;
 686   else
 687     new_argv[ARG_USE_PATH] = &quot;-&quot;;
 688 
 689   if (exit_status == NULL)
 690     new_argv[ARG_WAIT] = &quot;-&quot;;
 691   else
 692     new_argv[ARG_WAIT] = &quot;w&quot;;
 693 
 694   for (i = 0; i &lt;= argc; i++)
 695     new_argv[ARG_PROGRAM + i] = protected_argv[i];
 696 
 697   SETUP_DEBUG();
 698 
 699   if (debug)
 700     {
 701       g_print (&quot;calling %s with argv:\n&quot;, helper_process);
 702       for (i = 0; i &lt; argc + 1 + ARG_COUNT; i++)
<a name="39" id="anc39"></a><span class="line-modified"> 703     g_print (&quot;argv[%d]: %s\n&quot;, i, (new_argv[i] ? new_argv[i] : &quot;NULL&quot;));</span>
 704     }
 705 
 706   if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
 707     {
 708       if (conv_error_index == ARG_WORKING_DIRECTORY)
<a name="40" id="anc40"></a><span class="line-modified"> 709     g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,</span>
<span class="line-modified"> 710              _(&quot;Invalid working directory: %s&quot;),</span>
<span class="line-modified"> 711              conv_error-&gt;message);</span>
 712       else
<a name="41" id="anc41"></a><span class="line-modified"> 713     g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,</span>
<span class="line-modified"> 714              _(&quot;Invalid string in argument vector at %d: %s&quot;),</span>
<span class="line-modified"> 715              conv_error_index - ARG_PROGRAM, conv_error-&gt;message);</span>
 716       g_error_free (conv_error);
 717       g_strfreev (protected_argv);
 718       g_free (new_argv[0]);
 719       g_free (new_argv[ARG_WORKING_DIRECTORY]);
 720       g_free (new_argv);
 721       g_free (helper_process);
 722 
 723       goto cleanup_and_fail;
 724     }
 725 
 726   if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
 727     {
 728       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<a name="42" id="anc42"></a><span class="line-modified"> 729            _(&quot;Invalid string in environment: %s&quot;),</span>
<span class="line-modified"> 730            conv_error-&gt;message);</span>
 731       g_error_free (conv_error);
 732       g_strfreev (protected_argv);
 733       g_free (new_argv[0]);
 734       g_free (new_argv[ARG_WORKING_DIRECTORY]);
 735       g_free (new_argv);
 736       g_free (helper_process);
 737       g_strfreev ((gchar **) wargv);
 738 
 739       goto cleanup_and_fail;
 740     }
 741 
 742   whelper = g_utf8_to_utf16 (helper_process, -1, NULL, NULL, NULL);
 743   g_free (helper_process);
 744 
 745   if (wenvp != NULL)
 746     rc = _wspawnvpe (P_NOWAIT, whelper, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 747   else
 748     rc = _wspawnvp (P_NOWAIT, whelper, (const wchar_t **) wargv);
 749 
 750   errsv = errno;
 751 
 752   g_free (whelper);
 753   g_strfreev ((gchar **) wargv);
 754   g_strfreev ((gchar **) wenvp);
 755 
 756   /* Close the other process&#39;s ends of the pipes in this process,
 757    * otherwise the reader will never get EOF.
 758    */
 759   close_and_invalidate (&amp;child_err_report_pipe[1]);
 760   close_and_invalidate (&amp;helper_sync_pipe[0]);
 761 
 762   g_strfreev (protected_argv);
 763 
 764   g_free (new_argv[0]);
 765   g_free (new_argv[ARG_WORKING_DIRECTORY]);
 766   g_free (new_argv);
 767 
 768   /* Check if gspawn-win32-helper couldn&#39;t be run */
 769   if (rc == -1 &amp;&amp; errsv != 0)
 770     {
 771       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<a name="43" id="anc43"></a><span class="line-modified"> 772                    _(&quot;Failed to execute helper program (%s)&quot;),</span>
<span class="line-modified"> 773            g_strerror (errsv));</span>
 774       goto cleanup_and_fail;
 775     }
 776 
 777   if (exit_status != NULL)
 778     {
 779       /* Synchronous case. Pass helper&#39;s report pipe back to caller,
 780        * which takes care of reading it after the grandchild has
 781        * finished.
 782        */
 783       g_assert (err_report != NULL);
 784       *err_report = child_err_report_pipe[0];
 785       write (helper_sync_pipe[1], &quot; &quot;, 1);
 786       close_and_invalidate (&amp;helper_sync_pipe[1]);
 787     }
 788   else
 789     {
 790       /* Asynchronous case. We read the helper&#39;s report right away. */
 791       if (!read_helper_report (child_err_report_pipe[0], helper_report, error))
<a name="44" id="anc44"></a><span class="line-modified"> 792     goto cleanup_and_fail;</span>
 793 
 794       close_and_invalidate (&amp;child_err_report_pipe[0]);
 795 
 796       switch (helper_report[0])
<a name="45" id="anc45"></a>










 797     {
<a name="46" id="anc46"></a><span class="line-modified"> 798     case CHILD_NO_ERROR:</span>
<span class="line-modified"> 799       if (child_handle &amp;&amp; do_return_handle)</span>
<span class="line-modified"> 800         {</span>
<span class="line-removed"> 801           /* rc is our HANDLE for gspawn-win32-helper. It has</span>
<span class="line-removed"> 802            * told us the HANDLE of its child. Duplicate that into</span>
<span class="line-removed"> 803            * a HANDLE valid in this process.</span>
<span class="line-removed"> 804            */</span>
<span class="line-removed"> 805           if (!DuplicateHandle ((HANDLE) rc, (HANDLE) helper_report[1],</span>
<span class="line-removed"> 806                     GetCurrentProcess (), (LPHANDLE) child_handle,</span>
<span class="line-removed"> 807                     0, TRUE, DUPLICATE_SAME_ACCESS))</span>
<span class="line-removed"> 808         {</span>
<span class="line-removed"> 809           char *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-removed"> 810           g_print(&quot;%s\n&quot;, emsg);</span>
<span class="line-removed"> 811           *child_handle = 0;</span>
<span class="line-removed"> 812         }</span>
<span class="line-removed"> 813         }</span>
<span class="line-removed"> 814       else if (child_handle)</span>
<span class="line-removed"> 815         *child_handle = 0;</span>
<span class="line-removed"> 816       write (helper_sync_pipe[1], &quot; &quot;, 1);</span>
<span class="line-removed"> 817       close_and_invalidate (&amp;helper_sync_pipe[1]);</span>
<span class="line-removed"> 818       break;</span>
<span class="line-removed"> 819 </span>
<span class="line-removed"> 820     default:</span>
<span class="line-removed"> 821       write (helper_sync_pipe[1], &quot; &quot;, 1);</span>
<span class="line-removed"> 822       close_and_invalidate (&amp;helper_sync_pipe[1]);</span>
<span class="line-removed"> 823       set_child_error (helper_report, working_directory, error);</span>
<span class="line-removed"> 824       goto cleanup_and_fail;</span>
 825     }
<a name="47" id="anc47"></a>












 826     }
 827 
 828   /* Success against all odds! return the information */
 829 
 830   if (rc != -1)
 831     CloseHandle ((HANDLE) rc);
 832 
 833   return TRUE;
 834 
 835  cleanup_and_fail:
 836 
 837   if (rc != -1)
 838     CloseHandle ((HANDLE) rc);
 839   if (child_err_report_pipe[0] != -1)
 840     close (child_err_report_pipe[0]);
 841   if (child_err_report_pipe[1] != -1)
 842     close (child_err_report_pipe[1]);
 843   if (helper_sync_pipe[0] != -1)
 844     close (helper_sync_pipe[0]);
 845   if (helper_sync_pipe[1] != -1)
 846     close (helper_sync_pipe[1]);
 847 
 848   return FALSE;
 849 }
 850 
 851 static gboolean
 852 do_spawn_with_pipes (gint                 *exit_status,
<a name="48" id="anc48"></a><span class="line-modified"> 853              gboolean          do_return_handle,</span>
<span class="line-modified"> 854              const gchar          *working_directory,</span>
<span class="line-modified"> 855              gchar               **argv,</span>
<span class="line-modified"> 856              char                **envp,</span>
<span class="line-modified"> 857              GSpawnFlags           flags,</span>
<span class="line-modified"> 858              GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 859              GPid                 *child_handle,</span>
<span class="line-modified"> 860              gint                 *standard_input,</span>
<span class="line-modified"> 861              gint                 *standard_output,</span>
<span class="line-modified"> 862              gint                 *standard_error,</span>
<span class="line-modified"> 863              gint         *err_report,</span>
<span class="line-modified"> 864              GError              **error)</span>
 865 {
 866   int stdin_pipe[2] = { -1, -1 };
 867   int stdout_pipe[2] = { -1, -1 };
 868   int stderr_pipe[2] = { -1, -1 };
 869 
 870   if (standard_input &amp;&amp; !make_pipe (stdin_pipe, error))
 871     goto cleanup_and_fail;
 872 
 873   if (standard_output &amp;&amp; !make_pipe (stdout_pipe, error))
 874     goto cleanup_and_fail;
 875 
 876   if (standard_error &amp;&amp; !make_pipe (stderr_pipe, error))
 877     goto cleanup_and_fail;
 878 
 879   if (!do_spawn_with_fds (exit_status,
<a name="49" id="anc49"></a><span class="line-modified"> 880               do_return_handle,</span>
<span class="line-modified"> 881               working_directory,</span>
<span class="line-modified"> 882               argv,</span>
<span class="line-modified"> 883               envp,</span>
<span class="line-modified"> 884               flags,</span>
<span class="line-modified"> 885               child_setup,</span>
<span class="line-modified"> 886               child_handle,</span>
<span class="line-modified"> 887               stdin_pipe[0],</span>
<span class="line-modified"> 888               stdout_pipe[1],</span>
<span class="line-modified"> 889               stderr_pipe[1],</span>
<span class="line-modified"> 890               err_report,</span>
<span class="line-modified"> 891               error))</span>
 892     goto cleanup_and_fail;
 893 
 894   /* Close the other process&#39;s ends of the pipes in this process,
 895    * otherwise the reader will never get EOF.
 896    */
 897   close_and_invalidate (&amp;stdin_pipe[0]);
 898   close_and_invalidate (&amp;stdout_pipe[1]);
 899   close_and_invalidate (&amp;stderr_pipe[1]);
 900 
 901   if (standard_input)
 902     *standard_input = stdin_pipe[1];
 903   if (standard_output)
 904     *standard_output = stdout_pipe[0];
 905   if (standard_error)
 906     *standard_error = stderr_pipe[0];
 907 
 908   return TRUE;
 909 
 910  cleanup_and_fail:
 911 
 912   if (stdin_pipe[0] != -1)
 913     close (stdin_pipe[0]);
 914   if (stdin_pipe[1] != -1)
 915     close (stdin_pipe[1]);
 916   if (stdout_pipe[0] != -1)
 917     close (stdout_pipe[0]);
 918   if (stdout_pipe[1] != -1)
 919     close (stdout_pipe[1]);
 920   if (stderr_pipe[0] != -1)
 921     close (stderr_pipe[0]);
 922   if (stderr_pipe[1] != -1)
 923     close (stderr_pipe[1]);
 924 
 925   return FALSE;
 926 }
 927 
 928 gboolean
 929 g_spawn_sync (const gchar          *working_directory,
<a name="50" id="anc50"></a><span class="line-modified"> 930            gchar               **argv,</span>
<span class="line-modified"> 931            gchar               **envp,</span>
<span class="line-modified"> 932            GSpawnFlags           flags,</span>
<span class="line-modified"> 933            GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified"> 934            gpointer              user_data,</span>
<span class="line-modified"> 935            gchar               **standard_output,</span>
<span class="line-modified"> 936            gchar               **standard_error,</span>
<span class="line-modified"> 937            gint                 *exit_status,</span>
<span class="line-modified"> 938            GError              **error)</span>
 939 {
 940   gint outpipe = -1;
 941   gint errpipe = -1;
 942   gint reportpipe = -1;
 943   GIOChannel *outchannel = NULL;
 944   GIOChannel *errchannel = NULL;
 945   GPollFD outfd, errfd;
 946   GPollFD fds[2];
 947   gint nfds;
 948   gint outindex = -1;
 949   gint errindex = -1;
 950   gint ret;
 951   GString *outstr = NULL;
 952   GString *errstr = NULL;
 953   gboolean failed;
 954   gint status;
 955 
 956   g_return_val_if_fail (argv != NULL, FALSE);
 957   g_return_val_if_fail (!(flags &amp; G_SPAWN_DO_NOT_REAP_CHILD), FALSE);
 958   g_return_val_if_fail (standard_output == NULL ||
 959                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
 960   g_return_val_if_fail (standard_error == NULL ||
 961                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
 962 
 963   /* Just to ensure segfaults if callers try to use
 964    * these when an error is reported.
 965    */
 966   if (standard_output)
 967     *standard_output = NULL;
 968 
 969   if (standard_error)
 970     *standard_error = NULL;
 971 
 972   if (!do_spawn_with_pipes (&amp;status,
<a name="51" id="anc51"></a><span class="line-modified"> 973                 FALSE,</span>
<span class="line-modified"> 974                 working_directory,</span>
<span class="line-modified"> 975                 argv,</span>
<span class="line-modified"> 976                 envp,</span>
<span class="line-modified"> 977                 flags,</span>
<span class="line-modified"> 978                 child_setup,</span>
<span class="line-modified"> 979                 NULL,</span>
<span class="line-modified"> 980                 NULL,</span>
<span class="line-modified"> 981                 standard_output ? &amp;outpipe : NULL,</span>
<span class="line-modified"> 982                 standard_error ? &amp;errpipe : NULL,</span>
<span class="line-modified"> 983                 &amp;reportpipe,</span>
<span class="line-modified"> 984                 error))</span>
 985     return FALSE;
 986 
 987   /* Read data from child. */
 988 
 989   failed = FALSE;
 990 
 991   if (outpipe &gt;= 0)
 992     {
 993       outstr = g_string_new (NULL);
 994       outchannel = g_io_channel_win32_new_fd (outpipe);
 995       g_io_channel_set_encoding (outchannel, NULL, NULL);
 996       g_io_channel_set_buffered (outchannel, FALSE);
 997       g_io_channel_win32_make_pollfd (outchannel,
<a name="52" id="anc52"></a><span class="line-modified"> 998                       G_IO_IN | G_IO_ERR | G_IO_HUP,</span>
<span class="line-modified"> 999                       &amp;outfd);</span>
1000       if (debug)
<a name="53" id="anc53"></a><span class="line-modified">1001     g_print (&quot;outfd=%p\n&quot;, (HANDLE) outfd.fd);</span>
1002     }
1003 
1004   if (errpipe &gt;= 0)
1005     {
1006       errstr = g_string_new (NULL);
1007       errchannel = g_io_channel_win32_new_fd (errpipe);
1008       g_io_channel_set_encoding (errchannel, NULL, NULL);
1009       g_io_channel_set_buffered (errchannel, FALSE);
1010       g_io_channel_win32_make_pollfd (errchannel,
<a name="54" id="anc54"></a><span class="line-modified">1011                       G_IO_IN | G_IO_ERR | G_IO_HUP,</span>
<span class="line-modified">1012                       &amp;errfd);</span>
1013       if (debug)
<a name="55" id="anc55"></a><span class="line-modified">1014     g_print (&quot;errfd=%p\n&quot;, (HANDLE) errfd.fd);</span>
1015     }
1016 
1017   /* Read data until we get EOF on all pipes. */
1018   while (!failed &amp;&amp; (outpipe &gt;= 0 || errpipe &gt;= 0))
1019     {
1020       nfds = 0;
1021       if (outpipe &gt;= 0)
<a name="56" id="anc56"></a><span class="line-modified">1022     {</span>
<span class="line-modified">1023       fds[nfds] = outfd;</span>
<span class="line-modified">1024       outindex = nfds;</span>
<span class="line-modified">1025       nfds++;</span>
<span class="line-modified">1026     }</span>
1027       if (errpipe &gt;= 0)
<a name="57" id="anc57"></a><span class="line-modified">1028     {</span>
<span class="line-modified">1029       fds[nfds] = errfd;</span>
<span class="line-modified">1030       errindex = nfds;</span>
<span class="line-modified">1031       nfds++;</span>
<span class="line-modified">1032     }</span>
1033 
1034       if (debug)
<a name="58" id="anc58"></a><span class="line-modified">1035     g_print (&quot;g_spawn_sync: calling g_io_channel_win32_poll, nfds=%d\n&quot;,</span>
<span class="line-modified">1036          nfds);</span>
1037 
1038       ret = g_io_channel_win32_poll (fds, nfds, -1);
1039 
1040       if (ret &lt; 0)
1041         {
1042           failed = TRUE;
1043 
1044           g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_READ,
1045                                _(&quot;Unexpected error in g_io_channel_win32_poll() reading data from a child process&quot;));
1046 
1047           break;
1048         }
1049 
1050       if (outpipe &gt;= 0 &amp;&amp; (fds[outindex].revents &amp; G_IO_IN))
1051         {
1052           switch (read_data (outstr, outchannel, error))
1053             {
1054             case READ_FAILED:
<a name="59" id="anc59"></a><span class="line-modified">1055           if (debug)</span>
<span class="line-modified">1056         g_print (&quot;g_spawn_sync: outchannel: READ_FAILED\n&quot;);</span>
1057               failed = TRUE;
1058               break;
1059             case READ_EOF:
<a name="60" id="anc60"></a><span class="line-modified">1060           if (debug)</span>
<span class="line-modified">1061         g_print (&quot;g_spawn_sync: outchannel: READ_EOF\n&quot;);</span>
1062               g_io_channel_unref (outchannel);
<a name="61" id="anc61"></a><span class="line-modified">1063           outchannel = NULL;</span>
1064               close_and_invalidate (&amp;outpipe);
1065               break;
1066             default:
<a name="62" id="anc62"></a><span class="line-modified">1067           if (debug)</span>
<span class="line-modified">1068         g_print (&quot;g_spawn_sync: outchannel: OK\n&quot;);</span>
1069               break;
1070             }
1071 
1072           if (failed)
1073             break;
1074         }
1075 
1076       if (errpipe &gt;= 0 &amp;&amp; (fds[errindex].revents &amp; G_IO_IN))
1077         {
1078           switch (read_data (errstr, errchannel, error))
1079             {
1080             case READ_FAILED:
<a name="63" id="anc63"></a><span class="line-modified">1081           if (debug)</span>
<span class="line-modified">1082         g_print (&quot;g_spawn_sync: errchannel: READ_FAILED\n&quot;);</span>
1083               failed = TRUE;
1084               break;
1085             case READ_EOF:
<a name="64" id="anc64"></a><span class="line-modified">1086           if (debug)</span>
<span class="line-modified">1087         g_print (&quot;g_spawn_sync: errchannel: READ_EOF\n&quot;);</span>
<span class="line-modified">1088           g_io_channel_unref (errchannel);</span>
<span class="line-modified">1089           errchannel = NULL;</span>
1090               close_and_invalidate (&amp;errpipe);
1091               break;
1092             default:
<a name="65" id="anc65"></a><span class="line-modified">1093           if (debug)</span>
<span class="line-modified">1094         g_print (&quot;g_spawn_sync: errchannel: OK\n&quot;);</span>
1095               break;
1096             }
1097 
1098           if (failed)
1099             break;
1100         }
1101     }
1102 
1103   if (reportpipe == -1)
1104     {
1105       /* No helper process, exit status of actual spawned process
1106        * already available.
1107        */
1108       if (exit_status)
1109         *exit_status = status;
1110     }
1111   else
1112     {
1113       /* Helper process was involved. Read its report now after the
1114        * grandchild has finished.
1115        */
1116       gintptr helper_report[2];
1117 
1118       if (!read_helper_report (reportpipe, helper_report, error))
<a name="66" id="anc66"></a><span class="line-modified">1119     failed = TRUE;</span>
1120       else
<a name="67" id="anc67"></a><span class="line-modified">1121     {</span>
<span class="line-modified">1122       switch (helper_report[0])</span>
<span class="line-modified">1123         {</span>
<span class="line-modified">1124         case CHILD_NO_ERROR:</span>
<span class="line-modified">1125           if (exit_status)</span>
<span class="line-modified">1126         *exit_status = helper_report[1];</span>
<span class="line-modified">1127           break;</span>
<span class="line-modified">1128         default:</span>
<span class="line-modified">1129           set_child_error (helper_report, working_directory, error);</span>
<span class="line-modified">1130           failed = TRUE;</span>
<span class="line-modified">1131           break;</span>
<span class="line-modified">1132         }</span>
<span class="line-modified">1133     }</span>
1134       close_and_invalidate (&amp;reportpipe);
1135     }
1136 
1137 
1138   /* These should only be open still if we had an error.  */
1139 
1140   if (outchannel != NULL)
1141     g_io_channel_unref (outchannel);
1142   if (errchannel != NULL)
1143     g_io_channel_unref (errchannel);
1144   if (outpipe &gt;= 0)
1145     close_and_invalidate (&amp;outpipe);
1146   if (errpipe &gt;= 0)
1147     close_and_invalidate (&amp;errpipe);
1148 
1149   if (failed)
1150     {
1151       if (outstr)
1152         g_string_free (outstr, TRUE);
1153       if (errstr)
1154         g_string_free (errstr, TRUE);
1155 
1156       return FALSE;
1157     }
1158   else
1159     {
1160       if (standard_output)
1161         *standard_output = g_string_free (outstr, FALSE);
1162 
1163       if (standard_error)
1164         *standard_error = g_string_free (errstr, FALSE);
1165 
1166       return TRUE;
1167     }
1168 }
1169 
1170 gboolean
1171 g_spawn_async_with_pipes (const gchar          *working_directory,
<a name="68" id="anc68"></a><span class="line-modified">1172                    gchar               **argv,</span>
<span class="line-modified">1173                    gchar               **envp,</span>
<span class="line-modified">1174                    GSpawnFlags           flags,</span>
<span class="line-modified">1175                    GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1176                    gpointer              user_data,</span>
<span class="line-modified">1177                    GPid                 *child_handle,</span>
<span class="line-modified">1178                    gint                 *standard_input,</span>
<span class="line-modified">1179                    gint                 *standard_output,</span>
<span class="line-modified">1180                    gint                 *standard_error,</span>
<span class="line-modified">1181                    GError              **error)</span>
1182 {
1183   g_return_val_if_fail (argv != NULL, FALSE);
1184   g_return_val_if_fail (standard_output == NULL ||
1185                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
1186   g_return_val_if_fail (standard_error == NULL ||
1187                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
1188   /* can&#39;t inherit stdin if we have an input pipe. */
1189   g_return_val_if_fail (standard_input == NULL ||
1190                         !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
1191 
1192   return do_spawn_with_pipes (NULL,
<a name="69" id="anc69"></a><span class="line-modified">1193                   (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),</span>
<span class="line-modified">1194                   working_directory,</span>
<span class="line-modified">1195                   argv,</span>
<span class="line-modified">1196                   envp,</span>
<span class="line-modified">1197                   flags,</span>
<span class="line-modified">1198                   child_setup,</span>
<span class="line-modified">1199                   child_handle,</span>
<span class="line-modified">1200                   standard_input,</span>
<span class="line-modified">1201                   standard_output,</span>
<span class="line-modified">1202                   standard_error,</span>
<span class="line-modified">1203                   NULL,</span>
<span class="line-modified">1204                   error);</span>
1205 }
1206 
1207 gboolean
1208 g_spawn_async_with_fds (const gchar          *working_directory,
1209                         gchar               **argv,
1210                         gchar               **envp,
1211                         GSpawnFlags           flags,
1212                         GSpawnChildSetupFunc  child_setup,
1213                         gpointer              user_data,
1214                         GPid                 *child_handle,
1215                         gint                  stdin_fd,
1216                         gint                  stdout_fd,
1217                         gint                  stderr_fd,
1218                         GError              **error)
1219 {
1220   g_return_val_if_fail (argv != NULL, FALSE);
1221   g_return_val_if_fail (stdin_fd == -1 ||
1222                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
1223   g_return_val_if_fail (stderr_fd == -1 ||
1224                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
1225   /* can&#39;t inherit stdin if we have an input pipe. */
1226   g_return_val_if_fail (stdin_fd == -1 ||
1227                         !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
1228 
1229   return do_spawn_with_fds (NULL,
<a name="70" id="anc70"></a><span class="line-modified">1230                 (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),</span>
<span class="line-modified">1231                 working_directory,</span>
<span class="line-modified">1232                 argv,</span>
<span class="line-modified">1233                 envp,</span>
<span class="line-modified">1234                 flags,</span>
<span class="line-modified">1235                 child_setup,</span>
<span class="line-modified">1236                 child_handle,</span>
<span class="line-modified">1237                 stdin_fd,</span>
<span class="line-modified">1238                 stdout_fd,</span>
<span class="line-modified">1239                 stderr_fd,</span>
<span class="line-modified">1240                 NULL,</span>
<span class="line-modified">1241                 error);</span>
1242 }
1243 
1244 gboolean
1245 g_spawn_command_line_sync (const gchar  *command_line,
<a name="71" id="anc71"></a><span class="line-modified">1246                 gchar       **standard_output,</span>
<span class="line-modified">1247                 gchar       **standard_error,</span>
<span class="line-modified">1248                 gint         *exit_status,</span>
<span class="line-modified">1249                 GError      **error)</span>
1250 {
1251   gboolean retval;
1252   gchar **argv = 0;
1253 
1254   g_return_val_if_fail (command_line != NULL, FALSE);
1255 
1256   if (!g_shell_parse_argv (command_line,
1257                            NULL, &amp;argv,
1258                            error))
1259     return FALSE;
1260 
1261   retval = g_spawn_sync (NULL,
<a name="72" id="anc72"></a><span class="line-modified">1262                   argv,</span>
<span class="line-modified">1263                   NULL,</span>
<span class="line-modified">1264                   G_SPAWN_SEARCH_PATH,</span>
<span class="line-modified">1265                   NULL,</span>
<span class="line-modified">1266                   NULL,</span>
<span class="line-modified">1267                   standard_output,</span>
<span class="line-modified">1268                   standard_error,</span>
<span class="line-modified">1269                   exit_status,</span>
<span class="line-modified">1270                   error);</span>
1271   g_strfreev (argv);
1272 
1273   return retval;
1274 }
1275 
1276 gboolean
1277 g_spawn_command_line_async (const gchar *command_line,
<a name="73" id="anc73"></a><span class="line-modified">1278                  GError     **error)</span>
1279 {
1280   gboolean retval;
1281   gchar **argv = 0;
1282 
1283   g_return_val_if_fail (command_line != NULL, FALSE);
1284 
1285   if (!g_shell_parse_argv (command_line,
1286                            NULL, &amp;argv,
1287                            error))
1288     return FALSE;
1289 
1290   retval = g_spawn_async (NULL,
<a name="74" id="anc74"></a><span class="line-modified">1291                    argv,</span>
<span class="line-modified">1292                    NULL,</span>
<span class="line-modified">1293                    G_SPAWN_SEARCH_PATH,</span>
<span class="line-modified">1294                    NULL,</span>
<span class="line-modified">1295                    NULL,</span>
<span class="line-modified">1296                    NULL,</span>
<span class="line-modified">1297                    error);</span>
1298   g_strfreev (argv);
1299 
1300   return retval;
1301 }
1302 
1303 void
1304 g_spawn_close_pid (GPid pid)
1305 {
1306     CloseHandle (pid);
1307 }
1308 
1309 gboolean
1310 g_spawn_check_exit_status (gint      exit_status,
<a name="75" id="anc75"></a><span class="line-modified">1311                GError  **error)</span>
1312 {
1313   gboolean ret = FALSE;
1314 
1315   if (exit_status != 0)
1316     {
1317       g_set_error (error, G_SPAWN_EXIT_ERROR, exit_status,
<a name="76" id="anc76"></a><span class="line-modified">1318            _(&quot;Child process exited with code %ld&quot;),</span>
<span class="line-modified">1319            (long) exit_status);</span>
1320       goto out;
1321     }
1322 
1323   ret = TRUE;
1324  out:
1325   return ret;
1326 }
1327 
1328 #ifndef GSTREAMER_LITE
1329 #ifdef G_OS_WIN32
1330 
1331 /* Binary compatibility versions. Not for newly compiled code. */
1332 
1333 _GLIB_EXTERN gboolean g_spawn_async_utf8              (const gchar           *working_directory,
1334                                                        gchar                **argv,
1335                                                        gchar                **envp,
1336                                                        GSpawnFlags            flags,
1337                                                        GSpawnChildSetupFunc   child_setup,
1338                                                        gpointer               user_data,
1339                                                        GPid                  *child_pid,
1340                                                        GError               **error);
1341 _GLIB_EXTERN gboolean g_spawn_async_with_pipes_utf8   (const gchar           *working_directory,
1342                                                        gchar                **argv,
1343                                                        gchar                **envp,
1344                                                        GSpawnFlags            flags,
1345                                                        GSpawnChildSetupFunc   child_setup,
1346                                                        gpointer               user_data,
1347                                                        GPid                  *child_pid,
1348                                                        gint                  *standard_input,
1349                                                        gint                  *standard_output,
1350                                                        gint                  *standard_error,
1351                                                        GError               **error);
1352 _GLIB_EXTERN gboolean g_spawn_sync_utf8               (const gchar           *working_directory,
1353                                                        gchar                **argv,
1354                                                        gchar                **envp,
1355                                                        GSpawnFlags            flags,
1356                                                        GSpawnChildSetupFunc   child_setup,
1357                                                        gpointer               user_data,
1358                                                        gchar                **standard_output,
1359                                                        gchar                **standard_error,
1360                                                        gint                  *exit_status,
1361                                                        GError               **error);
1362 _GLIB_EXTERN gboolean g_spawn_command_line_sync_utf8  (const gchar           *command_line,
1363                                                        gchar                **standard_output,
1364                                                        gchar                **standard_error,
1365                                                        gint                  *exit_status,
1366                                                        GError               **error);
1367 _GLIB_EXTERN gboolean g_spawn_command_line_async_utf8 (const gchar           *command_line,
1368                                                        GError               **error);
1369 
1370 gboolean
1371 g_spawn_async_utf8 (const gchar          *working_directory,
<a name="77" id="anc77"></a><span class="line-modified">1372                           gchar               **argv,</span>
<span class="line-modified">1373                           gchar               **envp,</span>
<span class="line-modified">1374                           GSpawnFlags           flags,</span>
<span class="line-modified">1375                           GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1376                           gpointer              user_data,</span>
<span class="line-modified">1377                           GPid                 *child_handle,</span>
<span class="line-modified">1378                           GError              **error)</span>
1379 {
1380   return g_spawn_async (working_directory,
1381                         argv,
1382                         envp,
1383                         flags,
1384                         child_setup,
1385                         user_data,
<a name="78" id="anc78"></a><span class="line-modified">1386                       child_handle,</span>
<span class="line-modified">1387                       error);</span>
1388 }
1389 
1390 gboolean
1391 g_spawn_async_with_pipes_utf8 (const gchar          *working_directory,
<a name="79" id="anc79"></a><span class="line-modified">1392            gchar               **argv,</span>
<span class="line-modified">1393            gchar               **envp,</span>
<span class="line-modified">1394            GSpawnFlags           flags,</span>
<span class="line-modified">1395            GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1396            gpointer              user_data,</span>
<span class="line-modified">1397            GPid                 *child_handle,</span>
1398                                gint                 *standard_input,
1399                                gint                 *standard_output,
1400                                gint                 *standard_error,
<a name="80" id="anc80"></a><span class="line-modified">1401            GError              **error)</span>
1402 {
1403   return g_spawn_async_with_pipes (working_directory,
1404                                    argv,
1405                                    envp,
<a name="81" id="anc81"></a><span class="line-modified">1406                    flags,</span>
<span class="line-modified">1407                    child_setup,</span>
<span class="line-modified">1408                    user_data,</span>
<span class="line-modified">1409                    child_handle,</span>
1410                                    standard_input,
1411                                    standard_output,
1412                                    standard_error,
<a name="82" id="anc82"></a><span class="line-modified">1413                    error);</span>
1414 }
1415 
1416 gboolean
1417 g_spawn_sync_utf8 (const gchar          *working_directory,
<a name="83" id="anc83"></a><span class="line-modified">1418           gchar               **argv,</span>
<span class="line-modified">1419           gchar               **envp,</span>
<span class="line-modified">1420           GSpawnFlags           flags,</span>
<span class="line-modified">1421           GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1422           gpointer              user_data,</span>
<span class="line-modified">1423           gchar               **standard_output,</span>
<span class="line-modified">1424           gchar               **standard_error,</span>
<span class="line-modified">1425           gint                 *exit_status,</span>
<span class="line-modified">1426           GError              **error)</span>
1427 {
1428   return g_spawn_sync (working_directory,
1429                        argv,
1430                        envp,
1431                        flags,
1432                        child_setup,
1433                        user_data,
1434                        standard_output,
1435                        standard_error,
1436                        exit_status,
<a name="84" id="anc84"></a><span class="line-modified">1437                   error);</span>
1438 }
1439 
1440 gboolean
1441 g_spawn_command_line_sync_utf8 (const gchar  *command_line,
<a name="85" id="anc85"></a><span class="line-modified">1442                gchar       **standard_output,</span>
<span class="line-modified">1443                gchar       **standard_error,</span>
<span class="line-modified">1444                gint         *exit_status,</span>
<span class="line-modified">1445                GError      **error)</span>
1446 {
1447   return g_spawn_command_line_sync (command_line,
<a name="86" id="anc86"></a><span class="line-modified">1448                          standard_output,</span>
<span class="line-modified">1449                          standard_error,</span>
<span class="line-modified">1450                          exit_status,</span>
<span class="line-modified">1451                          error);</span>
1452 }
1453 
1454 gboolean
1455 g_spawn_command_line_async_utf8 (const gchar *command_line,
<a name="87" id="anc87"></a><span class="line-modified">1456                 GError     **error)</span>
1457 {
1458   return g_spawn_command_line_async (command_line, error);
1459 }
1460 
1461 #endif /* G_OS_WIN32 */
1462 #endif // GSTREAMER_LITE
1463 
1464 #endif /* !GSPAWN_HELPER */
<a name="88" id="anc88"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="88" type="hidden" />
</body>
</html>