<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstcollectpads.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstbasetransform.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstcollectpads.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstcollectpads.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  61  *   * gst_collect_pads_set_waiting() sets a pad to waiting or non-waiting mode.
  62  *     CollectPads element is not waiting for data to be collected on non-waiting pads.
  63  *     Thus these pads may but need not have data when the callback is called.
  64  *     All pads are in waiting mode by default.
  65  *
  66  */
  67 
  68 #ifdef HAVE_CONFIG_H
  69 #  include &quot;config.h&quot;
  70 #endif
  71 
  72 #include &lt;gst/gst_private.h&gt;
  73 
  74 #include &quot;gstcollectpads.h&quot;
  75 
  76 #include &quot;../../../gst/glib-compat-private.h&quot;
  77 
  78 GST_DEBUG_CATEGORY_STATIC (collect_pads_debug);
  79 #define GST_CAT_DEFAULT collect_pads_debug
  80 
<span class="line-removed">  81 #define parent_class gst_collect_pads_parent_class</span>
<span class="line-removed">  82 G_DEFINE_TYPE (GstCollectPads, gst_collect_pads, GST_TYPE_OBJECT);</span>
<span class="line-removed">  83 </span>
  84 struct _GstCollectDataPrivate
  85 {
  86   /* refcounting for struct, and destroy callback */
  87   GstCollectDataDestroyNotify destroy_notify;
  88   gint refcount;
  89 };
  90 
  91 struct _GstCollectPadsPrivate
  92 {
  93   /* with LOCK and/or STREAM_LOCK */
  94   gboolean started;
  95 
  96   /* with STREAM_LOCK */
  97   guint32 cookie;               /* pad_list cookie */
  98   guint numpads;                /* number of pads in @data */
  99   guint queuedpads;             /* number of pads with a buffer */
 100   guint eospads;                /* number of pads that are EOS */
 101   GstClockTime earliest_time;   /* Current earliest time */
 102   GstCollectData *earliest_data;        /* Pad data for current earliest time */
 103 
</pre>
<hr />
<pre>
 113   gpointer compare_user_data;
 114   GstCollectPadsEventFunction event_func;       /* function and data for event callback */
 115   gpointer event_user_data;
 116   GstCollectPadsQueryFunction query_func;
 117   gpointer query_user_data;
 118   GstCollectPadsClipFunction clip_func;
 119   gpointer clip_user_data;
 120   GstCollectPadsFlushFunction flush_func;
 121   gpointer flush_user_data;
 122 
 123   /* no other lock needed */
 124   GMutex evt_lock;              /* these make up sort of poor man&#39;s event signaling */
 125   GCond evt_cond;
 126   guint32 evt_cookie;
 127 
 128   gboolean seeking;
 129   gboolean pending_flush_start;
 130   gboolean pending_flush_stop;
 131 };
 132 



 133 static void gst_collect_pads_clear (GstCollectPads * pads,
 134     GstCollectData * data);
 135 static GstFlowReturn gst_collect_pads_chain (GstPad * pad, GstObject * parent,
 136     GstBuffer * buffer);
 137 static gboolean gst_collect_pads_event (GstPad * pad, GstObject * parent,
 138     GstEvent * event);
 139 static gboolean gst_collect_pads_query (GstPad * pad, GstObject * parent,
 140     GstQuery * query);
 141 static void gst_collect_pads_finalize (GObject * object);
 142 static GstFlowReturn gst_collect_pads_default_collected (GstCollectPads *
 143     pads, gpointer user_data);
 144 static gint gst_collect_pads_default_compare_func (GstCollectPads * pads,
 145     GstCollectData * data1, GstClockTime timestamp1, GstCollectData * data2,
 146     GstClockTime timestamp2, gpointer user_data);
 147 static gboolean gst_collect_pads_recalculate_full (GstCollectPads * pads);
 148 static void ref_data (GstCollectData * data);
 149 static void unref_data (GstCollectData * data);
 150 
 151 static gboolean gst_collect_pads_event_default_internal (GstCollectPads *
 152     pads, GstCollectData * data, GstEvent * event, gpointer user_data);
</pre>
<hr />
<pre>
 186   g_mutex_unlock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));          \
 187 } G_STMT_END
 188 #define GST_COLLECT_PADS_EVT_BROADCAST(pads) G_STMT_START {       \
 189   g_mutex_lock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));            \
 190   /* never mind wrap-around */                                     \
 191   ++(((GstCollectPads *) pads)-&gt;priv-&gt;evt_cookie);                      \
 192   g_cond_broadcast (GST_COLLECT_PADS_GET_EVT_COND (pads));        \
 193   g_mutex_unlock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));          \
 194 } G_STMT_END
 195 #define GST_COLLECT_PADS_EVT_INIT(cookie) G_STMT_START {          \
 196   g_mutex_lock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));            \
 197   cookie = ((GstCollectPads *) pads)-&gt;priv-&gt;evt_cookie;                 \
 198   g_mutex_unlock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));          \
 199 } G_STMT_END
 200 
 201 static void
 202 gst_collect_pads_class_init (GstCollectPadsClass * klass)
 203 {
 204   GObjectClass *gobject_class = (GObjectClass *) klass;
 205 
<span class="line-removed"> 206   g_type_class_add_private (klass, sizeof (GstCollectPadsPrivate));</span>
<span class="line-removed"> 207 </span>
 208   GST_DEBUG_CATEGORY_INIT (collect_pads_debug, &quot;collectpads&quot;, 0,
 209       &quot;GstCollectPads&quot;);
 210 
 211   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_collect_pads_finalize);
 212 }
 213 
 214 static void
 215 gst_collect_pads_init (GstCollectPads * pads)
 216 {
<span class="line-modified"> 217   pads-&gt;priv =</span>
<span class="line-removed"> 218       G_TYPE_INSTANCE_GET_PRIVATE (pads, GST_TYPE_COLLECT_PADS,</span>
<span class="line-removed"> 219       GstCollectPadsPrivate);</span>
 220 
 221   pads-&gt;data = NULL;
 222   pads-&gt;priv-&gt;cookie = 0;
 223   pads-&gt;priv-&gt;numpads = 0;
 224   pads-&gt;priv-&gt;queuedpads = 0;
 225   pads-&gt;priv-&gt;eospads = 0;
 226   pads-&gt;priv-&gt;started = FALSE;
 227 
 228   g_rec_mutex_init (&amp;pads-&gt;stream_lock);
 229 
 230   pads-&gt;priv-&gt;func = gst_collect_pads_default_collected;
 231   pads-&gt;priv-&gt;user_data = NULL;
 232   pads-&gt;priv-&gt;event_func = NULL;
 233   pads-&gt;priv-&gt;event_user_data = NULL;
 234 
 235   /* members for default muxing */
 236   pads-&gt;priv-&gt;buffer_func = NULL;
 237   pads-&gt;priv-&gt;buffer_user_data = NULL;
 238   pads-&gt;priv-&gt;compare_func = gst_collect_pads_default_compare_func;
 239   pads-&gt;priv-&gt;compare_user_data = NULL;
</pre>
<hr />
<pre>
 329   g_return_if_fail (pads != NULL);
 330   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 331 
 332   GST_OBJECT_LOCK (pads);
 333   gst_collect_pads_set_buffer_function_locked (pads, func, user_data);
 334   GST_OBJECT_UNLOCK (pads);
 335 }
 336 
 337 /**
 338  * gst_collect_pads_set_compare_function:
 339  * @pads: the pads to use
 340  * @func: (scope call): the function to set
 341  * @user_data: (closure): user data passed to the function
 342  *
 343  * Set the timestamp comparison function.
 344  *
 345  * MT safe.
 346  */
 347 /* NOTE allowing to change comparison seems not advisable;
 348 no known use-case, and collaboration with default algorithm is unpredictable.
<span class="line-modified"> 349 If custom compairing/operation is needed, just use a collect function of</span>
 350 your own */
 351 void
 352 gst_collect_pads_set_compare_function (GstCollectPads * pads,
 353     GstCollectPadsCompareFunction func, gpointer user_data)
 354 {
 355   g_return_if_fail (pads != NULL);
 356   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 357 
 358   GST_OBJECT_LOCK (pads);
 359   pads-&gt;priv-&gt;compare_func = func;
 360   pads-&gt;priv-&gt;compare_user_data = user_data;
 361   GST_OBJECT_UNLOCK (pads);
 362 }
 363 
 364 /**
 365  * gst_collect_pads_set_function:
 366  * @pads: the collectpads to use
 367  * @func: (scope call): the function to set
 368  * @user_data: user data passed to the function
 369  *
</pre>
</td>
<td>
<hr />
<pre>
  61  *   * gst_collect_pads_set_waiting() sets a pad to waiting or non-waiting mode.
  62  *     CollectPads element is not waiting for data to be collected on non-waiting pads.
  63  *     Thus these pads may but need not have data when the callback is called.
  64  *     All pads are in waiting mode by default.
  65  *
  66  */
  67 
  68 #ifdef HAVE_CONFIG_H
  69 #  include &quot;config.h&quot;
  70 #endif
  71 
  72 #include &lt;gst/gst_private.h&gt;
  73 
  74 #include &quot;gstcollectpads.h&quot;
  75 
  76 #include &quot;../../../gst/glib-compat-private.h&quot;
  77 
  78 GST_DEBUG_CATEGORY_STATIC (collect_pads_debug);
  79 #define GST_CAT_DEFAULT collect_pads_debug
  80 



  81 struct _GstCollectDataPrivate
  82 {
  83   /* refcounting for struct, and destroy callback */
  84   GstCollectDataDestroyNotify destroy_notify;
  85   gint refcount;
  86 };
  87 
  88 struct _GstCollectPadsPrivate
  89 {
  90   /* with LOCK and/or STREAM_LOCK */
  91   gboolean started;
  92 
  93   /* with STREAM_LOCK */
  94   guint32 cookie;               /* pad_list cookie */
  95   guint numpads;                /* number of pads in @data */
  96   guint queuedpads;             /* number of pads with a buffer */
  97   guint eospads;                /* number of pads that are EOS */
  98   GstClockTime earliest_time;   /* Current earliest time */
  99   GstCollectData *earliest_data;        /* Pad data for current earliest time */
 100 
</pre>
<hr />
<pre>
 110   gpointer compare_user_data;
 111   GstCollectPadsEventFunction event_func;       /* function and data for event callback */
 112   gpointer event_user_data;
 113   GstCollectPadsQueryFunction query_func;
 114   gpointer query_user_data;
 115   GstCollectPadsClipFunction clip_func;
 116   gpointer clip_user_data;
 117   GstCollectPadsFlushFunction flush_func;
 118   gpointer flush_user_data;
 119 
 120   /* no other lock needed */
 121   GMutex evt_lock;              /* these make up sort of poor man&#39;s event signaling */
 122   GCond evt_cond;
 123   guint32 evt_cookie;
 124 
 125   gboolean seeking;
 126   gboolean pending_flush_start;
 127   gboolean pending_flush_stop;
 128 };
 129 
<span class="line-added"> 130 #define parent_class gst_collect_pads_parent_class</span>
<span class="line-added"> 131 G_DEFINE_TYPE_WITH_PRIVATE (GstCollectPads, gst_collect_pads, GST_TYPE_OBJECT);</span>
<span class="line-added"> 132 </span>
 133 static void gst_collect_pads_clear (GstCollectPads * pads,
 134     GstCollectData * data);
 135 static GstFlowReturn gst_collect_pads_chain (GstPad * pad, GstObject * parent,
 136     GstBuffer * buffer);
 137 static gboolean gst_collect_pads_event (GstPad * pad, GstObject * parent,
 138     GstEvent * event);
 139 static gboolean gst_collect_pads_query (GstPad * pad, GstObject * parent,
 140     GstQuery * query);
 141 static void gst_collect_pads_finalize (GObject * object);
 142 static GstFlowReturn gst_collect_pads_default_collected (GstCollectPads *
 143     pads, gpointer user_data);
 144 static gint gst_collect_pads_default_compare_func (GstCollectPads * pads,
 145     GstCollectData * data1, GstClockTime timestamp1, GstCollectData * data2,
 146     GstClockTime timestamp2, gpointer user_data);
 147 static gboolean gst_collect_pads_recalculate_full (GstCollectPads * pads);
 148 static void ref_data (GstCollectData * data);
 149 static void unref_data (GstCollectData * data);
 150 
 151 static gboolean gst_collect_pads_event_default_internal (GstCollectPads *
 152     pads, GstCollectData * data, GstEvent * event, gpointer user_data);
</pre>
<hr />
<pre>
 186   g_mutex_unlock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));          \
 187 } G_STMT_END
 188 #define GST_COLLECT_PADS_EVT_BROADCAST(pads) G_STMT_START {       \
 189   g_mutex_lock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));            \
 190   /* never mind wrap-around */                                     \
 191   ++(((GstCollectPads *) pads)-&gt;priv-&gt;evt_cookie);                      \
 192   g_cond_broadcast (GST_COLLECT_PADS_GET_EVT_COND (pads));        \
 193   g_mutex_unlock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));          \
 194 } G_STMT_END
 195 #define GST_COLLECT_PADS_EVT_INIT(cookie) G_STMT_START {          \
 196   g_mutex_lock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));            \
 197   cookie = ((GstCollectPads *) pads)-&gt;priv-&gt;evt_cookie;                 \
 198   g_mutex_unlock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));          \
 199 } G_STMT_END
 200 
 201 static void
 202 gst_collect_pads_class_init (GstCollectPadsClass * klass)
 203 {
 204   GObjectClass *gobject_class = (GObjectClass *) klass;
 205 


 206   GST_DEBUG_CATEGORY_INIT (collect_pads_debug, &quot;collectpads&quot;, 0,
 207       &quot;GstCollectPads&quot;);
 208 
 209   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_collect_pads_finalize);
 210 }
 211 
 212 static void
 213 gst_collect_pads_init (GstCollectPads * pads)
 214 {
<span class="line-modified"> 215   pads-&gt;priv = gst_collect_pads_get_instance_private (pads);</span>


 216 
 217   pads-&gt;data = NULL;
 218   pads-&gt;priv-&gt;cookie = 0;
 219   pads-&gt;priv-&gt;numpads = 0;
 220   pads-&gt;priv-&gt;queuedpads = 0;
 221   pads-&gt;priv-&gt;eospads = 0;
 222   pads-&gt;priv-&gt;started = FALSE;
 223 
 224   g_rec_mutex_init (&amp;pads-&gt;stream_lock);
 225 
 226   pads-&gt;priv-&gt;func = gst_collect_pads_default_collected;
 227   pads-&gt;priv-&gt;user_data = NULL;
 228   pads-&gt;priv-&gt;event_func = NULL;
 229   pads-&gt;priv-&gt;event_user_data = NULL;
 230 
 231   /* members for default muxing */
 232   pads-&gt;priv-&gt;buffer_func = NULL;
 233   pads-&gt;priv-&gt;buffer_user_data = NULL;
 234   pads-&gt;priv-&gt;compare_func = gst_collect_pads_default_compare_func;
 235   pads-&gt;priv-&gt;compare_user_data = NULL;
</pre>
<hr />
<pre>
 325   g_return_if_fail (pads != NULL);
 326   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 327 
 328   GST_OBJECT_LOCK (pads);
 329   gst_collect_pads_set_buffer_function_locked (pads, func, user_data);
 330   GST_OBJECT_UNLOCK (pads);
 331 }
 332 
 333 /**
 334  * gst_collect_pads_set_compare_function:
 335  * @pads: the pads to use
 336  * @func: (scope call): the function to set
 337  * @user_data: (closure): user data passed to the function
 338  *
 339  * Set the timestamp comparison function.
 340  *
 341  * MT safe.
 342  */
 343 /* NOTE allowing to change comparison seems not advisable;
 344 no known use-case, and collaboration with default algorithm is unpredictable.
<span class="line-modified"> 345 If custom comparing/operation is needed, just use a collect function of</span>
 346 your own */
 347 void
 348 gst_collect_pads_set_compare_function (GstCollectPads * pads,
 349     GstCollectPadsCompareFunction func, gpointer user_data)
 350 {
 351   g_return_if_fail (pads != NULL);
 352   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 353 
 354   GST_OBJECT_LOCK (pads);
 355   pads-&gt;priv-&gt;compare_func = func;
 356   pads-&gt;priv-&gt;compare_user_data = user_data;
 357   GST_OBJECT_UNLOCK (pads);
 358 }
 359 
 360 /**
 361  * gst_collect_pads_set_function:
 362  * @pads: the collectpads to use
 363  * @func: (scope call): the function to set
 364  * @user_data: user data passed to the function
 365  *
</pre>
</td>
</tr>
</table>
<center><a href="gstbasetransform.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstcollectpads.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>