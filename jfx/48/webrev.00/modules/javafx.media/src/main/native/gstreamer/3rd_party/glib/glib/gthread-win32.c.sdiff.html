<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthread-win32.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gthread-posix.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gthread.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthread-win32.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
248 g_cond_wait (GCond  *cond,
249              GMutex *entered_mutex)
250 {
251   SleepConditionVariableSRW ((gpointer) cond, (gpointer) entered_mutex, INFINITE, 0);
252 }
253 
254 gboolean
255 g_cond_wait_until (GCond  *cond,
256                    GMutex *entered_mutex,
257                    gint64  end_time)
258 {
259   gint64 span, start_time;
260   DWORD span_millis;
261   gboolean signalled;
262 
263   start_time = g_get_monotonic_time ();
264   do
265     {
266       span = end_time - start_time;
267 
<span class="line-modified">268   if G_UNLIKELY (span &lt; 0)</span>
269         span_millis = 0;
270       else if G_UNLIKELY (span &gt; G_GINT64_CONSTANT (1000) * (DWORD) INFINITE)
271         span_millis = INFINITE;
272       else
273         /* Round up so we don&#39;t time out too early */
274         span_millis = (span + 1000 - 1) / 1000;
275 
276       /* We never want to wait infinitely */
277       if (span_millis &gt;= INFINITE)
278         span_millis = INFINITE - 1;
279 
280       signalled = SleepConditionVariableSRW ((gpointer) cond, (gpointer) entered_mutex, span_millis, 0);
281       if (signalled)
282         break;
283 
284       /* In case we didn&#39;t wait long enough after a timeout, wait again for the
285        * remaining time */
286       start_time = g_get_monotonic_time ();
<span class="line-modified">287 }</span>
288   while (start_time &lt; end_time);
289 
290   return signalled;
291 }
292 
293 /* {{{1 GPrivate */
294 
295 typedef struct _GPrivateDestructor GPrivateDestructor;
296 
297 struct _GPrivateDestructor
298 {
299   DWORD               index;
300   GDestroyNotify      notify;
301   GPrivateDestructor *next;
302 };
303 
304 static GPrivateDestructor * volatile g_private_destructors;
305 static CRITICAL_SECTION g_private_lock;
306 
307 static DWORD
</pre>
<hr />
<pre>
363                gpointer  value)
364 {
365   TlsSetValue (g_private_get_impl (key), value);
366 }
367 
368 void
369 g_private_replace (GPrivate *key,
370                    gpointer  value)
371 {
372   DWORD impl = g_private_get_impl (key);
373   gpointer old;
374 
375   old = TlsGetValue (impl);
376   if (old &amp;&amp; key-&gt;notify)
377     key-&gt;notify (old);
378   TlsSetValue (impl, value);
379 }
380 
381 /* {{{1 GThread */
382 
<span class="line-modified">383 #define win32_check_for_error(what) G_STMT_START{           \</span>
<span class="line-modified">384   if (!(what))                              \</span>
<span class="line-modified">385     g_error (&quot;file %s: line %d (%s): error %s during %s&quot;,       \</span>
<span class="line-modified">386          __FILE__, __LINE__, G_STRFUNC,             \</span>
<span class="line-modified">387          g_win32_error_message (GetLastError ()), #what);       \</span>
388   }G_STMT_END
389 
390 #define G_MUTEX_SIZE (sizeof (gpointer))
391 
392 typedef BOOL (__stdcall *GTryEnterCriticalSectionFunc) (CRITICAL_SECTION *);
393 
394 typedef struct
395 {
396   GRealThread thread;
397 
398   GThreadFunc proxy;
399   HANDLE      handle;
400 } GThreadWin32;
401 
402 void
403 g_system_thread_free (GRealThread *thread)
404 {
405   GThreadWin32 *wt = (GThreadWin32 *) thread;
406 
407   win32_check_for_error (CloseHandle (wt-&gt;handle));
</pre>
<hr />
<pre>
412 g_system_thread_exit (void)
413 {
414   _endthreadex (0);
415 }
416 
417 static guint __stdcall
418 g_thread_win32_proxy (gpointer data)
419 {
420   GThreadWin32 *self = data;
421 
422   self-&gt;proxy (self);
423 
424   g_system_thread_exit ();
425 
426   g_assert_not_reached ();
427 
428   return 0;
429 }
430 
431 GRealThread *
<span class="line-modified">432 g_system_thread_new (GThreadFunc   func,</span>
433                      gulong        stack_size,



434                      GError      **error)
435 {
436   GThreadWin32 *thread;

437   guint ignore;
438 
439   thread = g_slice_new0 (GThreadWin32);
<span class="line-modified">440   thread-&gt;proxy = func;</span>







441 
442   thread-&gt;handle = (HANDLE) _beginthreadex (NULL, stack_size, g_thread_win32_proxy, thread, 0, &amp;ignore);
443 
444   if (thread-&gt;handle == NULL)
445     {
446       gchar *win_error = g_win32_error_message (GetLastError ());
447       g_set_error (error, G_THREAD_ERROR, G_THREAD_ERROR_AGAIN,
448                    &quot;Error creating thread: %s&quot;, win_error);
449       g_free (win_error);
450       g_slice_free (GThreadWin32, thread);
451       return NULL;
452     }
453 
454   return (GRealThread *) thread;
455 }
456 
457 void
458 g_thread_yield (void)
459 {
460   Sleep(0);
</pre>
<hr />
<pre>
469 }
470 
471 #define EXCEPTION_SET_THREAD_NAME ((DWORD) 0x406D1388)
472 
473 #ifndef _MSC_VER
474 static void *SetThreadName_VEH_handle = NULL;
475 
476 static LONG __stdcall
477 SetThreadName_VEH (PEXCEPTION_POINTERS ExceptionInfo)
478 {
479   if (ExceptionInfo-&gt;ExceptionRecord != NULL &amp;&amp;
480       ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_SET_THREAD_NAME)
481     return EXCEPTION_CONTINUE_EXECUTION;
482 
483   return EXCEPTION_CONTINUE_SEARCH;
484 }
485 #endif
486 
487 typedef struct _THREADNAME_INFO
488 {
<span class="line-modified">489   DWORD  dwType;    /* must be 0x1000 */</span>
<span class="line-modified">490   LPCSTR szName;    /* pointer to name (in user addr space) */</span>
<span class="line-modified">491   DWORD  dwThreadID;    /* thread ID (-1=caller thread) */</span>
<span class="line-modified">492   DWORD  dwFlags;   /* reserved for future use, must be zero */</span>
493 } THREADNAME_INFO;
494 
495 static void
496 SetThreadName (DWORD  dwThreadID,
497                LPCSTR szThreadName)
498 {
499    THREADNAME_INFO info;
500    DWORD infosize;
501 
502    info.dwType = 0x1000;
503    info.szName = szThreadName;
504    info.dwThreadID = dwThreadID;
505    info.dwFlags = 0;
506 
507    infosize = sizeof (info) / sizeof (DWORD);
508 
509 #ifdef _MSC_VER
510    __try
511      {
512        RaiseException (EXCEPTION_SET_THREAD_NAME, 0, infosize, (DWORD *) &amp;info);
</pre>
</td>
<td>
<hr />
<pre>
248 g_cond_wait (GCond  *cond,
249              GMutex *entered_mutex)
250 {
251   SleepConditionVariableSRW ((gpointer) cond, (gpointer) entered_mutex, INFINITE, 0);
252 }
253 
254 gboolean
255 g_cond_wait_until (GCond  *cond,
256                    GMutex *entered_mutex,
257                    gint64  end_time)
258 {
259   gint64 span, start_time;
260   DWORD span_millis;
261   gboolean signalled;
262 
263   start_time = g_get_monotonic_time ();
264   do
265     {
266       span = end_time - start_time;
267 
<span class="line-modified">268       if G_UNLIKELY (span &lt; 0)</span>
269         span_millis = 0;
270       else if G_UNLIKELY (span &gt; G_GINT64_CONSTANT (1000) * (DWORD) INFINITE)
271         span_millis = INFINITE;
272       else
273         /* Round up so we don&#39;t time out too early */
274         span_millis = (span + 1000 - 1) / 1000;
275 
276       /* We never want to wait infinitely */
277       if (span_millis &gt;= INFINITE)
278         span_millis = INFINITE - 1;
279 
280       signalled = SleepConditionVariableSRW ((gpointer) cond, (gpointer) entered_mutex, span_millis, 0);
281       if (signalled)
282         break;
283 
284       /* In case we didn&#39;t wait long enough after a timeout, wait again for the
285        * remaining time */
286       start_time = g_get_monotonic_time ();
<span class="line-modified">287     }</span>
288   while (start_time &lt; end_time);
289 
290   return signalled;
291 }
292 
293 /* {{{1 GPrivate */
294 
295 typedef struct _GPrivateDestructor GPrivateDestructor;
296 
297 struct _GPrivateDestructor
298 {
299   DWORD               index;
300   GDestroyNotify      notify;
301   GPrivateDestructor *next;
302 };
303 
304 static GPrivateDestructor * volatile g_private_destructors;
305 static CRITICAL_SECTION g_private_lock;
306 
307 static DWORD
</pre>
<hr />
<pre>
363                gpointer  value)
364 {
365   TlsSetValue (g_private_get_impl (key), value);
366 }
367 
368 void
369 g_private_replace (GPrivate *key,
370                    gpointer  value)
371 {
372   DWORD impl = g_private_get_impl (key);
373   gpointer old;
374 
375   old = TlsGetValue (impl);
376   if (old &amp;&amp; key-&gt;notify)
377     key-&gt;notify (old);
378   TlsSetValue (impl, value);
379 }
380 
381 /* {{{1 GThread */
382 
<span class="line-modified">383 #define win32_check_for_error(what) G_STMT_START{     \</span>
<span class="line-modified">384   if (!(what))                \</span>
<span class="line-modified">385     g_error (&quot;file %s: line %d (%s): error %s during %s&quot;,   \</span>
<span class="line-modified">386        __FILE__, __LINE__, G_STRFUNC,       \</span>
<span class="line-modified">387        g_win32_error_message (GetLastError ()), #what);   \</span>
388   }G_STMT_END
389 
390 #define G_MUTEX_SIZE (sizeof (gpointer))
391 
392 typedef BOOL (__stdcall *GTryEnterCriticalSectionFunc) (CRITICAL_SECTION *);
393 
394 typedef struct
395 {
396   GRealThread thread;
397 
398   GThreadFunc proxy;
399   HANDLE      handle;
400 } GThreadWin32;
401 
402 void
403 g_system_thread_free (GRealThread *thread)
404 {
405   GThreadWin32 *wt = (GThreadWin32 *) thread;
406 
407   win32_check_for_error (CloseHandle (wt-&gt;handle));
</pre>
<hr />
<pre>
412 g_system_thread_exit (void)
413 {
414   _endthreadex (0);
415 }
416 
417 static guint __stdcall
418 g_thread_win32_proxy (gpointer data)
419 {
420   GThreadWin32 *self = data;
421 
422   self-&gt;proxy (self);
423 
424   g_system_thread_exit ();
425 
426   g_assert_not_reached ();
427 
428   return 0;
429 }
430 
431 GRealThread *
<span class="line-modified">432 g_system_thread_new (GThreadFunc   proxy,</span>
433                      gulong        stack_size,
<span class="line-added">434                      const char   *name,</span>
<span class="line-added">435                      GThreadFunc   func,</span>
<span class="line-added">436                      gpointer      data,</span>
437                      GError      **error)
438 {
439   GThreadWin32 *thread;
<span class="line-added">440   GRealThread *base_thread;</span>
441   guint ignore;
442 
443   thread = g_slice_new0 (GThreadWin32);
<span class="line-modified">444   thread-&gt;proxy = proxy;</span>
<span class="line-added">445   base_thread = (GRealThread*)thread;</span>
<span class="line-added">446   base_thread-&gt;ref_count = 2;</span>
<span class="line-added">447   base_thread-&gt;ours = TRUE;</span>
<span class="line-added">448   base_thread-&gt;thread.joinable = TRUE;</span>
<span class="line-added">449   base_thread-&gt;thread.func = func;</span>
<span class="line-added">450   base_thread-&gt;thread.data = data;</span>
<span class="line-added">451   base_thread-&gt;name = g_strdup (name);</span>
452 
453   thread-&gt;handle = (HANDLE) _beginthreadex (NULL, stack_size, g_thread_win32_proxy, thread, 0, &amp;ignore);
454 
455   if (thread-&gt;handle == NULL)
456     {
457       gchar *win_error = g_win32_error_message (GetLastError ());
458       g_set_error (error, G_THREAD_ERROR, G_THREAD_ERROR_AGAIN,
459                    &quot;Error creating thread: %s&quot;, win_error);
460       g_free (win_error);
461       g_slice_free (GThreadWin32, thread);
462       return NULL;
463     }
464 
465   return (GRealThread *) thread;
466 }
467 
468 void
469 g_thread_yield (void)
470 {
471   Sleep(0);
</pre>
<hr />
<pre>
480 }
481 
482 #define EXCEPTION_SET_THREAD_NAME ((DWORD) 0x406D1388)
483 
484 #ifndef _MSC_VER
485 static void *SetThreadName_VEH_handle = NULL;
486 
487 static LONG __stdcall
488 SetThreadName_VEH (PEXCEPTION_POINTERS ExceptionInfo)
489 {
490   if (ExceptionInfo-&gt;ExceptionRecord != NULL &amp;&amp;
491       ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_SET_THREAD_NAME)
492     return EXCEPTION_CONTINUE_EXECUTION;
493 
494   return EXCEPTION_CONTINUE_SEARCH;
495 }
496 #endif
497 
498 typedef struct _THREADNAME_INFO
499 {
<span class="line-modified">500   DWORD  dwType;  /* must be 0x1000 */</span>
<span class="line-modified">501   LPCSTR szName;  /* pointer to name (in user addr space) */</span>
<span class="line-modified">502   DWORD  dwThreadID;  /* thread ID (-1=caller thread) */</span>
<span class="line-modified">503   DWORD  dwFlags; /* reserved for future use, must be zero */</span>
504 } THREADNAME_INFO;
505 
506 static void
507 SetThreadName (DWORD  dwThreadID,
508                LPCSTR szThreadName)
509 {
510    THREADNAME_INFO info;
511    DWORD infosize;
512 
513    info.dwType = 0x1000;
514    info.szName = szThreadName;
515    info.dwThreadID = dwThreadID;
516    info.dwFlags = 0;
517 
518    infosize = sizeof (info) / sizeof (DWORD);
519 
520 #ifdef _MSC_VER
521    __try
522      {
523        RaiseException (EXCEPTION_SET_THREAD_NAME, 0, infosize, (DWORD *) &amp;info);
</pre>
</td>
</tr>
</table>
<center><a href="gthread-posix.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gthread.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>