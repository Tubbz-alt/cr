<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudioencoder.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2011 Mark Nauwelaerts &lt;mark.nauwelaerts@collabora.co.uk&gt;.
   3  * Copyright (C) 2011 Nokia Corporation. All rights reserved.
   4  *   Contact: Stefan Kost &lt;stefan.kost@nokia.com&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gstaudioencoder
  24  * @title: GstAudioEncoder
  25  * @short_description: Base class for audio encoders
  26  * @see_also: #GstBaseTransform
  27  *
  28  * This base class is for audio encoders turning raw audio samples into
  29  * encoded audio data.
  30  *
  31  * GstAudioEncoder and subclass should cooperate as follows.
  32  *
  33  * ## Configuration
  34  *
  35  *   * Initially, GstAudioEncoder calls @start when the encoder element
  36  *     is activated, which allows subclass to perform any global setup.
  37  *
  38  *   * GstAudioEncoder calls @set_format to inform subclass of the format
  39  *     of input audio data that it is about to receive.  Subclass should
  40  *     setup for encoding and configure various base class parameters
  41  *     appropriately, notably those directing desired input data handling.
  42  *     While unlikely, it might be called more than once, if changing input
  43  *     parameters require reconfiguration.
  44  *
  45  *   * GstAudioEncoder calls @stop at end of all processing.
  46  *
  47  * As of configuration stage, and throughout processing, GstAudioEncoder
  48  * maintains various parameters that provide required context,
  49  * e.g. describing the format of input audio data.
  50  * Conversely, subclass can and should configure these context parameters
  51  * to inform base class of its expectation w.r.t. buffer handling.
  52  *
  53  * ## Data processing
  54  *
  55  *     * Base class gathers input sample data (as directed by the context&#39;s
  56  *       frame_samples and frame_max) and provides this to subclass&#39; @handle_frame.
  57  *     * If codec processing results in encoded data, subclass should call
  58  *       gst_audio_encoder_finish_frame() to have encoded data pushed
  59  *       downstream. Alternatively, it might also call
  60  *       gst_audio_encoder_finish_frame() (with a NULL buffer and some number of
  61  *       dropped samples) to indicate dropped (non-encoded) samples.
  62  *     * Just prior to actually pushing a buffer downstream,
  63  *       it is passed to @pre_push.
  64  *     * During the parsing process GstAudioEncoderClass will handle both
  65  *       srcpad and sinkpad events. Sink events will be passed to subclass
  66  *       if @event callback has been provided.
  67  *
  68  * ## Shutdown phase
  69  *
  70  *   * GstAudioEncoder class calls @stop to inform the subclass that data
  71  *     parsing will be stopped.
  72  *
  73  * Subclass is responsible for providing pad template caps for
  74  * source and sink pads. The pads need to be named &quot;sink&quot; and &quot;src&quot;. It also
  75  * needs to set the fixed caps on srcpad, when the format is ensured.  This
  76  * is typically when base class calls subclass&#39; @set_format function, though
  77  * it might be delayed until calling @gst_audio_encoder_finish_frame.
  78  *
  79  * In summary, above process should have subclass concentrating on
  80  * codec data processing while leaving other matters to base class,
  81  * such as most notably timestamp handling.  While it may exert more control
  82  * in this area (see e.g. @pre_push), it is very much not recommended.
  83  *
  84  * In particular, base class will either favor tracking upstream timestamps
  85  * (at the possible expense of jitter) or aim to arrange for a perfect stream of
  86  * output timestamps, depending on #GstAudioEncoder:perfect-timestamp.
  87  * However, in the latter case, the input may not be so perfect or ideal, which
  88  * is handled as follows.  An input timestamp is compared with the expected
  89  * timestamp as dictated by input sample stream and if the deviation is less
  90  * than #GstAudioEncoder:tolerance, the deviation is discarded.
  91  * Otherwise, it is considered a discontuinity and subsequent output timestamp
  92  * is resynced to the new position after performing configured discontinuity
  93  * processing.  In the non-perfect-timestamp case, an upstream variation
  94  * exceeding tolerance only leads to marking DISCONT on subsequent outgoing
  95  * (while timestamps are adjusted to upstream regardless of variation).
  96  * While DISCONT is also marked in the perfect-timestamp case, this one
  97  * optionally (see #GstAudioEncoder:hard-resync)
  98  * performs some additional steps, such as clipping of (early) input samples
  99  * or draining all currently remaining input data, depending on the direction
 100  * of the discontuinity.
 101  *
 102  * If perfect timestamps are arranged, it is also possible to request baseclass
 103  * (usually set by subclass) to provide additional buffer metadata (in OFFSET
 104  * and OFFSET_END) fields according to granule defined semantics currently
 105  * needed by oggmux.  Specifically, OFFSET is set to granulepos (= sample count
 106  * including buffer) and OFFSET_END to corresponding timestamp (as determined
 107  * by same sample count and sample rate).
 108  *
 109  * Things that subclass need to take care of:
 110  *
 111  *   * Provide pad templates
 112  *   * Set source pad caps when appropriate
 113  *   * Inform base class of buffer processing needs using context&#39;s
 114  *      frame_samples and frame_bytes.
 115  *   * Set user-configurable properties to sane defaults for format and
 116  *      implementing codec at hand, e.g. those controlling timestamp behaviour
 117  *      and discontinuity processing.
 118  *   * Accept data in @handle_frame and provide encoded results to
 119  *      gst_audio_encoder_finish_frame().
 120  *
 121  */
 122 
 123 #ifdef HAVE_CONFIG_H
 124 #  include &quot;config.h&quot;
 125 #endif
 126 
 127 #include &quot;gstaudioencoder.h&quot;
 128 #include &quot;gstaudioutilsprivate.h&quot;
 129 #include &lt;gst/base/gstadapter.h&gt;
 130 #include &lt;gst/audio/audio.h&gt;
 131 #include &lt;gst/pbutils/descriptions.h&gt;
 132 
 133 #include &lt;stdlib.h&gt;
 134 #include &lt;string.h&gt;
 135 
 136 
 137 GST_DEBUG_CATEGORY_STATIC (gst_audio_encoder_debug);
 138 #define GST_CAT_DEFAULT gst_audio_encoder_debug
 139 
<a name="1" id="anc1"></a>



 140 enum
 141 {
 142   PROP_0,
 143   PROP_PERFECT_TS,
 144   PROP_GRANULE,
 145   PROP_HARD_RESYNC,
 146   PROP_TOLERANCE
 147 };
 148 
 149 #define DEFAULT_PERFECT_TS   FALSE
 150 #define DEFAULT_GRANULE      FALSE
 151 #define DEFAULT_HARD_RESYNC  FALSE
 152 #define DEFAULT_TOLERANCE    40000000
 153 #define DEFAULT_HARD_MIN     FALSE
 154 #define DEFAULT_DRAINABLE    TRUE
 155 
 156 typedef struct _GstAudioEncoderContext
 157 {
 158   /* input */
 159   /* last negotiated input caps */
 160   GstCaps *input_caps;
 161   /* last negotiated input info */
 162   GstAudioInfo info;
 163 
 164   /* output */
 165   GstCaps *caps;
 166   GstCaps *allocation_caps;
 167   gboolean output_caps_changed;
 168   gint frame_samples_min, frame_samples_max;
 169   gint frame_max;
 170   gint lookahead;
 171   /* MT-protected (with LOCK) */
 172   GstClockTime min_latency;
 173   GstClockTime max_latency;
 174 
 175   GList *headers;
 176   gboolean new_headers;
 177 
 178   GstAllocator *allocator;
 179   GstAllocationParams params;
 180 } GstAudioEncoderContext;
 181 
 182 struct _GstAudioEncoderPrivate
 183 {
 184   /* activation status */
 185   gboolean active;
 186 
 187   /* input base/first ts as basis for output ts;
 188    * kept nearly constant for perfect_ts,
 189    * otherwise resyncs to upstream ts */
 190   GstClockTime base_ts;
 191   /* corresponding base granulepos */
 192   gint64 base_gp;
 193   /* input samples processed and sent downstream so far (w.r.t. base_ts) */
 194   guint64 samples;
 195 
 196   /* currently collected sample data */
 197   GstAdapter *adapter;
 198   /* offset in adapter up to which already supplied to encoder */
 199   gint offset;
 200   /* mark outgoing discont */
 201   gboolean discont;
 202   /* to guess duration of drained data */
 203   GstClockTime last_duration;
 204 
 205   /* subclass provided data in processing round */
 206   gboolean got_data;
 207   /* subclass gave all it could already */
 208   gboolean drained;
 209   /* subclass currently being forcibly drained */
 210   gboolean force;
 211   /* need to handle changed input caps */
 212   gboolean do_caps;
 213 
 214   /* output bps estimatation */
 215   /* global in samples seen */
 216   guint64 samples_in;
 217   /* global bytes sent out */
 218   guint64 bytes_out;
 219 
 220   /* context storage */
 221   GstAudioEncoderContext ctx;
 222 
 223   /* properties */
 224   gint64 tolerance;
 225   gboolean perfect_ts;
 226   gboolean hard_resync;
 227   gboolean granule;
 228   gboolean hard_min;
 229   gboolean drainable;
 230 
 231   /* upstream stream tags (global tags are passed through as-is) */
 232   GstTagList *upstream_tags;
 233 
 234   /* subclass tags */
 235   GstTagList *tags;
 236   GstTagMergeMode tags_merge_mode;
 237 
 238   gboolean tags_changed;
 239 
 240   /* pending serialized sink events, will be sent from finish_frame() */
 241   GList *pending_events;
 242 };
 243 
 244 
 245 static GstElementClass *parent_class = NULL;
<a name="2" id="anc2"></a><span class="line-added"> 246 static gint private_offset = 0;</span>
 247 
 248 static void gst_audio_encoder_class_init (GstAudioEncoderClass * klass);
 249 static void gst_audio_encoder_init (GstAudioEncoder * parse,
 250     GstAudioEncoderClass * klass);
 251 
 252 GType
 253 gst_audio_encoder_get_type (void)
 254 {
 255   static GType audio_encoder_type = 0;
 256 
 257   if (!audio_encoder_type) {
 258     static const GTypeInfo audio_encoder_info = {
 259       sizeof (GstAudioEncoderClass),
 260       (GBaseInitFunc) NULL,
 261       (GBaseFinalizeFunc) NULL,
 262       (GClassInitFunc) gst_audio_encoder_class_init,
 263       NULL,
 264       NULL,
 265       sizeof (GstAudioEncoder),
 266       0,
 267       (GInstanceInitFunc) gst_audio_encoder_init,
 268     };
 269 #ifndef GSTREAMER_LITE
 270     const GInterfaceInfo preset_interface_info = {
 271       NULL,                     /* interface_init */
 272       NULL,                     /* interface_finalize */
 273       NULL                      /* interface_data */
 274     };
 275 #endif // GSTREAMER_LITE
 276 
 277     audio_encoder_type = g_type_register_static (GST_TYPE_ELEMENT,
 278         &quot;GstAudioEncoder&quot;, &amp;audio_encoder_info, G_TYPE_FLAG_ABSTRACT);
 279 
<a name="3" id="anc3"></a><span class="line-added"> 280     private_offset =</span>
<span class="line-added"> 281         g_type_add_instance_private (audio_encoder_type,</span>
<span class="line-added"> 282         sizeof (GstAudioEncoderPrivate));</span>
<span class="line-added"> 283 </span>
 284 #ifndef GSTREAMER_LITE
 285     g_type_add_interface_static (audio_encoder_type, GST_TYPE_PRESET,
 286         &amp;preset_interface_info);
 287 #endif // GSTREAMER_LITE
 288   }
 289   return audio_encoder_type;
 290 }
 291 
<a name="4" id="anc4"></a><span class="line-added"> 292 static inline GstAudioEncoderPrivate *</span>
<span class="line-added"> 293 gst_audio_encoder_get_instance_private (GstAudioEncoder * self)</span>
<span class="line-added"> 294 {</span>
<span class="line-added"> 295   return (G_STRUCT_MEMBER_P (self, private_offset));</span>
<span class="line-added"> 296 }</span>
<span class="line-added"> 297 </span>
 298 static void gst_audio_encoder_finalize (GObject * object);
 299 static void gst_audio_encoder_reset (GstAudioEncoder * enc, gboolean full);
 300 
 301 static void gst_audio_encoder_set_property (GObject * object,
 302     guint prop_id, const GValue * value, GParamSpec * pspec);
 303 static void gst_audio_encoder_get_property (GObject * object,
 304     guint prop_id, GValue * value, GParamSpec * pspec);
 305 
 306 static gboolean gst_audio_encoder_sink_activate_mode (GstPad * pad,
 307     GstObject * parent, GstPadMode mode, gboolean active);
 308 
 309 static GstCaps *gst_audio_encoder_getcaps_default (GstAudioEncoder * enc,
 310     GstCaps * filter);
 311 
 312 static gboolean gst_audio_encoder_sink_event_default (GstAudioEncoder * enc,
 313     GstEvent * event);
 314 static gboolean gst_audio_encoder_src_event_default (GstAudioEncoder * enc,
 315     GstEvent * event);
 316 static gboolean gst_audio_encoder_sink_event (GstPad * pad, GstObject * parent,
 317     GstEvent * event);
 318 static gboolean gst_audio_encoder_src_event (GstPad * pad, GstObject * parent,
 319     GstEvent * event);
 320 static gboolean gst_audio_encoder_sink_setcaps (GstAudioEncoder * enc,
 321     GstCaps * caps);
 322 static GstFlowReturn gst_audio_encoder_chain (GstPad * pad, GstObject * parent,
 323     GstBuffer * buffer);
 324 static gboolean gst_audio_encoder_src_query (GstPad * pad, GstObject * parent,
 325     GstQuery * query);
 326 static gboolean gst_audio_encoder_sink_query (GstPad * pad, GstObject * parent,
 327     GstQuery * query);
 328 static GstStateChangeReturn gst_audio_encoder_change_state (GstElement *
 329     element, GstStateChange transition);
 330 
 331 static gboolean gst_audio_encoder_decide_allocation_default (GstAudioEncoder *
 332     enc, GstQuery * query);
 333 static gboolean gst_audio_encoder_propose_allocation_default (GstAudioEncoder *
 334     enc, GstQuery * query);
 335 static gboolean gst_audio_encoder_negotiate_default (GstAudioEncoder * enc);
 336 static gboolean gst_audio_encoder_negotiate_unlocked (GstAudioEncoder * enc);
 337 
 338 static gboolean gst_audio_encoder_transform_meta_default (GstAudioEncoder *
 339     encoder, GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf);
 340 
 341 static gboolean gst_audio_encoder_sink_query_default (GstAudioEncoder * encoder,
 342     GstQuery * query);
 343 static gboolean gst_audio_encoder_src_query_default (GstAudioEncoder * encoder,
 344     GstQuery * query);
 345 
 346 static void
 347 gst_audio_encoder_class_init (GstAudioEncoderClass * klass)
 348 {
 349   GObjectClass *gobject_class;
 350   GstElementClass *gstelement_class;
 351 
 352   gobject_class = G_OBJECT_CLASS (klass);
 353   gstelement_class = GST_ELEMENT_CLASS (klass);
 354   parent_class = g_type_class_peek_parent (klass);
 355 
 356   GST_DEBUG_CATEGORY_INIT (gst_audio_encoder_debug, &quot;audioencoder&quot;, 0,
 357       &quot;audio encoder base class&quot;);
 358 
<a name="5" id="anc5"></a><span class="line-modified"> 359   if (private_offset != 0)</span>
<span class="line-added"> 360     g_type_class_adjust_private_offset (klass, &amp;private_offset);</span>
 361 
 362   gobject_class-&gt;set_property = gst_audio_encoder_set_property;
 363   gobject_class-&gt;get_property = gst_audio_encoder_get_property;
 364 
 365   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_audio_encoder_finalize);
 366 
 367   /* properties */
 368   g_object_class_install_property (gobject_class, PROP_PERFECT_TS,
 369       g_param_spec_boolean (&quot;perfect-timestamp&quot;, &quot;Perfect Timestamps&quot;,
 370           &quot;Favour perfect timestamps over tracking upstream timestamps&quot;,
 371           DEFAULT_PERFECT_TS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 372   g_object_class_install_property (gobject_class, PROP_GRANULE,
 373       g_param_spec_boolean (&quot;mark-granule&quot;, &quot;Granule Marking&quot;,
 374           &quot;Apply granule semantics to buffer metadata (implies perfect-timestamp)&quot;,
 375           DEFAULT_GRANULE, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 376   g_object_class_install_property (gobject_class, PROP_HARD_RESYNC,
 377       g_param_spec_boolean (&quot;hard-resync&quot;, &quot;Hard Resync&quot;,
 378           &quot;Perform clipping and sample flushing upon discontinuity&quot;,
 379           DEFAULT_HARD_RESYNC, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 380   g_object_class_install_property (gobject_class, PROP_TOLERANCE,
 381       g_param_spec_int64 (&quot;tolerance&quot;, &quot;Tolerance&quot;,
 382           &quot;Consider discontinuity if timestamp jitter/imperfection exceeds tolerance (ns)&quot;,
 383           0, G_MAXINT64, DEFAULT_TOLERANCE,
 384           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 385 
 386   gstelement_class-&gt;change_state =
 387       GST_DEBUG_FUNCPTR (gst_audio_encoder_change_state);
 388 
 389   klass-&gt;getcaps = gst_audio_encoder_getcaps_default;
 390   klass-&gt;sink_event = gst_audio_encoder_sink_event_default;
 391   klass-&gt;src_event = gst_audio_encoder_src_event_default;
 392   klass-&gt;sink_query = gst_audio_encoder_sink_query_default;
 393   klass-&gt;src_query = gst_audio_encoder_src_query_default;
 394   klass-&gt;propose_allocation = gst_audio_encoder_propose_allocation_default;
 395   klass-&gt;decide_allocation = gst_audio_encoder_decide_allocation_default;
 396   klass-&gt;negotiate = gst_audio_encoder_negotiate_default;
 397   klass-&gt;transform_meta = gst_audio_encoder_transform_meta_default;
 398 }
 399 
 400 static void
 401 gst_audio_encoder_init (GstAudioEncoder * enc, GstAudioEncoderClass * bclass)
 402 {
 403   GstPadTemplate *pad_template;
 404 
 405   GST_DEBUG_OBJECT (enc, &quot;gst_audio_encoder_init&quot;);
 406 
<a name="6" id="anc6"></a><span class="line-modified"> 407   enc-&gt;priv = gst_audio_encoder_get_instance_private (enc);</span>
 408 
 409   /* only push mode supported */
 410   pad_template =
 411       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 412   g_return_if_fail (pad_template != NULL);
 413   enc-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 414   gst_pad_set_event_function (enc-&gt;sinkpad,
 415       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_event));
 416   gst_pad_set_query_function (enc-&gt;sinkpad,
 417       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_query));
 418   gst_pad_set_chain_function (enc-&gt;sinkpad,
 419       GST_DEBUG_FUNCPTR (gst_audio_encoder_chain));
 420   gst_pad_set_activatemode_function (enc-&gt;sinkpad,
 421       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_activate_mode));
 422   gst_element_add_pad (GST_ELEMENT (enc), enc-&gt;sinkpad);
 423 
 424   GST_DEBUG_OBJECT (enc, &quot;sinkpad created&quot;);
 425 
 426   /* and we don&#39;t mind upstream traveling stuff that much ... */
 427   pad_template =
 428       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;src&quot;);
 429   g_return_if_fail (pad_template != NULL);
 430   enc-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 431   gst_pad_set_event_function (enc-&gt;srcpad,
 432       GST_DEBUG_FUNCPTR (gst_audio_encoder_src_event));
 433   gst_pad_set_query_function (enc-&gt;srcpad,
 434       GST_DEBUG_FUNCPTR (gst_audio_encoder_src_query));
 435   gst_pad_use_fixed_caps (enc-&gt;srcpad);
 436   gst_element_add_pad (GST_ELEMENT (enc), enc-&gt;srcpad);
 437   GST_DEBUG_OBJECT (enc, &quot;src created&quot;);
 438 
 439   enc-&gt;priv-&gt;adapter = gst_adapter_new ();
 440 
 441   g_rec_mutex_init (&amp;enc-&gt;stream_lock);
 442 
 443   /* property default */
 444   enc-&gt;priv-&gt;granule = DEFAULT_GRANULE;
 445   enc-&gt;priv-&gt;perfect_ts = DEFAULT_PERFECT_TS;
 446   enc-&gt;priv-&gt;hard_resync = DEFAULT_HARD_RESYNC;
 447   enc-&gt;priv-&gt;tolerance = DEFAULT_TOLERANCE;
 448   enc-&gt;priv-&gt;hard_min = DEFAULT_HARD_MIN;
 449   enc-&gt;priv-&gt;drainable = DEFAULT_DRAINABLE;
 450 
 451   /* init state */
 452   enc-&gt;priv-&gt;ctx.min_latency = 0;
 453   enc-&gt;priv-&gt;ctx.max_latency = 0;
 454   gst_audio_encoder_reset (enc, TRUE);
 455   GST_DEBUG_OBJECT (enc, &quot;init ok&quot;);
 456 }
 457 
 458 static void
 459 gst_audio_encoder_reset (GstAudioEncoder * enc, gboolean full)
 460 {
 461   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
 462 
 463   GST_LOG_OBJECT (enc, &quot;reset full %d&quot;, full);
 464 
 465   if (full) {
 466     enc-&gt;priv-&gt;active = FALSE;
 467     GST_OBJECT_LOCK (enc);
 468     enc-&gt;priv-&gt;samples_in = 0;
 469     enc-&gt;priv-&gt;bytes_out = 0;
 470     GST_OBJECT_UNLOCK (enc);
 471 
 472     g_list_foreach (enc-&gt;priv-&gt;ctx.headers, (GFunc) gst_buffer_unref, NULL);
 473     g_list_free (enc-&gt;priv-&gt;ctx.headers);
 474     enc-&gt;priv-&gt;ctx.headers = NULL;
 475     enc-&gt;priv-&gt;ctx.new_headers = FALSE;
 476 
 477     if (enc-&gt;priv-&gt;ctx.allocator)
 478       gst_object_unref (enc-&gt;priv-&gt;ctx.allocator);
 479     enc-&gt;priv-&gt;ctx.allocator = NULL;
 480 
 481     GST_OBJECT_LOCK (enc);
 482     gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.input_caps, NULL);
 483     gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.caps, NULL);
 484     gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.allocation_caps, NULL);
 485 
 486     memset (&amp;enc-&gt;priv-&gt;ctx, 0, sizeof (enc-&gt;priv-&gt;ctx));
 487     gst_audio_info_init (&amp;enc-&gt;priv-&gt;ctx.info);
 488     GST_OBJECT_UNLOCK (enc);
 489 
 490     if (enc-&gt;priv-&gt;upstream_tags) {
 491       gst_tag_list_unref (enc-&gt;priv-&gt;upstream_tags);
 492       enc-&gt;priv-&gt;upstream_tags = NULL;
 493     }
 494     if (enc-&gt;priv-&gt;tags)
 495       gst_tag_list_unref (enc-&gt;priv-&gt;tags);
 496     enc-&gt;priv-&gt;tags = NULL;
 497     enc-&gt;priv-&gt;tags_merge_mode = GST_TAG_MERGE_APPEND;
 498     enc-&gt;priv-&gt;tags_changed = FALSE;
 499 
 500     g_list_foreach (enc-&gt;priv-&gt;pending_events, (GFunc) gst_event_unref, NULL);
 501     g_list_free (enc-&gt;priv-&gt;pending_events);
 502     enc-&gt;priv-&gt;pending_events = NULL;
 503   }
 504 
 505   gst_segment_init (&amp;enc-&gt;input_segment, GST_FORMAT_TIME);
 506   gst_segment_init (&amp;enc-&gt;output_segment, GST_FORMAT_TIME);
 507 
 508   gst_adapter_clear (enc-&gt;priv-&gt;adapter);
 509   enc-&gt;priv-&gt;got_data = FALSE;
 510   enc-&gt;priv-&gt;drained = TRUE;
 511   enc-&gt;priv-&gt;offset = 0;
 512   enc-&gt;priv-&gt;base_ts = GST_CLOCK_TIME_NONE;
 513   enc-&gt;priv-&gt;base_gp = -1;
 514   enc-&gt;priv-&gt;samples = 0;
 515   enc-&gt;priv-&gt;discont = FALSE;
 516 
 517   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
 518 }
 519 
 520 static void
 521 gst_audio_encoder_finalize (GObject * object)
 522 {
 523   GstAudioEncoder *enc = GST_AUDIO_ENCODER (object);
 524 
 525   g_object_unref (enc-&gt;priv-&gt;adapter);
 526 
 527   g_rec_mutex_clear (&amp;enc-&gt;stream_lock);
 528 
 529   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 530 }
 531 
 532 static GstStateChangeReturn
 533 gst_audio_encoder_change_state (GstElement * element, GstStateChange transition)
 534 {
 535   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
 536   GstAudioEncoder *enc = GST_AUDIO_ENCODER (element);
 537   GstAudioEncoderClass *klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
 538 
 539   switch (transition) {
 540     case GST_STATE_CHANGE_NULL_TO_READY:
 541       if (klass-&gt;open) {
 542         if (!klass-&gt;open (enc))
 543           goto open_failed;
 544       }
 545     default:
 546       break;
 547   }
 548 
 549   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
 550 
 551   switch (transition) {
 552     case GST_STATE_CHANGE_READY_TO_NULL:
 553       if (klass-&gt;close) {
 554         if (!klass-&gt;close (enc))
 555           goto close_failed;
 556       }
 557     default:
 558       break;
 559   }
 560 
 561   return ret;
 562 
 563 open_failed:
 564   {
 565     GST_ELEMENT_ERROR (enc, LIBRARY, INIT, (NULL), (&quot;Failed to open codec&quot;));
 566     return GST_STATE_CHANGE_FAILURE;
 567   }
 568 close_failed:
 569   {
 570     GST_ELEMENT_ERROR (enc, LIBRARY, INIT, (NULL), (&quot;Failed to close codec&quot;));
 571     return GST_STATE_CHANGE_FAILURE;
 572   }
 573 }
 574 
 575 static gboolean
 576 gst_audio_encoder_push_event (GstAudioEncoder * enc, GstEvent * event)
 577 {
 578   switch (GST_EVENT_TYPE (event)) {
 579     case GST_EVENT_SEGMENT:{
 580       GstSegment seg;
 581 
 582       GST_AUDIO_ENCODER_STREAM_LOCK (enc);
 583       gst_event_copy_segment (event, &amp;seg);
 584 
 585       GST_DEBUG_OBJECT (enc, &quot;starting segment %&quot; GST_SEGMENT_FORMAT, &amp;seg);
 586 
 587       enc-&gt;output_segment = seg;
 588       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
 589       break;
 590     }
 591     default:
 592       break;
 593   }
 594 
 595   return gst_pad_push_event (enc-&gt;srcpad, event);
 596 }
 597 
 598 static inline void
 599 gst_audio_encoder_push_pending_events (GstAudioEncoder * enc)
 600 {
 601   GstAudioEncoderPrivate *priv = enc-&gt;priv;
 602 
 603   if (priv-&gt;pending_events) {
 604     GList *pending_events, *l;
 605 
 606     pending_events = priv-&gt;pending_events;
 607     priv-&gt;pending_events = NULL;
 608 
 609     GST_DEBUG_OBJECT (enc, &quot;Pushing pending events&quot;);
 610     for (l = pending_events; l; l = l-&gt;next)
 611       gst_audio_encoder_push_event (enc, l-&gt;data);
 612     g_list_free (pending_events);
 613   }
 614 }
 615 
 616 static GstEvent *
 617 gst_audio_encoder_create_merged_tags_event (GstAudioEncoder * enc)
 618 {
 619   GstTagList *merged_tags;
 620 
 621   GST_LOG_OBJECT (enc, &quot;upstream : %&quot; GST_PTR_FORMAT, enc-&gt;priv-&gt;upstream_tags);
 622   GST_LOG_OBJECT (enc, &quot;encoder  : %&quot; GST_PTR_FORMAT, enc-&gt;priv-&gt;tags);
 623   GST_LOG_OBJECT (enc, &quot;mode     : %d&quot;, enc-&gt;priv-&gt;tags_merge_mode);
 624 
 625   merged_tags =
 626       gst_tag_list_merge (enc-&gt;priv-&gt;upstream_tags, enc-&gt;priv-&gt;tags,
 627       enc-&gt;priv-&gt;tags_merge_mode);
 628 
 629   GST_DEBUG_OBJECT (enc, &quot;merged   : %&quot; GST_PTR_FORMAT, merged_tags);
 630 
 631   if (merged_tags == NULL)
 632     return NULL;
 633 
 634   if (gst_tag_list_is_empty (merged_tags)) {
 635     gst_tag_list_unref (merged_tags);
 636     return NULL;
 637   }
 638 
<a name="7" id="anc7"></a><span class="line-modified"> 639   /* add codec info to pending tags */</span>
 640 #if 0
<a name="8" id="anc8"></a><span class="line-modified"> 641   caps = gst_pad_get_current_caps (enc-&gt;srcpad);</span>
 642   gst_pb_utils_add_codec_description_to_tag_list (merged_tags,
<a name="9" id="anc9"></a><span class="line-modified"> 643       GST_TAG_AUDIO_CODEC, caps);</span>
 644 #endif
 645 
 646   return gst_event_new_tag (merged_tags);
 647 }
 648 
 649 static void
 650 gst_audio_encoder_check_and_push_pending_tags (GstAudioEncoder * enc)
 651 {
 652   if (enc-&gt;priv-&gt;tags_changed) {
 653     GstEvent *tags_event;
 654 
 655     tags_event = gst_audio_encoder_create_merged_tags_event (enc);
 656 
 657     if (tags_event != NULL)
 658       gst_audio_encoder_push_event (enc, tags_event);
 659 
 660     enc-&gt;priv-&gt;tags_changed = FALSE;
 661   }
 662 }
 663 
 664 
 665 static gboolean
 666 gst_audio_encoder_transform_meta_default (GstAudioEncoder *
 667     encoder, GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf)
 668 {
 669   const GstMetaInfo *info = meta-&gt;info;
 670   const gchar *const *tags;
 671 
 672   tags = gst_meta_api_type_get_tags (info-&gt;api);
 673 
 674   if (!tags || (g_strv_length ((gchar **) tags) == 1
 675           &amp;&amp; gst_meta_api_type_has_tag (info-&gt;api,
 676               g_quark_from_string (GST_META_TAG_AUDIO_STR))))
 677     return TRUE;
 678 
 679   return FALSE;
 680 }
 681 
 682 typedef struct
 683 {
 684   GstAudioEncoder *encoder;
 685   GstBuffer *outbuf;
 686 } CopyMetaData;
 687 
 688 static gboolean
 689 foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
 690 {
 691   CopyMetaData *data = user_data;
 692   GstAudioEncoder *encoder = data-&gt;encoder;
 693   GstAudioEncoderClass *klass = GST_AUDIO_ENCODER_GET_CLASS (encoder);
 694   GstBuffer *outbuf = data-&gt;outbuf;
 695   const GstMetaInfo *info = (*meta)-&gt;info;
 696   gboolean do_copy = FALSE;
 697 
 698   if (gst_meta_api_type_has_tag (info-&gt;api, _gst_meta_tag_memory)) {
 699     /* never call the transform_meta with memory specific metadata */
 700     GST_DEBUG_OBJECT (encoder, &quot;not copying memory specific metadata %s&quot;,
 701         g_type_name (info-&gt;api));
 702     do_copy = FALSE;
 703   } else if (klass-&gt;transform_meta) {
 704     do_copy = klass-&gt;transform_meta (encoder, outbuf, *meta, inbuf);
 705     GST_DEBUG_OBJECT (encoder, &quot;transformed metadata %s: copy: %d&quot;,
 706         g_type_name (info-&gt;api), do_copy);
 707   }
 708 
 709   /* we only copy metadata when the subclass implemented a transform_meta
 710    * function and when it returns %TRUE */
 711   if (do_copy &amp;&amp; info-&gt;transform_func) {
 712     GstMetaTransformCopy copy_data = { FALSE, 0, -1 };
 713     GST_DEBUG_OBJECT (encoder, &quot;copy metadata %s&quot;, g_type_name (info-&gt;api));
 714     /* simply copy then */
 715     info-&gt;transform_func (outbuf, *meta, inbuf,
 716         _gst_meta_transform_copy, &amp;copy_data);
 717   }
 718   return TRUE;
 719 }
 720 
 721 /**
 722  * gst_audio_encoder_finish_frame:
 723  * @enc: a #GstAudioEncoder
 724  * @buffer: encoded data
 725  * @samples: number of samples (per channel) represented by encoded data
 726  *
 727  * Collects encoded data and pushes encoded data downstream.
 728  * Source pad caps must be set when this is called.
 729  *
 730  * If @samples &lt; 0, then best estimate is all samples provided to encoder
 731  * (subclass) so far.  @buf may be NULL, in which case next number of @samples
 732  * are considered discarded, e.g. as a result of discontinuous transmission,
 733  * and a discontinuity is marked.
 734  *
<a name="10" id="anc10"></a><span class="line-modified"> 735  * Note that samples received in #GstAudioEncoderClass.handle_frame()</span>
 736  * may be invalidated by a call to this function.
 737  *
 738  * Returns: a #GstFlowReturn that should be escalated to caller (of caller)
 739  */
 740 GstFlowReturn
 741 gst_audio_encoder_finish_frame (GstAudioEncoder * enc, GstBuffer * buf,
 742     gint samples)
 743 {
 744   GstAudioEncoderClass *klass;
 745   GstAudioEncoderPrivate *priv;
 746   GstAudioEncoderContext *ctx;
 747   GstFlowReturn ret = GST_FLOW_OK;
 748   gboolean needs_reconfigure = FALSE;
 749   GstBuffer *inbuf = NULL;
 750 
 751   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
 752   priv = enc-&gt;priv;
 753   ctx = &amp;enc-&gt;priv-&gt;ctx;
 754 
 755   /* subclass should not hand us no data */
 756   g_return_val_if_fail (buf == NULL || gst_buffer_get_size (buf) &gt; 0,
 757       GST_FLOW_ERROR);
 758 
 759   /* subclass should know what it is producing by now */
 760   if (!ctx-&gt;caps)
 761     goto no_caps;
 762 
 763   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
 764 
 765   GST_LOG_OBJECT (enc,
 766       &quot;accepting %&quot; G_GSIZE_FORMAT &quot; bytes encoded data as %d samples&quot;,
 767       buf ? gst_buffer_get_size (buf) : -1, samples);
 768 
 769   needs_reconfigure = gst_pad_check_reconfigure (enc-&gt;srcpad);
 770   if (G_UNLIKELY (ctx-&gt;output_caps_changed || needs_reconfigure)) {
 771     if (!gst_audio_encoder_negotiate_unlocked (enc)) {
 772       gst_pad_mark_reconfigure (enc-&gt;srcpad);
 773       if (GST_PAD_IS_FLUSHING (enc-&gt;srcpad))
 774         ret = GST_FLOW_FLUSHING;
 775       else
 776         ret = GST_FLOW_NOT_NEGOTIATED;
 777       if (buf)
 778         gst_buffer_unref (buf);
 779       goto exit;
 780     }
 781   }
 782 
 783   /* mark subclass still alive and providing */
 784   if (G_LIKELY (buf))
 785     priv-&gt;got_data = TRUE;
 786 
 787   gst_audio_encoder_push_pending_events (enc);
 788 
 789   /* send after pending events, which likely includes segment event */
 790   gst_audio_encoder_check_and_push_pending_tags (enc);
 791 
 792   /* remove corresponding samples from input */
 793   if (samples &lt; 0)
 794     samples = (enc-&gt;priv-&gt;offset / ctx-&gt;info.bpf);
 795 
 796   if (G_LIKELY (samples)) {
 797     /* track upstream ts if so configured */
 798     if (!enc-&gt;priv-&gt;perfect_ts) {
 799       guint64 ts, distance;
 800 
 801       ts = gst_adapter_prev_pts (priv-&gt;adapter, &amp;distance);
 802       g_assert (distance % ctx-&gt;info.bpf == 0);
 803       distance /= ctx-&gt;info.bpf;
 804       GST_LOG_OBJECT (enc, &quot;%&quot; G_GUINT64_FORMAT &quot; samples past prev_ts %&quot;
 805           GST_TIME_FORMAT, distance, GST_TIME_ARGS (ts));
 806       GST_LOG_OBJECT (enc, &quot;%&quot; G_GUINT64_FORMAT &quot; samples past base_ts %&quot;
 807           GST_TIME_FORMAT, priv-&gt;samples, GST_TIME_ARGS (priv-&gt;base_ts));
 808       /* when draining adapter might be empty and no ts to offer */
 809       if (GST_CLOCK_TIME_IS_VALID (ts) &amp;&amp; ts != priv-&gt;base_ts) {
 810         GstClockTimeDiff diff;
 811         GstClockTime old_ts, next_ts;
 812 
 813         /* passed into another buffer;
 814          * mild check for discontinuity and only mark if so */
 815         next_ts = ts +
 816             gst_util_uint64_scale (distance, GST_SECOND, ctx-&gt;info.rate);
 817         old_ts = priv-&gt;base_ts +
 818             gst_util_uint64_scale (priv-&gt;samples, GST_SECOND, ctx-&gt;info.rate);
 819         diff = GST_CLOCK_DIFF (next_ts, old_ts);
 820         GST_LOG_OBJECT (enc, &quot;ts diff %d ms&quot;, (gint) (diff / GST_MSECOND));
 821         /* only mark discontinuity if beyond tolerance */
 822         if (G_UNLIKELY (diff &lt; -enc-&gt;priv-&gt;tolerance ||
 823                 diff &gt; enc-&gt;priv-&gt;tolerance)) {
 824           GST_DEBUG_OBJECT (enc, &quot;marked discont&quot;);
 825           priv-&gt;discont = TRUE;
 826         }
 827         if (diff &gt; GST_SECOND / ctx-&gt;info.rate / 2 ||
 828             diff &lt; -GST_SECOND / ctx-&gt;info.rate / 2) {
 829           GST_LOG_OBJECT (enc, &quot;new upstream ts %&quot; GST_TIME_FORMAT
 830               &quot; at distance %&quot; G_GUINT64_FORMAT, GST_TIME_ARGS (ts), distance);
 831           /* re-sync to upstream ts */
 832           priv-&gt;base_ts = ts;
 833           priv-&gt;samples = distance;
 834         } else {
 835           GST_LOG_OBJECT (enc, &quot;new upstream ts only introduces jitter&quot;);
 836         }
 837       }
 838     }
 839     /* advance sample view */
 840     if (G_UNLIKELY (samples * ctx-&gt;info.bpf &gt; priv-&gt;offset)) {
 841       guint avail = gst_adapter_available (priv-&gt;adapter);
 842 
 843       if (G_LIKELY (!priv-&gt;force)) {
 844         /* we should have received EOS to enable force */
 845         goto overflow;
 846       } else {
 847         priv-&gt;offset = 0;
 848         if (avail &gt; 0 &amp;&amp; samples * ctx-&gt;info.bpf &gt;= avail) {
 849           inbuf = gst_adapter_take_buffer_fast (priv-&gt;adapter, avail);
 850           gst_adapter_clear (priv-&gt;adapter);
 851         } else if (avail &gt; 0) {
 852           inbuf =
 853               gst_adapter_take_buffer_fast (priv-&gt;adapter,
 854               samples * ctx-&gt;info.bpf);
<a name="11" id="anc11"></a><span class="line-modified"> 855         }</span>
 856       }
 857     } else {
 858       guint avail = gst_adapter_available (priv-&gt;adapter);
 859 
 860       if (avail &gt; 0) {
 861         inbuf =
 862             gst_adapter_take_buffer_fast (priv-&gt;adapter,
 863             samples * ctx-&gt;info.bpf);
 864       }
 865       priv-&gt;offset -= samples * ctx-&gt;info.bpf;
 866       /* avoid subsequent stray prev_ts */
 867       if (G_UNLIKELY (gst_adapter_available (priv-&gt;adapter) == 0))
 868         gst_adapter_clear (priv-&gt;adapter);
 869     }
 870     /* sample count advanced below after buffer handling */
 871   }
 872 
 873   /* collect output */
 874   if (G_LIKELY (buf)) {
 875     gsize size;
 876 
 877     /* Pushing headers first */
 878     if (G_UNLIKELY (priv-&gt;ctx.new_headers)) {
 879       GList *tmp;
 880 
 881       GST_DEBUG_OBJECT (enc, &quot;Sending headers&quot;);
 882 
 883       for (tmp = priv-&gt;ctx.headers; tmp; tmp = tmp-&gt;next) {
 884         GstBuffer *tmpbuf = gst_buffer_ref (tmp-&gt;data);
 885 
 886         tmpbuf = gst_buffer_make_writable (tmpbuf);
 887         size = gst_buffer_get_size (tmpbuf);
 888 
 889         if (G_UNLIKELY (priv-&gt;discont)) {
 890           GST_LOG_OBJECT (enc, &quot;marking discont&quot;);
 891           GST_BUFFER_FLAG_SET (tmpbuf, GST_BUFFER_FLAG_DISCONT);
 892           priv-&gt;discont = FALSE;
 893         }
 894 
 895         /* Ogg codecs like Vorbis use offset/offset-end in a special
 896          * way and both should be 0 for these codecs */
 897         if (priv-&gt;base_gp &gt;= 0) {
 898           GST_BUFFER_OFFSET (tmpbuf) = 0;
 899           GST_BUFFER_OFFSET_END (tmpbuf) = 0;
 900         } else {
 901           GST_BUFFER_OFFSET (tmpbuf) = priv-&gt;bytes_out;
 902           GST_BUFFER_OFFSET_END (tmpbuf) = priv-&gt;bytes_out + size;
 903         }
 904 
 905         GST_OBJECT_LOCK (enc);
 906         priv-&gt;bytes_out += size;
 907         GST_OBJECT_UNLOCK (enc);
 908 
 909         ret = gst_pad_push (enc-&gt;srcpad, tmpbuf);
 910         if (ret != GST_FLOW_OK) {
 911           GST_WARNING_OBJECT (enc, &quot;pushing header returned %s&quot;,
 912               gst_flow_get_name (ret));
 913           goto exit;
<a name="12" id="anc12"></a><span class="line-modified"> 914         }</span>
 915       }
 916       priv-&gt;ctx.new_headers = FALSE;
 917     }
 918 
 919     size = gst_buffer_get_size (buf);
 920 
 921     GST_LOG_OBJECT (enc, &quot;taking %&quot; G_GSIZE_FORMAT &quot; bytes for output&quot;, size);
 922     buf = gst_buffer_make_writable (buf);
 923 
 924     /* decorate */
 925     if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts))) {
 926       /* FIXME ? lookahead could lead to weird ts and duration ?
 927        * (particularly if not in perfect mode) */
 928       /* mind sample rounding and produce perfect output */
 929       GST_BUFFER_TIMESTAMP (buf) = priv-&gt;base_ts +
 930           gst_util_uint64_scale (priv-&gt;samples - ctx-&gt;lookahead, GST_SECOND,
 931           ctx-&gt;info.rate);
 932       GST_BUFFER_DTS (buf) = GST_BUFFER_TIMESTAMP (buf);
 933       GST_DEBUG_OBJECT (enc, &quot;out samples %d&quot;, samples);
 934       if (G_LIKELY (samples &gt; 0)) {
 935         priv-&gt;samples += samples;
 936         GST_BUFFER_DURATION (buf) = priv-&gt;base_ts +
 937             gst_util_uint64_scale (priv-&gt;samples - ctx-&gt;lookahead, GST_SECOND,
 938             ctx-&gt;info.rate) - GST_BUFFER_TIMESTAMP (buf);
 939         priv-&gt;last_duration = GST_BUFFER_DURATION (buf);
 940       } else {
 941         /* duration forecast in case of handling remainder;
 942          * the last one is probably like the previous one ... */
 943         GST_BUFFER_DURATION (buf) = priv-&gt;last_duration;
 944       }
 945       if (priv-&gt;base_gp &gt;= 0) {
 946         /* pamper oggmux */
 947         /* FIXME: in longer run, muxer should take care of this ... */
 948         /* offset_end = granulepos for ogg muxer */
 949         GST_BUFFER_OFFSET_END (buf) = priv-&gt;base_gp + priv-&gt;samples -
 950             enc-&gt;priv-&gt;ctx.lookahead;
 951         /* offset = timestamp corresponding to granulepos for ogg muxer */
 952         GST_BUFFER_OFFSET (buf) =
 953             GST_FRAMES_TO_CLOCK_TIME (GST_BUFFER_OFFSET_END (buf),
 954             ctx-&gt;info.rate);
 955       } else {
 956         GST_BUFFER_OFFSET (buf) = priv-&gt;bytes_out;
 957         GST_BUFFER_OFFSET_END (buf) = priv-&gt;bytes_out + size;
 958       }
 959     }
 960 
 961     if (klass-&gt;transform_meta) {
 962       if (G_LIKELY (inbuf)) {
 963         CopyMetaData data;
 964 
 965         data.encoder = enc;
 966         data.outbuf = buf;
 967         gst_buffer_foreach_meta (inbuf, foreach_metadata, &amp;data);
 968       } else {
 969         GST_WARNING_OBJECT (enc,
 970             &quot;Can&#39;t copy metadata because input buffer disappeared&quot;);
 971       }
 972     }
 973 
 974     GST_OBJECT_LOCK (enc);
 975     priv-&gt;bytes_out += size;
 976     GST_OBJECT_UNLOCK (enc);
 977 
 978     if (G_UNLIKELY (priv-&gt;discont)) {
 979       GST_LOG_OBJECT (enc, &quot;marking discont&quot;);
 980       GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
 981       priv-&gt;discont = FALSE;
 982     }
 983 
 984     if (klass-&gt;pre_push) {
 985       /* last chance for subclass to do some dirty stuff */
 986       ret = klass-&gt;pre_push (enc, &amp;buf);
 987       if (ret != GST_FLOW_OK || !buf) {
 988         GST_DEBUG_OBJECT (enc, &quot;subclass returned %s, buf %p&quot;,
 989             gst_flow_get_name (ret), buf);
 990 
 991         if (buf)
 992           gst_buffer_unref (buf);
 993         goto exit;
 994       }
 995     }
 996 
 997     GST_LOG_OBJECT (enc,
 998         &quot;pushing buffer of size %&quot; G_GSIZE_FORMAT &quot; with ts %&quot; GST_TIME_FORMAT
 999         &quot;, duration %&quot; GST_TIME_FORMAT, size,
1000         GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
1001         GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
1002 
1003     ret = gst_pad_push (enc-&gt;srcpad, buf);
1004     GST_LOG_OBJECT (enc, &quot;buffer pushed: %s&quot;, gst_flow_get_name (ret));
1005   } else {
1006     /* merely advance samples, most work for that already done above */
1007     priv-&gt;samples += samples;
1008   }
1009 
1010 exit:
1011   if (inbuf)
1012     gst_buffer_unref (inbuf);
1013 
1014   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1015 
1016   return ret;
1017 
1018   /* ERRORS */
1019 no_caps:
1020   {
1021     GST_ELEMENT_ERROR (enc, STREAM, ENCODE, (&quot;no caps set&quot;), (NULL));
1022     if (buf)
1023       gst_buffer_unref (buf);
1024     return GST_FLOW_ERROR;
1025   }
1026 overflow:
1027   {
1028     GST_ELEMENT_ERROR (enc, STREAM, ENCODE,
1029         (&quot;received more encoded samples %d than provided %d as inputs&quot;,
1030             samples, priv-&gt;offset / ctx-&gt;info.bpf), (NULL));
1031     if (buf)
1032       gst_buffer_unref (buf);
1033     ret = GST_FLOW_ERROR;
1034     /* no way we can let this pass */
1035     g_assert_not_reached ();
1036     /* really no way */
1037     goto exit;
1038   }
1039 }
1040 
1041  /* adapter tracking idea:
1042   * - start of adapter corresponds with what has already been encoded
1043   * (i.e. really returned by encoder subclass)
1044   * - start + offset is what needs to be fed to subclass next */
1045 static GstFlowReturn
1046 gst_audio_encoder_push_buffers (GstAudioEncoder * enc, gboolean force)
1047 {
1048   GstAudioEncoderClass *klass;
1049   GstAudioEncoderPrivate *priv;
1050   GstAudioEncoderContext *ctx;
1051   gint av, need;
1052   GstBuffer *buf;
1053   GstFlowReturn ret = GST_FLOW_OK;
1054 
1055   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1056 
1057   g_return_val_if_fail (klass-&gt;handle_frame != NULL, GST_FLOW_ERROR);
1058 
1059   priv = enc-&gt;priv;
1060   ctx = &amp;enc-&gt;priv-&gt;ctx;
1061 
1062   while (ret == GST_FLOW_OK) {
1063 
1064     buf = NULL;
1065     av = gst_adapter_available (priv-&gt;adapter);
1066 
1067     g_assert (priv-&gt;offset &lt;= av);
1068     av -= priv-&gt;offset;
1069 
1070     need =
1071         ctx-&gt;frame_samples_min &gt;
1072         0 ? ctx-&gt;frame_samples_min * ctx-&gt;info.bpf : av;
1073     GST_LOG_OBJECT (enc, &quot;available: %d, needed: %d, force: %d&quot;, av, need,
1074         force);
1075 
1076     if ((need &gt; av) || !av) {
1077       if (G_UNLIKELY (force)) {
1078         priv-&gt;force = TRUE;
1079         need = av;
1080       } else {
1081         break;
1082       }
1083     } else {
1084       priv-&gt;force = FALSE;
1085     }
1086 
1087     if (ctx-&gt;frame_samples_max &gt; 0)
1088       need = MIN (av, ctx-&gt;frame_samples_max * ctx-&gt;info.bpf);
1089 
1090     if (ctx-&gt;frame_samples_min == ctx-&gt;frame_samples_max) {
1091       /* if we have some extra metadata,
1092        * provide for integer multiple of frames to allow for better granularity
1093        * of processing */
1094       if (ctx-&gt;frame_samples_min &gt; 0 &amp;&amp; need) {
1095         if (ctx-&gt;frame_max &gt; 1)
1096           need = need * MIN ((av / need), ctx-&gt;frame_max);
1097         else if (ctx-&gt;frame_max == 0)
1098           need = need * (av / need);
1099       }
1100     }
1101 
1102     priv-&gt;got_data = FALSE;
1103     if (G_LIKELY (need)) {
1104       const guint8 *data;
1105 
1106       data = gst_adapter_map (priv-&gt;adapter, priv-&gt;offset + need);
1107       buf =
1108           gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY,
1109           (gpointer) data, priv-&gt;offset + need, priv-&gt;offset, need, NULL, NULL);
1110     } else if (!priv-&gt;drainable) {
1111       GST_DEBUG_OBJECT (enc, &quot;non-drainable and no more data&quot;);
1112       goto finish;
1113     }
1114 
1115     GST_LOG_OBJECT (enc, &quot;providing subclass with %d bytes at offset %d&quot;,
1116         need, priv-&gt;offset);
1117 
1118     /* mark this already as consumed,
1119      * which it should be when subclass gives us data in exchange for samples */
1120     priv-&gt;offset += need;
1121     GST_OBJECT_LOCK (enc);
1122     priv-&gt;samples_in += need / ctx-&gt;info.bpf;
1123     GST_OBJECT_UNLOCK (enc);
1124 
1125     /* subclass might not want to be bothered with leftover data,
1126      * so take care of that here if so, otherwise pass along */
1127     if (G_UNLIKELY (priv-&gt;force &amp;&amp; priv-&gt;hard_min &amp;&amp; buf)) {
1128       GST_DEBUG_OBJECT (enc, &quot;bypassing subclass with leftover&quot;);
1129       ret = gst_audio_encoder_finish_frame (enc, NULL, -1);
1130     } else {
1131       ret = klass-&gt;handle_frame (enc, buf);
1132     }
1133 
1134     if (G_LIKELY (buf)) {
1135       gst_buffer_unref (buf);
1136       gst_adapter_unmap (priv-&gt;adapter);
1137     }
1138 
1139   finish:
1140     /* no data to feed, no leftover provided, then bail out */
1141     if (G_UNLIKELY (!buf &amp;&amp; !priv-&gt;got_data)) {
1142       priv-&gt;drained = TRUE;
1143       GST_LOG_OBJECT (enc, &quot;no more data drained from subclass&quot;);
1144       break;
1145     }
1146   }
1147 
1148   return ret;
1149 }
1150 
1151 static GstFlowReturn
1152 gst_audio_encoder_drain (GstAudioEncoder * enc)
1153 {
1154   GST_DEBUG_OBJECT (enc, &quot;draining&quot;);
1155   if (enc-&gt;priv-&gt;drained)
1156     return GST_FLOW_OK;
1157   else {
1158     GST_DEBUG_OBJECT (enc, &quot;... really&quot;);
1159     return gst_audio_encoder_push_buffers (enc, TRUE);
1160   }
1161 }
1162 
1163 static void
1164 gst_audio_encoder_set_base_gp (GstAudioEncoder * enc)
1165 {
1166   GstClockTime ts;
1167 
1168   if (!enc-&gt;priv-&gt;granule)
1169     return;
1170 
1171   /* use running time for granule */
1172   /* incoming data is clipped, so a valid input should yield a valid output */
1173   ts = gst_segment_to_running_time (&amp;enc-&gt;input_segment, GST_FORMAT_TIME,
1174       enc-&gt;priv-&gt;base_ts);
1175   if (GST_CLOCK_TIME_IS_VALID (ts)) {
1176     enc-&gt;priv-&gt;base_gp =
1177         GST_CLOCK_TIME_TO_FRAMES (enc-&gt;priv-&gt;base_ts, enc-&gt;priv-&gt;ctx.info.rate);
1178     GST_DEBUG_OBJECT (enc, &quot;new base gp %&quot; G_GINT64_FORMAT, enc-&gt;priv-&gt;base_gp);
1179   } else {
1180     /* should reasonably have a valid base,
1181      * otherwise start at 0 if we did not already start there earlier */
1182     if (enc-&gt;priv-&gt;base_gp &lt; 0) {
1183       enc-&gt;priv-&gt;base_gp = 0;
1184       GST_DEBUG_OBJECT (enc, &quot;new base gp %&quot; G_GINT64_FORMAT,
1185           enc-&gt;priv-&gt;base_gp);
1186     }
1187   }
1188 }
1189 
1190 static GstFlowReturn
1191 gst_audio_encoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
1192 {
1193   GstAudioEncoder *enc;
1194   GstAudioEncoderPrivate *priv;
1195   GstAudioEncoderContext *ctx;
1196   GstFlowReturn ret = GST_FLOW_OK;
1197   gboolean discont;
1198   gsize size;
1199 
1200   enc = GST_AUDIO_ENCODER (parent);
1201 
1202   priv = enc-&gt;priv;
1203   ctx = &amp;enc-&gt;priv-&gt;ctx;
1204 
1205   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1206 
1207   if (G_UNLIKELY (priv-&gt;do_caps)) {
1208     GstCaps *caps = gst_pad_get_current_caps (enc-&gt;sinkpad);
1209     if (!caps)
1210       goto not_negotiated;
1211     if (!gst_audio_encoder_sink_setcaps (enc, caps)) {
1212       gst_caps_unref (caps);
1213       goto not_negotiated;
1214     }
1215     gst_caps_unref (caps);
1216     priv-&gt;do_caps = FALSE;
1217   }
1218 
1219   /* should know what is coming by now */
1220   if (!ctx-&gt;info.bpf)
1221     goto not_negotiated;
1222 
1223   size = gst_buffer_get_size (buffer);
1224 
1225   GST_LOG_OBJECT (enc,
1226       &quot;received buffer of size %&quot; G_GSIZE_FORMAT &quot; with ts %&quot; GST_TIME_FORMAT
1227       &quot;, duration %&quot; GST_TIME_FORMAT, size,
1228       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
1229       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
1230 
1231   /* input shoud be whole number of sample frames */
1232   if (size % ctx-&gt;info.bpf)
1233     goto wrong_buffer;
1234 
1235 #ifndef GST_DISABLE_GST_DEBUG
1236   {
1237     GstClockTime duration;
1238     GstClockTimeDiff diff;
1239 
1240     /* verify buffer duration */
1241     duration = gst_util_uint64_scale (size, GST_SECOND,
1242         ctx-&gt;info.rate * ctx-&gt;info.bpf);
1243     diff = GST_CLOCK_DIFF (duration, GST_BUFFER_DURATION (buffer));
1244     if (GST_BUFFER_DURATION (buffer) != GST_CLOCK_TIME_NONE &amp;&amp;
1245         (diff &gt; GST_SECOND / ctx-&gt;info.rate / 2 ||
1246             diff &lt; -GST_SECOND / ctx-&gt;info.rate / 2)) {
1247       GST_DEBUG_OBJECT (enc, &quot;incoming buffer had incorrect duration %&quot;
1248           GST_TIME_FORMAT &quot;, expected duration %&quot; GST_TIME_FORMAT,
1249           GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)),
1250           GST_TIME_ARGS (duration));
1251     }
1252   }
1253 #endif
1254 
1255   discont = GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT);
1256   if (G_UNLIKELY (discont)) {
1257     GST_LOG_OBJECT (buffer, &quot;marked discont&quot;);
1258     enc-&gt;priv-&gt;discont = discont;
1259   }
1260 
1261   /* clip to segment */
1262   buffer = gst_audio_buffer_clip (buffer, &amp;enc-&gt;input_segment, ctx-&gt;info.rate,
1263       ctx-&gt;info.bpf);
1264   if (G_UNLIKELY (!buffer)) {
1265     GST_DEBUG_OBJECT (buffer, &quot;no data after clipping to segment&quot;);
1266     goto done;
1267   }
1268 
1269   size = gst_buffer_get_size (buffer);
1270 
1271   GST_LOG_OBJECT (enc,
1272       &quot;buffer after segment clipping has size %&quot; G_GSIZE_FORMAT &quot; with ts %&quot;
1273       GST_TIME_FORMAT &quot;, duration %&quot; GST_TIME_FORMAT, size,
1274       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
1275       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
1276 
1277   if (!GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts)) {
1278     priv-&gt;base_ts = GST_BUFFER_TIMESTAMP (buffer);
1279     GST_DEBUG_OBJECT (enc, &quot;new base ts %&quot; GST_TIME_FORMAT,
1280         GST_TIME_ARGS (priv-&gt;base_ts));
1281     gst_audio_encoder_set_base_gp (enc);
1282   }
1283 
1284   /* check for continuity;
1285    * checked elsewhere in non-perfect case */
1286   if (enc-&gt;priv-&gt;perfect_ts) {
1287     GstClockTimeDiff diff = 0;
1288     GstClockTime next_ts = 0;
1289 
1290     if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &amp;&amp;
1291         GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts)) {
1292       guint64 samples;
1293 
1294       samples = priv-&gt;samples +
1295           gst_adapter_available (priv-&gt;adapter) / ctx-&gt;info.bpf;
1296       next_ts = priv-&gt;base_ts +
1297           gst_util_uint64_scale (samples, GST_SECOND, ctx-&gt;info.rate);
1298       GST_LOG_OBJECT (enc, &quot;buffer is %&quot; G_GUINT64_FORMAT
1299           &quot; samples past base_ts %&quot; GST_TIME_FORMAT
1300           &quot;, expected ts %&quot; GST_TIME_FORMAT, samples,
1301           GST_TIME_ARGS (priv-&gt;base_ts), GST_TIME_ARGS (next_ts));
1302       diff = GST_CLOCK_DIFF (next_ts, GST_BUFFER_TIMESTAMP (buffer));
1303       GST_LOG_OBJECT (enc, &quot;ts diff %d ms&quot;, (gint) (diff / GST_MSECOND));
1304       /* if within tolerance,
1305        * discard buffer ts and carry on producing perfect stream,
1306        * otherwise clip or resync to ts */
1307       if (G_UNLIKELY (diff &lt; -enc-&gt;priv-&gt;tolerance ||
1308               diff &gt; enc-&gt;priv-&gt;tolerance)) {
1309         GST_DEBUG_OBJECT (enc, &quot;marked discont&quot;);
1310         discont = TRUE;
1311       }
1312     }
1313 
1314     /* do some fancy tweaking in hard resync case */
1315     if (discont &amp;&amp; enc-&gt;priv-&gt;hard_resync) {
1316       if (diff &lt; 0) {
1317         guint64 diff_bytes;
1318 
1319         GST_WARNING_OBJECT (enc, &quot;Buffer is older than expected ts %&quot;
1320             GST_TIME_FORMAT &quot;.  Clipping buffer&quot;, GST_TIME_ARGS (next_ts));
1321 
1322         diff_bytes =
1323             GST_CLOCK_TIME_TO_FRAMES (-diff, ctx-&gt;info.rate) * ctx-&gt;info.bpf;
1324         if (diff_bytes &gt;= size) {
1325           gst_buffer_unref (buffer);
1326           goto done;
1327         }
1328         buffer = gst_buffer_make_writable (buffer);
1329         gst_buffer_resize (buffer, diff_bytes, size - diff_bytes);
1330 
1331         GST_BUFFER_TIMESTAMP (buffer) += diff;
1332         /* care even less about duration after this */
1333       } else {
1334         /* drain stuff prior to resync */
1335         gst_audio_encoder_drain (enc);
1336       }
1337     }
1338     if (discont) {
1339       /* now re-sync ts */
1340       GstClockTime shift =
1341           gst_util_uint64_scale (gst_adapter_available (priv-&gt;adapter),
1342           GST_SECOND, ctx-&gt;info.rate * ctx-&gt;info.bpf);
1343 
1344       if (G_UNLIKELY (shift &gt; GST_BUFFER_TIMESTAMP (buffer))) {
1345         /* ERROR */
1346         goto wrong_time;
1347       }
1348       /* arrange for newly added samples to come out with the ts
1349        * of the incoming buffer that adds these */
1350       priv-&gt;base_ts = GST_BUFFER_TIMESTAMP (buffer) - shift;
1351       priv-&gt;samples = 0;
1352       gst_audio_encoder_set_base_gp (enc);
1353       priv-&gt;discont |= discont;
1354     }
1355   }
1356 
1357   gst_adapter_push (enc-&gt;priv-&gt;adapter, buffer);
1358   /* new stuff, so we can push subclass again */
1359   enc-&gt;priv-&gt;drained = FALSE;
1360 
1361   ret = gst_audio_encoder_push_buffers (enc, FALSE);
1362 
1363 done:
1364   GST_LOG_OBJECT (enc, &quot;chain leaving&quot;);
1365 
1366   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1367 
1368   return ret;
1369 
1370   /* ERRORS */
1371 not_negotiated:
1372   {
1373     GST_ELEMENT_ERROR (enc, CORE, NEGOTIATION, (NULL),
1374         (&quot;encoder not initialized&quot;));
1375     gst_buffer_unref (buffer);
1376     ret = GST_FLOW_NOT_NEGOTIATED;
1377     goto done;
1378   }
1379 wrong_buffer:
1380   {
1381     GST_ELEMENT_ERROR (enc, STREAM, ENCODE, (NULL),
1382         (&quot;buffer size %&quot; G_GSIZE_FORMAT &quot; not a multiple of %d&quot;,
1383             gst_buffer_get_size (buffer), ctx-&gt;info.bpf));
1384     gst_buffer_unref (buffer);
1385     ret = GST_FLOW_ERROR;
1386     goto done;
1387   }
1388 wrong_time:
1389   {
1390     GST_ELEMENT_ERROR (enc, STREAM, ENCODE, (NULL),
1391         (&quot;buffer going too far back in time&quot;));
1392     gst_buffer_unref (buffer);
1393     ret = GST_FLOW_ERROR;
1394     goto done;
<a name="13" id="anc13"></a><span class="line-modified">1395   }</span>
1396 }
1397 
1398 static gboolean
1399 gst_audio_encoder_sink_setcaps (GstAudioEncoder * enc, GstCaps * caps)
1400 {
1401   GstAudioEncoderClass *klass;
1402   GstAudioEncoderContext *ctx;
1403   GstAudioInfo state;
1404   gboolean res = TRUE;
1405   guint old_rate;
1406 
1407   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1408 
1409   /* subclass must do something here ... */
1410   g_return_val_if_fail (klass-&gt;set_format != NULL, FALSE);
1411 
1412   ctx = &amp;enc-&gt;priv-&gt;ctx;
1413 
1414   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1415 
1416   GST_DEBUG_OBJECT (enc, &quot;caps: %&quot; GST_PTR_FORMAT, caps);
1417 
1418   if (!gst_caps_is_fixed (caps))
1419     goto refuse_caps;
1420 
1421   if (enc-&gt;priv-&gt;ctx.input_caps
1422       &amp;&amp; gst_caps_is_equal (enc-&gt;priv-&gt;ctx.input_caps, caps))
1423     goto same_caps;
1424 
1425   if (!gst_audio_info_from_caps (&amp;state, caps))
1426     goto refuse_caps;
1427 
1428   if (enc-&gt;priv-&gt;ctx.input_caps &amp;&amp; gst_audio_info_is_equal (&amp;state, &amp;ctx-&gt;info))
1429     goto same_caps;
1430 
1431   /* adjust ts tracking to new sample rate */
1432   old_rate = GST_AUDIO_INFO_RATE (&amp;ctx-&gt;info);
1433   if (GST_CLOCK_TIME_IS_VALID (enc-&gt;priv-&gt;base_ts) &amp;&amp; old_rate) {
1434     enc-&gt;priv-&gt;base_ts +=
1435         GST_FRAMES_TO_CLOCK_TIME (enc-&gt;priv-&gt;samples, old_rate);
1436     enc-&gt;priv-&gt;samples = 0;
1437   }
1438 
1439   /* drain any pending old data stuff */
1440   gst_audio_encoder_drain (enc);
1441 
1442   /* context defaults */
1443   /* FIXME 2.0: This is quite unexpected behaviour. We should never
1444    * just reset *settings* of a subclass inside the base class */
1445   enc-&gt;priv-&gt;ctx.frame_samples_min = 0;
1446   enc-&gt;priv-&gt;ctx.frame_samples_max = 0;
1447   enc-&gt;priv-&gt;ctx.frame_max = 0;
1448   enc-&gt;priv-&gt;ctx.lookahead = 0;
1449 
1450   if (klass-&gt;set_format)
1451     res = klass-&gt;set_format (enc, &amp;state);
1452 
1453   if (res) {
1454     GST_OBJECT_LOCK (enc);
1455     ctx-&gt;info = state;
1456     gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.input_caps, caps);
1457     GST_OBJECT_UNLOCK (enc);
1458   } else {
1459     /* invalidate state to ensure no casual carrying on */
1460     GST_DEBUG_OBJECT (enc, &quot;subclass did not accept format&quot;);
1461     gst_audio_info_init (&amp;state);
1462     goto exit;
1463   }
1464 
1465 exit:
1466 
1467   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1468 
1469   return res;
1470 
1471 same_caps:
1472   {
1473     GST_DEBUG_OBJECT (enc, &quot;new audio format identical to configured format&quot;);
1474     goto exit;
1475   }
1476 
1477   /* ERRORS */
1478 refuse_caps:
1479   {
1480     GST_WARNING_OBJECT (enc, &quot;rejected caps %&quot; GST_PTR_FORMAT, caps);
1481     goto exit;
1482   }
1483 }
1484 
1485 
1486 /**
1487  * gst_audio_encoder_proxy_getcaps:
1488  * @enc: a #GstAudioEncoder
1489  * @caps: (allow-none): initial caps
1490  * @filter: (allow-none): filter caps
1491  *
1492  * Returns caps that express @caps (or sink template caps if @caps == NULL)
1493  * restricted to channel/rate combinations supported by downstream elements
1494  * (e.g. muxers).
1495  *
1496  * Returns: (transfer full): a #GstCaps owned by caller
1497  */
1498 GstCaps *
1499 gst_audio_encoder_proxy_getcaps (GstAudioEncoder * enc, GstCaps * caps,
1500     GstCaps * filter)
1501 {
1502   return __gst_audio_element_proxy_getcaps (GST_ELEMENT_CAST (enc),
1503       GST_AUDIO_ENCODER_SINK_PAD (enc), GST_AUDIO_ENCODER_SRC_PAD (enc),
1504       caps, filter);
<a name="14" id="anc14"></a><span class="line-modified">1505 }</span>
1506 
1507 static GstCaps *
1508 gst_audio_encoder_getcaps_default (GstAudioEncoder * enc, GstCaps * filter)
1509 {
1510   GstCaps *caps;
1511 
1512   caps = gst_audio_encoder_proxy_getcaps (enc, NULL, filter);
1513   GST_LOG_OBJECT (enc, &quot;returning caps %&quot; GST_PTR_FORMAT, caps);
1514 
1515   return caps;
1516 }
1517 
1518 static GList *
1519 _flush_events (GstPad * pad, GList * events)
1520 {
1521   GList *tmp;
1522 
1523   for (tmp = events; tmp; tmp = tmp-&gt;next) {
1524     if (GST_EVENT_TYPE (tmp-&gt;data) != GST_EVENT_EOS &amp;&amp;
1525         GST_EVENT_TYPE (tmp-&gt;data) != GST_EVENT_SEGMENT &amp;&amp;
1526         GST_EVENT_IS_STICKY (tmp-&gt;data)) {
1527       gst_pad_store_sticky_event (pad, GST_EVENT_CAST (tmp-&gt;data));
1528     }
1529     gst_event_unref (tmp-&gt;data);
1530   }
1531   g_list_free (events);
1532 
1533   return NULL;
1534 }
1535 
1536 static gboolean
1537 gst_audio_encoder_sink_event_default (GstAudioEncoder * enc, GstEvent * event)
1538 {
1539   GstAudioEncoderClass *klass;
1540   gboolean res;
1541 
1542   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1543 
1544   switch (GST_EVENT_TYPE (event)) {
1545     case GST_EVENT_SEGMENT:
1546     {
1547       GstSegment seg;
1548 
1549       gst_event_copy_segment (event, &amp;seg);
1550 
1551       if (seg.format == GST_FORMAT_TIME) {
1552         GST_DEBUG_OBJECT (enc, &quot;received TIME SEGMENT %&quot; GST_SEGMENT_FORMAT,
1553             &amp;seg);
1554       } else {
1555         GST_DEBUG_OBJECT (enc, &quot;received SEGMENT %&quot; GST_SEGMENT_FORMAT, &amp;seg);
1556         GST_DEBUG_OBJECT (enc, &quot;unsupported format; ignoring&quot;);
1557         res = TRUE;
1558         break;
1559       }
1560 
1561       GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1562       /* finish current segment */
1563       gst_audio_encoder_drain (enc);
1564       /* reset partially for new segment */
1565       gst_audio_encoder_reset (enc, FALSE);
1566       /* and follow along with segment */
1567       enc-&gt;input_segment = seg;
1568 
1569       enc-&gt;priv-&gt;pending_events =
1570           g_list_append (enc-&gt;priv-&gt;pending_events, event);
1571       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1572 
1573       res = TRUE;
1574       break;
1575     }
1576 
1577     case GST_EVENT_FLUSH_START:
1578       res = gst_audio_encoder_push_event (enc, event);
1579       break;
1580 
1581     case GST_EVENT_FLUSH_STOP:
1582       GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1583       /* discard any pending stuff */
1584       /* TODO route through drain ?? */
1585       if (!enc-&gt;priv-&gt;drained &amp;&amp; klass-&gt;flush)
1586         klass-&gt;flush (enc);
1587       /* and get (re)set for the sequel */
1588       gst_audio_encoder_reset (enc, FALSE);
1589 
1590       enc-&gt;priv-&gt;pending_events = _flush_events (enc-&gt;srcpad,
1591           enc-&gt;priv-&gt;pending_events);
1592       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1593 
1594       res = gst_audio_encoder_push_event (enc, event);
1595       break;
1596 
1597     case GST_EVENT_EOS:
1598       GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1599       gst_audio_encoder_drain (enc);
1600 
1601       /* check for pending events and tags */
1602       gst_audio_encoder_push_pending_events (enc);
1603       gst_audio_encoder_check_and_push_pending_tags (enc);
1604 
1605       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1606 
1607       /* forward immediately because no buffer or serialized event
1608        * will come after EOS and nothing could trigger another
1609        * _finish_frame() call. */
1610       res = gst_audio_encoder_push_event (enc, event);
1611       break;
1612 
1613     case GST_EVENT_CAPS:
1614     {
1615       GstCaps *caps;
1616 
1617       gst_event_parse_caps (event, &amp;caps);
1618       enc-&gt;priv-&gt;do_caps = TRUE;
1619       res = TRUE;
1620       gst_event_unref (event);
1621       break;
1622     }
1623 
1624     case GST_EVENT_STREAM_START:
1625     {
1626       GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1627       /* Flush upstream tags after a STREAM_START */
1628       GST_DEBUG_OBJECT (enc, &quot;received STREAM_START. Clearing taglist&quot;);
1629       if (enc-&gt;priv-&gt;upstream_tags) {
1630         gst_tag_list_unref (enc-&gt;priv-&gt;upstream_tags);
1631         enc-&gt;priv-&gt;upstream_tags = NULL;
1632         enc-&gt;priv-&gt;tags_changed = TRUE;
1633       }
1634       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1635       res = gst_audio_encoder_push_event (enc, event);
1636       break;
1637     }
1638 
1639     case GST_EVENT_TAG:
1640     {
1641       GstTagList *tags;
1642 
1643       gst_event_parse_tag (event, &amp;tags);
1644 
1645       if (gst_tag_list_get_scope (tags) == GST_TAG_SCOPE_STREAM) {
1646         GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1647         if (enc-&gt;priv-&gt;upstream_tags != tags) {
<a name="15" id="anc15"></a><span class="line-modified">1648           tags = gst_tag_list_copy (tags);</span>
<span class="line-modified">1649 </span>
<span class="line-modified">1650           /* FIXME: make generic based on GST_TAG_FLAG_ENCODED */</span>
<span class="line-modified">1651           gst_tag_list_remove_tag (tags, GST_TAG_CODEC);</span>
<span class="line-modified">1652           gst_tag_list_remove_tag (tags, GST_TAG_AUDIO_CODEC);</span>
<span class="line-modified">1653           gst_tag_list_remove_tag (tags, GST_TAG_VIDEO_CODEC);</span>
<span class="line-modified">1654           gst_tag_list_remove_tag (tags, GST_TAG_SUBTITLE_CODEC);</span>
<span class="line-modified">1655           gst_tag_list_remove_tag (tags, GST_TAG_CONTAINER_FORMAT);</span>
<span class="line-modified">1656           gst_tag_list_remove_tag (tags, GST_TAG_BITRATE);</span>
<span class="line-modified">1657           gst_tag_list_remove_tag (tags, GST_TAG_NOMINAL_BITRATE);</span>
<span class="line-modified">1658           gst_tag_list_remove_tag (tags, GST_TAG_MAXIMUM_BITRATE);</span>
<span class="line-modified">1659           gst_tag_list_remove_tag (tags, GST_TAG_MINIMUM_BITRATE);</span>
<span class="line-modified">1660           gst_tag_list_remove_tag (tags, GST_TAG_ENCODER);</span>
<span class="line-modified">1661           gst_tag_list_remove_tag (tags, GST_TAG_ENCODER_VERSION);</span>
1662 
1663           if (enc-&gt;priv-&gt;upstream_tags)
1664             gst_tag_list_unref (enc-&gt;priv-&gt;upstream_tags);
1665           enc-&gt;priv-&gt;upstream_tags = tags;
1666           GST_INFO_OBJECT (enc, &quot;upstream stream tags: %&quot; GST_PTR_FORMAT, tags);
1667         }
1668         gst_event_unref (event);
1669         event = gst_audio_encoder_create_merged_tags_event (enc);
1670         GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1671 
1672         /* No tags, go out of here instead of fall through */
1673         if (!event) {
<a name="16" id="anc16"></a><span class="line-modified">1674           res = TRUE;</span>
<span class="line-modified">1675           break;</span>
<span class="line-modified">1676         }</span>
1677       }
1678       /* fall through */
1679     }
1680     default:
1681       /* Forward non-serialized events immediately. */
1682       if (!GST_EVENT_IS_SERIALIZED (event)) {
1683         res =
1684             gst_pad_event_default (enc-&gt;sinkpad, GST_OBJECT_CAST (enc), event);
1685       } else {
1686         GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1687         enc-&gt;priv-&gt;pending_events =
1688             g_list_append (enc-&gt;priv-&gt;pending_events, event);
1689         GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1690         res = TRUE;
1691       }
1692       break;
1693   }
1694   return res;
1695 }
1696 
1697 static gboolean
1698 gst_audio_encoder_sink_event (GstPad * pad, GstObject * parent,
1699     GstEvent * event)
1700 {
1701   GstAudioEncoder *enc;
1702   GstAudioEncoderClass *klass;
1703   gboolean ret;
1704 
1705   enc = GST_AUDIO_ENCODER (parent);
1706   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1707 
1708   GST_DEBUG_OBJECT (enc, &quot;received event %d, %s&quot;, GST_EVENT_TYPE (event),
1709       GST_EVENT_TYPE_NAME (event));
1710 
1711   if (klass-&gt;sink_event)
1712     ret = klass-&gt;sink_event (enc, event);
1713   else {
1714     gst_event_unref (event);
1715     ret = FALSE;
1716   }
1717 
1718   GST_DEBUG_OBJECT (enc, &quot;event result %d&quot;, ret);
1719 
1720   return ret;
1721 }
1722 
1723 static gboolean
1724 gst_audio_encoder_sink_query_default (GstAudioEncoder * enc, GstQuery * query)
1725 {
1726   GstPad *pad = GST_AUDIO_ENCODER_SINK_PAD (enc);
1727   gboolean res = FALSE;
1728 
1729   switch (GST_QUERY_TYPE (query)) {
1730     case GST_QUERY_FORMATS:
1731     {
1732       gst_query_set_formats (query, 3,
1733           GST_FORMAT_TIME, GST_FORMAT_BYTES, GST_FORMAT_DEFAULT);
1734       res = TRUE;
1735       break;
1736     }
1737     case GST_QUERY_CONVERT:
1738     {
1739       GstFormat src_fmt, dest_fmt;
1740       gint64 src_val, dest_val;
1741 
1742       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, &amp;dest_val);
1743       GST_OBJECT_LOCK (enc);
1744       res = gst_audio_info_convert (&amp;enc-&gt;priv-&gt;ctx.info,
1745           src_fmt, src_val, dest_fmt, &amp;dest_val);
1746       GST_OBJECT_UNLOCK (enc);
1747       if (!res)
1748         goto error;
1749       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
1750       res = TRUE;
1751       break;
1752     }
1753     case GST_QUERY_CAPS:
1754     {
1755       GstCaps *filter, *caps;
1756       GstAudioEncoderClass *klass;
1757 
1758       gst_query_parse_caps (query, &amp;filter);
1759 
1760       klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1761       if (klass-&gt;getcaps) {
1762         caps = klass-&gt;getcaps (enc, filter);
1763         gst_query_set_caps_result (query, caps);
1764         gst_caps_unref (caps);
1765         res = TRUE;
1766       }
1767       break;
1768     }
1769     case GST_QUERY_ALLOCATION:
1770     {
1771       GstAudioEncoderClass *klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1772 
1773       if (klass-&gt;propose_allocation)
1774         res = klass-&gt;propose_allocation (enc, query);
1775       break;
1776     }
1777     default:
1778       res = gst_pad_query_default (pad, GST_OBJECT (enc), query);
1779       break;
1780   }
1781 
1782 error:
1783   return res;
1784 }
1785 
1786 static gboolean
1787 gst_audio_encoder_sink_query (GstPad * pad, GstObject * parent,
1788     GstQuery * query)
1789 {
1790   GstAudioEncoder *encoder;
1791   GstAudioEncoderClass *encoder_class;
1792   gboolean ret = FALSE;
1793 
1794   encoder = GST_AUDIO_ENCODER (parent);
1795   encoder_class = GST_AUDIO_ENCODER_GET_CLASS (encoder);
1796 
1797   GST_DEBUG_OBJECT (encoder, &quot;received query %d, %s&quot;, GST_QUERY_TYPE (query),
1798       GST_QUERY_TYPE_NAME (query));
1799 
1800   if (encoder_class-&gt;sink_query)
1801     ret = encoder_class-&gt;sink_query (encoder, query);
1802 
1803   return ret;
1804 }
1805 
1806 static gboolean
1807 gst_audio_encoder_src_event_default (GstAudioEncoder * enc, GstEvent * event)
1808 {
1809   gboolean res;
1810 
1811   switch (GST_EVENT_TYPE (event)) {
1812     default:
1813       res = gst_pad_event_default (enc-&gt;srcpad, GST_OBJECT_CAST (enc), event);
1814       break;
1815   }
1816   return res;
1817 }
1818 
1819 static gboolean
1820 gst_audio_encoder_src_event (GstPad * pad, GstObject * parent, GstEvent * event)
1821 {
1822   GstAudioEncoder *enc;
1823   GstAudioEncoderClass *klass;
1824   gboolean ret;
1825 
1826   enc = GST_AUDIO_ENCODER (parent);
1827   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1828 
1829   GST_DEBUG_OBJECT (enc, &quot;received event %d, %s&quot;, GST_EVENT_TYPE (event),
1830       GST_EVENT_TYPE_NAME (event));
1831 
1832   if (klass-&gt;src_event)
1833     ret = klass-&gt;src_event (enc, event);
1834   else {
1835     gst_event_unref (event);
1836     ret = FALSE;
1837   }
1838 
1839   return ret;
1840 }
1841 
1842 static gboolean
1843 gst_audio_encoder_decide_allocation_default (GstAudioEncoder * enc,
1844     GstQuery * query)
1845 {
1846   GstAllocator *allocator = NULL;
1847   GstAllocationParams params;
1848   gboolean update_allocator;
1849 
1850   /* we got configuration from our peer or the decide_allocation method,
1851    * parse them */
1852   if (gst_query_get_n_allocation_params (query) &gt; 0) {
1853     /* try the allocator */
1854     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
1855     update_allocator = TRUE;
1856   } else {
1857     allocator = NULL;
1858     gst_allocation_params_init (&amp;params);
1859     update_allocator = FALSE;
1860   }
1861 
1862   if (update_allocator)
1863     gst_query_set_nth_allocation_param (query, 0, allocator, &amp;params);
1864   else
1865     gst_query_add_allocation_param (query, allocator, &amp;params);
1866   if (allocator)
1867     gst_object_unref (allocator);
1868 
1869   return TRUE;
1870 }
1871 
1872 static gboolean
1873 gst_audio_encoder_propose_allocation_default (GstAudioEncoder * enc,
1874     GstQuery * query)
1875 {
1876   return TRUE;
1877 }
1878 
1879 /* FIXME ? are any of these queries (other than latency) an encoder&#39;s business
1880  * also, the conversion stuff might seem to make sense, but seems to not mind
1881  * segment stuff etc at all
1882  * Supposedly that&#39;s backward compatibility ... */
1883 static gboolean
1884 gst_audio_encoder_src_query_default (GstAudioEncoder * enc, GstQuery * query)
1885 {
1886   GstPad *pad = GST_AUDIO_ENCODER_SRC_PAD (enc);
1887   gboolean res = FALSE;
1888 
1889   GST_LOG_OBJECT (enc, &quot;handling query: %&quot; GST_PTR_FORMAT, query);
1890 
1891   switch (GST_QUERY_TYPE (query)) {
1892     case GST_QUERY_POSITION:
1893     {
1894       GstFormat fmt, req_fmt;
1895       gint64 pos, val;
1896 
1897       if ((res = gst_pad_peer_query (enc-&gt;sinkpad, query))) {
1898         GST_LOG_OBJECT (enc, &quot;returning peer response&quot;);
1899         break;
1900       }
1901 
1902       gst_query_parse_position (query, &amp;req_fmt, NULL);
1903 
1904       /* Refuse BYTES format queries. If it made sense to
1905        *        * answer them, upstream would have already */
1906       if (req_fmt == GST_FORMAT_BYTES) {
1907         GST_LOG_OBJECT (enc, &quot;Ignoring BYTES position query&quot;);
1908         break;
1909       }
1910 
1911       fmt = GST_FORMAT_TIME;
1912       if (!(res = gst_pad_peer_query_position (enc-&gt;sinkpad, fmt, &amp;pos)))
1913         break;
1914 
1915       if ((res =
1916               gst_pad_peer_query_convert (enc-&gt;sinkpad, fmt, pos, req_fmt,
1917                   &amp;val))) {
1918         gst_query_set_position (query, req_fmt, val);
1919       }
1920       break;
1921     }
1922     case GST_QUERY_DURATION:
1923     {
1924       GstFormat fmt, req_fmt;
1925       gint64 dur, val;
1926 
1927       if ((res = gst_pad_peer_query (enc-&gt;sinkpad, query))) {
1928         GST_LOG_OBJECT (enc, &quot;returning peer response&quot;);
1929         break;
1930       }
1931 
1932       gst_query_parse_duration (query, &amp;req_fmt, NULL);
1933 
1934       /* Refuse BYTES format queries. If it made sense to
1935        *        * answer them, upstream would have already */
1936       if (req_fmt == GST_FORMAT_BYTES) {
1937         GST_LOG_OBJECT (enc, &quot;Ignoring BYTES position query&quot;);
1938         break;
1939       }
1940 
1941       fmt = GST_FORMAT_TIME;
1942       if (!(res = gst_pad_peer_query_duration (enc-&gt;sinkpad, fmt, &amp;dur)))
1943         break;
1944 
1945       if ((res =
1946               gst_pad_peer_query_convert (enc-&gt;sinkpad, fmt, dur, req_fmt,
1947                   &amp;val))) {
1948         gst_query_set_duration (query, req_fmt, val);
1949       }
1950       break;
1951     }
1952     case GST_QUERY_FORMATS:
1953     {
1954       gst_query_set_formats (query, 2, GST_FORMAT_TIME, GST_FORMAT_BYTES);
1955       res = TRUE;
1956       break;
1957     }
1958     case GST_QUERY_CONVERT:
1959     {
1960       GstFormat src_fmt, dest_fmt;
1961       gint64 src_val, dest_val;
1962 
1963       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, &amp;dest_val);
1964       GST_OBJECT_LOCK (enc);
1965       res = __gst_audio_encoded_audio_convert (&amp;enc-&gt;priv-&gt;ctx.info,
<a name="17" id="anc17"></a><span class="line-modified">1966           enc-&gt;priv-&gt;bytes_out, enc-&gt;priv-&gt;samples_in, src_fmt, src_val,</span>
1967           &amp;dest_fmt, &amp;dest_val);
1968       GST_OBJECT_UNLOCK (enc);
1969       if (!res)
1970         break;
1971       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
1972       break;
1973     }
1974     case GST_QUERY_LATENCY:
1975     {
1976       if ((res = gst_pad_peer_query (enc-&gt;sinkpad, query))) {
1977         gboolean live;
1978         GstClockTime min_latency, max_latency;
1979 
1980         gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
1981         GST_DEBUG_OBJECT (enc, &quot;Peer latency: live %d, min %&quot;
1982             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
1983             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
1984 
1985         GST_OBJECT_LOCK (enc);
1986         /* add our latency */
<a name="18" id="anc18"></a><span class="line-modified">1987         min_latency += enc-&gt;priv-&gt;ctx.min_latency;</span>
1988         if (max_latency == -1 || enc-&gt;priv-&gt;ctx.max_latency == -1)
1989           max_latency = -1;
1990         else
1991           max_latency += enc-&gt;priv-&gt;ctx.max_latency;
1992         GST_OBJECT_UNLOCK (enc);
1993 
1994         gst_query_set_latency (query, live, min_latency, max_latency);
1995       }
1996       break;
1997     }
1998     default:
1999       res = gst_pad_query_default (pad, GST_OBJECT (enc), query);
2000       break;
2001   }
2002 
2003   return res;
2004 }
2005 
2006 static gboolean
2007 gst_audio_encoder_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
2008 {
2009   GstAudioEncoder *encoder;
2010   GstAudioEncoderClass *encoder_class;
2011   gboolean ret = FALSE;
2012 
2013   encoder = GST_AUDIO_ENCODER (parent);
2014   encoder_class = GST_AUDIO_ENCODER_GET_CLASS (encoder);
2015 
2016   GST_DEBUG_OBJECT (encoder, &quot;received query %d, %s&quot;, GST_QUERY_TYPE (query),
2017       GST_QUERY_TYPE_NAME (query));
2018 
2019   if (encoder_class-&gt;src_query)
2020     ret = encoder_class-&gt;src_query (encoder, query);
2021 
2022   return ret;
2023 }
2024 
2025 
2026 static void
2027 gst_audio_encoder_set_property (GObject * object, guint prop_id,
2028     const GValue * value, GParamSpec * pspec)
2029 {
2030   GstAudioEncoder *enc;
2031 
2032   enc = GST_AUDIO_ENCODER (object);
2033 
2034   switch (prop_id) {
2035     case PROP_PERFECT_TS:
2036       if (enc-&gt;priv-&gt;granule &amp;&amp; !g_value_get_boolean (value))
2037         GST_WARNING_OBJECT (enc, &quot;perfect-timestamp can not be set FALSE &quot;
2038             &quot;while granule handling is enabled&quot;);
2039       else
2040         enc-&gt;priv-&gt;perfect_ts = g_value_get_boolean (value);
2041       break;
2042     case PROP_HARD_RESYNC:
2043       enc-&gt;priv-&gt;hard_resync = g_value_get_boolean (value);
2044       break;
2045     case PROP_TOLERANCE:
2046       enc-&gt;priv-&gt;tolerance = g_value_get_int64 (value);
2047       break;
2048     default:
2049       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
2050       break;
2051   }
2052 }
2053 
2054 static void
2055 gst_audio_encoder_get_property (GObject * object, guint prop_id,
2056     GValue * value, GParamSpec * pspec)
2057 {
2058   GstAudioEncoder *enc;
2059 
2060   enc = GST_AUDIO_ENCODER (object);
2061 
2062   switch (prop_id) {
2063     case PROP_PERFECT_TS:
2064       g_value_set_boolean (value, enc-&gt;priv-&gt;perfect_ts);
2065       break;
2066     case PROP_GRANULE:
2067       g_value_set_boolean (value, enc-&gt;priv-&gt;granule);
2068       break;
2069     case PROP_HARD_RESYNC:
2070       g_value_set_boolean (value, enc-&gt;priv-&gt;hard_resync);
2071       break;
2072     case PROP_TOLERANCE:
2073       g_value_set_int64 (value, enc-&gt;priv-&gt;tolerance);
2074       break;
2075     default:
2076       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
2077       break;
2078   }
2079 }
2080 
2081 static gboolean
2082 gst_audio_encoder_activate (GstAudioEncoder * enc, gboolean active)
2083 {
2084   GstAudioEncoderClass *klass;
2085   gboolean result = TRUE;
2086 
2087   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
2088 
2089   g_return_val_if_fail (!enc-&gt;priv-&gt;granule || enc-&gt;priv-&gt;perfect_ts, FALSE);
2090 
2091   GST_DEBUG_OBJECT (enc, &quot;activate %d&quot;, active);
2092 
2093   if (active) {
2094     /* arrange clean state */
2095     gst_audio_encoder_reset (enc, TRUE);
2096 
2097     if (!enc-&gt;priv-&gt;active &amp;&amp; klass-&gt;start)
2098       result = klass-&gt;start (enc);
2099   } else {
2100     /* We must make sure streaming has finished before resetting things
2101      * and calling the ::stop vfunc */
2102     GST_PAD_STREAM_LOCK (enc-&gt;sinkpad);
2103     GST_PAD_STREAM_UNLOCK (enc-&gt;sinkpad);
2104 
2105     if (enc-&gt;priv-&gt;active &amp;&amp; klass-&gt;stop)
2106       result = klass-&gt;stop (enc);
2107 
2108     /* clean up */
2109     gst_audio_encoder_reset (enc, TRUE);
2110   }
2111   GST_DEBUG_OBJECT (enc, &quot;activate return: %d&quot;, result);
2112   return result;
2113 }
2114 
2115 
2116 static gboolean
2117 gst_audio_encoder_sink_activate_mode (GstPad * pad, GstObject * parent,
2118     GstPadMode mode, gboolean active)
2119 {
2120   gboolean result = TRUE;
2121   GstAudioEncoder *enc;
2122 
2123   enc = GST_AUDIO_ENCODER (parent);
2124 
2125   GST_DEBUG_OBJECT (enc, &quot;sink activate push %d&quot;, active);
2126 
2127   result = gst_audio_encoder_activate (enc, active);
2128 
2129   if (result)
2130     enc-&gt;priv-&gt;active = active;
2131 
2132   GST_DEBUG_OBJECT (enc, &quot;sink activate push return: %d&quot;, result);
2133 
2134   return result;
2135 }
2136 
2137 /**
2138  * gst_audio_encoder_get_audio_info:
2139  * @enc: a #GstAudioEncoder
2140  *
2141  * Returns: a #GstAudioInfo describing the input audio format
2142  */
2143 GstAudioInfo *
2144 gst_audio_encoder_get_audio_info (GstAudioEncoder * enc)
2145 {
2146   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), NULL);
2147 
2148   return &amp;enc-&gt;priv-&gt;ctx.info;
2149 }
2150 
2151 /**
2152  * gst_audio_encoder_set_frame_samples_min:
2153  * @enc: a #GstAudioEncoder
2154  * @num: number of samples per frame
2155  *
2156  * Sets number of samples (per channel) subclass needs to be handed,
2157  * at least or will be handed all available if 0.
2158  *
2159  * If an exact number of samples is required, gst_audio_encoder_set_frame_samples_max()
2160  * must be called with the same number.
2161  *
2162  * Note: This value will be reset to 0 every time before
<a name="19" id="anc19"></a><span class="line-modified">2163  * #GstAudioEncoderClass.set_format() is called.</span>
2164  */
2165 void
2166 gst_audio_encoder_set_frame_samples_min (GstAudioEncoder * enc, gint num)
2167 {
2168   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2169 
2170   enc-&gt;priv-&gt;ctx.frame_samples_min = num;
2171   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2172 }
2173 
2174 /**
2175  * gst_audio_encoder_get_frame_samples_min:
2176  * @enc: a #GstAudioEncoder
2177  *
2178  * Returns: currently minimum requested samples per frame
2179  */
2180 gint
2181 gst_audio_encoder_get_frame_samples_min (GstAudioEncoder * enc)
2182 {
2183   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2184 
2185   return enc-&gt;priv-&gt;ctx.frame_samples_min;
2186 }
2187 
2188 /**
2189  * gst_audio_encoder_set_frame_samples_max:
2190  * @enc: a #GstAudioEncoder
2191  * @num: number of samples per frame
2192  *
2193  * Sets number of samples (per channel) subclass needs to be handed,
2194  * at most or will be handed all available if 0.
2195  *
2196  * If an exact number of samples is required, gst_audio_encoder_set_frame_samples_min()
2197  * must be called with the same number.
2198  *
2199  * Note: This value will be reset to 0 every time before
<a name="20" id="anc20"></a><span class="line-modified">2200  * #GstAudioEncoderClass.set_format() is called.</span>
2201  */
2202 void
2203 gst_audio_encoder_set_frame_samples_max (GstAudioEncoder * enc, gint num)
2204 {
2205   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2206 
2207   enc-&gt;priv-&gt;ctx.frame_samples_max = num;
2208   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2209 }
2210 
2211 /**
2212  * gst_audio_encoder_get_frame_samples_max:
2213  * @enc: a #GstAudioEncoder
2214  *
2215  * Returns: currently maximum requested samples per frame
2216  */
2217 gint
2218 gst_audio_encoder_get_frame_samples_max (GstAudioEncoder * enc)
2219 {
2220   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2221 
2222   return enc-&gt;priv-&gt;ctx.frame_samples_max;
2223 }
2224 
2225 /**
2226  * gst_audio_encoder_set_frame_max:
2227  * @enc: a #GstAudioEncoder
2228  * @num: number of frames
2229  *
2230  * Sets max number of frames accepted at once (assumed minimally 1).
2231  * Requires @frame_samples_min and @frame_samples_max to be the equal.
2232  *
2233  * Note: This value will be reset to 0 every time before
<a name="21" id="anc21"></a><span class="line-modified">2234  * #GstAudioEncoderClass.set_format() is called.</span>
2235  */
2236 void
2237 gst_audio_encoder_set_frame_max (GstAudioEncoder * enc, gint num)
2238 {
2239   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2240 
2241   enc-&gt;priv-&gt;ctx.frame_max = num;
2242   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2243 }
2244 
2245 /**
2246  * gst_audio_encoder_get_frame_max:
2247  * @enc: a #GstAudioEncoder
2248  *
2249  * Returns: currently configured maximum handled frames
2250  */
2251 gint
2252 gst_audio_encoder_get_frame_max (GstAudioEncoder * enc)
2253 {
2254   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2255 
2256   return enc-&gt;priv-&gt;ctx.frame_max;
2257 }
2258 
2259 /**
2260  * gst_audio_encoder_set_lookahead:
2261  * @enc: a #GstAudioEncoder
2262  * @num: lookahead
2263  *
2264  * Sets encoder lookahead (in units of input rate samples)
2265  *
2266  * Note: This value will be reset to 0 every time before
<a name="22" id="anc22"></a><span class="line-modified">2267  * #GstAudioEncoderClass.set_format() is called.</span>
2268  */
2269 void
2270 gst_audio_encoder_set_lookahead (GstAudioEncoder * enc, gint num)
2271 {
2272   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2273 
2274   enc-&gt;priv-&gt;ctx.lookahead = num;
2275   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2276 }
2277 
2278 /**
2279  * gst_audio_encoder_get_lookahead:
2280  * @enc: a #GstAudioEncoder
2281  *
2282  * Returns: currently configured encoder lookahead
2283  */
2284 gint
2285 gst_audio_encoder_get_lookahead (GstAudioEncoder * enc)
2286 {
2287   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2288 
2289   return enc-&gt;priv-&gt;ctx.lookahead;
2290 }
2291 
2292 /**
2293  * gst_audio_encoder_set_latency:
2294  * @enc: a #GstAudioEncoder
2295  * @min: minimum latency
2296  * @max: maximum latency
2297  *
2298  * Sets encoder latency.
2299  */
2300 void
2301 gst_audio_encoder_set_latency (GstAudioEncoder * enc,
2302     GstClockTime min, GstClockTime max)
2303 {
2304   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2305   g_return_if_fail (GST_CLOCK_TIME_IS_VALID (min));
2306   g_return_if_fail (min &lt;= max);
2307 
2308   GST_OBJECT_LOCK (enc);
2309   enc-&gt;priv-&gt;ctx.min_latency = min;
2310   enc-&gt;priv-&gt;ctx.max_latency = max;
2311   GST_OBJECT_UNLOCK (enc);
2312 
2313   GST_LOG_OBJECT (enc, &quot;set to %&quot; GST_TIME_FORMAT &quot;-%&quot; GST_TIME_FORMAT,
2314       GST_TIME_ARGS (min), GST_TIME_ARGS (max));
2315 
2316   /* post latency message on the bus */
2317   gst_element_post_message (GST_ELEMENT (enc),
2318       gst_message_new_latency (GST_OBJECT (enc)));
2319 }
2320 
2321 /**
2322  * gst_audio_encoder_get_latency:
2323  * @enc: a #GstAudioEncoder
2324  * @min: (out) (allow-none): a pointer to storage to hold minimum latency
2325  * @max: (out) (allow-none): a pointer to storage to hold maximum latency
2326  *
2327  * Sets the variables pointed to by @min and @max to the currently configured
2328  * latency.
2329  */
2330 void
2331 gst_audio_encoder_get_latency (GstAudioEncoder * enc,
2332     GstClockTime * min, GstClockTime * max)
2333 {
2334   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2335 
2336   GST_OBJECT_LOCK (enc);
2337   if (min)
2338     *min = enc-&gt;priv-&gt;ctx.min_latency;
2339   if (max)
2340     *max = enc-&gt;priv-&gt;ctx.max_latency;
2341   GST_OBJECT_UNLOCK (enc);
2342 }
2343 
2344 /**
2345  * gst_audio_encoder_set_headers:
2346  * @enc: a #GstAudioEncoder
2347  * @headers: (transfer full) (element-type Gst.Buffer): a list of
2348  *   #GstBuffer containing the codec header
2349  *
2350  * Set the codec headers to be sent downstream whenever requested.
2351  */
2352 void
2353 gst_audio_encoder_set_headers (GstAudioEncoder * enc, GList * headers)
2354 {
2355   GST_DEBUG_OBJECT (enc, &quot;new headers %p&quot;, headers);
2356 
2357   if (enc-&gt;priv-&gt;ctx.headers) {
2358     g_list_foreach (enc-&gt;priv-&gt;ctx.headers, (GFunc) gst_buffer_unref, NULL);
2359     g_list_free (enc-&gt;priv-&gt;ctx.headers);
2360   }
2361   enc-&gt;priv-&gt;ctx.headers = headers;
2362   enc-&gt;priv-&gt;ctx.new_headers = TRUE;
2363 }
2364 
2365 /**
2366  * gst_audio_encoder_set_allocation_caps:
2367  * @enc: a #GstAudioEncoder
2368  * @allocation_caps: (allow-none): a #GstCaps or %NULL
2369  *
2370  * Sets a caps in allocation query which are different from the set
2371  * pad&#39;s caps. Use this function before calling
2372  * gst_audio_encoder_negotiate(). Setting to %NULL the allocation
2373  * query will use the caps from the pad.
2374  *
2375  * Since: 1.10
2376  */
2377 void
2378 gst_audio_encoder_set_allocation_caps (GstAudioEncoder * enc,
2379     GstCaps * allocation_caps)
2380 {
2381   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2382 
2383   gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.allocation_caps, allocation_caps);
2384 }
2385 
2386 /**
2387  * gst_audio_encoder_set_mark_granule:
2388  * @enc: a #GstAudioEncoder
2389  * @enabled: new state
2390  *
2391  * Enable or disable encoder granule handling.
2392  *
2393  * MT safe.
2394  */
2395 void
2396 gst_audio_encoder_set_mark_granule (GstAudioEncoder * enc, gboolean enabled)
2397 {
2398   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2399 
2400   GST_LOG_OBJECT (enc, &quot;enabled: %d&quot;, enabled);
2401 
2402   GST_OBJECT_LOCK (enc);
2403   enc-&gt;priv-&gt;granule = enabled;
2404   GST_OBJECT_UNLOCK (enc);
2405 }
2406 
2407 /**
2408  * gst_audio_encoder_get_mark_granule:
2409  * @enc: a #GstAudioEncoder
2410  *
2411  * Queries if the encoder will handle granule marking.
2412  *
2413  * Returns: TRUE if granule marking is enabled.
2414  *
2415  * MT safe.
2416  */
2417 gboolean
2418 gst_audio_encoder_get_mark_granule (GstAudioEncoder * enc)
2419 {
2420   gboolean result;
2421 
2422   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2423 
2424   GST_OBJECT_LOCK (enc);
2425   result = enc-&gt;priv-&gt;granule;
2426   GST_OBJECT_UNLOCK (enc);
2427 
2428   return result;
2429 }
2430 
2431 /**
2432  * gst_audio_encoder_set_perfect_timestamp:
2433  * @enc: a #GstAudioEncoder
2434  * @enabled: new state
2435  *
2436  * Enable or disable encoder perfect output timestamp preference.
2437  *
2438  * MT safe.
2439  */
2440 void
2441 gst_audio_encoder_set_perfect_timestamp (GstAudioEncoder * enc,
2442     gboolean enabled)
2443 {
2444   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2445 
2446   GST_LOG_OBJECT (enc, &quot;enabled: %d&quot;, enabled);
2447 
2448   GST_OBJECT_LOCK (enc);
2449   enc-&gt;priv-&gt;perfect_ts = enabled;
2450   GST_OBJECT_UNLOCK (enc);
2451 }
2452 
2453 /**
2454  * gst_audio_encoder_get_perfect_timestamp:
2455  * @enc: a #GstAudioEncoder
2456  *
2457  * Queries encoder perfect timestamp behaviour.
2458  *
2459  * Returns: TRUE if perfect timestamp setting enabled.
2460  *
2461  * MT safe.
2462  */
2463 gboolean
2464 gst_audio_encoder_get_perfect_timestamp (GstAudioEncoder * enc)
2465 {
2466   gboolean result;
2467 
2468   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2469 
2470   GST_OBJECT_LOCK (enc);
2471   result = enc-&gt;priv-&gt;perfect_ts;
2472   GST_OBJECT_UNLOCK (enc);
2473 
2474   return result;
2475 }
2476 
2477 /**
2478  * gst_audio_encoder_set_hard_sync:
2479  * @enc: a #GstAudioEncoder
2480  * @enabled: new state
2481  *
2482  * Sets encoder hard resync handling.
2483  *
2484  * MT safe.
2485  */
2486 void
2487 gst_audio_encoder_set_hard_resync (GstAudioEncoder * enc, gboolean enabled)
2488 {
2489   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2490 
2491   GST_LOG_OBJECT (enc, &quot;enabled: %d&quot;, enabled);
2492 
2493   GST_OBJECT_LOCK (enc);
2494   enc-&gt;priv-&gt;hard_resync = enabled;
2495   GST_OBJECT_UNLOCK (enc);
2496 }
2497 
2498 /**
2499  * gst_audio_encoder_get_hard_sync:
2500  * @enc: a #GstAudioEncoder
2501  *
2502  * Queries encoder&#39;s hard resync setting.
2503  *
2504  * Returns: TRUE if hard resync is enabled.
2505  *
2506  * MT safe.
2507  */
2508 gboolean
2509 gst_audio_encoder_get_hard_resync (GstAudioEncoder * enc)
2510 {
2511   gboolean result;
2512 
2513   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2514 
2515   GST_OBJECT_LOCK (enc);
2516   result = enc-&gt;priv-&gt;hard_resync;
2517   GST_OBJECT_UNLOCK (enc);
2518 
2519   return result;
2520 }
2521 
2522 /**
2523  * gst_audio_encoder_set_tolerance:
2524  * @enc: a #GstAudioEncoder
2525  * @tolerance: new tolerance
2526  *
2527  * Configures encoder audio jitter tolerance threshold.
2528  *
2529  * MT safe.
2530  */
2531 void
2532 gst_audio_encoder_set_tolerance (GstAudioEncoder * enc, GstClockTime tolerance)
2533 {
2534   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2535 
2536   GST_OBJECT_LOCK (enc);
2537   enc-&gt;priv-&gt;tolerance = tolerance;
2538   GST_OBJECT_UNLOCK (enc);
2539 
2540   GST_LOG_OBJECT (enc, &quot;set to %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (tolerance));
2541 }
2542 
2543 /**
2544  * gst_audio_encoder_get_tolerance:
2545  * @enc: a #GstAudioEncoder
2546  *
2547  * Queries current audio jitter tolerance threshold.
2548  *
2549  * Returns: encoder audio jitter tolerance threshold.
2550  *
2551  * MT safe.
2552  */
2553 GstClockTime
2554 gst_audio_encoder_get_tolerance (GstAudioEncoder * enc)
2555 {
2556   GstClockTime result;
2557 
2558   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2559 
2560   GST_OBJECT_LOCK (enc);
2561   result = enc-&gt;priv-&gt;tolerance;
2562   GST_OBJECT_UNLOCK (enc);
2563 
2564   return result;
2565 }
2566 
2567 /**
2568  * gst_audio_encoder_set_hard_min:
2569  * @enc: a #GstAudioEncoder
2570  * @enabled: new state
2571  *
2572  * Configures encoder hard minimum handling.  If enabled, subclass
2573  * will never be handed less samples than it configured, which otherwise
2574  * might occur near end-of-data handling.  Instead, the leftover samples
2575  * will simply be discarded.
2576  *
2577  * MT safe.
2578  */
2579 void
2580 gst_audio_encoder_set_hard_min (GstAudioEncoder * enc, gboolean enabled)
2581 {
2582   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2583 
2584   GST_OBJECT_LOCK (enc);
2585   enc-&gt;priv-&gt;hard_min = enabled;
2586   GST_OBJECT_UNLOCK (enc);
2587 }
2588 
2589 /**
2590  * gst_audio_encoder_get_hard_min:
2591  * @enc: a #GstAudioEncoder
2592  *
2593  * Queries encoder hard minimum handling.
2594  *
2595  * Returns: TRUE if hard minimum handling is enabled.
2596  *
2597  * MT safe.
2598  */
2599 gboolean
2600 gst_audio_encoder_get_hard_min (GstAudioEncoder * enc)
2601 {
2602   gboolean result;
2603 
2604   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2605 
2606   GST_OBJECT_LOCK (enc);
2607   result = enc-&gt;priv-&gt;hard_min;
2608   GST_OBJECT_UNLOCK (enc);
2609 
2610   return result;
2611 }
2612 
2613 /**
2614  * gst_audio_encoder_set_drainable:
2615  * @enc: a #GstAudioEncoder
2616  * @enabled: new state
2617  *
2618  * Configures encoder drain handling.  If drainable, subclass might
2619  * be handed a NULL buffer to have it return any leftover encoded data.
2620  * Otherwise, it is not considered so capable and will only ever be passed
2621  * real data.
2622  *
2623  * MT safe.
2624  */
2625 void
2626 gst_audio_encoder_set_drainable (GstAudioEncoder * enc, gboolean enabled)
2627 {
2628   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2629 
2630   GST_OBJECT_LOCK (enc);
2631   enc-&gt;priv-&gt;drainable = enabled;
2632   GST_OBJECT_UNLOCK (enc);
2633 }
2634 
2635 /**
2636  * gst_audio_encoder_get_drainable:
2637  * @enc: a #GstAudioEncoder
2638  *
2639  * Queries encoder drain handling.
2640  *
2641  * Returns: TRUE if drainable handling is enabled.
2642  *
2643  * MT safe.
2644  */
2645 gboolean
2646 gst_audio_encoder_get_drainable (GstAudioEncoder * enc)
2647 {
2648   gboolean result;
2649 
2650   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2651 
2652   GST_OBJECT_LOCK (enc);
2653   result = enc-&gt;priv-&gt;drainable;
2654   GST_OBJECT_UNLOCK (enc);
2655 
2656   return result;
2657 }
2658 
2659 /**
2660  * gst_audio_encoder_merge_tags:
2661  * @enc: a #GstAudioEncoder
2662  * @tags: (allow-none): a #GstTagList to merge, or NULL to unset
2663  *     previously-set tags
2664  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
2665  *
2666  * Sets the audio encoder tags and how they should be merged with any
2667  * upstream stream tags. This will override any tags previously-set
2668  * with gst_audio_encoder_merge_tags().
2669  *
2670  * Note that this is provided for convenience, and the subclass is
2671  * not required to use this and can still do tag handling on its own.
2672  *
2673  * MT safe.
2674  */
2675 void
2676 gst_audio_encoder_merge_tags (GstAudioEncoder * enc,
2677     const GstTagList * tags, GstTagMergeMode mode)
2678 {
2679   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2680   g_return_if_fail (tags == NULL || GST_IS_TAG_LIST (tags));
2681   g_return_if_fail (tags == NULL || mode != GST_TAG_MERGE_UNDEFINED);
2682 
2683   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
2684   if (enc-&gt;priv-&gt;tags != tags) {
2685     if (enc-&gt;priv-&gt;tags) {
2686       gst_tag_list_unref (enc-&gt;priv-&gt;tags);
2687       enc-&gt;priv-&gt;tags = NULL;
2688       enc-&gt;priv-&gt;tags_merge_mode = GST_TAG_MERGE_APPEND;
2689     }
2690     if (tags) {
2691       enc-&gt;priv-&gt;tags = gst_tag_list_ref ((GstTagList *) tags);
2692       enc-&gt;priv-&gt;tags_merge_mode = mode;
2693     }
2694 
2695     GST_DEBUG_OBJECT (enc, &quot;setting encoder tags to %&quot; GST_PTR_FORMAT, tags);
<a name="23" id="anc23"></a><span class="line-modified">2696     enc-&gt;priv-&gt;tags_changed = TRUE;</span>
2697   }
2698   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2699 }
2700 
2701 static gboolean
2702 gst_audio_encoder_negotiate_default (GstAudioEncoder * enc)
2703 {
2704   GstAudioEncoderClass *klass;
2705   gboolean res = TRUE;
2706   GstQuery *query = NULL;
2707   GstAllocator *allocator;
2708   GstAllocationParams params;
2709   GstCaps *caps, *prevcaps;
2710 
2711   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2712   g_return_val_if_fail (GST_IS_CAPS (enc-&gt;priv-&gt;ctx.caps), FALSE);
2713 
2714   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
2715 
2716   caps = enc-&gt;priv-&gt;ctx.caps;
2717   if (enc-&gt;priv-&gt;ctx.allocation_caps == NULL)
2718     enc-&gt;priv-&gt;ctx.allocation_caps = gst_caps_ref (caps);
2719 
2720   GST_DEBUG_OBJECT (enc, &quot;Setting srcpad caps %&quot; GST_PTR_FORMAT, caps);
2721 
2722   if (enc-&gt;priv-&gt;pending_events) {
2723     GList **pending_events, *l;
2724 
2725     pending_events = &amp;enc-&gt;priv-&gt;pending_events;
2726 
2727     GST_DEBUG_OBJECT (enc, &quot;Pushing pending events&quot;);
2728     for (l = *pending_events; l;) {
2729       GstEvent *event = GST_EVENT (l-&gt;data);
2730       GList *tmp;
2731 
2732       if (GST_EVENT_TYPE (event) &lt; GST_EVENT_CAPS) {
2733         gst_audio_encoder_push_event (enc, l-&gt;data);
2734         tmp = l;
2735         l = l-&gt;next;
2736         *pending_events = g_list_delete_link (*pending_events, tmp);
2737       } else {
2738         l = l-&gt;next;
2739       }
2740     }
2741   }
2742 
2743   prevcaps = gst_pad_get_current_caps (enc-&gt;srcpad);
2744   if (!prevcaps || !gst_caps_is_equal (prevcaps, caps))
2745     res = gst_pad_set_caps (enc-&gt;srcpad, caps);
2746   if (prevcaps)
2747     gst_caps_unref (prevcaps);
2748 
2749   if (!res)
2750     goto done;
2751   enc-&gt;priv-&gt;ctx.output_caps_changed = FALSE;
2752 
2753   query = gst_query_new_allocation (enc-&gt;priv-&gt;ctx.allocation_caps, TRUE);
2754   if (!gst_pad_peer_query (enc-&gt;srcpad, query)) {
2755     GST_DEBUG_OBJECT (enc, &quot;didn&#39;t get downstream ALLOCATION hints&quot;);
2756   }
2757 
2758   g_assert (klass-&gt;decide_allocation != NULL);
2759   res = klass-&gt;decide_allocation (enc, query);
2760 
2761   GST_DEBUG_OBJECT (enc, &quot;ALLOCATION (%d) params: %&quot; GST_PTR_FORMAT, res,
2762       query);
2763 
2764   if (!res)
2765     goto no_decide_allocation;
2766 
2767   /* we got configuration from our peer or the decide_allocation method,
2768    * parse them */
2769   if (gst_query_get_n_allocation_params (query) &gt; 0) {
2770     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
2771   } else {
2772     allocator = NULL;
2773     gst_allocation_params_init (&amp;params);
2774   }
2775 
2776   if (enc-&gt;priv-&gt;ctx.allocator)
2777     gst_object_unref (enc-&gt;priv-&gt;ctx.allocator);
2778   enc-&gt;priv-&gt;ctx.allocator = allocator;
2779   enc-&gt;priv-&gt;ctx.params = params;
2780 
2781 done:
2782   if (query)
2783     gst_query_unref (query);
2784 
2785   return res;
2786 
2787   /* ERRORS */
2788 no_decide_allocation:
2789   {
2790     GST_WARNING_OBJECT (enc, &quot;Subclass failed to decide allocation&quot;);
2791     goto done;
2792   }
2793 }
2794 
2795 static gboolean
2796 gst_audio_encoder_negotiate_unlocked (GstAudioEncoder * enc)
2797 {
2798   GstAudioEncoderClass *klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
2799   gboolean ret = TRUE;
2800 
2801   if (G_LIKELY (klass-&gt;negotiate))
2802     ret = klass-&gt;negotiate (enc);
2803 
2804   return ret;
2805 }
2806 
2807 /**
2808  * gst_audio_encoder_negotiate:
2809  * @enc: a #GstAudioEncoder
2810  *
2811  * Negotiate with downstream elements to currently configured #GstCaps.
2812  * Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
2813  * negotiate fails.
2814  *
2815  * Returns: %TRUE if the negotiation succeeded, else %FALSE.
2816  */
2817 gboolean
2818 gst_audio_encoder_negotiate (GstAudioEncoder * enc)
2819 {
2820   GstAudioEncoderClass *klass;
2821   gboolean ret = TRUE;
2822 
2823   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2824 
2825   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
2826 
2827   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
2828   gst_pad_check_reconfigure (enc-&gt;srcpad);
2829   if (klass-&gt;negotiate) {
2830     ret = klass-&gt;negotiate (enc);
2831     if (!ret)
2832       gst_pad_mark_reconfigure (enc-&gt;srcpad);
2833   }
2834   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2835 
2836   return ret;
2837 }
2838 
2839 /**
2840  * gst_audio_encoder_set_output_format:
2841  * @enc: a #GstAudioEncoder
2842  * @caps: (transfer none): #GstCaps
2843  *
2844  * Configure output caps on the srcpad of @enc.
2845  *
2846  * Returns: %TRUE on success.
2847  */
2848 gboolean
2849 gst_audio_encoder_set_output_format (GstAudioEncoder * enc, GstCaps * caps)
2850 {
2851   gboolean res = TRUE;
2852   GstCaps *templ_caps;
2853 
2854   GST_DEBUG_OBJECT (enc, &quot;Setting srcpad caps %&quot; GST_PTR_FORMAT, caps);
2855 
2856   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
2857   if (!gst_caps_is_fixed (caps))
2858     goto refuse_caps;
2859 
2860   /* Only allow caps that are a subset of the template caps */
2861   templ_caps = gst_pad_get_pad_template_caps (enc-&gt;srcpad);
2862   if (!gst_caps_is_subset (caps, templ_caps)) {
2863     gst_caps_unref (templ_caps);
2864     goto refuse_caps;
2865   }
2866   gst_caps_unref (templ_caps);
2867 
2868   gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.caps, caps);
2869   enc-&gt;priv-&gt;ctx.output_caps_changed = TRUE;
2870 
2871 done:
2872   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2873 
2874   return res;
2875 
2876   /* ERRORS */
2877 refuse_caps:
2878   {
2879     GST_WARNING_OBJECT (enc, &quot;refused caps %&quot; GST_PTR_FORMAT, caps);
2880     res = FALSE;
2881     goto done;
2882   }
2883 }
2884 
2885 /**
2886  * gst_audio_encoder_allocate_output_buffer:
2887  * @enc: a #GstAudioEncoder
2888  * @size: size of the buffer
2889  *
2890  * Helper function that allocates a buffer to hold an encoded audio frame
2891  * for @enc&#39;s current output format.
2892  *
2893  * Returns: (transfer full): allocated buffer
2894  */
2895 GstBuffer *
2896 gst_audio_encoder_allocate_output_buffer (GstAudioEncoder * enc, gsize size)
2897 {
2898   GstBuffer *buffer = NULL;
2899   gboolean needs_reconfigure = FALSE;
2900 
2901   g_return_val_if_fail (size &gt; 0, NULL);
2902 
2903   GST_DEBUG (&quot;alloc src buffer&quot;);
2904 
2905   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
2906 
2907   needs_reconfigure = gst_pad_check_reconfigure (enc-&gt;srcpad);
2908   if (G_UNLIKELY (enc-&gt;priv-&gt;ctx.output_caps_changed || (enc-&gt;priv-&gt;ctx.caps
2909               &amp;&amp; needs_reconfigure))) {
2910     if (!gst_audio_encoder_negotiate_unlocked (enc)) {
2911       GST_INFO_OBJECT (enc, &quot;Failed to negotiate, fallback allocation&quot;);
2912       gst_pad_mark_reconfigure (enc-&gt;srcpad);
2913       goto fallback;
2914     }
2915   }
2916 
2917   buffer =
2918       gst_buffer_new_allocate (enc-&gt;priv-&gt;ctx.allocator, size,
2919       &amp;enc-&gt;priv-&gt;ctx.params);
2920   if (!buffer) {
2921     GST_INFO_OBJECT (enc, &quot;couldn&#39;t allocate output buffer&quot;);
2922     goto fallback;
2923   }
2924 
2925   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2926 
2927   return buffer;
2928 
2929 fallback:
2930   buffer = gst_buffer_new_allocate (NULL, size, NULL);
2931   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2932 
2933   return buffer;
2934 }
2935 
2936 /**
2937  * gst_audio_encoder_get_allocator:
2938  * @enc: a #GstAudioEncoder
2939  * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
2940  * used
2941  * @params: (out) (allow-none) (transfer full): the
<a name="24" id="anc24"></a><span class="line-modified">2942  * #GstAllocationParams of @allocator</span>
2943  *
2944  * Lets #GstAudioEncoder sub-classes to know the memory @allocator
2945  * used by the base class and its @params.
2946  *
2947  * Unref the @allocator after use it.
2948  */
2949 void
2950 gst_audio_encoder_get_allocator (GstAudioEncoder * enc,
2951     GstAllocator ** allocator, GstAllocationParams * params)
2952 {
2953   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2954 
2955   if (allocator)
2956     *allocator = enc-&gt;priv-&gt;ctx.allocator ?
2957         gst_object_ref (enc-&gt;priv-&gt;ctx.allocator) : NULL;
2958 
2959   if (params)
2960     *params = enc-&gt;priv-&gt;ctx.params;
2961 }
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>