<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/gstdiscoverer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstdiscoverer-types.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstdiscoverer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/gstdiscoverer.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  36  * URIs to be processed (through gst_discoverer_discover_uri_async()) and then
  37  * asks for the discovery to begin (through gst_discoverer_start()).
  38  * By default this will use the GLib default main context unless you have
  39  * set a custom context using g_main_context_push_thread_default().
  40  *
  41  * All the information is returned in a #GstDiscovererInfo structure.
  42  */
  43 
  44 #ifdef HAVE_CONFIG_H
  45 #include &quot;config.h&quot;
  46 #endif
  47 
  48 #include &lt;gst/video/video.h&gt;
  49 #include &lt;gst/audio/audio.h&gt;
  50 
  51 #include &lt;string.h&gt;
  52 
  53 #include &quot;pbutils.h&quot;
  54 #include &quot;pbutils-private.h&quot;
  55 



  56 GST_DEBUG_CATEGORY_STATIC (discoverer_debug);
  57 #define GST_CAT_DEFAULT discoverer_debug

  58 
  59 static GQuark _CAPS_QUARK;
  60 static GQuark _TAGS_QUARK;
  61 static GQuark _ELEMENT_SRCPAD_QUARK;
  62 static GQuark _TOC_QUARK;
  63 static GQuark _STREAM_ID_QUARK;
  64 static GQuark _MISSING_PLUGIN_QUARK;
  65 static GQuark _STREAM_TOPOLOGY_QUARK;
  66 static GQuark _TOPOLOGY_PAD_QUARK;
  67 
  68 
  69 typedef struct
  70 {
  71   GstDiscoverer *dc;
  72   GstPad *pad;
  73   GstElement *queue;
  74   GstElement *sink;
  75   GstTagList *tags;
  76   GstToc *toc;
  77   gchar *stream_id;
</pre>
<hr />
<pre>
 107   GList *streams;
 108 
 109   /* List of these sinks and their handler IDs (to remove the probe) */
 110   guint pending_subtitle_pads;
 111 
 112   /* Whether we received no_more_pads */
 113   gboolean no_more_pads;
 114 
 115   GstState target_state;
 116   GstState current_state;
 117 
 118   /* Global elements */
 119   GstBin *pipeline;
 120   GstElement *uridecodebin;
 121   GstBus *bus;
 122 
 123   GType decodebin_type;
 124 
 125   /* Custom main context variables */
 126   GMainContext *ctx;
<span class="line-modified"> 127   guint sourceid;</span>
<span class="line-modified"> 128   guint timeoutid;</span>
 129 
 130   /* reusable queries */
 131   GstQuery *seeking_query;
 132 
 133   /* Handler ids for various callbacks */
 134   gulong pad_added_id;
 135   gulong pad_remove_id;
 136   gulong no_more_pads_id;
 137   gulong source_chg_id;
 138   gulong element_added_id;
 139   gulong bus_cb_id;


 140 };
 141 
 142 #define DISCO_LOCK(dc) g_mutex_lock (&amp;dc-&gt;priv-&gt;lock);
 143 #define DISCO_UNLOCK(dc) g_mutex_unlock (&amp;dc-&gt;priv-&gt;lock);
 144 
 145 static void
 146 _do_init (void)
 147 {
 148   GST_DEBUG_CATEGORY_INIT (discoverer_debug, &quot;discoverer&quot;, 0, &quot;Discoverer&quot;);
 149 
 150   _CAPS_QUARK = g_quark_from_static_string (&quot;caps&quot;);
 151   _ELEMENT_SRCPAD_QUARK = g_quark_from_static_string (&quot;element-srcpad&quot;);
 152   _TAGS_QUARK = g_quark_from_static_string (&quot;tags&quot;);
 153   _TOC_QUARK = g_quark_from_static_string (&quot;toc&quot;);
 154   _STREAM_ID_QUARK = g_quark_from_static_string (&quot;stream-id&quot;);
 155   _MISSING_PLUGIN_QUARK = g_quark_from_static_string (&quot;missing-plugin&quot;);
 156   _STREAM_TOPOLOGY_QUARK = g_quark_from_static_string (&quot;stream-topology&quot;);
 157   _TOPOLOGY_PAD_QUARK = g_quark_from_static_string (&quot;pad&quot;);
 158 };
 159 
 160 G_DEFINE_TYPE_EXTENDED (GstDiscoverer, gst_discoverer, G_TYPE_OBJECT, 0,
<span class="line-modified"> 161     _do_init ());</span>
 162 
 163 enum
 164 {
 165   SIGNAL_FINISHED,
 166   SIGNAL_STARTING,
 167   SIGNAL_DISCOVERED,
 168   SIGNAL_SOURCE_SETUP,
 169   LAST_SIGNAL
 170 };
 171 
 172 #define DEFAULT_PROP_TIMEOUT 15 * GST_SECOND

 173 
 174 enum
 175 {
 176   PROP_0,
<span class="line-modified"> 177   PROP_TIMEOUT</span>

 178 };
 179 
 180 static guint gst_discoverer_signals[LAST_SIGNAL] = { 0 };
 181 
 182 static void gst_discoverer_set_timeout (GstDiscoverer * dc,
 183     GstClockTime timeout);
 184 static gboolean async_timeout_cb (GstDiscoverer * dc);
 185 
 186 static void discoverer_bus_cb (GstBus * bus, GstMessage * msg,
 187     GstDiscoverer * dc);
 188 static void uridecodebin_pad_added_cb (GstElement * uridecodebin, GstPad * pad,
 189     GstDiscoverer * dc);
 190 static void uridecodebin_pad_removed_cb (GstElement * uridecodebin,
 191     GstPad * pad, GstDiscoverer * dc);
 192 static void uridecodebin_no_more_pads_cb (GstElement * uridecodebin,
 193     GstDiscoverer * dc);
 194 static void uridecodebin_source_changed_cb (GstElement * uridecodebin,
 195     GParamSpec * pspec, GstDiscoverer * dc);
 196 
 197 static void gst_discoverer_dispose (GObject * dc);
 198 static void gst_discoverer_finalize (GObject * dc);
 199 static void gst_discoverer_set_property (GObject * object, guint prop_id,
 200     const GValue * value, GParamSpec * pspec);
 201 static void gst_discoverer_get_property (GObject * object, guint prop_id,
 202     GValue * value, GParamSpec * pspec);







 203 
 204 static void
 205 gst_discoverer_class_init (GstDiscovererClass * klass)
 206 {
 207   GObjectClass *gobject_class = (GObjectClass *) klass;
 208 
 209   gobject_class-&gt;dispose = gst_discoverer_dispose;
 210   gobject_class-&gt;finalize = gst_discoverer_finalize;
 211 
 212   gobject_class-&gt;set_property = gst_discoverer_set_property;
 213   gobject_class-&gt;get_property = gst_discoverer_get_property;
 214 
<span class="line-removed"> 215   g_type_class_add_private (klass, sizeof (GstDiscovererPrivate));</span>
 216 
 217   /* properties */
 218   /**
 219    * GstDiscoverer:timeout:
 220    *
 221    * The duration (in nanoseconds) after which the discovery of an individual
 222    * URI will timeout.
 223    *
 224    * If the discovery of a URI times out, the %GST_DISCOVERER_TIMEOUT will be
 225    * set on the result flags.
 226    */
 227   g_object_class_install_property (gobject_class, PROP_TIMEOUT,
 228       g_param_spec_uint64 (&quot;timeout&quot;, &quot;timeout&quot;, &quot;Timeout&quot;,
 229           GST_SECOND, 3600 * GST_SECOND, DEFAULT_PROP_TIMEOUT,
 230           G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));
 231 


















 232   /* signals */
 233   /**
 234    * GstDiscoverer::finished:
 235    * @discoverer: the #GstDiscoverer
 236    *
 237    * Will be emitted in async mode when all pending URIs have been processed.
 238    */
 239   gst_discoverer_signals[SIGNAL_FINISHED] =
 240       g_signal_new (&quot;finished&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 241       G_STRUCT_OFFSET (GstDiscovererClass, finished),
 242       NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0, G_TYPE_NONE);
 243 
 244   /**
 245    * GstDiscoverer::starting:
 246    * @discoverer: the #GstDiscoverer
 247    *
 248    * Will be emitted when the discover starts analyzing the pending URIs
 249    */
 250   gst_discoverer_signals[SIGNAL_STARTING] =
 251       g_signal_new (&quot;starting&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
</pre>
<hr />
<pre>
 295 }
 296 
 297 static void
 298 uridecodebin_element_added_cb (GstElement * uridecodebin,
 299     GstElement * child, GstDiscoverer * dc)
 300 {
 301   GST_DEBUG (&quot;New element added to uridecodebin : %s&quot;,
 302       GST_ELEMENT_NAME (child));
 303 
 304   if (G_OBJECT_TYPE (child) == dc-&gt;priv-&gt;decodebin_type) {
 305     g_object_set (child, &quot;post-stream-topology&quot;, TRUE, NULL);
 306   }
 307 }
 308 
 309 static void
 310 gst_discoverer_init (GstDiscoverer * dc)
 311 {
 312   GstElement *tmp;
 313   GstFormat format = GST_FORMAT_TIME;
 314 
<span class="line-modified"> 315   dc-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (dc, GST_TYPE_DISCOVERER,</span>
<span class="line-removed"> 316       GstDiscovererPrivate);</span>
 317 
 318   dc-&gt;priv-&gt;timeout = DEFAULT_PROP_TIMEOUT;

 319   dc-&gt;priv-&gt;async = FALSE;
 320 
 321   g_mutex_init (&amp;dc-&gt;priv-&gt;lock);
 322 
 323   dc-&gt;priv-&gt;pending_subtitle_pads = 0;
 324 
 325   dc-&gt;priv-&gt;current_state = GST_STATE_NULL;
 326   dc-&gt;priv-&gt;target_state = GST_STATE_NULL;
 327   dc-&gt;priv-&gt;no_more_pads = FALSE;
 328 
 329   GST_LOG (&quot;Creating pipeline&quot;);
 330   dc-&gt;priv-&gt;pipeline = (GstBin *) gst_pipeline_new (&quot;Discoverer&quot;);
 331   GST_LOG_OBJECT (dc, &quot;Creating uridecodebin&quot;);
 332   dc-&gt;priv-&gt;uridecodebin =
 333       gst_element_factory_make (&quot;uridecodebin&quot;, &quot;discoverer-uri&quot;);
 334   if (G_UNLIKELY (dc-&gt;priv-&gt;uridecodebin == NULL)) {
 335     GST_ERROR (&quot;Can&#39;t create uridecodebin&quot;);
 336     return;
 337   }
 338   GST_LOG_OBJECT (dc, &quot;Adding uridecodebin to pipeline&quot;);
</pre>
<hr />
<pre>
 436 static void
 437 gst_discoverer_finalize (GObject * obj)
 438 {
 439   GstDiscoverer *dc = (GstDiscoverer *) obj;
 440 
 441   g_mutex_clear (&amp;dc-&gt;priv-&gt;lock);
 442 
 443   G_OBJECT_CLASS (gst_discoverer_parent_class)-&gt;finalize (obj);
 444 }
 445 
 446 static void
 447 gst_discoverer_set_property (GObject * object, guint prop_id,
 448     const GValue * value, GParamSpec * pspec)
 449 {
 450   GstDiscoverer *dc = (GstDiscoverer *) object;
 451 
 452   switch (prop_id) {
 453     case PROP_TIMEOUT:
 454       gst_discoverer_set_timeout (dc, g_value_get_uint64 (value));
 455       break;





 456     default:
 457       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 458       break;
 459   }
 460 }
 461 
 462 static void
 463 gst_discoverer_get_property (GObject * object, guint prop_id,
 464     GValue * value, GParamSpec * pspec)
 465 {
 466   GstDiscoverer *dc = (GstDiscoverer *) object;
 467 
 468   switch (prop_id) {
 469     case PROP_TIMEOUT:
 470       DISCO_LOCK (dc);
 471       g_value_set_uint64 (value, dc-&gt;priv-&gt;timeout);
 472       DISCO_UNLOCK (dc);
 473       break;





 474     default:
 475       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 476       break;
 477   }
 478 }
 479 
 480 static void
 481 gst_discoverer_set_timeout (GstDiscoverer * dc, GstClockTime timeout)
 482 {
 483   GST_DEBUG_OBJECT (dc, &quot;timeout : %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (timeout));
 484 
 485   /* FIXME : update current pending timeout if we&#39;re running */
 486   DISCO_LOCK (dc);
 487   dc-&gt;priv-&gt;timeout = timeout;
 488   DISCO_UNLOCK (dc);
 489 }
 490 
 491 static GstPadProbeReturn
 492 _event_probe (GstPad * pad, GstPadProbeInfo * info, PrivateStream * ps)
 493 {
</pre>
<hr />
<pre>
 530         GST_DEBUG_OBJECT (pad, &quot;Dropping toc since preroll is done&quot;);
 531       DISCO_UNLOCK (ps-&gt;dc);
 532       break;
 533     }
 534     case GST_EVENT_STREAM_START:{
 535       const gchar *stream_id;
 536 
 537       gst_event_parse_stream_start (event, &amp;stream_id);
 538 
 539       g_free (ps-&gt;stream_id);
 540       ps-&gt;stream_id = stream_id ? g_strdup (stream_id) : NULL;
 541       break;
 542     }
 543     default:
 544       break;
 545   }
 546 
 547   return GST_PAD_PROBE_OK;
 548 }
 549 
<span class="line-modified"> 550 static GstStaticCaps subtitle_caps = GST_STATIC_CAPS (&quot;text/x-raw; &quot;</span>
<span class="line-modified"> 551     &quot;subpicture/x-pgs; subpicture/x-dvb; subpicture/x-dvd; &quot;</span>
<span class="line-modified"> 552     &quot;application/x-subtitle-unknown; application/x-ssa; application/x-ass; &quot;</span>
<span class="line-removed"> 553     &quot;subtitle/x-kate; application/x-kate; subpicture/x-xsub&quot;);</span>
 554 
 555 static gboolean
 556 is_subtitle_caps (const GstCaps * caps)
 557 {
 558   GstCaps *subs_caps;


 559   gboolean ret;
 560 












 561   subs_caps = gst_static_caps_get (&amp;subtitle_caps);
 562   ret = gst_caps_can_intersect (caps, subs_caps);
 563   gst_caps_unref (subs_caps);
 564 
 565   return ret;
 566 }
 567 
 568 static GstPadProbeReturn
 569 got_subtitle_data (GstPad * pad, GstPadProbeInfo * info, GstDiscoverer * dc)
 570 {
 571   GstMessage *msg;
 572 
 573   if (!(GST_IS_BUFFER (info-&gt;data) || (GST_IS_EVENT (info-&gt;data)
 574               &amp;&amp; (GST_EVENT_TYPE ((GstEvent *) info-&gt;data) == GST_EVENT_GAP
 575                   || GST_EVENT_TYPE ((GstEvent *) info-&gt;data) ==
 576                   GST_EVENT_EOS))))
 577     return GST_PAD_PROBE_OK;
 578 
 579 
 580   DISCO_LOCK (dc);
</pre>
<hr />
<pre>
1289 
1290     for (i = 0; i &lt; len; i++) {
1291       const GValue *subv = gst_value_list_get_value (nval, i);
1292       const GstStructure *subst = gst_value_get_structure (subv);
1293       GstDiscovererStreamInfo *substream;
1294 
1295       GST_DEBUG (&quot;%d %&quot; GST_PTR_FORMAT, i, subst);
1296 
1297       substream = parse_stream_topology (dc, subst, NULL);
1298 
1299       substream-&gt;previous = res;
1300       cont-&gt;streams =
1301           g_list_append (cont-&gt;streams,
1302           gst_discoverer_stream_info_ref (substream));
1303     }
1304   }
1305 
1306   return res;
1307 }
1308 















































1309 /* Called when pipeline is pre-rolled */
1310 static void
1311 discoverer_collect (GstDiscoverer * dc)
1312 {
1313   GST_DEBUG (&quot;Collecting information&quot;);
1314 
1315   /* Stop the timeout handler if present */
<span class="line-modified">1316   if (dc-&gt;priv-&gt;timeoutid) {</span>
<span class="line-modified">1317     g_source_remove (dc-&gt;priv-&gt;timeoutid);</span>
<span class="line-modified">1318     dc-&gt;priv-&gt;timeoutid = 0;</span>








1319   }
1320 
1321   if (dc-&gt;priv-&gt;streams) {
1322     /* FIXME : Make this querying optional */
1323     if (TRUE) {
1324       GstElement *pipeline = (GstElement *) dc-&gt;priv-&gt;pipeline;
1325       gint64 dur;
1326 
1327       GST_DEBUG (&quot;Attempting to query duration&quot;);
1328 
1329       if (gst_element_query_duration (pipeline, GST_FORMAT_TIME, &amp;dur)) {
1330         GST_DEBUG (&quot;Got duration %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (dur));
1331         dc-&gt;priv-&gt;current_info-&gt;duration = (guint64) dur;
1332       } else if (dc-&gt;priv-&gt;current_info-&gt;result != GST_DISCOVERER_ERROR) {
1333         GstStateChangeReturn sret;
1334         /* Note: We don&#39;t switch to PLAYING if we previously saw an ERROR since
1335          * the state of various element isn&#39;t guaranteed anymore */
1336 
1337         /* Some parsers may not even return a rough estimate right away, e.g.
1338          * because they&#39;ve only processed a single frame so far, so if we
</pre>
<hr />
<pre>
1392      * initially there are 2, the image and raw stream, but we squash these
1393      * while parsing the stream topology). At some point, if we find that these
1394      * conditions are not sufficient, we can count the number of decoders and
1395      * parsers in the chain, and if there&#39;s more than one decoder, or any
1396      * parser at all, we should not mark this as an image.
1397      */
1398     if (dc-&gt;priv-&gt;current_info-&gt;duration == 0 &amp;&amp;
1399         dc-&gt;priv-&gt;current_info-&gt;stream_info != NULL &amp;&amp;
1400         dc-&gt;priv-&gt;current_info-&gt;stream_info-&gt;next == NULL) {
1401       GstDiscovererStreamInfo *stream_info;
1402       GstStructure *st;
1403 
1404       stream_info = dc-&gt;priv-&gt;current_info-&gt;stream_info;
1405       st = gst_caps_get_structure (stream_info-&gt;caps, 0);
1406 
1407       if (g_str_has_prefix (gst_structure_get_name (st), &quot;image/&quot;))
1408         ((GstDiscovererVideoInfo *) stream_info)-&gt;is_image = TRUE;
1409     }
1410   }
1411 
<span class="line-modified">1412   if (dc-&gt;priv-&gt;async) {</span>
<span class="line-modified">1413     GST_DEBUG (&quot;Emitting &#39;discoverered&#39;&quot;);</span>
<span class="line-modified">1414     g_signal_emit (dc, gst_discoverer_signals[SIGNAL_DISCOVERED], 0,</span>
<span class="line-modified">1415         dc-&gt;priv-&gt;current_info, dc-&gt;priv-&gt;current_error);</span>
<span class="line-modified">1416     /* Clients get a copy of current_info since it is a boxed type */</span>
<span class="line-modified">1417     gst_discoverer_info_unref (dc-&gt;priv-&gt;current_info);</span>
<span class="line-modified">1418     dc-&gt;priv-&gt;current_info = NULL;</span>
1419   }



1420 }
1421 
1422 static void
1423 get_async_cb (gpointer cb_data, GSource * source, GSourceFunc * func,
1424     gpointer * data)
1425 {
1426   *func = (GSourceFunc) async_timeout_cb;
1427   *data = cb_data;
1428 }
1429 
1430 /* Wrapper since GSourceCallbackFuncs don&#39;t expect a return value from ref() */
1431 static void
1432 _void_g_object_ref (gpointer object)
1433 {
1434   g_object_ref (G_OBJECT (object));
1435 }
1436 
1437 static void
1438 handle_current_async (GstDiscoverer * dc)
1439 {
1440   GSource *source;
1441   static GSourceCallbackFuncs cb_funcs = {
1442     _void_g_object_ref,
1443     g_object_unref,
1444     get_async_cb,
1445   };
1446 
1447   /* Attach a timeout to the main context */
1448   source = g_timeout_source_new (dc-&gt;priv-&gt;timeout / GST_MSECOND);
1449   g_source_set_callback_indirect (source, g_object_ref (dc), &amp;cb_funcs);
<span class="line-modified">1450   dc-&gt;priv-&gt;timeoutid = g_source_attach (source, dc-&gt;priv-&gt;ctx);</span>
<span class="line-modified">1451   g_source_unref (source);</span>
1452 }
1453 
1454 
1455 /* Returns TRUE if processing should stop */
1456 static gboolean
1457 handle_message (GstDiscoverer * dc, GstMessage * msg)
1458 {
1459   gboolean done = FALSE;
1460   const gchar *dump_name = NULL;
1461 
1462   GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;got a %s message&quot;,
1463       GST_MESSAGE_TYPE_NAME (msg));
1464 
1465   switch (GST_MESSAGE_TYPE (msg)) {
1466     case GST_MESSAGE_ERROR:{
1467       GError *gerr;
1468       gchar *debug;
1469 
1470       gst_message_parse_error (msg, &amp;gerr, &amp;debug);
1471       GST_WARNING_OBJECT (GST_MESSAGE_SRC (msg),
</pre>
<hr />
<pre>
1644     }
1645   } while (!done &amp;&amp; (g_timer_elapsed (timer, NULL) &lt; deadline));
1646 
1647   /* return result */
1648   if (!done) {
1649     GST_DEBUG (&quot;we timed out! Setting result to TIMEOUT&quot;);
1650     dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_TIMEOUT;
1651   }
1652 
1653   DISCO_LOCK (dc);
1654   dc-&gt;priv-&gt;processing = FALSE;
1655   DISCO_UNLOCK (dc);
1656 
1657 
1658   GST_DEBUG (&quot;Done&quot;);
1659 
1660   g_timer_stop (timer);
1661   g_timer_destroy (timer);
1662 }
1663 
<span class="line-modified">1664 static void</span>











































































1665 _setup_locked (GstDiscoverer * dc)
1666 {
1667   GstStateChangeReturn ret;























1668 
1669   GST_DEBUG (&quot;Setting up&quot;);
1670 
1671   /* Pop URI off the pending URI list */
1672   dc-&gt;priv-&gt;current_info =
1673       (GstDiscovererInfo *) g_object_new (GST_TYPE_DISCOVERER_INFO, NULL);
<span class="line-modified">1674   dc-&gt;priv-&gt;current_info-&gt;uri = (gchar *) dc-&gt;priv-&gt;pending_uris-&gt;data;</span>
<span class="line-modified">1675   dc-&gt;priv-&gt;pending_uris =</span>
<span class="line-removed">1676       g_list_delete_link (dc-&gt;priv-&gt;pending_uris, dc-&gt;priv-&gt;pending_uris);</span>
1677 
1678   /* set uri on uridecodebin */
1679   g_object_set (dc-&gt;priv-&gt;uridecodebin, &quot;uri&quot;, dc-&gt;priv-&gt;current_info-&gt;uri,
1680       NULL);
1681 
1682   GST_DEBUG (&quot;Current is now %s&quot;, dc-&gt;priv-&gt;current_info-&gt;uri);
1683 
1684   dc-&gt;priv-&gt;processing = TRUE;
1685 
1686   dc-&gt;priv-&gt;target_state = GST_STATE_PAUSED;
1687 
1688   /* set pipeline to PAUSED */
1689   DISCO_UNLOCK (dc);
1690   GST_DEBUG (&quot;Setting pipeline to PAUSED&quot;);
1691   ret =
1692       gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline,
1693       dc-&gt;priv-&gt;target_state);
1694 
1695   if (ret == GST_STATE_CHANGE_NO_PREROLL) {
1696     GST_DEBUG (&quot;Source is live, switching to PLAYING&quot;);
1697     dc-&gt;priv-&gt;target_state = GST_STATE_PLAYING;
1698     ret =
1699         gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline,
1700         dc-&gt;priv-&gt;target_state);
1701   }
1702   DISCO_LOCK (dc);
1703 
1704 
1705   GST_DEBUG_OBJECT (dc, &quot;Pipeline going to PAUSED : %s&quot;,
1706       gst_element_state_change_return_get_name (ret));


1707 }
1708 
1709 static void
1710 discoverer_cleanup (GstDiscoverer * dc)
1711 {
1712   GST_DEBUG (&quot;Cleaning up&quot;);
1713 
1714   DISCO_LOCK (dc);
1715   dc-&gt;priv-&gt;cleanup = TRUE;
1716   DISCO_UNLOCK (dc);
1717 
1718   gst_bus_set_flushing (dc-&gt;priv-&gt;bus, TRUE);
1719 
1720   DISCO_LOCK (dc);
1721   if (dc-&gt;priv-&gt;current_error) {
1722     g_error_free (dc-&gt;priv-&gt;current_error);
1723     DISCO_UNLOCK (dc);
1724     gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline, GST_STATE_NULL);
1725   } else {
1726     DISCO_UNLOCK (dc);
</pre>
<hr />
<pre>
1731 
1732   DISCO_LOCK (dc);
1733   dc-&gt;priv-&gt;current_error = NULL;
1734   if (dc-&gt;priv-&gt;current_topology) {
1735     gst_structure_free (dc-&gt;priv-&gt;current_topology);
1736     dc-&gt;priv-&gt;current_topology = NULL;
1737   }
1738 
1739   dc-&gt;priv-&gt;current_info = NULL;
1740 
1741   dc-&gt;priv-&gt;pending_subtitle_pads = 0;
1742 
1743   dc-&gt;priv-&gt;current_state = GST_STATE_NULL;
1744   dc-&gt;priv-&gt;target_state = GST_STATE_NULL;
1745   dc-&gt;priv-&gt;no_more_pads = FALSE;
1746   dc-&gt;priv-&gt;cleanup = FALSE;
1747 
1748 
1749   /* Try popping the next uri */
1750   if (dc-&gt;priv-&gt;async) {
<span class="line-modified">1751     if (dc-&gt;priv-&gt;pending_uris != NULL) {</span>
<span class="line-removed">1752       _setup_locked (dc);</span>
<span class="line-removed">1753       DISCO_UNLOCK (dc);</span>
<span class="line-removed">1754       /* Start timeout */</span>
<span class="line-removed">1755       handle_current_async (dc);</span>
<span class="line-removed">1756     } else {</span>
<span class="line-removed">1757       /* We&#39;re done ! */</span>
<span class="line-removed">1758       DISCO_UNLOCK (dc);</span>
<span class="line-removed">1759       g_signal_emit (dc, gst_discoverer_signals[SIGNAL_FINISHED], 0);</span>
<span class="line-removed">1760     }</span>
1761   } else
1762     DISCO_UNLOCK (dc);
1763 
1764   GST_DEBUG (&quot;out&quot;);
1765 }
1766 
1767 static void
1768 discoverer_bus_cb (GstBus * bus, GstMessage * msg, GstDiscoverer * dc)
1769 {
1770   if (dc-&gt;priv-&gt;processing) {
1771     if (handle_message (dc, msg)) {
1772       GST_DEBUG (&quot;Stopping asynchronously&quot;);
1773       /* Serialise with _event_probe() */
1774       DISCO_LOCK (dc);
1775       dc-&gt;priv-&gt;processing = FALSE;
1776       DISCO_UNLOCK (dc);
1777       discoverer_collect (dc);
1778       discoverer_cleanup (dc);
1779     }
1780   }
1781 }
1782 
1783 static gboolean
1784 async_timeout_cb (GstDiscoverer * dc)
1785 {
1786   if (!g_source_is_destroyed (g_main_current_source ())) {
<span class="line-removed">1787     dc-&gt;priv-&gt;timeoutid = 0;</span>
1788     GST_DEBUG (&quot;Setting result to TIMEOUT&quot;);
1789     dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_TIMEOUT;
1790     dc-&gt;priv-&gt;processing = FALSE;
1791     discoverer_collect (dc);
1792     discoverer_cleanup (dc);
1793   }
1794   return FALSE;
1795 }
1796 
1797 /* If there is a pending URI, it will pop it from the list of pending
1798  * URIs and start the discovery on it.
1799  *
1800  * Returns GST_DISCOVERER_OK if the next URI was popped and is processing,
1801  * else a error flag.
1802  */
1803 static GstDiscovererResult
1804 start_discovering (GstDiscoverer * dc)
1805 {

1806   GstDiscovererResult res = GST_DISCOVERER_OK;
1807 
1808   GST_DEBUG (&quot;Starting&quot;);
1809 
1810   DISCO_LOCK (dc);
1811   if (dc-&gt;priv-&gt;pending_uris == NULL) {
1812     GST_WARNING (&quot;No URI to process&quot;);
1813     res = GST_DISCOVERER_URI_INVALID;
1814     DISCO_UNLOCK (dc);
1815     goto beach;
1816   }
1817 
1818   if (dc-&gt;priv-&gt;current_info != NULL) {
1819     GST_WARNING (&quot;Already processing a file&quot;);
1820     res = GST_DISCOVERER_BUSY;
1821     DISCO_UNLOCK (dc);
1822     goto beach;
1823   }
1824 
1825   g_signal_emit (dc, gst_discoverer_signals[SIGNAL_STARTING], 0);
1826 
<span class="line-modified">1827   _setup_locked (dc);</span>
1828 
1829   DISCO_UNLOCK (dc);
1830 
<span class="line-modified">1831   if (dc-&gt;priv-&gt;async)</span>








1832     handle_current_async (dc);
<span class="line-modified">1833   else</span>
<span class="line-modified">1834     handle_current_sync (dc);</span>


1835 
1836 beach:
1837   return res;
1838 }
1839 
1840 /* Serializing code */
1841 
1842 static GVariant *
1843 _serialize_common_stream_info (GstDiscovererStreamInfo * sinfo,
1844     GstDiscovererSerializeFlags flags)
1845 {
1846   GVariant *common;

1847   gchar *caps_str = NULL, *tags_str = NULL, *misc_str = NULL;
1848 
1849   if (sinfo-&gt;caps &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_CAPS))
1850     caps_str = gst_caps_to_string (sinfo-&gt;caps);
1851 
1852   if (sinfo-&gt;tags &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_TAGS))
1853     tags_str = gst_tag_list_to_string (sinfo-&gt;tags);
1854 
1855   if (sinfo-&gt;misc &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_MISC))
1856     misc_str = gst_structure_to_string (sinfo-&gt;misc);
1857 






1858   common =
<span class="line-modified">1859       g_variant_new (&quot;(msmsmsms)&quot;, sinfo-&gt;stream_id, caps_str, tags_str,</span>
<span class="line-modified">1860       misc_str);</span>
1861 
1862   g_free (caps_str);
1863   g_free (tags_str);
1864   g_free (misc_str);
1865 
1866   return common;
1867 }
1868 
1869 static GVariant *
1870 _serialize_info (GstDiscovererInfo * info, GstDiscovererSerializeFlags flags)
1871 {
1872   gchar *tags_str = NULL;
1873   GVariant *ret;
1874 
1875   if (info-&gt;tags &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_TAGS))
1876     tags_str = gst_tag_list_to_string (info-&gt;tags);
1877 
1878   ret =
1879       g_variant_new (&quot;(mstbmsb)&quot;, info-&gt;uri, info-&gt;duration, info-&gt;seekable,
1880       tags_str, info-&gt;live);
</pre>
<hr />
<pre>
1945           g_variant_new (&quot;(yvav)&quot;, &#39;c&#39;, common_stream_variant, NULL);
1946     }
1947 
1948     gst_discoverer_stream_info_list_free (streams);
1949   } else if (GST_IS_DISCOVERER_AUDIO_INFO (sinfo)) {
1950     GVariant *audio_stream_info =
1951         _serialize_audio_stream_info (GST_DISCOVERER_AUDIO_INFO (sinfo));
1952     stream_variant =
1953         g_variant_new (&quot;(yvv)&quot;, &#39;a&#39;, common_stream_variant, audio_stream_info);
1954   } else if (GST_IS_DISCOVERER_VIDEO_INFO (sinfo)) {
1955     GVariant *video_stream_info =
1956         _serialize_video_stream_info (GST_DISCOVERER_VIDEO_INFO (sinfo));
1957     stream_variant =
1958         g_variant_new (&quot;(yvv)&quot;, &#39;v&#39;, common_stream_variant, video_stream_info);
1959   } else if (GST_IS_DISCOVERER_SUBTITLE_INFO (sinfo)) {
1960     GVariant *subtitle_stream_info =
1961         _serialize_subtitle_stream_info (GST_DISCOVERER_SUBTITLE_INFO (sinfo));
1962     stream_variant =
1963         g_variant_new (&quot;(yvv)&quot;, &#39;s&#39;, common_stream_variant,
1964         subtitle_stream_info);










1965   }
1966 
1967   return stream_variant;
1968 }
1969 
1970 /* Parsing code */
1971 
1972 #define GET_FROM_TUPLE(v, t, n, val) G_STMT_START{         \
1973   GVariant *child = g_variant_get_child_value (v, n); \
1974   *val = g_variant_get_##t(child); \
1975   g_variant_unref (child); \
1976 }G_STMT_END
1977 
1978 static const gchar *
1979 _maybe_get_string_from_tuple (GVariant * tuple, guint index)
1980 {
1981   const gchar *ret = NULL;
1982   GVariant *maybe;
1983   GET_FROM_TUPLE (tuple, maybe, index, &amp;maybe);
1984   if (maybe) {
</pre>
<hr />
<pre>
1992 static void
1993 _parse_info (GstDiscovererInfo * info, GVariant * info_variant)
1994 {
1995   const gchar *str;
1996 
1997   str = _maybe_get_string_from_tuple (info_variant, 0);
1998   if (str)
1999     info-&gt;uri = g_strdup (str);
2000 
2001   GET_FROM_TUPLE (info_variant, uint64, 1, &amp;info-&gt;duration);
2002   GET_FROM_TUPLE (info_variant, boolean, 2, &amp;info-&gt;seekable);
2003 
2004   str = _maybe_get_string_from_tuple (info_variant, 3);
2005   if (str)
2006     info-&gt;tags = gst_tag_list_new_from_string (str);
2007 
2008   GET_FROM_TUPLE (info_variant, boolean, 4, &amp;info-&gt;live);
2009 }
2010 
2011 static void
<span class="line-modified">2012 _parse_common_stream_info (GstDiscovererStreamInfo * sinfo, GVariant * common)</span>

2013 {
2014   const gchar *str;
2015 
2016   str = _maybe_get_string_from_tuple (common, 0);
2017   if (str)
2018     sinfo-&gt;stream_id = g_strdup (str);
2019 
2020   str = _maybe_get_string_from_tuple (common, 1);
2021   if (str)
2022     sinfo-&gt;caps = gst_caps_from_string (str);
2023 
2024   str = _maybe_get_string_from_tuple (common, 2);
2025   if (str)
2026     sinfo-&gt;tags = gst_tag_list_new_from_string (str);
2027 
2028   str = _maybe_get_string_from_tuple (common, 3);
2029   if (str)
2030     sinfo-&gt;misc = gst_structure_new_from_string (str);
2031 









2032   g_variant_unref (common);
2033 }
2034 
2035 static void
2036 _parse_audio_stream_info (GstDiscovererAudioInfo * ainfo, GVariant * specific)
2037 {
2038   const gchar *str;
2039 
2040   GET_FROM_TUPLE (specific, uint32, 0, &amp;ainfo-&gt;channels);
2041   GET_FROM_TUPLE (specific, uint32, 1, &amp;ainfo-&gt;sample_rate);
2042   GET_FROM_TUPLE (specific, uint32, 2, &amp;ainfo-&gt;bitrate);
2043   GET_FROM_TUPLE (specific, uint32, 3, &amp;ainfo-&gt;max_bitrate);
2044   GET_FROM_TUPLE (specific, uint32, 4, &amp;ainfo-&gt;depth);
2045 
2046   str = _maybe_get_string_from_tuple (specific, 5);
2047 
2048   if (str)
2049     ainfo-&gt;language = g_strdup (str);
2050 
2051   GET_FROM_TUPLE (specific, uint64, 6, &amp;ainfo-&gt;channel_mask);
</pre>
<hr />
<pre>
2097   GET_FROM_TUPLE (variant, byte, 0, &amp;type);
2098   switch (type) {
2099     case &#39;c&#39;:
2100       sinfo = g_object_new (GST_TYPE_DISCOVERER_CONTAINER_INFO, NULL);
2101       break;
2102     case &#39;a&#39;:
2103       sinfo = g_object_new (GST_TYPE_DISCOVERER_AUDIO_INFO, NULL);
2104       _parse_audio_stream_info (GST_DISCOVERER_AUDIO_INFO (sinfo),
2105           g_variant_get_child_value (specific, 0));
2106       break;
2107     case &#39;v&#39;:
2108       sinfo = g_object_new (GST_TYPE_DISCOVERER_VIDEO_INFO, NULL);
2109       _parse_video_stream_info (GST_DISCOVERER_VIDEO_INFO (sinfo),
2110           g_variant_get_child_value (specific, 0));
2111       break;
2112     case &#39;s&#39;:
2113       sinfo = g_object_new (GST_TYPE_DISCOVERER_SUBTITLE_INFO, NULL);
2114       _parse_subtitle_stream_info (GST_DISCOVERER_SUBTITLE_INFO (sinfo),
2115           g_variant_get_child_value (specific, 0));
2116       break;



2117     default:
2118       GST_WARNING (&quot;Unexpected discoverer info type %d&quot;, type);
2119       goto out;
2120   }
2121 
<span class="line-modified">2122   _parse_common_stream_info (sinfo, g_variant_get_child_value (common, 0));</span>

2123 
<span class="line-modified">2124   info-&gt;stream_list = g_list_append (info-&gt;stream_list, sinfo);</span>

2125 
2126   if (!info-&gt;stream_info) {
2127     info-&gt;stream_info = sinfo;
2128   }
2129 
2130   if (GST_IS_DISCOVERER_CONTAINER_INFO (sinfo)) {
2131     GVariantIter iter;
2132     GVariant *child;
2133 
2134     GstDiscovererContainerInfo *cinfo = GST_DISCOVERER_CONTAINER_INFO (sinfo);
2135     g_variant_iter_init (&amp;iter, specific);
2136     while ((child = g_variant_iter_next_value (&amp;iter))) {
2137       GstDiscovererStreamInfo *child_info;
2138       child_info = _parse_discovery (g_variant_get_variant (child), info);
2139       if (child_info != NULL) {
2140         cinfo-&gt;streams =
2141             g_list_append (cinfo-&gt;streams,
2142             gst_discoverer_stream_info_ref (child_info));
2143       }
2144       g_variant_unref (child);
</pre>
<hr />
<pre>
2171 
2172   GST_DEBUG_OBJECT (discoverer, &quot;Starting...&quot;);
2173 
2174   if (discoverer-&gt;priv-&gt;async) {
2175     GST_DEBUG_OBJECT (discoverer, &quot;We were already started&quot;);
2176     return;
2177   }
2178 
2179   discoverer-&gt;priv-&gt;async = TRUE;
2180   discoverer-&gt;priv-&gt;running = TRUE;
2181 
2182   ctx = g_main_context_get_thread_default ();
2183 
2184   /* Connect to bus signals */
2185   if (ctx == NULL)
2186     ctx = g_main_context_default ();
2187 
2188   source = gst_bus_create_watch (discoverer-&gt;priv-&gt;bus);
2189   g_source_set_callback (source, (GSourceFunc) gst_bus_async_signal_func,
2190       NULL, NULL);
<span class="line-modified">2191   discoverer-&gt;priv-&gt;sourceid = g_source_attach (source, ctx);</span>
<span class="line-modified">2192   g_source_unref (source);</span>
2193   discoverer-&gt;priv-&gt;ctx = g_main_context_ref (ctx);
2194 
2195   start_discovering (discoverer);
2196   GST_DEBUG_OBJECT (discoverer, &quot;Started&quot;);
2197 }
2198 
2199 /**
2200  * gst_discoverer_stop:
2201  * @discoverer: A #GstDiscoverer
2202  *
2203  * Stop the discovery of any pending URIs and clears the list of
2204  * pending URIS (if any).
2205  */
2206 void
2207 gst_discoverer_stop (GstDiscoverer * discoverer)
2208 {
2209   g_return_if_fail (GST_IS_DISCOVERER (discoverer));
2210 
2211   GST_DEBUG_OBJECT (discoverer, &quot;Stopping...&quot;);
2212 
</pre>
<hr />
<pre>
2214     GST_DEBUG_OBJECT (discoverer,
2215         &quot;We were already stopped, or running synchronously&quot;);
2216     return;
2217   }
2218 
2219   DISCO_LOCK (discoverer);
2220   if (discoverer-&gt;priv-&gt;processing) {
2221     /* We prevent any further processing by setting the bus to
2222      * flushing and setting the pipeline to READY.
2223      * _reset() will take care of the rest of the cleanup */
2224     if (discoverer-&gt;priv-&gt;bus)
2225       gst_bus_set_flushing (discoverer-&gt;priv-&gt;bus, TRUE);
2226     if (discoverer-&gt;priv-&gt;pipeline)
2227       gst_element_set_state ((GstElement *) discoverer-&gt;priv-&gt;pipeline,
2228           GST_STATE_READY);
2229   }
2230   discoverer-&gt;priv-&gt;running = FALSE;
2231   DISCO_UNLOCK (discoverer);
2232 
2233   /* Remove timeout handler */
<span class="line-modified">2234   if (discoverer-&gt;priv-&gt;timeoutid) {</span>
<span class="line-modified">2235     g_source_remove (discoverer-&gt;priv-&gt;timeoutid);</span>
<span class="line-modified">2236     discoverer-&gt;priv-&gt;timeoutid = 0;</span>

2237   }
2238   /* Remove signal watch */
<span class="line-modified">2239   if (discoverer-&gt;priv-&gt;sourceid) {</span>
<span class="line-modified">2240     g_source_remove (discoverer-&gt;priv-&gt;sourceid);</span>
<span class="line-modified">2241     discoverer-&gt;priv-&gt;sourceid = 0;</span>

2242   }
2243   /* Unref main context */
2244   if (discoverer-&gt;priv-&gt;ctx) {
2245     g_main_context_unref (discoverer-&gt;priv-&gt;ctx);
2246     discoverer-&gt;priv-&gt;ctx = NULL;
2247   }
2248   discoverer_reset (discoverer);
2249 
2250   discoverer-&gt;priv-&gt;async = FALSE;
2251 
2252   GST_DEBUG_OBJECT (discoverer, &quot;Stopped&quot;);
2253 }
2254 
2255 /**
2256  * gst_discoverer_discover_uri_async:
2257  * @discoverer: A #GstDiscoverer
2258  * @uri: the URI to add.
2259  *
2260  * Appends the given @uri to the list of URIs to discoverer. The actual
2261  * discovery of the @uri will only take place if gst_discoverer_start() has
</pre>
<hr />
<pre>
2387  * @info: A #GstDiscovererInfo
2388  * @flags: A combination of #GstDiscovererSerializeFlags to specify
2389  * what needs to be serialized.
2390  *
2391  * Serializes @info to a #GVariant that can be parsed again
2392  * through gst_discoverer_info_from_variant().
2393  *
2394  * Note that any #GstToc (s) that might have been discovered will not be serialized
2395  * for now.
2396  *
2397  * Returns: (transfer full): A newly-allocated #GVariant representing @info.
2398  *
2399  * Since: 1.6
2400  */
2401 GVariant *
2402 gst_discoverer_info_to_variant (GstDiscovererInfo * info,
2403     GstDiscovererSerializeFlags flags)
2404 {
2405   /* FIXME: implement TOC support */
2406   GVariant *stream_variant;
<span class="line-modified">2407   GVariant *variant;</span>
2408   GstDiscovererStreamInfo *sinfo;
2409   GVariant *wrapper;
2410 
2411   g_return_val_if_fail (GST_IS_DISCOVERER_INFO (info), NULL);
2412   g_return_val_if_fail (gst_discoverer_info_get_result (info) ==
2413       GST_DISCOVERER_OK, NULL);
2414 
2415   sinfo = gst_discoverer_info_get_stream_info (info);
2416   stream_variant = gst_discoverer_info_to_variant_recurse (sinfo, flags);
<span class="line-modified">2417   variant =</span>
<span class="line-modified">2418       g_variant_new (&quot;(vv)&quot;, _serialize_info (info, flags), stream_variant);</span>

2419 
2420   /* Returning a wrapper implies some small overhead, but simplifies
2421    * deserializing from bytes */
2422   wrapper = g_variant_new_variant (variant);
2423 
2424   gst_discoverer_stream_info_unref (sinfo);
2425   return wrapper;
2426 }
2427 
2428 /**
2429  * gst_discoverer_info_from_variant:
2430  * @variant: A #GVariant to deserialize into a #GstDiscovererInfo.
2431  *
2432  * Parses a #GVariant as produced by gst_discoverer_info_to_variant()
2433  * back to a #GstDiscovererInfo.
2434  *
2435  * Returns: (transfer full): A newly-allocated #GstDiscovererInfo.
2436  *
2437  * Since: 1.6
2438  */
</pre>
</td>
<td>
<hr />
<pre>
  36  * URIs to be processed (through gst_discoverer_discover_uri_async()) and then
  37  * asks for the discovery to begin (through gst_discoverer_start()).
  38  * By default this will use the GLib default main context unless you have
  39  * set a custom context using g_main_context_push_thread_default().
  40  *
  41  * All the information is returned in a #GstDiscovererInfo structure.
  42  */
  43 
  44 #ifdef HAVE_CONFIG_H
  45 #include &quot;config.h&quot;
  46 #endif
  47 
  48 #include &lt;gst/video/video.h&gt;
  49 #include &lt;gst/audio/audio.h&gt;
  50 
  51 #include &lt;string.h&gt;
  52 
  53 #include &quot;pbutils.h&quot;
  54 #include &quot;pbutils-private.h&quot;
  55 
<span class="line-added">  56 /* For g_stat () */</span>
<span class="line-added">  57 #include &lt;glib/gstdio.h&gt;</span>
<span class="line-added">  58 </span>
  59 GST_DEBUG_CATEGORY_STATIC (discoverer_debug);
  60 #define GST_CAT_DEFAULT discoverer_debug
<span class="line-added">  61 #define CACHE_DIRNAME &quot;discoverer&quot;</span>
  62 
  63 static GQuark _CAPS_QUARK;
  64 static GQuark _TAGS_QUARK;
  65 static GQuark _ELEMENT_SRCPAD_QUARK;
  66 static GQuark _TOC_QUARK;
  67 static GQuark _STREAM_ID_QUARK;
  68 static GQuark _MISSING_PLUGIN_QUARK;
  69 static GQuark _STREAM_TOPOLOGY_QUARK;
  70 static GQuark _TOPOLOGY_PAD_QUARK;
  71 
  72 
  73 typedef struct
  74 {
  75   GstDiscoverer *dc;
  76   GstPad *pad;
  77   GstElement *queue;
  78   GstElement *sink;
  79   GstTagList *tags;
  80   GstToc *toc;
  81   gchar *stream_id;
</pre>
<hr />
<pre>
 111   GList *streams;
 112 
 113   /* List of these sinks and their handler IDs (to remove the probe) */
 114   guint pending_subtitle_pads;
 115 
 116   /* Whether we received no_more_pads */
 117   gboolean no_more_pads;
 118 
 119   GstState target_state;
 120   GstState current_state;
 121 
 122   /* Global elements */
 123   GstBin *pipeline;
 124   GstElement *uridecodebin;
 125   GstBus *bus;
 126 
 127   GType decodebin_type;
 128 
 129   /* Custom main context variables */
 130   GMainContext *ctx;
<span class="line-modified"> 131   GSource *bus_source;</span>
<span class="line-modified"> 132   GSource *timeout_source;</span>
 133 
 134   /* reusable queries */
 135   GstQuery *seeking_query;
 136 
 137   /* Handler ids for various callbacks */
 138   gulong pad_added_id;
 139   gulong pad_remove_id;
 140   gulong no_more_pads_id;
 141   gulong source_chg_id;
 142   gulong element_added_id;
 143   gulong bus_cb_id;
<span class="line-added"> 144 </span>
<span class="line-added"> 145   gboolean use_cache;</span>
 146 };
 147 
 148 #define DISCO_LOCK(dc) g_mutex_lock (&amp;dc-&gt;priv-&gt;lock);
 149 #define DISCO_UNLOCK(dc) g_mutex_unlock (&amp;dc-&gt;priv-&gt;lock);
 150 
 151 static void
 152 _do_init (void)
 153 {
 154   GST_DEBUG_CATEGORY_INIT (discoverer_debug, &quot;discoverer&quot;, 0, &quot;Discoverer&quot;);
 155 
 156   _CAPS_QUARK = g_quark_from_static_string (&quot;caps&quot;);
 157   _ELEMENT_SRCPAD_QUARK = g_quark_from_static_string (&quot;element-srcpad&quot;);
 158   _TAGS_QUARK = g_quark_from_static_string (&quot;tags&quot;);
 159   _TOC_QUARK = g_quark_from_static_string (&quot;toc&quot;);
 160   _STREAM_ID_QUARK = g_quark_from_static_string (&quot;stream-id&quot;);
 161   _MISSING_PLUGIN_QUARK = g_quark_from_static_string (&quot;missing-plugin&quot;);
 162   _STREAM_TOPOLOGY_QUARK = g_quark_from_static_string (&quot;stream-topology&quot;);
 163   _TOPOLOGY_PAD_QUARK = g_quark_from_static_string (&quot;pad&quot;);
 164 };
 165 
 166 G_DEFINE_TYPE_EXTENDED (GstDiscoverer, gst_discoverer, G_TYPE_OBJECT, 0,
<span class="line-modified"> 167     G_ADD_PRIVATE (GstDiscoverer) _do_init ());</span>
 168 
 169 enum
 170 {
 171   SIGNAL_FINISHED,
 172   SIGNAL_STARTING,
 173   SIGNAL_DISCOVERED,
 174   SIGNAL_SOURCE_SETUP,
 175   LAST_SIGNAL
 176 };
 177 
 178 #define DEFAULT_PROP_TIMEOUT 15 * GST_SECOND
<span class="line-added"> 179 #define DEFAULT_PROP_USE_CACHE FALSE</span>
 180 
 181 enum
 182 {
 183   PROP_0,
<span class="line-modified"> 184   PROP_TIMEOUT,</span>
<span class="line-added"> 185   PROP_USE_CACHE</span>
 186 };
 187 
 188 static guint gst_discoverer_signals[LAST_SIGNAL] = { 0 };
 189 
 190 static void gst_discoverer_set_timeout (GstDiscoverer * dc,
 191     GstClockTime timeout);
 192 static gboolean async_timeout_cb (GstDiscoverer * dc);
 193 
 194 static void discoverer_bus_cb (GstBus * bus, GstMessage * msg,
 195     GstDiscoverer * dc);
 196 static void uridecodebin_pad_added_cb (GstElement * uridecodebin, GstPad * pad,
 197     GstDiscoverer * dc);
 198 static void uridecodebin_pad_removed_cb (GstElement * uridecodebin,
 199     GstPad * pad, GstDiscoverer * dc);
 200 static void uridecodebin_no_more_pads_cb (GstElement * uridecodebin,
 201     GstDiscoverer * dc);
 202 static void uridecodebin_source_changed_cb (GstElement * uridecodebin,
 203     GParamSpec * pspec, GstDiscoverer * dc);
 204 
 205 static void gst_discoverer_dispose (GObject * dc);
 206 static void gst_discoverer_finalize (GObject * dc);
 207 static void gst_discoverer_set_property (GObject * object, guint prop_id,
 208     const GValue * value, GParamSpec * pspec);
 209 static void gst_discoverer_get_property (GObject * object, guint prop_id,
 210     GValue * value, GParamSpec * pspec);
<span class="line-added"> 211 static gboolean _setup_locked (GstDiscoverer * dc);</span>
<span class="line-added"> 212 static void handle_current_async (GstDiscoverer * dc);</span>
<span class="line-added"> 213 static gboolean emit_discovererd_and_next (GstDiscoverer * dc);</span>
<span class="line-added"> 214 static GVariant *gst_discoverer_info_to_variant_recurse (GstDiscovererStreamInfo</span>
<span class="line-added"> 215     * sinfo, GstDiscovererSerializeFlags flags);</span>
<span class="line-added"> 216 static GstDiscovererStreamInfo *_parse_discovery (GVariant * variant,</span>
<span class="line-added"> 217     GstDiscovererInfo * info);</span>
 218 
 219 static void
 220 gst_discoverer_class_init (GstDiscovererClass * klass)
 221 {
 222   GObjectClass *gobject_class = (GObjectClass *) klass;
 223 
 224   gobject_class-&gt;dispose = gst_discoverer_dispose;
 225   gobject_class-&gt;finalize = gst_discoverer_finalize;
 226 
 227   gobject_class-&gt;set_property = gst_discoverer_set_property;
 228   gobject_class-&gt;get_property = gst_discoverer_get_property;
 229 

 230 
 231   /* properties */
 232   /**
 233    * GstDiscoverer:timeout:
 234    *
 235    * The duration (in nanoseconds) after which the discovery of an individual
 236    * URI will timeout.
 237    *
 238    * If the discovery of a URI times out, the %GST_DISCOVERER_TIMEOUT will be
 239    * set on the result flags.
 240    */
 241   g_object_class_install_property (gobject_class, PROP_TIMEOUT,
 242       g_param_spec_uint64 (&quot;timeout&quot;, &quot;timeout&quot;, &quot;Timeout&quot;,
 243           GST_SECOND, 3600 * GST_SECOND, DEFAULT_PROP_TIMEOUT,
 244           G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));
 245 
<span class="line-added"> 246   /**</span>
<span class="line-added"> 247    * GstDiscoverer::use-cache:</span>
<span class="line-added"> 248    *</span>
<span class="line-added"> 249    * Whether to use a serialized version of the discoverer info from our</span>
<span class="line-added"> 250    * own cache if accessible. This allows the discovery to be much faster</span>
<span class="line-added"> 251    * as when using this option, we do not need to create a #GstPipeline</span>
<span class="line-added"> 252    * and run it, but instead, just reload the #GstDiscovererInfo in its</span>
<span class="line-added"> 253    * serialized form.</span>
<span class="line-added"> 254    *</span>
<span class="line-added"> 255    * The cache files are saved in `$XDG_CACHE_DIR/gstreamer-1.0/discoverer/`.</span>
<span class="line-added"> 256    *</span>
<span class="line-added"> 257    * Since: 1.16</span>
<span class="line-added"> 258    */</span>
<span class="line-added"> 259   g_object_class_install_property (gobject_class, PROP_USE_CACHE,</span>
<span class="line-added"> 260       g_param_spec_boolean (&quot;use-cache&quot;, &quot;use cache&quot;, &quot;Use cache&quot;,</span>
<span class="line-added"> 261           DEFAULT_PROP_USE_CACHE,</span>
<span class="line-added"> 262           G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));</span>
<span class="line-added"> 263 </span>
 264   /* signals */
 265   /**
 266    * GstDiscoverer::finished:
 267    * @discoverer: the #GstDiscoverer
 268    *
 269    * Will be emitted in async mode when all pending URIs have been processed.
 270    */
 271   gst_discoverer_signals[SIGNAL_FINISHED] =
 272       g_signal_new (&quot;finished&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 273       G_STRUCT_OFFSET (GstDiscovererClass, finished),
 274       NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0, G_TYPE_NONE);
 275 
 276   /**
 277    * GstDiscoverer::starting:
 278    * @discoverer: the #GstDiscoverer
 279    *
 280    * Will be emitted when the discover starts analyzing the pending URIs
 281    */
 282   gst_discoverer_signals[SIGNAL_STARTING] =
 283       g_signal_new (&quot;starting&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
</pre>
<hr />
<pre>
 327 }
 328 
 329 static void
 330 uridecodebin_element_added_cb (GstElement * uridecodebin,
 331     GstElement * child, GstDiscoverer * dc)
 332 {
 333   GST_DEBUG (&quot;New element added to uridecodebin : %s&quot;,
 334       GST_ELEMENT_NAME (child));
 335 
 336   if (G_OBJECT_TYPE (child) == dc-&gt;priv-&gt;decodebin_type) {
 337     g_object_set (child, &quot;post-stream-topology&quot;, TRUE, NULL);
 338   }
 339 }
 340 
 341 static void
 342 gst_discoverer_init (GstDiscoverer * dc)
 343 {
 344   GstElement *tmp;
 345   GstFormat format = GST_FORMAT_TIME;
 346 
<span class="line-modified"> 347   dc-&gt;priv = gst_discoverer_get_instance_private (dc);</span>

 348 
 349   dc-&gt;priv-&gt;timeout = DEFAULT_PROP_TIMEOUT;
<span class="line-added"> 350   dc-&gt;priv-&gt;use_cache = DEFAULT_PROP_USE_CACHE;</span>
 351   dc-&gt;priv-&gt;async = FALSE;
 352 
 353   g_mutex_init (&amp;dc-&gt;priv-&gt;lock);
 354 
 355   dc-&gt;priv-&gt;pending_subtitle_pads = 0;
 356 
 357   dc-&gt;priv-&gt;current_state = GST_STATE_NULL;
 358   dc-&gt;priv-&gt;target_state = GST_STATE_NULL;
 359   dc-&gt;priv-&gt;no_more_pads = FALSE;
 360 
 361   GST_LOG (&quot;Creating pipeline&quot;);
 362   dc-&gt;priv-&gt;pipeline = (GstBin *) gst_pipeline_new (&quot;Discoverer&quot;);
 363   GST_LOG_OBJECT (dc, &quot;Creating uridecodebin&quot;);
 364   dc-&gt;priv-&gt;uridecodebin =
 365       gst_element_factory_make (&quot;uridecodebin&quot;, &quot;discoverer-uri&quot;);
 366   if (G_UNLIKELY (dc-&gt;priv-&gt;uridecodebin == NULL)) {
 367     GST_ERROR (&quot;Can&#39;t create uridecodebin&quot;);
 368     return;
 369   }
 370   GST_LOG_OBJECT (dc, &quot;Adding uridecodebin to pipeline&quot;);
</pre>
<hr />
<pre>
 468 static void
 469 gst_discoverer_finalize (GObject * obj)
 470 {
 471   GstDiscoverer *dc = (GstDiscoverer *) obj;
 472 
 473   g_mutex_clear (&amp;dc-&gt;priv-&gt;lock);
 474 
 475   G_OBJECT_CLASS (gst_discoverer_parent_class)-&gt;finalize (obj);
 476 }
 477 
 478 static void
 479 gst_discoverer_set_property (GObject * object, guint prop_id,
 480     const GValue * value, GParamSpec * pspec)
 481 {
 482   GstDiscoverer *dc = (GstDiscoverer *) object;
 483 
 484   switch (prop_id) {
 485     case PROP_TIMEOUT:
 486       gst_discoverer_set_timeout (dc, g_value_get_uint64 (value));
 487       break;
<span class="line-added"> 488     case PROP_USE_CACHE:</span>
<span class="line-added"> 489       DISCO_LOCK (dc);</span>
<span class="line-added"> 490       dc-&gt;priv-&gt;use_cache = g_value_get_boolean (value);</span>
<span class="line-added"> 491       DISCO_UNLOCK (dc);</span>
<span class="line-added"> 492       break;</span>
 493     default:
 494       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 495       break;
 496   }
 497 }
 498 
 499 static void
 500 gst_discoverer_get_property (GObject * object, guint prop_id,
 501     GValue * value, GParamSpec * pspec)
 502 {
 503   GstDiscoverer *dc = (GstDiscoverer *) object;
 504 
 505   switch (prop_id) {
 506     case PROP_TIMEOUT:
 507       DISCO_LOCK (dc);
 508       g_value_set_uint64 (value, dc-&gt;priv-&gt;timeout);
 509       DISCO_UNLOCK (dc);
 510       break;
<span class="line-added"> 511     case PROP_USE_CACHE:</span>
<span class="line-added"> 512       DISCO_LOCK (dc);</span>
<span class="line-added"> 513       g_value_set_boolean (value, dc-&gt;priv-&gt;use_cache);</span>
<span class="line-added"> 514       DISCO_UNLOCK (dc);</span>
<span class="line-added"> 515       break;</span>
 516     default:
 517       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 518       break;
 519   }
 520 }
 521 
 522 static void
 523 gst_discoverer_set_timeout (GstDiscoverer * dc, GstClockTime timeout)
 524 {
 525   GST_DEBUG_OBJECT (dc, &quot;timeout : %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (timeout));
 526 
 527   /* FIXME : update current pending timeout if we&#39;re running */
 528   DISCO_LOCK (dc);
 529   dc-&gt;priv-&gt;timeout = timeout;
 530   DISCO_UNLOCK (dc);
 531 }
 532 
 533 static GstPadProbeReturn
 534 _event_probe (GstPad * pad, GstPadProbeInfo * info, PrivateStream * ps)
 535 {
</pre>
<hr />
<pre>
 572         GST_DEBUG_OBJECT (pad, &quot;Dropping toc since preroll is done&quot;);
 573       DISCO_UNLOCK (ps-&gt;dc);
 574       break;
 575     }
 576     case GST_EVENT_STREAM_START:{
 577       const gchar *stream_id;
 578 
 579       gst_event_parse_stream_start (event, &amp;stream_id);
 580 
 581       g_free (ps-&gt;stream_id);
 582       ps-&gt;stream_id = stream_id ? g_strdup (stream_id) : NULL;
 583       break;
 584     }
 585     default:
 586       break;
 587   }
 588 
 589   return GST_PAD_PROBE_OK;
 590 }
 591 
<span class="line-modified"> 592 static GstStaticCaps subtitle_caps =</span>
<span class="line-modified"> 593     GST_STATIC_CAPS</span>
<span class="line-modified"> 594     (&quot;application/x-ssa; application/x-ass; application/x-kate&quot;);</span>

 595 
 596 static gboolean
 597 is_subtitle_caps (const GstCaps * caps)
 598 {
 599   GstCaps *subs_caps;
<span class="line-added"> 600   GstStructure *s;</span>
<span class="line-added"> 601   const gchar *name;</span>
 602   gboolean ret;
 603 
<span class="line-added"> 604   s = gst_caps_get_structure (caps, 0);</span>
<span class="line-added"> 605   if (!s)</span>
<span class="line-added"> 606     return FALSE;</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608   name = gst_structure_get_name (s);</span>
<span class="line-added"> 609   if (g_str_has_prefix (name, &quot;text/&quot;) ||</span>
<span class="line-added"> 610       g_str_has_prefix (name, &quot;subpicture/&quot;) ||</span>
<span class="line-added"> 611       g_str_has_prefix (name, &quot;subtitle/&quot;) ||</span>
<span class="line-added"> 612       g_str_has_prefix (name, &quot;closedcaption/&quot;) ||</span>
<span class="line-added"> 613       g_str_has_prefix (name, &quot;application/x-subtitle&quot;))</span>
<span class="line-added"> 614     return TRUE;</span>
<span class="line-added"> 615 </span>
 616   subs_caps = gst_static_caps_get (&amp;subtitle_caps);
 617   ret = gst_caps_can_intersect (caps, subs_caps);
 618   gst_caps_unref (subs_caps);
 619 
 620   return ret;
 621 }
 622 
 623 static GstPadProbeReturn
 624 got_subtitle_data (GstPad * pad, GstPadProbeInfo * info, GstDiscoverer * dc)
 625 {
 626   GstMessage *msg;
 627 
 628   if (!(GST_IS_BUFFER (info-&gt;data) || (GST_IS_EVENT (info-&gt;data)
 629               &amp;&amp; (GST_EVENT_TYPE ((GstEvent *) info-&gt;data) == GST_EVENT_GAP
 630                   || GST_EVENT_TYPE ((GstEvent *) info-&gt;data) ==
 631                   GST_EVENT_EOS))))
 632     return GST_PAD_PROBE_OK;
 633 
 634 
 635   DISCO_LOCK (dc);
</pre>
<hr />
<pre>
1344 
1345     for (i = 0; i &lt; len; i++) {
1346       const GValue *subv = gst_value_list_get_value (nval, i);
1347       const GstStructure *subst = gst_value_get_structure (subv);
1348       GstDiscovererStreamInfo *substream;
1349 
1350       GST_DEBUG (&quot;%d %&quot; GST_PTR_FORMAT, i, subst);
1351 
1352       substream = parse_stream_topology (dc, subst, NULL);
1353 
1354       substream-&gt;previous = res;
1355       cont-&gt;streams =
1356           g_list_append (cont-&gt;streams,
1357           gst_discoverer_stream_info_ref (substream));
1358     }
1359   }
1360 
1361   return res;
1362 }
1363 
<span class="line-added">1364 /* Required DISCO_LOCK to be taken, and will release it */</span>
<span class="line-added">1365 static void</span>
<span class="line-added">1366 setup_next_uri_locked (GstDiscoverer * dc)</span>
<span class="line-added">1367 {</span>
<span class="line-added">1368   if (dc-&gt;priv-&gt;pending_uris != NULL) {</span>
<span class="line-added">1369     gboolean ready = _setup_locked (dc);</span>
<span class="line-added">1370     DISCO_UNLOCK (dc);</span>
<span class="line-added">1371 </span>
<span class="line-added">1372     if (!ready) {</span>
<span class="line-added">1373       /* Start timeout */</span>
<span class="line-added">1374       handle_current_async (dc);</span>
<span class="line-added">1375     } else {</span>
<span class="line-added">1376       g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,</span>
<span class="line-added">1377           (GSourceFunc) emit_discovererd_and_next, gst_object_ref (dc),</span>
<span class="line-added">1378           gst_object_unref);</span>
<span class="line-added">1379     }</span>
<span class="line-added">1380   } else {</span>
<span class="line-added">1381     /* We&#39;re done ! */</span>
<span class="line-added">1382     DISCO_UNLOCK (dc);</span>
<span class="line-added">1383     g_signal_emit (dc, gst_discoverer_signals[SIGNAL_FINISHED], 0);</span>
<span class="line-added">1384   }</span>
<span class="line-added">1385 }</span>
<span class="line-added">1386 </span>
<span class="line-added">1387 </span>
<span class="line-added">1388 static void</span>
<span class="line-added">1389 emit_discovererd (GstDiscoverer * dc)</span>
<span class="line-added">1390 {</span>
<span class="line-added">1391   GST_DEBUG_OBJECT (dc, &quot;Emitting &#39;discoverered&#39; %s&quot;,</span>
<span class="line-added">1392       dc-&gt;priv-&gt;current_info-&gt;uri);</span>
<span class="line-added">1393   g_signal_emit (dc, gst_discoverer_signals[SIGNAL_DISCOVERED], 0,</span>
<span class="line-added">1394       dc-&gt;priv-&gt;current_info, dc-&gt;priv-&gt;current_error);</span>
<span class="line-added">1395   /* Clients get a copy of current_info since it is a boxed type */</span>
<span class="line-added">1396   gst_discoverer_info_unref (dc-&gt;priv-&gt;current_info);</span>
<span class="line-added">1397   dc-&gt;priv-&gt;current_info = NULL;</span>
<span class="line-added">1398 }</span>
<span class="line-added">1399 </span>
<span class="line-added">1400 static gboolean</span>
<span class="line-added">1401 emit_discovererd_and_next (GstDiscoverer * dc)</span>
<span class="line-added">1402 {</span>
<span class="line-added">1403   emit_discovererd (dc);</span>
<span class="line-added">1404 </span>
<span class="line-added">1405   DISCO_LOCK (dc);</span>
<span class="line-added">1406   setup_next_uri_locked (dc);</span>
<span class="line-added">1407 </span>
<span class="line-added">1408   return G_SOURCE_REMOVE;</span>
<span class="line-added">1409 }</span>
<span class="line-added">1410 </span>
1411 /* Called when pipeline is pre-rolled */
1412 static void
1413 discoverer_collect (GstDiscoverer * dc)
1414 {
1415   GST_DEBUG (&quot;Collecting information&quot;);
1416 
1417   /* Stop the timeout handler if present */
<span class="line-modified">1418   if (dc-&gt;priv-&gt;timeout_source) {</span>
<span class="line-modified">1419     g_source_destroy (dc-&gt;priv-&gt;timeout_source);</span>
<span class="line-modified">1420     g_source_unref (dc-&gt;priv-&gt;timeout_source);</span>
<span class="line-added">1421     dc-&gt;priv-&gt;timeout_source = NULL;</span>
<span class="line-added">1422   }</span>
<span class="line-added">1423 </span>
<span class="line-added">1424   if (dc-&gt;priv-&gt;use_cache &amp;&amp; dc-&gt;priv-&gt;current_info</span>
<span class="line-added">1425       &amp;&amp; dc-&gt;priv-&gt;current_info-&gt;from_cache) {</span>
<span class="line-added">1426     GST_DEBUG_OBJECT (dc,</span>
<span class="line-added">1427         &quot;Nothing to collect as the info was built from&quot; &quot; the cache&quot;);</span>
<span class="line-added">1428     return;</span>
1429   }
1430 
1431   if (dc-&gt;priv-&gt;streams) {
1432     /* FIXME : Make this querying optional */
1433     if (TRUE) {
1434       GstElement *pipeline = (GstElement *) dc-&gt;priv-&gt;pipeline;
1435       gint64 dur;
1436 
1437       GST_DEBUG (&quot;Attempting to query duration&quot;);
1438 
1439       if (gst_element_query_duration (pipeline, GST_FORMAT_TIME, &amp;dur)) {
1440         GST_DEBUG (&quot;Got duration %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (dur));
1441         dc-&gt;priv-&gt;current_info-&gt;duration = (guint64) dur;
1442       } else if (dc-&gt;priv-&gt;current_info-&gt;result != GST_DISCOVERER_ERROR) {
1443         GstStateChangeReturn sret;
1444         /* Note: We don&#39;t switch to PLAYING if we previously saw an ERROR since
1445          * the state of various element isn&#39;t guaranteed anymore */
1446 
1447         /* Some parsers may not even return a rough estimate right away, e.g.
1448          * because they&#39;ve only processed a single frame so far, so if we
</pre>
<hr />
<pre>
1502      * initially there are 2, the image and raw stream, but we squash these
1503      * while parsing the stream topology). At some point, if we find that these
1504      * conditions are not sufficient, we can count the number of decoders and
1505      * parsers in the chain, and if there&#39;s more than one decoder, or any
1506      * parser at all, we should not mark this as an image.
1507      */
1508     if (dc-&gt;priv-&gt;current_info-&gt;duration == 0 &amp;&amp;
1509         dc-&gt;priv-&gt;current_info-&gt;stream_info != NULL &amp;&amp;
1510         dc-&gt;priv-&gt;current_info-&gt;stream_info-&gt;next == NULL) {
1511       GstDiscovererStreamInfo *stream_info;
1512       GstStructure *st;
1513 
1514       stream_info = dc-&gt;priv-&gt;current_info-&gt;stream_info;
1515       st = gst_caps_get_structure (stream_info-&gt;caps, 0);
1516 
1517       if (g_str_has_prefix (gst_structure_get_name (st), &quot;image/&quot;))
1518         ((GstDiscovererVideoInfo *) stream_info)-&gt;is_image = TRUE;
1519     }
1520   }
1521 
<span class="line-modified">1522   if (dc-&gt;priv-&gt;use_cache &amp;&amp; dc-&gt;priv-&gt;current_info-&gt;cachefile &amp;&amp;</span>
<span class="line-modified">1523       dc-&gt;priv-&gt;current_info-&gt;result == GST_DISCOVERER_OK) {</span>
<span class="line-modified">1524     GVariant *variant = gst_discoverer_info_to_variant (dc-&gt;priv-&gt;current_info,</span>
<span class="line-modified">1525         GST_DISCOVERER_SERIALIZE_ALL);</span>
<span class="line-modified">1526 </span>
<span class="line-modified">1527     g_file_set_contents (dc-&gt;priv-&gt;current_info-&gt;cachefile,</span>
<span class="line-modified">1528         g_variant_get_data (variant), g_variant_get_size (variant), NULL);</span>
1529   }
<span class="line-added">1530 </span>
<span class="line-added">1531   if (dc-&gt;priv-&gt;async)</span>
<span class="line-added">1532     emit_discovererd (dc);</span>
1533 }
1534 
1535 static void
1536 get_async_cb (gpointer cb_data, GSource * source, GSourceFunc * func,
1537     gpointer * data)
1538 {
1539   *func = (GSourceFunc) async_timeout_cb;
1540   *data = cb_data;
1541 }
1542 
1543 /* Wrapper since GSourceCallbackFuncs don&#39;t expect a return value from ref() */
1544 static void
1545 _void_g_object_ref (gpointer object)
1546 {
1547   g_object_ref (G_OBJECT (object));
1548 }
1549 
1550 static void
1551 handle_current_async (GstDiscoverer * dc)
1552 {
1553   GSource *source;
1554   static GSourceCallbackFuncs cb_funcs = {
1555     _void_g_object_ref,
1556     g_object_unref,
1557     get_async_cb,
1558   };
1559 
1560   /* Attach a timeout to the main context */
1561   source = g_timeout_source_new (dc-&gt;priv-&gt;timeout / GST_MSECOND);
1562   g_source_set_callback_indirect (source, g_object_ref (dc), &amp;cb_funcs);
<span class="line-modified">1563   g_source_attach (source, dc-&gt;priv-&gt;ctx);</span>
<span class="line-modified">1564   dc-&gt;priv-&gt;timeout_source = source;</span>
1565 }
1566 
1567 
1568 /* Returns TRUE if processing should stop */
1569 static gboolean
1570 handle_message (GstDiscoverer * dc, GstMessage * msg)
1571 {
1572   gboolean done = FALSE;
1573   const gchar *dump_name = NULL;
1574 
1575   GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;got a %s message&quot;,
1576       GST_MESSAGE_TYPE_NAME (msg));
1577 
1578   switch (GST_MESSAGE_TYPE (msg)) {
1579     case GST_MESSAGE_ERROR:{
1580       GError *gerr;
1581       gchar *debug;
1582 
1583       gst_message_parse_error (msg, &amp;gerr, &amp;debug);
1584       GST_WARNING_OBJECT (GST_MESSAGE_SRC (msg),
</pre>
<hr />
<pre>
1757     }
1758   } while (!done &amp;&amp; (g_timer_elapsed (timer, NULL) &lt; deadline));
1759 
1760   /* return result */
1761   if (!done) {
1762     GST_DEBUG (&quot;we timed out! Setting result to TIMEOUT&quot;);
1763     dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_TIMEOUT;
1764   }
1765 
1766   DISCO_LOCK (dc);
1767   dc-&gt;priv-&gt;processing = FALSE;
1768   DISCO_UNLOCK (dc);
1769 
1770 
1771   GST_DEBUG (&quot;Done&quot;);
1772 
1773   g_timer_stop (timer);
1774   g_timer_destroy (timer);
1775 }
1776 
<span class="line-modified">1777 static gchar *</span>
<span class="line-added">1778 _serialized_info_get_path (GstDiscoverer * dc, gchar * uri)</span>
<span class="line-added">1779 {</span>
<span class="line-added">1780   GChecksum *cs = NULL;</span>
<span class="line-added">1781   GStatBuf file_status;</span>
<span class="line-added">1782   gchar *location = NULL, *res = NULL, *cache_dir = NULL, *tmp = NULL,</span>
<span class="line-added">1783       *protocol = gst_uri_get_protocol (uri), hash_dirname[3] = &quot;00&quot;;</span>
<span class="line-added">1784   const gchar *checksum;</span>
<span class="line-added">1785 </span>
<span class="line-added">1786   if (g_ascii_strcasecmp (protocol, &quot;file&quot;) != 0) {</span>
<span class="line-added">1787     GST_DEBUG_OBJECT (dc, &quot;Can not work with serialized DiscovererInfo&quot;</span>
<span class="line-added">1788         &quot; on non local files - protocol: %s&quot;, protocol);</span>
<span class="line-added">1789 </span>
<span class="line-added">1790     goto done;</span>
<span class="line-added">1791   }</span>
<span class="line-added">1792 </span>
<span class="line-added">1793   location = gst_uri_get_location (uri);</span>
<span class="line-added">1794   if (g_stat (location, &amp;file_status) &lt; 0) {</span>
<span class="line-added">1795     GST_DEBUG_OBJECT (dc, &quot;Could not get stat for file: %s&quot;, location);</span>
<span class="line-added">1796 </span>
<span class="line-added">1797     goto done;</span>
<span class="line-added">1798   }</span>
<span class="line-added">1799 </span>
<span class="line-added">1800   tmp = g_strdup_printf (&quot;%s-%&quot; G_GSIZE_FORMAT &quot;-%&quot; G_GINT64_FORMAT,</span>
<span class="line-added">1801       location, (gsize) file_status.st_size, (gint64) file_status.st_mtime);</span>
<span class="line-added">1802   cs = g_checksum_new (G_CHECKSUM_SHA1);</span>
<span class="line-added">1803   g_checksum_update (cs, (const guchar *) tmp, strlen (tmp));</span>
<span class="line-added">1804   checksum = g_checksum_get_string (cs);</span>
<span class="line-added">1805 </span>
<span class="line-added">1806   hash_dirname[0] = checksum[0];</span>
<span class="line-added">1807   hash_dirname[1] = checksum[1];</span>
<span class="line-added">1808   cache_dir =</span>
<span class="line-added">1809       g_build_filename (g_get_user_cache_dir (), &quot;gstreamer-&quot; GST_API_VERSION,</span>
<span class="line-added">1810       CACHE_DIRNAME, hash_dirname, NULL);</span>
<span class="line-added">1811   g_mkdir_with_parents (cache_dir, 0777);</span>
<span class="line-added">1812 </span>
<span class="line-added">1813   res = g_build_filename (cache_dir, &amp;checksum[2], NULL);</span>
<span class="line-added">1814 </span>
<span class="line-added">1815 done:</span>
<span class="line-added">1816   g_free (cache_dir);</span>
<span class="line-added">1817   g_free (location);</span>
<span class="line-added">1818   g_free (tmp);</span>
<span class="line-added">1819   g_free (protocol);</span>
<span class="line-added">1820 </span>
<span class="line-added">1821   return res;</span>
<span class="line-added">1822 }</span>
<span class="line-added">1823 </span>
<span class="line-added">1824 static GstDiscovererInfo *</span>
<span class="line-added">1825 _get_info_from_cachefile (GstDiscoverer * dc, gchar * cachefile)</span>
<span class="line-added">1826 {</span>
<span class="line-added">1827   gchar *data;</span>
<span class="line-added">1828   gsize length;</span>
<span class="line-added">1829 </span>
<span class="line-added">1830   if (g_file_get_contents (cachefile, &amp;data, &amp;length, NULL)) {</span>
<span class="line-added">1831     GstDiscovererInfo *info = NULL;</span>
<span class="line-added">1832     GVariant *variant =</span>
<span class="line-added">1833         g_variant_new_from_data (G_VARIANT_TYPE (&quot;v&quot;), data, length,</span>
<span class="line-added">1834         TRUE, NULL, NULL);</span>
<span class="line-added">1835 </span>
<span class="line-added">1836     info = gst_discoverer_info_from_variant (variant);</span>
<span class="line-added">1837     g_variant_unref (variant);</span>
<span class="line-added">1838 </span>
<span class="line-added">1839     if (info) {</span>
<span class="line-added">1840       info-&gt;cachefile = cachefile;</span>
<span class="line-added">1841       info-&gt;from_cache = (gpointer) 0x01;</span>
<span class="line-added">1842     }</span>
<span class="line-added">1843 </span>
<span class="line-added">1844     GST_INFO_OBJECT (dc, &quot;Got info from cache: %p&quot;, info);</span>
<span class="line-added">1845 </span>
<span class="line-added">1846     return info;</span>
<span class="line-added">1847   }</span>
<span class="line-added">1848 </span>
<span class="line-added">1849   return NULL;</span>
<span class="line-added">1850 }</span>
<span class="line-added">1851 </span>
<span class="line-added">1852 static gboolean</span>
1853 _setup_locked (GstDiscoverer * dc)
1854 {
1855   GstStateChangeReturn ret;
<span class="line-added">1856   gchar *uri = (gchar *) dc-&gt;priv-&gt;pending_uris-&gt;data;</span>
<span class="line-added">1857   gchar *cachefile = NULL;</span>
<span class="line-added">1858 </span>
<span class="line-added">1859   dc-&gt;priv-&gt;pending_uris =</span>
<span class="line-added">1860       g_list_delete_link (dc-&gt;priv-&gt;pending_uris, dc-&gt;priv-&gt;pending_uris);</span>
<span class="line-added">1861 </span>
<span class="line-added">1862   if (dc-&gt;priv-&gt;use_cache) {</span>
<span class="line-added">1863     cachefile = _serialized_info_get_path (dc, uri);</span>
<span class="line-added">1864     if (cachefile)</span>
<span class="line-added">1865       dc-&gt;priv-&gt;current_info = _get_info_from_cachefile (dc, cachefile);</span>
<span class="line-added">1866 </span>
<span class="line-added">1867     if (dc-&gt;priv-&gt;current_info) {</span>
<span class="line-added">1868       /* Make sure the URI is exactly what the user passed in */</span>
<span class="line-added">1869       g_free (dc-&gt;priv-&gt;current_info-&gt;uri);</span>
<span class="line-added">1870       dc-&gt;priv-&gt;current_info-&gt;uri = uri;</span>
<span class="line-added">1871 </span>
<span class="line-added">1872       dc-&gt;priv-&gt;current_info-&gt;cachefile = cachefile;</span>
<span class="line-added">1873       dc-&gt;priv-&gt;processing = FALSE;</span>
<span class="line-added">1874       dc-&gt;priv-&gt;target_state = GST_STATE_NULL;</span>
<span class="line-added">1875 </span>
<span class="line-added">1876       return TRUE;</span>
<span class="line-added">1877     }</span>
<span class="line-added">1878   }</span>
1879 
1880   GST_DEBUG (&quot;Setting up&quot;);
1881 
1882   /* Pop URI off the pending URI list */
1883   dc-&gt;priv-&gt;current_info =
1884       (GstDiscovererInfo *) g_object_new (GST_TYPE_DISCOVERER_INFO, NULL);
<span class="line-modified">1885   dc-&gt;priv-&gt;current_info-&gt;cachefile = cachefile;</span>
<span class="line-modified">1886   dc-&gt;priv-&gt;current_info-&gt;uri = uri;</span>

1887 
1888   /* set uri on uridecodebin */
1889   g_object_set (dc-&gt;priv-&gt;uridecodebin, &quot;uri&quot;, dc-&gt;priv-&gt;current_info-&gt;uri,
1890       NULL);
1891 
1892   GST_DEBUG (&quot;Current is now %s&quot;, dc-&gt;priv-&gt;current_info-&gt;uri);
1893 
1894   dc-&gt;priv-&gt;processing = TRUE;
1895 
1896   dc-&gt;priv-&gt;target_state = GST_STATE_PAUSED;
1897 
1898   /* set pipeline to PAUSED */
1899   DISCO_UNLOCK (dc);
1900   GST_DEBUG (&quot;Setting pipeline to PAUSED&quot;);
1901   ret =
1902       gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline,
1903       dc-&gt;priv-&gt;target_state);
1904 
1905   if (ret == GST_STATE_CHANGE_NO_PREROLL) {
1906     GST_DEBUG (&quot;Source is live, switching to PLAYING&quot;);
1907     dc-&gt;priv-&gt;target_state = GST_STATE_PLAYING;
1908     ret =
1909         gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline,
1910         dc-&gt;priv-&gt;target_state);
1911   }
1912   DISCO_LOCK (dc);
1913 
1914 
1915   GST_DEBUG_OBJECT (dc, &quot;Pipeline going to PAUSED : %s&quot;,
1916       gst_element_state_change_return_get_name (ret));
<span class="line-added">1917 </span>
<span class="line-added">1918   return FALSE;</span>
1919 }
1920 
1921 static void
1922 discoverer_cleanup (GstDiscoverer * dc)
1923 {
1924   GST_DEBUG (&quot;Cleaning up&quot;);
1925 
1926   DISCO_LOCK (dc);
1927   dc-&gt;priv-&gt;cleanup = TRUE;
1928   DISCO_UNLOCK (dc);
1929 
1930   gst_bus_set_flushing (dc-&gt;priv-&gt;bus, TRUE);
1931 
1932   DISCO_LOCK (dc);
1933   if (dc-&gt;priv-&gt;current_error) {
1934     g_error_free (dc-&gt;priv-&gt;current_error);
1935     DISCO_UNLOCK (dc);
1936     gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline, GST_STATE_NULL);
1937   } else {
1938     DISCO_UNLOCK (dc);
</pre>
<hr />
<pre>
1943 
1944   DISCO_LOCK (dc);
1945   dc-&gt;priv-&gt;current_error = NULL;
1946   if (dc-&gt;priv-&gt;current_topology) {
1947     gst_structure_free (dc-&gt;priv-&gt;current_topology);
1948     dc-&gt;priv-&gt;current_topology = NULL;
1949   }
1950 
1951   dc-&gt;priv-&gt;current_info = NULL;
1952 
1953   dc-&gt;priv-&gt;pending_subtitle_pads = 0;
1954 
1955   dc-&gt;priv-&gt;current_state = GST_STATE_NULL;
1956   dc-&gt;priv-&gt;target_state = GST_STATE_NULL;
1957   dc-&gt;priv-&gt;no_more_pads = FALSE;
1958   dc-&gt;priv-&gt;cleanup = FALSE;
1959 
1960 
1961   /* Try popping the next uri */
1962   if (dc-&gt;priv-&gt;async) {
<span class="line-modified">1963     setup_next_uri_locked (dc);</span>









1964   } else
1965     DISCO_UNLOCK (dc);
1966 
1967   GST_DEBUG (&quot;out&quot;);
1968 }
1969 
1970 static void
1971 discoverer_bus_cb (GstBus * bus, GstMessage * msg, GstDiscoverer * dc)
1972 {
1973   if (dc-&gt;priv-&gt;processing) {
1974     if (handle_message (dc, msg)) {
1975       GST_DEBUG (&quot;Stopping asynchronously&quot;);
1976       /* Serialise with _event_probe() */
1977       DISCO_LOCK (dc);
1978       dc-&gt;priv-&gt;processing = FALSE;
1979       DISCO_UNLOCK (dc);
1980       discoverer_collect (dc);
1981       discoverer_cleanup (dc);
1982     }
1983   }
1984 }
1985 
1986 static gboolean
1987 async_timeout_cb (GstDiscoverer * dc)
1988 {
1989   if (!g_source_is_destroyed (g_main_current_source ())) {

1990     GST_DEBUG (&quot;Setting result to TIMEOUT&quot;);
1991     dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_TIMEOUT;
1992     dc-&gt;priv-&gt;processing = FALSE;
1993     discoverer_collect (dc);
1994     discoverer_cleanup (dc);
1995   }
1996   return FALSE;
1997 }
1998 
1999 /* If there is a pending URI, it will pop it from the list of pending
2000  * URIs and start the discovery on it.
2001  *
2002  * Returns GST_DISCOVERER_OK if the next URI was popped and is processing,
2003  * else a error flag.
2004  */
2005 static GstDiscovererResult
2006 start_discovering (GstDiscoverer * dc)
2007 {
<span class="line-added">2008   gboolean ready;</span>
2009   GstDiscovererResult res = GST_DISCOVERER_OK;
2010 
2011   GST_DEBUG (&quot;Starting&quot;);
2012 
2013   DISCO_LOCK (dc);
2014   if (dc-&gt;priv-&gt;pending_uris == NULL) {
2015     GST_WARNING (&quot;No URI to process&quot;);
2016     res = GST_DISCOVERER_URI_INVALID;
2017     DISCO_UNLOCK (dc);
2018     goto beach;
2019   }
2020 
2021   if (dc-&gt;priv-&gt;current_info != NULL) {
2022     GST_WARNING (&quot;Already processing a file&quot;);
2023     res = GST_DISCOVERER_BUSY;
2024     DISCO_UNLOCK (dc);
2025     goto beach;
2026   }
2027 
2028   g_signal_emit (dc, gst_discoverer_signals[SIGNAL_STARTING], 0);
2029 
<span class="line-modified">2030   ready = _setup_locked (dc);</span>
2031 
2032   DISCO_UNLOCK (dc);
2033 
<span class="line-modified">2034   if (dc-&gt;priv-&gt;async) {</span>
<span class="line-added">2035     if (ready) {</span>
<span class="line-added">2036       g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,</span>
<span class="line-added">2037           (GSourceFunc) emit_discovererd_and_next, gst_object_ref (dc),</span>
<span class="line-added">2038           gst_object_unref);</span>
<span class="line-added">2039 </span>
<span class="line-added">2040       goto beach;</span>
<span class="line-added">2041     }</span>
<span class="line-added">2042 </span>
2043     handle_current_async (dc);
<span class="line-modified">2044   } else {</span>
<span class="line-modified">2045     if (!ready)</span>
<span class="line-added">2046       handle_current_sync (dc);</span>
<span class="line-added">2047   }</span>
2048 
2049 beach:
2050   return res;
2051 }
2052 
2053 /* Serializing code */
2054 
2055 static GVariant *
2056 _serialize_common_stream_info (GstDiscovererStreamInfo * sinfo,
2057     GstDiscovererSerializeFlags flags)
2058 {
2059   GVariant *common;
<span class="line-added">2060   GVariant *nextv = NULL;</span>
2061   gchar *caps_str = NULL, *tags_str = NULL, *misc_str = NULL;
2062 
2063   if (sinfo-&gt;caps &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_CAPS))
2064     caps_str = gst_caps_to_string (sinfo-&gt;caps);
2065 
2066   if (sinfo-&gt;tags &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_TAGS))
2067     tags_str = gst_tag_list_to_string (sinfo-&gt;tags);
2068 
2069   if (sinfo-&gt;misc &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_MISC))
2070     misc_str = gst_structure_to_string (sinfo-&gt;misc);
2071 
<span class="line-added">2072 </span>
<span class="line-added">2073   if (sinfo-&gt;next)</span>
<span class="line-added">2074     nextv = gst_discoverer_info_to_variant_recurse (sinfo-&gt;next, flags);</span>
<span class="line-added">2075   else</span>
<span class="line-added">2076     nextv = g_variant_new (&quot;()&quot;);</span>
<span class="line-added">2077 </span>
2078   common =
<span class="line-modified">2079       g_variant_new (&quot;(msmsmsmsv)&quot;, sinfo-&gt;stream_id, caps_str, tags_str,</span>
<span class="line-modified">2080       misc_str, nextv);</span>
2081 
2082   g_free (caps_str);
2083   g_free (tags_str);
2084   g_free (misc_str);
2085 
2086   return common;
2087 }
2088 
2089 static GVariant *
2090 _serialize_info (GstDiscovererInfo * info, GstDiscovererSerializeFlags flags)
2091 {
2092   gchar *tags_str = NULL;
2093   GVariant *ret;
2094 
2095   if (info-&gt;tags &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_TAGS))
2096     tags_str = gst_tag_list_to_string (info-&gt;tags);
2097 
2098   ret =
2099       g_variant_new (&quot;(mstbmsb)&quot;, info-&gt;uri, info-&gt;duration, info-&gt;seekable,
2100       tags_str, info-&gt;live);
</pre>
<hr />
<pre>
2165           g_variant_new (&quot;(yvav)&quot;, &#39;c&#39;, common_stream_variant, NULL);
2166     }
2167 
2168     gst_discoverer_stream_info_list_free (streams);
2169   } else if (GST_IS_DISCOVERER_AUDIO_INFO (sinfo)) {
2170     GVariant *audio_stream_info =
2171         _serialize_audio_stream_info (GST_DISCOVERER_AUDIO_INFO (sinfo));
2172     stream_variant =
2173         g_variant_new (&quot;(yvv)&quot;, &#39;a&#39;, common_stream_variant, audio_stream_info);
2174   } else if (GST_IS_DISCOVERER_VIDEO_INFO (sinfo)) {
2175     GVariant *video_stream_info =
2176         _serialize_video_stream_info (GST_DISCOVERER_VIDEO_INFO (sinfo));
2177     stream_variant =
2178         g_variant_new (&quot;(yvv)&quot;, &#39;v&#39;, common_stream_variant, video_stream_info);
2179   } else if (GST_IS_DISCOVERER_SUBTITLE_INFO (sinfo)) {
2180     GVariant *subtitle_stream_info =
2181         _serialize_subtitle_stream_info (GST_DISCOVERER_SUBTITLE_INFO (sinfo));
2182     stream_variant =
2183         g_variant_new (&quot;(yvv)&quot;, &#39;s&#39;, common_stream_variant,
2184         subtitle_stream_info);
<span class="line-added">2185   } else {</span>
<span class="line-added">2186     GVariant *nextv = NULL;</span>
<span class="line-added">2187     GstDiscovererStreamInfo *ninfo =</span>
<span class="line-added">2188         gst_discoverer_stream_info_get_next (sinfo);</span>
<span class="line-added">2189 </span>
<span class="line-added">2190     nextv = gst_discoverer_info_to_variant_recurse (ninfo, flags);</span>
<span class="line-added">2191 </span>
<span class="line-added">2192     stream_variant =</span>
<span class="line-added">2193         g_variant_new (&quot;(yvv)&quot;, &#39;n&#39;, common_stream_variant,</span>
<span class="line-added">2194         g_variant_new (&quot;v&quot;, nextv));</span>
2195   }
2196 
2197   return stream_variant;
2198 }
2199 
2200 /* Parsing code */
2201 
2202 #define GET_FROM_TUPLE(v, t, n, val) G_STMT_START{         \
2203   GVariant *child = g_variant_get_child_value (v, n); \
2204   *val = g_variant_get_##t(child); \
2205   g_variant_unref (child); \
2206 }G_STMT_END
2207 
2208 static const gchar *
2209 _maybe_get_string_from_tuple (GVariant * tuple, guint index)
2210 {
2211   const gchar *ret = NULL;
2212   GVariant *maybe;
2213   GET_FROM_TUPLE (tuple, maybe, index, &amp;maybe);
2214   if (maybe) {
</pre>
<hr />
<pre>
2222 static void
2223 _parse_info (GstDiscovererInfo * info, GVariant * info_variant)
2224 {
2225   const gchar *str;
2226 
2227   str = _maybe_get_string_from_tuple (info_variant, 0);
2228   if (str)
2229     info-&gt;uri = g_strdup (str);
2230 
2231   GET_FROM_TUPLE (info_variant, uint64, 1, &amp;info-&gt;duration);
2232   GET_FROM_TUPLE (info_variant, boolean, 2, &amp;info-&gt;seekable);
2233 
2234   str = _maybe_get_string_from_tuple (info_variant, 3);
2235   if (str)
2236     info-&gt;tags = gst_tag_list_new_from_string (str);
2237 
2238   GET_FROM_TUPLE (info_variant, boolean, 4, &amp;info-&gt;live);
2239 }
2240 
2241 static void
<span class="line-modified">2242 _parse_common_stream_info (GstDiscovererStreamInfo * sinfo, GVariant * common,</span>
<span class="line-added">2243     GstDiscovererInfo * info)</span>
2244 {
2245   const gchar *str;
2246 
2247   str = _maybe_get_string_from_tuple (common, 0);
2248   if (str)
2249     sinfo-&gt;stream_id = g_strdup (str);
2250 
2251   str = _maybe_get_string_from_tuple (common, 1);
2252   if (str)
2253     sinfo-&gt;caps = gst_caps_from_string (str);
2254 
2255   str = _maybe_get_string_from_tuple (common, 2);
2256   if (str)
2257     sinfo-&gt;tags = gst_tag_list_new_from_string (str);
2258 
2259   str = _maybe_get_string_from_tuple (common, 3);
2260   if (str)
2261     sinfo-&gt;misc = gst_structure_new_from_string (str);
2262 
<span class="line-added">2263   if (g_variant_n_children (common) &gt; 4) {</span>
<span class="line-added">2264     GVariant *nextv;</span>
<span class="line-added">2265 </span>
<span class="line-added">2266     GET_FROM_TUPLE (common, variant, 4, &amp;nextv);</span>
<span class="line-added">2267     if (g_variant_n_children (nextv) &gt; 0) {</span>
<span class="line-added">2268       sinfo-&gt;next = _parse_discovery (nextv, info);</span>
<span class="line-added">2269     }</span>
<span class="line-added">2270   }</span>
<span class="line-added">2271 </span>
2272   g_variant_unref (common);
2273 }
2274 
2275 static void
2276 _parse_audio_stream_info (GstDiscovererAudioInfo * ainfo, GVariant * specific)
2277 {
2278   const gchar *str;
2279 
2280   GET_FROM_TUPLE (specific, uint32, 0, &amp;ainfo-&gt;channels);
2281   GET_FROM_TUPLE (specific, uint32, 1, &amp;ainfo-&gt;sample_rate);
2282   GET_FROM_TUPLE (specific, uint32, 2, &amp;ainfo-&gt;bitrate);
2283   GET_FROM_TUPLE (specific, uint32, 3, &amp;ainfo-&gt;max_bitrate);
2284   GET_FROM_TUPLE (specific, uint32, 4, &amp;ainfo-&gt;depth);
2285 
2286   str = _maybe_get_string_from_tuple (specific, 5);
2287 
2288   if (str)
2289     ainfo-&gt;language = g_strdup (str);
2290 
2291   GET_FROM_TUPLE (specific, uint64, 6, &amp;ainfo-&gt;channel_mask);
</pre>
<hr />
<pre>
2337   GET_FROM_TUPLE (variant, byte, 0, &amp;type);
2338   switch (type) {
2339     case &#39;c&#39;:
2340       sinfo = g_object_new (GST_TYPE_DISCOVERER_CONTAINER_INFO, NULL);
2341       break;
2342     case &#39;a&#39;:
2343       sinfo = g_object_new (GST_TYPE_DISCOVERER_AUDIO_INFO, NULL);
2344       _parse_audio_stream_info (GST_DISCOVERER_AUDIO_INFO (sinfo),
2345           g_variant_get_child_value (specific, 0));
2346       break;
2347     case &#39;v&#39;:
2348       sinfo = g_object_new (GST_TYPE_DISCOVERER_VIDEO_INFO, NULL);
2349       _parse_video_stream_info (GST_DISCOVERER_VIDEO_INFO (sinfo),
2350           g_variant_get_child_value (specific, 0));
2351       break;
2352     case &#39;s&#39;:
2353       sinfo = g_object_new (GST_TYPE_DISCOVERER_SUBTITLE_INFO, NULL);
2354       _parse_subtitle_stream_info (GST_DISCOVERER_SUBTITLE_INFO (sinfo),
2355           g_variant_get_child_value (specific, 0));
2356       break;
<span class="line-added">2357     case &#39;n&#39;:</span>
<span class="line-added">2358       sinfo = g_object_new (GST_TYPE_DISCOVERER_STREAM_INFO, NULL);</span>
<span class="line-added">2359       break;</span>
2360     default:
2361       GST_WARNING (&quot;Unexpected discoverer info type %d&quot;, type);
2362       goto out;
2363   }
2364 
<span class="line-modified">2365   _parse_common_stream_info (sinfo, g_variant_get_child_value (common, 0),</span>
<span class="line-added">2366       info);</span>
2367 
<span class="line-modified">2368   if (!GST_IS_DISCOVERER_CONTAINER_INFO (sinfo))</span>
<span class="line-added">2369     info-&gt;stream_list = g_list_append (info-&gt;stream_list, sinfo);</span>
2370 
2371   if (!info-&gt;stream_info) {
2372     info-&gt;stream_info = sinfo;
2373   }
2374 
2375   if (GST_IS_DISCOVERER_CONTAINER_INFO (sinfo)) {
2376     GVariantIter iter;
2377     GVariant *child;
2378 
2379     GstDiscovererContainerInfo *cinfo = GST_DISCOVERER_CONTAINER_INFO (sinfo);
2380     g_variant_iter_init (&amp;iter, specific);
2381     while ((child = g_variant_iter_next_value (&amp;iter))) {
2382       GstDiscovererStreamInfo *child_info;
2383       child_info = _parse_discovery (g_variant_get_variant (child), info);
2384       if (child_info != NULL) {
2385         cinfo-&gt;streams =
2386             g_list_append (cinfo-&gt;streams,
2387             gst_discoverer_stream_info_ref (child_info));
2388       }
2389       g_variant_unref (child);
</pre>
<hr />
<pre>
2416 
2417   GST_DEBUG_OBJECT (discoverer, &quot;Starting...&quot;);
2418 
2419   if (discoverer-&gt;priv-&gt;async) {
2420     GST_DEBUG_OBJECT (discoverer, &quot;We were already started&quot;);
2421     return;
2422   }
2423 
2424   discoverer-&gt;priv-&gt;async = TRUE;
2425   discoverer-&gt;priv-&gt;running = TRUE;
2426 
2427   ctx = g_main_context_get_thread_default ();
2428 
2429   /* Connect to bus signals */
2430   if (ctx == NULL)
2431     ctx = g_main_context_default ();
2432 
2433   source = gst_bus_create_watch (discoverer-&gt;priv-&gt;bus);
2434   g_source_set_callback (source, (GSourceFunc) gst_bus_async_signal_func,
2435       NULL, NULL);
<span class="line-modified">2436   g_source_attach (source, ctx);</span>
<span class="line-modified">2437   discoverer-&gt;priv-&gt;bus_source = source;</span>
2438   discoverer-&gt;priv-&gt;ctx = g_main_context_ref (ctx);
2439 
2440   start_discovering (discoverer);
2441   GST_DEBUG_OBJECT (discoverer, &quot;Started&quot;);
2442 }
2443 
2444 /**
2445  * gst_discoverer_stop:
2446  * @discoverer: A #GstDiscoverer
2447  *
2448  * Stop the discovery of any pending URIs and clears the list of
2449  * pending URIS (if any).
2450  */
2451 void
2452 gst_discoverer_stop (GstDiscoverer * discoverer)
2453 {
2454   g_return_if_fail (GST_IS_DISCOVERER (discoverer));
2455 
2456   GST_DEBUG_OBJECT (discoverer, &quot;Stopping...&quot;);
2457 
</pre>
<hr />
<pre>
2459     GST_DEBUG_OBJECT (discoverer,
2460         &quot;We were already stopped, or running synchronously&quot;);
2461     return;
2462   }
2463 
2464   DISCO_LOCK (discoverer);
2465   if (discoverer-&gt;priv-&gt;processing) {
2466     /* We prevent any further processing by setting the bus to
2467      * flushing and setting the pipeline to READY.
2468      * _reset() will take care of the rest of the cleanup */
2469     if (discoverer-&gt;priv-&gt;bus)
2470       gst_bus_set_flushing (discoverer-&gt;priv-&gt;bus, TRUE);
2471     if (discoverer-&gt;priv-&gt;pipeline)
2472       gst_element_set_state ((GstElement *) discoverer-&gt;priv-&gt;pipeline,
2473           GST_STATE_READY);
2474   }
2475   discoverer-&gt;priv-&gt;running = FALSE;
2476   DISCO_UNLOCK (discoverer);
2477 
2478   /* Remove timeout handler */
<span class="line-modified">2479   if (discoverer-&gt;priv-&gt;timeout_source) {</span>
<span class="line-modified">2480     g_source_destroy (discoverer-&gt;priv-&gt;timeout_source);</span>
<span class="line-modified">2481     g_source_unref (discoverer-&gt;priv-&gt;timeout_source);</span>
<span class="line-added">2482     discoverer-&gt;priv-&gt;timeout_source = NULL;</span>
2483   }
2484   /* Remove signal watch */
<span class="line-modified">2485   if (discoverer-&gt;priv-&gt;bus_source) {</span>
<span class="line-modified">2486     g_source_destroy (discoverer-&gt;priv-&gt;bus_source);</span>
<span class="line-modified">2487     g_source_unref (discoverer-&gt;priv-&gt;bus_source);</span>
<span class="line-added">2488     discoverer-&gt;priv-&gt;bus_source = NULL;</span>
2489   }
2490   /* Unref main context */
2491   if (discoverer-&gt;priv-&gt;ctx) {
2492     g_main_context_unref (discoverer-&gt;priv-&gt;ctx);
2493     discoverer-&gt;priv-&gt;ctx = NULL;
2494   }
2495   discoverer_reset (discoverer);
2496 
2497   discoverer-&gt;priv-&gt;async = FALSE;
2498 
2499   GST_DEBUG_OBJECT (discoverer, &quot;Stopped&quot;);
2500 }
2501 
2502 /**
2503  * gst_discoverer_discover_uri_async:
2504  * @discoverer: A #GstDiscoverer
2505  * @uri: the URI to add.
2506  *
2507  * Appends the given @uri to the list of URIs to discoverer. The actual
2508  * discovery of the @uri will only take place if gst_discoverer_start() has
</pre>
<hr />
<pre>
2634  * @info: A #GstDiscovererInfo
2635  * @flags: A combination of #GstDiscovererSerializeFlags to specify
2636  * what needs to be serialized.
2637  *
2638  * Serializes @info to a #GVariant that can be parsed again
2639  * through gst_discoverer_info_from_variant().
2640  *
2641  * Note that any #GstToc (s) that might have been discovered will not be serialized
2642  * for now.
2643  *
2644  * Returns: (transfer full): A newly-allocated #GVariant representing @info.
2645  *
2646  * Since: 1.6
2647  */
2648 GVariant *
2649 gst_discoverer_info_to_variant (GstDiscovererInfo * info,
2650     GstDiscovererSerializeFlags flags)
2651 {
2652   /* FIXME: implement TOC support */
2653   GVariant *stream_variant;
<span class="line-modified">2654   GVariant *variant, *info_variant;</span>
2655   GstDiscovererStreamInfo *sinfo;
2656   GVariant *wrapper;
2657 
2658   g_return_val_if_fail (GST_IS_DISCOVERER_INFO (info), NULL);
2659   g_return_val_if_fail (gst_discoverer_info_get_result (info) ==
2660       GST_DISCOVERER_OK, NULL);
2661 
2662   sinfo = gst_discoverer_info_get_stream_info (info);
2663   stream_variant = gst_discoverer_info_to_variant_recurse (sinfo, flags);
<span class="line-modified">2664   info_variant = _serialize_info (info, flags);</span>
<span class="line-modified">2665 </span>
<span class="line-added">2666   variant = g_variant_new (&quot;(vv)&quot;, info_variant, stream_variant);</span>
2667 
2668   /* Returning a wrapper implies some small overhead, but simplifies
2669    * deserializing from bytes */
2670   wrapper = g_variant_new_variant (variant);
2671 
2672   gst_discoverer_stream_info_unref (sinfo);
2673   return wrapper;
2674 }
2675 
2676 /**
2677  * gst_discoverer_info_from_variant:
2678  * @variant: A #GVariant to deserialize into a #GstDiscovererInfo.
2679  *
2680  * Parses a #GVariant as produced by gst_discoverer_info_to_variant()
2681  * back to a #GstDiscovererInfo.
2682  *
2683  * Returns: (transfer full): A newly-allocated #GstDiscovererInfo.
2684  *
2685  * Since: 1.6
2686  */
</pre>
</td>
</tr>
</table>
<center><a href="gstdiscoverer-types.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstdiscoverer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>