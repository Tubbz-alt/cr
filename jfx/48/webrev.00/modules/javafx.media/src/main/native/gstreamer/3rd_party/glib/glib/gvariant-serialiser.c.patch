diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-serialiser.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-serialiser.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-serialiser.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-serialiser.c
@@ -1,8 +1,8 @@
 /*
- * Copyright � 2007, 2008 Ryan Lortie
- * Copyright � 2010 Codethink Limited
+ * Copyright (C) 2007, 2008 Ryan Lortie
+ * Copyright (C) 2010 Codethink Limited
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or (at your option) any later version.
@@ -20,11 +20,10 @@
 
 /* Prologue {{{1 */
 #include "config.h"
 
 #include "gvariant-serialiser.h"
-#include "gunicodeprivate.h"
 
 #include <glib/gvariant-internal.h>
 #include <glib/gtestutils.h>
 #include <glib/gstrfuncs.h>
 #include <glib/gtypes.h>
@@ -126,24 +125,28 @@
  * g_variant_serialised_check:
  * @serialised: a #GVariantSerialised struct
  *
  * Checks @serialised for validity according to the invariants described
  * above.
+ *
+ * Returns: %TRUE if @serialised is valid; %FALSE otherwise
  */
-static void
+gboolean
 g_variant_serialised_check (GVariantSerialised serialised)
 {
   gsize fixed_size;
   guint alignment;
 
-  g_assert (serialised.type_info != NULL);
+  if (serialised.type_info == NULL)
+    return FALSE;
   g_variant_type_info_query (serialised.type_info, &alignment, &fixed_size);
 
-  if (fixed_size)
-    g_assert_cmpint (serialised.size, ==, fixed_size);
-  else
-    g_assert (serialised.size == 0 || serialised.data != NULL);
+  if (fixed_size != 0 && serialised.size != fixed_size)
+    return FALSE;
+  else if (fixed_size == 0 &&
+           !(serialised.size == 0 || serialised.data != NULL))
+    return FALSE;
 
   /* Depending on the native alignment requirements of the machine, the
    * compiler will insert either 3 or 7 padding bytes after the char.
    * This will result in the sizeof() the struct being 12 or 16.
    * Subtract 9 to get 3 or 7 which is a nice bitmask to apply to get
@@ -166,14 +169,12 @@
    * example, has been seen to return pointers aligned to 6 mod 16.
    *
    * Check if this is a small allocation and return without enforcing
    * the alignment assertion if this is the case.
    */
-  if (serialised.size <= alignment)
-    return;
-
-  g_assert_cmpint (alignment & (gsize) serialised.data, ==, 0);
+  return (serialised.size <= alignment ||
+          (alignment & (gsize) serialised.data) == 0);
 }
 
 /* < private >
  * GVariantSerialisedFiller:
  * @serialised: a #GVariantSerialised instance to fill
@@ -1354,11 +1355,11 @@
  * Returns: the number of children
  */
 gsize
 g_variant_serialised_n_children (GVariantSerialised serialised)
 {
-  g_variant_serialised_check (serialised);
+  g_assert (g_variant_serialised_check (serialised));
 
   DISPATCH_CASES (serialised.type_info,
 
                   return gvs_/**/,/**/_n_children (serialised);
 
@@ -1391,19 +1392,19 @@
 g_variant_serialised_get_child (GVariantSerialised serialised,
                                 gsize              index_)
 {
   GVariantSerialised child;
 
-  g_variant_serialised_check (serialised);
+  g_assert (g_variant_serialised_check (serialised));
 
   if G_LIKELY (index_ < g_variant_serialised_n_children (serialised))
     {
       DISPATCH_CASES (serialised.type_info,
 
                       child = gvs_/**/,/**/_get_child (serialised, index_);
                       g_assert (child.size || child.data == NULL);
-                      g_variant_serialised_check (child);
+                      g_assert (g_variant_serialised_check (child));
                       return child;
 
                      )
       g_assert_not_reached ();
     }
@@ -1440,11 +1441,11 @@
 g_variant_serialiser_serialise (GVariantSerialised        serialised,
                                 GVariantSerialisedFiller  gvs_filler,
                                 const gpointer           *children,
                                 gsize                     n_children)
 {
-  g_variant_serialised_check (serialised);
+  g_assert (g_variant_serialised_check (serialised));
 
   DISPATCH_CASES (serialised.type_info,
 
                   gvs_/**/,/**/_serialise (serialised, gvs_filler,
                                            children, n_children);
@@ -1495,11 +1496,11 @@
 g_variant_serialised_byteswap (GVariantSerialised serialised)
 {
   gsize fixed_size;
   guint alignment;
 
-  g_variant_serialised_check (serialised);
+  g_assert (g_variant_serialised_check (serialised));
 
   if (!serialised.data)
     return;
 
   /* the types we potentially need to byteswap are
@@ -1651,11 +1652,11 @@
   expected_end = ((gchar *) data) + size - 1;
 
   if (*expected_end != '\0')
     return FALSE;
 
-  _g_utf8_validate_len (data, size, &end);
+  g_utf8_validate_len (data, size, &end);
 
   return end == expected_end;
 }
 
 /* < private >
@@ -1717,12 +1718,12 @@
  *
  * Performs the checks for being a valid string.
  *
  * Also, ensures that @data is a valid D-Bus type signature, as per the
  * D-Bus specification. Note that this means the empty string is valid, as the
- * D-Bus specification defines a signature as “zero or more single complete
- * types”.
+ * D-Bus specification defines a signature as zero or more single complete
+ * types.
  */
 gboolean
 g_variant_serialiser_is_signature (gconstpointer data,
                                    gsize         size)
 {
