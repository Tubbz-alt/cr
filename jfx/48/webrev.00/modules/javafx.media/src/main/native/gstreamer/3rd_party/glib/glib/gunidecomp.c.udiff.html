<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunidecomp.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gunicollate.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gunidecomp.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunidecomp.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -105,43 +105,43 @@</span>
   * according to their combining classes.  See the Unicode
   * manual for more information.
   **/
  void
  g_unicode_canonical_ordering (gunichar *string,
<span class="udiff-line-modified-removed">-                   gsize     len)</span>
<span class="udiff-line-modified-added">+             gsize     len)</span>
  {
    gsize i;
    int swap = 1;
  
    while (swap)
      {
        int last;
        swap = 0;
        last = COMBINING_CLASS (string[0]);
        for (i = 0; i &lt; len - 1; ++i)
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     int next = COMBINING_CLASS (string[i + 1]);</span>
<span class="udiff-line-added">+     if (next != 0 &amp;&amp; last &gt; next)</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         gsize j;</span>
<span class="udiff-line-added">+         /* Percolate item leftward through string.  */</span>
<span class="udiff-line-added">+         for (j = i + 1; j &gt; 0; --j)</span>
      {
<span class="udiff-line-modified-removed">-       int next = COMBINING_CLASS (string[i + 1]);</span>
<span class="udiff-line-modified-removed">-       if (next != 0 &amp;&amp; last &gt; next)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           gsize j;</span>
<span class="udiff-line-modified-removed">-           /* Percolate item leftward through string.  */</span>
<span class="udiff-line-modified-removed">-           for (j = i + 1; j &gt; 0; --j)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-removed">-           gunichar t;</span>
<span class="udiff-line-removed">-           if (COMBINING_CLASS (string[j - 1]) &lt;= next)</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           t = string[j];</span>
<span class="udiff-line-removed">-           string[j] = string[j - 1];</span>
<span class="udiff-line-removed">-           string[j - 1] = t;</span>
<span class="udiff-line-removed">-           swap = 1;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-           /* We&#39;re re-entering the loop looking at the old</span>
<span class="udiff-line-removed">-          character again.  */</span>
<span class="udiff-line-removed">-           next = last;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       last = next;</span>
<span class="udiff-line-modified-added">+       gunichar t;</span>
<span class="udiff-line-modified-added">+       if (COMBINING_CLASS (string[j - 1]) &lt;= next)</span>
<span class="udiff-line-modified-added">+         break;</span>
<span class="udiff-line-modified-added">+       t = string[j];</span>
<span class="udiff-line-modified-added">+       string[j] = string[j - 1];</span>
<span class="udiff-line-modified-added">+       string[j - 1] = t;</span>
<span class="udiff-line-modified-added">+       swap = 1;</span>
      }
<span class="udiff-line-added">+         /* We&#39;re re-entering the loop looking at the old</span>
<span class="udiff-line-added">+      character again.  */</span>
<span class="udiff-line-added">+         next = last;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     last = next;</span>
<span class="udiff-line-added">+   }</span>
      }
  }
  
  /* http://www.unicode.org/unicode/reports/tr15/#Hangul
   * r should be null or have sufficient space. Calling with r == NULL will
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162,57 +162,57 @@</span>
      }
  
    if (TIndex)
      {
        if (r)
<span class="udiff-line-modified-removed">-     r[2] = TBase + TIndex;</span>
<span class="udiff-line-modified-added">+   r[2] = TBase + TIndex;</span>
        *result_len = 3;
      }
    else
      *result_len = 2;
  }
  
  /* returns a pointer to a null-terminated UTF-8 string */
  static const gchar *
  find_decomposition (gunichar ch,
<span class="udiff-line-modified-removed">-             gboolean compat)</span>
<span class="udiff-line-modified-added">+         gboolean compat)</span>
  {
    int start = 0;
    int end = G_N_ELEMENTS (decomp_table);
  
    if (ch &gt;= decomp_table[start].ch &amp;&amp;
        ch &lt;= decomp_table[end - 1].ch)
      {
        while (TRUE)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       int half = (start + end) / 2;</span>
<span class="udiff-line-modified-removed">-       if (ch == decomp_table[half].ch)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           int offset;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     int half = (start + end) / 2;</span>
<span class="udiff-line-modified-added">+     if (ch == decomp_table[half].ch)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         int offset;</span>
  
<span class="udiff-line-modified-removed">-           if (compat)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           offset = decomp_table[half].compat_offset;</span>
<span class="udiff-line-modified-removed">-           if (offset == G_UNICODE_NOT_PRESENT_OFFSET)</span>
<span class="udiff-line-modified-removed">-             offset = decomp_table[half].canon_offset;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-           else</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           offset = decomp_table[half].canon_offset;</span>
<span class="udiff-line-modified-removed">-           if (offset == G_UNICODE_NOT_PRESENT_OFFSET)</span>
<span class="udiff-line-modified-removed">-             return NULL;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           return &amp;(decomp_expansion_string[offset]);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       else if (half == start)</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       else if (ch &gt; decomp_table[half].ch)</span>
<span class="udiff-line-removed">-         start = half;</span>
<span class="udiff-line-removed">-       else</span>
<span class="udiff-line-removed">-         end = half;</span>
<span class="udiff-line-modified-added">+         if (compat)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       offset = decomp_table[half].compat_offset;</span>
<span class="udiff-line-modified-added">+       if (offset == G_UNICODE_NOT_PRESENT_OFFSET)</span>
<span class="udiff-line-modified-added">+         offset = decomp_table[half].canon_offset;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+         else</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       offset = decomp_table[half].canon_offset;</span>
<span class="udiff-line-modified-added">+       if (offset == G_UNICODE_NOT_PRESENT_OFFSET)</span>
<span class="udiff-line-modified-added">+         return NULL;</span>
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return &amp;(decomp_expansion_string[offset]);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     else if (half == start)</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     else if (ch &gt; decomp_table[half].ch)</span>
<span class="udiff-line-added">+       start = half;</span>
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+       end = half;</span>
<span class="udiff-line-added">+   }</span>
      }
  
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -229,11 +229,11 @@</span>
   * Deprecated: 2.30: Use the more flexible g_unichar_fully_decompose()
   *   instead.
   **/
  gunichar *
  g_unicode_canonical_decomposition (gunichar ch,
<span class="udiff-line-modified-removed">-                    gsize   *result_len)</span>
<span class="udiff-line-modified-added">+            gsize   *result_len)</span>
  {
    const gchar *decomp;
    const gchar *p;
    gunichar *r;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -306,12 +306,12 @@</span>
  #define COMPOSE_INDEX(Char) \
       (((Char &gt;&gt; 8) &gt; (COMPOSE_TABLE_LAST)) ? 0 : CI((Char) &gt;&gt; 8, (Char) &amp; 0xff))
  
  static gboolean
  combine (gunichar  a,
<span class="udiff-line-modified-removed">-      gunichar  b,</span>
<span class="udiff-line-modified-removed">-      gunichar *result)</span>
<span class="udiff-line-modified-added">+    gunichar  b,</span>
<span class="udiff-line-modified-added">+    gunichar *result)</span>
  {
    gushort index_a, index_b;
  
    if (combine_hangul (a, b, result))
      return TRUE;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -319,59 +319,59 @@</span>
    index_a = COMPOSE_INDEX(a);
  
    if (index_a &gt;= COMPOSE_FIRST_SINGLE_START &amp;&amp; index_a &lt; COMPOSE_SECOND_START)
      {
        if (b == compose_first_single[index_a - COMPOSE_FIRST_SINGLE_START][0])
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       *result = compose_first_single[index_a - COMPOSE_FIRST_SINGLE_START][1];</span>
<span class="udiff-line-modified-removed">-       return TRUE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     *result = compose_first_single[index_a - COMPOSE_FIRST_SINGLE_START][1];</span>
<span class="udiff-line-modified-added">+     return TRUE;</span>
<span class="udiff-line-modified-added">+   }</span>
        else
          return FALSE;
      }
  
    index_b = COMPOSE_INDEX(b);
  
    if (index_b &gt;= COMPOSE_SECOND_SINGLE_START)
      {
        if (a == compose_second_single[index_b - COMPOSE_SECOND_SINGLE_START][0])
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       *result = compose_second_single[index_b - COMPOSE_SECOND_SINGLE_START][1];</span>
<span class="udiff-line-modified-removed">-       return TRUE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     *result = compose_second_single[index_b - COMPOSE_SECOND_SINGLE_START][1];</span>
<span class="udiff-line-modified-added">+     return TRUE;</span>
<span class="udiff-line-modified-added">+   }</span>
        else
          return FALSE;
      }
  
    if (index_a &gt;= COMPOSE_FIRST_START &amp;&amp; index_a &lt; COMPOSE_FIRST_SINGLE_START &amp;&amp;
        index_b &gt;= COMPOSE_SECOND_START &amp;&amp; index_b &lt; COMPOSE_SECOND_SINGLE_START)
      {
        gunichar res = compose_array[index_a - COMPOSE_FIRST_START][index_b - COMPOSE_SECOND_START];
  
        if (res)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       *result = res;</span>
<span class="udiff-line-modified-removed">-       return TRUE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     *result = res;</span>
<span class="udiff-line-modified-added">+     return TRUE;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    return FALSE;
  }
  
  gunichar *
  _g_utf8_normalize_wc (const gchar    *str,
<span class="udiff-line-modified-removed">-               gssize          max_len,</span>
<span class="udiff-line-modified-removed">-               GNormalizeMode  mode)</span>
<span class="udiff-line-modified-added">+           gssize          max_len,</span>
<span class="udiff-line-modified-added">+           GNormalizeMode  mode)</span>
  {
    gsize n_wc;
    gunichar *wc_buffer;
    const char *p;
    gsize last_start;
    gboolean do_compat = (mode == G_NORMALIZE_NFKC ||
<span class="udiff-line-modified-removed">-             mode == G_NORMALIZE_NFKD);</span>
<span class="udiff-line-modified-added">+       mode == G_NORMALIZE_NFKD);</span>
    gboolean do_compose = (mode == G_NORMALIZE_NFC ||
<span class="udiff-line-modified-removed">-              mode == G_NORMALIZE_NFKC);</span>
<span class="udiff-line-modified-added">+        mode == G_NORMALIZE_NFKC);</span>
  
    n_wc = 0;
    p = str;
    while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -428,19 +428,19 @@</span>
            else
              wc_buffer[n_wc++] = wc;
          }
  
        if (n_wc &gt; 0)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       cc = COMBINING_CLASS (wc_buffer[old_n_wc]);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     cc = COMBINING_CLASS (wc_buffer[old_n_wc]);</span>
  
<span class="udiff-line-modified-removed">-       if (cc == 0)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           g_unicode_canonical_ordering (wc_buffer + last_start, n_wc - last_start);</span>
<span class="udiff-line-modified-removed">-           last_start = old_n_wc;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (cc == 0)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         g_unicode_canonical_ordering (wc_buffer + last_start, n_wc - last_start);</span>
<span class="udiff-line-modified-added">+         last_start = old_n_wc;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+   }</span>
  
        p = g_utf8_next_char (p);
      }
  
    if (n_wc &gt; 0)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -458,36 +458,36 @@</span>
        gsize i, j;
        int last_cc = 0;
        last_start = 0;
  
        for (i = 0; i &lt; n_wc; i++)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       int cc = COMBINING_CLASS (wc_buffer[i]);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       if (i &gt; 0 &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           (last_cc == 0 || last_cc &lt; cc) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           combine (wc_buffer[last_start], wc_buffer[i],</span>
<span class="udiff-line-modified-removed">-                &amp;wc_buffer[last_start]))</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           for (j = i + 1; j &lt; n_wc; j++)</span>
<span class="udiff-line-modified-removed">-         wc_buffer[j-1] = wc_buffer[j];</span>
<span class="udiff-line-modified-removed">-           n_wc--;</span>
<span class="udiff-line-modified-removed">-           i--;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-           if (i == last_start)</span>
<span class="udiff-line-modified-removed">-         last_cc = 0;</span>
<span class="udiff-line-modified-removed">-           else</span>
<span class="udiff-line-modified-removed">-         last_cc = COMBINING_CLASS (wc_buffer[i-1]);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-           continue;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       if (cc == 0)</span>
<span class="udiff-line-modified-removed">-         last_start = i;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       last_cc = cc;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     int cc = COMBINING_CLASS (wc_buffer[i]);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (i &gt; 0 &amp;&amp;</span>
<span class="udiff-line-modified-added">+         (last_cc == 0 || last_cc &lt; cc) &amp;&amp;</span>
<span class="udiff-line-modified-added">+         combine (wc_buffer[last_start], wc_buffer[i],</span>
<span class="udiff-line-modified-added">+            &amp;wc_buffer[last_start]))</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         for (j = i + 1; j &lt; n_wc; j++)</span>
<span class="udiff-line-modified-added">+     wc_buffer[j-1] = wc_buffer[j];</span>
<span class="udiff-line-modified-added">+         n_wc--;</span>
<span class="udiff-line-modified-added">+         i--;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         if (i == last_start)</span>
<span class="udiff-line-modified-added">+     last_cc = 0;</span>
<span class="udiff-line-modified-added">+         else</span>
<span class="udiff-line-modified-added">+     last_cc = COMBINING_CLASS (wc_buffer[i-1]);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         continue;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (cc == 0)</span>
<span class="udiff-line-modified-added">+       last_start = i;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     last_cc = cc;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    wc_buffer[n_wc] = 0;
  
    return wc_buffer;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -523,18 +523,18 @@</span>
   * than a maximally decomposed form. This is often
   * useful if you intend to convert the string to
   * a legacy encoding or pass it to a system with
   * less capable Unicode handling.
   *
<span class="udiff-line-modified-removed">-  * Returns: a newly allocated string, that is the</span>
<span class="udiff-line-modified-removed">-  *   normalized form of @str, or %NULL if @str is not</span>
<span class="udiff-line-modified-removed">-  *   valid UTF-8.</span>
<span class="udiff-line-modified-added">+  * Returns: (nullable): a newly allocated string, that</span>
<span class="udiff-line-modified-added">+  *   is the normalized form of @str, or %NULL if @str</span>
<span class="udiff-line-modified-added">+  *   is not valid UTF-8.</span>
   **/
  gchar *
  g_utf8_normalize (const gchar    *str,
<span class="udiff-line-modified-removed">-           gssize          len,</span>
<span class="udiff-line-modified-removed">-           GNormalizeMode  mode)</span>
<span class="udiff-line-modified-added">+       gssize          len,</span>
<span class="udiff-line-modified-added">+       GNormalizeMode  mode)</span>
  {
    gunichar *result_wc = _g_utf8_normalize_wc (str, len, mode);
    gchar *result;
  
    result = g_ucs4_to_utf8 (result_wc, -1, NULL, NULL, NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -573,12 +573,12 @@</span>
  }
  
  /**
   * g_unichar_decompose:
   * @ch: a Unicode character
<span class="udiff-line-modified-removed">-  * @a: return location for the first component of @ch</span>
<span class="udiff-line-modified-removed">-  * @b: return location for the second component of @ch</span>
<span class="udiff-line-modified-added">+  * @a: (out) (not optional): return location for the first component of @ch</span>
<span class="udiff-line-modified-added">+  * @b: (out) (not optional): return location for the second component of @ch</span>
   *
   * Performs a single decomposition step of the
   * Unicode canonical decomposition algorithm.
   *
   * This function does not include compatibility
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -648,11 +648,11 @@</span>
  
  /**
   * g_unichar_compose:
   * @a: a Unicode character
   * @b: a Unicode character
<span class="udiff-line-modified-removed">-  * @ch: return location for the composed character</span>
<span class="udiff-line-modified-added">+  * @ch: (out) (not optional): return location for the composed character</span>
   *
   * Performs a single composition step of the
   * Unicode canonical composition algorithm.
   *
   * This function includes algorithmic Hangul Jamo composition,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -687,11 +687,11 @@</span>
  
  /**
   * g_unichar_fully_decompose:
   * @ch: a Unicode character.
   * @compat: whether perform canonical or compatibility decomposition
<span class="udiff-line-modified-removed">-  * @result: (nullable): location to store decomposed result, or %NULL</span>
<span class="udiff-line-modified-added">+  * @result: (optional) (out caller-allocates): location to store decomposed result, or %NULL</span>
   * @result_len: length of @result
   *
   * Computes the canonical or compatibility decomposition of a
   * Unicode character.  For compatibility decomposition,
   * pass %TRUE for @compat; for canonical decomposition
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -716,13 +716,13 @@</span>
   *
   * Since: 2.30
   **/
  gsize
  g_unichar_fully_decompose (gunichar  ch,
<span class="udiff-line-modified-removed">-                gboolean  compat,</span>
<span class="udiff-line-modified-removed">-                gunichar *result,</span>
<span class="udiff-line-modified-removed">-                gsize     result_len)</span>
<span class="udiff-line-modified-added">+          gboolean  compat,</span>
<span class="udiff-line-modified-added">+          gunichar *result,</span>
<span class="udiff-line-modified-added">+          gsize     result_len)</span>
  {
    const gchar *decomp;
    const gchar *p;
  
    /* Hangul syllable */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -731,11 +731,11 @@</span>
        gsize len, i;
        gunichar buffer[3];
        decompose_hangul (ch, result ? buffer : NULL, &amp;len);
        if (result)
          for (i = 0; i &lt; len &amp;&amp; i &lt; result_len; i++)
<span class="udiff-line-modified-removed">-       result[i] = buffer[i];</span>
<span class="udiff-line-modified-added">+     result[i] = buffer[i];</span>
        return len;
      }
    else if ((decomp = find_decomposition (ch, compat)) != NULL)
      {
        /* Found it.  */
</pre>
<center><a href="gunicollate.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gunidecomp.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>