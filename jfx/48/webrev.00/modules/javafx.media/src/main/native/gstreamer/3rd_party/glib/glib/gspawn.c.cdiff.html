<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gspawn-win32.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 450,12 ***</span>
  
        if (ret &lt; 0)
          {
            int errsv = errno;
  
<span class="line-modified">!       if (errno == EINTR)</span>
<span class="line-modified">!         continue;</span>
  
            failed = TRUE;
  
            g_set_error (error,
                         G_SPAWN_ERROR,
<span class="line-new-header">--- 450,12 ---</span>
  
        if (ret &lt; 0)
          {
            int errsv = errno;
  
<span class="line-modified">!     if (errno == EINTR)</span>
<span class="line-modified">!       continue;</span>
  
            failed = TRUE;
  
            g_set_error (error,
                         G_SPAWN_ERROR,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 631,11 ***</span>
   * library&#39;s spawn*() family of functions (which g_spawn_async_with_pipes()
   * eventually calls) paste the argument vector elements together into
   * a command line, and the C runtime startup code does a corresponding
   * reconstruction of an argument vector from the command line, to be
   * passed to main(). Complications arise when you have argument vector
<span class="line-modified">!  * elements that contain spaces of double quotes. The spawn*() functions</span>
   * don&#39;t do any quoting or escaping, but on the other hand the startup
   * code does do unquoting and unescaping in order to enable receiving
   * arguments with embedded spaces or double quotes. To work around this
   * asymmetry, g_spawn_async_with_pipes() will do quoting and escaping on
   * argument vector elements that need it before calling the C runtime
<span class="line-new-header">--- 631,11 ---</span>
   * library&#39;s spawn*() family of functions (which g_spawn_async_with_pipes()
   * eventually calls) paste the argument vector elements together into
   * a command line, and the C runtime startup code does a corresponding
   * reconstruction of an argument vector from the command line, to be
   * passed to main(). Complications arise when you have argument vector
<span class="line-modified">!  * elements that contain spaces or double quotes. The `spawn*()` functions</span>
   * don&#39;t do any quoting or escaping, but on the other hand the startup
   * code does do unquoting and unescaping in order to enable receiving
   * arguments with embedded spaces or double quotes. To work around this
   * asymmetry, g_spawn_async_with_pipes() will do quoting and escaping on
   * argument vector elements that need it before calling the C runtime
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1042,42 ***</span>
   *
   * Since: 2.34
   */
  gboolean
  g_spawn_check_exit_status (gint      exit_status,
<span class="line-modified">!                GError  **error)</span>
  {
    gboolean ret = FALSE;
  
    if (WIFEXITED (exit_status))
      {
        if (WEXITSTATUS (exit_status) != 0)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_set_error (error, G_SPAWN_EXIT_ERROR, WEXITSTATUS (exit_status),</span>
<span class="line-modified">!                _(&quot;Child process exited with code %ld&quot;),</span>
<span class="line-modified">!                (long) WEXITSTATUS (exit_status));</span>
<span class="line-modified">!       goto out;</span>
<span class="line-modified">!     }</span>
      }
    else if (WIFSIGNALED (exit_status))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!            _(&quot;Child process killed by signal %ld&quot;),</span>
<span class="line-modified">!            (long) WTERMSIG (exit_status));</span>
        goto out;
      }
    else if (WIFSTOPPED (exit_status))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!            _(&quot;Child process stopped by signal %ld&quot;),</span>
<span class="line-modified">!            (long) WSTOPSIG (exit_status));</span>
        goto out;
      }
    else
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!            _(&quot;Child process exited abnormally&quot;));</span>
        goto out;
      }
  
    ret = TRUE;
   out:
<span class="line-new-header">--- 1042,42 ---</span>
   *
   * Since: 2.34
   */
  gboolean
  g_spawn_check_exit_status (gint      exit_status,
<span class="line-modified">!          GError  **error)</span>
  {
    gboolean ret = FALSE;
  
    if (WIFEXITED (exit_status))
      {
        if (WEXITSTATUS (exit_status) != 0)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_set_error (error, G_SPAWN_EXIT_ERROR, WEXITSTATUS (exit_status),</span>
<span class="line-modified">!            _(&quot;Child process exited with code %ld&quot;),</span>
<span class="line-modified">!            (long) WEXITSTATUS (exit_status));</span>
<span class="line-modified">!     goto out;</span>
<span class="line-modified">!   }</span>
      }
    else if (WIFSIGNALED (exit_status))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!        _(&quot;Child process killed by signal %ld&quot;),</span>
<span class="line-modified">!        (long) WTERMSIG (exit_status));</span>
        goto out;
      }
    else if (WIFSTOPPED (exit_status))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!        _(&quot;Child process stopped by signal %ld&quot;),</span>
<span class="line-modified">!        (long) WSTOPSIG (exit_status));</span>
        goto out;
      }
    else
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!        _(&quot;Child process exited abnormally&quot;));</span>
        goto out;
      }
  
    ret = TRUE;
   out:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1193,20 ***</span>
              {
                de = (struct linux_dirent64 *)(buf + pos);
  
                fd = filename_to_fd (de-&gt;d_name);
                if (fd &lt; 0 || fd == dir_fd)
<span class="line-modified">!               continue;</span>
  
<span class="line-modified">!           if ((res = cb (data, fd)) != 0)</span>
<span class="line-modified">!               break;</span>
<span class="line-modified">!         }</span>
          }
  
        close (dir_fd);
        return res;
<span class="line-modified">!   }</span>
  
    /* If /proc is not mounted or not accessible we fall back to the old
     * rlimit trick */
  
  #endif
<span class="line-new-header">--- 1193,20 ---</span>
              {
                de = (struct linux_dirent64 *)(buf + pos);
  
                fd = filename_to_fd (de-&gt;d_name);
                if (fd &lt; 0 || fd == dir_fd)
<span class="line-modified">!                   continue;</span>
  
<span class="line-modified">!               if ((res = cb (data, fd)) != 0)</span>
<span class="line-modified">!                   break;</span>
<span class="line-modified">!             }</span>
          }
  
        close (dir_fd);
        return res;
<span class="line-modified">!     }</span>
  
    /* If /proc is not mounted or not accessible we fall back to the old
     * rlimit trick */
  
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1408,11 ***</span>
            return FALSE;
          }
        else if (chunk == 0)
          break; /* EOF */
        else /* chunk &gt; 0 */
<span class="line-modified">!     bytes += chunk;</span>
      }
  
    *n_ints_read = (gint)(bytes / sizeof(gint));
  
    return TRUE;
<span class="line-new-header">--- 1408,11 ---</span>
            return FALSE;
          }
        else if (chunk == 0)
          break; /* EOF */
        else /* chunk &gt; 0 */
<span class="line-modified">!   bytes += chunk;</span>
      }
  
    *n_ints_read = (gint)(bytes / sizeof(gint));
  
    return TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1597,29 ***</span>
  }
  #endif /* POSIX_SPAWN_AVAILABLE */
  
  static gboolean
  fork_exec_with_fds (gboolean              intermediate_child,
<span class="line-modified">!                       const gchar          *working_directory,</span>
<span class="line-modified">!                       gchar               **argv,</span>
<span class="line-modified">!                       gchar               **envp,</span>
<span class="line-modified">!                       gboolean              close_descriptors,</span>
<span class="line-modified">!                       gboolean              search_path,</span>
<span class="line-modified">!                       gboolean              search_path_from_envp,</span>
<span class="line-modified">!                       gboolean              stdout_to_null,</span>
<span class="line-modified">!                       gboolean              stderr_to_null,</span>
<span class="line-modified">!                       gboolean              child_inherits_stdin,</span>
<span class="line-modified">!                       gboolean              file_and_argv_zero,</span>
<span class="line-modified">!                       gboolean              cloexec_pipes,</span>
<span class="line-modified">!                       GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!                       gpointer              user_data,</span>
<span class="line-modified">!                       GPid                 *child_pid,</span>
<span class="line-modified">!                       gint                 *child_close_fds,</span>
<span class="line-modified">!                       gint                  stdin_fd,</span>
<span class="line-modified">!                       gint                  stdout_fd,</span>
<span class="line-modified">!                       gint                  stderr_fd,</span>
<span class="line-modified">!                       GError              **error)</span>
  {
    GPid pid = -1;
    gint child_err_report_pipe[2] = { -1, -1 };
    gint child_pid_report_pipe[2] = { -1, -1 };
    guint pipe_flags = cloexec_pipes ? FD_CLOEXEC : 0;
<span class="line-new-header">--- 1597,29 ---</span>
  }
  #endif /* POSIX_SPAWN_AVAILABLE */
  
  static gboolean
  fork_exec_with_fds (gboolean              intermediate_child,
<span class="line-modified">!                     const gchar          *working_directory,</span>
<span class="line-modified">!                     gchar               **argv,</span>
<span class="line-modified">!                     gchar               **envp,</span>
<span class="line-modified">!                     gboolean              close_descriptors,</span>
<span class="line-modified">!                     gboolean              search_path,</span>
<span class="line-modified">!                     gboolean              search_path_from_envp,</span>
<span class="line-modified">!                     gboolean              stdout_to_null,</span>
<span class="line-modified">!                     gboolean              stderr_to_null,</span>
<span class="line-modified">!                     gboolean              child_inherits_stdin,</span>
<span class="line-modified">!                     gboolean              file_and_argv_zero,</span>
<span class="line-modified">!                     gboolean              cloexec_pipes,</span>
<span class="line-modified">!                     GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!                     gpointer              user_data,</span>
<span class="line-modified">!                     GPid                 *child_pid,</span>
<span class="line-modified">!                     gint                 *child_close_fds,</span>
<span class="line-modified">!                     gint                  stdin_fd,</span>
<span class="line-modified">!                     gint                  stdout_fd,</span>
<span class="line-modified">!                     gint                  stderr_fd,</span>
<span class="line-modified">!                     GError              **error)</span>
  {
    GPid pid = -1;
    gint child_err_report_pipe[2] = { -1, -1 };
    gint child_pid_report_pipe[2] = { -1, -1 };
    guint pipe_flags = cloexec_pipes ? FD_CLOEXEC : 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1648,11 ***</span>
        if (status != ENOEXEC)
          {
            g_set_error (error,
                         G_SPAWN_ERROR,
                         G_SPAWN_ERROR_FAILED,
<span class="line-modified">!                        _(&quot;Failed to spawn child process “%s” (%s)&quot;),</span>
                         argv[0],
                         g_strerror (status));
            return FALSE;
         }
  
<span class="line-new-header">--- 1648,11 ---</span>
        if (status != ENOEXEC)
          {
            g_set_error (error,
                         G_SPAWN_ERROR,
                         G_SPAWN_ERROR_FAILED,
<span class="line-modified">!                        _(&quot;Failed to spawn child process &#39;%s&#39; (%s)&quot;),</span>
                         argv[0],
                         g_strerror (status));
            return FALSE;
         }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1816,11 ***</span>
                  goto wait_again;
                else if (errno == ECHILD)
                  ; /* do nothing, child already reaped */
                else
                  g_warning (&quot;waitpid() should not fail in &quot;
<span class="line-modified">!                &quot;&#39;fork_exec_with_pipes&#39;&quot;);</span>
              }
          }
  
  
        if (!read_ints (child_err_report_pipe[0],
<span class="line-new-header">--- 1816,11 ---</span>
                  goto wait_again;
                else if (errno == ECHILD)
                  ; /* do nothing, child already reaped */
                else
                  g_warning (&quot;waitpid() should not fail in &quot;
<span class="line-modified">!          &quot;&#39;fork_exec_with_pipes&#39;&quot;);</span>
              }
          }
  
  
        if (!read_ints (child_err_report_pipe[0],
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1846,11 ***</span>
  
              case CHILD_EXEC_FAILED:
                g_set_error (error,
                             G_SPAWN_ERROR,
                             _g_spawn_exec_err_to_g_error (buf[1]),
<span class="line-modified">!                            _(&quot;Failed to execute child process \&quot;%s\&quot; (%s)&quot;),</span>
                             argv[0],
                             g_strerror (buf[1]));
  
                break;
  
<span class="line-new-header">--- 1846,11 ---</span>
  
              case CHILD_EXEC_FAILED:
                g_set_error (error,
                             G_SPAWN_ERROR,
                             _g_spawn_exec_err_to_g_error (buf[1]),
<span class="line-modified">!                            _(&quot;Failed to execute child process &#39;%s&#39; (%s)&quot;),</span>
                             argv[0],
                             g_strerror (buf[1]));
  
                break;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1873,11 ***</span>
  
              default:
                g_set_error (error,
                             G_SPAWN_ERROR,
                             G_SPAWN_ERROR_FAILED,
<span class="line-modified">!                            _(&quot;Unknown error executing child process \&quot;%s\&quot;&quot;),</span>
                             argv[0]);
                break;
              }
  
            goto cleanup_and_fail;
<span class="line-new-header">--- 1873,11 ---</span>
  
              default:
                g_set_error (error,
                             G_SPAWN_ERROR,
                             G_SPAWN_ERROR_FAILED,
<span class="line-modified">!                            _(&quot;Unknown error executing child process &#39;%s&#39;&quot;),</span>
                             argv[0]);
                break;
              }
  
            goto cleanup_and_fail;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2061,12 ***</span>
  
      new_argv[0] = (char *) &quot;/bin/sh&quot;;
      new_argv[1] = (char *) file;
      while (argc &gt; 0)
        {
<span class="line-modified">!     new_argv[argc + 1] = argv[argc];</span>
<span class="line-modified">!     --argc;</span>
        }
  
      /* Execute the shell. */
      if (envp)
        execve (new_argv[0], new_argv, envp);
<span class="line-new-header">--- 2061,12 ---</span>
  
      new_argv[0] = (char *) &quot;/bin/sh&quot;;
      new_argv[1] = (char *) file;
      while (argc &gt; 0)
        {
<span class="line-modified">!   new_argv[argc + 1] = argv[argc];</span>
<span class="line-modified">!   --argc;</span>
        }
  
      /* Execute the shell. */
      if (envp)
        execve (new_argv[0], new_argv, envp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2108,11 ***</span>
          execve (file, argv, envp);
        else
          execv (file, argv);
  
        if (errno == ENOEXEC)
<span class="line-modified">!     script_execute (file, argv, envp);</span>
      }
    else
      {
        gboolean got_eacces = 0;
        const gchar *path, *p;
<span class="line-new-header">--- 2108,11 ---</span>
          execve (file, argv, envp);
        else
          execv (file, argv);
  
        if (errno == ENOEXEC)
<span class="line-modified">!   script_execute (file, argv, envp);</span>
      }
    else
      {
        gboolean got_eacces = 0;
        const gchar *path, *p;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2125,23 ***</span>
          path = g_environ_getenv (envp, &quot;PATH&quot;);
        if (search_path &amp;&amp; path == NULL)
          path = g_getenv (&quot;PATH&quot;);
  
        if (path == NULL)
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* There is no &#39;PATH&#39; in the environment.  The default</span>
<span class="line-modified">!        * search path in libc is the current directory followed by</span>
<span class="line-modified">!        * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.</span>
             */
  
            /* In GLib we put . last, for security, and don&#39;t use the
             * unportable confstr(); UNIX98 does not actually specify
             * what to search if PATH is unset. POSIX may, dunno.
             */
  
            path = &quot;/bin:/usr/bin:.&quot;;
<span class="line-modified">!     }</span>
  
        len = strlen (file) + 1;
        pathlen = strlen (path);
        freeme = name = g_malloc (pathlen + len + 1);
  
<span class="line-new-header">--- 2125,23 ---</span>
          path = g_environ_getenv (envp, &quot;PATH&quot;);
        if (search_path &amp;&amp; path == NULL)
          path = g_getenv (&quot;PATH&quot;);
  
        if (path == NULL)
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* There is no &#39;PATH&#39; in the environment.  The default</span>
<span class="line-modified">!      * search path in libc is the current directory followed by</span>
<span class="line-modified">!      * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.</span>
             */
  
            /* In GLib we put . last, for security, and don&#39;t use the
             * unportable confstr(); UNIX98 does not actually specify
             * what to search if PATH is unset. POSIX may, dunno.
             */
  
            path = &quot;/bin:/usr/bin:.&quot;;
<span class="line-modified">!   }</span>
  
        len = strlen (file) + 1;
        pathlen = strlen (path);
        freeme = name = g_malloc (pathlen + len + 1);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2151,79 ***</span>
        /* And add the slash before the filename  */
        *name = &#39;/&#39;;
  
        p = path;
        do
<span class="line-modified">!     {</span>
<span class="line-modified">!       char *startp;</span>
  
<span class="line-modified">!       path = p;</span>
<span class="line-modified">!       p = my_strchrnul (path, &#39;:&#39;);</span>
  
<span class="line-modified">!       if (p == path)</span>
<span class="line-modified">!         /* Two adjacent colons, or a colon at the beginning or the end</span>
               * of &#39;PATH&#39; means to search the current directory.
               */
<span class="line-modified">!         startp = name + 1;</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         startp = memcpy (name - (p - path), path, p - path);</span>
  
<span class="line-modified">!       /* Try to execute this name.  If it works, execv will not return.  */</span>
            if (envp)
              execve (startp, argv, envp);
            else
              execv (startp, argv);
  
<span class="line-modified">!       if (errno == ENOEXEC)</span>
<span class="line-modified">!         script_execute (startp, argv, envp);</span>
  
<span class="line-modified">!       switch (errno)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!         case EACCES:</span>
<span class="line-modified">!           /* Record the we got a &#39;Permission denied&#39; error.  If we end</span>
                 * up finding no executable we can use, we want to diagnose
                 * that we did find one but were denied access.
                 */
<span class="line-modified">!           got_eacces = TRUE;</span>
  
                /* FALL THRU */
  
<span class="line-modified">!         case ENOENT:</span>
  #ifdef ESTALE
<span class="line-modified">!         case ESTALE:</span>
  #endif
  #ifdef ENOTDIR
<span class="line-modified">!         case ENOTDIR:</span>
  #endif
<span class="line-modified">!           /* Those errors indicate the file is missing or not executable</span>
                 * by us, in which case we want to just try the next path
                 * directory.
                 */
<span class="line-modified">!           break;</span>
  
<span class="line-modified">!         case ENODEV:</span>
<span class="line-modified">!         case ETIMEDOUT:</span>
<span class="line-modified">!           /* Some strange filesystems like AFS return even</span>
<span class="line-modified">!            * stranger error numbers.  They cannot reasonably mean anything</span>
<span class="line-modified">!            * else so ignore those, too.</span>
<span class="line-modified">!            */</span>
<span class="line-modified">!           break;</span>
  
<span class="line-modified">!         default:</span>
<span class="line-modified">!           /* Some other error means we found an executable file, but</span>
                 * something went wrong executing it; return the error to our
                 * caller.
                 */
                g_free (freeme);
<span class="line-modified">!           return -1;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
        while (*p++ != &#39;\0&#39;);
  
        /* We tried every element and none of them worked.  */
        if (got_eacces)
<span class="line-modified">!     /* At least one failure was due to permissions, so report that</span>
           * error.
           */
          errno = EACCES;
  
        g_free (freeme);
<span class="line-new-header">--- 2151,79 ---</span>
        /* And add the slash before the filename  */
        *name = &#39;/&#39;;
  
        p = path;
        do
<span class="line-modified">!   {</span>
<span class="line-modified">!     char *startp;</span>
  
<span class="line-modified">!     path = p;</span>
<span class="line-modified">!     p = my_strchrnul (path, &#39;:&#39;);</span>
  
<span class="line-modified">!     if (p == path)</span>
<span class="line-modified">!       /* Two adjacent colons, or a colon at the beginning or the end</span>
               * of &#39;PATH&#39; means to search the current directory.
               */
<span class="line-modified">!       startp = name + 1;</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       startp = memcpy (name - (p - path), path, p - path);</span>
  
<span class="line-modified">!     /* Try to execute this name.  If it works, execv will not return.  */</span>
            if (envp)
              execve (startp, argv, envp);
            else
              execv (startp, argv);
  
<span class="line-modified">!     if (errno == ENOEXEC)</span>
<span class="line-modified">!       script_execute (startp, argv, envp);</span>
  
<span class="line-modified">!     switch (errno)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!       case EACCES:</span>
<span class="line-modified">!         /* Record the we got a &#39;Permission denied&#39; error.  If we end</span>
                 * up finding no executable we can use, we want to diagnose
                 * that we did find one but were denied access.
                 */
<span class="line-modified">!         got_eacces = TRUE;</span>
  
                /* FALL THRU */
  
<span class="line-modified">!       case ENOENT:</span>
  #ifdef ESTALE
<span class="line-modified">!       case ESTALE:</span>
  #endif
  #ifdef ENOTDIR
<span class="line-modified">!       case ENOTDIR:</span>
  #endif
<span class="line-modified">!         /* Those errors indicate the file is missing or not executable</span>
                 * by us, in which case we want to just try the next path
                 * directory.
                 */
<span class="line-modified">!         break;</span>
  
<span class="line-modified">!       case ENODEV:</span>
<span class="line-modified">!       case ETIMEDOUT:</span>
<span class="line-modified">!         /* Some strange filesystems like AFS return even</span>
<span class="line-modified">!          * stranger error numbers.  They cannot reasonably mean anything</span>
<span class="line-modified">!          * else so ignore those, too.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         break;</span>
  
<span class="line-modified">!       default:</span>
<span class="line-modified">!         /* Some other error means we found an executable file, but</span>
                 * something went wrong executing it; return the error to our
                 * caller.
                 */
                g_free (freeme);
<span class="line-modified">!         return -1;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
        while (*p++ != &#39;\0&#39;);
  
        /* We tried every element and none of them worked.  */
        if (got_eacces)
<span class="line-modified">!   /* At least one failure was due to permissions, so report that</span>
           * error.
           */
          errno = EACCES;
  
        g_free (freeme);
</pre>
<center><a href="gspawn-win32.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>