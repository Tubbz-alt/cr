<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  * Copyright (C) 2000-2001 Red Hat, Inc.
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General
  15  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  *
  17  * this code is based on the original GtkSignal implementation
  18  * for the Gtk+ library by Peter Mattis &lt;petm@xcf.berkeley.edu&gt;
  19  */
  20 
  21 /*
  22  * MT safe
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 
  27 #include &lt;string.h&gt;
  28 #include &lt;signal.h&gt;
  29 
  30 #include &quot;gsignal.h&quot;
  31 #include &quot;gtype-private.h&quot;
  32 #include &quot;gbsearcharray.h&quot;
  33 #include &quot;gvaluecollector.h&quot;
  34 #include &quot;gvaluetypes.h&quot;
  35 #include &quot;gobject.h&quot;
  36 #include &quot;genums.h&quot;
  37 #include &quot;gobject_trace.h&quot;
  38 
  39 
  40 /**
  41  * SECTION:signals
  42  * @short_description: A means for customization of object behaviour
  43  *     and a general purpose notification mechanism
  44  * @title: Signals
  45  *
  46  * The basic concept of the signal system is that of the emission
  47  * of a signal. Signals are introduced per-type and are identified
  48  * through strings. Signals introduced for a parent type are available
  49  * in derived types as well, so basically they are a per-type facility
  50  * that is inherited.
  51  *
  52  * A signal emission mainly involves invocation of a certain set of
  53  * callbacks in precisely defined manner. There are two main categories
  54  * of such callbacks, per-object ones and user provided ones.
  55  * (Although signals can deal with any kind of instantiatable type, I&#39;m
  56  * referring to those types as &quot;object types&quot; in the following, simply
  57  * because that is the context most users will encounter signals in.)
  58  * The per-object callbacks are most often referred to as &quot;object method
  59  * handler&quot; or &quot;default (signal) handler&quot;, while user provided callbacks are
  60  * usually just called &quot;signal handler&quot;.
  61  *
  62  * The object method handler is provided at signal creation time (this most
  63  * frequently happens at the end of an object class&#39; creation), while user
  64  * provided handlers are frequently connected and disconnected to/from a
  65  * certain signal on certain object instances.
  66  *
  67  * A signal emission consists of five stages, unless prematurely stopped:
  68  *
  69  * 1. Invocation of the object method handler for %G_SIGNAL_RUN_FIRST signals
  70  *
  71  * 2. Invocation of normal user-provided signal handlers (where the @after
  72  *    flag is not set)
  73  *
  74  * 3. Invocation of the object method handler for %G_SIGNAL_RUN_LAST signals
  75  *
  76  * 4. Invocation of user provided signal handlers (where the @after flag is set)
  77  *
  78  * 5. Invocation of the object method handler for %G_SIGNAL_RUN_CLEANUP signals
  79  *
  80  * The user-provided signal handlers are called in the order they were
  81  * connected in.
  82  *
  83  * All handlers may prematurely stop a signal emission, and any number of
  84  * handlers may be connected, disconnected, blocked or unblocked during
  85  * a signal emission.
  86  *
  87  * There are certain criteria for skipping user handlers in stages 2 and 4
  88  * of a signal emission.
  89  *
  90  * First, user handlers may be blocked. Blocked handlers are omitted during
  91  * callback invocation, to return from the blocked state, a handler has to
  92  * get unblocked exactly the same amount of times it has been blocked before.
  93  *
  94  * Second, upon emission of a %G_SIGNAL_DETAILED signal, an additional
  95  * @detail argument passed in to g_signal_emit() has to match the detail
  96  * argument of the signal handler currently subject to invocation.
  97  * Specification of no detail argument for signal handlers (omission of the
  98  * detail part of the signal specification upon connection) serves as a
  99  * wildcard and matches any detail argument passed in to emission.
 100  *
 101  * ## Memory management of signal handlers # {#signal-memory-management}
 102  *
 103  * If you are connecting handlers to signals and using a #GObject instance as
 104  * your signal handler user data, you should remember to pair calls to
 105  * g_signal_connect() with calls to g_signal_handler_disconnect() or
 106  * g_signal_handlers_disconnect_by_func(). While signal handlers are
 107  * automatically disconnected when the object emitting the signal is finalised,
 108  * they are not automatically disconnected when the signal handler user data is
 109  * destroyed. If this user data is a #GObject instance, using it from a
 110  * signal handler after it has been finalised is an error.
 111  *
 112  * There are two strategies for managing such user data. The first is to
 113  * disconnect the signal handler (using g_signal_handler_disconnect() or
 114  * g_signal_handlers_disconnect_by_func()) when the user data (object) is
 115  * finalised; this has to be implemented manually. For non-threaded programs,
 116  * g_signal_connect_object() can be used to implement this automatically.
 117  * Currently, however, it is unsafe to use in threaded programs.
 118  *
 119  * The second is to hold a strong reference on the user data until after the
 120  * signal is disconnected for other reasons. This can be implemented
 121  * automatically using g_signal_connect_data().
 122  *
 123  * The first approach is recommended, as the second approach can result in
 124  * effective memory leaks of the user data if the signal handler is never
 125  * disconnected for some reason.
 126  */
 127 
 128 
 129 #define REPORT_BUG      &quot;please report occurrence circumstances to gtk-devel-list@gnome.org&quot;
 130 
 131 /* --- typedefs --- */
 132 typedef struct _SignalNode   SignalNode;
 133 typedef struct _SignalKey    SignalKey;
 134 typedef struct _Emission     Emission;
 135 typedef struct _Handler      Handler;
 136 typedef struct _HandlerList  HandlerList;
 137 typedef struct _HandlerMatch HandlerMatch;
 138 typedef enum
 139 {
 140   EMISSION_STOP,
 141   EMISSION_RUN,
 142   EMISSION_HOOK,
 143   EMISSION_RESTART
 144 } EmissionState;
 145 
 146 
 147 /* --- prototypes --- */
 148 static inline guint     signal_id_lookup    (GQuark       quark,
 149                              GType        itype);
 150 static        void      signal_destroy_R    (SignalNode  *signal_node);
 151 static inline HandlerList*  handler_list_ensure (guint        signal_id,
 152                              gpointer     instance);
 153 static inline HandlerList*  handler_list_lookup (guint        signal_id,
 154                              gpointer     instance);
 155 static inline Handler*      handler_new     (guint            signal_id,
 156                              gpointer         instance,
 157                                                          gboolean     after);
 158 static        void      handler_insert      (guint        signal_id,
 159                              gpointer     instance,
 160                              Handler     *handler);
 161 static        Handler*      handler_lookup      (gpointer     instance,
 162                              gulong       handler_id,
 163                              GClosure        *closure,
 164                              guint       *signal_id_p);
 165 static inline HandlerMatch* handler_match_prepend   (HandlerMatch    *list,
 166                              Handler     *handler,
 167                              guint        signal_id);
 168 static inline HandlerMatch* handler_match_free1_R   (HandlerMatch    *node,
 169                              gpointer     instance);
 170 static        HandlerMatch* handlers_find       (gpointer     instance,
 171                              GSignalMatchType mask,
 172                              guint        signal_id,
 173                              GQuark       detail,
 174                              GClosure    *closure,
 175                              gpointer     func,
 176                              gpointer     data,
 177                              gboolean     one_and_only);
 178 static inline void      handler_ref     (Handler     *handler);
 179 static inline void      handler_unref_R     (guint        signal_id,
 180                              gpointer     instance,
 181                              Handler     *handler);
 182 static gint         handler_lists_cmp   (gconstpointer    node1,
 183                              gconstpointer    node2);
 184 static inline void      emission_push       (Emission    *emission);
 185 static inline void      emission_pop        (Emission    *emission);
 186 static inline Emission*     emission_find       (guint        signal_id,
 187                              GQuark       detail,
 188                              gpointer     instance);
 189 static gint         class_closures_cmp  (gconstpointer    node1,
 190                              gconstpointer    node2);
 191 static gint         signal_key_cmp      (gconstpointer    node1,
 192                              gconstpointer    node2);
 193 static        gboolean      signal_emit_unlocked_R  (SignalNode  *node,
 194                              GQuark       detail,
 195                              gpointer     instance,
 196                              GValue      *return_value,
 197                              const GValue    *instance_and_params);
 198 static       void               add_invalid_closure_notify    (Handler         *handler,
 199                                    gpointer         instance);
 200 static       void               remove_invalid_closure_notify (Handler         *handler,
 201                                    gpointer         instance);
 202 static       void               invalid_closure_notify  (gpointer         data,
 203                              GClosure        *closure);
 204 static const gchar *            type_debug_name         (GType            type);
 205 static void                     node_check_deprecated   (const SignalNode *node);
 206 static void                     node_update_single_va_closure (SignalNode *node);
 207 
 208 
 209 /* --- structures --- */
 210 typedef struct
 211 {
 212   GSignalAccumulator func;
 213   gpointer           data;
 214 } SignalAccumulator;
 215 typedef struct
 216 {
 217   GHook hook;
 218   GQuark detail;
 219 } SignalHook;
 220 #define SIGNAL_HOOK(hook)   ((SignalHook*) (hook))
 221 
 222 struct _SignalNode
 223 {
 224   /* permanent portion */
 225   guint              signal_id;
 226   GType              itype;
 227   const gchar       *name;
 228   guint              destroyed : 1;
 229 
 230   /* reinitializable portion */
 231   guint              flags : 9;
 232   guint              n_params : 8;
 233   guint              single_va_closure_is_valid : 1;
 234   guint              single_va_closure_is_after : 1;
 235   GType         *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
 236   GType          return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
 237   GBSearchArray     *class_closure_bsa;
 238   SignalAccumulator *accumulator;
 239   GSignalCMarshaller c_marshaller;
 240   GSignalCVaMarshaller va_marshaller;
 241   GHookList         *emission_hooks;
 242 
 243   GClosure *single_va_closure;
 244 };
 245 
 246 #define SINGLE_VA_CLOSURE_EMPTY_MAGIC GINT_TO_POINTER(1)    /* indicates single_va_closure is valid but empty */
 247 
 248 struct _SignalKey
 249 {
 250   GType  itype;
 251   GQuark quark;
 252   guint  signal_id;
 253 };
 254 
 255 struct _Emission
 256 {
 257   Emission             *next;
 258   gpointer              instance;
 259   GSignalInvocationHint ihint;
 260   EmissionState         state;
 261   GType         chain_type;
 262 };
 263 
 264 struct _HandlerList
 265 {
 266   guint    signal_id;
 267   Handler *handlers;
 268   Handler *tail_before;  /* normal signal handlers are appended here  */
 269   Handler *tail_after;   /* CONNECT_AFTER handlers are appended here  */
 270 };
 271 
 272 struct _Handler
 273 {
 274   gulong        sequential_number;
 275   Handler      *next;
 276   Handler      *prev;
 277   GQuark    detail;
 278   guint         signal_id;
 279   guint         ref_count;
 280   guint         block_count : 16;
 281 #define HANDLER_MAX_BLOCK_COUNT (1 &lt;&lt; 16)
 282   guint         after : 1;
 283   guint         has_invalid_closure_notify : 1;
 284   GClosure     *closure;
 285   gpointer      instance;
 286 };
 287 struct _HandlerMatch
 288 {
 289   Handler      *handler;
 290   HandlerMatch *next;
 291   guint         signal_id;
 292 };
 293 
 294 typedef struct
 295 {
 296   GType     instance_type; /* 0 for default closure */
 297   GClosure *closure;
 298 } ClassClosure;
 299 
 300 
 301 /* --- variables --- */
 302 static GBSearchArray *g_signal_key_bsa = NULL;
 303 static const GBSearchConfig g_signal_key_bconfig = {
 304   sizeof (SignalKey),
 305   signal_key_cmp,
 306   G_BSEARCH_ARRAY_ALIGN_POWER2,
 307 };
 308 static GBSearchConfig g_signal_hlbsa_bconfig = {
 309   sizeof (HandlerList),
 310   handler_lists_cmp,
 311   0,
 312 };
 313 static GBSearchConfig g_class_closure_bconfig = {
 314   sizeof (ClassClosure),
 315   class_closures_cmp,
 316   0,
 317 };
 318 static GHashTable    *g_handler_list_bsa_ht = NULL;
 319 static Emission      *g_emissions = NULL;
 320 static gulong         g_handler_sequential_number = 1;
 321 static GHashTable    *g_handlers = NULL;
 322 
 323 G_LOCK_DEFINE_STATIC (g_signal_mutex);
 324 #define SIGNAL_LOCK()       G_LOCK (g_signal_mutex)
 325 #define SIGNAL_UNLOCK()     G_UNLOCK (g_signal_mutex)
 326 
 327 
 328 /* --- signal nodes --- */
 329 static guint          g_n_signal_nodes = 0;
 330 static SignalNode   **g_signal_nodes = NULL;
 331 
 332 static inline SignalNode*
 333 LOOKUP_SIGNAL_NODE (guint signal_id)
 334 {
 335   if (signal_id &lt; g_n_signal_nodes)
 336     return g_signal_nodes[signal_id];
 337   else
 338     return NULL;
 339 }
 340 
 341 
 342 /* --- functions --- */
 343 static inline guint
 344 signal_id_lookup (GQuark quark,
 345           GType  itype)
 346 {
 347   GType *ifaces, type = itype;
 348   SignalKey key;
 349   guint n_ifaces;
 350 
 351   key.quark = quark;
 352 
 353   /* try looking up signals for this type and its ancestors */
 354   do
 355     {
 356       SignalKey *signal_key;
 357 
 358       key.itype = type;
 359       signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
 360 
 361       if (signal_key)
 362     return signal_key-&gt;signal_id;
 363 
 364       type = g_type_parent (type);
 365     }
 366   while (type);
 367 
 368   /* no luck, try interfaces it exports */
 369   ifaces = g_type_interfaces (itype, &amp;n_ifaces);
 370   while (n_ifaces--)
 371     {
 372       SignalKey *signal_key;
 373 
 374       key.itype = ifaces[n_ifaces];
 375       signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
 376 
 377       if (signal_key)
 378     {
 379       g_free (ifaces);
 380       return signal_key-&gt;signal_id;
 381     }
 382     }
 383   g_free (ifaces);
 384 
 385   return 0;
 386 }
 387 
 388 static gint
 389 class_closures_cmp (gconstpointer node1,
 390             gconstpointer node2)
 391 {
 392   const ClassClosure *c1 = node1, *c2 = node2;
 393 
 394   return G_BSEARCH_ARRAY_CMP (c1-&gt;instance_type, c2-&gt;instance_type);
 395 }
 396 
 397 static gint
 398 handler_lists_cmp (gconstpointer node1,
 399                    gconstpointer node2)
 400 {
 401   const HandlerList *hlist1 = node1, *hlist2 = node2;
 402 
 403   return G_BSEARCH_ARRAY_CMP (hlist1-&gt;signal_id, hlist2-&gt;signal_id);
 404 }
 405 
 406 static inline HandlerList*
 407 handler_list_ensure (guint    signal_id,
 408              gpointer instance)
 409 {
 410   GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
 411   HandlerList key;
 412 
 413   key.signal_id = signal_id;
 414   key.handlers    = NULL;
 415   key.tail_before = NULL;
 416   key.tail_after  = NULL;
 417   if (!hlbsa)
 418     {
 419       hlbsa = g_bsearch_array_create (&amp;g_signal_hlbsa_bconfig);
 420       hlbsa = g_bsearch_array_insert (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key);
 421       g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);
 422     }
 423   else
 424     {
 425       GBSearchArray *o = hlbsa;
 426 
 427       hlbsa = g_bsearch_array_insert (o, &amp;g_signal_hlbsa_bconfig, &amp;key);
 428       if (hlbsa != o)
 429     g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);
 430     }
 431   return g_bsearch_array_lookup (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key);
 432 }
 433 
 434 static inline HandlerList*
 435 handler_list_lookup (guint    signal_id,
 436              gpointer instance)
 437 {
 438   GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
 439   HandlerList key;
 440 
 441   key.signal_id = signal_id;
 442 
 443   return hlbsa ? g_bsearch_array_lookup (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key) : NULL;
 444 }
 445 
 446 static guint
 447 handler_hash (gconstpointer key)
 448 {
 449   return (guint)((Handler*)key)-&gt;sequential_number;
 450 }
 451 
 452 static gboolean
 453 handler_equal (gconstpointer a, gconstpointer b)
 454 {
 455   Handler *ha = (Handler *)a;
 456   Handler *hb = (Handler *)b;
 457   return (ha-&gt;sequential_number == hb-&gt;sequential_number) &amp;&amp;
 458       (ha-&gt;instance  == hb-&gt;instance);
 459 }
 460 
 461 static Handler*
 462 handler_lookup (gpointer  instance,
 463         gulong    handler_id,
 464         GClosure *closure,
 465         guint    *signal_id_p)
 466 {
 467   GBSearchArray *hlbsa;
 468 
 469   if (handler_id)
 470     {
 471       Handler key;
 472       key.sequential_number = handler_id;
 473       key.instance = instance;
 474       return g_hash_table_lookup (g_handlers, &amp;key);
 475 
 476     }
 477 
 478   hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
 479 
 480   if (hlbsa)
 481     {
 482       guint i;
 483 
 484       for (i = 0; i &lt; hlbsa-&gt;n_nodes; i++)
 485         {
 486           HandlerList *hlist = g_bsearch_array_get_nth (hlbsa, &amp;g_signal_hlbsa_bconfig, i);
 487           Handler *handler;
 488 
 489           for (handler = hlist-&gt;handlers; handler; handler = handler-&gt;next)
 490             if (closure ? (handler-&gt;closure == closure) : (handler-&gt;sequential_number == handler_id))
 491               {
 492                 if (signal_id_p)
 493                   *signal_id_p = hlist-&gt;signal_id;
 494 
 495                 return handler;
 496               }
 497         }
 498     }
 499 
 500   return NULL;
 501 }
 502 
 503 static inline HandlerMatch*
 504 handler_match_prepend (HandlerMatch *list,
 505                        Handler      *handler,
 506                guint         signal_id)
 507 {
 508   HandlerMatch *node;
 509 
 510   node = g_slice_new (HandlerMatch);
 511 #ifdef GSTREAMER_LITE
 512   if (node == NULL) {
 513     return NULL;
 514   }
 515 #endif // GSTREAMER_LITE
 516   node-&gt;handler = handler;
 517   node-&gt;next = list;
 518   node-&gt;signal_id = signal_id;
 519   handler_ref (handler);
 520 
 521   return node;
 522 }
 523 static inline HandlerMatch*
 524 handler_match_free1_R (HandlerMatch *node,
 525                gpointer      instance)
 526 {
 527   HandlerMatch *next = node-&gt;next;
 528 
 529   handler_unref_R (node-&gt;signal_id, instance, node-&gt;handler);
 530   g_slice_free (HandlerMatch, node);
 531 
 532   return next;
 533 }
 534 
 535 static HandlerMatch*
 536 handlers_find (gpointer         instance,
 537            GSignalMatchType mask,
 538            guint            signal_id,
 539            GQuark           detail,
 540            GClosure        *closure,
 541            gpointer         func,
 542            gpointer         data,
 543            gboolean         one_and_only)
 544 {
 545   HandlerMatch *mlist = NULL;
 546 
 547   if (mask &amp; G_SIGNAL_MATCH_ID)
 548     {
 549       HandlerList *hlist = handler_list_lookup (signal_id, instance);
 550       Handler *handler;
 551       SignalNode *node = NULL;
 552 
 553       if (mask &amp; G_SIGNAL_MATCH_FUNC)
 554     {
 555       node = LOOKUP_SIGNAL_NODE (signal_id);
 556       if (!node || !node-&gt;c_marshaller)
 557         return NULL;
 558     }
 559 
 560       mask = ~mask;
 561       for (handler = hlist ? hlist-&gt;handlers : NULL; handler; handler = handler-&gt;next)
 562         if (handler-&gt;sequential_number &amp;&amp;
 563         ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;
 564         ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;
 565             ((mask &amp; G_SIGNAL_MATCH_DATA) || handler-&gt;closure-&gt;data == data) &amp;&amp;
 566         ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;
 567         ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;
 568                           G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;
 569                           ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))
 570       {
 571         mlist = handler_match_prepend (mlist, handler, signal_id);
 572         if (one_and_only)
 573           return mlist;
 574       }
 575     }
 576   else
 577     {
 578       GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
 579 
 580       mask = ~mask;
 581       if (hlbsa)
 582         {
 583           guint i;
 584 
 585           for (i = 0; i &lt; hlbsa-&gt;n_nodes; i++)
 586             {
 587               HandlerList *hlist = g_bsearch_array_get_nth (hlbsa, &amp;g_signal_hlbsa_bconfig, i);
 588           SignalNode *node = NULL;
 589               Handler *handler;
 590 
 591           if (!(mask &amp; G_SIGNAL_MATCH_FUNC))
 592         {
 593           node = LOOKUP_SIGNAL_NODE (hlist-&gt;signal_id);
 594 #ifndef GSTREAMER_LITE
 595           if (!node-&gt;c_marshaller)
 596 #else // GSTREAMER_LITE
 597           if (!node || !node-&gt;c_marshaller)
 598 #endif // GSTREAMER_LITE
 599             continue;
 600         }
 601 
 602               for (handler = hlist-&gt;handlers; handler; handler = handler-&gt;next)
 603         if (handler-&gt;sequential_number &amp;&amp;
 604             ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;
 605                     ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;
 606                     ((mask &amp; G_SIGNAL_MATCH_DATA) || handler-&gt;closure-&gt;data == data) &amp;&amp;
 607             ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;
 608             ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;
 609                               G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;
 610                               ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))
 611           {
 612             mlist = handler_match_prepend (mlist, handler, hlist-&gt;signal_id);
 613             if (one_and_only)
 614               return mlist;
 615           }
 616             }
 617         }
 618     }
 619 
 620   return mlist;
 621 }
 622 
 623 static inline Handler*
 624 handler_new (guint signal_id, gpointer instance, gboolean after)
 625 {
 626   Handler *handler = g_slice_new (Handler);
 627 #ifndef G_DISABLE_CHECKS
 628   if (g_handler_sequential_number &lt; 1)
 629     g_error (G_STRLOC &quot;: handler id overflow, %s&quot;, REPORT_BUG);
 630 #endif
 631 
 632   handler-&gt;sequential_number = g_handler_sequential_number++;
 633   handler-&gt;prev = NULL;
 634   handler-&gt;next = NULL;
 635   handler-&gt;detail = 0;
 636   handler-&gt;signal_id = signal_id;
 637   handler-&gt;instance = instance;
 638   handler-&gt;ref_count = 1;
 639   handler-&gt;block_count = 0;
 640   handler-&gt;after = after != FALSE;
 641   handler-&gt;closure = NULL;
 642   handler-&gt;has_invalid_closure_notify = 0;
 643 
 644   g_hash_table_add (g_handlers, handler);
 645 
 646   return handler;
 647 }
 648 
 649 static inline void
 650 handler_ref (Handler *handler)
 651 {
 652   g_return_if_fail (handler-&gt;ref_count &gt; 0);
 653 
 654   handler-&gt;ref_count++;
 655 }
 656 
 657 static inline void
 658 handler_unref_R (guint    signal_id,
 659          gpointer instance,
 660          Handler *handler)
 661 {
 662   g_return_if_fail (handler-&gt;ref_count &gt; 0);
 663 
 664   handler-&gt;ref_count--;
 665 
 666   if (G_UNLIKELY (handler-&gt;ref_count == 0))
 667     {
 668       HandlerList *hlist = NULL;
 669 
 670       if (handler-&gt;next)
 671         handler-&gt;next-&gt;prev = handler-&gt;prev;
 672       if (handler-&gt;prev)    /* watch out for g_signal_handlers_destroy()! */
 673         handler-&gt;prev-&gt;next = handler-&gt;next;
 674       else
 675         {
 676           hlist = handler_list_lookup (signal_id, instance);
 677           g_assert (hlist != NULL);
 678           hlist-&gt;handlers = handler-&gt;next;
 679         }
 680 
 681       if (instance)
 682         {
 683           /*  check if we are removing the handler pointed to by tail_before  */
 684           if (!handler-&gt;after &amp;&amp; (!handler-&gt;next || handler-&gt;next-&gt;after))
 685             {
 686               if (!hlist)
 687                 hlist = handler_list_lookup (signal_id, instance);
 688               if (hlist)
 689                 {
 690                   g_assert (hlist-&gt;tail_before == handler); /* paranoid */
 691                   hlist-&gt;tail_before = handler-&gt;prev;
 692                 }
 693             }
 694 
 695           /*  check if we are removing the handler pointed to by tail_after  */
 696           if (!handler-&gt;next)
 697             {
 698               if (!hlist)
 699                 hlist = handler_list_lookup (signal_id, instance);
 700               if (hlist)
 701                 {
 702                   g_assert (hlist-&gt;tail_after == handler); /* paranoid */
 703                   hlist-&gt;tail_after = handler-&gt;prev;
 704                 }
 705             }
 706         }
 707 
 708       SIGNAL_UNLOCK ();
 709       g_closure_unref (handler-&gt;closure);
 710       SIGNAL_LOCK ();
 711       g_slice_free (Handler, handler);
 712     }
 713 }
 714 
 715 static void
 716 handler_insert (guint    signal_id,
 717         gpointer instance,
 718         Handler  *handler)
 719 {
 720   HandlerList *hlist;
 721 
 722   g_assert (handler-&gt;prev == NULL &amp;&amp; handler-&gt;next == NULL); /* paranoid */
 723 
 724   hlist = handler_list_ensure (signal_id, instance);
 725   if (!hlist-&gt;handlers)
 726     {
 727       hlist-&gt;handlers = handler;
 728       if (!handler-&gt;after)
 729         hlist-&gt;tail_before = handler;
 730     }
 731   else if (handler-&gt;after)
 732     {
 733       handler-&gt;prev = hlist-&gt;tail_after;
 734       hlist-&gt;tail_after-&gt;next = handler;
 735     }
 736   else
 737     {
 738       if (hlist-&gt;tail_before)
 739         {
 740           handler-&gt;next = hlist-&gt;tail_before-&gt;next;
 741           if (handler-&gt;next)
 742             handler-&gt;next-&gt;prev = handler;
 743           handler-&gt;prev = hlist-&gt;tail_before;
 744           hlist-&gt;tail_before-&gt;next = handler;
 745         }
 746       else /* insert !after handler into a list of only after handlers */
 747         {
 748           handler-&gt;next = hlist-&gt;handlers;
 749           if (handler-&gt;next)
 750             handler-&gt;next-&gt;prev = handler;
 751           hlist-&gt;handlers = handler;
 752         }
 753       hlist-&gt;tail_before = handler;
 754     }
 755 
 756   if (!handler-&gt;next)
 757     hlist-&gt;tail_after = handler;
 758 }
 759 
 760 static void
 761 node_update_single_va_closure (SignalNode *node)
 762 {
 763   GClosure *closure = NULL;
 764   gboolean is_after = FALSE;
 765 
 766   /* Fast path single-handler without boxing the arguments in GValues */
 767   if (G_TYPE_IS_OBJECT (node-&gt;itype) &amp;&amp;
 768       (node-&gt;flags &amp; (G_SIGNAL_MUST_COLLECT)) == 0 &amp;&amp;
 769       (node-&gt;emission_hooks == NULL || node-&gt;emission_hooks-&gt;hooks == NULL))
 770     {
 771       GSignalFlags run_type;
 772       ClassClosure * cc;
 773       GBSearchArray *bsa = node-&gt;class_closure_bsa;
 774 
 775       if (bsa == NULL || bsa-&gt;n_nodes == 0)
 776     closure = SINGLE_VA_CLOSURE_EMPTY_MAGIC;
 777       else if (bsa-&gt;n_nodes == 1)
 778     {
 779       /* Look for default class closure (can&#39;t support non-default as it
 780          chains up using GValues */
 781       cc = g_bsearch_array_get_nth (bsa, &amp;g_class_closure_bconfig, 0);
 782       if (cc-&gt;instance_type == 0)
 783         {
 784           run_type = node-&gt;flags &amp; (G_SIGNAL_RUN_FIRST|G_SIGNAL_RUN_LAST|G_SIGNAL_RUN_CLEANUP);
 785           /* Only support *one* of run-first or run-last, not multiple or cleanup */
 786           if (run_type == G_SIGNAL_RUN_FIRST ||
 787           run_type == G_SIGNAL_RUN_LAST)
 788         {
 789           closure = cc-&gt;closure;
 790           is_after = (run_type == G_SIGNAL_RUN_LAST);
 791         }
 792         }
 793     }
 794     }
 795 
 796   node-&gt;single_va_closure_is_valid = TRUE;
 797   node-&gt;single_va_closure = closure;
 798   node-&gt;single_va_closure_is_after = is_after;
 799 }
 800 
 801 static inline void
 802 emission_push (Emission  *emission)
 803 {
 804   emission-&gt;next = g_emissions;
 805   g_emissions = emission;
 806 }
 807 
 808 static inline void
 809 emission_pop (Emission  *emission)
 810 {
 811   Emission *node, *last = NULL;
 812 
 813   for (node = g_emissions; node; last = node, node = last-&gt;next)
 814     if (node == emission)
 815       {
 816     if (last)
 817       last-&gt;next = node-&gt;next;
 818     else
 819       g_emissions = node-&gt;next;
 820     return;
 821       }
 822   g_assert_not_reached ();
 823 }
 824 
 825 static inline Emission*
 826 emission_find (guint     signal_id,
 827            GQuark    detail,
 828            gpointer  instance)
 829 {
 830   Emission *emission;
 831 
 832   for (emission = g_emissions; emission; emission = emission-&gt;next)
 833     if (emission-&gt;instance == instance &amp;&amp;
 834     emission-&gt;ihint.signal_id == signal_id &amp;&amp;
 835     emission-&gt;ihint.detail == detail)
 836       return emission;
 837   return NULL;
 838 }
 839 
 840 static inline Emission*
 841 emission_find_innermost (gpointer instance)
 842 {
 843   Emission *emission;
 844 
 845   for (emission = g_emissions; emission; emission = emission-&gt;next)
 846     if (emission-&gt;instance == instance)
 847       return emission;
 848 
 849   return NULL;
 850       }
 851 
 852 static gint
 853 signal_key_cmp (gconstpointer node1,
 854                 gconstpointer node2)
 855 {
 856   const SignalKey *key1 = node1, *key2 = node2;
 857 
 858   if (key1-&gt;itype == key2-&gt;itype)
 859     return G_BSEARCH_ARRAY_CMP (key1-&gt;quark, key2-&gt;quark);
 860   else
 861     return G_BSEARCH_ARRAY_CMP (key1-&gt;itype, key2-&gt;itype);
 862 }
 863 
 864 void
 865 _g_signal_init (void)
 866 {
 867   SIGNAL_LOCK ();
 868   if (!g_n_signal_nodes)
 869     {
 870       /* setup handler list binary searchable array hash table (in german, that&#39;d be one word ;) */
 871       g_handler_list_bsa_ht = g_hash_table_new (g_direct_hash, NULL);
 872       g_signal_key_bsa = g_bsearch_array_create (&amp;g_signal_key_bconfig);
 873 
 874       /* invalid (0) signal_id */
 875       g_n_signal_nodes = 1;
 876       g_signal_nodes = g_renew (SignalNode*, g_signal_nodes, g_n_signal_nodes);
 877       g_signal_nodes[0] = NULL;
 878       g_handlers = g_hash_table_new (handler_hash, handler_equal);
 879     }
 880   SIGNAL_UNLOCK ();
 881 }
 882 
 883 void
 884 _g_signals_destroy (GType itype)
 885 {
 886   guint i;
 887 
 888   SIGNAL_LOCK ();
 889   for (i = 1; i &lt; g_n_signal_nodes; i++)
 890     {
 891       SignalNode *node = g_signal_nodes[i];
 892 
 893       if (node-&gt;itype == itype)
 894         {
 895           if (node-&gt;destroyed)
 896             g_warning (G_STRLOC &quot;: signal \&quot;%s\&quot; of type &#39;%s&#39; already destroyed&quot;,
 897                        node-&gt;name,
 898                        type_debug_name (node-&gt;itype));
 899           else
 900         signal_destroy_R (node);
 901         }
 902     }
 903   SIGNAL_UNLOCK ();
 904 }
 905 
 906 /**
 907  * g_signal_stop_emission:
 908  * @instance: (type GObject.Object): the object whose signal handlers you wish to stop.
 909  * @signal_id: the signal identifier, as returned by g_signal_lookup().
 910  * @detail: the detail which the signal was emitted with.
 911  *
 912  * Stops a signal&#39;s current emission.
 913  *
 914  * This will prevent the default method from running, if the signal was
 915  * %G_SIGNAL_RUN_LAST and you connected normally (i.e. without the &quot;after&quot;
 916  * flag).
 917  *
 918  * Prints a warning if used on a signal which isn&#39;t being emitted.
 919  */
 920 void
 921 g_signal_stop_emission (gpointer instance,
 922                         guint    signal_id,
 923             GQuark   detail)
 924 {
 925   SignalNode *node;
 926 
 927   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
 928   g_return_if_fail (signal_id &gt; 0);
 929 
 930   SIGNAL_LOCK ();
 931   node = LOOKUP_SIGNAL_NODE (signal_id);
 932   if (node &amp;&amp; detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
 933     {
 934       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);
 935       SIGNAL_UNLOCK ();
 936       return;
 937     }
 938   if (node &amp;&amp; g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
 939     {
 940       Emission *emission = emission_find (signal_id, detail, instance);
 941 
 942       if (emission)
 943         {
 944           if (emission-&gt;state == EMISSION_HOOK)
 945             g_warning (G_STRLOC &quot;: emission of signal \&quot;%s\&quot; for instance &#39;%p&#39; cannot be stopped from emission hook&quot;,
 946                        node-&gt;name, instance);
 947           else if (emission-&gt;state == EMISSION_RUN)
 948             emission-&gt;state = EMISSION_STOP;
 949         }
 950       else
 951         g_warning (G_STRLOC &quot;: no emission of signal \&quot;%s\&quot; to stop for instance &#39;%p&#39;&quot;,
 952                    node-&gt;name, instance);
 953     }
 954   else
 955     g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
 956   SIGNAL_UNLOCK ();
 957 }
 958 
 959 static void
 960 signal_finalize_hook (GHookList *hook_list,
 961               GHook     *hook)
 962 {
 963   GDestroyNotify destroy = hook-&gt;destroy;
 964 
 965   if (destroy)
 966     {
 967       hook-&gt;destroy = NULL;
 968       SIGNAL_UNLOCK ();
 969       destroy (hook-&gt;data);
 970       SIGNAL_LOCK ();
 971     }
 972 }
 973 
 974 /**
 975  * g_signal_add_emission_hook:
 976  * @signal_id: the signal identifier, as returned by g_signal_lookup().
 977  * @detail: the detail on which to call the hook.
 978  * @hook_func: a #GSignalEmissionHook function.
 979  * @hook_data: user data for @hook_func.
 980  * @data_destroy: a #GDestroyNotify for @hook_data.
 981  *
 982  * Adds an emission hook for a signal, which will get called for any emission
 983  * of that signal, independent of the instance. This is possible only
 984  * for signals which don&#39;t have #G_SIGNAL_NO_HOOKS flag set.
 985  *
 986  * Returns: the hook id, for later use with g_signal_remove_emission_hook().
 987  */
 988 gulong
 989 g_signal_add_emission_hook (guint               signal_id,
 990                 GQuark              detail,
 991                 GSignalEmissionHook hook_func,
 992                 gpointer            hook_data,
 993                 GDestroyNotify      data_destroy)
 994 {
 995   static gulong seq_hook_id = 1;
 996   SignalNode *node;
 997   GHook *hook;
 998   SignalHook *signal_hook;
 999 
1000   g_return_val_if_fail (signal_id &gt; 0, 0);
1001   g_return_val_if_fail (hook_func != NULL, 0);
1002 
1003   SIGNAL_LOCK ();
1004   node = LOOKUP_SIGNAL_NODE (signal_id);
1005   if (!node || node-&gt;destroyed)
1006     {
1007       g_warning (&quot;%s: invalid signal id &#39;%u&#39;&quot;, G_STRLOC, signal_id);
1008       SIGNAL_UNLOCK ();
1009       return 0;
1010     }
1011   if (node-&gt;flags &amp; G_SIGNAL_NO_HOOKS)
1012     {
1013       g_warning (&quot;%s: signal id &#39;%u&#39; does not support emission hooks (G_SIGNAL_NO_HOOKS flag set)&quot;, G_STRLOC, signal_id);
1014       SIGNAL_UNLOCK ();
1015       return 0;
1016     }
1017   if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
1018     {
1019       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);
1020       SIGNAL_UNLOCK ();
1021       return 0;
1022     }
1023     node-&gt;single_va_closure_is_valid = FALSE;
1024   if (!node-&gt;emission_hooks)
1025     {
1026       node-&gt;emission_hooks = g_new (GHookList, 1);
1027       g_hook_list_init (node-&gt;emission_hooks, sizeof (SignalHook));
1028       node-&gt;emission_hooks-&gt;finalize_hook = signal_finalize_hook;
1029     }
1030 
1031   node_check_deprecated (node);
1032 
1033   hook = g_hook_alloc (node-&gt;emission_hooks);
1034   hook-&gt;data = hook_data;
1035   hook-&gt;func = (gpointer) hook_func;
1036   hook-&gt;destroy = data_destroy;
1037   signal_hook = SIGNAL_HOOK (hook);
1038   signal_hook-&gt;detail = detail;
1039   node-&gt;emission_hooks-&gt;seq_id = seq_hook_id;
1040   g_hook_append (node-&gt;emission_hooks, hook);
1041   seq_hook_id = node-&gt;emission_hooks-&gt;seq_id;
1042 
1043   SIGNAL_UNLOCK ();
1044 
1045   return hook-&gt;hook_id;
1046 }
1047 
1048 /**
1049  * g_signal_remove_emission_hook:
1050  * @signal_id: the id of the signal
1051  * @hook_id: the id of the emission hook, as returned by
1052  *  g_signal_add_emission_hook()
1053  *
1054  * Deletes an emission hook.
1055  */
1056 void
1057 g_signal_remove_emission_hook (guint  signal_id,
1058                    gulong hook_id)
1059 {
1060   SignalNode *node;
1061 
1062   g_return_if_fail (signal_id &gt; 0);
1063   g_return_if_fail (hook_id &gt; 0);
1064 
1065   SIGNAL_LOCK ();
1066   node = LOOKUP_SIGNAL_NODE (signal_id);
1067   if (!node || node-&gt;destroyed)
1068     {
1069       g_warning (&quot;%s: invalid signal id &#39;%u&#39;&quot;, G_STRLOC, signal_id);
1070       goto out;
1071     }
1072   else if (!node-&gt;emission_hooks || !g_hook_destroy (node-&gt;emission_hooks, hook_id))
1073     g_warning (&quot;%s: signal \&quot;%s\&quot; had no hook (%lu) to remove&quot;, G_STRLOC, node-&gt;name, hook_id);
1074 
1075   node-&gt;single_va_closure_is_valid = FALSE;
1076 
1077  out:
1078   SIGNAL_UNLOCK ();
1079 }
1080 
1081 static inline guint
1082 signal_parse_name (const gchar *name,
1083            GType        itype,
1084            GQuark      *detail_p,
1085            gboolean     force_quark)
1086 {
1087   const gchar *colon = strchr (name, &#39;:&#39;);
1088   guint signal_id;
1089 
1090   if (!colon)
1091     {
1092       signal_id = signal_id_lookup (g_quark_try_string (name), itype);
1093       if (signal_id &amp;&amp; detail_p)
1094     *detail_p = 0;
1095     }
1096   else if (colon[1] == &#39;:&#39;)
1097     {
1098       gchar buffer[32];
1099       guint l = colon - name;
1100 
1101       if (l &lt; 32)
1102     {
1103       memcpy (buffer, name, l);
1104       buffer[l] = 0;
1105       signal_id = signal_id_lookup (g_quark_try_string (buffer), itype);
1106     }
1107       else
1108     {
1109       gchar *signal = g_new (gchar, l + 1);
1110 
1111       memcpy (signal, name, l);
1112       signal[l] = 0;
1113       signal_id = signal_id_lookup (g_quark_try_string (signal), itype);
1114       g_free (signal);
1115     }
1116 
1117       if (signal_id &amp;&amp; detail_p)
1118     *detail_p = colon[2] ? (force_quark ? g_quark_from_string : g_quark_try_string) (colon + 2) : 0;
1119     }
1120   else
1121     signal_id = 0;
1122   return signal_id;
1123 }
1124 
1125 /**
1126  * g_signal_parse_name:
1127  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
1128  * @itype: The interface/instance type that introduced &quot;signal-name&quot;.
1129  * @signal_id_p: (out): Location to store the signal id.
1130  * @detail_p: (out): Location to store the detail quark.
1131  * @force_detail_quark: %TRUE forces creation of a #GQuark for the detail.
1132  *
1133  * Internal function to parse a signal name into its @signal_id
1134  * and @detail quark.
1135  *
1136  * Returns: Whether the signal name could successfully be parsed and @signal_id_p and @detail_p contain valid return values.
1137  */
1138 gboolean
1139 g_signal_parse_name (const gchar *detailed_signal,
1140                      GType        itype,
1141                      guint       *signal_id_p,
1142                      GQuark      *detail_p,
1143              gboolean     force_detail_quark)
1144 {
1145   SignalNode *node;
1146   GQuark detail = 0;
1147   guint signal_id;
1148 
1149   g_return_val_if_fail (detailed_signal != NULL, FALSE);
1150   g_return_val_if_fail (G_TYPE_IS_INSTANTIATABLE (itype) || G_TYPE_IS_INTERFACE (itype), FALSE);
1151 
1152   SIGNAL_LOCK ();
1153   signal_id = signal_parse_name (detailed_signal, itype, &amp;detail, force_detail_quark);
1154   SIGNAL_UNLOCK ();
1155 
1156   node = signal_id ? LOOKUP_SIGNAL_NODE (signal_id) : NULL;
1157   if (!node || node-&gt;destroyed ||
1158       (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED)))
1159     return FALSE;
1160 
1161   if (signal_id_p)
1162     *signal_id_p = signal_id;
1163   if (detail_p)
1164     *detail_p = detail;
1165 
1166   return TRUE;
1167 }
1168 
1169 /**
1170  * g_signal_stop_emission_by_name:
1171  * @instance: (type GObject.Object): the object whose signal handlers you wish to stop.
1172  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
1173  *
1174  * Stops a signal&#39;s current emission.
1175  *
1176  * This is just like g_signal_stop_emission() except it will look up the
1177  * signal id for you.
1178  */
1179 void
1180 g_signal_stop_emission_by_name (gpointer     instance,
1181                 const gchar *detailed_signal)
1182 {
1183   guint signal_id;
1184   GQuark detail = 0;
1185   GType itype;
1186 
1187   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
1188   g_return_if_fail (detailed_signal != NULL);
1189 
1190   SIGNAL_LOCK ();
1191   itype = G_TYPE_FROM_INSTANCE (instance);
1192   signal_id = signal_parse_name (detailed_signal, itype, &amp;detail, TRUE);
1193   if (signal_id)
1194     {
1195       SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
1196 
1197       if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
1198     g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);
1199       else if (!g_type_is_a (itype, node-&gt;itype))
1200         g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
1201                    G_STRLOC, detailed_signal, instance, g_type_name (itype));
1202       else
1203     {
1204       Emission *emission = emission_find (signal_id, detail, instance);
1205 
1206       if (emission)
1207         {
1208           if (emission-&gt;state == EMISSION_HOOK)
1209         g_warning (G_STRLOC &quot;: emission of signal \&quot;%s\&quot; for instance &#39;%p&#39; cannot be stopped from emission hook&quot;,
1210                node-&gt;name, instance);
1211           else if (emission-&gt;state == EMISSION_RUN)
1212         emission-&gt;state = EMISSION_STOP;
1213         }
1214       else
1215         g_warning (G_STRLOC &quot;: no emission of signal \&quot;%s\&quot; to stop for instance &#39;%p&#39;&quot;,
1216                node-&gt;name, instance);
1217     }
1218     }
1219   else
1220     g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
1221                G_STRLOC, detailed_signal, instance, g_type_name (itype));
1222   SIGNAL_UNLOCK ();
1223 }
1224 
1225 /**
1226  * g_signal_lookup:
1227  * @name: the signal&#39;s name.
1228  * @itype: the type that the signal operates on.
1229  *
1230  * Given the name of the signal and the type of object it connects to, gets
1231  * the signal&#39;s identifying integer. Emitting the signal by number is
1232  * somewhat faster than using the name each time.
1233  *
1234  * Also tries the ancestors of the given type.
1235  *
1236  * See g_signal_new() for details on allowed signal names.
1237  *
1238  * Returns: the signal&#39;s identifying number, or 0 if no signal was found.
1239  */
1240 guint
1241 g_signal_lookup (const gchar *name,
1242                  GType        itype)
1243 {
1244   guint signal_id;
1245   g_return_val_if_fail (name != NULL, 0);
1246   g_return_val_if_fail (G_TYPE_IS_INSTANTIATABLE (itype) || G_TYPE_IS_INTERFACE (itype), 0);
1247 
1248   SIGNAL_LOCK ();
1249   signal_id = signal_id_lookup (g_quark_try_string (name), itype);
1250   SIGNAL_UNLOCK ();
1251   if (!signal_id)
1252     {
1253       /* give elaborate warnings */
1254       if (!g_type_name (itype))
1255     g_warning (G_STRLOC &quot;: unable to lookup signal \&quot;%s\&quot; for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,
1256            name, itype);
1257       else if (!G_TYPE_IS_INSTANTIATABLE (itype))
1258     g_warning (G_STRLOC &quot;: unable to lookup signal \&quot;%s\&quot; for non instantiatable type &#39;%s&#39;&quot;,
1259            name, g_type_name (itype));
1260       else if (!g_type_class_peek (itype))
1261     g_warning (G_STRLOC &quot;: unable to lookup signal \&quot;%s\&quot; of unloaded type &#39;%s&#39;&quot;,
1262            name, g_type_name (itype));
1263     }
1264 
1265   return signal_id;
1266 }
1267 
1268 /**
1269  * g_signal_list_ids:
1270  * @itype: Instance or interface type.
1271  * @n_ids: Location to store the number of signal ids for @itype.
1272  *
1273  * Lists the signals by id that a certain instance or interface type
1274  * created. Further information about the signals can be acquired through
1275  * g_signal_query().
1276  *
1277  * Returns: (array length=n_ids) (transfer full): Newly allocated array of signal IDs.
1278  */
1279 guint*
1280 g_signal_list_ids (GType  itype,
1281            guint *n_ids)
1282 {
1283   SignalKey *keys;
1284   GArray *result;
1285   guint n_nodes;
1286   guint i;
1287 
1288   g_return_val_if_fail (G_TYPE_IS_INSTANTIATABLE (itype) || G_TYPE_IS_INTERFACE (itype), NULL);
1289   g_return_val_if_fail (n_ids != NULL, NULL);
1290 
1291   SIGNAL_LOCK ();
1292   keys = g_bsearch_array_get_nth (g_signal_key_bsa, &amp;g_signal_key_bconfig, 0);
1293   n_nodes = g_bsearch_array_get_n_nodes (g_signal_key_bsa);
1294   result = g_array_new (FALSE, FALSE, sizeof (guint));
1295 #ifdef GSTREAMER_LITE
1296   if (result == NULL) {
1297     SIGNAL_UNLOCK ();
1298     return NULL;
1299   }
1300 #endif // GSTREAMER_LITE
1301 
1302   for (i = 0; i &lt; n_nodes; i++)
1303     if (keys[i].itype == itype)
1304       {
1305     const gchar *name = g_quark_to_string (keys[i].quark);
1306 
1307     /* Signal names with &quot;_&quot; in them are aliases to the same
1308      * name with &quot;-&quot; instead of &quot;_&quot;.
1309      */
1310     if (!strchr (name, &#39;_&#39;))
1311       g_array_append_val (result, keys[i].signal_id);
1312       }
1313   *n_ids = result-&gt;len;
1314   SIGNAL_UNLOCK ();
1315   if (!n_nodes)
1316     {
1317       /* give elaborate warnings */
1318       if (!g_type_name (itype))
1319     g_warning (G_STRLOC &quot;: unable to list signals for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,
1320            itype);
1321       else if (!G_TYPE_IS_INSTANTIATABLE (itype) &amp;&amp; !G_TYPE_IS_INTERFACE (itype))
1322     g_warning (G_STRLOC &quot;: unable to list signals of non instantiatable type &#39;%s&#39;&quot;,
1323            g_type_name (itype));
1324       else if (!g_type_class_peek (itype) &amp;&amp; !G_TYPE_IS_INTERFACE (itype))
1325     g_warning (G_STRLOC &quot;: unable to list signals of unloaded type &#39;%s&#39;&quot;,
1326            g_type_name (itype));
1327     }
1328 
1329   return (guint*) g_array_free (result, FALSE);
1330 }
1331 
1332 /**
1333  * g_signal_name:
1334  * @signal_id: the signal&#39;s identifying number.
1335  *
1336  * Given the signal&#39;s identifier, finds its name.
1337  *
1338  * Two different signals may have the same name, if they have differing types.
1339  *
1340  * Returns: the signal name, or %NULL if the signal number was invalid.
1341  */
1342 const gchar *
1343 g_signal_name (guint signal_id)
1344 {
1345   SignalNode *node;
1346   const gchar *name;
1347 
1348   SIGNAL_LOCK ();
1349   node = LOOKUP_SIGNAL_NODE (signal_id);
1350   name = node ? node-&gt;name : NULL;
1351   SIGNAL_UNLOCK ();
1352 
1353   return (char*) name;
1354 }
1355 
1356 /**
1357  * g_signal_query:
1358  * @signal_id: The signal id of the signal to query information for.
1359  * @query: (out caller-allocates): A user provided structure that is
1360  *  filled in with constant values upon success.
1361  *
1362  * Queries the signal system for in-depth information about a
1363  * specific signal. This function will fill in a user-provided
1364  * structure to hold signal-specific information. If an invalid
1365  * signal id is passed in, the @signal_id member of the #GSignalQuery
1366  * is 0. All members filled into the #GSignalQuery structure should
1367  * be considered constant and have to be left untouched.
1368  */
1369 void
1370 g_signal_query (guint         signal_id,
1371         GSignalQuery *query)
1372 {
1373   SignalNode *node;
1374 
1375   g_return_if_fail (query != NULL);
1376 
1377   SIGNAL_LOCK ();
1378   node = LOOKUP_SIGNAL_NODE (signal_id);
1379   if (!node || node-&gt;destroyed)
1380     query-&gt;signal_id = 0;
1381   else
1382     {
1383       query-&gt;signal_id = node-&gt;signal_id;
1384       query-&gt;signal_name = node-&gt;name;
1385       query-&gt;itype = node-&gt;itype;
1386       query-&gt;signal_flags = node-&gt;flags;
1387       query-&gt;return_type = node-&gt;return_type;
1388       query-&gt;n_params = node-&gt;n_params;
1389       query-&gt;param_types = node-&gt;param_types;
1390     }
1391   SIGNAL_UNLOCK ();
1392 }
1393 
1394 /**
1395  * g_signal_new:
1396  * @signal_name: the name for the signal
1397  * @itype: the type this signal pertains to. It will also pertain to
1398  *  types which are derived from this type.
1399  * @signal_flags: a combination of #GSignalFlags specifying detail of when
1400  *  the default handler is to be invoked. You should at least specify
1401  *  %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.
1402  * @class_offset: The offset of the function pointer in the class structure
1403  *  for this type. Used to invoke a class method generically. Pass 0 to
1404  *  not associate a class method slot with this signal.
1405  * @accumulator: the accumulator for this signal; may be %NULL.
1406  * @accu_data: user data for the @accumulator.
1407  * @c_marshaller: (nullable): the function to translate arrays of parameter
1408  *  values to signal emissions into C language callback invocations or %NULL.
1409  * @return_type: the type of return value, or #G_TYPE_NONE for a signal
1410  *  without a return value.
1411  * @n_params: the number of parameter types to follow.
1412  * @...: a list of types, one for each parameter.
1413  *
1414  * Creates a new signal. (This is usually done in the class initializer.)
1415  *
1416  * A signal name consists of segments consisting of ASCII letters and
1417  * digits, separated by either the &#39;-&#39; or &#39;_&#39; character. The first
1418  * character of a signal name must be a letter. Names which violate these
1419  * rules lead to undefined behaviour of the GSignal system.
1420  *
1421  * When registering a signal and looking up a signal, either separator can
1422  * be used, but they cannot be mixed.
1423  *
1424  * If 0 is used for @class_offset subclasses cannot override the class handler
1425  * in their class_init method by doing super_class-&gt;signal_handler = my_signal_handler.
1426  * Instead they will have to use g_signal_override_class_handler().
1427  *
1428  * If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
1429  * the marshaller for this signal.
1430  *
1431  * Returns: the signal id
1432  */
1433 guint
1434 g_signal_new (const gchar    *signal_name,
1435           GType       itype,
1436           GSignalFlags    signal_flags,
1437               guint               class_offset,
1438               GSignalAccumulator  accumulator,
1439           gpointer        accu_data,
1440               GSignalCMarshaller  c_marshaller,
1441           GType       return_type,
1442           guint       n_params,
1443               ...)
1444 {
1445   va_list args;
1446   guint signal_id;
1447 
1448   g_return_val_if_fail (signal_name != NULL, 0);
1449 
1450   va_start (args, n_params);
1451 
1452   signal_id = g_signal_new_valist (signal_name, itype, signal_flags,
1453                                    class_offset ? g_signal_type_cclosure_new (itype, class_offset) : NULL,
1454                    accumulator, accu_data, c_marshaller,
1455                                    return_type, n_params, args);
1456 
1457   va_end (args);
1458 
1459   return signal_id;
1460 }
1461 
1462 /**
1463  * g_signal_new_class_handler:
1464  * @signal_name: the name for the signal
1465  * @itype: the type this signal pertains to. It will also pertain to
1466  *  types which are derived from this type.
1467  * @signal_flags: a combination of #GSignalFlags specifying detail of when
1468  *  the default handler is to be invoked. You should at least specify
1469  *  %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.
1470  * @class_handler: a #GCallback which acts as class implementation of
1471  *  this signal. Used to invoke a class method generically. Pass %NULL to
1472  *  not associate a class method with this signal.
1473  * @accumulator: the accumulator for this signal; may be %NULL.
1474  * @accu_data: user data for the @accumulator.
1475  * @c_marshaller: (nullable): the function to translate arrays of parameter
1476  *  values to signal emissions into C language callback invocations or %NULL.
1477  * @return_type: the type of return value, or #G_TYPE_NONE for a signal
1478  *  without a return value.
1479  * @n_params: the number of parameter types to follow.
1480  * @...: a list of types, one for each parameter.
1481  *
1482  * Creates a new signal. (This is usually done in the class initializer.)
1483  *
1484  * This is a variant of g_signal_new() that takes a C callback instead
1485  * of a class offset for the signal&#39;s class handler. This function
1486  * doesn&#39;t need a function pointer exposed in the class structure of
1487  * an object definition, instead the function pointer is passed
1488  * directly and can be overriden by derived classes with
1489  * g_signal_override_class_closure() or
1490  * g_signal_override_class_handler()and chained to with
1491  * g_signal_chain_from_overridden() or
1492  * g_signal_chain_from_overridden_handler().
1493  *
1494  * See g_signal_new() for information about signal names.
1495  *
1496  * If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
1497  * the marshaller for this signal.
1498  *
1499  * Returns: the signal id
1500  *
1501  * Since: 2.18
1502  */
1503 guint
1504 g_signal_new_class_handler (const gchar        *signal_name,
1505                             GType               itype,
1506                             GSignalFlags        signal_flags,
1507                             GCallback           class_handler,
1508                             GSignalAccumulator  accumulator,
1509                             gpointer            accu_data,
1510                             GSignalCMarshaller  c_marshaller,
1511                             GType               return_type,
1512                             guint               n_params,
1513                             ...)
1514 {
1515   va_list args;
1516   guint signal_id;
1517 
1518   g_return_val_if_fail (signal_name != NULL, 0);
1519 
1520   va_start (args, n_params);
1521 
1522   signal_id = g_signal_new_valist (signal_name, itype, signal_flags,
1523                                    class_handler ? g_cclosure_new (class_handler, NULL, NULL) : NULL,
1524                                    accumulator, accu_data, c_marshaller,
1525                                    return_type, n_params, args);
1526 
1527   va_end (args);
1528 
1529   return signal_id;
1530 }
1531 
1532 static inline ClassClosure*
1533 signal_find_class_closure (SignalNode *node,
1534                GType       itype)
1535 {
1536   GBSearchArray *bsa = node-&gt;class_closure_bsa;
1537   ClassClosure *cc;
1538 
1539   if (bsa)
1540     {
1541       ClassClosure key;
1542 
1543       /* cc-&gt;instance_type is 0 for default closure */
1544 
1545       if (g_bsearch_array_get_n_nodes (bsa) == 1)
1546         {
1547           cc = g_bsearch_array_get_nth (bsa, &amp;g_class_closure_bconfig, 0);
1548           if (cc &amp;&amp; cc-&gt;instance_type == 0) /* check for default closure */
1549             return cc;
1550         }
1551 
1552       key.instance_type = itype;
1553       cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);
1554       while (!cc &amp;&amp; key.instance_type)
1555     {
1556       key.instance_type = g_type_parent (key.instance_type);
1557       cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);
1558     }
1559     }
1560   else
1561     cc = NULL;
1562   return cc;
1563 }
1564 
1565 static inline GClosure*
1566 signal_lookup_closure (SignalNode    *node,
1567                GTypeInstance *instance)
1568 {
1569   ClassClosure *cc;
1570 
1571   cc = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
1572   return cc ? cc-&gt;closure : NULL;
1573 }
1574 
1575 static void
1576 signal_add_class_closure (SignalNode *node,
1577               GType       itype,
1578               GClosure   *closure)
1579 {
1580   ClassClosure key;
1581 
1582   node-&gt;single_va_closure_is_valid = FALSE;
1583 
1584   if (!node-&gt;class_closure_bsa)
1585     node-&gt;class_closure_bsa = g_bsearch_array_create (&amp;g_class_closure_bconfig);
1586   key.instance_type = itype;
1587   key.closure = g_closure_ref (closure);
1588   node-&gt;class_closure_bsa = g_bsearch_array_insert (node-&gt;class_closure_bsa,
1589                             &amp;g_class_closure_bconfig,
1590                             &amp;key);
1591   g_closure_sink (closure);
1592   if (node-&gt;c_marshaller &amp;&amp; closure &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))
1593     {
1594       g_closure_set_marshal (closure, node-&gt;c_marshaller);
1595       if (node-&gt;va_marshaller)
1596     _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);
1597     }
1598 }
1599 
1600 /**
1601  * g_signal_newv:
1602  * @signal_name: the name for the signal
1603  * @itype: the type this signal pertains to. It will also pertain to
1604  *     types which are derived from this type
1605  * @signal_flags: a combination of #GSignalFlags specifying detail of when
1606  *     the default handler is to be invoked. You should at least specify
1607  *     %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST
1608  * @class_closure: (nullable): The closure to invoke on signal emission;
1609  *     may be %NULL
1610  * @accumulator: (nullable): the accumulator for this signal; may be %NULL
1611  * @accu_data: user data for the @accumulator
1612  * @c_marshaller: (nullable): the function to translate arrays of
1613  *     parameter values to signal emissions into C language callback
1614  *     invocations or %NULL
1615  * @return_type: the type of return value, or #G_TYPE_NONE for a signal
1616  *     without a return value
1617  * @n_params: the length of @param_types
1618  * @param_types: (array length=n_params): an array of types, one for
1619  *     each parameter
1620  *
1621  * Creates a new signal. (This is usually done in the class initializer.)
1622  *
1623  * See g_signal_new() for details on allowed signal names.
1624  *
1625  * If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
1626  * the marshaller for this signal.
1627  *
1628  * Returns: the signal id
1629  */
1630 guint
1631 g_signal_newv (const gchar       *signal_name,
1632                GType              itype,
1633                GSignalFlags       signal_flags,
1634                GClosure          *class_closure,
1635                GSignalAccumulator accumulator,
1636            gpointer       accu_data,
1637                GSignalCMarshaller c_marshaller,
1638                GType          return_type,
1639                guint              n_params,
1640                GType         *param_types)
1641 {
1642   gchar *name;
1643   guint signal_id, i;
1644   SignalNode *node;
1645   GSignalCMarshaller builtin_c_marshaller;
1646   GSignalCVaMarshaller builtin_va_marshaller;
1647   GSignalCVaMarshaller va_marshaller;
1648 
1649   g_return_val_if_fail (signal_name != NULL, 0);
1650   g_return_val_if_fail (G_TYPE_IS_INSTANTIATABLE (itype) || G_TYPE_IS_INTERFACE (itype), 0);
1651   if (n_params)
1652     g_return_val_if_fail (param_types != NULL, 0);
1653   g_return_val_if_fail ((return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0, 0);
1654   if (return_type == (G_TYPE_NONE &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
1655     g_return_val_if_fail (accumulator == NULL, 0);
1656   if (!accumulator)
1657     g_return_val_if_fail (accu_data == NULL, 0);
1658 
1659   name = g_strdup (signal_name);
1660   g_strdelimit (name, G_STR_DELIMITERS &quot;:^&quot;, &#39;_&#39;);  /* FIXME do character checks like for types */
1661 
1662   SIGNAL_LOCK ();
1663 
1664   signal_id = signal_id_lookup (g_quark_try_string (name), itype);
1665   node = LOOKUP_SIGNAL_NODE (signal_id);
1666   if (node &amp;&amp; !node-&gt;destroyed)
1667     {
1668       g_warning (G_STRLOC &quot;: signal \&quot;%s\&quot; already exists in the &#39;%s&#39; %s&quot;,
1669                  name,
1670                  type_debug_name (node-&gt;itype),
1671                  G_TYPE_IS_INTERFACE (node-&gt;itype) ? &quot;interface&quot; : &quot;class ancestry&quot;);
1672       g_free (name);
1673       SIGNAL_UNLOCK ();
1674       return 0;
1675     }
1676   if (node &amp;&amp; node-&gt;itype != itype)
1677     {
1678       g_warning (G_STRLOC &quot;: signal \&quot;%s\&quot; for type &#39;%s&#39; was previously created for type &#39;%s&#39;&quot;,
1679                  name,
1680                  type_debug_name (itype),
1681                  type_debug_name (node-&gt;itype));
1682       g_free (name);
1683       SIGNAL_UNLOCK ();
1684       return 0;
1685     }
1686   for (i = 0; i &lt; n_params; i++)
1687     if (!G_TYPE_IS_VALUE (param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
1688       {
1689     g_warning (G_STRLOC &quot;: parameter %d of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,
1690            i + 1, type_debug_name (param_types[i]), type_debug_name (itype), name);
1691     g_free (name);
1692     SIGNAL_UNLOCK ();
1693     return 0;
1694       }
1695   if (return_type != G_TYPE_NONE &amp;&amp; !G_TYPE_IS_VALUE (return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
1696     {
1697       g_warning (G_STRLOC &quot;: return value of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,
1698          type_debug_name (return_type), type_debug_name (itype), name);
1699       g_free (name);
1700       SIGNAL_UNLOCK ();
1701       return 0;
1702     }
1703   if (return_type != G_TYPE_NONE &amp;&amp;
1704       (signal_flags &amp; (G_SIGNAL_RUN_FIRST | G_SIGNAL_RUN_LAST | G_SIGNAL_RUN_CLEANUP)) == G_SIGNAL_RUN_FIRST)
1705     {
1706       g_warning (G_STRLOC &quot;: signal \&quot;%s::%s\&quot; has return type &#39;%s&#39; and is only G_SIGNAL_RUN_FIRST&quot;,
1707          type_debug_name (itype), name, type_debug_name (return_type));
1708       g_free (name);
1709       SIGNAL_UNLOCK ();
1710       return 0;
1711     }
1712 
1713   /* setup permanent portion of signal node */
1714   if (!node)
1715     {
1716       SignalKey key;
1717 
1718       signal_id = g_n_signal_nodes++;
1719       node = g_new (SignalNode, 1);
1720       node-&gt;signal_id = signal_id;
1721       g_signal_nodes = g_renew (SignalNode*, g_signal_nodes, g_n_signal_nodes);
1722       g_signal_nodes[signal_id] = node;
1723       node-&gt;itype = itype;
1724       node-&gt;name = name;
1725       key.itype = itype;
1726       key.quark = g_quark_from_string (node-&gt;name);
1727       key.signal_id = signal_id;
1728       g_signal_key_bsa = g_bsearch_array_insert (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
1729       g_strdelimit (name, &quot;_&quot;, &#39;-&#39;);
1730       node-&gt;name = g_intern_string (name);
1731       key.quark = g_quark_from_string (name);
1732       g_signal_key_bsa = g_bsearch_array_insert (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
1733 
1734       TRACE(GOBJECT_SIGNAL_NEW(signal_id, name, itype));
1735     }
1736   node-&gt;destroyed = FALSE;
1737 
1738   /* setup reinitializable portion */
1739   node-&gt;single_va_closure_is_valid = FALSE;
1740   node-&gt;flags = signal_flags &amp; G_SIGNAL_FLAGS_MASK;
1741   node-&gt;n_params = n_params;
1742   node-&gt;param_types = g_memdup (param_types, sizeof (GType) * n_params);
1743   node-&gt;return_type = return_type;
1744   node-&gt;class_closure_bsa = NULL;
1745   if (accumulator)
1746     {
1747       node-&gt;accumulator = g_new (SignalAccumulator, 1);
1748       node-&gt;accumulator-&gt;func = accumulator;
1749       node-&gt;accumulator-&gt;data = accu_data;
1750     }
1751   else
1752     node-&gt;accumulator = NULL;
1753 
1754   builtin_c_marshaller = NULL;
1755   builtin_va_marshaller = NULL;
1756 
1757   /* Pick up built-in va marshallers for standard types, and
1758      instead of generic marshaller if no marshaller specified */
1759   if (n_params == 0 &amp;&amp; return_type == G_TYPE_NONE)
1760     {
1761       builtin_c_marshaller = g_cclosure_marshal_VOID__VOID;
1762       builtin_va_marshaller = g_cclosure_marshal_VOID__VOIDv;
1763     }
1764   else if (n_params == 1 &amp;&amp; return_type == G_TYPE_NONE)
1765     {
1766 #define ADD_CHECK(__type__) \
1767       else if (g_type_is_a (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, G_TYPE_ ##__type__))         \
1768     {                                                                \
1769       builtin_c_marshaller = g_cclosure_marshal_VOID__ ## __type__;  \
1770       builtin_va_marshaller = g_cclosure_marshal_VOID__ ## __type__ ##v;     \
1771     }
1772 
1773       if (0) {}
1774       ADD_CHECK (BOOLEAN)
1775       ADD_CHECK (CHAR)
1776       ADD_CHECK (UCHAR)
1777       ADD_CHECK (INT)
1778       ADD_CHECK (UINT)
1779       ADD_CHECK (LONG)
1780       ADD_CHECK (ULONG)
1781       ADD_CHECK (ENUM)
1782       ADD_CHECK (FLAGS)
1783       ADD_CHECK (FLOAT)
1784       ADD_CHECK (DOUBLE)
1785       ADD_CHECK (STRING)
1786       ADD_CHECK (PARAM)
1787       ADD_CHECK (BOXED)
1788       ADD_CHECK (POINTER)
1789       ADD_CHECK (OBJECT)
1790       ADD_CHECK (VARIANT)
1791     }
1792 
1793   if (c_marshaller == NULL)
1794     {
1795       if (builtin_c_marshaller)
1796         {
1797     c_marshaller = builtin_c_marshaller;
1798           va_marshaller = builtin_va_marshaller;
1799         }
1800       else
1801     {
1802       c_marshaller = g_cclosure_marshal_generic;
1803       va_marshaller = g_cclosure_marshal_generic_va;
1804     }
1805     }
1806   else
1807     va_marshaller = NULL;
1808 
1809   node-&gt;c_marshaller = c_marshaller;
1810   node-&gt;va_marshaller = va_marshaller;
1811   node-&gt;emission_hooks = NULL;
1812   if (class_closure)
1813     signal_add_class_closure (node, 0, class_closure);
1814 
1815   SIGNAL_UNLOCK ();
1816 
1817   g_free (name);
1818 
1819   return signal_id;
1820 }
1821 
1822 /**
1823  * g_signal_set_va_marshaller:
1824  * @signal_id: the signal id
1825  * @instance_type: the instance type on which to set the marshaller.
1826  * @va_marshaller: the marshaller to set.
1827  *
1828  * Change the #GSignalCVaMarshaller used for a given signal.  This is a
1829  * specialised form of the marshaller that can often be used for the
1830  * common case of a single connected signal handler and avoids the
1831  * overhead of #GValue.  Its use is optional.
1832  *
1833  * Since: 2.32
1834  */
1835 void
1836 g_signal_set_va_marshaller (guint              signal_id,
1837                 GType              instance_type,
1838                 GSignalCVaMarshaller va_marshaller)
1839 {
1840   SignalNode *node;
1841 
1842   g_return_if_fail (signal_id &gt; 0);
1843   g_return_if_fail (va_marshaller != NULL);
1844 
1845   SIGNAL_LOCK ();
1846   node = LOOKUP_SIGNAL_NODE (signal_id);
1847   if (node)
1848     {
1849       node-&gt;va_marshaller = va_marshaller;
1850       if (node-&gt;class_closure_bsa)
1851     {
1852       ClassClosure *cc = g_bsearch_array_get_nth (node-&gt;class_closure_bsa, &amp;g_class_closure_bconfig, 0);
1853       if (cc-&gt;closure-&gt;marshal == node-&gt;c_marshaller)
1854         _g_closure_set_va_marshal (cc-&gt;closure, va_marshaller);
1855     }
1856 
1857       node-&gt;single_va_closure_is_valid = FALSE;
1858     }
1859 
1860   SIGNAL_UNLOCK ();
1861 }
1862 
1863 
1864 /**
1865  * g_signal_new_valist:
1866  * @signal_name: the name for the signal
1867  * @itype: the type this signal pertains to. It will also pertain to
1868  *  types which are derived from this type.
1869  * @signal_flags: a combination of #GSignalFlags specifying detail of when
1870  *  the default handler is to be invoked. You should at least specify
1871  *  %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.
1872  * @class_closure: The closure to invoke on signal emission; may be %NULL.
1873  * @accumulator: the accumulator for this signal; may be %NULL.
1874  * @accu_data: user data for the @accumulator.
1875  * @c_marshaller: (nullable): the function to translate arrays of parameter
1876  *  values to signal emissions into C language callback invocations or %NULL.
1877  * @return_type: the type of return value, or #G_TYPE_NONE for a signal
1878  *  without a return value.
1879  * @n_params: the number of parameter types in @args.
1880  * @args: va_list of #GType, one for each parameter.
1881  *
1882  * Creates a new signal. (This is usually done in the class initializer.)
1883  *
1884  * See g_signal_new() for details on allowed signal names.
1885  *
1886  * If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
1887  * the marshaller for this signal.
1888  *
1889  * Returns: the signal id
1890  */
1891 guint
1892 g_signal_new_valist (const gchar       *signal_name,
1893                      GType              itype,
1894                      GSignalFlags       signal_flags,
1895                      GClosure          *class_closure,
1896                      GSignalAccumulator accumulator,
1897              gpointer       accu_data,
1898                      GSignalCMarshaller c_marshaller,
1899                      GType              return_type,
1900                      guint              n_params,
1901                      va_list            args)
1902 {
1903   GType *param_types;
1904   guint i;
1905   guint signal_id;
1906 
1907   if (n_params &gt; 0)
1908     {
1909       param_types = g_new (GType, n_params);
1910 
1911       for (i = 0; i &lt; n_params; i++)
1912     param_types[i] = va_arg (args, GType);
1913     }
1914   else
1915     param_types = NULL;
1916 
1917   signal_id = g_signal_newv (signal_name, itype, signal_flags,
1918                  class_closure, accumulator, accu_data, c_marshaller,
1919                  return_type, n_params, param_types);
1920   g_free (param_types);
1921 
1922   return signal_id;
1923 }
1924 
1925 static void
1926 signal_destroy_R (SignalNode *signal_node)
1927 {
1928   SignalNode node = *signal_node;
1929 
1930   signal_node-&gt;destroyed = TRUE;
1931 
1932   /* reentrancy caution, zero out real contents first */
1933   signal_node-&gt;single_va_closure_is_valid = FALSE;
1934   signal_node-&gt;n_params = 0;
1935   signal_node-&gt;param_types = NULL;
1936   signal_node-&gt;return_type = 0;
1937   signal_node-&gt;class_closure_bsa = NULL;
1938   signal_node-&gt;accumulator = NULL;
1939   signal_node-&gt;c_marshaller = NULL;
1940   signal_node-&gt;va_marshaller = NULL;
1941   signal_node-&gt;emission_hooks = NULL;
1942 
1943 #ifdef  G_ENABLE_DEBUG
1944   /* check current emissions */
1945   {
1946     Emission *emission;
1947 
1948     for (emission = g_emissions; emission; emission = emission-&gt;next)
1949       if (emission-&gt;ihint.signal_id == node.signal_id)
1950         g_critical (G_STRLOC &quot;: signal \&quot;%s\&quot; being destroyed is currently in emission (instance &#39;%p&#39;)&quot;,
1951                     node.name, emission-&gt;instance);
1952   }
1953 #endif
1954 
1955   /* free contents that need to
1956    */
1957   SIGNAL_UNLOCK ();
1958   g_free (node.param_types);
1959   if (node.class_closure_bsa)
1960     {
1961       guint i;
1962 
1963       for (i = 0; i &lt; node.class_closure_bsa-&gt;n_nodes; i++)
1964     {
1965       ClassClosure *cc = g_bsearch_array_get_nth (node.class_closure_bsa, &amp;g_class_closure_bconfig, i);
1966 
1967       g_closure_unref (cc-&gt;closure);
1968     }
1969       g_bsearch_array_free (node.class_closure_bsa, &amp;g_class_closure_bconfig);
1970     }
1971   g_free (node.accumulator);
1972   if (node.emission_hooks)
1973     {
1974       g_hook_list_clear (node.emission_hooks);
1975       g_free (node.emission_hooks);
1976     }
1977   SIGNAL_LOCK ();
1978 }
1979 
1980 /**
1981  * g_signal_override_class_closure:
1982  * @signal_id: the signal id
1983  * @instance_type: the instance type on which to override the class closure
1984  *  for the signal.
1985  * @class_closure: the closure.
1986  *
1987  * Overrides the class closure (i.e. the default handler) for the given signal
1988  * for emissions on instances of @instance_type. @instance_type must be derived
1989  * from the type to which the signal belongs.
1990  *
1991  * See g_signal_chain_from_overridden() and
1992  * g_signal_chain_from_overridden_handler() for how to chain up to the
1993  * parent class closure from inside the overridden one.
1994  */
1995 void
1996 g_signal_override_class_closure (guint     signal_id,
1997                  GType     instance_type,
1998                  GClosure *class_closure)
1999 {
2000   SignalNode *node;
2001 
2002   g_return_if_fail (signal_id &gt; 0);
2003   g_return_if_fail (class_closure != NULL);
2004 
2005   SIGNAL_LOCK ();
2006   node = LOOKUP_SIGNAL_NODE (signal_id);
2007   node_check_deprecated (node);
2008 #ifndef GSTREAMER_LITE
2009   if (!g_type_is_a (instance_type, node-&gt;itype))
2010 #else // GSTREAMER_LITE
2011   if (node == NULL || !g_type_is_a (instance_type, node-&gt;itype))
2012 #endif // GSTREAMER_LITE
2013     g_warning (&quot;%s: type &#39;%s&#39; cannot be overridden for signal id &#39;%u&#39;&quot;, G_STRLOC, type_debug_name (instance_type), signal_id);
2014   else
2015     {
2016       ClassClosure *cc = signal_find_class_closure (node, instance_type);
2017 
2018       if (cc &amp;&amp; cc-&gt;instance_type == instance_type)
2019     g_warning (&quot;%s: type &#39;%s&#39; is already overridden for signal id &#39;%u&#39;&quot;, G_STRLOC, type_debug_name (instance_type), signal_id);
2020       else
2021     signal_add_class_closure (node, instance_type, class_closure);
2022     }
2023   SIGNAL_UNLOCK ();
2024 }
2025 
2026 /**
2027  * g_signal_override_class_handler:
2028  * @signal_name: the name for the signal
2029  * @instance_type: the instance type on which to override the class handler
2030  *  for the signal.
2031  * @class_handler: the handler.
2032  *
2033  * Overrides the class closure (i.e. the default handler) for the
2034  * given signal for emissions on instances of @instance_type with
2035  * callback @class_handler. @instance_type must be derived from the
2036  * type to which the signal belongs.
2037  *
2038  * See g_signal_chain_from_overridden() and
2039  * g_signal_chain_from_overridden_handler() for how to chain up to the
2040  * parent class closure from inside the overridden one.
2041  *
2042  * Since: 2.18
2043  */
2044 void
2045 g_signal_override_class_handler (const gchar *signal_name,
2046                  GType        instance_type,
2047                  GCallback    class_handler)
2048 {
2049   guint signal_id;
2050 
2051   g_return_if_fail (signal_name != NULL);
2052   g_return_if_fail (instance_type != G_TYPE_NONE);
2053   g_return_if_fail (class_handler != NULL);
2054 
2055   signal_id = g_signal_lookup (signal_name, instance_type);
2056 
2057   if (signal_id)
2058     g_signal_override_class_closure (signal_id, instance_type,
2059                                      g_cclosure_new (class_handler, NULL, NULL));
2060   else
2061     g_warning (&quot;%s: signal name &#39;%s&#39; is invalid for type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,
2062                G_STRLOC, signal_name, instance_type);
2063 
2064 }
2065 
2066 /**
2067  * g_signal_chain_from_overridden:
2068  * @instance_and_params: (array) the argument list of the signal emission.
2069  *  The first element in the array is a #GValue for the instance the signal
2070  *  is being emitted on. The rest are any arguments to be passed to the signal.
2071  * @return_value: Location for the return value.
2072  *
2073  * Calls the original class closure of a signal. This function should only
2074  * be called from an overridden class closure; see
2075  * g_signal_override_class_closure() and
2076  * g_signal_override_class_handler().
2077  */
2078 void
2079 g_signal_chain_from_overridden (const GValue *instance_and_params,
2080                 GValue       *return_value)
2081 {
2082   GType chain_type = 0, restore_type = 0;
2083   Emission *emission = NULL;
2084   GClosure *closure = NULL;
2085   guint n_params = 0;
2086   gpointer instance;
2087 
2088   g_return_if_fail (instance_and_params != NULL);
2089   instance = g_value_peek_pointer (instance_and_params);
2090   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2091 
2092   SIGNAL_LOCK ();
2093   emission = emission_find_innermost (instance);
2094   if (emission)
2095     {
2096       SignalNode *node = LOOKUP_SIGNAL_NODE (emission-&gt;ihint.signal_id);
2097 
2098       g_assert (node != NULL);  /* paranoid */
2099 
2100       /* we should probably do the same parameter checks as g_signal_emit() here.
2101        */
2102       if (emission-&gt;chain_type != G_TYPE_NONE)
2103     {
2104       ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);
2105 
2106       g_assert (cc != NULL);    /* closure currently in call stack */
2107 
2108       n_params = node-&gt;n_params;
2109       restore_type = cc-&gt;instance_type;
2110       cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));
2111       if (cc &amp;&amp; cc-&gt;instance_type != restore_type)
2112         {
2113           closure = cc-&gt;closure;
2114           chain_type = cc-&gt;instance_type;
2115         }
2116     }
2117       else
2118     g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);
2119     }
2120   else
2121     g_warning (&quot;%s: no signal is currently being emitted for instance &#39;%p&#39;&quot;, G_STRLOC, instance);
2122 
2123   if (closure)
2124     {
2125       emission-&gt;chain_type = chain_type;
2126       SIGNAL_UNLOCK ();
2127       g_closure_invoke (closure,
2128             return_value,
2129             n_params + 1,
2130             instance_and_params,
2131             &amp;emission-&gt;ihint);
2132       SIGNAL_LOCK ();
2133       emission-&gt;chain_type = restore_type;
2134     }
2135   SIGNAL_UNLOCK ();
2136 }
2137 
2138 /**
2139  * g_signal_chain_from_overridden_handler: (skip)
2140  * @instance: (type GObject.TypeInstance): the instance the signal is being
2141  *    emitted on.
2142  * @...: parameters to be passed to the parent class closure, followed by a
2143  *  location for the return value. If the return type of the signal
2144  *  is #G_TYPE_NONE, the return value location can be omitted.
2145  *
2146  * Calls the original class closure of a signal. This function should
2147  * only be called from an overridden class closure; see
2148  * g_signal_override_class_closure() and
2149  * g_signal_override_class_handler().
2150  *
2151  * Since: 2.18
2152  */
2153 void
2154 g_signal_chain_from_overridden_handler (gpointer instance,
2155                                         ...)
2156 {
2157   GType chain_type = 0, restore_type = 0;
2158   Emission *emission = NULL;
2159   GClosure *closure = NULL;
2160   SignalNode *node;
2161   guint n_params = 0;
2162 
2163   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2164 
2165   SIGNAL_LOCK ();
2166   emission = emission_find_innermost (instance);
2167   if (emission)
2168     {
2169       node = LOOKUP_SIGNAL_NODE (emission-&gt;ihint.signal_id);
2170 
2171       g_assert (node != NULL);  /* paranoid */
2172 
2173       /* we should probably do the same parameter checks as g_signal_emit() here.
2174        */
2175       if (emission-&gt;chain_type != G_TYPE_NONE)
2176     {
2177       ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);
2178 
2179       g_assert (cc != NULL);    /* closure currently in call stack */
2180 
2181       n_params = node-&gt;n_params;
2182       restore_type = cc-&gt;instance_type;
2183       cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));
2184       if (cc &amp;&amp; cc-&gt;instance_type != restore_type)
2185         {
2186           closure = cc-&gt;closure;
2187           chain_type = cc-&gt;instance_type;
2188         }
2189     }
2190       else
2191     g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);
2192     }
2193   else
2194     g_warning (&quot;%s: no signal is currently being emitted for instance &#39;%p&#39;&quot;, G_STRLOC, instance);
2195 
2196   if (closure)
2197     {
2198       GValue *instance_and_params;
2199       GType signal_return_type;
2200       GValue *param_values;
2201       va_list var_args;
2202       guint i;
2203 
2204       va_start (var_args, instance);
2205 
2206       signal_return_type = node-&gt;return_type;
2207       instance_and_params = g_alloca (sizeof (GValue) * (n_params + 1));
2208       memset (instance_and_params, 0, sizeof (GValue) * (n_params + 1));
2209       param_values = instance_and_params + 1;
2210 
2211       for (i = 0; i &lt; node-&gt;n_params; i++)
2212         {
2213           gchar *error;
2214           GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
2215           gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
2216 
2217           SIGNAL_UNLOCK ();
2218           G_VALUE_COLLECT_INIT (param_values + i, ptype,
2219                 var_args,
2220                 static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
2221                 &amp;error);
2222           if (error)
2223             {
2224               g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
2225               g_free (error);
2226 
2227               /* we purposely leak the value here, it might not be
2228                * in a sane state if an error condition occoured
2229                */
2230               while (i--)
2231                 g_value_unset (param_values + i);
2232 
2233               va_end (var_args);
2234               return;
2235             }
2236           SIGNAL_LOCK ();
2237         }
2238 
2239       SIGNAL_UNLOCK ();
2240       instance_and_params-&gt;g_type = 0;
2241       g_value_init_from_instance (instance_and_params, instance);
2242       SIGNAL_LOCK ();
2243 
2244       emission-&gt;chain_type = chain_type;
2245       SIGNAL_UNLOCK ();
2246 
2247       if (signal_return_type == G_TYPE_NONE)
2248         {
2249           g_closure_invoke (closure,
2250                             NULL,
2251                             n_params + 1,
2252                             instance_and_params,
2253                             &amp;emission-&gt;ihint);
2254         }
2255       else
2256         {
2257           GValue return_value = G_VALUE_INIT;
2258           gchar *error = NULL;
2259           GType rtype = signal_return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
2260           gboolean static_scope = signal_return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
2261 
2262           g_value_init (&amp;return_value, rtype);
2263 
2264           g_closure_invoke (closure,
2265                             &amp;return_value,
2266                             n_params + 1,
2267                             instance_and_params,
2268                             &amp;emission-&gt;ihint);
2269 
2270           G_VALUE_LCOPY (&amp;return_value,
2271                          var_args,
2272                          static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
2273                          &amp;error);
2274           if (!error)
2275             {
2276               g_value_unset (&amp;return_value);
2277             }
2278           else
2279             {
2280               g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
2281               g_free (error);
2282 
2283               /* we purposely leak the value here, it might not be
2284                * in a sane state if an error condition occurred
2285                */
2286             }
2287         }
2288 
2289       for (i = 0; i &lt; n_params; i++)
2290         g_value_unset (param_values + i);
2291       g_value_unset (instance_and_params);
2292 
2293       va_end (var_args);
2294 
2295       SIGNAL_LOCK ();
2296       emission-&gt;chain_type = restore_type;
2297     }
2298   SIGNAL_UNLOCK ();
2299 }
2300 
2301 /**
2302  * g_signal_get_invocation_hint:
2303  * @instance: (type GObject.Object): the instance to query
2304  *
2305  * Returns the invocation hint of the innermost signal emission of instance.
2306  *
2307  * Returns: (transfer none): the invocation hint of the innermost signal  emission.
2308  */
2309 GSignalInvocationHint*
2310 g_signal_get_invocation_hint (gpointer instance)
2311 {
2312   Emission *emission = NULL;
2313 
2314   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), NULL);
2315 
2316   SIGNAL_LOCK ();
2317   emission = emission_find_innermost (instance);
2318   SIGNAL_UNLOCK ();
2319 
2320   return emission ? &amp;emission-&gt;ihint : NULL;
2321 }
2322 
2323 /**
2324  * g_signal_connect_closure_by_id:
2325  * @instance: (type GObject.Object): the instance to connect to.
2326  * @signal_id: the id of the signal.
2327  * @detail: the detail.
2328  * @closure: the closure to connect.
2329  * @after: whether the handler should be called before or after the
2330  *  default handler of the signal.
2331  *
2332  * Connects a closure to a signal for a particular object.
2333  *
2334  * Returns: the handler ID (always greater than 0 for successful connections)
2335  */
2336 gulong
2337 g_signal_connect_closure_by_id (gpointer  instance,
2338                 guint     signal_id,
2339                 GQuark    detail,
2340                 GClosure *closure,
2341                 gboolean  after)
2342 {
2343   SignalNode *node;
2344   gulong handler_seq_no = 0;
2345 
2346   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2347   g_return_val_if_fail (signal_id &gt; 0, 0);
2348   g_return_val_if_fail (closure != NULL, 0);
2349 
2350   SIGNAL_LOCK ();
2351   node = LOOKUP_SIGNAL_NODE (signal_id);
2352   if (node)
2353     {
2354       if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
2355     g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);
2356       else if (!g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
2357     g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
2358       else
2359     {
2360       Handler *handler = handler_new (signal_id, instance, after);
2361 
2362       handler_seq_no = handler-&gt;sequential_number;
2363       handler-&gt;detail = detail;
2364       handler-&gt;closure = g_closure_ref (closure);
2365       g_closure_sink (closure);
2366       add_invalid_closure_notify (handler, instance);
2367       handler_insert (signal_id, instance, handler);
2368       if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))
2369         {
2370           g_closure_set_marshal (closure, node-&gt;c_marshaller);
2371           if (node-&gt;va_marshaller)
2372         _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);
2373         }
2374     }
2375     }
2376   else
2377     g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
2378   SIGNAL_UNLOCK ();
2379 
2380   return handler_seq_no;
2381 }
2382 
2383 /**
2384  * g_signal_connect_closure:
2385  * @instance: (type GObject.Object): the instance to connect to.
2386  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
2387  * @closure: the closure to connect.
2388  * @after: whether the handler should be called before or after the
2389  *  default handler of the signal.
2390  *
2391  * Connects a closure to a signal for a particular object.
2392  *
2393  * Returns: the handler ID (always greater than 0 for successful connections)
2394  */
2395 gulong
2396 g_signal_connect_closure (gpointer     instance,
2397               const gchar *detailed_signal,
2398               GClosure    *closure,
2399               gboolean     after)
2400 {
2401   guint signal_id;
2402   gulong handler_seq_no = 0;
2403   GQuark detail = 0;
2404   GType itype;
2405 
2406   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2407   g_return_val_if_fail (detailed_signal != NULL, 0);
2408   g_return_val_if_fail (closure != NULL, 0);
2409 
2410   SIGNAL_LOCK ();
2411   itype = G_TYPE_FROM_INSTANCE (instance);
2412   signal_id = signal_parse_name (detailed_signal, itype, &amp;detail, TRUE);
2413   if (signal_id)
2414     {
2415       SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
2416 
2417       if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
2418     g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);
2419       else if (!g_type_is_a (itype, node-&gt;itype))
2420         g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
2421                    G_STRLOC, detailed_signal, instance, g_type_name (itype));
2422       else
2423     {
2424       Handler *handler = handler_new (signal_id, instance, after);
2425 
2426       handler_seq_no = handler-&gt;sequential_number;
2427       handler-&gt;detail = detail;
2428       handler-&gt;closure = g_closure_ref (closure);
2429       g_closure_sink (closure);
2430       add_invalid_closure_notify (handler, instance);
2431       handler_insert (signal_id, instance, handler);
2432       if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))
2433         {
2434           g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);
2435           if (node-&gt;va_marshaller)
2436         _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);
2437         }
2438     }
2439     }
2440   else
2441     g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
2442                G_STRLOC, detailed_signal, instance, g_type_name (itype));
2443   SIGNAL_UNLOCK ();
2444 
2445   return handler_seq_no;
2446 }
2447 
2448 static void
2449 node_check_deprecated (const SignalNode *node)
2450 {
2451   static const gchar * g_enable_diagnostic = NULL;
2452 
2453   if (G_UNLIKELY (!g_enable_diagnostic))
2454     {
2455       g_enable_diagnostic = g_getenv (&quot;G_ENABLE_DIAGNOSTIC&quot;);
2456       if (!g_enable_diagnostic)
2457         g_enable_diagnostic = &quot;0&quot;;
2458     }
2459 
2460   if (g_enable_diagnostic[0] == &#39;1&#39;)
2461     {
2462       if (node-&gt;flags &amp; G_SIGNAL_DEPRECATED)
2463         {
2464           g_warning (&quot;The signal %s::%s is deprecated and shouldn&#39;t be used &quot;
2465                      &quot;anymore. It will be removed in a future version.&quot;,
2466                      type_debug_name (node-&gt;itype), node-&gt;name);
2467         }
2468     }
2469 }
2470 
2471 /**
2472  * g_signal_connect_data:
2473  * @instance: (type GObject.Object): the instance to connect to.
2474  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
2475  * @c_handler: the #GCallback to connect.
2476  * @data: data to pass to @c_handler calls.
2477  * @destroy_data: a #GClosureNotify for @data.
2478  * @connect_flags: a combination of #GConnectFlags.
2479  *
2480  * Connects a #GCallback function to a signal for a particular object. Similar
2481  * to g_signal_connect(), but allows to provide a #GClosureNotify for the data
2482  * which will be called when the signal handler is disconnected and no longer
2483  * used. Specify @connect_flags if you need `..._after()` or
2484  * `..._swapped()` variants of this function.
2485  *
2486  * Returns: the handler ID (always greater than 0 for successful connections)
2487  */
2488 gulong
2489 g_signal_connect_data (gpointer       instance,
2490                const gchar   *detailed_signal,
2491                GCallback      c_handler,
2492                gpointer       data,
2493                GClosureNotify destroy_data,
2494                GConnectFlags  connect_flags)
2495 {
2496   guint signal_id;
2497   gulong handler_seq_no = 0;
2498   GQuark detail = 0;
2499   GType itype;
2500   gboolean swapped, after;
2501 
2502   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2503   g_return_val_if_fail (detailed_signal != NULL, 0);
2504   g_return_val_if_fail (c_handler != NULL, 0);
2505 
2506   swapped = (connect_flags &amp; G_CONNECT_SWAPPED) != FALSE;
2507   after = (connect_flags &amp; G_CONNECT_AFTER) != FALSE;
2508 
2509   SIGNAL_LOCK ();
2510   itype = G_TYPE_FROM_INSTANCE (instance);
2511   signal_id = signal_parse_name (detailed_signal, itype, &amp;detail, TRUE);
2512   if (signal_id)
2513     {
2514       SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
2515 
2516       node_check_deprecated (node);
2517 
2518       if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
2519     g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);
2520       else if (!g_type_is_a (itype, node-&gt;itype))
2521         g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
2522                    G_STRLOC, detailed_signal, instance, g_type_name (itype));
2523       else
2524     {
2525       Handler *handler = handler_new (signal_id, instance, after);
2526 
2527       handler_seq_no = handler-&gt;sequential_number;
2528       handler-&gt;detail = detail;
2529       handler-&gt;closure = g_closure_ref ((swapped ? g_cclosure_new_swap : g_cclosure_new) (c_handler, data, destroy_data));
2530       g_closure_sink (handler-&gt;closure);
2531       handler_insert (signal_id, instance, handler);
2532       if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))
2533         {
2534           g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);
2535           if (node-&gt;va_marshaller)
2536         _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);
2537         }
2538         }
2539     }
2540   else
2541     g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
2542                G_STRLOC, detailed_signal, instance, g_type_name (itype));
2543   SIGNAL_UNLOCK ();
2544 
2545   return handler_seq_no;
2546 }
2547 
2548 /**
2549  * g_signal_handler_block:
2550  * @instance: (type GObject.Object): The instance to block the signal handler of.
2551  * @handler_id: Handler id of the handler to be blocked.
2552  *
2553  * Blocks a handler of an instance so it will not be called during any
2554  * signal emissions unless it is unblocked again. Thus &quot;blocking&quot; a
2555  * signal handler means to temporarily deactive it, a signal handler
2556  * has to be unblocked exactly the same amount of times it has been
2557  * blocked before to become active again.
2558  *
2559  * The @handler_id has to be a valid signal handler id, connected to a
2560  * signal of @instance.
2561  */
2562 void
2563 g_signal_handler_block (gpointer instance,
2564                         gulong   handler_id)
2565 {
2566   Handler *handler;
2567 
2568   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2569   g_return_if_fail (handler_id &gt; 0);
2570 
2571   SIGNAL_LOCK ();
2572   handler = handler_lookup (instance, handler_id, NULL, NULL);
2573   if (handler)
2574     {
2575 #ifndef G_DISABLE_CHECKS
2576       if (handler-&gt;block_count &gt;= HANDLER_MAX_BLOCK_COUNT - 1)
2577         g_error (G_STRLOC &quot;: handler block_count overflow, %s&quot;, REPORT_BUG);
2578 #endif
2579       handler-&gt;block_count += 1;
2580     }
2581   else
2582     g_warning (&quot;%s: instance &#39;%p&#39; has no handler with id &#39;%lu&#39;&quot;, G_STRLOC, instance, handler_id);
2583   SIGNAL_UNLOCK ();
2584 }
2585 
2586 /**
2587  * g_signal_handler_unblock:
2588  * @instance: (type GObject.Object): The instance to unblock the signal handler of.
2589  * @handler_id: Handler id of the handler to be unblocked.
2590  *
2591  * Undoes the effect of a previous g_signal_handler_block() call.  A
2592  * blocked handler is skipped during signal emissions and will not be
2593  * invoked, unblocking it (for exactly the amount of times it has been
2594  * blocked before) reverts its &quot;blocked&quot; state, so the handler will be
2595  * recognized by the signal system and is called upon future or
2596  * currently ongoing signal emissions (since the order in which
2597  * handlers are called during signal emissions is deterministic,
2598  * whether the unblocked handler in question is called as part of a
2599  * currently ongoing emission depends on how far that emission has
2600  * proceeded yet).
2601  *
2602  * The @handler_id has to be a valid id of a signal handler that is
2603  * connected to a signal of @instance and is currently blocked.
2604  */
2605 void
2606 g_signal_handler_unblock (gpointer instance,
2607                           gulong   handler_id)
2608 {
2609   Handler *handler;
2610 
2611   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2612   g_return_if_fail (handler_id &gt; 0);
2613 
2614   SIGNAL_LOCK ();
2615   handler = handler_lookup (instance, handler_id, NULL, NULL);
2616   if (handler)
2617     {
2618       if (handler-&gt;block_count)
2619         handler-&gt;block_count -= 1;
2620       else
2621         g_warning (G_STRLOC &quot;: handler &#39;%lu&#39; of instance &#39;%p&#39; is not blocked&quot;, handler_id, instance);
2622     }
2623   else
2624     g_warning (&quot;%s: instance &#39;%p&#39; has no handler with id &#39;%lu&#39;&quot;, G_STRLOC, instance, handler_id);
2625   SIGNAL_UNLOCK ();
2626 }
2627 
2628 /**
2629  * g_signal_handler_disconnect:
2630  * @instance: (type GObject.Object): The instance to remove the signal handler from.
2631  * @handler_id: Handler id of the handler to be disconnected.
2632  *
2633  * Disconnects a handler from an instance so it will not be called during
2634  * any future or currently ongoing emissions of the signal it has been
2635  * connected to. The @handler_id becomes invalid and may be reused.
2636  *
2637  * The @handler_id has to be a valid signal handler id, connected to a
2638  * signal of @instance.
2639  */
2640 void
2641 g_signal_handler_disconnect (gpointer instance,
2642                              gulong   handler_id)
2643 {
2644   Handler *handler;
2645 
2646   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2647   g_return_if_fail (handler_id &gt; 0);
2648 
2649   SIGNAL_LOCK ();
2650   handler = handler_lookup (instance, handler_id, 0, 0);
2651   if (handler)
2652     {
2653       g_hash_table_remove (g_handlers, handler);
2654       handler-&gt;sequential_number = 0;
2655       handler-&gt;block_count = 1;
2656       remove_invalid_closure_notify (handler, instance);
2657       handler_unref_R (handler-&gt;signal_id, instance, handler);
2658     }
2659   else
2660     g_warning (&quot;%s: instance &#39;%p&#39; has no handler with id &#39;%lu&#39;&quot;, G_STRLOC, instance, handler_id);
2661   SIGNAL_UNLOCK ();
2662 }
2663 
2664 /**
2665  * g_signal_handler_is_connected:
2666  * @instance: (type GObject.Object): The instance where a signal handler is sought.
2667  * @handler_id: the handler ID.
2668  *
2669  * Returns whether @handler_id is the ID of a handler connected to @instance.
2670  *
2671  * Returns: whether @handler_id identifies a handler connected to @instance.
2672  */
2673 gboolean
2674 g_signal_handler_is_connected (gpointer instance,
2675                    gulong   handler_id)
2676 {
2677   Handler *handler;
2678   gboolean connected;
2679 
2680   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), FALSE);
2681 
2682   SIGNAL_LOCK ();
2683   handler = handler_lookup (instance, handler_id, NULL, NULL);
2684   connected = handler != NULL;
2685   SIGNAL_UNLOCK ();
2686 
2687   return connected;
2688 }
2689 
2690 /**
2691  * g_signal_handlers_destroy:
2692  * @instance: (type GObject.Object): The instance whose signal handlers are destroyed
2693  *
2694  * Destroy all signal handlers of a type instance. This function is
2695  * an implementation detail of the #GObject dispose implementation,
2696  * and should not be used outside of the type system.
2697  */
2698 void
2699 g_signal_handlers_destroy (gpointer instance)
2700 {
2701   GBSearchArray *hlbsa;
2702 
2703   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2704 
2705   SIGNAL_LOCK ();
2706   hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
2707   if (hlbsa)
2708     {
2709       guint i;
2710 
2711       /* reentrancy caution, delete instance trace first */
2712       g_hash_table_remove (g_handler_list_bsa_ht, instance);
2713 
2714       for (i = 0; i &lt; hlbsa-&gt;n_nodes; i++)
2715         {
2716           HandlerList *hlist = g_bsearch_array_get_nth (hlbsa, &amp;g_signal_hlbsa_bconfig, i);
2717           Handler *handler = hlist-&gt;handlers;
2718 
2719           while (handler)
2720             {
2721               Handler *tmp = handler;
2722 
2723               handler = tmp-&gt;next;
2724               tmp-&gt;block_count = 1;
2725               /* cruel unlink, this works because _all_ handlers vanish */
2726               tmp-&gt;next = NULL;
2727               tmp-&gt;prev = tmp;
2728               if (tmp-&gt;sequential_number)
2729         {
2730                   g_hash_table_remove (g_handlers, tmp);
2731           remove_invalid_closure_notify (tmp, instance);
2732           tmp-&gt;sequential_number = 0;
2733           handler_unref_R (0, NULL, tmp);
2734         }
2735             }
2736         }
2737       g_bsearch_array_free (hlbsa, &amp;g_signal_hlbsa_bconfig);
2738     }
2739   SIGNAL_UNLOCK ();
2740 }
2741 
2742 /**
2743  * g_signal_handler_find:
2744  * @instance: (type GObject.Object): The instance owning the signal handler to be found.
2745  * @mask: Mask indicating which of @signal_id, @detail, @closure, @func
2746  *  and/or @data the handler has to match.
2747  * @signal_id: Signal the handler has to be connected to.
2748  * @detail: Signal detail the handler has to be connected to.
2749  * @closure: (nullable): The closure the handler will invoke.
2750  * @func: The C closure callback of the handler (useless for non-C closures).
2751  * @data: The closure data of the handler&#39;s closure.
2752  *
2753  * Finds the first signal handler that matches certain selection criteria.
2754  * The criteria mask is passed as an OR-ed combination of #GSignalMatchType
2755  * flags, and the criteria values are passed as arguments.
2756  * The match @mask has to be non-0 for successful matches.
2757  * If no handler was found, 0 is returned.
2758  *
2759  * Returns: A valid non-0 signal handler id for a successful match.
2760  */
2761 gulong
2762 g_signal_handler_find (gpointer         instance,
2763                        GSignalMatchType mask,
2764                        guint            signal_id,
2765                GQuark       detail,
2766                        GClosure        *closure,
2767                        gpointer         func,
2768                        gpointer         data)
2769 {
2770   gulong handler_seq_no = 0;
2771 
2772   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2773   g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
2774 
2775   if (mask &amp; G_SIGNAL_MATCH_MASK)
2776     {
2777       HandlerMatch *mlist;
2778 
2779       SIGNAL_LOCK ();
2780       mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, TRUE);
2781       if (mlist)
2782     {
2783       handler_seq_no = mlist-&gt;handler-&gt;sequential_number;
2784       handler_match_free1_R (mlist, instance);
2785     }
2786       SIGNAL_UNLOCK ();
2787     }
2788 
2789   return handler_seq_no;
2790 }
2791 
2792 static guint
2793 signal_handlers_foreach_matched_R (gpointer         instance,
2794                                    GSignalMatchType mask,
2795                                    guint            signal_id,
2796                                    GQuark           detail,
2797                                    GClosure        *closure,
2798                                    gpointer         func,
2799                                    gpointer         data,
2800                    void       (*callback) (gpointer instance,
2801                                    gulong   handler_seq_no))
2802 {
2803   HandlerMatch *mlist;
2804   guint n_handlers = 0;
2805 
2806   mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, FALSE);
2807   while (mlist)
2808     {
2809       n_handlers++;
2810       if (mlist-&gt;handler-&gt;sequential_number)
2811     {
2812       SIGNAL_UNLOCK ();
2813       callback (instance, mlist-&gt;handler-&gt;sequential_number);
2814       SIGNAL_LOCK ();
2815     }
2816       mlist = handler_match_free1_R (mlist, instance);
2817     }
2818 
2819   return n_handlers;
2820 }
2821 
2822 /**
2823  * g_signal_handlers_block_matched:
2824  * @instance: (type GObject.Object): The instance to block handlers from.
2825  * @mask: Mask indicating which of @signal_id, @detail, @closure, @func
2826  *  and/or @data the handlers have to match.
2827  * @signal_id: Signal the handlers have to be connected to.
2828  * @detail: Signal detail the handlers have to be connected to.
2829  * @closure: (nullable): The closure the handlers will invoke.
2830  * @func: The C closure callback of the handlers (useless for non-C closures).
2831  * @data: The closure data of the handlers&#39; closures.
2832  *
2833  * Blocks all handlers on an instance that match a certain selection criteria.
2834  * The criteria mask is passed as an OR-ed combination of #GSignalMatchType
2835  * flags, and the criteria values are passed as arguments.
2836  * Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
2837  * or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
2838  * If no handlers were found, 0 is returned, the number of blocked handlers
2839  * otherwise.
2840  *
2841  * Returns: The number of handlers that matched.
2842  */
2843 guint
2844 g_signal_handlers_block_matched (gpointer         instance,
2845                  GSignalMatchType mask,
2846                  guint            signal_id,
2847                  GQuark           detail,
2848                  GClosure        *closure,
2849                  gpointer         func,
2850                  gpointer         data)
2851 {
2852   guint n_handlers = 0;
2853 
2854   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2855   g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
2856 
2857   if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
2858     {
2859       SIGNAL_LOCK ();
2860       n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
2861                               closure, func, data,
2862                               g_signal_handler_block);
2863       SIGNAL_UNLOCK ();
2864     }
2865 
2866   return n_handlers;
2867 }
2868 
2869 /**
2870  * g_signal_handlers_unblock_matched:
2871  * @instance: (type GObject.Object): The instance to unblock handlers from.
2872  * @mask: Mask indicating which of @signal_id, @detail, @closure, @func
2873  *  and/or @data the handlers have to match.
2874  * @signal_id: Signal the handlers have to be connected to.
2875  * @detail: Signal detail the handlers have to be connected to.
2876  * @closure: (nullable): The closure the handlers will invoke.
2877  * @func: The C closure callback of the handlers (useless for non-C closures).
2878  * @data: The closure data of the handlers&#39; closures.
2879  *
2880  * Unblocks all handlers on an instance that match a certain selection
2881  * criteria. The criteria mask is passed as an OR-ed combination of
2882  * #GSignalMatchType flags, and the criteria values are passed as arguments.
2883  * Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
2884  * or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
2885  * If no handlers were found, 0 is returned, the number of unblocked handlers
2886  * otherwise. The match criteria should not apply to any handlers that are
2887  * not currently blocked.
2888  *
2889  * Returns: The number of handlers that matched.
2890  */
2891 guint
2892 g_signal_handlers_unblock_matched (gpointer         instance,
2893                    GSignalMatchType mask,
2894                    guint            signal_id,
2895                    GQuark           detail,
2896                    GClosure        *closure,
2897                    gpointer         func,
2898                    gpointer         data)
2899 {
2900   guint n_handlers = 0;
2901 
2902   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2903   g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
2904 
2905   if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
2906     {
2907       SIGNAL_LOCK ();
2908       n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
2909                               closure, func, data,
2910                               g_signal_handler_unblock);
2911       SIGNAL_UNLOCK ();
2912     }
2913 
2914   return n_handlers;
2915 }
2916 
2917 /**
2918  * g_signal_handlers_disconnect_matched:
2919  * @instance: (type GObject.Object): The instance to remove handlers from.
2920  * @mask: Mask indicating which of @signal_id, @detail, @closure, @func
2921  *  and/or @data the handlers have to match.
2922  * @signal_id: Signal the handlers have to be connected to.
2923  * @detail: Signal detail the handlers have to be connected to.
2924  * @closure: (nullable): The closure the handlers will invoke.
2925  * @func: The C closure callback of the handlers (useless for non-C closures).
2926  * @data: The closure data of the handlers&#39; closures.
2927  *
2928  * Disconnects all handlers on an instance that match a certain
2929  * selection criteria. The criteria mask is passed as an OR-ed
2930  * combination of #GSignalMatchType flags, and the criteria values are
2931  * passed as arguments.  Passing at least one of the
2932  * %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC or
2933  * %G_SIGNAL_MATCH_DATA match flags is required for successful
2934  * matches.  If no handlers were found, 0 is returned, the number of
2935  * disconnected handlers otherwise.
2936  *
2937  * Returns: The number of handlers that matched.
2938  */
2939 guint
2940 g_signal_handlers_disconnect_matched (gpointer         instance,
2941                       GSignalMatchType mask,
2942                       guint            signal_id,
2943                       GQuark           detail,
2944                       GClosure        *closure,
2945                       gpointer         func,
2946                       gpointer         data)
2947 {
2948   guint n_handlers = 0;
2949 
2950   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2951   g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
2952 
2953   if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
2954     {
2955       SIGNAL_LOCK ();
2956       n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
2957                               closure, func, data,
2958                               g_signal_handler_disconnect);
2959       SIGNAL_UNLOCK ();
2960     }
2961 
2962   return n_handlers;
2963 }
2964 
2965 /**
2966  * g_signal_has_handler_pending:
2967  * @instance: (type GObject.Object): the object whose signal handlers are sought.
2968  * @signal_id: the signal id.
2969  * @detail: the detail.
2970  * @may_be_blocked: whether blocked handlers should count as match.
2971  *
2972  * Returns whether there are any handlers connected to @instance for the
2973  * given signal id and detail.
2974  *
2975  * If @detail is 0 then it will only match handlers that were connected
2976  * without detail.  If @detail is non-zero then it will match handlers
2977  * connected both without detail and with the given detail.  This is
2978  * consistent with how a signal emitted with @detail would be delivered
2979  * to those handlers.
2980  *
2981  * Since 2.46 this also checks for a non-default class closure being
2982  * installed, as this is basically always what you want.
2983  *
2984  * One example of when you might use this is when the arguments to the
2985  * signal are difficult to compute. A class implementor may opt to not
2986  * emit the signal if no one is attached anyway, thus saving the cost
2987  * of building the arguments.
2988  *
2989  * Returns: %TRUE if a handler is connected to the signal, %FALSE
2990  *          otherwise.
2991  */
2992 gboolean
2993 g_signal_has_handler_pending (gpointer instance,
2994                   guint    signal_id,
2995                   GQuark   detail,
2996                   gboolean may_be_blocked)
2997 {
2998   HandlerMatch *mlist;
2999   gboolean has_pending;
3000   SignalNode *node;
3001 
3002   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), FALSE);
3003   g_return_val_if_fail (signal_id &gt; 0, FALSE);
3004 
3005   SIGNAL_LOCK ();
3006 
3007   node = LOOKUP_SIGNAL_NODE (signal_id);
3008   if (detail)
3009     {
3010 #ifndef GSTREAMER_LITE
3011       if (!(node-&gt;flags &amp; G_SIGNAL_DETAILED))
3012 #else // GSTREAMER_LITE
3013       if (node == NULL || !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
3014 #endif // GSTREAMER_LITE
3015     {
3016       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);
3017       SIGNAL_UNLOCK ();
3018       return FALSE;
3019     }
3020     }
3021   mlist = handlers_find (instance,
3022              (G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | (may_be_blocked ? 0 : G_SIGNAL_MATCH_UNBLOCKED)),
3023              signal_id, detail, NULL, NULL, NULL, TRUE);
3024   if (mlist)
3025     {
3026       has_pending = TRUE;
3027       handler_match_free1_R (mlist, instance);
3028     }
3029   else
3030     {
3031       ClassClosure *class_closure = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
3032       if (class_closure != NULL &amp;&amp; class_closure-&gt;instance_type != 0)
3033         has_pending = TRUE;
3034       else
3035     has_pending = FALSE;
3036     }
3037   SIGNAL_UNLOCK ();
3038 
3039   return has_pending;
3040 }
3041 
3042 /**
3043  * g_signal_emitv:
3044  * @instance_and_params: (array): argument list for the signal emission.
3045  *  The first element in the array is a #GValue for the instance the signal
3046  *  is being emitted on. The rest are any arguments to be passed to the signal.
3047  * @signal_id: the signal id
3048  * @detail: the detail
3049  * @return_value: (inout) (optional): Location to
3050  * store the return value of the signal emission. This must be provided if the
3051  * specified signal returns a value, but may be ignored otherwise.
3052  *
3053  * Emits a signal.
3054  *
3055  * Note that g_signal_emitv() doesn&#39;t change @return_value if no handlers are
3056  * connected, in contrast to g_signal_emit() and g_signal_emit_valist().
3057  */
3058 void
3059 g_signal_emitv (const GValue *instance_and_params,
3060                 guint         signal_id,
3061         GQuark        detail,
3062                 GValue       *return_value)
3063 {
3064   gpointer instance;
3065   SignalNode *node;
3066 #ifdef G_ENABLE_DEBUG
3067   const GValue *param_values;
3068   guint i;
3069 #endif
3070 
3071   g_return_if_fail (instance_and_params != NULL);
3072   instance = g_value_peek_pointer (instance_and_params);
3073   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
3074   g_return_if_fail (signal_id &gt; 0);
3075 
3076 #ifdef G_ENABLE_DEBUG
3077   param_values = instance_and_params + 1;
3078 #endif
3079 
3080   SIGNAL_LOCK ();
3081   node = LOOKUP_SIGNAL_NODE (signal_id);
3082   if (!node || !g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
3083     {
3084       g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
3085       SIGNAL_UNLOCK ();
3086       return;
3087     }
3088 #ifdef G_ENABLE_DEBUG
3089   if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
3090     {
3091       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);
3092       SIGNAL_UNLOCK ();
3093       return;
3094     }
3095   for (i = 0; i &lt; node-&gt;n_params; i++)
3096     if (!G_TYPE_CHECK_VALUE_TYPE (param_values + i, node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
3097       {
3098     g_critical (&quot;%s: value for &#39;%s&#39; parameter %u for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,
3099             G_STRLOC,
3100             type_debug_name (node-&gt;param_types[i]),
3101             i,
3102             node-&gt;name,
3103             G_VALUE_TYPE_NAME (param_values + i));
3104     SIGNAL_UNLOCK ();
3105     return;
3106       }
3107   if (node-&gt;return_type != G_TYPE_NONE)
3108     {
3109       if (!return_value)
3110     {
3111       g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is (NULL)&quot;,
3112               G_STRLOC,
3113               type_debug_name (node-&gt;return_type),
3114               node-&gt;name);
3115       SIGNAL_UNLOCK ();
3116       return;
3117     }
3118       else if (!node-&gt;accumulator &amp;&amp; !G_TYPE_CHECK_VALUE_TYPE (return_value, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
3119     {
3120       g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,
3121               G_STRLOC,
3122               type_debug_name (node-&gt;return_type),
3123               node-&gt;name,
3124               G_VALUE_TYPE_NAME (return_value));
3125       SIGNAL_UNLOCK ();
3126       return;
3127     }
3128     }
3129   else
3130     return_value = NULL;
3131 #endif  /* G_ENABLE_DEBUG */
3132 
3133   /* optimize NOP emissions */
3134   if (!node-&gt;single_va_closure_is_valid)
3135     node_update_single_va_closure (node);
3136 
3137   if (node-&gt;single_va_closure != NULL &amp;&amp;
3138       (node-&gt;single_va_closure == SINGLE_VA_CLOSURE_EMPTY_MAGIC ||
3139        _g_closure_is_void (node-&gt;single_va_closure, instance)))
3140     {
3141       HandlerList* hlist = handler_list_lookup (node-&gt;signal_id, instance);
3142       if (hlist == NULL || hlist-&gt;handlers == NULL)
3143     {
3144       /* nothing to do to emit this signal */
3145       SIGNAL_UNLOCK ();
3146       /* g_printerr (&quot;omitting emission of \&quot;%s\&quot;\n&quot;, node-&gt;name); */
3147       return;
3148     }
3149     }
3150 
3151   SIGNAL_UNLOCK ();
3152   signal_emit_unlocked_R (node, detail, instance, return_value, instance_and_params);
3153 }
3154 
3155 static inline gboolean
3156 accumulate (GSignalInvocationHint *ihint,
3157             GValue                *return_accu,
3158         GValue            *handler_return,
3159             SignalAccumulator     *accumulator)
3160 {
3161   gboolean continue_emission;
3162 
3163   if (!accumulator)
3164     return TRUE;
3165 
3166   continue_emission = accumulator-&gt;func (ihint, return_accu, handler_return, accumulator-&gt;data);
3167   g_value_reset (handler_return);
3168 
3169   return continue_emission;
3170 }
3171 
3172 /**
3173  * g_signal_emit_valist: (skip)
3174  * @instance: (type GObject.TypeInstance): the instance the signal is being
3175  *    emitted on.
3176  * @signal_id: the signal id
3177  * @detail: the detail
3178  * @var_args: a list of parameters to be passed to the signal, followed by a
3179  *  location for the return value. If the return type of the signal
3180  *  is #G_TYPE_NONE, the return value location can be omitted.
3181  *
3182  * Emits a signal.
3183  *
3184  * Note that g_signal_emit_valist() resets the return value to the default
3185  * if no handlers are connected, in contrast to g_signal_emitv().
3186  */
3187 void
3188 g_signal_emit_valist (gpointer instance,
3189               guint    signal_id,
3190               GQuark   detail,
3191               va_list  var_args)
3192 {
3193   GValue *instance_and_params;
3194   GType signal_return_type;
3195   GValue *param_values;
3196   SignalNode *node;
3197   guint i, n_params;
3198 
3199   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
3200   g_return_if_fail (signal_id &gt; 0);
3201 
3202   SIGNAL_LOCK ();
3203   node = LOOKUP_SIGNAL_NODE (signal_id);
3204   if (!node || !g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
3205     {
3206       g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
3207       SIGNAL_UNLOCK ();
3208       return;
3209     }
3210 #ifndef G_DISABLE_CHECKS
3211   if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
3212     {
3213       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);
3214       SIGNAL_UNLOCK ();
3215       return;
3216     }
3217 #endif  /* !G_DISABLE_CHECKS */
3218 
3219   if (!node-&gt;single_va_closure_is_valid)
3220     node_update_single_va_closure (node);
3221 
3222   if (node-&gt;single_va_closure != NULL)
3223     {
3224       HandlerList* hlist = handler_list_lookup (node-&gt;signal_id, instance);
3225       Handler *fastpath_handler = NULL;
3226       Handler *l;
3227       GClosure *closure = NULL;
3228       gboolean fastpath = TRUE;
3229       GSignalFlags run_type = G_SIGNAL_RUN_FIRST;
3230 
3231       if (node-&gt;single_va_closure != SINGLE_VA_CLOSURE_EMPTY_MAGIC &amp;&amp;
3232       !_g_closure_is_void (node-&gt;single_va_closure, instance))
3233     {
3234       if (_g_closure_supports_invoke_va (node-&gt;single_va_closure))
3235         {
3236           closure = node-&gt;single_va_closure;
3237           if (node-&gt;single_va_closure_is_after)
3238         run_type = G_SIGNAL_RUN_LAST;
3239           else
3240         run_type = G_SIGNAL_RUN_FIRST;
3241         }
3242       else
3243         fastpath = FALSE;
3244     }
3245 
3246       for (l = hlist ? hlist-&gt;handlers : NULL; fastpath &amp;&amp; l != NULL; l = l-&gt;next)
3247     {
3248       if (!l-&gt;block_count &amp;&amp;
3249           (!l-&gt;detail || l-&gt;detail == detail))
3250         {
3251           if (closure != NULL || !_g_closure_supports_invoke_va (l-&gt;closure))
3252         {
3253           fastpath = FALSE;
3254           break;
3255         }
3256           else
3257         {
3258                   fastpath_handler = l;
3259           closure = l-&gt;closure;
3260           if (l-&gt;after)
3261             run_type = G_SIGNAL_RUN_LAST;
3262           else
3263             run_type = G_SIGNAL_RUN_FIRST;
3264         }
3265         }
3266     }
3267 
3268       if (fastpath &amp;&amp; closure == NULL &amp;&amp; node-&gt;return_type == G_TYPE_NONE)
3269     {
3270       SIGNAL_UNLOCK ();
3271       return;
3272     }
3273 
3274       /* Don&#39;t allow no-recurse emission as we might have to restart, which means
3275      we will run multiple handlers and thus must ref all arguments */
3276       if (closure != NULL &amp;&amp; (node-&gt;flags &amp; (G_SIGNAL_NO_RECURSE)) != 0)
3277     fastpath = FALSE;
3278 
3279       if (fastpath)
3280     {
3281       SignalAccumulator *accumulator;
3282       Emission emission;
3283       GValue *return_accu, accu = G_VALUE_INIT;
3284       guint signal_id;
3285       GType instance_type = G_TYPE_FROM_INSTANCE (instance);
3286       GValue emission_return = G_VALUE_INIT;
3287           GType rtype = node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
3288       gboolean static_scope = node-&gt;return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
3289 
3290       signal_id = node-&gt;signal_id;
3291       accumulator = node-&gt;accumulator;
3292       if (rtype == G_TYPE_NONE)
3293         return_accu = NULL;
3294       else if (accumulator)
3295         return_accu = &amp;accu;
3296       else
3297         return_accu = &amp;emission_return;
3298 
3299       emission.instance = instance;
3300       emission.ihint.signal_id = signal_id;
3301       emission.ihint.detail = detail;
3302       emission.ihint.run_type = run_type;
3303       emission.state = EMISSION_RUN;
3304       emission.chain_type = instance_type;
3305       emission_push (&amp;emission);
3306 
3307           if (fastpath_handler)
3308             handler_ref (fastpath_handler);
3309 
3310       SIGNAL_UNLOCK ();
3311 
3312       TRACE(GOBJECT_SIGNAL_EMIT(signal_id, detail, instance, instance_type));
3313 
3314       if (rtype != G_TYPE_NONE)
3315         g_value_init (&amp;emission_return, rtype);
3316 
3317       if (accumulator)
3318         g_value_init (&amp;accu, rtype);
3319 
3320       if (closure != NULL)
3321         {
3322           g_object_ref (instance);
3323           _g_closure_invoke_va (closure,
3324                     return_accu,
3325                     instance,
3326                     var_args,
3327                     node-&gt;n_params,
3328                     node-&gt;param_types);
3329           accumulate (&amp;emission.ihint, &amp;emission_return, &amp;accu, accumulator);
3330         }
3331 
3332       SIGNAL_LOCK ();
3333 
3334       emission.chain_type = G_TYPE_NONE;
3335       emission_pop (&amp;emission);
3336 
3337           if (fastpath_handler)
3338             handler_unref_R (signal_id, instance, fastpath_handler);
3339 
3340       SIGNAL_UNLOCK ();
3341 
3342       if (accumulator)
3343         g_value_unset (&amp;accu);
3344 
3345       if (rtype != G_TYPE_NONE)
3346         {
3347           gchar *error = NULL;
3348           for (i = 0; i &lt; node-&gt;n_params; i++)
3349         {
3350           GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
3351           G_VALUE_COLLECT_SKIP (ptype, var_args);
3352         }
3353 
3354           G_VALUE_LCOPY (&amp;emission_return,
3355                  var_args,
3356                  static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
3357                  &amp;error);
3358           if (!error)
3359         g_value_unset (&amp;emission_return);
3360           else
3361         {
3362           g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
3363           g_free (error);
3364           /* we purposely leak the value here, it might not be
3365            * in a sane state if an error condition occurred
3366            */
3367         }
3368         }
3369 
3370       TRACE(GOBJECT_SIGNAL_EMIT_END(signal_id, detail, instance, instance_type));
3371 
3372           if (closure != NULL)
3373             g_object_unref (instance);
3374 
3375       return;
3376     }
3377     }
3378   SIGNAL_UNLOCK ();
3379 
3380   n_params = node-&gt;n_params;
3381   signal_return_type = node-&gt;return_type;
3382   instance_and_params = g_alloca (sizeof (GValue) * (n_params + 1));
3383   memset (instance_and_params, 0, sizeof (GValue) * (n_params + 1));
3384   param_values = instance_and_params + 1;
3385 
3386   for (i = 0; i &lt; node-&gt;n_params; i++)
3387     {
3388       gchar *error;
3389       GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
3390       gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
3391 
3392       G_VALUE_COLLECT_INIT (param_values + i, ptype,
3393                 var_args,
3394                 static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
3395                 &amp;error);
3396       if (error)
3397     {
3398       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
3399       g_free (error);
3400 
3401       /* we purposely leak the value here, it might not be
3402        * in a sane state if an error condition occoured
3403        */
3404       while (i--)
3405         g_value_unset (param_values + i);
3406 
3407       return;
3408     }
3409     }
3410 
3411   instance_and_params-&gt;g_type = 0;
3412   g_value_init_from_instance (instance_and_params, instance);
3413   if (signal_return_type == G_TYPE_NONE)
3414     signal_emit_unlocked_R (node, detail, instance, NULL, instance_and_params);
3415   else
3416     {
3417       GValue return_value = G_VALUE_INIT;
3418       gchar *error = NULL;
3419       GType rtype = signal_return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
3420       gboolean static_scope = signal_return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
3421 
3422       g_value_init (&amp;return_value, rtype);
3423 
3424       signal_emit_unlocked_R (node, detail, instance, &amp;return_value, instance_and_params);
3425 
3426       G_VALUE_LCOPY (&amp;return_value,
3427              var_args,
3428              static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
3429              &amp;error);
3430       if (!error)
3431     g_value_unset (&amp;return_value);
3432       else
3433     {
3434       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
3435       g_free (error);
3436 
3437       /* we purposely leak the value here, it might not be
3438        * in a sane state if an error condition occurred
3439        */
3440     }
3441     }
3442   for (i = 0; i &lt; n_params; i++)
3443     g_value_unset (param_values + i);
3444   g_value_unset (instance_and_params);
3445 }
3446 
3447 /**
3448  * g_signal_emit:
3449  * @instance: (type GObject.Object): the instance the signal is being emitted on.
3450  * @signal_id: the signal id
3451  * @detail: the detail
3452  * @...: parameters to be passed to the signal, followed by a
3453  *  location for the return value. If the return type of the signal
3454  *  is #G_TYPE_NONE, the return value location can be omitted.
3455  *
3456  * Emits a signal.
3457  *
3458  * Note that g_signal_emit() resets the return value to the default
3459  * if no handlers are connected, in contrast to g_signal_emitv().
3460  */
3461 void
3462 g_signal_emit (gpointer instance,
3463            guint    signal_id,
3464            GQuark   detail,
3465            ...)
3466 {
3467   va_list var_args;
3468 
3469   va_start (var_args, detail);
3470   g_signal_emit_valist (instance, signal_id, detail, var_args);
3471   va_end (var_args);
3472 }
3473 
3474 /**
3475  * g_signal_emit_by_name:
3476  * @instance: (type GObject.Object): the instance the signal is being emitted on.
3477  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
3478  * @...: parameters to be passed to the signal, followed by a
3479  *  location for the return value. If the return type of the signal
3480  *  is #G_TYPE_NONE, the return value location can be omitted.
3481  *
3482  * Emits a signal.
3483  *
3484  * Note that g_signal_emit_by_name() resets the return value to the default
3485  * if no handlers are connected, in contrast to g_signal_emitv().
3486  */
3487 void
3488 g_signal_emit_by_name (gpointer     instance,
3489                const gchar *detailed_signal,
3490                ...)
3491 {
3492   GQuark detail = 0;
3493   guint signal_id;
3494   GType itype;
3495 
3496   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
3497   g_return_if_fail (detailed_signal != NULL);
3498 
3499   itype = G_TYPE_FROM_INSTANCE (instance);
3500 
3501   SIGNAL_LOCK ();
3502   signal_id = signal_parse_name (detailed_signal, itype, &amp;detail, TRUE);
3503   SIGNAL_UNLOCK ();
3504 
3505   if (signal_id)
3506     {
3507       va_list var_args;
3508 
3509       va_start (var_args, detailed_signal);
3510       g_signal_emit_valist (instance, signal_id, detail, var_args);
3511       va_end (var_args);
3512     }
3513   else
3514     g_warning (&quot;%s: signal name &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
3515                G_STRLOC, detailed_signal, instance, g_type_name (itype));
3516 }
3517 
3518 static gboolean
3519 signal_emit_unlocked_R (SignalNode   *node,
3520             GQuark        detail,
3521                         gpointer      instance,
3522             GValue       *emission_return,
3523                         const GValue *instance_and_params)
3524 {
3525   SignalAccumulator *accumulator;
3526   Emission emission;
3527   GClosure *class_closure;
3528   HandlerList *hlist;
3529   Handler *handler_list = NULL;
3530   GValue *return_accu, accu = G_VALUE_INIT;
3531   guint signal_id;
3532   gulong max_sequential_handler_number;
3533   gboolean return_value_altered = FALSE;
3534 
3535   TRACE(GOBJECT_SIGNAL_EMIT(node-&gt;signal_id, detail, instance, G_TYPE_FROM_INSTANCE (instance)));
3536 
3537   SIGNAL_LOCK ();
3538   signal_id = node-&gt;signal_id;
3539 
3540   if (node-&gt;flags &amp; G_SIGNAL_NO_RECURSE)
3541     {
3542       Emission *node = emission_find (signal_id, detail, instance);
3543 
3544       if (node)
3545     {
3546       node-&gt;state = EMISSION_RESTART;
3547       SIGNAL_UNLOCK ();
3548       return return_value_altered;
3549     }
3550     }
3551   accumulator = node-&gt;accumulator;
3552   if (accumulator)
3553     {
3554       SIGNAL_UNLOCK ();
3555       g_value_init (&amp;accu, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);
3556       return_accu = &amp;accu;
3557       SIGNAL_LOCK ();
3558     }
3559   else
3560     return_accu = emission_return;
3561   emission.instance = instance;
3562   emission.ihint.signal_id = node-&gt;signal_id;
3563   emission.ihint.detail = detail;
3564   emission.ihint.run_type = 0;
3565   emission.state = 0;
3566   emission.chain_type = G_TYPE_NONE;
3567   emission_push (&amp;emission);
3568   class_closure = signal_lookup_closure (node, instance);
3569 
3570  EMIT_RESTART:
3571 
3572   if (handler_list)
3573     handler_unref_R (signal_id, instance, handler_list);
3574   max_sequential_handler_number = g_handler_sequential_number;
3575   hlist = handler_list_lookup (signal_id, instance);
3576   handler_list = hlist ? hlist-&gt;handlers : NULL;
3577   if (handler_list)
3578     handler_ref (handler_list);
3579 
3580   emission.ihint.run_type = G_SIGNAL_RUN_FIRST;
3581 
3582   if ((node-&gt;flags &amp; G_SIGNAL_RUN_FIRST) &amp;&amp; class_closure)
3583     {
3584       emission.state = EMISSION_RUN;
3585 
3586       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
3587       SIGNAL_UNLOCK ();
3588       g_closure_invoke (class_closure,
3589             return_accu,
3590             node-&gt;n_params + 1,
3591             instance_and_params,
3592             &amp;emission.ihint);
3593       if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
3594       emission.state == EMISSION_RUN)
3595     emission.state = EMISSION_STOP;
3596       SIGNAL_LOCK ();
3597       emission.chain_type = G_TYPE_NONE;
3598       return_value_altered = TRUE;
3599 
3600       if (emission.state == EMISSION_STOP)
3601     goto EMIT_CLEANUP;
3602       else if (emission.state == EMISSION_RESTART)
3603     goto EMIT_RESTART;
3604     }
3605 
3606   if (node-&gt;emission_hooks)
3607     {
3608       gboolean need_destroy, was_in_call, may_recurse = TRUE;
3609       GHook *hook;
3610 
3611       emission.state = EMISSION_HOOK;
3612       hook = g_hook_first_valid (node-&gt;emission_hooks, may_recurse);
3613       while (hook)
3614     {
3615       SignalHook *signal_hook = SIGNAL_HOOK (hook);
3616 
3617       if (!signal_hook-&gt;detail || signal_hook-&gt;detail == detail)
3618         {
3619           GSignalEmissionHook hook_func = (GSignalEmissionHook) hook-&gt;func;
3620 
3621           was_in_call = G_HOOK_IN_CALL (hook);
3622           hook-&gt;flags |= G_HOOK_FLAG_IN_CALL;
3623               SIGNAL_UNLOCK ();
3624           need_destroy = !hook_func (&amp;emission.ihint, node-&gt;n_params + 1, instance_and_params, hook-&gt;data);
3625           SIGNAL_LOCK ();
3626           if (!was_in_call)
3627         hook-&gt;flags &amp;= ~G_HOOK_FLAG_IN_CALL;
3628           if (need_destroy)
3629         g_hook_destroy_link (node-&gt;emission_hooks, hook);
3630         }
3631       hook = g_hook_next_valid (node-&gt;emission_hooks, hook, may_recurse);
3632     }
3633 
3634       if (emission.state == EMISSION_RESTART)
3635     goto EMIT_RESTART;
3636     }
3637 
3638   if (handler_list)
3639     {
3640       Handler *handler = handler_list;
3641 
3642       emission.state = EMISSION_RUN;
3643       handler_ref (handler);
3644       do
3645     {
3646       Handler *tmp;
3647 
3648       if (handler-&gt;after)
3649         {
3650           handler_unref_R (signal_id, instance, handler_list);
3651           handler_list = handler;
3652           break;
3653         }
3654       else if (!handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;
3655            handler-&gt;sequential_number &lt; max_sequential_handler_number)
3656         {
3657           SIGNAL_UNLOCK ();
3658           g_closure_invoke (handler-&gt;closure,
3659                 return_accu,
3660                 node-&gt;n_params + 1,
3661                 instance_and_params,
3662                 &amp;emission.ihint);
3663           if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
3664           emission.state == EMISSION_RUN)
3665         emission.state = EMISSION_STOP;
3666           SIGNAL_LOCK ();
3667           return_value_altered = TRUE;
3668 
3669           tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;
3670         }
3671       else
3672         tmp = handler-&gt;next;
3673 
3674       if (tmp)
3675         handler_ref (tmp);
3676       handler_unref_R (signal_id, instance, handler_list);
3677       handler_list = handler;
3678       handler = tmp;
3679     }
3680       while (handler);
3681 
3682       if (emission.state == EMISSION_STOP)
3683     goto EMIT_CLEANUP;
3684       else if (emission.state == EMISSION_RESTART)
3685     goto EMIT_RESTART;
3686     }
3687 
3688   emission.ihint.run_type = G_SIGNAL_RUN_LAST;
3689 
3690   if ((node-&gt;flags &amp; G_SIGNAL_RUN_LAST) &amp;&amp; class_closure)
3691     {
3692       emission.state = EMISSION_RUN;
3693 
3694       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
3695       SIGNAL_UNLOCK ();
3696       g_closure_invoke (class_closure,
3697             return_accu,
3698             node-&gt;n_params + 1,
3699             instance_and_params,
3700             &amp;emission.ihint);
3701       if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
3702       emission.state == EMISSION_RUN)
3703     emission.state = EMISSION_STOP;
3704       SIGNAL_LOCK ();
3705       emission.chain_type = G_TYPE_NONE;
3706       return_value_altered = TRUE;
3707 
3708       if (emission.state == EMISSION_STOP)
3709     goto EMIT_CLEANUP;
3710       else if (emission.state == EMISSION_RESTART)
3711     goto EMIT_RESTART;
3712     }
3713 
3714   if (handler_list)
3715     {
3716       Handler *handler = handler_list;
3717 
3718       emission.state = EMISSION_RUN;
3719       handler_ref (handler);
3720       do
3721     {
3722       Handler *tmp;
3723 
3724       if (handler-&gt;after &amp;&amp; !handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;
3725           handler-&gt;sequential_number &lt; max_sequential_handler_number)
3726         {
3727           SIGNAL_UNLOCK ();
3728           g_closure_invoke (handler-&gt;closure,
3729                 return_accu,
3730                 node-&gt;n_params + 1,
3731                 instance_and_params,
3732                 &amp;emission.ihint);
3733           if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
3734           emission.state == EMISSION_RUN)
3735         emission.state = EMISSION_STOP;
3736           SIGNAL_LOCK ();
3737           return_value_altered = TRUE;
3738 
3739           tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;
3740         }
3741       else
3742         tmp = handler-&gt;next;
3743 
3744       if (tmp)
3745         handler_ref (tmp);
3746       handler_unref_R (signal_id, instance, handler);
3747       handler = tmp;
3748     }
3749       while (handler);
3750 
3751       if (emission.state == EMISSION_STOP)
3752     goto EMIT_CLEANUP;
3753       else if (emission.state == EMISSION_RESTART)
3754     goto EMIT_RESTART;
3755     }
3756 
3757  EMIT_CLEANUP:
3758 
3759   emission.ihint.run_type = G_SIGNAL_RUN_CLEANUP;
3760 
3761   if ((node-&gt;flags &amp; G_SIGNAL_RUN_CLEANUP) &amp;&amp; class_closure)
3762     {
3763       gboolean need_unset = FALSE;
3764 
3765       emission.state = EMISSION_STOP;
3766 
3767       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
3768       SIGNAL_UNLOCK ();
3769       if (node-&gt;return_type != G_TYPE_NONE &amp;&amp; !accumulator)
3770     {
3771       g_value_init (&amp;accu, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);
3772       need_unset = TRUE;
3773     }
3774       g_closure_invoke (class_closure,
3775             node-&gt;return_type != G_TYPE_NONE ? &amp;accu : NULL,
3776             node-&gt;n_params + 1,
3777             instance_and_params,
3778             &amp;emission.ihint);
3779       if (need_unset)
3780     g_value_unset (&amp;accu);
3781       SIGNAL_LOCK ();
3782       emission.chain_type = G_TYPE_NONE;
3783 
3784       if (emission.state == EMISSION_RESTART)
3785     goto EMIT_RESTART;
3786     }
3787 
3788   if (handler_list)
3789     handler_unref_R (signal_id, instance, handler_list);
3790 
3791   emission_pop (&amp;emission);
3792   SIGNAL_UNLOCK ();
3793   if (accumulator)
3794     g_value_unset (&amp;accu);
3795 
3796   TRACE(GOBJECT_SIGNAL_EMIT_END(node-&gt;signal_id, detail, instance, G_TYPE_FROM_INSTANCE (instance)));
3797 
3798   return return_value_altered;
3799 }
3800 
3801 static void
3802 add_invalid_closure_notify (Handler  *handler,
3803                 gpointer  instance)
3804 {
3805   g_closure_add_invalidate_notifier (handler-&gt;closure, instance, invalid_closure_notify);
3806   handler-&gt;has_invalid_closure_notify = 1;
3807 }
3808 
3809 static void
3810 remove_invalid_closure_notify (Handler  *handler,
3811                    gpointer  instance)
3812 {
3813   if (handler-&gt;has_invalid_closure_notify)
3814     {
3815       g_closure_remove_invalidate_notifier (handler-&gt;closure, instance, invalid_closure_notify);
3816       handler-&gt;has_invalid_closure_notify = 0;
3817     }
3818 }
3819 
3820 static void
3821 invalid_closure_notify (gpointer  instance,
3822                 GClosure *closure)
3823 {
3824   Handler *handler;
3825   guint signal_id;
3826 
3827   SIGNAL_LOCK ();
3828 
3829   handler = handler_lookup (instance, 0, closure, &amp;signal_id);
3830 #ifdef GSTREAMER_LITE
3831   if (handler == NULL)
3832     return;
3833 #endif // GSTREAMER_LITE
3834   /* See https://bugzilla.gnome.org/show_bug.cgi?id=730296 for discussion about this... */
3835   g_assert (handler != NULL);
3836   g_assert (handler-&gt;closure == closure);
3837 
3838   handler-&gt;sequential_number = 0;
3839   handler-&gt;block_count = 1;
3840   handler_unref_R (signal_id, instance, handler);
3841 
3842   SIGNAL_UNLOCK ();
3843 }
3844 
3845 static const gchar*
3846 type_debug_name (GType type)
3847 {
3848   if (type)
3849     {
3850       const char *name = g_type_name (type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);
3851       return name ? name : &quot;&lt;unknown&gt;&quot;;
3852     }
3853   else
3854     return &quot;&lt;invalid&gt;&quot;;
3855 }
3856 
3857 /**
3858  * g_signal_accumulator_true_handled:
3859  * @ihint: standard #GSignalAccumulator parameter
3860  * @return_accu: standard #GSignalAccumulator parameter
3861  * @handler_return: standard #GSignalAccumulator parameter
3862  * @dummy: standard #GSignalAccumulator parameter
3863  *
3864  * A predefined #GSignalAccumulator for signals that return a
3865  * boolean values. The behavior that this accumulator gives is
3866  * that a return of %TRUE stops the signal emission: no further
3867  * callbacks will be invoked, while a return of %FALSE allows
3868  * the emission to continue. The idea here is that a %TRUE return
3869  * indicates that the callback handled the signal, and no further
3870  * handling is needed.
3871  *
3872  * Since: 2.4
3873  *
3874  * Returns: standard #GSignalAccumulator result
3875  */
3876 gboolean
3877 g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
3878                    GValue                *return_accu,
3879                    const GValue          *handler_return,
3880                    gpointer               dummy)
3881 {
3882   gboolean continue_emission;
3883   gboolean signal_handled;
3884 
3885   signal_handled = g_value_get_boolean (handler_return);
3886   g_value_set_boolean (return_accu, signal_handled);
3887   continue_emission = !signal_handled;
3888 
3889   return continue_emission;
3890 }
3891 
3892 /**
3893  * g_signal_accumulator_first_wins:
3894  * @ihint: standard #GSignalAccumulator parameter
3895  * @return_accu: standard #GSignalAccumulator parameter
3896  * @handler_return: standard #GSignalAccumulator parameter
3897  * @dummy: standard #GSignalAccumulator parameter
3898  *
3899  * A predefined #GSignalAccumulator for signals intended to be used as a
3900  * hook for application code to provide a particular value.  Usually
3901  * only one such value is desired and multiple handlers for the same
3902  * signal don&#39;t make much sense (except for the case of the default
3903  * handler defined in the class structure, in which case you will
3904  * usually want the signal connection to override the class handler).
3905  *
3906  * This accumulator will use the return value from the first signal
3907  * handler that is run as the return value for the signal and not run
3908  * any further handlers (ie: the first handler &quot;wins&quot;).
3909  *
3910  * Returns: standard #GSignalAccumulator result
3911  *
3912  * Since: 2.28
3913  **/
3914 gboolean
3915 g_signal_accumulator_first_wins (GSignalInvocationHint *ihint,
3916                                  GValue                *return_accu,
3917                                  const GValue          *handler_return,
3918                                  gpointer               dummy)
3919 {
3920   g_value_copy (handler_return, return_accu);
3921   return FALSE;
3922 }
    </pre>
  </body>
</html>