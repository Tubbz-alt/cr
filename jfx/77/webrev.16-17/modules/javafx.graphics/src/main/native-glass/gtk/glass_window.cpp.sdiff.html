<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_window.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 367             process_net_wm_property();
 368         } else if (event-&gt;atom == atom_net_wm_frame_extents) {
 369             if (frame_type != TITLED) {
 370                 return;
 371             }
 372 
 373             int top, left, bottom, right;
 374 
 375             if (get_frame_extents_property(&amp;top, &amp;left, &amp;bottom, &amp;right)) {
 376                 if (top + left + bottom + right &gt; 0) {
 377                     geometry.frame_extents_received = true;
 378                     geometry.adjust_w = left + right;
 379                     geometry.adjust_h = top + bottom;
 380                     geometry.view_x = left;
 381                     geometry.view_y = top;
 382 
 383                     save_cached_extents();
 384 
 385                     // set bounds again to set to correct window size that must
 386                     // be the total width and height accounting extents
<span class="line-modified"> 387                     set_bounds(0, 0, false, false, -1, -1, -1, -1);</span>



 388                 }
 389             }
 390         }
 391     }
 392 }
 393 
 394 void WindowContext::process_configure() {
 395     calculate_adjustments();
 396 
 397     gint x, y, w, h, gtk_w, gtk_h;
 398 
 399     gtk_window_get_position(GTK_WINDOW(gtk_widget), &amp;x, &amp;y);
 400     gtk_window_get_size(GTK_WINDOW(gtk_widget), &amp;gtk_w, &amp;gtk_h);
 401     w = gtk_w + geometry.adjust_w;
 402     h = gtk_h + geometry.adjust_h;
 403 
 404     gboolean pos_changed = geometry.current_x != x || geometry.current_y != y;
 405     gboolean size_changed = geometry.current_w != w || geometry.current_h != h
 406                             || geometry.current_cw != gtk_w || geometry.current_ch != gtk_h;
 407 
</pre>
<hr />
<pre>
 954         GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);
 955         gdk_window_set_functions(gdk_window, wmf);
 956 
 957         gtk_window_maximize(GTK_WINDOW(gtk_widget));
 958     } else {
 959         gtk_window_unmaximize(GTK_WINDOW(gtk_widget));
 960     }
 961 }
 962 
 963 void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
 964     calculate_adjustments();
 965 
 966     // newW / newH always content sizes compatible with GTK+
 967     // if window has no decoration, adjustments will be ZERO
 968     int newW = w &gt; 0 ? w - geometry.adjust_w : cw;
 969     int newH = h &gt; 0 ? h - geometry.adjust_h : ch;
 970 
 971     gboolean size_changed = FALSE;
 972     gboolean pos_changed = FALSE;
 973 


 974     if (newW &gt; 0 &amp;&amp; newH &gt; 0) {
 975         size_changed = TRUE;
 976 
 977         geometry.current_cw = newW;
 978         geometry.current_ch = newH;
 979         geometry.current_w = newW + geometry.adjust_w;
 980         geometry.current_h = newH + geometry.adjust_h;
 981 
 982         if (visible_received) {
 983             // update constraints if not resized by the user interface so it will
 984             // let gtk_window_resize succeed, because it&#39;s bound to geometry constraints
 985             apply_geometry();
 986             gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);
 987         } else {
 988             gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);
 989         }
 990     }
 991 
 992     if (xSet || ySet) {
 993         int newX = (xSet) ? x : geometry.current_x;
</pre>
</td>
<td>
<hr />
<pre>
 367             process_net_wm_property();
 368         } else if (event-&gt;atom == atom_net_wm_frame_extents) {
 369             if (frame_type != TITLED) {
 370                 return;
 371             }
 372 
 373             int top, left, bottom, right;
 374 
 375             if (get_frame_extents_property(&amp;top, &amp;left, &amp;bottom, &amp;right)) {
 376                 if (top + left + bottom + right &gt; 0) {
 377                     geometry.frame_extents_received = true;
 378                     geometry.adjust_w = left + right;
 379                     geometry.adjust_h = top + bottom;
 380                     geometry.view_x = left;
 381                     geometry.view_y = top;
 382 
 383                     save_cached_extents();
 384 
 385                     // set bounds again to set to correct window size that must
 386                     // be the total width and height accounting extents
<span class="line-modified"> 387                     // this is ignored if size is &quot;content size&quot; instead of &quot;window size&quot;</span>
<span class="line-added"> 388                     if (geometry.window_size_set) {</span>
<span class="line-added"> 389                         set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);</span>
<span class="line-added"> 390                     }</span>
 391                 }
 392             }
 393         }
 394     }
 395 }
 396 
 397 void WindowContext::process_configure() {
 398     calculate_adjustments();
 399 
 400     gint x, y, w, h, gtk_w, gtk_h;
 401 
 402     gtk_window_get_position(GTK_WINDOW(gtk_widget), &amp;x, &amp;y);
 403     gtk_window_get_size(GTK_WINDOW(gtk_widget), &amp;gtk_w, &amp;gtk_h);
 404     w = gtk_w + geometry.adjust_w;
 405     h = gtk_h + geometry.adjust_h;
 406 
 407     gboolean pos_changed = geometry.current_x != x || geometry.current_y != y;
 408     gboolean size_changed = geometry.current_w != w || geometry.current_h != h
 409                             || geometry.current_cw != gtk_w || geometry.current_ch != gtk_h;
 410 
</pre>
<hr />
<pre>
 957         GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);
 958         gdk_window_set_functions(gdk_window, wmf);
 959 
 960         gtk_window_maximize(GTK_WINDOW(gtk_widget));
 961     } else {
 962         gtk_window_unmaximize(GTK_WINDOW(gtk_widget));
 963     }
 964 }
 965 
 966 void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
 967     calculate_adjustments();
 968 
 969     // newW / newH always content sizes compatible with GTK+
 970     // if window has no decoration, adjustments will be ZERO
 971     int newW = w &gt; 0 ? w - geometry.adjust_w : cw;
 972     int newH = h &gt; 0 ? h - geometry.adjust_h : ch;
 973 
 974     gboolean size_changed = FALSE;
 975     gboolean pos_changed = FALSE;
 976 
<span class="line-added"> 977     geometry.window_size_set = (w &gt; 0 || h &gt; 0);</span>
<span class="line-added"> 978 </span>
 979     if (newW &gt; 0 &amp;&amp; newH &gt; 0) {
 980         size_changed = TRUE;
 981 
 982         geometry.current_cw = newW;
 983         geometry.current_ch = newH;
 984         geometry.current_w = newW + geometry.adjust_w;
 985         geometry.current_h = newH + geometry.adjust_h;
 986 
 987         if (visible_received) {
 988             // update constraints if not resized by the user interface so it will
 989             // let gtk_window_resize succeed, because it&#39;s bound to geometry constraints
 990             apply_geometry();
 991             gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);
 992         } else {
 993             gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);
 994         }
 995     }
 996 
 997     if (xSet || ySet) {
 998         int newX = (xSet) ? x : geometry.current_x;
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_window.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>