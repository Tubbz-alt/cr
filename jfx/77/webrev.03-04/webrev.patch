diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
@@ -817,12 +817,14 @@
         mainEnv->DeleteGlobalRef(jwindow);
         jwindow = NULL;
     }
 }
 
-// This function calculate the deltas between window and window + decoration (titleblar, borders)
-// Only useful if the window manager does not support the frame extents extension
+// This function calculate the deltas between window and window + decoration (titleblar, borders).
+// Only useful if the window manager does not support the frame extents extension - in this case
+// it uses GDK calculation, that is primary based on _NET_FRAME_EXTENTS but will try harder
+// if that's not available.
 void WindowContextTop::calculate_adjustments() {
     if (frame_type == TITLED && !geometry.frame_extents_received) {
         GdkRectangle er;
         gdk_window_get_frame_extents(gdk_window, &er);
 
@@ -844,14 +846,14 @@
 void WindowContextTop::apply_geometry() {
     GdkGeometry gdk_geometry;
     gdk_geometry.win_gravity = GDK_GRAVITY_NORTH_WEST;
 
     if ((!geometry.resizable || !geometry.enabled) && !(is_maximized || is_fullscreen)) {
-        gdk_geometry.min_width = geometry.current_w;
-        gdk_geometry.min_height = geometry.current_h;
-        gdk_geometry.max_width = geometry.current_w;
-        gdk_geometry.max_height = geometry.current_h;
+        gdk_geometry.min_width = geometry.current_w - geometry.adjust_w;
+        gdk_geometry.min_height = geometry.current_h - geometry.adjust_h;
+        gdk_geometry.max_width = geometry.current_w - geometry.adjust_w;
+        gdk_geometry.max_height = geometry.current_h - geometry.adjust_h;
     } else {
         gdk_geometry.min_width = (geometry.minw > 0) ? geometry.minw - geometry.adjust_w : 1;
         gdk_geometry.min_height = (geometry.minh > 0) ? geometry.minh - geometry.adjust_h : 1;
         gdk_geometry.max_width = (geometry.maxw > 0) ? geometry.maxw  - geometry.adjust_w : G_MAXINT;
         gdk_geometry.max_height = (geometry.maxh > 0) ? geometry.maxh - geometry.adjust_h : G_MAXINT;
@@ -860,18 +862,10 @@
     gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), gtk_widget, &gdk_geometry,
         (GdkWindowHints) (GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE | GDK_HINT_WIN_GRAVITY));
 }
 
 void WindowContextTop::size_position_notify() {
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyResize, geometry.current_cw, geometry.current_ch);
-        CHECK_JNI_EXCEPTION(mainEnv);
-
-        mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_MOVE);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
-
     if (jwindow) {
         mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,
                 (is_maximized)
                     ? com_sun_glass_events_WindowEvent_MAXIMIZE
                     : com_sun_glass_events_WindowEvent_RESIZE,
@@ -879,10 +873,18 @@
         CHECK_JNI_EXCEPTION(mainEnv)
 
         mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, geometry.current_x, geometry.current_y);
         CHECK_JNI_EXCEPTION(mainEnv)
     }
+
+    if (jview) {
+        mainEnv->CallVoidMethod(jview, jViewNotifyResize, geometry.current_cw, geometry.current_ch);
+        CHECK_JNI_EXCEPTION(mainEnv);
+
+        mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_MOVE);
+        CHECK_JNI_EXCEPTION(mainEnv)
+    }
 }
 
 void WindowContextTop::activate_window() {
     Display *display = GDK_DISPLAY_XDISPLAY (gdk_window_get_display (gdk_window));
     Atom navAtom = XInternAtom(display, "_NET_ACTIVE_WINDOW", True);
@@ -999,16 +1001,10 @@
         }
     }
 }
 
 void WindowContextTop::process_configure() {
-    // this is to let java know about user changes on the window
-    // if the window is not visible, there will be no changes
-//    if (!map_received && !is_maximized) {
-//        return;
-//    }
-
     gint x, y, w, h, gtk_w, gtk_h;
 
     calculate_adjustments();
 
     gtk_window_get_position(GTK_WINDOW(gtk_widget), &x, &y);
@@ -1046,17 +1042,13 @@
         }
     }
 }
 
 void WindowContextTop::set_resizable(bool res) {
-    if (map_received) {
-        if (res != geometry.resizable) {
-            geometry.resizable = res;
-            apply_geometry();
-        }
-    } else {
-        geometry.resizable_on_map = res;
+    if (res != geometry.resizable) {
+        geometry.resizable = res;
+        apply_geometry();
     }
 }
 
 void WindowContextTop::set_visible(bool visible) {
     WindowContextBase::set_visible(visible);
@@ -1069,10 +1061,11 @@
 
 void WindowContextTop::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
     calculate_adjustments();
 
     // newW / newH always content sizes compatible with GTK+
+    // if window has no decoration, adjustments will be ZERO
     int newW = w > 0 ? w - geometry.adjust_w : cw;
     int newH = h > 0 ? h - geometry.adjust_h : ch;
 
     gboolean changed = FALSE;
     if (newW > 0 && newH > 0) {
@@ -1081,13 +1074,13 @@
         geometry.current_cw = newW;
         geometry.current_ch = newH;
         geometry.current_w = newW + geometry.adjust_w;
         geometry.current_h = newH + geometry.adjust_h;
 
-        if (map_received) {
-            apply_geometry(); // update constraints if not resized by the user interface
-        }
+        // update constraints if not resized by the user interface so it will
+        // let gtk_window_resize succeed, because it's bound to geometry constraints
+        apply_geometry();
 
         gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);
     }
 
     if (xSet || ySet) {
@@ -1107,14 +1100,10 @@
     }
 }
 
 void WindowContextTop::process_map() {
     map_received = true;
-    geometry.resizable = geometry.resizable_on_map;
-    set_enabled(geometry.enabled_on_map);
-
-    apply_geometry();
 }
 
 void WindowContextTop::applyShapeMask(void* data, uint width, uint height) {
     if (frame_type != TRANSPARENT) {
         return;
@@ -1183,18 +1172,14 @@
 void WindowContextTop::set_alpha(double alpha) {
     gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble)alpha);
 }
 
 void WindowContextTop::set_enabled(bool enabled) {
-    if (map_received) {
-        if (enabled != geometry.enabled) {
-            gtk_widget_set_sensitive(gtk_widget, enabled);
-            geometry.enabled = enabled;
-            apply_geometry();
-        }
-    } else {
-        geometry.enabled_on_map = enabled;
+    if (enabled != geometry.enabled) {
+        gtk_widget_set_sensitive(gtk_widget, enabled);
+        geometry.enabled = enabled;
+        apply_geometry();
     }
 }
 
 void WindowContextTop::set_minimum_size(int w, int h) {
     gboolean changed = geometry.minw != w || geometry.minh != h;
diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.h b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.h
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.h
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.h
@@ -76,14 +76,12 @@
                       view_x(0),
                       view_y(0),
                       frame_extents_received(false),
                       gravity_x(1.00),
                       gravity_y(1.00),
-                      enabled_on_map(true),
                       enabled(true),
                       resizable(true),
-                      resizable_on_map(true),
                       minw(-1),
                       minh(-1),
                       maxw(-1),
                       maxh(-1){}
 
@@ -108,14 +106,12 @@
 
     // Currently not used
     float gravity_x;
     float gravity_y;
 
-    bool enabled_on_map;
     bool enabled;
     bool resizable;
-    bool resizable_on_map; // resizable property will be final when window is mapped
 
     int minw;
     int minh;
 
     int maxw;
