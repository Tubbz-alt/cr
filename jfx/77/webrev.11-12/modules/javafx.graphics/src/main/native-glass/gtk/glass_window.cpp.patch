diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
@@ -80,12 +80,12 @@
     ((WindowContext *) user_data)->process_mouse_button(&event->button);
     return TRUE;
 }
 
 static gboolean ctx_device_motion_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
-    ((WindowContext *) user_data)->process_mouse_motion(&event->motion);
     gdk_event_request_motions(&event->motion);
+    ((WindowContext *) user_data)->process_mouse_motion(&event->motion);
     return TRUE;
 }
 
 static gboolean ctx_device_scroll_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
     ((WindowContext *) user_data)->process_mouse_scroll(&event->scroll);
@@ -182,11 +182,12 @@
         is_iconified(false),
         is_maximized(false),
         is_mouse_entered(false),
         can_be_deleted(false),
         events_processing_cnt(0),
-        win_group(NULL) {
+        win_group(NULL),
+        pointer_device(NULL) {
 
     jwindow = mainEnv->NewGlobalRef(_jwindow);
 
     gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);
 
@@ -222,11 +223,10 @@
 
     glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);
     gtk_window_set_title(GTK_WINDOW(gtk_widget), "");
 
     gdk_window = gtk_widget_get_window(gtk_widget);
-
     g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
 
     glass_dnd_attach_context(this);
 
     gdk_windowManagerFunctions = wmf;
@@ -330,10 +330,11 @@
 }
 
 void WindowContext::process_focus(GdkEventFocus *event) {
     if (!event->in) {
         ungrab_focus();
+        pointer_device_ungrab();
     }
 
     if (xim.enabled && xim.ic) {
         if (event->in) {
             XSetICFocus(xim.ic);
@@ -413,10 +414,11 @@
     if (owner) {
         owner->remove_child(this);
     }
 
     ungrab_focus();
+    pointer_device_ungrab();
 
     std::set<WindowContext *>::iterator it;
     for (it = children.begin(); it != children.end(); ++it) {
         // FIX JDK-8226537: this method calls set_owner(NULL) which prevents
         // WindowContext::process_destroy() to call remove_child() (because children
@@ -462,10 +464,12 @@
     }
 }
 
 void WindowContext::process_mouse_button(GdkEventButton *event) {
     bool press = event->type == GDK_BUTTON_PRESS;
+    bool release = event->type == GDK_BUTTON_RELEASE;
+
     guint state = event->state;
     guint mask = 0;
 
     // We need to add/remove current mouse button from the modifier flags
     // as X lib state represents the state just prior to the event and
@@ -492,10 +496,29 @@
         state |= mask;
     } else {
         state &= ~mask;
     }
 
+    // Upper layers expects from us Windows behavior:
+    // all mouse events should be delivered to window where drag begins
+    // and no exit/enter event should be reported during this drag.
+    // We can grab mouse pointer for these needs.
+    if (press) {
+        pointer_device_grab();
+    } else {
+        if ((event->state & MOUSE_BUTTONS_MASK)
+            && !(state & MOUSE_BUTTONS_MASK)) { // all buttons released
+            pointer_device_ungrab();
+        } else if (event->button == 8 || event->button == 9) {
+            // GDK X backend interprets button press events for buttons 4-7 as
+            // scroll events so GDK_BUTTON4_MASK and GDK_BUTTON5_MASK will never
+            // be set on the event->state from GDK. Thus we cannot check if all
+            // buttons have been released in the usual way (as above).
+            pointer_device_ungrab();
+        }
+    }
+
     jint button = gtk_button_number_to_mouse_button(event->button);
 
     if (jview && button != com_sun_glass_events_MouseEvent_BUTTON_NONE) {
         mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
                                 press ? com_sun_glass_events_MouseEvent_DOWN : com_sun_glass_events_MouseEvent_UP,
@@ -1371,10 +1394,64 @@
         return (topO && topO->effective_on_top()) || on_top;
     }
     return on_top;
 }
 
+GdkDevice * WindowContext::get_pointer_device() {
+    GdkDevice * device;
+#ifdef GLASS_GTK3
+#if GTK_CHECK_VERSION(3, 20, 0)
+    device = gdk_seat_get_pointer(gdk_display_get_default_seat(gtk_widget_get_display(gtk_widget)));
+#else
+    device = gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget));
+#endif
+#else
+    // gtk2
+    device = gdk_display_get_core_pointer(gtk_widget_get_display(gtk_widget));
+#endif
+
+    return device;
+}
+
+void WindowContext::pointer_device_grab() {
+    if (is_grab_disabled()) {
+        return;
+    }
+
+    pointer_device_ungrab();
+
+    pointer_device = get_pointer_device();
+#ifdef GLASS_GTK3
+#if GTK_CHECK_VERSION(3, 20, 0)
+    gdk_seat_grab(gdk_device_get_seat(pointer_device),
+                  gdk_window, GDK_SEAT_CAPABILITY_ALL, TRUE, NULL, NULL, NULL, NULL);
+#else
+    gdk_device_grab(pointer_device, gdk_window, GDK_OWNERSHIP_WINDOW, TRUE, GDK_ALL_EVENTS_MASK,
+                    NULL, GDK_CURRENT_TIME);
+#endif
+#else
+    gdk_pointer_grab(gdk_window, TRUE, GDK_ALL_EVENTS_MASK, NULL, NULL, GDK_CURRENT_TIME);
+#endif
+}
+
+void WindowContext::pointer_device_ungrab() {
+    if (!pointer_device) {
+        return;
+    }
+
+#ifdef GLASS_GTK3
+#if GTK_CHECK_VERSION(3, 20, 0)
+    gdk_seat_ungrab(gdk_device_get_seat(pointer_device));
+#else
+    gdk_device_ungrab(pointer_device, GDK_CURRENT_TIME);
+#endif
+#else
+    gdk_pointer_ungrab(GDK_CURRENT_TIME);
+#endif
+    pointer_device = NULL;
+}
+
 WindowContext::~WindowContext() {
     if (xim.ic) {
         XDestroyIC(xim.ic);
         xim.ic = NULL;
     }
