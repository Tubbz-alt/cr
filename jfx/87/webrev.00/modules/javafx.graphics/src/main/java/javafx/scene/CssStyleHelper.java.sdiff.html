<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/java/javafx/scene/CssStyleHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>modules/javafx.graphics/src/main/java/javafx/scene/CssStyleHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 114         //
 115         // reuse the existing styleHelper if possible.
 116         //
 117         if ( canReuseStyleHelper(node, styleMap) ) {
 118 
 119             //
 120             // RT-33080
 121             //
 122             // If we&#39;re reusing a style helper, clear the fontSizeCache in case either this node or some parent
 123             // node has changed font from a user calling setFont.
 124             //
 125             // It may be the case that the node&#39;s font has changed from a call to setFont, which will
 126             // trigger a REAPPLY. If the REAPPLY comes because of a change in font, then the fontSizeCache
 127             // needs to be invalidated (cleared) so that new values will be looked up for all transition states.
 128             //
 129             if (node.styleHelper.cacheContainer != null &amp;&amp; node.styleHelper.isUserSetFont(node)) {
 130                 node.styleHelper.cacheContainer.fontSizeCache.clear();
 131             }
 132             node.styleHelper.cacheContainer.forceSlowpath = true;
 133             node.styleHelper.triggerStates.addAll(triggerStates[0]);
<span class="line-modified"> 134             node.styleHelper.firstStyleableAncestor = findFirstStyleableAncestor(node);</span>
 135             updateParentTriggerStates(node, depth, triggerStates);
 136             return node.styleHelper;
 137 
 138         }
 139 
 140         if (styleMap == null || styleMap.isEmpty()) {
 141 
 142             boolean mightInherit = false;
 143 
 144             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; props = node.getCssMetaData();
 145 
 146             final int pMax = props != null ? props.size() : 0;
 147             for (int p=0; p&lt;pMax; p++) {
 148 
 149                 final CssMetaData&lt;? extends Styleable, ?&gt; prop = props.get(p);
 150                 if (prop.isInherits()) {
 151                     mightInherit = true;
 152                     break;
 153                 }
 154             }
</pre>
<hr />
<pre>
 301 
 302         // If the style maps are the same instance, we can re-use the current styleHelper if the cacheContainer is null.
 303         // Under this condition, there are no styles for this node _and_ no styles inherit.
 304         if (node.styleHelper.cacheContainer == null) {
 305             return true;
 306         }
 307 
 308         //
 309         // The current map might be the same, but one of the node&#39;s parent&#39;s maps might have changed which
 310         // might cause some calculated values to change. To see if we can re-use the style-helper, we need to
 311         // check if the StyleMap id&#39;s have changed, which we can do by inspecting the cacheContainer&#39;s styleCacheKey
 312         // since it is made up of the current set of StyleMap ids.
 313         //
 314 
 315         Styleable parent = node.getStyleableParent();
 316 
 317         // if the node&#39;s parent is null and the style maps are the same, then we can certainly reuse the style-helper
 318         if (parent == null) {
 319             return true;
 320         }
<span class="line-modified"> 321 </span>

 322         CssStyleHelper parentHelper = getStyleHelper(node.styleHelper.firstStyleableAncestor);
 323 
 324         if (parentHelper != null &amp;&amp; parentHelper.cacheContainer != null) {
 325 
 326             int[] parentIds = parentHelper.cacheContainer.styleCacheKey.getStyleMapIds();
 327             int[] nodeIds = node.styleHelper.cacheContainer.styleCacheKey.getStyleMapIds();
 328 
 329             if (parentIds.length == nodeIds.length - 1) {
 330 
 331                 boolean isSame = true;
 332 
 333                 // check that all of the style map ids are the same.
 334                 for (int i = 0; i &lt; parentIds.length; i++) {
 335                     if (nodeIds[i + 1] != parentIds[i]) {
 336                         isSame = false;
 337                         break;
 338                     }
 339                 }
 340 
 341                 return isSame;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 114         //
 115         // reuse the existing styleHelper if possible.
 116         //
 117         if ( canReuseStyleHelper(node, styleMap) ) {
 118 
 119             //
 120             // RT-33080
 121             //
 122             // If we&#39;re reusing a style helper, clear the fontSizeCache in case either this node or some parent
 123             // node has changed font from a user calling setFont.
 124             //
 125             // It may be the case that the node&#39;s font has changed from a call to setFont, which will
 126             // trigger a REAPPLY. If the REAPPLY comes because of a change in font, then the fontSizeCache
 127             // needs to be invalidated (cleared) so that new values will be looked up for all transition states.
 128             //
 129             if (node.styleHelper.cacheContainer != null &amp;&amp; node.styleHelper.isUserSetFont(node)) {
 130                 node.styleHelper.cacheContainer.fontSizeCache.clear();
 131             }
 132             node.styleHelper.cacheContainer.forceSlowpath = true;
 133             node.styleHelper.triggerStates.addAll(triggerStates[0]);
<span class="line-modified"> 134 </span>
 135             updateParentTriggerStates(node, depth, triggerStates);
 136             return node.styleHelper;
 137 
 138         }
 139 
 140         if (styleMap == null || styleMap.isEmpty()) {
 141 
 142             boolean mightInherit = false;
 143 
 144             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; props = node.getCssMetaData();
 145 
 146             final int pMax = props != null ? props.size() : 0;
 147             for (int p=0; p&lt;pMax; p++) {
 148 
 149                 final CssMetaData&lt;? extends Styleable, ?&gt; prop = props.get(p);
 150                 if (prop.isInherits()) {
 151                     mightInherit = true;
 152                     break;
 153                 }
 154             }
</pre>
<hr />
<pre>
 301 
 302         // If the style maps are the same instance, we can re-use the current styleHelper if the cacheContainer is null.
 303         // Under this condition, there are no styles for this node _and_ no styles inherit.
 304         if (node.styleHelper.cacheContainer == null) {
 305             return true;
 306         }
 307 
 308         //
 309         // The current map might be the same, but one of the node&#39;s parent&#39;s maps might have changed which
 310         // might cause some calculated values to change. To see if we can re-use the style-helper, we need to
 311         // check if the StyleMap id&#39;s have changed, which we can do by inspecting the cacheContainer&#39;s styleCacheKey
 312         // since it is made up of the current set of StyleMap ids.
 313         //
 314 
 315         Styleable parent = node.getStyleableParent();
 316 
 317         // if the node&#39;s parent is null and the style maps are the same, then we can certainly reuse the style-helper
 318         if (parent == null) {
 319             return true;
 320         }
<span class="line-modified"> 321         //update ancestor since this node may have changed positions in the scene graph (JDK-8237469)</span>
<span class="line-added"> 322         node.styleHelper.firstStyleableAncestor = findFirstStyleableAncestor(node);</span>
 323         CssStyleHelper parentHelper = getStyleHelper(node.styleHelper.firstStyleableAncestor);
 324 
 325         if (parentHelper != null &amp;&amp; parentHelper.cacheContainer != null) {
 326 
 327             int[] parentIds = parentHelper.cacheContainer.styleCacheKey.getStyleMapIds();
 328             int[] nodeIds = node.styleHelper.cacheContainer.styleCacheKey.getStyleMapIds();
 329 
 330             if (parentIds.length == nodeIds.length - 1) {
 331 
 332                 boolean isSame = true;
 333 
 334                 // check that all of the style map ids are the same.
 335                 for (int i = 0; i &lt; parentIds.length; i++) {
 336                     if (nodeIds[i + 1] != parentIds[i]) {
 337                         isSame = false;
 338                         break;
 339                     }
 340                 }
 341 
 342                 return isSame;
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>