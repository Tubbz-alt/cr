<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/java/javafx/scene/CssStyleHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javafx.scene;
  26 
  27 import java.util.ArrayList;
  28 import java.util.Collections;
  29 import java.util.HashMap;
  30 import java.util.HashSet;
  31 import java.util.List;
  32 import java.util.Locale;
  33 import java.util.Map;
  34 import java.util.Map.Entry;
  35 import java.util.Set;
  36 
  37 import javafx.beans.property.ObjectProperty;
  38 import javafx.beans.property.SimpleObjectProperty;
  39 import javafx.beans.value.WritableValue;
  40 import com.sun.javafx.css.CascadingStyle;
  41 import javafx.css.CssMetaData;
  42 import javafx.css.CssParser;
  43 import javafx.css.FontCssMetaData;
  44 import javafx.css.ParsedValue;
  45 import javafx.css.PseudoClass;
  46 import javafx.css.Rule;
  47 import javafx.css.Selector;
  48 import javafx.css.Style;
  49 import javafx.css.StyleConverter;
  50 import javafx.css.StyleOrigin;
  51 import javafx.css.Styleable;
  52 import javafx.css.StyleableProperty;
  53 import javafx.css.Stylesheet;
  54 import javafx.scene.text.Font;
  55 import javafx.scene.text.FontPosture;
  56 import javafx.scene.text.FontWeight;
  57 
  58 import com.sun.javafx.css.CalculatedValue;
  59 import com.sun.javafx.css.ParsedValueImpl;
  60 import com.sun.javafx.css.PseudoClassState;
  61 import com.sun.javafx.css.StyleCache;
  62 import com.sun.javafx.css.StyleCacheEntry;
  63 import com.sun.javafx.css.StyleManager;
  64 import com.sun.javafx.css.StyleMap;
  65 import javafx.css.converter.FontConverter;
  66 import com.sun.javafx.util.Logging;
  67 import com.sun.javafx.util.Utils;
  68 
  69 import com.sun.javafx.logging.PlatformLogger;
  70 import com.sun.javafx.logging.PlatformLogger.Level;
  71 
  72 import static com.sun.javafx.css.CalculatedValue.*;
  73 
  74 /**
  75  * The StyleHelper is a helper class used for applying CSS information to Nodes.
  76  */
  77 final class CssStyleHelper {
  78 
  79     private static final PlatformLogger LOGGER = com.sun.javafx.util.Logging.getCSSLogger();
  80 
  81     private CssStyleHelper() {
  82         this.triggerStates = new PseudoClassState();
  83     }
  84 
  85     /**
  86      * Creates a new StyleHelper.
  87      */
  88     static CssStyleHelper createStyleHelper(final Node node) {
  89 
  90         // need to know how far we are to root in order to init arrays.
  91         // TODO: should we hang onto depth to avoid this nonsense later?
  92         // TODO: is there some other way of knowing how far from the root a node is?
  93         Styleable parent = node;
  94         int depth = 0;
  95         while(parent != null) {
  96             depth++;
  97             parent = parent.getStyleableParent();
  98         }
  99 
 100         // The List&lt;CacheEntry&gt; should only contain entries for those
 101         // pseudo-class states that have styles. The StyleHelper&#39;s
 102         // pseudoclassStateMask is a bitmask of those pseudoclasses that
 103         // appear in the node&#39;s StyleHelper&#39;s smap. This list of
 104         // pseudo-class masks is held by the StyleCacheKey. When a node is
 105         // styled, its pseudoclasses and the pseudoclasses of its parents
 106         // are gotten. By comparing the actual pseudo-class state to the
 107         // pseudo-class states that apply, a CacheEntry can be created or
 108         // fetched using only those pseudoclasses that matter.
 109         final PseudoClassState[] triggerStates = new PseudoClassState[depth];
 110 
 111         final StyleMap styleMap =
 112                 StyleManager.getInstance().findMatchingStyles(node, node.getSubScene(), triggerStates);
 113 
 114         //
 115         // reuse the existing styleHelper if possible.
 116         //
 117         if ( canReuseStyleHelper(node, styleMap) ) {
 118 
 119             //
 120             // RT-33080
 121             //
 122             // If we&#39;re reusing a style helper, clear the fontSizeCache in case either this node or some parent
 123             // node has changed font from a user calling setFont.
 124             //
 125             // It may be the case that the node&#39;s font has changed from a call to setFont, which will
 126             // trigger a REAPPLY. If the REAPPLY comes because of a change in font, then the fontSizeCache
 127             // needs to be invalidated (cleared) so that new values will be looked up for all transition states.
 128             //
 129             if (node.styleHelper.cacheContainer != null &amp;&amp; node.styleHelper.isUserSetFont(node)) {
 130                 node.styleHelper.cacheContainer.fontSizeCache.clear();
 131             }
 132             node.styleHelper.cacheContainer.forceSlowpath = true;
 133             node.styleHelper.triggerStates.addAll(triggerStates[0]);
 134 
 135             updateParentTriggerStates(node, depth, triggerStates);
 136             return node.styleHelper;
 137 
 138         }
 139 
 140         if (styleMap == null || styleMap.isEmpty()) {
 141 
 142             boolean mightInherit = false;
 143 
 144             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; props = node.getCssMetaData();
 145 
 146             final int pMax = props != null ? props.size() : 0;
 147             for (int p=0; p&lt;pMax; p++) {
 148 
 149                 final CssMetaData&lt;? extends Styleable, ?&gt; prop = props.get(p);
 150                 if (prop.isInherits()) {
 151                     mightInherit = true;
 152                     break;
 153                 }
 154             }
 155 
 156             if (mightInherit == false) {
 157 
 158                 // If this node had a style helper, then reset properties to their initial value
 159                 // since the node won&#39;t have a style helper after this call
 160                 if (node.styleHelper != null) {
 161                     node.styleHelper.resetToInitialValues(node);
 162                 }
 163 
 164                 //
 165                 // This node didn&#39;t have a StyleHelper before and it doesn&#39;t need one now since there are
 166                 // no styles in the StyleMap and no inherited styles.
 167                 return null;
 168             }
 169 
 170         }
 171 
 172         final CssStyleHelper helper = new CssStyleHelper();
 173         helper.triggerStates.addAll(triggerStates[0]);
 174 
 175         updateParentTriggerStates(node, depth, triggerStates);
 176 
 177         helper.cacheContainer = new CacheContainer(node, styleMap, depth);
 178 
 179         helper.firstStyleableAncestor = findFirstStyleableAncestor(node);
 180 
 181         // If this node had a style helper, then reset properties to their initial value
 182         // since the style map might now be different
 183         if (node.styleHelper != null) {
 184             node.styleHelper.resetToInitialValues(node);
 185         }
 186         return helper;
 187     }
 188 
 189     private static void updateParentTriggerStates(Styleable styleable, int depth, PseudoClassState[] triggerStates) {
 190         // make sure parent&#39;s transition states include the pseudo-classes
 191         // found when matching selectors
 192         Styleable parent = styleable.getStyleableParent();
 193         for(int n=1; n&lt;depth; n++) {
 194 
 195             // TODO: this means that a style like .menu-item:hover won&#39;t work. Need to separate CssStyleHelper tree from scene-graph tree
 196             if (parent instanceof Node == false) {
 197                 parent=parent.getStyleableParent();
 198                 continue;
 199             }
 200             Node parentNode = (Node)parent;
 201 
 202             final PseudoClassState triggerState = triggerStates[n];
 203 
 204             // if there is nothing in triggerState, then continue since there
 205             // isn&#39;t any pseudo-class state that might trigger a state change
 206             if (triggerState != null &amp;&amp; triggerState.size() &gt; 0) {
 207 
 208                 // Create a StyleHelper for the parent, if necessary.
 209                 // TODO : check why calling createStyleHelper(parentNode) does not work here?
 210                 if (parentNode.styleHelper == null) {
 211                     parentNode.styleHelper = new CssStyleHelper();
 212                     parentNode.styleHelper.firstStyleableAncestor = findFirstStyleableAncestor(parentNode) ;
 213                 }
 214                 parentNode.styleHelper.triggerStates.addAll(triggerState);
 215 
 216             }
 217 
 218             parent=parent.getStyleableParent();
 219         }
 220 
 221     }
 222     //
 223     // return true if the fontStyleableProperty&#39;s origin is USER
 224     //
 225     private boolean isUserSetFont(Styleable node) {
 226 
 227         if (node == null) return false; // should never happen, but just to be safe...
 228 
 229         CssMetaData&lt;Styleable, Font&gt; fontCssMetaData = cacheContainer != null ? cacheContainer.fontProp : null;
 230         if (fontCssMetaData != null) {
 231             StyleableProperty&lt;Font&gt; fontStyleableProperty = fontCssMetaData != null ? fontCssMetaData.getStyleableProperty(node) : null;
 232             if (fontStyleableProperty != null &amp;&amp; fontStyleableProperty.getStyleOrigin() == StyleOrigin.USER) return true;
 233         }
 234 
 235         Styleable styleableParent = firstStyleableAncestor;
 236         CssStyleHelper parentStyleHelper = getStyleHelper(firstStyleableAncestor);
 237 
 238         if (parentStyleHelper != null) {
 239             return parentStyleHelper.isUserSetFont(styleableParent);
 240         } else {
 241             return false;
 242         }
 243     }
 244 
 245     private static CssStyleHelper getStyleHelper(Node n) {
 246         return (n != null)? n.styleHelper : null;
 247     }
 248 
 249     private static Node findFirstStyleableAncestor(Styleable st) {
 250         Node ancestor = null;
 251         Styleable parent = st.getStyleableParent();
 252         while (parent != null) {
 253             if (parent instanceof Node) {
 254                 if (((Node) parent).styleHelper != null) {
 255                     ancestor = (Node) parent;
 256                     break;
 257                 }
 258             }
 259             parent = parent.getStyleableParent();
 260         }
 261 
 262         return ancestor;
 263     }
 264 
 265     //
 266     // return the value of the property
 267     //
 268     private static boolean isTrue(WritableValue&lt;Boolean&gt; booleanProperty) {
 269         return booleanProperty != null &amp;&amp; booleanProperty.getValue();
 270     }
 271 
 272     //
 273     // set the value of the property to true
 274     //
 275     private static void setTrue(WritableValue&lt;Boolean&gt; booleanProperty) {
 276         if (booleanProperty != null) booleanProperty.setValue(true);
 277     }
 278 
 279     //
 280     // return true if the Node&#39;s current styleHelper can be reused.
 281     //
 282     private static boolean canReuseStyleHelper(final Node node, final StyleMap styleMap) {
 283 
 284         // Obviously, we cannot reuse the node&#39;s style helper if it doesn&#39;t have one.
 285         if (node == null || node.styleHelper == null) {
 286             return false;
 287         }
 288 
 289         // If we have a styleHelper but the new styleMap is null, then we don&#39;t need a styleHelper at all
 290         if (styleMap == null) {
 291             return false;
 292         }
 293 
 294         StyleMap currentMap = node.styleHelper.getStyleMap(node);
 295 
 296         // We cannot reuse the style helper if the styleMap is not the same instance as the current one
 297         // Note: check instance equality!
 298         if (currentMap != styleMap) {
 299             return false;
 300         }
 301 
 302         // If the style maps are the same instance, we can re-use the current styleHelper if the cacheContainer is null.
 303         // Under this condition, there are no styles for this node _and_ no styles inherit.
 304         if (node.styleHelper.cacheContainer == null) {
 305             return true;
 306         }
 307 
 308         //
 309         // The current map might be the same, but one of the node&#39;s parent&#39;s maps might have changed which
 310         // might cause some calculated values to change. To see if we can re-use the style-helper, we need to
 311         // check if the StyleMap id&#39;s have changed, which we can do by inspecting the cacheContainer&#39;s styleCacheKey
 312         // since it is made up of the current set of StyleMap ids.
 313         //
 314 
 315         Styleable parent = node.getStyleableParent();
 316 
 317         // if the node&#39;s parent is null and the style maps are the same, then we can certainly reuse the style-helper
 318         if (parent == null) {
 319             return true;
 320         }
 321         //update ancestor since this node may have changed positions in the scene graph (JDK-8237469)
 322         node.styleHelper.firstStyleableAncestor = findFirstStyleableAncestor(node);
 323         CssStyleHelper parentHelper = getStyleHelper(node.styleHelper.firstStyleableAncestor);
 324 
 325         if (parentHelper != null &amp;&amp; parentHelper.cacheContainer != null) {
 326 
 327             int[] parentIds = parentHelper.cacheContainer.styleCacheKey.getStyleMapIds();
 328             int[] nodeIds = node.styleHelper.cacheContainer.styleCacheKey.getStyleMapIds();
 329 
 330             if (parentIds.length == nodeIds.length - 1) {
 331 
 332                 boolean isSame = true;
 333 
 334                 // check that all of the style map ids are the same.
 335                 for (int i = 0; i &lt; parentIds.length; i++) {
 336                     if (nodeIds[i + 1] != parentIds[i]) {
 337                         isSame = false;
 338                         break;
 339                     }
 340                 }
 341 
 342                 return isSame;
 343 
 344             }
 345         }
 346 
 347         return false;
 348     }
 349 
 350     /* This is the first Styleable parent (of Node this StyleHelper belongs to)
 351      * having a valid StyleHelper */
 352     private Node firstStyleableAncestor;
 353 
 354     private CacheContainer cacheContainer;
 355 
 356     private final static class CacheContainer {
 357 
 358         // Set internal internalState structures
 359         private CacheContainer(
 360                 Node node,
 361                 final StyleMap styleMap,
 362                 int depth) {
 363 
 364             int ctr = 0;
 365             int[] smapIds = new int[depth];
 366             smapIds[ctr++] = this.smapId = styleMap.getId();
 367 
 368             //
 369             // Create a set of StyleMap id&#39;s from the parent&#39;s smapIds.
 370             // The resulting smapIds array may have less than depth elements.
 371             // If a parent doesn&#39;t have a styleHelper or the styleHelper&#39;s
 372             // internal state is null, then that parent doesn&#39;t contribute
 373             // to the selection of a style. Any Node that has the same
 374             // set of smapId&#39;s can potentially share previously calculated
 375             // values.
 376             //
 377             Styleable parent = node.getStyleableParent();
 378             for(int d=1; d&lt;depth; d++) {
 379 
 380                 // TODO: won&#39;t work for something like .menu-item:hover. Need to separate CssStyleHelper tree from scene-graph tree
 381                 if ( parent instanceof Node) {
 382                     Node parentNode = (Node)parent;
 383                 final CssStyleHelper helper = parentNode.styleHelper;
 384                     if (helper != null &amp;&amp; helper.cacheContainer != null) {
 385                         smapIds[ctr++] = helper.cacheContainer.smapId;
 386                     }
 387                 }
 388                 parent = parent.getStyleableParent();
 389 
 390             }
 391 
 392             this.styleCacheKey = new StyleCache.Key(smapIds, ctr);
 393 
 394             CssMetaData&lt;Styleable,Font&gt; styleableFontProperty = null;
 395 
 396             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; props = node.getCssMetaData();
 397             final int pMax = props != null ? props.size() : 0;
 398             for (int p=0; p&lt;pMax; p++) {
 399                 final CssMetaData&lt;? extends Styleable, ?&gt; prop = props.get(p);
 400 
 401                 if (&quot;-fx-font&quot;.equals(prop.getProperty())) {
 402                     // unchecked!
 403                     styleableFontProperty = (CssMetaData&lt;Styleable, Font&gt;) prop;
 404                     break;
 405                 }
 406             }
 407 
 408             this.fontProp = styleableFontProperty;
 409             this.fontSizeCache = new HashMap&lt;&gt;();
 410 
 411             this.cssSetProperties = new HashMap&lt;&gt;();
 412 
 413         }
 414 
 415         private StyleMap getStyleMap(Styleable styleable) {
 416             if (styleable != null) {
 417                 SubScene subScene =  (styleable instanceof Node) ? ((Node) styleable).getSubScene() : null;
 418                 return StyleManager.getInstance().getStyleMap(styleable, subScene, smapId);
 419             } else {
 420                 return StyleMap.EMPTY_MAP;
 421             }
 422 
 423         }
 424 
 425         // This is the key we use to find the shared cache
 426         private final StyleCache.Key styleCacheKey;
 427 
 428         // If the node has a fontProperty, we hang onto the CssMetaData for it
 429         // so we can get at it later.
 430         // TBD - why not the fontProperty itself?
 431         private final CssMetaData&lt;Styleable,Font&gt; fontProp;
 432 
 433         // The id of StyleMap that contains the styles that apply to this node
 434         private final int smapId;
 435 
 436         // All nodes with the same set of styles share the same cache of
 437         // calculated values. But one node might have a different font-size
 438         // than another so the values are stored in cache by font-size.
 439         // This map associates a style cache entry with the font to use when
 440         // getting a value from or putting a value into cache.
 441         private final Map&lt;StyleCacheEntry.Key, CalculatedValue&gt; fontSizeCache;
 442 
 443         // Any properties that have been set by this style helper are tracked
 444         // here so the property can be reset without expanding properties that
 445         // were not set by css.
 446         private final Map&lt;CssMetaData, CalculatedValue&gt; cssSetProperties;
 447 
 448         private boolean forceSlowpath = false;
 449     }
 450 
 451     private void resetToInitialValues(final Styleable styleable) {
 452 
 453         if (cacheContainer == null ||
 454                 cacheContainer.cssSetProperties == null ||
 455                 cacheContainer.cssSetProperties.isEmpty()) return;
 456 
 457         // RT-31714 - make a copy of the entry set and clear the cssSetProperties immediately.
 458         Set&lt;Entry&lt;CssMetaData, CalculatedValue&gt;&gt; entrySet = new HashSet&lt;&gt;(cacheContainer.cssSetProperties.entrySet());
 459         cacheContainer.cssSetProperties.clear();
 460 
 461         for (Entry&lt;CssMetaData, CalculatedValue&gt; resetValues : entrySet) {
 462 
 463             final CssMetaData metaData = resetValues.getKey();
 464             final StyleableProperty styleableProperty = metaData.getStyleableProperty(styleable);
 465 
 466             final StyleOrigin styleOrigin = styleableProperty.getStyleOrigin();
 467             if (styleOrigin != null &amp;&amp; styleOrigin != StyleOrigin.USER) {
 468                 final CalculatedValue calculatedValue = resetValues.getValue();
 469                 styleableProperty.applyStyle(calculatedValue.getOrigin(), calculatedValue.getValue());
 470             }
 471         }
 472     }
 473 
 474 
 475     private StyleMap getStyleMap(Styleable styleable) {
 476         if (cacheContainer == null || styleable == null) return null;
 477         return cacheContainer.getStyleMap(styleable);
 478     }
 479 
 480     /**
 481      * A Set of all the pseudo-class states which, if they change, need to
 482      * cause the Node to be set to UPDATE its CSS styles on the next pulse.
 483      * For example, your stylesheet might have:
 484      * &lt;pre&gt;&lt;code&gt;
 485      * .button { ... }
 486      * .button:hover { ... }
 487      * .button *.label { text-fill: black }
 488      * .button:hover *.label { text-fill: blue }
 489      * &lt;/code&gt;&lt;/pre&gt;
 490      * In this case, the first 2 rules apply to the Button itself, but the
 491      * second two rules apply to the label within a Button. When the hover
 492      * changes on the Button, however, we must mark the Button as needing
 493      * an UPDATE. StyleHelper though only contains styles for the first two
 494      * rules for Button. The pseudoclassStateMask would in this case have
 495      * only a single bit set for &quot;hover&quot;. In this way the StyleHelper associated
 496      * with the Button would know whether a change to &quot;hover&quot; requires the
 497      * button and all children to be update. Other pseudo-class state changes
 498      * that are not in this hash set are ignored.
 499      * *
 500      * Called &quot;triggerStates&quot; since they would trigger a CSS update.
 501      */
 502     private PseudoClassState triggerStates = new PseudoClassState();
 503 
 504     boolean pseudoClassStateChanged(PseudoClass pseudoClass) {
 505         return triggerStates.contains(pseudoClass);
 506     }
 507 
 508     /**
 509      * Dynamic pseudo-class state of the node and its parents.
 510      * Only valid during a pulse.
 511      *
 512      * The StyleCacheEntry to choose depends on the Node&#39;s pseudo-class state
 513      * and the pseudo-class state of its parents. Without the parent
 514      * pseudo-class state, the fact that the the node in this pseudo-class state
 515      * matched foo:blah bar { } is lost.
 516      */
 517     // TODO: this should work on Styleable, not Node
 518     private Set&lt;PseudoClass&gt;[] getTransitionStates(final Node node) {
 519 
 520         // if cacheContainer is null, then CSS just doesn&#39;t apply to this node
 521         if (cacheContainer == null) return null;
 522 
 523         int depth = 0;
 524         Node parent = node;
 525         while (parent != null) {
 526             depth += 1;
 527             parent = parent.getParent();
 528         }
 529 
 530         //
 531         // StyleHelper#triggerStates is the set of pseudo-classes that appear
 532         // in the style maps of this StyleHelper. Calculated values are
 533         // cached by pseudo-class state, but only the pseudo-class states
 534         // that mater are used in the search. So we take the transition states
 535         // and intersect them with triggerStates to remove the
 536         // transition states that don&#39;t matter when it comes to matching states
 537         // on a  selector. For example if the style map contains only
 538         // .foo:hover { -fx-fill: red; } then only the hover state matters
 539         // but the transtion state could be [hover, focused]
 540         //
 541         final Set&lt;PseudoClass&gt;[] retainedStates = new PseudoClassState[depth];
 542 
 543         //
 544         // Note Well: The array runs from leaf to root. That is,
 545         // retainedStates[0] is the pseudo-class state for node and
 546         // retainedStates[1..(states.length-1)] are the retainedStates for the
 547         // node&#39;s parents.
 548         //
 549 
 550         int count = 0;
 551         parent = node;
 552         while (parent != null) { // This loop traverses through all ancestors till root
 553             final CssStyleHelper helper = (parent instanceof Node) ? parent.styleHelper : null;
 554             if (helper != null) {
 555                 final Set&lt;PseudoClass&gt; pseudoClassState = parent.pseudoClassStates;
 556                 retainedStates[count] = new PseudoClassState();
 557                 retainedStates[count].addAll(pseudoClassState);
 558                 // retainAll method takes the intersection of pseudoClassState and helper.triggerStates
 559                 retainedStates[count].retainAll(helper.triggerStates);
 560                 count += 1;
 561             }
 562             parent = parent.getParent();
 563         }
 564 
 565         final Set&lt;PseudoClass&gt;[] transitionStates = new PseudoClassState[count];
 566         System.arraycopy(retainedStates, 0, transitionStates, 0, count);
 567 
 568         return transitionStates;
 569 
 570     }
 571 
 572     /**
 573      * Called by the Node whenever it has transitioned from one set of
 574      * pseudo-class states to another. This function will then lookup the
 575      * new values for each of the styleable variables on the Node, and
 576      * then either set the value directly or start an animation based on
 577      * how things are specified in the CSS file. Currently animation support
 578      * is disabled until the new parser comes online with support for
 579      * animations and that support is detectable via the API.
 580      */
 581     void transitionToState(final Node node) {
 582 
 583         if (cacheContainer == null) {
 584             return;
 585         }
 586 
 587         //
 588         // If styleMap is null, then StyleManager has blown it away and we need to reapply CSS.
 589         //
 590         final StyleMap styleMap = getStyleMap(node);
 591         if (styleMap == null) {
 592             cacheContainer = null;
 593             node.reapplyCSS();
 594             return;
 595         }
 596 
 597         // if the style-map is empty, then we are only looking for inherited styles.
 598         final boolean inheritOnly = styleMap.isEmpty();
 599 
 600         //
 601         // Styles that need lookup can be cached provided none of the styles
 602         // are from Node.style.
 603         //
 604         final StyleCache sharedCache = StyleManager.getInstance().getSharedCache(node, node.getSubScene(), cacheContainer.styleCacheKey);
 605 
 606         if (sharedCache == null) {
 607             // Shared cache was blown away by StyleManager.
 608             // Therefore, this CssStyleHelper is no good.
 609             cacheContainer = null;
 610             node.reapplyCSS();
 611             return;
 612 
 613         }
 614 
 615         final Set&lt;PseudoClass&gt;[] transitionStates = getTransitionStates(node);
 616 
 617         final StyleCacheEntry.Key fontCacheKey = new StyleCacheEntry.Key(transitionStates, Font.getDefault());
 618         CalculatedValue cachedFont = cacheContainer.fontSizeCache.get(fontCacheKey);
 619 
 620         if (cachedFont == null) {
 621 
 622             cachedFont = lookupFont(node, &quot;-fx-font&quot;, styleMap, cachedFont);
 623 
 624             if (cachedFont == SKIP) cachedFont = getCachedFont(node.getStyleableParent());
 625             if (cachedFont == null) cachedFont = new CalculatedValue(Font.getDefault(), null, false);
 626 
 627             cacheContainer.fontSizeCache.put(fontCacheKey,cachedFont);
 628 
 629         }
 630 
 631         final Font fontForRelativeSizes = (Font)cachedFont.getValue();
 632 
 633         final StyleCacheEntry.Key cacheEntryKey = new StyleCacheEntry.Key(transitionStates, fontForRelativeSizes);
 634         StyleCacheEntry cacheEntry = sharedCache.getStyleCacheEntry(cacheEntryKey);
 635 
 636         // if the cacheEntry already exists, take the fastpath
 637         final boolean fastpath = cacheEntry != null;
 638 
 639         if (cacheEntry == null) {
 640             cacheEntry = new StyleCacheEntry();
 641             sharedCache.addStyleCacheEntry(cacheEntryKey, cacheEntry);
 642         }
 643 
 644         final List&lt;CssMetaData&lt;? extends Styleable,  ?&gt;&gt; styleables = node.getCssMetaData();
 645 
 646         // Used in the for loop below, and a convenient place to stop when debugging.
 647         final int max = styleables.size();
 648 
 649         final boolean isForceSlowpath = cacheContainer.forceSlowpath;
 650         cacheContainer.forceSlowpath = false;
 651 
 652         // For each property that is settable, we need to do a lookup and
 653         // transition to that value.
 654         for(int n=0; n&lt;max; n++) {
 655 
 656             @SuppressWarnings(&quot;unchecked&quot;) // this is a widening conversion
 657             final CssMetaData&lt;Styleable,Object&gt; cssMetaData =
 658                     (CssMetaData&lt;Styleable,Object&gt;)styleables.get(n);
 659 
 660             // Don&#39;t bother looking up styles that don&#39;t inherit.
 661             if (inheritOnly &amp;&amp; cssMetaData.isInherits() == false) {
 662                 continue;
 663             }
 664 
 665             // Skip the lookup if we know there isn&#39;t a chance for this property
 666             // to be set (usually due to a &quot;bind&quot;).
 667             if (!cssMetaData.isSettable(node)) continue;
 668 
 669             final String property = cssMetaData.getProperty();
 670 
 671             CalculatedValue calculatedValue = cacheEntry.get(property);
 672 
 673             // If there is no calculatedValue and we&#39;re on the fast path,
 674             // take the slow path if cssFlags is REAPPLY (RT-31691)
 675             final boolean forceSlowpath =
 676                     fastpath &amp;&amp; calculatedValue == null &amp;&amp; isForceSlowpath;
 677 
 678             final boolean addToCache =
 679                     (!fastpath &amp;&amp; calculatedValue == null) || forceSlowpath;
 680 
 681             if (fastpath &amp;&amp; !forceSlowpath) {
 682 
 683                 // If the cache contains SKIP, then there was an
 684                 // exception thrown from applyStyle
 685                 if (calculatedValue == SKIP) {
 686                     continue;
 687                 }
 688 
 689             } else if (calculatedValue == null) {
 690 
 691                 // slowpath!
 692                 calculatedValue = lookup(node, cssMetaData, styleMap, transitionStates[0],
 693                         node, cachedFont);
 694 
 695                 // lookup is not supposed to return null.
 696                 if (calculatedValue == null) {
 697                     assert false : &quot;lookup returned null for &quot; + property;
 698                     continue;
 699                 }
 700 
 701             }
 702 
 703             // StyleableProperty#applyStyle might throw an exception and it is called
 704             // from two places in this try block.
 705             try {
 706 
 707                 //
 708                 // RT-19089
 709                 // If the current value of the property was set by CSS
 710                 // and there is no style for the property, then reset this
 711                 // property to its initial value. If it was not set by CSS
 712                 // then leave the property alone.
 713                 //
 714                 if (calculatedValue == null || calculatedValue == SKIP) {
 715 
 716                     // cssSetProperties keeps track of the StyleableProperty&#39;s that were set by CSS in the previous state.
 717                     // If this property is not in cssSetProperties map, then the property was not set in the previous state.
 718                     // This accomplishes two things. First, it lets us know if the property was set in the previous state
 719                     // so it can be reset in this state if there is no value for it. Second, it calling
 720                     // CssMetaData#getStyleableProperty which is rather expensive as it may cause expansion of lazy
 721                     // properties.
 722                     CalculatedValue initialValue = cacheContainer.cssSetProperties.get(cssMetaData);
 723 
 724                     // if the current value was set by CSS and there
 725                     // is no calculated value for the property, then
 726                     // there was no style for the property in the current
 727                     // state, so reset the property to its initial value.
 728                     if (initialValue != null) {
 729 
 730                         StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);
 731                         if (styleableProperty.getStyleOrigin() != StyleOrigin.USER) {
 732                             styleableProperty.applyStyle(initialValue.getOrigin(), initialValue.getValue());
 733                         }
 734                     }
 735 
 736                     continue;
 737 
 738                 }
 739 
 740                 if (addToCache) {
 741 
 742                     // If we&#39;re not on the fastpath, then add the calculated
 743                     // value to cache.
 744                     cacheEntry.put(property, calculatedValue);
 745                 }
 746 
 747                 StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);
 748 
 749                 // need to know who set the current value - CSS, the user, or init
 750                 final StyleOrigin originOfCurrentValue = styleableProperty.getStyleOrigin();
 751 
 752 
 753                 // RT-10522:
 754                 // If the user set the property and there is a style and
 755                 // the style came from the user agent stylesheet, then
 756                 // skip the value. A style from a user agent stylesheet should
 757                 // not override the user set style.
 758                 //
 759                 final StyleOrigin originOfCalculatedValue = calculatedValue.getOrigin();
 760 
 761                 // A calculated value should never have a null style origin since that would
 762                 // imply the style didn&#39;t come from a stylesheet or in-line style.
 763                 if (originOfCalculatedValue == null) {
 764                     assert false : styleableProperty.toString();
 765                     continue;
 766                 }
 767 
 768                 if (originOfCurrentValue == StyleOrigin.USER) {
 769                     if (originOfCalculatedValue == StyleOrigin.USER_AGENT) {
 770                         continue;
 771                     }
 772                 }
 773 
 774                 final Object value = calculatedValue.getValue();
 775                 final Object currentValue = styleableProperty.getValue();
 776 
 777                 // RT-21185: Only apply the style if something has changed.
 778                 if ((originOfCurrentValue != originOfCalculatedValue)
 779                         || (currentValue != null
 780                         ? currentValue.equals(value) == false
 781                         : value != null)) {
 782 
 783                     if (LOGGER.isLoggable(Level.FINER)) {
 784                         LOGGER.finer(property + &quot;, call applyStyle: &quot; + styleableProperty + &quot;, value =&quot; +
 785                                 String.valueOf(value) + &quot;, originOfCalculatedValue=&quot; + originOfCalculatedValue);
 786                     }
 787 
 788                     styleableProperty.applyStyle(originOfCalculatedValue, value);
 789 
 790                     if (cacheContainer.cssSetProperties.containsKey(cssMetaData) == false) {
 791                         // track this property
 792                         CalculatedValue initialValue = new CalculatedValue(currentValue, originOfCurrentValue, false);
 793                         cacheContainer.cssSetProperties.put(cssMetaData, initialValue);
 794                     }
 795 
 796                 }
 797 
 798             } catch (Exception e) {
 799 
 800                 StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);
 801 
 802                 final String msg = String.format(&quot;Failed to set css [%s] on [%s] due to &#39;%s&#39;\n&quot;,
 803                         cssMetaData.getProperty(), styleableProperty, e.getMessage());
 804 
 805                 List&lt;CssParser.ParseError&gt; errors = null;
 806                 if ((errors = StyleManager.getErrors()) != null) {
 807                     final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, node, msg);
 808                     errors.add(error);
 809                 }
 810 
 811                 PlatformLogger logger = Logging.getCSSLogger();
 812                 if (logger.isLoggable(Level.WARNING)) {
 813                     logger.warning(msg);
 814                 }
 815 
 816                 // RT-27155: if setting value raises exception, reset value
 817                 // the value to initial and thereafter skip setting the property
 818                 cacheEntry.put(property, SKIP);
 819 
 820                 CalculatedValue cachedValue = null;
 821                 if (cacheContainer != null &amp;&amp; cacheContainer.cssSetProperties != null) {
 822                     cachedValue = cacheContainer.cssSetProperties.get(cssMetaData);
 823                 }
 824                 Object value = (cachedValue != null) ? cachedValue.getValue() : cssMetaData.getInitialValue(node);
 825                 StyleOrigin origin = (cachedValue != null) ? cachedValue.getOrigin() : null;
 826                 try {
 827                     styleableProperty.applyStyle(origin, value);
 828                 } catch (Exception ebad) {
 829                     // This would be bad.
 830                     if (logger.isLoggable(Level.SEVERE)) {
 831                         logger.severe(String.format(&quot;Could not reset [%s] on [%s] due to %s\n&quot; ,
 832                                 cssMetaData.getProperty(), styleableProperty, e.getMessage()));
 833                     }
 834                 }
 835 
 836             }
 837 
 838         }
 839     }
 840 
 841     /**
 842      * Gets the CSS CascadingStyle for the property of this node in these pseudo-class
 843      * states. A null style may be returned if there is no style information
 844      * for this combination of input parameters.
 845      *
 846      *
 847      * @param styleable
 848      * @param property
 849      * @param styleMap
 850      * @param states   @return
 851      * */
 852     private CascadingStyle getStyle(final Styleable styleable, final String property, final StyleMap styleMap, final Set&lt;PseudoClass&gt; states){
 853 
 854         if (styleMap == null || styleMap.isEmpty()) return null;
 855 
 856         final Map&lt;String, List&lt;CascadingStyle&gt;&gt; cascadingStyleMap = styleMap.getCascadingStyles();
 857         if (cascadingStyleMap == null || cascadingStyleMap.isEmpty()) return null;
 858 
 859         // Get all of the Styles which may apply to this particular property
 860         List&lt;CascadingStyle&gt; styles = cascadingStyleMap.get(property);
 861 
 862         // If there are no styles for this property then we can just bail
 863         if ((styles == null) || styles.isEmpty()) return null;
 864 
 865         // Go looking for the style. We do this by visiting each CascadingStyle in
 866         // order finding the first that matches the current node &amp; set of
 867         // pseudo-class states. We use an iteration style that avoids creating
 868         // garbage iterators (and wish javac did it for us...)
 869        CascadingStyle style = null;
 870         final int max = (styles == null) ? 0 : styles.size();
 871         for (int i=0; i&lt;max; i++) {
 872             final CascadingStyle s = styles.get(i);
 873             final Selector sel = s == null ? null : s.getSelector();
 874             if (sel == null) continue; // bail if the selector is null.
 875 //System.out.println(node.toString() + &quot;\n\tstates=&quot; + PseudoClassSet.getPseudoClasses(states) + &quot;\n\tstateMatches? &quot; + sel.stateMatches(node, states) + &quot;\n\tsel=&quot; + sel.toString());
 876             if (sel.stateMatches(styleable, states)) {
 877                 style = s;
 878                 break;
 879             }
 880         }
 881 
 882         return style;
 883     }
 884 
 885     /**
 886      * The main workhorse of this class, the lookup method walks up the CSS
 887      * style tree looking for the style information for the Node, the
 888      * property associated with the given styleable, in these states for this font.
 889      *
 890      *
 891      *
 892      *
 893      * @param styleable
 894      * @param states
 895      * @param originatingStyleable
 896      * @return
 897      */
 898     private CalculatedValue lookup(final Styleable styleable,
 899                                    final CssMetaData cssMetaData,
 900                                    final StyleMap styleMap,
 901                                    final Set&lt;PseudoClass&gt; states,
 902                                    final Styleable originatingStyleable,
 903                                    final CalculatedValue cachedFont) {
 904 
 905         if (cssMetaData.getConverter() == FontConverter.getInstance()) {
 906             return lookupFont(styleable, cssMetaData.getProperty(), styleMap, cachedFont);
 907         }
 908 
 909         final String property = cssMetaData.getProperty();
 910 
 911         // Get the CascadingStyle which may apply to this particular property
 912         CascadingStyle style = getStyle(styleable, property, styleMap, states);
 913 
 914         // If no style was found and there are no sub styleables, then there
 915         // are no matching styles for this property. We will then either SKIP
 916         // or we will INHERIT. We will inspect the default value for the styleable,
 917         // and if it is INHERIT then we will inherit otherwise we just skip it.
 918         final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; subProperties = cssMetaData.getSubProperties();
 919         final int numSubProperties = (subProperties != null) ? subProperties.size() : 0;
 920         if (style == null) {
 921 
 922             if (numSubProperties == 0) {
 923 
 924                 return handleNoStyleFound(styleable, cssMetaData,
 925                         styleMap, states, originatingStyleable, cachedFont);
 926 
 927             } else {
 928 
 929                 // If style is null then it means we didn&#39;t successfully find the
 930                 // property we were looking for. However, there might be sub styleables,
 931                 // in which case we should perform a lookup for them. For example,
 932                 // there might not be a style for &quot;font&quot;, but there might be one
 933                 // for &quot;font-size&quot; or &quot;font-weight&quot;. So if the style is null, then
 934                 // we need to check with the sub-styleables.
 935 
 936                 // Build up a list of all SubProperties which have a constituent part.
 937                 // I default the array to be the size of the number of total
 938                 // sub styleables to avoid having the array grow.
 939                 Map&lt;CssMetaData,Object&gt; subs = null;
 940                 StyleOrigin origin = null;
 941 
 942                 boolean isRelative = false;
 943 
 944                 for (int i=0; i&lt;numSubProperties; i++) {
 945                     CssMetaData subkey = subProperties.get(i);
 946                     CalculatedValue constituent =
 947                         lookup(styleable, subkey, styleMap, states,
 948                                 originatingStyleable, cachedFont);
 949                     if (constituent != SKIP) {
 950                         if (subs == null) {
 951                             subs = new HashMap&lt;&gt;();
 952                         }
 953                         subs.put(subkey, constituent.getValue());
 954 
 955                         // origin of this style is the most specific
 956                         if ((origin != null &amp;&amp; constituent.getOrigin() != null)
 957                                 ? origin.compareTo(constituent.getOrigin()) &lt; 0
 958                                 : constituent.getOrigin() != null) {
 959                             origin = constituent.getOrigin();
 960                         }
 961 
 962                         // if the constiuent uses relative sizes, then
 963                         // isRelative is true;
 964                         isRelative = isRelative || constituent.isRelative();
 965 
 966                     }
 967                 }
 968 
 969                 // If there are no subkeys which apply...
 970                 if (subs == null || subs.isEmpty()) {
 971                     return handleNoStyleFound(styleable, cssMetaData,
 972                             styleMap, states, originatingStyleable, cachedFont);
 973                 }
 974 
 975                 try {
 976                     final StyleConverter keyType = cssMetaData.getConverter();
 977                     Object ret = keyType.convert(subs);
 978                     return new CalculatedValue(ret, origin, isRelative);
 979                 } catch (ClassCastException cce) {
 980                     final String msg = formatExceptionMessage(styleable, cssMetaData, null, cce);
 981                     List&lt;CssParser.ParseError&gt; errors = null;
 982                     if ((errors = StyleManager.getErrors()) != null) {
 983                         final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
 984                         errors.add(error);
 985                     }
 986                     if (LOGGER.isLoggable(Level.WARNING)) {
 987                         LOGGER.warning(msg);
 988                         LOGGER.fine(&quot;caught: &quot;, cce);
 989                         LOGGER.fine(&quot;styleable = &quot; + cssMetaData);
 990                         LOGGER.fine(&quot;node = &quot; + styleable.toString());
 991                     }
 992                     return SKIP;
 993                 }
 994             }
 995 
 996         } else { // style != null
 997 
 998             // RT-10522:
 999             // If the user set the property and there is a style and
1000             // the style came from the user agent stylesheet, then
1001             // skip the value. A style from a user agent stylesheet should
1002             // not override the user set style.
1003             if (style.getOrigin() == StyleOrigin.USER_AGENT) {
1004 
1005                 StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(originatingStyleable);
1006                 // if styleableProperty is null, then we&#39;re dealing with a sub-property.
1007                 if (styleableProperty != null &amp;&amp; styleableProperty.getStyleOrigin() == StyleOrigin.USER) {
1008                     return SKIP;
1009                 }
1010             }
1011 
1012             // If there was a style found, then we want to check whether the
1013             // value was &quot;inherit&quot;. If so, then we will simply inherit.
1014             final ParsedValue cssValue = style.getParsedValue();
1015             if (cssValue != null &amp;&amp; &quot;inherit&quot;.equals(cssValue.getValue())) {
1016                 style = getInheritedStyle(styleable, property);
1017                 if (style == null) return SKIP;
1018             }
1019         }
1020 
1021 //        System.out.println(&quot;lookup &quot; + property +
1022 //                &quot;, selector = \&#39;&quot; + style.selector.toString() + &quot;\&#39;&quot; +
1023 //                &quot;, node = &quot; + node.toString());
1024 
1025         return calculateValue(style, styleable, cssMetaData, styleMap, states,
1026                 originatingStyleable, cachedFont);
1027     }
1028 
1029     /**
1030      * Called when there is no style found.
1031      */
1032     private CalculatedValue handleNoStyleFound(final Styleable styleable,
1033                                                final CssMetaData cssMetaData,
1034                                                final StyleMap styleMap, Set&lt;PseudoClass&gt; pseudoClassStates, Styleable originatingStyleable,
1035                                                final CalculatedValue cachedFont) {
1036 
1037         if (cssMetaData.isInherits()) {
1038 
1039 
1040             StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(styleable);
1041             StyleOrigin origin = styleableProperty != null ? styleableProperty.getStyleOrigin() : null;
1042 
1043             // RT-16308: if there is no matching style and the user set
1044             // the property, do not look for inherited styles.
1045             if (origin == StyleOrigin.USER) {
1046 
1047                     return SKIP;
1048 
1049             }
1050 
1051             CascadingStyle style = getInheritedStyle(styleable, cssMetaData.getProperty());
1052             if (style == null) return SKIP;
1053 
1054             CalculatedValue cv =
1055                     calculateValue(style, styleable, cssMetaData,
1056                             styleMap, pseudoClassStates, originatingStyleable,
1057                                    cachedFont);
1058 
1059             return cv;
1060 
1061         } else {
1062 
1063             // Not inherited. There is no style
1064             return SKIP;
1065 
1066         }
1067     }
1068     /**
1069      * Called when we must getInheritedStyle a value from a parent node in the scenegraph.
1070      */
1071     private CascadingStyle getInheritedStyle(
1072             final Styleable styleable,
1073             final String property) {
1074 
1075         Styleable parent = ((Node)styleable).styleHelper.firstStyleableAncestor;
1076         CssStyleHelper parentStyleHelper = getStyleHelper((Node) parent);
1077 
1078         if (parent != null &amp;&amp; parentStyleHelper != null) {
1079 
1080             StyleMap parentStyleMap = parentStyleHelper.getStyleMap(parent);
1081             Set&lt;PseudoClass&gt; transitionStates = ((Node)parent).pseudoClassStates;
1082             CascadingStyle cascadingStyle = parentStyleHelper.getStyle(parent, property, parentStyleMap, transitionStates);
1083 
1084             if (cascadingStyle != null) {
1085 
1086                 final ParsedValue cssValue = cascadingStyle.getParsedValue();
1087 
1088                 if (&quot;inherit&quot;.equals(cssValue.getValue())) {
1089                     return getInheritedStyle(parent, property);
1090                 }
1091                 return cascadingStyle;
1092             }
1093         }
1094 
1095         return null;
1096     }
1097 
1098 
1099     // helps with self-documenting the code
1100     private static final Set&lt;PseudoClass&gt; NULL_PSEUDO_CLASS_STATE = null;
1101 
1102     /**
1103      * Find the property among the styles that pertain to the Node
1104      */
1105     private CascadingStyle resolveRef(final Styleable styleable, final String property, final StyleMap styleMap, final Set&lt;PseudoClass&gt; states) {
1106 
1107         final CascadingStyle style = getStyle(styleable, property, styleMap, states);
1108         if (style != null) {
1109             return style;
1110         } else {
1111             // if style is null, it may be because there isn&#39;t a style for this
1112             // node in this state, or we may need to look up the parent chain
1113             if (states != null &amp;&amp; states.size() &gt; 0) {
1114                 // if states &gt; 0, then we need to check this node again,
1115                 // but without any states.
1116                 return resolveRef(styleable,property, styleMap, NULL_PSEUDO_CLASS_STATE);
1117             } else {
1118                 // TODO: This block was copied from inherit. Both should use same code somehow.
1119 
1120                 Styleable styleableParent = ((Node)styleable).styleHelper.firstStyleableAncestor;
1121                 CssStyleHelper parentStyleHelper = getStyleHelper((Node) styleableParent);
1122 
1123                 if (styleableParent == null || parentStyleHelper == null) {
1124                     return null;
1125                 }
1126 
1127                 StyleMap parentStyleMap = parentStyleHelper.getStyleMap(styleableParent);
1128                 Set&lt;PseudoClass&gt; styleableParentPseudoClassStates =
1129                     styleableParent instanceof Node
1130                         ? ((Node)styleableParent).pseudoClassStates
1131                         : styleable.getPseudoClassStates();
1132 
1133                 return parentStyleHelper.resolveRef(styleableParent, property,
1134                         parentStyleMap, styleableParentPseudoClassStates);
1135             }
1136         }
1137     }
1138 
1139     // to resolve a lookup, we just need to find the parsed value.
1140     private ParsedValue resolveLookups(
1141             final Styleable styleable,
1142             final ParsedValue parsedValue,
1143             final StyleMap styleMap, Set&lt;PseudoClass&gt; states,
1144             final ObjectProperty&lt;StyleOrigin&gt; whence,
1145             Set&lt;ParsedValue&gt; resolves) {
1146 
1147         //
1148         // either the value itself is a lookup, or the value contain a lookup
1149         //
1150         if (parsedValue.isLookup()) {
1151 
1152             // The value we&#39;re looking for should be a Paint, one of the
1153             // containers for linear, radial or ladder, or a derived color.
1154             final Object val = parsedValue.getValue();
1155             if (val instanceof String) {
1156 
1157                 final String sval = ((String) val).toLowerCase(Locale.ROOT);
1158 
1159                 CascadingStyle resolved =
1160                     resolveRef(styleable, sval, styleMap, states);
1161 
1162                 if (resolved != null) {
1163 
1164                     if (resolves.contains(resolved.getParsedValue())) {
1165 
1166                         if (LOGGER.isLoggable(Level.WARNING)) {
1167                             LOGGER.warning(&quot;Loop detected in &quot; + resolved.getRule().toString() + &quot; while resolving &#39;&quot; + sval + &quot;&#39;&quot;);
1168                         }
1169                         throw new IllegalArgumentException(&quot;Loop detected in &quot; + resolved.getRule().toString() + &quot; while resolving &#39;&quot; + sval + &quot;&#39;&quot;);
1170 
1171                     } else {
1172                         resolves.add(parsedValue);
1173                     }
1174 
1175                     // The origin of this parsed value is the greatest of
1176                     // any of the resolved reference. If a resolved reference
1177                     // comes from an inline style, for example, then the value
1178                     // calculated from the resolved lookup should have inline
1179                     // as its origin. Otherwise, an inline style could be
1180                     // stored in shared cache.
1181                     final StyleOrigin wOrigin = whence.get();
1182                     final StyleOrigin rOrigin = resolved.getOrigin();
1183                     if (rOrigin != null &amp;&amp; (wOrigin == null ||  wOrigin.compareTo(rOrigin) &lt; 0)) {
1184                         whence.set(rOrigin);
1185                     }
1186 
1187                     // the resolved value may itself need to be resolved.
1188                     // For example, if the value &quot;color&quot; resolves to &quot;base&quot;,
1189                     // then &quot;base&quot; will need to be resolved as well.
1190                     ParsedValue pv = resolveLookups(styleable, resolved.getParsedValue(), styleMap, states, whence, resolves);
1191 
1192                     if (resolves != null) {
1193                         resolves.remove(parsedValue);
1194                     }
1195 
1196                     return pv;
1197 
1198                 }
1199             }
1200         }
1201 
1202         // If the value doesn&#39;t contain any values that need lookup, then bail
1203         if (!parsedValue.isContainsLookups()) {
1204             return parsedValue;
1205         }
1206 
1207         final Object val = parsedValue.getValue();
1208 
1209         if (val instanceof ParsedValue[][]) {
1210 
1211             // If ParsedValue is a layered sequence of values, resolve the lookups for each.
1212             final ParsedValue[][] layers = (ParsedValue[][])val;
1213             ParsedValue[][] resolved = new ParsedValue[layers.length][0];
1214             for (int l=0; l&lt;layers.length; l++) {
1215                 resolved[l] = new ParsedValue[layers[l].length];
1216                 for (int ll=0; ll&lt;layers[l].length; ll++) {
1217                     if (layers[l][ll] == null) continue;
1218                     resolved[l][ll] =
1219                         resolveLookups(styleable, layers[l][ll], styleMap, states, whence, resolves);
1220                 }
1221             }
1222 
1223             resolves.clear();
1224 
1225             return new ParsedValueImpl(resolved, parsedValue.getConverter(), false);
1226 
1227         } else if (val instanceof ParsedValueImpl[]) {
1228 
1229             // If ParsedValue is a sequence of values, resolve the lookups for each.
1230             final ParsedValue[] layer = (ParsedValue[])val;
1231             ParsedValue[] resolved = new ParsedValue[layer.length];
1232             for (int l=0; l&lt;layer.length; l++) {
1233                 if (layer[l] == null) continue;
1234                 resolved[l] =
1235                     resolveLookups(styleable, layer[l], styleMap, states, whence, resolves);
1236             }
1237 
1238             resolves.clear();
1239 
1240             return new ParsedValueImpl(resolved, parsedValue.getConverter(), false);
1241 
1242         }
1243 
1244         return parsedValue;
1245 
1246     }
1247 
1248     private String getUnresolvedLookup(final ParsedValue resolved) {
1249 
1250         Object value = resolved.getValue();
1251 
1252         if (resolved.isLookup() &amp;&amp; value instanceof String) {
1253             return (String)value;
1254         }
1255 
1256         if (value instanceof ParsedValue[][]) {
1257             final ParsedValue[][] layers = (ParsedValue[][])value;
1258             for (int l=0; l&lt;layers.length; l++) {
1259                 for (int ll=0; ll&lt;layers[l].length; ll++) {
1260                     if (layers[l][ll] == null) continue;
1261                     String unresolvedLookup = getUnresolvedLookup(layers[l][ll]);
1262                     if (unresolvedLookup != null) return unresolvedLookup;
1263                 }
1264             }
1265 
1266         } else if (value instanceof ParsedValue[]) {
1267         // If ParsedValue is a sequence of values, resolve the lookups for each.
1268             final ParsedValue[] layer = (ParsedValue[])value;
1269             for (int l=0; l&lt;layer.length; l++) {
1270                 if (layer[l] == null) continue;
1271                 String unresolvedLookup = getUnresolvedLookup(layer[l]);
1272                 if (unresolvedLookup != null) return unresolvedLookup;
1273             }
1274         }
1275 
1276         return null;
1277     }
1278 
1279     private String formatUnresolvedLookupMessage(Styleable styleable, CssMetaData cssMetaData, Style style, ParsedValue resolved, ClassCastException cce) {
1280 
1281         // Find value that could not be looked up. If the resolved value does not contain lookups, then the
1282         // ClassCastException is not because of trying to convert a String (which is the missing lookup)
1283         // to some value, but is because the convert method got some wrong value - like a paint when it should be a color.
1284         // See RT-33319 for an example of this.
1285         String missingLookup = resolved != null &amp;&amp; resolved.isContainsLookups() ? getUnresolvedLookup(resolved) : null;
1286 
1287         StringBuilder sbuf = new StringBuilder();
1288         if (missingLookup != null) {
1289             sbuf.append(&quot;Could not resolve &#39;&quot;)
1290                     .append(missingLookup)
1291                     .append(&quot;&#39;&quot;)
1292                     .append(&quot; while resolving lookups for &#39;&quot;)
1293                     .append(cssMetaData.getProperty())
1294                     .append(&quot;&#39;&quot;);
1295         } else {
1296             sbuf.append(&quot;Caught &#39;&quot;)
1297                     .append(cce)
1298                     .append(&quot;&#39;&quot;)
1299                     .append(&quot; while converting value for &#39;&quot;)
1300                     .append(cssMetaData.getProperty())
1301                     .append(&quot;&#39;&quot;);
1302         }
1303 
1304         final Rule rule = style != null ? style.getDeclaration().getRule(): null;
1305         final Stylesheet stylesheet = rule != null ? rule.getStylesheet() : null;
1306         final String url = stylesheet != null ? stylesheet.getUrl() : null;
1307         if (url != null) {
1308             sbuf.append(&quot; from rule &#39;&quot;)
1309                 .append(style.getSelector())
1310                 .append(&quot;&#39; in stylesheet &quot;).append(url);
1311         } else if (stylesheet != null &amp;&amp; StyleOrigin.INLINE == stylesheet.getOrigin()) {
1312             sbuf.append(&quot; from inline style on &quot; )
1313                 .append(styleable.toString());
1314         }
1315 
1316         return sbuf.toString();
1317     }
1318 
1319     private String formatExceptionMessage(Styleable styleable, CssMetaData cssMetaData, Style style, Exception e) {
1320 
1321         StringBuilder sbuf = new StringBuilder();
1322         sbuf.append(&quot;Caught &quot;)
1323             .append(String.valueOf(e));
1324 
1325         if (cssMetaData != null) {
1326             sbuf.append(&quot;&#39;&quot;)
1327                 .append(&quot; while calculating value for &#39;&quot;)
1328                 .append(cssMetaData.getProperty())
1329                 .append(&quot;&#39;&quot;);
1330         }
1331 
1332         if (style != null) {
1333 
1334             final Rule rule = style.getDeclaration().getRule();
1335             final Stylesheet stylesheet = rule != null ? rule.getStylesheet() : null;
1336             final String url = stylesheet != null ? stylesheet.getUrl() : null;
1337 
1338             if (url != null) {
1339                 sbuf.append(&quot; from rule &#39;&quot;)
1340                         .append(style.getSelector())
1341                         .append(&quot;&#39; in stylesheet &quot;).append(url);
1342             } else if (styleable != null &amp;&amp; stylesheet != null &amp;&amp; StyleOrigin.INLINE == stylesheet.getOrigin()) {
1343                 sbuf.append(&quot; from inline style on &quot; )
1344                         .append(styleable.toString());
1345             } else {
1346                 sbuf.append(&quot; from style &#39;&quot;)
1347                     .append(String.valueOf(style))
1348                     .append(&quot;&#39;&quot;);
1349             }
1350         }
1351 
1352         return sbuf.toString();
1353     }
1354 
1355 
1356     private CalculatedValue calculateValue(
1357             final CascadingStyle style,
1358             final Styleable styleable,
1359             final CssMetaData cssMetaData,
1360             final StyleMap styleMap, final Set&lt;PseudoClass&gt; states,
1361             final Styleable originatingStyleable,
1362             final CalculatedValue fontFromCacheEntry) {
1363 
1364         final ParsedValue cssValue = style.getParsedValue();
1365         if (cssValue != null &amp;&amp; !(&quot;null&quot;.equals(cssValue.getValue()) || &quot;none&quot;.equals(cssValue.getValue()))) {
1366 
1367             ParsedValue resolved = null;
1368             try {
1369 
1370                 ObjectProperty&lt;StyleOrigin&gt; whence = new SimpleObjectProperty&lt;&gt;(style.getOrigin());
1371                 resolved = resolveLookups(styleable, cssValue, styleMap, states, whence, new HashSet&lt;&gt;());
1372 
1373                 final String property = cssMetaData.getProperty();
1374 
1375                 // The computed value
1376                 Object val = null;
1377                 boolean isFontProperty =
1378                         &quot;-fx-font&quot;.equals(property) ||
1379                         &quot;-fx-font-size&quot;.equals(property);
1380 
1381                 boolean isRelative = ParsedValueImpl.containsFontRelativeSize(resolved, isFontProperty);
1382 
1383                 //
1384                 // Avoid using a font calculated from a relative size
1385                 // to calculate a font with a relative size.
1386                 // For example:
1387                 // Assume the default font size is 13 and we have a style with
1388                 // -fx-font-size: 1.5em, then the cacheEntry font value will
1389                 // have a size of 13*1.5=19.5.
1390                 // Now, when converting that same font size again in response
1391                 // to looking up a value for -fx-font, we do not want to use
1392                 // 19.5 as the font for relative size conversion since this will
1393                 // yield a font 19.5*1.5=29.25 when really what we want is
1394                 // a font size of 19.5.
1395                 // In this situation, then, we use the font from the parent&#39;s
1396                 // cache entry.
1397                 Font fontForFontRelativeSizes = null;
1398 
1399                 if (isRelative &amp;&amp; isFontProperty &amp;&amp;
1400                     (fontFromCacheEntry == null || fontFromCacheEntry.isRelative())) {
1401 
1402                     Styleable parent = styleable;
1403                     CalculatedValue childsCachedFont = fontFromCacheEntry;
1404                     do {
1405 
1406                         CalculatedValue parentsCachedFont = getCachedFont(parent.getStyleableParent());
1407 
1408                         if (parentsCachedFont != null)  {
1409 
1410                             if (parentsCachedFont.isRelative()) {
1411 
1412                                 //
1413                                 // If the cached fonts are the same, then the cached font came from the same
1414                                 // style and we need to keep looking. Otherwise, use the font we found.
1415                                 //
1416                                 if (childsCachedFont == null || parentsCachedFont.equals(childsCachedFont)) {
1417                                     childsCachedFont = parentsCachedFont;
1418                                 } else {
1419                                     fontForFontRelativeSizes = (Font)parentsCachedFont.getValue();
1420                                 }
1421 
1422                             } else  {
1423                                 // fontValue.isRelative() == false!
1424                                 fontForFontRelativeSizes = (Font)parentsCachedFont.getValue();
1425                             }
1426 
1427                         }
1428 
1429                     } while(fontForFontRelativeSizes == null &amp;&amp;
1430                             (parent = parent.getStyleableParent()) != null);
1431                 }
1432 
1433                 // did we get a fontValue from the preceding block?
1434                 // if not, get it from our cacheEntry or choose the default
1435                 if (fontForFontRelativeSizes == null) {
1436                     if (fontFromCacheEntry != null &amp;&amp; fontFromCacheEntry.isRelative() == false) {
1437                         fontForFontRelativeSizes = (Font)fontFromCacheEntry.getValue();
1438                     } else {
1439                         fontForFontRelativeSizes = Font.getDefault();
1440                     }
1441                 }
1442 
1443                 final StyleConverter cssMetaDataConverter = cssMetaData.getConverter();
1444                 // RT-37727 - handling of properties that are insets is wonky. If the property is -fx-inset, then
1445                 // there isn&#39;t an issue because the converter assigns the InsetsConverter to the ParsedValue.
1446                 // But -my-insets will parse as an array of numbers and the parser will assign the Size sequence
1447                 // converter to it. So, if the CssMetaData says it uses InsetsConverter, use the InsetsConverter
1448                 // and not the parser assigned converter.
1449                 if (cssMetaDataConverter == StyleConverter.getInsetsConverter()) {
1450                     if (resolved.getValue() instanceof ParsedValue) {
1451                         // If you give the parser &quot;-my-insets: 5;&quot; you end up with a ParsedValue&lt;ParsedValue&lt;?,Size&gt;, Number&gt;
1452                         // and not a ParsedValue&lt;ParsedValue[], Number[]&gt; so here we wrap the value into an array
1453                         // to make the InsetsConverter happy.
1454                         resolved = new ParsedValueImpl(new ParsedValue[] {(ParsedValue)resolved.getValue()}, null, false);
1455                     }
1456                     val = cssMetaDataConverter.convert(resolved, fontForFontRelativeSizes);
1457                 }
1458                 else if (resolved.getConverter() != null)
1459                     val = resolved.convert(fontForFontRelativeSizes);
1460                 else
1461                     val = cssMetaData.getConverter().convert(resolved, fontForFontRelativeSizes);
1462 
1463                 final StyleOrigin origin = whence.get();
1464                 return new CalculatedValue(val, origin, isRelative);
1465 
1466             } catch (ClassCastException cce) {
1467                 final String msg = formatUnresolvedLookupMessage(styleable, cssMetaData, style.getStyle(),resolved, cce);
1468                 List&lt;CssParser.ParseError&gt; errors = null;
1469                 if ((errors = StyleManager.getErrors()) != null) {
1470                     final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
1471                     errors.add(error);
1472                 }
1473                 if (LOGGER.isLoggable(Level.WARNING)) {
1474                     LOGGER.warning(msg);
1475                     LOGGER.fine(&quot;node = &quot; + styleable.toString());
1476                     LOGGER.fine(&quot;cssMetaData = &quot; + cssMetaData);
1477                     LOGGER.fine(&quot;styles = &quot; + getMatchingStyles(styleable, cssMetaData));
1478                 }
1479                 return SKIP;
1480             } catch (IllegalArgumentException iae) {
1481                 final String msg = formatExceptionMessage(styleable, cssMetaData, style.getStyle(), iae);
1482                 List&lt;CssParser.ParseError&gt; errors = null;
1483                 if ((errors = StyleManager.getErrors()) != null) {
1484                     final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
1485                     errors.add(error);
1486                 }
1487                 if (LOGGER.isLoggable(Level.WARNING)) {
1488                     LOGGER.warning(msg);
1489                     LOGGER.fine(&quot;caught: &quot;, iae);
1490                     LOGGER.fine(&quot;styleable = &quot; + cssMetaData);
1491                     LOGGER.fine(&quot;node = &quot; + styleable.toString());
1492                 }
1493                 return SKIP;
1494             } catch (NullPointerException npe) {
1495                 final String msg = formatExceptionMessage(styleable, cssMetaData, style.getStyle(), npe);
1496                 List&lt;CssParser.ParseError&gt; errors = null;
1497                 if ((errors = StyleManager.getErrors()) != null) {
1498                     final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
1499                     errors.add(error);
1500                 }
1501                 if (LOGGER.isLoggable(Level.WARNING)) {
1502                     LOGGER.warning(msg);
1503                     LOGGER.fine(&quot;caught: &quot;, npe);
1504                     LOGGER.fine(&quot;styleable = &quot; + cssMetaData);
1505                     LOGGER.fine(&quot;node = &quot; + styleable.toString());
1506                 }
1507                 return SKIP;
1508             }
1509 
1510         }
1511         // either cssValue was null or cssValue&#39;s value was &quot;null&quot; or &quot;none&quot;
1512         return new CalculatedValue(null, style.getOrigin(), false);
1513 
1514     }
1515 
1516     private static final CssMetaData dummyFontProperty =
1517             new FontCssMetaData&lt;Node&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1518 
1519         @Override
1520         public boolean isSettable(Node node) {
1521             return true;
1522         }
1523 
1524         @Override
1525         public StyleableProperty&lt;Font&gt; getStyleableProperty(Node node) {
1526             return null;
1527         }
1528     };
1529 
1530     private CalculatedValue getCachedFont(final Styleable styleable) {
1531 
1532         if (styleable instanceof Node == false) return null;
1533 
1534         CalculatedValue cachedFont = null;
1535 
1536         Node parent = (Node)styleable;
1537 
1538         final CssStyleHelper parentHelper = parent.styleHelper;
1539 
1540         // if there is no parentHelper,
1541         // or there is a parentHelper but no cacheContainer,
1542         // then look to the next parent
1543         if (parentHelper == null || parentHelper.cacheContainer == null) {
1544 
1545             cachedFont = getCachedFont(parent.getStyleableParent());
1546 
1547         // there is a parent helper and a cacheContainer,
1548         } else  {
1549 
1550             CacheContainer parentCacheContainer = parentHelper.cacheContainer;
1551             if ( parentCacheContainer != null
1552                     &amp;&amp; parentCacheContainer.fontSizeCache != null
1553                     &amp;&amp; parentCacheContainer.fontSizeCache.isEmpty() == false) {
1554 
1555                 Set&lt;PseudoClass&gt;[] transitionStates = parentHelper.getTransitionStates(parent);
1556                 StyleCacheEntry.Key parentCacheEntryKey = new StyleCacheEntry.Key(transitionStates, Font.getDefault());
1557                 cachedFont = parentCacheContainer.fontSizeCache.get(parentCacheEntryKey);
1558             }
1559 
1560             if (cachedFont == null)  {
1561                 StyleMap smap = parentHelper.getStyleMap(parent);
1562                 cachedFont = parentHelper.lookupFont(parent, &quot;-fx-font&quot;, smap, null);
1563             }
1564         }
1565 
1566         return cachedFont != SKIP ? cachedFont : null;
1567     }
1568 
1569     /*package access for testing*/ FontPosture getFontPosture(Font font) {
1570         if (font == null) return FontPosture.REGULAR;
1571 
1572         String fontName = font.getName().toLowerCase(Locale.ROOT);
1573 
1574         if (fontName.contains(&quot;italic&quot;)) {
1575             return FontPosture.ITALIC;
1576         }
1577 
1578         return FontPosture.REGULAR;
1579     }
1580 
1581     /*package access for testing*/ FontWeight getFontWeight(Font font) {
1582         if (font == null) return FontWeight.NORMAL;
1583 
1584         String fontName = font.getName().toLowerCase(Locale.ROOT);
1585 
1586         if (fontName.contains(&quot;bold&quot;)) {
1587             if (fontName.contains(&quot;extra&quot;)) return FontWeight.EXTRA_BOLD;
1588             if (fontName.contains(&quot;ultra&quot;)) return FontWeight.EXTRA_BOLD;
1589             else if (fontName.contains(&quot;semi&quot;)) return FontWeight.SEMI_BOLD;
1590             else if (fontName.contains(&quot;demi&quot;)) return FontWeight.SEMI_BOLD;
1591             else return FontWeight.BOLD;
1592 
1593         } else if (fontName.contains(&quot;light&quot;)) {
1594             if (fontName.contains(&quot;extra&quot;)) return FontWeight.EXTRA_LIGHT;
1595             if (fontName.contains(&quot;ultra&quot;)) return FontWeight.EXTRA_LIGHT;
1596             else return FontWeight.LIGHT;
1597 
1598         } else if (fontName.contains(&quot;black&quot;)) {
1599             return FontWeight.BLACK;
1600 
1601         } else if (fontName.contains(&quot;heavy&quot;)) {
1602             return FontWeight.BLACK;
1603 
1604         } else if (fontName.contains(&quot;medium&quot;)) {
1605             return FontWeight.MEDIUM;
1606         }
1607 
1608         return FontWeight.NORMAL;
1609 
1610     }
1611 
1612     /*package access for testing*/ String getFontFamily(Font font) {
1613         if (font == null) return Font.getDefault().getFamily();
1614         return font.getFamily();
1615     }
1616 
1617 
1618     /*package access for testing*/ Font deriveFont(
1619             Font font,
1620             String fontFamily,
1621             FontWeight fontWeight,
1622             FontPosture fontPosture,
1623             double fontSize) {
1624 
1625         if (font != null &amp;&amp; fontFamily == null) fontFamily = getFontFamily(font);
1626         else if (fontFamily != null) fontFamily = Utils.stripQuotes(fontFamily);
1627 
1628         if (font != null &amp;&amp; fontWeight == null) fontWeight = getFontWeight(font);
1629         if (font != null &amp;&amp; fontPosture == null) fontPosture = getFontPosture(font);
1630         if (font != null &amp;&amp; fontSize &lt;= 0) fontSize = font.getSize();
1631 
1632         return  Font.font(
1633                 fontFamily,
1634                 fontWeight,
1635                 fontPosture,
1636                 fontSize);
1637     }
1638 
1639     /**
1640      * Look up a font property. This is handled separately from lookup since
1641      * font is inherited and has sub-properties. One should expect that the
1642      * text font for the following would be 16px Arial. The lookup method would
1643      * give 16px system since it would look &lt;em&gt;only&lt;/em&gt; for font-size,
1644      * font-family, etc &lt;em&gt;only&lt;/em&gt; if the lookup on font failed.
1645      * &lt;pre&gt;
1646      * Text text = new Text(&quot;Hello World&quot;);
1647      * text.setStyle(&quot;-fx-font-size: 16px;&quot;);
1648      * Group group = new Group();
1649      * group.setStyle(&quot;-fx-font: 12px Arial;&quot;);
1650      * group.getChildren().add(text);
1651      * &lt;/pre&gt;
1652      */
1653      /*package access for testing*/ CalculatedValue lookupFont(
1654             final Styleable styleable,
1655             final String property,
1656             final StyleMap styleMap,
1657             final CalculatedValue cachedFont)
1658     {
1659 
1660         StyleOrigin origin = null;
1661 
1662         // How far from this node did we travel to find a font shorthand?
1663         // Don&#39;t look past this distance for other font properties.
1664         int distance = 0;
1665 
1666         // Did we find a style?
1667         boolean foundStyle = false;
1668 
1669         String family = null;
1670         double size = -1;
1671         FontWeight weight = null;
1672         FontPosture posture = null;
1673 
1674         CalculatedValue cvFont = cachedFont;
1675 
1676 
1677         Set&lt;PseudoClass&gt; states = styleable instanceof Node ? ((Node)styleable).pseudoClassStates : styleable.getPseudoClassStates();
1678 
1679         // RT-20145 - if looking for font size and the node has a font,
1680         // use the font property&#39;s value if it was set by the user and
1681         // there is not an inline or author style.
1682 
1683         if (cacheContainer.fontProp != null) {
1684             StyleableProperty&lt;Font&gt; styleableProp = cacheContainer.fontProp.getStyleableProperty(styleable);
1685             StyleOrigin fpOrigin = styleableProp.getStyleOrigin();
1686             Font font = styleableProp.getValue();
1687             if (font == null) font = Font.getDefault();
1688             if (fpOrigin == StyleOrigin.USER) {
1689                 origin = fpOrigin;
1690                 family = getFontFamily(font);
1691                 size = font.getSize();
1692                 weight = getFontWeight(font);
1693                 posture = getFontPosture(font);
1694                 cvFont = new CalculatedValue(font, fpOrigin, false);
1695             }
1696         }
1697 
1698         CalculatedValue parentCachedFont = getCachedFont(styleable.getStyleableParent());
1699         if (parentCachedFont == null) parentCachedFont = new CalculatedValue(Font.getDefault(), null, false);
1700 
1701         //
1702         // Look up the font- properties
1703         //
1704         CascadingStyle fontShorthand = getStyle(styleable, property, styleMap, states);
1705 
1706         // don&#39;t look past current node for font shorthand if user set the font
1707         if (fontShorthand == null &amp;&amp; origin != StyleOrigin.USER) {
1708 
1709             Styleable parent = styleable != null ? styleable.getStyleableParent() : null;
1710 
1711             while (parent != null) { // This loop traverses through all ancestors till root
1712 
1713                 CssStyleHelper parentStyleHelper = parent instanceof Node ? ((Node)parent).styleHelper : null;
1714                 if (parentStyleHelper != null) {
1715 
1716                     distance += 1;
1717 
1718                     StyleMap parentStyleMap = parentStyleHelper.getStyleMap(parent);
1719                     Set&lt;PseudoClass&gt; transitionStates = ((Node)parent).pseudoClassStates;
1720                     CascadingStyle cascadingStyle = parentStyleHelper.getStyle(parent, property, parentStyleMap, transitionStates);
1721 
1722                     if (cascadingStyle != null) {
1723 
1724                         final ParsedValue cssValue = cascadingStyle.getParsedValue();
1725 
1726                         if (&quot;inherit&quot;.equals(cssValue.getValue()) == false) {
1727                             fontShorthand = cascadingStyle;
1728                             break;
1729                         }
1730                     }
1731 
1732                 }
1733 
1734                 parent = parent.getStyleableParent();
1735 
1736             }
1737 
1738         }
1739 
1740         if (fontShorthand != null) {
1741 
1742             //
1743             // If we don&#39;t have an existing font, or if the origin of the
1744             // existing font is less than that of the shorthand, then
1745             // take the shorthand. If the origins compare equals, then take
1746             // the shorthand since the fontProp value will not have been
1747             // updated yet.
1748             //
1749             if (origin == null || origin.compareTo(fontShorthand.getOrigin()) &lt;= 0) {
1750 
1751                 final CalculatedValue cv =
1752                         calculateValue(fontShorthand, styleable, dummyFontProperty,
1753                                 styleMap, states, styleable, parentCachedFont);
1754 
1755                 // cv could be SKIP
1756                 if (cv.getValue() instanceof Font) {
1757                     origin = cv.getOrigin();
1758                     Font font = (Font)cv.getValue();
1759                     family = getFontFamily(font);
1760                     size = font.getSize();
1761                     weight = getFontWeight(font);
1762                     posture = getFontPosture(font);
1763                     cvFont = cv;
1764                     foundStyle = true;
1765                 }
1766 
1767             }
1768         }
1769 
1770         CascadingStyle fontSize = getStyle(styleable, property.concat(&quot;-size&quot;), styleMap, states);
1771         if (fontSize != null) {
1772             // if we have a font shorthand and it is more specific than font-size, then don&#39;t use the font-size style
1773             if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontSize) &lt; 0) {
1774                 fontSize = null;
1775             } else if (origin == StyleOrigin.USER) {
1776                 // If fontSize is an inline or author-stylesheet style, use it.
1777                 // Otherwise, fontSize is a user-agent stylesheet style and should not override the USER style.
1778                 if (StyleOrigin.USER.compareTo(fontSize.getOrigin()) &gt; 0) {
1779                     fontSize = null;
1780                 }
1781             }
1782         } else if (origin != StyleOrigin.USER) {
1783             //
1784             // If we don&#39;t have a font-size, see if there is an inherited font-size.
1785             // If lookupInheritedFontProperty returns other than null, then we know that font-size is closer (more specific)
1786             // than the font shorthand
1787             //
1788             fontSize = lookupInheritedFontProperty(styleable, property.concat(&quot;-size&quot;), styleMap, distance, fontShorthand);
1789         }
1790 
1791         if (fontSize != null) {
1792 
1793             // The logic above ensures that, if fontSize is not null, then it is either
1794             // 1) a style matching this node and is more specific than the font shorthand or
1795             // 2) an inherited style that is more specific than the font shorthand
1796             // and, therefore, we can use the fontSize style
1797 
1798             final CalculatedValue cv =
1799                     calculateValue(fontSize, styleable, dummyFontProperty,
1800                             styleMap, states, styleable, parentCachedFont);
1801 
1802             if (cv.getValue() instanceof Double) {
1803                 if (origin == null || origin.compareTo(fontSize.getOrigin()) &lt;= 0) {
1804 
1805                     origin = cv.getOrigin();
1806                 }
1807                 size = (Double) cv.getValue();
1808 
1809                 if (cvFont != null) {
1810                     boolean isRelative = cvFont.isRelative() || cv.isRelative();
1811                     Font font = deriveFont((Font) cvFont.getValue(), family, weight, posture, size);
1812                     cvFont = new CalculatedValue(font, origin, isRelative);
1813                 } else {
1814                     boolean isRelative = cv.isRelative();
1815                     Font font = deriveFont(Font.getDefault(), family, weight, posture, size);
1816                     cvFont = new CalculatedValue(font, origin, isRelative);
1817                 }
1818                 foundStyle = true;
1819             }
1820 
1821         }
1822 
1823         // if cachedFont is null, then we&#39;re in this method to look up a font for the CacheContainer&#39;s fontSizeCache
1824         // and we only care about font-size or the size from font shorthand.
1825         if (cachedFont == null) {
1826             return (cvFont != null) ? cvFont : SKIP;
1827         }
1828 
1829         CascadingStyle fontWeight = getStyle(styleable, property.concat(&quot;-weight&quot;), styleMap, states);
1830         if (fontWeight != null) {
1831             // if we have a font shorthand and it is more specific than font-weight, then don&#39;t use the font-weight style
1832             if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontWeight) &lt; 0) {
1833                 fontWeight = null;
1834             }
1835 
1836         } else if (origin != StyleOrigin.USER) {
1837             //
1838             // If we don&#39;t have a font-weight, see if there is an inherited font-weight.
1839             // If lookupInheritedFontProperty returns other than null, then we know that font-weight is closer (more specific)
1840             // than the font shorthand
1841             //
1842             fontWeight = lookupInheritedFontProperty(styleable, property.concat(&quot;-weight&quot;), styleMap, distance, fontShorthand);
1843         }
1844 
1845         if (fontWeight != null) {
1846 
1847             // The logic above ensures that, if fontWeight is not null, then it is either
1848             // 1) a style matching this node and is more specific than the font shorthand or
1849             // 2) an inherited style that is more specific than the font shorthand
1850             // and, therefore, we can use the fontWeight style
1851 
1852             final CalculatedValue cv =
1853                     calculateValue(fontWeight, styleable, dummyFontProperty,
1854                             styleMap, states, styleable, null);
1855 
1856             if (cv.getValue() instanceof FontWeight) {
1857                 if (origin == null || origin.compareTo(fontWeight.getOrigin()) &lt;= 0) {
1858                     origin = cv.getOrigin();
1859                 }
1860                 weight = (FontWeight)cv.getValue();
1861                 foundStyle = true;
1862             }
1863         }
1864 
1865 
1866         CascadingStyle fontStyle = getStyle(styleable, property.concat(&quot;-style&quot;), styleMap, states);
1867         if (fontStyle != null) {
1868             // if we have a font shorthand and it is more specific than font-style, then don&#39;t use the font-style style
1869             if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontStyle) &lt; 0) {
1870                 fontStyle = null;
1871             }
1872 
1873         } else if (origin != StyleOrigin.USER) {
1874             //
1875             // If we don&#39;t have a font-style, see if there is an inherited font-style.
1876             // If lookupInheritedFontProperty returns other than null, then we know that font-style is closer (more specific)
1877             // than the font shorthand
1878             //
1879             fontStyle = lookupInheritedFontProperty(styleable, property.concat(&quot;-style&quot;), styleMap, distance, fontShorthand);
1880         }
1881 
1882         if (fontStyle != null) {
1883 
1884             // The logic above ensures that, if fontStyle is not null, then it is either
1885             // 1) a style matching this node and is more specific than the font shorthand or
1886             // 2) an inherited style that is more specific than the font shorthand
1887             // and, therefore, we can use the fontStyle style
1888 
1889             final CalculatedValue cv =
1890                     calculateValue(fontStyle, styleable, dummyFontProperty,
1891                             styleMap, states, styleable, null);
1892 
1893             if (cv.getValue() instanceof FontPosture) {
1894                 if (origin == null || origin.compareTo(fontStyle.getOrigin()) &lt;= 0) {
1895                     origin = cv.getOrigin();
1896                 }
1897                 posture = (FontPosture)cv.getValue();
1898                 foundStyle = true;
1899             }
1900 
1901         }
1902 
1903         CascadingStyle fontFamily = getStyle(styleable, property.concat(&quot;-family&quot;), styleMap, states);
1904         if (fontFamily != null) {
1905             // if we have a font shorthand and it is more specific than font-family, then don&#39;t use the font-family style
1906             if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontFamily) &lt; 0) {
1907                 fontFamily = null;
1908             }
1909 
1910         } else if (origin != StyleOrigin.USER) {
1911             //
1912             // If we don&#39;t have a font-family, see if there is an inherited font-family.
1913             // If lookupInheritedFontProperty returns other than null, then we know that font-family is closer (more specific)
1914             // than the font shorthand
1915             //
1916             fontFamily = lookupInheritedFontProperty(styleable, property.concat(&quot;-family&quot;), styleMap, distance, fontShorthand);
1917         }
1918 
1919         if (fontFamily != null) {
1920 
1921             // The logic above ensures that, if fontFamily is not null, then it is either
1922             // 1) a style matching this node and is more specific than the font shorthand or
1923             // 2) an inherited style that is more specific than the font shorthand
1924             // and, therefore, we can use the fontFamily style
1925 
1926             final CalculatedValue cv =
1927                     calculateValue(fontFamily, styleable, dummyFontProperty,
1928                             styleMap, states, styleable, null);
1929 
1930             if (cv.getValue() instanceof String) {
1931                 if (origin == null || origin.compareTo(fontFamily.getOrigin()) &lt;= 0) {
1932                     origin = cv.getOrigin();
1933                 }
1934                 family = (String)cv.getValue();
1935                 foundStyle = true;
1936             }
1937 
1938         }
1939 
1940         if (foundStyle) {
1941 
1942             Font font = cvFont != null ? (Font)cvFont.getValue() : Font.getDefault();
1943             Font derivedFont = deriveFont(font, family, weight, posture, size);
1944             return new CalculatedValue(derivedFont,origin,false);
1945 
1946         }
1947 
1948         return SKIP;
1949     }
1950 
1951     private CascadingStyle lookupInheritedFontProperty(
1952             final Styleable styleable,
1953             final String property,
1954             final StyleMap styleMap,
1955             final int distance,
1956             CascadingStyle fontShorthand) {
1957 
1958         Styleable parent = styleable != null ? styleable.getStyleableParent() : null;
1959 
1960         int nlooks = distance;
1961         while (parent != null &amp;&amp; nlooks &gt; 0) { // This loop traverses through all ancestors till root
1962 
1963             CssStyleHelper parentStyleHelper = parent instanceof Node ? ((Node)parent).styleHelper : null;
1964             if (parentStyleHelper != null) {
1965 
1966                 nlooks -= 1;
1967 
1968                 StyleMap parentStyleMap = parentStyleHelper.getStyleMap((parent));
1969                 Set&lt;PseudoClass&gt; transitionStates = ((Node)parent).pseudoClassStates;
1970                 CascadingStyle cascadingStyle = parentStyleHelper.getStyle(parent, property, parentStyleMap, transitionStates);
1971 
1972                 if (cascadingStyle != null) {
1973 
1974                     // If we are closer to the node than the font shorthand, then font shorthand doesn&#39;t matter.
1975                     // If the font shorthand and this style are the same distance, then we need to compare.
1976                     if (fontShorthand != null &amp;&amp; nlooks == 0) {
1977                         if (fontShorthand.compareTo(cascadingStyle) &lt; 0) {
1978                             return null;
1979                         }
1980                     }
1981 
1982                     final ParsedValue cssValue = cascadingStyle.getParsedValue();
1983 
1984                     if (&quot;inherit&quot;.equals(cssValue.getValue()) == false) {
1985                         return cascadingStyle;
1986                     }
1987                 }
1988 
1989             }
1990 
1991             parent = parent.getStyleableParent();
1992 
1993         }
1994 
1995         return null;
1996     }
1997 
1998 
1999     /**
2000      * Called from Node NodeHelper.getMatchingStyles
2001      * @param styleable
2002      * @param styleableProperty
2003      * @return
2004      */
2005     static List&lt;Style&gt; getMatchingStyles(final Styleable styleable, final CssMetaData styleableProperty) {
2006 
2007         if (!(styleable instanceof Node)) return Collections.&lt;Style&gt;emptyList();
2008 
2009         Node node = (Node)styleable;
2010         final CssStyleHelper helper = (node.styleHelper != null) ? node.styleHelper : createStyleHelper(node);
2011 
2012         if (helper != null) {
2013             return helper.getMatchingStyles(node, styleableProperty, false);
2014         }
2015         else {
2016             return Collections.&lt;Style&gt;emptyList();
2017         }
2018     }
2019 
2020     static Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; getMatchingStyles(Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; map, final Node node) {
2021 
2022         final CssStyleHelper helper = (node.styleHelper != null) ? node.styleHelper : createStyleHelper(node);
2023         if (helper != null) {
2024             if (map == null) map = new HashMap&lt;&gt;();
2025             for (CssMetaData metaData : node.getCssMetaData()) {
2026                 List&lt;Style&gt; styleList = helper.getMatchingStyles(node, metaData, true);
2027                 if (styleList != null &amp;&amp; !styleList.isEmpty()) {
2028                     StyleableProperty prop = metaData.getStyleableProperty(node);
2029                     map.put(prop, styleList);
2030                 }
2031             }
2032         }
2033 
2034         if (node instanceof Parent) {
2035             for (Node child : ((Parent)node).getChildren()) {
2036                 map = getMatchingStyles(map, child);
2037             }
2038         }
2039 
2040         return map;
2041     }
2042 
2043     private List&lt;Style&gt; getMatchingStyles(final Styleable node, final CssMetaData styleableProperty, boolean matchState) {
2044 
2045         final List&lt;CascadingStyle&gt; styleList = new ArrayList&lt;&gt;();
2046 
2047         getMatchingStyles(node, styleableProperty, styleList, matchState);
2048 
2049         List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; subProperties = styleableProperty.getSubProperties();
2050         if (subProperties != null) {
2051             for (int n=0,nMax=subProperties.size(); n&lt;nMax; n++) {
2052                 final CssMetaData subProperty = subProperties.get(n);
2053                 getMatchingStyles(node, subProperty, styleList, matchState);
2054             }
2055         }
2056 
2057         Collections.sort(styleList);
2058 
2059         final List&lt;Style&gt; matchingStyles = new ArrayList&lt;&gt;(styleList.size());
2060         for (int n=0,nMax=styleList.size(); n&lt;nMax; n++) {
2061             final Style style = styleList.get(n).getStyle();
2062             if (!matchingStyles.contains(style)) matchingStyles.add(style);
2063         }
2064 
2065         return matchingStyles;
2066     }
2067 
2068     private void getMatchingStyles(final Styleable node, final CssMetaData styleableProperty, final List&lt;CascadingStyle&gt; styleList, boolean matchState) {
2069 
2070         if (node != null) {
2071 
2072             String property = styleableProperty.getProperty();
2073             Node _node = node instanceof Node ? (Node)node : null;
2074             final StyleMap smap = getStyleMap(_node);
2075             if (smap == null) return;
2076 
2077             if (matchState) {
2078                 CascadingStyle cascadingStyle = getStyle(node, styleableProperty.getProperty(), smap, _node.pseudoClassStates);
2079                 if (cascadingStyle != null) {
2080                     styleList.add(cascadingStyle);
2081                     final ParsedValue parsedValue = cascadingStyle.getParsedValue();
2082                     getMatchingLookupStyles(node, parsedValue, styleList, matchState);
2083                 }
2084             }  else {
2085 
2086                 Map&lt;String, List&lt;CascadingStyle&gt;&gt; cascadingStyleMap = smap.getCascadingStyles();
2087                 // StyleMap.getCascadingStyles() does not return null
2088                 List&lt;CascadingStyle&gt; styles = cascadingStyleMap.get(property);
2089 
2090                 if (styles != null) {
2091                     styleList.addAll(styles);
2092                     for (int n=0, nMax=styles.size(); n&lt;nMax; n++) {
2093                         final CascadingStyle style = styles.get(n);
2094                         final ParsedValue parsedValue = style.getParsedValue();
2095                         getMatchingLookupStyles(node, parsedValue, styleList, matchState);
2096                     }
2097                 }
2098             }
2099 
2100             if (styleableProperty.isInherits()) {
2101                 Styleable parent = node.getStyleableParent();
2102                 while (parent != null) { // This loop traverses through all ancestors till root
2103                     CssStyleHelper parentHelper = parent instanceof Node
2104                             ? ((Node)parent).styleHelper
2105                             : null;
2106                     if (parentHelper != null) {
2107                         parentHelper.getMatchingStyles(parent, styleableProperty, styleList, matchState);
2108                     }
2109                     parent = parent.getStyleableParent();
2110                 }
2111             }
2112 
2113         }
2114 
2115     }
2116 
2117     // Pretty much a duplicate of resolveLookups, but without the state
2118     private void getMatchingLookupStyles(final Styleable node, final ParsedValue parsedValue, final List&lt;CascadingStyle&gt; styleList, boolean matchState) {
2119 
2120         if (parsedValue.isLookup()) {
2121 
2122             Object value = parsedValue.getValue();
2123 
2124             if (value instanceof String) {
2125 
2126                 final String property = (String)value;
2127                 // gather up any and all styles that contain this value as a property
2128                 Styleable parent = node;
2129                 do {
2130 
2131                     final Node _parent = parent instanceof Node ? (Node)parent : null;
2132                     final CssStyleHelper helper = _parent != null
2133                             ? _parent.styleHelper
2134                             : null;
2135                     if (helper != null) {
2136 
2137                         StyleMap styleMap = helper.getStyleMap(parent);
2138                         if (styleMap == null || styleMap.isEmpty()) continue;
2139 
2140                         final int start = styleList.size();
2141 
2142                         if (matchState) {
2143                             CascadingStyle cascadingStyle = helper.resolveRef(_parent, property, styleMap, _parent.pseudoClassStates);
2144                             if (cascadingStyle != null) {
2145                                 styleList.add(cascadingStyle);
2146                             }
2147                         } else {
2148                             final Map&lt;String, List&lt;CascadingStyle&gt;&gt; smap = styleMap.getCascadingStyles();
2149                             // getCascadingStyles does not return null
2150                             List&lt;CascadingStyle&gt; styles = smap.get(property);
2151 
2152                             if (styles != null) {
2153                                 styleList.addAll(styles);
2154                             }
2155 
2156                         }
2157 
2158                         final int end = styleList.size();
2159 
2160                         for (int index=start; index&lt;end; index++) {
2161                             final CascadingStyle style = styleList.get(index);
2162                             getMatchingLookupStyles(parent, style.getParsedValue(), styleList, matchState);
2163                         }
2164                     }
2165 
2166                 } while ((parent = parent.getStyleableParent()) != null); // This loop traverses through all ancestors till root
2167 
2168             }
2169         }
2170 
2171         // If the value doesn&#39;t contain any values that need lookup, then bail
2172         if (!parsedValue.isContainsLookups()) {
2173             return;
2174         }
2175 
2176         final Object val = parsedValue.getValue();
2177         if (val instanceof ParsedValue[][]) {
2178         // If ParsedValue is a layered sequence of values, resolve the lookups for each.
2179             final ParsedValue[][] layers = (ParsedValue[][])val;
2180             for (int l=0; l&lt;layers.length; l++) {
2181                 for (int ll=0; ll&lt;layers[l].length; ll++) {
2182                     if (layers[l][ll] == null) continue;
2183                         getMatchingLookupStyles(node, layers[l][ll], styleList, matchState);
2184                 }
2185             }
2186 
2187         } else if (val instanceof ParsedValue[]) {
2188         // If ParsedValue is a sequence of values, resolve the lookups for each.
2189             final ParsedValue[] layer = (ParsedValue[])val;
2190             for (int l=0; l&lt;layer.length; l++) {
2191                 if (layer[l] == null) continue;
2192                     getMatchingLookupStyles(node, layer[l], styleList, matchState);
2193             }
2194         }
2195 
2196     }
2197 
2198 }
    </pre>
  </body>
</html>