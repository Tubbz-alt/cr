<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.swing/src/main/java/javafx/embed/swing/JFXPanel.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.embed.swing;
  27 
  28 import java.awt.AlphaComposite;
  29 import java.awt.Component;
  30 import java.awt.Cursor;
  31 import java.awt.Dimension;
  32 import java.awt.Graphics;
  33 import java.awt.Graphics2D;
  34 import java.awt.KeyboardFocusManager;
  35 import java.awt.Point;
  36 import java.awt.Window;
  37 import java.awt.Insets;
  38 import java.awt.EventQueue;
  39 import java.awt.SecondaryLoop;
  40 import java.awt.GraphicsEnvironment;
  41 import java.awt.event.AWTEventListener;
  42 import java.awt.event.ComponentEvent;
  43 import java.awt.event.FocusEvent;
  44 import java.awt.event.HierarchyEvent;
  45 import java.awt.event.InputEvent;
  46 import java.awt.event.InputMethodEvent;
  47 import java.awt.event.KeyEvent;
  48 import java.awt.event.MouseEvent;
  49 import java.awt.event.MouseWheelEvent;
  50 import java.awt.event.InvocationEvent;
  51 import java.awt.im.InputMethodRequests;
  52 import java.awt.image.BufferedImage;
  53 import java.awt.image.DataBufferInt;
  54 import java.nio.IntBuffer;
  55 import java.util.concurrent.atomic.AtomicInteger;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 import javax.swing.JComponent;
  59 import javax.swing.SwingUtilities;
  60 
  61 import javafx.application.Platform;
  62 import javafx.scene.Scene;
  63 
  64 import com.sun.javafx.application.PlatformImpl;
  65 import com.sun.javafx.cursor.CursorFrame;
  66 import com.sun.javafx.stage.EmbeddedWindow;
  67 import com.sun.javafx.tk.Toolkit;
  68 import com.sun.javafx.PlatformUtil;
  69 
  70 import com.sun.javafx.logging.PlatformLogger;
  71 import com.sun.javafx.embed.AbstractEvents;
  72 import com.sun.javafx.embed.EmbeddedSceneInterface;
  73 import com.sun.javafx.embed.EmbeddedStageInterface;
  74 import com.sun.javafx.embed.HostInterface;
  75 
  76 import com.sun.javafx.embed.swing.SwingDnD;
  77 import com.sun.javafx.embed.swing.SwingEvents;
  78 import com.sun.javafx.embed.swing.SwingCursors;
  79 import com.sun.javafx.embed.swing.SwingNodeHelper;
  80 import com.sun.javafx.embed.swing.newimpl.JFXPanelInteropN;
  81 
  82 /**
  83 * {@code JFXPanel} is a component to embed JavaFX content into
  84  * Swing applications. The content to be displayed is specified
  85  * with the {@link #setScene} method that accepts an instance of
  86  * JavaFX {@code Scene}. After the scene is assigned, it gets
  87  * repainted automatically. All the input and focus events are
  88  * forwarded to the scene transparently to the developer.
  89  * &lt;p&gt;
  90  * There are some restrictions related to {@code JFXPanel}. As a
  91  * Swing component, it should only be accessed from the event
  92  * dispatch thread, except the {@link #setScene} method, which can
  93  * be called either on the event dispatch thread or on the JavaFX
  94  * application thread.
  95  * &lt;p&gt;
  96  * Here is a typical pattern how {@code JFXPanel} can used:
  97  * &lt;pre&gt;
  98  *     public class Test {
  99  *
 100  *         private static void initAndShowGUI() {
 101  *             // This method is invoked on Swing thread
 102  *             JFrame frame = new JFrame(&quot;FX&quot;);
 103  *             final JFXPanel fxPanel = new JFXPanel();
 104  *             frame.add(fxPanel);
 105  *             frame.setVisible(true);
 106  *
 107  *             Platform.runLater(new Runnable() {
 108  *                 &amp;#064;Override
 109  *                 public void run() {
 110  *                     initFX(fxPanel);
 111  *                 }
 112  *             });
 113  *         }
 114  *
 115  *         private static void initFX(JFXPanel fxPanel) {
 116  *             // This method is invoked on JavaFX thread
 117  *             Scene scene = createScene();
 118  *             fxPanel.setScene(scene);
 119  *         }
 120  *
 121  *         public static void main(String[] args) {
 122  *             SwingUtilities.invokeLater(new Runnable() {
 123  *                 &amp;#064;Override
 124  *                 public void run() {
 125  *                     initAndShowGUI();
 126  *                 }
 127  *             });
 128  *         }
 129  *     }
 130  * &lt;/pre&gt;
 131  *
 132  * @since JavaFX 2.0
 133  */
 134 public class JFXPanel extends JComponent {
 135 
 136     private final static PlatformLogger log = PlatformLogger.getLogger(JFXPanel.class.getName());
 137 
 138     private static AtomicInteger instanceCount = new AtomicInteger(0);
 139     private static PlatformImpl.FinishListener finishListener;
 140 
 141     private transient HostContainer hostContainer;
 142 
 143     private transient volatile EmbeddedWindow stage;
 144     private transient volatile Scene scene;
 145 
 146     // Accessed on EDT only
 147     private transient SwingDnD dnd;
 148 
 149     private transient EmbeddedStageInterface stagePeer;
 150     private transient EmbeddedSceneInterface scenePeer;
 151 
 152     // The logical size of the FX content
 153     private int pWidth;
 154     private int pHeight;
 155 
 156     // The scale factor, used to translate b/w the logical (the FX content dimension)
 157     // and physical (the back buffer&#39;s dimension) coordinate spaces
 158     private double scaleFactorX = 1.0;
 159     private double scaleFactorY = 1.0;
 160 
 161     // Preferred size set from FX
 162     private volatile int pPreferredWidth = -1;
 163     private volatile int pPreferredHeight = -1;
 164 
 165     // Cached copy of this component&#39;s location on screen to avoid
 166     // calling getLocationOnScreen() under the tree lock on FX thread
 167     private volatile int screenX = 0;
 168     private volatile int screenY = 0;
 169 
 170     // Accessed on EDT only
 171     private BufferedImage pixelsIm;
 172 
 173     private volatile float opacity = 1.0f;
 174 
 175     // Indicates how many times setFxEnabled(false) has been called.
 176     // A value of 0 means the component is enabled.
 177     private AtomicInteger disableCount = new AtomicInteger(0);
 178 
 179     private boolean isCapturingMouse = false;
 180 
 181     private static boolean fxInitialized;
 182 
 183     private JFXPanelInteropN jfxPanelIOP;
 184 
 185     private synchronized void registerFinishListener() {
 186         if (instanceCount.getAndIncrement() &gt; 0) {
 187             // Already registered
 188             return;
 189         }
 190         // Need to install a finish listener to catch calls to Platform.exit
 191         finishListener = new PlatformImpl.FinishListener() {
 192             @Override public void idle(boolean implicitExit) {
 193             }
 194             @Override public void exitCalled() {
 195             }
 196         };
 197         PlatformImpl.addListener(finishListener);
 198     }
 199 
 200     private synchronized void deregisterFinishListener() {
 201         if (instanceCount.decrementAndGet() &gt; 0) {
 202             // Other JFXPanels still alive
 203             return;
 204         }
 205         PlatformImpl.removeListener(finishListener);
 206         finishListener = null;
 207     }
 208 
 209     // Initialize FX runtime when the JFXPanel instance is constructed
 210     private synchronized static void initFx() {
 211         // Note that calling PlatformImpl.startup more than once is OK
 212         if (fxInitialized) {
 213             return;
 214         }
 215         EventQueue eventQueue = AccessController.doPrivileged(
 216                                 (PrivilegedAction&lt;EventQueue&gt;) java.awt.Toolkit
 217                                 .getDefaultToolkit()::getSystemEventQueue);
 218         if (eventQueue.isDispatchThread()) {
 219             // We won&#39;t block EDT by FX initialization
 220             SecondaryLoop secondaryLoop = eventQueue.createSecondaryLoop();
 221             final Throwable[] th = {null};
 222             new Thread(() -&gt; {
 223                 try {
 224                     PlatformImpl.startup(() -&gt; {});
 225                 } catch (Throwable t) {
 226                     th[0] = t;
 227                 } finally {
 228                     secondaryLoop.exit();
 229                 }
 230             }).start();
 231             secondaryLoop.enter();
 232             if (th[0] != null) {
 233                 if (th[0] instanceof RuntimeException) {
 234                     throw (RuntimeException) th[0];
 235                 } else if (th[0] instanceof Error) {
 236                     throw (Error) th[0];
 237                 }
 238                 throw new RuntimeException(&quot;FX initialization failed&quot;, th[0]);
 239             }
 240         } else {
 241             PlatformImpl.startup(() -&gt; {});
 242         }
 243         fxInitialized = true;
 244     }
 245 
 246     /**
 247      * Creates a new {@code JFXPanel} object.
 248      * &lt;p&gt;
 249      * &lt;b&gt;Implementation note&lt;/b&gt;: when the first {@code JFXPanel} object
 250      * is created, it implicitly initializes the JavaFX runtime. This is the
 251      * preferred way to initialize JavaFX in Swing.
 252      */
 253     public JFXPanel() {
 254         super();
 255 
 256         jfxPanelIOP = new JFXPanelInteropN();
 257         initFx();
 258 
 259         hostContainer = new HostContainer();
 260 
 261         enableEvents(InputEvent.COMPONENT_EVENT_MASK |
 262                      InputEvent.FOCUS_EVENT_MASK |
 263                      InputEvent.HIERARCHY_BOUNDS_EVENT_MASK |
 264                      InputEvent.HIERARCHY_EVENT_MASK |
 265                      InputEvent.MOUSE_EVENT_MASK |
 266                      InputEvent.MOUSE_MOTION_EVENT_MASK |
 267                      InputEvent.MOUSE_WHEEL_EVENT_MASK |
 268                      InputEvent.KEY_EVENT_MASK |
 269                      InputEvent.INPUT_METHOD_EVENT_MASK);
 270 
 271         setFocusable(true);
 272         setFocusTraversalKeysEnabled(false);
 273     }
 274 
 275     /**
 276      * Returns the JavaFX scene attached to this {@code JFXPanel}.
 277      *
 278      * @return the {@code Scene} attached to this {@code JFXPanel}
 279      */
 280     public Scene getScene() {
 281         return scene;
 282     }
 283 
 284     /**
 285      * Attaches a {@code Scene} object to display in this {@code
 286      * JFXPanel}. This method can be called either on the event
 287      * dispatch thread or the JavaFX application thread.
 288      *
 289      * @param newScene a scene to display in this {@code JFXpanel}
 290      *
 291      * @see java.awt.EventQueue#isDispatchThread()
 292      * @see javafx.application.Platform#isFxApplicationThread()
 293      */
 294     public void setScene(final Scene newScene) {
 295         if (Toolkit.getToolkit().isFxUserThread()) {
 296             setSceneImpl(newScene);
 297         } else {
 298             EventQueue eventQueue = AccessController.doPrivileged(
 299                     (PrivilegedAction&lt;EventQueue&gt;) java.awt.Toolkit
 300                             .getDefaultToolkit()::getSystemEventQueue);
 301             SecondaryLoop secondaryLoop = eventQueue.createSecondaryLoop();
 302             Platform.runLater(() -&gt; {
 303                 setSceneImpl(newScene);
 304                 secondaryLoop.exit();
 305             });
 306             secondaryLoop.enter();
 307         }
 308     }
 309 
 310     /*
 311      * Called on JavaFX app thread.
 312      */
 313     private void setSceneImpl(Scene newScene) {
 314         if ((stage != null) &amp;&amp; (newScene == null)) {
 315             stage.hide();
 316             stage = null;
 317         }
 318         scene = newScene;
 319         if ((stage == null) &amp;&amp; (newScene != null)) {
 320             stage = new EmbeddedWindow(hostContainer);
 321         }
 322         if (stage != null) {
 323             stage.setScene(newScene);
 324             if (!stage.isShowing()) {
 325                 stage.show();
 326             }
 327         }
 328     }
 329 
 330     /**
 331      * {@code JFXPanel}&#39;s opacity is controlled by the JavaFX content
 332      * which is displayed in this component, so this method overrides
 333      * {@link javax.swing.JComponent#setOpaque(boolean)} to only accept a
 334      * {@code false} value. If this method is called with a {@code true}
 335      * value, no action is performed.
 336      *
 337      * @param opaque must be {@code false}
 338      */
 339     @Override
 340     public final void setOpaque(boolean opaque) {
 341         // Don&#39;t let user control opacity
 342         if (!opaque) {
 343             super.setOpaque(opaque);
 344         }
 345     }
 346 
 347     /**
 348      * {@code JFXPanel}&#39;s opacity is controlled by the JavaFX content
 349      * which is displayed in this component, so this method overrides
 350      * {@link javax.swing.JComponent#isOpaque()} to always return a
 351      * {@code false} value.
 352      *
 353      * @return a {@code false} value
 354      */
 355     @Override
 356     public final boolean isOpaque() {
 357         return false;
 358     }
 359 
 360     private void sendMouseEventToFX(MouseEvent e) {
 361         if (scenePeer == null || !isFxEnabled()) {
 362             return;
 363         }
 364 
 365         // FX only supports 5 buttons so don&#39;t send the event for other buttons
 366         switch (e.getID()) {
 367             case MouseEvent.MOUSE_DRAGGED:
 368             case MouseEvent.MOUSE_PRESSED:
 369             case MouseEvent.MOUSE_RELEASED:
 370                 if (e.getButton() &gt; 5)  return;
 371                 break;
 372         }
 373 
 374         int extModifiers = e.getModifiersEx();
 375         // Fix for RT-15457: we should report no mouse button upon mouse release, so
 376         // *BtnDown values are calculated based on extMofifiers, not e.getButton()
 377         boolean primaryBtnDown = (extModifiers &amp; MouseEvent.BUTTON1_DOWN_MASK) != 0;
 378         boolean middleBtnDown = (extModifiers &amp; MouseEvent.BUTTON2_DOWN_MASK) != 0;
 379         boolean secondaryBtnDown = (extModifiers &amp; MouseEvent.BUTTON3_DOWN_MASK) != 0;
 380         boolean backBtnDown = (extModifiers &amp; MouseEvent.getMaskForButton(4)) != 0;
 381         boolean forwardBtnDown = (extModifiers &amp; MouseEvent.getMaskForButton(5)) != 0;
 382 
 383         // Fix for RT-16558: if a PRESSED event is consumed, e.g. by a Swing Popup,
 384         // subsequent DRAGGED and RELEASED events should not be sent to FX as well
 385         if (e.getID() == MouseEvent.MOUSE_DRAGGED) {
 386             if (!isCapturingMouse) {
 387                 return;
 388             }
 389         } else if (e.getID() == MouseEvent.MOUSE_PRESSED) {
 390             isCapturingMouse = true;
 391         } else if (e.getID() == MouseEvent.MOUSE_RELEASED) {
 392             if (!isCapturingMouse) {
 393                 return;
 394             }
 395             isCapturingMouse = primaryBtnDown || middleBtnDown || secondaryBtnDown || backBtnDown || forwardBtnDown;
 396         } else if (e.getID() == MouseEvent.MOUSE_CLICKED) {
 397             // Don&#39;t send click events to FX, as they are generated in Scene
 398             return;
 399         }
 400         // A workaround until JDK-8065131 is fixed.
 401         boolean popupTrigger = false;
 402         if (e.getID() == MouseEvent.MOUSE_PRESSED || e.getID() == MouseEvent.MOUSE_RELEASED) {
 403             popupTrigger = e.isPopupTrigger();
 404         }
 405 
 406         if(e.getID() == MouseEvent.MOUSE_WHEEL) {
 407             scenePeer.scrollEvent(AbstractEvents.MOUSEEVENT_VERTICAL_WHEEL,
 408                     0, -SwingEvents.getWheelRotation(e),
 409                     0, 0, // total scroll
 410                     40, 40, // multiplier
 411                     e.getX(), e.getY(),
 412                     e.getXOnScreen(), e.getYOnScreen(),
 413                     (extModifiers &amp; MouseEvent.SHIFT_DOWN_MASK) != 0,
 414                     (extModifiers &amp; MouseEvent.CTRL_DOWN_MASK) != 0,
 415                     (extModifiers &amp; MouseEvent.ALT_DOWN_MASK) != 0,
 416                     (extModifiers &amp; MouseEvent.META_DOWN_MASK) != 0, false);
 417         } else {
 418             scenePeer.mouseEvent(
 419                     SwingEvents.mouseIDToEmbedMouseType(e.getID()),
 420                     SwingEvents.mouseButtonToEmbedMouseButton(e.getButton(), extModifiers),
 421                     primaryBtnDown, middleBtnDown, secondaryBtnDown,
 422                     backBtnDown, forwardBtnDown,
 423                     e.getX(), e.getY(), e.getXOnScreen(), e.getYOnScreen(),
 424                     (extModifiers &amp; MouseEvent.SHIFT_DOWN_MASK) != 0,
 425                     (extModifiers &amp; MouseEvent.CTRL_DOWN_MASK) != 0,
 426                     (extModifiers &amp; MouseEvent.ALT_DOWN_MASK) != 0,
 427                     (extModifiers &amp; MouseEvent.META_DOWN_MASK) != 0,
 428                     popupTrigger);
 429         }
 430         if (e.isPopupTrigger()) {
 431             scenePeer.menuEvent(e.getX(), e.getY(), e.getXOnScreen(), e.getYOnScreen(), false);
 432         }
 433     }
 434 
 435     /**
 436      * Overrides the {@link java.awt.Component#processMouseEvent(MouseEvent)}
 437      * method to dispatch the mouse event to the JavaFX scene attached to this
 438      * {@code JFXPanel}.
 439      *
 440      * @param e the mouse event to dispatch to the JavaFX scene
 441      */
 442     @Override
 443     protected void processMouseEvent(MouseEvent e) {
 444         if ((e.getID() == MouseEvent.MOUSE_PRESSED) &amp;&amp;
 445             (e.getButton() == MouseEvent.BUTTON1)) {
 446             if (isFocusable() &amp;&amp; !hasFocus()) {
 447                 requestFocus();
 448                 // this focus request event goes to eventqueue and will be
 449                 // asynchronously handled so MOUSE_PRESSED event will not be
 450                 // honoured by FX immediately due to lack of focus in fx
 451                 // component. Fire the same MOUSE_PRESSED event after
 452                 // requestFocus() so that 2nd mouse press will be honoured
 453                 // since now fx have focus
 454                 jfxPanelIOP.postEvent(this, e);
 455             }
 456         }
 457 
 458         sendMouseEventToFX(e);
 459         super.processMouseEvent(e);
 460     }
 461 
 462     /**
 463      * Overrides the {@link java.awt.Component#processMouseMotionEvent(MouseEvent)}
 464      * method to dispatch the mouse motion event to the JavaFX scene attached to
 465      * this {@code JFXPanel}.
 466      *
 467      * @param e the mouse motion event to dispatch to the JavaFX scene
 468      */
 469     @Override
 470     protected void processMouseMotionEvent(MouseEvent e) {
 471         sendMouseEventToFX(e);
 472         super.processMouseMotionEvent(e);
 473     }
 474 
 475     /**
 476      * Overrides the
 477      * {@link java.awt.Component#processMouseWheelEvent(MouseWheelEvent)}
 478      * method to dispatch the mouse wheel event to the JavaFX scene attached
 479      * to this {@code JFXPanel}.
 480      *
 481      * @param e the mouse wheel event to dispatch to the JavaFX scene
 482      */
 483     @Override
 484     protected void processMouseWheelEvent(MouseWheelEvent e) {
 485         sendMouseEventToFX(e);
 486         super.processMouseWheelEvent(e);
 487     }
 488 
 489     private void sendKeyEventToFX(final KeyEvent e) {
 490         if (scenePeer == null || !isFxEnabled()) {
 491             return;
 492         }
 493 
 494         char[] chars = (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED)
 495                        ? new char[] {}
 496                        : new char[] { SwingEvents.keyCharToEmbedKeyChar(e.getKeyChar()) };
 497 
 498         scenePeer.keyEvent(
 499                 SwingEvents.keyIDToEmbedKeyType(e.getID()),
 500                 e.getKeyCode(), chars,
 501                 SwingEvents.keyModifiersToEmbedKeyModifiers(e.getModifiersEx()));
 502     }
 503 
 504     /**
 505      * Overrides the {@link java.awt.Component#processKeyEvent(KeyEvent)}
 506      * method to dispatch the key event to the JavaFX scene attached to this
 507      * {@code JFXPanel}.
 508      *
 509      * @param e the key event to dispatch to the JavaFX scene
 510      */
 511     @Override
 512     protected void processKeyEvent(KeyEvent e) {
 513         sendKeyEventToFX(e);
 514         super.processKeyEvent(e);
 515     }
 516 
 517     private void sendResizeEventToFX() {
 518         if (stagePeer != null) {
 519             stagePeer.setSize(pWidth, pHeight);
 520         }
 521         if (scenePeer != null) {
 522             scenePeer.setSize(pWidth, pHeight);
 523         }
 524     }
 525 
 526     /**
 527      * Overrides the
 528      * {@link java.awt.Component#processComponentEvent(ComponentEvent)}
 529      * method to dispatch {@link java.awt.event.ComponentEvent#COMPONENT_RESIZED}
 530      * events to the JavaFX scene attached to this {@code JFXPanel}. The JavaFX
 531      * scene object is then resized to match the {@code JFXPanel} size.
 532      *
 533      * @param e the component event to dispatch to the JavaFX scene
 534      */
 535     @Override
 536     protected void processComponentEvent(ComponentEvent e) {
 537         switch (e.getID()) {
 538             case ComponentEvent.COMPONENT_RESIZED: {
 539                 updateComponentSize();
 540                 break;
 541             }
 542             case ComponentEvent.COMPONENT_MOVED: {
 543                 if (updateScreenLocation()) {
 544                     sendMoveEventToFX();
 545                 }
 546                 break;
 547             }
 548             default: {
 549                 break;
 550             }
 551         }
 552         super.processComponentEvent(e);
 553     }
 554 
 555     // called on EDT only
 556     private void updateComponentSize() {
 557         int oldWidth = pWidth;
 558         int oldHeight = pHeight;
 559         // It&#39;s quite possible to get negative values here, this is not
 560         // what JavaFX embedded scenes/stages are ready to
 561         pWidth = Math.max(0, getWidth());
 562         pHeight = Math.max(0, getHeight());
 563         if (getBorder() != null) {
 564             Insets i = getBorder().getBorderInsets(this);
 565             pWidth -= (i.left + i.right);
 566             pHeight -= (i.top + i.bottom);
 567         }
 568         double newScaleFactorX = scaleFactorX;
 569         double newScaleFactorY = scaleFactorY;
 570         Graphics g = getGraphics();
 571         newScaleFactorX = GraphicsEnvironment.getLocalGraphicsEnvironment().
 572                           getDefaultScreenDevice().getDefaultConfiguration().
 573                           getDefaultTransform().getScaleX();
 574         newScaleFactorY = GraphicsEnvironment.getLocalGraphicsEnvironment().
 575                           getDefaultScreenDevice().getDefaultConfiguration().
 576                           getDefaultTransform().getScaleY();
 577         if (oldWidth != pWidth || oldHeight != pHeight ||
 578             newScaleFactorX != scaleFactorX || newScaleFactorY != scaleFactorY)
 579         {
 580             createResizePixelBuffer(newScaleFactorX, newScaleFactorY);
 581             if (scenePeer != null) {
 582                 scenePeer.setPixelScaleFactors((float) newScaleFactorX,
 583                                                (float) newScaleFactorY);
 584             }
 585             scaleFactorX = newScaleFactorX;
 586             scaleFactorY = newScaleFactorY;
 587             sendResizeEventToFX();
 588         }
 589     }
 590 
 591     // This methods should only be called on EDT
 592     private boolean updateScreenLocation() {
 593         synchronized (getTreeLock()) {
 594             if (isShowing()) {
 595                 Point p = getLocationOnScreen();
 596                 screenX = p.x;
 597                 screenY = p.y;
 598                 return true;
 599             }
 600         }
 601         return false;
 602     }
 603 
 604     private void sendMoveEventToFX() {
 605         if (stagePeer == null) {
 606             return;
 607         }
 608 
 609         stagePeer.setLocation(screenX, screenY);
 610     }
 611 
 612     /**
 613      * Overrides the
 614      * {@link java.awt.Component#processHierarchyBoundsEvent(HierarchyEvent)}
 615      * method to process {@link java.awt.event.HierarchyEvent#ANCESTOR_MOVED}
 616      * events and update the JavaFX scene location to match the {@code
 617      * JFXPanel} location on the screen.
 618      *
 619      * @param e the hierarchy bounds event to process
 620      */
 621     @Override
 622     protected void processHierarchyBoundsEvent(HierarchyEvent e) {
 623         if (e.getID() == HierarchyEvent.ANCESTOR_MOVED) {
 624             if (updateScreenLocation()) {
 625                 sendMoveEventToFX();
 626             }
 627         }
 628         super.processHierarchyBoundsEvent(e);
 629     }
 630 
 631     @Override
 632     protected void processHierarchyEvent(HierarchyEvent e) {
 633         if ((e.getChangeFlags() &amp; HierarchyEvent.SHOWING_CHANGED) != 0) {
 634             if (updateScreenLocation()) {
 635                 sendMoveEventToFX();
 636             }
 637         }
 638         super.processHierarchyEvent(e);
 639     }
 640 
 641     private void sendFocusEventToFX(final FocusEvent e) {
 642         if ((stage == null) || (stagePeer == null) || !isFxEnabled()) {
 643             return;
 644         }
 645 
 646         boolean focused = (e.getID() == FocusEvent.FOCUS_GAINED);
 647         int focusCause = (focused ? AbstractEvents.FOCUSEVENT_ACTIVATED :
 648                                       AbstractEvents.FOCUSEVENT_DEACTIVATED);
 649 
 650         if (focused) {
 651             if (e.getCause() == FocusEvent.Cause.TRAVERSAL_FORWARD) {
 652                 focusCause = AbstractEvents.FOCUSEVENT_TRAVERSED_FORWARD;
 653             } else if (e.getCause() == FocusEvent.Cause.TRAVERSAL_BACKWARD) {
 654                 focusCause = AbstractEvents.FOCUSEVENT_TRAVERSED_BACKWARD;
 655             }
 656         }
 657         stagePeer.setFocused(focused, focusCause);
 658     }
 659 
 660     /**
 661      * Overrides the
 662      * {@link java.awt.Component#processFocusEvent(FocusEvent)}
 663      * method to dispatch focus events to the JavaFX scene attached to this
 664      * {@code JFXPanel}.
 665      *
 666      * @param e the focus event to dispatch to the JavaFX scene
 667      */
 668     @Override
 669     protected void processFocusEvent(FocusEvent e) {
 670         sendFocusEventToFX(e);
 671         super.processFocusEvent(e);
 672     }
 673 
 674     // called on EDT only
 675     private void createResizePixelBuffer(double newScaleFactorX, double newScaleFactorY) {
 676         if (scenePeer == null || pWidth &lt;= 0 || pHeight &lt;= 0) {
 677             pixelsIm = null;
 678         } else {
 679             BufferedImage oldIm = pixelsIm;
 680             int newPixelW = (int) Math.ceil(pWidth * newScaleFactorX);
 681             int newPixelH = (int) Math.ceil(pHeight * newScaleFactorY);
 682             pixelsIm = new BufferedImage(newPixelW, newPixelH,
 683                                          SwingFXUtils.getBestBufferedImageType(
 684                                              scenePeer.getPixelFormat(), null, false));
 685             if (oldIm != null) {
 686                 double ratioX = newScaleFactorX / scaleFactorX;
 687                 double ratioY = newScaleFactorY / scaleFactorY;
 688                 // Transform old size to the new coordinate space.
 689                 int oldW = (int)Math.round(oldIm.getWidth() * ratioX);
 690                 int oldH = (int)Math.round(oldIm.getHeight() * ratioY);
 691 
 692                 Graphics g = pixelsIm.getGraphics();
 693                 try {
 694                     g.drawImage(oldIm, 0, 0, oldW, oldH, null);
 695                 } finally {
 696                     g.dispose();
 697                 }
 698             }
 699         }
 700     }
 701 
 702     @Override
 703     protected void processInputMethodEvent(InputMethodEvent e) {
 704         if (e.getID() == InputMethodEvent.INPUT_METHOD_TEXT_CHANGED) {
 705             sendInputMethodEventToFX(e);
 706         }
 707         super.processInputMethodEvent(e);
 708     }
 709 
 710     private void sendInputMethodEventToFX(InputMethodEvent e) {
 711         String t = InputMethodSupport.getTextForEvent(e);
 712 
 713         int insertionIndex = 0;
 714         if (e.getCaret() != null) {
 715             insertionIndex = e.getCaret().getInsertionIndex();
 716         }
 717         scenePeer.inputMethodEvent(
 718                 javafx.scene.input.InputMethodEvent.INPUT_METHOD_TEXT_CHANGED,
 719                 InputMethodSupport.inputMethodEventComposed(t, e.getCommittedCharacterCount()),
 720                 t.substring(0, e.getCommittedCharacterCount()),
 721                 insertionIndex);
 722     }
 723 
 724     /**
 725      * Overrides the {@link javax.swing.JComponent#paintComponent(Graphics)}
 726      * method to paint the content of the JavaFX scene attached to this
 727      * {@code JFXpanel}.
 728      *
 729      * @param g the Graphics context in which to paint
 730      *
 731      * @see #isOpaque()
 732      */
 733     @Override
 734     protected void paintComponent(Graphics g) {
 735         if (scenePeer == null) {
 736             return;
 737         }
 738         if (pixelsIm == null) {
 739             createResizePixelBuffer(scaleFactorX, scaleFactorY);
 740             if (pixelsIm == null) {
 741                 return;
 742             }
 743         }
 744         DataBufferInt dataBuf = (DataBufferInt)pixelsIm.getRaster().getDataBuffer();
 745         int[] pixelsData = dataBuf.getData();
 746         IntBuffer buf = IntBuffer.wrap(pixelsData);
 747         if (!scenePeer.getPixels(buf, pWidth, pHeight)) {
 748             // In this case we just render what we have so far in the buffer.
 749         }
 750 
 751         Graphics gg = null;
 752         try {
 753             gg = g.create();
 754             if ((opacity &lt; 1.0f) &amp;&amp; (gg instanceof Graphics2D)) {
 755                 Graphics2D g2d = (Graphics2D)gg;
 756                 AlphaComposite c = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, opacity);
 757                 g2d.setComposite(c);
 758             }
 759             if (getBorder() != null) {
 760                 Insets i = getBorder().getBorderInsets(this);
 761                 gg.translate(i.left, i.top);
 762             }
 763             gg.drawImage(pixelsIm, 0, 0, pWidth, pHeight, null);
 764 
 765             double newScaleFactorX = scaleFactorX;
 766             double newScaleFactorY = scaleFactorY;
 767             newScaleFactorX = GraphicsEnvironment.getLocalGraphicsEnvironment().
 768                               getDefaultScreenDevice().getDefaultConfiguration().
 769                               getDefaultTransform().getScaleX();
 770             newScaleFactorY = GraphicsEnvironment.getLocalGraphicsEnvironment().
 771                               getDefaultScreenDevice().getDefaultConfiguration().
 772                               getDefaultTransform().getScaleY();
 773             if (scaleFactorX != newScaleFactorX || scaleFactorY != newScaleFactorY) {
 774                 createResizePixelBuffer(newScaleFactorX, newScaleFactorY);
 775                 // The scene will request repaint.
 776                 scenePeer.setPixelScaleFactors((float) newScaleFactorX,
 777                                                (float) newScaleFactorY);
 778                 scaleFactorX = newScaleFactorX;
 779                 scaleFactorY = newScaleFactorY;
 780             }
 781         } catch (Throwable th) {
 782             th.printStackTrace();
 783         } finally {
 784             if (gg != null) {
 785                 gg.dispose();
 786             }
 787         }
 788     }
 789 
 790     /**
 791      * Returns the preferred size of this {@code JFXPanel}, either
 792      * previously set with {@link #setPreferredSize(Dimension)} or
 793      * based on the content of the JavaFX scene attached to this {@code
 794      * JFXPanel}.
 795      *
 796      * @return prefSize this {@code JFXPanel} preferred size
 797      */
 798     @Override
 799     public Dimension getPreferredSize() {
 800         if (isPreferredSizeSet() || scenePeer == null) {
 801             return super.getPreferredSize();
 802         }
 803         return new Dimension(pPreferredWidth, pPreferredHeight);
 804     }
 805 
 806     private boolean isFxEnabled() {
 807         return this.disableCount.get() == 0;
 808     }
 809 
 810     private void setFxEnabled(boolean enabled) {
 811         if (!enabled) {
 812             if (disableCount.incrementAndGet() == 1) {
 813                 if (dnd != null) {
 814                     dnd.removeNotify();
 815                 }
 816             }
 817         } else {
 818             if (disableCount.get() == 0) {
 819                 //should report a warning about an extra enable call ?
 820                 return;
 821             }
 822             if (disableCount.decrementAndGet() == 0) {
 823                 if (dnd != null) {
 824                     dnd.addNotify();
 825                 }
 826             }
 827         }
 828     }
 829 
 830     private transient  AWTEventListener ungrabListener = event -&gt; {
 831         if (jfxPanelIOP.isUngrabEvent(event)) {
 832             SwingNodeHelper.runOnFxThread(() -&gt; {
 833                 if (JFXPanel.this.stagePeer != null &amp;&amp;
 834                         getScene() != null &amp;&amp;
 835                         getScene().getFocusOwner() != null &amp;&amp;
 836                         getScene().getFocusOwner().isFocused()) {
 837                     JFXPanel.this.stagePeer.focusUngrab();
 838                 }
 839             });
 840         }
 841         if (event instanceof MouseEvent) {
 842             // Synthesize FOCUS_UNGRAB if user clicks the AWT top-level window
 843             // that contains the JFXPanel.
 844             if (event.getID() == MouseEvent.MOUSE_PRESSED &amp;&amp; event.getSource() instanceof Component) {
 845                 final Window jfxPanelWindow = SwingUtilities.getWindowAncestor(JFXPanel.this);
 846                 final Component source = (Component)event.getSource();
 847                 final Window eventWindow = source instanceof Window ? (Window)source : SwingUtilities.getWindowAncestor(source);
 848 
 849                 if (jfxPanelWindow == eventWindow) {
 850                     SwingNodeHelper.runOnFxThread(() -&gt; {
 851                         if (JFXPanel.this.stagePeer != null) {
 852                             // No need to check if grab is active or not.
 853                             // NoAutoHide popups don&#39;t request the grab and
 854                             // ignore the Ungrab event anyway.
 855                             // AutoHide popups actually should be hidden when
 856                             // user clicks some non-FX content, even if for
 857                             // some reason they didn&#39;t install the grab when
 858                             // they were shown.
 859                             JFXPanel.this.stagePeer.focusUngrab();
 860                         }
 861                     });
 862                 }
 863             }
 864         }
 865     };
 866 
 867     /**
 868      * Notifies this component that it now has a parent component. When this
 869      * method is invoked, the chain of parent components is set up with
 870      * KeyboardAction event listeners.
 871      */
 872     @Override
 873     public void addNotify() {
 874         super.addNotify();
 875 
 876         registerFinishListener();
 877 
 878         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 879             JFXPanel.this.getToolkit().addAWTEventListener(ungrabListener,
 880                                                jfxPanelIOP.getMask());
 881             return null;
 882         });
 883         updateComponentSize(); // see RT-23603
 884         SwingNodeHelper.runOnFxThread(() -&gt; {
 885             if ((stage != null) &amp;&amp; !stage.isShowing()) {
 886                 stage.show();
 887                 sendMoveEventToFX();
 888             }
 889         });
 890     }
 891 
 892     @Override
 893     public InputMethodRequests getInputMethodRequests() {
 894         EmbeddedSceneInterface scene = scenePeer;
 895         if (scene == null) {
 896             return null;
 897         }
 898         return new InputMethodSupport.InputMethodRequestsAdapter(scene.getInputMethodRequests());
 899     }
 900 
 901     /**
 902      * Notifies this component that it no longer has a parent component.
 903      * When this method is invoked, any KeyboardActions set up in the the
 904      * chain of parent components are removed.
 905      */
 906     @Override public void removeNotify() {
 907         SwingNodeHelper.runOnFxThread(() -&gt; {
 908             if ((stage != null) &amp;&amp; stage.isShowing()) {
 909                 stage.hide();
 910             }
 911         });
 912 
 913         pixelsIm = null;
 914         pWidth = 0;
 915         pHeight = 0;
 916 
 917         super.removeNotify();
 918 
 919         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 920             JFXPanel.this.getToolkit().removeAWTEventListener(ungrabListener);
 921             return null;
 922         });
 923 
 924         /* see CR 4867453 */
 925         getInputContext().removeNotify(this);
 926 
 927         deregisterFinishListener();
 928     }
 929 
 930     private void invokeOnClientEDT(Runnable r) {
 931         jfxPanelIOP.postEvent(this, new InvocationEvent(this, r));
 932     }
 933 
 934     private class HostContainer implements HostInterface {
 935 
 936         @Override
 937         public void setEmbeddedStage(EmbeddedStageInterface embeddedStage) {
 938             stagePeer = embeddedStage;
 939             if (stagePeer == null) {
 940                 return;
 941             }
 942             if (pWidth &gt; 0 &amp;&amp; pHeight &gt; 0) {
 943                 stagePeer.setSize(pWidth, pHeight);
 944             }
 945             invokeOnClientEDT(() -&gt; {
 946                 if (stagePeer != null &amp;&amp; JFXPanel.this.isFocusOwner()) {
 947                     stagePeer.setFocused(true, AbstractEvents.FOCUSEVENT_ACTIVATED);
 948                 }
 949             });
 950             sendMoveEventToFX();
 951         }
 952 
 953         @Override
 954         public void setEmbeddedScene(EmbeddedSceneInterface embeddedScene) {
 955             if (scenePeer == embeddedScene) {
 956                 return;
 957             }
 958             scenePeer = embeddedScene;
 959             if (scenePeer == null) {
 960                 invokeOnClientEDT(() -&gt; {
 961                     if (dnd != null) {
 962                         dnd.removeNotify();
 963                         dnd = null;
 964                     }
 965                 });
 966                 return;
 967             }
 968             if (pWidth &gt; 0 &amp;&amp; pHeight &gt; 0) {
 969                 scenePeer.setSize(pWidth, pHeight);
 970             }
 971             scenePeer.setPixelScaleFactors((float) scaleFactorX, (float) scaleFactorY);
 972 
 973             invokeOnClientEDT(() -&gt; {
 974                 dnd = new SwingDnD(JFXPanel.this, scenePeer);
 975                 dnd.addNotify();
 976                 if (scenePeer != null) {
 977                     scenePeer.setDragStartListener(dnd.getDragStartListener());
 978                 }
 979             });
 980         }
 981 
 982         @Override
 983         public boolean requestFocus() {
 984             return requestFocusInWindow();
 985         }
 986 
 987         @Override
 988         public boolean traverseFocusOut(boolean forward) {
 989             KeyboardFocusManager kfm = KeyboardFocusManager.getCurrentKeyboardFocusManager();
 990             if (forward) {
 991                 kfm.focusNextComponent(JFXPanel.this);
 992             } else {
 993                 kfm.focusPreviousComponent(JFXPanel.this);
 994             }
 995             return true;
 996         }
 997 
 998         @Override
 999         public void setPreferredSize(final int width, final int height) {
1000             invokeOnClientEDT(() -&gt; {
1001                 JFXPanel.this.pPreferredWidth = width;
1002                 JFXPanel.this.pPreferredHeight = height;
1003                 JFXPanel.this.revalidate();
1004             });
1005         }
1006 
1007         @Override
1008         public void repaint() {
1009             invokeOnClientEDT(() -&gt; {
1010                 JFXPanel.this.repaint();
1011             });
1012         }
1013 
1014         @Override
1015         public void setEnabled(final boolean enabled) {
1016             JFXPanel.this.setFxEnabled(enabled);
1017         }
1018 
1019         @Override
1020         public void setCursor(CursorFrame cursorFrame) {
1021             final Cursor cursor = getPlatformCursor(cursorFrame);
1022             invokeOnClientEDT(() -&gt; {
1023                 JFXPanel.this.setCursor(cursor);
1024             });
1025         }
1026 
1027         private Cursor getPlatformCursor(final CursorFrame cursorFrame) {
1028             final Cursor cachedPlatformCursor =
1029                     cursorFrame.getPlatformCursor(Cursor.class);
1030             if (cachedPlatformCursor != null) {
1031                 // platform cursor already cached
1032                 return cachedPlatformCursor;
1033             }
1034 
1035             // platform cursor not cached yet
1036             final Cursor platformCursor =
1037                     SwingCursors.embedCursorToCursor(cursorFrame);
1038             cursorFrame.setPlatforCursor(Cursor.class, platformCursor);
1039 
1040             return platformCursor;
1041         }
1042 
1043         @Override
1044         public boolean grabFocus() {
1045             // On X11 grab is limited to a single XDisplay connection,
1046             // so we can&#39;t delegate it to another GUI toolkit.
1047             if (PlatformUtil.isLinux()) return true;
1048 
1049             invokeOnClientEDT(() -&gt; {
1050                 Window window = SwingUtilities.getWindowAncestor(JFXPanel.this);
1051                 if (window != null) {
1052                     jfxPanelIOP.grab(JFXPanel.this.getToolkit(), window);
1053                 }
1054             });
1055 
1056             return true; // Oh, well...
1057         }
1058 
1059         @Override
1060         public void ungrabFocus() {
1061             // On X11 grab is limited to a single XDisplay connection,
1062             // so we can&#39;t delegate it to another GUI toolkit.
1063             if (PlatformUtil.isLinux()) return;
1064 
1065             invokeOnClientEDT(() -&gt; {
1066                 Window window = SwingUtilities.getWindowAncestor(JFXPanel.this);
1067                 if (window != null) {
1068                     jfxPanelIOP.ungrab(JFXPanel.this.getToolkit(), window);
1069                 }
1070             });
1071         }
1072     }
1073 }
    </pre>
  </body>
</html>