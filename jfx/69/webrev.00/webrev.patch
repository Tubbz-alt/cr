diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/spectrum/gstspectrum.c b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/spectrum/gstspectrum.c
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/spectrum/gstspectrum.c
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/spectrum/gstspectrum.c
@@ -156,10 +156,25 @@
 static GstFlowReturn gst_spectrum_transform_ip (GstBaseTransform * trans,
     GstBuffer * in);
 static gboolean gst_spectrum_setup (GstAudioFilter * base,
     const GstAudioInfo * info);
 
+#if defined (GSTREAMER_LITE) && defined (OSX)
+gboolean gst_spectrum_setup_api (GstAudioFilter * base, const GstAudioInfo * info,
+                                 guint bps_user, guint bpf_user) {
+    GstSpectrum *spectrum = GST_SPECTRUM (base);
+    spectrum->bps_user = bps_user;
+    spectrum->bpf_user = bpf_user;
+    return gst_spectrum_setup(base, info);
+}
+
+GstFlowReturn
+gst_spectrum_transform_ip_api (GstBaseTransform * trans, GstBuffer * buffer) {
+    return gst_spectrum_transform_ip(trans, buffer);
+}
+#endif // GSTREAMER_LITE and OSX
+
 static void
 gst_spectrum_class_init (GstSpectrumClass * klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
@@ -249,10 +264,16 @@
   spectrum->message_phase = DEFAULT_MESSAGE_PHASE;
   spectrum->interval = DEFAULT_INTERVAL;
   spectrum->bands = DEFAULT_BANDS;
   spectrum->threshold = DEFAULT_THRESHOLD;
 
+#if defined (GSTREAMER_LITE) && defined (OSX)
+  spectrum->bps_user = 0;
+  spectrum->bpf_user = 0;
+  spectrum->user_data = NULL;
+#endif // GSTREAMER_LITE and OSX
+
   g_mutex_init (&spectrum->lock);
 }
 
 static void
 gst_spectrum_alloc_channel_data (GstSpectrum * spectrum)
@@ -712,14 +733,28 @@
   GValue *mcv = NULL, *pcv = NULL;
   GstClockTime endtime, running_time, stream_time;
 
   GST_DEBUG_OBJECT (spectrum, "preparing message, bands =%d ", spectrum->bands);
 
+#if defined (GSTREAMER_LITE) && defined (OSX)
+  // When running spectrum directly we cannot figure out time stamps, since we do not
+  // have full pipeline. Caller will be responsible to handle time stamps.
+  if (spectrum->user_data != NULL) {
+    running_time = 0;
+    stream_time = 0;
+  } else {
+    running_time = gst_segment_to_running_time (&trans->segment, GST_FORMAT_TIME,
+      timestamp);
+    stream_time = gst_segment_to_stream_time (&trans->segment, GST_FORMAT_TIME,
+      timestamp);
+  }
+#else // GSTREAMER_LITE and OSX
   running_time = gst_segment_to_running_time (&trans->segment, GST_FORMAT_TIME,
       timestamp);
   stream_time = gst_segment_to_stream_time (&trans->segment, GST_FORMAT_TIME,
       timestamp);
+#endif // GSTREAMER_LITE and OSX
   /* endtime is for backwards compatibility */
   endtime = stream_time + duration;
 
   s = gst_structure_new ("spectrum",
       "endtime", GST_TYPE_CLOCK_TIME, endtime,
@@ -875,10 +910,16 @@
 
   rate = GST_AUDIO_FILTER_RATE (spectrum);
   channels = GST_AUDIO_FILTER_CHANNELS (spectrum);
   bps = GST_AUDIO_FILTER_BPS (spectrum);
   bpf = GST_AUDIO_FILTER_BPF (spectrum);
+#ifdef OSX
+  if (spectrum->bps_user != 0 && spectrum->bpf_user != 0) {
+    bps = spectrum->bps_user;
+    bpf = spectrum->bpf_user;
+  }
+#endif // OSX
   output_channels = spectrum->multi_channel ? channels : 1;
   max_value = (1UL << ((bps << 3) - 1)) - 1;
   bands = spectrum->bands;
   nfft = 2 * bands - 2;
 #else // GSTREAMER_LITE
diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/spectrum/gstspectrum.h b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/spectrum/gstspectrum.h
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/spectrum/gstspectrum.h
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/spectrum/gstspectrum.h
@@ -79,17 +79,31 @@
   guint64 accumulated_error;
 
   GMutex lock;
 
   GstSpectrumInputData input_data;
+
+#if defined (GSTREAMER_LITE) && defined (OSX)
+  guint bps_user; // User provided values to avoid more complex spectrum initialization
+  guint bpf_user;
+  void *user_data;
+#endif // GSTREAMER_LITE and OSX
 };
 
 struct _GstSpectrumClass
 {
   GstAudioFilterClass parent_class;
 };
 
 GType gst_spectrum_get_type (void);
 
+#if defined (GSTREAMER_LITE) && defined (OSX)
+GST_EXPORT gboolean gst_spectrum_setup_api (GstAudioFilter * base,
+    const GstAudioInfo * info, guint bps_user, guint bpf_user);
+
+GST_EXPORT GstFlowReturn
+gst_spectrum_transform_ip_api (GstBaseTransform * trans, GstBuffer * buffer);
+#endif // GSTREAMER_LITE and OSX
+
 G_END_DECLS
 
 #endif /* __GST_SPECTRUM_H__ */
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUBase.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUBase.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUBase.cpp
+++ /dev/null
@@ -1,2362 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#include "AUBase.h"
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-    #include "AUDispatch.h"
-#endif
-#include "AUInputElement.h"
-#include "AUOutputElement.h"
-#include <algorithm>
-#include <syslog.h>
-#include "CAAudioChannelLayout.h"
-#include "CAHostTimeBase.h"
-#include "CAVectorUnit.h"
-#include "CAXException.h"
-
-#if TARGET_OS_MAC && (TARGET_CPU_X86 || TARGET_CPU_X86_64)
-    // our compiler does ALL floating point with SSE
-    inline int  GETCSR ()    { int _result; asm volatile ("stmxcsr %0" : "=m" (*&_result) ); return _result; }
-    inline void SETCSR (int a)    { int _temp = a; asm volatile( "ldmxcsr %0" : : "m" (*&_temp ) ); }
-
-    #define DISABLE_DENORMALS int _savemxcsr = GETCSR(); SETCSR(_savemxcsr | 0x8040);
-    #define RESTORE_DENORMALS SETCSR(_savemxcsr);
-#else
-    #define DISABLE_DENORMALS
-    #define RESTORE_DENORMALS
-#endif
-
-static bool sAUBaseCFStringsInitialized = false;
-// this is used for the presets
-static CFStringRef kUntitledString = NULL;
-//these are the current keys for the class info document
-static CFStringRef kVersionString = NULL;
-static CFStringRef kTypeString = NULL;
-static CFStringRef kSubtypeString = NULL;
-static CFStringRef kManufacturerString = NULL;
-static CFStringRef kDataString = NULL;
-static CFStringRef kNameString = NULL;
-static CFStringRef kRenderQualityString = NULL;
-static CFStringRef kCPULoadString = NULL;
-static CFStringRef kElementNameString = NULL;
-static CFStringRef kPartString = NULL;
-
-SInt32 AUBase::sVectorUnitType = kVecUninitialized;
-
-//_____________________________________________________________________________
-//
-AUBase::AUBase( AudioComponentInstance          inInstance,
-                UInt32                          numInputElements,
-                UInt32                          numOutputElements,
-                UInt32                          numGroupElements) :
-    ComponentBase(inInstance),
-    mElementsCreated(false),
-    mInitialized(false),
-    mHasBegunInitializing(false),
-    mInitNumInputEls(numInputElements), mInitNumOutputEls(numOutputElements),
-#if !CA_BASIC_AU_FEATURES
-    mInitNumGroupEls(numGroupElements),
-#endif
-    mRenderCallbacksTouched(false),
-    mRenderThreadID (NULL),
-    mWantsRenderThreadID (false),
-    mLastRenderError(0),
-    mUsesFixedBlockSize(false),
-    mBuffersAllocated(false),
-    mLogString (NULL),
-    mNickName (NULL),
-    mAUMutex(NULL)
-    #if !CA_NO_AU_UI_FEATURES
-        ,
-        mContextName(NULL)
-    #endif
-{
-    ResetRenderTime ();
-
-    if(!sAUBaseCFStringsInitialized)
-    {
-        kUntitledString = CFSTR("Untitled");
-        kVersionString = CFSTR(kAUPresetVersionKey);
-        kTypeString = CFSTR(kAUPresetTypeKey);
-        kSubtypeString = CFSTR(kAUPresetSubtypeKey);
-        kManufacturerString = CFSTR(kAUPresetManufacturerKey);
-        kDataString = CFSTR(kAUPresetDataKey);
-        kNameString = CFSTR(kAUPresetNameKey);
-        kRenderQualityString = CFSTR(kAUPresetRenderQualityKey);
-        kCPULoadString = CFSTR(kAUPresetCPULoadKey);
-        kElementNameString = CFSTR(kAUPresetElementNameKey);
-        kPartString = CFSTR(kAUPresetPartKey);
-        sAUBaseCFStringsInitialized = true;
-    }
-
-    if (sVectorUnitType == kVecUninitialized) {
-        sVectorUnitType = CAVectorUnit::GetVectorUnitType() ;
-    }
-
-    mAudioUnitAPIVersion = 2;
-
-    SetMaxFramesPerSlice(kAUDefaultMaxFramesPerSlice);
-
-    GlobalScope().Initialize(this, kAudioUnitScope_Global, 1);
-
-#if !CA_NO_AU_UI_FEATURES
-    memset (&mHostCallbackInfo, 0, sizeof (mHostCallbackInfo));
-#endif
-
-
-    mCurrentPreset.presetNumber = -1;
-    mCurrentPreset.presetName = kUntitledString;
-    CFRetain (mCurrentPreset.presetName);
-}
-
-//_____________________________________________________________________________
-//
-AUBase::~AUBase()
-{
-    if (mCurrentPreset.presetName) CFRelease (mCurrentPreset.presetName);
-#if !CA_NO_AU_UI_FEATURES
-    if (mContextName) CFRelease (mContextName);
-#endif
-    if (mLogString) delete [] mLogString;
-    if (mNickName) CFRelease(mNickName);
-}
-
-//_____________________________________________________________________________
-//
-void    AUBase::CreateElements()
-{
-    if (!mElementsCreated) {
-        Inputs().Initialize(this, kAudioUnitScope_Input, mInitNumInputEls);
-        Outputs().Initialize(this, kAudioUnitScope_Output, mInitNumOutputEls);
-#if !CA_BASIC_AU_FEATURES
-        Groups().Initialize(this, kAudioUnitScope_Group, mInitNumGroupEls);
-#endif
-        CreateExtendedElements();
-
-        mElementsCreated = true;
-    }
-}
-
-//_____________________________________________________________________________
-//
-void    AUBase::SetMaxFramesPerSlice(UInt32 nFrames)
-{
-    mMaxFramesPerSlice = nFrames;
-    if (mBuffersAllocated)
-        ReallocateBuffers();
-    PropertyChanged(kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0);
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::CanSetMaxFrames() const
-{
-    return IsInitialized() ? kAudioUnitErr_Initialized : OSStatus(noErr);
-}
-
-//_____________________________________________________________________________
-//
-void                AUBase::ReallocateBuffers()
-{
-    CreateElements();
-
-    UInt32 nOutputs = Outputs().GetNumberOfElements();
-    for (UInt32 i = 0; i < nOutputs; ++i) {
-        AUOutputElement *output = GetOutput(i);
-        output->AllocateBuffer();   // does no work if already allocated
-    }
-    UInt32 nInputs = Inputs().GetNumberOfElements();
-    for (UInt32 i = 0; i < nInputs; ++i) {
-        AUInputElement *input = GetInput(i);
-        input->AllocateBuffer();    // does no work if already allocated
-    }
-    mBuffersAllocated = true;
-}
-
-//_____________________________________________________________________________
-//
-void                AUBase::DeallocateIOBuffers()
-{
-    if (!mBuffersAllocated)
-        return;
-
-    UInt32 nOutputs = Outputs().GetNumberOfElements();
-    for (UInt32 i = 0; i < nOutputs; ++i) {
-        AUOutputElement *output = GetOutput(i);
-        output->DeallocateBuffer();
-    }
-    UInt32 nInputs = Inputs().GetNumberOfElements();
-    for (UInt32 i = 0; i < nInputs; ++i) {
-        AUInputElement *input = GetInput(i);
-        input->DeallocateBuffer();
-    }
-    mBuffersAllocated = false;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::DoInitialize()
-{
-    OSStatus result = noErr;
-
-    if (!mInitialized) {
-        result = Initialize();
-        if (result == noErr) {
-            if (CanScheduleParameters())
-                mParamList.reserve(24);
-            mHasBegunInitializing = true;
-            ReallocateBuffers();    // calls CreateElements()
-            mInitialized = true;    // signal that it's okay to render
-            CAMemoryBarrier();
-        }
-    }
-
-    return result;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::Initialize()
-{
-    return noErr;
-}
-
-//_____________________________________________________________________________
-//
-void                AUBase::PreDestructor()
-{
-    // this is called from the ComponentBase dispatcher, which doesn't know anything about our (optional) lock
-    CAMutex::Locker lock(mAUMutex);
-    DoCleanup();
-}
-
-//_____________________________________________________________________________
-//
-void                AUBase::DoCleanup()
-{
-    if (mInitialized)
-        Cleanup();
-
-    DeallocateIOBuffers();
-    ResetRenderTime ();
-
-    mInitialized = false;
-    mHasBegunInitializing = false;
-}
-
-//_____________________________________________________________________________
-//
-void                AUBase::Cleanup()
-{
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::Reset(                  AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement)
-{
-    ResetRenderTime ();
-    return noErr;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::DispatchGetPropertyInfo(AudioUnitPropertyID             inID,
-                                                    AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement,
-                                                    UInt32 &                        outDataSize,
-                                                    Boolean &                       outWritable)
-{
-    OSStatus result = noErr;
-    bool validateElement = true;
-
-    switch (inID) {
-    case kAudioUnitProperty_MakeConnection:
-        ca_require(inScope == kAudioUnitScope_Input || inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = sizeof(AudioUnitConnection);
-        outWritable = true;
-        break;
-
-
-    case kAudioUnitProperty_SetRenderCallback:
-        ca_require(AudioUnitAPIVersion() > 1, InvalidProperty);
-        ca_require(inScope == kAudioUnitScope_Input || inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = sizeof(AURenderCallbackStruct);
-        outWritable = true;
-        break;
-
-    case kAudioUnitProperty_StreamFormat:
-        outDataSize = sizeof(CAStreamBasicDescription);
-        outWritable = IsStreamFormatWritable(inScope, inElement);
-        break;
-
-    case kAudioUnitProperty_SampleRate:
-        outDataSize = sizeof(Float64);
-        outWritable = IsStreamFormatWritable(inScope, inElement);
-        break;
-
-    case kAudioUnitProperty_ClassInfo:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = sizeof(CFPropertyListRef);
-        outWritable = true;
-        break;
-
-    case kAudioUnitProperty_FactoryPresets:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        result = GetPresets(NULL);
-        if (!result) {
-            outDataSize = sizeof(CFArrayRef);
-            outWritable = false;
-        }
-        break;
-
-    case kAudioUnitProperty_PresentPreset:
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-#ifndef __LP64__
-    case kAudioUnitProperty_CurrentPreset:
-#endif
-#endif
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = sizeof(AUPreset);
-        outWritable = true;
-        break;
-
-    case kAudioUnitProperty_ElementName:
-        outDataSize = sizeof (CFStringRef);
-        outWritable = true;
-        break;
-
-    case kAudioUnitProperty_ParameterList:
-        {
-            UInt32 nparams = 0;
-            result = GetParameterList(inScope, NULL, nparams);
-
-            outDataSize = sizeof(AudioUnitParameterID) * nparams;
-            outWritable = false;
-            validateElement = false;
-        }
-        break;
-
-    case kAudioUnitProperty_ParameterInfo:
-        outDataSize = sizeof(AudioUnitParameterInfo);
-        outWritable = false;
-        validateElement = false;
-        break;
-
-    case kAudioUnitProperty_ParameterHistoryInfo:
-        outDataSize = sizeof(AudioUnitParameterHistoryInfo);
-        outWritable = false;
-        validateElement = false;
-        break;
-
-    case kAudioUnitProperty_ElementCount:
-        outDataSize = sizeof(UInt32);
-        outWritable = BusCountWritable(inScope);
-        validateElement = false;
-        break;
-
-    case kAudioUnitProperty_Latency:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = sizeof(Float64);
-        outWritable = false;
-        break;
-
-    case kAudioUnitProperty_TailTime:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        if (SupportsTail()) {
-            outDataSize = sizeof(Float64);
-            outWritable = false;
-        } else
-            goto InvalidProperty;
-        break;
-
-    case kAudioUnitProperty_MaximumFramesPerSlice:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = sizeof(UInt32);
-        outWritable = true;
-        break;
-
-    case kAudioUnitProperty_LastRenderError:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = sizeof(OSStatus);
-        outWritable = false;
-        break;
-
-    case kAudioUnitProperty_SupportedNumChannels:
-    {
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        UInt32 num = SupportedNumChannels (NULL);
-        if (num) {
-            outDataSize = sizeof (AUChannelInfo) * num;
-            result = noErr;
-        } else
-            goto InvalidProperty;
-        outWritable = false;
-        break;
-    }
-
-    case kAudioUnitProperty_SupportedChannelLayoutTags:
-    {
-        UInt32 numLayouts = GetChannelLayoutTags(inScope, inElement, NULL);
-        if (numLayouts) {
-            outDataSize = numLayouts * sizeof(AudioChannelLayoutTag);
-            result = noErr;
-        } else
-            goto InvalidProperty;
-        outWritable = false;
-        validateElement = false; //already done it
-        break;
-    }
-
-    case kAudioUnitProperty_AudioChannelLayout:
-    {
-        outWritable = false;
-        outDataSize = GetAudioChannelLayout(inScope, inElement, NULL, outWritable);
-        if (outDataSize) {
-            result = noErr;
-        } else {
-            if (GetChannelLayoutTags(inScope, inElement, NULL) == 0)
-                goto InvalidProperty;
-            else
-                result = kAudioUnitErr_InvalidPropertyValue;
-        }
-        validateElement = false; //already done it
-        break;
-    }
-
-#if (MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_5) || TARGET_OS_IPHONE
-    case kAudioUnitProperty_ShouldAllocateBuffer:
-        ca_require((inScope == kAudioUnitScope_Input || inScope == kAudioUnitScope_Output), InvalidScope);
-        outWritable = true;
-        outDataSize = sizeof(UInt32);
-        break;
-#endif
-
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-    case kAudioUnitProperty_FastDispatch:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        if (!IsCMgrObject()) goto InvalidProperty;
-        outDataSize = sizeof(void *);
-        outWritable = false;
-        validateElement = false;
-        break;
-
-    case kAudioUnitProperty_GetUIComponentList:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = GetNumCustomUIComponents();
-        if (outDataSize == 0)
-            goto InvalidProperty;
-        outDataSize *= sizeof (AudioComponentDescription);
-
-        outWritable = false;
-        break;
-#endif
-
-    case kAudioUnitProperty_ParameterValueStrings:
-        result = GetParameterValueStrings(inScope, inElement, NULL);
-        if (result == noErr) {
-            outDataSize = sizeof(CFArrayRef);
-            outWritable = false;
-            validateElement = false;
-        }
-        break;
-
-#if !CA_NO_AU_HOST_CALLBACKS
-    case kAudioUnitProperty_HostCallbacks:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = sizeof(mHostCallbackInfo);
-        outWritable = true;
-        break;
-#endif
-#if !CA_NO_AU_UI_FEATURES
-    case kAudioUnitProperty_ContextName:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = sizeof(CFStringRef);
-        outWritable = true;
-        break;
-
-    case kAudioUnitProperty_IconLocation:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        outWritable = false;
-        if (!HasIcon())
-            goto InvalidProperty;
-        outDataSize = sizeof(CFURLRef);
-        break;
-
-    case kAudioUnitProperty_ParameterClumpName:
-        outDataSize = sizeof(AudioUnitParameterNameInfo );
-        outWritable = false;
-        break;
-
-#endif // !CA_NO_AU_UI_FEATURES
-
-    case 'lrst' :  // kAudioUnitProperty_LastRenderedSampleTime
-        outDataSize = sizeof(Float64);
-        outWritable = false;
-        break;
-
-    case kAudioUnitProperty_NickName:
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        outDataSize = sizeof(CFStringRef);
-        outWritable = true;
-        break;
-
-    default:
-        result = GetPropertyInfo(inID, inScope, inElement, outDataSize, outWritable);
-        validateElement = false;
-        break;
-    }
-
-    if (result == noErr && validateElement) {
-        ca_require(GetElement(inScope, inElement) != NULL, InvalidElement);
-    }
-
-    return result;
-InvalidProperty:
-    return kAudioUnitErr_InvalidProperty;
-InvalidScope:
-    return kAudioUnitErr_InvalidScope;
-InvalidElement:
-    return kAudioUnitErr_InvalidElement;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::DispatchGetProperty(    AudioUnitPropertyID             inID,
-                                                    AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement,
-                                                    void *                          outData)
-{
-    // NOTE: We're currently only called from AUBase::ComponentEntryDispatch, which
-    // calls DispatchGetPropertyInfo first, which performs validation of the scope/element,
-    // and ensures that the outData buffer is non-null and large enough.
-    OSStatus result = noErr;
-
-    switch (inID) {
-    case kAudioUnitProperty_StreamFormat:
-        *(CAStreamBasicDescription *)outData = GetStreamFormat(inScope, inElement);
-        break;
-
-    case kAudioUnitProperty_SampleRate:
-        *(Float64 *)outData = GetStreamFormat(inScope, inElement).mSampleRate;
-        break;
-
-    case kAudioUnitProperty_ParameterList:
-        {
-            UInt32 nparams = 0;
-            result = GetParameterList(inScope, (AudioUnitParameterID *)outData, nparams);
-        }
-        break;
-
-    case kAudioUnitProperty_ParameterInfo:
-        result = GetParameterInfo(inScope, inElement, *(AudioUnitParameterInfo *)outData);
-        break;
-
-    case kAudioUnitProperty_ParameterHistoryInfo:
-        {
-            AudioUnitParameterHistoryInfo* info = (AudioUnitParameterHistoryInfo*)outData;
-            result = GetParameterHistoryInfo(inScope, inElement, info->updatesPerSecond, info->historyDurationInSeconds);
-        }
-        break;
-
-    case kAudioUnitProperty_ClassInfo:
-        {
-            *(CFPropertyListRef *)outData = NULL;
-            result = SaveState((CFPropertyListRef *)outData);
-        }
-        break;
-
-    case kAudioUnitProperty_FactoryPresets:
-        {
-            *(CFArrayRef *)outData = NULL;
-            result = GetPresets ((CFArrayRef *)outData);
-        }
-        break;
-
-    case kAudioUnitProperty_PresentPreset:
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-#ifndef __LP64__
-    case kAudioUnitProperty_CurrentPreset:
-#endif
-#endif
-        {
-            *(AUPreset *)outData = mCurrentPreset;
-
-                // retain current string (as client owns a reference to it and will release it)
-            if (inID == kAudioUnitProperty_PresentPreset && mCurrentPreset.presetName)
-                CFRetain (mCurrentPreset.presetName);
-
-            result = noErr;
-        }
-        break;
-
-    case kAudioUnitProperty_ElementName:
-        {
-            AUElement * element = GetElement(inScope, inElement);
-            if (element->HasName()) {
-                *(CFStringRef *)outData = element->GetName();
-                CFRetain (element->GetName());
-                result = noErr;
-            } else
-                result = kAudioUnitErr_InvalidPropertyValue;
-        }
-        break;
-
-    case kAudioUnitProperty_ElementCount:
-        *(UInt32 *)outData = GetScope(inScope).GetNumberOfElements();
-        break;
-
-    case kAudioUnitProperty_Latency:
-        *(Float64 *)outData = GetLatency();
-        break;
-
-    case kAudioUnitProperty_TailTime:
-        if (SupportsTail())
-            *(Float64 *)outData = GetTailTime();
-        else
-            result = kAudioUnitErr_InvalidProperty;
-        break;
-
-    case kAudioUnitProperty_MaximumFramesPerSlice:
-        *(UInt32 *)outData = mMaxFramesPerSlice;
-        break;
-
-    case kAudioUnitProperty_LastRenderError:
-        *(OSStatus *)outData = mLastRenderError;
-        mLastRenderError = 0;
-        break;
-
-    case kAudioUnitProperty_SupportedNumChannels:
-        {
-            const AUChannelInfo* infoPtr = NULL;
-            UInt32 num = SupportedNumChannels (&infoPtr);
-            if(num != 0 && infoPtr != NULL)
-                memcpy (outData, infoPtr, num * sizeof (AUChannelInfo));
-        }
-        break;
-
-    case kAudioUnitProperty_SupportedChannelLayoutTags:
-        {
-            AudioChannelLayoutTag* ptr = outData ? static_cast<AudioChannelLayoutTag*>(outData) : NULL;
-            UInt32 numLayouts = GetChannelLayoutTags (inScope, inElement, ptr);
-            if (numLayouts == 0)
-                result = kAudioUnitErr_InvalidProperty;
-        }
-        break;
-
-    case kAudioUnitProperty_AudioChannelLayout:
-    {
-        AudioChannelLayout* ptr = outData ? static_cast<AudioChannelLayout*>(outData) : NULL;
-        Boolean writable;
-        UInt32 dataSize = GetAudioChannelLayout(inScope, inElement, ptr, writable);
-        if (!dataSize) {
-            result = kAudioUnitErr_InvalidProperty;
-        }
-        break;
-    }
-
-#if (MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_5) || TARGET_OS_IPHONE
-    case kAudioUnitProperty_ShouldAllocateBuffer:
-    {
-        AUIOElement * element = GetIOElement(inScope, inElement);
-        *(UInt32*)outData = element->WillAllocateBuffer();
-        break;
-    }
-#endif
-
-    case kAudioUnitProperty_ParameterValueStrings:
-        result = GetParameterValueStrings(inScope, inElement, (CFArrayRef *)outData);
-        break;
-
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-    case kAudioUnitProperty_FastDispatch:
-        if (!IsCMgrObject()) result = kAudioUnitErr_InvalidProperty;
-        else {
-            switch (inElement) {
-            case kAudioUnitGetParameterSelect:
-                *(AudioUnitGetParameterProc *)outData = (AudioUnitGetParameterProc)CMgr_AudioUnitBaseGetParameter;
-                break;
-            case kAudioUnitSetParameterSelect:
-                *(AudioUnitSetParameterProc *)outData = (AudioUnitSetParameterProc)CMgr_AudioUnitBaseSetParameter;
-                break;
-            case kAudioUnitRenderSelect:
-                if (AudioUnitAPIVersion() > 1)
-                    *(AudioUnitRenderProc *)outData = (AudioUnitRenderProc)CMgr_AudioUnitBaseRender;
-                else result = kAudioUnitErr_InvalidElement;
-                break;
-            default:
-                result = GetProperty(inID, inScope, inElement, outData);
-                break;
-            }
-        }
-        break;
-
-    case kAudioUnitProperty_GetUIComponentList:
-        GetUIComponentDescs ((ComponentDescription*)outData);
-        break;
-#endif
-
-#if !CA_NO_AU_HOST_CALLBACKS
-    case kAudioUnitProperty_HostCallbacks:
-        memcpy(outData, &mHostCallbackInfo, sizeof(mHostCallbackInfo));
-        break;
-#endif
-#if !CA_NO_AU_UI_FEATURES
-    case kAudioUnitProperty_ContextName:
-        *(CFStringRef *)outData = mContextName;
-        if (mContextName) {
-            CFRetain(mContextName);
-            // retain CFString (if exists) since client will be responsible for its release
-            result = noErr;
-        } else {
-            result = kAudioUnitErr_InvalidPropertyValue;
-        }
-        break;
-
-    case kAudioUnitProperty_IconLocation:
-        {
-            CFURLRef iconLocation = CopyIconLocation();
-            if (iconLocation) {
-                *(CFURLRef*)outData = iconLocation;
-            } else
-                result = kAudioUnitErr_InvalidProperty;
-        }
-        break;
-
-    case kAudioUnitProperty_ParameterClumpName:
-        {
-            AudioUnitParameterNameInfo * ioClumpInfo = (AudioUnitParameterNameInfo*) outData;
-            if (ioClumpInfo->inID == kAudioUnitClumpID_System)  // this ID value is reserved
-                result = kAudioUnitErr_InvalidPropertyValue;
-            else
-            {
-                result = CopyClumpName(inScope, ioClumpInfo->inID, ioClumpInfo->inDesiredLength, &ioClumpInfo->outName);
-
-                    // this is provided for compatbility with existing implementations that don't know
-                    // about this new mechanism
-                if (result == kAudioUnitErr_InvalidProperty)
-                    result = GetProperty (inID, inScope, inElement, outData);
-            }
-        }
-        break;
-
-#endif  // !CA_NO_AU_UI_FEATURES
-
-    case 'lrst' : // kAudioUnitProperty_LastRenderedSampleTime
-        *(Float64*)outData = mCurrentRenderTime.mSampleTime;
-        break;
-
-    case kAudioUnitProperty_NickName:
-        // Ownership follows Core Foundation's 'Copy Rule'
-        if (mNickName) CFRetain(mNickName);
-        *(CFStringRef*)outData = mNickName;
-        break;
-
-    default:
-        result = GetProperty(inID, inScope, inElement, outData);
-        break;
-    }
-    return result;
-}
-
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::DispatchSetProperty(    AudioUnitPropertyID             inID,
-                                                    AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement,
-                                                    const void *                    inData,
-                                                    UInt32                          inDataSize)
-{
-    OSStatus result = noErr;
-
-    switch (inID) {
-    case kAudioUnitProperty_MakeConnection:
-        ca_require(inDataSize >= sizeof(AudioUnitConnection), InvalidPropertyValue);
-        {
-            AudioUnitConnection &connection = *(AudioUnitConnection *)inData;
-            result = SetConnection(connection);
-        }
-        break;
-
-
-    case kAudioUnitProperty_SetRenderCallback:
-        {
-            ca_require(inDataSize >= sizeof(AURenderCallbackStruct), InvalidPropertyValue);
-            ca_require(AudioUnitAPIVersion() > 1, InvalidProperty);
-            AURenderCallbackStruct &callback = *(AURenderCallbackStruct*)inData;
-            result = SetInputCallback(kAudioUnitProperty_SetRenderCallback, inElement, callback.inputProc, callback.inputProcRefCon);
-        }
-        break;
-
-    case kAudioUnitProperty_ElementCount:
-        ca_require(inDataSize == sizeof(UInt32), InvalidPropertyValue);
-        ca_require(BusCountWritable(inScope), NotWritable);
-        result = SetBusCount(inScope, *(UInt32*)inData);
-        if (result == noErr) {
-            PropertyChanged(inID, inScope, inElement);
-        }
-        break;
-
-    case kAudioUnitProperty_MaximumFramesPerSlice:
-        ca_require(inDataSize == sizeof(UInt32), InvalidPropertyValue);
-        result = CanSetMaxFrames();
-        if (result) return result;
-        SetMaxFramesPerSlice(*(UInt32 *)inData);
-        break;
-
-    case kAudioUnitProperty_StreamFormat:
-        {
-            if (inDataSize < 36) goto InvalidPropertyValue;
-            ca_require(GetElement(inScope, inElement) != NULL, InvalidElement);
-
-            CAStreamBasicDescription newDesc;
-                // now we're going to be ultra conservative! because of discrepancies between
-                // sizes of this struct based on aligment padding inconsistencies
-            memset (&newDesc, 0, sizeof(newDesc));
-            memcpy (&newDesc, inData, 36);
-
-            ca_require(SanityCheck(newDesc), InvalidFormat);
-
-            ca_require(ValidFormat(inScope, inElement, newDesc), InvalidFormat);
-
-            const CAStreamBasicDescription curDesc = GetStreamFormat(inScope, inElement);
-
-            if ( !curDesc.IsExactlyEqual(newDesc) ) {
-                ca_require(IsStreamFormatWritable(inScope, inElement), NotWritable);
-                result = ChangeStreamFormat(inScope, inElement, curDesc, newDesc);
-            }
-        }
-        break;
-
-    case kAudioUnitProperty_SampleRate:
-        {
-            ca_require(inDataSize == sizeof(Float64), InvalidPropertyValue);
-            ca_require(GetElement(inScope, inElement) != NULL, InvalidElement);
-
-            const CAStreamBasicDescription curDesc = GetStreamFormat(inScope, inElement);
-            CAStreamBasicDescription newDesc = curDesc;
-            newDesc.mSampleRate = *(Float64 *)inData;
-
-            ca_require(ValidFormat(inScope, inElement, newDesc), InvalidFormat);
-
-            if ( !curDesc.IsExactlyEqual(newDesc) ) {
-                ca_require(IsStreamFormatWritable(inScope, inElement), NotWritable);
-                result = ChangeStreamFormat(inScope, inElement, curDesc, newDesc);
-            }
-        }
-        break;
-
-    case kAudioUnitProperty_AudioChannelLayout:
-        {
-            const AudioChannelLayout *layout = static_cast<const AudioChannelLayout *>(inData);
-            size_t headerSize = sizeof(AudioChannelLayout) - sizeof(AudioChannelDescription);
-
-            ca_require(inDataSize >= headerSize + layout->mNumberChannelDescriptions * sizeof(AudioChannelDescription), InvalidPropertyValue);
-            result = SetAudioChannelLayout(inScope, inElement, layout);
-            if (result == noErr)
-                PropertyChanged(inID, inScope, inElement);
-            break;
-        }
-
-    case kAudioUnitProperty_ClassInfo:
-        ca_require(inDataSize == sizeof(CFPropertyListRef *), InvalidPropertyValue);
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        result = RestoreState(*(CFPropertyListRef *)inData);
-        break;
-
-    case kAudioUnitProperty_PresentPreset:
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-#ifndef __LP64__
-    case kAudioUnitProperty_CurrentPreset:
-#endif
-#endif
-        {
-            ca_require(inDataSize == sizeof(AUPreset), InvalidPropertyValue);
-            ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-            AUPreset & newPreset = *(AUPreset *)inData;
-
-            if (newPreset.presetNumber >= 0)
-            {
-                result = NewFactoryPresetSet(newPreset);
-                // NewFactoryPresetSet SHOULD call SetAFactoryPreset if the preset is valid
-                // from its own list of preset number->name
-                if (!result)
-                    PropertyChanged(inID, inScope, inElement);
-            }
-            else if (newPreset.presetName)
-            {
-                result = NewCustomPresetSet(newPreset);
-                if (!result)
-                    PropertyChanged(inID, inScope, inElement);
-            }
-            else
-                result = kAudioUnitErr_InvalidPropertyValue;
-        }
-        break;
-
-    case kAudioUnitProperty_ElementName:
-        {
-            ca_require(GetElement(inScope, inElement) != NULL, InvalidElement);
-            ca_require(inDataSize == sizeof(CFStringRef), InvalidPropertyValue);
-            AUElement * element = GetScope(inScope).GetElement (inElement);
-            element->SetName (*(CFStringRef *)inData);
-            PropertyChanged(inID, inScope, inElement);
-        }
-        break;
-
-#if (MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_5) || TARGET_OS_IPHONE
-    case kAudioUnitProperty_ShouldAllocateBuffer:
-        {
-            ca_require((inScope == kAudioUnitScope_Input || inScope == kAudioUnitScope_Output), InvalidScope);
-            ca_require(GetElement(inScope, inElement) != NULL, InvalidElement);
-            ca_require(inDataSize == sizeof(UInt32), InvalidPropertyValue);
-            ca_require(!IsInitialized(), Initialized);
-
-            AUIOElement * element = GetIOElement(inScope, inElement);
-            element->SetWillAllocateBuffer(*(UInt32 *)inData != 0);
-        }
-        break;
-#endif
-
-#if !CA_NO_AU_HOST_CALLBACKS
-    case kAudioUnitProperty_HostCallbacks:
-    {
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        UInt32 availSize = std::min(inDataSize, (UInt32)sizeof(HostCallbackInfo));
-        bool hasChanged = !memcmp (&mHostCallbackInfo, inData, availSize);
-        memset (&mHostCallbackInfo, 0, sizeof (mHostCallbackInfo));
-        memcpy (&mHostCallbackInfo, inData, availSize);
-        if (hasChanged)
-            PropertyChanged(inID, inScope, inElement);
-        break;
-    }
-#endif
-#if !CA_NO_AU_UI_FEATURES
-    case kAudioUnitProperty_SetExternalBuffer:
-        ca_require(inDataSize >= sizeof(AudioUnitExternalBuffer), InvalidPropertyValue);
-        ca_require(IsInitialized(), Uninitialized);
-        {
-            AudioUnitExternalBuffer &buf = *(AudioUnitExternalBuffer*)inData;
-            if (intptr_t(buf.buffer) & 0x0F) result = kAudio_ParamError;
-            else if (inScope == kAudioUnitScope_Input) {
-                AUInputElement *input = GetInput(inElement);
-                input->UseExternalBuffer(buf);
-            } else {
-                AUOutputElement *output = GetOutput(inElement);
-                output->UseExternalBuffer(buf);
-            }
-        }
-        break;
-
-    case kAudioUnitProperty_ContextName:
-        {
-            ca_require(inDataSize == sizeof(CFStringRef), InvalidPropertyValue);
-            ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-            CFStringRef inStr = *(CFStringRef *)inData;
-            if (mContextName) CFRelease(mContextName);
-            if (inStr) CFRetain(inStr);
-            mContextName = inStr;
-            PropertyChanged(inID, inScope, inElement);
-        }
-        break;
-
-#endif // !CA_NO_AU_UI_FEATURES
-
-    case kAudioUnitProperty_NickName:
-    {
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        ca_require(inDataSize == sizeof(CFStringRef), InvalidPropertyValue);
-        CFStringRef inStr = *(CFStringRef *)inData;
-        if (mNickName) CFRelease(mNickName);
-        if (inStr) CFRetain(inStr);
-        mNickName = inStr;
-        PropertyChanged(inID, inScope, inElement);
-        break;
-    }
-
-    default:
-        result = SetProperty(inID, inScope, inElement, inData, inDataSize);
-        if (result == noErr)
-            PropertyChanged(inID, inScope, inElement);
-
-        break;
-    }
-    return result;
-NotWritable:
-    return kAudioUnitErr_PropertyNotWritable;
-InvalidFormat:
-    return kAudioUnitErr_FormatNotSupported;
-#if !CA_NO_AU_UI_FEATURES
-Uninitialized:
-    return kAudioUnitErr_Uninitialized;
-#endif
-#if (MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_5) || CA_USE_AUDIO_PLUGIN_ONLY
-Initialized:
-    return kAudioUnitErr_Initialized;
-#endif
-InvalidScope:
-    return kAudioUnitErr_InvalidScope;
-InvalidProperty:
-    return kAudioUnitErr_InvalidProperty;
-InvalidPropertyValue:
-    return kAudioUnitErr_InvalidPropertyValue;
-InvalidElement:
-    return kAudioUnitErr_InvalidElement;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::DispatchRemovePropertyValue (AudioUnitPropertyID        inID,
-                                                    AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement)
-{
-    OSStatus result = noErr;
-    switch (inID)
-    {
-    case kAudioUnitProperty_AudioChannelLayout:
-    {
-        result = RemoveAudioChannelLayout(inScope, inElement);
-        if (result == noErr)
-            PropertyChanged(inID, inScope, inElement);
-        break;
-    }
-
-#if !CA_NO_AU_HOST_CALLBACKS
-    case kAudioUnitProperty_HostCallbacks:
-    {
-        ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
-        bool hasValue = false;
-        void* ptr = &mHostCallbackInfo;
-        for (unsigned int i = 0; i <  sizeof (HostCallbackInfo); ++i) {
-            if (static_cast<char*>(ptr)[i]) {
-                hasValue = true;
-                break;
-            }
-        }
-        if (hasValue) {
-            memset (&mHostCallbackInfo, 0, sizeof (HostCallbackInfo));
-            PropertyChanged(inID, inScope, inElement);
-        }
-        break;
-    }
-#endif
-#if !CA_NO_AU_UI_FEATURES
-    case kAudioUnitProperty_ContextName:
-        if (mContextName) CFRelease(mContextName);
-        mContextName = NULL;
-        result = noErr;
-        break;
-
-#endif // !CA_NO_AU_UI_FEATURES
-
-    case kAudioUnitProperty_NickName:
-    {
-        if(inScope == kAudioUnitScope_Global) {
-            if (mNickName) CFRelease(mNickName);
-            mNickName = NULL;
-            PropertyChanged(inID, inScope, inElement);
-        } else {
-            result = kAudioUnitErr_InvalidScope;
-        }
-        break;
-    }
-
-    default:
-        result = RemovePropertyValue (inID, inScope, inElement);
-        break;
-    }
-
-    return result;
-#if !CA_NO_AU_UI_FEATURES || !CA_NO_AU_HOST_CALLBACKS
-InvalidScope:
-    return kAudioUnitErr_InvalidScope;
-#endif
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::GetPropertyInfo(        AudioUnitPropertyID             inID,
-                                                    AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement,
-                                                    UInt32 &                        outDataSize,
-                                                    Boolean &                       outWritable)
-{
-    return kAudioUnitErr_InvalidProperty;
-}
-
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::GetProperty(            AudioUnitPropertyID             inID,
-                                                    AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement,
-                                                    void *                          outData)
-{
-    return kAudioUnitErr_InvalidProperty;
-}
-
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::SetProperty(            AudioUnitPropertyID             inID,
-                                                    AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement,
-                                                    const void *                    inData,
-                                                    UInt32                          inDataSize)
-{
-    return kAudioUnitErr_InvalidProperty;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::RemovePropertyValue (   AudioUnitPropertyID             inID,
-                                                    AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement)
-{
-    return kAudioUnitErr_InvalidPropertyValue;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::AddPropertyListener(    AudioUnitPropertyID             inID,
-                                                    AudioUnitPropertyListenerProc   inProc,
-                                                    void *                          inProcRefCon)
-{
-    PropertyListener pl;
-
-    pl.propertyID = inID;
-    pl.listenerProc = inProc;
-    pl.listenerRefCon = inProcRefCon;
-
-    if (mPropertyListeners.empty())
-        mPropertyListeners.reserve(32);
-    mPropertyListeners.push_back(pl);
-
-    return noErr;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::RemovePropertyListener(     AudioUnitPropertyID             inID,
-                                                        AudioUnitPropertyListenerProc   inProc,
-                                                        void *                          inProcRefCon,
-                                                        bool                            refConSpecified)
-{
-    // iterate in reverse so that it's safe to erase in the middle of the vector
-    for (int i = (int)mPropertyListeners.size(); --i >=0; ) {
-        PropertyListeners::iterator it = mPropertyListeners.begin() + i;
-        if ((*it).propertyID == inID && (*it).listenerProc == inProc && (!refConSpecified || (*it).listenerRefCon == inProcRefCon))
-            mPropertyListeners.erase(it);
-    }
-    return noErr;
-}
-
-//_____________________________________________________________________________
-//
-void                AUBase::PropertyChanged(            AudioUnitPropertyID             inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement)
-{
-    for (PropertyListeners::iterator it = mPropertyListeners.begin(); it != mPropertyListeners.end(); ++it)
-        if ((*it).propertyID == inID)
-            ((*it).listenerProc)((*it).listenerRefCon, mComponentInstance, inID, inScope, inElement);
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::SetRenderNotification(  AURenderCallback                inProc,
-                                                    void *                          inRefCon)
-{
-    if (inProc == NULL)
-        return kAudio_ParamError;
-
-    mRenderCallbacksTouched = true;
-    mRenderCallbacks.deferred_add(RenderCallback(inProc, inRefCon));
-            // this will do nothing if it's already in the list
-    return noErr;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::RemoveRenderNotification(   AURenderCallback            inProc,
-                                                        void *                      inRefCon)
-{
-    mRenderCallbacks.deferred_remove(RenderCallback(inProc, inRefCon));
-    return noErr;   // error?
-}
-
-//_____________________________________________________________________________
-//
-OSStatus    AUBase::GetParameter(           AudioUnitParameterID            inID,
-                                                    AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement,
-                                                    AudioUnitParameterValue &       outValue)
-{
-    AUElement *elem = SafeGetElement(inScope, inElement);
-    outValue = elem->GetParameter(inID);
-    return noErr;
-}
-
-
-//_____________________________________________________________________________
-//
-OSStatus    AUBase::SetParameter(           AudioUnitParameterID            inID,
-                                                    AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement,
-                                                    AudioUnitParameterValue         inValue,
-                                                    UInt32                          inBufferOffsetInFrames)
-{
-    AUElement *elem = SafeGetElement(inScope, inElement);
-    elem->SetParameter(inID, inValue);
-    return noErr;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus    AUBase::ScheduleParameter ( const AudioUnitParameterEvent       *inParameterEvent,
-                                                    UInt32                          inNumEvents)
-{
-    bool canScheduleParameters = CanScheduleParameters();
-
-    for (UInt32 i = 0; i < inNumEvents; ++i)
-    {
-        if (inParameterEvent[i].eventType == kParameterEvent_Immediate)
-        {
-            SetParameter (inParameterEvent[i].parameter,
-                            inParameterEvent[i].scope,
-                            inParameterEvent[i].element,
-                            inParameterEvent[i].eventValues.immediate.value,
-                            inParameterEvent[i].eventValues.immediate.bufferOffset);
-        }
-        if (canScheduleParameters) {
-            mParamList.push_back (inParameterEvent[i]);
-        }
-    }
-
-    return noErr;
-}
-
-// ____________________________________________________________________________
-//
-static bool SortParameterEventList(const AudioUnitParameterEvent &ev1, const AudioUnitParameterEvent &ev2 )
-{
-    int offset1 = ev1.eventType == kParameterEvent_Immediate ?  ev1.eventValues.immediate.bufferOffset : ev1.eventValues.ramp.startBufferOffset;
-    int offset2 = ev2.eventType == kParameterEvent_Immediate ?  ev2.eventValues.immediate.bufferOffset : ev2.eventValues.ramp.startBufferOffset;
-
-    if(offset1 < offset2) return true;
-    return false;
-}
-
-
-// ____________________________________________________________________________
-//
-OSStatus    AUBase::ProcessForScheduledParams(  ParameterEventList      &inParamList,
-                                                        UInt32                  inFramesToProcess,
-                                                        void                    *inUserData )
-{
-    OSStatus result = noErr;
-
-    int totalFramesToProcess = inFramesToProcess;
-
-    int framesRemaining = totalFramesToProcess;
-
-    unsigned int currentStartFrame = 0; // start of the whole buffer
-
-
-
-    // sort the ParameterEventList by startBufferOffset
-    std::sort(inParamList.begin(), inParamList.end(), SortParameterEventList);
-
-    ParameterEventList::iterator iter = inParamList.begin();
-
-
-    while(framesRemaining > 0 )
-    {
-        // first of all, go through the ramped automation events and find out where the next
-        // division of our whole buffer will be
-
-        int currentEndFrame = totalFramesToProcess; // start out assuming we'll process all the way to
-                                                    // the end of the buffer
-
-        iter = inParamList.begin();
-
-        // find the next break point
-        while(iter != inParamList.end() )
-        {
-            AudioUnitParameterEvent &event = *iter;
-
-            int offset = event.eventType == kParameterEvent_Immediate ?  event.eventValues.immediate.bufferOffset : event.eventValues.ramp.startBufferOffset;
-
-            if(offset > (int)currentStartFrame && offset < currentEndFrame )
-            {
-                currentEndFrame = offset;
-                break;
-            }
-
-            // consider ramp end to be a possible choice (there may be gaps in the supplied ramp events)
-            if(event.eventType == kParameterEvent_Ramped )
-            {
-                offset = event.eventValues.ramp.startBufferOffset + event.eventValues.ramp.durationInFrames;
-
-                if(offset > (int)currentStartFrame && offset < currentEndFrame )
-                {
-                    currentEndFrame = offset;
-                }
-            }
-
-            iter++;
-        }
-
-        int framesThisTime = currentEndFrame - currentStartFrame;
-
-        // next, setup the parameter maps to be current for the ramp parameters active during
-        // this time segment...
-
-        for(ParameterEventList::iterator iter2 = inParamList.begin(); iter2 != inParamList.end(); iter2++ )
-        {
-            AudioUnitParameterEvent &event = *iter2;
-
-            bool eventFallsInSlice;
-
-
-            if(event.eventType == kParameterEvent_Ramped)
-                eventFallsInSlice = event.eventValues.ramp.startBufferOffset < currentEndFrame
-                    && event.eventValues.ramp.startBufferOffset + event.eventValues.ramp.durationInFrames > currentStartFrame;
-            else /* kParameterEvent_Immediate */
-                // actually, for the same parameter, there may be future immediate events which override this one,
-                // but it's OK since the event list is sorted in time order, we're guaranteed to end up with the current one
-                eventFallsInSlice = event.eventValues.immediate.bufferOffset <= currentStartFrame;
-
-            if(eventFallsInSlice)
-            {
-                AUElement *element = GetElement(event.scope, event.element );
-
-                if(element) element->SetScheduledEvent( event.parameter,
-                                                        event,
-                                                        currentStartFrame,
-                                                        currentEndFrame - currentStartFrame );
-            }
-        }
-
-
-
-        // Finally, actually do the processing for this slice.....
-
-        result = ProcessScheduledSlice( inUserData,
-                                        currentStartFrame,
-                                        framesThisTime,
-                                        inFramesToProcess );
-
-        if(result != noErr) break;
-
-        framesRemaining -= framesThisTime;
-        currentStartFrame = currentEndFrame;    // now start from where we left off last time
-    }
-
-    return result;
-}
-
-//_____________________________________________________________________________
-//
-void                AUBase::SetWantsRenderThreadID (bool inFlag)
-{
-    if (inFlag == mWantsRenderThreadID)
-        return;
-
-    mWantsRenderThreadID = inFlag;
-    if (!mWantsRenderThreadID)
-        mRenderThreadID = NULL;
-}
-
-//_____________________________________________________________________________
-//
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::DoRender(       AudioUnitRenderActionFlags &    ioActionFlags,
-                                            const AudioTimeStamp &          inTimeStamp,
-                                            UInt32                          inBusNumber,
-                                            UInt32                          inFramesToProcess,
-                                            AudioBufferList &               ioData)
-{
-    OSStatus theError;
-    RenderCallbackList::iterator rcit;
-
-    AUTRACE(kCATrace_AUBaseRenderStart, mComponentInstance, (uintptr_t)this, inBusNumber, inFramesToProcess, (uintptr_t)ioData.mBuffers[0].mData);
-    DISABLE_DENORMALS
-
-    try {
-        ca_require(IsInitialized(), Uninitialized);
-        ca_require(mAudioUnitAPIVersion >= 2, ParamErr);
-        if (inFramesToProcess > mMaxFramesPerSlice) {
-            static UInt64 lastTimeMessagePrinted = 0;
-            UInt64 now = CAHostTimeBase::GetCurrentTime();
-            if (now - lastTimeMessagePrinted > CAHostTimeBase::GetFrequency()) { // not more than once per second.
-                lastTimeMessagePrinted = now;
-                syslog(LOG_ERR, "kAudioUnitErr_TooManyFramesToProcess : inFramesToProcess=%u, mMaxFramesPerSlice=%u", (unsigned)inFramesToProcess, (unsigned)mMaxFramesPerSlice);
-                DebugMessageN4("%s:%d inFramesToProcess=%u, mMaxFramesPerSlice=%u; TooManyFrames", __FILE__, __LINE__, (unsigned)inFramesToProcess, (unsigned)mMaxFramesPerSlice);
-            }
-            goto TooManyFrames;
-        }
-        ca_require (!UsesFixedBlockSize() || inFramesToProcess == GetMaxFramesPerSlice(), ParamErr);
-
-        AUOutputElement *output = GetOutput(inBusNumber);   // will throw if non-existant
-        if (output->GetStreamFormat().NumberChannelStreams() != ioData.mNumberBuffers) {
-            DebugMessageN4("%s:%d ioData.mNumberBuffers=%u, output->GetStreamFormat().NumberChannelStreams()=%u; kAudio_ParamError",
-                __FILE__, __LINE__, (unsigned)ioData.mNumberBuffers, (unsigned)output->GetStreamFormat().NumberChannelStreams());
-            goto ParamErr;
-        }
-
-        unsigned expectedBufferByteSize = inFramesToProcess * output->GetStreamFormat().mBytesPerFrame;
-        for (unsigned ibuf = 0; ibuf < ioData.mNumberBuffers; ++ibuf) {
-            AudioBuffer &buf = ioData.mBuffers[ibuf];
-            if (buf.mData != NULL) {
-                // only care about the size if the buffer is non-null
-                if (buf.mDataByteSize < expectedBufferByteSize) {
-                    // if the buffer is too small, we cannot render safely. kAudio_ParamError.
-                    DebugMessageN7("%s:%d %u frames, %u bytes/frame, expected %u-byte buffer; ioData.mBuffers[%u].mDataByteSize=%u; kAudio_ParamError",
-                        __FILE__, __LINE__, (unsigned)inFramesToProcess, (unsigned)output->GetStreamFormat().mBytesPerFrame, expectedBufferByteSize, ibuf, (unsigned)buf.mDataByteSize);
-                    goto ParamErr;
-                }
-                // Some clients incorrectly pass bigger buffers than expectedBufferByteSize.
-                // We will generally set the buffer size at the end of rendering, before we return.
-                // However we should ensure that no one, DURING rendering, READS a
-                // potentially incorrect size. This can lead to doing too much work, or
-                // reading past the end of an input buffer into unmapped memory.
-                buf.mDataByteSize = expectedBufferByteSize;
-            }
-        }
-
-        if (WantsRenderThreadID())
-        {
-            #if TARGET_OS_MAC
-                mRenderThreadID = pthread_self();
-            #elif TARGET_OS_WIN32
-                mRenderThreadID = GetCurrentThreadId();
-            #endif
-        }
-
-        AudioUnitRenderActionFlags flags;
-        if (mRenderCallbacksTouched) {
-            mRenderCallbacks.update();
-            flags = ioActionFlags | kAudioUnitRenderAction_PreRender;
-            for (rcit = mRenderCallbacks.begin(); rcit != mRenderCallbacks.end(); ++rcit) {
-                RenderCallback &rc = *rcit;
-                AUTRACE(kCATrace_AUBaseRenderCallbackStart, mComponentInstance, (intptr_t)this, (intptr_t)rc.mRenderNotify, 1, 0);
-                (*(AURenderCallback)rc.mRenderNotify)(rc.mRenderNotifyRefCon,
-                                &flags,
-                                &inTimeStamp, inBusNumber, inFramesToProcess, &ioData);
-                AUTRACE(kCATrace_AUBaseRenderCallbackEnd, mComponentInstance, (intptr_t)this, (intptr_t)rc.mRenderNotify, 1, 0);
-            }
-        }
-
-        theError = DoRenderBus(ioActionFlags, inTimeStamp, inBusNumber, output, inFramesToProcess, ioData);
-
-        if (mRenderCallbacksTouched) {
-            flags = ioActionFlags | kAudioUnitRenderAction_PostRender;
-
-            if (SetRenderError (theError)) {
-                flags |= kAudioUnitRenderAction_PostRenderError;
-            }
-
-            for (rcit = mRenderCallbacks.begin(); rcit != mRenderCallbacks.end(); ++rcit) {
-                RenderCallback &rc = *rcit;
-                AUTRACE(kCATrace_AUBaseRenderCallbackStart, mComponentInstance, (intptr_t)this, (intptr_t)rc.mRenderNotify, 2, 0);
-                (*(AURenderCallback)rc.mRenderNotify)(rc.mRenderNotifyRefCon,
-                                &flags,
-                                &inTimeStamp, inBusNumber, inFramesToProcess, &ioData);
-                AUTRACE(kCATrace_AUBaseRenderCallbackEnd, mComponentInstance, (intptr_t)this, (intptr_t)rc.mRenderNotify, 2, 0);
-            }
-        }
-
-        // The vector's being emptied
-        // because these events should only apply to this Render cycle, so anything
-        // left over is from a preceding cycle and should be dumped.  New scheduled
-        // parameters must be scheduled from the next pre-render callback.
-        if (!mParamList.empty())
-            mParamList.clear();
-
-    }
-    catch (OSStatus err) {
-        theError = err;
-        goto errexit;
-    }
-    catch (...) {
-        theError = -1;
-        goto errexit;
-    }
-done:
-    RESTORE_DENORMALS
-    AUTRACE(kCATrace_AUBaseRenderEnd, mComponentInstance, (intptr_t)this, theError, ioActionFlags, CATrace_ablData(ioData));
-
-    return theError;
-
-Uninitialized:  theError = kAudioUnitErr_Uninitialized;             goto errexit;
-ParamErr:       theError = kAudio_ParamError;                       goto errexit;
-TooManyFrames:  theError = kAudioUnitErr_TooManyFramesToProcess;    goto errexit;
-errexit:
-    DebugMessageN2 ("  from %s, render err: %d", GetLoggingString(), (int)theError);
-    SetRenderError(theError);
-    goto done;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus    AUBase::DoProcess ( AudioUnitRenderActionFlags  &       ioActionFlags,
-                                const AudioTimeStamp &              inTimeStamp,
-                                UInt32                              inFramesToProcess,
-                                AudioBufferList &                   ioData)
-{
-    OSStatus theError;
-    AUTRACE(kCATrace_AUBaseRenderStart, mComponentInstance, (intptr_t)this, -1, inFramesToProcess, 0);
-    DISABLE_DENORMALS
-
-    try {
-
-        if (!(ioActionFlags & (1 << 9)/*kAudioUnitRenderAction_DoNotCheckRenderArgs*/)) {
-            ca_require(IsInitialized(), Uninitialized);
-            ca_require(inFramesToProcess <= mMaxFramesPerSlice, TooManyFrames);
-            ca_require(!UsesFixedBlockSize() || inFramesToProcess == GetMaxFramesPerSlice(), ParamErr);
-
-            AUInputElement *input = GetInput(0);    // will throw if non-existant
-            if (input->GetStreamFormat().NumberChannelStreams() != ioData.mNumberBuffers) {
-                DebugMessageN4("%s:%d ioData.mNumberBuffers=%u, input->GetStreamFormat().NumberChannelStreams()=%u; kAudio_ParamError",
-                    __FILE__, __LINE__, (unsigned)ioData.mNumberBuffers, (unsigned)input->GetStreamFormat().NumberChannelStreams());
-                goto ParamErr;
-            }
-
-            unsigned expectedBufferByteSize = inFramesToProcess * input->GetStreamFormat().mBytesPerFrame;
-            for (unsigned ibuf = 0; ibuf < ioData.mNumberBuffers; ++ibuf) {
-                AudioBuffer &buf = ioData.mBuffers[ibuf];
-                if (buf.mData != NULL) {
-                    // only care about the size if the buffer is non-null
-                    if (buf.mDataByteSize < expectedBufferByteSize) {
-                        // if the buffer is too small, we cannot render safely. kAudio_ParamError.
-                        DebugMessageN7("%s:%d %u frames, %u bytes/frame, expected %u-byte buffer; ioData.mBuffers[%u].mDataByteSize=%u; kAudio_ParamError",
-                            __FILE__, __LINE__, (unsigned)inFramesToProcess, (unsigned)input->GetStreamFormat().mBytesPerFrame, expectedBufferByteSize, ibuf, (unsigned)buf.mDataByteSize);
-                        goto ParamErr;
-                    }
-                    // Some clients incorrectly pass bigger buffers than expectedBufferByteSize.
-                    // We will generally set the buffer size at the end of rendering, before we return.
-                    // However we should ensure that no one, DURING rendering, READS a
-                    // potentially incorrect size. This can lead to doing too much work, or
-                    // reading past the end of an input buffer into unmapped memory.
-                    buf.mDataByteSize = expectedBufferByteSize;
-                }
-            }
-        }
-
-        if (WantsRenderThreadID())
-        {
-            #if TARGET_OS_MAC
-                mRenderThreadID = pthread_self();
-            #elif TARGET_OS_WIN32
-                mRenderThreadID = GetCurrentThreadId();
-            #endif
-        }
-
-        if (NeedsToRender (inTimeStamp)) {
-            theError = ProcessBufferLists (ioActionFlags, ioData, ioData, inFramesToProcess);
-        } else
-            theError = noErr;
-
-    }
-    catch (OSStatus err) {
-        theError = err;
-        goto errexit;
-    }
-    catch (...) {
-        theError = -1;
-        goto errexit;
-    }
-done:
-    RESTORE_DENORMALS
-    AUTRACE(kCATrace_AUBaseRenderEnd, mComponentInstance, (intptr_t)this, theError, ioActionFlags, CATrace_ablData(ioData));
-
-    return theError;
-
-Uninitialized:  theError = kAudioUnitErr_Uninitialized;             goto errexit;
-ParamErr:       theError = kAudio_ParamError;                       goto errexit;
-TooManyFrames:  theError = kAudioUnitErr_TooManyFramesToProcess;    goto errexit;
-errexit:
-    DebugMessageN2 ("  from %s, process err: %d", GetLoggingString(), (int)theError);
-    SetRenderError(theError);
-    goto done;
-}
-
-OSStatus    AUBase::DoProcessMultiple ( AudioUnitRenderActionFlags  & ioActionFlags,
-                               const AudioTimeStamp &               inTimeStamp,
-                               UInt32                               inFramesToProcess,
-                               UInt32                               inNumberInputBufferLists,
-                               const AudioBufferList **             inInputBufferLists,
-                               UInt32                               inNumberOutputBufferLists,
-                               AudioBufferList **                   ioOutputBufferLists)
-{
-    OSStatus theError;
-    DISABLE_DENORMALS
-
-    try {
-
-        if (!(ioActionFlags & (1 << 9)/*kAudioUnitRenderAction_DoNotCheckRenderArgs*/)) {
-            ca_require(IsInitialized(), Uninitialized);
-            ca_require(inFramesToProcess <= mMaxFramesPerSlice, TooManyFrames);
-            ca_require (!UsesFixedBlockSize() || inFramesToProcess == GetMaxFramesPerSlice(), ParamErr);
-
-            for (unsigned ibl = 0; ibl < inNumberInputBufferLists; ++ibl) {
-                if (inInputBufferLists[ibl] != NULL) {
-                    AUInputElement *input = GetInput(ibl);  // will throw if non-existant
-                    unsigned expectedBufferByteSize = inFramesToProcess * input->GetStreamFormat().mBytesPerFrame;
-
-                    if (input->GetStreamFormat().NumberChannelStreams() != inInputBufferLists[ibl]->mNumberBuffers) {
-                        DebugMessageN5("%s:%d inInputBufferLists[%u]->mNumberBuffers=%u, input->GetStreamFormat().NumberChannelStreams()=%u; kAudio_ParamError",
-                                       __FILE__, __LINE__, ibl, (unsigned)inInputBufferLists[ibl]->mNumberBuffers, (unsigned)input->GetStreamFormat().NumberChannelStreams());
-                        goto ParamErr;
-                    }
-
-                    for (unsigned ibuf = 0; ibuf < inInputBufferLists[ibl]->mNumberBuffers; ++ibuf) {
-                        const AudioBuffer &buf = inInputBufferLists[ibl]->mBuffers[ibuf];
-                        if (buf.mData != NULL) {
-                            if (buf.mDataByteSize < expectedBufferByteSize) {
-                                // the buffer is too small
-                                DebugMessageN8("%s:%d %u frames, %u bytes/frame, expected %u-byte buffer; inInputBufferLists[%u].mBuffers[%u].mDataByteSize=%u; kAudio_ParamError",
-                                               __FILE__, __LINE__, (unsigned)inFramesToProcess, (unsigned)input->GetStreamFormat().mBytesPerFrame, expectedBufferByteSize, ibl, ibuf, (unsigned)buf.mDataByteSize);
-                                goto ParamErr;
-                            }
-                        } else {
-                            // the buffer must exist
-                            goto ParamErr;
-                        }
-                    }
-                } else {
-                    // skip NULL input audio buffer list
-                }
-            }
-
-            for (unsigned obl = 0; obl < inNumberOutputBufferLists; ++obl) {
-                if (ioOutputBufferLists[obl] != NULL) {
-                    AUOutputElement *output = GetOutput(obl);   // will throw if non-existant
-                    unsigned expectedBufferByteSize = inFramesToProcess * output->GetStreamFormat().mBytesPerFrame;
-
-                    if (output->GetStreamFormat().NumberChannelStreams() != ioOutputBufferLists[obl]->mNumberBuffers) {
-                        DebugMessageN5("%s:%d ioOutputBufferLists[%u]->mNumberBuffers=%u, output->GetStreamFormat().NumberChannelStreams()=%u; kAudio_ParamError",
-                                       __FILE__, __LINE__, obl, (unsigned)ioOutputBufferLists[obl]->mNumberBuffers, (unsigned)output->GetStreamFormat().NumberChannelStreams());
-                        goto ParamErr;
-                    }
-
-                    for (unsigned obuf = 0; obuf < ioOutputBufferLists[obl]->mNumberBuffers; ++obuf) {
-                        AudioBuffer &buf = ioOutputBufferLists[obl]->mBuffers[obuf];
-                        if (buf.mData != NULL) {
-                            // only care about the size if the buffer is non-null
-                            if (buf.mDataByteSize < expectedBufferByteSize) {
-                                // if the buffer is too small, we cannot render safely. kAudio_ParamError.
-                                DebugMessageN8("%s:%d %u frames, %u bytes/frame, expected %u-byte buffer; ioOutputBufferLists[%u]->mBuffers[%u].mDataByteSize=%u; kAudio_ParamError",
-                                               __FILE__, __LINE__, (unsigned)inFramesToProcess, (unsigned)output->GetStreamFormat().mBytesPerFrame, expectedBufferByteSize, obl, obuf, (unsigned)buf.mDataByteSize);
-                                goto ParamErr;
-                            }
-                            // Some clients incorrectly pass bigger buffers than expectedBufferByteSize.
-                            // We will generally set the buffer size at the end of rendering, before we return.
-                            // However we should ensure that no one, DURING rendering, READS a
-                            // potentially incorrect size. This can lead to doing too much work, or
-                            // reading past the end of an input buffer into unmapped memory.
-                            buf.mDataByteSize = expectedBufferByteSize;
-                        }
-                    }
-                } else {
-                    // skip NULL output audio buffer list
-                }
-            }
-        }
-
-        if (WantsRenderThreadID())
-        {
-#if TARGET_OS_MAC
-            mRenderThreadID = pthread_self();
-#elif TARGET_OS_WIN32
-            mRenderThreadID = GetCurrentThreadId();
-#endif
-        }
-
-        if (NeedsToRender (inTimeStamp)) {
-            theError = ProcessMultipleBufferLists (ioActionFlags, inFramesToProcess, inNumberInputBufferLists, inInputBufferLists, inNumberOutputBufferLists, ioOutputBufferLists);
-        } else
-            theError = noErr;
-    }
-    catch (OSStatus err) {
-        theError = err;
-        goto errexit;
-    }
-    catch (...) {
-        theError = -1;
-        goto errexit;
-    }
-done:
-    RESTORE_DENORMALS
-
-    return theError;
-
-Uninitialized:  theError = kAudioUnitErr_Uninitialized;             goto errexit;
-ParamErr:       theError = kAudio_ParamError;                       goto errexit;
-TooManyFrames:  theError = kAudioUnitErr_TooManyFramesToProcess;    goto errexit;
-errexit:
-    DebugMessageN2 ("  from %s, processmultiple err: %d", GetLoggingString(), (int)theError);
-    SetRenderError(theError);
-    goto done;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::SetInputCallback(       UInt32                          inPropertyID,
-                                                    AudioUnitElement                inElement,
-                                                    AURenderCallback                inProc,
-                                                    void *                          inRefCon)
-{
-    AUInputElement *input = GetInput(inElement);    // may throw
-
-    input->SetInputCallback(inProc, inRefCon);
-    PropertyChanged(inPropertyID, kAudioUnitScope_Input, inElement);
-
-    return noErr;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::SetConnection(          const AudioUnitConnection &     inConnection)
-{
-
-    OSStatus err;
-    AUInputElement *input = GetInput(inConnection.destInputNumber); // may throw
-
-    if (inConnection.sourceAudioUnit) {
-        // connecting, not disconnecting
-        CAStreamBasicDescription sourceDesc;
-        UInt32 size = sizeof(CAStreamBasicDescription);
-        ca_require_noerr(err = AudioUnitGetProperty(
-                                        inConnection.sourceAudioUnit,
-                                        kAudioUnitProperty_StreamFormat,
-                                        kAudioUnitScope_Output,
-                                        inConnection.sourceOutputNumber,
-                                        &sourceDesc,
-                                        &size), errexit);
-        ca_require_noerr(err = DispatchSetProperty (kAudioUnitProperty_StreamFormat,
-                                kAudioUnitScope_Input, inConnection.destInputNumber,
-                                &sourceDesc, sizeof(CAStreamBasicDescription)), errexit);
-    }
-    input->SetConnection(inConnection);
-
-    PropertyChanged(kAudioUnitProperty_MakeConnection, kAudioUnitScope_Input, inConnection.destInputNumber);
-    return noErr;
-
-errexit:
-    return err;
-}
-
-//_____________________________________________________________________________
-//
-UInt32              AUBase::SupportedNumChannels (  const AUChannelInfo**           outInfo)
-{
-    return 0;
-}
-
-//_____________________________________________________________________________
-//
-bool                AUBase::ValidFormat(            AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement,
-                                                    const CAStreamBasicDescription &        inNewFormat)
-{
-    bool isInterleaved = false;
-
-    return inNewFormat.IsCommonFloat32(&isInterleaved) && !isInterleaved;
-}
-
-//_____________________________________________________________________________
-//
-bool                AUBase::IsStreamFormatWritable( AudioUnitScope                  scope,
-                                                    AudioUnitElement                element)
-{
-    switch (scope) {
-    case kAudioUnitScope_Input:
-        {
-            AUInputElement *input = GetInput(element);
-            if (input->HasConnection()) return false;   // can't write format when input comes from connection
-        }
-        // ... fall ...
-    case kAudioUnitScope_Output:
-        return StreamFormatWritable(scope, element);
-
-//#warning "aliasing of global scope format should be pushed to subclasses"
-    case kAudioUnitScope_Global:
-        return StreamFormatWritable(kAudioUnitScope_Output, 0);
-    }
-    return false;
-}
-
-//_____________________________________________________________________________
-//
-const CAStreamBasicDescription &
-                    AUBase::GetStreamFormat(        AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement)
-{
-//#warning "aliasing of global scope format should be pushed to subclasses"
-    AUIOElement *element;
-
-    switch (inScope) {
-    case kAudioUnitScope_Input:
-        element = Inputs().GetIOElement(inElement);
-        break;
-    case kAudioUnitScope_Output:
-        element = Outputs().GetIOElement(inElement);
-        break;
-    case kAudioUnitScope_Global:    // global stream description is an alias for that of output 0
-        element = Outputs().GetIOElement(0);
-        break;
-    default:
-        COMPONENT_THROW(kAudioUnitErr_InvalidScope);
-    }
-    return element->GetStreamFormat();
-}
-
-OSStatus            AUBase::SetBusCount(    AudioUnitScope                  inScope,
-                                            UInt32                          inCount)
-{
-    if (IsInitialized())
-        return kAudioUnitErr_Initialized;
-
-    GetScope(inScope).SetNumberOfElements(inCount);
-    return noErr;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::ChangeStreamFormat(     AudioUnitScope                  inScope,
-                                                    AudioUnitElement                inElement,
-                                                    const CAStreamBasicDescription & inPrevFormat,
-                                                    const CAStreamBasicDescription & inNewFormat)
-{
-    if (inNewFormat.IsExactlyEqual(inPrevFormat))
-        return noErr;
-
-//#warning "aliasing of global scope format should be pushed to subclasses"
-    AUIOElement *element;
-
-    switch (inScope) {
-    case kAudioUnitScope_Input:
-        element = Inputs().GetIOElement(inElement);
-        break;
-    case kAudioUnitScope_Output:
-        element = Outputs().GetIOElement(inElement);
-        break;
-    case kAudioUnitScope_Global:
-        element = Outputs().GetIOElement(0);
-        break;
-    default:
-        COMPONENT_THROW(kAudioUnitErr_InvalidScope);
-    }
-    element->SetStreamFormat(inNewFormat);
-    PropertyChanged(kAudioUnitProperty_StreamFormat, inScope, inElement);
-    return noErr;
-}
-
-UInt32      AUBase::GetChannelLayoutTags(   AudioUnitScope              inScope,
-                                            AudioUnitElement            inElement,
-                                            AudioChannelLayoutTag *     outLayoutTags)
-{
-    return GetIOElement(inScope, inElement)->GetChannelLayoutTags(outLayoutTags);
-}
-
-UInt32      AUBase::GetAudioChannelLayout(  AudioUnitScope              scope,
-                                            AudioUnitElement            element,
-                                            AudioChannelLayout *        outLayoutPtr,
-                                            Boolean &                   outWritable)
-{
-    AUIOElement * el = GetIOElement(scope, element);
-    return el->GetAudioChannelLayout(outLayoutPtr, outWritable);
-}
-
-OSStatus    AUBase::RemoveAudioChannelLayout(           AudioUnitScope              inScope,
-                                                        AudioUnitElement            inElement)
-{
-    OSStatus result = noErr;
-    AUIOElement * el = GetIOElement(inScope, inElement);
-    Boolean writable;
-    if (el->GetAudioChannelLayout(NULL, writable)) {
-        result = el->RemoveAudioChannelLayout();
-    }
-    return result;
-}
-
-OSStatus    AUBase::SetAudioChannelLayout(              AudioUnitScope              inScope,
-                                                        AudioUnitElement            inElement,
-                                                        const AudioChannelLayout *  inLayout)
-{
-    AUIOElement* ioEl = GetIOElement (inScope, inElement);
-
-    // the num channels of the layout HAS TO MATCH the current channels of the Element's stream format
-    UInt32 currentChannels = ioEl->GetStreamFormat().NumberChannels();
-    UInt32 numChannelsInLayout = CAAudioChannelLayout::NumberChannels(*inLayout);
-    if (currentChannels != numChannelsInLayout)
-        return kAudioUnitErr_InvalidPropertyValue;
-
-    UInt32 numLayouts = GetChannelLayoutTags (inScope, inElement, NULL);
-    if (numLayouts == 0)
-        return kAudioUnitErr_InvalidProperty;
-    AudioChannelLayoutTag *tags = (AudioChannelLayoutTag *)CA_malloc (numLayouts * sizeof (AudioChannelLayoutTag));
-    GetChannelLayoutTags (inScope, inElement, tags);
-    bool foundTag = false;
-    for (unsigned int i = 0; i < numLayouts; ++i) {
-        if (tags[i] == inLayout->mChannelLayoutTag || tags[i] == kAudioChannelLayoutTag_UseChannelDescriptions) {
-            foundTag = true;
-            break;
-        }
-    }
-    free(tags);
-
-    if (foundTag == false)
-        return kAudioUnitErr_InvalidPropertyValue;
-
-    return ioEl->SetAudioChannelLayout(*inLayout);
-}
-
-static void AddNumToDictionary (CFMutableDictionaryRef dict, CFStringRef key, SInt32 value)
-{
-    CFNumberRef num = CFNumberCreate (NULL, kCFNumberSInt32Type, &value);
-    CFDictionarySetValue (dict, key, num);
-    CFRelease (num);
-}
-
-#define kCurrentSavedStateVersion 0
-
-OSStatus            AUBase::SaveState(      CFPropertyListRef * outData)
-{
-    AudioComponentDescription desc = GetComponentDescription();
-
-    CFMutableDictionaryRef dict = CFDictionaryCreateMutable (NULL, 0,
-                                &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
-
-// first step -> save the version to the data ref
-    SInt32 value = kCurrentSavedStateVersion;
-    AddNumToDictionary (dict, kVersionString, value);
-
-// second step -> save the component type, subtype, manu to the data ref
-    value = desc.componentType;
-    AddNumToDictionary (dict, kTypeString, value);
-
-    value = desc.componentSubType;
-    AddNumToDictionary (dict, kSubtypeString, value);
-
-    value = desc.componentManufacturer;
-    AddNumToDictionary (dict, kManufacturerString, value);
-
-// fourth step -> save the state of all parameters on all scopes and elements
-    CFMutableDataRef data = CFDataCreateMutable(NULL, 0);
-    for (AudioUnitScope iscope = 0; iscope < 3; ++iscope) {
-        AUScope &scope = GetScope(iscope);
-        scope.SaveState (data);
-    }
-
-    SaveExtendedScopes(data);
-
-// save all this in the data section of the dictionary
-    CFDictionarySetValue(dict, kDataString, data);
-    CFRelease (data);
-
-//OK - now we're going to do some properties
-//save the preset name...
-    CFDictionarySetValue (dict, kNameString, mCurrentPreset.presetName);
-
-// Does the unit support the RenderQuality property - if so, save it...
-    value = 0;
-    OSStatus result = DispatchGetProperty (kAudioUnitProperty_RenderQuality,
-                                kAudioUnitScope_Global,
-                                0,
-                                &value);
-
-    if (result == noErr) {
-        AddNumToDictionary (dict, kRenderQualityString, value);
-    }
-
-// Does the unit support the CPULoad Quality property - if so, save it...
-    Float32 cpuLoad;
-    result = DispatchGetProperty (6/*kAudioUnitProperty_CPULoad*/,
-                                kAudioUnitScope_Global,
-                                0,
-                                &cpuLoad);
-
-    if (result == noErr) {
-        CFNumberRef num = CFNumberCreate (NULL, kCFNumberFloatType, &cpuLoad);
-        CFDictionarySetValue (dict, kCPULoadString, num);
-        CFRelease (num);
-    }
-
-// Do we have any element names for any of our scopes?
-    // first check to see if we have any names...
-    bool foundName = false;
-    for (AudioUnitScope i = 0; i < kNumScopes; ++i) {
-        foundName = GetScope (i).HasElementWithName();
-        if (foundName)
-            break;
-    }
-        // OK - we found a name away we go...
-    if (foundName) {
-        CFMutableDictionaryRef nameDict = CFDictionaryCreateMutable (NULL, 0,
-                                &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
-        for (AudioUnitScope i = 0; i < kNumScopes; ++i) {
-            GetScope (i).AddElementNamesToDict (nameDict);
-        }
-
-        CFDictionarySetValue (dict, kElementNameString, nameDict);
-        CFRelease (nameDict);
-    }
-
-// we're done!!!
-    *outData = dict;
-
-    return noErr;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::RestoreState(   CFPropertyListRef   plist)
-{
-    if (CFGetTypeID(plist) != CFDictionaryGetTypeID()) return kAudioUnitErr_InvalidPropertyValue;
-
-    AudioComponentDescription desc = GetComponentDescription();
-
-    CFDictionaryRef dict = static_cast<CFDictionaryRef>(plist);
-
-// zeroeth step - make sure the Part key is NOT present, as this method is used
-// to restore the GLOBAL state of the dictionary
-    if (CFDictionaryContainsKey (dict, kPartString))
-        return kAudioUnitErr_InvalidPropertyValue;
-
-// first step -> check the saved version in the data ref
-// at this point we're only dealing with version==0
-    CFNumberRef cfnum = reinterpret_cast<CFNumberRef>(CFDictionaryGetValue (dict, kVersionString));
-    if (cfnum == NULL) return kAudioUnitErr_InvalidPropertyValue;
-    SInt32 value;
-    CFNumberGetValue (cfnum, kCFNumberSInt32Type, &value);
-    if (value != kCurrentSavedStateVersion) return kAudioUnitErr_InvalidPropertyValue;
-
-// second step -> check that this data belongs to this kind of audio unit
-// by checking the component subtype and manuID
-// We're not checking the type, since there may be different versions (effect, format-converter, offline)
-// of essentially the same AU
-    cfnum = reinterpret_cast<CFNumberRef>(CFDictionaryGetValue (dict, kSubtypeString));
-    if (cfnum == NULL) return kAudioUnitErr_InvalidPropertyValue;
-    CFNumberGetValue (cfnum, kCFNumberSInt32Type, &value);
-    if (UInt32(value) != desc.componentSubType) return kAudioUnitErr_InvalidPropertyValue;
-
-    cfnum = reinterpret_cast<CFNumberRef>(CFDictionaryGetValue (dict, kManufacturerString));
-    if (cfnum == NULL) return kAudioUnitErr_InvalidPropertyValue;
-    CFNumberGetValue (cfnum, kCFNumberSInt32Type, &value);
-    if (UInt32(value) != desc.componentManufacturer) return kAudioUnitErr_InvalidPropertyValue;
-
-// fourth step -> restore the state of all of the parameters for each scope and element
-    CFDataRef data = reinterpret_cast<CFDataRef>(CFDictionaryGetValue (dict, kDataString));
-    if (data != NULL)
-    {
-        const UInt8 *p, *pend;
-
-        p = CFDataGetBytePtr(data);
-        pend = p + CFDataGetLength(data);
-
-        // we have a zero length data, which may just mean there were no parameters to save!
-        //  if (p >= pend) return noErr;
-
-        while (p < pend) {
-            UInt32 scopeIdx = CFSwapInt32BigToHost(*(UInt32 *)p);
-            p += sizeof(UInt32);
-
-            AUScope &scope = GetScope(scopeIdx);
-            p = scope.RestoreState(p);
-        }
-    }
-
-//OK - now we're going to do some properties
-//restore the preset name...
-    CFStringRef name = reinterpret_cast<CFStringRef>(CFDictionaryGetValue (dict, kNameString));
-    if (mCurrentPreset.presetName) CFRelease (mCurrentPreset.presetName);
-    if (name)
-    {
-        mCurrentPreset.presetName = name;
-        mCurrentPreset.presetNumber = -1;
-    }
-    else { // no name entry make the default one
-        mCurrentPreset.presetName = kUntitledString;
-        mCurrentPreset.presetNumber = -1;
-    }
-
-    CFRetain (mCurrentPreset.presetName);
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-#ifndef __LP64__
-    PropertyChanged(kAudioUnitProperty_CurrentPreset, kAudioUnitScope_Global, 0);
-#endif
-#endif
-    PropertyChanged(kAudioUnitProperty_PresentPreset, kAudioUnitScope_Global, 0);
-
-// Does the dict contain render quality information?
-    if (CFDictionaryGetValueIfPresent (dict, kRenderQualityString, reinterpret_cast<const void**>(&cfnum)))
-    {
-        CFNumberGetValue (cfnum, kCFNumberSInt32Type, &value);
-        DispatchSetProperty (kAudioUnitProperty_RenderQuality,
-                                kAudioUnitScope_Global,
-                                0,
-                                &value,
-                                sizeof(value));
-    }
-
-// Does the unit support the CPULoad Quality property - if so, save it...
-    if (CFDictionaryGetValueIfPresent (dict, kCPULoadString, reinterpret_cast<const void**>(&cfnum)))
-    {
-        Float32 floatValue;
-        CFNumberGetValue (cfnum, kCFNumberFloatType, &floatValue);
-        DispatchSetProperty (6/*kAudioUnitProperty_CPULoad*/,
-                                kAudioUnitScope_Global,
-                                0,
-                                &floatValue,
-                                sizeof(floatValue));
-    }
-
-// Do we have any element names for any of our scopes?
-    CFDictionaryRef nameDict;
-    if (CFDictionaryGetValueIfPresent (dict, kElementNameString, reinterpret_cast<const void**>(&nameDict)))
-    {
-        char string[64];
-        for (int i = 0; i < kNumScopes; ++i)
-        {
-            snprintf (string, sizeof(string), "%d", i);
-            CFStringRef key = CFStringCreateWithCString (NULL, string, kCFStringEncodingASCII);
-            CFDictionaryRef elementDict;
-            if (CFDictionaryGetValueIfPresent (nameDict, key, reinterpret_cast<const void**>(&elementDict)))
-            {
-                bool didAddElements = GetScope (i).RestoreElementNames (elementDict);
-                if (didAddElements)
-                    PropertyChanged (kAudioUnitProperty_ElementCount, i, 0);
-            }
-            CFRelease (key);
-        }
-    }
-
-    return noErr;
-}
-
-OSStatus            AUBase::GetPresets (            CFArrayRef *                    outData) const
-{
-    return kAudioUnitErr_InvalidProperty;
-}
-
-OSStatus            AUBase::NewFactoryPresetSet (const AUPreset & inNewFactoryPreset)
-{
-    return kAudioUnitErr_InvalidProperty;
-}
-
-OSStatus            AUBase::NewCustomPresetSet (const AUPreset & inNewCustomPreset)
-{
-    CFRelease (mCurrentPreset.presetName);
-    mCurrentPreset = inNewCustomPreset;
-    CFRetain (mCurrentPreset.presetName);
-    return noErr;
-}
-
-        // set the default preset for the unit -> the number of the preset MUST be >= 0
-        // and the name should be valid, or the preset WON'T take
-bool                AUBase::SetAFactoryPresetAsCurrent (const AUPreset & inPreset)
-{
-    if (inPreset.presetNumber < 0 || inPreset.presetName == NULL) return false;
-    CFRelease (mCurrentPreset.presetName);
-    mCurrentPreset = inPreset;
-    CFRetain (mCurrentPreset.presetName);
-    return true;
-}
-
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-int         AUBase::GetNumCustomUIComponents ()
-{
-    return 0;
-}
-
-void        AUBase::GetUIComponentDescs (ComponentDescription* inDescArray) {}
-#endif
-
-bool        AUBase::HasIcon ()
-{
-#if !CA_NO_AU_UI_FEATURES
-    CFURLRef url = CopyIconLocation();
-    if (url) {
-        CFRelease (url);
-        return true;
-    }
-#endif
-    return false;
-}
-
-CFURLRef    AUBase::CopyIconLocation ()
-{
-    return NULL;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::GetParameterList(       AudioUnitScope                  inScope,
-                                                    AudioUnitParameterID *          outParameterList,
-                                                    UInt32 &                        outNumParameters)
-{
-    AUScope &scope = GetScope(inScope);
-    AUElement *elementWithMostParameters = NULL;
-    UInt32 maxNumParams = 0;
-
-    int nElems = scope.GetNumberOfElements();
-    for (int ielem = 0; ielem < nElems; ++ielem) {
-        AUElement *element = scope.GetElement(ielem);
-        UInt32 nParams = element->GetNumberOfParameters();
-        if (nParams > maxNumParams) {
-            maxNumParams = nParams;
-            elementWithMostParameters = element;
-        }
-    }
-
-    if (outParameterList != NULL && elementWithMostParameters != NULL)
-        elementWithMostParameters->GetParameterList(outParameterList);
-
-    outNumParameters = maxNumParams;
-    return noErr;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::GetParameterInfo(       AudioUnitScope          inScope,
-                                                    AudioUnitParameterID    inParameterID,
-                                                    AudioUnitParameterInfo  &outParameterInfo )
-{
-    return kAudioUnitErr_InvalidParameter;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::GetParameterValueStrings(AudioUnitScope         inScope,
-                                                    AudioUnitParameterID    inParameterID,
-                                                    CFArrayRef *            outStrings)
-{
-    return kAudioUnitErr_InvalidProperty;
-}
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::GetParameterHistoryInfo(    AudioUnitScope                  inScope,
-                                                        AudioUnitParameterID            inParameterID,
-                                                        Float32 &                       outUpdatesPerSecond,
-                                                        Float32 &                       outHistoryDurationInSeconds)
-{
-    return kAudioUnitErr_InvalidProperty;
-}
-
-
-//_____________________________________________________________________________
-//
-OSStatus            AUBase::CopyClumpName(          AudioUnitScope          inScope,
-                                                    UInt32                  inClumpID,
-                                                    UInt32                  inDesiredNameLength,
-                                                    CFStringRef *           outClumpName)
-{
-    return kAudioUnitErr_InvalidProperty;
-}
-
-//_____________________________________________________________________________
-//
-void                AUBase::SetNumberOfElements(    AudioUnitScope                  inScope,
-                                                    UInt32                          numElements)
-{
-    if (inScope == kAudioUnitScope_Global && numElements != 1)
-        COMPONENT_THROW(kAudioUnitErr_InvalidScope);
-
-    GetScope(inScope).SetNumberOfElements(numElements);
-}
-
-//_____________________________________________________________________________
-//
-AUElement *         AUBase::CreateElement(          AudioUnitScope                  scope,
-                                                    AudioUnitElement                element)
-{
-    switch (scope) {
-    case kAudioUnitScope_Global:
-        return new AUElement(this);
-    case kAudioUnitScope_Input:
-        return new AUInputElement(this);
-    case kAudioUnitScope_Output:
-        return new AUOutputElement(this);
-#if !CA_BASIC_AU_FEATURES
-    case kAudioUnitScope_Group:
-        return new AUElement(this);
-    case kAudioUnitScope_Part:
-        return new AUElement(this);
-#endif
-    }
-    COMPONENT_THROW(kAudioUnitErr_InvalidScope);
-
-    return NULL;    // get rid of compiler warning
-}
-
-//_____________________________________________________________________________
-//
-bool    AUBase::FormatIsCanonical(      const CAStreamBasicDescription &f)
-{
-    return (f.mFormatID == kAudioFormatLinearPCM
-        &&  f.mFramesPerPacket == 1
-        &&  f.mBytesPerPacket == f.mBytesPerFrame
-//      &&  f.mChannelsPerFrame >= 0    -- this is always true since it's unsigned
-        // so far, it's a valid PCM format
-#if CA_PREFER_FIXED_POINT
-        &&  (f.mFormatFlags & kLinearPCMFormatFlagIsFloat) == 0
-        &&  (((f.mFormatFlags & kLinearPCMFormatFlagsSampleFractionMask) >> kLinearPCMFormatFlagsSampleFractionShift) == kAudioUnitSampleFractionBits)
-#else
-        &&  (f.mFormatFlags & kLinearPCMFormatFlagIsFloat) != 0
-#endif
-        &&  ((f.mChannelsPerFrame == 1) || ((f.mFormatFlags & kAudioFormatFlagIsNonInterleaved) == 0) == (mAudioUnitAPIVersion == 1))
-#if TARGET_RT_BIG_ENDIAN
-        &&  (f.mFormatFlags & kLinearPCMFormatFlagIsBigEndian) != 0
-#else
-        &&  (f.mFormatFlags & kLinearPCMFormatFlagIsBigEndian) == 0
-#endif
-        &&  f.mBitsPerChannel == 8 * sizeof(AudioUnitSampleType)
-        &&  f.mBytesPerFrame == f.NumberInterleavedChannels() * sizeof(AudioUnitSampleType)
-        );
-}
-
-//_____________________________________________________________________________
-//
-void    AUBase::MakeCanonicalFormat(    CAStreamBasicDescription &      f,
-                                        int                             nChannels)
-{
-    f.SetAUCanonical(nChannels, mAudioUnitAPIVersion < 2);  // interleaved for v1, non for v2
-    f.mSampleRate = 0.0;
-}
-
-const Float64 AUBase::kNoLastRenderedSampleTime = -1.;
-
-#include "AUBaseHelper.h"
-
-char*   AUBase::GetLoggingString () const
-{
-    if (mLogString) return mLogString;
-
-    AudioComponentDescription desc = GetComponentDescription();
-
-    const size_t logStringSize = 256;
-    const_cast<AUBase*>(this)->mLogString = new char[logStringSize];
-    char str[24];
-    char str1[24];
-    char str2[24];
-    snprintf (const_cast<AUBase*>(this)->mLogString, logStringSize, "AU (%p): %s %s %s",
-        GetComponentInstance(),
-        CAStringForOSType(desc.componentType, str, sizeof(str)),
-        CAStringForOSType(desc.componentSubType, str1, sizeof(str1)),
-        CAStringForOSType(desc.componentManufacturer, str2, sizeof(str2)));
-
-    return mLogString;
-}
-
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUBase.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUBase.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUBase.h
+++ /dev/null
@@ -1,1016 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#ifndef __AUBase_h__
-#define __AUBase_h__
-
-#include <TargetConditionals.h>
-
-#if TARGET_OS_MAC
-    #include <pthread.h>
-#elif TARGET_OS_WIN32
-    #include <windows.h>
-#else
-    #error Unsupported Operating System
-#endif
-
-#include <vector>
-
-#include "AUScopeElement.h"
-#include "AUInputElement.h"
-#include "AUOutputElement.h"
-#include "AUBuffer.h"
-#include "CAMath.h"
-#include "CAThreadSafeList.h"
-#include "CAVectorUnit.h"
-#include "CAMutex.h"
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <AudioUnit/AudioUnit.h>
-    #if !CA_BASIC_AU_FEATURES
-        #include <AudioUnit/MusicDevice.h>
-    #endif
-#else
-    #include "AudioUnit.h"
-    #if !CA_BASIC_AU_FEATURES
-        #include "MusicDevice.h"
-    #endif
-#endif
-
-#ifndef AUTRACE
-    #define AUTRACE(code, obj, a, b, c, d)
-#endif
-
-#include "AUPlugInDispatch.h"
-
-#ifndef CA_CANONICAL_DEPRECATED
-    #define CA_CANONICAL_DEPRECATED
-#endif
-
-// ________________________________________________________________________
-// These are to be moved to the public AudioUnit headers
-
-#define kAUDefaultSampleRate        44100.0
-#if !TARGET_OS_WIN32
-#define kAUDefaultMaxFramesPerSlice 1156
-//this allows enough default frames for a 512 dest 44K and SRC from 96K
-// add a padding of 4 frames for any altivec rounding
-#else
-#define kAUDefaultMaxFramesPerSlice 2048
-#endif
-
-// ________________________________________________________________________
-
-/*! @class AUBase */
-class AUBase : public ComponentBase {
-public:
-
-    /*! @ctor AUBase */
-                                AUBase(                 AudioComponentInstance          inInstance,
-                                                        UInt32                          numInputElements,
-                                                        UInt32                          numOutputElements,
-                                                        UInt32                          numGroupElements = 0);
-    /*! @dtor AUBase */
-    virtual                     ~AUBase();
-
-    /*! @method PostConstructor */
-    virtual void                PostConstructor() { CreateElements(); }
-
-    /*! @method PreDestructor */
-    virtual void                PreDestructor();
-
-    /*! @method CreateElements */
-    void                        CreateElements();
-                                    // Called immediately after construction, when virtual methods work.
-                                    // Or, a subclass may call this in order to have access to elements
-                                    // in its constructor.
-
-    /*! @method CreateExtendedElements */
-    virtual void CreateExtendedElements() {}
-
-#pragma mark -
-#pragma mark AU dispatch
-    // ________________________________________________________________________
-    // Virtual methods (mostly) directly corresponding to the entry points.  Many of these
-    // have useful implementations here and will not need overriding.
-
-    /*! @method DoInitialize */
-            OSStatus            DoInitialize();
-                // this implements the entry point and makes sure that initialization
-                // is only attempted exactly once...
-
-    /*! @method Initialize */
-    virtual OSStatus            Initialize();
-                // ... so that overrides to this method can assume that they will only
-                // be called exactly once.
-
-    /*! @method IsInitialized */
-            bool                IsInitialized() const { return mInitialized; }
-    /*! @method HasBegunInitializing */
-            bool                HasBegunInitializing() const { return mHasBegunInitializing; }
-
-    /*! @method DoCleanup */
-            void                DoCleanup();
-                // same pattern as with Initialize
-
-    /*! @method Cleanup */
-    virtual void                Cleanup();
-
-    /*! @method Reset */
-    virtual OSStatus            Reset(                  AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement);
-
-    // Note about GetPropertyInfo, GetProperty, SetProperty:
-    // Certain properties are trapped out in these dispatch functions and handled with different virtual
-    // methods.  (To discourage hacks and keep vtable size down, these are non-virtual)
-
-    /*! @method DispatchGetPropertyInfo */
-            OSStatus            DispatchGetPropertyInfo(AudioUnitPropertyID             inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement,
-                                                        UInt32 &                        outDataSize,
-                                                        Boolean &                       outWritable);
-
-    /*! @method DispatchGetProperty */
-            OSStatus            DispatchGetProperty(    AudioUnitPropertyID             inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement,
-                                                        void *                          outData);
-
-    /*! @method DispatchSetProperty */
-            OSStatus            DispatchSetProperty(    AudioUnitPropertyID             inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement,
-                                                        const void *                    inData,
-                                                        UInt32                          inDataSize);
-
-            OSStatus            DispatchRemovePropertyValue(    AudioUnitPropertyID     inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement);
-
-    /*! @method GetPropertyInfo */
-    virtual OSStatus            GetPropertyInfo(        AudioUnitPropertyID             inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement,
-                                                        UInt32 &                        outDataSize,
-                                                        Boolean &                       outWritable);
-
-    /*! @method GetProperty */
-    virtual OSStatus            GetProperty(            AudioUnitPropertyID             inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement,
-                                                        void *                          outData);
-
-    /*! @method SetProperty */
-    virtual OSStatus            SetProperty(            AudioUnitPropertyID             inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement,
-                                                        const void *                    inData,
-                                                        UInt32                          inDataSize);
-
-    /*! @method ClearPropertyUsage */
-    virtual OSStatus            RemovePropertyValue (   AudioUnitPropertyID             inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement);
-
-    /*! @method AddPropertyListener */
-    virtual OSStatus            AddPropertyListener(    AudioUnitPropertyID             inID,
-                                                        AudioUnitPropertyListenerProc   inProc,
-                                                        void *                          inProcRefCon);
-
-    /*! @method RemovePropertyListener */
-    virtual OSStatus            RemovePropertyListener( AudioUnitPropertyID             inID,
-                                                        AudioUnitPropertyListenerProc   inProc,
-                                                        void *                          inProcRefCon,
-                                                        bool                            refConSpecified);
-
-    /*! @method SetRenderNotification */
-    virtual OSStatus            SetRenderNotification(  AURenderCallback                inProc,
-                                                        void *                          inRefCon);
-
-    /*! @method RemoveRenderNotification */
-    virtual OSStatus            RemoveRenderNotification(
-                                                        AURenderCallback                inProc,
-                                                        void *                          inRefCon);
-
-    /*! @method GetParameter */
-    virtual OSStatus    GetParameter(           AudioUnitParameterID            inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement,
-                                                        AudioUnitParameterValue &       outValue);
-
-    /*! @method SetParameter */
-    virtual OSStatus    SetParameter(           AudioUnitParameterID            inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement,
-                                                        AudioUnitParameterValue         inValue,
-                                                        UInt32                          inBufferOffsetInFrames);
-
-    /*! @method CanScheduleParams */
-    virtual bool CanScheduleParameters() const = 0;
-
-    /*! @method ScheduleParameter */
-    virtual OSStatus    ScheduleParameter (     const AudioUnitParameterEvent   *inParameterEvent,
-                                                        UInt32                          inNumEvents);
-
-
-    /*! @method DoRender */
-    OSStatus    DoRender(                               AudioUnitRenderActionFlags &    ioActionFlags,
-                                                        const AudioTimeStamp &          inTimeStamp,
-                                                        UInt32                          inBusNumber,
-                                                        UInt32                          inNumberFrames,
-                                                        AudioBufferList &               ioData);
-
-
-    /*! @method Process */
-    OSStatus    DoProcess (                         AudioUnitRenderActionFlags  &       ioActionFlags,
-                                                    const AudioTimeStamp &              inTimeStamp,
-                                                    UInt32                              inFramesToProcess,
-                                                    AudioBufferList &                   ioData);
-
-    /*! @method ProcessMultiple */
-    OSStatus    DoProcessMultiple (                 AudioUnitRenderActionFlags  &       ioActionFlags,
-                                                    const AudioTimeStamp &              inTimeStamp,
-                                                    UInt32                              inFramesToProcess,
-                                                    UInt32                              inNumberInputBufferLists,
-                                                    const AudioBufferList **            inInputBufferLists,
-                                                    UInt32                              inNumberOutputBufferLists,
-                                                    AudioBufferList **                  ioOutputBufferLists);
-
-    /*! @method ProcessBufferLists */
-    virtual OSStatus    ProcessBufferLists(         AudioUnitRenderActionFlags &        ioActionFlags,
-                                                    const AudioBufferList &             inBuffer,
-                                                    AudioBufferList &                   outBuffer,
-                                                    UInt32                              inFramesToProcess )
-                        {
-                            return kAudio_UnimplementedError;
-                        }
-
-    /*! @method ProcessMultipleBufferLists */
-    virtual OSStatus    ProcessMultipleBufferLists( AudioUnitRenderActionFlags &        ioActionFlags,
-                                                    UInt32                              inFramesToProcess,
-                                                    UInt32                              inNumberInputBufferLists,
-                                                    const AudioBufferList **            inInputBufferLists,
-                                                    UInt32                              inNumberOutputBufferLists,
-                                                    AudioBufferList **                  ioOutputBufferLists)
-                        {
-                            return kAudio_UnimplementedError;
-                        }
-
-    /*! @method ComplexRender */
-    virtual OSStatus    ComplexRender(              AudioUnitRenderActionFlags &        ioActionFlags,
-                                                    const AudioTimeStamp &              inTimeStamp,
-                                                    UInt32                              inOutputBusNumber,
-                                                    UInt32                              inNumberOfPackets,
-                                                    UInt32 *                            outNumberOfPackets,
-                                                    AudioStreamPacketDescription *      outPacketDescriptions,
-                                                    AudioBufferList &                   ioData,
-                                                    void *                              outMetadata,
-                                                    UInt32 *                            outMetadataByteSize)
-                        {
-                            return kAudio_UnimplementedError;
-                        }
-
-    // Override this method if your AU processes multiple output busses completely independently --
-    // you'll want to just call Render without the NeedsToRender check.
-    // Otherwise, override Render().
-    //
-    // N.B. Implementations of this method can assume that the output's buffer list has already been
-    // prepared and access it with GetOutput(inBusNumber)->GetBufferList() instead of
-    // GetOutput(inBusNumber)->PrepareBuffer(nFrames) -- if PrepareBuffer is called, a
-    // copy may occur after rendering.
-    /*! @method RenderBus */
-    virtual OSStatus            RenderBus(              AudioUnitRenderActionFlags &    ioActionFlags,
-                                                        const AudioTimeStamp &          inTimeStamp,
-                                                        UInt32                          inBusNumber,
-                                                        UInt32                          inNumberFrames)
-                                {
-                                    if (NeedsToRender(inTimeStamp))
-                                        return Render(ioActionFlags, inTimeStamp, inNumberFrames);
-                                    return noErr;   // was presumably already rendered via another bus
-                                }
-
-    // N.B. For a unit with only one output bus, it can assume in its implementation of this
-    // method that the output's buffer list has already been prepared and access it with
-    // GetOutput(0)->GetBufferList() instead of GetOutput(0)->PrepareBuffer(nFrames)
-    //  -- if PrepareBuffer is called, a copy may occur after rendering.
-    /*! @method Render */
-    virtual OSStatus            Render(                 AudioUnitRenderActionFlags &    ioActionFlags,
-                                                        const AudioTimeStamp &          inTimeStamp,
-                                                        UInt32                          inNumberFrames)
-                                {
-                                    return noErr;
-                                }
-
-
-#pragma mark -
-#pragma mark Property Dispatch
-
-    static const Float64 kNoLastRenderedSampleTime;
-
-    // ________________________________________________________________________
-    // These are generated from DispatchGetProperty/DispatchGetPropertyInfo/DispatchSetProperty
-
-    /*! @method BusCountWritable */
-    virtual bool                BusCountWritable(       AudioUnitScope                  inScope)
-                                {
-                                    return false;
-                                }
-    virtual OSStatus            SetBusCount(        AudioUnitScope                  inScope,
-                                                    UInt32                          inCount);
-
-    /*! @method SetConnection */
-    virtual OSStatus            SetConnection(          const AudioUnitConnection &     inConnection);
-
-    /*! @method SetInputCallback */
-    virtual OSStatus            SetInputCallback(       UInt32                          inPropertyID,
-                                                        AudioUnitElement                inElement,
-                                                        AURenderCallback                inProc,
-                                                        void *                          inRefCon);
-
-    /*! @method GetParameterList */
-    virtual OSStatus            GetParameterList(       AudioUnitScope                  inScope,
-                                                        AudioUnitParameterID *          outParameterList,
-                                                        UInt32 &                        outNumParameters);
-                                                            // outParameterList may be a null pointer
-
-    /*! @method GetParameterInfo */
-    virtual OSStatus            GetParameterInfo(       AudioUnitScope                  inScope,
-                                                        AudioUnitParameterID            inParameterID,
-                                                        AudioUnitParameterInfo &        outParameterInfo);
-
-    virtual OSStatus            GetParameterHistoryInfo(AudioUnitScope                  inScope,
-                                                        AudioUnitParameterID            inParameterID,
-                                                        Float32 &                       outUpdatesPerSecond,
-                                                        Float32 &                       outHistoryDurationInSeconds);
-
-    /*! @method SaveState */
-    virtual OSStatus            SaveState(              CFPropertyListRef *             outData);
-
-    /*! @method SaveExtendedScopes */
-    virtual void                SaveExtendedScopes(     CFMutableDataRef                outData) {};
-
-    /*! @method RestoreState */
-    virtual OSStatus            RestoreState(           CFPropertyListRef               inData);
-
-    /*! @method GetParameterValueStrings */
-    virtual OSStatus            GetParameterValueStrings(AudioUnitScope                 inScope,
-                                                        AudioUnitParameterID            inParameterID,
-                                                        CFArrayRef *                    outStrings);
-
-    /*! @method CopyClumpName */
-    virtual OSStatus            CopyClumpName(          AudioUnitScope                  inScope,
-                                                        UInt32                          inClumpID,
-                                                        UInt32                          inDesiredNameLength,
-                                                        CFStringRef *                   outClumpName);
-
-    /*! @method GetPresets */
-    virtual OSStatus            GetPresets (            CFArrayRef *                    outData) const;
-
-        // set the default preset for the unit -> the number of the preset MUST be >= 0
-        // and the name should be valid, or the preset WON'T take
-    /*! @method SetAFactoryPresetAsCurrent */
-    bool                        SetAFactoryPresetAsCurrent (const AUPreset & inPreset);
-
-        // Called when someone sets a new, valid preset
-        // If this is a valid preset, then the subclass sets its state to that preset
-        // and returns noErr.
-        // If not a valid preset, return an error, and the pre-existing preset is restored
-    /*! @method NewFactoryPresetSet */
-    virtual OSStatus            NewFactoryPresetSet (const AUPreset & inNewFactoryPreset);
-
-    /*! @method NewCustomPresetSet */
-    virtual OSStatus            NewCustomPresetSet (const AUPreset & inNewCustomPreset);
-
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-    /*! @method GetNumCustomUIComponents */
-    virtual int                 GetNumCustomUIComponents ();
-
-    /*! @method GetUIComponentDescs */
-    virtual void                GetUIComponentDescs (ComponentDescription* inDescArray);
-#endif
-
-    /*! @method CopyIconLocation */
-    virtual CFURLRef            CopyIconLocation ();
-
-    // default is no latency, and unimplemented tail time
-    /*! @method GetLatency */
-    virtual Float64             GetLatency() {return 0.0;}
-    /*! @method GetTailTime */
-    virtual Float64             GetTailTime() {return 0;}
-    /*! @method SupportsRampAndTail */
-    virtual bool                SupportsTail () { return false; }
-
-    /*! @method IsStreamFormatWritable */
-            bool                IsStreamFormatWritable( AudioUnitScope                  scope,
-                                                        AudioUnitElement                element);
-
-    /*! @method StreamFormatWritable */
-    virtual bool                StreamFormatWritable(   AudioUnitScope                  scope,
-                                                        AudioUnitElement                element) = 0;
-                                                            // scope will always be input or output
-
-            // pass in a pointer to get the struct, and num channel infos
-            // you can pass in NULL to just get the number
-            // a return value of 0 (the default in AUBase) means the property is not supported...
-    /*! @method SupportedNumChannels */
-    virtual UInt32              SupportedNumChannels (  const AUChannelInfo**           outInfo);
-
-    /*! @method ValidFormat */
-    virtual bool                ValidFormat(            AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement,
-                                                        const CAStreamBasicDescription & inNewFormat);
-                                                            // Will only be called after StreamFormatWritable
-                                                            // has succeeded.
-                                                            // Default implementation requires canonical format:
-                                                            // native-endian 32-bit float, any sample rate,
-                                                            // any number of channels; override when other
-                                                            // formats are supported.  A subclass's override can
-                                                            // choose to always return true and trap invalid
-                                                            // formats in ChangeStreamFormat.
-
-
-    /*! @method FormatIsCanonical */
-            CA_CANONICAL_DEPRECATED
-            bool                FormatIsCanonical(      const CAStreamBasicDescription &format);
-
-    /*! @method MakeCanonicalFormat */
-            CA_CANONICAL_DEPRECATED
-            void                MakeCanonicalFormat(    CAStreamBasicDescription &  outDesc,
-                                                        int                         numChannels = 2);
-
-    /*! @method GetStreamFormat */
-    virtual const CAStreamBasicDescription &
-                                GetStreamFormat(        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement);
-
-    /*! @method ChangeStreamFormat */
-    virtual OSStatus            ChangeStreamFormat(     AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement,
-                                                        const CAStreamBasicDescription & inPrevFormat,
-                                                        const CAStreamBasicDescription & inNewFormat);
-                                                            // Will only be called after StreamFormatWritable
-                                                            // and ValidFormat have succeeded.
-
-    // ________________________________________________________________________
-
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-    /*! @method ComponentEntryDispatch */
-    static OSStatus         ComponentEntryDispatch( ComponentParameters *           params,
-                                                        AUBase *                        This);
-#endif
-
-    // ________________________________________________________________________
-    // Methods useful for subclasses
-
-    /*! @method GetScope */
-    AUScope &                   GetScope(               AudioUnitScope                  inScope)
-    {
-        if (inScope >= kNumScopes) {
-            AUScope * scope = GetScopeExtended(inScope);
-            if (!scope) COMPONENT_THROW(kAudioUnitErr_InvalidScope);
-            return *scope;
-        }
-        return mScopes[inScope];
-    }
-
-    /*! @method GetScopeExtended */
-    virtual AUScope *           GetScopeExtended (AudioUnitScope inScope) { return NULL; }
-
-    /*! @method GlobalScope */
-    AUScope &                   GlobalScope() { return mScopes[kAudioUnitScope_Global]; }
-    /*! @method Inputs */
-    AUScope &                   Inputs()    { return mScopes[kAudioUnitScope_Input]; }
-    /*! @method Outputs */
-    AUScope &                   Outputs()   { return mScopes[kAudioUnitScope_Output]; }
-#if !CA_BASIC_AU_FEATURES
-    /*! @method Groups */
-    AUScope &                   Groups()    { return mScopes[kAudioUnitScope_Group]; }
-#endif
-    /*! @method Globals */
-    AUElement *                 Globals()   { return mScopes[kAudioUnitScope_Global].GetElement(0); }
-
-    /*! @method SetNumberOfElements */
-    void                        SetNumberOfElements(    AudioUnitScope                  inScope,
-                                                        UInt32                          numElements);
-
-    /*! @method GetElement */
-    AUElement *                 GetElement(             AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement)
-    {
-        return GetScope(inScope).GetElement(inElement);
-    }
-
-    /*! @method GetIOElement */
-    AUIOElement *               GetIOElement(           AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement)
-    {
-        return GetScope(inScope).GetIOElement(inElement);
-    }
-
-    /*! @method SafeGetElement */
-    AUElement *                 SafeGetElement(         AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement)
-    {
-        return GetScope(inScope).SafeGetElement(inElement);
-    }
-
-    /*! @method GetInput */
-    AUInputElement *            GetInput(               AudioUnitElement                inElement)
-    {
-        return static_cast<AUInputElement *>(Inputs().SafeGetElement(inElement));
-    }
-
-    /*! @method GetOutput */
-    AUOutputElement *           GetOutput(              AudioUnitElement                inElement)
-    {
-        return static_cast<AUOutputElement *>(Outputs().SafeGetElement(inElement));
-    }
-
-#if !CA_BASIC_AU_FEATURES
-    /*! @method GetGroup */
-    AUElement *                 GetGroup(               AudioUnitElement                inElement)
-    {
-        return Groups().SafeGetElement(inElement);
-    }
-#endif
-
-    /*! @method PullInput */
-    OSStatus                    PullInput(              UInt32                      inBusNumber,
-                                                        AudioUnitRenderActionFlags &ioActionFlags,
-                                                        const AudioTimeStamp &      inTimeStamp,
-                                                        UInt32                      inNumberFrames)
-    {
-        AUInputElement *input = GetInput(inBusNumber);  // throws if error
-        return input->PullInput(ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames);
-    }
-
-    /*! @method GetMaxFramesPerSlice */
-    UInt32                      GetMaxFramesPerSlice() const { return mMaxFramesPerSlice; }
-    /*! @method UsesFixedBlockSize */
-    bool                        UsesFixedBlockSize() const { return mUsesFixedBlockSize; }
-    /*! @method SetUsesFixedBlockSize */
-    void                        SetUsesFixedBlockSize(bool inUsesFixedBlockSize) { mUsesFixedBlockSize = inUsesFixedBlockSize; }
-
-    /*! @method GetVectorUnitType */
-    static SInt32               GetVectorUnitType() { return sVectorUnitType; }
-    /*! @method HasVectorUnit */
-    static bool                 HasVectorUnit() { return sVectorUnitType > 0; }
-    /*! @method HasAltivec */
-    static bool                 HasAltivec() { return sVectorUnitType == kVecAltivec; }
-    /*! @method HasSSE2 */
-    static bool                 HasSSE2() { return sVectorUnitType >= kVecSSE2; }
-    /*! @method HasSSE3 */
-    static bool                 HasSSE3() { return sVectorUnitType >= kVecSSE3; }
-
-    /*! @method AudioUnitAPIVersion */
-    UInt8                       AudioUnitAPIVersion() const { return mAudioUnitAPIVersion; }
-
-    /*! @method IsRenderThread */
-    bool                        InRenderThread () const
-                                {
-#if TARGET_OS_MAC
-                                    return (mRenderThreadID ? pthread_equal (mRenderThreadID, pthread_self()) : false);
-#elif TARGET_OS_WIN32
-                                    return (mRenderThreadID ? mRenderThreadID == GetCurrentThreadId() : false);
-#endif
-                                }
-
-    /*! @method HasInput */
-    bool                        HasInput(               AudioUnitElement                inElement) {
-                                    AUInputElement *in = static_cast<AUInputElement *>(Inputs().GetElement(inElement));
-                                    return in != NULL && in->IsActive();
-                                }
-                                    // says whether an input is connected or has a callback
-
-    /*! @method PropertyChanged */
-    virtual void                PropertyChanged(        AudioUnitPropertyID             inID,
-                                                        AudioUnitScope                  inScope,
-                                                        AudioUnitElement                inElement);
-
-#if !CA_NO_AU_UI_FEATURES
-    // These calls can be used to call a Host's Callbacks. The method returns -1 if the host
-    // hasn't supplied the callback. Any other result is returned by the host.
-    // As in the API contract, for a parameter's value, you specify a pointer
-    // to that data type. Specify NULL for a parameter that you are not interested
-    // as this can save work in the host.
-
-    /*! @method CallHostBeatAndTempo */
-    OSStatus    CallHostBeatAndTempo (Float64               *outCurrentBeat,
-                                        Float64             *outCurrentTempo)
-    {
-        return (mHostCallbackInfo.beatAndTempoProc
-                        ? (*mHostCallbackInfo.beatAndTempoProc) (mHostCallbackInfo.hostUserData,
-                                                                    outCurrentBeat,
-                                                                    outCurrentTempo)
-                        : -1);
-    }
-
-    /*! @method CallHostMusicalTimeLocation */
-    OSStatus    CallHostMusicalTimeLocation (UInt32         *outDeltaSampleOffsetToNextBeat,
-                                        Float32             *outTimeSig_Numerator,
-                                        UInt32              *outTimeSig_Denominator,
-                                        Float64             *outCurrentMeasureDownBeat)
-    {
-        return (mHostCallbackInfo.musicalTimeLocationProc
-                        ? (*mHostCallbackInfo.musicalTimeLocationProc) (mHostCallbackInfo.hostUserData,
-                                                                            outDeltaSampleOffsetToNextBeat,
-                                                                            outTimeSig_Numerator,
-                                                                            outTimeSig_Denominator,
-                                                                            outCurrentMeasureDownBeat)
-                        : -1);
-    }
-
-    /*! @method CallHostTransportState */
-    OSStatus    CallHostTransportState (Boolean             *outIsPlaying,
-                                        Boolean             *outTransportStateChanged,
-                                        Float64             *outCurrentSampleInTimeLine,
-                                        Boolean             *outIsCycling,
-                                        Float64             *outCycleStartBeat,
-                                        Float64             *outCycleEndBeat)
-    {
-        return (mHostCallbackInfo.transportStateProc
-                        ? (*mHostCallbackInfo.transportStateProc) (mHostCallbackInfo.hostUserData,
-                                                                        outIsPlaying,
-                                                                        outTransportStateChanged,
-                                                                        outCurrentSampleInTimeLine,
-                                                                        outIsCycling,
-                                                                        outCycleStartBeat,
-                                                                        outCycleEndBeat)
-                        : -1);
-    }
-#endif
-
-    char*                       GetLoggingString () const;
-
-    CAMutex*                    GetMutex() { return mAUMutex; }
-
-    // ________________________________________________________________________
-    /*! @method CreateElement */
-    virtual AUElement *         CreateElement(          AudioUnitScope                  scope,
-                                                        AudioUnitElement                element);
-
-#pragma mark -
-#pragma mark AU Output Base Dispatch
-    // ________________________________________________________________________
-    // ________________________________________________________________________
-    // ________________________________________________________________________
-    // output unit methods
-    /*! @method Start */
-    virtual OSStatus    Start() { return kAudio_UnimplementedError; }
-    /*! @method Stop */
-    virtual OSStatus    Stop() { return kAudio_UnimplementedError; }
-
-#if !CA_BASIC_AU_FEATURES
-#pragma mark -
-#pragma mark AU Music Base Dispatch
-
-#if !TARGET_OS_IPHONE
-// these methods are deprecated, so we don't include them except for compatability
-    /*! @method PrepareInstrument */
-    virtual OSStatus            PrepareInstrument(MusicDeviceInstrumentID inInstrument) { return kAudio_UnimplementedError; }
-
-    /*! @method PrepareInstrument */
-    virtual OSStatus            ReleaseInstrument(MusicDeviceInstrumentID inInstrument) { return kAudio_UnimplementedError; }
-#endif
-
-    // ________________________________________________________________________
-    // ________________________________________________________________________
-    // ________________________________________________________________________
-    // music device/music effect methods -- incomplete
-    /*! @method MIDIEvent */
-    virtual OSStatus    MIDIEvent(      UInt32                      inStatus,
-                                        UInt32                      inData1,
-                                        UInt32                      inData2,
-                                        UInt32                      inOffsetSampleFrame) { return kAudio_UnimplementedError; }
-
-    /*! @method SysEx */
-    virtual OSStatus    SysEx(          const UInt8 *               inData,
-                                        UInt32                      inLength) { return kAudio_UnimplementedError;}
-
-    /*! @method StartNote */
-    virtual OSStatus    StartNote(      MusicDeviceInstrumentID     inInstrument,
-                                        MusicDeviceGroupID          inGroupID,
-                                        NoteInstanceID *            outNoteInstanceID,
-                                        UInt32                      inOffsetSampleFrame,
-                                        const MusicDeviceNoteParams &inParams) { return kAudio_UnimplementedError; }
-
-    /*! @method StopNote */
-    virtual OSStatus    StopNote(       MusicDeviceGroupID          inGroupID,
-                                        NoteInstanceID              inNoteInstanceID,
-                                        UInt32                      inOffsetSampleFrame) { return kAudio_UnimplementedError; }
-#endif
-
-    // ________________________________________________________________________
-    // ________________________________________________________________________
-    // ________________________________________________________________________
-
-protected:
-#pragma mark -
-#pragma mark Implementation methods
-
-    /*! @method ReallocateBuffers */
-    virtual void                ReallocateBuffers();
-                                    // needs to be called when mMaxFramesPerSlice changes
-    virtual void                DeallocateIOBuffers();
-
-    /*! @method FillInParameterName */
-    static void                 FillInParameterName (AudioUnitParameterInfo& ioInfo, CFStringRef inName, bool inShouldRelease)
-    {
-        ioInfo.cfNameString = inName;
-        ioInfo.flags |= kAudioUnitParameterFlag_HasCFNameString;
-        if (inShouldRelease)
-            ioInfo.flags |= kAudioUnitParameterFlag_CFNameRelease;
-        CFStringGetCString (inName, ioInfo.name, offsetof (AudioUnitParameterInfo, clumpID), kCFStringEncodingUTF8);
-    }
-
-    static void                 HasClump (AudioUnitParameterInfo& ioInfo, UInt32 inClumpID)
-    {
-        ioInfo.clumpID = inClumpID;
-        ioInfo.flags |= kAudioUnitParameterFlag_HasClump;
-    }
-
-    /*! @method SetMaxFramesPerSlice */
-    virtual void                SetMaxFramesPerSlice(UInt32 nFrames);
-
-    /*! @method CanSetMaxFrames */
-    virtual OSStatus            CanSetMaxFrames() const;
-
-    /*! @method WantsRenderThreadID */
-    bool                        WantsRenderThreadID () const { return mWantsRenderThreadID; }
-
-    /*! @method SetWantsRenderThreadID */
-    void                        SetWantsRenderThreadID (bool inFlag);
-
-    /*! @method SetRenderError */
-    OSStatus                    SetRenderError (OSStatus inErr)
-    {
-        if (inErr && mLastRenderError == 0) {
-            mLastRenderError = inErr;
-            PropertyChanged(kAudioUnitProperty_LastRenderError, kAudioUnitScope_Global, 0);
-        }
-        return inErr;
-    }
-
-private:
-    /*! @method DoRenderBus */
-    // shared between Render and RenderSlice, inlined to minimize function call overhead
-    OSStatus                    DoRenderBus(            AudioUnitRenderActionFlags &    ioActionFlags,
-                                                        const AudioTimeStamp &          inTimeStamp,
-                                                        UInt32                          inBusNumber,
-                                                        AUOutputElement *               theOutput,
-                                                        UInt32                          inNumberFrames,
-                                                        AudioBufferList &               ioData)
-    {
-        if (ioData.mBuffers[0].mData == NULL || (theOutput->WillAllocateBuffer() && Outputs().GetNumberOfElements() > 1))
-            // will render into cache buffer
-            theOutput->PrepareBuffer(inNumberFrames);
-        else
-            // will render into caller's buffer
-            theOutput->SetBufferList(ioData);
-        OSStatus result = RenderBus(ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames);
-        if (result == noErr) {
-            if (ioData.mBuffers[0].mData == NULL) {
-                theOutput->CopyBufferListTo(ioData);
-                AUTRACE(kCATrace_AUBaseDoRenderBus, mComponentInstance, inNumberFrames, (intptr_t)theOutput->GetBufferList().mBuffers[0].mData, 0, *(UInt32 *)ioData.mBuffers[0].mData);
-            } else {
-                theOutput->CopyBufferContentsTo(ioData);
-                AUTRACE(kCATrace_AUBaseDoRenderBus, mComponentInstance, inNumberFrames, (intptr_t)theOutput->GetBufferList().mBuffers[0].mData, (intptr_t)ioData.mBuffers[0].mData, *(UInt32 *)ioData.mBuffers[0].mData);
-                theOutput->InvalidateBufferList();
-            }
-        }
-        return result;
-    }
-
-    /*! @method HasIcon */
-    bool                        HasIcon ();
-
-    /*! @method ResetRenderTime */
-    void                        ResetRenderTime ()
-                                {
-                                    memset (&mCurrentRenderTime, 0, sizeof(mCurrentRenderTime));
-                                    mCurrentRenderTime.mSampleTime = kNoLastRenderedSampleTime;
-                                }
-
-protected:
-    /*! @method GetAudioChannelLayout */
-    virtual UInt32              GetChannelLayoutTags(   AudioUnitScope              scope,
-                                                        AudioUnitElement            element,
-                                                        AudioChannelLayoutTag *     outLayoutTags);
-
-    /*! @method GetAudioChannelLayout */
-    virtual UInt32              GetAudioChannelLayout(  AudioUnitScope              scope,
-                                                        AudioUnitElement            element,
-                                                        AudioChannelLayout *        outLayoutPtr,
-                                                        Boolean &                   outWritable);
-
-    /*! @method SetAudioChannelLayout */
-    virtual OSStatus            SetAudioChannelLayout(  AudioUnitScope              scope,
-                                                        AudioUnitElement            element,
-                                                        const AudioChannelLayout *  inLayout);
-
-    /*! @method RemoveAudioChannelLayout */
-    virtual OSStatus            RemoveAudioChannelLayout(AudioUnitScope scope, AudioUnitElement element);
-
-    /*! @method NeedsToRender */
-    bool                        NeedsToRender(          const AudioTimeStamp &      inTimeStamp)
-                                {
-                                    bool needsToRender = fnotequal(inTimeStamp.mSampleTime, mCurrentRenderTime.mSampleTime);
-                                    if (needsToRender)  // only copy this if we need to render
-                                        mCurrentRenderTime = inTimeStamp;
-                                    return needsToRender;
-                                }
-
-    // Scheduled parameter implementation:
-
-    typedef std::vector<AudioUnitParameterEvent> ParameterEventList;
-
-    // Usually, you won't override this method.  You only need to call this if your DSP code
-    // is prepared to handle scheduled immediate and ramped parameter changes.
-    // Before calling this method, it is assumed you have already called PullInput() on the input busses
-    // for which the DSP code depends.  ProcessForScheduledParams() will call (potentially repeatedly)
-    // virtual method ProcessScheduledSlice() to perform the actual DSP for a given sub-division of
-    // the buffer.  The job of ProcessForScheduledParams() is to sub-divide the buffer into smaller
-    // pieces according to the scheduled times found in the ParameterEventList (usually coming
-    // directly from a previous call to ScheduleParameter() ), setting the appropriate immediate or
-    // ramped parameter values for the corresponding scopes and elements, then calling ProcessScheduledSlice()
-    // to do the actual DSP for each of these divisions.
-    virtual OSStatus    ProcessForScheduledParams(  ParameterEventList      &inParamList,
-                                                            UInt32                  inFramesToProcess,
-                                                            void                    *inUserData );
-
-    //  This method is called (potentially repeatedly) by ProcessForScheduledParams()
-    //  in order to perform the actual DSP required for this portion of the entire buffer
-    //  being processed.  The entire buffer can be divided up into smaller "slices"
-    //  according to the timestamps on the scheduled parameters...
-    //
-    //  sub-classes wishing to handle scheduled parameter changes should override this method
-    //  in order to do the appropriate DSP.  AUEffectBase already overrides this for standard
-    //  effect AudioUnits.
-    virtual OSStatus            ProcessScheduledSlice(  void                *inUserData,
-                                                        UInt32              inStartFrameInBuffer,
-                                                        UInt32              inSliceFramesToProcess,
-                                                        UInt32              inTotalBufferFrames ) {return noErr;};  // default impl does nothing...
-
-
-    /*! @method CurrentRenderTime */
-    const AudioTimeStamp &      CurrentRenderTime () const { return mCurrentRenderTime; }
-
-    // ________________________________________________________________________
-    //  Private data members to discourage hacking in subclasses
-private:
-    struct RenderCallback {
-        RenderCallback(AURenderCallback proc, void *ref) :
-            mRenderNotify(proc),
-            mRenderNotifyRefCon(ref)
-        { }
-
-        AURenderCallback            mRenderNotify;
-        void *                      mRenderNotifyRefCon;
-
-        bool operator == (const RenderCallback &other) {
-            return this->mRenderNotify == other.mRenderNotify &&
-                    this->mRenderNotifyRefCon == other.mRenderNotifyRefCon;
-        }
-    };
-    typedef TThreadSafeList<RenderCallback> RenderCallbackList;
-
-protected:
-#if !CA_BASIC_AU_FEATURES
-    enum { kNumScopes = 4 };
-#else
-    enum { kNumScopes = 3 };
-#endif
-
-private:
-    /*! @var mElementsCreated */
-    bool                        mElementsCreated;
-protected:
-    /*! @var mInitialized */
-    bool                        mInitialized;
-    /*! @var mHasBegunInitializing */
-    bool                        mHasBegunInitializing;
-private:
-    /*! @var mAudioUnitAPIVersion */
-    UInt8                       mAudioUnitAPIVersion;
-
-    /*! @var mInitNumInputEls */
-    const UInt32                mInitNumInputEls;
-    /*! @var mInitNumOutputEls */
-    const UInt32                mInitNumOutputEls;
-#if !CA_BASIC_AU_FEATURES
-    /*! @var mInitNumGroupEls */
-    const UInt32                mInitNumGroupEls;
-#endif
-    /*! @var mScopes */
-    AUScope                     mScopes[kNumScopes];
-
-    /*! @var mRenderCallbacks */
-    RenderCallbackList          mRenderCallbacks;
-    bool                        mRenderCallbacksTouched;
-
-    /*! @var mRenderThreadID */
-#if TARGET_OS_MAC
-    pthread_t                   mRenderThreadID;
-#elif TARGET_OS_WIN32
-    UInt32                      mRenderThreadID;
-#endif
-
-    /*! @var mWantsRenderThreadID */
-    bool                        mWantsRenderThreadID;
-
-    /*! @var mCurrentRenderTime */
-    AudioTimeStamp              mCurrentRenderTime;
-
-    /*! @var mMaxFramesPerSlice */
-    UInt32                      mMaxFramesPerSlice;
-
-    /*! @var mLastRenderError */
-    OSStatus                    mLastRenderError;
-    /*! @var mCurrentPreset */
-    AUPreset                    mCurrentPreset;
-
-protected:
-    /*! @var mUsesFixedBlockSize */
-    bool                        mUsesFixedBlockSize;
-
-    struct PropertyListener {
-        AudioUnitPropertyID             propertyID;
-        AudioUnitPropertyListenerProc   listenerProc;
-        void *                          listenerRefCon;
-    };
-    typedef std::vector<PropertyListener>   PropertyListeners;
-
-    /*! @var mParamList */
-    ParameterEventList          mParamList;
-    /*! @var mPropertyListeners */
-    PropertyListeners           mPropertyListeners;
-
-    /*! @var mBuffersAllocated */
-    bool                        mBuffersAllocated;
-
-    /*! @var mLogString */
-    // if this is NOT null, it will contain identifying info about this AU.
-    char*                       mLogString;
-
-    /*! @var mNickName */
-    CFStringRef                 mNickName;
-
-    /*! @var mAUMutex */
-    CAMutex *                   mAUMutex;
-
-private:
-    /*! @var sVectorUnitType */
-    static SInt32   sVectorUnitType;
-
-#if !CA_NO_AU_HOST_CALLBACKS
-protected:
-    /*! @var mHostCallbackInfo */
-    HostCallbackInfo            mHostCallbackInfo;
-
-#endif
-#if !CA_NO_AU_UI_FEATURES
-protected:
-    /*! @var mContextInfo */
-    CFStringRef                 mContextName;
-#endif
-};
-
-inline  OSStatus    AUInputElement::PullInputWithBufferList(
-                                                AudioUnitRenderActionFlags &    ioActionFlags,
-                                                const AudioTimeStamp &          inTimeStamp,
-                                                AudioUnitElement                inElement,
-                                                UInt32                          nFrames,
-                                                AudioBufferList *               inBufferList)
-{
-    OSStatus theResult;
-
-    if (HasConnection()) {
-            // only support connections for V2 audio units
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-        if (mConnRenderProc != NULL)
-            theResult = reinterpret_cast<AudioUnitRenderProc>(mConnRenderProc)(
-                            mConnInstanceStorage, &ioActionFlags, &inTimeStamp, mConnection.sourceOutputNumber, nFrames, inBufferList);
-        else
-#endif
-            theResult = AudioUnitRender(
-                            mConnection.sourceAudioUnit, &ioActionFlags, &inTimeStamp, mConnection.sourceOutputNumber, nFrames, inBufferList);
-    } else {
-        // kFromCallback:
-            theResult = (mInputProc)(
-                            mInputProcRefCon, &ioActionFlags, &inTimeStamp, inElement, nFrames, inBufferList);
-    }
-
-    if (mInputType == kNoInput) // defense: the guy upstream could have disconnected
-                                // it's a horrible thing to do, but may happen!
-        return kAudioUnitErr_NoConnection;
-
-
-    return theResult;
-}
-
-#endif // __AUBase_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUInputElement.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUInputElement.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUInputElement.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#include "AUBase.h"
-
-inline bool HasGoodBufferPointers(const AudioBufferList &abl, UInt32 nBytes)
-{
-    const AudioBuffer *buf = abl.mBuffers;
-    for (UInt32 i = abl.mNumberBuffers; i--;++buf) {
-        if (buf->mData == NULL || buf->mDataByteSize < nBytes)
-            return false;
-    }
-    return true;
-}
-
-
-//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//  AUInputElement::AUInputElement
-//
-//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-AUInputElement::AUInputElement(AUBase *audioUnit) :
-    AUIOElement(audioUnit),
-    mInputType(kNoInput)
-{
-}
-
-//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//  AUInputElement::SetConnection
-//
-//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-void    AUInputElement::SetConnection(const AudioUnitConnection &conn)
-{
-    if (conn.sourceAudioUnit == 0) {
-        Disconnect();
-        return;
-    }
-
-    mInputType = kFromConnection;
-    mConnection = conn;
-    AllocateBuffer();
-
-    mConnInstanceStorage = NULL;
-
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-    mConnRenderProc = NULL;
-    UInt32 size = sizeof(AudioUnitRenderProc);
-    OSStatus result = AudioUnitGetProperty( conn.sourceAudioUnit,
-                            kAudioUnitProperty_FastDispatch,
-                            kAudioUnitScope_Global,
-                            kAudioUnitRenderSelect,
-                            &mConnRenderProc,
-                            &size);
-    if (result == noErr)
-        mConnInstanceStorage = CMgr_GetComponentInstanceStorage (conn.sourceAudioUnit);
-    else
-        mConnRenderProc = NULL;
-#endif
-}
-
-void    AUInputElement::Disconnect()
-{
-    mInputType = kNoInput;
-    mIOBuffer.Deallocate();
-}
-
-
-
-//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//  AUInputElement::SetInputCallback
-//
-//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-void    AUInputElement::SetInputCallback(AURenderCallback proc, void *refCon)
-{
-    if (proc == NULL)
-        Disconnect();
-    else {
-        mInputType = kFromCallback;
-        mInputProc = proc;
-        mInputProcRefCon = refCon;
-        AllocateBuffer();
-    }
-}
-
-OSStatus    AUInputElement::SetStreamFormat(const CAStreamBasicDescription &fmt)
-{
-    OSStatus err = AUIOElement::SetStreamFormat(fmt);
-    if (err == AUBase::noErr)
-        AllocateBuffer();
-    return err;
-}
-
-OSStatus        AUInputElement::PullInput(  AudioUnitRenderActionFlags &    ioActionFlags,
-                                            const AudioTimeStamp &          inTimeStamp,
-                                            AudioUnitElement                inElement,
-                                            UInt32                          nFrames)
-{
-    if (!IsActive())
-        return kAudioUnitErr_NoConnection;
-
-    AudioBufferList *pullBuffer;
-
-    if (HasConnection() || !WillAllocateBuffer())
-        pullBuffer = &mIOBuffer.PrepareNullBuffer(mStreamFormat, nFrames);
-    else
-        pullBuffer = &mIOBuffer.PrepareBuffer(mStreamFormat, nFrames);
-
-    return PullInputWithBufferList (ioActionFlags, inTimeStamp, inElement, nFrames, pullBuffer);
-}
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUInputElement.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUInputElement.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUInputElement.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#ifndef __AUInput_h__
-#define __AUInput_h__
-
-#include "AUScopeElement.h"
-#include "AUBuffer.h"
-
-/*! @class AUInputElement */
-class AUInputElement : public AUIOElement {
-public:
-
-    /*! @ctor AUInputElement */
-                        AUInputElement(AUBase *audioUnit);
-    /*! @dtor ~AUInputElement */
-    virtual             ~AUInputElement() { }
-
-    // AUElement override
-    /*! @method SetStreamFormat */
-    virtual OSStatus    SetStreamFormat(const CAStreamBasicDescription &desc);
-    /*! @method NeedsBufferSpace */
-    virtual bool        NeedsBufferSpace() const { return IsCallback(); }
-
-    /*! @method SetConnection */
-    void                SetConnection(const AudioUnitConnection &conn);
-    /*! @method SetInputCallback */
-    void                SetInputCallback(AURenderCallback proc, void *refCon);
-
-    /*! @method IsActive */
-    bool                IsActive() const { return mInputType != kNoInput; }
-    /*! @method IsCallback */
-    bool                IsCallback() const { return mInputType == kFromCallback; }
-    /*! @method HasConnection */
-    bool                HasConnection() const { return mInputType == kFromConnection; }
-
-    /*! @method PullInput */
-    OSStatus            PullInput(  AudioUnitRenderActionFlags &    ioActionFlags,
-                                    const AudioTimeStamp &          inTimeStamp,
-                                    AudioUnitElement                inElement,
-                                    UInt32                          inNumberFrames);
-
-    /*! @method PullInputWithBufferList */
-    OSStatus            PullInputWithBufferList(    AudioUnitRenderActionFlags &    ioActionFlags,
-                                                    const AudioTimeStamp &          inTimeStamp,
-                                                    AudioUnitElement                inElement,
-                                                    UInt32                          nFrames,
-                                                    AudioBufferList *               inBufferList);
-protected:
-    /*! @method Disconnect */
-    void                Disconnect();
-
-    enum EInputType { kNoInput, kFromConnection, kFromCallback };
-
-    /*! @var mInputType */
-    EInputType                  mInputType;
-
-    // if from callback:
-    /*! @var mInputProc */
-    AURenderCallback            mInputProc;
-    /*! @var mInputProcRefCon */
-    void *                      mInputProcRefCon;
-
-    // if from connection:
-    /*! @var mConnection */
-    AudioUnitConnection         mConnection;
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-    /*! @var mConnRenderProc */
-    AudioUnitRenderProc         mConnRenderProc;
-#endif
-    /*! @var mConnInstanceStorage */
-    void *                      mConnInstanceStorage;       // for the input component
-};
-
-
-#endif // __AUInput_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUOutputElement.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUOutputElement.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUOutputElement.cpp
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#include "AUOutputElement.h"
-#include "AUBase.h"
-
-AUOutputElement::AUOutputElement(AUBase *audioUnit) :
-    AUIOElement(audioUnit)
-{
-    AllocateBuffer();
-}
-
-OSStatus    AUOutputElement::SetStreamFormat(const CAStreamBasicDescription &desc)
-{
-    OSStatus result = AUIOElement::SetStreamFormat(desc);   // inherited
-    if (result == AUBase::noErr)
-        AllocateBuffer();
-    return result;
-}
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUOutputElement.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUOutputElement.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUOutputElement.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#ifndef __AUOutput_h__
-#define __AUOutput_h__
-
-#include "AUScopeElement.h"
-#include "AUBuffer.h"
-
-    /*! @class AUOutputElement */
-class AUOutputElement : public AUIOElement {
-public:
-    /*! @ctor AUOutputElement */
-                        AUOutputElement(AUBase *audioUnit);
-
-    // AUElement override
-    /*! @method SetStreamFormat */
-    virtual OSStatus    SetStreamFormat(const CAStreamBasicDescription &desc);
-    /*! @method NeedsBufferSpace */
-    virtual bool        NeedsBufferSpace() const { return true; }
-};
-
-#endif // __AUOutput_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUPlugInDispatch.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUPlugInDispatch.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUPlugInDispatch.cpp
+++ /dev/null
@@ -1,631 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#include "AUPlugInDispatch.h"
-#include "CAXException.h"
-#include "ComponentBase.h"
-#include "AUBase.h"
-
-#define ACPI ((AudioComponentPlugInInstance *)self)
-#define AUI ((AUBase *)&ACPI->mInstanceStorage)
-
-#define AUI_LOCK CAMutex::Locker auLock(AUI->GetMutex());
-
-// ------------------------------------------------------------------------------------------------
-static OSStatus AUMethodInitialize(void *self)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        result = AUI->DoInitialize();
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodUninitialize(void *self)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        AUI->DoCleanup();
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodGetPropertyInfo(void *self, AudioUnitPropertyID prop, AudioUnitScope scope, AudioUnitElement elem, UInt32 *outDataSize, Boolean *outWritable)
-{
-    OSStatus result = noErr;
-    try {
-        UInt32 dataSize = 0;        // 13517289 GetPropetyInfo was returning an uninitialized value when there is an error. This is a problem for auval.
-        Boolean writable = false;
-
-        AUI_LOCK
-        result = AUI->DispatchGetPropertyInfo(prop, scope, elem, dataSize, writable);
-        if (outDataSize != NULL)
-            *outDataSize = dataSize;
-        if (outWritable != NULL)
-            *outWritable = writable;
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodGetProperty(void *self, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, void *outData, UInt32 *ioDataSize)
-{
-    OSStatus result = noErr;
-    try {
-        UInt32 actualPropertySize, clientBufferSize;
-        Boolean writable;
-        char *tempBuffer;
-        void *destBuffer;
-
-        AUI_LOCK
-        if (ioDataSize == NULL) {
-            ca_debug_string("AudioUnitGetProperty: null size pointer");
-            result = kAudio_ParamError;
-            goto finishGetProperty;
-        }
-        if (outData == NULL) {
-            UInt32 dataSize;
-
-            result = AUI->DispatchGetPropertyInfo(inID, inScope, inElement, dataSize, writable);
-            *ioDataSize = dataSize;
-            goto finishGetProperty;
-        }
-
-        clientBufferSize = *ioDataSize;
-        if (clientBufferSize == 0)
-        {
-            ca_debug_string("AudioUnitGetProperty: *ioDataSize == 0 on entry");
-            // $$$ or should we allow this as a shortcut for finding the size?
-            result = kAudio_ParamError;
-            goto finishGetProperty;
-        }
-
-        result = AUI->DispatchGetPropertyInfo(inID, inScope, inElement, actualPropertySize, writable);
-        if (result != noErr)
-            goto finishGetProperty;
-
-        if (clientBufferSize < actualPropertySize)
-        {
-            tempBuffer = new char[actualPropertySize];
-            destBuffer = tempBuffer;
-        } else {
-            tempBuffer = NULL;
-            destBuffer = outData;
-        }
-
-        result = AUI->DispatchGetProperty(inID, inScope, inElement, destBuffer);
-
-        if (result == noErr) {
-            if (clientBufferSize < actualPropertySize && tempBuffer != NULL)
-            {
-                memcpy(outData, tempBuffer, clientBufferSize);
-                delete[] tempBuffer;
-                // ioDataSize remains correct, the number of bytes we wrote
-            } else
-                *ioDataSize = actualPropertySize;
-        } else
-            *ioDataSize = 0;
-    }
-    COMPONENT_CATCH
-finishGetProperty:
-    return result;
-}
-
-static OSStatus AUMethodSetProperty(void *self, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, const void *inData, UInt32 inDataSize)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        if (inData && inDataSize)
-            result = AUI->DispatchSetProperty(inID, inScope, inElement, inData, inDataSize);
-        else {
-            if (inData == NULL && inDataSize == 0) {
-                result = AUI->DispatchRemovePropertyValue(inID, inScope, inElement);
-            } else {
-                if (inData == NULL) {
-                    ca_debug_string("AudioUnitSetProperty: inData == NULL");
-                    result = kAudio_ParamError;
-                    goto finishSetProperty;
-                }
-
-                if (inDataSize == 0) {
-                    ca_debug_string("AudioUnitSetProperty: inDataSize == 0");
-                    result = kAudio_ParamError;
-                    goto finishSetProperty;
-                }
-            }
-        }
-    }
-    COMPONENT_CATCH
-finishSetProperty:
-    return result;
-}
-
-static OSStatus AUMethodAddPropertyListener(void *self, AudioUnitPropertyID prop, AudioUnitPropertyListenerProc proc, void *userData)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        result = AUI->AddPropertyListener(prop, proc, userData);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodRemovePropertyListener(void *self, AudioUnitPropertyID prop, AudioUnitPropertyListenerProc proc)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        result = AUI->RemovePropertyListener(prop, proc, NULL, false);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodRemovePropertyListenerWithUserData(void *self, AudioUnitPropertyID prop, AudioUnitPropertyListenerProc proc, void *userData)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        result = AUI->RemovePropertyListener(prop, proc, userData, true);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodAddRenderNotify(void *self, AURenderCallback proc, void *userData)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        result = AUI->SetRenderNotification(proc, userData);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodRemoveRenderNotify(void *self, AURenderCallback proc, void *userData)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        result = AUI->RemoveRenderNotification(proc, userData);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodGetParameter(void *self, AudioUnitParameterID param, AudioUnitScope scope, AudioUnitElement elem, AudioUnitParameterValue *value)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        result = (value == NULL ? kAudio_ParamError : AUI->GetParameter(param, scope, elem, *value));
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodSetParameter(void *self, AudioUnitParameterID param, AudioUnitScope scope, AudioUnitElement elem, AudioUnitParameterValue value, UInt32 bufferOffset)
-{
-    OSStatus result = noErr;
-    try {
-        // this is a (potentially) realtime method; no lock
-        result = AUI->SetParameter(param, scope, elem, value, bufferOffset);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodScheduleParameters(void *self, const AudioUnitParameterEvent *events, UInt32 numEvents)
-{
-    OSStatus result = noErr;
-    try {
-        // this is a (potentially) realtime method; no lock
-        result = AUI->ScheduleParameter(events, numEvents);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodRender(void *self, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inOutputBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData)
-{
-    OSStatus result = noErr;
-
-#if !TARGET_OS_IPHONE
-    try {
-#endif
-        // this is a processing method; no lock
-        AudioUnitRenderActionFlags tempFlags;
-
-        if (inTimeStamp == NULL || ioData == NULL)
-            result = kAudio_ParamError;
-        else {
-            if (ioActionFlags == NULL) {
-                tempFlags = 0;
-                ioActionFlags = &tempFlags;
-            }
-            result = AUI->DoRender(*ioActionFlags, *inTimeStamp, inOutputBusNumber, inNumberFrames, *ioData);
-        }
-
-#if !TARGET_OS_IPHONE
-    }
-    COMPONENT_CATCH
-#endif
-
-    return result;
-}
-
-static OSStatus AUMethodComplexRender(void *self, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inOutputBusNumber, UInt32 inNumberOfPackets, UInt32 *outNumberOfPackets, AudioStreamPacketDescription *outPacketDescriptions, AudioBufferList *ioData, void *outMetadata, UInt32 *outMetadataByteSize)
-{
-    OSStatus result = noErr;
-
-#if !TARGET_OS_IPHONE
-    try {
-#endif
-        // this is a processing method; no lock
-        AudioUnitRenderActionFlags tempFlags;
-
-        if (inTimeStamp == NULL || ioData == NULL)
-            result = kAudio_ParamError;
-        else {
-            if (ioActionFlags == NULL) {
-                tempFlags = 0;
-                ioActionFlags = &tempFlags;
-            }
-            result = AUI->ComplexRender(*ioActionFlags, *inTimeStamp, inOutputBusNumber, inNumberOfPackets, outNumberOfPackets, outPacketDescriptions, *ioData, outMetadata, outMetadataByteSize);
-        }
-
-#if !TARGET_OS_IPHONE
-    }
-    COMPONENT_CATCH
-#endif
-
-    return result;
-}
-
-static OSStatus AUMethodReset(void *self, AudioUnitScope scope, AudioUnitElement elem)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        result = AUI->Reset(scope, elem);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodProcess (void *self, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inNumberFrames, AudioBufferList *ioData)
-{
-    OSStatus result = noErr;
-
-#if !TARGET_OS_IPHONE
-    try {
-#endif
-        // this is a processing method; no lock
-        bool doParamCheck = true;
-
-        AudioUnitRenderActionFlags tempFlags;
-
-        if (ioActionFlags == NULL) {
-            tempFlags = 0;
-            ioActionFlags = &tempFlags;
-        } else {
-            if (*ioActionFlags & (1 << 9)/*kAudioUnitRenderAction_DoNotCheckRenderArgs*/)
-                doParamCheck = false;
-        }
-
-        if (doParamCheck && (inTimeStamp == NULL || ioData == NULL))
-            result = kAudio_ParamError;
-        else {
-            result = AUI->DoProcess(*ioActionFlags, *inTimeStamp, inNumberFrames, *ioData);
-        }
-
-#if !TARGET_OS_IPHONE
-    }
-    COMPONENT_CATCH
-#endif
-
-    return result;
-}
-
-static OSStatus AUMethodProcessMultiple (void *self, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inNumberFrames, UInt32 inNumberInputBufferLists, const AudioBufferList **inInputBufferLists, UInt32 inNumberOutputBufferLists, AudioBufferList **ioOutputBufferLists)
-{
-    OSStatus result = noErr;
-
-#if !TARGET_OS_IPHONE
-    try {
-#endif
-        // this is a processing method; no lock
-        bool doParamCheck = true;
-
-        AudioUnitRenderActionFlags tempFlags;
-
-        if (ioActionFlags == NULL) {
-            tempFlags = 0;
-            ioActionFlags = &tempFlags;
-        } else {
-            if (*ioActionFlags & (1 << 9)/*kAudioUnitRenderAction_DoNotCheckRenderArgs*/)
-                doParamCheck = false;
-        }
-
-        if (doParamCheck && (inTimeStamp == NULL || inInputBufferLists == NULL || ioOutputBufferLists == NULL))
-            result = kAudio_ParamError;
-        else {
-            result = AUI->DoProcessMultiple(*ioActionFlags, *inTimeStamp, inNumberFrames, inNumberInputBufferLists, inInputBufferLists, inNumberOutputBufferLists, ioOutputBufferLists);
-        }
-
-#if !TARGET_OS_IPHONE
-    }
-    COMPONENT_CATCH
-#endif
-
-    return result;
-}
-// ------------------------------------------------------------------------------------------------
-
-static OSStatus AUMethodStart(void *self)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        result = AUI->Start();
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodStop(void *self)
-{
-    OSStatus result = noErr;
-    try {
-        AUI_LOCK
-        result = AUI->Stop();
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-// ------------------------------------------------------------------------------------------------
-
-#if !CA_BASIC_AU_FEATURES
-// I don't know what I'm doing here; conflicts with the multiple inheritence in MusicDeviceBase.
-static OSStatus AUMethodMIDIEvent(void *self, UInt32 inStatus, UInt32 inData1, UInt32 inData2, UInt32 inOffsetSampleFrame)
-{
-    OSStatus result = noErr;
-    try {
-        // this is a potential render-time method; no lock
-        result = AUI->MIDIEvent(inStatus, inData1, inData2, inOffsetSampleFrame);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodSysEx(void *self, const UInt8 *inData, UInt32 inLength)
-{
-    OSStatus result = noErr;
-    try {
-        // this is a potential render-time method; no lock
-        result = AUI->SysEx(inData, inLength);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodStartNote(void *self, MusicDeviceInstrumentID inInstrument, MusicDeviceGroupID inGroupID, NoteInstanceID *outNoteInstanceID, UInt32 inOffsetSampleFrame, const MusicDeviceNoteParams *inParams)
-{
-    OSStatus result = noErr;
-    try {
-        // this is a potential render-time method; no lock
-        if (inParams == NULL || outNoteInstanceID == NULL)
-            result = kAudio_ParamError;
-        else
-            result = AUI->StartNote(inInstrument, inGroupID, outNoteInstanceID, inOffsetSampleFrame, *inParams);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodStopNote(void *self, MusicDeviceGroupID inGroupID, NoteInstanceID inNoteInstanceID, UInt32 inOffsetSampleFrame)
-{
-    OSStatus result = noErr;
-    try {
-        // this is a potential render-time method; no lock
-        result = AUI->StopNote(inGroupID, inNoteInstanceID, inOffsetSampleFrame);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-#if !TARGET_OS_IPHONE
-static OSStatus AUMethodPrepareInstrument (void *self, MusicDeviceInstrumentID inInstrument)
-{
-    OSStatus result = noErr;
-    try {
-        // this is a potential render-time method; no lock
-        result = AUI->PrepareInstrument(inInstrument);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-static OSStatus AUMethodReleaseInstrument (void *self, MusicDeviceInstrumentID inInstrument)
-{
-    OSStatus result = noErr;
-    try {
-        // this is a potential render-time method; no lock
-        result = AUI->ReleaseInstrument(inInstrument);
-    }
-    COMPONENT_CATCH
-    return result;
-}
-#endif // TARGET_OS_IPHONE
-#endif // CA_BASIC_AU_FEATURES
-
-
-//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-#pragma mark -
-#pragma mark Lookup Methods
-
-AudioComponentMethod AUBaseLookup::Lookup (SInt16 selector)
-{
-    switch (selector) {
-        case kAudioUnitInitializeSelect:        return (AudioComponentMethod)AUMethodInitialize;
-        case kAudioUnitUninitializeSelect:      return (AudioComponentMethod)AUMethodUninitialize;
-        case kAudioUnitGetPropertyInfoSelect:   return (AudioComponentMethod)AUMethodGetPropertyInfo;
-        case kAudioUnitGetPropertySelect:       return (AudioComponentMethod)AUMethodGetProperty;
-        case kAudioUnitSetPropertySelect:       return (AudioComponentMethod)AUMethodSetProperty;
-        case kAudioUnitAddPropertyListenerSelect:return (AudioComponentMethod)AUMethodAddPropertyListener;
-        case kAudioUnitRemovePropertyListenerSelect:
-                                                return (AudioComponentMethod)AUMethodRemovePropertyListener;
-        case kAudioUnitRemovePropertyListenerWithUserDataSelect:
-                                                return (AudioComponentMethod)AUMethodRemovePropertyListenerWithUserData;
-        case kAudioUnitAddRenderNotifySelect:   return (AudioComponentMethod)AUMethodAddRenderNotify;
-        case kAudioUnitRemoveRenderNotifySelect:return (AudioComponentMethod)AUMethodRemoveRenderNotify;
-        case kAudioUnitGetParameterSelect:      return (AudioComponentMethod)AUMethodGetParameter;
-        case kAudioUnitSetParameterSelect:      return (AudioComponentMethod)AUMethodSetParameter;
-        case kAudioUnitScheduleParametersSelect:return (AudioComponentMethod)AUMethodScheduleParameters;
-        case kAudioUnitRenderSelect:            return (AudioComponentMethod)AUMethodRender;
-        case kAudioUnitResetSelect:             return (AudioComponentMethod)AUMethodReset;
-        default:
-            break;
-    }
-    return NULL;
-}
-
-AudioComponentMethod AUOutputLookup::Lookup (SInt16 selector)
-{
-    AudioComponentMethod method = AUBaseLookup::Lookup(selector);
-    if (method) return method;
-
-    switch (selector) {
-        case kAudioOutputUnitStartSelect:   return (AudioComponentMethod)AUMethodStart;
-        case kAudioOutputUnitStopSelect:    return (AudioComponentMethod)AUMethodStop;
-        default:
-            break;
-    }
-    return NULL;
-}
-
-AudioComponentMethod AUComplexOutputLookup::Lookup (SInt16 selector)
-{
-    AudioComponentMethod method = AUBaseLookup::Lookup(selector);
-    if (method) return method;
-
-    method = AUOutputLookup::Lookup(selector);
-    if (method) return method;
-
-    if (selector == kAudioUnitComplexRenderSelect)
-        return (AudioComponentMethod)AUMethodComplexRender;
-    return NULL;
-}
-
-AudioComponentMethod AUBaseProcessLookup::Lookup (SInt16 selector)
-{
-    AudioComponentMethod method = AUBaseLookup::Lookup(selector);
-    if (method) return method;
-
-    if (selector == kAudioUnitProcessSelect)
-        return (AudioComponentMethod)AUMethodProcess;
-
-    return NULL;
-}
-
-AudioComponentMethod AUBaseProcessMultipleLookup::Lookup (SInt16 selector)
-{
-    AudioComponentMethod method = AUBaseLookup::Lookup(selector);
-    if (method) return method;
-
-    if (selector == kAudioUnitProcessMultipleSelect)
-        return (AudioComponentMethod)AUMethodProcessMultiple;
-
-    return NULL;
-}
-
-AudioComponentMethod AUBaseProcessAndMultipleLookup::Lookup (SInt16 selector)
-{
-    AudioComponentMethod method = AUBaseLookup::Lookup(selector);
-    if (method) return method;
-
-    method = AUBaseProcessMultipleLookup::Lookup(selector);
-    if (method) return method;
-
-    method = AUBaseProcessLookup::Lookup(selector);
-    if (method) return method;
-
-    return NULL;
-}
-
-#if !CA_BASIC_AU_FEATURES
-inline AudioComponentMethod MIDI_Lookup (SInt16 selector)
-{
-    switch (selector) {
-        case kMusicDeviceMIDIEventSelect:   return (AudioComponentMethod)AUMethodMIDIEvent;
-        case kMusicDeviceSysExSelect:       return (AudioComponentMethod)AUMethodSysEx;
-        default:
-            break;
-    }
-    return NULL;
-}
-
-AudioComponentMethod AUMIDILookup::Lookup (SInt16 selector)
-{
-    AudioComponentMethod method = AUBaseLookup::Lookup(selector);
-    if (method) return method;
-
-    return MIDI_Lookup(selector);
-}
-
-AudioComponentMethod AUMIDIProcessLookup::Lookup (SInt16 selector)
-{
-    AudioComponentMethod method = AUBaseProcessLookup::Lookup(selector);
-    if (method) return method;
-
-    return MIDI_Lookup(selector);
-}
-
-AudioComponentMethod AUMusicLookup::Lookup (SInt16 selector)
-{
-    AudioComponentMethod method = AUBaseLookup::Lookup(selector);
-    if (method) return method;
-
-    switch (selector) {
-        case kMusicDeviceStartNoteSelect:   return (AudioComponentMethod)AUMethodStartNote;
-        case kMusicDeviceStopNoteSelect:    return (AudioComponentMethod)AUMethodStopNote;
-#if !TARGET_OS_IPHONE
-        case kMusicDevicePrepareInstrumentSelect:   return (AudioComponentMethod)AUMethodPrepareInstrument;
-        case kMusicDeviceReleaseInstrumentSelect:   return (AudioComponentMethod)AUMethodReleaseInstrument;
-#endif
-        default:
-            break;
-    }
-    return MIDI_Lookup (selector);
-}
-
-AudioComponentMethod AUAuxBaseLookup::Lookup (SInt16 selector)
-{
-    switch (selector) {
-        case kAudioUnitGetPropertyInfoSelect:   return (AudioComponentMethod)AUMethodGetPropertyInfo;
-        case kAudioUnitGetPropertySelect:       return (AudioComponentMethod)AUMethodGetProperty;
-        case kAudioUnitSetPropertySelect:       return (AudioComponentMethod)AUMethodSetProperty;
-
-        case kAudioUnitGetParameterSelect:      return (AudioComponentMethod)AUMethodGetParameter;
-        case kAudioUnitSetParameterSelect:      return (AudioComponentMethod)AUMethodSetParameter;
-
-        default:
-            break;
-    }
-    return NULL;
-}
-#endif
-
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUPlugInDispatch.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUPlugInDispatch.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUPlugInDispatch.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#ifndef __AUPlugInBase_h__
-#define __AUPlugInBase_h__
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <AudioUnit/AudioComponent.h>
-    #if !CA_BASIC_AU_FEATURES
-        #include <AudioUnit/MusicDevice.h>
-    #endif
-#else
-    #include "AudioComponent.h"
-    #include "MusicDevice.h"
-#endif
-
-#include "ComponentBase.h"
-
-struct AUBaseLookup {
-    static AudioComponentMethod Lookup (SInt16 selector);
-};
-template <class Implementor>
-class AUBaseFactory : public APFactory<AUBaseLookup, Implementor>
-{
-};
-
-struct AUOutputLookup {
-    static AudioComponentMethod Lookup (SInt16 selector);
-};
-template <class Implementor>
-class AUOutputBaseFactory : public APFactory<AUOutputLookup, Implementor>
-{
-};
-
-struct AUComplexOutputLookup {
-    static AudioComponentMethod Lookup (SInt16 selector);
-};
-template <class Implementor>
-class AUOutputComplexBaseFactory : public APFactory<AUComplexOutputLookup, Implementor>
-{
-};
-
-struct AUBaseProcessLookup {
-    static AudioComponentMethod Lookup (SInt16 selector);
-};
-template <class Implementor>
-class AUBaseProcessFactory : public APFactory<AUBaseProcessLookup, Implementor>
-{
-};
-
-struct AUBaseProcessMultipleLookup {
-    static AudioComponentMethod Lookup (SInt16 selector);
-};
-template <class Implementor>
-class AUBaseProcessMultipleFactory : public APFactory<AUBaseProcessMultipleLookup, Implementor>
-{
-};
-
-struct AUBaseProcessAndMultipleLookup {
-    static AudioComponentMethod Lookup (SInt16 selector);
-};
-template <class Implementor>
-class AUBaseProcessAndMultipleFactory : public APFactory<AUBaseProcessAndMultipleLookup, Implementor>
-{
-};
-
-#if !CA_BASIC_AU_FEATURES
-struct AUMIDILookup {
-    static AudioComponentMethod Lookup (SInt16 selector);
-};
-template <class Implementor>
-class AUMIDIEffectFactory : public APFactory<AUMIDILookup, Implementor>
-{
-};
-
-struct AUMIDIProcessLookup {
-    static AudioComponentMethod Lookup (SInt16 selector);
-};
-template <class Implementor>
-class AUMIDIProcessFactory : public APFactory<AUMIDIProcessLookup, Implementor>
-{
-};
-
-struct AUMusicLookup {
-    static AudioComponentMethod Lookup (SInt16 selector);
-};
-template <class Implementor>
-class AUMusicDeviceFactory : public APFactory<AUMusicLookup, Implementor>
-{
-};
-
-struct AUAuxBaseLookup {
-    static AudioComponentMethod Lookup (SInt16 selector);
-};
-template <class Implementor>
-class AUAuxBaseFactory : public APFactory<AUAuxBaseLookup, Implementor>
-{
-};
-#endif // CA_BASIC_AU_FEATURES
-
-#endif // __AUPlugInBase_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUScopeElement.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUScopeElement.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUScopeElement.cpp
+++ /dev/null
@@ -1,559 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#include "AUScopeElement.h"
-#include <AudioUnit/AudioUnitProperties.h>
-#include "AUBase.h"
-
-/* This is defined in later MacOSX SDKs than the SDK used on the official build systems */
-#ifndef kAudioUnitParameterFlag_OmitFromPresets
- #define kAudioUnitParameterFlag_OmitFromPresets (1UL << 13)
-#endif
-
-//_____________________________________________________________________________
-//
-//  By default, parameterIDs may be arbitrarily spaced, and an STL map
-//  will be used for access.  Calling UseIndexedParameters() will
-//  instead use an STL vector for faster indexed access.
-//  This assumes the paramIDs are numbered 0.....inNumberOfParameters-1
-//  Call this before defining/adding any parameters with SetParameter()
-//
-void    AUElement::UseIndexedParameters(int inNumberOfParameters)
-{
-    mIndexedParameters.resize (inNumberOfParameters);
-    mUseIndexedParameters = true;
-}
-
-//_____________________________________________________________________________
-//
-//  Helper method.
-//  returns the ParameterMapEvent object associated with the paramID
-//
-inline ParameterMapEvent&   AUElement::GetParamEvent(AudioUnitParameterID paramID)
-{
-    ParameterMapEvent *event;
-
-    if(mUseIndexedParameters)
-    {
-        if(paramID >= mIndexedParameters.size() )
-            COMPONENT_THROW(kAudioUnitErr_InvalidParameter);
-
-        event = &mIndexedParameters[paramID];
-    }
-    else
-    {
-        ParameterMap::iterator i = mParameters.find(paramID);
-        if (i == mParameters.end())
-            COMPONENT_THROW(kAudioUnitErr_InvalidParameter);
-
-        event = &(*i).second;
-    }
-
-    return *event;
-}
-
-//_____________________________________________________________________________
-//
-//  Helper method.
-//  returns whether the specified paramID is known to the element
-//
-bool        AUElement::HasParameterID (AudioUnitParameterID paramID) const
-{
-    if(mUseIndexedParameters)
-    {
-        if(paramID >= mIndexedParameters.size() )
-            return false;
-
-        return true;
-    }
-
-    ParameterMap::const_iterator i = mParameters.find(paramID);
-    if (i == mParameters.end())
-        return false;
-
-    return true;
-}
-
-//_____________________________________________________________________________
-//
-//  caller assumes that this is actually an immediate parameter
-//
-AudioUnitParameterValue     AUElement::GetParameter(AudioUnitParameterID paramID)
-{
-    ParameterMapEvent &event = GetParamEvent(paramID);
-
-    return event.GetValue();
-}
-
-
-//_____________________________________________________________________________
-//
-void            AUElement::GetRampSliceStartEnd(    AudioUnitParameterID        paramID,
-                                                    AudioUnitParameterValue &   outStartValue,
-                                                    AudioUnitParameterValue &   outEndValue,
-                                                    AudioUnitParameterValue &   outValuePerFrameDelta )
-
-{
-    ParameterMapEvent &event = GetParamEvent(paramID);
-
-    // works even if the value is constant (immediate parameter value)
-    event.GetRampSliceStartEnd(outStartValue, outEndValue, outValuePerFrameDelta );
-}
-
-//_____________________________________________________________________________
-//
-AudioUnitParameterValue         AUElement::GetEndValue( AudioUnitParameterID        paramID)
-
-{
-    ParameterMapEvent &event = GetParamEvent(paramID);
-
-    // works even if the value is constant (immediate parameter value)
-    return event.GetEndValue();
-}
-
-//_____________________________________________________________________________
-//
-void            AUElement::SetParameter(AudioUnitParameterID paramID, AudioUnitParameterValue inValue, bool okWhenInitialized)
-{
-    if(mUseIndexedParameters)
-    {
-        ParameterMapEvent &event = GetParamEvent(paramID);
-        event.SetValue(inValue);
-    }
-    else
-    {
-        ParameterMap::iterator i = mParameters.find(paramID);
-
-        if (i == mParameters.end())
-        {
-            if (mAudioUnit->IsInitialized() && !okWhenInitialized) {
-                // The AU should not be creating new parameters once initialized.
-                // If a client tries to set an undefined parameter, we could throw as follows,
-                // but this might cause a regression. So it is better to just fail silently.
-                // COMPONENT_THROW(kAudioUnitErr_InvalidParameter);
-#if DEBUG
-                fprintf(stderr, "WARNING: %s SetParameter for undefined param ID %d while initialized. Ignoring..\n",
-                                mAudioUnit->GetLoggingString(), (int)paramID);
-#endif
-            } else {
-                // create new entry in map for the paramID (only happens first time)
-                ParameterMapEvent event(inValue);
-                mParameters[paramID] = event;
-            }
-        }
-        else
-        {
-            // paramID already exists in map so simply change its value
-            ParameterMapEvent &event = (*i).second;
-            event.SetValue(inValue);
-        }
-    }
-}
-
-//_____________________________________________________________________________
-//
-void            AUElement::SetScheduledEvent(   AudioUnitParameterID            paramID,
-                                                const AudioUnitParameterEvent   &inEvent,
-                                                UInt32                          inSliceOffsetInBuffer,
-                                                UInt32                          inSliceDurationFrames,
-                                                bool                            okWhenInitialized )
-{
-    if(mUseIndexedParameters)
-    {
-        ParameterMapEvent &event = GetParamEvent(paramID);
-        event.SetScheduledEvent(inEvent, inSliceOffsetInBuffer, inSliceDurationFrames );
-    }
-    else
-    {
-        ParameterMap::iterator i = mParameters.find(paramID);
-
-        if (i == mParameters.end())
-        {
-            if (mAudioUnit->IsInitialized() && !okWhenInitialized) {
-                // The AU should not be creating new parameters once initialized.
-                // If a client tries to set an undefined parameter, we could throw as follows,
-                // but this might cause a regression. So it is better to just fail silently.
-                // COMPONENT_THROW(kAudioUnitErr_InvalidParameter);
-#if DEBUG
-                fprintf(stderr, "WARNING: %s SetScheduledEvent for undefined param ID %d while initialized. Ignoring..\n",
-                                mAudioUnit->GetLoggingString(), (int)paramID);
-#endif
-            } else {
-                // create new entry in map for the paramID (only happens first time)
-                ParameterMapEvent event(inEvent, inSliceOffsetInBuffer, inSliceDurationFrames);
-                mParameters[paramID] = event;
-            }
-        }
-        else
-        {
-            // paramID already exists in map so simply change its value
-            ParameterMapEvent &event = (*i).second;
-
-            event.SetScheduledEvent(inEvent, inSliceOffsetInBuffer, inSliceDurationFrames );
-        }
-    }
-}
-
-
-
-//_____________________________________________________________________________
-//
-void            AUElement::GetParameterList(AudioUnitParameterID *outList)
-{
-    if(mUseIndexedParameters)
-    {
-        UInt32 nparams = static_cast<UInt32>(mIndexedParameters.size());
-        for (UInt32 i = 0; i < nparams; i++ )
-            *outList++ = (AudioUnitParameterID)i;
-    }
-    else
-    {
-        for (ParameterMap::iterator i = mParameters.begin(); i != mParameters.end(); ++i)
-            *outList++ = (*i).first;
-    }
-}
-
-//_____________________________________________________________________________
-//
-void            AUElement::SaveState(AudioUnitScope scope, CFMutableDataRef data)
-{
-    AudioUnitParameterInfo paramInfo;
-    CFIndex countOffset = CFDataGetLength(data);
-    UInt32 nparams, nOmitted = 0, theData;
-
-    if(mUseIndexedParameters)
-    {
-        nparams = static_cast<UInt32>(mIndexedParameters.size());
-        theData = CFSwapInt32HostToBig(nparams);
-        CFDataAppendBytes(data, (UInt8 *)&theData, sizeof(nparams));
-
-        for (UInt32 i = 0; i < nparams; i++)
-        {
-            struct {
-                UInt32              paramID;
-                //CFSwappedFloat32  value; crashes gcc3 PFE
-                UInt32              value;  // really a big-endian float
-            } entry;
-
-            if (mAudioUnit->GetParameterInfo(scope, i, paramInfo) == noErr) {
-                if ((paramInfo.flags & kAudioUnitParameterFlag_CFNameRelease) && paramInfo.cfNameString)
-                    CFRelease(paramInfo.cfNameString);
-                if (paramInfo.flags & kAudioUnitParameterFlag_OmitFromPresets) {
-                    ++nOmitted;
-                    continue;
-                }
-            }
-
-            entry.paramID = CFSwapInt32HostToBig(i);
-
-            AudioUnitParameterValue v = mIndexedParameters[i].GetValue();
-            entry.value = CFSwapInt32HostToBig(*(UInt32 *)&v );
-
-            CFDataAppendBytes(data, (UInt8 *)&entry, sizeof(entry));
-        }
-    }
-    else
-    {
-        nparams = static_cast<uint32_t>(mParameters.size());
-        theData = CFSwapInt32HostToBig(nparams);
-        CFDataAppendBytes(data, (UInt8 *)&theData, sizeof(nparams));
-
-        for (ParameterMap::iterator i = mParameters.begin(); i != mParameters.end(); ++i) {
-            struct {
-                UInt32              paramID;
-                //CFSwappedFloat32  value; crashes gcc3 PFE
-                UInt32              value;  // really a big-endian float
-            } entry;
-
-            if (mAudioUnit->GetParameterInfo(scope, (*i).first, paramInfo) == noErr) {
-                if ((paramInfo.flags & kAudioUnitParameterFlag_CFNameRelease) && paramInfo.cfNameString)
-                    CFRelease(paramInfo.cfNameString);
-                if (paramInfo.flags & kAudioUnitParameterFlag_OmitFromPresets) {
-                    ++nOmitted;
-                    continue;
-                }
-            }
-
-            entry.paramID = CFSwapInt32HostToBig((*i).first);
-
-            AudioUnitParameterValue v = (*i).second.GetValue();
-            entry.value = CFSwapInt32HostToBig(*(UInt32 *)&v );
-
-            CFDataAppendBytes(data, (UInt8 *)&entry, sizeof(entry));
-        }
-    }
-    if (nOmitted > 0) {
-        theData = CFSwapInt32HostToBig(nparams - nOmitted);
-        *(UInt32 *)(CFDataGetBytePtr(data) + countOffset) = theData;
-    }
-}
-
-//_____________________________________________________________________________
-//
-const UInt8 *   AUElement::RestoreState(const UInt8 *state)
-{
-    union FloatInt32 { UInt32 i; AudioUnitParameterValue f; };
-    const UInt8 *p = state;
-    UInt32 nparams = CFSwapInt32BigToHost(*(UInt32 *)p);
-    p += sizeof(UInt32);
-
-    for (UInt32 i = 0; i < nparams; ++i) {
-        struct {
-            AudioUnitParameterID        paramID;
-            AudioUnitParameterValue     value;
-        } entry;
-
-        entry.paramID = CFSwapInt32BigToHost(*(UInt32 *)p);
-        p += sizeof(UInt32);
-        FloatInt32 temp;
-        temp.i = CFSwapInt32BigToHost(*(UInt32 *)p);
-        entry.value = temp.f;
-        p += sizeof(AudioUnitParameterValue);
-
-        SetParameter(entry.paramID, entry.value);
-    }
-    return p;
-}
-
-//_____________________________________________________________________________
-//
-void    AUElement::SetName (CFStringRef inName)
-{
-    if (mElementName) CFRelease (mElementName);
-    mElementName = inName;
-    if (mElementName) CFRetain (mElementName);
-}
-
-
-//_____________________________________________________________________________
-//
-AUIOElement::AUIOElement(AUBase *audioUnit) :
-    AUElement(audioUnit),
-    mWillAllocate (true)
-{
-    mStreamFormat = CAStreamBasicDescription(kAUDefaultSampleRate, 2, CAStreamBasicDescription::kPCMFormatFloat32, audioUnit->AudioUnitAPIVersion() == 1);
-        // stereo
-        // interleaved if API version 1, deinterleaved if version 2
-}
-
-//_____________________________________________________________________________
-//
-OSStatus        AUIOElement::SetStreamFormat(const CAStreamBasicDescription &desc)
-{
-    mStreamFormat = desc;
-    return AUBase::noErr;
-}
-
-//_____________________________________________________________________________
-// inFramesToAllocate == 0 implies the AudioUnit's max-frames-per-slice will be used
-void            AUIOElement::AllocateBuffer(UInt32 inFramesToAllocate)
-{
-    if (GetAudioUnit()->HasBegunInitializing())
-    {
-        UInt32 framesToAllocate = inFramesToAllocate > 0 ? inFramesToAllocate : GetAudioUnit()->GetMaxFramesPerSlice();
-
-//      printf ("will allocate: %d\n", (int)((mWillAllocate && NeedsBufferSpace()) ? framesToAllocate : 0));
-
-        mIOBuffer.Allocate(mStreamFormat, (mWillAllocate && NeedsBufferSpace()) ? framesToAllocate : 0);
-    }
-}
-
-//_____________________________________________________________________________
-//
-void            AUIOElement::DeallocateBuffer()
-{
-    mIOBuffer.Deallocate();
-}
-
-//_____________________________________________________________________________
-//
-//      AudioChannelLayout support
-
-// outLayoutTagsPtr WILL be NULL if called to find out how many
-// layouts that Audio Unit will report
-// return 0 (ie. NO channel layouts) if the AU doesn't require channel layout knowledge
-UInt32      AUIOElement::GetChannelLayoutTags (AudioChannelLayoutTag        *outLayoutTagsPtr)
-{
-    return 0;
-}
-
-// As the AudioChannelLayout can be a variable length structure
-// (though in most cases it won't be!!!)
-// The size of the ACL is always returned by the method
-// if outMapPtr is NOT-NULL, then AU should copy into this pointer (outMapPtr) the current ACL that it has in use.
-// the AU should also return whether the property is writable (that is the client can provide any arbitrary ACL that the audio unit will then honour)
-// or if the property is read only - which is the generally preferred mode.
-// If the AU doesn't require an AudioChannelLayout, then just return 0.
-UInt32      AUIOElement::GetAudioChannelLayout (AudioChannelLayout  *outMapPtr,
-                                                Boolean             &outWritable)
-{
-    return 0;
-}
-
-// the incoming channel map will be at least as big as a basic AudioChannelLayout
-// but its contents will determine its actual size
-// Subclass should overide if channel map is writable
-OSStatus    AUIOElement::SetAudioChannelLayout (const AudioChannelLayout &inData)
-{
-    return kAudioUnitErr_InvalidProperty;
-}
-
-// Some units support optional usage of channel maps - typically converter units
-// that can do channel remapping between different maps. In that optional case
-// the user should be able to remove a channel map if that is possible.
-// Typically this is NOT the case (e.g., the 3DMixer even in the stereo case
-// needs to know if it is rendering to speakers or headphones)
-OSStatus    AUIOElement::RemoveAudioChannelLayout ()
-{
-    return kAudioUnitErr_InvalidPropertyValue;
-}
-
-
-//_____________________________________________________________________________
-//
-AUScope::~AUScope()
-{
-    for (ElementVector::iterator it = mElements.begin(); it != mElements.end(); ++it)
-        delete *it;
-}
-
-//_____________________________________________________________________________
-//
-void    AUScope::SetNumberOfElements(UInt32 numElements)
-{
-    if (mDelegate)
-        return mDelegate->SetNumberOfElements(numElements);
-
-    if (numElements > mElements.size()) {
-        mElements.reserve(numElements);
-        while (numElements > mElements.size()) {
-            AUElement *elem = mCreator->CreateElement(GetScope(), static_cast<UInt32>(mElements.size()));
-            mElements.push_back(elem);
-        }
-    } else
-        while (numElements < mElements.size()) {
-            AUElement *elem = mElements.back();
-            mElements.pop_back();
-            delete elem;
-        }
-}
-
-//_____________________________________________________________________________
-//
-bool    AUScope::HasElementWithName () const
-{
-    for (UInt32 i = 0; i < GetNumberOfElements(); ++i) {
-        AUElement * el = const_cast<AUScope*>(this)->GetElement (i);
-        if (el && el->HasName()) {
-            return true;
-        }
-    }
-    return false;
-}
-
-//_____________________________________________________________________________
-//
-
-void    AUScope::AddElementNamesToDict (CFMutableDictionaryRef & inNameDict)
-{
-    if (HasElementWithName())
-    {
-        static char string[32];
-        CFMutableDictionaryRef elementDict = CFDictionaryCreateMutable  (NULL, 0,
-                                &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
-        CFStringRef str;
-        for (UInt32 i = 0; i < GetNumberOfElements(); ++i) {
-            AUElement * el = GetElement (i);
-            if (el && el->HasName()) {
-                snprintf (string, sizeof(string), "%d", int(i));
-                str = CFStringCreateWithCString (NULL, string, kCFStringEncodingASCII);
-                CFDictionarySetValue (elementDict, str, el->GetName());
-                CFRelease (str);
-            }
-        }
-
-        snprintf (string, sizeof(string), "%d", int(mScope));
-        str = CFStringCreateWithCString (NULL, string, kCFStringEncodingASCII);
-        CFDictionarySetValue (inNameDict, str, elementDict);
-        CFRelease (str);
-        CFRelease (elementDict);
-    }
-}
-
-//_____________________________________________________________________________
-//
-bool    AUScope::RestoreElementNames (CFDictionaryRef& inNameDict)
-{
-    static char string[32];
-
-    //first we have to see if we have enough elements
-    bool didAddElements = false;
-    unsigned int maxElNum = GetNumberOfElements();
-
-    int dictSize = static_cast<int>(CFDictionaryGetCount(inNameDict));
-    CFStringRef * keys = (CFStringRef*)CA_malloc (dictSize * sizeof (CFStringRef));
-    CFDictionaryGetKeysAndValues (inNameDict, reinterpret_cast<const void**>(keys), NULL);
-    for (int i = 0; i < dictSize; i++)
-    {
-        unsigned int intKey = 0;
-        CFStringGetCString (keys[i], string, 32, kCFStringEncodingASCII);
-        int result = sscanf (string, "%u", &intKey);
-        // check if sscanf succeeded and element index is less than max elements.
-        if (result && UInt32(intKey) < maxElNum)
-        {
-            CFStringRef elName = reinterpret_cast<CFStringRef>(CFDictionaryGetValue (inNameDict,  keys[i]));
-            AUElement* element = GetElement (intKey);
-            if (element)
-                element->SetName (elName);
-        }
-    }
-    free (keys);
-
-    return didAddElements;
-}
-
-void    AUScope::SaveState(CFMutableDataRef data)
-{
-    AudioUnitElement nElems = GetNumberOfElements();
-    for (AudioUnitElement ielem = 0; ielem < nElems; ++ielem) {
-        AUElement *element = GetElement(ielem);
-        UInt32 nparams = element->GetNumberOfParameters();
-        if (nparams > 0) {
-            struct {
-                UInt32  scope;
-                UInt32  element;
-            } hdr;
-
-            hdr.scope = CFSwapInt32HostToBig(GetScope());
-            hdr.element = CFSwapInt32HostToBig(ielem);
-            CFDataAppendBytes(data, (UInt8 *)&hdr, sizeof(hdr));
-
-            element->SaveState(mScope, data);
-        }
-    }
-}
-
-const UInt8 *   AUScope::RestoreState(const UInt8 *state)
-{
-    const UInt8 *p = state;
-    UInt32 elementIdx = CFSwapInt32BigToHost(*(UInt32 *)p); p += sizeof(UInt32);
-    AUElement *element = GetElement(elementIdx);
-    if (!element) {
-        struct {
-            AudioUnitParameterID        paramID;
-            AudioUnitParameterValue     value;
-        } entry;
-        UInt32 nparams = CFSwapInt32BigToHost(*(UInt32 *)p);
-        p += sizeof(UInt32);
-
-        p += nparams * sizeof(entry);
-    } else
-        p = element->RestoreState(p);
-
-    return p;
-}
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUScopeElement.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUScopeElement.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUScopeElement.h
+++ /dev/null
@@ -1,519 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#ifndef __AUScopeElement_h__
-#define __AUScopeElement_h__
-
-#include <map>
-#include <vector>
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <AudioUnit/AudioUnit.h>
-#else
-    #include <AudioUnit.h>
-#endif
-#include "ComponentBase.h"
-#include "AUBuffer.h"
-
-class AUBase;
-
-#ifndef CA_CANONICAL_DEPRECATED
-    #define CA_CANONICAL_DEPRECATED
-#endif
-
-// ____________________________________________________________________________
-//
-// represents a parameter's value (either constant or ramped)
-/*! @class ParameterMapEvent */
-class ParameterMapEvent
-{
-public:
-/*! @ctor ParameterMapEvent */
-    ParameterMapEvent()
-        : mEventType(kParameterEvent_Immediate), mBufferOffset(0), mDurationInFrames(0), mValue1(0.0f), mValue2(0.0f), mSliceDurationFrames(0)
-        {}
-
-/*! @ctor ParameterMapEvent */
-    ParameterMapEvent(AudioUnitParameterValue inValue)
-        : mEventType(kParameterEvent_Immediate), mBufferOffset(0), mDurationInFrames(0), mValue1(inValue), mValue2(inValue), mSliceDurationFrames(0)
-        {}
-
-    // constructor for scheduled event
-/*! @ctor ParameterMapEvent */
-    ParameterMapEvent(  const AudioUnitParameterEvent   &inEvent,
-                        UInt32                          inSliceOffsetInBuffer,
-                        UInt32                          inSliceDurationFrames )
-    {
-        SetScheduledEvent(inEvent, inSliceOffsetInBuffer, inSliceDurationFrames );
-    };
-
-/*! @method SetScheduledEvent */
-    void SetScheduledEvent( const AudioUnitParameterEvent   &inEvent,
-                            UInt32                          inSliceOffsetInBuffer,
-                            UInt32                          inSliceDurationFrames )
-    {
-        mEventType = inEvent.eventType;
-        mSliceDurationFrames = inSliceDurationFrames;
-
-        if(mEventType == kParameterEvent_Immediate )
-        {
-            // constant immediate value for the whole slice
-            mValue1 = inEvent.eventValues.immediate.value;
-            mValue2 = mValue1;
-            mDurationInFrames = inSliceDurationFrames;
-            mBufferOffset = 0;
-        }
-        else
-        {
-            mDurationInFrames   =   inEvent.eventValues.ramp.durationInFrames;
-            mBufferOffset       =   inEvent.eventValues.ramp.startBufferOffset - inSliceOffsetInBuffer; // shift over for this slice
-            mValue1             =   inEvent.eventValues.ramp.startValue;
-            mValue2             =   inEvent.eventValues.ramp.endValue;
-        }
-    };
-
-
-
-/*! @method GetEventType */
-    AUParameterEventType        GetEventType() const {return mEventType;};
-
-/*! @method GetValue */
-    AudioUnitParameterValue     GetValue() const {return mValue1;}; // only valid if immediate event type
-/*! @method GetEndValue */
-    AudioUnitParameterValue     GetEndValue() const {return mValue2;};  // only valid if immediate event type
-/*! @method SetValue */
-    void                        SetValue(AudioUnitParameterValue inValue)
-                                {
-                                    mEventType = kParameterEvent_Immediate;
-                                    mValue1 = inValue;
-                                    mValue2 = inValue;
-                                }
-
-    // interpolates the start and end values corresponding to the current processing slice
-    // most ramp parameter implementations will want to use this method
-    // the start value will correspond to the start of the slice
-    // the end value will correspond to the end of the slice
-/*! @method GetRampSliceStartEnd */
-    void                    GetRampSliceStartEnd(   AudioUnitParameterValue &   outStartValue,
-                                                    AudioUnitParameterValue &   outEndValue,
-                                                    AudioUnitParameterValue &   outValuePerFrameDelta )
-    {
-        if (mEventType == kParameterEvent_Ramped) {
-            outValuePerFrameDelta = (mValue2 - mValue1) / mDurationInFrames;
-
-            outStartValue = mValue1 + outValuePerFrameDelta * (-mBufferOffset); // corresponds to frame 0 of this slice
-            outEndValue = outStartValue +  outValuePerFrameDelta * mSliceDurationFrames;
-        } else {
-            outValuePerFrameDelta = 0;
-            outStartValue = outEndValue = mValue1;
-        }
-    };
-
-    // Some ramp parameter implementations will want to interpret the ramp using their
-    // own interpolation method (perhaps non-linear)
-    // This method gives the raw ramp information, relative to this processing slice
-    // for the client to interpret as desired
-/*! @method GetRampInfo */
-    void                    GetRampInfo(    SInt32  &                   outBufferOffset,
-                                            UInt32  &                   outDurationInFrames,
-                                            AudioUnitParameterValue &   outStartValue,
-                                            AudioUnitParameterValue &   outEndValue )
-    {
-        outBufferOffset = mBufferOffset;
-        outDurationInFrames = mDurationInFrames;
-        outStartValue = mValue1;
-        outEndValue = mValue2;
-    };
-
-#if DEBUG
-    void                    Print()
-    {
-        printf("ParameterEvent @ %p\n", this);
-        printf("    mEventType = %d\n", (int)mEventType);
-        printf("    mBufferOffset = %d\n", (int)mBufferOffset);
-        printf("    mDurationInFrames = %d\n", (int)mDurationInFrames);
-        printf("    mSliceDurationFrames = %d\n", (int)mSliceDurationFrames);
-        printf("    mValue1 = %.5f\n", mValue1);
-        printf("    mValue2 = %.5f\n", mValue2);
-    }
-#endif
-
-private:
-    AUParameterEventType        mEventType;
-
-    SInt32                      mBufferOffset;      // ramp start offset relative to start of this slice (may be negative)
-    UInt32                      mDurationInFrames;  // total duration of ramp parameter
-    AudioUnitParameterValue     mValue1;                // value if immediate : startValue if ramp
-    AudioUnitParameterValue     mValue2;                // endValue (only used for ramp)
-
-    UInt32                  mSliceDurationFrames;   // duration of this processing slice
-};
-
-
-
-// ____________________________________________________________________________
-//
-class AUIOElement;
-
-/*! @class AUElement */
-class AUElement {
-public:
-/*! @ctor AUElement */
-                                AUElement(AUBase *audioUnit) : mAudioUnit(audioUnit),
-                                    mUseIndexedParameters(false), mElementName(0) { }
-
-/*! @dtor ~AUElement */
-    virtual                     ~AUElement() { if (mElementName) CFRelease (mElementName); }
-
-/*! @method GetNumberOfParameters */
-    virtual UInt32              GetNumberOfParameters()
-    {
-        if(mUseIndexedParameters) return static_cast<UInt32>(mIndexedParameters.size()); else return static_cast<UInt32>(mParameters.size());
-    }
-/*! @method GetParameterList */
-    virtual void                GetParameterList(AudioUnitParameterID *outList);
-/*! @method HasParameterID */
-    bool                        HasParameterID (AudioUnitParameterID paramID) const;
-
-/*! @method GetParameter */
-    AudioUnitParameterValue     GetParameter(AudioUnitParameterID paramID);
-/*! @method SetParameter */
-    void                        SetParameter(AudioUnitParameterID paramID, AudioUnitParameterValue value, bool okWhenInitialized = false);
-    // Only set okWhenInitialized to true when you know the outside world cannot access this element. Otherwise the parameter map could get corrupted.
-
-    // interpolates the start and end values corresponding to the current processing slice
-    // most ramp parameter implementations will want to use this method
-/*! @method GetRampSliceStartEnd */
-    void                        GetRampSliceStartEnd(   AudioUnitParameterID    paramID,
-                                                    AudioUnitParameterValue &   outStartValue,
-                                                    AudioUnitParameterValue &   outEndValue,
-                                                    AudioUnitParameterValue &   outValuePerFrameDelta );
-
-/*! @method GetEndValue */
-    AudioUnitParameterValue     GetEndValue(    AudioUnitParameterID        paramID);
-
-/*! @method SetRampParameter */
-    void                        SetScheduledEvent(  AudioUnitParameterID            paramID,
-                                                    const AudioUnitParameterEvent   &inEvent,
-                                                    UInt32                          inSliceOffsetInBuffer,
-                                                    UInt32                          inSliceDurationFrames,
-                                                    bool                            okWhenInitialized = false );
-    // Only set okWhenInitialized to true when you know the outside world cannot access this element. Otherwise the parameter map could get corrupted.
-
-
-/*! @method GetAudioUnit */
-    AUBase *                    GetAudioUnit() const { return mAudioUnit; };
-
-/*! @method SaveState */
-    void                        SaveState(AudioUnitScope scope, CFMutableDataRef data);
-/*! @method RestoreState */
-    const UInt8 *               RestoreState(const UInt8 *state);
-/*! @method GetName */
-    CFStringRef                 GetName () const { return mElementName; }
-/*! @method SetName */
-    void                        SetName (CFStringRef inName);
-/*! @method HasName */
-    bool                        HasName () const { return mElementName != 0; }
-/*! @method UseIndexedParameters */
-    virtual void                UseIndexedParameters(int inNumberOfParameters);
-
-/*! @method AsIOElement*/
-    virtual AUIOElement*        AsIOElement () { return NULL; }
-
-protected:
-    inline ParameterMapEvent&   GetParamEvent(AudioUnitParameterID paramID);
-
-private:
-    typedef std::map<AudioUnitParameterID, ParameterMapEvent, std::less<AudioUnitParameterID> > ParameterMap;
-
-/*! @var mAudioUnit */
-    AUBase *                        mAudioUnit;
-/*! @var mParameters */
-    ParameterMap                    mParameters;
-
-/*! @var mUseIndexedParameters */
-    bool                            mUseIndexedParameters;
-/*! @var mIndexedParameters */
-    std::vector<ParameterMapEvent>  mIndexedParameters;
-
-/*! @var mElementName */
-    CFStringRef                     mElementName;
-};
-
-
-
-// ____________________________________________________________________________
-//
-/*! @class AUIOElement */
-class AUIOElement : public AUElement {
-public:
-/*! @ctor AUIOElement */
-                                AUIOElement(AUBase *audioUnit);
-
-/*! @method GetStreamFormat */
-    const CAStreamBasicDescription &GetStreamFormat() const { return mStreamFormat; }
-
-/*! @method SetStreamFormat */
-    virtual OSStatus            SetStreamFormat(const CAStreamBasicDescription &desc);
-
-/*! @method AllocateBuffer */
-    virtual void                AllocateBuffer(UInt32 inFramesToAllocate = 0);
-/*! @method DeallocateBuffer */
-    void                        DeallocateBuffer();
-/*! @method NeedsBufferSpace */
-    virtual bool                NeedsBufferSpace() const = 0;
-
-/*! @method SetWillAllocateBuffer */
-    void                        SetWillAllocateBuffer(bool inFlag) {
-                                    mWillAllocate = inFlag;
-                                }
-/*! @method WillAllocateBuffer */
-    bool                        WillAllocateBuffer() const {
-                                    return mWillAllocate;
-                                }
-
-/*! @method UseExternalBuffer */
-    void                        UseExternalBuffer(const AudioUnitExternalBuffer &buf) {
-                                    mIOBuffer.UseExternalBuffer(mStreamFormat, buf);
-                                }
-/*! @method PrepareBuffer */
-    AudioBufferList &           PrepareBuffer(UInt32 nFrames) {
-                                    if (mWillAllocate)
-                                        return mIOBuffer.PrepareBuffer(mStreamFormat, nFrames);
-                                    throw OSStatus(kAudioUnitErr_InvalidPropertyValue);
-                                }
-/*! @method PrepareNullBuffer */
-    AudioBufferList &           PrepareNullBuffer(UInt32 nFrames) {
-                                    return mIOBuffer.PrepareNullBuffer(mStreamFormat, nFrames);
-                                }
-/*! @method SetBufferList */
-    AudioBufferList &           SetBufferList(AudioBufferList &abl) { return mIOBuffer.SetBufferList(abl); }
-/*! @method SetBuffer */
-    void                        SetBuffer(UInt32 index, AudioBuffer &ab) { mIOBuffer.SetBuffer(index, ab); }
-/*! @method InvalidateBufferList */
-    void                        InvalidateBufferList() { mIOBuffer.InvalidateBufferList(); }
-
-/*! @method GetBufferList */
-    AudioBufferList &           GetBufferList() const { return mIOBuffer.GetBufferList(); }
-
-/*! @method GetChannelData */
-    CA_CANONICAL_DEPRECATED
-    AudioUnitSampleType *       GetChannelData(int ch) const {
-                                    if (mStreamFormat.IsInterleaved())
-                                        return static_cast<AudioUnitSampleType *>(mIOBuffer.GetBufferList().mBuffers[0].mData) + ch;
-                                    else
-                                        return static_cast<AudioUnitSampleType *>(mIOBuffer.GetBufferList().mBuffers[ch].mData);
-                                }
-    Float32 *                   GetFloat32ChannelData(int ch) const {
-                                    if (mStreamFormat.IsInterleaved())
-                                        return static_cast<Float32 *>(mIOBuffer.GetBufferList().mBuffers[0].mData) + ch;
-                                    else
-                                        return static_cast<Float32 *>(mIOBuffer.GetBufferList().mBuffers[ch].mData);
-                                }
-    SInt32 *                    GetSInt32ChannelData(int ch) const {
-                                    if (mStreamFormat.IsInterleaved())
-                                        return static_cast<SInt32 *>(mIOBuffer.GetBufferList().mBuffers[0].mData) + ch;
-                                    else
-                                        return static_cast<SInt32 *>(mIOBuffer.GetBufferList().mBuffers[ch].mData);
-                                }
-    SInt16 *                    GetInt16ChannelData(int ch) const {
-                                    if (mStreamFormat.IsInterleaved())
-                                        return static_cast<SInt16 *>(mIOBuffer.GetBufferList().mBuffers[0].mData) + ch;
-                                    else
-                                        return static_cast<SInt16 *>(mIOBuffer.GetBufferList().mBuffers[ch].mData);
-                                }
-
-/*! @method CopyBufferListTo */
-    void                        CopyBufferListTo(AudioBufferList &abl) const {
-                                    mIOBuffer.CopyBufferListTo(abl);
-                                }
-/*! @method CopyBufferContentsTo */
-    void                        CopyBufferContentsTo(AudioBufferList &abl) const {
-                                    mIOBuffer.CopyBufferContentsTo(abl);
-                                }
-
-/*  UInt32                      BytesToFrames(UInt32 nBytes) { return nBytes / mStreamFormat.mBytesPerFrame; }
-    UInt32                      BytesToFrames(AudioBufferList &abl) {
-                                    return BytesToFrames(abl.mBuffers[0].mDataByteSize);
-                                }
-    UInt32                      FramesToBytes(UInt32 nFrames) { return nFrames * mStreamFormat.mBytesPerFrame; }*/
-
-/*! @method IsInterleaved */
-    bool                        IsInterleaved() const { return mStreamFormat.IsInterleaved(); }
-/*! @method NumberChannels */
-    UInt32                      NumberChannels() const { return mStreamFormat.NumberChannels(); }
-/*! @method NumberInterleavedChannels */
-    UInt32                      NumberInterleavedChannels() const { return mStreamFormat.NumberInterleavedChannels(); }
-
-/*! @method GetChannelMapTags */
-    virtual UInt32              GetChannelLayoutTags (AudioChannelLayoutTag *outLayoutTagsPtr);
-
-/*! @method GetAudioChannelLayout */
-    virtual UInt32              GetAudioChannelLayout (AudioChannelLayout   *outMapPtr, Boolean &outWritable);
-
-/*! @method SetAudioChannelLayout */
-    virtual OSStatus            SetAudioChannelLayout (const AudioChannelLayout &inData);
-
-/*! @method RemoveAudioChannelLayout */
-    virtual OSStatus            RemoveAudioChannelLayout ();
-
-/*! @method AsIOElement*/
-    virtual AUIOElement*        AsIOElement () { return this; }
-
-protected:
-/*! @var mStreamFormat */
-    CAStreamBasicDescription    mStreamFormat;
-/*! @var mIOBuffer */
-    AUBufferList                mIOBuffer;  // for input: input proc buffer, only allocated when needed
-                                            // for output: output cache, usually allocated early on
-/*! @var mWillAllocate */
-    bool                        mWillAllocate;
-};
-
-// ____________________________________________________________________________
-//
-// AUScopeDelegates are a way to get virtual scopes.
-/*! @class AUScopeDelegate */
-class AUScopeDelegate {
-public:
-/*! @ctor AUScopeDelegate */
-                    AUScopeDelegate() : mCreator(NULL), mScope(0) { }
-/*! @dtor ~AUScopeDelegate */
-                    virtual ~AUScopeDelegate() {}
-
-/*! @method Initialize */
-    void                    Initialize( AUBase *creator,
-                                        AudioUnitScope scope,
-                                        UInt32 numElements)
-    {
-        mCreator = creator;
-        mScope = scope;
-        SetNumberOfElements(numElements);
-    }
-
-/*! @method SetNumberOfElements */
-    virtual void            SetNumberOfElements(UInt32 numElements) = 0;
-
-/*! @method GetNumberOfElements */
-    virtual UInt32          GetNumberOfElements()    = 0;
-
-/*! @method GetElement */
-    virtual AUElement *     GetElement(UInt32 elementIndex) = 0;
-
-    AUBase *            GetCreator() const { return mCreator; }
-    AudioUnitScope      GetScope() const { return mScope; }
-
-
-private:
-/*! @var mCreator */
-    AUBase *                    mCreator;
-/*! @var mScope */
-    AudioUnitScope              mScope;
-};
-
-
-
-// ____________________________________________________________________________
-//
-/*! @class AUScope */
-class AUScope {
-public:
-/*! @ctor AUScope */
-                    AUScope() : mCreator(NULL), mScope(0), mDelegate(0) { }
-/*! @dtor ~AUScope */
-                    ~AUScope();
-
-/*! @method Initialize */
-    void            Initialize(AUBase *creator,
-                                AudioUnitScope scope,
-                                UInt32 numElements)
-    {
-        mCreator = creator;
-        mScope = scope;
-
-        if (mDelegate)
-            return mDelegate->Initialize(creator, scope, numElements);
-
-        SetNumberOfElements(numElements);
-    }
-
-/*! @method SetNumberOfElements */
-    void            SetNumberOfElements(UInt32 numElements);
-
-/*! @method GetNumberOfElements */
-    UInt32          GetNumberOfElements()   const
-    {
-        if (mDelegate)
-            return mDelegate->GetNumberOfElements();
-
-        return static_cast<UInt32>(mElements.size());
-    }
-
-/*! @method GetElement */
-    AUElement *     GetElement(UInt32 elementIndex) const
-    {
-        if (mDelegate)
-            return mDelegate->GetElement(elementIndex);
-
-        ElementVector::const_iterator i = mElements.begin() + elementIndex;
-            // catch passing -1 in as the elementIndex - causes a wrap around
-        return (i >= mElements.end() || i < mElements.begin()) ? NULL : *i;
-    }
-
-/*! @method SafeGetElement */
-    AUElement *     SafeGetElement(UInt32 elementIndex)
-    {
-        AUElement *element = GetElement(elementIndex);
-        if (element == NULL)
-            COMPONENT_THROW(kAudioUnitErr_InvalidElement);
-        return element;
-    }
-
-/*! @method GetIOElement */
-    AUIOElement *   GetIOElement(UInt32 elementIndex) const
-    {
-        AUElement *element = GetElement(elementIndex);
-        AUIOElement *ioel = element ? element->AsIOElement () : NULL;
-        if (!ioel)
-            COMPONENT_THROW (kAudioUnitErr_InvalidElement);
-        return ioel;
-    }
-
-/*! @method HasElementWithName */
-    bool            HasElementWithName () const;
-
-/*! @method AddElementNamesToDict */
-    void            AddElementNamesToDict (CFMutableDictionaryRef & inNameDict);
-
-    bool            RestoreElementNames (CFDictionaryRef& inNameDict);
-
-    AudioUnitScope      GetScope() const { return mScope; }
-
-    void SetDelegate(AUScopeDelegate* inDelegate) { mDelegate = inDelegate; }
-
-/*! @method SaveState */
-    void            SaveState(CFMutableDataRef data);
-
-/*! @method RestoreState */
-    const UInt8 *   RestoreState(const UInt8 *state);
-
-private:
-    typedef std::vector<AUElement *> ElementVector;
-/*! @var mCreator */
-    AUBase *                    mCreator;
-/*! @var mScope */
-    AudioUnitScope              mScope;
-/*! @var mElements */
-    ElementVector               mElements;
-/*! @var mDelegate */
-    AUScopeDelegate *           mDelegate;
-};
-
-
-
-#endif // __AUScopeElement_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/ComponentBase.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/ComponentBase.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/ComponentBase.cpp
+++ /dev/null
@@ -1,332 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#include "ComponentBase.h"
-#include "CAXException.h"
-
-#if TARGET_OS_MAC
-pthread_mutex_t ComponentInitLocker::sComponentOpenMutex = PTHREAD_MUTEX_INITIALIZER;
-pthread_once_t ComponentInitLocker::sOnce = PTHREAD_ONCE_INIT;
-
-void ComponentInitLocker::InitComponentInitLocker()
-{
-    // have to do this because OS X lacks PTHREAD_MUTEX_RECURSIVE_INITIALIZER_NP
-    pthread_mutexattr_t attr;
-    pthread_mutexattr_init(&attr);
-    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
-    pthread_mutex_init(&sComponentOpenMutex, &attr);
-    pthread_mutexattr_destroy(&attr);
-}
-
-#elif TARGET_OS_WIN32
-CAGuard ComponentInitLocker::sComponentOpenGuard("sComponentOpenGuard");
-#endif
-
-ComponentBase::EInstanceType ComponentBase::sNewInstanceType;
-
-static OSStatus CB_GetComponentDescription (const AudioComponentInstance inInstance, AudioComponentDescription * outDesc);
-#if !CA_USE_AUDIO_PLUGIN_ONLY && !TARGET_OS_WIN32
-    static OSStatus CMgr_GetComponentDescription (const AudioComponentInstance inInstance, AudioComponentDescription * outDesc);
-#endif
-
-ComponentBase::ComponentBase(AudioComponentInstance inInstance)
-    : mComponentInstance(inInstance),
-      mInstanceType(sNewInstanceType)
-{
-    GetComponentDescription();
-}
-
-ComponentBase::~ComponentBase()
-{
-}
-
-void            ComponentBase::PostConstructor()
-{
-}
-
-void            ComponentBase::PreDestructor()
-{
-}
-
-#define ACPI    ((AudioComponentPlugInInstance *)self)
-#define ACImp   ((ComponentBase *)&ACPI->mInstanceStorage)
-
-OSStatus ComponentBase::AP_Open(void *self, AudioUnit compInstance)
-{
-    OSStatus result = noErr;
-    try {
-        ComponentInitLocker lock;
-
-        ComponentBase::sNewInstanceType = ComponentBase::kAudioComponentInstance;
-        ComponentBase *cb = (ComponentBase *)(*ACPI->mConstruct)(&ACPI->mInstanceStorage, compInstance);
-        cb->PostConstructor();  // allows base class to do additional initialization
-        // once the derived class is fully constructed
-        result = noErr;
-    }
-    COMPONENT_CATCH
-    if (result)
-        delete ACPI;
-    return result;
-}
-
-OSStatus ComponentBase::AP_Close(void *self)
-{
-    OSStatus result = noErr;
-    try {
-        if (ACImp) {
-            ACImp->PreDestructor();
-            (*ACPI->mDestruct)(&ACPI->mInstanceStorage);
-            free(self);
-        }
-    }
-    COMPONENT_CATCH
-    return result;
-}
-
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-OSStatus        ComponentBase::Version()
-{
-    return 0x00000001;
-}
-
-OSStatus        ComponentBase::ComponentEntryDispatch(ComponentParameters *p, ComponentBase *This)
-{
-    if (This == NULL) return kAudio_ParamError;
-
-    OSStatus result = noErr;
-
-    switch (p->what) {
-    case kComponentCloseSelect:
-        This->PreDestructor();
-        delete This;
-        break;
-
-    case kComponentVersionSelect:
-        result = This->Version();
-        break;
-
-    case kComponentCanDoSelect:
-        switch (GetSelectorForCanDo(p)) {
-        case kComponentOpenSelect:
-        case kComponentCloseSelect:
-        case kComponentVersionSelect:
-        case kComponentCanDoSelect:
-            return 1;
-        default:
-            return 0;
-        }
-
-    default:
-        result = badComponentSelector;
-        break;
-    }
-    return result;
-}
-
-SInt16      ComponentBase::GetSelectorForCanDo(ComponentParameters *params)
-{
-    if (params->what != kComponentCanDoSelect) return 0;
-
-    #if TARGET_CPU_X86
-        SInt16 sel = params->params[0];
-    #elif TARGET_CPU_X86_64
-        SInt16 sel = params->params[1];
-    #elif TARGET_CPU_PPC
-        SInt16 sel = (params->params[0] >> 16);
-    #else
-        SInt16 sel = params->params[0];
-    #endif
-
-    return sel;
-/*
-        printf ("flags:%d, paramSize: %d, what: %d\n\t", params->flags, params->paramSize, params->what);
-        for (int i = 0; i < params->paramSize; ++i) {
-            printf ("[%d]:%d(0x%x), ", i, params->params[i], params->params[i]);
-        }
-        printf("\n\tsel:%d\n", sel);
-*/
-}
-
-#endif
-
-#if CA_DO_NOT_USE_AUDIO_COMPONENT
-static OSStatus ComponentBase_GetComponentDescription (const AudioComponentInstance & inInstance, AudioComponentDescription &outDesc);
-#endif
-
-AudioComponentDescription ComponentBase::GetComponentDescription() const
-{
-    AudioComponentDescription desc;
-    OSStatus result = 1;
-
-    if (IsPluginObject()) {
-        ca_require_noerr(result = CB_GetComponentDescription (mComponentInstance, &desc), home);
-    }
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-    else {
-        ca_require_noerr(result = CMgr_GetComponentDescription (mComponentInstance, &desc), home);
-    }
-#endif
-
-home:
-    if (result)
-        memset (&desc, 0, sizeof(AudioComponentDescription));
-
-    return desc;
-}
-
-#if CA_USE_AUDIO_PLUGIN_ONLY
-// everything we need is there and we should be linking against it
-static OSStatus CB_GetComponentDescription (const AudioComponentInstance inInstance, AudioComponentDescription * outDesc)
-{
-    AudioComponent comp = AudioComponentInstanceGetComponent(inInstance);
-    if (comp)
-        return AudioComponentGetDescription(comp, outDesc);
-
-    return kAudio_ParamError;
-}
-
-#elif !TARGET_OS_WIN32
-// these are the direct dependencies on ComponentMgr calls that an AU
-// that is a component mgr is dependent on
-
-// these are dynamically loaded so that these calls will work on Leopard
-#include <dlfcn.h>
-
-static OSStatus CB_GetComponentDescription (const AudioComponentInstance inInstance, AudioComponentDescription * outDesc)
-{
-    typedef AudioComponent (*AudioComponentInstanceGetComponentProc) (AudioComponentInstance);
-    static AudioComponentInstanceGetComponentProc aciGCProc = NULL;
-
-    typedef OSStatus (*AudioComponentGetDescriptionProc)(AudioComponent, AudioComponentDescription *);
-    static AudioComponentGetDescriptionProc acGDProc = NULL;
-
-    static int doneInit = 0;
-    if (doneInit == 0) {
-        doneInit = 1;
-        void* theImage = dlopen("/System/Library/Frameworks/AudioUnit.framework/AudioUnit", RTLD_LAZY);
-        if (theImage != NULL)
-        {
-            aciGCProc = (AudioComponentInstanceGetComponentProc)dlsym (theImage, "AudioComponentInstanceGetComponent");
-            if (aciGCProc) {
-                acGDProc = (AudioComponentGetDescriptionProc)dlsym (theImage, "AudioComponentGetDescription");
-            }
-        }
-    }
-
-    OSStatus result = kAudio_UnimplementedError;
-    if (acGDProc && aciGCProc) {
-        AudioComponent comp = (*aciGCProc)(inInstance);
-        if (comp)
-            result = (*acGDProc)(comp, outDesc);
-    }
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-    else {
-        result = CMgr_GetComponentDescription (inInstance, outDesc);
-    }
-#endif
-
-    return result;
-}
-
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-// these are the direct dependencies on ComponentMgr calls that an AU
-// that is a component mgr is dependent on
-
-// these are dynamically loaded
-
-#include <CoreServices/CoreServices.h>
-#include <AudioUnit/AudioUnit.h>
-#include "CAXException.h"
-#include "ComponentBase.h"
-
-//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-// Component Manager
-// Used for fast dispatch with audio units
-typedef Handle (*GetComponentInstanceStorageProc)(ComponentInstance aComponentInstance);
-static GetComponentInstanceStorageProc sGetComponentInstanceStorageProc = NULL;
-
-typedef OSErr (*GetComponentInfoProc)(Component, ComponentDescription *, void*, void*, void*);
-static GetComponentInfoProc sGetComponentInfoProc = NULL;
-
-typedef void (*SetComponentInstanceStorageProc)(ComponentInstance, Handle);
-static SetComponentInstanceStorageProc sSetComponentInstanceStorageProc = NULL;
-
-//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-static void CSInitOnce(void* /*unused*/)
-{
-    void *theImage = dlopen("/System/Library/Frameworks/CoreServices.framework/CoreServices", RTLD_LAZY);
-    if (!theImage) return;
-
-    sGetComponentInstanceStorageProc = (GetComponentInstanceStorageProc) dlsym(theImage, "GetComponentInstanceStorage");
-    sGetComponentInfoProc = (GetComponentInfoProc)dlsym (theImage, "GetComponentInfo");
-    sSetComponentInstanceStorageProc = (SetComponentInstanceStorageProc) dlsym(theImage, "SetComponentInstanceStorage");
-}
-
-#if TARGET_OS_MAC
-
-#include <dispatch/dispatch.h>
-
-static dispatch_once_t sCSInitOnce = 0;
-
-static void CSInit ()
-{
-    dispatch_once_f(&sCSInitOnce, NULL, CSInitOnce);
-}
-
-#else
-
-static void CSInit ()
-{
-    static int sDoCSLoad = 1;
-    if (sDoCSLoad) {
-        sDoCSLoad = 0;
-        CSInitOnce(NULL);
-    }
-}
-
-#endif
-
-OSStatus CMgr_GetComponentDescription (const AudioComponentInstance inInstance, AudioComponentDescription * outDesc)
-{
-    CSInit();
-    if (sGetComponentInfoProc)
-        return (*sGetComponentInfoProc)((Component)inInstance, (ComponentDescription*)outDesc, NULL, NULL, NULL);
-    return kAudio_UnimplementedError;
-}
-
-Handle CMgr_GetComponentInstanceStorage(ComponentInstance aComponentInstance)
-{
-    CSInit();
-    if (sGetComponentInstanceStorageProc)
-        return (*sGetComponentInstanceStorageProc)(aComponentInstance);
-    return NULL;
-}
-
-void CMgr_SetComponentInstanceStorage(ComponentInstance aComponentInstance, Handle theStorage)
-{
-    CSInit();
-    if (sSetComponentInstanceStorageProc)
-        (*sSetComponentInstanceStorageProc)(aComponentInstance, theStorage);
-}
-#endif // !CA_USE_AUDIO_PLUGIN_ONLY
-
-#else
-//#include "ComponentManagerDependenciesWin.h"
-// everything we need is there and we should be linking against it
-static OSStatus CB_GetComponentDescription (const AudioComponentInstance inInstance, AudioComponentDescription * outDesc)
-{
-    AudioComponent comp = AudioComponentInstanceGetComponent(inInstance);
-    if (comp)
-        return AudioComponentGetDescription(comp, outDesc);
-
-    return kAudio_ParamError;
-}
-
-#endif
-
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/ComponentBase.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/ComponentBase.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/ComponentBase.h
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#ifndef __ComponentBase_h__
-#define __ComponentBase_h__
-
-#include <new>
-#include "CADebugMacros.h"
-#include "CAXException.h"
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreAudio/CoreAudioTypes.h>
-    #include <AudioUnit/AudioUnit.h>
-
-    #if !CA_USE_AUDIO_PLUGIN_ONLY
-        #include <CoreServices/../Frameworks/CarbonCore.framework/Headers/Components.h>
-
-        #if (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_5)
-            #define AudioComponentInstance          ComponentInstance
-            #define AudioComponentDescription       ComponentDescription
-            #define AudioComponent                  Component
-        #endif
-        Handle CMgr_GetComponentInstanceStorage(ComponentInstance aComponentInstance);
-        void CMgr_SetComponentInstanceStorage(ComponentInstance aComponentInstance, Handle theStorage);
-    #endif
-
-    #if MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_4
-        typedef Float32 AudioUnitParameterValue;
-    #endif
-    #if COREAUDIOTYPES_VERSION < 1051
-        typedef Float32 AudioUnitSampleType;
-    #endif
-
-    #if !TARGET_OS_WIN32
-        #include <pthread.h>
-    #endif
-
-    #if TARGET_OS_WIN32
-        #include "CAGuard.h"
-    #endif
-#else
-    #include "CoreAudioTypes.h"
-    #if !CA_USE_AUDIO_PLUGIN_ONLY
-        #include "ComponentManagerDependenciesWin.h"
-    #endif
-    #include "AudioUnit.h"
-    #include "CAGuard.h"
-#endif
-
-#ifndef COMPONENT_THROW
-    #if VERBOSE_COMPONENT_THROW
-        #define COMPONENT_THROW(throw_err) \
-            do { DebugMessage(#throw_err); throw static_cast<OSStatus>(throw_err); } while (0)
-    #else
-        #define COMPONENT_THROW(throw_err) \
-            throw static_cast<OSStatus>(throw_err)
-    #endif
-#endif
-
-#define COMPONENT_CATCH \
-    catch (const CAXException &ex) { result = ex.mError; } \
-    catch (std::bad_alloc &) { result = kAudio_MemFullError; } \
-    catch (OSStatus catch_err) { result = catch_err; } \
-    catch (OSErr catch_err) { result = catch_err; } \
-    catch (...) { result = -1; }
-
-/*! @class ComponentBase */
-class ComponentBase {
-public:
-    // classic MacErrors
-    enum { noErr = 0};
-
-    /*! @ctor ComponentBase */
-                ComponentBase(AudioComponentInstance inInstance);
-
-    /*! @dtor ~ComponentBase */
-    virtual     ~ComponentBase();
-
-    /*! @method PostConstructor */
-    virtual void            PostConstructor();
-
-    /*! @method PreDestructor */
-    virtual void            PreDestructor();
-
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-    /*! @method Version */
-    virtual OSStatus        Version();
-
-    /*! @method ComponentEntryDispatch */
-    static OSStatus     ComponentEntryDispatch(ComponentParameters *p, ComponentBase *This);
-
-    /*! GetSelectorForCanDo */
-    static SInt16       GetSelectorForCanDo(ComponentParameters *params);
-#endif
-
-    /*! @method GetComponentInstance */
-    AudioComponentInstance      GetComponentInstance() const { return mComponentInstance; }
-
-    /*! @method GetComponentDescription */
-    AudioComponentDescription   GetComponentDescription() const;
-
-    // This global variable is so that new instances know how they were instantiated: via the Component Manager,
-    // or as AudioComponents. It's ugly, but preferable to altering the constructor of every class in the hierarchy.
-    // It's safe because construction is protected by ComponentInitLocker.
-    enum EInstanceType { kComponentMgrInstance, kAudioComponentInstance };
-    static EInstanceType sNewInstanceType;
-
-    /*! @method IsPluginObject */
-    bool            IsPluginObject () const { return mInstanceType == kAudioComponentInstance; }
-    /*! @method IsCMgrObject */
-    bool            IsCMgrObject () const { return mInstanceType == kComponentMgrInstance; }
-
-    /*! @method AP_Open */
-    static OSStatus AP_Open(void *self, AudioUnit compInstance);
-
-    /*! @method AP_Close */
-    static OSStatus AP_Close(void *self);
-
-protected:
-    /*! @var mComponentInstance */
-    AudioComponentInstance      mComponentInstance;
-    EInstanceType               mInstanceType;
-};
-
-class ComponentInitLocker
-{
-#if TARGET_OS_MAC
-public:
-    ComponentInitLocker()
-    {
-        pthread_once(&sOnce, InitComponentInitLocker);
-        pthread_mutex_lock(&sComponentOpenMutex);
-        mPreviousNewInstanceType = ComponentBase::sNewInstanceType;
-    }
-    ~ComponentInitLocker()
-    {
-        ComponentBase::sNewInstanceType = mPreviousNewInstanceType;
-        pthread_mutex_unlock(&sComponentOpenMutex);
-    }
-
-    // There are situations (11844772) where we need to be able to release the lock early.
-    class Unlocker {
-    public:
-        Unlocker()
-        {
-            pthread_mutex_unlock(&sComponentOpenMutex);
-        }
-        ~Unlocker()
-        {
-            pthread_mutex_lock(&sComponentOpenMutex);
-        }
-    };
-
-private:
-    static pthread_mutex_t sComponentOpenMutex;
-    static pthread_once_t sOnce;
-    static void InitComponentInitLocker();
-
-#elif TARGET_OS_WIN32
-public:
-    bool sNeedsUnlocking;
-    ComponentInitLocker() { sNeedsUnlocking = sComponentOpenGuard.Lock(); }
-    ~ComponentInitLocker() { if(sNeedsUnlocking) { sComponentOpenGuard.Unlock(); } }
-private:
-    static CAGuard  sComponentOpenGuard;
-#endif
-
-private:
-    ComponentBase::EInstanceType    mPreviousNewInstanceType;
-};
-
-/*! @class AudioComponentPlugInInstance */
-struct AudioComponentPlugInInstance {
-    AudioComponentPlugInInterface       mPlugInInterface;
-    void *                              (*mConstruct)(void *memory, AudioComponentInstance ci);
-    void                                (*mDestruct)(void *memory);
-    void *                              mPad[2];                // pad to a 16-byte boundary (in either 32 or 64 bit mode)
-    UInt32                              mInstanceStorage;       // the ACI implementation object is constructed into this memory
-                                                                // this member is just a placeholder. it is aligned to a 16byte boundary
-};
-
-/*! @class APFactory */
-template <class APMethodLookup, class Implementor>
-class APFactory {
-public:
-    static void *Construct(void *memory, AudioComponentInstance compInstance)
-    {
-        return new(memory) Implementor(compInstance);
-    }
-
-    static void Destruct(void *memory)
-    {
-        ((Implementor *)memory)->~Implementor();
-    }
-
-    // This is the AudioComponentFactoryFunction. It returns an AudioComponentPlugInInstance.
-    // The actual implementation object is not created until Open().
-    static AudioComponentPlugInInterface *Factory(const AudioComponentDescription * /* inDesc */)
-    {
-        AudioComponentPlugInInstance *acpi =
-                (AudioComponentPlugInInstance *)malloc( offsetof(AudioComponentPlugInInstance, mInstanceStorage) + sizeof(Implementor) );
-        acpi->mPlugInInterface.Open = ComponentBase::AP_Open;
-        acpi->mPlugInInterface.Close = ComponentBase::AP_Close;
-        acpi->mPlugInInterface.Lookup = APMethodLookup::Lookup;
-        acpi->mPlugInInterface.reserved = NULL;
-        acpi->mConstruct = Construct;
-        acpi->mDestruct = Destruct;
-        acpi->mPad[0] = NULL;
-        acpi->mPad[1] = NULL;
-        return (AudioComponentPlugInInterface*)acpi;
-    }
-
-    // This is for runtime registration (not for plug-ins loaded from bundles).
-    static AudioComponent Register(UInt32 type, UInt32 subtype, UInt32 manuf, CFStringRef name, UInt32 vers, UInt32 flags=0)
-    {
-        AudioComponentDescription desc = { type, subtype, manuf, flags, 0 };
-        return AudioComponentRegister(&desc, name, vers, Factory);
-    }
-};
-
-#if !CA_USE_AUDIO_PLUGIN_ONLY
-/*! @class ComponentEntryPoint
- *  @discussion This is only used for a component manager version
-*/
-template <class Class>
-class ComponentEntryPoint {
-public:
-    /*! @method Dispatch */
-    static OSStatus Dispatch(ComponentParameters *params, Class *obj)
-    {
-        OSStatus result = noErr;
-
-        try {
-            if (params->what == kComponentOpenSelect) {
-                // solve a host of initialization thread safety issues.
-                ComponentInitLocker lock;
-
-                ComponentBase::sNewInstanceType = ComponentBase::kComponentMgrInstance;
-                ComponentInstance ci = (ComponentInstance)(params->params[0]);
-                Class *This = new Class((AudioComponentInstance)ci);
-                This->PostConstructor();    // allows base class to do additional initialization
-                                            // once the derived class is fully constructed
-
-                CMgr_SetComponentInstanceStorage(ci, (Handle)This);
-            } else
-                result = Class::ComponentEntryDispatch(params, obj);
-        }
-        COMPONENT_CATCH
-
-        return result;
-    }
-
-    /*! @method Register */
-    static Component Register(OSType compType, OSType subType, OSType manufacturer)
-    {
-        ComponentDescription    description = {compType, subType, manufacturer, 0, 0};
-        Component   component = RegisterComponent(&description, (ComponentRoutineUPP) Dispatch, registerComponentGlobal, NULL, NULL, NULL);
-        if (component != NULL) {
-            SetDefaultComponent(component, defaultComponentAnyFlagsAnyManufacturerAnySubType);
-        }
-        return component;
-    }
-};
-
-// NOTE: The Carbon Component Manager is deprecated in Mountain Lion (10.8).
-// This macro should not be used with new audio components.
-// It is only for backwards compatibility with Lion and Snow Leopard.
-// This macro registers both an Audio Component plugin and a Carbon Component Manager version.
-#define AUDIOCOMPONENT_ENTRY(FactoryType, Class) \
-    extern "C" OSStatus Class##Entry(ComponentParameters *params, Class *obj); \
-    extern "C" OSStatus Class##Entry(ComponentParameters *params, Class *obj) { \
-        return ComponentEntryPoint<Class>::Dispatch(params, obj); \
-    } \
-    extern "C" void * Class##Factory(const AudioComponentDescription *inDesc); \
-    extern "C" void * Class##Factory(const AudioComponentDescription *inDesc) { \
-        return FactoryType<Class>::Factory(inDesc); \
-    }
-    // the only component we still support are the carbon based view components
-    // you should be using this macro now to exclusively register those types
-#define VIEW_COMPONENT_ENTRY(Class) \
-    extern "C" OSStatus Class##Entry(ComponentParameters *params, Class *obj); \
-    extern "C" OSStatus Class##Entry(ComponentParameters *params, Class *obj) { \
-        return ComponentEntryPoint<Class>::Dispatch(params, obj); \
-    }
-
-    /*! @class ComponentRegistrar */
-template <class Class, OSType Type, OSType Subtype, OSType Manufacturer>
-class ComponentRegistrar {
-public:
-    /*! @ctor ComponentRegistrar */
-    ComponentRegistrar() { ComponentEntryPoint<Class>::Register(Type, Subtype, Manufacturer); }
-};
-
-#define COMPONENT_REGISTER(Class,Type,Subtype,Manufacturer) \
-    static ComponentRegistrar<Class, Type, Subtype, Manufacturer>   gRegistrar##Class
-#else
-#define COMPONENT_ENTRY(Class)
-#define COMPONENT_REGISTER(Class)
-// This macro is used to generate the Entry Point for a given Audio Component.
-// You should be using this macro now.
-#define AUDIOCOMPONENT_ENTRY(FactoryType, Class) \
-    extern "C" void * Class##Factory(const AudioComponentDescription *inDesc); \
-    extern "C" void * Class##Factory(const AudioComponentDescription *inDesc) { \
-        return FactoryType<Class>::Factory(inDesc); \
-    }
-
-#endif // !CA_USE_AUDIO_PLUGIN_ONLY
-
-
-#endif // __ComponentBase_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/OtherBases/AUEffectBase.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/OtherBases/AUEffectBase.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/OtherBases/AUEffectBase.cpp
+++ /dev/null
@@ -1,428 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#include "AUEffectBase.h"
-
-/*
-    This class does not deal as well as it should with N-M effects...
-
-    The problem areas are (if the channels don't match):
-        ProcessInPlace if the channels don't match - there will be problems if InputChan != OutputChan
-        Bypass - its just passing the buffers through when not processing them
-
-    This will be fixed in a future update...
-*/
-
-//_____________________________________________________________________________
-//
-AUEffectBase::AUEffectBase( AudioComponentInstance  audioUnit,
-                            bool                    inProcessesInPlace ) :
-    AUBase(audioUnit, 1, 1),        // 1 in bus, 1 out bus
-    mBypassEffect(false),
-    mParamSRDep (false),
-    mProcessesInPlace(inProcessesInPlace),
-    mMainOutput(NULL), mMainInput(NULL)
-#if TARGET_OS_IPHONE
-    , mOnlyOneKernel(false)
-#endif
-{
-}
-
-//_____________________________________________________________________________
-//
-AUEffectBase::~AUEffectBase()
-{
-    Cleanup();
-}
-
-//_____________________________________________________________________________
-//
-void AUEffectBase::Cleanup()
-{
-    for (KernelList::iterator it = mKernelList.begin(); it != mKernelList.end(); ++it)
-        delete *it;
-
-    mKernelList.clear();
-    mMainOutput = NULL;
-    mMainInput = NULL;
-}
-
-
-//_____________________________________________________________________________
-//
-OSStatus AUEffectBase::Initialize()
-{
-        // get our current numChannels for input and output
-    SInt16 auNumInputs = (SInt16) GetInput(0)->GetStreamFormat().mChannelsPerFrame;
-    SInt16 auNumOutputs = (SInt16) GetOutput(0)->GetStreamFormat().mChannelsPerFrame;
-
-        // does the unit publish specific information about channel configurations?
-    const AUChannelInfo *auChannelConfigs = NULL;
-    UInt32 numIOconfigs = SupportedNumChannels(&auChannelConfigs);
-
-    if ((numIOconfigs > 0) && (auChannelConfigs != NULL))
-    {
-        bool foundMatch = false;
-        for (UInt32 i = 0; (i < numIOconfigs) && !foundMatch; ++i)
-        {
-            SInt16 configNumInputs = auChannelConfigs[i].inChannels;
-            SInt16 configNumOutputs = auChannelConfigs[i].outChannels;
-            if ((configNumInputs < 0) && (configNumOutputs < 0))
-            {
-                    // unit accepts any number of channels on input and output
-                if (((configNumInputs == -1) && (configNumOutputs == -2))
-                    || ((configNumInputs == -2) && (configNumOutputs == -1)))
-                {
-                    foundMatch = true;
-                    // unit accepts any number of channels on input and output IFF they are the same number on both scopes
-                }
-                else if (((configNumInputs == -1) && (configNumOutputs == -1)) && (auNumInputs == auNumOutputs))
-                {
-                    foundMatch = true;
-                    // unit has specified a particular number of channels on both scopes
-                }
-                else
-                    continue;
-            }
-            else
-            {
-                    // the -1 case on either scope is saying that the unit doesn't care about the
-                    // number of channels on that scope
-                bool inputMatch = (auNumInputs == configNumInputs) || (configNumInputs == -1);
-                bool outputMatch = (auNumOutputs == configNumOutputs) || (configNumOutputs == -1);
-                if (inputMatch && outputMatch)
-                    foundMatch = true;
-            }
-        }
-        if (!foundMatch)
-            return kAudioUnitErr_FormatNotSupported;
-    }
-    else
-    {
-            // there is no specifically published channel info
-            // so for those kinds of effects, the assumption is that the channels (whatever their number)
-            // should match on both scopes
-        if ((auNumOutputs != auNumInputs) || (auNumOutputs == 0))
-        {
-            return kAudioUnitErr_FormatNotSupported;
-        }
-    }
-
-    MaintainKernels();
-
-    mMainOutput = GetOutput(0);
-    mMainInput = GetInput(0);
-
-    const CAStreamBasicDescription& format = GetStreamFormat(kAudioUnitScope_Output, 0);
-    format.IdentifyCommonPCMFormat(mCommonPCMFormat, NULL);
-    mBytesPerFrame = format.mBytesPerFrame;
-
-    return noErr;
-}
-
-OSStatus            AUEffectBase::Reset(        AudioUnitScope      inScope,
-                                                AudioUnitElement    inElement)
-{
-    for (KernelList::iterator it = mKernelList.begin(); it != mKernelList.end(); ++it) {
-        AUKernelBase *kernel = *it;
-        if (kernel != NULL)
-            kernel->Reset();
-    }
-
-    return AUBase::Reset(inScope, inElement);
-}
-
-OSStatus            AUEffectBase::GetPropertyInfo (AudioUnitPropertyID  inID,
-                                                AudioUnitScope                  inScope,
-                                                AudioUnitElement                inElement,
-                                                UInt32 &                        outDataSize,
-                                                Boolean &                       outWritable)
-{
-    if (inScope == kAudioUnitScope_Global) {
-        switch (inID) {
-            case kAudioUnitProperty_BypassEffect:
-                outWritable = true;
-                outDataSize = sizeof (UInt32);
-                return noErr;
-            case kAudioUnitProperty_InPlaceProcessing:
-                outWritable = true;
-                outDataSize = sizeof (UInt32);
-                return noErr;
-        }
-    }
-    return AUBase::GetPropertyInfo (inID, inScope, inElement, outDataSize, outWritable);
-}
-
-
-OSStatus            AUEffectBase::GetProperty (AudioUnitPropertyID      inID,
-                                      AudioUnitScope                    inScope,
-                                      AudioUnitElement                  inElement,
-                                      void *                            outData)
-{
-    if (inScope == kAudioUnitScope_Global) {
-        switch (inID) {
-            case kAudioUnitProperty_BypassEffect:
-                *((UInt32*)outData) = (IsBypassEffect() ? 1 : 0);
-                return noErr;
-            case kAudioUnitProperty_InPlaceProcessing:
-                *((UInt32*)outData) = (mProcessesInPlace ? 1 : 0);
-                return noErr;
-        }
-    }
-    return AUBase::GetProperty (inID, inScope, inElement, outData);
-}
-
-
-OSStatus            AUEffectBase::SetProperty(      AudioUnitPropertyID inID,
-                                       AudioUnitScope       inScope,
-                                       AudioUnitElement     inElement,
-                                       const void *         inData,
-                                       UInt32               inDataSize)
-{
-    if (inScope == kAudioUnitScope_Global) {
-        switch (inID) {
-            case kAudioUnitProperty_BypassEffect:
-            {
-                if (inDataSize < sizeof(UInt32))
-                    return kAudioUnitErr_InvalidPropertyValue;
-
-                bool tempNewSetting = *((UInt32*)inData) != 0;
-                    // we're changing the state of bypass
-                if (tempNewSetting != IsBypassEffect())
-                {
-                    if (!tempNewSetting && IsBypassEffect() && IsInitialized()) // turning bypass off and we're initialized
-                        Reset(0, 0);
-                    SetBypassEffect (tempNewSetting);
-                }
-                return noErr;
-            }
-            case kAudioUnitProperty_InPlaceProcessing:
-                mProcessesInPlace = (*((UInt32*)inData) != 0);
-                return noErr;
-        }
-    }
-    return AUBase::SetProperty (inID, inScope, inElement, inData, inDataSize);
-}
-
-
-void    AUEffectBase::MaintainKernels()
-{
-#if TARGET_OS_IPHONE
-    UInt32 nKernels = mOnlyOneKernel ? 1 : GetNumberOfChannels();
-#else
-    UInt32 nKernels = GetNumberOfChannels();
-#endif
-
-    if (mKernelList.size() < nKernels) {
-        mKernelList.reserve(nKernels);
-        for (UInt32 i = (UInt32)mKernelList.size(); i < nKernels; ++i)
-            mKernelList.push_back(NewKernel());
-    } else {
-        while (mKernelList.size() > nKernels) {
-            AUKernelBase *kernel = mKernelList.back();
-            delete kernel;
-            mKernelList.pop_back();
-        }
-    }
-
-    for(unsigned int i = 0; i < nKernels; i++ )
-    {
-        if(mKernelList[i]) {
-            mKernelList[i]->SetChannelNum (i);
-        }
-    }
-}
-
-bool        AUEffectBase::StreamFormatWritable( AudioUnitScope                  scope,
-                                                AudioUnitElement                element)
-{
-    return IsInitialized() ? false : true;
-}
-
-OSStatus            AUEffectBase::ChangeStreamFormat(   AudioUnitScope              inScope,
-                                                        AudioUnitElement            inElement,
-                                                        const CAStreamBasicDescription & inPrevFormat,
-                                                        const CAStreamBasicDescription & inNewFormat)
-{
-    OSStatus result = AUBase::ChangeStreamFormat(inScope, inElement, inPrevFormat, inNewFormat);
-    if (result == noErr)
-    {
-        // for the moment this only dependency we know about
-        // where a parameter's range may change is with the sample rate
-        // and effects are only publishing parameters in the global scope!
-        if (GetParamHasSampleRateDependency() && fnotequal(inPrevFormat.mSampleRate, inNewFormat.mSampleRate))
-            PropertyChanged(kAudioUnitProperty_ParameterList, kAudioUnitScope_Global, 0);
-    }
-
-    return result;
-}
-
-
-// ____________________________________________________________________________
-//
-//  This method is called (potentially repeatedly) by ProcessForScheduledParams()
-//  in order to perform the actual DSP required for this portion of the entire buffer
-//  being processed.  The entire buffer can be divided up into smaller "slices"
-//  according to the timestamps on the scheduled parameters...
-//
-OSStatus        AUEffectBase::ProcessScheduledSlice(    void                *inUserData,
-                                                        UInt32              inStartFrameInBuffer,
-                                                        UInt32              inSliceFramesToProcess,
-                                                        UInt32              inTotalBufferFrames )
-{
-    ScheduledProcessParams  &sliceParams = *((ScheduledProcessParams*)inUserData);
-
-    AudioUnitRenderActionFlags  &actionFlags = *sliceParams.actionFlags;
-    AudioBufferList             &inputBufferList = *sliceParams.inputBufferList;
-    AudioBufferList             &outputBufferList = *sliceParams.outputBufferList;
-
-    UInt32 channelSize = inSliceFramesToProcess * mBytesPerFrame;
-        // fix the size of the buffer we're operating on before we render this slice of time
-    for(unsigned int i = 0; i < inputBufferList.mNumberBuffers; i++ ) {
-        inputBufferList.mBuffers[i].mDataByteSize = inputBufferList.mBuffers[i].mNumberChannels * channelSize;
-    }
-
-    for(unsigned int i = 0; i < outputBufferList.mNumberBuffers; i++ ) {
-        outputBufferList.mBuffers[i].mDataByteSize = outputBufferList.mBuffers[i].mNumberChannels * channelSize;
-    }
-        // process the buffer
-    OSStatus result = ProcessBufferLists(actionFlags, inputBufferList, outputBufferList, inSliceFramesToProcess );
-
-        // we just partially processed the buffers, so increment the data pointers to the next part of the buffer to process
-    for(unsigned int i = 0; i < inputBufferList.mNumberBuffers; i++ ) {
-        inputBufferList.mBuffers[i].mData =
-            (char *)inputBufferList.mBuffers[i].mData + inputBufferList.mBuffers[i].mNumberChannels * channelSize;
-    }
-
-    for(unsigned int i = 0; i < outputBufferList.mNumberBuffers; i++ ) {
-        outputBufferList.mBuffers[i].mData =
-            (char *)outputBufferList.mBuffers[i].mData + outputBufferList.mBuffers[i].mNumberChannels * channelSize;
-    }
-
-    return result;
-}
-
-// ____________________________________________________________________________
-//
-
-OSStatus    AUEffectBase::Render(   AudioUnitRenderActionFlags &ioActionFlags,
-                                            const AudioTimeStamp &      inTimeStamp,
-                                            UInt32                      nFrames)
-{
-    if (!HasInput(0))
-        return kAudioUnitErr_NoConnection;
-
-    OSStatus result = noErr;
-
-    result = mMainInput->PullInput(ioActionFlags, inTimeStamp, 0 /* element */, nFrames);
-
-    if (result == noErr)
-    {
-        if(ProcessesInPlace() && mMainOutput->WillAllocateBuffer())
-        {
-            mMainOutput->SetBufferList(mMainInput->GetBufferList() );
-        }
-
-        if (ShouldBypassEffect())
-        {
-            // leave silence bit alone
-
-            if(!ProcessesInPlace() )
-            {
-                mMainInput->CopyBufferContentsTo (mMainOutput->GetBufferList());
-            }
-        }
-        else
-        {
-            if(mParamList.size() == 0 )
-            {
-                // this will read/write silence bit
-                result = ProcessBufferLists(ioActionFlags, mMainInput->GetBufferList(), mMainOutput->GetBufferList(), nFrames);
-            }
-            else
-            {
-                // deal with scheduled parameters...
-
-                AudioBufferList &inputBufferList = mMainInput->GetBufferList();
-                AudioBufferList &outputBufferList = mMainOutput->GetBufferList();
-
-                ScheduledProcessParams processParams;
-                processParams.actionFlags = &ioActionFlags;
-                processParams.inputBufferList = &inputBufferList;
-                processParams.outputBufferList = &outputBufferList;
-
-                // divide up the buffer into slices according to scheduled params then
-                // do the DSP for each slice (ProcessScheduledSlice() called for each slice)
-                result = ProcessForScheduledParams( mParamList,
-                                                    nFrames,
-                                                    &processParams );
-
-
-                // fixup the buffer pointers to how they were before we started
-                UInt32 channelSize = nFrames * mBytesPerFrame;
-                for(unsigned int i = 0; i < inputBufferList.mNumberBuffers; i++ ) {
-                    UInt32 size = inputBufferList.mBuffers[i].mNumberChannels * channelSize;
-                    inputBufferList.mBuffers[i].mData = (char *)inputBufferList.mBuffers[i].mData - size;
-                    inputBufferList.mBuffers[i].mDataByteSize = size;
-                }
-
-                for(unsigned int i = 0; i < outputBufferList.mNumberBuffers; i++ ) {
-                    UInt32 size = outputBufferList.mBuffers[i].mNumberChannels * channelSize;
-                    outputBufferList.mBuffers[i].mData = (char *)outputBufferList.mBuffers[i].mData - size;
-                    outputBufferList.mBuffers[i].mDataByteSize = size;
-                }
-            }
-        }
-
-        if ( (ioActionFlags & kAudioUnitRenderAction_OutputIsSilence) && !ProcessesInPlace() )
-        {
-            AUBufferList::ZeroBuffer(mMainOutput->GetBufferList() );
-        }
-    }
-
-    return result;
-}
-
-
-OSStatus    AUEffectBase::ProcessBufferLists(
-                                    AudioUnitRenderActionFlags &    ioActionFlags,
-                                    const AudioBufferList &         inBuffer,
-                                    AudioBufferList &               outBuffer,
-                                    UInt32                          inFramesToProcess )
-{
-    if (ShouldBypassEffect())
-        return noErr;
-
-    // interleaved (or mono)
-    switch (mCommonPCMFormat) {
-        case CAStreamBasicDescription::kPCMFormatFloat32 :
-            ProcessBufferListsT<Float32>(ioActionFlags, inBuffer, outBuffer, inFramesToProcess);
-            break;
-        case CAStreamBasicDescription::kPCMFormatFixed824 :
-            ProcessBufferListsT<SInt32>(ioActionFlags, inBuffer, outBuffer, inFramesToProcess);
-            break;
-        case CAStreamBasicDescription::kPCMFormatInt16 :
-            ProcessBufferListsT<SInt16>(ioActionFlags, inBuffer, outBuffer, inFramesToProcess);
-            break;
-        default :
-            throw CAException(kAudio_UnimplementedError);
-    }
-
-    return noErr;
-}
-
-Float64     AUEffectBase::GetSampleRate()
-{
-    return GetOutput(0)->GetStreamFormat().mSampleRate;
-}
-
-UInt32      AUEffectBase::GetNumberOfChannels()
-{
-    return GetOutput(0)->GetStreamFormat().mChannelsPerFrame;
-}
-
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/OtherBases/AUEffectBase.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/OtherBases/AUEffectBase.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/OtherBases/AUEffectBase.h
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#ifndef __AUEffectBase_h__
-#define __AUEffectBase_h__
-
-#include "AUBase.h"
-#include "AUSilentTimeout.h"
-#include "CAException.h"
-
-class AUKernelBase;
-
-//  Base class for an effect with one input stream, one output stream,
-//  any number of channels.
-    /*! @class AUEffectBase */
-class AUEffectBase : public AUBase {
-public:
-    /*! @ctor AUEffectBase */
-                                AUEffectBase(   AudioComponentInstance      audioUnit,
-                                                bool                        inProcessesInPlace = true );
-    /*! @dtor ~AUEffectBase */
-                                ~AUEffectBase();
-
-    /*! @method Initialize */
-    virtual OSStatus            Initialize();
-
-    /*! @method Cleanup */
-    virtual void                Cleanup();
-
-
-    /*! @method Reset */
-    virtual OSStatus            Reset(      AudioUnitScope              inScope,
-                                            AudioUnitElement            inElement);
-
-    /*! @method GetPropertyInfo */
-    virtual OSStatus            GetPropertyInfo (AudioUnitPropertyID    inID,
-                                            AudioUnitScope              inScope,
-                                            AudioUnitElement            inElement,
-                                            UInt32 &                    outDataSize,
-                                            Boolean &                   outWritable);
-
-    /*! @method GetProperty */
-    virtual OSStatus            GetProperty (AudioUnitPropertyID        inID,
-                                            AudioUnitScope              inScope,
-                                            AudioUnitElement            inElement,
-                                            void *                      outData);
-
-    /*! @method SetProperty */
-    virtual OSStatus            SetProperty(AudioUnitPropertyID         inID,
-                                            AudioUnitScope              inScope,
-                                            AudioUnitElement            inElement,
-                                            const void *                inData,
-                                            UInt32                      inDataSize);
-
-    /*! @method StreamFormatWritable */
-    virtual bool                StreamFormatWritable (AudioUnitScope    scope,
-                                            AudioUnitElement            element);
-
-    /*! @method ChangeStreamFormat */
-    virtual OSStatus            ChangeStreamFormat (
-                                        AudioUnitScope                      inScope,
-                                        AudioUnitElement                    inElement,
-                                        const CAStreamBasicDescription &    inPrevFormat,
-                                        const CAStreamBasicDescription &    inNewFormat);
-
-    /*! @method Render */
-    virtual OSStatus    Render(AudioUnitRenderActionFlags &     ioActionFlags,
-                                        const AudioTimeStamp &          inTimeStamp,
-                                        UInt32                          inNumberFrames);
-
-    // our virtual methods
-
-    // If your unit processes N to N channels, and there are no interactions between channels,
-    // it can override NewKernel to create a mono processing object per channel.  Otherwise,
-    // don't override NewKernel, and instead, override ProcessBufferLists.
-    /*! @method NewKernel */
-    virtual AUKernelBase *      NewKernel() { return NULL; }
-
-    /*! @method ProcessBufferLists */
-    virtual OSStatus            ProcessBufferLists(
-                                            AudioUnitRenderActionFlags &    ioActionFlags,
-                                            const AudioBufferList &         inBuffer,
-                                            AudioBufferList &               outBuffer,
-                                            UInt32                          inFramesToProcess );
-
-    // convenience format accessors (use output 0's format)
-    /*! @method GetSampleRate */
-    Float64                     GetSampleRate();
-
-    /*! @method GetNumberOfChannels */
-    UInt32                      GetNumberOfChannels();
-
-    // convenience wrappers for accessing parameters in the global scope
-    /*! @method SetParameter */
-    using AUBase::SetParameter;
-    void                        SetParameter(           AudioUnitParameterID            paramID,
-                                                        AudioUnitParameterValue         value)
-                                {
-                                    Globals()->SetParameter(paramID, value);
-                                }
-
-    /*! @method GetParameter */
-    using AUBase::GetParameter;
-    AudioUnitParameterValue     GetParameter(           AudioUnitParameterID            paramID )
-                                {
-                                    return Globals()->GetParameter(paramID );
-                                }
-
-    /*! @method CanScheduleParameters */
-    virtual bool                CanScheduleParameters() const { return true; }
-
-    /*! @method IsBypassEffect */
-    // This is used for the property value - to reflect to the UI if an effect is bypassed
-    bool                        IsBypassEffect () { return mBypassEffect; }
-
-protected:
-
-    /*! @method MaintainKernels */
-    void                        MaintainKernels();
-
-    /*! @method ShouldBypassEffect */
-    // This is used in the render call to see if an effect is bypassed
-    // It can return a different status than IsBypassEffect (though it MUST take that into account)
-    virtual bool                ShouldBypassEffect () { return IsBypassEffect(); }
-
-public:
-    /*! @method SetBypassEffect */
-    virtual void                SetBypassEffect (bool inFlag) { mBypassEffect = inFlag; }
-
-    /*! @method SetParamHasSampleRateDependency */
-    void                        SetParamHasSampleRateDependency (bool inFlag)
-                                {
-                                    mParamSRDep = inFlag;
-                                }
-
-    /*! @method GetParamHasSampleRateDependency */
-    bool                        GetParamHasSampleRateDependency () const { return mParamSRDep; }
-
-    struct ScheduledProcessParams   // pointer passed in as void* userData param for ProcessScheduledSlice()
-    {
-        AudioUnitRenderActionFlags  *actionFlags;
-        AudioBufferList             *inputBufferList;
-        AudioBufferList             *outputBufferList;
-    };
-
-    virtual OSStatus            ProcessScheduledSlice(  void                *inUserData,
-                                                        UInt32              inStartFrameInBuffer,
-                                                        UInt32              inSliceFramesToProcess,
-                                                        UInt32              inTotalBufferFrames );
-
-
-    bool                            ProcessesInPlace() const {return mProcessesInPlace;};
-    void                            SetProcessesInPlace(bool inProcessesInPlace) {mProcessesInPlace = inProcessesInPlace;};
-
-    typedef std::vector<AUKernelBase *> KernelList;
-
-
-
-protected:
-    /*! @var mKernelList */
-    KernelList                      mKernelList;
-
-    AUKernelBase* GetKernel(UInt32 index) { return mKernelList[index]; }
-
-    /*! @method IsInputSilent */
-    bool                            IsInputSilent (AudioUnitRenderActionFlags   inActionFlags, UInt32 inFramesToProcess)
-                                    {
-                                        bool inputSilent = (inActionFlags & kAudioUnitRenderAction_OutputIsSilence) != 0;
-
-                                        // take latency and tail time into account when propagating the silent bit
-                                        UInt32 silentTimeoutFrames = UInt32(GetSampleRate() * (GetLatency() + GetTailTime()));
-                                        mSilentTimeout.Process (inFramesToProcess, silentTimeoutFrames, inputSilent);
-                                        return inputSilent;
-                                    }
-
-#if TARGET_OS_IPHONE
-    void SetOnlyOneKernel(bool inUseOnlyOneKernel) { mOnlyOneKernel = inUseOnlyOneKernel; } // set in ctor of subclass that wants it.
-#endif
-
-    template <typename T>
-    void    ProcessBufferListsT(
-                                        AudioUnitRenderActionFlags &    ioActionFlags,
-                                        const AudioBufferList &         inBuffer,
-                                        AudioBufferList &               outBuffer,
-                                        UInt32                          inFramesToProcess );
-
-    CAStreamBasicDescription::CommonPCMFormat GetCommonPCMFormat() const { return mCommonPCMFormat; }
-
-
-private:
-    /*! @var mBypassEffect */
-    bool                            mBypassEffect;
-    /*! @var mParamSRDep */
-    bool                            mParamSRDep;
-
-    /*! @var mProcessesInplace */
-    bool                            mProcessesInPlace;
-
-    /*! @var mSilentTimeout */
-    AUSilentTimeout                 mSilentTimeout;
-
-    /*! @var mMainOutput */
-    AUOutputElement *               mMainOutput;
-
-    /*! @var mMainInput */
-    AUInputElement *                mMainInput;
-
-#if TARGET_OS_IPHONE
-    /*! @var mOnlyOneKernel */
-    bool                            mOnlyOneKernel;
-#endif
-
-    /*! @var mCommonPCMFormat */
-    CAStreamBasicDescription::CommonPCMFormat       mCommonPCMFormat;
-    UInt32                          mBytesPerFrame;
-};
-
-
-//  Base class for a "kernel", an object that performs DSP on one channel of an interleaved stream.
-    /*! @class AUKernelBase */
-class AUKernelBase {
-public:
-    /*! @ctor AUKernelBase */
-                                AUKernelBase(AUEffectBase *inAudioUnit ) :
-                                    mAudioUnit(inAudioUnit) { }
-
-    /*! @dtor ~AUKernelBase */
-    virtual                     ~AUKernelBase() { }
-
-    /*! @method Reset */
-    virtual void                Reset() { }
-
-    /*! @method Process */
-    virtual void                Process(    const Float32 *                     inSourceP,
-                                            Float32 *                           inDestP,
-                                            UInt32                              inFramesToProcess,
-                                            UInt32                              inNumChannels,
-                                            bool &                              ioSilence) { throw CAException(kAudio_UnimplementedError ); }
-
-    /*! @method Process */
-    virtual void                Process(    const SInt32 *                      inSourceP,
-                                            SInt32 *                            inDestP,
-                                            UInt32                              inFramesToProcess,
-                                            UInt32                              inNumChannels,
-                                            bool &                              ioSilence) { throw CAException(kAudio_UnimplementedError ); }
-
-    /*! @method Process */
-    virtual void                Process(    const SInt16 *                      inSourceP,
-                                            SInt16 *                            inDestP,
-                                            UInt32                              inFramesToProcess,
-                                            UInt32                              inNumChannels,
-                                            bool &                              ioSilence) { throw CAException(kAudio_UnimplementedError ); }
-
-    /*! @method GetSampleRate */
-    Float64                     GetSampleRate()
-                                {
-                                    return mAudioUnit->GetSampleRate();
-                                }
-
-    /*! @method GetParameter */
-    AudioUnitParameterValue     GetParameter (AudioUnitParameterID  paramID)
-                                {
-                                    return mAudioUnit->GetParameter(paramID);
-                                }
-
-    void                        SetChannelNum (UInt32 inChan) { mChannelNum = inChan; }
-    UInt32                      GetChannelNum () { return mChannelNum; }
-
-protected:
-    /*! @var mAudioUnit */
-    AUEffectBase *      mAudioUnit;
-    UInt32              mChannelNum;
-
-};
-
-template <typename T>
-void    AUEffectBase::ProcessBufferListsT(
-                                    AudioUnitRenderActionFlags &    ioActionFlags,
-                                    const AudioBufferList &         inBuffer,
-                                    AudioBufferList &               outBuffer,
-                                    UInt32                          inFramesToProcess )
-{
-    bool ioSilence;
-
-    bool silentInput = IsInputSilent (ioActionFlags, inFramesToProcess);
-    ioActionFlags |= kAudioUnitRenderAction_OutputIsSilence;
-
-    // call the kernels to handle either interleaved or deinterleaved
-    if (inBuffer.mNumberBuffers == 1) {
-        if (inBuffer.mBuffers[0].mNumberChannels == 0)
-            throw CAException(kAudio_ParamError);
-
-        for (UInt32 channel = 0; channel < mKernelList.size(); ++channel) {
-            AUKernelBase *kernel = mKernelList[channel];
-
-            if (kernel == NULL) continue;
-            ioSilence = silentInput;
-
-            // process each interleaved channel individually
-            kernel->Process(
-                (const T *)inBuffer.mBuffers[0].mData + channel,
-                (T *)outBuffer.mBuffers[0].mData + channel,
-                inFramesToProcess,
-                inBuffer.mBuffers[0].mNumberChannels,
-                ioSilence);
-
-            if (!ioSilence)
-                ioActionFlags &= ~kAudioUnitRenderAction_OutputIsSilence;
-        }
-    } else {
-        for (UInt32 channel = 0; channel < mKernelList.size(); ++channel) {
-            AUKernelBase *kernel = mKernelList[channel];
-
-            if (kernel == NULL) continue;
-
-            ioSilence = silentInput;
-            const AudioBuffer *srcBuffer = &inBuffer.mBuffers[channel];
-            AudioBuffer *destBuffer = &outBuffer.mBuffers[channel];
-
-            kernel->Process(
-                (const T *)srcBuffer->mData,
-                (T *)destBuffer->mData,
-                inFramesToProcess,
-                1,
-                ioSilence);
-
-            if (!ioSilence)
-                ioActionFlags &= ~kAudioUnitRenderAction_OutputIsSilence;
-        }
-    }
-}
-
-
-#endif // __AUEffectBase_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBaseHelper.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBaseHelper.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBaseHelper.cpp
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#include "AUBaseHelper.h"
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <AudioUnit/AudioUnitProperties.h>
-#else
-    #include <AudioUnitProperties.h>
-#endif
-
-OSStatus    GetFileRefPath (CFDictionaryRef parent, CFStringRef frKey, CFStringRef * fPath)
-{
-    static CFStringRef kFRString = CFSTR (kAUPresetExternalFileRefs);
-
-    const void* frVal = CFDictionaryGetValue(parent, kFRString);
-    if (!frVal) return kAudioUnitErr_InvalidPropertyValue;
-
-    const void* frString = CFDictionaryGetValue ((CFDictionaryRef)frVal, frKey);
-    if (!frString) return kAudioUnitErr_InvalidPropertyValue;
-
-    if (fPath)
-        *fPath = (CFStringRef)frString;
-
-    return noErr;
-}
-
-CFMutableDictionaryRef CreateFileRefDict (CFStringRef fKey, CFStringRef fPath, CFMutableDictionaryRef fileRefDict)
-{
-    if (!fileRefDict)
-        fileRefDict = CFDictionaryCreateMutable (NULL, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
-
-    CFDictionarySetValue (fileRefDict, fKey, fPath);
-
-    return fileRefDict;
-}
-
-#if TARGET_OS_MAC
-// check if the URL can be accessed for reading/writing.  Returns 0 if yes, or the error value.
-int AccessURLAsset(const CFURLRef inURL, int mode)
-{
-    char path[PATH_MAX];
-    if (CFURLGetFileSystemRepresentation(inURL, TRUE, (UInt8 *)path, PATH_MAX) == FALSE)
-        return kAudio_FileNotFoundError;
-    // check whether we have access
-    int ret = access(path, mode);
-//  syslog(LOG_CRIT, "access() error is %d for \"%s\".\n", ret, path);
-    if (ret == 0) return 0;
-    switch (errno) {
-        case EACCES:
-        case EPERM:
-            return -54; /*permission denied error*/
-        case ENOENT:
-        case ENOTDIR:
-        case ELOOP:
-            return kAudio_FileNotFoundError;
-        default:
-            return errno;
-    }
-}
-#endif
-
-#if DEBUG
-//_____________________________________________________________________________
-//
-void PrintAUParamEvent (AudioUnitParameterEvent& event, FILE* f)
-{
-        bool isRamp = event.eventType == kParameterEvent_Ramped;
-        fprintf (f, "\tParamID=%ld,Scope=%ld,Element=%ld\n", (long)event.parameter, (long)event.scope, (long)event.element);
-        fprintf (f, "\tEvent Type:%s,", (isRamp ? "ramp" : "immediate"));
-        if (isRamp)
-            fprintf (f, "start=%ld,dur=%ld,startValue=%f,endValue=%f\n",
-                    (long)event.eventValues.ramp.startBufferOffset, (long)event.eventValues.ramp.durationInFrames,
-                    event.eventValues.ramp.startValue, event.eventValues.ramp.endValue);
-        else
-            fprintf (f, "start=%ld,value=%f\n",
-                    (long)event.eventValues.immediate.bufferOffset,
-                    event.eventValues.immediate.value);
-        fprintf (f, "- - - - - - - - - - - - - - - -\n");
-}
-#endif
-
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBaseHelper.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBaseHelper.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBaseHelper.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#ifndef __AUBaseHelper_h__
-#define __AUBaseHelper_h__
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreFoundation/CoreFoundation.h>
-    #include <AudioUnit/AUComponent.h>
-#else
-    #include <CoreFoundation.h>
-    #include <AUComponent.h>
-#endif
-
-#include "AUBase.h"
-
-// helpers for dealing with the file-references dictionary in an AUPreset
-OSStatus GetFileRefPath (CFDictionaryRef parent, CFStringRef frKey, CFStringRef * fPath);
-
-// if fileRefDict is NULL, this call creates one
-// if not NULL, then the key value is added to it
-CFMutableDictionaryRef CreateFileRefDict (CFStringRef fKey, CFStringRef fPath, CFMutableDictionaryRef fileRefDict);
-
-int AccessURLAsset(const CFURLRef inURL, int mode);
-
-#if DEBUG
-    void PrintAUParamEvent (AudioUnitParameterEvent& event, FILE* f);
-#endif
-
-
-
-#endif // __AUBaseHelper_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBuffer.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBuffer.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBuffer.cpp
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#include "AUBuffer.h"
-#include <stdlib.h>
-
-AUBufferList::~AUBufferList()
-{
-    Deallocate();
-    if (mPtrs)
-        free(mPtrs);
-}
-
-// a * b + c
-static UInt32 SafeMultiplyAddUInt32(UInt32 a, UInt32 b, UInt32 c)
-{
-    if (a == 0 || b == 0) return c;  // prevent zero divide
-
-    if (a > (0xFFFFFFFF - c) / b)
-        throw std::bad_alloc();
-
-    return a * b + c;
-}
-
-void                AUBufferList::Allocate(const CAStreamBasicDescription &format, UInt32 nFrames)
-{
-    UInt32 nStreams;
-    if (format.IsInterleaved()) {
-        nStreams = 1;
-    } else {
-        nStreams = format.mChannelsPerFrame;
-    }
-
-    // careful -- the I/O thread could be running!
-    if (nStreams > mAllocatedStreams) {
-        size_t theHeaderSize = sizeof(AudioBufferList) - sizeof(AudioBuffer);
-        mPtrs = (AudioBufferList *)CA_realloc(mPtrs,
-                                    SafeMultiplyAddUInt32(nStreams, sizeof(AudioBuffer), theHeaderSize));
-        mAllocatedStreams = nStreams;
-    }
-    UInt32 bytesPerStream = SafeMultiplyAddUInt32(nFrames, format.mBytesPerFrame, 0xF) & ~0xF;
-    UInt32 nBytes = SafeMultiplyAddUInt32(nStreams, bytesPerStream, 0);
-    if (nBytes > mAllocatedBytes) {
-        if (mExternalMemory) {
-            mExternalMemory = false;
-            mMemory = NULL;
-        }
-        mMemory = (Byte *)CA_realloc(mMemory, nBytes);
-        mAllocatedBytes = nBytes;
-    }
-    mAllocatedFrames = nFrames;
-    mPtrState = kPtrsInvalid;
-}
-
-void                AUBufferList::Deallocate()
-{
-    mAllocatedStreams = 0;
-    mAllocatedFrames = 0;
-    mAllocatedBytes = 0;
-// this causes a world of hurt if someone upstream disconnects during I/O (SysSoundGraph)
-/*  if (mPtrs) {
-        printf("deallocating bufferlist %08X\n", int(mPtrs));
-        free(mPtrs);
-        mPtrs = NULL;
-    } */
-    if (mMemory) {
-        if (mExternalMemory)
-            mExternalMemory = false;
-        else
-            free(mMemory);
-        mMemory = NULL;
-    }
-    mPtrState = kPtrsInvalid;
-}
-
-AudioBufferList &   AUBufferList::PrepareBuffer(const CAStreamBasicDescription &format, UInt32 nFrames)
-{
-    if (nFrames > mAllocatedFrames)
-        COMPONENT_THROW(kAudioUnitErr_TooManyFramesToProcess);
-
-    UInt32 nStreams;
-    UInt32 channelsPerStream;
-    if (format.IsInterleaved()) {
-        nStreams = 1;
-        channelsPerStream = format.mChannelsPerFrame;
-    } else {
-        nStreams = format.mChannelsPerFrame;
-        channelsPerStream = 1;
-        if (nStreams > mAllocatedStreams)
-            COMPONENT_THROW(kAudioUnitErr_FormatNotSupported);
-    }
-
-    AudioBufferList *abl = mPtrs;
-    abl->mNumberBuffers = nStreams;
-    AudioBuffer *buf = abl->mBuffers;
-    Byte *mem = mMemory;
-    UInt32 streamInterval = (mAllocatedFrames * format.mBytesPerFrame + 0xF) & ~0xF;
-    UInt32 bytesPerBuffer = nFrames * format.mBytesPerFrame;
-    for ( ; nStreams--; ++buf) {
-        buf->mNumberChannels = channelsPerStream;
-        buf->mData = mem;
-        buf->mDataByteSize = bytesPerBuffer;
-        mem += streamInterval;
-    }
-    if (UInt32(mem - mMemory) > mAllocatedBytes)
-        COMPONENT_THROW(kAudioUnitErr_TooManyFramesToProcess);
-    mPtrState = kPtrsToMyMemory;
-    return *mPtrs;
-}
-
-AudioBufferList &   AUBufferList::PrepareNullBuffer(const CAStreamBasicDescription &format, UInt32 nFrames)
-{
-    UInt32 nStreams;
-    UInt32 channelsPerStream;
-    if (format.IsInterleaved()) {
-        nStreams = 1;
-        channelsPerStream = format.mChannelsPerFrame;
-    } else {
-        nStreams = format.mChannelsPerFrame;
-        channelsPerStream = 1;
-        if (nStreams > mAllocatedStreams)
-            COMPONENT_THROW(kAudioUnitErr_FormatNotSupported);
-    }
-    AudioBufferList *abl = mPtrs;
-    abl->mNumberBuffers = nStreams;
-    AudioBuffer *buf = abl->mBuffers;
-    UInt32 bytesPerBuffer = nFrames * format.mBytesPerFrame;
-    for ( ; nStreams--; ++buf) {
-        buf->mNumberChannels = channelsPerStream;
-        buf->mData = NULL;
-        buf->mDataByteSize = bytesPerBuffer;
-    }
-    mPtrState = kPtrsToExternalMemory;
-    return *mPtrs;
-}
-
-// this should NOT be called while I/O is in process
-void        AUBufferList::UseExternalBuffer(const CAStreamBasicDescription &format, const AudioUnitExternalBuffer &buf)
-{
-    UInt32 alignedSize = buf.size & ~0xF;
-    if (mMemory != NULL && alignedSize >= mAllocatedBytes) {
-        // don't accept the buffer if we already have one and it's big enough
-        // if we don't already have one, we don't need one
-        Byte *oldMemory = mMemory;
-        mMemory = buf.buffer;
-        mAllocatedBytes = alignedSize;
-        // from Allocate(): nBytes = nStreams * nFrames * format.mBytesPerFrame;
-        // thus: nFrames = nBytes / (nStreams * format.mBytesPerFrame)
-        mAllocatedFrames = mAllocatedBytes / (format.NumberChannelStreams() * format.mBytesPerFrame);
-        mExternalMemory = true;
-        free(oldMemory);
-    }
-}
-
-#if DEBUG
-void    AUBufferList::PrintBuffer(const char *label, int subscript, const AudioBufferList &abl, UInt32 nFrames, bool asFloats)
-{
-    printf("  %s [%d] 0x%08lX:\n", label, subscript, long(&abl));
-    const AudioBuffer *buf = abl.mBuffers;
-    for (UInt32 i = 0; i < abl.mNumberBuffers; ++buf, ++i) {
-        printf("      [%2d] %5dbytes %dch @ %p: ", (int)i, (int)buf->mDataByteSize, (int)buf->mNumberChannels, buf->mData);
-        if (buf->mData != NULL) {
-            UInt32 nSamples = nFrames * buf->mNumberChannels;
-            for (UInt32 j = 0; j < nSamples; ++j) {
-                if (nSamples > 16 && (j % 16) == 0)
-                    printf("\n\t");
-                if (asFloats)
-                    printf(" %6.3f", ((float *)buf->mData)[j]);
-                else
-                    printf(" %08X", (unsigned)((UInt32 *)buf->mData)[j]);
-            }
-        }
-        printf("\n");
-    }
-}
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBuffer.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBuffer.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBuffer.h
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#ifndef __AUBuffer_h__
-#define __AUBuffer_h__
-
-#include <TargetConditionals.h>
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <AudioUnit/AudioUnit.h>
-#else
-    #include <AudioUnit.h>
-#endif
-
-#include <string.h>
-#include "CAStreamBasicDescription.h"
-#include "CAAutoDisposer.h"
-#include "CADebugMacros.h"
-
-// make this usable outside the stricter context of AudiUnits
-#ifndef COMPONENT_THROW
-    #define COMPONENT_THROW(err) \
-        do { DebugMessage(#err); throw static_cast<OSStatus>(err); } while (0)
-#endif
-
-
-    /*! @class AUBufferList */
-class AUBufferList {
-    enum EPtrState {
-        kPtrsInvalid,
-        kPtrsToMyMemory,
-        kPtrsToExternalMemory
-    };
-public:
-    /*! @ctor AUBufferList */
-    AUBufferList() : mPtrState(kPtrsInvalid), mExternalMemory(false), mPtrs(NULL), mMemory(NULL),
-        mAllocatedStreams(0), mAllocatedFrames(0), mAllocatedBytes(0) { }
-    /*! @dtor ~AUBufferList */
-    ~AUBufferList();
-
-    /*! @method PrepareBuffer */
-    AudioBufferList &   PrepareBuffer(const CAStreamBasicDescription &format, UInt32 nFrames);
-    /*! @method PrepareNullBuffer */
-    AudioBufferList &   PrepareNullBuffer(const CAStreamBasicDescription &format, UInt32 nFrames);
-
-    /*! @method SetBufferList */
-    AudioBufferList &   SetBufferList(const AudioBufferList &abl) {
-                            if (mAllocatedStreams < abl.mNumberBuffers)
-                                COMPONENT_THROW(-1);
-                            mPtrState = kPtrsToExternalMemory;
-                            memcpy(mPtrs, &abl, (char *)&abl.mBuffers[abl.mNumberBuffers] - (char *)&abl);
-                            return *mPtrs;
-                        }
-
-    /*! @method SetBuffer */
-    void                SetBuffer(UInt32 index, const AudioBuffer &ab) {
-                            if (mPtrState == kPtrsInvalid || index >= mPtrs->mNumberBuffers)
-                                COMPONENT_THROW(-1);
-                            mPtrState = kPtrsToExternalMemory;
-                            mPtrs->mBuffers[index] = ab;
-                        }
-
-    /*! @method InvalidateBufferList */
-    void                InvalidateBufferList() { mPtrState = kPtrsInvalid; }
-
-    /*! @method GetBufferList */
-    AudioBufferList &   GetBufferList() const {
-                            if (mPtrState == kPtrsInvalid)
-                                COMPONENT_THROW(-1);
-                            return *mPtrs;
-                        }
-
-    /*! @method CopyBufferListTo */
-    void                CopyBufferListTo(AudioBufferList &abl) const {
-                            if (mPtrState == kPtrsInvalid)
-                                COMPONENT_THROW(-1);
-                            memcpy(&abl, mPtrs, (char *)&abl.mBuffers[abl.mNumberBuffers] - (char *)&abl);
-                        }
-
-    /*! @method CopyBufferContentsTo */
-    void                CopyBufferContentsTo(AudioBufferList &abl) const {
-                            if (mPtrState == kPtrsInvalid)
-                                COMPONENT_THROW(-1);
-                            const AudioBuffer *srcbuf = mPtrs->mBuffers;
-                            AudioBuffer *destbuf = abl.mBuffers;
-
-                            for (UInt32 i = 0; i < abl.mNumberBuffers; ++i, ++srcbuf, ++destbuf) {
-                                if (i >= mPtrs->mNumberBuffers) // duplicate last source to additional outputs [4341137]
-                                    --srcbuf;
-                                if (destbuf->mData != srcbuf->mData)
-                                    memmove(destbuf->mData, srcbuf->mData, srcbuf->mDataByteSize);
-                                destbuf->mDataByteSize = srcbuf->mDataByteSize;
-                            }
-                        }
-
-    /*! @method Allocate */
-    void                Allocate(const CAStreamBasicDescription &format, UInt32 nFrames);
-    /*! @method Deallocate */
-    void                Deallocate();
-
-    /*! @method UseExternalBuffer */
-    void                UseExternalBuffer(const CAStreamBasicDescription &format, const AudioUnitExternalBuffer &buf);
-
-    // AudioBufferList utilities
-    /*! @method ZeroBuffer */
-    static void         ZeroBuffer(AudioBufferList &abl) {
-                            AudioBuffer *buf = abl.mBuffers;
-                            for (UInt32 i = abl.mNumberBuffers ; i--; ++buf)
-                                memset(buf->mData, 0, buf->mDataByteSize);
-                        }
-#if DEBUG
-    /*! @method PrintBuffer */
-    static void         PrintBuffer(const char *label, int subscript, const AudioBufferList &abl, UInt32 nFrames = 8, bool asFloats = true);
-#endif
-
-    /*! @method GetAllocatedFrames */
-    UInt32              GetAllocatedFrames() const { return mAllocatedFrames; }
-
-private:
-    /*! @ctor AUBufferList */
-    AUBufferList(AUBufferList &) { }    // prohibit copy constructor
-
-    /*! @var mPtrState */
-    EPtrState                   mPtrState;
-    /*! @var mExternalMemory */
-    bool                        mExternalMemory;
-    /*! @var mPtrs */
-    AudioBufferList *           mPtrs;
-    /*! @var mMemory */
-    Byte *                      mMemory;
-    /*! @var mAllocatedStreams */
-    UInt32                      mAllocatedStreams;
-    /*! @var mAllocatedFrames */
-    UInt32                      mAllocatedFrames;
-    /*! @var mAllocatedBytes */
-    UInt32                      mAllocatedBytes;
-};
-
-
-// Allocates an array of samples (type T), to be optimally aligned for the processor
-    /*! @class TAUBuffer */
-template <class T>
-class TAUBuffer {
-public:
-    enum {
-        kAlignInterval = 0x10,
-        kAlignMask = kAlignInterval - 1
-    };
-
-    /*! @ctor TAUBuffer.0 */
-    TAUBuffer() :   mMemObject(NULL), mAlignedBuffer(NULL), mBufferSizeBytes(0)
-    {
-    }
-
-    /*! @ctor TAUBuffer.1 */
-    TAUBuffer(UInt32 numElems, UInt32 numChannels) :    mMemObject(NULL), mAlignedBuffer(NULL),
-                                                        mBufferSizeBytes(0)
-    {
-        Allocate(numElems, numChannels);
-    }
-
-    /*! @dtor ~TAUBuffer */
-    ~TAUBuffer()
-    {
-        Deallocate();
-    }
-
-    /*! @method Allocate */
-    void    Allocate(UInt32 numElems)           // can also re-allocate
-    {
-        UInt32 reqSize = numElems * sizeof(T);
-
-        if (mMemObject != NULL && reqSize == mBufferSizeBytes)
-            return; // already allocated
-
-        mBufferSizeBytes = reqSize;
-        mMemObject = CA_realloc(mMemObject, reqSize);
-        UInt32 misalign = (uintptr_t)mMemObject & kAlignMask;
-        if (misalign) {
-            mMemObject = CA_realloc(mMemObject, reqSize + kAlignMask);
-            mAlignedBuffer = (T *)((char *)mMemObject + kAlignInterval - misalign);
-        } else
-            mAlignedBuffer = (T *)mMemObject;
-    }
-
-    /*! @method Deallocate */
-    void    Deallocate()
-    {
-        if (mMemObject == NULL) return;         // so this method has no effect if we're using
-                                                // an external buffer
-
-        free(mMemObject);
-        mMemObject = NULL;
-        mAlignedBuffer = NULL;
-        mBufferSizeBytes = 0;
-    }
-
-    /*! @method AllocateClear */
-    void    AllocateClear(UInt32 numElems)      // can also re-allocate
-    {
-        Allocate(numElems);
-        Clear();
-    }
-
-    /*! @method Clear */
-    void    Clear()
-    {
-        memset(mAlignedBuffer, 0, mBufferSizeBytes);
-    }
-
-    // accessors
-
-    /*! @method operator T *()@ */
-    operator T *()              { return mAlignedBuffer; }
-
-private:
-    /*! @var mMemObject */
-    void *      mMemObject;         // null when using an external buffer
-    /*! @var mAlignedBuffer */
-    T *         mAlignedBuffer;     // always valid once allocated
-    /*! @var mBufferSizeBytes */
-    UInt32      mBufferSizeBytes;
-};
-
-#endif // __AUBuffer_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUSilentTimeout.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUSilentTimeout.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUSilentTimeout.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio AUBase Classes
-*/
-
-#ifndef __AUSilentTimeout
-#define __AUSilentTimeout
-
-class AUSilentTimeout
-{
-public:
-    AUSilentTimeout()
-        :   mTimeoutCounter(0),
-            mResetTimer(true)
-                {};
-
-    void                Process(UInt32 inFramesToProcess, UInt32 inTimeoutLimit, bool &ioSilence )
-    {
-        if(ioSilence )
-        {
-            if(mResetTimer )
-            {
-                mTimeoutCounter = inTimeoutLimit;
-                mResetTimer = false;
-            }
-
-            if(mTimeoutCounter > 0 )
-            {
-                mTimeoutCounter -= inFramesToProcess;
-                ioSilence = false;
-            }
-        }
-        else
-        {
-            // signal to reset the next time we receive silence
-            mResetTimer = true;
-        }
-    }
-
-    void                Reset()
-    {
-        mResetTimer = true;
-    };
-
-
-
-private:
-    SInt32              mTimeoutCounter;
-    bool                mResetTimer;
-};
-
-#endif // __AUSilentTimeout
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAtomic.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAtomic.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAtomic.h
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-/*
-    This file implements all Atomic operations using Interlocked functions specified in
-    Winbase.h
-NOTE: According to Microsoft documentation, all Interlocked functions generates a
-full barrier.
-    On Windows:
-    As the Interlocked functions returns the Old value, Extra checks and operations
-    are made after the atomic operation to return value consistent with OSX counterparts.
-*/
-
-#ifndef __CAAtomic_h__
-#define __CAAtomic_h__
-
-#if TARGET_OS_WIN32
-    #include <windows.h>
-    #include <intrin.h>
-    #pragma intrinsic(_InterlockedOr)
-    #pragma intrinsic(_InterlockedAnd)
-#else
-    #include <CoreFoundation/CFBase.h>
-    #include <libkern/OSAtomic.h>
-#endif
-
-inline void CAMemoryBarrier()
-{
-#if TARGET_OS_WIN32
-    MemoryBarrier();
-#else
-    OSMemoryBarrier();
-#endif
-}
-
-inline SInt32 CAAtomicAdd32Barrier(SInt32 theAmt, volatile SInt32* theValue)
-{
-#if TARGET_OS_WIN32
-    long lRetVal = InterlockedExchangeAdd((volatile long*)theValue, theAmt);
-    // InterlockedExchangeAdd returns the original value which differs from OSX version.
-    // At this point the addition would have occured and hence returning the new value
-    // to keep it sync with OSX.
-    return lRetVal + theAmt;
-#else
-    return OSAtomicAdd32Barrier(theAmt, (volatile int32_t *)theValue);
-#endif
-}
-
-inline SInt32 CAAtomicOr32Barrier(UInt32 theMask, volatile UInt32* theValue)
-{
-#if TARGET_OS_WIN32
-    // InterlockedAnd macro is not defined in x86 platform, and hence using the intrinsic
-    // function instead.
-    long j = _InterlockedOr((volatile long*)theValue, theMask);
-    // _InterlockedOr returns the original value which differs from OSX version.
-    // Returning the new value similar to OSX
-    return (SInt32)(j | theMask);
-#else
-    return OSAtomicOr32Barrier(theMask, (volatile uint32_t *)theValue);
-#endif
-}
-
-inline SInt32 CAAtomicAnd32Barrier(UInt32 theMask, volatile UInt32* theValue)
-{
-#if TARGET_OS_WIN32
-// InterlockedAnd macro is not defined in x86 platform, and hence using the intrinsic
-// function instead.
-    long j = _InterlockedAnd((volatile long*)theValue, theMask);
-    // _InterlockedAnd returns the original value which differs from OSX version.
-    // Returning the new value similar to OSX
-    return (SInt32)(j & theMask);
-#else
-    return OSAtomicAnd32Barrier(theMask, (volatile uint32_t *)theValue);
-#endif
-}
-
-inline bool CAAtomicCompareAndSwap32Barrier(SInt32 oldValue, SInt32 newValue, volatile SInt32 *theValue)
-{
-#if TARGET_OS_WIN32
-    // InterlockedCompareExchange returns the old value. But we need to return bool value.
-    long lRetVal = InterlockedCompareExchange((volatile long*)theValue, newValue, oldValue);
-// Hence we check if the new value is set and if it is we return true else false.
-// If theValue is equal to oldValue then the swap happens. Otherwise swap doesn't happen.
-    return (oldValue == lRetVal);
-#else
-    return OSAtomicCompareAndSwap32Barrier(oldValue, newValue, (volatile int32_t *)theValue);
-#endif
-}
-
-
-inline SInt32 CAAtomicIncrement32(volatile SInt32* theValue)
-{
-#if TARGET_OS_WIN32
-    return (SInt32)InterlockedIncrement((volatile long*)theValue);
-#else
-    return OSAtomicIncrement32((volatile int32_t *)theValue);
-#endif
-}
-
-inline SInt32 CAAtomicDecrement32(volatile SInt32* theValue)
-{
-#if TARGET_OS_WIN32
-    return (SInt32)InterlockedDecrement((volatile long*)theValue);
-#else
-    return OSAtomicDecrement32((volatile int32_t *)theValue);
-#endif
-}
-
-inline SInt32 CAAtomicIncrement32Barrier(volatile SInt32* theValue)
-{
-#if TARGET_OS_WIN32
-    return CAAtomicIncrement32(theValue);
-#else
-    return OSAtomicIncrement32Barrier((volatile int32_t *)theValue);
-#endif
-}
-
-inline SInt32 CAAtomicDecrement32Barrier(volatile SInt32* theValue)
-{
-#if TARGET_OS_WIN32
-    return CAAtomicDecrement32(theValue);
-#else
-    return OSAtomicDecrement32Barrier((volatile int32_t *)theValue);
-#endif
-}
-
-inline bool CAAtomicTestAndClearBarrier(int bitToClear, void* theAddress)
-{
-#if TARGET_OS_WIN32
-    BOOL bOldVal = InterlockedBitTestAndReset((long*)theAddress, bitToClear);
-    return (bOldVal ? true : false);
-#else
-    return OSAtomicTestAndClearBarrier(bitToClear, (volatile void *)theAddress);
-#endif
-}
-
-inline bool CAAtomicTestAndClear(int bitToClear, void* theAddress)
-{
-#if TARGET_OS_WIN32
-    BOOL bOldVal = CAAtomicTestAndClearBarrier(bitToClear, (long*)theAddress);
-    return (bOldVal ? true : false);
-#else
-    return OSAtomicTestAndClear(bitToClear, (volatile void *)theAddress);
-#endif
-}
-
-inline bool CAAtomicTestAndSetBarrier(int bitToSet, void* theAddress)
-{
-#if TARGET_OS_WIN32
-    BOOL bOldVal = InterlockedBitTestAndSet((long*)theAddress, bitToSet);
-    return (bOldVal ? true : false);
-#else
-    return OSAtomicTestAndSetBarrier(bitToSet, (volatile void *)theAddress);
-#endif
-}
-
-// int32_t flavors -- for C++ only since we can't overload in C
-// CFBase.h defines SInt32 as signed int which is similar to int32_t. If CFBase.h is included, then
-// this will generate redefinition error. But on Mac, CFBase.h, still includes MacTypes.h where
-// SInt32 is defined as signed long so this would work there.
-// So in order to fix the redefinition errors, we define these functions only if MacTypes.h is included.
-#if defined(__cplusplus) && defined(__MACTYPES__) && !__LP64__
-inline int32_t CAAtomicAdd32Barrier(int32_t theAmt, volatile int32_t* theValue)
-{
-    return CAAtomicAdd32Barrier(theAmt, (volatile SInt32 *)theValue);
-}
-
-inline int32_t CAAtomicOr32Barrier(uint32_t theMask, volatile uint32_t* theValue)
-{
-    return CAAtomicOr32Barrier(theMask, (volatile UInt32 *)theValue);
-}
-
-inline int32_t CAAtomicAnd32Barrier(uint32_t theMask, volatile uint32_t* theValue)
-{
-    return CAAtomicAnd32Barrier(theMask, (volatile UInt32 *)theValue);
-}
-
-inline bool CAAtomicCompareAndSwap32Barrier(int32_t oldValue, int32_t newValue, volatile int32_t *theValue)
-{
-    return CAAtomicCompareAndSwap32Barrier(oldValue, newValue, (volatile SInt32 *)theValue);
-}
-
-inline int32_t CAAtomicIncrement32(volatile int32_t* theValue)
-{
-    return CAAtomicIncrement32((volatile SInt32 *)theValue);
-}
-
-inline int32_t CAAtomicDecrement32(volatile int32_t* theValue)
-{
-    return CAAtomicDecrement32((volatile SInt32 *)theValue);
-}
-
-inline int32_t CAAtomicIncrement32Barrier(volatile int32_t* theValue)
-{
-    return CAAtomicIncrement32Barrier((volatile SInt32 *)theValue);
-}
-
-inline int32_t CAAtomicDecrement32Barrier(volatile int32_t* theValue)
-{
-    return CAAtomicDecrement32Barrier((volatile SInt32 *)theValue);
-}
-#endif // __cplusplus && !__LP64__
-
-#if __LP64__
-inline bool CAAtomicCompareAndSwap64Barrier( int64_t __oldValue, int64_t __newValue, volatile int64_t *__theValue )
-{
-    return OSAtomicCompareAndSwap64Barrier(__oldValue, __newValue, __theValue);
-}
-#endif
-
-inline bool CAAtomicCompareAndSwapPtrBarrier(void *__oldValue, void *__newValue, volatile void ** __theValue)
-{
-#if __LP64__
-    return CAAtomicCompareAndSwap64Barrier((int64_t)__oldValue, (int64_t)__newValue, (int64_t *)__theValue);
-#else
-    return CAAtomicCompareAndSwap32Barrier((int32_t)__oldValue, (int32_t)__newValue, (int32_t *)__theValue);
-#endif
-}
-
-/* Spinlocks.  These use memory barriers as required to synchronize access to shared
- * memory protected by the lock.  The lock operation spins, but employs various strategies
- * to back off if the lock is held, making it immune to most priority-inversion livelocks.
- * The try operation immediately returns false if the lock was held, true if it took the
- * lock.  The convention is that unlocked is zero, locked is nonzero.
- */
-#define CA_SPINLOCK_INIT    0
-
-typedef int32_t CASpinLock;
-
-bool    CASpinLockTry( volatile CASpinLock *__lock );
-void    CASpinLockLock( volatile CASpinLock *__lock );
-void    CASpinLockUnlock( volatile CASpinLock *__lock );
-
-inline void    CASpinLockLock( volatile CASpinLock *__lock )
-{
-#if TARGET_OS_MAC
-    OSSpinLockLock(__lock);
-#else
-    while (CAAtomicTestAndSetBarrier(0, (void*)__lock))
-        usleep(1000); // ???
-#endif
-}
-
-inline void    CASpinLockUnlock( volatile CASpinLock *__lock )
-{
-#if TARGET_OS_MAC
-    OSSpinLockUnlock(__lock);
-#else
-    CAAtomicTestAndClearBarrier(0, (void*)__lock);
-#endif
-}
-
-inline bool    CASpinLockTry( volatile CASpinLock *__lock )
-{
-#if TARGET_OS_MAC
-    return OSSpinLockTry(__lock);
-#else
-    return (CAAtomicTestAndSetBarrier(0, (void*)__lock) == 0);
-#endif
-}
-
-
-#endif // __CAAtomic_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAtomicStack.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAtomicStack.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAtomicStack.h
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#ifndef __CAAtomicStack_h__
-#define __CAAtomicStack_h__
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <libkern/OSAtomic.h>
-#else
-    #include <CAAtomic.h>
-#endif
-
-#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_4
-    #include <CoreServices/CoreServices.h>
-#endif
-
-//  linked list LIFO or FIFO (pop_all_reversed) stack, elements are pushed and popped atomically
-//  class T must implement T *& next().
-template <class T>
-class TAtomicStack {
-public:
-    TAtomicStack() : mHead(NULL) { }
-
-    // non-atomic routines, for use when initializing/deinitializing, operate NON-atomically
-    void    push_NA(T *item)
-    {
-        item->next() = mHead;
-        mHead = item;
-    }
-
-    T *     pop_NA()
-    {
-        T *result = mHead;
-        if (result)
-            mHead = result->next();
-        return result;
-    }
-
-    bool    empty() const { return mHead == NULL; }
-
-    T *     head() { return mHead; }
-
-    // atomic routines
-    void    push_atomic(T *item)
-    {
-        T *head_;
-        do {
-            head_ = mHead;
-            item->next() = head_;
-        } while (!compare_and_swap(head_, item, &mHead));
-    }
-
-    void    push_multiple_atomic(T *item)
-        // pushes entire linked list headed by item
-    {
-        T *head_, *p = item, *tail;
-        // find the last one -- when done, it will be linked to head
-        do {
-            tail = p;
-            p = p->next();
-        } while (p);
-        do {
-            head_ = mHead;
-            tail->next() = head_;
-        } while (!compare_and_swap(head_, item, &mHead));
-    }
-
-    T *     pop_atomic_single_reader()
-        // this may only be used when only one thread may potentially pop from the stack.
-        // if multiple threads may pop, this suffers from the ABA problem.
-        // <rdar://problem/4606346> TAtomicStack suffers from the ABA problem
-    {
-        T *result;
-        do {
-            if ((result = mHead) == NULL)
-                break;
-        } while (!compare_and_swap(result, result->next(), &mHead));
-        return result;
-    }
-
-    T *     pop_atomic()
-        // This is inefficient for large linked lists.
-        // prefer pop_all() to a series of calls to pop_atomic.
-        // push_multiple_atomic has to traverse the entire list.
-    {
-        T *result = pop_all();
-        if (result) {
-            T *next = result->next();
-            if (next)
-                // push all the remaining items back onto the stack
-                push_multiple_atomic(next);
-        }
-        return result;
-    }
-
-    T *     pop_all()
-    {
-        T *result;
-        do {
-            if ((result = mHead) == NULL)
-                break;
-        } while (!compare_and_swap(result, NULL, &mHead));
-        return result;
-    }
-
-    T*      pop_all_reversed()
-    {
-        TAtomicStack<T> reversed;
-        T *p = pop_all(), *next;
-        while (p != NULL) {
-            next = p->next();
-            reversed.push_NA(p);
-            p = next;
-        }
-        return reversed.mHead;
-    }
-
-    static bool compare_and_swap(T *oldvalue, T *newvalue, T **pvalue)
-    {
-#if TARGET_OS_MAC
-    #if __LP64__
-            return ::OSAtomicCompareAndSwap64Barrier(int64_t(oldvalue), int64_t(newvalue), (int64_t *)pvalue);
-    #elif MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4
-            return ::OSAtomicCompareAndSwap32Barrier(int32_t(oldvalue), int32_t(newvalue), (int32_t *)pvalue);
-    #else
-            return ::CompareAndSwap(UInt32(oldvalue), UInt32(newvalue), (UInt32 *)pvalue);
-    #endif
-#else
-            //return ::CompareAndSwap(UInt32(oldvalue), UInt32(newvalue), (UInt32 *)pvalue);
-            return CAAtomicCompareAndSwap32Barrier(SInt32(oldvalue), SInt32(newvalue), (SInt32*)pvalue);
-#endif
-    }
-
-protected:
-    T *     mHead;
-};
-
-#if ((MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5) && !TARGET_OS_WIN32)
-#include <libkern/OSAtomic.h>
-
-class CAAtomicStack {
-public:
-    CAAtomicStack(size_t nextPtrOffset) : mNextPtrOffset(nextPtrOffset) {
-        /*OSQueueHead h = OS_ATOMIC_QUEUE_INIT; mHead = h;*/
-        mHead.opaque1 = 0; mHead.opaque2 = 0;
-    }
-    // a subset of the above
-    void    push_atomic(void *p) { OSAtomicEnqueue(&mHead, p, mNextPtrOffset); }
-    void    push_NA(void *p) { push_atomic(p); }
-
-    void *  pop_atomic() { return OSAtomicDequeue(&mHead, mNextPtrOffset); }
-    void *  pop_atomic_single_reader() { return pop_atomic(); }
-    void *  pop_NA() { return pop_atomic(); }
-
-private:
-    OSQueueHead     mHead;
-    size_t          mNextPtrOffset;
-};
-
-// a more efficient subset of TAtomicStack using OSQueue.
-template <class T>
-class TAtomicStack2 {
-public:
-    TAtomicStack2() {
-        /*OSQueueHead h = OS_ATOMIC_QUEUE_INIT; mHead = h;*/
-        mHead.opaque1 = 0; mHead.opaque2 = 0;
-        mNextPtrOffset = -1;
-    }
-    void    push_atomic(T *item) {
-        if (mNextPtrOffset < 0) {
-            T **pnext = &item->next();  // hack around offsetof not working with C++
-            mNextPtrOffset = (Byte *)pnext - (Byte *)item;
-        }
-        OSAtomicEnqueue(&mHead, item, mNextPtrOffset);
-    }
-    void    push_NA(T *item) { push_atomic(item); }
-
-    T *     pop_atomic() { return (T *)OSAtomicDequeue(&mHead, mNextPtrOffset); }
-    T *     pop_atomic_single_reader() { return pop_atomic(); }
-    T *     pop_NA() { return pop_atomic(); }
-
-    // caution: do not try to implement pop_all_reversed here. the writer could add new elements
-    // while the reader is trying to pop old ones!
-
-private:
-    OSQueueHead     mHead;
-    ssize_t         mNextPtrOffset;
-};
-
-#else
-
-#define TAtomicStack2 TAtomicStack
-
-#endif // MAC_OS_X_VERSION_MAX_ALLOWED && !TARGET_OS_WIN32
-
-#endif // __CAAtomicStack_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAudioChannelLayout.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAudioChannelLayout.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAudioChannelLayout.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-//=============================================================================
-//  Includes
-//=============================================================================
-
-//  Self Include
-#include "CAAudioChannelLayout.h"
-#include "CAAutoDisposer.h"
-#include <stdlib.h>
-#include <string.h>
-
-//=============================================================================
-//  CAAudioChannelLayout
-//=============================================================================
-
-AudioChannelLayout* CAAudioChannelLayout::Create(UInt32 inNumberChannelDescriptions)
-{
-    UInt32 theSize = CalculateByteSize(inNumberChannelDescriptions);
-    AudioChannelLayout* theAnswer = static_cast<AudioChannelLayout*>(CA_calloc(1, theSize));
-    if(theAnswer != NULL)
-    {
-        SetAllToUnknown(*theAnswer, inNumberChannelDescriptions);
-    }
-    return theAnswer;
-}
-
-void    CAAudioChannelLayout::Destroy(AudioChannelLayout* inChannelLayout)
-{
-    free(inChannelLayout);
-}
-
-void    CAAudioChannelLayout::SetAllToUnknown(AudioChannelLayout& outChannelLayout, UInt32 inNumberChannelDescriptions)
-{
-    outChannelLayout.mChannelLayoutTag = kAudioChannelLayoutTag_UseChannelDescriptions;
-    outChannelLayout.mChannelBitmap = 0;
-    outChannelLayout.mNumberChannelDescriptions = inNumberChannelDescriptions;
-    for(UInt32 theChannelIndex = 0; theChannelIndex < inNumberChannelDescriptions; ++theChannelIndex)
-    {
-        outChannelLayout.mChannelDescriptions[theChannelIndex].mChannelLabel = kAudioChannelLabel_Unknown;
-        outChannelLayout.mChannelDescriptions[theChannelIndex].mChannelFlags = 0;
-        outChannelLayout.mChannelDescriptions[theChannelIndex].mCoordinates[0] = 0;
-        outChannelLayout.mChannelDescriptions[theChannelIndex].mCoordinates[1] = 0;
-        outChannelLayout.mChannelDescriptions[theChannelIndex].mCoordinates[2] = 0;
-    }
-}
-
-bool    operator== (const AudioChannelLayout &x, const AudioChannelLayout &y)
-{
-    // compare based on the number of channel descriptions present
-    // (this may be too strict a comparison if all you care about are matching layout tags)
-    UInt32 theSize1 = CAAudioChannelLayout::CalculateByteSize(x.mNumberChannelDescriptions);
-    UInt32 theSize2 = CAAudioChannelLayout::CalculateByteSize(y.mNumberChannelDescriptions);
-
-    if (theSize1 != theSize2)
-        return false;
-
-    return !memcmp (&x, &y, theSize1);
-}
-
-bool    operator!= (const AudioChannelLayout &x, const AudioChannelLayout &y)
-{
-    return !(x == y);
-}
-
-// counting the one bits in a word
-inline UInt32 CountOnes(UInt32 x)
-{
-    // secret magic algorithm for counting bits in a word.
-    UInt32 t;
-    x = x - ((x >> 1) & 0x55555555);
-    t = ((x >> 2) & 0x33333333);
-    x = (x & 0x33333333) + t;
-    x = (x + (x >> 4)) & 0x0F0F0F0F;
-    x = x + (x << 8);
-    x = x + (x << 16);
-    return x >> 24;
-}
-
-UInt32  CAAudioChannelLayout::NumberChannels (const AudioChannelLayout& inLayout)
-{
-    if (inLayout.mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelDescriptions)
-        return inLayout.mNumberChannelDescriptions;
-
-    if (inLayout.mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelBitmap)
-        return CountOnes (inLayout.mChannelBitmap);
-
-    return AudioChannelLayoutTag_GetNumberOfChannels(inLayout.mChannelLayoutTag);
-}
-
-void    CAShowAudioChannelLayout (FILE* file, const AudioChannelLayout *layout)
-{
-    if (layout == NULL)
-    {
-        fprintf (file, "\tNULL layout\n");
-        return;
-    }
-    fprintf (file, "\tTag=0x%X, ", (int)layout->mChannelLayoutTag);
-    if (layout->mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelBitmap)
-        fprintf (file, "Using Bitmap:0x%X\n", (int)layout->mChannelBitmap);
-    else {
-        fprintf (file, "Num Chan Descs=%d\n", (int)layout->mNumberChannelDescriptions);
-        const AudioChannelDescription *desc = layout->mChannelDescriptions;
-        for (unsigned int i = 0; i < layout->mNumberChannelDescriptions; ++i, ++desc) {
-            fprintf (file, "\t\tLabel=%d, Flags=0x%X, ", (int)desc->mChannelLabel, (int)desc->mChannelFlags);
-            fprintf (file, "[az=%f,el=%f,dist=%f]\n", desc->mCoordinates[0], desc->mCoordinates[1], desc->mCoordinates[2]);
-        }
-    }
-}
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAudioChannelLayout.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAudioChannelLayout.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAudioChannelLayout.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#if !defined(__CAAudioChannelLayout_h__)
-#define __CAAudioChannelLayout_h__
-
-//=============================================================================
-//  Includes
-//=============================================================================
-
-//  System Includes
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreAudio/CoreAudioTypes.h>
-    #include <CoreFoundation/CoreFoundation.h>
-#else
-    #include <CoreAudioTypes.h>
-    #include <CoreFoundation.h>
-#endif
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "CADebugMacros.h"
-#include "CAAutoDisposer.h"
-
-#if !HAL_Build
-    #include "CAReferenceCounted.h"
-#endif
-
-//=============================================================================
-//  CAAudioChannelLayout
-//=============================================================================
-
-bool    operator== (const AudioChannelLayout &x, const AudioChannelLayout &y);
-bool    operator!= (const AudioChannelLayout &x, const AudioChannelLayout &y);
-
-extern "C" void     CAShowAudioChannelLayout (FILE* file, const AudioChannelLayout *layout);
-
-class CAAudioChannelLayout
-{
-//  static Construction/Destruction
-public:
-    static AudioChannelLayout*  Create(UInt32 inNumberChannelDescriptions);
-    static void                 Destroy(AudioChannelLayout* inChannelLayout);
-    static UInt32               CalculateByteSize(UInt32 inNumberChannelDescriptions) {
-                                    return SizeOf32(AudioChannelLayout) - SizeOf32(AudioChannelDescription) + (inNumberChannelDescriptions * SizeOf32(AudioChannelDescription));
-                                }
-    static void                 SetAllToUnknown(AudioChannelLayout& outChannelLayout, UInt32 inNumberChannelDescriptions);
-    static UInt32               NumberChannels(const AudioChannelLayout& inLayout);
-
-#if !HAL_Build
-// object methods
-public:
-                                CAAudioChannelLayout ();
-
-                                CAAudioChannelLayout (UInt32 inNumberChannels, bool inChooseSurround);
-                                    // if inChooseSurround is false, then symmetrical speaker arrangements
-                                    // are chosen in place of surround layouts if there is a choice
-                                    // This call chooses layouts based on the expected defaults in
-                                    // AudioUnit usage
-                                CAAudioChannelLayout (AudioChannelLayoutTag inTag);
-                                CAAudioChannelLayout (const CAAudioChannelLayout &c);
-                                CAAudioChannelLayout (const AudioChannelLayout* inChannelLayout);
-                                ~CAAudioChannelLayout();
-
-    CAAudioChannelLayout&       operator= (const AudioChannelLayout* inChannelLayout);
-    CAAudioChannelLayout&       operator= (const CAAudioChannelLayout& c);
-    bool                        operator== (const CAAudioChannelLayout &c) const;
-    bool                        operator!= (const CAAudioChannelLayout &c) const;
-
-    void                        SetWithTag(AudioChannelLayoutTag inTag);
-
-    bool                        IsValid() const { return NumberChannels() > 0; }
-    UInt32                      Size() const { return mLayout ? mLayout->Size() : 0; }
-
-    UInt32                      NumberChannels() const { return mLayout ? mLayout->NumberChannels() : 0; }
-
-    AudioChannelLayoutTag       Tag() const { return Layout().mChannelLayoutTag; }
-    const AudioChannelLayout&   Layout() const { return mLayout->Layout(); }
-    operator const AudioChannelLayout *() const { return &Layout(); }
-
-    void                        Print () const { Print (stdout); }
-    void                        Print (FILE* file) const;
-
-    OSStatus                    Save (CFPropertyListRef *outData) const;
-    OSStatus                    Restore (CFPropertyListRef &inData);
-
-private:
-    class RefCountedLayout : public CAReferenceCounted {
-        void *  operator new(size_t /* size */, size_t aclSize)
-        {
-            return CA_malloc(sizeof(RefCountedLayout) - sizeof(AudioChannelLayout) + aclSize);
-        }
-
-        void    operator delete(void *mem)
-        {
-            free(mem);
-        }
-
-
-        RefCountedLayout(UInt32 inDataSize) :
-            mByteSize(inDataSize)
-        {
-            memset(&mACL, 0, inDataSize);
-        }
-
-    public:
-        static RefCountedLayout *CreateWithNumberChannelDescriptions(unsigned nChannels) {
-                                size_t size = CAAudioChannelLayout::CalculateByteSize(nChannels);
-                                return new(size) RefCountedLayout((UInt32)size);
-                            }
-
-        static RefCountedLayout *CreateWithLayout(const AudioChannelLayout *layout) {
-                                size_t size = CAAudioChannelLayout::CalculateByteSize(layout->mNumberChannelDescriptions);
-                                RefCountedLayout *acl = new(size) RefCountedLayout((UInt32)size);
-                                memcpy(&acl->mACL, layout, size);
-                                return acl;
-                            }
-        static RefCountedLayout *CreateWithLayoutTag(AudioChannelLayoutTag layoutTag) {
-                                RefCountedLayout *acl = CreateWithNumberChannelDescriptions(0);
-                                acl->mACL.mChannelLayoutTag = layoutTag;
-                                return acl;
-                            }
-
-        const AudioChannelLayout &  Layout() const { return mACL; }
-
-        UInt32                      Size () const { return mByteSize; }
-
-        UInt32                      NumberChannels() { return CAAudioChannelLayout::NumberChannels(Layout()); }
-
-    private:
-        const UInt32        mByteSize;
-        AudioChannelLayout  mACL;
-        // * * * mACL is variable length and thus must be last * * *
-
-            // only the constructors can change the actual state of the layout
-        friend CAAudioChannelLayout::CAAudioChannelLayout (UInt32 inNumberChannels, bool inChooseSurround);
-        friend OSStatus CAAudioChannelLayout::Restore (CFPropertyListRef &inData);
-        friend CAAudioChannelLayout& CAAudioChannelLayout::operator= (const AudioChannelLayout* inChannelLayout);
-        friend void CAAudioChannelLayout::SetWithTag(AudioChannelLayoutTag inTag);
-
-        AudioChannelLayout *    GetLayout() { return &mACL; }
-
-    private:
-        // prohibited methods: private and unimplemented.
-        RefCountedLayout();
-        RefCountedLayout(const RefCountedLayout& c);
-        RefCountedLayout& operator=(const RefCountedLayout& c);
-    };
-
-    RefCountedLayout        *mLayout;
-#endif  //  HAL_Build
-
-};
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAutoDisposer.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAutoDisposer.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAutoDisposer.h
+++ /dev/null
@@ -1,470 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#if !defined(__CAPtr_h__)
-#define __CAPtr_h__
-
-#include <stdlib.h>     // for malloc
-#include <new>          // for bad_alloc
-#include <string.h>     // for memset
-
-inline void* CA_malloc(size_t size)
-{
-    void* p = malloc(size);
-    if (!p && size) throw std::bad_alloc();
-    return p;
-}
-
-inline void* CA_realloc(void* old, size_t size)
-{
-#if TARGET_OS_WIN32
-    void* p = realloc(old, size);
-#else
-    void* p = reallocf(old, size); // reallocf ensures the old pointer is freed if memory is full (p is NULL).
-#endif
-    if (!p && size) throw std::bad_alloc();
-    return p;
-}
-
-#ifndef UINTPTR_MAX
-#if __LP64__
-#define UINTPTR_MAX   18446744073709551615ULL
-#else
-#define UINTPTR_MAX   4294967295U
-#endif
-#endif
-
-inline void* CA_calloc(size_t n, size_t size)
-{
-    // ensure that multiplication will not overflow
-    if (n && UINTPTR_MAX / n < size) throw std::bad_alloc();
-
-    size_t nsize = n*size;
-    void* p = malloc(nsize);
-    if (!p && nsize) throw std::bad_alloc();
-
-    memset(p, 0, nsize);
-    return p;
-}
-
-
-// helper class for automatic conversions
-template <typename T>
-struct CAPtrRef
-{
-    T* ptr_;
-
-    explicit CAPtrRef(T* ptr) : ptr_(ptr) {}
-};
-
-template <typename T>
-class CAAutoFree
-{
-private:
-    T* ptr_;
-
-public:
-
-    CAAutoFree() : ptr_(0) {}
-
-    explicit CAAutoFree(T* ptr) : ptr_(ptr) {}
-
-    template<typename U>
-    CAAutoFree(CAAutoFree<U>& that) : ptr_(that.release()) {} // take ownership
-
-    // C++ std says: a template constructor is never a copy constructor
-    CAAutoFree(CAAutoFree<T>& that) : ptr_(that.release()) {} // take ownership
-
-    CAAutoFree(size_t n, bool clear = false)
-        // this becomes an ambiguous call if n == 0
-        : ptr_(0)
-        {
-            size_t maxItems = ~size_t(0) / sizeof(T);
-            if (n > maxItems)
-                throw std::bad_alloc();
-
-            ptr_ = static_cast<T*>(clear ? CA_calloc(n, sizeof(T)) : CA_malloc(n * sizeof(T)));
-        }
-
-    ~CAAutoFree() { free(); }
-
-    void alloc(size_t numItems, bool clear = false)
-    {
-        size_t maxItems = ~size_t(0) / sizeof(T);
-        if (numItems > maxItems) throw std::bad_alloc();
-
-        free();
-        ptr_ = static_cast<T*>(clear ? CA_calloc(numItems, sizeof(T)) : CA_malloc(numItems * sizeof(T)));
-    }
-
-    void allocBytes(size_t numBytes, bool clear = false)
-    {
-        free();
-        ptr_ = static_cast<T*>(clear ? CA_calloc(1, numBytes) : CA_malloc(numBytes));
-    }
-
-    void reallocBytes(size_t numBytes)
-    {
-        ptr_ = static_cast<T*>(CA_realloc(ptr_, numBytes));
-    }
-
-    void reallocItems(size_t numItems)
-    {
-        size_t maxItems = ~size_t(0) / sizeof(T);
-        if (numItems > maxItems) throw std::bad_alloc();
-
-        ptr_ = static_cast<T*>(CA_realloc(ptr_, numItems * sizeof(T)));
-    }
-
-    template <typename U>
-    CAAutoFree& operator=(CAAutoFree<U>& that)
-    {
-        set(that.release());    // take ownership
-        return *this;
-    }
-
-    CAAutoFree& operator=(CAAutoFree& that)
-    {
-        set(that.release());    // take ownership
-        return *this;
-    }
-
-    CAAutoFree& operator=(T* ptr)
-    {
-        set(ptr);
-        return *this;
-    }
-
-    template <typename U>
-    CAAutoFree& operator=(U* ptr)
-    {
-        set(ptr);
-        return *this;
-    }
-
-    T& operator*() const { return *ptr_; }
-    T* operator->() const { return ptr_; }
-
-    T* operator()() const { return ptr_; }
-    T* get() const { return ptr_; }
-    operator T*() const { return ptr_; }
-
-    bool operator==(CAAutoFree const& that) const { return ptr_ == that.ptr_; }
-    bool operator!=(CAAutoFree const& that) const { return ptr_ != that.ptr_; }
-    bool operator==(T* ptr) const { return ptr_ == ptr; }
-    bool operator!=(T* ptr) const { return ptr_ != ptr; }
-
-    T* release()
-    {
-        // release ownership
-        T* result = ptr_;
-        ptr_ = 0;
-        return result;
-    }
-
-    void set(T* ptr)
-    {
-        if (ptr != ptr_)
-        {
-            ::free(ptr_);
-            ptr_ = ptr;
-        }
-    }
-
-    void free()
-    {
-        set(0);
-    }
-
-
-    // automatic conversions to allow assignment from results of functions.
-    // hard to explain. see auto_ptr implementation and/or Josuttis' STL book.
-    CAAutoFree(CAPtrRef<T> ref) : ptr_(ref.ptr_) { }
-
-    CAAutoFree& operator=(CAPtrRef<T> ref)
-    {
-        set(ref.ptr_);
-        return *this;
-    }
-
-    template<typename U>
-    operator CAPtrRef<U>()
-        { return CAPtrRef<U>(release()); }
-
-    template<typename U>
-    operator CAAutoFree<U>()
-        { return CAAutoFree<U>(release()); }
-
-};
-
-
-template <typename T>
-class CAAutoDelete
-{
-private:
-    T* ptr_;
-
-public:
-    CAAutoDelete() : ptr_(0) {}
-
-    explicit CAAutoDelete(T* ptr) : ptr_(ptr) {}
-
-    template<typename U>
-    CAAutoDelete(CAAutoDelete<U>& that) : ptr_(that.release()) {} // take ownership
-
-    // C++ std says: a template constructor is never a copy constructor
-    CAAutoDelete(CAAutoDelete<T>& that) : ptr_(that.release()) {} // take ownership
-
-    ~CAAutoDelete() { free(); }
-
-    template <typename U>
-    CAAutoDelete& operator=(CAAutoDelete<U>& that)
-    {
-        set(that.release());    // take ownership
-        return *this;
-    }
-
-    CAAutoDelete& operator=(CAAutoDelete& that)
-    {
-        set(that.release());    // take ownership
-        return *this;
-    }
-
-    CAAutoDelete& operator=(T* ptr)
-    {
-        set(ptr);
-        return *this;
-    }
-
-    template <typename U>
-    CAAutoDelete& operator=(U* ptr)
-    {
-        set(ptr);
-        return *this;
-    }
-
-    T& operator*() const { return *ptr_; }
-    T* operator->() const { return ptr_; }
-
-    T* operator()() const { return ptr_; }
-    T* get() const { return ptr_; }
-    operator T*() const { return ptr_; }
-
-    bool operator==(CAAutoDelete const& that) const { return ptr_ == that.ptr_; }
-    bool operator!=(CAAutoDelete const& that) const { return ptr_ != that.ptr_; }
-    bool operator==(T* ptr) const { return ptr_ == ptr; }
-    bool operator!=(T* ptr) const { return ptr_ != ptr; }
-
-    T* release()
-    {
-        // release ownership
-        T* result = ptr_;
-        ptr_ = 0;
-        return result;
-    }
-
-    void set(T* ptr)
-    {
-        if (ptr != ptr_)
-        {
-            delete ptr_;
-            ptr_ = ptr;
-        }
-    }
-
-    void free()
-    {
-        set(0);
-    }
-
-
-    // automatic conversions to allow assignment from results of functions.
-    // hard to explain. see auto_ptr implementation and/or Josuttis' STL book.
-    CAAutoDelete(CAPtrRef<T> ref) : ptr_(ref.ptr_) { }
-
-    CAAutoDelete& operator=(CAPtrRef<T> ref)
-    {
-        set(ref.ptr_);
-        return *this;
-    }
-
-    template<typename U>
-    operator CAPtrRef<U>()
-        { return CAPtrRef<U>(release()); }
-
-    template<typename U>
-    operator CAAutoFree<U>()
-        { return CAAutoFree<U>(release()); }
-
-};
-
-
-template <typename T>
-class CAAutoArrayDelete
-{
-private:
-    T* ptr_;
-
-public:
-    CAAutoArrayDelete() : ptr_(0) {}
-
-    explicit CAAutoArrayDelete(T* ptr) : ptr_(ptr) {}
-
-    template<typename U>
-    CAAutoArrayDelete(CAAutoArrayDelete<U>& that) : ptr_(that.release()) {} // take ownership
-
-    // C++ std says: a template constructor is never a copy constructor
-    CAAutoArrayDelete(CAAutoArrayDelete<T>& that) : ptr_(that.release()) {} // take ownership
-
-    // this becomes an ambiguous call if n == 0
-    CAAutoArrayDelete(size_t n) : ptr_(new T[n]) {}
-
-    ~CAAutoArrayDelete() { free(); }
-
-    void alloc(size_t numItems)
-    {
-        free();
-        ptr_ = new T [numItems];
-    }
-
-    template <typename U>
-    CAAutoArrayDelete& operator=(CAAutoArrayDelete<U>& that)
-    {
-        set(that.release());    // take ownership
-        return *this;
-    }
-
-    CAAutoArrayDelete& operator=(CAAutoArrayDelete& that)
-    {
-        set(that.release());    // take ownership
-        return *this;
-    }
-
-    CAAutoArrayDelete& operator=(T* ptr)
-    {
-        set(ptr);
-        return *this;
-    }
-
-    template <typename U>
-    CAAutoArrayDelete& operator=(U* ptr)
-    {
-        set(ptr);
-        return *this;
-    }
-
-    T& operator*() const { return *ptr_; }
-    T* operator->() const { return ptr_; }
-
-    T* operator()() const { return ptr_; }
-    T* get() const { return ptr_; }
-    operator T*() const { return ptr_; }
-
-    bool operator==(CAAutoArrayDelete const& that) const { return ptr_ == that.ptr_; }
-    bool operator!=(CAAutoArrayDelete const& that) const { return ptr_ != that.ptr_; }
-    bool operator==(T* ptr) const { return ptr_ == ptr; }
-    bool operator!=(T* ptr) const { return ptr_ != ptr; }
-
-    T* release()
-    {
-        // release ownership
-        T* result = ptr_;
-        ptr_ = 0;
-        return result;
-    }
-
-    void set(T* ptr)
-    {
-        if (ptr != ptr_)
-        {
-            delete [] ptr_;
-            ptr_ = ptr;
-        }
-    }
-
-    void free()
-    {
-        set(0);
-    }
-
-
-    // automatic conversions to allow assignment from results of functions.
-    // hard to explain. see auto_ptr implementation and/or Josuttis' STL book.
-    CAAutoArrayDelete(CAPtrRef<T> ref) : ptr_(ref.ptr_) { }
-
-    CAAutoArrayDelete& operator=(CAPtrRef<T> ref)
-    {
-        set(ref.ptr_);
-        return *this;
-    }
-
-    template<typename U>
-    operator CAPtrRef<U>()
-        { return CAPtrRef<U>(release()); }
-
-    template<typename U>
-    operator CAAutoArrayDelete<U>()
-        { return CAAutoFree<U>(release()); }
-
-};
-
-
-
-
-
-// convenience function
-template <typename T>
-void free(CAAutoFree<T>& p)
-{
-    p.free();
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////
-////////////////////////////////////////////////////////////////////////////////////////////////////////
-////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-#if 0
-// example program showing ownership transfer
-
-CAAutoFree<char> source()
-{
-    // source allocates and returns ownership to the caller.
-    const char* str = "this is a test";
-    size_t size = strlen(str) + 1;
-    CAAutoFree<char> captr(size, false);
-    strlcpy(captr(), str, size);
-    printf("source %08X %08X '%s'\n", &captr, captr(), captr());
-    return captr;
-}
-
-void user(CAAutoFree<char> const& captr)
-{
-    // passed by const reference. user can access the pointer but does not take ownership.
-    printf("user: %08X %08X '%s'\n", &captr, captr(), captr());
-}
-
-void sink(CAAutoFree<char> captr)
-{
-    // passed by value. sink takes ownership and frees the pointer on return.
-    printf("sink: %08X %08X '%s'\n", &captr, captr(), captr());
-}
-
-
-int main (int argc, char * const argv[])
-{
-
-    CAAutoFree<char> captr(source());
-    printf("main captr A %08X %08X\n", &captr, captr());
-    user(captr);
-    sink(captr);
-    printf("main captr B %08X %08X\n", &captr, captr());
-    return 0;
-}
-#endif
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CABitOperations.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CABitOperations.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CABitOperations.h
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
-     File: CABitOperations.h
- Abstract: Part of CoreAudio Utility Classes
-  Version: 1.1
-
- Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple
- Inc. ("Apple") in consideration of your agreement to the following
- terms, and your use, installation, modification or redistribution of
- this Apple software constitutes acceptance of these terms.  If you do
- not agree with these terms, please do not use, install, modify or
- redistribute this Apple software.
-
- In consideration of your agreement to abide by the following terms, and
- subject to these terms, Apple grants you a personal, non-exclusive
- license, under Apple's copyrights in this original Apple software (the
- "Apple Software"), to use, reproduce, modify and redistribute the Apple
- Software, with or without modifications, in source and/or binary forms;
- provided that if you redistribute the Apple Software in its entirety and
- without modifications, you must retain this notice and the following
- text and disclaimers in all such redistributions of the Apple Software.
- Neither the name, trademarks, service marks or logos of Apple Inc. may
- be used to endorse or promote products derived from the Apple Software
- without specific prior written permission from Apple.  Except as
- expressly stated in this notice, no other rights or licenses, express or
- implied, are granted by Apple herein, including but not limited to any
- patent rights that may be infringed by your derivative works or by other
- works in which the Apple Software may be incorporated.
-
- The Apple Software is provided by Apple on an "AS IS" basis.  APPLE
- MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
- THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
- FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
- OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
-
- IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
- OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
- MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
- AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
- STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
- POSSIBILITY OF SUCH DAMAGE.
-
- Copyright (C) 2014 Apple Inc. All Rights Reserved.
-
-*/
-#ifndef _CABitOperations_h_
-#define _CABitOperations_h_
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    //#include <CoreServices/../Frameworks/CarbonCore.framework/Headers/MacTypes.h>
-    #include <CoreFoundation/CFBase.h>
-#else
-//  #include <MacTypes.h>
-    #include "CFBase.h"
-#endif
-#include <TargetConditionals.h>
-
-// return whether a number is a power of two
-inline UInt32 IsPowerOfTwo(UInt32 x)
-{
-    return (x & (x-1)) == 0;
-}
-
-// count the leading zeros in a word
-// Metrowerks Codewarrior. powerpc native count leading zeros instruction:
-// I think it's safe to remove this ...
-//#define CountLeadingZeroes(x)  ((int)__cntlzw((unsigned int)x))
-
-inline UInt32 CountLeadingZeroes(UInt32 arg)
-{
-// GNUC / LLVM have a builtin
-#if defined(__GNUC__) || defined(__llvm___)
-#if (TARGET_CPU_X86 || TARGET_CPU_X86_64)
-    if (arg == 0) return 32;
-#endif  // TARGET_CPU_X86 || TARGET_CPU_X86_64
-    return __builtin_clz(arg);
-#elif TARGET_OS_WIN32
-    UInt32 tmp;
-    __asm{
-        bsr eax, arg
-        mov ecx, 63
-        cmovz eax, ecx
-        xor eax, 31
-        mov tmp, eax    // this moves the result in tmp to return.
-    }
-    return tmp;
-#else
-#error "Unsupported architecture"
-#endif  // defined(__GNUC__)
-}
-// Alias (with different spelling)
-#define CountLeadingZeros CountLeadingZeroes
-
-inline UInt32 CountLeadingZeroesLong(UInt64 arg)
-{
-// GNUC / LLVM have a builtin
-#if defined(__GNUC__) || defined(__llvm___)
-#if (TARGET_CPU_X86 || TARGET_CPU_X86_64)
-    if (arg == 0) return 64;
-#endif  // TARGET_CPU_X86 || TARGET_CPU_X86_64
-    return __builtin_clzll(arg);
-#elif TARGET_OS_WIN32
-    UInt32 x = CountLeadingZeroes((UInt32)(arg >> 32));
-    if(x < 32)
-        return x;
-    else
-        return 32+CountLeadingZeroes((UInt32)arg);
-#else
-#error "Unsupported architecture"
-#endif  // defined(__GNUC__)
-}
-#define CountLeadingZerosLong CountLeadingZeroesLong
-
-// count trailing zeroes
-inline UInt32 CountTrailingZeroes(UInt32 x)
-{
-    return 32 - CountLeadingZeroes(~x & (x-1));
-}
-
-// count leading ones
-inline UInt32 CountLeadingOnes(UInt32 x)
-{
-    return CountLeadingZeroes(~x);
-}
-
-// count trailing ones
-inline UInt32 CountTrailingOnes(UInt32 x)
-{
-    return 32 - CountLeadingZeroes(x & (~x-1));
-}
-
-// number of bits required to represent x.
-inline UInt32 NumBits(UInt32 x)
-{
-    return 32 - CountLeadingZeroes(x);
-}
-
-// base 2 log of next power of two greater or equal to x
-inline UInt32 Log2Ceil(UInt32 x)
-{
-    return 32 - CountLeadingZeroes(x - 1);
-}
-
-// base 2 log of next power of two less or equal to x
-inline UInt32 Log2Floor(UInt32 x)
-{
-    return 32 - CountLeadingZeroes(x) - 1;
-}
-
-// next power of two greater or equal to x
-inline UInt32 NextPowerOfTwo(UInt32 x)
-{
-    return 1 << Log2Ceil(x);
-}
-
-// counting the one bits in a word
-inline UInt32 CountOnes(UInt32 x)
-{
-    // secret magic algorithm for counting bits in a word.
-    x = x - ((x >> 1) & 0x55555555);
-    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
-    return (((x + (x >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
-}
-
-// counting the zero bits in a word
-inline UInt32 CountZeroes(UInt32 x)
-{
-    return CountOnes(~x);
-}
-
-// return the bit position (0..31) of the least significant bit
-inline UInt32 LSBitPos(UInt32 x)
-{
-    return CountTrailingZeroes(x & -(SInt32)x);
-}
-
-// isolate the least significant bit
-inline UInt32 LSBit(UInt32 x)
-{
-    return x & -(SInt32)x;
-}
-
-// return the bit position (0..31) of the most significant bit
-inline UInt32 MSBitPos(UInt32 x)
-{
-    return 31 - CountLeadingZeroes(x);
-}
-
-// isolate the most significant bit
-inline UInt32 MSBit(UInt32 x)
-{
-    return 1 << MSBitPos(x);
-}
-
-// Division optimized for power of 2 denominators
-inline UInt32 DivInt(UInt32 numerator, UInt32 denominator)
-{
-    if(IsPowerOfTwo(denominator))
-        return numerator >> (31 - CountLeadingZeroes(denominator));
-    else
-        return numerator/denominator;
-}
-
-#endif
-
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugMacros.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugMacros.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugMacros.cpp
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#include "CADebugMacros.h"
-#include <stdio.h>
-#include <stdarg.h>
-#if TARGET_API_MAC_OSX
-    #include <syslog.h>
-#endif
-
-#if DEBUG
-#include <stdio.h>
-
-void    DebugPrint(const char *fmt, ...)
-{
-    va_list args;
-    va_start(args, fmt);
-    vprintf(fmt, args);
-    va_end(args);
-}
-#endif // DEBUG
-
-void    LogError(const char *fmt, ...)
-{
-    va_list args;
-    va_start(args, fmt);
-#if DEBUG
-    vprintf(fmt, args);
-#endif
-#if TARGET_API_MAC_OSX
-    vsyslog(LOG_ERR, fmt, args);
-#endif
-    va_end(args);
-}
-
-void    LogWarning(const char *fmt, ...)
-{
-    va_list args;
-    va_start(args, fmt);
-#if DEBUG
-    vprintf(fmt, args);
-#endif
-#if TARGET_API_MAC_OSX
-    vsyslog(LOG_WARNING, fmt, args);
-#endif
-    va_end(args);
-}
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugMacros.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugMacros.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugMacros.h
+++ /dev/null
@@ -1,543 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#if !defined(__CADebugMacros_h__)
-#define __CADebugMacros_h__
-
-//=============================================================================
-//  Includes
-//=============================================================================
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreAudio/CoreAudioTypes.h>
-#else
-    #include "CoreAudioTypes.h"
-#endif
-
-//=============================================================================
-//  CADebugMacros
-//=============================================================================
-
-//#define   CoreAudio_StopOnFailure         1
-//#define   CoreAudio_TimeStampMessages     1
-//#define   CoreAudio_ThreadStampMessages   1
-//#define   CoreAudio_FlushDebugMessages    1
-
-#if TARGET_RT_BIG_ENDIAN
-    #define CA4CCToCString(the4CC)                  { ((char*)&the4CC)[0], ((char*)&the4CC)[1], ((char*)&the4CC)[2], ((char*)&the4CC)[3], 0 }
-    #define CACopy4CCToCString(theCString, the4CC)  { theCString[0] = ((char*)&the4CC)[0]; theCString[1] = ((char*)&the4CC)[1]; theCString[2] = ((char*)&the4CC)[2]; theCString[3] = ((char*)&the4CC)[3]; theCString[4] = 0; }
-#else
-    #define CA4CCToCString(the4CC)                  { ((char*)&the4CC)[3], ((char*)&the4CC)[2], ((char*)&the4CC)[1], ((char*)&the4CC)[0], 0 }
-    #define CACopy4CCToCString(theCString, the4CC)  { theCString[0] = ((char*)&the4CC)[3]; theCString[1] = ((char*)&the4CC)[2]; theCString[2] = ((char*)&the4CC)[1]; theCString[3] = ((char*)&the4CC)[0]; theCString[4] = 0; }
-#endif
-
-//  This is a macro that does a sizeof and casts the result to a UInt32. This is useful for all the
-//  places where -wshorten64-32 catches assigning a sizeof expression to a UInt32.
-//  For want of a better place to park this, we'll park it here.
-#define SizeOf32(X) ((UInt32)sizeof(X))
-
-//  This is a macro that does a offsetof and casts the result to a UInt32. This is useful for all the
-//  places where -wshorten64-32 catches assigning an offsetof expression to a UInt32.
-//  For want of a better place to park this, we'll park it here.
-#define OffsetOf32(X, Y)    ((UInt32)offsetof(X, Y))
-
-//  This macro casts the expression to a UInt32. It is called out specially to allow us to track casts
-//  that have been added purely to avert -wshorten64-32 warnings on 64 bit platforms.
-//  For want of a better place to park this, we'll park it here.
-#define ToUInt32(X) ((UInt32)(X))
-#define ToSInt32(X) ((SInt32)(X))
-
-#pragma mark    Basic Definitions
-
-#if DEBUG || CoreAudio_Debug
-    // can be used to break into debugger immediately, also see CADebugger
-    #define BusError()      { long* p=NULL; *p=0; }
-
-    //  basic debugging print routines
-    #if TARGET_OS_MAC && !TARGET_API_MAC_CARBON
-        extern void DebugStr(const unsigned char* debuggerMsg);
-        #define DebugMessage(msg)   DebugStr("\p"msg)
-        #define DebugMessageN1(msg, N1)
-        #define DebugMessageN2(msg, N1, N2)
-        #define DebugMessageN3(msg, N1, N2, N3)
-    #else
-        #include "CADebugPrintf.h"
-
-        #if (CoreAudio_FlushDebugMessages && !CoreAudio_UseSysLog && !CoreAudio_UseCALog) || defined(CoreAudio_UseSideFile)
-            #define FlushRtn    ,fflush(DebugPrintfFile)
-        #else
-            #define FlushRtn
-        #endif
-
-        #if     CoreAudio_ThreadStampMessages
-            #include <pthread.h>
-            #include "CAHostTimeBase.h"
-            #if TARGET_RT_64_BIT
-                #define DebugPrintfThreadIDFormat   "%16p"
-            #else
-                #define DebugPrintfThreadIDFormat   "%8p"
-            #endif
-            #define DebugMsg(inFormat, ...) DebugPrintf("%17qd: " DebugPrintfThreadIDFormat " " inFormat, CAHostTimeBase::GetCurrentTimeInNanos(), pthread_self(), ## __VA_ARGS__) FlushRtn
-        #elif   CoreAudio_TimeStampMessages
-            #include "CAHostTimeBase.h"
-            #define DebugMsg(inFormat, ...) DebugPrintf("%17qd: " inFormat, CAHostTimeBase::GetCurrentTimeInNanos(), ## __VA_ARGS__) FlushRtn
-        #else
-            #define DebugMsg(inFormat, ...) DebugPrintf(inFormat, ## __VA_ARGS__) FlushRtn
-        #endif
-    #endif
-    void    DebugPrint(const char *fmt, ...);   // can be used like printf
-    #ifndef DEBUGPRINT
-        #define DEBUGPRINT(msg) DebugPrint msg      // have to double-parenthesize arglist (see Debugging.h)
-    #endif
-    #if VERBOSE
-        #define vprint(msg) DEBUGPRINT(msg)
-    #else
-        #define vprint(msg)
-    #endif
-
-    // Original macro keeps its function of turning on and off use of CADebuggerStop() for both asserts and throws.
-    // For backwards compat, it overrides any setting of the two sub-macros.
-    #if CoreAudio_StopOnFailure
-        #include "CADebugger.h"
-        #undef CoreAudio_StopOnAssert
-        #define CoreAudio_StopOnAssert 1
-        #undef CoreAudio_StopOnThrow
-        #define CoreAudio_StopOnThrow 1
-        #define STOP    CADebuggerStop()
-    #else
-        #define STOP
-    #endif
-
-    #if CoreAudio_StopOnAssert
-        #if !CoreAudio_StopOnFailure
-            #include "CADebugger.h"
-            #define STOP
-        #endif
-        #define __ASSERT_STOP CADebuggerStop()
-    #else
-        #define __ASSERT_STOP
-    #endif
-
-    #if CoreAudio_StopOnThrow
-        #if !CoreAudio_StopOnFailure
-            #include "CADebugger.h"
-            #define STOP
-        #endif
-        #define __THROW_STOP CADebuggerStop()
-    #else
-        #define __THROW_STOP
-    #endif
-
-#else
-    #define DebugMsg(inFormat, ...)
-    #ifndef DEBUGPRINT
-        #define DEBUGPRINT(msg)
-    #endif
-    #define vprint(msg)
-    #define STOP
-    #define __ASSERT_STOP
-    #define __THROW_STOP
-#endif
-
-//  Old-style numbered DebugMessage calls are implemented in terms of DebugMsg() now
-#define DebugMessage(msg)                                       DebugMsg(msg)
-#define DebugMessageN1(msg, N1)                                 DebugMsg(msg, N1)
-#define DebugMessageN2(msg, N1, N2)                             DebugMsg(msg, N1, N2)
-#define DebugMessageN3(msg, N1, N2, N3)                         DebugMsg(msg, N1, N2, N3)
-#define DebugMessageN4(msg, N1, N2, N3, N4)                     DebugMsg(msg, N1, N2, N3, N4)
-#define DebugMessageN5(msg, N1, N2, N3, N4, N5)                 DebugMsg(msg, N1, N2, N3, N4, N5)
-#define DebugMessageN6(msg, N1, N2, N3, N4, N5, N6)             DebugMsg(msg, N1, N2, N3, N4, N5, N6)
-#define DebugMessageN7(msg, N1, N2, N3, N4, N5, N6, N7)         DebugMsg(msg, N1, N2, N3, N4, N5, N6, N7)
-#define DebugMessageN8(msg, N1, N2, N3, N4, N5, N6, N7, N8)     DebugMsg(msg, N1, N2, N3, N4, N5, N6, N7, N8)
-#define DebugMessageN9(msg, N1, N2, N3, N4, N5, N6, N7, N8, N9) DebugMsg(msg, N1, N2, N3, N4, N5, N6, N7, N8, N9)
-
-void    LogError(const char *fmt, ...);         // writes to syslog (and stderr if debugging)
-void    LogWarning(const char *fmt, ...);       // writes to syslog (and stderr if debugging)
-
-#define NO_ACTION   (void)0
-
-#if DEBUG || CoreAudio_Debug
-
-#pragma mark    Debug Macros
-
-#define Assert(inCondition, inMessage)                                                    \
-            if(!(inCondition))                                                          \
-            {                                                                           \
-                DebugMessage(inMessage);                                                \
-                __ASSERT_STOP;                                                                  \
-            }
-
-#define AssertFileLine(inCondition, inMessage)                                            \
-            if(!(inCondition))                                                          \
-            {                                                                           \
-                DebugMessageN3("%s, line %d: %s", __FILE__, __LINE__, inMessage);       \
-                __ASSERT_STOP;                                                          \
-            }
-
-#define AssertNoError(inError, inMessage)                                             \
-            {                                                                           \
-                SInt32 __Err = (inError);                                               \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    char __4CC[5] = CA4CCToCString(__Err);                              \
-                    DebugMessageN2(inMessage ", Error: %d (%s)", (int)__Err, __4CC);        \
-                    __ASSERT_STOP;                                                      \
-                }                                                                       \
-            }
-
-#define AssertNoKernelError(inError, inMessage)                                           \
-            {                                                                           \
-                unsigned int __Err = (unsigned int)(inError);                           \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    DebugMessageN1(inMessage ", Error: 0x%X", __Err);                   \
-                    __ASSERT_STOP;                                                      \
-                }                                                                       \
-            }
-
-#define AssertNotNULL(inPtr, inMessage)                                                   \
-            {                                                                           \
-                if((inPtr) == NULL)                                                     \
-                {                                                                       \
-                    DebugMessage(inMessage);                                            \
-                    __ASSERT_STOP;                                                      \
-                }                                                                       \
-            }
-
-#define FailIf(inCondition, inHandler, inMessage)                                     \
-            if(inCondition)                                                             \
-            {                                                                           \
-                DebugMessage(inMessage);                                                \
-                STOP;                                                                   \
-                goto inHandler;                                                         \
-            }
-
-#define FailWithAction(inCondition, inAction, inHandler, inMessage)                       \
-            if(inCondition)                                                             \
-            {                                                                           \
-                DebugMessage(inMessage);                                                \
-                STOP;                                                                   \
-                { inAction; }                                                           \
-                goto inHandler;                                                         \
-            }
-
-#define FailIfNULL(inPointer, inAction, inHandler, inMessage)                         \
-            if((inPointer) == NULL)                                                     \
-            {                                                                           \
-                DebugMessage(inMessage);                                                \
-                STOP;                                                                   \
-                { inAction; }                                                           \
-                goto inHandler;                                                         \
-            }
-
-#define FailIfKernelError(inKernelError, inAction, inHandler, inMessage)              \
-            {                                                                           \
-                unsigned int __Err = (inKernelError);                                   \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    DebugMessageN1(inMessage ", Error: 0x%X", __Err);                   \
-                    STOP;                                                               \
-                    { inAction; }                                                       \
-                    goto inHandler;                                                     \
-                }                                                                       \
-            }
-
-#define FailIfError(inError, inAction, inHandler, inMessage)                          \
-            {                                                                           \
-                SInt32 __Err = (inError);                                               \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    char __4CC[5] = CA4CCToCString(__Err);                              \
-                    DebugMessageN2(inMessage ", Error: %ld (%s)", (long int)__Err, __4CC);  \
-                    STOP;                                                               \
-                    { inAction; }                                                       \
-                    goto inHandler;                                                     \
-                }                                                                       \
-            }
-
-#define FailIfNoMessage(inCondition, inHandler, inMessage)                                \
-            if(inCondition)                                                             \
-            {                                                                           \
-                STOP;                                                                   \
-                goto inHandler;                                                         \
-            }
-
-#define FailWithActionNoMessage(inCondition, inAction, inHandler, inMessage)          \
-            if(inCondition)                                                             \
-            {                                                                           \
-                STOP;                                                                   \
-                { inAction; }                                                           \
-                goto inHandler;                                                         \
-            }
-
-#define FailIfNULLNoMessage(inPointer, inAction, inHandler, inMessage)                    \
-            if((inPointer) == NULL)                                                     \
-            {                                                                           \
-                STOP;                                                                   \
-                { inAction; }                                                           \
-                goto inHandler;                                                         \
-            }
-
-#define FailIfKernelErrorNoMessage(inKernelError, inAction, inHandler, inMessage)     \
-            {                                                                           \
-                unsigned int __Err = (inKernelError);                                   \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    STOP;                                                               \
-                    { inAction; }                                                       \
-                    goto inHandler;                                                     \
-                }                                                                       \
-            }
-
-#define FailIfErrorNoMessage(inError, inAction, inHandler, inMessage)                 \
-            {                                                                           \
-                SInt32 __Err = (inError);                                               \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    STOP;                                                               \
-                    { inAction; }                                                       \
-                    goto inHandler;                                                     \
-                }                                                                       \
-            }
-
-#if defined(__cplusplus)
-
-#define CAThrow(inException)  __THROW_STOP; throw (inException)
-
-#define CAThrowIf(inCondition, inException, inMessage)                                  \
-            if(inCondition)                                                             \
-            {                                                                           \
-                DebugMessage(inMessage);                                                \
-                CAThrow(inException);                                                     \
-            }
-
-#define CAThrowIfNULL(inPointer, inException, inMessage)                                    \
-            if((inPointer) == NULL)                                                     \
-            {                                                                           \
-                DebugMessage(inMessage);                                                \
-                CAThrow(inException);                                                     \
-            }
-
-#define CAThrowIfKernelError(inKernelError, inException, inMessage)                     \
-            {                                                                           \
-                int __Err = (inKernelError);                                            \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    DebugMessageN1(inMessage ", Error: 0x%X", __Err);                   \
-                    CAThrow(inException);                                                 \
-                }                                                                       \
-            }
-
-#define CAThrowIfError(inError, inException, inMessage)                                 \
-            {                                                                           \
-                SInt32 __Err = (inError);                                               \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    char __4CC[5] = CA4CCToCString(__Err);                              \
-                    DebugMessageN2(inMessage ", Error: %d (%s)", (int)__Err, __4CC);    \
-                    CAThrow(inException);                                                 \
-                }                                                                       \
-            }
-
-#if TARGET_OS_WIN32
-#define CAThrowIfWinError(inError, inException, inMessage)                              \
-            {                                                                           \
-                HRESULT __Err = (inError);                                              \
-                if(FAILED(__Err))                                                       \
-                {                                                                       \
-                    DebugMessageN2(inMessage ", Code: %d, Facility: 0x%X", HRESULT_CODE(__Err), HRESULT_FACILITY(__Err));           \
-                    CAThrow(inException);                                                 \
-                }                                                                       \
-            }
-#endif
-
-#define SubclassResponsibility(inMethodName, inException)                               \
-            {                                                                           \
-                DebugMessage(inMethodName": Subclasses must implement this method");    \
-                CAThrow(inException);                                                     \
-            }
-
-#endif  //  defined(__cplusplus)
-
-#else
-
-#pragma mark    Release Macros
-
-#define Assert(inCondition, inMessage)                                                    \
-            if(!(inCondition))                                                          \
-            {                                                                           \
-                __ASSERT_STOP;                                                          \
-            }
-
-#define AssertFileLine(inCondition, inMessage) Assert(inCondition, inMessage)
-
-#define AssertNoError(inError, inMessage)                                             \
-            {                                                                           \
-                SInt32 __Err = (inError);                                               \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    __ASSERT_STOP;                                                      \
-                }                                                                       \
-            }
-
-#define AssertNoKernelError(inError, inMessage)                                           \
-            {                                                                           \
-                unsigned int __Err = (unsigned int)(inError);                           \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    __ASSERT_STOP;                                                      \
-                }                                                                       \
-            }
-
-#define AssertNotNULL(inPtr, inMessage)                                                   \
-            {                                                                           \
-                if((inPtr) == NULL)                                                     \
-                {                                                                       \
-                    __ASSERT_STOP;                                                      \
-                }                                                                       \
-            }
-
-#define FailIf(inCondition, inHandler, inMessage)                                     \
-            if(inCondition)                                                             \
-            {                                                                           \
-                STOP;                                                                   \
-                goto inHandler;                                                         \
-            }
-
-#define FailWithAction(inCondition, inAction, inHandler, inMessage)                       \
-            if(inCondition)                                                             \
-            {                                                                           \
-                STOP;                                                                   \
-                { inAction; }                                                           \
-                goto inHandler;                                                         \
-            }
-
-#define FailIfNULL(inPointer, inAction, inHandler, inMessage)                         \
-            if((inPointer) == NULL)                                                     \
-            {                                                                           \
-                STOP;                                                                   \
-                { inAction; }                                                           \
-                goto inHandler;                                                         \
-            }
-
-#define FailIfKernelError(inKernelError, inAction, inHandler, inMessage)              \
-            if((inKernelError) != 0)                                                    \
-            {                                                                           \
-                STOP;                                                                   \
-                { inAction; }                                                           \
-                goto inHandler;                                                         \
-            }
-
-#define FailIfError(inError, inAction, inHandler, inMessage)                          \
-            if((inError) != 0)                                                          \
-            {                                                                           \
-                STOP;                                                                   \
-                { inAction; }                                                           \
-                goto inHandler;                                                         \
-            }
-
-#define FailIfNoMessage(inCondition, inHandler, inMessage)                                \
-            if(inCondition)                                                             \
-            {                                                                           \
-                STOP;                                                                   \
-                goto inHandler;                                                         \
-            }
-
-#define FailWithActionNoMessage(inCondition, inAction, inHandler, inMessage)          \
-            if(inCondition)                                                             \
-            {                                                                           \
-                STOP;                                                                   \
-                { inAction; }                                                           \
-                goto inHandler;                                                         \
-            }
-
-#define FailIfNULLNoMessage(inPointer, inAction, inHandler, inMessage)                    \
-            if((inPointer) == NULL)                                                     \
-            {                                                                           \
-                STOP;                                                                   \
-                { inAction; }                                                           \
-                goto inHandler;                                                         \
-            }
-
-#define FailIfKernelErrorNoMessage(inKernelError, inAction, inHandler, inMessage)     \
-            {                                                                           \
-                unsigned int __Err = (inKernelError);                                   \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    STOP;                                                               \
-                    { inAction; }                                                       \
-                    goto inHandler;                                                     \
-                }                                                                       \
-            }
-
-#define FailIfErrorNoMessage(inError, inAction, inHandler, inMessage)                 \
-            {                                                                           \
-                SInt32 __Err = (inError);                                               \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    STOP;                                                               \
-                    { inAction; }                                                       \
-                    goto inHandler;                                                     \
-                }                                                                       \
-            }
-
-#if defined(__cplusplus)
-
-#define CAThrow(inException)  __THROW_STOP; throw (inException)
-
-#define CAThrowIf(inCondition, inException, inMessage)                                  \
-            if(inCondition)                                                             \
-            {                                                                           \
-                CAThrow(inException);                                                     \
-            }
-
-#define CAThrowIfNULL(inPointer, inException, inMessage)                                    \
-            if((inPointer) == NULL)                                                     \
-            {                                                                           \
-                CAThrow(inException);                                                     \
-            }
-
-#define CAThrowIfKernelError(inKernelError, inException, inMessage)                     \
-            {                                                                           \
-                int __Err = (inKernelError);                                            \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    CAThrow(inException);                                                 \
-                }                                                                       \
-            }
-
-#define CAThrowIfError(inError, inException, inMessage)                                 \
-            {                                                                           \
-                SInt32 __Err = (inError);                                               \
-                if(__Err != 0)                                                          \
-                {                                                                       \
-                    CAThrow(inException);                                                 \
-                }                                                                       \
-            }
-
-#if TARGET_OS_WIN32
-#define CAThrowIfWinError(inError, inException, inMessage)                              \
-            {                                                                           \
-                HRESULT __Err = (inError);                                              \
-                if(FAILED(__Err))                                                       \
-                {                                                                       \
-                    CAThrow(inException);                                                 \
-                }                                                                       \
-            }
-#endif
-
-#define SubclassResponsibility(inMethodName, inException)                               \
-            {                                                                           \
-                CAThrow(inException);                                                     \
-            }
-
-#endif  //  defined(__cplusplus)
-
-#endif  //  DEBUG || CoreAudio_Debug
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugPrintf.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugPrintf.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugPrintf.cpp
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-//==================================================================================================
-//  Includes
-//==================================================================================================
-
-//  Self Include
-#include "CADebugPrintf.h"
-
-#if DEBUG || CoreAudio_Debug
-
-    #if TARGET_OS_WIN32
-        #include <stdarg.h>
-        #include <stdio.h>
-        #include <Windows.h>
-        extern "C"
-        int CAWin32DebugPrintf(char* inFormat, ...)
-        {
-            char theMessage[1024];
-            va_list theArguments;
-            va_start(theArguments, inFormat);
-            _vsnprintf(theMessage, 1024, inFormat, theArguments);
-            va_end(theArguments);
-            OutputDebugString(theMessage);
-            return 0;
-        }
-    #endif
-
-    #if defined(CoreAudio_UseSideFile)
-        #include <unistd.h>
-        FILE* sDebugPrintfSideFile = NULL;
-        extern "C"
-        void OpenDebugPrintfSideFile()
-        {
-            if(sDebugPrintfSideFile == NULL)
-            {
-                char theFileName[1024];
-                snprintf(theFileName, sizeof(theFileName), CoreAudio_UseSideFile, getpid());
-                sDebugPrintfSideFile = fopen(theFileName, "a+");
-                DebugPrintfRtn(DebugPrintfFileComma "\n------------------------------\n");
-            }
-        }
-    #endif
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugPrintf.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugPrintf.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugPrintf.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#if !defined(__CADebugPrintf_h__)
-#define __CADebugPrintf_h__
-
-//=============================================================================
-//  Includes
-//=============================================================================
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreAudio/CoreAudioTypes.h>
-#else
-    #include "CoreAudioTypes.h"
-#endif
-
-//=============================================================================
-//  Macros to redirect debugging output to various logging services
-//=============================================================================
-
-//#define   CoreAudio_UseSideFile   "/CoreAudio-%d.txt"
-
-#if DEBUG || CoreAudio_Debug
-
-    #if TARGET_OS_WIN32
-        #if defined(__cplusplus)
-        extern "C"
-        #endif
-        extern int CAWin32DebugPrintf(char* inFormat, ...);
-        #define DebugPrintfRtn          CAWin32DebugPrintf
-        #define DebugPrintfFile
-        #define DebugPrintfLineEnding   "\n"
-        #define DebugPrintfFileComma
-        #define DebugPrintf(inFormat, ...) CAWin32DebugPrintf(informat "\n", ## __VA_ARGS__)
-    #else
-        #if CoreAudio_UseSysLog
-            #include <sys/syslog.h>
-            #define DebugPrintfRtn  syslog
-            #define DebugPrintfFile LOG_NOTICE
-            #define DebugPrintfLineEnding   ""
-            #define DebugPrintfFileComma    DebugPrintfFile,
-            #define DebugPrintf(inFormat, ...)  DebugPrintfRtn(DebugPrintfFileComma inFormat DebugPrintfLineEnding, ## __VA_ARGS__)
-        #elif defined(CoreAudio_UseSideFile)
-            #include <stdio.h>
-            #if defined(__cplusplus)
-            extern "C"
-            #endif
-            void OpenDebugPrintfSideFile();
-            extern FILE* sDebugPrintfSideFile;
-            #define DebugPrintfRtn  fprintf
-            #define DebugPrintfFile ((sDebugPrintfSideFile != NULL) ? sDebugPrintfSideFile : stderr)
-            #define DebugPrintfLineEnding   "\n"
-            #define DebugPrintfFileComma    DebugPrintfFile,
-            #define DebugPrintf(inFormat, ...)  DebugPrintfRtn(DebugPrintfFileComma inFormat DebugPrintfLineEnding, ## __VA_ARGS__)
-        #elif CoreAudio_UseCALog
-            #include "CALog.h"
-            /* We cannot use 'LOG' for 'DebugPrintfRtn' because it is a concatenating macro itself.  So we have to use syslog here. */
-            #include <sys/syslog.h>
-            #define DebugPrintfRtn syslog
-            #define DebugPrintfFile LOG_NOTICE
-            #define DebugPrintfLineEnding ""
-            #define DebugPrintfFileComma DebugPrintfFile,
-            /* Direct calls to 'DebugPrintf' use the new CALog system */
-            #define DebugPrintf(inFormat, ...)  LOG(kLogPriority_Notice, 0, inFormat, ## __VA_ARGS__)
-        #else
-            #include <stdio.h>
-            #define DebugPrintfRtn  fprintf
-            #define DebugPrintfFile stderr
-            #define DebugPrintfLineEnding   "\n"
-            #define DebugPrintfFileComma    DebugPrintfFile,
-            #define DebugPrintf(inFormat, ...)  DebugPrintfRtn(DebugPrintfFileComma inFormat DebugPrintfLineEnding, ## __VA_ARGS__)
-        #endif
-    #endif
-
-#else
-    #define DebugPrintfRtn
-    #define DebugPrintfFile
-    #define DebugPrintfLineEnding
-    #define DebugPrintfFileComma
-    #define DebugPrintf(inFormat, ...)
-#endif
-
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugger.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugger.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugger.cpp
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-//=============================================================================
-//  Includes
-//=============================================================================
-
-#include "CADebugger.h"
-
-//=============================================================================
-//  CADebugger
-//=============================================================================
-
-#if TARGET_API_MAC_OSX
-
-#include <sys/sysctl.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-bool CAIsDebuggerAttached(void)
-{
-    int                 mib[4];
-    struct kinfo_proc   info;
-    size_t              size;
-
-    mib[0] = CTL_KERN;
-    mib[1] = KERN_PROC;
-    mib[2] = KERN_PROC_PID;
-    mib[3] = getpid();
-    size = sizeof(info);
-    info.kp_proc.p_flag = 0;
-
-    sysctl(mib, 4, &info, &size, NULL, 0);
-
-    return (info.kp_proc.p_flag & P_TRACED) == P_TRACED;
-}
-
-#endif
-
-void    CADebuggerStop(void)
-{
-    #if CoreAudio_Debug
-        #if TARGET_API_MAC_OSX
-            if(CAIsDebuggerAttached())
-            {
-                #if defined(__i386__) || defined(__x86_64__)
-                    asm("int3");
-                #else
-                    __builtin_trap();
-                #endif
-            }
-            else
-            {
-                abort();
-            }
-        #else
-            __debugbreak();
-        #endif
-    #endif
-}
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugger.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugger.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugger.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#if !defined(__CADebugger_h__)
-#define __CADebugger_h__
-
-//=============================================================================
-//  Includes
-//=============================================================================
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreAudio/CoreAudioTypes.h>
-#else
-    #include <CoreAudioTypes.h>
-#endif
-
-//=============================================================================
-//  CADebugger
-//=============================================================================
-
-#if TARGET_API_MAC_OSX
-    extern bool CAIsDebuggerAttached(void);
-#endif
-extern void CADebuggerStop(void);
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAException.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAException.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAException.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#if !defined(__CAException_h__)
-#define __CAException_h__
-
-//=============================================================================
-//  Includes
-//=============================================================================
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreAudio/CoreAudioTypes.h>
-#else
-    #include "CoreAudioTypes.h"
-#endif
-
-//=============================================================================
-//  CAException
-//=============================================================================
-
-class CAException
-{
-
-public:
-                    CAException(OSStatus inError) : mError(inError) {}
-                    CAException(const CAException& inException) : mError(inException.mError) {}
-    CAException&    operator=(const CAException& inException) { mError = inException.mError; return *this; }
-                    ~CAException() {}
-
-    OSStatus        GetError() const { return mError; }
-
-protected:
-    OSStatus        mError;
-};
-
-#define CATry                               try{
-#define CACatch                             } catch(...) {}
-#define CASwallowException(inExpression)    try { inExpression; } catch(...) {}
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAHostTimeBase.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAHostTimeBase.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAHostTimeBase.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-//=============================================================================
-//  Includes
-//=============================================================================
-
-#include "CAHostTimeBase.h"
-
-Float64         CAHostTimeBase::sFrequency = 0;
-Float64         CAHostTimeBase::sInverseFrequency = 0;
-UInt32          CAHostTimeBase::sMinDelta = 0;
-UInt32          CAHostTimeBase::sToNanosNumerator = 0;
-UInt32          CAHostTimeBase::sToNanosDenominator = 0;
-pthread_once_t  CAHostTimeBase::sIsInited = PTHREAD_ONCE_INIT;
-#if Track_Host_TimeBase
-UInt64          CAHostTimeBase::sLastTime = 0;
-#endif
-
-//=============================================================================
-//  CAHostTimeBase
-//
-//  This class provides platform independent access to the host's time base.
-//=============================================================================
-
-void    CAHostTimeBase::Initialize()
-{
-    //  get the info about Absolute time
-    #if TARGET_OS_MAC
-        struct mach_timebase_info   theTimeBaseInfo;
-        mach_timebase_info(&theTimeBaseInfo);
-        sMinDelta = 1;
-        sToNanosNumerator = theTimeBaseInfo.numer;
-        sToNanosDenominator = theTimeBaseInfo.denom;
-
-        //  the frequency of that clock is: (sToNanosDenominator / sToNanosNumerator) * 10^9
-        sFrequency = static_cast<Float64>(sToNanosDenominator) / static_cast<Float64>(sToNanosNumerator);
-        sFrequency *= 1000000000.0;
-    #elif TARGET_OS_WIN32
-        LARGE_INTEGER theFrequency;
-        QueryPerformanceFrequency(&theFrequency);
-        sMinDelta = 1;
-        sToNanosNumerator = 1000000000ULL;
-        sToNanosDenominator = *((UInt64*)&theFrequency);
-        sFrequency = static_cast<Float64>(*((UInt64*)&theFrequency));
-    #endif
-    sInverseFrequency = 1.0 / sFrequency;
-
-    #if Log_Host_Time_Base_Parameters
-        DebugPrintf("Host Time Base Parameters");
-        DebugPrintf(" Minimum Delta:          %lu", (unsigned long)sMinDelta);
-        DebugPrintf(" Frequency:              %f", sFrequency);
-        DebugPrintf(" To Nanos Numerator:     %lu", (unsigned long)sToNanosNumerator);
-        DebugPrintf(" To Nanos Denominator:   %lu", (unsigned long)sToNanosDenominator);
-    #endif
-}
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAHostTimeBase.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAHostTimeBase.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAHostTimeBase.h
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#if !defined(__CAHostTimeBase_h__)
-#define __CAHostTimeBase_h__
-
-//=============================================================================
-//  Includes
-//=============================================================================
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreAudio/CoreAudioTypes.h>
-#else
-    #include <CoreAudioTypes.h>
-#endif
-
-#if TARGET_OS_MAC
-    #include <mach/mach_time.h>
-    #include <pthread.h>
-#elif TARGET_OS_WIN32
-    #include <windows.h>
-    #include "WinPThreadDefs.h"
-#else
-    #error  Unsupported operating system
-#endif
-
-#include "CADebugPrintf.h"
-
-//=============================================================================
-//  CAHostTimeBase
-//
-//  This class provides platform independent access to the host's time base.
-//=============================================================================
-
-#if CoreAudio_Debug
-//  #define Log_Host_Time_Base_Parameters   1
-//  #define Track_Host_TimeBase             1
-#endif
-
-class   CAHostTimeBase
-{
-
-public:
-    static UInt64           ConvertToNanos(UInt64 inHostTime);
-    static UInt64           ConvertFromNanos(UInt64 inNanos);
-
-    static UInt64           GetTheCurrentTime();
-#if TARGET_OS_MAC
-    static UInt64           GetCurrentTime() { return GetTheCurrentTime(); }
-#endif
-    static UInt64           GetCurrentTimeInNanos();
-
-    static Float64          GetFrequency() { pthread_once(&sIsInited, Initialize); return sFrequency; }
-    static Float64          GetInverseFrequency() { pthread_once(&sIsInited, Initialize); return sInverseFrequency; }
-    static UInt32           GetMinimumDelta() { pthread_once(&sIsInited, Initialize); return sMinDelta; }
-
-    static UInt64           AbsoluteHostDeltaToNanos(UInt64 inStartTime, UInt64 inEndTime);
-    static SInt64           HostDeltaToNanos(UInt64 inStartTime, UInt64 inEndTime);
-
-    static UInt64           MultiplyByRatio(UInt64 inMuliplicand, UInt32 inNumerator, UInt32 inDenominator);
-
-private:
-    static void             Initialize();
-
-    static pthread_once_t   sIsInited;
-
-    static Float64          sFrequency;
-    static Float64          sInverseFrequency;
-    static UInt32           sMinDelta;
-    static UInt32           sToNanosNumerator;
-    static UInt32           sToNanosDenominator;
-#if Track_Host_TimeBase
-    static UInt64           sLastTime;
-#endif
-};
-
-inline UInt64   CAHostTimeBase::GetTheCurrentTime()
-{
-    UInt64 theTime = 0;
-
-    #if TARGET_OS_MAC
-        theTime = mach_absolute_time();
-    #elif TARGET_OS_WIN32
-        LARGE_INTEGER theValue;
-        QueryPerformanceCounter(&theValue);
-        theTime = *((UInt64*)&theValue);
-    #endif
-
-    #if Track_Host_TimeBase
-        if(sLastTime != 0)
-        {
-            if(theTime <= sLastTime)
-            {
-                DebugPrintf("CAHostTimeBase::GetTheCurrentTime: the current time is earlier than the last time, now: %qd, then: %qd", theTime, sLastTime);
-            }
-            sLastTime = theTime;
-        }
-        else
-        {
-            sLastTime = theTime;
-        }
-    #endif
-
-    return theTime;
-}
-
-inline UInt64   CAHostTimeBase::ConvertToNanos(UInt64 inHostTime)
-{
-    pthread_once(&sIsInited, Initialize);
-
-    UInt64 theAnswer = MultiplyByRatio(inHostTime, sToNanosNumerator, sToNanosDenominator);
-    #if CoreAudio_Debug
-        if(((sToNanosNumerator > sToNanosDenominator) && (theAnswer < inHostTime)) || ((sToNanosDenominator > sToNanosNumerator) && (theAnswer > inHostTime)))
-        {
-            DebugPrintf("CAHostTimeBase::ConvertToNanos: The conversion wrapped");
-        }
-    #endif
-
-    return theAnswer;
-}
-
-inline UInt64   CAHostTimeBase::ConvertFromNanos(UInt64 inNanos)
-{
-    pthread_once(&sIsInited, Initialize);
-
-    UInt64 theAnswer = MultiplyByRatio(inNanos, sToNanosDenominator, sToNanosNumerator);
-    #if CoreAudio_Debug
-        if(((sToNanosDenominator > sToNanosNumerator) && (theAnswer < inNanos)) || ((sToNanosNumerator > sToNanosDenominator) && (theAnswer > inNanos)))
-        {
-            DebugPrintf("CAHostTimeBase::ConvertFromNanos: The conversion wrapped");
-        }
-    #endif
-
-    return theAnswer;
-}
-
-inline UInt64   CAHostTimeBase::GetCurrentTimeInNanos()
-{
-    return ConvertToNanos(GetTheCurrentTime());
-}
-
-inline UInt64   CAHostTimeBase::AbsoluteHostDeltaToNanos(UInt64 inStartTime, UInt64 inEndTime)
-{
-    UInt64 theAnswer;
-
-    if(inStartTime <= inEndTime)
-    {
-        theAnswer = inEndTime - inStartTime;
-    }
-    else
-    {
-        theAnswer = inStartTime - inEndTime;
-    }
-
-    return ConvertToNanos(theAnswer);
-}
-
-inline SInt64   CAHostTimeBase::HostDeltaToNanos(UInt64 inStartTime, UInt64 inEndTime)
-{
-    SInt64 theAnswer;
-    SInt64 theSign = 1;
-
-    if(inStartTime <= inEndTime)
-    {
-        theAnswer = static_cast<SInt64>(inEndTime - inStartTime);
-    }
-    else
-    {
-        theAnswer = static_cast<SInt64>(inStartTime - inEndTime);
-        theSign = -1;
-    }
-
-    return theSign * static_cast<SInt64>(ConvertToNanos(static_cast<UInt64>(theAnswer)));
-}
-
-inline UInt64   CAHostTimeBase::MultiplyByRatio(UInt64 inMuliplicand, UInt32 inNumerator, UInt32 inDenominator)
-{
-#if TARGET_OS_MAC && TARGET_RT_64_BIT
-    __uint128_t theAnswer = inMuliplicand;
-#else
-    long double theAnswer = inMuliplicand;
-#endif
-    if(inNumerator != inDenominator)
-    {
-        theAnswer *= inNumerator;
-        theAnswer /= inDenominator;
-    }
-    return static_cast<UInt64>(theAnswer);
-}
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CALogMacros.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CALogMacros.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CALogMacros.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#if !defined(__CALogMacros_h__)
-#define __CALogMacros_h__
-
-//=============================================================================
-//  Log Macros
-//=============================================================================
-
-#if CoreAudio_Debug
-
-    #include "CADebugMacros.h"
-    #include "CADebugPrintf.h"
-    #include <stdio.h>
-    #include <string.h>
-
-    #define PrintLine(msg)                      DebugPrintfRtn(DebugPrintfFileComma "%s\n", (msg))
-
-    #define PrintBool(msg, b)                   DebugPrintfRtn(DebugPrintfFileComma "%s%s\n", (msg), (b) ? "true" : "false")
-    #define PrintIndexedBool(msg, i, b)         DebugPrintfRtn(DebugPrintfFileComma "  %s %ld: %s\n", (msg), (long)(i), (b) ? "true" : "false")
-
-    #define PrintToggle(msg, b)                 DebugPrintfRtn(DebugPrintfFileComma "%s%s\n", (msg), (b) ? "on" : "off")
-    #define PrintIndexedToggle(msg, i, b)       DebugPrintfRtn(DebugPrintfFileComma "  %s %ld: %s\n", (msg), (long)(i), (b) ? "on" : "off")
-
-    #define PrintInt(msg, n)                    DebugPrintfRtn(DebugPrintfFileComma "%s%ld\n", (msg), (long)(n))
-    #define PrintIndexedInt(msg, i, n)          DebugPrintfRtn(DebugPrintfFileComma "  %s %ld: %ld\n", (msg), (long)(i), (long)(n))
-
-    #define PrintHex(msg, n)                    DebugPrintfRtn(DebugPrintfFileComma "%s0x%lX\n", (msg), (unsigned long)(n))
-    #define PrintIndexedHex(msg, i, n)          DebugPrintfRtn(DebugPrintfFileComma "  %s %ld: 0x%lX\n", (msg), (long)(i), (unsigned long)(n))
-
-    #define PrintFloat(msg, f)                  DebugPrintfRtn(DebugPrintfFileComma "%s%.6f\n", (msg), (f))
-    #define PrintIndexedFloat(msg, i, f)        DebugPrintfRtn(DebugPrintfFileComma "  %s %ld: %.6f\n", (msg), (long)(i), (f))
-    #define PrintFloatIndexedFloat(msg, i, f)   DebugPrintfRtn(DebugPrintfFileComma "  %s %.6f: %.6f\n", (msg), (i), (f))
-
-    #define PrintString(msg, s)                 DebugPrintfRtn(DebugPrintfFileComma "%s%s\n", (msg), (s))
-    #define PrintIndexedString(msg, i, s)       DebugPrintfRtn(DebugPrintfFileComma "  %s %ld: %s\n", (msg), (long)(i), (s))
-
-    #define PrintPointer(msg, p)                DebugPrintfRtn(DebugPrintfFileComma "%s%p\n", (msg), (p))
-    #define PrintIndexedPointer(msg, i, p)      DebugPrintfRtn(DebugPrintfFileComma "  %s %ld: %p\n", (msg), (long)(i), (p))
-
-    #define Print4CharCode(msg, c)              {                                                                                               \
-                                                    UInt32 __4CC_number = (c);                                                                  \
-                                                    char __4CC_string[5] = CA4CCToCString(__4CC_number);                                        \
-                                                    DebugPrintfRtn(DebugPrintfFileComma "%s'%s'\n", (msg), __4CC_string);                           \
-                                                }
-    #define PrintIndexed4CharCode(msg, i, c)    {                                                                                               \
-                                                    UInt32 __4CC_number = (c);                                                                  \
-                                                    char __4CC_string[5] = CA4CCToCString(__4CC_number);                                        \
-                                                    DebugPrintfRtn(DebugPrintfFileComma "  %s %ld: '%s'\n", (msg), (long)(i), __4CC_string);        \
-                                                }
-
-    #define ErrorLine(s)                        DebugPrintfRtn(DebugPrintfFileComma "%s\n", (s))
-    #define OSErrorLine(s, e)                   {                                                                                               \
-                                                    OSStatus __err_number = (e);                                                                \
-                                                    char __err_string[5] = CA4CCToCString(__err_number);                                        \
-                                                    DebugPrintfRtn(DebugPrintfFileComma "%s, OSStatus code: %s\n", (s), __err_string);              \
-                                                }
-
-    #define MessageIfOSError(e, s)              if((e) != 0) { OSErrorLine(s, e); }
-    #define MessageIfNULL(p, s)                 if((p) == 0) { ErrorLine(s); }
-
-#else
-
-    #define PrintLine(msg)
-
-    #define PrintBool(msg, b)                   (b)
-    #define PrintIndexedBool(msg, i, b)         (b)
-
-    #define PrintInt(msg, n)                    (n)
-    #define PrintIndexedInt(msg, i, n)          (n)
-
-    #define PrintHex(msg, n)                    (n)
-    #define PrintIndexedHex(msg, i, n)          (n)
-
-    #define PrintFloat(msg, f)                  (f)
-    #define PrintIndexedFloat(msg, i, f)        (f)
-    #define PrintFloatIndexedFloat(msg, i, f)   (f)
-
-    #define PrintString(msg, s)                 (s)
-    #define PrintIndexedString(msg, i, s)       (s)
-
-    #define PrintPointer(msg, p)                (p)
-    #define PrintIndexedPointer(msg, i, p)      (p)
-
-    #define Print4CharCode(msg, c)              (c)
-    #define PrintIndexed4CharCode(msg, i, c)    (c)
-
-    #define ErrorLine(s)                        (s)
-    #define OSErrorLine(s, e)                   (e)
-
-    #define MessageIfOSError(e, s)              (e)
-    #define MessageIfNULL(p, s)                 (p)
-
-#endif  //  CoreAudio_Debug
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAMath.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAMath.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAMath.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#ifndef __CAMath_h__
-#define __CAMath_h__
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreAudio/CoreAudioTypes.h>
-#else
-    #include <CoreAudioTypes.h>
-#endif
-
-inline bool fiszero(Float64 f) { return (f == 0.); }
-inline bool fiszero(Float32 f) { return (f == 0.f); }
-
-inline bool fnonzero(Float64 f) { return !fiszero(f); }
-inline bool fnonzero(Float32 f) { return !fiszero(f); }
-
-inline bool fequal(const Float64 &a, const Float64 &b) { return a == b; }
-inline bool fequal(const Float32 &a, const Float32 &b) { return a == b; }
-
-inline bool fnotequal(const Float64 &a, const Float64 &b) { return !fequal(a, b); }
-inline bool fnotequal(const Float32 &a, const Float32 &b) { return !fequal(a, b); }
-
-#endif // __CAMath_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAMutex.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAMutex.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAMutex.cpp
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-//==================================================================================================
-//  Includes
-//==================================================================================================
-
-//  Self Include
-#include "CAMutex.h"
-
-#if TARGET_OS_MAC
-    #include <errno.h>
-#endif
-
-//  PublicUtility Includes
-#include "CADebugMacros.h"
-#include "CAException.h"
-#include "CAHostTimeBase.h"
-
-//==================================================================================================
-//  Logging
-//==================================================================================================
-
-#if CoreAudio_Debug
-//  #define Log_Ownership       1
-//  #define Log_Errors          1
-//  #define Log_LongLatencies   1
-//  #define LongLatencyThreshholdNS 1000000ULL  // nanoseconds
-#endif
-
-//==================================================================================================
-//  CAMutex
-//==================================================================================================
-
-CAMutex::CAMutex(const char* inName)
-:
-    mName(inName),
-    mOwner(0)
-{
-#if TARGET_OS_MAC
-    OSStatus theError = pthread_mutex_init(&mMutex, NULL);
-    ThrowIf(theError != 0, CAException(theError), "CAMutex::CAMutex: Could not init the mutex");
-
-    #if Log_Ownership
-        DebugPrintf("%p %.4f: CAMutex::CAMutex: creating %s, owner: %p\n", pthread_self(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), mName, mOwner);
-    #endif
-#elif TARGET_OS_WIN32
-    mMutex = CreateMutex(NULL, false, NULL);
-    ThrowIfNULL(mMutex, CAException(GetLastError()), "CAMutex::CAMutex: could not create the mutex.");
-
-    #if Log_Ownership
-        DebugPrintf("%lu %.4f: CAMutex::CAMutex: creating %s, owner: %lu\n", GetCurrentThreadId(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), mName, mOwner);
-    #endif
-#endif
-}
-
-CAMutex::~CAMutex()
-{
-#if TARGET_OS_MAC
-    #if Log_Ownership
-        DebugPrintf("%p %.4f: CAMutex::~CAMutex: destroying %s, owner: %p\n", pthread_self(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), mName, mOwner);
-    #endif
-    pthread_mutex_destroy(&mMutex);
-#elif TARGET_OS_WIN32
-    #if Log_Ownership
-        DebugPrintf("%lu %.4f: CAMutex::~CAMutex: destroying %s, owner: %lu\n", GetCurrentThreadId(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), mName, mOwner);
-    #endif
-    if(mMutex != NULL)
-    {
-        CloseHandle(mMutex);
-    }
-#endif
-}
-
-bool    CAMutex::Lock()
-{
-    bool theAnswer = false;
-
-#if TARGET_OS_MAC
-    pthread_t theCurrentThread = pthread_self();
-    if(!pthread_equal(theCurrentThread, mOwner))
-    {
-        #if Log_Ownership
-            DebugPrintf("%p %.4f: CAMutex::Lock: thread %p is locking %s, owner: %p\n", theCurrentThread, ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), theCurrentThread, mName, mOwner);
-        #endif
-
-        #if Log_LongLatencies
-            UInt64 lockTryTime = CAHostTimeBase::GetCurrentTimeInNanos();
-        #endif
-
-        OSStatus theError = pthread_mutex_lock(&mMutex);
-        ThrowIf(theError != 0, CAException(theError), "CAMutex::Lock: Could not lock the mutex");
-        mOwner = theCurrentThread;
-        theAnswer = true;
-
-        #if Log_LongLatencies
-            UInt64 lockAcquireTime = CAHostTimeBase::GetCurrentTimeInNanos();
-            if (lockAcquireTime - lockTryTime >= LongLatencyThresholdNS)
-                DebugPrintf("Thread %p took %.6fs to acquire the lock %s\n", theCurrentThread, (lockAcquireTime - lockTryTime) * 1.0e-9 /* nanos to seconds */, mName);
-        #endif
-
-        #if Log_Ownership
-            DebugPrintf("%p %.4f: CAMutex::Lock: thread %p has locked %s, owner: %p\n", pthread_self(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), pthread_self(), mName, mOwner);
-        #endif
-    }
-#elif TARGET_OS_WIN32
-    if(mOwner != GetCurrentThreadId())
-    {
-        #if Log_Ownership
-            DebugPrintf("%lu %.4f: CAMutex::Lock: thread %lu is locking %s, owner: %lu\n", GetCurrentThreadId(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), GetCurrentThreadId(), mName, mOwner);
-        #endif
-
-        OSStatus theError = WaitForSingleObject(mMutex, INFINITE);
-        ThrowIfError(theError, CAException(theError), "CAMutex::Lock: could not lock the mutex");
-        mOwner = GetCurrentThreadId();
-        theAnswer = true;
-
-        #if Log_Ownership
-            DebugPrintf("%lu %.4f: CAMutex::Lock: thread %lu has locked %s, owner: %lu\n", GetCurrentThreadId(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), GetCurrentThreadId(), mName, mOwner);
-        #endif
-    }
-#endif
-
-    return theAnswer;
-}
-
-void    CAMutex::Unlock()
-{
-#if TARGET_OS_MAC
-    if(pthread_equal(pthread_self(), mOwner))
-    {
-        #if Log_Ownership
-            DebugPrintf("%p %.4f: CAMutex::Unlock: thread %p is unlocking %s, owner: %p\n", pthread_self(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), pthread_self(), mName, mOwner);
-        #endif
-
-        mOwner = 0;
-        OSStatus theError = pthread_mutex_unlock(&mMutex);
-        ThrowIf(theError != 0, CAException(theError), "CAMutex::Unlock: Could not unlock the mutex");
-
-        #if Log_Ownership
-            DebugPrintf("%p %.4f: CAMutex::Unlock: thread %p has unlocked %s, owner: %p\n", pthread_self(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), pthread_self(), mName, mOwner);
-        #endif
-    }
-    else
-    {
-        DebugMessage("CAMutex::Unlock: A thread is attempting to unlock a Mutex it doesn't own");
-    }
-#elif TARGET_OS_WIN32
-    if(mOwner == GetCurrentThreadId())
-    {
-        #if Log_Ownership
-            DebugPrintf("%lu %.4f: CAMutex::Unlock: thread %lu is unlocking %s, owner: %lu\n", GetCurrentThreadId(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), GetCurrentThreadId(), mName, mOwner);
-        #endif
-
-        mOwner = 0;
-        bool wasReleased = ReleaseMutex(mMutex);
-        ThrowIf(!wasReleased, CAException(GetLastError()), "CAMutex::Unlock: Could not unlock the mutex");
-
-        #if Log_Ownership
-            DebugPrintf("%lu %.4f: CAMutex::Unlock: thread %lu has unlocked %s, owner: %lu\n", GetCurrentThreadId(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), GetCurrentThreadId(), mName, mOwner);
-        #endif
-    }
-    else
-    {
-        DebugMessage("CAMutex::Unlock: A thread is attempting to unlock a Mutex it doesn't own");
-    }
-#endif
-}
-
-bool    CAMutex::Try(bool& outWasLocked)
-{
-    bool theAnswer = false;
-    outWasLocked = false;
-
-#if TARGET_OS_MAC
-    pthread_t theCurrentThread = pthread_self();
-    if(!pthread_equal(theCurrentThread, mOwner))
-    {
-        //  this means the current thread doesn't already own the lock
-        #if Log_Ownership
-            DebugPrintf("%p %.4f: CAMutex::Try: thread %p is try-locking %s, owner: %p\n", theCurrentThread, ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), theCurrentThread, mName, mOwner);
-        #endif
-
-        //  go ahead and call trylock to see if we can lock it.
-        int theError = pthread_mutex_trylock(&mMutex);
-        if(theError == 0)
-        {
-            //  return value of 0 means we successfully locked the lock
-            mOwner = theCurrentThread;
-            theAnswer = true;
-            outWasLocked = true;
-
-            #if Log_Ownership
-                DebugPrintf("%p %.4f: CAMutex::Try: thread %p has locked %s, owner: %p\n", theCurrentThread, ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), theCurrentThread, mName, mOwner);
-            #endif
-        }
-        else if(theError == EBUSY)
-        {
-            //  return value of EBUSY means that the lock was already locked by another thread
-            theAnswer = false;
-            outWasLocked = false;
-
-            #if Log_Ownership
-                DebugPrintf("%p %.4f: CAMutex::Try: thread %p failed to lock %s, owner: %p\n", theCurrentThread, ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), theCurrentThread, mName, mOwner);
-            #endif
-        }
-        else
-        {
-            //  any other return value means something really bad happenned
-            ThrowIfError(theError, CAException(theError), "CAMutex::Try: call to pthread_mutex_trylock failed");
-        }
-    }
-    else
-    {
-        //  this means the current thread already owns the lock
-        theAnswer = true;
-        outWasLocked = false;
-    }
-#elif TARGET_OS_WIN32
-    if(mOwner != GetCurrentThreadId())
-    {
-        //  this means the current thread doesn't own the lock
-        #if Log_Ownership
-            DebugPrintf("%lu %.4f: CAMutex::Try: thread %lu is try-locking %s, owner: %lu\n", GetCurrentThreadId(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), GetCurrentThreadId(), mName, mOwner);
-        #endif
-
-        //  try to acquire the mutex
-        OSStatus theError = WaitForSingleObject(mMutex, 0);
-        if(theError == WAIT_OBJECT_0)
-        {
-            //  this means we successfully locked the lock
-            mOwner = GetCurrentThreadId();
-            theAnswer = true;
-            outWasLocked = true;
-
-            #if Log_Ownership
-                DebugPrintf("%lu %.4f: CAMutex::Try: thread %lu has locked %s, owner: %lu\n", GetCurrentThreadId(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), GetCurrentThreadId(), mName, mOwner);
-            #endif
-        }
-        else if(theError == WAIT_TIMEOUT)
-        {
-            //  this means that the lock was already locked by another thread
-            theAnswer = false;
-            outWasLocked = false;
-
-            #if Log_Ownership
-                DebugPrintf("%lu %.4f: CAMutex::Try: thread %lu failed to lock %s, owner: %lu\n", GetCurrentThreadId(), ((Float64)(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000000.0), GetCurrentThreadId(), mName, mOwner);
-            #endif
-        }
-        else
-        {
-            //  any other return value means something really bad happenned
-            ThrowIfError(theError, CAException(GetLastError()), "CAMutex::Try: call to lock the mutex failed");
-        }
-    }
-    else
-    {
-        //  this means the current thread already owns the lock
-        theAnswer = true;
-        outWasLocked = false;
-    }
-#endif
-
-    return theAnswer;
-}
-
-bool    CAMutex::IsFree() const
-{
-    return mOwner == 0;
-}
-
-bool    CAMutex::IsOwnedByCurrentThread() const
-{
-    bool theAnswer = true;
-
-#if TARGET_OS_MAC
-    theAnswer = pthread_equal(pthread_self(), mOwner);
-#elif TARGET_OS_WIN32
-    theAnswer = (mOwner == GetCurrentThreadId());
-#endif
-
-    return theAnswer;
-}
-
-
-CAMutex::Unlocker::Unlocker(CAMutex& inMutex)
-:   mMutex(inMutex),
-    mNeedsLock(false)
-{
-    Assert(mMutex.IsOwnedByCurrentThread(), "Major problem: Unlocker attempted to unlock a mutex not owned by the current thread!");
-
-    mMutex.Unlock();
-    mNeedsLock = true;
-}
-
-CAMutex::Unlocker::~Unlocker()
-{
-    if(mNeedsLock)
-    {
-        mMutex.Lock();
-    }
-}
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAMutex.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAMutex.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAMutex.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#ifndef __CAMutex_h__
-#define __CAMutex_h__
-
-//==================================================================================================
-//  Includes
-//==================================================================================================
-
-//  System Includes
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreAudio/CoreAudioTypes.h>
-#else
-    #include <CoreAudioTypes.h>
-#endif
-
-#if TARGET_OS_MAC
-    #include <pthread.h>
-#elif TARGET_OS_WIN32
-    #include <windows.h>
-#else
-    #error  Unsupported operating system
-#endif
-
-//==================================================================================================
-//  A recursive mutex.
-//==================================================================================================
-
-class   CAMutex
-{
-//  Construction/Destruction
-public:
-                    CAMutex(const char* inName);
-    virtual         ~CAMutex();
-
-//  Actions
-public:
-    virtual bool    Lock();
-    virtual void    Unlock();
-    virtual bool    Try(bool& outWasLocked);    // returns true if lock is free, false if not
-
-    virtual bool    IsFree() const;
-    virtual bool    IsOwnedByCurrentThread() const;
-
-//  Implementation
-protected:
-    const char*     mName;
-#if TARGET_OS_MAC
-    pthread_t       mOwner;
-    pthread_mutex_t mMutex;
-#elif TARGET_OS_WIN32
-    UInt32          mOwner;
-    HANDLE          mMutex;
-#endif
-
-//  Helper class to manage taking and releasing recursively
-public:
-    class           Locker
-    {
-
-    //  Construction/Destruction
-    public:
-                    Locker(CAMutex& inMutex) : mMutex(&inMutex), mNeedsRelease(false) { mNeedsRelease = mMutex->Lock(); }
-                    Locker(CAMutex* inMutex) : mMutex(inMutex), mNeedsRelease(false) { mNeedsRelease = (mMutex != NULL && mMutex->Lock()); }
-                        // in this case the mutex can be null
-                    ~Locker() { if(mNeedsRelease) { mMutex->Unlock(); } }
-
-
-    private:
-                    Locker(const Locker&);
-        Locker&     operator=(const Locker&);
-
-    //  Implementation
-    private:
-        CAMutex*    mMutex;
-        bool        mNeedsRelease;
-
-    };
-
-// Unlocker
-    class Unlocker
-    {
-    public:
-                        Unlocker(CAMutex& inMutex);
-                        ~Unlocker();
-
-    private:
-        CAMutex&    mMutex;
-        bool        mNeedsLock;
-
-        // Hidden definitions of copy ctor, assignment operator
-        Unlocker(const Unlocker& copy);             // Not implemented
-        Unlocker& operator=(const Unlocker& copy);  // Not implemented
-    };
-
-// you can use this with Try - if you take the lock in try, pass in the outWasLocked var
-    class Tryer {
-
-    //  Construction/Destruction
-    public:
-        Tryer (CAMutex &mutex) : mMutex(mutex), mNeedsRelease(false), mHasLock(false) { mHasLock = mMutex.Try (mNeedsRelease); }
-        ~Tryer () { if (mNeedsRelease) mMutex.Unlock(); }
-
-        bool HasLock () const { return mHasLock; }
-
-    private:
-                    Tryer(const Tryer&);
-        Tryer&      operator=(const Tryer&);
-
-    //  Implementation
-    private:
-        CAMutex &       mMutex;
-        bool            mNeedsRelease;
-        bool            mHasLock;
-    };
-};
-
-
-#endif // __CAMutex_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAReferenceCounted.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAReferenceCounted.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAReferenceCounted.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#ifndef __CAReferenceCounted_h__
-#define __CAReferenceCounted_h__
-
-#include "CAAtomic.h"
-
-// base class for reference-counted objects
-class CAReferenceCounted {
-public:
-    CAReferenceCounted() : mRefCount(1) {}
-
-    void    retain() { CAAtomicIncrement32(&mRefCount); }
-
-    void    release()
-            {
-                SInt32 rc = CAAtomicDecrement32(&mRefCount);
-                if (rc == 0) {
-                    releaseObject();
-                }
-            }
-
-
-    class Retainer {
-    public:
-        Retainer(CAReferenceCounted *obj) : mObject(obj) { mObject->retain(); }
-        ~Retainer() { mObject->release(); }
-
-    private:
-        CAReferenceCounted *    mObject;
-    };
-
-protected:
-    virtual ~CAReferenceCounted() { }
-
-    virtual void releaseObject ()
-            {
-                delete this;
-            }
-
-#if DEBUG
-public:
-#endif
-    SInt32  GetReferenceCount() const { return mRefCount; }
-private:
-    SInt32      mRefCount;
-
-    CAReferenceCounted(const CAReferenceCounted &a);
-    CAReferenceCounted &operator=(const CAReferenceCounted &a);
-};
-
-
-#endif // __CAReferenceCounted_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CASpectralProcessor.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CASpectralProcessor.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CASpectralProcessor.cpp
+++ /dev/null
@@ -1,376 +0,0 @@
-/*
-     File: CASpectralProcessor.cpp
- Abstract: CASpectralProcessor.h
-  Version: 1.1
-
- Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple
- Inc. ("Apple") in consideration of your agreement to the following
- terms, and your use, installation, modification or redistribution of
- this Apple software constitutes acceptance of these terms.  If you do
- not agree with these terms, please do not use, install, modify or
- redistribute this Apple software.
-
- In consideration of your agreement to abide by the following terms, and
- subject to these terms, Apple grants you a personal, non-exclusive
- license, under Apple's copyrights in this original Apple software (the
- "Apple Software"), to use, reproduce, modify and redistribute the Apple
- Software, with or without modifications, in source and/or binary forms;
- provided that if you redistribute the Apple Software in its entirety and
- without modifications, you must retain this notice and the following
- text and disclaimers in all such redistributions of the Apple Software.
- Neither the name, trademarks, service marks or logos of Apple Inc. may
- be used to endorse or promote products derived from the Apple Software
- without specific prior written permission from Apple.  Except as
- expressly stated in this notice, no other rights or licenses, express or
- implied, are granted by Apple herein, including but not limited to any
- patent rights that may be infringed by your derivative works or by other
- works in which the Apple Software may be incorporated.
-
- The Apple Software is provided by Apple on an "AS IS" basis.  APPLE
- MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
- THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
- FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
- OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
-
- IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
- OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
- MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
- AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
- STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
- POSSIBILITY OF SUCH DAMAGE.
-
- Copyright (C) 2014 Apple Inc. All Rights Reserved.
-
-*/
-
-//#include "AudioFormulas.h"
-#include "CASpectralProcessor.h"
-#include "CABitOperations.h"
-
-
-#include <Accelerate/Accelerate.h>
-
-
-#define OFFSETOF(class, field)((size_t)&((class*)0)->field)
-
-CASpectralProcessor::CASpectralProcessor(UInt32 inFFTSize, UInt32 inHopSize, UInt32 inNumChannels, UInt32 inMaxFrames)
-    : mFFTSize(inFFTSize), mHopSize(inHopSize), mNumChannels(inNumChannels), mMaxFrames(inMaxFrames),
-    mLog2FFTSize(Log2Ceil(mFFTSize)),
-    mFFTMask(mFFTSize - 1),
-    mFFTByteSize(mFFTSize * sizeof(Float32)),
-    mIOBufSize(NextPowerOfTwo(mFFTSize + mMaxFrames)),
-    mIOMask(mIOBufSize - 1),
-    mInputSize(0),
-    mInputPos(0), mOutputPos(-mFFTSize & mIOMask),
-    mInFFTPos(0), mOutFFTPos(0),
-    mSpectralFunction(0), mUserData(0)
-{
-    mWindow.alloc(mFFTSize, false);
-    SineWindow(); // set default window.
-
-    mChannels.alloc(mNumChannels);
-    mSpectralBufferList.allocBytes(OFFSETOF(SpectralBufferList, mDSPSplitComplex[mNumChannels]), true);
-    mSpectralBufferList->mNumberSpectra = mNumChannels;
-    for (UInt32 i = 0; i < mNumChannels; ++i)
-    {
-        mChannels[i].mInputBuf.alloc(mIOBufSize, true);
-        mChannels[i].mOutputBuf.alloc(mIOBufSize, true);
-        mChannels[i].mFFTBuf.alloc(mFFTSize, true);
-        mChannels[i].mSplitFFTBuf.alloc(mFFTSize, true);
-        mSpectralBufferList->mDSPSplitComplex[i].realp = mChannels[i].mSplitFFTBuf();
-        mSpectralBufferList->mDSPSplitComplex[i].imagp = mChannels[i].mSplitFFTBuf() + (mFFTSize >> 1);
-    }
-
-    mFFTSetup = vDSP_create_fftsetup (mLog2FFTSize, FFT_RADIX2);
-
-}
-
-CASpectralProcessor::~CASpectralProcessor()
-{
-    mWindow.free();
-    mChannels.free();
-    mSpectralBufferList.free();
-    vDSP_destroy_fftsetup(mFFTSetup);
-}
-
-void CASpectralProcessor::Reset()
-{
-    mInputPos = 0;
-    mOutputPos = -mFFTSize & mIOMask;
-    mInFFTPos = 0;
-    mOutFFTPos = 0;
-
-    for (UInt32 i = 0; i < mNumChannels; ++i)
-    {
-        memset(mChannels[i].mInputBuf(), 0, mIOBufSize * sizeof(Float32));
-        memset(mChannels[i].mOutputBuf(), 0, mIOBufSize * sizeof(Float32));
-        memset(mChannels[i].mFFTBuf(), 0, mFFTSize * sizeof(Float32));
-    }
-}
-
-const double two_pi = 2. * M_PI;
-
-void CASpectralProcessor::HanningWindow()
-{
-    // this is also vector optimized
-
-    double w = two_pi / (double)(mFFTSize - 1);
-    for (UInt32 i = 0; i < mFFTSize; ++i)
-    {
-        mWindow[i] = (0.5 - 0.5 * cos(w * (double)i));
-    }
-}
-
-void CASpectralProcessor::SineWindow()
-{
-    double w = M_PI / (double)(mFFTSize - 1);
-    for (UInt32 i = 0; i < mFFTSize; ++i)
-    {
-        mWindow[i] = sin(w * (double)i);
-    }
-}
-
-void CASpectralProcessor::Process(UInt32 inNumFrames, AudioBufferList* inInput, AudioBufferList* outOutput)
-{
-    // copy from buffer list to input buffer
-    CopyInput(inNumFrames, inInput);
-
-    // if enough input to process, then process.
-    while (mInputSize >= mFFTSize)
-    {
-        CopyInputToFFT(); // copy from input buffer to fft buffer
-        DoWindowing();
-        DoFwdFFT();
-        ProcessSpectrum(mFFTSize, mSpectralBufferList());
-        DoInvFFT();
-        DoWindowing();
-        OverlapAddOutput();
-    }
-
-    // copy from output buffer to buffer list
-    CopyOutput(inNumFrames, outOutput);
-}
-
-void CASpectralProcessor::DoWindowing()
-{
-    Float32 *win = mWindow();
-    if (!win) return;
-    for (UInt32 i=0; i<mNumChannels; ++i) {
-        Float32 *x = mChannels[i].mFFTBuf();
-        vDSP_vmul(x, 1, win, 1, x, 1, mFFTSize);
-    }
-    //printf("DoWindowing %g %g\n", mChannels[0].mFFTBuf()[0], mChannels[0].mFFTBuf()[200]);
-}
-
-
-
-void CASpectralProcessor::CopyInput(UInt32 inNumFrames, AudioBufferList* inInput)
-{
-    UInt32 numBytes = inNumFrames * sizeof(Float32);
-    UInt32 firstPart = mIOBufSize - mInputPos;
-
-
-    if (firstPart < inNumFrames) {
-        UInt32 firstPartBytes = firstPart * sizeof(Float32);
-        UInt32 secondPartBytes = numBytes - firstPartBytes;
-        for (UInt32 i=0; i<mNumChannels; ++i) {
-            memcpy(mChannels[i].mInputBuf + mInputPos, inInput->mBuffers[i].mData, firstPartBytes);
-            memcpy(mChannels[i].mInputBuf, (UInt8*)inInput->mBuffers[i].mData + firstPartBytes, secondPartBytes);
-        }
-    } else {
-        UInt32 numBytes = inNumFrames * sizeof(Float32);
-        for (UInt32 i=0; i<mNumChannels; ++i) {
-            memcpy(mChannels[i].mInputBuf + mInputPos, inInput->mBuffers[i].mData, numBytes);
-        }
-    }
-    //printf("CopyInput %g %g\n", mChannels[0].mInputBuf[mInputPos], mChannels[0].mInputBuf[(mInputPos + 200) & mIOMask]);
-    //printf("CopyInput mInputPos %u   mIOBufSize %u\n", (unsigned)mInputPos, (unsigned)mIOBufSize);
-    mInputSize += inNumFrames;
-    mInputPos = (mInputPos + inNumFrames) & mIOMask;
-}
-
-void CASpectralProcessor::CopyOutput(UInt32 inNumFrames, AudioBufferList* outOutput)
-{
-    //printf("->CopyOutput %g %g\n", mChannels[0].mOutputBuf[mOutputPos], mChannels[0].mOutputBuf[(mOutputPos + 200) & mIOMask]);
-    //printf("CopyOutput mOutputPos %u\n", (unsigned)mOutputPos);
-    UInt32 numBytes = inNumFrames * sizeof(Float32);
-    UInt32 firstPart = mIOBufSize - mOutputPos;
-    if (firstPart < inNumFrames) {
-        UInt32 firstPartBytes = firstPart * sizeof(Float32);
-        UInt32 secondPartBytes = numBytes - firstPartBytes;
-        for (UInt32 i=0; i<mNumChannels; ++i) {
-            memcpy(outOutput->mBuffers[i].mData, mChannels[i].mOutputBuf + mOutputPos, firstPartBytes);
-            memcpy((UInt8*)outOutput->mBuffers[i].mData + firstPartBytes, mChannels[i].mOutputBuf, secondPartBytes);
-            memset(mChannels[i].mOutputBuf + mOutputPos, 0, firstPartBytes);
-            memset(mChannels[i].mOutputBuf, 0, secondPartBytes);
-        }
-    } else {
-        for (UInt32 i=0; i<mNumChannels; ++i) {
-            memcpy(outOutput->mBuffers[i].mData, mChannels[i].mOutputBuf + mOutputPos, numBytes);
-            memset(mChannels[i].mOutputBuf + mOutputPos, 0, numBytes);
-        }
-    }
-    //printf("<-CopyOutput %g %g\n", ((Float32*)outOutput->mBuffers[0].mData)[0], ((Float32*)outOutput->mBuffers[0].mData)[200]);
-    mOutputPos = (mOutputPos + inNumFrames) & mIOMask;
-}
-
-void CASpectralProcessor::PrintSpectralBufferList()
-{
-    UInt32 half = mFFTSize >> 1;
-    for (UInt32 i=0; i<mNumChannels; ++i) {
-        DSPSplitComplex &freqData = mSpectralBufferList->mDSPSplitComplex[i];
-
-        for (UInt32 j=0; j<half; j++){
-            printf(" bin[%d]: %lf + %lfi\n", (int) j, freqData.realp[j], freqData.imagp[j]);
-        }
-    }
-}
-
-
-void CASpectralProcessor::CopyInputToFFT()
-{
-    //printf("CopyInputToFFT mInFFTPos %u\n", (unsigned)mInFFTPos);
-    UInt32 firstPart = mIOBufSize - mInFFTPos;
-    UInt32 firstPartBytes = firstPart * sizeof(Float32);
-    if (firstPartBytes < mFFTByteSize) {
-        UInt32 secondPartBytes = mFFTByteSize - firstPartBytes;
-        for (UInt32 i=0; i<mNumChannels; ++i) {
-            memcpy(mChannels[i].mFFTBuf(), mChannels[i].mInputBuf() + mInFFTPos, firstPartBytes);
-            memcpy((UInt8*)mChannels[i].mFFTBuf() + firstPartBytes, mChannels[i].mInputBuf(), secondPartBytes);
-        }
-    } else {
-        for (UInt32 i=0; i<mNumChannels; ++i) {
-            memcpy(mChannels[i].mFFTBuf(), mChannels[i].mInputBuf() + mInFFTPos, mFFTByteSize);
-        }
-    }
-    mInputSize -= mHopSize;
-    mInFFTPos = (mInFFTPos + mHopSize) & mIOMask;
-    //printf("CopyInputToFFT %g %g\n", mChannels[0].mFFTBuf()[0], mChannels[0].mFFTBuf()[200]);
-}
-
-void CASpectralProcessor::OverlapAddOutput()
-{
-    //printf("OverlapAddOutput mOutFFTPos %u\n", (unsigned)mOutFFTPos);
-    UInt32 firstPart = mIOBufSize - mOutFFTPos;
-    if (firstPart < mFFTSize) {
-        UInt32 secondPart = mFFTSize - firstPart;
-        for (UInt32 i=0; i<mNumChannels; ++i) {
-            float* out1 = mChannels[i].mOutputBuf() + mOutFFTPos;
-            vDSP_vadd(out1, 1, mChannels[i].mFFTBuf(), 1, out1, 1, firstPart);
-            float* out2 = mChannels[i].mOutputBuf();
-            vDSP_vadd(out2, 1, mChannels[i].mFFTBuf() + firstPart, 1, out2, 1, secondPart);
-        }
-    } else {
-        for (UInt32 i=0; i<mNumChannels; ++i) {
-            float* out1 = mChannels[i].mOutputBuf() + mOutFFTPos;
-            vDSP_vadd(out1, 1, mChannels[i].mFFTBuf(), 1, out1, 1, mFFTSize);
-        }
-    }
-    //printf("OverlapAddOutput %g %g\n", mChannels[0].mOutputBuf[mOutFFTPos], mChannels[0].mOutputBuf[(mOutFFTPos + 200) & mIOMask]);
-    mOutFFTPos = (mOutFFTPos + mHopSize) & mIOMask;
-}
-
-
-void CASpectralProcessor::DoFwdFFT()
-{
-    //printf("->DoFwdFFT %g %g\n", mChannels[0].mFFTBuf()[0], mChannels[0].mFFTBuf()[200]);
-    UInt32 half = mFFTSize >> 1;
-    for (UInt32 i=0; i<mNumChannels; ++i)
-    {
-        vDSP_ctoz((DSPComplex*)mChannels[i].mFFTBuf(), 2, &mSpectralBufferList->mDSPSplitComplex[i], 1, half);
-        vDSP_fft_zrip(mFFTSetup, &mSpectralBufferList->mDSPSplitComplex[i], 1, mLog2FFTSize, FFT_FORWARD);
-    }
-    //printf("<-DoFwdFFT %g %g\n", direction, mChannels[0].mFFTBuf()[0], mChannels[0].mFFTBuf()[200]);
-}
-
-void CASpectralProcessor::DoInvFFT()
-{
-    //printf("->DoInvFFT %g %g\n", mChannels[0].mFFTBuf()[0], mChannels[0].mFFTBuf()[200]);
-    UInt32 half = mFFTSize >> 1;
-    for (UInt32 i=0; i<mNumChannels; ++i)
-    {
-        vDSP_fft_zrip(mFFTSetup, &mSpectralBufferList->mDSPSplitComplex[i], 1, mLog2FFTSize, FFT_INVERSE);
-        vDSP_ztoc(&mSpectralBufferList->mDSPSplitComplex[i], 1, (DSPComplex*)mChannels[i].mFFTBuf(), 2, half);
-        float scale = 0.5 / mFFTSize;
-        vDSP_vsmul(mChannels[i].mFFTBuf(), 1, &scale, mChannels[i].mFFTBuf(), 1, mFFTSize );
-    }
-    //printf("<-DoInvFFT %g %g\n", direction, mChannels[0].mFFTBuf()[0], mChannels[0].mFFTBuf()[200]);
-}
-
-void CASpectralProcessor::SetSpectralFunction(SpectralFunction inFunction, void* inUserData)
-{
-    mSpectralFunction = inFunction;
-    mUserData = inUserData;
-}
-
-void CASpectralProcessor::ProcessSpectrum(UInt32 inFFTSize, SpectralBufferList* inSpectra)
-{
-    if (mSpectralFunction)
-        (mSpectralFunction)(inSpectra, mUserData);
-}
-
-#pragma mark ___Utility___
-
-void CASpectralProcessor::GetMagnitude(AudioBufferList* list, Float32* min, Float32* max)
-{
-    UInt32 half = mFFTSize >> 1;
-    for (UInt32 i=0; i<mNumChannels; ++i) {
-        DSPSplitComplex &freqData = mSpectralBufferList->mDSPSplitComplex[i];
-
-        Float32* b = (Float32*) list->mBuffers[i].mData;
-
-        vDSP_zvabs(&freqData,1,b,1,half);
-
-        vDSP_maxmgv(b, 1, &max[i], half);
-        vDSP_minmgv(b, 1, &min[i], half);
-
-   }
-}
-
-
-void CASpectralProcessor::GetFrequencies(Float32* freqs, Float32 sampleRate)
-{
-    UInt32 half = mFFTSize >> 1;
-
-    for (UInt32 i=0; i< half; i++){
-        freqs[i] = ((Float32)(i))*sampleRate/((Float32)mFFTSize);
-    }
-}
-
-
-bool CASpectralProcessor::ProcessForwards(UInt32 inNumFrames, AudioBufferList* inInput)
-{
-    // copy from buffer list to input buffer
-    CopyInput(inNumFrames, inInput);
-
-    bool processed = false;
-    // if enough input to process, then process.
-    while (mInputSize >= mFFTSize)
-    {
-        CopyInputToFFT(); // copy from input buffer to fft buffer
-        DoWindowing();
-        DoFwdFFT();
-        ProcessSpectrum(mFFTSize, mSpectralBufferList()); // here you would copy the fft results out to a buffer indicated in mUserData, say for sonogram drawing
-        processed = true;
-    }
-
-    return processed;
-}
-
-bool CASpectralProcessor::ProcessBackwards(UInt32 inNumFrames, AudioBufferList* outOutput)
-{
-
-    ProcessSpectrum(mFFTSize, mSpectralBufferList());
-    DoInvFFT();
-    DoWindowing();
-    OverlapAddOutput();
-
-    // copy from output buffer to buffer list
-    CopyOutput(inNumFrames, outOutput);
-
-    return true;
-}
-
-
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CASpectralProcessor.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CASpectralProcessor.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CASpectralProcessor.h
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
-     File: CASpectralProcessor.h
- Abstract: Part of CoreAudio Utility Classes
-  Version: 1.1
-
- Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple
- Inc. ("Apple") in consideration of your agreement to the following
- terms, and your use, installation, modification or redistribution of
- this Apple software constitutes acceptance of these terms.  If you do
- not agree with these terms, please do not use, install, modify or
- redistribute this Apple software.
-
- In consideration of your agreement to abide by the following terms, and
- subject to these terms, Apple grants you a personal, non-exclusive
- license, under Apple's copyrights in this original Apple software (the
- "Apple Software"), to use, reproduce, modify and redistribute the Apple
- Software, with or without modifications, in source and/or binary forms;
- provided that if you redistribute the Apple Software in its entirety and
- without modifications, you must retain this notice and the following
- text and disclaimers in all such redistributions of the Apple Software.
- Neither the name, trademarks, service marks or logos of Apple Inc. may
- be used to endorse or promote products derived from the Apple Software
- without specific prior written permission from Apple.  Except as
- expressly stated in this notice, no other rights or licenses, express or
- implied, are granted by Apple herein, including but not limited to any
- patent rights that may be infringed by your derivative works or by other
- works in which the Apple Software may be incorporated.
-
- The Apple Software is provided by Apple on an "AS IS" basis.  APPLE
- MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
- THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
- FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
- OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
-
- IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
- OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
- MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
- AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
- STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
- POSSIBILITY OF SUCH DAMAGE.
-
- Copyright (C) 2014 Apple Inc. All Rights Reserved.
-
-*/
-#ifndef _SpectralProcesor_H_
-#define _SpectralProcesor_H_
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-#include <CoreAudio/CoreAudioTypes.h>
-#include <CoreFoundation/CoreFoundation.h>
-#else
-#include <CoreAudioTypes.h>
-#include <CoreFoundation.h>
-#endif
-
-#include <Accelerate/Accelerate.h>
-
-#include "CAAutoDisposer.h"
-
-struct SpectralBufferList
-{
-    UInt32 mNumberSpectra;
-    DSPSplitComplex mDSPSplitComplex[1];
-};
-
-class CASpectralProcessor
-{
-public:
-    CASpectralProcessor(UInt32 inFFTSize, UInt32 inHopSize, UInt32 inNumChannels, UInt32 inMaxFrames);
-    virtual ~CASpectralProcessor();
-
-    void Reset();
-
-    void Process(UInt32 inNumFrames, AudioBufferList* inInput, AudioBufferList* outOutput);
-
-    typedef void (*SpectralFunction)(SpectralBufferList* inSpectra, void* inUserData);
-
-    void SetSpectralFunction(SpectralFunction inFunction, void* inUserData);
-
-    UInt32 FFTSize() const { return mFFTSize; }
-    UInt32 MaxFrames() const { return mMaxFrames; }
-    UInt32 NumChannels() const { return mNumChannels; }
-    UInt32 HopSize() const { return mHopSize; }
-    Float32* Window() const { return mWindow; }
-
-
-    void HanningWindow(); // set up a hanning window
-    void SineWindow();
-
-    void GetFrequencies(Float32* freqs, Float32 sampleRate);                // only for processed forward
-    void GetMagnitude(AudioBufferList* inCopy, Float32* min, Float32* max); // only for processed forward
-
-    virtual bool ProcessForwards(UInt32 inNumFrames, AudioBufferList* inInput);
-    bool ProcessBackwards(UInt32 inNumFrames, AudioBufferList* outOutput);
-
-
-    void PrintSpectralBufferList();
-
-protected:
-    void CopyInput(UInt32 inNumFrames, AudioBufferList* inInput);
-    void CopyInputToFFT();
-    void DoWindowing();
-    void DoFwdFFT();
-    void DoInvFFT();
-    void OverlapAddOutput();
-    void CopyOutput(UInt32 inNumFrames, AudioBufferList* inOutput);
-    void ProcessSpectrum(UInt32 inFFTSize, SpectralBufferList* inSpectra);
-
-    UInt32 mFFTSize;
-    UInt32 mHopSize;
-    UInt32 mNumChannels;
-    UInt32 mMaxFrames;
-
-    UInt32 mLog2FFTSize;
-    UInt32 mFFTMask;
-    UInt32 mFFTByteSize;
-    UInt32 mIOBufSize;
-    UInt32 mIOMask;
-    UInt32 mInputSize;
-    UInt32 mInputPos;
-    UInt32 mOutputPos;
-    UInt32 mInFFTPos;
-    UInt32 mOutFFTPos;
-    FFTSetup mFFTSetup;
-
-    CAAutoFree<Float32> mWindow;
-    struct SpectralChannel
-    {
-        CAAutoFree<Float32> mInputBuf;      // log2ceil(FFT size + max frames)
-        CAAutoFree<Float32> mOutputBuf;     // log2ceil(FFT size + max frames)
-        CAAutoFree<Float32> mFFTBuf;        // FFT size
-        CAAutoFree<Float32> mSplitFFTBuf;   // FFT size
-    };
-    CAAutoArrayDelete<SpectralChannel> mChannels;
-
-    CAAutoFree<SpectralBufferList> mSpectralBufferList;
-
-    SpectralFunction mSpectralFunction;
-    void *mUserData;
-
-};
-
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAStreamBasicDescription.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAStreamBasicDescription.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAStreamBasicDescription.cpp
+++ /dev/null
@@ -1,887 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#include "CAStreamBasicDescription.h"
-#include "CAMath.h"
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreFoundation/CFByteOrder.h>
-#else
-    #include <CFByteOrder.h>
-#endif
-
-#pragma mark    This file needs to compile on earlier versions of the OS, so please keep that in mind when editing it
-
-char *CAStringForOSType (OSType t, char *writeLocation, size_t bufsize)
-{
-    if (bufsize > 0) {
-        char *p = writeLocation, *pend = writeLocation + bufsize;
-        union { UInt32 i; unsigned char str[4]; } u;
-        unsigned char *q = u.str;
-        u.i = CFSwapInt32HostToBig(t);
-
-        bool hasNonPrint = false;
-        for (int i = 0; i < 4; ++i) {
-            if (!(isprint(*q) && *q != '\\')) {
-                hasNonPrint = true;
-                break;
-            }
-            q++;
-        }
-        q = u.str;
-
-        if (hasNonPrint)
-            p += snprintf (p, pend - p, "0x");
-        else if (p < pend)
-            *p++ = '\'';
-
-        for (int i = 0; i < 4 && p < pend; ++i) {
-            if (hasNonPrint) {
-                p += snprintf(p, pend - p, "%02X", *q++);
-            } else {
-                *p++ = *q++;
-            }
-        }
-        if (!hasNonPrint && p < pend)
-            *p++ = '\'';
-        if (p >= pend) p -= 1;
-        *p = '\0';
-    }
-    return writeLocation;
-}
-
-
-const AudioStreamBasicDescription   CAStreamBasicDescription::sEmpty = { 0.0, 0, 0, 0, 0, 0, 0, 0, 0 };
-
-CAStreamBasicDescription::CAStreamBasicDescription()
-{
-    memset (this, 0, sizeof(AudioStreamBasicDescription));
-}
-
-CAStreamBasicDescription::CAStreamBasicDescription(const AudioStreamBasicDescription &desc)
-{
-    SetFrom(desc);
-}
-
-
-CAStreamBasicDescription::CAStreamBasicDescription(double inSampleRate,     UInt32 inFormatID,
-                                    UInt32 inBytesPerPacket,    UInt32 inFramesPerPacket,
-                                    UInt32 inBytesPerFrame,     UInt32 inChannelsPerFrame,
-                                    UInt32 inBitsPerChannel,    UInt32 inFormatFlags)
-{
-    mSampleRate = inSampleRate;
-    mFormatID = inFormatID;
-    mBytesPerPacket = inBytesPerPacket;
-    mFramesPerPacket = inFramesPerPacket;
-    mBytesPerFrame = inBytesPerFrame;
-    mChannelsPerFrame = inChannelsPerFrame;
-    mBitsPerChannel = inBitsPerChannel;
-    mFormatFlags = inFormatFlags;
-    mReserved = 0;
-}
-
-char *CAStreamBasicDescription::AsString(char *buf, size_t _bufsize, bool brief /*=false*/) const
-{
-    int bufsize = (int)_bufsize;    // must be signed to protect against overflow
-    char *theBuffer = buf;
-    int nc;
-    char formatID[24];
-    CAStringForOSType(mFormatID, formatID, sizeof(formatID));
-    if (brief) {
-        CommonPCMFormat com;
-        bool interleaved;
-        if (IdentifyCommonPCMFormat(com, &interleaved) && com != kPCMFormatOther) {
-            const char *desc;
-            switch (com) {
-            case kPCMFormatInt16:
-                desc = "Int16";
-                break;
-            case kPCMFormatInt32:
-                desc = "Int32";
-                break;
-            case kPCMFormatFixed824:
-                desc = "Int8.24";
-                break;
-            case kPCMFormatFloat32:
-                desc = "Float32";
-                break;
-            case kPCMFormatFloat64:
-                desc = "Float64";
-                break;
-            default:
-                desc = NULL;
-                break;
-            }
-            if (desc) {
-                const char *inter ="";
-                if (mChannelsPerFrame > 1)
-                    inter = !interleaved ? ", non-inter" : ", inter";
-                snprintf(buf, static_cast<size_t>(bufsize), "%2d ch, %6.0f Hz, %s%s", (int)mChannelsPerFrame, mSampleRate, desc, inter);
-                return theBuffer;
-            }
-        }
-        if (mChannelsPerFrame == 0 && mSampleRate == 0.0 && mFormatID == 0) {
-            snprintf(buf, static_cast<size_t>(bufsize), "%2d ch, %6.0f Hz", (int)mChannelsPerFrame, mSampleRate);
-            return theBuffer;
-        }
-    }
-
-    nc = snprintf(buf, static_cast<size_t>(bufsize), "%2d ch, %6.0f Hz, %s (0x%08X) ", (int)NumberChannels(), mSampleRate, formatID, (int)mFormatFlags);
-    buf += nc; if ((bufsize -= nc) <= 0) goto exit;
-    if (mFormatID == kAudioFormatLinearPCM) {
-        bool isInt = !(mFormatFlags & kLinearPCMFormatFlagIsFloat);
-        int wordSize = static_cast<int>(SampleWordSize());
-        const char *endian = (wordSize > 1) ?
-            ((mFormatFlags & kLinearPCMFormatFlagIsBigEndian) ? " big-endian" : " little-endian" ) : "";
-        const char *sign = isInt ?
-            ((mFormatFlags & kLinearPCMFormatFlagIsSignedInteger) ? " signed" : " unsigned") : "";
-        const char *floatInt = isInt ? "integer" : "float";
-        char packed[32];
-        if (wordSize > 0 && PackednessIsSignificant()) {
-            if (mFormatFlags & kLinearPCMFormatFlagIsPacked)
-                snprintf(packed, sizeof(packed), "packed in %d bytes", wordSize);
-            else
-                snprintf(packed, sizeof(packed), "unpacked in %d bytes", wordSize);
-        } else
-            packed[0] = '\0';
-        const char *align = (wordSize > 0 && AlignmentIsSignificant()) ?
-            ((mFormatFlags & kLinearPCMFormatFlagIsAlignedHigh) ? " high-aligned" : " low-aligned") : "";
-        const char *deinter = (mFormatFlags & kAudioFormatFlagIsNonInterleaved) ? ", deinterleaved" : "";
-        const char *commaSpace = (packed[0]!='\0') || (align[0]!='\0') ? ", " : "";
-        char bitdepth[20];
-
-        int fracbits = (mFormatFlags & kLinearPCMFormatFlagsSampleFractionMask) >> kLinearPCMFormatFlagsSampleFractionShift;
-        if (fracbits > 0)
-            snprintf(bitdepth, sizeof(bitdepth), "%d.%d", (int)mBitsPerChannel - fracbits, fracbits);
-        else
-            snprintf(bitdepth, sizeof(bitdepth), "%d", (int)mBitsPerChannel);
-
-        /*nc =*/ snprintf(buf, static_cast<size_t>(bufsize), "%s-bit%s%s %s%s%s%s%s",
-            bitdepth, endian, sign, floatInt,
-            commaSpace, packed, align, deinter);
-        // buf += nc; if ((bufsize -= nc) <= 0) goto exit;
-    } else if (mFormatID == kAudioFormatAppleLossless) {
-        int sourceBits = 0;
-        switch (mFormatFlags)
-        {
-            case 1: //  kAppleLosslessFormatFlag_16BitSourceData
-                sourceBits = 16;
-                break;
-            case 2: //  kAppleLosslessFormatFlag_20BitSourceData
-                sourceBits = 20;
-                break;
-            case 3: //  kAppleLosslessFormatFlag_24BitSourceData
-                sourceBits = 24;
-                break;
-            case 4: //  kAppleLosslessFormatFlag_32BitSourceData
-                sourceBits = 32;
-                break;
-        }
-        if (sourceBits)
-            nc = snprintf(buf, static_cast<size_t>(bufsize), "from %d-bit source, ", sourceBits);
-        else
-            nc = snprintf(buf, static_cast<size_t>(bufsize), "from UNKNOWN source bit depth, ");
-        buf += nc; if ((bufsize -= nc) <= 0) goto exit;
-        /*nc =*/ snprintf(buf, static_cast<size_t>(bufsize), "%d frames/packet", (int)mFramesPerPacket);
-        //  buf += nc; if ((bufsize -= nc) <= 0) goto exit;
-    }
-    else
-        /*nc =*/ snprintf(buf, static_cast<size_t>(bufsize), "%d bits/channel, %d bytes/packet, %d frames/packet, %d bytes/frame",
-            (int)mBitsPerChannel, (int)mBytesPerPacket, (int)mFramesPerPacket, (int)mBytesPerFrame);
-exit:
-    return theBuffer;
-}
-
-void    CAStreamBasicDescription::NormalizeLinearPCMFormat(AudioStreamBasicDescription& ioDescription)
-{
-    //  the only thing that changes is to make mixable linear PCM into the canonical linear PCM format
-    if((ioDescription.mFormatID == kAudioFormatLinearPCM) && ((ioDescription.mFormatFlags & kIsNonMixableFlag) == 0))
-    {
-        //  the canonical linear PCM format
-        ioDescription.mFormatFlags = kAudioFormatFlagsCanonical;
-        ioDescription.mBytesPerPacket = SizeOf32(AudioSampleType) * ioDescription.mChannelsPerFrame;
-        ioDescription.mFramesPerPacket = 1;
-        ioDescription.mBytesPerFrame = SizeOf32(AudioSampleType) * ioDescription.mChannelsPerFrame;
-        ioDescription.mBitsPerChannel = 8 * SizeOf32(AudioSampleType);
-    }
-}
-
-void    CAStreamBasicDescription::NormalizeLinearPCMFormat(bool inNativeEndian, AudioStreamBasicDescription& ioDescription)
-{
-    //  the only thing that changes is to make mixable linear PCM into the canonical linear PCM format
-    if((ioDescription.mFormatID == kAudioFormatLinearPCM) && ((ioDescription.mFormatFlags & kIsNonMixableFlag) == 0))
-    {
-        //  the canonical linear PCM format
-        ioDescription.mFormatFlags = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked;
-        if(inNativeEndian)
-        {
-#if TARGET_RT_BIG_ENDIAN
-            ioDescription.mFormatFlags |= kAudioFormatFlagIsBigEndian;
-#endif
-        }
-        else
-        {
-#if TARGET_RT_LITTLE_ENDIAN
-            ioDescription.mFormatFlags |= kAudioFormatFlagIsBigEndian;
-#endif
-        }
-        ioDescription.mBytesPerPacket = SizeOf32(AudioSampleType) * ioDescription.mChannelsPerFrame;
-        ioDescription.mFramesPerPacket = 1;
-        ioDescription.mBytesPerFrame = SizeOf32(AudioSampleType) * ioDescription.mChannelsPerFrame;
-        ioDescription.mBitsPerChannel = 8 * SizeOf32(AudioSampleType);
-    }
-}
-
-void    CAStreamBasicDescription::VirtualizeLinearPCMFormat(AudioStreamBasicDescription& ioDescription)
-{
-    //  the only thing that changes is to make mixable linear PCM into the HAL's virtual linear PCM format, which is Float32 currently
-    if((ioDescription.mFormatID == kAudioFormatLinearPCM) && ((ioDescription.mFormatFlags & kIsNonMixableFlag) == 0))
-    {
-        //  the virtual linear PCM format
-        ioDescription.mFormatFlags = kAudioFormatFlagsNativeFloatPacked;
-        ioDescription.mBytesPerPacket = SizeOf32(Float32) * ioDescription.mChannelsPerFrame;
-        ioDescription.mFramesPerPacket = 1;
-        ioDescription.mBytesPerFrame = SizeOf32(Float32) * ioDescription.mChannelsPerFrame;
-        ioDescription.mBitsPerChannel = 8 * SizeOf32(Float32);
-    }
-}
-
-void    CAStreamBasicDescription::VirtualizeLinearPCMFormat(bool inNativeEndian, AudioStreamBasicDescription& ioDescription)
-{
-    //  the only thing that changes is to make mixable linear PCM into the HAL's virtual linear PCM format, which is Float32 currently
-    if((ioDescription.mFormatID == kAudioFormatLinearPCM) && ((ioDescription.mFormatFlags & kIsNonMixableFlag) == 0))
-    {
-        //  the virtual linear PCM format
-        ioDescription.mFormatFlags = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked;
-        if(inNativeEndian)
-        {
-#if TARGET_RT_BIG_ENDIAN
-            ioDescription.mFormatFlags |= kAudioFormatFlagIsBigEndian;
-#endif
-        }
-        else
-        {
-#if TARGET_RT_LITTLE_ENDIAN
-            ioDescription.mFormatFlags |= kAudioFormatFlagIsBigEndian;
-#endif
-        }
-        ioDescription.mBytesPerPacket = SizeOf32(Float32) * ioDescription.mChannelsPerFrame;
-        ioDescription.mFramesPerPacket = 1;
-        ioDescription.mBytesPerFrame = SizeOf32(Float32) * ioDescription.mChannelsPerFrame;
-        ioDescription.mBitsPerChannel = 8 * SizeOf32(Float32);
-    }
-}
-
-void    CAStreamBasicDescription::ResetFormat(AudioStreamBasicDescription& ioDescription)
-{
-    ioDescription.mSampleRate = 0;
-    ioDescription.mFormatID = 0;
-    ioDescription.mBytesPerPacket = 0;
-    ioDescription.mFramesPerPacket = 0;
-    ioDescription.mBytesPerFrame = 0;
-    ioDescription.mChannelsPerFrame = 0;
-    ioDescription.mBitsPerChannel = 0;
-    ioDescription.mFormatFlags = 0;
-}
-
-void    CAStreamBasicDescription::FillOutFormat(AudioStreamBasicDescription& ioDescription, const AudioStreamBasicDescription& inTemplateDescription)
-{
-    if(fiszero(ioDescription.mSampleRate))
-    {
-        ioDescription.mSampleRate = inTemplateDescription.mSampleRate;
-    }
-    if(ioDescription.mFormatID == 0)
-    {
-        ioDescription.mFormatID = inTemplateDescription.mFormatID;
-    }
-    if(ioDescription.mFormatFlags == 0)
-    {
-        ioDescription.mFormatFlags = inTemplateDescription.mFormatFlags;
-    }
-    if(ioDescription.mBytesPerPacket == 0)
-    {
-        ioDescription.mBytesPerPacket = inTemplateDescription.mBytesPerPacket;
-    }
-    if(ioDescription.mFramesPerPacket == 0)
-    {
-        ioDescription.mFramesPerPacket = inTemplateDescription.mFramesPerPacket;
-    }
-    if(ioDescription.mBytesPerFrame == 0)
-    {
-        ioDescription.mBytesPerFrame = inTemplateDescription.mBytesPerFrame;
-    }
-    if(ioDescription.mChannelsPerFrame == 0)
-    {
-        ioDescription.mChannelsPerFrame = inTemplateDescription.mChannelsPerFrame;
-    }
-    if(ioDescription.mBitsPerChannel == 0)
-    {
-        ioDescription.mBitsPerChannel = inTemplateDescription.mBitsPerChannel;
-    }
-}
-
-void    CAStreamBasicDescription::GetSimpleName(const AudioStreamBasicDescription& inDescription, char* outName, UInt32 inMaxNameLength, bool inAbbreviate, bool inIncludeSampleRate)
-{
-    if(inIncludeSampleRate)
-    {
-        int theCharactersWritten = snprintf(outName, inMaxNameLength, "%.0f ", inDescription.mSampleRate);
-        outName += theCharactersWritten;
-        inMaxNameLength -= static_cast<UInt32>(theCharactersWritten);
-    }
-
-    switch(inDescription.mFormatID)
-    {
-        case kAudioFormatLinearPCM:
-            {
-                const char* theEndianString = NULL;
-                if((inDescription.mFormatFlags & kAudioFormatFlagIsBigEndian) != 0)
-                {
-                    #if TARGET_RT_LITTLE_ENDIAN
-                        theEndianString = "Big Endian";
-                    #endif
-                }
-                else
-                {
-                    #if TARGET_RT_BIG_ENDIAN
-                        theEndianString = "Little Endian";
-                    #endif
-                }
-
-                const char* theKindString = NULL;
-                if((inDescription.mFormatFlags & kAudioFormatFlagIsFloat) != 0)
-                {
-                    theKindString = (inAbbreviate ? "Float" : "Floating Point");
-                }
-                else if((inDescription.mFormatFlags & kAudioFormatFlagIsSignedInteger) != 0)
-                {
-                    theKindString = (inAbbreviate ? "SInt" : "Signed Integer");
-                }
-                else
-                {
-                    theKindString = (inAbbreviate ? "UInt" : "Unsigned Integer");
-                }
-
-                const char* thePackingString = NULL;
-                if((inDescription.mFormatFlags & kAudioFormatFlagIsPacked) == 0)
-                {
-                    if((inDescription.mFormatFlags & kAudioFormatFlagIsAlignedHigh) != 0)
-                    {
-                        thePackingString = "High";
-                    }
-                    else
-                    {
-                        thePackingString = "Low";
-                    }
-                }
-
-                const char* theMixabilityString = NULL;
-                if((inDescription.mFormatFlags & kIsNonMixableFlag) == 0)
-                {
-                    theMixabilityString = "Mixable";
-                }
-                else
-                {
-                    theMixabilityString = "Unmixable";
-                }
-
-                if(inAbbreviate)
-                {
-                    if(theEndianString != NULL)
-                    {
-                        if(thePackingString != NULL)
-                        {
-                            snprintf(outName, inMaxNameLength, "%s %d Ch %s %s %s%d/%s%d", theMixabilityString, (int)inDescription.mChannelsPerFrame, theEndianString, thePackingString, theKindString, (int)inDescription.mBitsPerChannel, theKindString, (int)(inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8);
-                        }
-                        else
-                        {
-                            snprintf(outName, inMaxNameLength, "%s %d Ch %s %s%d", theMixabilityString, (int)inDescription.mChannelsPerFrame, theEndianString, theKindString, (int)inDescription.mBitsPerChannel);
-                        }
-                    }
-                    else
-                    {
-                        if(thePackingString != NULL)
-                        {
-                            snprintf(outName, inMaxNameLength, "%s %d Ch %s %s%d/%s%d", theMixabilityString, (int)inDescription.mChannelsPerFrame, thePackingString, theKindString, (int)inDescription.mBitsPerChannel, theKindString, (int)((inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8));
-                        }
-                        else
-                        {
-                            snprintf(outName, inMaxNameLength, "%s %d Ch %s%d", theMixabilityString, (int)inDescription.mChannelsPerFrame, theKindString, (int)inDescription.mBitsPerChannel);
-                        }
-                    }
-                }
-                else
-                {
-                    if(theEndianString != NULL)
-                    {
-                        if(thePackingString != NULL)
-                        {
-                            snprintf(outName, inMaxNameLength, "%s %d Channel %d Bit %s %s Aligned %s in %d Bits", theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theEndianString, theKindString, thePackingString, (int)(inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8);
-                        }
-                        else
-                        {
-                            snprintf(outName, inMaxNameLength, "%s %d Channel %d Bit %s %s", theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theEndianString, theKindString);
-                        }
-                    }
-                    else
-                    {
-                        if(thePackingString != NULL)
-                        {
-                            snprintf(outName, inMaxNameLength, "%s %d Channel %d Bit %s Aligned %s in %d Bits", theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theKindString, thePackingString, (int)(inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8);
-                        }
-                        else
-                        {
-                            snprintf(outName, inMaxNameLength, "%s %d Channel %d Bit %s", theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theKindString);
-                        }
-                    }
-                }
-            }
-            break;
-
-        case kAudioFormatAC3:
-            strlcpy(outName, "AC-3", sizeof(outName));
-            break;
-
-        case kAudioFormat60958AC3:
-            strlcpy(outName, "AC-3 for SPDIF", sizeof(outName));
-            break;
-
-        default:
-            CACopy4CCToCString(outName, inDescription.mFormatID);
-            break;
-    };
-}
-
-#if CoreAudio_Debug
-#include "CALogMacros.h"
-
-void    CAStreamBasicDescription::PrintToLog(const AudioStreamBasicDescription& inDesc)
-{
-    PrintFloat      ("  Sample Rate:        ", inDesc.mSampleRate);
-    Print4CharCode  ("  Format ID:          ", inDesc.mFormatID);
-    PrintHex        ("  Format Flags:       ", inDesc.mFormatFlags);
-    PrintInt        ("  Bytes per Packet:   ", inDesc.mBytesPerPacket);
-    PrintInt        ("  Frames per Packet:  ", inDesc.mFramesPerPacket);
-    PrintInt        ("  Bytes per Frame:    ", inDesc.mBytesPerFrame);
-    PrintInt        ("  Channels per Frame: ", inDesc.mChannelsPerFrame);
-    PrintInt        ("  Bits per Channel:   ", inDesc.mBitsPerChannel);
-}
-#endif
-
-bool    operator<(const AudioStreamBasicDescription& x, const AudioStreamBasicDescription& y)
-{
-    bool theAnswer = false;
-    bool isDone = false;
-
-    //  note that if either side is 0, that field is skipped
-
-    //  format ID is the first order sort
-    if((!isDone) && ((x.mFormatID != 0) && (y.mFormatID != 0)))
-    {
-        if(x.mFormatID != y.mFormatID)
-        {
-            //  formats are sorted numerically except that linear
-            //  PCM is always first
-            if(x.mFormatID == kAudioFormatLinearPCM)
-            {
-                theAnswer = true;
-            }
-            else if(y.mFormatID == kAudioFormatLinearPCM)
-            {
-                theAnswer = false;
-            }
-            else
-            {
-                theAnswer = x.mFormatID < y.mFormatID;
-            }
-            isDone = true;
-        }
-    }
-
-
-    //  mixable is always better than non-mixable for linear PCM and should be the second order sort item
-    if((!isDone) && ((x.mFormatID == kAudioFormatLinearPCM) && (y.mFormatID == kAudioFormatLinearPCM)))
-    {
-        if(((x.mFormatFlags & kIsNonMixableFlag) == 0) && ((y.mFormatFlags & kIsNonMixableFlag) != 0))
-        {
-            theAnswer = true;
-            isDone = true;
-        }
-        else if(((x.mFormatFlags & kIsNonMixableFlag) != 0) && ((y.mFormatFlags & kIsNonMixableFlag) == 0))
-        {
-            theAnswer = false;
-            isDone = true;
-        }
-    }
-
-    //  floating point vs integer for linear PCM only
-    if((!isDone) && ((x.mFormatID == kAudioFormatLinearPCM) && (y.mFormatID == kAudioFormatLinearPCM)))
-    {
-        if((x.mFormatFlags & kAudioFormatFlagIsFloat) != (y.mFormatFlags & kAudioFormatFlagIsFloat))
-        {
-            //  floating point is better than integer
-            theAnswer = y.mFormatFlags & kAudioFormatFlagIsFloat;
-            isDone = true;
-        }
-    }
-
-    //  bit depth
-    if((!isDone) && ((x.mBitsPerChannel != 0) && (y.mBitsPerChannel != 0)))
-    {
-        if(x.mBitsPerChannel != y.mBitsPerChannel)
-        {
-            //  deeper bit depths are higher quality
-            theAnswer = x.mBitsPerChannel < y.mBitsPerChannel;
-            isDone = true;
-        }
-    }
-
-    //  sample rate
-    if((!isDone) && fnonzero(x.mSampleRate) && fnonzero(y.mSampleRate))
-    {
-        if(fnotequal(x.mSampleRate, y.mSampleRate))
-        {
-            //  higher sample rates are higher quality
-            theAnswer = x.mSampleRate < y.mSampleRate;
-            isDone = true;
-        }
-    }
-
-    //  number of channels
-    if((!isDone) && ((x.mChannelsPerFrame != 0) && (y.mChannelsPerFrame != 0)))
-    {
-        if(x.mChannelsPerFrame != y.mChannelsPerFrame)
-        {
-            //  more channels is higher quality
-            theAnswer = x.mChannelsPerFrame < y.mChannelsPerFrame;
-            //isDone = true;
-        }
-    }
-
-    return theAnswer;
-}
-
-UInt32 CAStreamBasicDescription::GetRegularizedFormatFlags(bool forHardware) const
-{
-    UInt32 result = mFormatFlags;
-
-    if (IsPCM()) {
-        // First, if there are bits other than AllClear set, clear it because it's lying.
-        if (result & ~kAudioFormatFlagsAreAllClear)
-            result &= ~kAudioFormatFlagsAreAllClear;
-
-        // If not forHardware, remove the mixability flag.
-        if (!forHardware)
-            result &= ~kLinearPCMFormatFlagIsNonMixable;
-
-        // If the format has no extra bits, then it is packed.
-        if (!PackednessIsSignificant())
-            result |= kLinearPCMFormatFlagIsPacked;
-
-        // Remove the high-aligned flag if alignment is irrelevant.
-        if (!AlignmentIsSignificant())
-            result &= ~kLinearPCMFormatFlagIsAlignedHigh;
-
-        // Remove the signed integer bit if it's float
-        if (result & kLinearPCMFormatFlagIsFloat)
-            result &= ~kLinearPCMFormatFlagIsSignedInteger;
-
-        // If the bit depth is 8 bits or less and the format is packed, we don't care about endianness
-        if (mBitsPerChannel <= 8 && (result & kLinearPCMFormatFlagIsPacked))
-            result &= kAudioFormatFlagIsBigEndian;
-
-        // If there is 1 channel, we don't care about non-interleavedness.
-        if (mChannelsPerFrame == 1)
-            result &= ~kLinearPCMFormatFlagIsNonInterleaved;
-
-        // Finally, if the bits really are all 0, set the AllClear flag.
-        if (result == 0)
-            result = kAudioFormatFlagsAreAllClear;
-    }
-    return result;
-}
-
-// private
-bool CAStreamBasicDescription::EquivalentFormatFlags(const AudioStreamBasicDescription &x, const AudioStreamBasicDescription &y, bool forHardware, bool usingWildcards)
-{
-    if (usingWildcards)
-    {
-        // if either of the formats is a wildcard, we don't care about the flags
-        // if either of the flags is a wildcard, we have matched
-        if (x.mFormatID == 0 || y.mFormatID == 0 || x.mFormatFlags == 0 || y.mFormatFlags == 0)
-        {
-            return true;
-        }
-    }
-
-    if (x.mFormatID != kAudioFormatLinearPCM) // we already know the formatID's match and have taken wildcards out of the picture.
-        return x.mFormatFlags == y.mFormatFlags;
-
-    // It is safe to down-cast from AudioStreamBasicDescription to its C++ wrapper.
-    // The cast could be avoided with a copy, but here, efficiency matters.
-    const CAStreamBasicDescription &a = *static_cast<const CAStreamBasicDescription *>(&x);
-    const CAStreamBasicDescription &b = *static_cast<const CAStreamBasicDescription *>(&y);
-
-    return a.GetRegularizedFormatFlags(forHardware) == b.GetRegularizedFormatFlags(forHardware);
-}
-
-bool    CAStreamBasicDescription::IsExactlyEqual(const AudioStreamBasicDescription &x, const AudioStreamBasicDescription &y)
-{
-    // mReserved didn't exist in early versions of OS X; we want to ignore differences there.
-    // The structure is properly packed up until that point, so the shortcut of using memcmp()
-    // instead of individual field comparisons is safe.
-    return memcmp(&x, &y, offsetof(AudioStreamBasicDescription, mReserved)) == 0;
-}
-
-#define MATCH_WITH_WILDCARD(name) ((x.name) == 0 || (y.name) == 0 || (x.name) == (y.name))
-
-bool    CAStreamBasicDescription::IsEquivalent(const AudioStreamBasicDescription &x, const AudioStreamBasicDescription &y, ComparisonOptions options)
-{
-    if (options & kCompareUsingWildcards) {
-        return
-            //  check the sample rate
-            (fiszero(x.mSampleRate) || fiszero(y.mSampleRate) || fequal(x.mSampleRate, y.mSampleRate))
-
-            //  check the format ids
-            && MATCH_WITH_WILDCARD(mFormatID)
-
-            //  check the bytes per packet
-            && MATCH_WITH_WILDCARD(mBytesPerPacket)
-
-            //  check the frames per packet
-            && MATCH_WITH_WILDCARD(mFramesPerPacket)
-
-            //  check the bytes per frame
-            && MATCH_WITH_WILDCARD(mBytesPerFrame)
-
-            //  check the channels per frame
-            && MATCH_WITH_WILDCARD(mChannelsPerFrame)
-
-            //  check the bits per channel
-            && MATCH_WITH_WILDCARD(mBitsPerChannel)
-
-            // Only if we get this far, do the work of matching the format flags
-            && EquivalentFormatFlags(x, y, options & kCompareForHardware, /*usingWildcards=*/true);
-    } else {
-        return  x.mSampleRate == y.mSampleRate
-            &&  x.mFormatID == y.mFormatID
-            &&  x.mBytesPerPacket == y.mBytesPerPacket
-            &&  x.mFramesPerPacket == y.mFramesPerPacket
-            &&  x.mChannelsPerFrame == y.mChannelsPerFrame
-            &&  x.mBitsPerChannel == y.mBitsPerChannel
-            &&  EquivalentFormatFlags(x, y, options & kCompareForHardware, /*usingWildcards=*/false);
-    }
-}
-
-// DEPRECATED.
-bool    operator==(const AudioStreamBasicDescription& x, const AudioStreamBasicDescription& y)
-{
-    return CAStreamBasicDescription::IsEquivalent(x, y, CAStreamBasicDescription::kCompareUsingWildcards | CAStreamBasicDescription::kCompareForHardware);
-}
-
-// To be deprecated.
-bool    CAStreamBasicDescription::IsEqual(const AudioStreamBasicDescription &other, bool interpretingWildcards) const
-{
-    if (interpretingWildcards)
-        return CAStreamBasicDescription::IsEquivalent(*this, other, CAStreamBasicDescription::kCompareUsingWildcards | CAStreamBasicDescription::kCompareForHardware);
-    return IsExactlyEqual(*this, other);
-}
-
-// DEPRECATED.
-bool    CAStreamBasicDescription::IsEqual(const AudioStreamBasicDescription &other) const
-{
-    return CAStreamBasicDescription::IsEquivalent(*this, other, CAStreamBasicDescription::kCompareUsingWildcards | CAStreamBasicDescription::kCompareForHardware);
-}
-
-bool SanityCheck(const AudioStreamBasicDescription& x)
-{
-    // This function returns false if there are sufficiently insane values in any field.
-    // It is very conservative so even some very unlikely values will pass.
-    // This is just meant to catch the case where the data from a file is corrupted.
-
-    return
-        (x.mSampleRate >= 0.)
-        && (x.mSampleRate < 3e6)    // SACD sample rate is 2.8224 MHz
-        && (x.mBytesPerPacket < 1000000)
-        && (x.mFramesPerPacket < 1000000)
-        && (x.mBytesPerFrame < 1000000)
-        && (x.mChannelsPerFrame > 0)
-        && (x.mChannelsPerFrame <= 1024)
-        && (x.mBitsPerChannel <= 1024)
-        && (x.mFormatID != 0)
-        && !(x.mFormatID == kAudioFormatLinearPCM && (x.mFramesPerPacket != 1 || x.mBytesPerPacket != x.mBytesPerFrame));
-}
-
-bool CAStreamBasicDescription::FromText(const char *inTextDesc, AudioStreamBasicDescription &fmt)
-{
-    const char *p = inTextDesc;
-
-    memset(&fmt, 0, sizeof(fmt));
-
-    bool isPCM = true;  // until proven otherwise
-    UInt32 pcmFlags = kAudioFormatFlagIsPacked | kAudioFormatFlagIsSignedInteger;
-
-    if (p[0] == '-')    // previously we required a leading dash on PCM formats
-        ++p;
-
-    if (p[0] == 'B' && p[1] == 'E') {
-        pcmFlags |= kLinearPCMFormatFlagIsBigEndian;
-        p += 2;
-    } else if (p[0] == 'L' && p[1] == 'E') {
-        p += 2;
-    } else {
-        // default is native-endian
-#if TARGET_RT_BIG_ENDIAN
-        pcmFlags |= kLinearPCMFormatFlagIsBigEndian;
-#endif
-    }
-    if (p[0] == 'F') {
-        pcmFlags = (pcmFlags & ~static_cast<UInt32>(kAudioFormatFlagIsSignedInteger)) | kAudioFormatFlagIsFloat;
-        ++p;
-    } else {
-        if (p[0] == 'U') {
-            pcmFlags &= ~static_cast<UInt32>(kAudioFormatFlagIsSignedInteger);
-            ++p;
-        }
-        if (p[0] == 'I')
-            ++p;
-        else {
-            // it's not PCM; presumably some other format (NOT VALIDATED; use AudioFormat for that)
-            isPCM = false;
-            p = inTextDesc; // go back to the beginning
-            char buf[4] = { ' ',' ',' ',' ' };
-            for (int i = 0; i < 4; ++i) {
-                if (*p != '\\') {
-                    if ((buf[i] = *p++) == '\0') {
-                        // special-case for 'aac'
-                        if (i != 3) return false;
-                        --p;    // keep pointing at the terminating null
-                        buf[i] = ' ';
-                        break;
-                    }
-                } else {
-                    // "\xNN" is a hex byte
-                    if (*++p != 'x') return false;
-                    int x;
-                    if (sscanf(++p, "%02X", &x) != 1) return false;
-                    buf[i] = static_cast<char>(x);
-                    p += 2;
-                }
-            }
-
-            if (strchr("-@/#", buf[3])) {
-                // further special-casing for 'aac'
-                buf[3] = ' ';
-                --p;
-            }
-
-            memcpy(&fmt.mFormatID, buf, 4);
-            fmt.mFormatID = CFSwapInt32BigToHost(fmt.mFormatID);
-        }
-    }
-
-    if (isPCM) {
-        fmt.mFormatID = kAudioFormatLinearPCM;
-        fmt.mFormatFlags = pcmFlags;
-        fmt.mFramesPerPacket = 1;
-        fmt.mChannelsPerFrame = 1;
-        UInt32 bitdepth = 0, fracbits = 0;
-        while (isdigit(*p))
-            bitdepth = 10 * bitdepth + static_cast<UInt32>(*p++ - '0');
-        if (*p == '.') {
-            ++p;
-            if (!isdigit(*p)) {
-                fprintf(stderr, "Expected fractional bits following '.'\n");
-                goto Bail;
-            }
-            while (isdigit(*p))
-                fracbits = 10 * fracbits + static_cast<UInt32>(*p++ - '0');
-            bitdepth += fracbits;
-            fmt.mFormatFlags |= (fracbits << kLinearPCMFormatFlagsSampleFractionShift);
-        }
-        fmt.mBitsPerChannel = bitdepth;
-        fmt.mBytesPerPacket = fmt.mBytesPerFrame = (bitdepth + 7) / 8;
-        if (bitdepth & 7) {
-            // assume unpacked. (packed odd bit depths are describable but not supported in AudioConverter.)
-            fmt.mFormatFlags &= ~static_cast<UInt32>(kLinearPCMFormatFlagIsPacked);
-            // alignment matters; default to high-aligned. use ':L_' for low.
-            fmt.mFormatFlags |= kLinearPCMFormatFlagIsAlignedHigh;
-        }
-    }
-    if (*p == '@') {
-        ++p;
-        while (isdigit(*p))
-            fmt.mSampleRate = 10 * fmt.mSampleRate + (*p++ - '0');
-    }
-    if (*p == '/') {
-        UInt32 flags = 0;
-        while (true) {
-            char c = *++p;
-            if (c >= '0' && c <= '9')
-                flags = (flags << 4) | static_cast<UInt32>(c - '0');
-            else if (c >= 'A' && c <= 'F')
-                flags = (flags << 4) | static_cast<UInt32>(c - 'A' + 10);
-            else if (c >= 'a' && c <= 'f')
-                flags = (flags << 4) | static_cast<UInt32>(c - 'a' + 10);
-            else break;
-        }
-        fmt.mFormatFlags = flags;
-    }
-    if (*p == '#') {
-        ++p;
-        while (isdigit(*p))
-            fmt.mFramesPerPacket = 10 * fmt.mFramesPerPacket + static_cast<UInt32>(*p++ - '0');
-    }
-    if (*p == ':') {
-        ++p;
-        fmt.mFormatFlags &= ~static_cast<UInt32>(kLinearPCMFormatFlagIsPacked);
-        if (*p == 'L')
-            fmt.mFormatFlags &= ~static_cast<UInt32>(kLinearPCMFormatFlagIsAlignedHigh);
-        else if (*p == 'H')
-            fmt.mFormatFlags |= kLinearPCMFormatFlagIsAlignedHigh;
-        else
-            goto Bail;
-        ++p;
-        UInt32 bytesPerFrame = 0;
-        while (isdigit(*p))
-            bytesPerFrame = 10 * bytesPerFrame + static_cast<UInt32>(*p++ - '0');
-        fmt.mBytesPerFrame = fmt.mBytesPerPacket = bytesPerFrame;
-    }
-    if (*p == ',') {
-        ++p;
-        int ch = 0;
-        while (isdigit(*p))
-            ch = 10 * ch + (*p++ - '0');
-        fmt.mChannelsPerFrame = static_cast<UInt32>(ch);
-        if (*p == 'D') {
-            ++p;
-            if (fmt.mFormatID != kAudioFormatLinearPCM) {
-                fprintf(stderr, "non-interleaved flag invalid for non-PCM formats\n");
-                goto Bail;
-            }
-            fmt.mFormatFlags |= kAudioFormatFlagIsNonInterleaved;
-        } else {
-            if (*p == 'I') ++p; // default
-            if (fmt.mFormatID == kAudioFormatLinearPCM)
-                fmt.mBytesPerPacket = fmt.mBytesPerFrame *= static_cast<UInt32>(ch);
-        }
-    }
-    if (*p != '\0') {
-        fprintf(stderr, "extra characters at end of format string: %s\n", p);
-        goto Bail;
-    }
-    return true;
-
-Bail:
-    fprintf(stderr, "Invalid format string: %s\n", inTextDesc);
-    fprintf(stderr, "Syntax of format strings is: \n");
-    return false;
-}
-
-const char *CAStreamBasicDescription::sTextParsingUsageString =
-    "format[@sample_rate_hz][/format_flags][#frames_per_packet][:LHbytesPerFrame][,channelsDI].\n"
-    "Format for PCM is [-][BE|LE]{F|I|UI}{bitdepth}; else a 4-char format code (e.g. aac, alac).\n";
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAStreamBasicDescription.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAStreamBasicDescription.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAStreamBasicDescription.h
+++ /dev/null
@@ -1,448 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#ifndef __CAStreamBasicDescription_h__
-#define __CAStreamBasicDescription_h__
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreAudio/CoreAudioTypes.h>
-    #include <CoreFoundation/CoreFoundation.h>
-#else
-    #include "CoreAudioTypes.h"
-    #include "CoreFoundation.h"
-#endif
-
-#include "CADebugMacros.h"
-#include <string.h> // for memset, memcpy
-#include <stdio.h>  // for FILE *
-
-#pragma mark    This file needs to compile on more earlier versions of the OS, so please keep that in mind when editing it
-
-#ifndef ASBD_STRICT_EQUALITY
-    #define ASBD_STRICT_EQUALITY 0
-#endif
-
-#if __GNUC__ && ASBD_STRICT_EQUALITY
-    // not turning on the deprecation just yet
-    #define ASBD_EQUALITY_DEPRECATED __attribute__((deprecated("This method uses a possibly surprising wildcard comparison (i.e. 0 channels == 1 channel)")))
-#else
-    #define ASBD_EQUALITY_DEPRECATED
-#endif
-
-#ifndef CA_CANONICAL_DEPRECATED
-    #define CA_CANONICAL_DEPRECATED
-#endif
-
-extern char *CAStringForOSType (OSType t, char *writeLocation, size_t bufsize);
-
-// define Leopard specific symbols for backward compatibility if applicable
-#if COREAUDIOTYPES_VERSION < 1050
-typedef Float32 AudioSampleType;
-enum { kAudioFormatFlagsCanonical = kAudioFormatFlagIsFloat | kAudioFormatFlagsNativeEndian | kAudioFormatFlagIsPacked };
-#endif
-#if COREAUDIOTYPES_VERSION < 1051
-typedef Float32 AudioUnitSampleType;
-enum {
-    kLinearPCMFormatFlagsSampleFractionShift    = 7,
-    kLinearPCMFormatFlagsSampleFractionMask     = (0x3F << kLinearPCMFormatFlagsSampleFractionShift),
-};
-#endif
-
-//  define the IsMixable format flag for all versions of the system
-#if (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_3)
-    enum { kIsNonMixableFlag = kAudioFormatFlagIsNonMixable };
-#else
-    enum { kIsNonMixableFlag = (1L << 6) };
-#endif
-
-//=============================================================================
-//  CAStreamBasicDescription
-//
-//  This is a wrapper class for the AudioStreamBasicDescription struct.
-//  It adds a number of convenience routines, but otherwise adds nothing
-//  to the footprint of the original struct.
-//=============================================================================
-class CAStreamBasicDescription :
-    public AudioStreamBasicDescription
-{
-
-//  Constants
-public:
-    static const AudioStreamBasicDescription    sEmpty;
-
-    enum CommonPCMFormat {
-        kPCMFormatOther     = 0,
-        kPCMFormatFloat32   = 1,
-        kPCMFormatInt16     = 2,
-        kPCMFormatFixed824  = 3,
-        kPCMFormatFloat64   = 4,
-        kPCMFormatInt32     = 5
-    };
-
-    // options for IsEquivalent
-    enum {
-        kCompareDefault         = 0,
-        kCompareUsingWildcards  = 1 << 0,   // treats fields with values of 0 as wildcards.
-                                            // too liberal if you need to represent 0 channels.
-        kCompareForHardware     = 1 << 1,   // formats are hardware formats (IsNonMixable flag is significant).
-
-        kCompareForHardwareUsingWildcards   = kCompareForHardware + kCompareUsingWildcards  //  for convenience
-    };
-    typedef UInt32 ComparisonOptions;
-
-//  Construction/Destruction
-public:
-    CAStreamBasicDescription();
-
-    CAStreamBasicDescription(const AudioStreamBasicDescription &desc);
-
-    CAStreamBasicDescription(       double inSampleRate,        UInt32 inFormatID,
-                                    UInt32 inBytesPerPacket,    UInt32 inFramesPerPacket,
-                                    UInt32 inBytesPerFrame,     UInt32 inChannelsPerFrame,
-                                    UInt32 inBitsPerChannel,    UInt32 inFormatFlags);
-
-    CAStreamBasicDescription(   double inSampleRate, UInt32 inNumChannels, CommonPCMFormat pcmf, bool inIsInterleaved) {
-        unsigned wordsize;
-
-        mSampleRate = inSampleRate;
-        mFormatID = kAudioFormatLinearPCM;
-        mFormatFlags = kAudioFormatFlagsNativeEndian | kAudioFormatFlagIsPacked;
-        mFramesPerPacket = 1;
-        mChannelsPerFrame = inNumChannels;
-        mBytesPerFrame = mBytesPerPacket = 0;
-        mReserved = 0;
-
-        switch (pcmf) {
-        default:
-            return;
-        case kPCMFormatFloat32:
-            wordsize = 4;
-            mFormatFlags |= kAudioFormatFlagIsFloat;
-            break;
-        case kPCMFormatFloat64:
-            wordsize = 8;
-            mFormatFlags |= kAudioFormatFlagIsFloat;
-            break;
-        case kPCMFormatInt16:
-            wordsize = 2;
-            mFormatFlags |= kAudioFormatFlagIsSignedInteger;
-            break;
-        case kPCMFormatInt32:
-            wordsize = 4;
-            mFormatFlags |= kAudioFormatFlagIsSignedInteger;
-            break;
-        case kPCMFormatFixed824:
-            wordsize = 4;
-            mFormatFlags |= kAudioFormatFlagIsSignedInteger | (24 << kLinearPCMFormatFlagsSampleFractionShift);
-            break;
-        }
-        mBitsPerChannel = wordsize * 8;
-        if (inIsInterleaved)
-            mBytesPerFrame = mBytesPerPacket = wordsize * inNumChannels;
-        else {
-            mFormatFlags |= kAudioFormatFlagIsNonInterleaved;
-            mBytesPerFrame = mBytesPerPacket = wordsize;
-        }
-    }
-
-//  Assignment
-    CAStreamBasicDescription&   operator=(const AudioStreamBasicDescription& v) { SetFrom(v); return *this; }
-
-    void    SetFrom(const AudioStreamBasicDescription &desc)
-    {
-        memcpy(this, &desc, sizeof(AudioStreamBasicDescription));
-    }
-
-    bool        FromText(const char *inTextDesc) { return FromText(inTextDesc, *this); }
-    static bool FromText(const char *inTextDesc, AudioStreamBasicDescription &outDesc);
-                    // return true if parsing was successful
-
-    static const char *sTextParsingUsageString;
-
-    // _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
-    //
-    // interrogation
-
-    bool    IsPCM() const { return mFormatID == kAudioFormatLinearPCM; }
-
-    bool    PackednessIsSignificant() const
-    {
-        Assert(IsPCM(), "PackednessIsSignificant only applies for PCM");
-        return (SampleWordSize() << 3) != mBitsPerChannel;
-    }
-
-    bool    AlignmentIsSignificant() const
-    {
-        return PackednessIsSignificant() || (mBitsPerChannel & 7) != 0;
-    }
-
-    bool    IsInterleaved() const
-    {
-        return !(mFormatFlags & kAudioFormatFlagIsNonInterleaved);
-    }
-
-    bool    IsSignedInteger() const
-    {
-        return IsPCM() && (mFormatFlags & kAudioFormatFlagIsSignedInteger);
-    }
-
-    bool    IsFloat() const
-    {
-        return IsPCM() && (mFormatFlags & kAudioFormatFlagIsFloat);
-    }
-
-    bool    IsNativeEndian() const
-    {
-        return (mFormatFlags & kAudioFormatFlagIsBigEndian) == kAudioFormatFlagsNativeEndian;
-    }
-
-    // for sanity with interleaved/deinterleaved possibilities, never access mChannelsPerFrame, use these:
-    UInt32  NumberInterleavedChannels() const   { return IsInterleaved() ? mChannelsPerFrame : 1; }
-    UInt32  NumberChannelStreams() const        { return IsInterleaved() ? 1 : mChannelsPerFrame; }
-    UInt32  NumberChannels() const              { return mChannelsPerFrame; }
-    UInt32  SampleWordSize() const              {
-            return (mBytesPerFrame > 0 && NumberInterleavedChannels()) ? mBytesPerFrame / NumberInterleavedChannels() :  0;
-    }
-
-    UInt32  FramesToBytes(UInt32 nframes) const { return nframes * mBytesPerFrame; }
-    UInt32  BytesToFrames(UInt32 nbytes) const  {
-        Assert(mBytesPerFrame > 0, "bytesPerFrame must be > 0 in BytesToFrames");
-        return nbytes / mBytesPerFrame;
-    }
-
-    bool    SameChannelsAndInterleaving(const CAStreamBasicDescription &a) const
-    {
-        return this->NumberChannels() == a.NumberChannels() && this->IsInterleaved() == a.IsInterleaved();
-    }
-
-    bool    IdentifyCommonPCMFormat(CommonPCMFormat &outFormat, bool *outIsInterleaved=NULL) const
-    {   // return true if it's a valid PCM format.
-
-        outFormat = kPCMFormatOther;
-        // trap out patently invalid formats.
-        if (mFormatID != kAudioFormatLinearPCM || mFramesPerPacket != 1 || mBytesPerFrame != mBytesPerPacket || mBitsPerChannel/8 > mBytesPerFrame || mChannelsPerFrame == 0)
-            return false;
-        bool interleaved = (mFormatFlags & kAudioFormatFlagIsNonInterleaved) == 0;
-        if (outIsInterleaved != NULL) *outIsInterleaved = interleaved;
-        unsigned wordsize = mBytesPerFrame;
-        if (interleaved) {
-            if (wordsize % mChannelsPerFrame != 0) return false;
-            wordsize /= mChannelsPerFrame;
-        }
-
-        if ((mFormatFlags & kAudioFormatFlagIsBigEndian) == kAudioFormatFlagsNativeEndian
-        && wordsize * 8 == mBitsPerChannel) {
-            // packed and native endian, good
-            if (mFormatFlags & kLinearPCMFormatFlagIsFloat) {
-                // float: reject nonsense bits
-                if (mFormatFlags & (kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagsSampleFractionMask))
-                    return false;
-                if (wordsize == 4)
-                    outFormat = kPCMFormatFloat32;
-                if (wordsize == 8)
-                    outFormat = kPCMFormatFloat64;
-            } else if (mFormatFlags & kLinearPCMFormatFlagIsSignedInteger) {
-                // signed int
-                unsigned fracbits = (mFormatFlags & kLinearPCMFormatFlagsSampleFractionMask) >> kLinearPCMFormatFlagsSampleFractionShift;
-                if (wordsize == 4 && fracbits == 24)
-                    outFormat = kPCMFormatFixed824;
-                else if (wordsize == 4 && fracbits == 0)
-                    outFormat = kPCMFormatInt32;
-                else if (wordsize == 2 && fracbits == 0)
-                    outFormat = kPCMFormatInt16;
-            }
-        }
-        return true;
-    }
-
-    bool IsCommonFloat32(bool *outIsInterleaved=NULL) const {
-        CommonPCMFormat fmt;
-        return IdentifyCommonPCMFormat(fmt, outIsInterleaved) && fmt == kPCMFormatFloat32;
-    }
-    bool IsCommonFloat64(bool *outIsInterleaved=NULL) const {
-        CommonPCMFormat fmt;
-        return IdentifyCommonPCMFormat(fmt, outIsInterleaved) && fmt == kPCMFormatFloat64;
-    }
-    bool IsCommonFixed824(bool *outIsInterleaved=NULL) const {
-        CommonPCMFormat fmt;
-        return IdentifyCommonPCMFormat(fmt, outIsInterleaved) && fmt == kPCMFormatFixed824;
-    }
-    bool IsCommonInt16(bool *outIsInterleaved=NULL) const {
-        CommonPCMFormat fmt;
-        return IdentifyCommonPCMFormat(fmt, outIsInterleaved) && fmt == kPCMFormatInt16;
-    }
-
-    // _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
-    //
-    //  manipulation
-
-    CA_CANONICAL_DEPRECATED
-    void    SetCanonical(UInt32 nChannels, bool interleaved)
-                // note: leaves sample rate untouched
-    {
-        mFormatID = kAudioFormatLinearPCM;
-        UInt32 sampleSize = SizeOf32(AudioSampleType);
-        mFormatFlags = kAudioFormatFlagsCanonical;
-        mBitsPerChannel = 8 * sampleSize;
-        mChannelsPerFrame = nChannels;
-        mFramesPerPacket = 1;
-        if (interleaved)
-            mBytesPerPacket = mBytesPerFrame = nChannels * sampleSize;
-        else {
-            mBytesPerPacket = mBytesPerFrame = sampleSize;
-            mFormatFlags |= kAudioFormatFlagIsNonInterleaved;
-        }
-    }
-
-    CA_CANONICAL_DEPRECATED
-    bool    IsCanonical() const
-    {
-        if (mFormatID != kAudioFormatLinearPCM) return false;
-        UInt32 reqFormatFlags;
-        UInt32 flagsMask = (kLinearPCMFormatFlagIsFloat | kLinearPCMFormatFlagIsBigEndian | kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagIsPacked | kLinearPCMFormatFlagsSampleFractionMask);
-        bool interleaved = (mFormatFlags & kAudioFormatFlagIsNonInterleaved) == 0;
-        unsigned sampleSize = SizeOf32(AudioSampleType);
-        reqFormatFlags = kAudioFormatFlagsCanonical;
-        UInt32 reqFrameSize = interleaved ? (mChannelsPerFrame * sampleSize) : sampleSize;
-
-        return ((mFormatFlags & flagsMask) == reqFormatFlags
-            && mBitsPerChannel == 8 * sampleSize
-            && mFramesPerPacket == 1
-            && mBytesPerFrame == reqFrameSize
-            && mBytesPerPacket == reqFrameSize);
-    }
-
-    CA_CANONICAL_DEPRECATED
-    void    SetAUCanonical(UInt32 nChannels, bool interleaved)
-    {
-        mFormatID = kAudioFormatLinearPCM;
-#if CA_PREFER_FIXED_POINT
-        mFormatFlags = kAudioFormatFlagsCanonical | (kAudioUnitSampleFractionBits << kLinearPCMFormatFlagsSampleFractionShift);
-#else
-        mFormatFlags = kAudioFormatFlagsCanonical;
-#endif
-        mChannelsPerFrame = nChannels;
-        mFramesPerPacket = 1;
-        mBitsPerChannel = 8 * SizeOf32(AudioUnitSampleType);
-        if (interleaved)
-            mBytesPerPacket = mBytesPerFrame = nChannels * SizeOf32(AudioUnitSampleType);
-        else {
-            mBytesPerPacket = mBytesPerFrame = SizeOf32(AudioUnitSampleType);
-            mFormatFlags |= kAudioFormatFlagIsNonInterleaved;
-        }
-    }
-
-    void    ChangeNumberChannels(UInt32 nChannels, bool interleaved)
-                // alter an existing format
-    {
-        Assert(IsPCM(), "ChangeNumberChannels only works for PCM formats");
-        UInt32 wordSize = SampleWordSize(); // get this before changing ANYTHING
-        if (wordSize == 0)
-            wordSize = (mBitsPerChannel + 7) / 8;
-        mChannelsPerFrame = nChannels;
-        mFramesPerPacket = 1;
-        if (interleaved) {
-            mBytesPerPacket = mBytesPerFrame = nChannels * wordSize;
-            mFormatFlags &= ~static_cast<UInt32>(kAudioFormatFlagIsNonInterleaved);
-        } else {
-            mBytesPerPacket = mBytesPerFrame = wordSize;
-            mFormatFlags |= kAudioFormatFlagIsNonInterleaved;
-        }
-    }
-
-    // _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
-    //
-    //  other
-
-    // IsEqual: Deprecated because of widespread errors due to the default wildcarding behavior.
-    ASBD_EQUALITY_DEPRECATED
-    bool IsEqual(const AudioStreamBasicDescription &other) const;
-    bool IsEqual(const AudioStreamBasicDescription &other, bool interpretingWildcards) const;
-
-    // IsExactlyEqual: bit-for-bit. usually unnecessarily strict.
-    static bool IsExactlyEqual(const AudioStreamBasicDescription &x, const AudioStreamBasicDescription &y);
-
-    // IsEquivalent: Returns whether the two formats are functionally the same, i.e. if one could
-    // be correctly passed as the other without an AudioConverter.
-    static bool IsEquivalent(const AudioStreamBasicDescription &x, const AudioStreamBasicDescription &y) { return IsEquivalent(x, y, kCompareDefault); }
-    static bool IsEquivalent(const AudioStreamBasicDescription &x, const AudioStreamBasicDescription &y, ComparisonOptions comparisonOptions);
-
-    // Member versions of IsExactlyEqual and IsEquivalent.
-    bool IsExactlyEqual(const AudioStreamBasicDescription &other) const { return IsExactlyEqual(*this, other); }
-    bool IsEquivalent(const AudioStreamBasicDescription &other) const { return IsEquivalent(*this, other); }
-    bool IsEquivalent(const AudioStreamBasicDescription &other, ComparisonOptions comparisonOptions) const { return IsEquivalent(*this, other, comparisonOptions); }
-
-    void    Print() const {
-        Print (stdout);
-    }
-
-    void    Print(FILE* file) const {
-        PrintFormat (file, "", "AudioStreamBasicDescription:");
-    }
-
-    void    PrintFormat(FILE *f, const char *indent, const char *name) const {
-        char buf[256];
-        fprintf(f, "%s%s %s\n", indent, name, AsString(buf, sizeof(buf)));
-    }
-
-    void    PrintFormat2(FILE *f, const char *indent, const char *name) const { // no trailing newline
-        char buf[256];
-        fprintf(f, "%s%s %s", indent, name, AsString(buf, sizeof(buf)));
-    }
-
-    char *  AsString(char *buf, size_t bufsize, bool brief=false) const;
-
-    static void Print (const AudioStreamBasicDescription &inDesc)
-    {
-        CAStreamBasicDescription desc(inDesc);
-        desc.Print ();
-    }
-
-    OSStatus            Save(CFPropertyListRef *outData) const;
-
-    OSStatus            Restore(CFPropertyListRef &inData);
-
-//  Operations
-    static bool         IsMixable(const AudioStreamBasicDescription& inDescription) { return (inDescription.mFormatID == kAudioFormatLinearPCM) && ((inDescription.mFormatFlags & kIsNonMixableFlag) == 0); }
-    CA_CANONICAL_DEPRECATED
-    static void         NormalizeLinearPCMFormat(AudioStreamBasicDescription& ioDescription);
-    CA_CANONICAL_DEPRECATED
-    static void         NormalizeLinearPCMFormat(bool inNativeEndian, AudioStreamBasicDescription& ioDescription);
-    static void         VirtualizeLinearPCMFormat(AudioStreamBasicDescription& ioDescription);
-    static void         VirtualizeLinearPCMFormat(bool inNativeEndian, AudioStreamBasicDescription& ioDescription);
-    static void         ResetFormat(AudioStreamBasicDescription& ioDescription);
-    static void         FillOutFormat(AudioStreamBasicDescription& ioDescription, const AudioStreamBasicDescription& inTemplateDescription);
-    static void         GetSimpleName(const AudioStreamBasicDescription& inDescription, char* outName, UInt32 inMaxNameLength, bool inAbbreviate, bool inIncludeSampleRate = false);
-
-#if CoreAudio_Debug
-    static void         PrintToLog(const AudioStreamBasicDescription& inDesc);
-#endif
-
-    UInt32              GetRegularizedFormatFlags(bool forHardware) const;
-
-private:
-    static bool EquivalentFormatFlags(const AudioStreamBasicDescription &x, const AudioStreamBasicDescription &y, bool forHardware, bool usingWildcards);
-};
-
-#define CAStreamBasicDescription_EmptyInit  0.0, 0, 0, 0, 0, 0, 0, 0, 0
-#define CAStreamBasicDescription_Empty      { CAStreamBasicDescription_EmptyInit }
-
-// operator== is deprecated because it uses the deprecated IsEqual(other, true).
-bool        operator<(const AudioStreamBasicDescription& x, const AudioStreamBasicDescription& y);
-ASBD_EQUALITY_DEPRECATED bool       operator==(const AudioStreamBasicDescription& x, const AudioStreamBasicDescription& y);
-#if TARGET_OS_MAC || (TARGET_OS_WIN32 && (_MSC_VER > 600))
-ASBD_EQUALITY_DEPRECATED inline bool    operator!=(const AudioStreamBasicDescription& x, const AudioStreamBasicDescription& y) { return !(x == y); }
-ASBD_EQUALITY_DEPRECATED inline bool    operator<=(const AudioStreamBasicDescription& x, const AudioStreamBasicDescription& y) { return (x < y) || (x == y); }
-ASBD_EQUALITY_DEPRECATED inline bool    operator>=(const AudioStreamBasicDescription& x, const AudioStreamBasicDescription& y) { return !(x < y); }
-ASBD_EQUALITY_DEPRECATED inline bool    operator>(const AudioStreamBasicDescription& x, const AudioStreamBasicDescription& y) { return !((x < y) || (x == y)); }
-#endif
-
-bool SanityCheck(const AudioStreamBasicDescription& x);
-
-
-#endif // __CAStreamBasicDescription_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAThreadSafeList.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAThreadSafeList.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAThreadSafeList.h
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#ifndef __CAThreadSafeList_h__
-#define __CAThreadSafeList_h__
-
-#include "CAAtomicStack.h"
-
-//  linked list of T's
-//  T must define operator ==
-template <class T>
-class TThreadSafeList {
-private:
-    enum EEventType { kAdd, kRemove, kClear };
-    class Node {
-    public:
-        Node *      mNext;
-        EEventType  mEventType;
-        T           mObject;
-
-        Node *& next() { return mNext; }
-    };
-
-public:
-    class iterator {
-    public:
-        iterator() { }
-        iterator(Node *n) : mNode(n) { }
-
-        bool operator == (const iterator &other) const { return this->mNode == other.mNode; }
-        bool operator != (const iterator &other) const { return this->mNode != other.mNode; }
-
-        T & operator * () const { return mNode->mObject; }
-
-        iterator & operator ++ () { mNode = mNode->next(); return *this; }  // preincrement
-        iterator operator ++ (int) { iterator tmp = *this; mNode = mNode->next(); return tmp; } // postincrement
-
-    private:
-        Node *      mNode;
-    };
-
-    TThreadSafeList() { }
-    ~TThreadSafeList()
-    {
-        mActiveList.free_all();
-        mPendingList.free_all();
-        mFreeList.free_all();
-    }
-
-    // These may be called on any thread
-
-    void    deferred_add(const T &obj)  // can be called on any thread
-    {
-        Node *node = AllocNode();
-        node->mEventType = kAdd;
-        node->mObject = obj;
-        mPendingList.push_atomic(node);
-        //mPendingList.dump("pending after add");
-    }
-
-    void    deferred_remove(const T &obj)   // can be called on any thread
-    {
-        Node *node = AllocNode();
-        node->mEventType = kRemove;
-        node->mObject = obj;
-        mPendingList.push_atomic(node);
-        //mPendingList.dump("pending after remove");
-    }
-
-    void    deferred_clear()                    // can be called on any thread
-    {
-        Node *node = AllocNode();
-        node->mEventType = kClear;
-        mPendingList.push_atomic(node);
-    }
-
-    // These must be called from only one thread
-
-    void    update()        // must only be called from one thread
-    {
-        NodeStack reversed;
-        Node *event, *node, *next;
-        bool workDone = false;
-
-        // reverse the events so they are in order
-        event = mPendingList.pop_all();
-        while (event != NULL) {
-            next = event->mNext;
-            reversed.push_NA(event);
-            event = next;
-            workDone = true;
-        }
-        if (workDone) {
-            //reversed.dump("pending popped");
-            //mActiveList.dump("active before update");
-
-            // now process them
-            while ((event = reversed.pop_NA()) != NULL) {
-                switch (event->mEventType) {
-                case kAdd:
-                    {
-                        Node **pnode;
-                        bool needToInsert = true;
-                        for (pnode = mActiveList.phead(); *pnode != NULL; pnode = &node->mNext) {
-                            node = *pnode;
-                            if (node->mObject == event->mObject) {
-                                //printf("already active!!!\n");
-                                FreeNode(event);
-                                needToInsert = false;
-                                break;
-                            }
-                        }
-                        if (needToInsert) {
-                            // link the new event in at the end of the active list
-                            *pnode = event;
-                            event->mNext = NULL;
-                        }
-                    }
-                    break;
-                case kRemove:
-                    // find matching node in the active list, remove it
-                    for (Node **pnode = mActiveList.phead(); *pnode != NULL; ) {
-                        node = *pnode;
-                        if (node->mObject == event->mObject) {
-                            *pnode = node->mNext;   // remove from linked list
-                            FreeNode(node);
-                            break;
-                        }
-                        pnode = &node->mNext;
-                    }
-                    // dispose the request node
-                    FreeNode(event);
-                    break;
-                case kClear:
-                    for (node = mActiveList.head(); node != NULL; ) {
-                        next = node->mNext;
-                        FreeNode(node);
-                        node = next;
-                    }
-                    FreeNode(event);
-                    break;
-                default:
-                    //printf("invalid node type %d!\n", event->mEventType);
-                    break;
-                }
-            }
-            //mActiveList.dump("active after update");
-        }
-    }
-
-    iterator begin() const {
-        //mActiveList.dump("active at begin");
-        return iterator(mActiveList.head());
-    }
-    iterator end() const { return iterator(NULL); }
-
-
-private:
-    Node *  AllocNode()
-    {
-        Node *node = mFreeList.pop_atomic();
-        if (node == NULL)
-            node = (Node *)CA_malloc(sizeof(Node));
-        return node;
-    }
-
-    void    FreeNode(Node *node)
-    {
-        mFreeList.push_atomic(node);
-    }
-
-private:
-    class NodeStack : public TAtomicStack<Node> {
-    public:
-        void free_all() {
-            Node *node;
-            while ((node = this->pop_NA()) != NULL)
-                free(node);
-        }
-
-        Node ** phead() { return &this->mHead; }
-        Node *  head() const { return this->mHead; }
-    };
-
-    NodeStack   mActiveList;    // what's actually in the container - only accessed on one thread
-    NodeStack   mPendingList;   // add or remove requests - threadsafe
-    NodeStack   mFreeList;      // free nodes for reuse - threadsafe
-};
-
-#endif // __CAThreadSafeList_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAVectorUnit.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAVectorUnit.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAVectorUnit.cpp
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#include "CAVectorUnit.h"
-
-#if !TARGET_OS_WIN32
-    #include <sys/sysctl.h>
-#elif HAS_IPP
-    #include "ippdefs.h"
-    #include "ippcore.h"
-#endif
-
-int gCAVectorUnitType = kVecUninitialized;
-
-#if TARGET_OS_WIN32
-// Use cpuid to check if SSE2 is available.
-// Before calling this function make sure cpuid is available
-static SInt32 IsSSE2Available()
-{
-    int return_value;
-
-    {
-        int r_edx;
-        _asm
-        {
-            mov eax, 0x01
-            cpuid
-            mov r_edx, edx
-        }
-        return_value = (r_edx >> 26) & 0x1;
-    }
-    return return_value;
-}
-
-// Use cpuid to check if SSE3 is available.
-// Before calling this function make sure cpuid is available
-static SInt32 IsSSE3Available()
-{
-    SInt32 return_value;
-
-    {
-        SInt32 r_ecx;
-        _asm
-        {
-            mov eax, 0x01
-            cpuid
-            mov r_ecx, ecx
-        }
-        return_value = r_ecx & 0x1;
-    }
-    return return_value;
-}
-
-// Return true if the cpuid instruction is available.
-// The cpuid instruction is available if bit 21 in the EFLAGS register can be changed
-// This function may not work on Intel CPUs prior to Pentium (didn't test)
-static bool IsCpuidAvailable()
-{
-    SInt32 return_value = 0x0;
-    _asm{
-        pushfd    ;         //push original EFLAGS
-        pop eax   ;         //get original EFLAGS
-        mov ecx, eax   ;    //save original EFLAGS
-        xor eax, 200000h  ; //flip ID bit in EFLAGS
-        push eax   ;        //save new EFLAGS value on stack
-        popfd    ;          //replace current EFLAGS value
-        pushfd    ;         //get new EFLAGS
-        pop eax   ;         //store new EFLAGS in EAX
-        xor eax, ecx   ;
-        je end_cpuid_identify  ; //can't toggle ID bit
-        mov return_value, 0x1;
-end_cpuid_identify:
-        nop;
-        }
-        return return_value;
-}
-
-#endif
-
-SInt32  CAVectorUnit_Examine()
-{
-    int result = kVecNone;
-
-#if TARGET_OS_WIN32
-#if HAS_IPP
-    // Initialize the static IPP library! This needs to be done before
-    // any IPP function calls, otherwise we may have a performance penalty
-    int status = ippStaticInit();
-    if ( status == ippStsNonIntelCpu )
-    {
-        IppCpuType cpuType = ippGetCpuType();
-        if ( cpuType >= ippCpuSSE || cpuType <= ippCpuSSE42 )
-            ippStaticInitCpu( cpuType );
-    }
-#endif
-    {
-        // On Windows we use cpuid to detect the vector unit because it works on Intel and AMD.
-        // The IPP library does not detect SSE on AMD processors.
-        if (IsCpuidAvailable())
-        {
-            if(IsSSE3Available())
-            {
-                result = kVecSSE3;
-            }
-            else if(IsSSE2Available())
-            {
-                result = kVecSSE2;
-            }
-        }
-    }
-#elif TARGET_OS_MAC
-#if DEBUG
-    if (getenv("CA_NoVector")) {
-        fprintf(stderr, "CA_NoVector set; Vector unit optimized routines will be bypassed\n");
-        return result;
-    }
-    else
-#endif
-    {
-    #if (TARGET_CPU_PPC || TARGET_CPU_PPC64)
-        int sels[2] = { CTL_HW, HW_VECTORUNIT };
-        int vType = 0; //0 == scalar only
-        size_t length = sizeof(vType);
-        int error = sysctl(sels, 2, &vType, &length, NULL, 0);
-        if (!error && vType > 0)
-            result = kVecAltivec;
-    #elif (TARGET_CPU_X86 || TARGET_CPU_X86_64)
-        static const struct { const char* kName; const int kVectype; } kStringVectypes[] = {
-            { "hw.optional.avx1_0", kVecAVX1 }, { "hw.optional.sse3", kVecSSE3 }, { "hw.optional.sse2", kVecSSE2 }
-        };
-        static const size_t kNumStringVectypes = sizeof(kStringVectypes)/sizeof(kStringVectypes[0]);
-        int i = 0, answer = 0;
-        while(i != kNumStringVectypes)
-        {
-            size_t length = sizeof(answer);
-            int error = sysctlbyname(kStringVectypes[i].kName, &answer, &length, NULL, 0);
-            if (!error && answer)
-            {
-                result = kStringVectypes[i].kVectype;
-                break;
-            }
-            ++i;
-        };
-    #elif CA_ARM_NEON
-        result = kVecNeon;
-    #endif
-    }
-#endif
-    gCAVectorUnitType = result;
-    return result;
-}
-
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAVectorUnit.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAVectorUnit.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAVectorUnit.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#ifndef __CAVectorUnit_h__
-#define __CAVectorUnit_h__
-
-#include <TargetConditionals.h>
-#include "CAVectorUnitTypes.h"
-#include <stdlib.h>
-#include <stdio.h>
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreFoundation/CFBase.h>
-#else
-    #include "CFBase.h"
-#endif
-
-// Unify checks for vector units.
-// Allow setting an environment variable "CA_NoVector" to turn off vectorized code at runtime (very useful for performance testing).
-
-extern int gCAVectorUnitType;
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-extern SInt32 CAVectorUnit_Examine();   // expensive. use GetType() for lazy initialization and caching.
-
-static inline SInt32 CAVectorUnit_GetType()
-{
-    int x = gCAVectorUnitType;
-    return (x != kVecUninitialized) ? x : CAVectorUnit_Examine();
-}
-
-static inline Boolean CAVectorUnit_HasVectorUnit()
-{
-    return CAVectorUnit_GetType() > kVecNone;
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#ifdef __cplusplus
-class CAVectorUnit {
-public:
-    static SInt32       GetVectorUnitType() { return CAVectorUnit_GetType(); }
-    static bool         HasVectorUnit() { return GetVectorUnitType() > kVecNone; }
-    static bool         HasAltivec() { return GetVectorUnitType() == kVecAltivec; }
-    static bool         HasSSE2() { return GetVectorUnitType() >= kVecSSE2; }
-    static bool         HasSSE3() { return GetVectorUnitType() >= kVecSSE3; }
-    static bool         HasAVX1() { return GetVectorUnitType() >= kVecAVX1; }
-    static bool         HasNeon() { return GetVectorUnitType() == kVecNeon; }
-};
-#endif
-
-#endif // __CAVectorUnit_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAVectorUnitTypes.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAVectorUnitTypes.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAVectorUnitTypes.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#ifndef __CAVectorUnitTypes_h__
-#define __CAVectorUnitTypes_h__
-
-enum {
-    kVecUninitialized = -1,
-    kVecNone = 0,
-    kVecAltivec = 1,
-    kVecSSE2 = 100,
-    kVecSSE3 = 101,
-    kVecAVX1 = 110,
-    kVecNeon = 200
-};
-
-#endif
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAXException.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAXException.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAXException.cpp
+++ /dev/null
@@ -1,11 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#include "CAXException.h"
-
-CAXException::WarningHandler CAXException::sWarningHandler = NULL;
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAXException.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAXException.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAXException.h
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
-See LICENSE.txt for this sampleâ€™s licensing information
-
-Abstract:
-Part of Core Audio Public Utility Classes
-*/
-
-#ifndef __CAXException_h__
-#define __CAXException_h__
-
-#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
-    #include <CoreFoundation/CoreFoundation.h>
-#else
-    #include <ConditionalMacros.h>
-    #include <CoreFoundation.h>
-#endif
-#include "CADebugMacros.h"
-#include <ctype.h>
-//#include <stdio.h>
-#include <string.h>
-
-
-class CAX4CCString {
-public:
-    CAX4CCString(OSStatus error) {
-        // see if it appears to be a 4-char-code
-        UInt32 beErr = CFSwapInt32HostToBig(error);
-        char *str = mStr;
-        memcpy(str + 1, &beErr, 4);
-        if (isprint(str[1]) && isprint(str[2]) && isprint(str[3]) && isprint(str[4])) {
-            str[0] = str[5] = '\'';
-            str[6] = '\0';
-        } else if (error > -200000 && error < 200000)
-            // no, format it as an integer
-            snprintf(str, sizeof(mStr), "%d", (int)error);
-        else
-            snprintf(str, sizeof(mStr), "0x%x", (int)error);
-    }
-    const char *get() const { return mStr; }
-    operator const char *() const { return mStr; }
-private:
-    char mStr[16];
-};
-
-class CAX4CCStringNoQuote {
-public:
-    CAX4CCStringNoQuote(OSStatus error) {
-        // see if it appears to be a 4-char-code
-        UInt32 beErr = CFSwapInt32HostToBig(error);
-        char *str = mStr;
-        memcpy(str, &beErr, 4);
-        if (isprint(str[0]) && isprint(str[1]) && isprint(str[2]) && isprint(str[3])) {
-            str[4] = '\0';
-        } else if (error > -200000 && error < 200000)
-            // no, format it as an integer
-            snprintf(str, sizeof(mStr), "%d", (int)error);
-        else
-            snprintf(str, sizeof(mStr), "0x%x", (int)error);
-    }
-    const char *get() const { return mStr; }
-    operator const char *() const { return mStr; }
-private:
-    char mStr[16];
-};
-
-
-// An extended exception class that includes the name of the failed operation
-class CAXException {
-public:
-    CAXException(const char *operation, OSStatus err) :
-        mError(err)
-        {
-            if (operation == NULL)
-                mOperation[0] = '\0';
-            else if (strlen(operation) >= sizeof(mOperation)) {
-                memcpy(mOperation, operation, sizeof(mOperation) - 1);
-                mOperation[sizeof(mOperation) - 1] = '\0';
-            } else
-
-            strlcpy(mOperation, operation, sizeof(mOperation));
-        }
-
-    char *FormatError(char *str, size_t strsize) const
-    {
-        return FormatError(str, strsize, mError);
-    }
-
-    char                mOperation[256];
-    const OSStatus      mError;
-
-    // -------------------------------------------------
-
-    typedef void (*WarningHandler)(const char *msg, OSStatus err);
-
-    static char *FormatError(char *str, size_t strsize, OSStatus error)
-    {
-        strlcpy(str, CAX4CCString(error), strsize);
-        return str;
-    }
-
-    static void Warning(const char *s, OSStatus error)
-    {
-        if (sWarningHandler)
-            (*sWarningHandler)(s, error);
-    }
-
-    static void SetWarningHandler(WarningHandler f) { sWarningHandler = f; }
-private:
-    static WarningHandler   sWarningHandler;
-};
-
-#if DEBUG || CoreAudio_Debug
-    #define XThrowIfError(error, operation)                                     \
-        do {                                                                    \
-            OSStatus __err = error;                                             \
-            if (__err) {                                                        \
-                DebugMessageN4("%s:%d: about to throw %s: %s", __FILE__, __LINE__, CAX4CCString(__err).get(), operation);\
-                __THROW_STOP;                                                           \
-                throw CAXException(operation, __err);                           \
-            }                                                                   \
-        } while (0)
-
-    #define XThrowIf(condition, error, operation)                               \
-        do {                                                                    \
-            if (condition) {                                                    \
-                OSStatus __err = error;                                         \
-                DebugMessageN4("%s:%d: about to throw %s: %s", __FILE__, __LINE__, CAX4CCString(__err).get(), operation);\
-                __THROW_STOP;                                                           \
-                throw CAXException(operation, __err);                           \
-            }                                                                   \
-        } while (0)
-
-    #define XRequireNoError(error, label)                                       \
-        do {                                                                    \
-            OSStatus __err = error;                                             \
-            if (__err) {                                                        \
-                DebugMessageN4("%s:%d: about to throw %s: %s", __FILE__, __LINE__, CAX4CCString(__err).get(), #error);\
-                STOP;                                                           \
-                goto label;                                                     \
-            }                                                                   \
-        } while (0)
-
-    #define XAssert(assertion)                                                  \
-        do {                                                                    \
-            if (!(assertion)) {                                                 \
-                DebugMessageN3("%s:%d: error: failed assertion: %s", __FILE__, __LINE__, #assertion);       \
-                __ASSERT_STOP;                                                          \
-            }                                                                   \
-        } while (0)
-
-    #define XAssertNoError(error)                                               \
-        do {                                                                    \
-            OSStatus __err = error;                                             \
-            if (__err) {                                                        \
-                DebugMessageN4("%s:%d: error %s: %s", __FILE__, __LINE__, CAX4CCString(__err).get(), #error);\
-                __ASSERT_STOP;                                                          \
-            }                                                                   \
-        } while (0)
-
-    #define ca_require_noerr(errorCode, exceptionLabel)                         \
-        do                                                                      \
-        {                                                                       \
-            int evalOnceErrorCode = (errorCode);                                \
-            if ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \
-            {                                                                   \
-                DebugMessageN5("ca_require_noerr: [%s, %d] (goto %s;) %s:%d",   \
-                    #errorCode, evalOnceErrorCode,                              \
-                    #exceptionLabel,                                            \
-                    __FILE__,                                                   \
-                    __LINE__);                                                  \
-                goto exceptionLabel;                                            \
-            }                                                                   \
-        } while ( 0 )
-
-    #define ca_verify_noerr(errorCode)                                          \
-        do                                                                      \
-        {                                                                       \
-            int evalOnceErrorCode = (errorCode);                                \
-            if ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \
-            {                                                                   \
-                DebugMessageN4("ca_verify_noerr: [%s, %d] %s:%d",               \
-                    #errorCode, evalOnceErrorCode,                              \
-                    __FILE__,                                                   \
-                    __LINE__);                                                  \
-            }                                                                   \
-        } while ( 0 )
-
-    #define ca_debug_string(message)                                            \
-        do                                                                      \
-        {                                                                       \
-            DebugMessageN3("ca_debug_string: %s %s:%d",                         \
-                message,                                                        \
-                __FILE__,                                                       \
-                __LINE__);                                                      \
-        } while ( 0 )
-
-
-    #define ca_verify(assertion)                                                \
-        do                                                                      \
-        {                                                                       \
-            if ( __builtin_expect(!(assertion), 0) )                            \
-            {                                                                   \
-                DebugMessageN3("ca_verify: %s %s:%d",                           \
-                    #assertion,                                                 \
-                    __FILE__,                                                   \
-                    __LINE__);                                                  \
-            }                                                                   \
-        } while ( 0 )
-
-    #define ca_require(assertion, exceptionLabel)                               \
-        do                                                                      \
-        {                                                                       \
-            if ( __builtin_expect(!(assertion), 0) )                            \
-            {                                                                   \
-                DebugMessageN4("ca_require: %s %s %s:%d",                       \
-                    #assertion,                                                 \
-                    #exceptionLabel,                                            \
-                    __FILE__,                                                   \
-                    __LINE__);                                                  \
-                goto exceptionLabel;                                            \
-            }                                                                   \
-        } while ( 0 )
-
-   #define ca_check(assertion)                                                  \
-      do                                                                        \
-      {                                                                         \
-          if ( __builtin_expect(!(assertion), 0) )                              \
-          {                                                                     \
-              DebugMessageN3("ca_check: %s %s:%d",                          \
-                  #assertion,                                                   \
-                  __FILE__,                                                     \
-                  __LINE__);                                                    \
-          }                                                                     \
-      } while ( 0 )
-
-#else
-    #define XThrowIfError(error, operation)                                     \
-        do {                                                                    \
-            OSStatus __err = error;                                             \
-            if (__err) {                                                        \
-                throw CAXException(operation, __err);                           \
-            }                                                                   \
-        } while (0)
-
-    #define XThrowIf(condition, error, operation)                               \
-        do {                                                                    \
-            if (condition) {                                                    \
-                OSStatus __err = error;                                         \
-                throw CAXException(operation, __err);                           \
-            }                                                                   \
-        } while (0)
-
-    #define XRequireNoError(error, label)                                       \
-        do {                                                                    \
-            OSStatus __err = error;                                             \
-            if (__err) {                                                        \
-                goto label;                                                     \
-            }                                                                   \
-        } while (0)
-
-    #define XAssert(assertion)                                                  \
-        do {                                                                    \
-            if (!(assertion)) {                                                 \
-            }                                                                   \
-        } while (0)
-
-    #define XAssertNoError(error)                                               \
-        do {                                                                    \
-            /*OSStatus __err =*/ error;                                         \
-        } while (0)
-
-    #define ca_require_noerr(errorCode, exceptionLabel)                         \
-        do                                                                      \
-        {                                                                       \
-            if ( __builtin_expect(0 != (errorCode), 0) )                        \
-            {                                                                   \
-                goto exceptionLabel;                                            \
-            }                                                                   \
-        } while ( 0 )
-
-    #define ca_verify_noerr(errorCode)                                          \
-        do                                                                      \
-        {                                                                       \
-            if ( 0 != (errorCode) )                                             \
-            {                                                                   \
-            }                                                                   \
-        } while ( 0 )
-
-    #define ca_debug_string(message)
-
-    #define ca_verify(assertion)                                                \
-        do                                                                      \
-        {                                                                       \
-            if ( !(assertion) )                                                 \
-            {                                                                   \
-            }                                                                   \
-        } while ( 0 )
-
-    #define ca_require(assertion, exceptionLabel)                               \
-        do                                                                      \
-        {                                                                       \
-            if ( __builtin_expect(!(assertion), 0) )                            \
-            {                                                                   \
-                goto exceptionLabel;                                            \
-            }                                                                   \
-        } while ( 0 )
-
-   #define ca_check(assertion)                                                  \
-        do                                                                      \
-        {                                                                       \
-            if ( !(assertion) )                                                 \
-            {                                                                   \
-            }                                                                   \
-        } while ( 0 )
-
-
-#endif
-
-#define XThrow(error, operation) XThrowIf(true, error, operation)
-#define XThrowIfErr(error) XThrowIfError(error, #error)
-
-#endif // __CAXException_h__
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/LICENSE.txt b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/LICENSE.txt
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/LICENSE.txt
+++ /dev/null
@@ -1,42 +0,0 @@
-Sample code project: Audio Unit Examples (AudioUnit Effect, Generator, Instrument, MIDI Processor and Offline)
-Version: 2.0
-
-IMPORTANT:  This Apple software is supplied to you by Apple
-Inc. ("Apple") in consideration of your agreement to the following
-terms, and your use, installation, modification or redistribution of
-this Apple software constitutes acceptance of these terms.  If you do
-not agree with these terms, please do not use, install, modify or
-redistribute this Apple software.
-
-In consideration of your agreement to abide by the following terms, and
-subject to these terms, Apple grants you a personal, non-exclusive
-license, under Apple's copyrights in this original Apple software (the
-"Apple Software"), to use, reproduce, modify and redistribute the Apple
-Software, with or without modifications, in source and/or binary forms;
-provided that if you redistribute the Apple Software in its entirety and
-without modifications, you must retain this notice and the following
-text and disclaimers in all such redistributions of the Apple Software.
-Neither the name, trademarks, service marks or logos of Apple Inc. may
-be used to endorse or promote products derived from the Apple Software
-without specific prior written permission from Apple.  Except as
-expressly stated in this notice, no other rights or licenses, express or
-implied, are granted by Apple herein, including but not limited to any
-patent rights that may be infringed by your derivative works or by other
-works in which the Apple Software may be incorporated.
-
-The Apple Software is provided by Apple on an "AS IS" basis.  APPLE
-MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
-THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
-FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
-OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
-
-IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
-OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
-MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
-AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
-STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-
-Copyright (C) 2016 Apple Inc. All Rights Reserved.
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/ReadMe.txt b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/ReadMe.txt
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/ReadMe.txt
+++ /dev/null
@@ -1,92 +0,0 @@
-ReadMe for AudioUnitExamples
------------------------------
-Version 2.0 (February 2016)
-
-/* ----------------------------- */
-
-NOTE: While AudioUnitExamples presents up to date (as of OS X 10.11.x) examples of Version 2 Audio Unit Plugins, with the release of OS X 10.11 Apple introduced the Version 3 Audio Unit Extension API.
-
-The Audio Unit Extensions API introduces a mechanism for developers to deliver Audio Units to users on iOS and OS X as App Extensions.
-The same API is available on both iOS and OS X and provides a bridging mechanism for existing Version 2 Audio Units and hosts to work with new Version 3 Audio Units and hosts.
-
-For more information regarding Version 3 Audio Unit Extensions, see the following resources:
-
-Audio Unit Extensions 2015 WWDC Video:
-
-    https://developer.apple.com/videos/play/wwdc2015-508/
-
-App Extension Programming Guide:
-
-    https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/
-
-AudioUnitV3Example:
-
-    https://developer.apple.com/library/ios/samplecode/AudioUnitV3Example/Introduction/Intro.html
-
-We encourage Audio Unit developers to adopt and move to the Version 3 Audio Unit Extension model for iOS 9 and OS X 10.11 forward.
-
-/* ----------------------------- */
-
-AudioUnitExamples is a collection of Version 2 AudioUnit sample code. Each project demonstrates how to create an AudioUnit of a specific type (i.e. Effect, Generator, Instrument, MIDI Processor and Offline Effect).
-
-AudioUnitEffectExample
-	This sample builds a simple low pass filter as an Effect AudioUnit with custom view. 
-AudioUnitGeneratorExample
-	This sample builds a pink noise generator as a Generator AudioUnit. 
-AudioUnitInstrumentExample
-	This sample builds a basic sin wave synth as an Instrument AudioUnit.
-AudioUnitOfflineEffectExample
-	This sample builds a simple Offline Effect AudioUnit.
-AudioUnitMidiProcessorExample
-    This sample buids a pass through midi processor. AU's of this type process midi input and produce midi output but do not produce any audio.
-StarterAudioUnitExample (TremoloUnit)
-	This sample is referenced in the AudioUnit programming guide. 
-
-The tutorial for Audio Unit Programming Guide is available in the ADC Reference Library at this location:
-
-	http://developer.apple.com/documentation/MusicAudio/Conceptual/AudioUnitProgrammingGuide/
-
-Technical note TN2247 describes how to support sandboxing in an AudioUnit
-
-	https://developer.apple.com/library/ios/technotes/tn2247
-
-Technical note TN2276 contains legacy information regarding Component Manager Based Audio Units (OS X 10.6 and earlier) and Audio
-Unit Plugins (10.7 and newer). This information is presented for completeness only. The AudioUnitExamples projects all build AUPlugins.
-
-    https://developer.apple.com/library/mac/technotes/tn2276
-
-Installation
-------------
-To install one of the sample audio unit for testing, place the built audio unit (e.g. FilterDemo.component) to the following directory. 
-
-	~/Library/Audio/Plug-Ins/Components/
-
-or to:
-
-	/Library/Audio/Plug-Ins/Components/
-
-
-Testing the Audio Unit
-----------------------
-To test your Audio Unit after installing it, use an Audio Unit hosting application such as "AU Lab".  AU Lab is part of the Audio Tools for Xcode. 
-
-Please refer to the following technical Q&A (QA1731) on how to download Audio Tools.
-
-	https://developer.apple.com/library/mac/qa/qa1731
-
-
-Sample Requirements
--------------------
-This sample project requires:
-	
-	Mac OS X v10.11.2 or later
-	Xcode 7.2.1 or later
-	
-Feedback
---------
-To send feedback to Apple about this sample project, use the feedback form at 
-this location:
-
-	http://developer.apple.com/contact/
-
-Copyright (C) 2004-2016 Apple Inc. All rights reserved.
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioEqualizer.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioEqualizer.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioEqualizer.cpp
+++ b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioEqualizer.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -32,35 +32,10 @@
 #define IND_A1 1
 #define IND_A2 2
 #define IND_B1 3
 #define IND_B2 4
 
-class AVFEqualizerKernel : public AUKernelBase {
-public:
-    AVFEqualizerKernel(AVFAudioEqualizer *eq, AUEffectBase *inAudioUnit) :
-        AUKernelBase(dynamic_cast<AUEffectBase*>(inAudioUnit)),
-        mEQ(eq)
-    {}
-
-    virtual ~AVFEqualizerKernel() {}
-
-    virtual void Process(const Float32 *inSourceP,
-                         Float32 *inDestP,
-                         UInt32 inFramesToProcess,
-                         UInt32 inNumChannels,
-                         bool& ioSilence) {
-        if (ioSilence) {
-            return;
-        }
-
-        mEQ->RunFilter(inSourceP, inDestP, inFramesToProcess, mChannelNum);
-    }
-
-private:
-    AVFAudioEqualizer *mEQ;
-};
-
 #pragma mark -
 
 AVFEqualizerBand::AVFEqualizerBand(AVFAudioEqualizer *eq, double frequency, double bandwidth, double gain) :
     CEqualizerBand(bandwidth, gain),
     mEQ(eq),
@@ -69,11 +44,11 @@
     mHistory(NULL),
     mFrequency(frequency),
     mFilterType(Peak)  // set later by the EQ, can be changed if band moves
 {
     // we may not have an audio unit yet
-    int channels = mEQ->GetChannelCount();
+    int channels = mEQ->GetChannels();
     if (channels > 0) {
         SetChannelCount(channels);
     }
     RecalculateParams();
 }
@@ -160,11 +135,11 @@
  * Note that the GStreamer coefficient names (a0-a2,b0-b2) are swapped from other
  * examples, but the use is the same.
  */
 void AVFEqualizerBand::SetupPeakFilter(double omega, double bw, double gain) {
     double cosF = cos(omega);
-    double alpha =  tan(bw / 2.0);
+    double alpha = tan(bw / 2.0);
     double alpha1 = alpha * gain;
     double alpha2 = alpha / gain;
 
     // set up peak filter coefficients
     mCoefficients[IND_A0] = 1.0 + alpha1;
@@ -228,11 +203,11 @@
     if (bw <= 0.0) {
         // no bandwidth, no filter...
         mBypass = true;
         return;
     }
-    double absGain = pow(10, m_Gain / 40);      // convert dB to scale
+    double absGain = pow(10, m_Gain / 40); // convert dB to scale
     double omega = calculate_omega(mFrequency, rate);
 
     switch (mFilterType) {
         case Peak:
             SetupPeakFilter(omega, bw, absGain);
@@ -256,11 +231,11 @@
         return;
     }
 
     // We may have more channels now than when we were initialized
     if (channel > mChannels) {
-        mChannels = mEQ->GetChannelCount();
+        mChannels = mEQ->GetChannels();
         SetChannelCount(mChannels);
     }
 
     if (mChannels > 0 && mHistory != NULL) {
         // copy source and dest history
@@ -270,46 +245,59 @@
         inDest[0] = mHistory[channel].y2;
 
         vDSP_deq22D(inSource, 1, mCoefficients, inDest, 1, frameCount);
 
         // update history
-        mHistory[channel].x1 = inSource[frameCount+1];
+        mHistory[channel].x1 = inSource[frameCount + 1];
         mHistory[channel].x2 = inSource[frameCount];
-        mHistory[channel].y1 = inDest[frameCount+1];
+        mHistory[channel].y1 = inDest[frameCount + 1];
         mHistory[channel].y2 = inDest[frameCount];
     }
 }
 
 #pragma mark -
 
+AVFAudioEqualizer::AVFAudioEqualizer() : CAudioEqualizer(),
+                                         mEnabled(false),
+                                         mEQBands(),
+                                         mEQBufferSize(0),
+                                         mEQBufferA(NULL),
+                                         mEQBufferB(NULL),
+                                         mSampleRate(0),
+                                         mChannels(0) {
+}
+
 AVFAudioEqualizer::~AVFAudioEqualizer() {
-    mEQBufferA.free();
-    mEQBufferB.free();
+    if (mEQBufferA != NULL) {
+        free(mEQBufferA);
+        mEQBufferA = NULL;
+    }
+
+    if (mEQBufferB != NULL) {
+        free(mEQBufferB);
+        mEQBufferB = NULL;
+    }
 
     // Free the EQ bands, otherwise they'll leak
     for (AVFEQBandIterator iter = mEQBands.begin(); iter != mEQBands.end(); iter++) {
         if (iter->second) {
             delete iter->second;
         }
     }
     mEQBands.clear();
 }
 
-AUKernelBase *AVFAudioEqualizer::NewKernel() {
-    return new AVFEqualizerKernel(this, mAudioUnit);
-}
-
 bool AVFAudioEqualizer::IsEnabled() {
     return mEnabled;
 }
 
 void AVFAudioEqualizer::SetEnabled(bool isEnabled) {
     mEnabled = isEnabled;
 }
 
 int AVFAudioEqualizer::GetNumBands() {
-    return (int)mEQBands.size();
+    return (int) mEQBands.size();
 }
 
 CEqualizerBand *AVFAudioEqualizer::AddBand(double frequency, double bandwidth, double gain) {
     if (!mEQBands[frequency]) {
         mEQBands[frequency] = new AVFEqualizerBand(this, frequency, bandwidth, gain);
@@ -369,40 +357,83 @@
         } else if (iter == --(mEQBands.end())) {
             type = AVFEqualizerBand::HighShelf;
         }
 
         band->SetFilterType(type);
-        band->SetChannelCount(GetChannelCount());
+        band->SetChannelCount(GetChannels());
         band->RecalculateParams();
         iter++; // here due to NULL ptr protection, otherwise we double increment
     }
+
+    // Clear temp buffers
+    if (mEQBufferA != NULL) {
+        memset(mEQBufferA, 0, mEQBufferSize * sizeof(double));
+    }
+
+    if (mEQBufferB != NULL) {
+        memset(mEQBufferB, 0, mEQBufferSize * sizeof(double));
+    }
 }
 
-void AVFAudioEqualizer::SetAudioUnit(AUEffectBase *unit) {
-    this->AVFKernelProcessor::SetAudioUnit(unit);
-    ResetBandParameters();
+void AVFAudioEqualizer::SetSampleRate(UInt32 rate) {
+    mSampleRate = rate;
+}
+
+void AVFAudioEqualizer::SetChannels(UInt32 count) {
+    mChannels = count;
+}
+
+UInt32 AVFAudioEqualizer::GetSampleRate() {
+    return mSampleRate;
+}
+
+UInt32 AVFAudioEqualizer::GetChannels() {
+    return mChannels;
+}
+
+bool AVFAudioEqualizer::ProcessBufferLists(const AudioBufferList & buffer,
+                                               UInt32 inFramesToProcess) {
+    for (UInt32 i = 0; i < buffer.mNumberBuffers; i++) {
+        RunFilter((const Float32 *) buffer.mBuffers[i].mData,
+                  (Float32 *) buffer.mBuffers[i].mData,
+                  inFramesToProcess,
+                  i);
+    }
+
+    return true;
 }
 
 void AVFAudioEqualizer::RunFilter(const Float32 *inSourceP,
-                                  Float32 *inDestP,
-                                  UInt32 inFramesToProcess,
-                                  UInt32 channel) {
+        Float32 *inDestP,
+        UInt32 inFramesToProcess,
+        UInt32 channel) {
     if (mEnabled && !mEQBands.empty()) {
         if (inFramesToProcess + 2 > mEQBufferSize) {
             mEQBufferSize = inFramesToProcess + 2;
-            mEQBufferA.free();
-            mEQBufferA.alloc(mEQBufferSize);
-            mEQBufferB.free();
-            mEQBufferB.alloc(mEQBufferSize);
+            if (mEQBufferA != NULL) {
+                free(mEQBufferA);
+                mEQBufferA = NULL;
+            }
+            if (mEQBufferB != NULL) {
+                free(mEQBufferB);
+                mEQBufferB = NULL;
+            }
+
+            mEQBufferA = (double*)calloc(mEQBufferSize, sizeof(double));
+            mEQBufferB = (double*)calloc(mEQBufferSize, sizeof(double));
+        }
+
+        if (mEQBufferA == NULL || mEQBufferB == NULL) {
+            return;
         }
 
         // start processing with A buffer first
         bool srcA = true;
 
         // The first two elements are copied each time we call a band to process
-            // float* cast is needed for Xcode 4.5
-        vDSP_vspdp((float*)inSourceP, 1, mEQBufferA.get() + 2, 1, inFramesToProcess);
+        // float* cast is needed for Xcode 4.5
+        vDSP_vspdp((float*) inSourceP, 1, mEQBufferA + 2, 1, inFramesToProcess);
 
         // Run each band in sequence
         for (AVFEQBandIterator iter = mEQBands.begin(); iter != mEQBands.end(); iter++) {
             if (iter->second) {
                 if (srcA) {
@@ -413,8 +444,8 @@
                 srcA = !srcA;
             }
         }
 
         // Copy back to dest stream
-        vDSP_vdpsp((srcA ? mEQBufferA : mEQBufferB)+2, 1, inDestP, 1, inFramesToProcess);
+        vDSP_vdpsp((srcA ? mEQBufferA : mEQBufferB) + 2, 1, inDestP, 1, inFramesToProcess);
     }
 }
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioEqualizer.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioEqualizer.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioEqualizer.h
+++ b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioEqualizer.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -29,34 +29,34 @@
 #include <PipelineManagement/AudioEqualizer.h>
 
 #include <map>
 #include <memory>
 
-#include "AVFKernelProcessor.h"
-#include "CAAutoDisposer.h"
+#include <AudioUnit/AudioUnit.h>
 
 class AVFAudioEqualizer;
 
 struct AVFEQBandHistory {
 public:
-    double x1, x2;  // input history
-    double y1, y2;  // output history
+    double x1, x2; // input history
+    double y1, y2; // output history
 
     AVFEQBandHistory() :
-        x1(0.0),
-        x2(0.0),
-        y1(0.0),
-        y2(0.0)
-    {}
+    x1(0.0),
+    x2(0.0),
+    y1(0.0),
+    y2(0.0) {
+    }
 };
 
 class AVFEqualizerBand : public CEqualizerBand {
 public:
+
     enum AVFEqualizerFilterType {
-        Peak,       // Use for middle bands
-        LowShelf,   // Use for lowest freq band
-        HighShelf   // Use for highest freq band
+        Peak, // Use for middle bands
+        LowShelf, // Use for lowest freq band
+        HighShelf // Use for highest freq band
     };
     AVFEqualizerBand(AVFAudioEqualizer *eq, double frequency, double bandwidth, double gain);
 
     virtual ~AVFEqualizerBand();
 
@@ -90,11 +90,11 @@
     void SetFilterType(AVFEqualizerFilterType type);
 
 private:
     AVFAudioEqualizer *mEQ;
     bool mBypass;
-    int mChannels;          // number of channels to process
+    int mChannels; // number of channels to process
     AVFEQBandHistory *mHistory; // one per channel
     double mFrequency;
     AVFEqualizerFilterType mFilterType;
 
     // We're implementing a simple biquadratic peak/notch filter (depending on gain)
@@ -106,65 +106,50 @@
     void SetupPeakFilter(double omega, double bw, double absGain);
     void SetupLowShelfFilter(double omega, double bw, double absGain);
     void SetupHighShelfFilter(double omega, double bw, double absGain);
 };
 
-typedef std::map<double,AVFEqualizerBand*> AVFEQBandMap;
+typedef std::map<double, AVFEqualizerBand*> AVFEQBandMap;
 typedef AVFEQBandMap::iterator AVFEQBandIterator;
 
 // Simple bridge class that forwards messages to it's AVFMediaPlayer
-class AVFAudioEqualizer : public AVFKernelProcessor, public CAudioEqualizer {
+
+class AVFAudioEqualizer : public CAudioEqualizer {
 public:
-    AVFAudioEqualizer() :
-        AVFKernelProcessor(),
-        CAudioEqualizer(),
-        mEnabled(false),
-        mEQBands(),
-        mEQBufferSize(0),
-        mEQBufferA(),
-        mEQBufferB()
-    {}
 
+    AVFAudioEqualizer();
     virtual ~AVFAudioEqualizer();
 
-    virtual AUKernelBase *NewKernel();
-
     virtual bool IsEnabled();
     virtual void SetEnabled(bool isEnabled);
     virtual int GetNumBands();
     virtual CEqualizerBand *AddBand(double frequency, double bandwidth, double gain);
     virtual bool RemoveBand(double frequency);
 
     void MoveBand(double oldFrequency, double newFrequency);
 
-    virtual void SetAudioUnit(AUEffectBase *unit);
+    void SetSampleRate(UInt32 rate);
+    void SetChannels(UInt32 count);
+    UInt32 GetSampleRate();
+    UInt32 GetChannels();
 
-    double GetSampleRate() {
-        if (mAudioUnit) {
-            return (double)mAudioUnit->GetSampleRate();
-        }
-        return 0.0;
-    }
-
-    int GetChannelCount() {
-        if (mAudioUnit) {
-            return mAudioUnit->GetNumberOfChannels();
-        }
-        return 0;
-    }
+    bool ProcessBufferLists(const AudioBufferList & buffer,
+                                UInt32 inFramesToProcess);
 
     void RunFilter(const Float32 *inSourceP, Float32 *inDestP, UInt32 inFramesToProcess, UInt32 channel);
 
+    // Call this after adding, removing or reordering bands
+    void ResetBandParameters();
+
 private:
     bool mEnabled;
     AVFEQBandMap mEQBands;
     int mEQBufferSize;
-    CAAutoFree<double> mEQBufferA; // temp storage since we have to process out of line
-    CAAutoFree<double> mEQBufferB;
-
-    // Call this after adding, removing or reordering bands
-    void ResetBandParameters();
+    double *mEQBufferA; // temp storage since we have to process out of line
+    double *mEQBufferB;
+    UInt32 mSampleRate;
+    UInt32 mChannels;
 };
 
 typedef std::shared_ptr<AVFAudioEqualizer> AVFAudioEqualizerPtr;
 
 #endif /* defined(__JFXMedia__AVFAudioEqualizer__) */
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioProcessor.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioProcessor.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioProcessor.h
+++ b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioProcessor.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,10 +30,29 @@
 #import "AVFAudioSpectrumUnit.h"
 #import "AVFAudioEqualizer.h"
 
 @class AVFMediaPlayer;
 
+class AVFTapContext {
+public:
+
+    AVFTapContext(AVFSoundLevelUnitPtr slu, AVFAudioSpectrumUnitPtr spectrum, AVFAudioEqualizerPtr eq);
+    ~AVFTapContext();
+
+    // Hold on to these while we're running
+    AVFSoundLevelUnitPtr audioSLU;
+    AVFAudioSpectrumUnitPtr audioSpectrum;
+    AVFAudioEqualizerPtr audioEQ;
+
+    // Audio parameters
+    UInt32 mSampleRate;
+    UInt32 mChannels;
+    UInt32 mMaxFrames;
+};
+
+typedef std::shared_ptr<AVFTapContext> AVFTapContextPtr;
+
 @interface AVFAudioProcessor : NSObject {
     AVAudioMix *_mixer;
 }
 
 @property (nonatomic,readonly) AVFSoundLevelUnitPtr soundLevelUnit;
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioProcessor.mm b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioProcessor.mm
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioProcessor.mm
+++ b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioProcessor.mm
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,62 +27,33 @@
 #import "AVFMediaPlayer.h"
 
 #import <AVFoundation/AVFoundation.h>
 #import <MediaToolbox/MediaToolbox.h>
 
-#import "AVFKernelProcessor.h"
 #import <CoreFoundation/CoreFoundation.h>
 
 #import <pthread.h>
 #import <objc/message.h>
 
 static void InitAudioTap(MTAudioProcessingTapRef tapRef, void *clientInfo, void **tapStorageOut);
 static void FinalizeAudioTap(MTAudioProcessingTapRef tapRef);
 static void PrepareAudioTap(MTAudioProcessingTapRef tapRef,
-                            CMItemCount maxFrames,
-                            const AudioStreamBasicDescription *processingFormat);
+        CMItemCount maxFrames,
+        const AudioStreamBasicDescription *processingFormat);
 static void UnprepareAudioTap(MTAudioProcessingTapRef tapRef);
 static void ProcessAudioTap(MTAudioProcessingTapRef tapRef, CMItemCount numberFrames,
-                            MTAudioProcessingTapFlags flags,
-                            AudioBufferList *bufferListInOut,
-                            CMItemCount *numberFramesOut,
-                            MTAudioProcessingTapFlags *flagsOut);
-
+        MTAudioProcessingTapFlags flags,
+        AudioBufferList *bufferListInOut,
+        CMItemCount *numberFramesOut,
+        MTAudioProcessingTapFlags *flagsOut);
 static OSStatus AVFTapRenderCallback(void *inRefCon,
                                      AudioUnitRenderActionFlags *ioActionFlags,
                                      const AudioTimeStamp *inTimeStamp,
                                      UInt32 inBusNumber,
                                      UInt32 inNumberFrames,
                                      AudioBufferList *ioData);
 
-class AVFTapContext {
-public:
-    AVFTapContext(AVFSoundLevelUnitPtr slu, AVFAudioSpectrumUnitPtr spectrum, AVFAudioEqualizerPtr eq) :
-        audioSLU(slu),
-        audioSpectrum(spectrum),
-        audioEQ(eq)
-    {
-    }
-
-    ~AVFTapContext() {
-        // AudioUnits have already been deallocated by now
-        // shared_ptrs get freed automatically
-    }
-
-    AudioUnit spectrumUnit;
-    AudioUnit volumeUnit;
-    AudioUnit eqUnit;
-
-    AudioUnit renderUnit; // the last unit in our chain
-    CMItemCount totalFrames;
-    
-    // Hold on to these while we're running
-    AVFSoundLevelUnitPtr audioSLU;
-    AVFAudioSpectrumUnitPtr audioSpectrum;
-    AVFAudioEqualizerPtr audioEQ;
-};
-
 @implementation AVFAudioProcessor
 
 - (id) init {
     if ((self = [super init]) != nil) {
         _soundLevelUnit = AVFSoundLevelUnitPtr(new AVFSoundLevelUnit());
@@ -94,55 +65,54 @@
         _audioDelay = 0LL;
     }
     return self;
 }
 
-- (void) dealloc {
+-(void) dealloc {
     _soundLevelUnit = nullptr;
     _audioSpectrum = nullptr;
     _audioEqualizer = nullptr;
 }
 
-- (void) setAudioTrack:(AVAssetTrack *)track {
+-(void) setAudioTrack : (AVAssetTrack *) track {
     if (track != _audioTrack) {
         // reset the audio mixer if it's already been created
         // this theoretically should never happen...
         _mixer = nil;
     }
     _audioTrack = track;
 }
 
-- (AVAudioMix*) mixer {
+-(AVAudioMix*) mixer {
     if (!self.audioTrack) {
         return nil;
     }
 
     if (!_mixer) {
         AVMutableAudioMix *mixer = [AVMutableAudioMix audioMix];
         if (mixer) {
             AVMutableAudioMixInputParameters *audioMixInputParameters =
-                [AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:self.audioTrack];
+                    [AVMutableAudioMixInputParameters audioMixInputParametersWithTrack : self.audioTrack];
             if (audioMixInputParameters &&
-                [audioMixInputParameters respondsToSelector:@selector(setAudioTapProcessor:)]) {
+                    [audioMixInputParameters respondsToSelector : @selector(setAudioTapProcessor :)]) {
                 MTAudioProcessingTapCallbacks callbacks;
 
                 callbacks.version = kMTAudioProcessingTapCallbacksVersion_0;
-                callbacks.clientInfo = (__bridge void *)self;
+                callbacks.clientInfo = (__bridge void *) self;
                 callbacks.init = InitAudioTap;
                 callbacks.finalize = FinalizeAudioTap;
                 callbacks.prepare = PrepareAudioTap;
                 callbacks.unprepare = UnprepareAudioTap;
                 callbacks.process = ProcessAudioTap;
 
                 MTAudioProcessingTapRef audioProcessingTap;
                 if (noErr == MTAudioProcessingTapCreate(kCFAllocatorDefault, &callbacks,
-                                             kMTAudioProcessingTapCreationFlag_PreEffects,
-                                             &audioProcessingTap))
-                {
+                        kMTAudioProcessingTapCreationFlag_PreEffects,
+                        &audioProcessingTap)) {
                     objc_msgSend(audioMixInputParameters,
-                                 @selector(setAudioTapProcessor:),
-                                 audioProcessingTap);
+                            @selector(setAudioTapProcessor :),
+                            audioProcessingTap);
 
                     CFRelease(audioProcessingTap); // owned by the mixer now
                     mixer.inputParameters = @[audioMixInputParameters];
 
                     _mixer = mixer;
@@ -151,42 +121,53 @@
         }
     }
     return _mixer;
 }
 
-- (void) setVolume:(float)volume {
+-(void) setVolume : (float) volume {
     _volume = volume;
     if (_soundLevelUnit != nullptr) {
         _soundLevelUnit->setVolume(volume);
     }
 }
 
-- (void) setBalance:(float)balance {
+-(void) setBalance : (float) balance {
     _balance = balance;
     if (_soundLevelUnit != nullptr) {
         _soundLevelUnit->setBalance(balance);
     }
 }
 
 @end
 
-void InitAudioTap(MTAudioProcessingTapRef tapRef, void *clientInfo, void **tapStorageOut)
-{
+AVFTapContext::AVFTapContext(AVFSoundLevelUnitPtr slu, AVFAudioSpectrumUnitPtr spectrum,
+                             AVFAudioEqualizerPtr eq) : audioSLU(slu),
+                                                        audioSpectrum(spectrum),
+                                                        audioEQ(eq),
+                                                        // Some reasonable defaults
+                                                        mSampleRate(48000),
+                                                        mChannels(2) {
+}
+
+AVFTapContext::~AVFTapContext() {
+    // AudioUnits have already been deallocated by now
+    // shared_ptrs get freed automatically
+}
+
+void InitAudioTap(MTAudioProcessingTapRef tapRef, void *clientInfo, void **tapStorageOut) {
     // retain the AU kernels so they don't get freed while we're running
-    AVFAudioProcessor *processor = (__bridge AVFAudioProcessor *)clientInfo;
+    AVFAudioProcessor *processor = (__bridge AVFAudioProcessor *) clientInfo;
     if (processor) {
         AVFTapContext *context = new AVFTapContext(processor.soundLevelUnit,
-                                                   processor.audioSpectrum,
-                                                   processor.audioEqualizer);
+                processor.audioSpectrum,
+                processor.audioEqualizer);
         *tapStorageOut = context;
     }
 }
 
-void FinalizeAudioTap(MTAudioProcessingTapRef tapRef)
-{
-    AVFTapContext *context = (AVFTapContext*)MTAudioProcessingTapGetStorage(tapRef);
-
+void FinalizeAudioTap(MTAudioProcessingTapRef tapRef) {
+    AVFTapContext *context = (AVFTapContext*) MTAudioProcessingTapGetStorage(tapRef);
     if (context) {
         delete context;
     }
 }
 
@@ -216,222 +197,88 @@
         status = AudioUnitInitialize(unit);
     }
     return status;
 }
 
-static OSStatus ConnectAudioUnits(AudioUnit source, AudioUnit sink) {
-    AudioUnitConnection connection;
-    connection.sourceAudioUnit = source;
-    connection.sourceOutputNumber = 0;
-    connection.destInputNumber = 0;
-    return AudioUnitSetProperty(sink, kAudioUnitProperty_MakeConnection,
-                                kAudioUnitScope_Input, 0,
-                                &connection, sizeof(connection));
-}
-
-AudioUnit FindAudioUnit(OSType type, OSType subType, OSType manu) {
-    AudioUnit audioUnit = NULL;
-
-    AudioComponentDescription audioComponentDescription;
-    audioComponentDescription.componentType = type;
-    audioComponentDescription.componentSubType = subType;
-    audioComponentDescription.componentManufacturer = manu;
-    audioComponentDescription.componentFlags = 0;
-    audioComponentDescription.componentFlagsMask = 0;
-
-    AudioComponent audioComponent = AudioComponentFindNext(NULL, &audioComponentDescription);
-    if (audioComponent) {
-        AudioComponentInstanceNew(audioComponent, &audioUnit);
-    }
-    return audioUnit;
-}
-
 void PrepareAudioTap(MTAudioProcessingTapRef tapRef,
-                     CMItemCount maxFrames,
-                     const AudioStreamBasicDescription *processingFormat)
-{
-    AVFTapContext *context = (AVFTapContext*)MTAudioProcessingTapGetStorage(tapRef);
+        CMItemCount maxFrames,
+        const AudioStreamBasicDescription *processingFormat) {
+    AVFTapContext *context = (AVFTapContext*) MTAudioProcessingTapGetStorage(tapRef);
 
     // Validate the audio format before we enable the processor
-
     // Failures here should rarely, if ever, happen so leave the NSLogs in for
     // easier diagnosis in the field
     if (processingFormat->mFormatID != kAudioFormatLinearPCM) {
         NSLog(@"AVFAudioProcessor needs linear PCM");
         return;
     }
 
     // Use the convenient kAudioFormatFlagsNativeFloatPacked to check if we can
     // process the incoming audio
     if ((processingFormat->mFormatFlags & kAudioFormatFlagsNativeFloatPacked)
-        != kAudioFormatFlagsNativeFloatPacked) {
+            != kAudioFormatFlagsNativeFloatPacked) {
         NSLog(@"AVFAudioProcessor needs native endian packed float samples!!");
         return;
     }
 
-    // Get an instance of our sound level unit
-    context->eqUnit = NULL;
+    context->mSampleRate = processingFormat->mSampleRate;
+    context->mChannels = processingFormat->mChannelsPerFrame;
+    context->mMaxFrames = maxFrames;
+
+    // Configure audio equalizer
     if (context->audioEQ != nullptr) {
-        context->eqUnit = NewKernelProcessorUnit(static_pointer_cast<AVFKernelProcessor>(context->audioEQ));
-        if (context->eqUnit) {
-            OSStatus status = SetupAudioUnit(context->eqUnit,
-                                             processingFormat,
-                                             (UInt32)maxFrames);
-            if (noErr != status) {
-                NSLog(@"Error creating audio equalizer unit: %d", status);
-                AudioComponentInstanceDispose(context->eqUnit);
-                context->eqUnit = NULL;
-            }
-        }
+        context->audioEQ.get()->SetSampleRate(context->mSampleRate);
+        context->audioEQ.get()->SetChannels(context->mChannels);
+        context->audioEQ.get()->ResetBandParameters();
     }
 
-    context->spectrumUnit = NULL;
+    // Configure spectrum
     if (context->audioSpectrum != nullptr) {
-        context->spectrumUnit = NewKernelProcessorUnit(static_pointer_cast<AVFKernelProcessor>(context->audioSpectrum));
-        if (context->spectrumUnit) {
-            OSStatus status = SetupAudioUnit(context->spectrumUnit,
-                                             processingFormat,
-                                             (UInt32)maxFrames);
-            if (noErr != status) {
-                NSLog(@"Error creating audio spectrum unit: %d", status);
-                AudioComponentInstanceDispose(context->spectrumUnit);
-                context->spectrumUnit = NULL;
-            }
-        }
+        context->audioSpectrum.get()->SetSampleRate(context->mSampleRate);
+        context->audioSpectrum.get()->SetChannels(context->mChannels);
+        context->audioSpectrum.get()->SetMaxFrames(context->mMaxFrames);
     }
 
-    context->volumeUnit = NULL;
     if (context->audioSLU != nullptr) {
-        context->volumeUnit = NewKernelProcessorUnit(static_pointer_cast<AVFKernelProcessor>(context->audioSLU));
-        if (context->volumeUnit) {
-            OSStatus status = SetupAudioUnit(context->volumeUnit,
-                                             processingFormat,
-                                             (UInt32)maxFrames);
-            if (noErr != status) {
-                NSLog(@"Error setting up Sound Level Unit: %d", status);
-                AudioComponentInstanceDispose(context->volumeUnit);
-                context->volumeUnit = NULL;
-            }
-        }
-    }
-
-    /*
-     * Use AudioUnitConnections to build a processing graph
-     * The last unit in the chain will be the unit we call to render, it will
-     * pull through the graph until we get to the first, which will fetch samples
-     * via the render proc we install.
-     *
-     * The graph will look like this:
-     *    (render proc) -> eqUnit -> spectrumUnit -> volUnit
-     *
-     * This will allow the EQ settings to affect the spectrum output, but not
-     * the volume or balance.
-     */
-    AudioUnit firstUnit = NULL;
-    context->renderUnit = NULL;
-
-    // Set initial settings
-    if (context->eqUnit) {
-        if (context->renderUnit) {
-            ConnectAudioUnits(context->renderUnit, context->eqUnit);
-        }
-        context->renderUnit = context->eqUnit;
-        if (!firstUnit) {
-            firstUnit = context->eqUnit;
-        }
+        context->audioSLU.get()->SetChannels(context->mChannels);
     }
-    if (context->spectrumUnit) {
-        if (context->renderUnit) {
-            ConnectAudioUnits(context->renderUnit, context->spectrumUnit);
-        }
-        context->renderUnit = context->spectrumUnit;
-        if (!firstUnit) {
-            firstUnit = context->spectrumUnit;
-        }
-    }
-    if (context->volumeUnit) {
-        if (context->renderUnit) {
-            ConnectAudioUnits(context->renderUnit, context->volumeUnit);
-        }
-        context->renderUnit = context->volumeUnit;
-        if (!firstUnit) {
-            firstUnit = context->volumeUnit;
-        }
-    }
-
-    // Set up a render callback on our first unit
-    if (firstUnit) {
-        AURenderCallbackStruct renderCB;
-        renderCB.inputProc = (AURenderCallback)AVFTapRenderCallback;
-        renderCB.inputProcRefCon = (void*)tapRef;
-        AudioUnitSetProperty(firstUnit,
-                             kAudioUnitProperty_SetRenderCallback,
-                             kAudioUnitScope_Input, 0,
-                             &renderCB, sizeof(renderCB));
-    }
-    context->totalFrames = 0;
 }
 
-void UnprepareAudioTap(MTAudioProcessingTapRef tapRef)
-{
-    AVFTapContext *context = (AVFTapContext*)MTAudioProcessingTapGetStorage(tapRef);
-    context->renderUnit = NULL;
-
-    if (context->spectrumUnit) {
-        AudioUnitUninitialize(context->spectrumUnit);
-        AudioComponentInstanceDispose(context->spectrumUnit);
-        context->spectrumUnit = NULL;
-    }
-    if (context->volumeUnit) {
-        AudioUnitUninitialize(context->volumeUnit);
-        AudioComponentInstanceDispose(context->volumeUnit);
-        context->volumeUnit = NULL;
-    }
-    if (context->eqUnit) {
-        AudioUnitUninitialize(context->eqUnit);
-        AudioComponentInstanceDispose(context->eqUnit);
-        context->eqUnit = NULL;
-    }
+void UnprepareAudioTap(MTAudioProcessingTapRef tapRef) {
+    // We do not need it anymore
 }
 
 void ProcessAudioTap(MTAudioProcessingTapRef tapRef,
-                     CMItemCount numberFrames,
-                     uint32_t flags,
-                     AudioBufferList *bufferListInOut,
-                     CMItemCount *numberFramesOut,
-                     uint32_t *flagsOut)
-{
-    AVFTapContext *context = (AVFTapContext*)MTAudioProcessingTapGetStorage(tapRef);
-    OSStatus status = noErr;
+        CMItemCount numberFrames,
+        uint32_t flags,
+        AudioBufferList *bufferListInOut,
+        CMItemCount *numberFramesOut,
+        uint32_t *flagsOut) {
+    AVFTapContext *context = (AVFTapContext*) MTAudioProcessingTapGetStorage(tapRef);
+    OSStatus status = MTAudioProcessingTapGetSourceAudio(tapRef, numberFrames, bufferListInOut,
+            flagsOut, NULL, numberFramesOut);
+    if (status != noErr) {
+        NSLog(@"MTAudioProcessingTapGetSourceAudio failed: %d", status);
+        return;
+    }
 
-    if (context->renderUnit) {
-        AudioTimeStamp audioTimeStamp;
-        audioTimeStamp.mSampleTime = context->totalFrames;
-        audioTimeStamp.mFlags = kAudioTimeStampSampleTimeValid;
-
-        status = AudioUnitRender(context->renderUnit,
-                                 0,
-                                 &audioTimeStamp,
-                                 0,
-                                 (UInt32)numberFrames,
-                                 bufferListInOut);
-        if (noErr != status) {
+    if (context->audioEQ != nullptr) {
+        if (!context->audioEQ.get()->ProcessBufferLists(*bufferListInOut, numberFrames)) {
+            NSLog(@"audioEQ ProcessBufferLists() failed");
             return;
         }
-        context->totalFrames += numberFrames;
-        *numberFramesOut = numberFrames;
-    } else {
-        MTAudioProcessingTapGetSourceAudio(tapRef, numberFrames, bufferListInOut,
-                                flagsOut, NULL, numberFramesOut);
     }
-}
 
-static OSStatus AVFTapRenderCallback(void *inRefCon,
-                                     AudioUnitRenderActionFlags *ioActionFlags,
-                                     const AudioTimeStamp *inTimeStamp,
-                                     UInt32 inBusNumber,
-                                     UInt32 inNumberFrames,
-                                     AudioBufferList *ioData)
-{
-    MTAudioProcessingTapRef tapRef = static_cast<MTAudioProcessingTapRef>(inRefCon);
-    return MTAudioProcessingTapGetSourceAudio(tapRef, inNumberFrames, ioData, NULL, NULL, NULL);
+    if (context->audioSpectrum != nullptr) {
+        if (!context->audioSpectrum.get()->ProcessBufferLists(*bufferListInOut, numberFrames)) {
+            NSLog(@"audioSpectrum ProcessBufferLists() failed");
+            return;
+        }
+    }
+
+    if (context->audioSLU != nullptr) {
+        if (!context->audioSLU.get()->ProcessBufferLists(*bufferListInOut, numberFrames)) {
+            NSLog(@"audioSLU ProcessBufferLists() failed");
+            return;
+        }
+    }
 }
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioSpectrumUnit.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioSpectrumUnit.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioSpectrumUnit.cpp
+++ b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioSpectrumUnit.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -22,119 +22,109 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 #include "AVFAudioSpectrumUnit.h"
-#include "AUEffectBase.h"
 
 #include <iostream>
 #include <Accelerate/Accelerate.h>
 
-// Determines the amount of overlap when running FFT operations
-// More oversampling produces smoother results, at the cost of CPU time
-// This doesn't have much effect until you get to high bin counts, with JavaFX
-// running 128 as the default, there doesn't seem to be much gain to doing
-// more than 2x
-// NOTE: this should be a user configurable option...
-#define kSpectrumOversampleFactor 2
-
-AVFAudioSpectrumUnit::AVFAudioSpectrumUnit() :
-    AVFKernelProcessor(),
-    mSpectrumCallbackProc(NULL),
-    mSpectrumCallbackContext(NULL),
-
-    mEnabled(true),
-
-    mBandCount(128),
-    mBands(NULL),
-    mUpdateInterval(kDefaultAudioSpectrumUpdateInterval),
-    mThreshold(kDefaultAudioSpectrumThreshold),
-    mProcessor(NULL),
-
-    mMixBufferFrameCapacity(0),
-
-    mSamplesPerInterval(0),
-    mFFTSize(0),
-    mFFTsPerInterval(0),
-    mFFTCount(0),
-    mWorkBuffer(),
-    mMagnitudes(),
-    mPhases(),
-
-    mRebuildCrunch(true),
-    mSpectralCrunch(NULL)
-{
+AVFAudioSpectrumUnit::AVFAudioSpectrumUnit() : mSpectrumCallbackProc(NULL),
+                                               mSpectrumCallbackContext(NULL),
+                                               mEnabled(true),
+                                               mBandCount(128),
+                                               mBands(NULL),
+                                               mUpdateInterval(kDefaultAudioSpectrumUpdateInterval),
+                                               mThreshold(kDefaultAudioSpectrumThreshold),
+                                               mMixBufferFrameCapacity(0),
+                                               mSampleRate(0),
+                                               mChannels(0),
+                                               mMaxFrames(0),
+                                               mSamplesPerInterval(0),
+                                               mRebuildCrunch(true),
+                                               mSpectrumElement(NULL),
+                                               mSpectrum(NULL) {
     mMixBuffer.mNumberBuffers = 1;
     mMixBuffer.mBuffers[0].mData = NULL;
 
     pthread_mutex_init(&mBandLock, NULL);
+
+    gst_init_check(NULL, NULL, NULL);
 }
 
 AVFAudioSpectrumUnit::~AVFAudioSpectrumUnit() {
     if (mMixBuffer.mBuffers[0].mData) {
         free(mMixBuffer.mBuffers[0].mData);
         mMixBuffer.mBuffers[0].mData = NULL;
     }
-    if (mSpectralCrunch) {
-        delete mSpectralCrunch;
-        mSpectralCrunch = NULL;
-    }
-    mWorkBuffer.free();
-    mMagnitudes.free();
-    mPhases.free();
+
+    ReleaseSpectralProcessor();
 }
 
-OSStatus AVFAudioSpectrumUnit::ProcessBufferLists(AudioUnitRenderActionFlags& ioActionFlags,
-                                                  const AudioBufferList& inBuffer,
-                                                  AudioBufferList& outBuffer,
-                                                  UInt32 inFramesToProcess)
-{
+bool AVFAudioSpectrumUnit::ProcessBufferLists(const AudioBufferList& inBuffer,
+                                                  UInt32 inFramesToProcess) {
     if (!mEnabled) {
-        return noErr;
+        return true;
     }
+
     // (Re)allocate mix buffer if needed
     if (!mMixBuffer.mBuffers[0].mData || mMixBufferFrameCapacity < inFramesToProcess) {
         // allocate buffer list (only need to do this once)
         if (mMixBuffer.mBuffers[0].mData) {
             free(mMixBuffer.mBuffers[0].mData);
             mMixBuffer.mBuffers[0].mData = NULL;
         }
 
-        mMixBufferFrameCapacity = mAudioUnit->GetMaxFramesPerSlice();
+        mMixBufferFrameCapacity = mMaxFrames;
 
         mMixBuffer.mBuffers[0].mNumberChannels = 1;
-        mMixBuffer.mBuffers[0].mData = calloc(mMixBufferFrameCapacity, sizeof(Float32));
+        mMixBuffer.mBuffers[0].mData = calloc(mMixBufferFrameCapacity, sizeof (Float32));
         mMixBuffer.mBuffers[0].mDataByteSize = 0; // size of actual contained data, not size of buffer
     }
 
     if (mRebuildCrunch) {
         SetupSpectralProcessor();
     }
-    if (mSpectralCrunch) {
+
+    if (mSpectrum != NULL) {
         // Mix the audio into one channel since JavaFX only supports single channel spectrum
         // Just use an arithmetic average, nothing fancy here
-        float *buffer = (float*)mMixBuffer.mBuffers[0].mData;
+        float *buffer = (float*) mMixBuffer.mBuffers[0].mData;
         vDSP_vclr(buffer, 1, mMixBufferFrameCapacity);
         for (int ii = 0; ii < inBuffer.mNumberBuffers; ii++) {
-            vDSP_vadd((float*)inBuffer.mBuffers[ii].mData, 1,
-                      buffer, 1,
-                      buffer, 1, inFramesToProcess);
+            vDSP_vadd((float*) inBuffer.mBuffers[ii].mData, 1,
+                    buffer, 1,
+                    buffer, 1, inFramesToProcess);
         }
-        float divisor = (float)inBuffer.mNumberBuffers;
+        float divisor = (float) inBuffer.mNumberBuffers;
         vDSP_vsdiv(buffer, 1,
-                   &divisor,
-                   buffer, 1, inFramesToProcess);
-        mMixBuffer.mBuffers[0].mDataByteSize = inFramesToProcess * sizeof(Float32);
+                &divisor,
+                buffer, 1, inFramesToProcess);
+        mMixBuffer.mBuffers[0].mDataByteSize = inFramesToProcess * sizeof (Float32);
+
+        // Just reuse already allocated memory from mMixBuffer and do not free it
+        // in GStreamer
+        GstBuffer *gstBuffer =
+                gst_buffer_new_wrapped_full(GST_MEMORY_FLAG_READONLY, // Allow only reading
+                mMixBuffer.mBuffers[0].mData,
+                mMixBuffer.mBuffers[0].mDataByteSize,
+                0,
+                mMixBuffer.mBuffers[0].mDataByteSize,
+                NULL,
+                NULL); // No need to free memory
+        if (gstBuffer == NULL) {
+            return false;
+        }
 
-        mSpectralCrunch->ProcessForwards(inFramesToProcess, &mMixBuffer);
+        GstFlowReturn result = gst_spectrum_transform_ip_api((GstBaseTransform *) mSpectrum, gstBuffer);
+        if (result != GST_FLOW_OK) {
+            return false;
+        }
+        gst_buffer_unref(gstBuffer);
     }
-    return noErr;
-}
 
-void AVFAudioSpectrumUnit::StreamFormatChanged(const CAStreamBasicDescription &newFormat) {
-    // just trigger rebuilding the spectrum based on an updated format
-    mRebuildCrunch = true;
+    return true;
 }
 
 bool AVFAudioSpectrumUnit::IsEnabled() {
     return mEnabled;
 }
@@ -175,144 +165,158 @@
         mRebuildCrunch = true;
     }
 }
 
 int AVFAudioSpectrumUnit::GetThreshold() {
-    return (int)mThreshold;
+    return (int) mThreshold;
 }
 
 void AVFAudioSpectrumUnit::SetThreshold(int threshold) {
-    if (mThreshold != (Float32)threshold) {
-        mThreshold = (Float32)threshold;
+    if (mThreshold != (Float32) threshold) {
+        mThreshold = (Float32) threshold;
+        mRebuildCrunch = true;
     }
 }
 
 void AVFAudioSpectrumUnit::UpdateBands(int size, const float* magnitudes, const float* phases) {
-}
-
-void AVFAudioSpectrumUnit::Reset() {
-    mRebuildCrunch = true;
-}
-
-static void AVFAudioSpectrum_SpectralFunction(SpectralBufferList* inSpectra, void* inUserData) {
-    AVFAudioSpectrumUnit *unit = static_cast<AVFAudioSpectrumUnit*>(inUserData);
-    if (unit && unit->IsEnabled()) {
-        unit->SpectralFunction(inSpectra);
-    }
-}
-
-void AVFAudioSpectrumUnit::SpectralFunction(SpectralBufferList* inSpectra) {
-    // https://developer.apple.com/library/mac/documentation/Performance/Conceptual/vDSP_Programming_Guide/UsingFourierTransforms/UsingFourierTransforms.html
-    // Scale the results properly, scale factor is 2x for 1D real forward transforms
-
     // lock now otherwise the bands could change while we're processing
     lockBands();
-    if (!mBands || mBandCount <= 0 || !mEnabled) {
+    if (!mBands || size <= 0 || !mEnabled) {
         unlockBands();
         return;
     }
 
-    float scale = 2.0;
-    DSPSplitComplex *cplx = inSpectra->mDSPSplitComplex;
-    vDSP_vsmul(cplx->realp, 1, &scale, cplx->realp, 1, mBandCount);
-    vDSP_vsmul(cplx->imagp, 1, &scale, cplx->imagp, 1, mBandCount);
+    // Update band data
+    mBands->UpdateBands(size, magnitudes, magnitudes);
 
-    if (mMagnitudes()) {
-        // Calculate magnitudes: (C.r^^2 + C.i^^2)
-        vDSP_zvmags(cplx, 1, mWorkBuffer, 1, mBandCount);
+    // Call our listener to dispatch the spectrum event
+    if (mSpectrumCallbackProc) {
+        double duration = (double) mSamplesPerInterval / (double) 44100;
+        mSpectrumCallbackProc(mSpectrumCallbackContext, duration);
+    }
 
-        // Convert magnitudes to dB: 10 * log10(mags[n] / nfft^^2)
-        Float32 nfft_sq = mFFTSize * mFFTSize;
-        vDSP_vdbcon(mWorkBuffer, 1, &nfft_sq, mWorkBuffer, 1, mBandCount, 0);
+    unlockBands();
+}
 
-        // Set threshold: M = (M > T) ? M : T
-        vDSP_vthr(mWorkBuffer, 1, &mThreshold, mWorkBuffer, 1, mBandCount);
+void AVFAudioSpectrumUnit::SetSampleRate(UInt32 rate) {
+    mSampleRate = rate;
+}
 
-        // Now have magnitudes in dB, just accumulate it
-        vDSP_vadd(mWorkBuffer, 1, mMagnitudes, 1, mMagnitudes, 1, mBandCount);
+void AVFAudioSpectrumUnit::SetChannels(UInt32 count) {
+    mChannels = count;
+}
+
+void AVFAudioSpectrumUnit::SetMaxFrames(UInt32 maxFrames) {
+    mMaxFrames = maxFrames;
+}
+
+void AVFAudioSpectrumUnit::SetSpectrumCallbackProc(AVFSpectrumUnitCallbackProc proc, void *context) {
+    mSpectrumCallbackProc = proc;
+    mSpectrumCallbackContext = context;
+}
+
+static gboolean PostMessageCallback(GstElement * element, GstMessage * message) {
+    if (message == NULL) {
+        return FALSE;
     }
 
-    if (mPhases()) {
-        // Just use vDSP to calculate phase directly
-        vDSP_zvphas(cplx, 1, mWorkBuffer, 1, mBandCount);
-        vDSP_vadd(mWorkBuffer, 1, mPhases, 1, mPhases, 1, mBandCount);
+    GstSpectrum *pSpectrum = GST_SPECTRUM(element);
+    if (pSpectrum == NULL || pSpectrum->user_data == NULL) {
+        return FALSE;
     }
 
-    mFFTCount++;
-    if (mFFTCount >= mFFTsPerInterval) {
-        float divisor = (float)mFFTCount;
+    AVFAudioSpectrumUnit *pSpectrumUnit = (AVFAudioSpectrumUnit*)pSpectrum->user_data;
 
-        // Get averages
-        vDSP_vsdiv(mMagnitudes, 1, &divisor, mMagnitudes, 1, mBandCount);
-        vDSP_vsdiv(mPhases, 1, &divisor, mPhases, 1, mBandCount);
+    const GstStructure *pStr = gst_message_get_structure(message);
+    if (gst_structure_has_name(pStr, "spectrum")) {
+        GstClockTime timestamp, duration;
 
-        // Update band data
-        mBands->UpdateBands(mBandCount, mMagnitudes, mPhases);
+        if (!gst_structure_get_clock_time(pStr, "timestamp", &timestamp))
+            timestamp = GST_CLOCK_TIME_NONE;
 
-        // Call our listener to dispatch the spectrum event
-        if (mSpectrumCallbackProc) {
-            double duration = (double)mSamplesPerInterval / (double)mAudioUnit->GetSampleRate();
-            mSpectrumCallbackProc(mSpectrumCallbackContext, duration);
-        }
+        if (!gst_structure_get_clock_time(pStr, "duration", &duration))
+            duration = GST_CLOCK_TIME_NONE;
 
-        // Reset things
-        vDSP_vclr(mMagnitudes, 1, mBandCount);
-        vDSP_vclr(mPhases, 1, mBandCount);
-        mFFTCount = 0;
+        size_t bandsNum = pSpectrumUnit->GetBands();
+
+        if (bandsNum > 0) {
+            float *magnitudes = new float[bandsNum];
+            float *phases = new float[bandsNum];
+
+            const GValue *magnitudes_value = gst_structure_get_value(pStr, "magnitude");
+            const GValue *phases_value = gst_structure_get_value(pStr, "phase");
+            for (int i = 0; i < bandsNum; i++) {
+                magnitudes[i] = g_value_get_float(gst_value_list_get_value(magnitudes_value, i));
+                phases[i] = g_value_get_float(gst_value_list_get_value(phases_value, i));
+            }
+            pSpectrumUnit->UpdateBands((int) bandsNum, magnitudes, phases);
+
+            delete [] magnitudes;
+            delete [] phases;
+        }
     }
-    unlockBands();
+
+    gst_message_unref(message);
+
+    return TRUE;
 }
 
 void AVFAudioSpectrumUnit::SetupSpectralProcessor() {
-    lockBands();
-
-    if (mSpectralCrunch) {
-        delete mSpectralCrunch;
-        mSpectralCrunch = NULL;
+    ReleaseSpectralProcessor();
 
-        mWorkBuffer.free();
-        mMagnitudes.free();
-        mPhases.free();
-    }
+    lockBands();
 
-    if (mEnabled && mBandCount > 0 && (mBands != NULL)) {
-        // inFFTSize = 2x number of bins (this is adjusted properly later)
-        // inHopSize = the number of samples to increment per update, depends on
-        //             how much oversampling we want
-        // inNumChannels = number of audio channels, we mix down to 1 since FX
-        //                 lamely only supports one channel spectrum output
-        // inMaxFrames = maximum number of frames we should ever process at once
-        //               this is not relevant to anything but how much memory
-        //               the analyzer allocates up front
-        mFFTSize = mBandCount * 2;
-        mSpectralCrunch = new CASpectralProcessor(mFFTSize,
-                                                  mFFTSize / kSpectrumOversampleFactor,
-                                                  1,
-                                                  mAudioUnit->GetMaxFramesPerSlice());
+    mSpectrumElement = gst_element_factory_make("spectrum", NULL);
+    mSpectrum = GST_SPECTRUM(mSpectrumElement);
+    mSpectrum->user_data = (void*)this;
 
-        // Set up a Hamming window to match GStreamer
-        vDSP_hamm_window(mSpectralCrunch->Window(), mFFTSize, vDSP_HALF_WINDOW);
+    // Set our own callback for post message
+    GstElementClass *klass;
+    klass = GST_ELEMENT_GET_CLASS(mSpectrumElement);
+    klass->post_message = PostMessageCallback;
 
-        mSpectralCrunch->SetSpectralFunction(AVFAudioSpectrum_SpectralFunction, this);
+    // Configure spectrum element
+    // Do send magnitude and phase information, off by default
+    g_object_set(mSpectrumElement, "post-messages", TRUE,
+                                   "message-magnitude", TRUE,
+                                   "message-phase", TRUE, NULL);
 
-        // Allocate mag/phase buffers and calculate FFT count per iteration
-        mWorkBuffer.alloc(mBandCount);
+    g_object_set(mSpectrumElement, "bands", mBandCount, NULL);
 
-        mMagnitudes.alloc(mBandCount);
-        vDSP_vclr(mMagnitudes(), 1, mBandCount);
+    mSamplesPerInterval = (UInt32)(mSampleRate * mUpdateInterval);
+    guint64 value = (guint64) (mUpdateInterval * GST_SECOND);
+    g_object_set(mSpectrumElement, "interval", value, NULL);
 
-        mPhases.alloc(mBandCount);
-        vDSP_vclr(mPhases(), 1, mBandCount);
+    g_object_set(mSpectrumElement, "threshold", (int) mThreshold, NULL);
 
-        mSamplesPerInterval = (UInt32)(mAudioUnit->GetSampleRate() * mUpdateInterval);
+    // Since we do not run spectrum element in pipeline and it will not get configured
+    // correctly, we need to set required information directly.
+    GST_AUDIO_FILTER_RATE(mSpectrum) = mSampleRate;
+    GST_AUDIO_FILTER_CHANNELS(mSpectrum) = 1; // Always 1 channel
 
-        // Clamp FFTs per interval to an integral number
-        mFFTCount = 0;
-        mFFTsPerInterval = mSamplesPerInterval / mFFTSize * kSpectrumOversampleFactor;
+    // gst_spectrum_setup()
+    GstAudioInfo *info = gst_audio_info_new();
+    gst_audio_info_init(info);
+    gst_audio_info_set_format(info, GST_AUDIO_FORMAT_F32, mSampleRate, 1, NULL);
+    // bps = 4 bytes - 32-bit float, bpf = 4 bytes - 32-bit float mono
+    gst_spectrum_setup_api((GstAudioFilter*) mSpectrum, info, 4, 4);
+    gst_audio_info_free(info);
 
-        // Recalculate mSamplesPerInterval so we report duration correctly
-        mSamplesPerInterval = mFFTsPerInterval / kSpectrumOversampleFactor * mFFTSize;
-    } // else leave disabled
+    // Set element to playing state
+    gst_element_set_state(mSpectrumElement, GST_STATE_PLAYING);
 
     mRebuildCrunch = false;
     unlockBands();
 }
+
+void AVFAudioSpectrumUnit::ReleaseSpectralProcessor() {
+    lockBands();
+
+    if (mSpectrumElement) {
+        gst_element_set_state(mSpectrumElement, GST_STATE_NULL);
+        gst_object_unref(GST_OBJECT(mSpectrumElement));
+        mSpectrumElement = NULL;
+        mSpectrum = NULL;
+    }
+
+    unlockBands();
+}
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioSpectrumUnit.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioSpectrumUnit.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioSpectrumUnit.h
+++ b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFAudioSpectrumUnit.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,15 +30,13 @@
 
 #include <pthread.h>
 #include <memory>
 
 #include "PipelineManagement/AudioSpectrum.h"
-#include "AVFKernelProcessor.h"
-#include "CASpectralProcessor.h"
-#include "CAStreamBasicDescription.h"
-#include "CAAutoDisposer.h"
 
+#include <gst/gst.h>
+#include <gstspectrum.h>
 
 // Defaults, these match the current defaults in JavaFX which get set anyways
 // but we can optimize things a bit here...
 #define kDefaultAudioSpectrumUpdateInterval 0.1 // every 1/10 second
 #define kDefaultAudioSpectrumThreshold -60.0    // -60 dB
@@ -51,23 +49,19 @@
  * timeStamp: the beginning time in seconds of the sample period (from beginning of stream)
  * duration: the length of time in seconds of the sample period
  */
 typedef void (*AVFSpectrumUnitCallbackProc)(void *callbackContext, double duration);
 
-class AVFAudioSpectrumUnit : public AVFKernelProcessor, public CAudioSpectrum {
+class AVFAudioSpectrumUnit : public CAudioSpectrum {
 public:
     AVFAudioSpectrumUnit();
     virtual ~AVFAudioSpectrumUnit();
 
     // We'll use ProcessBufferLists as it sends all channels at once instead
     // of individual channels
-    virtual OSStatus ProcessBufferLists(AudioUnitRenderActionFlags& ioActionFlags,
-                                        const AudioBufferList& inBuffer,
-                                        AudioBufferList& outBuffer,
-                                        UInt32 inFramesToProcess);
-
-    virtual void StreamFormatChanged(const CAStreamBasicDescription &newFormat);
+    bool ProcessBufferLists(const AudioBufferList& inBuffer,
+                            UInt32 inFramesToProcess);
 
     // Parameter accessors
     virtual bool IsEnabled();
     virtual void SetEnabled(bool isEnabled);
 
@@ -80,21 +74,14 @@
     virtual int GetThreshold();
     virtual void SetThreshold(int threshold);
 
     virtual void UpdateBands(int size, const float* magnitudes, const float* phases);
 
-    void Reset();
-    void SetSampleRate(Float32 rate);
-    void SetChannelCount(int count);
-
-    void SetSpectrumCallbackProc(AVFSpectrumUnitCallbackProc proc, void *context) {
-        mSpectrumCallbackProc = proc;
-        mSpectrumCallbackContext = context;
-    }
-
-    // Called by the spectrum processor, do not call
-    void SpectralFunction(SpectralBufferList* inSpectra);
+    void SetSampleRate(UInt32 rate);
+    void SetChannels(UInt32 count);
+    void SetMaxFrames(UInt32 maxFrames);
+    void SetSpectrumCallbackProc(AVFSpectrumUnitCallbackProc proc, void *context);
 
 private:
     AVFSpectrumUnitCallbackProc mSpectrumCallbackProc;
     void *mSpectrumCallbackContext;
     bool mEnabled;
@@ -102,37 +89,36 @@
     pthread_mutex_t mBandLock;      // prevent bands from disappearing while we're processing
     int mBandCount;
     CBandsHolder *mBands;
     double mUpdateInterval;
     Float32 mThreshold;
-    CASpectralProcessor *mProcessor;
 
     AudioBufferList mMixBuffer;
     int mMixBufferFrameCapacity;    // number of frames that can currently be stored in mix buffer
 
+    // Audio parameters
+    UInt32 mSampleRate;
+    UInt32 mChannels;
+    UInt32 mMaxFrames;
     UInt32 mSamplesPerInterval;
-    UInt32 mFFTSize;                // number of samples per FFT
-    UInt32 mFFTsPerInterval;        // integral number of FFTs per update interval
-    UInt32 mFFTCount;               // number of FFTs performed since last update
-
-    CAAutoFree<Float32> mWorkBuffer; // temp vectors for calculations
-    CAAutoFree<Float32> mMagnitudes; // magnitude accumulator
-    CAAutoFree<Float32> mPhases;     // phase accumulator
-
 
     bool mRebuildCrunch;
-    CASpectralProcessor *mSpectralCrunch;
+
+    // GStreamer
+    GstElement *mSpectrumElement;
+    GstSpectrum *mSpectrum;
 
     void lockBands() {
         pthread_mutex_lock(&mBandLock);
     }
 
     void unlockBands() {
         pthread_mutex_unlock(&mBandLock);
     }
 
     void SetupSpectralProcessor();
+    void ReleaseSpectralProcessor();
 };
 
 typedef std::shared_ptr<AVFAudioSpectrumUnit> AVFAudioSpectrumUnitPtr;
 
 #endif /* defined(__JFXMedia__AVFAudioSpectrumUnit__) */
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFKernelProcessor.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFKernelProcessor.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFKernelProcessor.cpp
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include "AVFKernelProcessor.h"
-
-#include <pthread.h>
-
-// Apple reserves 0-1024 for their own properties
-#define kAVFProperty_KernelProcessor 2099
-
-class AVFKernelComponent : AUEffectBase {
-public:
-    AVFKernelComponent(AudioComponentInstance audioUnit, bool inProcessesInPlace = true)
-        : AUEffectBase(audioUnit, inProcessesInPlace),
-        mUsesKernel(false),
-        mProcessor(nullptr)
-    {}
-
-    virtual ~AVFKernelComponent() {
-        mProcessor = nullptr;
-    }
-
-    virtual AUKernelBase *NewKernel() {
-        if (mProcessor != nullptr) {
-            AUKernelBase *kernel = mProcessor->NewKernel();
-            mUsesKernel = (kernel != NULL);
-            return kernel;
-        }
-        mUsesKernel = false;
-        return NULL;
-    }
-
-    virtual OSStatus ChangeStreamFormat(AudioUnitScope inScope,
-                                        AudioUnitElement inElement,
-                                        const CAStreamBasicDescription &inPrevFormat,
-                                        const CAStreamBasicDescription &inNewFormat) {
-        OSStatus status = this->AUEffectBase::ChangeStreamFormat(inScope,
-                                                                 inElement,
-                                                                 inPrevFormat,
-                                                                 inNewFormat);
-        if (mProcessor != nullptr && inScope == kAudioUnitScope_Input && inElement == 0) {
-            mProcessor->StreamFormatChanged(inNewFormat);
-        }
-        return status;
-    }
-
-    virtual OSStatus ProcessBufferLists(AudioUnitRenderActionFlags& ioActionFlags,
-                                        const AudioBufferList& inBuffer,
-                                        AudioBufferList& outBuffer,
-                                        UInt32 inFramesToProcess) {
-        // Call our base class if we have kernels
-        if (mUsesKernel) {
-            return this->AUEffectBase::ProcessBufferLists(ioActionFlags,
-                                                          inBuffer,
-                                                          outBuffer,
-                                                          inFramesToProcess);
-        }
-        // Otherwise call ProcessBufferLists
-        if (mProcessor != nullptr) {
-            return mProcessor->ProcessBufferLists(ioActionFlags,
-                                                  inBuffer,
-                                                  outBuffer,
-                                                  inFramesToProcess);
-        }
-        return noErr; // ??? just in case
-    }
-
-    virtual OSStatus SetProperty(AudioUnitPropertyID inID,
-                                 AudioUnitScope inScope,
-                                 AudioUnitElement inElement,
-                                 const void *inData,
-                                 UInt32 inDataSize) {
-        if (inID == kAVFProperty_KernelProcessor &&
-            inScope == kAudioUnitScope_Global &&
-            inElement == 0) {
-            if (inDataSize == sizeof(AVFKernelProcessor*)) {
-                AVFKernelProcessorPtr processor = *((AVFKernelProcessorPtr*)inData);
-                // this compares the raw pointers, not the shared_ptr itself
-                if (mProcessor != processor) {
-                    if (mProcessor != nullptr) {
-                        mProcessor->SetAudioUnit(NULL);
-                        mProcessor = nullptr;
-                    }
-
-                    mProcessor = processor;
-                    if (mProcessor != nullptr) {
-                        mProcessor->SetAudioUnit(this);
-                        const AudioStreamBasicDescription& format =
-                                GetStreamFormat(kAudioUnitScope_Input, 0);
-                        mProcessor->StreamFormatChanged(format);
-                    }
-                }
-                return noErr;
-            }
-            return kAudioUnitErr_InvalidPropertyValue;
-        }
-        return this->AUEffectBase::SetProperty(inID, inScope, inElement, inData, inDataSize);
-    }
-private:
-    bool mUsesKernel;
-    AVFKernelProcessorPtr mProcessor;
-};
-
-// Synchronize registration of the component
-volatile AudioComponent gAVFComponent = NULL;
-pthread_mutex_t gAVFComponentLock = PTHREAD_MUTEX_INITIALIZER;
-
-static inline AudioComponent GetAVFComponent() {
-    AudioComponent component = NULL;
-    pthread_mutex_lock(&gAVFComponentLock);
-
-    if (!gAVFComponent) {
-        gAVFComponent = AUBaseFactory<AVFKernelComponent>::Register(kAudioUnitType_Effect,
-                                                                    'Krnl',
-                                                                    'JAVA',
-                                                                    CFSTR("JavaFX Kernel Processor"),
-                                                                    0x00010000);
-    }
-    component = gAVFComponent;
-
-    pthread_mutex_unlock(&gAVFComponentLock);
-    return component;
-}
-
-
-AudioUnit NewKernelProcessorUnit(AVFKernelProcessorPtr kernel) {
-    OSStatus status = noErr;
-    AudioUnit unit = NULL;
-    AudioComponent ac = GetAVFComponent();
-
-    if (!ac) {
-        return NULL;
-    }
-
-    status = AudioComponentInstanceNew(ac, &unit);
-    if (noErr == status) {
-        status = AudioUnitSetProperty(unit,
-                                      kAVFProperty_KernelProcessor,
-                                      kAudioUnitScope_Global,
-                                      0,
-                                      &kernel,
-                                      sizeof(AVFKernelProcessorPtr*));
-    }
-
-    if (noErr != status) {
-        if (unit) {
-            AudioComponentInstanceDispose(unit);
-        }
-    }
-    return unit;
-}
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFKernelProcessor.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFKernelProcessor.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFKernelProcessor.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef __JFXMedia__AVFKernelProcessor__
-#define __JFXMedia__AVFKernelProcessor__
-
-#include <memory>
-
-#include "AUEffectBase.h"
-
-
-/*
- * Instead of writing N components that all basically function the same (at the
- * component level), we'll skip the complexity and just write one component that
- * handles everything by use of a abstract base class.
- */
-
-/*
- * Abstract base class used by the common AudioUnit to manage kernels. All
- * processing states must be managed in this class, rather than using properties
- * or parameters of the AudioUnit (since this is all private and in-process)
- */
-class AVFKernelProcessor {
-public:
-    AVFKernelProcessor() :
-        mAudioUnit(NULL)
-    {}
-
-    virtual ~AVFKernelProcessor() {}
-
-    // This is used internally, do not call directly
-    virtual void SetAudioUnit(AUEffectBase *audioUnit) {
-        mAudioUnit = audioUnit;
-    }
-
-    virtual void Reset() {}
-
-    /*
-     * Create a new processing kernel. This is called by the AudioUnit to create
-     * a kernel that will be called to process audio data. The audioUnit parameter
-     * is supplied by the component, generally you do not have to do anything with
-     * it, but it's needed for the AUKernelBase class.
-     */
-    virtual AUKernelBase *NewKernel() {
-        return NULL;
-    }
-
-    virtual OSStatus ProcessBufferLists(AudioUnitRenderActionFlags& ioActionFlags,
-                                        const AudioBufferList& inBuffer,
-                                        AudioBufferList& outBuffer,
-                                        UInt32 inFramesToProcess) {
-        return noErr;
-    }
-
-
-    virtual void StreamFormatChanged(const CAStreamBasicDescription &newFormat) {}
-
-protected:
-    AUEffectBase *mAudioUnit;
-};
-
-/*
- * Shared pointer that handles deleting the kernel when it's no longer in use.
- * Please use this instead of raw pointers.
- */
-
-typedef std::shared_ptr<AVFKernelProcessor> AVFKernelProcessorPtr;
-
-/*
- * Returns an instance of our common AudioUnit set up to use the given kernel.
- * Use static_pointer_cast<AVFKernelProcessor>(kernelPtr) when passing a subclass
- */
-AudioUnit NewKernelProcessorUnit(AVFKernelProcessorPtr kernel);
-
-#endif /* defined(__JFXMedia__AVFKernelProcessor__) */
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFSoundLevelUnit.cpp b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFSoundLevelUnit.cpp
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFSoundLevelUnit.cpp
+++ b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFSoundLevelUnit.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,66 +24,110 @@
  */
 
 #include "AVFSoundLevelUnit.h"
 #include <Accelerate/Accelerate.h>
 
-/*
- * The object that will do the actual processing. Each kernel processes only one
- * stream.
- */
-class AVFSoundLevelKernel : public AUKernelBase {
-public:
-    AVFSoundLevelKernel(AVFSoundLevelUnit *levelUnit, AUEffectBase *inAudioUnit)
-        : AUKernelBase(dynamic_cast<AUEffectBase*>(inAudioUnit)),
-        mLevelUnit(levelUnit)
-    {}
+AVFSoundLevelUnit::AVFSoundLevelUnit() :
+    mVolume(kDefaultSoundLevelParam_Volume),
+    mBalance(kDefaultSoundLevelParam_Balance),
+    mChannels(0) {
+}
 
-    virtual ~AVFSoundLevelKernel() {}
+AVFSoundLevelUnit::~AVFSoundLevelUnit() {
+}
 
-    virtual void Process(const Float32 *inSourceP,
-                 Float32 *inDestP,
-                 UInt32 inFramesToProcess,
-                 UInt32 inNumChannels,
-                 bool& ioSilence) {
-        if (ioSilence) {
-            return;
-        }
+Float32 AVFSoundLevelUnit::volume() {
+    return mVolume;
+}
+
+void AVFSoundLevelUnit::setVolume(Float32 volume) {
+    if (volume < 0.0) {
+        volume = 0.0;
+    } else if (volume > 1.0) {
+        volume = 1.0;
+    }
+    mVolume = volume;
+}
+
+Float32 AVFSoundLevelUnit::balance() {
+    return mBalance;
+}
+
+void AVFSoundLevelUnit::setBalance(Float32 balance) {
+    if (balance < -1.0) {
+        balance = -1.0;
+    } else if (balance > 1.0) {
+        balance = 1.0;
+    }
+    mBalance = balance;
+}
+
+void AVFSoundLevelUnit::SetChannels(UInt32 count) {
+    mChannels = count;
+}
+
+// For stereo (2 channel), channel 0 is left, channel 1 is right
+Float32 AVFSoundLevelUnit::CalculateChannelLevel(int channelNum, int channelCount) {
+    Float32 volume = mVolume;
+    Float32 balance = mBalance;
+    Float32 level = volume;
 
-        Float32 level = mLevelUnit->CalculateChannelLevel(GetChannelNum(),
-                                                          mAudioUnit->GetNumberOfChannels());
-        if (level == 1.0f) {
-            // Unity volume and balance
-            // if we're processing in-place then no need to do anything
-            if (inDestP != inSourceP) {
-                // There's no vector copy for non-complex numbers, so we'll just add zero
-                // We could just do memcpy, but if the channels are interleaved we don't
-                // want to modify other channels
-                Float32 addend = 0;
-                    // float* casts are needed for Xcode 4.5
-                vDSP_vsadd((float*)inSourceP, inNumChannels,
-                           &addend,
-                           (float*)inDestP, inNumChannels,
-                           inFramesToProcess);
-            }
-        } else if (level == 0.0) {
-            ioSilence = true;
-            // Just zero out the channel
-            vDSP_vclr(inDestP, inNumChannels, inFramesToProcess);
-        } else {
-            // Just multiply vector inSourceP by scalar volume, storing in vector inDestP
-            // we only attenuate the signal, so we don't need to be concerned about clipping
-            vDSP_vsmul(inSourceP,
-                       inNumChannels,
-                       &level,
-                       inDestP,
-                       inNumChannels,
-                       inFramesToProcess);
+    if (channelCount == 2) {
+        // balance is only done on stereo audio
+        if (((balance < 0.0) && channelNum == 1) ||
+                ((balance > 0.0) && channelNum == 0)) {
+            // attenuate according to balance
+            balance = 1.0 - fabsf(balance);
+            level *= balance; // invert so it ramps the right direction
         }
     }
+    return level;
+}
+
+bool AVFSoundLevelUnit::ProcessBufferLists(const AudioBufferList & buffer,
+                                           UInt32 inFramesToProcess) {
+    for (UInt32 i = 0; i < buffer.mNumberBuffers; i++) {
+        Process((const Float32 *) buffer.mBuffers[i].mData,
+                (Float32 *) buffer.mBuffers[i].mData,
+                inFramesToProcess,
+                i,
+                buffer.mBuffers[i].mNumberChannels);
+    }
+
+    return true;
+}
 
-private:
-    AVFSoundLevelUnit *mLevelUnit;
-};
+void AVFSoundLevelUnit::Process(const Float32 *inSourceP,
+        Float32 *inDestP,
+        UInt32 inFramesToProcess,
+        UInt32 channelNum,
+        UInt32 inNumChannels) {
 
-AUKernelBase *AVFSoundLevelUnit::NewKernel() {
-    return new AVFSoundLevelKernel(this, mAudioUnit);
+    Float32 level = CalculateChannelLevel(channelNum, mChannels);
+    if (level == 1.0f) {
+        // Unity volume and balance
+        // if we're processing in-place then no need to do anything
+        if (inDestP != inSourceP) {
+            // There's no vector copy for non-complex numbers, so we'll just add zero
+            // We could just do memcpy, but if the channels are interleaved we don't
+            // want to modify other channels
+            Float32 addend = 0;
+            // float* casts are needed for Xcode 4.5
+            vDSP_vsadd((float*) inSourceP, inNumChannels,
+                    &addend,
+                    (float*) inDestP, inNumChannels,
+                    inFramesToProcess);
+        }
+    } else if (level == 0.0) {
+        // Just zero out the channel
+        vDSP_vclr(inDestP, inNumChannels, inFramesToProcess);
+    } else {
+        // Just multiply vector inSourceP by scalar volume, storing in vector inDestP
+        // we only attenuate the signal, so we don't need to be concerned about clipping
+        vDSP_vsmul(inSourceP,
+                inNumChannels,
+                &level,
+                inDestP,
+                inNumChannels,
+                inFramesToProcess);
+    }
 }
diff a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFSoundLevelUnit.h b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFSoundLevelUnit.h
--- a/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFSoundLevelUnit.h
+++ b/modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFSoundLevelUnit.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -29,76 +29,40 @@
 #include <AudioUnit/AudioUnit.h>
 #include <Accelerate/Accelerate.h>
 
 #include <memory>
 
-#include "AVFKernelProcessor.h"
-#include "AUEffectBase.h"
-
 #define kDefaultSoundLevelParam_Volume 1.0f
 #define kDefaultSoundLevelParam_Balance 0.0f
 
 /*
  * This unit applies the volume/balance controls.
  */
-class AVFSoundLevelUnit : public AVFKernelProcessor {
+class AVFSoundLevelUnit {
 public:
-    AVFSoundLevelUnit() :
-        AVFKernelProcessor(),
-        mVolume(kDefaultSoundLevelParam_Volume),
-        mBalance(kDefaultSoundLevelParam_Balance)
-    {}
-
-    virtual ~AVFSoundLevelUnit() {}
-
-    virtual AUKernelBase *NewKernel();
-
-    Float32 volume() {
-        return mVolume;
-    }
-    void setVolume(Float32 volume) {
-        if (volume < 0.0) {
-            volume = 0.0;
-        } else if (volume > 1.0) {
-            volume = 1.0;
-        }
-        mVolume = volume;
-    }
-
-    Float32 balance() {
-        return mBalance;
-    }
-    void setBalance(Float32 balance) {
-        if (balance < -1.0) {
-            balance = -1.0;
-        } else if (balance > 1.0) {
-            balance = 1.0;
-        }
-        mBalance = balance;
-    }
+    AVFSoundLevelUnit();
 
-    // For stereo (2 channel), channel 0 is left, channel 1 is right
-    Float32 CalculateChannelLevel(int channelNum, int channelCount) {
-        Float32 volume = mVolume;
-        Float32 balance = mBalance;
-        Float32 level = volume;
+    ~AVFSoundLevelUnit();
 
-        if (channelCount == 2) {
-            // balance is only done on stereo audio
-            if (((balance < 0.0) && channelNum == 1) ||
-                ((balance > 0.0) && channelNum == 0)) {
-                // attenuate according to balance
-                balance = 1.0 - fabsf(balance);
-                level *= balance; // invert so it ramps the right direction
-            }
-        }
-        return level;
-    }
+    Float32 volume();
+    void setVolume(Float32 volume);
+    Float32 balance();
+    void setBalance(Float32 balance);
+    void SetChannels(UInt32 count);
+    Float32 CalculateChannelLevel(int channelNum, int channelCount);
+    bool ProcessBufferLists(const AudioBufferList & buffer,
+                                UInt32 inFramesToProcess);
+    void Process(const Float32 *inSourceP,
+                 Float32 *inDestP,
+                 UInt32 inFramesToProcess,
+                 UInt32 channelNum,
+                 UInt32 inNumChannels);
 
 private:
     Float32 mVolume;
     Float32 mBalance;
+    UInt32 mChannels;
 };
 
 typedef std::shared_ptr<AVFSoundLevelUnit> AVFSoundLevelUnitPtr;
 
 #endif /* defined(__JFXMedia__AVFSoundLevelUnit__) */
diff a/modules/javafx.media/src/main/native/jfxmedia/projects/mac/Makefile b/modules/javafx.media/src/main/native/jfxmedia/projects/mac/Makefile
--- a/modules/javafx.media/src/main/native/jfxmedia/projects/mac/Makefile
+++ b/modules/javafx.media/src/main/native/jfxmedia/projects/mac/Makefile
@@ -181,60 +181,52 @@
               -Wl,-install_name,@rpath/$(AVF_NAME) \
               -framework AVFoundation \
               -framework CoreMedia \
               -framework Accelerate \
               -framework AudioUnit \
-              -framework MediaToolbox
+              -framework MediaToolbox \
+              -lgstreamer-lite \
+              -lglib-lite
 
 AVF_CFLAGS = $(CFLAGS) \
              -DCA_AU_USE_FAST_DISPATCH=1 \
              -DCA_BASIC_AU_FEATURES=1 \
              -DCA_NO_AU_HOST_CALLBACKS=1 \
              -DCA_NO_AU_UI_FEATURES=1 \
              -DCA_USE_AUDIO_PLUGIN_ONLY=1 \
-             -fobjc-arc
-
-# CoreAudio Utility Classes provided by Apple
-COREAUDIO_UTILITY_CLASSES = \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUBase.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUInputElement.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUOutputElement.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUPlugInDispatch.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUScopeElement.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/ComponentBase.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/OtherBases/AUEffectBase.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility/AUBuffer.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAAudioChannelLayout.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CADebugPrintf.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAHostTimeBase.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CASpectralProcessor.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAStreamBasicDescription.cpp \
-        platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAVectorUnit.cpp
-
-COREAUDIO_INCLUDES = \
-        -I$(OSX_PLATFORM_BASE)/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase \
-        -I$(OSX_PLATFORM_BASE)/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/OtherBases \
-        -I$(OSX_PLATFORM_BASE)/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/Utility \
-        -I$(OSX_PLATFORM_BASE)/CoreAudioUtilityClasses/CoreAudio/PublicUtility
+             -fobjc-arc \
+             -DGST_REMOVE_DEPRECATED   \
+             -DGST_DISABLE_GST_DEBUG   \
+             -DGST_DISABLE_LOADSAVE    \
+             -DGST_DISABLE_XML         \
+             -DG_DISABLE_DEPRECATED    \
+             -DGSTREAMER_LITE          \
+             -DOSX                     \
+             -DHAVE_CONFIG_H
 
 AVF_SOURCES = \
         platform/osx/avf/AVFMediaPlayer.mm \
         platform/osx/avf/AVFAudioProcessor.mm \
         platform/osx/avf/AVFAudioEqualizer.cpp \
         platform/osx/avf/AVFAudioSpectrumUnit.cpp \
-        platform/osx/avf/AVFSoundLevelUnit.cpp \
-        platform/osx/avf/AVFKernelProcessor.cpp \
-        $(COREAUDIO_UTILITY_CLASSES)
+        platform/osx/avf/AVFSoundLevelUnit.cpp
 
 
 AVF_OBJECTS = $(patsubst %.mm,$(AVF_OBJBASE)/%.o,$(filter %.mm, $(AVF_SOURCES))) \
               $(patsubst %.cpp,$(AVF_OBJBASE)/%.o,$(filter %.cpp, $(AVF_SOURCES)))
 
 AVF_INCLUDES = \
     $(INCLUDES) \
-    $(COREAUDIO_INCLUDES) \
-    -I$(OSX_PLATFORM_BASE)
+    -I$(OSX_PLATFORM_BASE) \
+    -I$(GLIB_LITE_DIR)/ \
+    -I$(GLIB_LITE_DIR)/glib \
+    -I$(GLIB_LITE_DIR)/gmodule \
+    -I$(GLIB_LITE_DIR)/build/osx \
+    -I$(GSTREAMER_LITE_DIR)/gstreamer \
+    -I$(GSTREAMER_LITE_DIR)/gst-plugins-base/gst-libs \
+    -I$(GSTREAMER_LITE_DIR)/gstreamer/libs \
+    -I$(GSTREAMER_LITE_DIR)/gst-plugins-good/gst/spectrum
 
 -include $(AVF_OBJECTS:.o=.d)
 
 $(AVF_OBJBASE)/%.o: %.cpp
 	@mkdir -p $(dir $@)
