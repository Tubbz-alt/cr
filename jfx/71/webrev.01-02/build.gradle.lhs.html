<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames build.gradle</title>
    <link rel="stylesheet" href="style.css" />
    <script type="text/javascript" src="navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /**
  27  * The main build script for JavaFX.
  28  *
  29  * MUST FIX tasks to complete:
  30  *  - build check -- making sure the final artifact has the right bits
  31  *      - some things worth automatically sanity checking:
  32  *          - are there images in the javadocs?
  33  *          - are all of the expected dylibs etc there?
  34  *  - Perform sanity checking to make sure a JDK exists with javac, etc
  35  *  - Support building with no known JDK location, as long as javac, etc are on the path
  36  *  - Check all of the native flags. We&#39;re adding weight to some libs that don&#39;t need it, and so forth.
  37  *
  38  * Additional projects to work on as we go:
  39  *  - Add &quot;developer debug&quot;. This is where the natives do not have debug symbols, but the Java code does
  40  *  - The genVSproperties.bat doesn&#39;t find the directory where RC.exe lives. So it is hard coded. Might be a problem.
  41  *  - special tasks for common needs, such as:
  42  *      - updating copyright headers
  43  *      - stripping trailing whitespace (?)
  44  *  - checkstyle
  45  *  - findbugs
  46  *  - re needs?
  47  *  - sqe testing
  48  *  - API change check
  49  *  - Pushing results to a repo?
  50  *  - ServiceWithSecurityManagerTest fails to complete when run from gradle.
  51  *  - Integrate Parfait reports for C code
  52  *  - FXML Project tests are not running
  53  */
  54 defaultTasks = [&quot;sdk&quot;]
  55 
  56 import java.util.concurrent.CountDownLatch
  57 import java.util.concurrent.ExecutorService
  58 import java.util.concurrent.Executors
  59 import java.util.concurrent.Future
  60 
  61 /******************************************************************************
  62  *                              Utility methods                               *
  63  *****************************************************************************/
  64 
  65 /**
  66  * If the given named property is not defined, then this method will define
  67  * it with the given defaultValue. Any properties defined by this method can
  68  * be substituted on the command line by using -P, or by specifying a
  69  * gradle.properties file in the user home dir
  70  *
  71  * @param name The name of the property to define
  72  * @param defaultValue The default value to assign the property
  73  */
  74 void defineProperty(String name, String defaultValue) {
  75     if (!project.hasProperty(name)) {
  76         project.ext.set(name, defaultValue);
  77     }
  78 }
  79 
  80 /**
  81  * If the given named property is not defined, then this method will attempt to
  82  * look up the property in the props map, and use the defaultValue if it cannot be found.
  83  *
  84  * @param name The name of the property to look up and/or define
  85  * @param props The properties to look for the named property in, if it has not already been defined
  86  * @param defaultValue The default value if the property has not been defined and the
  87  *                     props map does not contain the named property
  88  */
  89 void defineProperty(String name, Properties props, String defaultValue) {
  90     if (!project.hasProperty(name)) {
  91         project.ext.set(name, props.getProperty(name, defaultValue));
  92     }
  93 }
  94 
  95 /**
  96  * Converts cygwin style paths to windows style paths, but with a forward slash.
  97  * This method is safe to call from any platform, and will only do work if
  98  * called on Windows (in all other cases it simply returns the supplied path.
  99  *
 100  * @param path the path to convert
 101  * @return the path converted to windows style, if on windows, otherwise it
 102  *         is the supplied path.
 103  */
 104 String cygpath(String path) {
 105     if (!IS_WINDOWS) return path;
 106     if (path == null || &quot;&quot;.equals(path)) return path;
 107     String ret = path.replaceAll(&#39;\\\\&#39;, &#39;/&#39;)
 108     logger.info(&quot;Converting path &#39;$path&#39; via cygpath to &quot;+ret)
 109     return ret
 110 }
 111 
 112 /**
 113  * Converts cygwin file paths for java executables to windows style
 114  * executable paths by changing forward slashes to back slashes and
 115  * adding the &#39;.exe&#39; extension.
 116  * This method is safe to call from any platform, and will only do work if
 117  * called on Windows (in all other cases it simply returns the supplied path).
 118  *
 119  * @param path the path to convert
 120  * @return the path converted to windows style, if on windows, otherwise it
 121  *         is the supplied path.
 122  */
 123 String cygpathExe(String path) {
 124     if (!IS_WINDOWS) return path;
 125     if (path == null || &quot;&quot;.equals(path)) return path;
 126     String ret = path.replaceAll(&#39;/&#39;, &#39;\\\\&#39;)
 127     logger.info(&quot;Converting path &#39;$path&#39; via cygpath to &quot;+ret)
 128     return ret + &quot;.exe&quot;
 129 }
 130 
 131 void loadProperties(String sourceFileName) {
 132     def config = new Properties()
 133     def propFile = new File(sourceFileName)
 134     if (propFile.canRead()) {
 135         config.load(new FileInputStream(propFile))
 136         for (java.util.Map.Entry property in config) {
 137             def keySplit = property.key.split(&quot;\\.&quot;);
 138             def key = keySplit[0];
 139             for (int i = 1; i &lt; keySplit.length; i++) {
 140                 key = key + keySplit[i].capitalize();
 141             }
 142             ext[key] = property.value;
 143         }
 144     }
 145 }
 146 
 147 /**
 148  * Struct used to contain some information passed to the closure
 149  * passed to compileTargets.
 150  */
 151 class CompileTarget {
 152     String name;
 153     String upper;
 154     String capital;
 155 }
 156 
 157 /**
 158  * Iterates over each of the compile targets, passing the given closure
 159  * a CompileTarget instance.
 160  *
 161  * @param c The closure to call
 162  */
 163 void compileTargets(Closure c) {
 164     if (COMPILE_TARGETS == &quot;&quot;) {
 165         return
 166     }
 167     COMPILE_TARGETS.split(&quot;,&quot;).each { target -&gt;
 168         CompileTarget ct = new CompileTarget();
 169         ct.name = target;
 170         ct.upper = target.trim().toUpperCase(Locale.ROOT)
 171         ct.capital = target.trim().capitalize()
 172         c(ct)
 173     }
 174 }
 175 
 176 /**
 177  * Manages the execution of some closure which is responsible for producing
 178  * content for a properties file built at build time and stored in the
 179  * root project&#39;s $buildDir, and then loading that properties file and
 180  * passing it to the processor closure.
 181  *
 182  * This is used on windows to produce a properties file containing all the
 183  * windows visual studio paths and environment variables, and on Linux
 184  * for storing the results of pkg-config calls.
 185  *
 186  * @param name the name of the file to produce
 187  * @param loader a closure which is invoked, given the properties file. This
 188  *        closure is invoked only if the properties file needs to be created
 189  *        and is responsible for populating the properties file.
 190  * @param processor a closure which is invoked every time this method is
 191  *        called and which will be given a Properties object, fully populated.
 192  *        The processor is then responsible for doing whatever it is that it
 193  *        must do with those properties (such as setting up environment
 194  *        variables used in subsequent native builds, or whatnot).
 195  */
 196 void setupTools(String name, Closure loader, Closure processor) {
 197     // Check to see whether $buildDir/$name.properties file exists. If not,
 198     // then generate it. Once generated, we need to read the properties file to
 199     // help us define the defaults for this block of properties
 200     File propFile = file(&quot;$buildDir/${name}.properties&quot;);
 201     if (!propFile.exists()) {
 202         // Create the properties file
 203         propFile.getParentFile().mkdirs();
 204         propFile.createNewFile();
 205         loader(propFile);
 206     }
 207 
 208     // Try reading the properties in order to define the properties. If the property file cannot
 209     // be located, then we will throw an exception because we cannot guess these values
 210     InputStream propStream = null;
 211     try {
 212         Properties properties = new Properties();
 213         propStream = new FileInputStream(propFile);
 214         properties.load(propStream);
 215         processor(properties);
 216     } finally {
 217         try { propStream.close() } catch (Exception e) { }
 218     }
 219 }
 220 
 221 String[] parseJavaVersion(String jRuntimeVersion) {
 222     def jVersion = jRuntimeVersion.split(&quot;[-\\+]&quot;)[0]
 223     def tmpBuildNumber = &quot;0&quot;
 224     if (jVersion.startsWith(&quot;1.&quot;)) {
 225         // This is a pre-JEP-223 version string
 226         def dashbIdx = jRuntimeVersion.lastIndexOf(&quot;-b&quot;)
 227         if (dashbIdx != -1) {
 228             tmpBuildNumber = jRuntimeVersion.substring(dashbIdx + 2)
 229         }
 230     } else {
 231         // This is a post-JEP-223 version string
 232         def plusIdx = jRuntimeVersion.indexOf(&quot;+&quot;)
 233         if (plusIdx != -1) {
 234             tmpBuildNumber = jRuntimeVersion.substring(plusIdx + 1)
 235         }
 236     }
 237     def jBuildNumber = tmpBuildNumber.split(&quot;[-\\+]&quot;)[0]
 238     def versionInfo = new String[2];
 239     versionInfo[0] = jVersion
 240     versionInfo[1] = jBuildNumber
 241     return versionInfo
 242 }
 243 
 244 /**
 245  * Fails the build with the specified error message
 246  *
 247  * @param msg the reason for the failure
 248  */
 249 void fail(String msg) {
 250     throw new GradleException(&quot;FAIL: &quot; + msg);
 251 }
 252 
 253 /******************************************************************************
 254  *                                                                            *
 255  *                   Definition of project properties                         *
 256  *                                                                            *
 257  *  All properties defined using ext. are immediately available throughout    *
 258  *  the script as variables that can be used. These variables are attached    *
 259  *  to the root project (whereas if they were defined as def variables then   *
 260  *  they would only be available within the root project scope).              *
 261  *                                                                            *
 262  *  All properties defined using the &quot;defineProperty&quot; method can be replaced  *
 263  *  on the command line by using the -P flag. For example, to override the    *
 264  *  location of the binary plug, you would specify -PBINARY_PLUG=some/where   *
 265  *                                                                            *
 266  *****************************************************************************/
 267 
 268 // If the ../rt-closed directory exists, then we are doing a closed build.
 269 // In this case, build and property files will be read from
 270 // ../rt-closed/closed-build.gradle and ../rt-closed/closed-properties.gradle
 271 // respectively
 272 
 273 def closedDir = file(&quot;../rt-closed&quot;)
 274 def buildClosed = closedDir.isDirectory()
 275 ext.BUILD_CLOSED = buildClosed
 276 
 277 ext.RUNARGSFILE = &quot;run.args&quot;
 278 ext.COMPILEARGSFILE = &quot;compile.args&quot;
 279 ext.RUNJAVAPOLICYFILE = &#39;run.java.policy&#39;
 280 
 281 ext.TESTCOMPILEARGSFILE = &quot;testcompile.args&quot;
 282 ext.TESTRUNARGSFILE = &quot;testrun.args&quot;
 283 ext.TESTJAVAPOLICYFILE = &#39;test.java.policy&#39;
 284 
 285 // the file containing &quot;extra&quot; --add-exports
 286 ext.EXTRAADDEXPORTS = &#39;buildSrc/addExports&#39;
 287 
 288 ext.MODULESOURCEPATH = &quot;modulesourcepath.args&quot;
 289 
 290 // These variables indicate what platform is running the build. Is
 291 // this build running on a Mac, Windows, or Linux machine? 32 or 64 bit?
 292 ext.OS_NAME = System.getProperty(&quot;os.name&quot;).toLowerCase()
 293 ext.OS_ARCH = System.getProperty(&quot;os.arch&quot;)
 294 ext.IS_64 = OS_ARCH.toLowerCase().contains(&quot;64&quot;)
 295 ext.IS_MAC = OS_NAME.contains(&quot;mac&quot;) || OS_NAME.contains(&quot;darwin&quot;)
 296 ext.IS_WINDOWS = OS_NAME.contains(&quot;windows&quot;)
 297 ext.IS_LINUX = OS_NAME.contains(&quot;linux&quot;)
 298 
 299 ext.MAVEN_GROUP_ID = &quot;org.openjfx&quot;
 300 
 301 // Verify that the architecture &amp; OS are supported configurations. Note that
 302 // at present building on PI is not supported, but we would only need to make
 303 // some changes on assumptions on what should be built (like SWT / Swing) and
 304 // such and we could probably make it work.
 305 if (!IS_MAC &amp;&amp; !IS_WINDOWS &amp;&amp; !IS_LINUX) fail(&quot;Unsupported build OS ${OS_NAME}&quot;)
 306 if (IS_WINDOWS &amp;&amp; OS_ARCH != &quot;x86&quot; &amp;&amp; OS_ARCH != &quot;amd64&quot;) {
 307     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 308 } else if (IS_MAC &amp;&amp; OS_ARCH != &quot;x86_64&quot;) {
 309     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 310 } else if (IS_LINUX &amp;&amp; OS_ARCH != &quot;i386&quot; &amp;&amp; OS_ARCH != &quot;amd64&quot;) {
 311     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 312 }
 313 
 314 
 315 // Get the JDK_HOME automatically based on the version of Java used to execute gradle. Or, if specified,
 316 // use a user supplied JDK_HOME, STUB_RUNTIME, JAVAC, all of which may be specified
 317 // independently (or we&#39;ll try to get the right one based on other supplied info). Sometimes the
 318 // JRE might be the thing that is being used instead of the JRE embedded in the JDK, such as:
 319 //    c:\Program Files (x86)\Java\jdk1.8.0\jre
 320 //    c:\Program Files (x86)\Java\jre8\
 321 // Because of this, you may sometimes get the jdk&#39;s JRE (in which case the logic we used to have here
 322 // was correct and consistent with all other platforms), or it might be the standalone JRE (for the love!).
 323 def envJavaHome = cygpath(System.getenv(&quot;JDK_HOME&quot;))
 324 if (envJavaHome == null || envJavaHome.equals(&quot;&quot;)) envJavaHome = cygpath(System.getenv(&quot;JAVA_HOME&quot;))
 325 def javaHome = envJavaHome == null || envJavaHome.equals(&quot;&quot;) ? System.getProperty(&quot;java.home&quot;) : envJavaHome
 326 def javaHomeFile = file(javaHome)
 327 defineProperty(&quot;JDK_HOME&quot;,
 328         javaHomeFile.name == &quot;jre&quot; ?
 329         javaHomeFile.getParent().toString() :
 330         javaHomeFile.name.startsWith(&quot;jre&quot;) ?
 331         new File(javaHomeFile.getParent(), &quot;jdk1.${javaHomeFile.name.substring(3)}.0&quot;).toString() :
 332         javaHome) // we have to bail and set it to something and this is as good as any!
 333 ext.JAVA_HOME = JDK_HOME
 334 
 335 defineProperty(&quot;JAVA&quot;, cygpathExe(&quot;$JDK_HOME/bin/java&quot;))
 336 defineProperty(&quot;JAVAC&quot;, cygpathExe(&quot;$JDK_HOME/bin/javac&quot;))
 337 defineProperty(&quot;JAVADOC&quot;, cygpathExe(&quot;$JDK_HOME/bin/javadoc&quot;))
 338 defineProperty(&quot;JMOD&quot;, cygpathExe(&quot;$JDK_HOME/bin/jmod&quot;))
 339 defineProperty(&quot;JDK_DOCS&quot;, &quot;https://docs.oracle.com/en/java/javase/12/docs/api/&quot;)
 340 defineProperty(&quot;JDK_JMODS&quot;, cygpath(System.getenv(&quot;JDK_JMODS&quot;)) ?: cygpath(System.getenv(&quot;JDK_HOME&quot;) + &quot;/jmods&quot;))
 341 
 342 defineProperty(&quot;javaRuntimeVersion&quot;, System.getProperty(&quot;java.runtime.version&quot;))
 343 def javaVersionInfo = parseJavaVersion(javaRuntimeVersion)
 344 defineProperty(&quot;javaVersion&quot;, javaVersionInfo[0])
 345 defineProperty(&quot;javaBuildNumber&quot;, javaVersionInfo[1])
 346 
 347 defineProperty(&quot;libAVRepositoryURL&quot;, &quot;https://libav.org/releases/&quot;)
 348 defineProperty(&quot;FFmpegRepositoryURL&quot;, &quot;https://www.ffmpeg.org/releases/&quot;)
 349 
 350 loadProperties(&quot;$projectDir/build.properties&quot;)
 351 
 352 def supplementalPreBuildFile = file(&quot;$closedDir/closed-pre-build.gradle&quot;);
 353 def supplementalBuildFile = file(&quot;$closedDir/closed-build.gradle&quot;);
 354 
 355 if (BUILD_CLOSED) {
 356     apply from: supplementalPreBuildFile
 357 }
 358 
 359 // GRADLE_VERSION_CHECK specifies whether to fail the build if the
 360 // gradle version check fails
 361 defineProperty(&quot;GRADLE_VERSION_CHECK&quot;, &quot;true&quot;)
 362 ext.IS_GRADLE_VERSION_CHECK = Boolean.parseBoolean(GRADLE_VERSION_CHECK)
 363 
 364 // JFX_DEPS_URL specifies the optional location of an alternate local repository
 365 defineProperty(&quot;JFX_DEPS_URL&quot;, &quot;&quot;)
 366 
 367 // JDK_DOCS_LINK specifies the optional URL for offline javadoc linking
 368 defineProperty(&quot;JDK_DOCS_LINK&quot;, &quot;&quot;)
 369 
 370 // COMPILE_WEBKIT specifies whether to build all of webkit.
 371 defineProperty(&quot;COMPILE_WEBKIT&quot;, &quot;false&quot;)
 372 ext.IS_COMPILE_WEBKIT = Boolean.parseBoolean(COMPILE_WEBKIT)
 373 
 374 // COMPILE_MEDIA specifies whether to build all of media.
 375 defineProperty(&quot;COMPILE_MEDIA&quot;, &quot;false&quot;)
 376 ext.IS_COMPILE_MEDIA = Boolean.parseBoolean(COMPILE_MEDIA)
 377 
 378 // BUILD_LIBAV_STUBS specifies whether to download and build libav/ffmpeg libraries
 379 defineProperty(&quot;BUILD_LIBAV_STUBS&quot;, &quot;false&quot;)
 380 ext.IS_BUILD_LIBAV_STUBS = IS_LINUX ? Boolean.parseBoolean(BUILD_LIBAV_STUBS) : false
 381 
 382 // BUILD_WORKING_LIBAV specifies whether to build libav/ffmpeg libraries with
 383 // decoder, demuxer, etc. required to run media. Valid only if BUILD_LIBAV_STUBS is true.
 384 defineProperty(&quot;BUILD_WORKING_LIBAV&quot;, &quot;false&quot;)
 385 ext.IS_BUILD_WORKING_LIBAV = IS_LINUX ? Boolean.parseBoolean(BUILD_WORKING_LIBAV) : false
 386 
 387 // COMPILE_PANGO specifies whether to build javafx_font_pango.
 388 defineProperty(&quot;COMPILE_PANGO&quot;, &quot;${IS_LINUX}&quot;)
 389 ext.IS_COMPILE_PANGO = Boolean.parseBoolean(COMPILE_PANGO)
 390 
 391 // COMPILE_HARFBUZZ specifies whether to use Harfbuzz.
 392 defineProperty(&quot;COMPILE_HARFBUZZ&quot;, &quot;false&quot;)
 393 ext.IS_COMPILE_HARFBUZZ = Boolean.parseBoolean(COMPILE_HARFBUZZ)
 394 
 395 // COMPILE_PARFAIT specifies whether to build parfait
 396 defineProperty(&quot;COMPILE_PARFAIT&quot;, &quot;false&quot;)
 397 ext.IS_COMPILE_PARFAIT = Boolean.parseBoolean(COMPILE_PARFAIT)
 398 
 399 defineProperty(&quot;STATIC_BUILD&quot;, &quot;false&quot;)
 400 ext.IS_STATIC_BUILD = Boolean.parseBoolean(STATIC_BUILD)
 401 
 402 if (IS_STATIC_BUILD &amp;&amp; IS_COMPILE_MEDIA) {
 403     throw new GradleException(&quot;Can not have COMPILE_MEDIA when STATIC_BUILD is enabled&quot;);
 404 }
 405 
 406 // BUILD_TOOLS_DOWNLOAD_SCRIPT specifies a path of a gradle script which downloads
 407 // required build tools.
 408 defineProperty(&quot;BUILD_TOOLS_DOWNLOAD_SCRIPT&quot;, &quot;&quot;)
 409 
 410 // Define the SWT.jar that we are going to have to download during the build process based
 411 // on what platform we are compiling from (not based on our target).
 412 ext.SWT_FILE_NAME = IS_MAC ? &quot;org.eclipse.swt.cocoa.macosx.x86_64_3.105.3.v20170228-0512&quot; :
 413     IS_WINDOWS &amp;&amp; IS_64 ? &quot;org.eclipse.swt.win32.win32.x86_64_3.105.3.v20170228-0512&quot; :
 414     IS_WINDOWS &amp;&amp; !IS_64 ? &quot;org.eclipse.swt.win32.win32.x86_3.105.3.v20170228-0512&quot; :
 415     IS_LINUX &amp;&amp; IS_64 ? &quot;org.eclipse.swt.gtk.linux.x86_64_3.105.3.v20170228-0512&quot; :
 416     IS_LINUX &amp;&amp; !IS_64 ? &quot;org.eclipse.swt.gtk.linux.x86_3.105.3.v20170228-0512&quot; : &quot;&quot;
 417 
 418 // Specifies whether to run full tests (true) or smoke tests (false)
 419 defineProperty(&quot;FULL_TEST&quot;, &quot;false&quot;)
 420 ext.IS_FULL_TEST = Boolean.parseBoolean(FULL_TEST);
 421 
 422 defineProperty(&quot;FORCE_TESTS&quot;, &quot;false&quot;)
 423 ext.IS_FORCE_TESTS = Boolean.parseBoolean(FORCE_TESTS);
 424 
 425 // Specifies whether to run robot-based visual tests (only used when FULL_TEST is also enabled)
 426 defineProperty(&quot;USE_ROBOT&quot;, &quot;false&quot;)
 427 ext.IS_USE_ROBOT = Boolean.parseBoolean(USE_ROBOT);
 428 
 429 // Specified whether to run tests in headless mode
 430 defineProperty(&quot;HEADLESS_TEST&quot;, &quot;false&quot;)
 431 ext.IS_HEADLESS_TEST = Boolean.parseBoolean(HEADLESS_TEST);
 432 
 433 // Specifies whether to run system tests that depend on AWT (only used when FULL_TEST is also enabled)
 434 defineProperty(&quot;AWT_TEST&quot;, &quot;true&quot;)
 435 ext.IS_AWT_TEST = Boolean.parseBoolean(AWT_TEST);
 436 
 437 // Specifies whether to run system tests that depend on SWT (only used when FULL_TEST is also enabled)
 438 defineProperty(&quot;SWT_TEST&quot;, &quot;true&quot;)
 439 ext.IS_SWT_TEST = Boolean.parseBoolean(SWT_TEST);
 440 
 441 // Specifies whether to run unstable tests (true) - tests that don&#39;t run well with Hudson builds
 442 // These tests should be protected with :
 443 //    assumeTrue(Boolean.getBoolean(&quot;unstable.test&quot;));
 444 defineProperty(&quot;UNSTABLE_TEST&quot;, &quot;false&quot;)
 445 ext.IS_UNSTABLE_TEST = Boolean.parseBoolean(UNSTABLE_TEST);
 446 
 447 // Toggle diagnostic output from the Gradle workaround and the Sandbox test apps.
 448 defineProperty(&quot;WORKER_DEBUG&quot;, &quot;false&quot;)
 449 ext.IS_WORKER_DEBUG = Boolean.parseBoolean(WORKER_DEBUG);
 450 
 451 // Specify the build configuration (Release, Debug, or DebugNative)
 452 defineProperty(&quot;CONF&quot;, &quot;Debug&quot;)
 453 ext.IS_DEBUG_JAVA = CONF == &quot;Debug&quot; || CONF == &quot;DebugNative&quot;
 454 ext.IS_DEBUG_NATIVE = CONF == &quot;DebugNative&quot;
 455 
 456 // Defines the compiler warning levels to use. If empty, then no warnings are generated. If
 457 // not empty, then the expected syntax is as a space or comma separated list of names, such
 458 // as defined in the javac documentation.
 459 defineProperty(&quot;LINT&quot;, &quot;none&quot;)
 460 ext.IS_LINT = LINT != &quot;none&quot;
 461 
 462 defineProperty(&quot;DOC_LINT&quot;, &quot;all&quot;)
 463 ext.IS_DOC_LINT = DOC_LINT != &quot;&quot;
 464 
 465 // Specifies whether to use the &quot;useDepend&quot; option when compiling Java sources
 466 defineProperty(&quot;USE_DEPEND&quot;, &quot;true&quot;)
 467 ext.IS_USE_DEPEND = Boolean.parseBoolean(USE_DEPEND)
 468 
 469 // Specifies whether to use the &quot;incremental&quot; option when compiling Java sources
 470 defineProperty(&quot;INCREMENTAL&quot;, &quot;false&quot;)
 471 ext.IS_INCREMENTAL = Boolean.parseBoolean(INCREMENTAL)
 472 
 473 // Specifies whether to include the Null3D pipeline (for perf debugging)
 474 defineProperty(&quot;INCLUDE_NULL3D&quot;, &quot;false&quot;)
 475 ext.IS_INCLUDE_NULL3D = Boolean.parseBoolean(INCLUDE_NULL3D)
 476 
 477 // Specifies whether to include the ES2 pipeline if available
 478 defineProperty(&quot;INCLUDE_ES2&quot;, IS_WINDOWS ? &quot;false&quot; : &quot;true&quot;)
 479 ext.IS_INCLUDE_ES2 = Boolean.parseBoolean(INCLUDE_ES2)
 480 
 481 // Specifies whether to generate code coverage statistics when running tests
 482 defineProperty(&quot;JCOV&quot;, &quot;false&quot;)
 483 ext.DO_JCOV = Boolean.parseBoolean(JCOV)
 484 
 485 // Specifies whether to use Cygwin when building OpenJFX. This should only ever
 486 // be set to false for development builds (that skip building media and webkit).
 487 defineProperty(&quot;USE_CYGWIN&quot;, &quot;true&quot;)
 488 ext.IS_USE_CYGWIN = Boolean.parseBoolean(USE_CYGWIN)
 489 
 490 // Define the number of threads to use when compiling (specifically for native compilation)
 491 // On Mac we limit it to 1 by default due to problems running gcc in parallel
 492 if (IS_MAC) {
 493     defineProperty(&quot;NUM_COMPILE_THREADS&quot;, &quot;1&quot;)
 494 } else {
 495     defineProperty(&quot;NUM_COMPILE_THREADS&quot;, &quot;${Runtime.runtime.availableProcessors()}&quot;)
 496 }
 497 
 498 //
 499 // The next three sections of properties are used to generate the
 500 // VersionInfo class, and the Windows DLL manifest.
 501 //
 502 
 503 // The following properties should be left alone by developers and set only from Hudson.
 504 defineProperty(&quot;HUDSON_JOB_NAME&quot;, &quot;not_hudson&quot;)
 505 defineProperty(&quot;HUDSON_BUILD_NUMBER&quot;,&quot;0000&quot;)
 506 defineProperty(&quot;PROMOTED_BUILD_NUMBER&quot;, &quot;0&quot;)
 507 defineProperty(&quot;MILESTONE_FCS&quot;, &quot;false&quot;)
 508 ext.IS_MILESTONE_FCS = Boolean.parseBoolean(MILESTONE_FCS)
 509 
 510 // The following properties define the product name for Oracle JDK and OpenJDK
 511 // for VersionInfo and the DLL manifest.
 512 if (BUILD_CLOSED) {
 513     defineProperty(&quot;PRODUCT_NAME&quot;, &quot;Java(TM)&quot;)
 514     defineProperty(&quot;COMPANY_NAME&quot;, &quot;Oracle Corporation&quot;)
 515     defineProperty(&quot;PLATFORM_NAME&quot;, &quot;Platform SE&quot;)
 516 } else {
 517     defineProperty(&quot;PRODUCT_NAME&quot;, &quot;OpenJFX&quot;)
 518     defineProperty(&quot;COMPANY_NAME&quot;, &quot;N/A&quot;)
 519     defineProperty(&quot;PLATFORM_NAME&quot;, &quot;Platform&quot;)
 520 }
 521 
 522 // The following properties are set based on properties defined in
 523 // build.properties. The release version and suffix should be updated
 524 // in that file.
 525 def relVer = 0
 526 if (jfxReleasePatchVersion == &quot;0&quot;) {
 527     if (jfxReleaseSecurityVersion == &quot;0&quot;) {
 528         if (jfxReleaseMinorVersion == &quot;0&quot;) {
 529             relVer = &quot;${jfxReleaseMajorVersion}&quot;
 530         } else {
 531             relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}&quot;
 532         }
 533     } else {
 534         relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}&quot;
 535     }
 536 } else {
 537     relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}&quot;
 538 }
 539 defineProperty(&quot;RELEASE_VERSION&quot;, relVer)
 540 defineProperty(&quot;RELEASE_VERSION_PADDED&quot;, &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}&quot;)
 541 
 542 def buildDate = new java.util.Date()
 543 def buildTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd-HHmmss&quot;).format(buildDate)
 544 defineProperty(&quot;BUILD_TIMESTAMP&quot;, buildTimestamp)
 545 def relSuffix = &quot;&quot;
 546 def relOpt = &quot;&quot;
 547 if (HUDSON_JOB_NAME == &quot;not_hudson&quot;) {
 548     relSuffix = &quot;-internal&quot;
 549     relOpt = &quot;-${buildTimestamp}&quot;
 550 } else {
 551     relSuffix = IS_MILESTONE_FCS ? &quot;&quot; : jfxReleaseSuffix
 552 }
 553 defineProperty(&quot;RELEASE_SUFFIX&quot;, relSuffix)
 554 defineProperty(&quot;RELEASE_VERSION_SHORT&quot;, &quot;${RELEASE_VERSION}${RELEASE_SUFFIX}&quot;)
 555 defineProperty(&quot;RELEASE_VERSION_LONG&quot;, &quot;${RELEASE_VERSION_SHORT}+${PROMOTED_BUILD_NUMBER}${relOpt}&quot;)
 556 defineProperty(&quot;MAVEN_VERSION&quot;, IS_MILESTONE_FCS ? &quot;${RELEASE_VERSION_SHORT}&quot; : &quot;${RELEASE_VERSION_LONG}&quot;)
 557 
 558 // Check whether the COMPILE_TARGETS property has been specified (if so, it was done by
 559 // the user and not by this script). If it has not been defined then default
 560 // to building the normal desktop build for this machine
 561 project.ext.set(&quot;defaultHostTarget&quot;, IS_MAC ? &quot;mac&quot; : IS_WINDOWS ? &quot;win&quot; : IS_LINUX ? &quot;linux&quot; : &quot;&quot;);
 562 defineProperty(&quot;COMPILE_TARGETS&quot;, &quot;$defaultHostTarget&quot;)
 563 
 564 // Flag indicating whether to import cross compile tools
 565 def importCrossTools = false
 566 if (hasProperty(&quot;IMPORT_CROSS_TOOLS&quot;)) {
 567     importCrossTools = Boolean.parseBoolean(IMPORT_CROSS_TOOLS);
 568 }
 569 ext.IS_IMPORT_CROSS_TOOLS = importCrossTools
 570 
 571 // Location of the cross compile tools
 572 def crossToolsDir = &quot;../crosslibs&quot;
 573 if (hasProperty(&quot;CROSS_TOOLS_DIR&quot;)) {
 574     crossToolsDir = CROSS_TOOLS_DIR
 575 }
 576 ext.CROSS_TOOLS_DIR = file(crossToolsDir)
 577 
 578 // Specifies whether to run tests with the existing javafx.* modules instead of compiling a new one
 579 defineProperty(&quot;BUILD_SDK_FOR_TEST&quot;, &quot;true&quot;)
 580 ext.DO_BUILD_SDK_FOR_TEST = Boolean.parseBoolean(BUILD_SDK_FOR_TEST)
 581 
 582 // All &quot;classes&quot; and &quot;jar&quot; tasks and their dependencies would be disabled
 583 // when running with DO_BUILD_SDK_FOR_TEST=false as they&#39;re unneeded for running tests
 584 if (!DO_BUILD_SDK_FOR_TEST) {
 585     gradle.taskGraph.useFilter({ task -&gt; !task.name.equals(&quot;classes&quot;) &amp;&amp; !task.name.equals(&quot;jar&quot;) })
 586 }
 587 
 588 // Make sure JDK_HOME/bin/java exists
 589 if (!file(JAVA).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;java&#39;: &#39;$JAVA&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 590 if (!file(JAVAC).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;javac&#39;: &#39;$JAVAC&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 591 if (!file(JAVADOC).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;javadoc&#39;: &#39;$JAVADOC&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 592 
 593 // Determine the verion of Java in JDK_HOME. It looks like this:
 594 //
 595 // $ java -version
 596 // java version &quot;1.7.0_45&quot;
 597 // Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
 598 // Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
 599 //
 600 // We need to parse the second line
 601 def inStream = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, &quot;-fullversion&quot;).start().getErrorStream()));
 602 try {
 603     String v = inStream.readLine().trim();
 604     if (v != null) {
 605         int ib = v.indexOf(&quot;full version \&quot;&quot;);
 606         if (ib != -1) {
 607             String str = v.substring(ib);
 608             String ver = str.substring(str.indexOf(&quot;\&quot;&quot;) + 1, str.size() - 1);
 609 
 610             defineProperty(&quot;jdkRuntimeVersion&quot;, ver)
 611             def jdkVersionInfo = parseJavaVersion(ver)
 612             defineProperty(&quot;jdkVersion&quot;, jdkVersionInfo[0])
 613             defineProperty(&quot;jdkBuildNumber&quot;, jdkVersionInfo[1])
 614         }
 615     }
 616 } finally {
 617     inStream.close();
 618 }
 619 if (!project.hasProperty(&quot;jdkRuntimeVersion&quot;)) throw new Exception(&quot;Unable to determine the version of Java in JDK_HOME at $JDK_HOME&quot;);
 620 
 621 
 622 // Determine whether the javafx.* modules are present in the JDK. To do this,
 623 // we will execute &quot;java --list-modules&quot; and search for javafx.base.
 624 ext.HAS_JAVAFX_MODULES = false;
 625 def inStream2 = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, &quot;--list-modules&quot;).start().getInputStream()));
 626 try {
 627     String v;
 628     while ((v = inStream2.readLine()) != null) {
 629         v = v.trim();
 630         if (v.startsWith(&quot;javafx.base&quot;)) ext.HAS_JAVAFX_MODULES = true;
 631     }
 632 } finally {
 633     inStream2.close();
 634 }
 635 
 636 // The HAS_JAVAFX_MODULES flag will be used to determine the mode for building
 637 // and running the applications and tests.
 638 // If HAS_JAVAFX_MODULES is true, then we will build / test javafx modules
 639 // for exporting to a JDK build. If HAS_JAVAFX_MODULES is false, then we will
 640 // build / test a standalone sdk for running with a JDK that does not include
 641 // the javafx modules.
 642 
 643 
 644 /**
 645  * Fetch/Check that external tools are present for the build. This method
 646  * will conditionally download the packages from project defined ivy repositories
 647  * and unpack them into the specified destdir
 648  *
 649  * @param configName A unique name to distinguish the configuration (ie &quot;ARMSFV6&quot;)
 650  * @param packages A list of required packages (with extensions .tgz, .zip)
 651  * @param destdir where the packages should be unpacked
 652  * @param doFetch if true, the named packages will be download
 653  */
 654 void fetchExternalTools(String configName, List packages, File destdir, boolean doFetch) {
 655     if (doFetch) {
 656         // create a unique configuration for this fetch
 657         def String fetchToolsConfig = &quot;fetchTools$configName&quot;
 658         rootProject.configurations.create(fetchToolsConfig)
 659 
 660         def List&lt;String&gt; fetchedPackages = []
 661         def int fetchCount = 0
 662 
 663         packages.each { pkgname-&gt;
 664             def int dotdex = pkgname.lastIndexOf(&#39;.&#39;)
 665             def int dashdex = pkgname.lastIndexOf(&#39;-&#39;)
 666             def String basename = pkgname.substring(0,dashdex)
 667             def String ver = pkgname.substring(dashdex+1,dotdex)
 668             def String ext = pkgname.substring(dotdex+1)
 669             def File pkgdir = file(&quot;$destdir/$basename-$ver&quot;)
 670 
 671             if (!pkgdir.isDirectory()) {
 672                 rootProject.dependencies.add(fetchToolsConfig, &quot;javafx:$basename:$ver&quot;, {
 673                     artifact {
 674                         name = basename
 675                         type = ext
 676                     }
 677                 })
 678                 println &quot;adding $pkgname as a downloadable item did not find $pkgdir&quot;
 679                 fetchedPackages.add(pkgname)
 680                 fetchCount++
 681             }
 682         }
 683 
 684         //fetch all the missing packages
 685         if (fetchedPackages.size &gt; 0) {
 686             destdir.mkdirs()
 687 
 688             logger.quiet &quot;fetching missing packages $fetchedPackages&quot;
 689             copy {
 690                 from rootProject.configurations[fetchToolsConfig]
 691                 into destdir
 692             }
 693 
 694             // unpack the fetched packages
 695             fetchedPackages.each { pkgname-&gt;
 696                 logger.quiet &quot;expanding the package $pkgname&quot;
 697                 def srcball = file(&quot;${destdir}/${pkgname}&quot;)
 698 
 699                 if (!srcball.exists()) {
 700                     throw new GradleException(&quot;Failed to fetch $pkgname&quot;);
 701                 }
 702 
 703                 def String basename = pkgname.substring(0,pkgname.lastIndexOf(&quot;.&quot;))
 704                 def File pkgdir = file(&quot;$destdir/$basename&quot;)
 705 
 706                 if (pkgname.endsWith(&quot;.tgz&quot;) || pkgname.endsWith(&quot;tar.gz&quot;)) {
 707                     if (IS_LINUX || IS_MAC) {
 708                         // use native tar to support symlinks
 709                         pkgdir.mkdirs()
 710                         exec {
 711                             workingDir pkgdir
 712                             commandLine &quot;tar&quot;, &quot;zxf&quot;, &quot;${srcball}&quot;
 713                          }
 714                     } else {
 715                         copy {
 716                             from tarTree(resources.gzip(&quot;${srcball}&quot;))
 717                             into pkgdir
 718                         }
 719                     }
 720                 } else if (pkgname.endsWith(&quot;.zip&quot;)) {
 721                      copy {
 722                          from zipTree(&quot;${srcball}&quot;)
 723                          into pkgdir
 724                      }
 725                 } else {
 726                     throw new GradleException(&quot;Unhandled package type for compile package ${pkgname}&quot;)
 727                 }
 728                 srcball.delete();
 729             }
 730         } else {
 731             logger.quiet &quot;all tool packages are present $packages&quot;
 732         }
 733     } else { // !doFetch - so just check they are present
 734         // check that all the dirs are really there
 735         def List&lt;String&gt; errors = []
 736         packages.each { pkgname-&gt;
 737             def String basename = pkgname.substring(0,pkgname.lastIndexOf(&quot;.&quot;))
 738             def File pkgdir = file(&quot;$destdir/$basename&quot;)
 739 
 740             if (!pkgdir.isDirectory()) {
 741                 errors.add(pkgname)
 742             }
 743         }
 744         if (errors.size &gt; 0) {
 745             throw new GradleException(&quot;Error: missing tool packages: $errors&quot;)
 746         } else {
 747             logger.quiet &quot;all tool packages are present $packages&quot;
 748         }
 749     }
 750 }
 751 
 752 // Make a forked ANT call.
 753 // This needs to be forked so that ant can be used with the right JDK and updated modules
 754 // for testing obscure things like packaging of apps
 755 void ant(String conf,   // platform configuration
 756          String dir,    // directory to run from
 757          String target, // ant target
 758          List&lt;String&gt;  params // parameters (usually -Dxxx=yyy)
 759          ) {
 760     // Try to use ANT_HOME
 761     String antHomeEnv = System.getenv(&quot;ANT_HOME&quot;)
 762     String antHome = antHomeEnv != null ? cygpath(antHomeEnv) : null;
 763     String ant = (antHome != null &amp;&amp; !antHome.equals(&quot;&quot;)) ? &quot;$antHome/bin/ant&quot; : &quot;ant&quot;;
 764 
 765     exec {
 766         workingDir = dir
 767         environment(&quot;JDK_HOME&quot;, JDK_HOME)
 768         environment(&quot;JAVA_HOME&quot;, JDK_HOME)
 769         if (IS_WINDOWS) {
 770             environment([
 771                     &quot;VCINSTALLDIR&quot;         : WINDOWS_VS_VCINSTALLDIR,
 772                     &quot;VSINSTALLDIR&quot;         : WINDOWS_VS_VSINSTALLDIR,
 773                     &quot;DEVENVDIR&quot;            : WINDOWS_VS_DEVENVDIR,
 774                     &quot;MSVCDIR&quot;              : WINDOWS_VS_MSVCDIR,
 775                     &quot;INCLUDE&quot;              : WINDOWS_VS_INCLUDE,
 776                     &quot;LIB&quot;                  : WINDOWS_VS_LIB,
 777                     &quot;LIBPATH&quot;              : WINDOWS_VS_LIBPATH,
 778                     &quot;DXSDK_DIR&quot;            : WINDOWS_DXSDK_DIR,
 779                     &quot;PATH&quot;                 : WINDOWS_VS_PATH
 780             ]);
 781             commandLine &quot;cmd&quot;, &quot;/c&quot;, ant, &quot;-Dbuild.compiler=javac1.7&quot;
 782         } else {
 783             commandLine ant, &quot;-Dbuild.compiler=javac1.7&quot;
 784         }
 785         if ((conf != null) &amp;&amp; !rootProject.defaultHostTarget.equals(conf)) {
 786             def targetProperties = rootProject.ext[conf.trim().toUpperCase()]
 787             args(&quot;-Dcross.platform=$conf&quot;)
 788             if (targetProperties.containsKey(&#39;arch&#39;)) {
 789                 args(&quot;-Dcross.platform.arch=${targetProperties.arch}&quot;)
 790             }
 791         }
 792         if (params != null) {
 793             params.each() { s-&gt;
 794                 args(s)
 795             }
 796         }
 797         if (IS_MILESTONE_FCS) {
 798             args(&#39;-Djfx.release.suffix=&quot;&quot;&#39;)
 799         }
 800         args(target);
 801     }
 802 }
 803 
 804 List&lt;String&gt; computeLibraryPath(boolean working) {
 805     List&lt;String&gt; lp = []
 806 
 807     if (HAS_JAVAFX_MODULES) {
 808         List&lt;String&gt; modsWithNative = [ &#39;graphics&#39;, &#39;media&#39;, &#39;web&#39; ]
 809 
 810         // the build/modular-sdk area
 811         def platformPrefix = &quot;&quot;
 812         def bundledSdkDirName = &quot;${platformPrefix}modular-sdk&quot;
 813         def bundledSdkDir = &quot;${rootProject.buildDir}/${bundledSdkDirName}&quot;
 814         def modulesLibsDir = &quot;${bundledSdkDir}/modules_libs&quot;
 815 
 816         modsWithNative.each() { m -&gt;
 817             lp &lt;&lt; cygpath(&quot;${modulesLibsDir}/javafx.${m}&quot;)
 818         }
 819     } else {
 820         def platformPrefix = &quot;&quot;
 821         def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
 822         def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
 823         def modulesLibName = IS_WINDOWS ? &quot;bin&quot; : &quot;lib&quot;
 824         def modulesLibsDir = &quot;${standaloneSdkDir}/${modulesLibName}&quot;
 825         lp &lt;&lt; cygpath(&quot;${modulesLibsDir}&quot;)
 826     }
 827 
 828     return lp
 829 }
 830 
 831 // Return list with the arguments needed for --patch-module or --module-path
 832 // for the provided projects. Used with Java executables ie. tests
 833 List&lt;String&gt; computePatchModuleArgs(List&lt;String&gt; deps, boolean test, boolean includeJLP) {
 834     List&lt;String&gt; pma = []
 835 
 836     if (HAS_JAVAFX_MODULES) {
 837         deps.each { String projname -&gt;
 838             def proj = project(projname)
 839             if (proj.hasProperty(&quot;moduleName&quot;)) {
 840                 File dir;
 841                 if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 842                     dir = file(&quot;${rootProject.buildDir}/shims&quot;)
 843                 } else {
 844                     dir = file(&quot;${rootProject.buildDir}/modular-sdk/modules&quot;)
 845                 }
 846                 String moduleName = proj.ext.moduleName
 847                 String dirpath = cygpath(&quot;${dir}/${moduleName}&quot;)
 848                 pma += &quot;--patch-module=${moduleName}=${dirpath}&quot;
 849             }
 850         }
 851     } else {
 852         String mp = null
 853         deps.each { String projname -&gt;
 854             def proj = project(projname)
 855             if (proj.hasProperty(&quot;moduleName&quot;)) {
 856                 String moduleName = proj.ext.moduleName
 857                 File dir;
 858                 if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 859                     dir = file(&quot;${rootProject.buildDir}/shims/${moduleName}&quot;)
 860                 } else {
 861                     dir = file(&quot;${rootProject.buildDir}/sdk/lib/${moduleName}.jar&quot;)
 862                 }
 863                 if (mp == null) {
 864                     mp = dir.path
 865                 } else {
 866                     mp = mp + File.pathSeparator + dir.path
 867                 }
 868             }
 869         }
 870 
 871         // in some cases like base we could end up with an empty
 872         // path... make sure we don&#39;t pass one back
 873         if (mp == null) {
 874             return null
 875         }
 876 
 877         pma += &#39;--module-path&#39;
 878         pma += mp
 879 
 880         String addm = null
 881         deps.each {String projname -&gt;
 882             def proj = project(projname)
 883             if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp; proj.buildModule) {
 884                 if (addm == null) {
 885                     addm = proj.moduleName
 886                 } else {
 887                     addm = addm + &quot;,&quot; + proj.moduleName
 888                 }
 889             }
 890         }
 891         if (addm != null) {
 892             pma += &quot;--add-modules=${addm}&quot;
 893         }
 894     }
 895 
 896     if (includeJLP) {
 897         pma += &quot;-Djava.library.path=&quot; + computeLibraryPath(true).join(File.pathSeparator)
 898     }
 899 
 900     return pma
 901 }
 902 
 903 // Return a list containing the --upgrade-module-path or --module-path
 904 // used with Javac
 905 List&lt;String&gt; computeModulePathArgs(String  pname, List&lt;String&gt; deps, boolean test) {
 906     List&lt;String&gt; mpa = HAS_JAVAFX_MODULES ? [ &#39;--upgrade-module-path&#39; ] : [ &#39;--module-path&#39; ]
 907     String mp = null
 908     deps.each { String projname -&gt;
 909         def proj = project(projname)
 910         // for a non test set of args, we don&#39;t want the current module in the list
 911         // for a test test, we do need it to update what we built
 912 
 913         if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp;
 914                 proj.buildModule &amp;&amp;
 915                 !(!test &amp;&amp; proj.name.equals(pname))) {
 916 
 917             File dir;
 918             if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 919                 dir = new File(proj.sourceSets.shims.java.outputDir, proj.ext.moduleName);
 920             } else {
 921                 dir = new File(proj.sourceSets.main.java.outputDir, proj.ext.moduleName);
 922             }
 923             if (mp == null) {
 924                 mp = dir.path
 925             } else {
 926                 mp = mp + File.pathSeparator + dir.path
 927             }
 928         }
 929     }
 930 
 931     // in some cases like base we could end up with an empty
 932     // path... make sure we don&#39;t pass one back
 933     if (mp == null) {
 934         return null
 935     }
 936 
 937     mpa += mp
 938 
 939     if (!HAS_JAVAFX_MODULES) {
 940         String addm = null
 941         deps.each {String projname -&gt;
 942             def proj = project(projname)
 943             // for a non test set of args, we don&#39;t want the current module in the list
 944             // for a test test, we do need it to update what we built
 945 
 946             if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp;
 947                     proj.buildModule &amp;&amp;
 948                     !(!test &amp;&amp; proj.name.equals(pname))) {
 949 
 950                 if (addm == null) {
 951                     addm = proj.moduleName
 952                 } else {
 953                     addm = addm + &quot;,&quot; + proj.moduleName
 954                 }
 955             }
 956         }
 957         if (addm != null) {
 958             mpa += &quot;--add-modules=${addm}&quot;
 959         }
 960     }
 961 
 962     return mpa
 963 }
 964 
 965 
 966 void writeRunArgsFile(File dest, List&lt;String&gt; libpath, List&lt;String&gt; modpath, List&lt;String&gt; modules) {
 967 
 968     dest.delete()
 969 
 970     logger.info(&quot;Creating file ${dest.path}&quot;)
 971 
 972     if (libpath != null) {
 973         dest &lt;&lt;  &quot;-Djava.library.path=\&quot;\\\n&quot;
 974         libpath.each() { e-&gt;
 975             dest &lt;&lt; &quot;  &quot;
 976             dest &lt;&lt; e
 977             dest &lt;&lt; File.pathSeparator
 978             dest &lt;&lt; &quot;\\\n&quot;
 979         }
 980         dest &lt;&lt;  &quot;  \&quot;\n&quot;
 981     }
 982 
 983     if (HAS_JAVAFX_MODULES) {
 984         modpath.each { e -&gt;
 985             dest &lt;&lt;  &quot;--patch-module=\&quot;&quot;
 986             dest &lt;&lt; e
 987             dest &lt;&lt; &quot;\&quot;\n&quot;
 988         }
 989     } else {
 990         if (modpath.size() == 1) {
 991             dest &lt;&lt;  &quot;--module-path=\&quot;&quot;
 992             dest &lt;&lt; modpath[0]
 993             dest &lt;&lt; &quot;\&quot;\n&quot;
 994         } else {
 995             dest &lt;&lt;  &quot;--module-path=\&quot;\\\n&quot;
 996             modpath.each() { e-&gt;
 997                 dest &lt;&lt; &quot;  &quot;
 998                 dest &lt;&lt; e
 999                 dest &lt;&lt; File.pathSeparator
1000                 dest &lt;&lt; &quot;\\\n&quot;
1001             }
1002             dest &lt;&lt;  &quot;  \&quot;\n&quot;
1003         }
1004     }
1005 
1006     if (modules != null) {
1007         dest &lt;&lt;  &quot;--add-modules=&quot;
1008         dest &lt;&lt; modules.join(&quot;,&quot;)
1009         dest &lt;&lt; &quot;\n&quot;
1010     }
1011 }
1012 
1013 // perform common project manipulation for modules
1014 void commonModuleSetup(Project p, List&lt;String&gt; moduleChain) {
1015 
1016     p.ext.moduleChain = moduleChain
1017 
1018     if (p.hasProperty(&quot;moduleName&quot;)) {
1019         p.ext.moduleDir = new File (p.sourceSets.main.java.outputDir, &quot;${p.moduleName}&quot;)
1020         if (p.sourceSets.hasProperty(&#39;shims&#39;)) {
1021             p.ext.moduleShimsDir = new File (p.sourceSets.shims.java.outputDir, &quot;${p.moduleName}&quot;)
1022         }
1023     }
1024 
1025     def mpa = computeModulePathArgs(p.name, moduleChain, false)
1026     if (mpa != null) {
1027         p.ext.modulePathArgs = mpa
1028     }
1029 
1030     p.ext.testModulePathArgs = computePatchModuleArgs(moduleChain, true, false)
1031     p.ext.patchModuleArgs = computePatchModuleArgs(moduleChain ,false, true)
1032     p.ext.testPatchModuleArgs = computePatchModuleArgs(moduleChain, true, true)
1033 
1034     moduleChain.each() {e -&gt;
1035         if (!e.equals(p.name)) {
1036             p.compileJava.dependsOn(project(e).classes)
1037             p.compileTestJava.dependsOn(project(e).testClasses)
1038         }
1039     }
1040 
1041     // read in any addExports file
1042     File addExportsFile = new File(p.projectDir,&quot;src/test/addExports&quot;)
1043     if (addExportsFile.exists()) {
1044         List&lt;String&gt; ae = []
1045         addExportsFile.eachLine { line -&gt;
1046             line = line.trim()
1047             if (!(line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;))) {
1048                 ae += line.split(&#39; &#39;)
1049             }
1050         }
1051         p.ext.testAddExports  = ae.flatten()
1052     }
1053 
1054     // read in the temporary addExports file EXTRAADDEXPORTS)
1055     //
1056     // These extra --add-exports will be used in two places and so we
1057     // create/modify two items:
1058     // p.testAddExports - add the extra items so they are included in test builds
1059     //
1060     // p.extraAddExports - for use in any other place where we don&#39;t automatically update
1061     //    for example any non modular, non &#39;test&#39; compile, any compile that does not
1062     //    use a module-source-path that includes the dependent modules
1063     //
1064     // Note that we don&#39;t modify the modular build (main, shims) because they use
1065     // module-info directly, and we don&#39;t want to cover up any missing items there.
1066     //
1067     if (!rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_ARGS&quot;)) {
1068         List&lt;String&gt; extraAddExportsList = []
1069         String fullae = &quot;&quot;
1070         File tmpaddExportsFile = new File(rootProject.projectDir, EXTRAADDEXPORTS)
1071         if (tmpaddExportsFile.exists()) {
1072             String nl = System.getProperty(&quot;line.separator&quot;)
1073             tmpaddExportsFile.eachLine { line -&gt;
1074                 line = line.trim()
1075                 fullae += line + nl
1076                 if (!(line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;))) {
1077                     extraAddExportsList += line.split(&#39; &#39;)
1078                 }
1079             }
1080         }
1081         // This string is used in the creation of the build/*.args files
1082         // so we preserve comments
1083         if (!extraAddExportsList.isEmpty()) {
1084             rootProject.ext.EXTRA_ADDEXPORTS_STRING = fullae
1085         }
1086         rootProject.ext.EXTRA_ADDEXPORTS_ARGS = extraAddExportsList
1087     }
1088 
1089     if (HAS_JAVAFX_MODULES) {
1090         // use this variable, because it shows we have a non empty addition
1091         if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
1092             p.ext.extraAddExports = EXTRA_ADDEXPORTS_ARGS.flatten()
1093             if (p.hasProperty(&quot;testAddExports&quot;)) {
1094                 p.testAddExports += EXTRA_ADDEXPORTS_ARGS.flatten()
1095             }
1096         }
1097     }
1098 }
1099 
1100 if (BUILD_TOOLS_DOWNLOAD_SCRIPT != &quot;&quot;) {
1101     println &quot;Include build tools download script:${BUILD_TOOLS_DOWNLOAD_SCRIPT}&quot;
1102     apply from: BUILD_TOOLS_DOWNLOAD_SCRIPT
1103 }
1104 
1105 // Now we need to define the native compilation tasks. The set of parameters to
1106 // native compilation depends on the target platform (and also to some extent what platform
1107 // you are compiling on). These settings are contained in various gradle files
1108 // such as mac.gradle and linux.gradle and armhf.gradle. Additionally, the developer
1109 // can specify COMPILE_FLAGS_FILE to be a URL or path to a different gradle file
1110 // that will contain the appropriate flags.
1111 defineProperty(&quot;COMPILE_FLAGS_FILES&quot;, COMPILE_TARGETS.split(&quot;,&quot;).collect {&quot;buildSrc/${it.trim()}.gradle&quot;}.join(&quot;,&quot;))
1112 if (COMPILE_TARGETS == &quot;all&quot;) {
1113     def tmp = []
1114     File buildSrcDir = file(&quot;buildSrc&quot;)
1115     buildSrcDir.listFiles().each { File f -&gt;
1116         if (f.isFile() &amp;&amp; f.name.endsWith(&quot;.gradle&quot;) &amp;&amp; !f.name.equals(&quot;build.gradle&quot;)) {
1117             def target = f.name.substring(0, f.name.lastIndexOf(&#39;.gradle&#39;)).toUpperCase(Locale.ROOT)
1118             apply from: f
1119             if (project.ext[&quot;${target}&quot;].canBuild) {
1120                 tmp.add(target)
1121             }
1122         }
1123     }
1124     COMPILE_FLAGS_FILES = tmp.collect { &quot;buildSrc/${it}.gradle&quot;}.join(&quot;,&quot;)
1125     COMPILE_TARGETS = tmp.collect { &quot;${it.toLowerCase()}&quot;}.join(&quot;,&quot;)
1126 } else {
1127     COMPILE_FLAGS_FILES.split(&quot;,&quot;).each {
1128         logger.info(&quot;Applying COMPILE_FLAGS_FILE &#39;$it&#39;&quot;)
1129         apply from: it
1130     }
1131 }
1132 
1133 if (COMPILE_TARGETS != &quot;&quot;) {
1134     def tmp = []
1135     COMPILE_TARGETS.split(&quot;,&quot;).each {target -&gt;
1136         if (project.ext[&quot;${target.toUpperCase(Locale.ROOT)}&quot;].canBuild) {
1137             tmp.add(target)
1138         }
1139     }
1140     COMPILE_TARGETS = tmp.collect { &quot;${it.toLowerCase()}&quot;}.join(&quot;,&quot;)
1141 }
1142 
1143 // Sanity check the expected properties all exist
1144 compileTargets { t -&gt;
1145     // Every platform must define these variables
1146     if (!project.hasProperty(t.upper)) throw new Exception(&quot;ERROR: Incorrectly configured compile flags file, missing ${t.name} property&quot;)
1147     def props = project.ext[t.upper];
1148     // TODO: we could remove libDest in favor of modLibDest
1149     [&quot;compileSwing&quot;, &quot;compileSWT&quot;, &quot;libDest&quot;].each { prop -&gt;
1150         if (!props.containsKey(prop)) throw new Exception(&quot;ERROR: Incorrectly configured compile flags file, missing ${prop} property on ${t.name}&quot;)
1151     }
1152 }
1153 
1154 // Various build flags may be set by the different target files, such as
1155 // whether to build Swing, SWT, etc. We iterate over all
1156 // compile targets and look for these settings in our properties. Note that
1157 // these properties cannot be set from the command line, but are set by
1158 // the target build files such as armv6hf.gradle or mac.gradle.
1159 ext.COMPILE_SWING = false;
1160 ext.COMPILE_SWT = false;
1161 compileTargets { t -&gt;
1162     def targetProperties = project.rootProject.ext[t.upper]
1163 
1164     if (targetProperties.compileSwing) COMPILE_SWING = true
1165     if (targetProperties.compileSWT) COMPILE_SWT = true
1166 
1167     if (!targetProperties.containsKey(&#39;compileWebnodeNative&#39;)) {
1168         // unless specified otherwise, we will compile native Webnode if IS_COMPILE_WEBKIT
1169         targetProperties.compileWebnodeNative = true
1170     }
1171 
1172     if (!targetProperties.containsKey(&#39;compileMediaNative&#39;)) {
1173         // unless specified otherwise, we will compile native Media if IS_COMPILE_MEDIA
1174         targetProperties.compileMediaNative = true
1175     }
1176 
1177     if (!targetProperties.containsKey(&#39;includeSWT&#39;)) targetProperties.includeSWT = true
1178     if (!targetProperties.containsKey(&#39;includeSwing&#39;)) targetProperties.includeSwing = true
1179     if (!targetProperties.containsKey(&#39;includeNull3d&#39;)) targetProperties.includeNull3d = true
1180     if (!targetProperties.containsKey(&#39;includeMonocle&#39;)) targetProperties.includeMonocle = false
1181     if (!targetProperties.containsKey(&#39;includeEGL&#39;)) targetProperties.includeEGL = false
1182 
1183     if (!targetProperties.containsKey(&#39;includeGTK&#39;)) targetProperties.includeGTK = IS_LINUX
1184 
1185     if (!targetProperties.containsKey(&#39;modLibDest&#39;)) targetProperties.modLibDest = targetProperties.libDest
1186 
1187     // This value is used as a prefix for various directories under ./build,
1188     // such as sdk, to allow for a common name for the hosted build
1189     // (for use when building apps) and a unique name for cross builds.
1190     if (rootProject.defaultHostTarget.equals(t.name)) {
1191         // use a simple common default for the &quot;host&quot; build
1192         targetProperties.platformPrefix=&quot;&quot;
1193     } else {
1194         // and a more complex one for cross builds
1195         targetProperties.platformPrefix=&quot;${t.name}-&quot;
1196     }
1197 }
1198 
1199 /******************************************************************************
1200  *                                                                            *
1201  *                         Build Setup Sanity Checks                          *
1202  *                                                                            *
1203  *  Here we do a variety of checks so that if the version of Java you are     *
1204  *  building with is misconfigured, or you are using the wrong version of     *
1205  *  gradle, etc you will get some kind of helpful error / warning message     *
1206  *                                                                            *
1207  *****************************************************************************/
1208 
1209 // Sanity check that we actually have a list of compile targets to execute
1210 if (COMPILE_TARGETS == null || COMPILE_TARGETS == &quot;&quot;) {
1211     throw new Exception(&quot;Unable to determine compilation platform, must specify valid COMPILE_TARGETS!&quot;)
1212 }
1213 
1214 // Verify that CONF is something useful
1215 if (CONF != &quot;Release&quot; &amp;&amp; CONF != &quot;Debug&quot; &amp;&amp; CONF != &quot;DebugNative&quot;) {
1216     logger.warn(&quot;Unknown configuration CONF=&#39;$CONF&#39;. Treating as &#39;Release&#39;&quot;)
1217 }
1218 
1219 // If the number of compile threads is less than 1 then we have a problem!
1220 if (Integer.parseInt(NUM_COMPILE_THREADS.toString()) &lt; 1) {
1221     logger.warn(&quot;NUM_COMPILE_THREADS was specified as &#39;$NUM_COMPILE_THREADS&#39; which is less than the minimum value of 1. &quot; +
1222             &quot;Building with a value of 1 instead.&quot;)
1223     NUM_COMPILE_THREADS = 1
1224 }
1225 
1226 // Check gradle version
1227 if (gradle.gradleVersion != jfxGradleVersion) {
1228     def ver = gradle.gradleVersion.split(&quot;[\\.]&quot;);
1229     def verMin = jfxGradleVersionMin.split(&quot;[\\.]&quot;);
1230     def gradleMajor = Integer.parseInt(ver[0]);
1231     def gradleMinor = Integer.parseInt(ver[1].split(&quot;[^0-9]&quot;)[0]);
1232     def gradleMajorMin = Integer.parseInt(verMin[0]);
1233     def gradleMinorMin = Integer.parseInt(verMin[1].split(&quot;[^0-9]&quot;)[0]);
1234     def err = &quot;&quot;;
1235     if (gradleMajor &lt; gradleMajorMin || (gradleMajor == gradleMajorMin &amp;&amp; gradleMinor &lt; gradleMinorMin)) {
1236         err = &quot;Gradle version too old: ${gradle.gradleVersion}; must be at least ${jfxGradleVersionMin}&quot;
1237     }
1238 
1239     if (IS_GRADLE_VERSION_CHECK &amp;&amp; err != &quot;&quot;) {
1240         fail(err);
1241     }
1242 
1243     logger.warn(&quot;*****************************************************************&quot;);
1244     logger.warn(&quot;Unsupported gradle version $gradle.gradleVersion in use.&quot;);
1245     logger.warn(&quot;Only version $jfxGradleVersion is supported. Use this version at your own risk&quot;);
1246     if ( err != &quot;&quot;) logger.warn(err);
1247     logger.warn(&quot;*****************************************************************&quot;);
1248 }
1249 
1250 // Look for stub runtime in bundled sdk, standalone sdk, or boot JDK
1251 
1252 def String cachedBundledRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/../caches/modular-sdk&quot;
1253 def String cachedStandaloneRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/../caches/sdk&quot;
1254 def String jdkStubRuntime = cygpath(&quot;$JDK_HOME&quot;)
1255 
1256 def defaultStubRuntime = &quot;&quot;
1257 if (file(cachedBundledRuntime).exists()) {
1258     defaultStubRuntime = cachedBundledRuntime
1259 } else if (file(cachedStandaloneRuntime).exists()) {
1260     defaultStubRuntime = cachedStandaloneRuntime
1261 } else if (BUILD_CLOSED) {
1262     defaultStubRuntime = cachedBundledRuntime
1263 } else {
1264     defaultStubRuntime = jdkStubRuntime
1265 }
1266 
1267 defineProperty(&quot;STUB_RUNTIME&quot;, defaultStubRuntime)
1268 
1269 if (STUB_RUNTIME.endsWith(&quot;/modular-sdk&quot;)) {
1270     def stubModulesLib = &quot;$STUB_RUNTIME/modules_libs&quot;
1271     defineProperty(&quot;MEDIA_STUB&quot;, &quot;$stubModulesLib/javafx.media&quot;)
1272     defineProperty(&quot;WEB_STUB&quot;, &quot;$stubModulesLib/javafx.web&quot;)
1273 } else {
1274     def libraryStub = IS_WINDOWS ? &quot;$STUB_RUNTIME/bin&quot; : &quot;$STUB_RUNTIME/lib&quot;
1275 
1276     defineProperty(&quot;MEDIA_STUB&quot;, libraryStub)
1277     defineProperty(&quot;WEB_STUB&quot;, libraryStub)
1278 }
1279 
1280 ext.UPDATE_STUB_CACHE = (BUILD_CLOSED &amp;&amp; STUB_RUNTIME != &quot;&quot; &amp;&amp; !file(STUB_RUNTIME).isDirectory())
1281 
1282 
1283 /******************************************************************************
1284  *                                                                            *
1285  *                      Logging of Properties and Settings                    *
1286  *                                                                            *
1287  *  Log some of the settings we&#39;ve determined. We could log more here, it     *
1288  *  doesn&#39;t really hurt.                                                      *
1289  *                                                                            *
1290  *****************************************************************************/
1291 
1292 logger.quiet(&quot;gradle.gradleVersion: $gradle.gradleVersion&quot;)
1293 logger.quiet(&quot;OS_NAME: $OS_NAME&quot;)
1294 logger.quiet(&quot;OS_ARCH: $OS_ARCH&quot;)
1295 logger.quiet(&quot;JAVA_HOME: $JAVA_HOME&quot;)
1296 logger.quiet(&quot;JDK_HOME: $JDK_HOME&quot;)
1297 logger.quiet(&quot;java.runtime.version: ${javaRuntimeVersion}&quot;)
1298 logger.quiet(&quot;java version: ${javaVersion}&quot;)
1299 logger.quiet(&quot;java build number: ${javaBuildNumber}&quot;)
1300 logger.quiet(&quot;jdk.runtime.version: ${jdkRuntimeVersion}&quot;)
1301 logger.quiet(&quot;jdk version: ${jdkVersion}&quot;)
1302 logger.quiet(&quot;jdk build number: ${jdkBuildNumber}&quot;)
1303 logger.quiet(&quot;minimum jdk version: ${jfxBuildJdkVersionMin}&quot;)
1304 logger.quiet(&quot;minimum jdk build number: ${jfxBuildJdkBuildnumMin}&quot;)
1305 
1306 if (IS_LINUX) {
1307     logger.quiet(&quot;GCC version: ${jfxBuildLinuxGccVersion}&quot;)
1308 } else if (IS_WINDOWS) {
1309     logger.quiet(&quot;MSVC version: ${jfxBuildWindowsMsvcVersion}&quot;)
1310 } else if (IS_MAC) {
1311     logger.quiet(&quot;XCODE version: ${jfxBuildMacosxXcodeVersion}&quot;)
1312 }
1313 logger.quiet(&quot;cmake version: ${jfxBuildCmakeVersion}&quot;)
1314 logger.quiet(&quot;ninja version: ${jfxBuildNinjaVersion}&quot;)
1315 logger.quiet(&quot;ant version: ${jfxBuildAntVersion}&quot;)
1316 
1317 logger.quiet(&quot;HAS_JAVAFX_MODULES: $HAS_JAVAFX_MODULES&quot;)
1318 logger.quiet(&quot;STUB_RUNTIME: $STUB_RUNTIME&quot;)
1319 logger.quiet(&quot;CONF: $CONF&quot;)
1320 logger.quiet(&quot;NUM_COMPILE_THREADS: $NUM_COMPILE_THREADS&quot;)
1321 logger.quiet(&quot;COMPILE_TARGETS: $COMPILE_TARGETS&quot;)
1322 logger.quiet(&quot;COMPILE_FLAGS_FILES: $COMPILE_FLAGS_FILES&quot;)
1323 logger.quiet(&quot;HUDSON_JOB_NAME: $HUDSON_JOB_NAME&quot;)
1324 logger.quiet(&quot;HUDSON_BUILD_NUMBER: $HUDSON_BUILD_NUMBER&quot;)
1325 logger.quiet(&quot;PROMOTED_BUILD_NUMBER: $PROMOTED_BUILD_NUMBER&quot;)
1326 logger.quiet(&quot;PRODUCT_NAME: $PRODUCT_NAME&quot;)
1327 logger.quiet(&quot;RELEASE_VERSION: $RELEASE_VERSION&quot;)
1328 logger.quiet(&quot;RELEASE_SUFFIX: $RELEASE_SUFFIX&quot;)
1329 logger.quiet(&quot;RELEASE_VERSION_SHORT: $RELEASE_VERSION_SHORT&quot;)
1330 logger.quiet(&quot;RELEASE_VERSION_LONG: $RELEASE_VERSION_LONG&quot;)
1331 logger.quiet(&quot;RELEASE_VERSION_PADDED: $RELEASE_VERSION_PADDED&quot;)
1332 logger.quiet(&quot;MAVEN_VERSION: $MAVEN_VERSION&quot;)
1333 logger.quiet(&quot;UPDATE_STUB_CACHE: $UPDATE_STUB_CACHE&quot;)
1334 
1335 /******************************************************************************
1336  *                                                                            *
1337  *                Definition of Native Code Compilation Tasks                 *
1338  *                                                                            *
1339  *    - CCTask compiles native code. Specifically it will compile .m, .c,     *
1340  *      .cpp, or .cc files. It uses the headers provided by running           *
1341  *      &#39;javac -h&#39; plus additional platform specific headers. It will         *
1342  *      compile into .obj files.                                              *
1343  *    - LinkTask will perform native linking and create the .dll / .so /      *
1344  *      .dylib as necessary.                                                  *
1345  *                                                                            *
1346  *****************************************************************************/
1347 
1348 // Save a reference to the buildSrc.jar file because we need it for actually
1349 // compiling things, not just for the sake of this build script
1350 // (such as generating the JSL files, etc)
1351 ext.BUILD_SRC = rootProject.files(&quot;buildSrc/build/libs/buildSrc.jar&quot;)
1352 
1353 /**
1354  * Convenience method for creating cc, link, and &quot;native&quot; tasks in the given project. These
1355  * tasks are parameterized by name, so that we can produce, for example, ccGlass, etc
1356  * named tasks.
1357  *
1358  * @param project The project to add tasks to
1359  * @param name The name of the project, such as &quot;prism-common&quot;. This name is used
1360  *        in the name of the generated task, such as ccPrismCommon, and also
1361  *        in the name of the final library, such as libprism-common.dylib.
1362  */
1363 void addNative(Project project, String name) {
1364     // TODO if we want to handle 32/64 bit windows in the same build,
1365     // Then we will need to modify the win compile target to be win32 or win64
1366     def capitalName = name.split(&quot;-&quot;).collect{it.capitalize()}.join()
1367     def nativeTask = project.task(&quot;native$capitalName&quot;, group: &quot;Build&quot;) {
1368         description = &quot;Generates JNI headers, compiles, and builds native dynamic library for $name for all compile targets&quot;
1369     }
1370     def cleanTask = project.task(&quot;cleanNative$capitalName&quot;, type: Delete, group: &quot;Build&quot;) {
1371         description = &quot;Clean native objects for $name&quot;
1372     }
1373     if (project.hasProperty(&quot;nativeAllTask&quot;)) project.nativeAllTask.dependsOn nativeTask
1374     project.assemble.dependsOn(nativeTask)
1375     if (project.hasProperty(&quot;cleanNativeAllTask&quot;)) project.cleanNativeAllTask.dependsOn cleanTask
1376 
1377     // Each of the different compile targets will be placed in a sub directory
1378     // of these root dirs, with the name of the dir being the name of the target
1379     def nativeRootDir = project.file(&quot;$project.buildDir/native/$name&quot;)
1380     def libRootDir = project.file(&quot;$project.buildDir/libs/$name&quot;)
1381     // For each compile target, create a cc / link pair
1382     compileTargets { t -&gt;
1383         def targetProperties = project.rootProject.ext[t.upper]
1384         def library = targetProperties.library
1385         def properties = targetProperties.get(name)
1386         def nativeDir = file(&quot;$nativeRootDir/${t.name}&quot;)
1387         def headerDir = file(&quot;${project.buildDir}/gensrc/headers/${project.moduleName}&quot;)
1388 
1389         // If there is not a library clause in the properties, assume it is not wanted
1390         if (!targetProperties.containsKey(name)) {
1391             println(&quot;Ignoring native library ${name}. Not defined in ${t.name} project properties&quot;);
1392             return
1393         }
1394 
1395         // check for the property disable${name} = true
1396         def String disableKey = &quot;disable${name}&quot;
1397         def boolean disabled = targetProperties.containsKey(disableKey) ? targetProperties.get(disableKey) : false
1398         if (disabled) {
1399             println(&quot;Native library ${name} disabled in ${t.name} project properties&quot;);
1400             return
1401         }
1402 
1403         def variants = properties.containsKey(&quot;variants&quot;) ? properties.variants : [&quot;&quot;];
1404         variants.each { variant -&gt;
1405             def variantProperties = variant == &quot;&quot; ? properties : properties.get(variant)
1406             def capitalVariant = variant.capitalize()
1407             def ccOutput = variant == &quot;&quot; ? nativeDir : file(&quot;$nativeDir/$variant&quot;)
1408             def ccTask = project.task(&quot;cc${t.capital}$capitalName$capitalVariant&quot;, type: CCTask, group: &quot;Build&quot;) {
1409                 description = &quot;Compiles native sources for ${name} for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
1410                 matches = &quot;.*\\.c|.*\\.cpp|.*\\.m|.*\\.cc&quot;
1411                 headers = headerDir
1412                 output(ccOutput)
1413                 params.addAll(variantProperties.ccFlags)
1414                 compiler = variantProperties.compiler
1415                 source(variantProperties.nativeSource)
1416                 cleanTask.delete ccOutput
1417             }
1418             def linkTask = project.task(&quot;link${t.capital}$capitalName$capitalVariant&quot;, type: LinkTask, dependsOn: ccTask, group: &quot;Build&quot;) {
1419                 description = &quot;Creates native dynamic library for $name for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
1420                 objectDir = ccOutput
1421                 linkParams.addAll(variantProperties.linkFlags)
1422                 lib = file(&quot;$libRootDir/${t.name}/${variant == &#39;&#39; ? library(properties.lib) : library(variantProperties.lib)}&quot;)
1423                 linker = variantProperties.linker
1424                 cleanTask.delete &quot;$libRootDir/${t.name}&quot;
1425             }
1426             nativeTask.dependsOn(linkTask)
1427             if (IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;) {
1428                 def rcTask = project.task(&quot;rc$capitalName$capitalVariant&quot;, type: CompileResourceTask, group: &quot;Build&quot;) {
1429                     description = &quot;Compiles native sources for $name&quot;
1430                     matches = &quot;.*\\.rc&quot;
1431                     compiler = variantProperties.rcCompiler
1432                     source(variantProperties.rcSource)
1433                     if (variantProperties.rcFlags) {
1434                         rcParams.addAll(variantProperties.rcFlags)
1435                     }
1436                     output(ccOutput)
1437                 }
1438                 linkTask.dependsOn rcTask;
1439             }
1440         }
1441 
1442         def useLipo = targetProperties.containsKey(&#39;useLipo&#39;) ? targetProperties.useLipo : false
1443         if (useLipo) {
1444             def lipoTask = project.task(&quot;lipo${t.capital}$capitalName&quot;, type: LipoTask, group: &quot;Build&quot;) {
1445                 description = &quot;Creates native fat library for $name for ${t.name}&quot;
1446                 libDir = file(&quot;$libRootDir/${t.name}&quot;)
1447                 lib = file(&quot;$libRootDir/${t.name}/${library(properties.lib)}&quot;)
1448             }
1449             nativeTask.dependsOn(lipoTask)
1450         }
1451     }
1452 }
1453 
1454 void addJSL(Project project, String name, String pkg, List&lt;String&gt; addExports, Closure compile) {
1455     def lowerName = name.toLowerCase()
1456 
1457     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
1458     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
1459     def compileCompilers = project.task(&quot;compile${name}Compilers&quot;,
1460             type: JavaCompile,
1461             dependsOn: project.compileJava) {
1462         description = &quot;Compile the $name JSL Compilers&quot;
1463 
1464         classpath =
1465                project.files(project.sourceSets.jslc.java.outputDir) +
1466                project.configurations.antlr
1467         source = [project.file(&quot;src/main/jsl-$lowerName&quot;)]
1468         destinationDir = project.file(&quot;$project.buildDir/classes/jsl-compilers/$lowerName&quot;)
1469 
1470         options.compilerArgs.addAll([
1471             &quot;-implicit:none&quot;,
1472             &quot;--module-path&quot;, modulePath,
1473             &quot;--add-modules=javafx.graphics&quot;
1474             ])
1475         if (addExports != null) {
1476             options.compilerArgs.addAll(addExports)
1477         }
1478     }
1479 
1480     def generateShaders = project.task(&quot;generate${name}Shaders&quot;,
1481             dependsOn: compileCompilers) {
1482         description = &quot;Generate $name shaders from JSL&quot;
1483         def sourceDir = project.file(&quot;src/main/jsl-$lowerName&quot;)
1484         def destinationDir = project.file(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;)
1485         inputs.dir sourceDir
1486         outputs.dir destinationDir
1487         doLast {
1488             compile(sourceDir, destinationDir)
1489         }
1490     }
1491 
1492     def compileHLSLShaders = project.task(&quot;compile${name}HLSLShaders&quot;,
1493             dependsOn: generateShaders,
1494             type: CompileHLSLTask) {
1495         enabled = IS_WINDOWS
1496         description = &quot;Compile $name HLSL files into .obj files&quot;
1497         matches = &quot;.*\\.hlsl&quot;
1498         output project.file(&quot;$project.buildDir/hlsl/$name/$pkg&quot;)
1499         source project.file(&quot;$project.buildDir/gensrc/jsl-$lowerName/$pkg&quot;)
1500     }
1501 
1502     def processShaders = project.task(&quot;process${name}Shaders&quot;,
1503             dependsOn: [generateShaders, compileHLSLShaders],
1504             type: Copy,
1505             description: &quot;Copy hlsl / frag shaders to build/resources/jsl-$lowerName&quot;) {
1506         from(&quot;$project.buildDir/hlsl/$name&quot;) {
1507             include &quot;**/*.obj&quot;
1508         }
1509         from(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;) {
1510             include(&quot;**/*.frag&quot;)
1511         }
1512         into project.moduleDir
1513     }
1514 
1515     project.processShaders.dependsOn(processShaders)
1516     project.sourceSets.shaders.output.dir(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;, builtBy: processShaders )
1517 
1518     def processShimsShaders = project.task(&quot;process${name}ShimsShaders&quot;,
1519             dependsOn: [generateShaders, compileHLSLShaders],
1520             type: Copy,
1521             description: &quot;Copy hlsl / frag shaders to shims&quot;) {
1522         from(&quot;$project.buildDir/hlsl/$name&quot;) {
1523             include &quot;**/*.obj&quot;
1524         }
1525         from(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;) {
1526             include(&quot;**/*.frag&quot;)
1527         }
1528         into project.moduleShimsDir
1529     }
1530 
1531     project.processShimsShaders.dependsOn(processShimsShaders)
1532 
1533 }
1534 
1535 void addMavenPublication(Project project, List&lt;String&gt; projectDependencies) {
1536     project.apply plugin: &#39;maven-publish&#39;
1537 
1538     project.group = MAVEN_GROUP_ID
1539     project.version = MAVEN_VERSION
1540 
1541     if (project.name == &#39;base&#39;) {
1542         project.publishing {
1543             publications {
1544                 javafx(MavenPublication) {
1545                     artifactId = &#39;javafx&#39;
1546                     artifacts = []
1547                 }
1548             }
1549         }
1550     }
1551 
1552     gradle.taskGraph.whenReady { g -&gt;
1553         project.tasks.findAll { it.name == &#39;generatePomFileForJavafxPublication&#39;}.each { it -&gt;
1554             it.doLast {
1555                 copy {
1556                     into project.file(&quot;${project.buildDir}/publications/javafx&quot;)
1557                     from file(&quot;${rootProject.projectDir}/javafx.pom&quot;)
1558                     rename &quot;javafx.pom&quot;, &quot;pom-default.xml&quot;
1559                     filter { line -&gt;
1560                         line.replaceAll(&quot;@VERSION@&quot;, MAVEN_VERSION)
1561                     }
1562                 }
1563             }
1564         }
1565     }
1566 
1567     project.publishing {
1568         repositories {
1569             maven {
1570                 def repositoryUrl = project.hasProperty(&#39;repositoryUrl&#39;) ? project.getProperty(&#39;repositoryUrl&#39;) : &quot;&quot;
1571                 def repositoryUsername = project.hasProperty(&#39;repositoryUsername&#39;) ? project.getProperty(&#39;repositoryUsername&#39;) : &quot;&quot;
1572                 def repositoryPassword = project.hasProperty(&#39;repositoryPassword&#39;) ? project.getProperty(&#39;repositoryPassword&#39;) : &quot;&quot;
1573                 url repositoryUrl
1574                 credentials {
1575                    username repositoryUsername
1576                    password repositoryPassword
1577                 }
1578             }
1579         }
1580     }
1581 
1582     compileTargets { t -&gt;
1583         project.publishing {
1584             publications {
1585                 maven(MavenPublication) {
1586                     artifactId = &quot;javafx-${project.name}&quot;
1587 
1588                     afterEvaluate {
1589                         artifact project.tasks.&quot;moduleEmptyPublicationJar$t.capital&quot;
1590                         artifact project.tasks.&quot;modularPublicationJar$t.capital&quot; {
1591                             classifier &quot;$t.name&quot;
1592                         }
1593                     }
1594 
1595                     pom.withXml {
1596                         Node parent = asNode().appendNode(&quot;parent&quot;)
1597                         parent.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1598                         parent.appendNode(&quot;artifactId&quot;, &quot;javafx&quot;)
1599                         parent.appendNode(&quot;version&quot;, MAVEN_VERSION)
1600 
1601                         Node dependencies = asNode().appendNode(&quot;dependencies&quot;)
1602 
1603                         Node projectDependencyPlatform = dependencies.appendNode(&quot;dependency&quot;)
1604                         projectDependencyPlatform.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1605                         projectDependencyPlatform.appendNode(&quot;artifactId&quot;, &quot;javafx-${project.name}&quot;)
1606                         projectDependencyPlatform.appendNode(&quot;version&quot;, MAVEN_VERSION)
1607                         projectDependencyPlatform.appendNode(&quot;classifier&quot;, &quot;\${javafx.platform}&quot;)
1608 
1609                         if (!projectDependencies.empty) {
1610                             projectDependencies.each { dep -&gt;
1611                                 Node projectDependency = dependencies.appendNode(&quot;dependency&quot;)
1612                                 projectDependency.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1613                                 projectDependency.appendNode(&quot;artifactId&quot;, &quot;javafx-$dep&quot;)
1614                                 projectDependency.appendNode(&quot;version&quot;, MAVEN_VERSION)
1615                            }
1616                         }
1617                     }
1618                 }
1619             }
1620 
1621         }
1622     }
1623 }
1624 
1625 /**
1626  * Verifies that all of the *.java files in a source tree have the
1627  * correct package name. If not, fail the build.
1628  *
1629  * @param sourceRoot the root of the source tree to check
1630  * @param hasModuleName true if the sources under sourceRoot are being
1631  * compiled as modules, with the immediate child directories being the
1632  * root(s) of the named modules being compiled. In this case the package
1633  * root is one directory below the sourceRoot.
1634  */
1635 void validatePackages(File sourceRoot, boolean hasModuleName) {
1636     if (!sourceRoot.isDirectory()) {
1637         return;
1638     }
1639     def err = false;
1640     String sourceString = sourceRoot.toString().replace(&quot;\\&quot;, &quot;/&quot;)
1641     def startPos = sourceString.length() + 1
1642     logger.info(&quot;validating packages for ${sourceRoot}&quot;)
1643     def inputFiles = fileTree(dir: sourceRoot, include: &quot;**/*.java&quot;)
1644     inputFiles.each { file -&gt;
1645         def packageRoot = file.toString().replace(&quot;\\&quot;, &quot;/&quot;).substring(startPos)
1646         if (hasModuleName) {
1647             packageRoot = packageRoot.substring(packageRoot.indexOf(&quot;/&quot;) + 1)
1648         }
1649         def endPos = packageRoot.lastIndexOf(&quot;/&quot;)
1650         def pkgEx = endPos &gt; -1 ?  packageRoot.substring(0, endPos).replace(&quot;/&quot;, &quot;.&quot;) : &quot;&quot;
1651         def pkg = &quot;&quot;
1652         file.withReader { reader -&gt;
1653             def line
1654             while ((line = reader.readLine()) != null) {
1655                 def words = line.trim().split(&quot;[ ;]+&quot;)
1656                 if (words.length &gt; 1 &amp;&amp; words[0] == &quot;package&quot;) {
1657                     pkg = words[1]
1658                     break;
1659                 }
1660             }
1661         }
1662         if (pkg != pkgEx) {
1663             err = true
1664             println &quot;*** ERROR: File location &lt;${file}&gt; does not match package name &lt;${pkg}&gt;&quot;
1665         }
1666     }
1667     if (err) {
1668         fail(&quot;Package validation failed&quot;)
1669     }
1670 }
1671 
1672 /**
1673  * Add a task to the given project to validate that the package names
1674  * of all java files in the given source sets have the correct package
1675  * name. If not, fail the build.
1676  */
1677 void addValidateSourceSets(Project project,
1678                            Collection&lt;SourceSet&gt; sourceSets,
1679                            Collection&lt;SourceSet&gt; modSourceSets) {
1680     def validateSourceSetsTask = project.task(&quot;validateSourceSets&quot;) {
1681         doLast {
1682             // Accumulate the root directories from all sourceSets.
1683             // We use a Set to elide duplicates (the shims sourceset
1684             // will include the dirs from the main sourceset)
1685             Set&lt;File&gt; sourceRoots = []
1686             sourceSets.each { srcSet -&gt;
1687                 srcSet.java.srcDirs.each { rootDir -&gt;
1688                     sourceRoots += rootDir
1689                 }
1690             }
1691             sourceRoots.each { rootDir -&gt;
1692                 validatePackages(rootDir, false)
1693             }
1694 
1695             Set&lt;File&gt; modSourceRoots = []
1696             modSourceSets.each { srcSet -&gt;
1697                 srcSet.java.srcDirs.each { rootDir -&gt;
1698                     modSourceRoots += rootDir
1699                 }
1700             }
1701             modSourceRoots.each { rootDir -&gt;
1702                 validatePackages(rootDir, true)
1703             }
1704         }
1705     }
1706 
1707     // Run this for all projects when compiling the test sources
1708     // (i.e., when running &quot;gradle test&quot;)
1709     project.compileTestJava.dependsOn(validateSourceSetsTask)
1710 }
1711 
1712 void addValidateSourceSets(Project project, Collection&lt;SourceSet&gt; sourceSets) {
1713     addValidateSourceSets(project, sourceSets, []);
1714 }
1715 
1716 
1717 /**
1718  * Parses a JDK version string. The string must be in one of the following
1719  * two formats:
1720  *
1721  *     major.minor.subminor
1722  * or
1723  *     major.minor.subminor_update
1724  *
1725  * In both cases a list of 4 integers is returned, with element 3 set to
1726  * 0 in the former case.
1727  */
1728 List parseJdkVersion(String version) {
1729     def arr = version.split(&quot;[_\\.]&quot;);
1730     def intArr = [];
1731     arr.each { s -&gt; intArr += Integer.parseInt(s); }
1732     while (intArr.size() &lt; 4) intArr += 0;
1733     return intArr;
1734 }
1735 
1736 /**
1737  * Returns -1, 0, or 1 depending on whether JDK version &quot;a&quot; is less than,
1738  * equal to, or grater than version &quot;b&quot;.
1739  */
1740 int compareJdkVersion(String a, String b) {
1741     def aIntArr = parseJdkVersion(a);
1742     def bIntArr = parseJdkVersion(b);
1743 
1744     for (int i = 0; i &lt; 4; i++) {
1745         if (aIntArr[i] &lt; bIntArr[i]) return -1;
1746         if (aIntArr[i] &gt; bIntArr[i]) return  1;
1747     }
1748     return 0;
1749 }
1750 
1751 // Task to verify the minimum level of Java needed to build JavaFX
1752 task verifyJava() {
1753     doLast {
1754         def status = compareJdkVersion(jdkVersion, jfxBuildJdkVersionMin);
1755         if (status &lt; 0) {
1756             fail(&quot;java version mismatch: JDK version (${jdkVersion}) &lt; minimum version (${jfxBuildJdkVersionMin})&quot;)
1757         } else if (status == 0) {
1758             def buildNum = Integer.parseInt(jdkBuildNumber)
1759             def minBuildNum = Integer.parseInt(jfxBuildJdkBuildnumMin)
1760             if (buildNum != 0 &amp;&amp; buildNum &lt; minBuildNum) {
1761                 fail(&quot;JDK build number ($buildNum) &lt; minimum build number ($minBuildNum)&quot;)
1762             }
1763         }
1764     }
1765 }
1766 
1767 task updateCacheIfNeeded() {
1768     // an empty task we can add to as needed for UPDATE_STUB_CACHE
1769 }
1770 
1771 task createTestArgfiles {
1772     // an empty task we can add to as needed
1773 }
1774 
1775 
1776 /*****************************************************************************
1777 *        Project definitions (dependencies, etc)                             *
1778 *****************************************************************************/
1779 
1780 void addJCov(p, test) {
1781     test.doFirst {
1782         def jcovJVMArgument =
1783                 &quot;include=javafx,&quot; +
1784                 &quot;include=com.sun.javafx,&quot; +
1785                 &quot;include=com.sun.glass,&quot; +
1786                 &quot;include=com.sun.openpisces,&quot; +
1787                 &quot;include=com.sun.pisces,&quot; +
1788                 &quot;include=com.sun.prism,&quot; +
1789                 &quot;include=com.sun.scenario,&quot; +
1790                 &quot;include=com.sun.webkit,&quot; +
1791                 &quot;exclude=com,&quot; +
1792                 &quot;exclude=java,&quot; +
1793                 &quot;exclude=javax,&quot; +
1794                 &quot;exclude=\&quot;**.test\&quot;,&quot; +
1795                 &quot;exclude=\&quot;**.*Test\&quot;,&quot; +
1796                 &quot;file=build/reports/jcov/report.xml,&quot; +
1797                 &quot;merge=merge&quot;;
1798         test.jvmArgs(&quot;-javaagent:${p.configurations.testCompile.files.find { it.name.startsWith(&#39;jcov&#39;) }}=$jcovJVMArgument&quot;);
1799         p.mkdir p.file(&quot;build/reports/jcov&quot;)
1800     }
1801     test.doLast {
1802         def reportFile = p.file(&quot;build/reports/jcov/report.xml&quot;)
1803         if (reportFile.exists()) {
1804             p.javaexec {
1805                 workingDir = p.file(&quot;build/reports/jcov&quot;)
1806                 classpath = p.files(p.configurations.testCompile.files.find { it.name.startsWith(&#39;jcov&#39;) })
1807                 main = &quot;com.sun.tdk.jcov.Helper&quot;
1808                 args = [
1809                         &quot;RepGen&quot;,
1810                         &quot;-exclude&quot;, &quot;\&quot;**.test\&quot;&quot;,
1811                         &quot;-exclude&quot;, &quot;\&quot;**.*Test\&quot;&quot;,
1812                         &quot;-output&quot;, &quot;.&quot;,
1813                         &quot;-source&quot;, p.sourceSets.main.java.srcDirs.collect{p.file(it)}.join(&quot;:&quot;),
1814                         &quot;report.xml&quot;
1815                 ]
1816             }
1817         }
1818     }
1819 }
1820 
1821 allprojects {
1822 
1823     // Setup the repositories that we&#39;ll download libraries from.
1824     // By default we use Maven Central for most things. The custom &quot;ivy&quot;
1825     // repo is for downloading SWT. The way it works is to setup the
1826     // download URL such that it will resolve to the actual jar file to
1827     // download. See SWT_FILE_NAME for the name of the jar that will be
1828     // used as the &quot;artifact&quot; in the pattern below.
1829     // If JFX_DEPS_URL is set, then that overrides the default
1830     // repositories. This allows the dependencies to be cached locally.
1831 
1832     if (JFX_DEPS_URL != &quot;&quot;) {
1833         repositories {
1834             ivy {
1835                 url JFX_DEPS_URL
1836                 metadataSources {
1837                     artifact()
1838                 }
1839                 patternLayout {
1840                     artifact &quot;[artifact]-[revision](-[classifier]).[ext]&quot;
1841                     artifact &quot;[artifact].[ext]&quot;
1842                 }
1843             }
1844         }
1845     }
1846 
1847     if (JFX_DEPS_URL == &quot;&quot;) {
1848         repositories {
1849             mavenCentral()
1850             ivy {
1851                 url &quot;https://download.eclipse.org/eclipse/updates/4.6/R-4.6.3-201703010400/plugins/&quot;
1852                 metadataSources {
1853                     artifact()
1854                 }
1855                 patternLayout {
1856                     artifact &quot;[artifact].[ext]&quot;
1857                 }
1858             }
1859         }
1860     }
1861 
1862     if (JFX_DEPS_URL == &quot;&quot; &amp;&amp; IS_BUILD_LIBAV_STUBS) {
1863         repositories {
1864             ivy {
1865                 url libAVRepositoryURL
1866                 metadataSources {
1867                     artifact()
1868                 }
1869                 patternLayout {
1870                     artifact &quot;[artifact].[ext]&quot;
1871                 }
1872             }
1873             ivy {
1874                 url FFmpegRepositoryURL
1875                 metadataSources {
1876                     artifact()
1877                 }
1878                 patternLayout {
1879                     artifact &quot;[artifact].[ext]&quot;
1880                 }
1881             }
1882         }
1883     }
1884 
1885     // We want to configure all projects as java projects and use the same compile settings
1886     // etc, except for the root project which we just want to ignore (and for now media)
1887     if (project == rootProject) {
1888        return
1889     }
1890     if (project.path.startsWith(&quot;:apps&quot;)) {
1891         // Lets handle the apps tree differently, as it is a collection of ant builds,
1892         // and the ant importer collides with the &#39;apply plugin:java&#39;
1893         return
1894     }
1895 
1896     // All of our projects are java projects
1897 
1898     apply plugin: &quot;java&quot;
1899     sourceCompatibility = 11
1900 
1901     // By default all of our projects require junit for testing so we can just
1902     // setup this dependency here.
1903     dependencies {
1904         testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
1905         if (BUILD_CLOSED &amp;&amp; DO_JCOV)  {
1906             testCompile name: &quot;jcov&quot;
1907         }
1908     }
1909 
1910     compileJava.dependsOn verifyJava
1911 
1912     // At the moment the ASM library shipped with Gradle that is used to
1913     // discover the different test classes fails on Java 8, so in order
1914     // to have sourceCompatibility set to 1.8 I have to also turn scanForClasses off
1915     // and manually specify the includes / excludes. At the moment we use
1916     // Java 7 but when we switch to 8 this will be needed, and probably again when
1917     // we start building with Java 9.
1918     test {
1919         executable = JAVA;
1920         enableAssertions = true;
1921         testLogging.exceptionFormat = &quot;full&quot;;
1922         scanForTestClasses = false;
1923         include(&quot;**/*Test.*&quot;);
1924         if (BUILD_CLOSED &amp;&amp; DO_JCOV) {
1925             addJCov(project, test)
1926         }
1927 
1928         if (IS_HEADLESS_TEST) {
1929             systemProperty &#39;glass.platform&#39;, &#39;Monocle&#39;
1930             systemProperty &#39;monocle.platform&#39;, &#39;Headless&#39;
1931             systemProperty &#39;prism.order&#39;, &#39;sw&#39;
1932             systemProperty &#39;com.sun.javafx.gestures.zoom&#39;, &#39;true&#39;
1933             systemProperty &#39;com.sun.javafx.gestures.rotate&#39;, &#39;true&#39;
1934             systemProperty &#39;com.sun.javafx.gestures.scroll&#39;, &#39;true&#39;
1935         }
1936 
1937         systemProperty &#39;unstable.test&#39;, IS_UNSTABLE_TEST
1938     }
1939 
1940     compileTestJava {
1941     }
1942 }
1943 
1944 // These strings define the module-source-path to be used in compilation.
1945 // They need to contain the full paths to the sources and the * will be
1946 // used to infer the module name that is used.
1947 project.ext.defaultModuleSourcePath =
1948     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;) +
1949         File.pathSeparator  +
1950     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1951 
1952 // graphics pass one
1953 project.ext.defaultModuleSourcePath_GraphicsOne =
1954     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;) +
1955         File.pathSeparator  +
1956     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1957 
1958 // web pass one
1959 project.ext.defaultModuleSourcePath_WebOne =
1960     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;)
1961 
1962 // Compiling the test shim files too.
1963 project.ext.defaultModuleSourcePathShim =
1964     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/{main,shims}/java&#39;) +
1965         File.pathSeparator  +
1966     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1967 
1968 // The &quot;base&quot; project is our first module and the most basic one required for
1969 // all other modules. It is useful even for non-GUI applications.
1970 project(&quot;:base&quot;) {
1971     project.ext.buildModule = true
1972     project.ext.includeSources = true
1973     project.ext.moduleRuntime = true
1974     project.ext.moduleName = &quot;javafx.base&quot;
1975 
1976     sourceSets {
1977         main
1978         shims {
1979             java {
1980                 compileClasspath += sourceSets.main.output
1981                 runtimeClasspath += sourceSets.main.output
1982             }
1983         }
1984         test {
1985             java {
1986                 compileClasspath += sourceSets.shims.output
1987                 runtimeClasspath += sourceSets.shims.output
1988             }
1989         }
1990     }
1991 
1992     dependencies {
1993         testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
1994         testCompile sourceSets.main.output
1995         testCompile sourceSets.shims.output
1996     }
1997 
1998     commonModuleSetup(project, [ &#39;base&#39; ])
1999 
2000     project.ext.moduleSourcePath = defaultModuleSourcePath
2001     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2002 
2003     // We need to take the VersionInfo.java file and replace the various
2004     // properties within it
2005     def replacements = [
2006         &quot;BUILD_TIMESTAMP&quot;: BUILD_TIMESTAMP,
2007         &quot;HUDSON_JOB_NAME&quot;: HUDSON_JOB_NAME,
2008         &quot;HUDSON_BUILD_NUMBER&quot;: HUDSON_BUILD_NUMBER,
2009         &quot;PROMOTED_BUILD_NUMBER&quot;: PROMOTED_BUILD_NUMBER,
2010         &quot;PRODUCT_NAME&quot;: PRODUCT_NAME,
2011         &quot;RELEASE_VERSION&quot;: RELEASE_VERSION,
2012         &quot;RELEASE_SUFFIX&quot;: RELEASE_SUFFIX];
2013     task processVersionInfo(type: Copy, description: &quot;Replace params in VersionInfo and copy file to destination&quot;) {
2014         doFirst { mkdir &quot;$buildDir/gensrc/java&quot; }
2015         from &quot;src/main/version-info&quot;
2016         into &quot;$buildDir/gensrc/java/com/sun/javafx/runtime&quot;
2017         filter {line-&gt;
2018             replacements.each() {k, v -&gt;
2019                 line = line.replace(&quot;@$k@&quot;, v.toString());
2020             }
2021             line
2022         }
2023     }
2024 
2025     // Make sure to include $buildDir/gensrc/java that we previously created.
2026     // We DO NOT want to include src/main/version-info
2027 
2028     sourceSets.main.java.srcDirs += &quot;$buildDir/gensrc/java&quot;
2029 
2030     compileJava.dependsOn processVersionInfo
2031     addMavenPublication(project, [])
2032 
2033     addValidateSourceSets(project, sourceSets)
2034 }
2035 
2036 // The graphics module is needed for any graphical JavaFX application. It requires
2037 // the base module and includes the scene graph, layout, css, prism, windowing, etc.
2038 // This is a fairly complicated module. There are many different types of native components
2039 // that all need to be compiled.
2040 project(&quot;:graphics&quot;) {
2041 
2042     project.ext.buildModule = true
2043     project.ext.includeSources = true
2044     project.ext.moduleRuntime = true
2045     project.ext.moduleName = &quot;javafx.graphics&quot;
2046     project.ext.mavenPublish = true
2047 
2048     getConfigurations().create(&quot;antlr&quot;);
2049 
2050     sourceSets {
2051         jslc   // JSLC gramar subset
2052         main
2053         shims {
2054             java {
2055                 compileClasspath += sourceSets.main.output
2056                 runtimeClasspath += sourceSets.main.output
2057             }
2058         }
2059         shaders // generated shaders (prism &amp; decora)
2060         test {
2061             java {
2062                 compileClasspath += sourceSets.shims.output
2063                 runtimeClasspath += sourceSets.shims.output
2064             }
2065         }
2066         stub
2067     }
2068 
2069     dependencies {
2070         stubCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
2071 
2072         antlr group: &quot;org.antlr&quot;, name: &quot;antlr4&quot;, version: &quot;4.7.2&quot;, classifier: &quot;complete&quot;
2073         compile project(&#39;:base&#39;)
2074     }
2075 
2076     project.ext.moduleSourcePath = defaultModuleSourcePath_GraphicsOne
2077     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2078 
2079     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39; ])
2080 
2081     List&lt;String&gt; decoraAddExports = [
2082             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect=ALL-UNNAMED&#39;,
2083             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect.light=ALL-UNNAMED&#39;,
2084             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect.impl.state=ALL-UNNAMED&#39;
2085             ]
2086     /*
2087     Graphics compilation is &quot;complicated&quot; by the generated shaders.
2088 
2089     We have two shader groups - Decora and Prism.
2090 
2091     The shader groups each will generate a custom compiler that
2092     then genarates the shader code. These compilers rely on the JSLC
2093     gramar parser which is antlr generated and compile separately.
2094 
2095     The decora compiler relies on compileJava - which is sourceSet.main.java
2096     It also accesses module private packages, so will need add-exports
2097 
2098     Once the shader java code is generated, we can compileFullJava
2099 
2100     After that, we can generate the required native header and then build the native code
2101     */
2102 
2103     project.task(&quot;processShaders&quot;) {
2104         // an empty task to hang the prism and decora shaders on
2105     }
2106 
2107     project.task(&quot;processShimsShaders&quot;) {
2108         // an empty task to hang the prism and decora shaders on
2109     }
2110 
2111     compileShimsJava.dependsOn(&quot;processShimsShaders&quot;)
2112 
2113     // Generate the JSLC support grammar
2114     project.task(&quot;generateGrammarSource&quot;, type: JavaExec) {
2115         // use antlr to generate our grammar.
2116         // note: the antlr plugin creates some issues with the other compiles
2117         // so we will do this by hand
2118 
2119         File wd = file(project.projectDir.path + &quot;/src/jslc/antlr&quot;)
2120         File outDir = file(&quot;$buildDir/gensrc/antlr&quot;)
2121         def inJSL = &quot;com/sun/scenario/effect/compiler/JSL.g4&quot;
2122         if (IS_WINDOWS) {
2123             // antlr needs backslashes on Windows
2124             inJSL = inJSL.replace(&quot;/&quot;, &quot;\\&quot;)
2125         }
2126 
2127         executable = JAVA
2128         classpath = project.configurations.antlr
2129         workingDir = wd
2130         main = &quot;org.antlr.v4.Tool&quot;
2131 
2132         args = [
2133             &quot;-o&quot;,
2134             outDir.toString(),
2135             &quot;-package&quot;,
2136             &quot;com.sun.scenario.effect.compiler&quot;,
2137             &quot;-visitor&quot;,
2138             inJSL ]
2139 
2140         inputs.dir wd
2141         outputs.dir outDir
2142     }
2143     sourceSets.jslc.java.srcDirs += &quot;$buildDir/gensrc/antlr&quot;
2144 
2145     // and compile the JSLC support classes
2146     compileJslcJava.dependsOn(generateGrammarSource)
2147     compileJslcJava.classpath = project.configurations.antlr
2148 
2149     compileJava.dependsOn(compileJslcJava)
2150 
2151     // this task is the &quot;second pass&quot; compile of all of the module classes
2152     project.task(&quot;compileFullJava&quot;, type: JavaCompile, dependsOn: processShaders) {
2153         description = &quot;Compile all of the graphics java classes - main and shaders&quot;
2154 
2155         classpath = configurations.compile
2156 
2157         source = project.sourceSets.main.java.srcDirs
2158         source += &quot;$buildDir/gensrc/java&quot;
2159         source += project.sourceSets.shaders.output
2160 
2161         destinationDir = project.sourceSets.main.java.outputDir
2162         options.compilerArgs.addAll([
2163             &#39;-h&#39;, &quot;$buildDir/gensrc/headers/&quot;,  // Note: this creates the native headers
2164             &#39;-implicit:none&#39;,
2165             &#39;--module-source-path&#39;, defaultModuleSourcePath
2166             ] )
2167     }
2168     classes.dependsOn(compileFullJava)
2169 
2170     project.sourceSets.shims.java.srcDirs += project.sourceSets.shaders.output
2171     project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/jsl-prism&quot;
2172     project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/jsl-decora&quot;
2173 
2174     compileShimsJava.dependsOn(compileFullJava)
2175 
2176     // Create a single &quot;native&quot; task which will depend on all the individual native tasks for graphics
2177     project.ext.nativeAllTask = task(&quot;native&quot;, group: &quot;Build&quot;, description: &quot;Compiles and Builds all native libraries for Graphics&quot;);
2178     project.ext.cleanNativeAllTask = task(&quot;cleanNative&quot;, group: &quot;Build&quot;, description: &quot;Clean all native libraries and objects for Graphics&quot;);
2179 
2180     // Add tasks for native compilation
2181     addNative(project, &quot;glass&quot;);
2182     addNative(project, &quot;prism&quot;)
2183     addNative(project, &quot;prismSW&quot;)
2184     addNative(project, &quot;font&quot;)
2185     addNative(project, &quot;iio&quot;)
2186     addNative(project, &quot;prismES2&quot;)
2187 
2188     if (IS_COMPILE_PANGO) {
2189         addNative(project, &quot;fontFreetype&quot;)
2190         addNative(project, &quot;fontPango&quot;)
2191     }
2192 
2193     if (IS_WINDOWS) {
2194         addNative(project, &quot;prismD3D&quot;)
2195         // TODO need to hook this up to be executed only if PassThroughVS.h is missing or PassThroughVS.hlsl is changed
2196         task generateD3DHeaders(group: &quot;Build&quot;) {
2197             enabled = IS_WINDOWS
2198             inputs.file &quot;src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl&quot;
2199             inputs.file &quot;src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl&quot;
2200             inputs.file &quot;src/main/native-prism-d3d/PassThroughVS.hlsl&quot;
2201             outputs.dir &quot;$buildDir/headers/PrismD3D/&quot;
2202             outputs.dir &quot;$buildDir/headers/PrismD3D/hlsl/&quot;
2203             description = &quot;Generate headers by compiling hlsl files&quot;
2204             doLast {
2205                 mkdir file(&quot;$buildDir/headers/PrismD3D/hlsl&quot;)
2206                 def PS_3D_SRC = file(&quot;src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl&quot;)
2207                 def VS_3D_SRC = file(&quot;src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl&quot;)
2208                 def PASSTHROUGH_VS_SRC = file(&quot;src/main/native-prism-d3d/PassThroughVS.hlsl&quot;)
2209                 def jobs = [
2210                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;vs_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/PassThroughVS.h&quot;, &quot;/E&quot;, &quot;passThrough&quot;, &quot;$PASSTHROUGH_VS_SRC&quot;],
2211                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS.h&quot;, &quot;/DSpec=0&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2212                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_i.h&quot;, &quot;/DSpec=0&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2213                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1n.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2214                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2n.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2215                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3n.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2216                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1t.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2217                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2t.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2218                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3t.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2219                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1c.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2220                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2c.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2221                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3c.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2222                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1m.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2223                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2m.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2224                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3m.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2225                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1n.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2226                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2n.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2227                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3n.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2228                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1t.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2229                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2t.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2230                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3t.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2231                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1c.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2232                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2c.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2233                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3c.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2234                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1m.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2235                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2m.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2236                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3m.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2237                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ni.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2238                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ni.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2239                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ni.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2240                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ti.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2241                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ti.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2242                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ti.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2243                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ci.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2244                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ci.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2245                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ci.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2246                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1mi.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2247                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2mi.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2248                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3mi.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2249                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ni.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2250                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ni.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2251                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ni.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2252                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ti.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2253                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ti.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2254                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ti.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2255                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ci.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2256                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ci.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2257                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ci.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2258                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1mi.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2259                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2mi.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2260                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3mi.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2261                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;vs_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1VS_Obj.h&quot;, &quot;/DVertexType=ObjVertex&quot;, &quot;$VS_3D_SRC&quot;]
2262                 ]
2263                 final ExecutorService executor = Executors.newFixedThreadPool(Integer.parseInt(project.NUM_COMPILE_THREADS.toString()));
2264                 final CountDownLatch latch = new CountDownLatch(jobs.size());
2265                 List futures = new ArrayList&lt;Future&gt;();
2266                 jobs.each { cmd -&gt;
2267                     futures.add(executor.submit(new Runnable() {
2268                         @Override public void run() {
2269                             try {
2270                                 exec {
2271                                     commandLine cmd
2272                                 }
2273                             } finally {
2274                                 latch.countDown();
2275                             }
2276                         }
2277                     }));
2278                 }
2279                 latch.await();
2280                 // Looking for whether an exception occurred while executing any of the futures.
2281                 // By calling &quot;get()&quot; on each future an exception will be thrown if one had occurred
2282                 // on the background thread.
2283                 futures.each {it.get();}
2284             }
2285         }
2286 
2287         ccWinPrismD3D.dependsOn generateD3DHeaders
2288     }
2289 
2290     // The Decora and Prism JSL files have to be generated in a very specific set of steps.
2291     //      1) Compile the *Compile.java classes. These live in src/main/jsl-* and will be
2292     //         output to $buildDir/classes/jsl-compilers/* (where * == decora or prism).
2293     //      2) Generate source files from the JSL files contained in src/main/jsl-*. These
2294     //         will be output to $buildDir/gensrc/jsl-*
2295     //      3) Compile the JSL Java sources in $buildDir/gensrc/jsl-* and put the output
2296     //         into classes/jsl-*
2297     //      4) Compile the native JSL sources in $buildDir/gensrc/jsl-* and put the obj
2298     //         files into native/jsl-* and the resulting library into libs/jsl-*.dll|so|dylib
2299     //      5) Modify the jar step to include classes/jsl-*
2300     // The native library must be copied over during SDK creation time in the &quot;sdk&quot; task. In
2301     // addition to these steps, the clean task is created. Note that I didn&#39;t bother to create
2302     // a new task for each of the decora files, preferring instead just to create a rule?? Also
2303     // need &quot;clean&quot; tasks for each compile task.
2304 
2305     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2306     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2307     addJSL(project, &quot;Decora&quot;, &quot;com/sun/scenario/effect/impl/hw/d3d/hlsl&quot;, decoraAddExports) { sourceDir, destinationDir -&gt;
2308         [[fileName: &quot;ColorAdjust&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2309          [fileName: &quot;Brightpass&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2310          [fileName: &quot;SepiaTone&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2311          [fileName: &quot;PerspectiveTransform&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2312          [fileName: &quot;DisplacementMap&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2313          [fileName: &quot;InvertMask&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2314          [fileName: &quot;Blend&quot;, generator: &quot;CompileBlend&quot;, outputs: &quot;-all&quot;],
2315          [fileName: &quot;PhongLighting&quot;, generator: &quot;CompilePhong&quot;, outputs: &quot;-all&quot;],
2316          [fileName: &quot;LinearConvolve&quot;, generator: &quot;CompileLinearConvolve&quot;, outputs: &quot;-hw&quot;],
2317          [fileName: &quot;LinearConvolveShadow&quot;, generator: &quot;CompileLinearConvolve&quot;, outputs: &quot;-hw&quot;]].each { settings -&gt;
2318             javaexec {
2319                 executable = JAVA
2320                 workingDir = project.projectDir
2321                 main = settings.generator
2322                 classpath = configurations.compile + configurations.antlr
2323                 classpath += files(project.sourceSets.jslc.java.outputDir)
2324 
2325                 classpath += files(&quot;${project.projectDir}/src/jslc/resources&quot;)
2326 
2327                 classpath += files(&quot;$buildDir/classes/jsl-compilers/decora&quot;)
2328                 jvmArgs += &quot;--module-path=$modulePath&quot;
2329                 jvmArgs += &quot;--add-modules=javafx.graphics&quot;
2330                 jvmArgs += decoraAddExports
2331                 args += [&quot;-i&quot;, sourceDir, &quot;-o&quot;, destinationDir, &quot;-t&quot;, &quot;-pkg&quot;, &quot;com/sun/scenario/effect&quot;, &quot;$settings.outputs&quot;, &quot;$settings.fileName&quot;]
2332             }
2333         }
2334     }
2335 
2336 
2337     task nativeDecora(dependsOn: compileDecoraHLSLShaders, group: &quot;Build&quot;) {
2338         description = &quot;Generates JNI headers, compiles, and builds native dynamic library for Decora&quot;
2339     }
2340     task cleanNativeDecora(type: Delete, group: &quot;Build&quot;) {
2341         description = &quot;Clean native objects for Decora&quot;
2342     }
2343 
2344     def headerDir = file(&quot;$buildDir/gensrc/headers/javafx.graphics&quot;)
2345     def nativeRootDir = project.file(&quot;$project.buildDir/native/jsl-decora&quot;)
2346     def libRootDir = project.file(&quot;$project.buildDir/libs/jsl-decora&quot;)
2347     // For each compile target, create cc and link tasks
2348     compileTargets { t -&gt;
2349         def target = t.name
2350         def upperTarget = t.upper
2351         def capitalTarget = t.capital
2352         def targetProperties = rootProject.ext[upperTarget];
2353         def library = targetProperties.library
2354         def properties = targetProperties.get(&#39;decora&#39;)
2355         def nativeDir = file(&quot;$nativeRootDir/$target&quot;);
2356 
2357         def variants = properties.containsKey(&quot;variants&quot;) ? properties.variants : [&quot;&quot;];
2358         variants.each { variant -&gt;
2359             def variantProperties = variant == &quot;&quot; ? properties : properties.get(variant)
2360             def capitalVariant = variant.capitalize()
2361             def ccOutput = variant == &quot;&quot; ? nativeDir : file(&quot;$nativeDir/$variant&quot;)
2362 
2363             def ccTask = task(&quot;compileDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: CCTask ) {
2364                 description = &quot;Compiles Decora SSE natives for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
2365                 matches = &quot;.*\\.cc&quot;
2366                 source file(&quot;$buildDir/gensrc/jsl-decora&quot;)
2367                 source file(project.projectDir.path + &quot;/src/main/native-decora&quot;)
2368                 headers = headerDir
2369                 params.addAll(variantProperties.ccFlags)
2370                 output(ccOutput)
2371                 compiler = variantProperties.compiler
2372                 cleanNativeDecora.delete ccOutput
2373             }
2374 
2375             def linkTask = task(&quot;linkDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: LinkTask, dependsOn: ccTask) {
2376                 description = &quot;Creates native dynamic library for Decora SSE ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
2377                 objectDir = ccOutput
2378                 linkParams.addAll(variantProperties.linkFlags)
2379                 lib = file(&quot;$libRootDir/$t.name/${library(variantProperties.lib)}&quot;)
2380                 linker = variantProperties.linker
2381                 cleanNativeDecora.delete &quot;$libRootDir/$t.name/&quot;
2382             }
2383 
2384             if (IS_WINDOWS &amp;&amp; target == &quot;win&quot;) {
2385                 def rcTask = project.task(&quot;rcDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: CompileResourceTask) {
2386                     description = &quot;Compiles native sources for Decora SSE&quot;
2387                     matches = &quot;.*\\.rc&quot;
2388                     compiler = variantProperties.rcCompiler
2389                     source(variantProperties.rcSource)
2390                     if (variantProperties.rcFlags) {
2391                         rcParams.addAll(variantProperties.rcFlags)
2392                     }
2393                     output(ccOutput)
2394                 }
2395                 linkTask.dependsOn rcTask;
2396             }
2397 
2398             nativeDecora.dependsOn(linkTask)
2399         }
2400     }
2401 
2402     // Prism JSL
2403     addJSL(project, &quot;Prism&quot;, &quot;com/sun/prism/d3d/hlsl&quot;, null) { sourceDir, destinationDir -&gt;
2404         def inputFiles = fileTree(dir: sourceDir)
2405         inputFiles.include &quot;**/*.jsl&quot;
2406         inputFiles.each { file -&gt;
2407             javaexec {
2408                 executable = JAVA
2409                 workingDir = project.projectDir
2410                 main = &quot;CompileJSL&quot;
2411                 classpath = configurations.compile + configurations.antlr
2412                 classpath += files(project.sourceSets.jslc.java.outputDir)
2413                 classpath += files(project.sourceSets.jslc.resources)
2414                 classpath += files(&quot;$buildDir/classes/jsl-compilers/prism&quot;,
2415                     project.projectDir.path + &quot;/src/main/jsl-prism&quot;) // for the .stg
2416                 args = [&quot;-i&quot;, sourceDir, &quot;-o&quot;, destinationDir, &quot;-t&quot;, &quot;-pkg&quot;, &quot;com/sun/prism&quot;, &quot;-d3d&quot;, &quot;-es2&quot;, &quot;-name&quot;, &quot;$file&quot;]
2417             }
2418         }
2419     }
2420 
2421     nativePrism.dependsOn compilePrismHLSLShaders;
2422 
2423     project.nativeAllTask.dependsOn nativeDecora
2424     project.cleanNativeAllTask.dependsOn cleanNativeDecora
2425     assemble.dependsOn nativeDecora
2426     processResources.dependsOn processDecoraShaders, processPrismShaders
2427 
2428     test {
2429         def cssDir = file(&quot;$buildDir/classes/java/main/${moduleName}/javafx&quot;)
2430         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;,
2431             &quot;-DCSS_META_DATA_TEST_DIR=$cssDir&quot;
2432         enableAssertions = true
2433         testLogging.exceptionFormat = &quot;full&quot;
2434         scanForTestClasses = false
2435         include &quot;**/*Test.*&quot;
2436         if (BUILD_CLOSED &amp;&amp; DO_JCOV) {
2437             addJCov(project, test)
2438         }
2439     }
2440 
2441     // To enable the IDEs to all be happy (no red squiggles) we need to have the libraries
2442     // available in some known location. Maybe in the future the Gradle plugins to each
2443     // of the IDEs will be good enough that we won&#39;t need this hack anymore.
2444     classes {
2445         doLast {
2446             // Copy all of the download libraries to the libs directory for the sake of the IDEs
2447             File libsDir = rootProject.file(&quot;build/libs&quot;);
2448 
2449             // In some IDEs (Eclipse for example), touching these libraries
2450             // cauese a full build within the IDE. When gradle is used
2451             // outside of the IDE, for example to build the native code,
2452             // a full rebuild is caused within the IDE. The fix is to check
2453             // for the presence of the target files in the lib directory
2454             // and not copy the files if all are present.
2455 
2456             libsDir.mkdirs();
2457 
2458             def allLibsPresent = true
2459             def libNames = [ &quot;antlr4-4.7.2-complete.jar&quot; ]
2460             libNames.each { name -&gt;
2461                 File f = new File(libsDir, name)
2462                 if (!f.exists()) allLibsPresent = false
2463             }
2464             if (allLibsPresent) return;
2465 
2466             for (File f : [configurations.compile.files, configurations.antlr.files].flatten()) {
2467                 copy {
2468                     into libsDir
2469                     from f.getParentFile()
2470                     include &quot;**/antlr4-4.7.2-complete.jar&quot;
2471                     includeEmptyDirs = false
2472                 }
2473             }
2474         }
2475     }
2476 
2477     addMavenPublication(project, [ &#39;base&#39; ])
2478 
2479     addValidateSourceSets(project, sourceSets)
2480 }
2481 
2482 project(&quot;:controls&quot;) {
2483     project.ext.buildModule = true
2484     project.ext.includeSources = true
2485     project.ext.moduleRuntime = true
2486     project.ext.moduleName = &quot;javafx.controls&quot;
2487 
2488     sourceSets {
2489         main
2490         shims {
2491             java {
2492                 compileClasspath += sourceSets.main.output
2493                 runtimeClasspath += sourceSets.main.output
2494             }
2495         }
2496         test {
2497             java {
2498                 compileClasspath += sourceSets.shims.output
2499                 runtimeClasspath += sourceSets.shims.output
2500             }
2501         }
2502     }
2503 
2504     project.ext.moduleSourcePath = defaultModuleSourcePath
2505     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2506 
2507     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39; ])
2508 
2509     dependencies {
2510         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
2511         testCompile project(&quot;:base&quot;).sourceSets.test.output
2512         compile project(&#39;:base&#39;)
2513         compile project(&#39;:graphics&#39;)
<a name="1" id="anc1"></a><span class="line-removed">2514         testCompile &quot;de.sandec:JMemoryBuddy:0.1.3&quot;</span>
2515     }
2516 
2517     test {
2518         def cssDir = file(&quot;$buildDir/classes/java/main/${moduleName}/javafx&quot;)
2519         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;,
2520             &quot;-DCSS_META_DATA_TEST_DIR=$cssDir&quot;
2521     }
2522 
2523     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2524     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main&quot;
2525     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2526     processResources {
2527       doLast {
2528         def cssFiles = fileTree(dir: &quot;$moduleDir/com/sun/javafx/scene/control/skin&quot;)
2529         cssFiles.include &quot;**/*.css&quot;
2530         cssFiles.each { css -&gt;
2531             logger.info(&quot;converting CSS to BSS ${css}&quot;);
2532 
2533             javaexec {
2534                 executable = JAVA
2535                 workingDir = project.projectDir
2536                 jvmArgs += patchModuleArgs
2537                 jvmArgs += &quot;--module-path=$modulePath&quot;
2538                 jvmArgs += &quot;--add-modules=javafx.graphics&quot;
2539                 main = &quot;com.sun.javafx.css.parser.Css2Bin&quot;
2540                 args css
2541             }
2542         }
2543       }
2544     }
2545 
2546     processShimsResources.dependsOn(project.task(&quot;copyShimBss&quot;, type: Copy) {
2547         from project.moduleDir
2548         into project.moduleShimsDir
2549         include &quot;**/*.bss&quot;
2550     })
2551 
2552     addMavenPublication(project, [ &#39;graphics&#39; ])
2553 
2554     addValidateSourceSets(project, sourceSets)
2555 }
2556 
2557 project(&quot;:swing&quot;) {
2558 
2559     tasks.all {
2560         if (!COMPILE_SWING) it.enabled = false
2561     }
2562 
2563     project.ext.buildModule = COMPILE_SWING
2564     project.ext.includeSources = true
2565     project.ext.moduleRuntime = true
2566     project.ext.moduleName = &quot;javafx.swing&quot;
2567 
2568     sourceSets {
2569         main
2570         //shims // no test shims needed
2571         test
2572     }
2573 
2574     project.ext.moduleSourcePath = defaultModuleSourcePath
2575     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2576 
2577     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;swing&#39; ])
2578 
2579     dependencies {
2580         compile project(&quot;:base&quot;)
2581         compile project(&quot;:graphics&quot;)
2582     }
2583 
2584     test {
2585         enabled = IS_FULL_TEST &amp;&amp; IS_AWT_TEST
2586     }
2587 
2588     if (COMPILE_SWING) {
2589         addMavenPublication(project, [ &#39;graphics&#39; ])
2590     }
2591 
2592     addValidateSourceSets(project, sourceSets)
2593 }
2594 
2595 project(&quot;:swt&quot;) {
2596     tasks.all {
2597         if (!COMPILE_SWT) it.enabled = false
2598     }
2599 
2600     // javafx.swt is an automatic module
2601     project.ext.buildModule = false
2602 
2603     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39; ])
2604 
2605     dependencies {
2606         compile name: SWT_FILE_NAME
2607     }
2608 
2609     classes {
2610         doLast {
2611             // Copy all of the download libraries to libs directory for the sake of the IDEs
2612             File libsDir = rootProject.file(&quot;build/libs&quot;);
2613             File swtLib = new File(libsDir, &quot;swt-debug.jar&quot;)
2614             libsDir.mkdirs();
2615 
2616             // Skip copy if file is present.
2617             if (swtLib.exists()) return;
2618 
2619             for (File f : configurations.compile.files) {
2620                 // Have to rename the swt jar because it is some platform specific name but
2621                 // for the sake of the IDEs we need to have a single stable name that works
2622                 // on every platform
2623                 copy {
2624                     into libsDir
2625                     from f.getParentFile()
2626                     include &quot;**/*swt*.jar&quot;
2627                     includeEmptyDirs = false
2628                     rename &quot;.*swt.*jar&quot;, &quot;swt-debug\\.jar&quot;
2629                 }
2630             }
2631         }
2632     }
2633 
2634     compileJava.options.compilerArgs.addAll([
2635             &quot;--add-exports=javafx.graphics/com.sun.glass.ui=ALL-UNNAMED&quot;,
2636             &quot;--add-exports=javafx.graphics/com.sun.javafx.cursor=ALL-UNNAMED&quot;,
2637             &quot;--add-exports=javafx.graphics/com.sun.javafx.embed=ALL-UNNAMED&quot;,
2638             &quot;--add-exports=javafx.graphics/com.sun.javafx.stage=ALL-UNNAMED&quot;,
2639             &quot;--add-exports=javafx.graphics/com.sun.javafx.tk=ALL-UNNAMED&quot;,
2640             ])
2641 
2642     test {
2643         //enabled = IS_FULL_TEST &amp;&amp; IS_SWT_TEST
2644         enabled = false // FIXME: JIGSAW -- support this with modules
2645         logger.info(&quot;JIGSAW Testing disabled for swt&quot;)
2646 
2647         if (IS_MAC) {
2648             enabled = false
2649             logger.info(&quot;SWT tests are disabled on MAC, because Gradle test runner does not handle -XstartOnFirstThread properly (https://issues.gradle.org/browse/GRADLE-3290).&quot;)
2650         }
2651     }
2652 
2653     addValidateSourceSets(project, sourceSets)
2654 }
2655 
2656 project(&quot;:fxml&quot;) {
2657     project.ext.buildModule = true
2658     project.ext.includeSources = true
2659     project.ext.moduleRuntime = true
2660     project.ext.moduleName = &quot;javafx.fxml&quot;
2661 
2662     sourceSets {
2663         main
2664         shims {
2665             java {
2666                 compileClasspath += sourceSets.main.output
2667                 runtimeClasspath += sourceSets.main.output
2668             }
2669         }
2670         test {
2671             java {
2672                 compileClasspath += sourceSets.shims.output
2673                 runtimeClasspath += sourceSets.shims.output
2674             }
2675         }
2676     }
2677 
2678     project.ext.moduleSourcePath = defaultModuleSourcePath
2679     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2680 
2681     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;fxml&#39; ])
2682 
2683 
2684     dependencies {
2685         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
2686         testCompile project(&quot;:base&quot;).sourceSets.test.output
2687         compile project(&quot;:base&quot;)
2688         compile project(&quot;:graphics&quot;)
2689     }
2690 
2691     test {
2692         // StubToolkit is not *really* needed here, but because some code inadvertently invokes performance
2693         // tracker and this attempts to fire up the toolkit and this looks for native libraries and fails,
2694         // we have to use the stub toolkit for now.
2695         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;
2696         // FIXME: change this to also allow JDK 9 boot jdk
2697         classpath += files(&quot;$JDK_HOME/jre/lib/ext/nashorn.jar&quot;)
2698     }
2699 
2700     addMavenPublication(project, [ &#39;controls&#39; ])
2701 
2702     addValidateSourceSets(project, sourceSets)
2703 }
2704 
2705 project(&quot;:media&quot;) {
2706     configurations {
2707         media
2708     }
2709 
2710     project.ext.buildModule = true
2711     project.ext.includeSources = true
2712     project.ext.moduleRuntime = true
2713     project.ext.moduleName = &quot;javafx.media&quot;
2714 
2715     sourceSets {
2716         main
2717         //shims // no test shims needed
2718         test
2719         tools {
2720             java.srcDir &quot;src/tools/java&quot;
2721         }
2722     }
2723 
2724     project.ext.moduleSourcePath = defaultModuleSourcePath
2725     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2726 
2727     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;media&#39; ])
2728 
2729     dependencies {
2730         if (IS_BUILD_LIBAV_STUBS) {
2731             media name: &quot;libav-9.14&quot;, ext: &quot;tar.gz&quot;
2732             media name: &quot;libav-11.4&quot;, ext: &quot;tar.gz&quot;
2733             media name: &quot;libav-12.1&quot;, ext: &quot;tar.gz&quot;
2734             media name: &quot;ffmpeg-3.3.3&quot;, ext: &quot;tar.gz&quot;
2735             media name: &quot;ffmpeg-4.0.2&quot;, ext: &quot;tar.gz&quot;
2736         }
2737         compile project(&quot;:base&quot;)
2738         compile project(&quot;:graphics&quot;)
2739     }
2740 
2741     compileJava.dependsOn updateCacheIfNeeded
2742 
2743     compileJava {
2744         // generate the native headers during compile
2745         options.compilerArgs.addAll([
2746             &#39;-h&#39;, &quot;${project.buildDir}/gensrc/headers&quot;
2747             ])
2748     }
2749 
2750     compileToolsJava {
2751         enabled = IS_COMPILE_MEDIA
2752         def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2753         options.compilerArgs.addAll([
2754             &quot;--module-path=$modulePath&quot;,
2755             &quot;--add-modules=javafx.media&quot;,
2756             &#39;--add-exports&#39;, &#39;javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED&#39;,
2757             ])
2758     }
2759 
2760     project.ext.makeJobsFlag = IS_WINDOWS &amp;&amp; IS_DEBUG_NATIVE ? &quot;-j1&quot; : &quot;-j5&quot;;
2761     project.ext.buildType = IS_DEBUG_NATIVE ? &quot;Debug&quot; : &quot;Release&quot;;
2762 
2763     def nativeSrcDir = file(&quot;${projectDir}/src/main/native&quot;)
2764     def generatedHeadersDir = file(&quot;${buildDir}/gensrc/headers/${project.moduleName}&quot;)
2765 
2766     task generateMediaErrorHeader(dependsOn: [compileJava, compileToolsJava]) {
2767         enabled = IS_COMPILE_MEDIA
2768         def headerpath = file(&quot;$generatedHeadersDir/jfxmedia_errors.h&quot;);
2769         doLast {
2770             def classpath = files(sourceSets.tools.output);
2771             def sourcepath = sourceSets.main.java.srcDirs;
2772             def srcRoot = (sourcepath.toArray())[0];
2773 
2774             mkdir generatedHeadersDir;
2775 
2776             def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2777             modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main&quot;
2778             modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2779 
2780             exec {
2781                 commandLine(&quot;$JAVA&quot;);
2782                 args += patchModuleArgs
2783                 args += [ &quot;--module-path=$modulePath&quot; ]
2784                 args += [ &quot;--add-modules=javafx.media&quot; ]
2785                 args +=  [ &#39;--add-exports=javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED&#39; ]
2786                 args +=  [ &#39;-classpath&#39;, &quot;${classpath.asPath}&quot; ]
2787                 args += [ &quot;headergen.HeaderGen&quot;, &quot;$headerpath&quot;, &quot;$srcRoot&quot; ]
2788             }
2789         }
2790         outputs.file(project.file(&quot;$headerpath&quot;))
2791     }
2792 
2793     task buildNativeTargets {
2794         enabled = IS_COMPILE_MEDIA
2795     }
2796 
2797     compileTargets { t-&gt;
2798         def targetProperties = project.rootProject.ext[t.upper]
2799         def nativeOutputDir = file(&quot;${buildDir}/native/${t.name}&quot;)
2800         def projectDir = t.name.startsWith(&quot;arm&quot;) ? &quot;linux&quot; : t.name
2801         def mediaProperties = targetProperties.media
2802         // Makefile for OSX needs to know if we&#39;re building for parfait
2803         def compileParfait = IS_COMPILE_PARFAIT ? &quot;true&quot; : &quot;false&quot;
2804 
2805         def buildNative = task(&quot;build${t.capital}Native&quot;, dependsOn: [generateMediaErrorHeader]) {
2806             enabled = targetProperties.compileMediaNative
2807             if (!targetProperties.compileMediaNative) {
2808                 println(&quot;Not compiling native Media for ${t.name} per configuration request&quot;);
2809             }
2810 
2811             doLast {
2812                 exec {
2813                     commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/jfxmedia/projects/${projectDir}&quot;)
2814                     args(&quot;JAVA_HOME=${JDK_HOME}&quot;, &quot;GENERATED_HEADERS_DIR=${generatedHeadersDir}&quot;,
2815                          &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=jfxmedia&quot;,
2816                          &quot;COMPILE_PARFAIT=${compileParfait}&quot;,
2817                          IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;,
2818                         &quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2819 
2820                     if (t.name == &quot;win&quot;) {
2821                         environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2822                         args( &quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.jfxmediaRcFile}&quot;)
2823                     } else {
2824                         if (t.name.startsWith(&quot;arm&quot;)) {
2825                             args(&quot;EXTRA_CFLAGS=${mediaProperties.extra_cflags}&quot;, &quot;EXTRA_LDFLAGS=${mediaProperties.extra_ldflags}&quot;)
2826                         } else {
2827                             args(&quot;HOST_COMPILE=1&quot;)
2828                         }
2829                     }
2830                 }
2831             }
2832         }
2833 
2834         // check for the property disable${name} = true
2835         def boolean disabled = targetProperties.containsKey(&#39;disableMedia&#39;) ? targetProperties.get(&#39;disableMedia&#39;) : false
2836         if (!disabled) {
2837             // Building GStreamer
2838             def buildGStreamer = task(&quot;build${t.capital}GStreamer&quot;) {
2839                 enabled = IS_COMPILE_MEDIA
2840                 doLast {
2841                     exec {
2842                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/gstreamer-lite&quot;)
2843                         args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=gstreamer-lite&quot;,
2844                              IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;, &quot;CC=${mediaProperties.compiler}&quot;,
2845                              &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2846 
2847                         if (t.name == &quot;win&quot;) {
2848                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2849                             args(&quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.gstreamerRcFile}&quot;)
2850                         }
2851                     }
2852                 }
2853             }
2854 
2855             def buildPlugins = task(&quot;build${t.capital}Plugins&quot;, dependsOn: buildGStreamer) {
2856                 enabled = IS_COMPILE_MEDIA
2857 
2858                 doLast {
2859                     exec {
2860                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/fxplugins&quot;)
2861                         args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=fxplugins&quot;,
2862                              IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;,
2863                              &quot;CC=${mediaProperties.compiler}&quot;, &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2864 
2865                         if (t.name == &quot;win&quot;) {
2866                             Map winEnv = new HashMap(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2867 
2868                             String sdkDir = System.getenv(&quot;BASECLASSES_SDK_DIR&quot;);
2869                             if (sdkDir == null) {
2870                                 sdkDir = &quot;C:/Program Files/Microsoft SDKs/Windows/v7.1&quot; // Default value
2871                                 winEnv[&quot;BASECLASSES_SDK_DIR&quot;] = sdkDir
2872                             }
2873                             environment(winEnv)
2874 
2875                             args(&quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.fxpluginsRcFile}&quot;)
2876                         }
2877                     }
2878                 }
2879             }
2880 
2881             buildNative.dependsOn buildPlugins
2882 
2883             if (t.name == &quot;linux&quot;) {
2884                 // Pre-defined command line arguments
2885                 def cfgCMDArgs = [&quot;sh&quot;, &quot;configure&quot;]
2886                 def commonCfgArgs = [&quot;--enable-shared&quot;, &quot;--disable-debug&quot;, &quot;--disable-static&quot;, &quot;--disable-yasm&quot;, &quot;--disable-doc&quot;, &quot;--disable-programs&quot;, &quot;--disable-everything&quot;]
2887                 def codecsCfgArgs = [&quot;--enable-decoder=aac,mp3,mp3float,h264&quot;, &quot;--enable-parser=aac,h264&quot;, &quot;--enable-demuxer=aac,h264,mpegts,mpegtsraw&quot;]
2888 
2889                 def copyLibAVStubs = {String fromDir, String toDir -&gt;
2890                     FileCollection config = files(&quot;config.h&quot;)
2891                     FileCollection libavcodec = files(&quot;avcodec.h&quot;, &quot;avfft.h&quot;, &quot;dxva2.h&quot;, &quot;vaapi.h&quot;, &quot;vda.h&quot;,
2892                                                       &quot;vdpau.h&quot;, &quot;version.h&quot;, &quot;xvmc.h&quot;, &quot;old_codec_ids.h&quot;)
2893                     FileCollection libavdevice = files(&quot;avdevice.h&quot;, &quot;version.h&quot;)
2894                     FileCollection libavfilter = files(&quot;avfiltergraph.h&quot;, &quot;avfilter.h&quot;, &quot;buffersink.h&quot;, &quot;buffersrc.h&quot;, &quot;version.h&quot;);
2895                     FileCollection libavformat = files(&quot;avformat.h&quot;, &quot;avio.h&quot;, &quot;version.h&quot;)
2896                     FileCollection libavresample = files(&quot;avresample.h&quot;, &quot;version.h&quot;)
2897                     FileCollection libavutil = files(&quot;adler32.h&quot;, &quot;blowfish.h&quot;, &quot;error.h&quot;, &quot;log.h&quot;, &quot;pixfmt.h&quot;,
2898                                                      &quot;aes.h&quot;, &quot;bswap.h&quot;, &quot;eval.h&quot;, &quot;lzo.h&quot;, &quot;random_seed.h&quot;,
2899                                                      &quot;attributes.h&quot;, &quot;buffer.h&quot;, &quot;fifo.h&quot;, &quot;macros.h&quot;, &quot;rational.h&quot;,
2900                                                      &quot;audio_fifo.h&quot;, &quot;channel_layout.h&quot;, &quot;file.h&quot;, &quot;mathematics.h&quot;, &quot;samplefmt.h&quot;,
2901                                                      &quot;avassert.h&quot;, &quot;common.h&quot;, &quot;frame.h&quot;, &quot;md5.h&quot;, &quot;sha.h&quot;,
2902                                                      &quot;avconfig.h&quot;, &quot;imgutils.h&quot;, &quot;mem.h&quot;, &quot;time.h&quot;, &quot;avstring.h&quot;,
2903                                                      &quot;cpu_internal.h&quot;, &quot;intfloat.h&quot;, &quot;opt.h&quot;, &quot;version.h&quot;, &quot;avutil.h&quot;,
2904                                                      &quot;crc.h&quot;, &quot;intreadwrite.h&quot;, &quot;parseutils.h&quot;, &quot;xtea.h&quot;, &quot;base64.h&quot;,
2905                                                      &quot;dict.h&quot;, &quot;lfg.h&quot;, &quot;pixdesc.h&quot;, &quot;intfloat_readwrite.h&quot;, &quot;old_pix_fmts.h&quot;, &quot;audioconvert.h&quot;,
2906                                                      &quot;cpu.h&quot;, &quot;hwcontext.h&quot;)
2907                     FileCollection libavutil_x86 = files(&quot;cpu.h&quot;) // Use cpu.h from x86 instead of libavutil root if exist
2908                     FileCollection libswscale = files(&quot;swscale.h&quot;, &quot;version.h&quot;)
2909 
2910                     def copyLibAVFiles = {FileCollection files, String fDir, String tDir -&gt;
2911                         File dir = file(tDir)
2912                         dir.mkdirs()
2913 
2914                         files.each { File file -&gt;
2915                             copy {
2916                                 from fDir
2917                                 into tDir
2918                                 include file.name
2919                             }
2920                         }
2921                     }
2922 
2923                     copyLibAVFiles(config, fromDir, &quot;${toDir}/include&quot;)
2924                     copyLibAVFiles(libavcodec, &quot;${fromDir}/libavcodec&quot;, &quot;${toDir}/include/libavcodec&quot;)
2925                     copyLibAVFiles(libavdevice, &quot;${fromDir}/libavdevice&quot;, &quot;${toDir}/include/libavdevice&quot;)
2926                     copyLibAVFiles(libavfilter, &quot;${fromDir}/libavfilter&quot;, &quot;${toDir}/include/libavfilter&quot;)
2927                     copyLibAVFiles(libavformat, &quot;${fromDir}/libavformat&quot;, &quot;${toDir}/include/libavformat&quot;)
2928                     copyLibAVFiles(libavresample, &quot;${fromDir}/libavresample&quot;, &quot;${toDir}/include/libavresample&quot;)
2929                     copyLibAVFiles(libavutil, &quot;${fromDir}/libavutil&quot;, &quot;${toDir}/include/libavutil&quot;)
2930                     copyLibAVFiles(libavutil_x86, &quot;${fromDir}/libavutil/x86&quot;, &quot;${toDir}/include/libavutil&quot;)
2931                     copyLibAVFiles(libswscale, &quot;${fromDir}/libswscale&quot;, &quot;${toDir}/include/libswscale&quot;)
2932 
2933                     // Copy libs
2934                     FileTree libs = fileTree(dir: &quot;${fromDir}&quot;, include: &quot;**/*.so*&quot;)
2935                     libs.each {File file -&gt;
2936                         copy {
2937                             from file
2938                             into &quot;${toDir}/lib&quot;
2939                         }
2940                     }
2941                 }
2942 
2943                 def buildLibAVStubs = task(&quot;buildLibAVStubs&quot;, dependsOn: []) {
2944                     enabled = IS_BUILD_LIBAV_STUBS
2945 
2946                     doLast {
2947                         project.ext.libav = [:]
2948                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/libav&quot;
2949                         project.ext.libav.versions = [ &quot;9.14&quot;, &quot;11.4&quot;, &quot;12.1&quot; ]
2950                         project.ext.libav.versionmap = [ &quot;9.14&quot; : &quot;54&quot;, &quot;11.4&quot; : &quot;56&quot;, &quot;12.1&quot; : &quot;57&quot; ]
2951 
2952                         libav.versions.each { version -&gt;
2953                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
2954                             for (File f : configurations.media.files) {
2955                                 if (f.name.startsWith(&quot;libav-${version}&quot;)) {
2956                                     File dir = file(libavDir)
2957                                     dir.mkdirs()
2958                                     def libavTar = &quot;${libav.basedir}/libav-${version}.tar&quot;
2959                                     ant.gunzip(src: f, dest: libavTar)
2960                                     ant.untar(src: libavTar, dest: libav.basedir)
2961                                 }
2962                             }
2963                         }
2964 
2965                         libav.versions.each { version -&gt;
2966                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
2967                             File dir = file(libavDir)
2968                             if (dir.exists()) {
2969                                 def configFile = &quot;${libav.basedir}/libav-${version}/config.h&quot;
2970                                 File cfgFile = file(configFile)
2971                                 if (!cfgFile.exists()) {
2972                                     // Add execute permissions to version.sh, otherwise build fails
2973                                     exec {
2974                                         workingDir(&quot;$libavDir&quot;)
2975                                         commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
2976                                     }
2977                                     exec {
2978                                         workingDir(&quot;$libavDir&quot;)
2979                                         if (IS_BUILD_WORKING_LIBAV) {
2980                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)
2981                                         } else {
2982                                             commandLine(cfgCMDArgs + commonCfgArgs)
2983                                         }
2984                                     }
2985                                 }
2986                                 exec {
2987                                     workingDir(&quot;$libavDir&quot;)
2988                                     commandLine(&quot;make&quot;)
2989                                 }
2990                             }
2991                         }
2992 
2993                         libav.versions.each { version -&gt;
2994                             def fromDir = &quot;${libav.basedir}/libav-${version}&quot;
2995                             def majorVersion = libav.versionmap[version]
2996                             def toDir = &quot;${libav.basedir}/libav-${majorVersion}&quot;
2997                             copyLibAVStubs(fromDir, toDir)
2998                         }
2999                     }
3000                 }
3001 
3002                 def buildLibAVFFmpegStubs = task(&quot;buildLibAVFFmpegStubs&quot;, dependsOn: []) {
3003                     enabled = IS_BUILD_LIBAV_STUBS
3004 
3005                     def extraCfgArgs = [&quot;--build-suffix=-ffmpeg&quot;]
3006 
3007                     doLast {
3008                         project.ext.libav = [:]
3009                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/libavffmpeg&quot;
3010                         project.ext.libav.versions = [ &quot;11.4&quot; ]
3011                         project.ext.libav.versionmap = [ &quot;11.4&quot; : &quot;56&quot; ]
3012 
3013                         libav.versions.each { version -&gt;
3014                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
3015                             for (File f : configurations.media.files) {
3016                                 if (f.name.startsWith(&quot;libav-${version}&quot;)) {
3017                                     File dir = file(libavDir)
3018                                     dir.mkdirs()
3019                                     def libavTar = &quot;${libav.basedir}/libav-${version}.tar&quot;
3020                                     ant.gunzip(src: f, dest: libavTar)
3021                                     ant.untar(src: libavTar, dest: libav.basedir)
3022                                 }
3023                             }
3024                         }
3025 
3026                         libav.versions.each { version -&gt;
3027                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
3028                             File dir = file(libavDir)
3029                             if (dir.exists()) {
3030                                 def configFile = &quot;${libav.basedir}/libav-${version}/config.h&quot;
3031                                 File cfgFile = file(configFile)
3032                                 if (!cfgFile.exists()) {
3033                                     // Patch *.v files, so we have *_FFMPEG_$MAJOR instead of *_$MAJOR, otherwise library will not be loaded
3034                                     FileTree vfiles = fileTree(dir: &quot;${libavDir}&quot;, include: &quot;**/*.v&quot;)
3035                                     vfiles.each {File file -&gt;
3036                                         String data = file.getText(&quot;UTF-8&quot;)
3037                                         data = data.replace(&quot;_\$MAJOR&quot;, &quot;_FFMPEG_\$MAJOR&quot;)
3038                                         file.write(data, &quot;UTF-8&quot;)
3039                                     }
3040                                     // Add execute permissions to version.sh, otherwise build fails
3041                                     exec {
3042                                         workingDir(&quot;$libavDir&quot;)
3043                                         commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
3044                                     }
3045                                     exec {
3046                                         workingDir(&quot;$libavDir&quot;)
3047                                         if (IS_BUILD_WORKING_LIBAV) {
3048                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs + extraCfgArgs)
3049                                         } else {
3050                                             commandLine(cfgCMDArgs + commonCfgArgs + extraCfgArgs)
3051                                         }
3052                                     }
3053                                 }
3054                                 exec {
3055                                     workingDir(&quot;$libavDir&quot;)
3056                                     commandLine(&quot;make&quot;)
3057                                 }
3058                             }
3059                         }
3060 
3061                         libav.versions.each { version -&gt;
3062                             def fromDir = &quot;${libav.basedir}/libav-${version}&quot;
3063                             def majorVersion = libav.versionmap[version]
3064                             def toDir = &quot;${libav.basedir}/libav-${majorVersion}&quot;
3065                             copyLibAVStubs(fromDir, toDir)
3066 
3067                             // Special case to copy *-ffmpeg.so to *.so
3068                             FileTree libs = fileTree(dir: &quot;${fromDir}&quot;, include: &quot;**/*-ffmpeg.so&quot;)
3069                             libs.each {File file -&gt;
3070                                 copy {
3071                                     from file
3072                                     into &quot;${toDir}/lib&quot;
3073                                     rename { String fileName -&gt;
3074                                         fileName.replace(&quot;-ffmpeg&quot;, &quot;&quot;)
3075                                     }
3076                                 }
3077                             }
3078                         }
3079                     }
3080                 }
3081 
3082                 def buildFFmpegStubs = task(&quot;buildFFmpegStubs&quot;, dependsOn: []) {
3083                     enabled = IS_BUILD_LIBAV_STUBS
3084 
3085                     doLast {
3086                         project.ext.libav = [:]
3087                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/ffmpeg&quot;
3088                         project.ext.libav.versions = [ &quot;3.3.3&quot;, &quot;4.0.2&quot; ]
3089                         project.ext.libav.versionmap = [ &quot;3.3.3&quot; : &quot;57&quot;, &quot;4.0.2&quot; : &quot;58&quot; ]
3090 
3091                         libav.versions.each { version -&gt;
3092                             def libavDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3093                             for (File f : configurations.media.files) {
3094                                 if (f.name.startsWith(&quot;ffmpeg-${version}&quot;)) {
3095                                     File dir = file(libavDir)
3096                                     dir.mkdirs()
3097                                     def libavTar = &quot;${libav.basedir}/ffmpeg-${version}.tar&quot;
3098                                     ant.gunzip(src: f, dest: libavTar)
3099                                     ant.untar(src: libavTar, dest: libav.basedir)
3100                                 }
3101                             }
3102                         }
3103 
3104                         libav.versions.each { version -&gt;
3105                             def libavDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3106                             File dir = file(libavDir)
3107                             if (dir.exists()) {
3108                                 def configFile = &quot;${libavDir}/config.h&quot;
3109                                 File cfgFile = file(configFile)
3110                                 if (!cfgFile.exists()) {
3111                                     // Add execute permissions to version.sh, otherwise build fails
3112                                     def versionFile = &quot;${libavDir}/version.sh&quot;
3113                                     File verFile = file(versionFile)
3114                                     if (verFile.exists()) {
3115                                         exec {
3116                                             workingDir(&quot;$libavDir&quot;)
3117                                             commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
3118                                         }
3119                                     } else {
3120                                         versionFile = &quot;${libavDir}/ffbuild/version.sh&quot;
3121                                         verFile = file(versionFile)
3122                                         if (verFile.exists()) {
3123                                             exec {
3124                                                 workingDir(&quot;${libavDir}/ffbuild&quot;)
3125                                                 commandLine(&quot;chmod&quot;)
3126                                                 args += &quot;+x&quot;
3127                                                 args += [&quot;version.sh&quot;, &quot;libversion.sh&quot;, &quot;pkgconfig_generate.sh&quot;]
3128                                             }
3129                                         }
3130                                     }
3131                                     exec {
3132                                         workingDir(&quot;$libavDir&quot;)
3133                                         if (IS_BUILD_WORKING_LIBAV) {
3134                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)
3135                                         } else {
3136                                             commandLine(cfgCMDArgs + commonCfgArgs)
3137                                         }
3138                                     }
3139                                 }
3140                                 exec {
3141                                     workingDir(&quot;$libavDir&quot;)
3142                                     commandLine(&quot;make&quot;)
3143                                 }
3144                             }
3145                         }
3146 
3147                         libav.versions.each { version -&gt;
3148                             def fromDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3149                             def majorVersion = libav.versionmap[version]
3150                             def toDir = &quot;${libav.basedir}/ffmpeg-${majorVersion}&quot;
3151                             copyLibAVStubs(fromDir, toDir)
3152                         }
3153                     }
3154                 }
3155 
3156                 def buildAVPlugin = task( &quot;buildAVPlugin&quot;, dependsOn: [buildPlugins, buildLibAVStubs, buildLibAVFFmpegStubs, buildFFmpegStubs]) {
3157                     enabled = IS_COMPILE_MEDIA
3158 
3159                     doLast {
3160                         if (IS_BUILD_LIBAV_STUBS) {
3161                             project.ext.libav = [:]
3162                             project.ext.libav.basedir = &quot;${buildDir}/native/linux/libav/libav&quot;
3163                             project.ext.libav.versions = [ &quot;53&quot;, &quot;54&quot;, &quot;55&quot;, &quot;56&quot;, &quot;57&quot; ]
3164                             project.ext.libav.libavffmpeg = [:]
3165                             project.ext.libav.libavffmpeg.basedir = &quot;${buildDir}/native/linux/libavffmpeg/libav&quot;
3166                             project.ext.libav.libavffmpeg.versions = [ &quot;56&quot; ]
3167                             project.ext.libav.ffmpeg = [:]
3168                             project.ext.libav.ffmpeg.basedir = &quot;${buildDir}/native/linux/ffmpeg/ffmpeg&quot;
3169                             project.ext.libav.ffmpeg.versions = [ &quot;57&quot;, &quot;58&quot; ]
3170 
3171                             project.ext.libav.versions.each { version -&gt;
3172                                 def libavDir = &quot;${project.ext.libav.basedir}-${version}&quot;
3173                                 File dir = file(libavDir)
3174                                 if (dir.exists()) {
3175                                     exec {
3176                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3177                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3178                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3179                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3180                                              &quot;SUFFIX=&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3181                                     }
3182                                 }
3183                             }
3184 
3185                             project.ext.libav.libavffmpeg.versions.each { version -&gt;
3186                                 def libavDir = &quot;${project.ext.libav.libavffmpeg.basedir}-${version}&quot;
3187                                 File dir = file(libavDir)
3188                                 if (dir.exists()) {
3189                                     exec {
3190                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3191                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3192                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3193                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3194                                              &quot;SUFFIX=-ffmpeg&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3195                                     }
3196                                 }
3197                             }
3198 
3199                             project.ext.libav.ffmpeg.versions.each { version -&gt;
3200                                 def libavDir = &quot;${project.ext.libav.ffmpeg.basedir}-${version}&quot;
3201                                 File dir = file(libavDir)
3202                                 if (dir.exists()) {
3203                                     exec {
3204                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3205                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3206                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3207                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3208                                              &quot;SUFFIX=-ffmpeg&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3209                                     }
3210                                 }
3211                             }
3212                         } else {
3213                             // Building fxavcodec plugin (libav plugin)
3214                             exec {
3215                                 commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3216                                 args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3217                                      &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3218                                      &quot;BASE_NAME=avplugin&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3219                             }
3220                         }
3221                     }
3222                 }
3223                 buildNative.dependsOn buildAVPlugin
3224             }
3225 
3226             if (t.name == &quot;win&quot;) {
3227                 def buildResources = task(&quot;buildResources&quot;) {
3228                     doLast {
3229                         def rcOutputDir = &quot;${nativeOutputDir}/${buildType}&quot;
3230                         mkdir rcOutputDir
3231                         exec {
3232                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3233                             commandLine (WIN.media.rcCompiler)
3234                             args(WIN.media.glibRcFlags)
3235                             args(&quot;/Fo${rcOutputDir}/${WIN.media.glibRcFile}&quot;, WIN.media.rcSource)
3236                         }
3237 
3238                         exec {
3239                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3240                             commandLine (WIN.media.rcCompiler)
3241                             args(WIN.media.gstreamerRcFlags)
3242                             args(&quot;/Fo${rcOutputDir}/${WIN.media.gstreamerRcFile}&quot;, WIN.media.rcSource)
3243                         }
3244 
3245                         exec {
3246                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3247                             commandLine (WIN.media.rcCompiler)
3248                             args(WIN.media.fxpluginsRcFlags)
3249                             args(&quot;/Fo${rcOutputDir}/${WIN.media.fxpluginsRcFile}&quot;, WIN.media.rcSource)
3250                         }
3251 
3252                         exec {
3253                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3254                             commandLine (WIN.media.rcCompiler)
3255                             args(WIN.media.jfxmediaRcFlags)
3256                             args(&quot;/Fo${rcOutputDir}/${WIN.media.jfxmediaRcFile}&quot;, WIN.media.rcSource)
3257                         }
3258                     }
3259                 }
3260 
3261                 def buildGlib = task(&quot;build${t.capital}Glib&quot;, dependsOn: [buildResources]) {
3262                     enabled = IS_COMPILE_MEDIA
3263                     doLast {
3264                         exec {
3265                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3266                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite&quot;)
3267                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=glib-lite&quot;,
3268                                  IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;, &quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.glibRcFile}&quot;,
3269                                  &quot;CC=${mediaProperties.compiler}&quot;, &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
3270                         }
3271                     }
3272                 }
3273                 buildGStreamer.dependsOn buildGlib
3274 
3275             } else if (t.name == &quot;mac&quot;) {
3276                 def buildGlib = task(&quot;build${t.capital}Glib&quot;) {
3277                     enabled = IS_COMPILE_MEDIA
3278                     doLast {
3279                         exec {
3280                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/libffi&quot;)
3281                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=ffi&quot;)
3282                             args (&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;, &quot;AR=${mediaProperties.ar}&quot;)
3283                         }
3284 
3285                         exec {
3286                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite&quot;)
3287                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=glib-lite&quot;)
3288                             args (&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
3289                         }
3290                     }
3291                 }
3292                 buildGStreamer.dependsOn buildGlib
3293             }
3294         }
3295 
3296         buildNativeTargets.dependsOn buildNative
3297     }
3298 
3299     jar {
3300         exclude(&quot;headergen/**&quot;)
3301 
3302         dependsOn compileJava
3303         if (IS_COMPILE_MEDIA) {
3304             dependsOn buildNativeTargets
3305         }
3306     }
3307 
3308     addMavenPublication(project, [ &#39;graphics&#39; ])
3309 
3310     addValidateSourceSets(project, sourceSets)
3311 }
3312 
3313 project(&quot;:web&quot;) {
3314     configurations {
3315         webkit
3316     }
3317     project.ext.buildModule = true
3318     project.ext.includeSources = true
3319     project.ext.moduleRuntime = true
3320     project.ext.moduleName = &quot;javafx.web&quot;
3321 
3322     sourceSets {
3323         main
3324         shims {
3325             java {
3326                 compileClasspath += sourceSets.main.output
3327                 runtimeClasspath += sourceSets.main.output
3328             }
3329         }
3330         test {
3331             java {
3332                 compileClasspath += sourceSets.shims.output
3333                 runtimeClasspath += sourceSets.shims.output
3334             }
3335         }
3336     }
3337 
3338     project.ext.moduleSourcePath = defaultModuleSourcePath
3339     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
3340 
3341     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;media&#39;, &#39;web&#39; ])
3342 
3343     dependencies {
3344         compile project(&quot;:base&quot;)
3345         compile project(&quot;:graphics&quot;)
3346         compile project(&quot;:controls&quot;)
3347         compile project(&quot;:media&quot;)
3348     }
3349 
3350     compileJava.dependsOn updateCacheIfNeeded
3351 
3352     task webArchiveJar(type: Jar) {
3353         from (project.file(&quot;$projectDir/src/test/resources/test/html&quot;)) {
3354             include &quot;**/archive-*.*&quot;
3355         }
3356         archiveName = &quot;webArchiveJar.jar&quot;
3357         destinationDir = file(&quot;$buildDir/testing/resources&quot;)
3358     }
3359 
3360     def gensrcDir = &quot;${buildDir}/gensrc/java&quot;
3361 
3362     // add in the wrappers to the compile
3363     sourceSets.main.java.srcDirs += &quot;${gensrcDir}&quot;
3364 
3365     if (IS_COMPILE_WEBKIT) {
3366         compileJava {
3367             // generate the native headers during compile
3368             // only needed if we are doing the native compile
3369             options.compilerArgs.addAll([
3370                 &#39;-h&#39;, &quot;${project.buildDir}/gensrc/headers&quot;
3371                 ])
3372         }
3373     }
3374 
3375     // Copy these to a common location in the moduleSourcePath
3376     def copyWrappers = project.task(&quot;copyPreGeneratedWrappers&quot;, type: Copy) {
3377         from &quot;src/main/native/Source/WebCore/bindings/java/dom3/java&quot;
3378         into &quot;${gensrcDir}&quot;
3379     }
3380 
3381     compileJava.dependsOn(copyWrappers);
3382 
3383     test {
3384         doFirst {
3385             if (!IS_COMPILE_WEBKIT) {
3386                 println &quot;*****************************************************&quot;
3387                 println &quot;WARNING: running web tests without building webkit.&quot;
3388                 println &quot;The webkit native library will be copied from the JDK,&quot;
3389                 println &quot;which might lead to failures in some web tests.&quot;
3390                 println &quot;To avoid these failures, you should either build&quot;
3391                 println &quot;webkit locally, copy the native webkit library from a&quot;
3392                 println &quot;recent build, or skip execution of web test cases with&quot;
3393                 println &quot;&#39;-x :web:test&#39;&quot;
3394                 println &quot;*****************************************************&quot;
3395             }
3396         }
3397         // Run web tests in headless mode
3398         systemProperty &#39;glass.platform&#39;, &#39;Monocle&#39;
3399         systemProperty &#39;monocle.platform&#39;, &#39;Headless&#39;
3400         systemProperty &#39;prism.order&#39;, &#39;sw&#39;
3401         dependsOn webArchiveJar
3402         def testResourceDir = file(&quot;$buildDir/testing/resources&quot;)
3403         jvmArgs &quot;-DWEB_ARCHIVE_JAR_TEST_DIR=$testResourceDir&quot;
3404     }
3405 
3406     task compileJavaDOMBinding()
3407 
3408     compileTargets { t -&gt;
3409         def targetProperties = project.rootProject.ext[t.upper]
3410         def webkitProperties = targetProperties.webkit
3411         def classifier = (t.name != &quot;linux&quot; &amp;&amp; t.name != &quot;win&quot;) ? t.name :
3412                           IS_64 ? &quot;${t.name}-amd64&quot; : &quot;${t.name}-i586&quot;
3413 
3414         def webkitOutputDir = cygpath(&quot;$buildDir/${t.name}&quot;)
3415         def webkitConfig = IS_DEBUG_NATIVE ? &quot;Debug&quot; : &quot;Release&quot;
3416 
3417         File nativeBuildDir = new File(&quot;${webkitOutputDir}&quot;)
3418         nativeBuildDir.mkdirs()
3419 
3420         def compileNativeTask = task(&quot;compileNative${t.capital}&quot;, dependsOn: [compileJava]) {
3421             println &quot;Building Webkit configuration /$webkitConfig/ into $webkitOutputDir&quot;
3422             enabled =  (IS_COMPILE_WEBKIT)
3423 
3424             doLast {
3425                 exec {
3426                     workingDir(&quot;$webkitOutputDir&quot;)
3427                     commandLine(&quot;perl&quot;, &quot;$projectDir/src/main/native/Tools/Scripts/set-webkit-configuration&quot;, &quot;--$webkitConfig&quot;)
3428                     environment([&quot;WEBKIT_OUTPUTDIR&quot; : webkitOutputDir])
3429                 }
3430 
3431                 exec {
3432                     workingDir(&quot;$webkitOutputDir&quot;)
3433                     def cmakeArgs = &quot;-DENABLE_TOOLS=1&quot;
3434                     cmakeArgs = &quot; $cmakeArgs -DCMAKE_C_COMPILER=&#39;${webkitProperties.compiler}&#39;&quot;
3435                     if (t.name == &quot;win&quot;) {
3436                         // To enable ninja build on Windows
3437                         environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3438                     } else if (t.name == &quot;mac&quot;) {
3439                         cmakeArgs = &quot; $cmakeArgs -DCMAKE_OSX_DEPLOYMENT_TARGET=$MACOSX_MIN_VERSION -DCMAKE_OSX_SYSROOT=$MACOSX_SDK_PATH&quot;
3440                     } else if (t.name == &quot;linux&quot;) {
3441                         cmakeArgs = &quot; $cmakeArgs -DCMAKE_SYSTEM_NAME=Linux&quot;
3442                         if (IS_64) {
3443                             cmakeArgs = &quot;$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=x86_64&quot;
3444                         } else {
3445                             cmakeArgs = &quot;$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=i586&quot;
3446                         }
3447                         // TODO: Use cflags and ldflags from all platforms
3448                         def cFlags = webkitProperties.ccFlags?.join(&#39; &#39;) ?: &#39;&#39;
3449                         def lFlags = webkitProperties.linkFlags?.join(&#39; &#39;) ?: &#39;&#39;
3450                         // -shared flag should be omitted while creating executable.
3451                         def exeFlags = webkitProperties.linkFlags?.join(&#39; &#39;)?.replace(&#39;-shared&#39;, &#39;&#39;) ?: &#39;&#39;
3452                         cmakeArgs = &quot;$cmakeArgs -DCMAKE_C_FLAGS=&#39;${cFlags}&#39; -DCMAKE_CXX_FLAGS=&#39;${cFlags}&#39;&quot;
3453                         cmakeArgs = &quot;$cmakeArgs -DCMAKE_SHARED_LINKER_FLAGS=&#39;${lFlags}&#39; -DCMAKE_EXE_LINKER_FLAGS=&#39;${exeFlags}&#39;&quot;
3454                     } else if (t.name.startsWith(&quot;arm&quot;)) {
3455                         fail(&quot;ARM target is not supported as of now.&quot;)
3456                     }
3457 
3458                     if (IS_COMPILE_PARFAIT) {
3459                         environment([
3460                             &quot;COMPILE_PARFAIT&quot; : &quot;true&quot;
3461                         ])
3462                         environment &quot;PATH&quot;, System.env.PARFAIT_PATH + File.pathSeparator + environment.PATH
3463                         cmakeArgs = &quot;-DCMAKE_C_COMPILER=parfait-gcc -DCMAKE_CXX_COMPILER=parfait-g++&quot;
3464                     }
3465 
3466                     if (project.hasProperty(&#39;toolsPath&#39;)) {
3467                         environment &quot;PATH&quot;, toolsPath + File.pathSeparator + environment.PATH
3468                     }
3469 
3470                     environment([
3471                         &quot;JAVA_HOME&quot;       : JDK_HOME,
3472                         &quot;WEBKIT_OUTPUTDIR&quot; : webkitOutputDir,
3473                         &quot;PYTHONDONTWRITEBYTECODE&quot; : &quot;1&quot;,
3474                     ])
3475 
3476                     def targetCpuBitDepthSwitch = &quot;&quot;
3477                     if (IS_64) {
3478                         targetCpuBitDepthSwitch = &quot;--64-bit&quot;
3479                     } else {
3480                         targetCpuBitDepthSwitch = &quot;--32-bit&quot;
3481                     }
3482                     cmakeArgs += &quot; -DJAVAFX_RELEASE_VERSION=${jfxReleaseMajorVersion}&quot;
3483                     commandLine(&quot;perl&quot;, &quot;$projectDir/src/main/native/Tools/Scripts/build-webkit&quot;,
3484                         &quot;--java&quot;, &quot;--icu-unicode&quot;, targetCpuBitDepthSwitch,
3485                         &quot;--no-experimental-features&quot;, &quot;--cmakeargs=${cmakeArgs}&quot;)
3486                 }
3487             }
3488         }
3489 
3490         // Cmake places Windows DLL in bin directory
3491         def dllDir = IS_WINDOWS ? &quot;bin&quot; : &quot;lib&quot;
3492         def copyDumpTreeNativeTask = task(&quot;copyDumpTreeNative${t.capital}&quot;, type: Copy,
3493                 dependsOn: [ compileNativeTask]) {
3494             def library = rootProject.ext[t.upper].library
3495             from &quot;$webkitOutputDir/$webkitConfig/$dllDir/${library(&#39;DumpRenderTreeJava&#39;)}&quot;
3496             into &quot;$buildDir/test/${t.name}&quot;
3497         }
3498 
3499         def copyNativeTask = task(&quot;copyNative${t.capital}&quot;, type: Copy,
3500                 dependsOn: [compileNativeTask, copyDumpTreeNativeTask]) {
3501             enabled =  (IS_COMPILE_WEBKIT)
3502             def library = rootProject.ext[t.upper].library
3503             from &quot;$webkitOutputDir/$webkitConfig/$dllDir/${library(&#39;jfxwebkit&#39;)}&quot;
3504             into &quot;$buildDir/libs/${t.name}&quot;
3505         }
3506 
3507         if (IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;) {
3508             def rcTask = project.task(&quot;rc${t.capital}&quot;, type: CompileResourceTask) {
3509                 compiler = webkitProperties.rcCompiler
3510                 source(webkitProperties.rcSource)
3511                 if (webkitProperties.rcFlags) {
3512                     rcParams.addAll(webkitProperties.rcFlags)
3513                 }
3514                 output(file(&quot;$webkitOutputDir/$webkitConfig/WebCore/obj&quot;))
3515             }
3516             compileNativeTask.dependsOn rcTask
3517         }
3518 
3519         def compileJavaDOMBindingTask = task(&quot;compileJavaDOMBinding${t.capital}&quot;, type: JavaCompile,
3520                 dependsOn: [compileJava, compileNativeTask, copyNativeTask]) {
3521             destinationDir = file(&quot;$buildDir/classes/java/main&quot;)
3522             classpath = configurations.compile
3523             source = project.sourceSets.main.java.srcDirs
3524             options.compilerArgs.addAll([
3525                 &#39;-implicit:none&#39;,
3526                 &#39;--module-source-path&#39;, defaultModuleSourcePath
3527                 ])
3528         }
3529 
3530         compileJavaDOMBinding.dependsOn compileJavaDOMBindingTask
3531 
3532         if (!targetProperties.compileWebnodeNative) {
3533             println(&quot;Not compiling native Webkit for ${t.name} per configuration request&quot;);
3534             compileNativeTask.enabled = false
3535         }
3536     }
3537 
3538     def drtClasses = &quot;**/com/sun/javafx/webkit/drt/**&quot;
3539     task drtJar(type: Jar, dependsOn: compileJava) {
3540         archiveName = &quot;drt.jar&quot;
3541         destinationDir = file(&quot;$buildDir/test&quot;)
3542         from &quot;$buildDir/classes/java/main/javafx.web/&quot;
3543         include drtClasses
3544         includeEmptyDirs = false
3545     }
3546 
3547     if (IS_COMPILE_WEBKIT) {
3548         assemble.dependsOn compileJavaDOMBinding, drtJar
3549     }
3550 
3551     addMavenPublication(project, [ &#39;controls&#39;, &#39;media&#39; ])
3552 
3553     addValidateSourceSets(project, sourceSets)
3554 }
3555 
3556 // This project is for system tests that need to run with a full SDK.
3557 // Most of them display a stage or do other things that preclude running
3558 // them in a shared JVM or as part of the &quot;smoke test&quot; run (which must
3559 // not pop up any windows or use audio). As such, they are only enabled
3560 // when FULL_TEST is specified, and each test runs in its own JVM
3561 project(&quot;:systemTests&quot;) {
3562 
3563     sourceSets {
3564         test
3565 
3566         // Source sets for standalone test apps (used for launcher tests)
3567         testapp1
3568 
3569         // Modular applications
3570         testapp2
3571         testapp3
3572         testapp4
3573         testapp5
3574         testapp6
3575     }
3576 
3577     def nonModSrcSets = [
3578         sourceSets.test,
3579         sourceSets.testapp1
3580     ]
3581 
3582     def modSrcSets = [
3583         sourceSets.testapp2,
3584         sourceSets.testapp3,
3585         sourceSets.testapp4,
3586         sourceSets.testapp5,
3587         sourceSets.testapp6
3588     ]
3589 
3590     project.ext.buildModule = false
3591     project.ext.moduleRuntime = false
3592     project.ext.moduleName = &quot;systemTests&quot;
3593 
3594     dependencies {
3595         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
3596         testCompile project(&quot;:base&quot;).sourceSets.test.output
3597         testCompile project(&quot;:controls&quot;).sourceSets.test.output
3598         testCompile project(&quot;:swing&quot;).sourceSets.test.output
3599     }
3600 
3601     def dependentProjects = [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;media&#39;, &#39;web&#39;, &#39;swing&#39;, &#39;fxml&#39; ]
3602     commonModuleSetup(project, dependentProjects)
3603 
3604     File testJavaPolicyFile = new File(rootProject.buildDir, TESTJAVAPOLICYFILE);
3605     File testRunArgsFile = new File(rootProject.buildDir,TESTRUNARGSFILE);
3606 
3607     File stRunArgsFile = new File(project.buildDir,&quot;st.run.args&quot;);
3608 
3609     def sts = task(&quot;systemTestSetup&quot;) {
3610         outputs.file(stRunArgsFile)
3611 
3612         doLast() {
3613             stRunArgsFile.delete()
3614 
3615             logger.info(&quot;Creating patchmodule.args file ${stRunArgsFile}&quot;)
3616 
3617             // Create an argfile with the information needed to launch
3618             // the stand alone system unit tests.
3619 
3620             //First add in all of the patch-module args we use for the
3621             //normal unit tests, copied from test.run.args
3622             testRunArgsFile.eachLine { str -&gt;
3623                 stRunArgsFile &lt;&lt;  &quot;${str}\n&quot;
3624             }
3625 
3626             // Now add in the working classpath elements (junit, test classes...)
3627             stRunArgsFile &lt;&lt;  &quot;-cp \&quot;\\\n&quot;
3628             test.classpath.each() { elem -&gt;
3629                 def e = cygpath(&quot;${elem}&quot;)
3630                 stRunArgsFile &lt;&lt;  &quot;  ${e}${File.pathSeparator}\\\n&quot;
3631             }
3632             stRunArgsFile &lt;&lt;  &quot;\&quot;\n&quot;
3633         }
3634     }
3635 
3636     test.dependsOn(sts)
3637     test.dependsOn(createTestArgfiles);
3638 
3639     // Tasks to create standalone test applications for the launcher tests
3640 
3641     if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3642         compileTestapp1Java.options.compilerArgs.addAll(testModulePathArgs)
3643     }
3644     dependentProjects.each { e -&gt;
3645         compileTestapp1Java.dependsOn(rootProject.project(e).testClasses)
3646     }
3647 
3648     def testapp1JarName = &quot;testapp1.jar&quot;
3649     task createTestapp1Jar1(type: Jar) {
3650         dependsOn compileTestapp1Java
3651         enabled = IS_FULL_TEST
3652 
3653         destinationDir = file(&quot;$buildDir/testapp1&quot;)
3654         archiveName = testapp1JarName
3655         includeEmptyDirs = false
3656         from project.sourceSets.testapp1.java.outputDir
3657         include(&quot;testapp/**&quot;)
3658         include(&quot;com/javafx/main/**&quot;)
3659 
3660         manifest {
3661             attributes(
3662                 &quot;Main-Class&quot; : &quot;com.javafx.main.Main&quot;,
3663                 &quot;JavaFX-Version&quot; : &quot;2.2&quot;,
3664                 &quot;JavaFX-Application-Class&quot; : &quot;testapp.HelloWorld&quot;,
3665                 &quot;JavaFX-Class-Path&quot; : &quot;jar2.jar&quot;
3666             )
3667         }
3668     }
3669 
3670     task createTestapp1Jar2(type: Jar) {
3671         dependsOn compileTestapp1Java
3672         enabled = IS_FULL_TEST
3673 
3674         destinationDir = file(&quot;$buildDir/testapp1&quot;)
3675         archiveName = &quot;jar2.jar&quot;;
3676         includeEmptyDirs = false
3677         from project.sourceSets.testapp1.java.outputDir
3678         include(&quot;pkg2/**&quot;)
3679     }
3680 
3681     task createTestApps() {
3682         dependsOn(createTestapp1Jar1)
3683         dependsOn(createTestapp1Jar2)
3684     }
3685     test.dependsOn(createTestApps);
3686 
3687     def modtestapps = [ &quot;testapp2&quot;, &quot;testapp3&quot;, &quot;testapp4&quot;, &quot;testapp5&quot;, &quot;testapp6&quot;  ]
3688     modtestapps.each { testapp -&gt;
3689         def testappCapital = testapp.capitalize()
3690         def copyTestAppTask = task(&quot;copy${testappCapital}&quot;, type: Copy) {
3691             from project.sourceSets.&quot;${testapp}&quot;.java.outputDir
3692             from project.sourceSets.&quot;${testapp}&quot;.output.resourcesDir
3693             into &quot;${project.buildDir}/modules/${testapp}&quot;
3694         }
3695 
3696         def List&lt;String&gt; testAppSourceDirs = []
3697         project.sourceSets.&quot;${testapp}&quot;.java.srcDirs.each { dir -&gt;
3698             testAppSourceDirs += dir
3699         }
3700         def testappCompileTasks = project.getTasksByName(&quot;compile${testappCapital}Java&quot;, true);
3701         def testappResourceTasks = project.getTasksByName(&quot;process${testappCapital}Resources&quot;, true);
3702         testappCompileTasks.each { appCompileTask -&gt;
3703             appCompileTask.options.compilerArgs.addAll([
3704                 &#39;-implicit:none&#39;,
3705                 &#39;--module-source-path&#39;, testAppSourceDirs.join(File.pathSeparator),
3706                 ] )
3707             if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3708                 appCompileTask.options.compilerArgs.addAll(testModulePathArgs)
3709             }
3710 
3711             dependentProjects.each { e -&gt;
3712                 appCompileTask.dependsOn(rootProject.project(e).testClasses)
3713             }
3714 
3715             copyTestAppTask.dependsOn(appCompileTask)
3716         }
3717         testappResourceTasks.each { appResourceTask -&gt;
3718             copyTestAppTask.dependsOn(appResourceTask)
3719         }
3720 
3721         createTestApps.dependsOn(copyTestAppTask)
3722     }
3723 
3724     test {
3725         enabled = IS_FULL_TEST
3726 
3727         // Parse testPatchModuleArgs looking for &quot;--module-path&quot;.
3728         // Save path if found so we can pass it to the module launcher tests
3729         def pendingModulePath = false
3730         testPatchModuleArgs.each { str -&gt;
3731             if (pendingModulePath) {
3732                 project.ext.launcherModulePath = str;
3733                 pendingModulePath = false
3734             } else if (str == &quot;--module-path&quot;) {
3735                 pendingModulePath = true
3736             }
3737         }
3738 
3739         // Properties passed to launcher tests
3740         systemProperty &quot;launchertest.testapp1.jar&quot;, &quot;build/testapp1/$testapp1JarName&quot;
3741         modtestapps.each { testapp -&gt;
3742             systemProperty &quot;launchertest.${testapp}.module.path&quot;,
3743                     &quot;${project.buildDir}/modules/${testapp}&quot;
3744         }
3745 
3746         // Properties passed to test.util.Util
3747         systemProperties &#39;worker.debug&#39;: IS_WORKER_DEBUG
3748         systemProperties &#39;worker.patchmodule.file&#39;: cygpath(stRunArgsFile.path)
3749         if (project.hasProperty(&quot;launcherModulePath&quot;)) {
3750             systemProperties &#39;worker.module.path&#39;: launcherModulePath
3751         }
3752         systemProperties &#39;worker.patch.policy&#39;: cygpath(testJavaPolicyFile.path)
3753         systemProperties &#39;worker.java.cmd&#39;: JAVA
3754 
3755         if (rootProject.hasProperty(&quot;ClipShapeTest.numTests&quot;)) {
3756             systemProperty &quot;ClipShapeTest.numTests&quot;, rootProject.getProperty(&quot;ClipShapeTest.numTests&quot;)
3757         }
3758 
3759         if (!IS_USE_ROBOT) {
3760             // Disable all robot-based visual tests
3761             exclude(&quot;test/robot/**&quot;);
3762         }
3763         if (!IS_UNSTABLE_TEST) {
3764             // JDK-8196607 Don&#39;t run monocle test cases 
3765             exclude(&quot;test/robot/com/sun/glass/ui/monocle/**&quot;);
3766         }
3767         if (!IS_AWT_TEST) {
3768             // Disable all AWT-based tests
3769             exclude(&quot;**/javafx/embed/swing/*.*&quot;);
3770             exclude(&quot;**/com/sun/javafx/application/Swing*.*&quot;);
3771         }
3772 
3773         forkEvery = 1
3774     }
3775 
3776     addValidateSourceSets(project, nonModSrcSets, modSrcSets)
3777 }
3778 
3779 allprojects {
3780     // The following block is a workaround for the fact that presently Gradle
3781     // can&#39;t set the -XDignore.symbol.file flag, because it appears that the
3782     // javac API is lacking support for it. So what we&#39;ll do is find any Compile
3783     // task and manually provide the options necessary to fire up the
3784     // compiler with the right settings.
3785     tasks.withType(JavaCompile) { compile -&gt;
3786         if (compile.options.hasProperty(&quot;useAnt&quot;)) {
3787             compile.options.useAnt = true
3788             compile.options.useDepend = IS_USE_DEPEND
3789         } else if (compile.options.hasProperty(&quot;incremental&quot;)) {
3790             compile.options.incremental = IS_INCREMENTAL
3791         }
3792         compile.options.debug = true // we always generate debugging info in the class files
3793         compile.options.debugOptions.debugLevel = IS_DEBUG_JAVA ? &quot;source,lines,vars&quot; : &quot;source,lines&quot;
3794         compile.options.fork = true
3795 
3796         compile.options.forkOptions.executable = JAVAC
3797 
3798         compile.options.warnings = IS_LINT
3799 
3800         compile.options.compilerArgs += [&quot;-XDignore.symbol.file&quot;, &quot;-encoding&quot;, &quot;UTF-8&quot;]
3801 
3802         // we use a custom javadoc command
3803         project.javadoc.enabled = false
3804 
3805         // Add in the -Xlint options
3806         if (IS_LINT) {
3807             LINT.split(&quot;[, ]&quot;).each { s -&gt;
3808                 compile.options.compilerArgs += &quot;-Xlint:$s&quot;
3809             }
3810         }
3811     } // tasks with javaCompile
3812 
3813     // If I am a module....
3814     if (project.hasProperty(&#39;moduleSourcePath&#39;) &amp;&amp;
3815             (project.hasProperty(&#39;buildModule&#39;) &amp;&amp; project.buildModule)) {
3816         project.compileJava {
3817             options.compilerArgs.addAll([
3818                 &#39;-implicit:none&#39;,
3819                 &#39;--module-source-path&#39;, project.moduleSourcePath
3820                 ])
3821         }
3822         // no jars needed for modules
3823         project.jar.enabled = false
3824 
3825         // and redirect the resources into the module
3826         project.sourceSets.main.output.resourcesDir = project.moduleDir
3827         project.processResources.destinationDir = project.moduleDir
3828     }
3829 
3830     if (project.hasProperty(&#39;moduleSourcePathShim&#39;) &amp;&amp;
3831             project.sourceSets.hasProperty(&#39;shims&#39;)) {
3832 
3833         // sync up the obvious source directories with the shims
3834         // others (like the shaders in graphics) should be added in there
3835         project.sourceSets.shims.java.srcDirs += project.sourceSets.main.java.srcDirs
3836         project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/java&quot;
3837 
3838         project.compileShimsJava {
3839             options.compilerArgs.addAll([
3840                 &#39;-implicit:none&#39;,
3841                 &#39;--module-source-path&#39;, project.moduleSourcePathShim
3842                 ])
3843         }
3844         project.compileShimsJava.dependsOn(project.compileJava)
3845 
3846         def copyGeneratedShimsTask = task(&quot;copyGeneratedShims&quot;, type: Copy, dependsOn: [compileShimsJava, processShimsResources]) {
3847             from project.sourceSets.shims.java.outputDir
3848             into &quot;${rootProject.buildDir}/shims&quot;
3849             if (HAS_JAVAFX_MODULES) {
3850                 exclude(&quot;*/module-info.class&quot;)
3851             }
3852         }
3853 
3854         project.processShimsResources.dependsOn(project.processResources)
3855 
3856         // shims resources should have the main resouces as a base
3857         project.sourceSets.shims.resources.srcDirs += project.sourceSets.main.resources.srcDirs
3858 
3859         // and redirect the resources into the module
3860         project.sourceSets.shims.output.resourcesDir = project.moduleShimsDir
3861         project.processShimsResources.destinationDir = project.moduleShimsDir
3862 
3863        compileTestJava.dependsOn(copyGeneratedShimsTask)
3864     }
3865 
3866     if (project.hasProperty(&#39;modulePathArgs&#39;)) {
3867         project.compileJava.options.compilerArgs.addAll(modulePathArgs)
3868     }
3869 
3870     if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3871         project.compileTestJava.options.compilerArgs.addAll(testModulePathArgs)
3872     }
3873 
3874     if (project.hasProperty(&#39;testPatchModuleArgs&#39;)) {
3875         project.test.jvmArgs += testPatchModuleArgs
3876     }
3877 
3878     /* Note: we should not have to add extraAddExports to the normal
3879      * modular compile, as it contains all of the module-info files.
3880      * In fact doing so might cover up a module-info issue.
3881      * so we don&#39;t do it, and I will leave this commented out
3882      * block as a reminder of this fact.
3883     if (project.hasProperty(&#39;extraAddExports&#39;)) {
3884         project.compileJava.options.compilerArgs.addAll(extraAddExports);
3885     }
3886     */
3887 
3888     if (project.hasProperty(&#39;testAddExports&#39;)) {
3889         project.compileTestJava.options.compilerArgs.addAll(testAddExports);
3890         project.test.jvmArgs += testAddExports
3891     }
3892 
3893     if (rootProject.hasProperty(&quot;EXTRA_TEST_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;test&#39;)) {
3894         EXTRA_TEST_ARGS.split(&#39; &#39;).each() { e -&gt;
3895             project.test.jvmArgs += e
3896         }
3897     }
3898 
3899     if (rootProject.hasProperty(&quot;EXTRA_COMPILE_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;compileJava&#39;)) {
3900         project.compileJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(&#39; &#39;))
3901     }
3902 
3903     if (rootProject.hasProperty(&quot;EXTRA_COMPILE_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;compileTestJava&#39;)) {
3904         project.compileTestJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(&#39; &#39;))
3905     }
3906 }
3907 
3908 /******************************************************************************
3909  *                                                                            *
3910  *                             Top Level Tasks                                *
3911  *                                                                            *
3912  *  These are the tasks which are defined only for the top level project and  *
3913  *  not for any sub projects. These are generally the entry point that is     *
3914  *  used by Hudson and by the continuous build system.                        *
3915  *                                                                            *
3916  *****************************************************************************/
3917 
3918 task clean() {
3919     group = &quot;Basic&quot;
3920     description = &quot;Deletes the build directory and the build directory of all sub projects&quot;
3921     getSubprojects().each { subProject -&gt;
3922         dependsOn(subProject.getTasksByName(&quot;clean&quot;, true));
3923     }
3924     doLast {
3925         delete(buildDir);
3926     }
3927 }
3928 
3929 task cleanAll() {
3930     group = &quot;Basic&quot;
3931     description = &quot;Scrubs the repo of build artifacts&quot;
3932     dependsOn(clean)
3933     doLast {
3934         //delete(&quot;.gradle&quot;); This causes problems on windows.
3935         delete(&quot;buildSrc/build&quot;);
3936     }
3937 }
3938 
3939 task createMSPfile() {
3940     group = &quot;Build&quot;
3941     File mspFile = new File(rootProject.buildDir,MODULESOURCEPATH)
3942     outputs.file(mspFile)
3943 
3944     doLast {
3945         mspFile.delete()
3946         mspFile &lt;&lt; &quot;--module-source-path\n&quot;
3947         mspFile &lt;&lt; defaultModuleSourcePath
3948         mspFile &lt;&lt; &quot;\n&quot;
3949     }
3950 }
3951 
3952 task javadoc(type: Javadoc, dependsOn: createMSPfile) {
3953     group = &quot;Basic&quot;
3954     description = &quot;Generates the JavaDoc for all the public API&quot;
3955     executable = JAVADOC
3956     def projectsToDocument = [
3957             project(&quot;:base&quot;), project(&quot;:graphics&quot;), project(&quot;:controls&quot;), project(&quot;:media&quot;),
3958             project(&quot;:swing&quot;), /*project(&quot;:swt&quot;),*/ project(&quot;:fxml&quot;), project(&quot;:web&quot;)]
3959     source(projectsToDocument.collect({
3960         [it.sourceSets.main.java]
3961     }));
3962     setDestinationDir(new File(buildDir, &#39;javadoc&#39;));
3963 
3964     exclude(&quot;com/**/*&quot;, &quot;Compile*&quot;, &quot;javafx/builder/**/*&quot;, &quot;javafx/scene/accessibility/**/*&quot;);
3965 
3966     options.tags(&quot;apiNote:a:API Note:&quot;)
3967     options.tags(&quot;implSpec:a:Implementation Requirements:&quot;)
3968     options.tags(&quot;implNote:a:Implementation Note:&quot;)
3969     options.tags(&quot;param&quot;)
3970     options.tags(&quot;return&quot;)
3971     options.tags(&quot;throws&quot;)
3972     options.tags(&quot;moduleGraph:X&quot;)
3973     options.tags(&quot;since&quot;)
3974     options.tags(&quot;version&quot;)
3975     options.tags(&quot;serialData&quot;)
3976     options.tags(&quot;factory&quot;)
3977     options.tags(&quot;see&quot;)
3978 
3979     options.windowTitle(&quot;${javadocTitle}&quot;)
3980     options.header(&quot;${javadocHeader}&quot;)
3981     options.bottom(&quot;${javadocBottom}&quot;)
3982     options.locale(&quot;en&quot;);
3983     if (JDK_DOCS_LINK != &quot;&quot;) {
3984         options.linksOffline(JDK_DOCS, JDK_DOCS_LINK);
3985     } else {
3986         options.links(JDK_DOCS);
3987     }
3988     options.addBooleanOption(&quot;XDignore.symbol.file&quot;).setValue(true);
3989     options.addBooleanOption(&quot;Xdoclint:${DOC_LINT}&quot;).setValue(IS_DOC_LINT);
3990     options.addBooleanOption(&quot;html5&quot;).setValue(true);
3991     options.addBooleanOption(&quot;javafx&quot;).setValue(true);
3992     options.addBooleanOption(&quot;use&quot;).setValue(true);
3993 
3994     options.setOptionFiles([
3995         new File(rootProject.buildDir,MODULESOURCEPATH)
3996         ]);
3997 
3998     doLast {
3999         projectsToDocument.each { p -&gt;
4000             def destDir = &quot;$buildDir/javadoc/${p.ext.moduleName}&quot;
4001             copy {
4002                 from(&quot;$p.projectDir/src/main/docs&quot;) {
4003                     include &quot;**/*.html&quot;
4004                     filter { line-&gt;
4005                         line = line.replace(&quot;@FXVERSION@&quot;, RELEASE_VERSION)
4006                     }
4007                 }
4008                 from(&quot;$p.projectDir/src/main/docs&quot;) {
4009                     exclude &quot;**/*.html&quot;
4010                 }
4011 
4012                 into destDir
4013             }
4014         }
4015     }
4016 
4017     dependsOn(projectsToDocument.collect { project -&gt; project.getTasksByName(&quot;classes&quot;, true)});
4018 }
4019 
4020 task sdk() {
4021     if (DO_BUILD_SDK_FOR_TEST) {
4022         rootProject.getTasksByName(&quot;test&quot;, true).each { t -&gt;
4023             if (t.enabled) t.dependsOn(sdk)
4024         }
4025     }
4026 }
4027 
4028 task jmods() {
4029     dependsOn(sdk)
4030     // real work items added later.
4031 }
4032 
4033 task appsjar() {
4034     dependsOn(sdk)
4035     // Note: the jar dependencies get added elsewhere see project(&quot;:apps&quot;)
4036 }
4037 
4038 // these are empty tasks, allowing us to depend on the task, which may have other
4039 // real work items added later.
4040 task copyAppsArtifacts() {
4041     dependsOn(appsjar)
4042 }
4043 
4044 task apps() {
4045     dependsOn(sdk)
4046     dependsOn(appsjar)
4047     dependsOn(copyAppsArtifacts)
4048 }
4049 
4050 task findbugs() {
4051     dependsOn(sdk)
4052 
4053     doLast {
4054         if (!BUILD_CLOSED) {
4055             println &quot;findbugs task is only run for a closed build&quot;
4056         }
4057     }
4058 }
4059 
4060 // create the zip file of modules for a JDK build
4061 task jdkZip {
4062     dependsOn(sdk)
4063 }
4064 
4065 // The following tasks are for the closed build only. They are a no-op for the open build
4066 
4067 task checkCache() {
4068     dependsOn(updateCacheIfNeeded)
4069 }
4070 
4071 task publicExports() {
4072     dependsOn(sdk, jmods, apps, javadoc, jdkZip)
4073     // note the real work is below in the compileTargets
4074 }
4075 
4076 task perf() {
4077     dependsOn(sdk, apps)
4078     doLast {
4079         if (!BUILD_CLOSED) {
4080             println &quot;perf task is only run for a closed build&quot;
4081         }
4082     }
4083 }
4084 
4085 task zips() {
4086     dependsOn(sdk, jmods, javadoc, apps, jdkZip, publicExports, perf)
4087     // note the real work is below in the compileTargets
4088 }
4089 
4090 task all() {
4091     dependsOn(sdk,publicExports,apps,perf,zips)
4092 }
4093 
4094 
4095 // Construct list of subprojects that are modules
4096 ext.moduleProjList = []
4097 subprojects {
4098     if (project.hasProperty(&quot;buildModule&quot;) &amp;&amp; project.ext.buildModule) {
4099         rootProject.ext.moduleProjList += project
4100         println &quot;module: $project (buildModule=YES)&quot;
4101     } else {
4102         println &quot;module: $project (buildModule=NO)&quot;
4103     }
4104 }
4105 
4106 
4107 // Define the sdk task, which also produces the javafx.swt modular jar
4108 
4109 compileTargets { t -&gt;
4110 
4111     def javafxSwtTask = task(&quot;javafxSwt$t.capital&quot;, type: Jar) {
4112         enabled = COMPILE_SWT
4113         group = &quot;Basic&quot;
4114         description = &quot;Creates the javafx-swt.jar for the $t.name target&quot;
4115         destinationDir = file(&quot;${project(&quot;:swt&quot;).buildDir}/libs&quot;)
4116         archiveName = &quot;javafx-swt.jar&quot;
4117         includeEmptyDirs = false
4118         from(&quot;${project(&quot;:swt&quot;).buildDir}/classes/java/main&quot;);
4119         include(&quot;**/javafx/embed/swt/**&quot;)
4120 
4121         dependsOn(
4122             project(&quot;:swt&quot;).compileJava,
4123             project(&quot;:swt&quot;).processResources,
4124             // note: assemble and classes are not enough for DidWork
4125             project(&quot;:swt&quot;).classes,
4126             // classes is needed for a jar copy
4127             )
4128     }
4129 
4130     // FIXME: do we really need the index task for this modular jar?
4131     def javafxSwtIndexTask = task(&quot;javafxSwtIndex$t.capital&quot;) {
4132         //the following is a workaround for the lack of indexing in gradle 1.4 through 1.7
4133         dependsOn(javafxSwtTask)
4134 
4135         doLast() {
4136             ant.jar (update: true, index: true, destfile: &quot;${javafxSwtTask.destinationDir}/${javafxSwtTask.archiveName}&quot;)
4137         }
4138     }
4139 
4140     def sdkTask = task(&quot;sdk$t.capital&quot;) {
4141         group = &quot;Basic&quot;
4142         dependsOn(javafxSwtIndexTask)
4143     }
4144 
4145     sdk.dependsOn(sdkTask)
4146 }
4147 
4148 project(&quot;:apps&quot;) {
4149     // The apps build is Ant based, we will exec ant from gradle.
4150 
4151     // Download the Lucene libraries needed for the Ensemble8 app
4152     def luceneVersion = &quot;7.7.1&quot;
4153     getConfigurations().create(&quot;lucene&quot;);
4154     dependencies {
4155         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-core&quot;, version: luceneVersion
4156         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-grouping&quot;, version: luceneVersion
4157         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-queryparser&quot;, version: luceneVersion
4158     }
4159 
4160     // Copy Lucene libraries into the Ensemble8/lib directory
4161     File ensembleLibDir = rootProject.file(&quot;apps/samples/Ensemble8/lib&quot;);
4162     def libNames = [ &quot;lucene-core-${luceneVersion}.jar&quot;,
4163                      &quot;lucene-grouping-${luceneVersion}.jar&quot;,
4164                      &quot;lucene-queryparser-${luceneVersion}.jar&quot; ]
4165 
4166 
4167     task getLucene(type: Copy) {
4168         doFirst {
4169             ensembleLibDir.mkdirs();
4170         }
4171         into ensembleLibDir
4172         includeEmptyDirs = false
4173         configurations.lucene.files.each { f -&gt;
4174             libNames.each { name -&gt;
4175                 if (name == f.getName()) {
4176                     from f.getPath()
4177                 }
4178             }
4179         }
4180     }
4181 
4182     compileTargets { t -&gt;
4183         List&lt;String&gt; params = []
4184 
4185         params &lt;&lt; &quot;-DtargetBld=$t.name&quot;
4186 
4187         if (!rootProject.ext[t.upper].compileSwing) {
4188             params &lt;&lt; &quot;-DJFX_CORE_ONLY=true&quot;
4189         }
4190         params &lt;&lt; &quot;-Dplatforms.JDK_1.9.home=${rootProject.ext.JDK_HOME}&quot;
4191         params &lt;&lt; &quot;-Dcompile.patch=@${rootProject.buildDir}/${COMPILEARGSFILE}&quot;
4192         params &lt;&lt; &quot;-Drun.patch=@${rootProject.buildDir}/${RUNARGSFILE}&quot;
4193 
4194         def appsJar = project.task(&quot;appsJar${t.capital}&quot;) {
4195             dependsOn(sdk, getLucene)
4196             doLast() {
4197                 ant(t.name,
4198                       projectDir.path,
4199                       &quot;appsJar&quot;,
4200                       params);
4201             }
4202         }
4203         rootProject.appsjar.dependsOn(appsJar)
4204 
4205         def appsClean = project.task(&quot;clean${t.capital}&quot;) {
4206             doLast() {
4207                 ant(t.name,
4208                       project.projectDir.path,
4209                       &quot;clean&quot;,
4210                       params);
4211                 delete(ensembleLibDir);
4212             }
4213         }
4214         rootProject.clean.dependsOn(appsClean)
4215     }
4216 }
4217 
4218 // Tasks to create the disk layout for the sdk, jmods, and docs
4219 // in the artifacts directory (publicExports), and zip them up in
4220 // artifacts/bundles (zips)
4221 // These tasks are only used for the standalone SDK.
4222 compileTargets { t -&gt;
4223     if (!HAS_JAVAFX_MODULES) {
4224         def targetProperties = rootProject.ext[t.upper]
4225         def platformPrefix = targetProperties.platformPrefix
4226 
4227         def artifactsDir = &quot;${rootProject.buildDir}/artifacts&quot;
4228         def bundlesDir = &quot;${artifactsDir}/bundles&quot;
4229 
4230         def sdkDirName = &quot;${platformPrefix}sdk&quot;
4231         def sdkDir = &quot;${rootProject.buildDir}/${sdkDirName}&quot;
4232         def sdkBundleName = &quot;javafx-sdk-${RELEASE_VERSION}&quot;
4233         def sdkArtifactsDir = &quot;${artifactsDir}/${sdkBundleName}&quot;
4234 
4235         def docsDirName = &quot;javadoc&quot;
4236         def docsDir = &quot;${rootProject.buildDir}/${docsDirName}&quot;
4237         def docsBundleName = &quot;javafx-docs-${RELEASE_VERSION}&quot;
4238         def docsArtifactsDir = &quot;${artifactsDir}/${docsBundleName}&quot;
4239 
4240         def jmodsDirName = &quot;jmods&quot;
4241         def jmodsDir = &quot;${rootProject.buildDir}/${jmodsDirName}&quot;
4242         def jmodsBundleName = &quot;javafx-jmods-${RELEASE_VERSION}&quot;
4243         def jmodsArtifactsDir = &quot;${artifactsDir}/${jmodsBundleName}&quot;
4244 
4245         def publicExportsTask = task (&quot;publicExportsStandalone${t.capital}&quot;) {
4246             group = &quot;Basic&quot;
4247             description = &quot;Creates the disk layout for sdk, jmods, and docs&quot;
4248         }
4249         publicExports.dependsOn(publicExportsTask)
4250 
4251         def copyArtifactsSdkTask = task(&quot;copyArtifactsSdk$t.capital&quot;, type: Copy, dependsOn: [sdk,jmods,apps,javadoc]) {
4252             from sdkDir
4253             into sdkArtifactsDir
4254         }
4255         publicExportsTask.dependsOn(copyArtifactsSdkTask)
4256 
4257         // Need to modify file permissions Windows to make sure that the
4258         // execute bit is set, and that the files are world readable
4259         def chmodArtifactsSdkTask = task(&quot;chmodArtifactsSdk$t.capital&quot;, dependsOn: copyArtifactsSdkTask) {
4260             if (IS_WINDOWS &amp;&amp; IS_USE_CYGWIN) {
4261                 doLast {
4262                     exec {
4263                         workingDir(sdkArtifactsDir)
4264                         commandLine(&quot;chmod&quot;, &quot;-R&quot;, &quot;755&quot;, &quot;.&quot;)
4265                     }
4266                 }
4267             }
4268         }
4269         publicExportsTask.dependsOn(chmodArtifactsSdkTask)
4270 
4271         def copyArtifactsDocsTask = task(&quot;copyArtifactsDocs$t.capital&quot;, type: Copy, dependsOn: chmodArtifactsSdkTask) {
4272             from docsDir
4273             into &quot;${docsArtifactsDir}/api&quot;
4274         }
4275         publicExportsTask.dependsOn(copyArtifactsDocsTask)
4276 
4277         def copyArtifactsJmodsTask = task(&quot;copyArtifactsJmods$t.capital&quot;, type: Copy, dependsOn: copyArtifactsDocsTask) {
4278             from jmodsDir
4279             into &quot;${jmodsArtifactsDir}&quot;
4280         }
4281         publicExportsTask.dependsOn(copyArtifactsJmodsTask)
4282 
4283         def zipsTask = task (&quot;zipsStandalone${t.capital}&quot;) {
4284             group = &quot;Basic&quot;
4285             description = &quot;Creates the public zip bundles&quot;
4286         }
4287         zips.dependsOn(zipsTask)
4288 
4289         // Use native zip tool so that file permissions are preserved on Windows
4290         def zipSdkTask = task(&quot;zipSdk$t.capital&quot;, dependsOn: publicExportsTask) {
4291             doLast {
4292                 def outZipFile = &quot;${bundlesDir}/${sdkBundleName}.zip&quot;
4293                 mkdir bundlesDir
4294                 exec {
4295                     workingDir(artifactsDir)
4296                     commandLine(&quot;zip&quot;, &quot;-q&quot;, &quot;-r&quot;, outZipFile, sdkBundleName)
4297                 }
4298             }
4299         }
4300         zipsTask.dependsOn(zipSdkTask)
4301 
4302         def zipDocsTask = task(&quot;zipDocs$t.capital&quot;, type: Zip, dependsOn: zipSdkTask) {
4303             destinationDir = file(&quot;${bundlesDir}&quot;)
4304             archiveName = &quot;${docsBundleName}.zip&quot;
4305             includeEmptyDirs = false
4306             from docsArtifactsDir
4307             into &quot;${docsBundleName}&quot;
4308         }
4309         zipsTask.dependsOn(zipDocsTask)
4310 
4311         def zipJmodsTask = task(&quot;zipJmods$t.capital&quot;, type: Zip, dependsOn: zipDocsTask) {
4312             destinationDir = file(&quot;${bundlesDir}&quot;)
4313             archiveName = &quot;${jmodsBundleName}.zip&quot;
4314             includeEmptyDirs = false
4315             from jmodsArtifactsDir
4316             into &quot;${jmodsBundleName}&quot;
4317         }
4318         zipsTask.dependsOn(zipJmodsTask)
4319     }
4320 }
4321 
4322 
4323 /******************************************************************************
4324  *                                                                            *
4325  *                               Modules                                      *
4326  *                                                                            *
4327  *****************************************************************************/
4328 
4329 ext.moduleDependencies = [file(&quot;dependencies&quot;)]
4330 
4331 task buildModules {
4332 }
4333 
4334 // Combine the classes, lib, and bin for each module
4335 compileTargets { t -&gt;
4336     def targetProperties = project.ext[t.upper]
4337 
4338     def platformPrefix = targetProperties.platformPrefix
4339     def bundledSdkDirName = &quot;${platformPrefix}modular-sdk&quot;
4340     def bundledSdkDir = &quot;${rootProject.buildDir}/${bundledSdkDirName}&quot;
4341     def modulesDir = &quot;${bundledSdkDir}/modules&quot;
4342     def modulesCmdsDir = &quot;${bundledSdkDir}/modules_cmds&quot;
4343     def modulesLibsDir = &quot;${bundledSdkDir}/modules_libs&quot;
4344     def modulesSrcDir = &quot;${bundledSdkDir}/modules_src&quot;
4345     def modulesConfDir = &quot;${bundledSdkDir}/modules_conf&quot;
4346     def modulesLegalDir = &quot;${bundledSdkDir}/modules_legal&quot;
4347     def modulesMakeDir = &quot;${bundledSdkDir}/make&quot;
4348 
4349     final File runArgsFile = file(&quot;${rootProject.buildDir}/${RUNARGSFILE}&quot;)
4350     final File compileArgsFile = file(&quot;${rootProject.buildDir}/${COMPILEARGSFILE}&quot;)
4351 
4352     project.files(runArgsFile);
4353 
4354     def buildModulesTask = task(&quot;buildModules$t.capital&quot;, group: &quot;Build&quot;) {
4355         // BUNDLED SDK
4356 
4357         // Copy dependencies/*/module-info.java.extra
4358         // merging as needed, removing duplicates
4359         // only lines with &#39;exports&#39; will be copied
4360         def dependencyRoots = moduleDependencies
4361         if (rootProject.hasProperty(&quot;closedModuleDepedencies&quot;)) {
4362             dependencyRoots = [dependencyRoots, closedModuleDepedencies].flatten()
4363         }
4364 
4365         // Create the inputs/outputs list first to support UP-TO-DATE
4366         ArrayList outputNames = new ArrayList()
4367         dependencyRoots.each { root -&gt;
4368             FileTree ft = fileTree(root).include(&#39;**/*.extra&#39;)
4369             ft.each() { e-&gt;
4370                 inputs.file(e)
4371 
4372                 String usename = e.path
4373                 String filePath = e.getAbsolutePath()
4374                 String folderPath = root.getAbsolutePath()
4375                 if (filePath.startsWith(folderPath)) {
4376                     usename = filePath.substring(folderPath.length() + 1);
4377                 }
4378                 if (! outputNames.contains(usename) ) {
4379                     outputNames.add(usename)
4380                 }
4381             }
4382         }
4383 
4384         outputNames.each() { e-&gt;
4385                 File f = new File(modulesSrcDir, e)
4386                 outputs.file(f)
4387         }
4388 
4389         def outputPolicyDir = &quot;${modulesConfDir}/java.base/security&quot;
4390         def outputPolicyFile = file(&quot;${outputPolicyDir}/java.policy.extra&quot;)
4391 
4392         outputs.file(outputPolicyFile)
4393         moduleProjList.each { project -&gt;
4394             def policyDir = &quot;${project.projectDir}/src/main/conf/security&quot;
4395             def policyFile = file(&quot;${policyDir}/java.policy&quot;)
4396             if (policyFile.exists()) {
4397                 inputs.file(policyFile)
4398             }
4399         }
4400 
4401         doLast {
4402             Map extras = [:]
4403 
4404             dependencyRoots.each { root -&gt;
4405                 FileTree ft = fileTree(root).include(&#39;**/*.extra&#39;)
4406                 ft.each() { e-&gt;
4407                     String usename = e.path
4408                     String filePath = e.getAbsolutePath()
4409                     String folderPath = root.getAbsolutePath()
4410                     if (filePath.startsWith(folderPath)) {
4411                         usename = filePath.substring(folderPath.length() + 1);
4412                     }
4413                     if (extras.containsKey(usename)) {
4414                         List&lt;String&gt; lines = extras.get(usename)
4415                         e.eachLine { line -&gt;
4416                             line = line.trim()
4417                             if (line.length() &gt; 1 &amp;&amp; Character.isLetter(line.charAt(0))) {
4418                                 lines &lt;&lt; line
4419                             }
4420                         }
4421 
4422                     } else {
4423                         List&lt;String&gt; lines = []
4424                         e.eachLine { line -&gt;
4425                             line = line.trim()
4426                             if (line.length() &gt; 1 &amp;&amp; Character.isLetter(line.charAt(0))) {
4427                                 lines &lt;&lt; line
4428                             }
4429                         }
4430                         extras.put(usename,lines)
4431                     }
4432                 }
4433             }
4434             extras.keySet().each() { e-&gt;
4435                 File f = new File(modulesSrcDir, e)
4436                 f.getParentFile().mkdirs()
4437                 f.delete()
4438 
4439                 extras.get(e).unique().each() { l-&gt;
4440                     f &lt;&lt; l
4441                     f &lt;&lt; &quot;\n&quot;
4442                 }
4443             }
4444 
4445             // concatecate java.policy files into a single file
4446             //
4447             mkdir outputPolicyDir
4448             outputPolicyFile.delete()
4449             moduleProjList.each { project -&gt;
4450                 def policyDir = &quot;${project.projectDir}/src/main/conf/security&quot;
4451                 def policyFile = file(&quot;${policyDir}/java.policy&quot;)
4452                 if (policyFile.exists()) outputPolicyFile &lt;&lt; policyFile.text
4453             }
4454         }
4455     }
4456     buildModules.dependsOn(buildModulesTask)
4457 
4458     // BUNDLED SDK
4459     moduleProjList.each { project -&gt;
4460         // Copy classes, bin, and lib directories
4461 
4462         def moduleName = project.ext.moduleName
4463         def buildDir = project.buildDir
4464 
4465         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4466         def dstClassesDir = &quot;${modulesDir}/${moduleName}&quot;
4467         def copyClassFilesTask = project.task(&quot;copyClassFiles$t.capital&quot;, type: Copy, dependsOn: project.assemble) {
4468             from srcClassesDir
4469             into dstClassesDir
4470             exclude(&quot;module-info.class&quot;)
4471         }
4472 
4473         def srcCmdsDir = &quot;${buildDir}/${platformPrefix}module-bin&quot;
4474         def dstCmdsDir = &quot;${modulesCmdsDir}/${moduleName}&quot;
4475         def copyBinFilesTask = project.task(&quot;copyBinFiles$t.capital&quot;, type: Copy, dependsOn: copyClassFilesTask) {
4476             from srcCmdsDir
4477             into dstCmdsDir
4478         }
4479 
4480         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4481         def dstLibsDir = &quot;${modulesLibsDir}/${moduleName}&quot;
4482         def copyLibFilesTask = project.task(&quot;copyLibFiles$t.capital&quot;, type: Copy, dependsOn: copyBinFilesTask) {
4483             from srcLibsDir
4484             into dstLibsDir
4485         }
4486 
4487         // Copy module sources
4488         // FIXME: javafx.swt sources?
4489         def copySources = project.hasProperty(&quot;includeSources&quot;) &amp;&amp; project.includeSources
4490         def copySourceFilesTask = project.task(&quot;copySourceFiles$t.capital&quot;, type: Copy, dependsOn: copyLibFilesTask) {
4491             if (copySources) {
4492                 from &quot;${project.projectDir}/src/main/java&quot;
4493                 if (project.name.equals(&quot;base&quot;)) {
4494                     from &quot;${project.projectDir}/build/gensrc/java&quot;
4495                 }
4496                 if (project.name.equals(&quot;web&quot;)) {
4497                     from &quot;${project.projectDir}/src/main/native/Source/WebCore/bindings/java/dom3/java&quot;
4498                 }
4499             } else {
4500                 from &quot;${project.projectDir}/src/main/java/module-info.java&quot;
4501             }
4502             into &quot;${modulesSrcDir}/${moduleName}&quot;
4503             include &quot;**/*.java&quot;
4504 
4505             if (project.hasProperty(&quot;sourceFilter&quot;)) {
4506                 filter(project.sourceFilter)
4507             }
4508         }
4509 
4510         // Copy .html and other files needed for doc bundles
4511         def copyDocFiles = project.task(&quot;copyDocFiles$t.capital&quot;, type: Copy, dependsOn: copySourceFilesTask) {
4512             if (copySources) {
4513                 from(&quot;${project.projectDir}/src/main/docs&quot;) {
4514                     include &quot;**/*.html&quot;
4515                     filter { line-&gt;
4516                         line = line.replace(&quot;@FXVERSION@&quot;, RELEASE_VERSION)
4517                     }
4518                 }
4519                 from(&quot;${project.projectDir}/src/main/docs&quot;) {
4520                     exclude &quot;**/*.html&quot;
4521                 }
4522                 from(&quot;${project.projectDir}/src/main/java&quot;) {
4523                     exclude &quot;**/*.java&quot;
4524                 }
4525 
4526                 into &quot;${modulesSrcDir}/${moduleName}&quot;
4527             }
4528         }
4529 
4530         // Copy make/build.properties
4531         def srcMakeDir = &quot;${project.projectDir}/make&quot;
4532         def dstMakeDir = &quot;${modulesMakeDir}/${moduleName}&quot;
4533         def copyBuildPropertiesTask = project.task(&quot;copyBuildProperties$t.capital&quot;, type: Copy, dependsOn: copyDocFiles) {
4534             from srcMakeDir
4535             into dstMakeDir
4536         }
4537 
4538         // Copy legal files
4539         def srcLegalDir = &quot;${project.projectDir}/src/main/legal&quot;
4540         def dstLegalDir = &quot;${modulesLegalDir}/${moduleName}&quot;
4541         def copyLegalTask = project.task(&quot;copyLegal$t.capital&quot;, type: Copy, dependsOn: copyBuildPropertiesTask) {
4542             from srcLegalDir
4543             into dstLegalDir
4544 
4545             // Exclude ANGLE since we (currently) do not use it
4546             exclude(&quot;angle.md&quot;)
4547         }
4548 
4549         buildModulesTask.dependsOn(
4550             copyClassFilesTask,
4551             copyLibFilesTask,
4552             copySourceFilesTask,
4553             copyDocFiles,
4554             copyBuildPropertiesTask,
4555             copyLegalTask)
4556     }
4557 
4558     // ============================================================
4559 
4560     def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
4561     def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
4562     def standaloneLibDir = &quot;${standaloneSdkDir}/lib&quot;
4563     def libDest=targetProperties.libDest
4564     def standaloneNativeDir = &quot;${standaloneSdkDir}/${libDest}&quot;
4565     def standaloneLegalDir = &quot;${standaloneSdkDir}/legal&quot;
4566     def standaloneSrcZipName = &quot;src.zip&quot;
4567 
4568     // STANDALONE SDK
4569     moduleProjList.each { project -&gt;
4570         // Copy classes, bin, and lib directories
4571 
4572         def moduleName = project.ext.moduleName
4573         def buildDir = project.buildDir
4574 
4575         // Create modular jars
4576         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4577         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4578         def dstModularJarDir = &quot;${standaloneLibDir}&quot;
4579         def modularJarName = &quot;${moduleName}.jar&quot;
4580         def modularJarTask = project.task(&quot;modularJarStandalone$t.capital&quot;, type: Jar, dependsOn: project.assemble) {
4581             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4582             archiveName = modularJarName
4583             includeEmptyDirs = false
4584             from srcClassesDir
4585         }
4586 
4587         // Copy native libraries
4588         def srcNativeDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4589         def dstNativeDir = &quot;${standaloneNativeDir}&quot;
4590         def copyNativeFilesTask = project.task(&quot;copyNativeFilesStandalone$t.capital&quot;, type: Copy, dependsOn: modularJarTask) {
4591             from srcNativeDir
4592             into dstNativeDir
4593             include(&quot;*.dll&quot;)
4594         }
4595 
4596         // Copy other lib files
4597         def dstLibsDir = &quot;${standaloneLibDir}&quot;
4598         def copyLibFilesTask = project.task(&quot;copyLibFilesStandalone$t.capital&quot;, type: Copy, dependsOn: copyNativeFilesTask) {
4599             from srcLibsDir
4600             into dstLibsDir
4601             exclude(&quot;*.dll&quot;)
4602         }
4603 
4604         // Copy legal files
4605         def licenseFiles = [ &quot;ADDITIONAL_LICENSE_INFO&quot;, &quot;ASSEMBLY_EXCEPTION&quot;, &quot;LICENSE&quot; ]
4606         def srcLegalDir = &quot;${project.projectDir}/src/main/legal&quot;
4607         def dstLegalDir = &quot;${standaloneLegalDir}/${moduleName}&quot;
4608         def copyLegalTask = project.task(&quot;copyLegalStandalone$t.capital&quot;, type: Copy, dependsOn: copyLibFilesTask) {
4609 
4610             def rtDir = rootProject.file(&#39;.&#39;)
4611             licenseFiles.each { lFile -&gt;
4612                 from &quot;${rtDir}/${lFile}&quot;
4613             }
4614 
4615             from srcLegalDir
4616 
4617             into dstLegalDir
4618 
4619             // Exclude ANGLE since we (currently) do not use it
4620             exclude(&quot;angle.md&quot;)
4621         }
4622 
4623         buildModulesTask.dependsOn(
4624             modularJarTask,
4625             copyNativeFilesTask,
4626             copyLibFilesTask,
4627             copyLegalTask)
4628     }
4629 
4630     // Zip module sources for standalone SDK
4631     //
4632     // NOTE: the input is taken from the modular-sdk/modules_src dir
4633     // so that we don&#39;t have to duplicate the logic and create another
4634     // temporary directory. This is somewhat inelegant, since the bundled sdk
4635     // and the standalone sdk should be independent of one another, but seems
4636     // better than the alternatives.
4637     def zipSourceFilesTask = project.task(&quot;zipSourceFilesStandalone$t.capital&quot;, type: Zip, dependsOn: buildModulesTask) {
4638         destinationDir = file(&quot;${standaloneLibDir}&quot;)
4639         archiveName = standaloneSrcZipName
4640         includeEmptyDirs = false
4641         from modulesSrcDir
4642         include &quot;**/*.java&quot;
4643     }
4644     buildModules.dependsOn(zipSourceFilesTask)
4645 
4646     // ============================================================
4647 
4648     // Maven Publications
4649     def publicationDirName = &quot;${platformPrefix}publications&quot;
4650     def publicationDir = &quot;${rootProject.buildDir}/${publicationDirName}&quot;
4651 
4652     moduleProjList.each { project -&gt; 
4653         // Create publications to be uploaded 
4654 
4655         def moduleName = project.ext.moduleName
4656         def buildDir = project.buildDir
4657 
4658         def dstModularJarDir=&quot;${publicationDir}&quot;
4659         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4660         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4661 
4662         def modularEmptyPublicationJarName = &quot;${moduleName}.jar&quot;
4663         def modularEmptyPublicationJarTask = project.task(&quot;moduleEmptyPublicationJar${t.capital}&quot;, type: Jar) {
4664             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4665             archiveName = modularEmptyPublicationJarName
4666             manifest {
4667                 attributes(
4668                     &#39;Automatic-Module-Name&#39;:&quot;${moduleName}Empty&quot;
4669                 )
4670             }
4671         }
4672 
4673         def modularPublicationJarName = &quot;${moduleName}-${t.name}.jar&quot;
4674         def modularPublicationJarTask = project.task(&quot;modularPublicationJar${t.capital}&quot;, type: Jar, dependsOn: modularEmptyPublicationJarTask) {
4675             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4676             archiveName = modularPublicationJarName
4677             from srcLibsDir
4678             from srcClassesDir
4679         }
4680 
4681         buildModulesTask.dependsOn(modularPublicationJarTask)
4682 
4683     }
4684     // ============================================================
4685 
4686     def buildRunArgsTask = task(&quot;buildRunArgs$t.capital&quot;,
4687             group: &quot;Build&quot;, dependsOn: buildModulesTask) {
4688         outputs.file(runArgsFile);
4689         inputs.file(EXTRAADDEXPORTS);
4690         doLast() {
4691             List&lt;String&gt;modpath = []
4692             List&lt;String&gt;modnames = []
4693 
4694             moduleProjList.each { project -&gt;
4695                 def moduleName = project.ext.moduleName
4696                 def dstModuleDir = cygpath(&quot;${modulesDir}/${moduleName}&quot;)
4697                 if (HAS_JAVAFX_MODULES) {
4698                     modpath &lt;&lt;  &quot;${moduleName}=${dstModuleDir}&quot;
4699                 } else {
4700                     modnames &lt;&lt; moduleName
4701                 }
4702             }
4703 
4704             if (HAS_JAVAFX_MODULES) {
4705                 writeRunArgsFile(runArgsFile, computeLibraryPath(true), modpath, null)
4706                 writeRunArgsFile(compileArgsFile, null, modpath, null)
4707 
4708                 if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
4709                     runArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
4710                     compileArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
4711                 }
4712             } else {
4713                 modpath = [ cygpath(&quot;${standaloneLibDir}&quot;) ]
4714                 writeRunArgsFile(runArgsFile, null, modpath, modnames)
4715                 writeRunArgsFile(compileArgsFile, null, modpath, modnames)
4716             }
4717         }
4718     }
4719     buildModules.dependsOn(buildRunArgsTask)
4720 
4721     def isWindows = IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;;
4722     def isMac = IS_MAC &amp;&amp; t.name == &quot;mac&quot;;
4723 
4724     // Create layout for modular classes
4725     moduleProjList.each { project -&gt;
4726         def buildModuleClassesTask = project.task(&quot;buildModule$t.capital&quot;, group: &quot;Build&quot;, type: Copy) {
4727             dependsOn(project.assemble)
4728             def buildDir = project.buildDir
4729             def sourceBuildDirs = [
4730                 &quot;${buildDir}/classes/java/main/${project.moduleName}&quot;,
4731             ]
4732 
4733             def moduleClassesDir = &quot;$buildDir/${platformPrefix}module-classes&quot;
4734                 includeEmptyDirs = false
4735                 sourceBuildDirs.each { d -&gt;
4736                     from d
4737                 }
4738                 into moduleClassesDir
4739 
4740                 // Exclude obsolete, experimental, or non-shipping code
4741                 exclude(&quot;version.rc&quot;)
4742                 exclude(&quot;com/sun/glass/ui/swt&quot;)
4743                 exclude(&quot;com/sun/javafx/tools/ant&quot;)
4744                 exclude(&quot;com/javafx/main&quot;)
4745                 exclude(&quot;com/sun/javafx/webkit/drt&quot;)
4746                 if (!IS_INCLUDE_NULL3D) {
4747                     exclude (&quot;com/sun/prism/null3d&quot;)
4748                 }
4749                 if (!IS_INCLUDE_ES2) {
4750                        exclude(&quot;com/sun/prism/es2&quot;,
4751                                &quot;com/sun/scenario/effect/impl/es2&quot;)
4752                 }
4753 
4754                 // Exclude platform-specific classes for other platforms
4755 
4756                 if (!isMac) {
4757                     exclude (&quot;com/sun/media/jfxmediaimpl/platform/osx&quot;,
4758                              &quot;com/sun/prism/es2/MacGL*&quot;,
4759                              &quot;com/sun/glass/events/mac&quot;,
4760                              &quot;com/sun/glass/ui/mac&quot;,
4761                              )
4762                 }
4763 
4764                 if (!isWindows) {
4765                     exclude (&quot;**/*.hlsl&quot;,
4766                              &quot;com/sun/glass/ui/win&quot;,
4767                              &quot;com/sun/prism/d3d&quot;,
4768                              &quot;com/sun/prism/es2/WinGL*&quot;,
4769                              &quot;com/sun/scenario/effect/impl/hw/d3d&quot;
4770                              )
4771                 }
4772 
4773                 if (!targetProperties.includeGTK) { //usually IS_LINUX
4774                     exclude (
4775                              &quot;com/sun/glass/ui/gtk&quot;,
4776                              &quot;com/sun/prism/es2/EGL*&quot;,
4777                              &quot;com/sun/prism/es2/X11GL*&quot;
4778                              )
4779                 }
4780 
4781                 if (!targetProperties.includeEGL) {
4782                     exclude (&quot;com/sun/prism/es2/EGL*&quot;)
4783                 }
4784 
4785                 if (!targetProperties.includeMonocle) {
4786                     exclude (&quot;com/sun/glass/ui/monocle&quot;)
4787                     exclude(&quot;com/sun/prism/es2/Monocle*&quot;)
4788                 }
4789 
4790                 if (t.name != &#39;ios&#39;) {
4791                     exclude (&quot;com/sun/media/jfxmediaimpl/platform/ios&quot;,
4792                              &quot;com/sun/glass/ui/ios&quot;,
4793                              &quot;com/sun/prism/es2/IOS*&quot;
4794                              )
4795                 }
4796 
4797                 if (t.name != &#39;android&#39; &amp;&amp; t.name != &#39;dalvik&#39;) {
4798                     exclude (&quot;com/sun/glass/ui/android&quot;)
4799                 }
4800 
4801                 // Filter out other platform-specific classes
4802                 if (targetProperties.containsKey(&#39;jfxrtJarExcludes&#39;)) {
4803                     exclude(targetProperties.jfxrtJarExcludes)
4804                 }
4805 
4806                 /* FIXME: JIGSAW -- handle this in the module itself
4807                 String webbld = project(&quot;:web&quot;).buildDir.path
4808                 String ctrlbld = project(&quot;:controls&quot;).buildDir.path
4809                 if (t.name == &#39;android&#39;) {
4810                     from (&quot;${webbld}/classes/android&quot;,
4811                           &quot;${webbld}/resources/android&quot;,
4812                           &quot;${ctrlbld}/classes/android&quot;,
4813                           &quot;${ctrlbld}/resources/android&quot;)
4814                 } else if (t.name == &#39;ios&#39;) {
4815                     from (&quot;${webbld}/classes/ios&quot;,
4816                           &quot;${webbld}/resources/ios&quot;)
4817                 } else {
4818                     from (&quot;${webbld}/classes/java/main&quot;)
4819                 }
4820                 */
4821         }
4822         buildModulesTask.dependsOn(buildModuleClassesTask)
4823     }
4824 
4825     def buildModuleLibsTask = task(&quot;buildModuleLibs$t.capital&quot;) {
4826         group = &quot;Basic&quot;
4827 
4828         def baseProject = project(&quot;:base&quot;);
4829 
4830         def graphicsProject = project(&quot;:graphics&quot;);
4831 
4832         def mediaProject = project(&quot;:media&quot;);
4833 
4834         def webProject = project(&quot;:web&quot;);
4835         dependsOn(webProject.assemble)
4836 
4837         def swtProject = project(&quot;:swt&quot;);
4838 
4839         def library = targetProperties.library
4840 
4841         def useLipo = targetProperties.containsKey(&#39;useLipo&#39;) ? targetProperties.useLipo : false
4842         def modLibDest = targetProperties.modLibDest
4843         def moduleNativeDirName = &quot;${platformPrefix}module-$modLibDest&quot;
4844 
4845         def buildModuleBaseTask = task(&quot;buildModuleBase$t.capital&quot;, dependsOn: baseProject.assemble) {
4846             group = &quot;Basic&quot;
4847             description = &quot;creates javafx.base property files&quot;
4848 
4849             def moduleLibDir = &quot;${baseProject.buildDir}/${platformPrefix}module-lib&quot;
4850             final File javafxProperties = file(&quot;${moduleLibDir}/javafx.properties&quot;)
4851             outputs.file(javafxProperties)
4852 
4853             if (targetProperties.containsKey(&quot;javafxPlatformProperties&quot;)) {
4854                 final File javafxPlatformProperties = file(&quot;${moduleLibDir}/javafx.platform.properties&quot;)
4855                 outputs.file(javafxPlatformProperties)
4856             }
4857 
4858             doLast {
4859                 mkdir moduleLibDir
4860 
4861                 javafxProperties.delete()
4862                 javafxProperties &lt;&lt; &quot;javafx.version=$RELEASE_VERSION_SHORT&quot;;
4863                 javafxProperties &lt;&lt; &quot;\n&quot;
4864                 javafxProperties &lt;&lt; &quot;javafx.runtime.version=$RELEASE_VERSION_LONG&quot;;
4865                 javafxProperties &lt;&lt; &quot;\n&quot;
4866                 javafxProperties &lt;&lt; &quot;javafx.runtime.build=$PROMOTED_BUILD_NUMBER&quot;;
4867                 javafxProperties &lt;&lt; &quot;\n&quot;
4868                 // Include any properties that have been defined (most likely in
4869                 // one of the various platform gradle files)
4870                 if (targetProperties.containsKey(&quot;javafxProperties&quot;)) {
4871                     javafxProperties &lt;&lt; targetProperties.javafxProperties
4872                     javafxProperties &lt;&lt; &quot;\n&quot;
4873                 }
4874 
4875                 // Embedded builds define this file as well
4876                 if (targetProperties.containsKey(&quot;javafxPlatformProperties&quot;)) {
4877                     final File javafxPlatformProperties = file(&quot;${moduleLibDir}/javafx.platform.properties&quot;)
4878                     javafxPlatformProperties.delete()
4879                     javafxPlatformProperties &lt;&lt; targetProperties.javafxPlatformProperties
4880                     javafxPlatformProperties &lt;&lt; &quot;\n&quot;
4881                 }
4882             }
4883         }
4884 
4885         def buildModuleGraphicsTask = task(&quot;buildModuleGraphics$t.capital&quot;, type: Copy, dependsOn: graphicsProject.assemble) {
4886             group = &quot;Basic&quot;
4887             description = &quot;copies javafx.graphics native libraries&quot;
4888 
4889             into &quot;${graphicsProject.buildDir}/${moduleNativeDirName}&quot;
4890 
4891             from(&quot;${graphicsProject.buildDir}/libs/jsl-decora/${t.name}/${library(targetProperties.decora.lib)}&quot;)
4892             def libs = [&#39;font&#39;, &#39;prism&#39;, &#39;prismSW&#39;, &#39;glass&#39;, &#39;iio&#39;]
4893             if (IS_INCLUDE_ES2) {
4894                 libs += [&#39;prismES2&#39;];
4895             }
4896             if (IS_COMPILE_PANGO) {
4897                 libs += [&#39;fontFreetype&#39;, &#39;fontPango&#39;];
4898             }
4899             libs.each { lib -&gt;
4900                 def variants = targetProperties[lib].containsKey(&#39;variants&#39;) &amp;&amp; !useLipo ? targetProperties[lib].variants : [null]
4901                 variants.each { variant -&gt;
4902                     def variantProperties = variant ? targetProperties[lib][variant] : targetProperties[lib]
4903                     from (&quot;${graphicsProject.buildDir}/libs/$lib/$t.name/${library(variantProperties.lib)}&quot;)
4904                 }
4905             }
4906             if (IS_WINDOWS) {
4907                 from (&quot;${graphicsProject.buildDir}/libs/prismD3D/${t.name}/${library(targetProperties.prismD3D.lib)}&quot;);
4908                 targetProperties.VS2017DLLs.each { vslib -&gt;
4909                     from (&quot;$vslib&quot;);
4910                 }
4911                 targetProperties.WinSDKDLLs.each { winsdklib -&gt;
4912                     from (&quot;$winsdklib&quot;);
4913                 }
4914             }
4915         }
4916 
4917         def buildModuleMediaTask = task(&quot;buildModuleMedia$t.capital&quot;, type: Copy, dependsOn: mediaProject.assemble) {
4918             group = &quot;Basic&quot;
4919             description = &quot;copies javafx.media native libraries&quot;
4920 
4921             into &quot;${mediaProject.buildDir}/${moduleNativeDirName}&quot;
4922 
4923             def mediaBuildType = project(&quot;:media&quot;).ext.buildType
4924             if (IS_COMPILE_MEDIA) {
4925                 [ &quot;fxplugins&quot;, &quot;gstreamer-lite&quot;, &quot;jfxmedia&quot; ].each { name -&gt;
4926                     from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}&quot;) }
4927 
4928                 if (t.name == &quot;mac&quot;) {
4929                     // OSX media natives
4930                     [ &quot;jfxmedia_qtkit&quot;, &quot;jfxmedia_avf&quot;, &quot;glib-lite&quot; ].each { name -&gt;
4931                         from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}&quot;) }
4932                 } else if (t.name == &quot;linux&quot;) {
4933                     from(&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}&quot;) { include &quot;libavplugin*.so&quot; }
4934                 } else from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(&quot;glib-lite&quot;)}&quot;)
4935             } else {
4936                 if (t.name != &quot;android&quot;  &amp;&amp; t.name != &quot;dalvik&quot; ) {
4937                     [ &quot;fxplugins&quot;, &quot;gstreamer-lite&quot;, &quot;jfxmedia&quot; ].each { name -&gt;
4938                         from (&quot;$MEDIA_STUB/${library(name)}&quot;) }
4939                 }
4940 
4941                 if (t.name == &quot;mac&quot;) {
4942                     // copy libjfxmedia_{avf,qtkit}.dylib if they exist
4943                     [ &quot;jfxmedia_qtkit&quot;, &quot;jfxmedia_avf&quot;, &quot;glib-lite&quot; ].each { name -&gt;
4944                         from (&quot;$MEDIA_STUB/${library(name)}&quot;) }
4945                 } else if (t.name == &quot;linux&quot;) {
4946                     from(MEDIA_STUB) { include &quot;libavplugin*.so&quot; }
4947                 }
4948                 else if (t.name != &quot;android&quot;  &amp;&amp; t.name != &quot;dalvik&quot; ) {
4949                     from (&quot;$MEDIA_STUB/${library(&quot;glib-lite&quot;)}&quot;)
4950                 }
4951             }
4952         }
4953 
4954         def buildModuleWeb = task(&quot;buildModuleWeb$t.capital&quot;, type: Copy, dependsOn: webProject.assemble) {
4955             group = &quot;Basic&quot;
4956             description = &quot;copies javafx.web native libraries&quot;
4957 
4958             into &quot;${webProject.buildDir}/${moduleNativeDirName}&quot;
4959 
4960             if (IS_COMPILE_WEBKIT) {
4961                 from (&quot;${webProject.buildDir}/libs/${t.name}/${library(&#39;jfxwebkit&#39;)}&quot;)
4962             } else {
4963                 if (t.name != &quot;android&quot; &amp;&amp; t.name != &quot;ios&quot; &amp;&amp; t.name != &quot;dalvik&quot;) {
4964                     from (&quot;$WEB_STUB/${library(&#39;jfxwebkit&#39;)}&quot;)
4965                 }
4966             }
4967         }
4968 
4969         def buildModuleSWT = task(&quot;buildModuleSWT$t.capital&quot;, type: Copy) {
4970             group = &quot;Basic&quot;
4971             description = &quot;copies SWT JAR&quot;
4972 
4973             // FIXME: the following is a hack to workaround the fact that there
4974             // is no way to deliver javafx-swt.jar other than in one of the
4975             // existing runtime modules.
4976 
4977             dependsOn(buildModuleGraphicsTask) // we copy to the graphics module
4978 
4979             if (COMPILE_SWT) {
4980                 def javafxSwtIndexTask = tasks.getByName(&quot;javafxSwtIndex${t.capital}&quot;);
4981                 dependsOn(javafxSwtIndexTask)
4982                 //enabled = COMPILE_SWT
4983             }
4984 
4985             // Copy javafx-swt.jar to the javafx-graphics module lib dir
4986             from &quot;${swtProject.buildDir}/libs/javafx-swt.jar&quot;
4987             into &quot;${graphicsProject.buildDir}/${platformPrefix}module-lib&quot;
4988         }
4989 
4990         dependsOn(
4991             buildModuleBaseTask,
4992             buildModuleGraphicsTask,
4993             buildModuleMediaTask,
4994             buildModuleWeb,
4995             buildModuleSWT,
4996             )
4997     }
4998     buildModulesTask.dependsOn(buildModuleLibsTask)
4999 
5000     def zipTask = project.task(&quot;buildModuleZip$t.capital&quot;, type: Zip, group: &quot;Build&quot;,
5001             dependsOn: buildModulesTask ) {
5002 
5003         // FIXME: JIGSAW -- this should be moved to a sub-directory so we can keep the same name
5004         def jfxBundle = &quot;${platformPrefix}javafx-exports.zip&quot;
5005 
5006         doFirst() {
5007             file(&quot;${rootProject.buildDir}/${jfxBundle}&quot;).delete()
5008         }
5009 
5010         archiveName = jfxBundle
5011         destinationDir = file(&quot;${rootProject.buildDir}&quot;)
5012         includeEmptyDirs = false
5013         from &quot;${bundledSdkDir}&quot;
5014     }
5015     jdkZip.dependsOn(zipTask)
5016 
5017     Task testArgFiles = task(&quot;createTestArgfiles${t.capital}&quot;) {
5018 
5019         File testRunArgsFile = new File(rootProject.buildDir, TESTRUNARGSFILE)
5020         //test (shimed) version
5021         File testCompileArgsFile = new File(rootProject.buildDir, TESTCOMPILEARGSFILE)
5022         // And a test java.policy file
5023         File testJavaPolicyFile = new File(rootProject.buildDir, TESTJAVAPOLICYFILE)
5024         // and the non-test version to go with run.args
5025         File runJavaPolicyFile = new File(rootProject.buildDir, RUNJAVAPOLICYFILE);
5026 
5027         outputs.file(testRunArgsFile)
5028         outputs.file(testCompileArgsFile)
5029         outputs.file(testJavaPolicyFile)
5030         outputs.file(runJavaPolicyFile)
5031         inputs.file(EXTRAADDEXPORTS);
5032 
5033         doLast() {
5034             rootProject.buildDir.mkdir()
5035 
5036             List&lt;String&gt; projNames = []
5037             moduleProjList.each { project -&gt;
5038                 projNames &lt;&lt; project.name
5039             }
5040 
5041             // And the test (shimed) variation...
5042 
5043             testRunArgsFile.delete()
5044             testCompileArgsFile.delete()
5045 
5046             testJavaPolicyFile.delete()
5047             runJavaPolicyFile.delete()
5048 
5049             List&lt;String&gt; modpath = []
5050 
5051             if (HAS_JAVAFX_MODULES) {
5052                 moduleProjList.each { project -&gt;
5053                     if (project.hasProperty(&quot;moduleName&quot;) &amp;&amp; project.buildModule) {
5054                         File dir;
5055                         if (project.sourceSets.hasProperty(&#39;shims&#39;)) {
5056                            dir = new File(rootProject.buildDir, &quot;shims/${project.ext.moduleName}&quot;)
5057                         } else {
5058                            dir = new File(rootProject.buildDir, &quot;modular-sdk/modules/${project.ext.moduleName}&quot;)
5059                         }
5060 
5061                         def dstModuleDir = cygpath(dir.path)
5062                         modpath &lt;&lt; &quot;${project.ext.moduleName}=${dstModuleDir}&quot;
5063 
5064                         String themod = dir.toURI()
5065                         testJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5066                         &quot;    permission java.security.AllPermission;\n&quot; +
5067                         &quot;};\n&quot;
5068 
5069                         dir = new File(rootProject.buildDir, &quot;modular-sdk/modules/${project.ext.moduleName}&quot;)
5070                         themod = dir.toURI()
5071                         runJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5072                         &quot;    permission java.security.AllPermission;\n&quot; +
5073                         &quot;};\n&quot;
5074                     }
5075                 }
5076 
5077                 writeRunArgsFile(testCompileArgsFile, null, modpath, null)
5078                 writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, null)
5079 
5080                 if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
5081                     testCompileArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
5082                     testRunArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
5083                 }
5084             } else  {
5085                 def modnames = []
5086                 moduleProjList.each { project -&gt;
5087                     if (project.hasProperty(&quot;moduleName&quot;) &amp;&amp; project.buildModule) {
5088                         modnames &lt;&lt; project.ext.moduleName
5089                         File dir;
5090                         if (project.sourceSets.hasProperty(&#39;shims&#39;)) {
5091                            dir = new File(rootProject.buildDir, &quot;shims/${project.ext.moduleName}&quot;)
5092                         } else {
5093                            dir = new File(rootProject.buildDir, &quot;sdk/lib/${project.ext.moduleName}.jar&quot;)
5094                         }
5095 
5096                         def dstModuleDir = cygpath(dir.path)
5097                         modpath &lt;&lt; &quot;${dstModuleDir}&quot;
5098 
5099                         String themod = dir.toURI()
5100                         testJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5101                         &quot;    permission java.security.AllPermission;\n&quot; +
5102                         &quot;};\n&quot;
5103 
5104                         dir = new File(rootProject.buildDir, &quot;sdk/lib/${project.ext.moduleName}.jar&quot;)
5105                         themod = dir.toURI()
5106                         runJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5107                         &quot;    permission java.security.AllPermission;\n&quot; +
5108                         &quot;};\n&quot;
5109                     }
5110                 }
5111 
5112                 writeRunArgsFile(testCompileArgsFile, null, modpath, modnames)
5113                 writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, modnames)
5114 
5115             }
5116         }
5117     }
5118     sdk.dependsOn(testArgFiles)
5119     createTestArgfiles.dependsOn(testArgFiles)
5120 
5121     def sdkTask = tasks.getByName(&quot;sdk${t.capital}&quot;);
5122     sdkTask.dependsOn(buildModulesTask)
5123 }
5124 sdk.dependsOn(buildModules)
5125 
5126 // Build the jmod for each module for the standalone SDK only.
5127 compileTargets { t -&gt;
5128     if (!HAS_JAVAFX_MODULES) {
5129         def targetProperties = project.ext[t.upper]
5130 
5131         def platformPrefix = targetProperties.platformPrefix
5132         def jmodsDirName = &quot;${platformPrefix}jmods&quot;
5133         def jmodsDir = &quot;${rootProject.buildDir}/${jmodsDirName}&quot;
5134         def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
5135         def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
5136         def standaloneLegalDir = &quot;${standaloneSdkDir}/legal&quot;
5137 
5138         def excludeNativeLibs = []
5139         if (IS_WINDOWS) {
5140             // List of duplicate Microsoft DLLs to exclude
5141             excludeNativeLibs += targetProperties.VS2017DLLNames
5142             excludeNativeLibs += targetProperties.WinSDKDLLNames
5143         }
5144 
5145         moduleProjList.each { project -&gt;
5146             def moduleName = project.ext.moduleName
5147             def buildDir = project.buildDir
5148 
5149             def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
5150             def srcLibDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
5151             def srcLegalDir = &quot;${standaloneLegalDir}/${moduleName}&quot;
5152 
5153             def jmodName = &quot;${moduleName}.jmod&quot;
5154             def jmodFile = &quot;${jmodsDir}/${jmodName}&quot;
5155             def jmodTask = project.task(&quot;jmod$t.capital&quot;, group: &quot;Build&quot;, dependsOn: sdk) {
5156                 doLast {
5157                     mkdir jmodsDir
5158                     delete(jmodFile);
5159                     exec {
5160                         commandLine(JMOD)
5161                         args(&quot;create&quot;)
5162                         args(&quot;--class-path&quot;)
5163                         args(srcClassesDir)
5164                         // Not all modules have a &quot;lib&quot; dir
5165                         if (file(srcLibDir).isDirectory()) {
5166                             args(&quot;--libs&quot;)
5167                             args(srcLibDir)
5168                         }
5169                         // Exclude duplicate native libs from javafx.graphics.jmod
5170                         if (moduleName == &quot;javafx.graphics&quot;) {
5171                             excludeNativeLibs.each { name -&gt;
5172                                 args(&quot;--exclude&quot;)
5173                                 args(name)
5174                             }
5175                         }
5176                         args(&quot;--legal-notices&quot;)
5177                         args(srcLegalDir)
5178                         args(jmodFile)
5179                     }
5180                 }
5181             }
5182 
5183             jmods.dependsOn(jmodTask)
5184         }
5185     }
5186 }
5187 
5188 /******************************************************************************
5189  *                                                                            *
5190  *                              BUILD_CLOSED                                  *
5191  *                                                                            *
5192  * This next section should remain at the end of the build script. It allows  *
5193  * for a &quot;supplemental&quot; gradle file to be used to extend the normal build     *
5194  * structure. For example, this is used for passing a supplemental gradle     *
5195  * file for producing official JavaFX builds.                                 *
5196  *                                                                            *
5197  *****************************************************************************/
5198 
5199 if (BUILD_CLOSED) {
5200     apply from: supplementalBuildFile
5201 }
5202 
5203 task showFlags {
5204 }
5205 
5206 compileTargets { t -&gt;
5207     // Every platform must define these variables
5208     def props = project.ext[t.upper];
5209     showFlags.dependsOn(
5210         project.task(&quot;showFlags$t.upper&quot;) {
5211             doLast() {
5212                 println &quot;Properties set for $t.upper&quot;
5213                 props.each { println it }
5214             }
5215         }
5216     )
5217 
5218 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>