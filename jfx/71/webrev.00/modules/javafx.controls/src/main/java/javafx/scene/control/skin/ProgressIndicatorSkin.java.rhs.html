<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/ProgressIndicatorSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javafx.scene.control.skin;
 27 
 28 import com.sun.javafx.scene.NodeHelper;
 29 import com.sun.javafx.scene.control.skin.Utils;
 30 import java.util.ArrayList;
 31 import java.util.Collections;
 32 import java.util.List;
<a name="1" id="anc1"></a><span class="line-added"> 33 import java.util.function.Consumer;</span>
 34 
 35 import javafx.animation.Animation;
 36 import javafx.animation.KeyFrame;
 37 import javafx.animation.KeyValue;
 38 import javafx.animation.Timeline;
 39 import javafx.beans.property.BooleanProperty;
 40 import javafx.beans.property.IntegerProperty;
 41 import javafx.beans.property.ObjectProperty;
<a name="2" id="anc2"></a><span class="line-added"> 42 import javafx.beans.value.ObservableValue;</span>
 43 import javafx.beans.value.WritableValue;
 44 import javafx.collections.FXCollections;
 45 import javafx.collections.ObservableList;
 46 import javafx.geometry.NodeOrientation;
 47 import javafx.geometry.VPos;
 48 import javafx.scene.Node;
 49 import javafx.scene.control.Control;
 50 import javafx.scene.control.ProgressIndicator;
 51 import javafx.scene.control.SkinBase;
 52 import javafx.scene.layout.Pane;
 53 import javafx.scene.layout.Region;
 54 import javafx.scene.layout.StackPane;
 55 import javafx.scene.paint.Color;
 56 import javafx.scene.paint.Paint;
 57 import javafx.scene.shape.Arc;
 58 import javafx.scene.shape.ArcType;
 59 import javafx.scene.shape.Circle;
<a name="3" id="anc3"></a><span class="line-added"> 60 import javafx.scene.text.Font;</span>
 61 import javafx.scene.text.Text;
 62 import javafx.scene.text.TextBoundsType;
 63 import javafx.scene.transform.Scale;
 64 import javafx.util.Duration;
 65 import javafx.css.CssMetaData;
 66 import javafx.css.StyleableObjectProperty;
 67 import javafx.css.StyleableProperty;
 68 import javafx.css.StyleableBooleanProperty;
 69 import javafx.css.StyleableIntegerProperty;
 70 import javafx.css.converter.BooleanConverter;
 71 import javafx.css.converter.PaintConverter;
 72 import javafx.css.converter.SizeConverter;
 73 import com.sun.javafx.scene.control.skin.resources.ControlResources;
 74 import javafx.css.Styleable;
 75 
 76 /**
 77  * Default skin implementation for the {@link ProgressIndicator} control.
 78  *
 79  * @see ProgressIndicator
 80  * @since 9
 81  */
 82 public class ProgressIndicatorSkin extends SkinBase&lt;ProgressIndicator&gt; {
 83 
 84     /***************************************************************************
 85      *                                                                         *
 86      * Static fields                                                           *
 87      *                                                                         *
 88      **************************************************************************/
 89 
 90 
 91 
 92     /***************************************************************************
 93      *                                                                         *
 94      * Private fields                                                          *
 95      *                                                                         *
 96      **************************************************************************/
 97 
 98     // JDK-8149818: This constant should not be static, because the
 99     // Locale may change between instances.
100 
101     /** DONE string is just used to know the size of Done as that is the biggest text we need to allow for */
102     private final String DONE = ControlResources.getString(&quot;ProgressIndicator.doneString&quot;);
103 
104     final Duration CLIPPED_DELAY = new Duration(300);
105     final Duration UNCLIPPED_DELAY = new Duration(0);
106 
107     private IndeterminateSpinner spinner;
108     private DeterminateIndicator determinateIndicator;
109     private ProgressIndicator control;
110 
111     Animation indeterminateTransition;
112 
113 
114 
115     /***************************************************************************
116      *                                                                         *
117      * Constructors                                                            *
118      *                                                                         *
119      **************************************************************************/
120 
121     /**
122      * Creates a new ProgressIndicatorSkin instance, installing the necessary child
123      * nodes into the Control {@link Control#getChildren() children} list.
124      *
125      * @param control The control that this skin should be installed onto.
126      */
127     public ProgressIndicatorSkin(ProgressIndicator control) {
128         super(control);
129 
130         this.control = control;
131 
132         // register listeners
133         registerChangeListener(control.indeterminateProperty(), e -&gt; initialize());
134         registerChangeListener(control.progressProperty(), e -&gt; updateProgress());
135         registerChangeListener(NodeHelper.treeShowingProperty(control), e -&gt; updateAnimation());
136         registerChangeListener(control.sceneProperty(), e-&gt;updateAnimation());
137 
138         initialize();
139         updateAnimation();
140     }
141 
142 
143 
144     /***************************************************************************
145      *                                                                         *
146      * Properties                                                              *
147      *                                                                         *
148      **************************************************************************/
149 
150     /**
151      * The colour of the progress segment.
152      */
153     private ObjectProperty&lt;Paint&gt; progressColor = new StyleableObjectProperty&lt;Paint&gt;(null) {
154         @Override protected void invalidated() {
155             final Paint value = get();
156             if (value != null &amp;&amp; !(value instanceof Color)) {
157                 if (isBound()) {
158                     unbind();
159                 }
160                 set(null);
161                 throw new IllegalArgumentException(&quot;Only Color objects are supported&quot;);
162             }
163             if (spinner!=null) spinner.setFillOverride(value);
164             if (determinateIndicator!=null) determinateIndicator.setFillOverride(value);
165         }
166 
167         @Override public Object getBean() {
168             return ProgressIndicatorSkin.this;
169         }
170 
171         @Override public String getName() {
172             return &quot;progressColorProperty&quot;;
173         }
174 
175         @Override public CssMetaData&lt;ProgressIndicator,Paint&gt; getCssMetaData() {
176             return PROGRESS_COLOR;
177         }
178     };
179 
180     Paint getProgressColor() {
181         return progressColor.get();
182     }
183 
184     /**
185      * The number of segments in the spinner.
186      */
187     private IntegerProperty indeterminateSegmentCount = new StyleableIntegerProperty(8) {
188         @Override protected void invalidated() {
189             if (spinner!=null) spinner.rebuild();
190         }
191 
192         @Override public Object getBean() {
193             return ProgressIndicatorSkin.this;
194         }
195 
196         @Override public String getName() {
197             return &quot;indeterminateSegmentCount&quot;;
198         }
199 
200         @Override public CssMetaData&lt;ProgressIndicator,Number&gt; getCssMetaData() {
201             return INDETERMINATE_SEGMENT_COUNT;
202         }
203     };
204 
205     /**
206      * True if the progress indicator should rotate as well as animate opacity.
207      */
208     private final BooleanProperty spinEnabled = new StyleableBooleanProperty(false) {
209         @Override protected void invalidated() {
210             if (spinner!=null) spinner.setSpinEnabled(get());
211         }
212 
213         @Override public CssMetaData&lt;ProgressIndicator,Boolean&gt; getCssMetaData() {
214             return SPIN_ENABLED;
215         }
216 
217         @Override public Object getBean() {
218             return ProgressIndicatorSkin.this;
219         }
220 
221         @Override public String getName() {
222             return &quot;spinEnabled&quot;;
223         }
224     };
225 
226 
227 
228     /***************************************************************************
229      *                                                                         *
230      * Public API                                                              *
231      *                                                                         *
232      **************************************************************************/
233 
234     /** {@inheritDoc} */
235     @Override public void dispose() {
236         super.dispose();
237 
238         if (indeterminateTransition != null) {
239             indeterminateTransition.stop();
240             indeterminateTransition = null;
241         }
242 
243         if (spinner != null) {
244             spinner = null;
245         }
246 
247         control = null;
248     }
249 
250     /** {@inheritDoc} */
251     @Override protected void layoutChildren(final double x, final double y,
252                                             final double w, final double h) {
253         if (spinner != null &amp;&amp; control.isIndeterminate()) {
254             spinner.layoutChildren();
255             spinner.resizeRelocate(0, 0, w, h);
256         } else if (determinateIndicator != null) {
257             determinateIndicator.layoutChildren();
258             determinateIndicator.resizeRelocate(0, 0, w, h);
259         }
260     }
261 
262     /** {@inheritDoc} */
263     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
264         double minWidth = 0.0;
265 
266         if (spinner != null &amp;&amp; control.isIndeterminate()) {
267             minWidth = spinner.minWidth(-1);
268         } else if (determinateIndicator != null) {
269             minWidth = determinateIndicator.minWidth(-1);
270         }
271         return minWidth;
272     }
273 
274     /** {@inheritDoc} */
275     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
276         double minHeight = 0.0;
277 
278         if (spinner != null &amp;&amp; control.isIndeterminate()) {
279             minHeight = spinner.minHeight(-1);
280         } else if (determinateIndicator != null) {
281             minHeight = determinateIndicator.minHeight(-1);
282         }
283         return minHeight;
284     }
285 
286     /** {@inheritDoc} */
287     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
288         double prefWidth = 0.0;
289 
290         if (spinner != null &amp;&amp; control.isIndeterminate()) {
291             prefWidth = spinner.prefWidth(height);
292         } else if (determinateIndicator != null) {
293             prefWidth = determinateIndicator.prefWidth(height);
294         }
295         return prefWidth;
296     }
297 
298    /** {@inheritDoc} */
299    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
300         double prefHeight = 0.0;
301 
302         if (spinner != null &amp;&amp; control.isIndeterminate()) {
303             prefHeight = spinner.prefHeight(width);
304         } else if (determinateIndicator != null) {
305             prefHeight = determinateIndicator.prefHeight(width);
306         }
307         return prefHeight;
308     }
309 
310     /** {@inheritDoc} */
311     @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
312         return computePrefWidth(height, topInset, rightInset, bottomInset, leftInset);
313     }
314 
315     /** {@inheritDoc} */
316     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
317         return computePrefHeight(width, topInset, rightInset, bottomInset, leftInset);
318     }
319 
320 
321     /***************************************************************************
322      *                                                                         *
323      * Private implementation                                                  *
324      *                                                                         *
325      **************************************************************************/
326 
327     void initialize() {
328         boolean isIndeterminate = control.isIndeterminate();
329         if (isIndeterminate) {
<a name="4" id="anc4"></a><span class="line-modified">330             // clean up the old determinateIndicator</span>
<span class="line-added">331             if(determinateIndicator != null) {</span>
<span class="line-added">332                 determinateIndicator.unregisterListener();</span>
<span class="line-added">333             }</span>
334             determinateIndicator = null;
335 
336             // create spinner
337             spinner = new IndeterminateSpinner(spinEnabled.get(), progressColor.get());
338             getChildren().setAll(spinner);
339             if (NodeHelper.isTreeShowing(control)) {
340                 if (indeterminateTransition != null) {
341                     indeterminateTransition.play();
342                 }
343             }
344         } else {
345             // clean up after spinner
346             if (spinner != null) {
347                 if (indeterminateTransition != null) {
348                     indeterminateTransition.stop();
349                 }
350                 spinner = null;
351             }
352 
353             // create determinateIndicator
354             determinateIndicator = new DeterminateIndicator(control, this, progressColor.get());
355             getChildren().setAll(determinateIndicator);
356         }
357     }
358 
359     void updateProgress() {
360         if (determinateIndicator != null) {
361             determinateIndicator.updateProgress(control.getProgress());
362         }
363     }
364 
365     void createIndeterminateTimeline() {
366         if (spinner != null) {
367             spinner.rebuildTimeline();
368         }
369     }
370 
371     void pauseTimeline(boolean pause) {
372         if (getSkinnable().isIndeterminate()) {
373             if (indeterminateTransition == null) {
374                 createIndeterminateTimeline();
375             }
376             if (pause) {
377                 indeterminateTransition.pause();
378             } else {
379                 indeterminateTransition.play();
380             }
381         }
382     }
383 
384     void updateAnimation() {
385         ProgressIndicator control = getSkinnable();
386         final boolean isTreeShowing = NodeHelper.isTreeShowing(control) &amp;&amp;
387                                       control.getScene() != null;
388         if (indeterminateTransition != null) {
389             pauseTimeline(!isTreeShowing);
390         } else if (isTreeShowing) {
391             createIndeterminateTimeline();
392         }
393     }
394 
395 
396 
397     /***************************************************************************
398      *                                                                         *
399      * Stylesheet Handling                                                     *
400      *                                                                         *
401      **************************************************************************/
402 
403     private static final CssMetaData&lt;ProgressIndicator,Paint&gt; PROGRESS_COLOR =
404             new CssMetaData&lt;ProgressIndicator,Paint&gt;(&quot;-fx-progress-color&quot;,
405                     PaintConverter.getInstance(), null) {
406 
407                 @Override
408                 public boolean isSettable(ProgressIndicator n) {
409                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
410                     return skin.progressColor == null ||
411                             !skin.progressColor.isBound();
412                 }
413 
414                 @Override
415                 public StyleableProperty&lt;Paint&gt; getStyleableProperty(ProgressIndicator n) {
416                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
417                     return (StyleableProperty&lt;Paint&gt;)(WritableValue&lt;Paint&gt;)skin.progressColor;
418                 }
419             };
420     private static final CssMetaData&lt;ProgressIndicator,Number&gt; INDETERMINATE_SEGMENT_COUNT =
421             new CssMetaData&lt;ProgressIndicator,Number&gt;(&quot;-fx-indeterminate-segment-count&quot;,
422                     SizeConverter.getInstance(), 8) {
423 
424                 @Override public boolean isSettable(ProgressIndicator n) {
425                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
426                     return skin.indeterminateSegmentCount == null ||
427                             !skin.indeterminateSegmentCount.isBound();
428                 }
429 
430                 @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(ProgressIndicator n) {
431                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
432                     return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.indeterminateSegmentCount;
433                 }
434             };
435     private static final CssMetaData&lt;ProgressIndicator,Boolean&gt; SPIN_ENABLED =
436             new CssMetaData&lt;ProgressIndicator,Boolean&gt;(&quot;-fx-spin-enabled&quot;, BooleanConverter.getInstance(), Boolean.FALSE) {
437 
438                 @Override public boolean isSettable(ProgressIndicator node) {
439                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) node.getSkin();
440                     return skin.spinEnabled == null || !skin.spinEnabled.isBound();
441                 }
442 
443                 @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(ProgressIndicator node) {
444                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) node.getSkin();
445                     return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.spinEnabled;
446                 }
447             };
448 
449     private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
450     static {
451         final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
452                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
453         styleables.add(PROGRESS_COLOR);
454         styleables.add(INDETERMINATE_SEGMENT_COUNT);
455         styleables.add(SPIN_ENABLED);
456         STYLEABLES = Collections.unmodifiableList(styleables);
457     }
458 
459     /**
460      * Returns the CssMetaData associated with this class, which may include the
461      * CssMetaData of its superclasses.
462      * @return the CssMetaData associated with this class, which may include the
463      * CssMetaData of its superclasses
464      */
465     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
466         return STYLEABLES;
467     }
468 
469     /**
470      * {@inheritDoc}
471      */
472     @Override
473     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
474         return getClassCssMetaData();
475     }
476 
477 
478 
479     /***************************************************************************
480      *                                                                         *
481      * Support classes                                                         *
482      *                                                                         *
483      **************************************************************************/
484 
485     private final class DeterminateIndicator extends Region {
486         private double textGap = 2.0F;
487 
488         // only update progress text on whole percentages
489         private int intProgress;
490 
491         // only update pie arc to nearest degree
492         private int degProgress;
493         private Text text;
494         private StackPane indicator;
495         private StackPane progress;
496         private StackPane tick;
497         private Arc arcShape;
498         private Circle indicatorCircle;
499         private double doneTextWidth;
500         private double doneTextHeight;
<a name="5" id="anc5"></a><span class="line-added">501         private Consumer&lt;ObservableValue&lt;?&gt;&gt; fontListener = null;</span>
502 
503         public DeterminateIndicator(ProgressIndicator control, ProgressIndicatorSkin s, Paint fillOverride) {
504 
505             getStyleClass().add(&quot;determinate-indicator&quot;);
506 
507             intProgress = (int) Math.round(control.getProgress() * 100.0) ;
508             degProgress = (int) (360 * control.getProgress());
509 
510             getChildren().clear();
511 
512             text = new Text((control.getProgress() &gt;= 1) ? (DONE) : (&quot;&quot; + intProgress + &quot;%&quot;));
513             text.setTextOrigin(VPos.TOP);
514             text.getStyleClass().setAll(&quot;text&quot;, &quot;percentage&quot;);
515 
<a name="6" id="anc6"></a><span class="line-modified">516             fontListener = o -&gt; {</span>
517                 doneTextWidth = Utils.computeTextWidth(text.getFont(), DONE, 0);
518                 doneTextHeight = Utils.computeTextHeight(text.getFont(), DONE, 0, TextBoundsType.LOGICAL_VERTICAL_CENTER);
<a name="7" id="anc7"></a><span class="line-modified">519             };</span>
<span class="line-added">520             registerChangeListener(text.fontProperty(), (Consumer&lt;ObservableValue&lt;?&gt;&gt;) fontListener);</span>
521 
522             // The circular background for the progress pie piece
523             indicator = new StackPane();
524             indicator.setScaleShape(false);
525             indicator.setCenterShape(false);
526             indicator.getStyleClass().setAll(&quot;indicator&quot;);
527             indicatorCircle = new Circle();
528             indicator.setShape(indicatorCircle);
529 
530             // The shape for our progress pie piece
531             arcShape = new Arc();
532             arcShape.setType(ArcType.ROUND);
533             arcShape.setStartAngle(90.0F);
534 
535             // Our progress pie piece
536             progress = new StackPane();
537             progress.getStyleClass().setAll(&quot;progress&quot;);
538             progress.setScaleShape(false);
539             progress.setCenterShape(false);
540             progress.setShape(arcShape);
541             progress.getChildren().clear();
542             setFillOverride(fillOverride);
543 
544             // The check mark that&#39;s drawn at 100%
545             tick = new StackPane();
546             tick.getStyleClass().setAll(&quot;tick&quot;);
547 
548             getChildren().setAll(indicator, progress, text, tick);
549             updateProgress(control.getProgress());
550         }
551 
<a name="8" id="anc8"></a><span class="line-added">552         private void unregisterListener() {</span>
<span class="line-added">553             unregisterChangeListeners(text.fontProperty());</span>
<span class="line-added">554         }</span>
<span class="line-added">555 </span>
556         private void setFillOverride(Paint fillOverride) {
557             if (fillOverride instanceof Color) {
558                 Color c = (Color)fillOverride;
559                 progress.setStyle(&quot;-fx-background-color: rgba(&quot;+((int)(255*c.getRed()))+&quot;,&quot;+((int)(255*c.getGreen()))+&quot;,&quot;+((int)(255*c.getBlue()))+&quot;,&quot;+c.getOpacity()+&quot;);&quot;);
560             } else {
561                 progress.setStyle(null);
562             }
563         }
564 
565         @Override public boolean usesMirroring() {
566             // This is used instead of setting NodeOrientation,
567             // allowing the Text node to inherit the current
568             // orientation.
569             return false;
570         }
571 
572         private void updateProgress(double progress) {
573             intProgress = (int) Math.round(progress * 100.0) ;
574             text.setText((progress &gt;= 1) ? (DONE) : (&quot;&quot; + intProgress + &quot;%&quot;));
575 
576             degProgress = (int) (360 * progress);
577             arcShape.setLength(-degProgress);
578             requestLayout();
579         }
580 
581         @Override protected void layoutChildren() {
582             // Position and size the circular background
583             final double left = control.snappedLeftInset();
584             final double right = control.snappedRightInset();
585             final double top = control.snappedTopInset();
586             final double bottom = control.snappedBottomInset();
587 
588             /*
589             ** use the min of width, or height, keep it a circle
590             */
591             final double areaW = control.getWidth() - left - right;
592             final double areaH = control.getHeight() - top - bottom - textGap - doneTextHeight;
593             final double radiusW = areaW / 2;
594             final double radiusH = areaH / 2;
595             final double radius = Math.floor(Math.min(radiusW, radiusH));
596             final double centerX = snapPosition(left + radiusW);
597             final double centerY = snapPosition(top + radius);
598 
599             // find radius that fits inside radius - insetsPadding
600             final double iLeft = indicator.snappedLeftInset();
601             final double iRight = indicator.snappedRightInset();
602             final double iTop = indicator.snappedTopInset();
603             final double iBottom = indicator.snappedBottomInset();
604             final double progressRadius = snapSize(Math.min(
605                     Math.min(radius - iLeft, radius - iRight),
606                     Math.min(radius - iTop, radius - iBottom)));
607 
608             indicatorCircle.setRadius(radius);
609             indicator.setLayoutX(centerX);
610             indicator.setLayoutY(centerY);
611 
612             arcShape.setRadiusX(progressRadius);
613             arcShape.setRadiusY(progressRadius);
614             progress.setLayoutX(centerX);
615             progress.setLayoutY(centerY);
616 
617             // find radius that fits inside progressRadius - progressInsets
618             final double pLeft = progress.snappedLeftInset();
619             final double pRight = progress.snappedRightInset();
620             final double pTop = progress.snappedTopInset();
621             final double pBottom = progress.snappedBottomInset();
622             final double indicatorRadius = snapSize(Math.min(
623                     Math.min(progressRadius - pLeft, progressRadius - pRight),
624                     Math.min(progressRadius - pTop, progressRadius - pBottom)));
625 
626             // find size of spare box that fits inside indicator radius
627             double squareBoxHalfWidth = Math.ceil(Math.sqrt((indicatorRadius * indicatorRadius) / 2));
628 
629             tick.setLayoutX(centerX - squareBoxHalfWidth);
630             tick.setLayoutY(centerY - squareBoxHalfWidth);
631             tick.resize(squareBoxHalfWidth + squareBoxHalfWidth, squareBoxHalfWidth + squareBoxHalfWidth);
632             tick.setVisible(control.getProgress() &gt;= 1);
633 
634             // if the % text can&#39;t fit anywhere in the bounds then don&#39;t display it
635             double textWidth = text.getLayoutBounds().getWidth();
636             double textHeight = text.getLayoutBounds().getHeight();
637             if (control.getWidth() &gt;= textWidth &amp;&amp; control.getHeight() &gt;= textHeight) {
638                 if (!text.isVisible()) text.setVisible(true);
639                 text.setLayoutY(snapPosition(centerY + radius + textGap));
640                 text.setLayoutX(snapPosition(centerX - (textWidth/2)));
641             } else {
642                 if (text.isVisible()) text.setVisible(false);
643             }
644         }
645 
646         @Override protected double computePrefWidth(double height) {
647             final double left = control.snappedLeftInset();
648             final double right = control.snappedRightInset();
649             final double iLeft = indicator.snappedLeftInset();
650             final double iRight = indicator.snappedRightInset();
651             final double iTop = indicator.snappedTopInset();
652             final double iBottom = indicator.snappedBottomInset();
653             final double indicatorMax = snapSize(Math.max(Math.max(iLeft, iRight), Math.max(iTop, iBottom)));
654             final double pLeft = progress.snappedLeftInset();
655             final double pRight = progress.snappedRightInset();
656             final double pTop = progress.snappedTopInset();
657             final double pBottom = progress.snappedBottomInset();
658             final double progressMax = snapSize(Math.max(Math.max(pLeft, pRight), Math.max(pTop, pBottom)));
659             final double tLeft = tick.snappedLeftInset();
660             final double tRight = tick.snappedRightInset();
661             final double indicatorWidth = indicatorMax + progressMax + tLeft + tRight + progressMax + indicatorMax;
662             return left + Math.max(indicatorWidth, doneTextWidth) + right;
663         }
664 
665         @Override protected double computePrefHeight(double width) {
666             final double top = control.snappedTopInset();
667             final double bottom = control.snappedBottomInset();
668             final double iLeft = indicator.snappedLeftInset();
669             final double iRight = indicator.snappedRightInset();
670             final double iTop = indicator.snappedTopInset();
671             final double iBottom = indicator.snappedBottomInset();
672             final double indicatorMax = snapSize(Math.max(Math.max(iLeft, iRight), Math.max(iTop, iBottom)));
673             final double pLeft = progress.snappedLeftInset();
674             final double pRight = progress.snappedRightInset();
675             final double pTop = progress.snappedTopInset();
676             final double pBottom = progress.snappedBottomInset();
677             final double progressMax = snapSize(Math.max(Math.max(pLeft, pRight), Math.max(pTop, pBottom)));
678             final double tTop = tick.snappedTopInset();
679             final double tBottom = tick.snappedBottomInset();
680             final double indicatorHeight = indicatorMax + progressMax + tTop + tBottom + progressMax + indicatorMax;
681             return top + indicatorHeight + textGap + doneTextHeight + bottom;
682         }
683 
684         @Override protected double computeMaxWidth(double height) {
685             return computePrefWidth(height);
686         }
687 
688         @Override protected double computeMaxHeight(double width) {
689             return computePrefHeight(width);
690         }
691     }
692 
693 
694     private final class IndeterminateSpinner extends Region {
695         private IndicatorPaths pathsG;
696         private final List&lt;Double&gt; opacities = new ArrayList&lt;&gt;();
697         private boolean spinEnabled = false;
698         private Paint fillOverride = null;
699 
700         private IndeterminateSpinner(boolean spinEnabled, Paint fillOverride) {
701             this.spinEnabled = spinEnabled;
702             this.fillOverride = fillOverride;
703 
704             setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
705             getStyleClass().setAll(&quot;spinner&quot;);
706 
707             pathsG = new IndicatorPaths();
708             getChildren().add(pathsG);
709             rebuild();
710 
711             rebuildTimeline();
712 
713         }
714 
715         public void setFillOverride(Paint fillOverride) {
716             this.fillOverride = fillOverride;
717             rebuild();
718         }
719 
720         public void setSpinEnabled(boolean spinEnabled) {
721             this.spinEnabled = spinEnabled;
722             rebuildTimeline();
723         }
724 
725         private void rebuildTimeline() {
726             if (spinEnabled) {
727                 if (indeterminateTransition == null) {
728                     indeterminateTransition = new Timeline();
729                     indeterminateTransition.setCycleCount(Timeline.INDEFINITE);
730                     indeterminateTransition.setDelay(UNCLIPPED_DELAY);
731                 } else {
732                     indeterminateTransition.stop();
733                     ((Timeline)indeterminateTransition).getKeyFrames().clear();
734                 }
735                 final ObservableList&lt;KeyFrame&gt; keyFrames = FXCollections.&lt;KeyFrame&gt;observableArrayList();
736 
737                 keyFrames.add(new KeyFrame(Duration.millis(1), new KeyValue(pathsG.rotateProperty(), 360)));
738                 keyFrames.add(new KeyFrame(Duration.millis(3900), new KeyValue(pathsG.rotateProperty(), 0)));
739 
740                 for (int i = 100; i &lt;= 3900; i += 100) {
741                     keyFrames.add(new KeyFrame(Duration.millis(i), event -&gt; shiftColors()));
742                 }
743 
744                 ((Timeline)indeterminateTransition).getKeyFrames().setAll(keyFrames);
745                 indeterminateTransition.playFromStart();
746             } else {
747                 if (indeterminateTransition != null) {
748                     indeterminateTransition.stop();
749                     ((Timeline)indeterminateTransition).getKeyFrames().clear();
750                     indeterminateTransition = null;
751                 }
752             }
753         }
754 
755         private class IndicatorPaths extends Pane {
756             @Override protected double computePrefWidth(double height) {
757                 double w = 0;
758                 for(Node child: getChildren()) {
759                     if (child instanceof Region) {
760                         Region region = (Region)child;
761                         if (region.getShape() != null) {
762                             w = Math.max(w,region.getShape().getLayoutBounds().getMaxX());
763                         } else {
764                             w = Math.max(w,region.prefWidth(height));
765                         }
766                     }
767                 }
768                 return w;
769             }
770 
771             @Override protected double computePrefHeight(double width) {
772                 double h = 0;
773                 for(Node child: getChildren()) {
774                     if (child instanceof Region) {
775                         Region region = (Region)child;
776                         if (region.getShape() != null) {
777                             h = Math.max(h,region.getShape().getLayoutBounds().getMaxY());
778                         } else {
779                             h = Math.max(h,region.prefHeight(width));
780                         }
781                     }
782                 }
783                 return h;
784             }
785 
786             @Override protected void layoutChildren() {
787                 // calculate scale
788                 double scale = getWidth() / computePrefWidth(-1);
789                 for(Node child: getChildren()) {
790                     if (child instanceof Region) {
791                         Region region = (Region)child;
792                         if (region.getShape() != null) {
793                             region.resize(
794                                     region.getShape().getLayoutBounds().getMaxX(),
795                                     region.getShape().getLayoutBounds().getMaxY()
796                             );
797                             region.getTransforms().setAll(new Scale(scale,scale,0,0));
798                         } else {
799                             region.autosize();
800                         }
801                     }
802                 }
803             }
804         }
805 
806         @Override protected void layoutChildren() {
807             final double w = control.getWidth() - control.snappedLeftInset() - control.snappedRightInset();
808             final double h = control.getHeight() - control.snappedTopInset() - control.snappedBottomInset();
809             final double prefW = pathsG.prefWidth(-1);
810             final double prefH = pathsG.prefHeight(-1);
811             double scaleX = w / prefW;
812             double scale = scaleX;
813             if ((scaleX * prefH) &gt; h) {
814                 scale = h / prefH;
815             }
816             double indicatorW = prefW * scale;
817             double indicatorH = prefH * scale;
818             pathsG.resizeRelocate((w - indicatorW) / 2, (h - indicatorH) / 2, indicatorW, indicatorH);
819         }
820 
821         private void rebuild() {
822             // update indeterminate indicator
823             final int segments = indeterminateSegmentCount.get();
824             opacities.clear();
825             pathsG.getChildren().clear();
826             final double step = 0.8/(segments-1);
827             for (int i = 0; i &lt; segments; i++) {
828                 Region region = new Region();
829                 region.setScaleShape(false);
830                 region.setCenterShape(false);
831                 region.getStyleClass().addAll(&quot;segment&quot;, &quot;segment&quot; + i);
832                 if (fillOverride instanceof Color) {
833                     Color c = (Color)fillOverride;
834                     region.setStyle(&quot;-fx-background-color: rgba(&quot;+((int)(255*c.getRed()))+&quot;,&quot;+((int)(255*c.getGreen()))+&quot;,&quot;+((int)(255*c.getBlue()))+&quot;,&quot;+c.getOpacity()+&quot;);&quot;);
835                 } else {
836                     region.setStyle(null);
837                 }
838                 pathsG.getChildren().add(region);
839                 opacities.add(Math.max(0.1, (1.0 - (step*i))));
840             }
841         }
842 
843         private void shiftColors() {
844             if (opacities.size() &lt;= 0) return;
845             final int segments = indeterminateSegmentCount.get();
846             Collections.rotate(opacities, -1);
847             for (int i = 0; i &lt; segments; i++) {
848                 pathsG.getChildren().get(i).setOpacity(opacities.get(i));
849             }
850         }
851     }
852 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>