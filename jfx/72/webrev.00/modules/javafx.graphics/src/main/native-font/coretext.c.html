<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/native-font/coretext.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifdef __APPLE__
  27 #include &lt;TargetConditionals.h&gt;
  28 
  29 #if TARGET_OS_MAC
  30 
  31 #include &lt;jni.h&gt;
  32 #include &lt;com_sun_javafx_font_coretext_OS.h&gt;
  33 
  34 #import &lt;CoreFoundation/CoreFoundation.h&gt;
  35 
  36 #if TARGET_OS_IPHONE
  37 #import &lt;CoreGraphics/CoreGraphics.h&gt;
  38 #import &lt;CoreText/CoreText.h&gt;
  39 #else
  40 #import &lt;ApplicationServices/ApplicationServices.h&gt;
  41 #endif
  42 
  43 
  44 #define OS_NATIVE(func) Java_com_sun_javafx_font_coretext_OS_##func
  45 
  46 extern jboolean checkAndClearException(JNIEnv *env);
  47 
  48 jboolean checkAndClearException(JNIEnv *env)
  49 {
  50     jthrowable t = (*env)-&gt;ExceptionOccurred(env);
  51     if (!t) {
  52         return JNI_FALSE;
  53     }
  54     (*env)-&gt;ExceptionClear(env);
  55     return JNI_TRUE;
  56 }
  57 
  58 /**************************************************************************/
  59 /*                                                                        */
  60 /*                            Structs                                     */
  61 /*                                                                        */
  62 /**************************************************************************/
  63 typedef struct CGAffineTransform_FID_CACHE {
  64     int cached;
  65     jclass clazz;
  66     jfieldID a, b, c, d, tx, ty;
  67     jmethodID init;
  68 } CGAffineTransform_FID_CACHE;
  69 
  70 CGAffineTransform_FID_CACHE CGAffineTransformFc;
  71 
  72 void cacheCGAffineTransformFields(JNIEnv *env)
  73 {
  74     if (CGAffineTransformFc.cached) return;
  75     jclass tmpClass = (*env)-&gt;FindClass(env, &quot;com/sun/javafx/font/coretext/CGAffineTransform&quot;);
  76     if (checkAndClearException(env) || !tmpClass) {
  77         fprintf(stderr, &quot;cacheCGAffineTransformFields error: JNI exception or tmpClass == NULL&quot;);
  78         return;
  79     }
  80     CGAffineTransformFc.clazz =  (jclass)(*env)-&gt;NewGlobalRef(env, tmpClass);
  81     CGAffineTransformFc.a = (*env)-&gt;GetFieldID(env, CGAffineTransformFc.clazz, &quot;a&quot;, &quot;D&quot;);
  82     if (checkAndClearException(env) || !CGAffineTransformFc.a) {
  83         fprintf(stderr, &quot;cacheCGAffineTransformFields error: JNI exception or a == NULL&quot;);
  84         return;
  85     }
  86     CGAffineTransformFc.b = (*env)-&gt;GetFieldID(env, CGAffineTransformFc.clazz, &quot;b&quot;, &quot;D&quot;);
  87     if (checkAndClearException(env) || !CGAffineTransformFc.b) {
  88         fprintf(stderr, &quot;cacheCGAffineTransformFields error: JNI exception or b == NULL&quot;);
  89         return;
  90     }
  91     CGAffineTransformFc.c = (*env)-&gt;GetFieldID(env, CGAffineTransformFc.clazz, &quot;c&quot;, &quot;D&quot;);
  92     if (checkAndClearException(env) || !CGAffineTransformFc.c) {
  93         fprintf(stderr, &quot;cacheCGAffineTransformFields error: JNI exception or c == NULL&quot;);
  94         return;
  95     }
  96     CGAffineTransformFc.d = (*env)-&gt;GetFieldID(env, CGAffineTransformFc.clazz, &quot;d&quot;, &quot;D&quot;);
  97     if (checkAndClearException(env) || !CGAffineTransformFc.d) {
  98         fprintf(stderr, &quot;cacheCGAffineTransformFields error: JNI exception or d == NULL&quot;);
  99         return;
 100     }
 101     CGAffineTransformFc.tx = (*env)-&gt;GetFieldID(env, CGAffineTransformFc.clazz, &quot;tx&quot;, &quot;D&quot;);
 102     if (checkAndClearException(env) || !CGAffineTransformFc.tx) {
 103         fprintf(stderr, &quot;cacheCGAffineTransformFields error: JNI exception or tx == NULL&quot;);
 104         return;
 105     }
 106     CGAffineTransformFc.ty = (*env)-&gt;GetFieldID(env, CGAffineTransformFc.clazz, &quot;ty&quot;, &quot;D&quot;);
 107     if (checkAndClearException(env) || !CGAffineTransformFc.ty) {
 108         fprintf(stderr, &quot;cacheCGAffineTransformFields error: JNI exception or ty == NULL&quot;);
 109         return;
 110     }
 111     CGAffineTransformFc.init = (*env)-&gt;GetMethodID(env, CGAffineTransformFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 112     if (checkAndClearException(env) || !CGAffineTransformFc.init) {
 113         fprintf(stderr, &quot;cacheCGAffineTransformFields error: JNI exception or init == NULL&quot;);
 114         return;
 115     }
 116     CGAffineTransformFc.cached = 1;
 117 }
 118 
 119 CGAffineTransform *getCGAffineTransformFields(JNIEnv *env, jobject lpObject, CGAffineTransform *lpStruct)
 120 {
 121     if (!CGAffineTransformFc.cached) cacheCGAffineTransformFields(env);
 122     lpStruct-&gt;a = (*env)-&gt;GetDoubleField(env, lpObject, CGAffineTransformFc.a);
 123     lpStruct-&gt;b = (*env)-&gt;GetDoubleField(env, lpObject, CGAffineTransformFc.b);
 124     lpStruct-&gt;c = (*env)-&gt;GetDoubleField(env, lpObject, CGAffineTransformFc.c);
 125     lpStruct-&gt;d = (*env)-&gt;GetDoubleField(env, lpObject, CGAffineTransformFc.d);
 126     lpStruct-&gt;tx = (*env)-&gt;GetDoubleField(env, lpObject, CGAffineTransformFc.tx);
 127     lpStruct-&gt;ty = (*env)-&gt;GetDoubleField(env, lpObject, CGAffineTransformFc.ty);
 128     return lpStruct;
 129 }
 130 
 131 void setCGAffineTransformFields(JNIEnv *env, jobject lpObject, CGAffineTransform *lpStruct)
 132 {
 133     if (!CGAffineTransformFc.cached) cacheCGAffineTransformFields(env);
 134     (*env)-&gt;SetDoubleField(env, lpObject, CGAffineTransformFc.a, (jdouble)lpStruct-&gt;a);
 135     (*env)-&gt;SetDoubleField(env, lpObject, CGAffineTransformFc.b, (jdouble)lpStruct-&gt;b);
 136     (*env)-&gt;SetDoubleField(env, lpObject, CGAffineTransformFc.c, (jdouble)lpStruct-&gt;c);
 137     (*env)-&gt;SetDoubleField(env, lpObject, CGAffineTransformFc.d, (jdouble)lpStruct-&gt;d);
 138     (*env)-&gt;SetDoubleField(env, lpObject, CGAffineTransformFc.tx, (jdouble)lpStruct-&gt;tx);
 139     (*env)-&gt;SetDoubleField(env, lpObject, CGAffineTransformFc.ty, (jdouble)lpStruct-&gt;ty);
 140 }
 141 
 142 jobject newCGAffineTransform(JNIEnv *env, CGAffineTransform *lpStruct)
 143 {
 144     jobject lpObject = NULL;
 145     if (!CGAffineTransformFc.cached) cacheCGAffineTransformFields(env);
 146     lpObject = (*env)-&gt;NewObject(env, CGAffineTransformFc.clazz, CGAffineTransformFc.init);
 147     if (lpObject &amp;&amp; lpStruct) setCGAffineTransformFields(env, lpObject, lpStruct);
 148     return lpObject;
 149 }
 150 
 151 typedef struct CGPoint_FID_CACHE {
 152     int cached;
 153     jclass clazz;
 154     jfieldID x, y;
 155     jmethodID init;
 156 } CGPoint_FID_CACHE;
 157 
 158 CGPoint_FID_CACHE CGPointFc;
 159 
 160 void cacheCGPointFields(JNIEnv *env)
 161 {
 162     if (CGPointFc.cached) return;
 163     jclass tmpClass = (*env)-&gt;FindClass(env, &quot;com/sun/javafx/font/coretext/CGPoint&quot;);
 164     if (checkAndClearException(env) || !tmpClass) {
 165         fprintf(stderr, &quot;cacheCGPointFields error: JNI exception or tmpClass == NULL&quot;);
 166         return;
 167     }
 168     CGPointFc.clazz =  (jclass)(*env)-&gt;NewGlobalRef(env, tmpClass);
 169     CGPointFc.x = (*env)-&gt;GetFieldID(env, CGPointFc.clazz, &quot;x&quot;, &quot;D&quot;);
 170     if (checkAndClearException(env) || !CGPointFc.x) {
 171         fprintf(stderr, &quot;cacheCGPointFields error: JNI exception or x == NULL&quot;);
 172         return;
 173     }
 174     CGPointFc.y = (*env)-&gt;GetFieldID(env, CGPointFc.clazz, &quot;y&quot;, &quot;D&quot;);
 175     if (checkAndClearException(env) || !CGPointFc.y) {
 176         fprintf(stderr, &quot;cacheCGPointFields error: JNI exception or y == NULL&quot;);
 177         return;
 178     }
 179     CGPointFc.init = (*env)-&gt;GetMethodID(env, CGPointFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 180     if (checkAndClearException(env) || !CGPointFc.init) {
 181         fprintf(stderr, &quot;cacheCGPointFields error: JNI exception or init == NULL&quot;);
 182         return;
 183     }
 184     CGPointFc.cached = 1;
 185 }
 186 
 187 CGPoint *getCGPointFields(JNIEnv *env, jobject lpObject, CGPoint *lpStruct)
 188 {
 189     if (!CGPointFc.cached) cacheCGPointFields(env);
 190     lpStruct-&gt;x = (*env)-&gt;GetDoubleField(env, lpObject, CGPointFc.x);
 191     lpStruct-&gt;y = (*env)-&gt;GetDoubleField(env, lpObject, CGPointFc.y);
 192     return lpStruct;
 193 }
 194 
 195 void setCGPointFields(JNIEnv *env, jobject lpObject, CGPoint *lpStruct)
 196 {
 197     if (!CGPointFc.cached) cacheCGPointFields(env);
 198     (*env)-&gt;SetDoubleField(env, lpObject, CGPointFc.x, (jdouble)lpStruct-&gt;x);
 199     (*env)-&gt;SetDoubleField(env, lpObject, CGPointFc.y, (jdouble)lpStruct-&gt;y);
 200 }
 201 
 202 jobject newCGPoint(JNIEnv *env, CGPoint *lpStruct)
 203 {
 204     jobject lpObject = NULL;
 205     if (!CGPointFc.cached) cacheCGPointFields(env);
 206     lpObject = (*env)-&gt;NewObject(env, CGPointFc.clazz, CGPointFc.init);
 207     if (lpObject &amp;&amp; lpStruct) setCGPointFields(env, lpObject, lpStruct);
 208     return lpObject;
 209 }
 210 
 211 typedef struct CGSize_FID_CACHE {
 212     int cached;
 213     jclass clazz;
 214     jfieldID width, height;
 215     jmethodID init;
 216 } CGSize_FID_CACHE;
 217 
 218 CGSize_FID_CACHE CGSizeFc;
 219 
 220 void cacheCGSizeFields(JNIEnv *env)
 221 {
 222     if (CGSizeFc.cached) return;
 223     jclass tmpClass = (*env)-&gt;FindClass(env, &quot;com/sun/javafx/font/coretext/CGSize&quot;);
 224     if (checkAndClearException(env) || !tmpClass) {
 225         fprintf(stderr, &quot;cacheCGSizeFields error: JNI exception or tmpClass == NULL&quot;);
 226         return;
 227     }
 228     CGSizeFc.clazz =  (jclass)(*env)-&gt;NewGlobalRef(env, tmpClass);
 229     CGSizeFc.width = (*env)-&gt;GetFieldID(env, CGSizeFc.clazz, &quot;width&quot;, &quot;D&quot;);
 230     if (checkAndClearException(env) || !CGSizeFc.width) {
 231         fprintf(stderr, &quot;cacheCGSizeFields error: JNI exception or width == NULL&quot;);
 232         return;
 233     }
 234     CGSizeFc.height = (*env)-&gt;GetFieldID(env, CGSizeFc.clazz, &quot;height&quot;, &quot;D&quot;);
 235     if (checkAndClearException(env) || !CGSizeFc.height) {
 236         fprintf(stderr, &quot;cacheCGSizeFields error: JNI exception or height == NULL&quot;);
 237         return;
 238     }
 239     CGSizeFc.init = (*env)-&gt;GetMethodID(env, CGSizeFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 240     if (checkAndClearException(env) || !CGSizeFc.init) {
 241         fprintf(stderr, &quot;cacheCGSizeFields error: JNI exception or init == NULL&quot;);
 242         return;
 243     }
 244     CGSizeFc.cached = 1;
 245 }
 246 
 247 CGSize *getCGSizeFields(JNIEnv *env, jobject lpObject, CGSize *lpStruct)
 248 {
 249     if (!CGSizeFc.cached) cacheCGSizeFields(env);
 250     lpStruct-&gt;width = (*env)-&gt;GetDoubleField(env, lpObject, CGSizeFc.width);
 251     lpStruct-&gt;height = (*env)-&gt;GetDoubleField(env, lpObject, CGSizeFc.height);
 252     return lpStruct;
 253 }
 254 
 255 void setCGSizeFields(JNIEnv *env, jobject lpObject, CGSize *lpStruct)
 256 {
 257     if (!CGSizeFc.cached) cacheCGSizeFields(env);
 258     (*env)-&gt;SetDoubleField(env, lpObject, CGSizeFc.width, (jdouble)lpStruct-&gt;width);
 259     (*env)-&gt;SetDoubleField(env, lpObject, CGSizeFc.height, (jdouble)lpStruct-&gt;height);
 260 }
 261 
 262 jobject newCGSize(JNIEnv *env, CGSize *lpStruct)
 263 {
 264     jobject lpObject = NULL;
 265     if (!CGSizeFc.cached) cacheCGSizeFields(env);
 266     lpObject = (*env)-&gt;NewObject(env, CGSizeFc.clazz, CGSizeFc.init);
 267     if (lpObject &amp;&amp; lpStruct) setCGSizeFields(env, lpObject, lpStruct);
 268     return lpObject;
 269 }
 270 
 271 typedef struct CGRect_FID_CACHE {
 272     int cached;
 273     jclass clazz;
 274     jfieldID origin, size;
 275     jmethodID init;
 276 } CGRect_FID_CACHE;
 277 
 278 CGRect_FID_CACHE CGRectFc;
 279 
 280 void cacheCGRectFields(JNIEnv *env)
 281 {
 282     if (CGRectFc.cached) return;
 283     jclass tmpClass = (*env)-&gt;FindClass(env, &quot;com/sun/javafx/font/coretext/CGRect&quot;);
 284     if (checkAndClearException(env) || !tmpClass) {
 285         fprintf(stderr, &quot;cacheCGRectFields error: JNI exception or tmpClass == NULL&quot;);
 286         return;
 287     }
 288     CGRectFc.clazz =  (jclass)(*env)-&gt;NewGlobalRef(env, tmpClass);
 289     CGRectFc.origin = (*env)-&gt;GetFieldID(env, CGRectFc.clazz, &quot;origin&quot;, &quot;Lcom/sun/javafx/font/coretext/CGPoint;&quot;);
 290     if (checkAndClearException(env) || !CGRectFc.origin) {
 291         fprintf(stderr, &quot;cacheCGRectFields error: JNI exception or origin == NULL&quot;);
 292         return;
 293     }
 294     CGRectFc.size = (*env)-&gt;GetFieldID(env, CGRectFc.clazz, &quot;size&quot;, &quot;Lcom/sun/javafx/font/coretext/CGSize;&quot;);
 295     if (checkAndClearException(env) || !CGRectFc.size) {
 296         fprintf(stderr, &quot;cacheCGRectFields error: JNI exception or size == NULL&quot;);
 297         return;
 298     }
 299     CGRectFc.init = (*env)-&gt;GetMethodID(env, CGRectFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 300     if (checkAndClearException(env) || !CGRectFc.init) {
 301         fprintf(stderr, &quot;cacheCGRectFields error: JNI exception or init == NULL&quot;);
 302         return;
 303     }
 304     CGRectFc.cached = 1;
 305 }
 306 
 307 CGRect *getCGRectFields(JNIEnv *env, jobject lpObject, CGRect *lpStruct)
 308 {
 309     if (!CGRectFc.cached) cacheCGRectFields(env);
 310     {
 311     jobject lpObject1 = (*env)-&gt;GetObjectField(env, lpObject, CGRectFc.origin);
 312     if (lpObject1 != NULL) getCGPointFields(env, lpObject1, &amp;lpStruct-&gt;origin);
 313     }
 314     {
 315     jobject lpObject1 = (*env)-&gt;GetObjectField(env, lpObject, CGRectFc.size);
 316     if (lpObject1 != NULL) getCGSizeFields(env, lpObject1, &amp;lpStruct-&gt;size);
 317     }
 318     return lpStruct;
 319 }
 320 
 321 void setCGRectFields(JNIEnv *env, jobject lpObject, CGRect *lpStruct)
 322 {
 323     if (!CGRectFc.cached) cacheCGRectFields(env);
 324     {
 325     jobject lpObject1 = (*env)-&gt;GetObjectField(env, lpObject, CGRectFc.origin);
 326     if (lpObject1 != NULL) setCGPointFields(env, lpObject1, &amp;lpStruct-&gt;origin);
 327     }
 328     {
 329     jobject lpObject1 = (*env)-&gt;GetObjectField(env, lpObject, CGRectFc.size);
 330     if (lpObject1 != NULL) setCGSizeFields(env, lpObject1, &amp;lpStruct-&gt;size);
 331     }
 332 }
 333 
 334 jobject newCGRect(JNIEnv *env, CGRect *lpStruct)
 335 {
 336     jobject lpObject = NULL;
 337     if (!CGRectFc.cached) cacheCGRectFields(env);
 338     lpObject = (*env)-&gt;NewObject(env, CGRectFc.clazz, CGRectFc.init);
 339     if (lpObject &amp;&amp; lpStruct) setCGRectFields(env, lpObject, lpStruct);
 340     return lpObject;
 341 }
 342 
 343 /**************************************************************************/
 344 /*                                                                        */
 345 /*                            Functions                                   */
 346 /*                                                                        */
 347 /**************************************************************************/
 348 
 349 JNIEXPORT jlong JNICALL OS_NATIVE(kCFAllocatorDefault)
 350     (JNIEnv *env, jclass that)
 351 {
 352     return (jlong)kCFAllocatorDefault;
 353 }
 354 
 355 JNIEXPORT jlong JNICALL OS_NATIVE(CFStringCreateWithCharacters__J_3CJ)
 356     (JNIEnv *env, jclass that, jlong arg0, jcharArray arg1, jlong arg2)
 357 {
 358     jchar *lparg1=NULL;
 359     jlong rc = 0;
 360     if (arg1) if ((lparg1 = (*env)-&gt;GetCharArrayElements(env, arg1, NULL)) == NULL) goto fail;
 361     rc = (jlong)CFStringCreateWithCharacters((CFAllocatorRef)arg0, (UniChar*)lparg1, (CFIndex)arg2);
 362 fail:
 363     if (arg1 &amp;&amp; lparg1) (*env)-&gt;ReleaseCharArrayElements(env, arg1, lparg1, 0);
 364     return rc;
 365 }
 366 
 367 JNIEXPORT void JNICALL OS_NATIVE(CFRelease)
 368     (JNIEnv *env, jclass that, jlong arg0)
 369 {
 370     CFRelease((CFTypeRef)arg0);
 371 }
 372 
 373 JNIEXPORT jlong JNICALL OS_NATIVE(CTFontCreateWithGraphicsFont)
 374     (JNIEnv *env, jclass that, jlong cgFont, jdouble size, jobject matrix, jlong attributes)
 375 {
 376     CGAffineTransform transform;
 377     if (matrix) {
 378         getCGAffineTransformFields(env, matrix, &amp;transform);
 379     } else {
 380         transform = CGAffineTransformIdentity;
 381     }
 382     return (jlong)CTFontCreateWithGraphicsFont((CGFontRef)cgFont, (CGFloat)size, &amp;transform, (CTFontDescriptorRef)attributes);
 383 }
 384 
 385 JNIEXPORT jlong JNICALL OS_NATIVE(CTFontCreateWithName)
 386     (JNIEnv *env, jclass that, jlong arg0, jdouble arg1, jobject arg2)
 387 {
 388     CGAffineTransform _arg2, *lparg2=NULL;
 389     jlong rc = 0;
 390     if (arg2) if ((lparg2 = getCGAffineTransformFields(env, arg2, &amp;_arg2)) == NULL) goto fail;
 391     CFStringRef fontName = (CFStringRef)arg0;
 392     if (CFStringGetCharacterAtIndex(fontName, 0) == &#39;.&#39;) {
 393         bool bold = CFStringFind(fontName, CFSTR(&quot;bold&quot;), kCFCompareCaseInsensitive).location != kCFNotFound;
 394         CTFontRef font = CTFontCreateUIFontForLanguage(bold ? kCTFontUIFontEmphasizedSystem : kCTFontUIFontSystem, 0.0, NULL);
 395         rc = (jlong) CTFontCreateCopyWithAttributes(font, (CGFloat)arg1, (CGAffineTransform*)lparg2, NULL);
 396         CFRelease(font);
 397     } else {
 398         rc = (jlong) CTFontCreateWithName(fontName, (CGFloat)arg1, (CGAffineTransform*)lparg2);
 399     }
 400 fail:
 401     /* In only */
 402 //    if (arg2 &amp;&amp; lparg2) setCGAffineTransformFields(env, arg2, lparg2);
 403     return rc;
 404 }
 405 
 406 
 407 JNIEXPORT jlong JNICALL OS_NATIVE(CFURLCreateWithFileSystemPath)
 408     (JNIEnv *env, jclass that, jlong arg0, jlong arg1, jlong arg2, jboolean arg3)
 409 {
 410     return (jlong)CFURLCreateWithFileSystemPath((CFAllocatorRef)arg0, (CFStringRef)arg1, (CFURLPathStyle)arg2, (Boolean)arg3);
 411 }
 412 
 413 JNIEXPORT jboolean JNICALL OS_NATIVE(CTFontManagerRegisterFontsForURL)
 414     (JNIEnv *env, jclass that, jlong arg0, jint arg1, jlong arg2)
 415 {
 416     return (jboolean)CTFontManagerRegisterFontsForURL((CFURLRef)arg0, (CTFontManagerScope)arg1, (CFErrorRef*)arg2);
 417 }
 418 
 419 JNIEXPORT jlong JNICALL OS_NATIVE(CTFontCreatePathForGlyph)
 420     (JNIEnv *env, jclass that, jlong arg0, jshort arg1, jobject arg2)
 421 {
 422     CGAffineTransform _arg2, *lparg2=NULL;
 423     jlong rc = 0;
 424     if (arg2) if ((lparg2 = getCGAffineTransformFields(env, arg2, &amp;_arg2)) == NULL) goto fail;
 425     rc = (jlong)CTFontCreatePathForGlyph((CTFontRef)arg0, (CGGlyph)arg1, (CGAffineTransform*)lparg2);
 426 fail:
 427     /* In Only */
 428 //    if (arg2 &amp;&amp; lparg2) setCGAffineTransformFields(env, arg2, lparg2);
 429     return rc;
 430 }
 431 
 432 JNIEXPORT jlong JNICALL OS_NATIVE(CGFontCreateWithDataProvider)
 433     (JNIEnv *env, jclass that, jlong dataProvider)
 434 {
 435     return (jlong)CGFontCreateWithDataProvider((CGDataProviderRef)dataProvider);
 436 }
 437 
 438 JNIEXPORT void JNICALL OS_NATIVE(CGPathRelease)
 439     (JNIEnv *env, jclass that, jlong arg0)
 440 {
 441     CGPathRelease((CGPathRef)arg0);
 442 }
 443 
 444 JNIEXPORT jlong JNICALL OS_NATIVE(CGColorSpaceCreateDeviceRGB)
 445     (JNIEnv *env, jclass that)
 446 {
 447     return (jlong)CGColorSpaceCreateDeviceRGB();
 448 }
 449 
 450 JNIEXPORT jlong JNICALL OS_NATIVE(CGColorSpaceCreateDeviceGray)
 451     (JNIEnv *env, jclass that)
 452 {
 453     return (jlong)CGColorSpaceCreateDeviceGray();
 454 }
 455 
 456 JNIEXPORT jlong JNICALL OS_NATIVE(CGBitmapContextCreate)
 457     (JNIEnv *env, jclass that, jlong arg0, jlong arg1, jlong arg2, jlong arg3, jlong arg4, jlong arg5, jint arg6)
 458 {
 459     return (jlong)CGBitmapContextCreate((void*)arg0, (size_t)arg1, (size_t)arg2, (size_t)arg3, (size_t)arg4, (CGColorSpaceRef)arg5, (CGBitmapInfo)arg6);
 460 }
 461 
 462 JNIEXPORT void JNICALL OS_NATIVE(CGContextSetAllowsFontSmoothing)
 463     (JNIEnv *env, jclass that, jlong arg0, jboolean arg1)
 464 {
 465     CGContextSetAllowsFontSmoothing((CGContextRef)arg0, (_Bool)arg1);
 466 }
 467 
 468 JNIEXPORT void JNICALL OS_NATIVE(CGContextSetAllowsAntialiasing)
 469     (JNIEnv *env, jclass that, jlong arg0, jboolean arg1)
 470 {
 471     CGContextSetAllowsAntialiasing((CGContextRef)arg0, (_Bool)arg1);
 472 }
 473 
 474 JNIEXPORT void JNICALL OS_NATIVE(CGContextSetAllowsFontSubpixelPositioning)
 475     (JNIEnv *env, jclass that, jlong arg0, jboolean arg1)
 476 {
 477     CGContextSetAllowsFontSubpixelPositioning((CGContextRef)arg0, (_Bool)arg1);
 478 }
 479 
 480 JNIEXPORT void JNICALL OS_NATIVE(CGContextSetAllowsFontSubpixelQuantization)
 481     (JNIEnv *env, jclass that, jlong arg0, jboolean arg1)
 482 {
 483     CGContextSetAllowsFontSubpixelQuantization((CGContextRef)arg0, (_Bool)arg1);
 484 }
 485 
 486 JNIEXPORT void JNICALL OS_NATIVE(CGContextSetRGBFillColor)
 487     (JNIEnv *env, jclass that, jlong arg0, jdouble arg1, jdouble arg2, jdouble arg3, jdouble arg4)
 488 {
 489     CGContextSetRGBFillColor((CGContextRef)arg0, (CGFloat)arg1, (CGFloat)arg2, (CGFloat)arg3, (CGFloat)arg4);
 490 }
 491 
 492 JNIEXPORT void JNICALL OS_NATIVE(CGContextFillRect)
 493     (JNIEnv *env, jclass that, jlong arg0, jobject arg1)
 494 {
 495     CGRect _arg1, *lparg1=NULL;
 496     /* In Only */
 497     if (arg1) if ((lparg1 = getCGRectFields(env, arg1, &amp;_arg1)) == NULL) return;
 498     CGContextFillRect((CGContextRef)arg0, *lparg1);
 499 }
 500 
 501 JNIEXPORT void JNICALL OS_NATIVE(CGContextTranslateCTM)
 502     (JNIEnv *env, jclass that, jlong arg0, jdouble arg1, jdouble arg2)
 503 {
 504     CGContextTranslateCTM((CGContextRef)arg0, (CGFloat)arg1, (CGFloat)arg2);
 505 }
 506 
 507 JNIEXPORT void JNICALL OS_NATIVE(CGContextRelease)
 508     (JNIEnv *env, jclass that, jlong arg0)
 509 {
 510     CGContextRelease((CGContextRef)arg0);
 511 }
 512 
 513 JNIEXPORT void JNICALL OS_NATIVE(CGColorSpaceRelease)
 514     (JNIEnv *env, jclass that, jlong arg0)
 515 {
 516     CGColorSpaceRelease((CGColorSpaceRef)arg0);
 517 }
 518 
 519 JNIEXPORT jlong JNICALL OS_NATIVE(CGDataProviderCreateWithURL)
 520     (JNIEnv *env, jclass that, jlong cfURL) {
 521       return (jlong)CGDataProviderCreateWithURL((CFURLRef)cfURL);
 522 }
 523 
 524 JNIEXPORT jlong JNICALL OS_NATIVE(kCFTypeDictionaryKeyCallBacks)
 525     (JNIEnv *env, jclass that)
 526 {
 527     return (jlong)&amp;kCFTypeDictionaryKeyCallBacks;
 528 }
 529 
 530 JNIEXPORT jlong JNICALL OS_NATIVE(kCFTypeDictionaryValueCallBacks)
 531     (JNIEnv *env, jclass that)
 532 {
 533     return (jlong)&amp;kCFTypeDictionaryValueCallBacks;
 534 }
 535 
 536 JNIEXPORT jlong JNICALL OS_NATIVE(CFDictionaryCreateMutable)
 537     (JNIEnv *env, jclass that, jlong arg0, jlong arg1, jlong arg2, jlong arg3)
 538 {
 539     return (jlong)CFDictionaryCreateMutable((CFAllocatorRef)arg0, (CFIndex)arg1, (CFDictionaryKeyCallBacks*)arg2, (CFDictionaryValueCallBacks*)arg3);
 540 }
 541 
 542 JNIEXPORT void JNICALL OS_NATIVE(CFDictionaryAddValue)
 543     (JNIEnv *env, jclass that, jlong arg0, jlong arg1, jlong arg2)
 544 {
 545     CFDictionaryAddValue((CFMutableDictionaryRef)arg0, (void*)arg1, (void*)arg2);
 546 }
 547 
 548 JNIEXPORT jlong JNICALL OS_NATIVE(CFDictionaryGetValue)
 549     (JNIEnv *env, jclass that, jlong arg0, jlong arg1)
 550 {
 551     return (jlong)CFDictionaryGetValue((CFDictionaryRef)arg0, (void*)arg1);
 552 }
 553 
 554 JNIEXPORT jlong JNICALL OS_NATIVE(kCTFontAttributeName)
 555     (JNIEnv *env, jclass that)
 556 {
 557     return (jlong)kCTFontAttributeName;
 558 }
 559 
 560 JNIEXPORT jlong JNICALL OS_NATIVE(kCTParagraphStyleAttributeName)
 561     (JNIEnv *env, jclass that)
 562 {
 563     return (jlong)kCTParagraphStyleAttributeName;
 564 }
 565 
 566 JNIEXPORT jlong JNICALL OS_NATIVE(CFAttributedStringCreate)
 567     (JNIEnv *env, jclass that, jlong arg0, jlong arg1, jlong arg2)
 568 {
 569     return (jlong)CFAttributedStringCreate((CFAllocatorRef)arg0, (CFStringRef)arg1, (CFDictionaryRef)arg2);
 570 }
 571 
 572 JNIEXPORT jlong JNICALL OS_NATIVE(CTLineCreateWithAttributedString)
 573     (JNIEnv *env, jclass that, jlong arg0)
 574 {
 575     return (jlong)CTLineCreateWithAttributedString((CFAttributedStringRef)arg0);
 576 }
 577 
 578 JNIEXPORT jlong JNICALL OS_NATIVE(CTLineGetGlyphRuns)
 579     (JNIEnv *env, jclass that, jlong arg0)
 580 {
 581     return (jlong)CTLineGetGlyphRuns((CTLineRef)arg0);
 582 }
 583 
 584 JNIEXPORT jdouble JNICALL OS_NATIVE(CTLineGetTypographicBounds)
 585     (JNIEnv *env, jclass that, jlong arg0)
 586 {
 587     return (jdouble)CTLineGetTypographicBounds((CTLineRef)arg0, NULL, NULL, NULL);
 588 }
 589 
 590 JNIEXPORT jlong JNICALL OS_NATIVE(CTLineGetGlyphCount)
 591     (JNIEnv *env, jclass that, jlong arg0)
 592 {
 593     return (jlong)CTLineGetGlyphCount((CTLineRef)arg0);
 594 }
 595 
 596 JNIEXPORT jlong JNICALL OS_NATIVE(CFArrayGetCount)
 597     (JNIEnv *env, jclass that, jlong arg0)
 598 {
 599     return (jlong)CFArrayGetCount((CFArrayRef)arg0);
 600 }
 601 
 602 JNIEXPORT jlong JNICALL OS_NATIVE(CFArrayGetValueAtIndex)
 603     (JNIEnv *env, jclass that, jlong arg0, jlong arg1)
 604 {
 605     return (jlong)CFArrayGetValueAtIndex((CFArrayRef)arg0, (CFIndex)arg1);
 606 }
 607 
 608 JNIEXPORT jlong JNICALL OS_NATIVE(CTRunGetGlyphCount)
 609     (JNIEnv *env, jclass that, jlong arg0)
 610 {
 611     return (jlong)CTRunGetGlyphCount((CTRunRef)arg0);
 612 }
 613 
 614 JNIEXPORT jlong JNICALL OS_NATIVE(CTRunGetAttributes)
 615     (JNIEnv *env, jclass that, jlong arg0)
 616 {
 617     return (jlong)CTRunGetAttributes((CTRunRef)arg0);
 618 }
 619 
 620 /**************************************************************************/
 621 /*                                                                        */
 622 /*                           Custom Functions                             */
 623 /*                                                                        */
 624 /**************************************************************************/
 625 
 626 
 627 JNIEXPORT jlong JNICALL OS_NATIVE(CFStringCreateWithCharacters__J_3CJJ)
 628     (JNIEnv *env, jclass that, jlong arg0, jcharArray arg1, jlong arg2, jlong arg3)
 629 {
 630     jchar *lparg1=NULL;
 631     jlong rc = 0;
 632     if (arg1) if ((lparg1 = (*env)-&gt;GetPrimitiveArrayCritical(env, arg1, NULL)) == NULL) goto fail;
 633     UniChar* str = lparg1 + arg2;
 634     rc = (jlong)CFStringCreateWithCharacters((CFAllocatorRef)arg0, str, (CFIndex)arg3);
 635 fail:
 636     if (arg1 &amp;&amp; lparg1) (*env)-&gt;ReleasePrimitiveArrayCritical(env, arg1, lparg1, 0);
 637     return rc;
 638 }
 639 
 640 JNIEXPORT jint JNICALL OS_NATIVE(CTRunGetGlyphs)
 641     (JNIEnv *env, jclass that, jlong runRef, jint slotMask, jint start, jintArray bufferRef)
 642 {
 643     CTRunRef run = (CTRunRef)runRef;
 644     const CGGlyph * glyphs = CTRunGetGlyphsPtr(run);
 645     CFIndex count = CTRunGetGlyphCount(run);
 646     if (count == 0) {
 647         return 0;
 648     }
 649 
 650     CGGlyph* tempGlyphs = NULL;
 651     if (!glyphs) {
 652         tempGlyphs = (CGGlyph*) malloc(count * sizeof(CGGlyph));
 653         if (!tempGlyphs) {
 654             return 0;
 655         }
 656 
 657         CTRunGetGlyphs(run, CFRangeMake(0, 0), tempGlyphs);
 658         glyphs = tempGlyphs;
 659     }
 660 
 661     int i = 0;
 662     if (glyphs) {
 663         jint* buffer = (*env)-&gt;GetPrimitiveArrayCritical(env, bufferRef, NULL);
 664         if (buffer) {
 665             while(i &lt; count) {
 666                 buffer[start + i] = slotMask | (glyphs[i] &amp; 0xFFFF);
 667                 i++;
 668             }
 669             (*env)-&gt;ReleasePrimitiveArrayCritical(env, bufferRef, buffer, 0);
 670         }
 671     }
 672 
 673     if (tempGlyphs) {
 674         free(tempGlyphs);
 675     }
 676     return i;
 677 }
 678 
 679 JNIEXPORT jint JNICALL OS_NATIVE(CTRunGetPositions)
 680     (JNIEnv *env, jclass that, jlong runRef, jint start, jfloatArray bufferRef)
 681 {
 682     CTRunRef run = (CTRunRef)runRef;
 683     const CGPoint* positions = CTRunGetPositionsPtr(run);
 684     CFIndex count = CTRunGetGlyphCount(run);
 685     if (count == 0) {
 686         return 0;
 687     }
 688 
 689     CGPoint* tempPositions = NULL;
 690     if (!positions) {
 691         tempPositions = (CGPoint*) malloc(count * sizeof(CGPoint));
 692         if (!tempPositions) {
 693             return 0;
 694         }
 695 
 696         CTRunGetPositions(run, CFRangeMake(0, 0), tempPositions);
 697         positions = tempPositions;
 698     }
 699 
 700     int j = 0;
 701     if (positions) {
 702         jfloat* buffer = (*env)-&gt;GetPrimitiveArrayCritical(env, bufferRef, NULL);
 703         if (buffer) {
 704             int i = 0;
 705             while (i &lt; count) {
 706                 CGPoint pos = positions[i++];
 707                 buffer[start + j++] = pos.x;
 708                 buffer[start + j++] = pos.y;
 709             }
 710             (*env)-&gt;ReleasePrimitiveArrayCritical(env, bufferRef, buffer, 0);
 711         }
 712     }
 713 
 714     if (tempPositions) {
 715         free(tempPositions);
 716     }
 717     return j;
 718 }
 719 
 720 JNIEXPORT jint JNICALL OS_NATIVE(CTRunGetStringIndices)
 721     (JNIEnv *env, jclass that, jlong runRef, jint start, jintArray bufferRef)
 722 {
 723     CTRunRef run = (CTRunRef)runRef;
 724     const CFIndex* indices = CTRunGetStringIndicesPtr(run);
 725     CFIndex count = CTRunGetGlyphCount(run);
 726     if (count == 0) {
 727         return 0;
 728     }
 729 
 730     CFIndex* tempIndices = NULL;
 731     if (!indices) {
 732         tempIndices = (CFIndex*) malloc(count * sizeof(CFIndex));
 733         if (!tempIndices) {
 734             return 0;
 735         }
 736 
 737         CTRunGetStringIndices(run, CFRangeMake(0, 0), tempIndices);
 738         indices = tempIndices;
 739     }
 740 
 741     int i = 0;
 742     if (indices) {
 743         jint* buffer = (*env)-&gt;GetPrimitiveArrayCritical(env, bufferRef, NULL);
 744         if (buffer) {
 745             while(i &lt; count) {
 746                 buffer[start + i] = indices[i];
 747                 i++;
 748             }
 749             (*env)-&gt;ReleasePrimitiveArrayCritical(env, bufferRef, buffer, 0);
 750         }
 751 
 752         if (tempIndices) {
 753             free(tempIndices);
 754         }
 755     }
 756     return i;
 757 }
 758 
 759 JNIEXPORT jstring JNICALL OS_NATIVE(CTFontCopyAttributeDisplayName)
 760     (JNIEnv *env, jclass that, jlong arg0)
 761 {
 762     CFStringRef stringRef = CTFontCopyAttribute((CTFontRef)arg0, kCTFontDisplayNameAttribute);
 763     if (stringRef == NULL) return NULL;
 764     CFIndex length = CFStringGetLength(stringRef);
 765     UniChar buffer[length];
 766     CFStringGetCharacters(stringRef, CFRangeMake(0, length), buffer);
 767     CFRelease(stringRef);
 768     return (*env)-&gt;NewString(env, (jchar *)buffer, length);
 769 }
 770 
 771 JNIEXPORT jbyteArray JNICALL OS_NATIVE(CGBitmapContextGetData)
 772     (JNIEnv *env, jclass that, jlong arg0, jint dstWidth, jint dstHeight, jint bpp)
 773 {
 774     jbyteArray result = NULL;
 775     if (dstWidth &lt; 0) return NULL;
 776     if (dstHeight &lt; 0) return NULL;
 777     if (bpp != 8 &amp;&amp; bpp != 24) return NULL;
 778     CGContextRef context = (CGContextRef)arg0;
 779     if (context == NULL) return NULL;
 780     jbyte *srcData = (jbyte*)CGBitmapContextGetData(context);
 781 
 782     if (srcData) {
 783         /* Use one byte per pixel for grayscale */
 784         size_t srcWidth = CGBitmapContextGetWidth(context);
 785         if (srcWidth &lt; dstWidth) return NULL;
 786         size_t srcHeight =  CGBitmapContextGetHeight(context);
 787         if (srcHeight &lt; dstHeight) return NULL;
 788         size_t srcBytesPerRow = CGBitmapContextGetBytesPerRow(context);
 789         size_t srcStep = CGBitmapContextGetBitsPerPixel(context) / 8;
 790         int srcOffset = (srcHeight - dstHeight) * srcBytesPerRow;
 791 
 792 
 793         //bits per pixel, either 8 for gray or 24 for LCD.
 794         int dstStep = bpp / 8;
 795         size_t size = dstWidth * dstHeight * dstStep;
 796         jbyte* data = (jbyte*)calloc(size, sizeof(jbyte));
 797         if (data == NULL) return NULL;
 798 
 799         int x, y, sx;
 800         int dstOffset = 0;
 801         for (y = 0; y &lt; dstHeight; y++) {
 802             for (x = 0, sx = 0; x &lt; dstWidth; x++, dstOffset += dstStep, sx += srcStep) {
 803                 if (dstStep == 1) {
 804                     /* BGRA or Gray to Gray */
 805                     data[dstOffset] = 0xFF - srcData[srcOffset + sx];
 806                 } else {
 807                     /* BGRA to RGB */
 808                     data[dstOffset]     = 0xFF - srcData[srcOffset + sx + 2];
 809                     data[dstOffset + 1] = 0xFF - srcData[srcOffset + sx + 1];
 810                     data[dstOffset + 2] = 0xFF - srcData[srcOffset + sx];
 811                 }
 812             }
 813             srcOffset += srcBytesPerRow;
 814         }
 815 
 816         result = (*env)-&gt;NewByteArray(env, size);
 817         if (result) {
 818             (*env)-&gt;SetByteArrayRegion(env, result, 0, size, data);
 819         }
 820         free(data);
 821     }
 822     return result;
 823 }
 824 
 825 JNIEXPORT void JNICALL OS_NATIVE(CGRectApplyAffineTransform)
 826     (JNIEnv *env, jclass that, jobject arg0, jobject arg1)
 827 {
 828     CGRect _arg0, *lparg0=NULL;
 829     CGAffineTransform _arg1, *lparg1=NULL;
 830     if (arg0) if ((lparg0 = getCGRectFields(env, arg0, &amp;_arg0)) == NULL) goto fail;
 831     if (arg1) if ((lparg1 = getCGAffineTransformFields(env, arg1, &amp;_arg1)) == NULL) goto fail;
 832     _arg0 = CGRectApplyAffineTransform(*lparg0, *lparg1);
 833 fail:
 834     /* In Only */
 835 //    if (arg1 &amp;&amp; lparg1) setCGAffineTransformFields(env, arg1, lparg1);
 836     if (arg0 &amp;&amp; lparg0) setCGRectFields(env, arg0, lparg0);
 837 }
 838 
 839 JNIEXPORT void JNICALL OS_NATIVE(CTFontDrawGlyphs)
 840     (JNIEnv *env, jclass that, jlong arg0, jshort arg1, jdouble arg2, jdouble arg3, jlong contextRef)
 841 {
 842     /* Custom: only takes one glyph at the time */
 843     CGGlyph glyphs[] = {arg1};
 844     CGPoint pos[] = {CGPointMake(arg2, arg3)};
 845     CTFontDrawGlyphs((CTFontRef)arg0, glyphs, pos, 1, (CGContextRef)contextRef);
 846 }
 847 
 848 JNIEXPORT jboolean JNICALL OS_NATIVE(CTFontGetBoundingRectForGlyphUsingTables)
 849     (JNIEnv *env, jclass that, jlong arg1, jshort arg2, jshort arg3, jintArray arg4)
 850 {
 851     /* The following code is based on scalerMethods.c#getGlyphBoundingBoxNative */
 852     CTFontRef fontRef = (CTFontRef)arg1;
 853     CTFontTableOptions options = kCTFontTableOptionNoOptions;
 854     CFDataRef tableData;
 855     CFIndex length;
 856 
 857     /* indexToLocFormat is stored in Java for performance */
 858 //    tableData = CTFontCopyTable(fontRef, kCTFontTableHead, options);
 859 //    const UInt8 * head = CFDataGetBytePtr(tableData);
 860 //    UInt16 indexToLocFormat = CFSwapInt16BigToHost(*((SInt16*)(head + 50)));
 861 //    printf(&quot;here0 indexToLocFormat=%u \n&quot;, indexToLocFormat); fflush(stdout);
 862 //    CFRelease(tableData);
 863     UInt16 indexToLocFormat = arg3;
 864 
 865     tableData = CTFontCopyTable(fontRef, kCTFontTableLoca, options);
 866     if (tableData == NULL) return FALSE;
 867     length = CFDataGetLength(tableData);
 868     UInt32 offset1 = 0, offset2 = 0;
 869     UInt32 index = arg2 &amp; 0xFFFF;
 870     if (indexToLocFormat) {
 871         const UInt32 * loca = (const UInt32 *)CFDataGetBytePtr(tableData);
 872         if (loca != NULL &amp;&amp; (index + 1) &lt; (length / 4)) {
 873             offset1 = CFSwapInt32BigToHost(loca[index]);
 874             offset2 = CFSwapInt32BigToHost(loca[index + 1]);
 875         }
 876     } else {
 877         const UInt16 * loca = (const UInt16 *)CFDataGetBytePtr(tableData);
 878         if (loca != NULL &amp;&amp; (index + 1) &lt; (length / 2)) {
 879             offset1 = CFSwapInt16BigToHost(loca[index]) &lt;&lt; 1;
 880             offset2 = CFSwapInt16BigToHost(loca[index + 1]) &lt;&lt; 1;
 881         }
 882     }
 883     CFRelease(tableData);
 884     jboolean result = FALSE;
 885     if (offset2 &gt; offset1 &amp;&amp; (offset2 - offset1) &gt;= 10) {
 886         tableData = CTFontCopyTable(fontRef, kCTFontTableGlyf, options);
 887         if (tableData == NULL) return FALSE;
 888         length = CFDataGetLength(tableData);
 889         const UInt8 * ptr = CFDataGetBytePtr(tableData);
 890         if (ptr != NULL &amp;&amp; (offset1 + 10) &lt; length) {
 891             const SInt16 * glyf = (const SInt16 *)(ptr + offset1);
 892             /*
 893              * CFSwapInt16BigToHost returns an unsigned short, need
 894              * to cast back to signed short before assigning to jint.
 895              */
 896             jint data[] = {
 897                 (SInt16)CFSwapInt16BigToHost(glyf[1]),
 898                 (SInt16)CFSwapInt16BigToHost(glyf[2]),
 899                 (SInt16)CFSwapInt16BigToHost(glyf[3]),
 900                 (SInt16)CFSwapInt16BigToHost(glyf[4]),
 901             };
 902             (*env)-&gt;SetIntArrayRegion(env, arg4, 0, 4, data);
 903             result = TRUE;
 904         }
 905         CFRelease(tableData);
 906     }
 907     return result;
 908 }
 909 
 910 JNIEXPORT jdouble JNICALL OS_NATIVE(CTFontGetAdvancesForGlyphs)
 911     (JNIEnv *env, jclass that, jlong arg0, jint arg1, jshort arg2, jobject arg3)
 912 {
 913     /* Custom: only takes one glyph at the time */
 914     jdouble rc = 0;
 915     CGGlyph glyphs[] = {arg2};
 916     CGSize _arg3, *lparg3=NULL;
 917     if (arg3) if ((lparg3 = getCGSizeFields(env, arg3, &amp;_arg3)) == NULL) goto fail;
 918     rc = (jdouble)CTFontGetAdvancesForGlyphs((CTFontRef)arg0, (CTFontOrientation)arg1, glyphs, lparg3, 1);
 919 fail:
 920     if (arg3 &amp;&amp; lparg3) setCGSizeFields(env, arg3, &amp;_arg3);
 921     return rc;
 922 }
 923 
 924 JNIEXPORT jobject JNICALL OS_NATIVE(CGPathGetPathBoundingBox)
 925     (JNIEnv *env, jclass that, jlong arg0)
 926 {
 927     CGRect result = CGPathGetPathBoundingBox((CGPathRef)arg0);
 928     return newCGRect(env, &amp;result);
 929 }
 930 
 931 JNIEXPORT jlong JNICALL OS_NATIVE(CTParagraphStyleCreate)
 932     (JNIEnv *env, jclass that, jint arg0)
 933 {
 934     CTWritingDirection dir = (CTWritingDirection)arg0;
 935     CTParagraphStyleSetting settings[] = {
 936         {kCTParagraphStyleSpecifierBaseWritingDirection, sizeof(dir), &amp;dir}
 937     };
 938     return (jlong)CTParagraphStyleCreate(settings, sizeof(settings) / sizeof(settings[0]));
 939 }
 940 
 941 /***********************************************/
 942 /*                Glyph Outline                */
 943 /***********************************************/
 944 
 945 static const int DEFAULT_LEN_TYPES = 10;
 946 static const int DEFAULT_LEN_COORDS = 50;
 947 typedef struct _PathData {
 948     jbyte* pointTypes;
 949     int numTypes;
 950     int lenTypes;
 951     jfloat* pointCoords;
 952     int numCoords;
 953     int lenCoords;
 954 } PathData;
 955 
 956 void pathApplierFunctionFast(void *i, const CGPathElement *e) {
 957     PathData *info = (PathData *)i;
 958     if (info-&gt;numTypes == info-&gt;lenTypes) {
 959         info-&gt;lenTypes += DEFAULT_LEN_TYPES;
 960         info-&gt;pointTypes = (jbyte*)realloc(info-&gt;pointTypes, info-&gt;lenTypes * sizeof(jbyte));
 961     }
 962     jint type;
 963     int coordCount = 0;
 964     switch (e-&gt;type) {
 965     case kCGPathElementMoveToPoint:
 966         type = 0;
 967         coordCount = 1;
 968         break;
 969     case kCGPathElementAddLineToPoint:
 970         type = 1;
 971         coordCount = 1;
 972         break;
 973     case kCGPathElementAddQuadCurveToPoint:
 974         type = 2;
 975         coordCount = 2;
 976         break;
 977     case kCGPathElementAddCurveToPoint:
 978         type = 3;
 979         coordCount = 3;
 980         break;
 981     case kCGPathElementCloseSubpath:
 982         type = 4;
 983         coordCount = 0;
 984         break;
 985     }
 986     info-&gt;pointTypes[info-&gt;numTypes++] = type;
 987 
 988     if (info-&gt;numCoords + (coordCount * 2) &gt; info-&gt;lenCoords) {
 989         info-&gt;lenCoords += DEFAULT_LEN_COORDS;
 990         info-&gt;pointCoords = (jfloat*)realloc(info-&gt;pointCoords, info-&gt;lenCoords * sizeof(jfloat));
 991     }
 992     int j;
 993     for (j = 0; j &lt; coordCount; j++) {
 994         CGPoint pt = e-&gt;points[j];
 995         info-&gt;pointCoords[info-&gt;numCoords++] = pt.x;
 996         info-&gt;pointCoords[info-&gt;numCoords++] = pt.y;
 997     }
 998 }
 999 
1000 JNIEXPORT jobject JNICALL OS_NATIVE(CGPathApply)
1001     (JNIEnv *env, jclass that, jlong arg0)
1002 {
1003     jobject path2D = NULL;
1004     PathData data;
1005     data.pointTypes = (jbyte*)malloc(sizeof(jbyte) * DEFAULT_LEN_TYPES);
1006     data.numTypes = 0;
1007     data.lenTypes = DEFAULT_LEN_TYPES;
1008     data.pointCoords = (jfloat*)malloc(sizeof(jfloat) * DEFAULT_LEN_COORDS);
1009     data.numCoords = 0;
1010     data.lenCoords = DEFAULT_LEN_COORDS;
1011 
1012     CGPathApply((CGPathRef)arg0, &amp;data, pathApplierFunctionFast);
1013 
1014     static jclass path2DClass = NULL;
1015     static jmethodID path2DCtr = NULL;
1016     if (path2DClass == NULL) {
1017         jclass tmpClass = (*env)-&gt;FindClass(env, &quot;com/sun/javafx/geom/Path2D&quot;);
1018         if ((*env)-&gt;ExceptionOccurred(env) || !tmpClass) {
1019             fprintf(stderr, &quot;OS_NATIVE error: JNI exception or tmpClass == NULL&quot;);
1020             goto fail;
1021         }
1022         path2DClass = (jclass)(*env)-&gt;NewGlobalRef(env, tmpClass);
1023         path2DCtr = (*env)-&gt;GetMethodID(env, path2DClass, &quot;&lt;init&gt;&quot;, &quot;(I[BI[FI)V&quot;);
1024         if ((*env)-&gt;ExceptionOccurred(env) || !path2DCtr) {
1025             fprintf(stderr, &quot;OS_NATIVE error: JNI exception or path2DCtr == NULL&quot;);
1026             goto fail;
1027         }
1028     }
1029 
1030     jbyteArray types = (*env)-&gt;NewByteArray(env, data.numTypes);
1031     jfloatArray coords = (*env)-&gt;NewFloatArray(env, data.numCoords);
1032     if (types &amp;&amp; coords) {
1033         (*env)-&gt;SetByteArrayRegion(env, types, 0, data.numTypes, data.pointTypes);
1034         if ((*env)-&gt;ExceptionOccurred(env)) {
1035             fprintf(stderr, &quot;OS_NATIVE error: JNI exception&quot;);
1036             goto fail;
1037         }
1038         (*env)-&gt;SetFloatArrayRegion(env, coords, 0, data.numCoords, data.pointCoords);
1039         if ((*env)-&gt;ExceptionOccurred(env)) {
1040             fprintf(stderr, &quot;OS_NATIVE error: JNI exception&quot;);
1041             goto fail;
1042         }
1043         path2D = (*env)-&gt;NewObject(env, path2DClass, path2DCtr,
1044                                    0 /*winding rule*/,
1045                                    types, data.numTypes,
1046                                    coords, data.numCoords);
1047         if ((*env)-&gt;ExceptionOccurred(env) || !path2D) {
1048             goto fail;
1049         }
1050     }
1051 fail:
1052     free(data.pointTypes);
1053     free(data.pointCoords);
1054     return path2D;
1055 }
1056 
1057 #endif /* TARGET_OS_MAC */
1058 #endif /* __APPLE__ */
1059 
    </pre>
  </body>
</html>