<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGRegion.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.sg.prism;
  27 
  28 import javafx.geometry.Insets;
  29 import javafx.geometry.Side;
  30 import javafx.scene.layout.Background;
  31 import javafx.scene.layout.BackgroundFill;
  32 import javafx.scene.layout.BackgroundImage;
  33 import javafx.scene.layout.BackgroundPosition;
  34 import javafx.scene.layout.BackgroundRepeat;
  35 import javafx.scene.layout.BackgroundSize;
  36 import javafx.scene.layout.Border;
  37 import javafx.scene.layout.BorderImage;
  38 import javafx.scene.layout.BorderRepeat;
  39 import javafx.scene.layout.BorderStroke;
  40 import javafx.scene.layout.BorderStrokeStyle;
  41 import javafx.scene.layout.BorderWidths;
  42 import javafx.scene.layout.CornerRadii;
  43 import javafx.scene.paint.Color;
  44 import javafx.scene.paint.LinearGradient;
  45 import javafx.scene.shape.StrokeLineCap;
  46 import javafx.scene.shape.StrokeLineJoin;
  47 import javafx.scene.shape.StrokeType;
  48 
  49 import java.util.Collections;
  50 import java.util.List;
  51 import java.util.WeakHashMap;
  52 
  53 import com.sun.glass.ui.Screen;
  54 import com.sun.javafx.PlatformUtil;
  55 import com.sun.javafx.application.PlatformImpl;
  56 import com.sun.javafx.geom.Path2D;
  57 import com.sun.javafx.geom.RectBounds;
  58 import com.sun.javafx.geom.Rectangle;
  59 import com.sun.javafx.geom.Shape;
  60 import com.sun.javafx.geom.transform.Affine2D;
  61 import com.sun.javafx.geom.transform.BaseTransform;
  62 import com.sun.javafx.geom.transform.GeneralTransform3D;
  63 import com.sun.javafx.logging.PulseLogger;
  64 import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
  65 import com.sun.javafx.scene.NodeHelper;
  66 import com.sun.javafx.tk.Toolkit;
  67 import com.sun.prism.BasicStroke;
  68 import com.sun.prism.Graphics;
  69 import com.sun.prism.Image;
  70 import com.sun.prism.RTTexture;
  71 import com.sun.prism.Texture;
  72 import com.sun.prism.impl.PrismSettings;
  73 import com.sun.prism.paint.ImagePattern;
  74 import com.sun.prism.paint.Paint;
  75 import com.sun.prism.PrinterGraphics;
  76 import com.sun.scenario.effect.Offset;
  77 
  78 /**
  79  * Implementation of the Region peer. This behaves like an NGGroup, in that
  80  * it has children, but like a leaf node, in that it also draws itself if it has
  81  * a Background or Border which contains non-transparent fills / strokes / images.
  82  */
  83 public class NGRegion extends NGGroup {
  84     /**
  85      * This scratch transform is used when transforming shapes. Because this is
  86      * a static variable, it is only intended to be used from a single thread,
  87      * the render thread in this case.
  88      */
  89     private static final Affine2D SCRATCH_AFFINE = new Affine2D();
  90 
  91     /**
  92      * Temporary rect for general use. Because this is a static variable,
  93      * it is only intended to be used from a single thread, the render thread
  94      * in this case.
  95      */
  96     private static final Rectangle TEMP_RECT = new Rectangle();
  97 
  98     /**
  99      * Screen to RegionImageCache mapping. This mapping is required as textures
 100      * are only valid in graphics context used to create them (relies on a one
 101      * to one mapping between Screen and GraphicsContext).
 102      */
 103     private static WeakHashMap&lt;Screen, RegionImageCache&gt; imageCacheMap = new WeakHashMap&lt;&gt;();
 104 
 105     /**
 106      * Indicates the cached image can be sliced vertically.
 107      */
 108     private static final int CACHE_SLICE_V = 0x1;
 109 
 110     /**
 111      * Indicates the cached image can be sliced horizontally.
 112      */
 113     private static final int CACHE_SLICE_H = 0x2;
 114 
 115     /**
 116      * The background to use for drawing. Since this is an immutable object, I can simply refer to
 117      * its fields / methods directly when rendering. I will make sure this is not ever null at
 118      * the time that we do the sync, so that the code in this class can assume non-null.
 119      */
 120     private Background background = Background.EMPTY;
 121 
 122     /**
 123      * The combined insets of all the backgrounds. As of right now, Background doesn&#39;t store
 124      * this information itself, although it probably could (and probably should).
 125      */
 126     private Insets backgroundInsets = Insets.EMPTY;
 127 
 128     /**
 129      * The border to use for drawing. Similar to background, this is not-null and immutable.
 130      */
 131     private Border border = Border.EMPTY;
 132 
 133     /**
 134      * The normalized list of CornerRadii have been precomputed at the FX layer to
 135      * properly account for percentages, insets and radii scaling to prevent
 136      * the radii from overflowing the dimensions of the region.
 137      * The List objects are shared with the FX layer and are therefore
 138      * unmodifiable.  If the normalized list is null then it means that all
 139      * of the raw radii in the list were already absolute and non-overflowing
 140      * and so the originals can be used from the arrays of strokes and fills.
 141      */
 142     private List&lt;CornerRadii&gt; normalizedFillCorners;
 143     private List&lt;CornerRadii&gt; normalizedStrokeCorners;
 144 
 145     /**
 146      * The shape of the region. Usually this will be null (except for things like check box
 147      * checks, scroll bar down arrows / up arrows, etc). If this is not null, it determines
 148      * the shape of the region to draw. If it is null, then the assumed shape of the region is
 149      * one of a rounded rectangle. This shape is a com.sun.javafx.geom.Shape, and is not
 150      * touched by the FX scene graph except during synchronization, so it is safe to access
 151      * on the render thread.
 152      */
 153     private Shape shape;
 154     private NGShape ngShape;
 155 
 156     /**
 157      * Whether we should scale the shape to match the bounds of the region. Only applies
 158      * if the shape is not null.
 159      */
 160     private boolean scaleShape = true;
 161 
 162     /**
 163      * Whether we should center the shape within the bounds of the region. Only applies
 164      * if the shape is not null.
 165      */
 166     private boolean centerShape = true;
 167 
 168     /**
 169      * Whether we should attempt to use region caching for a region with a shape.
 170      */
 171     private boolean cacheShape = false;
 172 
 173     /**
 174      * A cached set of the opaque insets as given to us during synchronization. We hold
 175      * on to this so that we can determine the opaque insets in the computeOpaqueRegion method.
 176      */
 177     private float opaqueTop = Float.NaN,
 178             opaqueRight = Float.NaN,
 179             opaqueBottom = Float.NaN,
 180             opaqueLeft = Float.NaN;
 181 
 182     /**
 183      * The width and height of the region.
 184      */
 185     private float width, height;
 186 
 187     /**
 188      * Determined when a background is set on the region, this flag indicates whether this
 189      * background can be cached. As of this time, the only backgrounds which can be cached
 190      * are those where there are only solid fills or linear gradients.
 191      */
 192     private int cacheMode;
 193 
 194     /**
 195      * Is the key into the image cache that identifies the required background
 196      * for the region.
 197      */
 198     private Integer cacheKey;
 199 
 200     /**
 201      * Simple Helper Function for cleanup.
 202      */
 203     static Paint getPlatformPaint(javafx.scene.paint.Paint paint) {
 204         return (Paint)Toolkit.getPaintAccessor().getPlatformPaint(paint);
 205     }
 206 
 207     // We create a class instance of a no op. Effect internally to handle 3D
 208     // transform if user didn&#39;t use Effect for 3D Transformed Region. This will
 209     // automatically forces Region rendering path to use the Effect path.
 210     private static final Offset nopEffect = new Offset(0, 0, null);
 211     private EffectFilter nopEffectFilter;
 212 
 213     /**************************************************************************
 214      *                                                                        *
 215      * Methods used during synchronization only.                              *
 216      *                                                                        *
 217      *************************************************************************/
 218 
 219     /**
 220      * Called by the Region during synchronization. The Region *should* ensure that this is only
 221      * called when one of these properties has changed. The cost of calling it excessively is
 222      * only that the opaque region is invalidated excessively. Updating the shape and
 223      * associated booleans is actually a very cheap operation.
 224      *
 225      * @param shape    The shape, may be null.
 226      * @param scaleShape whether to scale the shape
 227      * @param positionShape whether to center the shape
 228      */
 229     public void updateShape(Object shape, boolean scaleShape, boolean positionShape, boolean cacheShape) {
 230         this.ngShape = shape == null ? null : NodeHelper.getPeer(((javafx.scene.shape.Shape)shape));
 231         this.shape = shape == null ? null : ngShape.getShape();
 232         this.scaleShape = scaleShape;
 233         this.centerShape = positionShape;
 234         this.cacheShape = cacheShape;
 235         // Technically I don&#39;t think this is needed because whenever the shape changes, setOpaqueInsets
 236         // is also called, so this will get invalidated twice.
 237         invalidateOpaqueRegion();
 238         cacheKey = null;
 239         visualsChanged();
 240     }
 241 
 242     /**
 243      * Called by the Region whenever the width or height of the region has changed.
 244      * The Region *should* only call this when the width or height have actually changed.
 245      *
 246      * @param width     The width of the region, not including insets or outsets
 247      * @param height    The height of the region, not including insets or outsets
 248      */
 249     public void setSize(float width, float height) {
 250         this.width = width;
 251         this.height = height;
 252         invalidateOpaqueRegion();
 253         cacheKey = null;
 254         visualsChanged();
 255         // We only have to clear the background insets when the size changes if the
 256         // background has fills who&#39;s insets are dependent on the size (as would be
 257         // true only if a CornerRadii of any background fill on the background had
 258         // a percentage based radius).
 259         if (background != null &amp;&amp; background.isFillPercentageBased()) {
 260             backgroundInsets = null;
 261         }
 262     }
 263 
 264     /**
 265      * Called by Region whenever an image that was being loaded in the background has
 266      * finished loading. Nothing changes in terms of metrics or sizes or caches, but
 267      * we do need to repaint everything.
 268      */
 269     public void imagesUpdated() {
 270         visualsChanged();
 271     }
 272 
 273     /**
 274      * Called by the Region when the Border is changed. The Region *must* only call
 275      * this method if the border object has actually changed, or excessive work may be done.
 276      *
 277      * @param b Border, of type javafx.scene.layout.Border
 278      */
 279     public void updateBorder(Border b) {
 280         // Make sure that the border instance we store on this NGRegion is never null
 281         final Border old = border;
 282         border = b == null ? Border.EMPTY : b;
 283 
 284         // Determine whether the geometry has changed, or if only the visuals have
 285         // changed. Geometry changes will require more work, and an equals check
 286         // on the border objects is generally very fast (either for identity or
 287         // for !equals. It is a bit longer for when they really are equal, but faster
 288         // than a geometryChanged!)
 289         if (!border.getOutsets().equals(old.getOutsets())) {
 290             geometryChanged();
 291         } else {
 292             visualsChanged();
 293         }
 294     }
 295 
 296     /**
 297      * Called by the Region when any parameters are changed.
 298      * It is only technically needed when a parameter that affects the size
 299      * of any percentage or overflowing corner radii is changed, but since
 300      * the data is not processed here in NGRegion, it is set on every update
 301      * of the peers for any reason.
 302      * A null value means that the raw radii in the BorderStroke objects
 303      * themselves were already absolute and non-overflowing.
 304      *
 305      * @param normalizedStrokeCorners a precomputed copy of the radii in the
 306      *        BorderStroke objects that are not percentages and do not overflow
 307      */
 308     public void updateStrokeCorners(List&lt;CornerRadii&gt; normalizedStrokeCorners) {
 309         this.normalizedStrokeCorners = normalizedStrokeCorners;
 310     }
 311 
 312     /**
 313      * Returns the normalized (non-percentage, non-overflowing) radii for the
 314      * selected index into the BorderStroke objects.
 315      * If a List was synchronized from the Region object, the value from that
 316      * List, otherwise the raw radii are fetched from the indicated BorderStroke
 317      * object.
 318      *
 319      * @param index the index of the BorderStroke object being processed
 320      * @return the normalized radii for the indicated BorderStroke object
 321      */
 322     private CornerRadii getNormalizedStrokeRadii(int index) {
 323         return (normalizedStrokeCorners == null
 324                 ? border.getStrokes().get(index).getRadii()
 325                 : normalizedStrokeCorners.get(index));
 326     }
 327 
 328     /**
 329      * Called by the Region when the Background has changed. The Region *must* only call
 330      * this method if the background object has actually changed, or excessive work may be done.
 331      *
 332      * @param b    Background, of type javafx.scene.layout.Background. Can be null.
 333      */
 334     public void updateBackground(Background b) {
 335         // NOTE: We don&#39;t explicitly invalidate the opaque region in this method, because the
 336         // Region will always call setOpaqueInsets whenever the background is changed, and
 337         // setOpaqueInsets always invalidates the opaque region. So we don&#39;t have to do it
 338         // again here. This wasn&#39;t immediately obvious and it might be better to combine
 339         // the updateBackground and setOpaqueInsets methods into one call, so that we
 340         // can more easily ensure that the opaque region is updated correctly.
 341 
 342         // Make sure that the background instance we store on this NGRegion is never null
 343         final Background old = background;
 344         background = b == null ? Background.EMPTY : b;
 345 
 346         final List&lt;BackgroundFill&gt; fills = background.getFills();
 347         cacheMode = 0;
 348         if (!PrismSettings.disableRegionCaching &amp;&amp; !fills.isEmpty() &amp;&amp; (shape == null || cacheShape)) {
 349             cacheMode = CACHE_SLICE_H | CACHE_SLICE_V;
 350             for (int i=0, max=fills.size(); i&lt;max &amp;&amp; cacheMode != 0; i++) {
 351                 // We need to now inspect the paint to determine whether we can use a cache for this background.
 352                 // If a shape is being used, we don&#39;t care about gradients (we cache &#39;em both), but for a rectangle
 353                 // fill we omit these (so we can do 3-patch scaling). An ImagePattern is deadly to either
 354                 // (well, only deadly to a shape if it turns out to be a writable image).
 355                 final BackgroundFill fill = fills.get(i);
 356                 javafx.scene.paint.Paint paint = fill.getFill();
 357                 if (shape == null) {
 358                     if (paint instanceof LinearGradient) {
 359                         LinearGradient linear = (LinearGradient) paint;
 360                         if (linear.getStartX() != linear.getEndX()) {
 361                             cacheMode &amp;= ~CACHE_SLICE_H;
 362                         }
 363                         if (linear.getStartY() != linear.getEndY()) {
 364                             cacheMode &amp;= ~CACHE_SLICE_V;
 365                         }
 366                     } else if (!(paint instanceof Color)) {
 367                         //Either radial gradient or image pattern
 368                         cacheMode = 0;
 369                     }
 370                 } else if (paint instanceof javafx.scene.paint.ImagePattern) {
 371                     cacheMode = 0;
 372                 }
 373             }
 374         }
 375         backgroundInsets = null;
 376         cacheKey = null;
 377 
 378         // Only update the geom if the new background is geometrically different from the old
 379         if (!background.getOutsets().equals(old.getOutsets())) {
 380             geometryChanged();
 381         } else {
 382             visualsChanged();
 383         }
 384     }
 385 
 386     /**
 387      * Called by the Region when any parameters are changed.
 388      * It is only technically needed when a parameter that affects the size
 389      * of any percentage or overflowing corner radii is changed, but since
 390      * the data is not processed here in NGRegion, it is set on every update
 391      * of the peers for any reason.
 392      * A null value means that the raw radii in the BackgroundFill objects
 393      * themselves were already absolute and non-overflowing.
 394      *
 395      * @param normalizedStrokeCorners a precomputed copy of the radii in the
 396      *        BackgroundFill objects that are not percentages and do not overflow
 397      */
 398     public void updateFillCorners(List&lt;CornerRadii&gt; normalizedFillCorners) {
 399         this.normalizedFillCorners = normalizedFillCorners;
 400     }
 401 
 402     /**
 403      * Returns the normalized (non-percentage, non-overflowing) radii for the
 404      * selected index into the BackgroundFill objects.
 405      * If a List was synchronized from the Region object, the value from that
 406      * List, otherwise the raw radii are fetched from the indicated BackgroundFill
 407      * object.
 408      *
 409      * @param index the index of the BackgroundFill object being processed
 410      * @return the normalized radii for the indicated BackgroundFill object
 411      */
 412     private CornerRadii getNormalizedFillRadii(int index) {
 413         return (normalizedFillCorners == null
 414                 ? background.getFills().get(index).getRadii()
 415                 : normalizedFillCorners.get(index));
 416     }
 417 
 418     /**
 419      * Called by the Region whenever it knows that the opaque insets have changed. The
 420      * Region &lt;strong&gt;must&lt;/strong&gt; make sure that these opaque insets include the opaque
 421      * inset information from the Border and Background as well, the NGRegion will not
 422      * recompute this information. This is done because Border and Background are immutable,
 423      * and as such this information is computed once and stored rather than recomputed
 424      * each time we have to render. Any developer supplied opaque insets must be combined
 425      * with the Border / Background intrinsic opaque insets prior to this call and passed
 426      * as the arguments to this method.
 427      *
 428      * @param top       The top, if NaN then there is no opaque inset at all
 429      * @param right     The right, must not be NaN or Infinity, etc.
 430      * @param bottom    The bottom, must not be NaN or Infinity, etc.
 431      * @param left      The left, must not be NaN or Infinity, etc.
 432      */
 433     public void setOpaqueInsets(float top, float right, float bottom, float left) {
 434         opaqueTop = top;
 435         opaqueRight = right;
 436         opaqueBottom = bottom;
 437         opaqueLeft = left;
 438         invalidateOpaqueRegion();
 439     }
 440 
 441     /**
 442      * When cleaning the dirty tree, we also have to keep in mind
 443      * the NGShape used by the NGRegion
 444      */
 445     @Override public void clearDirtyTree() {
 446         super.clearDirtyTree();
 447         if (ngShape != null) {
 448             ngShape.clearDirtyTree();
 449         }
 450     }
 451 
 452     /**************************************************************************
 453      *                                                                        *
 454      * Implementations of methods defined in the parent classes, with the     *
 455      * exception of rendering methods.                                        *
 456      *                                                                        *
 457      *************************************************************************/
 458 
 459     private RegionImageCache getImageCache(final Graphics g) {
 460         final Screen screen = g.getAssociatedScreen();
 461         RegionImageCache cache = imageCacheMap.get(screen);
 462         if (cache != null) {
 463             RTTexture tex = cache.getBackingStore();
 464             if (tex.isSurfaceLost()) {
 465                 imageCacheMap.remove(screen);
 466                 cache = null;
 467             }
 468         }
 469         if (cache == null) {
 470             cache = new RegionImageCache(g.getResourceFactory());
 471             imageCacheMap.put(screen, cache);
 472         }
 473         return cache;
 474     }
 475 
 476     private Integer getCacheKey(int w, int h) {
 477         if (cacheKey == null) {
 478             int key = 31 * w;
 479             key = key * 37 + h;
 480             key = key * 47 + background.hashCode();
 481             if (shape != null) {
 482                 key = key * 73 + shape.hashCode();
 483             }
 484             cacheKey = key;
 485         }
 486         return cacheKey;
 487     }
 488 
 489     @Override protected boolean supportsOpaqueRegions() { return true; }
 490 
 491     @Override
 492     protected boolean hasOpaqueRegion() {
 493         return super.hasOpaqueRegion() &amp;&amp;
 494                 !Float.isNaN(opaqueTop) &amp;&amp; !Float.isNaN(opaqueRight) &amp;&amp;
 495                 !Float.isNaN(opaqueBottom) &amp;&amp; !Float.isNaN(opaqueLeft);
 496     }
 497 
 498     /**
 499      * The opaque region of an NGRegion takes into account the opaque insets
 500      * specified by the Region during synchronization. It also takes into
 501      * account the clip and the effect.
 502      *
 503      * @param opaqueRegion
 504      * @return
 505      */
 506     @Override protected RectBounds computeOpaqueRegion(RectBounds opaqueRegion) {
 507         // TODO what to do if the opaqueRegion has negative width or height due to excessive opaque insets? (RT-26979)
 508         return (RectBounds) opaqueRegion.deriveWithNewBounds(opaqueLeft, opaqueTop, 0, width - opaqueRight, height - opaqueBottom, 0);
 509     }
 510 
 511     @Override protected RenderRootResult computeRenderRoot(NodePath path, RectBounds dirtyRegion,
 512                                                            int cullingIndex, BaseTransform tx,
 513                                                            GeneralTransform3D pvTx) {
 514 
 515         RenderRootResult result = super.computeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);
 516         if (result == RenderRootResult.NO_RENDER_ROOT){
 517             result = computeNodeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);
 518         }
 519         return result;
 520     }
 521 
 522     @Override protected boolean hasVisuals() {
 523         // This isn&#39;t entirely accurate -- the background might
 524         // not be empty but still not draw anything since a BackgroundFill
 525         // might be TRANSPARENT. The same is true of the border, which
 526         // might have BorderStrokes but perhaps none of them draw.
 527         return !border.isEmpty() || !background.isEmpty();
 528     }
 529 
 530     @Override protected boolean hasOverlappingContents() {
 531         // It may be that this can be optimized further, but I&#39;m a bit
 532         // worried about it as I would have to check that the children do not
 533         // overlap with the strokes, and the strokes don&#39;t overlap each other,
 534         // and there are no backgrounds, etc. So there are a few fast paths
 535         // that could be used, but not sure it is really of any benefit in
 536         // the real cases.
 537         return true;
 538     }
 539 
 540     /**************************************************************************
 541      *                                                                        *
 542      * Region drawing.                                                        *
 543      *                                                                        *
 544      *************************************************************************/
 545 
 546     @Override protected void renderContent(Graphics g) {
 547         // Use Effect to render a 3D transformed Region that does not contain 3D
 548         // transformed children. This is done in order to render the Region&#39;s
 549         // content and children into an image in local coordinates using the identity
 550         // transform. The resulting image will then be correctly transformed in 3D by
 551         // the composite transform used to render this Region.
 552         // However, we avoid doing this for Regions whose children have a 3D
 553         // transform, because it will flatten the transforms of those children
 554         // and not look correct.
 555         if (!g.getTransformNoClone().is2D() &amp;&amp; this.isContentBounds2D()) {
 556             assert (getEffectFilter() == null);
 557 
 558             // Use Effect to render 3D transformed Region.
 559             // We will need to use a no op. Effect internally since user
 560             // didn&#39;t use Effect for this Region
 561             if (nopEffectFilter == null) {
 562                 nopEffectFilter = new EffectFilter(nopEffect, this);
 563             }
 564             nopEffectFilter.render(g);
 565 
 566             return;
 567         }
 568 
 569         // If the shape is not null, then the shape will define what we need to draw for
 570         // this region. If the shape is null, then the &quot;shape&quot; of the region is just a
 571         // rectangle (or rounded rectangle, depending on the Background).
 572         if (shape != null) {
 573             renderAsShape(g);
 574         } else if (width &gt; 0 &amp;&amp; height &gt; 0) {
 575             renderAsRectangle(g);
 576         }
 577 
 578         // Paint the children
 579         super.renderContent(g);
 580     }
 581 
 582     /**************************************************************************
 583      *                                                                        *
 584      * Drawing a region background and borders when the Region has been       *
 585      * specified to have a shape. This is typically used to render some       *
 586      * portions of a UI Control, such as the tick on a CheckBox, the dot on a *
 587      * RadioButton, or the disclosure node arrow on a TreeView. In these      *
 588      * cases, the overall region size is typically very small and can         *
 589      * therefore easily be cached.                                            *
 590      *                                                                        *
 591      *************************************************************************/
 592 
 593     private void renderAsShape(Graphics g) {
 594         if (!background.isEmpty()) {
 595             // Note: resizeShape is not cheap. This should be refactored so that we only invoke
 596             // it if we absolutely have to. Specifically, if the background, shape, and size of the region
 597             // has not changed since the last time we rendered we could skip all this and render
 598             // directly out of a cache.
 599             final Insets outsets = background.getOutsets();
 600             final Shape outsetShape = resizeShape((float) -outsets.getTop(), (float) -outsets.getRight(),
 601                                                   (float) -outsets.getBottom(), (float) -outsets.getLeft());
 602             final RectBounds outsetShapeBounds = outsetShape.getBounds();
 603             final int textureWidth = Math.round(outsetShapeBounds.getWidth()),
 604                       textureHeight = Math.round(outsetShapeBounds.getHeight());
 605 
 606             final int border = 1;
 607             // See if we have a cached representation for this region background already. In UI controls,
 608             // the arrow in a scroll bar button or the dot in a radio button or the tick in a check box are
 609             // all examples of cases where we&#39;d like to reuse a cached image for performance reasons rather
 610             // than re-drawing everything each time.
 611 
 612             RTTexture cached = null;
 613             Rectangle rect = null;
 614             // RT-25013: We need to make sure that we do not use a cached image in the case of a
 615             // scaled region, or things won&#39;t look right (they&#39;ll looked scaled instead of vector-resized).
 616             if (cacheMode != 0 &amp;&amp; g.getTransformNoClone().isTranslateOrIdentity() &amp;&amp; !(g instanceof PrinterGraphics)) {
 617                 final RegionImageCache imageCache = getImageCache(g);
 618                 if (imageCache.isImageCachable(textureWidth, textureHeight)) {
 619                     final Integer key = getCacheKey(textureWidth, textureHeight);
 620                     rect = TEMP_RECT;
 621                     rect.setBounds(0, 0, textureWidth + border, textureHeight + border);
 622                     boolean render = imageCache.getImageLocation(key, rect, background, shape, g);
 623                     if (!rect.isEmpty()) {
 624                         // An empty rect indicates a failure occurred in the imageCache
 625                         cached = imageCache.getBackingStore();
 626                     }
 627                     if (cached != null &amp;&amp; render) {
 628                         Graphics cachedGraphics = cached.createGraphics();
 629 
 630                         // Have to move the origin such that when rendering to x=0, we actually end up rendering
 631                         // at x=bounds.getMinX(). Otherwise anything rendered to the left of the origin would be lost
 632                         cachedGraphics.translate(rect.x - outsetShapeBounds.getMinX(),
 633                                                  rect.y - outsetShapeBounds.getMinY());
 634                         renderBackgroundShape(cachedGraphics);
 635                         if (PULSE_LOGGING_ENABLED) {
 636                             PulseLogger.incrementCounter(&quot;Rendering region shape image to cache&quot;);
 637                         }
 638                     }
 639                 }
 640             }
 641 
 642             // &quot;cached&quot; might not be null if either there was a cached image, or we just created one.
 643             // In either case, we need to now render from the cached texture to the graphics
 644             if (cached != null) {
 645                 // We just draw exactly what it was we have cached
 646                 final float dstX1 = outsetShapeBounds.getMinX();
 647                 final float dstY1 = outsetShapeBounds.getMinY();
 648                 final float dstX2 = outsetShapeBounds.getMaxX();
 649                 final float dstY2 = outsetShapeBounds.getMaxY();
 650 
 651                 final float srcX1 = rect.x;
 652                 final float srcY1 = rect.y;
 653                 final float srcX2 = srcX1 + textureWidth;
 654                 final float srcY2 = srcY1 + textureHeight;
 655 
 656                 g.drawTexture(cached, dstX1, dstY1, dstX2, dstY2, srcX1, srcY1, srcX2, srcY2);
 657                 if (PULSE_LOGGING_ENABLED) {
 658                     PulseLogger.incrementCounter(&quot;Cached region shape image used&quot;);
 659                 }
 660             } else {
 661                 // no cache, rendering backgrounds directly to graphics
 662                 renderBackgroundShape(g);
 663             }
 664         }
 665 
 666         // Note that if you use borders, you&#39;re going to pay a premium in performance.
 667         // I don&#39;t think this is strictly necessary (since we won&#39;t stretch a cached
 668         // region shape anyway), so really this code should some how be combined
 669         // with the caching code that happened above for backgrounds.
 670         if (!border.isEmpty()) {
 671             // We only deal with stroke borders, we never deal with ImageBorders when
 672             // painting a shape on a Region. This is primarily because we don&#39;t know
 673             // how to handle a 9-patch image on a random shape. We&#39;ll have to implement
 674             // this at some point, but today is not that day.
 675             final List&lt;BorderStroke&gt; strokes = border.getStrokes();
 676             for (int i = 0, max = strokes.size(); i &lt; max; i++) {
 677                 // Get the BorderStroke. When stroking a shape, we only honor the
 678                 // topStroke, topStyle, widths.top, and insets.
 679                 final BorderStroke stroke = strokes.get(i);
 680                 // We&#39;re stroking a path, so there is no point trying to figure out the length.
 681                 // Instead, we just pass -1, telling setBorderStyle to just do a simple stroke
 682                 setBorderStyle(g, stroke, -1, false);
 683                 final Insets insets = stroke.getInsets();
 684                 g.draw(resizeShape((float) insets.getTop(), (float) insets.getRight(),
 685                                    (float) insets.getBottom(), (float) insets.getLeft()));
 686             }
 687         }
 688     }
 689 
 690     private void renderBackgroundShape(Graphics g) {
 691         if (PULSE_LOGGING_ENABLED) {
 692             PulseLogger.incrementCounter(&quot;NGRegion renderBackgroundShape slow path&quot;);
 693             PulseLogger.addMessage(&quot;Slow shape path for &quot; + getName());
 694         }
 695 
 696         // We first need to draw each background fill. We don&#39;t pay any attention
 697         // to the radii of the BackgroundFill, but we do honor the insets and
 698         // the fill paint itself.
 699         final List&lt;BackgroundFill&gt; fills = background.getFills();
 700         for (int i = 0, max = fills.size(); i &lt; max; i++) {
 701             final BackgroundFill fill = fills.get(i);
 702             // Get the paint for this BackgroundFill. It should not be possible
 703             // for it to ever be null
 704             final Paint paint = getPlatformPaint(fill.getFill());
 705             assert paint != null;
 706             g.setPaint(paint);
 707             // Adjust the box within which we will fit the shape based on the
 708             // insets. The resize shape method will resize the shape to fit
 709             final Insets insets = fill.getInsets();
 710             g.fill(resizeShape((float) insets.getTop(), (float) insets.getRight(),
 711                                (float) insets.getBottom(), (float) insets.getLeft()));
 712         }
 713 
 714         // We now need to draw each background image. Only the &quot;cover&quot; property
 715         // of BackgroundImage, and the &quot;image&quot; property itself, have any impact
 716         // on how the image is applied to a Shape.
 717         final List&lt;BackgroundImage&gt; images = background.getImages();
 718         for (int i = 0, max = images.size(); i &lt; max; i++) {
 719             final BackgroundImage image = images.get(i);
 720             final Image prismImage = (Image) Toolkit.getImageAccessor().getPlatformImage(image.getImage());
 721             if (prismImage == null) {
 722                 // The prismImage might be null if the Image has not completed loading.
 723                 // In that case, we simply must skip rendering of that layer this
 724                 // time around.
 725                 continue;
 726             }
 727             // We need to translate the shape based on 0 insets. This will for example
 728             // center and / or position the shape if necessary.
 729             final Shape translatedShape = resizeShape(0, 0, 0, 0);
 730             // Now ensure that the ImagePattern is based on the x/y position of the
 731             // shape and not on the 0,0 position of the region.
 732             final RectBounds bounds = translatedShape.getBounds();
 733             ImagePattern pattern = image.getSize().isCover() ?
 734                     new ImagePattern(prismImage, bounds.getMinX(), bounds.getMinY(),
 735                                      bounds.getWidth(), bounds.getHeight(), false, false) :
 736                     new ImagePattern(prismImage, bounds.getMinX(), bounds.getMinY(),
 737                                      prismImage.getWidth(), prismImage.getHeight(), false, false);
 738             g.setPaint(pattern);
 739             // Go ahead and finally fill!
 740             g.fill(translatedShape);
 741         }
 742     }
 743 
 744     /**************************************************************************
 745      *                                                                        *
 746      * Drawing a region background and borders when the Region has no defined *
 747      * shape, and is therefore treated as a rounded rectangle. This is the    *
 748      * most common code path for UI Controls.                                 *
 749      *                                                                        *
 750      *************************************************************************/
 751 
 752     private void renderAsRectangle(Graphics g) {
 753         if (!background.isEmpty()) {
 754             renderBackgroundRectangle(g);
 755         }
 756 
 757         if (!border.isEmpty()) {
 758             renderBorderRectangle(g);
 759         }
 760     }
 761 
 762     private void renderBackgroundRectangle(Graphics g) {
 763         // TODO a big chunk of this only makes sense to do if there actually are background fills,
 764         // and we should guard against that.
 765 
 766         // cacheWidth is the width of the region used within the cached image. For example,
 767         // perhaps normally the width of a region is 200px. But instead I will render the
 768         // region as though it is 20px wide into the cached image. 20px in this case is
 769         // the cache width. Although it may draw into more pixels than this (for example,
 770         // drawing the focus rectangle extends beyond the width of the region).
 771         // left + right background insets give us the left / right slice locations, plus 1 pixel for the center.
 772         // Round the whole thing up to be a whole number.
 773         if (backgroundInsets == null) updateBackgroundInsets();
 774         final double leftInset = backgroundInsets.getLeft() + 1;
 775         final double rightInset = backgroundInsets.getRight() + 1;
 776         final double topInset = backgroundInsets.getTop() + 1;
 777         final double bottomInset = backgroundInsets.getBottom() + 1;
 778 
 779         // If the insets are too large, then we want to use the width of the region instead of the
 780         // computed cacheWidth. RadioButton, for example, enters this case
 781         int cacheWidth = roundUp(width);
 782         if ((cacheMode &amp; CACHE_SLICE_H) != 0) {
 783             cacheWidth = Math.min(cacheWidth, (int) (leftInset + rightInset));
 784         }
 785         int cacheHeight = roundUp(height);
 786         if ((cacheMode &amp; CACHE_SLICE_V) != 0) {
 787             cacheHeight = Math.min(cacheHeight, (int) (topInset + bottomInset));
 788         }
 789 
 790         final Insets outsets = background.getOutsets();
 791         final int outsetsTop = roundUp(outsets.getTop());
 792         final int outsetsRight = roundUp(outsets.getRight());
 793         final int outsetsBottom = roundUp(outsets.getBottom());
 794         final int outsetsLeft = roundUp(outsets.getLeft());
 795 
 796         // The textureWidth / textureHeight is the width/height of the actual image. This needs to be rounded
 797         // up to the next whole pixel value.
 798         final int textureWidth = outsetsLeft + cacheWidth + outsetsRight;
 799         final int textureHeight = outsetsTop + cacheHeight + outsetsBottom;
 800 
 801         // See if we have a cached representation for this region background already.
 802         // RT-25013: We need to make sure that we do not use a cached image in the case of a
 803         // scaled region, or things won&#39;t look right (they&#39;ll looked scaled instead of vector-resized).
 804         // RT-25049: Need to only use the cache for pixel aligned regions or the result
 805         // will not look the same as though drawn by vector
 806         final boolean cache =
 807                 background.getFills().size() &gt; 1 &amp;&amp; // Not worth the overhead otherwise
 808                 cacheMode != 0 &amp;&amp;
 809                 g.getTransformNoClone().isTranslateOrIdentity() &amp;&amp;
 810                 !(g instanceof PrinterGraphics);
 811         final int border = 1;
 812         RTTexture cached = null;
 813         Rectangle rect = null;
 814         if (cache) {
 815             RegionImageCache imageCache = getImageCache(g);
 816             if (imageCache.isImageCachable(textureWidth, textureHeight)) {
 817                 final Integer key = getCacheKey(textureWidth, textureHeight);
 818                 rect = TEMP_RECT;
 819                 rect.setBounds(0, 0, textureWidth + border, textureHeight + border);
 820                 boolean render = imageCache.getImageLocation(key, rect, background, shape, g);
 821                 if (!rect.isEmpty()) {
 822                     // An empty rect indicates a failure occurred in the imageCache
 823                     cached = imageCache.getBackingStore();
 824                 }
 825                 if (cached != null &amp;&amp; render) {
 826                     Graphics cacheGraphics = cached.createGraphics();
 827 
 828                     // Have to move the origin such that when rendering to x=0, we actually end up rendering
 829                     // at x=outsets.getLeft(). Otherwise anything rendered to the left of the origin would be lost
 830                     // Round up to the nearest pixel
 831                     cacheGraphics.translate(rect.x + outsetsLeft, rect.y + outsetsTop);
 832 
 833                     // Rendering backgrounds to the cache
 834                     renderBackgroundRectanglesDirectly(cacheGraphics, cacheWidth, cacheHeight);
 835 
 836                     if (PULSE_LOGGING_ENABLED) {
 837                         PulseLogger.incrementCounter(&quot;Rendering region background image to cache&quot;);
 838                     }
 839                 }
 840             }
 841         }
 842 
 843         // &quot;cached&quot; might not be null if either there was a cached image, or we just created one.
 844         // In either case, we need to now render from the cached texture to the graphics
 845         if (cached != null) {
 846             renderBackgroundRectangleFromCache(
 847                     g, cached, rect, textureWidth, textureHeight,
 848                     topInset, rightInset, bottomInset, leftInset,
 849                     outsetsTop, outsetsRight, outsetsBottom, outsetsLeft);
 850         } else {
 851             // no cache, rendering backgrounds directly to graphics
 852             renderBackgroundRectanglesDirectly(g, width, height);
 853         }
 854 
 855         final List&lt;BackgroundImage&gt; images = background.getImages();
 856         for (int i = 0, max = images.size(); i &lt; max; i++) {
 857             final BackgroundImage image = images.get(i);
 858             Image prismImage = (Image) Toolkit.getImageAccessor().getPlatformImage(image.getImage());
 859             if (prismImage == null) {
 860                 // The prismImage might be null if the Image has not completed loading.
 861                 // In that case, we simply must skip rendering of that layer this
 862                 // time around.
 863                 continue;
 864             }
 865 
 866             final int imgUnscaledWidth = (int)image.getImage().getWidth();
 867             final int imgUnscaledHeight = (int)image.getImage().getHeight();
 868             final int imgWidth = prismImage.getWidth();
 869             final int imgHeight = prismImage.getHeight();
 870             // TODO need to write tests where we use a writable image and draw to it a lot. (RT-26978)
 871             if (imgWidth != 0 &amp;&amp; imgHeight != 0) {
 872                 final BackgroundSize size = image.getSize();
 873                 if (size.isCover()) {
 874                     // When &quot;cover&quot; is true, we can ignore most properties on the BackgroundSize and
 875                     // BackgroundRepeat and BackgroundPosition. Because the image will be stretched to
 876                     // fill the entire space, there is no need to know the repeat or position or
 877                     // size width / height.
 878                     final float scale = Math.max(width / imgWidth,height / imgHeight);
 879                     final Texture texture =
 880                         g.getResourceFactory().getCachedTexture(prismImage, Texture.WrapMode.CLAMP_TO_EDGE);
 881                     g.drawTexture(texture,
 882                             0, 0, width, height,
 883                             0, 0, width/scale, height/scale
 884                     );
 885                     texture.unlock();
 886                 } else {
 887                     // Other than &quot;cover&quot;, all other modes need to pay attention to the repeat,
 888                     // size, and position in order to determine how to render. This next block
 889                     // of code is responsible for determining the width and height of the area
 890                     // that we are going to fill. The size might be percentage based, in which
 891                     // case we need to multiply by the width or height.
 892                     final double w = size.isWidthAsPercentage() ? size.getWidth() * width : size.getWidth();
 893                     final double h = size.isHeightAsPercentage() ? size.getHeight() * height : size.getHeight();
 894 
 895                     // Now figure out the width and height of each tile to be drawn. The actual image
 896                     // dimensions may be one thing, but we need to figure out what the size of the image
 897                     // in the destination is going to be.
 898                     final double tileWidth, tileHeight;
 899                     if (size.isContain()) {
 900                         // In the case of &quot;contain&quot;, we compute the destination size based on the largest
 901                         // possible scale such that the aspect ratio is maintained, yet one side of the
 902                         // region is completely filled.
 903                         final float scaleX = width / imgUnscaledWidth;
 904                         final float scaleY = height / imgUnscaledHeight;
 905                         final float scale = Math.min(scaleX, scaleY);
 906                         tileWidth = Math.ceil(scale * imgUnscaledWidth);
 907                         tileHeight = Math.ceil(scale * imgUnscaledHeight);
 908                     } else if (size.getWidth() &gt;= 0 &amp;&amp; size.getHeight() &gt;= 0) {
 909                         // The width and height have been expressly defined. Note that AUTO is -1,
 910                         // and all other negative values are disallowed, so by checking &gt;= 0, we
 911                         // are essentially saying &quot;if neither is AUTO&quot;
 912                         tileWidth = w;
 913                         tileHeight = h;
 914                     } else if (w &gt;= 0) {
 915                         // In this case, the width is specified, but the height is AUTO
 916                         tileWidth = w;
 917                         final double scale = tileWidth / imgUnscaledWidth;
 918                         tileHeight = imgUnscaledHeight * scale;
 919                     } else if (h &gt;= 0) {
 920                         // Here the height is specified and the width is AUTO
 921                         tileHeight = h;
 922                         final double scale = tileHeight / imgUnscaledHeight;
 923                         tileWidth = imgUnscaledWidth * scale;
 924                     } else {
 925                         // Both are auto.
 926                         tileWidth = imgUnscaledWidth;
 927                         tileHeight = imgUnscaledHeight;
 928                     }
 929 
 930                     // Now figure out where we are going to place the images within the region.
 931                     // For example, the developer can ask for 20px or 20%, and we need to first
 932                     // determine where to place the image. This starts by figuring out the pixel
 933                     // based value for the position.
 934                     final BackgroundPosition pos = image.getPosition();
 935                     final double tileX, tileY;
 936 
 937                     if (pos.getHorizontalSide() == Side.LEFT) {
 938                         final double position = pos.getHorizontalPosition();
 939                         if (pos.isHorizontalAsPercentage()) {
 940                             tileX = (position * width) - (position * tileWidth);
 941                         } else {
 942                             tileX = position;
 943                         }
 944                     } else {
 945                         if (pos.isHorizontalAsPercentage()) {
 946                             final double position = 1 - pos.getHorizontalPosition();
 947                             tileX = (position * width) - (position * tileWidth);
 948                         } else {
 949                             tileX = width - tileWidth- pos.getHorizontalPosition();
 950                         }
 951                     }
 952 
 953                     if (pos.getVerticalSide() == Side.TOP) {
 954                         final double position = pos.getVerticalPosition();
 955                         if (pos.isVerticalAsPercentage()) {
 956                             tileY = (position * height) - (position * tileHeight);
 957                         } else {
 958                             tileY = position;
 959                         }
 960                     } else {
 961                         if (pos.isVerticalAsPercentage()) {
 962                             final double position = 1 - pos.getVerticalPosition();
 963                             tileY = (position * height) - (position * tileHeight);
 964                         } else {
 965                             tileY = height - tileHeight - pos.getVerticalPosition();
 966                         }
 967                     }
 968 
 969                     // Now that we have acquired or computed all the data, we&#39;ll let paintTiles
 970                     // do the actual rendering operation.
 971                     paintTiles(g, prismImage, image.getRepeatX(), image.getRepeatY(),
 972                                pos.getHorizontalSide(), pos.getVerticalSide(),
 973                                0, 0, width, height, // the region area to fill with the image
 974                                0, 0, imgWidth, imgHeight, // The entire image is used
 975                                (float) tileX, (float) tileY, (float) tileWidth, (float) tileHeight);
 976                 }
 977             }
 978         }
 979     }
 980 
 981     private void renderBackgroundRectangleFromCache(
 982             Graphics g, RTTexture cached, Rectangle rect, int textureWidth, int textureHeight,
 983             double topInset, double rightInset, double bottomInset, double leftInset,
 984             int outsetsTop, int outsetsRight, int outsetsBottom, int outsetsLeft) {
 985 
 986         // All cache operations are padded by (just shy of) half a pixel so
 987         // that as we are translated by sub-pixel amounts we continue to sample
 988         // all of the cached pixels out until they become transparent at (or
 989         // 1-bit worth of non-zero alhpa from) the center of the border pixel
 990         // around the cache.  If there is an integer translation, then our
 991         // padding should come up just shy of including new rows/columns of
 992         // pixels in the rendering and thus have no impact on pixel fill rates.
 993         final float pad = 0.5f - 1f/256f;
 994         final float dstWidth = outsetsLeft + width + outsetsRight;
 995         final float dstHeight = outsetsTop + height + outsetsBottom;
 996         final boolean sameWidth = textureWidth == dstWidth;
 997         final boolean sameHeight = textureHeight == dstHeight;
 998         final float dstX1 = -outsetsLeft - pad;
 999         final float dstY1 = -outsetsTop - pad;
1000         final float dstX2 = width + outsetsRight + pad;
1001         final float dstY2 = height + outsetsBottom + pad;
1002         final float srcX1 = rect.x - pad;
1003         final float srcY1 = rect.y - pad;
1004         final float srcX2 = rect.x + textureWidth + pad;
1005         final float srcY2 = rect.y + textureHeight + pad;
1006 
1007         // If total destination width is &lt; the source width, then we need to start
1008         // shrinking the left and right sides to accommodate. Likewise in the other dimension.
1009         double adjustedLeftInset = leftInset;
1010         double adjustedRightInset = rightInset;
1011         double adjustedTopInset = topInset;
1012         double adjustedBottomInset = bottomInset;
1013         if (leftInset + rightInset &gt; width) {
1014             double fraction = width / (leftInset + rightInset);
1015             adjustedLeftInset *= fraction;
1016             adjustedRightInset *= fraction;
1017         }
1018         if (topInset + bottomInset &gt; height) {
1019             double fraction = height / (topInset + bottomInset);
1020             adjustedTopInset *= fraction;
1021             adjustedBottomInset *= fraction;
1022         }
1023 
1024         if (sameWidth &amp;&amp; sameHeight) {
1025             g.drawTexture(cached, dstX1, dstY1, dstX2, dstY2, srcX1, srcY1, srcX2, srcY2);
1026         } else if (sameHeight) {
1027             // We do 3-patch rendering fixed height
1028             final float left  = pad + (float) (adjustedLeftInset  + outsetsLeft);
1029             final float right = pad + (float) (adjustedRightInset + outsetsRight);
1030 
1031             final float dstLeftX = dstX1 + left;
1032             final float dstRightX = dstX2 - right;
1033             final float srcLeftX = srcX1 + left;
1034             final float srcRightX = srcX2 - right;
1035 
1036             g.drawTexture3SliceH(cached,
1037                                  dstX1, dstY1, dstX2, dstY2,
1038                                  srcX1, srcY1, srcX2, srcY2,
1039                                  dstLeftX, dstRightX, srcLeftX, srcRightX);
1040         } else if (sameWidth) {
1041             // We do 3-patch rendering fixed width
1042             final float top    = pad + (float) (adjustedTopInset    + outsetsTop);
1043             final float bottom = pad + (float) (adjustedBottomInset + outsetsBottom);
1044 
1045             final float dstTopY = dstY1 + top;
1046             final float dstBottomY = dstY2 - bottom;
1047             final float srcTopY = srcY1 + top;
1048             final float srcBottomY = srcY2 - bottom;
1049 
1050             g.drawTexture3SliceV(cached,
1051                                  dstX1, dstY1, dstX2, dstY2,
1052                                  srcX1, srcY1, srcX2, srcY2,
1053                                  dstTopY, dstBottomY, srcTopY, srcBottomY);
1054         } else {
1055             // We do 9-patch rendering
1056             final float left   = pad + (float) (adjustedLeftInset   + outsetsLeft);
1057             final float top    = pad + (float) (adjustedTopInset    + outsetsTop);
1058             final float right  = pad + (float) (adjustedRightInset  + outsetsRight);
1059             final float bottom = pad + (float) (adjustedBottomInset + outsetsBottom);
1060 
1061             final float dstLeftX = dstX1 + left;
1062             final float dstRightX = dstX2 - right;
1063             final float srcLeftX = srcX1 + left;
1064             final float srcRightX = srcX2 - right;
1065             final float dstTopY = dstY1 + top;
1066             final float dstBottomY = dstY2 - bottom;
1067             final float srcTopY = srcY1 + top;
1068             final float srcBottomY = srcY2 - bottom;
1069 
1070             g.drawTexture9Slice(cached,
1071                                 dstX1, dstY1, dstX2, dstY2,
1072                                 srcX1, srcY1, srcX2, srcY2,
1073                                 dstLeftX, dstTopY, dstRightX, dstBottomY,
1074                                 srcLeftX, srcTopY, srcRightX, srcBottomY);
1075         }
1076 
1077         if (PULSE_LOGGING_ENABLED) {
1078             PulseLogger.incrementCounter(&quot;Cached region background image used&quot;);
1079         }
1080     }
1081 
1082     private void renderBackgroundRectanglesDirectly(Graphics g, float width, float height) {
1083         final List&lt;BackgroundFill&gt; fills = background.getFills();
1084         for (int i = 0, max = fills.size(); i &lt; max; i++) {
1085             final BackgroundFill fill = fills.get(i);
1086             final Insets insets = fill.getInsets();
1087             final float t = (float) insets.getTop(),
1088                     l = (float) insets.getLeft(),
1089                     b = (float) insets.getBottom(),
1090                     r = (float) insets.getRight();
1091             // w and h is the width and height of the area to be filled (width and height less insets)
1092             float w = width - l - r;
1093             float h = height - t - b;
1094             // Only setup and paint for those areas which have positive width and height. This means, if
1095             // the insets are such that the right edge is left of the left edge, then we have a negative
1096             // width and will not paint it. TODO we need to document this fact (RT-26924)
1097             if (w &gt; 0 &amp;&amp; h &gt; 0) {
1098                 // Could optimize this such that if paint is transparent then we go no further.
1099                 final Paint paint = getPlatformPaint(fill.getFill());
1100                 g.setPaint(paint);
1101                 final CornerRadii radii = getNormalizedFillRadii(i);
1102                 // This is a workaround for RT-28435 so we use path rasterizer for small radius&#39;s We are
1103                 // keeping old rendering. We do not apply workaround when using Caspian or Embedded
1104                 if (radii.isUniform() &amp;&amp;
1105                         !(!PlatformImpl.isCaspian() &amp;&amp; !(PlatformUtil.isEmbedded() || PlatformUtil.isIOS()) &amp;&amp; radii.getTopLeftHorizontalRadius() &gt; 0 &amp;&amp; radii.getTopLeftHorizontalRadius() &lt;= 4)) {
1106                     // If the radii is uniform then we know every corner matches, so we can do some
1107                     // faster rendering paths.
1108                     float tlhr = (float) radii.getTopLeftHorizontalRadius();
1109                     float tlvr = (float) radii.getTopLeftVerticalRadius();
1110                     if (tlhr == 0 &amp;&amp; tlvr == 0) {
1111                         // The edges are square, so we can do a simple fill rect
1112                         g.fillRect(l, t, w, h);
1113                     } else {
1114                         // The edges are rounded, so we need to compute the arc width and arc height
1115                         // and fill a round rect
1116                         float arcWidth = tlhr + tlhr;
1117                         float arcHeight = tlvr + tlvr;
1118                         // If the arc width and arc height are so large as to exceed the width / height of
1119                         // the region, then we clamp to the width / height of the region (which will give
1120                         // the look of a circle on that corner)
1121                         if (arcWidth &gt; w) arcWidth = w;
1122                         if (arcHeight &gt; h) arcHeight = h;
1123                         g.fillRoundRect(l, t, w, h, arcWidth, arcHeight);
1124                     }
1125                 } else {
1126                     if (PULSE_LOGGING_ENABLED) {
1127                         PulseLogger.incrementCounter(&quot;NGRegion renderBackgrounds slow path&quot;);
1128                         PulseLogger.addMessage(&quot;Slow background path for &quot; + getName());
1129                     }
1130                     // The edges are not uniform, so we have to render each edge independently
1131                     // TODO document the issue number which will give us a fast path for rendering
1132                     // non-uniform corners, and that we want to implement that instead of createPath2
1133                     // below in such cases. (RT-26979)
1134                     g.fill(createPath(width, height, t, l, b, r, radii));
1135                 }
1136             }
1137         }
1138     }
1139 
1140     private void renderBorderRectangle(Graphics g) {
1141         final List&lt;BorderImage&gt; images = border.getImages();
1142         final List&lt;BorderStroke&gt; strokes = images.isEmpty() ? border.getStrokes() : Collections.emptyList();
1143         for (int i = 0, max = strokes.size(); i &lt; max; i++) {
1144             final BorderStroke stroke = strokes.get(i);
1145             final BorderWidths widths = stroke.getWidths();
1146             final CornerRadii radii = getNormalizedStrokeRadii(i);
1147             final Insets insets = stroke.getInsets();
1148 
1149             final javafx.scene.paint.Paint topStroke = stroke.getTopStroke();
1150             final javafx.scene.paint.Paint rightStroke = stroke.getRightStroke();
1151             final javafx.scene.paint.Paint bottomStroke = stroke.getBottomStroke();
1152             final javafx.scene.paint.Paint leftStroke = stroke.getLeftStroke();
1153 
1154             final float topInset = (float) insets.getTop();
1155             final float rightInset = (float) insets.getRight();
1156             final float bottomInset = (float) insets.getBottom();
1157             final float leftInset = (float) insets.getLeft();
1158 
1159             final float topWidth = (float) (widths.isTopAsPercentage() ? height * widths.getTop() : widths.getTop());
1160             final float rightWidth = (float) (widths.isRightAsPercentage() ? width * widths.getRight() : widths.getRight());
1161             final float bottomWidth = (float) (widths.isBottomAsPercentage() ? height * widths.getBottom() : widths.getBottom());
1162             final float leftWidth = (float) (widths.isLeftAsPercentage() ? width * widths.getLeft() : widths.getLeft());
1163 
1164             final BorderStrokeStyle topStyle = stroke.getTopStyle();
1165             final BorderStrokeStyle rightStyle = stroke.getRightStyle();
1166             final BorderStrokeStyle bottomStyle = stroke.getBottomStyle();
1167             final BorderStrokeStyle leftStyle = stroke.getLeftStyle();
1168 
1169             final StrokeType topType = topStyle.getType();
1170             final StrokeType rightType = rightStyle.getType();
1171             final StrokeType bottomType = bottomStyle.getType();
1172             final StrokeType leftType = leftStyle.getType();
1173 
1174             // The Prism Graphics logic can stroke lines only CENTERED and doesn&#39;t know what to do with
1175             // INSIDE or OUTSIDE strokes for lines. The only way to deal with those is
1176             // to compensate for them here. So we will adjust the bounds that we are going
1177             // to stroke to take into account the insets (obviously), and also where we
1178             // want the stroked line to appear (inside, or outside, or centered).
1179             final float t = topInset +
1180                     (topType == StrokeType.OUTSIDE ? -topWidth / 2 :
1181                      topType == StrokeType.INSIDE ? topWidth / 2 : 0);
1182             final float l = leftInset +
1183                     (leftType == StrokeType.OUTSIDE ? -leftWidth / 2 :
1184                      leftType == StrokeType.INSIDE ? leftWidth / 2 : 0);
1185             final float b = bottomInset +
1186                     (bottomType == StrokeType.OUTSIDE ? -bottomWidth / 2 :
1187                      bottomType == StrokeType.INSIDE ? bottomWidth / 2 : 0);
1188             final float r = rightInset +
1189                     (rightType == StrokeType.OUTSIDE ? -rightWidth / 2 :
1190                      rightType == StrokeType.INSIDE ? rightWidth / 2 : 0);
1191 
1192             // If the radii are uniform, then reading any one value is sufficient to
1193             // know what the radius is for all values
1194             final float radius = (float) radii.getTopLeftHorizontalRadius();
1195             if (stroke.isStrokeUniform()) {
1196                 // If the stroke is uniform, then that means that the style, width, and stroke of
1197                 // all four sides is the same.
1198                 if (!(topStroke instanceof Color &amp;&amp; ((Color)topStroke).getOpacity() == 0f) &amp;&amp; topStyle != BorderStrokeStyle.NONE) {
1199                     float w = width - l - r;
1200                     float h = height - t - b;
1201                     // The length of each side of the path we&#39;re going to stroke
1202                     final double di = 2 * radii.getTopLeftHorizontalRadius();
1203                     final double circle = di*Math.PI;
1204                     final double totalLineLength =
1205                             circle +
1206                             2 * (w - di) +
1207                             2 * (h - di);
1208 
1209                     if (w &gt;= 0 &amp;&amp; h &gt;= 0) {
1210                         setBorderStyle(g, stroke, totalLineLength, true);
1211                         if (radii.isUniform() &amp;&amp; radius == 0) {
1212                             // We&#39;re just drawing a squared stroke on all four sides of the same style
1213                             // and width and color, so a simple drawRect call is all that is needed.
1214                             g.drawRect(l, t, w, h);
1215                         } else if (radii.isUniform()) {
1216                             // The radii are uniform, but are not squared up, so we have to
1217                             // draw a rounded rectangle.
1218                             float ar = radius + radius;
1219                             if (ar &gt; w) ar = w;
1220                             if (ar &gt; h) ar = h;
1221                             g.drawRoundRect(l, t, w, h, ar, ar);
1222                         } else {
1223                             // We do not have uniform radii, so we need to create a path that represents
1224                             // the stroke and then draw that.
1225                             g.draw(createPath(width, height, t, l, b, r, radii));
1226                         }
1227                     }
1228                 }
1229             } else if (radii.isUniform() &amp;&amp; radius == 0) {
1230 
1231                 // We have different styles, or widths, or strokes on one or more sides, and
1232                 // therefore we have to draw each side independently. However, the corner radii
1233                 // are all 0, so we don&#39;t have to go to the trouble of constructing some complicated
1234                 // path to represent the border, we just draw each line independently.
1235                 // Note that in each of these checks, if the stroke is identity equal to the TRANSPARENT
1236                 // Color or the style is identity equal to BorderStrokeStyle.NONE, then we skip that
1237                 // side. It is possible however to have a Color as the stroke which is effectively
1238                 // TRANSPARENT and a style that is effectively NONE, but we are not checking for those
1239                 // cases and will in those cases be doing more work than necessary.
1240                 // TODO make sure CSS uses TRANSPARENT and NONE when possible (RT-26943)
1241                 if (!(topStroke instanceof Color &amp;&amp; ((Color)topStroke).getOpacity() == 0f) &amp;&amp; topStyle != BorderStrokeStyle.NONE) {
1242                     g.setPaint(getPlatformPaint(topStroke));
1243                     if (BorderStrokeStyle.SOLID == topStyle) {
1244                         g.fillRect(leftInset, topInset, width - leftInset - rightInset, topWidth);
1245                     } else {
1246                         g.setStroke(createStroke(topStyle, topWidth, width, true));
1247                         g.drawLine(l, t, width - r, t);
1248                     }
1249                 }
1250 
1251                 if (!(rightStroke instanceof Color &amp;&amp; ((Color)rightStroke).getOpacity() == 0f) &amp;&amp; rightStyle != BorderStrokeStyle.NONE) {
1252                     g.setPaint(getPlatformPaint(rightStroke));
1253                     if (BorderStrokeStyle.SOLID == rightStyle) {
1254                         g.fillRect(width - rightInset - rightWidth, topInset,
1255                                    rightWidth, height - topInset - bottomInset);
1256                     } else {
1257                         g.setStroke(createStroke(rightStyle, rightWidth, height, true));
1258                         g.drawLine(width - r, t, width - r, height - b);
1259                     }
1260                 }
1261 
1262                 if (!(bottomStroke instanceof Color &amp;&amp; ((Color)bottomStroke).getOpacity() == 0f) &amp;&amp; bottomStyle != BorderStrokeStyle.NONE) {
1263                     g.setPaint(getPlatformPaint(bottomStroke));
1264                     if (BorderStrokeStyle.SOLID == bottomStyle) {
1265                         g.fillRect(leftInset, height - bottomInset - bottomWidth,
1266                                 width - leftInset - rightInset, bottomWidth);
1267                     } else {
1268                         g.setStroke(createStroke(bottomStyle, bottomWidth, width, true));
1269                         g.drawLine(l, height - b, width - r, height - b);
1270                     }
1271                 }
1272 
1273                 if (!(leftStroke instanceof Color &amp;&amp; ((Color)leftStroke).getOpacity() == 0f) &amp;&amp; leftStyle != BorderStrokeStyle.NONE) {
1274                     g.setPaint(getPlatformPaint(leftStroke));
1275                     if (BorderStrokeStyle.SOLID == leftStyle) {
1276                         g.fillRect(leftInset, topInset, leftWidth, height - topInset - bottomInset);
1277                     } else {
1278                         g.setStroke(createStroke(leftStyle, leftWidth, height, true));
1279                         g.drawLine(l, t, l, height - b);
1280                     }
1281                 }
1282             } else {
1283                 // In this case, we have different styles and/or strokes and/or widths on one or
1284                 // more sides, and either the radii are not uniform, or they are uniform but greater
1285                 // than 0. In this case we have to take a much slower rendering path by turning this
1286                 // stroke into a path (or in the current implementation, an array of paths).
1287                 Shape[] paths = createPaths(t, l, b, r, radii);
1288                 if (topStyle != BorderStrokeStyle.NONE) {
1289                     double rsum = radii.getTopLeftHorizontalRadius() + radii.getTopRightHorizontalRadius();
1290                     double topLineLength = width + rsum * (Math.PI / 4 - 1);
1291                     g.setStroke(createStroke(topStyle, topWidth, topLineLength, true));
1292                     g.setPaint(getPlatformPaint(topStroke));
1293                     g.draw(paths[0]);
1294                 }
1295                 if (rightStyle != BorderStrokeStyle.NONE) {
1296                     double rsum = radii.getTopRightVerticalRadius() + radii.getBottomRightVerticalRadius();
1297                     double rightLineLength = height + rsum * (Math.PI / 4 - 1);
1298                     g.setStroke(createStroke(rightStyle, rightWidth, rightLineLength, true));
1299                     g.setPaint(getPlatformPaint(rightStroke));
1300                     g.draw(paths[1]);
1301                 }
1302                 if (bottomStyle != BorderStrokeStyle.NONE) {
1303                     double rsum = radii.getBottomLeftHorizontalRadius() + radii.getBottomRightHorizontalRadius();
1304                     double bottomLineLength = width + rsum * (Math.PI / 4 - 1);
1305                     g.setStroke(createStroke(bottomStyle, bottomWidth, bottomLineLength, true));
1306                     g.setPaint(getPlatformPaint(bottomStroke));
1307                     g.draw(paths[2]);
1308                 }
1309                 if (leftStyle != BorderStrokeStyle.NONE) {
1310                     double rsum = radii.getTopLeftVerticalRadius() + radii.getBottomLeftVerticalRadius();
1311                     double leftLineLength = height + rsum * (Math.PI / 4 - 1);
1312                     g.setStroke(createStroke(leftStyle, leftWidth, leftLineLength, true));
1313                     g.setPaint(getPlatformPaint(leftStroke));
1314                     g.draw(paths[3]);
1315                 }
1316             }
1317         }
1318 
1319         for (int i = 0, max = images.size(); i &lt; max; i++) {
1320             final BorderImage ib = images.get(i);
1321             final Image prismImage = (Image) Toolkit.getImageAccessor().getPlatformImage(ib.getImage());
1322             if (prismImage == null) {
1323                 // The prismImage might be null if the Image has not completed loading.
1324                 // In that case, we simply must skip rendering of that layer this
1325                 // time around.
1326                 continue;
1327             }
1328             final int imgWidth = prismImage.getWidth();
1329             final int imgHeight = prismImage.getHeight();
1330             final float imgScale = prismImage.getPixelScale();
1331             final BorderWidths widths = ib.getWidths();
1332             final Insets insets = ib.getInsets();
1333             final BorderWidths slices = ib.getSlices();
1334 
1335             // we will get gaps if we don&#39;t round to pixel boundaries
1336             final int topInset = (int) Math.round(insets.getTop());
1337             final int rightInset = (int) Math.round(insets.getRight());
1338             final int bottomInset = (int) Math.round(insets.getBottom());
1339             final int leftInset = (int) Math.round(insets.getLeft());
1340 
1341             final int topWidth = widthSize(widths.isTopAsPercentage(), widths.getTop(), height);
1342             final int rightWidth = widthSize(widths.isRightAsPercentage(), widths.getRight(), width);
1343             final int bottomWidth = widthSize(widths.isBottomAsPercentage(), widths.getBottom(), height);
1344             final int leftWidth = widthSize(widths.isLeftAsPercentage(), widths.getLeft(), width);
1345 
1346             final int topSlice = sliceSize(slices.isTopAsPercentage(), slices.getTop(), imgHeight, imgScale);
1347             final int rightSlice = sliceSize(slices.isRightAsPercentage(), slices.getRight(), imgWidth, imgScale);
1348             final int bottomSlice = sliceSize(slices.isBottomAsPercentage(), slices.getBottom(), imgHeight, imgScale);
1349             final int leftSlice = sliceSize(slices.isLeftAsPercentage(), slices.getLeft(), imgWidth, imgScale);
1350 
1351             // handle case where region is too small to fit in borders
1352             if ((leftInset + leftWidth + rightInset + rightWidth) &gt; width
1353                     || (topInset + topWidth + bottomInset + bottomWidth) &gt; height) {
1354                 continue;
1355             }
1356 
1357             // calculate some things we can share
1358             final int centerMinX = leftInset + leftWidth;
1359             final int centerMinY = topInset + topWidth;
1360             final int centerW = Math.round(width) - rightInset - rightWidth - centerMinX;
1361             final int centerH = Math.round(height) - bottomInset - bottomWidth - centerMinY;
1362             final int centerMaxX = centerW + centerMinX;
1363             final int centerMaxY = centerH + centerMinY;
1364             final int centerSliceWidth = imgWidth - leftSlice - rightSlice;
1365             final int centerSliceHeight = imgHeight - topSlice - bottomSlice;
1366             // paint top left corner
1367             paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
1368                        leftInset, topInset, leftWidth, topWidth, // target bounds
1369                        0, 0, leftSlice, topSlice, // src image bounds
1370                        0, 0, leftWidth, topWidth); // tile bounds
1371             // paint top slice
1372             float tileWidth = (ib.getRepeatX() == BorderRepeat.STRETCH) ?
1373                     centerW : (topSlice &gt; 0 ? (centerSliceWidth * topWidth) / topSlice : 0);
1374             float tileHeight = topWidth;
1375             paintTiles(
1376                     g, prismImage, ib.getRepeatX(), BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
1377                     centerMinX, topInset, centerW, topWidth,
1378                     leftSlice, 0, centerSliceWidth, topSlice,
1379                     (centerW - tileWidth) / 2, 0, tileWidth, tileHeight);
1380             // paint top right corner
1381             paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
1382                        centerMaxX, topInset, rightWidth, topWidth,
1383                        (imgWidth - rightSlice), 0, rightSlice, topSlice,
1384                        0, 0, rightWidth, topWidth);
1385             // paint left slice
1386             tileWidth = leftWidth;
1387             tileHeight = (ib.getRepeatY() == BorderRepeat.STRETCH) ?
1388                     centerH : (leftSlice &gt; 0 ? (leftWidth * centerSliceHeight) / leftSlice : 0);
1389             paintTiles(g, prismImage, BorderRepeat.STRETCH, ib.getRepeatY(), Side.LEFT, Side.TOP,
1390                        leftInset, centerMinY, leftWidth, centerH,
1391                        0, topSlice, leftSlice, centerSliceHeight,
1392                        0, (centerH - tileHeight) / 2, tileWidth, tileHeight);
1393             // paint right slice
1394             tileWidth = rightWidth;
1395             tileHeight = (ib.getRepeatY() == BorderRepeat.STRETCH) ?
1396                     centerH : (rightSlice &gt; 0 ? (rightWidth * centerSliceHeight) / rightSlice : 0);
1397             paintTiles(g, prismImage, BorderRepeat.STRETCH, ib.getRepeatY(), Side.LEFT, Side.TOP,
1398                        centerMaxX, centerMinY, rightWidth, centerH,
1399                        imgWidth - rightSlice, topSlice, rightSlice, centerSliceHeight,
1400                        0, (centerH - tileHeight) / 2, tileWidth, tileHeight);
1401             // paint bottom left corner
1402             paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
1403                        leftInset, centerMaxY, leftWidth, bottomWidth,
1404                        0, imgHeight - bottomSlice, leftSlice, bottomSlice,
1405                        0, 0, leftWidth, bottomWidth);
1406             // paint bottom slice
1407             tileWidth = (ib.getRepeatX() == BorderRepeat.STRETCH) ?
1408                     centerW : (bottomSlice &gt; 0 ? (centerSliceWidth * bottomWidth) / bottomSlice : 0);
1409             tileHeight = bottomWidth;
1410             paintTiles(g, prismImage, ib.getRepeatX(), BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
1411                        centerMinX, centerMaxY, centerW, bottomWidth,
1412                        leftSlice, imgHeight - bottomSlice, centerSliceWidth, bottomSlice,
1413                        (centerW - tileWidth) / 2, 0, tileWidth, tileHeight);
1414             // paint bottom right corner
1415             paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
1416                        centerMaxX, centerMaxY, rightWidth, bottomWidth,
1417                        imgWidth - rightSlice, imgHeight - bottomSlice, rightSlice, bottomSlice,
1418                        0, 0, rightWidth, bottomWidth);
1419             // paint the center slice
1420             if (ib.isFilled()) {
1421                 // handle no repeat as stretch
1422                 final float imgW = (ib.getRepeatX() == BorderRepeat.STRETCH) ? centerW : centerSliceWidth;
1423                 final float imgH = (ib.getRepeatY() == BorderRepeat.STRETCH) ? centerH : centerSliceHeight;
1424                 paintTiles(g, prismImage, ib.getRepeatX(), ib.getRepeatY(), Side.LEFT, Side.TOP,
1425                            centerMinX, centerMinY, centerW, centerH,
1426                            leftSlice, topSlice, centerSliceWidth, centerSliceHeight,
1427                            0, 0, imgW, imgH);
1428             }
1429         }
1430     }
1431 
1432     /**
1433      * Visits each of the background fills and takes their radii into account to determine the insets.
1434      * The backgroundInsets variable is cleared whenever the fills change, or whenever the size of the
1435      * region has changed (because if the size of the region changed and a radius is percentage based
1436      * then we need to recompute the insets).
1437      */
1438     private void updateBackgroundInsets() {
1439         float top=0, right=0, bottom=0, left=0;
1440         final List&lt;BackgroundFill&gt; fills = background.getFills();
1441         for (int i=0, max=fills.size(); i&lt;max; i++) {
1442             // We need to now inspect the paint to determine whether we can use a cache for this background.
1443             // If a shape is being used, we don&#39;t care about gradients (we cache &#39;em both), but for a rectangle
1444             // fill we omit these (so we can do 3-patch scaling). An ImagePattern is deadly to either
1445             // (well, only deadly to a shape if it turns out to be a writable image).
1446             final BackgroundFill fill = fills.get(i);
1447             final Insets insets = fill.getInsets();
1448             final CornerRadii radii = getNormalizedFillRadii(i);
1449             top = (float) Math.max(top, insets.getTop() + Math.max(radii.getTopLeftVerticalRadius(), radii.getTopRightVerticalRadius()));
1450             right = (float) Math.max(right, insets.getRight() + Math.max(radii.getTopRightHorizontalRadius(), radii.getBottomRightHorizontalRadius()));
1451             bottom = (float) Math.max(bottom, insets.getBottom() + Math.max(radii.getBottomRightVerticalRadius(), radii.getBottomLeftVerticalRadius()));
1452             left = (float) Math.max(left, insets.getLeft() + Math.max(radii.getTopLeftHorizontalRadius(), radii.getBottomLeftHorizontalRadius()));
1453         }
1454         backgroundInsets = new Insets(roundUp(top), roundUp(right), roundUp(bottom), roundUp(left));
1455     }
1456 
1457     private int widthSize(boolean isPercent, double sliceSize, float objSize) {
1458         //Not strictly correct. See RT-34051
1459         return (int) Math.round(isPercent ? sliceSize * objSize : sliceSize);
1460     }
1461 
1462     private int sliceSize(boolean isPercent, double sliceSize, float objSize, float scale) {
1463         if (isPercent) sliceSize *= objSize;
1464         if (sliceSize &gt; objSize) sliceSize = objSize;
1465         return (int) Math.round(sliceSize * scale);
1466     }
1467 
1468     private int roundUp(double d) {
1469         return (d - (int)d) == 0 ? (int) d : (int) (d + 1);
1470     }
1471 
1472 
1473     /**
1474      * Creates a Prism BasicStroke based on the stroke style, width, and line length.
1475      *
1476      * @param sb             The BorderStrokeStyle
1477      * @param strokeWidth    The width of the stroke we&#39;re going to draw
1478      * @param lineLength     The total linear length of this stroke. This is needed for
1479      *                       handling &quot;dashed&quot; and &quot;dotted&quot; cases, otherwise, it is ignored.
1480      * @param forceCentered  When this is set to true, the stroke is always centered.
1481      *                       The &quot;outer/inner&quot; stroking has to be done by moving the line
1482      * @return A prism BasicStroke
1483      */
1484     private BasicStroke createStroke(BorderStrokeStyle sb,
1485                                      double strokeWidth,
1486                                      double lineLength,
1487                                      boolean forceCentered) {
1488         int cap;
1489         if (sb.getLineCap() == StrokeLineCap.BUTT) {
1490             cap = BasicStroke.CAP_BUTT;
1491         } else if (sb.getLineCap() == StrokeLineCap.SQUARE) {
1492             cap = BasicStroke.CAP_SQUARE;
1493         } else {
1494             cap = BasicStroke.CAP_ROUND;
1495         }
1496 
1497         int join;
1498         if (sb.getLineJoin() == StrokeLineJoin.BEVEL) {
1499             join = BasicStroke.JOIN_BEVEL;
1500         } else if (sb.getLineJoin() == StrokeLineJoin.MITER) {
1501             join = BasicStroke.JOIN_MITER;
1502         } else {
1503             join = BasicStroke.JOIN_ROUND;
1504         }
1505 
1506         int type;
1507         if (forceCentered) {
1508             type = BasicStroke.TYPE_CENTERED;
1509         } else if (scaleShape) {
1510             // Note: this is just a workaround that allows us to avoid shape bounds computation with the given stroke.
1511             // By using inner stroke, we know the shape bounds and the shape will be scaled correctly, but the size of
1512             // the stroke after the scale will be slightly different, but this should be visible only with big stroke widths
1513             // See https://javafx-jira.kenai.com/browse/RT-38384
1514             type = BasicStroke.TYPE_INNER;
1515         } else {
1516             switch (sb.getType()) {
1517                 case INSIDE:
1518                     type = BasicStroke.TYPE_INNER;
1519                     break;
1520                 case OUTSIDE:
1521                     type = BasicStroke.TYPE_OUTER;
1522                     break;
1523                 case CENTERED:
1524                 default:
1525                     type = BasicStroke.TYPE_CENTERED;
1526                     break;
1527             }
1528         }
1529 
1530         BasicStroke bs;
1531         if (sb == BorderStrokeStyle.NONE) {
1532             throw new AssertionError(&quot;Should never have been asked to draw a border with NONE&quot;);
1533         } else if (strokeWidth &lt;= 0) {
1534             // The stroke essentially disappears in this case, but some of the
1535             // dashing calculations below can produce degenerate dash arrays
1536             // that are problematic when the strokeWidth is 0.
1537 
1538             // Ideally the calling code would not even be trying to perform a
1539             // stroke under these conditions, but there are so many unchecked
1540             // calls to createStroke() in the code that pass the result directly
1541             // to a Graphics and then use it, that we need to return something
1542             // valid, even if it represents a NOP.
1543 
1544             bs = new BasicStroke((float) strokeWidth, cap, join,
1545                     (float) sb.getMiterLimit());
1546         } else if (sb.getDashArray().size() &gt; 0) {
1547             List&lt;Double&gt; dashArray = sb.getDashArray();
1548             double[] array;
1549             float dashOffset;
1550             if (dashArray == BorderStrokeStyle.DOTTED.getDashArray()) {
1551                 // NOTE: IF line length is &gt; 0, then we are going to do some math to try to make the resulting
1552                 // dots look pleasing. It is set to -1 if we are stroking a random path (vs. a rounded rect), in
1553                 // which case we are going to just scale the dotting pattern based on the stroke width, but we won&#39;t
1554                 // try to adjust the phase to make it look better.
1555                 if (lineLength &gt; 0) {
1556                     // For DOTTED we want the dash array to be 0, val, where the &quot;val&quot; is as close to strokewidth*2 as
1557                     // possible, but we want the spacing to be such that we get an even spacing between all dots around
1558                     // the edge.
1559                     double remainder = lineLength % (strokeWidth * 2);
1560                     double numSpaces = lineLength / (strokeWidth * 2);
1561                     double spaceWidth = (strokeWidth * 2) + (remainder / numSpaces);
1562                     array = new double[] {0, spaceWidth};
1563                     dashOffset = 0;
1564                 } else {
1565                     array = new double[] {0, strokeWidth * 2};
1566                     dashOffset = 0;
1567                 }
1568             } else if (dashArray == BorderStrokeStyle.DASHED.getDashArray()) {
1569                 // NOTE: IF line length is &gt; 0, then we are going to do some math to try to make the resulting
1570                 // dash look pleasing. It is set to -1 if we are stroking a random path (vs. a rounded rect), in
1571                 // which case we are going to just scale the dashing pattern based on the stroke width, but we won&#39;t
1572                 // try to adjust the phase to make it look better.
1573                 if (lineLength &gt; 0) {
1574                     // For DASHED we want the dash array to be 2*strokewidth, val where &quot;val&quot; is as close to
1575                     // 1.4*strokewidth as possible, but we want the spacing to be such that we get an even spacing between
1576                     // all dashes around the edge. Maybe we can start with the dash phase at half the dash length.
1577                     final double dashLength = strokeWidth * 2;
1578                     double gapLength = strokeWidth * 1.4;
1579                     final double segmentLength = dashLength + gapLength;
1580                     final double divided = lineLength / segmentLength;
1581                     final double numSegments = (int) divided;
1582                     if (numSegments &gt; 0) {
1583                         final double dashCumulative = numSegments * dashLength;
1584                         gapLength = (lineLength - dashCumulative) / numSegments;
1585                     }
1586                     array = new double[] {dashLength, gapLength};
1587                     dashOffset = (float) (dashLength*.6);
1588                 } else {
1589                     array = new double[] {2 * strokeWidth, 1.4 * strokeWidth};
1590                     dashOffset = 0;
1591                 }
1592             } else {
1593                 // If we are not DASHED or DOTTED or we&#39;re stroking a path and not a basic rounded rectangle
1594                 // so we just take what we&#39;ve been given.
1595                 array = new double[dashArray.size()];
1596                 for (int i=0; i&lt;array.length; i++) {
1597                     array[i] = dashArray.get(i);
1598                 }
1599                 dashOffset = (float) sb.getDashOffset();
1600             }
1601 
1602             bs = new BasicStroke(type, (float) strokeWidth, cap, join,
1603                     (float) sb.getMiterLimit(),
1604                     array, dashOffset);
1605         } else {
1606             bs = new BasicStroke(type, (float) strokeWidth, cap, join,
1607                     (float) sb.getMiterLimit());
1608         }
1609 
1610         return bs;
1611     }
1612 
1613     private void setBorderStyle(Graphics g, BorderStroke sb, double length, boolean forceCentered) {
1614         // Any one of, or all of, the sides could be &#39;none&#39;.
1615         // Take the first side that isn&#39;t.
1616         final BorderWidths widths = sb.getWidths();
1617         BorderStrokeStyle bs = sb.getTopStyle();
1618         double sbWidth = widths.isTopAsPercentage() ? height * widths.getTop() : widths.getTop();
1619         Paint sbFill = getPlatformPaint(sb.getTopStroke());
1620         if (bs == null) {
1621             bs = sb.getLeftStyle();
1622             sbWidth = widths.isLeftAsPercentage() ? width * widths.getLeft() : widths.getLeft();
1623             sbFill = getPlatformPaint(sb.getLeftStroke());
1624             if (bs == null) {
1625                 bs = sb.getBottomStyle();
1626                 sbWidth = widths.isBottomAsPercentage() ? height * widths.getBottom() : widths.getBottom();
1627                 sbFill = getPlatformPaint(sb.getBottomStroke());
1628                 if (bs == null) {
1629                     bs = sb.getRightStyle();
1630                     sbWidth = widths.isRightAsPercentage() ? width * widths.getRight() : widths.getRight();
1631                     sbFill = getPlatformPaint(sb.getRightStroke());
1632                 }
1633             }
1634         }
1635         if (bs == null || bs == BorderStrokeStyle.NONE) {
1636             return;
1637         }
1638 
1639         g.setStroke(createStroke(bs, sbWidth, length, forceCentered));
1640         g.setPaint(sbFill);
1641     }
1642 
1643     /**
1644      * Inserts geometry into the specified Path2D object for the specified
1645      * corner of a general rounded rectangle.
1646      *
1647      * The corner drawn is specified by the quadrant parameter, whose least
1648      * significant 2 bits specify the following corners and the associated
1649      * start, corner, and end points (which are always drawn clockwise):
1650      *
1651      * 0 - Top Left:      X + 0 , Y + VR,      X, Y,      X + HR, Y + 0
1652      * 1 - Top Right:     X - HR, Y + 0 ,      X, Y,      X + 0 , Y + VR
1653      * 2 - Bottom Right:  X + 0 , Y - VR,      X, Y,      X - HR, Y + 0
1654      * 3 - Bottom Left:   X + HR, Y + 0 ,      X, Y,      X + 0 , Y - VR
1655      *
1656      * The associated horizontal and vertical radii are fetched from the
1657      * indicated CornerRadii object which is assumed to be absolute (not
1658      * percentage based) and already scaled so that no pair of radii are
1659      * larger than the indicated width/height of the rounded rectangle being
1660      * expressed.
1661      *
1662      * The tstart and tend parameters specify what portion of the rounded
1663      * corner should be drawn with 0f =&gt; 1f being the entire rounded corner.
1664      *
1665      * The newPath parameter indicates whether the path should reach the
1666      * starting point with a moveTo() command or a lineTo() segment.
1667      *
1668      * @param path
1669      * @param radii
1670      * @param x
1671      * @param y
1672      * @param quadrant
1673      * @param tstart
1674      * @param tend
1675      * @param newPath
1676      */
1677     private void doCorner(Path2D path, CornerRadii radii,
1678                           float x, float y, int quadrant,
1679                           float tstart, float tend, boolean newPath)
1680     {
1681         float dx0, dy0, dx1, dy1;
1682         float hr, vr;
1683         switch (quadrant &amp; 0x3) {
1684             case 0:
1685                 hr = (float) radii.getTopLeftHorizontalRadius();
1686                 vr = (float) radii.getTopLeftVerticalRadius();
1687                 // 0 - Top Left:      X + 0 , Y + VR,      X, Y,      X + HR, Y + 0
1688                 dx0 =  0f;  dy0 =  vr;    dx1 =  hr;  dy1 =  0f;
1689                 break;
1690             case 1:
1691                 hr = (float) radii.getTopRightHorizontalRadius();
1692                 vr = (float) radii.getTopRightVerticalRadius();
1693                 // 1 - Top Right:     X - HR, Y + 0 ,      X, Y,      X + 0 , Y + VR
1694                 dx0 = -hr;  dy0 =  0f;    dx1 =  0f;  dy1 =  vr;
1695                 break;
1696             case 2:
1697                 hr = (float) radii.getBottomRightHorizontalRadius();
1698                 vr = (float) radii.getBottomRightVerticalRadius();
1699                 // 2 - Bottom Right:  X + 0 , Y - VR,      X, Y,      X - HR, Y + 0
1700                 dx0 =  0f;  dy0 = -vr;    dx1 = -hr;  dy1 = 0f;
1701                 break;
1702             case 3:
1703                 hr = (float) radii.getBottomLeftHorizontalRadius();
1704                 vr = (float) radii.getBottomLeftVerticalRadius();
1705                 // 3 - Bottom Left:   X + HR, Y + 0 ,      X, Y,      X + 0 , Y - VR
1706                 dx0 =  hr;  dy0 =  0f;    dx1 =  0f;  dy1 = -vr;
1707                 break;
1708             default: return; // Can never happen
1709         }
1710         if (hr &gt; 0 &amp;&amp; vr &gt; 0) {
1711             path.appendOvalQuadrant(x + dx0, y + dy0, x, y, x + dx1, y + dy1, tstart, tend,
1712                                     (newPath)
1713                                         ? Path2D.CornerPrefix.MOVE_THEN_CORNER
1714                                         : Path2D.CornerPrefix.LINE_THEN_CORNER);
1715         } else if (newPath) {
1716             path.moveTo(x, y);
1717         } else {
1718             path.lineTo(x, y);
1719         }
1720     }
1721 
1722     /**
1723      * Creates a rounded rectangle path with our width and height, different corner radii,
1724      * offset with given offsets
1725      */
1726     private Path2D createPath(float width, float height, float t, float l, float bo, float ro, CornerRadii radii) {
1727         float r = width - ro;
1728         float b = height - bo;
1729         Path2D path = new Path2D();
1730         doCorner(path, radii, l, t, 0, 0f, 1f, true);
1731         doCorner(path, radii, r, t, 1, 0f, 1f, false);
1732         doCorner(path, radii, r, b, 2, 0f, 1f, false);
1733         doCorner(path, radii, l, b, 3, 0f, 1f, false);
1734         path.closePath();
1735         return path;
1736     }
1737 
1738     private Path2D makeRoundedEdge(CornerRadii radii,
1739                                    float x0, float y0, float x1, float y1,
1740                                    int quadrant)
1741     {
1742         Path2D path = new Path2D();
1743         doCorner(path, radii, x0, y0, quadrant,   0.5f, 1.0f, true);
1744         doCorner(path, radii, x1, y1, quadrant+1, 0.0f, 0.5f, false);
1745         return path;
1746     }
1747 
1748     /**
1749      * Creates a rounded rectangle path with our width and height, different corner radii, offset with given offsets.
1750      * Each side as a separate path.  The sides are returned in the CSS standard
1751      * order of top, right, bottom, left.
1752      */
1753     private Path2D[] createPaths(float t, float l, float bo, float ro, CornerRadii radii)
1754     {
1755         float r = width - ro;
1756         float b = height - bo;
1757         return new Path2D[] {
1758             makeRoundedEdge(radii, l, t, r, t, 0), // top
1759             makeRoundedEdge(radii, r, t, r, b, 1), // right
1760             makeRoundedEdge(radii, r, b, l, b, 2), // bottom
1761             makeRoundedEdge(radii, l, b, l, t, 3), // left
1762         };
1763     }
1764 
1765     /**
1766      * Create a bigger or smaller version of shape. If not scaleShape then the shape is just centered rather
1767      * than resized. Proportions are not maintained when resizing. This is necessary so as to ensure
1768      * that the fill never looks scaled. For example, a tile-imaged based background will look stretched
1769      * if we were to render a scaled shape. Instead, we produce a new shape based on the scaled size and
1770      * then fill that shape without additional transforms.
1771      */
1772     private Shape resizeShape(float topOffset, float rightOffset, float bottomOffset, float leftOffset) {
1773         // The bounds of the shape, before any centering / scaling takes place
1774         final RectBounds bounds = shape.getBounds();
1775         if (scaleShape) {
1776             // First we need to modify the transform to scale the shape so that it will fit
1777             // within the insets.
1778             SCRATCH_AFFINE.setToIdentity();
1779             SCRATCH_AFFINE.translate(leftOffset, topOffset);
1780             // width &amp; height are the width and height of the region. w &amp; h are the width and height
1781             // of the box within which the new shape must fit.
1782             final float w = width - leftOffset - rightOffset;
1783             final float h = height - topOffset - bottomOffset;
1784             SCRATCH_AFFINE.scale(w / bounds.getWidth(), h / bounds.getHeight());
1785             // If we also need to center it, we need to adjust the transform so as to place
1786             // the shape in the center of the bounds
1787             if (centerShape) {
1788                 SCRATCH_AFFINE.translate(-bounds.getMinX(), -bounds.getMinY());
1789             }
1790             return SCRATCH_AFFINE.createTransformedShape(shape);
1791         } else if (centerShape) {
1792             // We are only centering. In this case, what we want is for the
1793             // original shape to be centered. If there are offsets (insets)
1794             // then we must pre-scale about the center to account for it.
1795             final float boundsWidth = bounds.getWidth();
1796             final float boundsHeight = bounds.getHeight();
1797             float newW = boundsWidth - leftOffset - rightOffset;
1798             float newH = boundsHeight - topOffset - bottomOffset;
1799             SCRATCH_AFFINE.setToIdentity();
1800             SCRATCH_AFFINE.translate(leftOffset + (width - boundsWidth)/2 - bounds.getMinX(),
1801                                      topOffset + (height - boundsHeight)/2 - bounds.getMinY());
1802             if (newH != boundsHeight || newW != boundsWidth) {
1803                 SCRATCH_AFFINE.translate(bounds.getMinX(), bounds.getMinY());
1804                 SCRATCH_AFFINE.scale(newW / boundsWidth, newH / boundsHeight);
1805                 SCRATCH_AFFINE.translate(-bounds.getMinX(), -bounds.getMinY());
1806             }
1807             return SCRATCH_AFFINE.createTransformedShape(shape);
1808         } else if (topOffset != 0 || rightOffset != 0 || bottomOffset != 0 || leftOffset != 0) {
1809             // We are neither centering nor scaling, but we still have to resize the
1810             // shape because we have to fit within the bounds defined by the offsets
1811             float newW = bounds.getWidth() - leftOffset - rightOffset;
1812             float newH = bounds.getHeight() - topOffset - bottomOffset;
1813             SCRATCH_AFFINE.setToIdentity();
1814             SCRATCH_AFFINE.translate(leftOffset, topOffset);
1815             SCRATCH_AFFINE.translate(bounds.getMinX(), bounds.getMinY());
1816             SCRATCH_AFFINE.scale(newW / bounds.getWidth(), newH / bounds.getHeight());
1817             SCRATCH_AFFINE.translate(-bounds.getMinX(), -bounds.getMinY());
1818             return SCRATCH_AFFINE.createTransformedShape(shape);
1819         } else {
1820             // Nothing has changed, so we can simply return!
1821             return shape;
1822         }
1823     }
1824 
1825     private void paintTiles(Graphics g, Image img, BorderRepeat repeatX, BorderRepeat repeatY, Side horizontalSide, Side verticalSide,
1826             final float regionX, final float regionY, final float regionWidth, final float regionHeight,
1827             final int srcX, final int srcY, final int srcW, final int srcH,
1828             float tileX, float tileY, float tileWidth, float tileHeight)
1829     {
1830         BackgroundRepeat rx = null;
1831         BackgroundRepeat ry = null;
1832 
1833         switch (repeatX) {
1834             case REPEAT: rx = BackgroundRepeat.REPEAT; break;
1835             case STRETCH: rx = BackgroundRepeat.NO_REPEAT; break;
1836             case ROUND: rx = BackgroundRepeat.ROUND; break;
1837             case SPACE: rx = BackgroundRepeat.SPACE; break;
1838         }
1839 
1840         switch (repeatY) {
1841             case REPEAT: ry = BackgroundRepeat.REPEAT; break;
1842             case STRETCH: ry = BackgroundRepeat.NO_REPEAT; break;
1843             case ROUND: ry = BackgroundRepeat.ROUND; break;
1844             case SPACE: ry = BackgroundRepeat.SPACE; break;
1845         }
1846 
1847         paintTiles(g, img, rx, ry, horizontalSide, verticalSide, regionX, regionY, regionWidth, regionHeight,
1848                    srcX, srcY, srcW, srcH, tileX, tileY, tileWidth, tileHeight);
1849     }
1850 
1851     /**
1852      * Paints a subsection (srcX,srcY,srcW,srcH) of an image tiled or stretched to fill the destination area
1853      * (regionWidth,regionHeight). It is assumed we are pre-transformed to the correct origin, top left or destination area. When
1854      * tiling the first tile is positioned within the rectangle (tileX,tileY,tileW,tileH).
1855      *
1856      * Drawing two images next to each other on a non-pixel boundary can not be done simply so we use integers here. This
1857      * assumption may be wrong when drawing though a scale transform.
1858      *
1859      * @param g        The graphics context to draw image into
1860      * @param img       The image to draw
1861      * @param repeatX   The horizontal repeat style for filling the area with the src image
1862      * @param repeatY   The vertical repeat style for filling the area with the src image
1863      * @param horizontalSide The left or right
1864      * @param verticalSide The top or bottom
1865      * @param regionX      The top left corner X of the area of the graphics context to fill with our img
1866      * @param regionY      The top left corner Y of the area of the graphics context to fill with our img
1867      * @param regionWidth      The width of the area of the graphics context to fill with our img
1868      * @param regionHeight      The height of the area of the graphics context to fill with our img
1869      * @param srcX      The top left corner X of the area of the image to paint with
1870      * @param srcY      The top left corner Y of the area of the image to paint with
1871      * @param srcW      The width of the area of the image to paint with, -1 to use the original image width
1872      * @param srcH      The height of the area of the image to paint with, -1 to use the original image height
1873      * @param tileX     The top left corner X of the area of the first tile within the destination rectangle. In some
1874      *                  cases we begin by drawing the center tile, and working to the left &amp; right (for example), so
1875      *                  this value is not always the same as regionX.
1876      * @param tileY     The top left corner Y of the area of the first tile within the destination rectangle
1877      * @param tileWidth The width of the area of the first tile within the destination rectangle, if &lt;= 0, then the use intrinsic value
1878      * @param tileHeight The height of the area of the first tile within the destination rectangle, if &lt;= 0, then the use intrinsic value
1879      */
1880     private void paintTiles(Graphics g, Image img, BackgroundRepeat repeatX, BackgroundRepeat repeatY, Side horizontalSide, Side verticalSide,
1881             final float regionX, final float regionY, final float regionWidth, final float regionHeight,
1882             final int srcX, final int srcY, final int srcW, final int srcH,
1883             float tileX, float tileY, float tileWidth, float tileHeight)
1884     {
1885         // If the destination width/height is 0 or the src width / height is 0 then we have
1886         // nothing to draw, so we can just bail.
1887         if (regionWidth &lt;= 0 || regionHeight &lt;= 0 || srcW &lt;= 0 || srcH &lt;= 0) return;
1888 
1889         // At this point we should have real values for the image source coordinates
1890         assert srcX &gt;= 0 &amp;&amp; srcY &gt;= 0 &amp;&amp; srcW &gt; 0 &amp;&amp; srcH &gt; 0;
1891 
1892         // If we are repeating in both the x &amp; y directions, then we can take a fast path and just
1893         // use the ImagePattern directly instead of having to issue a large number of drawTexture calls.
1894         // This is the generally common case where we are tiling the background in both dimensions.
1895         // Note that this only works if the anchor point is the top-left, otherwise the ImagePattern would
1896         // not give the correct expected results.
1897         if (tileX == 0 &amp;&amp; tileY == 0 &amp;&amp; repeatX == BackgroundRepeat.REPEAT &amp;&amp; repeatY == BackgroundRepeat.REPEAT) {
1898             if (srcX != 0 || srcY != 0 || srcW != img.getWidth() || srcH != img.getHeight()) {
1899                 img = img.createSubImage(srcX, srcY, srcW, srcH);
1900             }
1901             g.setPaint(new ImagePattern(img, 0, 0, tileWidth, tileHeight, false, false));
1902             g.fillRect(regionX, regionY, regionWidth, regionHeight);
1903         } else {
1904             // If SPACE repeat mode is being used, then we need to take special action if there is not enough
1905             // space to have more than one tile. Basically, it needs to act as NO_REPEAT in that case (see
1906             // section 3.4 of the spec for details under rules for SPACE).
1907             if (repeatX == BackgroundRepeat.SPACE &amp;&amp; (regionWidth &lt; (tileWidth * 2))) {
1908                 repeatX = BackgroundRepeat.NO_REPEAT;
1909             }
1910 
1911             if (repeatY == BackgroundRepeat.SPACE &amp;&amp; (regionHeight &lt; (tileHeight * 2))) {
1912                 repeatY = BackgroundRepeat.NO_REPEAT;
1913             }
1914 
1915             // The following variables are computed and used in order to lay out the tiles in the x and y directions.
1916             // &quot;count&quot; is used to keep track of the number of tiles to lay down in the x and y directions.
1917             final int countX, countY;
1918             // The amount to increment the dstX and dstY by during the rendering loop. This may be positive or
1919             //negative and will include any space between tiles.
1920             final float xIncrement, yIncrement;
1921 
1922             // Based on the repeat mode, populate the above variables
1923             if (repeatX == BackgroundRepeat.REPEAT) {
1924                 // In some cases we have a large positive offset but are in repeat mode. What we need
1925                 // to do is tile, but we want to do so in such a way that we are &quot;anchored&quot; to the center,
1926                 // or right, or whatnot. That is what offsetX will be used for.
1927                 float offsetX = 0;
1928                 if (tileX != 0) {
1929                     float mod = tileX % tileWidth;
1930                     tileX = mod == 0 ? 0 : tileX &lt; 0 ? mod : mod - tileWidth;
1931                     offsetX = tileX;
1932                 }
1933                 countX = (int) Math.max(1, Math.ceil((regionWidth - offsetX) / tileWidth));
1934                 xIncrement = horizontalSide == Side.RIGHT ? -tileWidth : tileWidth;
1935             } else if (repeatX == BackgroundRepeat.SPACE) {
1936                 tileX = 0; // Space will always start from the top left
1937                 countX = (int) (regionWidth / tileWidth);
1938                 float remainder = (regionWidth % tileWidth);
1939                 xIncrement = tileWidth + (remainder / (countX - 1));
1940             } else if (repeatX == BackgroundRepeat.ROUND) {
1941                 tileX = 0; // Round will always start from the top left
1942                 countX = (int) (regionWidth / tileWidth);
1943                 tileWidth = regionWidth / (int)(regionWidth / tileWidth);
1944                 xIncrement = tileWidth;
1945             } else { // no repeat
1946                 countX = 1;
1947                 xIncrement = horizontalSide == Side.RIGHT ? -tileWidth : tileWidth;
1948             }
1949 
1950             if (repeatY == BackgroundRepeat.REPEAT) {
1951                 float offsetY = 0;
1952                 if (tileY != 0) {
1953                     float mod = tileY % tileHeight;
1954                     tileY = mod == 0 ? 0 : tileY &lt; 0 ? mod : mod - tileHeight;
1955                     offsetY = tileY;
1956                 }
1957                 countY = (int) Math.max(1, Math.ceil((regionHeight - offsetY) / tileHeight));
1958                 yIncrement = verticalSide == Side.BOTTOM ? -tileHeight : tileHeight;
1959             } else if (repeatY == BackgroundRepeat.SPACE) {
1960                 tileY = 0; // Space will always start from the top left
1961                 countY = (int) (regionHeight / tileHeight);
1962                 float remainder = (regionHeight % tileHeight);
1963                 yIncrement = tileHeight + (remainder / (countY - 1));
1964             } else if (repeatY == BackgroundRepeat.ROUND) {
1965                 tileY = 0; // Round will always start from the top left
1966                 countY = (int) (regionHeight / tileHeight);
1967                 tileHeight = regionHeight / (int)(regionHeight / tileHeight);
1968                 yIncrement = tileHeight;
1969             } else { // no repeat
1970                 countY = 1;
1971                 yIncrement = verticalSide == Side.BOTTOM ? -tileHeight : tileHeight;
1972             }
1973 
1974             // paint loop
1975             final Texture texture =
1976                 g.getResourceFactory().getCachedTexture(img, Texture.WrapMode.CLAMP_TO_EDGE);
1977             final int srcX2 = srcX + srcW;
1978             final int srcY2 = srcY + srcH;
1979             final float regionX2 = regionX + regionWidth;
1980             final float regionY2 = regionY + regionHeight;
1981 
1982             float dstY = regionY + tileY;
1983             for (int y = 0; y &lt; countY; y++) {
1984                 float dstY2 = dstY + tileHeight;
1985                 float dstX = regionX + tileX;
1986                 for (int x = 0; x &lt; countX; x++) {
1987                     float dstX2 = dstX + tileWidth;
1988                     // We don&#39;t want to end up rendering if we find that the destination rect is completely
1989                     // off of the region rendering area
1990                     boolean skipRender = false;
1991                     float dx1 = dstX &lt; regionX ? regionX : dstX;
1992                     float dy1 = dstY &lt; regionY ? regionY : dstY;
1993                     if (dx1 &gt; regionX2 || dy1 &gt; regionY2) skipRender = true;
1994 
1995                     float dx2 = dstX2 &gt; regionX2 ? regionX2 : dstX2;
1996                     float dy2 = dstY2 &gt; regionY2 ? regionY2 : dstY2;
1997                     if (dx2 &lt; regionX || dy2 &lt; regionY) skipRender = true;
1998 
1999                     if (!skipRender) {
2000                         // We know that dstX, dstY, dstX2, dstY2 overlap the region drawing area. Now we need
2001                         // to compute the source rectangle, and then draw.
2002                         float sx1 = dstX &lt; regionX ? srcX + srcW * (-tileX / tileWidth) : srcX;
2003                         float sy1 = dstY &lt; regionY ? srcY + srcH * (-tileY / tileHeight) : srcY;
2004                         float sx2 = dstX2 &gt; regionX2 ? srcX2 - srcW * ((dstX2 - regionX2) / tileWidth) : srcX2;
2005                         float sy2 = dstY2 &gt; regionY2 ? srcY2 - srcH * ((dstY2 - regionY2) / tileHeight) : srcY2;
2006 //                        System.out.println(&quot;g.drawTexture(texture, &quot; + dx1 + &quot;, &quot; + dy1 + &quot;, &quot; + dx2 + &quot;, &quot; + dy2 + &quot;, &quot; + sx1 + &quot;, &quot; + sy1 + &quot;, &quot; + sx2 + &quot;, &quot; + sy2 + &quot;)&quot;);
2007                         g.drawTexture(texture, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
2008                     }
2009                     dstX += xIncrement;
2010                 }
2011                 dstY += yIncrement;
2012             }
2013             texture.unlock();
2014         }
2015     }
2016 
2017     final Border getBorder() {
2018         return border;
2019     }
2020 
2021     final Background getBackground() {
2022         return background;
2023     }
2024 
2025     final float getWidth() {
2026         return width;
2027     }
2028 
2029     final float getHeight() {
2030         return height;
2031     }
2032 
2033 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>