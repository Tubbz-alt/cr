<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.base/src/main/java/javafx/collections/FXCollections.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.collections;
  27 
  28 import com.sun.javafx.collections.ListListenerHelper;
  29 import com.sun.javafx.collections.MapListenerHelper;
  30 import com.sun.javafx.collections.SetListenerHelper;
  31 import java.lang.reflect.Array;
  32 import java.util.AbstractList;
  33 import java.util.AbstractMap;
  34 import java.util.AbstractSet;
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Collection;
  38 import java.util.Collections;
  39 import java.util.Comparator;
  40 import java.util.HashMap;
  41 import java.util.HashSet;
  42 import java.util.Iterator;
  43 import java.util.List;
  44 import java.util.ListIterator;
  45 import java.util.Map;
  46 import java.util.NoSuchElementException;
  47 import java.util.Random;
  48 import java.util.Set;
  49 
  50 import javafx.beans.InvalidationListener;
  51 
  52 import com.sun.javafx.collections.ObservableListWrapper;
  53 import com.sun.javafx.collections.ObservableMapWrapper;
  54 import com.sun.javafx.collections.ObservableSetWrapper;
  55 import com.sun.javafx.collections.MapAdapterChange;
  56 import com.sun.javafx.collections.ObservableFloatArrayImpl;
  57 import com.sun.javafx.collections.ObservableIntegerArrayImpl;
  58 import com.sun.javafx.collections.ObservableSequentialListWrapper;
  59 import com.sun.javafx.collections.SetAdapterChange;
  60 import com.sun.javafx.collections.SortableList;
  61 import com.sun.javafx.collections.SourceAdapterChange;
  62 import java.util.RandomAccess;
  63 import javafx.beans.Observable;
  64 import javafx.collections.ListChangeListener.Change;
  65 import javafx.util.Callback;
  66 
  67 /**
  68  * Utility class that consists of static methods that are 1:1 copies of java.util.Collections methods.
  69  * &lt;br&gt;&lt;br&gt;
  70  * The wrapper methods (like synchronizedObservableList or emptyObservableList) has exactly the same
  71  * functionality as the methods in Collections, with exception that they return ObservableList and are
  72  * therefore suitable for methods that require ObservableList on input.
  73  * &lt;br&gt;&lt;br&gt;
  74  * The utility methods are here mainly for performance reasons. All methods are optimized in a way that
  75  * they yield only limited number of notifications. On the other hand, java.util.Collections methods
  76  * might call &quot;modification methods&quot; on an ObservableList multiple times, resulting in a number of notifications.
  77  *
  78  * @since JavaFX 2.0
  79  */
  80 public class FXCollections {
  81     /** Not to be instantiated. */
  82     private FXCollections() { }
  83 
  84     /**
  85      * Constructs an ObservableList that is backed by the specified list.
  86      * Mutation operations on the ObservableList instance will be reported
  87      * to observers that have registered on that instance.&lt;br&gt;
  88      * Note that mutation operations made directly to the underlying list are
  89      * &lt;em&gt;not&lt;/em&gt; reported to observers of any ObservableList that
  90      * wraps it.
  91      *
  92      * @param &lt;E&gt; The type of List to be wrapped
  93      * @param list a concrete List that backs this ObservableList
  94      * @return a newly created ObservableList
  95      */
  96     public static &lt;E&gt; ObservableList&lt;E&gt; observableList(List&lt;E&gt; list) {
  97         if (list == null) {
  98             throw new NullPointerException();
  99         }
 100         return list instanceof RandomAccess ? new ObservableListWrapper&lt;E&gt;(list) :
 101                 new ObservableSequentialListWrapper&lt;E&gt;(list);
 102     }
 103 
 104     /**
 105      * Constructs an ObservableList that is backed by the specified list.
 106      * Mutation operations on the ObservableList instance will be reported
 107      * to observers that have registered on that instance.&lt;br&gt;
 108      * Note that mutation operations made directly to the underlying list are
 109      * &lt;em&gt;not&lt;/em&gt; reported to observers of any ObservableList that
 110      * wraps it.
 111      * &lt;br&gt;
 112      * This list also reports mutations of the elements in it by using &lt;code&gt;extractor&lt;/code&gt;.
 113      * Observable objects returned by extractor (applied to each list element) are listened for changes
 114      * and transformed into &quot;update&quot; change of ListChangeListener.
 115      *
 116      * @param &lt;E&gt; The type of List to be wrapped
 117      * @param list a concrete List that backs this ObservableList
 118      * @param extractor element to Observable[] convertor
 119      * @since JavaFX 2.1
 120      * @return a newly created ObservableList
 121      */
 122     public static &lt;E&gt; ObservableList&lt;E&gt; observableList(List&lt;E&gt; list, Callback&lt;E, Observable[]&gt; extractor) {
 123         if (list == null || extractor == null) {
 124             throw new NullPointerException();
 125         }
 126         return list instanceof RandomAccess ? new ObservableListWrapper&lt;E&gt;(list, extractor) :
 127             new ObservableSequentialListWrapper&lt;E&gt;(list, extractor);
 128     }
 129 
 130     /**
 131      * Constructs an ObservableMap that is backed by the specified map.
 132      * Mutation operations on the ObservableMap instance will be reported
 133      * to observers that have registered on that instance.&lt;br&gt;
 134      * Note that mutation operations made directly to the underlying map are &lt;em&gt;not&lt;/em&gt;
 135      * reported to observers of any ObservableMap that wraps it.
 136      * @param &lt;K&gt; the type of the wrapped key
 137      * @param &lt;V&gt; the type of the wrapped value
 138      * @param map a Map that backs this ObservableMap
 139      * @return a newly created ObservableMap
 140      */
 141     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; observableMap(Map&lt;K, V&gt; map) {
 142         if (map == null) {
 143             throw new NullPointerException();
 144         }
 145         return new ObservableMapWrapper&lt;K, V&gt;(map);
 146     }
 147 
 148     /**
 149      * Constructs an ObservableSet that is backed by the specified set.
 150      * Mutation operations on the ObservableSet instance will be reported
 151      * to observers that have registered on that instance.&lt;br&gt;
 152      * Note that mutation operations made directly to the underlying set are &lt;em&gt;not&lt;/em&gt;
 153      * reported to observers of any ObservableSet that wraps it.
 154      * @param &lt;E&gt; The type of List to be wrapped
 155      * @param set a Set that backs this ObservableSet
 156      * @return a newly created ObservableSet
 157      * @since JavaFX 2.1
 158      */
 159     public static &lt;E&gt; ObservableSet&lt;E&gt; observableSet(Set&lt;E&gt; set) {
 160         if (set == null) {
 161             throw new NullPointerException();
 162         }
 163         return new ObservableSetWrapper&lt;E&gt;(set);
 164     }
 165 
 166     /**
 167      * Constructs an ObservableSet backed by a HashSet
 168      * that contains all the specified elements.
 169      * @param &lt;E&gt; The type of List to be wrapped
 170      * @param elements elements that will be added into returned ObservableSet
 171      * @return a newly created ObservableSet
 172      * @since JavaFX 2.1
 173      */
 174     public static &lt;E&gt; ObservableSet&lt;E&gt; observableSet(E... elements) {
 175         if (elements == null) {
 176             throw new NullPointerException();
 177         }
 178         Set&lt;E&gt; set = new HashSet&lt;E&gt;(elements.length);
 179         Collections.addAll(set, elements);
 180         return new ObservableSetWrapper&lt;E&gt;(set);
 181     }
 182 
 183     /**
 184      * Constructs a read-only interface to the specified ObservableMap. Only
 185      * mutation operations made to the underlying ObservableMap will be reported
 186      * to observers that have registered on the unmodifiable instance. This allows
 187      * clients to track changes in a Map but disallows the ability to modify it.
 188      * @param &lt;K&gt; the type of the wrapped key
 189      * @param &lt;V&gt; the type of the wrapped value
 190      * @param map an ObservableMap that is to be monitored by this interface
 191      * @return a newly created UnmodifiableObservableMap
 192      */
 193     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; unmodifiableObservableMap(ObservableMap&lt;K, V&gt; map) {
 194         if (map == null) {
 195             throw new NullPointerException();
 196         }
 197         return new com.sun.javafx.collections.UnmodifiableObservableMap&lt;K, V&gt;(map);
 198     }
 199 
 200     /**
 201      * Creates and returns a typesafe wrapper on top of provided observable map.
 202      * @param &lt;K&gt; the type of the wrapped key
 203      * @param &lt;V&gt; the type of the wrapped value
 204      * @param map an Observable map to be wrapped
 205      * @param keyType the type of key that {@code map} is permitted to hold
 206      * @param valueType the type of value that {@code map} is permitted to hold
 207      * @return a dynamically typesafe view of the specified map
 208      * @see Collections#checkedMap(java.util.Map, java.lang.Class, java.lang.Class)
 209      * @since JavaFX 8.0
 210      */
 211     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; checkedObservableMap(ObservableMap&lt;K, V&gt; map, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
 212         if (map == null || keyType == null || valueType == null) {
 213             throw new NullPointerException();
 214         }
 215         return new CheckedObservableMap&lt;K, V&gt;(map, keyType, valueType);
 216     }
 217 
 218     /**
 219      * Creates and returns a synchronized wrapper on top of provided observable map.
 220      * @param &lt;K&gt; the type of the wrapped key
 221      * @param &lt;V&gt; the type of the wrapped value
 222      * @param  map the map to be &quot;wrapped&quot; in a synchronized map.
 223      * @return A synchronized version of the observable map
 224      * @see Collections#synchronizedMap(java.util.Map)
 225      * @since JavaFX 8.0
 226      */
 227     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; synchronizedObservableMap(ObservableMap&lt;K, V&gt; map) {
 228         if (map == null) {
 229             throw new NullPointerException();
 230         }
 231         return new SynchronizedObservableMap&lt;K, V&gt;(map);
 232     }
 233 
 234     private static ObservableMap EMPTY_OBSERVABLE_MAP = new EmptyObservableMap();
 235 
 236     /**
 237      * Creates an empty unmodifiable observable map.
 238      * @param &lt;K&gt; the type of the wrapped key
 239      * @param &lt;V&gt; the type of the wrapped value
 240      * @return An empty unmodifiable observable map
 241      * @see Collections#emptyMap()
 242      * @since JavaFX 8.0
 243      */
 244     @SuppressWarnings(&quot;unchecked&quot;)
 245     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; emptyObservableMap() {
 246         return EMPTY_OBSERVABLE_MAP;
 247     }
 248 
 249     /**
 250      * Creates a new empty observable integer array.
 251      * @return a newly created ObservableIntegerArray
 252      * @since JavaFX 8.0
 253      */
 254     public static ObservableIntegerArray observableIntegerArray() {
 255         return new ObservableIntegerArrayImpl();
 256     }
 257 
 258     /**
 259      * Creates a new observable integer array with {@code values} set to it.
 260      * @param values the values that will be in the new observable integer array
 261      * @return a newly created ObservableIntegerArray
 262      * @since JavaFX 8.0
 263      */
 264     public static ObservableIntegerArray observableIntegerArray(int... values) {
 265         return new ObservableIntegerArrayImpl(values);
 266     }
 267 
 268     /**
 269      * Creates a new observable integer array with copy of elements in given
 270      * {@code array}.
 271      * @param array observable integer array to copy
 272      * @return a newly created ObservableIntegerArray
 273      * @since JavaFX 8.0
 274      */
 275     public static ObservableIntegerArray observableIntegerArray(ObservableIntegerArray array) {
 276         return new ObservableIntegerArrayImpl(array);
 277     }
 278 
 279     /**
 280      * Creates a new empty observable float array.
 281      * @return a newly created ObservableFloatArray
 282      * @since JavaFX 8.0
 283      */
 284     public static ObservableFloatArray observableFloatArray() {
 285         return new ObservableFloatArrayImpl();
 286     }
 287 
 288     /**
 289      * Creates a new observable float array with {@code values} set to it.
 290      * @param values the values that will be in the new observable float array
 291      * @return a newly created ObservableFloatArray
 292      * @since JavaFX 8.0
 293      */
 294     public static ObservableFloatArray observableFloatArray(float... values) {
 295         return new ObservableFloatArrayImpl(values);
 296     }
 297 
 298     /**
 299      * Creates a new observable float array with copy of elements in given
 300      * {@code array}.
 301      * @param array observable float array to copy
 302      * @return a newly created ObservableFloatArray
 303      * @since JavaFX 8.0
 304      */
 305     public static ObservableFloatArray observableFloatArray(ObservableFloatArray array) {
 306         return new ObservableFloatArrayImpl(array);
 307     }
 308 
 309     /**
 310      * Creates a new empty observable list that is backed by an arraylist.
 311      * @see #observableList(java.util.List)
 312      * @param &lt;E&gt; The type of List to be wrapped
 313      * @return a newly created ObservableList
 314      */
 315     @SuppressWarnings(&quot;unchecked&quot;)
 316     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList() {
 317         return observableList(new ArrayList());
 318     }
 319 
 320     /**
 321      * Creates a new empty observable list backed by an arraylist.
 322      *
 323      * This list reports element updates.
 324      * @param &lt;E&gt; The type of List to be wrapped
 325      * @param extractor element to Observable[] convertor. Observable objects are listened for changes on the element.
 326      * @see #observableList(java.util.List, javafx.util.Callback)
 327      * @since JavaFX 2.1
 328      * @return a newly created ObservableList
 329      */
 330     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(Callback&lt;E, Observable[]&gt; extractor) {
 331         return observableList(new ArrayList(), extractor);
 332     }
 333 
 334     /**
 335      * Creates a new observable array list with {@code items} added to it.
 336      * @param &lt;E&gt; The type of List to be wrapped
 337      * @param items the items that will be in the new observable ArrayList
 338      * @return a newly created observableArrayList
 339      * @see #observableArrayList()
 340      */
 341     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(E... items) {
 342         ObservableList&lt;E&gt; list = observableArrayList();
 343         list.addAll(items);
 344         return list;
 345     }
 346 
 347     /**
 348      * Creates a new observable array list and adds a content of collection {@code col}
 349      * to it.
 350      * @param &lt;E&gt; The type of List to be wrapped
 351      * @param col a collection which content should be added to the observableArrayList
 352      * @return a newly created observableArrayList
 353      */
 354     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(Collection&lt;? extends E&gt; col) {
 355         ObservableList&lt;E&gt; list = observableArrayList();
 356         list.addAll(col);
 357         return list;
 358     }
 359 
 360     /**
 361      * Creates a new empty observable map that is backed by a HashMap.
 362      * @param &lt;K&gt; the type of the wrapped key
 363      * @param &lt;V&gt; the type of the wrapped value
 364      * @return a newly created observable HashMap
 365      */
 366     public static &lt;K,V&gt; ObservableMap&lt;K,V&gt; observableHashMap() {
 367         return observableMap(new HashMap&lt;K, V&gt;());
 368     }
 369 
 370     /**
 371      * Concatenates more observable lists into one. The resulting list
 372      * would be backed by an arraylist.
 373      * @param &lt;E&gt; The type of List to be wrapped
 374      * @param lists lists to concatenate
 375      * @return new observable array list concatenated from the arguments
 376      */
 377     public static &lt;E&gt; ObservableList&lt;E&gt; concat(ObservableList&lt;E&gt;... lists) {
 378         if (lists.length == 0 ) {
 379             return observableArrayList();
 380         }
 381         if (lists.length == 1) {
 382             return observableArrayList(lists[0]);
 383         }
 384         ArrayList&lt;E&gt; backingList = new ArrayList&lt;E&gt;();
 385         for (ObservableList&lt;E&gt; s : lists) {
 386             backingList.addAll(s);
 387         }
 388 
 389         return observableList(backingList);
 390     }
 391 
 392     /**
 393      * Creates and returns unmodifiable wrapper list on top of provided observable list.
 394      * @param list  an ObservableList that is to be wrapped
 395      * @param &lt;E&gt; The type of List to be wrapped
 396      * @return an ObserableList wrapper that is unmodifiable
 397      * @see Collections#unmodifiableList(java.util.List)
 398      */
 399     public static&lt;E&gt; ObservableList&lt;E&gt; unmodifiableObservableList(ObservableList&lt;E&gt; list) {
 400         if (list == null) {
 401             throw new NullPointerException();
 402         }
 403         return new UnmodifiableObservableListImpl&lt;E&gt;(list);
 404     }
 405 
 406     /**
 407      * Creates and returns a typesafe wrapper on top of provided observable list.
 408      * @param &lt;E&gt; The type of List to be wrapped
 409      * @param list  an Observable list to be wrapped
 410      * @param type   the type of element that {@code list} is permitted to hold
 411      * @return a dynamically typesafe view of the specified list
 412      * @see Collections#checkedList(java.util.List, java.lang.Class)
 413      */
 414     public static&lt;E&gt; ObservableList&lt;E&gt; checkedObservableList(ObservableList&lt;E&gt; list, Class&lt;E&gt; type) {
 415         if (list == null) {
 416             throw new NullPointerException();
 417         }
 418         return new CheckedObservableList&lt;E&gt;(list, type);
 419     }
 420 
 421     /**
 422      * Creates and returns a synchronized wrapper on top of provided observable list.
 423      * @param &lt;E&gt; The type of List to be wrapped
 424      * @param  list the list to be &quot;wrapped&quot; in a synchronized list.
 425      * @return A synchronized version of the observable list
 426      * @see Collections#synchronizedList(java.util.List)
 427      */
 428     public static&lt;E&gt; ObservableList&lt;E&gt; synchronizedObservableList(ObservableList&lt;E&gt; list) {
 429         if (list == null) {
 430             throw new NullPointerException();
 431         }
 432         return new SynchronizedObservableList&lt;E&gt;(list);
 433     }
 434 
 435     private static ObservableList EMPTY_OBSERVABLE_LIST = new EmptyObservableList();
 436 
 437 
 438     /**
 439      * Creates an empty unmodifiable observable list.
 440      * @param &lt;E&gt; The type of List to be wrapped
 441      * @return An empty unmodifiable observable list
 442      * @see Collections#emptyList()
 443      */
 444     @SuppressWarnings(&quot;unchecked&quot;)
 445     public static&lt;E&gt; ObservableList&lt;E&gt; emptyObservableList() {
 446         return EMPTY_OBSERVABLE_LIST;
 447     }
 448 
 449     /**
 450      * Creates an unmodifiable observable list with single element.
 451      * @param &lt;E&gt; The type of List to be wrapped
 452      * @param e the only elements that will be contained in this singleton observable list
 453      * @return a singleton observable list
 454      * @see Collections#singletonList(java.lang.Object)
 455      */
 456     public static&lt;E&gt; ObservableList&lt;E&gt; singletonObservableList(E e) {
 457         return new SingletonObservableList&lt;E&gt;(e);
 458     }
 459 
 460     /**
 461      * Creates and returns unmodifiable wrapper on top of provided observable set.
 462      * @param &lt;E&gt; The type of List to be wrapped
 463      * @param set an ObservableSet that is to be wrapped
 464      * @return an ObserableSet wrapper that is unmodifiable
 465      * @see Collections#unmodifiableSet(java.util.Set)
 466      * @since JavaFX 8.0
 467      */
 468     public static&lt;E&gt; ObservableSet&lt;E&gt; unmodifiableObservableSet(ObservableSet&lt;E&gt; set) {
 469         if (set == null) {
 470             throw new NullPointerException();
 471         }
 472         return new UnmodifiableObservableSet&lt;E&gt;(set);
 473     }
 474 
 475     /**
 476      * Creates and returns a typesafe wrapper on top of provided observable set.
 477      * @param &lt;E&gt; The type of List to be wrapped
 478      * @param set an Observable set to be wrapped
 479      * @param type  the type of element that {@code set} is permitted to hold
 480      * @return a dynamically typesafe view of the specified set
 481      * @see Collections#checkedSet(java.util.Set, java.lang.Class)
 482      * @since JavaFX 8.0
 483      */
 484     public static&lt;E&gt; ObservableSet&lt;E&gt; checkedObservableSet(ObservableSet&lt;E&gt; set, Class&lt;E&gt; type) {
 485         if (set == null) {
 486             throw new NullPointerException();
 487         }
 488         return new CheckedObservableSet&lt;E&gt;(set, type);
 489     }
 490 
 491     /**
 492      * Creates and returns a synchronized wrapper on top of provided observable set.
 493      * @param &lt;E&gt; The type of List to be wrapped
 494      * @param  set the set to be &quot;wrapped&quot; in a synchronized set.
 495      * @return A synchronized version of the observable set
 496      * @see Collections#synchronizedSet(java.util.Set)
 497      * @since JavaFX 8.0
 498      */
 499     public static&lt;E&gt; ObservableSet&lt;E&gt; synchronizedObservableSet(ObservableSet&lt;E&gt; set) {
 500         if (set == null) {
 501             throw new NullPointerException();
 502         }
 503         return new SynchronizedObservableSet&lt;E&gt;(set);
 504     }
 505 
 506     private static ObservableSet EMPTY_OBSERVABLE_SET = new EmptyObservableSet();
 507 
 508     /**
 509      * Creates an empty unmodifiable observable set.
 510      * @param &lt;E&gt; The type of List to be wrapped
 511      * @return An empty unmodifiable observable set
 512      * @see Collections#emptySet()
 513      * @since JavaFX 8.0
 514      */
 515     @SuppressWarnings(&quot;unchecked&quot;)
 516     public static&lt;E&gt; ObservableSet&lt;E&gt; emptyObservableSet() {
 517         return EMPTY_OBSERVABLE_SET;
 518     }
 519 
 520     /**
 521      * Copies elements from src to dest. Fires only &lt;b&gt;one&lt;/b&gt; change notification on dest.
 522      * @param &lt;T&gt; The type of List to be wrapped
 523      * @param dest the destination observable list
 524      * @param src the source list
 525      * @see Collections#copy(java.util.List, java.util.List)
 526      */
 527     @SuppressWarnings(&quot;unchecked&quot;)
 528     public static &lt;T&gt; void copy(ObservableList&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
 529         final int srcSize = src.size();
 530         if (srcSize &gt; dest.size()) {
 531             throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);
 532         }
 533         T[] destArray = (T[]) dest.toArray();
 534         System.arraycopy(src.toArray(), 0, destArray, 0, srcSize);
 535         dest.setAll(destArray);
 536     }
 537 
 538     /**
 539      * Fills the provided list with obj. Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 540      * @param &lt;T&gt; The type of List to be wrapped
 541      * @param list the list to fill
 542      * @param obj the object to fill the list with
 543      * @see Collections#fill(java.util.List, java.lang.Object)
 544      */
 545     @SuppressWarnings(&quot;unchecked&quot;)
 546     public static &lt;T&gt; void fill(ObservableList&lt;? super T&gt; list, T obj) {
 547         T[] newContent = (T[]) new Object[list.size()];
 548         Arrays.fill(newContent, obj);
 549         list.setAll(newContent);
 550     }
 551 
 552     /**
 553      * Replace all oldVal elements in the list with newVal element.
 554      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 555      * @param &lt;T&gt; The type of List to be wrapped
 556      * @param list the list which will have it&#39;s elements replaced
 557      * @param oldVal the element that is going to be replace
 558      * @param newVal the replacement
 559      * @return true if the list was modified
 560      * @see Collections#replaceAll(java.util.List, java.lang.Object, java.lang.Object)
 561      */
 562     @SuppressWarnings(&quot;unchecked&quot;)
 563     public static &lt;T&gt; boolean replaceAll(ObservableList&lt;T&gt; list, T oldVal, T newVal) {
 564         T[] newContent = (T[]) list.toArray();
 565         boolean modified = false;
 566         for (int i = 0 ; i &lt; newContent.length; ++i) {
 567             if (newContent[i].equals(oldVal)) {
 568                 newContent[i] = newVal;
 569                 modified = true;
 570             }
 571         }
 572         if (modified) {
 573             list.setAll(newContent);
 574         }
 575         return modified;
 576     }
 577 
 578     /**
 579      * Reverse the order in the list
 580      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 581      * @param list the list to be reversed
 582      * @see Collections#reverse(java.util.List)
 583      */
 584     @SuppressWarnings(&quot;unchecked&quot;)
 585     public static void reverse(ObservableList list) {
 586         Object[] newContent = list.toArray();
 587         for (int i = 0; i &lt; newContent.length / 2; ++i) {
 588             Object tmp = newContent[i];
 589             newContent[i] = newContent[newContent.length - i - 1];
 590             newContent[newContent.length -i - 1] = tmp;
 591         }
 592         list.setAll(newContent);
 593     }
 594 
 595     /**
 596      * Rotates the list by distance.
 597      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 598      * @param list the list to be rotated
 599      * @param distance the distance of rotation
 600      * @see Collections#rotate(java.util.List, int)
 601      */
 602     @SuppressWarnings(&quot;unchecked&quot;)
 603     public static void rotate(ObservableList list, int distance) {
 604         Object[] newContent = list.toArray();
 605 
 606         int size = list.size();
 607         distance = distance % size;
 608         if (distance &lt; 0)
 609             distance += size;
 610         if (distance == 0)
 611             return;
 612 
 613         for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
 614             Object displaced = newContent[cycleStart];
 615             Object tmp;
 616             int i = cycleStart;
 617             do {
 618                 i += distance;
 619                 if (i &gt;= size)
 620                     i -= size;
 621                 tmp = newContent[i];
 622                 newContent[i] = displaced;
 623                 displaced = tmp;
 624                 nMoved ++;
 625             } while(i != cycleStart);
 626         }
 627         list.setAll(newContent);
 628     }
 629 
 630     /**
 631      * Shuffles all elements in the observable list.
 632      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 633      * @param list the list to shuffle
 634      * @see Collections#shuffle(java.util.List)
 635      */
 636     public static void shuffle(ObservableList&lt;?&gt; list) {
 637         if (r == null) {
 638             r = new Random();
 639         }
 640         shuffle(list, r);
 641     }
 642     private static Random r;
 643 
 644     /**
 645      * Shuffles all elements in the observable list.
 646      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 647      * @param list the list to be shuffled
 648      * @param rnd the random generator used for shuffling
 649      * @see Collections#shuffle(java.util.List, java.util.Random)
 650      */
 651     @SuppressWarnings(&quot;unchecked&quot;)
 652     public static void shuffle(ObservableList list, Random rnd) {
 653         Object newContent[] = list.toArray();
 654 
 655         for (int i = list.size(); i &gt; 1; i--) {
 656             swap(newContent, i - 1, rnd.nextInt(i));
 657         }
 658 
 659         list.setAll(newContent);
 660     }
 661 
 662     private static void swap(Object[] arr, int i, int j) {
 663         Object tmp = arr[i];
 664         arr[i] = arr[j];
 665         arr[j] = tmp;
 666     }
 667 
 668     /**
 669      * Sorts the provided observable list.
 670      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 671      * @param &lt;T&gt; The type of List to be wrapped
 672      * @param list the list to be sorted
 673      * @see Collections#sort(java.util.List)
 674      */
 675     @SuppressWarnings(&quot;unchecked&quot;)
 676     public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(ObservableList&lt;T&gt; list) {
 677         if (list instanceof SortableList) {
 678             ((SortableList&lt;? extends T&gt;)list).sort();
 679         } else {
 680             List&lt;T&gt; newContent = new ArrayList&lt;T&gt;(list);
 681             Collections.sort(newContent);
 682             list.setAll((Collection&lt;T&gt;)newContent);
 683         }
 684     }
 685 
 686     /**
 687      * Sorts the provided observable list using the c comparator.
 688      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 689      * @param &lt;T&gt; The type of List to be wrapped
 690      * @param list the list to sort
 691      * @param c comparator used for sorting. Null if natural ordering is required.
 692      * @see Collections#sort(java.util.List, java.util.Comparator)
 693      */
 694     @SuppressWarnings(&quot;unchecked&quot;)
 695     public static &lt;T&gt; void sort(ObservableList&lt;T&gt; list, Comparator&lt;? super T&gt; c) {
 696         if (list instanceof SortableList) {
 697             ((SortableList&lt;? extends T&gt;)list).sort(c);
 698         } else {
 699             List&lt;T&gt; newContent = new ArrayList&lt;T&gt;(list);
 700             Collections.sort(newContent, c);
 701             list.setAll((Collection&lt;T&gt;)newContent);
 702         }
 703     }
 704 
 705     private static class EmptyObservableList&lt;E&gt; extends AbstractList&lt;E&gt; implements ObservableList&lt;E&gt; {
 706 
 707         private static final ListIterator iterator = new ListIterator() {
 708 
 709             @Override
 710             public boolean hasNext() {
 711                 return false;
 712             }
 713 
 714             @Override
 715             public Object next() {
 716                 throw new NoSuchElementException();
 717             }
 718 
 719             @Override
 720             public void remove() {
 721                 throw new UnsupportedOperationException();
 722             }
 723 
 724             @Override
 725             public boolean hasPrevious() {
 726                 return false;
 727             }
 728 
 729             @Override
 730             public Object previous() {
 731                 throw new NoSuchElementException();
 732             }
 733 
 734             @Override
 735             public int nextIndex() {
 736                 return 0;
 737             }
 738 
 739             @Override
 740             public int previousIndex() {
 741                 return -1;
 742             }
 743 
 744             @Override
 745             public void set(Object e) {
 746                 throw new UnsupportedOperationException();
 747             }
 748 
 749             @Override
 750             public void add(Object e) {
 751                 throw new UnsupportedOperationException();
 752             }
 753         };
 754 
 755         public EmptyObservableList() {
 756         }
 757 
 758         @Override
 759         public final void addListener(InvalidationListener listener) {
 760         }
 761 
 762         @Override
 763         public final void removeListener(InvalidationListener listener) {
 764         }
 765 
 766 
 767         @Override
 768         public void addListener(ListChangeListener&lt;? super E&gt; o) {
 769         }
 770 
 771         @Override
 772         public void removeListener(ListChangeListener&lt;? super E&gt; o) {
 773         }
 774 
 775         @Override
 776         public int size() {
 777             return 0;
 778         }
 779 
 780         @Override
 781         public boolean contains(Object o) {
 782             return false;
 783         }
 784 
 785         @Override
 786         @SuppressWarnings(&quot;unchecked&quot;)
 787         public Iterator&lt;E&gt; iterator() {
 788             return iterator;
 789         }
 790 
 791         @Override
 792         public boolean containsAll(Collection&lt;?&gt; c) {
 793             return c.isEmpty();
 794         }
 795 
 796         @Override
 797         public E get(int index) {
 798             throw new IndexOutOfBoundsException();
 799         }
 800 
 801         @Override
 802         public int indexOf(Object o) {
 803             return -1;
 804         }
 805 
 806         @Override
 807         public int lastIndexOf(Object o) {
 808             return -1;
 809         }
 810 
 811         @Override
 812         @SuppressWarnings(&quot;unchecked&quot;)
 813         public ListIterator&lt;E&gt; listIterator() {
 814             return iterator;
 815         }
 816 
 817         @Override
 818         @SuppressWarnings(&quot;unchecked&quot;)
 819         public ListIterator&lt;E&gt; listIterator(int index) {
 820             if (index != 0) {
 821                 throw new IndexOutOfBoundsException();
 822             }
 823             return iterator;
 824         }
 825 
 826         @Override
 827         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
 828             if (fromIndex != 0 || toIndex != 0) {
 829                 throw new IndexOutOfBoundsException();
 830             }
 831             return this;
 832         }
 833 
 834         @Override
 835         public boolean addAll(E... elements) {
 836             throw new UnsupportedOperationException();
 837         }
 838 
 839         @Override
 840         public boolean setAll(E... elements) {
 841             throw new UnsupportedOperationException();
 842         }
 843 
 844         @Override
 845         public boolean setAll(Collection&lt;? extends E&gt; col) {
 846             throw new UnsupportedOperationException();
 847         }
 848 
 849         @Override
 850         public boolean removeAll(E... elements) {
 851             throw new UnsupportedOperationException();
 852         }
 853 
 854         @Override
 855         public boolean retainAll(E... elements) {
 856             throw new UnsupportedOperationException();
 857         }
 858 
 859         @Override
 860         public void remove(int from, int to) {
 861             throw new UnsupportedOperationException();
 862         }
 863     }
 864 
 865     private static class SingletonObservableList&lt;E&gt; extends AbstractList&lt;E&gt; implements ObservableList&lt;E&gt; {
 866 
 867         private final E element;
 868 
 869         public SingletonObservableList(E element) {
 870             if (element == null) {
 871                 throw new NullPointerException();
 872             }
 873             this.element = element;
 874         }
 875 
 876         @Override
 877         public boolean addAll(E... elements) {
 878             throw new UnsupportedOperationException();
 879         }
 880 
 881         @Override
 882         public boolean setAll(E... elements) {
 883             throw new UnsupportedOperationException();
 884         }
 885 
 886         @Override
 887         public boolean setAll(Collection&lt;? extends E&gt; col) {
 888             throw new UnsupportedOperationException();
 889         }
 890 
 891         @Override
 892         public boolean removeAll(E... elements) {
 893             throw new UnsupportedOperationException();
 894         }
 895 
 896         @Override
 897         public boolean retainAll(E... elements) {
 898             throw new UnsupportedOperationException();
 899         }
 900 
 901         @Override
 902         public void remove(int from, int to) {
 903             throw new UnsupportedOperationException();
 904         }
 905 
 906         @Override
 907         public void addListener(InvalidationListener listener) {
 908         }
 909 
 910         @Override
 911         public void removeListener(InvalidationListener listener) {
 912         }
 913 
 914         @Override
 915         public void addListener(ListChangeListener&lt;? super E&gt; o) {
 916         }
 917 
 918         @Override
 919         public void removeListener(ListChangeListener&lt;? super E&gt; o) {
 920         }
 921 
 922         @Override
 923         public int size() {
 924             return 1;
 925         }
 926 
 927         @Override
 928         public boolean isEmpty() {
 929             return false;
 930         }
 931 
 932         @Override
 933         public boolean contains(Object o) {
 934             return element.equals(o);
 935         }
 936 
 937         @Override
 938         public E get(int index) {
 939             if (index != 0) {
 940                 throw new IndexOutOfBoundsException();
 941             }
 942             return element;
 943         }
 944 
 945     }
 946 
 947     private static class UnmodifiableObservableListImpl&lt;T&gt; extends ObservableListBase&lt;T&gt; implements ObservableList&lt;T&gt; {
 948 
 949         private final ObservableList&lt;T&gt; backingList;
 950         private final ListChangeListener&lt;T&gt; listener;
 951 
 952         public UnmodifiableObservableListImpl(ObservableList&lt;T&gt; backingList) {
 953             this.backingList = backingList;
 954             listener = c -&gt; {
 955                 fireChange(new SourceAdapterChange&lt;T&gt;(UnmodifiableObservableListImpl.this, c));
 956             };
 957             this.backingList.addListener(new WeakListChangeListener&lt;T&gt;(listener));
 958         }
 959 
 960         @Override
 961         public T get(int index) {
 962             return backingList.get(index);
 963         }
 964 
 965         @Override
 966         public int size() {
 967             return backingList.size();
 968         }
 969 
 970         @Override
 971         public boolean addAll(T... elements) {
 972             throw new UnsupportedOperationException();
 973         }
 974 
 975         @Override
 976         public boolean setAll(T... elements) {
 977             throw new UnsupportedOperationException();
 978         }
 979 
 980         @Override
 981         public boolean setAll(Collection&lt;? extends T&gt; col) {
 982             throw new UnsupportedOperationException();
 983         }
 984 
 985         @Override
 986         public boolean removeAll(T... elements) {
 987             throw new UnsupportedOperationException();
 988         }
 989 
 990         @Override
 991         public boolean retainAll(T... elements) {
 992             throw new UnsupportedOperationException();
 993         }
 994 
 995         @Override
 996         public void remove(int from, int to) {
 997             throw new UnsupportedOperationException();
 998         }
 999 
1000     }
1001 
1002     private static class SynchronizedList&lt;T&gt; implements List&lt;T&gt; {
1003         final Object mutex;
1004         private final List&lt;T&gt; backingList;
1005 
1006         SynchronizedList(List&lt;T&gt; list, Object mutex) {
1007             this.backingList = list;
1008             this.mutex = mutex;
1009         }
1010 
1011         SynchronizedList(List&lt;T&gt; list) {
<a name="1" id="anc1"></a><span class="line-removed">1012             this.backingList = list;</span>
<span class="line-removed">1013             this.mutex = this;</span>
<span class="line-removed">1014         }</span>
<span class="line-removed">1015 </span>
<span class="line-removed">1016         SynchronizedList(List&lt;T&gt; list) {</span>
<span class="line-removed">1017             this.backingList = list;</span>
<span class="line-removed">1018             this.mutex = this;</span>
<span class="line-removed">1019         }</span>
<span class="line-removed">1020 </span>
<span class="line-removed">1021         SynchronizedList(List&lt;T&gt; list) {</span>
1022             this.backingList = list;
1023             this.mutex = this;
1024         }
1025 
1026         @Override
1027         public int size() {
1028             synchronized(mutex) {
1029                 return backingList.size();
1030             }
1031         }
1032 
1033         @Override
1034         public boolean isEmpty() {
1035             synchronized(mutex) {
1036                 return backingList.isEmpty();
1037             }
1038         }
1039 
1040         @Override
1041         public boolean contains(Object o) {
1042             synchronized(mutex) {
1043                 return backingList.contains(o);
1044             }
1045         }
1046 
1047         @Override
1048         public Iterator&lt;T&gt; iterator() {
1049             return backingList.iterator();
1050         }
1051 
1052         @Override
1053         public Object[] toArray() {
1054             synchronized(mutex)  {
1055                 return backingList.toArray();
1056             }
1057         }
1058 
1059         @Override
1060         public &lt;T&gt; T[] toArray(T[] a) {
1061             synchronized(mutex) {
1062                 return backingList.toArray(a);
1063             }
1064         }
1065 
1066         @Override
1067         public boolean add(T e) {
1068             synchronized(mutex) {
1069                 return backingList.add(e);
1070             }
1071         }
1072 
1073         @Override
1074         public boolean remove(Object o) {
1075             synchronized(mutex) {
1076                 return backingList.remove(o);
1077             }
1078         }
1079 
1080         @Override
1081         public boolean containsAll(Collection&lt;?&gt; c) {
1082             synchronized(mutex) {
1083                 return backingList.containsAll(c);
1084             }
1085         }
1086 
1087         @Override
1088         public boolean addAll(Collection&lt;? extends T&gt; c) {
1089             synchronized(mutex) {
1090                 return backingList.addAll(c);
1091             }
1092         }
1093 
1094         @Override
1095         public boolean addAll(int index, Collection&lt;? extends T&gt; c) {
1096             synchronized(mutex) {
1097                 return backingList.addAll(index, c);
1098 
1099             }
1100         }
1101 
1102         @Override
1103         public boolean removeAll(Collection&lt;?&gt; c) {
1104             synchronized(mutex) {
1105                 return backingList.removeAll(c);
1106             }
1107         }
1108 
1109         @Override
1110         public boolean retainAll(Collection&lt;?&gt; c) {
1111             synchronized(mutex) {
1112                 return backingList.retainAll(c);
1113             }
1114         }
1115 
1116         @Override
1117         public void clear() {
1118             synchronized(mutex) {
1119                 backingList.clear();
1120             }
1121         }
1122 
1123         @Override
1124         public T get(int index) {
1125             synchronized(mutex) {
1126                 return backingList.get(index);
1127             }
1128         }
1129 
1130         @Override
1131         public T set(int index, T element) {
1132             synchronized(mutex) {
1133                 return backingList.set(index, element);
1134             }
1135         }
1136 
1137         @Override
1138         public void add(int index, T element) {
1139             synchronized(mutex) {
1140                 backingList.add(index, element);
1141             }
1142         }
1143 
1144         @Override
1145         public T remove(int index) {
1146             synchronized(mutex) {
1147                 return backingList.remove(index);
1148             }
1149         }
1150 
1151         @Override
1152         public int indexOf(Object o) {
1153             synchronized(mutex) {
1154                 return backingList.indexOf(o);
1155             }
1156         }
1157 
1158         @Override
1159         public int lastIndexOf(Object o) {
1160             synchronized(mutex) {
1161                 return backingList.lastIndexOf(o);
1162             }
1163         }
1164 
1165         @Override
1166         public ListIterator&lt;T&gt; listIterator() {
1167             return backingList.listIterator();
1168         }
1169 
1170         @Override
1171         public ListIterator&lt;T&gt; listIterator(int index) {
1172             synchronized(mutex) {
1173                 return backingList.listIterator(index);
1174             }
1175         }
1176 
1177         @Override
1178         public List&lt;T&gt; subList(int fromIndex, int toIndex) {
1179             synchronized(mutex) {
1180                 return new SynchronizedList&lt;T&gt;(backingList.subList(fromIndex, toIndex),
1181                         mutex);
1182             }
1183         }
1184 
1185         @Override
1186         public String toString() {
1187             synchronized(mutex) {
1188                 return backingList.toString();
1189             }
1190         }
1191 
1192         @Override
1193         public int hashCode() {
1194             synchronized(mutex) {
1195                 return backingList.hashCode();
1196             }
1197         }
1198 
1199         @Override
1200         public boolean equals(Object o) {
1201             synchronized(mutex) {
1202                 return backingList.equals(o);
1203             }
1204         }
1205 
1206     }
1207 
1208     private static class SynchronizedObservableList&lt;T&gt; extends SynchronizedList&lt;T&gt; implements ObservableList&lt;T&gt; {
1209 
1210         private ListListenerHelper helper;
1211 
1212         private final ObservableList&lt;T&gt; backingList;
1213         private final ListChangeListener&lt;T&gt; listener;
1214 
1215         SynchronizedObservableList(ObservableList&lt;T&gt; seq) {
1216             super(seq);
1217             this.backingList = seq;
1218             listener = c -&gt; {
1219                 ListListenerHelper.fireValueChangedEvent(helper, new SourceAdapterChange&lt;T&gt;(SynchronizedObservableList.this, c));
1220             };
1221             backingList.addListener(new WeakListChangeListener&lt;T&gt;(listener));
1222         }
1223 
1224         @Override
1225         public boolean addAll(T... elements) {
1226             synchronized(mutex) {
1227                 return backingList.addAll(elements);
1228             }
1229         }
1230 
1231         @Override
1232         public boolean setAll(T... elements) {
1233             synchronized(mutex) {
1234                 return backingList.setAll(elements);
1235             }
1236         }
1237 
1238         @Override
1239         public boolean removeAll(T... elements) {
1240             synchronized(mutex) {
1241                 return backingList.removeAll(elements);
1242             }
1243         }
1244 
1245         @Override
1246         public boolean retainAll(T... elements) {
1247             synchronized(mutex) {
1248                 return backingList.retainAll(elements);
1249             }
1250         }
1251 
1252         @Override
1253         public void remove(int from, int to) {
1254             synchronized(mutex) {
1255                 backingList.remove(from, to);
1256             }
1257         }
1258 
1259         @Override
1260         public boolean setAll(Collection&lt;? extends T&gt; col) {
1261             synchronized(mutex) {
1262                 return backingList.setAll(col);
1263             }
1264         }
1265 
1266         @Override
1267         public final void addListener(InvalidationListener listener) {
1268             synchronized (mutex) {
1269                 helper = ListListenerHelper.addListener(helper, listener);
1270             }
1271         }
1272 
1273         @Override
1274         public final void removeListener(InvalidationListener listener) {
1275             synchronized (mutex) {
1276                 helper = ListListenerHelper.removeListener(helper, listener);
1277             }
1278         }
1279 
1280         @Override
1281         public void addListener(ListChangeListener&lt;? super T&gt; listener) {
1282             synchronized (mutex) {
1283                 helper = ListListenerHelper.addListener(helper, listener);
1284             }
1285         }
1286 
1287         @Override
1288         public void removeListener(ListChangeListener&lt;? super T&gt; listener) {
1289             synchronized (mutex) {
1290                 helper = ListListenerHelper.removeListener(helper, listener);
1291             }
1292         }
1293 
1294 
1295     }
1296 
1297     private static class CheckedObservableList&lt;T&gt; extends ObservableListBase&lt;T&gt; implements ObservableList&lt;T&gt; {
1298 
1299         private final ObservableList&lt;T&gt; list;
1300         private final Class&lt;T&gt; type;
1301         private final ListChangeListener&lt;T&gt; listener;
1302 
1303         CheckedObservableList(ObservableList&lt;T&gt; list, Class&lt;T&gt; type) {
1304             if (list == null || type == null) {
1305                 throw new NullPointerException();
1306             }
1307             this.list = list;
1308             this.type = type;
1309             listener = c -&gt; {
1310                 fireChange(new SourceAdapterChange&lt;T&gt;(CheckedObservableList.this, c));
1311             };
1312             list.addListener(new WeakListChangeListener&lt;T&gt;(listener));
1313         }
1314 
1315         void typeCheck(Object o) {
1316             if (o != null &amp;&amp; !type.isInstance(o)) {
1317                 throw new ClassCastException(&quot;Attempt to insert &quot;
1318                         + o.getClass() + &quot; element into collection with element type &quot;
1319                         + type);
1320             }
1321         }
1322 
1323         @Override
1324         public int size() {
1325             return list.size();
1326         }
1327 
1328         @Override
1329         public boolean isEmpty() {
1330             return list.isEmpty();
1331         }
1332 
1333         @Override
1334         public boolean contains(Object o) {
1335             return list.contains(o);
1336         }
1337 
1338         @Override
1339         public Object[] toArray() {
1340             return list.toArray();
1341         }
1342 
1343         @Override
1344         public &lt;T&gt; T[] toArray(T[] a) {
1345             return list.toArray(a);
1346         }
1347 
1348         @Override
1349         public String toString() {
1350             return list.toString();
1351         }
1352 
1353         @Override
1354         public boolean remove(Object o) {
1355             return list.remove(o);
1356         }
1357 
1358         @Override
1359         public boolean containsAll(Collection&lt;?&gt; coll) {
1360             return list.containsAll(coll);
1361         }
1362 
1363         @Override
1364         public boolean removeAll(Collection&lt;?&gt; coll) {
1365             return list.removeAll(coll);
1366         }
1367 
1368         @Override
1369         public boolean retainAll(Collection&lt;?&gt; coll) {
1370             return list.retainAll(coll);
1371         }
1372 
1373         @Override
1374         public boolean removeAll(T... elements) {
1375             return list.removeAll(elements);
1376         }
1377 
1378         @Override
1379         public boolean retainAll(T... elements) {
1380             return list.retainAll(elements);
1381         }
1382 
1383         @Override
1384         public void remove(int from, int to) {
1385             list.remove(from, to);
1386         }
1387 
1388         @Override
1389         public void clear() {
1390             list.clear();
1391         }
1392 
1393         @Override
1394         public boolean equals(Object o) {
1395             return o == this || list.equals(o);
1396         }
1397 
1398         @Override
1399         public int hashCode() {
1400             return list.hashCode();
1401         }
1402 
1403         @Override
1404         public T get(int index) {
1405             return list.get(index);
1406         }
1407 
1408         @Override
1409         public T remove(int index) {
1410             return list.remove(index);
1411         }
1412 
1413         @Override
1414         public int indexOf(Object o) {
1415             return list.indexOf(o);
1416         }
1417 
1418         @Override
1419         public int lastIndexOf(Object o) {
1420             return list.lastIndexOf(o);
1421         }
1422 
1423         @Override
1424         public T set(int index, T element) {
1425             typeCheck(element);
1426             return list.set(index, element);
1427         }
1428 
1429         @Override
1430         public void add(int index, T element) {
1431             typeCheck(element);
1432             list.add(index, element);
1433         }
1434 
1435         @Override
1436         @SuppressWarnings(&quot;unchecked&quot;)
1437         public boolean addAll(int index, Collection&lt;? extends T&gt; c) {
1438             T[] a = null;
1439             try {
1440                 a = c.toArray((T[]) Array.newInstance(type, 0));
1441             } catch (ArrayStoreException e) {
1442                 throw new ClassCastException();
1443             }
1444 
1445             return this.list.addAll(index, Arrays.asList(a));
1446         }
1447 
1448         @Override
1449         @SuppressWarnings(&quot;unchecked&quot;)
1450         public boolean addAll(Collection&lt;? extends T&gt; coll) {
1451             T[] a = null;
1452             try {
1453                 a = coll.toArray((T[]) Array.newInstance(type, 0));
1454             } catch (ArrayStoreException e) {
1455                 throw new ClassCastException();
1456             }
1457 
1458             return this.list.addAll(Arrays.asList(a));
1459         }
1460 
1461         @Override
1462         public ListIterator&lt;T&gt; listIterator() {
1463             return listIterator(0);
1464         }
1465 
1466         @Override
1467         public ListIterator&lt;T&gt; listIterator(final int index) {
1468             return new ListIterator&lt;T&gt;() {
1469 
1470                 ListIterator&lt;T&gt; i = list.listIterator(index);
1471 
1472                 @Override
1473                 public boolean hasNext() {
1474                     return i.hasNext();
1475                 }
1476 
1477                 @Override
1478                 public T next() {
1479                     return i.next();
1480                 }
1481 
1482                 @Override
1483                 public boolean hasPrevious() {
1484                     return i.hasPrevious();
1485                 }
1486 
1487                 @Override
1488                 public T previous() {
1489                     return i.previous();
1490                 }
1491 
1492                 @Override
1493                 public int nextIndex() {
1494                     return i.nextIndex();
1495                 }
1496 
1497                 @Override
1498                 public int previousIndex() {
1499                     return i.previousIndex();
1500                 }
1501 
1502                 @Override
1503                 public void remove() {
1504                     i.remove();
1505                 }
1506 
1507                 @Override
1508                 public void set(T e) {
1509                     typeCheck(e);
1510                     i.set(e);
1511                 }
1512 
1513                 @Override
1514                 public void add(T e) {
1515                     typeCheck(e);
1516                     i.add(e);
1517                 }
1518             };
1519         }
1520 
1521         @Override
1522         public Iterator&lt;T&gt; iterator() {
1523             return new Iterator&lt;T&gt;() {
1524 
1525                 private final Iterator&lt;T&gt; it = list.iterator();
1526 
1527                 @Override
1528                 public boolean hasNext() {
1529                     return it.hasNext();
1530                 }
1531 
1532                 @Override
1533                 public T next() {
1534                     return it.next();
1535                 }
1536 
1537                 @Override
1538                 public void remove() {
1539                     it.remove();
1540                 }
1541             };
1542         }
1543 
1544         @Override
1545         public boolean add(T e) {
1546             typeCheck(e);
1547             return list.add(e);
1548         }
1549 
1550         @Override
1551         public List&lt;T&gt; subList(int fromIndex, int toIndex) {
1552             return Collections.checkedList(list.subList(fromIndex, toIndex), type);
1553         }
1554 
1555         @Override
1556         @SuppressWarnings(&quot;unchecked&quot;)
1557         public boolean addAll(T... elements) {
1558             try {
1559                 T[] array = (T[]) Array.newInstance(type, elements.length);
1560                 System.arraycopy(elements, 0, array, 0, elements.length);
1561                 return list.addAll(array);
1562             } catch (ArrayStoreException e) {
1563                 throw new ClassCastException();
1564             }
1565         }
1566 
1567         @Override
1568         @SuppressWarnings(&quot;unchecked&quot;)
1569         public boolean setAll(T... elements) {
1570             try {
1571                 T[] array = (T[]) Array.newInstance(type, elements.length);
1572                 System.arraycopy(elements, 0, array, 0, elements.length);
1573                 return list.setAll(array);
1574             } catch (ArrayStoreException e) {
1575                 throw new ClassCastException();
1576             }
1577         }
1578 
1579         @Override
1580         @SuppressWarnings(&quot;unchecked&quot;)
1581         public boolean setAll(Collection&lt;? extends T&gt; col) {
1582             T[] a = null;
1583             try {
1584                 a = col.toArray((T[]) Array.newInstance(type, 0));
1585             } catch (ArrayStoreException e) {
1586                 throw new ClassCastException();
1587             }
1588 
1589             return list.setAll(Arrays.asList(a));
1590         }
1591     }
1592 
1593     private static class EmptyObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1594 
1595         public EmptyObservableSet() {
1596         }
1597 
1598         @Override
1599         public void addListener(InvalidationListener listener) {
1600         }
1601 
1602         @Override
1603         public void removeListener(InvalidationListener listener) {
1604         }
1605 
1606         @Override
1607         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1608         }
1609 
1610         @Override
1611         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1612         }
1613 
1614         @Override
1615         public int size() {
1616             return 0;
1617         }
1618 
1619         @Override
1620         public boolean isEmpty() {
1621             return true;
1622         }
1623 
1624         @Override
1625         public boolean contains(Object obj) {
1626             return false;
1627         }
1628 
1629         @Override
1630         public boolean containsAll(Collection&lt;?&gt; c) {
1631             return c.isEmpty();
1632         }
1633 
1634         @Override
1635         public Object[] toArray() {
1636             return new Object[0];
1637         }
1638 
1639         @Override
1640         public &lt;E&gt; E[] toArray(E[] a) {
1641             if (a.length &gt; 0)
1642                 a[0] = null;
1643             return a;
1644         }
1645 
1646         @Override
1647         public Iterator&lt;E&gt; iterator() {
1648             return new Iterator() {
1649 
1650                 @Override
1651                 public boolean hasNext() {
1652                     return false;
1653                 }
1654 
1655                 @Override
1656                 public Object next() {
1657                     throw new NoSuchElementException();
1658                 }
1659 
1660                 @Override
1661                 public void remove() {
1662                     throw new UnsupportedOperationException();
1663                 }
1664             };
1665         }
1666 
1667     }
1668 
1669     private static class UnmodifiableObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1670 
1671         private final ObservableSet&lt;E&gt; backingSet;
1672         private SetListenerHelper&lt;E&gt; listenerHelper;
1673         private SetChangeListener&lt;E&gt; listener;
1674 
1675         public UnmodifiableObservableSet(ObservableSet&lt;E&gt; backingSet) {
1676             this.backingSet = backingSet;
1677             this.listener = null;
1678         }
1679 
1680         private void initListener() {
1681             if (listener == null) {
1682                 listener = c -&gt; {
1683                     callObservers(new SetAdapterChange&lt;E&gt;(UnmodifiableObservableSet.this, c));
1684                 };
1685                 this.backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1686             }
1687         }
1688 
1689         private void callObservers(SetChangeListener.Change&lt;? extends E&gt; change) {
1690             SetListenerHelper.fireValueChangedEvent(listenerHelper, change);
1691         }
1692 
1693         @Override
1694         public Iterator&lt;E&gt; iterator() {
1695             return new Iterator&lt;E&gt;() {
1696                 private final Iterator&lt;? extends E&gt; i = backingSet.iterator();
1697 
1698                 @Override
1699                 public boolean hasNext() {
1700                     return i.hasNext();
1701                 }
1702 
1703                 @Override
1704                 public E next() {
1705                     return i.next();
1706                 }
1707             };
1708         }
1709 
1710         @Override
1711         public int size() {
1712             return backingSet.size();
1713         }
1714 
1715         @Override
1716         public boolean isEmpty() {
1717             return backingSet.isEmpty();
1718         }
1719 
1720         @Override
1721         public boolean contains(Object o) {
1722             return backingSet.contains(o);
1723         }
1724 
1725         @Override
1726         public void addListener(InvalidationListener listener) {
1727             initListener();
1728             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1729         }
1730 
1731         @Override
1732         public void removeListener(InvalidationListener listener) {
1733             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1734         }
1735 
1736         @Override
1737         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1738             initListener();
1739             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1740         }
1741 
1742         @Override
1743         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1744             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1745         }
1746 
1747         @Override
1748         public boolean add(E e) {
1749             throw new UnsupportedOperationException();
1750         }
1751 
1752         @Override
1753         public boolean remove(Object o) {
1754             throw new UnsupportedOperationException();
1755         }
1756 
1757         @Override
1758         public boolean addAll(Collection&lt;? extends E&gt; c) {
1759             throw new UnsupportedOperationException();
1760         }
1761 
1762         @Override
1763         public boolean retainAll(Collection&lt;?&gt; c) {
1764             throw new UnsupportedOperationException();
1765         }
1766 
1767         @Override
1768         public boolean removeAll(Collection&lt;?&gt; c) {
1769             throw new UnsupportedOperationException();
1770         }
1771 
1772         @Override
1773         public void clear() {
1774             throw new UnsupportedOperationException();
1775         }
1776     }
1777 
1778     private static class SynchronizedSet&lt;E&gt; implements Set&lt;E&gt; {
1779         final Object mutex;
1780         private final Set&lt;E&gt; backingSet;
1781 
1782         SynchronizedSet(Set&lt;E&gt; set, Object mutex) {
1783             this.backingSet = set;
1784             this.mutex = mutex;
1785         }
1786 
1787         SynchronizedSet(Set&lt;E&gt; set) {
1788             this.backingSet = set;
1789             this.mutex = this;
1790         }
1791 
1792         @Override
1793         public int size() {
1794             synchronized(mutex) {
1795                 return backingSet.size();
1796             }
1797         }
1798 
1799         @Override
1800         public boolean isEmpty() {
1801             synchronized(mutex) {
1802                 return backingSet.isEmpty();
1803             }
1804         }
1805 
1806         @Override
1807         public boolean contains(Object o) {
1808             synchronized(mutex) {
1809                 return backingSet.contains(o);
1810             }
1811         }
1812 
1813         @Override
1814         public Iterator&lt;E&gt; iterator() {
1815             return backingSet.iterator();
1816         }
1817 
1818         @Override
1819         public Object[] toArray() {
1820             synchronized(mutex) {
1821                 return backingSet.toArray();
1822             }
1823         }
1824 
1825         @Override
1826         public &lt;E&gt; E[] toArray(E[] a) {
1827             synchronized(mutex) {
1828                 return backingSet.toArray(a);
1829             }
1830         }
1831 
1832         @Override
1833         public boolean add(E e) {
1834             synchronized(mutex) {
1835                 return backingSet.add(e);
1836             }
1837         }
1838 
1839         @Override
1840         public boolean remove(Object o) {
1841             synchronized(mutex) {
1842                 return backingSet.remove(o);
1843             }
1844         }
1845 
1846         @Override
1847         public boolean containsAll(Collection&lt;?&gt; c) {
1848             synchronized(mutex) {
1849                 return backingSet.containsAll(c);
1850             }
1851         }
1852 
1853         @Override
1854         public boolean addAll(Collection&lt;? extends E&gt; c) {
1855             synchronized(mutex) {
1856                 return backingSet.addAll(c);
1857             }
1858         }
1859 
1860         @Override
1861         public boolean retainAll(Collection&lt;?&gt; c) {
1862             synchronized(mutex) {
1863                 return backingSet.retainAll(c);
1864             }
1865         }
1866 
1867         @Override
1868         public boolean removeAll(Collection&lt;?&gt; c) {
1869             synchronized(mutex) {
1870                 return backingSet.removeAll(c);
1871             }
1872         }
1873 
1874         @Override
1875         public void clear() {
1876             synchronized(mutex) {
1877                 backingSet.clear();
1878             }
1879         }
1880 
1881         @Override
1882         public boolean equals(Object o) {
1883             if (o == this) {
1884                 return true;
1885             }
1886             synchronized(mutex) {
1887                 return backingSet.equals(o);
1888             }
1889         }
1890 
1891         @Override
1892         public int hashCode() {
1893             synchronized (mutex) {
1894                 return backingSet.hashCode();
1895             }
1896         }
1897     }
1898 
1899     private static class SynchronizedObservableSet&lt;E&gt; extends SynchronizedSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1900 
1901         private final ObservableSet&lt;E&gt; backingSet;
1902         private SetListenerHelper listenerHelper;
1903         private final SetChangeListener&lt;E&gt; listener;
1904 
1905         SynchronizedObservableSet(ObservableSet&lt;E&gt; set) {
1906             super(set);
1907             backingSet = set;
1908             listener = c -&gt; {
1909                 SetListenerHelper.fireValueChangedEvent(listenerHelper, new SetAdapterChange&lt;E&gt;(SynchronizedObservableSet.this, c));
1910             };
1911             backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1912         }
1913 
1914         @Override
1915         public void addListener(InvalidationListener listener) {
1916             synchronized (mutex) {
1917                 listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1918             }
1919         }
1920 
1921         @Override
1922         public void removeListener(InvalidationListener listener) {
1923             synchronized (mutex) {
1924                 listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1925             }
1926         }
1927         @Override
1928         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1929             synchronized (mutex) {
1930                 listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1931             }
1932         }
1933 
1934         @Override
1935         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1936             synchronized (mutex) {
1937                 listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1938             }
1939         }
1940     }
1941 
1942     private static class CheckedObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1943 
1944         private final ObservableSet&lt;E&gt; backingSet;
1945         private final Class&lt;E&gt; type;
1946         private SetListenerHelper listenerHelper;
1947         private final SetChangeListener&lt;E&gt; listener;
1948 
1949         CheckedObservableSet(ObservableSet&lt;E&gt; set, Class&lt;E&gt; type) {
1950             if (set == null || type == null) {
1951                 throw new NullPointerException();
1952             }
1953             backingSet = set;
1954             this.type = type;
1955             listener = c -&gt; {
1956                 callObservers(new SetAdapterChange&lt;E&gt;(CheckedObservableSet.this, c));
1957             };
1958             backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1959         }
1960 
1961         private void callObservers(SetChangeListener.Change&lt;? extends E&gt; c) {
1962             SetListenerHelper.fireValueChangedEvent(listenerHelper, c);
1963         }
1964 
1965         void typeCheck(Object o) {
1966             if (o != null &amp;&amp; !type.isInstance(o)) {
1967                 throw new ClassCastException(&quot;Attempt to insert &quot;
1968                         + o.getClass() + &quot; element into collection with element type &quot;
1969                         + type);
1970             }
1971         }
1972 
1973         @Override
1974         public void addListener(InvalidationListener listener) {
1975             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1976         }
1977 
1978         @Override
1979         public void removeListener(InvalidationListener listener) {
1980             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1981         }
1982 
1983         @Override
1984         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1985             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1986         }
1987 
1988         @Override
1989         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1990             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1991         }
1992 
1993         @Override
1994         public int size() {
1995             return backingSet.size();
1996         }
1997 
1998         @Override
1999         public boolean isEmpty() {
2000             return backingSet.isEmpty();
2001         }
2002 
2003         @Override
2004         public boolean contains(Object o) {
2005             return backingSet.contains(o);
2006         }
2007 
2008         @Override
2009         public Object[] toArray() {
2010             return backingSet.toArray();
2011         }
2012 
2013         @Override
2014         public &lt;T&gt; T[] toArray(T[] a) {
2015             return backingSet.toArray(a);
2016         }
2017 
2018         @Override
2019         public boolean add(E e) {
2020             typeCheck(e);
2021             return backingSet.add(e);
2022         }
2023 
2024         @Override
2025         public boolean remove(Object o) {
2026             return backingSet.remove(o);
2027         }
2028 
2029         @Override
2030         public boolean containsAll(Collection&lt;?&gt; c) {
2031             return backingSet.containsAll(c);
2032         }
2033 
2034         @Override
2035         @SuppressWarnings(&quot;unchecked&quot;)
2036         public boolean addAll(Collection&lt;? extends E&gt; c) {
2037             E[] a = null;
2038             try {
2039                 a = c.toArray((E[]) Array.newInstance(type, 0));
2040             } catch (ArrayStoreException e) {
2041                 throw new ClassCastException();
2042             }
2043 
2044             return backingSet.addAll(Arrays.asList(a));
2045         }
2046 
2047         @Override
2048         public boolean retainAll(Collection&lt;?&gt; c) {
2049             return backingSet.retainAll(c);
2050         }
2051 
2052         @Override
2053         public boolean removeAll(Collection&lt;?&gt; c) {
2054             return backingSet.removeAll(c);
2055         }
2056 
2057         @Override
2058         public void clear() {
2059             backingSet.clear();
2060         }
2061 
2062         @Override
2063         public boolean equals(Object o) {
2064             return o == this || backingSet.equals(o);
2065         }
2066 
2067         @Override
2068         public int hashCode() {
2069             return backingSet.hashCode();
2070         }
2071 
2072         @Override
2073         public Iterator&lt;E&gt; iterator() {
2074             final Iterator&lt;E&gt; it = backingSet.iterator();
2075 
2076             return new Iterator&lt;E&gt;() {
2077                 @Override
2078                 public boolean hasNext() {
2079                     return it.hasNext();
2080                 }
2081 
2082                 @Override
2083                 public E next() {
2084                     return it.next();
2085                 }
2086 
2087                 @Override
2088                 public void remove() {
2089                     it.remove();
2090                 }
2091             };
2092         }
2093 
2094     }
2095 
2096     private static class EmptyObservableMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2097 
2098         public EmptyObservableMap() {
2099         }
2100 
2101         @Override
2102         public void addListener(InvalidationListener listener) {
2103         }
2104 
2105         @Override
2106         public void removeListener(InvalidationListener listener) {
2107         }
2108 
2109         @Override
2110         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2111         }
2112 
2113         @Override
2114         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2115         }
2116 
2117         @Override
2118         public int size() {
2119             return 0;
2120         }
2121 
2122         @Override
2123         public boolean isEmpty() {
2124             return true;
2125         }
2126 
2127         @Override
2128         public boolean containsKey(Object key) {
2129             return false;
2130         }
2131 
2132         @Override
2133         public boolean containsValue(Object value) {
2134             return false;
2135         }
2136 
2137         @Override
2138         public V get(Object key) {
2139             return null;
2140         }
2141 
2142         @Override
2143         public Set&lt;K&gt; keySet() {
2144             return emptyObservableSet();
2145         }
2146 
2147         @Override
2148         public Collection&lt;V&gt; values() {
2149             return emptyObservableSet();
2150         }
2151 
2152         @Override
2153         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
2154             return emptyObservableSet();
2155         }
2156 
2157         @Override
2158         public boolean equals(Object o) {
2159             return (o instanceof Map) &amp;&amp; ((Map&lt;?,?&gt;)o).isEmpty();
2160         }
2161 
2162         @Override
2163         public int hashCode() {
2164             return 0;
2165         }
2166     }
2167 
2168     private static class CheckedObservableMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2169 
2170         private final ObservableMap&lt;K, V&gt; backingMap;
2171         private final Class&lt;K&gt; keyType;
2172         private final Class&lt;V&gt; valueType;
2173         private MapListenerHelper listenerHelper;
2174         private final MapChangeListener&lt;K, V&gt; listener;
2175 
2176         CheckedObservableMap(ObservableMap&lt;K, V&gt; map, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
2177             backingMap = map;
2178             this.keyType = keyType;
2179             this.valueType = valueType;
2180             listener = c -&gt; {
2181                 callObservers(new MapAdapterChange&lt;K, V&gt;(CheckedObservableMap.this, c));
2182             };
2183             backingMap.addListener(new WeakMapChangeListener&lt;K, V&gt;(listener));
2184         }
2185 
2186         private void callObservers(MapChangeListener.Change&lt;? extends K, ? extends V&gt; c) {
2187             MapListenerHelper.fireValueChangedEvent(listenerHelper, c);
2188         }
2189 
2190         void typeCheck(Object key, Object value) {
2191             if (key != null &amp;&amp; !keyType.isInstance(key)) {
2192                 throw new ClassCastException(&quot;Attempt to insert &quot;
2193                         + key.getClass() + &quot; key into map with key type &quot;
2194                         + keyType);
2195             }
2196 
2197             if (value != null &amp;&amp; !valueType.isInstance(value)) {
2198                 throw new ClassCastException(&quot;Attempt to insert &quot;
2199                         + value.getClass() + &quot; value into map with value type &quot;
2200                         + valueType);
2201             }
2202         }
2203 
2204         @Override
2205         public void addListener(InvalidationListener listener) {
2206             listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2207         }
2208 
2209         @Override
2210         public void removeListener(InvalidationListener listener) {
2211             listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2212         }
2213 
2214         @Override
2215         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2216             listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2217         }
2218 
2219         @Override
2220         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2221             listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2222         }
2223 
2224         @Override
2225         public int size() {
2226             return backingMap.size();
2227         }
2228 
2229         @Override
2230         public boolean isEmpty() {
2231             return backingMap.isEmpty();
2232         }
2233 
2234         @Override
2235         public boolean containsKey(Object key) {
2236             return backingMap.containsKey(key);
2237         }
2238 
2239         @Override
2240         public boolean containsValue(Object value) {
2241             return backingMap.containsValue(value);
2242         }
2243 
2244         @Override
2245         public V get(Object key) {
2246             return backingMap.get(key);
2247         }
2248 
2249         @Override
2250         public V put(K key, V value) {
2251             typeCheck(key, value);
2252             return backingMap.put(key, value);
2253         }
2254 
2255         @Override
2256         public V remove(Object key) {
2257             return backingMap.remove(key);
2258         }
2259 
2260         @Override
2261         @SuppressWarnings(&quot;unchecked&quot;)
2262         public void putAll(Map t) {
2263             // Satisfy the following goals:
2264             // - good diagnostics in case of type mismatch
2265             // - all-or-nothing semantics
2266             // - protection from malicious t
2267             // - correct behavior if t is a concurrent map
2268             Object[] entries = t.entrySet().toArray();
2269             List&lt;Map.Entry&lt;K,V&gt;&gt; checked =
2270                 new ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;(entries.length);
2271             for (Object o : entries) {
2272                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
2273                 Object k = e.getKey();
2274                 Object v = e.getValue();
2275                 typeCheck(k, v);
2276                 checked.add(
2277                     new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;((K) k, (V) v));
2278             }
2279             for (Map.Entry&lt;K,V&gt; e : checked)
2280                 backingMap.put(e.getKey(), e.getValue());
2281         }
2282 
2283         @Override
2284         public void clear() {
2285             backingMap.clear();
2286         }
2287 
2288         @Override
2289         public Set&lt;K&gt; keySet() {
2290             return backingMap.keySet();
2291         }
2292 
2293         @Override
2294         public Collection&lt;V&gt; values() {
2295             return backingMap.values();
2296         }
2297 
2298         private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;
2299 
2300         @Override
2301         public Set entrySet() {
2302             if (entrySet==null)
2303                 entrySet = new CheckedEntrySet&lt;K,V&gt;(backingMap.entrySet(), valueType);
2304             return entrySet;
2305         }
2306 
2307         @Override
2308         public boolean equals(Object o) {
2309             return o == this || backingMap.equals(o);
2310         }
2311 
2312         @Override
2313         public int hashCode() {
2314             return backingMap.hashCode();
2315         }
2316 
2317         static class CheckedEntrySet&lt;K,V&gt; implements Set&lt;Map.Entry&lt;K,V&gt;&gt; {
2318             private final Set&lt;Map.Entry&lt;K,V&gt;&gt; s;
2319             private final Class&lt;V&gt; valueType;
2320 
2321             CheckedEntrySet(Set&lt;Map.Entry&lt;K, V&gt;&gt; s, Class&lt;V&gt; valueType) {
2322                 this.s = s;
2323                 this.valueType = valueType;
2324             }
2325 
2326             @Override
2327             public int size() {
2328                 return s.size();
2329             }
2330 
2331             @Override
2332             public boolean isEmpty() {
2333                 return s.isEmpty();
2334             }
2335 
2336             @Override
2337             public String toString() {
2338                 return s.toString();
2339             }
2340 
2341             @Override
2342             public int hashCode() {
2343                 return s.hashCode();
2344             }
2345 
2346             @Override
2347             public void clear() {
2348                 s.clear();
2349             }
2350 
2351             @Override
2352             public boolean add(Map.Entry&lt;K, V&gt; e) {
2353                 throw new UnsupportedOperationException();
2354             }
2355 
2356             @Override
2357             public boolean addAll(Collection&lt;? extends Map.Entry&lt;K, V&gt;&gt; coll) {
2358                 throw new UnsupportedOperationException();
2359             }
2360 
2361             @Override
2362             public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
2363                 final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; i = s.iterator();
2364                 final Class&lt;V&gt; valueType = this.valueType;
2365 
2366                 return new Iterator&lt;Map.Entry&lt;K,V&gt;&gt;() {
2367                     @Override
2368                     public boolean hasNext() {
2369                         return i.hasNext();
2370                     }
2371 
2372                     @Override
2373                     public void remove() {
2374                         i.remove();
2375                     }
2376 
2377                     @Override
2378                     public Map.Entry&lt;K,V&gt; next() {
2379                         return checkedEntry(i.next(), valueType);
2380                     }
2381                 };
2382             }
2383 
2384             @Override
2385             @SuppressWarnings(&quot;unchecked&quot;)
2386             public Object[] toArray() {
2387                 Object[] source = s.toArray();
2388 
2389                 /*
2390                  * Ensure that we don&#39;t get an ArrayStoreException even if
2391                  * s.toArray returns an array of something other than Object
2392                  */
2393                 Object[] dest = (CheckedEntry.class.isInstance(
2394                     source.getClass().getComponentType()) ? source :
2395                                  new Object[source.length]);
2396 
2397                 for (int i = 0; i &lt; source.length; i++)
2398                     dest[i] = checkedEntry((Map.Entry&lt;K,V&gt;)source[i],
2399                                            valueType);
2400                 return dest;
2401             }
2402 
2403             @Override
2404             @SuppressWarnings(&quot;unchecked&quot;)
2405             public &lt;T&gt; T[] toArray(T[] a) {
2406                 // We don&#39;t pass a to s.toArray, to avoid window of
2407                 // vulnerability wherein an unscrupulous multithreaded client
2408                 // could get his hands on raw (unwrapped) Entries from s.
2409                 T[] arr = s.toArray(a.length==0 ? a : Arrays.copyOf(a, 0));
2410 
2411                 for (int i=0; i&lt;arr.length; i++)
2412                     arr[i] = (T) checkedEntry((Map.Entry&lt;K,V&gt;)arr[i],
2413                                               valueType);
2414                 if (arr.length &gt; a.length)
2415                     return arr;
2416 
2417                 System.arraycopy(arr, 0, a, 0, arr.length);
2418                 if (a.length &gt; arr.length)
2419                     a[arr.length] = null;
2420                 return a;
2421             }
2422 
2423             /**
2424              * This method is overridden to protect the backing set against
2425              * an object with a nefarious equals function that senses
2426              * that the equality-candidate is Map.Entry and calls its
2427              * setValue method.
2428              */
2429             @Override
2430             public boolean contains(Object o) {
2431                 if (!(o instanceof Map.Entry))
2432                     return false;
2433                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
2434                 return s.contains(
2435                     (e instanceof CheckedEntry) ? e : checkedEntry(e, valueType));
2436             }
2437 
2438             /**
2439              * The bulk collection methods are overridden to protect
2440              * against an unscrupulous collection whose contains(Object o)
2441              * method senses when o is a Map.Entry, and calls o.setValue.
2442              */
2443             @Override
2444             public boolean containsAll(Collection&lt;?&gt; c) {
2445                 for (Object o : c)
2446                     if (!contains(o)) // Invokes safe contains() above
2447                         return false;
2448                 return true;
2449             }
2450 
2451             @Override
2452             public boolean remove(Object o) {
2453                 if (!(o instanceof Map.Entry))
2454                     return false;
2455                 return s.remove(new AbstractMap.SimpleImmutableEntry
2456                                 &lt;Object, Object&gt;((Map.Entry&lt;?,?&gt;)o));
2457             }
2458 
2459             @Override
2460             public boolean removeAll(Collection&lt;?&gt; c) {
2461                 return batchRemove(c, false);
2462             }
2463 
2464             @Override
2465             public boolean retainAll(Collection&lt;?&gt; c) {
2466                 return batchRemove(c, true);
2467             }
2468 
2469             private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
2470                 boolean modified = false;
2471                 Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = iterator();
2472                 while (it.hasNext()) {
2473                     if (c.contains(it.next()) != complement) {
2474                         it.remove();
2475                         modified = true;
2476                     }
2477                 }
2478                 return modified;
2479             }
2480 
2481             @Override
2482             public boolean equals(Object o) {
2483                 if (o == this)
2484                     return true;
2485                 if (!(o instanceof Set))
2486                     return false;
2487                 Set&lt;?&gt; that = (Set&lt;?&gt;) o;
2488                 return that.size() == s.size()
2489                     &amp;&amp; containsAll(that); // Invokes safe containsAll() above
2490             }
2491 
2492             static &lt;K,V,T&gt; CheckedEntry&lt;K,V,T&gt; checkedEntry(Map.Entry&lt;K,V&gt; e,
2493                                                             Class&lt;T&gt; valueType) {
2494                 return new CheckedEntry&lt;K,V,T&gt;(e, valueType);
2495             }
2496 
2497             /**
2498              * This &quot;wrapper class&quot; serves two purposes: it prevents
2499              * the client from modifying the backing Map, by short-circuiting
2500              * the setValue method, and it protects the backing Map against
2501              * an ill-behaved Map.Entry that attempts to modify another
2502              * Map.Entry when asked to perform an equality check.
2503              */
2504             private static class CheckedEntry&lt;K,V,T&gt; implements Map.Entry&lt;K,V&gt; {
2505                 private final Map.Entry&lt;K, V&gt; e;
2506                 private final Class&lt;T&gt; valueType;
2507 
2508                 CheckedEntry(Map.Entry&lt;K, V&gt; e, Class&lt;T&gt; valueType) {
2509                     this.e = e;
2510                     this.valueType = valueType;
2511                 }
2512 
2513                 @Override
2514                 public K getKey() {
2515                     return e.getKey();
2516                 }
2517 
2518                 @Override
2519                 public V getValue() {
2520                     return e.getValue();
2521                 }
2522 
2523                 @Override
2524                 public int hashCode() {
2525                     return e.hashCode();
2526                 }
2527 
2528                 @Override
2529                 public String toString() {
2530                     return e.toString();
2531                 }
2532 
2533                 @Override
2534                 public V setValue(V value) {
2535                     if (value != null &amp;&amp; !valueType.isInstance(value))
2536                         throw new ClassCastException(badValueMsg(value));
2537                     return e.setValue(value);
2538                 }
2539 
2540                 private String badValueMsg(Object value) {
2541                     return &quot;Attempt to insert &quot; + value.getClass() +
2542                         &quot; value into map with value type &quot; + valueType;
2543                 }
2544 
2545                 @Override
2546                 public boolean equals(Object o) {
2547                     if (o == this)
2548                         return true;
2549                     if (!(o instanceof Map.Entry))
2550                         return false;
2551                     return e.equals(new AbstractMap.SimpleImmutableEntry
2552                                     &lt;Object, Object&gt;((Map.Entry&lt;?,?&gt;)o));
2553                 }
2554             }
2555         }
2556 
2557     }
2558 
2559     private static class SynchronizedMap&lt;K, V&gt; implements Map&lt;K, V&gt; {
2560         final Object mutex;
2561         private final Map&lt;K, V&gt; backingMap;
2562 
2563         SynchronizedMap(Map&lt;K, V&gt; map) {
2564             backingMap = map;
2565             this.mutex = this;
2566         }
2567 
2568         @Override
2569         public int size() {
2570             synchronized (mutex) {
2571                 return backingMap.size();
2572             }
2573         }
2574 
2575         @Override
2576         public boolean isEmpty() {
2577             synchronized (mutex) {
2578                 return backingMap.isEmpty();
2579             }
2580         }
2581 
2582         @Override
2583         public boolean containsKey(Object key) {
2584             synchronized (mutex) {
2585                 return backingMap.containsKey(key);
2586             }
2587         }
2588 
2589         @Override
2590         public boolean containsValue(Object value) {
2591             synchronized (mutex) {
2592                 return backingMap.containsValue(value);
2593             }
2594         }
2595 
2596         @Override
2597         public V get(Object key) {
2598             synchronized (mutex) {
2599                 return backingMap.get(key);
2600             }
2601         }
2602 
2603         @Override
2604         public V put(K key, V value) {
2605             synchronized (mutex) {
2606                 return backingMap.put(key, value);
2607             }
2608         }
2609 
2610         @Override
2611         public V remove(Object key) {
2612             synchronized (mutex) {
2613                 return backingMap.remove(key);
2614             }
2615         }
2616 
2617         @Override
2618         public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
2619             synchronized (mutex) {
2620                 backingMap.putAll(m);
2621             }
2622         }
2623 
2624         @Override
2625         public void clear() {
2626             synchronized (mutex) {
2627                 backingMap.clear();
2628             }
2629         }
2630 
2631         private transient Set&lt;K&gt; keySet = null;
2632         private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;
2633         private transient Collection&lt;V&gt; values = null;
2634 
2635         @Override
2636         public Set&lt;K&gt; keySet() {
2637             synchronized(mutex) {
2638                 if (keySet==null)
2639                     keySet = new SynchronizedSet&lt;K&gt;(backingMap.keySet(), mutex);
2640                 return keySet;
2641             }
2642         }
2643 
2644         @Override
2645         public Collection&lt;V&gt; values() {
2646             synchronized(mutex) {
2647                 if (values==null)
2648                     values = new SynchronizedCollection&lt;V&gt;(backingMap.values(), mutex);
2649                 return values;
2650             }
2651         }
2652 
2653         @Override
2654         public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
2655             synchronized(mutex) {
2656                 if (entrySet==null)
2657                     entrySet = new SynchronizedSet&lt;Map.Entry&lt;K,V&gt;&gt;(backingMap.entrySet(), mutex);
2658                 return entrySet;
2659             }
2660         }
2661 
2662         @Override
2663         public boolean equals(Object o) {
2664             if (o == this) {
2665                 return true;
2666             }
2667             synchronized(mutex) {
2668                 return backingMap.equals(o);
2669             }
2670         }
2671 
2672         @Override
2673         public int hashCode() {
2674             synchronized(mutex) {
2675                 return backingMap.hashCode();
2676             }
2677         }
2678 
2679     }
2680 
2681     private static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt; {
2682 
2683         private final Collection&lt;E&gt; backingCollection;
2684         final Object mutex;
2685 
2686         SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) {
2687             backingCollection = c;
2688             this.mutex = mutex;
2689         }
2690 
2691         SynchronizedCollection(Collection&lt;E&gt; c) {
2692             this(c, new Object());
2693         }
2694 
2695         @Override
2696         public int size() {
2697             synchronized (mutex) {
2698                 return backingCollection.size();
2699             }
2700         }
2701 
2702         @Override
2703         public boolean isEmpty() {
2704             synchronized (mutex) {
2705                 return backingCollection.isEmpty();
2706             }
2707         }
2708 
2709         @Override
2710         public boolean contains(Object o) {
2711             synchronized (mutex) {
2712                 return backingCollection.contains(o);
2713             }
2714         }
2715 
2716         @Override
2717         public Iterator&lt;E&gt; iterator() {
2718             return backingCollection.iterator();
2719         }
2720 
2721         @Override
2722         public Object[] toArray() {
2723             synchronized (mutex) {
2724                 return backingCollection.toArray();
2725             }
2726         }
2727 
2728         @Override
2729         public &lt;T&gt; T[] toArray(T[] a) {
2730             synchronized (mutex) {
2731                 return backingCollection.toArray(a);
2732             }
2733         }
2734 
2735         @Override
2736         public boolean add(E e) {
2737             synchronized (mutex) {
2738                 return backingCollection.add(e);
2739             }
2740         }
2741 
2742         @Override
2743         public boolean remove(Object o) {
2744             synchronized (mutex) {
2745                 return backingCollection.remove(o);
2746             }
2747         }
2748 
2749         @Override
2750         public boolean containsAll(Collection&lt;?&gt; c) {
2751             synchronized (mutex) {
2752                 return backingCollection.containsAll(c);
2753             }
2754         }
2755 
2756         @Override
2757         public boolean addAll(Collection&lt;? extends E&gt; c) {
2758             synchronized (mutex) {
2759                 return backingCollection.addAll(c);
2760             }
2761         }
2762 
2763         @Override
2764         public boolean removeAll(Collection&lt;?&gt; c) {
2765             synchronized (mutex) {
2766                 return backingCollection.removeAll(c);
2767             }
2768         }
2769 
2770         @Override
2771         public boolean retainAll(Collection&lt;?&gt; c) {
2772             synchronized (mutex) {
2773                 return backingCollection.retainAll(c);
2774             }
2775         }
2776 
2777         @Override
2778         public void clear() {
2779             synchronized (mutex) {
2780                 backingCollection.clear();
2781             }
2782         }
2783     }
2784 
2785     private static class SynchronizedObservableMap&lt;K, V&gt; extends SynchronizedMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2786 
2787         private final ObservableMap&lt;K, V&gt; backingMap;
2788         private MapListenerHelper listenerHelper;
2789         private final MapChangeListener&lt;K, V&gt; listener;
2790 
2791         SynchronizedObservableMap(ObservableMap&lt;K, V&gt; map) {
2792             super(map);
2793             backingMap = map;
2794             listener = c -&gt; {
2795                 MapListenerHelper.fireValueChangedEvent(listenerHelper, new MapAdapterChange&lt;K, V&gt;(SynchronizedObservableMap.this, c));
2796             };
2797             backingMap.addListener(new WeakMapChangeListener&lt;K, V&gt;(listener));
2798         }
2799 
2800         @Override
2801         public void addListener(InvalidationListener listener) {
2802             synchronized (mutex) {
2803                 listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2804             }
2805         }
2806 
2807         @Override
2808         public void removeListener(InvalidationListener listener) {
2809             synchronized (mutex) {
2810                 listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2811             }
2812         }
2813 
2814         @Override
2815         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2816             synchronized (mutex) {
2817                 listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2818             }
2819         }
2820 
2821         @Override
2822         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2823             synchronized (mutex) {
2824                 listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2825             }
2826         }
2827 
2828     }
2829 
2830 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>