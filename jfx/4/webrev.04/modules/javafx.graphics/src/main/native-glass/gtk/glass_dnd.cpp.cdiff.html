<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="GlassApplication.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_dnd.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 139,10 ***</span>
<span class="line-new-header">--- 139,16 ---</span>
      gint dx, dy;
  } enter_ctx = {NULL, FALSE, NULL, 0, 0};
  
  gboolean is_dnd_owner = FALSE;
  
<span class="line-added">+ GtkWidget *drag_widget = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ gboolean is_in_drag() {</span>
<span class="line-added">+     return drag_widget != NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static void reset_enter_ctx() {
      if (enter_ctx.mimes != NULL) {
          mainEnv-&gt;DeleteGlobalRef(enter_ctx.mimes);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 509,233 ***</span>
  
      return ret;
  }
  
  /************************* SOURCE *********************************************/
<span class="line-modified">! static GdkWindow *dnd_window = NULL;</span>
  static jint dnd_performed_action;
  
<span class="line-removed">- const char * const SOURCE_DND_CONTEXT = &quot;fx-dnd-context&quot;;</span>
  const char * const SOURCE_DND_DATA = &quot;fx-dnd-data&quot;;
<span class="line-removed">- const char * const SOURCE_DND_ACTIONS = &quot;fx-dnd-actions&quot;;</span>
  
<span class="line-modified">! static GdkWindow* get_dnd_window()</span>
  {
<span class="line-removed">-     if (dnd_window == NULL) {</span>
<span class="line-removed">-         GdkWindowAttr attr;</span>
<span class="line-removed">-         memset(&amp;attr, 0, sizeof (GdkWindowAttr));</span>
<span class="line-removed">-         attr.override_redirect = TRUE;</span>
<span class="line-removed">-         attr.window_type = GDK_WINDOW_TEMP;</span>
<span class="line-removed">-         attr.type_hint = GDK_WINDOW_TYPE_HINT_UTILITY;</span>
<span class="line-removed">-         attr.wclass = GDK_INPUT_OUTPUT;</span>
<span class="line-removed">-         attr.event_mask = GDK_ALL_EVENTS_MASK;</span>
<span class="line-removed">-         dnd_window = gdk_window_new(NULL, &amp;attr, GDK_WA_NOREDIR | GDK_WA_TYPE_HINT);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         gdk_window_move(dnd_window, -99, -99);</span>
<span class="line-removed">-         gdk_window_resize(dnd_window, 1, 1);</span>
<span class="line-removed">-         gdk_window_show(dnd_window);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return dnd_window;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void dnd_set_performed_action(jint performed_action) {</span>
      dnd_performed_action = performed_action;
  }
  
<span class="line-modified">! static jint dnd_get_performed_action() {</span>
      return dnd_performed_action;
  }
  
<span class="line-modified">! static void dnd_pointer_grab(GdkEvent *event, GdkCursor *cursor)</span>
  {
<span class="line-modified">!     glass_gdk_master_pointer_grab(event, dnd_window, cursor);</span>
<span class="line-modified">! }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static GdkDragContext *get_drag_context() {</span>
<span class="line-removed">-     GdkDragContext *ctx;</span>
<span class="line-removed">-     ctx = (GdkDragContext*)g_object_get_data(G_OBJECT(dnd_window), SOURCE_DND_CONTEXT);</span>
<span class="line-removed">-     return ctx;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static gboolean dnd_finish_callback(gpointer) {</span>
<span class="line-removed">-     if (dnd_window) {</span>
<span class="line-removed">-         dnd_set_performed_action(</span>
<span class="line-removed">-                 translate_gdk_action_to_glass(</span>
<span class="line-removed">-                     gdk_drag_context_get_selected_action(</span>
<span class="line-removed">-                         get_drag_context())));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         gdk_window_destroy(dnd_window);</span>
<span class="line-removed">-         dnd_window = NULL;</span>
<span class="line-removed">-         DragView::reset_drag_view();</span>
      }
<span class="line-removed">- </span>
<span class="line-removed">-     return FALSE;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef GLASS_GTK3</span>
<span class="line-removed">- static void dnd_finished_callback(GdkDragContext *ctx, gpointer user_data) {</span>
<span class="line-removed">-     dnd_finish_callback(user_data);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static gboolean dnd_update_drag_view(gpointer) {</span>
<span class="line-removed">-     gint x, y;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     gdk_device_get_position(gdk_drag_context_get_device(get_drag_context()),</span>
<span class="line-removed">-                                 NULL, &amp;x, &amp;y);</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-     DragView::move(x, y);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return FALSE;</span>
  }
<span class="line-removed">- #endif</span>
  
<span class="line-modified">! gboolean is_in_drag()</span>
  {
<span class="line-modified">!     return dnd_window != NULL;</span>
  }
  
<span class="line-modified">! static void determine_actions(guint state, GdkDragAction *action, GdkDragAction *possible_actions)</span>
  {
<span class="line-modified">!     GdkDragAction suggested = static_cast&lt;GdkDragAction&gt;(GPOINTER_TO_INT(g_object_get_data(G_OBJECT(dnd_window), SOURCE_DND_ACTIONS)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK)) {</span>
<span class="line-removed">-         if ((state &amp; GDK_CONTROL_MASK) &amp;&amp; (state &amp; GDK_SHIFT_MASK) &amp;&amp; (suggested &amp; GDK_ACTION_LINK)) {</span>
<span class="line-removed">-             *action = *possible_actions = GDK_ACTION_LINK;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         } else if ((state &amp; GDK_SHIFT_MASK) &amp;&amp; (suggested &amp; GDK_ACTION_MOVE)) {</span>
<span class="line-removed">-             *action = *possible_actions = GDK_ACTION_MOVE;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         } else if (suggested &amp; GDK_ACTION_COPY){</span>
<span class="line-removed">-             *action = *possible_actions = GDK_ACTION_COPY;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     *possible_actions = suggested;</span>
  
<span class="line-modified">!     if (suggested &amp; GDK_ACTION_COPY) {</span>
<span class="line-modified">!         *action = GDK_ACTION_COPY;</span>
<span class="line-modified">!     } else if (suggested &amp; GDK_ACTION_MOVE) {</span>
<span class="line-modified">!         *action = GDK_ACTION_MOVE;</span>
<span class="line-modified">!     } else if (suggested &amp; GDK_ACTION_LINK) {</span>
<span class="line-modified">!         *action = GDK_ACTION_LINK;</span>
      } else {
<span class="line-modified">!         *action = static_cast&lt;GdkDragAction&gt;(0);</span>
      }
  }
  
<span class="line-modified">! static jobject dnd_source_get_data(const char *key)</span>
  {
<span class="line-modified">!     jobject data = (jobject)g_object_get_data(G_OBJECT(dnd_window), SOURCE_DND_DATA);</span>
<span class="line-removed">-     jstring string = mainEnv-&gt;NewStringUTF(key);</span>
<span class="line-removed">-     EXCEPTION_OCCURED(mainEnv);</span>
<span class="line-removed">-     jobject result = mainEnv-&gt;CallObjectMethod(data, jMapGet, string, NULL);</span>
  
<span class="line-modified">!     return (EXCEPTION_OCCURED(mainEnv)) ? NULL : result;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static gboolean dnd_source_set_utf8_string(GdkWindow *requestor, GdkAtom property)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     jstring string = (jstring)dnd_source_get_data(&quot;text/plain&quot;);</span>
<span class="line-removed">-     if (!string) {</span>
<span class="line-removed">-         return FALSE;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     const char *cstring = mainEnv-&gt;GetStringUTFChars(string, NULL);</span>
<span class="line-removed">-     if (!cstring) {</span>
<span class="line-removed">-         return FALSE;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     gint size = strlen(cstring);</span>
  
<span class="line-modified">!     gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,</span>
<span class="line-removed">-             8, GDK_PROP_MODE_REPLACE, (guchar *)cstring, size);</span>
  
<span class="line-modified">!     mainEnv-&gt;ReleaseStringUTFChars(string, cstring);</span>
<span class="line-modified">!     return TRUE;</span>
  }
  
<span class="line-modified">! static gboolean dnd_source_set_string(GdkWindow *requestor, GdkAtom property)</span>
  {
<span class="line-modified">!     jstring string = (jstring)dnd_source_get_data(&quot;text/plain&quot;);</span>
      if (!string) {
          return FALSE;
      }
  
<span class="line-removed">-     gboolean is_data_set = FALSE;</span>
      const char *cstring = mainEnv-&gt;GetStringUTFChars(string, NULL);
      if (cstring) {
<span class="line-modified">!         gchar *res_str = g_convert((gchar *)cstring, -1, &quot;ISO-8859-1&quot;, &quot;UTF-8&quot;, NULL, NULL, NULL);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (res_str) {</span>
<span class="line-modified">!             gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,</span>
<span class="line-modified">!                     8, GDK_PROP_MODE_REPLACE, (guchar *)res_str, strlen(res_str));</span>
<span class="line-modified">!             g_free(res_str);</span>
<span class="line-modified">!             is_data_set = TRUE;</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         mainEnv-&gt;ReleaseStringUTFChars(string, cstring);</span>
      }
      return is_data_set;
  }
  
<span class="line-modified">! static gboolean dnd_source_set_image(GdkWindow *requestor, GdkAtom property, GdkAtom target)</span>
  {
<span class="line-modified">!     jobject pixels = dnd_source_get_data(&quot;application/x-java-rawimage&quot;);</span>
      if (!pixels) {
          return FALSE;
      }
  
      gchar *buffer;
      gsize size;
      const char * type;
      GdkPixbuf *pixbuf = NULL;
<span class="line-modified">!     gboolean result = FALSE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (target == TARGET_MIME_PNG_ATOM) {</span>
<span class="line-removed">-         type = &quot;png&quot;;</span>
<span class="line-removed">-     } else if (target == TARGET_MIME_JPEG_ATOM) {</span>
<span class="line-removed">-         type = &quot;jpeg&quot;;</span>
<span class="line-removed">-     } else if (target == TARGET_MIME_TIFF_ATOM) {</span>
<span class="line-removed">-         type = &quot;tiff&quot;;</span>
<span class="line-removed">-     } else if (target == TARGET_MIME_BMP_ATOM) {</span>
<span class="line-removed">-         type = &quot;bmp&quot;;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         return FALSE;</span>
<span class="line-removed">-     }</span>
  
      mainEnv-&gt;CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&amp;pixbuf));
  
<span class="line-modified">!     if (!EXCEPTION_OCCURED(mainEnv)</span>
<span class="line-modified">!             &amp;&amp; gdk_pixbuf_save_to_buffer(pixbuf, &amp;buffer, &amp;size, type, NULL, NULL)) {</span>
<span class="line-removed">-         gdk_property_change(requestor, property, target,</span>
<span class="line-removed">-                 8, GDK_PROP_MODE_REPLACE, (guchar *)buffer, size);</span>
<span class="line-removed">-         result = TRUE;</span>
      }
      g_object_unref(pixbuf);
<span class="line-modified">!     return result;</span>
  }
  
<span class="line-modified">! static gboolean dnd_source_set_uri_list(GdkWindow *requestor, GdkAtom property)</span>
  {
      const gchar* url = NULL;
      jstring jurl = NULL;
  
      jobjectArray files_array = NULL;
      gsize files_cnt = 0;
  
<span class="line-modified">!     if (jurl = (jstring) dnd_source_get_data(&quot;text/uri-list&quot;)) {</span>
          url = mainEnv-&gt;GetStringUTFChars(jurl, NULL);
      }
  
<span class="line-modified">!     if (files_array = (jobjectArray) dnd_source_get_data(&quot;application/x-java-file-list&quot;)) {</span>
          files_cnt = mainEnv-&gt;GetArrayLength(files_array);
      }
      if (!url &amp;&amp; !files_cnt) {
          return FALSE;
      }
  
      GString* res = g_string_new (NULL); //http://www.ietf.org/rfc/rfc2483.txt
  
      if (files_cnt &gt; 0) {
          for (gsize i = 0; i &lt; files_cnt; ++i) {
              jstring string = (jstring) mainEnv-&gt;GetObjectArrayElement(files_array, i);
<span class="line-new-header">--- 515,169 ---</span>
  
      return ret;
  }
  
  /************************* SOURCE *********************************************/
<span class="line-modified">! </span>
  static jint dnd_performed_action;
  
  const char * const SOURCE_DND_DATA = &quot;fx-dnd-data&quot;;
  
<span class="line-modified">! static void dnd_set_performed_action(jint performed_action)</span>
  {
      dnd_performed_action = performed_action;
  }
  
<span class="line-modified">! static jint dnd_get_performed_action()</span>
<span class="line-added">+ {</span>
      return dnd_performed_action;
  }
  
<span class="line-modified">! static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer)</span>
  {
<span class="line-modified">!     if (pixels != NULL) {</span>
<span class="line-modified">!         g_free(pixels);</span>
      }
  }
  
<span class="line-modified">! static jobject dnd_source_get_data(GtkWidget *widget, const char *key)</span>
  {
<span class="line-modified">!     jobject data = (jobject)g_object_get_data(G_OBJECT(widget), SOURCE_DND_DATA);</span>
<span class="line-added">+     jstring string = mainEnv-&gt;NewStringUTF(key);</span>
<span class="line-added">+     EXCEPTION_OCCURED(mainEnv);</span>
<span class="line-added">+     jobject result = mainEnv-&gt;CallObjectMethod(data, jMapGet, string, NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return (EXCEPTION_OCCURED(mainEnv)) ? NULL : result;</span>
  }
  
<span class="line-modified">! static void add_gtk_target_from_jstring(JNIEnv *env, GtkTargetList **list, jstring string, guint flags)</span>
  {
<span class="line-modified">!     const char *gstring = env-&gt;GetStringUTFChars(string, NULL);</span>
  
<span class="line-modified">!     if (g_strcmp0(gstring, &quot;text/plain&quot;) == 0) {</span>
<span class="line-modified">!         gtk_target_list_add(*list, TARGET_UTF8_STRING_ATOM, flags, 0);</span>
<span class="line-modified">!         gtk_target_list_add(*list, TARGET_MIME_TEXT_PLAIN_ATOM, flags, 0);</span>
<span class="line-modified">!         gtk_target_list_add(*list, TARGET_STRING_ATOM, flags, 0);</span>
<span class="line-modified">!         //gtk_target_list_add(*list, TARGET_COMPOUND_TEXT_ATOM, flags, ??);</span>
<span class="line-modified">!     } else if (g_strcmp0(gstring, &quot;application/x-java-rawimage&quot;) == 0) {</span>
<span class="line-added">+         gtk_target_list_add(*list, TARGET_MIME_PNG_ATOM, flags, 0);</span>
<span class="line-added">+         gtk_target_list_add(*list, TARGET_MIME_JPEG_ATOM, flags, 0);</span>
<span class="line-added">+         gtk_target_list_add(*list, TARGET_MIME_TIFF_ATOM, flags, 0);</span>
<span class="line-added">+         gtk_target_list_add(*list, TARGET_MIME_BMP_ATOM, flags, 0);</span>
<span class="line-added">+     } else if (g_strcmp0(gstring, &quot;application/x-java-file-list&quot;) == 0) {</span>
<span class="line-added">+         gtk_target_list_add(*list, TARGET_MIME_URI_LIST_ATOM, flags, 0);</span>
<span class="line-added">+     } else if (g_strcmp0(gstring, &quot;application/x-java-drag-image&quot;) == 0</span>
<span class="line-added">+         || g_strcmp0(gstring, &quot;application/x-java-drag-image-offset&quot;) == 0) {</span>
<span class="line-added">+         // do nothing - those are DragView information</span>
      } else {
<span class="line-modified">!         GdkAtom atom = gdk_atom_intern(gstring, FALSE);</span>
<span class="line-added">+         gtk_target_list_add(*list, atom, flags, 0);</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     env-&gt;ReleaseStringUTFChars(string, gstring);</span>
  }
  
<span class="line-modified">! static GtkTargetList* data_to_gtk_target_list(JNIEnv *env, jobject data)</span>
  {
<span class="line-modified">!     guint flags = GTK_TARGET_OTHER_APP | GTK_TARGET_SAME_APP;</span>
  
<span class="line-modified">!     jobject keys;</span>
<span class="line-modified">!     jobject keysIterator;</span>
<span class="line-added">+     jstring next;</span>
  
<span class="line-modified">!     GtkTargetList *tlist = gtk_target_list_new (NULL, 0);</span>
  
<span class="line-modified">!     init_target_atoms();</span>
  
<span class="line-modified">!     gint added_count = 0;</span>
  
<span class="line-modified">!     keys = env-&gt;CallObjectMethod(data, jMapKeySet, NULL);</span>
<span class="line-modified">!     JNI_EXCEPTION_TO_CPP(env)</span>
<span class="line-added">+     keysIterator = env-&gt;CallObjectMethod(keys, jIterableIterator, NULL);</span>
<span class="line-added">+     JNI_EXCEPTION_TO_CPP(env)</span>
<span class="line-added">+     while (env-&gt;CallBooleanMethod(keysIterator, jIteratorHasNext) == JNI_TRUE) {</span>
<span class="line-added">+         next = (jstring)env-&gt;CallObjectMethod(keysIterator, jIteratorNext, NULL);</span>
<span class="line-added">+         JNI_EXCEPTION_TO_CPP(env)</span>
<span class="line-added">+         add_gtk_target_from_jstring(env, &amp;tlist, next, flags);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return tlist;</span>
  }
  
<span class="line-modified">! static gboolean dnd_source_set_string(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)</span>
  {
<span class="line-modified">!     gboolean is_data_set;</span>
<span class="line-added">+ </span>
<span class="line-added">+     jstring string = (jstring)dnd_source_get_data(widget, &quot;text/plain&quot;);</span>
      if (!string) {
          return FALSE;
      }
  
      const char *cstring = mainEnv-&gt;GetStringUTFChars(string, NULL);
      if (cstring) {
<span class="line-modified">!         if (atom == TARGET_MIME_TEXT_PLAIN_ATOM) {</span>
<span class="line-modified">!             gchar *res_str = g_convert((gchar *) cstring, -1, &quot;ISO-8859-1&quot;, &quot;UTF-8&quot;, NULL, NULL, NULL);</span>
<span class="line-modified">!             if (res_str) {</span>
<span class="line-modified">!                 is_data_set = gtk_selection_data_set_text(data, res_str, strlen(res_str));</span>
<span class="line-modified">!                 g_free(res_str);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         } else {</span>
<span class="line-added">+             gint size = strlen(cstring);</span>
<span class="line-added">+             is_data_set = gtk_selection_data_set_text(data, (gchar *) cstring, size);</span>
          }
      }
<span class="line-added">+ </span>
<span class="line-added">+     mainEnv-&gt;ReleaseStringUTFChars(string, cstring);</span>
<span class="line-added">+ </span>
      return is_data_set;
  }
  
<span class="line-modified">! static gboolean dnd_source_set_image(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)</span>
  {
<span class="line-modified">!     jobject pixels = dnd_source_get_data(widget, &quot;application/x-java-rawimage&quot;);</span>
      if (!pixels) {
          return FALSE;
      }
  
      gchar *buffer;
      gsize size;
      const char * type;
      GdkPixbuf *pixbuf = NULL;
<span class="line-modified">!     gboolean is_data_set;</span>
  
      mainEnv-&gt;CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&amp;pixbuf));
  
<span class="line-modified">!     if (!EXCEPTION_OCCURED(mainEnv)) {</span>
<span class="line-modified">!         is_data_set = gtk_selection_data_set_pixbuf(data, pixbuf);</span>
      }
<span class="line-added">+ </span>
      g_object_unref(pixbuf);
<span class="line-modified">! </span>
<span class="line-added">+     return is_data_set;</span>
  }
  
<span class="line-modified">! static gboolean dnd_source_set_uri(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)</span>
  {
      const gchar* url = NULL;
      jstring jurl = NULL;
  
      jobjectArray files_array = NULL;
      gsize files_cnt = 0;
  
<span class="line-modified">!     if (jurl = (jstring) dnd_source_get_data(widget, &quot;text/uri-list&quot;)) {</span>
          url = mainEnv-&gt;GetStringUTFChars(jurl, NULL);
      }
  
<span class="line-modified">!     if (files_array = (jobjectArray) dnd_source_get_data(widget, &quot;application/x-java-file-list&quot;)) {</span>
          files_cnt = mainEnv-&gt;GetArrayLength(files_array);
      }
<span class="line-added">+ </span>
      if (!url &amp;&amp; !files_cnt) {
          return FALSE;
      }
  
<span class="line-added">+     gboolean is_data_set;</span>
      GString* res = g_string_new (NULL); //http://www.ietf.org/rfc/rfc2483.txt
  
      if (files_cnt &gt; 0) {
          for (gsize i = 0; i &lt; files_cnt; ++i) {
              jstring string = (jstring) mainEnv-&gt;GetObjectArrayElement(files_array, i);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 754,42 ***</span>
          g_string_append(res, url);
          g_string_append(res, URI_LIST_LINE_BREAK);
          mainEnv-&gt;ReleaseStringUTFChars(jurl, url);
      }
  
<span class="line-modified">!     gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,</span>
<span class="line-modified">!             8, GDK_PROP_MODE_REPLACE, (guchar *) res-&gt;str, res-&gt;len);</span>
  
<span class="line-modified">!     g_string_free(res, TRUE);</span>
<span class="line-modified">!     return TRUE;</span>
  }
  
<span class="line-modified">! static gboolean dnd_source_set_raw(GdkWindow *requestor, GdkAtom property, GdkAtom target)</span>
  {
<span class="line-modified">!     gchar *target_name = gdk_atom_name(target);</span>
<span class="line-modified">!     jobject data = dnd_source_get_data(target_name);</span>
      gboolean is_data_set = FALSE;
      if (data) {
          if (mainEnv-&gt;IsInstanceOf(data, jStringCls)) {
              const char *cstring = mainEnv-&gt;GetStringUTFChars((jstring)data, NULL);
              if (cstring) {
<span class="line-modified">!                 gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,</span>
<span class="line-removed">-                         8, GDK_PROP_MODE_REPLACE, (guchar *) cstring, strlen(cstring));</span>
<span class="line-removed">- </span>
                  mainEnv-&gt;ReleaseStringUTFChars((jstring)data, cstring);
<span class="line-removed">-                 is_data_set = TRUE;</span>
              }
          } else if (mainEnv-&gt;IsInstanceOf(data, jByteBufferCls)) {
              jbyteArray byteArray = (jbyteArray)mainEnv-&gt;CallObjectMethod(data, jByteBufferArray);
              if (!EXCEPTION_OCCURED(mainEnv)) {
                  jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
                  if (raw) {
                      jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
<span class="line-modified">! </span>
<span class="line-removed">-                     gdk_property_change(requestor, property, target,</span>
<span class="line-removed">-                             8, GDK_PROP_MODE_REPLACE, (guchar *) raw, nraw);</span>
<span class="line-removed">- </span>
                      mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
                      is_data_set = TRUE;
                  }
              }
          }
<span class="line-new-header">--- 696,40 ---</span>
          g_string_append(res, url);
          g_string_append(res, URI_LIST_LINE_BREAK);
          mainEnv-&gt;ReleaseStringUTFChars(jurl, url);
      }
  
<span class="line-modified">!     gchar *uri[2];</span>
<span class="line-modified">!     uri[0] = g_string_free(res, FALSE);</span>
<span class="line-added">+     uri[1] = NULL;</span>
  
<span class="line-modified">!     is_data_set = gtk_selection_data_set_uris(data, uri);</span>
<span class="line-modified">! </span>
<span class="line-added">+     g_free(uri[0]);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return is_data_set;</span>
  }
  
<span class="line-modified">! static gboolean dnd_source_set_raw(GtkWidget *widget, GtkSelectionData *sel_data, GdkAtom atom)</span>
  {
<span class="line-modified">!     gchar *target_name = gdk_atom_name(atom);</span>
<span class="line-modified">!     jobject data = dnd_source_get_data(widget, target_name);</span>
      gboolean is_data_set = FALSE;
      if (data) {
          if (mainEnv-&gt;IsInstanceOf(data, jStringCls)) {
              const char *cstring = mainEnv-&gt;GetStringUTFChars((jstring)data, NULL);
              if (cstring) {
<span class="line-modified">!                 is_data_set = gtk_selection_data_set_text(sel_data, (gchar *) cstring, strlen(cstring));</span>
                  mainEnv-&gt;ReleaseStringUTFChars((jstring)data, cstring);
              }
          } else if (mainEnv-&gt;IsInstanceOf(data, jByteBufferCls)) {
              jbyteArray byteArray = (jbyteArray)mainEnv-&gt;CallObjectMethod(data, jByteBufferArray);
              if (!EXCEPTION_OCCURED(mainEnv)) {
                  jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
                  if (raw) {
                      jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
<span class="line-modified">!                     gtk_selection_data_set(sel_data, atom, 8, (guchar *) raw, nraw);</span>
                      mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
                      is_data_set = TRUE;
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 797,347 ***</span>
  
      g_free(target_name);
      return is_data_set;
  }
  
<span class="line-modified">! static void process_dnd_source_selection_req(GdkWindow *window, GdkEvent *gdkEvent)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     (void)window;</span>
<span class="line-modified">! </span>
<span class="line-removed">-     GdkEventSelection *event = &amp;gdkEvent-&gt;selection;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef GLASS_GTK3</span>
<span class="line-removed">-     GdkWindow *requestor = (event-&gt;requestor);</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     GdkWindow *requestor =</span>
<span class="line-removed">-         gdk_x11_window_foreign_new_for_display(gdk_display_get_default(), event-&gt;requestor);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     gboolean is_data_set = FALSE;</span>
<span class="line-removed">-     if (event-&gt;target == TARGET_UTF8_STRING_ATOM</span>
<span class="line-removed">-             || event-&gt;target == TARGET_MIME_TEXT_PLAIN_ATOM) {</span>
<span class="line-removed">-         is_data_set = dnd_source_set_utf8_string(requestor, event-&gt;property);</span>
<span class="line-removed">-     } else if (event-&gt;target == TARGET_STRING_ATOM) {</span>
<span class="line-removed">-         is_data_set = dnd_source_set_string(requestor, event-&gt;property);</span>
<span class="line-removed">- //    } else if (event-&gt;target == TARGET_COMPOUND_TEXT_ATOM) { // XXX compound text</span>
<span class="line-removed">-     } else if (target_is_image(event-&gt;target)) {</span>
<span class="line-removed">-         is_data_set = dnd_source_set_image(requestor, event-&gt;property, event-&gt;target);</span>
<span class="line-removed">-     } else if (event-&gt;target == TARGET_MIME_URI_LIST_ATOM) {</span>
<span class="line-removed">-         is_data_set = dnd_source_set_uri_list(requestor, event-&gt;property);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         is_data_set = dnd_source_set_raw(requestor, event-&gt;property, event-&gt;target);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     gdk_selection_send_notify(event-&gt;requestor, event-&gt;selection, event-&gt;target,</span>
<span class="line-removed">-                                (is_data_set) ? event-&gt;property : GDK_NONE, event-&gt;time);</span>
<span class="line-removed">- </span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void process_dnd_source_mouse_release(GdkWindow *window, GdkEvent *event) {</span>
<span class="line-removed">-     (void)window;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     glass_gdk_master_pointer_ungrab(event);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (gdk_drag_context_get_selected_action(get_drag_context())) {</span>
<span class="line-removed">-         gdk_drag_drop(get_drag_context(), GDK_CURRENT_TIME);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         gdk_drag_abort(get_drag_context(), GDK_CURRENT_TIME);</span>
<span class="line-removed">-         /* let the gdk_drag_abort messages handled before finish */</span>
<span class="line-removed">-         gdk_threads_add_idle((GSourceFunc) dnd_finish_callback, NULL);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void process_drag_motion(gint x_root, gint y_root, guint state)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     GdkWindow *dest_window;</span>
<span class="line-removed">-     GdkDragProtocol prot;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifndef GLASS_GTK3</span>
<span class="line-removed">-     // gtk3 uses a move-when-idle method</span>
<span class="line-removed">-     DragView::move(x_root, y_root);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     gdk_drag_find_window_for_screen(get_drag_context(), NULL, gdk_screen_get_default(),</span>
<span class="line-removed">-             x_root, y_root, &amp;dest_window, &amp;prot);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (prot != GDK_DRAG_PROTO_NONE) {</span>
<span class="line-removed">-         GdkDragAction action, possible_actions;</span>
<span class="line-removed">-         determine_actions(state, &amp;action, &amp;possible_actions);</span>
<span class="line-removed">-         gdk_drag_motion(get_drag_context(), dest_window, prot, x_root, y_root,</span>
<span class="line-removed">-                 action, possible_actions, GDK_CURRENT_TIME);</span>
      }
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void process_dnd_source_mouse_motion(GdkWindow *window, GdkEvent *event)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     (void)window;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     GdkEventMotion *eventMotion = &amp;event-&gt;motion;</span>
<span class="line-removed">-     process_drag_motion(eventMotion-&gt;x_root, eventMotion-&gt;y_root, eventMotion-&gt;state);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! static void process_dnd_source_key_press_release(GdkWindow *window, GdkEvent *event)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     (void)window;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     GdkEventKey *eventKey = &amp;event-&gt;key;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (eventKey-&gt;is_modifier) {</span>
<span class="line-removed">-         guint state = eventKey-&gt;state;</span>
<span class="line-removed">-         guint new_mod = 0;</span>
<span class="line-removed">-         gint x,y;</span>
<span class="line-removed">-         if (eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Control_L) ||</span>
<span class="line-removed">-                 eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Control_R)) {</span>
<span class="line-removed">-             new_mod = GDK_CONTROL_MASK;</span>
<span class="line-removed">-         } else if (eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Alt_L) ||</span>
<span class="line-removed">-                 eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Alt_R)) {</span>
<span class="line-removed">-             new_mod = GDK_MOD1_MASK;</span>
<span class="line-removed">-         } else if (eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Shift_L) ||</span>
<span class="line-removed">-                 eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Shift_R)) {</span>
<span class="line-removed">-             new_mod = GDK_SHIFT_MASK;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (eventKey-&gt;type == GDK_KEY_PRESS) {</span>
<span class="line-removed">-             state |= new_mod;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             state ^= new_mod;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef GLASS_GTK3</span>
<span class="line-removed">-         gdk_device_get_position(gdk_drag_context_get_device(get_drag_context()), NULL, &amp;x, &amp;y);</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-         glass_gdk_master_pointer_get_position(&amp;x, &amp;y);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-         process_drag_motion(x, y, state);</span>
<span class="line-removed">-     }</span>
  }
  
<span class="line-modified">! static void process_dnd_source_drag_status(GdkWindow *window, GdkEvent *event)</span>
  {
<span class="line-modified">!     (void)window;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     GdkEventDND *eventDnd = &amp;event-&gt;dnd;</span>
<span class="line-removed">-     GdkDragAction selected = gdk_drag_context_get_selected_action(eventDnd-&gt;context);</span>
<span class="line-removed">-     GdkCursor* cursor;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef GLASS_GTK3</span>
<span class="line-removed">-     // dragview shows content when dragging - this updates the position</span>
<span class="line-removed">-     gdk_threads_add_idle_full (GDK_PRIORITY_REDRAW + 5, dnd_update_drag_view,</span>
<span class="line-removed">-                                NULL, NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (selected &amp; GDK_ACTION_COPY) {</span>
<span class="line-removed">-         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-copy&quot;);</span>
<span class="line-removed">-         if (cursor == NULL) {</span>
<span class="line-removed">-             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;copy&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } else if (selected &amp; (GDK_ACTION_MOVE | GDK_ACTION_PRIVATE)) {</span>
<span class="line-removed">-         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-move&quot;);</span>
<span class="line-removed">-         if (cursor == NULL) {</span>
<span class="line-removed">-             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;move&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (cursor == NULL) {</span>
<span class="line-removed">-             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;closedhand&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } else if (selected &amp; GDK_ACTION_LINK) {</span>
<span class="line-removed">-         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-link&quot;);</span>
<span class="line-removed">-         if (cursor == NULL) {</span>
<span class="line-removed">-             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;link&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (cursor == NULL) {</span>
<span class="line-removed">-             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;alias&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-no-drop&quot;);</span>
<span class="line-removed">-         if (cursor == NULL) {</span>
<span class="line-removed">-             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;no-drop&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (cursor == NULL) {</span>
<span class="line-removed">-             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;not-allowed&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (cursor == NULL) {</span>
<span class="line-removed">-             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;forbidden&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (cursor == NULL) {</span>
<span class="line-removed">-             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-none&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (cursor == NULL) {</span>
<span class="line-removed">-         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;default&quot;);</span>
      }
<span class="line-modified">! </span>
<span class="line-removed">-     dnd_pointer_grab(event, cursor);</span>
  }
  
<span class="line-modified">! static void process_dnd_source_drop_finished(GdkWindow *window, GdkEvent *event)</span>
  {
<span class="line-modified">!     (void)window;</span>
<span class="line-modified">!     (void)event;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     gdk_threads_add_idle((GSourceFunc) dnd_finish_callback, NULL);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void process_dnd_source(GdkWindow *window, GdkEvent *event) {</span>
<span class="line-removed">-     switch(event-&gt;type) {</span>
<span class="line-removed">-         case GDK_MOTION_NOTIFY:</span>
<span class="line-removed">-             process_dnd_source_mouse_motion(window, event);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case GDK_BUTTON_RELEASE:</span>
<span class="line-removed">-             process_dnd_source_mouse_release(window, event);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case GDK_DRAG_STATUS:</span>
<span class="line-removed">-             process_dnd_source_drag_status(window, event);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case GDK_DROP_FINISHED:</span>
<span class="line-removed">-             process_dnd_source_drop_finished(window, event);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case GDK_KEY_PRESS:</span>
<span class="line-removed">-         case GDK_KEY_RELEASE:</span>
<span class="line-removed">-             process_dnd_source_key_press_release(window, event);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case GDK_DRAG_ENTER:</span>
<span class="line-removed">-             gdk_selection_owner_set(dnd_window, gdk_drag_get_selection(get_drag_context()),</span>
<span class="line-removed">-                                     GDK_CURRENT_TIME, FALSE);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case GDK_SELECTION_REQUEST:</span>
<span class="line-removed">-             process_dnd_source_selection_req(window, event);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-     }</span>
  }
  
<span class="line-modified">! static void add_target_from_jstring(JNIEnv *env, GList **list, jstring string)</span>
  {
<span class="line-modified">!     const char *gstring = env-&gt;GetStringUTFChars(string, NULL);</span>
<span class="line-modified">!     if (g_strcmp0(gstring, &quot;text/plain&quot;) == 0) {</span>
<span class="line-modified">!         *list = g_list_append(*list, TARGET_UTF8_STRING_ATOM);</span>
<span class="line-modified">!         *list = g_list_append(*list, TARGET_MIME_TEXT_PLAIN_ATOM);</span>
<span class="line-modified">!         *list = g_list_append(*list, TARGET_STRING_ATOM);</span>
<span class="line-modified">!         //*list = g_list_append(list, TARGET_COMPOUND_TEXT_ATOM);</span>
<span class="line-modified">!     } else if (g_strcmp0(gstring, &quot;application/x-java-rawimage&quot;) == 0) {</span>
<span class="line-modified">!         *list = g_list_append(*list, TARGET_MIME_PNG_ATOM);</span>
<span class="line-removed">-         *list = g_list_append(*list, TARGET_MIME_JPEG_ATOM);</span>
<span class="line-removed">-         *list = g_list_append(*list, TARGET_MIME_TIFF_ATOM);</span>
<span class="line-removed">-         *list = g_list_append(*list, TARGET_MIME_BMP_ATOM);</span>
<span class="line-removed">-     } else if (g_strcmp0(gstring, &quot;application/x-java-file-list&quot;) == 0) {</span>
<span class="line-removed">-         *list = g_list_append(*list, TARGET_MIME_URI_LIST_ATOM);</span>
      } else {
<span class="line-modified">!         *list = g_list_append(*list, gdk_atom_intern(gstring, FALSE));</span>
      }
<span class="line-removed">-     env-&gt;ReleaseStringUTFChars(string, gstring);</span>
  }
  
<span class="line-modified">! static GList* data_to_targets(JNIEnv *env, jobject data)</span>
  {
<span class="line-modified">!     jobject keys;</span>
<span class="line-removed">-     jobject keysIterator;</span>
<span class="line-removed">-     jstring next;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     GList *list = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     init_target_atoms();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     keys = env-&gt;CallObjectMethod(data, jMapKeySet, NULL);</span>
<span class="line-removed">-     JNI_EXCEPTION_TO_CPP(env)</span>
<span class="line-removed">-     keysIterator = env-&gt;CallObjectMethod(keys, jIterableIterator, NULL);</span>
<span class="line-removed">-     JNI_EXCEPTION_TO_CPP(env)</span>
<span class="line-removed">-     while (env-&gt;CallBooleanMethod(keysIterator, jIteratorHasNext) == JNI_TRUE) {</span>
<span class="line-removed">-         next = (jstring)env-&gt;CallObjectMethod(keysIterator, jIteratorNext, NULL);</span>
<span class="line-removed">-         JNI_EXCEPTION_TO_CPP(env)</span>
<span class="line-removed">-         add_target_from_jstring(env, &amp;list, next);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return list;</span>
  }
  
  static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported)
  {
<span class="line-removed">-     GdkWindow *src_window = get_dnd_window();</span>
<span class="line-removed">-     GList *targets;</span>
<span class="line-removed">-     GdkDragContext *ctx;</span>
<span class="line-removed">- </span>
      if (supported == 0) {
          return; // No supported actions, do nothing
      }
  
<span class="line-removed">-     targets = data_to_targets(env, data);</span>
<span class="line-removed">- </span>
      data = env-&gt;NewGlobalRef(data);
  
      GdkDragAction actions = translate_glass_action_to_gdk(supported);
<span class="line-removed">-     g_object_set_data_full(G_OBJECT(src_window), SOURCE_DND_DATA, data, clear_global_ref);</span>
<span class="line-removed">-     g_object_set_data(G_OBJECT(src_window), SOURCE_DND_ACTIONS, (gpointer)actions);</span>
  
<span class="line-modified">!     DragView::set_drag_view();</span>
  
<span class="line-modified">! #ifdef GLASS_GTK3</span>
<span class="line-removed">-     GdkDevice *device = gdk_device_manager_get_client_pointer(</span>
<span class="line-removed">-                     gdk_display_get_device_manager(</span>
<span class="line-removed">-                         gdk_display_get_default()));</span>
  
<span class="line-modified">!     ctx = gdk_drag_begin_for_device(src_window, device, targets);</span>
<span class="line-modified">! #else</span>
<span class="line-removed">-     ctx = gdk_drag_begin(src_window, targets);</span>
<span class="line-removed">- #endif</span>
  
<span class="line-modified">!     g_list_free(targets);</span>
<span class="line-modified">!     g_object_set_data(G_OBJECT(src_window), SOURCE_DND_CONTEXT, ctx);</span>
  
<span class="line-modified">! #ifdef GLASS_GTK3</span>
<span class="line-modified">!     if (gtk_get_minor_version() &gt;= 20) {</span>
<span class="line-removed">-         // according to GDK docs, this is only fired on managed mode, but</span>
<span class="line-removed">-         // on 3.20+ the GDK_DROP_FINISHED event stopped working and this signal</span>
<span class="line-removed">-         // works (even when not managed).</span>
<span class="line-removed">-         g_signal_connect(ctx, &quot;dnd-finished&quot;,</span>
<span class="line-removed">-             G_CALLBACK(dnd_finished_callback), NULL);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if(gdk_device_grab(device, src_window, GDK_OWNERSHIP_NONE, FALSE,</span>
<span class="line-modified">!                     (GdkEventMask)</span>
<span class="line-modified">!                          (GDK_POINTER_MOTION_MASK</span>
<span class="line-modified">!                              | GDK_BUTTON_MOTION_MASK</span>
<span class="line-modified">!                              | GDK_BUTTON1_MOTION_MASK</span>
<span class="line-modified">!                              | GDK_BUTTON2_MOTION_MASK</span>
<span class="line-modified">!                              | GDK_BUTTON3_MOTION_MASK</span>
<span class="line-modified">!                              | GDK_BUTTON_RELEASE_MASK),</span>
<span class="line-modified">!                        NULL, GDK_CURRENT_TIME) != GDK_GRAB_SUCCESS) {</span>
<span class="line-modified">!         g_warning(&quot;Usable to grab pointer device.&quot;);</span>
<span class="line-modified">!     }</span>
  #else
<span class="line-modified">!     dnd_pointer_grab(NULL, NULL);</span>
  #endif
  
<span class="line-modified">!     is_dnd_owner = TRUE;</span>
  }
  
<span class="line-modified">! jint execute_dnd(JNIEnv *env, jobject data, jint supported) {</span>
      try {
          dnd_source_push_data(env, data, supported);
      } catch (jni_exception&amp;) {
<span class="line-modified">!         return 0;</span>
      }
  
      while (is_in_drag()) {
          gtk_main_iteration();
      }
  
      return dnd_get_performed_action();
  }
  
   /******************** DRAG VIEW ***************************/
<span class="line-modified">! DragView::View* DragView::view = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">- void DragView::reset_drag_view() {</span>
<span class="line-removed">-     delete view;</span>
<span class="line-removed">-     view = NULL;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! gboolean DragView::get_drag_image_offset(int* x, int* y) {</span>
      gboolean offset_set = FALSE;
<span class="line-modified">!     jobject bb = dnd_source_get_data(&quot;application/x-java-drag-image-offset&quot;);</span>
      if (bb) {
          jbyteArray byteArray = (jbyteArray)mainEnv-&gt;CallObjectMethod(bb, jByteBufferArray);
          if (!EXCEPTION_OCCURED(mainEnv)) {
              jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
              jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
<span class="line-new-header">--- 737,140 ---</span>
  
      g_free(target_name);
      return is_data_set;
  }
  
<span class="line-modified">! static gboolean dnd_destroy_drag_widget_callback(gpointer) {</span>
<span class="line-modified">!     if (drag_widget) {</span>
<span class="line-modified">!         gtk_widget_destroy(drag_widget);</span>
<span class="line-modified">!         drag_widget = NULL;</span>
      }
  
<span class="line-modified">!     return FALSE;</span>
  }
  
<span class="line-modified">! static void dnd_end_callback(GtkWidget *widget,</span>
<span class="line-added">+                              GdkDragContext *context,</span>
<span class="line-added">+                              gpointer user_data)</span>
  {
<span class="line-modified">!     if (drag_widget) {</span>
<span class="line-modified">!         GdkDragAction action = gdk_drag_context_get_selected_action(context);</span>
<span class="line-modified">!         dnd_set_performed_action(translate_gdk_action_to_glass(action));</span>
      }
<span class="line-modified">!     gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);</span>
  }
  
<span class="line-modified">! static gboolean dnd_drag_failed_callback(GtkWidget *widget,</span>
<span class="line-added">+                                      GdkDragContext *context,</span>
<span class="line-added">+                                      GtkDragResult result,</span>
<span class="line-added">+                                      gpointer user_data)</span>
  {
<span class="line-modified">!     dnd_set_performed_action(com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE);</span>
<span class="line-modified">!     gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);</span>
  
<span class="line-modified">!     return FALSE;</span>
  }
  
<span class="line-modified">! static void dnd_data_get_callback(GtkWidget *widget,</span>
<span class="line-added">+                                   GdkDragContext *context,</span>
<span class="line-added">+                                   GtkSelectionData *data,</span>
<span class="line-added">+                                   guint info,</span>
<span class="line-added">+                                   guint time,</span>
<span class="line-added">+                                   gpointer user_data)</span>
  {
<span class="line-modified">!     GdkAtom atom = gtk_selection_data_get_target(data);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (target_is_text(atom)) {</span>
<span class="line-modified">!         dnd_source_set_string(widget, data, atom);</span>
<span class="line-modified">!     } else if (target_is_image(atom)) {</span>
<span class="line-modified">!         dnd_source_set_image(widget, data, atom);</span>
<span class="line-modified">!     } else if (target_is_uri(atom)) {</span>
<span class="line-modified">!         dnd_source_set_uri(widget, data, atom);</span>
      } else {
<span class="line-modified">!         dnd_source_set_raw(widget, data, atom);</span>
      }
  }
  
<span class="line-modified">! static void dnd_drag_begin_callback(GtkWidget *widget,</span>
<span class="line-added">+                                     GdkDragContext *context,</span>
<span class="line-added">+                                     gpointer user_data)</span>
  {
<span class="line-modified">!     DragView::set_drag_view(widget, context);</span>
  }
  
  static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported)
  {
      if (supported == 0) {
          return; // No supported actions, do nothing
      }
  
      data = env-&gt;NewGlobalRef(data);
  
      GdkDragAction actions = translate_glass_action_to_gdk(supported);
  
<span class="line-modified">!     // this widget is used only to pass events and will</span>
<span class="line-added">+     // be destroyed on drag end</span>
<span class="line-added">+     drag_widget = gtk_window_new(GTK_WINDOW_POPUP);</span>
<span class="line-added">+     gtk_window_resize(GTK_WINDOW(drag_widget), 1, 1);</span>
<span class="line-added">+     gtk_window_move(GTK_WINDOW(drag_widget), -200, -200);</span>
<span class="line-added">+     gtk_widget_show(drag_widget);</span>
  
<span class="line-modified">!     g_object_set_data_full(G_OBJECT(drag_widget), SOURCE_DND_DATA, data, clear_global_ref);</span>
  
<span class="line-modified">!     g_signal_connect(drag_widget, &quot;drag-begin&quot;,</span>
<span class="line-modified">!         G_CALLBACK(dnd_drag_begin_callback), NULL);</span>
  
<span class="line-modified">!     g_signal_connect(drag_widget, &quot;drag-failed&quot;,</span>
<span class="line-modified">!         G_CALLBACK(dnd_drag_failed_callback), NULL);</span>
  
<span class="line-modified">!     g_signal_connect(drag_widget, &quot;drag-data-get&quot;,</span>
<span class="line-modified">!         G_CALLBACK(dnd_data_get_callback), NULL);</span>
  
<span class="line-modified">!     g_signal_connect(drag_widget, &quot;drag-end&quot;,</span>
<span class="line-modified">!         G_CALLBACK(dnd_end_callback), NULL);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     GtkTargetList *tlist = data_to_gtk_target_list(env, data);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     GdkDragContext *context;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     gint x, y;</span>
<span class="line-modified">!     glass_gdk_master_pointer_get_position(&amp;x, &amp;y);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     is_dnd_owner = TRUE;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if GTK_CHECK_VERSION(3, 10, 0)</span>
<span class="line-added">+     context = gtk_drag_begin_with_coordinates(drag_widget, tlist, actions, 1, NULL, x, y);</span>
  #else
<span class="line-modified">!     context = gtk_drag_begin(drag_widget, tlist, actions, 1, NULL);</span>
  #endif
  
<span class="line-modified">!     gtk_target_list_unref(tlist);</span>
  }
  
<span class="line-modified">! jint execute_dnd(JNIEnv *env, jobject data, jint supported)</span>
<span class="line-added">+ {</span>
      try {
          dnd_source_push_data(env, data, supported);
      } catch (jni_exception&amp;) {
<span class="line-modified">!         gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);</span>
<span class="line-added">+         return com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE;</span>
      }
  
      while (is_in_drag()) {
          gtk_main_iteration();
      }
  
      return dnd_get_performed_action();
  }
  
   /******************** DRAG VIEW ***************************/
<span class="line-modified">!  DragView::View* DragView::view = NULL;</span>
  
<span class="line-modified">!  gboolean DragView::get_drag_image_offset(GtkWidget *widget, int* x, int* y)</span>
<span class="line-added">+  {</span>
      gboolean offset_set = FALSE;
<span class="line-modified">!     jobject bb = dnd_source_get_data(widget, &quot;application/x-java-drag-image-offset&quot;);</span>
      if (bb) {
          jbyteArray byteArray = (jbyteArray)mainEnv-&gt;CallObjectMethod(bb, jByteBufferArray);
          if (!EXCEPTION_OCCURED(mainEnv)) {
              jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
              jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1153,32 ***</span>
          }
      }
      return offset_set;
  }
  
<span class="line-modified">! static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer) {</span>
<span class="line-modified">!     if (pixels != NULL) {</span>
<span class="line-removed">-         g_free(pixels);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- GdkPixbuf* DragView::get_drag_image(gboolean* is_raw_image, gint* width, gint* height) {</span>
      GdkPixbuf *pixbuf = NULL;
      gboolean is_raw = FALSE;
  
<span class="line-modified">!     jobject drag_image = dnd_source_get_data(&quot;application/x-java-drag-image&quot;);</span>
  
      if (drag_image) {
          jbyteArray byteArray = (jbyteArray) mainEnv-&gt;CallObjectMethod(drag_image, jByteBufferArray);
          if (!EXCEPTION_OCCURED(mainEnv)) {
  
              jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
              jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
  
              int w = 0, h = 0;
              int whsz = sizeof(jint) * 2; // Pixels are stored right after two ints
<span class="line-modified">!                                          // in this byteArray: width and height</span>
              if (nraw &gt; whsz) {
                  jint* int_raw = (jint*) raw;
                  w = BSWAP_32(int_raw[0]);
                  h = BSWAP_32(int_raw[1]);
  
<span class="line-new-header">--- 886,27 ---</span>
          }
      }
      return offset_set;
  }
  
<span class="line-modified">! GdkPixbuf* DragView::get_drag_image(GtkWidget *widget, gboolean* is_raw_image, gint* width, gint* height)</span>
<span class="line-modified">! {</span>
      GdkPixbuf *pixbuf = NULL;
      gboolean is_raw = FALSE;
  
<span class="line-modified">!     jobject drag_image = dnd_source_get_data(widget, &quot;application/x-java-drag-image&quot;);</span>
  
      if (drag_image) {
          jbyteArray byteArray = (jbyteArray) mainEnv-&gt;CallObjectMethod(drag_image, jByteBufferArray);
          if (!EXCEPTION_OCCURED(mainEnv)) {
  
              jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
              jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
  
              int w = 0, h = 0;
              int whsz = sizeof(jint) * 2; // Pixels are stored right after two ints
<span class="line-modified">!             // in this byteArray: width and height</span>
              if (nraw &gt; whsz) {
                  jint* int_raw = (jint*) raw;
                  w = BSWAP_32(int_raw[0]);
                  h = BSWAP_32(int_raw[1]);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1186,20 ***</span>
                  if ((nraw - whsz) / 4 - w * h &gt;= 0 ) {
                      guchar* data = (guchar*) g_try_malloc0(nraw - whsz);
                      if (data) {
                          memcpy(data, (raw + whsz), nraw - whsz);
                          pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,
<span class="line-modified">!                                 w, h, w * 4, pixbufDestroyNotifyFunc, NULL);</span>
                      }
                  }
              }
              mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
          }
      }
  
      if (!GDK_IS_PIXBUF(pixbuf)) {
<span class="line-modified">!         jobject pixels = dnd_source_get_data(&quot;application/x-java-rawimage&quot;);</span>
          if (pixels) {
              is_raw = TRUE;
              mainEnv-&gt;CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&amp;pixbuf));
              CHECK_JNI_EXCEPTION_RET(mainEnv, NULL)
          }
<span class="line-new-header">--- 914,20 ---</span>
                  if ((nraw - whsz) / 4 - w * h &gt;= 0 ) {
                      guchar* data = (guchar*) g_try_malloc0(nraw - whsz);
                      if (data) {
                          memcpy(data, (raw + whsz), nraw - whsz);
                          pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,
<span class="line-modified">!                                                           w, h, w * 4, pixbufDestroyNotifyFunc, NULL);</span>
                      }
                  }
              }
              mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
          }
      }
  
      if (!GDK_IS_PIXBUF(pixbuf)) {
<span class="line-modified">!         jobject pixels = dnd_source_get_data(widget, &quot;application/x-java-rawimage&quot;);</span>
          if (pixels) {
              is_raw = TRUE;
              mainEnv-&gt;CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&amp;pixbuf));
              CHECK_JNI_EXCEPTION_RET(mainEnv, NULL)
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1215,11 ***</span>
      if (w &gt; DRAG_IMAGE_MAX_WIDTH || h &gt; DRAG_IMAGE_MAX_HEIGH) {
          double rw = DRAG_IMAGE_MAX_WIDTH / (double)w;
          double rh =  DRAG_IMAGE_MAX_HEIGH / (double)h;
          double r = MIN(rw, rh);
  
<span class="line-removed">- </span>
          int new_w = w * r;
          int new_h = h * r;
  
          w = new_w;
          h = new_h;
<span class="line-new-header">--- 943,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1237,89 ***</span>
      *height = h;
  
      return pixbuf;
  }
  
<span class="line-modified">! void DragView::set_drag_view() {</span>
<span class="line-modified">!     reset_drag_view();</span>
<span class="line-removed">- </span>
      gboolean is_raw_image = FALSE;
      gint w = 0, h = 0;
<span class="line-modified">!     GdkPixbuf* pixbuf = get_drag_image(&amp;is_raw_image, &amp;w, &amp;h);</span>
  
      if (GDK_IS_PIXBUF(pixbuf)) {
          gint offset_x = w / 2;
          gint offset_y = h / 2;
  
<span class="line-modified">!         gboolean is_offset_set = get_drag_image_offset(&amp;offset_x, &amp;offset_y);</span>
  
<span class="line-modified">!         DragView::view = new DragView::View(pixbuf, is_raw_image, is_offset_set, offset_x, offset_y);</span>
<span class="line-modified">!     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- void DragView::move(gint x, gint y) {</span>
<span class="line-removed">-     if (view) {</span>
<span class="line-removed">-         view-&gt;move(x, y);</span>
      }
  }
  
<span class="line-modified">! static void on_screen_changed(GtkWidget *widget, GdkScreen *previous_screen, gpointer view) {</span>
      (void)widget;
      (void)previous_screen;
  
      ((DragView::View*) view)-&gt;screen_changed();
  }
  
<span class="line-modified">! static gboolean on_draw(GtkWidget *widget, cairo_t *cr, gpointer view) {</span>
<span class="line-modified">!     (void)widget;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ((DragView::View*) view)-&gt;expose(cr);</span>
<span class="line-removed">-     return FALSE;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static gboolean on_expose(GtkWidget *widget, GdkEventExpose *event, gpointer view) {</span>
      (void)widget;
      (void)event;
  
<span class="line-modified">!     ((DragView::View*) view)-&gt;expose(NULL);</span>
      return FALSE;
  }
  
<span class="line-modified">! DragView::View::View(GdkPixbuf* _pixbuf, gboolean _is_raw_image,</span>
<span class="line-modified">!                                 gboolean _is_offset_set, gint _offset_x, gint _offset_y) :</span>
<span class="line-modified">!         pixbuf(_pixbuf),</span>
<span class="line-modified">!         is_raw_image(_is_raw_image),</span>
<span class="line-modified">!         is_offset_set(_is_offset_set),</span>
<span class="line-modified">!         offset_x(_offset_x),</span>
<span class="line-modified">!         offset_y(_offset_y)</span>
  {
<span class="line-modified">!     width = gdk_pixbuf_get_width(pixbuf);</span>
<span class="line-modified">!     height = gdk_pixbuf_get_height(pixbuf);</span>
<span class="line-modified">! </span>
      widget = gtk_window_new(GTK_WINDOW_POPUP);
      gtk_window_set_type_hint(GTK_WINDOW(widget), GDK_WINDOW_TYPE_HINT_DND);
      gtk_widget_set_events(widget, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK);
  
      screen_changed();
  
      gtk_widget_realize(widget);
  
      gtk_widget_set_app_paintable(widget, TRUE);
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef GLASS_GTK3</span>
<span class="line-removed">-     g_signal_connect(G_OBJECT(widget), &quot;draw&quot;, G_CALLBACK(on_draw), this);</span>
<span class="line-removed">- #else</span>
      g_signal_connect(G_OBJECT(widget), &quot;expose-event&quot;, G_CALLBACK(on_expose), this);
<span class="line-removed">- #endif</span>
      g_signal_connect(G_OBJECT(widget), &quot;screen-changed&quot;, G_CALLBACK(on_screen_changed), this);
<span class="line-removed">- </span>
      gtk_widget_set_size_request(widget, width, height);
<span class="line-removed">- </span>
      gtk_window_set_decorated(GTK_WINDOW(widget), FALSE);
<span class="line-modified">!     gtk_window_set_opacity(GTK_WINDOW(widget), .7);</span>
  }
  
<span class="line-modified">! void DragView::View::screen_changed() {</span>
      GdkScreen *screen = gtk_widget_get_screen(widget);
  
      glass_configure_window_transparency(widget, true);
  
      if (!gdk_screen_is_composited(screen)) {
<span class="line-new-header">--- 964,79 ---</span>
      *height = h;
  
      return pixbuf;
  }
  
<span class="line-modified">! void DragView::set_drag_view(GtkWidget *widget, GdkDragContext *context)</span>
<span class="line-modified">! {</span>
      gboolean is_raw_image = FALSE;
      gint w = 0, h = 0;
<span class="line-modified">!     GdkPixbuf* pixbuf = get_drag_image(widget, &amp;is_raw_image, &amp;w, &amp;h);</span>
  
      if (GDK_IS_PIXBUF(pixbuf)) {
          gint offset_x = w / 2;
          gint offset_y = h / 2;
  
<span class="line-modified">!         gboolean is_offset_set = get_drag_image_offset(widget, &amp;offset_x, &amp;offset_y);</span>
  
<span class="line-modified">!         DragView::view = new DragView::View(context, pixbuf, w, h, is_raw_image,</span>
<span class="line-modified">!             is_offset_set, offset_x, offset_y);</span>
      }
  }
  
<span class="line-modified">! static void on_screen_changed(GtkWidget *widget, GdkScreen *previous_screen, gpointer view)</span>
<span class="line-added">+ {</span>
      (void)widget;
      (void)previous_screen;
  
      ((DragView::View*) view)-&gt;screen_changed();
  }
  
<span class="line-modified">! static gboolean on_expose(GtkWidget *widget, GdkEventExpose *event, gpointer view)</span>
<span class="line-modified">! {</span>
      (void)widget;
      (void)event;
  
<span class="line-modified">!     ((DragView::View*) view)-&gt;expose();</span>
      return FALSE;
  }
  
<span class="line-modified">! DragView::View::View(GdkDragContext* _context, GdkPixbuf* _pixbuf, gint _width, gint _height,</span>
<span class="line-modified">!                      gboolean _is_raw_image, gboolean _is_offset_set, gint _offset_x, gint _offset_y) :</span>
<span class="line-modified">!     context(_context),</span>
<span class="line-modified">!     pixbuf(_pixbuf),</span>
<span class="line-modified">!     width(_width),</span>
<span class="line-modified">!     height(_height),</span>
<span class="line-modified">!     is_raw_image(_is_raw_image),</span>
<span class="line-added">+     is_offset_set(_is_offset_set),</span>
<span class="line-added">+     offset_x(_offset_x),</span>
<span class="line-added">+     offset_y(_offset_y)</span>
  {
<span class="line-modified">! #ifdef GLASS_GTK3</span>
<span class="line-modified">!     gtk_drag_set_icon_pixbuf(context, pixbuf, offset_x, offset_y);</span>
<span class="line-modified">! #else</span>
      widget = gtk_window_new(GTK_WINDOW_POPUP);
      gtk_window_set_type_hint(GTK_WINDOW(widget), GDK_WINDOW_TYPE_HINT_DND);
      gtk_widget_set_events(widget, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK);
  
      screen_changed();
  
      gtk_widget_realize(widget);
  
      gtk_widget_set_app_paintable(widget, TRUE);
      g_signal_connect(G_OBJECT(widget), &quot;expose-event&quot;, G_CALLBACK(on_expose), this);
      g_signal_connect(G_OBJECT(widget), &quot;screen-changed&quot;, G_CALLBACK(on_screen_changed), this);
      gtk_widget_set_size_request(widget, width, height);
      gtk_window_set_decorated(GTK_WINDOW(widget), FALSE);
<span class="line-modified">! </span>
<span class="line-added">+     gtk_widget_show_all(widget);</span>
<span class="line-added">+     gtk_drag_set_icon_widget(context, widget, offset_x, offset_y);</span>
<span class="line-added">+ #endif</span>
  }
  
<span class="line-modified">! void DragView::View::screen_changed()</span>
<span class="line-added">+ {</span>
      GdkScreen *screen = gtk_widget_get_screen(widget);
  
      glass_configure_window_transparency(widget, true);
  
      if (!gdk_screen_is_composited(screen)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1328,14 ***</span>
              offset_y = 1;
          }
      }
  }
  
<span class="line-modified">! void DragView::View::expose(cairo_t *context) {</span>
<span class="line-modified">! #ifndef GLASS_GTK3</span>
<span class="line-modified">!     context = gdk_cairo_create(gtk_widget_get_window(widget));</span>
<span class="line-modified">! #endif</span>
      cairo_surface_t* cairo_surface;
  
      guchar* pixels = is_raw_image
              ? (guchar*) convert_BGRA_to_RGBA((const int*) gdk_pixbuf_get_pixels(pixbuf),
                                                  gdk_pixbuf_get_rowstride(pixbuf),
<span class="line-new-header">--- 1045,14 ---</span>
              offset_y = 1;
          }
      }
  }
  
<span class="line-modified">! void DragView::View::expose()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     cairo_t *context = gdk_cairo_create(gtk_widget_get_window(widget));</span>
<span class="line-modified">! </span>
      cairo_surface_t* cairo_surface;
  
      guchar* pixels = is_raw_image
              ? (guchar*) convert_BGRA_to_RGBA((const int*) gdk_pixbuf_get_pixels(pixbuf),
                                                  gdk_pixbuf_get_rowstride(pixbuf),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1352,41 ***</span>
      cairo_paint(context);
  
      if (is_raw_image) {
          g_free(pixels);
      }
<span class="line-removed">- </span>
<span class="line-removed">-     cairo_surface_destroy(cairo_surface);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifndef GLASS_GTK3</span>
      cairo_destroy(context);
<span class="line-modified">! #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void DragView::View::move(gint x, gint y) {</span>
<span class="line-removed">- #ifdef GLASS_GTK3</span>
<span class="line-removed">-     // gtk3 method uses a move-when-idle method</span>
<span class="line-removed">-     gtk_window_move(GTK_WINDOW(widget), x - offset_x, y - offset_y);</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     if (!gtk_events_pending()) { // avoid sluggish window move</span>
<span class="line-removed">-         gtk_window_move(GTK_WINDOW(widget), x - offset_x, y - offset_y);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (gtk_widget_get_visible(widget)) {</span>
<span class="line-removed">-         gdk_window_raise(gtk_widget_get_window(widget));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     else {</span>
<span class="line-removed">-         gtk_widget_show(widget);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- DragView::View::~View() {</span>
<span class="line-removed">-     if (widget) {</span>
<span class="line-removed">-         gtk_widget_destroy(widget);</span>
<span class="line-removed">-         widget == NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (pixbuf) {</span>
<span class="line-removed">-         g_object_unref(pixbuf);</span>
<span class="line-removed">-         pixbuf == NULL;</span>
<span class="line-removed">-     }</span>
  }
<span class="line-new-header">--- 1069,8 ---</span>
      cairo_paint(context);
  
      if (is_raw_image) {
          g_free(pixels);
      }
      cairo_destroy(context);
<span class="line-modified">!     cairo_surface_destroy(cairo_surface);</span>
  }
</pre>
<center><a href="GlassApplication.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_dnd.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>