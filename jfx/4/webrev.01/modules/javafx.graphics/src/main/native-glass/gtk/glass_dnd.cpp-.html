<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &quot;glass_dnd.h&quot;
  26 #include &quot;glass_general.h&quot;
  27 #include &quot;glass_evloop.h&quot;
  28 
  29 #include &quot;com_sun_glass_events_DndEvent.h&quot;
  30 #include &quot;com_sun_glass_ui_gtk_GtkDnDClipboard.h&quot;
  31 
  32 #include &lt;jni.h&gt;
  33 #include &lt;cstring&gt;
  34 
  35 #include &lt;gtk/gtk.h&gt;
  36 #include &lt;gdk/gdkx.h&gt;
  37 #include &lt;gdk/gdkkeysyms.h&gt;
  38 
  39 /************************* COMMON *********************************************/
  40 static jint translate_gdk_action_to_glass(GdkDragAction action)
  41 {
  42     jint result = 0;
  43     result |= (action &amp; GDK_ACTION_COPY)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY : 0;
  44     result |= (action &amp; GDK_ACTION_MOVE)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE : 0;
  45     result |= (action &amp; GDK_ACTION_LINK)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE : 0;
  46     return result;
  47 }
  48 
  49 static GdkDragAction translate_glass_action_to_gdk(jint action)
  50 {
  51     int result = 0;
  52     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY)? GDK_ACTION_COPY : 0;
  53     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE)? GDK_ACTION_MOVE : 0;
  54     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE)? GDK_ACTION_LINK : 0;
  55     return static_cast&lt;GdkDragAction&gt;(result);
  56 }
  57 
  58 static gboolean target_atoms_initialized = FALSE;
  59 static GdkAtom TARGET_UTF8_STRING_ATOM;
  60 static GdkAtom TARGET_MIME_TEXT_PLAIN_ATOM;
  61 static GdkAtom TARGET_COMPOUND_TEXT_ATOM;
  62 static GdkAtom TARGET_STRING_ATOM;
  63 
  64 static GdkAtom TARGET_MIME_URI_LIST_ATOM;
  65 
  66 static GdkAtom TARGET_MIME_PNG_ATOM;
  67 static GdkAtom TARGET_MIME_JPEG_ATOM;
  68 static GdkAtom TARGET_MIME_TIFF_ATOM;
  69 static GdkAtom TARGET_MIME_BMP_ATOM;
  70 
  71 static void init_target_atoms()
  72 {
  73     if (target_atoms_initialized) {
  74         return;
  75     }
  76     TARGET_UTF8_STRING_ATOM = gdk_atom_intern_static_string(&quot;UTF8_STRING&quot;);
  77     TARGET_MIME_TEXT_PLAIN_ATOM = gdk_atom_intern_static_string(&quot;text/plain&quot;);
  78     TARGET_COMPOUND_TEXT_ATOM = gdk_atom_intern_static_string(&quot;COMPOUND_TEXT&quot;);
  79     TARGET_STRING_ATOM = gdk_atom_intern_static_string(&quot;STRING&quot;);
  80 
  81     TARGET_MIME_URI_LIST_ATOM = gdk_atom_intern_static_string(&quot;text/uri-list&quot;);
  82 
  83     TARGET_MIME_PNG_ATOM = gdk_atom_intern_static_string(&quot;image/png&quot;);
  84     TARGET_MIME_JPEG_ATOM = gdk_atom_intern_static_string(&quot;image/jpeg&quot;);
  85     TARGET_MIME_TIFF_ATOM = gdk_atom_intern_static_string(&quot;image/tiff&quot;);
  86     TARGET_MIME_BMP_ATOM = gdk_atom_intern_static_string(&quot;image/bmp&quot;);
  87 
  88     target_atoms_initialized = TRUE;
  89 }
  90 
  91 static gboolean target_is_text(GdkAtom target)
  92 {
  93     init_target_atoms();
  94 
  95     return (target == TARGET_UTF8_STRING_ATOM ||
  96             target == TARGET_STRING_ATOM ||
  97             target == TARGET_MIME_TEXT_PLAIN_ATOM/* ||
  98             target == TARGET_COMPOUND_TEXT_ATOM*/);
  99 }
 100 
 101 static gboolean target_is_uri(GdkAtom target)
 102 {
 103     init_target_atoms();
 104     return target == TARGET_MIME_URI_LIST_ATOM;
 105 }
 106 
 107 static gboolean target_is_image(GdkAtom target)
 108 {
 109     init_target_atoms();
 110     return (target == TARGET_MIME_PNG_ATOM ||
 111             target == TARGET_MIME_JPEG_ATOM ||
 112             target == TARGET_MIME_TIFF_ATOM ||
 113             target == TARGET_MIME_BMP_ATOM);
 114 }
 115 
 116 static void clear_global_ref(gpointer data)
 117 {
 118     mainEnv-&gt;DeleteGlobalRef((jobject)data);
 119 }
 120 
 121 static void dnd_set_performed_action(jint performed_action);
 122 static jint dnd_get_performed_action();
 123 
 124 /************************* TARGET *********************************************/
 125 struct selection_data_ctx {
 126     gboolean received;
 127     guchar *data;
 128     GdkAtom type;
 129     gint format;
 130     gint length;
 131 };
 132 
 133 static gboolean dnd_target_receive_data(JNIEnv *env, GdkAtom target, selection_data_ctx *selection_ctx);
 134 
 135 static struct {
 136     GdkDragContext *ctx;
 137     gboolean just_entered;
 138     jobjectArray mimes;
 139     gint dx, dy;
 140 } enter_ctx = {NULL, FALSE, NULL, 0, 0};
 141 
 142 gboolean is_dnd_owner = FALSE;
 143 
 144 static void reset_enter_ctx() {
 145     if (enter_ctx.mimes != NULL) {
 146         mainEnv-&gt;DeleteGlobalRef(enter_ctx.mimes);
 147     }
 148 
 149     memset(&amp;enter_ctx, 0, sizeof(enter_ctx));
 150 }
 151 
 152 static void process_dnd_target_drag_enter(WindowContext *ctx, GdkEventDND *event)
 153 {
 154     reset_enter_ctx();
 155     enter_ctx.ctx = event-&gt;context;
 156     enter_ctx.just_entered = TRUE;
 157     gdk_window_get_origin(ctx-&gt;get_gdk_window(), &amp;enter_ctx.dx, &amp;enter_ctx.dy);
 158     is_dnd_owner = is_in_drag();
 159 }
 160 
 161 static void process_dnd_target_drag_motion(WindowContext *ctx, GdkEventDND *event)
 162 {
 163     if (!enter_ctx.ctx) {
 164         gdk_drag_status(event-&gt;context, static_cast&lt;GdkDragAction&gt;(0), GDK_CURRENT_TIME);
 165         return; // Do not process motion events if no enter event was received
 166     }
 167     jmethodID method = enter_ctx.just_entered ? jViewNotifyDragEnter : jViewNotifyDragOver;
 168     GdkDragAction suggested = gdk_drag_context_get_suggested_action(event-&gt;context);
 169     GdkDragAction result = translate_glass_action_to_gdk(mainEnv-&gt;CallIntMethod(ctx-&gt;get_jview(), method,
 170             (jint)event-&gt;x_root - enter_ctx.dx, (jint)event-&gt;y_root - enter_ctx.dy,
 171             (jint)event-&gt;x_root, (jint)event-&gt;y_root,
 172             translate_gdk_action_to_glass(suggested)));
 173     CHECK_JNI_EXCEPTION(mainEnv)
 174 
 175     if (enter_ctx.just_entered) {
 176         enter_ctx.just_entered = FALSE;
 177     }
 178     gdk_drag_status(event-&gt;context, result, GDK_CURRENT_TIME);
 179 }
 180 
 181 static void process_dnd_target_drag_leave(WindowContext *ctx, GdkEventDND *event)
 182 {
 183     (void)event;
 184 
 185     mainEnv-&gt;CallVoidMethod(ctx-&gt;get_jview(), jViewNotifyDragLeave, NULL);
 186     CHECK_JNI_EXCEPTION(mainEnv)
 187 }
 188 
 189 static void process_dnd_target_drop_start(WindowContext *ctx, GdkEventDND *event)
 190 {
 191     if (!enter_ctx.ctx || enter_ctx.just_entered) {
 192         gdk_drop_finish(event-&gt;context, FALSE, GDK_CURRENT_TIME);
 193         gdk_drop_reply(event-&gt;context, FALSE, GDK_CURRENT_TIME);
 194         return; // Do not process drop events if no enter event and subsequent motion event were received
 195     }
 196     GdkDragAction selected = gdk_drag_context_get_selected_action(event-&gt;context);
 197 
 198     mainEnv-&gt;CallIntMethod(ctx-&gt;get_jview(), jViewNotifyDragDrop,
 199             (jint)event-&gt;x_root - enter_ctx.dx, (jint)event-&gt;y_root - enter_ctx.dy,
 200             (jint)event-&gt;x_root, (jint)event-&gt;y_root,
 201             translate_gdk_action_to_glass(selected));
 202     LOG_EXCEPTION(mainEnv)
 203 
 204     gdk_drop_finish(event-&gt;context, TRUE, GDK_CURRENT_TIME);
 205     gdk_drop_reply(event-&gt;context, TRUE, GDK_CURRENT_TIME);
 206 }
 207 
 208 static gboolean check_state_in_drag(JNIEnv *env)
 209 {
 210     if (!enter_ctx.ctx) {
 211         jclass jc = env-&gt;FindClass(&quot;java/lang/IllegalStateException&quot;);
 212         if (!env-&gt;ExceptionCheck()) {
 213             env-&gt;ThrowNew(jc,
 214                     &quot;Cannot get supported actions. Drag pointer haven&#39;t entered the application window&quot;);
 215         }
 216         return TRUE;
 217     }
 218     return FALSE;
 219 }
 220 
 221 // Events coming from application that are related to us being a DnD target
 222 void process_dnd_target(WindowContext *ctx, GdkEventDND *event)
 223 {
 224     switch (event-&gt;type) {
 225         case GDK_DRAG_ENTER:
 226             process_dnd_target_drag_enter(ctx, event);
 227             break;
 228         case GDK_DRAG_MOTION:
 229             process_dnd_target_drag_motion(ctx, event);
 230             break;
 231         case GDK_DRAG_LEAVE:
 232             process_dnd_target_drag_leave(ctx, event);
 233             break;
 234         case GDK_DROP_START:
 235             process_dnd_target_drop_start(ctx, event);
 236             break;
 237         default:
 238             break;
 239     }
 240 }
 241 
 242 jobjectArray dnd_target_get_mimes(JNIEnv *env)
 243 {
 244     if (check_state_in_drag(env)) {
 245         return NULL;
 246     }
 247     if (!enter_ctx.mimes) {
 248         GList* targets = gdk_drag_context_list_targets(enter_ctx.ctx);
 249         jobject set = env-&gt;NewObject(jHashSetCls, jHashSetInit, NULL);
 250         EXCEPTION_OCCURED(env);
 251 
 252         while (targets) {
 253             GdkAtom target = GDK_POINTER_TO_ATOM(targets-&gt;data);
 254             gchar *name = gdk_atom_name(target);
 255 
 256             if (target_is_text(target)) {
 257                 jstring jStr = env-&gt;NewStringUTF(&quot;text/plain&quot;);
 258                 EXCEPTION_OCCURED(env);
 259                 env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);
 260                 EXCEPTION_OCCURED(env);
 261             }
 262 
 263             if (target_is_image(target)) {
 264                 jstring jStr = env-&gt;NewStringUTF(&quot;application/x-java-rawimage&quot;);
 265                 EXCEPTION_OCCURED(env);
 266                 env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);
 267                 EXCEPTION_OCCURED(env);
 268             }
 269 
 270             if (target_is_uri(target)) {
 271                 selection_data_ctx ctx;
 272                 if (dnd_target_receive_data(env, TARGET_MIME_URI_LIST_ATOM, &amp;ctx)) {
 273                     gchar** uris = g_uri_list_extract_uris((gchar *) ctx.data);
 274                     guint size = g_strv_length(uris);
 275                     guint files_cnt = get_files_count(uris);
 276                     if (files_cnt) {
 277                         jstring jStr = env-&gt;NewStringUTF(&quot;application/x-java-file-list&quot;);
 278                         EXCEPTION_OCCURED(env);
 279                         env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);
 280                         EXCEPTION_OCCURED(env);
 281                     }
 282                     if (size - files_cnt) {
 283                         jstring jStr = env-&gt;NewStringUTF(&quot;text/uri-list&quot;);
 284                         EXCEPTION_OCCURED(env);
 285                         env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);
 286                         EXCEPTION_OCCURED(env);
 287                     }
 288                     g_strfreev(uris);
 289                 }
 290                 g_free(ctx.data);
 291             } else {
 292                 jstring jStr = env-&gt;NewStringUTF(name);
 293                 EXCEPTION_OCCURED(env);
 294                 env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);
 295                 EXCEPTION_OCCURED(env);
 296             }
 297 
 298             g_free(name);
 299             targets = targets-&gt;next;
 300         }
 301         enter_ctx.mimes = env-&gt;NewObjectArray(env-&gt;CallIntMethod(set, jSetSize, NULL),
 302                 jStringCls, NULL);
 303         EXCEPTION_OCCURED(env);
 304         enter_ctx.mimes = (jobjectArray)env-&gt;CallObjectMethod(set, jSetToArray, enter_ctx.mimes, NULL);
 305         enter_ctx.mimes = (jobjectArray)env-&gt;NewGlobalRef(enter_ctx.mimes);
 306     }
 307     return enter_ctx.mimes;
 308 }
 309 
 310 jint dnd_target_get_supported_actions(JNIEnv *env)
 311 {
 312     if (check_state_in_drag(env)) {
 313         return 0;
 314     }
 315     return translate_gdk_action_to_glass(gdk_drag_context_get_actions(enter_ctx.ctx));
 316 }
 317 
 318 static void wait_for_selection_data_hook(GdkEvent * event, void * data)
 319 {
 320     selection_data_ctx *ctx = (selection_data_ctx*)data;
 321     GdkWindow *dest = glass_gdk_drag_context_get_dest_window(enter_ctx.ctx);
 322     if (event-&gt;type == GDK_SELECTION_NOTIFY &amp;&amp;
 323             event-&gt;selection.window == dest) {
 324         if (event-&gt;selection.property) { // if 0, that we received negative response
 325             ctx-&gt;length = gdk_selection_property_get(dest, &amp;(ctx-&gt;data), &amp;(ctx-&gt;type), &amp;(ctx-&gt;format));
 326         }
 327         ctx-&gt;received = TRUE;
 328     }
 329 }
 330 
 331 static gboolean dnd_target_receive_data(JNIEnv *env, GdkAtom target, selection_data_ctx *selection_ctx)
 332 {
 333     GevlHookRegistration hookReg;
 334 
 335     memset(selection_ctx, 0, sizeof(selection_data_ctx));
 336 
 337     gdk_selection_convert(glass_gdk_drag_context_get_dest_window(enter_ctx.ctx), gdk_drag_get_selection(enter_ctx.ctx), target,
 338                           GDK_CURRENT_TIME);
 339 
 340     hookReg =
 341             glass_evloop_hook_add(
 342                     (GevlHookFunction) wait_for_selection_data_hook,
 343                     selection_ctx);
 344     if (HANDLE_MEM_ALLOC_ERROR(env, hookReg,
 345                                &quot;Failed to allocate event hook&quot;)) {
 346         return TRUE;
 347     }
 348 
 349     do {
 350         gtk_main_iteration();
 351     } while (!(selection_ctx-&gt;received));
 352 
 353 
 354     glass_evloop_hook_remove(hookReg);
 355     return selection_ctx-&gt;data != NULL;
 356 }
 357 
 358 static jobject dnd_target_get_string(JNIEnv *env)
 359 {
 360     jobject result = NULL;
 361     selection_data_ctx ctx;
 362 
 363     if (dnd_target_receive_data(env, TARGET_UTF8_STRING_ATOM, &amp;ctx)) {
 364         result = env-&gt;NewStringUTF((char *)ctx.data);
 365         EXCEPTION_OCCURED(env);
 366         g_free(ctx.data);
 367     }
 368     if (!result &amp;&amp; dnd_target_receive_data(env, TARGET_MIME_TEXT_PLAIN_ATOM, &amp;ctx)) {
 369         result = env-&gt;NewStringUTF((char *)ctx.data);
 370         EXCEPTION_OCCURED(env);
 371         g_free(ctx.data);
 372     }
 373     // TODO find out how to convert from compound text
 374     // if (!result &amp;&amp; dnd_target_receive_data(env, TARGET_COMPOUND_TEXT_ATOM, &amp;ctx)) {
 375     // }
 376     if (!result &amp;&amp; dnd_target_receive_data(env, TARGET_STRING_ATOM, &amp;ctx)) {
 377         gchar *str;
 378         str = g_convert( (gchar *)ctx.data, -1, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, NULL, NULL, NULL);
 379         if (str != NULL) {
 380             result = env-&gt;NewStringUTF(str);
 381             EXCEPTION_OCCURED(env);
 382             g_free(str);
 383         }
 384         g_free(ctx.data);
 385     }
 386     return result;
 387 }
 388 
 389 static jobject dnd_target_get_list(JNIEnv *env, gboolean files)
 390 {
 391     jobject result = NULL;
 392     selection_data_ctx ctx;
 393 
 394     if (dnd_target_receive_data(env, TARGET_MIME_URI_LIST_ATOM, &amp;ctx)) {
 395         result = uris_to_java(env, g_uri_list_extract_uris((gchar *)ctx.data), files);
 396         g_free(ctx.data);
 397     }
 398 
 399     return result;
 400 }
 401 
 402 static jobject dnd_target_get_image(JNIEnv *env)
 403 {
 404     GdkPixbuf *buf;
 405     GInputStream *stream;
 406     jobject result = NULL;
 407     GdkAtom targets[] = {
 408         TARGET_MIME_PNG_ATOM,
 409         TARGET_MIME_JPEG_ATOM,
 410         TARGET_MIME_TIFF_ATOM,
 411         TARGET_MIME_BMP_ATOM,
 412         0};
 413     GdkAtom *cur_target = targets;
 414     selection_data_ctx ctx;
 415 
 416     while(*cur_target != 0 &amp;&amp; result == NULL) {
 417         if (dnd_target_receive_data(env, *cur_target, &amp;ctx)) {
 418             stream = g_memory_input_stream_new_from_data(ctx.data, ctx.length * (ctx.format / 8),
 419                     (GDestroyNotify)g_free);
 420             buf = gdk_pixbuf_new_from_stream(stream, NULL, NULL);
 421             if (buf) {
 422                 int w;
 423                 int h;
 424                 int stride;
 425                 guchar *data;
 426                 jbyteArray data_array;
 427                 jobject buffer;
 428 
 429                 if (!gdk_pixbuf_get_has_alpha(buf)) {
 430                     GdkPixbuf *tmp_buf = gdk_pixbuf_add_alpha(buf, FALSE, 0, 0, 0);
 431                     g_object_unref(buf);
 432                     buf = tmp_buf;
 433                 }
 434 
 435                 w = gdk_pixbuf_get_width(buf);
 436                 h = gdk_pixbuf_get_height(buf);
 437                 stride = gdk_pixbuf_get_rowstride(buf);
 438                 data = gdk_pixbuf_get_pixels(buf);
 439 
 440                 //Actually, we are converting RGBA to BGRA, but that&#39;s the same operation
 441                 data = (guchar*) convert_BGRA_to_RGBA((int*) data, stride, h);
 442                 data_array = env-&gt;NewByteArray(stride * h);
 443                 EXCEPTION_OCCURED(env);
 444                 env-&gt;SetByteArrayRegion(data_array, 0, stride*h, (jbyte*) data);
 445                 EXCEPTION_OCCURED(env);
 446 
 447                 buffer = env-&gt;CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, data_array);
 448                 EXCEPTION_OCCURED(env);
 449                 result = env-&gt;NewObject(jGtkPixelsCls, jGtkPixelsInit, w, h, buffer);
 450                 EXCEPTION_OCCURED(env);
 451 
 452                 g_object_unref(buf);
 453                 g_free(data); // data from convert_BGRA_to_RGBA
 454             }
 455             g_object_unref(stream);
 456         }
 457         ++cur_target;
 458     }
 459     return result;
 460 }
 461 
 462 static jobject dnd_target_get_raw(JNIEnv *env, GdkAtom target, gboolean string_data)
 463 {
 464     selection_data_ctx ctx;
 465     jobject result = NULL;
 466     if (dnd_target_receive_data(env, target, &amp;ctx)) {
 467         if (string_data) {
 468              result = env-&gt;NewStringUTF((char *)ctx.data);
 469              EXCEPTION_OCCURED(env);
 470         } else {
 471             jsize length = ctx.length * (ctx.format / 8);
 472             jbyteArray array = env-&gt;NewByteArray(length);
 473             EXCEPTION_OCCURED(env);
 474             env-&gt;SetByteArrayRegion(array, 0, length, (const jbyte*)ctx.data);
 475             EXCEPTION_OCCURED(env);
 476             result = env-&gt;CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, array);
 477             EXCEPTION_OCCURED(env);
 478         }
 479     }
 480     g_free(ctx.data);
 481     return result;
 482 }
 483 
 484 jobject dnd_target_get_data(JNIEnv *env, jstring mime)
 485 {
 486     if (check_state_in_drag(env)) {
 487         return NULL;
 488     }
 489     const char *cmime = env-&gt;GetStringUTFChars(mime, NULL);
 490     jobject ret = NULL;
 491 
 492     init_target_atoms();
 493 
 494     if (g_strcmp0(cmime, &quot;text/plain&quot;) == 0) {
 495         ret = dnd_target_get_string(env);
 496     } else if (g_strcmp0(cmime, &quot;text/uri-list&quot;) == 0) {
 497         ret = dnd_target_get_list(env, FALSE);
 498     } else if (g_str_has_prefix(cmime, &quot;text/&quot;)) {
 499         ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), TRUE);
 500     } else if (g_strcmp0(cmime, &quot;application/x-java-file-list&quot;) == 0) {
 501         ret = dnd_target_get_list(env, TRUE);
 502     } else if (g_strcmp0(cmime, &quot;application/x-java-rawimage&quot;) == 0 ) {
 503         ret = dnd_target_get_image(env);
 504     } else {
 505         ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), FALSE);
 506     }
 507     LOG_EXCEPTION(env)
 508     env-&gt;ReleaseStringUTFChars(mime, cmime);
 509 
 510     return ret;
 511 }
 512 
 513 /************************* SOURCE *********************************************/
 514 static GdkWindow *dnd_window = NULL;
 515 static jint dnd_performed_action;
 516 
 517 const char * const SOURCE_DND_CONTEXT = &quot;fx-dnd-context&quot;;
 518 const char * const SOURCE_DND_DATA = &quot;fx-dnd-data&quot;;
 519 const char * const SOURCE_DND_ACTIONS = &quot;fx-dnd-actions&quot;;
 520 
 521 static GdkWindow* get_dnd_window()
 522 {
 523     if (dnd_window == NULL) {
 524         GdkWindowAttr attr;
 525         memset(&amp;attr, 0, sizeof (GdkWindowAttr));
 526         attr.override_redirect = TRUE;
 527         attr.window_type = GDK_WINDOW_TEMP;
 528         attr.type_hint = GDK_WINDOW_TYPE_HINT_UTILITY;
 529         attr.wclass = GDK_INPUT_OUTPUT;
 530         attr.event_mask = GDK_ALL_EVENTS_MASK;
 531         dnd_window = gdk_window_new(NULL, &amp;attr, GDK_WA_NOREDIR | GDK_WA_TYPE_HINT);
 532 
 533         gdk_window_move(dnd_window, -99, -99);
 534         gdk_window_resize(dnd_window, 1, 1);
 535         gdk_window_show(dnd_window);
 536     }
 537     return dnd_window;
 538 }
 539 
 540 static void dnd_set_performed_action(jint performed_action) {
 541     dnd_performed_action = performed_action;
 542 }
 543 
 544 static jint dnd_get_performed_action() {
 545     return dnd_performed_action;
 546 }
 547 
 548 static void dnd_pointer_grab(GdkEvent *event, GdkCursor *cursor)
 549 {
 550     glass_gdk_master_pointer_grab(event, dnd_window, cursor);
 551 }
 552 
 553 static GdkDragContext *get_drag_context() {
 554     GdkDragContext *ctx;
 555     ctx = (GdkDragContext*)g_object_get_data(G_OBJECT(dnd_window), SOURCE_DND_CONTEXT);
 556     return ctx;
 557 }
 558 
 559 static gboolean dnd_finish_callback(gpointer) {
 560     if (dnd_window) {
 561         dnd_set_performed_action(
 562                 translate_gdk_action_to_glass(
 563                     gdk_drag_context_get_selected_action(
 564                         get_drag_context())));
 565 
 566         gdk_window_destroy(dnd_window);
 567         dnd_window = NULL;
 568         DragView::reset_drag_view();
 569     }
 570 
 571     return FALSE;
 572 }
 573 
 574 #ifdef GLASS_GTK3
 575 static void dnd_finished_callback(GdkDragContext *ctx, gpointer user_data) {
 576     dnd_finish_callback(user_data);
 577 }
 578 
 579 static gboolean dnd_update_drag_view(gpointer) {
 580     gint x, y;
 581 
 582     gdk_device_get_position(gdk_drag_context_get_device(get_drag_context()),
 583                                 NULL, &amp;x, &amp;y);
 584 
 585 
 586     DragView::move(x, y);
 587 
 588     return FALSE;
 589 }
 590 #endif
 591 
 592 gboolean is_in_drag()
 593 {
 594     return dnd_window != NULL;
 595 }
 596 
 597 static void determine_actions(guint state, GdkDragAction *action, GdkDragAction *possible_actions)
 598 {
 599     GdkDragAction suggested = static_cast&lt;GdkDragAction&gt;(GPOINTER_TO_INT(g_object_get_data(G_OBJECT(dnd_window), SOURCE_DND_ACTIONS)));
 600 
 601     if (state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK)) {
 602         if ((state &amp; GDK_CONTROL_MASK) &amp;&amp; (state &amp; GDK_SHIFT_MASK) &amp;&amp; (suggested &amp; GDK_ACTION_LINK)) {
 603             *action = *possible_actions = GDK_ACTION_LINK;
 604             return;
 605         } else if ((state &amp; GDK_SHIFT_MASK) &amp;&amp; (suggested &amp; GDK_ACTION_MOVE)) {
 606             *action = *possible_actions = GDK_ACTION_MOVE;
 607             return;
 608         } else if (suggested &amp; GDK_ACTION_COPY){
 609             *action = *possible_actions = GDK_ACTION_COPY;
 610             return;
 611         }
 612     }
 613 
 614     *possible_actions = suggested;
 615 
 616     if (suggested &amp; GDK_ACTION_COPY) {
 617         *action = GDK_ACTION_COPY;
 618     } else if (suggested &amp; GDK_ACTION_MOVE) {
 619         *action = GDK_ACTION_MOVE;
 620     } else if (suggested &amp; GDK_ACTION_LINK) {
 621         *action = GDK_ACTION_LINK;
 622     } else {
 623         *action = static_cast&lt;GdkDragAction&gt;(0);
 624     }
 625 }
 626 
 627 static jobject dnd_source_get_data(const char *key)
 628 {
 629     jobject data = (jobject)g_object_get_data(G_OBJECT(dnd_window), SOURCE_DND_DATA);
 630     jstring string = mainEnv-&gt;NewStringUTF(key);
 631     EXCEPTION_OCCURED(mainEnv);
 632     jobject result = mainEnv-&gt;CallObjectMethod(data, jMapGet, string, NULL);
 633 
 634     return (EXCEPTION_OCCURED(mainEnv)) ? NULL : result;
 635 }
 636 
 637 static gboolean dnd_source_set_utf8_string(GdkWindow *requestor, GdkAtom property)
 638 {
 639     jstring string = (jstring)dnd_source_get_data(&quot;text/plain&quot;);
 640     if (!string) {
 641         return FALSE;
 642     }
 643 
 644     const char *cstring = mainEnv-&gt;GetStringUTFChars(string, NULL);
 645     if (!cstring) {
 646         return FALSE;
 647     }
 648     gint size = strlen(cstring);
 649 
 650     gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,
 651             8, GDK_PROP_MODE_REPLACE, (guchar *)cstring, size);
 652 
 653     mainEnv-&gt;ReleaseStringUTFChars(string, cstring);
 654     return TRUE;
 655 }
 656 
 657 static gboolean dnd_source_set_string(GdkWindow *requestor, GdkAtom property)
 658 {
 659     jstring string = (jstring)dnd_source_get_data(&quot;text/plain&quot;);
 660     if (!string) {
 661         return FALSE;
 662     }
 663 
 664     gboolean is_data_set = FALSE;
 665     const char *cstring = mainEnv-&gt;GetStringUTFChars(string, NULL);
 666     if (cstring) {
 667         gchar *res_str = g_convert((gchar *)cstring, -1, &quot;ISO-8859-1&quot;, &quot;UTF-8&quot;, NULL, NULL, NULL);
 668 
 669         if (res_str) {
 670             gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,
 671                     8, GDK_PROP_MODE_REPLACE, (guchar *)res_str, strlen(res_str));
 672             g_free(res_str);
 673             is_data_set = TRUE;
 674         }
 675 
 676         mainEnv-&gt;ReleaseStringUTFChars(string, cstring);
 677     }
 678     return is_data_set;
 679 }
 680 
 681 static gboolean dnd_source_set_image(GdkWindow *requestor, GdkAtom property, GdkAtom target)
 682 {
 683     jobject pixels = dnd_source_get_data(&quot;application/x-java-rawimage&quot;);
 684     if (!pixels) {
 685         return FALSE;
 686     }
 687 
 688     gchar *buffer;
 689     gsize size;
 690     const char * type;
 691     GdkPixbuf *pixbuf = NULL;
 692     gboolean result = FALSE;
 693 
 694     if (target == TARGET_MIME_PNG_ATOM) {
 695         type = &quot;png&quot;;
 696     } else if (target == TARGET_MIME_JPEG_ATOM) {
 697         type = &quot;jpeg&quot;;
 698     } else if (target == TARGET_MIME_TIFF_ATOM) {
 699         type = &quot;tiff&quot;;
 700     } else if (target == TARGET_MIME_BMP_ATOM) {
 701         type = &quot;bmp&quot;;
 702     } else {
 703         return FALSE;
 704     }
 705 
 706     mainEnv-&gt;CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&amp;pixbuf));
 707 
 708     if (!EXCEPTION_OCCURED(mainEnv)
 709             &amp;&amp; gdk_pixbuf_save_to_buffer(pixbuf, &amp;buffer, &amp;size, type, NULL, NULL)) {
 710         gdk_property_change(requestor, property, target,
 711                 8, GDK_PROP_MODE_REPLACE, (guchar *)buffer, size);
 712         result = TRUE;
 713     }
 714     g_object_unref(pixbuf);
 715     return result;
 716 }
 717 
 718 static gboolean dnd_source_set_uri_list(GdkWindow *requestor, GdkAtom property)
 719 {
 720     const gchar* url = NULL;
 721     jstring jurl = NULL;
 722 
 723     jobjectArray files_array = NULL;
 724     gsize files_cnt = 0;
 725 
 726     if (jurl = (jstring) dnd_source_get_data(&quot;text/uri-list&quot;)) {
 727         url = mainEnv-&gt;GetStringUTFChars(jurl, NULL);
 728     }
 729 
 730     if (files_array = (jobjectArray) dnd_source_get_data(&quot;application/x-java-file-list&quot;)) {
 731         files_cnt = mainEnv-&gt;GetArrayLength(files_array);
 732     }
 733     if (!url &amp;&amp; !files_cnt) {
 734         return FALSE;
 735     }
 736 
 737     GString* res = g_string_new (NULL); //http://www.ietf.org/rfc/rfc2483.txt
 738 
 739     if (files_cnt &gt; 0) {
 740         for (gsize i = 0; i &lt; files_cnt; ++i) {
 741             jstring string = (jstring) mainEnv-&gt;GetObjectArrayElement(files_array, i);
 742             EXCEPTION_OCCURED(mainEnv);
 743             const gchar* file = mainEnv-&gt;GetStringUTFChars(string, NULL);
 744             gchar* uri = g_filename_to_uri(file, NULL, NULL);
 745 
 746             g_string_append(res, uri);
 747             g_string_append(res, URI_LIST_LINE_BREAK);
 748 
 749             g_free(uri);
 750             mainEnv-&gt;ReleaseStringUTFChars(string, file);
 751         }
 752     }
 753     if (url) {
 754         g_string_append(res, url);
 755         g_string_append(res, URI_LIST_LINE_BREAK);
 756         mainEnv-&gt;ReleaseStringUTFChars(jurl, url);
 757     }
 758 
 759     gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,
 760             8, GDK_PROP_MODE_REPLACE, (guchar *) res-&gt;str, res-&gt;len);
 761 
 762     g_string_free(res, TRUE);
 763     return TRUE;
 764 }
 765 
 766 static gboolean dnd_source_set_raw(GdkWindow *requestor, GdkAtom property, GdkAtom target)
 767 {
 768     gchar *target_name = gdk_atom_name(target);
 769     jobject data = dnd_source_get_data(target_name);
 770     gboolean is_data_set = FALSE;
 771     if (data) {
 772         if (mainEnv-&gt;IsInstanceOf(data, jStringCls)) {
 773             const char *cstring = mainEnv-&gt;GetStringUTFChars((jstring)data, NULL);
 774             if (cstring) {
 775                 gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,
 776                         8, GDK_PROP_MODE_REPLACE, (guchar *) cstring, strlen(cstring));
 777 
 778                 mainEnv-&gt;ReleaseStringUTFChars((jstring)data, cstring);
 779                 is_data_set = TRUE;
 780             }
 781         } else if (mainEnv-&gt;IsInstanceOf(data, jByteBufferCls)) {
 782             jbyteArray byteArray = (jbyteArray)mainEnv-&gt;CallObjectMethod(data, jByteBufferArray);
 783             if (!EXCEPTION_OCCURED(mainEnv)) {
 784                 jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
 785                 if (raw) {
 786                     jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
 787 
 788                     gdk_property_change(requestor, property, target,
 789                             8, GDK_PROP_MODE_REPLACE, (guchar *) raw, nraw);
 790 
 791                     mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
 792                     is_data_set = TRUE;
 793                 }
 794             }
 795         }
 796     }
 797 
 798     g_free(target_name);
 799     return is_data_set;
 800 }
 801 
 802 static void process_dnd_source_selection_req(GdkWindow *window, GdkEvent *gdkEvent)
 803 {
 804     (void)window;
 805 
 806     GdkEventSelection *event = &amp;gdkEvent-&gt;selection;
 807 
 808 #ifdef GLASS_GTK3
 809     GdkWindow *requestor = (event-&gt;requestor);
 810 #else
 811     GdkWindow *requestor =
 812         gdk_x11_window_foreign_new_for_display(gdk_display_get_default(), event-&gt;requestor);
 813 #endif
 814 
 815     gboolean is_data_set = FALSE;
 816     if (event-&gt;target == TARGET_UTF8_STRING_ATOM
 817             || event-&gt;target == TARGET_MIME_TEXT_PLAIN_ATOM) {
 818         is_data_set = dnd_source_set_utf8_string(requestor, event-&gt;property);
 819     } else if (event-&gt;target == TARGET_STRING_ATOM) {
 820         is_data_set = dnd_source_set_string(requestor, event-&gt;property);
 821 //    } else if (event-&gt;target == TARGET_COMPOUND_TEXT_ATOM) { // XXX compound text
 822     } else if (target_is_image(event-&gt;target)) {
 823         is_data_set = dnd_source_set_image(requestor, event-&gt;property, event-&gt;target);
 824     } else if (event-&gt;target == TARGET_MIME_URI_LIST_ATOM) {
 825         is_data_set = dnd_source_set_uri_list(requestor, event-&gt;property);
 826     } else {
 827         is_data_set = dnd_source_set_raw(requestor, event-&gt;property, event-&gt;target);
 828     }
 829 
 830     gdk_selection_send_notify(event-&gt;requestor, event-&gt;selection, event-&gt;target,
 831                                (is_data_set) ? event-&gt;property : GDK_NONE, event-&gt;time);
 832 
 833 }
 834 
 835 static void process_dnd_source_mouse_release(GdkWindow *window, GdkEvent *event) {
 836     (void)window;
 837 
 838     glass_gdk_master_pointer_ungrab(event);
 839 
 840     if (gdk_drag_context_get_selected_action(get_drag_context())) {
 841         gdk_drag_drop(get_drag_context(), GDK_CURRENT_TIME);
 842     } else {
 843         gdk_drag_abort(get_drag_context(), GDK_CURRENT_TIME);
 844         /* let the gdk_drag_abort messages handled before finish */
 845         gdk_threads_add_idle((GSourceFunc) dnd_finish_callback, NULL);
 846     }
 847 }
 848 
 849 static void process_drag_motion(gint x_root, gint y_root, guint state)
 850 {
 851     GdkWindow *dest_window;
 852     GdkDragProtocol prot;
 853 
 854 #ifndef GLASS_GTK3
 855     // gtk3 uses a move-when-idle method
 856     DragView::move(x_root, y_root);
 857 #endif
 858 
 859     gdk_drag_find_window_for_screen(get_drag_context(), NULL, gdk_screen_get_default(),
 860             x_root, y_root, &amp;dest_window, &amp;prot);
 861 
 862     if (prot != GDK_DRAG_PROTO_NONE) {
 863         GdkDragAction action, possible_actions;
 864         determine_actions(state, &amp;action, &amp;possible_actions);
 865         gdk_drag_motion(get_drag_context(), dest_window, prot, x_root, y_root,
 866                 action, possible_actions, GDK_CURRENT_TIME);
 867     }
 868 }
 869 
 870 static void process_dnd_source_mouse_motion(GdkWindow *window, GdkEvent *event)
 871 {
 872     (void)window;
 873 
 874     GdkEventMotion *eventMotion = &amp;event-&gt;motion;
 875     process_drag_motion(eventMotion-&gt;x_root, eventMotion-&gt;y_root, eventMotion-&gt;state);
 876 }
 877 
 878 static void process_dnd_source_key_press_release(GdkWindow *window, GdkEvent *event)
 879 {
 880     (void)window;
 881 
 882     GdkEventKey *eventKey = &amp;event-&gt;key;
 883 
 884     if (eventKey-&gt;is_modifier) {
 885         guint state = eventKey-&gt;state;
 886         guint new_mod = 0;
 887         gint x,y;
 888         if (eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Control_L) ||
 889                 eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Control_R)) {
 890             new_mod = GDK_CONTROL_MASK;
 891         } else if (eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Alt_L) ||
 892                 eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Alt_R)) {
 893             new_mod = GDK_MOD1_MASK;
 894         } else if (eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Shift_L) ||
 895                 eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Shift_R)) {
 896             new_mod = GDK_SHIFT_MASK;
 897         }
 898 
 899         if (eventKey-&gt;type == GDK_KEY_PRESS) {
 900             state |= new_mod;
 901         } else {
 902             state ^= new_mod;
 903         }
 904 
 905 #ifdef GLASS_GTK3
 906         gdk_device_get_position(gdk_drag_context_get_device(get_drag_context()), NULL, &amp;x, &amp;y);
 907 #else
 908         glass_gdk_master_pointer_get_position(&amp;x, &amp;y);
 909 #endif
 910         process_drag_motion(x, y, state);
 911     }
 912 }
 913 
 914 static void process_dnd_source_drag_status(GdkWindow *window, GdkEvent *event)
 915 {
 916     (void)window;
 917 
 918     GdkEventDND *eventDnd = &amp;event-&gt;dnd;
 919     GdkDragAction selected = gdk_drag_context_get_selected_action(eventDnd-&gt;context);
 920     GdkCursor* cursor;
 921 
 922 #ifdef GLASS_GTK3
 923     // dragview shows content when dragging - this updates the position
 924     gdk_threads_add_idle_full (GDK_PRIORITY_REDRAW + 5, dnd_update_drag_view,
 925                                NULL, NULL);
 926 
 927 #endif
 928 
 929     if (selected &amp; GDK_ACTION_COPY) {
 930         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-copy&quot;);
 931         if (cursor == NULL) {
 932             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;copy&quot;);
 933         }
 934     } else if (selected &amp; (GDK_ACTION_MOVE | GDK_ACTION_PRIVATE)) {
 935         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-move&quot;);
 936         if (cursor == NULL) {
 937             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;move&quot;);
 938         }
 939         if (cursor == NULL) {
 940             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;closedhand&quot;);
 941         }
 942     } else if (selected &amp; GDK_ACTION_LINK) {
 943         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-link&quot;);
 944         if (cursor == NULL) {
 945             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;link&quot;);
 946         }
 947         if (cursor == NULL) {
 948             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;alias&quot;);
 949         }
 950     } else {
 951         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-no-drop&quot;);
 952         if (cursor == NULL) {
 953             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;no-drop&quot;);
 954         }
 955         if (cursor == NULL) {
 956             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;not-allowed&quot;);
 957         }
 958         if (cursor == NULL) {
 959             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;forbidden&quot;);
 960         }
 961         if (cursor == NULL) {
 962             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-none&quot;);
 963         }
 964     }
 965 
 966     if (cursor == NULL) {
 967         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;default&quot;);
 968     }
 969 
 970     dnd_pointer_grab(event, cursor);
 971 }
 972 
 973 static void process_dnd_source_drop_finished(GdkWindow *window, GdkEvent *event)
 974 {
 975     (void)window;
 976     (void)event;
 977 
 978     gdk_threads_add_idle((GSourceFunc) dnd_finish_callback, NULL);
 979 }
 980 
 981 void process_dnd_source(GdkWindow *window, GdkEvent *event) {
 982     switch(event-&gt;type) {
 983         case GDK_MOTION_NOTIFY:
 984             process_dnd_source_mouse_motion(window, event);
 985             break;
 986         case GDK_BUTTON_RELEASE:
 987             process_dnd_source_mouse_release(window, event);
 988             break;
 989         case GDK_DRAG_STATUS:
 990             process_dnd_source_drag_status(window, event);
 991             break;
 992         case GDK_DROP_FINISHED:
 993             process_dnd_source_drop_finished(window, event);
 994             break;
 995         case GDK_KEY_PRESS:
 996         case GDK_KEY_RELEASE:
 997             process_dnd_source_key_press_release(window, event);
 998             break;
 999         case GDK_DRAG_ENTER:
1000             gdk_selection_owner_set(dnd_window, gdk_drag_get_selection(get_drag_context()),
1001                                     GDK_CURRENT_TIME, FALSE);
1002             break;
1003         case GDK_SELECTION_REQUEST:
1004             process_dnd_source_selection_req(window, event);
1005             break;
1006         default:
1007             break;
1008     }
1009 }
1010 
1011 static void add_target_from_jstring(JNIEnv *env, GList **list, jstring string)
1012 {
1013     const char *gstring = env-&gt;GetStringUTFChars(string, NULL);
1014     if (g_strcmp0(gstring, &quot;text/plain&quot;) == 0) {
1015         *list = g_list_append(*list, TARGET_UTF8_STRING_ATOM);
1016         *list = g_list_append(*list, TARGET_MIME_TEXT_PLAIN_ATOM);
1017         *list = g_list_append(*list, TARGET_STRING_ATOM);
1018         //*list = g_list_append(list, TARGET_COMPOUND_TEXT_ATOM);
1019     } else if (g_strcmp0(gstring, &quot;application/x-java-rawimage&quot;) == 0) {
1020         *list = g_list_append(*list, TARGET_MIME_PNG_ATOM);
1021         *list = g_list_append(*list, TARGET_MIME_JPEG_ATOM);
1022         *list = g_list_append(*list, TARGET_MIME_TIFF_ATOM);
1023         *list = g_list_append(*list, TARGET_MIME_BMP_ATOM);
1024     } else if (g_strcmp0(gstring, &quot;application/x-java-file-list&quot;) == 0) {
1025         *list = g_list_append(*list, TARGET_MIME_URI_LIST_ATOM);
1026     } else {
1027         *list = g_list_append(*list, gdk_atom_intern(gstring, FALSE));
1028     }
1029     env-&gt;ReleaseStringUTFChars(string, gstring);
1030 }
1031 
1032 static GList* data_to_targets(JNIEnv *env, jobject data)
1033 {
1034     jobject keys;
1035     jobject keysIterator;
1036     jstring next;
1037 
1038     GList *list = NULL;
1039 
1040     init_target_atoms();
1041 
1042     keys = env-&gt;CallObjectMethod(data, jMapKeySet, NULL);
1043     JNI_EXCEPTION_TO_CPP(env)
1044     keysIterator = env-&gt;CallObjectMethod(keys, jIterableIterator, NULL);
1045     JNI_EXCEPTION_TO_CPP(env)
1046     while (env-&gt;CallBooleanMethod(keysIterator, jIteratorHasNext) == JNI_TRUE) {
1047         next = (jstring)env-&gt;CallObjectMethod(keysIterator, jIteratorNext, NULL);
1048         JNI_EXCEPTION_TO_CPP(env)
1049         add_target_from_jstring(env, &amp;list, next);
1050     }
1051     return list;
1052 }
1053 
1054 static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported)
1055 {
1056     GdkWindow *src_window = get_dnd_window();
1057     GList *targets;
1058     GdkDragContext *ctx;
1059 
1060     if (supported == 0) {
1061         return; // No supported actions, do nothing
1062     }
1063 
1064     targets = data_to_targets(env, data);
1065 
1066     data = env-&gt;NewGlobalRef(data);
1067 
1068     GdkDragAction actions = translate_glass_action_to_gdk(supported);
1069     g_object_set_data_full(G_OBJECT(src_window), SOURCE_DND_DATA, data, clear_global_ref);
1070     g_object_set_data(G_OBJECT(src_window), SOURCE_DND_ACTIONS, (gpointer)actions);
1071 
1072     DragView::set_drag_view();
1073 
1074 #ifdef GLASS_GTK3
1075     GdkDevice *device = gdk_device_manager_get_client_pointer(
1076                     gdk_display_get_device_manager(
1077                         gdk_display_get_default()));
1078 
1079     ctx = gdk_drag_begin_for_device(src_window, device, targets);
1080 #else
1081     ctx = gdk_drag_begin(src_window, targets);
1082 #endif
1083 
1084     g_list_free(targets);
1085     g_object_set_data(G_OBJECT(src_window), SOURCE_DND_CONTEXT, ctx);
1086 
1087 #ifdef GLASS_GTK3
1088     if (gtk_get_minor_version() &gt;= 20) {
1089         // according to GDK docs, this is only fired on managed mode, but
1090         // on 3.20+ the GDK_DROP_FINISHED event stopped working and this signal
1091         // works (even when not managed).
1092         g_signal_connect(ctx, &quot;dnd-finished&quot;,
1093             G_CALLBACK(dnd_finished_callback), NULL);
1094     }
1095 
1096     if(gdk_device_grab(device, src_window, GDK_OWNERSHIP_NONE, FALSE,
1097                     (GdkEventMask)
1098                          (GDK_POINTER_MOTION_MASK
1099                              | GDK_BUTTON_MOTION_MASK
1100                              | GDK_BUTTON1_MOTION_MASK
1101                              | GDK_BUTTON2_MOTION_MASK
1102                              | GDK_BUTTON3_MOTION_MASK
1103                              | GDK_BUTTON_RELEASE_MASK),
1104                        NULL, GDK_CURRENT_TIME) != GDK_GRAB_SUCCESS) {
1105         g_warning(&quot;Usable to grab pointer device.&quot;);
1106     }
1107 #else
1108     dnd_pointer_grab(NULL, NULL);
1109 #endif
1110 
1111     is_dnd_owner = TRUE;
1112 }
1113 
1114 jint execute_dnd(JNIEnv *env, jobject data, jint supported) {
1115     try {
1116         dnd_source_push_data(env, data, supported);
1117     } catch (jni_exception&amp;) {
1118         return 0;
1119     }
1120 
1121     while (is_in_drag()) {
1122         gtk_main_iteration();
1123     }
1124 
1125     return dnd_get_performed_action();
1126 }
1127 
1128  /******************** DRAG VIEW ***************************/
1129 DragView::View* DragView::view = NULL;
1130 
1131 void DragView::reset_drag_view() {
1132     delete view;
1133     view = NULL;
1134 }
1135 
1136 gboolean DragView::get_drag_image_offset(int* x, int* y) {
1137     gboolean offset_set = FALSE;
1138     jobject bb = dnd_source_get_data(&quot;application/x-java-drag-image-offset&quot;);
1139     if (bb) {
1140         jbyteArray byteArray = (jbyteArray)mainEnv-&gt;CallObjectMethod(bb, jByteBufferArray);
1141         if (!EXCEPTION_OCCURED(mainEnv)) {
1142             jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
1143             jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
1144 
1145             if ((size_t) nraw &gt;= sizeof(jint) * 2) {
1146                 jint* r = (jint*) raw;
1147                 *x = BSWAP_32(r[0]);
1148                 *y = BSWAP_32(r[1]);
1149                 offset_set = TRUE;
1150             }
1151 
1152             mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
1153         }
1154     }
1155     return offset_set;
1156 }
1157 
1158 static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer) {
1159     if (pixels != NULL) {
1160         g_free(pixels);
1161     }
1162 }
1163 
1164 GdkPixbuf* DragView::get_drag_image(gboolean* is_raw_image, gint* width, gint* height) {
1165     GdkPixbuf *pixbuf = NULL;
1166     gboolean is_raw = FALSE;
1167 
1168     jobject drag_image = dnd_source_get_data(&quot;application/x-java-drag-image&quot;);
1169 
1170     if (drag_image) {
1171         jbyteArray byteArray = (jbyteArray) mainEnv-&gt;CallObjectMethod(drag_image, jByteBufferArray);
1172         if (!EXCEPTION_OCCURED(mainEnv)) {
1173 
1174             jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
1175             jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
1176 
1177             int w = 0, h = 0;
1178             int whsz = sizeof(jint) * 2; // Pixels are stored right after two ints
1179                                          // in this byteArray: width and height
1180             if (nraw &gt; whsz) {
1181                 jint* int_raw = (jint*) raw;
1182                 w = BSWAP_32(int_raw[0]);
1183                 h = BSWAP_32(int_raw[1]);
1184 
1185                 // We should have enough pixels for requested width and height
1186                 if ((nraw - whsz) / 4 - w * h &gt;= 0 ) {
1187                     guchar* data = (guchar*) g_try_malloc0(nraw - whsz);
1188                     if (data) {
1189                         memcpy(data, (raw + whsz), nraw - whsz);
1190                         pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,
1191                                 w, h, w * 4, pixbufDestroyNotifyFunc, NULL);
1192                     }
1193                 }
1194             }
1195             mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
1196         }
1197     }
1198 
1199     if (!GDK_IS_PIXBUF(pixbuf)) {
1200         jobject pixels = dnd_source_get_data(&quot;application/x-java-rawimage&quot;);
1201         if (pixels) {
1202             is_raw = TRUE;
1203             mainEnv-&gt;CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&amp;pixbuf));
1204             CHECK_JNI_EXCEPTION_RET(mainEnv, NULL)
1205         }
1206     }
1207 
1208     if (!GDK_IS_PIXBUF(pixbuf)) {
1209         return NULL;
1210     }
1211 
1212     int w = gdk_pixbuf_get_width(pixbuf);
1213     int h = gdk_pixbuf_get_height(pixbuf);
1214 
1215     if (w &gt; DRAG_IMAGE_MAX_WIDTH || h &gt; DRAG_IMAGE_MAX_HEIGH) {
1216         double rw = DRAG_IMAGE_MAX_WIDTH / (double)w;
1217         double rh =  DRAG_IMAGE_MAX_HEIGH / (double)h;
1218         double r = MIN(rw, rh);
1219 
1220 
1221         int new_w = w * r;
1222         int new_h = h * r;
1223 
1224         w = new_w;
1225         h = new_h;
1226 
1227         GdkPixbuf *tmp_pixbuf = gdk_pixbuf_scale_simple(pixbuf, new_w, new_h, GDK_INTERP_TILES);
1228         g_object_unref(pixbuf);
1229         if (!GDK_IS_PIXBUF(tmp_pixbuf)) {
1230             return NULL;
1231         }
1232         pixbuf = tmp_pixbuf;
1233     }
1234 
1235     *is_raw_image = is_raw;
1236     *width = w;
1237     *height = h;
1238 
1239     return pixbuf;
1240 }
1241 
1242 void DragView::set_drag_view() {
1243     reset_drag_view();
1244 
1245     gboolean is_raw_image = FALSE;
1246     gint w = 0, h = 0;
1247     GdkPixbuf* pixbuf = get_drag_image(&amp;is_raw_image, &amp;w, &amp;h);
1248 
1249     if (GDK_IS_PIXBUF(pixbuf)) {
1250         gint offset_x = w / 2;
1251         gint offset_y = h / 2;
1252 
1253         gboolean is_offset_set = get_drag_image_offset(&amp;offset_x, &amp;offset_y);
1254 
1255         DragView::view = new DragView::View(pixbuf, is_raw_image, is_offset_set, offset_x, offset_y);
1256     }
1257 }
1258 void DragView::move(gint x, gint y) {
1259     if (view) {
1260         view-&gt;move(x, y);
1261     }
1262 }
1263 
1264 static void on_screen_changed(GtkWidget *widget, GdkScreen *previous_screen, gpointer view) {
1265     (void)widget;
1266     (void)previous_screen;
1267 
1268     ((DragView::View*) view)-&gt;screen_changed();
1269 }
1270 
1271 static gboolean on_draw(GtkWidget *widget, cairo_t *cr, gpointer view) {
1272     (void)widget;
1273 
1274     ((DragView::View*) view)-&gt;expose(cr);
1275     return FALSE;
1276 }
1277 
1278 static gboolean on_expose(GtkWidget *widget, GdkEventExpose *event, gpointer view) {
1279     (void)widget;
1280     (void)event;
1281 
1282     ((DragView::View*) view)-&gt;expose(NULL);
1283     return FALSE;
1284 }
1285 
1286 DragView::View::View(GdkPixbuf* _pixbuf, gboolean _is_raw_image,
1287                                 gboolean _is_offset_set, gint _offset_x, gint _offset_y) :
1288         pixbuf(_pixbuf),
1289         is_raw_image(_is_raw_image),
1290         is_offset_set(_is_offset_set),
1291         offset_x(_offset_x),
1292         offset_y(_offset_y)
1293 {
1294     width = gdk_pixbuf_get_width(pixbuf);
1295     height = gdk_pixbuf_get_height(pixbuf);
1296 
1297     widget = gtk_window_new(GTK_WINDOW_POPUP);
1298     gtk_window_set_type_hint(GTK_WINDOW(widget), GDK_WINDOW_TYPE_HINT_DND);
1299     gtk_widget_set_events(widget, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK);
1300 
1301     screen_changed();
1302 
1303     gtk_widget_realize(widget);
1304 
1305     gtk_widget_set_app_paintable(widget, TRUE);
1306 
1307 #ifdef GLASS_GTK3
1308     g_signal_connect(G_OBJECT(widget), &quot;draw&quot;, G_CALLBACK(on_draw), this);
1309 #else
1310     g_signal_connect(G_OBJECT(widget), &quot;expose-event&quot;, G_CALLBACK(on_expose), this);
1311 #endif
1312     g_signal_connect(G_OBJECT(widget), &quot;screen-changed&quot;, G_CALLBACK(on_screen_changed), this);
1313 
1314     gtk_widget_set_size_request(widget, width, height);
1315 
1316     gtk_window_set_decorated(GTK_WINDOW(widget), FALSE);
1317     gtk_window_set_opacity(GTK_WINDOW(widget), .7);
1318 }
1319 
1320 void DragView::View::screen_changed() {
1321     GdkScreen *screen = gtk_widget_get_screen(widget);
1322 
1323     glass_configure_window_transparency(widget, true);
1324 
1325     if (!gdk_screen_is_composited(screen)) {
1326         if (!is_offset_set) {
1327             offset_x = 1;
1328             offset_y = 1;
1329         }
1330     }
1331 }
1332 
1333 void DragView::View::expose(cairo_t *context) {
1334 #ifndef GLASS_GTK3
1335     context = gdk_cairo_create(gtk_widget_get_window(widget));
1336 #endif
1337     cairo_surface_t* cairo_surface;
1338 
1339     guchar* pixels = is_raw_image
1340             ? (guchar*) convert_BGRA_to_RGBA((const int*) gdk_pixbuf_get_pixels(pixbuf),
1341                                                 gdk_pixbuf_get_rowstride(pixbuf),
1342                                                 height)
1343             : gdk_pixbuf_get_pixels(pixbuf);
1344 
1345     cairo_surface = cairo_image_surface_create_for_data(
1346             pixels,
1347             CAIRO_FORMAT_ARGB32,
1348             width, height, width * 4);
1349 
1350     cairo_set_source_surface(context, cairo_surface, 0, 0);
1351     cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
1352     cairo_paint(context);
1353 
1354     if (is_raw_image) {
1355         g_free(pixels);
1356     }
1357 
1358     cairo_surface_destroy(cairo_surface);
1359 
1360 #ifndef GLASS_GTK3
1361     cairo_destroy(context);
1362 #endif
1363 }
1364 
1365 void DragView::View::move(gint x, gint y) {
1366 #ifdef GLASS_GTK3
1367     // gtk3 method uses a move-when-idle method
1368     gtk_window_move(GTK_WINDOW(widget), x - offset_x, y - offset_y);
1369 #else
1370     if (!gtk_events_pending()) { // avoid sluggish window move
1371         gtk_window_move(GTK_WINDOW(widget), x - offset_x, y - offset_y);
1372     }
1373 #endif
1374 
1375     if (gtk_widget_get_visible(widget)) {
1376         gdk_window_raise(gtk_widget_get_window(widget));
1377     }
1378     else {
1379         gtk_widget_show(widget);
1380     }
1381 }
1382 
1383 DragView::View::~View() {
1384     if (widget) {
1385         gtk_widget_destroy(widget);
1386         widget == NULL;
1387     }
1388     if (pixbuf) {
1389         g_object_unref(pixbuf);
1390         pixbuf == NULL;
1391     }
1392 }
    </pre>
  </body>
</html>