<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &quot;glass_dnd.h&quot;
  26 #include &quot;glass_general.h&quot;
  27 #include &quot;glass_evloop.h&quot;
  28 
  29 #include &quot;com_sun_glass_events_DndEvent.h&quot;
  30 #include &quot;com_sun_glass_ui_gtk_GtkDnDClipboard.h&quot;
  31 
  32 #include &lt;jni.h&gt;
  33 #include &lt;cstring&gt;
  34 
  35 #include &lt;gtk/gtk.h&gt;
  36 #include &lt;gdk/gdkx.h&gt;
  37 #include &lt;gdk/gdkkeysyms.h&gt;
  38 
  39 /************************* COMMON *********************************************/
  40 static jint translate_gdk_action_to_glass(GdkDragAction action)
  41 {
  42     jint result = 0;
  43     result |= (action &amp; GDK_ACTION_COPY)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY : 0;
  44     result |= (action &amp; GDK_ACTION_MOVE)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE : 0;
  45     result |= (action &amp; GDK_ACTION_LINK)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE : 0;
  46     return result;
  47 }
  48 
  49 static GdkDragAction translate_glass_action_to_gdk(jint action)
  50 {
  51     int result = 0;
  52     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY)? GDK_ACTION_COPY : 0;
  53     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE)? GDK_ACTION_MOVE : 0;
  54     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE)? GDK_ACTION_LINK : 0;
  55     return static_cast&lt;GdkDragAction&gt;(result);
  56 }
  57 
  58 static gboolean target_atoms_initialized = FALSE;
  59 static GdkAtom TARGET_UTF8_STRING_ATOM;
  60 static GdkAtom TARGET_MIME_TEXT_PLAIN_ATOM;
  61 static GdkAtom TARGET_COMPOUND_TEXT_ATOM;
  62 static GdkAtom TARGET_STRING_ATOM;
  63 
  64 static GdkAtom TARGET_MIME_URI_LIST_ATOM;
  65 
  66 static GdkAtom TARGET_MIME_PNG_ATOM;
  67 static GdkAtom TARGET_MIME_JPEG_ATOM;
  68 static GdkAtom TARGET_MIME_TIFF_ATOM;
  69 static GdkAtom TARGET_MIME_BMP_ATOM;
  70 
  71 static void init_target_atoms()
  72 {
  73     if (target_atoms_initialized) {
  74         return;
  75     }
  76     TARGET_UTF8_STRING_ATOM = gdk_atom_intern_static_string(&quot;UTF8_STRING&quot;);
  77     TARGET_MIME_TEXT_PLAIN_ATOM = gdk_atom_intern_static_string(&quot;text/plain&quot;);
  78     TARGET_COMPOUND_TEXT_ATOM = gdk_atom_intern_static_string(&quot;COMPOUND_TEXT&quot;);
  79     TARGET_STRING_ATOM = gdk_atom_intern_static_string(&quot;STRING&quot;);
  80 
  81     TARGET_MIME_URI_LIST_ATOM = gdk_atom_intern_static_string(&quot;text/uri-list&quot;);
  82 
  83     TARGET_MIME_PNG_ATOM = gdk_atom_intern_static_string(&quot;image/png&quot;);
  84     TARGET_MIME_JPEG_ATOM = gdk_atom_intern_static_string(&quot;image/jpeg&quot;);
  85     TARGET_MIME_TIFF_ATOM = gdk_atom_intern_static_string(&quot;image/tiff&quot;);
  86     TARGET_MIME_BMP_ATOM = gdk_atom_intern_static_string(&quot;image/bmp&quot;);
  87 
  88     target_atoms_initialized = TRUE;
  89 }
  90 
  91 static gboolean target_is_text(GdkAtom target)
  92 {
  93     init_target_atoms();
  94 
  95     return (target == TARGET_UTF8_STRING_ATOM ||
  96             target == TARGET_STRING_ATOM ||
  97             target == TARGET_MIME_TEXT_PLAIN_ATOM/* ||
  98             target == TARGET_COMPOUND_TEXT_ATOM*/);
  99 }
 100 
 101 static gboolean target_is_uri(GdkAtom target)
 102 {
 103     init_target_atoms();
 104     return target == TARGET_MIME_URI_LIST_ATOM;
 105 }
 106 
 107 static gboolean target_is_image(GdkAtom target)
 108 {
 109     init_target_atoms();
 110     return (target == TARGET_MIME_PNG_ATOM ||
 111             target == TARGET_MIME_JPEG_ATOM ||
 112             target == TARGET_MIME_TIFF_ATOM ||
 113             target == TARGET_MIME_BMP_ATOM);
 114 }
 115 
 116 static void clear_global_ref(gpointer data)
 117 {
 118     mainEnv-&gt;DeleteGlobalRef((jobject)data);
 119 }
 120 
 121 static void dnd_set_performed_action(jint performed_action);
 122 static jint dnd_get_performed_action();
 123 
 124 /************************* TARGET *********************************************/
 125 struct selection_data_ctx {
 126     gboolean received;
 127     guchar *data;
 128     GdkAtom type;
 129     gint format;
 130     gint length;
 131 };
 132 
 133 static gboolean dnd_target_receive_data(JNIEnv *env, GdkAtom target, selection_data_ctx *selection_ctx);
 134 
 135 static struct {
 136     GdkDragContext *ctx;
 137     gboolean just_entered;
 138     jobjectArray mimes;
 139     gint dx, dy;
 140 } enter_ctx = {NULL, FALSE, NULL, 0, 0};
 141 
 142 gboolean is_dnd_owner = FALSE;
 143 
<a name="1" id="anc1"></a>





 144 static void reset_enter_ctx() {
 145     if (enter_ctx.mimes != NULL) {
 146         mainEnv-&gt;DeleteGlobalRef(enter_ctx.mimes);
 147     }
 148 
 149     memset(&amp;enter_ctx, 0, sizeof(enter_ctx));
 150 }
 151 
 152 static void process_dnd_target_drag_enter(WindowContext *ctx, GdkEventDND *event)
 153 {
 154     reset_enter_ctx();
 155     enter_ctx.ctx = event-&gt;context;
 156     enter_ctx.just_entered = TRUE;
 157     gdk_window_get_origin(ctx-&gt;get_gdk_window(), &amp;enter_ctx.dx, &amp;enter_ctx.dy);
 158     is_dnd_owner = is_in_drag();
 159 }
 160 
 161 static void process_dnd_target_drag_motion(WindowContext *ctx, GdkEventDND *event)
 162 {
 163     if (!enter_ctx.ctx) {
 164         gdk_drag_status(event-&gt;context, static_cast&lt;GdkDragAction&gt;(0), GDK_CURRENT_TIME);
 165         return; // Do not process motion events if no enter event was received
 166     }
 167     jmethodID method = enter_ctx.just_entered ? jViewNotifyDragEnter : jViewNotifyDragOver;
 168     GdkDragAction suggested = gdk_drag_context_get_suggested_action(event-&gt;context);
 169     GdkDragAction result = translate_glass_action_to_gdk(mainEnv-&gt;CallIntMethod(ctx-&gt;get_jview(), method,
 170             (jint)event-&gt;x_root - enter_ctx.dx, (jint)event-&gt;y_root - enter_ctx.dy,
 171             (jint)event-&gt;x_root, (jint)event-&gt;y_root,
 172             translate_gdk_action_to_glass(suggested)));
 173     CHECK_JNI_EXCEPTION(mainEnv)
 174 
 175     if (enter_ctx.just_entered) {
 176         enter_ctx.just_entered = FALSE;
 177     }
 178     gdk_drag_status(event-&gt;context, result, GDK_CURRENT_TIME);
 179 }
 180 
 181 static void process_dnd_target_drag_leave(WindowContext *ctx, GdkEventDND *event)
 182 {
 183     (void)event;
 184 
 185     mainEnv-&gt;CallVoidMethod(ctx-&gt;get_jview(), jViewNotifyDragLeave, NULL);
 186     CHECK_JNI_EXCEPTION(mainEnv)
 187 }
 188 
 189 static void process_dnd_target_drop_start(WindowContext *ctx, GdkEventDND *event)
 190 {
 191     if (!enter_ctx.ctx || enter_ctx.just_entered) {
 192         gdk_drop_finish(event-&gt;context, FALSE, GDK_CURRENT_TIME);
 193         gdk_drop_reply(event-&gt;context, FALSE, GDK_CURRENT_TIME);
 194         return; // Do not process drop events if no enter event and subsequent motion event were received
 195     }
 196     GdkDragAction selected = gdk_drag_context_get_selected_action(event-&gt;context);
 197 
 198     mainEnv-&gt;CallIntMethod(ctx-&gt;get_jview(), jViewNotifyDragDrop,
 199             (jint)event-&gt;x_root - enter_ctx.dx, (jint)event-&gt;y_root - enter_ctx.dy,
 200             (jint)event-&gt;x_root, (jint)event-&gt;y_root,
 201             translate_gdk_action_to_glass(selected));
 202     LOG_EXCEPTION(mainEnv)
 203 
 204     gdk_drop_finish(event-&gt;context, TRUE, GDK_CURRENT_TIME);
 205     gdk_drop_reply(event-&gt;context, TRUE, GDK_CURRENT_TIME);
 206 }
 207 
 208 static gboolean check_state_in_drag(JNIEnv *env)
 209 {
 210     if (!enter_ctx.ctx) {
 211         jclass jc = env-&gt;FindClass(&quot;java/lang/IllegalStateException&quot;);
 212         if (!env-&gt;ExceptionCheck()) {
 213             env-&gt;ThrowNew(jc,
 214                     &quot;Cannot get supported actions. Drag pointer haven&#39;t entered the application window&quot;);
 215         }
 216         return TRUE;
 217     }
 218     return FALSE;
 219 }
 220 
 221 // Events coming from application that are related to us being a DnD target
 222 void process_dnd_target(WindowContext *ctx, GdkEventDND *event)
 223 {
 224     switch (event-&gt;type) {
 225         case GDK_DRAG_ENTER:
 226             process_dnd_target_drag_enter(ctx, event);
 227             break;
 228         case GDK_DRAG_MOTION:
 229             process_dnd_target_drag_motion(ctx, event);
 230             break;
 231         case GDK_DRAG_LEAVE:
 232             process_dnd_target_drag_leave(ctx, event);
 233             break;
 234         case GDK_DROP_START:
 235             process_dnd_target_drop_start(ctx, event);
 236             break;
 237         default:
 238             break;
 239     }
 240 }
 241 
 242 jobjectArray dnd_target_get_mimes(JNIEnv *env)
 243 {
 244     if (check_state_in_drag(env)) {
 245         return NULL;
 246     }
 247     if (!enter_ctx.mimes) {
 248         GList* targets = gdk_drag_context_list_targets(enter_ctx.ctx);
 249         jobject set = env-&gt;NewObject(jHashSetCls, jHashSetInit, NULL);
 250         EXCEPTION_OCCURED(env);
 251 
 252         while (targets) {
 253             GdkAtom target = GDK_POINTER_TO_ATOM(targets-&gt;data);
 254             gchar *name = gdk_atom_name(target);
 255 
 256             if (target_is_text(target)) {
 257                 jstring jStr = env-&gt;NewStringUTF(&quot;text/plain&quot;);
 258                 EXCEPTION_OCCURED(env);
 259                 env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);
 260                 EXCEPTION_OCCURED(env);
 261             }
 262 
 263             if (target_is_image(target)) {
 264                 jstring jStr = env-&gt;NewStringUTF(&quot;application/x-java-rawimage&quot;);
 265                 EXCEPTION_OCCURED(env);
 266                 env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);
 267                 EXCEPTION_OCCURED(env);
 268             }
 269 
 270             if (target_is_uri(target)) {
 271                 selection_data_ctx ctx;
 272                 if (dnd_target_receive_data(env, TARGET_MIME_URI_LIST_ATOM, &amp;ctx)) {
 273                     gchar** uris = g_uri_list_extract_uris((gchar *) ctx.data);
 274                     guint size = g_strv_length(uris);
 275                     guint files_cnt = get_files_count(uris);
 276                     if (files_cnt) {
 277                         jstring jStr = env-&gt;NewStringUTF(&quot;application/x-java-file-list&quot;);
 278                         EXCEPTION_OCCURED(env);
 279                         env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);
 280                         EXCEPTION_OCCURED(env);
 281                     }
 282                     if (size - files_cnt) {
 283                         jstring jStr = env-&gt;NewStringUTF(&quot;text/uri-list&quot;);
 284                         EXCEPTION_OCCURED(env);
 285                         env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);
 286                         EXCEPTION_OCCURED(env);
 287                     }
 288                     g_strfreev(uris);
 289                 }
 290                 g_free(ctx.data);
 291             } else {
 292                 jstring jStr = env-&gt;NewStringUTF(name);
 293                 EXCEPTION_OCCURED(env);
 294                 env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);
 295                 EXCEPTION_OCCURED(env);
 296             }
 297 
 298             g_free(name);
 299             targets = targets-&gt;next;
 300         }
 301         enter_ctx.mimes = env-&gt;NewObjectArray(env-&gt;CallIntMethod(set, jSetSize, NULL),
 302                 jStringCls, NULL);
 303         EXCEPTION_OCCURED(env);
 304         enter_ctx.mimes = (jobjectArray)env-&gt;CallObjectMethod(set, jSetToArray, enter_ctx.mimes, NULL);
 305         enter_ctx.mimes = (jobjectArray)env-&gt;NewGlobalRef(enter_ctx.mimes);
 306     }
 307     return enter_ctx.mimes;
 308 }
 309 
 310 jint dnd_target_get_supported_actions(JNIEnv *env)
 311 {
 312     if (check_state_in_drag(env)) {
 313         return 0;
 314     }
 315     return translate_gdk_action_to_glass(gdk_drag_context_get_actions(enter_ctx.ctx));
 316 }
 317 
 318 static void wait_for_selection_data_hook(GdkEvent * event, void * data)
 319 {
 320     selection_data_ctx *ctx = (selection_data_ctx*)data;
 321     GdkWindow *dest = glass_gdk_drag_context_get_dest_window(enter_ctx.ctx);
 322     if (event-&gt;type == GDK_SELECTION_NOTIFY &amp;&amp;
 323             event-&gt;selection.window == dest) {
 324         if (event-&gt;selection.property) { // if 0, that we received negative response
 325             ctx-&gt;length = gdk_selection_property_get(dest, &amp;(ctx-&gt;data), &amp;(ctx-&gt;type), &amp;(ctx-&gt;format));
 326         }
 327         ctx-&gt;received = TRUE;
 328     }
 329 }
 330 
 331 static gboolean dnd_target_receive_data(JNIEnv *env, GdkAtom target, selection_data_ctx *selection_ctx)
 332 {
 333     GevlHookRegistration hookReg;
 334 
 335     memset(selection_ctx, 0, sizeof(selection_data_ctx));
 336 
 337     gdk_selection_convert(glass_gdk_drag_context_get_dest_window(enter_ctx.ctx), gdk_drag_get_selection(enter_ctx.ctx), target,
 338                           GDK_CURRENT_TIME);
 339 
 340     hookReg =
 341             glass_evloop_hook_add(
 342                     (GevlHookFunction) wait_for_selection_data_hook,
 343                     selection_ctx);
 344     if (HANDLE_MEM_ALLOC_ERROR(env, hookReg,
 345                                &quot;Failed to allocate event hook&quot;)) {
 346         return TRUE;
 347     }
 348 
 349     do {
 350         gtk_main_iteration();
 351     } while (!(selection_ctx-&gt;received));
 352 
 353 
 354     glass_evloop_hook_remove(hookReg);
 355     return selection_ctx-&gt;data != NULL;
 356 }
 357 
 358 static jobject dnd_target_get_string(JNIEnv *env)
 359 {
 360     jobject result = NULL;
 361     selection_data_ctx ctx;
 362 
 363     if (dnd_target_receive_data(env, TARGET_UTF8_STRING_ATOM, &amp;ctx)) {
 364         result = env-&gt;NewStringUTF((char *)ctx.data);
 365         EXCEPTION_OCCURED(env);
 366         g_free(ctx.data);
 367     }
 368     if (!result &amp;&amp; dnd_target_receive_data(env, TARGET_MIME_TEXT_PLAIN_ATOM, &amp;ctx)) {
 369         result = env-&gt;NewStringUTF((char *)ctx.data);
 370         EXCEPTION_OCCURED(env);
 371         g_free(ctx.data);
 372     }
 373     // TODO find out how to convert from compound text
 374     // if (!result &amp;&amp; dnd_target_receive_data(env, TARGET_COMPOUND_TEXT_ATOM, &amp;ctx)) {
 375     // }
 376     if (!result &amp;&amp; dnd_target_receive_data(env, TARGET_STRING_ATOM, &amp;ctx)) {
 377         gchar *str;
 378         str = g_convert( (gchar *)ctx.data, -1, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, NULL, NULL, NULL);
 379         if (str != NULL) {
 380             result = env-&gt;NewStringUTF(str);
 381             EXCEPTION_OCCURED(env);
 382             g_free(str);
 383         }
 384         g_free(ctx.data);
 385     }
 386     return result;
 387 }
 388 
 389 static jobject dnd_target_get_list(JNIEnv *env, gboolean files)
 390 {
 391     jobject result = NULL;
 392     selection_data_ctx ctx;
 393 
 394     if (dnd_target_receive_data(env, TARGET_MIME_URI_LIST_ATOM, &amp;ctx)) {
 395         result = uris_to_java(env, g_uri_list_extract_uris((gchar *)ctx.data), files);
 396         g_free(ctx.data);
 397     }
 398 
 399     return result;
 400 }
 401 
 402 static jobject dnd_target_get_image(JNIEnv *env)
 403 {
 404     GdkPixbuf *buf;
 405     GInputStream *stream;
 406     jobject result = NULL;
 407     GdkAtom targets[] = {
 408         TARGET_MIME_PNG_ATOM,
 409         TARGET_MIME_JPEG_ATOM,
 410         TARGET_MIME_TIFF_ATOM,
 411         TARGET_MIME_BMP_ATOM,
 412         0};
 413     GdkAtom *cur_target = targets;
 414     selection_data_ctx ctx;
 415 
 416     while(*cur_target != 0 &amp;&amp; result == NULL) {
 417         if (dnd_target_receive_data(env, *cur_target, &amp;ctx)) {
 418             stream = g_memory_input_stream_new_from_data(ctx.data, ctx.length * (ctx.format / 8),
 419                     (GDestroyNotify)g_free);
 420             buf = gdk_pixbuf_new_from_stream(stream, NULL, NULL);
 421             if (buf) {
 422                 int w;
 423                 int h;
 424                 int stride;
 425                 guchar *data;
 426                 jbyteArray data_array;
 427                 jobject buffer;
 428 
 429                 if (!gdk_pixbuf_get_has_alpha(buf)) {
 430                     GdkPixbuf *tmp_buf = gdk_pixbuf_add_alpha(buf, FALSE, 0, 0, 0);
 431                     g_object_unref(buf);
 432                     buf = tmp_buf;
 433                 }
 434 
 435                 w = gdk_pixbuf_get_width(buf);
 436                 h = gdk_pixbuf_get_height(buf);
 437                 stride = gdk_pixbuf_get_rowstride(buf);
 438                 data = gdk_pixbuf_get_pixels(buf);
 439 
 440                 //Actually, we are converting RGBA to BGRA, but that&#39;s the same operation
 441                 data = (guchar*) convert_BGRA_to_RGBA((int*) data, stride, h);
 442                 data_array = env-&gt;NewByteArray(stride * h);
 443                 EXCEPTION_OCCURED(env);
 444                 env-&gt;SetByteArrayRegion(data_array, 0, stride*h, (jbyte*) data);
 445                 EXCEPTION_OCCURED(env);
 446 
 447                 buffer = env-&gt;CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, data_array);
 448                 EXCEPTION_OCCURED(env);
 449                 result = env-&gt;NewObject(jGtkPixelsCls, jGtkPixelsInit, w, h, buffer);
 450                 EXCEPTION_OCCURED(env);
 451 
 452                 g_object_unref(buf);
 453                 g_free(data); // data from convert_BGRA_to_RGBA
 454             }
 455             g_object_unref(stream);
 456         }
 457         ++cur_target;
 458     }
 459     return result;
 460 }
 461 
 462 static jobject dnd_target_get_raw(JNIEnv *env, GdkAtom target, gboolean string_data)
 463 {
 464     selection_data_ctx ctx;
 465     jobject result = NULL;
 466     if (dnd_target_receive_data(env, target, &amp;ctx)) {
 467         if (string_data) {
 468              result = env-&gt;NewStringUTF((char *)ctx.data);
 469              EXCEPTION_OCCURED(env);
 470         } else {
 471             jsize length = ctx.length * (ctx.format / 8);
 472             jbyteArray array = env-&gt;NewByteArray(length);
 473             EXCEPTION_OCCURED(env);
 474             env-&gt;SetByteArrayRegion(array, 0, length, (const jbyte*)ctx.data);
 475             EXCEPTION_OCCURED(env);
 476             result = env-&gt;CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, array);
 477             EXCEPTION_OCCURED(env);
 478         }
 479     }
 480     g_free(ctx.data);
 481     return result;
 482 }
 483 
 484 jobject dnd_target_get_data(JNIEnv *env, jstring mime)
 485 {
 486     if (check_state_in_drag(env)) {
 487         return NULL;
 488     }
 489     const char *cmime = env-&gt;GetStringUTFChars(mime, NULL);
 490     jobject ret = NULL;
 491 
 492     init_target_atoms();
 493 
 494     if (g_strcmp0(cmime, &quot;text/plain&quot;) == 0) {
 495         ret = dnd_target_get_string(env);
 496     } else if (g_strcmp0(cmime, &quot;text/uri-list&quot;) == 0) {
 497         ret = dnd_target_get_list(env, FALSE);
 498     } else if (g_str_has_prefix(cmime, &quot;text/&quot;)) {
 499         ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), TRUE);
 500     } else if (g_strcmp0(cmime, &quot;application/x-java-file-list&quot;) == 0) {
 501         ret = dnd_target_get_list(env, TRUE);
 502     } else if (g_strcmp0(cmime, &quot;application/x-java-rawimage&quot;) == 0 ) {
 503         ret = dnd_target_get_image(env);
 504     } else {
 505         ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), FALSE);
 506     }
 507     LOG_EXCEPTION(env)
 508     env-&gt;ReleaseStringUTFChars(mime, cmime);
 509 
 510     return ret;
 511 }
 512 
 513 /************************* SOURCE *********************************************/
<a name="2" id="anc2"></a><span class="line-modified"> 514 static GdkWindow *dnd_window = NULL;</span>

 515 static jint dnd_performed_action;
 516 
<a name="3" id="anc3"></a><span class="line-removed"> 517 const char * const SOURCE_DND_CONTEXT = &quot;fx-dnd-context&quot;;</span>
 518 const char * const SOURCE_DND_DATA = &quot;fx-dnd-data&quot;;
<a name="4" id="anc4"></a><span class="line-removed"> 519 const char * const SOURCE_DND_ACTIONS = &quot;fx-dnd-actions&quot;;</span>
 520 
<a name="5" id="anc5"></a><span class="line-modified"> 521 static GdkWindow* get_dnd_window()</span>
 522 {
<a name="6" id="anc6"></a><span class="line-removed"> 523     if (dnd_window == NULL) {</span>
<span class="line-removed"> 524         GdkWindowAttr attr;</span>
<span class="line-removed"> 525         memset(&amp;attr, 0, sizeof (GdkWindowAttr));</span>
<span class="line-removed"> 526         attr.override_redirect = TRUE;</span>
<span class="line-removed"> 527         attr.window_type = GDK_WINDOW_TEMP;</span>
<span class="line-removed"> 528         attr.type_hint = GDK_WINDOW_TYPE_HINT_UTILITY;</span>
<span class="line-removed"> 529         attr.wclass = GDK_INPUT_OUTPUT;</span>
<span class="line-removed"> 530         attr.event_mask = GDK_ALL_EVENTS_MASK;</span>
<span class="line-removed"> 531         dnd_window = gdk_window_new(NULL, &amp;attr, GDK_WA_NOREDIR | GDK_WA_TYPE_HINT);</span>
<span class="line-removed"> 532 </span>
<span class="line-removed"> 533         gdk_window_move(dnd_window, -99, -99);</span>
<span class="line-removed"> 534         gdk_window_resize(dnd_window, 1, 1);</span>
<span class="line-removed"> 535         gdk_window_show(dnd_window);</span>
<span class="line-removed"> 536     }</span>
<span class="line-removed"> 537     return dnd_window;</span>
<span class="line-removed"> 538 }</span>
<span class="line-removed"> 539 </span>
<span class="line-removed"> 540 static void dnd_set_performed_action(jint performed_action) {</span>
 541     dnd_performed_action = performed_action;
 542 }
 543 
<a name="7" id="anc7"></a><span class="line-modified"> 544 static jint dnd_get_performed_action() {</span>

 545     return dnd_performed_action;
 546 }
 547 
<a name="8" id="anc8"></a><span class="line-modified"> 548 static void dnd_pointer_grab(GdkEvent *event, GdkCursor *cursor)</span>
 549 {
<a name="9" id="anc9"></a><span class="line-modified"> 550     glass_gdk_master_pointer_grab(event, dnd_window, cursor);</span>
<span class="line-modified"> 551 }</span>
<span class="line-removed"> 552 </span>
<span class="line-removed"> 553 static GdkDragContext *get_drag_context() {</span>
<span class="line-removed"> 554     GdkDragContext *ctx;</span>
<span class="line-removed"> 555     ctx = (GdkDragContext*)g_object_get_data(G_OBJECT(dnd_window), SOURCE_DND_CONTEXT);</span>
<span class="line-removed"> 556     return ctx;</span>
<span class="line-removed"> 557 }</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559 static gboolean dnd_finish_callback(gpointer) {</span>
<span class="line-removed"> 560     if (dnd_window) {</span>
<span class="line-removed"> 561         dnd_set_performed_action(</span>
<span class="line-removed"> 562                 translate_gdk_action_to_glass(</span>
<span class="line-removed"> 563                     gdk_drag_context_get_selected_action(</span>
<span class="line-removed"> 564                         get_drag_context())));</span>
<span class="line-removed"> 565 </span>
<span class="line-removed"> 566         gdk_window_destroy(dnd_window);</span>
<span class="line-removed"> 567         dnd_window = NULL;</span>
<span class="line-removed"> 568         DragView::reset_drag_view();</span>
 569     }
<a name="10" id="anc10"></a><span class="line-removed"> 570 </span>
<span class="line-removed"> 571     return FALSE;</span>
<span class="line-removed"> 572 }</span>
<span class="line-removed"> 573 </span>
<span class="line-removed"> 574 #ifdef GLASS_GTK3</span>
<span class="line-removed"> 575 static void dnd_finished_callback(GdkDragContext *ctx, gpointer user_data) {</span>
<span class="line-removed"> 576     dnd_finish_callback(user_data);</span>
 577 }
 578 
<a name="11" id="anc11"></a><span class="line-modified"> 579 static gboolean dnd_update_drag_view(gpointer) {</span>
<span class="line-removed"> 580     gint x, y;</span>
<span class="line-removed"> 581 </span>
<span class="line-removed"> 582     gdk_device_get_position(gdk_drag_context_get_device(get_drag_context()),</span>
<span class="line-removed"> 583                                 NULL, &amp;x, &amp;y);</span>
<span class="line-removed"> 584 </span>
<span class="line-removed"> 585 </span>
<span class="line-removed"> 586     DragView::move(x, y);</span>
<span class="line-removed"> 587 </span>
<span class="line-removed"> 588     return FALSE;</span>
<span class="line-removed"> 589 }</span>
<span class="line-removed"> 590 #endif</span>
<span class="line-removed"> 591 </span>
<span class="line-removed"> 592 gboolean is_in_drag()</span>
 593 {
<a name="12" id="anc12"></a><span class="line-modified"> 594     return dnd_window != NULL;</span>





 595 }
 596 
<a name="13" id="anc13"></a><span class="line-modified"> 597 static void determine_actions(guint state, GdkDragAction *action, GdkDragAction *possible_actions)</span>
 598 {
<a name="14" id="anc14"></a><span class="line-modified"> 599     GdkDragAction suggested = static_cast&lt;GdkDragAction&gt;(GPOINTER_TO_INT(g_object_get_data(G_OBJECT(dnd_window), SOURCE_DND_ACTIONS)));</span>
<span class="line-removed"> 600 </span>
<span class="line-removed"> 601     if (state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK)) {</span>
<span class="line-removed"> 602         if ((state &amp; GDK_CONTROL_MASK) &amp;&amp; (state &amp; GDK_SHIFT_MASK) &amp;&amp; (suggested &amp; GDK_ACTION_LINK)) {</span>
<span class="line-removed"> 603             *action = *possible_actions = GDK_ACTION_LINK;</span>
<span class="line-removed"> 604             return;</span>
<span class="line-removed"> 605         } else if ((state &amp; GDK_SHIFT_MASK) &amp;&amp; (suggested &amp; GDK_ACTION_MOVE)) {</span>
<span class="line-removed"> 606             *action = *possible_actions = GDK_ACTION_MOVE;</span>
<span class="line-removed"> 607             return;</span>
<span class="line-removed"> 608         } else if (suggested &amp; GDK_ACTION_COPY){</span>
<span class="line-removed"> 609             *action = *possible_actions = GDK_ACTION_COPY;</span>
<span class="line-removed"> 610             return;</span>
<span class="line-removed"> 611         }</span>
<span class="line-removed"> 612     }</span>
<span class="line-removed"> 613 </span>
<span class="line-removed"> 614     *possible_actions = suggested;</span>
 615 
<a name="15" id="anc15"></a><span class="line-modified"> 616     if (suggested &amp; GDK_ACTION_COPY) {</span>
<span class="line-modified"> 617         *action = GDK_ACTION_COPY;</span>
<span class="line-modified"> 618     } else if (suggested &amp; GDK_ACTION_MOVE) {</span>
<span class="line-modified"> 619         *action = GDK_ACTION_MOVE;</span>
<span class="line-modified"> 620     } else if (suggested &amp; GDK_ACTION_LINK) {</span>
<span class="line-modified"> 621         *action = GDK_ACTION_LINK;</span>









 622     } else {
<a name="16" id="anc16"></a><span class="line-modified"> 623         *action = static_cast&lt;GdkDragAction&gt;(0);</span>

 624     }
<a name="17" id="anc17"></a>

 625 }
 626 
<a name="18" id="anc18"></a><span class="line-modified"> 627 static jobject dnd_source_get_data(const char *key)</span>
 628 {
<a name="19" id="anc19"></a><span class="line-modified"> 629     jobject data = (jobject)g_object_get_data(G_OBJECT(dnd_window), SOURCE_DND_DATA);</span>
<span class="line-removed"> 630     jstring string = mainEnv-&gt;NewStringUTF(key);</span>
<span class="line-removed"> 631     EXCEPTION_OCCURED(mainEnv);</span>
<span class="line-removed"> 632     jobject result = mainEnv-&gt;CallObjectMethod(data, jMapGet, string, NULL);</span>
 633 
<a name="20" id="anc20"></a><span class="line-modified"> 634     return (EXCEPTION_OCCURED(mainEnv)) ? NULL : result;</span>
<span class="line-modified"> 635 }</span>

 636 
<a name="21" id="anc21"></a><span class="line-modified"> 637 static gboolean dnd_source_set_utf8_string(GdkWindow *requestor, GdkAtom property)</span>
<span class="line-removed"> 638 {</span>
<span class="line-removed"> 639     jstring string = (jstring)dnd_source_get_data(&quot;text/plain&quot;);</span>
<span class="line-removed"> 640     if (!string) {</span>
<span class="line-removed"> 641         return FALSE;</span>
<span class="line-removed"> 642     }</span>
 643 
<a name="22" id="anc22"></a><span class="line-modified"> 644     const char *cstring = mainEnv-&gt;GetStringUTFChars(string, NULL);</span>
<span class="line-removed"> 645     if (!cstring) {</span>
<span class="line-removed"> 646         return FALSE;</span>
<span class="line-removed"> 647     }</span>
<span class="line-removed"> 648     gint size = strlen(cstring);</span>
 649 
<a name="23" id="anc23"></a><span class="line-modified"> 650     gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,</span>
<span class="line-removed"> 651             8, GDK_PROP_MODE_REPLACE, (guchar *)cstring, size);</span>
 652 
<a name="24" id="anc24"></a><span class="line-modified"> 653     mainEnv-&gt;ReleaseStringUTFChars(string, cstring);</span>
<span class="line-modified"> 654     return TRUE;</span>









 655 }
 656 
<a name="25" id="anc25"></a><span class="line-modified"> 657 static gboolean dnd_source_set_string(GdkWindow *requestor, GdkAtom property)</span>
 658 {
<a name="26" id="anc26"></a><span class="line-modified"> 659     jstring string = (jstring)dnd_source_get_data(&quot;text/plain&quot;);</span>


 660     if (!string) {
 661         return FALSE;
 662     }
 663 
<a name="27" id="anc27"></a><span class="line-removed"> 664     gboolean is_data_set = FALSE;</span>
 665     const char *cstring = mainEnv-&gt;GetStringUTFChars(string, NULL);
 666     if (cstring) {
<a name="28" id="anc28"></a><span class="line-modified"> 667         gchar *res_str = g_convert((gchar *)cstring, -1, &quot;ISO-8859-1&quot;, &quot;UTF-8&quot;, NULL, NULL, NULL);</span>
<span class="line-modified"> 668 </span>
<span class="line-modified"> 669         if (res_str) {</span>
<span class="line-modified"> 670             gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,</span>
<span class="line-modified"> 671                     8, GDK_PROP_MODE_REPLACE, (guchar *)res_str, strlen(res_str));</span>
<span class="line-modified"> 672             g_free(res_str);</span>
<span class="line-modified"> 673             is_data_set = TRUE;</span>


 674         }
<a name="29" id="anc29"></a><span class="line-removed"> 675 </span>
<span class="line-removed"> 676         mainEnv-&gt;ReleaseStringUTFChars(string, cstring);</span>
 677     }
<a name="30" id="anc30"></a>


 678     return is_data_set;
 679 }
 680 
<a name="31" id="anc31"></a><span class="line-modified"> 681 static gboolean dnd_source_set_image(GdkWindow *requestor, GdkAtom property, GdkAtom target)</span>
 682 {
<a name="32" id="anc32"></a><span class="line-modified"> 683     jobject pixels = dnd_source_get_data(&quot;application/x-java-rawimage&quot;);</span>
 684     if (!pixels) {
 685         return FALSE;
 686     }
 687 
 688     gchar *buffer;
 689     gsize size;
 690     const char * type;
 691     GdkPixbuf *pixbuf = NULL;
<a name="33" id="anc33"></a><span class="line-modified"> 692     gboolean result = FALSE;</span>
<span class="line-removed"> 693 </span>
<span class="line-removed"> 694     if (target == TARGET_MIME_PNG_ATOM) {</span>
<span class="line-removed"> 695         type = &quot;png&quot;;</span>
<span class="line-removed"> 696     } else if (target == TARGET_MIME_JPEG_ATOM) {</span>
<span class="line-removed"> 697         type = &quot;jpeg&quot;;</span>
<span class="line-removed"> 698     } else if (target == TARGET_MIME_TIFF_ATOM) {</span>
<span class="line-removed"> 699         type = &quot;tiff&quot;;</span>
<span class="line-removed"> 700     } else if (target == TARGET_MIME_BMP_ATOM) {</span>
<span class="line-removed"> 701         type = &quot;bmp&quot;;</span>
<span class="line-removed"> 702     } else {</span>
<span class="line-removed"> 703         return FALSE;</span>
<span class="line-removed"> 704     }</span>
 705 
 706     mainEnv-&gt;CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&amp;pixbuf));
 707 
<a name="34" id="anc34"></a><span class="line-modified"> 708     if (!EXCEPTION_OCCURED(mainEnv)</span>
<span class="line-modified"> 709             &amp;&amp; gdk_pixbuf_save_to_buffer(pixbuf, &amp;buffer, &amp;size, type, NULL, NULL)) {</span>
<span class="line-removed"> 710         gdk_property_change(requestor, property, target,</span>
<span class="line-removed"> 711                 8, GDK_PROP_MODE_REPLACE, (guchar *)buffer, size);</span>
<span class="line-removed"> 712         result = TRUE;</span>
 713     }
<a name="35" id="anc35"></a>
 714     g_object_unref(pixbuf);
<a name="36" id="anc36"></a><span class="line-modified"> 715     return result;</span>

 716 }
 717 
<a name="37" id="anc37"></a><span class="line-modified"> 718 static gboolean dnd_source_set_uri_list(GdkWindow *requestor, GdkAtom property)</span>
 719 {
 720     const gchar* url = NULL;
 721     jstring jurl = NULL;
 722 
 723     jobjectArray files_array = NULL;
 724     gsize files_cnt = 0;
 725 
<a name="38" id="anc38"></a><span class="line-modified"> 726     if (jurl = (jstring) dnd_source_get_data(&quot;text/uri-list&quot;)) {</span>
 727         url = mainEnv-&gt;GetStringUTFChars(jurl, NULL);
 728     }
 729 
<a name="39" id="anc39"></a><span class="line-modified"> 730     if (files_array = (jobjectArray) dnd_source_get_data(&quot;application/x-java-file-list&quot;)) {</span>
 731         files_cnt = mainEnv-&gt;GetArrayLength(files_array);
 732     }
<a name="40" id="anc40"></a>
 733     if (!url &amp;&amp; !files_cnt) {
 734         return FALSE;
 735     }
 736 
<a name="41" id="anc41"></a>
 737     GString* res = g_string_new (NULL); //http://www.ietf.org/rfc/rfc2483.txt
 738 
 739     if (files_cnt &gt; 0) {
 740         for (gsize i = 0; i &lt; files_cnt; ++i) {
 741             jstring string = (jstring) mainEnv-&gt;GetObjectArrayElement(files_array, i);
 742             EXCEPTION_OCCURED(mainEnv);
 743             const gchar* file = mainEnv-&gt;GetStringUTFChars(string, NULL);
 744             gchar* uri = g_filename_to_uri(file, NULL, NULL);
 745 
 746             g_string_append(res, uri);
 747             g_string_append(res, URI_LIST_LINE_BREAK);
 748 
 749             g_free(uri);
 750             mainEnv-&gt;ReleaseStringUTFChars(string, file);
 751         }
 752     }
 753     if (url) {
 754         g_string_append(res, url);
 755         g_string_append(res, URI_LIST_LINE_BREAK);
 756         mainEnv-&gt;ReleaseStringUTFChars(jurl, url);
 757     }
 758 
<a name="42" id="anc42"></a><span class="line-modified"> 759     gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,</span>
<span class="line-modified"> 760             8, GDK_PROP_MODE_REPLACE, (guchar *) res-&gt;str, res-&gt;len);</span>

 761 
<a name="43" id="anc43"></a><span class="line-modified"> 762     g_string_free(res, TRUE);</span>
<span class="line-modified"> 763     return TRUE;</span>



 764 }
 765 
<a name="44" id="anc44"></a><span class="line-modified"> 766 static gboolean dnd_source_set_raw(GdkWindow *requestor, GdkAtom property, GdkAtom target)</span>
 767 {
<a name="45" id="anc45"></a><span class="line-modified"> 768     gchar *target_name = gdk_atom_name(target);</span>
<span class="line-modified"> 769     jobject data = dnd_source_get_data(target_name);</span>
 770     gboolean is_data_set = FALSE;
 771     if (data) {
 772         if (mainEnv-&gt;IsInstanceOf(data, jStringCls)) {
 773             const char *cstring = mainEnv-&gt;GetStringUTFChars((jstring)data, NULL);
 774             if (cstring) {
<a name="46" id="anc46"></a><span class="line-modified"> 775                 gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,</span>
<span class="line-removed"> 776                         8, GDK_PROP_MODE_REPLACE, (guchar *) cstring, strlen(cstring));</span>
<span class="line-removed"> 777 </span>
 778                 mainEnv-&gt;ReleaseStringUTFChars((jstring)data, cstring);
<a name="47" id="anc47"></a><span class="line-removed"> 779                 is_data_set = TRUE;</span>
 780             }
 781         } else if (mainEnv-&gt;IsInstanceOf(data, jByteBufferCls)) {
 782             jbyteArray byteArray = (jbyteArray)mainEnv-&gt;CallObjectMethod(data, jByteBufferArray);
 783             if (!EXCEPTION_OCCURED(mainEnv)) {
 784                 jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
 785                 if (raw) {
 786                     jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
<a name="48" id="anc48"></a><span class="line-modified"> 787 </span>
<span class="line-removed"> 788                     gdk_property_change(requestor, property, target,</span>
<span class="line-removed"> 789                             8, GDK_PROP_MODE_REPLACE, (guchar *) raw, nraw);</span>
<span class="line-removed"> 790 </span>
 791                     mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
 792                     is_data_set = TRUE;
 793                 }
 794             }
 795         }
 796     }
 797 
 798     g_free(target_name);
 799     return is_data_set;
 800 }
 801 
<a name="49" id="anc49"></a><span class="line-modified"> 802 static void process_dnd_source_selection_req(GdkWindow *window, GdkEvent *gdkEvent)</span>
<span class="line-modified"> 803 {</span>
<span class="line-modified"> 804     (void)window;</span>
<span class="line-removed"> 805 </span>
<span class="line-removed"> 806     GdkEventSelection *event = &amp;gdkEvent-&gt;selection;</span>
<span class="line-removed"> 807 </span>
<span class="line-removed"> 808 #ifdef GLASS_GTK3</span>
<span class="line-removed"> 809     GdkWindow *requestor = (event-&gt;requestor);</span>
<span class="line-removed"> 810 #else</span>
<span class="line-removed"> 811     GdkWindow *requestor =</span>
<span class="line-removed"> 812         gdk_x11_window_foreign_new_for_display(gdk_display_get_default(), event-&gt;requestor);</span>
<span class="line-removed"> 813 #endif</span>
<span class="line-removed"> 814 </span>
<span class="line-removed"> 815     gboolean is_data_set = FALSE;</span>
<span class="line-removed"> 816     if (event-&gt;target == TARGET_UTF8_STRING_ATOM</span>
<span class="line-removed"> 817             || event-&gt;target == TARGET_MIME_TEXT_PLAIN_ATOM) {</span>
<span class="line-removed"> 818         is_data_set = dnd_source_set_utf8_string(requestor, event-&gt;property);</span>
<span class="line-removed"> 819     } else if (event-&gt;target == TARGET_STRING_ATOM) {</span>
<span class="line-removed"> 820         is_data_set = dnd_source_set_string(requestor, event-&gt;property);</span>
<span class="line-removed"> 821 //    } else if (event-&gt;target == TARGET_COMPOUND_TEXT_ATOM) { // XXX compound text</span>
<span class="line-removed"> 822     } else if (target_is_image(event-&gt;target)) {</span>
<span class="line-removed"> 823         is_data_set = dnd_source_set_image(requestor, event-&gt;property, event-&gt;target);</span>
<span class="line-removed"> 824     } else if (event-&gt;target == TARGET_MIME_URI_LIST_ATOM) {</span>
<span class="line-removed"> 825         is_data_set = dnd_source_set_uri_list(requestor, event-&gt;property);</span>
<span class="line-removed"> 826     } else {</span>
<span class="line-removed"> 827         is_data_set = dnd_source_set_raw(requestor, event-&gt;property, event-&gt;target);</span>
<span class="line-removed"> 828     }</span>
<span class="line-removed"> 829 </span>
<span class="line-removed"> 830     gdk_selection_send_notify(event-&gt;requestor, event-&gt;selection, event-&gt;target,</span>
<span class="line-removed"> 831                                (is_data_set) ? event-&gt;property : GDK_NONE, event-&gt;time);</span>
<span class="line-removed"> 832 </span>
<span class="line-removed"> 833 }</span>
<span class="line-removed"> 834 </span>
<span class="line-removed"> 835 static void process_dnd_source_mouse_release(GdkWindow *window, GdkEvent *event) {</span>
<span class="line-removed"> 836     (void)window;</span>
<span class="line-removed"> 837 </span>
<span class="line-removed"> 838     glass_gdk_master_pointer_ungrab(event);</span>
<span class="line-removed"> 839 </span>
<span class="line-removed"> 840     if (gdk_drag_context_get_selected_action(get_drag_context())) {</span>
<span class="line-removed"> 841         gdk_drag_drop(get_drag_context(), GDK_CURRENT_TIME);</span>
<span class="line-removed"> 842     } else {</span>
<span class="line-removed"> 843         gdk_drag_abort(get_drag_context(), GDK_CURRENT_TIME);</span>
<span class="line-removed"> 844         /* let the gdk_drag_abort messages handled before finish */</span>
<span class="line-removed"> 845         gdk_threads_add_idle((GSourceFunc) dnd_finish_callback, NULL);</span>
<span class="line-removed"> 846     }</span>
<span class="line-removed"> 847 }</span>
<span class="line-removed"> 848 </span>
<span class="line-removed"> 849 static void process_drag_motion(gint x_root, gint y_root, guint state)</span>
 850 {
<a name="50" id="anc50"></a><span class="line-modified"> 851     GdkWindow *dest_window;</span>
<span class="line-modified"> 852     GdkDragProtocol prot;</span>
<span class="line-modified"> 853 </span>
<span class="line-modified"> 854 #ifndef GLASS_GTK3</span>
<span class="line-modified"> 855     // gtk3 uses a move-when-idle method</span>
<span class="line-removed"> 856     DragView::move(x_root, y_root);</span>
<span class="line-removed"> 857 #endif</span>
<span class="line-removed"> 858 </span>
<span class="line-removed"> 859     gdk_drag_find_window_for_screen(get_drag_context(), NULL, gdk_screen_get_default(),</span>
<span class="line-removed"> 860             x_root, y_root, &amp;dest_window, &amp;prot);</span>
<span class="line-removed"> 861 </span>
<span class="line-removed"> 862     if (prot != GDK_DRAG_PROTO_NONE) {</span>
<span class="line-removed"> 863         GdkDragAction action, possible_actions;</span>
<span class="line-removed"> 864         determine_actions(state, &amp;action, &amp;possible_actions);</span>
<span class="line-removed"> 865         gdk_drag_motion(get_drag_context(), dest_window, prot, x_root, y_root,</span>
<span class="line-removed"> 866                 action, possible_actions, GDK_CURRENT_TIME);</span>
 867     }
 868 }
 869 
<a name="51" id="anc51"></a><span class="line-modified"> 870 static void process_dnd_source_mouse_motion(GdkWindow *window, GdkEvent *event)</span>
<span class="line-modified"> 871 {</span>
<span class="line-modified"> 872     (void)window;</span>
<span class="line-modified"> 873 </span>
<span class="line-removed"> 874     GdkEventMotion *eventMotion = &amp;event-&gt;motion;</span>
<span class="line-removed"> 875     process_drag_motion(eventMotion-&gt;x_root, eventMotion-&gt;y_root, eventMotion-&gt;state);</span>
<span class="line-removed"> 876 }</span>
<span class="line-removed"> 877 </span>
<span class="line-removed"> 878 static void process_dnd_source_key_press_release(GdkWindow *window, GdkEvent *event)</span>
 879 {
<a name="52" id="anc52"></a><span class="line-modified"> 880     (void)window;</span>
<span class="line-modified"> 881 </span>
<span class="line-modified"> 882     GdkEventKey *eventKey = &amp;event-&gt;key;</span>
<span class="line-removed"> 883 </span>
<span class="line-removed"> 884     if (eventKey-&gt;is_modifier) {</span>
<span class="line-removed"> 885         guint state = eventKey-&gt;state;</span>
<span class="line-removed"> 886         guint new_mod = 0;</span>
<span class="line-removed"> 887         gint x,y;</span>
<span class="line-removed"> 888         if (eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Control_L) ||</span>
<span class="line-removed"> 889                 eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Control_R)) {</span>
<span class="line-removed"> 890             new_mod = GDK_CONTROL_MASK;</span>
<span class="line-removed"> 891         } else if (eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Alt_L) ||</span>
<span class="line-removed"> 892                 eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Alt_R)) {</span>
<span class="line-removed"> 893             new_mod = GDK_MOD1_MASK;</span>
<span class="line-removed"> 894         } else if (eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Shift_L) ||</span>
<span class="line-removed"> 895                 eventKey-&gt;keyval == GLASS_GDK_KEY_CONSTANT(Shift_R)) {</span>
<span class="line-removed"> 896             new_mod = GDK_SHIFT_MASK;</span>
<span class="line-removed"> 897         }</span>
<span class="line-removed"> 898 </span>
<span class="line-removed"> 899         if (eventKey-&gt;type == GDK_KEY_PRESS) {</span>
<span class="line-removed"> 900             state |= new_mod;</span>
<span class="line-removed"> 901         } else {</span>
<span class="line-removed"> 902             state ^= new_mod;</span>
<span class="line-removed"> 903         }</span>
<span class="line-removed"> 904 </span>
<span class="line-removed"> 905 #ifdef GLASS_GTK3</span>
<span class="line-removed"> 906         gdk_device_get_position(gdk_drag_context_get_device(get_drag_context()), NULL, &amp;x, &amp;y);</span>
<span class="line-removed"> 907 #else</span>
<span class="line-removed"> 908         glass_gdk_master_pointer_get_position(&amp;x, &amp;y);</span>
<span class="line-removed"> 909 #endif</span>
<span class="line-removed"> 910         process_drag_motion(x, y, state);</span>
<span class="line-removed"> 911     }</span>
<span class="line-removed"> 912 }</span>
 913 
<a name="53" id="anc53"></a><span class="line-modified"> 914 static void process_dnd_source_drag_status(GdkWindow *window, GdkEvent *event)</span>
<span class="line-removed"> 915 {</span>
<span class="line-removed"> 916     (void)window;</span>
<span class="line-removed"> 917 </span>
<span class="line-removed"> 918     GdkEventDND *eventDnd = &amp;event-&gt;dnd;</span>
<span class="line-removed"> 919     GdkDragAction selected = gdk_drag_context_get_selected_action(eventDnd-&gt;context);</span>
<span class="line-removed"> 920     GdkCursor* cursor;</span>
<span class="line-removed"> 921 </span>
<span class="line-removed"> 922 #ifdef GLASS_GTK3</span>
<span class="line-removed"> 923     // dragview shows content when dragging - this updates the position</span>
<span class="line-removed"> 924     gdk_threads_add_idle_full (GDK_PRIORITY_REDRAW + 5, dnd_update_drag_view,</span>
<span class="line-removed"> 925                                NULL, NULL);</span>
<span class="line-removed"> 926 </span>
<span class="line-removed"> 927 #endif</span>
<span class="line-removed"> 928 </span>
<span class="line-removed"> 929     if (selected &amp; GDK_ACTION_COPY) {</span>
<span class="line-removed"> 930         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-copy&quot;);</span>
<span class="line-removed"> 931         if (cursor == NULL) {</span>
<span class="line-removed"> 932             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;copy&quot;);</span>
<span class="line-removed"> 933         }</span>
<span class="line-removed"> 934     } else if (selected &amp; (GDK_ACTION_MOVE | GDK_ACTION_PRIVATE)) {</span>
<span class="line-removed"> 935         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-move&quot;);</span>
<span class="line-removed"> 936         if (cursor == NULL) {</span>
<span class="line-removed"> 937             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;move&quot;);</span>
<span class="line-removed"> 938         }</span>
<span class="line-removed"> 939         if (cursor == NULL) {</span>
<span class="line-removed"> 940             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;closedhand&quot;);</span>
<span class="line-removed"> 941         }</span>
<span class="line-removed"> 942     } else if (selected &amp; GDK_ACTION_LINK) {</span>
<span class="line-removed"> 943         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-link&quot;);</span>
<span class="line-removed"> 944         if (cursor == NULL) {</span>
<span class="line-removed"> 945             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;link&quot;);</span>
<span class="line-removed"> 946         }</span>
<span class="line-removed"> 947         if (cursor == NULL) {</span>
<span class="line-removed"> 948             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;alias&quot;);</span>
<span class="line-removed"> 949         }</span>
<span class="line-removed"> 950     } else {</span>
<span class="line-removed"> 951         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-no-drop&quot;);</span>
<span class="line-removed"> 952         if (cursor == NULL) {</span>
<span class="line-removed"> 953             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;no-drop&quot;);</span>
<span class="line-removed"> 954         }</span>
<span class="line-removed"> 955         if (cursor == NULL) {</span>
<span class="line-removed"> 956             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;not-allowed&quot;);</span>
<span class="line-removed"> 957         }</span>
<span class="line-removed"> 958         if (cursor == NULL) {</span>
<span class="line-removed"> 959             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;forbidden&quot;);</span>
<span class="line-removed"> 960         }</span>
<span class="line-removed"> 961         if (cursor == NULL) {</span>
<span class="line-removed"> 962             cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;dnd-none&quot;);</span>
<span class="line-removed"> 963         }</span>
<span class="line-removed"> 964     }</span>
<span class="line-removed"> 965 </span>
<span class="line-removed"> 966     if (cursor == NULL) {</span>
<span class="line-removed"> 967         cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;default&quot;);</span>
<span class="line-removed"> 968     }</span>
<span class="line-removed"> 969 </span>
<span class="line-removed"> 970     dnd_pointer_grab(event, cursor);</span>
<span class="line-removed"> 971 }</span>
<span class="line-removed"> 972 </span>
<span class="line-removed"> 973 static void process_dnd_source_drop_finished(GdkWindow *window, GdkEvent *event)</span>
<span class="line-removed"> 974 {</span>
<span class="line-removed"> 975     (void)window;</span>
<span class="line-removed"> 976     (void)event;</span>
<span class="line-removed"> 977 </span>
<span class="line-removed"> 978     gdk_threads_add_idle((GSourceFunc) dnd_finish_callback, NULL);</span>
<span class="line-removed"> 979 }</span>
<span class="line-removed"> 980 </span>
<span class="line-removed"> 981 void process_dnd_source(GdkWindow *window, GdkEvent *event) {</span>
<span class="line-removed"> 982     switch(event-&gt;type) {</span>
<span class="line-removed"> 983         case GDK_MOTION_NOTIFY:</span>
<span class="line-removed"> 984             process_dnd_source_mouse_motion(window, event);</span>
<span class="line-removed"> 985             break;</span>
<span class="line-removed"> 986         case GDK_BUTTON_RELEASE:</span>
<span class="line-removed"> 987             process_dnd_source_mouse_release(window, event);</span>
<span class="line-removed"> 988             break;</span>
<span class="line-removed"> 989         case GDK_DRAG_STATUS:</span>
<span class="line-removed"> 990             process_dnd_source_drag_status(window, event);</span>
<span class="line-removed"> 991             break;</span>
<span class="line-removed"> 992         case GDK_DROP_FINISHED:</span>
<span class="line-removed"> 993             process_dnd_source_drop_finished(window, event);</span>
<span class="line-removed"> 994             break;</span>
<span class="line-removed"> 995         case GDK_KEY_PRESS:</span>
<span class="line-removed"> 996         case GDK_KEY_RELEASE:</span>
<span class="line-removed"> 997             process_dnd_source_key_press_release(window, event);</span>
<span class="line-removed"> 998             break;</span>
<span class="line-removed"> 999         case GDK_DRAG_ENTER:</span>
<span class="line-removed">1000             gdk_selection_owner_set(dnd_window, gdk_drag_get_selection(get_drag_context()),</span>
<span class="line-removed">1001                                     GDK_CURRENT_TIME, FALSE);</span>
<span class="line-removed">1002             break;</span>
<span class="line-removed">1003         case GDK_SELECTION_REQUEST:</span>
<span class="line-removed">1004             process_dnd_source_selection_req(window, event);</span>
<span class="line-removed">1005             break;</span>
<span class="line-removed">1006         default:</span>
<span class="line-removed">1007             break;</span>
<span class="line-removed">1008     }</span>
1009 }
1010 
<a name="54" id="anc54"></a><span class="line-modified">1011 static void add_target_from_jstring(JNIEnv *env, GList **list, jstring string)</span>





1012 {
<a name="55" id="anc55"></a><span class="line-modified">1013     const char *gstring = env-&gt;GetStringUTFChars(string, NULL);</span>
<span class="line-modified">1014     if (g_strcmp0(gstring, &quot;text/plain&quot;) == 0) {</span>
<span class="line-modified">1015         *list = g_list_append(*list, TARGET_UTF8_STRING_ATOM);</span>
<span class="line-modified">1016         *list = g_list_append(*list, TARGET_MIME_TEXT_PLAIN_ATOM);</span>
<span class="line-modified">1017         *list = g_list_append(*list, TARGET_STRING_ATOM);</span>
<span class="line-modified">1018         //*list = g_list_append(list, TARGET_COMPOUND_TEXT_ATOM);</span>
<span class="line-modified">1019     } else if (g_strcmp0(gstring, &quot;application/x-java-rawimage&quot;) == 0) {</span>
<span class="line-modified">1020         *list = g_list_append(*list, TARGET_MIME_PNG_ATOM);</span>
<span class="line-removed">1021         *list = g_list_append(*list, TARGET_MIME_JPEG_ATOM);</span>
<span class="line-removed">1022         *list = g_list_append(*list, TARGET_MIME_TIFF_ATOM);</span>
<span class="line-removed">1023         *list = g_list_append(*list, TARGET_MIME_BMP_ATOM);</span>
<span class="line-removed">1024     } else if (g_strcmp0(gstring, &quot;application/x-java-file-list&quot;) == 0) {</span>
<span class="line-removed">1025         *list = g_list_append(*list, TARGET_MIME_URI_LIST_ATOM);</span>
1026     } else {
<a name="56" id="anc56"></a><span class="line-modified">1027         *list = g_list_append(*list, gdk_atom_intern(gstring, FALSE));</span>
1028     }
<a name="57" id="anc57"></a><span class="line-removed">1029     env-&gt;ReleaseStringUTFChars(string, gstring);</span>
1030 }
1031 
<a name="58" id="anc58"></a><span class="line-modified">1032 static GList* data_to_targets(JNIEnv *env, jobject data)</span>


1033 {
<a name="59" id="anc59"></a><span class="line-modified">1034     jobject keys;</span>
<span class="line-removed">1035     jobject keysIterator;</span>
<span class="line-removed">1036     jstring next;</span>
<span class="line-removed">1037 </span>
<span class="line-removed">1038     GList *list = NULL;</span>
<span class="line-removed">1039 </span>
<span class="line-removed">1040     init_target_atoms();</span>
<span class="line-removed">1041 </span>
<span class="line-removed">1042     keys = env-&gt;CallObjectMethod(data, jMapKeySet, NULL);</span>
<span class="line-removed">1043     JNI_EXCEPTION_TO_CPP(env)</span>
<span class="line-removed">1044     keysIterator = env-&gt;CallObjectMethod(keys, jIterableIterator, NULL);</span>
<span class="line-removed">1045     JNI_EXCEPTION_TO_CPP(env)</span>
<span class="line-removed">1046     while (env-&gt;CallBooleanMethod(keysIterator, jIteratorHasNext) == JNI_TRUE) {</span>
<span class="line-removed">1047         next = (jstring)env-&gt;CallObjectMethod(keysIterator, jIteratorNext, NULL);</span>
<span class="line-removed">1048         JNI_EXCEPTION_TO_CPP(env)</span>
<span class="line-removed">1049         add_target_from_jstring(env, &amp;list, next);</span>
<span class="line-removed">1050     }</span>
<span class="line-removed">1051     return list;</span>
1052 }
1053 
1054 static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported)
1055 {
<a name="60" id="anc60"></a><span class="line-removed">1056     GdkWindow *src_window = get_dnd_window();</span>
<span class="line-removed">1057     GList *targets;</span>
<span class="line-removed">1058     GdkDragContext *ctx;</span>
<span class="line-removed">1059 </span>
1060     if (supported == 0) {
1061         return; // No supported actions, do nothing
1062     }
1063 
<a name="61" id="anc61"></a><span class="line-removed">1064     targets = data_to_targets(env, data);</span>
<span class="line-removed">1065 </span>
1066     data = env-&gt;NewGlobalRef(data);
1067 
1068     GdkDragAction actions = translate_glass_action_to_gdk(supported);
<a name="62" id="anc62"></a><span class="line-removed">1069     g_object_set_data_full(G_OBJECT(src_window), SOURCE_DND_DATA, data, clear_global_ref);</span>
<span class="line-removed">1070     g_object_set_data(G_OBJECT(src_window), SOURCE_DND_ACTIONS, (gpointer)actions);</span>
1071 
<a name="63" id="anc63"></a><span class="line-modified">1072     DragView::set_drag_view();</span>





1073 
<a name="64" id="anc64"></a><span class="line-modified">1074 #ifdef GLASS_GTK3</span>
<span class="line-removed">1075     GdkDevice *device = gdk_device_manager_get_client_pointer(</span>
<span class="line-removed">1076                     gdk_display_get_device_manager(</span>
<span class="line-removed">1077                         gdk_display_get_default()));</span>
1078 
<a name="65" id="anc65"></a><span class="line-modified">1079     ctx = gdk_drag_begin_for_device(src_window, device, targets);</span>
<span class="line-modified">1080 #else</span>
<span class="line-removed">1081     ctx = gdk_drag_begin(src_window, targets);</span>
<span class="line-removed">1082 #endif</span>
1083 
<a name="66" id="anc66"></a><span class="line-modified">1084     g_list_free(targets);</span>
<span class="line-modified">1085     g_object_set_data(G_OBJECT(src_window), SOURCE_DND_CONTEXT, ctx);</span>
1086 
<a name="67" id="anc67"></a><span class="line-modified">1087 #ifdef GLASS_GTK3</span>
<span class="line-modified">1088     if (gtk_get_minor_version() &gt;= 20) {</span>
<span class="line-removed">1089         // according to GDK docs, this is only fired on managed mode, but</span>
<span class="line-removed">1090         // on 3.20+ the GDK_DROP_FINISHED event stopped working and this signal</span>
<span class="line-removed">1091         // works (even when not managed).</span>
<span class="line-removed">1092         g_signal_connect(ctx, &quot;dnd-finished&quot;,</span>
<span class="line-removed">1093             G_CALLBACK(dnd_finished_callback), NULL);</span>
<span class="line-removed">1094     }</span>
1095 
<a name="68" id="anc68"></a><span class="line-modified">1096     if(gdk_device_grab(device, src_window, GDK_OWNERSHIP_NONE, FALSE,</span>
<span class="line-modified">1097                     (GdkEventMask)</span>
<span class="line-modified">1098                          (GDK_POINTER_MOTION_MASK</span>
<span class="line-modified">1099                              | GDK_BUTTON_MOTION_MASK</span>
<span class="line-modified">1100                              | GDK_BUTTON1_MOTION_MASK</span>
<span class="line-modified">1101                              | GDK_BUTTON2_MOTION_MASK</span>
<span class="line-modified">1102                              | GDK_BUTTON3_MOTION_MASK</span>
<span class="line-modified">1103                              | GDK_BUTTON_RELEASE_MASK),</span>
<span class="line-modified">1104                        NULL, GDK_CURRENT_TIME) != GDK_GRAB_SUCCESS) {</span>
<span class="line-modified">1105         g_warning(&quot;Usable to grab pointer device.&quot;);</span>
<span class="line-modified">1106     }</span>



1107 #else
<a name="69" id="anc69"></a><span class="line-modified">1108     dnd_pointer_grab(NULL, NULL);</span>
1109 #endif
1110 
<a name="70" id="anc70"></a><span class="line-modified">1111     is_dnd_owner = TRUE;</span>
1112 }
1113 
<a name="71" id="anc71"></a><span class="line-modified">1114 jint execute_dnd(JNIEnv *env, jobject data, jint supported) {</span>

1115     try {
1116         dnd_source_push_data(env, data, supported);
1117     } catch (jni_exception&amp;) {
<a name="72" id="anc72"></a><span class="line-modified">1118         return 0;</span>
1119     }
1120 
1121     while (is_in_drag()) {
1122         gtk_main_iteration();
1123     }
1124 
1125     return dnd_get_performed_action();
1126 }
1127 
1128  /******************** DRAG VIEW ***************************/
<a name="73" id="anc73"></a><span class="line-modified">1129 DragView::View* DragView::view = NULL;</span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131 void DragView::reset_drag_view() {</span>
<span class="line-removed">1132     delete view;</span>
<span class="line-removed">1133     view = NULL;</span>
<span class="line-removed">1134 }</span>
1135 
<a name="74" id="anc74"></a><span class="line-modified">1136 gboolean DragView::get_drag_image_offset(int* x, int* y) {</span>

1137     gboolean offset_set = FALSE;
<a name="75" id="anc75"></a><span class="line-modified">1138     jobject bb = dnd_source_get_data(&quot;application/x-java-drag-image-offset&quot;);</span>
1139     if (bb) {
1140         jbyteArray byteArray = (jbyteArray)mainEnv-&gt;CallObjectMethod(bb, jByteBufferArray);
1141         if (!EXCEPTION_OCCURED(mainEnv)) {
1142             jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
1143             jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
1144 
1145             if ((size_t) nraw &gt;= sizeof(jint) * 2) {
1146                 jint* r = (jint*) raw;
1147                 *x = BSWAP_32(r[0]);
1148                 *y = BSWAP_32(r[1]);
1149                 offset_set = TRUE;
1150             }
1151 
1152             mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
1153         }
1154     }
1155     return offset_set;
1156 }
1157 
<a name="76" id="anc76"></a><span class="line-modified">1158 static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer) {</span>
<span class="line-modified">1159     if (pixels != NULL) {</span>
<span class="line-removed">1160         g_free(pixels);</span>
<span class="line-removed">1161     }</span>
<span class="line-removed">1162 }</span>
<span class="line-removed">1163 </span>
<span class="line-removed">1164 GdkPixbuf* DragView::get_drag_image(gboolean* is_raw_image, gint* width, gint* height) {</span>
1165     GdkPixbuf *pixbuf = NULL;
1166     gboolean is_raw = FALSE;
1167 
<a name="77" id="anc77"></a><span class="line-modified">1168     jobject drag_image = dnd_source_get_data(&quot;application/x-java-drag-image&quot;);</span>
1169 
1170     if (drag_image) {
1171         jbyteArray byteArray = (jbyteArray) mainEnv-&gt;CallObjectMethod(drag_image, jByteBufferArray);
1172         if (!EXCEPTION_OCCURED(mainEnv)) {
1173 
1174             jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);
1175             jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
1176 
1177             int w = 0, h = 0;
1178             int whsz = sizeof(jint) * 2; // Pixels are stored right after two ints
<a name="78" id="anc78"></a><span class="line-modified">1179                                          // in this byteArray: width and height</span>
1180             if (nraw &gt; whsz) {
1181                 jint* int_raw = (jint*) raw;
1182                 w = BSWAP_32(int_raw[0]);
1183                 h = BSWAP_32(int_raw[1]);
1184 
1185                 // We should have enough pixels for requested width and height
1186                 if ((nraw - whsz) / 4 - w * h &gt;= 0 ) {
1187                     guchar* data = (guchar*) g_try_malloc0(nraw - whsz);
1188                     if (data) {
1189                         memcpy(data, (raw + whsz), nraw - whsz);
1190                         pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,
<a name="79" id="anc79"></a><span class="line-modified">1191                                 w, h, w * 4, pixbufDestroyNotifyFunc, NULL);</span>
1192                     }
1193                 }
1194             }
1195             mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
1196         }
1197     }
1198 
1199     if (!GDK_IS_PIXBUF(pixbuf)) {
<a name="80" id="anc80"></a><span class="line-modified">1200         jobject pixels = dnd_source_get_data(&quot;application/x-java-rawimage&quot;);</span>
1201         if (pixels) {
1202             is_raw = TRUE;
1203             mainEnv-&gt;CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&amp;pixbuf));
1204             CHECK_JNI_EXCEPTION_RET(mainEnv, NULL)
1205         }
1206     }
1207 
1208     if (!GDK_IS_PIXBUF(pixbuf)) {
1209         return NULL;
1210     }
1211 
1212     int w = gdk_pixbuf_get_width(pixbuf);
1213     int h = gdk_pixbuf_get_height(pixbuf);
1214 
1215     if (w &gt; DRAG_IMAGE_MAX_WIDTH || h &gt; DRAG_IMAGE_MAX_HEIGH) {
1216         double rw = DRAG_IMAGE_MAX_WIDTH / (double)w;
1217         double rh =  DRAG_IMAGE_MAX_HEIGH / (double)h;
1218         double r = MIN(rw, rh);
1219 
<a name="81" id="anc81"></a><span class="line-removed">1220 </span>
1221         int new_w = w * r;
1222         int new_h = h * r;
1223 
1224         w = new_w;
1225         h = new_h;
1226 
1227         GdkPixbuf *tmp_pixbuf = gdk_pixbuf_scale_simple(pixbuf, new_w, new_h, GDK_INTERP_TILES);
1228         g_object_unref(pixbuf);
1229         if (!GDK_IS_PIXBUF(tmp_pixbuf)) {
1230             return NULL;
1231         }
1232         pixbuf = tmp_pixbuf;
1233     }
1234 
1235     *is_raw_image = is_raw;
1236     *width = w;
1237     *height = h;
1238 
1239     return pixbuf;
1240 }
1241 
<a name="82" id="anc82"></a><span class="line-modified">1242 void DragView::set_drag_view() {</span>
<span class="line-modified">1243     reset_drag_view();</span>
<span class="line-removed">1244 </span>
1245     gboolean is_raw_image = FALSE;
1246     gint w = 0, h = 0;
<a name="83" id="anc83"></a><span class="line-modified">1247     GdkPixbuf* pixbuf = get_drag_image(&amp;is_raw_image, &amp;w, &amp;h);</span>
1248 
1249     if (GDK_IS_PIXBUF(pixbuf)) {
1250         gint offset_x = w / 2;
1251         gint offset_y = h / 2;
1252 
<a name="84" id="anc84"></a><span class="line-modified">1253         gboolean is_offset_set = get_drag_image_offset(&amp;offset_x, &amp;offset_y);</span>
1254 
<a name="85" id="anc85"></a><span class="line-modified">1255         DragView::view = new DragView::View(pixbuf, is_raw_image, is_offset_set, offset_x, offset_y);</span>
<span class="line-modified">1256     }</span>
<span class="line-removed">1257 }</span>
<span class="line-removed">1258 void DragView::move(gint x, gint y) {</span>
<span class="line-removed">1259     if (view) {</span>
<span class="line-removed">1260         view-&gt;move(x, y);</span>
1261     }
1262 }
1263 
<a name="86" id="anc86"></a><span class="line-modified">1264 static void on_screen_changed(GtkWidget *widget, GdkScreen *previous_screen, gpointer view) {</span>

1265     (void)widget;
1266     (void)previous_screen;
1267 
1268     ((DragView::View*) view)-&gt;screen_changed();
1269 }
1270 
<a name="87" id="anc87"></a><span class="line-modified">1271 static gboolean on_draw(GtkWidget *widget, cairo_t *cr, gpointer view) {</span>
<span class="line-modified">1272     (void)widget;</span>
<span class="line-removed">1273 </span>
<span class="line-removed">1274     ((DragView::View*) view)-&gt;expose(cr);</span>
<span class="line-removed">1275     return FALSE;</span>
<span class="line-removed">1276 }</span>
<span class="line-removed">1277 </span>
<span class="line-removed">1278 static gboolean on_expose(GtkWidget *widget, GdkEventExpose *event, gpointer view) {</span>
1279     (void)widget;
1280     (void)event;
1281 
<a name="88" id="anc88"></a><span class="line-modified">1282     ((DragView::View*) view)-&gt;expose(NULL);</span>
1283     return FALSE;
1284 }
1285 
<a name="89" id="anc89"></a><span class="line-modified">1286 DragView::View::View(GdkPixbuf* _pixbuf, gboolean _is_raw_image,</span>
<span class="line-modified">1287                                 gboolean _is_offset_set, gint _offset_x, gint _offset_y) :</span>
<span class="line-modified">1288         pixbuf(_pixbuf),</span>
<span class="line-modified">1289         is_raw_image(_is_raw_image),</span>
<span class="line-modified">1290         is_offset_set(_is_offset_set),</span>
<span class="line-modified">1291         offset_x(_offset_x),</span>
<span class="line-modified">1292         offset_y(_offset_y)</span>



1293 {
<a name="90" id="anc90"></a><span class="line-modified">1294     width = gdk_pixbuf_get_width(pixbuf);</span>
<span class="line-modified">1295     height = gdk_pixbuf_get_height(pixbuf);</span>
<span class="line-modified">1296 </span>
1297     widget = gtk_window_new(GTK_WINDOW_POPUP);
1298     gtk_window_set_type_hint(GTK_WINDOW(widget), GDK_WINDOW_TYPE_HINT_DND);
1299     gtk_widget_set_events(widget, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK);
1300 
1301     screen_changed();
1302 
1303     gtk_widget_realize(widget);
1304 
1305     gtk_widget_set_app_paintable(widget, TRUE);
<a name="91" id="anc91"></a><span class="line-removed">1306 </span>
<span class="line-removed">1307 #ifdef GLASS_GTK3</span>
<span class="line-removed">1308     g_signal_connect(G_OBJECT(widget), &quot;draw&quot;, G_CALLBACK(on_draw), this);</span>
<span class="line-removed">1309 #else</span>
1310     g_signal_connect(G_OBJECT(widget), &quot;expose-event&quot;, G_CALLBACK(on_expose), this);
<a name="92" id="anc92"></a><span class="line-removed">1311 #endif</span>
1312     g_signal_connect(G_OBJECT(widget), &quot;screen-changed&quot;, G_CALLBACK(on_screen_changed), this);
<a name="93" id="anc93"></a><span class="line-removed">1313 </span>
1314     gtk_widget_set_size_request(widget, width, height);
<a name="94" id="anc94"></a><span class="line-removed">1315 </span>
1316     gtk_window_set_decorated(GTK_WINDOW(widget), FALSE);
<a name="95" id="anc95"></a><span class="line-modified">1317     gtk_window_set_opacity(GTK_WINDOW(widget), .7);</span>



1318 }
1319 
<a name="96" id="anc96"></a><span class="line-modified">1320 void DragView::View::screen_changed() {</span>

1321     GdkScreen *screen = gtk_widget_get_screen(widget);
1322 
1323     glass_configure_window_transparency(widget, true);
1324 
1325     if (!gdk_screen_is_composited(screen)) {
1326         if (!is_offset_set) {
1327             offset_x = 1;
1328             offset_y = 1;
1329         }
1330     }
1331 }
1332 
<a name="97" id="anc97"></a><span class="line-modified">1333 void DragView::View::expose(cairo_t *context) {</span>
<span class="line-modified">1334 #ifndef GLASS_GTK3</span>
<span class="line-modified">1335     context = gdk_cairo_create(gtk_widget_get_window(widget));</span>
<span class="line-modified">1336 #endif</span>
1337     cairo_surface_t* cairo_surface;
1338 
1339     guchar* pixels = is_raw_image
1340             ? (guchar*) convert_BGRA_to_RGBA((const int*) gdk_pixbuf_get_pixels(pixbuf),
1341                                                 gdk_pixbuf_get_rowstride(pixbuf),
1342                                                 height)
1343             : gdk_pixbuf_get_pixels(pixbuf);
1344 
1345     cairo_surface = cairo_image_surface_create_for_data(
1346             pixels,
1347             CAIRO_FORMAT_ARGB32,
1348             width, height, width * 4);
1349 
1350     cairo_set_source_surface(context, cairo_surface, 0, 0);
1351     cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
1352     cairo_paint(context);
1353 
1354     if (is_raw_image) {
1355         g_free(pixels);
1356     }
<a name="98" id="anc98"></a><span class="line-removed">1357 </span>
<span class="line-removed">1358     cairo_surface_destroy(cairo_surface);</span>
<span class="line-removed">1359 </span>
<span class="line-removed">1360 #ifndef GLASS_GTK3</span>
1361     cairo_destroy(context);
<a name="99" id="anc99"></a><span class="line-modified">1362 #endif</span>
<span class="line-removed">1363 }</span>
<span class="line-removed">1364 </span>
<span class="line-removed">1365 void DragView::View::move(gint x, gint y) {</span>
<span class="line-removed">1366 #ifdef GLASS_GTK3</span>
<span class="line-removed">1367     // gtk3 method uses a move-when-idle method</span>
<span class="line-removed">1368     gtk_window_move(GTK_WINDOW(widget), x - offset_x, y - offset_y);</span>
<span class="line-removed">1369 #else</span>
<span class="line-removed">1370     if (!gtk_events_pending()) { // avoid sluggish window move</span>
<span class="line-removed">1371         gtk_window_move(GTK_WINDOW(widget), x - offset_x, y - offset_y);</span>
<span class="line-removed">1372     }</span>
<span class="line-removed">1373 #endif</span>
<span class="line-removed">1374 </span>
<span class="line-removed">1375     if (gtk_widget_get_visible(widget)) {</span>
<span class="line-removed">1376         gdk_window_raise(gtk_widget_get_window(widget));</span>
<span class="line-removed">1377     }</span>
<span class="line-removed">1378     else {</span>
<span class="line-removed">1379         gtk_widget_show(widget);</span>
<span class="line-removed">1380     }</span>
<span class="line-removed">1381 }</span>
<span class="line-removed">1382 </span>
<span class="line-removed">1383 DragView::View::~View() {</span>
<span class="line-removed">1384     if (widget) {</span>
<span class="line-removed">1385         gtk_widget_destroy(widget);</span>
<span class="line-removed">1386         widget == NULL;</span>
<span class="line-removed">1387     }</span>
<span class="line-removed">1388     if (pixbuf) {</span>
<span class="line-removed">1389         g_object_unref(pixbuf);</span>
<span class="line-removed">1390         pixbuf == NULL;</span>
<span class="line-removed">1391     }</span>
1392 }
<a name="100" id="anc100"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="100" type="hidden" />
</body>
</html>