diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/network/java/ResourceHandleJava.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/network/java/ResourceHandleJava.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/network/java/ResourceHandleJava.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/network/java/ResourceHandleJava.cpp
@@ -22,14 +22,16 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 #include "config.h"
-#include "ResourceHandle.h"
-#include "ResourceHandleInternal.h"
 
+#include <wtf/CompletionHandler.h>
 #include "NotImplemented.h"
+#include "ResourceHandle.h"
+#include "ResourceHandleInternal.h"
+#include "com_sun_webkit_LoadListenerClient.h"
 
 namespace WebCore {
 
 ResourceHandleInternal::~ResourceHandleInternal()
 {
@@ -40,19 +42,115 @@
 }
 
 bool ResourceHandle::start()
 {
     ASSERT(!d->m_loader);
-    d->m_loader = URLLoader::loadAsynchronously(context(), this);
+    d->m_loader = URLLoader::loadAsynchronously(context(), this, this->firstRequest());
     return d->m_loader != nullptr;
 }
 
 void ResourceHandle::cancel()
 {
+        d->m_loader.reset();
+    }
+}
+
+static bool shouldRedirectAsGET(const ResourceRequest& request, const ResourceResponse& response, bool crossOrigin)
+{
+    if (request.httpMethod() == "GET" || request.httpMethod() == "HEAD")
+        return false;
+
+    if (!request.url().protocolIsInHTTPFamily())
+        return true;
+
+    if (response.isSeeOther())
+        return true;
+
+    if ((response.isMovedPermanently() || response.isFound()) && (request.httpMethod() == "POST"))
+        return true;
+
+    if (crossOrigin && (request.httpMethod() == "DELETE"))
+        return true;
+
+    return false;
+}
+
+void ResourceHandle::willSendRequest(const ResourceResponse& response)
+{
+    ASSERT(isMainThread());
+
+    ResourceRequest request = firstRequest();
+
+    static const int maxRedirects = 20;
+    if (d->m_redirectCount++ > maxRedirects) {
+        client()->didFail(this, ResourceError(
+            String(),
+            com_sun_webkit_LoadListenerClient_TOO_MANY_REDIRECTS,
+            request.url(),
+            "Illegal redirect"));
+        return;
+    }
+
+    if (response.httpStatusCode() == 307) {
+        String lastHTTPMethod = d->m_lastHTTPMethod;
+        if (!equalIgnoringASCIICase(lastHTTPMethod, request.httpMethod())) {
+            request.setHTTPMethod(lastHTTPMethod);
+
+            FormData* body = d->m_firstRequest.httpBody();
+            if (!equalLettersIgnoringASCIICase(lastHTTPMethod, "get") && body && !body->isEmpty())
+                request.setHTTPBody(body);
+
+            String originalContentType = d->m_firstRequest.httpContentType();
+            if (!originalContentType.isEmpty())
+                request.setHTTPHeaderField(HTTPHeaderName::ContentType, originalContentType);
+        }
+    }
+
+    String location = response.httpHeaderField(HTTPHeaderName::Location);
+    URL newURL = URL(response.url(), location);
+    bool crossOrigin = !protocolHostAndPortAreEqual(request.url(), newURL);
+
+    ResourceRequest newRequest = request;
+    newRequest.setURL(newURL);
+
+    if (shouldRedirectAsGET(newRequest, response, crossOrigin)) {
+        newRequest.setHTTPMethod("GET");
+        newRequest.setHTTPBody(nullptr);
+        newRequest.clearHTTPContentType();
+    }
+
+    if (crossOrigin) {
+        // If the network layer carries over authentication headers from the original request
+        // in a cross-origin redirect, we want to clear those headers here.
+        newRequest.clearHTTPAuthorization();
+        newRequest.clearHTTPOrigin();
+    }
+
+    // Should not set Referer after a redirect from a secure resource to non-secure one.
+    if (!newURL.protocolIs("https") && protocolIs(newRequest.httpReferrer(), "https") && context()->shouldClearReferrerOnHTTPSToHTTPRedirect())
+        newRequest.clearHTTPReferrer();
+
+    client()->willSendRequestAsync(this, WTFMove(newRequest), ResourceResponse(response), [this, protectedThis = makeRef(*this)] (ResourceRequest&& request) {
+        continueAfterWillSendRequest(WTFMove(request));
+    });
+}
+
+void ResourceHandle::continueAfterWillSendRequest(ResourceRequest&& request)
+{
+    ASSERT(isMainThread());
+
+    // willSendRequest might cancel the load.
+    if (!d->m_loader || !client())
+        return;
+
+    cancel();
+    if (request.isNull()) {
+        return;
     }
+    d->m_loader = URLLoader::loadAsynchronously(context(), this, request);
 }
 
 //utatodo: merge artifact
 void ResourceHandle::platformLoadResourceSynchronously(NetworkingContext* context,
                                                const ResourceRequest& request,
@@ -62,11 +160,10 @@
                                                Vector<char>& data)
 {
     URLLoader::loadSynchronously(context, request, error, response, data);
 }
 
-
 void ResourceHandle::platformSetDefersLoading(bool)
 {
     notImplemented();
 }
 
