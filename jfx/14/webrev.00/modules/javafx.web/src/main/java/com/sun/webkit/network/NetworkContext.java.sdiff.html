<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/java/com/sun/webkit/network/NetworkContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ByteBufferPool.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="URLLoader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/java/com/sun/webkit/network/NetworkContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45 final class NetworkContext {
 46 
 47     private static final PlatformLogger logger =
 48             PlatformLogger.getLogger(NetworkContext.class.getName());
 49 
 50     /**
 51      * The size of the thread pool for asynchronous loaders.
 52      */
 53     private static final int THREAD_POOL_SIZE = 20;
 54 
 55     /**
 56      * The thread pool keep alive time.
 57      */
 58     private static final long THREAD_POOL_KEEP_ALIVE_TIME = 10000L;
 59 
 60     /**
 61      * The default value of the &quot;http.maxConnections&quot; system property.
 62      */
 63     private static final int DEFAULT_HTTP_MAX_CONNECTIONS = 5;
 64 






 65     /**
 66      * The buffer size for the shared pool of byte buffers.
 67      */
 68     private static final int BYTE_BUFFER_SIZE = 1024 * 40;
 69 
 70     /**
 71      * The thread pool used to execute asynchronous loaders.
 72      */
 73     private static final ThreadPoolExecutor threadPool;





 74     static {
 75         threadPool = new ThreadPoolExecutor(
 76                 THREAD_POOL_SIZE,
 77                 THREAD_POOL_SIZE,
 78                 THREAD_POOL_KEEP_ALIVE_TIME,
 79                 TimeUnit.MILLISECONDS,
 80                 new LinkedBlockingQueue&lt;Runnable&gt;(),
 81                 new URLLoaderThreadFactory());
 82         threadPool.allowCoreThreadTimeOut(true);


 83     }
 84 
 85     /**
 86      * The shared pool of byte buffers.
 87      */
 88     private static final ByteBufferPool byteBufferPool =
 89             ByteBufferPool.newInstance(BYTE_BUFFER_SIZE);
 90 
 91 
 92     /**
 93      * Non-invocable constructor.
 94      */
 95     private NetworkContext() {
 96         throw new AssertionError();
 97     }
 98 
 99 
100     /**
101      * Checks whether a URL is valid or not. I.E. if we do have a protocol
102      * handler to deal with it.
103      *
104      * @param url the &lt;code&gt;String&lt;/code&gt; containing the url to check.
105      * @return &lt;code&gt;true&lt;/code&gt; if we can handle the url. &lt;code&gt;false&lt;/code&gt;
106      *         otherwise.
107      */
108     private static boolean canHandleURL(String url) {
109         java.net.URL u = null;
110         try {
111             u = newURL(url);
112         } catch (MalformedURLException malformedURLException) {
113         }
114         return u != null;
115     }
116 
117     /**
118      * Starts an asynchronous load or executes a synchronous one.
119      */
<span class="line-modified">120     private static URLLoader fwkLoad(WebPage webPage,</span>
121                                      boolean asynchronous,
122                                      String url,
123                                      String method,
124                                      String headers,
125                                      FormDataElement[] formDataElements,
126                                      long data)
127     {
128         if (logger.isLoggable(Level.FINEST)) {
129             logger.finest(String.format(
130                     &quot;webPage: [%s], &quot; +
131                     &quot;asynchronous: [%s], &quot; +
132                     &quot;url: [%s], &quot; +
133                     &quot;method: [%s], &quot; +
134                     &quot;formDataElements: %s, &quot; +
135                     &quot;data: [0x%016X], &quot; +
136                     &quot;headers:%n%s&quot;,
137                     webPage,
138                     asynchronous,
139                     url,
140                     method,
















146         URLLoader loader = new URLLoader(
147                 webPage,
148                 byteBufferPool,
149                 asynchronous,
150                 url,
151                 method,
152                 headers,
153                 formDataElements,
154                 data);
155         if (asynchronous) {
156             threadPool.submit(loader);
157             if (logger.isLoggable(Level.FINEST)) {
158                 logger.finest(
159                         &quot;active count: [{0}], &quot; +
160                         &quot;pool size: [{1}], &quot; +
161                         &quot;max pool size: [{2}], &quot; +
162                         &quot;task count: [{3}], &quot; +
163                         &quot;completed task count: [{4}]&quot;,
164                         new Object[] {
165                                 threadPool.getActiveCount(),
</pre>
<hr />
<pre>
167                                 threadPool.getMaximumPoolSize(),
168                                 threadPool.getTaskCount(),
169                                 threadPool.getCompletedTaskCount()});
170             }
171             return loader;
172         } else {
173             loader.run();
174             return null;
175         }
176     }
177 
178     /**
179      * Returns the maximum allowed number of connections per host.
180      */
181     private static int fwkGetMaximumHTTPConnectionCountPerHost() {
182         // Our implementation employs HttpURLConnection for all
183         // HTTP exchanges, so return the value of the &quot;http.maxConnections&quot;
184         // system property.
185         int propValue = AccessController.doPrivileged(
186                 (PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;http.maxConnections&quot;, -1));




187         return propValue &gt;= 0 ? propValue : DEFAULT_HTTP_MAX_CONNECTIONS;
188     }
189 
190     /**
191      * Thread factory for URL loader threads.
192      */
193     private static final class URLLoaderThreadFactory implements ThreadFactory {
194         private final ThreadGroup group;
195         private final AtomicInteger index = new AtomicInteger(1);
196 
197         // Need to assert the modifyThread and modifyThreadGroup permission when
198         // creating the thread from the URLLoaderThreadFactory, so we can
199         // create the thread with the desired ThreadGroup.
200         // Note that this is needed when running as an applet or a web start app.
201         private static final Permission modifyThreadGroupPerm = new RuntimePermission(&quot;modifyThreadGroup&quot;);
202         private static final Permission modifyThreadPerm = new RuntimePermission(&quot;modifyThread&quot;);
203 
204         private URLLoaderThreadFactory() {
205             SecurityManager sm = System.getSecurityManager();
206             group = (sm != null) ? sm.getThreadGroup()
</pre>
</td>
<td>
<hr />
<pre>
 45 final class NetworkContext {
 46 
 47     private static final PlatformLogger logger =
 48             PlatformLogger.getLogger(NetworkContext.class.getName());
 49 
 50     /**
 51      * The size of the thread pool for asynchronous loaders.
 52      */
 53     private static final int THREAD_POOL_SIZE = 20;
 54 
 55     /**
 56      * The thread pool keep alive time.
 57      */
 58     private static final long THREAD_POOL_KEEP_ALIVE_TIME = 10000L;
 59 
 60     /**
 61      * The default value of the &quot;http.maxConnections&quot; system property.
 62      */
 63     private static final int DEFAULT_HTTP_MAX_CONNECTIONS = 5;
 64 
<span class="line-added"> 65     /**</span>
<span class="line-added"> 66      * The default value of the maximum concurrent connections for</span>
<span class="line-added"> 67      * new gen HTTP2 client</span>
<span class="line-added"> 68      */</span>
<span class="line-added"> 69     private static final int DEFAULT_HTTP2_MAX_CONNECTIONS = 20;</span>
<span class="line-added"> 70 </span>
 71     /**
 72      * The buffer size for the shared pool of byte buffers.
 73      */
 74     private static final int BYTE_BUFFER_SIZE = 1024 * 40;
 75 
 76     /**
 77      * The thread pool used to execute asynchronous loaders.
 78      */
 79     private static final ThreadPoolExecutor threadPool;
<span class="line-added"> 80 </span>
<span class="line-added"> 81     /**</span>
<span class="line-added"> 82      * Can use HTTP2Loader</span>
<span class="line-added"> 83      */</span>
<span class="line-added"> 84     private static final boolean useHTTP2Loader;</span>
 85     static {
 86         threadPool = new ThreadPoolExecutor(
 87                 THREAD_POOL_SIZE,
 88                 THREAD_POOL_SIZE,
 89                 THREAD_POOL_KEEP_ALIVE_TIME,
 90                 TimeUnit.MILLISECONDS,
 91                 new LinkedBlockingQueue&lt;Runnable&gt;(),
 92                 new URLLoaderThreadFactory());
 93         threadPool.allowCoreThreadTimeOut(true);
<span class="line-added"> 94 </span>
<span class="line-added"> 95         useHTTP2Loader = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.valueOf(System.getProperty(&quot;com.sun.webkit.useHTTP2Loader&quot;, &quot;true&quot;)));</span>
 96     }
 97 
 98     /**
 99      * The shared pool of byte buffers.
100      */
101     private static final ByteBufferPool byteBufferPool =
102             ByteBufferPool.newInstance(BYTE_BUFFER_SIZE);
103 
104 
105     /**
106      * Non-invocable constructor.
107      */
108     private NetworkContext() {
109         throw new AssertionError();
110     }
111 
112 
113     /**
114      * Checks whether a URL is valid or not. I.E. if we do have a protocol
115      * handler to deal with it.
116      *
117      * @param url the &lt;code&gt;String&lt;/code&gt; containing the url to check.
118      * @return &lt;code&gt;true&lt;/code&gt; if we can handle the url. &lt;code&gt;false&lt;/code&gt;
119      *         otherwise.
120      */
121     private static boolean canHandleURL(String url) {
122         java.net.URL u = null;
123         try {
124             u = newURL(url);
125         } catch (MalformedURLException malformedURLException) {
126         }
127         return u != null;
128     }
129 
130     /**
131      * Starts an asynchronous load or executes a synchronous one.
132      */
<span class="line-modified">133     private static URLLoaderBase fwkLoad(WebPage webPage,</span>
134                                      boolean asynchronous,
135                                      String url,
136                                      String method,
137                                      String headers,
138                                      FormDataElement[] formDataElements,
139                                      long data)
140     {
141         if (logger.isLoggable(Level.FINEST)) {
142             logger.finest(String.format(
143                     &quot;webPage: [%s], &quot; +
144                     &quot;asynchronous: [%s], &quot; +
145                     &quot;url: [%s], &quot; +
146                     &quot;method: [%s], &quot; +
147                     &quot;formDataElements: %s, &quot; +
148                     &quot;data: [0x%016X], &quot; +
149                     &quot;headers:%n%s&quot;,
150                     webPage,
151                     asynchronous,
152                     url,
153                     method,
<span class="line-added">159 </span>
<span class="line-added">160         if (useHTTP2Loader) {</span>
<span class="line-added">161             final URLLoaderBase loader = HTTP2Loader.create(</span>
<span class="line-added">162                 webPage,</span>
<span class="line-added">163                 byteBufferPool,</span>
<span class="line-added">164                 asynchronous,</span>
<span class="line-added">165                 url,</span>
<span class="line-added">166                 method,</span>
<span class="line-added">167                 headers,</span>
<span class="line-added">168                 formDataElements,</span>
<span class="line-added">169                 data);</span>
<span class="line-added">170             if (loader != null) {</span>
<span class="line-added">171                 return loader;</span>
<span class="line-added">172             }</span>
<span class="line-added">173         }</span>
<span class="line-added">174 </span>
175         URLLoader loader = new URLLoader(
176                 webPage,
177                 byteBufferPool,
178                 asynchronous,
179                 url,
180                 method,
181                 headers,
182                 formDataElements,
183                 data);
184         if (asynchronous) {
185             threadPool.submit(loader);
186             if (logger.isLoggable(Level.FINEST)) {
187                 logger.finest(
188                         &quot;active count: [{0}], &quot; +
189                         &quot;pool size: [{1}], &quot; +
190                         &quot;max pool size: [{2}], &quot; +
191                         &quot;task count: [{3}], &quot; +
192                         &quot;completed task count: [{4}]&quot;,
193                         new Object[] {
194                                 threadPool.getActiveCount(),
</pre>
<hr />
<pre>
196                                 threadPool.getMaximumPoolSize(),
197                                 threadPool.getTaskCount(),
198                                 threadPool.getCompletedTaskCount()});
199             }
200             return loader;
201         } else {
202             loader.run();
203             return null;
204         }
205     }
206 
207     /**
208      * Returns the maximum allowed number of connections per host.
209      */
210     private static int fwkGetMaximumHTTPConnectionCountPerHost() {
211         // Our implementation employs HttpURLConnection for all
212         // HTTP exchanges, so return the value of the &quot;http.maxConnections&quot;
213         // system property.
214         int propValue = AccessController.doPrivileged(
215                 (PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;http.maxConnections&quot;, -1));
<span class="line-added">216 </span>
<span class="line-added">217         if (useHTTP2Loader) {</span>
<span class="line-added">218             return propValue &gt;= 0 ? propValue : DEFAULT_HTTP2_MAX_CONNECTIONS;</span>
<span class="line-added">219         }</span>
220         return propValue &gt;= 0 ? propValue : DEFAULT_HTTP_MAX_CONNECTIONS;
221     }
222 
223     /**
224      * Thread factory for URL loader threads.
225      */
226     private static final class URLLoaderThreadFactory implements ThreadFactory {
227         private final ThreadGroup group;
228         private final AtomicInteger index = new AtomicInteger(1);
229 
230         // Need to assert the modifyThread and modifyThreadGroup permission when
231         // creating the thread from the URLLoaderThreadFactory, so we can
232         // create the thread with the desired ThreadGroup.
233         // Note that this is needed when running as an applet or a web start app.
234         private static final Permission modifyThreadGroupPerm = new RuntimePermission(&quot;modifyThreadGroup&quot;);
235         private static final Permission modifyThreadPerm = new RuntimePermission(&quot;modifyThread&quot;);
236 
237         private URLLoaderThreadFactory() {
238             SecurityManager sm = System.getSecurityManager();
239             group = (sm != null) ? sm.getThreadGroup()
</pre>
</td>
</tr>
</table>
<center><a href="ByteBufferPool.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="URLLoader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>