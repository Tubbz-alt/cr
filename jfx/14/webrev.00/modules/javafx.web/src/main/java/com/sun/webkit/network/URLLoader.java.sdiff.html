<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/java/com/sun/webkit/network/URLLoader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NetworkContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../module-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/java/com/sun/webkit/network/URLLoader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.webkit.network;
  27 
  28 import com.sun.javafx.logging.PlatformLogger;
  29 import com.sun.javafx.logging.PlatformLogger.Level;
  30 import com.sun.webkit.Invoker;
  31 import com.sun.webkit.LoadListenerClient;
  32 import com.sun.webkit.WebPage;
  33 import static com.sun.webkit.network.URLs.newURL;
  34 import java.io.EOFException;
  35 import java.io.File;
  36 import java.io.FileNotFoundException;
  37 import java.io.IOException;
  38 import java.io.InputStream;
  39 import java.io.OutputStream;
  40 import java.io.UnsupportedEncodingException;
<span class="line-removed">  41 import java.lang.annotation.Native;</span>
  42 import java.net.ConnectException;
  43 import java.net.HttpRetryException;
  44 import java.net.HttpURLConnection;
  45 import java.net.MalformedURLException;
  46 import java.net.NoRouteToHostException;
  47 import java.net.SocketException;
  48 import java.net.SocketTimeoutException;
  49 import java.net.URL;
  50 import java.net.URLConnection;
  51 import java.net.URLDecoder;
  52 import java.net.UnknownHostException;
  53 import java.nio.ByteBuffer;
  54 import java.security.AccessControlException;
  55 import java.security.AccessController;
  56 import java.security.PrivilegedAction;
  57 import java.util.List;
  58 import java.util.Locale;
  59 import java.util.Map;
  60 import java.util.concurrent.CountDownLatch;
  61 import java.util.zip.GZIPInputStream;
  62 import java.util.zip.InflaterInputStream;
  63 import javax.net.ssl.SSLHandshakeException;
  64 
  65 /**
  66  * A runnable that loads a resource specified by a URL.
  67  */
<span class="line-modified">  68 final class URLLoader implements Runnable {</span>
<span class="line-removed">  69 </span>
<span class="line-removed">  70     @Native public static final int ALLOW_UNASSIGNED = java.net.IDN.ALLOW_UNASSIGNED;</span>
  71 
  72     private static final PlatformLogger logger =
  73             PlatformLogger.getLogger(URLLoader.class.getName());
<span class="line-removed">  74     private static final int MAX_REDIRECTS = 10;</span>
  75     private static final int MAX_BUF_COUNT = 3;
  76     private static final String GET = &quot;GET&quot;;
  77     private static final String HEAD = &quot;HEAD&quot;;
  78     private static final String DELETE = &quot;DELETE&quot;;
  79 
  80 
  81     private final WebPage webPage;
  82     private final ByteBufferPool byteBufferPool;
  83     private final boolean asynchronous;
  84     private String url;
  85     private String method;
  86     private final String headers;
  87     private FormDataElement[] formDataElements;
  88     private final long data;
  89     private volatile boolean canceled = false;
  90 
  91 
  92     /**
  93      * Creates a new {@code URLLoader}.
  94      */
</pre>
<hr />
<pre>
  98               String url,
  99               String method,
 100               String headers,
 101               FormDataElement[] formDataElements,
 102               long data)
 103     {
 104         this.webPage = webPage;
 105         this.byteBufferPool = byteBufferPool;
 106         this.asynchronous = asynchronous;
 107         this.url = url;
 108         this.method = method;
 109         this.headers = headers;
 110         this.formDataElements = formDataElements;
 111         this.data = data;
 112     }
 113 
 114 
 115     /**
 116      * Cancels this loader.
 117      */
<span class="line-modified"> 118     private void fwkCancel() {</span>

 119         if (logger.isLoggable(Level.FINEST)) {
 120             logger.finest(String.format(&quot;data: [0x%016X]&quot;, data));
 121         }
 122         canceled = true;
 123     }
 124 
 125     /**
 126      * {@inheritDoc}
 127      */
 128     @Override
 129     public void run() {
 130         // Run the loader in the page&#39;s access control context
 131         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 132             doRun();
 133             return null;
 134         }, webPage.getAccessControlContext());
 135     }
 136 
 137     /**
 138      * Executes this loader.
 139      */
 140     private void doRun() {
 141         Throwable error = null;
 142         int errorCode = 0;
 143         try {
<span class="line-removed"> 144             int redirectCount = 0;</span>
 145             boolean streaming = true;
 146             boolean connectionResetRetry = true;
 147             while (true) {
 148                 // RT-14438
 149                 String actualUrl = url;
 150                 if (url.startsWith(&quot;file:&quot;)) {
 151                     int questionMarkPosition = url.indexOf(&#39;?&#39;);
 152                     if (questionMarkPosition != -1) {
 153                         actualUrl = url.substring(0, questionMarkPosition);
 154                     }
 155                 }
 156 
 157                 URL urlObject = newURL(actualUrl);
 158 
 159                 // RT-22458
 160                 workaround7177996(urlObject);
 161 
 162                 URLConnection c = urlObject.openConnection();
 163                 prepareConnection(c);
 164 
<span class="line-removed"> 165                 Redirect redirect = null;</span>
 166                 try {
 167                     sendRequest(c, streaming);
<span class="line-modified"> 168                     redirect = receiveResponse(c);</span>
 169                 } catch (HttpRetryException ex) {
 170                     // RT-19914
 171                     if (streaming) {
 172                         streaming = false;
 173                         continue; // retry without streaming
 174                     } else {
 175                         throw ex;
 176                     }
 177                 } catch (SocketException ex) {
 178                     // SocketException: Connection reset, Retry once
 179                     if (&quot;Connection reset&quot;.equals(ex.getMessage()) &amp;&amp; connectionResetRetry) {
 180                         connectionResetRetry = false;
 181                         continue;
 182                     } else {
 183                         throw ex;
 184                     }
 185                 } finally {
 186                     close(c);
 187                 }
<span class="line-modified"> 188 </span>
<span class="line-removed"> 189                 if (redirect != null) {</span>
<span class="line-removed"> 190                     if (redirectCount++ &gt;= MAX_REDIRECTS) {</span>
<span class="line-removed"> 191                         throw new TooManyRedirectsException();</span>
<span class="line-removed"> 192                     }</span>
<span class="line-removed"> 193                     boolean resetRequest = !redirect.preserveRequest</span>
<span class="line-removed"> 194                             &amp;&amp; !method.equals(GET) &amp;&amp; !method.equals(HEAD);</span>
<span class="line-removed"> 195                     String newMethod = resetRequest ? GET : method;</span>
<span class="line-removed"> 196                     willSendRequest(redirect.url, newMethod, c);</span>
<span class="line-removed"> 197                     // willSendRequest() may cancel this loader</span>
<span class="line-removed"> 198                     if (canceled) {</span>
<span class="line-removed"> 199                         break;</span>
<span class="line-removed"> 200                     }</span>
<span class="line-removed"> 201                     url = redirect.url;</span>
<span class="line-removed"> 202                     method = newMethod;</span>
<span class="line-removed"> 203                     formDataElements = resetRequest ? null : formDataElements;</span>
<span class="line-removed"> 204                 } else {</span>
<span class="line-removed"> 205                     break;</span>
<span class="line-removed"> 206                 }</span>
 207             }
 208         } catch (MalformedURLException ex) {
 209             error = ex;
 210             errorCode = LoadListenerClient.MALFORMED_URL;
 211         } catch (AccessControlException ex) {
 212             error = ex;
 213             errorCode = LoadListenerClient.PERMISSION_DENIED;
 214         } catch (UnknownHostException ex) {
 215             error = ex;
 216             errorCode = LoadListenerClient.UNKNOWN_HOST;
 217         } catch (NoRouteToHostException ex) {
 218             error = ex;
 219             errorCode = LoadListenerClient.NO_ROUTE_TO_HOST;
 220         } catch (ConnectException ex) {
 221             error = ex;
 222             errorCode = LoadListenerClient.CONNECTION_REFUSED;
 223         } catch (SocketException ex) {
 224             error = ex;
 225             errorCode = LoadListenerClient.CONNECTION_RESET;
 226         } catch (SSLHandshakeException ex) {
<span class="line-removed"> 235         } catch (TooManyRedirectsException ex) {</span>
<span class="line-removed"> 236             error = ex;</span>
<span class="line-removed"> 237             errorCode = LoadListenerClient.TOO_MANY_REDIRECTS;</span>
 238         } catch (FileNotFoundException ex) {
 239             error = ex;
 240             errorCode = LoadListenerClient.FILE_NOT_FOUND;
 241         } catch (Throwable th) {
 242             error = th;
 243             errorCode = LoadListenerClient.UNKNOWN_ERROR;
 244         }
 245 
 246         if (error != null) {
 247             if (errorCode == LoadListenerClient.UNKNOWN_ERROR) {
 248                 logger.warning(&quot;Unexpected error&quot;, error);
 249             } else {
 250                 logger.finest(&quot;Load error&quot;, error);
 251             }
 252             didFail(errorCode, error.getMessage());
 253         }
 254     }
 255 
 256     private static void workaround7177996(URL url)
 257         throws FileNotFoundException
</pre>
<hr />
<pre>
 400             }
 401         } finally {
 402             if (out != null) {
 403                 try {
 404                     out.close();
 405                 } catch (IOException ignore) {}
 406             }
 407             if (formDataElements != null &amp;&amp; c instanceof HttpURLConnection) {
 408                 for (FormDataElement formDataElement : formDataElements) {
 409                     try {
 410                         formDataElement.close();
 411                     } catch (IOException ignore) {}
 412                 }
 413             }
 414         }
 415     }
 416 
 417     /**
 418      * Receives response from the server.
 419      */
<span class="line-modified"> 420     private Redirect receiveResponse(URLConnection c)</span>
 421         throws IOException, InterruptedException
 422     {
 423         if (canceled) {
<span class="line-modified"> 424             return null;</span>
 425         }
 426 
 427         InputStream errorStream = null;
 428 
 429         if (c instanceof HttpURLConnection) {
 430             HttpURLConnection http = (HttpURLConnection) c;
 431 
 432             int code = http.getResponseCode();
 433             if (code == -1) {
 434                 throw new InvalidResponseException();
 435             }
 436 
 437             if (canceled) {
<span class="line-modified"> 438                 return null;</span>
 439             }
 440 
 441             // See RT-17435
 442             switch (code) {
 443                 case 301: // Moved Permanently
 444                 case 302: // Found
 445                 case 303: // See Other
 446                 case 307: // Temporary Redirect
<span class="line-modified"> 447                     String newLoc = http.getHeaderField(&quot;Location&quot;);</span>
<span class="line-removed"> 448                     if (newLoc != null) {</span>
<span class="line-removed"> 449                         URL newUrl;</span>
<span class="line-removed"> 450                         try {</span>
<span class="line-removed"> 451                             newUrl = newURL(newLoc);</span>
<span class="line-removed"> 452                         } catch (MalformedURLException mue) {</span>
<span class="line-removed"> 453                             // Try to treat newLoc as a relative URI to conform</span>
<span class="line-removed"> 454                             // to popular browsers</span>
<span class="line-removed"> 455                             newUrl = newURL(c.getURL(), newLoc);</span>
<span class="line-removed"> 456                         }</span>
<span class="line-removed"> 457                         return new Redirect(newUrl.toExternalForm(),</span>
<span class="line-removed"> 458                                             code == 307);</span>
<span class="line-removed"> 459                     }</span>
 460                     break;
 461 
 462                 case 304: // Not Modified
 463                     didReceiveResponse(c);
 464                     didFinishLoading();
<span class="line-modified"> 465                     return null;</span>
 466             }
 467 
 468             if (code &gt;= 400 &amp;&amp; !method.equals(HEAD)) {
 469                 errorStream = http.getErrorStream();
 470             }
 471         }
 472 
 473         // Let&#39;s see if it&#39;s an ftp (or ftps) URL and we need to transform
 474         // a directory listing into HTML
 475         if (url.startsWith(&quot;ftp:&quot;) || url.startsWith(&quot;ftps:&quot;)) {
 476             boolean dir = false;
 477             boolean notsure = false;
 478             // Unfortunately, there is no clear way to determine if we are
 479             // accessing a directory, so a bit of guessing is in order
 480             String path = c.getURL().getPath();
 481             if (path == null || path.isEmpty() || path.endsWith(&quot;/&quot;)
 482                     || path.contains(&quot;;type=d&quot;))
 483             {
 484                 dir = true;
 485             } else {
</pre>
<hr />
<pre>
 493             }
 494             if (dir) {
 495                 c = new DirectoryURLConnection(c, notsure);
 496             }
 497         }
 498 
 499         // Same is true for FileURLConnection
 500         if (url.startsWith(&quot;file:&quot;)) {
 501             if(&quot;text/plain&quot;.equals(c.getContentType())
 502                     &amp;&amp; c.getHeaderField(&quot;content-length&quot;) == null)
 503             {
 504                 // It is a directory
 505                 c = new DirectoryURLConnection(c);
 506             }
 507         }
 508 
 509         didReceiveResponse(c);
 510 
 511         if (method.equals(HEAD)) {
 512             didFinishLoading();
<span class="line-modified"> 513             return null;</span>
 514         }
 515 
 516         InputStream inputStream = null;
 517         try {
 518             inputStream = errorStream == null
 519                 ? c.getInputStream() : errorStream;
 520         } catch (HttpRetryException ex) {
 521             // HttpRetryException is handled from doRun() method.
 522             // Hence rethrowing the exception to caller(doRun() method)
 523             throw ex;
 524         } catch (IOException e) {
 525             if (logger.isLoggable(Level.FINE)) {
 526                 logger.fine(String.format(&quot;Exception caught: [%s], %s&quot;,
 527                     e.getClass().getSimpleName(),
 528                     e.getMessage()));
 529             }
 530         }
 531 
 532         String encoding = c.getContentEncoding();
 533         if (inputStream != null) {
</pre>
<hr />
<pre>
 584                         byteBuffer = null;
 585 
 586                         int outstanding = count - remaining;
 587                         if (outstanding &gt; 0) {
 588                             byteBuffer = allocator.allocate();
 589                             byteBuffer.put(buffer, remaining, outstanding);
 590                         }
 591                     }
 592                 }
 593             }
 594             if (!canceled) {
 595                 if (byteBuffer != null &amp;&amp; byteBuffer.position() &gt; 0) {
 596                     byteBuffer.flip();
 597                     didReceiveData(byteBuffer, allocator);
 598                     byteBuffer = null;
 599                 }
 600                 didFinishLoading();
 601             }
 602         } finally {
 603             if (byteBuffer != null) {
<span class="line-removed"> 604                 byteBuffer.clear();</span>
 605                 allocator.release(byteBuffer);
 606             }
 607         }
<span class="line-removed"> 608         return null;</span>
 609     }
 610 
 611     /**
 612      * Releases the resources that may be associated with a connection.
 613      */
 614     private static void close(URLConnection c) {
 615         if (c instanceof HttpURLConnection) {
 616             InputStream errorStream = ((HttpURLConnection) c).getErrorStream();
 617             if (errorStream != null) {
 618                 try {
 619                     errorStream.close();
 620                 } catch (IOException ignore) {}
 621             }
 622         }
 623         try {
 624             c.getInputStream().close();
 625         } catch (IOException ignore) {}
 626     }
 627 
<span class="line-removed"> 628 </span>
<span class="line-removed"> 629     /**</span>
<span class="line-removed"> 630      * A holder for redirect information.</span>
<span class="line-removed"> 631      */</span>
<span class="line-removed"> 632     private static final class Redirect {</span>
<span class="line-removed"> 633         private final String url;</span>
<span class="line-removed"> 634         private final boolean preserveRequest;</span>
<span class="line-removed"> 635 </span>
<span class="line-removed"> 636         private Redirect(String url, boolean preserveRequest) {</span>
<span class="line-removed"> 637             this.url = url;</span>
<span class="line-removed"> 638             this.preserveRequest = preserveRequest;</span>
<span class="line-removed"> 639         }</span>
<span class="line-removed"> 640     }</span>
<span class="line-removed"> 641 </span>
 642     /**
 643      * Signals an invalid response from the server.
 644      */
 645     private static final class InvalidResponseException extends IOException {
 646         private InvalidResponseException() {
 647             super(&quot;Invalid server response&quot;);
 648         }
 649     }
 650 
<span class="line-removed"> 651     /**</span>
<span class="line-removed"> 652      * Signals that too many redirects have been encountered</span>
<span class="line-removed"> 653      * while processing the request.</span>
<span class="line-removed"> 654      */</span>
<span class="line-removed"> 655     private static final class TooManyRedirectsException extends IOException {</span>
<span class="line-removed"> 656         private TooManyRedirectsException() {</span>
<span class="line-removed"> 657             super(&quot;Too many redirects&quot;);</span>
<span class="line-removed"> 658         }</span>
<span class="line-removed"> 659     }</span>
<span class="line-removed"> 660 </span>
 661     private void didSendData(final long totalBytesSent,
 662                              final long totalBytesToBeSent)
 663     {
 664         callBack(() -&gt; {
 665             if (!canceled) {
 666                 notifyDidSendData(totalBytesSent, totalBytesToBeSent);
 667             }
 668         });
 669     }
 670 
 671     private void notifyDidSendData(long totalBytesSent,
 672                                    long totalBytesToBeSent)
 673     {
 674         if (logger.isLoggable(Level.FINEST)) {
 675             logger.finest(String.format(
 676                     &quot;totalBytesSent: [%d], &quot;
 677                     + &quot;totalBytesToBeSent: [%d], &quot;
 678                     + &quot;data: [0x%016X]&quot;,
 679                     totalBytesSent,
 680                     totalBytesToBeSent,
 681                     data));
 682         }
 683         twkDidSendData(totalBytesSent, totalBytesToBeSent, data);
 684     }
 685 
<span class="line-modified"> 686     private void willSendRequest(String newUrl,</span>
<span class="line-removed"> 687                                  final String newMethod,</span>
<span class="line-removed"> 688                                  URLConnection c) throws InterruptedException</span>
 689     {
<span class="line-removed"> 690         final String adjustedNewUrl = adjustUrlForWebKit(newUrl);</span>
 691         final int status = extractStatus(c);
 692         final String contentType = c.getContentType();
 693         final String contentEncoding = extractContentEncoding(c);
 694         final long contentLength = extractContentLength(c);
 695         final String responseHeaders = extractHeaders(c);
 696         final String adjustedUrl = adjustUrlForWebKit(url);
<span class="line-removed"> 697         final CountDownLatch latch =</span>
<span class="line-removed"> 698                 asynchronous ? new CountDownLatch(1) : null;</span>
 699         callBack(() -&gt; {
<span class="line-modified"> 700             try {</span>
<span class="line-modified"> 701                 if (!canceled) {</span>
<span class="line-modified"> 702                     boolean keepGoing = notifyWillSendRequest(</span>
<span class="line-modified"> 703                             adjustedNewUrl,</span>
<span class="line-modified"> 704                             newMethod,</span>
<span class="line-modified"> 705                             status,</span>
<span class="line-modified"> 706                             contentType,</span>
<span class="line-modified"> 707                             contentEncoding,</span>
<span class="line-removed"> 708                             contentLength,</span>
<span class="line-removed"> 709                             responseHeaders,</span>
<span class="line-removed"> 710                             adjustedUrl);</span>
<span class="line-removed"> 711                     if (!keepGoing) {</span>
<span class="line-removed"> 712                         fwkCancel();</span>
<span class="line-removed"> 713                     }</span>
<span class="line-removed"> 714                 }</span>
<span class="line-removed"> 715             } finally {</span>
<span class="line-removed"> 716                 if (latch != null) {</span>
<span class="line-removed"> 717                     latch.countDown();</span>
<span class="line-removed"> 718                 }</span>
 719             }
 720         });
<span class="line-removed"> 721         if (latch != null) {</span>
<span class="line-removed"> 722             latch.await();</span>
<span class="line-removed"> 723         }</span>
 724     }
 725 
<span class="line-modified"> 726     private boolean notifyWillSendRequest(String newUrl,</span>
<span class="line-removed"> 727                                           String newMethod,</span>
<span class="line-removed"> 728                                           int status,</span>
 729                                           String contentType,
 730                                           String contentEncoding,
 731                                           long contentLength,
 732                                           String headers,
 733                                           String url)
 734     {
 735         if (logger.isLoggable(Level.FINEST)) {
 736             logger.finest(String.format(
<span class="line-modified"> 737                     &quot;newUrl: [%s], &quot;</span>
<span class="line-removed"> 738                     + &quot;newMethod: [%s], &quot;</span>
<span class="line-removed"> 739                     + &quot;status: [%d], &quot;</span>
 740                     + &quot;contentType: [%s], &quot;
 741                     + &quot;contentEncoding: [%s], &quot;
 742                     + &quot;contentLength: [%d], &quot;
 743                     + &quot;url: [%s], &quot;
 744                     + &quot;data: [0x%016X], &quot;
 745                     + &quot;headers:%n%s&quot;,
<span class="line-removed"> 746                     newUrl,</span>
<span class="line-removed"> 747                     newMethod,</span>
 748                     status,
 749                     contentType,
 750                     contentEncoding,
 751                     contentLength,
 752                     url,
 753                     data,
 754                     Util.formatHeaders(headers)));
 755         }
<span class="line-modified"> 756         boolean result = twkWillSendRequest(</span>
<span class="line-removed"> 757                 newUrl,</span>
<span class="line-removed"> 758                 newMethod,</span>
 759                 status,
 760                 contentType,
 761                 contentEncoding,
 762                 contentLength,
 763                 headers,
 764                 url,
 765                 data);
<span class="line-removed"> 766         if (logger.isLoggable(Level.FINEST)) {</span>
<span class="line-removed"> 767             logger.finest(String.format(&quot;result: [%s]&quot;, result));</span>
<span class="line-removed"> 768         }</span>
<span class="line-removed"> 769         return result;</span>
 770     }
 771 
 772     private void didReceiveResponse(URLConnection c) {
 773         final int status = extractStatus(c);
 774         final String contentType = c.getContentType();
 775         final String contentEncoding = extractContentEncoding(c);
 776         final long contentLength = extractContentLength(c);
 777         final String responseHeaders = extractHeaders(c);
 778         final String adjustedUrl = adjustUrlForWebKit(url);
 779         callBack(() -&gt; {
 780             if (!canceled) {
 781                 notifyDidReceiveResponse(
 782                         status,
 783                         contentType,
 784                         contentEncoding,
 785                         contentLength,
 786                         responseHeaders,
 787                         adjustedUrl);
 788             }
 789         });
</pre>
<hr />
<pre>
 816         twkDidReceiveResponse(
 817                 status,
 818                 contentType,
 819                 contentEncoding,
 820                 contentLength,
 821                 headers,
 822                 url,
 823                 data);
 824     }
 825 
 826     private void didReceiveData(final ByteBuffer byteBuffer,
 827                                 final ByteBufferAllocator allocator)
 828     {
 829         callBack(() -&gt; {
 830             if (!canceled) {
 831                 notifyDidReceiveData(
 832                         byteBuffer,
 833                         byteBuffer.position(),
 834                         byteBuffer.remaining());
 835             }
<span class="line-removed"> 836             byteBuffer.clear();</span>
 837             allocator.release(byteBuffer);
 838         });
 839     }
 840 
 841     private void notifyDidReceiveData(ByteBuffer byteBuffer,
 842                                       int position,
 843                                       int remaining)
 844     {
 845         if (logger.isLoggable(Level.FINEST)) {
 846             logger.finest(String.format(
 847                     &quot;byteBuffer: [%s], &quot;
 848                     + &quot;position: [%s], &quot;
 849                     + &quot;remaining: [%s], &quot;
 850                     + &quot;data: [0x%016X]&quot;,
 851                     byteBuffer,
 852                     position,
 853                     remaining,
 854                     data));
 855         }
 856         twkDidReceiveData(byteBuffer, position, remaining, data);
</pre>
<hr />
<pre>
 886                     &quot;errorCode: [%d], &quot;
 887                     + &quot;url: [%s], &quot;
 888                     + &quot;message: [%s], &quot;
 889                     + &quot;data: [0x%016X]&quot;,
 890                     errorCode,
 891                     url,
 892                     message,
 893                     data));
 894         }
 895         twkDidFail(errorCode, url, message, data);
 896     }
 897 
 898     private void callBack(Runnable runnable) {
 899         if (asynchronous) {
 900             Invoker.getInvoker().invokeOnEventThread(runnable);
 901         } else {
 902             runnable.run();
 903         }
 904     }
 905 
<span class="line-removed"> 906     private static native void twkDidSendData(long totalBytesSent,</span>
<span class="line-removed"> 907                                               long totalBytesToBeSent,</span>
<span class="line-removed"> 908                                               long data);</span>
<span class="line-removed"> 909 </span>
<span class="line-removed"> 910     private static native boolean twkWillSendRequest(String newUrl,</span>
<span class="line-removed"> 911                                                      String newMethod,</span>
<span class="line-removed"> 912                                                      int status,</span>
<span class="line-removed"> 913                                                      String contentType,</span>
<span class="line-removed"> 914                                                      String contentEncoding,</span>
<span class="line-removed"> 915                                                      long contentLength,</span>
<span class="line-removed"> 916                                                      String headers,</span>
<span class="line-removed"> 917                                                      String url,</span>
<span class="line-removed"> 918                                                      long data);</span>
<span class="line-removed"> 919 </span>
<span class="line-removed"> 920     private static native void twkDidReceiveResponse(int status,</span>
<span class="line-removed"> 921                                                      String contentType,</span>
<span class="line-removed"> 922                                                      String contentEncoding,</span>
<span class="line-removed"> 923                                                      long contentLength,</span>
<span class="line-removed"> 924                                                      String headers,</span>
<span class="line-removed"> 925                                                      String url,</span>
<span class="line-removed"> 926                                                      long data);</span>
<span class="line-removed"> 927 </span>
<span class="line-removed"> 928     private static native void twkDidReceiveData(ByteBuffer byteBuffer,</span>
<span class="line-removed"> 929                                                  int position,</span>
<span class="line-removed"> 930                                                  int remaining,</span>
<span class="line-removed"> 931                                                  long data);</span>
<span class="line-removed"> 932 </span>
<span class="line-removed"> 933     private static native void twkDidFinishLoading(long data);</span>
<span class="line-removed"> 934 </span>
<span class="line-removed"> 935     private static native void twkDidFail(int errorCode,</span>
<span class="line-removed"> 936                                           String url,</span>
<span class="line-removed"> 937                                           String message,</span>
<span class="line-removed"> 938                                           long data);</span>
<span class="line-removed"> 939 </span>
 940     /**
 941      * Given a {@link URLConnection}, returns the connection status
 942      * for passing into native callbacks.
 943      */
 944     private static int extractStatus(URLConnection c) {
 945         int status = 0;
 946         if (c instanceof HttpURLConnection) {
 947             try {
 948                 status = ((HttpURLConnection) c).getResponseCode();
 949             } catch (java.io.IOException ignore) {}
 950         }
 951         return status;
 952     }
 953 
 954     /**
 955      * Given a {@link URLConnection}, returns the content encoding
 956      * for passing into native callbacks.
 957      */
 958     private static String extractContentEncoding(URLConnection c) {
 959         String contentEncoding = c.getContentEncoding();
</pre>
</td>
<td>
<hr />
<pre>
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.webkit.network;
  27 
  28 import com.sun.javafx.logging.PlatformLogger;
  29 import com.sun.javafx.logging.PlatformLogger.Level;
  30 import com.sun.webkit.Invoker;
  31 import com.sun.webkit.LoadListenerClient;
  32 import com.sun.webkit.WebPage;
  33 import static com.sun.webkit.network.URLs.newURL;
  34 import java.io.EOFException;
  35 import java.io.File;
  36 import java.io.FileNotFoundException;
  37 import java.io.IOException;
  38 import java.io.InputStream;
  39 import java.io.OutputStream;
  40 import java.io.UnsupportedEncodingException;

  41 import java.net.ConnectException;
  42 import java.net.HttpRetryException;
  43 import java.net.HttpURLConnection;
  44 import java.net.MalformedURLException;
  45 import java.net.NoRouteToHostException;
  46 import java.net.SocketException;
  47 import java.net.SocketTimeoutException;
  48 import java.net.URL;
  49 import java.net.URLConnection;
  50 import java.net.URLDecoder;
  51 import java.net.UnknownHostException;
  52 import java.nio.ByteBuffer;
  53 import java.security.AccessControlException;
  54 import java.security.AccessController;
  55 import java.security.PrivilegedAction;
  56 import java.util.List;
  57 import java.util.Locale;
  58 import java.util.Map;
  59 import java.util.concurrent.CountDownLatch;
  60 import java.util.zip.GZIPInputStream;
  61 import java.util.zip.InflaterInputStream;
  62 import javax.net.ssl.SSLHandshakeException;
  63 
  64 /**
  65  * A runnable that loads a resource specified by a URL.
  66  */
<span class="line-modified">  67 final class URLLoader extends URLLoaderBase implements Runnable {</span>


  68 
  69     private static final PlatformLogger logger =
  70             PlatformLogger.getLogger(URLLoader.class.getName());

  71     private static final int MAX_BUF_COUNT = 3;
  72     private static final String GET = &quot;GET&quot;;
  73     private static final String HEAD = &quot;HEAD&quot;;
  74     private static final String DELETE = &quot;DELETE&quot;;
  75 
  76 
  77     private final WebPage webPage;
  78     private final ByteBufferPool byteBufferPool;
  79     private final boolean asynchronous;
  80     private String url;
  81     private String method;
  82     private final String headers;
  83     private FormDataElement[] formDataElements;
  84     private final long data;
  85     private volatile boolean canceled = false;
  86 
  87 
  88     /**
  89      * Creates a new {@code URLLoader}.
  90      */
</pre>
<hr />
<pre>
  94               String url,
  95               String method,
  96               String headers,
  97               FormDataElement[] formDataElements,
  98               long data)
  99     {
 100         this.webPage = webPage;
 101         this.byteBufferPool = byteBufferPool;
 102         this.asynchronous = asynchronous;
 103         this.url = url;
 104         this.method = method;
 105         this.headers = headers;
 106         this.formDataElements = formDataElements;
 107         this.data = data;
 108     }
 109 
 110 
 111     /**
 112      * Cancels this loader.
 113      */
<span class="line-modified"> 114     @Override</span>
<span class="line-added"> 115     public void fwkCancel() {</span>
 116         if (logger.isLoggable(Level.FINEST)) {
 117             logger.finest(String.format(&quot;data: [0x%016X]&quot;, data));
 118         }
 119         canceled = true;
 120     }
 121 
 122     /**
 123      * {@inheritDoc}
 124      */
 125     @Override
 126     public void run() {
 127         // Run the loader in the page&#39;s access control context
 128         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 129             doRun();
 130             return null;
 131         }, webPage.getAccessControlContext());
 132     }
 133 
 134     /**
 135      * Executes this loader.
 136      */
 137     private void doRun() {
 138         Throwable error = null;
 139         int errorCode = 0;
 140         try {

 141             boolean streaming = true;
 142             boolean connectionResetRetry = true;
 143             while (true) {
 144                 // RT-14438
 145                 String actualUrl = url;
 146                 if (url.startsWith(&quot;file:&quot;)) {
 147                     int questionMarkPosition = url.indexOf(&#39;?&#39;);
 148                     if (questionMarkPosition != -1) {
 149                         actualUrl = url.substring(0, questionMarkPosition);
 150                     }
 151                 }
 152 
 153                 URL urlObject = newURL(actualUrl);
 154 
 155                 // RT-22458
 156                 workaround7177996(urlObject);
 157 
 158                 URLConnection c = urlObject.openConnection();
 159                 prepareConnection(c);
 160 

 161                 try {
 162                     sendRequest(c, streaming);
<span class="line-modified"> 163                     receiveResponse(c);</span>
 164                 } catch (HttpRetryException ex) {
 165                     // RT-19914
 166                     if (streaming) {
 167                         streaming = false;
 168                         continue; // retry without streaming
 169                     } else {
 170                         throw ex;
 171                     }
 172                 } catch (SocketException ex) {
 173                     // SocketException: Connection reset, Retry once
 174                     if (&quot;Connection reset&quot;.equals(ex.getMessage()) &amp;&amp; connectionResetRetry) {
 175                         connectionResetRetry = false;
 176                         continue;
 177                     } else {
 178                         throw ex;
 179                     }
 180                 } finally {
 181                     close(c);
 182                 }
<span class="line-modified"> 183                 break;</span>


















 184             }
 185         } catch (MalformedURLException ex) {
 186             error = ex;
 187             errorCode = LoadListenerClient.MALFORMED_URL;
 188         } catch (AccessControlException ex) {
 189             error = ex;
 190             errorCode = LoadListenerClient.PERMISSION_DENIED;
 191         } catch (UnknownHostException ex) {
 192             error = ex;
 193             errorCode = LoadListenerClient.UNKNOWN_HOST;
 194         } catch (NoRouteToHostException ex) {
 195             error = ex;
 196             errorCode = LoadListenerClient.NO_ROUTE_TO_HOST;
 197         } catch (ConnectException ex) {
 198             error = ex;
 199             errorCode = LoadListenerClient.CONNECTION_REFUSED;
 200         } catch (SocketException ex) {
 201             error = ex;
 202             errorCode = LoadListenerClient.CONNECTION_RESET;
 203         } catch (SSLHandshakeException ex) {



 212         } catch (FileNotFoundException ex) {
 213             error = ex;
 214             errorCode = LoadListenerClient.FILE_NOT_FOUND;
 215         } catch (Throwable th) {
 216             error = th;
 217             errorCode = LoadListenerClient.UNKNOWN_ERROR;
 218         }
 219 
 220         if (error != null) {
 221             if (errorCode == LoadListenerClient.UNKNOWN_ERROR) {
 222                 logger.warning(&quot;Unexpected error&quot;, error);
 223             } else {
 224                 logger.finest(&quot;Load error&quot;, error);
 225             }
 226             didFail(errorCode, error.getMessage());
 227         }
 228     }
 229 
 230     private static void workaround7177996(URL url)
 231         throws FileNotFoundException
</pre>
<hr />
<pre>
 374             }
 375         } finally {
 376             if (out != null) {
 377                 try {
 378                     out.close();
 379                 } catch (IOException ignore) {}
 380             }
 381             if (formDataElements != null &amp;&amp; c instanceof HttpURLConnection) {
 382                 for (FormDataElement formDataElement : formDataElements) {
 383                     try {
 384                         formDataElement.close();
 385                     } catch (IOException ignore) {}
 386                 }
 387             }
 388         }
 389     }
 390 
 391     /**
 392      * Receives response from the server.
 393      */
<span class="line-modified"> 394     private void receiveResponse(URLConnection c)</span>
 395         throws IOException, InterruptedException
 396     {
 397         if (canceled) {
<span class="line-modified"> 398             return;</span>
 399         }
 400 
 401         InputStream errorStream = null;
 402 
 403         if (c instanceof HttpURLConnection) {
 404             HttpURLConnection http = (HttpURLConnection) c;
 405 
 406             int code = http.getResponseCode();
 407             if (code == -1) {
 408                 throw new InvalidResponseException();
 409             }
 410 
 411             if (canceled) {
<span class="line-modified"> 412                 return;</span>
 413             }
 414 
 415             // See RT-17435
 416             switch (code) {
 417                 case 301: // Moved Permanently
 418                 case 302: // Found
 419                 case 303: // See Other
 420                 case 307: // Temporary Redirect
<span class="line-modified"> 421                     willSendRequest(c);</span>












 422                     break;
 423 
 424                 case 304: // Not Modified
 425                     didReceiveResponse(c);
 426                     didFinishLoading();
<span class="line-modified"> 427                     return;</span>
 428             }
 429 
 430             if (code &gt;= 400 &amp;&amp; !method.equals(HEAD)) {
 431                 errorStream = http.getErrorStream();
 432             }
 433         }
 434 
 435         // Let&#39;s see if it&#39;s an ftp (or ftps) URL and we need to transform
 436         // a directory listing into HTML
 437         if (url.startsWith(&quot;ftp:&quot;) || url.startsWith(&quot;ftps:&quot;)) {
 438             boolean dir = false;
 439             boolean notsure = false;
 440             // Unfortunately, there is no clear way to determine if we are
 441             // accessing a directory, so a bit of guessing is in order
 442             String path = c.getURL().getPath();
 443             if (path == null || path.isEmpty() || path.endsWith(&quot;/&quot;)
 444                     || path.contains(&quot;;type=d&quot;))
 445             {
 446                 dir = true;
 447             } else {
</pre>
<hr />
<pre>
 455             }
 456             if (dir) {
 457                 c = new DirectoryURLConnection(c, notsure);
 458             }
 459         }
 460 
 461         // Same is true for FileURLConnection
 462         if (url.startsWith(&quot;file:&quot;)) {
 463             if(&quot;text/plain&quot;.equals(c.getContentType())
 464                     &amp;&amp; c.getHeaderField(&quot;content-length&quot;) == null)
 465             {
 466                 // It is a directory
 467                 c = new DirectoryURLConnection(c);
 468             }
 469         }
 470 
 471         didReceiveResponse(c);
 472 
 473         if (method.equals(HEAD)) {
 474             didFinishLoading();
<span class="line-modified"> 475             return;</span>
 476         }
 477 
 478         InputStream inputStream = null;
 479         try {
 480             inputStream = errorStream == null
 481                 ? c.getInputStream() : errorStream;
 482         } catch (HttpRetryException ex) {
 483             // HttpRetryException is handled from doRun() method.
 484             // Hence rethrowing the exception to caller(doRun() method)
 485             throw ex;
 486         } catch (IOException e) {
 487             if (logger.isLoggable(Level.FINE)) {
 488                 logger.fine(String.format(&quot;Exception caught: [%s], %s&quot;,
 489                     e.getClass().getSimpleName(),
 490                     e.getMessage()));
 491             }
 492         }
 493 
 494         String encoding = c.getContentEncoding();
 495         if (inputStream != null) {
</pre>
<hr />
<pre>
 546                         byteBuffer = null;
 547 
 548                         int outstanding = count - remaining;
 549                         if (outstanding &gt; 0) {
 550                             byteBuffer = allocator.allocate();
 551                             byteBuffer.put(buffer, remaining, outstanding);
 552                         }
 553                     }
 554                 }
 555             }
 556             if (!canceled) {
 557                 if (byteBuffer != null &amp;&amp; byteBuffer.position() &gt; 0) {
 558                     byteBuffer.flip();
 559                     didReceiveData(byteBuffer, allocator);
 560                     byteBuffer = null;
 561                 }
 562                 didFinishLoading();
 563             }
 564         } finally {
 565             if (byteBuffer != null) {

 566                 allocator.release(byteBuffer);
 567             }
 568         }

 569     }
 570 
 571     /**
 572      * Releases the resources that may be associated with a connection.
 573      */
 574     private static void close(URLConnection c) {
 575         if (c instanceof HttpURLConnection) {
 576             InputStream errorStream = ((HttpURLConnection) c).getErrorStream();
 577             if (errorStream != null) {
 578                 try {
 579                     errorStream.close();
 580                 } catch (IOException ignore) {}
 581             }
 582         }
 583         try {
 584             c.getInputStream().close();
 585         } catch (IOException ignore) {}
 586     }
 587 














 588     /**
 589      * Signals an invalid response from the server.
 590      */
 591     private static final class InvalidResponseException extends IOException {
 592         private InvalidResponseException() {
 593             super(&quot;Invalid server response&quot;);
 594         }
 595     }
 596 










 597     private void didSendData(final long totalBytesSent,
 598                              final long totalBytesToBeSent)
 599     {
 600         callBack(() -&gt; {
 601             if (!canceled) {
 602                 notifyDidSendData(totalBytesSent, totalBytesToBeSent);
 603             }
 604         });
 605     }
 606 
 607     private void notifyDidSendData(long totalBytesSent,
 608                                    long totalBytesToBeSent)
 609     {
 610         if (logger.isLoggable(Level.FINEST)) {
 611             logger.finest(String.format(
 612                     &quot;totalBytesSent: [%d], &quot;
 613                     + &quot;totalBytesToBeSent: [%d], &quot;
 614                     + &quot;data: [0x%016X]&quot;,
 615                     totalBytesSent,
 616                     totalBytesToBeSent,
 617                     data));
 618         }
 619         twkDidSendData(totalBytesSent, totalBytesToBeSent, data);
 620     }
 621 
<span class="line-modified"> 622     private void willSendRequest(URLConnection c) throws InterruptedException</span>


 623     {

 624         final int status = extractStatus(c);
 625         final String contentType = c.getContentType();
 626         final String contentEncoding = extractContentEncoding(c);
 627         final long contentLength = extractContentLength(c);
 628         final String responseHeaders = extractHeaders(c);
 629         final String adjustedUrl = adjustUrlForWebKit(url);


 630         callBack(() -&gt; {
<span class="line-modified"> 631             if (!canceled) {</span>
<span class="line-modified"> 632                 notifyWillSendRequest(</span>
<span class="line-modified"> 633                         status,</span>
<span class="line-modified"> 634                         contentType,</span>
<span class="line-modified"> 635                         contentEncoding,</span>
<span class="line-modified"> 636                         contentLength,</span>
<span class="line-modified"> 637                         responseHeaders,</span>
<span class="line-modified"> 638                         adjustedUrl);</span>











 639             }
 640         });



 641     }
 642 
<span class="line-modified"> 643     private void notifyWillSendRequest(int status,</span>


 644                                           String contentType,
 645                                           String contentEncoding,
 646                                           long contentLength,
 647                                           String headers,
 648                                           String url)
 649     {
 650         if (logger.isLoggable(Level.FINEST)) {
 651             logger.finest(String.format(
<span class="line-modified"> 652                     &quot;status: [%d], &quot;</span>


 653                     + &quot;contentType: [%s], &quot;
 654                     + &quot;contentEncoding: [%s], &quot;
 655                     + &quot;contentLength: [%d], &quot;
 656                     + &quot;url: [%s], &quot;
 657                     + &quot;data: [0x%016X], &quot;
 658                     + &quot;headers:%n%s&quot;,


 659                     status,
 660                     contentType,
 661                     contentEncoding,
 662                     contentLength,
 663                     url,
 664                     data,
 665                     Util.formatHeaders(headers)));
 666         }
<span class="line-modified"> 667         twkWillSendRequest(</span>


 668                 status,
 669                 contentType,
 670                 contentEncoding,
 671                 contentLength,
 672                 headers,
 673                 url,
 674                 data);




 675     }
 676 
 677     private void didReceiveResponse(URLConnection c) {
 678         final int status = extractStatus(c);
 679         final String contentType = c.getContentType();
 680         final String contentEncoding = extractContentEncoding(c);
 681         final long contentLength = extractContentLength(c);
 682         final String responseHeaders = extractHeaders(c);
 683         final String adjustedUrl = adjustUrlForWebKit(url);
 684         callBack(() -&gt; {
 685             if (!canceled) {
 686                 notifyDidReceiveResponse(
 687                         status,
 688                         contentType,
 689                         contentEncoding,
 690                         contentLength,
 691                         responseHeaders,
 692                         adjustedUrl);
 693             }
 694         });
</pre>
<hr />
<pre>
 721         twkDidReceiveResponse(
 722                 status,
 723                 contentType,
 724                 contentEncoding,
 725                 contentLength,
 726                 headers,
 727                 url,
 728                 data);
 729     }
 730 
 731     private void didReceiveData(final ByteBuffer byteBuffer,
 732                                 final ByteBufferAllocator allocator)
 733     {
 734         callBack(() -&gt; {
 735             if (!canceled) {
 736                 notifyDidReceiveData(
 737                         byteBuffer,
 738                         byteBuffer.position(),
 739                         byteBuffer.remaining());
 740             }

 741             allocator.release(byteBuffer);
 742         });
 743     }
 744 
 745     private void notifyDidReceiveData(ByteBuffer byteBuffer,
 746                                       int position,
 747                                       int remaining)
 748     {
 749         if (logger.isLoggable(Level.FINEST)) {
 750             logger.finest(String.format(
 751                     &quot;byteBuffer: [%s], &quot;
 752                     + &quot;position: [%s], &quot;
 753                     + &quot;remaining: [%s], &quot;
 754                     + &quot;data: [0x%016X]&quot;,
 755                     byteBuffer,
 756                     position,
 757                     remaining,
 758                     data));
 759         }
 760         twkDidReceiveData(byteBuffer, position, remaining, data);
</pre>
<hr />
<pre>
 790                     &quot;errorCode: [%d], &quot;
 791                     + &quot;url: [%s], &quot;
 792                     + &quot;message: [%s], &quot;
 793                     + &quot;data: [0x%016X]&quot;,
 794                     errorCode,
 795                     url,
 796                     message,
 797                     data));
 798         }
 799         twkDidFail(errorCode, url, message, data);
 800     }
 801 
 802     private void callBack(Runnable runnable) {
 803         if (asynchronous) {
 804             Invoker.getInvoker().invokeOnEventThread(runnable);
 805         } else {
 806             runnable.run();
 807         }
 808     }
 809 


































 810     /**
 811      * Given a {@link URLConnection}, returns the connection status
 812      * for passing into native callbacks.
 813      */
 814     private static int extractStatus(URLConnection c) {
 815         int status = 0;
 816         if (c instanceof HttpURLConnection) {
 817             try {
 818                 status = ((HttpURLConnection) c).getResponseCode();
 819             } catch (java.io.IOException ignore) {}
 820         }
 821         return status;
 822     }
 823 
 824     /**
 825      * Given a {@link URLConnection}, returns the content encoding
 826      * for passing into native callbacks.
 827      */
 828     private static String extractContentEncoding(URLConnection c) {
 829         String contentEncoding = c.getContentEncoding();
</pre>
</td>
</tr>
</table>
<center><a href="NetworkContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../module-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>