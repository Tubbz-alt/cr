<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/com/sun/webkit/network/URLLoader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.webkit.network;
  27 
  28 import com.sun.javafx.logging.PlatformLogger;
  29 import com.sun.javafx.logging.PlatformLogger.Level;
  30 import com.sun.webkit.Invoker;
  31 import com.sun.webkit.LoadListenerClient;
  32 import com.sun.webkit.WebPage;
  33 import static com.sun.webkit.network.URLs.newURL;
  34 import java.io.EOFException;
  35 import java.io.File;
  36 import java.io.FileNotFoundException;
  37 import java.io.IOException;
  38 import java.io.InputStream;
  39 import java.io.OutputStream;
  40 import java.io.UnsupportedEncodingException;
<a name="1" id="anc1"></a><span class="line-removed">  41 import java.lang.annotation.Native;</span>
  42 import java.net.ConnectException;
  43 import java.net.HttpRetryException;
  44 import java.net.HttpURLConnection;
  45 import java.net.MalformedURLException;
  46 import java.net.NoRouteToHostException;
  47 import java.net.SocketException;
  48 import java.net.SocketTimeoutException;
  49 import java.net.URL;
  50 import java.net.URLConnection;
  51 import java.net.URLDecoder;
  52 import java.net.UnknownHostException;
  53 import java.nio.ByteBuffer;
  54 import java.security.AccessControlException;
  55 import java.security.AccessController;
  56 import java.security.PrivilegedAction;
  57 import java.util.List;
  58 import java.util.Locale;
  59 import java.util.Map;
  60 import java.util.concurrent.CountDownLatch;
  61 import java.util.zip.GZIPInputStream;
  62 import java.util.zip.InflaterInputStream;
  63 import javax.net.ssl.SSLHandshakeException;
  64 
  65 /**
  66  * A runnable that loads a resource specified by a URL.
  67  */
<a name="2" id="anc2"></a><span class="line-modified">  68 final class URLLoader implements Runnable {</span>
<span class="line-removed">  69 </span>
<span class="line-removed">  70     @Native public static final int ALLOW_UNASSIGNED = java.net.IDN.ALLOW_UNASSIGNED;</span>
  71 
  72     private static final PlatformLogger logger =
  73             PlatformLogger.getLogger(URLLoader.class.getName());
<a name="3" id="anc3"></a><span class="line-removed">  74     private static final int MAX_REDIRECTS = 10;</span>
  75     private static final int MAX_BUF_COUNT = 3;
  76     private static final String GET = &quot;GET&quot;;
  77     private static final String HEAD = &quot;HEAD&quot;;
  78     private static final String DELETE = &quot;DELETE&quot;;
  79 
  80 
  81     private final WebPage webPage;
  82     private final ByteBufferPool byteBufferPool;
  83     private final boolean asynchronous;
  84     private String url;
  85     private String method;
  86     private final String headers;
  87     private FormDataElement[] formDataElements;
  88     private final long data;
  89     private volatile boolean canceled = false;
  90 
  91 
  92     /**
  93      * Creates a new {@code URLLoader}.
  94      */
  95     URLLoader(WebPage webPage,
  96               ByteBufferPool byteBufferPool,
  97               boolean asynchronous,
  98               String url,
  99               String method,
 100               String headers,
 101               FormDataElement[] formDataElements,
 102               long data)
 103     {
 104         this.webPage = webPage;
 105         this.byteBufferPool = byteBufferPool;
 106         this.asynchronous = asynchronous;
 107         this.url = url;
 108         this.method = method;
 109         this.headers = headers;
 110         this.formDataElements = formDataElements;
 111         this.data = data;
 112     }
 113 
 114 
 115     /**
 116      * Cancels this loader.
 117      */
<a name="4" id="anc4"></a><span class="line-modified"> 118     private void fwkCancel() {</span>

 119         if (logger.isLoggable(Level.FINEST)) {
 120             logger.finest(String.format(&quot;data: [0x%016X]&quot;, data));
 121         }
 122         canceled = true;
 123     }
 124 
 125     /**
 126      * {@inheritDoc}
 127      */
 128     @Override
 129     public void run() {
 130         // Run the loader in the page&#39;s access control context
 131         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 132             doRun();
 133             return null;
 134         }, webPage.getAccessControlContext());
 135     }
 136 
 137     /**
 138      * Executes this loader.
 139      */
 140     private void doRun() {
 141         Throwable error = null;
 142         int errorCode = 0;
 143         try {
<a name="5" id="anc5"></a><span class="line-removed"> 144             int redirectCount = 0;</span>
 145             boolean streaming = true;
 146             boolean connectionResetRetry = true;
 147             while (true) {
 148                 // RT-14438
 149                 String actualUrl = url;
 150                 if (url.startsWith(&quot;file:&quot;)) {
 151                     int questionMarkPosition = url.indexOf(&#39;?&#39;);
 152                     if (questionMarkPosition != -1) {
 153                         actualUrl = url.substring(0, questionMarkPosition);
 154                     }
 155                 }
 156 
 157                 URL urlObject = newURL(actualUrl);
 158 
 159                 // RT-22458
 160                 workaround7177996(urlObject);
 161 
 162                 URLConnection c = urlObject.openConnection();
 163                 prepareConnection(c);
 164 
<a name="6" id="anc6"></a><span class="line-removed"> 165                 Redirect redirect = null;</span>
 166                 try {
 167                     sendRequest(c, streaming);
<a name="7" id="anc7"></a><span class="line-modified"> 168                     redirect = receiveResponse(c);</span>
 169                 } catch (HttpRetryException ex) {
 170                     // RT-19914
 171                     if (streaming) {
 172                         streaming = false;
 173                         continue; // retry without streaming
 174                     } else {
 175                         throw ex;
 176                     }
 177                 } catch (SocketException ex) {
 178                     // SocketException: Connection reset, Retry once
 179                     if (&quot;Connection reset&quot;.equals(ex.getMessage()) &amp;&amp; connectionResetRetry) {
 180                         connectionResetRetry = false;
 181                         continue;
 182                     } else {
 183                         throw ex;
 184                     }
 185                 } finally {
 186                     close(c);
 187                 }
<a name="8" id="anc8"></a><span class="line-modified"> 188 </span>
<span class="line-removed"> 189                 if (redirect != null) {</span>
<span class="line-removed"> 190                     if (redirectCount++ &gt;= MAX_REDIRECTS) {</span>
<span class="line-removed"> 191                         throw new TooManyRedirectsException();</span>
<span class="line-removed"> 192                     }</span>
<span class="line-removed"> 193                     boolean resetRequest = !redirect.preserveRequest</span>
<span class="line-removed"> 194                             &amp;&amp; !method.equals(GET) &amp;&amp; !method.equals(HEAD);</span>
<span class="line-removed"> 195                     String newMethod = resetRequest ? GET : method;</span>
<span class="line-removed"> 196                     willSendRequest(redirect.url, newMethod, c);</span>
<span class="line-removed"> 197                     // willSendRequest() may cancel this loader</span>
<span class="line-removed"> 198                     if (canceled) {</span>
<span class="line-removed"> 199                         break;</span>
<span class="line-removed"> 200                     }</span>
<span class="line-removed"> 201                     url = redirect.url;</span>
<span class="line-removed"> 202                     method = newMethod;</span>
<span class="line-removed"> 203                     formDataElements = resetRequest ? null : formDataElements;</span>
<span class="line-removed"> 204                 } else {</span>
<span class="line-removed"> 205                     break;</span>
<span class="line-removed"> 206                 }</span>
 207             }
 208         } catch (MalformedURLException ex) {
 209             error = ex;
 210             errorCode = LoadListenerClient.MALFORMED_URL;
 211         } catch (AccessControlException ex) {
 212             error = ex;
 213             errorCode = LoadListenerClient.PERMISSION_DENIED;
 214         } catch (UnknownHostException ex) {
 215             error = ex;
 216             errorCode = LoadListenerClient.UNKNOWN_HOST;
 217         } catch (NoRouteToHostException ex) {
 218             error = ex;
 219             errorCode = LoadListenerClient.NO_ROUTE_TO_HOST;
 220         } catch (ConnectException ex) {
 221             error = ex;
 222             errorCode = LoadListenerClient.CONNECTION_REFUSED;
 223         } catch (SocketException ex) {
 224             error = ex;
 225             errorCode = LoadListenerClient.CONNECTION_RESET;
 226         } catch (SSLHandshakeException ex) {
 227             error = ex;
 228             errorCode = LoadListenerClient.SSL_HANDSHAKE;
 229         } catch (SocketTimeoutException ex) {
 230             error = ex;
 231             errorCode = LoadListenerClient.CONNECTION_TIMED_OUT;
 232         } catch (InvalidResponseException ex) {
 233             error = ex;
 234             errorCode = LoadListenerClient.INVALID_RESPONSE;
<a name="9" id="anc9"></a><span class="line-removed"> 235         } catch (TooManyRedirectsException ex) {</span>
<span class="line-removed"> 236             error = ex;</span>
<span class="line-removed"> 237             errorCode = LoadListenerClient.TOO_MANY_REDIRECTS;</span>
 238         } catch (FileNotFoundException ex) {
 239             error = ex;
 240             errorCode = LoadListenerClient.FILE_NOT_FOUND;
 241         } catch (Throwable th) {
 242             error = th;
 243             errorCode = LoadListenerClient.UNKNOWN_ERROR;
 244         }
 245 
 246         if (error != null) {
 247             if (errorCode == LoadListenerClient.UNKNOWN_ERROR) {
 248                 logger.warning(&quot;Unexpected error&quot;, error);
 249             } else {
 250                 logger.finest(&quot;Load error&quot;, error);
 251             }
 252             didFail(errorCode, error.getMessage());
 253         }
 254     }
 255 
 256     private static void workaround7177996(URL url)
 257         throws FileNotFoundException
 258     {
 259         if (!url.getProtocol().equals(&quot;file&quot;)) {
 260             return;
 261         }
 262 
 263         String host = url.getHost();
 264         if (host == null || host.equals(&quot;&quot;) || host.equals(&quot;~&quot;)
 265                 || host.equalsIgnoreCase(&quot;localhost&quot;) )
 266         {
 267            return;
 268         }
 269 
 270         if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {
 271             String path = null;
 272             try {
 273                 path = URLDecoder.decode(url.getPath(), &quot;UTF-8&quot;);
 274             } catch (UnsupportedEncodingException e) {
 275                 // The system should always have the platform default
 276             }
 277             path = path.replace(&#39;/&#39;, &#39;\\&#39;);
 278             path = path.replace(&#39;|&#39;, &#39;:&#39;);
 279             File file = new File(&quot;\\\\&quot; + host + path);
 280             if (!file.exists()) {
 281                 throw new FileNotFoundException(&quot;File not found: &quot; + url);
 282             }
 283         } else {
 284             throw new FileNotFoundException(&quot;File not found: &quot; + url);
 285         }
 286     }
 287 
 288     /**
 289      * Prepares a connection.
 290      */
 291     private void prepareConnection(URLConnection c) throws IOException {
 292         // The following two timeouts are quite arbitrary and should
 293         // probably be configurable via an API
 294         c.setConnectTimeout(30000);   // 30 seconds
 295         c.setReadTimeout(60000 * 60); // 60 minutes
 296 
 297         // Given that WebKit has its own cache, do not use
 298         // any URLConnection caches, even if someone installs them.
 299         // As a side effect, this fixes the problem of WebPane not
 300         // working well with the plug-in cache, which was one of
 301         // the causes for RT-11880.
 302         c.setUseCaches(false);
 303 
 304         Locale loc = Locale.getDefault();
 305         String lang = &quot;&quot;;
 306         if (!loc.equals(Locale.US) &amp;&amp; !loc.equals(Locale.ENGLISH)) {
 307             lang = loc.getCountry().isEmpty() ?
 308                 loc.getLanguage() + &quot;,&quot;:
 309                 loc.getLanguage() + &quot;-&quot; + loc.getCountry() + &quot;,&quot;;
 310         }
 311         c.setRequestProperty(&quot;Accept-Language&quot;, lang.toLowerCase() + &quot;en-us;q=0.8,en;q=0.7&quot;);
 312         c.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);
 313         c.setRequestProperty(&quot;Accept-Charset&quot;, &quot;ISO-8859-1,utf-8;q=0.7,*;q=0.7&quot;);
 314 
 315         if (headers != null &amp;&amp; headers.length() &gt; 0) {
 316             for (String h : headers.split(&quot;\n&quot;)) {
 317                 int i = h.indexOf(&#39;:&#39;);
 318                 if (i &gt; 0) {
 319                     c.addRequestProperty(h.substring(0, i), h.substring(i + 2));
 320                 }
 321             }
 322         }
 323 
 324         if (c instanceof HttpURLConnection) {
 325             HttpURLConnection httpConnection = (HttpURLConnection) c;
 326             httpConnection.setRequestMethod(method);
 327             // There are too many bugs in the way HttpURLConnection handles
 328             // redirects, so we will deal with them ourselves
 329             httpConnection.setInstanceFollowRedirects(false);
 330         }
 331     }
 332 
 333     /**
 334      * Sends request to the server.
 335      */
 336     private void sendRequest(URLConnection c, boolean streaming)
 337         throws IOException
 338     {
 339         OutputStream out = null;
 340         try {
 341             long bytesToBeSent = 0;
 342             boolean sendFormData = formDataElements != null
 343                     &amp;&amp; c instanceof HttpURLConnection
 344                     &amp;&amp; !method.equals(DELETE);
 345             boolean isGetOrHead = method.equals(GET) || method.equals(HEAD);
 346             if (sendFormData) {
 347                 c.setDoOutput(true);
 348 
 349                 for (FormDataElement formDataElement : formDataElements) {
 350                     formDataElement.open();
 351                     bytesToBeSent += formDataElement.getSize();
 352                 }
 353 
 354                 if (streaming) {
 355                     HttpURLConnection http = (HttpURLConnection) c;
 356                     if (bytesToBeSent &lt;= Integer.MAX_VALUE) {
 357                         http.setFixedLengthStreamingMode((int) bytesToBeSent);
 358                     } else {
 359                         http.setChunkedStreamingMode(0);
 360                     }
 361                 }
 362             } else if (!isGetOrHead &amp;&amp; (c instanceof HttpURLConnection)) {
 363                 c.setRequestProperty(&quot;Content-Length&quot;, &quot;0&quot;);
 364             }
 365 
 366             int maxTryCount = isGetOrHead ? 3 : 1;
 367             c.setConnectTimeout(c.getConnectTimeout() / maxTryCount);
 368             int tryCount = 0;
 369             while (!canceled) {
 370                 try {
 371                     c.connect();
 372                     break;
 373                 } catch (SocketTimeoutException ex) {
 374                     if (++tryCount &gt;= maxTryCount) {
 375                         throw ex;
 376                     }
 377                 } catch (IllegalArgumentException ex) {
 378                     // Happens with some malformed URLs
 379                     throw new MalformedURLException(url);
 380                 }
 381             }
 382 
 383             if (sendFormData) {
 384                 out = c.getOutputStream();
 385                 byte[] buffer = new byte[4096];
 386                 long bytesSent = 0;
 387                 for (FormDataElement formDataElement : formDataElements) {
 388                     InputStream in = formDataElement.getInputStream();
 389                     int count;
 390                     while ((count = in.read(buffer)) &gt; 0) {
 391                         out.write(buffer, 0, count);
 392                         bytesSent += count;
 393                         didSendData(bytesSent, bytesToBeSent);
 394                     }
 395                     formDataElement.close();
 396                 }
 397                 out.flush();
 398                 out.close();
 399                 out = null;
 400             }
 401         } finally {
 402             if (out != null) {
 403                 try {
 404                     out.close();
 405                 } catch (IOException ignore) {}
 406             }
 407             if (formDataElements != null &amp;&amp; c instanceof HttpURLConnection) {
 408                 for (FormDataElement formDataElement : formDataElements) {
 409                     try {
 410                         formDataElement.close();
 411                     } catch (IOException ignore) {}
 412                 }
 413             }
 414         }
 415     }
 416 
 417     /**
 418      * Receives response from the server.
 419      */
<a name="10" id="anc10"></a><span class="line-modified"> 420     private Redirect receiveResponse(URLConnection c)</span>
 421         throws IOException, InterruptedException
 422     {
 423         if (canceled) {
<a name="11" id="anc11"></a><span class="line-modified"> 424             return null;</span>
 425         }
 426 
 427         InputStream errorStream = null;
 428 
 429         if (c instanceof HttpURLConnection) {
 430             HttpURLConnection http = (HttpURLConnection) c;
 431 
 432             int code = http.getResponseCode();
 433             if (code == -1) {
 434                 throw new InvalidResponseException();
 435             }
 436 
 437             if (canceled) {
<a name="12" id="anc12"></a><span class="line-modified"> 438                 return null;</span>
 439             }
 440 
 441             // See RT-17435
 442             switch (code) {
 443                 case 301: // Moved Permanently
 444                 case 302: // Found
 445                 case 303: // See Other
 446                 case 307: // Temporary Redirect
<a name="13" id="anc13"></a><span class="line-modified"> 447                     String newLoc = http.getHeaderField(&quot;Location&quot;);</span>
<span class="line-removed"> 448                     if (newLoc != null) {</span>
<span class="line-removed"> 449                         URL newUrl;</span>
<span class="line-removed"> 450                         try {</span>
<span class="line-removed"> 451                             newUrl = newURL(newLoc);</span>
<span class="line-removed"> 452                         } catch (MalformedURLException mue) {</span>
<span class="line-removed"> 453                             // Try to treat newLoc as a relative URI to conform</span>
<span class="line-removed"> 454                             // to popular browsers</span>
<span class="line-removed"> 455                             newUrl = newURL(c.getURL(), newLoc);</span>
<span class="line-removed"> 456                         }</span>
<span class="line-removed"> 457                         return new Redirect(newUrl.toExternalForm(),</span>
<span class="line-removed"> 458                                             code == 307);</span>
<span class="line-removed"> 459                     }</span>
 460                     break;
 461 
 462                 case 304: // Not Modified
 463                     didReceiveResponse(c);
 464                     didFinishLoading();
<a name="14" id="anc14"></a><span class="line-modified"> 465                     return null;</span>
 466             }
 467 
 468             if (code &gt;= 400 &amp;&amp; !method.equals(HEAD)) {
 469                 errorStream = http.getErrorStream();
 470             }
 471         }
 472 
 473         // Let&#39;s see if it&#39;s an ftp (or ftps) URL and we need to transform
 474         // a directory listing into HTML
 475         if (url.startsWith(&quot;ftp:&quot;) || url.startsWith(&quot;ftps:&quot;)) {
 476             boolean dir = false;
 477             boolean notsure = false;
 478             // Unfortunately, there is no clear way to determine if we are
 479             // accessing a directory, so a bit of guessing is in order
 480             String path = c.getURL().getPath();
 481             if (path == null || path.isEmpty() || path.endsWith(&quot;/&quot;)
 482                     || path.contains(&quot;;type=d&quot;))
 483             {
 484                 dir = true;
 485             } else {
 486                 String type = c.getContentType();
 487                 if (&quot;text/plain&quot;.equalsIgnoreCase(type)
 488                         || &quot;text/html&quot;.equalsIgnoreCase(type))
 489                 {
 490                     dir = true;
 491                     notsure = true;
 492                 }
 493             }
 494             if (dir) {
 495                 c = new DirectoryURLConnection(c, notsure);
 496             }
 497         }
 498 
 499         // Same is true for FileURLConnection
 500         if (url.startsWith(&quot;file:&quot;)) {
 501             if(&quot;text/plain&quot;.equals(c.getContentType())
 502                     &amp;&amp; c.getHeaderField(&quot;content-length&quot;) == null)
 503             {
 504                 // It is a directory
 505                 c = new DirectoryURLConnection(c);
 506             }
 507         }
 508 
 509         didReceiveResponse(c);
 510 
 511         if (method.equals(HEAD)) {
 512             didFinishLoading();
<a name="15" id="anc15"></a><span class="line-modified"> 513             return null;</span>
 514         }
 515 
 516         InputStream inputStream = null;
 517         try {
 518             inputStream = errorStream == null
 519                 ? c.getInputStream() : errorStream;
 520         } catch (HttpRetryException ex) {
 521             // HttpRetryException is handled from doRun() method.
 522             // Hence rethrowing the exception to caller(doRun() method)
 523             throw ex;
 524         } catch (IOException e) {
 525             if (logger.isLoggable(Level.FINE)) {
 526                 logger.fine(String.format(&quot;Exception caught: [%s], %s&quot;,
 527                     e.getClass().getSimpleName(),
 528                     e.getMessage()));
 529             }
 530         }
 531 
 532         String encoding = c.getContentEncoding();
 533         if (inputStream != null) {
 534             try {
 535                 if (&quot;gzip&quot;.equalsIgnoreCase(encoding)) {
 536                     inputStream = new GZIPInputStream(inputStream);
 537                 } else if (&quot;deflate&quot;.equalsIgnoreCase(encoding)) {
 538                     inputStream = new InflaterInputStream(inputStream);
 539                 }
 540             } catch (IOException e) {
 541                 if (logger.isLoggable(Level.FINE)) {
 542                     logger.fine(String.format(&quot;Exception caught: [%s], %s&quot;,
 543                         e.getClass().getSimpleName(),
 544                         e.getMessage()));
 545                 }
 546             }
 547         }
 548 
 549         ByteBufferAllocator allocator =
 550                 byteBufferPool.newAllocator(MAX_BUF_COUNT);
 551         ByteBuffer byteBuffer = null;
 552         try {
 553             if (inputStream != null) {
 554                 // 8192 is the default size of a BufferedInputStream used in
 555                 // most URLConnections, by using the same size, we avoid quite
 556                 // a few System.arrayCopy() calls
 557                 byte[] buffer = new byte[8192];
 558                 while (!canceled) {
 559                     int count;
 560                     try {
 561                         count = inputStream.read(buffer);
 562                     } catch (EOFException ex) {
 563                         // can be thrown by GZIPInputStream signaling
 564                         // the end of the stream
 565                         count = -1;
 566                     }
 567 
 568                     if (count == -1) {
 569                         break;
 570                     }
 571 
 572                     if (byteBuffer == null) {
 573                         byteBuffer = allocator.allocate();
 574                     }
 575 
 576                     int remaining = byteBuffer.remaining();
 577                     if (count &lt; remaining) {
 578                         byteBuffer.put(buffer, 0, count);
 579                     } else {
 580                         byteBuffer.put(buffer, 0, remaining);
 581 
 582                         byteBuffer.flip();
 583                         didReceiveData(byteBuffer, allocator);
 584                         byteBuffer = null;
 585 
 586                         int outstanding = count - remaining;
 587                         if (outstanding &gt; 0) {
 588                             byteBuffer = allocator.allocate();
 589                             byteBuffer.put(buffer, remaining, outstanding);
 590                         }
 591                     }
 592                 }
 593             }
 594             if (!canceled) {
 595                 if (byteBuffer != null &amp;&amp; byteBuffer.position() &gt; 0) {
 596                     byteBuffer.flip();
 597                     didReceiveData(byteBuffer, allocator);
 598                     byteBuffer = null;
 599                 }
 600                 didFinishLoading();
 601             }
 602         } finally {
 603             if (byteBuffer != null) {
<a name="16" id="anc16"></a><span class="line-removed"> 604                 byteBuffer.clear();</span>
 605                 allocator.release(byteBuffer);
 606             }
 607         }
<a name="17" id="anc17"></a><span class="line-removed"> 608         return null;</span>
 609     }
 610 
 611     /**
 612      * Releases the resources that may be associated with a connection.
 613      */
 614     private static void close(URLConnection c) {
 615         if (c instanceof HttpURLConnection) {
 616             InputStream errorStream = ((HttpURLConnection) c).getErrorStream();
 617             if (errorStream != null) {
 618                 try {
 619                     errorStream.close();
 620                 } catch (IOException ignore) {}
 621             }
 622         }
 623         try {
 624             c.getInputStream().close();
 625         } catch (IOException ignore) {}
 626     }
 627 
<a name="18" id="anc18"></a><span class="line-removed"> 628 </span>
<span class="line-removed"> 629     /**</span>
<span class="line-removed"> 630      * A holder for redirect information.</span>
<span class="line-removed"> 631      */</span>
<span class="line-removed"> 632     private static final class Redirect {</span>
<span class="line-removed"> 633         private final String url;</span>
<span class="line-removed"> 634         private final boolean preserveRequest;</span>
<span class="line-removed"> 635 </span>
<span class="line-removed"> 636         private Redirect(String url, boolean preserveRequest) {</span>
<span class="line-removed"> 637             this.url = url;</span>
<span class="line-removed"> 638             this.preserveRequest = preserveRequest;</span>
<span class="line-removed"> 639         }</span>
<span class="line-removed"> 640     }</span>
<span class="line-removed"> 641 </span>
 642     /**
 643      * Signals an invalid response from the server.
 644      */
 645     private static final class InvalidResponseException extends IOException {
 646         private InvalidResponseException() {
 647             super(&quot;Invalid server response&quot;);
 648         }
 649     }
 650 
<a name="19" id="anc19"></a><span class="line-removed"> 651     /**</span>
<span class="line-removed"> 652      * Signals that too many redirects have been encountered</span>
<span class="line-removed"> 653      * while processing the request.</span>
<span class="line-removed"> 654      */</span>
<span class="line-removed"> 655     private static final class TooManyRedirectsException extends IOException {</span>
<span class="line-removed"> 656         private TooManyRedirectsException() {</span>
<span class="line-removed"> 657             super(&quot;Too many redirects&quot;);</span>
<span class="line-removed"> 658         }</span>
<span class="line-removed"> 659     }</span>
<span class="line-removed"> 660 </span>
 661     private void didSendData(final long totalBytesSent,
 662                              final long totalBytesToBeSent)
 663     {
 664         callBack(() -&gt; {
 665             if (!canceled) {
 666                 notifyDidSendData(totalBytesSent, totalBytesToBeSent);
 667             }
 668         });
 669     }
 670 
 671     private void notifyDidSendData(long totalBytesSent,
 672                                    long totalBytesToBeSent)
 673     {
 674         if (logger.isLoggable(Level.FINEST)) {
 675             logger.finest(String.format(
 676                     &quot;totalBytesSent: [%d], &quot;
 677                     + &quot;totalBytesToBeSent: [%d], &quot;
 678                     + &quot;data: [0x%016X]&quot;,
 679                     totalBytesSent,
 680                     totalBytesToBeSent,
 681                     data));
 682         }
 683         twkDidSendData(totalBytesSent, totalBytesToBeSent, data);
 684     }
 685 
<a name="20" id="anc20"></a><span class="line-modified"> 686     private void willSendRequest(String newUrl,</span>
<span class="line-removed"> 687                                  final String newMethod,</span>
<span class="line-removed"> 688                                  URLConnection c) throws InterruptedException</span>
 689     {
<a name="21" id="anc21"></a><span class="line-removed"> 690         final String adjustedNewUrl = adjustUrlForWebKit(newUrl);</span>
 691         final int status = extractStatus(c);
 692         final String contentType = c.getContentType();
 693         final String contentEncoding = extractContentEncoding(c);
 694         final long contentLength = extractContentLength(c);
 695         final String responseHeaders = extractHeaders(c);
 696         final String adjustedUrl = adjustUrlForWebKit(url);
<a name="22" id="anc22"></a><span class="line-removed"> 697         final CountDownLatch latch =</span>
<span class="line-removed"> 698                 asynchronous ? new CountDownLatch(1) : null;</span>
 699         callBack(() -&gt; {
<a name="23" id="anc23"></a><span class="line-modified"> 700             try {</span>
<span class="line-modified"> 701                 if (!canceled) {</span>
<span class="line-modified"> 702                     boolean keepGoing = notifyWillSendRequest(</span>
<span class="line-modified"> 703                             adjustedNewUrl,</span>
<span class="line-modified"> 704                             newMethod,</span>
<span class="line-modified"> 705                             status,</span>
<span class="line-modified"> 706                             contentType,</span>
<span class="line-modified"> 707                             contentEncoding,</span>
<span class="line-removed"> 708                             contentLength,</span>
<span class="line-removed"> 709                             responseHeaders,</span>
<span class="line-removed"> 710                             adjustedUrl);</span>
<span class="line-removed"> 711                     if (!keepGoing) {</span>
<span class="line-removed"> 712                         fwkCancel();</span>
<span class="line-removed"> 713                     }</span>
<span class="line-removed"> 714                 }</span>
<span class="line-removed"> 715             } finally {</span>
<span class="line-removed"> 716                 if (latch != null) {</span>
<span class="line-removed"> 717                     latch.countDown();</span>
<span class="line-removed"> 718                 }</span>
 719             }
 720         });
<a name="24" id="anc24"></a><span class="line-removed"> 721         if (latch != null) {</span>
<span class="line-removed"> 722             latch.await();</span>
<span class="line-removed"> 723         }</span>
 724     }
 725 
<a name="25" id="anc25"></a><span class="line-modified"> 726     private boolean notifyWillSendRequest(String newUrl,</span>
<span class="line-removed"> 727                                           String newMethod,</span>
<span class="line-removed"> 728                                           int status,</span>
 729                                           String contentType,
 730                                           String contentEncoding,
 731                                           long contentLength,
 732                                           String headers,
 733                                           String url)
 734     {
 735         if (logger.isLoggable(Level.FINEST)) {
 736             logger.finest(String.format(
<a name="26" id="anc26"></a><span class="line-modified"> 737                     &quot;newUrl: [%s], &quot;</span>
<span class="line-removed"> 738                     + &quot;newMethod: [%s], &quot;</span>
<span class="line-removed"> 739                     + &quot;status: [%d], &quot;</span>
 740                     + &quot;contentType: [%s], &quot;
 741                     + &quot;contentEncoding: [%s], &quot;
 742                     + &quot;contentLength: [%d], &quot;
 743                     + &quot;url: [%s], &quot;
 744                     + &quot;data: [0x%016X], &quot;
 745                     + &quot;headers:%n%s&quot;,
<a name="27" id="anc27"></a><span class="line-removed"> 746                     newUrl,</span>
<span class="line-removed"> 747                     newMethod,</span>
 748                     status,
 749                     contentType,
 750                     contentEncoding,
 751                     contentLength,
 752                     url,
 753                     data,
 754                     Util.formatHeaders(headers)));
 755         }
<a name="28" id="anc28"></a><span class="line-modified"> 756         boolean result = twkWillSendRequest(</span>
<span class="line-removed"> 757                 newUrl,</span>
<span class="line-removed"> 758                 newMethod,</span>
 759                 status,
 760                 contentType,
 761                 contentEncoding,
 762                 contentLength,
 763                 headers,
 764                 url,
 765                 data);
<a name="29" id="anc29"></a><span class="line-removed"> 766         if (logger.isLoggable(Level.FINEST)) {</span>
<span class="line-removed"> 767             logger.finest(String.format(&quot;result: [%s]&quot;, result));</span>
<span class="line-removed"> 768         }</span>
<span class="line-removed"> 769         return result;</span>
 770     }
 771 
 772     private void didReceiveResponse(URLConnection c) {
 773         final int status = extractStatus(c);
 774         final String contentType = c.getContentType();
 775         final String contentEncoding = extractContentEncoding(c);
 776         final long contentLength = extractContentLength(c);
 777         final String responseHeaders = extractHeaders(c);
 778         final String adjustedUrl = adjustUrlForWebKit(url);
 779         callBack(() -&gt; {
 780             if (!canceled) {
 781                 notifyDidReceiveResponse(
 782                         status,
 783                         contentType,
 784                         contentEncoding,
 785                         contentLength,
 786                         responseHeaders,
 787                         adjustedUrl);
 788             }
 789         });
 790     }
 791 
 792     private void notifyDidReceiveResponse(int status,
 793                                           String contentType,
 794                                           String contentEncoding,
 795                                           long contentLength,
 796                                           String headers,
 797                                           String url)
 798     {
 799         if (logger.isLoggable(Level.FINEST)) {
 800             logger.finest(String.format(
 801                     &quot;status: [%d], &quot;
 802                     + &quot;contentType: [%s], &quot;
 803                     + &quot;contentEncoding: [%s], &quot;
 804                     + &quot;contentLength: [%d], &quot;
 805                     + &quot;url: [%s], &quot;
 806                     + &quot;data: [0x%016X], &quot;
 807                     + &quot;headers:%n%s&quot;,
 808                     status,
 809                     contentType,
 810                     contentEncoding,
 811                     contentLength,
 812                     url,
 813                     data,
 814                     Util.formatHeaders(headers)));
 815         }
 816         twkDidReceiveResponse(
 817                 status,
 818                 contentType,
 819                 contentEncoding,
 820                 contentLength,
 821                 headers,
 822                 url,
 823                 data);
 824     }
 825 
 826     private void didReceiveData(final ByteBuffer byteBuffer,
 827                                 final ByteBufferAllocator allocator)
 828     {
 829         callBack(() -&gt; {
 830             if (!canceled) {
 831                 notifyDidReceiveData(
 832                         byteBuffer,
 833                         byteBuffer.position(),
 834                         byteBuffer.remaining());
 835             }
<a name="30" id="anc30"></a><span class="line-removed"> 836             byteBuffer.clear();</span>
 837             allocator.release(byteBuffer);
 838         });
 839     }
 840 
 841     private void notifyDidReceiveData(ByteBuffer byteBuffer,
 842                                       int position,
 843                                       int remaining)
 844     {
 845         if (logger.isLoggable(Level.FINEST)) {
 846             logger.finest(String.format(
 847                     &quot;byteBuffer: [%s], &quot;
 848                     + &quot;position: [%s], &quot;
 849                     + &quot;remaining: [%s], &quot;
 850                     + &quot;data: [0x%016X]&quot;,
 851                     byteBuffer,
 852                     position,
 853                     remaining,
 854                     data));
 855         }
 856         twkDidReceiveData(byteBuffer, position, remaining, data);
 857     }
 858 
 859     private void didFinishLoading() {
 860         callBack(() -&gt; {
 861             if (!canceled) {
 862                 notifyDidFinishLoading();
 863             }
 864         });
 865     }
 866 
 867     private void notifyDidFinishLoading() {
 868         if (logger.isLoggable(Level.FINEST)) {
 869             logger.finest(String.format(&quot;data: [0x%016X]&quot;, data));
 870         }
 871         twkDidFinishLoading(data);
 872     }
 873 
 874     private void didFail(final int errorCode, final String message) {
 875         final String adjustedUrl = adjustUrlForWebKit(url);
 876         callBack(() -&gt; {
 877             if (!canceled) {
 878                 notifyDidFail(errorCode, adjustedUrl, message);
 879             }
 880         });
 881     }
 882 
 883     private void notifyDidFail(int errorCode, String url, String message) {
 884         if (logger.isLoggable(Level.FINEST)) {
 885             logger.finest(String.format(
 886                     &quot;errorCode: [%d], &quot;
 887                     + &quot;url: [%s], &quot;
 888                     + &quot;message: [%s], &quot;
 889                     + &quot;data: [0x%016X]&quot;,
 890                     errorCode,
 891                     url,
 892                     message,
 893                     data));
 894         }
 895         twkDidFail(errorCode, url, message, data);
 896     }
 897 
 898     private void callBack(Runnable runnable) {
 899         if (asynchronous) {
 900             Invoker.getInvoker().invokeOnEventThread(runnable);
 901         } else {
 902             runnable.run();
 903         }
 904     }
 905 
<a name="31" id="anc31"></a><span class="line-removed"> 906     private static native void twkDidSendData(long totalBytesSent,</span>
<span class="line-removed"> 907                                               long totalBytesToBeSent,</span>
<span class="line-removed"> 908                                               long data);</span>
<span class="line-removed"> 909 </span>
<span class="line-removed"> 910     private static native boolean twkWillSendRequest(String newUrl,</span>
<span class="line-removed"> 911                                                      String newMethod,</span>
<span class="line-removed"> 912                                                      int status,</span>
<span class="line-removed"> 913                                                      String contentType,</span>
<span class="line-removed"> 914                                                      String contentEncoding,</span>
<span class="line-removed"> 915                                                      long contentLength,</span>
<span class="line-removed"> 916                                                      String headers,</span>
<span class="line-removed"> 917                                                      String url,</span>
<span class="line-removed"> 918                                                      long data);</span>
<span class="line-removed"> 919 </span>
<span class="line-removed"> 920     private static native void twkDidReceiveResponse(int status,</span>
<span class="line-removed"> 921                                                      String contentType,</span>
<span class="line-removed"> 922                                                      String contentEncoding,</span>
<span class="line-removed"> 923                                                      long contentLength,</span>
<span class="line-removed"> 924                                                      String headers,</span>
<span class="line-removed"> 925                                                      String url,</span>
<span class="line-removed"> 926                                                      long data);</span>
<span class="line-removed"> 927 </span>
<span class="line-removed"> 928     private static native void twkDidReceiveData(ByteBuffer byteBuffer,</span>
<span class="line-removed"> 929                                                  int position,</span>
<span class="line-removed"> 930                                                  int remaining,</span>
<span class="line-removed"> 931                                                  long data);</span>
<span class="line-removed"> 932 </span>
<span class="line-removed"> 933     private static native void twkDidFinishLoading(long data);</span>
<span class="line-removed"> 934 </span>
<span class="line-removed"> 935     private static native void twkDidFail(int errorCode,</span>
<span class="line-removed"> 936                                           String url,</span>
<span class="line-removed"> 937                                           String message,</span>
<span class="line-removed"> 938                                           long data);</span>
<span class="line-removed"> 939 </span>
 940     /**
 941      * Given a {@link URLConnection}, returns the connection status
 942      * for passing into native callbacks.
 943      */
 944     private static int extractStatus(URLConnection c) {
 945         int status = 0;
 946         if (c instanceof HttpURLConnection) {
 947             try {
 948                 status = ((HttpURLConnection) c).getResponseCode();
 949             } catch (java.io.IOException ignore) {}
 950         }
 951         return status;
 952     }
 953 
 954     /**
 955      * Given a {@link URLConnection}, returns the content encoding
 956      * for passing into native callbacks.
 957      */
 958     private static String extractContentEncoding(URLConnection c) {
 959         String contentEncoding = c.getContentEncoding();
 960         // For compressed streams, the encoding is in Content-Type
 961         if (&quot;gzip&quot;.equalsIgnoreCase(contentEncoding) ||
 962             &quot;deflate&quot;.equalsIgnoreCase(contentEncoding))
 963         {
 964             contentEncoding = null;
 965             String contentType  = c.getContentType();
 966             if (contentType != null) {
 967                 int i = contentType.indexOf(&quot;charset=&quot;);
 968                 if (i &gt;= 0) {
 969                     contentEncoding = contentType.substring(i + 8);
 970                     i = contentEncoding.indexOf(&quot;;&quot;);
 971                     if (i &gt; 0) {
 972                         contentEncoding = contentEncoding.substring(0, i);
 973                     }
 974                 }
 975             }
 976         }
 977         return contentEncoding;
 978     }
 979 
 980     /**
 981      * Given a {@link URLConnection}, returns the content length
 982      * for passing into native callbacks.
 983      */
 984     private static long extractContentLength(URLConnection c) {
 985         // Cannot use URLConnection.getContentLength()
 986         // as it only returns an int
 987         try {
 988             return Long.parseLong(c.getHeaderField(&quot;content-length&quot;));
 989         } catch (Exception ex) {
 990             return -1;
 991         }
 992     }
 993 
 994     /**
 995      * Given a {@link URLConnection}, returns the headers string
 996      * for passing into native callbacks.
 997      */
 998     private static String extractHeaders(URLConnection c) {
 999         StringBuilder sb = new StringBuilder();
1000         Map&lt;String, List&lt;String&gt;&gt; headers = c.getHeaderFields();
1001         for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry: headers.entrySet()) {
1002             String key = entry.getKey();
1003             List&lt;String&gt; values = entry.getValue();
1004             for (String value : values) {
1005                 sb.append(key != null ? key : &quot;&quot;);
1006                 sb.append(&#39;:&#39;).append(value).append(&#39;\n&#39;);
1007             }
1008         }
1009         return sb.toString();
1010     }
1011 
1012     /**
1013      * Adjust a URL string for passing into WebKit.
1014      */
1015     private static String adjustUrlForWebKit(String url) {
1016         try {
1017             url = Util.adjustUrlForWebKit(url);
1018         } catch (Exception ignore) {
1019         }
1020         return url;
1021     }
1022 }
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>