<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rbnf.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="quantityformatter.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbt.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rbnf.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 678,20 ***</span>
  // ----------
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
                                               const UnicodeString&amp; locs,
                                               const Locale&amp; alocale, UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified">!   : ruleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(alocale)
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
<span class="line-new-header">--- 678,20 ---</span>
  // ----------
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
                                               const UnicodeString&amp; locs,
                                               const Locale&amp; alocale, UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified">!   : fRuleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(alocale)
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 703,20 ***</span>
  }
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
                                               const UnicodeString&amp; locs,
                                               UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified">!   : ruleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(Locale::getDefault())
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
<span class="line-new-header">--- 703,20 ---</span>
  }
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
                                               const UnicodeString&amp; locs,
                                               UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified">!   : fRuleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(Locale::getDefault())
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 728,20 ***</span>
  }
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
                                               LocalizationInfo* info,
                                               const Locale&amp; alocale, UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified">!   : ruleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(alocale)
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
<span class="line-new-header">--- 728,20 ---</span>
  }
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
                                               LocalizationInfo* info,
                                               const Locale&amp; alocale, UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified">!   : fRuleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(alocale)
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 752,20 ***</span>
  }
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
                           UParseError&amp; perror,
                           UErrorCode&amp; status)
<span class="line-modified">!   : ruleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(Locale::getDefault())
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
<span class="line-new-header">--- 752,20 ---</span>
  }
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
                           UParseError&amp; perror,
                           UErrorCode&amp; status)
<span class="line-modified">!   : fRuleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(Locale::getDefault())
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 777,20 ***</span>
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
                           const Locale&amp; aLocale,
                           UParseError&amp; perror,
                           UErrorCode&amp; status)
<span class="line-modified">!   : ruleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(aLocale)
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
<span class="line-new-header">--- 777,20 ---</span>
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
                           const Locale&amp; aLocale,
                           UParseError&amp; perror,
                           UErrorCode&amp; status)
<span class="line-modified">!   : fRuleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(aLocale)
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 799,20 ***</span>
  {
      init(description, NULL, perror, status);
  }
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(URBNFRuleSetTag tag, const Locale&amp; alocale, UErrorCode&amp; status)
<span class="line-modified">!   : ruleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(alocale)
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
<span class="line-new-header">--- 799,20 ---</span>
  {
      init(description, NULL, perror, status);
  }
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(URBNFRuleSetTag tag, const Locale&amp; alocale, UErrorCode&amp; status)
<span class="line-modified">!   : fRuleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(alocale)
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 866,20 ***</span>
      ures_close(nfrb);
  }
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const RuleBasedNumberFormat&amp; rhs)
    : NumberFormat(rhs)
<span class="line-modified">!   , ruleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(rhs.locale)
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
<span class="line-new-header">--- 866,20 ---</span>
      ures_close(nfrb);
  }
  
  RuleBasedNumberFormat::RuleBasedNumberFormat(const RuleBasedNumberFormat&amp; rhs)
    : NumberFormat(rhs)
<span class="line-modified">!   , fRuleSets(NULL)</span>
    , ruleSetDescriptions(NULL)
    , numRuleSets(0)
    , defaultRuleSet(NULL)
    , locale(rhs.locale)
    , collator(NULL)
    , decimalFormatSymbols(NULL)
    , defaultInfinityRule(NULL)
    , defaultNaNRule(NULL)
<span class="line-modified">!   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
    , lenient(FALSE)
    , lenientParseRules(NULL)
    , localizations(NULL)
    , capitalizationInfoSet(FALSE)
    , capitalizationForUIListMenu(FALSE)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 948,12 ***</span>
                  ? rhs.localizations == NULL
                  : (rhs.localizations == NULL
                      ? FALSE
                      : *localizations == rhs.localizations))) {
  
<span class="line-modified">!             NFRuleSet** p = ruleSets;</span>
<span class="line-modified">!             NFRuleSet** q = rhs.ruleSets;</span>
              if (p == NULL) {
                  return q == NULL;
              } else if (q == NULL) {
                  return FALSE;
              }
<span class="line-new-header">--- 948,12 ---</span>
                  ? rhs.localizations == NULL
                  : (rhs.localizations == NULL
                      ? FALSE
                      : *localizations == rhs.localizations))) {
  
<span class="line-modified">!             NFRuleSet** p = fRuleSets;</span>
<span class="line-modified">!             NFRuleSet** q = rhs.fRuleSets;</span>
              if (p == NULL) {
                  return q == NULL;
              } else if (q == NULL) {
                  return FALSE;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 970,12 ***</span>
  
  UnicodeString
  RuleBasedNumberFormat::getRules() const
  {
      UnicodeString result;
<span class="line-modified">!     if (ruleSets != NULL) {</span>
<span class="line-modified">!         for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
              (*p)-&gt;appendRules(result);
          }
      }
      return result;
  }
<span class="line-new-header">--- 970,12 ---</span>
  
  UnicodeString
  RuleBasedNumberFormat::getRules() const
  {
      UnicodeString result;
<span class="line-modified">!     if (fRuleSets != NULL) {</span>
<span class="line-modified">!         for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
              (*p)-&gt;appendRules(result);
          }
      }
      return result;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 985,13 ***</span>
  {
      if (localizations) {
          UnicodeString string(TRUE, localizations-&gt;getRuleSetName(index), (int32_t)-1);
          return string;
      }
<span class="line-modified">!     else if (ruleSets) {</span>
          UnicodeString result;
<span class="line-modified">!         for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
              NFRuleSet* rs = *p;
              if (rs-&gt;isPublic()) {
                  if (--index == -1) {
                      rs-&gt;getName(result);
                      return result;
<span class="line-new-header">--- 985,13 ---</span>
  {
      if (localizations) {
          UnicodeString string(TRUE, localizations-&gt;getRuleSetName(index), (int32_t)-1);
          return string;
      }
<span class="line-modified">!     else if (fRuleSets) {</span>
          UnicodeString result;
<span class="line-modified">!         for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
              NFRuleSet* rs = *p;
              if (rs-&gt;isPublic()) {
                  if (--index == -1) {
                      rs-&gt;getName(result);
                      return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1008,12 ***</span>
  {
      int32_t result = 0;
      if (localizations) {
          result = localizations-&gt;getNumberOfRuleSets();
      }
<span class="line-modified">!     else if (ruleSets) {</span>
<span class="line-modified">!         for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
              if ((**p).isPublic()) {
                  ++result;
              }
          }
      }
<span class="line-new-header">--- 1008,12 ---</span>
  {
      int32_t result = 0;
      if (localizations) {
          result = localizations-&gt;getNumberOfRuleSets();
      }
<span class="line-modified">!     else if (fRuleSets) {</span>
<span class="line-modified">!         for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
              if ((**p).isPublic()) {
                  ++result;
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1096,12 ***</span>
  }
  
  NFRuleSet*
  RuleBasedNumberFormat::findRuleSet(const UnicodeString&amp; name, UErrorCode&amp; status) const
  {
<span class="line-modified">!     if (U_SUCCESS(status) &amp;&amp; ruleSets) {</span>
<span class="line-modified">!         for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
              NFRuleSet* rs = *p;
              if (rs-&gt;isNamed(name)) {
                  return rs;
              }
          }
<span class="line-new-header">--- 1096,12 ---</span>
  }
  
  NFRuleSet*
  RuleBasedNumberFormat::findRuleSet(const UnicodeString&amp; name, UErrorCode&amp; status) const
  {
<span class="line-modified">!     if (U_SUCCESS(status) &amp;&amp; fRuleSets) {</span>
<span class="line-modified">!         for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
              NFRuleSet* rs = *p;
              if (rs-&gt;isNamed(name)) {
                  return rs;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1130,15 ***</span>
          else {
              // We&#39;re outside of our normal range that this framework can handle.
              // The DecimalFormat will provide more accurate results.
  
              // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
<span class="line-modified">!             NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);</span>
              Formattable f;
<span class="line-modified">!             f.adoptDecimalQuantity(new DecimalQuantity(number));</span>
              decimalFormat-&gt;format(f, appendTo, posIter, status);
<span class="line-removed">-             delete decimalFormat;</span>
          }
      }
      return appendTo;
  }
  
<span class="line-new-header">--- 1130,21 ---</span>
          else {
              // We&#39;re outside of our normal range that this framework can handle.
              // The DecimalFormat will provide more accurate results.
  
              // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
<span class="line-modified">!             LocalPointer&lt;NumberFormat&gt; decimalFormat(NumberFormat::createInstance(locale, UNUM_DECIMAL, status), status);</span>
<span class="line-added">+             if (decimalFormat.isNull()) {</span>
<span class="line-added">+                 return appendTo;</span>
<span class="line-added">+             }</span>
              Formattable f;
<span class="line-modified">!             LocalPointer&lt;DecimalQuantity&gt; decimalQuantity(new DecimalQuantity(number), status);</span>
<span class="line-added">+             if (decimalQuantity.isNull()) {</span>
<span class="line-added">+                 return appendTo;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             f.adoptDecimalQuantity(decimalQuantity.orphan()); // f now owns decimalQuantity.</span>
              decimalFormat-&gt;format(f, appendTo, posIter, status);
          }
      }
      return appendTo;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1163,15 ***</span>
          else {
              // We&#39;re outside of our normal range that this framework can handle.
              // The DecimalFormat will provide more accurate results.
  
              // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
<span class="line-modified">!             NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);</span>
              Formattable f;
<span class="line-modified">!             f.adoptDecimalQuantity(new DecimalQuantity(number));</span>
              decimalFormat-&gt;format(f, appendTo, pos, status);
<span class="line-removed">-             delete decimalFormat;</span>
          }
      }
      return appendTo;
  }
  
<span class="line-new-header">--- 1169,21 ---</span>
          else {
              // We&#39;re outside of our normal range that this framework can handle.
              // The DecimalFormat will provide more accurate results.
  
              // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
<span class="line-modified">!             LocalPointer&lt;NumberFormat&gt; decimalFormat(NumberFormat::createInstance(locale, UNUM_DECIMAL, status), status);</span>
<span class="line-added">+             if (decimalFormat.isNull()) {</span>
<span class="line-added">+                 return appendTo;</span>
<span class="line-added">+             }</span>
              Formattable f;
<span class="line-modified">!             LocalPointer&lt;DecimalQuantity&gt; decimalQuantity(new DecimalQuantity(number), status);</span>
<span class="line-added">+             if (decimalQuantity.isNull()) {</span>
<span class="line-added">+                 return appendTo;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             f.adoptDecimalQuantity(decimalQuantity.orphan()); // f now owns decimalQuantity.</span>
              decimalFormat-&gt;format(f, appendTo, pos, status);
          }
      }
      return appendTo;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1310,15 ***</span>
          if (number == U_INT64_MIN) {
              // We can&#39;t handle this value right now. Provide an accurate default value.
  
              // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
              NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);
              Formattable f;
              FieldPosition pos(FieldPosition::DONT_CARE);
<span class="line-modified">!             DecimalQuantity *digitList = new DecimalQuantity();</span>
<span class="line-modified">!             digitList-&gt;setToLong(number);</span>
<span class="line-modified">!             f.adoptDecimalQuantity(digitList);</span>
              decimalFormat-&gt;format(f, toAppendTo, pos, status);
              delete decimalFormat;
          }
          else {
              int32_t startPos = toAppendTo.length();
<span class="line-new-header">--- 1322,23 ---</span>
          if (number == U_INT64_MIN) {
              // We can&#39;t handle this value right now. Provide an accurate default value.
  
              // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
              NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);
<span class="line-added">+             if (decimalFormat == nullptr) {</span>
<span class="line-added">+                 return toAppendTo;</span>
<span class="line-added">+             }</span>
              Formattable f;
              FieldPosition pos(FieldPosition::DONT_CARE);
<span class="line-modified">!             DecimalQuantity *decimalQuantity = new DecimalQuantity();</span>
<span class="line-modified">!             if (decimalQuantity == nullptr) {</span>
<span class="line-modified">!                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+                 delete decimalFormat;</span>
<span class="line-added">+                 return toAppendTo;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             decimalQuantity-&gt;setToLong(number);</span>
<span class="line-added">+             f.adoptDecimalQuantity(decimalQuantity); // f now owns decimalQuantity.</span>
              decimalFormat-&gt;format(f, toAppendTo, pos, status);
              delete decimalFormat;
          }
          else {
              int32_t startPos = toAppendTo.length();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1356,22 ***</span>
  void
  RuleBasedNumberFormat::parse(const UnicodeString&amp; text,
                               Formattable&amp; result,
                               ParsePosition&amp; parsePosition) const
  {
<span class="line-modified">!     if (!ruleSets) {</span>
          parsePosition.setErrorIndex(0);
          return;
      }
  
      UnicodeString workingText(text, parsePosition.getIndex());
      ParsePosition workingPos(0);
  
      ParsePosition high_pp(0);
      Formattable high_result;
  
<span class="line-modified">!     for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
          NFRuleSet *rp = *p;
          if (rp-&gt;isPublic() &amp;&amp; rp-&gt;isParseable()) {
              ParsePosition working_pp(0);
              Formattable working_result;
  
<span class="line-new-header">--- 1376,22 ---</span>
  void
  RuleBasedNumberFormat::parse(const UnicodeString&amp; text,
                               Formattable&amp; result,
                               ParsePosition&amp; parsePosition) const
  {
<span class="line-modified">!     if (!fRuleSets) {</span>
          parsePosition.setErrorIndex(0);
          return;
      }
  
      UnicodeString workingText(text, parsePosition.getIndex());
      ParsePosition workingPos(0);
  
      ParsePosition high_pp(0);
      Formattable high_result;
  
<span class="line-modified">!     for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
          NFRuleSet *rp = *p;
          if (rp-&gt;isPublic() &amp;&amp; rp-&gt;isParseable()) {
              ParsePosition working_pp(0);
              Formattable working_result;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1455,19 ***</span>
  
  void
  RuleBasedNumberFormat::initDefaultRuleSet()
  {
      defaultRuleSet = NULL;
<span class="line-modified">!     if (!ruleSets) {</span>
          return;
      }
  
      const UnicodeString spellout(UNICODE_STRING_SIMPLE(&quot;%spellout-numbering&quot;));
      const UnicodeString ordinal(UNICODE_STRING_SIMPLE(&quot;%digits-ordinal&quot;));
      const UnicodeString duration(UNICODE_STRING_SIMPLE(&quot;%duration&quot;));
  
<span class="line-modified">!     NFRuleSet**p = &amp;ruleSets[0];</span>
      while (*p) {
          if ((*p)-&gt;isNamed(spellout) || (*p)-&gt;isNamed(ordinal) || (*p)-&gt;isNamed(duration)) {
              defaultRuleSet = *p;
              return;
          } else {
<span class="line-new-header">--- 1475,19 ---</span>
  
  void
  RuleBasedNumberFormat::initDefaultRuleSet()
  {
      defaultRuleSet = NULL;
<span class="line-modified">!     if (!fRuleSets) {</span>
          return;
      }
  
      const UnicodeString spellout(UNICODE_STRING_SIMPLE(&quot;%spellout-numbering&quot;));
      const UnicodeString ordinal(UNICODE_STRING_SIMPLE(&quot;%digits-ordinal&quot;));
      const UnicodeString duration(UNICODE_STRING_SIMPLE(&quot;%duration&quot;));
  
<span class="line-modified">!     NFRuleSet**p = &amp;fRuleSets[0];</span>
      while (*p) {
          if ((*p)-&gt;isNamed(spellout) || (*p)-&gt;isNamed(ordinal) || (*p)-&gt;isNamed(duration)) {
              defaultRuleSet = *p;
              return;
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1475,11 ***</span>
          }
      }
  
      defaultRuleSet = *--p;
      if (!defaultRuleSet-&gt;isPublic()) {
<span class="line-modified">!         while (p != ruleSets) {</span>
              if ((*--p)-&gt;isPublic()) {
                  defaultRuleSet = *p;
                  break;
              }
          }
<span class="line-new-header">--- 1495,11 ---</span>
          }
      }
  
      defaultRuleSet = *--p;
      if (!defaultRuleSet-&gt;isPublic()) {
<span class="line-modified">!         while (p != fRuleSets) {</span>
              if ((*--p)-&gt;isPublic()) {
                  defaultRuleSet = *p;
                  break;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1545,11 ***</span>
  
              // copy out the lenient-parse rules and delete them
              // from the description
              lenientParseRules = new UnicodeString();
              /* test for NULL */
<span class="line-modified">!             if (lenientParseRules == 0) {</span>
                  status = U_MEMORY_ALLOCATION_ERROR;
                  return;
              }
              lenientParseRules-&gt;setTo(description, lpStart, lpEnd - lpStart);
  
<span class="line-new-header">--- 1565,11 ---</span>
  
              // copy out the lenient-parse rules and delete them
              // from the description
              lenientParseRules = new UnicodeString();
              /* test for NULL */
<span class="line-modified">!             if (lenientParseRules == nullptr) {</span>
                  status = U_MEMORY_ALLOCATION_ERROR;
                  return;
              }
              lenientParseRules-&gt;setTo(description, lpStart, lpEnd - lpStart);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1566,19 ***</span>
          ++p;
      }
      ++numRuleSets;
  
      // our rule list is an array of the appropriate size
<span class="line-modified">!     ruleSets = (NFRuleSet **)uprv_malloc((numRuleSets + 1) * sizeof(NFRuleSet *));</span>
      /* test for NULL */
<span class="line-modified">!     if (ruleSets == 0) {</span>
          status = U_MEMORY_ALLOCATION_ERROR;
          return;
      }
  
      for (int i = 0; i &lt;= numRuleSets; ++i) {
<span class="line-modified">!         ruleSets[i] = NULL;</span>
      }
  
      // divide up the descriptions into individual rule-set descriptions
      // and store them in a temporary array.  At each step, we also
      // new up a rule set, but all this does is initialize its name
<span class="line-new-header">--- 1586,19 ---</span>
          ++p;
      }
      ++numRuleSets;
  
      // our rule list is an array of the appropriate size
<span class="line-modified">!     fRuleSets = (NFRuleSet **)uprv_malloc((numRuleSets + 1) * sizeof(NFRuleSet *));</span>
      /* test for NULL */
<span class="line-modified">!     if (fRuleSets == 0) {</span>
          status = U_MEMORY_ALLOCATION_ERROR;
          return;
      }
  
      for (int i = 0; i &lt;= numRuleSets; ++i) {
<span class="line-modified">!         fRuleSets[i] = NULL;</span>
      }
  
      // divide up the descriptions into individual rule-set descriptions
      // and store them in a temporary array.  At each step, we also
      // new up a rule set, but all this does is initialize its name
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1590,31 ***</span>
          status = U_ILLEGAL_ARGUMENT_ERROR;
          return;
      }
  
      ruleSetDescriptions = new UnicodeString[numRuleSets];
<span class="line-modified">!     if (ruleSetDescriptions == 0) {</span>
          status = U_MEMORY_ALLOCATION_ERROR;
          return;
      }
  
      {
          int curRuleSet = 0;
          int32_t start = 0;
          for (int32_t p = description.indexOf(gSemiPercent, 2, 0); p != -1; p = description.indexOf(gSemiPercent, 2, start)) {
              ruleSetDescriptions[curRuleSet].setTo(description, start, p + 1 - start);
<span class="line-modified">!             ruleSets[curRuleSet] = new NFRuleSet(this, ruleSetDescriptions, curRuleSet, status);</span>
<span class="line-modified">!             if (ruleSets[curRuleSet] == 0) {</span>
                  status = U_MEMORY_ALLOCATION_ERROR;
                  return;
              }
              ++curRuleSet;
              start = p + 1;
          }
          ruleSetDescriptions[curRuleSet].setTo(description, start, description.length() - start);
<span class="line-modified">!         ruleSets[curRuleSet] = new NFRuleSet(this, ruleSetDescriptions, curRuleSet, status);</span>
<span class="line-modified">!         if (ruleSets[curRuleSet] == 0) {</span>
              status = U_MEMORY_ALLOCATION_ERROR;
              return;
          }
      }
  
<span class="line-new-header">--- 1610,31 ---</span>
          status = U_ILLEGAL_ARGUMENT_ERROR;
          return;
      }
  
      ruleSetDescriptions = new UnicodeString[numRuleSets];
<span class="line-modified">!     if (ruleSetDescriptions == nullptr) {</span>
          status = U_MEMORY_ALLOCATION_ERROR;
          return;
      }
  
      {
          int curRuleSet = 0;
          int32_t start = 0;
          for (int32_t p = description.indexOf(gSemiPercent, 2, 0); p != -1; p = description.indexOf(gSemiPercent, 2, start)) {
              ruleSetDescriptions[curRuleSet].setTo(description, start, p + 1 - start);
<span class="line-modified">!             fRuleSets[curRuleSet] = new NFRuleSet(this, ruleSetDescriptions, curRuleSet, status);</span>
<span class="line-modified">!             if (fRuleSets[curRuleSet] == nullptr) {</span>
                  status = U_MEMORY_ALLOCATION_ERROR;
                  return;
              }
              ++curRuleSet;
              start = p + 1;
          }
          ruleSetDescriptions[curRuleSet].setTo(description, start, description.length() - start);
<span class="line-modified">!         fRuleSets[curRuleSet] = new NFRuleSet(this, ruleSetDescriptions, curRuleSet, status);</span>
<span class="line-modified">!         if (fRuleSets[curRuleSet] == nullptr) {</span>
              status = U_MEMORY_ALLOCATION_ERROR;
              return;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1628,15 ***</span>
      // set to be known.  For purposes of initialization, this is always the
      // last public rule set, no matter what the localization data says.
      initDefaultRuleSet();
  
      // finally, we can go back through the temporary descriptions
<span class="line-modified">!     // list and finish seting up the substructure (and we throw</span>
      // away the temporary descriptions as we go)
      {
          for (int i = 0; i &lt; numRuleSets; i++) {
<span class="line-modified">!             ruleSets[i]-&gt;parseRules(ruleSetDescriptions[i], status);</span>
          }
      }
  
      // Now that the rules are initialized, the &#39;real&#39; default rule
      // set can be adjusted by the localization data.
<span class="line-new-header">--- 1648,15 ---</span>
      // set to be known.  For purposes of initialization, this is always the
      // last public rule set, no matter what the localization data says.
      initDefaultRuleSet();
  
      // finally, we can go back through the temporary descriptions
<span class="line-modified">!     // list and finish setting up the substructure (and we throw</span>
      // away the temporary descriptions as we go)
      {
          for (int i = 0; i &lt; numRuleSets; i++) {
<span class="line-modified">!             fRuleSets[i]-&gt;parseRules(ruleSetDescriptions[i], status);</span>
          }
      }
  
      // Now that the rules are initialized, the &#39;real&#39; default rule
      // set can be adjusted by the localization data.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1678,11 ***</span>
          }
  #if !UCONFIG_NO_BREAK_ITERATION
          if ( capitalizationBrkIter == NULL &amp;&amp; (value==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
                  (value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU &amp;&amp; capitalizationForUIListMenu) ||
                  (value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE &amp;&amp; capitalizationForStandAlone)) ) {
<span class="line-modified">!             UErrorCode status = U_ZERO_ERROR;</span>
              capitalizationBrkIter = BreakIterator::createSentenceInstance(locale, status);
              if (U_FAILURE(status)) {
                  delete capitalizationBrkIter;
                  capitalizationBrkIter = NULL;
              }
<span class="line-new-header">--- 1698,11 ---</span>
          }
  #if !UCONFIG_NO_BREAK_ITERATION
          if ( capitalizationBrkIter == NULL &amp;&amp; (value==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
                  (value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU &amp;&amp; capitalizationForUIListMenu) ||
                  (value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE &amp;&amp; capitalizationForStandAlone)) ) {
<span class="line-modified">!             status = U_ZERO_ERROR;</span>
              capitalizationBrkIter = BreakIterator::createSentenceInstance(locale, status);
              if (U_FAILURE(status)) {
                  delete capitalizationBrkIter;
                  capitalizationBrkIter = NULL;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1702,12 ***</span>
      rb = ures_getByKeyWithFallback(rb, &quot;number-spellout&quot;, rb, &amp;status);
      if (U_SUCCESS(status) &amp;&amp; rb != NULL) {
          int32_t len = 0;
          const int32_t * intVector = ures_getIntVector(rb, &amp;len, &amp;status);
          if (U_SUCCESS(status) &amp;&amp; intVector != NULL &amp;&amp; len &gt;= 2) {
<span class="line-modified">!             capitalizationForUIListMenu = intVector[0];</span>
<span class="line-modified">!             capitalizationForStandAlone = intVector[1];</span>
          }
      }
      ures_close(rb);
  #endif
  }
<span class="line-new-header">--- 1722,12 ---</span>
      rb = ures_getByKeyWithFallback(rb, &quot;number-spellout&quot;, rb, &amp;status);
      if (U_SUCCESS(status) &amp;&amp; rb != NULL) {
          int32_t len = 0;
          const int32_t * intVector = ures_getIntVector(rb, &amp;len, &amp;status);
          if (U_SUCCESS(status) &amp;&amp; intVector != NULL &amp;&amp; len &gt;= 2) {
<span class="line-modified">!             capitalizationForUIListMenu = static_cast&lt;UBool&gt;(intVector[0]);</span>
<span class="line-modified">!             capitalizationForStandAlone = static_cast&lt;UBool&gt;(intVector[1]);</span>
          }
      }
      ures_close(rb);
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1738,11 ***</span>
          else if (p &lt; description.length()) {
              result.append(description, start, p + 1 - start);
              start = p + 1;
          }
  
<span class="line-modified">!         // when we get here, we&#39;ve seeked off the end of the sring, and</span>
          // we terminate the loop (we continue until *start* is -1 rather
          // than until *p* is -1, because otherwise we&#39;d miss the last
          // rule in the description)
          else {
              start = -1;
<span class="line-new-header">--- 1758,11 ---</span>
          else if (p &lt; description.length()) {
              result.append(description, start, p + 1 - start);
              start = p + 1;
          }
  
<span class="line-modified">!         // when we get here, we&#39;ve seeked off the end of the string, and</span>
          // we terminate the loop (we continue until *start* is -1 rather
          // than until *p* is -1, because otherwise we&#39;d miss the last
          // rule in the description)
          else {
              start = -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1754,16 ***</span>
  
  
  void
  RuleBasedNumberFormat::dispose()
  {
<span class="line-modified">!     if (ruleSets) {</span>
<span class="line-modified">!         for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
              delete *p;
          }
<span class="line-modified">!         uprv_free(ruleSets);</span>
<span class="line-modified">!         ruleSets = NULL;</span>
      }
  
      if (ruleSetDescriptions) {
          delete [] ruleSetDescriptions;
          ruleSetDescriptions = NULL;
<span class="line-new-header">--- 1774,16 ---</span>
  
  
  void
  RuleBasedNumberFormat::dispose()
  {
<span class="line-modified">!     if (fRuleSets) {</span>
<span class="line-modified">!         for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
              delete *p;
          }
<span class="line-modified">!         uprv_free(fRuleSets);</span>
<span class="line-modified">!         fRuleSets = NULL;</span>
      }
  
      if (ruleSetDescriptions) {
          delete [] ruleSetDescriptions;
          ruleSetDescriptions = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1809,20 ***</span>
  */
  const RuleBasedCollator*
  RuleBasedNumberFormat::getCollator() const
  {
  #if !UCONFIG_NO_COLLATION
<span class="line-modified">!     if (!ruleSets) {</span>
          return NULL;
      }
  
      // lazy-evaluate the collator
      if (collator == NULL &amp;&amp; lenient) {
          // create a default collator based on the formatter&#39;s locale,
          // then pull out that collator&#39;s rules, append any additional
          // rules specified in the description, and create a _new_
<span class="line-modified">!         // collator based on the combinaiton of those rules</span>
  
          UErrorCode status = U_ZERO_ERROR;
  
          Collator* temp = Collator::createInstance(locale, status);
          RuleBasedCollator* newCollator;
<span class="line-new-header">--- 1829,20 ---</span>
  */
  const RuleBasedCollator*
  RuleBasedNumberFormat::getCollator() const
  {
  #if !UCONFIG_NO_COLLATION
<span class="line-modified">!     if (!fRuleSets) {</span>
          return NULL;
      }
  
      // lazy-evaluate the collator
      if (collator == NULL &amp;&amp; lenient) {
          // create a default collator based on the formatter&#39;s locale,
          // then pull out that collator&#39;s rules, append any additional
          // rules specified in the description, and create a _new_
<span class="line-modified">!         // collator based on the combination of those rules</span>
  
          UErrorCode status = U_ZERO_ERROR;
  
          Collator* temp = Collator::createInstance(locale, status);
          RuleBasedCollator* newCollator;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1861,17 ***</span>
  RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &amp;status)
  {
      // lazy-evaluate the DecimalFormatSymbols object.  This object
      // is shared by all DecimalFormat instances belonging to this
      // formatter
<span class="line-modified">!     if (decimalFormatSymbols == NULL) {</span>
<span class="line-modified">!         DecimalFormatSymbols* temp = new DecimalFormatSymbols(locale, status);</span>
          if (U_SUCCESS(status)) {
<span class="line-modified">!             decimalFormatSymbols = temp;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-             delete temp;</span>
          }
      }
      return decimalFormatSymbols;
  }
  
<span class="line-new-header">--- 1881,14 ---</span>
  RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &amp;status)
  {
      // lazy-evaluate the DecimalFormatSymbols object.  This object
      // is shared by all DecimalFormat instances belonging to this
      // formatter
<span class="line-modified">!     if (decimalFormatSymbols == nullptr) {</span>
<span class="line-modified">!         LocalPointer&lt;DecimalFormatSymbols&gt; temp(new DecimalFormatSymbols(locale, status), status);</span>
          if (U_SUCCESS(status)) {
<span class="line-modified">!             decimalFormatSymbols = temp.orphan();</span>
          }
      }
      return decimalFormatSymbols;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1887,21 ***</span>
  
  NFRule*
  RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &amp;status)
  {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
      if (defaultInfinityRule == NULL) {
          UnicodeString rule(UNICODE_STRING_SIMPLE(&quot;Inf: &quot;));
          rule.append(getDecimalFormatSymbols()-&gt;getSymbol(DecimalFormatSymbols::kInfinitySymbol));
<span class="line-modified">!         NFRule* temp = new NFRule(this, rule, status);</span>
          if (U_SUCCESS(status)) {
<span class="line-modified">!             defaultInfinityRule = temp;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-             delete temp;</span>
          }
      }
      return defaultInfinityRule;
  }
  
<span class="line-new-header">--- 1904,18 ---</span>
  
  NFRule*
  RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &amp;status)
  {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      if (defaultInfinityRule == NULL) {
          UnicodeString rule(UNICODE_STRING_SIMPLE(&quot;Inf: &quot;));
          rule.append(getDecimalFormatSymbols()-&gt;getSymbol(DecimalFormatSymbols::kInfinitySymbol));
<span class="line-modified">!         LocalPointer&lt;NFRule&gt; temp(new NFRule(this, rule, status), status);</span>
          if (U_SUCCESS(status)) {
<span class="line-modified">!             defaultInfinityRule = temp.orphan();</span>
          }
      }
      return defaultInfinityRule;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1913,21 ***</span>
  
  NFRule*
  RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode &amp;status)
  {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
<span class="line-modified">!     if (defaultNaNRule == NULL) {</span>
          UnicodeString rule(UNICODE_STRING_SIMPLE(&quot;NaN: &quot;));
          rule.append(getDecimalFormatSymbols()-&gt;getSymbol(DecimalFormatSymbols::kNaNSymbol));
<span class="line-modified">!         NFRule* temp = new NFRule(this, rule, status);</span>
          if (U_SUCCESS(status)) {
<span class="line-modified">!             defaultNaNRule = temp;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-             delete temp;</span>
          }
      }
      return defaultNaNRule;
  }
  
<span class="line-new-header">--- 1927,18 ---</span>
  
  NFRule*
  RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode &amp;status)
  {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-modified">!     if (defaultNaNRule == nullptr) {</span>
          UnicodeString rule(UNICODE_STRING_SIMPLE(&quot;NaN: &quot;));
          rule.append(getDecimalFormatSymbols()-&gt;getSymbol(DecimalFormatSymbols::kNaNSymbol));
<span class="line-modified">!         LocalPointer&lt;NFRule&gt; temp(new NFRule(this, rule, status), status);</span>
          if (U_SUCCESS(status)) {
<span class="line-modified">!             defaultNaNRule = temp.orphan();</span>
          }
      }
      return defaultNaNRule;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1961,19 ***</span>
  
          delete defaultNaNRule;
          defaultNaNRule = NULL;
          initializeDefaultNaNRule(status); // Reset with the new DecimalFormatSymbols
  
<span class="line-modified">!         if (ruleSets) {</span>
              for (int32_t i = 0; i &lt; numRuleSets; i++) {
<span class="line-modified">!                 ruleSets[i]-&gt;setDecimalFormatSymbols(*symbolsToAdopt, status);</span>
              }
          }
      }
  }
  
<span class="line-modified">! // Setting the symbols is equlivalent to adopting a newly created localized symbols.</span>
  void
  RuleBasedNumberFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols)
  {
      adoptDecimalFormatSymbols(new DecimalFormatSymbols(symbols));
  }
<span class="line-new-header">--- 1972,19 ---</span>
  
          delete defaultNaNRule;
          defaultNaNRule = NULL;
          initializeDefaultNaNRule(status); // Reset with the new DecimalFormatSymbols
  
<span class="line-modified">!         if (fRuleSets) {</span>
              for (int32_t i = 0; i &lt; numRuleSets; i++) {
<span class="line-modified">!                 fRuleSets[i]-&gt;setDecimalFormatSymbols(*symbolsToAdopt, status);</span>
              }
          }
      }
  }
  
<span class="line-modified">! // Setting the symbols is equivalent to adopting a newly created localized symbols.</span>
  void
  RuleBasedNumberFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols)
  {
      adoptDecimalFormatSymbols(new DecimalFormatSymbols(symbols));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1981,28 ***</span>
  PluralFormat *
  RuleBasedNumberFormat::createPluralFormat(UPluralType pluralType,
                                            const UnicodeString &amp;pattern,
                                            UErrorCode&amp; status) const
  {
<span class="line-modified">!     return new PluralFormat(locale, pluralType, pattern, status);</span>
  }
  
  /**
   * Get the rounding mode.
   * @return A rounding mode
   */
  DecimalFormat::ERoundingMode RuleBasedNumberFormat::getRoundingMode() const {
<span class="line-modified">!     return roundingMode;</span>
  }
  
  /**
   * Set the rounding mode.  This has no effect unless the rounding
   * increment is greater than zero.
   * @param roundingMode A rounding mode
   */
  void RuleBasedNumberFormat::setRoundingMode(DecimalFormat::ERoundingMode roundingMode) {
<span class="line-modified">!     this-&gt;roundingMode = roundingMode;</span>
  }
  
  U_NAMESPACE_END
  
  /* U_HAVE_RBNF */
<span class="line-new-header">--- 1992,32 ---</span>
  PluralFormat *
  RuleBasedNumberFormat::createPluralFormat(UPluralType pluralType,
                                            const UnicodeString &amp;pattern,
                                            UErrorCode&amp; status) const
  {
<span class="line-modified">!     auto *pf = new PluralFormat(locale, pluralType, pattern, status);</span>
<span class="line-added">+     if (pf == nullptr) {</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return pf;</span>
  }
  
  /**
   * Get the rounding mode.
   * @return A rounding mode
   */
  DecimalFormat::ERoundingMode RuleBasedNumberFormat::getRoundingMode() const {
<span class="line-modified">!     return fRoundingMode;</span>
  }
  
  /**
   * Set the rounding mode.  This has no effect unless the rounding
   * increment is greater than zero.
   * @param roundingMode A rounding mode
   */
  void RuleBasedNumberFormat::setRoundingMode(DecimalFormat::ERoundingMode roundingMode) {
<span class="line-modified">!     fRoundingMode = roundingMode;</span>
  }
  
  U_NAMESPACE_END
  
  /* U_HAVE_RBNF */
</pre>
<center><a href="quantityformatter.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbt.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>