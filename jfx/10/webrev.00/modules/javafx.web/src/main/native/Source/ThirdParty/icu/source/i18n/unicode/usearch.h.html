<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/usearch.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 2001-2011,2014 IBM and others. All rights reserved.
  6 **********************************************************************
  7 *   Date        Name        Description
  8 *  06/28/2001   synwee      Creation.
  9 **********************************************************************
 10 */
 11 #ifndef USEARCH_H
 12 #define USEARCH_H
 13 
 14 #include &quot;unicode/utypes.h&quot;
 15 
 16 #if !UCONFIG_NO_COLLATION &amp;&amp; !UCONFIG_NO_BREAK_ITERATION
 17 
 18 #include &quot;unicode/localpointer.h&quot;
 19 #include &quot;unicode/ucol.h&quot;
 20 #include &quot;unicode/ucoleitr.h&quot;
 21 #include &quot;unicode/ubrk.h&quot;
 22 
 23 /**
 24  * \file
 25  * \brief C API: StringSearch
 26  *
 27  * C Apis for an engine that provides language-sensitive text searching based
 28  * on the comparison rules defined in a &lt;tt&gt;UCollator&lt;/tt&gt; data struct,
 29  * see &lt;tt&gt;ucol.h&lt;/tt&gt;. This ensures that language eccentricity can be
 30  * handled, e.g. for the German collator, characters &amp;szlig; and SS will be matched
 31  * if case is chosen to be ignored.
 32  * See the &lt;a href=&quot;http://source.icu-project.org/repos/icu/icuhtml/trunk/design/collation/ICU_collation_design.htm&quot;&gt;
 33  * &quot;ICU Collation Design Document&quot;&lt;/a&gt; for more information.
 34  * &lt;p&gt;
 35  * The implementation may use a linear search or a modified form of the Boyer-Moore
 36  * search; for more information on the latter see
 37  * &lt;a href=&quot;http://icu-project.org/docs/papers/efficient_text_searching_in_java.html&quot;&gt;
 38  * &quot;Efficient Text Searching in Java&quot;&lt;/a&gt;, published in &lt;i&gt;Java Report&lt;/i&gt;
 39  * in February, 1999.
 40  * &lt;p&gt;
 41  * There are 2 match options for selection:&lt;br&gt;
 42  * Let S&#39; be the sub-string of a text string S between the offsets start and
 43  * end &lt;start, end&gt;.
 44  * &lt;br&gt;
 45  * A pattern string P matches a text string S at the offsets &lt;start, end&gt;
 46  * if
 47  * &lt;pre&gt;
 48  * option 1. Some canonical equivalent of P matches some canonical equivalent
 49  *           of S&#39;
 50  * option 2. P matches S&#39; and if P starts or ends with a combining mark,
 51  *           there exists no non-ignorable combining mark before or after S&#39;
 52  *           in S respectively.
 53  * &lt;/pre&gt;
 54  * Option 2. will be the default.
 55  * &lt;p&gt;
 56  * This search has APIs similar to that of other text iteration mechanisms
 57  * such as the break iterators in &lt;tt&gt;ubrk.h&lt;/tt&gt;. Using these
 58  * APIs, it is easy to scan through text looking for all occurances of
 59  * a given pattern. This search iterator allows changing of direction by
 60  * calling a &lt;tt&gt;reset&lt;/tt&gt; followed by a &lt;tt&gt;next&lt;/tt&gt; or &lt;tt&gt;previous&lt;/tt&gt;.
 61  * Though a direction change can occur without calling &lt;tt&gt;reset&lt;/tt&gt; first,
 62  * this operation comes with some speed penalty.
 63  * Generally, match results in the forward direction will match the result
 64  * matches in the backwards direction in the reverse order
 65  * &lt;p&gt;
 66  * &lt;tt&gt;usearch.h&lt;/tt&gt; provides APIs to specify the starting position
 67  * within the text string to be searched, e.g. &lt;tt&gt;usearch_setOffset&lt;/tt&gt;,
 68  * &lt;tt&gt;usearch_preceding&lt;/tt&gt; and &lt;tt&gt;usearch_following&lt;/tt&gt;. Since the
 69  * starting position will be set as it is specified, please take note that
 70  * there are some dangerous positions which the search may render incorrect
 71  * results:
 72  * &lt;ul&gt;
 73  * &lt;li&gt; The midst of a substring that requires normalization.
 74  * &lt;li&gt; If the following match is to be found, the position should not be the
 75  *      second character which requires to be swapped with the preceding
 76  *      character. Vice versa, if the preceding match is to be found,
 77  *      position to search from should not be the first character which
 78  *      requires to be swapped with the next character. E.g certain Thai and
 79  *      Lao characters require swapping.
 80  * &lt;li&gt; If a following pattern match is to be found, any position within a
 81  *      contracting sequence except the first will fail. Vice versa if a
 82  *      preceding pattern match is to be found, a invalid starting point
 83  *      would be any character within a contracting sequence except the last.
 84  * &lt;/ul&gt;
 85  * &lt;p&gt;
 86  * A breakiterator can be used if only matches at logical breaks are desired.
 87  * Using a breakiterator will only give you results that exactly matches the
 88  * boundaries given by the breakiterator. For instance the pattern &quot;e&quot; will
 89  * not be found in the string &quot;\u00e9&quot; if a character break iterator is used.
 90  * &lt;p&gt;
 91  * Options are provided to handle overlapping matches.
 92  * E.g. In English, overlapping matches produces the result 0 and 2
 93  * for the pattern &quot;abab&quot; in the text &quot;ababab&quot;, where else mutually
 94  * exclusive matches only produce the result of 0.
 95  * &lt;p&gt;
 96  * Options are also provided to implement &quot;asymmetric search&quot; as described in
 97  * &lt;a href=&quot;http://www.unicode.org/reports/tr10/#Asymmetric_Search&quot;&gt;
 98  * UTS #10 Unicode Collation Algorithm&lt;/a&gt;, specifically the USearchAttribute
 99  * USEARCH_ELEMENT_COMPARISON and its values.
100  * &lt;p&gt;
101  * Though collator attributes will be taken into consideration while
102  * performing matches, there are no APIs here for setting and getting the
103  * attributes. These attributes can be set by getting the collator
104  * from &lt;tt&gt;usearch_getCollator&lt;/tt&gt; and using the APIs in &lt;tt&gt;ucol.h&lt;/tt&gt;.
105  * Lastly to update String Search to the new collator attributes,
106  * usearch_reset() has to be called.
107  * &lt;p&gt;
108  * Restriction: &lt;br&gt;
109  * Currently there are no composite characters that consists of a
110  * character with combining class &gt; 0 before a character with combining
111  * class == 0. However, if such a character exists in the future, the
112  * search mechanism does not guarantee the results for option 1.
113  *
114  * &lt;p&gt;
115  * Example of use:&lt;br&gt;
116  * &lt;pre&gt;&lt;code&gt;
117  * char *tgtstr = &quot;The quick brown fox jumped over the lazy fox&quot;;
118  * char *patstr = &quot;fox&quot;;
119  * UChar target[64];
120  * UChar pattern[16];
121  * UErrorCode status = U_ZERO_ERROR;
122  * u_uastrcpy(target, tgtstr);
123  * u_uastrcpy(pattern, patstr);
124  *
125  * UStringSearch *search = usearch_open(pattern, -1, target, -1, &quot;en_US&quot;,
126  *                                  NULL, &amp;status);
127  * if (U_SUCCESS(status)) {
128  *     for (int pos = usearch_first(search, &amp;status);
129  *          pos != USEARCH_DONE;
130  *          pos = usearch_next(search, &amp;status))
131  *     {
132  *         printf(&quot;Found match at %d pos, length is %d\n&quot;, pos,
133  *                                        usearch_getMatchLength(search));
134  *     }
135  * }
136  *
137  * usearch_close(search);
138  * &lt;/code&gt;&lt;/pre&gt;
139  * @stable ICU 2.4
140  */
141 
142 /**
143 * DONE is returned by previous() and next() after all valid matches have
144 * been returned, and by first() and last() if there are no matches at all.
145 * @stable ICU 2.4
146 */
147 #define USEARCH_DONE -1
148 
149 /**
150 * Data structure for searching
151 * @stable ICU 2.4
152 */
153 struct UStringSearch;
154 /**
155 * Data structure for searching
156 * @stable ICU 2.4
157 */
158 typedef struct UStringSearch UStringSearch;
159 
160 /**
161 * @stable ICU 2.4
162 */
163 typedef enum {
164     /**
165      * Option for overlapping matches
166      * @stable ICU 2.4
167      */
168     USEARCH_OVERLAP = 0,
169 #ifndef U_HIDE_DEPRECATED_API
170     /**
171      * Option for canonical matches; option 1 in header documentation.
172      * The default value will be USEARCH_OFF.
173      * Note: Setting this option to USEARCH_ON currently has no effect on
174      * search behavior, and this option is deprecated. Instead, to control
175      * canonical match behavior, you must set UCOL_NORMALIZATION_MODE
176      * appropriately (to UCOL_OFF or UCOL_ON) in the UCollator used by
177      * the UStringSearch object.
178      * @see usearch_openFromCollator
179      * @see usearch_getCollator
180      * @see usearch_setCollator
181      * @see ucol_getAttribute
182      * @deprecated ICU 53
183      */
184     USEARCH_CANONICAL_MATCH = 1,
185 #endif  /* U_HIDE_DEPRECATED_API */
186     /**
187      * Option to control how collation elements are compared.
188      * The default value will be USEARCH_STANDARD_ELEMENT_COMPARISON.
189      * @stable ICU 4.4
190      */
191     USEARCH_ELEMENT_COMPARISON = 2,
192 
193 #ifndef U_HIDE_DEPRECATED_API
194     /**
195      * One more than the highest normal USearchAttribute value.
196      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
197      */
198     USEARCH_ATTRIBUTE_COUNT = 3
199 #endif  /* U_HIDE_DEPRECATED_API */
200 } USearchAttribute;
201 
202 /**
203 * @stable ICU 2.4
204 */
205 typedef enum {
206     /**
207      * Default value for any USearchAttribute
208      * @stable ICU 2.4
209      */
210     USEARCH_DEFAULT = -1,
211     /**
212      * Value for USEARCH_OVERLAP and USEARCH_CANONICAL_MATCH
213      * @stable ICU 2.4
214      */
215     USEARCH_OFF,
216     /**
217      * Value for USEARCH_OVERLAP and USEARCH_CANONICAL_MATCH
218      * @stable ICU 2.4
219      */
220     USEARCH_ON,
221     /**
222      * Value (default) for USEARCH_ELEMENT_COMPARISON;
223      * standard collation element comparison at the specified collator
224      * strength.
225      * @stable ICU 4.4
226      */
227     USEARCH_STANDARD_ELEMENT_COMPARISON,
228     /**
229      * Value for USEARCH_ELEMENT_COMPARISON;
230      * collation element comparison is modified to effectively provide
231      * behavior between the specified strength and strength - 1. Collation
232      * elements in the pattern that have the base weight for the specified
233      * strength are treated as &quot;wildcards&quot; that match an element with any
234      * other weight at that collation level in the searched text. For
235      * example, with a secondary-strength English collator, a plain &#39;e&#39; in
236      * the pattern will match a plain e or an e with any diacritic in the
237      * searched text, but an e with diacritic in the pattern will only
238      * match an e with the same diacritic in the searched text.
239      *
240      * This supports &quot;asymmetric search&quot; as described in
241      * &lt;a href=&quot;http://www.unicode.org/reports/tr10/#Asymmetric_Search&quot;&gt;
242      * UTS #10 Unicode Collation Algorithm&lt;/a&gt;.
243      *
244      * @stable ICU 4.4
245      */
246     USEARCH_PATTERN_BASE_WEIGHT_IS_WILDCARD,
247     /**
248      * Value for USEARCH_ELEMENT_COMPARISON.
249      * collation element comparison is modified to effectively provide
250      * behavior between the specified strength and strength - 1. Collation
251      * elements in either the pattern or the searched text that have the
252      * base weight for the specified strength are treated as &quot;wildcards&quot;
253      * that match an element with any other weight at that collation level.
254      * For example, with a secondary-strength English collator, a plain &#39;e&#39;
255      * in the pattern will match a plain e or an e with any diacritic in the
256      * searched text, but an e with diacritic in the pattern will only
257      * match an e with the same diacritic or a plain e in the searched text.
258      *
259      * This option is similar to &quot;asymmetric search&quot; as described in
260      * [UTS #10 Unicode Collation Algorithm](http://www.unicode.org/reports/tr10/#Asymmetric_Search),
261      * but also allows unmarked characters in the searched text to match
262      * marked or unmarked versions of that character in the pattern.
263      *
264      * @stable ICU 4.4
265      */
266     USEARCH_ANY_BASE_WEIGHT_IS_WILDCARD,
267 
268 #ifndef U_HIDE_DEPRECATED_API
269     /**
270      * One more than the highest normal USearchAttributeValue value.
271      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
272      */
273     USEARCH_ATTRIBUTE_VALUE_COUNT
274 #endif  /* U_HIDE_DEPRECATED_API */
275 } USearchAttributeValue;
276 
277 /* open and close ------------------------------------------------------ */
278 
279 /**
280 * Creating a search iterator data struct using the argument locale language
281 * rule set. A collator will be created in the process, which will be owned by
282 * this search and will be deleted in &lt;tt&gt;usearch_close&lt;/tt&gt;.
283 * @param pattern for matching
284 * @param patternlength length of the pattern, -1 for null-termination
285 * @param text text string
286 * @param textlength length of the text string, -1 for null-termination
287 * @param locale name of locale for the rules to be used
288 * @param breakiter A BreakIterator that will be used to restrict the points
289 *                  at which matches are detected. If a match is found, but
290 *                  the match&#39;s start or end index is not a boundary as
291 *                  determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt;, the match will
292 *                  be rejected and another will be searched for.
293 *                  If this parameter is &lt;tt&gt;NULL&lt;/tt&gt;, no break detection is
294 *                  attempted.
295 * @param status for errors if it occurs. If pattern or text is NULL, or if
296 *               patternlength or textlength is 0 then an
297 *               U_ILLEGAL_ARGUMENT_ERROR is returned.
298 * @return search iterator data structure, or NULL if there is an error.
299 * @stable ICU 2.4
300 */
301 U_STABLE UStringSearch * U_EXPORT2 usearch_open(const UChar          *pattern,
302                                               int32_t         patternlength,
303                                         const UChar          *text,
304                                               int32_t         textlength,
305                                         const char           *locale,
306                                               UBreakIterator *breakiter,
307                                               UErrorCode     *status);
308 
309 /**
310 * Creating a search iterator data struct using the argument collator language
311 * rule set. Note, user retains the ownership of this collator, thus the
312 * responsibility of deletion lies with the user.
313 * NOTE: string search cannot be instantiated from a collator that has
314 * collate digits as numbers (CODAN) turned on.
315 * @param pattern for matching
316 * @param patternlength length of the pattern, -1 for null-termination
317 * @param text text string
318 * @param textlength length of the text string, -1 for null-termination
319 * @param collator used for the language rules
320 * @param breakiter A BreakIterator that will be used to restrict the points
321 *                  at which matches are detected. If a match is found, but
322 *                  the match&#39;s start or end index is not a boundary as
323 *                  determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt;, the match will
324 *                  be rejected and another will be searched for.
325 *                  If this parameter is &lt;tt&gt;NULL&lt;/tt&gt;, no break detection is
326 *                  attempted.
327 * @param status for errors if it occurs. If collator, pattern or text is NULL,
328 *               or if patternlength or textlength is 0 then an
329 *               U_ILLEGAL_ARGUMENT_ERROR is returned.
330 * @return search iterator data structure, or NULL if there is an error.
331 * @stable ICU 2.4
332 */
333 U_STABLE UStringSearch * U_EXPORT2 usearch_openFromCollator(
334                                          const UChar *pattern,
335                                                int32_t         patternlength,
336                                          const UChar          *text,
337                                                int32_t         textlength,
338                                          const UCollator      *collator,
339                                                UBreakIterator *breakiter,
340                                                UErrorCode     *status);
341 
342 /**
343 * Destroying and cleaning up the search iterator data struct.
344 * If a collator is created in &lt;tt&gt;usearch_open&lt;/tt&gt;, it will be destroyed here.
345 * @param searchiter data struct to clean up
346 * @stable ICU 2.4
347 */
348 U_STABLE void U_EXPORT2 usearch_close(UStringSearch *searchiter);
349 
350 #if U_SHOW_CPLUSPLUS_API
351 
352 U_NAMESPACE_BEGIN
353 
354 /**
355  * \class LocalUStringSearchPointer
356  * &quot;Smart pointer&quot; class, closes a UStringSearch via usearch_close().
357  * For most methods see the LocalPointerBase base class.
358  *
359  * @see LocalPointerBase
360  * @see LocalPointer
361  * @stable ICU 4.4
362  */
363 U_DEFINE_LOCAL_OPEN_POINTER(LocalUStringSearchPointer, UStringSearch, usearch_close);
364 
365 U_NAMESPACE_END
366 
367 #endif
368 
369 /* get and set methods -------------------------------------------------- */
370 
371 /**
372 * Sets the current position in the text string which the next search will
373 * start from. Clears previous states.
374 * This method takes the argument index and sets the position in the text
375 * string accordingly without checking if the index is pointing to a
376 * valid starting point to begin searching.
377 * Search positions that may render incorrect results are highlighted in the
378 * header comments
379 * @param strsrch search iterator data struct
380 * @param position position to start next search from. If position is less
381 *          than or greater than the text range for searching,
382 *          an U_INDEX_OUTOFBOUNDS_ERROR will be returned
383 * @param status error status if any.
384 * @stable ICU 2.4
385 */
386 U_STABLE void U_EXPORT2 usearch_setOffset(UStringSearch *strsrch,
387                                         int32_t    position,
388                                         UErrorCode    *status);
389 
390 /**
391 * Return the current index in the string text being searched.
392 * If the iteration has gone past the end of the text (or past the beginning
393 * for a backwards search), &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; is returned.
394 * @param strsrch search iterator data struct
395 * @see #USEARCH_DONE
396 * @stable ICU 2.4
397 */
398 U_STABLE int32_t U_EXPORT2 usearch_getOffset(const UStringSearch *strsrch);
399 
400 /**
401 * Sets the text searching attributes located in the enum USearchAttribute
402 * with values from the enum USearchAttributeValue.
403 * &lt;tt&gt;USEARCH_DEFAULT&lt;/tt&gt; can be used for all attributes for resetting.
404 * @param strsrch search iterator data struct
405 * @param attribute text attribute to be set
406 * @param value text attribute value
407 * @param status for errors if it occurs
408 * @see #usearch_getAttribute
409 * @stable ICU 2.4
410 */
411 U_STABLE void U_EXPORT2 usearch_setAttribute(UStringSearch         *strsrch,
412                                            USearchAttribute       attribute,
413                                            USearchAttributeValue  value,
414                                            UErrorCode            *status);
415 
416 /**
417 * Gets the text searching attributes.
418 * @param strsrch search iterator data struct
419 * @param attribute text attribute to be retrieve
420 * @return text attribute value
421 * @see #usearch_setAttribute
422 * @stable ICU 2.4
423 */
424 U_STABLE USearchAttributeValue U_EXPORT2 usearch_getAttribute(
425                                          const UStringSearch    *strsrch,
426                                                USearchAttribute  attribute);
427 
428 /**
429 * Returns the index to the match in the text string that was searched.
430 * This call returns a valid result only after a successful call to
431 * &lt;tt&gt;usearch_first&lt;/tt&gt;, &lt;tt&gt;usearch_next&lt;/tt&gt;, &lt;tt&gt;usearch_previous&lt;/tt&gt;,
432 * or &lt;tt&gt;usearch_last&lt;/tt&gt;.
433 * Just after construction, or after a searching method returns
434 * &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;, this method will return &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;.
435 * &lt;p&gt;
436 * Use &lt;tt&gt;usearch_getMatchedLength&lt;/tt&gt; to get the matched string length.
437 * @param strsrch search iterator data struct
438 * @return index to a substring within the text string that is being
439 *         searched.
440 * @see #usearch_first
441 * @see #usearch_next
442 * @see #usearch_previous
443 * @see #usearch_last
444 * @see #USEARCH_DONE
445 * @stable ICU 2.4
446 */
447 U_STABLE int32_t U_EXPORT2 usearch_getMatchedStart(
448                                                const UStringSearch *strsrch);
449 
450 /**
451 * Returns the length of text in the string which matches the search pattern.
452 * This call returns a valid result only after a successful call to
453 * &lt;tt&gt;usearch_first&lt;/tt&gt;, &lt;tt&gt;usearch_next&lt;/tt&gt;, &lt;tt&gt;usearch_previous&lt;/tt&gt;,
454 * or &lt;tt&gt;usearch_last&lt;/tt&gt;.
455 * Just after construction, or after a searching method returns
456 * &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;, this method will return 0.
457 * @param strsrch search iterator data struct
458 * @return The length of the match in the string text, or 0 if there is no
459 *         match currently.
460 * @see #usearch_first
461 * @see #usearch_next
462 * @see #usearch_previous
463 * @see #usearch_last
464 * @see #USEARCH_DONE
465 * @stable ICU 2.4
466 */
467 U_STABLE int32_t U_EXPORT2 usearch_getMatchedLength(
468                                                const UStringSearch *strsrch);
469 
470 /**
471 * Returns the text that was matched by the most recent call to
472 * &lt;tt&gt;usearch_first&lt;/tt&gt;, &lt;tt&gt;usearch_next&lt;/tt&gt;, &lt;tt&gt;usearch_previous&lt;/tt&gt;,
473 * or &lt;tt&gt;usearch_last&lt;/tt&gt;.
474 * If the iterator is not pointing at a valid match (e.g. just after
475 * construction or after &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; has been returned, returns
476 * an empty string. If result is not large enough to store the matched text,
477 * result will be filled with the partial text and an U_BUFFER_OVERFLOW_ERROR
478 * will be returned in status. result will be null-terminated whenever
479 * possible. If the buffer fits the matched text exactly, a null-termination
480 * is not possible, then a U_STRING_NOT_TERMINATED_ERROR set in status.
481 * Pre-flighting can be either done with length = 0 or the API
482 * &lt;tt&gt;usearch_getMatchLength&lt;/tt&gt;.
483 * @param strsrch search iterator data struct
484 * @param result UChar buffer to store the matched string
485 * @param resultCapacity length of the result buffer
486 * @param status error returned if result is not large enough
487 * @return exact length of the matched text, not counting the null-termination
488 * @see #usearch_first
489 * @see #usearch_next
490 * @see #usearch_previous
491 * @see #usearch_last
492 * @see #USEARCH_DONE
493 * @stable ICU 2.4
494 */
495 U_STABLE int32_t U_EXPORT2 usearch_getMatchedText(const UStringSearch *strsrch,
496                                             UChar         *result,
497                                             int32_t        resultCapacity,
498                                             UErrorCode    *status);
499 
500 #if !UCONFIG_NO_BREAK_ITERATION
501 
502 /**
503 * Set the BreakIterator that will be used to restrict the points at which
504 * matches are detected.
505 * @param strsrch search iterator data struct
506 * @param breakiter A BreakIterator that will be used to restrict the points
507 *                  at which matches are detected. If a match is found, but
508 *                  the match&#39;s start or end index is not a boundary as
509 *                  determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt;, the match will
510 *                  be rejected and another will be searched for.
511 *                  If this parameter is &lt;tt&gt;NULL&lt;/tt&gt;, no break detection is
512 *                  attempted.
513 * @param status for errors if it occurs
514 * @see #usearch_getBreakIterator
515 * @stable ICU 2.4
516 */
517 U_STABLE void U_EXPORT2 usearch_setBreakIterator(UStringSearch  *strsrch,
518                                                UBreakIterator *breakiter,
519                                                UErrorCode     *status);
520 
521 /**
522 * Returns the BreakIterator that is used to restrict the points at which
523 * matches are detected. This will be the same object that was passed to the
524 * constructor or to &lt;tt&gt;usearch_setBreakIterator&lt;/tt&gt;. Note that
525 * &lt;tt&gt;NULL&lt;/tt&gt;
526 * is a legal value; it means that break detection should not be attempted.
527 * @param strsrch search iterator data struct
528 * @return break iterator used
529 * @see #usearch_setBreakIterator
530 * @stable ICU 2.4
531 */
532 U_STABLE const UBreakIterator * U_EXPORT2 usearch_getBreakIterator(
533                                               const UStringSearch *strsrch);
534 
535 #endif
536 
537 /**
538 * Set the string text to be searched. Text iteration will hence begin at the
539 * start of the text string. This method is useful if you want to re-use an
540 * iterator to search for the same pattern within a different body of text.
541 * @param strsrch search iterator data struct
542 * @param text new string to look for match
543 * @param textlength length of the new string, -1 for null-termination
544 * @param status for errors if it occurs. If text is NULL, or textlength is 0
545 *               then an U_ILLEGAL_ARGUMENT_ERROR is returned with no change
546 *               done to strsrch.
547 * @see #usearch_getText
548 * @stable ICU 2.4
549 */
550 U_STABLE void U_EXPORT2 usearch_setText(      UStringSearch *strsrch,
551                                       const UChar         *text,
552                                             int32_t        textlength,
553                                             UErrorCode    *status);
554 
555 /**
556 * Return the string text to be searched.
557 * @param strsrch search iterator data struct
558 * @param length returned string text length
559 * @return string text
560 * @see #usearch_setText
561 * @stable ICU 2.4
562 */
563 U_STABLE const UChar * U_EXPORT2 usearch_getText(const UStringSearch *strsrch,
564                                                int32_t       *length);
565 
566 /**
567 * Gets the collator used for the language rules.
568 * &lt;p&gt;
569 * Deleting the returned &lt;tt&gt;UCollator&lt;/tt&gt; before calling
570 * &lt;tt&gt;usearch_close&lt;/tt&gt; would cause the string search to fail.
571 * &lt;tt&gt;usearch_close&lt;/tt&gt; will delete the collator if this search owns it.
572 * @param strsrch search iterator data struct
573 * @return collator
574 * @stable ICU 2.4
575 */
576 U_STABLE UCollator * U_EXPORT2 usearch_getCollator(
577                                                const UStringSearch *strsrch);
578 
579 /**
580 * Sets the collator used for the language rules. User retains the ownership
581 * of this collator, thus the responsibility of deletion lies with the user.
582 * This method causes internal data such as Boyer-Moore shift tables to
583 * be recalculated, but the iterator&#39;s position is unchanged.
584 * @param strsrch search iterator data struct
585 * @param collator to be used
586 * @param status for errors if it occurs
587 * @stable ICU 2.4
588 */
589 U_STABLE void U_EXPORT2 usearch_setCollator(      UStringSearch *strsrch,
590                                           const UCollator     *collator,
591                                                 UErrorCode    *status);
592 
593 /**
594 * Sets the pattern used for matching.
595 * Internal data like the Boyer Moore table will be recalculated, but the
596 * iterator&#39;s position is unchanged.
597 * @param strsrch search iterator data struct
598 * @param pattern string
599 * @param patternlength pattern length, -1 for null-terminated string
600 * @param status for errors if it occurs. If text is NULL, or textlength is 0
601 *               then an U_ILLEGAL_ARGUMENT_ERROR is returned with no change
602 *               done to strsrch.
603 * @stable ICU 2.4
604 */
605 U_STABLE void U_EXPORT2 usearch_setPattern(      UStringSearch *strsrch,
606                                          const UChar         *pattern,
607                                                int32_t        patternlength,
608                                                UErrorCode    *status);
609 
610 /**
611 * Gets the search pattern
612 * @param strsrch search iterator data struct
613 * @param length return length of the pattern, -1 indicates that the pattern
614 *               is null-terminated
615 * @return pattern string
616 * @stable ICU 2.4
617 */
618 U_STABLE const UChar * U_EXPORT2 usearch_getPattern(
619                                                const UStringSearch *strsrch,
620                                                      int32_t       *length);
621 
622 /* methods ------------------------------------------------------------- */
623 
624 /**
625 * Returns the first index at which the string text matches the search
626 * pattern.
627 * The iterator is adjusted so that its current index (as returned by
628 * &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if one was found.
629 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
630 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;.
631 * @param strsrch search iterator data struct
632 * @param status for errors if it occurs
633 * @return The character index of the first match, or
634 * &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no matches.
635 * @see #usearch_getOffset
636 * @see #USEARCH_DONE
637 * @stable ICU 2.4
638 */
639 U_STABLE int32_t U_EXPORT2 usearch_first(UStringSearch *strsrch,
640                                            UErrorCode    *status);
641 
642 /**
643 * Returns the first index equal or greater than &lt;tt&gt;position&lt;/tt&gt; at which
644 * the string text
645 * matches the search pattern. The iterator is adjusted so that its current
646 * index (as returned by &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if
647 * one was found.
648 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
649 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;
650 * &lt;p&gt;
651 * Search positions that may render incorrect results are highlighted in the
652 * header comments. If position is less than or greater than the text range
653 * for searching, an U_INDEX_OUTOFBOUNDS_ERROR will be returned
654 * @param strsrch search iterator data struct
655 * @param position to start the search at
656 * @param status for errors if it occurs
657 * @return The character index of the first match following &lt;tt&gt;pos&lt;/tt&gt;,
658 *         or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no matches.
659 * @see #usearch_getOffset
660 * @see #USEARCH_DONE
661 * @stable ICU 2.4
662 */
663 U_STABLE int32_t U_EXPORT2 usearch_following(UStringSearch *strsrch,
664                                                int32_t    position,
665                                                UErrorCode    *status);
666 
667 /**
668 * Returns the last index in the target text at which it matches the search
669 * pattern. The iterator is adjusted so that its current
670 * index (as returned by &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if
671 * one was found.
672 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
673 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;.
674 * @param strsrch search iterator data struct
675 * @param status for errors if it occurs
676 * @return The index of the first match, or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there
677 *         are no matches.
678 * @see #usearch_getOffset
679 * @see #USEARCH_DONE
680 * @stable ICU 2.4
681 */
682 U_STABLE int32_t U_EXPORT2 usearch_last(UStringSearch *strsrch,
683                                           UErrorCode    *status);
684 
685 /**
686 * Returns the first index less than &lt;tt&gt;position&lt;/tt&gt; at which the string text
687 * matches the search pattern. The iterator is adjusted so that its current
688 * index (as returned by &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if
689 * one was found.
690 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
691 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;
692 * &lt;p&gt;
693 * Search positions that may render incorrect results are highlighted in the
694 * header comments. If position is less than or greater than the text range
695 * for searching, an U_INDEX_OUTOFBOUNDS_ERROR will be returned.
696 * &lt;p&gt;
697 * When &lt;tt&gt;USEARCH_OVERLAP&lt;/tt&gt; option is off, the last index of the
698 * result match is always less than &lt;tt&gt;position&lt;/tt&gt;.
699 * When &lt;tt&gt;USERARCH_OVERLAP&lt;/tt&gt; is on, the result match may span across
700 * &lt;tt&gt;position&lt;/tt&gt;.
701 * @param strsrch search iterator data struct
702 * @param position index position the search is to begin at
703 * @param status for errors if it occurs
704 * @return The character index of the first match preceding &lt;tt&gt;pos&lt;/tt&gt;,
705 *         or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no matches.
706 * @see #usearch_getOffset
707 * @see #USEARCH_DONE
708 * @stable ICU 2.4
709 */
710 U_STABLE int32_t U_EXPORT2 usearch_preceding(UStringSearch *strsrch,
711                                                int32_t    position,
712                                                UErrorCode    *status);
713 
714 /**
715 * Returns the index of the next point at which the string text matches the
716 * search pattern, starting from the current position.
717 * The iterator is adjusted so that its current
718 * index (as returned by &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if
719 * one was found.
720 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
721 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;
722 * @param strsrch search iterator data struct
723 * @param status for errors if it occurs
724 * @return The index of the next match after the current position, or
725 *         &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no more matches.
726 * @see #usearch_first
727 * @see #usearch_getOffset
728 * @see #USEARCH_DONE
729 * @stable ICU 2.4
730 */
731 U_STABLE int32_t U_EXPORT2 usearch_next(UStringSearch *strsrch,
732                                           UErrorCode    *status);
733 
734 /**
735 * Returns the index of the previous point at which the string text matches
736 * the search pattern, starting at the current position.
737 * The iterator is adjusted so that its current
738 * index (as returned by &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if
739 * one was found.
740 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
741 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;
742 * @param strsrch search iterator data struct
743 * @param status for errors if it occurs
744 * @return The index of the previous match before the current position,
745 *         or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no more matches.
746 * @see #usearch_last
747 * @see #usearch_getOffset
748 * @see #USEARCH_DONE
749 * @stable ICU 2.4
750 */
751 U_STABLE int32_t U_EXPORT2 usearch_previous(UStringSearch *strsrch,
752                                               UErrorCode    *status);
753 
754 /**
755 * Reset the iteration.
756 * Search will begin at the start of the text string if a forward iteration
757 * is initiated before a backwards iteration. Otherwise if a backwards
758 * iteration is initiated before a forwards iteration, the search will begin
759 * at the end of the text string.
760 * @param strsrch search iterator data struct
761 * @see #usearch_first
762 * @stable ICU 2.4
763 */
764 U_STABLE void U_EXPORT2 usearch_reset(UStringSearch *strsrch);
765 
766 #ifndef U_HIDE_INTERNAL_API
767 /**
768   *  Simple forward search for the pattern, starting at a specified index,
769   *     and using using a default set search options.
770   *
771   *  This is an experimental function, and is not an official part of the
772   *      ICU API.
773   *
774   *  The collator options, such as UCOL_STRENGTH and UCOL_NORMALIZTION, are honored.
775   *
776   *  The UStringSearch options USEARCH_CANONICAL_MATCH, USEARCH_OVERLAP and
777   *  any Break Iterator are ignored.
778   *
779   *  Matches obey the following constraints:
780   *
781   *      Characters at the start or end positions of a match that are ignorable
782   *      for collation are not included as part of the match, unless they
783   *      are part of a combining sequence, as described below.
784   *
785   *      A match will not include a partial combining sequence.  Combining
786   *      character sequences  are considered to be  inseperable units,
787   *      and either match the pattern completely, or are considered to not match
788   *      at all.  Thus, for example, an A followed a combining accent mark will
789   *      not be found when searching for a plain (unaccented) A.   (unless
790   *      the collation strength has been set to ignore all accents).
791   *
792   *      When beginning a search, the initial starting position, startIdx,
793   *      is assumed to be an acceptable match boundary with respect to
794   *      combining characters.  A combining sequence that spans across the
795   *      starting point will not supress a match beginning at startIdx.
796   *
797   *      Characters that expand to multiple collation elements
798   *      (German sharp-S becoming &#39;ss&#39;, or the composed forms of accented
799   *      characters, for example) also must match completely.
800   *      Searching for a single &#39;s&#39; in a string containing only a sharp-s will
801   *      find no match.
802   *
803   *
804   *  @param strsrch    the UStringSearch struct, which references both
805   *                    the text to be searched  and the pattern being sought.
806   *  @param startIdx   The index into the text to begin the search.
807   *  @param matchStart An out parameter, the starting index of the matched text.
808   *                    This parameter may be NULL.
809   *                    A value of -1 will be returned if no match was found.
810   *  @param matchLimit Out parameter, the index of the first position following the matched text.
811   *                    The matchLimit will be at a suitable position for beginning a subsequent search
812   *                    in the input text.
813   *                    This parameter may be NULL.
814   *                    A value of -1 will be returned if no match was found.
815   *
816   *  @param status     Report any errors.  Note that no match found is not an error.
817   *  @return           TRUE if a match was found, FALSE otherwise.
818   *
819   *  @internal
820   */
821 U_INTERNAL UBool U_EXPORT2 usearch_search(UStringSearch *strsrch,
822                                           int32_t        startIdx,
823                                           int32_t        *matchStart,
824                                           int32_t        *matchLimit,
825                                           UErrorCode     *status);
826 
827 /**
828   *  Simple backwards search for the pattern, starting at a specified index,
829   *     and using using a default set search options.
830   *
831   *  This is an experimental function, and is not an official part of the
832   *      ICU API.
833   *
834   *  The collator options, such as UCOL_STRENGTH and UCOL_NORMALIZTION, are honored.
835   *
836   *  The UStringSearch options USEARCH_CANONICAL_MATCH, USEARCH_OVERLAP and
837   *  any Break Iterator are ignored.
838   *
839   *  Matches obey the following constraints:
840   *
841   *      Characters at the start or end positions of a match that are ignorable
842   *      for collation are not included as part of the match, unless they
843   *      are part of a combining sequence, as described below.
844   *
845   *      A match will not include a partial combining sequence.  Combining
846   *      character sequences  are considered to be  inseperable units,
847   *      and either match the pattern completely, or are considered to not match
848   *      at all.  Thus, for example, an A followed a combining accent mark will
849   *      not be found when searching for a plain (unaccented) A.   (unless
850   *      the collation strength has been set to ignore all accents).
851   *
852   *      When beginning a search, the initial starting position, startIdx,
853   *      is assumed to be an acceptable match boundary with respect to
854   *      combining characters.  A combining sequence that spans across the
855   *      starting point will not supress a match beginning at startIdx.
856   *
857   *      Characters that expand to multiple collation elements
858   *      (German sharp-S becoming &#39;ss&#39;, or the composed forms of accented
859   *      characters, for example) also must match completely.
860   *      Searching for a single &#39;s&#39; in a string containing only a sharp-s will
861   *      find no match.
862   *
863   *
864   *  @param strsrch    the UStringSearch struct, which references both
865   *                    the text to be searched  and the pattern being sought.
866   *  @param startIdx   The index into the text to begin the search.
867   *  @param matchStart An out parameter, the starting index of the matched text.
868   *                    This parameter may be NULL.
869   *                    A value of -1 will be returned if no match was found.
870   *  @param matchLimit Out parameter, the index of the first position following the matched text.
871   *                    The matchLimit will be at a suitable position for beginning a subsequent search
872   *                    in the input text.
873   *                    This parameter may be NULL.
874   *                    A value of -1 will be returned if no match was found.
875   *
876   *  @param status     Report any errors.  Note that no match found is not an error.
877   *  @return           TRUE if a match was found, FALSE otherwise.
878   *
879   *  @internal
880   */
881 U_INTERNAL UBool U_EXPORT2 usearch_searchBackwards(UStringSearch *strsrch,
882                                                    int32_t        startIdx,
883                                                    int32_t        *matchStart,
884                                                    int32_t        *matchLimit,
885                                                    UErrorCode     *status);
886 #endif  /* U_HIDE_INTERNAL_API */
887 
888 #endif /* #if !UCONFIG_NO_COLLATION  &amp;&amp; !UCONFIG_NO_BREAK_ITERATION */
889 
890 #endif
    </pre>
  </body>
</html>