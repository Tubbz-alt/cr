<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/regexcmp.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="rbtz.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="regexcst.txt.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/regexcmp.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #include &quot;unicode/utf.h&quot;
  #include &quot;unicode/utf16.h&quot;
  #include &quot;patternprops.h&quot;
  #include &quot;putilimp.h&quot;
  #include &quot;cmemory.h&quot;
<span class="line-added">+ #include &quot;cstr.h&quot;</span>
  #include &quot;cstring.h&quot;
  #include &quot;uvectr32.h&quot;
  #include &quot;uvectr64.h&quot;
  #include &quot;uassert.h&quot;
  #include &quot;uinvchar.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1462,11 ***</span>
              case 0x75: /* &#39;u&#39; */   bit = 0; /* Unicode casing */  break;
              case 0x77: /* &#39;w&#39; */   bit = UREGEX_UWORD;            break;
              case 0x78: /* &#39;x&#39; */   bit = UREGEX_COMMENTS;         break;
              case 0x2d: /* &#39;-&#39; */   fSetModeFlag = FALSE;          break;
              default:
<span class="line-modified">!                 U_ASSERT(FALSE);   // Should never happen.  Other chars are filtered out</span>
                                     // by the scanner.
              }
              if (fSetModeFlag) {
                  fNewModeFlags |= bit;
              } else {
<span class="line-new-header">--- 1463,11 ---</span>
              case 0x75: /* &#39;u&#39; */   bit = 0; /* Unicode casing */  break;
              case 0x77: /* &#39;w&#39; */   bit = UREGEX_UWORD;            break;
              case 0x78: /* &#39;x&#39; */   bit = UREGEX_COMMENTS;         break;
              case 0x2d: /* &#39;-&#39; */   fSetModeFlag = FALSE;          break;
              default:
<span class="line-modified">!                 UPRV_UNREACHABLE;   // Should never happen.  Other chars are filtered out</span>
                                     // by the scanner.
              }
              if (fSetModeFlag) {
                  fNewModeFlags |= bit;
              } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1837,13 ***</span>
          s-&gt;add(fLastSetLiteral, fC.fChar);
          break;
          }
  
      default:
<span class="line-modified">!         U_ASSERT(FALSE);</span>
<span class="line-removed">-         error(U_REGEX_INTERNAL_ERROR);</span>
<span class="line-removed">-         break;</span>
      }
  
      if (U_FAILURE(*fStatus)) {
          returnVal = FALSE;
      }
<span class="line-new-header">--- 1838,11 ---</span>
          s-&gt;add(fLastSetLiteral, fC.fChar);
          break;
          }
  
      default:
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
      }
  
      if (U_FAILURE(*fStatus)) {
          returnVal = FALSE;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1946,29 ***</span>
  int32_t RegexCompile::buildOp(int32_t type, int32_t val) {
      if (U_FAILURE(*fStatus)) {
          return 0;
      }
      if (type &lt; 0 || type &gt; 255) {
<span class="line-modified">!         U_ASSERT(FALSE);</span>
<span class="line-removed">-         error(U_REGEX_INTERNAL_ERROR);</span>
<span class="line-removed">-         type = URX_RESERVED_OP;</span>
      }
      if (val &gt; 0x00ffffff) {
<span class="line-modified">!         U_ASSERT(FALSE);</span>
<span class="line-removed">-         error(U_REGEX_INTERNAL_ERROR);</span>
<span class="line-removed">-         val = 0;</span>
      }
      if (val &lt; 0) {
          if (!(type == URX_RESERVED_OP_N || type == URX_RESERVED_OP)) {
<span class="line-modified">!             U_ASSERT(FALSE);</span>
<span class="line-removed">-             error(U_REGEX_INTERNAL_ERROR);</span>
<span class="line-removed">-             return -1;</span>
          }
          if (URX_TYPE(val) != 0xff) {
<span class="line-modified">!             U_ASSERT(FALSE);</span>
<span class="line-removed">-             error(U_REGEX_INTERNAL_ERROR);</span>
<span class="line-removed">-             return -1;</span>
          }
          type = URX_RESERVED_OP_N;
      }
      return (type &lt;&lt; 24) | val;
  }
<span class="line-new-header">--- 1945,21 ---</span>
  int32_t RegexCompile::buildOp(int32_t type, int32_t val) {
      if (U_FAILURE(*fStatus)) {
          return 0;
      }
      if (type &lt; 0 || type &gt; 255) {
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
      }
      if (val &gt; 0x00ffffff) {
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
      }
      if (val &lt; 0) {
          if (!(type == URX_RESERVED_OP_N || type == URX_RESERVED_OP)) {
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
          }
          if (URX_TYPE(val) != 0xff) {
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
          }
          type = URX_RESERVED_OP_N;
      }
      return (type &lt;&lt; 24) | val;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2292,10 ***</span>
<span class="line-new-header">--- 2283,17 ---</span>
              }
              if (maxML == INT32_MAX) {
                  error(U_REGEX_LOOK_BEHIND_LIMIT);
                  break;
              }
<span class="line-added">+             if (minML == INT32_MAX &amp;&amp; maxML == 0) {</span>
<span class="line-added">+                 // This condition happens when no match is possible, such as with a</span>
<span class="line-added">+                 // [set] expression containing no elements.</span>
<span class="line-added">+                 // In principle, the generated code to evaluate the expression could be deleted,</span>
<span class="line-added">+                 // but it&#39;s probably not worth the complication.</span>
<span class="line-added">+                 minML = 0;</span>
<span class="line-added">+             }</span>
              U_ASSERT(minML &lt;= maxML);
  
              // Insert the min and max match len bounds into the URX_LB_CONT op that
              //  appears at the top of the look-behind block, at location fMatchOpenParen+1
              fRXPat-&gt;fCompiledPat-&gt;setElementAt(minML,  fMatchOpenParen-2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2328,10 ***</span>
<span class="line-new-header">--- 2326,18 ---</span>
              }
              if (maxML == INT32_MAX) {
                  error(U_REGEX_LOOK_BEHIND_LIMIT);
                  break;
              }
<span class="line-added">+             if (minML == INT32_MAX &amp;&amp; maxML == 0) {</span>
<span class="line-added">+                 // This condition happens when no match is possible, such as with a</span>
<span class="line-added">+                 // [set] expression containing no elements.</span>
<span class="line-added">+                 // In principle, the generated code to evaluate the expression could be deleted,</span>
<span class="line-added">+                 // but it&#39;s probably not worth the complication.</span>
<span class="line-added">+                 minML = 0;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              U_ASSERT(minML &lt;= maxML);
  
              // Insert the min and max match len bounds into the URX_LB_CONT op that
              //  appears at the top of the look-behind block, at location fMatchOpenParen+1
              fRXPat-&gt;fCompiledPat-&gt;setElementAt(minML,  fMatchOpenParen-3);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2345,11 ***</span>
          break;
  
  
  
      default:
<span class="line-modified">!         U_ASSERT(FALSE);</span>
      }
  
      // remember the next location in the compiled pattern.
      // The compilation of Quantifiers will look at this to see whether its looping
      //   over a parenthesized block or a single item
<span class="line-new-header">--- 2351,11 ---</span>
          break;
  
  
  
      default:
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
      }
  
      // remember the next location in the compiled pattern.
      // The compilation of Quantifiers will look at this to see whether its looping
      //   over a parenthesized block or a single item
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2605,12 ***</span>
  
  // End of machine generated data.
  
      if (c &lt; UCHAR_MIN_VALUE || c &gt; UCHAR_MAX_VALUE) {
          // This function should never be called with an invalid input character.
<span class="line-modified">!         U_ASSERT(FALSE);</span>
<span class="line-removed">-         starterChars-&gt;clear();</span>
      } else if (u_hasBinaryProperty(c, UCHAR_CASE_SENSITIVE)) {
          UChar32 caseFoldedC  = u_foldCase(c, U_FOLD_CASE_DEFAULT);
          starterChars-&gt;set(caseFoldedC, caseFoldedC);
  
          int32_t i;
<span class="line-new-header">--- 2611,11 ---</span>
  
  // End of machine generated data.
  
      if (c &lt; UCHAR_MIN_VALUE || c &gt; UCHAR_MAX_VALUE) {
          // This function should never be called with an invalid input character.
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
      } else if (u_hasBinaryProperty(c, UCHAR_CASE_SENSITIVE)) {
          UChar32 caseFoldedC  = u_foldCase(c, U_FOLD_CASE_DEFAULT);
          starterChars-&gt;set(caseFoldedC, caseFoldedC);
  
          int32_t i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3100,17 ***</span>
          case URX_LA_END:
          case URX_LB_CONT:
          case URX_LB_END:
          case URX_LBN_CONT:
          case URX_LBN_END:
<span class="line-modified">!             U_ASSERT(FALSE);     // Shouldn&#39;t get here.  These ops should be</span>
                                   //  consumed by the scan in URX_LA_START and LB_START
<span class="line-removed">- </span>
<span class="line-removed">-             break;</span>
<span class="line-removed">- </span>
          default:
<span class="line-modified">!             U_ASSERT(FALSE);</span>
              }
  
          }
  
  
<span class="line-new-header">--- 3105,14 ---</span>
          case URX_LA_END:
          case URX_LB_CONT:
          case URX_LB_END:
          case URX_LBN_CONT:
          case URX_LBN_END:
<span class="line-modified">!             UPRV_UNREACHABLE;     // Shouldn&#39;t get here.  These ops should be</span>
                                   //  consumed by the scan in URX_LA_START and LB_START
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
              }
  
          }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3426,11 ***</span>
              // Only come here if the matching URX_LA_START or URX_LB_START was not in the
              //   range being sized, which happens when measuring size of look-behind blocks.
              break;
  
          default:
<span class="line-modified">!             U_ASSERT(FALSE);</span>
              }
  
          }
  
      // We have finished walking through the ops.  Check whether some forward jump
<span class="line-new-header">--- 3428,11 ---</span>
              // Only come here if the matching URX_LA_START or URX_LB_START was not in the
              //   range being sized, which happens when measuring size of look-behind blocks.
              break;
  
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
              }
  
          }
  
      // We have finished walking through the ops.  Check whether some forward jump
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3670,12 ***</span>
  
          case URX_CTR_LOOP:
          case URX_CTR_LOOP_NG:
              // These opcodes will be skipped over by code for URX_CRT_INIT.
              // We shouldn&#39;t encounter them here.
<span class="line-modified">!             U_ASSERT(FALSE);</span>
<span class="line-removed">-             break;</span>
  
          case URX_LOOP_SR_I:
          case URX_LOOP_DOT_I:
          case URX_LOOP_C:
              // For anything to do with loops, make the match length unbounded.
<span class="line-new-header">--- 3672,11 ---</span>
  
          case URX_CTR_LOOP:
          case URX_CTR_LOOP_NG:
              // These opcodes will be skipped over by code for URX_CRT_INIT.
              // We shouldn&#39;t encounter them here.
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
  
          case URX_LOOP_SR_I:
          case URX_LOOP_DOT_I:
          case URX_LOOP_C:
              // For anything to do with loops, make the match length unbounded.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3691,12 ***</span>
              //  but good enough for now.
              break;
  
              // End of look-ahead ops should always be consumed by the processing at
              //  the URX_LA_START op.
<span class="line-modified">!             // U_ASSERT(FALSE);</span>
<span class="line-removed">-             // break;</span>
  
          case URX_LB_START:
              {
                  // Look-behind.  Scan forward until the matching look-around end,
                  //   without processing the look-behind block.
<span class="line-new-header">--- 3692,11 ---</span>
              //  but good enough for now.
              break;
  
              // End of look-ahead ops should always be consumed by the processing at
              //  the URX_LA_START op.
<span class="line-modified">!             // UPRV_UNREACHABLE;</span>
  
          case URX_LB_START:
              {
                  // Look-behind.  Scan forward until the matching look-around end,
                  //   without processing the look-behind block.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3717,11 ***</span>
                  }
              }
              break;
  
          default:
<span class="line-modified">!             U_ASSERT(FALSE);</span>
          }
  
  
          if (currentLen == INT32_MAX) {
              //  The maximum length is unbounded.
<span class="line-new-header">--- 3717,11 ---</span>
                  }
              }
              break;
  
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
          }
  
  
          if (currentLen == INT32_MAX) {
              //  The maximum length is unbounded.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3872,12 ***</span>
              dst++;
              break;
  
          default:
              // Some op is unaccounted for.
<span class="line-modified">!             U_ASSERT(FALSE);</span>
<span class="line-removed">-             error(U_REGEX_INTERNAL_ERROR);</span>
          }
      }
  
      fRXPat-&gt;fCompiledPat-&gt;setSize(dst);
  }
<span class="line-new-header">--- 3872,11 ---</span>
              dst++;
              break;
  
          default:
              // Some op is unaccounted for.
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
          }
      }
  
      fRXPat-&gt;fCompiledPat-&gt;setSize(dst);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3890,11 ***</span>
  //  Error         Report a rule parse error.
  //                Only report it if no previous error has been recorded.
  //
  //------------------------------------------------------------------------------
  void RegexCompile::error(UErrorCode e) {
<span class="line-modified">!     if (U_SUCCESS(*fStatus)) {</span>
          *fStatus = e;
          // Hmm. fParseErr (UParseError) line &amp; offset fields are int32_t in public
          // API (see common/unicode/parseerr.h), while fLineNum and fCharNum are
          // int64_t. If the values of the latter are out of range for the former,
          // set them to the appropriate &quot;field not supported&quot; values.
<span class="line-new-header">--- 3889,11 ---</span>
  //  Error         Report a rule parse error.
  //                Only report it if no previous error has been recorded.
  //
  //------------------------------------------------------------------------------
  void RegexCompile::error(UErrorCode e) {
<span class="line-modified">!     if (U_SUCCESS(*fStatus) || e == U_MEMORY_ALLOCATION_ERROR) {</span>
          *fStatus = e;
          // Hmm. fParseErr (UParseError) line &amp; offset fields are int32_t in public
          // API (see common/unicode/parseerr.h), while fLineNum and fCharNum are
          // int64_t. If the values of the latter are out of range for the former,
          // set them to the appropriate &quot;field not supported&quot; values.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4009,22 ***</span>
  //                out comments and processing some backslash character escapes.
  //                The rest of the pattern grammar is handled at the next level up.
  //
  //------------------------------------------------------------------------------
  void RegexCompile::nextChar(RegexPatternChar &amp;c) {
<span class="line-modified">! </span>
      fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat-&gt;fPattern);
      c.fChar    = nextCharLL();
      c.fQuoted  = FALSE;
  
      if (fQuoteMode) {
          c.fQuoted = TRUE;
          if ((c.fChar==chBackSlash &amp;&amp; peekCharLL()==chE &amp;&amp; ((fModeFlags &amp; UREGEX_LITERAL) == 0)) ||
              c.fChar == (UChar32)-1) {
              fQuoteMode = FALSE;  //  Exit quote mode,
              nextCharLL();        // discard the E
<span class="line-modified">!             nextChar(c);         // recurse to get the real next char</span>
          }
      }
      else if (fInBackslashQuote) {
          // The current character immediately follows a &#39;\&#39;
          // Don&#39;t check for any further escapes, just return it as-is.
<span class="line-new-header">--- 4008,24 ---</span>
  //                out comments and processing some backslash character escapes.
  //                The rest of the pattern grammar is handled at the next level up.
  //
  //------------------------------------------------------------------------------
  void RegexCompile::nextChar(RegexPatternChar &amp;c) {
<span class="line-modified">!   tailRecursion:</span>
      fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat-&gt;fPattern);
      c.fChar    = nextCharLL();
      c.fQuoted  = FALSE;
  
      if (fQuoteMode) {
          c.fQuoted = TRUE;
          if ((c.fChar==chBackSlash &amp;&amp; peekCharLL()==chE &amp;&amp; ((fModeFlags &amp; UREGEX_LITERAL) == 0)) ||
              c.fChar == (UChar32)-1) {
              fQuoteMode = FALSE;  //  Exit quote mode,
              nextCharLL();        // discard the E
<span class="line-modified">!             // nextChar(c);      // recurse to get the real next char</span>
<span class="line-added">+             goto tailRecursion;  // Note: fuzz testing produced testcases that</span>
<span class="line-added">+                                  //       resulted in stack overflow here.</span>
          }
      }
      else if (fInBackslashQuote) {
          // The current character immediately follows a &#39;\&#39;
          // Don&#39;t check for any further escapes, just return it as-is.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4138,12 ***</span>
                  c.fQuoted = TRUE;
              }
              else if (peekCharLL() == chQ) {
                  //  &quot;\Q&quot;  enter quote mode, which will continue until &quot;\E&quot;
                  fQuoteMode = TRUE;
<span class="line-modified">!                 nextCharLL();       // discard the &#39;Q&#39;.</span>
<span class="line-modified">!                 nextChar(c);        // recurse to get the real next char.</span>
              }
              else
              {
                  // We are in a &#39;\&#39; escape that will be handled by the state table scanner.
                  // Just return the backslash, but remember that the following char is to
<span class="line-new-header">--- 4139,14 ---</span>
                  c.fQuoted = TRUE;
              }
              else if (peekCharLL() == chQ) {
                  //  &quot;\Q&quot;  enter quote mode, which will continue until &quot;\E&quot;
                  fQuoteMode = TRUE;
<span class="line-modified">!                 nextCharLL();        // discard the &#39;Q&#39;.</span>
<span class="line-modified">!                 // nextChar(c);      // recurse to get the real next char.</span>
<span class="line-added">+                 goto tailRecursion;  // Note: fuzz testing produced test cases that</span>
<span class="line-added">+                 //                            resulted in stack overflow here.</span>
              }
              else
              {
                  // We are in a &#39;\&#39; escape that will be handled by the state table scanner.
                  // Just return the backslash, but remember that the following char is to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4368,213 ***</span>
  //  Create a Unicode Set from a Unicode Property expression.
  //     This is common code underlying both \p{...} ane [:...:] expressions.
  //     Includes trying the Java &quot;properties&quot; that aren&#39;t supported as
  //     normal ICU UnicodeSet properties
  //
<span class="line-removed">- static const UChar posSetPrefix[] = {0x5b, 0x5c, 0x70, 0x7b, 0}; // &quot;[\p{&quot;</span>
<span class="line-removed">- static const UChar negSetPrefix[] = {0x5b, 0x5c, 0x50, 0x7b, 0}; // &quot;[\P{&quot;</span>
  UnicodeSet *RegexCompile::createSetForProperty(const UnicodeString &amp;propName, UBool negated) {
<span class="line-removed">-     UnicodeString   setExpr;</span>
<span class="line-removed">-     UnicodeSet      *set;</span>
<span class="line-removed">-     uint32_t        usetFlags = 0;</span>
  
      if (U_FAILURE(*fStatus)) {
<span class="line-modified">!         return NULL;</span>
      }
  
<span class="line-modified">!     //</span>
<span class="line-modified">!     //  First try the property as we received it</span>
<span class="line-modified">!     //</span>
<span class="line-modified">!     if (negated) {</span>
<span class="line-modified">!         setExpr.append(negSetPrefix, -1);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         setExpr.append(posSetPrefix, -1);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     setExpr.append(propName);</span>
<span class="line-modified">!     setExpr.append(chRBrace);</span>
<span class="line-modified">!     setExpr.append(chRBracket);</span>
<span class="line-removed">-     if (fModeFlags &amp; UREGEX_CASE_INSENSITIVE) {</span>
<span class="line-removed">-         usetFlags |= USET_CASE_INSENSITIVE;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     set = new UnicodeSet(setExpr, usetFlags, NULL, *fStatus);</span>
<span class="line-removed">-     if (U_SUCCESS(*fStatus)) {</span>
<span class="line-removed">-        return set;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     delete set;</span>
<span class="line-removed">-     set = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     //  The property as it was didn&#39;t work.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     //  Do [:word:]. It is not recognized as a property by UnicodeSet.  &quot;word&quot; not standard POSIX</span>
<span class="line-removed">-     //     or standard Java, but many other regular expression packages do recognize it.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (propName.caseCompare(UNICODE_STRING_SIMPLE(&quot;word&quot;), 0) == 0) {</span>
<span class="line-removed">-         *fStatus = U_ZERO_ERROR;</span>
<span class="line-removed">-         set = new UnicodeSet(*(fRXPat-&gt;fStaticSets[URX_ISWORD_SET]));</span>
<span class="line-removed">-         if (set == NULL) {</span>
<span class="line-removed">-             *fStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">-             return set;</span>
          }
<span class="line-modified">!         if (negated) {</span>
<span class="line-modified">!             set-&gt;complement();</span>
          }
<span class="line-removed">-         return set;</span>
<span class="line-removed">-     }</span>
  
  
<span class="line-modified">!     //    Do Java fixes -</span>
<span class="line-modified">!     //       InGreek -&gt; InGreek or Coptic, that being the official Unicode name for that block.</span>
<span class="line-modified">!     //       InCombiningMarksforSymbols -&gt; InCombiningDiacriticalMarksforSymbols.</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     //       Note on Spaces:  either &quot;InCombiningMarksForSymbols&quot; or &quot;InCombining Marks for Symbols&quot;</span>
<span class="line-removed">-     //                        is accepted by Java.  The property part of the name is compared</span>
<span class="line-removed">-     //                        case-insenstively.  The spaces must be exactly as shown, either</span>
<span class="line-removed">-     //                        all there, or all omitted, with exactly one at each position</span>
<span class="line-removed">-     //                        if they are present.  From checking against JDK 1.6</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     //       This code should be removed when ICU properties support the Java  compatibility names</span>
<span class="line-removed">-     //          (ICU 4.0?)</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     UnicodeString mPropName = propName;</span>
<span class="line-removed">-     if (mPropName.caseCompare(UNICODE_STRING_SIMPLE(&quot;InGreek&quot;), 0) == 0) {</span>
<span class="line-removed">-         mPropName = UNICODE_STRING_SIMPLE(&quot;InGreek and Coptic&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (mPropName.caseCompare(UNICODE_STRING_SIMPLE(&quot;InCombining Marks for Symbols&quot;), 0) == 0 ||</span>
<span class="line-removed">-         mPropName.caseCompare(UNICODE_STRING_SIMPLE(&quot;InCombiningMarksforSymbols&quot;), 0) == 0) {</span>
<span class="line-removed">-         mPropName = UNICODE_STRING_SIMPLE(&quot;InCombining Diacritical Marks for Symbols&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;all&quot;)) == 0) {</span>
<span class="line-removed">-         mPropName = UNICODE_STRING_SIMPLE(&quot;javaValidCodePoint&quot;);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     //    See if the property looks like a Java &quot;InBlockName&quot;, which</span>
<span class="line-modified">!     //    we will recast as &quot;Block=BlockName&quot;</span>
<span class="line-modified">!     //</span>
<span class="line-modified">!     if (mPropName.startsWith(u&quot;In&quot;, 2) &amp;&amp; propName.length()&gt;=3) {</span>
<span class="line-modified">!         setExpr.truncate(4);   // Leaves &quot;[\p{&quot;, or &quot;[\P{&quot;</span>
<span class="line-modified">!         setExpr.append(u&quot;Block=&quot;, -1);</span>
<span class="line-modified">!         setExpr.append(UnicodeString(mPropName, 2));  // Property with the leading &quot;In&quot; removed.</span>
<span class="line-modified">!         setExpr.append(chRBrace);</span>
<span class="line-removed">-         setExpr.append(chRBracket);</span>
<span class="line-removed">-         *fStatus = U_ZERO_ERROR;</span>
<span class="line-removed">-         set = new UnicodeSet(setExpr, usetFlags, NULL, *fStatus);</span>
<span class="line-removed">-         if (U_SUCCESS(*fStatus)) {</span>
<span class="line-removed">-             return set;</span>
          }
<span class="line-removed">-         delete set;</span>
<span class="line-removed">-         set = NULL;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (propName.startsWith(UNICODE_STRING_SIMPLE(&quot;java&quot;)) ||</span>
<span class="line-modified">!         propName.compare(UNICODE_STRING_SIMPLE(&quot;all&quot;)) == 0)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="line-removed">-         //setExpr.remove();</span>
<span class="line-removed">-         set = new UnicodeSet();</span>
<span class="line-removed">-         //</span>
<span class="line-removed">-         //  Try the various Java specific properties.</span>
<span class="line-removed">-         //   These all begin with &quot;java&quot;</span>
          //
<span class="line-modified">!         if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaDefined&quot;)) == 0) {</span>
<span class="line-modified">!             addCategory(set, U_GC_CN_MASK, localStatus);</span>
<span class="line-modified">!             set-&gt;complement();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaDigit&quot;)) == 0) {</span>
<span class="line-modified">!             addCategory(set, U_GC_ND_MASK, localStatus);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaIdentifierIgnorable&quot;)) == 0) {</span>
<span class="line-modified">!             addIdentifierIgnorable(set, localStatus);</span>
<span class="line-modified">!         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaISOControl&quot;)) == 0) {</span>
<span class="line-removed">-             set-&gt;add(0, 0x1F).add(0x7F, 0x9F);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaJavaIdentifierPart&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_SC_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_PC_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_ND_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_NL_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_MC_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_MN_MASK, localStatus);</span>
<span class="line-removed">-             addIdentifierIgnorable(set, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaJavaIdentifierStart&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_NL_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_SC_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_PC_MASK, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaLetter&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaLetterOrDigit&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_ND_MASK, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaLowerCase&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_LL_MASK, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaMirrored&quot;)) == 0) {</span>
<span class="line-removed">-             set-&gt;applyIntPropertyValue(UCHAR_BIDI_MIRRORED, 1, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaSpaceChar&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_Z_MASK, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaSupplementaryCodePoint&quot;)) == 0) {</span>
<span class="line-removed">-             set-&gt;add(0x10000, UnicodeSet::MAX_VALUE);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaTitleCase&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_LT_MASK, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaUnicodeIdentifierStart&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_NL_MASK, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaUnicodeIdentifierPart&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_PC_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_ND_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_NL_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_MC_MASK, localStatus);</span>
<span class="line-removed">-             addCategory(set, U_GC_MN_MASK, localStatus);</span>
<span class="line-removed">-             addIdentifierIgnorable(set, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaUpperCase&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_LU_MASK, localStatus);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaValidCodePoint&quot;)) == 0) {</span>
<span class="line-removed">-             set-&gt;add(0, UnicodeSet::MAX_VALUE);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaWhitespace&quot;)) == 0) {</span>
<span class="line-removed">-             addCategory(set, U_GC_Z_MASK, localStatus);</span>
<span class="line-removed">-             set-&gt;removeAll(UnicodeSet().add(0xa0).add(0x2007).add(0x202f));</span>
<span class="line-removed">-             set-&gt;add(9, 0x0d).add(0x1c, 0x1f);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;all&quot;)) == 0) {</span>
<span class="line-removed">-             set-&gt;add(0, UnicodeSet::MAX_VALUE);</span>
          }
  
<span class="line-modified">!         if (U_SUCCESS(localStatus) &amp;&amp; !set-&gt;isEmpty()) {</span>
<span class="line-modified">!             *fStatus = U_ZERO_ERROR;</span>
<span class="line-modified">!             if (usetFlags &amp; USET_CASE_INSENSITIVE) {</span>
                  set-&gt;closeOver(USET_CASE_INSENSITIVE);
              }
<span class="line-modified">!             if (negated) {</span>
                  set-&gt;complement();
              }
<span class="line-modified">!             return set;</span>
          }
<span class="line-modified">!         delete set;</span>
<span class="line-modified">!         set = NULL;</span>
      }
<span class="line-removed">-     error(*fStatus);</span>
<span class="line-removed">-     return NULL;</span>
  }
  
  
<span class="line-removed">- </span>
  //
  //  SetEval   Part of the evaluation of [set expressions].
  //            Perform any pending (stacked) operations with precedence
  //            equal or greater to that of the next operator encountered
  //            in the expression.
<span class="line-new-header">--- 4371,213 ---</span>
  //  Create a Unicode Set from a Unicode Property expression.
  //     This is common code underlying both \p{...} ane [:...:] expressions.
  //     Includes trying the Java &quot;properties&quot; that aren&#39;t supported as
  //     normal ICU UnicodeSet properties
  //
  UnicodeSet *RegexCompile::createSetForProperty(const UnicodeString &amp;propName, UBool negated) {
  
      if (U_FAILURE(*fStatus)) {
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-added">+     LocalPointer&lt;UnicodeSet&gt; set;</span>
<span class="line-added">+     UErrorCode status = U_ZERO_ERROR;</span>
  
<span class="line-modified">!     do {      // non-loop, exists to allow breaks from the block.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         //  First try the property as we received it</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         UnicodeString   setExpr;</span>
<span class="line-modified">!         uint32_t        usetFlags = 0;</span>
<span class="line-modified">!         setExpr.append(u&quot;[\\p{&quot;, -1);</span>
<span class="line-modified">!         setExpr.append(propName);</span>
<span class="line-modified">!         setExpr.append(u&quot;}]&quot;, -1);</span>
<span class="line-modified">!         if (fModeFlags &amp; UREGEX_CASE_INSENSITIVE) {</span>
<span class="line-modified">!             usetFlags |= USET_CASE_INSENSITIVE;</span>
          }
<span class="line-modified">!         set.adoptInsteadAndCheckErrorCode(new UnicodeSet(setExpr, usetFlags, NULL, status), status);</span>
<span class="line-modified">!         if (U_SUCCESS(status) || status == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">+             break;</span>
          }
  
<span class="line-added">+         //</span>
<span class="line-added">+         //  The incoming property wasn&#39;t directly recognized by ICU.</span>
  
<span class="line-modified">!         //  Check [:word:] and [:all:]. These are not recognized as a properties by ICU UnicodeSet.</span>
<span class="line-modified">!         //     Java accepts &#39;word&#39; with mixed case.</span>
<span class="line-modified">!         //     Java accepts &#39;all&#39; only in all lower case.</span>
  
<span class="line-modified">!         status = U_ZERO_ERROR;</span>
<span class="line-modified">!         if (propName.caseCompare(u&quot;word&quot;, -1, 0) == 0) {</span>
<span class="line-modified">!             set.adoptInsteadAndCheckErrorCode(new UnicodeSet(*(fRXPat-&gt;fStaticSets[URX_ISWORD_SET])), status);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (propName.compare(u&quot;all&quot;, -1) == 0) {</span>
<span class="line-modified">!             set.adoptInsteadAndCheckErrorCode(new UnicodeSet(0, 0x10ffff), status);</span>
<span class="line-modified">!             break;</span>
          }
  
<span class="line-modified">! </span>
<span class="line-modified">!         //    Do Java InBlock expressions</span>
          //
<span class="line-modified">!         UnicodeString mPropName = propName;</span>
<span class="line-modified">!         if (mPropName.startsWith(u&quot;In&quot;, 2) &amp;&amp; mPropName.length() &gt;= 3) {</span>
<span class="line-modified">!             status = U_ZERO_ERROR;</span>
<span class="line-modified">!             set.adoptInsteadAndCheckErrorCode(new UnicodeSet(), status);</span>
<span class="line-modified">!             if (U_FAILURE(status)) {</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             UnicodeString blockName(mPropName, 2);  // Property with the leading &quot;In&quot; removed.</span>
<span class="line-modified">!             set-&gt;applyPropertyAlias(UnicodeString(u&quot;Block&quot;), blockName, status);</span>
<span class="line-modified">!             break;</span>
          }
  
<span class="line-modified">!         //  Check for the Java form &quot;IsBooleanPropertyValue&quot;, which we will recast</span>
<span class="line-modified">!         //  as &quot;BooleanPropertyValue&quot;. The property value can be either a</span>
<span class="line-modified">!         //  a General Category or a Script Name.</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (propName.startsWith(u&quot;Is&quot;, 2) &amp;&amp; propName.length()&gt;=3) {</span>
<span class="line-added">+             mPropName.remove(0, 2);      // Strip the &quot;Is&quot;</span>
<span class="line-added">+             if (mPropName.indexOf(u&#39;=&#39;) &gt;= 0) {</span>
<span class="line-added">+                 // Reject any &quot;Is...&quot; property expression containing an &#39;=&#39;, that is,</span>
<span class="line-added">+                 // any non-binary property expression.</span>
<span class="line-added">+                 status = U_REGEX_PROPERTY_SYNTAX;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (mPropName.caseCompare(u&quot;assigned&quot;, -1, 0) == 0) {</span>
<span class="line-added">+                 mPropName.setTo(u&quot;unassigned&quot;, -1);</span>
<span class="line-added">+                 negated = !negated;</span>
<span class="line-added">+             } else if (mPropName.caseCompare(u&quot;TitleCase&quot;, -1, 0) == 0) {</span>
<span class="line-added">+                 mPropName.setTo(u&quot;Titlecase_Letter&quot;, -1);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             mPropName.insert(0, u&quot;[\\p{&quot;, -1);</span>
<span class="line-added">+             mPropName.append(u&quot;}]&quot;, -1);</span>
<span class="line-added">+             set.adoptInsteadAndCheckErrorCode(new UnicodeSet(mPropName, *fStatus), status);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (U_SUCCESS(status) &amp;&amp; !set-&gt;isEmpty() &amp;&amp; (usetFlags &amp; USET_CASE_INSENSITIVE)) {</span>
                  set-&gt;closeOver(USET_CASE_INSENSITIVE);
              }
<span class="line-modified">!             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (propName.startsWith(u&quot;java&quot;, -1)) {</span>
<span class="line-added">+             status = U_ZERO_ERROR;</span>
<span class="line-added">+             set.adoptInsteadAndCheckErrorCode(new UnicodeSet(), status);</span>
<span class="line-added">+             if (U_FAILURE(status)) {</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             //</span>
<span class="line-added">+             //  Try the various Java specific properties.</span>
<span class="line-added">+             //   These all begin with &quot;java&quot;</span>
<span class="line-added">+             //</span>
<span class="line-added">+             if (propName.compare(u&quot;javaDefined&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_CN_MASK, status);</span>
                  set-&gt;complement();
              }
<span class="line-modified">!             else if (propName.compare(u&quot;javaDigit&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_ND_MASK, status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaIdentifierIgnorable&quot;, -1) == 0) {</span>
<span class="line-added">+                 addIdentifierIgnorable(set.getAlias(), status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaISOControl&quot;, -1) == 0) {</span>
<span class="line-added">+                 set-&gt;add(0, 0x1F).add(0x7F, 0x9F);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaJavaIdentifierPart&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_SC_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_PC_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_ND_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_NL_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_MC_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_MN_MASK, status);</span>
<span class="line-added">+                 addIdentifierIgnorable(set.getAlias(), status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaJavaIdentifierStart&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_NL_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_SC_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_PC_MASK, status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaLetter&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaLetterOrDigit&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_ND_MASK, status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaLowerCase&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_LL_MASK, status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaMirrored&quot;, -1) == 0) {</span>
<span class="line-added">+                 set-&gt;applyIntPropertyValue(UCHAR_BIDI_MIRRORED, 1, status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaSpaceChar&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_Z_MASK, status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaSupplementaryCodePoint&quot;, -1) == 0) {</span>
<span class="line-added">+                 set-&gt;add(0x10000, UnicodeSet::MAX_VALUE);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaTitleCase&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_LT_MASK, status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaUnicodeIdentifierStart&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_NL_MASK, status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaUnicodeIdentifierPart&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_PC_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_ND_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_NL_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_MC_MASK, status);</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_MN_MASK, status);</span>
<span class="line-added">+                 addIdentifierIgnorable(set.getAlias(), status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaUpperCase&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_LU_MASK, status);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaValidCodePoint&quot;, -1) == 0) {</span>
<span class="line-added">+                 set-&gt;add(0, UnicodeSet::MAX_VALUE);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (propName.compare(u&quot;javaWhitespace&quot;, -1) == 0) {</span>
<span class="line-added">+                 addCategory(set.getAlias(), U_GC_Z_MASK, status);</span>
<span class="line-added">+                 set-&gt;removeAll(UnicodeSet().add(0xa0).add(0x2007).add(0x202f));</span>
<span class="line-added">+                 set-&gt;add(9, 0x0d).add(0x1c, 0x1f);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 status = U_REGEX_PROPERTY_SYNTAX;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (U_SUCCESS(status) &amp;&amp; !set-&gt;isEmpty() &amp;&amp; (usetFlags &amp; USET_CASE_INSENSITIVE)) {</span>
<span class="line-added">+                 set-&gt;closeOver(USET_CASE_INSENSITIVE);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Unrecognized property. ICU didn&#39;t like it as it was, and none of the Java compatibility</span>
<span class="line-added">+         // extensions matched it.</span>
<span class="line-added">+         status = U_REGEX_PROPERTY_SYNTAX;</span>
<span class="line-added">+     } while (false);   // End of do loop block. Code above breaks out of the block on success or hard failure.</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (U_SUCCESS(status)) {</span>
<span class="line-added">+         U_ASSERT(set.isValid());</span>
<span class="line-added">+         if (negated) {</span>
<span class="line-added">+             set-&gt;complement();</span>
          }
<span class="line-modified">!         return set.orphan();</span>
<span class="line-modified">!     } else {</span>
<span class="line-added">+         if (status == U_ILLEGAL_ARGUMENT_ERROR) {</span>
<span class="line-added">+             status = U_REGEX_PROPERTY_SYNTAX;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         error(status);</span>
<span class="line-added">+         return nullptr;</span>
      }
  }
  
  
  //
  //  SetEval   Part of the evaluation of [set expressions].
  //            Perform any pending (stacked) operations with precedence
  //            equal or greater to that of the next operator encountered
  //            in the expression.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4619,12 ***</span>
                  leftOperand = (UnicodeSet *)fSetStack.peek();
                  leftOperand-&gt;addAll(*rightOperand);
                  delete rightOperand;
                  break;
              default:
<span class="line-modified">!                 U_ASSERT(FALSE);</span>
<span class="line-removed">-                 break;</span>
              }
          }
      }
  
  void RegexCompile::setPushOp(int32_t op) {
<span class="line-new-header">--- 4622,11 ---</span>
                  leftOperand = (UnicodeSet *)fSetStack.peek();
                  leftOperand-&gt;addAll(*rightOperand);
                  delete rightOperand;
                  break;
              default:
<span class="line-modified">!                 UPRV_UNREACHABLE;</span>
              }
          }
      }
  
  void RegexCompile::setPushOp(int32_t op) {
</pre>
<center><a href="rbtz.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="regexcst.txt.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>