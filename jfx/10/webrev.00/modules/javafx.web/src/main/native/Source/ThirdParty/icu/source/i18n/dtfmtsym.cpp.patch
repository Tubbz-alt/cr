diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtfmtsym.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtfmtsym.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtfmtsym.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtfmtsym.cpp
@@ -19,10 +19,13 @@
 *   03/27/00    weiv        Keeping resource bundle around!
 *   06/30/05    emmons      Added eraNames, narrow month/day, standalone context
 *   10/12/05    emmons      Added setters for eraNames, month/day by width/context
 *******************************************************************************
 */
+
+#include <utility>
+
 #include "unicode/utypes.h"
 
 #if !UCONFIG_NO_FORMATTING
 #include "unicode/ustring.h"
 #include "unicode/localpointer.h"
@@ -230,12 +233,10 @@
 
 // static const char gLocalPatternCharsTag[]="localPatternChars";
 
 static const char gContextTransformsTag[]="contextTransforms";
 
-static UMutex LOCK = U_MUTEX_INITIALIZER;
-
 /**
  * Jitterbug 2974: MSVC has a bug whereby new X[0] behaves badly.
  * Work around this.
  */
 static inline UnicodeString* newUnicodeStringArray(size_t count) {
@@ -329,11 +330,11 @@
  * be set already by the caller.
  */
 void
 DateFormatSymbols::createZoneStrings(const UnicodeString *const * otherStrings)
 {
-    int32_t row = 0, col;
+    int32_t row, col;
     UBool failed = FALSE;
 
     fZoneStrings = (UnicodeString **)uprv_malloc(fZoneStringsRowCount * sizeof(UnicodeString *));
     if (fZoneStrings != NULL) {
         for (row=0; row<fZoneStringsRowCount; ++row)
@@ -1243,10 +1244,11 @@
 
 const UnicodeString**
 DateFormatSymbols::getZoneStrings(int32_t& rowCount, int32_t& columnCount) const
 {
     const UnicodeString **result = NULL;
+    static UMutex LOCK = U_MUTEX_INITIALIZER;
 
     umtx_lock(&LOCK);
     if (fZoneStrings == NULL) {
         if (fLocaleZoneStrings == NULL) {
             ((DateFormatSymbols*)this)->initZoneStringsArray();
@@ -1309,11 +1311,11 @@
         const UnicodeString *tzid;
         int32_t i = 0;
         UDate now = Calendar::getNow();
         UnicodeString tzDispName;
 
-        while ((tzid = tzids->snext(status))) {
+        while ((tzid = tzids->snext(status)) != 0) {
             if (U_FAILURE(status)) {
                 break;
             }
 
             zarray[i] = new UnicodeString[5];
@@ -1498,11 +1500,11 @@
     /**
      * Whenever there are aliases, the same object will be added twice to 'map'.
      * To avoid double deletion, 'maps' won't take ownership of the objects. Instead,
      * 'mapRefs' will own them and will delete them when CalendarDataSink is deleted.
      */
-    UVector mapRefs;
+    MemoryPool<Hashtable> mapRefs;
 
     // Paths and the aliases they point to
     UVector aliasPathPairs;
 
     // Current and next calendar resource table which should be loaded
@@ -1516,11 +1518,11 @@
     UnicodeString aliasRelativePath;
 
     // Initializes CalendarDataSink with default values
     CalendarDataSink(UErrorCode& status)
     :   arrays(FALSE, status), arraySizes(FALSE, status), maps(FALSE, status),
-        mapRefs(deleteHashtable, NULL, 10, status),
+        mapRefs(),
         aliasPathPairs(uprv_deleteUObject, uhash_compareUnicodeString, status),
         currentCalendarType(), nextCalendarType(),
         resourcesToVisit(NULL), aliasRelativePath() {
         if (U_FAILURE(status)) { return; }
     }
@@ -1661,11 +1663,11 @@
             }
         } while (modified && !aliasPathPairs.isEmpty());
 
         // Set the resources to visit on the next calendar
         if (!resourcesToVisitNext.isNull()) {
-            resourcesToVisit.moveFrom(resourcesToVisitNext);
+            resourcesToVisit = std::move(resourcesToVisitNext);
         }
     }
 
     // Process the nested resource bundle tables
     void processResource(UnicodeString &path, const char *key, ResourceValue &value, UErrorCode &errorCode) {
@@ -1686,18 +1688,18 @@
 
             // == Handle String elements ==
             if (value.getType() == URES_STRING) {
                 // We are on a leaf, store the map elements into the stringMap
                 if (i == 0) {
-                    LocalPointer<Hashtable> stringMapPtr(new Hashtable(FALSE, errorCode), errorCode);
-                    stringMap = stringMapPtr.getAlias();
+                    // mapRefs will keep ownership of 'stringMap':
+                    stringMap = mapRefs.create(FALSE, errorCode);
+                    if (stringMap == NULL) {
+                        errorCode = U_MEMORY_ALLOCATION_ERROR;
+                        return;
+                    }
                     maps.put(path, stringMap, errorCode);
-                    // mapRefs will take ownership of 'stringMap':
-                    mapRefs.addElement(stringMap, errorCode);
                     if (U_FAILURE(errorCode)) { return; }
-                    // Only release ownership after mapRefs takes it (no error happened):
-                    stringMapPtr.orphan();
                     stringMap->setValueDeleter(uprv_deleteUObject);
                 }
                 U_ASSERT(stringMap != NULL);
                 int32_t valueStringSize;
                 const UChar *valueString = value.getString(valueStringSize, errorCode);
@@ -1837,15 +1839,10 @@
 
     // Deleter function to be used by 'arrays'
     static void U_CALLCONV deleteUnicodeStringArray(void *uArray) {
         delete[] static_cast<UnicodeString *>(uArray);
     }
-
-    // Deleter function to be used by 'maps'
-    static void U_CALLCONV deleteHashtable(void *table) {
-        delete static_cast<Hashtable *>(table);
-    }
 };
 // Virtual destructors have to be defined out of line
 CalendarDataSink::~CalendarDataSink() {
     arrays.setValueDeleter(deleteUnicodeStringArray);
 }
@@ -2222,12 +2219,12 @@
                         // linear search; list is short and we cannot be sure that bsearch is available
                         while ( typeMapPtr->usageTypeName != NULL && (compResult = uprv_strcmp(usageType, typeMapPtr->usageTypeName)) > 0 ) {
                             ++typeMapPtr;
                         }
                         if (typeMapPtr->usageTypeName != NULL && compResult == 0) {
-                            fCapitalization[typeMapPtr->usageTypeEnumValue][0] = intVector[0];
-                            fCapitalization[typeMapPtr->usageTypeEnumValue][1] = intVector[1];
+                            fCapitalization[typeMapPtr->usageTypeEnumValue][0] = static_cast<UBool>(intVector[0]);
+                            fCapitalization[typeMapPtr->usageTypeEnumValue][1] = static_cast<UBool>(intVector[1]);
                         }
                     }
                 }
                 tempStatus = U_ZERO_ERROR;
                 ures_close(contextTransformUsage);
