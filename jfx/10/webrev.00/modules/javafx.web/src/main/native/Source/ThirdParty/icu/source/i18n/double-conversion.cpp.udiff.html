<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/double-conversion.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="double-conversion-utils.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/double-conversion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -32,12 +32,15 @@</span>
  
  // ICU PATCH: ifdef around UCONFIG_NO_FORMATTING
  #include &quot;unicode/utypes.h&quot;
  #if !UCONFIG_NO_FORMATTING
  
<span class="udiff-line-modified-removed">- #include &lt;limits.h&gt;</span>
<span class="udiff-line-modified-removed">- #include &lt;math.h&gt;</span>
<span class="udiff-line-modified-added">+ // ICU PATCH: Do not include std::locale.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ #include &lt;climits&gt;</span>
<span class="udiff-line-added">+ //#include &lt;locale&gt;</span>
<span class="udiff-line-added">+ #include &lt;cmath&gt;</span>
  
  // ICU PATCH: Customize header file paths for ICU.
  // The file fixed-dtoa.h is not needed.
  
  #include &quot;double-conversion.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -430,25 +433,64 @@</span>
    BignumDtoa(v, bignum_mode, requested_digits, vector, length, point);
    vector[*length] = &#39;\0&#39;;
  }
  
  
<span class="udiff-line-added">+ namespace {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline char ToLower(char ch) {</span>
<span class="udiff-line-added">+ #if 0  // do not include std::locale in ICU</span>
<span class="udiff-line-added">+   static const std::ctype&lt;char&gt;&amp; cType =</span>
<span class="udiff-line-added">+       std::use_facet&lt;std::ctype&lt;char&gt; &gt;(std::locale::classic());</span>
<span class="udiff-line-added">+   return cType.tolower(ch);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   (void)ch;</span>
<span class="udiff-line-added">+   UNREACHABLE();</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline char Pass(char ch) {</span>
<span class="udiff-line-added">+   return ch;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;class Iterator, class Converter&gt;</span>
<span class="udiff-line-added">+ static inline bool ConsumeSubStringImpl(Iterator* current,</span>
<span class="udiff-line-added">+                                         Iterator end,</span>
<span class="udiff-line-added">+                                         const char* substring,</span>
<span class="udiff-line-added">+                                         Converter converter) {</span>
<span class="udiff-line-added">+   ASSERT(converter(**current) == *substring);</span>
<span class="udiff-line-added">+   for (substring++; *substring != &#39;\0&#39;; substring++) {</span>
<span class="udiff-line-added">+     ++*current;</span>
<span class="udiff-line-added">+     if (*current == end || converter(**current) != *substring) {</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ++*current;</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Consumes the given substring from the iterator.
  // Returns false, if the substring does not match.
  template &lt;class Iterator&gt;
  static bool ConsumeSubString(Iterator* current,
                               Iterator end,
<span class="udiff-line-modified-removed">-                              const char* substring) {</span>
<span class="udiff-line-modified-removed">-   ASSERT(**current == *substring);</span>
<span class="udiff-line-modified-removed">-   for (substring++; *substring != &#39;\0&#39;; substring++) {</span>
<span class="udiff-line-modified-removed">-     ++*current;</span>
<span class="udiff-line-modified-removed">-     if (*current == end || **current != *substring) return false;</span>
<span class="udiff-line-modified-added">+                              const char* substring,</span>
<span class="udiff-line-modified-added">+                              bool allow_case_insensibility) {</span>
<span class="udiff-line-modified-added">+   if (allow_case_insensibility) {</span>
<span class="udiff-line-modified-added">+     return ConsumeSubStringImpl(current, end, substring, ToLower);</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-added">+     return ConsumeSubStringImpl(current, end, substring, Pass);</span>
    }
<span class="udiff-line-removed">-   ++*current;</span>
<span class="udiff-line-removed">-   return true;</span>
  }
  
<span class="udiff-line-added">+ // Consumes first character of the str is equal to ch</span>
<span class="udiff-line-added">+ inline bool ConsumeFirstCharacter(char ch,</span>
<span class="udiff-line-added">+                                          const char* str,</span>
<span class="udiff-line-added">+                                          bool case_insensibility) {</span>
<span class="udiff-line-added">+   return case_insensibility ? ToLower(ch) == str[0] : ch == str[0];</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ }  // namespace</span>
  
  // Maximum number of significant digits in decimal representation.
  // The longest possible double in decimal representation is
  // (2^53 - 1) * 2 ^ -1074 that is (2 ^ 53 - 1) * 5 ^ 1074 / 10 ^ 1074
  // (768 digits). If we parse a number whose first digits are equal to a
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -511,19 +553,19 @@</span>
  //
  // The function is small and could be inlined, but VS2012 emitted a warning
  // because it constant-propagated the radix and concluded that the last
  // condition was always true. By moving it into a separate function the
  // compiler wouldn&#39;t warn anymore.
<span class="udiff-line-modified-removed">- #if _MSC_VER</span>
<span class="udiff-line-modified-added">+ #ifdef _MSC_VER</span>
  #pragma optimize(&quot;&quot;,off)
  static bool IsDecimalDigitForRadix(int c, int radix) {
    return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;
  }
  #pragma optimize(&quot;&quot;,on)
  #else
  static bool inline IsDecimalDigitForRadix(int c, int radix) {
<span class="udiff-line-modified-removed">-     return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;</span>
<span class="udiff-line-modified-added">+   return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;</span>
  }
  #endif
  // Returns true if &#39;c&#39; is a character digit that is valid for the given radix.
  // The &#39;a_character&#39; should be &#39;a&#39; or &#39;A&#39;.
  //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -533,49 +575,130 @@</span>
  // compiler wouldn&#39;t warn anymore.
  static bool IsCharacterDigitForRadix(int c, int radix, char a_character) {
    return radix &gt; 10 &amp;&amp; c &gt;= a_character &amp;&amp; c &lt; a_character + radix - 10;
  }
  
<span class="udiff-line-added">+ // Returns true, when the iterator is equal to end.</span>
<span class="udiff-line-added">+ template&lt;class Iterator&gt;</span>
<span class="udiff-line-added">+ static bool Advance (Iterator* it, uc16 separator, int base, Iterator&amp; end) {</span>
<span class="udiff-line-added">+   if (separator == StringToDoubleConverter::kNoSeparator) {</span>
<span class="udiff-line-added">+     ++(*it);</span>
<span class="udiff-line-added">+     return *it == end;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!isDigit(**it, base)) {</span>
<span class="udiff-line-added">+     ++(*it);</span>
<span class="udiff-line-added">+     return *it == end;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ++(*it);</span>
<span class="udiff-line-added">+   if (*it == end) return true;</span>
<span class="udiff-line-added">+   if (*it + 1 == end) return false;</span>
<span class="udiff-line-added">+   if (**it == separator &amp;&amp; isDigit(*(*it + 1), base)) {</span>
<span class="udiff-line-added">+     ++(*it);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return *it == end;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Checks whether the string in the range start-end is a hex-float string.</span>
<span class="udiff-line-added">+ // This function assumes that the leading &#39;0x&#39;/&#39;0X&#39; is already consumed.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Hex float strings are of one of the following forms:</span>
<span class="udiff-line-added">+ //   - hex_digits+ &#39;p&#39; (&#39;+&#39;|&#39;-&#39;)? exponent_digits+</span>
<span class="udiff-line-added">+ //   - hex_digits* &#39;.&#39; hex_digits+ &#39;p&#39; (&#39;+&#39;|&#39;-&#39;)? exponent_digits+</span>
<span class="udiff-line-added">+ //   - hex_digits+ &#39;.&#39; &#39;p&#39; (&#39;+&#39;|&#39;-&#39;)? exponent_digits+</span>
<span class="udiff-line-added">+ template&lt;class Iterator&gt;</span>
<span class="udiff-line-added">+ static bool IsHexFloatString(Iterator start,</span>
<span class="udiff-line-added">+                              Iterator end,</span>
<span class="udiff-line-added">+                              uc16 separator,</span>
<span class="udiff-line-added">+                              bool allow_trailing_junk) {</span>
<span class="udiff-line-added">+   ASSERT(start != end);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Iterator current = start;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool saw_digit = false;</span>
<span class="udiff-line-added">+   while (isDigit(*current, 16)) {</span>
<span class="udiff-line-added">+     saw_digit = true;</span>
<span class="udiff-line-added">+     if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (*current == &#39;.&#39;) {</span>
<span class="udiff-line-added">+     if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="udiff-line-added">+     while (isDigit(*current, 16)) {</span>
<span class="udiff-line-added">+       saw_digit = true;</span>
<span class="udiff-line-added">+       if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (!saw_digit) return false;  // Only the &#39;.&#39;, but no digits.</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (*current != &#39;p&#39; &amp;&amp; *current != &#39;P&#39;) return false;</span>
<span class="udiff-line-added">+   if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="udiff-line-added">+   if (*current == &#39;+&#39; || *current == &#39;-&#39;) {</span>
<span class="udiff-line-added">+     if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!isDigit(*current, 10)) return false;</span>
<span class="udiff-line-added">+   if (Advance(&amp;current, separator, 16, end)) return true;</span>
<span class="udiff-line-added">+   while (isDigit(*current, 10)) {</span>
<span class="udiff-line-added">+     if (Advance(&amp;current, separator, 16, end)) return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return allow_trailing_junk || !AdvanceToNonspace(&amp;current, end);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  
  // Parsing integers with radix 2, 4, 8, 16, 32. Assumes current != end.
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // If parse_as_hex_float is true, then the string must be a valid</span>
<span class="udiff-line-added">+ // hex-float.</span>
  template &lt;int radix_log_2, class Iterator&gt;
  static double RadixStringToIeee(Iterator* current,
                                  Iterator end,
                                  bool sign,
<span class="udiff-line-added">+                                 uc16 separator,</span>
<span class="udiff-line-added">+                                 bool parse_as_hex_float,</span>
                                  bool allow_trailing_junk,
                                  double junk_string_value,
                                  bool read_as_double,
                                  bool* result_is_junk) {
    ASSERT(*current != end);
<span class="udiff-line-added">+   ASSERT(!parse_as_hex_float ||</span>
<span class="udiff-line-added">+       IsHexFloatString(*current, end, separator, allow_trailing_junk));</span>
  
    const int kDoubleSize = Double::kSignificandSize;
    const int kSingleSize = Single::kSignificandSize;
    const int kSignificandSize = read_as_double? kDoubleSize: kSingleSize;
  
    *result_is_junk = true;
  
<span class="udiff-line-added">+   int64_t number = 0;</span>
<span class="udiff-line-added">+   int exponent = 0;</span>
<span class="udiff-line-added">+   const int radix = (1 &lt;&lt; radix_log_2);</span>
<span class="udiff-line-added">+   // Whether we have encountered a &#39;.&#39; and are parsing the decimal digits.</span>
<span class="udiff-line-added">+   // Only relevant if parse_as_hex_float is true.</span>
<span class="udiff-line-added">+   bool post_decimal = false;</span>
<span class="udiff-line-added">+ </span>
    // Skip leading 0s.
    while (**current == &#39;0&#39;) {
<span class="udiff-line-modified-removed">-     ++(*current);</span>
<span class="udiff-line-removed">-     if (*current == end) {</span>
<span class="udiff-line-modified-added">+     if (Advance(current, separator, radix, end)) {</span>
        *result_is_junk = false;
        return SignedZero(sign);
      }
    }
  
<span class="udiff-line-modified-removed">-   int64_t number = 0;</span>
<span class="udiff-line-removed">-   int exponent = 0;</span>
<span class="udiff-line-removed">-   const int radix = (1 &lt;&lt; radix_log_2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   do {</span>
<span class="udiff-line-modified-added">+   while (true) {</span>
      int digit;
      if (IsDecimalDigitForRadix(**current, radix)) {
        digit = static_cast&lt;char&gt;(**current) - &#39;0&#39;;
<span class="udiff-line-added">+       if (post_decimal) exponent -= radix_log_2;</span>
      } else if (IsCharacterDigitForRadix(**current, radix, &#39;a&#39;)) {
        digit = static_cast&lt;char&gt;(**current) - &#39;a&#39; + 10;
<span class="udiff-line-added">+       if (post_decimal) exponent -= radix_log_2;</span>
      } else if (IsCharacterDigitForRadix(**current, radix, &#39;A&#39;)) {
        digit = static_cast&lt;char&gt;(**current) - &#39;A&#39; + 10;
<span class="udiff-line-added">+       if (post_decimal) exponent -= radix_log_2;</span>
<span class="udiff-line-added">+     } else if (parse_as_hex_float &amp;&amp; **current == &#39;.&#39;) {</span>
<span class="udiff-line-added">+       post_decimal = true;</span>
<span class="udiff-line-added">+       Advance(current, separator, radix, end);</span>
<span class="udiff-line-added">+       ASSERT(*current != end);</span>
<span class="udiff-line-added">+       continue;</span>
<span class="udiff-line-added">+     } else if (parse_as_hex_float &amp;&amp; (**current == &#39;p&#39; || **current == &#39;P&#39;)) {</span>
<span class="udiff-line-added">+       break;</span>
      } else {
        if (allow_trailing_junk || !AdvanceToNonspace(current, end)) {
          break;
        } else {
          return junk_string_value;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -594,21 +717,30 @@</span>
        }
  
        int dropped_bits_mask = ((1 &lt;&lt; overflow_bits_count) - 1);
        int dropped_bits = static_cast&lt;int&gt;(number) &amp; dropped_bits_mask;
        number &gt;&gt;= overflow_bits_count;
<span class="udiff-line-modified-removed">-       exponent = overflow_bits_count;</span>
<span class="udiff-line-modified-added">+       exponent += overflow_bits_count;</span>
  
        bool zero_tail = true;
        for (;;) {
<span class="udiff-line-modified-removed">-         ++(*current);</span>
<span class="udiff-line-modified-removed">-         if (*current == end || !isDigit(**current, radix)) break;</span>
<span class="udiff-line-modified-added">+         if (Advance(current, separator, radix, end)) break;</span>
<span class="udiff-line-modified-added">+         if (parse_as_hex_float &amp;&amp; **current == &#39;.&#39;) {</span>
<span class="udiff-line-added">+           // Just run over the &#39;.&#39;. We are just trying to see whether there is</span>
<span class="udiff-line-added">+           // a non-zero digit somewhere.</span>
<span class="udiff-line-added">+           Advance(current, separator, radix, end);</span>
<span class="udiff-line-added">+           ASSERT(*current != end);</span>
<span class="udiff-line-added">+           post_decimal = true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (!isDigit(**current, radix)) break;</span>
          zero_tail = zero_tail &amp;&amp; **current == &#39;0&#39;;
<span class="udiff-line-modified-removed">-         exponent += radix_log_2;</span>
<span class="udiff-line-modified-added">+         if (!post_decimal) exponent += radix_log_2;</span>
        }
  
<span class="udiff-line-modified-removed">-       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(current, end)) {</span>
<span class="udiff-line-modified-added">+       if (!parse_as_hex_float &amp;&amp;</span>
<span class="udiff-line-added">+           !allow_trailing_junk &amp;&amp;</span>
<span class="udiff-line-added">+           AdvanceToNonspace(current, end)) {</span>
          return junk_string_value;
        }
  
        int middle_value = (1 &lt;&lt; (overflow_bits_count - 1));
        if (dropped_bits &gt; middle_value) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -626,28 +758,51 @@</span>
          exponent++;
          number &gt;&gt;= 1;
        }
        break;
      }
<span class="udiff-line-modified-removed">-     ++(*current);</span>
<span class="udiff-line-modified-removed">-   } while (*current != end);</span>
<span class="udiff-line-modified-added">+     if (Advance(current, separator, radix, end)) break;</span>
<span class="udiff-line-modified-added">+   }</span>
  
    ASSERT(number &lt; ((int64_t)1 &lt;&lt; kSignificandSize));
    ASSERT(static_cast&lt;int64_t&gt;(static_cast&lt;double&gt;(number)) == number);
  
    *result_is_junk = false;
  
<span class="udiff-line-modified-removed">-   if (exponent == 0) {</span>
<span class="udiff-line-modified-added">+   if (parse_as_hex_float) {</span>
<span class="udiff-line-added">+     ASSERT(**current == &#39;p&#39; || **current == &#39;P&#39;);</span>
<span class="udiff-line-added">+     Advance(current, separator, radix, end);</span>
<span class="udiff-line-added">+     ASSERT(*current != end);</span>
<span class="udiff-line-added">+     bool is_negative = false;</span>
<span class="udiff-line-added">+     if (**current == &#39;+&#39;) {</span>
<span class="udiff-line-added">+       Advance(current, separator, radix, end);</span>
<span class="udiff-line-added">+       ASSERT(*current != end);</span>
<span class="udiff-line-added">+     } else if (**current == &#39;-&#39;) {</span>
<span class="udiff-line-added">+       is_negative = true;</span>
<span class="udiff-line-added">+       Advance(current, separator, radix, end);</span>
<span class="udiff-line-added">+       ASSERT(*current != end);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     int written_exponent = 0;</span>
<span class="udiff-line-added">+     while (IsDecimalDigitForRadix(**current, 10)) {</span>
<span class="udiff-line-added">+       written_exponent = 10 * written_exponent + **current - &#39;0&#39;;</span>
<span class="udiff-line-added">+       if (Advance(current, separator, radix, end)) break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (is_negative) written_exponent = -written_exponent;</span>
<span class="udiff-line-added">+     exponent += written_exponent;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (exponent == 0 || number == 0) {</span>
      if (sign) {
        if (number == 0) return -0.0;
        number = -number;
      }
      return static_cast&lt;double&gt;(number);
    }
  
    ASSERT(number != 0);
<span class="udiff-line-modified-removed">-   return Double(DiyFp(number, exponent)).value();</span>
<span class="udiff-line-modified-added">+   double result = Double(DiyFp(number, exponent)).value();</span>
<span class="udiff-line-added">+   return sign ? -result : result;</span>
  }
  
  template &lt;class Iterator&gt;
  double StringToDoubleConverter::StringToIeee(
      Iterator input,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -661,10 +816,11 @@</span>
  
    const bool allow_trailing_junk = (flags_ &amp; ALLOW_TRAILING_JUNK) != 0;
    const bool allow_leading_spaces = (flags_ &amp; ALLOW_LEADING_SPACES) != 0;
    const bool allow_trailing_spaces = (flags_ &amp; ALLOW_TRAILING_SPACES) != 0;
    const bool allow_spaces_after_sign = (flags_ &amp; ALLOW_SPACES_AFTER_SIGN) != 0;
<span class="udiff-line-added">+   const bool allow_case_insensibility = (flags_ &amp; ALLOW_CASE_INSENSIBILITY) != 0;</span>
  
    // To make sure that iterator dereferencing is valid the following
    // convention is used:
    // 1. Each &#39;++current&#39; statement is followed by check for equality to &#39;end&#39;.
    // 2. If AdvanceToNonspace returned false then current == end.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -710,12 +866,12 @@</span>
      }
      current = next_non_space;
    }
  
    if (infinity_symbol_ != NULL) {
<span class="udiff-line-modified-removed">-     if (*current == infinity_symbol_[0]) {</span>
<span class="udiff-line-modified-removed">-       if (!ConsumeSubString(&amp;current, end, infinity_symbol_)) {</span>
<span class="udiff-line-modified-added">+     if (ConsumeFirstCharacter(*current, infinity_symbol_, allow_case_insensibility)) {</span>
<span class="udiff-line-modified-added">+       if (!ConsumeSubString(&amp;current, end, infinity_symbol_, allow_case_insensibility)) {</span>
          return junk_string_value_;
        }
  
        if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
          return junk_string_value_;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -729,12 +885,12 @@</span>
        return sign ? -Double::Infinity() : Double::Infinity();
      }
    }
  
    if (nan_symbol_ != NULL) {
<span class="udiff-line-modified-removed">-     if (*current == nan_symbol_[0]) {</span>
<span class="udiff-line-modified-removed">-       if (!ConsumeSubString(&amp;current, end, nan_symbol_)) {</span>
<span class="udiff-line-modified-added">+     if (ConsumeFirstCharacter(*current, nan_symbol_, allow_case_insensibility)) {</span>
<span class="udiff-line-modified-added">+       if (!ConsumeSubString(&amp;current, end, nan_symbol_, allow_case_insensibility)) {</span>
          return junk_string_value_;
        }
  
        if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
          return junk_string_value_;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -749,29 +905,36 @@</span>
      }
    }
  
    bool leading_zero = false;
    if (*current == &#39;0&#39;) {
<span class="udiff-line-modified-removed">-     ++current;</span>
<span class="udiff-line-removed">-     if (current == end) {</span>
<span class="udiff-line-modified-added">+     if (Advance(&amp;current, separator_, 10, end)) {</span>
        *processed_characters_count = static_cast&lt;int&gt;(current - input);
        return SignedZero(sign);
      }
  
      leading_zero = true;
  
      // It could be hexadecimal value.
<span class="udiff-line-modified-removed">-     if ((flags_ &amp; ALLOW_HEX) &amp;&amp; (*current == &#39;x&#39; || *current == &#39;X&#39;)) {</span>
<span class="udiff-line-modified-added">+     if (((flags_ &amp; ALLOW_HEX) || (flags_ &amp; ALLOW_HEX_FLOATS)) &amp;&amp;</span>
<span class="udiff-line-added">+         (*current == &#39;x&#39; || *current == &#39;X&#39;)) {</span>
        ++current;
<span class="udiff-line-modified-removed">-       if (current == end || !isDigit(*current, 16)) {</span>
<span class="udiff-line-modified-removed">-         return junk_string_value_;  // &quot;0x&quot;.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       bool parse_as_hex_float = (flags_ &amp; ALLOW_HEX_FLOATS) &amp;&amp;</span>
<span class="udiff-line-added">+                 IsHexFloatString(current, end, separator_, allow_trailing_junk);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (current == end) return junk_string_value_;  // &quot;0x&quot;</span>
<span class="udiff-line-added">+       if (!parse_as_hex_float &amp;&amp; !isDigit(*current, 16)) {</span>
<span class="udiff-line-added">+         return junk_string_value_;</span>
        }
  
        bool result_is_junk;
        double result = RadixStringToIeee&lt;4&gt;(&amp;current,
                                             end,
<span class="udiff-line-added">+                                            separator_,</span>
<span class="udiff-line-added">+                                            parse_as_hex_float,</span>
                                             allow_trailing_junk,
                                             junk_string_value_,
                                             read_as_double,
                                             &amp;result_is_junk);
        if (!result_is_junk) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -781,12 +944,11 @@</span>
        return result;
      }
  
      // Ignore leading zeros in the integer part.
      while (*current == &#39;0&#39;) {
<span class="udiff-line-modified-removed">-       ++current;</span>
<span class="udiff-line-removed">-       if (current == end) {</span>
<span class="udiff-line-modified-added">+       if (Advance(&amp;current, separator_, 10, end)) {</span>
          *processed_characters_count = static_cast&lt;int&gt;(current - input);
          return SignedZero(sign);
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -803,24 +965,22 @@</span>
      } else {
        insignificant_digits++;  // Move the digit into the exponential part.
        nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;
      }
      octal = octal &amp;&amp; *current &lt; &#39;8&#39;;
<span class="udiff-line-modified-removed">-     ++current;</span>
<span class="udiff-line-removed">-     if (current == end) goto parsing_done;</span>
<span class="udiff-line-modified-added">+     if (Advance(&amp;current, separator_, 10, end)) goto parsing_done;</span>
    }
  
    if (significant_digits == 0) {
      octal = false;
    }
  
    if (*current == &#39;.&#39;) {
      if (octal &amp;&amp; !allow_trailing_junk) return junk_string_value_;
      if (octal) goto parsing_done;
  
<span class="udiff-line-modified-removed">-     ++current;</span>
<span class="udiff-line-removed">-     if (current == end) {</span>
<span class="udiff-line-modified-added">+     if (Advance(&amp;current, separator_, 10, end)) {</span>
        if (significant_digits == 0 &amp;&amp; !leading_zero) {
          return junk_string_value_;
        } else {
          goto parsing_done;
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -829,12 +989,11 @@</span>
      if (significant_digits == 0) {
        // octal = false;
        // Integer part consists of 0 or is absent. Significant digits start after
        // leading zeros (if any).
        while (*current == &#39;0&#39;) {
<span class="udiff-line-modified-removed">-         ++current;</span>
<span class="udiff-line-removed">-         if (current == end) {</span>
<span class="udiff-line-modified-added">+         if (Advance(&amp;current, separator_, 10, end)) {</span>
            *processed_characters_count = static_cast&lt;int&gt;(current - input);
            return SignedZero(sign);
          }
          exponent--;  // Move this 0 into the exponent.
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -850,12 +1009,11 @@</span>
          exponent--;
        } else {
          // Ignore insignificant digits in the fractional part.
          nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;
        }
<span class="udiff-line-modified-removed">-       ++current;</span>
<span class="udiff-line-removed">-       if (current == end) goto parsing_done;</span>
<span class="udiff-line-modified-added">+       if (Advance(&amp;current, separator_, 10, end)) goto parsing_done;</span>
      }
    }
  
    if (!leading_zero &amp;&amp; exponent == 0 &amp;&amp; significant_digits == 0) {
      // If leading_zeros is true then the string contains zeros.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -867,13 +1025,15 @@</span>
  
    // Parse exponential part.
    if (*current == &#39;e&#39; || *current == &#39;E&#39;) {
      if (octal &amp;&amp; !allow_trailing_junk) return junk_string_value_;
      if (octal) goto parsing_done;
<span class="udiff-line-added">+     Iterator junk_begin = current;</span>
      ++current;
      if (current == end) {
        if (allow_trailing_junk) {
<span class="udiff-line-added">+         current = junk_begin;</span>
          goto parsing_done;
        } else {
          return junk_string_value_;
        }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -881,19 +1041,21 @@</span>
      if (*current == &#39;+&#39; || *current == &#39;-&#39;) {
        exponen_sign = static_cast&lt;char&gt;(*current);
        ++current;
        if (current == end) {
          if (allow_trailing_junk) {
<span class="udiff-line-added">+           current = junk_begin;</span>
            goto parsing_done;
          } else {
            return junk_string_value_;
          }
        }
<span class="udiff-line-added">+         current = junk_begin;</span>
          goto parsing_done;
        } else {
          return junk_string_value_;
        }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -934,10 +1096,12 @@</span>
      bool result_is_junk;
      char* start = buffer;
      result = RadixStringToIeee&lt;3&gt;(&amp;start,
                                    buffer + buffer_pos,
                                    sign,
<span class="udiff-line-added">+                                   separator_,</span>
<span class="udiff-line-added">+                                   false, // Don&#39;t parse as hex_float.</span>
                                    allow_trailing_junk,
                                    junk_string_value_,
                                    read_as_double,
                                    &amp;result_is_junk);
      ASSERT(!result_is_junk);
</pre>
<center><a href="double-conversion-utils.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>