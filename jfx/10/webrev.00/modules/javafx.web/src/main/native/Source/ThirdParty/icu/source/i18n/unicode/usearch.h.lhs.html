<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/usearch.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 2001-2011,2014 IBM and others. All rights reserved.
  6 **********************************************************************
  7 *   Date        Name        Description
  8 *  06/28/2001   synwee      Creation.
  9 **********************************************************************
 10 */
 11 #ifndef USEARCH_H
 12 #define USEARCH_H
 13 
 14 #include &quot;unicode/utypes.h&quot;
 15 
 16 #if !UCONFIG_NO_COLLATION &amp;&amp; !UCONFIG_NO_BREAK_ITERATION
 17 
 18 #include &quot;unicode/localpointer.h&quot;
 19 #include &quot;unicode/ucol.h&quot;
 20 #include &quot;unicode/ucoleitr.h&quot;
 21 #include &quot;unicode/ubrk.h&quot;
 22 
 23 /**
 24  * \file
 25  * \brief C API: StringSearch
 26  *
 27  * C Apis for an engine that provides language-sensitive text searching based
 28  * on the comparison rules defined in a &lt;tt&gt;UCollator&lt;/tt&gt; data struct,
 29  * see &lt;tt&gt;ucol.h&lt;/tt&gt;. This ensures that language eccentricity can be
 30  * handled, e.g. for the German collator, characters &amp;szlig; and SS will be matched
 31  * if case is chosen to be ignored.
 32  * See the &lt;a href=&quot;http://source.icu-project.org/repos/icu/icuhtml/trunk/design/collation/ICU_collation_design.htm&quot;&gt;
 33  * &quot;ICU Collation Design Document&quot;&lt;/a&gt; for more information.
 34  * &lt;p&gt;
 35  * The implementation may use a linear search or a modified form of the Boyer-Moore
 36  * search; for more information on the latter see
 37  * &lt;a href=&quot;http://icu-project.org/docs/papers/efficient_text_searching_in_java.html&quot;&gt;
 38  * &quot;Efficient Text Searching in Java&quot;&lt;/a&gt;, published in &lt;i&gt;Java Report&lt;/i&gt;
 39  * in February, 1999.
 40  * &lt;p&gt;
 41  * There are 2 match options for selection:&lt;br&gt;
 42  * Let S&#39; be the sub-string of a text string S between the offsets start and
 43  * end &lt;start, end&gt;.
 44  * &lt;br&gt;
 45  * A pattern string P matches a text string S at the offsets &lt;start, end&gt;
 46  * if
 47  * &lt;pre&gt;
 48  * option 1. Some canonical equivalent of P matches some canonical equivalent
 49  *           of S&#39;
 50  * option 2. P matches S&#39; and if P starts or ends with a combining mark,
 51  *           there exists no non-ignorable combining mark before or after S&#39;
 52  *           in S respectively.
 53  * &lt;/pre&gt;
 54  * Option 2. will be the default.
 55  * &lt;p&gt;
 56  * This search has APIs similar to that of other text iteration mechanisms
 57  * such as the break iterators in &lt;tt&gt;ubrk.h&lt;/tt&gt;. Using these
 58  * APIs, it is easy to scan through text looking for all occurances of
 59  * a given pattern. This search iterator allows changing of direction by
 60  * calling a &lt;tt&gt;reset&lt;/tt&gt; followed by a &lt;tt&gt;next&lt;/tt&gt; or &lt;tt&gt;previous&lt;/tt&gt;.
 61  * Though a direction change can occur without calling &lt;tt&gt;reset&lt;/tt&gt; first,
 62  * this operation comes with some speed penalty.
 63  * Generally, match results in the forward direction will match the result
 64  * matches in the backwards direction in the reverse order
 65  * &lt;p&gt;
 66  * &lt;tt&gt;usearch.h&lt;/tt&gt; provides APIs to specify the starting position
 67  * within the text string to be searched, e.g. &lt;tt&gt;usearch_setOffset&lt;/tt&gt;,
 68  * &lt;tt&gt;usearch_preceding&lt;/tt&gt; and &lt;tt&gt;usearch_following&lt;/tt&gt;. Since the
 69  * starting position will be set as it is specified, please take note that
 70  * there are some dangerous positions which the search may render incorrect
 71  * results:
 72  * &lt;ul&gt;
 73  * &lt;li&gt; The midst of a substring that requires normalization.
 74  * &lt;li&gt; If the following match is to be found, the position should not be the
 75  *      second character which requires to be swapped with the preceding
 76  *      character. Vice versa, if the preceding match is to be found,
 77  *      position to search from should not be the first character which
 78  *      requires to be swapped with the next character. E.g certain Thai and
 79  *      Lao characters require swapping.
 80  * &lt;li&gt; If a following pattern match is to be found, any position within a
 81  *      contracting sequence except the first will fail. Vice versa if a
 82  *      preceding pattern match is to be found, a invalid starting point
 83  *      would be any character within a contracting sequence except the last.
 84  * &lt;/ul&gt;
 85  * &lt;p&gt;
 86  * A breakiterator can be used if only matches at logical breaks are desired.
 87  * Using a breakiterator will only give you results that exactly matches the
 88  * boundaries given by the breakiterator. For instance the pattern &quot;e&quot; will
 89  * not be found in the string &quot;\u00e9&quot; if a character break iterator is used.
 90  * &lt;p&gt;
 91  * Options are provided to handle overlapping matches.
 92  * E.g. In English, overlapping matches produces the result 0 and 2
 93  * for the pattern &quot;abab&quot; in the text &quot;ababab&quot;, where else mutually
 94  * exclusive matches only produce the result of 0.
 95  * &lt;p&gt;
 96  * Options are also provided to implement &quot;asymmetric search&quot; as described in
 97  * &lt;a href=&quot;http://www.unicode.org/reports/tr10/#Asymmetric_Search&quot;&gt;
 98  * UTS #10 Unicode Collation Algorithm&lt;/a&gt;, specifically the USearchAttribute
 99  * USEARCH_ELEMENT_COMPARISON and its values.
100  * &lt;p&gt;
101  * Though collator attributes will be taken into consideration while
102  * performing matches, there are no APIs here for setting and getting the
103  * attributes. These attributes can be set by getting the collator
104  * from &lt;tt&gt;usearch_getCollator&lt;/tt&gt; and using the APIs in &lt;tt&gt;ucol.h&lt;/tt&gt;.
105  * Lastly to update String Search to the new collator attributes,
106  * usearch_reset() has to be called.
107  * &lt;p&gt;
108  * Restriction: &lt;br&gt;
109  * Currently there are no composite characters that consists of a
110  * character with combining class &gt; 0 before a character with combining
111  * class == 0. However, if such a character exists in the future, the
112  * search mechanism does not guarantee the results for option 1.
113  *
114  * &lt;p&gt;
115  * Example of use:&lt;br&gt;
116  * &lt;pre&gt;&lt;code&gt;
117  * char *tgtstr = &quot;The quick brown fox jumped over the lazy fox&quot;;
118  * char *patstr = &quot;fox&quot;;
119  * UChar target[64];
120  * UChar pattern[16];
121  * UErrorCode status = U_ZERO_ERROR;
122  * u_uastrcpy(target, tgtstr);
123  * u_uastrcpy(pattern, patstr);
124  *
125  * UStringSearch *search = usearch_open(pattern, -1, target, -1, &quot;en_US&quot;,
126  *                                  NULL, &amp;status);
127  * if (U_SUCCESS(status)) {
128  *     for (int pos = usearch_first(search, &amp;status);
129  *          pos != USEARCH_DONE;
130  *          pos = usearch_next(search, &amp;status))
131  *     {
132  *         printf(&quot;Found match at %d pos, length is %d\n&quot;, pos,
133  *                                        usearch_getMatchLength(search));
134  *     }
135  * }
136  *
137  * usearch_close(search);
138  * &lt;/code&gt;&lt;/pre&gt;
139  * @stable ICU 2.4
140  */
141 
142 /**
143 * DONE is returned by previous() and next() after all valid matches have
144 * been returned, and by first() and last() if there are no matches at all.
145 * @stable ICU 2.4
146 */
147 #define USEARCH_DONE -1
148 
149 /**
150 * Data structure for searching
151 * @stable ICU 2.4
152 */
153 struct UStringSearch;
154 /**
155 * Data structure for searching
156 * @stable ICU 2.4
157 */
158 typedef struct UStringSearch UStringSearch;
159 
160 /**
161 * @stable ICU 2.4
162 */
163 typedef enum {
164     /**
165      * Option for overlapping matches
166      * @stable ICU 2.4
167      */
168     USEARCH_OVERLAP = 0,
169 #ifndef U_HIDE_DEPRECATED_API
170     /**
171      * Option for canonical matches; option 1 in header documentation.
172      * The default value will be USEARCH_OFF.
173      * Note: Setting this option to USEARCH_ON currently has no effect on
174      * search behavior, and this option is deprecated. Instead, to control
175      * canonical match behavior, you must set UCOL_NORMALIZATION_MODE
176      * appropriately (to UCOL_OFF or UCOL_ON) in the UCollator used by
177      * the UStringSearch object.
178      * @see usearch_openFromCollator
179      * @see usearch_getCollator
180      * @see usearch_setCollator
181      * @see ucol_getAttribute
182      * @deprecated ICU 53
183      */
184     USEARCH_CANONICAL_MATCH = 1,
185 #endif  /* U_HIDE_DEPRECATED_API */
186     /**
187      * Option to control how collation elements are compared.
188      * The default value will be USEARCH_STANDARD_ELEMENT_COMPARISON.
189      * @stable ICU 4.4
190      */
191     USEARCH_ELEMENT_COMPARISON = 2,
192 
193 #ifndef U_HIDE_DEPRECATED_API
194     /**
195      * One more than the highest normal USearchAttribute value.
196      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
197      */
198     USEARCH_ATTRIBUTE_COUNT = 3
199 #endif  /* U_HIDE_DEPRECATED_API */
200 } USearchAttribute;
201 
202 /**
203 * @stable ICU 2.4
204 */
205 typedef enum {
206     /**
207      * Default value for any USearchAttribute
208      * @stable ICU 2.4
209      */
210     USEARCH_DEFAULT = -1,
211     /**
212      * Value for USEARCH_OVERLAP and USEARCH_CANONICAL_MATCH
213      * @stable ICU 2.4
214      */
215     USEARCH_OFF,
216     /**
217      * Value for USEARCH_OVERLAP and USEARCH_CANONICAL_MATCH
218      * @stable ICU 2.4
219      */
220     USEARCH_ON,
221     /**
222      * Value (default) for USEARCH_ELEMENT_COMPARISON;
223      * standard collation element comparison at the specified collator
224      * strength.
225      * @stable ICU 4.4
226      */
227     USEARCH_STANDARD_ELEMENT_COMPARISON,
228     /**
229      * Value for USEARCH_ELEMENT_COMPARISON;
230      * collation element comparison is modified to effectively provide
231      * behavior between the specified strength and strength - 1. Collation
232      * elements in the pattern that have the base weight for the specified
233      * strength are treated as &quot;wildcards&quot; that match an element with any
234      * other weight at that collation level in the searched text. For
235      * example, with a secondary-strength English collator, a plain &#39;e&#39; in
236      * the pattern will match a plain e or an e with any diacritic in the
237      * searched text, but an e with diacritic in the pattern will only
238      * match an e with the same diacritic in the searched text.
239      *
240      * This supports &quot;asymmetric search&quot; as described in
241      * &lt;a href=&quot;http://www.unicode.org/reports/tr10/#Asymmetric_Search&quot;&gt;
242      * UTS #10 Unicode Collation Algorithm&lt;/a&gt;.
243      *
244      * @stable ICU 4.4
245      */
246     USEARCH_PATTERN_BASE_WEIGHT_IS_WILDCARD,
247     /**
248      * Value for USEARCH_ELEMENT_COMPARISON.
249      * collation element comparison is modified to effectively provide
250      * behavior between the specified strength and strength - 1. Collation
251      * elements in either the pattern or the searched text that have the
252      * base weight for the specified strength are treated as &quot;wildcards&quot;
253      * that match an element with any other weight at that collation level.
254      * For example, with a secondary-strength English collator, a plain &#39;e&#39;
255      * in the pattern will match a plain e or an e with any diacritic in the
256      * searched text, but an e with diacritic in the pattern will only
257      * match an e with the same diacritic or a plain e in the searched text.
258      *
259      * This option is similar to &quot;asymmetric search&quot; as described in
<a name="1" id="anc1"></a><span class="line-modified">260      * &lt;a href=&quot;http://www.unicode.org/reports/tr10/#Asymmetric_Search&quot;&gt;</span>
<span class="line-modified">261      * UTS #10 Unicode Collation Algorithm&lt;/a, but also allows unmarked</span>
<span class="line-modified">262      * characters in the searched text to match marked or unmarked versions of</span>
<span class="line-removed">263      * that character in the pattern.</span>
264      *
265      * @stable ICU 4.4
266      */
267     USEARCH_ANY_BASE_WEIGHT_IS_WILDCARD,
268 
269 #ifndef U_HIDE_DEPRECATED_API
270     /**
271      * One more than the highest normal USearchAttributeValue value.
272      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
273      */
274     USEARCH_ATTRIBUTE_VALUE_COUNT
275 #endif  /* U_HIDE_DEPRECATED_API */
276 } USearchAttributeValue;
277 
278 /* open and close ------------------------------------------------------ */
279 
280 /**
281 * Creating a search iterator data struct using the argument locale language
282 * rule set. A collator will be created in the process, which will be owned by
283 * this search and will be deleted in &lt;tt&gt;usearch_close&lt;/tt&gt;.
284 * @param pattern for matching
285 * @param patternlength length of the pattern, -1 for null-termination
286 * @param text text string
287 * @param textlength length of the text string, -1 for null-termination
288 * @param locale name of locale for the rules to be used
289 * @param breakiter A BreakIterator that will be used to restrict the points
290 *                  at which matches are detected. If a match is found, but
291 *                  the match&#39;s start or end index is not a boundary as
292 *                  determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt;, the match will
293 *                  be rejected and another will be searched for.
294 *                  If this parameter is &lt;tt&gt;NULL&lt;/tt&gt;, no break detection is
295 *                  attempted.
296 * @param status for errors if it occurs. If pattern or text is NULL, or if
297 *               patternlength or textlength is 0 then an
298 *               U_ILLEGAL_ARGUMENT_ERROR is returned.
299 * @return search iterator data structure, or NULL if there is an error.
300 * @stable ICU 2.4
301 */
302 U_STABLE UStringSearch * U_EXPORT2 usearch_open(const UChar          *pattern,
303                                               int32_t         patternlength,
304                                         const UChar          *text,
305                                               int32_t         textlength,
306                                         const char           *locale,
307                                               UBreakIterator *breakiter,
308                                               UErrorCode     *status);
309 
310 /**
311 * Creating a search iterator data struct using the argument collator language
312 * rule set. Note, user retains the ownership of this collator, thus the
313 * responsibility of deletion lies with the user.
314 * NOTE: string search cannot be instantiated from a collator that has
315 * collate digits as numbers (CODAN) turned on.
316 * @param pattern for matching
317 * @param patternlength length of the pattern, -1 for null-termination
318 * @param text text string
319 * @param textlength length of the text string, -1 for null-termination
320 * @param collator used for the language rules
321 * @param breakiter A BreakIterator that will be used to restrict the points
322 *                  at which matches are detected. If a match is found, but
323 *                  the match&#39;s start or end index is not a boundary as
324 *                  determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt;, the match will
325 *                  be rejected and another will be searched for.
326 *                  If this parameter is &lt;tt&gt;NULL&lt;/tt&gt;, no break detection is
327 *                  attempted.
328 * @param status for errors if it occurs. If collator, pattern or text is NULL,
329 *               or if patternlength or textlength is 0 then an
330 *               U_ILLEGAL_ARGUMENT_ERROR is returned.
331 * @return search iterator data structure, or NULL if there is an error.
332 * @stable ICU 2.4
333 */
334 U_STABLE UStringSearch * U_EXPORT2 usearch_openFromCollator(
335                                          const UChar *pattern,
336                                                int32_t         patternlength,
337                                          const UChar          *text,
338                                                int32_t         textlength,
339                                          const UCollator      *collator,
340                                                UBreakIterator *breakiter,
341                                                UErrorCode     *status);
342 
343 /**
344 * Destroying and cleaning up the search iterator data struct.
345 * If a collator is created in &lt;tt&gt;usearch_open&lt;/tt&gt;, it will be destroyed here.
346 * @param searchiter data struct to clean up
347 * @stable ICU 2.4
348 */
349 U_STABLE void U_EXPORT2 usearch_close(UStringSearch *searchiter);
350 
351 #if U_SHOW_CPLUSPLUS_API
352 
353 U_NAMESPACE_BEGIN
354 
355 /**
356  * \class LocalUStringSearchPointer
357  * &quot;Smart pointer&quot; class, closes a UStringSearch via usearch_close().
358  * For most methods see the LocalPointerBase base class.
359  *
360  * @see LocalPointerBase
361  * @see LocalPointer
362  * @stable ICU 4.4
363  */
364 U_DEFINE_LOCAL_OPEN_POINTER(LocalUStringSearchPointer, UStringSearch, usearch_close);
365 
366 U_NAMESPACE_END
367 
368 #endif
369 
370 /* get and set methods -------------------------------------------------- */
371 
372 /**
373 * Sets the current position in the text string which the next search will
374 * start from. Clears previous states.
375 * This method takes the argument index and sets the position in the text
376 * string accordingly without checking if the index is pointing to a
377 * valid starting point to begin searching.
378 * Search positions that may render incorrect results are highlighted in the
379 * header comments
380 * @param strsrch search iterator data struct
381 * @param position position to start next search from. If position is less
382 *          than or greater than the text range for searching,
383 *          an U_INDEX_OUTOFBOUNDS_ERROR will be returned
384 * @param status error status if any.
385 * @stable ICU 2.4
386 */
387 U_STABLE void U_EXPORT2 usearch_setOffset(UStringSearch *strsrch,
388                                         int32_t    position,
389                                         UErrorCode    *status);
390 
391 /**
392 * Return the current index in the string text being searched.
393 * If the iteration has gone past the end of the text (or past the beginning
394 * for a backwards search), &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; is returned.
395 * @param strsrch search iterator data struct
396 * @see #USEARCH_DONE
397 * @stable ICU 2.4
398 */
399 U_STABLE int32_t U_EXPORT2 usearch_getOffset(const UStringSearch *strsrch);
400 
401 /**
402 * Sets the text searching attributes located in the enum USearchAttribute
403 * with values from the enum USearchAttributeValue.
404 * &lt;tt&gt;USEARCH_DEFAULT&lt;/tt&gt; can be used for all attributes for resetting.
405 * @param strsrch search iterator data struct
406 * @param attribute text attribute to be set
407 * @param value text attribute value
408 * @param status for errors if it occurs
409 * @see #usearch_getAttribute
410 * @stable ICU 2.4
411 */
412 U_STABLE void U_EXPORT2 usearch_setAttribute(UStringSearch         *strsrch,
413                                            USearchAttribute       attribute,
414                                            USearchAttributeValue  value,
415                                            UErrorCode            *status);
416 
417 /**
418 * Gets the text searching attributes.
419 * @param strsrch search iterator data struct
420 * @param attribute text attribute to be retrieve
421 * @return text attribute value
422 * @see #usearch_setAttribute
423 * @stable ICU 2.4
424 */
425 U_STABLE USearchAttributeValue U_EXPORT2 usearch_getAttribute(
426                                          const UStringSearch    *strsrch,
427                                                USearchAttribute  attribute);
428 
429 /**
430 * Returns the index to the match in the text string that was searched.
431 * This call returns a valid result only after a successful call to
432 * &lt;tt&gt;usearch_first&lt;/tt&gt;, &lt;tt&gt;usearch_next&lt;/tt&gt;, &lt;tt&gt;usearch_previous&lt;/tt&gt;,
433 * or &lt;tt&gt;usearch_last&lt;/tt&gt;.
434 * Just after construction, or after a searching method returns
435 * &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;, this method will return &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;.
436 * &lt;p&gt;
437 * Use &lt;tt&gt;usearch_getMatchedLength&lt;/tt&gt; to get the matched string length.
438 * @param strsrch search iterator data struct
439 * @return index to a substring within the text string that is being
440 *         searched.
441 * @see #usearch_first
442 * @see #usearch_next
443 * @see #usearch_previous
444 * @see #usearch_last
445 * @see #USEARCH_DONE
446 * @stable ICU 2.4
447 */
448 U_STABLE int32_t U_EXPORT2 usearch_getMatchedStart(
449                                                const UStringSearch *strsrch);
450 
451 /**
452 * Returns the length of text in the string which matches the search pattern.
453 * This call returns a valid result only after a successful call to
454 * &lt;tt&gt;usearch_first&lt;/tt&gt;, &lt;tt&gt;usearch_next&lt;/tt&gt;, &lt;tt&gt;usearch_previous&lt;/tt&gt;,
455 * or &lt;tt&gt;usearch_last&lt;/tt&gt;.
456 * Just after construction, or after a searching method returns
457 * &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;, this method will return 0.
458 * @param strsrch search iterator data struct
459 * @return The length of the match in the string text, or 0 if there is no
460 *         match currently.
461 * @see #usearch_first
462 * @see #usearch_next
463 * @see #usearch_previous
464 * @see #usearch_last
465 * @see #USEARCH_DONE
466 * @stable ICU 2.4
467 */
468 U_STABLE int32_t U_EXPORT2 usearch_getMatchedLength(
469                                                const UStringSearch *strsrch);
470 
471 /**
472 * Returns the text that was matched by the most recent call to
473 * &lt;tt&gt;usearch_first&lt;/tt&gt;, &lt;tt&gt;usearch_next&lt;/tt&gt;, &lt;tt&gt;usearch_previous&lt;/tt&gt;,
474 * or &lt;tt&gt;usearch_last&lt;/tt&gt;.
475 * If the iterator is not pointing at a valid match (e.g. just after
476 * construction or after &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; has been returned, returns
477 * an empty string. If result is not large enough to store the matched text,
478 * result will be filled with the partial text and an U_BUFFER_OVERFLOW_ERROR
479 * will be returned in status. result will be null-terminated whenever
480 * possible. If the buffer fits the matched text exactly, a null-termination
481 * is not possible, then a U_STRING_NOT_TERMINATED_ERROR set in status.
482 * Pre-flighting can be either done with length = 0 or the API
483 * &lt;tt&gt;usearch_getMatchLength&lt;/tt&gt;.
484 * @param strsrch search iterator data struct
485 * @param result UChar buffer to store the matched string
486 * @param resultCapacity length of the result buffer
487 * @param status error returned if result is not large enough
488 * @return exact length of the matched text, not counting the null-termination
489 * @see #usearch_first
490 * @see #usearch_next
491 * @see #usearch_previous
492 * @see #usearch_last
493 * @see #USEARCH_DONE
494 * @stable ICU 2.4
495 */
496 U_STABLE int32_t U_EXPORT2 usearch_getMatchedText(const UStringSearch *strsrch,
497                                             UChar         *result,
498                                             int32_t        resultCapacity,
499                                             UErrorCode    *status);
500 
501 #if !UCONFIG_NO_BREAK_ITERATION
502 
503 /**
504 * Set the BreakIterator that will be used to restrict the points at which
505 * matches are detected.
506 * @param strsrch search iterator data struct
507 * @param breakiter A BreakIterator that will be used to restrict the points
508 *                  at which matches are detected. If a match is found, but
509 *                  the match&#39;s start or end index is not a boundary as
510 *                  determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt;, the match will
511 *                  be rejected and another will be searched for.
512 *                  If this parameter is &lt;tt&gt;NULL&lt;/tt&gt;, no break detection is
513 *                  attempted.
514 * @param status for errors if it occurs
515 * @see #usearch_getBreakIterator
516 * @stable ICU 2.4
517 */
518 U_STABLE void U_EXPORT2 usearch_setBreakIterator(UStringSearch  *strsrch,
519                                                UBreakIterator *breakiter,
520                                                UErrorCode     *status);
521 
522 /**
523 * Returns the BreakIterator that is used to restrict the points at which
524 * matches are detected. This will be the same object that was passed to the
525 * constructor or to &lt;tt&gt;usearch_setBreakIterator&lt;/tt&gt;. Note that
526 * &lt;tt&gt;NULL&lt;/tt&gt;
527 * is a legal value; it means that break detection should not be attempted.
528 * @param strsrch search iterator data struct
529 * @return break iterator used
530 * @see #usearch_setBreakIterator
531 * @stable ICU 2.4
532 */
533 U_STABLE const UBreakIterator * U_EXPORT2 usearch_getBreakIterator(
534                                               const UStringSearch *strsrch);
535 
536 #endif
537 
538 /**
539 * Set the string text to be searched. Text iteration will hence begin at the
540 * start of the text string. This method is useful if you want to re-use an
541 * iterator to search for the same pattern within a different body of text.
542 * @param strsrch search iterator data struct
543 * @param text new string to look for match
544 * @param textlength length of the new string, -1 for null-termination
545 * @param status for errors if it occurs. If text is NULL, or textlength is 0
546 *               then an U_ILLEGAL_ARGUMENT_ERROR is returned with no change
547 *               done to strsrch.
548 * @see #usearch_getText
549 * @stable ICU 2.4
550 */
551 U_STABLE void U_EXPORT2 usearch_setText(      UStringSearch *strsrch,
552                                       const UChar         *text,
553                                             int32_t        textlength,
554                                             UErrorCode    *status);
555 
556 /**
557 * Return the string text to be searched.
558 * @param strsrch search iterator data struct
559 * @param length returned string text length
560 * @return string text
561 * @see #usearch_setText
562 * @stable ICU 2.4
563 */
564 U_STABLE const UChar * U_EXPORT2 usearch_getText(const UStringSearch *strsrch,
565                                                int32_t       *length);
566 
567 /**
568 * Gets the collator used for the language rules.
569 * &lt;p&gt;
570 * Deleting the returned &lt;tt&gt;UCollator&lt;/tt&gt; before calling
571 * &lt;tt&gt;usearch_close&lt;/tt&gt; would cause the string search to fail.
572 * &lt;tt&gt;usearch_close&lt;/tt&gt; will delete the collator if this search owns it.
573 * @param strsrch search iterator data struct
574 * @return collator
575 * @stable ICU 2.4
576 */
577 U_STABLE UCollator * U_EXPORT2 usearch_getCollator(
578                                                const UStringSearch *strsrch);
579 
580 /**
581 * Sets the collator used for the language rules. User retains the ownership
582 * of this collator, thus the responsibility of deletion lies with the user.
583 * This method causes internal data such as Boyer-Moore shift tables to
584 * be recalculated, but the iterator&#39;s position is unchanged.
585 * @param strsrch search iterator data struct
586 * @param collator to be used
587 * @param status for errors if it occurs
588 * @stable ICU 2.4
589 */
590 U_STABLE void U_EXPORT2 usearch_setCollator(      UStringSearch *strsrch,
591                                           const UCollator     *collator,
592                                                 UErrorCode    *status);
593 
594 /**
595 * Sets the pattern used for matching.
596 * Internal data like the Boyer Moore table will be recalculated, but the
597 * iterator&#39;s position is unchanged.
598 * @param strsrch search iterator data struct
599 * @param pattern string
600 * @param patternlength pattern length, -1 for null-terminated string
601 * @param status for errors if it occurs. If text is NULL, or textlength is 0
602 *               then an U_ILLEGAL_ARGUMENT_ERROR is returned with no change
603 *               done to strsrch.
604 * @stable ICU 2.4
605 */
606 U_STABLE void U_EXPORT2 usearch_setPattern(      UStringSearch *strsrch,
607                                          const UChar         *pattern,
608                                                int32_t        patternlength,
609                                                UErrorCode    *status);
610 
611 /**
612 * Gets the search pattern
613 * @param strsrch search iterator data struct
614 * @param length return length of the pattern, -1 indicates that the pattern
615 *               is null-terminated
616 * @return pattern string
617 * @stable ICU 2.4
618 */
619 U_STABLE const UChar * U_EXPORT2 usearch_getPattern(
620                                                const UStringSearch *strsrch,
621                                                      int32_t       *length);
622 
623 /* methods ------------------------------------------------------------- */
624 
625 /**
626 * Returns the first index at which the string text matches the search
627 * pattern.
628 * The iterator is adjusted so that its current index (as returned by
629 * &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if one was found.
630 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
631 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;.
632 * @param strsrch search iterator data struct
633 * @param status for errors if it occurs
634 * @return The character index of the first match, or
635 * &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no matches.
636 * @see #usearch_getOffset
637 * @see #USEARCH_DONE
638 * @stable ICU 2.4
639 */
640 U_STABLE int32_t U_EXPORT2 usearch_first(UStringSearch *strsrch,
641                                            UErrorCode    *status);
642 
643 /**
644 * Returns the first index equal or greater than &lt;tt&gt;position&lt;/tt&gt; at which
645 * the string text
646 * matches the search pattern. The iterator is adjusted so that its current
647 * index (as returned by &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if
648 * one was found.
649 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
650 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;
651 * &lt;p&gt;
652 * Search positions that may render incorrect results are highlighted in the
653 * header comments. If position is less than or greater than the text range
654 * for searching, an U_INDEX_OUTOFBOUNDS_ERROR will be returned
655 * @param strsrch search iterator data struct
656 * @param position to start the search at
657 * @param status for errors if it occurs
658 * @return The character index of the first match following &lt;tt&gt;pos&lt;/tt&gt;,
659 *         or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no matches.
660 * @see #usearch_getOffset
661 * @see #USEARCH_DONE
662 * @stable ICU 2.4
663 */
664 U_STABLE int32_t U_EXPORT2 usearch_following(UStringSearch *strsrch,
665                                                int32_t    position,
666                                                UErrorCode    *status);
667 
668 /**
669 * Returns the last index in the target text at which it matches the search
670 * pattern. The iterator is adjusted so that its current
671 * index (as returned by &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if
672 * one was found.
673 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
674 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;.
675 * @param strsrch search iterator data struct
676 * @param status for errors if it occurs
677 * @return The index of the first match, or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there
678 *         are no matches.
679 * @see #usearch_getOffset
680 * @see #USEARCH_DONE
681 * @stable ICU 2.4
682 */
683 U_STABLE int32_t U_EXPORT2 usearch_last(UStringSearch *strsrch,
684                                           UErrorCode    *status);
685 
686 /**
687 * Returns the first index less than &lt;tt&gt;position&lt;/tt&gt; at which the string text
688 * matches the search pattern. The iterator is adjusted so that its current
689 * index (as returned by &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if
690 * one was found.
691 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
692 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;
693 * &lt;p&gt;
694 * Search positions that may render incorrect results are highlighted in the
695 * header comments. If position is less than or greater than the text range
696 * for searching, an U_INDEX_OUTOFBOUNDS_ERROR will be returned.
697 * &lt;p&gt;
698 * When &lt;tt&gt;USEARCH_OVERLAP&lt;/tt&gt; option is off, the last index of the
699 * result match is always less than &lt;tt&gt;position&lt;/tt&gt;.
700 * When &lt;tt&gt;USERARCH_OVERLAP&lt;/tt&gt; is on, the result match may span across
701 * &lt;tt&gt;position&lt;/tt&gt;.
702 * @param strsrch search iterator data struct
703 * @param position index position the search is to begin at
704 * @param status for errors if it occurs
705 * @return The character index of the first match preceding &lt;tt&gt;pos&lt;/tt&gt;,
706 *         or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no matches.
707 * @see #usearch_getOffset
708 * @see #USEARCH_DONE
709 * @stable ICU 2.4
710 */
711 U_STABLE int32_t U_EXPORT2 usearch_preceding(UStringSearch *strsrch,
712                                                int32_t    position,
713                                                UErrorCode    *status);
714 
715 /**
716 * Returns the index of the next point at which the string text matches the
717 * search pattern, starting from the current position.
718 * The iterator is adjusted so that its current
719 * index (as returned by &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if
720 * one was found.
721 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
722 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;
723 * @param strsrch search iterator data struct
724 * @param status for errors if it occurs
725 * @return The index of the next match after the current position, or
726 *         &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no more matches.
727 * @see #usearch_first
728 * @see #usearch_getOffset
729 * @see #USEARCH_DONE
730 * @stable ICU 2.4
731 */
732 U_STABLE int32_t U_EXPORT2 usearch_next(UStringSearch *strsrch,
733                                           UErrorCode    *status);
734 
735 /**
736 * Returns the index of the previous point at which the string text matches
737 * the search pattern, starting at the current position.
738 * The iterator is adjusted so that its current
739 * index (as returned by &lt;tt&gt;usearch_getOffset&lt;/tt&gt;) is the match position if
740 * one was found.
741 * If a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and
742 * the iterator will be adjusted to the index &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;
743 * @param strsrch search iterator data struct
744 * @param status for errors if it occurs
745 * @return The index of the previous match before the current position,
746 *         or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no more matches.
747 * @see #usearch_last
748 * @see #usearch_getOffset
749 * @see #USEARCH_DONE
750 * @stable ICU 2.4
751 */
752 U_STABLE int32_t U_EXPORT2 usearch_previous(UStringSearch *strsrch,
753                                               UErrorCode    *status);
754 
755 /**
756 * Reset the iteration.
757 * Search will begin at the start of the text string if a forward iteration
758 * is initiated before a backwards iteration. Otherwise if a backwards
759 * iteration is initiated before a forwards iteration, the search will begin
760 * at the end of the text string.
761 * @param strsrch search iterator data struct
762 * @see #usearch_first
763 * @stable ICU 2.4
764 */
765 U_STABLE void U_EXPORT2 usearch_reset(UStringSearch *strsrch);
766 
767 #ifndef U_HIDE_INTERNAL_API
768 /**
769   *  Simple forward search for the pattern, starting at a specified index,
770   *     and using using a default set search options.
771   *
772   *  This is an experimental function, and is not an official part of the
773   *      ICU API.
774   *
775   *  The collator options, such as UCOL_STRENGTH and UCOL_NORMALIZTION, are honored.
776   *
777   *  The UStringSearch options USEARCH_CANONICAL_MATCH, USEARCH_OVERLAP and
778   *  any Break Iterator are ignored.
779   *
780   *  Matches obey the following constraints:
781   *
782   *      Characters at the start or end positions of a match that are ignorable
783   *      for collation are not included as part of the match, unless they
784   *      are part of a combining sequence, as described below.
785   *
786   *      A match will not include a partial combining sequence.  Combining
787   *      character sequences  are considered to be  inseperable units,
788   *      and either match the pattern completely, or are considered to not match
789   *      at all.  Thus, for example, an A followed a combining accent mark will
790   *      not be found when searching for a plain (unaccented) A.   (unless
791   *      the collation strength has been set to ignore all accents).
792   *
793   *      When beginning a search, the initial starting position, startIdx,
794   *      is assumed to be an acceptable match boundary with respect to
795   *      combining characters.  A combining sequence that spans across the
796   *      starting point will not supress a match beginning at startIdx.
797   *
798   *      Characters that expand to multiple collation elements
799   *      (German sharp-S becoming &#39;ss&#39;, or the composed forms of accented
800   *      characters, for example) also must match completely.
801   *      Searching for a single &#39;s&#39; in a string containing only a sharp-s will
802   *      find no match.
803   *
804   *
805   *  @param strsrch    the UStringSearch struct, which references both
806   *                    the text to be searched  and the pattern being sought.
807   *  @param startIdx   The index into the text to begin the search.
808   *  @param matchStart An out parameter, the starting index of the matched text.
809   *                    This parameter may be NULL.
810   *                    A value of -1 will be returned if no match was found.
811   *  @param matchLimit Out parameter, the index of the first position following the matched text.
812   *                    The matchLimit will be at a suitable position for beginning a subsequent search
813   *                    in the input text.
814   *                    This parameter may be NULL.
815   *                    A value of -1 will be returned if no match was found.
816   *
817   *  @param status     Report any errors.  Note that no match found is not an error.
818   *  @return           TRUE if a match was found, FALSE otherwise.
819   *
820   *  @internal
821   */
822 U_INTERNAL UBool U_EXPORT2 usearch_search(UStringSearch *strsrch,
823                                           int32_t        startIdx,
824                                           int32_t        *matchStart,
825                                           int32_t        *matchLimit,
826                                           UErrorCode     *status);
827 
828 /**
829   *  Simple backwards search for the pattern, starting at a specified index,
830   *     and using using a default set search options.
831   *
832   *  This is an experimental function, and is not an official part of the
833   *      ICU API.
834   *
835   *  The collator options, such as UCOL_STRENGTH and UCOL_NORMALIZTION, are honored.
836   *
837   *  The UStringSearch options USEARCH_CANONICAL_MATCH, USEARCH_OVERLAP and
838   *  any Break Iterator are ignored.
839   *
840   *  Matches obey the following constraints:
841   *
842   *      Characters at the start or end positions of a match that are ignorable
843   *      for collation are not included as part of the match, unless they
844   *      are part of a combining sequence, as described below.
845   *
846   *      A match will not include a partial combining sequence.  Combining
847   *      character sequences  are considered to be  inseperable units,
848   *      and either match the pattern completely, or are considered to not match
849   *      at all.  Thus, for example, an A followed a combining accent mark will
850   *      not be found when searching for a plain (unaccented) A.   (unless
851   *      the collation strength has been set to ignore all accents).
852   *
853   *      When beginning a search, the initial starting position, startIdx,
854   *      is assumed to be an acceptable match boundary with respect to
855   *      combining characters.  A combining sequence that spans across the
856   *      starting point will not supress a match beginning at startIdx.
857   *
858   *      Characters that expand to multiple collation elements
859   *      (German sharp-S becoming &#39;ss&#39;, or the composed forms of accented
860   *      characters, for example) also must match completely.
861   *      Searching for a single &#39;s&#39; in a string containing only a sharp-s will
862   *      find no match.
863   *
864   *
865   *  @param strsrch    the UStringSearch struct, which references both
866   *                    the text to be searched  and the pattern being sought.
867   *  @param startIdx   The index into the text to begin the search.
868   *  @param matchStart An out parameter, the starting index of the matched text.
869   *                    This parameter may be NULL.
870   *                    A value of -1 will be returned if no match was found.
871   *  @param matchLimit Out parameter, the index of the first position following the matched text.
872   *                    The matchLimit will be at a suitable position for beginning a subsequent search
873   *                    in the input text.
874   *                    This parameter may be NULL.
875   *                    A value of -1 will be returned if no match was found.
876   *
877   *  @param status     Report any errors.  Note that no match found is not an error.
878   *  @return           TRUE if a match was found, FALSE otherwise.
879   *
880   *  @internal
881   */
882 U_INTERNAL UBool U_EXPORT2 usearch_searchBackwards(UStringSearch *strsrch,
883                                                    int32_t        startIdx,
884                                                    int32_t        *matchStart,
885                                                    int32_t        *matchLimit,
886                                                    UErrorCode     *status);
887 #endif  /* U_HIDE_INTERNAL_API */
888 
889 #endif /* #if !UCONFIG_NO_COLLATION  &amp;&amp; !UCONFIG_NO_BREAK_ITERATION */
890 
891 #endif
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>