<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/numberformatter.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="nounit.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="numfmt.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/numberformatter.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 9,13 ***</span>
<span class="line-new-header">--- 9,15 ---</span>
  
  #include &quot;unicode/appendable.h&quot;
  #include &quot;unicode/dcfmtsym.h&quot;
  #include &quot;unicode/currunit.h&quot;
  #include &quot;unicode/fieldpos.h&quot;
<span class="line-added">+ #include &quot;unicode/formattedvalue.h&quot;</span>
  #include &quot;unicode/fpositer.h&quot;
  #include &quot;unicode/measunit.h&quot;
  #include &quot;unicode/nounit.h&quot;
<span class="line-added">+ #include &quot;unicode/parseerr.h&quot;</span>
  #include &quot;unicode/plurrule.h&quot;
  #include &quot;unicode/ucurr.h&quot;
  #include &quot;unicode/unum.h&quot;
  #include &quot;unicode/unumberformatter.h&quot;
  #include &quot;unicode/uobject.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,29 ***</span>
   *     .precision(Precision::maxDigits(2))
   *     .locale(...)
   *     .format(1234)
   *     .toString();  // €1.2K in en-US
   *
<span class="line-modified">!  * // Create a formatter in a singleton for use later:</span>
   * static const LocalizedNumberFormatter formatter = NumberFormatter::withLocale(...)
   *     .unit(NoUnit::percent())
   *     .precision(Precision::fixedFraction(3));
   * formatter.format(5.9831).toString();  // 5.983% in en-US
   *
<span class="line-modified">!  * // Create a &quot;template&quot; in a singleton but without setting a locale until the call site:</span>
<span class="line-modified">!  * static const UnlocalizedNumberFormatter template = NumberFormatter::with()</span>
   *     .sign(UNumberSignDisplay::UNUM_SIGN_ALWAYS)
<span class="line-modified">!  *     .adoptUnit(MeasureUnit::createMeter(status))</span>
<span class="line-modified">!  *     .unitWidth(UNumberUnitWidth::UNUM_UNIT_WIDTH_FULL_NAME);</span>
<span class="line-modified">!  * template.locale(...).format(1234).toString();  // +1,234 meters in en-US</span>
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * This API offers more features than DecimalFormat and is geared toward new users of ICU.
   *
   * &lt;p&gt;
<span class="line-modified">!  * NumberFormatter instances are immutable and thread safe. This means that invoking a configuration method has no</span>
   * effect on the receiving instance; you must store and use the new number formatter instance it returns instead.
   *
   * &lt;pre&gt;
   * UnlocalizedNumberFormatter formatter = UnlocalizedNumberFormatter::with().notation(Notation::scientific());
   * formatter.precision(Precision.maxFraction(2)); // does nothing!
<span class="line-new-header">--- 42,31 ---</span>
   *     .precision(Precision::maxDigits(2))
   *     .locale(...)
   *     .format(1234)
   *     .toString();  // €1.2K in en-US
   *
<span class="line-modified">!  * // Create a formatter in a singleton by value for use later:</span>
   * static const LocalizedNumberFormatter formatter = NumberFormatter::withLocale(...)
   *     .unit(NoUnit::percent())
   *     .precision(Precision::fixedFraction(3));
   * formatter.format(5.9831).toString();  // 5.983% in en-US
   *
<span class="line-modified">!  * // Create a &quot;template&quot; in a singleton unique_ptr but without setting a locale until the call site:</span>
<span class="line-modified">!  * std::unique_ptr&lt;UnlocalizedNumberFormatter&gt; template = NumberFormatter::with()</span>
   *     .sign(UNumberSignDisplay::UNUM_SIGN_ALWAYS)
<span class="line-modified">!  *     .unit(MeasureUnit::getMeter())</span>
<span class="line-modified">!  *     .unitWidth(UNumberUnitWidth::UNUM_UNIT_WIDTH_FULL_NAME)</span>
<span class="line-modified">!  *     .clone();</span>
<span class="line-added">+  * template-&gt;locale(...).format(1234).toString();  // +1,234 meters in en-US</span>
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * This API offers more features than DecimalFormat and is geared toward new users of ICU.
   *
   * &lt;p&gt;
<span class="line-modified">!  * NumberFormatter instances (i.e., LocalizedNumberFormatter and UnlocalizedNumberFormatter)</span>
<span class="line-added">+  * are immutable and thread safe. This means that invoking a configuration method has no</span>
   * effect on the receiving instance; you must store and use the new number formatter instance it returns instead.
   *
   * &lt;pre&gt;
   * UnlocalizedNumberFormatter formatter = UnlocalizedNumberFormatter::with().notation(Notation::scientific());
   * formatter.precision(Precision.maxFraction(2)); // does nothing!
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,31 ***</span>
  class IncrementPrecision;
  class IntegerWidth;
  
  namespace impl {
  
  /**
   * Datatype for minimum/maximum fraction digits. Must be able to hold kMaxIntFracSig.
   *
   * @internal
   */
  typedef int16_t digits_t;
  
  /**
   * Use a default threshold of 3. This means that the third time .format() is called, the data structures get built
   * using the &quot;safe&quot; code path. The first two calls to .format() will trigger the unsafe code path.
   *
   * @internal
   */
<span class="line-modified">! static constexpr int32_t DEFAULT_THRESHOLD = 3;</span>
  
  // Forward declarations:
  class Padder;
  struct MacroProps;
  struct MicroProps;
  class DecimalQuantity;
<span class="line-modified">! struct UFormattedNumberData;</span>
  class NumberFormatterImpl;
  struct ParsedPatternInfo;
  class ScientificModifier;
  class MultiplierProducer;
  class RoundingImpl;
<span class="line-new-header">--- 110,33 ---</span>
  class IncrementPrecision;
  class IntegerWidth;
  
  namespace impl {
  
<span class="line-added">+ // can&#39;t be #ifndef U_HIDE_INTERNAL_API; referenced throughout this file in public classes</span>
  /**
   * Datatype for minimum/maximum fraction digits. Must be able to hold kMaxIntFracSig.
   *
   * @internal
   */
  typedef int16_t digits_t;
  
<span class="line-added">+ // can&#39;t be #ifndef U_HIDE_INTERNAL_API; needed for struct initialization</span>
  /**
   * Use a default threshold of 3. This means that the third time .format() is called, the data structures get built
   * using the &quot;safe&quot; code path. The first two calls to .format() will trigger the unsafe code path.
   *
   * @internal
   */
<span class="line-modified">! static constexpr int32_t kInternalDefaultThreshold = 3;</span>
  
  // Forward declarations:
  class Padder;
  struct MacroProps;
  struct MicroProps;
  class DecimalQuantity;
<span class="line-modified">! class UFormattedNumberData;</span>
  class NumberFormatterImpl;
  struct ParsedPatternInfo;
  class ScientificModifier;
  class MultiplierProducer;
  class RoundingImpl;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,15 ***</span>
  struct DecimalFormatProperties;
  class MultiplierFormatHandler;
  class CurrencySymbols;
  class GeneratorHelpers;
  class DecNum;
  
  } // namespace impl
  
<span class="line-modified">! // Reserve extra names in case they are added as classes in the future:</span>
  typedef Notation CompactNotation;
  typedef Notation SimpleNotation;
  
  /**
   * A class that defines the notation style to be used when formatting numbers in NumberFormatter.
   *
<span class="line-new-header">--- 148,36 ---</span>
  struct DecimalFormatProperties;
  class MultiplierFormatHandler;
  class CurrencySymbols;
  class GeneratorHelpers;
  class DecNum;
<span class="line-added">+ class NumberRangeFormatterImpl;</span>
<span class="line-added">+ struct RangeMacroProps;</span>
<span class="line-added">+ struct UFormattedNumberImpl;</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * Used for NumberRangeFormatter and implemented in numrange_fluent.cpp.</span>
<span class="line-added">+  * Declared here so it can be friended.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @internal</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void touchRangeLocales(impl::RangeMacroProps&amp; macros);</span>
  
  } // namespace impl
  
<span class="line-modified">! /**</span>
<span class="line-added">+  * Extra name reserved in case it is needed in the future.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @draft ICU 63</span>
<span class="line-added">+  */</span>
  typedef Notation CompactNotation;
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * Extra name reserved in case it is needed in the future.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @draft ICU 63</span>
<span class="line-added">+  */</span>
  typedef Notation SimpleNotation;
  
  /**
   * A class that defines the notation style to be used when formatting numbers in NumberFormatter.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 306,14 ***</span>
<span class="line-new-header">--- 333,19 ---</span>
          NTN_SCIENTIFIC, NTN_COMPACT, NTN_SIMPLE, NTN_ERROR
      } fType;
  
      union NotationUnion {
          // For NTN_SCIENTIFIC
<span class="line-added">+         /** @internal */</span>
          struct ScientificSettings {
<span class="line-added">+             /** @internal */</span>
              int8_t fEngineeringInterval;
<span class="line-added">+             /** @internal */</span>
              bool fRequireMinInt;
<span class="line-added">+             /** @internal */</span>
              impl::digits_t fMinExponentDigits;
<span class="line-added">+             /** @internal */</span>
              UNumberSignDisplay fExponentSignDisplay;
          } scientific;
  
          // For NTN_COMPACT
          UNumberCompactStyle compactStyle;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 405,21 ***</span>
  
      // So that NumberPropertyMapper can create instances
      friend class impl::NumberPropertyMapper;
  };
  
<span class="line-modified">! // Reserve extra names in case they are added as classes in the future:</span>
  typedef Precision SignificantDigitsPrecision;
  
<span class="line-removed">- // Typedefs for ICU 60/61 compatibility.</span>
<span class="line-removed">- // These will be removed in ICU 64.</span>
<span class="line-removed">- // See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">- typedef Precision Rounder;</span>
<span class="line-removed">- typedef FractionPrecision FractionRounder;</span>
<span class="line-removed">- typedef IncrementPrecision IncrementRounder;</span>
<span class="line-removed">- typedef CurrencyPrecision CurrencyRounder;</span>
<span class="line-removed">- </span>
  /**
   * A class that defines the rounding precision to be used when formatting numbers in NumberFormatter.
   *
   * &lt;p&gt;
   * To create a Precision, use one of the factory methods.
<span class="line-new-header">--- 437,17 ---</span>
  
      // So that NumberPropertyMapper can create instances
      friend class impl::NumberPropertyMapper;
  };
  
<span class="line-modified">! /**</span>
<span class="line-added">+  * Extra name reserved in case it is needed in the future.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @draft ICU 63</span>
<span class="line-added">+  */</span>
  typedef Precision SignificantDigitsPrecision;
  
  /**
   * A class that defines the rounding precision to be used when formatting numbers in NumberFormatter.
   *
   * &lt;p&gt;
   * To create a Precision, use one of the factory methods.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 432,14 ***</span>
      /**
       * Show all available digits to full precision.
       *
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; When formatting a &lt;em&gt;double&lt;/em&gt;, this method, along with {@link #minFraction} and
<span class="line-modified">!      * {@link #minDigits}, will trigger complex algorithm similar to &lt;em&gt;Dragon4&lt;/em&gt; to determine the low-order digits</span>
<span class="line-modified">!      * and the number of digits to display based on the value of the double. If the number of fraction places or</span>
<span class="line-modified">!      * significant digits can be bounded, consider using {@link #maxFraction} or {@link #maxDigits} instead to maximize</span>
<span class="line-modified">!      * performance. For more information, read the following blog post.</span>
       *
       * &lt;p&gt;
       * http://www.serpentine.com/blog/2011/06/29/here-be-dragons-advances-in-problems-you-didnt-even-know-you-had/
       *
       * @return A Precision for chaining or passing to the NumberFormatter precision() setter.
<span class="line-new-header">--- 460,15 ---</span>
      /**
       * Show all available digits to full precision.
       *
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; When formatting a &lt;em&gt;double&lt;/em&gt;, this method, along with {@link #minFraction} and
<span class="line-modified">!      * {@link #minSignificantDigits}, will trigger complex algorithm similar to &lt;em&gt;Dragon4&lt;/em&gt; to determine the</span>
<span class="line-modified">!      * low-order digits and the number of digits to display based on the value of the double.</span>
<span class="line-modified">!      * If the number of fraction places or significant digits can be bounded, consider using {@link #maxFraction}</span>
<span class="line-modified">!      * or {@link #maxSignificantDigits} instead to maximize performance.</span>
<span class="line-added">+      * For more information, read the following blog post.</span>
       *
       * &lt;p&gt;
       * http://www.serpentine.com/blog/2011/06/29/here-be-dragons-advances-in-problems-you-didnt-even-know-you-had/
       *
       * @return A Precision for chaining or passing to the NumberFormatter precision() setter.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,11 ***</span>
      /**
       * Show numbers rounded if necessary to a certain number of significant digits or significant figures. Additionally,
       * pad with zeros to ensure that this number of significant digits/figures are always shown.
       *
       * &lt;p&gt;
<span class="line-modified">!      * This method is equivalent to {@link #minMaxDigits} with both arguments equal.</span>
       *
       * @param minMaxSignificantDigits
       *            The minimum and maximum number of significant digits to display (rounding if too long or padding with
       *            zeros if too short).
       * @return A precision for chaining or passing to the NumberFormatter precision() setter.
<span class="line-new-header">--- 558,11 ---</span>
      /**
       * Show numbers rounded if necessary to a certain number of significant digits or significant figures. Additionally,
       * pad with zeros to ensure that this number of significant digits/figures are always shown.
       *
       * &lt;p&gt;
<span class="line-modified">!      * This method is equivalent to {@link #minMaxSignificantDigits} with both arguments equal.</span>
       *
       * @param minMaxSignificantDigits
       *            The minimum and maximum number of significant digits to display (rounding if too long or padding with
       *            zeros if too short).
       * @return A precision for chaining or passing to the NumberFormatter precision() setter.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 577,35 ***</span>
       * @draft ICU 62
       */
      static SignificantDigitsPrecision minMaxSignificantDigits(int32_t minSignificantDigits,
                                                                int32_t maxSignificantDigits);
  
<span class="line-removed">- #ifndef U_HIDE_DEPRECATED_API</span>
<span class="line-removed">-     // Compatiblity methods that will be removed in ICU 64.</span>
<span class="line-removed">-     // See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** @deprecated ICU 62 */</span>
<span class="line-removed">-     static inline SignificantDigitsPrecision fixedDigits(int32_t a) {</span>
<span class="line-removed">-         return fixedSignificantDigits(a);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** @deprecated ICU 62 */</span>
<span class="line-removed">-     static inline SignificantDigitsPrecision minDigits(int32_t a) {</span>
<span class="line-removed">-         return minSignificantDigits(a);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** @deprecated ICU 62 */</span>
<span class="line-removed">-     static inline SignificantDigitsPrecision maxDigits(int32_t a) {</span>
<span class="line-removed">-         return maxSignificantDigits(a);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** @deprecated ICU 62 */</span>
<span class="line-removed">-     static inline SignificantDigitsPrecision minMaxDigits(int32_t a, int32_t b) {</span>
<span class="line-removed">-         return minMaxSignificantDigits(a, b);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif  /* U_HIDE_DEPRECATED_API */</span>
<span class="line-removed">- </span>
      /**
       * Show numbers rounded if necessary to the closest multiple of a certain rounding increment. For example, if the
       * rounding increment is 0.5, then round 1.2 to 1 and round 1.3 to 1.5.
       *
       * &lt;p&gt;
<span class="line-new-header">--- 606,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 642,50 ***</span>
       * @return A CurrencyPrecision for chaining or passing to the NumberFormatter precision() setter.
       * @draft ICU 60
       */
      static CurrencyPrecision currency(UCurrencyUsage currencyUsage);
  
<span class="line-removed">- #ifndef U_HIDE_DEPRECATED_API</span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Sets the rounding mode to use when picking the direction to round (up or down). Common values</span>
<span class="line-removed">-      * include HALF_EVEN, HALF_UP, and FLOOR. The default is HALF_EVEN.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param roundingMode</span>
<span class="line-removed">-      *            The RoundingMode to use.</span>
<span class="line-removed">-      * @return A Precision for passing to the NumberFormatter precision() setter.</span>
<span class="line-removed">-      * @deprecated ICU 62 Use the top-level roundingMode() setting instead.</span>
<span class="line-removed">-      *            This method will be removed in ICU 64.</span>
<span class="line-removed">-      *            See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     Precision withMode(UNumberFormatRoundingMode roundingMode) const;</span>
<span class="line-removed">- #endif  /* U_HIDE_DEPRECATED_API */</span>
<span class="line-removed">- </span>
    private:
      enum PrecisionType {
          RND_BOGUS,
          RND_NONE,
          RND_FRACTION,
          RND_SIGNIFICANT,
          RND_FRACTION_SIGNIFICANT,
          RND_INCREMENT,
          RND_CURRENCY,
          RND_ERROR
      } fType;
  
      union PrecisionUnion {
          struct FractionSignificantSettings {
              // For RND_FRACTION, RND_SIGNIFICANT, and RND_FRACTION_SIGNIFICANT
              impl::digits_t fMinFrac;
              impl::digits_t fMaxFrac;
              impl::digits_t fMinSig;
              impl::digits_t fMaxSig;
          } fracSig;
          struct IncrementSettings {
              double fIncrement;
              impl::digits_t fMinFrac;
              impl::digits_t fMaxFrac;
<span class="line-modified">!         } increment; // For RND_INCREMENT</span>
          UCurrencyUsage currencyUsage; // For RND_CURRENCY
          UErrorCode errorCode; // For RND_ERROR
      } fUnion;
  
      typedef PrecisionUnion::FractionSignificantSettings FractionSignificantSettings;
<span class="line-new-header">--- 646,56 ---</span>
       * @return A CurrencyPrecision for chaining or passing to the NumberFormatter precision() setter.
       * @draft ICU 60
       */
      static CurrencyPrecision currency(UCurrencyUsage currencyUsage);
  
    private:
      enum PrecisionType {
          RND_BOGUS,
          RND_NONE,
          RND_FRACTION,
          RND_SIGNIFICANT,
          RND_FRACTION_SIGNIFICANT,
<span class="line-added">+ </span>
<span class="line-added">+         // Used for strange increments like 3.14.</span>
          RND_INCREMENT,
<span class="line-added">+ </span>
<span class="line-added">+         // Used for increments with 1 as the only digit. This is different than fraction</span>
<span class="line-added">+         // rounding because it supports having additional trailing zeros. For example, this</span>
<span class="line-added">+         // class is used to round with the increment 0.010.</span>
<span class="line-added">+         RND_INCREMENT_ONE,</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Used for increments with 5 as the only digit (nickel rounding).</span>
<span class="line-added">+         RND_INCREMENT_FIVE,</span>
<span class="line-added">+ </span>
          RND_CURRENCY,
          RND_ERROR
      } fType;
  
      union PrecisionUnion {
<span class="line-added">+         /** @internal */</span>
          struct FractionSignificantSettings {
              // For RND_FRACTION, RND_SIGNIFICANT, and RND_FRACTION_SIGNIFICANT
<span class="line-added">+             /** @internal */</span>
              impl::digits_t fMinFrac;
<span class="line-added">+             /** @internal */</span>
              impl::digits_t fMaxFrac;
<span class="line-added">+             /** @internal */</span>
              impl::digits_t fMinSig;
<span class="line-added">+             /** @internal */</span>
              impl::digits_t fMaxSig;
          } fracSig;
<span class="line-added">+         /** @internal */</span>
          struct IncrementSettings {
<span class="line-added">+             // For RND_INCREMENT, RND_INCREMENT_ONE, and RND_INCREMENT_FIVE</span>
<span class="line-added">+             /** @internal */</span>
              double fIncrement;
<span class="line-added">+             /** @internal */</span>
              impl::digits_t fMinFrac;
<span class="line-added">+             /** @internal */</span>
              impl::digits_t fMaxFrac;
<span class="line-modified">!         } increment;</span>
          UCurrencyUsage currencyUsage; // For RND_CURRENCY
          UErrorCode errorCode; // For RND_ERROR
      } fUnion;
  
      typedef PrecisionUnion::FractionSignificantSettings FractionSignificantSettings;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1203,22 ***</span>
  /** @internal */
  class U_I18N_API Grouper : public UMemory {
    public:
  #ifndef U_HIDE_INTERNAL_API
      /** @internal */
<span class="line-modified">!     static Grouper forStrategy(UGroupingStrategy grouping);</span>
  
      /**
       * Resolve the values in Properties to a Grouper object.
       * @internal
       */
      static Grouper forProperties(const DecimalFormatProperties&amp; properties);
  
      // Future: static Grouper forProperties(DecimalFormatProperties&amp; properties);
  
      /** @internal */
<span class="line-modified">!     Grouper(int16_t grouping1, int16_t grouping2, int16_t minGrouping, UGroupingStrategy strategy)</span>
              : fGrouping1(grouping1),
                fGrouping2(grouping2),
                fMinGrouping(minGrouping),
                fStrategy(strategy) {}
  #endif  // U_HIDE_INTERNAL_API
<span class="line-new-header">--- 1213,22 ---</span>
  /** @internal */
  class U_I18N_API Grouper : public UMemory {
    public:
  #ifndef U_HIDE_INTERNAL_API
      /** @internal */
<span class="line-modified">!     static Grouper forStrategy(UNumberGroupingStrategy grouping);</span>
  
      /**
       * Resolve the values in Properties to a Grouper object.
       * @internal
       */
      static Grouper forProperties(const DecimalFormatProperties&amp; properties);
  
      // Future: static Grouper forProperties(DecimalFormatProperties&amp; properties);
  
      /** @internal */
<span class="line-modified">!     Grouper(int16_t grouping1, int16_t grouping2, int16_t minGrouping, UNumberGroupingStrategy strategy)</span>
              : fGrouping1(grouping1),
                fGrouping2(grouping2),
                fMinGrouping(minGrouping),
                fStrategy(strategy) {}
  #endif  // U_HIDE_INTERNAL_API
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1249,16 ***</span>
       * &lt;/ul&gt;
       */
      int16_t fMinGrouping;
  
      /**
<span class="line-modified">!      * The UGroupingStrategy that was used to create this Grouper, or UNUM_GROUPING_COUNT if this</span>
<span class="line-modified">!      * was not created from a UGroupingStrategy.</span>
       */
<span class="line-modified">!     UGroupingStrategy fStrategy;</span>
  
<span class="line-modified">!     Grouper() : fGrouping1(-3) {};</span>
  
      bool isBogus() const {
          return fGrouping1 == -3;
      }
  
<span class="line-new-header">--- 1259,16 ---</span>
       * &lt;/ul&gt;
       */
      int16_t fMinGrouping;
  
      /**
<span class="line-modified">!      * The UNumberGroupingStrategy that was used to create this Grouper, or UNUM_GROUPING_COUNT if this</span>
<span class="line-modified">!      * was not created from a UNumberGroupingStrategy.</span>
       */
<span class="line-modified">!     UNumberGroupingStrategy fStrategy;</span>
  
<span class="line-modified">!     Grouper() : fGrouping1(-3) {}</span>
  
      bool isBogus() const {
          return fGrouping1 == -3;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1399,11 ***</span>
  
      /** @internal */
      const CurrencySymbols* currencySymbols = nullptr;  // no ownership
  
      /** @internal */
<span class="line-modified">!     int32_t threshold = DEFAULT_THRESHOLD;</span>
  
      /** @internal */
      Locale locale;
  
      // NOTE: Uses default copy and move constructors.
<span class="line-new-header">--- 1409,11 ---</span>
  
      /** @internal */
      const CurrencySymbols* currencySymbols = nullptr;  // no ownership
  
      /** @internal */
<span class="line-modified">!     int32_t threshold = kInternalDefaultThreshold;</span>
  
      /** @internal */
      Locale locale;
  
      // NOTE: Uses default copy and move constructors.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1421,11 ***</span>
  
  } // namespace impl
  
  /**
   * An abstract base class for specifying settings related to number formatting. This class is implemented by
<span class="line-modified">!  * {@link UnlocalizedNumberFormatter} and {@link LocalizedNumberFormatter}.</span>
   */
  template&lt;typename Derived&gt;
  class U_I18N_API NumberFormatterSettings {
    public:
      /**
<span class="line-new-header">--- 1431,12 ---</span>
  
  } // namespace impl
  
  /**
   * An abstract base class for specifying settings related to number formatting. This class is implemented by
<span class="line-modified">!  * {@link UnlocalizedNumberFormatter} and {@link LocalizedNumberFormatter}. This class is not intended for</span>
<span class="line-added">+  * public subclassing.</span>
   */
  template&lt;typename Derived&gt;
  class U_I18N_API NumberFormatterSettings {
    public:
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1479,15 ***</span>
       * &lt;/ul&gt;
       *
       * All units will be properly localized with locale data, and all units are compatible with notation styles,
       * rounding precisions, and other number formatter settings.
       *
<span class="line-modified">!      * Pass this method any instance of {@link MeasureUnit}. For units of measure (which often involve the</span>
<span class="line-removed">-      * factory methods that return a pointer):</span>
       *
       * &lt;pre&gt;
<span class="line-modified">!      * NumberFormatter::with().adoptUnit(MeasureUnit::createMeter(status))</span>
       * &lt;/pre&gt;
       *
       * Currency:
       *
       * &lt;pre&gt;
<span class="line-new-header">--- 1490,14 ---</span>
       * &lt;/ul&gt;
       *
       * All units will be properly localized with locale data, and all units are compatible with notation styles,
       * rounding precisions, and other number formatter settings.
       *
<span class="line-modified">!      * Pass this method any instance of {@link MeasureUnit}. For units of measure:</span>
       *
       * &lt;pre&gt;
<span class="line-modified">!      * NumberFormatter::with().unit(MeasureUnit::getMeter())</span>
       * &lt;/pre&gt;
       *
       * Currency:
       *
       * &lt;pre&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1526,15 ***</span>
       */
      Derived unit(const icu::MeasureUnit &amp;unit) &amp;&amp;;
  
      /**
       * Like unit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory
<span class="line-modified">!      * methods, which return pointers that need ownership.  Example:</span>
       *
<span class="line-modified">!      * &lt;pre&gt;</span>
<span class="line-removed">-      * NumberFormatter::with().adoptUnit(MeasureUnit::createMeter(status))</span>
<span class="line-removed">-      * &lt;/pre&gt;</span>
       *
       * @param unit
       *            The unit to render.
       * @return The fluent chain.
       * @see #unit
<span class="line-new-header">--- 1536,13 ---</span>
       */
      Derived unit(const icu::MeasureUnit &amp;unit) &amp;&amp;;
  
      /**
       * Like unit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory
<span class="line-modified">!      * methods that return pointers that need ownership.</span>
       *
<span class="line-modified">!      * Note: consider using the MeasureFormat factory methods that return by value.</span>
       *
       * @param unit
       *            The unit to render.
       * @return The fluent chain.
       * @see #unit
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1556,12 ***</span>
  
      /**
       * Sets a unit to be used in the denominator. For example, to format &quot;3 m/s&quot;, pass METER to the unit and SECOND to
       * the perUnit.
       *
<span class="line-modified">!      * Pass this method any instance of {@link MeasureUnit}.  Since MeasureUnit factory methods return pointers, the</span>
<span class="line-modified">!      * {@link #adoptPerUnit} version of this method is often more useful.</span>
       *
       * The default is not to display any unit in the denominator.
       *
       * If a per-unit is specified without a primary unit via {@link #unit}, the behavior is undefined.
       *
<span class="line-new-header">--- 1564,17 ---</span>
  
      /**
       * Sets a unit to be used in the denominator. For example, to format &quot;3 m/s&quot;, pass METER to the unit and SECOND to
       * the perUnit.
       *
<span class="line-modified">!      * Pass this method any instance of {@link MeasureUnit}. Example:</span>
<span class="line-modified">!      *</span>
<span class="line-added">+      * &lt;pre&gt;</span>
<span class="line-added">+      * NumberFormatter::with()</span>
<span class="line-added">+      *      .unit(MeasureUnit::getMeter())</span>
<span class="line-added">+      *      .perUnit(MeasureUnit::getSecond())</span>
<span class="line-added">+      * &lt;/pre&gt;</span>
       *
       * The default is not to display any unit in the denominator.
       *
       * If a per-unit is specified without a primary unit via {@link #unit}, the behavior is undefined.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1584,17 ***</span>
       */
      Derived perUnit(const icu::MeasureUnit &amp;perUnit) &amp;&amp;;
  
      /**
       * Like perUnit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory
<span class="line-modified">!      * methods, which return pointers that need ownership.  Example:</span>
       *
<span class="line-modified">!      * &lt;pre&gt;</span>
<span class="line-removed">-      * NumberFormatter::with()</span>
<span class="line-removed">-      *      .adoptUnit(MeasureUnit::createMeter(status))</span>
<span class="line-removed">-      *      .adoptPerUnit(MeasureUnit::createSecond(status))</span>
<span class="line-removed">-      * &lt;/pre&gt;</span>
       *
       * @param perUnit
       *            The unit to render in the denominator.
       * @return The fluent chain.
       * @see #perUnit
<span class="line-new-header">--- 1597,13 ---</span>
       */
      Derived perUnit(const icu::MeasureUnit &amp;perUnit) &amp;&amp;;
  
      /**
       * Like perUnit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory
<span class="line-modified">!      * methods that return pointers that need ownership.</span>
       *
<span class="line-modified">!      * Note: consider using the MeasureFormat factory methods that return by value.</span>
       *
       * @param perUnit
       *            The unit to render in the denominator.
       * @return The fluent chain.
       * @see #perUnit
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1655,20 ***</span>
       * @see #precision
       * @draft ICU 62
       */
      Derived precision(const Precision&amp; precision) &amp;&amp;;
  
<span class="line-removed">- #ifndef U_HIDE_DEPRECATED_API</span>
<span class="line-removed">-     // Compatibility method that will be removed in ICU 64.</span>
<span class="line-removed">-     // Use precision() instead.</span>
<span class="line-removed">-     // See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">-     /** @deprecated ICU 62 */</span>
<span class="line-removed">-     Derived rounding(const Rounder&amp; rounder) const &amp; {</span>
<span class="line-removed">-         return precision(rounder);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif  /* U_HIDE_DEPRECATED_API */</span>
<span class="line-removed">- </span>
      /**
       * Specifies how to determine the direction to round a number when it has more digits than fit in the
       * desired precision.  When formatting 1.235:
       *
       * &lt;ul&gt;
<span class="line-new-header">--- 1664,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1708,11 ***</span>
       *
       * &lt;p&gt;
       * The exact grouping widths will be chosen based on the locale.
       *
       * &lt;p&gt;
<span class="line-modified">!      * Pass this method an element from the {@link UGroupingStrategy} enum. For example:</span>
       *
       * &lt;pre&gt;
       * NumberFormatter::with().grouping(UNUM_GROUPING_MIN2)
       * &lt;/pre&gt;
       *
<span class="line-new-header">--- 1707,11 ---</span>
       *
       * &lt;p&gt;
       * The exact grouping widths will be chosen based on the locale.
       *
       * &lt;p&gt;
<span class="line-modified">!      * Pass this method an element from the {@link UNumberGroupingStrategy} enum. For example:</span>
       *
       * &lt;pre&gt;
       * NumberFormatter::with().grouping(UNUM_GROUPING_MIN2)
       * &lt;/pre&gt;
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1722,23 ***</span>
       * @param strategy
       *            The grouping strategy to use.
       * @return The fluent chain.
       * @draft ICU 61
       */
<span class="line-modified">!     Derived grouping(UGroupingStrategy strategy) const &amp;;</span>
  
      /**
       * Overload of grouping() for use on an rvalue reference.
       *
       * @param strategy
       *            The grouping strategy to use.
       * @return The fluent chain.
       * @see #grouping
<span class="line-removed">-      * @provisional This API might change or be removed in a future release.</span>
       * @draft ICU 62
       */
<span class="line-modified">!     Derived grouping(UGroupingStrategy strategy) &amp;&amp;;</span>
  
      /**
       * Specifies the minimum and maximum number of digits to render before the decimal mark.
       *
       * &lt;ul&gt;
<span class="line-new-header">--- 1721,22 ---</span>
       * @param strategy
       *            The grouping strategy to use.
       * @return The fluent chain.
       * @draft ICU 61
       */
<span class="line-modified">!     Derived grouping(UNumberGroupingStrategy strategy) const &amp;;</span>
  
      /**
       * Overload of grouping() for use on an rvalue reference.
       *
       * @param strategy
       *            The grouping strategy to use.
       * @return The fluent chain.
       * @see #grouping
       * @draft ICU 62
       */
<span class="line-modified">!     Derived grouping(UNumberGroupingStrategy strategy) &amp;&amp;;</span>
  
      /**
       * Specifies the minimum and maximum number of digits to render before the decimal mark.
       *
       * &lt;ul&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1746,11 ***</span>
       * &lt;li&gt;One minimum integer digit: &quot;0.08&quot;
       * &lt;li&gt;Two minimum integer digits: &quot;00.08&quot;
       * &lt;/ul&gt;
       *
       * &lt;p&gt;
<span class="line-modified">!      * Pass this method the return value of {@link IntegerWidth#zeroFillTo(int)}. For example:</span>
       *
       * &lt;pre&gt;
       * NumberFormatter::with().integerWidth(IntegerWidth::zeroFillTo(2))
       * &lt;/pre&gt;
       *
<span class="line-new-header">--- 1744,11 ---</span>
       * &lt;li&gt;One minimum integer digit: &quot;0.08&quot;
       * &lt;li&gt;Two minimum integer digits: &quot;00.08&quot;
       * &lt;/ul&gt;
       *
       * &lt;p&gt;
<span class="line-modified">!      * Pass this method the return value of {@link IntegerWidth#zeroFillTo}. For example:</span>
       *
       * &lt;pre&gt;
       * NumberFormatter::with().integerWidth(IntegerWidth::zeroFillTo(2))
       * &lt;/pre&gt;
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2080,10 ***</span>
<span class="line-new-header">--- 2078,32 ---</span>
       * @return A number skeleton string with behavior corresponding to this number formatter.
       * @draft ICU 62
       */
      UnicodeString toSkeleton(UErrorCode&amp; status) const;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the current (Un)LocalizedNumberFormatter as a LocalPointer</span>
<span class="line-added">+      * wrapping a heap-allocated copy of the current object.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * This is equivalent to new-ing the move constructor with a value object</span>
<span class="line-added">+      * as the argument.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return A wrapped (Un)LocalizedNumberFormatter pointer, or a wrapped</span>
<span class="line-added">+      *         nullptr on failure.</span>
<span class="line-added">+      * @draft ICU 64</span>
<span class="line-added">+      */</span>
<span class="line-added">+     LocalPointer&lt;Derived&gt; clone() const &amp;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Overload of clone for use on an rvalue reference.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return A wrapped (Un)LocalizedNumberFormatter pointer, or a wrapped</span>
<span class="line-added">+      *         nullptr on failure.</span>
<span class="line-added">+      * @draft ICU 64</span>
<span class="line-added">+      */</span>
<span class="line-added">+     LocalPointer&lt;Derived&gt; clone() &amp;&amp;;</span>
<span class="line-added">+ </span>
      /**
       * Sets the UErrorCode if an error occurred in the fluent chain.
       * Preserves older error codes in the outErrorCode.
       * @return TRUE if U_FAILURE(outErrorCode)
       * @draft ICU 60
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2093,28 ***</span>
              // Do not overwrite the older error code
              return TRUE;
          }
          fMacros.copyErrorTo(outErrorCode);
          return U_FAILURE(outErrorCode);
<span class="line-modified">!     };</span>
  
      // NOTE: Uses default copy and move constructors.
  
<span class="line-modified">!   protected:</span>
      impl::MacroProps fMacros;
  
<span class="line-removed">-   private:</span>
      // Don&#39;t construct me directly!  Use (Un)LocalizedNumberFormatter.
      NumberFormatterSettings() = default;
  
      friend class LocalizedNumberFormatter;
      friend class UnlocalizedNumberFormatter;
  };
  
  /**
   * A NumberFormatter that does not yet have a locale. In order to format numbers, a locale must be specified.
   *
   * @see NumberFormatter
   * @draft ICU 60
   */
  class U_I18N_API UnlocalizedNumberFormatter
          : public NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;, public UMemory {
<span class="line-new-header">--- 2113,33 ---</span>
              // Do not overwrite the older error code
              return TRUE;
          }
          fMacros.copyErrorTo(outErrorCode);
          return U_FAILURE(outErrorCode);
<span class="line-modified">!     }</span>
  
      // NOTE: Uses default copy and move constructors.
  
<span class="line-modified">!   private:</span>
      impl::MacroProps fMacros;
  
      // Don&#39;t construct me directly!  Use (Un)LocalizedNumberFormatter.
      NumberFormatterSettings() = default;
  
      friend class LocalizedNumberFormatter;
      friend class UnlocalizedNumberFormatter;
<span class="line-added">+ </span>
<span class="line-added">+     // Give NumberRangeFormatter access to the MacroProps</span>
<span class="line-added">+     friend void impl::touchRangeLocales(impl::RangeMacroProps&amp; macros);</span>
<span class="line-added">+     friend class impl::NumberRangeFormatterImpl;</span>
  };
  
  /**
   * A NumberFormatter that does not yet have a locale. In order to format numbers, a locale must be specified.
   *
<span class="line-added">+  * Instances of this class are immutable and thread-safe.</span>
<span class="line-added">+  *</span>
   * @see NumberFormatter
   * @draft ICU 60
   */
  class U_I18N_API UnlocalizedNumberFormatter
          : public NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;, public UMemory {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2122,17 ***</span>
    public:
      /**
       * Associate the given locale with the number formatter. The locale is used for picking the appropriate symbols,
       * formats, and other data for number display.
       *
<span class="line-removed">-      * &lt;p&gt;</span>
<span class="line-removed">-      * To use the Java default locale, call Locale::getDefault():</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;pre&gt;</span>
<span class="line-removed">-      * NumberFormatter::with(). ... .locale(Locale::getDefault())</span>
<span class="line-removed">-      * &lt;/pre&gt;</span>
<span class="line-removed">-      *</span>
       * @param locale
       *            The locale to use when loading data for number formatting.
       * @return The fluent chain.
       * @draft ICU 60
       */
<span class="line-new-header">--- 2147,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2154,11 ***</span>
       *
       * @draft ICU 62
       */
      UnlocalizedNumberFormatter() = default;
  
<span class="line-removed">-     // Make default copy constructor call the NumberFormatterSettings copy constructor.</span>
      /**
       * Returns a copy of this UnlocalizedNumberFormatter.
       * @draft ICU 60
       */
      UnlocalizedNumberFormatter(const UnlocalizedNumberFormatter &amp;other);
<span class="line-new-header">--- 2172,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2197,10 ***</span>
<span class="line-new-header">--- 2214,12 ---</span>
  };
  
  /**
   * A NumberFormatter that has a locale associated with it; this means .format() methods are available.
   *
<span class="line-added">+  * Instances of this class are immutable and thread-safe.</span>
<span class="line-added">+  *</span>
   * @see NumberFormatter
   * @draft ICU 60
   */
  class U_I18N_API LocalizedNumberFormatter
          : public NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;, public UMemory {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2269,11 ***</span>
       * Internal method for testing.
       * @internal
       */
      int32_t getCallCount() const;
  
<span class="line-modified">! #endif</span>
  
      /**
       * Creates a representation of this LocalizedNumberFormat as an icu::Format, enabling the use
       * of this number formatter with APIs that need an object of that type, such as MessageFormat.
       *
<span class="line-new-header">--- 2288,11 ---</span>
       * Internal method for testing.
       * @internal
       */
      int32_t getCallCount() const;
  
<span class="line-modified">! #endif  /* U_HIDE_INTERNAL_API */</span>
  
      /**
       * Creates a representation of this LocalizedNumberFormat as an icu::Format, enabling the use
       * of this number formatter with APIs that need an object of that type, such as MessageFormat.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2293,11 ***</span>
       *
       * @draft ICU 62
       */
      LocalizedNumberFormatter() = default;
  
<span class="line-removed">-     // Make default copy constructor call the NumberFormatterSettings copy constructor.</span>
      /**
       * Returns a copy of this LocalizedNumberFormatter.
       * @draft ICU 60
       */
      LocalizedNumberFormatter(const LocalizedNumberFormatter &amp;other);
<span class="line-new-header">--- 2312,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2331,15 ***</span>
       * &lt;p&gt;
       * This function is very hot, being called in every call to the number formatting pipeline.
       *
       * @param results
       *            The results object. This method will mutate it to save the results.
       * @internal
       */
      void formatImpl(impl::UFormattedNumberData *results, UErrorCode &amp;status) const;
  
<span class="line-modified">! #endif</span>
  
      /**
       * Destruct this LocalizedNumberFormatter, cleaning up any memory it might own.
       * @draft ICU 60
       */
<span class="line-new-header">--- 2349,16 ---</span>
       * &lt;p&gt;
       * This function is very hot, being called in every call to the number formatting pipeline.
       *
       * @param results
       *            The results object. This method will mutate it to save the results.
<span class="line-added">+      * @param status</span>
       * @internal
       */
      void formatImpl(impl::UFormattedNumberData *results, UErrorCode &amp;status) const;
  
<span class="line-modified">! #endif  /* U_HIDE_INTERNAL_API */</span>
  
      /**
       * Destruct this LocalizedNumberFormatter, cleaning up any memory it might own.
       * @draft ICU 60
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2357,10 ***</span>
<span class="line-new-header">--- 2376,12 ---</span>
  
      LocalizedNumberFormatter(const impl::MacroProps &amp;macros, const Locale &amp;locale);
  
      LocalizedNumberFormatter(impl::MacroProps &amp;&amp;macros, const Locale &amp;locale);
  
<span class="line-added">+     void clear();</span>
<span class="line-added">+ </span>
      void lnfMoveHelper(LocalizedNumberFormatter&amp;&amp; src);
  
      /**
       * @return true if the compiled formatter is available.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2376,92 ***</span>
  
  /**
   * The result of a number formatting operation. This class allows the result to be exported in several data types,
   * including a UnicodeString and a FieldPositionIterator.
   *
   * @draft ICU 60
   */
<span class="line-modified">! class U_I18N_API FormattedNumber : public UMemory {</span>
    public:
<span class="line-modified">! #ifndef U_HIDE_DEPRECATED_API</span>
      /**
<span class="line-modified">!      * Returns a UnicodeString representation of the formatted number.</span>
<span class="line-modified">!      *</span>
<span class="line-removed">-      * @return a UnicodeString containing the localized number.</span>
<span class="line-removed">-      * @deprecated ICU 62 Use the version of this method with an error code instead.</span>
<span class="line-removed">-      *                This method was never @stable and will be removed in a future release.</span>
<span class="line-removed">-      *                See http://bugs.icu-project.org/trac/ticket/13746</span>
       */
<span class="line-modified">!     UnicodeString toString() const;</span>
<span class="line-modified">! #endif  /* U_HIDE_DEPRECATED_API */</span>
  
      /**
<span class="line-modified">!      * Returns a UnicodeString representation of the formatted number.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param status</span>
<span class="line-removed">-      *            Set if an error occurs while formatting the number to the UnicodeString.</span>
<span class="line-removed">-      * @return a UnicodeString containing the localized number.</span>
       * @draft ICU 62
       */
<span class="line-modified">!     UnicodeString toString(UErrorCode&amp; status) const;</span>
  
<span class="line-removed">- #ifndef U_HIDE_DEPRECATED_API</span>
      /**
<span class="line-modified">!      * Appends the formatted number to an Appendable.</span>
<span class="line-modified">!      *</span>
<span class="line-removed">-      * @param appendable</span>
<span class="line-removed">-      *            The Appendable to which to append the formatted number string.</span>
<span class="line-removed">-      * @return The same Appendable, for chaining.</span>
<span class="line-removed">-      * @deprecated ICU 62 Use the version of this method with an error code instead.</span>
<span class="line-removed">-      *                This method was never @stable and will be removed in a future release.</span>
<span class="line-removed">-      *                See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">-      * @see Appendable</span>
       */
<span class="line-modified">!     Appendable &amp;appendTo(Appendable &amp;appendable);</span>
<span class="line-removed">- #endif  /* U_HIDE_DEPRECATED_API */</span>
  
      /**
<span class="line-modified">!      * Appends the formatted number to an Appendable.</span>
       *
<span class="line-removed">-      * @param appendable</span>
<span class="line-removed">-      *            The Appendable to which to append the formatted number string.</span>
<span class="line-removed">-      * @param status</span>
<span class="line-removed">-      *            Set if an error occurs while formatting the number to the Appendable.</span>
<span class="line-removed">-      * @return The same Appendable, for chaining.</span>
       * @draft ICU 62
<span class="line-removed">-      * @see Appendable</span>
       */
<span class="line-modified">!     Appendable &amp;appendTo(Appendable &amp;appendable, UErrorCode&amp; status);</span>
  
<span class="line-modified">! #ifndef U_HIDE_DEPRECATED_API</span>
      /**
<span class="line-modified">!      * Determine the start and end indices of the first occurrence of the given &lt;em&gt;field&lt;/em&gt; in the output string.</span>
<span class="line-removed">-      * This allows you to determine the locations of the integer part, fraction part, and sign.</span>
       *
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-removed">-      * If multiple different field attributes are needed, this method can be called repeatedly, or if &lt;em&gt;all&lt;/em&gt; field</span>
<span class="line-removed">-      * attributes are needed, consider using populateFieldPositionIterator().</span>
       *
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-removed">-      * If a field occurs multiple times in an output string, such as a grouping separator, this method will only ever</span>
<span class="line-removed">-      * return the first occurrence. Use populateFieldPositionIterator() to access all occurrences of an attribute.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param fieldPosition</span>
<span class="line-removed">-      *            The FieldPosition to populate with the start and end indices of the desired field.</span>
<span class="line-removed">-      * @param status</span>
<span class="line-removed">-      *            Set if an error occurs while populating the FieldPosition.</span>
<span class="line-removed">-      * @deprecated ICU 62 Use {@link #nextFieldPosition} instead. This method will be removed in a future</span>
<span class="line-removed">-      *             release. See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">-      * @see UNumberFormatFields</span>
       */
<span class="line-modified">!     void populateFieldPosition(FieldPosition &amp;fieldPosition, UErrorCode &amp;status);</span>
<span class="line-modified">! #endif  /* U_HIDE_DEPRECATED_API */</span>
  
      /**
<span class="line-modified">!      * Determines the start and end indices of the next occurrence of the given &lt;em&gt;field&lt;/em&gt; in the</span>
<span class="line-modified">!      * output string. This allows you to determine the locations of, for example, the integer part,</span>
<span class="line-modified">!      * fraction part, or symbols.</span>
       *
       * If a field occurs just once, calling this method will find that occurrence and return it. If a
       * field occurs multiple times, this method may be called repeatedly with the following pattern:
       *
       * &lt;pre&gt;
<span class="line-new-header">--- 2397,82 ---</span>
  
  /**
   * The result of a number formatting operation. This class allows the result to be exported in several data types,
   * including a UnicodeString and a FieldPositionIterator.
   *
<span class="line-added">+  * Instances of this class are immutable and thread-safe.</span>
<span class="line-added">+  *</span>
   * @draft ICU 60
   */
<span class="line-modified">! class U_I18N_API FormattedNumber : public UMemory, public FormattedValue {</span>
    public:
<span class="line-modified">! </span>
      /**
<span class="line-modified">!      * Default constructor; makes an empty FormattedNumber.</span>
<span class="line-modified">!      * @draft ICU 64</span>
       */
<span class="line-modified">!     FormattedNumber()</span>
<span class="line-modified">!         : fData(nullptr), fErrorCode(U_INVALID_STATE_ERROR) {}</span>
  
      /**
<span class="line-modified">!      * Move constructor: Leaves the source FormattedNumber in an undefined state.</span>
       * @draft ICU 62
       */
<span class="line-modified">!     FormattedNumber(FormattedNumber&amp;&amp; src) U_NOEXCEPT;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Destruct an instance of FormattedNumber.</span>
<span class="line-added">+      * @draft ICU 60</span>
<span class="line-added">+      */</span>
<span class="line-added">+     virtual ~FormattedNumber() U_OVERRIDE;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /** Copying not supported; use move constructor instead. */</span>
<span class="line-added">+     FormattedNumber(const FormattedNumber&amp;) = delete;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /** Copying not supported; use move assignment instead. */</span>
<span class="line-added">+     FormattedNumber&amp; operator=(const FormattedNumber&amp;) = delete;</span>
  
      /**
<span class="line-modified">!      * Move assignment: Leaves the source FormattedNumber in an undefined state.</span>
<span class="line-modified">!      * @draft ICU 62</span>
       */
<span class="line-modified">!     FormattedNumber&amp; operator=(FormattedNumber&amp;&amp; src) U_NOEXCEPT;</span>
  
<span class="line-added">+     // Copybrief: this method is older than the parent method</span>
      /**
<span class="line-modified">!      * @copybrief FormattedValue::toString()</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * For more information, see FormattedValue::toString()</span>
       *
       * @draft ICU 62
       */
<span class="line-modified">!     UnicodeString toString(UErrorCode&amp; status) const U_OVERRIDE;</span>
  
<span class="line-modified">!     // Copydoc: this method is new in ICU 64</span>
<span class="line-added">+     /** @copydoc FormattedValue::toTempString() */</span>
<span class="line-added">+     UnicodeString toTempString(UErrorCode&amp; status) const U_OVERRIDE;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Copybrief: this method is older than the parent method</span>
      /**
<span class="line-modified">!      * @copybrief FormattedValue::appendTo()</span>
       *
<span class="line-modified">!      * For more information, see FormattedValue::appendTo()</span>
       *
<span class="line-modified">!      * @draft ICU 62</span>
       */
<span class="line-modified">!     Appendable &amp;appendTo(Appendable&amp; appendable, UErrorCode&amp; status) const U_OVERRIDE;</span>
<span class="line-modified">! </span>
<span class="line-added">+     // Copydoc: this method is new in ICU 64</span>
<span class="line-added">+     /** @copydoc FormattedValue::nextPosition() */</span>
<span class="line-added">+     UBool nextPosition(ConstrainedFieldPosition&amp; cfpos, UErrorCode&amp; status) const U_OVERRIDE;</span>
  
      /**
<span class="line-modified">!      * Determines the start (inclusive) and end (exclusive) indices of the next occurrence of the given</span>
<span class="line-modified">!      * &lt;em&gt;field&lt;/em&gt; in the output string. This allows you to determine the locations of, for example,</span>
<span class="line-modified">!      * the integer part, fraction part, or symbols.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * This is a simpler but less powerful alternative to {@link #nextPosition}.</span>
       *
       * If a field occurs just once, calling this method will find that occurrence and return it. If a
       * field occurs multiple times, this method may be called repeatedly with the following pattern:
       *
       * &lt;pre&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2470,51 ***</span>
       *   // do something with fpos.
       * }
       * &lt;/pre&gt;
       *
       * This method is useful if you know which field to query. If you want all available field position
<span class="line-modified">!      * information, use #getAllFieldPositions().</span>
       *
       * @param fieldPosition
       *            Input+output variable. On input, the &quot;field&quot; property determines which field to look
       *            up, and the &quot;beginIndex&quot; and &quot;endIndex&quot; properties determine where to begin the search.
       *            On output, the &quot;beginIndex&quot; is set to the beginning of the first occurrence of the
<span class="line-modified">!      *            field with either begin or end indices after the input indices, &quot;endIndex&quot; is set to</span>
       *            the end of that occurrence of the field (exclusive index). If a field position is not
       *            found, the method returns FALSE and the FieldPosition may or may not be changed.
       * @param status
       *            Set if an error occurs while populating the FieldPosition.
       * @return TRUE if a new occurrence of the field was found; FALSE otherwise.
       * @draft ICU 62
       * @see UNumberFormatFields
       */
      UBool nextFieldPosition(FieldPosition&amp; fieldPosition, UErrorCode&amp; status) const;
  
<span class="line-removed">- #ifndef U_HIDE_DEPRECATED_API</span>
      /**
       * Export the formatted number to a FieldPositionIterator. This allows you to determine which characters in
       * the output string correspond to which &lt;em&gt;fields&lt;/em&gt;, such as the integer part, fraction part, and sign.
       *
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-removed">-      * If information on only one field is needed, consider using populateFieldPosition() instead.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param iterator</span>
<span class="line-removed">-      *            The FieldPositionIterator to populate with all of the fields present in the formatted number.</span>
<span class="line-removed">-      * @param status</span>
<span class="line-removed">-      *            Set if an error occurs while populating the FieldPositionIterator.</span>
<span class="line-removed">-      * @deprecated ICU 62 Use {@link #getAllFieldPositions} instead. This method will be removed in a</span>
<span class="line-removed">-      *             future release. See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">-      * @see UNumberFormatFields</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     void populateFieldPositionIterator(FieldPositionIterator &amp;iterator, UErrorCode &amp;status);</span>
<span class="line-removed">- #endif  /* U_HIDE_DEPRECATED_API */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Export the formatted number to a FieldPositionIterator. This allows you to determine which characters in</span>
<span class="line-removed">-      * the output string correspond to which &lt;em&gt;fields&lt;/em&gt;, such as the integer part, fraction part, and sign.</span>
       *
<span class="line-modified">!      * If information on only one field is needed, use #nextFieldPosition() instead.</span>
       *
       * @param iterator
       *            The FieldPositionIterator to populate with all of the fields present in the formatted number.
       * @param status
       *            Set if an error occurs while populating the FieldPositionIterator.
<span class="line-new-header">--- 2481,34 ---</span>
       *   // do something with fpos.
       * }
       * &lt;/pre&gt;
       *
       * This method is useful if you know which field to query. If you want all available field position
<span class="line-modified">!      * information, use {@link #nextPosition} or {@link #getAllFieldPositions}.</span>
       *
       * @param fieldPosition
       *            Input+output variable. On input, the &quot;field&quot; property determines which field to look
       *            up, and the &quot;beginIndex&quot; and &quot;endIndex&quot; properties determine where to begin the search.
       *            On output, the &quot;beginIndex&quot; is set to the beginning of the first occurrence of the
<span class="line-modified">!      *            field with either begin or end indices after the input indices; &quot;endIndex&quot; is set to</span>
       *            the end of that occurrence of the field (exclusive index). If a field position is not
       *            found, the method returns FALSE and the FieldPosition may or may not be changed.
       * @param status
       *            Set if an error occurs while populating the FieldPosition.
       * @return TRUE if a new occurrence of the field was found; FALSE otherwise.
       * @draft ICU 62
       * @see UNumberFormatFields
       */
      UBool nextFieldPosition(FieldPosition&amp; fieldPosition, UErrorCode&amp; status) const;
  
      /**
       * Export the formatted number to a FieldPositionIterator. This allows you to determine which characters in
       * the output string correspond to which &lt;em&gt;fields&lt;/em&gt;, such as the integer part, fraction part, and sign.
       *
<span class="line-modified">!      * This is an alternative to the more powerful #nextPosition() API.</span>
       *
<span class="line-modified">!      * If information on only one field is needed, use #nextPosition() or #nextFieldPosition() instead.</span>
       *
       * @param iterator
       *            The FieldPositionIterator to populate with all of the fields present in the formatted number.
       * @param status
       *            Set if an error occurs while populating the FieldPositionIterator.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2535,61 ***</span>
       * Populates the mutable builder type FieldPositionIteratorHandler.
       * @internal
       */
      void getAllFieldPositionsImpl(FieldPositionIteratorHandler&amp; fpih, UErrorCode&amp; status) const;
  
<span class="line-modified">! #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Copying not supported; use move constructor instead.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     FormattedNumber(const FormattedNumber&amp;) = delete;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Copying not supported; use move assignment instead.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     FormattedNumber&amp; operator=(const FormattedNumber&amp;) = delete;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Move constructor:</span>
<span class="line-removed">-      * Leaves the source FormattedNumber in an undefined state.</span>
<span class="line-removed">-      * @draft ICU 62</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     FormattedNumber(FormattedNumber&amp;&amp; src) U_NOEXCEPT;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Move assignment:</span>
<span class="line-removed">-      * Leaves the source FormattedNumber in an undefined state.</span>
<span class="line-removed">-      * @draft ICU 62</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     FormattedNumber&amp; operator=(FormattedNumber&amp;&amp; src) U_NOEXCEPT;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Destruct an instance of FormattedNumber, cleaning up any memory it might own.</span>
<span class="line-removed">-      * @draft ICU 60</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     ~FormattedNumber();</span>
  
    private:
      // Can&#39;t use LocalPointer because UFormattedNumberData is forward-declared
<span class="line-modified">!     const impl::UFormattedNumberData *fResults;</span>
  
      // Error code for the terminal methods
      UErrorCode fErrorCode;
  
      /**
       * Internal constructor from data type. Adopts the data pointer.
       * @internal
       */
      explicit FormattedNumber(impl::UFormattedNumberData *results)
<span class="line-modified">!         : fResults(results), fErrorCode(U_ZERO_ERROR) {};</span>
  
      explicit FormattedNumber(UErrorCode errorCode)
<span class="line-modified">!         : fResults(nullptr), fErrorCode(errorCode) {};</span>
  
      // To give LocalizedNumberFormatter format methods access to this class&#39;s constructor:
      friend class LocalizedNumberFormatter;
  };
  
  /**
   * See the main description in numberformatter.h for documentation and examples.
   *
<span class="line-new-header">--- 2529,34 ---</span>
       * Populates the mutable builder type FieldPositionIteratorHandler.
       * @internal
       */
      void getAllFieldPositionsImpl(FieldPositionIteratorHandler&amp; fpih, UErrorCode&amp; status) const;
  
<span class="line-modified">! #endif  /* U_HIDE_INTERNAL_API */</span>
  
    private:
      // Can&#39;t use LocalPointer because UFormattedNumberData is forward-declared
<span class="line-modified">!     const impl::UFormattedNumberData *fData;</span>
  
      // Error code for the terminal methods
      UErrorCode fErrorCode;
  
      /**
       * Internal constructor from data type. Adopts the data pointer.
       * @internal
       */
      explicit FormattedNumber(impl::UFormattedNumberData *results)
<span class="line-modified">!         : fData(results), fErrorCode(U_ZERO_ERROR) {}</span>
  
      explicit FormattedNumber(UErrorCode errorCode)
<span class="line-modified">!         : fData(nullptr), fErrorCode(errorCode) {}</span>
  
      // To give LocalizedNumberFormatter format methods access to this class&#39;s constructor:
      friend class LocalizedNumberFormatter;
<span class="line-added">+ </span>
<span class="line-added">+     // To give C API access to internals</span>
<span class="line-added">+     friend struct impl::UFormattedNumberImpl;</span>
  };
  
  /**
   * See the main description in numberformatter.h for documentation and examples.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2619,19 ***</span>
<span class="line-new-header">--- 2586,42 ---</span>
  
      /**
       * Call this method at the beginning of a NumberFormatter fluent chain to create an instance based
       * on a given number skeleton string.
       *
<span class="line-added">+      * It is possible for an error to occur while parsing. See the overload of this method if you are</span>
<span class="line-added">+      * interested in the location of a possible parse error.</span>
<span class="line-added">+      *</span>
       * @param skeleton
       *            The skeleton string off of which to base this NumberFormatter.
       * @param status
       *            Set to U_NUMBER_SKELETON_SYNTAX_ERROR if the skeleton was invalid.
       * @return An UnlocalizedNumberFormatter, to be used for chaining.
<span class="line-added">+     /**</span>
<span class="line-added">+      * Call this method at the beginning of a NumberFormatter fluent chain to create an instance based</span>
<span class="line-added">+      * on a given number skeleton string.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If an error occurs while parsing the skeleton string, the offset into the skeleton string at</span>
<span class="line-added">+      * which the error occurred will be saved into the UParseError, if provided.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param skeleton</span>
<span class="line-added">+      *            The skeleton string off of which to base this NumberFormatter.</span>
<span class="line-added">+      * @param perror</span>
<span class="line-added">+      *            A parse error struct populated if an error occurs when parsing.</span>
<span class="line-added">+  *                If no error occurs, perror.offset will be set to -1.</span>
<span class="line-added">+      * @param status</span>
<span class="line-added">+      *            Set to U_NUMBER_SKELETON_SYNTAX_ERROR if the skeleton was invalid.</span>
<span class="line-added">+      * @return An UnlocalizedNumberFormatter, to be used for chaining.</span>
<span class="line-added">+      * @draft ICU 64</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static UnlocalizedNumberFormatter forSkeleton(const UnicodeString&amp; skeleton,</span>
<span class="line-added">+                                                   UParseError&amp; perror, UErrorCode&amp; status);</span>
<span class="line-added">+ </span>
      /**
       * Use factory methods instead of the constructor to create a NumberFormatter.
       */
      NumberFormatter() = delete;
  };
</pre>
<center><a href="nounit.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="numfmt.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>