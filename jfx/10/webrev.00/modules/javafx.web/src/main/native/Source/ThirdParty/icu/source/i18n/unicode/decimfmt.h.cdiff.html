<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/decimfmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="dcfmtsym.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="dtitvfmt.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/decimfmt.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 61,39 ***</span>
  namespace impl {
  class NumberParserImpl;
  }
  }
  
<span class="line-removed">- // explicit template instantiation. see digitlst.h</span>
<span class="line-removed">- // (When building DLLs for Windows this is required.)</span>
<span class="line-removed">- #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN</span>
<span class="line-removed">- template class U_I18N_API    EnumSet&lt;UNumberFormatAttribute,</span>
<span class="line-removed">-             UNUM_MAX_NONBOOLEAN_ATTRIBUTE+1,</span>
<span class="line-removed">-             UNUM_LIMIT_BOOLEAN_ATTRIBUTE&gt;;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  /**
<span class="line-modified">!  * &lt;p&gt;&lt;strong&gt;IMPORTANT:&lt;/strong&gt; New users are strongly encouraged to see if</span>
   * numberformatter.h fits their use case.  Although not deprecated, this header
   * is provided for backwards compatibility only.
<span class="line-removed">-  * &lt;hr/&gt;</span>
   *
   * DecimalFormat is a concrete subclass of NumberFormat that formats decimal
   * numbers. It has a variety of features designed to make it possible to parse
   * and format numbers in any locale, including support for Western, Arabic, or
   * Indic digits.  It also supports different flavors of numbers, including
   * integers (&quot;123&quot;), fixed-point numbers (&quot;123.4&quot;), scientific notation
   * (&quot;1.23E4&quot;), percentages (&quot;12%&quot;), and currency amounts (&quot;$123&quot;, &quot;USD123&quot;,
   * &quot;123 US dollars&quot;).  All of these flavors can be easily localized.
   *
<span class="line-modified">!  * &lt;p&gt;To obtain a NumberFormat for a specific locale (including the default</span>
   * locale) call one of NumberFormat&#39;s factory methods such as
   * createInstance(). Do not call the DecimalFormat constructors directly, unless
   * you know what you are doing, since the NumberFormat factory methods may
   * return subclasses other than DecimalFormat.
   *
<span class="line-modified">!  * &lt;p&gt;&lt;strong&gt;Example Usage&lt;/strong&gt;</span>
   *
   * \code
   *     // Normally we would have a GUI with a menu for this
   *     int32_t locCount;
   *     const Locale* locales = NumberFormat::getAvailableLocales(locCount);
<span class="line-new-header">--- 61,30 ---</span>
  namespace impl {
  class NumberParserImpl;
  }
  }
  
  /**
<span class="line-modified">!  * **IMPORTANT:** New users are strongly encouraged to see if</span>
   * numberformatter.h fits their use case.  Although not deprecated, this header
   * is provided for backwards compatibility only.
   *
   * DecimalFormat is a concrete subclass of NumberFormat that formats decimal
   * numbers. It has a variety of features designed to make it possible to parse
   * and format numbers in any locale, including support for Western, Arabic, or
   * Indic digits.  It also supports different flavors of numbers, including
   * integers (&quot;123&quot;), fixed-point numbers (&quot;123.4&quot;), scientific notation
   * (&quot;1.23E4&quot;), percentages (&quot;12%&quot;), and currency amounts (&quot;$123&quot;, &quot;USD123&quot;,
   * &quot;123 US dollars&quot;).  All of these flavors can be easily localized.
   *
<span class="line-modified">!  * To obtain a NumberFormat for a specific locale (including the default</span>
   * locale) call one of NumberFormat&#39;s factory methods such as
   * createInstance(). Do not call the DecimalFormat constructors directly, unless
   * you know what you are doing, since the NumberFormat factory methods may
   * return subclasses other than DecimalFormat.
   *
<span class="line-modified">!  * **Example Usage**</span>
   *
   * \code
   *     // Normally we would have a GUI with a menu for this
   *     int32_t locCount;
   *     const Locale* locales = NumberFormat::getAvailableLocales(locCount);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,30 ***</span>
   *                 delete form;
   *             }
   *         }
   *     }
   * \endcode
<span class="line-modified">!  * &lt;P&gt;</span>
<span class="line-modified">!  * Another example use createInstance(style)</span>
<span class="line-modified">!  * &lt;P&gt;</span>
<span class="line-modified">!  * &lt;pre&gt;</span>
<span class="line-modified">!  * &lt;strong&gt;// Print out a number using the localized number, currency,</span>
   * // percent, scientific, integer, iso currency, and plural currency
   * // format for each locale&lt;/strong&gt;
   * Locale* locale = new Locale(&quot;en&quot;, &quot;US&quot;);
   * double myNumber = 1234.56;
   * UErrorCode success = U_ZERO_ERROR;
   * UnicodeString str;
   * Formattable fmtable;
   * for (int j=NumberFormat::kNumberStyle;
   *      j&lt;=NumberFormat::kPluralCurrencyStyle;
   *      ++j) {
<span class="line-modified">!  *     NumberFormat* format = NumberFormat::createInstance(locale, j, success);</span>
   *     str.remove();
   *     cout &lt;&lt; &quot;format result &quot; &lt;&lt; form-&gt;format(myNumber, str) &lt;&lt; endl;
   *     format-&gt;parse(form-&gt;format(myNumber, str), fmtable, success);
<span class="line-modified">!  * }&lt;/pre&gt;</span>
   *
   *
   * &lt;p&gt;&lt;strong&gt;Patterns&lt;/strong&gt;
   *
   * &lt;p&gt;A DecimalFormat consists of a &lt;em&gt;pattern&lt;/em&gt; and a set of
<span class="line-new-header">--- 124,32 ---</span>
   *                 delete form;
   *             }
   *         }
   *     }
   * \endcode
<span class="line-modified">!  *</span>
<span class="line-modified">!  * **Another example use createInstance(style)**</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * \code</span>
<span class="line-modified">!  * // Print out a number using the localized number, currency,</span>
   * // percent, scientific, integer, iso currency, and plural currency
   * // format for each locale&lt;/strong&gt;
   * Locale* locale = new Locale(&quot;en&quot;, &quot;US&quot;);
   * double myNumber = 1234.56;
   * UErrorCode success = U_ZERO_ERROR;
   * UnicodeString str;
   * Formattable fmtable;
   * for (int j=NumberFormat::kNumberStyle;
   *      j&lt;=NumberFormat::kPluralCurrencyStyle;
   *      ++j) {
<span class="line-modified">!  *     NumberFormat* form = NumberFormat::createInstance(locale, j, success);</span>
   *     str.remove();
   *     cout &lt;&lt; &quot;format result &quot; &lt;&lt; form-&gt;format(myNumber, str) &lt;&lt; endl;
   *     format-&gt;parse(form-&gt;format(myNumber, str), fmtable, success);
<span class="line-modified">!  *     delete form;</span>
<span class="line-added">+  * }</span>
<span class="line-added">+  * \endcode</span>
   *
   *
   * &lt;p&gt;&lt;strong&gt;Patterns&lt;/strong&gt;
   *
   * &lt;p&gt;A DecimalFormat consists of a &lt;em&gt;pattern&lt;/em&gt; and a set of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 281,11 ***</span>
   *     &lt;td&gt;Prefix or suffix boundary
   *     &lt;td&gt;Yes
   *     &lt;td&gt;Pad escape, precedes pad character
   * &lt;/table&gt;
   *
<span class="line-modified">!  * &lt;p&gt;A DecimalFormat pattern contains a postive and negative</span>
   * subpattern, for example, &quot;#,##0.00;(#,##0.00)&quot;.  Each subpattern has a
   * prefix, a numeric part, and a suffix.  If there is no explicit negative
   * subpattern, the negative subpattern is the localized minus sign prefixed to the
   * positive subpattern. That is, &quot;0.00&quot; alone is equivalent to &quot;0.00;-0.00&quot;.  If there
   * is an explicit negative subpattern, it serves only to specify the negative
<span class="line-new-header">--- 274,11 ---</span>
   *     &lt;td&gt;Prefix or suffix boundary
   *     &lt;td&gt;Yes
   *     &lt;td&gt;Pad escape, precedes pad character
   * &lt;/table&gt;
   *
<span class="line-modified">!  * &lt;p&gt;A DecimalFormat pattern contains a positive and negative</span>
   * subpattern, for example, &quot;#,##0.00;(#,##0.00)&quot;.  Each subpattern has a
   * prefix, a numeric part, and a suffix.  If there is no explicit negative
   * subpattern, the negative subpattern is the localized minus sign prefixed to the
   * positive subpattern. That is, &quot;0.00&quot; alone is equivalent to &quot;0.00;-0.00&quot;.  If there
   * is an explicit negative subpattern, it serves only to specify the negative
</pre>
<hr />
<pre>
<span class="line-old-header">*** 416,11 ***</span>
   * if the maximum fraction digits is 2.  This behavior can be changed
   * by specifying a rounding increment and/or a rounding mode.
   *
   * &lt;li&gt;If the number of actual fraction digits is less than the
   * &lt;em&gt;minimum fraction digits&lt;/em&gt;, then trailing zeros are added.
<span class="line-modified">!  * For example, 0.125 is formatted as &quot;0.1250&quot; if the mimimum fraction</span>
   * digits is set to 4.
   *
   * &lt;li&gt;Trailing fractional zeros are not displayed if they occur
   * &lt;em&gt;j&lt;/em&gt; positions after the decimal, where &lt;em&gt;j&lt;/em&gt; is less
   * than the maximum fraction digits. For example, 0.10004 is
<span class="line-new-header">--- 409,11 ---</span>
   * if the maximum fraction digits is 2.  This behavior can be changed
   * by specifying a rounding increment and/or a rounding mode.
   *
   * &lt;li&gt;If the number of actual fraction digits is less than the
   * &lt;em&gt;minimum fraction digits&lt;/em&gt;, then trailing zeros are added.
<span class="line-modified">!  * For example, 0.125 is formatted as &quot;0.1250&quot; if the minimum fraction</span>
   * digits is set to 4.
   *
   * &lt;li&gt;Trailing fractional zeros are not displayed if they occur
   * &lt;em&gt;j&lt;/em&gt; positions after the decimal, where &lt;em&gt;j&lt;/em&gt; is less
   * than the maximum fraction digits. For example, 0.10004 is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 581,13 ***</span>
   * maximum integer digit count of one, a minimum fraction digit count of
   * &lt;code&gt;getMinimumSignificantDigits() - 1&lt;/code&gt;, and a maximum fraction digit
   * count of &lt;code&gt;getMaximumSignificantDigits() - 1&lt;/code&gt;. For example, the
   * pattern &lt;code&gt;&quot;@@###E0&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;0.0###E0&quot;&lt;/code&gt;.
   *
<span class="line-modified">!  * &lt;li&gt;If signficant digits are in use, then the integer and fraction</span>
   * digit counts, as set via the API, are ignored.  If significant
<span class="line-modified">!  * digits are not in use, then the signficant digit counts, as set via</span>
   * the API, are ignored.
   *
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;strong&gt;Padding&lt;/strong&gt;
<span class="line-new-header">--- 574,13 ---</span>
   * maximum integer digit count of one, a minimum fraction digit count of
   * &lt;code&gt;getMinimumSignificantDigits() - 1&lt;/code&gt;, and a maximum fraction digit
   * count of &lt;code&gt;getMaximumSignificantDigits() - 1&lt;/code&gt;. For example, the
   * pattern &lt;code&gt;&quot;@@###E0&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;0.0###E0&quot;&lt;/code&gt;.
   *
<span class="line-modified">!  * &lt;li&gt;If significant digits are in use, then the integer and fraction</span>
   * digit counts, as set via the API, are ignored.  If significant
<span class="line-modified">!  * digits are not in use, then the significant digit counts, as set via</span>
   * the API, are ignored.
   *
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;strong&gt;Padding&lt;/strong&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 637,11 ***</span>
   * nearest 0.65 is 1.3.  The rounding increment may be specified through the API
   * or in a pattern.  To specify a rounding increment in a pattern, include the
   * increment in the pattern itself.  &quot;#,#50&quot; specifies a rounding increment of
   * 50.  &quot;#,##0.05&quot; specifies a rounding increment of 0.05.
   *
<span class="line-modified">!  * &lt;p&gt;In the absense of an explicit rounding increment numbers are</span>
   * rounded to their formatted width.
   *
   * &lt;ul&gt;
   * &lt;li&gt;Rounding only affects the string produced by formatting.  It does
   * not affect parsing or change any numerical values.
<span class="line-new-header">--- 630,11 ---</span>
   * nearest 0.65 is 1.3.  The rounding increment may be specified through the API
   * or in a pattern.  To specify a rounding increment in a pattern, include the
   * increment in the pattern itself.  &quot;#,#50&quot; specifies a rounding increment of
   * 50.  &quot;#,##0.05&quot; specifies a rounding increment of 0.05.
   *
<span class="line-modified">!  * &lt;p&gt;In the absence of an explicit rounding increment numbers are</span>
   * rounded to their formatted width.
   *
   * &lt;ul&gt;
   * &lt;li&gt;Rounding only affects the string produced by formatting.  It does
   * not affect parsing or change any numerical values.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 688,11 ***</span>
       * on NumberFormat such as createInstance. These factories will
       * return the most appropriate sub-class of NumberFormat for a given
       * locale.
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified">!      * {@link NumberFormatter} instead of DecimalFormat.</span>
       * @param status    Output param set to success/failure code. If the
       *                  pattern is invalid this will be set to a failure code.
       * @stable ICU 2.0
       */
      DecimalFormat(UErrorCode&amp; status);
<span class="line-new-header">--- 681,11 ---</span>
       * on NumberFormat such as createInstance. These factories will
       * return the most appropriate sub-class of NumberFormat for a given
       * locale.
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified">!      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
       * @param status    Output param set to success/failure code. If the
       *                  pattern is invalid this will be set to a failure code.
       * @stable ICU 2.0
       */
      DecimalFormat(UErrorCode&amp; status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 706,11 ***</span>
       * on NumberFormat such as createInstance. These factories will
       * return the most appropriate sub-class of NumberFormat for a given
       * locale.
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified">!      * {@link NumberFormatter} instead of DecimalFormat.</span>
       * @param pattern   A non-localized pattern string.
       * @param status    Output param set to success/failure code. If the
       *                  pattern is invalid this will be set to a failure code.
       * @stable ICU 2.0
       */
<span class="line-new-header">--- 699,11 ---</span>
       * on NumberFormat such as createInstance. These factories will
       * return the most appropriate sub-class of NumberFormat for a given
       * locale.
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified">!      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
       * @param pattern   A non-localized pattern string.
       * @param status    Output param set to success/failure code. If the
       *                  pattern is invalid this will be set to a failure code.
       * @stable ICU 2.0
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 726,11 ***</span>
       * createInstance or createCurrencyInstance. If you need only minor adjustments
       * to a standard format, you can modify the format returned by
       * a NumberFormat factory method.
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified">!      * {@link NumberFormatter} instead of DecimalFormat.</span>
       *
       * @param pattern           a non-localized pattern string
       * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
       *                          delete this object after making this call.
       * @param status            Output param set to success/failure code. If the
<span class="line-new-header">--- 719,11 ---</span>
       * createInstance or createCurrencyInstance. If you need only minor adjustments
       * to a standard format, you can modify the format returned by
       * a NumberFormat factory method.
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified">!      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
       *
       * @param pattern           a non-localized pattern string
       * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
       *                          delete this object after making this call.
       * @param status            Output param set to success/failure code. If the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 780,11 ***</span>
      /**
       * Set an integer attribute on this DecimalFormat.
       * May return U_UNSUPPORTED_ERROR if this instance does not support
       * the specified attribute.
       * @param attr the attribute to set
<span class="line-modified">!      * @param newvalue new value</span>
       * @param status the error type
       * @return *this - for chaining (example: format.setAttribute(...).setAttribute(...) )
       * @stable ICU 51
       */
      virtual DecimalFormat&amp; setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode&amp; status);
<span class="line-new-header">--- 773,11 ---</span>
      /**
       * Set an integer attribute on this DecimalFormat.
       * May return U_UNSUPPORTED_ERROR if this instance does not support
       * the specified attribute.
       * @param attr the attribute to set
<span class="line-modified">!      * @param newValue new value</span>
       * @param status the error type
       * @return *this - for chaining (example: format.setAttribute(...).setAttribute(...) )
       * @stable ICU 51
       */
      virtual DecimalFormat&amp; setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode&amp; status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 837,16 ***</span>
       * createInstance or createCurrencyInstance. If you need only minor adjustments
       * to a standard format, you can modify the format returned by
       * a NumberFormat factory method.
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified">!      * {@link NumberFormatter} instead of DecimalFormat.</span>
       *
       * @param pattern           a non-localized pattern string
       * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
       *                          delete this object after making this call.
<span class="line-modified">!      * @param parseError        Output param to receive errors occured during parsing</span>
       * @param status            Output param set to success/failure code. If the
       *                          pattern is invalid this will be set to a failure code.
       * @stable ICU 2.0
       */
      DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
<span class="line-new-header">--- 830,16 ---</span>
       * createInstance or createCurrencyInstance. If you need only minor adjustments
       * to a standard format, you can modify the format returned by
       * a NumberFormat factory method.
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified">!      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
       *
       * @param pattern           a non-localized pattern string
       * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
       *                          delete this object after making this call.
<span class="line-modified">!      * @param parseError        Output param to receive errors occurred during parsing</span>
       * @param status            Output param set to success/failure code. If the
       *                          pattern is invalid this will be set to a failure code.
       * @stable ICU 2.0
       */
      DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 862,11 ***</span>
       * createInstance or createCurrencyInstance. If you need only minor adjustments
       * to a standard format, you can modify the format returned by
       * a NumberFormat factory method.
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified">!      * {@link NumberFormatter} instead of DecimalFormat.</span>
       *
       * @param pattern           a non-localized pattern string
       * @param symbols   the set of symbols to be used
       * @param status            Output param set to success/failure code. If the
       *                          pattern is invalid this will be set to a failure code.
<span class="line-new-header">--- 855,11 ---</span>
       * createInstance or createCurrencyInstance. If you need only minor adjustments
       * to a standard format, you can modify the format returned by
       * a NumberFormat factory method.
       * &lt;p&gt;
       * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified">!      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
       *
       * @param pattern           a non-localized pattern string
       * @param symbols   the set of symbols to be used
       * @param status            Output param set to success/failure code. If the
       *                          pattern is invalid this will be set to a failure code.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 984,10 ***</span>
<span class="line-new-header">--- 977,11 ---</span>
       * @param number    The value to be formatted.
       * @param appendTo  Output parameter to receive result.
       *                  Result is appended to existing contents.
       * @param pos       On input: an alignment field, if desired.
       *                  On output: the offsets of the alignment field.
<span class="line-added">+      * @param status    Output param filled with success/failure status.</span>
       * @return          Reference to &#39;appendTo&#39; parameter.
       * @internal
       */
      UnicodeString&amp; format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
                            UErrorCode&amp; status) const U_OVERRIDE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1029,10 ***</span>
<span class="line-new-header">--- 1023,11 ---</span>
       * @param number    The value to be formatted.
       * @param appendTo  Output parameter to receive result.
       *                  Result is appended to existing contents.
       * @param pos       On input: an alignment field, if desired.
       *                  On output: the offsets of the alignment field.
<span class="line-added">+      * @param status    Output param filled with success/failure status.</span>
       * @return          Reference to &#39;appendTo&#39; parameter.
       * @internal
       */
      UnicodeString&amp; format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
                            UErrorCode&amp; status) const U_OVERRIDE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1118,11 ***</span>
      /**
       * Parse the given string using this object&#39;s choices. The method
       * does string comparisons to try to find an optimal match.
       * If no object can be parsed, index is unchanged, and NULL is
       * returned.  The result is returned as the most parsimonious
<span class="line-modified">!      * type of Formattable that will accomodate all of the</span>
       * necessary precision.  For example, if the result is exactly 12,
       * it will be returned as a long.  However, if it is 1.5, it will
       * be returned as a double.
       *
       * @param text           The text to be parsed.
<span class="line-new-header">--- 1113,11 ---</span>
      /**
       * Parse the given string using this object&#39;s choices. The method
       * does string comparisons to try to find an optimal match.
       * If no object can be parsed, index is unchanged, and NULL is
       * returned.  The result is returned as the most parsimonious
<span class="line-modified">!      * type of Formattable that will accommodate all of the</span>
       * necessary precision.  For example, if the result is exactly 12,
       * it will be returned as a long.  However, if it is 1.5, it will
       * be returned as a double.
       *
       * @param text           The text to be parsed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1283,24 ***</span>
       * Examples: 123%
       * @stable ICU 2.0
       */
      virtual void setNegativeSuffix(const UnicodeString&amp; newValue);
  
<span class="line-modified">! #ifndef U_HIDE_INTERNAL_API</span>
      /**
       * Whether to show the plus sign on positive (non-negative) numbers; for example, &quot;+12&quot;
<span class="line-modified">!      * @internal Technical Preview</span>
       */
      UBool isSignAlwaysShown() const;
<span class="line-removed">- #endif  /* U_HIDE_INTERNAL_API */</span>
  
      /**
<span class="line-modified">!      * Set whether to show the plus sign on positive (non-negative) numbers; for example, &quot;+12&quot;</span>
<span class="line-modified">!      * @param value The new setting for whether to show plus sign on positive numbers</span>
<span class="line-modified">!      * @internal Technical Preview</span>
       */
<span class="line-modified">!     virtual void setSignAlwaysShown(UBool value);</span>
  
      /**
       * Get the multiplier for use in percent, permill, etc.
       * For a percentage, set the suffixes to have &quot;%&quot; and the multiplier to be 100.
       * (For Arabic, use arabic percent symbol).
<span class="line-new-header">--- 1278,31 ---</span>
       * Examples: 123%
       * @stable ICU 2.0
       */
      virtual void setNegativeSuffix(const UnicodeString&amp; newValue);
  
<span class="line-modified">! #ifndef U_HIDE_DRAFT_API</span>
      /**
       * Whether to show the plus sign on positive (non-negative) numbers; for example, &quot;+12&quot;
<span class="line-modified">!      *</span>
<span class="line-added">+      * For more control over sign display, use NumberFormatter.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return Whether the sign is shown on positive numbers and zero.</span>
<span class="line-added">+      * @draft ICU 64</span>
       */
      UBool isSignAlwaysShown() const;
  
      /**
<span class="line-modified">!      * Set whether to show the plus sign on positive (non-negative) numbers; for example, &quot;+12&quot;.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * For more control over sign display, use NumberFormatter.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param value true to always show a sign; false to hide the sign on positive numbers and zero.</span>
<span class="line-added">+      * @draft ICU 64</span>
       */
<span class="line-modified">!     void setSignAlwaysShown(UBool value);</span>
<span class="line-added">+ #endif  /* U_HIDE_DRAFT_API */</span>
  
      /**
       * Get the multiplier for use in percent, permill, etc.
       * For a percentage, set the suffixes to have &quot;%&quot; and the multiplier to be 100.
       * (For Arabic, use arabic percent symbol).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1341,11 ***</span>
       *
       * @return    the current value of the power-of-ten multiplier.
       * @draft ICU 62
       */
      int32_t getMultiplierScale(void) const;
<span class="line-removed">- #endif  /* U_HIDE_DRAFT_API */</span>
  
      /**
       * Sets a power of ten by which number should be multiplied before formatting, which
       * can be combined with setMultiplier() to multiply by any arbitrary decimal value.
       *
<span class="line-new-header">--- 1343,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1362,11 ***</span>
       * This method is analogous to UNUM_SCALE in setAttribute.
       *
       * @param newValue    the new value of the power-of-ten multiplier.
       * @draft ICU 62
       */
<span class="line-modified">!     virtual void setMultiplierScale(int32_t newValue);</span>
  
      /**
       * Get the rounding increment.
       * @return A positive rounding increment, or 0.0 if a custom rounding
       * increment is not in effect.
<span class="line-new-header">--- 1363,12 ---</span>
       * This method is analogous to UNUM_SCALE in setAttribute.
       *
       * @param newValue    the new value of the power-of-ten multiplier.
       * @draft ICU 62
       */
<span class="line-modified">!     void setMultiplierScale(int32_t newValue);</span>
<span class="line-added">+ #endif  /* U_HIDE_DRAFT_API */</span>
  
      /**
       * Get the rounding increment.
       * @return A positive rounding increment, or 0.0 if a custom rounding
       * increment is not in effect.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1455,12 ***</span>
  
      /**
       * Set the character used to pad to the format width.  If padding
       * is not enabled, then this will take effect if padding is later
       * enabled.
<span class="line-modified">!      * @param padChar a string containing the pad charcter. If the string</span>
<span class="line-modified">!      * has length 0, then the pad characer is set to &#39; &#39;.  Otherwise</span>
       * padChar.char32At(0) will be used as the pad character.
       * @see #setFormatWidth
       * @see #getFormatWidth
       * @see #getPadCharacterString
       * @see #getPadPosition
<span class="line-new-header">--- 1457,12 ---</span>
  
      /**
       * Set the character used to pad to the format width.  If padding
       * is not enabled, then this will take effect if padding is later
       * enabled.
<span class="line-modified">!      * @param padChar a string containing the pad character. If the string</span>
<span class="line-modified">!      * has length 0, then the pad character is set to &#39; &#39;.  Otherwise</span>
       * padChar.char32At(0) will be used as the pad character.
       * @see #setFormatWidth
       * @see #getFormatWidth
       * @see #getPadCharacterString
       * @see #getPadPosition
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1645,47 ***</span>
       * @see DecimalFormatSymbols::setGroupingSeparator
       * @stable ICU 2.4
       */
      virtual void setSecondaryGroupingSize(int32_t newValue);
  
<span class="line-modified">! #ifndef U_HIDE_INTERNAL_API</span>
<span class="line-removed">- </span>
      /**
       * Returns the minimum number of grouping digits.
       * Grouping separators are output if there are at least this many
       * digits to the left of the first (rightmost) grouping separator,
       * that is, there are at least (minimum grouping + grouping size) integer digits.
       * (Subject to isGroupingUsed().)
       *
       * For example, if this value is 2, and the grouping size is 3, then
       * 9999 -&gt; &quot;9999&quot; and 10000 -&gt; &quot;10,000&quot;
       *
<span class="line-removed">-      * This is a technology preview. This API may change behavior or may be removed.</span>
<span class="line-removed">-      *</span>
       * The default value for this attribute is 0.
       * A value of 1, 0, or lower, means that the use of grouping separators
       * only depends on the grouping size (and on isGroupingUsed()).
<span class="line-modified">!      * Currently, the corresponding CLDR data is not used; this is likely to change.</span>
       *
       * @see setMinimumGroupingDigits
       * @see getGroupingSize
<span class="line-modified">!      * @internal technology preview</span>
       */
      int32_t getMinimumGroupingDigits() const;
  
<span class="line-removed">- #endif  /* U_HIDE_INTERNAL_API */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Cannot use #ifndef U_HIDE_INTERNAL_API for the following draft method since it is virtual. */</span>
      /**
       * Sets the minimum grouping digits. Setting to a value less than or
       * equal to 1 turns off minimum grouping digits.
       *
       * @param newValue the new value of minimum grouping digits.
       * @see getMinimumGroupingDigits
<span class="line-modified">!      * @internal technology preview</span>
       */
<span class="line-modified">!     virtual void setMinimumGroupingDigits(int32_t newValue);</span>
  
  
      /**
       * Allows you to get the behavior of the decimal separator with integers.
       * (The decimal separator will always appear with decimals.)
<span class="line-new-header">--- 1647,48 ---</span>
       * @see DecimalFormatSymbols::setGroupingSeparator
       * @stable ICU 2.4
       */
      virtual void setSecondaryGroupingSize(int32_t newValue);
  
<span class="line-modified">! #ifndef U_HIDE_DRAFT_API</span>
      /**
       * Returns the minimum number of grouping digits.
       * Grouping separators are output if there are at least this many
       * digits to the left of the first (rightmost) grouping separator,
       * that is, there are at least (minimum grouping + grouping size) integer digits.
       * (Subject to isGroupingUsed().)
       *
       * For example, if this value is 2, and the grouping size is 3, then
       * 9999 -&gt; &quot;9999&quot; and 10000 -&gt; &quot;10,000&quot;
       *
       * The default value for this attribute is 0.
       * A value of 1, 0, or lower, means that the use of grouping separators
       * only depends on the grouping size (and on isGroupingUsed()).
<span class="line-modified">!      *</span>
<span class="line-added">+      * NOTE: The CLDR data is used in NumberFormatter but not in DecimalFormat.</span>
<span class="line-added">+      * This is for backwards compatibility reasons.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * For more control over grouping strategies, use NumberFormatter.</span>
       *
       * @see setMinimumGroupingDigits
       * @see getGroupingSize
<span class="line-modified">!      * @draft ICU 64</span>
       */
      int32_t getMinimumGroupingDigits() const;
  
      /**
       * Sets the minimum grouping digits. Setting to a value less than or
       * equal to 1 turns off minimum grouping digits.
       *
<span class="line-added">+      * For more control over grouping strategies, use NumberFormatter.</span>
<span class="line-added">+      *</span>
       * @param newValue the new value of minimum grouping digits.
       * @see getMinimumGroupingDigits
<span class="line-modified">!      * @draft ICU 64</span>
       */
<span class="line-modified">!     void setMinimumGroupingDigits(int32_t newValue);</span>
<span class="line-added">+ #endif  /* U_HIDE_DRAFT_API */</span>
  
  
      /**
       * Allows you to get the behavior of the decimal separator with integers.
       * (The decimal separator will always appear with decimals.)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1723,63 ***</span>
       * @param newValue    set TRUE if input must contain a match to decimal mark in pattern
       * @stable ICU 54
       */
      virtual void setDecimalPatternMatchRequired(UBool newValue);
  
      /**
<span class="line-modified">!      * {@icu} Returns whether to ignore exponents when parsing.</span>
       *
       * @see #setParseNoExponent
<span class="line-modified">!      * @internal This API is a technical preview. It may change in an upcoming release.</span>
       */
<span class="line-modified">!     virtual UBool isParseNoExponent() const;</span>
  
      /**
<span class="line-modified">!      * {@icu} Specifies whether to stop parsing when an exponent separator is encountered. For</span>
       * example, parses &quot;123E4&quot; to 123 (with parse position 3) instead of 1230000 (with parse position
       * 5).
       *
       * @param value true to prevent exponents from being parsed; false to allow them to be parsed.
<span class="line-modified">!      * @internal This API is a technical preview. It may change in an upcoming release.</span>
       */
<span class="line-modified">!     virtual void setParseNoExponent(UBool value);</span>
  
      /**
<span class="line-modified">!      * {@icu} Returns whether parsing is sensitive to case (lowercase/uppercase).</span>
       *
       * @see #setParseCaseSensitive
<span class="line-modified">!      * @internal This API is a technical preview. It may change in an upcoming release.</span>
       */
<span class="line-modified">!     virtual UBool isParseCaseSensitive() const;</span>
  
      /**
<span class="line-modified">!      * {@icu} Whether to pay attention to case when parsing; default is to ignore case (perform</span>
       * case-folding). For example, &quot;A&quot; == &quot;a&quot; in case-insensitive but not case-sensitive mode.
       *
       * Currency symbols are never case-folded. For example, &quot;us$1.00&quot; will not parse in case-insensitive
       * mode, even though &quot;US$1.00&quot; parses.
       *
<span class="line-modified">!      * @internal This API is a technical preview. It may change in an upcoming release.</span>
       */
<span class="line-modified">!     virtual void setParseCaseSensitive(UBool value);</span>
  
      /**
<span class="line-modified">!      * {@icu} Returns whether truncation of high-order integer digits should result in an error.</span>
       * By default, setMaximumIntegerDigits truncates high-order digits silently.
       *
       * @see setFormatFailIfMoreThanMaxDigits
<span class="line-modified">!      * @internal This API is a technical preview. It may change in an upcoming release.</span>
       */
<span class="line-modified">!     virtual UBool isFormatFailIfMoreThanMaxDigits() const;</span>
  
      /**
<span class="line-modified">!      * {@icu} Sets whether truncation of high-order integer digits should result in an error.</span>
       * By default, setMaximumIntegerDigits truncates high-order digits silently.
       *
<span class="line-modified">!      * @internal This API is a technical preview. It may change in an upcoming release.</span>
       */
<span class="line-modified">!     virtual void setFormatFailIfMoreThanMaxDigits(UBool value);</span>
  
  
      /**
       * Synthesizes a pattern string that represents the current state
       * of this Format object.
<span class="line-new-header">--- 1726,71 ---</span>
       * @param newValue    set TRUE if input must contain a match to decimal mark in pattern
       * @stable ICU 54
       */
      virtual void setDecimalPatternMatchRequired(UBool newValue);
  
<span class="line-added">+ #ifndef U_HIDE_DRAFT_API</span>
      /**
<span class="line-modified">!      * Returns whether to ignore exponents when parsing.</span>
       *
<span class="line-added">+      * @return Whether to ignore exponents when parsing.</span>
       * @see #setParseNoExponent
<span class="line-modified">!      * @draft ICU 64</span>
       */
<span class="line-modified">!     UBool isParseNoExponent() const;</span>
  
      /**
<span class="line-modified">!      * Specifies whether to stop parsing when an exponent separator is encountered. For</span>
       * example, parses &quot;123E4&quot; to 123 (with parse position 3) instead of 1230000 (with parse position
       * 5).
       *
       * @param value true to prevent exponents from being parsed; false to allow them to be parsed.
<span class="line-modified">!      * @draft ICU 64</span>
       */
<span class="line-modified">!     void setParseNoExponent(UBool value);</span>
  
      /**
<span class="line-modified">!      * Returns whether parsing is sensitive to case (lowercase/uppercase).</span>
       *
<span class="line-added">+      * @return Whether parsing is case-sensitive.</span>
       * @see #setParseCaseSensitive
<span class="line-modified">!      * @draft ICU 64</span>
       */
<span class="line-modified">!     UBool isParseCaseSensitive() const;</span>
  
      /**
<span class="line-modified">!      * Whether to pay attention to case when parsing; default is to ignore case (perform</span>
       * case-folding). For example, &quot;A&quot; == &quot;a&quot; in case-insensitive but not case-sensitive mode.
       *
       * Currency symbols are never case-folded. For example, &quot;us$1.00&quot; will not parse in case-insensitive
       * mode, even though &quot;US$1.00&quot; parses.
       *
<span class="line-modified">!      * @param value true to enable case-sensitive parsing (the default); false to force</span>
<span class="line-added">+      *              case-sensitive parsing behavior.</span>
<span class="line-added">+      * @draft ICU 64</span>
       */
<span class="line-modified">!     void setParseCaseSensitive(UBool value);</span>
  
      /**
<span class="line-modified">!      * Returns whether truncation of high-order integer digits should result in an error.</span>
       * By default, setMaximumIntegerDigits truncates high-order digits silently.
       *
<span class="line-added">+      * @return Whether an error code is set if high-order digits are truncated.</span>
       * @see setFormatFailIfMoreThanMaxDigits
<span class="line-modified">!      * @draft ICU 64</span>
       */
<span class="line-modified">!     UBool isFormatFailIfMoreThanMaxDigits() const;</span>
  
      /**
<span class="line-modified">!      * Sets whether truncation of high-order integer digits should result in an error.</span>
       * By default, setMaximumIntegerDigits truncates high-order digits silently.
       *
<span class="line-modified">!      * @param value Whether to set an error code if high-order digits are truncated.</span>
<span class="line-added">+      * @draft ICU 64</span>
       */
<span class="line-modified">!     void setFormatFailIfMoreThanMaxDigits(UBool value);</span>
<span class="line-added">+ #endif  /* U_HIDE_DRAFT_API */</span>
  
  
      /**
       * Synthesizes a pattern string that represents the current state
       * of this Format object.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2015,20 ***</span>
       * @deprecated ICU 3.0. Use setCurrency(const char16_t*, UErrorCode&amp;).
       */
      virtual void setCurrency(const char16_t* theCurrency);
  
      /**
<span class="line-modified">!      * Sets the &lt;tt&gt;Currency Context&lt;/tt&gt; object used to display currency.</span>
       * This takes effect immediately, if this format is a
       * currency format.
<span class="line-modified">!      * @param currencyContext new currency context object to use.</span>
       * @stable ICU 54
       */
      void setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec);
  
      /**
<span class="line-modified">!      * Returns the &lt;tt&gt;Currency Context&lt;/tt&gt; object used to display currency</span>
       * @stable ICU 54
       */
      UCurrencyUsage getCurrencyUsage() const;
  
  #ifndef U_HIDE_INTERNAL_API
<span class="line-new-header">--- 2026,21 ---</span>
       * @deprecated ICU 3.0. Use setCurrency(const char16_t*, UErrorCode&amp;).
       */
      virtual void setCurrency(const char16_t* theCurrency);
  
      /**
<span class="line-modified">!      * Sets the `Currency Usage` object used to display currency.</span>
       * This takes effect immediately, if this format is a
       * currency format.
<span class="line-modified">!      * @param newUsage new currency usage object to use.</span>
<span class="line-added">+      * @param ec input-output error code</span>
       * @stable ICU 54
       */
      void setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec);
  
      /**
<span class="line-modified">!      * Returns the `Currency Usage` object used to display currency</span>
       * @stable ICU 54
       */
      UCurrencyUsage getCurrencyUsage() const;
  
  #ifndef U_HIDE_INTERNAL_API
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2048,38 ***</span>
       *  @internal
       */
      void formatToDecimalQuantity(const Formattable&amp; number, number::impl::DecimalQuantity&amp; output,
                                   UErrorCode&amp; status) const;
  
<span class="line-modified">! #endif</span>
  
  #ifndef U_HIDE_DRAFT_API
      /**
<span class="line-modified">!      * Converts this DecimalFormat to a NumberFormatter.  Starting in ICU 60,</span>
<span class="line-modified">!      * NumberFormatter is the recommended way to format numbers.</span>
       *
       * NOTE: The returned LocalizedNumberFormatter is owned by this DecimalFormat.
       * If a non-const method is called on the DecimalFormat, or if the DecimalFormat
       * is deleted, the object becomes invalid. If you plan to keep the return value
       * beyond the lifetime of the DecimalFormat, copy it to a local variable:
       *
       * &lt;pre&gt;
<span class="line-modified">!      * LocalizedNumberFormatter f = df-&gt;toNumberFormatter();</span>
       * &lt;/pre&gt;
       *
<span class="line-modified">!      * It is, however, safe to use the return value for chaining:</span>
       *
<span class="line-modified">!      * &lt;pre&gt;</span>
<span class="line-modified">!      * FormattedNumber result = df-&gt;toNumberFormatter().formatDouble(123, status);</span>
<span class="line-removed">-      * &lt;/pre&gt;</span>
       *
<span class="line-modified">!      * @param output The variable into which to store the LocalizedNumberFormatter.</span>
<span class="line-modified">!      * @return The output variable, for chaining.</span>
<span class="line-modified">!      * @draft ICU 62</span>
       */
      const number::LocalizedNumberFormatter&amp; toNumberFormatter() const;
<span class="line-modified">! #endif  /* U_HIDE_DRAFT_API */</span>
  
      /**
       * Return the class ID for this class.  This is useful only for
       * comparing to a return value from getDynamicClassID().  For example:
       * &lt;pre&gt;
<span class="line-new-header">--- 2060,76 ---</span>
       *  @internal
       */
      void formatToDecimalQuantity(const Formattable&amp; number, number::impl::DecimalQuantity&amp; output,
                                   UErrorCode&amp; status) const;
  
<span class="line-modified">! #endif  /* U_HIDE_INTERNAL_API */</span>
  
  #ifndef U_HIDE_DRAFT_API
      /**
<span class="line-modified">!      * Converts this DecimalFormat to a (Localized)NumberFormatter. Starting</span>
<span class="line-modified">!      * in ICU 60, NumberFormatter is the recommended way to format numbers.</span>
<span class="line-added">+      * You can use the returned LocalizedNumberFormatter to format numbers and</span>
<span class="line-added">+      * get a FormattedNumber, which contains a string as well as additional</span>
<span class="line-added">+      * annotations about the formatted value.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If a memory allocation failure occurs, the return value of this method</span>
<span class="line-added">+      * might be null. If you are concerned about correct recovery from</span>
<span class="line-added">+      * out-of-memory situations, use this pattern:</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;pre&gt;</span>
<span class="line-added">+      * FormattedNumber result;</span>
<span class="line-added">+      * if (auto* ptr = df-&gt;toNumberFormatter(status)) {</span>
<span class="line-added">+      *     result = ptr-&gt;formatDouble(123, status);</span>
<span class="line-added">+      * }</span>
<span class="line-added">+      * &lt;/pre&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If you are not concerned about out-of-memory situations, or if your</span>
<span class="line-added">+      * environment throws exceptions when memory allocation failure occurs,</span>
<span class="line-added">+      * you can chain the methods, like this:</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;pre&gt;</span>
<span class="line-added">+      * FormattedNumber result = df</span>
<span class="line-added">+      *     -&gt;toNumberFormatter(status)</span>
<span class="line-added">+      *     -&gt;formatDouble(123, status);</span>
<span class="line-added">+      * &lt;/pre&gt;</span>
       *
       * NOTE: The returned LocalizedNumberFormatter is owned by this DecimalFormat.
       * If a non-const method is called on the DecimalFormat, or if the DecimalFormat
       * is deleted, the object becomes invalid. If you plan to keep the return value
       * beyond the lifetime of the DecimalFormat, copy it to a local variable:
       *
       * &lt;pre&gt;
<span class="line-modified">!      * LocalizedNumberFormatter lnf;</span>
<span class="line-added">+      * if (auto* ptr = df-&gt;toNumberFormatter(status)) {</span>
<span class="line-added">+      *     lnf = *ptr;</span>
<span class="line-added">+      * }</span>
       * &lt;/pre&gt;
       *
<span class="line-modified">!      * @param status Set on failure, like U_MEMORY_ALLOCATION_ERROR.</span>
<span class="line-added">+      * @return A pointer to an internal object, or nullptr on failure.</span>
<span class="line-added">+      *         Do not delete the return value!</span>
<span class="line-added">+      * @draft ICU 64</span>
<span class="line-added">+      */</span>
<span class="line-added">+     const number::LocalizedNumberFormatter* toNumberFormatter(UErrorCode&amp; status) const;</span>
<span class="line-added">+ #endif  /* U_HIDE_DRAFT_API */</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifndef U_HIDE_DEPRECATED_API</span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Deprecated: Like {@link #toNumberFormatter(UErrorCode&amp;) const},</span>
<span class="line-added">+      * but does not take an error code.</span>
       *
<span class="line-modified">!      * The new signature should be used in case an error occurs while returning the</span>
<span class="line-modified">!      * LocalizedNumberFormatter.</span>
       *
<span class="line-modified">!      * This old signature will be removed in ICU 65.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return A reference to an internal object.</span>
<span class="line-added">+      * @deprecated ICU 64</span>
       */
      const number::LocalizedNumberFormatter&amp; toNumberFormatter() const;
<span class="line-modified">! #endif  /* U_HIDE_DEPRECATED_API */</span>
  
      /**
       * Return the class ID for this class.  This is useful only for
       * comparing to a return value from getDynamicClassID().  For example:
       * &lt;pre&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2108,11 ***</span>
    private:
  
      /** Rebuilds the formatter object from the property bag. */
      void touch(UErrorCode&amp; status);
  
<span class="line-modified">!     /** Rebuilds the formatter object, hiding the error code. */</span>
      void touchNoError();
  
      /**
       * Updates the property bag with settings from the given pattern.
       *
<span class="line-new-header">--- 2158,11 ---</span>
    private:
  
      /** Rebuilds the formatter object from the property bag. */
      void touch(UErrorCode&amp; status);
  
<span class="line-modified">!     /** Rebuilds the formatter object, ignoring any error code. */</span>
      void touchNoError();
  
      /**
       * Updates the property bag with settings from the given pattern.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2147,16 ***</span>
  
      //=====================================================================================//
      //                                   INSTANCE FIELDS                                   //
      //=====================================================================================//
  
<span class="line-modified">!     // Only one instance field: keep all fields inside of an implementation class defined in number_mapper.h</span>
<span class="line-modified">!     number::impl::DecimalFormatFields* fields;</span>
  
      // Allow child class CompactDecimalFormat to access fProperties:
      friend class CompactDecimalFormat;
  
  };
  
  U_NAMESPACE_END
  
  #endif /* #if !UCONFIG_NO_FORMATTING */
<span class="line-new-header">--- 2197,21 ---</span>
  
      //=====================================================================================//
      //                                   INSTANCE FIELDS                                   //
      //=====================================================================================//
  
<span class="line-modified">! </span>
<span class="line-modified">!     // One instance field for the implementation, keep all fields inside of an implementation</span>
<span class="line-added">+     // class defined in number_mapper.h</span>
<span class="line-added">+     number::impl::DecimalFormatFields* fields = nullptr;</span>
  
      // Allow child class CompactDecimalFormat to access fProperties:
      friend class CompactDecimalFormat;
  
<span class="line-added">+     // Allow MeasureFormat to use fieldPositionHelper:</span>
<span class="line-added">+     friend class MeasureFormat;</span>
<span class="line-added">+ </span>
  };
  
  U_NAMESPACE_END
  
  #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
<center><a href="dcfmtsym.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="dtitvfmt.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>