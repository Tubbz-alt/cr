<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/uspoof.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="usearch.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../upluralrules.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/uspoof.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  77  * \endcode
  78  *
  79  * &lt;p&gt;
  80  * The call to {@link uspoof_open} creates a &lt;code&gt;USpoofChecker&lt;/code&gt; object; the call to {@link uspoof_setChecks}
  81  * enables confusable checking and disables all other checks; the call to {@link uspoof_areConfusable} performs the
  82  * confusability test; and the following line extracts the result out of the return value. For best performance,
  83  * the instance should be created once (e.g., upon application startup), and the efficient
  84  * {@link uspoof_areConfusable} method can be used at runtime.
  85  *
  86  * &lt;p&gt;
  87  * The type {@link LocalUSpoofCheckerPointer} is exposed for C++ programmers.  It will automatically call
  88  * {@link uspoof_close} when the object goes out of scope:
  89  *
  90  * \code{.cpp}
  91  * UErrorCode status = U_ZERO_ERROR;
  92  * LocalUSpoofCheckerPointer sc(uspoof_open(&amp;status));
  93  * uspoof_setChecks(sc.getAlias(), USPOOF_CONFUSABLE, &amp;status);
  94  * // ...
  95  * \endcode
  96  *
<span class="line-removed">  97  * &lt;p&gt;</span>
  98  * UTS 39 defines two strings to be &lt;em&gt;confusable&lt;/em&gt; if they map to the same &lt;em&gt;skeleton string&lt;/em&gt;. A skeleton can
  99  * be thought of as a &quot;hash code&quot;. {@link uspoof_getSkeleton} computes the skeleton for a particular string, so
 100  * the following snippet is equivalent to the example above:
 101  *
 102  * \code{.c}
 103  * UErrorCode status = U_ZERO_ERROR;
 104  * UChar* str1 = (UChar*) u&quot;Harvest&quot;;
 105  * UChar* str2 = (UChar*) u&quot;\u0397arvest&quot;;  // with U+0397 GREEK CAPITAL LETTER ETA
 106  *
 107  * USpoofChecker* sc = uspoof_open(&amp;status);
 108  * uspoof_setChecks(sc, USPOOF_CONFUSABLE, &amp;status);
 109  *
 110  * // Get skeleton 1
 111  * int32_t skel1Len = uspoof_getSkeleton(sc, 0, str1, -1, NULL, 0, &amp;status);
 112  * UChar* skel1 = (UChar*) malloc(++skel1Len * sizeof(UChar));
 113  * status = U_ZERO_ERROR;
 114  * uspoof_getSkeleton(sc, 0, str1, -1, skel1, skel1Len, &amp;status);
 115  *
 116  * // Get skeleton 2
 117  * int32_t skel2Len = uspoof_getSkeleton(sc, 0, str2, -1, NULL, 0, &amp;status);
<span class="line-removed"> 131  * &lt;p&gt;</span>
 132  * If you need to check if a string is confusable with any string in a dictionary of many strings, rather than calling
 133  * {@link uspoof_areConfusable} many times in a loop, {@link uspoof_getSkeleton} can be used instead, as shown below:
 134  *
 135  * \code{.c}
 136  * UErrorCode status = U_ZERO_ERROR;
 137  * #define DICTIONARY_LENGTH 2
 138  * UChar* dictionary[DICTIONARY_LENGTH] = { (UChar*) u&quot;lorem&quot;, (UChar*) u&quot;ipsum&quot; };
 139  * UChar* skeletons[DICTIONARY_LENGTH];
 140  * UChar* str = (UChar*) u&quot;1orern&quot;;
 141  *
 142  * // Setup:
 143  * USpoofChecker* sc = uspoof_open(&amp;status);
 144  * uspoof_setChecks(sc, USPOOF_CONFUSABLE, &amp;status);
 145  * for (size_t i=0; i&lt;DICTIONARY_LENGTH; i++) {
 146  *     UChar* word = dictionary[i];
 147  *     int32_t len = uspoof_getSkeleton(sc, 0, word, -1, NULL, 0, &amp;status);
 148  *     skeletons[i] = (UChar*) malloc(++len * sizeof(UChar));
 149  *     status = U_ZERO_ERROR;
 150  *     uspoof_getSkeleton(sc, 0, word, -1, skeletons[i], len, &amp;status);
 151  * }
</pre>
<hr />
<pre>
 155  *     int32_t len = uspoof_getSkeleton(sc, 0, str, -1, NULL, 0, &amp;status);
 156  *     UChar* skel = (UChar*) malloc(++len * sizeof(UChar));
 157  *     status = U_ZERO_ERROR;
 158  *     uspoof_getSkeleton(sc, 0, str, -1, skel, len, &amp;status);
 159  *     UBool result = FALSE;
 160  *     for (size_t i=0; i&lt;DICTIONARY_LENGTH; i++) {
 161  *         result = u_strcmp(skel, skeletons[i]) == 0;
 162  *         if (result == TRUE) { break; }
 163  *     }
 164  *     // Has confusable in dictionary: 1 (status: U_ZERO_ERROR)
 165  *     printf(&quot;Has confusable in dictionary: %d (status: %s)\n&quot;, result, u_errorName(status));
 166  *     free(skel);
 167  * }
 168  *
 169  * for (size_t i=0; i&lt;DICTIONARY_LENGTH; i++) {
 170  *     free(skeletons[i]);
 171  * }
 172  * uspoof_close(sc);
 173  * \endcode
 174  *
<span class="line-removed"> 175  * &lt;p&gt;</span>
 176  * &lt;b&gt;Note:&lt;/b&gt; Since the Unicode confusables mapping table is frequently updated, confusable skeletons are &lt;em&gt;not&lt;/em&gt;
 177  * guaranteed to be the same between ICU releases. We therefore recommend that you always compute confusable skeletons
 178  * at runtime and do not rely on creating a permanent, or difficult to update, database of skeletons.
 179  *
 180  * &lt;h2&gt;Spoof Detection&lt;/h2&gt;
 181  *
<span class="line-removed"> 182  * &lt;p&gt;</span>
 183  * The following snippet shows a minimal example of using &lt;code&gt;USpoofChecker&lt;/code&gt; to perform spoof detection on a
 184  * string:
 185  *
 186  * \code{.c}
 187  * UErrorCode status = U_ZERO_ERROR;
 188  * UChar* str = (UChar*) u&quot;p\u0430ypal&quot;;  // with U+0430 CYRILLIC SMALL LETTER A
 189  *
 190  * // Get the default set of allowable characters:
 191  * USet* allowed = uset_openEmpty();
 192  * uset_addAll(allowed, uspoof_getRecommendedSet(&amp;status));
 193  * uset_addAll(allowed, uspoof_getInclusionSet(&amp;status));
 194  *
 195  * USpoofChecker* sc = uspoof_open(&amp;status);
 196  * uspoof_setAllowedChars(sc, allowed, &amp;status);
 197  * uspoof_setRestrictionLevel(sc, USPOOF_MODERATELY_RESTRICTIVE);
 198  *
 199  * int32_t bitmask = uspoof_check(sc, str, -1, NULL, &amp;status);
 200  * UBool result = bitmask != 0;
 201  * // fails checks: 1 (status: U_ZERO_ERROR)
 202  * printf(&quot;fails checks: %d (status: %s)\n&quot;, result, u_errorName(status));
<span class="line-removed"> 207  * &lt;p&gt;</span>
 208  * As in the case for confusability checking, it is good practice to create one &lt;code&gt;USpoofChecker&lt;/code&gt; instance at
 209  * startup, and call the cheaper {@link uspoof_check} online. We specify the set of
 210  * allowed characters to be those with type RECOMMENDED or INCLUSION, according to the recommendation in UTS 39.
 211  *
<span class="line-removed"> 212  * &lt;p&gt;</span>
 213  * In addition to {@link uspoof_check}, the function {@link uspoof_checkUTF8} is exposed for UTF8-encoded char* strings,
 214  * and {@link uspoof_checkUnicodeString} is exposed for C++ programmers.
 215  *
<span class="line-removed"> 216  * &lt;p&gt;</span>
 217  * If the {@link USPOOF_AUX_INFO} check is enabled, a limited amount of information on why a string failed the checks
 218  * is available in the returned bitmask.  For complete information, use the {@link uspoof_check2} class of functions
 219  * with a {@link USpoofCheckResult} parameter:
 220  *
 221  * \code{.c}
 222  * UErrorCode status = U_ZERO_ERROR;
 223  * UChar* str = (UChar*) u&quot;p\u0430ypal&quot;;  // with U+0430 CYRILLIC SMALL LETTER A
 224  *
 225  * // Get the default set of allowable characters:
 226  * USet* allowed = uset_openEmpty();
 227  * uset_addAll(allowed, uspoof_getRecommendedSet(&amp;status));
 228  * uset_addAll(allowed, uspoof_getInclusionSet(&amp;status));
 229  *
 230  * USpoofChecker* sc = uspoof_open(&amp;status);
 231  * uspoof_setAllowedChars(sc, allowed, &amp;status);
 232  * uspoof_setRestrictionLevel(sc, USPOOF_MODERATELY_RESTRICTIVE);
 233  *
 234  * USpoofCheckResult* checkResult = uspoof_openCheckResult(&amp;status);
 235  * int32_t bitmask = uspoof_check2(sc, str, -1, checkResult, &amp;status);
 236  *
</pre>
<hr />
<pre>
 257  * UnicodeSet allowed;
 258  * allowed.addAll(*uspoof_getRecommendedUnicodeSet(&amp;status));
 259  * allowed.addAll(*uspoof_getInclusionUnicodeSet(&amp;status));
 260  *
 261  * LocalUSpoofCheckerPointer sc(uspoof_open(&amp;status));
 262  * uspoof_setAllowedChars(sc.getAlias(), allowed.toUSet(), &amp;status);
 263  * uspoof_setRestrictionLevel(sc.getAlias(), USPOOF_MODERATELY_RESTRICTIVE);
 264  *
 265  * LocalUSpoofCheckResultPointer checkResult(uspoof_openCheckResult(&amp;status));
 266  * int32_t bitmask = uspoof_check2UnicodeString(sc.getAlias(), str, checkResult.getAlias(), &amp;status);
 267  *
 268  * int32_t failures1 = bitmask;
 269  * int32_t failures2 = uspoof_getCheckResultChecks(checkResult.getAlias(), &amp;status);
 270  * assert(failures1 == failures2);
 271  * // checks that failed: 0x00000010 (status: U_ZERO_ERROR)
 272  * printf(&quot;checks that failed: %#010x (status: %s)\n&quot;, failures1, u_errorName(status));
 273  *
 274  * // Explicit cleanup not necessary.
 275  * \endcode
 276  *
<span class="line-removed"> 277  * &lt;p&gt;</span>
 278  * The return value is a bitmask of the checks that failed. In this case, there was one check that failed:
 279  * {@link USPOOF_RESTRICTION_LEVEL}, corresponding to the fifth bit (16). The possible checks are:
 280  *
 281  * &lt;ul&gt;
 282  * &lt;li&gt;&lt;code&gt;RESTRICTION_LEVEL&lt;/code&gt;: flags strings that violate the
 283  * &lt;a href=&quot;http://unicode.org/reports/tr39/#Restriction_Level_Detection&quot;&gt;Restriction Level&lt;/a&gt; test as specified in UTS
 284  * 39; in most cases, this means flagging strings that contain characters from multiple different scripts.&lt;/li&gt;
 285  * &lt;li&gt;&lt;code&gt;INVISIBLE&lt;/code&gt;: flags strings that contain invisible characters, such as zero-width spaces, or character
 286  * sequences that are likely not to display, such as multiple occurrences of the same non-spacing mark.&lt;/li&gt;
 287  * &lt;li&gt;&lt;code&gt;CHAR_LIMIT&lt;/code&gt;: flags strings that contain characters outside of a specified set of acceptable
 288  * characters. See {@link uspoof_setAllowedChars} and {@link uspoof_setAllowedLocales}.&lt;/li&gt;
 289  * &lt;li&gt;&lt;code&gt;MIXED_NUMBERS&lt;/code&gt;: flags strings that contain digits from multiple different numbering systems.&lt;/li&gt;
 290  * &lt;/ul&gt;
 291  *
 292  * &lt;p&gt;
 293  * These checks can be enabled independently of each other. For example, if you were interested in checking for only the
 294  * INVISIBLE and MIXED_NUMBERS conditions, you could do:
 295  *
 296  * \code{.c}
 297  * UErrorCode status = U_ZERO_ERROR;
<span class="line-removed"> 310  * &lt;p&gt;</span>
 311  * Here is an example in C++ showing how to compute the restriction level of a string:
 312  *
 313  * \code{.cpp}
 314  * UErrorCode status = U_ZERO_ERROR;
 315  * UnicodeString str((UChar*) u&quot;p\u0430ypal&quot;);  // with U+0430 CYRILLIC SMALL LETTER A
 316  *
 317  * // Get the default set of allowable characters:
 318  * UnicodeSet allowed;
 319  * allowed.addAll(*uspoof_getRecommendedUnicodeSet(&amp;status));
 320  * allowed.addAll(*uspoof_getInclusionUnicodeSet(&amp;status));
 321  *
 322  * LocalUSpoofCheckerPointer sc(uspoof_open(&amp;status));
 323  * uspoof_setAllowedChars(sc.getAlias(), allowed.toUSet(), &amp;status);
 324  * uspoof_setRestrictionLevel(sc.getAlias(), USPOOF_MODERATELY_RESTRICTIVE);
 325  * uspoof_setChecks(sc.getAlias(), USPOOF_RESTRICTION_LEVEL | USPOOF_AUX_INFO, &amp;status);
 326  *
 327  * LocalUSpoofCheckResultPointer checkResult(uspoof_openCheckResult(&amp;status));
 328  * int32_t bitmask = uspoof_check2UnicodeString(sc.getAlias(), str, checkResult.getAlias(), &amp;status);
 329  *
 330  * URestrictionLevel restrictionLevel = uspoof_getCheckResultRestrictionLevel(checkResult.getAlias(), &amp;status);
<span class="line-removed"> 337  * &lt;p&gt;</span>
 338  * The code &#39;0x50000000&#39; corresponds to the restriction level USPOOF_MINIMALLY_RESTRICTIVE.  Since
 339  * USPOOF_MINIMALLY_RESTRICTIVE is weaker than USPOOF_MODERATELY_RESTRICTIVE, the string fails the check.
 340  *
<span class="line-removed"> 341  * &lt;p&gt;</span>
 342  * &lt;b&gt;Note:&lt;/b&gt; The Restriction Level is the most powerful of the checks. The full logic is documented in
 343  * &lt;a href=&quot;http://unicode.org/reports/tr39/#Restriction_Level_Detection&quot;&gt;UTS 39&lt;/a&gt;, but the basic idea is that strings
 344  * are restricted to contain characters from only a single script, &lt;em&gt;except&lt;/em&gt; that most scripts are allowed to have
 345  * Latin characters interspersed. Although the default restriction level is &lt;code&gt;HIGHLY_RESTRICTIVE&lt;/code&gt;, it is
 346  * recommended that users set their restriction level to &lt;code&gt;MODERATELY_RESTRICTIVE&lt;/code&gt;, which allows Latin mixed
 347  * with all other scripts except Cyrillic, Greek, and Cherokee, with which it is often confusable. For more details on
 348  * the levels, see UTS 39 or {@link URestrictionLevel}. The Restriction Level test is aware of the set of
 349  * allowed characters set in {@link uspoof_setAllowedChars}. Note that characters which have script code
 350  * COMMON or INHERITED, such as numbers and punctuation, are ignored when computing whether a string has multiple
 351  * scripts.
 352  *
 353  * &lt;h2&gt;Additional Information&lt;/h2&gt;
 354  *
<span class="line-removed"> 355  * &lt;p&gt;</span>
 356  * A &lt;code&gt;USpoofChecker&lt;/code&gt; instance may be used repeatedly to perform checks on any number of identifiers.
 357  *
<span class="line-removed"> 358  * &lt;p&gt;</span>
 359  * &lt;b&gt;Thread Safety:&lt;/b&gt; The test functions for checking a single identifier, or for testing whether
 360  * two identifiers are possible confusable, are thread safe. They may called concurrently, from multiple threads,
 361  * using the same USpoofChecker instance.
 362  *
<span class="line-removed"> 363  * &lt;p&gt;</span>
 364  * More generally, the standard ICU thread safety rules apply: functions that take a const USpoofChecker parameter are
 365  * thread safe. Those that take a non-const USpoofChecker are not thread safe..
 366  *
 367  * @stable ICU 4.6
 368  */
 369 
 370 struct USpoofChecker;
 371 /**
 372  * @stable ICU 4.2
 373  */
 374 typedef struct USpoofChecker USpoofChecker; /**&lt; typedef for C of USpoofChecker */
 375 
 376 struct USpoofCheckResult;
 377 /**
 378  * @see uspoof_openCheckResult
 379  * @stable ICU 58
 380  */
 381 typedef struct USpoofCheckResult USpoofCheckResult;
 382 
 383 /**
</pre>
<hr />
<pre>
1202  */
1203 U_STABLE USpoofCheckResult* U_EXPORT2
1204 uspoof_openCheckResult(UErrorCode *status);
1205 
1206 /**
1207  * Close a USpoofCheckResult, freeing any memory that was being held by
1208  *   its implementation.
1209  *
1210  * @param checkResult  The instance of USpoofCheckResult to close
1211  * @stable ICU 58
1212  */
1213 U_STABLE void U_EXPORT2
1214 uspoof_closeCheckResult(USpoofCheckResult *checkResult);
1215 
1216 #if U_SHOW_CPLUSPLUS_API
1217 
1218 U_NAMESPACE_BEGIN
1219 
1220 /**
1221  * \class LocalUSpoofCheckResultPointer
<span class="line-modified">1222  * &quot;Smart pointer&quot; class, closes a USpoofCheckResult via {@link uspoof_closeCheckResult}.</span>
1223  * For most methods see the LocalPointerBase base class.
1224  *
1225  * @see LocalPointerBase
1226  * @see LocalPointer
1227  * @stable ICU 58
1228  */






1229 U_DEFINE_LOCAL_OPEN_POINTER(LocalUSpoofCheckResultPointer, USpoofCheckResult, uspoof_closeCheckResult);

1230 
1231 U_NAMESPACE_END
1232 
1233 #endif
1234 
1235 /**
1236  * Indicates which of the spoof check(s) have failed. The value is a bitwise OR of the constants for the tests
1237  * in question: USPOOF_RESTRICTION_LEVEL, USPOOF_CHAR_LIMIT, and so on.
1238  *
1239  * @param checkResult  The instance of USpoofCheckResult created by {@link uspoof_openCheckResult}
1240  * @param status       The error code, set if an error occurred.
1241  * @return        An integer value with bits set for any potential security
1242  *                or spoofing issues detected.  The bits are defined by
1243  *                enum USpoofChecks.  (returned_value &amp; USPOOF_ALL_CHECKS)
1244  *                will be zero if the input string passes all of the
1245  *                enabled checks.
1246  * @see uspoof_setChecks
1247  * @stable ICU 58
1248  */
1249 U_STABLE int32_t U_EXPORT2
</pre>
</td>
<td>
<hr />
<pre>
  77  * \endcode
  78  *
  79  * &lt;p&gt;
  80  * The call to {@link uspoof_open} creates a &lt;code&gt;USpoofChecker&lt;/code&gt; object; the call to {@link uspoof_setChecks}
  81  * enables confusable checking and disables all other checks; the call to {@link uspoof_areConfusable} performs the
  82  * confusability test; and the following line extracts the result out of the return value. For best performance,
  83  * the instance should be created once (e.g., upon application startup), and the efficient
  84  * {@link uspoof_areConfusable} method can be used at runtime.
  85  *
  86  * &lt;p&gt;
  87  * The type {@link LocalUSpoofCheckerPointer} is exposed for C++ programmers.  It will automatically call
  88  * {@link uspoof_close} when the object goes out of scope:
  89  *
  90  * \code{.cpp}
  91  * UErrorCode status = U_ZERO_ERROR;
  92  * LocalUSpoofCheckerPointer sc(uspoof_open(&amp;status));
  93  * uspoof_setChecks(sc.getAlias(), USPOOF_CONFUSABLE, &amp;status);
  94  * // ...
  95  * \endcode
  96  *

  97  * UTS 39 defines two strings to be &lt;em&gt;confusable&lt;/em&gt; if they map to the same &lt;em&gt;skeleton string&lt;/em&gt;. A skeleton can
  98  * be thought of as a &quot;hash code&quot;. {@link uspoof_getSkeleton} computes the skeleton for a particular string, so
  99  * the following snippet is equivalent to the example above:
 100  *
 101  * \code{.c}
 102  * UErrorCode status = U_ZERO_ERROR;
 103  * UChar* str1 = (UChar*) u&quot;Harvest&quot;;
 104  * UChar* str2 = (UChar*) u&quot;\u0397arvest&quot;;  // with U+0397 GREEK CAPITAL LETTER ETA
 105  *
 106  * USpoofChecker* sc = uspoof_open(&amp;status);
 107  * uspoof_setChecks(sc, USPOOF_CONFUSABLE, &amp;status);
 108  *
 109  * // Get skeleton 1
 110  * int32_t skel1Len = uspoof_getSkeleton(sc, 0, str1, -1, NULL, 0, &amp;status);
 111  * UChar* skel1 = (UChar*) malloc(++skel1Len * sizeof(UChar));
 112  * status = U_ZERO_ERROR;
 113  * uspoof_getSkeleton(sc, 0, str1, -1, skel1, skel1Len, &amp;status);
 114  *
 115  * // Get skeleton 2
 116  * int32_t skel2Len = uspoof_getSkeleton(sc, 0, str2, -1, NULL, 0, &amp;status);

 130  * If you need to check if a string is confusable with any string in a dictionary of many strings, rather than calling
 131  * {@link uspoof_areConfusable} many times in a loop, {@link uspoof_getSkeleton} can be used instead, as shown below:
 132  *
 133  * \code{.c}
 134  * UErrorCode status = U_ZERO_ERROR;
 135  * #define DICTIONARY_LENGTH 2
 136  * UChar* dictionary[DICTIONARY_LENGTH] = { (UChar*) u&quot;lorem&quot;, (UChar*) u&quot;ipsum&quot; };
 137  * UChar* skeletons[DICTIONARY_LENGTH];
 138  * UChar* str = (UChar*) u&quot;1orern&quot;;
 139  *
 140  * // Setup:
 141  * USpoofChecker* sc = uspoof_open(&amp;status);
 142  * uspoof_setChecks(sc, USPOOF_CONFUSABLE, &amp;status);
 143  * for (size_t i=0; i&lt;DICTIONARY_LENGTH; i++) {
 144  *     UChar* word = dictionary[i];
 145  *     int32_t len = uspoof_getSkeleton(sc, 0, word, -1, NULL, 0, &amp;status);
 146  *     skeletons[i] = (UChar*) malloc(++len * sizeof(UChar));
 147  *     status = U_ZERO_ERROR;
 148  *     uspoof_getSkeleton(sc, 0, word, -1, skeletons[i], len, &amp;status);
 149  * }
</pre>
<hr />
<pre>
 153  *     int32_t len = uspoof_getSkeleton(sc, 0, str, -1, NULL, 0, &amp;status);
 154  *     UChar* skel = (UChar*) malloc(++len * sizeof(UChar));
 155  *     status = U_ZERO_ERROR;
 156  *     uspoof_getSkeleton(sc, 0, str, -1, skel, len, &amp;status);
 157  *     UBool result = FALSE;
 158  *     for (size_t i=0; i&lt;DICTIONARY_LENGTH; i++) {
 159  *         result = u_strcmp(skel, skeletons[i]) == 0;
 160  *         if (result == TRUE) { break; }
 161  *     }
 162  *     // Has confusable in dictionary: 1 (status: U_ZERO_ERROR)
 163  *     printf(&quot;Has confusable in dictionary: %d (status: %s)\n&quot;, result, u_errorName(status));
 164  *     free(skel);
 165  * }
 166  *
 167  * for (size_t i=0; i&lt;DICTIONARY_LENGTH; i++) {
 168  *     free(skeletons[i]);
 169  * }
 170  * uspoof_close(sc);
 171  * \endcode
 172  *

 173  * &lt;b&gt;Note:&lt;/b&gt; Since the Unicode confusables mapping table is frequently updated, confusable skeletons are &lt;em&gt;not&lt;/em&gt;
 174  * guaranteed to be the same between ICU releases. We therefore recommend that you always compute confusable skeletons
 175  * at runtime and do not rely on creating a permanent, or difficult to update, database of skeletons.
 176  *
 177  * &lt;h2&gt;Spoof Detection&lt;/h2&gt;
 178  *

 179  * The following snippet shows a minimal example of using &lt;code&gt;USpoofChecker&lt;/code&gt; to perform spoof detection on a
 180  * string:
 181  *
 182  * \code{.c}
 183  * UErrorCode status = U_ZERO_ERROR;
 184  * UChar* str = (UChar*) u&quot;p\u0430ypal&quot;;  // with U+0430 CYRILLIC SMALL LETTER A
 185  *
 186  * // Get the default set of allowable characters:
 187  * USet* allowed = uset_openEmpty();
 188  * uset_addAll(allowed, uspoof_getRecommendedSet(&amp;status));
 189  * uset_addAll(allowed, uspoof_getInclusionSet(&amp;status));
 190  *
 191  * USpoofChecker* sc = uspoof_open(&amp;status);
 192  * uspoof_setAllowedChars(sc, allowed, &amp;status);
 193  * uspoof_setRestrictionLevel(sc, USPOOF_MODERATELY_RESTRICTIVE);
 194  *
 195  * int32_t bitmask = uspoof_check(sc, str, -1, NULL, &amp;status);
 196  * UBool result = bitmask != 0;
 197  * // fails checks: 1 (status: U_ZERO_ERROR)
 198  * printf(&quot;fails checks: %d (status: %s)\n&quot;, result, u_errorName(status));

 203  * As in the case for confusability checking, it is good practice to create one &lt;code&gt;USpoofChecker&lt;/code&gt; instance at
 204  * startup, and call the cheaper {@link uspoof_check} online. We specify the set of
 205  * allowed characters to be those with type RECOMMENDED or INCLUSION, according to the recommendation in UTS 39.
 206  *

 207  * In addition to {@link uspoof_check}, the function {@link uspoof_checkUTF8} is exposed for UTF8-encoded char* strings,
 208  * and {@link uspoof_checkUnicodeString} is exposed for C++ programmers.
 209  *

 210  * If the {@link USPOOF_AUX_INFO} check is enabled, a limited amount of information on why a string failed the checks
 211  * is available in the returned bitmask.  For complete information, use the {@link uspoof_check2} class of functions
 212  * with a {@link USpoofCheckResult} parameter:
 213  *
 214  * \code{.c}
 215  * UErrorCode status = U_ZERO_ERROR;
 216  * UChar* str = (UChar*) u&quot;p\u0430ypal&quot;;  // with U+0430 CYRILLIC SMALL LETTER A
 217  *
 218  * // Get the default set of allowable characters:
 219  * USet* allowed = uset_openEmpty();
 220  * uset_addAll(allowed, uspoof_getRecommendedSet(&amp;status));
 221  * uset_addAll(allowed, uspoof_getInclusionSet(&amp;status));
 222  *
 223  * USpoofChecker* sc = uspoof_open(&amp;status);
 224  * uspoof_setAllowedChars(sc, allowed, &amp;status);
 225  * uspoof_setRestrictionLevel(sc, USPOOF_MODERATELY_RESTRICTIVE);
 226  *
 227  * USpoofCheckResult* checkResult = uspoof_openCheckResult(&amp;status);
 228  * int32_t bitmask = uspoof_check2(sc, str, -1, checkResult, &amp;status);
 229  *
</pre>
<hr />
<pre>
 250  * UnicodeSet allowed;
 251  * allowed.addAll(*uspoof_getRecommendedUnicodeSet(&amp;status));
 252  * allowed.addAll(*uspoof_getInclusionUnicodeSet(&amp;status));
 253  *
 254  * LocalUSpoofCheckerPointer sc(uspoof_open(&amp;status));
 255  * uspoof_setAllowedChars(sc.getAlias(), allowed.toUSet(), &amp;status);
 256  * uspoof_setRestrictionLevel(sc.getAlias(), USPOOF_MODERATELY_RESTRICTIVE);
 257  *
 258  * LocalUSpoofCheckResultPointer checkResult(uspoof_openCheckResult(&amp;status));
 259  * int32_t bitmask = uspoof_check2UnicodeString(sc.getAlias(), str, checkResult.getAlias(), &amp;status);
 260  *
 261  * int32_t failures1 = bitmask;
 262  * int32_t failures2 = uspoof_getCheckResultChecks(checkResult.getAlias(), &amp;status);
 263  * assert(failures1 == failures2);
 264  * // checks that failed: 0x00000010 (status: U_ZERO_ERROR)
 265  * printf(&quot;checks that failed: %#010x (status: %s)\n&quot;, failures1, u_errorName(status));
 266  *
 267  * // Explicit cleanup not necessary.
 268  * \endcode
 269  *

 270  * The return value is a bitmask of the checks that failed. In this case, there was one check that failed:
 271  * {@link USPOOF_RESTRICTION_LEVEL}, corresponding to the fifth bit (16). The possible checks are:
 272  *
 273  * &lt;ul&gt;
 274  * &lt;li&gt;&lt;code&gt;RESTRICTION_LEVEL&lt;/code&gt;: flags strings that violate the
 275  * &lt;a href=&quot;http://unicode.org/reports/tr39/#Restriction_Level_Detection&quot;&gt;Restriction Level&lt;/a&gt; test as specified in UTS
 276  * 39; in most cases, this means flagging strings that contain characters from multiple different scripts.&lt;/li&gt;
 277  * &lt;li&gt;&lt;code&gt;INVISIBLE&lt;/code&gt;: flags strings that contain invisible characters, such as zero-width spaces, or character
 278  * sequences that are likely not to display, such as multiple occurrences of the same non-spacing mark.&lt;/li&gt;
 279  * &lt;li&gt;&lt;code&gt;CHAR_LIMIT&lt;/code&gt;: flags strings that contain characters outside of a specified set of acceptable
 280  * characters. See {@link uspoof_setAllowedChars} and {@link uspoof_setAllowedLocales}.&lt;/li&gt;
 281  * &lt;li&gt;&lt;code&gt;MIXED_NUMBERS&lt;/code&gt;: flags strings that contain digits from multiple different numbering systems.&lt;/li&gt;
 282  * &lt;/ul&gt;
 283  *
 284  * &lt;p&gt;
 285  * These checks can be enabled independently of each other. For example, if you were interested in checking for only the
 286  * INVISIBLE and MIXED_NUMBERS conditions, you could do:
 287  *
 288  * \code{.c}
 289  * UErrorCode status = U_ZERO_ERROR;

 302  * Here is an example in C++ showing how to compute the restriction level of a string:
 303  *
 304  * \code{.cpp}
 305  * UErrorCode status = U_ZERO_ERROR;
 306  * UnicodeString str((UChar*) u&quot;p\u0430ypal&quot;);  // with U+0430 CYRILLIC SMALL LETTER A
 307  *
 308  * // Get the default set of allowable characters:
 309  * UnicodeSet allowed;
 310  * allowed.addAll(*uspoof_getRecommendedUnicodeSet(&amp;status));
 311  * allowed.addAll(*uspoof_getInclusionUnicodeSet(&amp;status));
 312  *
 313  * LocalUSpoofCheckerPointer sc(uspoof_open(&amp;status));
 314  * uspoof_setAllowedChars(sc.getAlias(), allowed.toUSet(), &amp;status);
 315  * uspoof_setRestrictionLevel(sc.getAlias(), USPOOF_MODERATELY_RESTRICTIVE);
 316  * uspoof_setChecks(sc.getAlias(), USPOOF_RESTRICTION_LEVEL | USPOOF_AUX_INFO, &amp;status);
 317  *
 318  * LocalUSpoofCheckResultPointer checkResult(uspoof_openCheckResult(&amp;status));
 319  * int32_t bitmask = uspoof_check2UnicodeString(sc.getAlias(), str, checkResult.getAlias(), &amp;status);
 320  *
 321  * URestrictionLevel restrictionLevel = uspoof_getCheckResultRestrictionLevel(checkResult.getAlias(), &amp;status);

 328  * The code &#39;0x50000000&#39; corresponds to the restriction level USPOOF_MINIMALLY_RESTRICTIVE.  Since
 329  * USPOOF_MINIMALLY_RESTRICTIVE is weaker than USPOOF_MODERATELY_RESTRICTIVE, the string fails the check.
 330  *

 331  * &lt;b&gt;Note:&lt;/b&gt; The Restriction Level is the most powerful of the checks. The full logic is documented in
 332  * &lt;a href=&quot;http://unicode.org/reports/tr39/#Restriction_Level_Detection&quot;&gt;UTS 39&lt;/a&gt;, but the basic idea is that strings
 333  * are restricted to contain characters from only a single script, &lt;em&gt;except&lt;/em&gt; that most scripts are allowed to have
 334  * Latin characters interspersed. Although the default restriction level is &lt;code&gt;HIGHLY_RESTRICTIVE&lt;/code&gt;, it is
 335  * recommended that users set their restriction level to &lt;code&gt;MODERATELY_RESTRICTIVE&lt;/code&gt;, which allows Latin mixed
 336  * with all other scripts except Cyrillic, Greek, and Cherokee, with which it is often confusable. For more details on
 337  * the levels, see UTS 39 or {@link URestrictionLevel}. The Restriction Level test is aware of the set of
 338  * allowed characters set in {@link uspoof_setAllowedChars}. Note that characters which have script code
 339  * COMMON or INHERITED, such as numbers and punctuation, are ignored when computing whether a string has multiple
 340  * scripts.
 341  *
 342  * &lt;h2&gt;Additional Information&lt;/h2&gt;
 343  *

 344  * A &lt;code&gt;USpoofChecker&lt;/code&gt; instance may be used repeatedly to perform checks on any number of identifiers.
 345  *

 346  * &lt;b&gt;Thread Safety:&lt;/b&gt; The test functions for checking a single identifier, or for testing whether
 347  * two identifiers are possible confusable, are thread safe. They may called concurrently, from multiple threads,
 348  * using the same USpoofChecker instance.
 349  *

 350  * More generally, the standard ICU thread safety rules apply: functions that take a const USpoofChecker parameter are
 351  * thread safe. Those that take a non-const USpoofChecker are not thread safe..
 352  *
 353  * @stable ICU 4.6
 354  */
 355 
 356 struct USpoofChecker;
 357 /**
 358  * @stable ICU 4.2
 359  */
 360 typedef struct USpoofChecker USpoofChecker; /**&lt; typedef for C of USpoofChecker */
 361 
 362 struct USpoofCheckResult;
 363 /**
 364  * @see uspoof_openCheckResult
 365  * @stable ICU 58
 366  */
 367 typedef struct USpoofCheckResult USpoofCheckResult;
 368 
 369 /**
</pre>
<hr />
<pre>
1188  */
1189 U_STABLE USpoofCheckResult* U_EXPORT2
1190 uspoof_openCheckResult(UErrorCode *status);
1191 
1192 /**
1193  * Close a USpoofCheckResult, freeing any memory that was being held by
1194  *   its implementation.
1195  *
1196  * @param checkResult  The instance of USpoofCheckResult to close
1197  * @stable ICU 58
1198  */
1199 U_STABLE void U_EXPORT2
1200 uspoof_closeCheckResult(USpoofCheckResult *checkResult);
1201 
1202 #if U_SHOW_CPLUSPLUS_API
1203 
1204 U_NAMESPACE_BEGIN
1205 
1206 /**
1207  * \class LocalUSpoofCheckResultPointer
<span class="line-modified">1208  * &quot;Smart pointer&quot; class, closes a USpoofCheckResult via `uspoof_closeCheckResult()`.</span>
1209  * For most methods see the LocalPointerBase base class.
1210  *
1211  * @see LocalPointerBase
1212  * @see LocalPointer
1213  * @stable ICU 58
1214  */
<span class="line-added">1215 </span>
<span class="line-added">1216 /**</span>
<span class="line-added">1217  * \cond</span>
<span class="line-added">1218  * Note: Doxygen is giving a bogus warning on this U_DEFINE_LOCAL_OPEN_POINTER.</span>
<span class="line-added">1219  *       For now, suppress with a Doxygen cond</span>
<span class="line-added">1220  */</span>
1221 U_DEFINE_LOCAL_OPEN_POINTER(LocalUSpoofCheckResultPointer, USpoofCheckResult, uspoof_closeCheckResult);
<span class="line-added">1222 /** \endcond */</span>
1223 
1224 U_NAMESPACE_END
1225 
1226 #endif
1227 
1228 /**
1229  * Indicates which of the spoof check(s) have failed. The value is a bitwise OR of the constants for the tests
1230  * in question: USPOOF_RESTRICTION_LEVEL, USPOOF_CHAR_LIMIT, and so on.
1231  *
1232  * @param checkResult  The instance of USpoofCheckResult created by {@link uspoof_openCheckResult}
1233  * @param status       The error code, set if an error occurred.
1234  * @return        An integer value with bits set for any potential security
1235  *                or spoofing issues detected.  The bits are defined by
1236  *                enum USpoofChecks.  (returned_value &amp; USPOOF_ALL_CHECKS)
1237  *                will be zero if the input string passes all of the
1238  *                enabled checks.
1239  * @see uspoof_setChecks
1240  * @stable ICU 58
1241  */
1242 U_STABLE int32_t U_EXPORT2
</pre>
</td>
</tr>
</table>
<center><a href="usearch.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../upluralrules.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>