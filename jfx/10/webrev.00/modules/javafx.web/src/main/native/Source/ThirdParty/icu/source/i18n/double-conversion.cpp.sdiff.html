<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/double-conversion.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="double-conversion-utils.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/double-conversion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17 //     * Neither the name of Google Inc. nor the names of its
  18 //       contributors may be used to endorse or promote products derived
  19 //       from this software without specific prior written permission.
  20 //
  21 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  22 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  23 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  24 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  25 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  26 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  27 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  28 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  29 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  30 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  31 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32 
  33 // ICU PATCH: ifdef around UCONFIG_NO_FORMATTING
  34 #include &quot;unicode/utypes.h&quot;
  35 #if !UCONFIG_NO_FORMATTING
  36 
<span class="line-modified">  37 #include &lt;limits.h&gt;</span>
<span class="line-modified">  38 #include &lt;math.h&gt;</span>



  39 
  40 // ICU PATCH: Customize header file paths for ICU.
  41 // The file fixed-dtoa.h is not needed.
  42 
  43 #include &quot;double-conversion.h&quot;
  44 
  45 #include &quot;double-conversion-bignum-dtoa.h&quot;
  46 #include &quot;double-conversion-fast-dtoa.h&quot;
  47 #include &quot;double-conversion-ieee.h&quot;
  48 #include &quot;double-conversion-strtod.h&quot;
  49 #include &quot;double-conversion-utils.h&quot;
  50 
  51 // ICU PATCH: Wrap in ICU namespace
  52 U_NAMESPACE_BEGIN
  53 
  54 namespace double_conversion {
  55 
  56 #if 0  // not needed for ICU
  57 const DoubleToStringConverter&amp; DoubleToStringConverter::EcmaScriptConverter() {
  58   int flags = UNIQUE_ZERO | EMIT_POSITIVE_EXPONENT_SIGN;
</pre>
<hr />
<pre>
 415       fast_worked = FastFixedDtoa(v, requested_digits, vector, length, point);
 416       break;
 417     case PRECISION:
 418       fast_worked = FastDtoa(v, FAST_DTOA_PRECISION, requested_digits,
 419                              vector, length, point);
 420       break;
 421 #endif // not needed for ICU
 422     default:
 423       fast_worked = false;
 424       UNREACHABLE();
 425   }
 426   if (fast_worked) return;
 427 
 428   // If the fast dtoa didn&#39;t succeed use the slower bignum version.
 429   BignumDtoaMode bignum_mode = DtoaToBignumDtoaMode(mode);
 430   BignumDtoa(v, bignum_mode, requested_digits, vector, length, point);
 431   vector[*length] = &#39;\0&#39;;
 432 }
 433 
 434 

































 435 // Consumes the given substring from the iterator.
 436 // Returns false, if the substring does not match.
 437 template &lt;class Iterator&gt;
 438 static bool ConsumeSubString(Iterator* current,
 439                              Iterator end,
<span class="line-modified"> 440                              const char* substring) {</span>
<span class="line-modified"> 441   ASSERT(**current == *substring);</span>
<span class="line-modified"> 442   for (substring++; *substring != &#39;\0&#39;; substring++) {</span>
<span class="line-modified"> 443     ++*current;</span>
<span class="line-modified"> 444     if (*current == end || **current != *substring) return false;</span>

 445   }
<span class="line-removed"> 446   ++*current;</span>
<span class="line-removed"> 447   return true;</span>
 448 }
 449 







 450 
 451 // Maximum number of significant digits in decimal representation.
 452 // The longest possible double in decimal representation is
 453 // (2^53 - 1) * 2 ^ -1074 that is (2 ^ 53 - 1) * 5 ^ 1074 / 10 ^ 1074
 454 // (768 digits). If we parse a number whose first digits are equal to a
 455 // mean of 2 adjacent doubles (that could have up to 769 digits) the result
 456 // must be rounded to the bigger one unless the tail consists of zeros, so
 457 // we don&#39;t need to preserve all the digits.
 458 const int kMaxSignificantDigits = 772;
 459 
 460 
 461 static const char kWhitespaceTable7[] = { 32, 13, 10, 9, 11, 12 };
 462 static const int kWhitespaceTable7Length = ARRAY_SIZE(kWhitespaceTable7);
 463 
 464 
 465 static const uc16 kWhitespaceTable16[] = {
 466   160, 8232, 8233, 5760, 6158, 8192, 8193, 8194, 8195,
 467   8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279
 468 };
 469 static const int kWhitespaceTable16Length = ARRAY_SIZE(kWhitespaceTable16);
</pre>
<hr />
<pre>
 496 
 497 
 498 static bool isDigit(int x, int radix) {
 499   return (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39; &amp;&amp; x &lt; &#39;0&#39; + radix)
 500       || (radix &gt; 10 &amp;&amp; x &gt;= &#39;a&#39; &amp;&amp; x &lt; &#39;a&#39; + radix - 10)
 501       || (radix &gt; 10 &amp;&amp; x &gt;= &#39;A&#39; &amp;&amp; x &lt; &#39;A&#39; + radix - 10);
 502 }
 503 
 504 
 505 static double SignedZero(bool sign) {
 506   return sign ? -0.0 : 0.0;
 507 }
 508 
 509 
 510 // Returns true if &#39;c&#39; is a decimal digit that is valid for the given radix.
 511 //
 512 // The function is small and could be inlined, but VS2012 emitted a warning
 513 // because it constant-propagated the radix and concluded that the last
 514 // condition was always true. By moving it into a separate function the
 515 // compiler wouldn&#39;t warn anymore.
<span class="line-modified"> 516 #if _MSC_VER</span>
 517 #pragma optimize(&quot;&quot;,off)
 518 static bool IsDecimalDigitForRadix(int c, int radix) {
 519   return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;
 520 }
 521 #pragma optimize(&quot;&quot;,on)
 522 #else
 523 static bool inline IsDecimalDigitForRadix(int c, int radix) {
<span class="line-modified"> 524     return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;</span>
 525 }
 526 #endif
 527 // Returns true if &#39;c&#39; is a character digit that is valid for the given radix.
 528 // The &#39;a_character&#39; should be &#39;a&#39; or &#39;A&#39;.
 529 //
 530 // The function is small and could be inlined, but VS2012 emitted a warning
 531 // because it constant-propagated the radix and concluded that the first
 532 // condition was always false. By moving it into a separate function the
 533 // compiler wouldn&#39;t warn anymore.
 534 static bool IsCharacterDigitForRadix(int c, int radix, char a_character) {
 535   return radix &gt; 10 &amp;&amp; c &gt;= a_character &amp;&amp; c &lt; a_character + radix - 10;
 536 }
 537 






























































 538 
 539 // Parsing integers with radix 2, 4, 8, 16, 32. Assumes current != end.



 540 template &lt;int radix_log_2, class Iterator&gt;
 541 static double RadixStringToIeee(Iterator* current,
 542                                 Iterator end,
 543                                 bool sign,


 544                                 bool allow_trailing_junk,
 545                                 double junk_string_value,
 546                                 bool read_as_double,
 547                                 bool* result_is_junk) {
 548   ASSERT(*current != end);


 549 
 550   const int kDoubleSize = Double::kSignificandSize;
 551   const int kSingleSize = Single::kSignificandSize;
 552   const int kSignificandSize = read_as_double? kDoubleSize: kSingleSize;
 553 
 554   *result_is_junk = true;
 555 







 556   // Skip leading 0s.
 557   while (**current == &#39;0&#39;) {
<span class="line-modified"> 558     ++(*current);</span>
<span class="line-removed"> 559     if (*current == end) {</span>
 560       *result_is_junk = false;
 561       return SignedZero(sign);
 562     }
 563   }
 564 
<span class="line-modified"> 565   int64_t number = 0;</span>
<span class="line-removed"> 566   int exponent = 0;</span>
<span class="line-removed"> 567   const int radix = (1 &lt;&lt; radix_log_2);</span>
<span class="line-removed"> 568 </span>
<span class="line-removed"> 569   do {</span>
 570     int digit;
 571     if (IsDecimalDigitForRadix(**current, radix)) {
 572       digit = static_cast&lt;char&gt;(**current) - &#39;0&#39;;

 573     } else if (IsCharacterDigitForRadix(**current, radix, &#39;a&#39;)) {
 574       digit = static_cast&lt;char&gt;(**current) - &#39;a&#39; + 10;

 575     } else if (IsCharacterDigitForRadix(**current, radix, &#39;A&#39;)) {
 576       digit = static_cast&lt;char&gt;(**current) - &#39;A&#39; + 10;








 577     } else {
 578       if (allow_trailing_junk || !AdvanceToNonspace(current, end)) {
 579         break;
 580       } else {
 581         return junk_string_value;
 582       }
 583     }
 584 
 585     number = number * radix + digit;
 586     int overflow = static_cast&lt;int&gt;(number &gt;&gt; kSignificandSize);
 587     if (overflow != 0) {
 588       // Overflow occurred. Need to determine which direction to round the
 589       // result.
 590       int overflow_bits_count = 1;
 591       while (overflow &gt; 1) {
 592         overflow_bits_count++;
 593         overflow &gt;&gt;= 1;
 594       }
 595 
 596       int dropped_bits_mask = ((1 &lt;&lt; overflow_bits_count) - 1);
 597       int dropped_bits = static_cast&lt;int&gt;(number) &amp; dropped_bits_mask;
 598       number &gt;&gt;= overflow_bits_count;
<span class="line-modified"> 599       exponent = overflow_bits_count;</span>
 600 
 601       bool zero_tail = true;
 602       for (;;) {
<span class="line-modified"> 603         ++(*current);</span>
<span class="line-modified"> 604         if (*current == end || !isDigit(**current, radix)) break;</span>







 605         zero_tail = zero_tail &amp;&amp; **current == &#39;0&#39;;
<span class="line-modified"> 606         exponent += radix_log_2;</span>
 607       }
 608 
<span class="line-modified"> 609       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(current, end)) {</span>


 610         return junk_string_value;
 611       }
 612 
 613       int middle_value = (1 &lt;&lt; (overflow_bits_count - 1));
 614       if (dropped_bits &gt; middle_value) {
 615         number++;  // Rounding up.
 616       } else if (dropped_bits == middle_value) {
 617         // Rounding to even to consistency with decimals: half-way case rounds
 618         // up if significant part is odd and down otherwise.
 619         if ((number &amp; 1) != 0 || !zero_tail) {
 620           number++;  // Rounding up.
 621         }
 622       }
 623 
 624       // Rounding up may cause overflow.
 625       if ((number &amp; ((int64_t)1 &lt;&lt; kSignificandSize)) != 0) {
 626         exponent++;
 627         number &gt;&gt;= 1;
 628       }
 629       break;
 630     }
<span class="line-modified"> 631     ++(*current);</span>
<span class="line-modified"> 632   } while (*current != end);</span>
 633 
 634   ASSERT(number &lt; ((int64_t)1 &lt;&lt; kSignificandSize));
 635   ASSERT(static_cast&lt;int64_t&gt;(static_cast&lt;double&gt;(number)) == number);
 636 
 637   *result_is_junk = false;
 638 
<span class="line-modified"> 639   if (exponent == 0) {</span>






















 640     if (sign) {
 641       if (number == 0) return -0.0;
 642       number = -number;
 643     }
 644     return static_cast&lt;double&gt;(number);
 645   }
 646 
 647   ASSERT(number != 0);
<span class="line-modified"> 648   return Double(DiyFp(number, exponent)).value();</span>

 649 }
 650 
 651 template &lt;class Iterator&gt;
 652 double StringToDoubleConverter::StringToIeee(
 653     Iterator input,
 654     int length,
 655     bool read_as_double,
 656     int* processed_characters_count) const {
 657   Iterator current = input;
 658   Iterator end = input + length;
 659 
 660   *processed_characters_count = 0;
 661 
 662   const bool allow_trailing_junk = (flags_ &amp; ALLOW_TRAILING_JUNK) != 0;
 663   const bool allow_leading_spaces = (flags_ &amp; ALLOW_LEADING_SPACES) != 0;
 664   const bool allow_trailing_spaces = (flags_ &amp; ALLOW_TRAILING_SPACES) != 0;
 665   const bool allow_spaces_after_sign = (flags_ &amp; ALLOW_SPACES_AFTER_SIGN) != 0;

 666 
 667   // To make sure that iterator dereferencing is valid the following
 668   // convention is used:
 669   // 1. Each &#39;++current&#39; statement is followed by check for equality to &#39;end&#39;.
 670   // 2. If AdvanceToNonspace returned false then current == end.
 671   // 3. If &#39;current&#39; becomes equal to &#39;end&#39; the function returns or goes to
 672   // &#39;parsing_done&#39;.
 673   // 4. &#39;current&#39; is not dereferenced after the &#39;parsing_done&#39; label.
 674   // 5. Code before &#39;parsing_done&#39; may rely on &#39;current != end&#39;.
 675   if (current == end) return empty_string_value_;
 676 
 677   if (allow_leading_spaces || allow_trailing_spaces) {
 678     if (!AdvanceToNonspace(&amp;current, end)) {
 679       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 680       return empty_string_value_;
 681     }
 682     if (!allow_leading_spaces &amp;&amp; (input != current)) {
 683       // No leading spaces allowed, but AdvanceToNonspace moved forward.
 684       return junk_string_value_;
 685     }
</pre>
<hr />
<pre>
 695   int exponent = 0;
 696   int significant_digits = 0;
 697   int insignificant_digits = 0;
 698   bool nonzero_digit_dropped = false;
 699 
 700   bool sign = false;
 701 
 702   if (*current == &#39;+&#39; || *current == &#39;-&#39;) {
 703     sign = (*current == &#39;-&#39;);
 704     ++current;
 705     Iterator next_non_space = current;
 706     // Skip following spaces (if allowed).
 707     if (!AdvanceToNonspace(&amp;next_non_space, end)) return junk_string_value_;
 708     if (!allow_spaces_after_sign &amp;&amp; (current != next_non_space)) {
 709       return junk_string_value_;
 710     }
 711     current = next_non_space;
 712   }
 713 
 714   if (infinity_symbol_ != NULL) {
<span class="line-modified"> 715     if (*current == infinity_symbol_[0]) {</span>
<span class="line-modified"> 716       if (!ConsumeSubString(&amp;current, end, infinity_symbol_)) {</span>
 717         return junk_string_value_;
 718       }
 719 
 720       if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
 721         return junk_string_value_;
 722       }
 723       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
 724         return junk_string_value_;
 725       }
 726 
 727       ASSERT(buffer_pos == 0);
 728       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 729       return sign ? -Double::Infinity() : Double::Infinity();
 730     }
 731   }
 732 
 733   if (nan_symbol_ != NULL) {
<span class="line-modified"> 734     if (*current == nan_symbol_[0]) {</span>
<span class="line-modified"> 735       if (!ConsumeSubString(&amp;current, end, nan_symbol_)) {</span>
 736         return junk_string_value_;
 737       }
 738 
 739       if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
 740         return junk_string_value_;
 741       }
 742       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
 743         return junk_string_value_;
 744       }
 745 
 746       ASSERT(buffer_pos == 0);
 747       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 748       return sign ? -Double::NaN() : Double::NaN();
 749     }
 750   }
 751 
 752   bool leading_zero = false;
 753   if (*current == &#39;0&#39;) {
<span class="line-modified"> 754     ++current;</span>
<span class="line-removed"> 755     if (current == end) {</span>
 756       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 757       return SignedZero(sign);
 758     }
 759 
 760     leading_zero = true;
 761 
 762     // It could be hexadecimal value.
<span class="line-modified"> 763     if ((flags_ &amp; ALLOW_HEX) &amp;&amp; (*current == &#39;x&#39; || *current == &#39;X&#39;)) {</span>

 764       ++current;
<span class="line-modified"> 765       if (current == end || !isDigit(*current, 16)) {</span>
<span class="line-modified"> 766         return junk_string_value_;  // &quot;0x&quot;.</span>





 767       }
 768 
 769       bool result_is_junk;
 770       double result = RadixStringToIeee&lt;4&gt;(&amp;current,
 771                                            end,
 772                                            sign,


 773                                            allow_trailing_junk,
 774                                            junk_string_value_,
 775                                            read_as_double,
 776                                            &amp;result_is_junk);
 777       if (!result_is_junk) {
 778         if (allow_trailing_spaces) AdvanceToNonspace(&amp;current, end);
 779         *processed_characters_count = static_cast&lt;int&gt;(current - input);
 780       }
 781       return result;
 782     }
 783 
 784     // Ignore leading zeros in the integer part.
 785     while (*current == &#39;0&#39;) {
<span class="line-modified"> 786       ++current;</span>
<span class="line-removed"> 787       if (current == end) {</span>
 788         *processed_characters_count = static_cast&lt;int&gt;(current - input);
 789         return SignedZero(sign);
 790       }
 791     }
 792   }
 793 
 794   bool octal = leading_zero &amp;&amp; (flags_ &amp; ALLOW_OCTALS) != 0;
 795 
 796   // Copy significant digits of the integer part (if any) to the buffer.
 797   while (*current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;) {
 798     if (significant_digits &lt; kMaxSignificantDigits) {
 799       ASSERT(buffer_pos &lt; kBufferSize);
 800       buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);
 801       significant_digits++;
 802       // Will later check if it&#39;s an octal in the buffer.
 803     } else {
 804       insignificant_digits++;  // Move the digit into the exponential part.
 805       nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;
 806     }
 807     octal = octal &amp;&amp; *current &lt; &#39;8&#39;;
<span class="line-modified"> 808     ++current;</span>
<span class="line-removed"> 809     if (current == end) goto parsing_done;</span>
 810   }
 811 
 812   if (significant_digits == 0) {
 813     octal = false;
 814   }
 815 
 816   if (*current == &#39;.&#39;) {
 817     if (octal &amp;&amp; !allow_trailing_junk) return junk_string_value_;
 818     if (octal) goto parsing_done;
 819 
<span class="line-modified"> 820     ++current;</span>
<span class="line-removed"> 821     if (current == end) {</span>
 822       if (significant_digits == 0 &amp;&amp; !leading_zero) {
 823         return junk_string_value_;
 824       } else {
 825         goto parsing_done;
 826       }
 827     }
 828 
 829     if (significant_digits == 0) {
 830       // octal = false;
 831       // Integer part consists of 0 or is absent. Significant digits start after
 832       // leading zeros (if any).
 833       while (*current == &#39;0&#39;) {
<span class="line-modified"> 834         ++current;</span>
<span class="line-removed"> 835         if (current == end) {</span>
 836           *processed_characters_count = static_cast&lt;int&gt;(current - input);
 837           return SignedZero(sign);
 838         }
 839         exponent--;  // Move this 0 into the exponent.
 840       }
 841     }
 842 
 843     // There is a fractional part.
 844     // We don&#39;t emit a &#39;.&#39;, but adjust the exponent instead.
 845     while (*current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;) {
 846       if (significant_digits &lt; kMaxSignificantDigits) {
 847         ASSERT(buffer_pos &lt; kBufferSize);
 848         buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);
 849         significant_digits++;
 850         exponent--;
 851       } else {
 852         // Ignore insignificant digits in the fractional part.
 853         nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;
 854       }
<span class="line-modified"> 855       ++current;</span>
<span class="line-removed"> 856       if (current == end) goto parsing_done;</span>
 857     }
 858   }
 859 
 860   if (!leading_zero &amp;&amp; exponent == 0 &amp;&amp; significant_digits == 0) {
 861     // If leading_zeros is true then the string contains zeros.
 862     // If exponent &lt; 0 then string was [+-]\.0*...
 863     // If significant_digits != 0 the string is not equal to 0.
 864     // Otherwise there are no digits in the string.
 865     return junk_string_value_;
 866   }
 867 
 868   // Parse exponential part.
 869   if (*current == &#39;e&#39; || *current == &#39;E&#39;) {
 870     if (octal &amp;&amp; !allow_trailing_junk) return junk_string_value_;
 871     if (octal) goto parsing_done;

 872     ++current;
 873     if (current == end) {
 874       if (allow_trailing_junk) {

 875         goto parsing_done;
 876       } else {
 877         return junk_string_value_;
 878       }
 879     }
 880     char exponen_sign = &#39;+&#39;;
 881     if (*current == &#39;+&#39; || *current == &#39;-&#39;) {
 882       exponen_sign = static_cast&lt;char&gt;(*current);
 883       ++current;
 884       if (current == end) {
 885         if (allow_trailing_junk) {

 886           goto parsing_done;
 887         } else {
 888           return junk_string_value_;
 889         }
 890       }
 891     }
 892 
 893     if (current == end || *current &lt; &#39;0&#39; || *current &gt; &#39;9&#39;) {
 894       if (allow_trailing_junk) {

 895         goto parsing_done;
 896       } else {
 897         return junk_string_value_;
 898       }
 899     }
 900 
 901     const int max_exponent = INT_MAX / 2;
 902     ASSERT(-max_exponent / 2 &lt;= exponent &amp;&amp; exponent &lt;= max_exponent / 2);
 903     int num = 0;
 904     do {
 905       // Check overflow.
 906       int digit = *current - &#39;0&#39;;
 907       if (num &gt;= max_exponent / 10
 908           &amp;&amp; !(num == max_exponent / 10 &amp;&amp; digit &lt;= max_exponent % 10)) {
 909         num = max_exponent;
 910       } else {
 911         num = num * 10 + digit;
 912       }
 913       ++current;
 914     } while (current != end &amp;&amp; *current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;);
</pre>
<hr />
<pre>
 919   if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
 920     return junk_string_value_;
 921   }
 922   if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
 923     return junk_string_value_;
 924   }
 925   if (allow_trailing_spaces) {
 926     AdvanceToNonspace(&amp;current, end);
 927   }
 928 
 929   parsing_done:
 930   exponent += insignificant_digits;
 931 
 932   if (octal) {
 933     double result;
 934     bool result_is_junk;
 935     char* start = buffer;
 936     result = RadixStringToIeee&lt;3&gt;(&amp;start,
 937                                   buffer + buffer_pos,
 938                                   sign,


 939                                   allow_trailing_junk,
 940                                   junk_string_value_,
 941                                   read_as_double,
 942                                   &amp;result_is_junk);
 943     ASSERT(!result_is_junk);
 944     *processed_characters_count = static_cast&lt;int&gt;(current - input);
 945     return result;
 946   }
 947 
 948   if (nonzero_digit_dropped) {
 949     buffer[buffer_pos++] = &#39;1&#39;;
 950     exponent--;
 951   }
 952 
 953   ASSERT(buffer_pos &lt; kBufferSize);
 954   buffer[buffer_pos] = &#39;\0&#39;;
 955 
 956   double converted;
 957   if (read_as_double) {
 958     converted = Strtod(Vector&lt;const char&gt;(buffer, buffer_pos), exponent);
</pre>
</td>
<td>
<hr />
<pre>
  17 //     * Neither the name of Google Inc. nor the names of its
  18 //       contributors may be used to endorse or promote products derived
  19 //       from this software without specific prior written permission.
  20 //
  21 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  22 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  23 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  24 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  25 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  26 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  27 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  28 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  29 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  30 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  31 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32 
  33 // ICU PATCH: ifdef around UCONFIG_NO_FORMATTING
  34 #include &quot;unicode/utypes.h&quot;
  35 #if !UCONFIG_NO_FORMATTING
  36 
<span class="line-modified">  37 // ICU PATCH: Do not include std::locale.</span>
<span class="line-modified">  38 </span>
<span class="line-added">  39 #include &lt;climits&gt;</span>
<span class="line-added">  40 //#include &lt;locale&gt;</span>
<span class="line-added">  41 #include &lt;cmath&gt;</span>
  42 
  43 // ICU PATCH: Customize header file paths for ICU.
  44 // The file fixed-dtoa.h is not needed.
  45 
  46 #include &quot;double-conversion.h&quot;
  47 
  48 #include &quot;double-conversion-bignum-dtoa.h&quot;
  49 #include &quot;double-conversion-fast-dtoa.h&quot;
  50 #include &quot;double-conversion-ieee.h&quot;
  51 #include &quot;double-conversion-strtod.h&quot;
  52 #include &quot;double-conversion-utils.h&quot;
  53 
  54 // ICU PATCH: Wrap in ICU namespace
  55 U_NAMESPACE_BEGIN
  56 
  57 namespace double_conversion {
  58 
  59 #if 0  // not needed for ICU
  60 const DoubleToStringConverter&amp; DoubleToStringConverter::EcmaScriptConverter() {
  61   int flags = UNIQUE_ZERO | EMIT_POSITIVE_EXPONENT_SIGN;
</pre>
<hr />
<pre>
 418       fast_worked = FastFixedDtoa(v, requested_digits, vector, length, point);
 419       break;
 420     case PRECISION:
 421       fast_worked = FastDtoa(v, FAST_DTOA_PRECISION, requested_digits,
 422                              vector, length, point);
 423       break;
 424 #endif // not needed for ICU
 425     default:
 426       fast_worked = false;
 427       UNREACHABLE();
 428   }
 429   if (fast_worked) return;
 430 
 431   // If the fast dtoa didn&#39;t succeed use the slower bignum version.
 432   BignumDtoaMode bignum_mode = DtoaToBignumDtoaMode(mode);
 433   BignumDtoa(v, bignum_mode, requested_digits, vector, length, point);
 434   vector[*length] = &#39;\0&#39;;
 435 }
 436 
 437 
<span class="line-added"> 438 namespace {</span>
<span class="line-added"> 439 </span>
<span class="line-added"> 440 inline char ToLower(char ch) {</span>
<span class="line-added"> 441 #if 0  // do not include std::locale in ICU</span>
<span class="line-added"> 442   static const std::ctype&lt;char&gt;&amp; cType =</span>
<span class="line-added"> 443       std::use_facet&lt;std::ctype&lt;char&gt; &gt;(std::locale::classic());</span>
<span class="line-added"> 444   return cType.tolower(ch);</span>
<span class="line-added"> 445 #else</span>
<span class="line-added"> 446   (void)ch;</span>
<span class="line-added"> 447   UNREACHABLE();</span>
<span class="line-added"> 448 #endif</span>
<span class="line-added"> 449 }</span>
<span class="line-added"> 450 </span>
<span class="line-added"> 451 inline char Pass(char ch) {</span>
<span class="line-added"> 452   return ch;</span>
<span class="line-added"> 453 }</span>
<span class="line-added"> 454 </span>
<span class="line-added"> 455 template &lt;class Iterator, class Converter&gt;</span>
<span class="line-added"> 456 static inline bool ConsumeSubStringImpl(Iterator* current,</span>
<span class="line-added"> 457                                         Iterator end,</span>
<span class="line-added"> 458                                         const char* substring,</span>
<span class="line-added"> 459                                         Converter converter) {</span>
<span class="line-added"> 460   ASSERT(converter(**current) == *substring);</span>
<span class="line-added"> 461   for (substring++; *substring != &#39;\0&#39;; substring++) {</span>
<span class="line-added"> 462     ++*current;</span>
<span class="line-added"> 463     if (*current == end || converter(**current) != *substring) {</span>
<span class="line-added"> 464       return false;</span>
<span class="line-added"> 465     }</span>
<span class="line-added"> 466   }</span>
<span class="line-added"> 467   ++*current;</span>
<span class="line-added"> 468   return true;</span>
<span class="line-added"> 469 }</span>
<span class="line-added"> 470 </span>
 471 // Consumes the given substring from the iterator.
 472 // Returns false, if the substring does not match.
 473 template &lt;class Iterator&gt;
 474 static bool ConsumeSubString(Iterator* current,
 475                              Iterator end,
<span class="line-modified"> 476                              const char* substring,</span>
<span class="line-modified"> 477                              bool allow_case_insensibility) {</span>
<span class="line-modified"> 478   if (allow_case_insensibility) {</span>
<span class="line-modified"> 479     return ConsumeSubStringImpl(current, end, substring, ToLower);</span>
<span class="line-modified"> 480   } else {</span>
<span class="line-added"> 481     return ConsumeSubStringImpl(current, end, substring, Pass);</span>
 482   }


 483 }
 484 
<span class="line-added"> 485 // Consumes first character of the str is equal to ch</span>
<span class="line-added"> 486 inline bool ConsumeFirstCharacter(char ch,</span>
<span class="line-added"> 487                                          const char* str,</span>
<span class="line-added"> 488                                          bool case_insensibility) {</span>
<span class="line-added"> 489   return case_insensibility ? ToLower(ch) == str[0] : ch == str[0];</span>
<span class="line-added"> 490 }</span>
<span class="line-added"> 491 }  // namespace</span>
 492 
 493 // Maximum number of significant digits in decimal representation.
 494 // The longest possible double in decimal representation is
 495 // (2^53 - 1) * 2 ^ -1074 that is (2 ^ 53 - 1) * 5 ^ 1074 / 10 ^ 1074
 496 // (768 digits). If we parse a number whose first digits are equal to a
 497 // mean of 2 adjacent doubles (that could have up to 769 digits) the result
 498 // must be rounded to the bigger one unless the tail consists of zeros, so
 499 // we don&#39;t need to preserve all the digits.
 500 const int kMaxSignificantDigits = 772;
 501 
 502 
 503 static const char kWhitespaceTable7[] = { 32, 13, 10, 9, 11, 12 };
 504 static const int kWhitespaceTable7Length = ARRAY_SIZE(kWhitespaceTable7);
 505 
 506 
 507 static const uc16 kWhitespaceTable16[] = {
 508   160, 8232, 8233, 5760, 6158, 8192, 8193, 8194, 8195,
 509   8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279
 510 };
 511 static const int kWhitespaceTable16Length = ARRAY_SIZE(kWhitespaceTable16);
</pre>
<hr />
<pre>
 538 
 539 
 540 static bool isDigit(int x, int radix) {
 541   return (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39; &amp;&amp; x &lt; &#39;0&#39; + radix)
 542       || (radix &gt; 10 &amp;&amp; x &gt;= &#39;a&#39; &amp;&amp; x &lt; &#39;a&#39; + radix - 10)
 543       || (radix &gt; 10 &amp;&amp; x &gt;= &#39;A&#39; &amp;&amp; x &lt; &#39;A&#39; + radix - 10);
 544 }
 545 
 546 
 547 static double SignedZero(bool sign) {
 548   return sign ? -0.0 : 0.0;
 549 }
 550 
 551 
 552 // Returns true if &#39;c&#39; is a decimal digit that is valid for the given radix.
 553 //
 554 // The function is small and could be inlined, but VS2012 emitted a warning
 555 // because it constant-propagated the radix and concluded that the last
 556 // condition was always true. By moving it into a separate function the
 557 // compiler wouldn&#39;t warn anymore.
<span class="line-modified"> 558 #ifdef _MSC_VER</span>
 559 #pragma optimize(&quot;&quot;,off)
 560 static bool IsDecimalDigitForRadix(int c, int radix) {
 561   return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;
 562 }
 563 #pragma optimize(&quot;&quot;,on)
 564 #else
 565 static bool inline IsDecimalDigitForRadix(int c, int radix) {
<span class="line-modified"> 566   return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;</span>
 567 }
 568 #endif
 569 // Returns true if &#39;c&#39; is a character digit that is valid for the given radix.
 570 // The &#39;a_character&#39; should be &#39;a&#39; or &#39;A&#39;.
 571 //
 572 // The function is small and could be inlined, but VS2012 emitted a warning
 573 // because it constant-propagated the radix and concluded that the first
 574 // condition was always false. By moving it into a separate function the
 575 // compiler wouldn&#39;t warn anymore.
 576 static bool IsCharacterDigitForRadix(int c, int radix, char a_character) {
 577   return radix &gt; 10 &amp;&amp; c &gt;= a_character &amp;&amp; c &lt; a_character + radix - 10;
 578 }
 579 
<span class="line-added"> 580 // Returns true, when the iterator is equal to end.</span>
<span class="line-added"> 581 template&lt;class Iterator&gt;</span>
<span class="line-added"> 582 static bool Advance (Iterator* it, uc16 separator, int base, Iterator&amp; end) {</span>
<span class="line-added"> 583   if (separator == StringToDoubleConverter::kNoSeparator) {</span>
<span class="line-added"> 584     ++(*it);</span>
<span class="line-added"> 585     return *it == end;</span>
<span class="line-added"> 586   }</span>
<span class="line-added"> 587   if (!isDigit(**it, base)) {</span>
<span class="line-added"> 588     ++(*it);</span>
<span class="line-added"> 589     return *it == end;</span>
<span class="line-added"> 590   }</span>
<span class="line-added"> 591   ++(*it);</span>
<span class="line-added"> 592   if (*it == end) return true;</span>
<span class="line-added"> 593   if (*it + 1 == end) return false;</span>
<span class="line-added"> 594   if (**it == separator &amp;&amp; isDigit(*(*it + 1), base)) {</span>
<span class="line-added"> 595     ++(*it);</span>
<span class="line-added"> 596   }</span>
<span class="line-added"> 597   return *it == end;</span>
<span class="line-added"> 598 }</span>
<span class="line-added"> 599 </span>
<span class="line-added"> 600 // Checks whether the string in the range start-end is a hex-float string.</span>
<span class="line-added"> 601 // This function assumes that the leading &#39;0x&#39;/&#39;0X&#39; is already consumed.</span>
<span class="line-added"> 602 //</span>
<span class="line-added"> 603 // Hex float strings are of one of the following forms:</span>
<span class="line-added"> 604 //   - hex_digits+ &#39;p&#39; (&#39;+&#39;|&#39;-&#39;)? exponent_digits+</span>
<span class="line-added"> 605 //   - hex_digits* &#39;.&#39; hex_digits+ &#39;p&#39; (&#39;+&#39;|&#39;-&#39;)? exponent_digits+</span>
<span class="line-added"> 606 //   - hex_digits+ &#39;.&#39; &#39;p&#39; (&#39;+&#39;|&#39;-&#39;)? exponent_digits+</span>
<span class="line-added"> 607 template&lt;class Iterator&gt;</span>
<span class="line-added"> 608 static bool IsHexFloatString(Iterator start,</span>
<span class="line-added"> 609                              Iterator end,</span>
<span class="line-added"> 610                              uc16 separator,</span>
<span class="line-added"> 611                              bool allow_trailing_junk) {</span>
<span class="line-added"> 612   ASSERT(start != end);</span>
<span class="line-added"> 613 </span>
<span class="line-added"> 614   Iterator current = start;</span>
<span class="line-added"> 615 </span>
<span class="line-added"> 616   bool saw_digit = false;</span>
<span class="line-added"> 617   while (isDigit(*current, 16)) {</span>
<span class="line-added"> 618     saw_digit = true;</span>
<span class="line-added"> 619     if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="line-added"> 620   }</span>
<span class="line-added"> 621   if (*current == &#39;.&#39;) {</span>
<span class="line-added"> 622     if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="line-added"> 623     while (isDigit(*current, 16)) {</span>
<span class="line-added"> 624       saw_digit = true;</span>
<span class="line-added"> 625       if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="line-added"> 626     }</span>
<span class="line-added"> 627     if (!saw_digit) return false;  // Only the &#39;.&#39;, but no digits.</span>
<span class="line-added"> 628   }</span>
<span class="line-added"> 629   if (*current != &#39;p&#39; &amp;&amp; *current != &#39;P&#39;) return false;</span>
<span class="line-added"> 630   if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="line-added"> 631   if (*current == &#39;+&#39; || *current == &#39;-&#39;) {</span>
<span class="line-added"> 632     if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="line-added"> 633   }</span>
<span class="line-added"> 634   if (!isDigit(*current, 10)) return false;</span>
<span class="line-added"> 635   if (Advance(&amp;current, separator, 16, end)) return true;</span>
<span class="line-added"> 636   while (isDigit(*current, 10)) {</span>
<span class="line-added"> 637     if (Advance(&amp;current, separator, 16, end)) return true;</span>
<span class="line-added"> 638   }</span>
<span class="line-added"> 639   return allow_trailing_junk || !AdvanceToNonspace(&amp;current, end);</span>
<span class="line-added"> 640 }</span>
<span class="line-added"> 641 </span>
 642 
 643 // Parsing integers with radix 2, 4, 8, 16, 32. Assumes current != end.
<span class="line-added"> 644 //</span>
<span class="line-added"> 645 // If parse_as_hex_float is true, then the string must be a valid</span>
<span class="line-added"> 646 // hex-float.</span>
 647 template &lt;int radix_log_2, class Iterator&gt;
 648 static double RadixStringToIeee(Iterator* current,
 649                                 Iterator end,
 650                                 bool sign,
<span class="line-added"> 651                                 uc16 separator,</span>
<span class="line-added"> 652                                 bool parse_as_hex_float,</span>
 653                                 bool allow_trailing_junk,
 654                                 double junk_string_value,
 655                                 bool read_as_double,
 656                                 bool* result_is_junk) {
 657   ASSERT(*current != end);
<span class="line-added"> 658   ASSERT(!parse_as_hex_float ||</span>
<span class="line-added"> 659       IsHexFloatString(*current, end, separator, allow_trailing_junk));</span>
 660 
 661   const int kDoubleSize = Double::kSignificandSize;
 662   const int kSingleSize = Single::kSignificandSize;
 663   const int kSignificandSize = read_as_double? kDoubleSize: kSingleSize;
 664 
 665   *result_is_junk = true;
 666 
<span class="line-added"> 667   int64_t number = 0;</span>
<span class="line-added"> 668   int exponent = 0;</span>
<span class="line-added"> 669   const int radix = (1 &lt;&lt; radix_log_2);</span>
<span class="line-added"> 670   // Whether we have encountered a &#39;.&#39; and are parsing the decimal digits.</span>
<span class="line-added"> 671   // Only relevant if parse_as_hex_float is true.</span>
<span class="line-added"> 672   bool post_decimal = false;</span>
<span class="line-added"> 673 </span>
 674   // Skip leading 0s.
 675   while (**current == &#39;0&#39;) {
<span class="line-modified"> 676     if (Advance(current, separator, radix, end)) {</span>

 677       *result_is_junk = false;
 678       return SignedZero(sign);
 679     }
 680   }
 681 
<span class="line-modified"> 682   while (true) {</span>




 683     int digit;
 684     if (IsDecimalDigitForRadix(**current, radix)) {
 685       digit = static_cast&lt;char&gt;(**current) - &#39;0&#39;;
<span class="line-added"> 686       if (post_decimal) exponent -= radix_log_2;</span>
 687     } else if (IsCharacterDigitForRadix(**current, radix, &#39;a&#39;)) {
 688       digit = static_cast&lt;char&gt;(**current) - &#39;a&#39; + 10;
<span class="line-added"> 689       if (post_decimal) exponent -= radix_log_2;</span>
 690     } else if (IsCharacterDigitForRadix(**current, radix, &#39;A&#39;)) {
 691       digit = static_cast&lt;char&gt;(**current) - &#39;A&#39; + 10;
<span class="line-added"> 692       if (post_decimal) exponent -= radix_log_2;</span>
<span class="line-added"> 693     } else if (parse_as_hex_float &amp;&amp; **current == &#39;.&#39;) {</span>
<span class="line-added"> 694       post_decimal = true;</span>
<span class="line-added"> 695       Advance(current, separator, radix, end);</span>
<span class="line-added"> 696       ASSERT(*current != end);</span>
<span class="line-added"> 697       continue;</span>
<span class="line-added"> 698     } else if (parse_as_hex_float &amp;&amp; (**current == &#39;p&#39; || **current == &#39;P&#39;)) {</span>
<span class="line-added"> 699       break;</span>
 700     } else {
 701       if (allow_trailing_junk || !AdvanceToNonspace(current, end)) {
 702         break;
 703       } else {
 704         return junk_string_value;
 705       }
 706     }
 707 
 708     number = number * radix + digit;
 709     int overflow = static_cast&lt;int&gt;(number &gt;&gt; kSignificandSize);
 710     if (overflow != 0) {
 711       // Overflow occurred. Need to determine which direction to round the
 712       // result.
 713       int overflow_bits_count = 1;
 714       while (overflow &gt; 1) {
 715         overflow_bits_count++;
 716         overflow &gt;&gt;= 1;
 717       }
 718 
 719       int dropped_bits_mask = ((1 &lt;&lt; overflow_bits_count) - 1);
 720       int dropped_bits = static_cast&lt;int&gt;(number) &amp; dropped_bits_mask;
 721       number &gt;&gt;= overflow_bits_count;
<span class="line-modified"> 722       exponent += overflow_bits_count;</span>
 723 
 724       bool zero_tail = true;
 725       for (;;) {
<span class="line-modified"> 726         if (Advance(current, separator, radix, end)) break;</span>
<span class="line-modified"> 727         if (parse_as_hex_float &amp;&amp; **current == &#39;.&#39;) {</span>
<span class="line-added"> 728           // Just run over the &#39;.&#39;. We are just trying to see whether there is</span>
<span class="line-added"> 729           // a non-zero digit somewhere.</span>
<span class="line-added"> 730           Advance(current, separator, radix, end);</span>
<span class="line-added"> 731           ASSERT(*current != end);</span>
<span class="line-added"> 732           post_decimal = true;</span>
<span class="line-added"> 733         }</span>
<span class="line-added"> 734         if (!isDigit(**current, radix)) break;</span>
 735         zero_tail = zero_tail &amp;&amp; **current == &#39;0&#39;;
<span class="line-modified"> 736         if (!post_decimal) exponent += radix_log_2;</span>
 737       }
 738 
<span class="line-modified"> 739       if (!parse_as_hex_float &amp;&amp;</span>
<span class="line-added"> 740           !allow_trailing_junk &amp;&amp;</span>
<span class="line-added"> 741           AdvanceToNonspace(current, end)) {</span>
 742         return junk_string_value;
 743       }
 744 
 745       int middle_value = (1 &lt;&lt; (overflow_bits_count - 1));
 746       if (dropped_bits &gt; middle_value) {
 747         number++;  // Rounding up.
 748       } else if (dropped_bits == middle_value) {
 749         // Rounding to even to consistency with decimals: half-way case rounds
 750         // up if significant part is odd and down otherwise.
 751         if ((number &amp; 1) != 0 || !zero_tail) {
 752           number++;  // Rounding up.
 753         }
 754       }
 755 
 756       // Rounding up may cause overflow.
 757       if ((number &amp; ((int64_t)1 &lt;&lt; kSignificandSize)) != 0) {
 758         exponent++;
 759         number &gt;&gt;= 1;
 760       }
 761       break;
 762     }
<span class="line-modified"> 763     if (Advance(current, separator, radix, end)) break;</span>
<span class="line-modified"> 764   }</span>
 765 
 766   ASSERT(number &lt; ((int64_t)1 &lt;&lt; kSignificandSize));
 767   ASSERT(static_cast&lt;int64_t&gt;(static_cast&lt;double&gt;(number)) == number);
 768 
 769   *result_is_junk = false;
 770 
<span class="line-modified"> 771   if (parse_as_hex_float) {</span>
<span class="line-added"> 772     ASSERT(**current == &#39;p&#39; || **current == &#39;P&#39;);</span>
<span class="line-added"> 773     Advance(current, separator, radix, end);</span>
<span class="line-added"> 774     ASSERT(*current != end);</span>
<span class="line-added"> 775     bool is_negative = false;</span>
<span class="line-added"> 776     if (**current == &#39;+&#39;) {</span>
<span class="line-added"> 777       Advance(current, separator, radix, end);</span>
<span class="line-added"> 778       ASSERT(*current != end);</span>
<span class="line-added"> 779     } else if (**current == &#39;-&#39;) {</span>
<span class="line-added"> 780       is_negative = true;</span>
<span class="line-added"> 781       Advance(current, separator, radix, end);</span>
<span class="line-added"> 782       ASSERT(*current != end);</span>
<span class="line-added"> 783     }</span>
<span class="line-added"> 784     int written_exponent = 0;</span>
<span class="line-added"> 785     while (IsDecimalDigitForRadix(**current, 10)) {</span>
<span class="line-added"> 786       written_exponent = 10 * written_exponent + **current - &#39;0&#39;;</span>
<span class="line-added"> 787       if (Advance(current, separator, radix, end)) break;</span>
<span class="line-added"> 788     }</span>
<span class="line-added"> 789     if (is_negative) written_exponent = -written_exponent;</span>
<span class="line-added"> 790     exponent += written_exponent;</span>
<span class="line-added"> 791   }</span>
<span class="line-added"> 792 </span>
<span class="line-added"> 793   if (exponent == 0 || number == 0) {</span>
 794     if (sign) {
 795       if (number == 0) return -0.0;
 796       number = -number;
 797     }
 798     return static_cast&lt;double&gt;(number);
 799   }
 800 
 801   ASSERT(number != 0);
<span class="line-modified"> 802   double result = Double(DiyFp(number, exponent)).value();</span>
<span class="line-added"> 803   return sign ? -result : result;</span>
 804 }
 805 
 806 template &lt;class Iterator&gt;
 807 double StringToDoubleConverter::StringToIeee(
 808     Iterator input,
 809     int length,
 810     bool read_as_double,
 811     int* processed_characters_count) const {
 812   Iterator current = input;
 813   Iterator end = input + length;
 814 
 815   *processed_characters_count = 0;
 816 
 817   const bool allow_trailing_junk = (flags_ &amp; ALLOW_TRAILING_JUNK) != 0;
 818   const bool allow_leading_spaces = (flags_ &amp; ALLOW_LEADING_SPACES) != 0;
 819   const bool allow_trailing_spaces = (flags_ &amp; ALLOW_TRAILING_SPACES) != 0;
 820   const bool allow_spaces_after_sign = (flags_ &amp; ALLOW_SPACES_AFTER_SIGN) != 0;
<span class="line-added"> 821   const bool allow_case_insensibility = (flags_ &amp; ALLOW_CASE_INSENSIBILITY) != 0;</span>
 822 
 823   // To make sure that iterator dereferencing is valid the following
 824   // convention is used:
 825   // 1. Each &#39;++current&#39; statement is followed by check for equality to &#39;end&#39;.
 826   // 2. If AdvanceToNonspace returned false then current == end.
 827   // 3. If &#39;current&#39; becomes equal to &#39;end&#39; the function returns or goes to
 828   // &#39;parsing_done&#39;.
 829   // 4. &#39;current&#39; is not dereferenced after the &#39;parsing_done&#39; label.
 830   // 5. Code before &#39;parsing_done&#39; may rely on &#39;current != end&#39;.
 831   if (current == end) return empty_string_value_;
 832 
 833   if (allow_leading_spaces || allow_trailing_spaces) {
 834     if (!AdvanceToNonspace(&amp;current, end)) {
 835       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 836       return empty_string_value_;
 837     }
 838     if (!allow_leading_spaces &amp;&amp; (input != current)) {
 839       // No leading spaces allowed, but AdvanceToNonspace moved forward.
 840       return junk_string_value_;
 841     }
</pre>
<hr />
<pre>
 851   int exponent = 0;
 852   int significant_digits = 0;
 853   int insignificant_digits = 0;
 854   bool nonzero_digit_dropped = false;
 855 
 856   bool sign = false;
 857 
 858   if (*current == &#39;+&#39; || *current == &#39;-&#39;) {
 859     sign = (*current == &#39;-&#39;);
 860     ++current;
 861     Iterator next_non_space = current;
 862     // Skip following spaces (if allowed).
 863     if (!AdvanceToNonspace(&amp;next_non_space, end)) return junk_string_value_;
 864     if (!allow_spaces_after_sign &amp;&amp; (current != next_non_space)) {
 865       return junk_string_value_;
 866     }
 867     current = next_non_space;
 868   }
 869 
 870   if (infinity_symbol_ != NULL) {
<span class="line-modified"> 871     if (ConsumeFirstCharacter(*current, infinity_symbol_, allow_case_insensibility)) {</span>
<span class="line-modified"> 872       if (!ConsumeSubString(&amp;current, end, infinity_symbol_, allow_case_insensibility)) {</span>
 873         return junk_string_value_;
 874       }
 875 
 876       if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
 877         return junk_string_value_;
 878       }
 879       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
 880         return junk_string_value_;
 881       }
 882 
 883       ASSERT(buffer_pos == 0);
 884       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 885       return sign ? -Double::Infinity() : Double::Infinity();
 886     }
 887   }
 888 
 889   if (nan_symbol_ != NULL) {
<span class="line-modified"> 890     if (ConsumeFirstCharacter(*current, nan_symbol_, allow_case_insensibility)) {</span>
<span class="line-modified"> 891       if (!ConsumeSubString(&amp;current, end, nan_symbol_, allow_case_insensibility)) {</span>
 892         return junk_string_value_;
 893       }
 894 
 895       if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
 896         return junk_string_value_;
 897       }
 898       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
 899         return junk_string_value_;
 900       }
 901 
 902       ASSERT(buffer_pos == 0);
 903       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 904       return sign ? -Double::NaN() : Double::NaN();
 905     }
 906   }
 907 
 908   bool leading_zero = false;
 909   if (*current == &#39;0&#39;) {
<span class="line-modified"> 910     if (Advance(&amp;current, separator_, 10, end)) {</span>

 911       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 912       return SignedZero(sign);
 913     }
 914 
 915     leading_zero = true;
 916 
 917     // It could be hexadecimal value.
<span class="line-modified"> 918     if (((flags_ &amp; ALLOW_HEX) || (flags_ &amp; ALLOW_HEX_FLOATS)) &amp;&amp;</span>
<span class="line-added"> 919         (*current == &#39;x&#39; || *current == &#39;X&#39;)) {</span>
 920       ++current;
<span class="line-modified"> 921 </span>
<span class="line-modified"> 922       bool parse_as_hex_float = (flags_ &amp; ALLOW_HEX_FLOATS) &amp;&amp;</span>
<span class="line-added"> 923                 IsHexFloatString(current, end, separator_, allow_trailing_junk);</span>
<span class="line-added"> 924 </span>
<span class="line-added"> 925       if (current == end) return junk_string_value_;  // &quot;0x&quot;</span>
<span class="line-added"> 926       if (!parse_as_hex_float &amp;&amp; !isDigit(*current, 16)) {</span>
<span class="line-added"> 927         return junk_string_value_;</span>
 928       }
 929 
 930       bool result_is_junk;
 931       double result = RadixStringToIeee&lt;4&gt;(&amp;current,
 932                                            end,
 933                                            sign,
<span class="line-added"> 934                                            separator_,</span>
<span class="line-added"> 935                                            parse_as_hex_float,</span>
 936                                            allow_trailing_junk,
 937                                            junk_string_value_,
 938                                            read_as_double,
 939                                            &amp;result_is_junk);
 940       if (!result_is_junk) {
 941         if (allow_trailing_spaces) AdvanceToNonspace(&amp;current, end);
 942         *processed_characters_count = static_cast&lt;int&gt;(current - input);
 943       }
 944       return result;
 945     }
 946 
 947     // Ignore leading zeros in the integer part.
 948     while (*current == &#39;0&#39;) {
<span class="line-modified"> 949       if (Advance(&amp;current, separator_, 10, end)) {</span>

 950         *processed_characters_count = static_cast&lt;int&gt;(current - input);
 951         return SignedZero(sign);
 952       }
 953     }
 954   }
 955 
 956   bool octal = leading_zero &amp;&amp; (flags_ &amp; ALLOW_OCTALS) != 0;
 957 
 958   // Copy significant digits of the integer part (if any) to the buffer.
 959   while (*current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;) {
 960     if (significant_digits &lt; kMaxSignificantDigits) {
 961       ASSERT(buffer_pos &lt; kBufferSize);
 962       buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);
 963       significant_digits++;
 964       // Will later check if it&#39;s an octal in the buffer.
 965     } else {
 966       insignificant_digits++;  // Move the digit into the exponential part.
 967       nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;
 968     }
 969     octal = octal &amp;&amp; *current &lt; &#39;8&#39;;
<span class="line-modified"> 970     if (Advance(&amp;current, separator_, 10, end)) goto parsing_done;</span>

 971   }
 972 
 973   if (significant_digits == 0) {
 974     octal = false;
 975   }
 976 
 977   if (*current == &#39;.&#39;) {
 978     if (octal &amp;&amp; !allow_trailing_junk) return junk_string_value_;
 979     if (octal) goto parsing_done;
 980 
<span class="line-modified"> 981     if (Advance(&amp;current, separator_, 10, end)) {</span>

 982       if (significant_digits == 0 &amp;&amp; !leading_zero) {
 983         return junk_string_value_;
 984       } else {
 985         goto parsing_done;
 986       }
 987     }
 988 
 989     if (significant_digits == 0) {
 990       // octal = false;
 991       // Integer part consists of 0 or is absent. Significant digits start after
 992       // leading zeros (if any).
 993       while (*current == &#39;0&#39;) {
<span class="line-modified"> 994         if (Advance(&amp;current, separator_, 10, end)) {</span>

 995           *processed_characters_count = static_cast&lt;int&gt;(current - input);
 996           return SignedZero(sign);
 997         }
 998         exponent--;  // Move this 0 into the exponent.
 999       }
1000     }
1001 
1002     // There is a fractional part.
1003     // We don&#39;t emit a &#39;.&#39;, but adjust the exponent instead.
1004     while (*current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;) {
1005       if (significant_digits &lt; kMaxSignificantDigits) {
1006         ASSERT(buffer_pos &lt; kBufferSize);
1007         buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);
1008         significant_digits++;
1009         exponent--;
1010       } else {
1011         // Ignore insignificant digits in the fractional part.
1012         nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;
1013       }
<span class="line-modified">1014       if (Advance(&amp;current, separator_, 10, end)) goto parsing_done;</span>

1015     }
1016   }
1017 
1018   if (!leading_zero &amp;&amp; exponent == 0 &amp;&amp; significant_digits == 0) {
1019     // If leading_zeros is true then the string contains zeros.
1020     // If exponent &lt; 0 then string was [+-]\.0*...
1021     // If significant_digits != 0 the string is not equal to 0.
1022     // Otherwise there are no digits in the string.
1023     return junk_string_value_;
1024   }
1025 
1026   // Parse exponential part.
1027   if (*current == &#39;e&#39; || *current == &#39;E&#39;) {
1028     if (octal &amp;&amp; !allow_trailing_junk) return junk_string_value_;
1029     if (octal) goto parsing_done;
<span class="line-added">1030     Iterator junk_begin = current;</span>
1031     ++current;
1032     if (current == end) {
1033       if (allow_trailing_junk) {
<span class="line-added">1034         current = junk_begin;</span>
1035         goto parsing_done;
1036       } else {
1037         return junk_string_value_;
1038       }
1039     }
1040     char exponen_sign = &#39;+&#39;;
1041     if (*current == &#39;+&#39; || *current == &#39;-&#39;) {
1042       exponen_sign = static_cast&lt;char&gt;(*current);
1043       ++current;
1044       if (current == end) {
1045         if (allow_trailing_junk) {
<span class="line-added">1046           current = junk_begin;</span>
1047           goto parsing_done;
1048         } else {
1049           return junk_string_value_;
1050         }
1051       }
1052     }
1053 
1054     if (current == end || *current &lt; &#39;0&#39; || *current &gt; &#39;9&#39;) {
1055       if (allow_trailing_junk) {
<span class="line-added">1056         current = junk_begin;</span>
1057         goto parsing_done;
1058       } else {
1059         return junk_string_value_;
1060       }
1061     }
1062 
1063     const int max_exponent = INT_MAX / 2;
1064     ASSERT(-max_exponent / 2 &lt;= exponent &amp;&amp; exponent &lt;= max_exponent / 2);
1065     int num = 0;
1066     do {
1067       // Check overflow.
1068       int digit = *current - &#39;0&#39;;
1069       if (num &gt;= max_exponent / 10
1070           &amp;&amp; !(num == max_exponent / 10 &amp;&amp; digit &lt;= max_exponent % 10)) {
1071         num = max_exponent;
1072       } else {
1073         num = num * 10 + digit;
1074       }
1075       ++current;
1076     } while (current != end &amp;&amp; *current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;);
</pre>
<hr />
<pre>
1081   if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
1082     return junk_string_value_;
1083   }
1084   if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
1085     return junk_string_value_;
1086   }
1087   if (allow_trailing_spaces) {
1088     AdvanceToNonspace(&amp;current, end);
1089   }
1090 
1091   parsing_done:
1092   exponent += insignificant_digits;
1093 
1094   if (octal) {
1095     double result;
1096     bool result_is_junk;
1097     char* start = buffer;
1098     result = RadixStringToIeee&lt;3&gt;(&amp;start,
1099                                   buffer + buffer_pos,
1100                                   sign,
<span class="line-added">1101                                   separator_,</span>
<span class="line-added">1102                                   false, // Don&#39;t parse as hex_float.</span>
1103                                   allow_trailing_junk,
1104                                   junk_string_value_,
1105                                   read_as_double,
1106                                   &amp;result_is_junk);
1107     ASSERT(!result_is_junk);
1108     *processed_characters_count = static_cast&lt;int&gt;(current - input);
1109     return result;
1110   }
1111 
1112   if (nonzero_digit_dropped) {
1113     buffer[buffer_pos++] = &#39;1&#39;;
1114     exponent--;
1115   }
1116 
1117   ASSERT(buffer_pos &lt; kBufferSize);
1118   buffer[buffer_pos] = &#39;\0&#39;;
1119 
1120   double converted;
1121   if (read_as_double) {
1122     converted = Strtod(Vector&lt;const char&gt;(buffer, buffer_pos), exponent);
</pre>
</td>
</tr>
</table>
<center><a href="double-conversion-utils.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>