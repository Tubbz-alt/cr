<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tzgnames.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 2011-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 *******************************************************************************
   8 */
   9 
  10 #include &quot;unicode/utypes.h&quot;
  11 
  12 #if !UCONFIG_NO_FORMATTING
  13 
  14 #include &quot;tzgnames.h&quot;
  15 
  16 #include &quot;unicode/basictz.h&quot;
  17 #include &quot;unicode/locdspnm.h&quot;
  18 #include &quot;unicode/rbtz.h&quot;
  19 #include &quot;unicode/simpleformatter.h&quot;
  20 #include &quot;unicode/simpletz.h&quot;
  21 #include &quot;unicode/strenum.h&quot;
  22 #include &quot;unicode/vtzone.h&quot;
  23 
  24 #include &quot;cmemory.h&quot;
  25 #include &quot;cstring.h&quot;
  26 #include &quot;mutex.h&quot;
  27 #include &quot;uhash.h&quot;
  28 #include &quot;uassert.h&quot;
  29 #include &quot;umutex.h&quot;
  30 #include &quot;uresimp.h&quot;
  31 #include &quot;ureslocs.h&quot;
  32 #include &quot;zonemeta.h&quot;
  33 #include &quot;tznames_impl.h&quot;
  34 #include &quot;olsontz.h&quot;
  35 #include &quot;ucln_in.h&quot;
  36 
  37 U_NAMESPACE_BEGIN
  38 
  39 #define ZID_KEY_MAX  128
  40 
  41 static const char gZoneStrings[]                = &quot;zoneStrings&quot;;
  42 
  43 static const char gRegionFormatTag[]            = &quot;regionFormat&quot;;
  44 static const char gFallbackFormatTag[]          = &quot;fallbackFormat&quot;;
  45 
  46 static const UChar gEmpty[]                     = {0x00};
  47 
  48 static const UChar gDefRegionPattern[]          = {0x7B, 0x30, 0x7D, 0x00}; // &quot;{0}&quot;
  49 static const UChar gDefFallbackPattern[]        = {0x7B, 0x31, 0x7D, 0x20, 0x28, 0x7B, 0x30, 0x7D, 0x29, 0x00}; // &quot;{1} ({0})&quot;
  50 
  51 static const double kDstCheckRange      = (double)184*U_MILLIS_PER_DAY;
  52 
  53 
  54 
  55 U_CDECL_BEGIN
  56 
  57 typedef struct PartialLocationKey {
  58     const UChar* tzID;
  59     const UChar* mzID;
  60     UBool isLong;
  61 } PartialLocationKey;
  62 
  63 /**
  64  * Hash function for partial location name hash key
  65  */
  66 static int32_t U_CALLCONV
  67 hashPartialLocationKey(const UHashTok key) {
  68     // &lt;tzID&gt;&amp;&lt;mzID&gt;#[L|S]
  69     PartialLocationKey *p = (PartialLocationKey *)key.pointer;
  70     UnicodeString str(p-&gt;tzID);
  71     str.append((UChar)0x26)
  72         .append(p-&gt;mzID, -1)
  73         .append((UChar)0x23)
  74         .append((UChar)(p-&gt;isLong ? 0x4C : 0x53));
  75     return str.hashCode();
  76 }
  77 
  78 /**
  79  * Comparer for partial location name hash key
  80  */
  81 static UBool U_CALLCONV
  82 comparePartialLocationKey(const UHashTok key1, const UHashTok key2) {
  83     PartialLocationKey *p1 = (PartialLocationKey *)key1.pointer;
  84     PartialLocationKey *p2 = (PartialLocationKey *)key2.pointer;
  85 
  86     if (p1 == p2) {
  87         return TRUE;
  88     }
  89     if (p1 == NULL || p2 == NULL) {
  90         return FALSE;
  91     }
  92     // We just check identity of tzID/mzID
  93     return (p1-&gt;tzID == p2-&gt;tzID &amp;&amp; p1-&gt;mzID == p2-&gt;mzID &amp;&amp; p1-&gt;isLong == p2-&gt;isLong);
  94 }
  95 
  96 /**
  97  * Deleter for GNameInfo
  98  */
  99 static void U_CALLCONV
 100 deleteGNameInfo(void *obj) {
 101     uprv_free(obj);
 102 }
 103 
 104 /**
 105  * GNameInfo stores zone name information in the local trie
 106  */
 107 typedef struct GNameInfo {
 108     UTimeZoneGenericNameType    type;
 109     const UChar*                tzID;
 110 } ZNameInfo;
 111 
 112 /**
 113  * GMatchInfo stores zone name match information used by find method
 114  */
 115 typedef struct GMatchInfo {
 116     const GNameInfo*    gnameInfo;
 117     int32_t             matchLength;
 118     UTimeZoneFormatTimeType   timeType;
 119 } ZMatchInfo;
 120 
 121 U_CDECL_END
 122 
 123 // ---------------------------------------------------
 124 // The class stores time zone generic name match information
 125 // ---------------------------------------------------
 126 class TimeZoneGenericNameMatchInfo : public UMemory {
 127 public:
 128     TimeZoneGenericNameMatchInfo(UVector* matches);
 129     ~TimeZoneGenericNameMatchInfo();
 130 
 131     int32_t size() const;
 132     UTimeZoneGenericNameType getGenericNameType(int32_t index) const;
 133     int32_t getMatchLength(int32_t index) const;
 134     UnicodeString&amp; getTimeZoneID(int32_t index, UnicodeString&amp; tzID) const;
 135 
 136 private:
 137     UVector* fMatches;  // vector of MatchEntry
 138 };
 139 
 140 TimeZoneGenericNameMatchInfo::TimeZoneGenericNameMatchInfo(UVector* matches)
 141 : fMatches(matches) {
 142 }
 143 
 144 TimeZoneGenericNameMatchInfo::~TimeZoneGenericNameMatchInfo() {
 145     if (fMatches != NULL) {
 146         delete fMatches;
 147     }
 148 }
 149 
 150 int32_t
 151 TimeZoneGenericNameMatchInfo::size() const {
 152     if (fMatches == NULL) {
 153         return 0;
 154     }
 155     return fMatches-&gt;size();
 156 }
 157 
 158 UTimeZoneGenericNameType
 159 TimeZoneGenericNameMatchInfo::getGenericNameType(int32_t index) const {
 160     GMatchInfo *minfo = (GMatchInfo *)fMatches-&gt;elementAt(index);
 161     if (minfo != NULL) {
 162         return static_cast&lt;UTimeZoneGenericNameType&gt;(minfo-&gt;gnameInfo-&gt;type);
 163     }
 164     return UTZGNM_UNKNOWN;
 165 }
 166 
 167 int32_t
 168 TimeZoneGenericNameMatchInfo::getMatchLength(int32_t index) const {
 169     ZMatchInfo *minfo = (ZMatchInfo *)fMatches-&gt;elementAt(index);
 170     if (minfo != NULL) {
 171         return minfo-&gt;matchLength;
 172     }
 173     return -1;
 174 }
 175 
 176 UnicodeString&amp;
 177 TimeZoneGenericNameMatchInfo::getTimeZoneID(int32_t index, UnicodeString&amp; tzID) const {
 178     GMatchInfo *minfo = (GMatchInfo *)fMatches-&gt;elementAt(index);
 179     if (minfo != NULL &amp;&amp; minfo-&gt;gnameInfo-&gt;tzID != NULL) {
 180         tzID.setTo(TRUE, minfo-&gt;gnameInfo-&gt;tzID, -1);
 181     } else {
 182         tzID.setToBogus();
 183     }
 184     return tzID;
 185 }
 186 
 187 // ---------------------------------------------------
 188 // GNameSearchHandler
 189 // ---------------------------------------------------
 190 class GNameSearchHandler : public TextTrieMapSearchResultHandler {
 191 public:
 192     GNameSearchHandler(uint32_t types);
 193     virtual ~GNameSearchHandler();
 194 
 195     UBool handleMatch(int32_t matchLength, const CharacterNode *node, UErrorCode &amp;status);
 196     UVector* getMatches(int32_t&amp; maxMatchLen);
 197 
 198 private:
 199     uint32_t fTypes;
 200     UVector* fResults;
 201     int32_t fMaxMatchLen;
 202 };
 203 
 204 GNameSearchHandler::GNameSearchHandler(uint32_t types)
 205 : fTypes(types), fResults(NULL), fMaxMatchLen(0) {
 206 }
 207 
 208 GNameSearchHandler::~GNameSearchHandler() {
 209     if (fResults != NULL) {
 210         delete fResults;
 211     }
 212 }
 213 
 214 UBool
 215 GNameSearchHandler::handleMatch(int32_t matchLength, const CharacterNode *node, UErrorCode &amp;status) {
 216     if (U_FAILURE(status)) {
 217         return FALSE;
 218     }
 219     if (node-&gt;hasValues()) {
 220         int32_t valuesCount = node-&gt;countValues();
 221         for (int32_t i = 0; i &lt; valuesCount; i++) {
 222             GNameInfo *nameinfo = (ZNameInfo *)node-&gt;getValue(i);
 223             if (nameinfo == NULL) {
 224                 break;
 225             }
 226             if ((nameinfo-&gt;type &amp; fTypes) != 0) {
 227                 // matches a requested type
 228                 if (fResults == NULL) {
 229                     fResults = new UVector(uprv_free, NULL, status);
 230                     if (fResults == NULL) {
 231                         status = U_MEMORY_ALLOCATION_ERROR;
 232                     }
 233                 }
 234                 if (U_SUCCESS(status)) {
 235                     U_ASSERT(fResults != NULL);
 236                     GMatchInfo *gmatch = (GMatchInfo *)uprv_malloc(sizeof(GMatchInfo));
 237                     if (gmatch == NULL) {
 238                         status = U_MEMORY_ALLOCATION_ERROR;
 239                     } else {
 240                         // add the match to the vector
 241                         gmatch-&gt;gnameInfo = nameinfo;
 242                         gmatch-&gt;matchLength = matchLength;
 243                         gmatch-&gt;timeType = UTZFMT_TIME_TYPE_UNKNOWN;
 244                         fResults-&gt;addElement(gmatch, status);
 245                         if (U_FAILURE(status)) {
 246                             uprv_free(gmatch);
 247                         } else {
 248                             if (matchLength &gt; fMaxMatchLen) {
 249                                 fMaxMatchLen = matchLength;
 250                             }
 251                         }
 252                     }
 253                 }
 254             }
 255         }
 256     }
 257     return TRUE;
 258 }
 259 
 260 UVector*
 261 GNameSearchHandler::getMatches(int32_t&amp; maxMatchLen) {
 262     // give the ownership to the caller
 263     UVector *results = fResults;
 264     maxMatchLen = fMaxMatchLen;
 265 
 266     // reset
 267     fResults = NULL;
 268     fMaxMatchLen = 0;
 269     return results;
 270 }
 271 
 272 static UMutex *gLock() {
 273     static UMutex m = U_MUTEX_INITIALIZER;
 274     return &amp;m;
 275 }
 276 
 277 class TZGNCore : public UMemory {
 278 public:
 279     TZGNCore(const Locale&amp; locale, UErrorCode&amp; status);
 280     virtual ~TZGNCore();
 281 
 282     UnicodeString&amp; getDisplayName(const TimeZone&amp; tz, UTimeZoneGenericNameType type,
 283                         UDate date, UnicodeString&amp; name) const;
 284 
 285     UnicodeString&amp; getGenericLocationName(const UnicodeString&amp; tzCanonicalID, UnicodeString&amp; name) const;
 286 
 287     int32_t findBestMatch(const UnicodeString&amp; text, int32_t start, uint32_t types,
 288         UnicodeString&amp; tzID, UTimeZoneFormatTimeType&amp; timeType, UErrorCode&amp; status) const;
 289 
 290 private:
 291     Locale fLocale;
 292     const TimeZoneNames* fTimeZoneNames;
 293     UHashtable* fLocationNamesMap;
 294     UHashtable* fPartialLocationNamesMap;
 295 
 296     SimpleFormatter fRegionFormat;
 297     SimpleFormatter fFallbackFormat;
 298 
 299     LocaleDisplayNames* fLocaleDisplayNames;
 300     ZNStringPool fStringPool;
 301 
 302     TextTrieMap fGNamesTrie;
 303     UBool fGNamesTrieFullyLoaded;
 304 
 305     char fTargetRegion[ULOC_COUNTRY_CAPACITY];
 306 
 307     void initialize(const Locale&amp; locale, UErrorCode&amp; status);
 308     void cleanup();
 309 
 310     void loadStrings(const UnicodeString&amp; tzCanonicalID);
 311 
 312     const UChar* getGenericLocationName(const UnicodeString&amp; tzCanonicalID);
 313 
 314     UnicodeString&amp; formatGenericNonLocationName(const TimeZone&amp; tz, UTimeZoneGenericNameType type,
 315                         UDate date, UnicodeString&amp; name) const;
 316 
 317     UnicodeString&amp; getPartialLocationName(const UnicodeString&amp; tzCanonicalID,
 318                         const UnicodeString&amp; mzID, UBool isLong, const UnicodeString&amp; mzDisplayName,
 319                         UnicodeString&amp; name) const;
 320 
 321     const UChar* getPartialLocationName(const UnicodeString&amp; tzCanonicalID,
 322                         const UnicodeString&amp; mzID, UBool isLong, const UnicodeString&amp; mzDisplayName);
 323 
 324     TimeZoneGenericNameMatchInfo* findLocal(const UnicodeString&amp; text, int32_t start, uint32_t types, UErrorCode&amp; status) const;
 325 
 326     TimeZoneNames::MatchInfoCollection* findTimeZoneNames(const UnicodeString&amp; text, int32_t start, uint32_t types, UErrorCode&amp; status) const;
 327 };
 328 
 329 
 330 // ---------------------------------------------------
 331 // TZGNCore - core implmentation of TimeZoneGenericNames
 332 //
 333 // TimeZoneGenericNames is parallel to TimeZoneNames,
 334 // but handles run-time generated time zone names.
 335 // This is the main part of this module.
 336 // ---------------------------------------------------
 337 TZGNCore::TZGNCore(const Locale&amp; locale, UErrorCode&amp; status)
 338 : fLocale(locale),
 339   fTimeZoneNames(NULL),
 340   fLocationNamesMap(NULL),
 341   fPartialLocationNamesMap(NULL),
 342   fLocaleDisplayNames(NULL),
 343   fStringPool(status),
 344   fGNamesTrie(TRUE, deleteGNameInfo),
 345   fGNamesTrieFullyLoaded(FALSE) {
 346     initialize(locale, status);
 347 }
 348 
 349 TZGNCore::~TZGNCore() {
 350     cleanup();
 351 }
 352 
 353 void
 354 TZGNCore::initialize(const Locale&amp; locale, UErrorCode&amp; status) {
 355     if (U_FAILURE(status)) {
 356         return;
 357     }
 358 
 359     // TimeZoneNames
 360     fTimeZoneNames = TimeZoneNames::createInstance(locale, status);
 361     if (U_FAILURE(status)) {
 362         return;
 363     }
 364 
 365     // Initialize format patterns
 366     UnicodeString rpat(TRUE, gDefRegionPattern, -1);
 367     UnicodeString fpat(TRUE, gDefFallbackPattern, -1);
 368 
 369     UErrorCode tmpsts = U_ZERO_ERROR;   // OK with fallback warning..
 370     UResourceBundle *zoneStrings = ures_open(U_ICUDATA_ZONE, locale.getName(), &amp;tmpsts);
 371     zoneStrings = ures_getByKeyWithFallback(zoneStrings, gZoneStrings, zoneStrings, &amp;tmpsts);
 372 
 373     if (U_SUCCESS(tmpsts)) {
 374         const UChar *regionPattern = ures_getStringByKeyWithFallback(zoneStrings, gRegionFormatTag, NULL, &amp;tmpsts);
 375         if (U_SUCCESS(tmpsts) &amp;&amp; u_strlen(regionPattern) &gt; 0) {
 376             rpat.setTo(regionPattern, -1);
 377         }
 378         tmpsts = U_ZERO_ERROR;
 379         const UChar *fallbackPattern = ures_getStringByKeyWithFallback(zoneStrings, gFallbackFormatTag, NULL, &amp;tmpsts);
 380         if (U_SUCCESS(tmpsts) &amp;&amp; u_strlen(fallbackPattern) &gt; 0) {
 381             fpat.setTo(fallbackPattern, -1);
 382         }
 383     }
 384     ures_close(zoneStrings);
 385 
 386     fRegionFormat.applyPatternMinMaxArguments(rpat, 1, 1, status);
 387     fFallbackFormat.applyPatternMinMaxArguments(fpat, 2, 2, status);
 388     if (U_FAILURE(status)) {
 389         cleanup();
 390         return;
 391     }
 392 
 393     // locale display names
 394     fLocaleDisplayNames = LocaleDisplayNames::createInstance(locale);
 395 
 396     // hash table for names - no key/value deleters
 397     fLocationNamesMap = uhash_open(uhash_hashUChars, uhash_compareUChars, NULL, &amp;status);
 398     if (U_FAILURE(status)) {
 399         cleanup();
 400         return;
 401     }
 402 
 403     fPartialLocationNamesMap = uhash_open(hashPartialLocationKey, comparePartialLocationKey, NULL, &amp;status);
 404     if (U_FAILURE(status)) {
 405         cleanup();
 406         return;
 407     }
 408     uhash_setKeyDeleter(fPartialLocationNamesMap, uprv_free);
 409     // no value deleter
 410 
 411     // target region
 412     const char* region = fLocale.getCountry();
 413     int32_t regionLen = static_cast&lt;int32_t&gt;(uprv_strlen(region));
 414     if (regionLen == 0) {
 415         char loc[ULOC_FULLNAME_CAPACITY];
 416         uloc_addLikelySubtags(fLocale.getName(), loc, sizeof(loc), &amp;status);
 417 
 418         regionLen = uloc_getCountry(loc, fTargetRegion, sizeof(fTargetRegion), &amp;status);
 419         if (U_SUCCESS(status)) {
 420             fTargetRegion[regionLen] = 0;
 421         } else {
 422             cleanup();
 423             return;
 424         }
 425     } else if (regionLen &lt; (int32_t)sizeof(fTargetRegion)) {
 426         uprv_strcpy(fTargetRegion, region);
 427     } else {
 428         fTargetRegion[0] = 0;
 429     }
 430 
 431     // preload generic names for the default zone
 432     TimeZone *tz = TimeZone::createDefault();
 433     const UChar *tzID = ZoneMeta::getCanonicalCLDRID(*tz);
 434     if (tzID != NULL) {
 435         loadStrings(UnicodeString(TRUE, tzID, -1));
 436     }
 437     delete tz;
 438 }
 439 
 440 void
 441 TZGNCore::cleanup() {
 442     if (fLocaleDisplayNames != NULL) {
 443         delete fLocaleDisplayNames;
 444     }
 445     if (fTimeZoneNames != NULL) {
 446         delete fTimeZoneNames;
 447     }
 448 
 449     uhash_close(fLocationNamesMap);
 450     uhash_close(fPartialLocationNamesMap);
 451 }
 452 
 453 
 454 UnicodeString&amp;
 455 TZGNCore::getDisplayName(const TimeZone&amp; tz, UTimeZoneGenericNameType type, UDate date, UnicodeString&amp; name) const {
 456     name.setToBogus();
 457     switch (type) {
 458     case UTZGNM_LOCATION:
 459         {
 460             const UChar* tzCanonicalID = ZoneMeta::getCanonicalCLDRID(tz);
 461             if (tzCanonicalID != NULL) {
 462                 getGenericLocationName(UnicodeString(TRUE, tzCanonicalID, -1), name);
 463             }
 464         }
 465         break;
 466     case UTZGNM_LONG:
 467     case UTZGNM_SHORT:
 468         formatGenericNonLocationName(tz, type, date, name);
 469         if (name.isEmpty()) {
 470             const UChar* tzCanonicalID = ZoneMeta::getCanonicalCLDRID(tz);
 471             if (tzCanonicalID != NULL) {
 472                 getGenericLocationName(UnicodeString(TRUE, tzCanonicalID, -1), name);
 473             }
 474         }
 475         break;
 476     default:
 477         break;
 478     }
 479     return name;
 480 }
 481 
 482 UnicodeString&amp;
 483 TZGNCore::getGenericLocationName(const UnicodeString&amp; tzCanonicalID, UnicodeString&amp; name) const {
 484     if (tzCanonicalID.isEmpty()) {
 485         name.setToBogus();
 486         return name;
 487     }
 488 
 489     const UChar *locname = NULL;
 490     TZGNCore *nonConstThis = const_cast&lt;TZGNCore *&gt;(this);
 491     umtx_lock(gLock());
 492     {
 493         locname = nonConstThis-&gt;getGenericLocationName(tzCanonicalID);
 494     }
 495     umtx_unlock(gLock());
 496 
 497     if (locname == NULL) {
 498         name.setToBogus();
 499     } else {
 500         name.setTo(locname, u_strlen(locname));
 501     }
 502 
 503     return name;
 504 }
 505 
 506 /*
 507  * This method updates the cache and must be called with a lock
 508  */
 509 const UChar*
 510 TZGNCore::getGenericLocationName(const UnicodeString&amp; tzCanonicalID) {
 511     U_ASSERT(!tzCanonicalID.isEmpty());
 512     if (tzCanonicalID.length() &gt; ZID_KEY_MAX) {
 513         return NULL;
 514     }
 515 
 516     UErrorCode status = U_ZERO_ERROR;
 517     UChar tzIDKey[ZID_KEY_MAX + 1];
 518     int32_t tzIDKeyLen = tzCanonicalID.extract(tzIDKey, ZID_KEY_MAX + 1, status);
 519     U_ASSERT(status == U_ZERO_ERROR);   // already checked length above
 520     tzIDKey[tzIDKeyLen] = 0;
 521 
 522     const UChar *locname = (const UChar *)uhash_get(fLocationNamesMap, tzIDKey);
 523 
 524     if (locname != NULL) {
 525         // gEmpty indicate the name is not available
 526         if (locname == gEmpty) {
 527             return NULL;
 528         }
 529         return locname;
 530     }
 531 
 532     // Construct location name
 533     UnicodeString name;
 534     UnicodeString usCountryCode;
 535     UBool isPrimary = FALSE;
 536 
 537     ZoneMeta::getCanonicalCountry(tzCanonicalID, usCountryCode, &amp;isPrimary);
 538 
 539     if (!usCountryCode.isEmpty()) {
 540         if (isPrimary) {
 541             // If this is the primary zone in the country, use the country name.
 542             char countryCode[ULOC_COUNTRY_CAPACITY];
 543             U_ASSERT(usCountryCode.length() &lt; ULOC_COUNTRY_CAPACITY);
 544             int32_t ccLen = usCountryCode.extract(0, usCountryCode.length(), countryCode, sizeof(countryCode), US_INV);
 545             countryCode[ccLen] = 0;
 546 
 547             UnicodeString country;
 548             fLocaleDisplayNames-&gt;regionDisplayName(countryCode, country);
 549             fRegionFormat.format(country, name, status);
 550         } else {
 551             // If this is not the primary zone in the country,
 552             // use the exemplar city name.
 553 
 554             // getExemplarLocationName should retur non-empty string
 555             // if the time zone is associated with a region
 556 
 557             UnicodeString city;
 558             fTimeZoneNames-&gt;getExemplarLocationName(tzCanonicalID, city);
 559             fRegionFormat.format(city, name, status);
 560         }
 561         if (U_FAILURE(status)) {
 562             return NULL;
 563         }
 564     }
 565 
 566     locname = name.isEmpty() ? NULL : fStringPool.get(name, status);
 567     if (U_SUCCESS(status)) {
 568         // Cache the result
 569         const UChar* cacheID = ZoneMeta::findTimeZoneID(tzCanonicalID);
 570         U_ASSERT(cacheID != NULL);
 571         if (locname == NULL) {
 572             // gEmpty to indicate - no location name available
 573             uhash_put(fLocationNamesMap, (void *)cacheID, (void *)gEmpty, &amp;status);
 574         } else {
 575             uhash_put(fLocationNamesMap, (void *)cacheID, (void *)locname, &amp;status);
 576             if (U_FAILURE(status)) {
 577                 locname = NULL;
 578             } else {
 579                 // put the name info into the trie
 580                 GNameInfo *nameinfo = (ZNameInfo *)uprv_malloc(sizeof(GNameInfo));
 581                 if (nameinfo != NULL) {
 582                     nameinfo-&gt;type = UTZGNM_LOCATION;
 583                     nameinfo-&gt;tzID = cacheID;
 584                     fGNamesTrie.put(locname, nameinfo, status);
 585                 }
 586             }
 587         }
 588     }
 589 
 590     return locname;
 591 }
 592 
 593 UnicodeString&amp;
 594 TZGNCore::formatGenericNonLocationName(const TimeZone&amp; tz, UTimeZoneGenericNameType type, UDate date, UnicodeString&amp; name) const {
 595     U_ASSERT(type == UTZGNM_LONG || type == UTZGNM_SHORT);
 596     name.setToBogus();
 597 
 598     const UChar* uID = ZoneMeta::getCanonicalCLDRID(tz);
 599     if (uID == NULL) {
 600         return name;
 601     }
 602 
 603     UnicodeString tzID(TRUE, uID, -1);
 604 
 605     // Try to get a name from time zone first
 606     UTimeZoneNameType nameType = (type == UTZGNM_LONG) ? UTZNM_LONG_GENERIC : UTZNM_SHORT_GENERIC;
 607     fTimeZoneNames-&gt;getTimeZoneDisplayName(tzID, nameType, name);
 608 
 609     if (!name.isEmpty()) {
 610         return name;
 611     }
 612 
 613     // Try meta zone
 614     UChar mzIDBuf[32];
 615     UnicodeString mzID(mzIDBuf, 0, UPRV_LENGTHOF(mzIDBuf));
 616     fTimeZoneNames-&gt;getMetaZoneID(tzID, date, mzID);
 617     if (!mzID.isEmpty()) {
 618         UErrorCode status = U_ZERO_ERROR;
 619         UBool useStandard = FALSE;
 620         int32_t raw, sav;
 621         UChar tmpNameBuf[ZONE_NAME_U16_MAX];
 622 
 623         tz.getOffset(date, FALSE, raw, sav, status);
 624         if (U_FAILURE(status)) {
 625             return name;
 626         }
 627 
 628         if (sav == 0) {
 629             useStandard = TRUE;
 630 
 631             TimeZone *tmptz = tz.clone();
 632             // Check if the zone actually uses daylight saving time around the time
 633             BasicTimeZone *btz = NULL;
 634             if (dynamic_cast&lt;OlsonTimeZone *&gt;(tmptz) != NULL
 635                 || dynamic_cast&lt;SimpleTimeZone *&gt;(tmptz) != NULL
 636                 || dynamic_cast&lt;RuleBasedTimeZone *&gt;(tmptz) != NULL
 637                 || dynamic_cast&lt;VTimeZone *&gt;(tmptz) != NULL) {
 638                 btz = (BasicTimeZone*)tmptz;
 639             }
 640 
 641             if (btz != NULL) {
 642                 TimeZoneTransition before;
 643                 UBool beforTrs = btz-&gt;getPreviousTransition(date, TRUE, before);
 644                 if (beforTrs
 645                         &amp;&amp; (date - before.getTime() &lt; kDstCheckRange)
 646                         &amp;&amp; before.getFrom()-&gt;getDSTSavings() != 0) {
 647                     useStandard = FALSE;
 648                 } else {
 649                     TimeZoneTransition after;
 650                     UBool afterTrs = btz-&gt;getNextTransition(date, FALSE, after);
 651                     if (afterTrs
 652                             &amp;&amp; (after.getTime() - date &lt; kDstCheckRange)
 653                             &amp;&amp; after.getTo()-&gt;getDSTSavings() != 0) {
 654                         useStandard = FALSE;
 655                     }
 656                 }
 657             } else {
 658                 // If not BasicTimeZone... only if the instance is not an ICU&#39;s implementation.
 659                 // We may get a wrong answer in edge case, but it should practically work OK.
 660                 tmptz-&gt;getOffset(date - kDstCheckRange, FALSE, raw, sav, status);
 661                 if (sav != 0) {
 662                     useStandard = FALSE;
 663                 } else {
 664                     tmptz-&gt;getOffset(date + kDstCheckRange, FALSE, raw, sav, status);
 665                     if (sav != 0){
 666                         useStandard = FALSE;
 667                     }
 668                 }
 669                 if (U_FAILURE(status)) {
 670                     delete tmptz;
 671                     return name;
 672                 }
 673             }
 674             delete tmptz;
 675         }
 676         if (useStandard) {
 677             UTimeZoneNameType stdNameType = (nameType == UTZNM_LONG_GENERIC)
 678                 ? UTZNM_LONG_STANDARD : UTZNM_SHORT_STANDARD;
 679             UnicodeString stdName(tmpNameBuf, 0, UPRV_LENGTHOF(tmpNameBuf));
 680             fTimeZoneNames-&gt;getDisplayName(tzID, stdNameType, date, stdName);
 681             if (!stdName.isEmpty()) {
 682                 name.setTo(stdName);
 683 
 684                 // TODO: revisit this issue later
 685                 // In CLDR, a same display name is used for both generic and standard
 686                 // for some meta zones in some locales.  This looks like a data bugs.
 687                 // For now, we check if the standard name is different from its generic
 688                 // name below.
 689                 UChar genNameBuf[ZONE_NAME_U16_MAX];
 690                 UnicodeString mzGenericName(genNameBuf, 0, UPRV_LENGTHOF(genNameBuf));
 691                 fTimeZoneNames-&gt;getMetaZoneDisplayName(mzID, nameType, mzGenericName);
 692                 if (stdName.caseCompare(mzGenericName, 0) == 0) {
 693                     name.setToBogus();
 694                 }
 695             }
 696         }
 697         if (name.isEmpty()) {
 698             // Get a name from meta zone
 699             UnicodeString mzName(tmpNameBuf, 0, UPRV_LENGTHOF(tmpNameBuf));
 700             fTimeZoneNames-&gt;getMetaZoneDisplayName(mzID, nameType, mzName);
 701             if (!mzName.isEmpty()) {
 702                 // Check if we need to use a partial location format.
 703                 // This check is done by comparing offset with the meta zone&#39;s
 704                 // golden zone at the given date.
 705                 UChar idBuf[32];
 706                 UnicodeString goldenID(idBuf, 0, UPRV_LENGTHOF(idBuf));
 707                 fTimeZoneNames-&gt;getReferenceZoneID(mzID, fTargetRegion, goldenID);
 708                 if (!goldenID.isEmpty() &amp;&amp; goldenID != tzID) {
 709                     TimeZone *goldenZone = TimeZone::createTimeZone(goldenID);
 710                     int32_t raw1, sav1;
 711 
 712                     // Check offset in the golden zone with wall time.
 713                     // With getOffset(date, false, offsets1),
 714                     // you may get incorrect results because of time overlap at DST-&gt;STD
 715                     // transition.
 716                     goldenZone-&gt;getOffset(date + raw + sav, TRUE, raw1, sav1, status);
 717                     delete goldenZone;
 718                     if (U_SUCCESS(status)) {
 719                         if (raw != raw1 || sav != sav1) {
 720                             // Now we need to use a partial location format
 721                             getPartialLocationName(tzID, mzID, (nameType == UTZNM_LONG_GENERIC), mzName, name);
 722                         } else {
 723                             name.setTo(mzName);
 724                         }
 725                     }
 726                 } else {
 727                     name.setTo(mzName);
 728                 }
 729             }
 730         }
 731     }
 732     return name;
 733 }
 734 
 735 UnicodeString&amp;
 736 TZGNCore::getPartialLocationName(const UnicodeString&amp; tzCanonicalID,
 737                         const UnicodeString&amp; mzID, UBool isLong, const UnicodeString&amp; mzDisplayName,
 738                         UnicodeString&amp; name) const {
 739     name.setToBogus();
 740     if (tzCanonicalID.isEmpty() || mzID.isEmpty() || mzDisplayName.isEmpty()) {
 741         return name;
 742     }
 743 
 744     const UChar *uplname = NULL;
 745     TZGNCore *nonConstThis = const_cast&lt;TZGNCore *&gt;(this);
 746     umtx_lock(gLock());
 747     {
 748         uplname = nonConstThis-&gt;getPartialLocationName(tzCanonicalID, mzID, isLong, mzDisplayName);
 749     }
 750     umtx_unlock(gLock());
 751 
 752     if (uplname == NULL) {
 753         name.setToBogus();
 754     } else {
 755         name.setTo(TRUE, uplname, -1);
 756     }
 757     return name;
 758 }
 759 
 760 /*
 761  * This method updates the cache and must be called with a lock
 762  */
 763 const UChar*
 764 TZGNCore::getPartialLocationName(const UnicodeString&amp; tzCanonicalID,
 765                         const UnicodeString&amp; mzID, UBool isLong, const UnicodeString&amp; mzDisplayName) {
 766     U_ASSERT(!tzCanonicalID.isEmpty());
 767     U_ASSERT(!mzID.isEmpty());
 768     U_ASSERT(!mzDisplayName.isEmpty());
 769 
 770     PartialLocationKey key;
 771     key.tzID = ZoneMeta::findTimeZoneID(tzCanonicalID);
 772     key.mzID = ZoneMeta::findMetaZoneID(mzID);
 773     key.isLong = isLong;
 774     U_ASSERT(key.tzID != NULL &amp;&amp; key.mzID != NULL);
 775 
 776     const UChar* uplname = (const UChar*)uhash_get(fPartialLocationNamesMap, (void *)&amp;key);
 777     if (uplname != NULL) {
 778         return uplname;
 779     }
 780 
 781     UnicodeString location;
 782     UnicodeString usCountryCode;
 783     ZoneMeta::getCanonicalCountry(tzCanonicalID, usCountryCode);
 784     if (!usCountryCode.isEmpty()) {
 785         char countryCode[ULOC_COUNTRY_CAPACITY];
 786         U_ASSERT(usCountryCode.length() &lt; ULOC_COUNTRY_CAPACITY);
 787         int32_t ccLen = usCountryCode.extract(0, usCountryCode.length(), countryCode, sizeof(countryCode), US_INV);
 788         countryCode[ccLen] = 0;
 789 
 790         UnicodeString regionalGolden;
 791         fTimeZoneNames-&gt;getReferenceZoneID(mzID, countryCode, regionalGolden);
 792         if (tzCanonicalID == regionalGolden) {
 793             // Use country name
 794             fLocaleDisplayNames-&gt;regionDisplayName(countryCode, location);
 795         } else {
 796             // Otherwise, use exemplar city name
 797             fTimeZoneNames-&gt;getExemplarLocationName(tzCanonicalID, location);
 798         }
 799     } else {
 800         fTimeZoneNames-&gt;getExemplarLocationName(tzCanonicalID, location);
 801         if (location.isEmpty()) {
 802             // This could happen when the time zone is not associated with a country,
 803             // and its ID is not hierarchical, for example, CST6CDT.
 804             // We use the canonical ID itself as the location for this case.
 805             location.setTo(tzCanonicalID);
 806         }
 807     }
 808 
 809     UErrorCode status = U_ZERO_ERROR;
 810     UnicodeString name;
 811     fFallbackFormat.format(location, mzDisplayName, name, status);
 812     if (U_FAILURE(status)) {
 813         return NULL;
 814     }
 815 
 816     uplname = fStringPool.get(name, status);
 817     if (U_SUCCESS(status)) {
 818         // Add the name to cache
 819         PartialLocationKey* cacheKey = (PartialLocationKey *)uprv_malloc(sizeof(PartialLocationKey));
 820         if (cacheKey != NULL) {
 821             cacheKey-&gt;tzID = key.tzID;
 822             cacheKey-&gt;mzID = key.mzID;
 823             cacheKey-&gt;isLong = key.isLong;
 824             uhash_put(fPartialLocationNamesMap, (void *)cacheKey, (void *)uplname, &amp;status);
 825             if (U_FAILURE(status)) {
 826                 uprv_free(cacheKey);
 827             } else {
 828                 // put the name to the local trie as well
 829                 GNameInfo *nameinfo = (ZNameInfo *)uprv_malloc(sizeof(GNameInfo));
 830                 if (nameinfo != NULL) {
 831                     nameinfo-&gt;type = isLong ? UTZGNM_LONG : UTZGNM_SHORT;
 832                     nameinfo-&gt;tzID = key.tzID;
 833                     fGNamesTrie.put(uplname, nameinfo, status);
 834                 }
 835             }
 836         }
 837     }
 838     return uplname;
 839 }
 840 
 841 /*
 842  * This method updates the cache and must be called with a lock,
 843  * except initializer.
 844  */
 845 void
 846 TZGNCore::loadStrings(const UnicodeString&amp; tzCanonicalID) {
 847     // load the generic location name
 848     getGenericLocationName(tzCanonicalID);
 849 
 850     // partial location names
 851     UErrorCode status = U_ZERO_ERROR;
 852 
 853     const UnicodeString *mzID;
 854     UnicodeString goldenID;
 855     UnicodeString mzGenName;
 856     UTimeZoneNameType genNonLocTypes[] = {
 857         UTZNM_LONG_GENERIC, UTZNM_SHORT_GENERIC,
 858         UTZNM_UNKNOWN /*terminator*/
 859     };
 860 
 861     StringEnumeration *mzIDs = fTimeZoneNames-&gt;getAvailableMetaZoneIDs(tzCanonicalID, status);
 862     while ((mzID = mzIDs-&gt;snext(status)) != NULL) {
 863         if (U_FAILURE(status)) {
 864             break;
 865         }
 866         // if this time zone is not the golden zone of the meta zone,
 867         // partial location name (such as &quot;PT (Los Angeles)&quot;) might be
 868         // available.
 869         fTimeZoneNames-&gt;getReferenceZoneID(*mzID, fTargetRegion, goldenID);
 870         if (tzCanonicalID != goldenID) {
 871             for (int32_t i = 0; genNonLocTypes[i] != UTZNM_UNKNOWN; i++) {
 872                 fTimeZoneNames-&gt;getMetaZoneDisplayName(*mzID, genNonLocTypes[i], mzGenName);
 873                 if (!mzGenName.isEmpty()) {
 874                     // getPartialLocationName formats a name and put it into the trie
 875                     getPartialLocationName(tzCanonicalID, *mzID,
 876                         (genNonLocTypes[i] == UTZNM_LONG_GENERIC), mzGenName);
 877                 }
 878             }
 879         }
 880     }
 881     if (mzIDs != NULL) {
 882         delete mzIDs;
 883     }
 884 }
 885 
 886 int32_t
 887 TZGNCore::findBestMatch(const UnicodeString&amp; text, int32_t start, uint32_t types,
 888         UnicodeString&amp; tzID, UTimeZoneFormatTimeType&amp; timeType, UErrorCode&amp; status) const {
 889     timeType = UTZFMT_TIME_TYPE_UNKNOWN;
 890     tzID.setToBogus();
 891 
 892     if (U_FAILURE(status)) {
 893         return 0;
 894     }
 895 
 896     // Find matches in the TimeZoneNames first
 897     TimeZoneNames::MatchInfoCollection *tznamesMatches = findTimeZoneNames(text, start, types, status);
 898     if (U_FAILURE(status)) {
 899         return 0;
 900     }
 901 
 902     int32_t bestMatchLen = 0;
 903     UTimeZoneFormatTimeType bestMatchTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
 904     UnicodeString bestMatchTzID;
 905     // UBool isLongStandard = FALSE;   // workaround - see the comments below
 906     UBool isStandard = FALSE;       // TODO: Temporary hack (on hack) for short standard name/location name conflict (found in zh_Hant), should be removed after CLDR 21m1 integration
 907 
 908     if (tznamesMatches != NULL) {
 909         UnicodeString mzID;
 910         for (int32_t i = 0; i &lt; tznamesMatches-&gt;size(); i++) {
 911             int32_t len = tznamesMatches-&gt;getMatchLengthAt(i);
 912             if (len &gt; bestMatchLen) {
 913                 bestMatchLen = len;
 914                 if (!tznamesMatches-&gt;getTimeZoneIDAt(i, bestMatchTzID)) {
 915                     // name for a meta zone
 916                     if (tznamesMatches-&gt;getMetaZoneIDAt(i, mzID)) {
 917                         fTimeZoneNames-&gt;getReferenceZoneID(mzID, fTargetRegion, bestMatchTzID);
 918                     }
 919                 }
 920                 UTimeZoneNameType nameType = tznamesMatches-&gt;getNameTypeAt(i);
 921                 if (U_FAILURE(status)) {
 922                     break;
 923                 }
 924                 switch (nameType) {
 925                 case UTZNM_LONG_STANDARD:
 926                     // isLongStandard = TRUE;
 927                 case UTZNM_SHORT_STANDARD:  // this one is never used for generic, but just in case
 928                     isStandard = TRUE;      // TODO: Remove this later, see the comments above.
 929                     bestMatchTimeType = UTZFMT_TIME_TYPE_STANDARD;
 930                     break;
 931                 case UTZNM_LONG_DAYLIGHT:
 932                 case UTZNM_SHORT_DAYLIGHT: // this one is never used for generic, but just in case
 933                     bestMatchTimeType = UTZFMT_TIME_TYPE_DAYLIGHT;
 934                     break;
 935                 default:
 936                     bestMatchTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
 937                 }
 938             }
 939         }
 940         delete tznamesMatches;
 941         if (U_FAILURE(status)) {
 942             return 0;
 943         }
 944 
 945         if (bestMatchLen == (text.length() - start)) {
 946             // Full match
 947 
 948             //tzID.setTo(bestMatchTzID);
 949             //timeType = bestMatchTimeType;
 950             //return bestMatchLen;
 951 
 952             // TODO Some time zone uses a same name for the long standard name
 953             // and the location name. When the match is a long standard name,
 954             // then we need to check if the name is same with the location name.
 955             // This is probably a data error or a design bug.
 956 /*
 957             if (!isLongStandard) {
 958                 tzID.setTo(bestMatchTzID);
 959                 timeType = bestMatchTimeType;
 960                 return bestMatchLen;
 961             }
 962 */
 963             // TODO The deprecation of commonlyUsed flag introduced the name
 964             // conflict not only for long standard names, but short standard names too.
 965             // These short names (found in zh_Hant) should be gone once we clean
 966             // up CLDR time zone display name data. Once the short name conflict
 967             // problem (with location name) is resolved, we should change the condition
 968             // below back to the original one above. -Yoshito (2011-09-14)
 969             if (!isStandard) {
 970                 tzID.setTo(bestMatchTzID);
 971                 timeType = bestMatchTimeType;
 972                 return bestMatchLen;
 973             }
 974         }
 975     }
 976 
 977     // Find matches in the local trie
 978     TimeZoneGenericNameMatchInfo *localMatches = findLocal(text, start, types, status);
 979     if (U_FAILURE(status)) {
 980         return 0;
 981     }
 982     if (localMatches != NULL) {
 983         for (int32_t i = 0; i &lt; localMatches-&gt;size(); i++) {
 984             int32_t len = localMatches-&gt;getMatchLength(i);
 985 
 986             // TODO See the above TODO. We use len &gt;= bestMatchLen
 987             // because of the long standard/location name collision
 988             // problem. If it is also a location name, carrying
 989             // timeType = UTZFMT_TIME_TYPE_STANDARD will cause a
 990             // problem in SimpleDateFormat
 991             if (len &gt;= bestMatchLen) {
 992                 bestMatchLen = localMatches-&gt;getMatchLength(i);
 993                 bestMatchTimeType = UTZFMT_TIME_TYPE_UNKNOWN;   // because generic
 994                 localMatches-&gt;getTimeZoneID(i, bestMatchTzID);
 995             }
 996         }
 997         delete localMatches;
 998     }
 999 
1000     if (bestMatchLen &gt; 0) {
1001         timeType = bestMatchTimeType;
1002         tzID.setTo(bestMatchTzID);
1003     }
1004     return bestMatchLen;
1005 }
1006 
1007 TimeZoneGenericNameMatchInfo*
1008 TZGNCore::findLocal(const UnicodeString&amp; text, int32_t start, uint32_t types, UErrorCode&amp; status) const {
1009     GNameSearchHandler handler(types);
1010 
1011     TZGNCore *nonConstThis = const_cast&lt;TZGNCore *&gt;(this);
1012 
1013     umtx_lock(gLock());
1014     {
1015         fGNamesTrie.search(text, start, (TextTrieMapSearchResultHandler *)&amp;handler, status);
1016     }
1017     umtx_unlock(gLock());
1018 
1019     if (U_FAILURE(status)) {
1020         return NULL;
1021     }
1022 
1023     TimeZoneGenericNameMatchInfo *gmatchInfo = NULL;
1024 
1025     int32_t maxLen = 0;
1026     UVector *results = handler.getMatches(maxLen);
1027     if (results != NULL &amp;&amp; ((maxLen == (text.length() - start)) || fGNamesTrieFullyLoaded)) {
1028         // perfect match
1029         gmatchInfo = new TimeZoneGenericNameMatchInfo(results);
1030         if (gmatchInfo == NULL) {
1031             status = U_MEMORY_ALLOCATION_ERROR;
1032             delete results;
1033             return NULL;
1034         }
1035         return gmatchInfo;
1036     }
1037 
1038     if (results != NULL) {
1039         delete results;
1040     }
1041 
1042     // All names are not yet loaded into the local trie.
1043     // Load all available names into the trie. This could be very heavy.
1044     umtx_lock(gLock());
1045     {
1046         if (!fGNamesTrieFullyLoaded) {
1047             StringEnumeration *tzIDs = TimeZone::createTimeZoneIDEnumeration(UCAL_ZONE_TYPE_CANONICAL, NULL, NULL, status);
1048             if (U_SUCCESS(status)) {
1049                 const UnicodeString *tzID;
1050                 while ((tzID = tzIDs-&gt;snext(status)) != NULL) {
1051                     if (U_FAILURE(status)) {
1052                         break;
1053                     }
1054                     nonConstThis-&gt;loadStrings(*tzID);
1055                 }
1056             }
1057             if (tzIDs != NULL) {
1058                 delete tzIDs;
1059             }
1060 
1061             if (U_SUCCESS(status)) {
1062                 nonConstThis-&gt;fGNamesTrieFullyLoaded = TRUE;
1063             }
1064         }
1065     }
1066     umtx_unlock(gLock());
1067 
1068     if (U_FAILURE(status)) {
1069         return NULL;
1070     }
1071 
1072     umtx_lock(gLock());
1073     {
1074         // now try it again
1075         fGNamesTrie.search(text, start, (TextTrieMapSearchResultHandler *)&amp;handler, status);
1076     }
1077     umtx_unlock(gLock());
1078 
1079     results = handler.getMatches(maxLen);
1080     if (results != NULL &amp;&amp; maxLen &gt; 0) {
1081         gmatchInfo = new TimeZoneGenericNameMatchInfo(results);
1082         if (gmatchInfo == NULL) {
1083             status = U_MEMORY_ALLOCATION_ERROR;
1084             delete results;
1085             return NULL;
1086         }
1087     }
1088 
1089     return gmatchInfo;
1090 }
1091 
1092 TimeZoneNames::MatchInfoCollection*
1093 TZGNCore::findTimeZoneNames(const UnicodeString&amp; text, int32_t start, uint32_t types, UErrorCode&amp; status) const {
1094     // Check if the target name typs is really in the TimeZoneNames
1095     uint32_t nameTypes = 0;
1096     if (types &amp; UTZGNM_LONG) {
1097         nameTypes |= (UTZNM_LONG_GENERIC | UTZNM_LONG_STANDARD);
1098     }
1099     if (types &amp; UTZGNM_SHORT) {
1100         nameTypes |= (UTZNM_SHORT_GENERIC | UTZNM_SHORT_STANDARD);
1101     }
1102 
1103     if (types) {
1104         // Find matches in the TimeZoneNames
1105         return fTimeZoneNames-&gt;find(text, start, nameTypes, status);
1106     }
1107 
1108     return NULL;
1109 }
1110 
1111 typedef struct TZGNCoreRef {
1112     TZGNCore*       obj;
1113     int32_t         refCount;
1114     double          lastAccess;
1115 } TZGNCoreRef;
1116 
1117 // TZGNCore object cache handling
1118 static UMutex *gTZGNLock() {
1119     static UMutex m = U_MUTEX_INITIALIZER;
1120     return &amp;m;
1121 }
1122 static UHashtable *gTZGNCoreCache = NULL;
1123 static UBool gTZGNCoreCacheInitialized = FALSE;
1124 
1125 // Access count - incremented every time up to SWEEP_INTERVAL,
1126 // then reset to 0
1127 static int32_t gAccessCount = 0;
1128 
1129 // Interval for calling the cache sweep function - every 100 times
1130 #define SWEEP_INTERVAL 100
1131 
1132 // Cache expiration in millisecond. When a cached entry is no
1133 // longer referenced and exceeding this threshold since last
1134 // access time, then the cache entry will be deleted by the sweep
1135 // function. For now, 3 minutes.
1136 #define CACHE_EXPIRATION 180000.0
1137 
1138 U_CDECL_BEGIN
1139 /**
1140  * Cleanup callback func
1141  */
1142 static UBool U_CALLCONV tzgnCore_cleanup(void)
1143 {
1144     if (gTZGNCoreCache != NULL) {
1145         uhash_close(gTZGNCoreCache);
1146         gTZGNCoreCache = NULL;
1147     }
1148     gTZGNCoreCacheInitialized = FALSE;
1149     return TRUE;
1150 }
1151 
1152 /**
1153  * Deleter for TZGNCoreRef
1154  */
1155 static void U_CALLCONV
1156 deleteTZGNCoreRef(void *obj) {
1157     icu::TZGNCoreRef *entry = (icu::TZGNCoreRef*)obj;
1158     delete (icu::TZGNCore*) entry-&gt;obj;
1159     uprv_free(entry);
1160 }
1161 U_CDECL_END
1162 
1163 /**
1164  * Function used for removing unreferrenced cache entries exceeding
1165  * the expiration time. This function must be called with in the mutex
1166  * block.
1167  */
1168 static void sweepCache() {
1169     int32_t pos = UHASH_FIRST;
1170     const UHashElement* elem;
1171     double now = (double)uprv_getUTCtime();
1172 
1173     while ((elem = uhash_nextElement(gTZGNCoreCache, &amp;pos)) != NULL) {
1174         TZGNCoreRef *entry = (TZGNCoreRef *)elem-&gt;value.pointer;
1175         if (entry-&gt;refCount &lt;= 0 &amp;&amp; (now - entry-&gt;lastAccess) &gt; CACHE_EXPIRATION) {
1176             // delete this entry
1177             uhash_removeElement(gTZGNCoreCache, elem);
1178         }
1179     }
1180 }
1181 
1182 TimeZoneGenericNames::TimeZoneGenericNames()
1183 : fRef(0) {
1184 }
1185 
1186 TimeZoneGenericNames::~TimeZoneGenericNames() {
1187     umtx_lock(gTZGNLock());
1188     {
1189         U_ASSERT(fRef-&gt;refCount &gt; 0);
1190         // Just decrement the reference count
1191         fRef-&gt;refCount--;
1192     }
1193     umtx_unlock(gTZGNLock());
1194 }
1195 
1196 TimeZoneGenericNames*
1197 TimeZoneGenericNames::createInstance(const Locale&amp; locale, UErrorCode&amp; status) {
1198     if (U_FAILURE(status)) {
1199         return NULL;
1200     }
1201     TimeZoneGenericNames* instance = new TimeZoneGenericNames();
1202     if (instance == NULL) {
1203         status = U_MEMORY_ALLOCATION_ERROR;
1204         return NULL;
1205     }
1206 
1207     TZGNCoreRef *cacheEntry = NULL;
1208     {
1209         Mutex lock(gTZGNLock());
1210 
1211         if (!gTZGNCoreCacheInitialized) {
1212             // Create empty hashtable
1213             gTZGNCoreCache = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;status);
1214             if (U_SUCCESS(status)) {
1215                 uhash_setKeyDeleter(gTZGNCoreCache, uprv_free);
1216                 uhash_setValueDeleter(gTZGNCoreCache, deleteTZGNCoreRef);
1217                 gTZGNCoreCacheInitialized = TRUE;
1218                 ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONEGENERICNAMES, tzgnCore_cleanup);
1219             }
1220         }
1221         if (U_FAILURE(status)) {
1222             return NULL;
1223         }
1224 
1225         // Check the cache, if not available, create new one and cache
1226         const char *key = locale.getName();
1227         cacheEntry = (TZGNCoreRef *)uhash_get(gTZGNCoreCache, key);
1228         if (cacheEntry == NULL) {
1229             TZGNCore *tzgnCore = NULL;
1230             char *newKey = NULL;
1231 
1232             tzgnCore = new TZGNCore(locale, status);
1233             if (tzgnCore == NULL) {
1234                 status = U_MEMORY_ALLOCATION_ERROR;
1235             }
1236             if (U_SUCCESS(status)) {
1237                 newKey = (char *)uprv_malloc(uprv_strlen(key) + 1);
1238                 if (newKey == NULL) {
1239                     status = U_MEMORY_ALLOCATION_ERROR;
1240                 } else {
1241                     uprv_strcpy(newKey, key);
1242                 }
1243             }
1244             if (U_SUCCESS(status)) {
1245                 cacheEntry = (TZGNCoreRef *)uprv_malloc(sizeof(TZGNCoreRef));
1246                 if (cacheEntry == NULL) {
1247                     status = U_MEMORY_ALLOCATION_ERROR;
1248                 } else {
1249                     cacheEntry-&gt;obj = tzgnCore;
1250                     cacheEntry-&gt;refCount = 1;
1251                     cacheEntry-&gt;lastAccess = (double)uprv_getUTCtime();
1252 
1253                     uhash_put(gTZGNCoreCache, newKey, cacheEntry, &amp;status);
1254                 }
1255             }
1256             if (U_FAILURE(status)) {
1257                 if (tzgnCore != NULL) {
1258                     delete tzgnCore;
1259                 }
1260                 if (newKey != NULL) {
1261                     uprv_free(newKey);
1262                 }
1263                 if (cacheEntry != NULL) {
1264                     uprv_free(cacheEntry);
1265                 }
1266                 cacheEntry = NULL;
1267             }
1268         } else {
1269             // Update the reference count
1270             cacheEntry-&gt;refCount++;
1271             cacheEntry-&gt;lastAccess = (double)uprv_getUTCtime();
1272         }
1273         gAccessCount++;
1274         if (gAccessCount &gt;= SWEEP_INTERVAL) {
1275             // sweep
1276             sweepCache();
1277             gAccessCount = 0;
1278         }
1279     }  // End of mutex locked block
1280 
1281     if (cacheEntry == NULL) {
1282         delete instance;
1283         return NULL;
1284     }
1285 
1286     instance-&gt;fRef = cacheEntry;
1287     return instance;
1288 }
1289 
1290 UBool
1291 TimeZoneGenericNames::operator==(const TimeZoneGenericNames&amp; other) const {
1292     // Just compare if the other object also use the same
1293     // ref entry
1294     return fRef == other.fRef;
1295 }
1296 
1297 TimeZoneGenericNames*
1298 TimeZoneGenericNames::clone() const {
1299     TimeZoneGenericNames* other = new TimeZoneGenericNames();
1300     if (other) {
1301         umtx_lock(gTZGNLock());
1302         {
1303             // Just increments the reference count
1304             fRef-&gt;refCount++;
1305             other-&gt;fRef = fRef;
1306         }
1307         umtx_unlock(gTZGNLock());
1308     }
1309     return other;
1310 }
1311 
1312 UnicodeString&amp;
1313 TimeZoneGenericNames::getDisplayName(const TimeZone&amp; tz, UTimeZoneGenericNameType type,
1314                         UDate date, UnicodeString&amp; name) const {
1315     return fRef-&gt;obj-&gt;getDisplayName(tz, type, date, name);
1316 }
1317 
1318 UnicodeString&amp;
1319 TimeZoneGenericNames::getGenericLocationName(const UnicodeString&amp; tzCanonicalID, UnicodeString&amp; name) const {
1320     return fRef-&gt;obj-&gt;getGenericLocationName(tzCanonicalID, name);
1321 }
1322 
1323 int32_t
1324 TimeZoneGenericNames::findBestMatch(const UnicodeString&amp; text, int32_t start, uint32_t types,
1325         UnicodeString&amp; tzID, UTimeZoneFormatTimeType&amp; timeType, UErrorCode&amp; status) const {
1326     return fRef-&gt;obj-&gt;findBestMatch(text, start, types, tzID, timeType, status);
1327 }
1328 
1329 U_NAMESPACE_END
1330 #endif
    </pre>
  </body>
</html>