<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/regex.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 2002-2016, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 *   file name:  regex.h
   9 *   encoding:   UTF-8
  10 *   indentation:4
  11 *
  12 *   created on: 2002oct22
  13 *   created by: Andy Heninger
  14 *
  15 *   ICU Regular Expressions, API for C++
  16 */
  17 
  18 #ifndef REGEX_H
  19 #define REGEX_H
  20 
  21 //#define REGEX_DEBUG
  22 
  23 /**
  24  * \file
  25  * \brief  C++ API:  Regular Expressions
  26  *
<a name="1" id="anc1"></a><span class="line-modified">  27  * The ICU API for processing regular expressions consists of two classes,</span>
<span class="line-modified">  28  *  `RegexPattern` and `RegexMatcher`.</span>
<span class="line-modified">  29  *  `RegexPattern` objects represent a pre-processed, or compiled</span>


  30  *  regular expression.  They are created from a regular expression pattern string,
<a name="2" id="anc2"></a><span class="line-modified">  31  *  and can be used to create `RegexMatcher` objects for the pattern.</span>
  32  *
<a name="3" id="anc3"></a><span class="line-modified">  33  * Class `RegexMatcher` bundles together a regular expression</span>
  34  *  pattern and a target string to which the search pattern will be applied.
<a name="4" id="anc4"></a><span class="line-modified">  35  *  `RegexMatcher` includes API for doing plain find or search</span>
  36  *  operations, for search and replace operations, and for obtaining detailed
<a name="5" id="anc5"></a><span class="line-modified">  37  *  information about bounds of a match.</span>
  38  *
<a name="6" id="anc6"></a><span class="line-modified">  39  * Note that by constructing `RegexMatcher` objects directly from regular</span>
  40  * expression pattern strings application code can be simplified and the explicit
<a name="7" id="anc7"></a><span class="line-modified">  41  * need for `RegexPattern` objects can usually be eliminated.</span>
<span class="line-modified">  42  *</span>
  43  */
  44 
  45 #include &quot;unicode/utypes.h&quot;
  46 
  47 #if !UCONFIG_NO_REGULAR_EXPRESSIONS
  48 
  49 #include &quot;unicode/uobject.h&quot;
  50 #include &quot;unicode/unistr.h&quot;
  51 #include &quot;unicode/utext.h&quot;
  52 #include &quot;unicode/parseerr.h&quot;
  53 
  54 #include &quot;unicode/uregex.h&quot;
  55 
  56 // Forward Declarations
  57 
  58 struct UHashtable;
  59 
  60 U_NAMESPACE_BEGIN
  61 
  62 struct Regex8BitSet;
  63 class  RegexCImpl;
  64 class  RegexMatcher;
  65 class  RegexPattern;
  66 struct REStackFrame;
  67 class  RuleBasedBreakIterator;
  68 class  UnicodeSet;
  69 class  UVector;
  70 class  UVector32;
  71 class  UVector64;
  72 
  73 
  74 /**
<a name="8" id="anc8"></a><span class="line-modified">  75   * Class `RegexPattern` represents a compiled regular expression.  It includes</span>
  76   * factory methods for creating a RegexPattern object from the source (string) form
  77   * of a regular expression, methods for creating RegexMatchers that allow the pattern
  78   * to be applied to input text, and a few convenience methods for simple common
  79   * uses of regular expressions.
  80   *
<a name="9" id="anc9"></a><span class="line-modified">  81   * Class RegexPattern is not intended to be subclassed.</span>
  82   *
  83   * @stable ICU 2.4
  84   */
  85 class U_I18N_API RegexPattern U_FINAL : public UObject {
  86 public:
  87 
  88     /**
  89      * default constructor.  Create a RegexPattern object that refers to no actual
  90      *   pattern.  Not normally needed; RegexPattern objects are usually
<a name="10" id="anc10"></a><span class="line-modified">  91      *   created using the factory method `compile()`.</span>
  92      *
  93      * @stable ICU 2.4
  94      */
  95     RegexPattern();
  96 
  97     /**
  98      * Copy Constructor.  Create a new RegexPattern object that is equivalent
  99      *                    to the source object.
 100      * @param source the pattern object to be copied.
 101      * @stable ICU 2.4
 102      */
 103     RegexPattern(const RegexPattern &amp;source);
 104 
 105     /**
 106      * Destructor.  Note that a RegexPattern object must persist so long as any
 107      *  RegexMatcher objects that were created from the RegexPattern are active.
 108      * @stable ICU 2.4
 109      */
 110     virtual ~RegexPattern();
 111 
 112     /**
 113      * Comparison operator.  Two RegexPattern objects are considered equal if they
<a name="11" id="anc11"></a><span class="line-modified"> 114      * were constructed from identical source patterns using the same #URegexpFlag</span>
 115      * settings.
 116      * @param that a RegexPattern object to compare with &quot;this&quot;.
 117      * @return TRUE if the objects are equivalent.
 118      * @stable ICU 2.4
 119      */
 120     UBool           operator==(const RegexPattern&amp; that) const;
 121 
 122     /**
 123      * Comparison operator.  Two RegexPattern objects are considered equal if they
<a name="12" id="anc12"></a><span class="line-modified"> 124      * were constructed from identical source patterns using the same #URegexpFlag</span>
 125      * settings.
 126      * @param that a RegexPattern object to compare with &quot;this&quot;.
 127      * @return TRUE if the objects are different.
 128      * @stable ICU 2.4
 129      */
 130     inline UBool    operator!=(const RegexPattern&amp; that) const {return ! operator ==(that);}
 131 
 132     /**
 133      * Assignment operator.  After assignment, this RegexPattern will behave identically
 134      *     to the source object.
 135      * @stable ICU 2.4
 136      */
 137     RegexPattern  &amp;operator =(const RegexPattern &amp;source);
 138 
 139     /**
 140      * Create an exact copy of this RegexPattern object.  Since RegexPattern is not
 141      * intended to be subclassed, &lt;code&gt;clone()&lt;/code&gt; and the copy construction are
 142      * equivalent operations.
 143      * @return the copy of this RegexPattern
 144      * @stable ICU 2.4
 145      */
 146     virtual RegexPattern  *clone() const;
 147 
 148 
 149    /**
 150     * Compiles the regular expression in string form into a RegexPattern
 151     * object.  These compile methods, rather than the constructors, are the usual
 152     * way that RegexPattern objects are created.
 153     *
<a name="13" id="anc13"></a><span class="line-modified"> 154     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 155     * objects created from the pattern are active.  RegexMatchers keep a pointer
 156     * back to their pattern, so premature deletion of the pattern is a
<a name="14" id="anc14"></a><span class="line-modified"> 157     * catastrophic error.</span>
 158     *
<a name="15" id="anc15"></a><span class="line-modified"> 159     * All #URegexpFlag pattern match mode flags are set to their default values.</span>
 160     *
<a name="16" id="anc16"></a><span class="line-modified"> 161     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 162     *    from a pattern string rather than separately compiling the pattern and
<a name="17" id="anc17"></a><span class="line-modified"> 163     *    then creating a RegexMatcher object from the pattern.</span>
 164     *
 165     * @param regex The regular expression to be compiled.
 166     * @param pe    Receives the position (line and column nubers) of any error
 167     *              within the regular expression.)
 168     * @param status A reference to a UErrorCode to receive any errors.
 169     * @return      A regexPattern object for the compiled pattern.
 170     *
 171     * @stable ICU 2.4
 172     */
 173     static RegexPattern * U_EXPORT2 compile( const UnicodeString &amp;regex,
 174         UParseError          &amp;pe,
 175         UErrorCode           &amp;status);
 176 
 177    /**
 178     * Compiles the regular expression in string form into a RegexPattern
 179     * object.  These compile methods, rather than the constructors, are the usual
 180     * way that RegexPattern objects are created.
 181     *
<a name="18" id="anc18"></a><span class="line-modified"> 182     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 183     * objects created from the pattern are active.  RegexMatchers keep a pointer
 184     * back to their pattern, so premature deletion of the pattern is a
<a name="19" id="anc19"></a><span class="line-modified"> 185     * catastrophic error.</span>
 186     *
<a name="20" id="anc20"></a><span class="line-modified"> 187     * All #URegexpFlag pattern match mode flags are set to their default values.</span>
 188     *
<a name="21" id="anc21"></a><span class="line-modified"> 189     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 190     *    from a pattern string rather than separately compiling the pattern and
<a name="22" id="anc22"></a><span class="line-modified"> 191     *    then creating a RegexMatcher object from the pattern.</span>
 192     *
 193     * @param regex The regular expression to be compiled. Note, the text referred
 194     *              to by this UText must not be deleted during the lifetime of the
 195     *              RegexPattern object or any RegexMatcher object created from it.
 196     * @param pe    Receives the position (line and column nubers) of any error
 197     *              within the regular expression.)
 198     * @param status A reference to a UErrorCode to receive any errors.
 199     * @return      A regexPattern object for the compiled pattern.
 200     *
 201     * @stable ICU 4.6
 202     */
 203     static RegexPattern * U_EXPORT2 compile( UText *regex,
 204         UParseError          &amp;pe,
 205         UErrorCode           &amp;status);
 206 
 207    /**
 208     * Compiles the regular expression in string form into a RegexPattern
<a name="23" id="anc23"></a><span class="line-modified"> 209     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
 210     * rather than the constructors, are the usual way that RegexPattern objects
 211     * are created.
 212     *
<a name="24" id="anc24"></a><span class="line-modified"> 213     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 214     * objects created from the pattern are active.  RegexMatchers keep a pointer
 215     * back to their pattern, so premature deletion of the pattern is a
<a name="25" id="anc25"></a><span class="line-modified"> 216     * catastrophic error.</span>
 217     *
<a name="26" id="anc26"></a><span class="line-modified"> 218     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 219     *    from a pattern string instead of than separately compiling the pattern and
<a name="27" id="anc27"></a><span class="line-modified"> 220     *    then creating a RegexMatcher object from the pattern.</span>
 221     *
 222     * @param regex The regular expression to be compiled.
<a name="28" id="anc28"></a><span class="line-modified"> 223     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
 224     * @param pe    Receives the position (line and column numbers) of any error
 225     *              within the regular expression.)
 226     * @param status   A reference to a UErrorCode to receive any errors.
 227     * @return      A regexPattern object for the compiled pattern.
 228     *
 229     * @stable ICU 2.4
 230     */
 231     static RegexPattern * U_EXPORT2 compile( const UnicodeString &amp;regex,
 232         uint32_t             flags,
 233         UParseError          &amp;pe,
 234         UErrorCode           &amp;status);
 235 
 236    /**
 237     * Compiles the regular expression in string form into a RegexPattern
<a name="29" id="anc29"></a><span class="line-modified"> 238     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
 239     * rather than the constructors, are the usual way that RegexPattern objects
 240     * are created.
 241     *
<a name="30" id="anc30"></a><span class="line-modified"> 242     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 243     * objects created from the pattern are active.  RegexMatchers keep a pointer
 244     * back to their pattern, so premature deletion of the pattern is a
<a name="31" id="anc31"></a><span class="line-modified"> 245     * catastrophic error.</span>
 246     *
<a name="32" id="anc32"></a><span class="line-modified"> 247     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 248     *    from a pattern string instead of than separately compiling the pattern and
<a name="33" id="anc33"></a><span class="line-modified"> 249     *    then creating a RegexMatcher object from the pattern.</span>
 250     *
 251     * @param regex The regular expression to be compiled. Note, the text referred
 252     *              to by this UText must not be deleted during the lifetime of the
 253     *              RegexPattern object or any RegexMatcher object created from it.
<a name="34" id="anc34"></a><span class="line-modified"> 254     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
 255     * @param pe    Receives the position (line and column numbers) of any error
 256     *              within the regular expression.)
 257     * @param status   A reference to a UErrorCode to receive any errors.
 258     * @return      A regexPattern object for the compiled pattern.
 259     *
 260     * @stable ICU 4.6
 261     */
 262     static RegexPattern * U_EXPORT2 compile( UText *regex,
 263         uint32_t             flags,
 264         UParseError          &amp;pe,
 265         UErrorCode           &amp;status);
 266 
 267    /**
 268     * Compiles the regular expression in string form into a RegexPattern
<a name="35" id="anc35"></a><span class="line-modified"> 269     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
 270     * rather than the constructors, are the usual way that RegexPattern objects
 271     * are created.
 272     *
<a name="36" id="anc36"></a><span class="line-modified"> 273     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 274     * objects created from the pattern are active.  RegexMatchers keep a pointer
 275     * back to their pattern, so premature deletion of the pattern is a
<a name="37" id="anc37"></a><span class="line-modified"> 276     * catastrophic error.</span>
 277     *
<a name="38" id="anc38"></a><span class="line-modified"> 278     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 279     *    from a pattern string instead of than separately compiling the pattern and
<a name="39" id="anc39"></a><span class="line-modified"> 280     *    then creating a RegexMatcher object from the pattern.</span>
 281     *
 282     * @param regex The regular expression to be compiled.
<a name="40" id="anc40"></a><span class="line-modified"> 283     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
 284     * @param status   A reference to a UErrorCode to receive any errors.
 285     * @return      A regexPattern object for the compiled pattern.
 286     *
 287     * @stable ICU 2.6
 288     */
 289     static RegexPattern * U_EXPORT2 compile( const UnicodeString &amp;regex,
 290         uint32_t             flags,
 291         UErrorCode           &amp;status);
 292 
 293    /**
 294     * Compiles the regular expression in string form into a RegexPattern
<a name="41" id="anc41"></a><span class="line-modified"> 295     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
 296     * rather than the constructors, are the usual way that RegexPattern objects
 297     * are created.
 298     *
<a name="42" id="anc42"></a><span class="line-modified"> 299     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 300     * objects created from the pattern are active.  RegexMatchers keep a pointer
 301     * back to their pattern, so premature deletion of the pattern is a
<a name="43" id="anc43"></a><span class="line-modified"> 302     * catastrophic error.</span>
 303     *
<a name="44" id="anc44"></a><span class="line-modified"> 304     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 305     *    from a pattern string instead of than separately compiling the pattern and
<a name="45" id="anc45"></a><span class="line-modified"> 306     *    then creating a RegexMatcher object from the pattern.</span>
 307     *
 308     * @param regex The regular expression to be compiled. Note, the text referred
 309     *              to by this UText must not be deleted during the lifetime of the
 310     *              RegexPattern object or any RegexMatcher object created from it.
<a name="46" id="anc46"></a><span class="line-modified"> 311     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
 312     * @param status   A reference to a UErrorCode to receive any errors.
 313     * @return      A regexPattern object for the compiled pattern.
 314     *
 315     * @stable ICU 4.6
 316     */
 317     static RegexPattern * U_EXPORT2 compile( UText *regex,
 318         uint32_t             flags,
 319         UErrorCode           &amp;status);
 320 
 321    /**
<a name="47" id="anc47"></a><span class="line-modified"> 322     * Get the #URegexpFlag match mode flags that were used when compiling this pattern.</span>
<span class="line-modified"> 323     * @return  the #URegexpFlag match mode flags</span>
 324     * @stable ICU 2.4
 325     */
 326     virtual uint32_t flags() const;
 327 
 328    /**
 329     * Creates a RegexMatcher that will match the given input against this pattern.  The
 330     * RegexMatcher can then be used to perform match, find or replace operations
 331     * on the input.  Note that a RegexPattern object must not be deleted while
 332     * RegexMatchers created from it still exist and might possibly be used again.
<a name="48" id="anc48"></a><span class="line-modified"> 333     *</span>
 334     * The matcher will retain a reference to the supplied input string, and all regexp
 335     * pattern matching operations happen directly on this original string.  It is
 336     * critical that the string not be altered or deleted before use by the regular
 337     * expression operations is complete.
 338     *
 339     * @param input    The input string to which the regular expression will be applied.
 340     * @param status   A reference to a UErrorCode to receive any errors.
 341     * @return         A RegexMatcher object for this pattern and input.
 342     *
 343     * @stable ICU 2.4
 344     */
 345     virtual RegexMatcher *matcher(const UnicodeString &amp;input,
 346         UErrorCode          &amp;status) const;
 347 
 348 private:
 349     /**
 350      * Cause a compilation error if an application accidentally attempts to
 351      *   create a matcher with a (char16_t *) string as input rather than
 352      *   a UnicodeString.  Avoids a dangling reference to a temporary string.
<a name="49" id="anc49"></a><span class="line-modified"> 353      *</span>
 354      * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
 355      * using one of the aliasing constructors, such as
<a name="50" id="anc50"></a><span class="line-modified"> 356      * `UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);`</span>
 357      * or in a UText, using
<a name="51" id="anc51"></a><span class="line-modified"> 358      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`</span>
 359      *
 360      */
 361     RegexMatcher *matcher(const char16_t *input,
 362         UErrorCode          &amp;status) const;
 363 public:
 364 
 365 
 366    /**
 367     * Creates a RegexMatcher that will match against this pattern.  The
 368     * RegexMatcher can be used to perform match, find or replace operations.
 369     * Note that a RegexPattern object must not be deleted while
 370     * RegexMatchers created from it still exist and might possibly be used again.
 371     *
 372     * @param status   A reference to a UErrorCode to receive any errors.
 373     * @return      A RegexMatcher object for this pattern and input.
 374     *
 375     * @stable ICU 2.6
 376     */
 377     virtual RegexMatcher *matcher(UErrorCode  &amp;status) const;
 378 
 379 
 380    /**
 381     * Test whether a string matches a regular expression.  This convenience function
 382     * both compiles the regular expression and applies it in a single operation.
 383     * Note that if the same pattern needs to be applied repeatedly, this method will be
 384     * less efficient than creating and reusing a RegexMatcher object.
 385     *
 386     * @param regex The regular expression
 387     * @param input The string data to be matched
 388     * @param pe Receives the position of any syntax errors within the regular expression
 389     * @param status A reference to a UErrorCode to receive any errors.
 390     * @return True if the regular expression exactly matches the full input string.
 391     *
 392     * @stable ICU 2.4
 393     */
 394     static UBool U_EXPORT2 matches(const UnicodeString   &amp;regex,
 395         const UnicodeString   &amp;input,
 396               UParseError     &amp;pe,
 397               UErrorCode      &amp;status);
 398 
 399    /**
 400     * Test whether a string matches a regular expression.  This convenience function
 401     * both compiles the regular expression and applies it in a single operation.
 402     * Note that if the same pattern needs to be applied repeatedly, this method will be
 403     * less efficient than creating and reusing a RegexMatcher object.
 404     *
 405     * @param regex The regular expression
 406     * @param input The string data to be matched
 407     * @param pe Receives the position of any syntax errors within the regular expression
 408     * @param status A reference to a UErrorCode to receive any errors.
 409     * @return True if the regular expression exactly matches the full input string.
 410     *
 411     * @stable ICU 4.6
 412     */
 413     static UBool U_EXPORT2 matches(UText *regex,
 414         UText           *input,
 415         UParseError     &amp;pe,
 416         UErrorCode      &amp;status);
 417 
 418    /**
 419     * Returns the regular expression from which this pattern was compiled. This method will work
 420     * even if the pattern was compiled from a UText.
 421     *
 422     * Note: If the pattern was originally compiled from a UText, and that UText was modified,
 423     * the returned string may no longer reflect the RegexPattern object.
 424     * @stable ICU 2.4
 425     */
 426     virtual UnicodeString pattern() const;
 427 
 428 
 429    /**
 430     * Returns the regular expression from which this pattern was compiled. This method will work
 431     * even if the pattern was compiled from a UnicodeString.
 432     *
 433     * Note: This is the original input, not a clone. If the pattern was originally compiled from a
 434     * UText, and that UText was modified, the returned UText may no longer reflect the RegexPattern
 435     * object.
 436     *
 437     * @stable ICU 4.6
 438     */
 439     virtual UText *patternText(UErrorCode      &amp;status) const;
 440 
 441 
 442     /**
 443      * Get the group number corresponding to a named capture group.
 444      * The returned number can be used with any function that access
 445      * capture groups by number.
 446      *
 447      * The function returns an error status if the specified name does not
 448      * appear in the pattern.
 449      *
 450      * @param  groupName   The capture group name.
 451      * @param  status      A UErrorCode to receive any errors.
 452      *
 453      * @stable ICU 55
 454      */
 455     virtual int32_t groupNumberFromName(const UnicodeString &amp;groupName, UErrorCode &amp;status) const;
 456 
 457 
 458     /**
 459      * Get the group number corresponding to a named capture group.
 460      * The returned number can be used with any function that access
 461      * capture groups by number.
 462      *
 463      * The function returns an error status if the specified name does not
 464      * appear in the pattern.
 465      *
 466      * @param  groupName   The capture group name,
 467      *                     platform invariant characters only.
 468      * @param  nameLength  The length of the name, or -1 if the name is
 469      *                     nul-terminated.
 470      * @param  status      A UErrorCode to receive any errors.
 471      *
 472      * @stable ICU 55
 473      */
 474     virtual int32_t groupNumberFromName(const char *groupName, int32_t nameLength, UErrorCode &amp;status) const;
 475 
 476 
 477     /**
 478      * Split a string into fields.  Somewhat like split() from Perl or Java.
 479      * Pattern matches identify delimiters that separate the input
 480      * into fields.  The input data between the delimiters becomes the
 481      * fields themselves.
 482      *
 483      * If the delimiter pattern includes capture groups, the captured text will
 484      * also appear in the destination array of output strings, interspersed
 485      * with the fields.  This is similar to Perl, but differs from Java,
 486      * which ignores the presence of capture groups in the pattern.
 487      *
 488      * Trailing empty fields will always be returned, assuming sufficient
 489      * destination capacity.  This differs from the default behavior for Java
 490      * and Perl where trailing empty fields are not returned.
 491      *
 492      * The number of strings produced by the split operation is returned.
 493      * This count includes the strings from capture groups in the delimiter pattern.
 494      * This behavior differs from Java, which ignores capture groups.
 495      *
 496      * For the best performance on split() operations,
 497      * &lt;code&gt;RegexMatcher::split&lt;/code&gt; is preferable to this function
 498      *
 499      * @param input   The string to be split into fields.  The field delimiters
 500      *                match the pattern (in the &quot;this&quot; object)
 501      * @param dest    An array of UnicodeStrings to receive the results of the split.
 502      *                This is an array of actual UnicodeString objects, not an
 503      *                array of pointers to strings.  Local (stack based) arrays can
 504      *                work well here.
 505      * @param destCapacity  The number of elements in the destination array.
 506      *                If the number of fields found is less than destCapacity, the
 507      *                extra strings in the destination array are not altered.
 508      *                If the number of destination strings is less than the number
 509      *                of fields, the trailing part of the input string, including any
 510      *                field delimiters, is placed in the last destination string.
 511      * @param status  A reference to a UErrorCode to receive any errors.
 512      * @return        The number of fields into which the input string was split.
 513      * @stable ICU 2.4
 514      */
 515     virtual int32_t  split(const UnicodeString &amp;input,
 516         UnicodeString    dest[],
 517         int32_t          destCapacity,
 518         UErrorCode       &amp;status) const;
 519 
 520 
 521     /**
<a name="52" id="anc52"></a><span class="line-modified"> 522      * Split a string into fields.  Somewhat like %split() from Perl or Java.</span>
 523      * Pattern matches identify delimiters that separate the input
 524      * into fields.  The input data between the delimiters becomes the
 525      * fields themselves.
 526      *
 527      * If the delimiter pattern includes capture groups, the captured text will
 528      * also appear in the destination array of output strings, interspersed
 529      * with the fields.  This is similar to Perl, but differs from Java,
 530      * which ignores the presence of capture groups in the pattern.
 531      *
 532      * Trailing empty fields will always be returned, assuming sufficient
 533      * destination capacity.  This differs from the default behavior for Java
 534      * and Perl where trailing empty fields are not returned.
 535      *
 536      * The number of strings produced by the split operation is returned.
 537      * This count includes the strings from capture groups in the delimiter pattern.
 538      * This behavior differs from Java, which ignores capture groups.
 539      *
 540      *  For the best performance on split() operations,
<a name="53" id="anc53"></a><span class="line-modified"> 541      *  `RegexMatcher::split()` is preferable to this function</span>
 542      *
 543      * @param input   The string to be split into fields.  The field delimiters
 544      *                match the pattern (in the &quot;this&quot; object)
 545      * @param dest    An array of mutable UText structs to receive the results of the split.
 546      *                If a field is NULL, a new UText is allocated to contain the results for
 547      *                that field. This new UText is not guaranteed to be mutable.
 548      * @param destCapacity  The number of elements in the destination array.
 549      *                If the number of fields found is less than destCapacity, the
 550      *                extra strings in the destination array are not altered.
 551      *                If the number of destination strings is less than the number
 552      *                of fields, the trailing part of the input string, including any
 553      *                field delimiters, is placed in the last destination string.
 554      * @param status  A reference to a UErrorCode to receive any errors.
 555      * @return        The number of destination strings used.
 556      *
 557      * @stable ICU 4.6
 558      */
 559     virtual int32_t  split(UText *input,
 560         UText            *dest[],
 561         int32_t          destCapacity,
 562         UErrorCode       &amp;status) const;
 563 
 564 
 565     /**
 566      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for the actual class.
 567      *
 568      * @stable ICU 2.4
 569      */
 570     virtual UClassID getDynamicClassID() const;
 571 
 572     /**
 573      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for this class.
 574      *
 575      * @stable ICU 2.4
 576      */
 577     static UClassID U_EXPORT2 getStaticClassID();
 578 
 579 private:
 580     //
 581     //  Implementation Data
 582     //
 583     UText          *fPattern;      // The original pattern string.
 584     UnicodeString  *fPatternString; // The original pattern UncodeString if relevant
 585     uint32_t        fFlags;        // The flags used when compiling the pattern.
 586                                    //
 587     UVector64       *fCompiledPat; // The compiled pattern p-code.
 588     UnicodeString   fLiteralText;  // Any literal string data from the pattern,
 589                                    //   after un-escaping, for use during the match.
 590 
 591     UVector         *fSets;        // Any UnicodeSets referenced from the pattern.
 592     Regex8BitSet    *fSets8;       //      (and fast sets for latin-1 range.)
 593 
 594 
 595     UErrorCode      fDeferredStatus; // status if some prior error has left this
 596                                    //  RegexPattern in an unusable state.
 597 
 598     int32_t         fMinMatchLen;  // Minimum Match Length.  All matches will have length
 599                                    //   &gt;= this value.  For some patterns, this calculated
 600                                    //   value may be less than the true shortest
 601                                    //   possible match.
 602 
 603     int32_t         fFrameSize;    // Size of a state stack frame in the
 604                                    //   execution engine.
 605 
 606     int32_t         fDataSize;     // The size of the data needed by the pattern that
 607                                    //   does not go on the state stack, but has just
 608                                    //   a single copy per matcher.
 609 
 610     UVector32       *fGroupMap;    // Map from capture group number to position of
 611                                    //   the group&#39;s variables in the matcher stack frame.
 612 
 613     UnicodeSet     **fStaticSets;  // Ptr to static (shared) sets for predefined
 614                                    //   regex character classes, e.g. Word.
 615 
 616     Regex8BitSet   *fStaticSets8;  // Ptr to the static (shared) latin-1 only
 617                                    //  sets for predefined regex classes.
 618 
 619     int32_t         fStartType;    // Info on how a match must start.
 620     int32_t         fInitialStringIdx;     //
 621     int32_t         fInitialStringLen;
 622     UnicodeSet     *fInitialChars;
 623     UChar32         fInitialChar;
 624     Regex8BitSet   *fInitialChars8;
 625     UBool           fNeedsAltInput;
 626 
 627     UHashtable     *fNamedCaptureMap;  // Map from capture group names to numbers.
 628 
 629     friend class RegexCompile;
 630     friend class RegexMatcher;
 631     friend class RegexCImpl;
 632 
 633     //
 634     //  Implementation Methods
 635     //
 636     void        init();            // Common initialization, for use by constructors.
 637     void        zap();             // Common cleanup
 638 
 639     void        dumpOp(int32_t index) const;
 640 
 641   public:
 642 #ifndef U_HIDE_INTERNAL_API
 643     /**
 644       * Dump a compiled pattern. Internal debug function.
 645       * @internal
 646       */
 647     void        dumpPattern() const;
 648 #endif  /* U_HIDE_INTERNAL_API */
 649 };
 650 
 651 
 652 
 653 /**
 654  *  class RegexMatcher bundles together a regular expression pattern and
 655  *  input text to which the expression can be applied.  It includes methods
 656  *  for testing for matches, and for find and replace operations.
 657  *
 658  * &lt;p&gt;Class RegexMatcher is not intended to be subclassed.&lt;/p&gt;
 659  *
 660  * @stable ICU 2.4
 661  */
 662 class U_I18N_API RegexMatcher U_FINAL : public UObject {
 663 public:
 664 
 665     /**
 666       * Construct a RegexMatcher for a regular expression.
 667       * This is a convenience method that avoids the need to explicitly create
 668       * a RegexPattern object.  Note that if several RegexMatchers need to be
 669       * created for the same expression, it will be more efficient to
 670       * separately create and cache a RegexPattern object, and use
 671       * its matcher() method to create the RegexMatcher objects.
 672       *
 673       *  @param regexp The Regular Expression to be compiled.
<a name="54" id="anc54"></a><span class="line-modified"> 674       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>

 675       *  @param status Any errors are reported by setting this UErrorCode variable.
 676       *  @stable ICU 2.6
 677       */
 678     RegexMatcher(const UnicodeString &amp;regexp, uint32_t flags, UErrorCode &amp;status);
 679 
 680     /**
 681       * Construct a RegexMatcher for a regular expression.
 682       * This is a convenience method that avoids the need to explicitly create
 683       * a RegexPattern object.  Note that if several RegexMatchers need to be
 684       * created for the same expression, it will be more efficient to
 685       * separately create and cache a RegexPattern object, and use
 686       * its matcher() method to create the RegexMatcher objects.
 687       *
 688       *  @param regexp The regular expression to be compiled.
<a name="55" id="anc55"></a><span class="line-modified"> 689       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>

 690       *  @param status Any errors are reported by setting this UErrorCode variable.
 691       *
 692       *  @stable ICU 4.6
 693       */
 694     RegexMatcher(UText *regexp, uint32_t flags, UErrorCode &amp;status);
 695 
 696     /**
 697       * Construct a RegexMatcher for a regular expression.
 698       * This is a convenience method that avoids the need to explicitly create
 699       * a RegexPattern object.  Note that if several RegexMatchers need to be
 700       * created for the same expression, it will be more efficient to
 701       * separately create and cache a RegexPattern object, and use
 702       * its matcher() method to create the RegexMatcher objects.
<a name="56" id="anc56"></a><span class="line-modified"> 703       *</span>
 704       * The matcher will retain a reference to the supplied input string, and all regexp
 705       * pattern matching operations happen directly on the original string.  It is
 706       * critical that the string not be altered or deleted before use by the regular
 707       * expression operations is complete.
 708       *
 709       *  @param regexp The Regular Expression to be compiled.
 710       *  @param input  The string to match.  The matcher retains a reference to the
 711       *                caller&#39;s string; mo copy is made.
<a name="57" id="anc57"></a><span class="line-modified"> 712       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>

 713       *  @param status Any errors are reported by setting this UErrorCode variable.
 714       *  @stable ICU 2.6
 715       */
 716     RegexMatcher(const UnicodeString &amp;regexp, const UnicodeString &amp;input,
 717         uint32_t flags, UErrorCode &amp;status);
 718 
 719     /**
 720       * Construct a RegexMatcher for a regular expression.
 721       * This is a convenience method that avoids the need to explicitly create
 722       * a RegexPattern object.  Note that if several RegexMatchers need to be
 723       * created for the same expression, it will be more efficient to
 724       * separately create and cache a RegexPattern object, and use
 725       * its matcher() method to create the RegexMatcher objects.
<a name="58" id="anc58"></a><span class="line-modified"> 726       *</span>
 727       * The matcher will make a shallow clone of the supplied input text, and all regexp
 728       * pattern matching operations happen on this clone.  While read-only operations on
 729       * the supplied text are permitted, it is critical that the underlying string not be
 730       * altered or deleted before use by the regular expression operations is complete.
 731       *
 732       *  @param regexp The Regular Expression to be compiled.
 733       *  @param input  The string to match.  The matcher retains a shallow clone of the text.
<a name="59" id="anc59"></a><span class="line-modified"> 734       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>

 735       *  @param status Any errors are reported by setting this UErrorCode variable.
 736       *
 737       *  @stable ICU 4.6
 738       */
 739     RegexMatcher(UText *regexp, UText *input,
 740         uint32_t flags, UErrorCode &amp;status);
 741 
 742 private:
 743     /**
 744      * Cause a compilation error if an application accidentally attempts to
 745      *   create a matcher with a (char16_t *) string as input rather than
 746      *   a UnicodeString.    Avoids a dangling reference to a temporary string.
<a name="60" id="anc60"></a><span class="line-modified"> 747      *</span>
 748      * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
 749      * using one of the aliasing constructors, such as
<a name="61" id="anc61"></a><span class="line-modified"> 750      * `UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);`</span>
 751      * or in a UText, using
<a name="62" id="anc62"></a><span class="line-modified"> 752      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`</span>

 753      */
 754     RegexMatcher(const UnicodeString &amp;regexp, const char16_t *input,
 755         uint32_t flags, UErrorCode &amp;status);
 756 public:
 757 
 758 
 759    /**
 760     *   Destructor.
 761     *
 762     *  @stable ICU 2.4
 763     */
 764     virtual ~RegexMatcher();
 765 
 766 
 767    /**
 768     *   Attempts to match the entire input region against the pattern.
 769     *    @param   status     A reference to a UErrorCode to receive any errors.
 770     *    @return TRUE if there is a match
 771     *    @stable ICU 2.4
 772     */
 773     virtual UBool matches(UErrorCode &amp;status);
 774 
 775 
 776    /**
 777     *   Resets the matcher, then attempts to match the input beginning
 778     *   at the specified startIndex, and extending to the end of the input.
 779     *   The input region is reset to include the entire input string.
 780     *   A successful match must extend to the end of the input.
 781     *    @param   startIndex The input string (native) index at which to begin matching.
 782     *    @param   status     A reference to a UErrorCode to receive any errors.
 783     *    @return TRUE if there is a match
 784     *    @stable ICU 2.8
 785     */
 786     virtual UBool matches(int64_t startIndex, UErrorCode &amp;status);
 787 
 788 
 789    /**
 790     *   Attempts to match the input string, starting from the beginning of the region,
 791     *   against the pattern.  Like the matches() method, this function
 792     *   always starts at the beginning of the input region;
 793     *   unlike that function, it does not require that the entire region be matched.
 794     *
<a name="63" id="anc63"></a><span class="line-modified"> 795     *   If the match succeeds then more information can be obtained via the start(),</span>
<span class="line-modified"> 796     *   end(), and group() functions.</span>
 797     *
 798     *    @param   status     A reference to a UErrorCode to receive any errors.
 799     *    @return  TRUE if there is a match at the start of the input string.
 800     *    @stable ICU 2.4
 801     */
 802     virtual UBool lookingAt(UErrorCode &amp;status);
 803 
 804 
 805   /**
 806     *   Attempts to match the input string, starting from the specified index, against the pattern.
 807     *   The match may be of any length, and is not required to extend to the end
 808     *   of the input string.  Contrast with match().
 809     *
<a name="64" id="anc64"></a><span class="line-modified"> 810     *   If the match succeeds then more information can be obtained via the start(),</span>
<span class="line-modified"> 811     *   end(), and group() functions.</span>
 812     *
 813     *    @param   startIndex The input string (native) index at which to begin matching.
 814     *    @param   status     A reference to a UErrorCode to receive any errors.
 815     *    @return  TRUE if there is a match.
 816     *    @stable ICU 2.8
 817     */
 818     virtual UBool lookingAt(int64_t startIndex, UErrorCode &amp;status);
 819 
 820 
 821    /**
 822     *  Find the next pattern match in the input string.
 823     *  The find begins searching the input at the location following the end of
 824     *  the previous match, or at the start of the string if there is no previous match.
<a name="65" id="anc65"></a><span class="line-modified"> 825     *  If a match is found, `start()`, `end()` and `group()`</span>
 826     *  will provide more information regarding the match.
<a name="66" id="anc66"></a><span class="line-modified"> 827     *  Note that if the input string is changed by the application,</span>
 828     *     use find(startPos, status) instead of find(), because the saved starting
<a name="67" id="anc67"></a><span class="line-modified"> 829     *     position may not be valid with the altered input string.</span>
 830     *  @return  TRUE if a match is found.
 831     *  @stable ICU 2.4
 832     */
 833     virtual UBool find();
 834 
 835 
 836    /**
 837     *  Find the next pattern match in the input string.
 838     *  The find begins searching the input at the location following the end of
 839     *  the previous match, or at the start of the string if there is no previous match.
<a name="68" id="anc68"></a><span class="line-modified"> 840     *  If a match is found, `start()`, `end()` and `group()`</span>
 841     *  will provide more information regarding the match.
<a name="69" id="anc69"></a><span class="line-modified"> 842     *</span>
<span class="line-modified"> 843     *  Note that if the input string is changed by the application,</span>
<span class="line-modified"> 844     *  use find(startPos, status) instead of find(), because the saved starting</span>
<span class="line-added"> 845     *  position may not be valid with the altered input string.</span>
 846     *  @param   status  A reference to a UErrorCode to receive any errors.
 847     *  @return  TRUE if a match is found.
 848     * @stable ICU 55
 849     */
 850     virtual UBool find(UErrorCode &amp;status);
 851 
 852    /**
 853     *   Resets this RegexMatcher and then attempts to find the next substring of the
 854     *   input string that matches the pattern, starting at the specified index.
 855     *
 856     *   @param   start     The (native) index in the input string to begin the search.
 857     *   @param   status    A reference to a UErrorCode to receive any errors.
 858     *   @return  TRUE if a match is found.
 859     *   @stable ICU 2.4
 860     */
 861     virtual UBool find(int64_t start, UErrorCode &amp;status);
 862 
 863 
 864    /**
 865     *   Returns a string containing the text matched by the previous match.
 866     *   If the pattern can match an empty string, an empty string may be returned.
 867     *   @param   status      A reference to a UErrorCode to receive any errors.
 868     *                        Possible errors are  U_REGEX_INVALID_STATE if no match
 869     *                        has been attempted or the last match failed.
 870     *   @return  a string containing the matched input text.
 871     *   @stable ICU 2.4
 872     */
 873     virtual UnicodeString group(UErrorCode &amp;status) const;
 874 
 875 
 876    /**
 877     *    Returns a string containing the text captured by the given group
 878     *    during the previous match operation.  Group(0) is the entire match.
 879     *
 880     *    A zero length string is returned both for capture groups that did not
 881     *    participate in the match and for actual zero length matches.
 882     *    To distinguish between these two cases use the function start(),
 883     *    which returns -1 for non-participating groups.
 884     *
 885     *    @param groupNum the capture group number
 886     *    @param   status     A reference to a UErrorCode to receive any errors.
 887     *                        Possible errors are  U_REGEX_INVALID_STATE if no match
 888     *                        has been attempted or the last match failed and
 889     *                        U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number.
 890     *    @return the captured text
 891     *    @stable ICU 2.4
 892     */
 893     virtual UnicodeString group(int32_t groupNum, UErrorCode &amp;status) const;
 894 
 895    /**
 896     *   Returns the number of capturing groups in this matcher&#39;s pattern.
 897     *   @return the number of capture groups
 898     *   @stable ICU 2.4
 899     */
 900     virtual int32_t groupCount() const;
 901 
 902 
 903    /**
 904     *   Returns a shallow clone of the entire live input string with the UText current native index
 905     *   set to the beginning of the requested group.
 906     *
 907     *   @param   dest        The UText into which the input should be cloned, or NULL to create a new UText
 908     *   @param   group_len   A reference to receive the length of the desired capture group
 909     *   @param   status      A reference to a UErrorCode to receive any errors.
 910     *                        Possible errors are  U_REGEX_INVALID_STATE if no match
 911     *                        has been attempted or the last match failed and
 912     *                        U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number.
 913     *   @return dest if non-NULL, a shallow copy of the input text otherwise
 914     *
 915     *   @stable ICU 4.6
 916     */
 917     virtual UText *group(UText *dest, int64_t &amp;group_len, UErrorCode &amp;status) const;
 918 
 919    /**
 920     *   Returns a shallow clone of the entire live input string with the UText current native index
 921     *   set to the beginning of the requested group.
 922     *
 923     *   A group length of zero is returned both for capture groups that did not
 924     *   participate in the match and for actual zero length matches.
 925     *   To distinguish between these two cases use the function start(),
 926     *   which returns -1 for non-participating groups.
 927     *
 928     *   @param   groupNum   The capture group number.
 929     *   @param   dest        The UText into which the input should be cloned, or NULL to create a new UText.
 930     *   @param   group_len   A reference to receive the length of the desired capture group
 931     *   @param   status      A reference to a UErrorCode to receive any errors.
 932     *                        Possible errors are  U_REGEX_INVALID_STATE if no match
 933     *                        has been attempted or the last match failed and
 934     *                        U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number.
 935     *   @return dest if non-NULL, a shallow copy of the input text otherwise
 936     *
 937     *   @stable ICU 4.6
 938     */
 939     virtual UText *group(int32_t groupNum, UText *dest, int64_t &amp;group_len, UErrorCode &amp;status) const;
 940 
 941    /**
 942     *   Returns the index in the input string of the start of the text matched
 943     *   during the previous match operation.
 944     *    @param   status      a reference to a UErrorCode to receive any errors.
 945     *    @return              The (native) position in the input string of the start of the last match.
 946     *    @stable ICU 2.4
 947     */
 948     virtual int32_t start(UErrorCode &amp;status) const;
 949 
 950    /**
 951     *   Returns the index in the input string of the start of the text matched
 952     *   during the previous match operation.
 953     *    @param   status      a reference to a UErrorCode to receive any errors.
 954     *    @return              The (native) position in the input string of the start of the last match.
 955     *   @stable ICU 4.6
 956     */
 957     virtual int64_t start64(UErrorCode &amp;status) const;
 958 
 959 
 960    /**
 961     *   Returns the index in the input string of the start of the text matched by the
 962     *    specified capture group during the previous match operation.  Return -1 if
 963     *    the capture group exists in the pattern, but was not part of the last match.
 964     *
 965     *    @param  group       the capture group number
 966     *    @param  status      A reference to a UErrorCode to receive any errors.  Possible
 967     *                        errors are  U_REGEX_INVALID_STATE if no match has been
 968     *                        attempted or the last match failed, and
 969     *                        U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number
 970     *    @return the (native) start position of substring matched by the specified group.
 971     *    @stable ICU 2.4
 972     */
 973     virtual int32_t start(int32_t group, UErrorCode &amp;status) const;
 974 
 975    /**
 976     *   Returns the index in the input string of the start of the text matched by the
 977     *    specified capture group during the previous match operation.  Return -1 if
 978     *    the capture group exists in the pattern, but was not part of the last match.
 979     *
 980     *    @param  group       the capture group number.
 981     *    @param  status      A reference to a UErrorCode to receive any errors.  Possible
 982     *                        errors are  U_REGEX_INVALID_STATE if no match has been
 983     *                        attempted or the last match failed, and
 984     *                        U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number.
 985     *    @return the (native) start position of substring matched by the specified group.
 986     *    @stable ICU 4.6
 987     */
 988     virtual int64_t start64(int32_t group, UErrorCode &amp;status) const;
 989 
 990    /**
 991     *    Returns the index in the input string of the first character following the
 992     *    text matched during the previous match operation.
 993     *
 994     *   @param   status      A reference to a UErrorCode to receive any errors.  Possible
 995     *                        errors are  U_REGEX_INVALID_STATE if no match has been
 996     *                        attempted or the last match failed.
 997     *    @return the index of the last character matched, plus one.
 998     *                        The index value returned is a native index, corresponding to
 999     *                        code units for the underlying encoding type, for example,
1000     *                        a byte index for UTF-8.
1001     *   @stable ICU 2.4
1002     */
1003     virtual int32_t end(UErrorCode &amp;status) const;
1004 
1005    /**
1006     *    Returns the index in the input string of the first character following the
1007     *    text matched during the previous match operation.
1008     *
1009     *   @param   status      A reference to a UErrorCode to receive any errors.  Possible
1010     *                        errors are  U_REGEX_INVALID_STATE if no match has been
1011     *                        attempted or the last match failed.
1012     *    @return the index of the last character matched, plus one.
1013     *                        The index value returned is a native index, corresponding to
1014     *                        code units for the underlying encoding type, for example,
1015     *                        a byte index for UTF-8.
1016     *   @stable ICU 4.6
1017     */
1018     virtual int64_t end64(UErrorCode &amp;status) const;
1019 
1020 
1021    /**
1022     *    Returns the index in the input string of the character following the
1023     *    text matched by the specified capture group during the previous match operation.
1024     *
1025     *    @param group  the capture group number
1026     *    @param   status      A reference to a UErrorCode to receive any errors.  Possible
1027     *                        errors are  U_REGEX_INVALID_STATE if no match has been
1028     *                        attempted or the last match failed and
1029     *                        U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number
1030     *    @return  the index of the first character following the text
1031     *              captured by the specified group during the previous match operation.
1032     *              Return -1 if the capture group exists in the pattern but was not part of the match.
1033     *              The index value returned is a native index, corresponding to
1034     *              code units for the underlying encoding type, for example,
1035     *              a byte index for UTF8.
1036     *    @stable ICU 2.4
1037     */
1038     virtual int32_t end(int32_t group, UErrorCode &amp;status) const;
1039 
1040    /**
1041     *    Returns the index in the input string of the character following the
1042     *    text matched by the specified capture group during the previous match operation.
1043     *
1044     *    @param group  the capture group number
1045     *    @param   status      A reference to a UErrorCode to receive any errors.  Possible
1046     *                        errors are  U_REGEX_INVALID_STATE if no match has been
1047     *                        attempted or the last match failed and
1048     *                        U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number
1049     *    @return  the index of the first character following the text
1050     *              captured by the specified group during the previous match operation.
1051     *              Return -1 if the capture group exists in the pattern but was not part of the match.
1052     *              The index value returned is a native index, corresponding to
1053     *              code units for the underlying encoding type, for example,
1054     *              a byte index for UTF8.
1055     *   @stable ICU 4.6
1056     */
1057     virtual int64_t end64(int32_t group, UErrorCode &amp;status) const;
1058 
1059    /**
1060     *   Resets this matcher.  The effect is to remove any memory of previous matches,
1061     *       and to cause subsequent find() operations to begin at the beginning of
1062     *       the input string.
1063     *
1064     *   @return this RegexMatcher.
1065     *   @stable ICU 2.4
1066     */
1067     virtual RegexMatcher &amp;reset();
1068 
1069 
1070    /**
1071     *   Resets this matcher, and set the current input position.
1072     *   The effect is to remove any memory of previous matches,
1073     *       and to cause subsequent find() operations to begin at
1074     *       the specified (native) position in the input string.
<a name="70" id="anc70"></a><span class="line-modified">1075     *</span>
1076     *   The matcher&#39;s region is reset to its default, which is the entire
1077     *   input string.
<a name="71" id="anc71"></a><span class="line-modified">1078     *</span>
1079     *   An alternative to this function is to set a match region
1080     *   beginning at the desired index.
1081     *
1082     *   @return this RegexMatcher.
1083     *   @stable ICU 2.8
1084     */
1085     virtual RegexMatcher &amp;reset(int64_t index, UErrorCode &amp;status);
1086 
1087 
1088    /**
1089     *   Resets this matcher with a new input string.  This allows instances of RegexMatcher
1090     *     to be reused, which is more efficient than creating a new RegexMatcher for
1091     *     each input string to be processed.
1092     *   @param input The new string on which subsequent pattern matches will operate.
1093     *                The matcher retains a reference to the callers string, and operates
1094     *                directly on that.  Ownership of the string remains with the caller.
1095     *                Because no copy of the string is made, it is essential that the
1096     *                caller not delete the string until after regexp operations on it
1097     *                are done.
1098     *                Note that while a reset on the matcher with an input string that is then
1099     *                modified across/during matcher operations may be supported currently for UnicodeString,
1100     *                this was not originally intended behavior, and support for this is not guaranteed
1101     *                in upcoming versions of ICU.
1102     *   @return this RegexMatcher.
1103     *   @stable ICU 2.4
1104     */
1105     virtual RegexMatcher &amp;reset(const UnicodeString &amp;input);
1106 
1107 
1108    /**
1109     *   Resets this matcher with a new input string.  This allows instances of RegexMatcher
1110     *     to be reused, which is more efficient than creating a new RegexMatcher for
1111     *     each input string to be processed.
1112     *   @param input The new string on which subsequent pattern matches will operate.
1113     *                The matcher makes a shallow clone of the given text; ownership of the
1114     *                original string remains with the caller. Because no deep copy of the
1115     *                text is made, it is essential that the caller not modify the string
1116     *                until after regexp operations on it are done.
1117     *   @return this RegexMatcher.
1118     *
1119     *   @stable ICU 4.6
1120     */
1121     virtual RegexMatcher &amp;reset(UText *input);
1122 
1123 
1124   /**
1125     *  Set the subject text string upon which the regular expression is looking for matches
1126     *  without changing any other aspect of the matching state.
1127     *  The new and previous text strings must have the same content.
1128     *
1129     *  This function is intended for use in environments where ICU is operating on
1130     *  strings that may move around in memory.  It provides a mechanism for notifying
1131     *  ICU that the string has been relocated, and providing a new UText to access the
1132     *  string in its new position.
1133     *
1134     *  Note that the regular expression implementation never copies the underlying text
1135     *  of a string being matched, but always operates directly on the original text
1136     *  provided by the user. Refreshing simply drops the references to the old text
1137     *  and replaces them with references to the new.
1138     *
1139     *  Caution:  this function is normally used only by very specialized,
1140     *  system-level code.  One example use case is with garbage collection that moves
1141     *  the text in memory.
1142     *
1143     * @param input      The new (moved) text string.
1144     * @param status     Receives errors detected by this function.
1145     *
1146     * @stable ICU 4.8
1147     */
1148     virtual RegexMatcher &amp;refreshInputText(UText *input, UErrorCode &amp;status);
1149 
1150 private:
1151     /**
1152      * Cause a compilation error if an application accidentally attempts to
1153      *   reset a matcher with a (char16_t *) string as input rather than
1154      *   a UnicodeString.    Avoids a dangling reference to a temporary string.
<a name="72" id="anc72"></a><span class="line-modified">1155      *</span>
1156      * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
1157      * using one of the aliasing constructors, such as
<a name="73" id="anc73"></a><span class="line-modified">1158      * `UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);`</span>
1159      * or in a UText, using
<a name="74" id="anc74"></a><span class="line-modified">1160      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`</span>
1161      *
1162      */
1163     RegexMatcher &amp;reset(const char16_t *input);
1164 public:
1165 
1166    /**
1167     *   Returns the input string being matched.  Ownership of the string belongs to
1168     *   the matcher; it should not be altered or deleted. This method will work even if the input
1169     *   was originally supplied as a UText.
1170     *   @return the input string
1171     *   @stable ICU 2.4
1172     */
1173     virtual const UnicodeString &amp;input() const;
1174 
1175    /**
1176     *   Returns the input string being matched.  This is the live input text; it should not be
1177     *   altered or deleted. This method will work even if the input was originally supplied as
1178     *   a UnicodeString.
1179     *   @return the input text
1180     *
1181     *   @stable ICU 4.6
1182     */
1183     virtual UText *inputText() const;
1184 
1185    /**
1186     *   Returns the input string being matched, either by copying it into the provided
1187     *   UText parameter or by returning a shallow clone of the live input. Note that copying
1188     *   the entire input may cause significant performance and memory issues.
1189     *   @param dest The UText into which the input should be copied, or NULL to create a new UText
1190     *   @param status error code
1191     *   @return dest if non-NULL, a shallow copy of the input text otherwise
1192     *
1193     *   @stable ICU 4.6
1194     */
1195     virtual UText *getInput(UText *dest, UErrorCode &amp;status) const;
1196 
1197 
1198    /** Sets the limits of this matcher&#39;s region.
1199      * The region is the part of the input string that will be searched to find a match.
1200      * Invoking this method resets the matcher, and then sets the region to start
1201      * at the index specified by the start parameter and end at the index specified
1202      * by the end parameter.
1203      *
1204      * Depending on the transparency and anchoring being used (see useTransparentBounds
1205      * and useAnchoringBounds), certain constructs such as anchors may behave differently
1206      * at or around the boundaries of the region
1207      *
1208      * The function will fail if start is greater than limit, or if either index
1209      *  is less than zero or greater than the length of the string being matched.
1210      *
1211      * @param start  The (native) index to begin searches at.
1212      * @param limit  The index to end searches at (exclusive).
1213      * @param status A reference to a UErrorCode to receive any errors.
1214      * @stable ICU 4.0
1215      */
1216      virtual RegexMatcher &amp;region(int64_t start, int64_t limit, UErrorCode &amp;status);
1217 
1218    /**
1219      * Identical to region(start, limit, status) but also allows a start position without
1220      *  resetting the region state.
1221      * @param regionStart The region start
1222      * @param regionLimit the limit of the region
1223      * @param startIndex  The (native) index within the region bounds at which to begin searches.
1224      * @param status A reference to a UErrorCode to receive any errors.
1225      *                If startIndex is not within the specified region bounds,
1226      *                U_INDEX_OUTOFBOUNDS_ERROR is returned.
1227      * @stable ICU 4.6
1228      */
1229      virtual RegexMatcher &amp;region(int64_t regionStart, int64_t regionLimit, int64_t startIndex, UErrorCode &amp;status);
1230 
1231    /**
1232      * Reports the start index of this matcher&#39;s region. The searches this matcher
1233      * conducts are limited to finding matches within regionStart (inclusive) and
1234      * regionEnd (exclusive).
1235      *
1236      * @return The starting (native) index of this matcher&#39;s region.
1237      * @stable ICU 4.0
1238      */
1239      virtual int32_t regionStart() const;
1240 
1241    /**
1242      * Reports the start index of this matcher&#39;s region. The searches this matcher
1243      * conducts are limited to finding matches within regionStart (inclusive) and
1244      * regionEnd (exclusive).
1245      *
1246      * @return The starting (native) index of this matcher&#39;s region.
1247      * @stable ICU 4.6
1248      */
1249      virtual int64_t regionStart64() const;
1250 
1251 
1252     /**
1253       * Reports the end (limit) index (exclusive) of this matcher&#39;s region. The searches
1254       * this matcher conducts are limited to finding matches within regionStart
1255       * (inclusive) and regionEnd (exclusive).
1256       *
1257       * @return The ending point (native) of this matcher&#39;s region.
1258       * @stable ICU 4.0
1259       */
1260       virtual int32_t regionEnd() const;
1261 
1262    /**
1263      * Reports the end (limit) index (exclusive) of this matcher&#39;s region. The searches
1264      * this matcher conducts are limited to finding matches within regionStart
1265      * (inclusive) and regionEnd (exclusive).
1266      *
1267      * @return The ending point (native) of this matcher&#39;s region.
1268      * @stable ICU 4.6
1269      */
1270       virtual int64_t regionEnd64() const;
1271 
1272     /**
1273       * Queries the transparency of region bounds for this matcher.
1274       * See useTransparentBounds for a description of transparent and opaque bounds.
1275       * By default, a matcher uses opaque region boundaries.
1276       *
1277       * @return TRUE if this matcher is using opaque bounds, false if it is not.
1278       * @stable ICU 4.0
1279       */
1280       virtual UBool hasTransparentBounds() const;
1281 
1282     /**
1283       * Sets the transparency of region bounds for this matcher.
1284       * Invoking this function with an argument of true will set this matcher to use transparent bounds.
1285       * If the boolean argument is false, then opaque bounds will be used.
1286       *
1287       * Using transparent bounds, the boundaries of this matcher&#39;s region are transparent
1288       * to lookahead, lookbehind, and boundary matching constructs. Those constructs can
1289       * see text beyond the boundaries of the region while checking for a match.
1290       *
1291       * With opaque bounds, no text outside of the matcher&#39;s region is visible to lookahead,
1292       * lookbehind, and boundary matching constructs.
1293       *
1294       * By default, a matcher uses opaque bounds.
1295       *
1296       * @param   b TRUE for transparent bounds; FALSE for opaque bounds
1297       * @return  This Matcher;
1298       * @stable ICU 4.0
1299       **/
1300       virtual RegexMatcher &amp;useTransparentBounds(UBool b);
1301 
1302 
1303     /**
1304       * Return true if this matcher is using anchoring bounds.
1305       * By default, matchers use anchoring region bounds.
1306       *
1307       * @return TRUE if this matcher is using anchoring bounds.
1308       * @stable ICU 4.0
1309       */
1310       virtual UBool hasAnchoringBounds() const;
1311 
1312 
1313     /**
1314       * Set whether this matcher is using Anchoring Bounds for its region.
1315       * With anchoring bounds, pattern anchors such as ^ and $ will match at the start
1316       * and end of the region.  Without Anchoring Bounds, anchors will only match at
1317       * the positions they would in the complete text.
1318       *
1319       * Anchoring Bounds are the default for regions.
1320       *
1321       * @param b TRUE if to enable anchoring bounds; FALSE to disable them.
1322       * @return  This Matcher
1323       * @stable ICU 4.0
1324       */
1325       virtual RegexMatcher &amp;useAnchoringBounds(UBool b);
1326 
1327 
1328     /**
1329       * Return TRUE if the most recent matching operation attempted to access
1330       *  additional input beyond the available input text.
1331       *  In this case, additional input text could change the results of the match.
1332       *
1333       *  hitEnd() is defined for both successful and unsuccessful matches.
1334       *  In either case hitEnd() will return TRUE if if the end of the text was
1335       *  reached at any point during the matching process.
1336       *
1337       *  @return  TRUE if the most recent match hit the end of input
1338       *  @stable ICU 4.0
1339       */
1340       virtual UBool hitEnd() const;
1341 
1342     /**
1343       * Return TRUE the most recent match succeeded and additional input could cause
1344       * it to fail. If this method returns false and a match was found, then more input
1345       * might change the match but the match won&#39;t be lost. If a match was not found,
1346       * then requireEnd has no meaning.
1347       *
1348       * @return TRUE if more input could cause the most recent match to no longer match.
1349       * @stable ICU 4.0
1350       */
1351       virtual UBool requireEnd() const;
1352 
1353 
1354    /**
1355     *    Returns the pattern that is interpreted by this matcher.
1356     *    @return  the RegexPattern for this RegexMatcher
1357     *    @stable ICU 2.4
1358     */
1359     virtual const RegexPattern &amp;pattern() const;
1360 
1361 
1362    /**
1363     *    Replaces every substring of the input that matches the pattern
1364     *    with the given replacement string.  This is a convenience function that
1365     *    provides a complete find-and-replace-all operation.
1366     *
1367     *    This method first resets this matcher. It then scans the input string
1368     *    looking for matches of the pattern. Input that is not part of any
1369     *    match is left unchanged; each match is replaced in the result by the
1370     *    replacement string. The replacement string may contain references to
1371     *    capture groups.
1372     *
1373     *    @param   replacement a string containing the replacement text.
1374     *    @param   status      a reference to a UErrorCode to receive any errors.
1375     *    @return              a string containing the results of the find and replace.
1376     *    @stable ICU 2.4
1377     */
1378     virtual UnicodeString replaceAll(const UnicodeString &amp;replacement, UErrorCode &amp;status);
1379 
1380 
1381    /**
1382     *    Replaces every substring of the input that matches the pattern
1383     *    with the given replacement string.  This is a convenience function that
1384     *    provides a complete find-and-replace-all operation.
1385     *
1386     *    This method first resets this matcher. It then scans the input string
1387     *    looking for matches of the pattern. Input that is not part of any
1388     *    match is left unchanged; each match is replaced in the result by the
1389     *    replacement string. The replacement string may contain references to
1390     *    capture groups.
1391     *
1392     *    @param   replacement a string containing the replacement text.
1393     *    @param   dest        a mutable UText in which the results are placed.
1394     *                          If NULL, a new UText will be created (which may not be mutable).
1395     *    @param   status      a reference to a UErrorCode to receive any errors.
1396     *    @return              a string containing the results of the find and replace.
1397     *                          If a pre-allocated UText was provided, it will always be used and returned.
1398     *
1399     *    @stable ICU 4.6
1400     */
1401     virtual UText *replaceAll(UText *replacement, UText *dest, UErrorCode &amp;status);
1402 
1403 
1404    /**
1405     * Replaces the first substring of the input that matches
1406     * the pattern with the replacement string.   This is a convenience
1407     * function that provides a complete find-and-replace operation.
1408     *
<a name="75" id="anc75"></a><span class="line-modified">1409     * This function first resets this RegexMatcher. It then scans the input string</span>
1410     * looking for a match of the pattern. Input that is not part
1411     * of the match is appended directly to the result string; the match is replaced
1412     * in the result by the replacement string. The replacement string may contain
<a name="76" id="anc76"></a><span class="line-modified">1413     * references to captured groups.</span>
1414     *
<a name="77" id="anc77"></a><span class="line-modified">1415     * The state of the matcher (the position at which a subsequent find()</span>
1416     *    would begin) after completing a replaceFirst() is not specified.  The
<a name="78" id="anc78"></a><span class="line-modified">1417     *    RegexMatcher should be reset before doing additional find() operations.</span>
1418     *
1419     *    @param   replacement a string containing the replacement text.
1420     *    @param   status      a reference to a UErrorCode to receive any errors.
1421     *    @return              a string containing the results of the find and replace.
1422     *    @stable ICU 2.4
1423     */
1424     virtual UnicodeString replaceFirst(const UnicodeString &amp;replacement, UErrorCode &amp;status);
1425 
1426 
1427    /**
1428     * Replaces the first substring of the input that matches
1429     * the pattern with the replacement string.   This is a convenience
1430     * function that provides a complete find-and-replace operation.
1431     *
<a name="79" id="anc79"></a><span class="line-modified">1432     * This function first resets this RegexMatcher. It then scans the input string</span>
1433     * looking for a match of the pattern. Input that is not part
1434     * of the match is appended directly to the result string; the match is replaced
1435     * in the result by the replacement string. The replacement string may contain
<a name="80" id="anc80"></a><span class="line-modified">1436     * references to captured groups.</span>
1437     *
<a name="81" id="anc81"></a><span class="line-modified">1438     * The state of the matcher (the position at which a subsequent find()</span>
1439     *    would begin) after completing a replaceFirst() is not specified.  The
<a name="82" id="anc82"></a><span class="line-modified">1440     *    RegexMatcher should be reset before doing additional find() operations.</span>
1441     *
1442     *    @param   replacement a string containing the replacement text.
1443     *    @param   dest        a mutable UText in which the results are placed.
1444     *                          If NULL, a new UText will be created (which may not be mutable).
1445     *    @param   status      a reference to a UErrorCode to receive any errors.
1446     *    @return              a string containing the results of the find and replace.
1447     *                          If a pre-allocated UText was provided, it will always be used and returned.
1448     *
1449     *    @stable ICU 4.6
1450     */
1451     virtual UText *replaceFirst(UText *replacement, UText *dest, UErrorCode &amp;status);
1452 
1453 
1454    /**
1455     *   Implements a replace operation intended to be used as part of an
1456     *   incremental find-and-replace.
1457     *
<a name="83" id="anc83"></a><span class="line-modified">1458     *   The input string, starting from the end of the previous replacement and ending at</span>
1459     *   the start of the current match, is appended to the destination string.  Then the
1460     *   replacement string is appended to the output string,
<a name="84" id="anc84"></a><span class="line-modified">1461     *   including handling any substitutions of captured text.</span>
1462     *
<a name="85" id="anc85"></a><span class="line-modified">1463     *   For simple, prepackaged, non-incremental find-and-replace</span>
<span class="line-modified">1464     *   operations, see replaceFirst() or replaceAll().</span>
1465     *
1466     *   @param   dest        A UnicodeString to which the results of the find-and-replace are appended.
1467     *   @param   replacement A UnicodeString that provides the text to be substituted for
1468     *                        the input text that matched the regexp pattern.  The replacement
1469     *                        text may contain references to captured text from the
1470     *                        input.
1471     *   @param   status      A reference to a UErrorCode to receive any errors.  Possible
1472     *                        errors are  U_REGEX_INVALID_STATE if no match has been
1473     *                        attempted or the last match failed, and U_INDEX_OUTOFBOUNDS_ERROR
1474     *                        if the replacement text specifies a capture group that
1475     *                        does not exist in the pattern.
1476     *
1477     *   @return  this  RegexMatcher
1478     *   @stable ICU 2.4
1479     *
1480     */
1481     virtual RegexMatcher &amp;appendReplacement(UnicodeString &amp;dest,
1482         const UnicodeString &amp;replacement, UErrorCode &amp;status);
1483 
1484 
1485    /**
1486     *   Implements a replace operation intended to be used as part of an
1487     *   incremental find-and-replace.
1488     *
<a name="86" id="anc86"></a><span class="line-modified">1489     *   The input string, starting from the end of the previous replacement and ending at</span>
1490     *   the start of the current match, is appended to the destination string.  Then the
1491     *   replacement string is appended to the output string,
<a name="87" id="anc87"></a><span class="line-modified">1492     *   including handling any substitutions of captured text.</span>
1493     *
<a name="88" id="anc88"></a><span class="line-modified">1494     *   For simple, prepackaged, non-incremental find-and-replace</span>
<span class="line-modified">1495     *   operations, see replaceFirst() or replaceAll().</span>
1496     *
1497     *   @param   dest        A mutable UText to which the results of the find-and-replace are appended.
1498     *                         Must not be NULL.
1499     *   @param   replacement A UText that provides the text to be substituted for
1500     *                        the input text that matched the regexp pattern.  The replacement
1501     *                        text may contain references to captured text from the input.
1502     *   @param   status      A reference to a UErrorCode to receive any errors.  Possible
1503     *                        errors are  U_REGEX_INVALID_STATE if no match has been
1504     *                        attempted or the last match failed, and U_INDEX_OUTOFBOUNDS_ERROR
1505     *                        if the replacement text specifies a capture group that
1506     *                        does not exist in the pattern.
1507     *
1508     *   @return  this  RegexMatcher
1509     *
1510     *   @stable ICU 4.6
1511     */
1512     virtual RegexMatcher &amp;appendReplacement(UText *dest,
1513         UText *replacement, UErrorCode &amp;status);
1514 
1515 
1516    /**
1517     * As the final step in a find-and-replace operation, append the remainder
1518     * of the input string, starting at the position following the last appendReplacement(),
<a name="89" id="anc89"></a><span class="line-modified">1519     * to the destination string. `appendTail()` is intended to be invoked after one</span>
<span class="line-modified">1520     * or more invocations of the `RegexMatcher::appendReplacement()`.</span>
1521     *
1522     *  @param dest A UnicodeString to which the results of the find-and-replace are appended.
1523     *  @return  the destination string.
1524     *  @stable ICU 2.4
1525     */
1526     virtual UnicodeString &amp;appendTail(UnicodeString &amp;dest);
1527 
1528 
1529    /**
1530     * As the final step in a find-and-replace operation, append the remainder
1531     * of the input string, starting at the position following the last appendReplacement(),
<a name="90" id="anc90"></a><span class="line-modified">1532     * to the destination string. `appendTail()` is intended to be invoked after one</span>
<span class="line-modified">1533     * or more invocations of the `RegexMatcher::appendReplacement()`.</span>
1534     *
1535     *  @param dest A mutable UText to which the results of the find-and-replace are appended.
1536     *               Must not be NULL.
1537     *  @param status error cod
1538     *  @return  the destination string.
1539     *
1540     *  @stable ICU 4.6
1541     */
1542     virtual UText *appendTail(UText *dest, UErrorCode &amp;status);
1543 
1544 
1545     /**
<a name="91" id="anc91"></a><span class="line-modified">1546      * Split a string into fields.  Somewhat like %split() from Perl.</span>
1547      * The pattern matches identify delimiters that separate the input
1548      *  into fields.  The input data between the matches becomes the
1549      *  fields themselves.
1550      *
1551      * @param input   The string to be split into fields.  The field delimiters
1552      *                match the pattern (in the &quot;this&quot; object).  This matcher
1553      *                will be reset to this input string.
1554      * @param dest    An array of UnicodeStrings to receive the results of the split.
1555      *                This is an array of actual UnicodeString objects, not an
1556      *                array of pointers to strings.  Local (stack based) arrays can
1557      *                work well here.
1558      * @param destCapacity  The number of elements in the destination array.
1559      *                If the number of fields found is less than destCapacity, the
1560      *                extra strings in the destination array are not altered.
1561      *                If the number of destination strings is less than the number
1562      *                of fields, the trailing part of the input string, including any
1563      *                field delimiters, is placed in the last destination string.
1564      * @param status  A reference to a UErrorCode to receive any errors.
1565      * @return        The number of fields into which the input string was split.
1566      * @stable ICU 2.6
1567      */
1568     virtual int32_t  split(const UnicodeString &amp;input,
1569         UnicodeString    dest[],
1570         int32_t          destCapacity,
1571         UErrorCode       &amp;status);
1572 
1573 
1574     /**
<a name="92" id="anc92"></a><span class="line-modified">1575      * Split a string into fields.  Somewhat like %split() from Perl.</span>
1576      * The pattern matches identify delimiters that separate the input
1577      *  into fields.  The input data between the matches becomes the
1578      *  fields themselves.
1579      *
1580      * @param input   The string to be split into fields.  The field delimiters
1581      *                match the pattern (in the &quot;this&quot; object).  This matcher
1582      *                will be reset to this input string.
1583      * @param dest    An array of mutable UText structs to receive the results of the split.
1584      *                If a field is NULL, a new UText is allocated to contain the results for
1585      *                that field. This new UText is not guaranteed to be mutable.
1586      * @param destCapacity  The number of elements in the destination array.
1587      *                If the number of fields found is less than destCapacity, the
1588      *                extra strings in the destination array are not altered.
1589      *                If the number of destination strings is less than the number
1590      *                of fields, the trailing part of the input string, including any
1591      *                field delimiters, is placed in the last destination string.
1592      * @param status  A reference to a UErrorCode to receive any errors.
1593      * @return        The number of fields into which the input string was split.
1594      *
1595      * @stable ICU 4.6
1596      */
1597     virtual int32_t  split(UText *input,
1598         UText           *dest[],
1599         int32_t          destCapacity,
1600         UErrorCode       &amp;status);
1601 
1602   /**
1603     *   Set a processing time limit for match operations with this Matcher.
1604     *
1605     *   Some patterns, when matching certain strings, can run in exponential time.
1606     *   For practical purposes, the match operation may appear to be in an
1607     *   infinite loop.
1608     *   When a limit is set a match operation will fail with an error if the
1609     *   limit is exceeded.
<a name="93" id="anc93"></a><span class="line-modified">1610     *</span>
1611     *   The units of the limit are steps of the match engine.
1612     *   Correspondence with actual processor time will depend on the speed
1613     *   of the processor and the details of the specific pattern, but will
1614     *   typically be on the order of milliseconds.
<a name="94" id="anc94"></a><span class="line-modified">1615     *</span>
1616     *   By default, the matching time is not limited.
<a name="95" id="anc95"></a><span class="line-modified">1617     *</span>
1618     *
1619     *   @param   limit       The limit value, or 0 for no limit.
1620     *   @param   status      A reference to a UErrorCode to receive any errors.
1621     *   @stable ICU 4.0
1622     */
1623     virtual void setTimeLimit(int32_t limit, UErrorCode &amp;status);
1624 
1625   /**
1626     * Get the time limit, if any, for match operations made with this Matcher.
1627     *
1628     *   @return the maximum allowed time for a match, in units of processing steps.
1629     *   @stable ICU 4.0
1630     */
1631     virtual int32_t getTimeLimit() const;
1632 
1633   /**
1634     *  Set the amount of heap storage available for use by the match backtracking stack.
1635     *  The matcher is also reset, discarding any results from previous matches.
<a name="96" id="anc96"></a><span class="line-modified">1636     *</span>
1637     *  ICU uses a backtracking regular expression engine, with the backtrack stack
1638     *  maintained on the heap.  This function sets the limit to the amount of memory
<a name="97" id="anc97"></a><span class="line-modified">1639     *  that can be used for this purpose.  A backtracking stack overflow will</span>
1640     *  result in an error from the match operation that caused it.
<a name="98" id="anc98"></a><span class="line-modified">1641     *</span>
1642     *  A limit is desirable because a malicious or poorly designed pattern can use
1643     *  excessive memory, potentially crashing the process.  A limit is enabled
1644     *  by default.
<a name="99" id="anc99"></a><span class="line-modified">1645     *</span>
1646     *  @param limit  The maximum size, in bytes, of the matching backtrack stack.
1647     *                A value of zero means no limit.
1648     *                The limit must be greater or equal to zero.
1649     *
1650     *  @param status   A reference to a UErrorCode to receive any errors.
1651     *
1652     *  @stable ICU 4.0
1653     */
1654     virtual void setStackLimit(int32_t  limit, UErrorCode &amp;status);
1655 
1656   /**
1657     *  Get the size of the heap storage available for use by the back tracking stack.
1658     *
1659     *  @return  the maximum backtracking stack size, in bytes, or zero if the
1660     *           stack size is unlimited.
1661     *  @stable ICU 4.0
1662     */
1663     virtual int32_t  getStackLimit() const;
1664 
1665 
1666   /**
1667     * Set a callback function for use with this Matcher.
1668     * During matching operations the function will be called periodically,
1669     * giving the application the opportunity to terminate a long-running
1670     * match.
1671     *
1672     *    @param   callback    A pointer to the user-supplied callback function.
1673     *    @param   context     User context pointer.  The value supplied at the
1674     *                         time the callback function is set will be saved
1675     *                         and passed to the callback each time that it is called.
1676     *    @param   status      A reference to a UErrorCode to receive any errors.
1677     *  @stable ICU 4.0
1678     */
1679     virtual void setMatchCallback(URegexMatchCallback     *callback,
1680                                   const void              *context,
1681                                   UErrorCode              &amp;status);
1682 
1683 
1684   /**
1685     *  Get the callback function for this URegularExpression.
1686     *
1687     *    @param   callback    Out parameter, receives a pointer to the user-supplied
1688     *                         callback function.
1689     *    @param   context     Out parameter, receives the user context pointer that
1690     *                         was set when uregex_setMatchCallback() was called.
1691     *    @param   status      A reference to a UErrorCode to receive any errors.
1692     *    @stable ICU 4.0
1693     */
1694     virtual void getMatchCallback(URegexMatchCallback     *&amp;callback,
1695                                   const void              *&amp;context,
1696                                   UErrorCode              &amp;status);
1697 
1698 
1699   /**
1700     * Set a progress callback function for use with find operations on this Matcher.
1701     * During find operations, the callback will be invoked after each return from a
1702     * match attempt, giving the application the opportunity to terminate a long-running
1703     * find operation.
1704     *
1705     *    @param   callback    A pointer to the user-supplied callback function.
1706     *    @param   context     User context pointer.  The value supplied at the
1707     *                         time the callback function is set will be saved
1708     *                         and passed to the callback each time that it is called.
1709     *    @param   status      A reference to a UErrorCode to receive any errors.
1710     *    @stable ICU 4.6
1711     */
1712     virtual void setFindProgressCallback(URegexFindProgressCallback      *callback,
1713                                               const void                              *context,
1714                                               UErrorCode                              &amp;status);
1715 
1716 
1717   /**
1718     *  Get the find progress callback function for this URegularExpression.
1719     *
1720     *    @param   callback    Out parameter, receives a pointer to the user-supplied
1721     *                         callback function.
1722     *    @param   context     Out parameter, receives the user context pointer that
1723     *                         was set when uregex_setFindProgressCallback() was called.
1724     *    @param   status      A reference to a UErrorCode to receive any errors.
1725     *    @stable ICU 4.6
1726     */
1727     virtual void getFindProgressCallback(URegexFindProgressCallback      *&amp;callback,
1728                                               const void                      *&amp;context,
1729                                               UErrorCode                      &amp;status);
1730 
1731 #ifndef U_HIDE_INTERNAL_API
1732    /**
1733      *   setTrace   Debug function, enable/disable tracing of the matching engine.
1734      *              For internal ICU development use only.  DO NO USE!!!!
1735      *   @internal
1736      */
1737     void setTrace(UBool state);
1738 #endif  /* U_HIDE_INTERNAL_API */
1739 
1740     /**
1741     * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for this class.
1742     *
1743     * @stable ICU 2.2
1744     */
1745     static UClassID U_EXPORT2 getStaticClassID();
1746 
1747     /**
1748      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for the actual class.
1749      *
1750      * @stable ICU 2.2
1751      */
1752     virtual UClassID getDynamicClassID() const;
1753 
1754 private:
1755     // Constructors and other object boilerplate are private.
1756     // Instances of RegexMatcher can not be assigned, copied, cloned, etc.
1757     RegexMatcher();                  // default constructor not implemented
1758     RegexMatcher(const RegexPattern *pat);
1759     RegexMatcher(const RegexMatcher &amp;other);
1760     RegexMatcher &amp;operator =(const RegexMatcher &amp;rhs);
1761     void init(UErrorCode &amp;status);                      // Common initialization
1762     void init2(UText *t, UErrorCode &amp;e);  // Common initialization, part 2.
1763 
1764     friend class RegexPattern;
1765     friend class RegexCImpl;
1766 public:
1767 #ifndef U_HIDE_INTERNAL_API
1768     /** @internal  */
1769     void resetPreserveRegion();  // Reset matcher state, but preserve any region.
1770 #endif  /* U_HIDE_INTERNAL_API */
1771 private:
1772 
1773     //
1774     //  MatchAt   This is the internal interface to the match engine itself.
1775     //            Match status comes back in matcher member variables.
1776     //
1777     void                 MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &amp;status);
1778     inline void          backTrack(int64_t &amp;inputIdx, int32_t &amp;patIdx);
1779     UBool                isWordBoundary(int64_t pos);         // perform Perl-like  \b test
1780     UBool                isUWordBoundary(int64_t pos);        // perform RBBI based \b test
1781     REStackFrame        *resetStack();
1782     inline REStackFrame *StateSave(REStackFrame *fp, int64_t savePatIdx, UErrorCode &amp;status);
1783     void                 IncrementTime(UErrorCode &amp;status);
1784 
1785     // Call user find callback function, if set. Return TRUE if operation should be interrupted.
1786     inline UBool         findProgressInterrupt(int64_t matchIndex, UErrorCode &amp;status);
1787 
1788     int64_t              appendGroup(int32_t groupNum, UText *dest, UErrorCode &amp;status) const;
1789 
1790     UBool                findUsingChunk(UErrorCode &amp;status);
1791     void                 MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &amp;status);
1792     UBool                isChunkWordBoundary(int32_t pos);
1793 
1794     const RegexPattern  *fPattern;
1795     RegexPattern        *fPatternOwned;    // Non-NULL if this matcher owns the pattern, and
1796                                            //   should delete it when through.
1797 
1798     const UnicodeString *fInput;           // The string being matched. Only used for input()
1799     UText               *fInputText;       // The text being matched. Is never NULL.
1800     UText               *fAltInputText;    // A shallow copy of the text being matched.
1801                                            //   Only created if the pattern contains backreferences.
1802     int64_t              fInputLength;     // Full length of the input text.
1803     int32_t              fFrameSize;       // The size of a frame in the backtrack stack.
1804 
1805     int64_t              fRegionStart;     // Start of the input region, default = 0.
1806     int64_t              fRegionLimit;     // End of input region, default to input.length.
1807 
1808     int64_t              fAnchorStart;     // Region bounds for anchoring operations (^ or $).
1809     int64_t              fAnchorLimit;     //   See useAnchoringBounds
1810 
1811     int64_t              fLookStart;       // Region bounds for look-ahead/behind and
1812     int64_t              fLookLimit;       //   and other boundary tests.  See
1813                                            //   useTransparentBounds
1814 
1815     int64_t              fActiveStart;     // Currently active bounds for matching.
1816     int64_t              fActiveLimit;     //   Usually is the same as region, but
1817                                            //   is changed to fLookStart/Limit when
1818                                            //   entering look around regions.
1819 
1820     UBool                fTransparentBounds;  // True if using transparent bounds.
1821     UBool                fAnchoringBounds; // True if using anchoring bounds.
1822 
1823     UBool                fMatch;           // True if the last attempted match was successful.
1824     int64_t              fMatchStart;      // Position of the start of the most recent match
1825     int64_t              fMatchEnd;        // First position after the end of the most recent match
1826                                            //   Zero if no previous match, even when a region
1827                                            //   is active.
1828     int64_t              fLastMatchEnd;    // First position after the end of the previous match,
1829                                            //   or -1 if there was no previous match.
1830     int64_t              fAppendPosition;  // First position after the end of the previous
1831                                            //   appendReplacement().  As described by the
1832                                            //   JavaDoc for Java Matcher, where it is called
1833                                            //   &quot;append position&quot;
1834     UBool                fHitEnd;          // True if the last match touched the end of input.
1835     UBool                fRequireEnd;      // True if the last match required end-of-input
1836                                            //    (matched $ or Z)
1837 
1838     UVector64           *fStack;
1839     REStackFrame        *fFrame;           // After finding a match, the last active stack frame,
1840                                            //   which will contain the capture group results.
1841                                            //   NOT valid while match engine is running.
1842 
1843     int64_t             *fData;            // Data area for use by the compiled pattern.
1844     int64_t             fSmallData[8];     //   Use this for data if it&#39;s enough.
1845 
1846     int32_t             fTimeLimit;        // Max time (in arbitrary steps) to let the
1847                                            //   match engine run.  Zero for unlimited.
1848 
1849     int32_t             fTime;             // Match time, accumulates while matching.
1850     int32_t             fTickCounter;      // Low bits counter for time.  Counts down StateSaves.
1851                                            //   Kept separately from fTime to keep as much
1852                                            //   code as possible out of the inline
1853                                            //   StateSave function.
1854 
1855     int32_t             fStackLimit;       // Maximum memory size to use for the backtrack
1856                                            //   stack, in bytes.  Zero for unlimited.
1857 
1858     URegexMatchCallback *fCallbackFn;       // Pointer to match progress callback funct.
1859                                            //   NULL if there is no callback.
1860     const void         *fCallbackContext;  // User Context ptr for callback function.
1861 
1862     URegexFindProgressCallback  *fFindProgressCallbackFn;  // Pointer to match progress callback funct.
1863                                                            //   NULL if there is no callback.
1864     const void         *fFindProgressCallbackContext;      // User Context ptr for callback function.
1865 
1866 
1867     UBool               fInputUniStrMaybeMutable;  // Set when fInputText wraps a UnicodeString that may be mutable - compatibility.
1868 
1869     UBool               fTraceDebug;       // Set true for debug tracing of match engine.
1870 
1871     UErrorCode          fDeferredStatus;   // Save error state that cannot be immediately
1872                                            //   reported, or that permanently disables this matcher.
1873 
1874     RuleBasedBreakIterator  *fWordBreakItr;
1875 };
1876 
1877 U_NAMESPACE_END
1878 #endif  // UCONFIG_NO_REGULAR_EXPRESSIONS
1879 #endif
<a name="100" id="anc100"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="100" type="hidden" />
</body>
</html>