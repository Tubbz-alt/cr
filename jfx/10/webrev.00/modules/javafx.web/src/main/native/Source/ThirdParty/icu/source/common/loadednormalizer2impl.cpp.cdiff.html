<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/loadednormalizer2impl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="hash.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="localsvc.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/loadednormalizer2impl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 16,10 ***</span>
<span class="line-new-header">--- 16,11 ---</span>
  #if !UCONFIG_NO_NORMALIZATION
  
  #include &quot;unicode/udata.h&quot;
  #include &quot;unicode/localpointer.h&quot;
  #include &quot;unicode/normalizer2.h&quot;
<span class="line-added">+ #include &quot;unicode/ucptrie.h&quot;</span>
  #include &quot;unicode/unistr.h&quot;
  #include &quot;unicode/unorm.h&quot;
  #include &quot;cstring.h&quot;
  #include &quot;mutex.h&quot;
  #include &quot;norm2allmodes.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,16 ***</span>
  private:
      static UBool U_CALLCONV
      isAcceptable(void *context, const char *type, const char *name, const UDataInfo *pInfo);
  
      UDataMemory *memory;
<span class="line-modified">!     UTrie2 *ownedTrie;</span>
  };
  
  LoadedNormalizer2Impl::~LoadedNormalizer2Impl() {
      udata_close(memory);
<span class="line-modified">!     utrie2_close(ownedTrie);</span>
  }
  
  UBool U_CALLCONV
  LoadedNormalizer2Impl::isAcceptable(void * /*context*/,
                                      const char * /* type */, const char * /*name*/,
<span class="line-new-header">--- 41,16 ---</span>
  private:
      static UBool U_CALLCONV
      isAcceptable(void *context, const char *type, const char *name, const UDataInfo *pInfo);
  
      UDataMemory *memory;
<span class="line-modified">!     UCPTrie *ownedTrie;</span>
  };
  
  LoadedNormalizer2Impl::~LoadedNormalizer2Impl() {
      udata_close(memory);
<span class="line-modified">!     ucptrie_close(ownedTrie);</span>
  }
  
  UBool U_CALLCONV
  LoadedNormalizer2Impl::isAcceptable(void * /*context*/,
                                      const char * /* type */, const char * /*name*/,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,11 ***</span>
          pInfo-&gt;charsetFamily==U_CHARSET_FAMILY &amp;&amp;
          pInfo-&gt;dataFormat[0]==0x4e &amp;&amp;    /* dataFormat=&quot;Nrm2&quot; */
          pInfo-&gt;dataFormat[1]==0x72 &amp;&amp;
          pInfo-&gt;dataFormat[2]==0x6d &amp;&amp;
          pInfo-&gt;dataFormat[3]==0x32 &amp;&amp;
<span class="line-modified">!         pInfo-&gt;formatVersion[0]==3</span>
      ) {
          // Normalizer2Impl *me=(Normalizer2Impl *)context;
          // uprv_memcpy(me-&gt;dataVersion, pInfo-&gt;dataVersion, 4);
          return TRUE;
      } else {
<span class="line-new-header">--- 61,11 ---</span>
          pInfo-&gt;charsetFamily==U_CHARSET_FAMILY &amp;&amp;
          pInfo-&gt;dataFormat[0]==0x4e &amp;&amp;    /* dataFormat=&quot;Nrm2&quot; */
          pInfo-&gt;dataFormat[1]==0x72 &amp;&amp;
          pInfo-&gt;dataFormat[2]==0x6d &amp;&amp;
          pInfo-&gt;dataFormat[3]==0x32 &amp;&amp;
<span class="line-modified">!         pInfo-&gt;formatVersion[0]==4</span>
      ) {
          // Normalizer2Impl *me=(Normalizer2Impl *)context;
          // uprv_memcpy(me-&gt;dataVersion, pInfo-&gt;dataVersion, 4);
          return TRUE;
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,13 ***</span>
          return;
      }
  
      int32_t offset=inIndexes[IX_NORM_TRIE_OFFSET];
      int32_t nextOffset=inIndexes[IX_EXTRA_DATA_OFFSET];
<span class="line-modified">!     ownedTrie=utrie2_openFromSerialized(UTRIE2_16_VALUE_BITS,</span>
<span class="line-modified">!                                         inBytes+offset, nextOffset-offset, NULL,</span>
<span class="line-modified">!                                         &amp;errorCode);</span>
      if(U_FAILURE(errorCode)) {
          return;
      }
  
      offset=nextOffset;
<span class="line-new-header">--- 90,13 ---</span>
          return;
      }
  
      int32_t offset=inIndexes[IX_NORM_TRIE_OFFSET];
      int32_t nextOffset=inIndexes[IX_EXTRA_DATA_OFFSET];
<span class="line-modified">!     ownedTrie=ucptrie_openFromBinary(UCPTRIE_TYPE_FAST, UCPTRIE_VALUE_BITS_16,</span>
<span class="line-modified">!                                      inBytes+offset, nextOffset-offset, NULL,</span>
<span class="line-modified">!                                      &amp;errorCode);</span>
      if(U_FAILURE(errorCode)) {
          return;
      }
  
      offset=nextOffset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,25 ***</span>
  
  U_CDECL_BEGIN
  static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup();
  U_CDECL_END
  
<span class="line-modified">! static Norm2AllModes *nfkcSingleton;</span>
<span class="line-modified">! static Norm2AllModes *nfkc_cfSingleton;</span>
<span class="line-modified">! static UHashtable    *cache=NULL;</span>
  
  static icu::UInitOnce nfkcInitOnce = U_INITONCE_INITIALIZER;
  static icu::UInitOnce nfkc_cfInitOnce = U_INITONCE_INITIALIZER;
  
  // UInitOnce singleton initialization function
  static void U_CALLCONV initSingletons(const char *what, UErrorCode &amp;errorCode) {
      if (uprv_strcmp(what, &quot;nfkc&quot;) == 0) {
          nfkcSingleton    = Norm2AllModes::createInstance(NULL, &quot;nfkc&quot;, errorCode);
      } else if (uprv_strcmp(what, &quot;nfkc_cf&quot;) == 0) {
          nfkc_cfSingleton = Norm2AllModes::createInstance(NULL, &quot;nfkc_cf&quot;, errorCode);
      } else {
<span class="line-modified">!         U_ASSERT(FALSE);   // Unknown singleton</span>
      }
      ucln_common_registerCleanup(UCLN_COMMON_LOADED_NORMALIZER2, uprv_loaded_normalizer2_cleanup);
  }
  
  U_CDECL_BEGIN
<span class="line-new-header">--- 130,36 ---</span>
  
  U_CDECL_BEGIN
  static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup();
  U_CDECL_END
  
<span class="line-modified">! #if !NORM2_HARDCODE_NFC_DATA</span>
<span class="line-modified">! static Norm2AllModes *nfcSingleton;</span>
<span class="line-modified">! static icu::UInitOnce nfcInitOnce = U_INITONCE_INITIALIZER;</span>
<span class="line-added">+ #endif</span>
  
<span class="line-added">+ static Norm2AllModes *nfkcSingleton;</span>
  static icu::UInitOnce nfkcInitOnce = U_INITONCE_INITIALIZER;
<span class="line-added">+ </span>
<span class="line-added">+ static Norm2AllModes *nfkc_cfSingleton;</span>
  static icu::UInitOnce nfkc_cfInitOnce = U_INITONCE_INITIALIZER;
  
<span class="line-added">+ static UHashtable    *cache=NULL;</span>
<span class="line-added">+ </span>
  // UInitOnce singleton initialization function
  static void U_CALLCONV initSingletons(const char *what, UErrorCode &amp;errorCode) {
<span class="line-added">+ #if !NORM2_HARDCODE_NFC_DATA</span>
<span class="line-added">+     if (uprv_strcmp(what, &quot;nfc&quot;) == 0) {</span>
<span class="line-added">+         nfcSingleton    = Norm2AllModes::createInstance(NULL, &quot;nfc&quot;, errorCode);</span>
<span class="line-added">+     } else</span>
<span class="line-added">+ #endif</span>
      if (uprv_strcmp(what, &quot;nfkc&quot;) == 0) {
          nfkcSingleton    = Norm2AllModes::createInstance(NULL, &quot;nfkc&quot;, errorCode);
      } else if (uprv_strcmp(what, &quot;nfkc_cf&quot;) == 0) {
          nfkc_cfSingleton = Norm2AllModes::createInstance(NULL, &quot;nfkc_cf&quot;, errorCode);
      } else {
<span class="line-modified">!         UPRV_UNREACHABLE;   // Unknown singleton</span>
      }
      ucln_common_registerCleanup(UCLN_COMMON_LOADED_NORMALIZER2, uprv_loaded_normalizer2_cleanup);
  }
  
  U_CDECL_BEGIN
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,23 ***</span>
  static void U_CALLCONV deleteNorm2AllModes(void *allModes) {
      delete (Norm2AllModes *)allModes;
  }
  
  static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup() {
      delete nfkcSingleton;
      nfkcSingleton = NULL;
      delete nfkc_cfSingleton;
      nfkc_cfSingleton = NULL;
      uhash_close(cache);
      cache=NULL;
<span class="line-removed">-     nfkcInitOnce.reset();</span>
<span class="line-removed">-     nfkc_cfInitOnce.reset();</span>
      return TRUE;
  }
  
  U_CDECL_END
  
  const Norm2AllModes *
  Norm2AllModes::getNFKCInstance(UErrorCode &amp;errorCode) {
      if(U_FAILURE(errorCode)) { return NULL; }
      umtx_initOnce(nfkcInitOnce, &amp;initSingletons, &quot;nfkc&quot;, errorCode);
      return nfkcSingleton;
<span class="line-new-header">--- 167,40 ---</span>
  static void U_CALLCONV deleteNorm2AllModes(void *allModes) {
      delete (Norm2AllModes *)allModes;
  }
  
  static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup() {
<span class="line-added">+ #if !NORM2_HARDCODE_NFC_DATA</span>
<span class="line-added">+     delete nfcSingleton;</span>
<span class="line-added">+     nfcSingleton = NULL;</span>
<span class="line-added">+     nfcInitOnce.reset();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      delete nfkcSingleton;
      nfkcSingleton = NULL;
<span class="line-added">+     nfkcInitOnce.reset();</span>
<span class="line-added">+ </span>
      delete nfkc_cfSingleton;
      nfkc_cfSingleton = NULL;
<span class="line-added">+     nfkc_cfInitOnce.reset();</span>
<span class="line-added">+ </span>
      uhash_close(cache);
      cache=NULL;
      return TRUE;
  }
  
  U_CDECL_END
  
<span class="line-added">+ #if !NORM2_HARDCODE_NFC_DATA</span>
<span class="line-added">+ const Norm2AllModes *</span>
<span class="line-added">+ Norm2AllModes::getNFCInstance(UErrorCode &amp;errorCode) {</span>
<span class="line-added">+     if(U_FAILURE(errorCode)) { return NULL; }</span>
<span class="line-added">+     umtx_initOnce(nfcInitOnce, &amp;initSingletons, &quot;nfc&quot;, errorCode);</span>
<span class="line-added">+     return nfcSingleton;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  const Norm2AllModes *
  Norm2AllModes::getNFKCInstance(UErrorCode &amp;errorCode) {
      if(U_FAILURE(errorCode)) { return NULL; }
      umtx_initOnce(nfkcInitOnce, &amp;initSingletons, &quot;nfkc&quot;, errorCode);
      return nfkcSingleton;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,10 ***</span>
<span class="line-new-header">--- 211,40 ---</span>
      if(U_FAILURE(errorCode)) { return NULL; }
      umtx_initOnce(nfkc_cfInitOnce, &amp;initSingletons, &quot;nfkc_cf&quot;, errorCode);
      return nfkc_cfSingleton;
  }
  
<span class="line-added">+ #if !NORM2_HARDCODE_NFC_DATA</span>
<span class="line-added">+ const Normalizer2 *</span>
<span class="line-added">+ Normalizer2::getNFCInstance(UErrorCode &amp;errorCode) {</span>
<span class="line-added">+     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);</span>
<span class="line-added">+     return allModes!=NULL ? &amp;allModes-&gt;comp : NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const Normalizer2 *</span>
<span class="line-added">+ Normalizer2::getNFDInstance(UErrorCode &amp;errorCode) {</span>
<span class="line-added">+     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);</span>
<span class="line-added">+     return allModes!=NULL ? &amp;allModes-&gt;decomp : NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const Normalizer2 *Normalizer2Factory::getFCDInstance(UErrorCode &amp;errorCode) {</span>
<span class="line-added">+     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);</span>
<span class="line-added">+     return allModes!=NULL ? &amp;allModes-&gt;fcd : NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const Normalizer2 *Normalizer2Factory::getFCCInstance(UErrorCode &amp;errorCode) {</span>
<span class="line-added">+     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);</span>
<span class="line-added">+     return allModes!=NULL ? &amp;allModes-&gt;fcc : NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const Normalizer2Impl *</span>
<span class="line-added">+ Normalizer2Factory::getNFCImpl(UErrorCode &amp;errorCode) {</span>
<span class="line-added">+     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);</span>
<span class="line-added">+     return allModes!=NULL ? allModes-&gt;impl : NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  const Normalizer2 *
  Normalizer2::getNFKCInstance(UErrorCode &amp;errorCode) {
      const Norm2AllModes *allModes=Norm2AllModes::getNFKCInstance(errorCode);
      return allModes!=NULL ? &amp;allModes-&gt;comp : NULL;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,11 ***</span>
                      uhash_setKeyDeleter(cache, uprv_free);
                      uhash_setValueDeleter(cache, deleteNorm2AllModes);
                  }
                  void *temp=uhash_get(cache, name);
                  if(temp==NULL) {
<span class="line-modified">!                     int32_t keyLength=uprv_strlen(name)+1;</span>
                      char *nameCopy=(char *)uprv_malloc(keyLength);
                      if(nameCopy==NULL) {
                          errorCode=U_MEMORY_ALLOCATION_ERROR;
                          return NULL;
                      }
<span class="line-new-header">--- 304,11 ---</span>
                      uhash_setKeyDeleter(cache, uprv_free);
                      uhash_setValueDeleter(cache, deleteNorm2AllModes);
                  }
                  void *temp=uhash_get(cache, name);
                  if(temp==NULL) {
<span class="line-modified">!                     int32_t keyLength= static_cast&lt;int32_t&gt;(uprv_strlen(name)+1);</span>
                      char *nameCopy=(char *)uprv_malloc(keyLength);
                      if(nameCopy==NULL) {
                          errorCode=U_MEMORY_ALLOCATION_ERROR;
                          return NULL;
                      }
</pre>
<center><a href="hash.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="localsvc.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>