<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_skeletons.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_scientific.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_skeletons.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_skeletons.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 157,12 ***</span>
          case STEM_ENGINEERING:
              return Notation::engineering();
          case STEM_NOTATION_SIMPLE:
              return Notation::simple();
          default:
<span class="line-modified">!             U_ASSERT(false);</span>
<span class="line-removed">-             return Notation::simple(); // return a value: silence compiler warning</span>
      }
  }
  
  MeasureUnit stem_to_object::unit(skeleton::StemEnum stem) {
      switch (stem) {
<span class="line-new-header">--- 157,11 ---</span>
          case STEM_ENGINEERING:
              return Notation::engineering();
          case STEM_NOTATION_SIMPLE:
              return Notation::simple();
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
      }
  }
  
  MeasureUnit stem_to_object::unit(skeleton::StemEnum stem) {
      switch (stem) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,12 ***</span>
              return NoUnit::percent(); // NOLINT
          case STEM_PERMILLE:
              // Slicing is okay
              return NoUnit::permille(); // NOLINT
          default:
<span class="line-modified">!             U_ASSERT(false);</span>
<span class="line-removed">-             return {}; // return a value: silence compiler warning</span>
      }
  }
  
  Precision stem_to_object::precision(skeleton::StemEnum stem) {
      switch (stem) {
<span class="line-new-header">--- 173,11 ---</span>
              return NoUnit::percent(); // NOLINT
          case STEM_PERMILLE:
              // Slicing is okay
              return NoUnit::permille(); // NOLINT
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
      }
  }
  
  Precision stem_to_object::precision(skeleton::StemEnum stem) {
      switch (stem) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,12 ***</span>
          case STEM_PRECISION_CURRENCY_STANDARD:
              return Precision::currency(UCURR_USAGE_STANDARD);
          case STEM_PRECISION_CURRENCY_CASH:
              return Precision::currency(UCURR_USAGE_CASH);
          default:
<span class="line-modified">!             U_ASSERT(false);</span>
<span class="line-removed">-             return Precision::integer(); // return a value: silence compiler warning</span>
      }
  }
  
  UNumberFormatRoundingMode stem_to_object::roundingMode(skeleton::StemEnum stem) {
      switch (stem) {
<span class="line-new-header">--- 188,11 ---</span>
          case STEM_PRECISION_CURRENCY_STANDARD:
              return Precision::currency(UCURR_USAGE_STANDARD);
          case STEM_PRECISION_CURRENCY_CASH:
              return Precision::currency(UCURR_USAGE_CASH);
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
      }
  }
  
  UNumberFormatRoundingMode stem_to_object::roundingMode(skeleton::StemEnum stem) {
      switch (stem) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,16 ***</span>
          case STEM_ROUNDING_MODE_HALF_UP:
              return UNUM_ROUND_HALFUP;
          case STEM_ROUNDING_MODE_UNNECESSARY:
              return UNUM_ROUND_UNNECESSARY;
          default:
<span class="line-modified">!             U_ASSERT(false);</span>
<span class="line-removed">-             return UNUM_ROUND_UNNECESSARY;</span>
      }
  }
  
<span class="line-modified">! UGroupingStrategy stem_to_object::groupingStrategy(skeleton::StemEnum stem) {</span>
      switch (stem) {
          case STEM_GROUP_OFF:
              return UNUM_GROUPING_OFF;
          case STEM_GROUP_MIN2:
              return UNUM_GROUPING_MIN2;
<span class="line-new-header">--- 211,15 ---</span>
          case STEM_ROUNDING_MODE_HALF_UP:
              return UNUM_ROUND_HALFUP;
          case STEM_ROUNDING_MODE_UNNECESSARY:
              return UNUM_ROUND_UNNECESSARY;
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
      }
  }
  
<span class="line-modified">! UNumberGroupingStrategy stem_to_object::groupingStrategy(skeleton::StemEnum stem) {</span>
      switch (stem) {
          case STEM_GROUP_OFF:
              return UNUM_GROUPING_OFF;
          case STEM_GROUP_MIN2:
              return UNUM_GROUPING_MIN2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 313,15 ***</span>
              break;
          case UNUM_ROUND_UNNECESSARY:
              sb.append(u&quot;rounding-mode-unnecessary&quot;, -1);
              break;
          default:
<span class="line-modified">!             U_ASSERT(false);</span>
      }
  }
  
<span class="line-modified">! void enum_to_stem_string::groupingStrategy(UGroupingStrategy value, UnicodeString&amp; sb) {</span>
      switch (value) {
          case UNUM_GROUPING_OFF:
              sb.append(u&quot;group-off&quot;, -1);
              break;
          case UNUM_GROUPING_MIN2:
<span class="line-new-header">--- 309,15 ---</span>
              break;
          case UNUM_ROUND_UNNECESSARY:
              sb.append(u&quot;rounding-mode-unnecessary&quot;, -1);
              break;
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
      }
  }
  
<span class="line-modified">! void enum_to_stem_string::groupingStrategy(UNumberGroupingStrategy value, UnicodeString&amp; sb) {</span>
      switch (value) {
          case UNUM_GROUPING_OFF:
              sb.append(u&quot;group-off&quot;, -1);
              break;
          case UNUM_GROUPING_MIN2:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,11 ***</span>
              break;
          case UNUM_GROUPING_THOUSANDS:
              sb.append(u&quot;group-thousands&quot;, -1);
              break;
          default:
<span class="line-modified">!             U_ASSERT(false);</span>
      }
  }
  
  void enum_to_stem_string::unitWidth(UNumberUnitWidth value, UnicodeString&amp; sb) {
      switch (value) {
<span class="line-new-header">--- 331,11 ---</span>
              break;
          case UNUM_GROUPING_THOUSANDS:
              sb.append(u&quot;group-thousands&quot;, -1);
              break;
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
      }
  }
  
  void enum_to_stem_string::unitWidth(UNumberUnitWidth value, UnicodeString&amp; sb) {
      switch (value) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 357,11 ***</span>
              break;
          case UNUM_UNIT_WIDTH_HIDDEN:
              sb.append(u&quot;unit-width-hidden&quot;, -1);
              break;
          default:
<span class="line-modified">!             U_ASSERT(false);</span>
      }
  }
  
  void enum_to_stem_string::signDisplay(UNumberSignDisplay value, UnicodeString&amp; sb) {
      switch (value) {
<span class="line-new-header">--- 353,11 ---</span>
              break;
          case UNUM_UNIT_WIDTH_HIDDEN:
              sb.append(u&quot;unit-width-hidden&quot;, -1);
              break;
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
      }
  }
  
  void enum_to_stem_string::signDisplay(UNumberSignDisplay value, UnicodeString&amp; sb) {
      switch (value) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,11 ***</span>
              break;
          case UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO:
              sb.append(u&quot;sign-accounting-except-zero&quot;, -1);
              break;
          default:
<span class="line-modified">!             U_ASSERT(false);</span>
      }
  }
  
  void
  enum_to_stem_string::decimalSeparatorDisplay(UNumberDecimalSeparatorDisplay value, UnicodeString&amp; sb) {
<span class="line-new-header">--- 381,11 ---</span>
              break;
          case UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO:
              sb.append(u&quot;sign-accounting-except-zero&quot;, -1);
              break;
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
      }
  }
  
  void
  enum_to_stem_string::decimalSeparatorDisplay(UNumberDecimalSeparatorDisplay value, UnicodeString&amp; sb) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,30 ***</span>
              break;
          case UNUM_DECIMAL_SEPARATOR_ALWAYS:
              sb.append(u&quot;decimal-always&quot;, -1);
              break;
          default:
<span class="line-modified">!             U_ASSERT(false);</span>
      }
  }
  
  
<span class="line-modified">! UnlocalizedNumberFormatter skeleton::create(const UnicodeString&amp; skeletonString, UErrorCode&amp; status) {</span>
      umtx_initOnce(gNumberSkeletonsInitOnce, &amp;initNumberSkeletons, status);
<span class="line-modified">!     MacroProps macros = parseSkeleton(skeletonString, status);</span>
<span class="line-modified">!     return NumberFormatter::with().macros(macros);</span>
  }
  
  UnicodeString skeleton::generate(const MacroProps&amp; macros, UErrorCode&amp; status) {
      umtx_initOnce(gNumberSkeletonsInitOnce, &amp;initNumberSkeletons, status);
      UnicodeString sb;
      GeneratorHelpers::generateSkeleton(macros, sb, status);
      return sb;
  }
  
<span class="line-modified">! MacroProps skeleton::parseSkeleton(const UnicodeString&amp; skeletonString, UErrorCode&amp; status) {</span>
<span class="line-modified">!     if (U_FAILURE(status)) { return MacroProps(); }</span>
  
      // Add a trailing whitespace to the end of the skeleton string to make code cleaner.
      UnicodeString tempSkeletonString(skeletonString);
      tempSkeletonString.append(u&#39; &#39;);
  
<span class="line-new-header">--- 395,62 ---</span>
              break;
          case UNUM_DECIMAL_SEPARATOR_ALWAYS:
              sb.append(u&quot;decimal-always&quot;, -1);
              break;
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
      }
  }
  
  
<span class="line-modified">! UnlocalizedNumberFormatter skeleton::create(</span>
<span class="line-added">+         const UnicodeString&amp; skeletonString, UParseError* perror, UErrorCode&amp; status) {</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Initialize perror</span>
<span class="line-added">+     if (perror != nullptr) {</span>
<span class="line-added">+         perror-&gt;line = 0;</span>
<span class="line-added">+         perror-&gt;offset = -1;</span>
<span class="line-added">+         perror-&gt;preContext[0] = 0;</span>
<span class="line-added">+         perror-&gt;postContext[0] = 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      umtx_initOnce(gNumberSkeletonsInitOnce, &amp;initNumberSkeletons, status);
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return {};</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     int32_t errOffset;</span>
<span class="line-added">+     MacroProps macros = parseSkeleton(skeletonString, errOffset, status);</span>
<span class="line-added">+     if (U_SUCCESS(status)) {</span>
<span class="line-added">+         return NumberFormatter::with().macros(macros);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (perror == nullptr) {</span>
<span class="line-added">+         return {};</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Populate the UParseError with the error location</span>
<span class="line-added">+     perror-&gt;offset = errOffset;</span>
<span class="line-added">+     int32_t contextStart = uprv_max(0, errOffset - U_PARSE_CONTEXT_LEN + 1);</span>
<span class="line-added">+     int32_t contextEnd = uprv_min(skeletonString.length(), errOffset + U_PARSE_CONTEXT_LEN - 1);</span>
<span class="line-added">+     skeletonString.extract(contextStart, errOffset - contextStart, perror-&gt;preContext, 0);</span>
<span class="line-added">+     perror-&gt;preContext[errOffset - contextStart] = 0;</span>
<span class="line-added">+     skeletonString.extract(errOffset, contextEnd - errOffset, perror-&gt;postContext, 0);</span>
<span class="line-added">+     perror-&gt;postContext[contextEnd - errOffset] = 0;</span>
<span class="line-added">+     return {};</span>
  }
  
  UnicodeString skeleton::generate(const MacroProps&amp; macros, UErrorCode&amp; status) {
      umtx_initOnce(gNumberSkeletonsInitOnce, &amp;initNumberSkeletons, status);
      UnicodeString sb;
      GeneratorHelpers::generateSkeleton(macros, sb, status);
      return sb;
  }
  
<span class="line-modified">! MacroProps skeleton::parseSkeleton(</span>
<span class="line-modified">!         const UnicodeString&amp; skeletonString, int32_t&amp; errOffset, UErrorCode&amp; status) {</span>
<span class="line-added">+     U_ASSERT(U_SUCCESS(status));</span>
  
      // Add a trailing whitespace to the end of the skeleton string to make code cleaner.
      UnicodeString tempSkeletonString(skeletonString);
      tempSkeletonString.append(u&#39; &#39;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 462,21 ***</span>
              } else {
                  // A separator after the first separator of a token. Parse it as an option.
                  stem = parseOption(stem, segment, macros, status);
              }
              segment.resetLength();
<span class="line-modified">!             if (U_FAILURE(status)) { return macros; }</span>
  
              // Consume the segment:
              segment.adjustOffset(offset);
              offset = 0;
  
              return macros;
  
          } else {
              // Two spaces in a row; this is OK.
          }
<span class="line-new-header">--- 490,25 ---</span>
              } else {
                  // A separator after the first separator of a token. Parse it as an option.
                  stem = parseOption(stem, segment, macros, status);
              }
              segment.resetLength();
<span class="line-modified">!             if (U_FAILURE(status)) {</span>
<span class="line-added">+                 errOffset = segment.getOffset();</span>
<span class="line-added">+                 return macros;</span>
<span class="line-added">+             }</span>
  
              // Consume the segment:
              segment.adjustOffset(offset);
              offset = 0;
  
<span class="line-added">+             errOffset = segment.getOffset();</span>
              return macros;
  
          } else {
              // Two spaces in a row; this is OK.
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 484,10 ***</span>
<span class="line-new-header">--- 516,11 ---</span>
          // Does the current stem forbid options?
          if (isOptionSeparator &amp;&amp; stem == STATE_NULL) {
              // segment.setLength(U16_LENGTH(cp)); // for error message
              // throw new SkeletonSyntaxException(&quot;Unexpected option separator&quot;, segment);
              status = U_NUMBER_SKELETON_SYNTAX_ERROR;
<span class="line-added">+             errOffset = segment.getOffset();</span>
              return macros;
          }
  
          // Does the current stem require an option?
          if (isTokenSeparator &amp;&amp; stem != STATE_NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 500,10 ***</span>
<span class="line-new-header">--- 533,11 ---</span>
                  case STATE_NUMBERING_SYSTEM:
                  case STATE_SCALE:
                      // segment.setLength(U16_LENGTH(cp)); // for error message
                      // throw new SkeletonSyntaxException(&quot;Stem requires an option&quot;, segment);
                      status = U_NUMBER_SKELETON_SYNTAX_ERROR;
<span class="line-added">+                     errOffset = segment.getOffset();</span>
                      return macros;
                  default:
                      break;
              }
              stem = STATE_NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 663,12 ***</span>
          case STEM_SCALE:
          CHECK_NULL(seen, scale, status);
              return STATE_SCALE;
  
          default:
<span class="line-modified">!             U_ASSERT(false);</span>
<span class="line-removed">-             return STATE_NULL; // return a value: silence compiler warning</span>
      }
  }
  
  ParseState skeleton::parseOption(ParseState stem, const StringSegment&amp; segment, MacroProps&amp; macros,
                                   UErrorCode&amp; status) {
<span class="line-new-header">--- 697,11 ---</span>
          case STEM_SCALE:
          CHECK_NULL(seen, scale, status);
              return STATE_SCALE;
  
          default:
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
      }
  }
  
  ParseState skeleton::parseOption(ParseState stem, const StringSegment&amp; segment, MacroProps&amp; macros,
                                   UErrorCode&amp; status) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1387,11 ***</span>
          if (impl.fMinSig == -1) {
              blueprint_helpers::generateDigitsStem(1, impl.fMaxSig, sb, status);
          } else {
              blueprint_helpers::generateDigitsStem(impl.fMinSig, -1, sb, status);
          }
<span class="line-modified">!     } else if (macros.precision.fType == Precision::RND_INCREMENT) {</span>
          const Precision::IncrementSettings&amp; impl = macros.precision.fUnion.increment;
          sb.append(u&quot;precision-increment/&quot;, -1);
          blueprint_helpers::generateIncrementOption(
                  impl.fIncrement,
                  impl.fMinFrac - impl.fMaxFrac,
<span class="line-new-header">--- 1420,13 ---</span>
          if (impl.fMinSig == -1) {
              blueprint_helpers::generateDigitsStem(1, impl.fMaxSig, sb, status);
          } else {
              blueprint_helpers::generateDigitsStem(impl.fMinSig, -1, sb, status);
          }
<span class="line-modified">!     } else if (macros.precision.fType == Precision::RND_INCREMENT</span>
<span class="line-added">+             || macros.precision.fType == Precision::RND_INCREMENT_ONE</span>
<span class="line-added">+             || macros.precision.fType == Precision::RND_INCREMENT_FIVE) {</span>
          const Precision::IncrementSettings&amp; impl = macros.precision.fUnion.increment;
          sb.append(u&quot;precision-increment/&quot;, -1);
          blueprint_helpers::generateIncrementOption(
                  impl.fIncrement,
                  impl.fMinFrac - impl.fMaxFrac,
</pre>
<center><a href="number_scientific.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_skeletons.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>