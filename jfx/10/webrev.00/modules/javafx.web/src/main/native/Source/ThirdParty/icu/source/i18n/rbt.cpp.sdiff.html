<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rbt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="rbnf.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbt.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rbt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10 **********************************************************************
 11 */
 12 
 13 #include &quot;unicode/utypes.h&quot;
 14 
 15 #if !UCONFIG_NO_TRANSLITERATION
 16 
 17 #include &quot;unicode/rep.h&quot;
 18 #include &quot;unicode/uniset.h&quot;
 19 #include &quot;rbt_pars.h&quot;
 20 #include &quot;rbt_data.h&quot;
 21 #include &quot;rbt_rule.h&quot;
 22 #include &quot;rbt.h&quot;
 23 #include &quot;mutex.h&quot;
 24 #include &quot;umutex.h&quot;
 25 
 26 U_NAMESPACE_BEGIN
 27 
 28 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(RuleBasedTransliterator)
 29 
<span class="line-removed"> 30 static UMutex transliteratorDataMutex = U_MUTEX_INITIALIZER;</span>
 31 static Replaceable *gLockedText = NULL;
 32 
 33 void RuleBasedTransliterator::_construct(const UnicodeString&amp; rules,
 34                                          UTransDirection direction,
 35                                          UParseError&amp; parseError,
 36                                          UErrorCode&amp; status) {
 37     fData = 0;
 38     isDataOwned = TRUE;
 39     if (U_FAILURE(status)) {
 40         return;
 41     }
 42 
 43     TransliteratorParser parser(status);
 44     parser.parse(rules, direction, parseError, status);
 45     if (U_FAILURE(status)) {
 46         return;
 47     }
 48 
 49     if (parser.idBlockVector.size() != 0 ||
 50         parser.compoundFilter != NULL ||
</pre>
<hr />
<pre>
236     }
237 
238     // Transliterator locking.  Rule-based Transliterators are not thread safe; concurrent
239     //   operations must be prevented.
240     // A Complication: compound transliterators can result in recursive entries to this
241     //   function, sometimes with different &quot;This&quot; objects, always with the same text.
242     //   Double-locking must be prevented in these cases.
243     //
244 
245     UBool    lockedMutexAtThisLevel = FALSE;
246 
247     // Test whether this request is operating on the same text string as
248     //   some other transliteration that is still in progress and holding the
249     //   transliteration mutex.  If so, do not lock the transliteration
250     //    mutex again.
251     //
252     //  gLockedText variable is protected by the global ICU mutex.
253     //  Shared RBT data protected by transliteratorDataMutex.
254     //
255     // TODO(andy): Need a better scheme for handling this.


256     UBool needToLock;
257     {
258         Mutex m;
259         needToLock = (&amp;text != gLockedText);
260     }
261     if (needToLock) {
262         umtx_lock(&amp;transliteratorDataMutex);  // Contention, longish waits possible here.
263         Mutex m;
264         gLockedText = &amp;text;
265         lockedMutexAtThisLevel = TRUE;
266     }
267 
268     // Check to make sure we don&#39;t dereference a null pointer.
269     if (fData != NULL) {
270         while (index.start &lt; index.limit &amp;&amp;
271                loopCount &lt;= loopLimit &amp;&amp;
272                fData-&gt;ruleSet.transliterate(text, index, isIncremental)) {
273             ++loopCount;
274         }
275     }
</pre>
</td>
<td>
<hr />
<pre>
 10 **********************************************************************
 11 */
 12 
 13 #include &quot;unicode/utypes.h&quot;
 14 
 15 #if !UCONFIG_NO_TRANSLITERATION
 16 
 17 #include &quot;unicode/rep.h&quot;
 18 #include &quot;unicode/uniset.h&quot;
 19 #include &quot;rbt_pars.h&quot;
 20 #include &quot;rbt_data.h&quot;
 21 #include &quot;rbt_rule.h&quot;
 22 #include &quot;rbt.h&quot;
 23 #include &quot;mutex.h&quot;
 24 #include &quot;umutex.h&quot;
 25 
 26 U_NAMESPACE_BEGIN
 27 
 28 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(RuleBasedTransliterator)
 29 

 30 static Replaceable *gLockedText = NULL;
 31 
 32 void RuleBasedTransliterator::_construct(const UnicodeString&amp; rules,
 33                                          UTransDirection direction,
 34                                          UParseError&amp; parseError,
 35                                          UErrorCode&amp; status) {
 36     fData = 0;
 37     isDataOwned = TRUE;
 38     if (U_FAILURE(status)) {
 39         return;
 40     }
 41 
 42     TransliteratorParser parser(status);
 43     parser.parse(rules, direction, parseError, status);
 44     if (U_FAILURE(status)) {
 45         return;
 46     }
 47 
 48     if (parser.idBlockVector.size() != 0 ||
 49         parser.compoundFilter != NULL ||
</pre>
<hr />
<pre>
235     }
236 
237     // Transliterator locking.  Rule-based Transliterators are not thread safe; concurrent
238     //   operations must be prevented.
239     // A Complication: compound transliterators can result in recursive entries to this
240     //   function, sometimes with different &quot;This&quot; objects, always with the same text.
241     //   Double-locking must be prevented in these cases.
242     //
243 
244     UBool    lockedMutexAtThisLevel = FALSE;
245 
246     // Test whether this request is operating on the same text string as
247     //   some other transliteration that is still in progress and holding the
248     //   transliteration mutex.  If so, do not lock the transliteration
249     //    mutex again.
250     //
251     //  gLockedText variable is protected by the global ICU mutex.
252     //  Shared RBT data protected by transliteratorDataMutex.
253     //
254     // TODO(andy): Need a better scheme for handling this.
<span class="line-added">255 </span>
<span class="line-added">256     static UMutex transliteratorDataMutex = U_MUTEX_INITIALIZER;</span>
257     UBool needToLock;
258     {
259         Mutex m;
260         needToLock = (&amp;text != gLockedText);
261     }
262     if (needToLock) {
263         umtx_lock(&amp;transliteratorDataMutex);  // Contention, longish waits possible here.
264         Mutex m;
265         gLockedText = &amp;text;
266         lockedMutexAtThisLevel = TRUE;
267     }
268 
269     // Check to make sure we don&#39;t dereference a null pointer.
270     if (fData != NULL) {
271         while (index.start &lt; index.limit &amp;&amp;
272                loopCount &lt;= loopLimit &amp;&amp;
273                fData-&gt;ruleSet.transliterate(text, index, isIncremental)) {
274             ++loopCount;
275         }
276     }
</pre>
</td>
</tr>
</table>
<center><a href="rbnf.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbt.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>