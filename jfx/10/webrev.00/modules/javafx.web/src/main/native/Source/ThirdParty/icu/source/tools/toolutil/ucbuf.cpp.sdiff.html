<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/ucbuf.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="toolutil.vcxproj.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ucmstate.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/ucbuf.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
161 /* fill the uchar buffer */
162 static UCHARBUF*
163 ucbuf_fillucbuf( UCHARBUF* buf,UErrorCode* error){
164     UChar* pTarget=NULL;
165     UChar* target=NULL;
166     const char* source=NULL;
167     char  carr[MAX_IN_BUF] = {&#39;\0&#39;};
168     char* cbuf =  carr;
169     int32_t inputRead=0;
170     int32_t outputWritten=0;
171     int32_t offset=0;
172     const char* sourceLimit =NULL;
173     int32_t cbufSize=0;
174     pTarget = buf-&gt;buffer;
175     /* check if we arrived here without exhausting the buffer*/
176     if(buf-&gt;currentPos&lt;buf-&gt;bufLimit){
177         offset = (int32_t)(buf-&gt;bufLimit-buf-&gt;currentPos);
178         memmove(buf-&gt;buffer,buf-&gt;currentPos,offset* sizeof(UChar));
179     }
180 
<span class="line-modified">181 #if UCBUF_DEBUG</span>
182     memset(pTarget+offset,0xff,sizeof(UChar)*(MAX_IN_BUF-offset));
183 #endif
184     if(buf-&gt;isBuffered){
185         cbufSize = MAX_IN_BUF;
186         /* read the file */
187         inputRead=T_FileStream_read(buf-&gt;in,cbuf,cbufSize-offset);
188         buf-&gt;remaining-=inputRead;
189 
190     }else{
191         cbufSize = T_FileStream_size(buf-&gt;in);
192         cbuf = (char*)uprv_malloc(cbufSize);
193         if (cbuf == NULL) {
194             *error = U_MEMORY_ALLOCATION_ERROR;
195             return NULL;
196         }
197         inputRead= T_FileStream_read(buf-&gt;in,cbuf,cbufSize);
198         buf-&gt;remaining-=inputRead;
199     }
200 
201     /* just to be sure...*/
</pre>
<hr />
<pre>
278              */
279             ucnv_setToUCallBack(buf-&gt;conv,
280                UCNV_TO_U_CALLBACK_SUBSTITUTE,
281                toUNewContext,
282                &amp;toUOldAction,
283                (const void**)&amp;toUOldContext,
284                &amp;error1);
285 
286             /* reset source and target start positions */
287             target = pTarget+offset;
288             source = cbuf;
289 
290             /* re convert */
291             ucnv_toUnicode(buf-&gt;conv,&amp;target,target+(buf-&gt;bufCapacity-offset),
292                             &amp;source,sourceLimit,NULL,
293                             (UBool)(buf-&gt;remaining==0),&amp;error1);
294 
295         }
296         outputWritten = (int32_t)(target - pTarget);
297 
<span class="line-modified">298 #if UCBUF_DEBUG</span>
299         {
300             int i;
301             target = pTarget;
302             for(i=0;i&lt;numRead;i++){
303               /*  printf(&quot;%c&quot;, (char)(*target++));*/
304             }
305         }
306 #endif
307 
308     }else{
309         u_charsToUChars(cbuf,target+offset,inputRead);
310         outputWritten=((buf-&gt;remaining&gt;cbufSize)? cbufSize:inputRead+offset);
311     }
312     buf-&gt;currentPos = pTarget;
313     buf-&gt;bufLimit=pTarget+outputWritten;
314     *buf-&gt;bufLimit=0; /*NUL terminate*/
315     if(cbuf!=carr){
316         uprv_free(cbuf);
317     }
318     return buf;
</pre>
</td>
<td>
<hr />
<pre>
161 /* fill the uchar buffer */
162 static UCHARBUF*
163 ucbuf_fillucbuf( UCHARBUF* buf,UErrorCode* error){
164     UChar* pTarget=NULL;
165     UChar* target=NULL;
166     const char* source=NULL;
167     char  carr[MAX_IN_BUF] = {&#39;\0&#39;};
168     char* cbuf =  carr;
169     int32_t inputRead=0;
170     int32_t outputWritten=0;
171     int32_t offset=0;
172     const char* sourceLimit =NULL;
173     int32_t cbufSize=0;
174     pTarget = buf-&gt;buffer;
175     /* check if we arrived here without exhausting the buffer*/
176     if(buf-&gt;currentPos&lt;buf-&gt;bufLimit){
177         offset = (int32_t)(buf-&gt;bufLimit-buf-&gt;currentPos);
178         memmove(buf-&gt;buffer,buf-&gt;currentPos,offset* sizeof(UChar));
179     }
180 
<span class="line-modified">181 #ifdef UCBUF_DEBUG</span>
182     memset(pTarget+offset,0xff,sizeof(UChar)*(MAX_IN_BUF-offset));
183 #endif
184     if(buf-&gt;isBuffered){
185         cbufSize = MAX_IN_BUF;
186         /* read the file */
187         inputRead=T_FileStream_read(buf-&gt;in,cbuf,cbufSize-offset);
188         buf-&gt;remaining-=inputRead;
189 
190     }else{
191         cbufSize = T_FileStream_size(buf-&gt;in);
192         cbuf = (char*)uprv_malloc(cbufSize);
193         if (cbuf == NULL) {
194             *error = U_MEMORY_ALLOCATION_ERROR;
195             return NULL;
196         }
197         inputRead= T_FileStream_read(buf-&gt;in,cbuf,cbufSize);
198         buf-&gt;remaining-=inputRead;
199     }
200 
201     /* just to be sure...*/
</pre>
<hr />
<pre>
278              */
279             ucnv_setToUCallBack(buf-&gt;conv,
280                UCNV_TO_U_CALLBACK_SUBSTITUTE,
281                toUNewContext,
282                &amp;toUOldAction,
283                (const void**)&amp;toUOldContext,
284                &amp;error1);
285 
286             /* reset source and target start positions */
287             target = pTarget+offset;
288             source = cbuf;
289 
290             /* re convert */
291             ucnv_toUnicode(buf-&gt;conv,&amp;target,target+(buf-&gt;bufCapacity-offset),
292                             &amp;source,sourceLimit,NULL,
293                             (UBool)(buf-&gt;remaining==0),&amp;error1);
294 
295         }
296         outputWritten = (int32_t)(target - pTarget);
297 
<span class="line-modified">298 #ifdef UCBUF_DEBUG</span>
299         {
300             int i;
301             target = pTarget;
302             for(i=0;i&lt;numRead;i++){
303               /*  printf(&quot;%c&quot;, (char)(*target++));*/
304             }
305         }
306 #endif
307 
308     }else{
309         u_charsToUChars(cbuf,target+offset,inputRead);
310         outputWritten=((buf-&gt;remaining&gt;cbufSize)? cbufSize:inputRead+offset);
311     }
312     buf-&gt;currentPos = pTarget;
313     buf-&gt;bufLimit=pTarget+outputWritten;
314     *buf-&gt;bufLimit=0; /*NUL terminate*/
315     if(cbuf!=carr){
316         uprv_free(cbuf);
317     }
318     return buf;
</pre>
</td>
</tr>
</table>
<center><a href="toolutil.vcxproj.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ucmstate.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>