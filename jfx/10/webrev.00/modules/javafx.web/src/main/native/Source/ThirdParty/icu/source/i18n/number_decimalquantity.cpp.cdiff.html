<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_decimalquantity.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_compact.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_decimalquantity.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_decimalquantity.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 110,86 ***</span>
      return *this;
  }
  
  void DecimalQuantity::copyFieldsFrom(const DecimalQuantity&amp; other) {
      bogus = other.bogus;
<span class="line-removed">-     lOptPos = other.lOptPos;</span>
      lReqPos = other.lReqPos;
      rReqPos = other.rReqPos;
<span class="line-removed">-     rOptPos = other.rOptPos;</span>
      scale = other.scale;
      precision = other.precision;
      flags = other.flags;
      origDouble = other.origDouble;
      origDelta = other.origDelta;
      isApproximate = other.isApproximate;
  }
  
  void DecimalQuantity::clear() {
<span class="line-removed">-     lOptPos = INT32_MAX;</span>
      lReqPos = 0;
      rReqPos = 0;
<span class="line-removed">-     rOptPos = INT32_MIN;</span>
      flags = 0;
      setBcdToZero(); // sets scale, precision, hasDouble, origDouble, origDelta, and BCD data
  }
  
<span class="line-modified">! void DecimalQuantity::setIntegerLength(int32_t minInt, int32_t maxInt) {</span>
      // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.
      U_ASSERT(minInt &gt;= 0);
<span class="line-removed">-     U_ASSERT(maxInt &gt;= minInt);</span>
  
      // Special behavior: do not set minInt to be less than what is already set.
      // This is so significant digits rounding can set the integer length.
      if (minInt &lt; lReqPos) {
          minInt = lReqPos;
      }
  
      // Save values into internal state
<span class="line-removed">-     // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE &gt; Integer.MIN_VALUE</span>
<span class="line-removed">-     lOptPos = maxInt;</span>
      lReqPos = minInt;
  }
  
<span class="line-modified">! void DecimalQuantity::setFractionLength(int32_t minFrac, int32_t maxFrac) {</span>
      // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.
      U_ASSERT(minFrac &gt;= 0);
<span class="line-removed">-     U_ASSERT(maxFrac &gt;= minFrac);</span>
  
      // Save values into internal state
      // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE &gt; Integer.MIN_VALUE
      rReqPos = -minFrac;
<span class="line-modified">!     rOptPos = -maxFrac;</span>
  }
  
  uint64_t DecimalQuantity::getPositionFingerprint() const {
      uint64_t fingerprint = 0;
<span class="line-removed">-     fingerprint ^= lOptPos;</span>
      fingerprint ^= (lReqPos &lt;&lt; 16);
      fingerprint ^= (static_cast&lt;uint64_t&gt;(rReqPos) &lt;&lt; 32);
<span class="line-removed">-     fingerprint ^= (static_cast&lt;uint64_t&gt;(rOptPos) &lt;&lt; 48);</span>
      return fingerprint;
  }
  
  void DecimalQuantity::roundToIncrement(double roundingIncrement, RoundingMode roundingMode,
<span class="line-modified">!                                        int32_t maxFrac, UErrorCode&amp; status) {</span>
<span class="line-modified">!     // TODO(13701): This is innefficient.  Improve?</span>
<span class="line-modified">!     // TODO(13701): Should we convert to decNumber instead?</span>
<span class="line-modified">!     roundToInfinity();</span>
<span class="line-modified">!     double temp = toDouble();</span>
<span class="line-modified">!     temp /= roundingIncrement;</span>
<span class="line-modified">!     // Use another DecimalQuantity to perform the actual rounding...</span>
<span class="line-modified">!     DecimalQuantity dq;</span>
<span class="line-modified">!     dq.setToDouble(temp);</span>
<span class="line-modified">!     dq.roundToMagnitude(0, roundingMode, status);</span>
<span class="line-modified">!     temp = dq.toDouble();</span>
<span class="line-modified">!     temp *= roundingIncrement;</span>
<span class="line-modified">!     setToDouble(temp);</span>
<span class="line-modified">!     // Since we reset the value to a double, we need to specify the rounding boundary</span>
<span class="line-modified">!     // in order to get the DecimalQuantity out of approximation mode.</span>
<span class="line-modified">!     // NOTE: In Java, we have minMaxFrac, but in C++, the two are differentiated.</span>
<span class="line-modified">!     roundToMagnitude(-maxFrac, roundingMode, status);</span>
  }
  
  void DecimalQuantity::multiplyBy(const DecNum&amp; multiplicand, UErrorCode&amp; status) {
      if (isInfinite() || isZero() || isNaN()) {
          return;
<span class="line-new-header">--- 110,100 ---</span>
      return *this;
  }
  
  void DecimalQuantity::copyFieldsFrom(const DecimalQuantity&amp; other) {
      bogus = other.bogus;
      lReqPos = other.lReqPos;
      rReqPos = other.rReqPos;
      scale = other.scale;
      precision = other.precision;
      flags = other.flags;
      origDouble = other.origDouble;
      origDelta = other.origDelta;
      isApproximate = other.isApproximate;
  }
  
  void DecimalQuantity::clear() {
      lReqPos = 0;
      rReqPos = 0;
      flags = 0;
      setBcdToZero(); // sets scale, precision, hasDouble, origDouble, origDelta, and BCD data
  }
  
<span class="line-modified">! void DecimalQuantity::setMinInteger(int32_t minInt) {</span>
      // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.
      U_ASSERT(minInt &gt;= 0);
  
      // Special behavior: do not set minInt to be less than what is already set.
      // This is so significant digits rounding can set the integer length.
      if (minInt &lt; lReqPos) {
          minInt = lReqPos;
      }
  
      // Save values into internal state
      lReqPos = minInt;
  }
  
<span class="line-modified">! void DecimalQuantity::setMinFraction(int32_t minFrac) {</span>
      // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.
      U_ASSERT(minFrac &gt;= 0);
  
      // Save values into internal state
      // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE &gt; Integer.MIN_VALUE
      rReqPos = -minFrac;
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void DecimalQuantity::applyMaxInteger(int32_t maxInt) {</span>
<span class="line-added">+     // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.</span>
<span class="line-added">+     U_ASSERT(maxInt &gt;= 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (precision == 0) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (maxInt &lt;= scale) {</span>
<span class="line-added">+         setBcdToZero();</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     int32_t magnitude = getMagnitude();</span>
<span class="line-added">+     if (maxInt &lt;= magnitude) {</span>
<span class="line-added">+         popFromLeft(magnitude - maxInt + 1);</span>
<span class="line-added">+         compact();</span>
<span class="line-added">+     }</span>
  }
  
  uint64_t DecimalQuantity::getPositionFingerprint() const {
      uint64_t fingerprint = 0;
      fingerprint ^= (lReqPos &lt;&lt; 16);
      fingerprint ^= (static_cast&lt;uint64_t&gt;(rReqPos) &lt;&lt; 32);
      return fingerprint;
  }
  
  void DecimalQuantity::roundToIncrement(double roundingIncrement, RoundingMode roundingMode,
<span class="line-modified">!                                        UErrorCode&amp; status) {</span>
<span class="line-modified">!     // Do not call this method with an increment having only a 1 or a 5 digit!</span>
<span class="line-modified">!     // Use a more efficient call to either roundToMagnitude() or roundToNickel().</span>
<span class="line-modified">!     // Check a few popular rounding increments; a more thorough check is in Java.</span>
<span class="line-modified">!     U_ASSERT(roundingIncrement != 0.01);</span>
<span class="line-modified">!     U_ASSERT(roundingIncrement != 0.05);</span>
<span class="line-modified">!     U_ASSERT(roundingIncrement != 0.1);</span>
<span class="line-modified">!     U_ASSERT(roundingIncrement != 0.5);</span>
<span class="line-modified">!     U_ASSERT(roundingIncrement != 1);</span>
<span class="line-modified">!     U_ASSERT(roundingIncrement != 5);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     DecNum incrementDN;</span>
<span class="line-modified">!     incrementDN.setTo(roundingIncrement, status);</span>
<span class="line-modified">!     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Divide this DecimalQuantity by the increment, round, then multiply back.</span>
<span class="line-modified">!     divideBy(incrementDN, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">+     roundToMagnitude(0, roundingMode, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">+     multiplyBy(incrementDN, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
  }
  
  void DecimalQuantity::multiplyBy(const DecNum&amp; multiplicand, UErrorCode&amp; status) {
      if (isInfinite() || isZero() || isNaN()) {
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,21 ***</span>
      // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
      // See the comment in the header file explaining the &quot;isApproximate&quot; field.
      U_ASSERT(!isApproximate);
  
      int32_t magnitude = scale + precision;
<span class="line-modified">!     int32_t result = (lReqPos &gt; magnitude) ? lReqPos : (lOptPos &lt; magnitude) ? lOptPos : magnitude;</span>
      return result - 1;
  }
  
  int32_t DecimalQuantity::getLowerDisplayMagnitude() const {
      // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
      // See the comment in the header file explaining the &quot;isApproximate&quot; field.
      U_ASSERT(!isApproximate);
  
      int32_t magnitude = scale;
<span class="line-modified">!     int32_t result = (rReqPos &lt; magnitude) ? rReqPos : (rOptPos &gt; magnitude) ? rOptPos : magnitude;</span>
      return result;
  }
  
  int8_t DecimalQuantity::getDigit(int32_t magnitude) const {
      // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
<span class="line-new-header">--- 282,21 ---</span>
      // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
      // See the comment in the header file explaining the &quot;isApproximate&quot; field.
      U_ASSERT(!isApproximate);
  
      int32_t magnitude = scale + precision;
<span class="line-modified">!     int32_t result = (lReqPos &gt; magnitude) ? lReqPos : magnitude;</span>
      return result - 1;
  }
  
  int32_t DecimalQuantity::getLowerDisplayMagnitude() const {
      // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
      // See the comment in the header file explaining the &quot;isApproximate&quot; field.
      U_ASSERT(!isApproximate);
  
      int32_t magnitude = scale;
<span class="line-modified">!     int32_t result = (rReqPos &lt; magnitude) ? rReqPos : magnitude;</span>
      return result;
  }
  
  int8_t DecimalQuantity::getDigit(int32_t magnitude) const {
      // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,11 ***</span>
  int64_t DecimalQuantity::toLong(bool truncateIfOverflow) const {
      // NOTE: Call sites should be guarded by fitsInLong(), like this:
      // if (dq.fitsInLong()) { /* use dq.toLong() */ } else { /* use some fallback */ }
      // Fallback behavior upon truncateIfOverflow is to truncate at 17 digits.
      uint64_t result = 0L;
<span class="line-modified">!     int32_t upperMagnitude = std::min(scale + precision, lOptPos) - 1;</span>
      if (truncateIfOverflow) {
          upperMagnitude = std::min(upperMagnitude, 17);
      }
      for (int32_t magnitude = upperMagnitude; magnitude &gt;= 0; magnitude--) {
          result = result * 10 + getDigitPos(magnitude - scale);
<span class="line-new-header">--- 513,11 ---</span>
  int64_t DecimalQuantity::toLong(bool truncateIfOverflow) const {
      // NOTE: Call sites should be guarded by fitsInLong(), like this:
      // if (dq.fitsInLong()) { /* use dq.toLong() */ } else { /* use some fallback */ }
      // Fallback behavior upon truncateIfOverflow is to truncate at 17 digits.
      uint64_t result = 0L;
<span class="line-modified">!     int32_t upperMagnitude = scale + precision - 1;</span>
      if (truncateIfOverflow) {
          upperMagnitude = std::min(upperMagnitude, 17);
      }
      for (int32_t magnitude = upperMagnitude; magnitude &gt;= 0; magnitude--) {
          result = result * 10 + getDigitPos(magnitude - scale);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 515,11 ***</span>
  }
  
  uint64_t DecimalQuantity::toFractionLong(bool includeTrailingZeros) const {
      uint64_t result = 0L;
      int32_t magnitude = -1;
<span class="line-modified">!     int32_t lowerMagnitude = std::max(scale, rOptPos);</span>
      if (includeTrailingZeros) {
          lowerMagnitude = std::min(lowerMagnitude, rReqPos);
      }
      for (; magnitude &gt;= lowerMagnitude &amp;&amp; result &lt;= 1e18L; magnitude--) {
          result = result * 10 + getDigitPos(magnitude - scale);
<span class="line-new-header">--- 529,11 ---</span>
  }
  
  uint64_t DecimalQuantity::toFractionLong(bool includeTrailingZeros) const {
      uint64_t result = 0L;
      int32_t magnitude = -1;
<span class="line-modified">!     int32_t lowerMagnitude = scale;</span>
      if (includeTrailingZeros) {
          lowerMagnitude = std::min(lowerMagnitude, rReqPos);
      }
      for (; magnitude &gt;= lowerMagnitude &amp;&amp; result &lt;= 1e18L; magnitude--) {
          result = result * 10 + getDigitPos(magnitude - scale);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 604,113 ***</span>
          scale = 0;
          compact();
      }
  }
  
  void DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, UErrorCode&amp; status) {
      // The position in the BCD at which rounding will be performed; digits to the right of position
      // will be rounded away.
<span class="line-removed">-     // TODO: Andy: There was a test failure because of integer overflow here. Should I do</span>
<span class="line-removed">-     // &quot;safe subtraction&quot; everywhere in the code?  What&#39;s the nicest way to do it?</span>
      int position = safeSubtract(magnitude, scale);
  
<span class="line-modified">!     if (position &lt;= 0 &amp;&amp; !isApproximate) {</span>
          // All digits are to the left of the rounding magnitude.
      } else if (precision == 0) {
          // No rounding for zero.
      } else {
          // Perform rounding logic.
          // &quot;leading&quot; = most significant digit to the right of rounding
<span class="line-removed">-         // &quot;trailing&quot; = least significant digit to the left of rounding</span>
          int8_t leadingDigit = getDigitPos(safeSubtract(position, 1));
<span class="line-removed">-         int8_t trailingDigit = getDigitPos(position);</span>
  
          // Compute which section of the number we are in.
          // EDGE means we are at the bottom or top edge, like 1.000 or 1.999 (used by doubles)
          // LOWER means we are between the bottom edge and the midpoint, like 1.391
          // MIDPOINT means we are exactly in the middle, like 1.500
          // UPPER means we are between the midpoint and the top edge, like 1.916
<span class="line-modified">!         roundingutils::Section section = roundingutils::SECTION_MIDPOINT;</span>
          if (!isApproximate) {
<span class="line-modified">!             if (leadingDigit &lt; 5) {</span>
                  section = roundingutils::SECTION_LOWER;
              } else if (leadingDigit &gt; 5) {
                  section = roundingutils::SECTION_UPPER;
              } else {
                  for (int p = safeSubtract(position, 2); p &gt;= 0; p--) {
                      if (getDigitPos(p) != 0) {
                          section = roundingutils::SECTION_UPPER;
                          break;
                      }
                  }
              }
          } else {
              int32_t p = safeSubtract(position, 2);
              int32_t minP = uprv_max(0, precision - 14);
<span class="line-modified">!             if (leadingDigit == 0) {</span>
                  section = roundingutils::SECTION_LOWER_EDGE;
                  for (; p &gt;= minP; p--) {
                      if (getDigitPos(p) != 0) {
                          section = roundingutils::SECTION_LOWER;
                          break;
                      }
                  }
<span class="line-modified">!             } else if (leadingDigit == 4) {</span>
                  for (; p &gt;= minP; p--) {
                      if (getDigitPos(p) != 9) {
                          section = roundingutils::SECTION_LOWER;
                          break;
                      }
                  }
<span class="line-modified">!             } else if (leadingDigit == 5) {</span>
                  for (; p &gt;= minP; p--) {
                      if (getDigitPos(p) != 0) {
                          section = roundingutils::SECTION_UPPER;
                          break;
                      }
                  }
<span class="line-modified">!             } else if (leadingDigit == 9) {</span>
                  section = roundingutils::SECTION_UPPER_EDGE;
                  for (; p &gt;= minP; p--) {
                      if (getDigitPos(p) != 9) {
                          section = roundingutils::SECTION_UPPER;
                          break;
                      }
                  }
              } else if (leadingDigit &lt; 5) {
                  section = roundingutils::SECTION_LOWER;
              } else {
                  section = roundingutils::SECTION_UPPER;
              }
  
              bool roundsAtMidpoint = roundingutils::roundsAtMidpoint(roundingMode);
              if (safeSubtract(position, 1) &lt; precision - 14 ||
                  (roundsAtMidpoint &amp;&amp; section == roundingutils::SECTION_MIDPOINT) ||
                  (!roundsAtMidpoint &amp;&amp; section &lt; 0 /* i.e. at upper or lower edge */)) {
<span class="line-modified">!                 // Oops! This means that we have to get the exact representation of the double, because</span>
<span class="line-modified">!                 // the zone of uncertainty is along the rounding boundary.</span>
                  convertToAccurateDouble();
<span class="line-modified">!                 roundToMagnitude(magnitude, roundingMode, status); // start over</span>
                  return;
              }
  
              // Turn off the approximate double flag, since the value is now confirmed to be exact.
              isApproximate = false;
              origDouble = 0.0;
              origDelta = 0;
  
<span class="line-modified">!             if (position &lt;= 0) {</span>
                  // All digits are to the left of the rounding magnitude.
                  return;
              }
  
              // Good to continue rounding.
              if (section == -1) { section = roundingutils::SECTION_LOWER; }
              if (section == -2) { section = roundingutils::SECTION_UPPER; }
          }
  
<span class="line-modified">!         bool roundDown = roundingutils::getRoundingDirection((trailingDigit % 2) == 0,</span>
                  isNegative(),
                  section,
                  roundingMode,
                  status);
          if (U_FAILURE(status)) {
<span class="line-new-header">--- 618,165 ---</span>
          scale = 0;
          compact();
      }
  }
  
<span class="line-added">+ void DecimalQuantity::roundToNickel(int32_t magnitude, RoundingMode roundingMode, UErrorCode&amp; status) {</span>
<span class="line-added">+     roundToMagnitude(magnitude, roundingMode, true, status);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, UErrorCode&amp; status) {
<span class="line-added">+     roundToMagnitude(magnitude, roundingMode, false, status);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, bool nickel, UErrorCode&amp; status) {</span>
      // The position in the BCD at which rounding will be performed; digits to the right of position
      // will be rounded away.
      int position = safeSubtract(magnitude, scale);
  
<span class="line-modified">!     // &quot;trailing&quot; = least significant digit to the left of rounding</span>
<span class="line-added">+     int8_t trailingDigit = getDigitPos(position);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (position &lt;= 0 &amp;&amp; !isApproximate &amp;&amp; (!nickel || trailingDigit == 0 || trailingDigit == 5)) {</span>
          // All digits are to the left of the rounding magnitude.
      } else if (precision == 0) {
          // No rounding for zero.
      } else {
          // Perform rounding logic.
          // &quot;leading&quot; = most significant digit to the right of rounding
          int8_t leadingDigit = getDigitPos(safeSubtract(position, 1));
  
          // Compute which section of the number we are in.
          // EDGE means we are at the bottom or top edge, like 1.000 or 1.999 (used by doubles)
          // LOWER means we are between the bottom edge and the midpoint, like 1.391
          // MIDPOINT means we are exactly in the middle, like 1.500
          // UPPER means we are between the midpoint and the top edge, like 1.916
<span class="line-modified">!         roundingutils::Section section;</span>
          if (!isApproximate) {
<span class="line-modified">!             if (nickel &amp;&amp; trailingDigit != 2 &amp;&amp; trailingDigit != 7) {</span>
<span class="line-added">+                 // Nickel rounding, and not at .02x or .07x</span>
<span class="line-added">+                 if (trailingDigit &lt; 2) {</span>
<span class="line-added">+                     // .00, .01 =&gt; down to .00</span>
<span class="line-added">+                     section = roundingutils::SECTION_LOWER;</span>
<span class="line-added">+                 } else if (trailingDigit &lt; 5) {</span>
<span class="line-added">+                     // .03, .04 =&gt; up to .05</span>
<span class="line-added">+                     section = roundingutils::SECTION_UPPER;</span>
<span class="line-added">+                 } else if (trailingDigit &lt; 7) {</span>
<span class="line-added">+                     // .05, .06 =&gt; down to .05</span>
<span class="line-added">+                     section = roundingutils::SECTION_LOWER;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // .08, .09 =&gt; up to .10</span>
<span class="line-added">+                     section = roundingutils::SECTION_UPPER;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else if (leadingDigit &lt; 5) {</span>
<span class="line-added">+                 // Includes nickel rounding .020-.024 and .070-.074</span>
                  section = roundingutils::SECTION_LOWER;
              } else if (leadingDigit &gt; 5) {
<span class="line-added">+                 // Includes nickel rounding .026-.029 and .076-.079</span>
                  section = roundingutils::SECTION_UPPER;
              } else {
<span class="line-added">+                 // Includes nickel rounding .025 and .075</span>
<span class="line-added">+                 section = roundingutils::SECTION_MIDPOINT;</span>
                  for (int p = safeSubtract(position, 2); p &gt;= 0; p--) {
                      if (getDigitPos(p) != 0) {
                          section = roundingutils::SECTION_UPPER;
                          break;
                      }
                  }
              }
          } else {
              int32_t p = safeSubtract(position, 2);
              int32_t minP = uprv_max(0, precision - 14);
<span class="line-modified">!             if (leadingDigit == 0 &amp;&amp; (!nickel || trailingDigit == 0 || trailingDigit == 5)) {</span>
                  section = roundingutils::SECTION_LOWER_EDGE;
                  for (; p &gt;= minP; p--) {
                      if (getDigitPos(p) != 0) {
                          section = roundingutils::SECTION_LOWER;
                          break;
                      }
                  }
<span class="line-modified">!             } else if (leadingDigit == 4 &amp;&amp; (!nickel || trailingDigit == 2 || trailingDigit == 7)) {</span>
<span class="line-added">+                 section = roundingutils::SECTION_MIDPOINT;</span>
                  for (; p &gt;= minP; p--) {
                      if (getDigitPos(p) != 9) {
                          section = roundingutils::SECTION_LOWER;
                          break;
                      }
                  }
<span class="line-modified">!             } else if (leadingDigit == 5 &amp;&amp; (!nickel || trailingDigit == 2 || trailingDigit == 7)) {</span>
<span class="line-added">+                 section = roundingutils::SECTION_MIDPOINT;</span>
                  for (; p &gt;= minP; p--) {
                      if (getDigitPos(p) != 0) {
                          section = roundingutils::SECTION_UPPER;
                          break;
                      }
                  }
<span class="line-modified">!             } else if (leadingDigit == 9 &amp;&amp; (!nickel || trailingDigit == 4 || trailingDigit == 9)) {</span>
                  section = roundingutils::SECTION_UPPER_EDGE;
                  for (; p &gt;= minP; p--) {
                      if (getDigitPos(p) != 9) {
                          section = roundingutils::SECTION_UPPER;
                          break;
                      }
                  }
<span class="line-added">+             } else if (nickel &amp;&amp; trailingDigit != 2 &amp;&amp; trailingDigit != 7) {</span>
<span class="line-added">+                 // Nickel rounding, and not at .02x or .07x</span>
<span class="line-added">+                 if (trailingDigit &lt; 2) {</span>
<span class="line-added">+                     // .00, .01 =&gt; down to .00</span>
<span class="line-added">+                     section = roundingutils::SECTION_LOWER;</span>
<span class="line-added">+                 } else if (trailingDigit &lt; 5) {</span>
<span class="line-added">+                     // .03, .04 =&gt; up to .05</span>
<span class="line-added">+                     section = roundingutils::SECTION_UPPER;</span>
<span class="line-added">+                 } else if (trailingDigit &lt; 7) {</span>
<span class="line-added">+                     // .05, .06 =&gt; down to .05</span>
<span class="line-added">+                     section = roundingutils::SECTION_LOWER;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // .08, .09 =&gt; up to .10</span>
<span class="line-added">+                     section = roundingutils::SECTION_UPPER;</span>
<span class="line-added">+                 }</span>
              } else if (leadingDigit &lt; 5) {
<span class="line-added">+                 // Includes nickel rounding .020-.024 and .070-.074</span>
                  section = roundingutils::SECTION_LOWER;
              } else {
<span class="line-added">+                 // Includes nickel rounding .026-.029 and .076-.079</span>
                  section = roundingutils::SECTION_UPPER;
              }
  
              bool roundsAtMidpoint = roundingutils::roundsAtMidpoint(roundingMode);
              if (safeSubtract(position, 1) &lt; precision - 14 ||
                  (roundsAtMidpoint &amp;&amp; section == roundingutils::SECTION_MIDPOINT) ||
                  (!roundsAtMidpoint &amp;&amp; section &lt; 0 /* i.e. at upper or lower edge */)) {
<span class="line-modified">!                 // Oops! This means that we have to get the exact representation of the double,</span>
<span class="line-modified">!                 // because the zone of uncertainty is along the rounding boundary.</span>
                  convertToAccurateDouble();
<span class="line-modified">!                 roundToMagnitude(magnitude, roundingMode, nickel, status); // start over</span>
                  return;
              }
  
              // Turn off the approximate double flag, since the value is now confirmed to be exact.
              isApproximate = false;
              origDouble = 0.0;
              origDelta = 0;
  
<span class="line-modified">!             if (position &lt;= 0 &amp;&amp; (!nickel || trailingDigit == 0 || trailingDigit == 5)) {</span>
                  // All digits are to the left of the rounding magnitude.
                  return;
              }
  
              // Good to continue rounding.
              if (section == -1) { section = roundingutils::SECTION_LOWER; }
              if (section == -2) { section = roundingutils::SECTION_UPPER; }
          }
  
<span class="line-modified">!         // Nickel rounding &quot;half even&quot; goes to the nearest whole (away from the 5).</span>
<span class="line-added">+         bool isEven = nickel</span>
<span class="line-added">+                 ? (trailingDigit &lt; 2 || trailingDigit &gt; 7</span>
<span class="line-added">+                         || (trailingDigit == 2 &amp;&amp; section != roundingutils::SECTION_UPPER)</span>
<span class="line-added">+                         || (trailingDigit == 7 &amp;&amp; section == roundingutils::SECTION_UPPER))</span>
<span class="line-added">+                 : (trailingDigit % 2) == 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         bool roundDown = roundingutils::getRoundingDirection(isEven,</span>
                  isNegative(),
                  section,
                  roundingMode,
                  status);
          if (U_FAILURE(status)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 723,16 ***</span>
              scale = magnitude;
          } else {
              shiftRight(position);
          }
  
          // Bubble the result to the higher digits
          if (!roundDown) {
              if (trailingDigit == 9) {
                  int bubblePos = 0;
<span class="line-modified">!                 // Note: in the long implementation, the most digits BCD can have at this point is 15,</span>
<span class="line-modified">!                 // so bubblePos &lt;= 15 and getDigitPos(bubblePos) is safe.</span>
                  for (; getDigitPos(bubblePos) == 9; bubblePos++) {}
                  shiftRight(bubblePos); // shift off the trailing 9s
              }
              int8_t digit0 = getDigitPos(0);
              U_ASSERT(digit0 != 9);
<span class="line-new-header">--- 789,32 ---</span>
              scale = magnitude;
          } else {
              shiftRight(position);
          }
  
<span class="line-added">+         if (nickel) {</span>
<span class="line-added">+             if (trailingDigit &lt; 5 &amp;&amp; roundDown) {</span>
<span class="line-added">+                 setDigitPos(0, 0);</span>
<span class="line-added">+                 compact();</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             } else if (trailingDigit &gt;= 5 &amp;&amp; !roundDown) {</span>
<span class="line-added">+                 setDigitPos(0, 9);</span>
<span class="line-added">+                 trailingDigit = 9;</span>
<span class="line-added">+                 // do not return: use the bubbling logic below</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 setDigitPos(0, 5);</span>
<span class="line-added">+                 // compact not necessary: digit at position 0 is nonzero</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // Bubble the result to the higher digits
          if (!roundDown) {
              if (trailingDigit == 9) {
                  int bubblePos = 0;
<span class="line-modified">!                 // Note: in the long implementation, the most digits BCD can have at this point is</span>
<span class="line-modified">!                 // 15, so bubblePos &lt;= 15 and getDigitPos(bubblePos) is safe.</span>
                  for (; getDigitPos(bubblePos) == 9; bubblePos++) {}
                  shiftRight(bubblePos); // shift off the trailing 9s
              }
              int8_t digit0 = getDigitPos(0);
              U_ASSERT(digit0 != 9);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 804,25 ***</span>
      }
      if (precision == 0) {
          result.append(u&quot;0E+0&quot;, -1);
          return result;
      }
<span class="line-modified">!     // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from</span>
<span class="line-modified">!     // rOptPos (aka -maxFrac) due to overflow.</span>
<span class="line-removed">-     int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;</span>
<span class="line-removed">-     int32_t lowerPos = std::max(scale, rOptPos) - scale;</span>
      int32_t p = upperPos;
      result.append(u&#39;0&#39; + getDigitPos(p));
      if ((--p) &gt;= lowerPos) {
          result.append(u&#39;.&#39;);
          for (; p &gt;= lowerPos; p--) {
              result.append(u&#39;0&#39; + getDigitPos(p));
          }
      }
      result.append(u&#39;E&#39;);
      int32_t _scale = upperPos + scale;
<span class="line-modified">!     if (_scale &lt; 0) {</span>
          _scale *= -1;
          result.append(u&#39;-&#39;);
      } else {
          result.append(u&#39;+&#39;);
      }
<span class="line-new-header">--- 886,26 ---</span>
      }
      if (precision == 0) {
          result.append(u&quot;0E+0&quot;, -1);
          return result;
      }
<span class="line-modified">!     int32_t upperPos = precision - 1;</span>
<span class="line-modified">!     int32_t lowerPos = 0;</span>
      int32_t p = upperPos;
      result.append(u&#39;0&#39; + getDigitPos(p));
      if ((--p) &gt;= lowerPos) {
          result.append(u&#39;.&#39;);
          for (; p &gt;= lowerPos; p--) {
              result.append(u&#39;0&#39; + getDigitPos(p));
          }
      }
      result.append(u&#39;E&#39;);
      int32_t _scale = upperPos + scale;
<span class="line-modified">!     if (_scale == INT32_MIN) {</span>
<span class="line-added">+         result.append({u&quot;-2147483648&quot;, -1});</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     } else if (_scale &lt; 0) {</span>
          _scale *= -1;
          result.append(u&#39;-&#39;);
      } else {
          result.append(u&#39;+&#39;);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 902,10 ***</span>
<span class="line-new-header">--- 985,23 ---</span>
      }
      scale += numDigits;
      precision -= numDigits;
  }
  
<span class="line-added">+ void DecimalQuantity::popFromLeft(int32_t numDigits) {</span>
<span class="line-added">+     U_ASSERT(numDigits &lt;= precision);</span>
<span class="line-added">+     if (usingBytes) {</span>
<span class="line-added">+         int i = precision - 1;</span>
<span class="line-added">+         for (; i &gt;= precision - numDigits; i--) {</span>
<span class="line-added">+             fBCD.bcdBytes.ptr[i] = 0;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         fBCD.bcdLong &amp;= (static_cast&lt;uint64_t&gt;(1) &lt;&lt; ((precision - numDigits) * 4)) - 1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     precision -= numDigits;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void DecimalQuantity::setBcdToZero() {
      if (usingBytes) {
          uprv_free(fBCD.bcdBytes.ptr);
          fBCD.bcdBytes.ptr = nullptr;
          usingBytes = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1152,12 ***</span>
      // No error
      return nullptr;
  }
  
  bool DecimalQuantity::operator==(const DecimalQuantity&amp; other) const {
<span class="line-modified">!     // FIXME: Make a faster implementation.</span>
<span class="line-modified">!     return toString() == other.toString();</span>
  }
  
  UnicodeString DecimalQuantity::toString() const {
      MaybeStackArray&lt;char, 30&gt; digits(precision + 1);
      for (int32_t i = 0; i &lt; precision; i++) {
<span class="line-new-header">--- 1248,33 ---</span>
      // No error
      return nullptr;
  }
  
  bool DecimalQuantity::operator==(const DecimalQuantity&amp; other) const {
<span class="line-modified">!     bool basicEquals =</span>
<span class="line-modified">!             scale == other.scale</span>
<span class="line-added">+             &amp;&amp; precision == other.precision</span>
<span class="line-added">+             &amp;&amp; flags == other.flags</span>
<span class="line-added">+             &amp;&amp; lReqPos == other.lReqPos</span>
<span class="line-added">+             &amp;&amp; rReqPos == other.rReqPos</span>
<span class="line-added">+             &amp;&amp; isApproximate == other.isApproximate;</span>
<span class="line-added">+     if (!basicEquals) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (precision == 0) {</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     } else if (isApproximate) {</span>
<span class="line-added">+         return origDouble == other.origDouble &amp;&amp; origDelta == other.origDelta;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         for (int m = getUpperDisplayMagnitude(); m &gt;= getLowerDisplayMagnitude(); m--) {</span>
<span class="line-added">+             if (getDigit(m) != other.getDigit(m)) {</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
  }
  
  UnicodeString DecimalQuantity::toString() const {
      MaybeStackArray&lt;char, 30&gt; digits(precision + 1);
      for (int32_t i = 0; i &lt; precision; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1166,15 ***</span>
      digits[precision] = 0; // terminate buffer
      char buffer8[100];
      snprintf(
              buffer8,
              sizeof(buffer8),
<span class="line-modified">!             &quot;&lt;DecimalQuantity %d:%d:%d:%d %s %s%s%s%d&gt;&quot;,</span>
<span class="line-removed">-             (lOptPos &gt; 999 ? 999 : lOptPos),</span>
              lReqPos,
              rReqPos,
<span class="line-removed">-             (rOptPos &lt; -999 ? -999 : rOptPos),</span>
              (usingBytes ? &quot;bytes&quot; : &quot;long&quot;),
              (isNegative() ? &quot;-&quot; : &quot;&quot;),
              (precision == 0 ? &quot;0&quot; : digits.getAlias()),
              &quot;E&quot;,
              scale);
<span class="line-new-header">--- 1283,13 ---</span>
      digits[precision] = 0; // terminate buffer
      char buffer8[100];
      snprintf(
              buffer8,
              sizeof(buffer8),
<span class="line-modified">!             &quot;&lt;DecimalQuantity %d:%d %s %s%s%s%d&gt;&quot;,</span>
              lReqPos,
              rReqPos,
              (usingBytes ? &quot;bytes&quot; : &quot;long&quot;),
              (isNegative() ? &quot;-&quot; : &quot;&quot;),
              (precision == 0 ? &quot;0&quot; : digits.getAlias()),
              &quot;E&quot;,
              scale);
</pre>
<center><a href="number_compact.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_decimalquantity.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>