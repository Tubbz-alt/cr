<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/unistr.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 1998-2016, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 *
   9 * File unistr.h
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   09/25/98    stephen     Creation.
  15 *   11/11/98    stephen     Changed per 11/9 code review.
  16 *   04/20/99    stephen     Overhauled per 4/16 code review.
  17 *   11/18/99    aliu        Made to inherit from Replaceable.  Added method
  18 *                           handleReplaceBetween(); other methods unchanged.
  19 *   06/25/01    grhoten     Remove dependency on iostream.
  20 ******************************************************************************
  21 */
  22 
  23 #ifndef UNISTR_H
  24 #define UNISTR_H
  25 
  26 /**
  27  * \file
  28  * \brief C++ API: Unicode String
  29  */
  30 
  31 #include &lt;cstddef&gt;
  32 #include &quot;unicode/utypes.h&quot;
  33 #include &quot;unicode/char16ptr.h&quot;
  34 #include &quot;unicode/rep.h&quot;
  35 #include &quot;unicode/std_string.h&quot;
  36 #include &quot;unicode/stringpiece.h&quot;
  37 #include &quot;unicode/bytestream.h&quot;
  38 
  39 struct UConverter;          // unicode/ucnv.h
  40 
  41 #ifndef USTRING_H
  42 /**
  43  * \ingroup ustring_ustrlen
  44  */
  45 U_STABLE int32_t U_EXPORT2
  46 u_strlen(const UChar *s);
  47 #endif
  48 
  49 U_NAMESPACE_BEGIN
  50 
  51 #if !UCONFIG_NO_BREAK_ITERATION
  52 class BreakIterator;        // unicode/brkiter.h
  53 #endif
  54 class Edits;
  55 
  56 U_NAMESPACE_END
  57 
  58 // Not #ifndef U_HIDE_INTERNAL_API because UnicodeString needs the UStringCaseMapper.
  59 /**
  60  * Internal string case mapping function type.
  61  * All error checking must be done.
  62  * src and dest must not overlap.
  63  * @internal
  64  */
  65 typedef int32_t U_CALLCONV
  66 UStringCaseMapper(int32_t caseLocale, uint32_t options,
  67 #if !UCONFIG_NO_BREAK_ITERATION
  68                   icu::BreakIterator *iter,
  69 #endif
  70                   char16_t *dest, int32_t destCapacity,
  71                   const char16_t *src, int32_t srcLength,
  72                   icu::Edits *edits,
  73                   UErrorCode &amp;errorCode);
  74 
  75 U_NAMESPACE_BEGIN
  76 
  77 class Locale;               // unicode/locid.h
  78 class StringCharacterIterator;
  79 class UnicodeStringAppendable;  // unicode/appendable.h
  80 
  81 /* The &lt;iostream&gt; include has been moved to unicode/ustream.h */
  82 
  83 /**
  84  * Constant to be used in the UnicodeString(char *, int32_t, EInvariant) constructor
  85  * which constructs a Unicode string from an invariant-character char * string.
  86  * About invariant characters see utypes.h.
  87  * This constructor has no runtime dependency on conversion code and is
  88  * therefore recommended over ones taking a charset name string
  89  * (where the empty string &quot;&quot; indicates invariant-character conversion).
  90  *
  91  * @stable ICU 3.2
  92  */
  93 #define US_INV icu::UnicodeString::kInvariant
  94 
  95 /**
  96  * Unicode String literals in C++.
  97  *
  98  * Note: these macros are not recommended for new code.
  99  * Prior to the availability of C++11 and u&quot;unicode string literals&quot;,
 100  * these macros were provided for portability and efficiency when
 101  * initializing UnicodeStrings from literals.
 102  *
 103  * They work only for strings that contain &quot;invariant characters&quot;, i.e.,
 104  * only latin letters, digits, and some punctuation.
 105  * See utypes.h for details.
 106  *
 107  * The string parameter must be a C string literal.
 108  * The length of the string, not including the terminating
 109  * &lt;code&gt;NUL&lt;/code&gt;, must be specified as a constant.
 110  * @stable ICU 2.0
 111  */
 112 #if !U_CHAR16_IS_TYPEDEF
 113 # define UNICODE_STRING(cs, _length) icu::UnicodeString(TRUE, u ## cs, _length)
 114 #else
 115 # define UNICODE_STRING(cs, _length) icu::UnicodeString(TRUE, (const char16_t*)u ## cs, _length)
 116 #endif
 117 
 118 /**
 119  * Unicode String literals in C++.
 120  * Dependent on the platform properties, different UnicodeString
 121  * constructors should be used to create a UnicodeString object from
 122  * a string literal.
 123  * The macros are defined for improved performance.
 124  * They work only for strings that contain &quot;invariant characters&quot;, i.e.,
 125  * only latin letters, digits, and some punctuation.
 126  * See utypes.h for details.
 127  *
 128  * The string parameter must be a C string literal.
 129  * @stable ICU 2.0
 130  */
 131 #define UNICODE_STRING_SIMPLE(cs) UNICODE_STRING(cs, -1)
 132 
 133 /**
 134  * \def UNISTR_FROM_CHAR_EXPLICIT
 135  * This can be defined to be empty or &quot;explicit&quot;.
 136  * If explicit, then the UnicodeString(char16_t) and UnicodeString(UChar32)
 137  * constructors are marked as explicit, preventing their inadvertent use.
 138  * @stable ICU 49
 139  */
 140 #ifndef UNISTR_FROM_CHAR_EXPLICIT
 141 # if defined(U_COMBINED_IMPLEMENTATION) || defined(U_COMMON_IMPLEMENTATION) || defined(U_I18N_IMPLEMENTATION) || defined(U_IO_IMPLEMENTATION)
 142     // Auto-&quot;explicit&quot; in ICU library code.
 143 #   define UNISTR_FROM_CHAR_EXPLICIT explicit
 144 # else
 145     // Empty by default for source code compatibility.
 146 #   define UNISTR_FROM_CHAR_EXPLICIT
 147 # endif
 148 #endif
 149 
 150 /**
 151  * \def UNISTR_FROM_STRING_EXPLICIT
 152  * This can be defined to be empty or &quot;explicit&quot;.
 153  * If explicit, then the UnicodeString(const char *) and UnicodeString(const char16_t *)
 154  * constructors are marked as explicit, preventing their inadvertent use.
 155  *
 156  * In particular, this helps prevent accidentally depending on ICU conversion code
 157  * by passing a string literal into an API with a const UnicodeString &amp; parameter.
 158  * @stable ICU 49
 159  */
 160 #ifndef UNISTR_FROM_STRING_EXPLICIT
 161 # if defined(U_COMBINED_IMPLEMENTATION) || defined(U_COMMON_IMPLEMENTATION) || defined(U_I18N_IMPLEMENTATION) || defined(U_IO_IMPLEMENTATION)
 162     // Auto-&quot;explicit&quot; in ICU library code.
 163 #   define UNISTR_FROM_STRING_EXPLICIT explicit
 164 # else
 165     // Empty by default for source code compatibility.
 166 #   define UNISTR_FROM_STRING_EXPLICIT
 167 # endif
 168 #endif
 169 
 170 /**
 171  * \def UNISTR_OBJECT_SIZE
 172  * Desired sizeof(UnicodeString) in bytes.
 173  * It should be a multiple of sizeof(pointer) to avoid unusable space for padding.
 174  * The object size may want to be a multiple of 16 bytes,
 175  * which is a common granularity for heap allocation.
 176  *
 177  * Any space inside the object beyond sizeof(vtable pointer) + 2
 178  * is available for storing short strings inside the object.
 179  * The bigger the object, the longer a string that can be stored inside the object,
 180  * without additional heap allocation.
 181  *
 182  * Depending on a platform&#39;s pointer size, pointer alignment requirements,
 183  * and struct padding, the compiler will usually round up sizeof(UnicodeString)
 184  * to 4 * sizeof(pointer) (or 3 * sizeof(pointer) for P128 data models),
 185  * to hold the fields for heap-allocated strings.
 186  * Such a minimum size also ensures that the object is easily large enough
 187  * to hold at least 2 char16_ts, for one supplementary code point (U16_MAX_LENGTH).
 188  *
 189  * sizeof(UnicodeString) &gt;= 48 should work for all known platforms.
 190  *
 191  * For example, on a 64-bit machine where sizeof(vtable pointer) is 8,
 192  * sizeof(UnicodeString) = 64 would leave space for
 193  * (64 - sizeof(vtable pointer) - 2) / U_SIZEOF_UCHAR = (64 - 8 - 2) / 2 = 27
 194  * char16_ts stored inside the object.
 195  *
 196  * The minimum object size on a 64-bit machine would be
 197  * 4 * sizeof(pointer) = 4 * 8 = 32 bytes,
 198  * and the internal buffer would hold up to 11 char16_ts in that case.
 199  *
 200  * @see U16_MAX_LENGTH
 201  * @stable ICU 56
 202  */
 203 #ifndef UNISTR_OBJECT_SIZE
 204 # define UNISTR_OBJECT_SIZE 64
 205 #endif
 206 
 207 /**
 208  * UnicodeString is a string class that stores Unicode characters directly and provides
 209  * similar functionality as the Java String and StringBuffer/StringBuilder classes.
 210  * It is a concrete implementation of the abstract class Replaceable (for transliteration).
 211  *
 212  * A UnicodeString may also &quot;alias&quot; an external array of characters
 213  * (that is, point to it, rather than own the array)
 214  * whose lifetime must then at least match the lifetime of the aliasing object.
 215  * This aliasing may be preserved when returning a UnicodeString by value,
 216  * depending on the compiler and the function implementation,
 217  * via Return Value Optimization (RVO) or the move assignment operator.
 218  * (However, the copy assignment operator does not preserve aliasing.)
 219  * For details see the description of storage models at the end of the class API docs
 220  * and in the User Guide chapter linked from there.
 221  *
 222  * The UnicodeString class is not suitable for subclassing.
 223  *
 224  * &lt;p&gt;For an overview of Unicode strings in C and C++ see the
 225  * &lt;a href=&quot;http://userguide.icu-project.org/strings#TOC-Strings-in-C-C-&quot;&gt;User Guide Strings chapter&lt;/a&gt;.&lt;/p&gt;
 226  *
 227  * &lt;p&gt;In ICU, a Unicode string consists of 16-bit Unicode &lt;em&gt;code units&lt;/em&gt;.
 228  * A Unicode character may be stored with either one code unit
 229  * (the most common case) or with a matched pair of special code units
 230  * (&quot;surrogates&quot;). The data type for code units is char16_t.
 231  * For single-character handling, a Unicode character code &lt;em&gt;point&lt;/em&gt; is a value
 232  * in the range 0..0x10ffff. ICU uses the UChar32 type for code points.&lt;/p&gt;
 233  *
 234  * &lt;p&gt;Indexes and offsets into and lengths of strings always count code units, not code points.
 235  * This is the same as with multi-byte char* strings in traditional string handling.
 236  * Operations on partial strings typically do not test for code point boundaries.
 237  * If necessary, the user needs to take care of such boundaries by testing for the code unit
 238  * values or by using functions like
 239  * UnicodeString::getChar32Start() and UnicodeString::getChar32Limit()
 240  * (or, in C, the equivalent macros U16_SET_CP_START() and U16_SET_CP_LIMIT(), see utf.h).&lt;/p&gt;
 241  *
 242  * UnicodeString methods are more lenient with regard to input parameter values
 243  * than other ICU APIs. In particular:
 244  * - If indexes are out of bounds for a UnicodeString object
 245  *   (&lt;0 or &gt;length()) then they are &quot;pinned&quot; to the nearest boundary.
 246  * - If primitive string pointer values (e.g., const char16_t * or char *)
 247  *   for input strings are NULL, then those input string parameters are treated
 248  *   as if they pointed to an empty string.
 249  *   However, this is &lt;em&gt;not&lt;/em&gt; the case for char * parameters for charset names
 250  *   or other IDs.
 251  * - Most UnicodeString methods do not take a UErrorCode parameter because
 252  *   there are usually very few opportunities for failure other than a shortage
 253  *   of memory, error codes in low-level C++ string methods would be inconvenient,
 254  *   and the error code as the last parameter (ICU convention) would prevent
 255  *   the use of default parameter values.
 256  *   Instead, such methods set the UnicodeString into a &quot;bogus&quot; state
 257  *   (see isBogus()) if an error occurs.
 258  *
 259  * In string comparisons, two UnicodeString objects that are both &quot;bogus&quot;
 260  * compare equal (to be transitive and prevent endless loops in sorting),
 261  * and a &quot;bogus&quot; string compares less than any non-&quot;bogus&quot; one.
 262  *
 263  * Const UnicodeString methods are thread-safe. Multiple threads can use
 264  * const methods on the same UnicodeString object simultaneously,
 265  * but non-const methods must not be called concurrently (in multiple threads)
 266  * with any other (const or non-const) methods.
 267  *
 268  * Similarly, const UnicodeString &amp; parameters are thread-safe.
 269  * One object may be passed in as such a parameter concurrently in multiple threads.
 270  * This includes the const UnicodeString &amp; parameters for
 271  * copy construction, assignment, and cloning.
 272  *
 273  * &lt;p&gt;UnicodeString uses several storage methods.
 274  * String contents can be stored inside the UnicodeString object itself,
 275  * in an allocated and shared buffer, or in an outside buffer that is &quot;aliased&quot;.
 276  * Most of this is done transparently, but careful aliasing in particular provides
 277  * significant performance improvements.
 278  * Also, the internal buffer is accessible via special functions.
 279  * For details see the
 280  * &lt;a href=&quot;http://userguide.icu-project.org/strings#TOC-Maximizing-Performance-with-the-UnicodeString-Storage-Model&quot;&gt;User Guide Strings chapter&lt;/a&gt;.&lt;/p&gt;
 281  *
 282  * @see utf.h
 283  * @see CharacterIterator
 284  * @stable ICU 2.0
 285  */
 286 class U_COMMON_API UnicodeString : public Replaceable
 287 {
 288 public:
 289 
 290   /**
 291    * Constant to be used in the UnicodeString(char *, int32_t, EInvariant) constructor
 292    * which constructs a Unicode string from an invariant-character char * string.
 293    * Use the macro US_INV instead of the full qualification for this value.
 294    *
 295    * @see US_INV
 296    * @stable ICU 3.2
 297    */
 298   enum EInvariant {
 299     /**
 300      * @see EInvariant
 301      * @stable ICU 3.2
 302      */
 303     kInvariant
 304   };
 305 
 306   //========================================
 307   // Read-only operations
 308   //========================================
 309 
 310   /* Comparison - bitwise only - for international comparison use collation */
 311 
 312   /**
 313    * Equality operator. Performs only bitwise comparison.
 314    * @param text The UnicodeString to compare to this one.
 315    * @return TRUE if &lt;TT&gt;text&lt;/TT&gt; contains the same characters as this one,
 316    * FALSE otherwise.
 317    * @stable ICU 2.0
 318    */
 319   inline UBool operator== (const UnicodeString&amp; text) const;
 320 
 321   /**
 322    * Inequality operator. Performs only bitwise comparison.
 323    * @param text The UnicodeString to compare to this one.
 324    * @return FALSE if &lt;TT&gt;text&lt;/TT&gt; contains the same characters as this one,
 325    * TRUE otherwise.
 326    * @stable ICU 2.0
 327    */
 328   inline UBool operator!= (const UnicodeString&amp; text) const;
 329 
 330   /**
 331    * Greater than operator. Performs only bitwise comparison.
 332    * @param text The UnicodeString to compare to this one.
 333    * @return TRUE if the characters in this are bitwise
 334    * greater than the characters in &lt;code&gt;text&lt;/code&gt;, FALSE otherwise
 335    * @stable ICU 2.0
 336    */
 337   inline UBool operator&gt; (const UnicodeString&amp; text) const;
 338 
 339   /**
 340    * Less than operator. Performs only bitwise comparison.
 341    * @param text The UnicodeString to compare to this one.
 342    * @return TRUE if the characters in this are bitwise
 343    * less than the characters in &lt;code&gt;text&lt;/code&gt;, FALSE otherwise
 344    * @stable ICU 2.0
 345    */
 346   inline UBool operator&lt; (const UnicodeString&amp; text) const;
 347 
 348   /**
 349    * Greater than or equal operator. Performs only bitwise comparison.
 350    * @param text The UnicodeString to compare to this one.
 351    * @return TRUE if the characters in this are bitwise
 352    * greater than or equal to the characters in &lt;code&gt;text&lt;/code&gt;, FALSE otherwise
 353    * @stable ICU 2.0
 354    */
 355   inline UBool operator&gt;= (const UnicodeString&amp; text) const;
 356 
 357   /**
 358    * Less than or equal operator. Performs only bitwise comparison.
 359    * @param text The UnicodeString to compare to this one.
 360    * @return TRUE if the characters in this are bitwise
 361    * less than or equal to the characters in &lt;code&gt;text&lt;/code&gt;, FALSE otherwise
 362    * @stable ICU 2.0
 363    */
 364   inline UBool operator&lt;= (const UnicodeString&amp; text) const;
 365 
 366   /**
 367    * Compare the characters bitwise in this UnicodeString to
 368    * the characters in &lt;code&gt;text&lt;/code&gt;.
 369    * @param text The UnicodeString to compare to this one.
 370    * @return The result of bitwise character comparison: 0 if this
 371    * contains the same characters as &lt;code&gt;text&lt;/code&gt;, -1 if the characters in
 372    * this are bitwise less than the characters in &lt;code&gt;text&lt;/code&gt;, +1 if the
 373    * characters in this are bitwise greater than the characters
 374    * in &lt;code&gt;text&lt;/code&gt;.
 375    * @stable ICU 2.0
 376    */
 377   inline int8_t compare(const UnicodeString&amp; text) const;
 378 
 379   /**
 380    * Compare the characters bitwise in the range
 381    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters
 382    * in the &lt;b&gt;entire string&lt;/b&gt; &lt;TT&gt;text&lt;/TT&gt;.
 383    * (The parameters &quot;start&quot; and &quot;length&quot; are not applied to the other text &quot;text&quot;.)
 384    * @param start the offset at which the compare operation begins
 385    * @param length the number of characters of text to compare.
 386    * @param text the other text to be compared against this string.
 387    * @return The result of bitwise character comparison: 0 if this
 388    * contains the same characters as &lt;code&gt;text&lt;/code&gt;, -1 if the characters in
 389    * this are bitwise less than the characters in &lt;code&gt;text&lt;/code&gt;, +1 if the
 390    * characters in this are bitwise greater than the characters
 391    * in &lt;code&gt;text&lt;/code&gt;.
 392    * @stable ICU 2.0
 393    */
 394   inline int8_t compare(int32_t start,
 395          int32_t length,
 396          const UnicodeString&amp; text) const;
 397 
 398   /**
 399    * Compare the characters bitwise in the range
 400    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters
 401    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range
 402    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).
 403    * @param start the offset at which the compare operation begins
 404    * @param length the number of characters in this to compare.
 405    * @param srcText the text to be compared
 406    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start comparison
 407    * @param srcLength the number of characters in &lt;TT&gt;src&lt;/TT&gt; to compare
 408    * @return The result of bitwise character comparison: 0 if this
 409    * contains the same characters as &lt;code&gt;srcText&lt;/code&gt;, -1 if the characters in
 410    * this are bitwise less than the characters in &lt;code&gt;srcText&lt;/code&gt;, +1 if the
 411    * characters in this are bitwise greater than the characters
 412    * in &lt;code&gt;srcText&lt;/code&gt;.
 413    * @stable ICU 2.0
 414    */
 415    inline int8_t compare(int32_t start,
 416          int32_t length,
 417          const UnicodeString&amp; srcText,
 418          int32_t srcStart,
 419          int32_t srcLength) const;
 420 
 421   /**
 422    * Compare the characters bitwise in this UnicodeString with the first
 423    * &lt;TT&gt;srcLength&lt;/TT&gt; characters in &lt;TT&gt;srcChars&lt;/TT&gt;.
 424    * @param srcChars The characters to compare to this UnicodeString.
 425    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to compare
 426    * @return The result of bitwise character comparison: 0 if this
 427    * contains the same characters as &lt;code&gt;srcChars&lt;/code&gt;, -1 if the characters in
 428    * this are bitwise less than the characters in &lt;code&gt;srcChars&lt;/code&gt;, +1 if the
 429    * characters in this are bitwise greater than the characters
 430    * in &lt;code&gt;srcChars&lt;/code&gt;.
 431    * @stable ICU 2.0
 432    */
 433   inline int8_t compare(ConstChar16Ptr srcChars,
 434          int32_t srcLength) const;
 435 
 436   /**
 437    * Compare the characters bitwise in the range
 438    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the first
 439    * &lt;TT&gt;length&lt;/TT&gt; characters in &lt;TT&gt;srcChars&lt;/TT&gt;
 440    * @param start the offset at which the compare operation begins
 441    * @param length the number of characters to compare.
 442    * @param srcChars the characters to be compared
 443    * @return The result of bitwise character comparison: 0 if this
 444    * contains the same characters as &lt;code&gt;srcChars&lt;/code&gt;, -1 if the characters in
 445    * this are bitwise less than the characters in &lt;code&gt;srcChars&lt;/code&gt;, +1 if the
 446    * characters in this are bitwise greater than the characters
 447    * in &lt;code&gt;srcChars&lt;/code&gt;.
 448    * @stable ICU 2.0
 449    */
 450   inline int8_t compare(int32_t start,
 451          int32_t length,
 452          const char16_t *srcChars) const;
 453 
 454   /**
 455    * Compare the characters bitwise in the range
 456    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters
 457    * in &lt;TT&gt;srcChars&lt;/TT&gt; in the range
 458    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).
 459    * @param start the offset at which the compare operation begins
 460    * @param length the number of characters in this to compare
 461    * @param srcChars the characters to be compared
 462    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; to start comparison
 463    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to compare
 464    * @return The result of bitwise character comparison: 0 if this
 465    * contains the same characters as &lt;code&gt;srcChars&lt;/code&gt;, -1 if the characters in
 466    * this are bitwise less than the characters in &lt;code&gt;srcChars&lt;/code&gt;, +1 if the
 467    * characters in this are bitwise greater than the characters
 468    * in &lt;code&gt;srcChars&lt;/code&gt;.
 469    * @stable ICU 2.0
 470    */
 471   inline int8_t compare(int32_t start,
 472          int32_t length,
 473          const char16_t *srcChars,
 474          int32_t srcStart,
 475          int32_t srcLength) const;
 476 
 477   /**
 478    * Compare the characters bitwise in the range
 479    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;limit&lt;/TT&gt;) with the characters
 480    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range
 481    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcLimit&lt;/TT&gt;).
 482    * @param start the offset at which the compare operation begins
 483    * @param limit the offset immediately following the compare operation
 484    * @param srcText the text to be compared
 485    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start comparison
 486    * @param srcLimit the offset into &lt;TT&gt;srcText&lt;/TT&gt; to limit comparison
 487    * @return The result of bitwise character comparison: 0 if this
 488    * contains the same characters as &lt;code&gt;srcText&lt;/code&gt;, -1 if the characters in
 489    * this are bitwise less than the characters in &lt;code&gt;srcText&lt;/code&gt;, +1 if the
 490    * characters in this are bitwise greater than the characters
 491    * in &lt;code&gt;srcText&lt;/code&gt;.
 492    * @stable ICU 2.0
 493    */
 494   inline int8_t compareBetween(int32_t start,
 495             int32_t limit,
 496             const UnicodeString&amp; srcText,
 497             int32_t srcStart,
 498             int32_t srcLimit) const;
 499 
 500   /**
 501    * Compare two Unicode strings in code point order.
 502    * The result may be different from the results of compare(), operator&lt;, etc.
 503    * if supplementary characters are present:
 504    *
 505    * In UTF-16, supplementary characters (with code points U+10000 and above) are
 506    * stored with pairs of surrogate code units. These have values from 0xd800 to 0xdfff,
 507    * which means that they compare as less than some other BMP characters like U+feff.
 508    * This function compares Unicode strings in code point order.
 509    * If either of the UTF-16 strings is malformed (i.e., it contains unpaired surrogates), then the result is not defined.
 510    *
 511    * @param text Another string to compare this one to.
 512    * @return a negative/zero/positive integer corresponding to whether
 513    * this string is less than/equal to/greater than the second one
 514    * in code point order
 515    * @stable ICU 2.0
 516    */
 517   inline int8_t compareCodePointOrder(const UnicodeString&amp; text) const;
 518 
 519   /**
 520    * Compare two Unicode strings in code point order.
 521    * The result may be different from the results of compare(), operator&lt;, etc.
 522    * if supplementary characters are present:
 523    *
 524    * In UTF-16, supplementary characters (with code points U+10000 and above) are
 525    * stored with pairs of surrogate code units. These have values from 0xd800 to 0xdfff,
 526    * which means that they compare as less than some other BMP characters like U+feff.
 527    * This function compares Unicode strings in code point order.
 528    * If either of the UTF-16 strings is malformed (i.e., it contains unpaired surrogates), then the result is not defined.
 529    *
 530    * @param start The start offset in this string at which the compare operation begins.
 531    * @param length The number of code units from this string to compare.
 532    * @param srcText Another string to compare this one to.
 533    * @return a negative/zero/positive integer corresponding to whether
 534    * this string is less than/equal to/greater than the second one
 535    * in code point order
 536    * @stable ICU 2.0
 537    */
 538   inline int8_t compareCodePointOrder(int32_t start,
 539                                       int32_t length,
 540                                       const UnicodeString&amp; srcText) const;
 541 
 542   /**
 543    * Compare two Unicode strings in code point order.
 544    * The result may be different from the results of compare(), operator&lt;, etc.
 545    * if supplementary characters are present:
 546    *
 547    * In UTF-16, supplementary characters (with code points U+10000 and above) are
 548    * stored with pairs of surrogate code units. These have values from 0xd800 to 0xdfff,
 549    * which means that they compare as less than some other BMP characters like U+feff.
 550    * This function compares Unicode strings in code point order.
 551    * If either of the UTF-16 strings is malformed (i.e., it contains unpaired surrogates), then the result is not defined.
 552    *
 553    * @param start The start offset in this string at which the compare operation begins.
 554    * @param length The number of code units from this string to compare.
 555    * @param srcText Another string to compare this one to.
 556    * @param srcStart The start offset in that string at which the compare operation begins.
 557    * @param srcLength The number of code units from that string to compare.
 558    * @return a negative/zero/positive integer corresponding to whether
 559    * this string is less than/equal to/greater than the second one
 560    * in code point order
 561    * @stable ICU 2.0
 562    */
 563    inline int8_t compareCodePointOrder(int32_t start,
 564                                        int32_t length,
 565                                        const UnicodeString&amp; srcText,
 566                                        int32_t srcStart,
 567                                        int32_t srcLength) const;
 568 
 569   /**
 570    * Compare two Unicode strings in code point order.
 571    * The result may be different from the results of compare(), operator&lt;, etc.
 572    * if supplementary characters are present:
 573    *
 574    * In UTF-16, supplementary characters (with code points U+10000 and above) are
 575    * stored with pairs of surrogate code units. These have values from 0xd800 to 0xdfff,
 576    * which means that they compare as less than some other BMP characters like U+feff.
 577    * This function compares Unicode strings in code point order.
 578    * If either of the UTF-16 strings is malformed (i.e., it contains unpaired surrogates), then the result is not defined.
 579    *
 580    * @param srcChars A pointer to another string to compare this one to.
 581    * @param srcLength The number of code units from that string to compare.
 582    * @return a negative/zero/positive integer corresponding to whether
 583    * this string is less than/equal to/greater than the second one
 584    * in code point order
 585    * @stable ICU 2.0
 586    */
 587   inline int8_t compareCodePointOrder(ConstChar16Ptr srcChars,
 588                                       int32_t srcLength) const;
 589 
 590   /**
 591    * Compare two Unicode strings in code point order.
 592    * The result may be different from the results of compare(), operator&lt;, etc.
 593    * if supplementary characters are present:
 594    *
 595    * In UTF-16, supplementary characters (with code points U+10000 and above) are
 596    * stored with pairs of surrogate code units. These have values from 0xd800 to 0xdfff,
 597    * which means that they compare as less than some other BMP characters like U+feff.
 598    * This function compares Unicode strings in code point order.
 599    * If either of the UTF-16 strings is malformed (i.e., it contains unpaired surrogates), then the result is not defined.
 600    *
 601    * @param start The start offset in this string at which the compare operation begins.
 602    * @param length The number of code units from this string to compare.
 603    * @param srcChars A pointer to another string to compare this one to.
 604    * @return a negative/zero/positive integer corresponding to whether
 605    * this string is less than/equal to/greater than the second one
 606    * in code point order
 607    * @stable ICU 2.0
 608    */
 609   inline int8_t compareCodePointOrder(int32_t start,
 610                                       int32_t length,
 611                                       const char16_t *srcChars) const;
 612 
 613   /**
 614    * Compare two Unicode strings in code point order.
 615    * The result may be different from the results of compare(), operator&lt;, etc.
 616    * if supplementary characters are present:
 617    *
 618    * In UTF-16, supplementary characters (with code points U+10000 and above) are
 619    * stored with pairs of surrogate code units. These have values from 0xd800 to 0xdfff,
 620    * which means that they compare as less than some other BMP characters like U+feff.
 621    * This function compares Unicode strings in code point order.
 622    * If either of the UTF-16 strings is malformed (i.e., it contains unpaired surrogates), then the result is not defined.
 623    *
 624    * @param start The start offset in this string at which the compare operation begins.
 625    * @param length The number of code units from this string to compare.
 626    * @param srcChars A pointer to another string to compare this one to.
 627    * @param srcStart The start offset in that string at which the compare operation begins.
 628    * @param srcLength The number of code units from that string to compare.
 629    * @return a negative/zero/positive integer corresponding to whether
 630    * this string is less than/equal to/greater than the second one
 631    * in code point order
 632    * @stable ICU 2.0
 633    */
 634   inline int8_t compareCodePointOrder(int32_t start,
 635                                       int32_t length,
 636                                       const char16_t *srcChars,
 637                                       int32_t srcStart,
 638                                       int32_t srcLength) const;
 639 
 640   /**
 641    * Compare two Unicode strings in code point order.
 642    * The result may be different from the results of compare(), operator&lt;, etc.
 643    * if supplementary characters are present:
 644    *
 645    * In UTF-16, supplementary characters (with code points U+10000 and above) are
 646    * stored with pairs of surrogate code units. These have values from 0xd800 to 0xdfff,
 647    * which means that they compare as less than some other BMP characters like U+feff.
 648    * This function compares Unicode strings in code point order.
 649    * If either of the UTF-16 strings is malformed (i.e., it contains unpaired surrogates), then the result is not defined.
 650    *
 651    * @param start The start offset in this string at which the compare operation begins.
 652    * @param limit The offset after the last code unit from this string to compare.
 653    * @param srcText Another string to compare this one to.
 654    * @param srcStart The start offset in that string at which the compare operation begins.
 655    * @param srcLimit The offset after the last code unit from that string to compare.
 656    * @return a negative/zero/positive integer corresponding to whether
 657    * this string is less than/equal to/greater than the second one
 658    * in code point order
 659    * @stable ICU 2.0
 660    */
 661   inline int8_t compareCodePointOrderBetween(int32_t start,
 662                                              int32_t limit,
 663                                              const UnicodeString&amp; srcText,
 664                                              int32_t srcStart,
 665                                              int32_t srcLimit) const;
 666 
 667   /**
 668    * Compare two strings case-insensitively using full case folding.
 669    * This is equivalent to this-&gt;foldCase(options).compare(text.foldCase(options)).
 670    *
 671    * @param text Another string to compare this one to.
 672    * @param options A bit set of options:
 673    *   - U_FOLD_CASE_DEFAULT or 0 is used for default options:
 674    *     Comparison in code unit order with default case folding.
 675    *
 676    *   - U_COMPARE_CODE_POINT_ORDER
 677    *     Set to choose code point order instead of code unit order
 678    *     (see u_strCompare for details).
 679    *
 680    *   - U_FOLD_CASE_EXCLUDE_SPECIAL_I
 681    *
 682    * @return A negative, zero, or positive integer indicating the comparison result.
 683    * @stable ICU 2.0
 684    */
 685   inline int8_t caseCompare(const UnicodeString&amp; text, uint32_t options) const;
 686 
 687   /**
 688    * Compare two strings case-insensitively using full case folding.
 689    * This is equivalent to this-&gt;foldCase(options).compare(srcText.foldCase(options)).
 690    *
 691    * @param start The start offset in this string at which the compare operation begins.
 692    * @param length The number of code units from this string to compare.
 693    * @param srcText Another string to compare this one to.
 694    * @param options A bit set of options:
 695    *   - U_FOLD_CASE_DEFAULT or 0 is used for default options:
 696    *     Comparison in code unit order with default case folding.
 697    *
 698    *   - U_COMPARE_CODE_POINT_ORDER
 699    *     Set to choose code point order instead of code unit order
 700    *     (see u_strCompare for details).
 701    *
 702    *   - U_FOLD_CASE_EXCLUDE_SPECIAL_I
 703    *
 704    * @return A negative, zero, or positive integer indicating the comparison result.
 705    * @stable ICU 2.0
 706    */
 707   inline int8_t caseCompare(int32_t start,
 708          int32_t length,
 709          const UnicodeString&amp; srcText,
 710          uint32_t options) const;
 711 
 712   /**
 713    * Compare two strings case-insensitively using full case folding.
 714    * This is equivalent to this-&gt;foldCase(options).compare(srcText.foldCase(options)).
 715    *
 716    * @param start The start offset in this string at which the compare operation begins.
 717    * @param length The number of code units from this string to compare.
 718    * @param srcText Another string to compare this one to.
 719    * @param srcStart The start offset in that string at which the compare operation begins.
 720    * @param srcLength The number of code units from that string to compare.
 721    * @param options A bit set of options:
 722    *   - U_FOLD_CASE_DEFAULT or 0 is used for default options:
 723    *     Comparison in code unit order with default case folding.
 724    *
 725    *   - U_COMPARE_CODE_POINT_ORDER
 726    *     Set to choose code point order instead of code unit order
 727    *     (see u_strCompare for details).
 728    *
 729    *   - U_FOLD_CASE_EXCLUDE_SPECIAL_I
 730    *
 731    * @return A negative, zero, or positive integer indicating the comparison result.
 732    * @stable ICU 2.0
 733    */
 734   inline int8_t caseCompare(int32_t start,
 735          int32_t length,
 736          const UnicodeString&amp; srcText,
 737          int32_t srcStart,
 738          int32_t srcLength,
 739          uint32_t options) const;
 740 
 741   /**
 742    * Compare two strings case-insensitively using full case folding.
 743    * This is equivalent to this-&gt;foldCase(options).compare(srcChars.foldCase(options)).
 744    *
 745    * @param srcChars A pointer to another string to compare this one to.
 746    * @param srcLength The number of code units from that string to compare.
 747    * @param options A bit set of options:
 748    *   - U_FOLD_CASE_DEFAULT or 0 is used for default options:
 749    *     Comparison in code unit order with default case folding.
 750    *
 751    *   - U_COMPARE_CODE_POINT_ORDER
 752    *     Set to choose code point order instead of code unit order
 753    *     (see u_strCompare for details).
 754    *
 755    *   - U_FOLD_CASE_EXCLUDE_SPECIAL_I
 756    *
 757    * @return A negative, zero, or positive integer indicating the comparison result.
 758    * @stable ICU 2.0
 759    */
 760   inline int8_t caseCompare(ConstChar16Ptr srcChars,
 761          int32_t srcLength,
 762          uint32_t options) const;
 763 
 764   /**
 765    * Compare two strings case-insensitively using full case folding.
 766    * This is equivalent to this-&gt;foldCase(options).compare(srcChars.foldCase(options)).
 767    *
 768    * @param start The start offset in this string at which the compare operation begins.
 769    * @param length The number of code units from this string to compare.
 770    * @param srcChars A pointer to another string to compare this one to.
 771    * @param options A bit set of options:
 772    *   - U_FOLD_CASE_DEFAULT or 0 is used for default options:
 773    *     Comparison in code unit order with default case folding.
 774    *
 775    *   - U_COMPARE_CODE_POINT_ORDER
 776    *     Set to choose code point order instead of code unit order
 777    *     (see u_strCompare for details).
 778    *
 779    *   - U_FOLD_CASE_EXCLUDE_SPECIAL_I
 780    *
 781    * @return A negative, zero, or positive integer indicating the comparison result.
 782    * @stable ICU 2.0
 783    */
 784   inline int8_t caseCompare(int32_t start,
 785          int32_t length,
 786          const char16_t *srcChars,
 787          uint32_t options) const;
 788 
 789   /**
 790    * Compare two strings case-insensitively using full case folding.
 791    * This is equivalent to this-&gt;foldCase(options).compare(srcChars.foldCase(options)).
 792    *
 793    * @param start The start offset in this string at which the compare operation begins.
 794    * @param length The number of code units from this string to compare.
 795    * @param srcChars A pointer to another string to compare this one to.
 796    * @param srcStart The start offset in that string at which the compare operation begins.
 797    * @param srcLength The number of code units from that string to compare.
 798    * @param options A bit set of options:
 799    *   - U_FOLD_CASE_DEFAULT or 0 is used for default options:
 800    *     Comparison in code unit order with default case folding.
 801    *
 802    *   - U_COMPARE_CODE_POINT_ORDER
 803    *     Set to choose code point order instead of code unit order
 804    *     (see u_strCompare for details).
 805    *
 806    *   - U_FOLD_CASE_EXCLUDE_SPECIAL_I
 807    *
 808    * @return A negative, zero, or positive integer indicating the comparison result.
 809    * @stable ICU 2.0
 810    */
 811   inline int8_t caseCompare(int32_t start,
 812          int32_t length,
 813          const char16_t *srcChars,
 814          int32_t srcStart,
 815          int32_t srcLength,
 816          uint32_t options) const;
 817 
 818   /**
 819    * Compare two strings case-insensitively using full case folding.
 820    * This is equivalent to this-&gt;foldCase(options).compareBetween(text.foldCase(options)).
 821    *
 822    * @param start The start offset in this string at which the compare operation begins.
 823    * @param limit The offset after the last code unit from this string to compare.
 824    * @param srcText Another string to compare this one to.
 825    * @param srcStart The start offset in that string at which the compare operation begins.
 826    * @param srcLimit The offset after the last code unit from that string to compare.
 827    * @param options A bit set of options:
 828    *   - U_FOLD_CASE_DEFAULT or 0 is used for default options:
 829    *     Comparison in code unit order with default case folding.
 830    *
 831    *   - U_COMPARE_CODE_POINT_ORDER
 832    *     Set to choose code point order instead of code unit order
 833    *     (see u_strCompare for details).
 834    *
 835    *   - U_FOLD_CASE_EXCLUDE_SPECIAL_I
 836    *
 837    * @return A negative, zero, or positive integer indicating the comparison result.
 838    * @stable ICU 2.0
 839    */
 840   inline int8_t caseCompareBetween(int32_t start,
 841             int32_t limit,
 842             const UnicodeString&amp; srcText,
 843             int32_t srcStart,
 844             int32_t srcLimit,
 845             uint32_t options) const;
 846 
 847   /**
 848    * Determine if this starts with the characters in &lt;TT&gt;text&lt;/TT&gt;
 849    * @param text The text to match.
 850    * @return TRUE if this starts with the characters in &lt;TT&gt;text&lt;/TT&gt;,
 851    * FALSE otherwise
 852    * @stable ICU 2.0
 853    */
 854   inline UBool startsWith(const UnicodeString&amp; text) const;
 855 
 856   /**
 857    * Determine if this starts with the characters in &lt;TT&gt;srcText&lt;/TT&gt;
 858    * in the range [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).
 859    * @param srcText The text to match.
 860    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start matching
 861    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; to match
 862    * @return TRUE if this starts with the characters in &lt;TT&gt;text&lt;/TT&gt;,
 863    * FALSE otherwise
 864    * @stable ICU 2.0
 865    */
 866   inline UBool startsWith(const UnicodeString&amp; srcText,
 867             int32_t srcStart,
 868             int32_t srcLength) const;
 869 
 870   /**
 871    * Determine if this starts with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;
 872    * @param srcChars The characters to match.
 873    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;
 874    * @return TRUE if this starts with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;,
 875    * FALSE otherwise
 876    * @stable ICU 2.0
 877    */
 878   inline UBool startsWith(ConstChar16Ptr srcChars,
 879             int32_t srcLength) const;
 880 
 881   /**
 882    * Determine if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;
 883    * in the range  [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).
 884    * @param srcChars The characters to match.
 885    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start matching
 886    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match
 887    * @return TRUE if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;, FALSE otherwise
 888    * @stable ICU 2.0
 889    */
 890   inline UBool startsWith(const char16_t *srcChars,
 891             int32_t srcStart,
 892             int32_t srcLength) const;
 893 
 894   /**
 895    * Determine if this ends with the characters in &lt;TT&gt;text&lt;/TT&gt;
 896    * @param text The text to match.
 897    * @return TRUE if this ends with the characters in &lt;TT&gt;text&lt;/TT&gt;,
 898    * FALSE otherwise
 899    * @stable ICU 2.0
 900    */
 901   inline UBool endsWith(const UnicodeString&amp; text) const;
 902 
 903   /**
 904    * Determine if this ends with the characters in &lt;TT&gt;srcText&lt;/TT&gt;
 905    * in the range [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).
 906    * @param srcText The text to match.
 907    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start matching
 908    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; to match
 909    * @return TRUE if this ends with the characters in &lt;TT&gt;text&lt;/TT&gt;,
 910    * FALSE otherwise
 911    * @stable ICU 2.0
 912    */
 913   inline UBool endsWith(const UnicodeString&amp; srcText,
 914           int32_t srcStart,
 915           int32_t srcLength) const;
 916 
 917   /**
 918    * Determine if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;
 919    * @param srcChars The characters to match.
 920    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;
 921    * @return TRUE if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;,
 922    * FALSE otherwise
 923    * @stable ICU 2.0
 924    */
 925   inline UBool endsWith(ConstChar16Ptr srcChars,
 926           int32_t srcLength) const;
 927 
 928   /**
 929    * Determine if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;
 930    * in the range  [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).
 931    * @param srcChars The characters to match.
 932    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start matching
 933    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match
 934    * @return TRUE if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;,
 935    * FALSE otherwise
 936    * @stable ICU 2.0
 937    */
 938   inline UBool endsWith(const char16_t *srcChars,
 939           int32_t srcStart,
 940           int32_t srcLength) const;
 941 
 942 
 943   /* Searching - bitwise only */
 944 
 945   /**
 946    * Locate in this the first occurrence of the characters in &lt;TT&gt;text&lt;/TT&gt;,
 947    * using bitwise comparison.
 948    * @param text The text to search for.
 949    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
 950    * or -1 if not found.
 951    * @stable ICU 2.0
 952    */
 953   inline int32_t indexOf(const UnicodeString&amp; text) const;
 954 
 955   /**
 956    * Locate in this the first occurrence of the characters in &lt;TT&gt;text&lt;/TT&gt;
 957    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.
 958    * @param text The text to search for.
 959    * @param start The offset at which searching will start.
 960    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
 961    * or -1 if not found.
 962    * @stable ICU 2.0
 963    */
 964   inline int32_t indexOf(const UnicodeString&amp; text,
 965               int32_t start) const;
 966 
 967   /**
 968    * Locate in this the first occurrence in the range
 969    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters
 970    * in &lt;TT&gt;text&lt;/TT&gt;, using bitwise comparison.
 971    * @param text The text to search for.
 972    * @param start The offset at which searching will start.
 973    * @param length The number of characters to search
 974    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
 975    * or -1 if not found.
 976    * @stable ICU 2.0
 977    */
 978   inline int32_t indexOf(const UnicodeString&amp; text,
 979               int32_t start,
 980               int32_t length) const;
 981 
 982   /**
 983    * Locate in this the first occurrence in the range
 984    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters
 985    *  in &lt;TT&gt;srcText&lt;/TT&gt; in the range
 986    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;),
 987    * using bitwise comparison.
 988    * @param srcText The text to search for.
 989    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; at which
 990    * to start matching
 991    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; to match
 992    * @param start the offset into this at which to start matching
 993    * @param length the number of characters in this to search
 994    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
 995    * or -1 if not found.
 996    * @stable ICU 2.0
 997    */
 998   inline int32_t indexOf(const UnicodeString&amp; srcText,
 999               int32_t srcStart,
1000               int32_t srcLength,
1001               int32_t start,
1002               int32_t length) const;
1003 
1004   /**
1005    * Locate in this the first occurrence of the characters in
1006    * &lt;TT&gt;srcChars&lt;/TT&gt;
1007    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.
1008    * @param srcChars The text to search for.
1009    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match
1010    * @param start the offset into this at which to start matching
1011    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
1012    * or -1 if not found.
1013    * @stable ICU 2.0
1014    */
1015   inline int32_t indexOf(const char16_t *srcChars,
1016               int32_t srcLength,
1017               int32_t start) const;
1018 
1019   /**
1020    * Locate in this the first occurrence in the range
1021    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters
1022    * in &lt;TT&gt;srcChars&lt;/TT&gt;, using bitwise comparison.
1023    * @param srcChars The text to search for.
1024    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;
1025    * @param start The offset at which searching will start.
1026    * @param length The number of characters to search
1027    * @return The offset into this of the start of &lt;TT&gt;srcChars&lt;/TT&gt;,
1028    * or -1 if not found.
1029    * @stable ICU 2.0
1030    */
1031   inline int32_t indexOf(ConstChar16Ptr srcChars,
1032               int32_t srcLength,
1033               int32_t start,
1034               int32_t length) const;
1035 
1036   /**
1037    * Locate in this the first occurrence in the range
1038    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters
1039    * in &lt;TT&gt;srcChars&lt;/TT&gt; in the range
1040    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;),
1041    * using bitwise comparison.
1042    * @param srcChars The text to search for.
1043    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; at which
1044    * to start matching
1045    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match
1046    * @param start the offset into this at which to start matching
1047    * @param length the number of characters in this to search
1048    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
1049    * or -1 if not found.
1050    * @stable ICU 2.0
1051    */
1052   int32_t indexOf(const char16_t *srcChars,
1053               int32_t srcStart,
1054               int32_t srcLength,
1055               int32_t start,
1056               int32_t length) const;
1057 
1058   /**
1059    * Locate in this the first occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;,
1060    * using bitwise comparison.
1061    * @param c The code unit to search for.
1062    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1063    * @stable ICU 2.0
1064    */
1065   inline int32_t indexOf(char16_t c) const;
1066 
1067   /**
1068    * Locate in this the first occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;,
1069    * using bitwise comparison.
1070    *
1071    * @param c The code point to search for.
1072    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1073    * @stable ICU 2.0
1074    */
1075   inline int32_t indexOf(UChar32 c) const;
1076 
1077   /**
1078    * Locate in this the first occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;,
1079    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.
1080    * @param c The code unit to search for.
1081    * @param start The offset at which searching will start.
1082    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1083    * @stable ICU 2.0
1084    */
1085   inline int32_t indexOf(char16_t c,
1086               int32_t start) const;
1087 
1088   /**
1089    * Locate in this the first occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;
1090    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.
1091    *
1092    * @param c The code point to search for.
1093    * @param start The offset at which searching will start.
1094    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1095    * @stable ICU 2.0
1096    */
1097   inline int32_t indexOf(UChar32 c,
1098               int32_t start) const;
1099 
1100   /**
1101    * Locate in this the first occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;
1102    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;),
1103    * using bitwise comparison.
1104    * @param c The code unit to search for.
1105    * @param start the offset into this at which to start matching
1106    * @param length the number of characters in this to search
1107    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1108    * @stable ICU 2.0
1109    */
1110   inline int32_t indexOf(char16_t c,
1111               int32_t start,
1112               int32_t length) const;
1113 
1114   /**
1115    * Locate in this the first occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;
1116    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;),
1117    * using bitwise comparison.
1118    *
1119    * @param c The code point to search for.
1120    * @param start the offset into this at which to start matching
1121    * @param length the number of characters in this to search
1122    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1123    * @stable ICU 2.0
1124    */
1125   inline int32_t indexOf(UChar32 c,
1126               int32_t start,
1127               int32_t length) const;
1128 
1129   /**
1130    * Locate in this the last occurrence of the characters in &lt;TT&gt;text&lt;/TT&gt;,
1131    * using bitwise comparison.
1132    * @param text The text to search for.
1133    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
1134    * or -1 if not found.
1135    * @stable ICU 2.0
1136    */
1137   inline int32_t lastIndexOf(const UnicodeString&amp; text) const;
1138 
1139   /**
1140    * Locate in this the last occurrence of the characters in &lt;TT&gt;text&lt;/TT&gt;
1141    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.
1142    * @param text The text to search for.
1143    * @param start The offset at which searching will start.
1144    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
1145    * or -1 if not found.
1146    * @stable ICU 2.0
1147    */
1148   inline int32_t lastIndexOf(const UnicodeString&amp; text,
1149               int32_t start) const;
1150 
1151   /**
1152    * Locate in this the last occurrence in the range
1153    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters
1154    * in &lt;TT&gt;text&lt;/TT&gt;, using bitwise comparison.
1155    * @param text The text to search for.
1156    * @param start The offset at which searching will start.
1157    * @param length The number of characters to search
1158    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
1159    * or -1 if not found.
1160    * @stable ICU 2.0
1161    */
1162   inline int32_t lastIndexOf(const UnicodeString&amp; text,
1163               int32_t start,
1164               int32_t length) const;
1165 
1166   /**
1167    * Locate in this the last occurrence in the range
1168    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters
1169    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range
1170    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;),
1171    * using bitwise comparison.
1172    * @param srcText The text to search for.
1173    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; at which
1174    * to start matching
1175    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; to match
1176    * @param start the offset into this at which to start matching
1177    * @param length the number of characters in this to search
1178    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
1179    * or -1 if not found.
1180    * @stable ICU 2.0
1181    */
1182   inline int32_t lastIndexOf(const UnicodeString&amp; srcText,
1183               int32_t srcStart,
1184               int32_t srcLength,
1185               int32_t start,
1186               int32_t length) const;
1187 
1188   /**
1189    * Locate in this the last occurrence of the characters in &lt;TT&gt;srcChars&lt;/TT&gt;
1190    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.
1191    * @param srcChars The text to search for.
1192    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match
1193    * @param start the offset into this at which to start matching
1194    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
1195    * or -1 if not found.
1196    * @stable ICU 2.0
1197    */
1198   inline int32_t lastIndexOf(const char16_t *srcChars,
1199               int32_t srcLength,
1200               int32_t start) const;
1201 
1202   /**
1203    * Locate in this the last occurrence in the range
1204    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters
1205    * in &lt;TT&gt;srcChars&lt;/TT&gt;, using bitwise comparison.
1206    * @param srcChars The text to search for.
1207    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;
1208    * @param start The offset at which searching will start.
1209    * @param length The number of characters to search
1210    * @return The offset into this of the start of &lt;TT&gt;srcChars&lt;/TT&gt;,
1211    * or -1 if not found.
1212    * @stable ICU 2.0
1213    */
1214   inline int32_t lastIndexOf(ConstChar16Ptr srcChars,
1215               int32_t srcLength,
1216               int32_t start,
1217               int32_t length) const;
1218 
1219   /**
1220    * Locate in this the last occurrence in the range
1221    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters
1222    * in &lt;TT&gt;srcChars&lt;/TT&gt; in the range
1223    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;),
1224    * using bitwise comparison.
1225    * @param srcChars The text to search for.
1226    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; at which
1227    * to start matching
1228    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match
1229    * @param start the offset into this at which to start matching
1230    * @param length the number of characters in this to search
1231    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,
1232    * or -1 if not found.
1233    * @stable ICU 2.0
1234    */
1235   int32_t lastIndexOf(const char16_t *srcChars,
1236               int32_t srcStart,
1237               int32_t srcLength,
1238               int32_t start,
1239               int32_t length) const;
1240 
1241   /**
1242    * Locate in this the last occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;,
1243    * using bitwise comparison.
1244    * @param c The code unit to search for.
1245    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1246    * @stable ICU 2.0
1247    */
1248   inline int32_t lastIndexOf(char16_t c) const;
1249 
1250   /**
1251    * Locate in this the last occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;,
1252    * using bitwise comparison.
1253    *
1254    * @param c The code point to search for.
1255    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1256    * @stable ICU 2.0
1257    */
1258   inline int32_t lastIndexOf(UChar32 c) const;
1259 
1260   /**
1261    * Locate in this the last occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;
1262    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.
1263    * @param c The code unit to search for.
1264    * @param start The offset at which searching will start.
1265    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1266    * @stable ICU 2.0
1267    */
1268   inline int32_t lastIndexOf(char16_t c,
1269               int32_t start) const;
1270 
1271   /**
1272    * Locate in this the last occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;
1273    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.
1274    *
1275    * @param c The code point to search for.
1276    * @param start The offset at which searching will start.
1277    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1278    * @stable ICU 2.0
1279    */
1280   inline int32_t lastIndexOf(UChar32 c,
1281               int32_t start) const;
1282 
1283   /**
1284    * Locate in this the last occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;
1285    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;),
1286    * using bitwise comparison.
1287    * @param c The code unit to search for.
1288    * @param start the offset into this at which to start matching
1289    * @param length the number of characters in this to search
1290    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1291    * @stable ICU 2.0
1292    */
1293   inline int32_t lastIndexOf(char16_t c,
1294               int32_t start,
1295               int32_t length) const;
1296 
1297   /**
1298    * Locate in this the last occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;
1299    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;),
1300    * using bitwise comparison.
1301    *
1302    * @param c The code point to search for.
1303    * @param start the offset into this at which to start matching
1304    * @param length the number of characters in this to search
1305    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.
1306    * @stable ICU 2.0
1307    */
1308   inline int32_t lastIndexOf(UChar32 c,
1309               int32_t start,
1310               int32_t length) const;
1311 
1312 
1313   /* Character access */
1314 
1315   /**
1316    * Return the code unit at offset &lt;tt&gt;offset&lt;/tt&gt;.
1317    * If the offset is not valid (0..length()-1) then U+ffff is returned.
1318    * @param offset a valid offset into the text
1319    * @return the code unit at offset &lt;tt&gt;offset&lt;/tt&gt;
1320    *         or 0xffff if the offset is not valid for this string
1321    * @stable ICU 2.0
1322    */
1323   inline char16_t charAt(int32_t offset) const;
1324 
1325   /**
1326    * Return the code unit at offset &lt;tt&gt;offset&lt;/tt&gt;.
1327    * If the offset is not valid (0..length()-1) then U+ffff is returned.
1328    * @param offset a valid offset into the text
1329    * @return the code unit at offset &lt;tt&gt;offset&lt;/tt&gt;
1330    * @stable ICU 2.0
1331    */
1332   inline char16_t operator[] (int32_t offset) const;
1333 
1334   /**
1335    * Return the code point that contains the code unit
1336    * at offset &lt;tt&gt;offset&lt;/tt&gt;.
1337    * If the offset is not valid (0..length()-1) then U+ffff is returned.
1338    * @param offset a valid offset into the text
1339    * that indicates the text offset of any of the code units
1340    * that will be assembled into a code point (21-bit value) and returned
1341    * @return the code point of text at &lt;tt&gt;offset&lt;/tt&gt;
1342    *         or 0xffff if the offset is not valid for this string
1343    * @stable ICU 2.0
1344    */
1345   UChar32 char32At(int32_t offset) const;
1346 
1347   /**
1348    * Adjust a random-access offset so that
1349    * it points to the beginning of a Unicode character.
1350    * The offset that is passed in points to
1351    * any code unit of a code point,
1352    * while the returned offset will point to the first code unit
1353    * of the same code point.
1354    * In UTF-16, if the input offset points to a second surrogate
1355    * of a surrogate pair, then the returned offset will point
1356    * to the first surrogate.
1357    * @param offset a valid offset into one code point of the text
1358    * @return offset of the first code unit of the same code point
1359    * @see U16_SET_CP_START
1360    * @stable ICU 2.0
1361    */
1362   int32_t getChar32Start(int32_t offset) const;
1363 
1364   /**
1365    * Adjust a random-access offset so that
1366    * it points behind a Unicode character.
1367    * The offset that is passed in points behind
1368    * any code unit of a code point,
1369    * while the returned offset will point behind the last code unit
1370    * of the same code point.
1371    * In UTF-16, if the input offset points behind the first surrogate
1372    * (i.e., to the second surrogate)
1373    * of a surrogate pair, then the returned offset will point
1374    * behind the second surrogate (i.e., to the first surrogate).
1375    * @param offset a valid offset after any code unit of a code point of the text
1376    * @return offset of the first code unit after the same code point
1377    * @see U16_SET_CP_LIMIT
1378    * @stable ICU 2.0
1379    */
1380   int32_t getChar32Limit(int32_t offset) const;
1381 
1382   /**
1383    * Move the code unit index along the string by delta code points.
1384    * Interpret the input index as a code unit-based offset into the string,
1385    * move the index forward or backward by delta code points, and
1386    * return the resulting index.
1387    * The input index should point to the first code unit of a code point,
1388    * if there is more than one.
1389    *
1390    * Both input and output indexes are code unit-based as for all
1391    * string indexes/offsets in ICU (and other libraries, like MBCS char*).
1392    * If delta&lt;0 then the index is moved backward (toward the start of the string).
1393    * If delta&gt;0 then the index is moved forward (toward the end of the string).
1394    *
1395    * This behaves like CharacterIterator::move32(delta, kCurrent).
1396    *
1397    * Behavior for out-of-bounds indexes:
1398    * &lt;code&gt;moveIndex32&lt;/code&gt; pins the input index to 0..length(), i.e.,
1399    * if the input index&lt;0 then it is pinned to 0;
1400    * if it is index&gt;length() then it is pinned to length().
1401    * Afterwards, the index is moved by &lt;code&gt;delta&lt;/code&gt; code points
1402    * forward or backward,
1403    * but no further backward than to 0 and no further forward than to length().
1404    * The resulting index return value will be in between 0 and length(), inclusively.
1405    *
1406    * Examples:
1407    * &lt;pre&gt;
1408    * // s has code points &#39;a&#39; U+10000 &#39;b&#39; U+10ffff U+2029
1409    * UnicodeString s=UNICODE_STRING(&quot;a\\U00010000b\\U0010ffff\\u2029&quot;, 31).unescape();
1410    *
1411    * // initial index: position of U+10000
1412    * int32_t index=1;
1413    *
1414    * // the following examples will all result in index==4, position of U+10ffff
1415    *
1416    * // skip 2 code points from some position in the string
1417    * index=s.moveIndex32(index, 2); // skips U+10000 and &#39;b&#39;
1418    *
1419    * // go to the 3rd code point from the start of s (0-based)
1420    * index=s.moveIndex32(0, 3); // skips &#39;a&#39;, U+10000, and &#39;b&#39;
1421    *
1422    * // go to the next-to-last code point of s
1423    * index=s.moveIndex32(s.length(), -2); // backward-skips U+2029 and U+10ffff
1424    * &lt;/pre&gt;
1425    *
1426    * @param index input code unit index
1427    * @param delta (signed) code point count to move the index forward or backward
1428    *        in the string
1429    * @return the resulting code unit index
1430    * @stable ICU 2.0
1431    */
1432   int32_t moveIndex32(int32_t index, int32_t delta) const;
1433 
1434   /* Substring extraction */
1435 
1436   /**
1437    * Copy the characters in the range
1438    * [&lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;start + length&lt;/tt&gt;) into the array &lt;tt&gt;dst&lt;/tt&gt;,
1439    * beginning at &lt;tt&gt;dstStart&lt;/tt&gt;.
1440    * If the string aliases to &lt;code&gt;dst&lt;/code&gt; itself as an external buffer,
1441    * then extract() will not copy the contents.
1442    *
1443    * @param start offset of first character which will be copied into the array
1444    * @param length the number of characters to extract
1445    * @param dst array in which to copy characters.  The length of &lt;tt&gt;dst&lt;/tt&gt;
1446    * must be at least (&lt;tt&gt;dstStart + length&lt;/tt&gt;).
1447    * @param dstStart the offset in &lt;TT&gt;dst&lt;/TT&gt; where the first character
1448    * will be extracted
1449    * @stable ICU 2.0
1450    */
1451   inline void extract(int32_t start,
1452            int32_t length,
1453            Char16Ptr dst,
1454            int32_t dstStart = 0) const;
1455 
1456   /**
1457    * Copy the contents of the string into dest.
1458    * This is a convenience function that
1459    * checks if there is enough space in dest,
1460    * extracts the entire string if possible,
1461    * and NUL-terminates dest if possible.
1462    *
1463    * If the string fits into dest but cannot be NUL-terminated
1464    * (length()==destCapacity) then the error code is set to U_STRING_NOT_TERMINATED_WARNING.
1465    * If the string itself does not fit into dest
1466    * (length()&gt;destCapacity) then the error code is set to U_BUFFER_OVERFLOW_ERROR.
1467    *
1468    * If the string aliases to &lt;code&gt;dest&lt;/code&gt; itself as an external buffer,
1469    * then extract() will not copy the contents.
1470    *
1471    * @param dest Destination string buffer.
1472    * @param destCapacity Number of char16_ts available at dest.
1473    * @param errorCode ICU error code.
1474    * @return length()
1475    * @stable ICU 2.0
1476    */
1477   int32_t
1478   extract(Char16Ptr dest, int32_t destCapacity,
1479           UErrorCode &amp;errorCode) const;
1480 
1481   /**
1482    * Copy the characters in the range
1483    * [&lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;start + length&lt;/tt&gt;) into the  UnicodeString
1484    * &lt;tt&gt;target&lt;/tt&gt;.
1485    * @param start offset of first character which will be copied
1486    * @param length the number of characters to extract
1487    * @param target UnicodeString into which to copy characters.
1488    * @return A reference to &lt;TT&gt;target&lt;/TT&gt;
1489    * @stable ICU 2.0
1490    */
1491   inline void extract(int32_t start,
1492            int32_t length,
1493            UnicodeString&amp; target) const;
1494 
1495   /**
1496    * Copy the characters in the range [&lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;limit&lt;/tt&gt;)
1497    * into the array &lt;tt&gt;dst&lt;/tt&gt;, beginning at &lt;tt&gt;dstStart&lt;/tt&gt;.
1498    * @param start offset of first character which will be copied into the array
1499    * @param limit offset immediately following the last character to be copied
1500    * @param dst array in which to copy characters.  The length of &lt;tt&gt;dst&lt;/tt&gt;
1501    * must be at least (&lt;tt&gt;dstStart + (limit - start)&lt;/tt&gt;).
1502    * @param dstStart the offset in &lt;TT&gt;dst&lt;/TT&gt; where the first character
1503    * will be extracted
1504    * @stable ICU 2.0
1505    */
1506   inline void extractBetween(int32_t start,
1507               int32_t limit,
1508               char16_t *dst,
1509               int32_t dstStart = 0) const;
1510 
1511   /**
1512    * Copy the characters in the range [&lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;limit&lt;/tt&gt;)
1513    * into the UnicodeString &lt;tt&gt;target&lt;/tt&gt;.  Replaceable API.
1514    * @param start offset of first character which will be copied
1515    * @param limit offset immediately following the last character to be copied
1516    * @param target UnicodeString into which to copy characters.
1517    * @return A reference to &lt;TT&gt;target&lt;/TT&gt;
1518    * @stable ICU 2.0
1519    */
1520   virtual void extractBetween(int32_t start,
1521               int32_t limit,
1522               UnicodeString&amp; target) const;
1523 
1524   /**
1525    * Copy the characters in the range
1526    * [&lt;tt&gt;start&lt;/TT&gt;, &lt;tt&gt;start + startLength&lt;/TT&gt;) into an array of characters.
1527    * All characters must be invariant (see utypes.h).
1528    * Use US_INV as the last, signature-distinguishing parameter.
1529    *
1530    * This function does not write any more than &lt;code&gt;targetCapacity&lt;/code&gt;
1531    * characters but returns the length of the entire output string
1532    * so that one can allocate a larger buffer and call the function again
1533    * if necessary.
1534    * The output string is NUL-terminated if possible.
1535    *
1536    * @param start offset of first character which will be copied
1537    * @param startLength the number of characters to extract
1538    * @param target the target buffer for extraction, can be NULL
1539    *               if targetLength is 0
1540    * @param targetCapacity the length of the target buffer
1541    * @param inv Signature-distinguishing paramater, use US_INV.
1542    * @return the output string length, not including the terminating NUL
1543    * @stable ICU 3.2
1544    */
1545   int32_t extract(int32_t start,
1546            int32_t startLength,
1547            char *target,
1548            int32_t targetCapacity,
1549            enum EInvariant inv) const;
1550 
1551 #if U_CHARSET_IS_UTF8 || !UCONFIG_NO_CONVERSION
1552 
1553   /**
1554    * Copy the characters in the range
1555    * [&lt;tt&gt;start&lt;/TT&gt;, &lt;tt&gt;start + length&lt;/TT&gt;) into an array of characters
1556    * in the platform&#39;s default codepage.
1557    * This function does not write any more than &lt;code&gt;targetLength&lt;/code&gt;
1558    * characters but returns the length of the entire output string
1559    * so that one can allocate a larger buffer and call the function again
1560    * if necessary.
1561    * The output string is NUL-terminated if possible.
1562    *
1563    * @param start offset of first character which will be copied
1564    * @param startLength the number of characters to extract
1565    * @param target the target buffer for extraction
1566    * @param targetLength the length of the target buffer
1567    * If &lt;TT&gt;target&lt;/TT&gt; is NULL, then the number of bytes required for
1568    * &lt;TT&gt;target&lt;/TT&gt; is returned.
1569    * @return the output string length, not including the terminating NUL
1570    * @stable ICU 2.0
1571    */
1572   int32_t extract(int32_t start,
1573            int32_t startLength,
1574            char *target,
1575            uint32_t targetLength) const;
1576 
1577 #endif
1578 
1579 #if !UCONFIG_NO_CONVERSION
1580 
1581   /**
1582    * Copy the characters in the range
1583    * [&lt;tt&gt;start&lt;/TT&gt;, &lt;tt&gt;start + length&lt;/TT&gt;) into an array of characters
1584    * in a specified codepage.
1585    * The output string is NUL-terminated.
1586    *
1587    * Recommendation: For invariant-character strings use
1588    * extract(int32_t start, int32_t length, char *target, int32_t targetCapacity, enum EInvariant inv) const
1589    * because it avoids object code dependencies of UnicodeString on
1590    * the conversion code.
1591    *
1592    * @param start offset of first character which will be copied
1593    * @param startLength the number of characters to extract
1594    * @param target the target buffer for extraction
1595    * @param codepage the desired codepage for the characters.  0 has
1596    * the special meaning of the default codepage
1597    * If &lt;code&gt;codepage&lt;/code&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),
1598    * then a simple conversion is performed on the codepage-invariant
1599    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
1600    * If &lt;TT&gt;target&lt;/TT&gt; is NULL, then the number of bytes required for
1601    * &lt;TT&gt;target&lt;/TT&gt; is returned. It is assumed that the target is big enough
1602    * to fit all of the characters.
1603    * @return the output string length, not including the terminating NUL
1604    * @stable ICU 2.0
1605    */
1606   inline int32_t extract(int32_t start,
1607                  int32_t startLength,
1608                  char *target,
1609                  const char *codepage = 0) const;
1610 
1611   /**
1612    * Copy the characters in the range
1613    * [&lt;tt&gt;start&lt;/TT&gt;, &lt;tt&gt;start + length&lt;/TT&gt;) into an array of characters
1614    * in a specified codepage.
1615    * This function does not write any more than &lt;code&gt;targetLength&lt;/code&gt;
1616    * characters but returns the length of the entire output string
1617    * so that one can allocate a larger buffer and call the function again
1618    * if necessary.
1619    * The output string is NUL-terminated if possible.
1620    *
1621    * Recommendation: For invariant-character strings use
1622    * extract(int32_t start, int32_t length, char *target, int32_t targetCapacity, enum EInvariant inv) const
1623    * because it avoids object code dependencies of UnicodeString on
1624    * the conversion code.
1625    *
1626    * @param start offset of first character which will be copied
1627    * @param startLength the number of characters to extract
1628    * @param target the target buffer for extraction
1629    * @param targetLength the length of the target buffer
1630    * @param codepage the desired codepage for the characters.  0 has
1631    * the special meaning of the default codepage
1632    * If &lt;code&gt;codepage&lt;/code&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),
1633    * then a simple conversion is performed on the codepage-invariant
1634    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
1635    * If &lt;TT&gt;target&lt;/TT&gt; is NULL, then the number of bytes required for
1636    * &lt;TT&gt;target&lt;/TT&gt; is returned.
1637    * @return the output string length, not including the terminating NUL
1638    * @stable ICU 2.0
1639    */
1640   int32_t extract(int32_t start,
1641            int32_t startLength,
1642            char *target,
1643            uint32_t targetLength,
1644            const char *codepage) const;
1645 
1646   /**
1647    * Convert the UnicodeString into a codepage string using an existing UConverter.
1648    * The output string is NUL-terminated if possible.
1649    *
1650    * This function avoids the overhead of opening and closing a converter if
1651    * multiple strings are extracted.
1652    *
1653    * @param dest destination string buffer, can be NULL if destCapacity==0
1654    * @param destCapacity the number of chars available at dest
1655    * @param cnv the converter object to be used (ucnv_resetFromUnicode() will be called),
1656    *        or NULL for the default converter
1657    * @param errorCode normal ICU error code
1658    * @return the length of the output string, not counting the terminating NUL;
1659    *         if the length is greater than destCapacity, then the string will not fit
1660    *         and a buffer of the indicated length would need to be passed in
1661    * @stable ICU 2.0
1662    */
1663   int32_t extract(char *dest, int32_t destCapacity,
1664                   UConverter *cnv,
1665                   UErrorCode &amp;errorCode) const;
1666 
1667 #endif
1668 
1669   /**
1670    * Create a temporary substring for the specified range.
1671    * Unlike the substring constructor and setTo() functions,
1672    * the object returned here will be a read-only alias (using getBuffer())
1673    * rather than copying the text.
1674    * As a result, this substring operation is much faster but requires
1675    * that the original string not be modified or deleted during the lifetime
1676    * of the returned substring object.
1677    * @param start offset of the first character visible in the substring
1678    * @param length length of the substring
1679    * @return a read-only alias UnicodeString object for the substring
1680    * @stable ICU 4.4
1681    */
1682   UnicodeString tempSubString(int32_t start=0, int32_t length=INT32_MAX) const;
1683 
1684   /**
1685    * Create a temporary substring for the specified range.
1686    * Same as tempSubString(start, length) except that the substring range
1687    * is specified as a (start, limit) pair (with an exclusive limit index)
1688    * rather than a (start, length) pair.
1689    * @param start offset of the first character visible in the substring
1690    * @param limit offset immediately following the last character visible in the substring
1691    * @return a read-only alias UnicodeString object for the substring
1692    * @stable ICU 4.4
1693    */
1694   inline UnicodeString tempSubStringBetween(int32_t start, int32_t limit=INT32_MAX) const;
1695 
1696   /**
1697    * Convert the UnicodeString to UTF-8 and write the result
1698    * to a ByteSink. This is called by toUTF8String().
1699    * Unpaired surrogates are replaced with U+FFFD.
1700    * Calls u_strToUTF8WithSub().
1701    *
1702    * @param sink A ByteSink to which the UTF-8 version of the string is written.
1703    *             sink.Flush() is called at the end.
1704    * @stable ICU 4.2
1705    * @see toUTF8String
1706    */
1707   void toUTF8(ByteSink &amp;sink) const;
1708 
1709   /**
1710    * Convert the UnicodeString to UTF-8 and append the result
1711    * to a standard string.
1712    * Unpaired surrogates are replaced with U+FFFD.
1713    * Calls toUTF8().
1714    *
1715    * @param result A standard string (or a compatible object)
1716    *        to which the UTF-8 version of the string is appended.
1717    * @return The string object.
1718    * @stable ICU 4.2
1719    * @see toUTF8
1720    */
1721   template&lt;typename StringClass&gt;
1722   StringClass &amp;toUTF8String(StringClass &amp;result) const {
1723     StringByteSink&lt;StringClass&gt; sbs(&amp;result, length());
1724     toUTF8(sbs);
1725     return result;
1726   }
1727 
1728   /**
1729    * Convert the UnicodeString to UTF-32.
1730    * Unpaired surrogates are replaced with U+FFFD.
1731    * Calls u_strToUTF32WithSub().
1732    *
1733    * @param utf32 destination string buffer, can be NULL if capacity==0
1734    * @param capacity the number of UChar32s available at utf32
1735    * @param errorCode Standard ICU error code. Its input value must
1736    *                  pass the U_SUCCESS() test, or else the function returns
1737    *                  immediately. Check for U_FAILURE() on output or use with
1738    *                  function chaining. (See User Guide for details.)
1739    * @return The length of the UTF-32 string.
1740    * @see fromUTF32
1741    * @stable ICU 4.2
1742    */
1743   int32_t toUTF32(UChar32 *utf32, int32_t capacity, UErrorCode &amp;errorCode) const;
1744 
1745   /* Length operations */
1746 
1747   /**
1748    * Return the length of the UnicodeString object.
1749    * The length is the number of char16_t code units are in the UnicodeString.
1750    * If you want the number of code points, please use countChar32().
1751    * @return the length of the UnicodeString object
1752    * @see countChar32
1753    * @stable ICU 2.0
1754    */
1755   inline int32_t length(void) const;
1756 
1757   /**
1758    * Count Unicode code points in the length char16_t code units of the string.
1759    * A code point may occupy either one or two char16_t code units.
1760    * Counting code points involves reading all code units.
1761    *
1762    * This functions is basically the inverse of moveIndex32().
1763    *
1764    * @param start the index of the first code unit to check
1765    * @param length the number of char16_t code units to check
1766    * @return the number of code points in the specified code units
1767    * @see length
1768    * @stable ICU 2.0
1769    */
1770   int32_t
1771   countChar32(int32_t start=0, int32_t length=INT32_MAX) const;
1772 
1773   /**
1774    * Check if the length char16_t code units of the string
1775    * contain more Unicode code points than a certain number.
1776    * This is more efficient than counting all code points in this part of the string
1777    * and comparing that number with a threshold.
1778    * This function may not need to scan the string at all if the length
1779    * falls within a certain range, and
1780    * never needs to count more than &#39;number+1&#39; code points.
1781    * Logically equivalent to (countChar32(start, length)&gt;number).
1782    * A Unicode code point may occupy either one or two char16_t code units.
1783    *
1784    * @param start the index of the first code unit to check (0 for the entire string)
1785    * @param length the number of char16_t code units to check
1786    *               (use INT32_MAX for the entire string; remember that start/length
1787    *                values are pinned)
1788    * @param number The number of code points in the (sub)string is compared against
1789    *               the &#39;number&#39; parameter.
1790    * @return Boolean value for whether the string contains more Unicode code points
1791    *         than &#39;number&#39;. Same as (u_countChar32(s, length)&gt;number).
1792    * @see countChar32
1793    * @see u_strHasMoreChar32Than
1794    * @stable ICU 2.4
1795    */
1796   UBool
1797   hasMoreChar32Than(int32_t start, int32_t length, int32_t number) const;
1798 
1799   /**
1800    * Determine if this string is empty.
1801    * @return TRUE if this string contains 0 characters, FALSE otherwise.
1802    * @stable ICU 2.0
1803    */
1804   inline UBool isEmpty(void) const;
1805 
1806   /**
1807    * Return the capacity of the internal buffer of the UnicodeString object.
1808    * This is useful together with the getBuffer functions.
1809    * See there for details.
1810    *
1811    * @return the number of char16_ts available in the internal buffer
1812    * @see getBuffer
1813    * @stable ICU 2.0
1814    */
1815   inline int32_t getCapacity(void) const;
1816 
1817   /* Other operations */
1818 
1819   /**
1820    * Generate a hash code for this object.
1821    * @return The hash code of this UnicodeString.
1822    * @stable ICU 2.0
1823    */
1824   inline int32_t hashCode(void) const;
1825 
1826   /**
1827    * Determine if this object contains a valid string.
1828    * A bogus string has no value. It is different from an empty string,
1829    * although in both cases isEmpty() returns TRUE and length() returns 0.
1830    * setToBogus() and isBogus() can be used to indicate that no string value is available.
1831    * For a bogus string, getBuffer() and getTerminatedBuffer() return NULL, and
1832    * length() returns 0.
1833    *
1834    * @return TRUE if the string is bogus/invalid, FALSE otherwise
1835    * @see setToBogus()
1836    * @stable ICU 2.0
1837    */
1838   inline UBool isBogus(void) const;
1839 
1840 
1841   //========================================
1842   // Write operations
1843   //========================================
1844 
1845   /* Assignment operations */
1846 
1847   /**
1848    * Assignment operator.  Replace the characters in this UnicodeString
1849    * with the characters from &lt;TT&gt;srcText&lt;/TT&gt;.
1850    *
1851    * Starting with ICU 2.4, the assignment operator and the copy constructor
1852    * allocate a new buffer and copy the buffer contents even for readonly aliases.
1853    * By contrast, the fastCopyFrom() function implements the old,
1854    * more efficient but less safe behavior
1855    * of making this string also a readonly alias to the same buffer.
1856    *
1857    * If the source object has an &quot;open&quot; buffer from getBuffer(minCapacity),
1858    * then the copy is an empty string.
1859    *
1860    * @param srcText The text containing the characters to replace
1861    * @return a reference to this
1862    * @stable ICU 2.0
1863    * @see fastCopyFrom
1864    */
1865   UnicodeString &amp;operator=(const UnicodeString &amp;srcText);
1866 
1867   /**
1868    * Almost the same as the assignment operator.
1869    * Replace the characters in this UnicodeString
1870    * with the characters from &lt;code&gt;srcText&lt;/code&gt;.
1871    *
1872    * This function works the same as the assignment operator
1873    * for all strings except for ones that are readonly aliases.
1874    *
1875    * Starting with ICU 2.4, the assignment operator and the copy constructor
1876    * allocate a new buffer and copy the buffer contents even for readonly aliases.
1877    * This function implements the old, more efficient but less safe behavior
1878    * of making this string also a readonly alias to the same buffer.
1879    *
1880    * The fastCopyFrom function must be used only if it is known that the lifetime of
1881    * this UnicodeString does not exceed the lifetime of the aliased buffer
1882    * including its contents, for example for strings from resource bundles
1883    * or aliases to string constants.
1884    *
1885    * If the source object has an &quot;open&quot; buffer from getBuffer(minCapacity),
1886    * then the copy is an empty string.
1887    *
1888    * @param src The text containing the characters to replace.
1889    * @return a reference to this
1890    * @stable ICU 2.4
1891    */
1892   UnicodeString &amp;fastCopyFrom(const UnicodeString &amp;src);
1893 
1894   /**
1895    * Move assignment operator; might leave src in bogus state.
1896    * This string will have the same contents and state that the source string had.
1897    * The behavior is undefined if *this and src are the same object.
1898    * @param src source string
1899    * @return *this
1900    * @stable ICU 56
1901    */
1902   UnicodeString &amp;operator=(UnicodeString &amp;&amp;src) U_NOEXCEPT {
1903     return moveFrom(src);
1904   }
1905 
1906   // do not use #ifndef U_HIDE_DRAFT_API for moveFrom, needed by non-draft API
1907   /**
1908    * Move assignment; might leave src in bogus state.
1909    * This string will have the same contents and state that the source string had.
1910    * The behavior is undefined if *this and src are the same object.
1911    *
1912    * Can be called explicitly, does not need C++11 support.
1913    * @param src source string
1914    * @return *this
1915    * @draft ICU 56
1916    */
1917   UnicodeString &amp;moveFrom(UnicodeString &amp;src) U_NOEXCEPT;
1918 
1919   /**
1920    * Swap strings.
1921    * @param other other string
1922    * @stable ICU 56
1923    */
1924   void swap(UnicodeString &amp;other) U_NOEXCEPT;
1925 
1926   /**
1927    * Non-member UnicodeString swap function.
1928    * @param s1 will get s2&#39;s contents and state
1929    * @param s2 will get s1&#39;s contents and state
1930    * @stable ICU 56
1931    */
1932   friend U_COMMON_API inline void U_EXPORT2
1933   swap(UnicodeString &amp;s1, UnicodeString &amp;s2) U_NOEXCEPT {
1934     s1.swap(s2);
1935   }
1936 
1937   /**
1938    * Assignment operator.  Replace the characters in this UnicodeString
1939    * with the code unit &lt;TT&gt;ch&lt;/TT&gt;.
1940    * @param ch the code unit to replace
1941    * @return a reference to this
1942    * @stable ICU 2.0
1943    */
1944   inline UnicodeString&amp; operator= (char16_t ch);
1945 
1946   /**
1947    * Assignment operator.  Replace the characters in this UnicodeString
1948    * with the code point &lt;TT&gt;ch&lt;/TT&gt;.
1949    * @param ch the code point to replace
1950    * @return a reference to this
1951    * @stable ICU 2.0
1952    */
1953   inline UnicodeString&amp; operator= (UChar32 ch);
1954 
1955   /**
1956    * Set the text in the UnicodeString object to the characters
1957    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range
1958    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcText.length()&lt;/TT&gt;).
1959    * &lt;TT&gt;srcText&lt;/TT&gt; is not modified.
1960    * @param srcText the source for the new characters
1961    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; where new characters
1962    * will be obtained
1963    * @return a reference to this
1964    * @stable ICU 2.2
1965    */
1966   inline UnicodeString&amp; setTo(const UnicodeString&amp; srcText,
1967                int32_t srcStart);
1968 
1969   /**
1970    * Set the text in the UnicodeString object to the characters
1971    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range
1972    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).
1973    * &lt;TT&gt;srcText&lt;/TT&gt; is not modified.
1974    * @param srcText the source for the new characters
1975    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; where new characters
1976    * will be obtained
1977    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; in the
1978    * replace string.
1979    * @return a reference to this
1980    * @stable ICU 2.0
1981    */
1982   inline UnicodeString&amp; setTo(const UnicodeString&amp; srcText,
1983                int32_t srcStart,
1984                int32_t srcLength);
1985 
1986   /**
1987    * Set the text in the UnicodeString object to the characters in
1988    * &lt;TT&gt;srcText&lt;/TT&gt;.
1989    * &lt;TT&gt;srcText&lt;/TT&gt; is not modified.
1990    * @param srcText the source for the new characters
1991    * @return a reference to this
1992    * @stable ICU 2.0
1993    */
1994   inline UnicodeString&amp; setTo(const UnicodeString&amp; srcText);
1995 
1996   /**
1997    * Set the characters in the UnicodeString object to the characters
1998    * in &lt;TT&gt;srcChars&lt;/TT&gt;. &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.
1999    * @param srcChars the source for the new characters
2000    * @param srcLength the number of Unicode characters in srcChars.
2001    * @return a reference to this
2002    * @stable ICU 2.0
2003    */
2004   inline UnicodeString&amp; setTo(const char16_t *srcChars,
2005                int32_t srcLength);
2006 
2007   /**
2008    * Set the characters in the UnicodeString object to the code unit
2009    * &lt;TT&gt;srcChar&lt;/TT&gt;.
2010    * @param srcChar the code unit which becomes the UnicodeString&#39;s character
2011    * content
2012    * @return a reference to this
2013    * @stable ICU 2.0
2014    */
2015   UnicodeString&amp; setTo(char16_t srcChar);
2016 
2017   /**
2018    * Set the characters in the UnicodeString object to the code point
2019    * &lt;TT&gt;srcChar&lt;/TT&gt;.
2020    * @param srcChar the code point which becomes the UnicodeString&#39;s character
2021    * content
2022    * @return a reference to this
2023    * @stable ICU 2.0
2024    */
2025   UnicodeString&amp; setTo(UChar32 srcChar);
2026 
2027   /**
2028    * Aliasing setTo() function, analogous to the readonly-aliasing char16_t* constructor.
2029    * The text will be used for the UnicodeString object, but
2030    * it will not be released when the UnicodeString is destroyed.
2031    * This has copy-on-write semantics:
2032    * When the string is modified, then the buffer is first copied into
2033    * newly allocated memory.
2034    * The aliased buffer is never modified.
2035    *
2036    * In an assignment to another UnicodeString, when using the copy constructor
2037    * or the assignment operator, the text will be copied.
2038    * When using fastCopyFrom(), the text will be aliased again,
2039    * so that both strings then alias the same readonly-text.
2040    *
2041    * @param isTerminated specifies if &lt;code&gt;text&lt;/code&gt; is &lt;code&gt;NUL&lt;/code&gt;-terminated.
2042    *                     This must be true if &lt;code&gt;textLength==-1&lt;/code&gt;.
2043    * @param text The characters to alias for the UnicodeString.
2044    * @param textLength The number of Unicode characters in &lt;code&gt;text&lt;/code&gt; to alias.
2045    *                   If -1, then this constructor will determine the length
2046    *                   by calling &lt;code&gt;u_strlen()&lt;/code&gt;.
2047    * @return a reference to this
2048    * @stable ICU 2.0
2049    */
2050   UnicodeString &amp;setTo(UBool isTerminated,
2051                        ConstChar16Ptr text,
2052                        int32_t textLength);
2053 
2054   /**
2055    * Aliasing setTo() function, analogous to the writable-aliasing char16_t* constructor.
2056    * The text will be used for the UnicodeString object, but
2057    * it will not be released when the UnicodeString is destroyed.
2058    * This has write-through semantics:
2059    * For as long as the capacity of the buffer is sufficient, write operations
2060    * will directly affect the buffer. When more capacity is necessary, then
2061    * a new buffer will be allocated and the contents copied as with regularly
2062    * constructed strings.
2063    * In an assignment to another UnicodeString, the buffer will be copied.
2064    * The extract(Char16Ptr dst) function detects whether the dst pointer is the same
2065    * as the string buffer itself and will in this case not copy the contents.
2066    *
2067    * @param buffer The characters to alias for the UnicodeString.
2068    * @param buffLength The number of Unicode characters in &lt;code&gt;buffer&lt;/code&gt; to alias.
2069    * @param buffCapacity The size of &lt;code&gt;buffer&lt;/code&gt; in char16_ts.
2070    * @return a reference to this
2071    * @stable ICU 2.0
2072    */
2073   UnicodeString &amp;setTo(char16_t *buffer,
2074                        int32_t buffLength,
2075                        int32_t buffCapacity);
2076 
2077   /**
2078    * Make this UnicodeString object invalid.
2079    * The string will test TRUE with isBogus().
2080    *
2081    * A bogus string has no value. It is different from an empty string.
2082    * It can be used to indicate that no string value is available.
2083    * getBuffer() and getTerminatedBuffer() return NULL, and
2084    * length() returns 0.
2085    *
2086    * This utility function is used throughout the UnicodeString
2087    * implementation to indicate that a UnicodeString operation failed,
2088    * and may be used in other functions,
2089    * especially but not exclusively when such functions do not
2090    * take a UErrorCode for simplicity.
2091    *
2092    * The following methods, and no others, will clear a string object&#39;s bogus flag:
2093    * - remove()
2094    * - remove(0, INT32_MAX)
2095    * - truncate(0)
2096    * - operator=() (assignment operator)
2097    * - setTo(...)
2098    *
2099    * The simplest ways to turn a bogus string into an empty one
2100    * is to use the remove() function.
2101    * Examples for other functions that are equivalent to &quot;set to empty string&quot;:
2102    * \code
2103    * if(s.isBogus()) {
2104    *   s.remove();           // set to an empty string (remove all), or
2105    *   s.remove(0, INT32_MAX); // set to an empty string (remove all), or
2106    *   s.truncate(0);        // set to an empty string (complete truncation), or
2107    *   s=UnicodeString();    // assign an empty string, or
2108    *   s.setTo((UChar32)-1); // set to a pseudo code point that is out of range, or
2109    *   static const char16_t nul=0;
2110    *   s.setTo(&amp;nul, 0);     // set to an empty C Unicode string
2111    * }
2112    * \endcode
2113    *
2114    * @see isBogus()
2115    * @stable ICU 2.0
2116    */
2117   void setToBogus();
2118 
2119   /**
2120    * Set the character at the specified offset to the specified character.
2121    * @param offset A valid offset into the text of the character to set
2122    * @param ch The new character
2123    * @return A reference to this
2124    * @stable ICU 2.0
2125    */
2126   UnicodeString&amp; setCharAt(int32_t offset,
2127                char16_t ch);
2128 
2129 
2130   /* Append operations */
2131 
2132   /**
2133    * Append operator. Append the code unit &lt;TT&gt;ch&lt;/TT&gt; to the UnicodeString
2134    * object.
2135    * @param ch the code unit to be appended
2136    * @return a reference to this
2137    * @stable ICU 2.0
2138    */
2139  inline  UnicodeString&amp; operator+= (char16_t ch);
2140 
2141   /**
2142    * Append operator. Append the code point &lt;TT&gt;ch&lt;/TT&gt; to the UnicodeString
2143    * object.
2144    * @param ch the code point to be appended
2145    * @return a reference to this
2146    * @stable ICU 2.0
2147    */
2148  inline  UnicodeString&amp; operator+= (UChar32 ch);
2149 
2150   /**
2151    * Append operator. Append the characters in &lt;TT&gt;srcText&lt;/TT&gt; to the
2152    * UnicodeString object. &lt;TT&gt;srcText&lt;/TT&gt; is not modified.
2153    * @param srcText the source for the new characters
2154    * @return a reference to this
2155    * @stable ICU 2.0
2156    */
2157   inline UnicodeString&amp; operator+= (const UnicodeString&amp; srcText);
2158 
2159   /**
2160    * Append the characters
2161    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range
2162    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;) to the
2163    * UnicodeString object at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcText&lt;/TT&gt;
2164    * is not modified.
2165    * @param srcText the source for the new characters
2166    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; where new characters
2167    * will be obtained
2168    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; in
2169    * the append string
2170    * @return a reference to this
2171    * @stable ICU 2.0
2172    */
2173   inline UnicodeString&amp; append(const UnicodeString&amp; srcText,
2174             int32_t srcStart,
2175             int32_t srcLength);
2176 
2177   /**
2178    * Append the characters in &lt;TT&gt;srcText&lt;/TT&gt; to the UnicodeString object.
2179    * &lt;TT&gt;srcText&lt;/TT&gt; is not modified.
2180    * @param srcText the source for the new characters
2181    * @return a reference to this
2182    * @stable ICU 2.0
2183    */
2184   inline UnicodeString&amp; append(const UnicodeString&amp; srcText);
2185 
2186   /**
2187    * Append the characters in &lt;TT&gt;srcChars&lt;/TT&gt; in the range
2188    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;) to the UnicodeString
2189    * object at offset
2190    * &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.
2191    * @param srcChars the source for the new characters
2192    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; where new characters
2193    * will be obtained
2194    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; in
2195    *                  the append string; can be -1 if &lt;TT&gt;srcChars&lt;/TT&gt; is NUL-terminated
2196    * @return a reference to this
2197    * @stable ICU 2.0
2198    */
2199   inline UnicodeString&amp; append(const char16_t *srcChars,
2200             int32_t srcStart,
2201             int32_t srcLength);
2202 
2203   /**
2204    * Append the characters in &lt;TT&gt;srcChars&lt;/TT&gt; to the UnicodeString object
2205    * at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.
2206    * @param srcChars the source for the new characters
2207    * @param srcLength the number of Unicode characters in &lt;TT&gt;srcChars&lt;/TT&gt;;
2208    *                  can be -1 if &lt;TT&gt;srcChars&lt;/TT&gt; is NUL-terminated
2209    * @return a reference to this
2210    * @stable ICU 2.0
2211    */
2212   inline UnicodeString&amp; append(ConstChar16Ptr srcChars,
2213             int32_t srcLength);
2214 
2215   /**
2216    * Append the code unit &lt;TT&gt;srcChar&lt;/TT&gt; to the UnicodeString object.
2217    * @param srcChar the code unit to append
2218    * @return a reference to this
2219    * @stable ICU 2.0
2220    */
2221   inline UnicodeString&amp; append(char16_t srcChar);
2222 
2223   /**
2224    * Append the code point &lt;TT&gt;srcChar&lt;/TT&gt; to the UnicodeString object.
2225    * @param srcChar the code point to append
2226    * @return a reference to this
2227    * @stable ICU 2.0
2228    */
2229   UnicodeString&amp; append(UChar32 srcChar);
2230 
2231 
2232   /* Insert operations */
2233 
2234   /**
2235    * Insert the characters in &lt;TT&gt;srcText&lt;/TT&gt; in the range
2236    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;) into the UnicodeString
2237    * object at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcText&lt;/TT&gt; is not modified.
2238    * @param start the offset where the insertion begins
2239    * @param srcText the source for the new characters
2240    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; where new characters
2241    * will be obtained
2242    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; in
2243    * the insert string
2244    * @return a reference to this
2245    * @stable ICU 2.0
2246    */
2247   inline UnicodeString&amp; insert(int32_t start,
2248             const UnicodeString&amp; srcText,
2249             int32_t srcStart,
2250             int32_t srcLength);
2251 
2252   /**
2253    * Insert the characters in &lt;TT&gt;srcText&lt;/TT&gt; into the UnicodeString object
2254    * at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcText&lt;/TT&gt; is not modified.
2255    * @param start the offset where the insertion begins
2256    * @param srcText the source for the new characters
2257    * @return a reference to this
2258    * @stable ICU 2.0
2259    */
2260   inline UnicodeString&amp; insert(int32_t start,
2261             const UnicodeString&amp; srcText);
2262 
2263   /**
2264    * Insert the characters in &lt;TT&gt;srcChars&lt;/TT&gt; in the range
2265    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;) into the UnicodeString
2266    *  object at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.
2267    * @param start the offset at which the insertion begins
2268    * @param srcChars the source for the new characters
2269    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; where new characters
2270    * will be obtained
2271    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;
2272    * in the insert string
2273    * @return a reference to this
2274    * @stable ICU 2.0
2275    */
2276   inline UnicodeString&amp; insert(int32_t start,
2277             const char16_t *srcChars,
2278             int32_t srcStart,
2279             int32_t srcLength);
2280 
2281   /**
2282    * Insert the characters in &lt;TT&gt;srcChars&lt;/TT&gt; into the UnicodeString object
2283    * at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.
2284    * @param start the offset where the insertion begins
2285    * @param srcChars the source for the new characters
2286    * @param srcLength the number of Unicode characters in srcChars.
2287    * @return a reference to this
2288    * @stable ICU 2.0
2289    */
2290   inline UnicodeString&amp; insert(int32_t start,
2291             ConstChar16Ptr srcChars,
2292             int32_t srcLength);
2293 
2294   /**
2295    * Insert the code unit &lt;TT&gt;srcChar&lt;/TT&gt; into the UnicodeString object at
2296    * offset &lt;TT&gt;start&lt;/TT&gt;.
2297    * @param start the offset at which the insertion occurs
2298    * @param srcChar the code unit to insert
2299    * @return a reference to this
2300    * @stable ICU 2.0
2301    */
2302   inline UnicodeString&amp; insert(int32_t start,
2303             char16_t srcChar);
2304 
2305   /**
2306    * Insert the code point &lt;TT&gt;srcChar&lt;/TT&gt; into the UnicodeString object at
2307    * offset &lt;TT&gt;start&lt;/TT&gt;.
2308    * @param start the offset at which the insertion occurs
2309    * @param srcChar the code point to insert
2310    * @return a reference to this
2311    * @stable ICU 2.0
2312    */
2313   inline UnicodeString&amp; insert(int32_t start,
2314             UChar32 srcChar);
2315 
2316 
2317   /* Replace operations */
2318 
2319   /**
2320    * Replace the characters in the range
2321    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters in
2322    * &lt;TT&gt;srcText&lt;/TT&gt; in the range
2323    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).
2324    * &lt;TT&gt;srcText&lt;/TT&gt; is not modified.
2325    * @param start the offset at which the replace operation begins
2326    * @param length the number of characters to replace. The character at
2327    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.
2328    * @param srcText the source for the new characters
2329    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; where new characters
2330    * will be obtained
2331    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; in
2332    * the replace string
2333    * @return a reference to this
2334    * @stable ICU 2.0
2335    */
2336   UnicodeString&amp; replace(int32_t start,
2337              int32_t length,
2338              const UnicodeString&amp; srcText,
2339              int32_t srcStart,
2340              int32_t srcLength);
2341 
2342   /**
2343    * Replace the characters in the range
2344    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;)
2345    * with the characters in &lt;TT&gt;srcText&lt;/TT&gt;.  &lt;TT&gt;srcText&lt;/TT&gt; is
2346    *  not modified.
2347    * @param start the offset at which the replace operation begins
2348    * @param length the number of characters to replace. The character at
2349    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.
2350    * @param srcText the source for the new characters
2351    * @return a reference to this
2352    * @stable ICU 2.0
2353    */
2354   UnicodeString&amp; replace(int32_t start,
2355              int32_t length,
2356              const UnicodeString&amp; srcText);
2357 
2358   /**
2359    * Replace the characters in the range
2360    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters in
2361    * &lt;TT&gt;srcChars&lt;/TT&gt; in the range
2362    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;). &lt;TT&gt;srcChars&lt;/TT&gt;
2363    * is not modified.
2364    * @param start the offset at which the replace operation begins
2365    * @param length the number of characters to replace.  The character at
2366    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.
2367    * @param srcChars the source for the new characters
2368    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; where new characters
2369    * will be obtained
2370    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;
2371    * in the replace string
2372    * @return a reference to this
2373    * @stable ICU 2.0
2374    */
2375   UnicodeString&amp; replace(int32_t start,
2376              int32_t length,
2377              const char16_t *srcChars,
2378              int32_t srcStart,
2379              int32_t srcLength);
2380 
2381   /**
2382    * Replace the characters in the range
2383    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters in
2384    * &lt;TT&gt;srcChars&lt;/TT&gt;.  &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.
2385    * @param start the offset at which the replace operation begins
2386    * @param length number of characters to replace.  The character at
2387    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.
2388    * @param srcChars the source for the new characters
2389    * @param srcLength the number of Unicode characters in srcChars
2390    * @return a reference to this
2391    * @stable ICU 2.0
2392    */
2393   inline UnicodeString&amp; replace(int32_t start,
2394              int32_t length,
2395              ConstChar16Ptr srcChars,
2396              int32_t srcLength);
2397 
2398   /**
2399    * Replace the characters in the range
2400    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the code unit
2401    * &lt;TT&gt;srcChar&lt;/TT&gt;.
2402    * @param start the offset at which the replace operation begins
2403    * @param length the number of characters to replace.  The character at
2404    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.
2405    * @param srcChar the new code unit
2406    * @return a reference to this
2407    * @stable ICU 2.0
2408    */
2409   inline UnicodeString&amp; replace(int32_t start,
2410              int32_t length,
2411              char16_t srcChar);
2412 
2413   /**
2414    * Replace the characters in the range
2415    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the code point
2416    * &lt;TT&gt;srcChar&lt;/TT&gt;.
2417    * @param start the offset at which the replace operation begins
2418    * @param length the number of characters to replace.  The character at
2419    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.
2420    * @param srcChar the new code point
2421    * @return a reference to this
2422    * @stable ICU 2.0
2423    */
2424   UnicodeString&amp; replace(int32_t start, int32_t length, UChar32 srcChar);
2425 
2426   /**
2427    * Replace the characters in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;limit&lt;/TT&gt;)
2428    * with the characters in &lt;TT&gt;srcText&lt;/TT&gt;. &lt;TT&gt;srcText&lt;/TT&gt; is not modified.
2429    * @param start the offset at which the replace operation begins
2430    * @param limit the offset immediately following the replace range
2431    * @param srcText the source for the new characters
2432    * @return a reference to this
2433    * @stable ICU 2.0
2434    */
2435   inline UnicodeString&amp; replaceBetween(int32_t start,
2436                 int32_t limit,
2437                 const UnicodeString&amp; srcText);
2438 
2439   /**
2440    * Replace the characters in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;limit&lt;/TT&gt;)
2441    * with the characters in &lt;TT&gt;srcText&lt;/TT&gt; in the range
2442    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcLimit&lt;/TT&gt;). &lt;TT&gt;srcText&lt;/TT&gt; is not modified.
2443    * @param start the offset at which the replace operation begins
2444    * @param limit the offset immediately following the replace range
2445    * @param srcText the source for the new characters
2446    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; where new characters
2447    * will be obtained
2448    * @param srcLimit the offset immediately following the range to copy
2449    * in &lt;TT&gt;srcText&lt;/TT&gt;
2450    * @return a reference to this
2451    * @stable ICU 2.0
2452    */
2453   inline UnicodeString&amp; replaceBetween(int32_t start,
2454                 int32_t limit,
2455                 const UnicodeString&amp; srcText,
2456                 int32_t srcStart,
2457                 int32_t srcLimit);
2458 
2459   /**
2460    * Replace a substring of this object with the given text.
2461    * @param start the beginning index, inclusive; &lt;code&gt;0 &lt;= start
2462    * &lt;= limit&lt;/code&gt;.
2463    * @param limit the ending index, exclusive; &lt;code&gt;start &lt;= limit
2464    * &lt;= length()&lt;/code&gt;.
2465    * @param text the text to replace characters &lt;code&gt;start&lt;/code&gt;
2466    * to &lt;code&gt;limit - 1&lt;/code&gt;
2467    * @stable ICU 2.0
2468    */
2469   virtual void handleReplaceBetween(int32_t start,
2470                                     int32_t limit,
2471                                     const UnicodeString&amp; text);
2472 
2473   /**
2474    * Replaceable API
2475    * @return TRUE if it has MetaData
2476    * @stable ICU 2.4
2477    */
2478   virtual UBool hasMetaData() const;
2479 
2480   /**
2481    * Copy a substring of this object, retaining attribute (out-of-band)
2482    * information.  This method is used to duplicate or reorder substrings.
2483    * The destination index must not overlap the source range.
2484    *
2485    * @param start the beginning index, inclusive; &lt;code&gt;0 &lt;= start &lt;=
2486    * limit&lt;/code&gt;.
2487    * @param limit the ending index, exclusive; &lt;code&gt;start &lt;= limit &lt;=
2488    * length()&lt;/code&gt;.
2489    * @param dest the destination index.  The characters from
2490    * &lt;code&gt;start..limit-1&lt;/code&gt; will be copied to &lt;code&gt;dest&lt;/code&gt;.
2491    * Implementations of this method may assume that &lt;code&gt;dest &lt;= start ||
2492    * dest &gt;= limit&lt;/code&gt;.
2493    * @stable ICU 2.0
2494    */
2495   virtual void copy(int32_t start, int32_t limit, int32_t dest);
2496 
2497   /* Search and replace operations */
2498 
2499   /**
2500    * Replace all occurrences of characters in oldText with the characters
2501    * in newText
2502    * @param oldText the text containing the search text
2503    * @param newText the text containing the replacement text
2504    * @return a reference to this
2505    * @stable ICU 2.0
2506    */
2507   inline UnicodeString&amp; findAndReplace(const UnicodeString&amp; oldText,
2508                 const UnicodeString&amp; newText);
2509 
2510   /**
2511    * Replace all occurrences of characters in oldText with characters
2512    * in newText
2513    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;).
2514    * @param start the start of the range in which replace will performed
2515    * @param length the length of the range in which replace will be performed
2516    * @param oldText the text containing the search text
2517    * @param newText the text containing the replacement text
2518    * @return a reference to this
2519    * @stable ICU 2.0
2520    */
2521   inline UnicodeString&amp; findAndReplace(int32_t start,
2522                 int32_t length,
2523                 const UnicodeString&amp; oldText,
2524                 const UnicodeString&amp; newText);
2525 
2526   /**
2527    * Replace all occurrences of characters in oldText in the range
2528    * [&lt;TT&gt;oldStart&lt;/TT&gt;, &lt;TT&gt;oldStart + oldLength&lt;/TT&gt;) with the characters
2529    * in newText in the range
2530    * [&lt;TT&gt;newStart&lt;/TT&gt;, &lt;TT&gt;newStart + newLength&lt;/TT&gt;)
2531    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;).
2532    * @param start the start of the range in which replace will performed
2533    * @param length the length of the range in which replace will be performed
2534    * @param oldText the text containing the search text
2535    * @param oldStart the start of the search range in &lt;TT&gt;oldText&lt;/TT&gt;
2536    * @param oldLength the length of the search range in &lt;TT&gt;oldText&lt;/TT&gt;
2537    * @param newText the text containing the replacement text
2538    * @param newStart the start of the replacement range in &lt;TT&gt;newText&lt;/TT&gt;
2539    * @param newLength the length of the replacement range in &lt;TT&gt;newText&lt;/TT&gt;
2540    * @return a reference to this
2541    * @stable ICU 2.0
2542    */
2543   UnicodeString&amp; findAndReplace(int32_t start,
2544                 int32_t length,
2545                 const UnicodeString&amp; oldText,
2546                 int32_t oldStart,
2547                 int32_t oldLength,
2548                 const UnicodeString&amp; newText,
2549                 int32_t newStart,
2550                 int32_t newLength);
2551 
2552 
2553   /* Remove operations */
2554 
2555   /**
2556    * Remove all characters from the UnicodeString object.
2557    * @return a reference to this
2558    * @stable ICU 2.0
2559    */
2560   inline UnicodeString&amp; remove(void);
2561 
2562   /**
2563    * Remove the characters in the range
2564    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) from the UnicodeString object.
2565    * @param start the offset of the first character to remove
2566    * @param length the number of characters to remove
2567    * @return a reference to this
2568    * @stable ICU 2.0
2569    */
2570   inline UnicodeString&amp; remove(int32_t start,
2571                                int32_t length = (int32_t)INT32_MAX);
2572 
2573   /**
2574    * Remove the characters in the range
2575    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;limit&lt;/TT&gt;) from the UnicodeString object.
2576    * @param start the offset of the first character to remove
2577    * @param limit the offset immediately following the range to remove
2578    * @return a reference to this
2579    * @stable ICU 2.0
2580    */
2581   inline UnicodeString&amp; removeBetween(int32_t start,
2582                                       int32_t limit = (int32_t)INT32_MAX);
2583 
2584   /**
2585    * Retain only the characters in the range
2586    * [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt;) from the UnicodeString object.
2587    * Removes characters before &lt;code&gt;start&lt;/code&gt; and at and after &lt;code&gt;limit&lt;/code&gt;.
2588    * @param start the offset of the first character to retain
2589    * @param limit the offset immediately following the range to retain
2590    * @return a reference to this
2591    * @stable ICU 4.4
2592    */
2593   inline UnicodeString &amp;retainBetween(int32_t start, int32_t limit = INT32_MAX);
2594 
2595   /* Length operations */
2596 
2597   /**
2598    * Pad the start of this UnicodeString with the character &lt;TT&gt;padChar&lt;/TT&gt;.
2599    * If the length of this UnicodeString is less than targetLength,
2600    * length() - targetLength copies of padChar will be added to the
2601    * beginning of this UnicodeString.
2602    * @param targetLength the desired length of the string
2603    * @param padChar the character to use for padding. Defaults to
2604    * space (U+0020)
2605    * @return TRUE if the text was padded, FALSE otherwise.
2606    * @stable ICU 2.0
2607    */
2608   UBool padLeading(int32_t targetLength,
2609                     char16_t padChar = 0x0020);
2610 
2611   /**
2612    * Pad the end of this UnicodeString with the character &lt;TT&gt;padChar&lt;/TT&gt;.
2613    * If the length of this UnicodeString is less than targetLength,
2614    * length() - targetLength copies of padChar will be added to the
2615    * end of this UnicodeString.
2616    * @param targetLength the desired length of the string
2617    * @param padChar the character to use for padding. Defaults to
2618    * space (U+0020)
2619    * @return TRUE if the text was padded, FALSE otherwise.
2620    * @stable ICU 2.0
2621    */
2622   UBool padTrailing(int32_t targetLength,
2623                      char16_t padChar = 0x0020);
2624 
2625   /**
2626    * Truncate this UnicodeString to the &lt;TT&gt;targetLength&lt;/TT&gt;.
2627    * @param targetLength the desired length of this UnicodeString.
2628    * @return TRUE if the text was truncated, FALSE otherwise
2629    * @stable ICU 2.0
2630    */
2631   inline UBool truncate(int32_t targetLength);
2632 
2633   /**
2634    * Trims leading and trailing whitespace from this UnicodeString.
2635    * @return a reference to this
2636    * @stable ICU 2.0
2637    */
2638   UnicodeString&amp; trim(void);
2639 
2640 
2641   /* Miscellaneous operations */
2642 
2643   /**
2644    * Reverse this UnicodeString in place.
2645    * @return a reference to this
2646    * @stable ICU 2.0
2647    */
2648   inline UnicodeString&amp; reverse(void);
2649 
2650   /**
2651    * Reverse the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) in
2652    * this UnicodeString.
2653    * @param start the start of the range to reverse
2654    * @param length the number of characters to to reverse
2655    * @return a reference to this
2656    * @stable ICU 2.0
2657    */
2658   inline UnicodeString&amp; reverse(int32_t start,
2659              int32_t length);
2660 
2661   /**
2662    * Convert the characters in this to UPPER CASE following the conventions of
2663    * the default locale.
2664    * @return A reference to this.
2665    * @stable ICU 2.0
2666    */
2667   UnicodeString&amp; toUpper(void);
2668 
2669   /**
2670    * Convert the characters in this to UPPER CASE following the conventions of
2671    * a specific locale.
2672    * @param locale The locale containing the conventions to use.
2673    * @return A reference to this.
2674    * @stable ICU 2.0
2675    */
2676   UnicodeString&amp; toUpper(const Locale&amp; locale);
2677 
2678   /**
2679    * Convert the characters in this to lower case following the conventions of
2680    * the default locale.
2681    * @return A reference to this.
2682    * @stable ICU 2.0
2683    */
2684   UnicodeString&amp; toLower(void);
2685 
2686   /**
2687    * Convert the characters in this to lower case following the conventions of
2688    * a specific locale.
2689    * @param locale The locale containing the conventions to use.
2690    * @return A reference to this.
2691    * @stable ICU 2.0
2692    */
2693   UnicodeString&amp; toLower(const Locale&amp; locale);
2694 
2695 #if !UCONFIG_NO_BREAK_ITERATION
2696 
2697   /**
2698    * Titlecase this string, convenience function using the default locale.
2699    *
2700    * Casing is locale-dependent and context-sensitive.
2701    * Titlecasing uses a break iterator to find the first characters of words
2702    * that are to be titlecased. It titlecases those characters and lowercases
2703    * all others.
2704    *
2705    * The titlecase break iterator can be provided to customize for arbitrary
2706    * styles, using rules and dictionaries beyond the standard iterators.
2707    * It may be more efficient to always provide an iterator to avoid
2708    * opening and closing one for each string.
2709    * The standard titlecase iterator for the root locale implements the
2710    * algorithm of Unicode TR 21.
2711    *
2712    * This function uses only the setText(), first() and next() methods of the
2713    * provided break iterator.
2714    *
2715    * @param titleIter A break iterator to find the first characters of words
2716    *                  that are to be titlecased.
2717    *                  If none is provided (0), then a standard titlecase
2718    *                  break iterator is opened.
2719    *                  Otherwise the provided iterator is set to the string&#39;s text.
2720    * @return A reference to this.
2721    * @stable ICU 2.1
2722    */
2723   UnicodeString &amp;toTitle(BreakIterator *titleIter);
2724 
2725   /**
2726    * Titlecase this string.
2727    *
2728    * Casing is locale-dependent and context-sensitive.
2729    * Titlecasing uses a break iterator to find the first characters of words
2730    * that are to be titlecased. It titlecases those characters and lowercases
2731    * all others.
2732    *
2733    * The titlecase break iterator can be provided to customize for arbitrary
2734    * styles, using rules and dictionaries beyond the standard iterators.
2735    * It may be more efficient to always provide an iterator to avoid
2736    * opening and closing one for each string.
2737    * The standard titlecase iterator for the root locale implements the
2738    * algorithm of Unicode TR 21.
2739    *
2740    * This function uses only the setText(), first() and next() methods of the
2741    * provided break iterator.
2742    *
2743    * @param titleIter A break iterator to find the first characters of words
2744    *                  that are to be titlecased.
2745    *                  If none is provided (0), then a standard titlecase
2746    *                  break iterator is opened.
2747    *                  Otherwise the provided iterator is set to the string&#39;s text.
2748    * @param locale    The locale to consider.
2749    * @return A reference to this.
2750    * @stable ICU 2.1
2751    */
2752   UnicodeString &amp;toTitle(BreakIterator *titleIter, const Locale &amp;locale);
2753 
2754   /**
2755    * Titlecase this string, with options.
2756    *
2757    * Casing is locale-dependent and context-sensitive.
2758    * Titlecasing uses a break iterator to find the first characters of words
2759    * that are to be titlecased. It titlecases those characters and lowercases
2760    * all others. (This can be modified with options.)
2761    *
2762    * The titlecase break iterator can be provided to customize for arbitrary
2763    * styles, using rules and dictionaries beyond the standard iterators.
2764    * It may be more efficient to always provide an iterator to avoid
2765    * opening and closing one for each string.
2766    * The standard titlecase iterator for the root locale implements the
2767    * algorithm of Unicode TR 21.
2768    *
2769    * This function uses only the setText(), first() and next() methods of the
2770    * provided break iterator.
2771    *
2772    * @param titleIter A break iterator to find the first characters of words
2773    *                  that are to be titlecased.
2774    *                  If none is provided (0), then a standard titlecase
2775    *                  break iterator is opened.
2776    *                  Otherwise the provided iterator is set to the string&#39;s text.
2777    * @param locale    The locale to consider.
2778    * @param options   Options bit set, usually 0. See U_TITLECASE_NO_LOWERCASE,
2779    *                  U_TITLECASE_NO_BREAK_ADJUSTMENT, U_TITLECASE_ADJUST_TO_CASED,
2780    *                  U_TITLECASE_WHOLE_STRING, U_TITLECASE_SENTENCES.
2781    * @param options Options bit set, see ucasemap_open().
2782    * @return A reference to this.
2783    * @stable ICU 3.8
2784    */
2785   UnicodeString &amp;toTitle(BreakIterator *titleIter, const Locale &amp;locale, uint32_t options);
2786 
2787 #endif
2788 
2789   /**
2790    * Case-folds the characters in this string.
2791    *
2792    * Case-folding is locale-independent and not context-sensitive,
2793    * but there is an option for whether to include or exclude mappings for dotted I
2794    * and dotless i that are marked with &#39;T&#39; in CaseFolding.txt.
2795    *
2796    * The result may be longer or shorter than the original.
2797    *
2798    * @param options Either U_FOLD_CASE_DEFAULT or U_FOLD_CASE_EXCLUDE_SPECIAL_I
2799    * @return A reference to this.
2800    * @stable ICU 2.0
2801    */
2802   UnicodeString &amp;foldCase(uint32_t options=0 /*U_FOLD_CASE_DEFAULT*/);
2803 
2804   //========================================
2805   // Access to the internal buffer
2806   //========================================
2807 
2808   /**
2809    * Get a read/write pointer to the internal buffer.
2810    * The buffer is guaranteed to be large enough for at least minCapacity char16_ts,
2811    * writable, and is still owned by the UnicodeString object.
2812    * Calls to getBuffer(minCapacity) must not be nested, and
2813    * must be matched with calls to releaseBuffer(newLength).
2814    * If the string buffer was read-only or shared,
2815    * then it will be reallocated and copied.
2816    *
2817    * An attempted nested call will return 0, and will not further modify the
2818    * state of the UnicodeString object.
2819    * It also returns 0 if the string is bogus.
2820    *
2821    * The actual capacity of the string buffer may be larger than minCapacity.
2822    * getCapacity() returns the actual capacity.
2823    * For many operations, the full capacity should be used to avoid reallocations.
2824    *
2825    * While the buffer is &quot;open&quot; between getBuffer(minCapacity)
2826    * and releaseBuffer(newLength), the following applies:
2827    * - The string length is set to 0.
2828    * - Any read API call on the UnicodeString object will behave like on a 0-length string.
2829    * - Any write API call on the UnicodeString object is disallowed and will have no effect.
2830    * - You can read from and write to the returned buffer.
2831    * - The previous string contents will still be in the buffer;
2832    *   if you want to use it, then you need to call length() before getBuffer(minCapacity).
2833    *   If the length() was greater than minCapacity, then any contents after minCapacity
2834    *   may be lost.
2835    *   The buffer contents is not NUL-terminated by getBuffer().
2836    *   If length()&lt;getCapacity() then you can terminate it by writing a NUL
2837    *   at index length().
2838    * - You must call releaseBuffer(newLength) before and in order to
2839    *   return to normal UnicodeString operation.
2840    *
2841    * @param minCapacity the minimum number of char16_ts that are to be available
2842    *        in the buffer, starting at the returned pointer;
2843    *        default to the current string capacity if minCapacity==-1
2844    * @return a writable pointer to the internal string buffer,
2845    *         or nullptr if an error occurs (nested calls, out of memory)
2846    *
2847    * @see releaseBuffer
2848    * @see getTerminatedBuffer()
2849    * @stable ICU 2.0
2850    */
2851   char16_t *getBuffer(int32_t minCapacity);
2852 
2853   /**
2854    * Release a read/write buffer on a UnicodeString object with an
2855    * &quot;open&quot; getBuffer(minCapacity).
2856    * This function must be called in a matched pair with getBuffer(minCapacity).
2857    * releaseBuffer(newLength) must be called if and only if a getBuffer(minCapacity) is &quot;open&quot;.
2858    *
2859    * It will set the string length to newLength, at most to the current capacity.
2860    * If newLength==-1 then it will set the length according to the
2861    * first NUL in the buffer, or to the capacity if there is no NUL.
2862    *
2863    * After calling releaseBuffer(newLength) the UnicodeString is back to normal operation.
2864    *
2865    * @param newLength the new length of the UnicodeString object;
2866    *        defaults to the current capacity if newLength is greater than that;
2867    *        if newLength==-1, it defaults to u_strlen(buffer) but not more than
2868    *        the current capacity of the string
2869    *
2870    * @see getBuffer(int32_t minCapacity)
2871    * @stable ICU 2.0
2872    */
2873   void releaseBuffer(int32_t newLength=-1);
2874 
2875   /**
2876    * Get a read-only pointer to the internal buffer.
2877    * This can be called at any time on a valid UnicodeString.
2878    *
2879    * It returns 0 if the string is bogus, or
2880    * during an &quot;open&quot; getBuffer(minCapacity).
2881    *
2882    * It can be called as many times as desired.
2883    * The pointer that it returns will remain valid until the UnicodeString object is modified,
2884    * at which time the pointer is semantically invalidated and must not be used any more.
2885    *
2886    * The capacity of the buffer can be determined with getCapacity().
2887    * The part after length() may or may not be initialized and valid,
2888    * depending on the history of the UnicodeString object.
2889    *
2890    * The buffer contents is (probably) not NUL-terminated.
2891    * You can check if it is with
2892    * &lt;code&gt;(s.length()&lt;s.getCapacity() &amp;&amp; buffer[s.length()]==0)&lt;/code&gt;.
2893    * (See getTerminatedBuffer().)
2894    *
2895    * The buffer may reside in read-only memory. Its contents must not
2896    * be modified.
2897    *
2898    * @return a read-only pointer to the internal string buffer,
2899    *         or nullptr if the string is empty or bogus
2900    *
2901    * @see getBuffer(int32_t minCapacity)
2902    * @see getTerminatedBuffer()
2903    * @stable ICU 2.0
2904    */
2905   inline const char16_t *getBuffer() const;
2906 
2907   /**
2908    * Get a read-only pointer to the internal buffer,
2909    * making sure that it is NUL-terminated.
2910    * This can be called at any time on a valid UnicodeString.
2911    *
2912    * It returns 0 if the string is bogus, or
2913    * during an &quot;open&quot; getBuffer(minCapacity), or if the buffer cannot
2914    * be NUL-terminated (because memory allocation failed).
2915    *
2916    * It can be called as many times as desired.
2917    * The pointer that it returns will remain valid until the UnicodeString object is modified,
2918    * at which time the pointer is semantically invalidated and must not be used any more.
2919    *
2920    * The capacity of the buffer can be determined with getCapacity().
2921    * The part after length()+1 may or may not be initialized and valid,
2922    * depending on the history of the UnicodeString object.
2923    *
2924    * The buffer contents is guaranteed to be NUL-terminated.
2925    * getTerminatedBuffer() may reallocate the buffer if a terminating NUL
2926    * is written.
2927    * For this reason, this function is not const, unlike getBuffer().
2928    * Note that a UnicodeString may also contain NUL characters as part of its contents.
2929    *
2930    * The buffer may reside in read-only memory. Its contents must not
2931    * be modified.
2932    *
2933    * @return a read-only pointer to the internal string buffer,
2934    *         or 0 if the string is empty or bogus
2935    *
2936    * @see getBuffer(int32_t minCapacity)
2937    * @see getBuffer()
2938    * @stable ICU 2.2
2939    */
2940   const char16_t *getTerminatedBuffer();
2941 
2942   //========================================
2943   // Constructors
2944   //========================================
2945 
2946   /** Construct an empty UnicodeString.
2947    * @stable ICU 2.0
2948    */
2949   inline UnicodeString();
2950 
2951   /**
2952    * Construct a UnicodeString with capacity to hold &lt;TT&gt;capacity&lt;/TT&gt; char16_ts
2953    * @param capacity the number of char16_ts this UnicodeString should hold
2954    * before a resize is necessary; if count is greater than 0 and count
2955    * code points c take up more space than capacity, then capacity is adjusted
2956    * accordingly.
2957    * @param c is used to initially fill the string
2958    * @param count specifies how many code points c are to be written in the
2959    *              string
2960    * @stable ICU 2.0
2961    */
2962   UnicodeString(int32_t capacity, UChar32 c, int32_t count);
2963 
2964   /**
2965    * Single char16_t (code unit) constructor.
2966    *
2967    * It is recommended to mark this constructor &quot;explicit&quot; by
2968    * &lt;code&gt;-DUNISTR_FROM_CHAR_EXPLICIT=explicit&lt;/code&gt;
2969    * on the compiler command line or similar.
2970    * @param ch the character to place in the UnicodeString
2971    * @stable ICU 2.0
2972    */
2973   UNISTR_FROM_CHAR_EXPLICIT UnicodeString(char16_t ch);
2974 
2975   /**
2976    * Single UChar32 (code point) constructor.
2977    *
2978    * It is recommended to mark this constructor &quot;explicit&quot; by
2979    * &lt;code&gt;-DUNISTR_FROM_CHAR_EXPLICIT=explicit&lt;/code&gt;
2980    * on the compiler command line or similar.
2981    * @param ch the character to place in the UnicodeString
2982    * @stable ICU 2.0
2983    */
2984   UNISTR_FROM_CHAR_EXPLICIT UnicodeString(UChar32 ch);
2985 
2986   /**
2987    * char16_t* constructor.
2988    *
2989    * It is recommended to mark this constructor &quot;explicit&quot; by
2990    * &lt;code&gt;-DUNISTR_FROM_STRING_EXPLICIT=explicit&lt;/code&gt;
2991    * on the compiler command line or similar.
2992    * @param text The characters to place in the UnicodeString.  &lt;TT&gt;text&lt;/TT&gt;
2993    * must be NULL (U+0000) terminated.
2994    * @stable ICU 2.0
2995    */
2996   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const char16_t *text);
2997 
2998 #if !U_CHAR16_IS_TYPEDEF
2999   /**
3000    * uint16_t * constructor.
3001    * Delegates to UnicodeString(const char16_t *).
3002    *
3003    * It is recommended to mark this constructor &quot;explicit&quot; by
3004    * &lt;code&gt;-DUNISTR_FROM_STRING_EXPLICIT=explicit&lt;/code&gt;
3005    * on the compiler command line or similar.
3006    * @param text NUL-terminated UTF-16 string
3007    * @stable ICU 59
3008    */
3009   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const uint16_t *text) :
3010       UnicodeString(ConstChar16Ptr(text)) {}
3011 #endif
3012 
3013 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
3014   /**
3015    * wchar_t * constructor.
3016    * (Only defined if U_SIZEOF_WCHAR_T==2.)
3017    * Delegates to UnicodeString(const char16_t *).
3018    *
3019    * It is recommended to mark this constructor &quot;explicit&quot; by
3020    * &lt;code&gt;-DUNISTR_FROM_STRING_EXPLICIT=explicit&lt;/code&gt;
3021    * on the compiler command line or similar.
3022    * @param text NUL-terminated UTF-16 string
3023    * @stable ICU 59
3024    */
3025   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const wchar_t *text) :
3026       UnicodeString(ConstChar16Ptr(text)) {}
3027 #endif
3028 
3029   /**
3030    * nullptr_t constructor.
3031    * Effectively the same as the default constructor, makes an empty string object.
3032    *
3033    * It is recommended to mark this constructor &quot;explicit&quot; by
3034    * &lt;code&gt;-DUNISTR_FROM_STRING_EXPLICIT=explicit&lt;/code&gt;
3035    * on the compiler command line or similar.
3036    * @param text nullptr
3037    * @stable ICU 59
3038    */
3039   UNISTR_FROM_STRING_EXPLICIT inline UnicodeString(const std::nullptr_t text);
3040 
3041   /**
3042    * char16_t* constructor.
3043    * @param text The characters to place in the UnicodeString.
3044    * @param textLength The number of Unicode characters in &lt;TT&gt;text&lt;/TT&gt;
3045    * to copy.
3046    * @stable ICU 2.0
3047    */
3048   UnicodeString(const char16_t *text,
3049         int32_t textLength);
3050 
3051 #if !U_CHAR16_IS_TYPEDEF
3052   /**
3053    * uint16_t * constructor.
3054    * Delegates to UnicodeString(const char16_t *, int32_t).
3055    * @param text UTF-16 string
3056    * @param length string length
3057    * @stable ICU 59
3058    */
3059   UnicodeString(const uint16_t *text, int32_t length) :
3060       UnicodeString(ConstChar16Ptr(text), length) {}
3061 #endif
3062 
3063 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
3064   /**
3065    * wchar_t * constructor.
3066    * (Only defined if U_SIZEOF_WCHAR_T==2.)
3067    * Delegates to UnicodeString(const char16_t *, int32_t).
3068    * @param text NUL-terminated UTF-16 string
3069    * @param length string length
3070    * @stable ICU 59
3071    */
3072   UnicodeString(const wchar_t *text, int32_t length) :
3073       UnicodeString(ConstChar16Ptr(text), length) {}
3074 #endif
3075 
3076   /**
3077    * nullptr_t constructor.
3078    * Effectively the same as the default constructor, makes an empty string object.
3079    * @param text nullptr
3080    * @param length ignored
3081    * @stable ICU 59
3082    */
3083   inline UnicodeString(const std::nullptr_t text, int32_t length);
3084 
3085   /**
3086    * Readonly-aliasing char16_t* constructor.
3087    * The text will be used for the UnicodeString object, but
3088    * it will not be released when the UnicodeString is destroyed.
3089    * This has copy-on-write semantics:
3090    * When the string is modified, then the buffer is first copied into
3091    * newly allocated memory.
3092    * The aliased buffer is never modified.
3093    *
3094    * In an assignment to another UnicodeString, when using the copy constructor
3095    * or the assignment operator, the text will be copied.
3096    * When using fastCopyFrom(), the text will be aliased again,
3097    * so that both strings then alias the same readonly-text.
3098    *
3099    * @param isTerminated specifies if &lt;code&gt;text&lt;/code&gt; is &lt;code&gt;NUL&lt;/code&gt;-terminated.
3100    *                     This must be true if &lt;code&gt;textLength==-1&lt;/code&gt;.
3101    * @param text The characters to alias for the UnicodeString.
3102    * @param textLength The number of Unicode characters in &lt;code&gt;text&lt;/code&gt; to alias.
3103    *                   If -1, then this constructor will determine the length
3104    *                   by calling &lt;code&gt;u_strlen()&lt;/code&gt;.
3105    * @stable ICU 2.0
3106    */
3107   UnicodeString(UBool isTerminated,
3108                 ConstChar16Ptr text,
3109                 int32_t textLength);
3110 
3111   /**
3112    * Writable-aliasing char16_t* constructor.
3113    * The text will be used for the UnicodeString object, but
3114    * it will not be released when the UnicodeString is destroyed.
3115    * This has write-through semantics:
3116    * For as long as the capacity of the buffer is sufficient, write operations
3117    * will directly affect the buffer. When more capacity is necessary, then
3118    * a new buffer will be allocated and the contents copied as with regularly
3119    * constructed strings.
3120    * In an assignment to another UnicodeString, the buffer will be copied.
3121    * The extract(Char16Ptr dst) function detects whether the dst pointer is the same
3122    * as the string buffer itself and will in this case not copy the contents.
3123    *
3124    * @param buffer The characters to alias for the UnicodeString.
3125    * @param buffLength The number of Unicode characters in &lt;code&gt;buffer&lt;/code&gt; to alias.
3126    * @param buffCapacity The size of &lt;code&gt;buffer&lt;/code&gt; in char16_ts.
3127    * @stable ICU 2.0
3128    */
3129   UnicodeString(char16_t *buffer, int32_t buffLength, int32_t buffCapacity);
3130 
3131 #if !U_CHAR16_IS_TYPEDEF
3132   /**
3133    * Writable-aliasing uint16_t * constructor.
3134    * Delegates to UnicodeString(const char16_t *, int32_t, int32_t).
3135    * @param buffer writable buffer of/for UTF-16 text
3136    * @param buffLength length of the current buffer contents
3137    * @param buffCapacity buffer capacity
3138    * @stable ICU 59
3139    */
3140   UnicodeString(uint16_t *buffer, int32_t buffLength, int32_t buffCapacity) :
3141       UnicodeString(Char16Ptr(buffer), buffLength, buffCapacity) {}
3142 #endif
3143 
3144 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
3145   /**
3146    * Writable-aliasing wchar_t * constructor.
3147    * (Only defined if U_SIZEOF_WCHAR_T==2.)
3148    * Delegates to UnicodeString(const char16_t *, int32_t, int32_t).
3149    * @param buffer writable buffer of/for UTF-16 text
3150    * @param buffLength length of the current buffer contents
3151    * @param buffCapacity buffer capacity
3152    * @stable ICU 59
3153    */
3154   UnicodeString(wchar_t *buffer, int32_t buffLength, int32_t buffCapacity) :
3155       UnicodeString(Char16Ptr(buffer), buffLength, buffCapacity) {}
3156 #endif
3157 
3158   /**
3159    * Writable-aliasing nullptr_t constructor.
3160    * Effectively the same as the default constructor, makes an empty string object.
3161    * @param buffer nullptr
3162    * @param buffLength ignored
3163    * @param buffCapacity ignored
3164    * @stable ICU 59
3165    */
3166   inline UnicodeString(std::nullptr_t buffer, int32_t buffLength, int32_t buffCapacity);
3167 
3168 #if U_CHARSET_IS_UTF8 || !UCONFIG_NO_CONVERSION
3169 
3170   /**
3171    * char* constructor.
3172    * Uses the default converter (and thus depends on the ICU conversion code)
3173    * unless U_CHARSET_IS_UTF8 is set to 1.
3174    *
3175    * For ASCII (really &quot;invariant character&quot;) strings it is more efficient to use
3176    * the constructor that takes a US_INV (for its enum EInvariant).
3177    * For ASCII (invariant-character) string literals, see UNICODE_STRING and
3178    * UNICODE_STRING_SIMPLE.
3179    *
3180    * It is recommended to mark this constructor &quot;explicit&quot; by
3181    * &lt;code&gt;-DUNISTR_FROM_STRING_EXPLICIT=explicit&lt;/code&gt;
3182    * on the compiler command line or similar.
3183    * @param codepageData an array of bytes, null-terminated,
3184    *                     in the platform&#39;s default codepage.
3185    * @stable ICU 2.0
3186    * @see UNICODE_STRING
3187    * @see UNICODE_STRING_SIMPLE
3188    */
3189   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const char *codepageData);
3190 
3191   /**
3192    * char* constructor.
3193    * Uses the default converter (and thus depends on the ICU conversion code)
3194    * unless U_CHARSET_IS_UTF8 is set to 1.
3195    * @param codepageData an array of bytes in the platform&#39;s default codepage.
3196    * @param dataLength The number of bytes in &lt;TT&gt;codepageData&lt;/TT&gt;.
3197    * @stable ICU 2.0
3198    */
3199   UnicodeString(const char *codepageData, int32_t dataLength);
3200 
3201 #endif
3202 
3203 #if !UCONFIG_NO_CONVERSION
3204 
3205   /**
3206    * char* constructor.
3207    * @param codepageData an array of bytes, null-terminated
3208    * @param codepage the encoding of &lt;TT&gt;codepageData&lt;/TT&gt;.  The special
3209    * value 0 for &lt;TT&gt;codepage&lt;/TT&gt; indicates that the text is in the
3210    * platform&#39;s default codepage.
3211    *
3212    * If &lt;code&gt;codepage&lt;/code&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),
3213    * then a simple conversion is performed on the codepage-invariant
3214    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
3215    * Recommendation: For invariant-character strings use the constructor
3216    * UnicodeString(const char *src, int32_t length, enum EInvariant inv)
3217    * because it avoids object code dependencies of UnicodeString on
3218    * the conversion code.
3219    *
3220    * @stable ICU 2.0
3221    */
3222   UnicodeString(const char *codepageData, const char *codepage);
3223 
3224   /**
3225    * char* constructor.
3226    * @param codepageData an array of bytes.
3227    * @param dataLength The number of bytes in &lt;TT&gt;codepageData&lt;/TT&gt;.
3228    * @param codepage the encoding of &lt;TT&gt;codepageData&lt;/TT&gt;.  The special
3229    * value 0 for &lt;TT&gt;codepage&lt;/TT&gt; indicates that the text is in the
3230    * platform&#39;s default codepage.
3231    * If &lt;code&gt;codepage&lt;/code&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),
3232    * then a simple conversion is performed on the codepage-invariant
3233    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
3234    * Recommendation: For invariant-character strings use the constructor
3235    * UnicodeString(const char *src, int32_t length, enum EInvariant inv)
3236    * because it avoids object code dependencies of UnicodeString on
3237    * the conversion code.
3238    *
3239    * @stable ICU 2.0
3240    */
3241   UnicodeString(const char *codepageData, int32_t dataLength, const char *codepage);
3242 
3243   /**
3244    * char * / UConverter constructor.
3245    * This constructor uses an existing UConverter object to
3246    * convert the codepage string to Unicode and construct a UnicodeString
3247    * from that.
3248    *
3249    * The converter is reset at first.
3250    * If the error code indicates a failure before this constructor is called,
3251    * or if an error occurs during conversion or construction,
3252    * then the string will be bogus.
3253    *
3254    * This function avoids the overhead of opening and closing a converter if
3255    * multiple strings are constructed.
3256    *
3257    * @param src input codepage string
3258    * @param srcLength length of the input string, can be -1 for NUL-terminated strings
3259    * @param cnv converter object (ucnv_resetToUnicode() will be called),
3260    *        can be NULL for the default converter
3261    * @param errorCode normal ICU error code
3262    * @stable ICU 2.0
3263    */
3264   UnicodeString(
3265         const char *src, int32_t srcLength,
3266         UConverter *cnv,
3267         UErrorCode &amp;errorCode);
3268 
3269 #endif
3270 
3271   /**
3272    * Constructs a Unicode string from an invariant-character char * string.
3273    * About invariant characters see utypes.h.
3274    * This constructor has no runtime dependency on conversion code and is
3275    * therefore recommended over ones taking a charset name string
3276    * (where the empty string &quot;&quot; indicates invariant-character conversion).
3277    *
3278    * Use the macro US_INV as the third, signature-distinguishing parameter.
3279    *
3280    * For example:
3281    * \code
3282    * void fn(const char *s) {
3283    *   UnicodeString ustr(s, -1, US_INV);
3284    *   // use ustr ...
3285    * }
3286    * \endcode
3287    *
3288    * @param src String using only invariant characters.
3289    * @param length Length of src, or -1 if NUL-terminated.
3290    * @param inv Signature-distinguishing paramater, use US_INV.
3291    *
3292    * @see US_INV
3293    * @stable ICU 3.2
3294    */
3295   UnicodeString(const char *src, int32_t length, enum EInvariant inv);
3296 
3297 
3298   /**
3299    * Copy constructor.
3300    *
3301    * Starting with ICU 2.4, the assignment operator and the copy constructor
3302    * allocate a new buffer and copy the buffer contents even for readonly aliases.
3303    * By contrast, the fastCopyFrom() function implements the old,
3304    * more efficient but less safe behavior
3305    * of making this string also a readonly alias to the same buffer.
3306    *
3307    * If the source object has an &quot;open&quot; buffer from getBuffer(minCapacity),
3308    * then the copy is an empty string.
3309    *
3310    * @param that The UnicodeString object to copy.
3311    * @stable ICU 2.0
3312    * @see fastCopyFrom
3313    */
3314   UnicodeString(const UnicodeString&amp; that);
3315 
3316   /**
3317    * Move constructor; might leave src in bogus state.
3318    * This string will have the same contents and state that the source string had.
3319    * @param src source string
3320    * @stable ICU 56
3321    */
3322   UnicodeString(UnicodeString &amp;&amp;src) U_NOEXCEPT;
3323 
3324   /**
3325    * &#39;Substring&#39; constructor from tail of source string.
3326    * @param src The UnicodeString object to copy.
3327    * @param srcStart The offset into &lt;tt&gt;src&lt;/tt&gt; at which to start copying.
3328    * @stable ICU 2.2
3329    */
3330   UnicodeString(const UnicodeString&amp; src, int32_t srcStart);
3331 
3332   /**
3333    * &#39;Substring&#39; constructor from subrange of source string.
3334    * @param src The UnicodeString object to copy.
3335    * @param srcStart The offset into &lt;tt&gt;src&lt;/tt&gt; at which to start copying.
3336    * @param srcLength The number of characters from &lt;tt&gt;src&lt;/tt&gt; to copy.
3337    * @stable ICU 2.2
3338    */
3339   UnicodeString(const UnicodeString&amp; src, int32_t srcStart, int32_t srcLength);
3340 
3341   /**
3342    * Clone this object, an instance of a subclass of Replaceable.
3343    * Clones can be used concurrently in multiple threads.
3344    * If a subclass does not implement clone(), or if an error occurs,
3345    * then NULL is returned.
3346    * The clone functions in all subclasses return a pointer to a Replaceable
3347    * because some compilers do not support covariant (same-as-this)
3348    * return types; cast to the appropriate subclass if necessary.
3349    * The caller must delete the clone.
3350    *
3351    * @return a clone of this object
3352    *
3353    * @see Replaceable::clone
3354    * @see getDynamicClassID
3355    * @stable ICU 2.6
3356    */
3357   virtual Replaceable *clone() const;
3358 
3359   /** Destructor.
3360    * @stable ICU 2.0
3361    */
3362   virtual ~UnicodeString();
3363 
3364   /**
3365    * Create a UnicodeString from a UTF-8 string.
3366    * Illegal input is replaced with U+FFFD. Otherwise, errors result in a bogus string.
3367    * Calls u_strFromUTF8WithSub().
3368    *
3369    * @param utf8 UTF-8 input string.
3370    *             Note that a StringPiece can be implicitly constructed
3371    *             from a std::string or a NUL-terminated const char * string.
3372    * @return A UnicodeString with equivalent UTF-16 contents.
3373    * @see toUTF8
3374    * @see toUTF8String
3375    * @stable ICU 4.2
3376    */
3377   static UnicodeString fromUTF8(StringPiece utf8);
3378 
3379   /**
3380    * Create a UnicodeString from a UTF-32 string.
3381    * Illegal input is replaced with U+FFFD. Otherwise, errors result in a bogus string.
3382    * Calls u_strFromUTF32WithSub().
3383    *
3384    * @param utf32 UTF-32 input string. Must not be NULL.
3385    * @param length Length of the input string, or -1 if NUL-terminated.
3386    * @return A UnicodeString with equivalent UTF-16 contents.
3387    * @see toUTF32
3388    * @stable ICU 4.2
3389    */
3390   static UnicodeString fromUTF32(const UChar32 *utf32, int32_t length);
3391 
3392   /* Miscellaneous operations */
3393 
3394   /**
3395    * Unescape a string of characters and return a string containing
3396    * the result.  The following escape sequences are recognized:
3397    *
3398    * \\uhhhh       4 hex digits; h in [0-9A-Fa-f]
3399    * \\Uhhhhhhhh   8 hex digits
3400    * \\xhh         1-2 hex digits
3401    * \\ooo         1-3 octal digits; o in [0-7]
3402    * \\cX          control-X; X is masked with 0x1F
3403    *
3404    * as well as the standard ANSI C escapes:
3405    *
3406    * \\a =&gt; U+0007, \\b =&gt; U+0008, \\t =&gt; U+0009, \\n =&gt; U+000A,
3407    * \\v =&gt; U+000B, \\f =&gt; U+000C, \\r =&gt; U+000D, \\e =&gt; U+001B,
3408    * \\&amp;quot; =&gt; U+0022, \\&#39; =&gt; U+0027, \\? =&gt; U+003F, \\\\ =&gt; U+005C
3409    *
3410    * Anything else following a backslash is generically escaped.  For
3411    * example, &quot;[a\\-z]&quot; returns &quot;[a-z]&quot;.
3412    *
3413    * If an escape sequence is ill-formed, this method returns an empty
3414    * string.  An example of an ill-formed sequence is &quot;\\u&quot; followed by
3415    * fewer than 4 hex digits.
3416    *
3417    * This function is similar to u_unescape() but not identical to it.
3418    * The latter takes a source char*, so it does escape recognition
3419    * and also invariant conversion.
3420    *
3421    * @return a string with backslash escapes interpreted, or an
3422    * empty string on error.
3423    * @see UnicodeString#unescapeAt()
3424    * @see u_unescape()
3425    * @see u_unescapeAt()
3426    * @stable ICU 2.0
3427    */
3428   UnicodeString unescape() const;
3429 
3430   /**
3431    * Unescape a single escape sequence and return the represented
3432    * character.  See unescape() for a listing of the recognized escape
3433    * sequences.  The character at offset-1 is assumed (without
3434    * checking) to be a backslash.  If the escape sequence is
3435    * ill-formed, or the offset is out of range, U_SENTINEL=-1 is
3436    * returned.
3437    *
3438    * @param offset an input output parameter.  On input, it is the
3439    * offset into this string where the escape sequence is located,
3440    * after the initial backslash.  On output, it is advanced after the
3441    * last character parsed.  On error, it is not advanced at all.
3442    * @return the character represented by the escape sequence at
3443    * offset, or U_SENTINEL=-1 on error.
3444    * @see UnicodeString#unescape()
3445    * @see u_unescape()
3446    * @see u_unescapeAt()
3447    * @stable ICU 2.0
3448    */
3449   UChar32 unescapeAt(int32_t &amp;offset) const;
3450 
3451   /**
3452    * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for this class.
3453    *
3454    * @stable ICU 2.2
3455    */
3456   static UClassID U_EXPORT2 getStaticClassID();
3457 
3458   /**
3459    * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for the actual class.
3460    *
3461    * @stable ICU 2.2
3462    */
3463   virtual UClassID getDynamicClassID() const;
3464 
3465   //========================================
3466   // Implementation methods
3467   //========================================
3468 
3469 protected:
3470   /**
3471    * Implement Replaceable::getLength() (see jitterbug 1027).
3472    * @stable ICU 2.4
3473    */
3474   virtual int32_t getLength() const;
3475 
3476   /**
3477    * The change in Replaceable to use virtual getCharAt() allows
3478    * UnicodeString::charAt() to be inline again (see jitterbug 709).
3479    * @stable ICU 2.4
3480    */
3481   virtual char16_t getCharAt(int32_t offset) const;
3482 
3483   /**
3484    * The change in Replaceable to use virtual getChar32At() allows
3485    * UnicodeString::char32At() to be inline again (see jitterbug 709).
3486    * @stable ICU 2.4
3487    */
3488   virtual UChar32 getChar32At(int32_t offset) const;
3489 
3490 private:
3491   // For char* constructors. Could be made public.
3492   UnicodeString &amp;setToUTF8(StringPiece utf8);
3493   // For extract(char*).
3494   // We could make a toUTF8(target, capacity, errorCode) public but not
3495   // this version: New API will be cleaner if we make callers create substrings
3496   // rather than having start+length on every method,
3497   // and it should take a UErrorCode&amp;.
3498   int32_t
3499   toUTF8(int32_t start, int32_t len,
3500          char *target, int32_t capacity) const;
3501 
3502   /**
3503    * Internal string contents comparison, called by operator==.
3504    * Requires: this &amp; text not bogus and have same lengths.
3505    */
3506   UBool doEquals(const UnicodeString &amp;text, int32_t len) const;
3507 
3508   inline int8_t
3509   doCompare(int32_t start,
3510            int32_t length,
3511            const UnicodeString&amp; srcText,
3512            int32_t srcStart,
3513            int32_t srcLength) const;
3514 
3515   int8_t doCompare(int32_t start,
3516            int32_t length,
3517            const char16_t *srcChars,
3518            int32_t srcStart,
3519            int32_t srcLength) const;
3520 
3521   inline int8_t
3522   doCompareCodePointOrder(int32_t start,
3523                           int32_t length,
3524                           const UnicodeString&amp; srcText,
3525                           int32_t srcStart,
3526                           int32_t srcLength) const;
3527 
3528   int8_t doCompareCodePointOrder(int32_t start,
3529                                  int32_t length,
3530                                  const char16_t *srcChars,
3531                                  int32_t srcStart,
3532                                  int32_t srcLength) const;
3533 
3534   inline int8_t
3535   doCaseCompare(int32_t start,
3536                 int32_t length,
3537                 const UnicodeString &amp;srcText,
3538                 int32_t srcStart,
3539                 int32_t srcLength,
3540                 uint32_t options) const;
3541 
3542   int8_t
3543   doCaseCompare(int32_t start,
3544                 int32_t length,
3545                 const char16_t *srcChars,
3546                 int32_t srcStart,
3547                 int32_t srcLength,
3548                 uint32_t options) const;
3549 
3550   int32_t doIndexOf(char16_t c,
3551             int32_t start,
3552             int32_t length) const;
3553 
3554   int32_t doIndexOf(UChar32 c,
3555                         int32_t start,
3556                         int32_t length) const;
3557 
3558   int32_t doLastIndexOf(char16_t c,
3559                 int32_t start,
3560                 int32_t length) const;
3561 
3562   int32_t doLastIndexOf(UChar32 c,
3563                             int32_t start,
3564                             int32_t length) const;
3565 
3566   void doExtract(int32_t start,
3567          int32_t length,
3568          char16_t *dst,
3569          int32_t dstStart) const;
3570 
3571   inline void doExtract(int32_t start,
3572          int32_t length,
3573          UnicodeString&amp; target) const;
3574 
3575   inline char16_t doCharAt(int32_t offset)  const;
3576 
3577   UnicodeString&amp; doReplace(int32_t start,
3578                int32_t length,
3579                const UnicodeString&amp; srcText,
3580                int32_t srcStart,
3581                int32_t srcLength);
3582 
3583   UnicodeString&amp; doReplace(int32_t start,
3584                int32_t length,
3585                const char16_t *srcChars,
3586                int32_t srcStart,
3587                int32_t srcLength);
3588 
3589   UnicodeString&amp; doAppend(const UnicodeString&amp; src, int32_t srcStart, int32_t srcLength);
3590   UnicodeString&amp; doAppend(const char16_t *srcChars, int32_t srcStart, int32_t srcLength);
3591 
3592   UnicodeString&amp; doReverse(int32_t start,
3593                int32_t length);
3594 
3595   // calculate hash code
3596   int32_t doHashCode(void) const;
3597 
3598   // get pointer to start of array
3599   // these do not check for kOpenGetBuffer, unlike the public getBuffer() function
3600   inline char16_t* getArrayStart(void);
3601   inline const char16_t* getArrayStart(void) const;
3602 
3603   inline UBool hasShortLength() const;
3604   inline int32_t getShortLength() const;
3605 
3606   // A UnicodeString object (not necessarily its current buffer)
3607   // is writable unless it isBogus() or it has an &quot;open&quot; getBuffer(minCapacity).
3608   inline UBool isWritable() const;
3609 
3610   // Is the current buffer writable?
3611   inline UBool isBufferWritable() const;
3612 
3613   // None of the following does releaseArray().
3614   inline void setZeroLength();
3615   inline void setShortLength(int32_t len);
3616   inline void setLength(int32_t len);
3617   inline void setToEmpty();
3618   inline void setArray(char16_t *array, int32_t len, int32_t capacity); // sets length but not flags
3619 
3620   // allocate the array; result may be the stack buffer
3621   // sets refCount to 1 if appropriate
3622   // sets fArray, fCapacity, and flags
3623   // sets length to 0
3624   // returns boolean for success or failure
3625   UBool allocate(int32_t capacity);
3626 
3627   // release the array if owned
3628   void releaseArray(void);
3629 
3630   // turn a bogus string into an empty one
3631   void unBogus();
3632 
3633   // implements assigment operator, copy constructor, and fastCopyFrom()
3634   UnicodeString &amp;copyFrom(const UnicodeString &amp;src, UBool fastCopy=FALSE);
3635 
3636   // Copies just the fields without memory management.
3637   void copyFieldsFrom(UnicodeString &amp;src, UBool setSrcToBogus) U_NOEXCEPT;
3638 
3639   // Pin start and limit to acceptable values.
3640   inline void pinIndex(int32_t&amp; start) const;
3641   inline void pinIndices(int32_t&amp; start,
3642                          int32_t&amp; length) const;
3643 
3644 #if !UCONFIG_NO_CONVERSION
3645 
3646   /* Internal extract() using UConverter. */
3647   int32_t doExtract(int32_t start, int32_t length,
3648                     char *dest, int32_t destCapacity,
3649                     UConverter *cnv,
3650                     UErrorCode &amp;errorCode) const;
3651 
3652   /*
3653    * Real constructor for converting from codepage data.
3654    * It assumes that it is called with !fRefCounted.
3655    *
3656    * If &lt;code&gt;codepage==0&lt;/code&gt;, then the default converter
3657    * is used for the platform encoding.
3658    * If &lt;code&gt;codepage&lt;/code&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),
3659    * then a simple conversion is performed on the codepage-invariant
3660    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
3661    */
3662   void doCodepageCreate(const char *codepageData,
3663                         int32_t dataLength,
3664                         const char *codepage);
3665 
3666   /*
3667    * Worker function for creating a UnicodeString from
3668    * a codepage string using a UConverter.
3669    */
3670   void
3671   doCodepageCreate(const char *codepageData,
3672                    int32_t dataLength,
3673                    UConverter *converter,
3674                    UErrorCode &amp;status);
3675 
3676 #endif
3677 
3678   /*
3679    * This function is called when write access to the array
3680    * is necessary.
3681    *
3682    * We need to make a copy of the array if
3683    * the buffer is read-only, or
3684    * the buffer is refCounted (shared), and refCount&gt;1, or
3685    * the buffer is too small.
3686    *
3687    * Return FALSE if memory could not be allocated.
3688    */
3689   UBool cloneArrayIfNeeded(int32_t newCapacity = -1,
3690                             int32_t growCapacity = -1,
3691                             UBool doCopyArray = TRUE,
3692                             int32_t **pBufferToDelete = 0,
3693                             UBool forceClone = FALSE);
3694 
3695   /**
3696    * Common function for UnicodeString case mappings.
3697    * The stringCaseMapper has the same type UStringCaseMapper
3698    * as in ustr_imp.h for ustrcase_map().
3699    */
3700   UnicodeString &amp;
3701   caseMap(int32_t caseLocale, uint32_t options,
3702 #if !UCONFIG_NO_BREAK_ITERATION
3703           BreakIterator *iter,
3704 #endif
3705           UStringCaseMapper *stringCaseMapper);
3706 
3707   // ref counting
3708   void addRef(void);
3709   int32_t removeRef(void);
3710   int32_t refCount(void) const;
3711 
3712   // constants
3713   enum {
3714     /**
3715      * Size of stack buffer for short strings.
3716      * Must be at least U16_MAX_LENGTH for the single-code point constructor to work.
3717      * @see UNISTR_OBJECT_SIZE
3718      */
3719     US_STACKBUF_SIZE=(int32_t)(UNISTR_OBJECT_SIZE-sizeof(void *)-2)/U_SIZEOF_UCHAR,
3720     kInvalidUChar=0xffff, // U+FFFF returned by charAt(invalid index)
3721     kInvalidHashCode=0, // invalid hash code
3722     kEmptyHashCode=1, // hash code for empty string
3723 
3724     // bit flag values for fLengthAndFlags
3725     kIsBogus=1,         // this string is bogus, i.e., not valid or NULL
3726     kUsingStackBuffer=2,// using fUnion.fStackFields instead of fUnion.fFields
3727     kRefCounted=4,      // there is a refCount field before the characters in fArray
3728     kBufferIsReadonly=8,// do not write to this buffer
3729     kOpenGetBuffer=16,  // getBuffer(minCapacity) was called (is &quot;open&quot;),
3730                         // and releaseBuffer(newLength) must be called
3731     kAllStorageFlags=0x1f,
3732 
3733     kLengthShift=5,     // remaining 11 bits for non-negative short length, or negative if long
3734     kLength1=1&lt;&lt;kLengthShift,
3735     kMaxShortLength=0x3ff,  // max non-negative short length (leaves top bit 0)
3736     kLengthIsLarge=0xffe0,  // short length &lt; 0, real length is in fUnion.fFields.fLength
3737 
3738     // combined values for convenience
3739     kShortString=kUsingStackBuffer,
3740     kLongString=kRefCounted,
3741     kReadonlyAlias=kBufferIsReadonly,
3742     kWritableAlias=0
3743   };
3744 
3745   friend class UnicodeStringAppendable;
3746 
3747   union StackBufferOrFields;        // forward declaration necessary before friend declaration
3748   friend union StackBufferOrFields; // make US_STACKBUF_SIZE visible inside fUnion
3749 
3750   /*
3751    * The following are all the class fields that are stored
3752    * in each UnicodeString object.
3753    * Note that UnicodeString has virtual functions,
3754    * therefore there is an implicit vtable pointer
3755    * as the first real field.
3756    * The fields should be aligned such that no padding is necessary.
3757    * On 32-bit machines, the size should be 32 bytes,
3758    * on 64-bit machines (8-byte pointers), it should be 40 bytes.
3759    *
3760    * We use a hack to achieve this.
3761    *
3762    * With at least some compilers, each of the following is forced to
3763    * a multiple of sizeof(pointer) [the largest field base unit here is a data pointer],
3764    * rounded up with additional padding if the fields do not already fit that requirement:
3765    * - sizeof(class UnicodeString)
3766    * - offsetof(UnicodeString, fUnion)
3767    * - sizeof(fUnion)
3768    * - sizeof(fStackFields)
3769    *
3770    * We optimize for the longest possible internal buffer for short strings.
3771    * fUnion.fStackFields begins with 2 bytes for storage flags
3772    * and the length of relatively short strings,
3773    * followed by the buffer for short string contents.
3774    * There is no padding inside fStackFields.
3775    *
3776    * Heap-allocated and aliased strings use fUnion.fFields.
3777    * Both fStackFields and fFields must begin with the same fields for flags and short length,
3778    * that is, those must have the same memory offsets inside the object,
3779    * because the flags must be inspected in order to decide which half of fUnion is being used.
3780    * We assume that the compiler does not reorder the fields.
3781    *
3782    * (Padding at the end of fFields is ok:
3783    * As long as it is no larger than fStackFields, it is not wasted space.)
3784    *
3785    * For some of the history of the UnicodeString class fields layout, see
3786    * - ICU ticket #11551 &quot;longer UnicodeString contents in stack buffer&quot;
3787    * - ICU ticket #11336 &quot;UnicodeString: recombine stack buffer arrays&quot;
3788    * - ICU ticket #8322 &quot;why is sizeof(UnicodeString)==48?&quot;
3789    */
3790   // (implicit) *vtable;
3791   union StackBufferOrFields {
3792     // fStackFields is used iff (fLengthAndFlags&amp;kUsingStackBuffer) else fFields is used.
3793     // Each struct of the union must begin with fLengthAndFlags.
3794     struct {
3795       int16_t fLengthAndFlags;          // bit fields: see constants above
3796       char16_t fBuffer[US_STACKBUF_SIZE];  // buffer for short strings
3797     } fStackFields;
3798     struct {
3799       int16_t fLengthAndFlags;          // bit fields: see constants above
3800       int32_t fLength;    // number of characters in fArray if &gt;127; else undefined
3801       int32_t fCapacity;  // capacity of fArray (in char16_ts)
3802       // array pointer last to minimize padding for machines with P128 data model
3803       // or pointer sizes that are not a power of 2
3804       char16_t   *fArray;    // the Unicode data
3805     } fFields;
3806   } fUnion;
3807 };
3808 
3809 /**
3810  * Create a new UnicodeString with the concatenation of two others.
3811  *
3812  * @param s1 The first string to be copied to the new one.
3813  * @param s2 The second string to be copied to the new one, after s1.
3814  * @return UnicodeString(s1).append(s2)
3815  * @stable ICU 2.8
3816  */
3817 U_COMMON_API UnicodeString U_EXPORT2
3818 operator+ (const UnicodeString &amp;s1, const UnicodeString &amp;s2);
3819 
3820 //========================================
3821 // Inline members
3822 //========================================
3823 
3824 //========================================
3825 // Privates
3826 //========================================
3827 
3828 inline void
3829 UnicodeString::pinIndex(int32_t&amp; start) const
3830 {
3831   // pin index
3832   if(start &lt; 0) {
3833     start = 0;
3834   } else if(start &gt; length()) {
3835     start = length();
3836   }
3837 }
3838 
3839 inline void
3840 UnicodeString::pinIndices(int32_t&amp; start,
3841                           int32_t&amp; _length) const
3842 {
3843   // pin indices
3844   int32_t len = length();
3845   if(start &lt; 0) {
3846     start = 0;
3847   } else if(start &gt; len) {
3848     start = len;
3849   }
3850   if(_length &lt; 0) {
3851     _length = 0;
3852   } else if(_length &gt; (len - start)) {
3853     _length = (len - start);
3854   }
3855 }
3856 
3857 inline char16_t*
3858 UnicodeString::getArrayStart() {
3859   return (fUnion.fFields.fLengthAndFlags&amp;kUsingStackBuffer) ?
3860     fUnion.fStackFields.fBuffer : fUnion.fFields.fArray;
3861 }
3862 
3863 inline const char16_t*
3864 UnicodeString::getArrayStart() const {
3865   return (fUnion.fFields.fLengthAndFlags&amp;kUsingStackBuffer) ?
3866     fUnion.fStackFields.fBuffer : fUnion.fFields.fArray;
3867 }
3868 
3869 //========================================
3870 // Default constructor
3871 //========================================
3872 
3873 inline
3874 UnicodeString::UnicodeString() {
3875   fUnion.fStackFields.fLengthAndFlags=kShortString;
3876 }
3877 
3878 inline UnicodeString::UnicodeString(const std::nullptr_t /*text*/) {
3879   fUnion.fStackFields.fLengthAndFlags=kShortString;
3880 }
3881 
3882 inline UnicodeString::UnicodeString(const std::nullptr_t /*text*/, int32_t /*length*/) {
3883   fUnion.fStackFields.fLengthAndFlags=kShortString;
3884 }
3885 
3886 inline UnicodeString::UnicodeString(std::nullptr_t /*buffer*/, int32_t /*buffLength*/, int32_t /*buffCapacity*/) {
3887   fUnion.fStackFields.fLengthAndFlags=kShortString;
3888 }
3889 
3890 //========================================
3891 // Read-only implementation methods
3892 //========================================
3893 inline UBool
3894 UnicodeString::hasShortLength() const {
3895   return fUnion.fFields.fLengthAndFlags&gt;=0;
3896 }
3897 
3898 inline int32_t
3899 UnicodeString::getShortLength() const {
3900   // fLengthAndFlags must be non-negative -&gt; short length &gt;= 0
3901   // and arithmetic or logical shift does not matter.
3902   return fUnion.fFields.fLengthAndFlags&gt;&gt;kLengthShift;
3903 }
3904 
3905 inline int32_t
3906 UnicodeString::length() const {
3907   return hasShortLength() ? getShortLength() : fUnion.fFields.fLength;
3908 }
3909 
3910 inline int32_t
3911 UnicodeString::getCapacity() const {
3912   return (fUnion.fFields.fLengthAndFlags&amp;kUsingStackBuffer) ?
3913     US_STACKBUF_SIZE : fUnion.fFields.fCapacity;
3914 }
3915 
3916 inline int32_t
3917 UnicodeString::hashCode() const
3918 { return doHashCode(); }
3919 
3920 inline UBool
3921 UnicodeString::isBogus() const
3922 { return (UBool)(fUnion.fFields.fLengthAndFlags &amp; kIsBogus); }
3923 
3924 inline UBool
3925 UnicodeString::isWritable() const
3926 { return (UBool)!(fUnion.fFields.fLengthAndFlags&amp;(kOpenGetBuffer|kIsBogus)); }
3927 
3928 inline UBool
3929 UnicodeString::isBufferWritable() const
3930 {
3931   return (UBool)(
3932       !(fUnion.fFields.fLengthAndFlags&amp;(kOpenGetBuffer|kIsBogus|kBufferIsReadonly)) &amp;&amp;
3933       (!(fUnion.fFields.fLengthAndFlags&amp;kRefCounted) || refCount()==1));
3934 }
3935 
3936 inline const char16_t *
3937 UnicodeString::getBuffer() const {
3938   if(fUnion.fFields.fLengthAndFlags&amp;(kIsBogus|kOpenGetBuffer)) {
3939     return nullptr;
3940   } else if(fUnion.fFields.fLengthAndFlags&amp;kUsingStackBuffer) {
3941     return fUnion.fStackFields.fBuffer;
3942   } else {
3943     return fUnion.fFields.fArray;
3944   }
3945 }
3946 
3947 //========================================
3948 // Read-only alias methods
3949 //========================================
3950 inline int8_t
3951 UnicodeString::doCompare(int32_t start,
3952               int32_t thisLength,
3953               const UnicodeString&amp; srcText,
3954               int32_t srcStart,
3955               int32_t srcLength) const
3956 {
3957   if(srcText.isBogus()) {
3958     return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
3959   } else {
3960     srcText.pinIndices(srcStart, srcLength);
3961     return doCompare(start, thisLength, srcText.getArrayStart(), srcStart, srcLength);
3962   }
3963 }
3964 
3965 inline UBool
3966 UnicodeString::operator== (const UnicodeString&amp; text) const
3967 {
3968   if(isBogus()) {
3969     return text.isBogus();
3970   } else {
3971     int32_t len = length(), textLength = text.length();
3972     return !text.isBogus() &amp;&amp; len == textLength &amp;&amp; doEquals(text, len);
3973   }
3974 }
3975 
3976 inline UBool
3977 UnicodeString::operator!= (const UnicodeString&amp; text) const
3978 { return (! operator==(text)); }
3979 
3980 inline UBool
3981 UnicodeString::operator&gt; (const UnicodeString&amp; text) const
3982 { return doCompare(0, length(), text, 0, text.length()) == 1; }
3983 
3984 inline UBool
3985 UnicodeString::operator&lt; (const UnicodeString&amp; text) const
3986 { return doCompare(0, length(), text, 0, text.length()) == -1; }
3987 
3988 inline UBool
3989 UnicodeString::operator&gt;= (const UnicodeString&amp; text) const
3990 { return doCompare(0, length(), text, 0, text.length()) != -1; }
3991 
3992 inline UBool
3993 UnicodeString::operator&lt;= (const UnicodeString&amp; text) const
3994 { return doCompare(0, length(), text, 0, text.length()) != 1; }
3995 
3996 inline int8_t
3997 UnicodeString::compare(const UnicodeString&amp; text) const
3998 { return doCompare(0, length(), text, 0, text.length()); }
3999 
4000 inline int8_t
4001 UnicodeString::compare(int32_t start,
4002                int32_t _length,
4003                const UnicodeString&amp; srcText) const
4004 { return doCompare(start, _length, srcText, 0, srcText.length()); }
4005 
4006 inline int8_t
4007 UnicodeString::compare(ConstChar16Ptr srcChars,
4008                int32_t srcLength) const
4009 { return doCompare(0, length(), srcChars, 0, srcLength); }
4010 
4011 inline int8_t
4012 UnicodeString::compare(int32_t start,
4013                int32_t _length,
4014                const UnicodeString&amp; srcText,
4015                int32_t srcStart,
4016                int32_t srcLength) const
4017 { return doCompare(start, _length, srcText, srcStart, srcLength); }
4018 
4019 inline int8_t
4020 UnicodeString::compare(int32_t start,
4021                int32_t _length,
4022                const char16_t *srcChars) const
4023 { return doCompare(start, _length, srcChars, 0, _length); }
4024 
4025 inline int8_t
4026 UnicodeString::compare(int32_t start,
4027                int32_t _length,
4028                const char16_t *srcChars,
4029                int32_t srcStart,
4030                int32_t srcLength) const
4031 { return doCompare(start, _length, srcChars, srcStart, srcLength); }
4032 
4033 inline int8_t
4034 UnicodeString::compareBetween(int32_t start,
4035                   int32_t limit,
4036                   const UnicodeString&amp; srcText,
4037                   int32_t srcStart,
4038                   int32_t srcLimit) const
4039 { return doCompare(start, limit - start,
4040            srcText, srcStart, srcLimit - srcStart); }
4041 
4042 inline int8_t
4043 UnicodeString::doCompareCodePointOrder(int32_t start,
4044                                        int32_t thisLength,
4045                                        const UnicodeString&amp; srcText,
4046                                        int32_t srcStart,
4047                                        int32_t srcLength) const
4048 {
4049   if(srcText.isBogus()) {
4050     return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
4051   } else {
4052     srcText.pinIndices(srcStart, srcLength);
4053     return doCompareCodePointOrder(start, thisLength, srcText.getArrayStart(), srcStart, srcLength);
4054   }
4055 }
4056 
4057 inline int8_t
4058 UnicodeString::compareCodePointOrder(const UnicodeString&amp; text) const
4059 { return doCompareCodePointOrder(0, length(), text, 0, text.length()); }
4060 
4061 inline int8_t
4062 UnicodeString::compareCodePointOrder(int32_t start,
4063                                      int32_t _length,
4064                                      const UnicodeString&amp; srcText) const
4065 { return doCompareCodePointOrder(start, _length, srcText, 0, srcText.length()); }
4066 
4067 inline int8_t
4068 UnicodeString::compareCodePointOrder(ConstChar16Ptr srcChars,
4069                                      int32_t srcLength) const
4070 { return doCompareCodePointOrder(0, length(), srcChars, 0, srcLength); }
4071 
4072 inline int8_t
4073 UnicodeString::compareCodePointOrder(int32_t start,
4074                                      int32_t _length,
4075                                      const UnicodeString&amp; srcText,
4076                                      int32_t srcStart,
4077                                      int32_t srcLength) const
4078 { return doCompareCodePointOrder(start, _length, srcText, srcStart, srcLength); }
4079 
4080 inline int8_t
4081 UnicodeString::compareCodePointOrder(int32_t start,
4082                                      int32_t _length,
4083                                      const char16_t *srcChars) const
4084 { return doCompareCodePointOrder(start, _length, srcChars, 0, _length); }
4085 
4086 inline int8_t
4087 UnicodeString::compareCodePointOrder(int32_t start,
4088                                      int32_t _length,
4089                                      const char16_t *srcChars,
4090                                      int32_t srcStart,
4091                                      int32_t srcLength) const
4092 { return doCompareCodePointOrder(start, _length, srcChars, srcStart, srcLength); }
4093 
4094 inline int8_t
4095 UnicodeString::compareCodePointOrderBetween(int32_t start,
4096                                             int32_t limit,
4097                                             const UnicodeString&amp; srcText,
4098                                             int32_t srcStart,
4099                                             int32_t srcLimit) const
4100 { return doCompareCodePointOrder(start, limit - start,
4101            srcText, srcStart, srcLimit - srcStart); }
4102 
4103 inline int8_t
4104 UnicodeString::doCaseCompare(int32_t start,
4105                              int32_t thisLength,
4106                              const UnicodeString &amp;srcText,
4107                              int32_t srcStart,
4108                              int32_t srcLength,
4109                              uint32_t options) const
4110 {
4111   if(srcText.isBogus()) {
4112     return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
4113   } else {
4114     srcText.pinIndices(srcStart, srcLength);
4115     return doCaseCompare(start, thisLength, srcText.getArrayStart(), srcStart, srcLength, options);
4116   }
4117 }
4118 
4119 inline int8_t
4120 UnicodeString::caseCompare(const UnicodeString &amp;text, uint32_t options) const {
4121   return doCaseCompare(0, length(), text, 0, text.length(), options);
4122 }
4123 
4124 inline int8_t
4125 UnicodeString::caseCompare(int32_t start,
4126                            int32_t _length,
4127                            const UnicodeString &amp;srcText,
4128                            uint32_t options) const {
4129   return doCaseCompare(start, _length, srcText, 0, srcText.length(), options);
4130 }
4131 
4132 inline int8_t
4133 UnicodeString::caseCompare(ConstChar16Ptr srcChars,
4134                            int32_t srcLength,
4135                            uint32_t options) const {
4136   return doCaseCompare(0, length(), srcChars, 0, srcLength, options);
4137 }
4138 
4139 inline int8_t
4140 UnicodeString::caseCompare(int32_t start,
4141                            int32_t _length,
4142                            const UnicodeString &amp;srcText,
4143                            int32_t srcStart,
4144                            int32_t srcLength,
4145                            uint32_t options) const {
4146   return doCaseCompare(start, _length, srcText, srcStart, srcLength, options);
4147 }
4148 
4149 inline int8_t
4150 UnicodeString::caseCompare(int32_t start,
4151                            int32_t _length,
4152                            const char16_t *srcChars,
4153                            uint32_t options) const {
4154   return doCaseCompare(start, _length, srcChars, 0, _length, options);
4155 }
4156 
4157 inline int8_t
4158 UnicodeString::caseCompare(int32_t start,
4159                            int32_t _length,
4160                            const char16_t *srcChars,
4161                            int32_t srcStart,
4162                            int32_t srcLength,
4163                            uint32_t options) const {
4164   return doCaseCompare(start, _length, srcChars, srcStart, srcLength, options);
4165 }
4166 
4167 inline int8_t
4168 UnicodeString::caseCompareBetween(int32_t start,
4169                                   int32_t limit,
4170                                   const UnicodeString &amp;srcText,
4171                                   int32_t srcStart,
4172                                   int32_t srcLimit,
4173                                   uint32_t options) const {
4174   return doCaseCompare(start, limit - start, srcText, srcStart, srcLimit - srcStart, options);
4175 }
4176 
4177 inline int32_t
4178 UnicodeString::indexOf(const UnicodeString&amp; srcText,
4179                int32_t srcStart,
4180                int32_t srcLength,
4181                int32_t start,
4182                int32_t _length) const
4183 {
4184   if(!srcText.isBogus()) {
4185     srcText.pinIndices(srcStart, srcLength);
4186     if(srcLength &gt; 0) {
4187       return indexOf(srcText.getArrayStart(), srcStart, srcLength, start, _length);
4188     }
4189   }
4190   return -1;
4191 }
4192 
4193 inline int32_t
4194 UnicodeString::indexOf(const UnicodeString&amp; text) const
4195 { return indexOf(text, 0, text.length(), 0, length()); }
4196 
4197 inline int32_t
4198 UnicodeString::indexOf(const UnicodeString&amp; text,
4199                int32_t start) const {
4200   pinIndex(start);
4201   return indexOf(text, 0, text.length(), start, length() - start);
4202 }
4203 
4204 inline int32_t
4205 UnicodeString::indexOf(const UnicodeString&amp; text,
4206                int32_t start,
4207                int32_t _length) const
4208 { return indexOf(text, 0, text.length(), start, _length); }
4209 
4210 inline int32_t
4211 UnicodeString::indexOf(const char16_t *srcChars,
4212                int32_t srcLength,
4213                int32_t start) const {
4214   pinIndex(start);
4215   return indexOf(srcChars, 0, srcLength, start, length() - start);
4216 }
4217 
4218 inline int32_t
4219 UnicodeString::indexOf(ConstChar16Ptr srcChars,
4220                int32_t srcLength,
4221                int32_t start,
4222                int32_t _length) const
4223 { return indexOf(srcChars, 0, srcLength, start, _length); }
4224 
4225 inline int32_t
4226 UnicodeString::indexOf(char16_t c,
4227                int32_t start,
4228                int32_t _length) const
4229 { return doIndexOf(c, start, _length); }
4230 
4231 inline int32_t
4232 UnicodeString::indexOf(UChar32 c,
4233                int32_t start,
4234                int32_t _length) const
4235 { return doIndexOf(c, start, _length); }
4236 
4237 inline int32_t
4238 UnicodeString::indexOf(char16_t c) const
4239 { return doIndexOf(c, 0, length()); }
4240 
4241 inline int32_t
4242 UnicodeString::indexOf(UChar32 c) const
4243 { return indexOf(c, 0, length()); }
4244 
4245 inline int32_t
4246 UnicodeString::indexOf(char16_t c,
4247                int32_t start) const {
4248   pinIndex(start);
4249   return doIndexOf(c, start, length() - start);
4250 }
4251 
4252 inline int32_t
4253 UnicodeString::indexOf(UChar32 c,
4254                int32_t start) const {
4255   pinIndex(start);
4256   return indexOf(c, start, length() - start);
4257 }
4258 
4259 inline int32_t
4260 UnicodeString::lastIndexOf(ConstChar16Ptr srcChars,
4261                int32_t srcLength,
4262                int32_t start,
4263                int32_t _length) const
4264 { return lastIndexOf(srcChars, 0, srcLength, start, _length); }
4265 
4266 inline int32_t
4267 UnicodeString::lastIndexOf(const char16_t *srcChars,
4268                int32_t srcLength,
4269                int32_t start) const {
4270   pinIndex(start);
4271   return lastIndexOf(srcChars, 0, srcLength, start, length() - start);
4272 }
4273 
4274 inline int32_t
4275 UnicodeString::lastIndexOf(const UnicodeString&amp; srcText,
4276                int32_t srcStart,
4277                int32_t srcLength,
4278                int32_t start,
4279                int32_t _length) const
4280 {
4281   if(!srcText.isBogus()) {
4282     srcText.pinIndices(srcStart, srcLength);
4283     if(srcLength &gt; 0) {
4284       return lastIndexOf(srcText.getArrayStart(), srcStart, srcLength, start, _length);
4285     }
4286   }
4287   return -1;
4288 }
4289 
4290 inline int32_t
4291 UnicodeString::lastIndexOf(const UnicodeString&amp; text,
4292                int32_t start,
4293                int32_t _length) const
4294 { return lastIndexOf(text, 0, text.length(), start, _length); }
4295 
4296 inline int32_t
4297 UnicodeString::lastIndexOf(const UnicodeString&amp; text,
4298                int32_t start) const {
4299   pinIndex(start);
4300   return lastIndexOf(text, 0, text.length(), start, length() - start);
4301 }
4302 
4303 inline int32_t
4304 UnicodeString::lastIndexOf(const UnicodeString&amp; text) const
4305 { return lastIndexOf(text, 0, text.length(), 0, length()); }
4306 
4307 inline int32_t
4308 UnicodeString::lastIndexOf(char16_t c,
4309                int32_t start,
4310                int32_t _length) const
4311 { return doLastIndexOf(c, start, _length); }
4312 
4313 inline int32_t
4314 UnicodeString::lastIndexOf(UChar32 c,
4315                int32_t start,
4316                int32_t _length) const {
4317   return doLastIndexOf(c, start, _length);
4318 }
4319 
4320 inline int32_t
4321 UnicodeString::lastIndexOf(char16_t c) const
4322 { return doLastIndexOf(c, 0, length()); }
4323 
4324 inline int32_t
4325 UnicodeString::lastIndexOf(UChar32 c) const {
4326   return lastIndexOf(c, 0, length());
4327 }
4328 
4329 inline int32_t
4330 UnicodeString::lastIndexOf(char16_t c,
4331                int32_t start) const {
4332   pinIndex(start);
4333   return doLastIndexOf(c, start, length() - start);
4334 }
4335 
4336 inline int32_t
4337 UnicodeString::lastIndexOf(UChar32 c,
4338                int32_t start) const {
4339   pinIndex(start);
4340   return lastIndexOf(c, start, length() - start);
4341 }
4342 
4343 inline UBool
4344 UnicodeString::startsWith(const UnicodeString&amp; text) const
4345 { return compare(0, text.length(), text, 0, text.length()) == 0; }
4346 
4347 inline UBool
4348 UnicodeString::startsWith(const UnicodeString&amp; srcText,
4349               int32_t srcStart,
4350               int32_t srcLength) const
4351 { return doCompare(0, srcLength, srcText, srcStart, srcLength) == 0; }
4352 
4353 inline UBool
4354 UnicodeString::startsWith(ConstChar16Ptr srcChars, int32_t srcLength) const {
4355   if(srcLength &lt; 0) {
4356     srcLength = u_strlen(toUCharPtr(srcChars));
4357   }
4358   return doCompare(0, srcLength, srcChars, 0, srcLength) == 0;
4359 }
4360 
4361 inline UBool
4362 UnicodeString::startsWith(const char16_t *srcChars, int32_t srcStart, int32_t srcLength) const {
4363   if(srcLength &lt; 0) {
4364     srcLength = u_strlen(toUCharPtr(srcChars));
4365   }
4366   return doCompare(0, srcLength, srcChars, srcStart, srcLength) == 0;
4367 }
4368 
4369 inline UBool
4370 UnicodeString::endsWith(const UnicodeString&amp; text) const
4371 { return doCompare(length() - text.length(), text.length(),
4372            text, 0, text.length()) == 0; }
4373 
4374 inline UBool
4375 UnicodeString::endsWith(const UnicodeString&amp; srcText,
4376             int32_t srcStart,
4377             int32_t srcLength) const {
4378   srcText.pinIndices(srcStart, srcLength);
4379   return doCompare(length() - srcLength, srcLength,
4380                    srcText, srcStart, srcLength) == 0;
4381 }
4382 
4383 inline UBool
4384 UnicodeString::endsWith(ConstChar16Ptr srcChars,
4385             int32_t srcLength) const {
4386   if(srcLength &lt; 0) {
4387     srcLength = u_strlen(toUCharPtr(srcChars));
4388   }
4389   return doCompare(length() - srcLength, srcLength,
4390                    srcChars, 0, srcLength) == 0;
4391 }
4392 
4393 inline UBool
4394 UnicodeString::endsWith(const char16_t *srcChars,
4395             int32_t srcStart,
4396             int32_t srcLength) const {
4397   if(srcLength &lt; 0) {
4398     srcLength = u_strlen(toUCharPtr(srcChars + srcStart));
4399   }
4400   return doCompare(length() - srcLength, srcLength,
4401                    srcChars, srcStart, srcLength) == 0;
4402 }
4403 
4404 //========================================
4405 // replace
4406 //========================================
4407 inline UnicodeString&amp;
4408 UnicodeString::replace(int32_t start,
4409                int32_t _length,
4410                const UnicodeString&amp; srcText)
4411 { return doReplace(start, _length, srcText, 0, srcText.length()); }
4412 
4413 inline UnicodeString&amp;
4414 UnicodeString::replace(int32_t start,
4415                int32_t _length,
4416                const UnicodeString&amp; srcText,
4417                int32_t srcStart,
4418                int32_t srcLength)
4419 { return doReplace(start, _length, srcText, srcStart, srcLength); }
4420 
4421 inline UnicodeString&amp;
4422 UnicodeString::replace(int32_t start,
4423                int32_t _length,
4424                ConstChar16Ptr srcChars,
4425                int32_t srcLength)
4426 { return doReplace(start, _length, srcChars, 0, srcLength); }
4427 
4428 inline UnicodeString&amp;
4429 UnicodeString::replace(int32_t start,
4430                int32_t _length,
4431                const char16_t *srcChars,
4432                int32_t srcStart,
4433                int32_t srcLength)
4434 { return doReplace(start, _length, srcChars, srcStart, srcLength); }
4435 
4436 inline UnicodeString&amp;
4437 UnicodeString::replace(int32_t start,
4438                int32_t _length,
4439                char16_t srcChar)
4440 { return doReplace(start, _length, &amp;srcChar, 0, 1); }
4441 
4442 inline UnicodeString&amp;
4443 UnicodeString::replaceBetween(int32_t start,
4444                   int32_t limit,
4445                   const UnicodeString&amp; srcText)
4446 { return doReplace(start, limit - start, srcText, 0, srcText.length()); }
4447 
4448 inline UnicodeString&amp;
4449 UnicodeString::replaceBetween(int32_t start,
4450                   int32_t limit,
4451                   const UnicodeString&amp; srcText,
4452                   int32_t srcStart,
4453                   int32_t srcLimit)
4454 { return doReplace(start, limit - start, srcText, srcStart, srcLimit - srcStart); }
4455 
4456 inline UnicodeString&amp;
4457 UnicodeString::findAndReplace(const UnicodeString&amp; oldText,
4458                   const UnicodeString&amp; newText)
4459 { return findAndReplace(0, length(), oldText, 0, oldText.length(),
4460             newText, 0, newText.length()); }
4461 
4462 inline UnicodeString&amp;
4463 UnicodeString::findAndReplace(int32_t start,
4464                   int32_t _length,
4465                   const UnicodeString&amp; oldText,
4466                   const UnicodeString&amp; newText)
4467 { return findAndReplace(start, _length, oldText, 0, oldText.length(),
4468             newText, 0, newText.length()); }
4469 
4470 // ============================
4471 // extract
4472 // ============================
4473 inline void
4474 UnicodeString::doExtract(int32_t start,
4475              int32_t _length,
4476              UnicodeString&amp; target) const
4477 { target.replace(0, target.length(), *this, start, _length); }
4478 
4479 inline void
4480 UnicodeString::extract(int32_t start,
4481                int32_t _length,
4482                Char16Ptr target,
4483                int32_t targetStart) const
4484 { doExtract(start, _length, target, targetStart); }
4485 
4486 inline void
4487 UnicodeString::extract(int32_t start,
4488                int32_t _length,
4489                UnicodeString&amp; target) const
4490 { doExtract(start, _length, target); }
4491 
4492 #if !UCONFIG_NO_CONVERSION
4493 
4494 inline int32_t
4495 UnicodeString::extract(int32_t start,
4496                int32_t _length,
4497                char *dst,
4498                const char *codepage) const
4499 
4500 {
4501   // This dstSize value will be checked explicitly
4502   return extract(start, _length, dst, dst!=0 ? 0xffffffff : 0, codepage);
4503 }
4504 
4505 #endif
4506 
4507 inline void
4508 UnicodeString::extractBetween(int32_t start,
4509                   int32_t limit,
4510                   char16_t *dst,
4511                   int32_t dstStart) const {
4512   pinIndex(start);
4513   pinIndex(limit);
4514   doExtract(start, limit - start, dst, dstStart);
4515 }
4516 
4517 inline UnicodeString
4518 UnicodeString::tempSubStringBetween(int32_t start, int32_t limit) const {
4519     return tempSubString(start, limit - start);
4520 }
4521 
4522 inline char16_t
4523 UnicodeString::doCharAt(int32_t offset) const
4524 {
4525   if((uint32_t)offset &lt; (uint32_t)length()) {
4526     return getArrayStart()[offset];
4527   } else {
4528     return kInvalidUChar;
4529   }
4530 }
4531 
4532 inline char16_t
4533 UnicodeString::charAt(int32_t offset) const
4534 { return doCharAt(offset); }
4535 
4536 inline char16_t
4537 UnicodeString::operator[] (int32_t offset) const
4538 { return doCharAt(offset); }
4539 
4540 inline UBool
4541 UnicodeString::isEmpty() const {
4542   // Arithmetic or logical right shift does not matter: only testing for 0.
4543   return (fUnion.fFields.fLengthAndFlags&gt;&gt;kLengthShift) == 0;
4544 }
4545 
4546 //========================================
4547 // Write implementation methods
4548 //========================================
4549 inline void
4550 UnicodeString::setZeroLength() {
4551   fUnion.fFields.fLengthAndFlags &amp;= kAllStorageFlags;
4552 }
4553 
4554 inline void
4555 UnicodeString::setShortLength(int32_t len) {
4556   // requires 0 &lt;= len &lt;= kMaxShortLength
4557   fUnion.fFields.fLengthAndFlags =
4558     (int16_t)((fUnion.fFields.fLengthAndFlags &amp; kAllStorageFlags) | (len &lt;&lt; kLengthShift));
4559 }
4560 
4561 inline void
4562 UnicodeString::setLength(int32_t len) {
4563   if(len &lt;= kMaxShortLength) {
4564     setShortLength(len);
4565   } else {
4566     fUnion.fFields.fLengthAndFlags |= kLengthIsLarge;
4567     fUnion.fFields.fLength = len;
4568   }
4569 }
4570 
4571 inline void
4572 UnicodeString::setToEmpty() {
4573   fUnion.fFields.fLengthAndFlags = kShortString;
4574 }
4575 
4576 inline void
4577 UnicodeString::setArray(char16_t *array, int32_t len, int32_t capacity) {
4578   setLength(len);
4579   fUnion.fFields.fArray = array;
4580   fUnion.fFields.fCapacity = capacity;
4581 }
4582 
4583 inline UnicodeString&amp;
4584 UnicodeString::operator= (char16_t ch)
4585 { return doReplace(0, length(), &amp;ch, 0, 1); }
4586 
4587 inline UnicodeString&amp;
4588 UnicodeString::operator= (UChar32 ch)
4589 { return replace(0, length(), ch); }
4590 
4591 inline UnicodeString&amp;
4592 UnicodeString::setTo(const UnicodeString&amp; srcText,
4593              int32_t srcStart,
4594              int32_t srcLength)
4595 {
4596   unBogus();
4597   return doReplace(0, length(), srcText, srcStart, srcLength);
4598 }
4599 
4600 inline UnicodeString&amp;
4601 UnicodeString::setTo(const UnicodeString&amp; srcText,
4602              int32_t srcStart)
4603 {
4604   unBogus();
4605   srcText.pinIndex(srcStart);
4606   return doReplace(0, length(), srcText, srcStart, srcText.length() - srcStart);
4607 }
4608 
4609 inline UnicodeString&amp;
4610 UnicodeString::setTo(const UnicodeString&amp; srcText)
4611 {
4612   return copyFrom(srcText);
4613 }
4614 
4615 inline UnicodeString&amp;
4616 UnicodeString::setTo(const char16_t *srcChars,
4617              int32_t srcLength)
4618 {
4619   unBogus();
4620   return doReplace(0, length(), srcChars, 0, srcLength);
4621 }
4622 
4623 inline UnicodeString&amp;
4624 UnicodeString::setTo(char16_t srcChar)
4625 {
4626   unBogus();
4627   return doReplace(0, length(), &amp;srcChar, 0, 1);
4628 }
4629 
4630 inline UnicodeString&amp;
4631 UnicodeString::setTo(UChar32 srcChar)
4632 {
4633   unBogus();
4634   return replace(0, length(), srcChar);
4635 }
4636 
4637 inline UnicodeString&amp;
4638 UnicodeString::append(const UnicodeString&amp; srcText,
4639               int32_t srcStart,
4640               int32_t srcLength)
4641 { return doAppend(srcText, srcStart, srcLength); }
4642 
4643 inline UnicodeString&amp;
4644 UnicodeString::append(const UnicodeString&amp; srcText)
4645 { return doAppend(srcText, 0, srcText.length()); }
4646 
4647 inline UnicodeString&amp;
4648 UnicodeString::append(const char16_t *srcChars,
4649               int32_t srcStart,
4650               int32_t srcLength)
4651 { return doAppend(srcChars, srcStart, srcLength); }
4652 
4653 inline UnicodeString&amp;
4654 UnicodeString::append(ConstChar16Ptr srcChars,
4655               int32_t srcLength)
4656 { return doAppend(srcChars, 0, srcLength); }
4657 
4658 inline UnicodeString&amp;
4659 UnicodeString::append(char16_t srcChar)
4660 { return doAppend(&amp;srcChar, 0, 1); }
4661 
4662 inline UnicodeString&amp;
4663 UnicodeString::operator+= (char16_t ch)
4664 { return doAppend(&amp;ch, 0, 1); }
4665 
4666 inline UnicodeString&amp;
4667 UnicodeString::operator+= (UChar32 ch) {
4668   return append(ch);
4669 }
4670 
4671 inline UnicodeString&amp;
4672 UnicodeString::operator+= (const UnicodeString&amp; srcText)
4673 { return doAppend(srcText, 0, srcText.length()); }
4674 
4675 inline UnicodeString&amp;
4676 UnicodeString::insert(int32_t start,
4677               const UnicodeString&amp; srcText,
4678               int32_t srcStart,
4679               int32_t srcLength)
4680 { return doReplace(start, 0, srcText, srcStart, srcLength); }
4681 
4682 inline UnicodeString&amp;
4683 UnicodeString::insert(int32_t start,
4684               const UnicodeString&amp; srcText)
4685 { return doReplace(start, 0, srcText, 0, srcText.length()); }
4686 
4687 inline UnicodeString&amp;
4688 UnicodeString::insert(int32_t start,
4689               const char16_t *srcChars,
4690               int32_t srcStart,
4691               int32_t srcLength)
4692 { return doReplace(start, 0, srcChars, srcStart, srcLength); }
4693 
4694 inline UnicodeString&amp;
4695 UnicodeString::insert(int32_t start,
4696               ConstChar16Ptr srcChars,
4697               int32_t srcLength)
4698 { return doReplace(start, 0, srcChars, 0, srcLength); }
4699 
4700 inline UnicodeString&amp;
4701 UnicodeString::insert(int32_t start,
4702               char16_t srcChar)
4703 { return doReplace(start, 0, &amp;srcChar, 0, 1); }
4704 
4705 inline UnicodeString&amp;
4706 UnicodeString::insert(int32_t start,
4707               UChar32 srcChar)
4708 { return replace(start, 0, srcChar); }
4709 
4710 
4711 inline UnicodeString&amp;
4712 UnicodeString::remove()
4713 {
4714   // remove() of a bogus string makes the string empty and non-bogus
4715   if(isBogus()) {
4716     setToEmpty();
4717   } else {
4718     setZeroLength();
4719   }
4720   return *this;
4721 }
4722 
4723 inline UnicodeString&amp;
4724 UnicodeString::remove(int32_t start,
4725              int32_t _length)
4726 {
4727     if(start &lt;= 0 &amp;&amp; _length == INT32_MAX) {
4728         // remove(guaranteed everything) of a bogus string makes the string empty and non-bogus
4729         return remove();
4730     }
4731     return doReplace(start, _length, NULL, 0, 0);
4732 }
4733 
4734 inline UnicodeString&amp;
4735 UnicodeString::removeBetween(int32_t start,
4736                 int32_t limit)
4737 { return doReplace(start, limit - start, NULL, 0, 0); }
4738 
4739 inline UnicodeString &amp;
4740 UnicodeString::retainBetween(int32_t start, int32_t limit) {
4741   truncate(limit);
4742   return doReplace(0, start, NULL, 0, 0);
4743 }
4744 
4745 inline UBool
4746 UnicodeString::truncate(int32_t targetLength)
4747 {
4748   if(isBogus() &amp;&amp; targetLength == 0) {
4749     // truncate(0) of a bogus string makes the string empty and non-bogus
4750     unBogus();
4751     return FALSE;
4752   } else if((uint32_t)targetLength &lt; (uint32_t)length()) {
4753     setLength(targetLength);
4754     return TRUE;
4755   } else {
4756     return FALSE;
4757   }
4758 }
4759 
4760 inline UnicodeString&amp;
4761 UnicodeString::reverse()
4762 { return doReverse(0, length()); }
4763 
4764 inline UnicodeString&amp;
4765 UnicodeString::reverse(int32_t start,
4766                int32_t _length)
4767 { return doReverse(start, _length); }
4768 
4769 U_NAMESPACE_END
4770 
4771 #endif
    </pre>
  </body>
</html>