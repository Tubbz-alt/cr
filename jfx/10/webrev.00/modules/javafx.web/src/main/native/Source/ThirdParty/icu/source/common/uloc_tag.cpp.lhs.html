<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_tag.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 2009-2015, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 */
   9 
<a name="1" id="anc1"></a>
  10 #include &quot;unicode/utypes.h&quot;
  11 #include &quot;unicode/ures.h&quot;
<a name="2" id="anc2"></a>
  12 #include &quot;unicode/putil.h&quot;
<a name="3" id="anc3"></a>
  13 #include &quot;unicode/uloc.h&quot;
  14 #include &quot;ustr_imp.h&quot;
<a name="4" id="anc4"></a>
  15 #include &quot;cmemory.h&quot;
  16 #include &quot;cstring.h&quot;
  17 #include &quot;putilimp.h&quot;
  18 #include &quot;uinvchar.h&quot;
  19 #include &quot;ulocimp.h&quot;
  20 #include &quot;uassert.h&quot;
  21 
  22 
  23 /* struct holding a single variant */
  24 typedef struct VariantListEntry {
  25     const char              *variant;
  26     struct VariantListEntry *next;
  27 } VariantListEntry;
  28 
  29 /* struct holding a single attribute value */
<a name="5" id="anc5"></a><span class="line-modified">  30 typedef struct AttributeListEntry {</span>
  31     const char              *attribute;
  32     struct AttributeListEntry *next;
<a name="6" id="anc6"></a><span class="line-modified">  33 } AttributeListEntry;</span>
  34 
  35 /* struct holding a single extension */
<a name="7" id="anc7"></a><span class="line-modified">  36 typedef struct ExtensionListEntry {</span>
  37     const char                  *key;
  38     const char                  *value;
  39     struct ExtensionListEntry   *next;
<a name="8" id="anc8"></a><span class="line-modified">  40 } ExtensionListEntry;</span>
  41 
  42 #define MAXEXTLANG 3
  43 typedef struct ULanguageTag {
  44     char                *buf;   /* holding parsed subtags */
  45     const char          *language;
  46     const char          *extlang[MAXEXTLANG];
  47     const char          *script;
  48     const char          *region;
  49     VariantListEntry    *variants;
  50     ExtensionListEntry  *extensions;
  51     const char          *privateuse;
  52     const char          *grandfathered;
  53 } ULanguageTag;
  54 
  55 #define MINLEN 2
  56 #define SEP &#39;-&#39;
  57 #define PRIVATEUSE &#39;x&#39;
  58 #define LDMLEXT &#39;u&#39;
  59 
  60 #define LOCALE_SEP &#39;_&#39;
  61 #define LOCALE_EXT_SEP &#39;@&#39;
  62 #define LOCALE_KEYWORD_SEP &#39;;&#39;
  63 #define LOCALE_KEY_TYPE_SEP &#39;=&#39;
  64 
  65 #define ISALPHA(c) uprv_isASCIILetter(c)
  66 #define ISNUMERIC(c) ((c)&gt;=&#39;0&#39; &amp;&amp; (c)&lt;=&#39;9&#39;)
  67 
  68 static const char EMPTY[] = &quot;&quot;;
  69 static const char LANG_UND[] = &quot;und&quot;;
  70 static const char PRIVATEUSE_KEY[] = &quot;x&quot;;
  71 static const char _POSIX[] = &quot;_POSIX&quot;;
  72 static const char POSIX_KEY[] = &quot;va&quot;;
  73 static const char POSIX_VALUE[] = &quot;posix&quot;;
  74 static const char LOCALE_ATTRIBUTE_KEY[] = &quot;attribute&quot;;
  75 static const char PRIVUSE_VARIANT_PREFIX[] = &quot;lvariant&quot;;
  76 static const char LOCALE_TYPE_YES[] = &quot;yes&quot;;
  77 
  78 #define LANG_UND_LEN 3
  79 
<a name="9" id="anc9"></a>


















  80 static const char* const GRANDFATHERED[] = {
  81 /*  grandfathered   preferred */
  82     &quot;art-lojban&quot;,   &quot;jbo&quot;,
<a name="10" id="anc10"></a><span class="line-modified">  83     &quot;cel-gaulish&quot;,  &quot;xtg-x-cel-gaulish&quot;,</span>
<span class="line-removed">  84     &quot;en-GB-oed&quot;,    &quot;en-GB-x-oed&quot;,</span>
  85     &quot;i-ami&quot;,        &quot;ami&quot;,
  86     &quot;i-bnn&quot;,        &quot;bnn&quot;,
<a name="11" id="anc11"></a><span class="line-removed">  87     &quot;i-default&quot;,    &quot;en-x-i-default&quot;,</span>
<span class="line-removed">  88     &quot;i-enochian&quot;,   &quot;und-x-i-enochian&quot;,</span>
  89     &quot;i-hak&quot;,        &quot;hak&quot;,
  90     &quot;i-klingon&quot;,    &quot;tlh&quot;,
  91     &quot;i-lux&quot;,        &quot;lb&quot;,
<a name="12" id="anc12"></a><span class="line-removed">  92     &quot;i-mingo&quot;,      &quot;see-x-i-mingo&quot;,</span>
  93     &quot;i-navajo&quot;,     &quot;nv&quot;,
  94     &quot;i-pwn&quot;,        &quot;pwn&quot;,
  95     &quot;i-tao&quot;,        &quot;tao&quot;,
  96     &quot;i-tay&quot;,        &quot;tay&quot;,
  97     &quot;i-tsu&quot;,        &quot;tsu&quot;,
  98     &quot;no-bok&quot;,       &quot;nb&quot;,
  99     &quot;no-nyn&quot;,       &quot;nn&quot;,
 100     &quot;sgn-be-fr&quot;,    &quot;sfb&quot;,
 101     &quot;sgn-be-nl&quot;,    &quot;vgt&quot;,
 102     &quot;sgn-ch-de&quot;,    &quot;sgg&quot;,
 103     &quot;zh-guoyu&quot;,     &quot;cmn&quot;,
 104     &quot;zh-hakka&quot;,     &quot;hak&quot;,
<a name="13" id="anc13"></a><span class="line-removed"> 105     &quot;zh-min&quot;,       &quot;nan-x-zh-min&quot;,</span>
 106     &quot;zh-min-nan&quot;,   &quot;nan&quot;,
 107     &quot;zh-xiang&quot;,     &quot;hsn&quot;,
<a name="14" id="anc14"></a><span class="line-modified"> 108     NULL,           NULL</span>
























































 109 };
 110 
<a name="15" id="anc15"></a>









 111 static const char DEPRECATEDLANGS[][4] = {
 112 /*  deprecated  new */
<a name="16" id="anc16"></a>
 113     &quot;iw&quot;,       &quot;he&quot;,
 114     &quot;ji&quot;,       &quot;yi&quot;,
<a name="17" id="anc17"></a><span class="line-modified"> 115     &quot;in&quot;,       &quot;id&quot;</span>




























































































 116 };
 117 
 118 /*
 119 * -------------------------------------------------
 120 *
 121 * These ultag_ functions may be exposed as APIs later
 122 *
 123 * -------------------------------------------------
 124 */
 125 
 126 static ULanguageTag*
 127 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status);
 128 
 129 static void
 130 ultag_close(ULanguageTag* langtag);
 131 
 132 static const char*
 133 ultag_getLanguage(const ULanguageTag* langtag);
 134 
 135 #if 0
 136 static const char*
 137 ultag_getJDKLanguage(const ULanguageTag* langtag);
 138 #endif
 139 
 140 static const char*
 141 ultag_getExtlang(const ULanguageTag* langtag, int32_t idx);
 142 
 143 static int32_t
 144 ultag_getExtlangSize(const ULanguageTag* langtag);
 145 
 146 static const char*
 147 ultag_getScript(const ULanguageTag* langtag);
 148 
 149 static const char*
 150 ultag_getRegion(const ULanguageTag* langtag);
 151 
 152 static const char*
 153 ultag_getVariant(const ULanguageTag* langtag, int32_t idx);
 154 
 155 static int32_t
 156 ultag_getVariantsSize(const ULanguageTag* langtag);
 157 
 158 static const char*
 159 ultag_getExtensionKey(const ULanguageTag* langtag, int32_t idx);
 160 
 161 static const char*
 162 ultag_getExtensionValue(const ULanguageTag* langtag, int32_t idx);
 163 
 164 static int32_t
 165 ultag_getExtensionsSize(const ULanguageTag* langtag);
 166 
 167 static const char*
 168 ultag_getPrivateUse(const ULanguageTag* langtag);
 169 
 170 #if 0
 171 static const char*
 172 ultag_getGrandfathered(const ULanguageTag* langtag);
 173 #endif
 174 
<a name="18" id="anc18"></a>














 175 /*
 176 * -------------------------------------------------
 177 *
 178 * Language subtag syntax validation functions
 179 *
 180 * -------------------------------------------------
 181 */
 182 
 183 static UBool
 184 _isAlphaString(const char* s, int32_t len) {
 185     int32_t i;
 186     for (i = 0; i &lt; len; i++) {
 187         if (!ISALPHA(*(s + i))) {
 188             return FALSE;
 189         }
 190     }
 191     return TRUE;
 192 }
 193 
 194 static UBool
 195 _isNumericString(const char* s, int32_t len) {
 196     int32_t i;
 197     for (i = 0; i &lt; len; i++) {
 198         if (!ISNUMERIC(*(s + i))) {
 199             return FALSE;
 200         }
 201     }
 202     return TRUE;
 203 }
 204 
 205 static UBool
 206 _isAlphaNumericString(const char* s, int32_t len) {
 207     int32_t i;
 208     for (i = 0; i &lt; len; i++) {
 209         if (!ISALPHA(*(s + i)) &amp;&amp; !ISNUMERIC(*(s + i))) {
 210             return FALSE;
 211         }
 212     }
 213     return TRUE;
 214 }
 215 
 216 static UBool
<a name="19" id="anc19"></a><span class="line-modified"> 217 _isLanguageSubtag(const char* s, int32_t len) {</span>











 218     /*
<a name="20" id="anc20"></a><span class="line-modified"> 219      * language      = 2*3ALPHA            ; shortest ISO 639 code</span>
<span class="line-modified"> 220      *                 [&quot;-&quot; extlang]       ; sometimes followed by</span>
<span class="line-modified"> 221      *                                     ;   extended language subtags</span>
<span class="line-removed"> 222      *               / 4ALPHA              ; or reserved for future use</span>
<span class="line-removed"> 223      *               / 5*8ALPHA            ; or registered language subtag</span>
 224      */
 225     if (len &lt; 0) {
 226         len = (int32_t)uprv_strlen(s);
 227     }
 228     if (len &gt;= 2 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaString(s, len)) {
 229         return TRUE;
 230     }
 231     return FALSE;
 232 }
 233 
 234 static UBool
 235 _isExtlangSubtag(const char* s, int32_t len) {
 236     /*
 237      * extlang       = 3ALPHA              ; selected ISO 639 codes
 238      *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 239      */
 240     if (len &lt; 0) {
 241         len = (int32_t)uprv_strlen(s);
 242     }
 243     if (len == 3 &amp;&amp; _isAlphaString(s, len)) {
 244         return TRUE;
 245     }
 246     return FALSE;
 247 }
 248 
<a name="21" id="anc21"></a><span class="line-modified"> 249 static UBool</span>
<span class="line-modified"> 250 _isScriptSubtag(const char* s, int32_t len) {</span>
 251     /*
 252      * script        = 4ALPHA              ; ISO 15924 code
 253      */
 254     if (len &lt; 0) {
 255         len = (int32_t)uprv_strlen(s);
 256     }
 257     if (len == 4 &amp;&amp; _isAlphaString(s, len)) {
 258         return TRUE;
 259     }
 260     return FALSE;
 261 }
 262 
<a name="22" id="anc22"></a><span class="line-modified"> 263 static UBool</span>
<span class="line-modified"> 264 _isRegionSubtag(const char* s, int32_t len) {</span>
 265     /*
 266      * region        = 2ALPHA              ; ISO 3166-1 code
 267      *               / 3DIGIT              ; UN M.49 code
 268      */
 269     if (len &lt; 0) {
 270         len = (int32_t)uprv_strlen(s);
 271     }
 272     if (len == 2 &amp;&amp; _isAlphaString(s, len)) {
 273         return TRUE;
 274     }
 275     if (len == 3 &amp;&amp; _isNumericString(s, len)) {
 276         return TRUE;
 277     }
 278     return FALSE;
 279 }
 280 
 281 static UBool
 282 _isVariantSubtag(const char* s, int32_t len) {
 283     /*
 284      * variant       = 5*8alphanum         ; registered variants
 285      *               / (DIGIT 3alphanum)
 286      */
 287     if (len &lt; 0) {
 288         len = (int32_t)uprv_strlen(s);
 289     }
<a name="23" id="anc23"></a><span class="line-modified"> 290     if (len &gt;= 5 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaNumericString(s, len)) {</span>
 291         return TRUE;
 292     }
 293     if (len == 4 &amp;&amp; ISNUMERIC(*s) &amp;&amp; _isAlphaNumericString(s + 1, 3)) {
 294         return TRUE;
 295     }
 296     return FALSE;
 297 }
 298 
<a name="24" id="anc24"></a>


































 299 static UBool
 300 _isPrivateuseVariantSubtag(const char* s, int32_t len) {
 301     /*
 302      * variant       = 1*8alphanum         ; registered variants
 303      *               / (DIGIT 3alphanum)
 304      */
<a name="25" id="anc25"></a><span class="line-modified"> 305     if (len &lt; 0) {</span>
<span class="line-removed"> 306         len = (int32_t)uprv_strlen(s);</span>
<span class="line-removed"> 307     }</span>
<span class="line-removed"> 308     if (len &gt;= 1 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaNumericString(s, len)) {</span>
<span class="line-removed"> 309         return TRUE;</span>
<span class="line-removed"> 310     }</span>
<span class="line-removed"> 311     return FALSE;</span>
 312 }
 313 
 314 static UBool
 315 _isExtensionSingleton(const char* s, int32_t len) {
 316     /*
 317      * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
<a name="26" id="anc26"></a>





 318      */
 319     if (len &lt; 0) {
 320         len = (int32_t)uprv_strlen(s);
 321     }
<a name="27" id="anc27"></a><span class="line-modified"> 322     if (len == 1 &amp;&amp; ISALPHA(*s) &amp;&amp; (uprv_tolower(*s) != PRIVATEUSE)) {</span>
 323         return TRUE;
 324     }
 325     return FALSE;
 326 }
 327 
 328 static UBool
 329 _isExtensionSubtag(const char* s, int32_t len) {
 330     /*
 331      * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
 332      */
<a name="28" id="anc28"></a>






































 333     if (len &lt; 0) {
 334         len = (int32_t)uprv_strlen(s);
 335     }
<a name="29" id="anc29"></a><span class="line-modified"> 336     if (len &gt;= 2 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaNumericString(s, len)) {</span>
 337         return TRUE;
 338     }
 339     return FALSE;
 340 }
 341 
<a name="30" id="anc30"></a><span class="line-modified"> 342 static UBool</span>
<span class="line-modified"> 343 _isExtensionSubtags(const char* s, int32_t len) {</span>
<span class="line-modified"> 344     const char *p = s;</span>
<span class="line-modified"> 345     const char *pSubtag = NULL;</span>
<span class="line-modified"> 346 </span>
<span class="line-modified"> 347     if (len &lt; 0) {</span>
<span class="line-modified"> 348         len = (int32_t)uprv_strlen(s);</span>
<span class="line-removed"> 349     }</span>
 350 
<a name="31" id="anc31"></a><span class="line-modified"> 351     while ((p - s) &lt; len) {</span>
<span class="line-modified"> 352         if (*p == SEP) {</span>
<span class="line-modified"> 353             if (pSubtag == NULL) {</span>
<span class="line-modified"> 354                 return FALSE;</span>
<span class="line-modified"> 355             }</span>
<span class="line-modified"> 356             if (!_isExtensionSubtag(pSubtag, (int32_t)(p - pSubtag))) {</span>
<span class="line-removed"> 357                 return FALSE;</span>
<span class="line-removed"> 358             }</span>
<span class="line-removed"> 359             pSubtag = NULL;</span>
<span class="line-removed"> 360         } else if (pSubtag == NULL) {</span>
<span class="line-removed"> 361             pSubtag = p;</span>
<span class="line-removed"> 362         }</span>
<span class="line-removed"> 363         p++;</span>
<span class="line-removed"> 364     }</span>
<span class="line-removed"> 365     if (pSubtag == NULL) {</span>
<span class="line-removed"> 366         return FALSE;</span>
<span class="line-removed"> 367     }</span>
<span class="line-removed"> 368     return _isExtensionSubtag(pSubtag, (int32_t)(p - pSubtag));</span>
 369 }
 370 
 371 static UBool
<a name="32" id="anc32"></a><span class="line-modified"> 372 _isPrivateuseValueSubtag(const char* s, int32_t len) {</span>

 373     /*
<a name="33" id="anc33"></a><span class="line-modified"> 374      * privateuse    = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))</span>
 375      */
 376     if (len &lt; 0) {
 377         len = (int32_t)uprv_strlen(s);
 378     }
<a name="34" id="anc34"></a><span class="line-modified"> 379     if (len &gt;= 1 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaNumericString(s, len)) {</span>
 380         return TRUE;
 381     }
 382     return FALSE;
 383 }
 384 
 385 static UBool
<a name="35" id="anc35"></a><span class="line-modified"> 386 _isPrivateuseValueSubtags(const char* s, int32_t len) {</span>
<span class="line-modified"> 387     const char *p = s;</span>
<span class="line-modified"> 388     const char *pSubtag = NULL;</span>
<span class="line-modified"> 389 </span>
<span class="line-modified"> 390     if (len &lt; 0) {</span>
<span class="line-modified"> 391         len = (int32_t)uprv_strlen(s);</span>
<span class="line-modified"> 392     }</span>
 393 
<a name="36" id="anc36"></a><span class="line-modified"> 394     while ((p - s) &lt; len) {</span>
<span class="line-modified"> 395         if (*p == SEP) {</span>
<span class="line-modified"> 396             if (pSubtag == NULL) {</span>
<span class="line-modified"> 397                 return FALSE;</span>




















 398             }
<a name="37" id="anc37"></a><span class="line-modified"> 399             if (!_isPrivateuseValueSubtag(pSubtag, (int32_t)(p - pSubtag))) {</span>
<span class="line-modified"> 400                 return FALSE;</span>





















 401             }
<a name="38" id="anc38"></a><span class="line-modified"> 402             pSubtag = NULL;</span>
<span class="line-modified"> 403         } else if (pSubtag == NULL) {</span>
<span class="line-modified"> 404             pSubtag = p;</span>
<span class="line-modified"> 405         }</span>
<span class="line-modified"> 406         p++;</span>
<span class="line-modified"> 407     }</span>
<span class="line-modified"> 408     if (pSubtag == NULL) {</span>
<span class="line-modified"> 409         return FALSE;</span>








 410     }
<a name="39" id="anc39"></a><span class="line-modified"> 411     return _isPrivateuseValueSubtag(pSubtag, (int32_t)(p - pSubtag));</span>
 412 }
 413 
<a name="40" id="anc40"></a><span class="line-modified"> 414 U_CFUNC UBool</span>
<span class="line-modified"> 415 ultag_isUnicodeLocaleKey(const char* s, int32_t len) {</span>
<span class="line-modified"> 416     if (len &lt; 0) {</span>
<span class="line-modified"> 417         len = (int32_t)uprv_strlen(s);</span>
<span class="line-modified"> 418     }</span>
<span class="line-modified"> 419     if (len == 2 &amp;&amp; _isAlphaNumericString(s, len)) {</span>
<span class="line-modified"> 420         return TRUE;</span>




























 421     }
 422     return FALSE;
 423 }
 424 
<a name="41" id="anc41"></a><span class="line-modified"> 425 U_CFUNC UBool</span>
<span class="line-modified"> 426 ultag_isUnicodeLocaleType(const char*s, int32_t len) {</span>


 427     const char* p;
<a name="42" id="anc42"></a>
 428     int32_t subtagLen = 0;
 429 
 430     if (len &lt; 0) {
 431         len = (int32_t)uprv_strlen(s);
 432     }
 433 
 434     for (p = s; len &gt; 0; p++, len--) {
 435         if (*p == SEP) {
<a name="43" id="anc43"></a><span class="line-modified"> 436             if (subtagLen &lt; 3) {</span>
 437                 return FALSE;
 438             }
 439             subtagLen = 0;
<a name="44" id="anc44"></a><span class="line-modified"> 440         } else if (ISALPHA(*p) || ISNUMERIC(*p)) {</span>
<span class="line-removed"> 441             subtagLen++;</span>
<span class="line-removed"> 442             if (subtagLen &gt; 8) {</span>
<span class="line-removed"> 443                 return FALSE;</span>
<span class="line-removed"> 444             }</span>
 445         } else {
<a name="45" id="anc45"></a><span class="line-modified"> 446             return FALSE;</span>
 447         }
 448     }
 449 
<a name="46" id="anc46"></a><span class="line-modified"> 450     return (subtagLen &gt;= 3);</span>














 451 }
<a name="47" id="anc47"></a>

 452 /*
 453 * -------------------------------------------------
 454 *
 455 * Helper functions
 456 *
 457 * -------------------------------------------------
 458 */
 459 
 460 static UBool
 461 _addVariantToList(VariantListEntry **first, VariantListEntry *var) {
 462     UBool bAdded = TRUE;
 463 
 464     if (*first == NULL) {
 465         var-&gt;next = NULL;
 466         *first = var;
 467     } else {
 468         VariantListEntry *prev, *cur;
 469         int32_t cmp;
 470 
 471         /* variants order should be preserved */
 472         prev = NULL;
 473         cur = *first;
 474         while (TRUE) {
 475             if (cur == NULL) {
 476                 prev-&gt;next = var;
 477                 var-&gt;next = NULL;
 478                 break;
 479             }
 480 
 481             /* Checking for duplicate variant */
 482             cmp = uprv_compareInvCharsAsAscii(var-&gt;variant, cur-&gt;variant);
 483             if (cmp == 0) {
 484                 /* duplicated variant */
 485                 bAdded = FALSE;
 486                 break;
 487             }
 488             prev = cur;
 489             cur = cur-&gt;next;
 490         }
 491     }
 492 
 493     return bAdded;
 494 }
 495 
 496 static UBool
 497 _addAttributeToList(AttributeListEntry **first, AttributeListEntry *attr) {
 498     UBool bAdded = TRUE;
 499 
 500     if (*first == NULL) {
 501         attr-&gt;next = NULL;
 502         *first = attr;
 503     } else {
 504         AttributeListEntry *prev, *cur;
 505         int32_t cmp;
 506 
 507         /* reorder variants in alphabetical order */
 508         prev = NULL;
 509         cur = *first;
 510         while (TRUE) {
 511             if (cur == NULL) {
 512                 prev-&gt;next = attr;
 513                 attr-&gt;next = NULL;
 514                 break;
 515             }
 516             cmp = uprv_compareInvCharsAsAscii(attr-&gt;attribute, cur-&gt;attribute);
 517             if (cmp &lt; 0) {
 518                 if (prev == NULL) {
 519                     *first = attr;
 520                 } else {
 521                     prev-&gt;next = attr;
 522                 }
 523                 attr-&gt;next = cur;
 524                 break;
 525             }
 526             if (cmp == 0) {
 527                 /* duplicated variant */
 528                 bAdded = FALSE;
 529                 break;
 530             }
 531             prev = cur;
 532             cur = cur-&gt;next;
 533         }
 534     }
 535 
 536     return bAdded;
 537 }
 538 
 539 
 540 static UBool
 541 _addExtensionToList(ExtensionListEntry **first, ExtensionListEntry *ext, UBool localeToBCP) {
 542     UBool bAdded = TRUE;
 543 
 544     if (*first == NULL) {
 545         ext-&gt;next = NULL;
 546         *first = ext;
 547     } else {
 548         ExtensionListEntry *prev, *cur;
 549         int32_t cmp;
 550 
 551         /* reorder variants in alphabetical order */
 552         prev = NULL;
 553         cur = *first;
 554         while (TRUE) {
 555             if (cur == NULL) {
 556                 prev-&gt;next = ext;
 557                 ext-&gt;next = NULL;
 558                 break;
 559             }
 560             if (localeToBCP) {
 561                 /* special handling for locale to bcp conversion */
 562                 int32_t len, curlen;
 563 
 564                 len = (int32_t)uprv_strlen(ext-&gt;key);
 565                 curlen = (int32_t)uprv_strlen(cur-&gt;key);
 566 
 567                 if (len == 1 &amp;&amp; curlen == 1) {
 568                     if (*(ext-&gt;key) == *(cur-&gt;key)) {
 569                         cmp = 0;
 570                     } else if (*(ext-&gt;key) == PRIVATEUSE) {
 571                         cmp = 1;
 572                     } else if (*(cur-&gt;key) == PRIVATEUSE) {
 573                         cmp = -1;
 574                     } else {
 575                         cmp = *(ext-&gt;key) - *(cur-&gt;key);
 576                     }
 577                 } else if (len == 1) {
 578                     cmp = *(ext-&gt;key) - LDMLEXT;
 579                 } else if (curlen == 1) {
 580                     cmp = LDMLEXT - *(cur-&gt;key);
 581                 } else {
 582                     cmp = uprv_compareInvCharsAsAscii(ext-&gt;key, cur-&gt;key);
 583                     /* Both are u extension keys - we need special handling for &#39;attribute&#39; */
 584                     if (cmp != 0) {
 585                         if (uprv_strcmp(cur-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
 586                             cmp = 1;
 587                         } else if (uprv_strcmp(ext-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
 588                             cmp = -1;
 589                         }
 590                     }
 591                 }
 592             } else {
 593                 cmp = uprv_compareInvCharsAsAscii(ext-&gt;key, cur-&gt;key);
 594             }
 595             if (cmp &lt; 0) {
 596                 if (prev == NULL) {
 597                     *first = ext;
 598                 } else {
 599                     prev-&gt;next = ext;
 600                 }
 601                 ext-&gt;next = cur;
 602                 break;
 603             }
 604             if (cmp == 0) {
 605                 /* duplicated extension key */
 606                 bAdded = FALSE;
 607                 break;
 608             }
 609             prev = cur;
 610             cur = cur-&gt;next;
 611         }
 612     }
 613 
 614     return bAdded;
 615 }
 616 
 617 static void
 618 _initializeULanguageTag(ULanguageTag* langtag) {
 619     int32_t i;
 620 
 621     langtag-&gt;buf = NULL;
 622 
 623     langtag-&gt;language = EMPTY;
 624     for (i = 0; i &lt; MAXEXTLANG; i++) {
 625         langtag-&gt;extlang[i] = NULL;
 626     }
 627 
 628     langtag-&gt;script = EMPTY;
 629     langtag-&gt;region = EMPTY;
 630 
 631     langtag-&gt;variants = NULL;
 632     langtag-&gt;extensions = NULL;
 633 
 634     langtag-&gt;grandfathered = EMPTY;
 635     langtag-&gt;privateuse = EMPTY;
 636 }
 637 
<a name="48" id="anc48"></a><span class="line-modified"> 638 static int32_t</span>
<span class="line-modified"> 639 _appendLanguageToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UErrorCode* status) {</span>
 640     char buf[ULOC_LANG_CAPACITY];
 641     UErrorCode tmpStatus = U_ZERO_ERROR;
 642     int32_t len, i;
<a name="49" id="anc49"></a><span class="line-removed"> 643     int32_t reslen = 0;</span>
 644 
 645     if (U_FAILURE(*status)) {
<a name="50" id="anc50"></a><span class="line-modified"> 646         return 0;</span>
 647     }
 648 
 649     len = uloc_getLanguage(localeID, buf, sizeof(buf), &amp;tmpStatus);
 650     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
 651         if (strict) {
 652             *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="51" id="anc51"></a><span class="line-modified"> 653             return 0;</span>
 654         }
 655         len = 0;
 656     }
 657 
 658     /* Note: returned language code is in lower case letters */
 659 
 660     if (len == 0) {
<a name="52" id="anc52"></a><span class="line-modified"> 661         if (reslen &lt; capacity) {</span>
<span class="line-modified"> 662             uprv_memcpy(appendAt + reslen, LANG_UND, uprv_min(LANG_UND_LEN, capacity - reslen));</span>
<span class="line-removed"> 663         }</span>
<span class="line-removed"> 664         reslen += LANG_UND_LEN;</span>
<span class="line-removed"> 665     } else if (!_isLanguageSubtag(buf, len)) {</span>
 666             /* invalid language code */
 667         if (strict) {
 668             *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="53" id="anc53"></a><span class="line-modified"> 669             return 0;</span>
<span class="line-removed"> 670         }</span>
<span class="line-removed"> 671         if (reslen &lt; capacity) {</span>
<span class="line-removed"> 672             uprv_memcpy(appendAt + reslen, LANG_UND, uprv_min(LANG_UND_LEN, capacity - reslen));</span>
 673         }
<a name="54" id="anc54"></a><span class="line-modified"> 674         reslen += LANG_UND_LEN;</span>
 675     } else {
 676         /* resolve deprecated */
 677         for (i = 0; i &lt; UPRV_LENGTHOF(DEPRECATEDLANGS); i += 2) {
<a name="55" id="anc55"></a>




 678             if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDLANGS[i]) == 0) {
 679                 uprv_strcpy(buf, DEPRECATEDLANGS[i + 1]);
 680                 len = (int32_t)uprv_strlen(buf);
 681                 break;
 682             }
 683         }
<a name="56" id="anc56"></a><span class="line-modified"> 684         if (reslen &lt; capacity) {</span>
<span class="line-removed"> 685             uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));</span>
<span class="line-removed"> 686         }</span>
<span class="line-removed"> 687         reslen += len;</span>
 688     }
<a name="57" id="anc57"></a><span class="line-removed"> 689     u_terminateChars(appendAt, capacity, reslen, status);</span>
<span class="line-removed"> 690     return reslen;</span>
 691 }
 692 
<a name="58" id="anc58"></a><span class="line-modified"> 693 static int32_t</span>
<span class="line-modified"> 694 _appendScriptToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UErrorCode* status) {</span>
 695     char buf[ULOC_SCRIPT_CAPACITY];
 696     UErrorCode tmpStatus = U_ZERO_ERROR;
 697     int32_t len;
<a name="59" id="anc59"></a><span class="line-removed"> 698     int32_t reslen = 0;</span>
 699 
 700     if (U_FAILURE(*status)) {
<a name="60" id="anc60"></a><span class="line-modified"> 701         return 0;</span>
 702     }
 703 
 704     len = uloc_getScript(localeID, buf, sizeof(buf), &amp;tmpStatus);
 705     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
 706         if (strict) {
 707             *status = U_ILLEGAL_ARGUMENT_ERROR;
 708         }
<a name="61" id="anc61"></a><span class="line-modified"> 709         return 0;</span>
 710     }
 711 
 712     if (len &gt; 0) {
<a name="62" id="anc62"></a><span class="line-modified"> 713         if (!_isScriptSubtag(buf, len)) {</span>
 714             /* invalid script code */
 715             if (strict) {
 716                 *status = U_ILLEGAL_ARGUMENT_ERROR;
 717             }
<a name="63" id="anc63"></a><span class="line-modified"> 718             return 0;</span>
 719         } else {
<a name="64" id="anc64"></a><span class="line-modified"> 720             if (reslen &lt; capacity) {</span>
<span class="line-modified"> 721                 *(appendAt + reslen) = SEP;</span>
<span class="line-removed"> 722             }</span>
<span class="line-removed"> 723             reslen++;</span>
<span class="line-removed"> 724 </span>
<span class="line-removed"> 725             if (reslen &lt; capacity) {</span>
<span class="line-removed"> 726                 uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));</span>
<span class="line-removed"> 727             }</span>
<span class="line-removed"> 728             reslen += len;</span>
 729         }
 730     }
<a name="65" id="anc65"></a><span class="line-removed"> 731     u_terminateChars(appendAt, capacity, reslen, status);</span>
<span class="line-removed"> 732     return reslen;</span>
 733 }
 734 
<a name="66" id="anc66"></a><span class="line-modified"> 735 static int32_t</span>
<span class="line-modified"> 736 _appendRegionToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UErrorCode* status) {</span>
 737     char buf[ULOC_COUNTRY_CAPACITY];
 738     UErrorCode tmpStatus = U_ZERO_ERROR;
 739     int32_t len;
<a name="67" id="anc67"></a><span class="line-removed"> 740     int32_t reslen = 0;</span>
 741 
 742     if (U_FAILURE(*status)) {
<a name="68" id="anc68"></a><span class="line-modified"> 743         return 0;</span>
 744     }
 745 
 746     len = uloc_getCountry(localeID, buf, sizeof(buf), &amp;tmpStatus);
 747     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
 748         if (strict) {
 749             *status = U_ILLEGAL_ARGUMENT_ERROR;
 750         }
<a name="69" id="anc69"></a><span class="line-modified"> 751         return 0;</span>
 752     }
 753 
 754     if (len &gt; 0) {
<a name="70" id="anc70"></a><span class="line-modified"> 755         if (!_isRegionSubtag(buf, len)) {</span>
 756             /* invalid region code */
 757             if (strict) {
 758                 *status = U_ILLEGAL_ARGUMENT_ERROR;
 759             }
<a name="71" id="anc71"></a><span class="line-modified"> 760             return 0;</span>
 761         } else {
<a name="72" id="anc72"></a><span class="line-modified"> 762             if (reslen &lt; capacity) {</span>
<span class="line-modified"> 763                 *(appendAt + reslen) = SEP;</span>
<span class="line-modified"> 764             }</span>
<span class="line-modified"> 765             reslen++;</span>
<span class="line-modified"> 766 </span>
<span class="line-modified"> 767             if (reslen &lt; capacity) {</span>
<span class="line-modified"> 768                 uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));</span>

 769             }
<a name="73" id="anc73"></a><span class="line-modified"> 770             reslen += len;</span>
 771         }
 772     }
<a name="74" id="anc74"></a><span class="line-removed"> 773     u_terminateChars(appendAt, capacity, reslen, status);</span>
<span class="line-removed"> 774     return reslen;</span>
 775 }
 776 
<a name="75" id="anc75"></a><span class="line-modified"> 777 static int32_t</span>
<span class="line-modified"> 778 _appendVariantsToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UBool *hadPosix, UErrorCode* status) {</span>
 779     char buf[ULOC_FULLNAME_CAPACITY];
 780     UErrorCode tmpStatus = U_ZERO_ERROR;
 781     int32_t len, i;
<a name="76" id="anc76"></a><span class="line-removed"> 782     int32_t reslen = 0;</span>
 783 
 784     if (U_FAILURE(*status)) {
<a name="77" id="anc77"></a><span class="line-modified"> 785         return 0;</span>
 786     }
 787 
 788     len = uloc_getVariant(localeID, buf, sizeof(buf), &amp;tmpStatus);
 789     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
 790         if (strict) {
 791             *status = U_ILLEGAL_ARGUMENT_ERROR;
 792         }
<a name="78" id="anc78"></a><span class="line-modified"> 793         return 0;</span>
 794     }
 795 
 796     if (len &gt; 0) {
 797         char *p, *pVar;
 798         UBool bNext = TRUE;
 799         VariantListEntry *var;
 800         VariantListEntry *varFirst = NULL;
 801 
 802         pVar = NULL;
 803         p = buf;
 804         while (bNext) {
 805             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
 806                 if (*p == 0) {
 807                     bNext = FALSE;
 808                 } else {
 809                     *p = 0; /* terminate */
 810                 }
 811                 if (pVar == NULL) {
 812                     if (strict) {
 813                         *status = U_ILLEGAL_ARGUMENT_ERROR;
 814                         break;
 815                     }
 816                     /* ignore empty variant */
 817                 } else {
 818                     /* ICU uses upper case letters for variants, but
 819                        the canonical format is lowercase in BCP47 */
 820                     for (i = 0; *(pVar + i) != 0; i++) {
 821                         *(pVar + i) = uprv_tolower(*(pVar + i));
 822                     }
 823 
 824                     /* validate */
 825                     if (_isVariantSubtag(pVar, -1)) {
 826                         if (uprv_strcmp(pVar,POSIX_VALUE) || len != (int32_t)uprv_strlen(POSIX_VALUE)) {
 827                             /* emit the variant to the list */
 828                             var = (VariantListEntry*)uprv_malloc(sizeof(VariantListEntry));
 829                             if (var == NULL) {
 830                                 *status = U_MEMORY_ALLOCATION_ERROR;
 831                                 break;
 832                             }
 833                             var-&gt;variant = pVar;
 834                             if (!_addVariantToList(&amp;varFirst, var)) {
 835                                 /* duplicated variant */
 836                                 uprv_free(var);
 837                                 if (strict) {
 838                                     *status = U_ILLEGAL_ARGUMENT_ERROR;
 839                                     break;
 840                                 }
 841                             }
 842                         } else {
 843                             /* Special handling for POSIX variant, need to remember that we had it and then */
 844                             /* treat it like an extension later. */
 845                             *hadPosix = TRUE;
 846                         }
 847                     } else if (strict) {
 848                         *status = U_ILLEGAL_ARGUMENT_ERROR;
 849                         break;
 850                     } else if (_isPrivateuseValueSubtag(pVar, -1)) {
 851                         /* Handle private use subtags separately */
 852                         break;
 853                     }
 854                 }
 855                 /* reset variant starting position */
 856                 pVar = NULL;
 857             } else if (pVar == NULL) {
 858                 pVar = p;
 859             }
 860             p++;
 861         }
 862 
 863         if (U_SUCCESS(*status)) {
 864             if (varFirst != NULL) {
 865                 int32_t varLen;
 866 
 867                 /* write out validated/normalized variants to the target */
 868                 var = varFirst;
 869                 while (var != NULL) {
<a name="79" id="anc79"></a><span class="line-modified"> 870                     if (reslen &lt; capacity) {</span>
<span class="line-removed"> 871                         *(appendAt + reslen) = SEP;</span>
<span class="line-removed"> 872                     }</span>
<span class="line-removed"> 873                     reslen++;</span>
 874                     varLen = (int32_t)uprv_strlen(var-&gt;variant);
<a name="80" id="anc80"></a><span class="line-modified"> 875                     if (reslen &lt; capacity) {</span>
<span class="line-removed"> 876                         uprv_memcpy(appendAt + reslen, var-&gt;variant, uprv_min(varLen, capacity - reslen));</span>
<span class="line-removed"> 877                     }</span>
<span class="line-removed"> 878                     reslen += varLen;</span>
 879                     var = var-&gt;next;
 880                 }
 881             }
 882         }
 883 
 884         /* clean up */
 885         var = varFirst;
 886         while (var != NULL) {
 887             VariantListEntry *tmpVar = var-&gt;next;
 888             uprv_free(var);
 889             var = tmpVar;
 890         }
 891 
 892         if (U_FAILURE(*status)) {
<a name="81" id="anc81"></a><span class="line-modified"> 893             return 0;</span>
 894         }
 895     }
<a name="82" id="anc82"></a><span class="line-removed"> 896 </span>
<span class="line-removed"> 897     u_terminateChars(appendAt, capacity, reslen, status);</span>
<span class="line-removed"> 898     return reslen;</span>
 899 }
 900 
<a name="83" id="anc83"></a><span class="line-modified"> 901 static int32_t</span>
<span class="line-modified"> 902 _appendKeywordsToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UBool hadPosix, UErrorCode* status) {</span>
<span class="line-removed"> 903     char buf[ULOC_KEYWORD_AND_VALUES_CAPACITY];</span>
 904     char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY] = { 0 };
 905     int32_t attrBufLength = 0;
<a name="84" id="anc84"></a><span class="line-removed"> 906     UEnumeration *keywordEnum = NULL;</span>
<span class="line-removed"> 907     int32_t reslen = 0;</span>
 908 
<a name="85" id="anc85"></a><span class="line-modified"> 909     keywordEnum = uloc_openKeywords(localeID, status);</span>




 910     if (U_FAILURE(*status) &amp;&amp; !hadPosix) {
<a name="86" id="anc86"></a><span class="line-modified"> 911         uenum_close(keywordEnum);</span>
<span class="line-removed"> 912         return 0;</span>
 913     }
<a name="87" id="anc87"></a><span class="line-modified"> 914     if (keywordEnum != NULL || hadPosix) {</span>
 915         /* reorder extensions */
 916         int32_t len;
 917         const char *key;
 918         ExtensionListEntry *firstExt = NULL;
 919         ExtensionListEntry *ext;
 920         AttributeListEntry *firstAttr = NULL;
 921         AttributeListEntry *attr;
<a name="88" id="anc88"></a><span class="line-modified"> 922         char *attrValue;</span>
<span class="line-removed"> 923         char extBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];</span>
<span class="line-removed"> 924         char *pExtBuf = extBuf;</span>
<span class="line-removed"> 925         int32_t extBufCapacity = sizeof(extBuf);</span>
 926         const char *bcpKey=nullptr, *bcpValue=nullptr;
 927         UErrorCode tmpStatus = U_ZERO_ERROR;
 928         int32_t keylen;
 929         UBool isBcpUExt;
 930 
 931         while (TRUE) {
<a name="89" id="anc89"></a><span class="line-modified"> 932             key = uenum_next(keywordEnum, NULL, status);</span>

 933             if (key == NULL) {
 934                 break;
 935             }
<a name="90" id="anc90"></a><span class="line-modified"> 936             len = uloc_getKeywordValue(localeID, key, buf, sizeof(buf), &amp;tmpStatus);</span>
<span class="line-modified"> 937             /* buf must be null-terminated */</span>
<span class="line-modified"> 938             if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {</span>



























 939                 if (strict) {
 940                     *status = U_ILLEGAL_ARGUMENT_ERROR;
 941                     break;
 942                 }
 943                 /* ignore this keyword */
 944                 tmpStatus = U_ZERO_ERROR;
 945                 continue;
 946             }
 947 
<a name="91" id="anc91"></a>




 948             keylen = (int32_t)uprv_strlen(key);
 949             isBcpUExt = (keylen &gt; 1);
 950 
 951             /* special keyword used for representing Unicode locale attributes */
 952             if (uprv_strcmp(key, LOCALE_ATTRIBUTE_KEY) == 0) {
 953                 if (len &gt; 0) {
 954                     int32_t i = 0;
 955                     while (TRUE) {
 956                         attrBufLength = 0;
 957                         for (; i &lt; len; i++) {
 958                             if (buf[i] != &#39;-&#39;) {
 959                                 attrBuf[attrBufLength++] = buf[i];
 960                             } else {
 961                                 i++;
 962                                 break;
 963                             }
 964                         }
 965                         if (attrBufLength &gt; 0) {
 966                             attrBuf[attrBufLength] = 0;
 967 
 968                         } else if (i &gt;= len){
 969                             break;
 970                         }
 971 
 972                         /* create AttributeListEntry */
<a name="92" id="anc92"></a><span class="line-modified"> 973                         attr = (AttributeListEntry*)uprv_malloc(sizeof(AttributeListEntry));</span>
 974                         if (attr == NULL) {
 975                             *status = U_MEMORY_ALLOCATION_ERROR;
 976                             break;
 977                         }
<a name="93" id="anc93"></a><span class="line-modified"> 978                         attrValue = (char*)uprv_malloc(attrBufLength + 1);</span>

 979                         if (attrValue == NULL) {
 980                             *status = U_MEMORY_ALLOCATION_ERROR;
 981                             break;
 982                         }
<a name="94" id="anc94"></a><span class="line-modified"> 983                         uprv_strcpy(attrValue, attrBuf);</span>
<span class="line-modified"> 984                         attr-&gt;attribute = attrValue;</span>


 985 
 986                         if (!_addAttributeToList(&amp;firstAttr, attr)) {
<a name="95" id="anc95"></a><span class="line-removed"> 987                             uprv_free(attr);</span>
<span class="line-removed"> 988                             uprv_free(attrValue);</span>
 989                             if (strict) {
 990                                 *status = U_ILLEGAL_ARGUMENT_ERROR;
 991                                 break;
 992                             }
 993                         }
 994                     }
 995                     /* for a place holder ExtensionListEntry */
 996                     bcpKey = LOCALE_ATTRIBUTE_KEY;
 997                     bcpValue = NULL;
 998                 }
 999             } else if (isBcpUExt) {
1000                 bcpKey = uloc_toUnicodeLocaleKey(key);
1001                 if (bcpKey == NULL) {
1002                     if (strict) {
1003                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1004                         break;
1005                     }
1006                     continue;
1007                 }
1008 
1009                 /* we&#39;ve checked buf is null-terminated above */
<a name="96" id="anc96"></a><span class="line-modified">1010                 bcpValue = uloc_toUnicodeLocaleType(key, buf);</span>
1011                 if (bcpValue == NULL) {
1012                     if (strict) {
1013                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1014                         break;
1015                     }
1016                     continue;
1017                 }
<a name="97" id="anc97"></a><span class="line-modified">1018                 if (bcpValue == buf) {</span>
1019                     /*
1020                     When uloc_toUnicodeLocaleType(key, buf) returns the
1021                     input value as is, the value is well-formed, but has
1022                     no known mapping. This implementation normalizes the
<a name="98" id="anc98"></a><span class="line-modified">1023                     the value to lower case</span>
1024                     */
<a name="99" id="anc99"></a>




1025                     int32_t bcpValueLen = static_cast&lt;int32_t&gt;(uprv_strlen(bcpValue));
<a name="100" id="anc100"></a><span class="line-modified">1026                     if (bcpValueLen &lt; extBufCapacity) {</span>
<span class="line-modified">1027                         uprv_strcpy(pExtBuf, bcpValue);</span>
<span class="line-modified">1028                         T_CString_toLowerCase(pExtBuf);</span>







1029 
<a name="101" id="anc101"></a><span class="line-modified">1030                         bcpValue = pExtBuf;</span>

1031 
<a name="102" id="anc102"></a><span class="line-modified">1032                         pExtBuf += (bcpValueLen + 1);</span>
<span class="line-modified">1033                         extBufCapacity -= (bcpValueLen + 1);</span>
<span class="line-modified">1034                     } else {</span>
<span class="line-modified">1035                         if (strict) {</span>
<span class="line-removed">1036                             *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-removed">1037                             break;</span>
<span class="line-removed">1038                         }</span>
<span class="line-removed">1039                         continue;</span>
1040                     }
<a name="103" id="anc103"></a>

1041                 }
1042             } else {
1043                 if (*key == PRIVATEUSE) {
<a name="104" id="anc104"></a><span class="line-modified">1044                     if (!_isPrivateuseValueSubtags(buf, len)) {</span>
1045                         if (strict) {
1046                             *status = U_ILLEGAL_ARGUMENT_ERROR;
1047                             break;
1048                         }
1049                         continue;
1050                     }
1051                 } else {
<a name="105" id="anc105"></a><span class="line-modified">1052                     if (!_isExtensionSingleton(key, keylen) || !_isExtensionSubtags(buf, len)) {</span>
1053                         if (strict) {
1054                             *status = U_ILLEGAL_ARGUMENT_ERROR;
1055                             break;
1056                         }
1057                         continue;
1058                     }
1059                 }
1060                 bcpKey = key;
<a name="106" id="anc106"></a><span class="line-modified">1061                 if ((len + 1) &lt; extBufCapacity) {</span>
<span class="line-modified">1062                     uprv_memcpy(pExtBuf, buf, len);</span>
<span class="line-modified">1063                     bcpValue = pExtBuf;</span>
<span class="line-modified">1064 </span>
<span class="line-modified">1065                     pExtBuf += len;</span>
<span class="line-modified">1066 </span>
<span class="line-modified">1067                     *pExtBuf = 0;</span>
<span class="line-modified">1068                     pExtBuf++;</span>
<span class="line-removed">1069 </span>
<span class="line-removed">1070                     extBufCapacity -= (len + 1);</span>
<span class="line-removed">1071                 } else {</span>
<span class="line-removed">1072                     *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
1073                     break;
1074                 }
<a name="107" id="anc107"></a>
1075             }
1076 
1077             /* create ExtensionListEntry */
<a name="108" id="anc108"></a><span class="line-modified">1078             ext = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
1079             if (ext == NULL) {
1080                 *status = U_MEMORY_ALLOCATION_ERROR;
1081                 break;
1082             }
1083             ext-&gt;key = bcpKey;
1084             ext-&gt;value = bcpValue;
1085 
1086             if (!_addExtensionToList(&amp;firstExt, ext, TRUE)) {
<a name="109" id="anc109"></a><span class="line-removed">1087                 uprv_free(ext);</span>
1088                 if (strict) {
1089                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1090                     break;
1091                 }
1092             }
1093         }
1094 
1095         /* Special handling for POSIX variant - add the keywords for POSIX */
1096         if (hadPosix) {
1097             /* create ExtensionListEntry for POSIX */
<a name="110" id="anc110"></a><span class="line-modified">1098             ext = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
1099             if (ext == NULL) {
1100                 *status = U_MEMORY_ALLOCATION_ERROR;
<a name="111" id="anc111"></a><span class="line-modified">1101                 goto cleanup;</span>
1102             }
1103             ext-&gt;key = POSIX_KEY;
1104             ext-&gt;value = POSIX_VALUE;
1105 
1106             if (!_addExtensionToList(&amp;firstExt, ext, TRUE)) {
<a name="112" id="anc112"></a><span class="line-modified">1107                 uprv_free(ext);</span>
1108             }
1109         }
1110 
1111         if (U_SUCCESS(*status) &amp;&amp; (firstExt != NULL || firstAttr != NULL)) {
1112             UBool startLDMLExtension = FALSE;
1113             for (ext = firstExt; ext; ext = ext-&gt;next) {
1114                 if (!startLDMLExtension &amp;&amp; uprv_strlen(ext-&gt;key) &gt; 1) {
1115                     /* first LDML u singlton extension */
<a name="113" id="anc113"></a><span class="line-modified">1116                    if (reslen &lt; capacity) {</span>
<span class="line-removed">1117                        *(appendAt + reslen) = SEP;</span>
<span class="line-removed">1118                    }</span>
<span class="line-removed">1119                    reslen++;</span>
<span class="line-removed">1120                    if (reslen &lt; capacity) {</span>
<span class="line-removed">1121                        *(appendAt + reslen) = LDMLEXT;</span>
<span class="line-removed">1122                    }</span>
<span class="line-removed">1123                    reslen++;</span>
<span class="line-removed">1124 </span>
1125                    startLDMLExtension = TRUE;
1126                 }
1127 
1128                 /* write out the sorted BCP47 attributes, extensions and private use */
1129                 if (uprv_strcmp(ext-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
1130                     /* write the value for the attributes */
1131                     for (attr = firstAttr; attr; attr = attr-&gt;next) {
<a name="114" id="anc114"></a><span class="line-modified">1132                         if (reslen &lt; capacity) {</span>
<span class="line-modified">1133                             *(appendAt + reslen) = SEP;</span>
<span class="line-modified">1134                         }</span>
<span class="line-removed">1135                         reslen++;</span>
<span class="line-removed">1136                         len = (int32_t)uprv_strlen(attr-&gt;attribute);</span>
<span class="line-removed">1137                         if (reslen &lt; capacity) {</span>
<span class="line-removed">1138                             uprv_memcpy(appendAt + reslen, attr-&gt;attribute, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1139                         }</span>
<span class="line-removed">1140                         reslen += len;</span>
1141                     }
1142                 } else {
<a name="115" id="anc115"></a><span class="line-modified">1143                     if (reslen &lt; capacity) {</span>
<span class="line-modified">1144                         *(appendAt + reslen) = SEP;</span>
<span class="line-modified">1145                     }</span>
<span class="line-modified">1146                     reslen++;</span>
<span class="line-removed">1147                     len = (int32_t)uprv_strlen(ext-&gt;key);</span>
<span class="line-removed">1148                     if (reslen &lt; capacity) {</span>
<span class="line-removed">1149                         uprv_memcpy(appendAt + reslen, ext-&gt;key, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1150                     }</span>
<span class="line-removed">1151                     reslen += len;</span>
<span class="line-removed">1152                     if (reslen &lt; capacity) {</span>
<span class="line-removed">1153                         *(appendAt + reslen) = SEP;</span>
<span class="line-removed">1154                     }</span>
<span class="line-removed">1155                     reslen++;</span>
<span class="line-removed">1156                     len = (int32_t)uprv_strlen(ext-&gt;value);</span>
<span class="line-removed">1157                     if (reslen &lt; capacity) {</span>
<span class="line-removed">1158                         uprv_memcpy(appendAt + reslen, ext-&gt;value, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1159                     }</span>
<span class="line-removed">1160                     reslen += len;</span>
1161                 }
1162             }
1163         }
<a name="116" id="anc116"></a><span class="line-removed">1164 cleanup:</span>
<span class="line-removed">1165         /* clean up */</span>
<span class="line-removed">1166         ext = firstExt;</span>
<span class="line-removed">1167         while (ext != NULL) {</span>
<span class="line-removed">1168             ExtensionListEntry *tmpExt = ext-&gt;next;</span>
<span class="line-removed">1169             uprv_free(ext);</span>
<span class="line-removed">1170             ext = tmpExt;</span>
<span class="line-removed">1171         }</span>
<span class="line-removed">1172 </span>
<span class="line-removed">1173         attr = firstAttr;</span>
<span class="line-removed">1174         while (attr != NULL) {</span>
<span class="line-removed">1175             AttributeListEntry *tmpAttr = attr-&gt;next;</span>
<span class="line-removed">1176             char *pValue = (char *)attr-&gt;attribute;</span>
<span class="line-removed">1177             uprv_free(pValue);</span>
<span class="line-removed">1178             uprv_free(attr);</span>
<span class="line-removed">1179             attr = tmpAttr;</span>
<span class="line-removed">1180         }</span>
<span class="line-removed">1181 </span>
<span class="line-removed">1182         uenum_close(keywordEnum);</span>
<span class="line-removed">1183 </span>
<span class="line-removed">1184         if (U_FAILURE(*status)) {</span>
<span class="line-removed">1185             return 0;</span>
<span class="line-removed">1186         }</span>
1187     }
<a name="117" id="anc117"></a><span class="line-removed">1188 </span>
<span class="line-removed">1189     return u_terminateChars(appendAt, capacity, reslen, status);</span>
1190 }
1191 
1192 /**
1193  * Append keywords parsed from LDML extension value
1194  * e.g. &quot;u-ca-gregory-co-trad&quot; -&gt; {calendar = gregorian} {collation = traditional}
1195  * Note: char* buf is used for storing keywords
1196  */
1197 static void
<a name="118" id="anc118"></a><span class="line-modified">1198 _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendTo, char* buf, int32_t bufSize, UBool *posixVariant, UErrorCode *status) {</span>
1199     const char *pTag;   /* beginning of current subtag */
1200     const char *pKwds;  /* beginning of key-type pairs */
1201     UBool variantExists = *posixVariant;
1202 
1203     ExtensionListEntry *kwdFirst = NULL;    /* first LDML keyword */
1204     ExtensionListEntry *kwd, *nextKwd;
1205 
<a name="119" id="anc119"></a><span class="line-removed">1206     AttributeListEntry *attrFirst = NULL;   /* first attribute */</span>
<span class="line-removed">1207     AttributeListEntry *attr, *nextAttr;</span>
<span class="line-removed">1208 </span>
1209     int32_t len;
<a name="120" id="anc120"></a><span class="line-removed">1210     int32_t bufIdx = 0;</span>
<span class="line-removed">1211 </span>
<span class="line-removed">1212     char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];</span>
<span class="line-removed">1213     int32_t attrBufIdx = 0;</span>
1214 
1215     /* Reset the posixVariant value */
1216     *posixVariant = FALSE;
1217 
1218     pTag = ldmlext;
1219     pKwds = NULL;
1220 
<a name="121" id="anc121"></a><span class="line-modified">1221     /* Iterate through u extension attributes */</span>
<span class="line-modified">1222     while (*pTag) {</span>
<span class="line-modified">1223         /* locate next separator char */</span>
<span class="line-removed">1224         for (len = 0; *(pTag + len) &amp;&amp; *(pTag + len) != SEP; len++);</span>
1225 
<a name="122" id="anc122"></a><span class="line-modified">1226         if (ultag_isUnicodeLocaleKey(pTag, len)) {</span>
<span class="line-modified">1227             pKwds = pTag;</span>
<span class="line-removed">1228             break;</span>
<span class="line-removed">1229         }</span>
1230 
<a name="123" id="anc123"></a><span class="line-modified">1231         /* add this attribute to the list */</span>
<span class="line-removed">1232         attr = (AttributeListEntry*)uprv_malloc(sizeof(AttributeListEntry));</span>
<span class="line-removed">1233         if (attr == NULL) {</span>
<span class="line-removed">1234             *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">1235             goto cleanup;</span>
<span class="line-removed">1236         }</span>
1237 
<a name="124" id="anc124"></a><span class="line-modified">1238         if (len &lt; (int32_t)sizeof(attrBuf) - attrBufIdx) {</span>
<span class="line-modified">1239             uprv_memcpy(&amp;attrBuf[attrBufIdx], pTag, len);</span>
<span class="line-modified">1240             attrBuf[attrBufIdx + len] = 0;</span>
<span class="line-modified">1241             attr-&gt;attribute = &amp;attrBuf[attrBufIdx];</span>
<span class="line-removed">1242             attrBufIdx += (len + 1);</span>
<span class="line-removed">1243         } else {</span>
<span class="line-removed">1244             *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-removed">1245             goto cleanup;</span>
<span class="line-removed">1246         }</span>
1247 
<a name="125" id="anc125"></a><span class="line-modified">1248         if (!_addAttributeToList(&amp;attrFirst, attr)) {</span>
<span class="line-modified">1249             *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">1250             uprv_free(attr);</span>
<span class="line-modified">1251             goto cleanup;</span>
<span class="line-removed">1252         }</span>
1253 
<a name="126" id="anc126"></a><span class="line-modified">1254         /* next tag */</span>
<span class="line-modified">1255         pTag += len;</span>
<span class="line-modified">1256         if (*pTag) {</span>
<span class="line-modified">1257             /* next to the separator */</span>
<span class="line-modified">1258             pTag++;</span>
<span class="line-modified">1259         }</span>
<span class="line-removed">1260     }</span>
1261 
<a name="127" id="anc127"></a><span class="line-modified">1262     if (attrFirst) {</span>
<span class="line-modified">1263         /* emit attributes as an LDML keyword, e.g. attribute=attr1-attr2 */</span>







1264 
<a name="128" id="anc128"></a><span class="line-modified">1265         if (attrBufIdx &gt; bufSize) {</span>
<span class="line-modified">1266             /* attrBufIdx == &lt;total length of attribute subtag&gt; + 1 */</span>
<span class="line-modified">1267             *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">1268             goto cleanup;</span>
<span class="line-removed">1269         }</span>
1270 
<a name="129" id="anc129"></a><span class="line-modified">1271         kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
<span class="line-modified">1272         if (kwd == NULL) {</span>
<span class="line-modified">1273             *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1274             goto cleanup;</span>


1275         }
1276 
<a name="130" id="anc130"></a><span class="line-modified">1277         kwd-&gt;key = LOCALE_ATTRIBUTE_KEY;</span>
<span class="line-modified">1278         kwd-&gt;value = buf;</span>
1279 
<a name="131" id="anc131"></a><span class="line-modified">1280         /* attribute subtags sorted in alphabetical order as type */</span>
<span class="line-modified">1281         attr = attrFirst;</span>
<span class="line-modified">1282         while (attr != NULL) {</span>
<span class="line-modified">1283             nextAttr = attr-&gt;next;</span>
<span class="line-removed">1284 </span>
<span class="line-removed">1285             /* buffer size check is done above */</span>
<span class="line-removed">1286             if (attr != attrFirst) {</span>
<span class="line-removed">1287                 *(buf + bufIdx) = SEP;</span>
<span class="line-removed">1288                 bufIdx++;</span>
1289             }
1290 
<a name="132" id="anc132"></a><span class="line-modified">1291             len = static_cast&lt;int32_t&gt;(uprv_strlen(attr-&gt;attribute));</span>
<span class="line-modified">1292             uprv_memcpy(buf + bufIdx, attr-&gt;attribute, len);</span>
<span class="line-modified">1293             bufIdx += len;</span>


1294 
<a name="133" id="anc133"></a><span class="line-modified">1295             attr = nextAttr;</span>
<span class="line-modified">1296         }</span>
<span class="line-modified">1297         *(buf + bufIdx) = 0;</span>
<span class="line-modified">1298         bufIdx++;</span>









1299 
<a name="134" id="anc134"></a><span class="line-modified">1300         if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {</span>
<span class="line-modified">1301             *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-removed">1302             uprv_free(kwd);</span>
<span class="line-removed">1303             goto cleanup;</span>
<span class="line-removed">1304         }</span>
1305 
<a name="135" id="anc135"></a><span class="line-modified">1306         /* once keyword entry is created, delete the attribute list */</span>
<span class="line-modified">1307         attr = attrFirst;</span>
<span class="line-modified">1308         while (attr != NULL) {</span>
<span class="line-modified">1309             nextAttr = attr-&gt;next;</span>
<span class="line-removed">1310             uprv_free(attr);</span>
<span class="line-removed">1311             attr = nextAttr;</span>
1312         }
<a name="136" id="anc136"></a><span class="line-removed">1313         attrFirst = NULL;</span>
1314     }
1315 
1316     if (pKwds) {
1317         const char *pBcpKey = NULL;     /* u extenstion key subtag */
1318         const char *pBcpType = NULL;    /* beginning of u extension type subtag(s) */
1319         int32_t bcpKeyLen = 0;
1320         int32_t bcpTypeLen = 0;
1321         UBool isDone = FALSE;
1322 
1323         pTag = pKwds;
1324         /* BCP47 representation of LDML key/type pairs */
1325         while (!isDone) {
1326             const char *pNextBcpKey = NULL;
1327             int32_t nextBcpKeyLen = 0;
1328             UBool emitKeyword = FALSE;
1329 
1330             if (*pTag) {
1331                 /* locate next separator char */
1332                 for (len = 0; *(pTag + len) &amp;&amp; *(pTag + len) != SEP; len++);
1333 
1334                 if (ultag_isUnicodeLocaleKey(pTag, len)) {
1335                     if (pBcpKey) {
1336                         emitKeyword = TRUE;
1337                         pNextBcpKey = pTag;
1338                         nextBcpKeyLen = len;
1339                     } else {
1340                         pBcpKey = pTag;
1341                         bcpKeyLen = len;
1342                     }
1343                 } else {
1344                     U_ASSERT(pBcpKey != NULL);
1345                     /* within LDML type subtags */
1346                     if (pBcpType) {
1347                         bcpTypeLen += (len + 1);
1348                     } else {
1349                         pBcpType = pTag;
1350                         bcpTypeLen = len;
1351                     }
1352                 }
1353 
1354                 /* next tag */
1355                 pTag += len;
1356                 if (*pTag) {
1357                     /* next to the separator */
1358                     pTag++;
1359                 }
1360             } else {
1361                 /* processing last one */
1362                 emitKeyword = TRUE;
1363                 isDone = TRUE;
1364             }
1365 
1366             if (emitKeyword) {
1367                 const char *pKey = NULL;    /* LDML key */
1368                 const char *pType = NULL;   /* LDML type */
1369 
1370                 char bcpKeyBuf[9];          /* BCP key length is always 2 for now */
1371 
1372                 U_ASSERT(pBcpKey != NULL);
1373 
1374                 if (bcpKeyLen &gt;= (int32_t)sizeof(bcpKeyBuf)) {
1375                     /* the BCP key is invalid */
1376                     *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="137" id="anc137"></a><span class="line-modified">1377                     goto cleanup;</span>
1378                 }
1379 
1380                 uprv_strncpy(bcpKeyBuf, pBcpKey, bcpKeyLen);
1381                 bcpKeyBuf[bcpKeyLen] = 0;
1382 
1383                 /* u extension key to LDML key */
1384                 pKey = uloc_toLegacyKey(bcpKeyBuf);
1385                 if (pKey == NULL) {
1386                     *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="138" id="anc138"></a><span class="line-modified">1387                     goto cleanup;</span>
1388                 }
1389                 if (pKey == bcpKeyBuf) {
1390                     /*
1391                     The key returned by toLegacyKey points to the input buffer.
1392                     We normalize the result key to lower case.
1393                     */
1394                     T_CString_toLowerCase(bcpKeyBuf);
<a name="139" id="anc139"></a><span class="line-modified">1395                     if (bufSize - bufIdx - 1 &gt;= bcpKeyLen) {</span>
<span class="line-modified">1396                         uprv_memcpy(buf + bufIdx, bcpKeyBuf, bcpKeyLen);</span>
<span class="line-modified">1397                         pKey = buf + bufIdx;</span>
<span class="line-modified">1398                         bufIdx += bcpKeyLen;</span>
<span class="line-modified">1399                         *(buf + bufIdx) = 0;</span>
<span class="line-modified">1400                         bufIdx++;</span>
<span class="line-modified">1401                     } else {</span>
<span class="line-removed">1402                         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-removed">1403                         goto cleanup;</span>
1404                     }
<a name="140" id="anc140"></a>
1405                 }
1406 
1407                 if (pBcpType) {
1408                     char bcpTypeBuf[128];       /* practically long enough even considering multiple subtag type */
1409                     if (bcpTypeLen &gt;= (int32_t)sizeof(bcpTypeBuf)) {
1410                         /* the BCP type is too long */
1411                         *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="141" id="anc141"></a><span class="line-modified">1412                         goto cleanup;</span>
1413                     }
1414 
1415                     uprv_strncpy(bcpTypeBuf, pBcpType, bcpTypeLen);
1416                     bcpTypeBuf[bcpTypeLen] = 0;
1417 
1418                     /* BCP type to locale type */
1419                     pType = uloc_toLegacyType(pKey, bcpTypeBuf);
1420                     if (pType == NULL) {
1421                         *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="142" id="anc142"></a><span class="line-modified">1422                         goto cleanup;</span>
1423                     }
1424                     if (pType == bcpTypeBuf) {
1425                         /*
1426                         The type returned by toLegacyType points to the input buffer.
1427                         We normalize the result type to lower case.
1428                         */
1429                         /* normalize to lower case */
1430                         T_CString_toLowerCase(bcpTypeBuf);
<a name="143" id="anc143"></a><span class="line-modified">1431                         if (bufSize - bufIdx - 1 &gt;= bcpTypeLen) {</span>
<span class="line-modified">1432                             uprv_memcpy(buf + bufIdx, bcpTypeBuf, bcpTypeLen);</span>
<span class="line-modified">1433                             pType = buf + bufIdx;</span>
<span class="line-modified">1434                             bufIdx += bcpTypeLen;</span>
<span class="line-removed">1435                             *(buf + bufIdx) = 0;</span>
<span class="line-removed">1436                             bufIdx++;</span>
<span class="line-removed">1437                         } else {</span>
<span class="line-removed">1438                             *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-removed">1439                             goto cleanup;</span>
1440                         }
<a name="144" id="anc144"></a>



1441                     }
1442                 } else {
1443                     /* typeless - default type value is &quot;yes&quot; */
1444                     pType = LOCALE_TYPE_YES;
1445                 }
1446 
1447                 /* Special handling for u-va-posix, since we want to treat this as a variant,
1448                    not as a keyword */
1449                 if (!variantExists &amp;&amp; !uprv_strcmp(pKey, POSIX_KEY) &amp;&amp; !uprv_strcmp(pType, POSIX_VALUE) ) {
1450                     *posixVariant = TRUE;
1451                 } else {
1452                     /* create an ExtensionListEntry for this keyword */
<a name="145" id="anc145"></a><span class="line-modified">1453                     kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
1454                     if (kwd == NULL) {
1455                         *status = U_MEMORY_ALLOCATION_ERROR;
<a name="146" id="anc146"></a><span class="line-modified">1456                         goto cleanup;</span>
1457                     }
1458 
1459                     kwd-&gt;key = pKey;
1460                     kwd-&gt;value = pType;
1461 
1462                     if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
<a name="147" id="anc147"></a><span class="line-modified">1463                         *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">1464                         uprv_free(kwd);</span>
<span class="line-removed">1465                         goto cleanup;</span>
1466                     }
1467                 }
1468 
1469                 pBcpKey = pNextBcpKey;
1470                 bcpKeyLen = pNextBcpKey != NULL ? nextBcpKeyLen : 0;
1471                 pBcpType = NULL;
1472                 bcpTypeLen = 0;
1473             }
1474         }
1475     }
1476 
1477     kwd = kwdFirst;
1478     while (kwd != NULL) {
1479         nextKwd = kwd-&gt;next;
1480         _addExtensionToList(appendTo, kwd, FALSE);
1481         kwd = nextKwd;
1482     }
<a name="148" id="anc148"></a><span class="line-removed">1483 </span>
<span class="line-removed">1484     return;</span>
<span class="line-removed">1485 </span>
<span class="line-removed">1486 cleanup:</span>
<span class="line-removed">1487     attr = attrFirst;</span>
<span class="line-removed">1488     while (attr != NULL) {</span>
<span class="line-removed">1489         nextAttr = attr-&gt;next;</span>
<span class="line-removed">1490         uprv_free(attr);</span>
<span class="line-removed">1491         attr = nextAttr;</span>
<span class="line-removed">1492     }</span>
<span class="line-removed">1493 </span>
<span class="line-removed">1494     kwd = kwdFirst;</span>
<span class="line-removed">1495     while (kwd != NULL) {</span>
<span class="line-removed">1496         nextKwd = kwd-&gt;next;</span>
<span class="line-removed">1497         uprv_free(kwd);</span>
<span class="line-removed">1498         kwd = nextKwd;</span>
<span class="line-removed">1499     }</span>
1500 }
1501 
1502 
<a name="149" id="anc149"></a><span class="line-modified">1503 static int32_t</span>
<span class="line-modified">1504 _appendKeywords(ULanguageTag* langtag, char* appendAt, int32_t capacity, UErrorCode* status) {</span>
<span class="line-removed">1505     int32_t reslen = 0;</span>
1506     int32_t i, n;
1507     int32_t len;
1508     ExtensionListEntry *kwdFirst = NULL;
1509     ExtensionListEntry *kwd;
1510     const char *key, *type;
<a name="150" id="anc150"></a><span class="line-modified">1511     char *kwdBuf = NULL;</span>
<span class="line-modified">1512     int32_t kwdBufLength = capacity;</span>
1513     UBool posixVariant = FALSE;
1514 
1515     if (U_FAILURE(*status)) {
<a name="151" id="anc151"></a><span class="line-modified">1516         return 0;</span>
<span class="line-removed">1517     }</span>
<span class="line-removed">1518 </span>
<span class="line-removed">1519     kwdBuf = (char*)uprv_malloc(kwdBufLength);</span>
<span class="line-removed">1520     if (kwdBuf == NULL) {</span>
<span class="line-removed">1521         *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">1522         return 0;</span>
1523     }
1524 
1525     /* Determine if variants already exists */
1526     if (ultag_getVariantsSize(langtag)) {
1527         posixVariant = TRUE;
1528     }
1529 
1530     n = ultag_getExtensionsSize(langtag);
1531 
1532     /* resolve locale keywords and reordering keys */
1533     for (i = 0; i &lt; n; i++) {
1534         key = ultag_getExtensionKey(langtag, i);
1535         type = ultag_getExtensionValue(langtag, i);
1536         if (*key == LDMLEXT) {
<a name="152" id="anc152"></a><span class="line-modified">1537             _appendLDMLExtensionAsKeywords(type, &amp;kwdFirst, kwdBuf, kwdBufLength, &amp;posixVariant, status);</span>
1538             if (U_FAILURE(*status)) {
1539                 break;
1540             }
1541         } else {
<a name="153" id="anc153"></a><span class="line-modified">1542             kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
1543             if (kwd == NULL) {
1544                 *status = U_MEMORY_ALLOCATION_ERROR;
1545                 break;
1546             }
1547             kwd-&gt;key = key;
1548             kwd-&gt;value = type;
1549             if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
<a name="154" id="anc154"></a><span class="line-removed">1550                 uprv_free(kwd);</span>
1551                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1552                 break;
1553             }
1554         }
1555     }
1556 
1557     if (U_SUCCESS(*status)) {
1558         type = ultag_getPrivateUse(langtag);
1559         if ((int32_t)uprv_strlen(type) &gt; 0) {
1560             /* add private use as a keyword */
<a name="155" id="anc155"></a><span class="line-modified">1561             kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
1562             if (kwd == NULL) {
1563                 *status = U_MEMORY_ALLOCATION_ERROR;
1564             } else {
1565                 kwd-&gt;key = PRIVATEUSE_KEY;
1566                 kwd-&gt;value = type;
1567                 if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
<a name="156" id="anc156"></a><span class="line-removed">1568                     uprv_free(kwd);</span>
1569                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1570                 }
1571             }
1572         }
1573     }
1574 
1575     /* If a POSIX variant was in the extensions, write it out before writing the keywords. */
1576 
1577     if (U_SUCCESS(*status) &amp;&amp; posixVariant) {
1578         len = (int32_t) uprv_strlen(_POSIX);
<a name="157" id="anc157"></a><span class="line-modified">1579         if (reslen &lt; capacity) {</span>
<span class="line-removed">1580             uprv_memcpy(appendAt + reslen, _POSIX, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1581         }</span>
<span class="line-removed">1582         reslen += len;</span>
1583     }
1584 
1585     if (U_SUCCESS(*status) &amp;&amp; kwdFirst != NULL) {
1586         /* write out the sorted keywords */
1587         UBool firstValue = TRUE;
1588         kwd = kwdFirst;
1589         do {
<a name="158" id="anc158"></a><span class="line-modified">1590             if (reslen &lt; capacity) {</span>
<span class="line-modified">1591                 if (firstValue) {</span>
<span class="line-modified">1592                     /* &#39;@&#39; */</span>
<span class="line-modified">1593                     *(appendAt + reslen) = LOCALE_EXT_SEP;</span>
<span class="line-modified">1594                     firstValue = FALSE;</span>
<span class="line-removed">1595                 } else {</span>
<span class="line-removed">1596                     /* &#39;;&#39; */</span>
<span class="line-removed">1597                     *(appendAt + reslen) = LOCALE_KEYWORD_SEP;</span>
<span class="line-removed">1598                 }</span>
1599             }
<a name="159" id="anc159"></a><span class="line-removed">1600             reslen++;</span>
1601 
1602             /* key */
1603             len = (int32_t)uprv_strlen(kwd-&gt;key);
<a name="160" id="anc160"></a><span class="line-modified">1604             if (reslen &lt; capacity) {</span>
<span class="line-modified">1605                 uprv_memcpy(appendAt + reslen, kwd-&gt;key, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1606             }</span>
<span class="line-removed">1607             reslen += len;</span>
<span class="line-removed">1608 </span>
<span class="line-removed">1609             /* &#39;=&#39; */</span>
<span class="line-removed">1610             if (reslen &lt; capacity) {</span>
<span class="line-removed">1611                 *(appendAt + reslen) = LOCALE_KEY_TYPE_SEP;</span>
<span class="line-removed">1612             }</span>
<span class="line-removed">1613             reslen++;</span>
1614 
1615             /* type */
1616             len = (int32_t)uprv_strlen(kwd-&gt;value);
<a name="161" id="anc161"></a><span class="line-modified">1617             if (reslen &lt; capacity) {</span>
<span class="line-removed">1618                 uprv_memcpy(appendAt + reslen, kwd-&gt;value, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1619             }</span>
<span class="line-removed">1620             reslen += len;</span>
1621 
1622             kwd = kwd-&gt;next;
1623         } while (kwd);
1624     }
<a name="162" id="anc162"></a><span class="line-removed">1625 </span>
<span class="line-removed">1626     /* clean up */</span>
<span class="line-removed">1627     kwd = kwdFirst;</span>
<span class="line-removed">1628     while (kwd != NULL) {</span>
<span class="line-removed">1629         ExtensionListEntry *tmpKwd = kwd-&gt;next;</span>
<span class="line-removed">1630         uprv_free(kwd);</span>
<span class="line-removed">1631         kwd = tmpKwd;</span>
<span class="line-removed">1632     }</span>
<span class="line-removed">1633 </span>
<span class="line-removed">1634     uprv_free(kwdBuf);</span>
<span class="line-removed">1635 </span>
<span class="line-removed">1636     if (U_FAILURE(*status)) {</span>
<span class="line-removed">1637         return 0;</span>
<span class="line-removed">1638     }</span>
<span class="line-removed">1639 </span>
<span class="line-removed">1640     return u_terminateChars(appendAt, capacity, reslen, status);</span>
1641 }
1642 
<a name="163" id="anc163"></a><span class="line-modified">1643 static int32_t</span>
<span class="line-modified">1644 _appendPrivateuseToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UBool hadPosix, UErrorCode* status) {</span>
1645     (void)hadPosix;
1646     char buf[ULOC_FULLNAME_CAPACITY];
1647     char tmpAppend[ULOC_FULLNAME_CAPACITY];
1648     UErrorCode tmpStatus = U_ZERO_ERROR;
1649     int32_t len, i;
1650     int32_t reslen = 0;
<a name="164" id="anc164"></a>
1651 
1652     if (U_FAILURE(*status)) {
<a name="165" id="anc165"></a><span class="line-modified">1653         return 0;</span>
1654     }
1655 
1656     len = uloc_getVariant(localeID, buf, sizeof(buf), &amp;tmpStatus);
1657     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1658         if (strict) {
1659             *status = U_ILLEGAL_ARGUMENT_ERROR;
1660         }
<a name="166" id="anc166"></a><span class="line-modified">1661         return 0;</span>
1662     }
1663 
1664     if (len &gt; 0) {
1665         char *p, *pPriv;
1666         UBool bNext = TRUE;
1667         UBool firstValue = TRUE;
1668         UBool writeValue;
1669 
1670         pPriv = NULL;
1671         p = buf;
1672         while (bNext) {
1673             writeValue = FALSE;
1674             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
1675                 if (*p == 0) {
1676                     bNext = FALSE;
1677                 } else {
1678                     *p = 0; /* terminate */
1679                 }
1680                 if (pPriv != NULL) {
1681                     /* Private use in the canonical format is lowercase in BCP47 */
1682                     for (i = 0; *(pPriv + i) != 0; i++) {
1683                         *(pPriv + i) = uprv_tolower(*(pPriv + i));
1684                     }
1685 
1686                     /* validate */
1687                     if (_isPrivateuseValueSubtag(pPriv, -1)) {
1688                         if (firstValue) {
1689                             if (!_isVariantSubtag(pPriv, -1)) {
1690                                 writeValue = TRUE;
1691                             }
1692                         } else {
1693                             writeValue = TRUE;
1694                         }
1695                     } else if (strict) {
1696                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1697                         break;
1698                     } else {
1699                         break;
1700                     }
1701 
1702                     if (writeValue) {
1703                         if (reslen &lt; capacity) {
1704                             tmpAppend[reslen++] = SEP;
1705                         }
1706 
1707                         if (firstValue) {
1708                             if (reslen &lt; capacity) {
1709                                 tmpAppend[reslen++] = *PRIVATEUSE_KEY;
1710                             }
1711 
1712                             if (reslen &lt; capacity) {
1713                                 tmpAppend[reslen++] = SEP;
1714                             }
1715 
1716                             len = (int32_t)uprv_strlen(PRIVUSE_VARIANT_PREFIX);
1717                             if (reslen &lt; capacity) {
1718                                 uprv_memcpy(tmpAppend + reslen, PRIVUSE_VARIANT_PREFIX, uprv_min(len, capacity - reslen));
1719                             }
1720                             reslen += len;
1721 
1722                             if (reslen &lt; capacity) {
1723                                 tmpAppend[reslen++] = SEP;
1724                             }
1725 
1726                             firstValue = FALSE;
1727                         }
1728 
1729                         len = (int32_t)uprv_strlen(pPriv);
1730                         if (reslen &lt; capacity) {
1731                             uprv_memcpy(tmpAppend + reslen, pPriv, uprv_min(len, capacity - reslen));
1732                         }
1733                         reslen += len;
1734                     }
1735                 }
1736                 /* reset private use starting position */
1737                 pPriv = NULL;
1738             } else if (pPriv == NULL) {
1739                 pPriv = p;
1740             }
1741             p++;
1742         }
1743 
1744         if (U_FAILURE(*status)) {
<a name="167" id="anc167"></a><span class="line-modified">1745             return 0;</span>
1746         }
1747     }
1748 
1749     if (U_SUCCESS(*status)) {
1750         len = reslen;
<a name="168" id="anc168"></a><span class="line-modified">1751         if (reslen &lt; capacity) {</span>
<span class="line-removed">1752             uprv_memcpy(appendAt, tmpAppend, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1753         }</span>
1754     }
<a name="169" id="anc169"></a><span class="line-removed">1755 </span>
<span class="line-removed">1756     u_terminateChars(appendAt, capacity, reslen, status);</span>
<span class="line-removed">1757 </span>
<span class="line-removed">1758     return reslen;</span>
1759 }
1760 
1761 /*
1762 * -------------------------------------------------
1763 *
1764 * ultag_ functions
1765 *
1766 * -------------------------------------------------
1767 */
1768 
1769 /* Bit flags used by the parser */
1770 #define LANG 0x0001
1771 #define EXTL 0x0002
1772 #define SCRT 0x0004
1773 #define REGN 0x0008
1774 #define VART 0x0010
1775 #define EXTS 0x0020
1776 #define EXTV 0x0040
1777 #define PRIV 0x0080
1778 
1779 /**
1780  * Ticket #12705 - Visual Studio 2015 Update 3 contains a new code optimizer which has problems optimizing
1781  * this function. (See https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/ )
1782  * As a workaround, we will turn off optimization just for this function on VS2015 Update 3 and above.
1783  */
1784 #if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 190024210))
1785 #pragma optimize( &quot;&quot;, off )
1786 #endif
1787 
1788 static ULanguageTag*
1789 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status) {
<a name="170" id="anc170"></a><span class="line-removed">1790     ULanguageTag *t;</span>
1791     char *tagBuf;
1792     int16_t next;
1793     char *pSubtag, *pNext, *pLastGoodPosition;
1794     int32_t subtagLen;
1795     int32_t extlangIdx;
1796     ExtensionListEntry *pExtension;
1797     char *pExtValueSubtag, *pExtValueSubtagEnd;
1798     int32_t i;
1799     UBool privateuseVar = FALSE;
1800     int32_t grandfatheredLen = 0;
1801 
1802     if (parsedLen != NULL) {
1803         *parsedLen = 0;
1804     }
1805 
1806     if (U_FAILURE(*status)) {
1807         return NULL;
1808     }
1809 
1810     if (tagLen &lt; 0) {
1811         tagLen = (int32_t)uprv_strlen(tag);
1812     }
1813 
1814     /* copy the entire string */
1815     tagBuf = (char*)uprv_malloc(tagLen + 1);
1816     if (tagBuf == NULL) {
1817         *status = U_MEMORY_ALLOCATION_ERROR;
1818         return NULL;
1819     }
1820     uprv_memcpy(tagBuf, tag, tagLen);
1821     *(tagBuf + tagLen) = 0;
1822 
1823     /* create a ULanguageTag */
<a name="171" id="anc171"></a><span class="line-modified">1824     t = (ULanguageTag*)uprv_malloc(sizeof(ULanguageTag));</span>
<span class="line-modified">1825     if (t == NULL) {</span>

1826         uprv_free(tagBuf);
1827         *status = U_MEMORY_ALLOCATION_ERROR;
1828         return NULL;
1829     }
<a name="172" id="anc172"></a><span class="line-modified">1830     _initializeULanguageTag(t);</span>
1831     t-&gt;buf = tagBuf;
1832 
1833     if (tagLen &lt; MINLEN) {
1834         /* the input tag is too short - return empty ULanguageTag */
<a name="173" id="anc173"></a><span class="line-modified">1835         return t;</span>
1836     }
1837 
<a name="174" id="anc174"></a>



1838     /* check if the tag is grandfathered */
<a name="175" id="anc175"></a><span class="line-modified">1839     for (i = 0; GRANDFATHERED[i] != NULL; i += 2) {</span>
<span class="line-modified">1840         if (uprv_stricmp(GRANDFATHERED[i], tagBuf) == 0) {</span>








1841             int32_t newTagLength;
1842 
<a name="176" id="anc176"></a><span class="line-modified">1843             grandfatheredLen = tagLen;  /* back up for output parsedLen */</span>
<span class="line-modified">1844             newTagLength = static_cast&lt;int32_t&gt;(uprv_strlen(GRANDFATHERED[i+1]));</span>

1845             if (tagLen &lt; newTagLength) {
1846                 uprv_free(tagBuf);
1847                 tagBuf = (char*)uprv_malloc(newTagLength + 1);
1848                 if (tagBuf == NULL) {
1849                     *status = U_MEMORY_ALLOCATION_ERROR;
<a name="177" id="anc177"></a><span class="line-removed">1850                     ultag_close(t);</span>
1851                     return NULL;
1852                 }
1853                 t-&gt;buf = tagBuf;
1854                 tagLen = newTagLength;
1855             }
<a name="178" id="anc178"></a>
1856             uprv_strcpy(t-&gt;buf, GRANDFATHERED[i + 1]);
<a name="179" id="anc179"></a>


1857             break;
1858         }
1859     }
1860 
<a name="180" id="anc180"></a>





























1861     /*
1862      * langtag      =   language
1863      *                  [&quot;-&quot; script]
1864      *                  [&quot;-&quot; region]
1865      *                  *(&quot;-&quot; variant)
1866      *                  *(&quot;-&quot; extension)
1867      *                  [&quot;-&quot; privateuse]
1868      */
1869 
1870     next = LANG | PRIV;
1871     pNext = pLastGoodPosition = tagBuf;
1872     extlangIdx = 0;
1873     pExtension = NULL;
1874     pExtValueSubtag = NULL;
1875     pExtValueSubtagEnd = NULL;
1876 
1877     while (pNext) {
1878         char *pSep;
1879 
1880         pSubtag = pNext;
1881 
1882         /* locate next separator char */
1883         pSep = pSubtag;
1884         while (*pSep) {
1885             if (*pSep == SEP) {
1886                 break;
1887             }
1888             pSep++;
1889         }
1890         if (*pSep == 0) {
1891             /* last subtag */
1892             pNext = NULL;
1893         } else {
1894             pNext = pSep + 1;
1895         }
1896         subtagLen = (int32_t)(pSep - pSubtag);
1897 
1898         if (next &amp; LANG) {
<a name="181" id="anc181"></a><span class="line-modified">1899             if (_isLanguageSubtag(pSubtag, subtagLen)) {</span>
1900                 *pSep = 0;  /* terminate */
<a name="182" id="anc182"></a>
1901                 t-&gt;language = T_CString_toLowerCase(pSubtag);
1902 
1903                 pLastGoodPosition = pSep;
<a name="183" id="anc183"></a><span class="line-modified">1904                 next = EXTL | SCRT | REGN | VART | EXTS | PRIV;</span>


1905                 continue;
1906             }
1907         }
1908         if (next &amp; EXTL) {
1909             if (_isExtlangSubtag(pSubtag, subtagLen)) {
1910                 *pSep = 0;
1911                 t-&gt;extlang[extlangIdx++] = T_CString_toLowerCase(pSubtag);
1912 
1913                 pLastGoodPosition = pSep;
1914                 if (extlangIdx &lt; 3) {
1915                     next = EXTL | SCRT | REGN | VART | EXTS | PRIV;
1916                 } else {
1917                     next = SCRT | REGN | VART | EXTS | PRIV;
1918                 }
1919                 continue;
1920             }
1921         }
1922         if (next &amp; SCRT) {
<a name="184" id="anc184"></a><span class="line-modified">1923             if (_isScriptSubtag(pSubtag, subtagLen)) {</span>
1924                 char *p = pSubtag;
1925 
1926                 *pSep = 0;
1927 
1928                 /* to title case */
1929                 *p = uprv_toupper(*p);
1930                 p++;
1931                 for (; *p; p++) {
1932                     *p = uprv_tolower(*p);
1933                 }
1934 
1935                 t-&gt;script = pSubtag;
1936 
1937                 pLastGoodPosition = pSep;
1938                 next = REGN | VART | EXTS | PRIV;
1939                 continue;
1940             }
1941         }
1942         if (next &amp; REGN) {
<a name="185" id="anc185"></a><span class="line-modified">1943             if (_isRegionSubtag(pSubtag, subtagLen)) {</span>
1944                 *pSep = 0;
<a name="186" id="anc186"></a>
1945                 t-&gt;region = T_CString_toUpperCase(pSubtag);
1946 
1947                 pLastGoodPosition = pSep;
1948                 next = VART | EXTS | PRIV;
1949                 continue;
1950             }
1951         }
1952         if (next &amp; VART) {
1953             if (_isVariantSubtag(pSubtag, subtagLen) ||
1954                (privateuseVar &amp;&amp; _isPrivateuseVariantSubtag(pSubtag, subtagLen))) {
1955                 VariantListEntry *var;
1956                 UBool isAdded;
1957 
1958                 var = (VariantListEntry*)uprv_malloc(sizeof(VariantListEntry));
1959                 if (var == NULL) {
1960                     *status = U_MEMORY_ALLOCATION_ERROR;
<a name="187" id="anc187"></a><span class="line-modified">1961                     goto error;</span>
1962                 }
1963                 *pSep = 0;
1964                 var-&gt;variant = T_CString_toUpperCase(pSubtag);
1965                 isAdded = _addVariantToList(&amp;(t-&gt;variants), var);
1966                 if (!isAdded) {
1967                     /* duplicated variant entry */
1968                     uprv_free(var);
1969                     break;
1970                 }
1971                 pLastGoodPosition = pSep;
1972                 next = VART | EXTS | PRIV;
1973                 continue;
1974             }
1975         }
1976         if (next &amp; EXTS) {
1977             if (_isExtensionSingleton(pSubtag, subtagLen)) {
1978                 if (pExtension != NULL) {
1979                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
1980                         /* the previous extension is incomplete */
1981                         uprv_free(pExtension);
1982                         pExtension = NULL;
1983                         break;
1984                     }
1985 
1986                     /* terminate the previous extension value */
1987                     *pExtValueSubtagEnd = 0;
1988                     pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
1989 
1990                     /* insert the extension to the list */
1991                     if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
1992                         pLastGoodPosition = pExtValueSubtagEnd;
1993                     } else {
1994                         /* stop parsing here */
1995                         uprv_free(pExtension);
1996                         pExtension = NULL;
1997                         break;
1998                     }
1999                 }
2000 
2001                 /* create a new extension */
2002                 pExtension = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
2003                 if (pExtension == NULL) {
2004                     *status = U_MEMORY_ALLOCATION_ERROR;
<a name="188" id="anc188"></a><span class="line-modified">2005                     goto error;</span>
2006                 }
2007                 *pSep = 0;
2008                 pExtension-&gt;key = T_CString_toLowerCase(pSubtag);
2009                 pExtension-&gt;value = NULL;   /* will be set later */
2010 
2011                 /*
2012                  * reset the start and the end location of extension value
2013                  * subtags for this extension
2014                  */
2015                 pExtValueSubtag = NULL;
2016                 pExtValueSubtagEnd = NULL;
2017 
2018                 next = EXTV;
2019                 continue;
2020             }
2021         }
2022         if (next &amp; EXTV) {
2023             if (_isExtensionSubtag(pSubtag, subtagLen)) {
2024                 if (pExtValueSubtag == NULL) {
2025                     /* if the start postion of this extension&#39;s value is not yet,
2026                         this one is the first value subtag */
2027                     pExtValueSubtag = pSubtag;
2028                 }
2029 
2030                 /* Mark the end of this subtag */
2031                 pExtValueSubtagEnd = pSep;
2032                 next = EXTS | EXTV | PRIV;
2033 
2034                 continue;
2035             }
2036         }
2037         if (next &amp; PRIV) {
<a name="189" id="anc189"></a><span class="line-modified">2038             if (uprv_tolower(*pSubtag) == PRIVATEUSE) {</span>
2039                 char *pPrivuseVal;
2040 
2041                 if (pExtension != NULL) {
2042                     /* Process the last extension */
2043                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2044                         /* the previous extension is incomplete */
2045                         uprv_free(pExtension);
2046                         pExtension = NULL;
2047                         break;
2048                     } else {
2049                         /* terminate the previous extension value */
2050                         *pExtValueSubtagEnd = 0;
2051                         pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2052 
2053                         /* insert the extension to the list */
2054                         if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2055                             pLastGoodPosition = pExtValueSubtagEnd;
2056                             pExtension = NULL;
2057                         } else {
2058                         /* stop parsing here */
2059                             uprv_free(pExtension);
2060                             pExtension = NULL;
2061                             break;
2062                         }
2063                     }
2064                 }
2065 
2066                 /* The rest of part will be private use value subtags */
2067                 if (pNext == NULL) {
2068                     /* empty private use subtag */
2069                     break;
2070                 }
2071                 /* back up the private use value start position */
2072                 pPrivuseVal = pNext;
2073 
2074                 /* validate private use value subtags */
2075                 while (pNext) {
2076                     pSubtag = pNext;
2077                     pSep = pSubtag;
2078                     while (*pSep) {
2079                         if (*pSep == SEP) {
2080                             break;
2081                         }
2082                         pSep++;
2083                     }
2084                     if (*pSep == 0) {
2085                         /* last subtag */
2086                         pNext = NULL;
2087                     } else {
2088                         pNext = pSep + 1;
2089                     }
2090                     subtagLen = (int32_t)(pSep - pSubtag);
2091 
2092                     if (uprv_strncmp(pSubtag, PRIVUSE_VARIANT_PREFIX, uprv_strlen(PRIVUSE_VARIANT_PREFIX)) == 0) {
2093                         *pSep = 0;
2094                         next = VART;
2095                         privateuseVar = TRUE;
2096                         break;
2097                     } else if (_isPrivateuseValueSubtag(pSubtag, subtagLen)) {
2098                         pLastGoodPosition = pSep;
2099                     } else {
2100                         break;
2101                     }
2102                 }
2103 
2104                 if (next == VART) {
2105                     continue;
2106                 }
2107 
2108                 if (pLastGoodPosition - pPrivuseVal &gt; 0) {
2109                     *pLastGoodPosition = 0;
2110                     t-&gt;privateuse = T_CString_toLowerCase(pPrivuseVal);
2111                 }
2112                 /* No more subtags, exiting the parse loop */
2113                 break;
2114             }
2115             break;
2116         }
2117 
2118         /* If we fell through here, it means this subtag is illegal - quit parsing */
2119         break;
2120     }
2121 
2122     if (pExtension != NULL) {
2123         /* Process the last extension */
2124         if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2125             /* the previous extension is incomplete */
2126             uprv_free(pExtension);
2127         } else {
2128             /* terminate the previous extension value */
2129             *pExtValueSubtagEnd = 0;
2130             pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2131             /* insert the extension to the list */
2132             if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2133                 pLastGoodPosition = pExtValueSubtagEnd;
2134             } else {
2135                 uprv_free(pExtension);
2136             }
2137         }
2138     }
2139 
2140     if (parsedLen != NULL) {
<a name="190" id="anc190"></a><span class="line-modified">2141         *parsedLen = (grandfatheredLen &gt; 0) ? grandfatheredLen : (int32_t)(pLastGoodPosition - t-&gt;buf);</span>
2142     }
2143 
<a name="191" id="anc191"></a><span class="line-modified">2144     return t;</span>
<span class="line-removed">2145 </span>
<span class="line-removed">2146 error:</span>
<span class="line-removed">2147     ultag_close(t);</span>
<span class="line-removed">2148     return NULL;</span>
2149 }
2150 
2151 /**
2152 * Ticket #12705 - Turn optimization back on.
2153 */
2154 #if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 190024210))
2155 #pragma optimize( &quot;&quot;, on )
2156 #endif
2157 
2158 static void
2159 ultag_close(ULanguageTag* langtag) {
2160 
2161     if (langtag == NULL) {
2162         return;
2163     }
2164 
2165     uprv_free(langtag-&gt;buf);
2166 
2167     if (langtag-&gt;variants) {
2168         VariantListEntry *curVar = langtag-&gt;variants;
2169         while (curVar) {
2170             VariantListEntry *nextVar = curVar-&gt;next;
2171             uprv_free(curVar);
2172             curVar = nextVar;
2173         }
2174     }
2175 
2176     if (langtag-&gt;extensions) {
2177         ExtensionListEntry *curExt = langtag-&gt;extensions;
2178         while (curExt) {
2179             ExtensionListEntry *nextExt = curExt-&gt;next;
2180             uprv_free(curExt);
2181             curExt = nextExt;
2182         }
2183     }
2184 
2185     uprv_free(langtag);
2186 }
2187 
2188 static const char*
2189 ultag_getLanguage(const ULanguageTag* langtag) {
2190     return langtag-&gt;language;
2191 }
2192 
2193 #if 0
2194 static const char*
2195 ultag_getJDKLanguage(const ULanguageTag* langtag) {
2196     int32_t i;
2197     for (i = 0; DEPRECATEDLANGS[i] != NULL; i += 2) {
2198         if (uprv_compareInvCharsAsAscii(DEPRECATEDLANGS[i], langtag-&gt;language) == 0) {
2199             return DEPRECATEDLANGS[i + 1];
2200         }
2201     }
2202     return langtag-&gt;language;
2203 }
2204 #endif
2205 
2206 static const char*
2207 ultag_getExtlang(const ULanguageTag* langtag, int32_t idx) {
2208     if (idx &gt;= 0 &amp;&amp; idx &lt; MAXEXTLANG) {
2209         return langtag-&gt;extlang[idx];
2210     }
2211     return NULL;
2212 }
2213 
2214 static int32_t
2215 ultag_getExtlangSize(const ULanguageTag* langtag) {
2216     int32_t size = 0;
2217     int32_t i;
2218     for (i = 0; i &lt; MAXEXTLANG; i++) {
2219         if (langtag-&gt;extlang[i]) {
2220             size++;
2221         }
2222     }
2223     return size;
2224 }
2225 
2226 static const char*
2227 ultag_getScript(const ULanguageTag* langtag) {
2228     return langtag-&gt;script;
2229 }
2230 
2231 static const char*
2232 ultag_getRegion(const ULanguageTag* langtag) {
2233     return langtag-&gt;region;
2234 }
2235 
2236 static const char*
2237 ultag_getVariant(const ULanguageTag* langtag, int32_t idx) {
2238     const char *var = NULL;
2239     VariantListEntry *cur = langtag-&gt;variants;
2240     int32_t i = 0;
2241     while (cur) {
2242         if (i == idx) {
2243             var = cur-&gt;variant;
2244             break;
2245         }
2246         cur = cur-&gt;next;
2247         i++;
2248     }
2249     return var;
2250 }
2251 
2252 static int32_t
2253 ultag_getVariantsSize(const ULanguageTag* langtag) {
2254     int32_t size = 0;
2255     VariantListEntry *cur = langtag-&gt;variants;
2256     while (TRUE) {
2257         if (cur == NULL) {
2258             break;
2259         }
2260         size++;
2261         cur = cur-&gt;next;
2262     }
2263     return size;
2264 }
2265 
2266 static const char*
2267 ultag_getExtensionKey(const ULanguageTag* langtag, int32_t idx) {
2268     const char *key = NULL;
2269     ExtensionListEntry *cur = langtag-&gt;extensions;
2270     int32_t i = 0;
2271     while (cur) {
2272         if (i == idx) {
2273             key = cur-&gt;key;
2274             break;
2275         }
2276         cur = cur-&gt;next;
2277         i++;
2278     }
2279     return key;
2280 }
2281 
2282 static const char*
2283 ultag_getExtensionValue(const ULanguageTag* langtag, int32_t idx) {
2284     const char *val = NULL;
2285     ExtensionListEntry *cur = langtag-&gt;extensions;
2286     int32_t i = 0;
2287     while (cur) {
2288         if (i == idx) {
2289             val = cur-&gt;value;
2290             break;
2291         }
2292         cur = cur-&gt;next;
2293         i++;
2294     }
2295     return val;
2296 }
2297 
2298 static int32_t
2299 ultag_getExtensionsSize(const ULanguageTag* langtag) {
2300     int32_t size = 0;
2301     ExtensionListEntry *cur = langtag-&gt;extensions;
2302     while (TRUE) {
2303         if (cur == NULL) {
2304             break;
2305         }
2306         size++;
2307         cur = cur-&gt;next;
2308     }
2309     return size;
2310 }
2311 
2312 static const char*
2313 ultag_getPrivateUse(const ULanguageTag* langtag) {
2314     return langtag-&gt;privateuse;
2315 }
2316 
2317 #if 0
2318 static const char*
2319 ultag_getGrandfathered(const ULanguageTag* langtag) {
2320     return langtag-&gt;grandfathered;
2321 }
2322 #endif
2323 
2324 
2325 /*
2326 * -------------------------------------------------
2327 *
2328 * Locale/BCP47 conversion APIs, exposed as uloc_*
2329 *
2330 * -------------------------------------------------
2331 */
2332 U_CAPI int32_t U_EXPORT2
2333 uloc_toLanguageTag(const char* localeID,
2334                    char* langtag,
2335                    int32_t langtagCapacity,
2336                    UBool strict,
2337                    UErrorCode* status) {
<a name="192" id="anc192"></a><span class="line-modified">2338     /* char canonical[ULOC_FULLNAME_CAPACITY]; */ /* See #6822 */</span>
<span class="line-modified">2339     char canonical[256];</span>
<span class="line-modified">2340     int32_t reslen = 0;</span>



























2341     UErrorCode tmpStatus = U_ZERO_ERROR;
2342     UBool hadPosix = FALSE;
2343     const char* pKeywordStart;
2344 
2345     /* Note: uloc_canonicalize returns &quot;en_US_POSIX&quot; for input locale ID &quot;&quot;.  See #6835 */
<a name="193" id="anc193"></a><span class="line-modified">2346     canonical[0] = 0;</span>
<span class="line-modified">2347     if (uprv_strlen(localeID) &gt; 0) {</span>
<span class="line-modified">2348         uloc_canonicalize(localeID, canonical, sizeof(canonical), &amp;tmpStatus);</span>
<span class="line-modified">2349         if (tmpStatus != U_ZERO_ERROR) {</span>
























2350             *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="194" id="anc194"></a><span class="line-modified">2351             return 0;</span>










2352         }
2353     }
2354 
2355     /* For handling special case - private use only tag */
<a name="195" id="anc195"></a><span class="line-modified">2356     pKeywordStart = locale_getKeywordsStart(canonical);</span>
<span class="line-modified">2357     if (pKeywordStart == canonical) {</span>
<span class="line-removed">2358         UEnumeration *kwdEnum;</span>
2359         int kwdCnt = 0;
2360         UBool done = FALSE;
2361 
<a name="196" id="anc196"></a><span class="line-modified">2362         kwdEnum = uloc_openKeywords((const char*)canonical, &amp;tmpStatus);</span>
<span class="line-modified">2363         if (kwdEnum != NULL) {</span>
<span class="line-modified">2364             kwdCnt = uenum_count(kwdEnum, &amp;tmpStatus);</span>
2365             if (kwdCnt == 1) {
2366                 const char *key;
2367                 int32_t len = 0;
2368 
<a name="197" id="anc197"></a><span class="line-modified">2369                 key = uenum_next(kwdEnum, &amp;len, &amp;tmpStatus);</span>
2370                 if (len == 1 &amp;&amp; *key == PRIVATEUSE) {
2371                     char buf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
2372                     buf[0] = PRIVATEUSE;
2373                     buf[1] = SEP;
2374                     len = uloc_getKeywordValue(localeID, key, &amp;buf[2], sizeof(buf) - 2, &amp;tmpStatus);
2375                     if (U_SUCCESS(tmpStatus)) {
<a name="198" id="anc198"></a><span class="line-modified">2376                         if (_isPrivateuseValueSubtags(&amp;buf[2], len)) {</span>
2377                             /* return private use only tag */
<a name="199" id="anc199"></a><span class="line-modified">2378                             reslen = len + 2;</span>
<span class="line-removed">2379                             uprv_memcpy(langtag, buf, uprv_min(reslen, langtagCapacity));</span>
<span class="line-removed">2380                             u_terminateChars(langtag, langtagCapacity, reslen, status);</span>
2381                             done = TRUE;
2382                         } else if (strict) {
2383                             *status = U_ILLEGAL_ARGUMENT_ERROR;
2384                             done = TRUE;
2385                         }
2386                         /* if not strict mode, then &quot;und&quot; will be returned */
2387                     } else {
2388                         *status = U_ILLEGAL_ARGUMENT_ERROR;
2389                         done = TRUE;
2390                     }
2391                 }
2392             }
<a name="200" id="anc200"></a><span class="line-removed">2393             uenum_close(kwdEnum);</span>
2394             if (done) {
<a name="201" id="anc201"></a><span class="line-modified">2395                 return reslen;</span>
2396             }
2397         }
2398     }
2399 
<a name="202" id="anc202"></a><span class="line-modified">2400     reslen += _appendLanguageToLanguageTag(canonical, langtag, langtagCapacity, strict, status);</span>
<span class="line-modified">2401     reslen += _appendScriptToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, status);</span>
<span class="line-modified">2402     reslen += _appendRegionToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, status);</span>
<span class="line-modified">2403     reslen += _appendVariantsToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, &amp;hadPosix, status);</span>
<span class="line-modified">2404     reslen += _appendKeywordsToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, hadPosix, status);</span>
<span class="line-modified">2405     reslen += _appendPrivateuseToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, hadPosix, status);</span>
<span class="line-removed">2406 </span>
<span class="line-removed">2407     return reslen;</span>
2408 }
2409 
2410 
2411 U_CAPI int32_t U_EXPORT2
2412 uloc_forLanguageTag(const char* langtag,
2413                     char* localeID,
2414                     int32_t localeIDCapacity,
2415                     int32_t* parsedLength,
2416                     UErrorCode* status) {
<a name="203" id="anc203"></a><span class="line-modified">2417     ULanguageTag *lt;</span>
<span class="line-modified">2418     int32_t reslen = 0;</span>




























2419     const char *subtag, *p;
2420     int32_t len;
2421     int32_t i, n;
2422     UBool noRegion = TRUE;
2423 
<a name="204" id="anc204"></a><span class="line-modified">2424     lt = ultag_parse(langtag, -1, parsedLength, status);</span>
2425     if (U_FAILURE(*status)) {
<a name="205" id="anc205"></a><span class="line-modified">2426         return 0;</span>
2427     }
2428 
2429     /* language */
<a name="206" id="anc206"></a><span class="line-modified">2430     subtag = ultag_getExtlangSize(lt) &gt; 0 ? ultag_getExtlang(lt, 0) : ultag_getLanguage(lt);</span>
2431     if (uprv_compareInvCharsAsAscii(subtag, LANG_UND) != 0) {
2432         len = (int32_t)uprv_strlen(subtag);
2433         if (len &gt; 0) {
<a name="207" id="anc207"></a><span class="line-modified">2434             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2435                 uprv_memcpy(localeID, subtag, uprv_min(len, localeIDCapacity - reslen));</span>
<span class="line-removed">2436             }</span>
<span class="line-removed">2437             reslen += len;</span>
2438         }
2439     }
2440 
2441     /* script */
<a name="208" id="anc208"></a><span class="line-modified">2442     subtag = ultag_getScript(lt);</span>
2443     len = (int32_t)uprv_strlen(subtag);
2444     if (len &gt; 0) {
<a name="209" id="anc209"></a><span class="line-modified">2445         if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2446             *(localeID + reslen) = LOCALE_SEP;</span>
<span class="line-removed">2447         }</span>
<span class="line-removed">2448         reslen++;</span>
2449 
2450         /* write out the script in title case */
<a name="210" id="anc210"></a><span class="line-modified">2451         p = subtag;</span>
<span class="line-modified">2452         while (*p) {</span>
<span class="line-modified">2453             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-removed">2454                 if (p == subtag) {</span>
<span class="line-removed">2455                     *(localeID + reslen) = uprv_toupper(*p);</span>
<span class="line-removed">2456                 } else {</span>
<span class="line-removed">2457                     *(localeID + reslen) = *p;</span>
<span class="line-removed">2458                 }</span>
<span class="line-removed">2459             }</span>
<span class="line-removed">2460             reslen++;</span>
<span class="line-removed">2461             p++;</span>
<span class="line-removed">2462         }</span>
2463     }
2464 
2465     /* region */
<a name="211" id="anc211"></a><span class="line-modified">2466     subtag = ultag_getRegion(lt);</span>
2467     len = (int32_t)uprv_strlen(subtag);
2468     if (len &gt; 0) {
<a name="212" id="anc212"></a><span class="line-modified">2469         if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2470             *(localeID + reslen) = LOCALE_SEP;</span>
<span class="line-modified">2471         }</span>
<span class="line-modified">2472         reslen++;</span>
<span class="line-removed">2473         /* write out the retion in upper case */</span>
2474         p = subtag;
2475         while (*p) {
<a name="213" id="anc213"></a><span class="line-modified">2476             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2477                 *(localeID + reslen) = uprv_toupper(*p);</span>
<span class="line-removed">2478             }</span>
<span class="line-removed">2479             reslen++;</span>
2480             p++;
2481         }
2482         noRegion = FALSE;
2483     }
2484 
2485     /* variants */
<a name="214" id="anc214"></a><span class="line-modified">2486     n = ultag_getVariantsSize(lt);</span>
2487     if (n &gt; 0) {
2488         if (noRegion) {
<a name="215" id="anc215"></a><span class="line-modified">2489             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2490                 *(localeID + reslen) = LOCALE_SEP;</span>
<span class="line-removed">2491             }</span>
<span class="line-removed">2492             reslen++;</span>
2493         }
2494 
2495         for (i = 0; i &lt; n; i++) {
<a name="216" id="anc216"></a><span class="line-modified">2496             subtag = ultag_getVariant(lt, i);</span>
<span class="line-modified">2497             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2498                 *(localeID + reslen) = LOCALE_SEP;</span>
<span class="line-removed">2499             }</span>
<span class="line-removed">2500             reslen++;</span>
2501             /* write out the variant in upper case */
2502             p = subtag;
2503             while (*p) {
<a name="217" id="anc217"></a><span class="line-modified">2504                 if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2505                     *(localeID + reslen) = uprv_toupper(*p);</span>
<span class="line-removed">2506                 }</span>
<span class="line-removed">2507                 reslen++;</span>
2508                 p++;
2509             }
2510         }
2511     }
2512 
2513     /* keywords */
<a name="218" id="anc218"></a><span class="line-modified">2514     n = ultag_getExtensionsSize(lt);</span>
<span class="line-modified">2515     subtag = ultag_getPrivateUse(lt);</span>
2516     if (n &gt; 0 || uprv_strlen(subtag) &gt; 0) {
<a name="219" id="anc219"></a><span class="line-modified">2517         if (reslen == 0 &amp;&amp; n &gt; 0) {</span>
2518             /* need a language */
<a name="220" id="anc220"></a><span class="line-modified">2519             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-removed">2520                 uprv_memcpy(localeID + reslen, LANG_UND, uprv_min(LANG_UND_LEN, localeIDCapacity - reslen));</span>
<span class="line-removed">2521             }</span>
<span class="line-removed">2522             reslen += LANG_UND_LEN;</span>
2523         }
<a name="221" id="anc221"></a><span class="line-modified">2524         len = _appendKeywords(lt, localeID + reslen, localeIDCapacity - reslen, status);</span>
<span class="line-removed">2525         reslen += len;</span>
2526     }
<a name="222" id="anc222"></a><span class="line-removed">2527 </span>
<span class="line-removed">2528     ultag_close(lt);</span>
<span class="line-removed">2529     return u_terminateChars(localeID, localeIDCapacity, reslen, status);</span>
2530 }
<a name="223" id="anc223"></a><span class="line-removed">2531 </span>
<span class="line-removed">2532 </span>
<a name="224" id="anc224"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="224" type="hidden" />
</body>
</html>