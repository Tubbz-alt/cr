<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ucnv_u8.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 2002-2016, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 **********************************************************************
  8 *   file name:  ucnv_u8.c
  9 *   encoding:   UTF-8
 10 *   tab size:   8 (not used)
 11 *   indentation:4
 12 *
 13 *   created on: 2002jul01
 14 *   created by: Markus W. Scherer
 15 *
 16 *   UTF-8 converter implementation. Used to be in ucnv_utf.c.
 17 *
 18 *   Also, CESU-8 implementation, see UTR 26.
 19 *   The CESU-8 converter uses all the same functions as the
 20 *   UTF-8 converter, with a branch for converting supplementary code points.
 21 */
 22 
 23 #include &quot;unicode/utypes.h&quot;
 24 
 25 #if !UCONFIG_NO_CONVERSION
 26 
 27 #include &quot;unicode/ucnv.h&quot;
 28 #include &quot;unicode/utf.h&quot;
 29 #include &quot;unicode/utf8.h&quot;
 30 #include &quot;unicode/utf16.h&quot;
 31 #include &quot;uassert.h&quot;
 32 #include &quot;ucnv_bld.h&quot;
 33 #include &quot;ucnv_cnv.h&quot;
 34 #include &quot;cmemory.h&quot;
 35 #include &quot;ustr_imp.h&quot;
 36 
 37 /* Prototypes --------------------------------------------------------------- */
 38 
 39 /* Keep these here to make finicky compilers happy */
 40 
 41 U_CFUNC void ucnv_fromUnicode_UTF8(UConverterFromUnicodeArgs *args,
 42                                            UErrorCode *err);
 43 U_CFUNC void ucnv_fromUnicode_UTF8_OFFSETS_LOGIC(UConverterFromUnicodeArgs *args,
 44                                                         UErrorCode *err);
 45 
 46 
 47 /* UTF-8 -------------------------------------------------------------------- */
 48 
 49 #define MAXIMUM_UCS2            0x0000FFFF
 50 
 51 static const uint32_t offsetsFromUTF8[5] = {0,
 52   (uint32_t) 0x00000000, (uint32_t) 0x00003080, (uint32_t) 0x000E2080,
 53   (uint32_t) 0x03C82080
 54 };
 55 
 56 static UBool hasCESU8Data(const UConverter *cnv)
 57 {
 58 #if UCONFIG_ONLY_HTML_CONVERSION
 59     (void) (cnv);
 60     return FALSE;
 61 #else
 62     return (UBool)(cnv-&gt;sharedData == &amp;_CESU8Data);
 63 #endif
 64 }
 65 U_CDECL_BEGIN
 66 static void  U_CALLCONV ucnv_toUnicode_UTF8 (UConverterToUnicodeArgs * args,
 67                                   UErrorCode * err)
 68 {
 69     UConverter *cnv = args-&gt;converter;
 70     const unsigned char *mySource = (unsigned char *) args-&gt;source;
 71     UChar *myTarget = args-&gt;target;
 72     const unsigned char *sourceLimit = (unsigned char *) args-&gt;sourceLimit;
 73     const UChar *targetLimit = args-&gt;targetLimit;
 74     unsigned char *toUBytes = cnv-&gt;toUBytes;
 75     UBool isCESU8 = hasCESU8Data(cnv);
 76     uint32_t ch, ch2 = 0;
 77     int32_t i, inBytes;
 78 
 79     /* Restore size of current sequence */
 80     if (cnv-&gt;toULength &gt; 0 &amp;&amp; myTarget &lt; targetLimit)
 81     {
 82         inBytes = cnv-&gt;mode;            /* restore # of bytes to consume */
 83         i = cnv-&gt;toULength;             /* restore # of bytes consumed */
 84         cnv-&gt;toULength = 0;
 85 
 86         ch = cnv-&gt;toUnicodeStatus;/*Stores the previously calculated ch from a previous call*/
 87         cnv-&gt;toUnicodeStatus = 0;
 88         goto morebytes;
 89     }
 90 
 91 
 92     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
 93     {
 94         ch = *(mySource++);
 95         if (U8_IS_SINGLE(ch))        /* Simple case */
 96         {
 97             *(myTarget++) = (UChar) ch;
 98         }
 99         else
100         {
101             /* store the first char */
102             toUBytes[0] = (char)ch;
103             inBytes = U8_COUNT_BYTES_NON_ASCII(ch); /* lookup current sequence length */
104             i = 1;
105 
106 morebytes:
107             while (i &lt; inBytes)
108             {
109                 if (mySource &lt; sourceLimit)
110                 {
111                     toUBytes[i] = (char) (ch2 = *mySource);
112                     if (!icu::UTF8::isValidTrail(ch, ch2, i, inBytes) &amp;&amp;
113                             !(isCESU8 &amp;&amp; i == 1 &amp;&amp; ch == 0xed &amp;&amp; U8_IS_TRAIL(ch2)))
114                     {
115                         break; /* i &lt; inBytes */
116                     }
117                     ch = (ch &lt;&lt; 6) + ch2;
118                     ++mySource;
119                     i++;
120                 }
121                 else
122                 {
123                     /* stores a partially calculated target*/
124                     cnv-&gt;toUnicodeStatus = ch;
125                     cnv-&gt;mode = inBytes;
126                     cnv-&gt;toULength = (int8_t) i;
127                     goto donefornow;
128                 }
129             }
130 
131             // In CESU-8, only surrogates, not supplementary code points, are encoded directly.
132             if (i == inBytes &amp;&amp; (!isCESU8 || i &lt;= 3))
133             {
134                 /* Remove the accumulated high bits */
135                 ch -= offsetsFromUTF8[inBytes];
136 
137                 /* Normal valid byte when the loop has not prematurely terminated (i &lt; inBytes) */
138                 if (ch &lt;= MAXIMUM_UCS2)
139                 {
140                     /* fits in 16 bits */
141                     *(myTarget++) = (UChar) ch;
142                 }
143                 else
144                 {
145                     /* write out the surrogates */
146                     *(myTarget++) = U16_LEAD(ch);
147                     ch = U16_TRAIL(ch);
148                     if (myTarget &lt; targetLimit)
149                     {
150                         *(myTarget++) = (UChar)ch;
151                     }
152                     else
153                     {
154                         /* Put in overflow buffer (not handled here) */
155                         cnv-&gt;UCharErrorBuffer[0] = (UChar) ch;
156                         cnv-&gt;UCharErrorBufferLength = 1;
157                         *err = U_BUFFER_OVERFLOW_ERROR;
158                         break;
159                     }
160                 }
161             }
162             else
163             {
164                 cnv-&gt;toULength = (int8_t)i;
165                 *err = U_ILLEGAL_CHAR_FOUND;
166                 break;
167             }
168         }
169     }
170 
171 donefornow:
172     if (mySource &lt; sourceLimit &amp;&amp; myTarget &gt;= targetLimit &amp;&amp; U_SUCCESS(*err))
173     {
174         /* End of target buffer */
175         *err = U_BUFFER_OVERFLOW_ERROR;
176     }
177 
178     args-&gt;target = myTarget;
179     args-&gt;source = (const char *) mySource;
180 }
181 
182 static void  U_CALLCONV ucnv_toUnicode_UTF8_OFFSETS_LOGIC (UConverterToUnicodeArgs * args,
183                                                 UErrorCode * err)
184 {
185     UConverter *cnv = args-&gt;converter;
186     const unsigned char *mySource = (unsigned char *) args-&gt;source;
187     UChar *myTarget = args-&gt;target;
188     int32_t *myOffsets = args-&gt;offsets;
189     int32_t offsetNum = 0;
190     const unsigned char *sourceLimit = (unsigned char *) args-&gt;sourceLimit;
191     const UChar *targetLimit = args-&gt;targetLimit;
192     unsigned char *toUBytes = cnv-&gt;toUBytes;
193     UBool isCESU8 = hasCESU8Data(cnv);
194     uint32_t ch, ch2 = 0;
195     int32_t i, inBytes;
196 
197     /* Restore size of current sequence */
198     if (cnv-&gt;toULength &gt; 0 &amp;&amp; myTarget &lt; targetLimit)
199     {
200         inBytes = cnv-&gt;mode;            /* restore # of bytes to consume */
201         i = cnv-&gt;toULength;             /* restore # of bytes consumed */
202         cnv-&gt;toULength = 0;
203 
204         ch = cnv-&gt;toUnicodeStatus;/*Stores the previously calculated ch from a previous call*/
205         cnv-&gt;toUnicodeStatus = 0;
206         goto morebytes;
207     }
208 
209     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
210     {
211         ch = *(mySource++);
212         if (U8_IS_SINGLE(ch))        /* Simple case */
213         {
214             *(myTarget++) = (UChar) ch;
215             *(myOffsets++) = offsetNum++;
216         }
217         else
218         {
219             toUBytes[0] = (char)ch;
220             inBytes = U8_COUNT_BYTES_NON_ASCII(ch);
221             i = 1;
222 
223 morebytes:
224             while (i &lt; inBytes)
225             {
226                 if (mySource &lt; sourceLimit)
227                 {
228                     toUBytes[i] = (char) (ch2 = *mySource);
229                     if (!icu::UTF8::isValidTrail(ch, ch2, i, inBytes) &amp;&amp;
230                             !(isCESU8 &amp;&amp; i == 1 &amp;&amp; ch == 0xed &amp;&amp; U8_IS_TRAIL(ch2)))
231                     {
232                         break; /* i &lt; inBytes */
233                     }
234                     ch = (ch &lt;&lt; 6) + ch2;
235                     ++mySource;
236                     i++;
237                 }
238                 else
239                 {
240                     cnv-&gt;toUnicodeStatus = ch;
241                     cnv-&gt;mode = inBytes;
242                     cnv-&gt;toULength = (int8_t)i;
243                     goto donefornow;
244                 }
245             }
246 
247             // In CESU-8, only surrogates, not supplementary code points, are encoded directly.
248             if (i == inBytes &amp;&amp; (!isCESU8 || i &lt;= 3))
249             {
250                 /* Remove the accumulated high bits */
251                 ch -= offsetsFromUTF8[inBytes];
252 
253                 /* Normal valid byte when the loop has not prematurely terminated (i &lt; inBytes) */
254                 if (ch &lt;= MAXIMUM_UCS2)
255                 {
256                     /* fits in 16 bits */
257                     *(myTarget++) = (UChar) ch;
258                     *(myOffsets++) = offsetNum;
259                 }
260                 else
261                 {
262                     /* write out the surrogates */
263                     *(myTarget++) = U16_LEAD(ch);
264                     *(myOffsets++) = offsetNum;
265                     ch = U16_TRAIL(ch);
266                     if (myTarget &lt; targetLimit)
267                     {
268                         *(myTarget++) = (UChar)ch;
269                         *(myOffsets++) = offsetNum;
270                     }
271                     else
272                     {
273                         cnv-&gt;UCharErrorBuffer[0] = (UChar) ch;
274                         cnv-&gt;UCharErrorBufferLength = 1;
275                         *err = U_BUFFER_OVERFLOW_ERROR;
276                     }
277                 }
278                 offsetNum += i;
279             }
280             else
281             {
282                 cnv-&gt;toULength = (int8_t)i;
283                 *err = U_ILLEGAL_CHAR_FOUND;
284                 break;
285             }
286         }
287     }
288 
289 donefornow:
290     if (mySource &lt; sourceLimit &amp;&amp; myTarget &gt;= targetLimit &amp;&amp; U_SUCCESS(*err))
291     {   /* End of target buffer */
292         *err = U_BUFFER_OVERFLOW_ERROR;
293     }
294 
295     args-&gt;target = myTarget;
296     args-&gt;source = (const char *) mySource;
297     args-&gt;offsets = myOffsets;
298 }
299 U_CDECL_END
300 
301 U_CFUNC void  U_CALLCONV ucnv_fromUnicode_UTF8 (UConverterFromUnicodeArgs * args,
302                                     UErrorCode * err)
303 {
304     UConverter *cnv = args-&gt;converter;
305     const UChar *mySource = args-&gt;source;
306     const UChar *sourceLimit = args-&gt;sourceLimit;
307     uint8_t *myTarget = (uint8_t *) args-&gt;target;
308     const uint8_t *targetLimit = (uint8_t *) args-&gt;targetLimit;
309     uint8_t *tempPtr;
310     UChar32 ch;
311     uint8_t tempBuf[4];
312     int32_t indexToWrite;
313     UBool isNotCESU8 = !hasCESU8Data(cnv);
314 
315     if (cnv-&gt;fromUChar32 &amp;&amp; myTarget &lt; targetLimit)
316     {
317         ch = cnv-&gt;fromUChar32;
318         cnv-&gt;fromUChar32 = 0;
319         goto lowsurrogate;
320     }
321 
322     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
323     {
324         ch = *(mySource++);
325 
326         if (ch &lt; 0x80)        /* Single byte */
327         {
328             *(myTarget++) = (uint8_t) ch;
329         }
330         else if (ch &lt; 0x800)  /* Double byte */
331         {
332             *(myTarget++) = (uint8_t) ((ch &gt;&gt; 6) | 0xc0);
333             if (myTarget &lt; targetLimit)
334             {
335                 *(myTarget++) = (uint8_t) ((ch &amp; 0x3f) | 0x80);
336             }
337             else
338             {
339                 cnv-&gt;charErrorBuffer[0] = (uint8_t) ((ch &amp; 0x3f) | 0x80);
340                 cnv-&gt;charErrorBufferLength = 1;
341                 *err = U_BUFFER_OVERFLOW_ERROR;
342             }
343         }
344         else {
345             /* Check for surrogates */
346             if(U16_IS_SURROGATE(ch) &amp;&amp; isNotCESU8) {
347 lowsurrogate:
348                 if (mySource &lt; sourceLimit) {
349                     /* test both code units */
350                     if(U16_IS_SURROGATE_LEAD(ch) &amp;&amp; U16_IS_TRAIL(*mySource)) {
351                         /* convert and consume this supplementary code point */
352                         ch=U16_GET_SUPPLEMENTARY(ch, *mySource);
353                         ++mySource;
354                         /* exit this condition tree */
355                     }
356                     else {
357                         /* this is an unpaired trail or lead code unit */
358                         /* callback(illegal) */
359                         cnv-&gt;fromUChar32 = ch;
360                         *err = U_ILLEGAL_CHAR_FOUND;
361                         break;
362                     }
363                 }
364                 else {
365                     /* no more input */
366                     cnv-&gt;fromUChar32 = ch;
367                     break;
368                 }
369             }
370 
371             /* Do we write the buffer directly for speed,
372             or do we have to be careful about target buffer space? */
373             tempPtr = (((targetLimit - myTarget) &gt;= 4) ? myTarget : tempBuf);
374 
375             if (ch &lt;= MAXIMUM_UCS2) {
376                 indexToWrite = 2;
377                 tempPtr[0] = (uint8_t) ((ch &gt;&gt; 12) | 0xe0);
378             }
379             else {
380                 indexToWrite = 3;
381                 tempPtr[0] = (uint8_t) ((ch &gt;&gt; 18) | 0xf0);
382                 tempPtr[1] = (uint8_t) (((ch &gt;&gt; 12) &amp; 0x3f) | 0x80);
383             }
384             tempPtr[indexToWrite-1] = (uint8_t) (((ch &gt;&gt; 6) &amp; 0x3f) | 0x80);
385             tempPtr[indexToWrite] = (uint8_t) ((ch &amp; 0x3f) | 0x80);
386 
387             if (tempPtr == myTarget) {
388                 /* There was enough space to write the codepoint directly. */
389                 myTarget += (indexToWrite + 1);
390             }
391             else {
392                 /* We might run out of room soon. Write it slowly. */
393                 for (; tempPtr &lt;= (tempBuf + indexToWrite); tempPtr++) {
394                     if (myTarget &lt; targetLimit) {
395                         *(myTarget++) = *tempPtr;
396                     }
397                     else {
398                         cnv-&gt;charErrorBuffer[cnv-&gt;charErrorBufferLength++] = *tempPtr;
399                         *err = U_BUFFER_OVERFLOW_ERROR;
400                     }
401                 }
402             }
403         }
404     }
405 
406     if (mySource &lt; sourceLimit &amp;&amp; myTarget &gt;= targetLimit &amp;&amp; U_SUCCESS(*err))
407     {
408         *err = U_BUFFER_OVERFLOW_ERROR;
409     }
410 
411     args-&gt;target = (char *) myTarget;
412     args-&gt;source = mySource;
413 }
414 
415 U_CFUNC void  U_CALLCONV ucnv_fromUnicode_UTF8_OFFSETS_LOGIC (UConverterFromUnicodeArgs * args,
416                                                   UErrorCode * err)
417 {
418     UConverter *cnv = args-&gt;converter;
419     const UChar *mySource = args-&gt;source;
420     int32_t *myOffsets = args-&gt;offsets;
421     const UChar *sourceLimit = args-&gt;sourceLimit;
422     uint8_t *myTarget = (uint8_t *) args-&gt;target;
423     const uint8_t *targetLimit = (uint8_t *) args-&gt;targetLimit;
424     uint8_t *tempPtr;
425     UChar32 ch;
426     int32_t offsetNum, nextSourceIndex;
427     int32_t indexToWrite;
428     uint8_t tempBuf[4];
429     UBool isNotCESU8 = !hasCESU8Data(cnv);
430 
431     if (cnv-&gt;fromUChar32 &amp;&amp; myTarget &lt; targetLimit)
432     {
433         ch = cnv-&gt;fromUChar32;
434         cnv-&gt;fromUChar32 = 0;
435         offsetNum = -1;
436         nextSourceIndex = 0;
437         goto lowsurrogate;
438     } else {
439         offsetNum = 0;
440     }
441 
442     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
443     {
444         ch = *(mySource++);
445 
446         if (ch &lt; 0x80)        /* Single byte */
447         {
448             *(myOffsets++) = offsetNum++;
449             *(myTarget++) = (char) ch;
450         }
451         else if (ch &lt; 0x800)  /* Double byte */
452         {
453             *(myOffsets++) = offsetNum;
454             *(myTarget++) = (uint8_t) ((ch &gt;&gt; 6) | 0xc0);
455             if (myTarget &lt; targetLimit)
456             {
457                 *(myOffsets++) = offsetNum++;
458                 *(myTarget++) = (uint8_t) ((ch &amp; 0x3f) | 0x80);
459             }
460             else
461             {
462                 cnv-&gt;charErrorBuffer[0] = (uint8_t) ((ch &amp; 0x3f) | 0x80);
463                 cnv-&gt;charErrorBufferLength = 1;
464                 *err = U_BUFFER_OVERFLOW_ERROR;
465             }
466         }
467         else
468         /* Check for surrogates */
469         {
470             nextSourceIndex = offsetNum + 1;
471 
472             if(U16_IS_SURROGATE(ch) &amp;&amp; isNotCESU8) {
473 lowsurrogate:
474                 if (mySource &lt; sourceLimit) {
475                     /* test both code units */
476                     if(U16_IS_SURROGATE_LEAD(ch) &amp;&amp; U16_IS_TRAIL(*mySource)) {
477                         /* convert and consume this supplementary code point */
478                         ch=U16_GET_SUPPLEMENTARY(ch, *mySource);
479                         ++mySource;
480                         ++nextSourceIndex;
481                         /* exit this condition tree */
482                     }
483                     else {
484                         /* this is an unpaired trail or lead code unit */
485                         /* callback(illegal) */
486                         cnv-&gt;fromUChar32 = ch;
487                         *err = U_ILLEGAL_CHAR_FOUND;
488                         break;
489                     }
490                 }
491                 else {
492                     /* no more input */
493                     cnv-&gt;fromUChar32 = ch;
494                     break;
495                 }
496             }
497 
498             /* Do we write the buffer directly for speed,
499             or do we have to be careful about target buffer space? */
500             tempPtr = (((targetLimit - myTarget) &gt;= 4) ? myTarget : tempBuf);
501 
502             if (ch &lt;= MAXIMUM_UCS2) {
503                 indexToWrite = 2;
504                 tempPtr[0] = (uint8_t) ((ch &gt;&gt; 12) | 0xe0);
505             }
506             else {
507                 indexToWrite = 3;
508                 tempPtr[0] = (uint8_t) ((ch &gt;&gt; 18) | 0xf0);
509                 tempPtr[1] = (uint8_t) (((ch &gt;&gt; 12) &amp; 0x3f) | 0x80);
510             }
511             tempPtr[indexToWrite-1] = (uint8_t) (((ch &gt;&gt; 6) &amp; 0x3f) | 0x80);
512             tempPtr[indexToWrite] = (uint8_t) ((ch &amp; 0x3f) | 0x80);
513 
514             if (tempPtr == myTarget) {
515                 /* There was enough space to write the codepoint directly. */
516                 myTarget += (indexToWrite + 1);
517                 myOffsets[0] = offsetNum;
518                 myOffsets[1] = offsetNum;
519                 myOffsets[2] = offsetNum;
520                 if (indexToWrite &gt;= 3) {
521                     myOffsets[3] = offsetNum;
522                 }
523                 myOffsets += (indexToWrite + 1);
524             }
525             else {
526                 /* We might run out of room soon. Write it slowly. */
527                 for (; tempPtr &lt;= (tempBuf + indexToWrite); tempPtr++) {
528                     if (myTarget &lt; targetLimit)
529                     {
530                         *(myOffsets++) = offsetNum;
531                         *(myTarget++) = *tempPtr;
532                     }
533                     else
534                     {
535                         cnv-&gt;charErrorBuffer[cnv-&gt;charErrorBufferLength++] = *tempPtr;
536                         *err = U_BUFFER_OVERFLOW_ERROR;
537                     }
538                 }
539             }
540             offsetNum = nextSourceIndex;
541         }
542     }
543 
544     if (mySource &lt; sourceLimit &amp;&amp; myTarget &gt;= targetLimit &amp;&amp; U_SUCCESS(*err))
545     {
546         *err = U_BUFFER_OVERFLOW_ERROR;
547     }
548 
549     args-&gt;target = (char *) myTarget;
550     args-&gt;source = mySource;
551     args-&gt;offsets = myOffsets;
552 }
553 
554 U_CDECL_BEGIN
555 static UChar32 U_CALLCONV ucnv_getNextUChar_UTF8(UConverterToUnicodeArgs *args,
556                                                UErrorCode *err) {
557     UConverter *cnv;
558     const uint8_t *sourceInitial;
559     const uint8_t *source;
560     uint8_t myByte;
561     UChar32 ch;
562     int8_t i;
563 
564     /* UTF-8 only here, the framework handles CESU-8 to combine surrogate pairs */
565 
566     cnv = args-&gt;converter;
567     sourceInitial = source = (const uint8_t *)args-&gt;source;
568     if (source &gt;= (const uint8_t *)args-&gt;sourceLimit)
569     {
570         /* no input */
571         *err = U_INDEX_OUTOFBOUNDS_ERROR;
572         return 0xffff;
573     }
574 
575     myByte = (uint8_t)*(source++);
576     if (U8_IS_SINGLE(myByte))
577     {
578         args-&gt;source = (const char *)source;
579         return (UChar32)myByte;
580     }
581 
582     uint16_t countTrailBytes = U8_COUNT_TRAIL_BYTES(myByte);
583     if (countTrailBytes == 0) {
584         cnv-&gt;toUBytes[0] = myByte;
585         cnv-&gt;toULength = 1;
586         *err = U_ILLEGAL_CHAR_FOUND;
587         args-&gt;source = (const char *)source;
588         return 0xffff;
589     }
590 
591     /*The byte sequence is longer than the buffer area passed*/
592     if (((const char *)source + countTrailBytes) &gt; args-&gt;sourceLimit)
593     {
594         /* check if all of the remaining bytes are trail bytes */
595         uint16_t extraBytesToWrite = countTrailBytes + 1;
596         cnv-&gt;toUBytes[0] = myByte;
597         i = 1;
598         *err = U_TRUNCATED_CHAR_FOUND;
599         while(source &lt; (const uint8_t *)args-&gt;sourceLimit) {
600             uint8_t b = *source;
601             if(icu::UTF8::isValidTrail(myByte, b, i, extraBytesToWrite)) {
602                 cnv-&gt;toUBytes[i++] = b;
603                 ++source;
604             } else {
605                 /* error even before we run out of input */
606                 *err = U_ILLEGAL_CHAR_FOUND;
607                 break;
608             }
609         }
610         cnv-&gt;toULength = i;
611         args-&gt;source = (const char *)source;
612         return 0xffff;
613     }
614 
615     ch = myByte &lt;&lt; 6;
616     if(countTrailBytes == 2) {
617         uint8_t t1 = *source, t2;
618         if(U8_IS_VALID_LEAD3_AND_T1(myByte, t1) &amp;&amp; U8_IS_TRAIL(t2 = *++source)) {
619             args-&gt;source = (const char *)(source + 1);
620             return (((ch + t1) &lt;&lt; 6) + t2) - offsetsFromUTF8[3];
621         }
622     } else if(countTrailBytes == 1) {
623         uint8_t t1 = *source;
624         if(U8_IS_TRAIL(t1)) {
625             args-&gt;source = (const char *)(source + 1);
626             return (ch + t1) - offsetsFromUTF8[2];
627         }
628     } else {  // countTrailBytes == 3
629         uint8_t t1 = *source, t2, t3;
630         if(U8_IS_VALID_LEAD4_AND_T1(myByte, t1) &amp;&amp; U8_IS_TRAIL(t2 = *++source) &amp;&amp;
631                 U8_IS_TRAIL(t3 = *++source)) {
632             args-&gt;source = (const char *)(source + 1);
633             return (((((ch + t1) &lt;&lt; 6) + t2) &lt;&lt; 6) + t3) - offsetsFromUTF8[4];
634         }
635     }
636     args-&gt;source = (const char *)source;
637 
638     for(i = 0; sourceInitial &lt; source; ++i) {
639         cnv-&gt;toUBytes[i] = *sourceInitial++;
640     }
641     cnv-&gt;toULength = i;
642     *err = U_ILLEGAL_CHAR_FOUND;
643     return 0xffff;
644 }
645 U_CDECL_END
646 
647 /* UTF-8-from-UTF-8 conversion functions ------------------------------------ */
648 
649 U_CDECL_BEGIN
650 /* &quot;Convert&quot; UTF-8 to UTF-8: Validate and copy. Modified from ucnv_DBCSFromUTF8(). */
651 static void U_CALLCONV
652 ucnv_UTF8FromUTF8(UConverterFromUnicodeArgs *pFromUArgs,
653                   UConverterToUnicodeArgs *pToUArgs,
654                   UErrorCode *pErrorCode) {
655     UConverter *utf8;
656     const uint8_t *source, *sourceLimit;
657     uint8_t *target;
658     int32_t targetCapacity;
659     int32_t count;
660 
661     int8_t oldToULength, toULength, toULimit;
662 
663     UChar32 c;
664     uint8_t b, t1, t2;
665 
666     /* set up the local pointers */
667     utf8=pToUArgs-&gt;converter;
668     source=(uint8_t *)pToUArgs-&gt;source;
669     sourceLimit=(uint8_t *)pToUArgs-&gt;sourceLimit;
670     target=(uint8_t *)pFromUArgs-&gt;target;
671     targetCapacity=(int32_t)(pFromUArgs-&gt;targetLimit-pFromUArgs-&gt;target);
672 
673     /* get the converter state from the UTF-8 UConverter */
674     if(utf8-&gt;toULength &gt; 0) {
675         toULength=oldToULength=utf8-&gt;toULength;
676         toULimit=(int8_t)utf8-&gt;mode;
677         c=(UChar32)utf8-&gt;toUnicodeStatus;
678     } else {
679         toULength=oldToULength=toULimit=0;
680         c = 0;
681     }
682 
683     count=(int32_t)(sourceLimit-source)+oldToULength;
684     if(count&lt;toULimit) {
685         /*
686          * Not enough input to complete the partial character.
687          * Jump to moreBytes below - it will not output to target.
688          */
689     } else if(targetCapacity&lt;toULimit) {
690         /*
691          * Not enough target capacity to output the partial character.
692          * Let the standard converter handle this.
693          */
694         *pErrorCode=U_USING_DEFAULT_WARNING;
695         return;
696     } else {
697         // Use a single counter for source and target, counting the minimum of
698         // the source length and the target capacity.
699         // Let the standard converter handle edge cases.
700         if(count&gt;targetCapacity) {
701             count=targetCapacity;
702         }
703 
704         // The conversion loop checks count&gt;0 only once per character.
705         // If the buffer ends with a truncated sequence,
706         // then we reduce the count to stop before that,
707         // and collect the remaining bytes after the conversion loop.
708 
709         // Do not go back into the bytes that will be read for finishing a partial
710         // sequence from the previous buffer.
711         int32_t length=count-toULimit;
712         U8_TRUNCATE_IF_INCOMPLETE(source, 0, length);
713         count=toULimit+length;
714     }
715 
716     if(c!=0) {
717         utf8-&gt;toUnicodeStatus=0;
718         utf8-&gt;toULength=0;
719         goto moreBytes;
720         /* See note in ucnv_SBCSFromUTF8() about this goto. */
721     }
722 
723     /* conversion loop */
724     while(count&gt;0) {
725         b=*source++;
726         if(U8_IS_SINGLE(b)) {
727             /* convert ASCII */
728             *target++=b;
729             --count;
730             continue;
731         } else {
732             if(b&gt;=0xe0) {
733                 if( /* handle U+0800..U+FFFF inline */
734                     b&lt;0xf0 &amp;&amp;
735                     U8_IS_VALID_LEAD3_AND_T1(b, t1=source[0]) &amp;&amp;
736                     U8_IS_TRAIL(t2=source[1])
737                 ) {
738                     source+=2;
739                     *target++=b;
740                     *target++=t1;
741                     *target++=t2;
742                     count-=3;
743                     continue;
744                 }
745             } else {
746                 if( /* handle U+0080..U+07FF inline */
747                     b&gt;=0xc2 &amp;&amp;
748                     U8_IS_TRAIL(t1=*source)
749                 ) {
750                     ++source;
751                     *target++=b;
752                     *target++=t1;
753                     count-=2;
754                     continue;
755                 }
756             }
757 
758             /* handle &quot;complicated&quot; and error cases, and continuing partial characters */
759             oldToULength=0;
760             toULength=1;
761             toULimit=U8_COUNT_BYTES_NON_ASCII(b);
762             c=b;
763 moreBytes:
764             while(toULength&lt;toULimit) {
765                 if(source&lt;sourceLimit) {
766                     b=*source;
767                     if(icu::UTF8::isValidTrail(c, b, toULength, toULimit)) {
768                         ++source;
769                         ++toULength;
770                         c=(c&lt;&lt;6)+b;
771                     } else {
772                         break; /* sequence too short, stop with toULength&lt;toULimit */
773                     }
774                 } else {
775                     /* store the partial UTF-8 character, compatible with the regular UTF-8 converter */
776                     source-=(toULength-oldToULength);
777                     while(oldToULength&lt;toULength) {
778                         utf8-&gt;toUBytes[oldToULength++]=*source++;
779                     }
780                     utf8-&gt;toUnicodeStatus=c;
781                     utf8-&gt;toULength=toULength;
782                     utf8-&gt;mode=toULimit;
783                     pToUArgs-&gt;source=(char *)source;
784                     pFromUArgs-&gt;target=(char *)target;
785                     return;
786                 }
787             }
788 
789             if(toULength!=toULimit) {
790                 /* error handling: illegal UTF-8 byte sequence */
791                 source-=(toULength-oldToULength);
792                 while(oldToULength&lt;toULength) {
793                     utf8-&gt;toUBytes[oldToULength++]=*source++;
794                 }
795                 utf8-&gt;toULength=toULength;
796                 pToUArgs-&gt;source=(char *)source;
797                 pFromUArgs-&gt;target=(char *)target;
798                 *pErrorCode=U_ILLEGAL_CHAR_FOUND;
799                 return;
800             }
801 
802             /* copy the legal byte sequence to the target */
803             {
804                 int8_t i;
805 
806                 for(i=0; i&lt;oldToULength; ++i) {
807                     *target++=utf8-&gt;toUBytes[i];
808                 }
809                 source-=(toULength-oldToULength);
810                 for(; i&lt;toULength; ++i) {
811                     *target++=*source++;
812                 }
813                 count-=toULength;
814             }
815         }
816     }
817     U_ASSERT(count&gt;=0);
818 
819     if(U_SUCCESS(*pErrorCode) &amp;&amp; source&lt;sourceLimit) {
820         if(target==(const uint8_t *)pFromUArgs-&gt;targetLimit) {
821             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
822         } else {
823             b=*source;
824             toULimit=U8_COUNT_BYTES(b);
825             if(toULimit&gt;(sourceLimit-source)) {
826                 /* collect a truncated byte sequence */
827                 toULength=0;
828                 c=b;
829                 for(;;) {
830                     utf8-&gt;toUBytes[toULength++]=b;
831                     if(++source==sourceLimit) {
832                         /* partial byte sequence at end of source */
833                         utf8-&gt;toUnicodeStatus=c;
834                         utf8-&gt;toULength=toULength;
835                         utf8-&gt;mode=toULimit;
836                         break;
837                     } else if(!icu::UTF8::isValidTrail(c, b=*source, toULength, toULimit)) {
838                         utf8-&gt;toULength=toULength;
839                         *pErrorCode=U_ILLEGAL_CHAR_FOUND;
840                         break;
841                     }
842                     c=(c&lt;&lt;6)+b;
843                 }
844             } else {
845                 /* partial-sequence target overflow: fall back to the pivoting implementation */
846                 *pErrorCode=U_USING_DEFAULT_WARNING;
847             }
848         }
849     }
850 
851     /* write back the updated pointers */
852     pToUArgs-&gt;source=(char *)source;
853     pFromUArgs-&gt;target=(char *)target;
854 }
855 
856 U_CDECL_END
857 
858 /* UTF-8 converter data ----------------------------------------------------- */
859 
860 static const UConverterImpl _UTF8Impl={
861     UCNV_UTF8,
862 
863     NULL,
864     NULL,
865 
866     NULL,
867     NULL,
868     NULL,
869 
870     ucnv_toUnicode_UTF8,
871     ucnv_toUnicode_UTF8_OFFSETS_LOGIC,
872     ucnv_fromUnicode_UTF8,
873     ucnv_fromUnicode_UTF8_OFFSETS_LOGIC,
874     ucnv_getNextUChar_UTF8,
875 
876     NULL,
877     NULL,
878     NULL,
879     NULL,
880     ucnv_getNonSurrogateUnicodeSet,
881 
882     ucnv_UTF8FromUTF8,
883     ucnv_UTF8FromUTF8
884 };
885 
886 /* The 1208 CCSID refers to any version of Unicode of UTF-8 */
887 static const UConverterStaticData _UTF8StaticData={
888     sizeof(UConverterStaticData),
889     &quot;UTF-8&quot;,
890     1208, UCNV_IBM, UCNV_UTF8,
891     1, 3, /* max 3 bytes per UChar from UTF-8 (4 bytes from surrogate _pair_) */
892     { 0xef, 0xbf, 0xbd, 0 },3,FALSE,FALSE,
893     0,
894     0,
895     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
896 };
897 
898 
899 const UConverterSharedData _UTF8Data=
900         UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(&amp;_UTF8StaticData, &amp;_UTF8Impl);
901 
902 /* CESU-8 converter data ---------------------------------------------------- */
903 
904 static const UConverterImpl _CESU8Impl={
905     UCNV_CESU8,
906 
907     NULL,
908     NULL,
909 
910     NULL,
911     NULL,
912     NULL,
913 
914     ucnv_toUnicode_UTF8,
915     ucnv_toUnicode_UTF8_OFFSETS_LOGIC,
916     ucnv_fromUnicode_UTF8,
917     ucnv_fromUnicode_UTF8_OFFSETS_LOGIC,
918     NULL,
919 
920     NULL,
921     NULL,
922     NULL,
923     NULL,
924     ucnv_getCompleteUnicodeSet,
925 
926     NULL,
927     NULL
928 };
929 
930 static const UConverterStaticData _CESU8StaticData={
931     sizeof(UConverterStaticData),
932     &quot;CESU-8&quot;,
933     9400, /* CCSID for CESU-8 */
934     UCNV_UNKNOWN, UCNV_CESU8, 1, 3,
935     { 0xef, 0xbf, 0xbd, 0 },3,FALSE,FALSE,
936     0,
937     0,
938     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
939 };
940 
941 
942 const UConverterSharedData _CESU8Data=
943         UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(&amp;_CESU8StaticData, &amp;_CESU8Impl);
944 
945 #endif
    </pre>
  </body>
</html>