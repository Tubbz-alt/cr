<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_formatimpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_fluent.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_formatimpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_formatimpl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 50         ures_getSize(bundle.getAlias()) &gt; 2) { // the length is 3 if more data is present
 51         ures_getByIndex(bundle.getAlias(), 2, bundle.getAlias(), &amp;localStatus);
 52         int32_t dummy;
 53         result.exists = true;
 54         result.pattern = ures_getStringByIndex(bundle.getAlias(), 0, &amp;dummy, &amp;localStatus);
 55         result.decimalSeparator = ures_getStringByIndex(bundle.getAlias(), 1, &amp;dummy, &amp;localStatus);
 56         result.groupingSeparator = ures_getStringByIndex(bundle.getAlias(), 2, &amp;dummy, &amp;localStatus);
 57         status = localStatus;
 58     } else if (localStatus != U_MISSING_RESOURCE_ERROR) {
 59         status = localStatus;
 60     }
 61     return result;
 62 }
 63 
 64 }  // namespace
 65 
 66 
 67 MicroPropsGenerator::~MicroPropsGenerator() = default;
 68 
 69 
<span class="line-modified"> 70 NumberFormatterImpl* NumberFormatterImpl::fromMacros(const MacroProps&amp; macros, UErrorCode&amp; status) {</span>
<span class="line-modified"> 71     return new NumberFormatterImpl(macros, true, status);</span>
 72 }
 73 
<span class="line-modified"> 74 void NumberFormatterImpl::applyStatic(const MacroProps&amp; macros, DecimalQuantity&amp; inValue,</span>
<span class="line-modified"> 75                                       NumberStringBuilder&amp; outString, UErrorCode&amp; status) {</span>
 76     NumberFormatterImpl impl(macros, false, status);
<span class="line-modified"> 77     impl.applyUnsafe(inValue, outString, status);</span>




 78 }
 79 
 80 int32_t NumberFormatterImpl::getPrefixSuffixStatic(const MacroProps&amp; macros, int8_t signum,
 81                                                    StandardPlural::Form plural,
 82                                                    NumberStringBuilder&amp; outString, UErrorCode&amp; status) {
 83     NumberFormatterImpl impl(macros, false, status);
 84     return impl.getPrefixSuffixUnsafe(signum, plural, outString, status);
 85 }
 86 
 87 // NOTE: C++ SPECIFIC DIFFERENCE FROM JAVA:
 88 // The &quot;safe&quot; apply method uses a new MicroProps. In the MicroPropsGenerator, fMicros is copied into the new instance.
 89 // The &quot;unsafe&quot; method simply re-uses fMicros, eliminating the extra copy operation.
 90 // See MicroProps::processQuantity() for details.
 91 
<span class="line-modified"> 92 void NumberFormatterImpl::apply(DecimalQuantity&amp; inValue, NumberStringBuilder&amp; outString,</span>
 93                                 UErrorCode&amp; status) const {
<span class="line-removed"> 94     if (U_FAILURE(status)) { return; }</span>
 95     MicroProps micros;
<span class="line-modified"> 96     if (!fMicroPropsGenerator) { return; }</span>
<span class="line-modified"> 97     fMicroPropsGenerator-&gt;processQuantity(inValue, micros, status);</span>
<span class="line-modified"> 98     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified"> 99     microsToString(micros, inValue, outString, status);</span>

100 }
101 
<span class="line-modified">102 void NumberFormatterImpl::applyUnsafe(DecimalQuantity&amp; inValue, NumberStringBuilder&amp; outString,</span>
<span class="line-modified">103                                       UErrorCode&amp; status) {</span>
104     if (U_FAILURE(status)) { return; }

















105     fMicroPropsGenerator-&gt;processQuantity(inValue, fMicros, status);
<span class="line-modified">106     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">107     microsToString(fMicros, inValue, outString, status);</span>

108 }
109 
110 int32_t NumberFormatterImpl::getPrefixSuffix(int8_t signum, StandardPlural::Form plural,
111                                              NumberStringBuilder&amp; outString, UErrorCode&amp; status) const {
112     if (U_FAILURE(status)) { return 0; }
113     // #13453: DecimalFormat wants the affixes from the pattern only (modMiddle, aka pattern modifier).
114     // Safe path: use fImmutablePatternModifier.
115     const Modifier* modifier = fImmutablePatternModifier-&gt;getModifier(signum, plural);
116     modifier-&gt;apply(outString, 0, 0, status);
117     if (U_FAILURE(status)) { return 0; }
<span class="line-modified">118     return modifier-&gt;getPrefixLength(status);</span>
119 }
120 
121 int32_t NumberFormatterImpl::getPrefixSuffixUnsafe(int8_t signum, StandardPlural::Form plural,
122                                                    NumberStringBuilder&amp; outString, UErrorCode&amp; status) {
123     if (U_FAILURE(status)) { return 0; }
124     // #13453: DecimalFormat wants the affixes from the pattern only (modMiddle, aka pattern modifier).
125     // Unsafe path: use fPatternModifier.
126     fPatternModifier-&gt;setNumberProperties(signum, plural);
127     fPatternModifier-&gt;apply(outString, 0, 0, status);
128     if (U_FAILURE(status)) { return 0; }
<span class="line-modified">129     return fPatternModifier-&gt;getPrefixLength(status);</span>
130 }
131 
132 NumberFormatterImpl::NumberFormatterImpl(const MacroProps&amp; macros, bool safe, UErrorCode&amp; status) {
133     fMicroPropsGenerator = macrosToMicroGenerator(macros, safe, status);
134 }
135 
136 //////////
137 
138 const MicroPropsGenerator*
139 NumberFormatterImpl::macrosToMicroGenerator(const MacroProps&amp; macros, bool safe, UErrorCode&amp; status) {
140     if (U_FAILURE(status)) { return nullptr; }
141     const MicroPropsGenerator* chain = &amp;fMicros;
142 
143     // Check that macros is error-free before continuing.
144     if (macros.copyErrorTo(status)) {
145         return nullptr;
146     }
147 
148     // TODO: Accept currency symbols from DecimalFormatSymbols?
149 
150     // Pre-compute a few values for efficiency.
151     bool isCurrency = utils::unitIsCurrency(macros.unit);
152     bool isNoUnit = utils::unitIsNoUnit(macros.unit);
<span class="line-modified">153     bool isPercent = isNoUnit &amp;&amp; utils::unitIsPercent(macros.unit);</span>
<span class="line-modified">154     bool isPermille = isNoUnit &amp;&amp; utils::unitIsPermille(macros.unit);</span>
<span class="line-removed">155     bool isCldrUnit = !isCurrency &amp;&amp; !isNoUnit;</span>
156     bool isAccounting =
157             macros.sign == UNUM_SIGN_ACCOUNTING || macros.sign == UNUM_SIGN_ACCOUNTING_ALWAYS ||
158             macros.sign == UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO;
<span class="line-modified">159     CurrencyUnit currency(nullptr, status);</span>
160     if (isCurrency) {
161         currency = CurrencyUnit(macros.unit, status); // Restore CurrencyUnit from MeasureUnit
162     }
163     const CurrencySymbols* currencySymbols;
164     if (macros.currencySymbols != nullptr) {
165         // Used by the DecimalFormat code path
166         currencySymbols = macros.currencySymbols;
167     } else {
168         fWarehouse.fCurrencySymbols = {currency, macros.locale, status};
169         currencySymbols = &amp;fWarehouse.fCurrencySymbols;
170     }
171     UNumberUnitWidth unitWidth = UNUM_UNIT_WIDTH_SHORT;
172     if (macros.unitWidth != UNUM_UNIT_WIDTH_COUNT) {
173         unitWidth = macros.unitWidth;
174     }


175 
176     // Select the numbering system.
177     LocalPointer&lt;const NumberingSystem&gt; nsLocal;
178     const NumberingSystem* ns;
179     if (macros.symbols.isNumberingSystem()) {
180         ns = macros.symbols.getNumberingSystem();
181     } else {
182         // TODO: Is there a way to avoid creating the NumberingSystem object?
183         ns = NumberingSystem::createInstance(macros.locale, status);
184         // Give ownership to the function scope.
185         nsLocal.adoptInstead(ns);
186     }
187     const char* nsName = U_SUCCESS(status) ? ns-&gt;getName() : &quot;latn&quot;;


188 
189     // Resolve the symbols. Do this here because currency may need to customize them.
190     if (macros.symbols.isDecimalFormatSymbols()) {
191         fMicros.symbols = macros.symbols.getDecimalFormatSymbols();
192     } else {
193         fMicros.symbols = new DecimalFormatSymbols(macros.locale, *ns, status);
194         // Give ownership to the NumberFormatterImpl.
195         fSymbols.adoptInstead(fMicros.symbols);
196     }
197 
198     // Load and parse the pattern string. It is used for grouping sizes and affixes only.
199     // If we are formatting currency, check for a currency-specific pattern.
200     const char16_t* pattern = nullptr;
201     if (isCurrency) {
202         CurrencyFormatInfoResult info = getCurrencyFormatInfo(
203                 macros.locale, currency.getSubtype(), status);
204         if (info.exists) {
205             pattern = info.pattern;
206             // It&#39;s clunky to clone an object here, but this code is not frequently executed.
207             auto* symbols = new DecimalFormatSymbols(*fMicros.symbols);
208             fMicros.symbols = symbols;
209             fSymbols.adoptInstead(symbols);
210             symbols-&gt;setSymbol(
211                     DecimalFormatSymbols::ENumberFormatSymbol::kMonetarySeparatorSymbol,
212                     UnicodeString(info.decimalSeparator),
213                     FALSE);
214             symbols-&gt;setSymbol(
215                     DecimalFormatSymbols::ENumberFormatSymbol::kMonetaryGroupingSeparatorSymbol,
216                     UnicodeString(info.groupingSeparator),
217                     FALSE);
218         }
219     }
220     if (pattern == nullptr) {
221         CldrPatternStyle patternStyle;
<span class="line-modified">222         if (isPercent || isPermille) {</span>


223             patternStyle = CLDR_PATTERN_STYLE_PERCENT;
224         } else if (!isCurrency || unitWidth == UNUM_UNIT_WIDTH_FULL_NAME) {
225             patternStyle = CLDR_PATTERN_STYLE_DECIMAL;
226         } else if (isAccounting) {
227             // NOTE: Although ACCOUNTING and ACCOUNTING_ALWAYS are only supported in currencies right now,
228             // the API contract allows us to add support to other units in the future.
229             patternStyle = CLDR_PATTERN_STYLE_ACCOUNTING;
230         } else {
231             patternStyle = CLDR_PATTERN_STYLE_CURRENCY;
232         }
233         pattern = utils::getPatternForStyle(macros.locale, nsName, patternStyle, status);
234     }
235     auto patternInfo = new ParsedPatternInfo();
236     fPatternInfo.adoptInstead(patternInfo);
237     PatternParser::parseToPatternInfo(UnicodeString(pattern), *patternInfo, status);
238 
239     /////////////////////////////////////////////////////////////////////////////////////
240     /// START POPULATING THE DEFAULT MICROPROPS AND BUILDING THE MICROPROPS GENERATOR ///
241     /////////////////////////////////////////////////////////////////////////////////////
242 
</pre>
<hr />
<pre>
305         fMicros.decimal = UNUM_DECIMAL_SEPARATOR_AUTO;
306     }
307 
308     // Use monetary separator symbols
309     fMicros.useCurrency = isCurrency;
310 
311     // Inner modifier (scientific notation)
312     if (macros.notation.fType == Notation::NTN_SCIENTIFIC) {
313         fScientificHandler.adoptInstead(new ScientificHandler(&amp;macros.notation, fMicros.symbols, chain));
314         chain = fScientificHandler.getAlias();
315     } else {
316         // No inner modifier required
317         fMicros.modInner = &amp;fMicros.helpers.emptyStrongModifier;
318     }
319 
320     // Middle modifier (patterns, positive/negative, currency symbols, percent)
321     auto patternModifier = new MutablePatternModifier(false);
322     fPatternModifier.adoptInstead(patternModifier);
323     patternModifier-&gt;setPatternInfo(
324             macros.affixProvider != nullptr ? macros.affixProvider
<span class="line-modified">325                                             : static_cast&lt;const AffixPatternProvider*&gt;(fPatternInfo.getAlias()));</span>

326     patternModifier-&gt;setPatternAttributes(fMicros.sign, isPermille);
327     if (patternModifier-&gt;needsPlurals()) {
328         patternModifier-&gt;setSymbols(
329                 fMicros.symbols,
330                 currencySymbols,
331                 unitWidth,
332                 resolvePluralRules(macros.rules, macros.locale, status));
333     } else {
334         patternModifier-&gt;setSymbols(fMicros.symbols, currencySymbols, unitWidth, nullptr);
335     }
336     if (safe) {
337         fImmutablePatternModifier.adoptInstead(patternModifier-&gt;createImmutableAndChain(chain, status));
338         chain = fImmutablePatternModifier.getAlias();
339     } else {
340         patternModifier-&gt;addToChain(chain);
341         chain = patternModifier;
342     }
343 
344     // Outer modifier (CLDR units and currency long names)
345     if (isCldrUnit) {
346         fLongNameHandler.adoptInstead(
<span class="line-modified">347                 new LongNameHandler(</span>
<span class="line-modified">348                         LongNameHandler::forMeasureUnit(</span>
<span class="line-modified">349                                 macros.locale,</span>
<span class="line-modified">350                                 macros.unit,</span>
<span class="line-modified">351                                 macros.perUnit,</span>
<span class="line-modified">352                                 unitWidth,</span>
<span class="line-modified">353                                 resolvePluralRules(macros.rules, macros.locale, status),</span>
<span class="line-modified">354                                 chain,</span>
<span class="line-removed">355                                 status)));</span>
356         chain = fLongNameHandler.getAlias();
357     } else if (isCurrency &amp;&amp; unitWidth == UNUM_UNIT_WIDTH_FULL_NAME) {
358         fLongNameHandler.adoptInstead(
<span class="line-modified">359                 new LongNameHandler(</span>
<span class="line-modified">360                         LongNameHandler::forCurrencyLongNames(</span>
<span class="line-modified">361                                 macros.locale,</span>
<span class="line-modified">362                                 currency,</span>
<span class="line-modified">363                                 resolvePluralRules(macros.rules, macros.locale, status),</span>
<span class="line-modified">364                                 chain,</span>
<span class="line-removed">365                                 status)));</span>
366         chain = fLongNameHandler.getAlias();
367     } else {
368         // No outer modifier required
369         fMicros.modOuter = &amp;fMicros.helpers.emptyWeakModifier;
370     }
371 
372     // Compact notation
373     // NOTE: Compact notation can (but might not) override the middle modifier and rounding.
374     // It therefore needs to go at the end of the chain.
375     if (macros.notation.fType == Notation::NTN_COMPACT) {
376         CompactType compactType = (isCurrency &amp;&amp; unitWidth != UNUM_UNIT_WIDTH_FULL_NAME)
377                                   ? CompactType::TYPE_CURRENCY : CompactType::TYPE_DECIMAL;
378         fCompactHandler.adoptInstead(
379                 new CompactHandler(
380                         macros.notation.fUnion.compactStyle,
381                         macros.locale,
382                         nsName,
383                         compactType,
384                         resolvePluralRules(macros.rules, macros.locale, status),
385                         safe ? patternModifier : nullptr,
</pre>
<hr />
<pre>
387                         status));
388         chain = fCompactHandler.getAlias();
389     }
390 
391     return chain;
392 }
393 
394 const PluralRules*
395 NumberFormatterImpl::resolvePluralRules(const PluralRules* rulesPtr, const Locale&amp; locale,
396                                         UErrorCode&amp; status) {
397     if (rulesPtr != nullptr) {
398         return rulesPtr;
399     }
400     // Lazily create PluralRules
401     if (fRules.isNull()) {
402         fRules.adoptInstead(PluralRules::forLocale(locale, status));
403     }
404     return fRules.getAlias();
405 }
406 
<span class="line-modified">407 int32_t NumberFormatterImpl::microsToString(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,</span>
<span class="line-modified">408                                             NumberStringBuilder&amp; string, UErrorCode&amp; status) {</span>
<span class="line-removed">409     micros.rounder.apply(quantity, status);</span>
<span class="line-removed">410     micros.integerWidth.apply(quantity, status);</span>
<span class="line-removed">411     int32_t length = writeNumber(micros, quantity, string, status);</span>
<span class="line-removed">412     // NOTE: When range formatting is added, these modifiers can bubble up.</span>
<span class="line-removed">413     // For now, apply them all here at once.</span>
414     // Always apply the inner modifier (which is &quot;strong&quot;).
<span class="line-modified">415     length += micros.modInner-&gt;apply(string, 0, length, status);</span>
416     if (micros.padding.isValid()) {
417         length += micros.padding
<span class="line-modified">418                 .padAndApply(*micros.modMiddle, *micros.modOuter, string, 0, length, status);</span>
419     } else {
<span class="line-modified">420         length += micros.modMiddle-&gt;apply(string, 0, length, status);</span>
<span class="line-modified">421         length += micros.modOuter-&gt;apply(string, 0, length, status);</span>
422     }
423     return length;
424 }
425 
426 int32_t NumberFormatterImpl::writeNumber(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">427                                          NumberStringBuilder&amp; string, UErrorCode&amp; status) {</span>

428     int32_t length = 0;
429     if (quantity.isInfinite()) {
430         length += string.insert(
<span class="line-modified">431                 length,</span>
432                 micros.symbols-&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kInfinitySymbol),
433                 UNUM_INTEGER_FIELD,
434                 status);
435 
436     } else if (quantity.isNaN()) {
437         length += string.insert(
<span class="line-modified">438                 length,</span>
439                 micros.symbols-&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kNaNSymbol),
440                 UNUM_INTEGER_FIELD,
441                 status);
442 
443     } else {
444         // Add the integer digits
<span class="line-modified">445         length += writeIntegerDigits(micros, quantity, string, status);</span>
446 
447         // Add the decimal point
448         if (quantity.getLowerDisplayMagnitude() &lt; 0 || micros.decimal == UNUM_DECIMAL_SEPARATOR_ALWAYS) {
449             length += string.insert(
<span class="line-modified">450                     length,</span>
451                     micros.useCurrency ? micros.symbols-&gt;getSymbol(
452                             DecimalFormatSymbols::ENumberFormatSymbol::kMonetarySeparatorSymbol) : micros
453                             .symbols
454                             -&gt;getSymbol(
455                                     DecimalFormatSymbols::ENumberFormatSymbol::kDecimalSeparatorSymbol),
456                     UNUM_DECIMAL_SEPARATOR_FIELD,
457                     status);
458         }
459 
460         // Add the fraction digits
<span class="line-modified">461         length += writeFractionDigits(micros, quantity, string, status);</span>
462     }
463 
464     return length;
465 }
466 
467 int32_t NumberFormatterImpl::writeIntegerDigits(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">468                                                 NumberStringBuilder&amp; string, UErrorCode&amp; status) {</span>

469     int length = 0;
470     int integerCount = quantity.getUpperDisplayMagnitude() + 1;
471     for (int i = 0; i &lt; integerCount; i++) {
472         // Add grouping separator
473         if (micros.grouping.groupAtPosition(i, quantity)) {
474             length += string.insert(
<span class="line-modified">475                     0,</span>
476                     micros.useCurrency ? micros.symbols-&gt;getSymbol(
477                             DecimalFormatSymbols::ENumberFormatSymbol::kMonetaryGroupingSeparatorSymbol)
478                                        : micros.symbols-&gt;getSymbol(
479                             DecimalFormatSymbols::ENumberFormatSymbol::kGroupingSeparatorSymbol),
480                     UNUM_GROUPING_SEPARATOR_FIELD,
481                     status);
482         }
483 
484         // Get and append the next digit value
485         int8_t nextDigit = quantity.getDigit(i);
486         length += utils::insertDigitFromSymbols(
<span class="line-modified">487                 string, 0, nextDigit, *micros.symbols, UNUM_INTEGER_FIELD, status);</span>
488     }
489     return length;
490 }
491 
492 int32_t NumberFormatterImpl::writeFractionDigits(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">493                                                  NumberStringBuilder&amp; string, UErrorCode&amp; status) {</span>

494     int length = 0;
495     int fractionCount = -quantity.getLowerDisplayMagnitude();
496     for (int i = 0; i &lt; fractionCount; i++) {
497         // Get and append the next digit value
498         int8_t nextDigit = quantity.getDigit(-i - 1);
499         length += utils::insertDigitFromSymbols(
<span class="line-modified">500                 string, string.length(), nextDigit, *micros.symbols, UNUM_FRACTION_FIELD, status);</span>
501     }
502     return length;
503 }
504 
505 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
<td>
<hr />
<pre>
 50         ures_getSize(bundle.getAlias()) &gt; 2) { // the length is 3 if more data is present
 51         ures_getByIndex(bundle.getAlias(), 2, bundle.getAlias(), &amp;localStatus);
 52         int32_t dummy;
 53         result.exists = true;
 54         result.pattern = ures_getStringByIndex(bundle.getAlias(), 0, &amp;dummy, &amp;localStatus);
 55         result.decimalSeparator = ures_getStringByIndex(bundle.getAlias(), 1, &amp;dummy, &amp;localStatus);
 56         result.groupingSeparator = ures_getStringByIndex(bundle.getAlias(), 2, &amp;dummy, &amp;localStatus);
 57         status = localStatus;
 58     } else if (localStatus != U_MISSING_RESOURCE_ERROR) {
 59         status = localStatus;
 60     }
 61     return result;
 62 }
 63 
 64 }  // namespace
 65 
 66 
 67 MicroPropsGenerator::~MicroPropsGenerator() = default;
 68 
 69 
<span class="line-modified"> 70 NumberFormatterImpl::NumberFormatterImpl(const MacroProps&amp; macros, UErrorCode&amp; status)</span>
<span class="line-modified"> 71     : NumberFormatterImpl(macros, true, status) {</span>
 72 }
 73 
<span class="line-modified"> 74 int32_t NumberFormatterImpl::formatStatic(const MacroProps&amp; macros, DecimalQuantity&amp; inValue,</span>
<span class="line-modified"> 75                                        NumberStringBuilder&amp; outString, UErrorCode&amp; status) {</span>
 76     NumberFormatterImpl impl(macros, false, status);
<span class="line-modified"> 77     MicroProps&amp; micros = impl.preProcessUnsafe(inValue, status);</span>
<span class="line-added"> 78     if (U_FAILURE(status)) { return 0; }</span>
<span class="line-added"> 79     int32_t length = writeNumber(micros, inValue, outString, 0, status);</span>
<span class="line-added"> 80     length += writeAffixes(micros, outString, 0, length, status);</span>
<span class="line-added"> 81     return length;</span>
 82 }
 83 
 84 int32_t NumberFormatterImpl::getPrefixSuffixStatic(const MacroProps&amp; macros, int8_t signum,
 85                                                    StandardPlural::Form plural,
 86                                                    NumberStringBuilder&amp; outString, UErrorCode&amp; status) {
 87     NumberFormatterImpl impl(macros, false, status);
 88     return impl.getPrefixSuffixUnsafe(signum, plural, outString, status);
 89 }
 90 
 91 // NOTE: C++ SPECIFIC DIFFERENCE FROM JAVA:
 92 // The &quot;safe&quot; apply method uses a new MicroProps. In the MicroPropsGenerator, fMicros is copied into the new instance.
 93 // The &quot;unsafe&quot; method simply re-uses fMicros, eliminating the extra copy operation.
 94 // See MicroProps::processQuantity() for details.
 95 
<span class="line-modified"> 96 int32_t NumberFormatterImpl::format(DecimalQuantity&amp; inValue, NumberStringBuilder&amp; outString,</span>
 97                                 UErrorCode&amp; status) const {

 98     MicroProps micros;
<span class="line-modified"> 99     preProcess(inValue, micros, status);</span>
<span class="line-modified">100     if (U_FAILURE(status)) { return 0; }</span>
<span class="line-modified">101     int32_t length = writeNumber(micros, inValue, outString, 0, status);</span>
<span class="line-modified">102     length += writeAffixes(micros, outString, 0, length, status);</span>
<span class="line-added">103     return length;</span>
104 }
105 
<span class="line-modified">106 void NumberFormatterImpl::preProcess(DecimalQuantity&amp; inValue, MicroProps&amp; microsOut,</span>
<span class="line-modified">107                                      UErrorCode&amp; status) const {</span>
108     if (U_FAILURE(status)) { return; }
<span class="line-added">109     if (fMicroPropsGenerator == nullptr) {</span>
<span class="line-added">110         status = U_INTERNAL_PROGRAM_ERROR;</span>
<span class="line-added">111         return;</span>
<span class="line-added">112     }</span>
<span class="line-added">113     fMicroPropsGenerator-&gt;processQuantity(inValue, microsOut, status);</span>
<span class="line-added">114     microsOut.rounder.apply(inValue, status);</span>
<span class="line-added">115     microsOut.integerWidth.apply(inValue, status);</span>
<span class="line-added">116 }</span>
<span class="line-added">117 </span>
<span class="line-added">118 MicroProps&amp; NumberFormatterImpl::preProcessUnsafe(DecimalQuantity&amp; inValue, UErrorCode&amp; status) {</span>
<span class="line-added">119     if (U_FAILURE(status)) {</span>
<span class="line-added">120         return fMicros; // must always return a value</span>
<span class="line-added">121     }</span>
<span class="line-added">122     if (fMicroPropsGenerator == nullptr) {</span>
<span class="line-added">123         status = U_INTERNAL_PROGRAM_ERROR;</span>
<span class="line-added">124         return fMicros; // must always return a value</span>
<span class="line-added">125     }</span>
126     fMicroPropsGenerator-&gt;processQuantity(inValue, fMicros, status);
<span class="line-modified">127     fMicros.rounder.apply(inValue, status);</span>
<span class="line-modified">128     fMicros.integerWidth.apply(inValue, status);</span>
<span class="line-added">129     return fMicros;</span>
130 }
131 
132 int32_t NumberFormatterImpl::getPrefixSuffix(int8_t signum, StandardPlural::Form plural,
133                                              NumberStringBuilder&amp; outString, UErrorCode&amp; status) const {
134     if (U_FAILURE(status)) { return 0; }
135     // #13453: DecimalFormat wants the affixes from the pattern only (modMiddle, aka pattern modifier).
136     // Safe path: use fImmutablePatternModifier.
137     const Modifier* modifier = fImmutablePatternModifier-&gt;getModifier(signum, plural);
138     modifier-&gt;apply(outString, 0, 0, status);
139     if (U_FAILURE(status)) { return 0; }
<span class="line-modified">140     return modifier-&gt;getPrefixLength();</span>
141 }
142 
143 int32_t NumberFormatterImpl::getPrefixSuffixUnsafe(int8_t signum, StandardPlural::Form plural,
144                                                    NumberStringBuilder&amp; outString, UErrorCode&amp; status) {
145     if (U_FAILURE(status)) { return 0; }
146     // #13453: DecimalFormat wants the affixes from the pattern only (modMiddle, aka pattern modifier).
147     // Unsafe path: use fPatternModifier.
148     fPatternModifier-&gt;setNumberProperties(signum, plural);
149     fPatternModifier-&gt;apply(outString, 0, 0, status);
150     if (U_FAILURE(status)) { return 0; }
<span class="line-modified">151     return fPatternModifier-&gt;getPrefixLength();</span>
152 }
153 
154 NumberFormatterImpl::NumberFormatterImpl(const MacroProps&amp; macros, bool safe, UErrorCode&amp; status) {
155     fMicroPropsGenerator = macrosToMicroGenerator(macros, safe, status);
156 }
157 
158 //////////
159 
160 const MicroPropsGenerator*
161 NumberFormatterImpl::macrosToMicroGenerator(const MacroProps&amp; macros, bool safe, UErrorCode&amp; status) {
162     if (U_FAILURE(status)) { return nullptr; }
163     const MicroPropsGenerator* chain = &amp;fMicros;
164 
165     // Check that macros is error-free before continuing.
166     if (macros.copyErrorTo(status)) {
167         return nullptr;
168     }
169 
170     // TODO: Accept currency symbols from DecimalFormatSymbols?
171 
172     // Pre-compute a few values for efficiency.
173     bool isCurrency = utils::unitIsCurrency(macros.unit);
174     bool isNoUnit = utils::unitIsNoUnit(macros.unit);
<span class="line-modified">175     bool isPercent = utils::unitIsPercent(macros.unit);</span>
<span class="line-modified">176     bool isPermille = utils::unitIsPermille(macros.unit);</span>

177     bool isAccounting =
178             macros.sign == UNUM_SIGN_ACCOUNTING || macros.sign == UNUM_SIGN_ACCOUNTING_ALWAYS ||
179             macros.sign == UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO;
<span class="line-modified">180     CurrencyUnit currency(u&quot;&quot;, status);</span>
181     if (isCurrency) {
182         currency = CurrencyUnit(macros.unit, status); // Restore CurrencyUnit from MeasureUnit
183     }
184     const CurrencySymbols* currencySymbols;
185     if (macros.currencySymbols != nullptr) {
186         // Used by the DecimalFormat code path
187         currencySymbols = macros.currencySymbols;
188     } else {
189         fWarehouse.fCurrencySymbols = {currency, macros.locale, status};
190         currencySymbols = &amp;fWarehouse.fCurrencySymbols;
191     }
192     UNumberUnitWidth unitWidth = UNUM_UNIT_WIDTH_SHORT;
193     if (macros.unitWidth != UNUM_UNIT_WIDTH_COUNT) {
194         unitWidth = macros.unitWidth;
195     }
<span class="line-added">196     bool isCldrUnit = !isCurrency &amp;&amp; !isNoUnit &amp;&amp;</span>
<span class="line-added">197         (unitWidth == UNUM_UNIT_WIDTH_FULL_NAME || !(isPercent || isPermille));</span>
198 
199     // Select the numbering system.
200     LocalPointer&lt;const NumberingSystem&gt; nsLocal;
201     const NumberingSystem* ns;
202     if (macros.symbols.isNumberingSystem()) {
203         ns = macros.symbols.getNumberingSystem();
204     } else {
205         // TODO: Is there a way to avoid creating the NumberingSystem object?
206         ns = NumberingSystem::createInstance(macros.locale, status);
207         // Give ownership to the function scope.
208         nsLocal.adoptInstead(ns);
209     }
210     const char* nsName = U_SUCCESS(status) ? ns-&gt;getName() : &quot;latn&quot;;
<span class="line-added">211     uprv_strncpy(fMicros.nsName, nsName, 8);</span>
<span class="line-added">212     fMicros.nsName[8] = 0; // guarantee NUL-terminated</span>
213 
214     // Resolve the symbols. Do this here because currency may need to customize them.
215     if (macros.symbols.isDecimalFormatSymbols()) {
216         fMicros.symbols = macros.symbols.getDecimalFormatSymbols();
217     } else {
218         fMicros.symbols = new DecimalFormatSymbols(macros.locale, *ns, status);
219         // Give ownership to the NumberFormatterImpl.
220         fSymbols.adoptInstead(fMicros.symbols);
221     }
222 
223     // Load and parse the pattern string. It is used for grouping sizes and affixes only.
224     // If we are formatting currency, check for a currency-specific pattern.
225     const char16_t* pattern = nullptr;
226     if (isCurrency) {
227         CurrencyFormatInfoResult info = getCurrencyFormatInfo(
228                 macros.locale, currency.getSubtype(), status);
229         if (info.exists) {
230             pattern = info.pattern;
231             // It&#39;s clunky to clone an object here, but this code is not frequently executed.
232             auto* symbols = new DecimalFormatSymbols(*fMicros.symbols);
233             fMicros.symbols = symbols;
234             fSymbols.adoptInstead(symbols);
235             symbols-&gt;setSymbol(
236                     DecimalFormatSymbols::ENumberFormatSymbol::kMonetarySeparatorSymbol,
237                     UnicodeString(info.decimalSeparator),
238                     FALSE);
239             symbols-&gt;setSymbol(
240                     DecimalFormatSymbols::ENumberFormatSymbol::kMonetaryGroupingSeparatorSymbol,
241                     UnicodeString(info.groupingSeparator),
242                     FALSE);
243         }
244     }
245     if (pattern == nullptr) {
246         CldrPatternStyle patternStyle;
<span class="line-modified">247         if (isCldrUnit) {</span>
<span class="line-added">248             patternStyle = CLDR_PATTERN_STYLE_DECIMAL;</span>
<span class="line-added">249         } else if (isPercent || isPermille) {</span>
250             patternStyle = CLDR_PATTERN_STYLE_PERCENT;
251         } else if (!isCurrency || unitWidth == UNUM_UNIT_WIDTH_FULL_NAME) {
252             patternStyle = CLDR_PATTERN_STYLE_DECIMAL;
253         } else if (isAccounting) {
254             // NOTE: Although ACCOUNTING and ACCOUNTING_ALWAYS are only supported in currencies right now,
255             // the API contract allows us to add support to other units in the future.
256             patternStyle = CLDR_PATTERN_STYLE_ACCOUNTING;
257         } else {
258             patternStyle = CLDR_PATTERN_STYLE_CURRENCY;
259         }
260         pattern = utils::getPatternForStyle(macros.locale, nsName, patternStyle, status);
261     }
262     auto patternInfo = new ParsedPatternInfo();
263     fPatternInfo.adoptInstead(patternInfo);
264     PatternParser::parseToPatternInfo(UnicodeString(pattern), *patternInfo, status);
265 
266     /////////////////////////////////////////////////////////////////////////////////////
267     /// START POPULATING THE DEFAULT MICROPROPS AND BUILDING THE MICROPROPS GENERATOR ///
268     /////////////////////////////////////////////////////////////////////////////////////
269 
</pre>
<hr />
<pre>
332         fMicros.decimal = UNUM_DECIMAL_SEPARATOR_AUTO;
333     }
334 
335     // Use monetary separator symbols
336     fMicros.useCurrency = isCurrency;
337 
338     // Inner modifier (scientific notation)
339     if (macros.notation.fType == Notation::NTN_SCIENTIFIC) {
340         fScientificHandler.adoptInstead(new ScientificHandler(&amp;macros.notation, fMicros.symbols, chain));
341         chain = fScientificHandler.getAlias();
342     } else {
343         // No inner modifier required
344         fMicros.modInner = &amp;fMicros.helpers.emptyStrongModifier;
345     }
346 
347     // Middle modifier (patterns, positive/negative, currency symbols, percent)
348     auto patternModifier = new MutablePatternModifier(false);
349     fPatternModifier.adoptInstead(patternModifier);
350     patternModifier-&gt;setPatternInfo(
351             macros.affixProvider != nullptr ? macros.affixProvider
<span class="line-modified">352                                             : static_cast&lt;const AffixPatternProvider*&gt;(fPatternInfo.getAlias()),</span>
<span class="line-added">353             UNUM_FIELD_COUNT);</span>
354     patternModifier-&gt;setPatternAttributes(fMicros.sign, isPermille);
355     if (patternModifier-&gt;needsPlurals()) {
356         patternModifier-&gt;setSymbols(
357                 fMicros.symbols,
358                 currencySymbols,
359                 unitWidth,
360                 resolvePluralRules(macros.rules, macros.locale, status));
361     } else {
362         patternModifier-&gt;setSymbols(fMicros.symbols, currencySymbols, unitWidth, nullptr);
363     }
364     if (safe) {
365         fImmutablePatternModifier.adoptInstead(patternModifier-&gt;createImmutableAndChain(chain, status));
366         chain = fImmutablePatternModifier.getAlias();
367     } else {
368         patternModifier-&gt;addToChain(chain);
369         chain = patternModifier;
370     }
371 
372     // Outer modifier (CLDR units and currency long names)
373     if (isCldrUnit) {
374         fLongNameHandler.adoptInstead(
<span class="line-modified">375                 LongNameHandler::forMeasureUnit(</span>
<span class="line-modified">376                         macros.locale,</span>
<span class="line-modified">377                         macros.unit,</span>
<span class="line-modified">378                         macros.perUnit,</span>
<span class="line-modified">379                         unitWidth,</span>
<span class="line-modified">380                         resolvePluralRules(macros.rules, macros.locale, status),</span>
<span class="line-modified">381                         chain,</span>
<span class="line-modified">382                         status));</span>

383         chain = fLongNameHandler.getAlias();
384     } else if (isCurrency &amp;&amp; unitWidth == UNUM_UNIT_WIDTH_FULL_NAME) {
385         fLongNameHandler.adoptInstead(
<span class="line-modified">386                 LongNameHandler::forCurrencyLongNames(</span>
<span class="line-modified">387                         macros.locale,</span>
<span class="line-modified">388                         currency,</span>
<span class="line-modified">389                         resolvePluralRules(macros.rules, macros.locale, status),</span>
<span class="line-modified">390                         chain,</span>
<span class="line-modified">391                         status));</span>

392         chain = fLongNameHandler.getAlias();
393     } else {
394         // No outer modifier required
395         fMicros.modOuter = &amp;fMicros.helpers.emptyWeakModifier;
396     }
397 
398     // Compact notation
399     // NOTE: Compact notation can (but might not) override the middle modifier and rounding.
400     // It therefore needs to go at the end of the chain.
401     if (macros.notation.fType == Notation::NTN_COMPACT) {
402         CompactType compactType = (isCurrency &amp;&amp; unitWidth != UNUM_UNIT_WIDTH_FULL_NAME)
403                                   ? CompactType::TYPE_CURRENCY : CompactType::TYPE_DECIMAL;
404         fCompactHandler.adoptInstead(
405                 new CompactHandler(
406                         macros.notation.fUnion.compactStyle,
407                         macros.locale,
408                         nsName,
409                         compactType,
410                         resolvePluralRules(macros.rules, macros.locale, status),
411                         safe ? patternModifier : nullptr,
</pre>
<hr />
<pre>
413                         status));
414         chain = fCompactHandler.getAlias();
415     }
416 
417     return chain;
418 }
419 
420 const PluralRules*
421 NumberFormatterImpl::resolvePluralRules(const PluralRules* rulesPtr, const Locale&amp; locale,
422                                         UErrorCode&amp; status) {
423     if (rulesPtr != nullptr) {
424         return rulesPtr;
425     }
426     // Lazily create PluralRules
427     if (fRules.isNull()) {
428         fRules.adoptInstead(PluralRules::forLocale(locale, status));
429     }
430     return fRules.getAlias();
431 }
432 
<span class="line-modified">433 int32_t NumberFormatterImpl::writeAffixes(const MicroProps&amp; micros, NumberStringBuilder&amp; string,</span>
<span class="line-modified">434                                           int32_t start, int32_t end, UErrorCode&amp; status) {</span>





435     // Always apply the inner modifier (which is &quot;strong&quot;).
<span class="line-modified">436     int32_t length = micros.modInner-&gt;apply(string, start, end, status);</span>
437     if (micros.padding.isValid()) {
438         length += micros.padding
<span class="line-modified">439                 .padAndApply(*micros.modMiddle, *micros.modOuter, string, start, length + end, status);</span>
440     } else {
<span class="line-modified">441         length += micros.modMiddle-&gt;apply(string, start, length + end, status);</span>
<span class="line-modified">442         length += micros.modOuter-&gt;apply(string, start, length + end, status);</span>
443     }
444     return length;
445 }
446 
447 int32_t NumberFormatterImpl::writeNumber(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">448                                          NumberStringBuilder&amp; string, int32_t index,</span>
<span class="line-added">449                                          UErrorCode&amp; status) {</span>
450     int32_t length = 0;
451     if (quantity.isInfinite()) {
452         length += string.insert(
<span class="line-modified">453                 length + index,</span>
454                 micros.symbols-&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kInfinitySymbol),
455                 UNUM_INTEGER_FIELD,
456                 status);
457 
458     } else if (quantity.isNaN()) {
459         length += string.insert(
<span class="line-modified">460                 length + index,</span>
461                 micros.symbols-&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kNaNSymbol),
462                 UNUM_INTEGER_FIELD,
463                 status);
464 
465     } else {
466         // Add the integer digits
<span class="line-modified">467         length += writeIntegerDigits(micros, quantity, string, length + index, status);</span>
468 
469         // Add the decimal point
470         if (quantity.getLowerDisplayMagnitude() &lt; 0 || micros.decimal == UNUM_DECIMAL_SEPARATOR_ALWAYS) {
471             length += string.insert(
<span class="line-modified">472                     length + index,</span>
473                     micros.useCurrency ? micros.symbols-&gt;getSymbol(
474                             DecimalFormatSymbols::ENumberFormatSymbol::kMonetarySeparatorSymbol) : micros
475                             .symbols
476                             -&gt;getSymbol(
477                                     DecimalFormatSymbols::ENumberFormatSymbol::kDecimalSeparatorSymbol),
478                     UNUM_DECIMAL_SEPARATOR_FIELD,
479                     status);
480         }
481 
482         // Add the fraction digits
<span class="line-modified">483         length += writeFractionDigits(micros, quantity, string, length + index, status);</span>
484     }
485 
486     return length;
487 }
488 
489 int32_t NumberFormatterImpl::writeIntegerDigits(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">490                                                 NumberStringBuilder&amp; string, int32_t index,</span>
<span class="line-added">491                                                 UErrorCode&amp; status) {</span>
492     int length = 0;
493     int integerCount = quantity.getUpperDisplayMagnitude() + 1;
494     for (int i = 0; i &lt; integerCount; i++) {
495         // Add grouping separator
496         if (micros.grouping.groupAtPosition(i, quantity)) {
497             length += string.insert(
<span class="line-modified">498                     index,</span>
499                     micros.useCurrency ? micros.symbols-&gt;getSymbol(
500                             DecimalFormatSymbols::ENumberFormatSymbol::kMonetaryGroupingSeparatorSymbol)
501                                        : micros.symbols-&gt;getSymbol(
502                             DecimalFormatSymbols::ENumberFormatSymbol::kGroupingSeparatorSymbol),
503                     UNUM_GROUPING_SEPARATOR_FIELD,
504                     status);
505         }
506 
507         // Get and append the next digit value
508         int8_t nextDigit = quantity.getDigit(i);
509         length += utils::insertDigitFromSymbols(
<span class="line-modified">510                 string, index, nextDigit, *micros.symbols, UNUM_INTEGER_FIELD, status);</span>
511     }
512     return length;
513 }
514 
515 int32_t NumberFormatterImpl::writeFractionDigits(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">516                                                  NumberStringBuilder&amp; string, int32_t index,</span>
<span class="line-added">517                                                  UErrorCode&amp; status) {</span>
518     int length = 0;
519     int fractionCount = -quantity.getLowerDisplayMagnitude();
520     for (int i = 0; i &lt; fractionCount; i++) {
521         // Get and append the next digit value
522         int8_t nextDigit = quantity.getDigit(-i - 1);
523         length += utils::insertDigitFromSymbols(
<span class="line-modified">524                 string, length + index, nextDigit, *micros.symbols, UNUM_FRACTION_FIELD, status);</span>
525     }
526     return length;
527 }
528 
529 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
</tr>
</table>
<center><a href="number_fluent.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_formatimpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>