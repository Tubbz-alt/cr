<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/uset.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 *
   6 *   Copyright (C) 2002-2014, International Business Machines
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 *******************************************************************************
  10 *   file name:  uset.h
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 2002mar07
  16 *   created by: Markus W. Scherer
  17 *
  18 *   C version of UnicodeSet.
  19 */
  20 
  21 
  22 /**
  23  * \file
  24  * \brief C API: Unicode Set
  25  *
  26  * &lt;p&gt;This is a C wrapper around the C++ UnicodeSet class.&lt;/p&gt;
  27  */
  28 
  29 #ifndef __USET_H__
  30 #define __USET_H__
  31 
  32 #include &quot;unicode/utypes.h&quot;
  33 #include &quot;unicode/uchar.h&quot;
  34 #include &quot;unicode/localpointer.h&quot;
  35 
<a name="1" id="anc1"></a><span class="line-modified">  36 #ifndef UCNV_H</span>
<span class="line-modified">  37 struct USet;</span>



  38 /**
<a name="2" id="anc2"></a><span class="line-modified">  39  * A UnicodeSet.  Use the uset_* API to manipulate.  Create with</span>

  40  * uset_open*, and destroy with uset_close.
  41  * @stable ICU 2.4
  42  */
  43 typedef struct USet USet;
  44 #endif
  45 
  46 /**
  47  * Bitmask values to be passed to uset_openPatternOptions() or
  48  * uset_applyPattern() taking an option parameter.
  49  * @stable ICU 2.4
  50  */
  51 enum {
  52     /**
  53      * Ignore white space within patterns unless quoted or escaped.
  54      * @stable ICU 2.4
  55      */
  56     USET_IGNORE_SPACE = 1,
  57 
  58     /**
  59      * Enable case insensitive matching.  E.g., &quot;[ab]&quot; with this flag
  60      * will match &#39;a&#39;, &#39;A&#39;, &#39;b&#39;, and &#39;B&#39;.  &quot;[^ab]&quot; with this flag will
  61      * match all except &#39;a&#39;, &#39;A&#39;, &#39;b&#39;, and &#39;B&#39;. This performs a full
  62      * closure over case mappings, e.g. U+017F for s.
  63      *
  64      * The resulting set is a superset of the input for the code points but
  65      * not for the strings.
  66      * It performs a case mapping closure of the code points and adds
  67      * full case folding strings for the code points, and reduces strings of
  68      * the original set to their full case folding equivalents.
  69      *
  70      * This is designed for case-insensitive matches, for example
  71      * in regular expressions. The full code point case closure allows checking of
  72      * an input character directly against the closure set.
  73      * Strings are matched by comparing the case-folded form from the closure
  74      * set with an incremental case folding of the string in question.
  75      *
  76      * The closure set will also contain single code points if the original
  77      * set contained case-equivalent strings (like U+00DF for &quot;ss&quot; or &quot;Ss&quot; etc.).
  78      * This is not necessary (that is, redundant) for the above matching method
  79      * but results in the same closure sets regardless of whether the original
  80      * set contained the code point or a string.
  81      *
  82      * @stable ICU 2.4
  83      */
  84     USET_CASE_INSENSITIVE = 2,
  85 
  86     /**
  87      * Enable case insensitive matching.  E.g., &quot;[ab]&quot; with this flag
  88      * will match &#39;a&#39;, &#39;A&#39;, &#39;b&#39;, and &#39;B&#39;.  &quot;[^ab]&quot; with this flag will
  89      * match all except &#39;a&#39;, &#39;A&#39;, &#39;b&#39;, and &#39;B&#39;. This adds the lower-,
  90      * title-, and uppercase mappings as well as the case folding
  91      * of each existing element in the set.
  92      * @stable ICU 3.2
  93      */
  94     USET_ADD_CASE_MAPPINGS = 4
  95 };
  96 
  97 /**
  98  * Argument values for whether span() and similar functions continue while
  99  * the current character is contained vs. not contained in the set.
 100  *
 101  * The functionality is straightforward for sets with only single code points,
 102  * without strings (which is the common case):
 103  * - USET_SPAN_CONTAINED and USET_SPAN_SIMPLE work the same.
 104  * - USET_SPAN_CONTAINED and USET_SPAN_SIMPLE are inverses of USET_SPAN_NOT_CONTAINED.
 105  * - span() and spanBack() partition any string the same way when
 106  *   alternating between span(USET_SPAN_NOT_CONTAINED) and
 107  *   span(either &quot;contained&quot; condition).
 108  * - Using a complemented (inverted) set and the opposite span conditions
 109  *   yields the same results.
 110  *
 111  * When a set contains multi-code point strings, then these statements may not
 112  * be true, depending on the strings in the set (for example, whether they
 113  * overlap with each other) and the string that is processed.
 114  * For a set with strings:
 115  * - The complement of the set contains the opposite set of code points,
 116  *   but the same set of strings.
 117  *   Therefore, complementing both the set and the span conditions
 118  *   may yield different results.
 119  * - When starting spans at different positions in a string
 120  *   (span(s, ...) vs. span(s+1, ...)) the ends of the spans may be different
 121  *   because a set string may start before the later position.
 122  * - span(USET_SPAN_SIMPLE) may be shorter than
 123  *   span(USET_SPAN_CONTAINED) because it will not recursively try
 124  *   all possible paths.
 125  *   For example, with a set which contains the three strings &quot;xy&quot;, &quot;xya&quot; and &quot;ax&quot;,
 126  *   span(&quot;xyax&quot;, USET_SPAN_CONTAINED) will return 4 but
 127  *   span(&quot;xyax&quot;, USET_SPAN_SIMPLE) will return 3.
 128  *   span(USET_SPAN_SIMPLE) will never be longer than
 129  *   span(USET_SPAN_CONTAINED).
 130  * - With either &quot;contained&quot; condition, span() and spanBack() may partition
 131  *   a string in different ways.
 132  *   For example, with a set which contains the two strings &quot;ab&quot; and &quot;ba&quot;,
 133  *   and when processing the string &quot;aba&quot;,
 134  *   span() will yield contained/not-contained boundaries of { 0, 2, 3 }
 135  *   while spanBack() will yield boundaries of { 0, 1, 3 }.
 136  *
 137  * Note: If it is important to get the same boundaries whether iterating forward
 138  * or backward through a string, then either only span() should be used and
 139  * the boundaries cached for backward operation, or an ICU BreakIterator
 140  * could be used.
 141  *
 142  * Note: Unpaired surrogates are treated like surrogate code points.
 143  * Similarly, set strings match only on code point boundaries,
 144  * never in the middle of a surrogate pair.
 145  * Illegal UTF-8 sequences are treated like U+FFFD.
 146  * When processing UTF-8 strings, malformed set strings
 147  * (strings with unpaired surrogates which cannot be converted to UTF-8)
 148  * are ignored.
 149  *
 150  * @stable ICU 3.8
 151  */
 152 typedef enum USetSpanCondition {
 153     /**
 154      * Continues a span() while there is no set element at the current position.
 155      * Increments by one code point at a time.
 156      * Stops before the first set element (character or string).
 157      * (For code points only, this is like while contains(current)==FALSE).
 158      *
 159      * When span() returns, the substring between where it started and the position
 160      * it returned consists only of characters that are not in the set,
 161      * and none of its strings overlap with the span.
 162      *
 163      * @stable ICU 3.8
 164      */
 165     USET_SPAN_NOT_CONTAINED = 0,
 166     /**
 167      * Spans the longest substring that is a concatenation of set elements (characters or strings).
 168      * (For characters only, this is like while contains(current)==TRUE).
 169      *
 170      * When span() returns, the substring between where it started and the position
 171      * it returned consists only of set elements (characters or strings) that are in the set.
 172      *
 173      * If a set contains strings, then the span will be the longest substring for which there
 174      * exists at least one non-overlapping concatenation of set elements (characters or strings).
 175      * This is equivalent to a POSIX regular expression for &lt;code&gt;(OR of each set element)*&lt;/code&gt;.
 176      * (Java/ICU/Perl regex stops at the first match of an OR.)
 177      *
 178      * @stable ICU 3.8
 179      */
 180     USET_SPAN_CONTAINED = 1,
 181     /**
 182      * Continues a span() while there is a set element at the current position.
 183      * Increments by the longest matching element at each position.
 184      * (For characters only, this is like while contains(current)==TRUE).
 185      *
 186      * When span() returns, the substring between where it started and the position
 187      * it returned consists only of set elements (characters or strings) that are in the set.
 188      *
 189      * If a set only contains single characters, then this is the same
 190      * as USET_SPAN_CONTAINED.
 191      *
 192      * If a set contains strings, then the span will be the longest substring
 193      * with a match at each position with the longest single set element (character or string).
 194      *
 195      * Use this span condition together with other longest-match algorithms,
 196      * such as ICU converters (ucnv_getUnicodeSet()).
 197      *
 198      * @stable ICU 3.8
 199      */
 200     USET_SPAN_SIMPLE = 2,
 201 #ifndef U_HIDE_DEPRECATED_API
 202     /**
 203      * One more than the last span condition.
 204      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
 205      */
 206     USET_SPAN_CONDITION_COUNT
 207 #endif  // U_HIDE_DEPRECATED_API
 208 } USetSpanCondition;
 209 
 210 enum {
 211     /**
 212      * Capacity of USerializedSet::staticArray.
 213      * Enough for any single-code point set.
 214      * Also provides padding for nice sizeof(USerializedSet).
 215      * @stable ICU 2.4
 216      */
 217     USET_SERIALIZED_STATIC_ARRAY_CAPACITY=8
 218 };
 219 
 220 /**
 221  * A serialized form of a Unicode set.  Limited manipulations are
 222  * possible directly on a serialized set.  See below.
 223  * @stable ICU 2.4
 224  */
 225 typedef struct USerializedSet {
 226     /**
 227      * The serialized Unicode Set.
 228      * @stable ICU 2.4
 229      */
 230     const uint16_t *array;
 231     /**
 232      * The length of the array that contains BMP characters.
 233      * @stable ICU 2.4
 234      */
 235     int32_t bmpLength;
 236     /**
 237      * The total length of the array.
 238      * @stable ICU 2.4
 239      */
 240     int32_t length;
 241     /**
 242      * A small buffer for the array to reduce memory allocations.
 243      * @stable ICU 2.4
 244      */
 245     uint16_t staticArray[USET_SERIALIZED_STATIC_ARRAY_CAPACITY];
 246 } USerializedSet;
 247 
 248 /*********************************************************************
 249  * USet API
 250  *********************************************************************/
 251 
 252 /**
 253  * Create an empty USet object.
 254  * Equivalent to uset_open(1, 0).
 255  * @return a newly created USet.  The caller must call uset_close() on
 256  * it when done.
 257  * @stable ICU 4.2
 258  */
 259 U_STABLE USet* U_EXPORT2
 260 uset_openEmpty(void);
 261 
 262 /**
 263  * Creates a USet object that contains the range of characters
 264  * start..end, inclusive.  If &lt;code&gt;start &gt; end&lt;/code&gt;
 265  * then an empty set is created (same as using uset_openEmpty()).
 266  * @param start first character of the range, inclusive
 267  * @param end last character of the range, inclusive
 268  * @return a newly created USet.  The caller must call uset_close() on
 269  * it when done.
 270  * @stable ICU 2.4
 271  */
 272 U_STABLE USet* U_EXPORT2
 273 uset_open(UChar32 start, UChar32 end);
 274 
 275 /**
 276  * Creates a set from the given pattern.  See the UnicodeSet class
 277  * description for the syntax of the pattern language.
 278  * @param pattern a string specifying what characters are in the set
 279  * @param patternLength the length of the pattern, or -1 if null
 280  * terminated
 281  * @param ec the error code
 282  * @stable ICU 2.4
 283  */
 284 U_STABLE USet* U_EXPORT2
 285 uset_openPattern(const UChar* pattern, int32_t patternLength,
 286                  UErrorCode* ec);
 287 
 288 /**
 289  * Creates a set from the given pattern.  See the UnicodeSet class
 290  * description for the syntax of the pattern language.
 291  * @param pattern a string specifying what characters are in the set
 292  * @param patternLength the length of the pattern, or -1 if null
 293  * terminated
 294  * @param options bitmask for options to apply to the pattern.
 295  * Valid options are USET_IGNORE_SPACE and USET_CASE_INSENSITIVE.
 296  * @param ec the error code
 297  * @stable ICU 2.4
 298  */
 299 U_STABLE USet* U_EXPORT2
 300 uset_openPatternOptions(const UChar* pattern, int32_t patternLength,
 301                  uint32_t options,
 302                  UErrorCode* ec);
 303 
 304 /**
 305  * Disposes of the storage used by a USet object.  This function should
 306  * be called exactly once for objects returned by uset_open().
 307  * @param set the object to dispose of
 308  * @stable ICU 2.4
 309  */
 310 U_STABLE void U_EXPORT2
 311 uset_close(USet* set);
 312 
 313 #if U_SHOW_CPLUSPLUS_API
 314 
 315 U_NAMESPACE_BEGIN
 316 
 317 /**
 318  * \class LocalUSetPointer
 319  * &quot;Smart pointer&quot; class, closes a USet via uset_close().
 320  * For most methods see the LocalPointerBase base class.
 321  *
 322  * @see LocalPointerBase
 323  * @see LocalPointer
 324  * @stable ICU 4.4
 325  */
 326 U_DEFINE_LOCAL_OPEN_POINTER(LocalUSetPointer, USet, uset_close);
 327 
 328 U_NAMESPACE_END
 329 
 330 #endif
 331 
 332 /**
 333  * Returns a copy of this object.
 334  * If this set is frozen, then the clone will be frozen as well.
 335  * Use uset_cloneAsThawed() for a mutable clone of a frozen set.
 336  * @param set the original set
 337  * @return the newly allocated copy of the set
 338  * @see uset_cloneAsThawed
 339  * @stable ICU 3.8
 340  */
 341 U_STABLE USet * U_EXPORT2
 342 uset_clone(const USet *set);
 343 
 344 /**
 345  * Determines whether the set has been frozen (made immutable) or not.
 346  * See the ICU4J Freezable interface for details.
 347  * @param set the set
 348  * @return TRUE/FALSE for whether the set has been frozen
 349  * @see uset_freeze
 350  * @see uset_cloneAsThawed
 351  * @stable ICU 3.8
 352  */
 353 U_STABLE UBool U_EXPORT2
 354 uset_isFrozen(const USet *set);
 355 
 356 /**
 357  * Freeze the set (make it immutable).
 358  * Once frozen, it cannot be unfrozen and is therefore thread-safe
 359  * until it is deleted.
 360  * See the ICU4J Freezable interface for details.
 361  * Freezing the set may also make some operations faster, for example
 362  * uset_contains() and uset_span().
 363  * A frozen set will not be modified. (It remains frozen.)
 364  * @param set the set
 365  * @return the same set, now frozen
 366  * @see uset_isFrozen
 367  * @see uset_cloneAsThawed
 368  * @stable ICU 3.8
 369  */
 370 U_STABLE void U_EXPORT2
 371 uset_freeze(USet *set);
 372 
 373 /**
 374  * Clone the set and make the clone mutable.
 375  * See the ICU4J Freezable interface for details.
 376  * @param set the set
 377  * @return the mutable clone
 378  * @see uset_freeze
 379  * @see uset_isFrozen
 380  * @see uset_clone
 381  * @stable ICU 3.8
 382  */
 383 U_STABLE USet * U_EXPORT2
 384 uset_cloneAsThawed(const USet *set);
 385 
 386 /**
 387  * Causes the USet object to represent the range &lt;code&gt;start - end&lt;/code&gt;.
 388  * If &lt;code&gt;start &gt; end&lt;/code&gt; then this USet is set to an empty range.
 389  * A frozen set will not be modified.
 390  * @param set the object to set to the given range
 391  * @param start first character in the set, inclusive
 392  * @param end last character in the set, inclusive
 393  * @stable ICU 3.2
 394  */
 395 U_STABLE void U_EXPORT2
 396 uset_set(USet* set,
 397          UChar32 start, UChar32 end);
 398 
 399 /**
 400  * Modifies the set to represent the set specified by the given
 401  * pattern. See the UnicodeSet class description for the syntax of
 402  * the pattern language. See also the User Guide chapter about UnicodeSet.
 403  * &lt;em&gt;Empties the set passed before applying the pattern.&lt;/em&gt;
 404  * A frozen set will not be modified.
 405  * @param set               The set to which the pattern is to be applied.
 406  * @param pattern           A pointer to UChar string specifying what characters are in the set.
 407  *                          The character at pattern[0] must be a &#39;[&#39;.
 408  * @param patternLength     The length of the UChar string. -1 if NUL terminated.
 409  * @param options           A bitmask for options to apply to the pattern.
 410  *                          Valid options are USET_IGNORE_SPACE and USET_CASE_INSENSITIVE.
 411  * @param status            Returns an error if the pattern cannot be parsed.
 412  * @return                  Upon successful parse, the value is either
 413  *                          the index of the character after the closing &#39;]&#39;
 414  *                          of the parsed pattern.
 415  *                          If the status code indicates failure, then the return value
 416  *                          is the index of the error in the source.
 417  *
 418  * @stable ICU 2.8
 419  */
 420 U_STABLE int32_t U_EXPORT2
 421 uset_applyPattern(USet *set,
 422                   const UChar *pattern, int32_t patternLength,
 423                   uint32_t options,
 424                   UErrorCode *status);
 425 
 426 /**
 427  * Modifies the set to contain those code points which have the given value
 428  * for the given binary or enumerated property, as returned by
 429  * u_getIntPropertyValue.  Prior contents of this set are lost.
 430  * A frozen set will not be modified.
 431  *
 432  * @param set the object to contain the code points defined by the property
 433  *
 434  * @param prop a property in the range UCHAR_BIN_START..UCHAR_BIN_LIMIT-1
 435  * or UCHAR_INT_START..UCHAR_INT_LIMIT-1
 436  * or UCHAR_MASK_START..UCHAR_MASK_LIMIT-1.
 437  *
 438  * @param value a value in the range u_getIntPropertyMinValue(prop)..
 439  * u_getIntPropertyMaxValue(prop), with one exception.  If prop is
 440  * UCHAR_GENERAL_CATEGORY_MASK, then value should not be a UCharCategory, but
 441  * rather a mask value produced by U_GET_GC_MASK().  This allows grouped
 442  * categories such as [:L:] to be represented.
 443  *
 444  * @param ec error code input/output parameter
 445  *
 446  * @stable ICU 3.2
 447  */
 448 U_STABLE void U_EXPORT2
 449 uset_applyIntPropertyValue(USet* set,
 450                            UProperty prop, int32_t value, UErrorCode* ec);
 451 
 452 /**
 453  * Modifies the set to contain those code points which have the
 454  * given value for the given property.  Prior contents of this
 455  * set are lost.
 456  * A frozen set will not be modified.
 457  *
 458  * @param set the object to contain the code points defined by the given
 459  * property and value alias
 460  *
 461  * @param prop a string specifying a property alias, either short or long.
 462  * The name is matched loosely.  See PropertyAliases.txt for names and a
 463  * description of loose matching.  If the value string is empty, then this
 464  * string is interpreted as either a General_Category value alias, a Script
 465  * value alias, a binary property alias, or a special ID.  Special IDs are
 466  * matched loosely and correspond to the following sets:
 467  *
 468  * &quot;ANY&quot; = [\\u0000-\\U0010FFFF],
 469  * &quot;ASCII&quot; = [\\u0000-\\u007F],
 470  * &quot;Assigned&quot; = [:^Cn:].
 471  *
 472  * @param propLength the length of the prop, or -1 if NULL
 473  *
 474  * @param value a string specifying a value alias, either short or long.
 475  * The name is matched loosely.  See PropertyValueAliases.txt for names
 476  * and a description of loose matching.  In addition to aliases listed,
 477  * numeric values and canonical combining classes may be expressed
 478  * numerically, e.g., (&quot;nv&quot;, &quot;0.5&quot;) or (&quot;ccc&quot;, &quot;220&quot;).  The value string
 479  * may also be empty.
 480  *
 481  * @param valueLength the length of the value, or -1 if NULL
 482  *
 483  * @param ec error code input/output parameter
 484  *
 485  * @stable ICU 3.2
 486  */
 487 U_STABLE void U_EXPORT2
 488 uset_applyPropertyAlias(USet* set,
 489                         const UChar *prop, int32_t propLength,
 490                         const UChar *value, int32_t valueLength,
 491                         UErrorCode* ec);
 492 
 493 /**
 494  * Return true if the given position, in the given pattern, appears
 495  * to be the start of a UnicodeSet pattern.
 496  *
 497  * @param pattern a string specifying the pattern
 498  * @param patternLength the length of the pattern, or -1 if NULL
 499  * @param pos the given position
 500  * @stable ICU 3.2
 501  */
 502 U_STABLE UBool U_EXPORT2
 503 uset_resemblesPattern(const UChar *pattern, int32_t patternLength,
 504                       int32_t pos);
 505 
 506 /**
 507  * Returns a string representation of this set.  If the result of
 508  * calling this function is passed to a uset_openPattern(), it
 509  * will produce another set that is equal to this one.
 510  * @param set the set
 511  * @param result the string to receive the rules, may be NULL
 512  * @param resultCapacity the capacity of result, may be 0 if result is NULL
 513  * @param escapeUnprintable if TRUE then convert unprintable
 514  * character to their hex escape representations, \\uxxxx or
 515  * \\Uxxxxxxxx.  Unprintable characters are those other than
 516  * U+000A, U+0020..U+007E.
 517  * @param ec error code.
 518  * @return length of string, possibly larger than resultCapacity
 519  * @stable ICU 2.4
 520  */
 521 U_STABLE int32_t U_EXPORT2
 522 uset_toPattern(const USet* set,
 523                UChar* result, int32_t resultCapacity,
 524                UBool escapeUnprintable,
 525                UErrorCode* ec);
 526 
 527 /**
 528  * Adds the given character to the given USet.  After this call,
 529  * uset_contains(set, c) will return TRUE.
 530  * A frozen set will not be modified.
 531  * @param set the object to which to add the character
 532  * @param c the character to add
 533  * @stable ICU 2.4
 534  */
 535 U_STABLE void U_EXPORT2
 536 uset_add(USet* set, UChar32 c);
 537 
 538 /**
 539  * Adds all of the elements in the specified set to this set if
 540  * they&#39;re not already present.  This operation effectively
 541  * modifies this set so that its value is the &lt;i&gt;union&lt;/i&gt; of the two
 542  * sets.  The behavior of this operation is unspecified if the specified
 543  * collection is modified while the operation is in progress.
 544  * A frozen set will not be modified.
 545  *
 546  * @param set the object to which to add the set
 547  * @param additionalSet the source set whose elements are to be added to this set.
 548  * @stable ICU 2.6
 549  */
 550 U_STABLE void U_EXPORT2
 551 uset_addAll(USet* set, const USet *additionalSet);
 552 
 553 /**
 554  * Adds the given range of characters to the given USet.  After this call,
 555  * uset_contains(set, start, end) will return TRUE.
 556  * A frozen set will not be modified.
 557  * @param set the object to which to add the character
 558  * @param start the first character of the range to add, inclusive
 559  * @param end the last character of the range to add, inclusive
 560  * @stable ICU 2.2
 561  */
 562 U_STABLE void U_EXPORT2
 563 uset_addRange(USet* set, UChar32 start, UChar32 end);
 564 
 565 /**
 566  * Adds the given string to the given USet.  After this call,
 567  * uset_containsString(set, str, strLen) will return TRUE.
 568  * A frozen set will not be modified.
 569  * @param set the object to which to add the character
 570  * @param str the string to add
 571  * @param strLen the length of the string or -1 if null terminated.
 572  * @stable ICU 2.4
 573  */
 574 U_STABLE void U_EXPORT2
 575 uset_addString(USet* set, const UChar* str, int32_t strLen);
 576 
 577 /**
 578  * Adds each of the characters in this string to the set. Thus &quot;ch&quot; =&gt; {&quot;c&quot;, &quot;h&quot;}
 579  * If this set already any particular character, it has no effect on that character.
 580  * A frozen set will not be modified.
 581  * @param set the object to which to add the character
 582  * @param str the source string
 583  * @param strLen the length of the string or -1 if null terminated.
 584  * @stable ICU 3.4
 585  */
 586 U_STABLE void U_EXPORT2
 587 uset_addAllCodePoints(USet* set, const UChar *str, int32_t strLen);
 588 
 589 /**
 590  * Removes the given character from the given USet.  After this call,
 591  * uset_contains(set, c) will return FALSE.
 592  * A frozen set will not be modified.
 593  * @param set the object from which to remove the character
 594  * @param c the character to remove
 595  * @stable ICU 2.4
 596  */
 597 U_STABLE void U_EXPORT2
 598 uset_remove(USet* set, UChar32 c);
 599 
 600 /**
 601  * Removes the given range of characters from the given USet.  After this call,
 602  * uset_contains(set, start, end) will return FALSE.
 603  * A frozen set will not be modified.
 604  * @param set the object to which to add the character
 605  * @param start the first character of the range to remove, inclusive
 606  * @param end the last character of the range to remove, inclusive
 607  * @stable ICU 2.2
 608  */
 609 U_STABLE void U_EXPORT2
 610 uset_removeRange(USet* set, UChar32 start, UChar32 end);
 611 
 612 /**
 613  * Removes the given string to the given USet.  After this call,
 614  * uset_containsString(set, str, strLen) will return FALSE.
 615  * A frozen set will not be modified.
 616  * @param set the object to which to add the character
 617  * @param str the string to remove
 618  * @param strLen the length of the string or -1 if null terminated.
 619  * @stable ICU 2.4
 620  */
 621 U_STABLE void U_EXPORT2
 622 uset_removeString(USet* set, const UChar* str, int32_t strLen);
 623 
 624 /**
 625  * Removes from this set all of its elements that are contained in the
 626  * specified set.  This operation effectively modifies this
 627  * set so that its value is the &lt;i&gt;asymmetric set difference&lt;/i&gt; of
 628  * the two sets.
 629  * A frozen set will not be modified.
 630  * @param set the object from which the elements are to be removed
 631  * @param removeSet the object that defines which elements will be
 632  * removed from this set
 633  * @stable ICU 3.2
 634  */
 635 U_STABLE void U_EXPORT2
 636 uset_removeAll(USet* set, const USet* removeSet);
 637 
 638 /**
 639  * Retain only the elements in this set that are contained in the
 640  * specified range.  If &lt;code&gt;start &gt; end&lt;/code&gt; then an empty range is
 641  * retained, leaving the set empty.  This is equivalent to
 642  * a boolean logic AND, or a set INTERSECTION.
 643  * A frozen set will not be modified.
 644  *
 645  * @param set the object for which to retain only the specified range
 646  * @param start first character, inclusive, of range to be retained
 647  * to this set.
 648  * @param end last character, inclusive, of range to be retained
 649  * to this set.
 650  * @stable ICU 3.2
 651  */
 652 U_STABLE void U_EXPORT2
 653 uset_retain(USet* set, UChar32 start, UChar32 end);
 654 
 655 /**
 656  * Retains only the elements in this set that are contained in the
 657  * specified set.  In other words, removes from this set all of
 658  * its elements that are not contained in the specified set.  This
 659  * operation effectively modifies this set so that its value is
 660  * the &lt;i&gt;intersection&lt;/i&gt; of the two sets.
 661  * A frozen set will not be modified.
 662  *
 663  * @param set the object on which to perform the retain
 664  * @param retain set that defines which elements this set will retain
 665  * @stable ICU 3.2
 666  */
 667 U_STABLE void U_EXPORT2
 668 uset_retainAll(USet* set, const USet* retain);
 669 
 670 /**
 671  * Reallocate this objects internal structures to take up the least
 672  * possible space, without changing this object&#39;s value.
 673  * A frozen set will not be modified.
 674  *
 675  * @param set the object on which to perfrom the compact
 676  * @stable ICU 3.2
 677  */
 678 U_STABLE void U_EXPORT2
 679 uset_compact(USet* set);
 680 
 681 /**
 682  * Inverts this set.  This operation modifies this set so that
 683  * its value is its complement.  This operation does not affect
 684  * the multicharacter strings, if any.
 685  * A frozen set will not be modified.
 686  * @param set the set
 687  * @stable ICU 2.4
 688  */
 689 U_STABLE void U_EXPORT2
 690 uset_complement(USet* set);
 691 
 692 /**
 693  * Complements in this set all elements contained in the specified
 694  * set.  Any character in the other set will be removed if it is
 695  * in this set, or will be added if it is not in this set.
 696  * A frozen set will not be modified.
 697  *
 698  * @param set the set with which to complement
 699  * @param complement set that defines which elements will be xor&#39;ed
 700  * from this set.
 701  * @stable ICU 3.2
 702  */
 703 U_STABLE void U_EXPORT2
 704 uset_complementAll(USet* set, const USet* complement);
 705 
 706 /**
 707  * Removes all of the elements from this set.  This set will be
 708  * empty after this call returns.
 709  * A frozen set will not be modified.
 710  * @param set the set
 711  * @stable ICU 2.4
 712  */
 713 U_STABLE void U_EXPORT2
 714 uset_clear(USet* set);
 715 
 716 /**
 717  * Close this set over the given attribute.  For the attribute
 718  * USET_CASE, the result is to modify this set so that:
 719  *
 720  * 1. For each character or string &#39;a&#39; in this set, all strings or
 721  * characters &#39;b&#39; such that foldCase(a) == foldCase(b) are added
 722  * to this set.
 723  *
 724  * 2. For each string &#39;e&#39; in the resulting set, if e !=
 725  * foldCase(e), &#39;e&#39; will be removed.
 726  *
 727  * Example: [aq\\u00DF{Bc}{bC}{Fi}] =&gt; [aAqQ\\u00DF\\uFB01{ss}{bc}{fi}]
 728  *
 729  * (Here foldCase(x) refers to the operation u_strFoldCase, and a
 730  * == b denotes that the contents are the same, not pointer
 731  * comparison.)
 732  *
 733  * A frozen set will not be modified.
 734  *
 735  * @param set the set
 736  *
 737  * @param attributes bitmask for attributes to close over.
 738  * Currently only the USET_CASE bit is supported.  Any undefined bits
 739  * are ignored.
 740  * @stable ICU 4.2
 741  */
 742 U_STABLE void U_EXPORT2
 743 uset_closeOver(USet* set, int32_t attributes);
 744 
 745 /**
 746  * Remove all strings from this set.
 747  *
 748  * @param set the set
 749  * @stable ICU 4.2
 750  */
 751 U_STABLE void U_EXPORT2
 752 uset_removeAllStrings(USet* set);
 753 
 754 /**
 755  * Returns TRUE if the given USet contains no characters and no
 756  * strings.
 757  * @param set the set
 758  * @return true if set is empty
 759  * @stable ICU 2.4
 760  */
 761 U_STABLE UBool U_EXPORT2
 762 uset_isEmpty(const USet* set);
 763 
 764 /**
 765  * Returns TRUE if the given USet contains the given character.
 766  * This function works faster with a frozen set.
 767  * @param set the set
 768  * @param c The codepoint to check for within the set
 769  * @return true if set contains c
 770  * @stable ICU 2.4
 771  */
 772 U_STABLE UBool U_EXPORT2
 773 uset_contains(const USet* set, UChar32 c);
 774 
 775 /**
 776  * Returns TRUE if the given USet contains all characters c
 777  * where start &lt;= c &amp;&amp; c &lt;= end.
 778  * @param set the set
 779  * @param start the first character of the range to test, inclusive
 780  * @param end the last character of the range to test, inclusive
 781  * @return TRUE if set contains the range
 782  * @stable ICU 2.2
 783  */
 784 U_STABLE UBool U_EXPORT2
 785 uset_containsRange(const USet* set, UChar32 start, UChar32 end);
 786 
 787 /**
 788  * Returns TRUE if the given USet contains the given string.
 789  * @param set the set
 790  * @param str the string
 791  * @param strLen the length of the string or -1 if null terminated.
 792  * @return true if set contains str
 793  * @stable ICU 2.4
 794  */
 795 U_STABLE UBool U_EXPORT2
 796 uset_containsString(const USet* set, const UChar* str, int32_t strLen);
 797 
 798 /**
 799  * Returns the index of the given character within this set, where
 800  * the set is ordered by ascending code point.  If the character
 801  * is not in this set, return -1.  The inverse of this method is
 802  * &lt;code&gt;charAt()&lt;/code&gt;.
 803  * @param set the set
 804  * @param c the character to obtain the index for
 805  * @return an index from 0..size()-1, or -1
 806  * @stable ICU 3.2
 807  */
 808 U_STABLE int32_t U_EXPORT2
 809 uset_indexOf(const USet* set, UChar32 c);
 810 
 811 /**
 812  * Returns the character at the given index within this set, where
 813  * the set is ordered by ascending code point.  If the index is
 814  * out of range, return (UChar32)-1.  The inverse of this method is
 815  * &lt;code&gt;indexOf()&lt;/code&gt;.
 816  * @param set the set
 817  * @param charIndex an index from 0..size()-1 to obtain the char for
 818  * @return the character at the given index, or (UChar32)-1.
 819  * @stable ICU 3.2
 820  */
 821 U_STABLE UChar32 U_EXPORT2
 822 uset_charAt(const USet* set, int32_t charIndex);
 823 
 824 /**
 825  * Returns the number of characters and strings contained in the given
 826  * USet.
 827  * @param set the set
 828  * @return a non-negative integer counting the characters and strings
 829  * contained in set
 830  * @stable ICU 2.4
 831  */
 832 U_STABLE int32_t U_EXPORT2
 833 uset_size(const USet* set);
 834 
 835 /**
 836  * Returns the number of items in this set.  An item is either a range
 837  * of characters or a single multicharacter string.
 838  * @param set the set
 839  * @return a non-negative integer counting the character ranges
 840  * and/or strings contained in set
 841  * @stable ICU 2.4
 842  */
 843 U_STABLE int32_t U_EXPORT2
 844 uset_getItemCount(const USet* set);
 845 
 846 /**
 847  * Returns an item of this set.  An item is either a range of
 848  * characters or a single multicharacter string.
 849  * @param set the set
 850  * @param itemIndex a non-negative integer in the range 0..
 851  * uset_getItemCount(set)-1
 852  * @param start pointer to variable to receive first character
 853  * in range, inclusive
 854  * @param end pointer to variable to receive last character in range,
 855  * inclusive
 856  * @param str buffer to receive the string, may be NULL
 857  * @param strCapacity capacity of str, or 0 if str is NULL
 858  * @param ec error code
 859  * @return the length of the string (&gt;= 2), or 0 if the item is a
 860  * range, in which case it is the range *start..*end, or -1 if
 861  * itemIndex is out of range
 862  * @stable ICU 2.4
 863  */
 864 U_STABLE int32_t U_EXPORT2
 865 uset_getItem(const USet* set, int32_t itemIndex,
 866              UChar32* start, UChar32* end,
 867              UChar* str, int32_t strCapacity,
 868              UErrorCode* ec);
 869 
 870 /**
 871  * Returns true if set1 contains all the characters and strings
 872  * of set2. It answers the question, &#39;Is set1 a superset of set2?&#39;
 873  * @param set1 set to be checked for containment
 874  * @param set2 set to be checked for containment
 875  * @return true if the test condition is met
 876  * @stable ICU 3.2
 877  */
 878 U_STABLE UBool U_EXPORT2
 879 uset_containsAll(const USet* set1, const USet* set2);
 880 
 881 /**
 882  * Returns true if this set contains all the characters
 883  * of the given string. This is does not check containment of grapheme
 884  * clusters, like uset_containsString.
 885  * @param set set of characters to be checked for containment
 886  * @param str string containing codepoints to be checked for containment
 887  * @param strLen the length of the string or -1 if null terminated.
 888  * @return true if the test condition is met
 889  * @stable ICU 3.4
 890  */
 891 U_STABLE UBool U_EXPORT2
 892 uset_containsAllCodePoints(const USet* set, const UChar *str, int32_t strLen);
 893 
 894 /**
 895  * Returns true if set1 contains none of the characters and strings
 896  * of set2. It answers the question, &#39;Is set1 a disjoint set of set2?&#39;
 897  * @param set1 set to be checked for containment
 898  * @param set2 set to be checked for containment
 899  * @return true if the test condition is met
 900  * @stable ICU 3.2
 901  */
 902 U_STABLE UBool U_EXPORT2
 903 uset_containsNone(const USet* set1, const USet* set2);
 904 
 905 /**
 906  * Returns true if set1 contains some of the characters and strings
 907  * of set2. It answers the question, &#39;Does set1 and set2 have an intersection?&#39;
 908  * @param set1 set to be checked for containment
 909  * @param set2 set to be checked for containment
 910  * @return true if the test condition is met
 911  * @stable ICU 3.2
 912  */
 913 U_STABLE UBool U_EXPORT2
 914 uset_containsSome(const USet* set1, const USet* set2);
 915 
 916 /**
 917  * Returns the length of the initial substring of the input string which
 918  * consists only of characters and strings that are contained in this set
 919  * (USET_SPAN_CONTAINED, USET_SPAN_SIMPLE),
 920  * or only of characters and strings that are not contained
 921  * in this set (USET_SPAN_NOT_CONTAINED).
 922  * See USetSpanCondition for details.
 923  * Similar to the strspn() C library function.
 924  * Unpaired surrogates are treated according to contains() of their surrogate code points.
 925  * This function works faster with a frozen set and with a non-negative string length argument.
 926  * @param set the set
 927  * @param s start of the string
 928  * @param length of the string; can be -1 for NUL-terminated
 929  * @param spanCondition specifies the containment condition
 930  * @return the length of the initial substring according to the spanCondition;
 931  *         0 if the start of the string does not fit the spanCondition
 932  * @stable ICU 3.8
 933  * @see USetSpanCondition
 934  */
 935 U_STABLE int32_t U_EXPORT2
 936 uset_span(const USet *set, const UChar *s, int32_t length, USetSpanCondition spanCondition);
 937 
 938 /**
 939  * Returns the start of the trailing substring of the input string which
 940  * consists only of characters and strings that are contained in this set
 941  * (USET_SPAN_CONTAINED, USET_SPAN_SIMPLE),
 942  * or only of characters and strings that are not contained
 943  * in this set (USET_SPAN_NOT_CONTAINED).
 944  * See USetSpanCondition for details.
 945  * Unpaired surrogates are treated according to contains() of their surrogate code points.
 946  * This function works faster with a frozen set and with a non-negative string length argument.
 947  * @param set the set
 948  * @param s start of the string
 949  * @param length of the string; can be -1 for NUL-terminated
 950  * @param spanCondition specifies the containment condition
 951  * @return the start of the trailing substring according to the spanCondition;
 952  *         the string length if the end of the string does not fit the spanCondition
 953  * @stable ICU 3.8
 954  * @see USetSpanCondition
 955  */
 956 U_STABLE int32_t U_EXPORT2
 957 uset_spanBack(const USet *set, const UChar *s, int32_t length, USetSpanCondition spanCondition);
 958 
 959 /**
 960  * Returns the length of the initial substring of the input string which
 961  * consists only of characters and strings that are contained in this set
 962  * (USET_SPAN_CONTAINED, USET_SPAN_SIMPLE),
 963  * or only of characters and strings that are not contained
 964  * in this set (USET_SPAN_NOT_CONTAINED).
 965  * See USetSpanCondition for details.
 966  * Similar to the strspn() C library function.
 967  * Malformed byte sequences are treated according to contains(0xfffd).
 968  * This function works faster with a frozen set and with a non-negative string length argument.
 969  * @param set the set
 970  * @param s start of the string (UTF-8)
 971  * @param length of the string; can be -1 for NUL-terminated
 972  * @param spanCondition specifies the containment condition
 973  * @return the length of the initial substring according to the spanCondition;
 974  *         0 if the start of the string does not fit the spanCondition
 975  * @stable ICU 3.8
 976  * @see USetSpanCondition
 977  */
 978 U_STABLE int32_t U_EXPORT2
 979 uset_spanUTF8(const USet *set, const char *s, int32_t length, USetSpanCondition spanCondition);
 980 
 981 /**
 982  * Returns the start of the trailing substring of the input string which
 983  * consists only of characters and strings that are contained in this set
 984  * (USET_SPAN_CONTAINED, USET_SPAN_SIMPLE),
 985  * or only of characters and strings that are not contained
 986  * in this set (USET_SPAN_NOT_CONTAINED).
 987  * See USetSpanCondition for details.
 988  * Malformed byte sequences are treated according to contains(0xfffd).
 989  * This function works faster with a frozen set and with a non-negative string length argument.
 990  * @param set the set
 991  * @param s start of the string (UTF-8)
 992  * @param length of the string; can be -1 for NUL-terminated
 993  * @param spanCondition specifies the containment condition
 994  * @return the start of the trailing substring according to the spanCondition;
 995  *         the string length if the end of the string does not fit the spanCondition
 996  * @stable ICU 3.8
 997  * @see USetSpanCondition
 998  */
 999 U_STABLE int32_t U_EXPORT2
1000 uset_spanBackUTF8(const USet *set, const char *s, int32_t length, USetSpanCondition spanCondition);
1001 
1002 /**
1003  * Returns true if set1 contains all of the characters and strings
1004  * of set2, and vis versa. It answers the question, &#39;Is set1 equal to set2?&#39;
1005  * @param set1 set to be checked for containment
1006  * @param set2 set to be checked for containment
1007  * @return true if the test condition is met
1008  * @stable ICU 3.2
1009  */
1010 U_STABLE UBool U_EXPORT2
1011 uset_equals(const USet* set1, const USet* set2);
1012 
1013 /*********************************************************************
1014  * Serialized set API
1015  *********************************************************************/
1016 
1017 /**
1018  * Serializes this set into an array of 16-bit integers.  Serialization
1019  * (currently) only records the characters in the set; multicharacter
1020  * strings are ignored.
1021  *
1022  * The array
1023  * has following format (each line is one 16-bit integer):
1024  *
1025  *  length     = (n+2*m) | (m!=0?0x8000:0)
1026  *  bmpLength  = n; present if m!=0
1027  *  bmp[0]
1028  *  bmp[1]
1029  *  ...
1030  *  bmp[n-1]
1031  *  supp-high[0]
1032  *  supp-low[0]
1033  *  supp-high[1]
1034  *  supp-low[1]
1035  *  ...
1036  *  supp-high[m-1]
1037  *  supp-low[m-1]
1038  *
1039  * The array starts with a header.  After the header are n bmp
1040  * code points, then m supplementary code points.  Either n or m
1041  * or both may be zero.  n+2*m is always &lt;= 0x7FFF.
1042  *
1043  * If there are no supplementary characters (if m==0) then the
1044  * header is one 16-bit integer, &#39;length&#39;, with value n.
1045  *
1046  * If there are supplementary characters (if m!=0) then the header
1047  * is two 16-bit integers.  The first, &#39;length&#39;, has value
1048  * (n+2*m)|0x8000.  The second, &#39;bmpLength&#39;, has value n.
1049  *
1050  * After the header the code points are stored in ascending order.
1051  * Supplementary code points are stored as most significant 16
1052  * bits followed by least significant 16 bits.
1053  *
1054  * @param set the set
1055  * @param dest pointer to buffer of destCapacity 16-bit integers.
1056  * May be NULL only if destCapacity is zero.
1057  * @param destCapacity size of dest, or zero.  Must not be negative.
1058  * @param pErrorCode pointer to the error code.  Will be set to
1059  * U_INDEX_OUTOFBOUNDS_ERROR if n+2*m &gt; 0x7FFF.  Will be set to
1060  * U_BUFFER_OVERFLOW_ERROR if n+2*m+(m!=0?2:1) &gt; destCapacity.
1061  * @return the total length of the serialized format, including
1062  * the header, that is, n+2*m+(m!=0?2:1), or 0 on error other
1063  * than U_BUFFER_OVERFLOW_ERROR.
1064  * @stable ICU 2.4
1065  */
1066 U_STABLE int32_t U_EXPORT2
1067 uset_serialize(const USet* set, uint16_t* dest, int32_t destCapacity, UErrorCode* pErrorCode);
1068 
1069 /**
1070  * Given a serialized array, fill in the given serialized set object.
1071  * @param fillSet pointer to result
1072  * @param src pointer to start of array
1073  * @param srcLength length of array
1074  * @return true if the given array is valid, otherwise false
1075  * @stable ICU 2.4
1076  */
1077 U_STABLE UBool U_EXPORT2
1078 uset_getSerializedSet(USerializedSet* fillSet, const uint16_t* src, int32_t srcLength);
1079 
1080 /**
1081  * Set the USerializedSet to contain the given character (and nothing
1082  * else).
1083  * @param fillSet pointer to result
1084  * @param c The codepoint to set
1085  * @stable ICU 2.4
1086  */
1087 U_STABLE void U_EXPORT2
1088 uset_setSerializedToOne(USerializedSet* fillSet, UChar32 c);
1089 
1090 /**
1091  * Returns TRUE if the given USerializedSet contains the given
1092  * character.
1093  * @param set the serialized set
1094  * @param c The codepoint to check for within the set
1095  * @return true if set contains c
1096  * @stable ICU 2.4
1097  */
1098 U_STABLE UBool U_EXPORT2
1099 uset_serializedContains(const USerializedSet* set, UChar32 c);
1100 
1101 /**
1102  * Returns the number of disjoint ranges of characters contained in
1103  * the given serialized set.  Ignores any strings contained in the
1104  * set.
1105  * @param set the serialized set
1106  * @return a non-negative integer counting the character ranges
1107  * contained in set
1108  * @stable ICU 2.4
1109  */
1110 U_STABLE int32_t U_EXPORT2
1111 uset_getSerializedRangeCount(const USerializedSet* set);
1112 
1113 /**
1114  * Returns a range of characters contained in the given serialized
1115  * set.
1116  * @param set the serialized set
1117  * @param rangeIndex a non-negative integer in the range 0..
1118  * uset_getSerializedRangeCount(set)-1
1119  * @param pStart pointer to variable to receive first character
1120  * in range, inclusive
1121  * @param pEnd pointer to variable to receive last character in range,
1122  * inclusive
1123  * @return true if rangeIndex is valid, otherwise false
1124  * @stable ICU 2.4
1125  */
1126 U_STABLE UBool U_EXPORT2
1127 uset_getSerializedRange(const USerializedSet* set, int32_t rangeIndex,
1128                         UChar32* pStart, UChar32* pEnd);
1129 
1130 #endif
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>