<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/usprep.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ushape.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ustr_cnv.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/usprep.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 #include &quot;cmemory.h&quot;
 31 #include &quot;sprpimpl.h&quot;
 32 #include &quot;ustr_imp.h&quot;
 33 #include &quot;uhash.h&quot;
 34 #include &quot;cstring.h&quot;
 35 #include &quot;udataswp.h&quot;
 36 #include &quot;ucln_cmn.h&quot;
 37 #include &quot;ubidi_props.h&quot;
 38 #include &quot;uprops.h&quot;
 39 
 40 U_NAMESPACE_USE
 41 
 42 U_CDECL_BEGIN
 43 
 44 /*
 45 Static cache for already opened StringPrep profiles
 46 */
 47 static UHashtable *SHARED_DATA_HASHTABLE = NULL;
 48 static icu::UInitOnce gSharedDataInitOnce;
 49 
<span class="line-modified"> 50 static UMutex usprepMutex = U_MUTEX_INITIALIZER;</span>



 51 
 52 /* format version of spp file */
 53 //static uint8_t formatVersion[4]={ 0, 0, 0, 0 };
 54 
 55 /* the Unicode version of the sprep data */
 56 static UVersionInfo dataVersion={ 0, 0, 0, 0 };
 57 
 58 /* Profile names must be aligned to UStringPrepProfileType */
 59 static const char * const PROFILE_NAMES[] = {
 60     &quot;rfc3491&quot;,      /* USPREP_RFC3491_NAMEPREP */
 61     &quot;rfc3530cs&quot;,    /* USPREP_RFC3530_NFS4_CS_PREP */
 62     &quot;rfc3530csci&quot;,  /* USPREP_RFC3530_NFS4_CS_PREP_CI */
 63     &quot;rfc3491&quot;,      /* USPREP_RFC3530_NSF4_CIS_PREP */
 64     &quot;rfc3530mixp&quot;,  /* USPREP_RFC3530_NSF4_MIXED_PREP_PREFIX */
 65     &quot;rfc3491&quot;,      /* USPREP_RFC3530_NSF4_MIXED_PREP_SUFFIX */
 66     &quot;rfc3722&quot;,      /* USPREP_RFC3722_ISCSI */
 67     &quot;rfc3920node&quot;,  /* USPREP_RFC3920_NODEPREP */
 68     &quot;rfc3920res&quot;,   /* USPREP_RFC3920_RESOURCEPREP */
 69     &quot;rfc4011&quot;,      /* USPREP_RFC4011_MIB */
 70     &quot;rfc4013&quot;,      /* USPREP_RFC4013_SASLPREP */
</pre>
<hr />
<pre>
 95         return TRUE;
 96     } else {
 97         return FALSE;
 98     }
 99 }
100 
101 static int32_t U_CALLCONV
102 getSPrepFoldingOffset(uint32_t data) {
103 
104     return (int32_t)data;
105 
106 }
107 
108 /* hashes an entry  */
109 static int32_t U_CALLCONV
110 hashEntry(const UHashTok parm) {
111     UStringPrepKey *b = (UStringPrepKey *)parm.pointer;
112     UHashTok namekey, pathkey;
113     namekey.pointer = b-&gt;name;
114     pathkey.pointer = b-&gt;path;
<span class="line-modified">115     return uhash_hashChars(namekey)+37*uhash_hashChars(pathkey);</span>


116 }
117 
118 /* compares two entries */
119 static UBool U_CALLCONV
120 compareEntries(const UHashTok p1, const UHashTok p2) {
121     UStringPrepKey *b1 = (UStringPrepKey *)p1.pointer;
122     UStringPrepKey *b2 = (UStringPrepKey *)p2.pointer;
123     UHashTok name1, name2, path1, path2;
124     name1.pointer = b1-&gt;name;
125     name2.pointer = b2-&gt;name;
126     path1.pointer = b1-&gt;path;
127     path2.pointer = b2-&gt;path;
128     return ((UBool)(uhash_compareChars(name1, name2) &amp;
129         uhash_compareChars(path1, path2)));
130 }
131 
132 static void
133 usprep_unload(UStringPrepProfile* data){
134     udata_close(data-&gt;sprepData);
135 }
136 
137 static int32_t
138 usprep_internal_flushCache(UBool noRefCount){
139     UStringPrepProfile *profile = NULL;
140     UStringPrepKey  *key  = NULL;
141     int32_t pos = UHASH_FIRST;
142     int32_t deletedNum = 0;
143     const UHashElement *e;
144 
145     /*
146      * if shared data hasn&#39;t even been lazy evaluated yet
147      * return 0
148      */
<span class="line-modified">149     umtx_lock(&amp;usprepMutex);</span>
150     if (SHARED_DATA_HASHTABLE == NULL) {
<span class="line-modified">151         umtx_unlock(&amp;usprepMutex);</span>
152         return 0;
153     }
154 
155     /*creates an enumeration to iterate through every element in the table */
156     while ((e = uhash_nextElement(SHARED_DATA_HASHTABLE, &amp;pos)) != NULL)
157     {
158         profile = (UStringPrepProfile *) e-&gt;value.pointer;
159         key  = (UStringPrepKey *) e-&gt;key.pointer;
160 
161         if ((noRefCount== FALSE &amp;&amp; profile-&gt;refCount == 0) ||
162              noRefCount== TRUE) {
163             deletedNum++;
164             uhash_removeElement(SHARED_DATA_HASHTABLE, e);
165 
166             /* unload the data */
167             usprep_unload(profile);
168 
169             if(key-&gt;name != NULL) {
170                 uprv_free(key-&gt;name);
171                 key-&gt;name=NULL;
172             }
173             if(key-&gt;path != NULL) {
174                 uprv_free(key-&gt;path);
175                 key-&gt;path=NULL;
176             }
177             uprv_free(profile);
178             uprv_free(key);
179         }
180 
181     }
<span class="line-modified">182     umtx_unlock(&amp;usprepMutex);</span>
183 
184     return deletedNum;
185 }
186 
187 /* Works just like ucnv_flushCache()
188 static int32_t
189 usprep_flushCache(){
190     return usprep_internal_flushCache(FALSE);
191 }
192 */
193 
194 static UBool U_CALLCONV usprep_cleanup(void){
195     if (SHARED_DATA_HASHTABLE != NULL) {
196         usprep_internal_flushCache(TRUE);
197         if (SHARED_DATA_HASHTABLE != NULL &amp;&amp; uhash_count(SHARED_DATA_HASHTABLE) == 0) {
198             uhash_close(SHARED_DATA_HASHTABLE);
199             SHARED_DATA_HASHTABLE = NULL;
200         }
201     }
202     gSharedDataInitOnce.reset();
</pre>
<hr />
<pre>
240 
241     /* open the data outside the mutex block */
242     //TODO: change the path
243     dataMemory=udata_openChoice(path, type, name, isSPrepAcceptable, NULL, errorCode);
244     if(U_FAILURE(*errorCode)) {
245         return FALSE;
246     }
247 
248     p=(const int32_t *)udata_getMemory(dataMemory);
249     pb=(const uint8_t *)(p+_SPREP_INDEX_TOP);
250     utrie_unserialize(&amp;_sprepTrie, pb, p[_SPREP_INDEX_TRIE_SIZE], errorCode);
251     _sprepTrie.getFoldingOffset=getSPrepFoldingOffset;
252 
253 
254     if(U_FAILURE(*errorCode)) {
255         udata_close(dataMemory);
256         return FALSE;
257     }
258 
259     /* in the mutex block, set the data for this process */
<span class="line-modified">260     umtx_lock(&amp;usprepMutex);</span>
261     if(profile-&gt;sprepData==NULL) {
262         profile-&gt;sprepData=dataMemory;
263         dataMemory=NULL;
264         uprv_memcpy(&amp;profile-&gt;indexes, p, sizeof(profile-&gt;indexes));
265         uprv_memcpy(&amp;profile-&gt;sprepTrie, &amp;_sprepTrie, sizeof(UTrie));
266     } else {
267         p=(const int32_t *)udata_getMemory(profile-&gt;sprepData);
268     }
<span class="line-modified">269     umtx_unlock(&amp;usprepMutex);</span>
270     /* initialize some variables */
271     profile-&gt;mappingData=(uint16_t *)((uint8_t *)(p+_SPREP_INDEX_TOP)+profile-&gt;indexes[_SPREP_INDEX_TRIE_SIZE]);
272 
273     u_getUnicodeVersion(normUnicodeVersion);
274     normUniVer = (normUnicodeVersion[0] &lt;&lt; 24) + (normUnicodeVersion[1] &lt;&lt; 16) +
275                  (normUnicodeVersion[2] &lt;&lt; 8 ) + (normUnicodeVersion[3]);
276     sprepUniVer = (dataVersion[0] &lt;&lt; 24) + (dataVersion[1] &lt;&lt; 16) +
277                   (dataVersion[2] &lt;&lt; 8 ) + (dataVersion[3]);
278     normCorrVer = profile-&gt;indexes[_SPREP_NORM_CORRECTNS_LAST_UNI_VERSION];
279 
280     if(U_FAILURE(*errorCode)){
281         udata_close(dataMemory);
282         return FALSE;
283     }
284     if( normUniVer &lt; sprepUniVer &amp;&amp; /* the Unicode version of SPREP file must be less than the Unicode Vesion of the normalization data */
285         normUniVer &lt; normCorrVer &amp;&amp; /* the Unicode version of the NormalizationCorrections.txt file should be less than the Unicode Vesion of the normalization data */
286         ((profile-&gt;indexes[_SPREP_OPTIONS] &amp; _SPREP_NORMALIZATION_ON) &gt; 0) /* normalization turned on*/
287       ){
288         *errorCode = U_INVALID_FORMAT_ERROR;
289         udata_close(dataMemory);
</pre>
<hr />
<pre>
306                   UErrorCode *status){
307 
308     UStringPrepProfile* profile = NULL;
309 
310     initCache(status);
311 
312     if(U_FAILURE(*status)){
313         return NULL;
314     }
315 
316     UStringPrepKey stackKey;
317     /*
318      * const is cast way to save malloc, strcpy and free calls
319      * we use the passed in pointers for fetching the data from the
320      * hash table which is safe
321      */
322     stackKey.name = (char*) name;
323     stackKey.path = (char*) path;
324 
325     /* fetch the data from the cache */
<span class="line-modified">326     umtx_lock(&amp;usprepMutex);</span>
327     profile = (UStringPrepProfile*) (uhash_get(SHARED_DATA_HASHTABLE,&amp;stackKey));
328     if(profile != NULL) {
329         profile-&gt;refCount++;
330     }
<span class="line-modified">331     umtx_unlock(&amp;usprepMutex);</span>
332 
333     if(profile == NULL) {
334         /* else load the data and put the data in the cache */
335         LocalMemory&lt;UStringPrepProfile&gt; newProfile;
336         if(newProfile.allocateInsteadAndReset() == NULL) {
337             *status = U_MEMORY_ALLOCATION_ERROR;
338             return NULL;
339         }
340 
341         /* load the data */
342         if(!loadData(newProfile.getAlias(), path, name, _SPREP_DATA_TYPE, status) || U_FAILURE(*status) ){
343             return NULL;
344         }
345 
346         /* get the options */
347         newProfile-&gt;doNFKC = (UBool)((newProfile-&gt;indexes[_SPREP_OPTIONS] &amp; _SPREP_NORMALIZATION_ON) &gt; 0);
348         newProfile-&gt;checkBiDi = (UBool)((newProfile-&gt;indexes[_SPREP_OPTIONS] &amp; _SPREP_CHECK_BIDI_ON) &gt; 0);
349 
350         LocalMemory&lt;UStringPrepKey&gt; key;
351         LocalMemory&lt;char&gt; keyName;
352         LocalMemory&lt;char&gt; keyPath;
353         if( key.allocateInsteadAndReset() == NULL ||
<span class="line-modified">354             keyName.allocateInsteadAndCopy(uprv_strlen(name)+1) == NULL ||</span>
355             (path != NULL &amp;&amp;
<span class="line-modified">356              keyPath.allocateInsteadAndCopy(uprv_strlen(path)+1) == NULL)</span>
357          ) {
358             *status = U_MEMORY_ALLOCATION_ERROR;
359             usprep_unload(newProfile.getAlias());
360             return NULL;
361         }
362 
<span class="line-modified">363         umtx_lock(&amp;usprepMutex);</span>
364         // If another thread already inserted the same key/value, refcount and cleanup our thread data
365         profile = (UStringPrepProfile*) (uhash_get(SHARED_DATA_HASHTABLE,&amp;stackKey));
366         if(profile != NULL) {
367             profile-&gt;refCount++;
368             usprep_unload(newProfile.getAlias());
369         }
370         else {
371             /* initialize the key members */
372             key-&gt;name = keyName.orphan();
373             uprv_strcpy(key-&gt;name, name);
374             if(path != NULL){
375                 key-&gt;path = keyPath.orphan();
376                 uprv_strcpy(key-&gt;path, path);
377             }
378             profile = newProfile.orphan();
379 
380             /* add the data object to the cache */
381             profile-&gt;refCount = 1;
382             uhash_put(SHARED_DATA_HASHTABLE, key.orphan(), profile, status);
383         }
<span class="line-modified">384         umtx_unlock(&amp;usprepMutex);</span>
385     }
386 
387     return profile;
388 }
389 
390 U_CAPI UStringPrepProfile* U_EXPORT2
391 usprep_open(const char* path,
392             const char* name,
393             UErrorCode* status){
394 
395     if(status == NULL || U_FAILURE(*status)){
396         return NULL;
397     }
398 
399     /* initialize the profile struct members */
400     return usprep_getProfile(path,name,status);
401 }
402 
403 U_CAPI UStringPrepProfile* U_EXPORT2
404 usprep_openByType(UStringPrepProfileType type,
405                   UErrorCode* status) {
406     if(status == NULL || U_FAILURE(*status)){
407         return NULL;
408     }
409     int32_t index = (int32_t)type;
410     if (index &lt; 0 || index &gt;= UPRV_LENGTHOF(PROFILE_NAMES)) {
411         *status = U_ILLEGAL_ARGUMENT_ERROR;
412         return NULL;
413     }
414     return usprep_open(NULL, PROFILE_NAMES[index], status);
415 }
416 
417 U_CAPI void U_EXPORT2
418 usprep_close(UStringPrepProfile* profile){
419     if(profile==NULL){
420         return;
421     }
422 
<span class="line-modified">423     umtx_lock(&amp;usprepMutex);</span>
424     /* decrement the ref count*/
425     if(profile-&gt;refCount &gt; 0){
426         profile-&gt;refCount--;
427     }
<span class="line-modified">428     umtx_unlock(&amp;usprepMutex);</span>
429 
430 }
431 
432 U_CFUNC void
433 uprv_syntaxError(const UChar* rules,
434                  int32_t pos,
435                  int32_t rulesLen,
436                  UParseError* parseError){
437     if(parseError == NULL){
438         return;
439     }
440     parseError-&gt;offset = pos;
441     parseError-&gt;line = 0 ; // we are not using line numbers
442 
443     // for pre-context
444     int32_t start = (pos &lt; U_PARSE_CONTEXT_LEN)? 0 : (pos - (U_PARSE_CONTEXT_LEN-1));
445     int32_t limit = pos;
446 
447     u_memcpy(parseError-&gt;preContext,rules+start,limit-start);
448     //null terminate the buffer
</pre>
<hr />
<pre>
709     int32_t b2Len = s2.length();
710     UCharDirection direction=U_CHAR_DIRECTION_COUNT, firstCharDir=U_CHAR_DIRECTION_COUNT;
711     UBool leftToRight=FALSE, rightToLeft=FALSE;
712     int32_t rtlPos =-1, ltrPos =-1;
713 
714     for(int32_t b2Index=0; b2Index&lt;b2Len;){
715         UChar32 ch = 0;
716         U16_NEXT(b2, b2Index, b2Len, ch);
717 
718         uint16_t result;
719         UTRIE_GET16(&amp;profile-&gt;sprepTrie,ch,result);
720 
721         int16_t value;
722         UBool isIndex;
723         UStringPrepType type = getValues(result, value, isIndex);
724 
725         if( type == USPREP_PROHIBITED ||
726             ((result &lt; _SPREP_TYPE_THRESHOLD) &amp;&amp; (result &amp; 0x01) /* first bit says it the code point is prohibited*/)
727            ){
728             *status = U_STRINGPREP_PROHIBITED_ERROR;
<span class="line-modified">729             uprv_syntaxError(b1, b2Index-U16_LENGTH(ch), b2Len, parseError);</span>
730             return 0;
731         }
732 
733         if(profile-&gt;checkBiDi) {
734             direction = ubidi_getClass(ch);
735             if(firstCharDir == U_CHAR_DIRECTION_COUNT){
736                 firstCharDir = direction;
737             }
738             if(direction == U_LEFT_TO_RIGHT){
739                 leftToRight = TRUE;
740                 ltrPos = b2Index-1;
741             }
742             if(direction == U_RIGHT_TO_LEFT || direction == U_RIGHT_TO_LEFT_ARABIC){
743                 rightToLeft = TRUE;
744                 rtlPos = b2Index-1;
745             }
746         }
747     }
748     if(profile-&gt;checkBiDi == TRUE){
749         // satisfy 2
</pre>
</td>
<td>
<hr />
<pre>
 30 #include &quot;cmemory.h&quot;
 31 #include &quot;sprpimpl.h&quot;
 32 #include &quot;ustr_imp.h&quot;
 33 #include &quot;uhash.h&quot;
 34 #include &quot;cstring.h&quot;
 35 #include &quot;udataswp.h&quot;
 36 #include &quot;ucln_cmn.h&quot;
 37 #include &quot;ubidi_props.h&quot;
 38 #include &quot;uprops.h&quot;
 39 
 40 U_NAMESPACE_USE
 41 
 42 U_CDECL_BEGIN
 43 
 44 /*
 45 Static cache for already opened StringPrep profiles
 46 */
 47 static UHashtable *SHARED_DATA_HASHTABLE = NULL;
 48 static icu::UInitOnce gSharedDataInitOnce;
 49 
<span class="line-modified"> 50 static UMutex *usprepMutex() {</span>
<span class="line-added"> 51     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added"> 52     return &amp;m;</span>
<span class="line-added"> 53 }</span>
 54 
 55 /* format version of spp file */
 56 //static uint8_t formatVersion[4]={ 0, 0, 0, 0 };
 57 
 58 /* the Unicode version of the sprep data */
 59 static UVersionInfo dataVersion={ 0, 0, 0, 0 };
 60 
 61 /* Profile names must be aligned to UStringPrepProfileType */
 62 static const char * const PROFILE_NAMES[] = {
 63     &quot;rfc3491&quot;,      /* USPREP_RFC3491_NAMEPREP */
 64     &quot;rfc3530cs&quot;,    /* USPREP_RFC3530_NFS4_CS_PREP */
 65     &quot;rfc3530csci&quot;,  /* USPREP_RFC3530_NFS4_CS_PREP_CI */
 66     &quot;rfc3491&quot;,      /* USPREP_RFC3530_NSF4_CIS_PREP */
 67     &quot;rfc3530mixp&quot;,  /* USPREP_RFC3530_NSF4_MIXED_PREP_PREFIX */
 68     &quot;rfc3491&quot;,      /* USPREP_RFC3530_NSF4_MIXED_PREP_SUFFIX */
 69     &quot;rfc3722&quot;,      /* USPREP_RFC3722_ISCSI */
 70     &quot;rfc3920node&quot;,  /* USPREP_RFC3920_NODEPREP */
 71     &quot;rfc3920res&quot;,   /* USPREP_RFC3920_RESOURCEPREP */
 72     &quot;rfc4011&quot;,      /* USPREP_RFC4011_MIB */
 73     &quot;rfc4013&quot;,      /* USPREP_RFC4013_SASLPREP */
</pre>
<hr />
<pre>
 98         return TRUE;
 99     } else {
100         return FALSE;
101     }
102 }
103 
104 static int32_t U_CALLCONV
105 getSPrepFoldingOffset(uint32_t data) {
106 
107     return (int32_t)data;
108 
109 }
110 
111 /* hashes an entry  */
112 static int32_t U_CALLCONV
113 hashEntry(const UHashTok parm) {
114     UStringPrepKey *b = (UStringPrepKey *)parm.pointer;
115     UHashTok namekey, pathkey;
116     namekey.pointer = b-&gt;name;
117     pathkey.pointer = b-&gt;path;
<span class="line-modified">118     uint32_t unsignedHash = static_cast&lt;uint32_t&gt;(uhash_hashChars(namekey)) +</span>
<span class="line-added">119             37u * static_cast&lt;uint32_t&gt;(uhash_hashChars(pathkey));</span>
<span class="line-added">120     return static_cast&lt;int32_t&gt;(unsignedHash);</span>
121 }
122 
123 /* compares two entries */
124 static UBool U_CALLCONV
125 compareEntries(const UHashTok p1, const UHashTok p2) {
126     UStringPrepKey *b1 = (UStringPrepKey *)p1.pointer;
127     UStringPrepKey *b2 = (UStringPrepKey *)p2.pointer;
128     UHashTok name1, name2, path1, path2;
129     name1.pointer = b1-&gt;name;
130     name2.pointer = b2-&gt;name;
131     path1.pointer = b1-&gt;path;
132     path2.pointer = b2-&gt;path;
133     return ((UBool)(uhash_compareChars(name1, name2) &amp;
134         uhash_compareChars(path1, path2)));
135 }
136 
137 static void
138 usprep_unload(UStringPrepProfile* data){
139     udata_close(data-&gt;sprepData);
140 }
141 
142 static int32_t
143 usprep_internal_flushCache(UBool noRefCount){
144     UStringPrepProfile *profile = NULL;
145     UStringPrepKey  *key  = NULL;
146     int32_t pos = UHASH_FIRST;
147     int32_t deletedNum = 0;
148     const UHashElement *e;
149 
150     /*
151      * if shared data hasn&#39;t even been lazy evaluated yet
152      * return 0
153      */
<span class="line-modified">154     umtx_lock(usprepMutex());</span>
155     if (SHARED_DATA_HASHTABLE == NULL) {
<span class="line-modified">156         umtx_unlock(usprepMutex());</span>
157         return 0;
158     }
159 
160     /*creates an enumeration to iterate through every element in the table */
161     while ((e = uhash_nextElement(SHARED_DATA_HASHTABLE, &amp;pos)) != NULL)
162     {
163         profile = (UStringPrepProfile *) e-&gt;value.pointer;
164         key  = (UStringPrepKey *) e-&gt;key.pointer;
165 
166         if ((noRefCount== FALSE &amp;&amp; profile-&gt;refCount == 0) ||
167              noRefCount== TRUE) {
168             deletedNum++;
169             uhash_removeElement(SHARED_DATA_HASHTABLE, e);
170 
171             /* unload the data */
172             usprep_unload(profile);
173 
174             if(key-&gt;name != NULL) {
175                 uprv_free(key-&gt;name);
176                 key-&gt;name=NULL;
177             }
178             if(key-&gt;path != NULL) {
179                 uprv_free(key-&gt;path);
180                 key-&gt;path=NULL;
181             }
182             uprv_free(profile);
183             uprv_free(key);
184         }
185 
186     }
<span class="line-modified">187     umtx_unlock(usprepMutex());</span>
188 
189     return deletedNum;
190 }
191 
192 /* Works just like ucnv_flushCache()
193 static int32_t
194 usprep_flushCache(){
195     return usprep_internal_flushCache(FALSE);
196 }
197 */
198 
199 static UBool U_CALLCONV usprep_cleanup(void){
200     if (SHARED_DATA_HASHTABLE != NULL) {
201         usprep_internal_flushCache(TRUE);
202         if (SHARED_DATA_HASHTABLE != NULL &amp;&amp; uhash_count(SHARED_DATA_HASHTABLE) == 0) {
203             uhash_close(SHARED_DATA_HASHTABLE);
204             SHARED_DATA_HASHTABLE = NULL;
205         }
206     }
207     gSharedDataInitOnce.reset();
</pre>
<hr />
<pre>
245 
246     /* open the data outside the mutex block */
247     //TODO: change the path
248     dataMemory=udata_openChoice(path, type, name, isSPrepAcceptable, NULL, errorCode);
249     if(U_FAILURE(*errorCode)) {
250         return FALSE;
251     }
252 
253     p=(const int32_t *)udata_getMemory(dataMemory);
254     pb=(const uint8_t *)(p+_SPREP_INDEX_TOP);
255     utrie_unserialize(&amp;_sprepTrie, pb, p[_SPREP_INDEX_TRIE_SIZE], errorCode);
256     _sprepTrie.getFoldingOffset=getSPrepFoldingOffset;
257 
258 
259     if(U_FAILURE(*errorCode)) {
260         udata_close(dataMemory);
261         return FALSE;
262     }
263 
264     /* in the mutex block, set the data for this process */
<span class="line-modified">265     umtx_lock(usprepMutex());</span>
266     if(profile-&gt;sprepData==NULL) {
267         profile-&gt;sprepData=dataMemory;
268         dataMemory=NULL;
269         uprv_memcpy(&amp;profile-&gt;indexes, p, sizeof(profile-&gt;indexes));
270         uprv_memcpy(&amp;profile-&gt;sprepTrie, &amp;_sprepTrie, sizeof(UTrie));
271     } else {
272         p=(const int32_t *)udata_getMemory(profile-&gt;sprepData);
273     }
<span class="line-modified">274     umtx_unlock(usprepMutex());</span>
275     /* initialize some variables */
276     profile-&gt;mappingData=(uint16_t *)((uint8_t *)(p+_SPREP_INDEX_TOP)+profile-&gt;indexes[_SPREP_INDEX_TRIE_SIZE]);
277 
278     u_getUnicodeVersion(normUnicodeVersion);
279     normUniVer = (normUnicodeVersion[0] &lt;&lt; 24) + (normUnicodeVersion[1] &lt;&lt; 16) +
280                  (normUnicodeVersion[2] &lt;&lt; 8 ) + (normUnicodeVersion[3]);
281     sprepUniVer = (dataVersion[0] &lt;&lt; 24) + (dataVersion[1] &lt;&lt; 16) +
282                   (dataVersion[2] &lt;&lt; 8 ) + (dataVersion[3]);
283     normCorrVer = profile-&gt;indexes[_SPREP_NORM_CORRECTNS_LAST_UNI_VERSION];
284 
285     if(U_FAILURE(*errorCode)){
286         udata_close(dataMemory);
287         return FALSE;
288     }
289     if( normUniVer &lt; sprepUniVer &amp;&amp; /* the Unicode version of SPREP file must be less than the Unicode Vesion of the normalization data */
290         normUniVer &lt; normCorrVer &amp;&amp; /* the Unicode version of the NormalizationCorrections.txt file should be less than the Unicode Vesion of the normalization data */
291         ((profile-&gt;indexes[_SPREP_OPTIONS] &amp; _SPREP_NORMALIZATION_ON) &gt; 0) /* normalization turned on*/
292       ){
293         *errorCode = U_INVALID_FORMAT_ERROR;
294         udata_close(dataMemory);
</pre>
<hr />
<pre>
311                   UErrorCode *status){
312 
313     UStringPrepProfile* profile = NULL;
314 
315     initCache(status);
316 
317     if(U_FAILURE(*status)){
318         return NULL;
319     }
320 
321     UStringPrepKey stackKey;
322     /*
323      * const is cast way to save malloc, strcpy and free calls
324      * we use the passed in pointers for fetching the data from the
325      * hash table which is safe
326      */
327     stackKey.name = (char*) name;
328     stackKey.path = (char*) path;
329 
330     /* fetch the data from the cache */
<span class="line-modified">331     umtx_lock(usprepMutex());</span>
332     profile = (UStringPrepProfile*) (uhash_get(SHARED_DATA_HASHTABLE,&amp;stackKey));
333     if(profile != NULL) {
334         profile-&gt;refCount++;
335     }
<span class="line-modified">336     umtx_unlock(usprepMutex());</span>
337 
338     if(profile == NULL) {
339         /* else load the data and put the data in the cache */
340         LocalMemory&lt;UStringPrepProfile&gt; newProfile;
341         if(newProfile.allocateInsteadAndReset() == NULL) {
342             *status = U_MEMORY_ALLOCATION_ERROR;
343             return NULL;
344         }
345 
346         /* load the data */
347         if(!loadData(newProfile.getAlias(), path, name, _SPREP_DATA_TYPE, status) || U_FAILURE(*status) ){
348             return NULL;
349         }
350 
351         /* get the options */
352         newProfile-&gt;doNFKC = (UBool)((newProfile-&gt;indexes[_SPREP_OPTIONS] &amp; _SPREP_NORMALIZATION_ON) &gt; 0);
353         newProfile-&gt;checkBiDi = (UBool)((newProfile-&gt;indexes[_SPREP_OPTIONS] &amp; _SPREP_CHECK_BIDI_ON) &gt; 0);
354 
355         LocalMemory&lt;UStringPrepKey&gt; key;
356         LocalMemory&lt;char&gt; keyName;
357         LocalMemory&lt;char&gt; keyPath;
358         if( key.allocateInsteadAndReset() == NULL ||
<span class="line-modified">359             keyName.allocateInsteadAndCopy(static_cast&lt;int32_t&gt;(uprv_strlen(name)+1)) == NULL ||</span>
360             (path != NULL &amp;&amp;
<span class="line-modified">361              keyPath.allocateInsteadAndCopy(static_cast&lt;int32_t&gt;(uprv_strlen(path)+1)) == NULL)</span>
362          ) {
363             *status = U_MEMORY_ALLOCATION_ERROR;
364             usprep_unload(newProfile.getAlias());
365             return NULL;
366         }
367 
<span class="line-modified">368         umtx_lock(usprepMutex());</span>
369         // If another thread already inserted the same key/value, refcount and cleanup our thread data
370         profile = (UStringPrepProfile*) (uhash_get(SHARED_DATA_HASHTABLE,&amp;stackKey));
371         if(profile != NULL) {
372             profile-&gt;refCount++;
373             usprep_unload(newProfile.getAlias());
374         }
375         else {
376             /* initialize the key members */
377             key-&gt;name = keyName.orphan();
378             uprv_strcpy(key-&gt;name, name);
379             if(path != NULL){
380                 key-&gt;path = keyPath.orphan();
381                 uprv_strcpy(key-&gt;path, path);
382             }
383             profile = newProfile.orphan();
384 
385             /* add the data object to the cache */
386             profile-&gt;refCount = 1;
387             uhash_put(SHARED_DATA_HASHTABLE, key.orphan(), profile, status);
388         }
<span class="line-modified">389         umtx_unlock(usprepMutex());</span>
390     }
391 
392     return profile;
393 }
394 
395 U_CAPI UStringPrepProfile* U_EXPORT2
396 usprep_open(const char* path,
397             const char* name,
398             UErrorCode* status){
399 
400     if(status == NULL || U_FAILURE(*status)){
401         return NULL;
402     }
403 
404     /* initialize the profile struct members */
405     return usprep_getProfile(path,name,status);
406 }
407 
408 U_CAPI UStringPrepProfile* U_EXPORT2
409 usprep_openByType(UStringPrepProfileType type,
410                   UErrorCode* status) {
411     if(status == NULL || U_FAILURE(*status)){
412         return NULL;
413     }
414     int32_t index = (int32_t)type;
415     if (index &lt; 0 || index &gt;= UPRV_LENGTHOF(PROFILE_NAMES)) {
416         *status = U_ILLEGAL_ARGUMENT_ERROR;
417         return NULL;
418     }
419     return usprep_open(NULL, PROFILE_NAMES[index], status);
420 }
421 
422 U_CAPI void U_EXPORT2
423 usprep_close(UStringPrepProfile* profile){
424     if(profile==NULL){
425         return;
426     }
427 
<span class="line-modified">428     umtx_lock(usprepMutex());</span>
429     /* decrement the ref count*/
430     if(profile-&gt;refCount &gt; 0){
431         profile-&gt;refCount--;
432     }
<span class="line-modified">433     umtx_unlock(usprepMutex());</span>
434 
435 }
436 
437 U_CFUNC void
438 uprv_syntaxError(const UChar* rules,
439                  int32_t pos,
440                  int32_t rulesLen,
441                  UParseError* parseError){
442     if(parseError == NULL){
443         return;
444     }
445     parseError-&gt;offset = pos;
446     parseError-&gt;line = 0 ; // we are not using line numbers
447 
448     // for pre-context
449     int32_t start = (pos &lt; U_PARSE_CONTEXT_LEN)? 0 : (pos - (U_PARSE_CONTEXT_LEN-1));
450     int32_t limit = pos;
451 
452     u_memcpy(parseError-&gt;preContext,rules+start,limit-start);
453     //null terminate the buffer
</pre>
<hr />
<pre>
714     int32_t b2Len = s2.length();
715     UCharDirection direction=U_CHAR_DIRECTION_COUNT, firstCharDir=U_CHAR_DIRECTION_COUNT;
716     UBool leftToRight=FALSE, rightToLeft=FALSE;
717     int32_t rtlPos =-1, ltrPos =-1;
718 
719     for(int32_t b2Index=0; b2Index&lt;b2Len;){
720         UChar32 ch = 0;
721         U16_NEXT(b2, b2Index, b2Len, ch);
722 
723         uint16_t result;
724         UTRIE_GET16(&amp;profile-&gt;sprepTrie,ch,result);
725 
726         int16_t value;
727         UBool isIndex;
728         UStringPrepType type = getValues(result, value, isIndex);
729 
730         if( type == USPREP_PROHIBITED ||
731             ((result &lt; _SPREP_TYPE_THRESHOLD) &amp;&amp; (result &amp; 0x01) /* first bit says it the code point is prohibited*/)
732            ){
733             *status = U_STRINGPREP_PROHIBITED_ERROR;
<span class="line-modified">734             uprv_syntaxError(b2, b2Index-U16_LENGTH(ch), b2Len, parseError);</span>
735             return 0;
736         }
737 
738         if(profile-&gt;checkBiDi) {
739             direction = ubidi_getClass(ch);
740             if(firstCharDir == U_CHAR_DIRECTION_COUNT){
741                 firstCharDir = direction;
742             }
743             if(direction == U_LEFT_TO_RIGHT){
744                 leftToRight = TRUE;
745                 ltrPos = b2Index-1;
746             }
747             if(direction == U_RIGHT_TO_LEFT || direction == U_RIGHT_TO_LEFT_ARABIC){
748                 rightToLeft = TRUE;
749                 rtlPos = b2Index-1;
750             }
751         }
752     }
753     if(profile-&gt;checkBiDi == TRUE){
754         // satisfy 2
</pre>
</td>
</tr>
</table>
<center><a href="ushape.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ustr_cnv.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>