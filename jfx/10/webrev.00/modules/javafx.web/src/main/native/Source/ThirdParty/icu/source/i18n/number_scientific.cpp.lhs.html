<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_scientific.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2017 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 #include &quot;unicode/utypes.h&quot;
  5 
  6 #if !UCONFIG_NO_FORMATTING
  7 
  8 #include &lt;cstdlib&gt;
  9 #include &quot;number_scientific.h&quot;
 10 #include &quot;number_utils.h&quot;
 11 #include &quot;number_stringbuilder.h&quot;
 12 #include &quot;unicode/unum.h&quot;
 13 #include &quot;number_microprops.h&quot;
 14 
 15 using namespace icu;
 16 using namespace icu::number;
 17 using namespace icu::number::impl;
 18 
 19 // NOTE: The object lifecycle of ScientificModifier and ScientificHandler differ greatly in Java and C++.
 20 //
 21 // During formatting, we need to provide an object with state (the exponent) as the inner modifier.
 22 //
 23 // In Java, where the priority is put on reducing object creations, the unsafe code path re-uses the
 24 // ScientificHandler as a ScientificModifier, and the safe code path pre-computes 25 ScientificModifier
 25 // instances.  This scheme reduces the number of object creations by 1 in both safe and unsafe.
 26 //
 27 // In C++, MicroProps provides a pre-allocated ScientificModifier, and ScientificHandler simply populates
 28 // the state (the exponent) into that ScientificModifier. There is no difference between safe and unsafe.
 29 
 30 ScientificModifier::ScientificModifier() : fExponent(0), fHandler(nullptr) {}
 31 
 32 void ScientificModifier::set(int32_t exponent, const ScientificHandler *handler) {
 33     // ScientificModifier should be set only once.
 34     U_ASSERT(fHandler == nullptr);
 35     fExponent = exponent;
 36     fHandler = handler;
 37 }
 38 
 39 int32_t ScientificModifier::apply(NumberStringBuilder &amp;output, int32_t /*leftIndex*/, int32_t rightIndex,
 40                                   UErrorCode &amp;status) const {
 41     // FIXME: Localized exponent separator location.
 42     int i = rightIndex;
 43     // Append the exponent separator and sign
 44     i += output.insert(
 45             i,
 46             fHandler-&gt;fSymbols-&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kExponentialSymbol),
 47             UNUM_EXPONENT_SYMBOL_FIELD,
 48             status);
 49     if (fExponent &lt; 0 &amp;&amp; fHandler-&gt;fSettings.fExponentSignDisplay != UNUM_SIGN_NEVER) {
 50         i += output.insert(
 51                 i,
 52                 fHandler-&gt;fSymbols
 53                         -&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kMinusSignSymbol),
 54                 UNUM_EXPONENT_SIGN_FIELD,
 55                 status);
 56     } else if (fExponent &gt;= 0 &amp;&amp; fHandler-&gt;fSettings.fExponentSignDisplay == UNUM_SIGN_ALWAYS) {
 57         i += output.insert(
 58                 i,
 59                 fHandler-&gt;fSymbols
 60                         -&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kPlusSignSymbol),
 61                 UNUM_EXPONENT_SIGN_FIELD,
 62                 status);
 63     }
 64     // Append the exponent digits (using a simple inline algorithm)
 65     int32_t disp = std::abs(fExponent);
 66     for (int j = 0; j &lt; fHandler-&gt;fSettings.fMinExponentDigits || disp &gt; 0; j++, disp /= 10) {
 67         auto d = static_cast&lt;int8_t&gt;(disp % 10);
 68         i += utils::insertDigitFromSymbols(
 69                 output,
 70                 i - j,
 71                 d,
 72                 *fHandler-&gt;fSymbols,
 73                 UNUM_EXPONENT_FIELD,
 74                 status);
 75     }
 76     return i - rightIndex;
 77 }
 78 
<a name="1" id="anc1"></a><span class="line-modified"> 79 int32_t ScientificModifier::getPrefixLength(UErrorCode &amp;status) const {</span>
<span class="line-removed"> 80     (void)status;</span>
 81     // TODO: Localized exponent separator location.
 82     return 0;
 83 }
 84 
<a name="2" id="anc2"></a><span class="line-modified"> 85 int32_t ScientificModifier::getCodePointCount(UErrorCode &amp;status) const {</span>
<span class="line-modified"> 86     (void)status;</span>
<span class="line-modified"> 87     // This method is not used for strong modifiers.</span>
<span class="line-modified"> 88     U_ASSERT(false);</span>
<span class="line-modified"> 89     return 0;</span>
 90 }
 91 
 92 bool ScientificModifier::isStrong() const {
 93     // Scientific is always strong
 94     return true;
 95 }
 96 
<a name="3" id="anc3"></a>



















 97 // Note: Visual Studio does not compile this function without full name space. Why?
 98 icu::number::impl::ScientificHandler::ScientificHandler(const Notation *notation, const DecimalFormatSymbols *symbols,
 99     const MicroPropsGenerator *parent) :
100     fSettings(notation-&gt;fUnion.scientific), fSymbols(symbols), fParent(parent) {}
101 
102 void ScientificHandler::processQuantity(DecimalQuantity &amp;quantity, MicroProps &amp;micros,
103                                         UErrorCode &amp;status) const {
104     fParent-&gt;processQuantity(quantity, micros, status);
105     if (U_FAILURE(status)) { return; }
106 
107     // Treat zero as if it had magnitude 0
108     int32_t exponent;
109     if (quantity.isZero()) {
110         if (fSettings.fRequireMinInt &amp;&amp; micros.rounder.isSignificantDigits()) {
111             // Show &quot;00.000E0&quot; on pattern &quot;00.000E0&quot;
112             micros.rounder.apply(quantity, fSettings.fEngineeringInterval, status);
113             exponent = 0;
114         } else {
115             micros.rounder.apply(quantity, status);
116             exponent = 0;
117         }
118     } else {
119         exponent = -micros.rounder.chooseMultiplierAndApply(quantity, *this, status);
120     }
121 
122     // Use MicroProps&#39;s helper ScientificModifier and save it as the modInner.
123     ScientificModifier &amp;mod = micros.helpers.scientificModifier;
124     mod.set(exponent, this);
125     micros.modInner = &amp;mod;
126 
127     // We already performed rounding. Do not perform it again.
128     micros.rounder = RoundingImpl::passThrough();
129 }
130 
131 int32_t ScientificHandler::getMultiplier(int32_t magnitude) const {
132     int32_t interval = fSettings.fEngineeringInterval;
133     int32_t digitsShown;
134     if (fSettings.fRequireMinInt) {
135         // For patterns like &quot;000.00E0&quot; and &quot;.00E0&quot;
136         digitsShown = interval;
137     } else if (interval &lt;= 1) {
138         // For patterns like &quot;0.00E0&quot; and &quot;@@@E0&quot;
139         digitsShown = 1;
140     } else {
141         // For patterns like &quot;##0.00&quot;
142         digitsShown = ((magnitude % interval + interval) % interval) + 1;
143     }
144     return digitsShown - magnitude - 1;
145 }
146 
147 #endif /* #if !UCONFIG_NO_FORMATTING */
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>