<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/unumberformatter.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="unum.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="unumsys.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/unumberformatter.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 // © 2018 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 #include &quot;unicode/utypes.h&quot;
  5 
  6 #if !UCONFIG_NO_FORMATTING
  7 #ifndef __UNUMBERFORMATTER_H__
  8 #define __UNUMBERFORMATTER_H__
  9 

 10 #include &quot;unicode/ufieldpositer.h&quot;
 11 #include &quot;unicode/umisc.h&quot;

 12 
 13 
 14 /**
 15  * \file
 16  * \brief C-compatible API for localized number formatting; not recommended for C++.
 17  *
 18  * This is the C-compatible version of the NumberFormatter API introduced in ICU 60. C++ users should
 19  * include unicode/numberformatter.h and use the proper C++ APIs.
 20  *
 21  * The C API accepts a number skeleton string for specifying the settings for formatting, which covers a
 22  * very large subset of all possible number formatting features. For more information on number skeleton
 23  * strings, see unicode/numberformatter.h.
 24  *
 25  * When using UNumberFormatter, which is treated as immutable, the results are exported to a mutable
 26  * UFormattedNumber object, which you subsequently use for populating your string buffer or iterating over
 27  * the fields.
 28  *
 29  * Example code:
 30  * &lt;pre&gt;
 31  * // Setup:
</pre>
<hr />
<pre>
 74  * // No need to do any cleanup since we are using LocalPointer.
 75  * &lt;/pre&gt;
 76  */
 77 
 78 
 79 #ifndef U_HIDE_DRAFT_API
 80 /**
 81  * An enum declaring how to render units, including currencies. Example outputs when formatting 123 USD and 123
 82  * meters in &lt;em&gt;en-CA&lt;/em&gt;:
 83  *
 84  * &lt;p&gt;
 85  * &lt;ul&gt;
 86  * &lt;li&gt;NARROW*: &quot;$123.00&quot; and &quot;123 m&quot;
 87  * &lt;li&gt;SHORT: &quot;US$ 123.00&quot; and &quot;123 m&quot;
 88  * &lt;li&gt;FULL_NAME: &quot;123.00 US dollars&quot; and &quot;123 meters&quot;
 89  * &lt;li&gt;ISO_CODE: &quot;USD 123.00&quot; and undefined behavior
 90  * &lt;li&gt;HIDDEN: &quot;123.00&quot; and &quot;123&quot;
 91  * &lt;/ul&gt;
 92  *
 93  * &lt;p&gt;
<span class="line-modified"> 94  * This enum is similar to {@link com.ibm.icu.text.MeasureFormat.FormatWidth}.</span>
 95  *
 96  * @draft ICU 60
 97  */
 98 typedef enum UNumberUnitWidth {
 99     /**
100      * Print an abbreviated version of the unit name. Similar to SHORT, but always use the shortest available
101      * abbreviation or symbol. This option can be used when the context hints at the identity of the unit. For more
102      * information on the difference between NARROW and SHORT, see SHORT.
103      *
104      * &lt;p&gt;
105      * In CLDR, this option corresponds to the &quot;Narrow&quot; format for measure units and the &quot;¤¤¤¤¤&quot; placeholder for
106      * currencies.
107      *
108      * @draft ICU 60
109      */
110             UNUM_UNIT_WIDTH_NARROW,
111 
112     /**
113      * Print an abbreviated version of the unit name. Similar to NARROW, but use a slightly wider abbreviation or
114      * symbol when there may be ambiguity. This is the default behavior.
</pre>
<hr />
<pre>
173  * outputs for 1234 and 1234567 in &lt;em&gt;en-IN&lt;/em&gt;:
174  *
175  * &lt;ul&gt;
176  * &lt;li&gt;OFF: 1234 and 12345
177  * &lt;li&gt;MIN2: 1234 and 12,34,567
178  * &lt;li&gt;AUTO: 1,234 and 12,34,567
179  * &lt;li&gt;ON_ALIGNED: 1,234 and 12,34,567
180  * &lt;li&gt;THOUSANDS: 1,234 and 1,234,567
181  * &lt;/ul&gt;
182  *
183  * &lt;p&gt;
184  * The default is AUTO, which displays grouping separators unless the locale data says that grouping
185  * is not customary. To force grouping for all numbers greater than 1000 consistently across locales,
186  * use ON_ALIGNED. On the other hand, to display grouping less frequently than the default, use MIN2
187  * or OFF. See the docs of each option for details.
188  *
189  * &lt;p&gt;
190  * Note: This enum specifies the strategy for grouping sizes. To set which character to use as the
191  * grouping separator, use the &quot;symbols&quot; setter.
192  *
<span class="line-modified">193  * @draft ICU 61 -- TODO: This should be renamed to UNumberGroupingStrategy before promoting to stable,</span>
<span class="line-removed">194  * for consistency with the other enums.</span>
195  */
<span class="line-modified">196 typedef enum UGroupingStrategy {</span>
197     /**
198      * Do not display grouping separators in any locale.
199      *
200      * @draft ICU 61
201      */
202             UNUM_GROUPING_OFF,
203 
204     /**
205      * Display grouping using locale defaults, except do not show grouping on values smaller than
206      * 10000 (such that there is a &lt;em&gt;minimum of two digits&lt;/em&gt; before the first separator).
207      *
208      * &lt;p&gt;
209      * Note that locales may restrict grouping separators to be displayed only on 1 million or
210      * greater (for example, ee and hu) or disable grouping altogether (for example, bg currency).
211      *
212      * &lt;p&gt;
213      * Locale data is used to determine whether to separate larger numbers into groups of 2
214      * (customary in South Asia) or groups of 3 (customary in Europe and the Americas).
215      *
216      * @draft ICU 61
</pre>
<hr />
<pre>
237      *
238      * &lt;p&gt;
239      * This option ignores the locale data that restricts or disables grouping, described in MIN2 and
240      * AUTO. This option may be useful to normalize the alignment of numbers, such as in a
241      * spreadsheet.
242      *
243      * &lt;p&gt;
244      * Locale data is used to determine whether to separate larger numbers into groups of 2
245      * (customary in South Asia) or groups of 3 (customary in Europe and the Americas).
246      *
247      * @draft ICU 61
248      */
249             UNUM_GROUPING_ON_ALIGNED,
250 
251     /**
252      * Use the Western defaults: groups of 3 and enabled for all numbers 1000 or greater. Do not use
253      * locale data for determining the grouping strategy.
254      *
255      * @draft ICU 61
256      */
<span class="line-modified">257             UNUM_GROUPING_THOUSANDS,</span>
258 


259     /**
<span class="line-modified">260      * One more than the highest UGroupingStrategy value.</span>
261      *
262      * @internal ICU 62: The numeric value may change over time; see ICU ticket #12420.
263      */
264             UNUM_GROUPING_COUNT




265 
<span class="line-removed">266 } UGroupingStrategy;</span>
267 #endif  /* U_HIDE_DRAFT_API */
268 
269 #ifndef U_HIDE_DRAFT_API
270 /**
271  * An enum declaring how to denote positive and negative numbers. Example outputs when formatting
272  * 123, 0, and -123 in &lt;em&gt;en-US&lt;/em&gt;:
273  *
274  * &lt;ul&gt;
275  * &lt;li&gt;AUTO: &quot;123&quot;, &quot;0&quot;, and &quot;-123&quot;
276  * &lt;li&gt;ALWAYS: &quot;+123&quot;, &quot;+0&quot;, and &quot;-123&quot;
277  * &lt;li&gt;NEVER: &quot;123&quot;, &quot;0&quot;, and &quot;123&quot;
278  * &lt;li&gt;ACCOUNTING: &quot;$123&quot;, &quot;$0&quot;, and &quot;($123)&quot;
279  * &lt;li&gt;ACCOUNTING_ALWAYS: &quot;+$123&quot;, &quot;+$0&quot;, and &quot;($123)&quot;
280  * &lt;li&gt;EXCEPT_ZERO: &quot;+123&quot;, &quot;0&quot;, and &quot;-123&quot;
281  * &lt;li&gt;ACCOUNTING_EXCEPT_ZERO: &quot;+$123&quot;, &quot;$0&quot;, and &quot;($123)&quot;
282  * &lt;/ul&gt;
283  *
284  * &lt;p&gt;
285  * The exact format, including the position and the code point of the sign, differ by locale.
286  *
</pre>
<hr />
<pre>
354             UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO,
355 
356     /**
357      * One more than the highest UNumberSignDisplay value.
358      *
359      * @internal ICU 60: The numeric value may change over time; see ICU ticket #12420.
360      */
361             UNUM_SIGN_COUNT
362 } UNumberSignDisplay;
363 #endif  /* U_HIDE_DRAFT_API */
364 
365 #ifndef U_HIDE_DRAFT_API
366 /**
367  * An enum declaring how to render the decimal separator.
368  *
369  * &lt;p&gt;
370  * &lt;ul&gt;
371  * &lt;li&gt;UNUM_DECIMAL_SEPARATOR_AUTO: &quot;1&quot;, &quot;1.1&quot;
372  * &lt;li&gt;UNUM_DECIMAL_SEPARATOR_ALWAYS: &quot;1.&quot;, &quot;1.1&quot;
373  * &lt;/ul&gt;


374  */
375 typedef enum UNumberDecimalSeparatorDisplay {
376     /**
377      * Show the decimal separator when there are one or more digits to display after the separator, and do not show
378      * it otherwise. This is the default behavior.
379      *
380      * @draft ICU 60
381      */
382             UNUM_DECIMAL_SEPARATOR_AUTO,
383 
384     /**
385      * Always show the decimal separator, even if there are no digits to display after the separator.
386      *
387      * @draft ICU 60
388      */
389             UNUM_DECIMAL_SEPARATOR_ALWAYS,
390 
391     /**
392      * One more than the highest UNumberDecimalSeparatorDisplay value.
393      *
394      * @internal ICU 60: The numeric value may change over time; see ICU ticket #12420.
395      */
396             UNUM_DECIMAL_SEPARATOR_COUNT
397 } UNumberDecimalSeparatorDisplay;
398 #endif  /* U_HIDE_DRAFT_API */
399 
<span class="line-modified">400 #ifndef U_HIDE_DRAFT_API</span>
401 /**
402  * C-compatible version of icu::number::LocalizedNumberFormatter.
403  *
404  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
405  *
<span class="line-modified">406  * @draft ICU 62</span>
407  */
<span class="line-removed">408 struct UNumberFormatter;</span>
409 typedef struct UNumberFormatter UNumberFormatter;
410 
<span class="line-modified">411 </span>
412 /**
413  * C-compatible version of icu::number::FormattedNumber.
414  *
415  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
416  *
<span class="line-modified">417  * @draft ICU 62</span>
418  */
<span class="line-removed">419 struct UFormattedNumber;</span>
420 typedef struct UFormattedNumber UFormattedNumber;
421 
422 
423 /**
424  * Creates a new UNumberFormatter for the given skeleton string and locale. This is currently the only
425  * method for creating a new UNumberFormatter.
426  *
427  * Objects of type UNumberFormatter returned by this method are threadsafe.
428  *
429  * For more details on skeleton strings, see the documentation in numberformatter.h. For more details on
430  * the usage of this API, see the documentation at the top of unumberformatter.h.
431  *
432  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
433  *
434  * @param skeleton The skeleton string, like u&quot;percent precision-integer&quot;
435  * @param skeletonLen The number of UChars in the skeleton string, or -1 it it is NUL-terminated.
436  * @param locale The NUL-terminated locale ID.
437  * @param ec Set if an error occurs.
<span class="line-modified">438  * @draft ICU 62</span>
439  */
<span class="line-modified">440 U_DRAFT UNumberFormatter* U_EXPORT2</span>
441 unumf_openForSkeletonAndLocale(const UChar* skeleton, int32_t skeletonLen, const char* locale,
442                                UErrorCode* ec);
443 
444 

445 /**
<span class="line-modified">446  * Creates a new UFormattedNumber for holding the result of a number formatting operation.</span>

447  *
<span class="line-modified">448  * Objects of type UFormattedNumber are not guaranteed to be threadsafe.</span>
<span class="line-modified">449  *</span>
<span class="line-modified">450  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.</span>















451  *
452  * @param ec Set if an error occurs.
<span class="line-modified">453  * @draft ICU 62</span>
454  */
<span class="line-modified">455 U_DRAFT UFormattedNumber* U_EXPORT2</span>
456 unumf_openResult(UErrorCode* ec);
457 
458 
459 /**
460  * Uses a UNumberFormatter to format an integer to a UFormattedNumber. A string, field position, and other
461  * information can be retrieved from the UFormattedNumber.
462  *
463  * The UNumberFormatter can be shared between threads. Each thread should have its own local
464  * UFormattedNumber, however, for storing the result of the formatting operation.
465  *
466  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
467  *
468  * @param uformatter A formatter object created by unumf_openForSkeletonAndLocale or similar.
469  * @param value The number to be formatted.
470  * @param uresult The object that will be mutated to store the result; see unumf_openResult.
471  * @param ec Set if an error occurs.
<span class="line-modified">472  * @draft ICU 62</span>
473  */
<span class="line-modified">474 U_DRAFT void U_EXPORT2</span>
475 unumf_formatInt(const UNumberFormatter* uformatter, int64_t value, UFormattedNumber* uresult,
476                 UErrorCode* ec);
477 
478 
479 /**
480  * Uses a UNumberFormatter to format a double to a UFormattedNumber. A string, field position, and other
481  * information can be retrieved from the UFormattedNumber.
482  *
483  * The UNumberFormatter can be shared between threads. Each thread should have its own local
484  * UFormattedNumber, however, for storing the result of the formatting operation.
485  *
486  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
487  *
488  * @param uformatter A formatter object created by unumf_openForSkeletonAndLocale or similar.
489  * @param value The number to be formatted.
490  * @param uresult The object that will be mutated to store the result; see unumf_openResult.
491  * @param ec Set if an error occurs.
<span class="line-modified">492  * @draft ICU 62</span>
493  */
<span class="line-modified">494 U_DRAFT void U_EXPORT2</span>
495 unumf_formatDouble(const UNumberFormatter* uformatter, double value, UFormattedNumber* uresult,
496                    UErrorCode* ec);
497 
498 
499 /**
500  * Uses a UNumberFormatter to format a decimal number to a UFormattedNumber. A string, field position, and
501  * other information can be retrieved from the UFormattedNumber.
502  *
503  * The UNumberFormatter can be shared between threads. Each thread should have its own local
504  * UFormattedNumber, however, for storing the result of the formatting operation.
505  *
506  * The syntax of the unformatted number is a &quot;numeric string&quot; as defined in the Decimal Arithmetic
507  * Specification, available at http://speleotrove.com/decimal
508  *
509  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
510  *
511  * @param uformatter A formatter object created by unumf_openForSkeletonAndLocale or similar.
512  * @param value The numeric string to be formatted.
513  * @param valueLen The length of the numeric string, or -1 if it is NUL-terminated.
514  * @param uresult The object that will be mutated to store the result; see unumf_openResult.
515  * @param ec Set if an error occurs.
<span class="line-modified">516  * @draft ICU 62</span>
517  */
<span class="line-modified">518 U_DRAFT void U_EXPORT2</span>
519 unumf_formatDecimal(const UNumberFormatter* uformatter, const char* value, int32_t valueLen,
520                     UFormattedNumber* uresult, UErrorCode* ec);
521 



















522 
523 /**
524  * Extracts the result number string out of a UFormattedNumber to a UChar buffer if possible.
525  * If bufferCapacity is greater than the required length, a terminating NUL is written.
526  * If bufferCapacity is less than the required length, an error code is set.
527  *





528  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
529  *
530  * @param uresult The object containing the formatted number.
531  * @param buffer Where to save the string output.
532  * @param bufferCapacity The number of UChars available in the buffer.
533  * @param ec Set if an error occurs.
534  * @return The required length.
<span class="line-modified">535  * @draft ICU 62</span>
536  */
<span class="line-modified">537 U_DRAFT int32_t U_EXPORT2</span>
538 unumf_resultToString(const UFormattedNumber* uresult, UChar* buffer, int32_t bufferCapacity,
539                      UErrorCode* ec);
540 
541 
542 /**
543  * Determines the start and end indices of the next occurrence of the given &lt;em&gt;field&lt;/em&gt; in the
544  * output string. This allows you to determine the locations of, for example, the integer part,
545  * fraction part, or symbols.
546  *


547  * If a field occurs just once, calling this method will find that occurrence and return it. If a
548  * field occurs multiple times, this method may be called repeatedly with the following pattern:
549  *
550  * &lt;pre&gt;
551  * UFieldPosition ufpos = {UNUM_GROUPING_SEPARATOR_FIELD, 0, 0};
552  * while (unumf_resultNextFieldPosition(uresult, ufpos, &amp;ec)) {
553  *   // do something with ufpos.
554  * }
555  * &lt;/pre&gt;
556  *
557  * This method is useful if you know which field to query. If you want all available field position
558  * information, use unumf_resultGetAllFieldPositions().
559  *
560  * NOTE: All fields of the UFieldPosition must be initialized before calling this method.
561  *
<span class="line-modified">562  * @param fieldPosition</span>

563  *            Input+output variable. On input, the &quot;field&quot; property determines which field to look up,
564  *            and the &quot;endIndex&quot; property determines where to begin the search. On output, the
565  *            &quot;beginIndex&quot; field is set to the beginning of the first occurrence of the field after the
566  *            input &quot;endIndex&quot;, and &quot;endIndex&quot; is set to the end of that occurrence of the field
567  *            (exclusive index). If a field position is not found, the FieldPosition is not changed and
568  *            the method returns FALSE.
569  * @param ec Set if an error occurs.
<span class="line-modified">570  * @draft ICU 62</span>
571  */
<span class="line-modified">572 U_DRAFT UBool U_EXPORT2</span>
573 unumf_resultNextFieldPosition(const UFormattedNumber* uresult, UFieldPosition* ufpos, UErrorCode* ec);
574 
575 
576 /**
577  * Populates the given iterator with all fields in the formatted output string. This allows you to
578  * determine the locations of the integer part, fraction part, and sign.
579  *
<span class="line-modified">580  * If you need information on only one field, use unumf_resultNextFieldPosition().</span>



581  *
582  * @param uresult The object containing the formatted number.
<span class="line-modified">583  * @param fpositer</span>
584  *         A pointer to a UFieldPositionIterator created by {@link #ufieldpositer_open}. Iteration
585  *         information already present in the UFieldPositionIterator is deleted, and the iterator is reset
586  *         to apply to the fields in the formatted string created by this function call. The field values
587  *         and indexes returned by {@link #ufieldpositer_next} represent fields denoted by
588  *         the UNumberFormatFields enum. Fields are not returned in a guaranteed order. Fields cannot
589  *         overlap, but they may nest. For example, 1234 could format as &quot;1,234&quot; which might consist of a
590  *         grouping separator field for &#39;,&#39; and an integer field encompassing the entire string.
591  * @param ec Set if an error occurs.
<span class="line-modified">592  * @draft ICU 62</span>
593  */
<span class="line-modified">594 U_DRAFT void U_EXPORT2</span>
595 unumf_resultGetAllFieldPositions(const UFormattedNumber* uresult, UFieldPositionIterator* ufpositer,
596                                  UErrorCode* ec);
597 
598 
599 /**
600  * Releases the UNumberFormatter created by unumf_openForSkeletonAndLocale().
601  *
<span class="line-removed">602  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.</span>
<span class="line-removed">603  *</span>
604  * @param uformatter An object created by unumf_openForSkeletonAndLocale().
<span class="line-modified">605  * @draft ICU 62</span>
606  */
<span class="line-modified">607 U_DRAFT void U_EXPORT2</span>
608 unumf_close(UNumberFormatter* uformatter);
609 
610 
611 /**
612  * Releases the UFormattedNumber created by unumf_openResult().
613  *
<span class="line-removed">614  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.</span>
<span class="line-removed">615  *</span>
616  * @param uresult An object created by unumf_openResult().
<span class="line-modified">617  * @draft ICU 62</span>
618  */
<span class="line-modified">619 U_DRAFT void U_EXPORT2</span>
620 unumf_closeResult(UFormattedNumber* uresult);
621 
622 
623 #if U_SHOW_CPLUSPLUS_API
624 U_NAMESPACE_BEGIN
625 
626 /**
627  * \class LocalUNumberFormatterPointer
628  * &quot;Smart pointer&quot; class; closes a UNumberFormatter via unumf_close().
629  * For most methods see the LocalPointerBase base class.
630  *
631  * Usage:
632  * &lt;pre&gt;
633  * LocalUNumberFormatterPointer uformatter(unumf_openForSkeletonAndLocale(...));
634  * // no need to explicitly call unumf_close()
635  * &lt;/pre&gt;
636  *
637  * @see LocalPointerBase
638  * @see LocalPointer
<span class="line-modified">639  * @draft ICU 62</span>
640  */
641 U_DEFINE_LOCAL_OPEN_POINTER(LocalUNumberFormatterPointer, UNumberFormatter, unumf_close);
642 
643 /**
<span class="line-modified">644  * \class LocalUNumberFormatterPointer</span>
645  * &quot;Smart pointer&quot; class; closes a UFormattedNumber via unumf_closeResult().
646  * For most methods see the LocalPointerBase base class.
647  *
648  * Usage:
649  * &lt;pre&gt;
650  * LocalUFormattedNumberPointer uformatter(unumf_openResult(...));
651  * // no need to explicitly call unumf_closeResult()
652  * &lt;/pre&gt;
653  *
654  * @see LocalPointerBase
655  * @see LocalPointer
<span class="line-modified">656  * @draft ICU 62</span>
657  */
658 U_DEFINE_LOCAL_OPEN_POINTER(LocalUFormattedNumberPointer, UFormattedNumber, unumf_closeResult);
659 
660 U_NAMESPACE_END
661 #endif // U_SHOW_CPLUSPLUS_API
662 
<span class="line-removed">663 #endif  /* U_HIDE_DRAFT_API */</span>
<span class="line-removed">664 </span>
665 #endif //__UNUMBERFORMATTER_H__
666 #endif /* #if !UCONFIG_NO_FORMATTING */
<span class="line-removed">667 </span>
<span class="line-removed">668 </span>
<span class="line-removed">669 </span>
<span class="line-removed">670 </span>
<span class="line-removed">671 </span>
<span class="line-removed">672 </span>
<span class="line-removed">673 </span>
<span class="line-removed">674 </span>
<span class="line-removed">675 </span>
<span class="line-removed">676 </span>
<span class="line-removed">677 </span>
<span class="line-removed">678 </span>
<span class="line-removed">679 </span>
<span class="line-removed">680 </span>
<span class="line-removed">681 </span>
<span class="line-removed">682 </span>
<span class="line-removed">683 </span>
<span class="line-removed">684 </span>
<span class="line-removed">685 </span>
<span class="line-removed">686 </span>
<span class="line-removed">687 </span>
<span class="line-removed">688 </span>
<span class="line-removed">689 </span>
<span class="line-removed">690 </span>
<span class="line-removed">691 </span>
<span class="line-removed">692 </span>
<span class="line-removed">693 </span>
<span class="line-removed">694 </span>
<span class="line-removed">695 </span>
<span class="line-removed">696 </span>
<span class="line-removed">697 </span>
<span class="line-removed">698 </span>
<span class="line-removed">699 </span>
<span class="line-removed">700 </span>
<span class="line-removed">701 </span>
<span class="line-removed">702 </span>
<span class="line-removed">703 </span>
<span class="line-removed">704 </span>
<span class="line-removed">705 </span>
<span class="line-removed">706 </span>
<span class="line-removed">707 </span>
<span class="line-removed">708 </span>
<span class="line-removed">709 </span>
<span class="line-removed">710 </span>
<span class="line-removed">711 </span>
<span class="line-removed">712 </span>
<span class="line-removed">713 </span>
<span class="line-removed">714 </span>
<span class="line-removed">715 </span>
<span class="line-removed">716 </span>
<span class="line-removed">717 </span>
</pre>
</td>
<td>
<hr />
<pre>
  1 // © 2018 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 #include &quot;unicode/utypes.h&quot;
  5 
  6 #if !UCONFIG_NO_FORMATTING
  7 #ifndef __UNUMBERFORMATTER_H__
  8 #define __UNUMBERFORMATTER_H__
  9 
<span class="line-added"> 10 #include &quot;unicode/parseerr.h&quot;</span>
 11 #include &quot;unicode/ufieldpositer.h&quot;
 12 #include &quot;unicode/umisc.h&quot;
<span class="line-added"> 13 #include &quot;unicode/uformattedvalue.h&quot;</span>
 14 
 15 
 16 /**
 17  * \file
 18  * \brief C-compatible API for localized number formatting; not recommended for C++.
 19  *
 20  * This is the C-compatible version of the NumberFormatter API introduced in ICU 60. C++ users should
 21  * include unicode/numberformatter.h and use the proper C++ APIs.
 22  *
 23  * The C API accepts a number skeleton string for specifying the settings for formatting, which covers a
 24  * very large subset of all possible number formatting features. For more information on number skeleton
 25  * strings, see unicode/numberformatter.h.
 26  *
 27  * When using UNumberFormatter, which is treated as immutable, the results are exported to a mutable
 28  * UFormattedNumber object, which you subsequently use for populating your string buffer or iterating over
 29  * the fields.
 30  *
 31  * Example code:
 32  * &lt;pre&gt;
 33  * // Setup:
</pre>
<hr />
<pre>
 76  * // No need to do any cleanup since we are using LocalPointer.
 77  * &lt;/pre&gt;
 78  */
 79 
 80 
 81 #ifndef U_HIDE_DRAFT_API
 82 /**
 83  * An enum declaring how to render units, including currencies. Example outputs when formatting 123 USD and 123
 84  * meters in &lt;em&gt;en-CA&lt;/em&gt;:
 85  *
 86  * &lt;p&gt;
 87  * &lt;ul&gt;
 88  * &lt;li&gt;NARROW*: &quot;$123.00&quot; and &quot;123 m&quot;
 89  * &lt;li&gt;SHORT: &quot;US$ 123.00&quot; and &quot;123 m&quot;
 90  * &lt;li&gt;FULL_NAME: &quot;123.00 US dollars&quot; and &quot;123 meters&quot;
 91  * &lt;li&gt;ISO_CODE: &quot;USD 123.00&quot; and undefined behavior
 92  * &lt;li&gt;HIDDEN: &quot;123.00&quot; and &quot;123&quot;
 93  * &lt;/ul&gt;
 94  *
 95  * &lt;p&gt;
<span class="line-modified"> 96  * This enum is similar to {@link UMeasureFormatWidth}.</span>
 97  *
 98  * @draft ICU 60
 99  */
100 typedef enum UNumberUnitWidth {
101     /**
102      * Print an abbreviated version of the unit name. Similar to SHORT, but always use the shortest available
103      * abbreviation or symbol. This option can be used when the context hints at the identity of the unit. For more
104      * information on the difference between NARROW and SHORT, see SHORT.
105      *
106      * &lt;p&gt;
107      * In CLDR, this option corresponds to the &quot;Narrow&quot; format for measure units and the &quot;¤¤¤¤¤&quot; placeholder for
108      * currencies.
109      *
110      * @draft ICU 60
111      */
112             UNUM_UNIT_WIDTH_NARROW,
113 
114     /**
115      * Print an abbreviated version of the unit name. Similar to NARROW, but use a slightly wider abbreviation or
116      * symbol when there may be ambiguity. This is the default behavior.
</pre>
<hr />
<pre>
175  * outputs for 1234 and 1234567 in &lt;em&gt;en-IN&lt;/em&gt;:
176  *
177  * &lt;ul&gt;
178  * &lt;li&gt;OFF: 1234 and 12345
179  * &lt;li&gt;MIN2: 1234 and 12,34,567
180  * &lt;li&gt;AUTO: 1,234 and 12,34,567
181  * &lt;li&gt;ON_ALIGNED: 1,234 and 12,34,567
182  * &lt;li&gt;THOUSANDS: 1,234 and 1,234,567
183  * &lt;/ul&gt;
184  *
185  * &lt;p&gt;
186  * The default is AUTO, which displays grouping separators unless the locale data says that grouping
187  * is not customary. To force grouping for all numbers greater than 1000 consistently across locales,
188  * use ON_ALIGNED. On the other hand, to display grouping less frequently than the default, use MIN2
189  * or OFF. See the docs of each option for details.
190  *
191  * &lt;p&gt;
192  * Note: This enum specifies the strategy for grouping sizes. To set which character to use as the
193  * grouping separator, use the &quot;symbols&quot; setter.
194  *
<span class="line-modified">195  * @draft ICU 63</span>

196  */
<span class="line-modified">197 typedef enum UNumberGroupingStrategy {</span>
198     /**
199      * Do not display grouping separators in any locale.
200      *
201      * @draft ICU 61
202      */
203             UNUM_GROUPING_OFF,
204 
205     /**
206      * Display grouping using locale defaults, except do not show grouping on values smaller than
207      * 10000 (such that there is a &lt;em&gt;minimum of two digits&lt;/em&gt; before the first separator).
208      *
209      * &lt;p&gt;
210      * Note that locales may restrict grouping separators to be displayed only on 1 million or
211      * greater (for example, ee and hu) or disable grouping altogether (for example, bg currency).
212      *
213      * &lt;p&gt;
214      * Locale data is used to determine whether to separate larger numbers into groups of 2
215      * (customary in South Asia) or groups of 3 (customary in Europe and the Americas).
216      *
217      * @draft ICU 61
</pre>
<hr />
<pre>
238      *
239      * &lt;p&gt;
240      * This option ignores the locale data that restricts or disables grouping, described in MIN2 and
241      * AUTO. This option may be useful to normalize the alignment of numbers, such as in a
242      * spreadsheet.
243      *
244      * &lt;p&gt;
245      * Locale data is used to determine whether to separate larger numbers into groups of 2
246      * (customary in South Asia) or groups of 3 (customary in Europe and the Americas).
247      *
248      * @draft ICU 61
249      */
250             UNUM_GROUPING_ON_ALIGNED,
251 
252     /**
253      * Use the Western defaults: groups of 3 and enabled for all numbers 1000 or greater. Do not use
254      * locale data for determining the grouping strategy.
255      *
256      * @draft ICU 61
257      */
<span class="line-modified">258             UNUM_GROUPING_THOUSANDS</span>
259 
<span class="line-added">260 #ifndef U_HIDE_INTERNAL_API</span>
<span class="line-added">261     ,</span>
262     /**
<span class="line-modified">263      * One more than the highest UNumberGroupingStrategy value.</span>
264      *
265      * @internal ICU 62: The numeric value may change over time; see ICU ticket #12420.
266      */
267             UNUM_GROUPING_COUNT
<span class="line-added">268 #endif  /* U_HIDE_INTERNAL_API */</span>
<span class="line-added">269 </span>
<span class="line-added">270 } UNumberGroupingStrategy;</span>
<span class="line-added">271 </span>
272 

273 #endif  /* U_HIDE_DRAFT_API */
274 
275 #ifndef U_HIDE_DRAFT_API
276 /**
277  * An enum declaring how to denote positive and negative numbers. Example outputs when formatting
278  * 123, 0, and -123 in &lt;em&gt;en-US&lt;/em&gt;:
279  *
280  * &lt;ul&gt;
281  * &lt;li&gt;AUTO: &quot;123&quot;, &quot;0&quot;, and &quot;-123&quot;
282  * &lt;li&gt;ALWAYS: &quot;+123&quot;, &quot;+0&quot;, and &quot;-123&quot;
283  * &lt;li&gt;NEVER: &quot;123&quot;, &quot;0&quot;, and &quot;123&quot;
284  * &lt;li&gt;ACCOUNTING: &quot;$123&quot;, &quot;$0&quot;, and &quot;($123)&quot;
285  * &lt;li&gt;ACCOUNTING_ALWAYS: &quot;+$123&quot;, &quot;+$0&quot;, and &quot;($123)&quot;
286  * &lt;li&gt;EXCEPT_ZERO: &quot;+123&quot;, &quot;0&quot;, and &quot;-123&quot;
287  * &lt;li&gt;ACCOUNTING_EXCEPT_ZERO: &quot;+$123&quot;, &quot;$0&quot;, and &quot;($123)&quot;
288  * &lt;/ul&gt;
289  *
290  * &lt;p&gt;
291  * The exact format, including the position and the code point of the sign, differ by locale.
292  *
</pre>
<hr />
<pre>
360             UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO,
361 
362     /**
363      * One more than the highest UNumberSignDisplay value.
364      *
365      * @internal ICU 60: The numeric value may change over time; see ICU ticket #12420.
366      */
367             UNUM_SIGN_COUNT
368 } UNumberSignDisplay;
369 #endif  /* U_HIDE_DRAFT_API */
370 
371 #ifndef U_HIDE_DRAFT_API
372 /**
373  * An enum declaring how to render the decimal separator.
374  *
375  * &lt;p&gt;
376  * &lt;ul&gt;
377  * &lt;li&gt;UNUM_DECIMAL_SEPARATOR_AUTO: &quot;1&quot;, &quot;1.1&quot;
378  * &lt;li&gt;UNUM_DECIMAL_SEPARATOR_ALWAYS: &quot;1.&quot;, &quot;1.1&quot;
379  * &lt;/ul&gt;
<span class="line-added">380  *</span>
<span class="line-added">381  * @draft ICU 60</span>
382  */
383 typedef enum UNumberDecimalSeparatorDisplay {
384     /**
385      * Show the decimal separator when there are one or more digits to display after the separator, and do not show
386      * it otherwise. This is the default behavior.
387      *
388      * @draft ICU 60
389      */
390             UNUM_DECIMAL_SEPARATOR_AUTO,
391 
392     /**
393      * Always show the decimal separator, even if there are no digits to display after the separator.
394      *
395      * @draft ICU 60
396      */
397             UNUM_DECIMAL_SEPARATOR_ALWAYS,
398 
399     /**
400      * One more than the highest UNumberDecimalSeparatorDisplay value.
401      *
402      * @internal ICU 60: The numeric value may change over time; see ICU ticket #12420.
403      */
404             UNUM_DECIMAL_SEPARATOR_COUNT
405 } UNumberDecimalSeparatorDisplay;
406 #endif  /* U_HIDE_DRAFT_API */
407 
<span class="line-modified">408 struct UNumberFormatter;</span>
409 /**
410  * C-compatible version of icu::number::LocalizedNumberFormatter.
411  *
412  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
413  *
<span class="line-modified">414  * @stable ICU 62</span>
415  */

416 typedef struct UNumberFormatter UNumberFormatter;
417 
<span class="line-modified">418 struct UFormattedNumber;</span>
419 /**
420  * C-compatible version of icu::number::FormattedNumber.
421  *
422  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
423  *
<span class="line-modified">424  * @stable ICU 62</span>
425  */

426 typedef struct UFormattedNumber UFormattedNumber;
427 
428 
429 /**
430  * Creates a new UNumberFormatter for the given skeleton string and locale. This is currently the only
431  * method for creating a new UNumberFormatter.
432  *
433  * Objects of type UNumberFormatter returned by this method are threadsafe.
434  *
435  * For more details on skeleton strings, see the documentation in numberformatter.h. For more details on
436  * the usage of this API, see the documentation at the top of unumberformatter.h.
437  *
438  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
439  *
440  * @param skeleton The skeleton string, like u&quot;percent precision-integer&quot;
441  * @param skeletonLen The number of UChars in the skeleton string, or -1 it it is NUL-terminated.
442  * @param locale The NUL-terminated locale ID.
443  * @param ec Set if an error occurs.
<span class="line-modified">444  * @stable ICU 62</span>
445  */
<span class="line-modified">446 U_STABLE UNumberFormatter* U_EXPORT2</span>
447 unumf_openForSkeletonAndLocale(const UChar* skeleton, int32_t skeletonLen, const char* locale,
448                                UErrorCode* ec);
449 
450 
<span class="line-added">451 #ifndef U_HIDE_DRAFT_API</span>
452 /**
<span class="line-modified">453  * Like unumf_openForSkeletonAndLocale, but accepts a UParseError, which will be populated with the</span>
<span class="line-added">454  * location of a skeleton syntax error if such a syntax error exists.</span>
455  *
<span class="line-modified">456  * @param skeleton The skeleton string, like u&quot;percent precision-integer&quot;</span>
<span class="line-modified">457  * @param skeletonLen The number of UChars in the skeleton string, or -1 it it is NUL-terminated.</span>
<span class="line-modified">458  * @param locale The NUL-terminated locale ID.</span>
<span class="line-added">459  * @param perror A parse error struct populated if an error occurs when parsing. Can be NULL.</span>
<span class="line-added">460  *               If no error occurs, perror-&gt;offset will be set to -1.</span>
<span class="line-added">461  * @param ec Set if an error occurs.</span>
<span class="line-added">462  * @draft ICU 64</span>
<span class="line-added">463  */</span>
<span class="line-added">464 U_DRAFT UNumberFormatter* U_EXPORT2</span>
<span class="line-added">465 unumf_openForSkeletonAndLocaleWithError(</span>
<span class="line-added">466        const UChar* skeleton, int32_t skeletonLen, const char* locale, UParseError* perror, UErrorCode* ec);</span>
<span class="line-added">467 #endif  // U_HIDE_DRAFT_API</span>
<span class="line-added">468 </span>
<span class="line-added">469 </span>
<span class="line-added">470 /**</span>
<span class="line-added">471  * Creates an object to hold the result of a UNumberFormatter</span>
<span class="line-added">472  * operation. The object can be used repeatedly; it is cleared whenever</span>
<span class="line-added">473  * passed to a format function.</span>
474  *
475  * @param ec Set if an error occurs.
<span class="line-modified">476  * @stable ICU 62</span>
477  */
<span class="line-modified">478 U_STABLE UFormattedNumber* U_EXPORT2</span>
479 unumf_openResult(UErrorCode* ec);
480 
481 
482 /**
483  * Uses a UNumberFormatter to format an integer to a UFormattedNumber. A string, field position, and other
484  * information can be retrieved from the UFormattedNumber.
485  *
486  * The UNumberFormatter can be shared between threads. Each thread should have its own local
487  * UFormattedNumber, however, for storing the result of the formatting operation.
488  *
489  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
490  *
491  * @param uformatter A formatter object created by unumf_openForSkeletonAndLocale or similar.
492  * @param value The number to be formatted.
493  * @param uresult The object that will be mutated to store the result; see unumf_openResult.
494  * @param ec Set if an error occurs.
<span class="line-modified">495  * @stable ICU 62</span>
496  */
<span class="line-modified">497 U_STABLE void U_EXPORT2</span>
498 unumf_formatInt(const UNumberFormatter* uformatter, int64_t value, UFormattedNumber* uresult,
499                 UErrorCode* ec);
500 
501 
502 /**
503  * Uses a UNumberFormatter to format a double to a UFormattedNumber. A string, field position, and other
504  * information can be retrieved from the UFormattedNumber.
505  *
506  * The UNumberFormatter can be shared between threads. Each thread should have its own local
507  * UFormattedNumber, however, for storing the result of the formatting operation.
508  *
509  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
510  *
511  * @param uformatter A formatter object created by unumf_openForSkeletonAndLocale or similar.
512  * @param value The number to be formatted.
513  * @param uresult The object that will be mutated to store the result; see unumf_openResult.
514  * @param ec Set if an error occurs.
<span class="line-modified">515  * @stable ICU 62</span>
516  */
<span class="line-modified">517 U_STABLE void U_EXPORT2</span>
518 unumf_formatDouble(const UNumberFormatter* uformatter, double value, UFormattedNumber* uresult,
519                    UErrorCode* ec);
520 
521 
522 /**
523  * Uses a UNumberFormatter to format a decimal number to a UFormattedNumber. A string, field position, and
524  * other information can be retrieved from the UFormattedNumber.
525  *
526  * The UNumberFormatter can be shared between threads. Each thread should have its own local
527  * UFormattedNumber, however, for storing the result of the formatting operation.
528  *
529  * The syntax of the unformatted number is a &quot;numeric string&quot; as defined in the Decimal Arithmetic
530  * Specification, available at http://speleotrove.com/decimal
531  *
532  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
533  *
534  * @param uformatter A formatter object created by unumf_openForSkeletonAndLocale or similar.
535  * @param value The numeric string to be formatted.
536  * @param valueLen The length of the numeric string, or -1 if it is NUL-terminated.
537  * @param uresult The object that will be mutated to store the result; see unumf_openResult.
538  * @param ec Set if an error occurs.
<span class="line-modified">539  * @stable ICU 62</span>
540  */
<span class="line-modified">541 U_STABLE void U_EXPORT2</span>
542 unumf_formatDecimal(const UNumberFormatter* uformatter, const char* value, int32_t valueLen,
543                     UFormattedNumber* uresult, UErrorCode* ec);
544 
<span class="line-added">545 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added">546 /**</span>
<span class="line-added">547  * Returns a representation of a UFormattedNumber as a UFormattedValue,</span>
<span class="line-added">548  * which can be subsequently passed to any API requiring that type.</span>
<span class="line-added">549  *</span>
<span class="line-added">550  * The returned object is owned by the UFormattedNumber and is valid</span>
<span class="line-added">551  * only as long as the UFormattedNumber is present and unchanged in memory.</span>
<span class="line-added">552  *</span>
<span class="line-added">553  * You can think of this method as a cast between types.</span>
<span class="line-added">554  *</span>
<span class="line-added">555  * @param uresult The object containing the formatted string.</span>
<span class="line-added">556  * @param ec Set if an error occurs.</span>
<span class="line-added">557  * @return A UFormattedValue owned by the input object.</span>
<span class="line-added">558  * @draft ICU 64</span>
<span class="line-added">559  */</span>
<span class="line-added">560 U_DRAFT const UFormattedValue* U_EXPORT2</span>
<span class="line-added">561 unumf_resultAsValue(const UFormattedNumber* uresult, UErrorCode* ec);</span>
<span class="line-added">562 #endif  /* U_HIDE_DRAFT_API */</span>
<span class="line-added">563 </span>
564 
565 /**
566  * Extracts the result number string out of a UFormattedNumber to a UChar buffer if possible.
567  * If bufferCapacity is greater than the required length, a terminating NUL is written.
568  * If bufferCapacity is less than the required length, an error code is set.
569  *
<span class="line-added">570  * Also see ufmtval_getString, which returns a NUL-terminated string:</span>
<span class="line-added">571  *</span>
<span class="line-added">572  *     int32_t len;</span>
<span class="line-added">573  *     const UChar* str = ufmtval_getString(unumf_resultAsValue(uresult, &amp;ec), &amp;len, &amp;ec);</span>
<span class="line-added">574  *</span>
575  * NOTE: This is a C-compatible API; C++ users should build against numberformatter.h instead.
576  *
577  * @param uresult The object containing the formatted number.
578  * @param buffer Where to save the string output.
579  * @param bufferCapacity The number of UChars available in the buffer.
580  * @param ec Set if an error occurs.
581  * @return The required length.
<span class="line-modified">582  * @stable ICU 62</span>
583  */
<span class="line-modified">584 U_STABLE int32_t U_EXPORT2</span>
585 unumf_resultToString(const UFormattedNumber* uresult, UChar* buffer, int32_t bufferCapacity,
586                      UErrorCode* ec);
587 
588 
589 /**
590  * Determines the start and end indices of the next occurrence of the given &lt;em&gt;field&lt;/em&gt; in the
591  * output string. This allows you to determine the locations of, for example, the integer part,
592  * fraction part, or symbols.
593  *
<span class="line-added">594  * This is a simpler but less powerful alternative to {@link ufmtval_nextPosition}.</span>
<span class="line-added">595  *</span>
596  * If a field occurs just once, calling this method will find that occurrence and return it. If a
597  * field occurs multiple times, this method may be called repeatedly with the following pattern:
598  *
599  * &lt;pre&gt;
600  * UFieldPosition ufpos = {UNUM_GROUPING_SEPARATOR_FIELD, 0, 0};
601  * while (unumf_resultNextFieldPosition(uresult, ufpos, &amp;ec)) {
602  *   // do something with ufpos.
603  * }
604  * &lt;/pre&gt;
605  *
606  * This method is useful if you know which field to query. If you want all available field position
607  * information, use unumf_resultGetAllFieldPositions().
608  *
609  * NOTE: All fields of the UFieldPosition must be initialized before calling this method.
610  *
<span class="line-modified">611  * @param uresult The object containing the formatted number.</span>
<span class="line-added">612  * @param ufpos</span>
613  *            Input+output variable. On input, the &quot;field&quot; property determines which field to look up,
614  *            and the &quot;endIndex&quot; property determines where to begin the search. On output, the
615  *            &quot;beginIndex&quot; field is set to the beginning of the first occurrence of the field after the
616  *            input &quot;endIndex&quot;, and &quot;endIndex&quot; is set to the end of that occurrence of the field
617  *            (exclusive index). If a field position is not found, the FieldPosition is not changed and
618  *            the method returns FALSE.
619  * @param ec Set if an error occurs.
<span class="line-modified">620  * @stable ICU 62</span>
621  */
<span class="line-modified">622 U_STABLE UBool U_EXPORT2</span>
623 unumf_resultNextFieldPosition(const UFormattedNumber* uresult, UFieldPosition* ufpos, UErrorCode* ec);
624 
625 
626 /**
627  * Populates the given iterator with all fields in the formatted output string. This allows you to
628  * determine the locations of the integer part, fraction part, and sign.
629  *
<span class="line-modified">630  * This is an alternative to the more powerful {@link ufmtval_nextPosition} API.</span>
<span class="line-added">631  *</span>
<span class="line-added">632  * If you need information on only one field, use {@link ufmtval_nextPosition} or</span>
<span class="line-added">633  * {@link unumf_resultNextFieldPosition}.</span>
634  *
635  * @param uresult The object containing the formatted number.
<span class="line-modified">636  * @param ufpositer</span>
637  *         A pointer to a UFieldPositionIterator created by {@link #ufieldpositer_open}. Iteration
638  *         information already present in the UFieldPositionIterator is deleted, and the iterator is reset
639  *         to apply to the fields in the formatted string created by this function call. The field values
640  *         and indexes returned by {@link #ufieldpositer_next} represent fields denoted by
641  *         the UNumberFormatFields enum. Fields are not returned in a guaranteed order. Fields cannot
642  *         overlap, but they may nest. For example, 1234 could format as &quot;1,234&quot; which might consist of a
643  *         grouping separator field for &#39;,&#39; and an integer field encompassing the entire string.
644  * @param ec Set if an error occurs.
<span class="line-modified">645  * @stable ICU 62</span>
646  */
<span class="line-modified">647 U_STABLE void U_EXPORT2</span>
648 unumf_resultGetAllFieldPositions(const UFormattedNumber* uresult, UFieldPositionIterator* ufpositer,
649                                  UErrorCode* ec);
650 
651 
652 /**
653  * Releases the UNumberFormatter created by unumf_openForSkeletonAndLocale().
654  *


655  * @param uformatter An object created by unumf_openForSkeletonAndLocale().
<span class="line-modified">656  * @stable ICU 62</span>
657  */
<span class="line-modified">658 U_STABLE void U_EXPORT2</span>
659 unumf_close(UNumberFormatter* uformatter);
660 
661 
662 /**
663  * Releases the UFormattedNumber created by unumf_openResult().
664  *


665  * @param uresult An object created by unumf_openResult().
<span class="line-modified">666  * @stable ICU 62</span>
667  */
<span class="line-modified">668 U_STABLE void U_EXPORT2</span>
669 unumf_closeResult(UFormattedNumber* uresult);
670 
671 
672 #if U_SHOW_CPLUSPLUS_API
673 U_NAMESPACE_BEGIN
674 
675 /**
676  * \class LocalUNumberFormatterPointer
677  * &quot;Smart pointer&quot; class; closes a UNumberFormatter via unumf_close().
678  * For most methods see the LocalPointerBase base class.
679  *
680  * Usage:
681  * &lt;pre&gt;
682  * LocalUNumberFormatterPointer uformatter(unumf_openForSkeletonAndLocale(...));
683  * // no need to explicitly call unumf_close()
684  * &lt;/pre&gt;
685  *
686  * @see LocalPointerBase
687  * @see LocalPointer
<span class="line-modified">688  * @stable ICU 62</span>
689  */
690 U_DEFINE_LOCAL_OPEN_POINTER(LocalUNumberFormatterPointer, UNumberFormatter, unumf_close);
691 
692 /**
<span class="line-modified">693  * \class LocalUFormattedNumberPointer</span>
694  * &quot;Smart pointer&quot; class; closes a UFormattedNumber via unumf_closeResult().
695  * For most methods see the LocalPointerBase base class.
696  *
697  * Usage:
698  * &lt;pre&gt;
699  * LocalUFormattedNumberPointer uformatter(unumf_openResult(...));
700  * // no need to explicitly call unumf_closeResult()
701  * &lt;/pre&gt;
702  *
703  * @see LocalPointerBase
704  * @see LocalPointer
<span class="line-modified">705  * @stable ICU 62</span>
706  */
707 U_DEFINE_LOCAL_OPEN_POINTER(LocalUFormattedNumberPointer, UFormattedNumber, unumf_closeResult);
708 
709 U_NAMESPACE_END
710 #endif // U_SHOW_CPLUSPLUS_API
711 


712 #endif //__UNUMBERFORMATTER_H__
713 #endif /* #if !UCONFIG_NO_FORMATTING */



















































</pre>
</td>
</tr>
</table>
<center><a href="unum.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="unumsys.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>