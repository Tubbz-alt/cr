<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/filestrm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 ******************************************************************************
  5 *
  6 *   Copyright (C) 1997-2011, International Business Machines
  7 *   Corporation and others.  All Rights Reserved.
  8 *
  9 ******************************************************************************
 10 *
 11 * File FILESTRM.C
 12 *
 13 * @author       Glenn Marcy
 14 *
 15 * Modification History:
 16 *
 17 *   Date        Name        Description
 18 *   5/8/98      gm          Created
 19 *  03/02/99     stephen     Reordered params in ungetc to match stdio
 20 *                           Added wopen
 21 *   3/29/99     helena      Merged Stephen and Bertrand&#39;s changes.
 22 *
 23 ******************************************************************************
 24 */
 25 
 26 #include &quot;filestrm.h&quot;
 27 
 28 #include &quot;cmemory.h&quot;
 29 
 30 #include &lt;stdio.h&gt;
 31 
 32 U_CAPI FileStream* U_EXPORT2
 33 T_FileStream_open(const char* filename, const char* mode)
 34 {
 35     if(filename != NULL &amp;&amp; *filename != 0 &amp;&amp; mode != NULL &amp;&amp; *mode != 0) {
 36         FILE *file = fopen(filename, mode);
 37         return (FileStream*)file;
 38     } else {
 39         return NULL;
 40     }
 41 }
 42 
 43 /*
 44 U_CAPI FileStream* U_EXPORT2
 45 T_FileStream_wopen(const wchar_t* filename, const wchar_t* mode)
 46 {
 47    // TBD: _wfopen is believed to be MS-specific?
 48 #if U_PLATFORM_USES_ONLY_WIN32_API
 49     FILE* result = _wfopen(filename, mode);
 50     return (FileStream*)result;
 51 #else
 52     size_t fnMbsSize, mdMbsSize;
 53     char *fn, *md;
 54     FILE *result;
 55 
 56     // convert from wchar_t to char
 57     fnMbsSize = wcstombs(NULL, filename, ((size_t)-1) &gt;&gt; 1);
 58     fn = (char*)uprv_malloc(fnMbsSize+2);
 59     wcstombs(fn, filename, fnMbsSize);
 60     fn[fnMbsSize] = 0;
 61 
 62     mdMbsSize = wcstombs(NULL, mode, ((size_t)-1) &gt;&gt; 1);
 63     md = (char*)uprv_malloc(mdMbsSize+2);
 64     wcstombs(md, mode, mdMbsSize);
 65     md[mdMbsSize] = 0;
 66 
 67     result = fopen(fn, md);
 68     uprv_free(fn);
 69     uprv_free(md);
 70     return (FileStream*)result;
 71 #endif
 72 }
 73 */
 74 U_CAPI void U_EXPORT2
 75 T_FileStream_close(FileStream* fileStream)
 76 {
 77     if (fileStream != 0)
 78         fclose((FILE*)fileStream);
 79 }
 80 
 81 U_CAPI UBool U_EXPORT2
 82 T_FileStream_file_exists(const char* filename)
 83 {
 84     FILE* temp = fopen(filename, &quot;r&quot;);
 85     if (temp) {
 86         fclose(temp);
 87         return TRUE;
 88     } else
 89         return FALSE;
 90 }
 91 
 92 /*static const int32_t kEOF;
 93 const int32_t FileStream::kEOF = EOF;*/
 94 
 95 /*
 96 U_CAPI FileStream*
 97 T_FileStream_tmpfile()
 98 {
 99     FILE* file = tmpfile();
100     return (FileStream*)file;
101 }
102 */
103 
104 U_CAPI int32_t U_EXPORT2
105 T_FileStream_read(FileStream* fileStream, void* addr, int32_t len)
106 {
107     return fread(addr, 1, len, (FILE*)fileStream);
108 }
109 
110 U_CAPI int32_t U_EXPORT2
111 T_FileStream_write(FileStream* fileStream, const void* addr, int32_t len)
112 {
113 
114     return fwrite(addr, 1, len, (FILE*)fileStream);
115 }
116 
117 U_CAPI void U_EXPORT2
118 T_FileStream_rewind(FileStream* fileStream)
119 {
120     rewind((FILE*)fileStream);
121 }
122 
123 U_CAPI int32_t U_EXPORT2
124 T_FileStream_putc(FileStream* fileStream, int32_t ch)
125 {
126     int32_t c = fputc(ch, (FILE*)fileStream);
127     return c;
128 }
129 
130 U_CAPI int U_EXPORT2
131 T_FileStream_getc(FileStream* fileStream)
132 {
133     int c = fgetc((FILE*)fileStream);
134     return c;
135 }
136 
137 U_CAPI int32_t U_EXPORT2
138 T_FileStream_ungetc(int32_t ch, FileStream* fileStream)
139 {
140 
141     int32_t c = ungetc(ch, (FILE*)fileStream);
142     return c;
143 }
144 
145 U_CAPI int32_t U_EXPORT2
146 T_FileStream_peek(FileStream* fileStream)
147 {
148     int32_t c = fgetc((FILE*)fileStream);
149     return ungetc(c, (FILE*)fileStream);
150 }
151 
152 U_CAPI char* U_EXPORT2
153 T_FileStream_readLine(FileStream* fileStream, char* buffer, int32_t length)
154 {
155     return fgets(buffer, length, (FILE*)fileStream);
156 }
157 
158 U_CAPI int32_t U_EXPORT2
159 T_FileStream_writeLine(FileStream* fileStream, const char* buffer)
160 {
161     return fputs(buffer, (FILE*)fileStream);
162 }
163 
164 U_CAPI int32_t U_EXPORT2
165 T_FileStream_size(FileStream* fileStream)
166 {
167     int32_t savedPos = ftell((FILE*)fileStream);
168     int32_t size = 0;
169 
170     /*Changes by Bertrand A. D. doesn&#39;t affect the current position
171     goes to the end of the file before ftell*/
172     fseek((FILE*)fileStream, 0, SEEK_END);
173     size = (int32_t)ftell((FILE*)fileStream);
174     fseek((FILE*)fileStream, savedPos, SEEK_SET);
175     return size;
176 }
177 
178 U_CAPI int U_EXPORT2
179 T_FileStream_eof(FileStream* fileStream)
180 {
181     return feof((FILE*)fileStream);
182 }
183 
184 /*
185  Warning
186  This function may not work consistently on all platforms
187  (e.g. HP-UX, FreeBSD and MacOSX don&#39;t return an error when
188  putc is used on a file opened as readonly)
189 */
190 U_CAPI int U_EXPORT2
191 T_FileStream_error(FileStream* fileStream)
192 {
193     return (fileStream == 0 || ferror((FILE*)fileStream));
194 }
195 
196 /* This function doesn&#39;t work. */
197 /* force the stream to set its error flag*/
198 /*U_CAPI void U_EXPORT2
199 T_FileStream_setError(FileStream* fileStream)
200 {
201     fseek((FILE*)fileStream, 99999, SEEK_SET);
202 }
203 */
204 
205 U_CAPI FileStream* U_EXPORT2
206 T_FileStream_stdin(void)
207 {
208     return (FileStream*)stdin;
209 }
210 
211 U_CAPI FileStream* U_EXPORT2
212 T_FileStream_stdout(void)
213 {
214     return (FileStream*)stdout;
215 }
216 
217 
218 U_CAPI FileStream* U_EXPORT2
219 T_FileStream_stderr(void)
220 {
221     return (FileStream*)stderr;
222 }
223 
224 U_CAPI UBool U_EXPORT2
225 T_FileStream_remove(const char* fileName){
226     return (remove(fileName) == 0);
227 }
    </pre>
  </body>
</html>