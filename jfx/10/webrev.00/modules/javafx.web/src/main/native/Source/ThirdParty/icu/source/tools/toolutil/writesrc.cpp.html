<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/writesrc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // © 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 *
  6 *   Copyright (C) 2005-2012, International Business Machines
  7 *   Corporation and others.  All Rights Reserved.
  8 *
  9 *******************************************************************************
 10 *   file name:  writesrc.c
 11 *   encoding:   UTF-8
 12 *   tab size:   8 (not used)
 13 *   indentation:4
 14 *
 15 *   created on: 2005apr23
 16 *   created by: Markus W. Scherer
 17 *
 18 *   Helper functions for writing source code for data.
 19 */
 20 
 21 #include &lt;stdio.h&gt;
 22 #include &lt;time.h&gt;
 23 #include &quot;unicode/utypes.h&quot;
 24 #include &quot;unicode/putil.h&quot;
 25 #include &quot;unicode/ucptrie.h&quot;
 26 #include &quot;utrie2.h&quot;
 27 #include &quot;cstring.h&quot;
 28 #include &quot;writesrc.h&quot;
 29 
 30 static FILE *
 31 usrc_createWithHeader(const char *path, const char *filename,
 32                       const char *header, const char *generator) {
 33     char buffer[1024];
 34     const char *p;
 35     char *q;
 36     FILE *f;
 37     char c;
 38 
 39     if(path==NULL) {
 40         p=filename;
 41     } else {
 42         /* concatenate path and filename, with U_FILE_SEP_CHAR in between if necessary */
 43         uprv_strcpy(buffer, path);
 44         q=buffer+uprv_strlen(buffer);
 45         if(q&gt;buffer &amp;&amp; (c=*(q-1))!=U_FILE_SEP_CHAR &amp;&amp; c!=U_FILE_ALT_SEP_CHAR) {
 46             *q++=U_FILE_SEP_CHAR;
 47         }
 48         uprv_strcpy(q, filename);
 49         p=buffer;
 50     }
 51 
 52     f=fopen(p, &quot;w&quot;);
 53     if(f!=NULL) {
 54         const struct tm *lt;
 55         time_t t;
 56 
 57         time(&amp;t);
 58         lt=localtime(&amp;t);
 59         if(generator==NULL) {
 60             strftime(buffer, sizeof(buffer), &quot;%Y-%m-%d&quot;, lt);
 61             fprintf(f, header, filename, buffer);
 62         } else {
 63             fprintf(f, header, filename, generator);
 64         }
 65     } else {
 66         fprintf(
 67             stderr,
 68             &quot;usrc_create(%s, %s): unable to create file\n&quot;,
 69             path!=NULL ? path : &quot;&quot;, filename);
 70     }
 71     return f;
 72 }
 73 
 74 U_CAPI FILE * U_EXPORT2
 75 usrc_create(const char *path, const char *filename, int32_t copyrightYear, const char *generator) {
 76     const char *header;
 77     char buffer[200];
 78     if(copyrightYear&lt;=2016) {
 79         header=
 80             &quot;// © 2016 and later: Unicode, Inc. and others.\n&quot;
 81             &quot;// License &amp; terms of use: http://www.unicode.org/copyright.html\n&quot;
 82             &quot;//\n&quot;
 83             &quot;// Copyright (C) 1999-2016, International Business Machines\n&quot;
 84             &quot;// Corporation and others.  All Rights Reserved.\n&quot;
 85             &quot;//\n&quot;
 86             &quot;// file name: %s\n&quot;
 87             &quot;//\n&quot;
 88             &quot;// machine-generated by: %s\n&quot;
 89             &quot;\n\n&quot;;
 90     } else {
 91         sprintf(buffer,
 92                 &quot;// © %d and later: Unicode, Inc. and others.\n&quot;
 93                 &quot;// License &amp; terms of use: http://www.unicode.org/copyright.html\n&quot;
 94                 &quot;//\n&quot;
 95                 &quot;// file name: %%s\n&quot;
 96                 &quot;//\n&quot;
 97                 &quot;// machine-generated by: %%s\n&quot;
 98                 &quot;\n\n&quot;,
 99                 (int)copyrightYear);
100         header=buffer;
101     }
102     return usrc_createWithHeader(path, filename, header, generator);
103 }
104 
105 U_CAPI FILE * U_EXPORT2
106 usrc_createTextData(const char *path, const char *filename, const char *generator) {
107     // TODO: Add parameter for the first year this file was generated, not before 2016.
108     static const char *header=
109         &quot;# Copyright (C) 2016 and later: Unicode, Inc. and others.\n&quot;
110         &quot;# License &amp; terms of use: http://www.unicode.org/copyright.html\n&quot;
111         &quot;# Copyright (C) 1999-2016, International Business Machines\n&quot;
112         &quot;# Corporation and others.  All Rights Reserved.\n&quot;
113         &quot;#\n&quot;
114         &quot;# file name: %s\n&quot;
115         &quot;#\n&quot;
116         &quot;# machine-generated by: %s\n&quot;
117         &quot;\n\n&quot;;
118     return usrc_createWithHeader(path, filename, header, generator);
119 }
120 
121 U_CAPI void U_EXPORT2
122 usrc_writeArray(FILE *f,
123                 const char *prefix,
124                 const void *p, int32_t width, int32_t length,
125                 const char *postfix) {
126     const uint8_t *p8;
127     const uint16_t *p16;
128     const uint32_t *p32;
129     uint32_t value;
130     int32_t i, col;
131 
132     p8=NULL;
133     p16=NULL;
134     p32=NULL;
135     switch(width) {
136     case 8:
137         p8=(const uint8_t *)p;
138         break;
139     case 16:
140         p16=(const uint16_t *)p;
141         break;
142     case 32:
143         p32=(const uint32_t *)p;
144         break;
145     default:
146         fprintf(stderr, &quot;usrc_writeArray(width=%ld) unrecognized width\n&quot;, (long)width);
147         return;
148     }
149     if(prefix!=NULL) {
150         fprintf(f, prefix, (long)length);
151     }
152     for(i=col=0; i&lt;length; ++i, ++col) {
153         if(i&gt;0) {
154             if(col&lt;16) {
155                 fputc(&#39;,&#39;, f);
156             } else {
157                 fputs(&quot;,\n&quot;, f);
158                 col=0;
159             }
160         }
161         switch(width) {
162         case 8:
163             value=p8[i];
164             break;
165         case 16:
166             value=p16[i];
167             break;
168         case 32:
169             value=p32[i];
170             break;
171         default:
172             value=0; /* unreachable */
173             break;
174         }
175         fprintf(f, value&lt;=9 ? &quot;%lu&quot; : &quot;0x%lx&quot;, (unsigned long)value);
176     }
177     if(postfix!=NULL) {
178         fputs(postfix, f);
179     }
180 }
181 
182 U_CAPI void U_EXPORT2
183 usrc_writeUTrie2Arrays(FILE *f,
184                        const char *indexPrefix, const char *data32Prefix,
185                        const UTrie2 *pTrie,
186                        const char *postfix) {
187     if(pTrie-&gt;data32==NULL) {
188         /* 16-bit trie */
189         usrc_writeArray(f, indexPrefix, pTrie-&gt;index, 16, pTrie-&gt;indexLength+pTrie-&gt;dataLength, postfix);
190     } else {
191         /* 32-bit trie */
192         usrc_writeArray(f, indexPrefix, pTrie-&gt;index, 16, pTrie-&gt;indexLength, postfix);
193         usrc_writeArray(f, data32Prefix, pTrie-&gt;data32, 32, pTrie-&gt;dataLength, postfix);
194     }
195 }
196 
197 U_CAPI void U_EXPORT2
198 usrc_writeUTrie2Struct(FILE *f,
199                        const char *prefix,
200                        const UTrie2 *pTrie,
201                        const char *indexName, const char *data32Name,
202                        const char *postfix) {
203     if(prefix!=NULL) {
204         fputs(prefix, f);
205     }
206     if(pTrie-&gt;data32==NULL) {
207         /* 16-bit trie */
208         fprintf(
209             f,
210             &quot;    %s,\n&quot;         /* index */
211             &quot;    %s+%ld,\n&quot;     /* data16 */
212             &quot;    NULL,\n&quot;,      /* data32 */
213             indexName,
214             indexName,
215             (long)pTrie-&gt;indexLength);
216     } else {
217         /* 32-bit trie */
218         fprintf(
219             f,
220             &quot;    %s,\n&quot;         /* index */
221             &quot;    NULL,\n&quot;       /* data16 */
222             &quot;    %s,\n&quot;,        /* data32 */
223             indexName,
224             data32Name);
225     }
226     fprintf(
227         f,
228         &quot;    %ld,\n&quot;            /* indexLength */
229         &quot;    %ld,\n&quot;            /* dataLength */
230         &quot;    0x%hx,\n&quot;          /* index2NullOffset */
231         &quot;    0x%hx,\n&quot;          /* dataNullOffset */
232         &quot;    0x%lx,\n&quot;          /* initialValue */
233         &quot;    0x%lx,\n&quot;          /* errorValue */
234         &quot;    0x%lx,\n&quot;          /* highStart */
235         &quot;    0x%lx,\n&quot;          /* highValueIndex */
236         &quot;    NULL, 0, FALSE, FALSE, 0, NULL\n&quot;,
237         (long)pTrie-&gt;indexLength, (long)pTrie-&gt;dataLength,
238         (short)pTrie-&gt;index2NullOffset, (short)pTrie-&gt;dataNullOffset,
239         (long)pTrie-&gt;initialValue, (long)pTrie-&gt;errorValue,
240         (long)pTrie-&gt;highStart, (long)pTrie-&gt;highValueIndex);
241     if(postfix!=NULL) {
242         fputs(postfix, f);
243     }
244 }
245 
246 U_CAPI void U_EXPORT2
247 usrc_writeUCPTrieArrays(FILE *f,
248                         const char *indexPrefix, const char *dataPrefix,
249                         const UCPTrie *pTrie,
250                         const char *postfix) {
251     usrc_writeArray(f, indexPrefix, pTrie-&gt;index, 16, pTrie-&gt;indexLength, postfix);
252     int32_t width=
253         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_16 ? 16 :
254         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_32 ? 32 :
255         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_8 ? 8 : 0;
256     usrc_writeArray(f, dataPrefix, pTrie-&gt;data.ptr0, width, pTrie-&gt;dataLength, postfix);
257 }
258 
259 U_CAPI void U_EXPORT2
260 usrc_writeUCPTrieStruct(FILE *f,
261                         const char *prefix,
262                         const UCPTrie *pTrie,
263                         const char *indexName, const char *dataName,
264                         const char *postfix) {
265     if(prefix!=NULL) {
266         fputs(prefix, f);
267     }
268     fprintf(
269         f,
270         &quot;    %s,\n&quot;             // index
271         &quot;    { %s },\n&quot;,        // data (union)
272         indexName,
273         dataName);
274     fprintf(
275         f,
276         &quot;    %ld, %ld,\n&quot;       // indexLength, dataLength
277         &quot;    0x%lx, 0x%x,\n&quot;    // highStart, shifted12HighStart
278         &quot;    %d, %d,\n&quot;         // type, valueWidth
279         &quot;    0, 0,\n&quot;           // reserved32, reserved16
280         &quot;    0x%x, 0x%lx,\n&quot;    // index3NullOffset, dataNullOffset
281         &quot;    0x%lx,\n&quot;,         // nullValue
282         (long)pTrie-&gt;indexLength, (long)pTrie-&gt;dataLength,
283         (long)pTrie-&gt;highStart, pTrie-&gt;shifted12HighStart,
284         pTrie-&gt;type, pTrie-&gt;valueWidth,
285         pTrie-&gt;index3NullOffset, (long)pTrie-&gt;dataNullOffset,
286         (long)pTrie-&gt;nullValue);
287     if(postfix!=NULL) {
288         fputs(postfix, f);
289     }
290 }
291 
292 U_CAPI void U_EXPORT2
293 usrc_writeUCPTrie(FILE *f, const char *name, const UCPTrie *pTrie) {
294     int32_t width=
295         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_16 ? 16 :
296         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_32 ? 32 :
297         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_8 ? 8 : 0;
298     char line[100], line2[100], line3[100];
299     sprintf(line, &quot;static const uint16_t %s_trieIndex[%%ld]={\n&quot;, name);
300     sprintf(line2, &quot;static const uint%d_t %s_trieData[%%ld]={\n&quot;, (int)width, name);
301     usrc_writeUCPTrieArrays(f, line, line2, pTrie, &quot;\n};\n\n&quot;);
302     sprintf(line, &quot;static const UCPTrie %s_trie={\n&quot;, name);
303     sprintf(line2, &quot;%s_trieIndex&quot;, name);
304     sprintf(line3, &quot;%s_trieData&quot;, name);
305     usrc_writeUCPTrieStruct(f, line, pTrie, line2, line3, &quot;};\n\n&quot;);
306 }
307 
308 U_CAPI void U_EXPORT2
309 usrc_writeArrayOfMostlyInvChars(FILE *f,
310                                 const char *prefix,
311                                 const char *p, int32_t length,
312                                 const char *postfix) {
313     int32_t i, col;
314     int prev2, prev, c;
315 
316     if(prefix!=NULL) {
317         fprintf(f, prefix, (long)length);
318     }
319     prev2=prev=-1;
320     for(i=col=0; i&lt;length; ++i, ++col) {
321         c=(uint8_t)p[i];
322         if(i&gt;0) {
323             /* Break long lines. Try to break at interesting places, to minimize revision diffs. */
324             if(
325                 /* Very long line. */
326                 col&gt;=32 ||
327                 /* Long line, break after terminating NUL. */
328                 (col&gt;=24 &amp;&amp; prev2&gt;=0x20 &amp;&amp; prev==0) ||
329                 /* Medium-long line, break before non-NUL, non-character byte. */
330                 (col&gt;=16 &amp;&amp; (prev==0 || prev&gt;=0x20) &amp;&amp; 0&lt;c &amp;&amp; c&lt;0x20)
331             ) {
332                 fputs(&quot;,\n&quot;, f);
333                 col=0;
334             } else {
335                 fputc(&#39;,&#39;, f);
336             }
337         }
338         fprintf(f, c&lt;0x20 ? &quot;%u&quot; : &quot;&#39;%c&#39;&quot;, c);
339         prev2=prev;
340         prev=c;
341     }
342     if(postfix!=NULL) {
343         fputs(postfix, f);
344     }
345 }
    </pre>
  </body>
</html>