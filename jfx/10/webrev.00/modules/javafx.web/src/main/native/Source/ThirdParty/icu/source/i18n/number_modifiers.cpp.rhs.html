<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_modifiers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2017 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 #include &quot;unicode/utypes.h&quot;
  5 
  6 #if !UCONFIG_NO_FORMATTING
  7 
  8 #include &quot;umutex.h&quot;
  9 #include &quot;ucln_cmn.h&quot;
 10 #include &quot;ucln_in.h&quot;
 11 #include &quot;number_modifiers.h&quot;
 12 
 13 using namespace icu;
 14 using namespace icu::number;
 15 using namespace icu::number::impl;
 16 
 17 namespace {
 18 
 19 // TODO: This is copied from simpleformatter.cpp
 20 const int32_t ARG_NUM_LIMIT = 0x100;
 21 
 22 // These are the default currency spacing UnicodeSets in CLDR.
 23 // Pre-compute them for performance.
 24 // The Java unit test testCurrencySpacingPatternStability() will start failing if these change in CLDR.
 25 icu::UInitOnce gDefaultCurrencySpacingInitOnce = U_INITONCE_INITIALIZER;
 26 
 27 UnicodeSet *UNISET_DIGIT = nullptr;
 28 UnicodeSet *UNISET_NOTS = nullptr;
 29 
 30 UBool U_CALLCONV cleanupDefaultCurrencySpacing() {
 31     delete UNISET_DIGIT;
 32     UNISET_DIGIT = nullptr;
 33     delete UNISET_NOTS;
 34     UNISET_NOTS = nullptr;
 35     gDefaultCurrencySpacingInitOnce.reset();
 36     return TRUE;
 37 }
 38 
 39 void U_CALLCONV initDefaultCurrencySpacing(UErrorCode &amp;status) {
 40     ucln_i18n_registerCleanup(UCLN_I18N_CURRENCY_SPACING, cleanupDefaultCurrencySpacing);
 41     UNISET_DIGIT = new UnicodeSet(UnicodeString(u&quot;[:digit:]&quot;), status);
 42     UNISET_NOTS = new UnicodeSet(UnicodeString(u&quot;[:^S:]&quot;), status);
 43     if (UNISET_DIGIT == nullptr || UNISET_NOTS == nullptr) {
 44         status = U_MEMORY_ALLOCATION_ERROR;
 45         return;
 46     }
 47     UNISET_DIGIT-&gt;freeze();
 48     UNISET_NOTS-&gt;freeze();
 49 }
 50 
 51 }  // namespace
 52 
 53 
 54 Modifier::~Modifier() = default;
 55 
<a name="1" id="anc1"></a><span class="line-added"> 56 Modifier::Parameters::Parameters()</span>
<span class="line-added"> 57         : obj(nullptr) {}</span>
<span class="line-added"> 58 </span>
<span class="line-added"> 59 Modifier::Parameters::Parameters(</span>
<span class="line-added"> 60     const ModifierStore* _obj, int8_t _signum, StandardPlural::Form _plural)</span>
<span class="line-added"> 61         : obj(_obj), signum(_signum), plural(_plural) {}</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63 ModifierStore::~ModifierStore() = default;</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65 AdoptingModifierStore::~AdoptingModifierStore()  {</span>
<span class="line-added"> 66     for (const Modifier *mod : mods) {</span>
<span class="line-added"> 67         delete mod;</span>
<span class="line-added"> 68     }</span>
<span class="line-added"> 69 }</span>
<span class="line-added"> 70 </span>
 71 
 72 int32_t ConstantAffixModifier::apply(NumberStringBuilder &amp;output, int leftIndex, int rightIndex,
 73                                      UErrorCode &amp;status) const {
 74     // Insert the suffix first since inserting the prefix will change the rightIndex
 75     int length = output.insert(rightIndex, fSuffix, fField, status);
 76     length += output.insert(leftIndex, fPrefix, fField, status);
 77     return length;
 78 }
 79 
<a name="2" id="anc2"></a><span class="line-modified"> 80 int32_t ConstantAffixModifier::getPrefixLength() const {</span>

 81     return fPrefix.length();
 82 }
 83 
<a name="3" id="anc3"></a><span class="line-modified"> 84 int32_t ConstantAffixModifier::getCodePointCount() const {</span>

 85     return fPrefix.countChar32() + fSuffix.countChar32();
 86 }
 87 
 88 bool ConstantAffixModifier::isStrong() const {
 89     return fStrong;
 90 }
 91 
<a name="4" id="anc4"></a><span class="line-added"> 92 bool ConstantAffixModifier::containsField(UNumberFormatFields field) const {</span>
<span class="line-added"> 93     (void)field;</span>
<span class="line-added"> 94     // This method is not currently used.</span>
<span class="line-added"> 95     UPRV_UNREACHABLE;</span>
<span class="line-added"> 96 }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98 void ConstantAffixModifier::getParameters(Parameters&amp; output) const {</span>
<span class="line-added"> 99     (void)output;</span>
<span class="line-added">100     // This method is not currently used.</span>
<span class="line-added">101     UPRV_UNREACHABLE;</span>
<span class="line-added">102 }</span>
<span class="line-added">103 </span>
<span class="line-added">104 bool ConstantAffixModifier::semanticallyEquivalent(const Modifier&amp; other) const {</span>
<span class="line-added">105     auto* _other = dynamic_cast&lt;const ConstantAffixModifier*&gt;(&amp;other);</span>
<span class="line-added">106     if (_other == nullptr) {</span>
<span class="line-added">107         return false;</span>
<span class="line-added">108     }</span>
<span class="line-added">109     return fPrefix == _other-&gt;fPrefix</span>
<span class="line-added">110         &amp;&amp; fSuffix == _other-&gt;fSuffix</span>
<span class="line-added">111         &amp;&amp; fField == _other-&gt;fField</span>
<span class="line-added">112         &amp;&amp; fStrong == _other-&gt;fStrong;</span>
<span class="line-added">113 }</span>
<span class="line-added">114 </span>
<span class="line-added">115 </span>
116 SimpleModifier::SimpleModifier(const SimpleFormatter &amp;simpleFormatter, Field field, bool strong)
<a name="5" id="anc5"></a><span class="line-modified">117         : SimpleModifier(simpleFormatter, field, strong, {}) {}</span>
<span class="line-added">118 </span>
<span class="line-added">119 SimpleModifier::SimpleModifier(const SimpleFormatter &amp;simpleFormatter, Field field, bool strong,</span>
<span class="line-added">120                                const Modifier::Parameters parameters)</span>
<span class="line-added">121         : fCompiledPattern(simpleFormatter.compiledPattern), fField(field), fStrong(strong),</span>
<span class="line-added">122           fParameters(parameters) {</span>
123     int32_t argLimit = SimpleFormatter::getArgumentLimit(
124             fCompiledPattern.getBuffer(), fCompiledPattern.length());
125     if (argLimit == 0) {
126         // No arguments in compiled pattern
127         fPrefixLength = fCompiledPattern.charAt(1) - ARG_NUM_LIMIT;
128         U_ASSERT(2 + fPrefixLength == fCompiledPattern.length());
129         // Set suffixOffset = -1 to indicate no arguments in compiled pattern.
130         fSuffixOffset = -1;
131         fSuffixLength = 0;
132     } else {
133         U_ASSERT(argLimit == 1);
134         if (fCompiledPattern.charAt(1) != 0) {
<a name="6" id="anc6"></a><span class="line-added">135             // Found prefix</span>
136             fPrefixLength = fCompiledPattern.charAt(1) - ARG_NUM_LIMIT;
137             fSuffixOffset = 3 + fPrefixLength;
138         } else {
<a name="7" id="anc7"></a><span class="line-added">139             // No prefix</span>
140             fPrefixLength = 0;
141             fSuffixOffset = 2;
142         }
143         if (3 + fPrefixLength &lt; fCompiledPattern.length()) {
<a name="8" id="anc8"></a><span class="line-added">144             // Found suffix</span>
145             fSuffixLength = fCompiledPattern.charAt(fSuffixOffset) - ARG_NUM_LIMIT;
146         } else {
<a name="9" id="anc9"></a><span class="line-added">147             // No suffix</span>
148             fSuffixLength = 0;
149         }
150     }
151 }
152 
153 SimpleModifier::SimpleModifier()
154         : fField(UNUM_FIELD_COUNT), fStrong(false), fPrefixLength(0), fSuffixLength(0) {
155 }
156 
157 int32_t SimpleModifier::apply(NumberStringBuilder &amp;output, int leftIndex, int rightIndex,
158                               UErrorCode &amp;status) const {
<a name="10" id="anc10"></a><span class="line-modified">159     return formatAsPrefixSuffix(output, leftIndex, rightIndex, status);</span>
160 }
161 
<a name="11" id="anc11"></a><span class="line-modified">162 int32_t SimpleModifier::getPrefixLength() const {</span>

163     return fPrefixLength;
164 }
165 
<a name="12" id="anc12"></a><span class="line-modified">166 int32_t SimpleModifier::getCodePointCount() const {</span>

167     int32_t count = 0;
168     if (fPrefixLength &gt; 0) {
169         count += fCompiledPattern.countChar32(2, fPrefixLength);
170     }
171     if (fSuffixLength &gt; 0) {
172         count += fCompiledPattern.countChar32(1 + fSuffixOffset, fSuffixLength);
173     }
174     return count;
175 }
176 
177 bool SimpleModifier::isStrong() const {
178     return fStrong;
179 }
180 
<a name="13" id="anc13"></a><span class="line-added">181 bool SimpleModifier::containsField(UNumberFormatFields field) const {</span>
<span class="line-added">182     (void)field;</span>
<span class="line-added">183     // This method is not currently used.</span>
<span class="line-added">184     UPRV_UNREACHABLE;</span>
<span class="line-added">185 }</span>
<span class="line-added">186 </span>
<span class="line-added">187 void SimpleModifier::getParameters(Parameters&amp; output) const {</span>
<span class="line-added">188     output = fParameters;</span>
<span class="line-added">189 }</span>
<span class="line-added">190 </span>
<span class="line-added">191 bool SimpleModifier::semanticallyEquivalent(const Modifier&amp; other) const {</span>
<span class="line-added">192     auto* _other = dynamic_cast&lt;const SimpleModifier*&gt;(&amp;other);</span>
<span class="line-added">193     if (_other == nullptr) {</span>
<span class="line-added">194         return false;</span>
<span class="line-added">195     }</span>
<span class="line-added">196     if (fParameters.obj != nullptr) {</span>
<span class="line-added">197         return fParameters.obj == _other-&gt;fParameters.obj;</span>
<span class="line-added">198     }</span>
<span class="line-added">199     return fCompiledPattern == _other-&gt;fCompiledPattern</span>
<span class="line-added">200         &amp;&amp; fField == _other-&gt;fField</span>
<span class="line-added">201         &amp;&amp; fStrong == _other-&gt;fStrong;</span>
<span class="line-added">202 }</span>
<span class="line-added">203 </span>
<span class="line-added">204 </span>
205 int32_t
206 SimpleModifier::formatAsPrefixSuffix(NumberStringBuilder &amp;result, int32_t startIndex, int32_t endIndex,
<a name="14" id="anc14"></a><span class="line-modified">207                                      UErrorCode &amp;status) const {</span>
<span class="line-modified">208     if (fSuffixOffset == -1 &amp;&amp; fPrefixLength + fSuffixLength &gt; 0) {</span>
209         // There is no argument for the inner number; overwrite the entire segment with our string.
<a name="15" id="anc15"></a><span class="line-modified">210         return result.splice(startIndex, endIndex, fCompiledPattern, 2, 2 + fPrefixLength, fField, status);</span>
211     } else {
212         if (fPrefixLength &gt; 0) {
<a name="16" id="anc16"></a><span class="line-modified">213             result.insert(startIndex, fCompiledPattern, 2, 2 + fPrefixLength, fField, status);</span>
214         }
215         if (fSuffixLength &gt; 0) {
216             result.insert(
217                     endIndex + fPrefixLength,
218                     fCompiledPattern,
219                     1 + fSuffixOffset,
220                     1 + fSuffixOffset + fSuffixLength,
<a name="17" id="anc17"></a><span class="line-modified">221                     fField,</span>
222                     status);
223         }
224         return fPrefixLength + fSuffixLength;
225     }
226 }
227 
<a name="18" id="anc18"></a><span class="line-added">228 </span>
<span class="line-added">229 int32_t</span>
<span class="line-added">230 SimpleModifier::formatTwoArgPattern(const SimpleFormatter&amp; compiled, NumberStringBuilder&amp; result,</span>
<span class="line-added">231                                     int32_t index, int32_t* outPrefixLength, int32_t* outSuffixLength,</span>
<span class="line-added">232                                     Field field, UErrorCode&amp; status) {</span>
<span class="line-added">233     const UnicodeString&amp; compiledPattern = compiled.compiledPattern;</span>
<span class="line-added">234     int32_t argLimit = SimpleFormatter::getArgumentLimit(</span>
<span class="line-added">235             compiledPattern.getBuffer(), compiledPattern.length());</span>
<span class="line-added">236     if (argLimit != 2) {</span>
<span class="line-added">237         status = U_INTERNAL_PROGRAM_ERROR;</span>
<span class="line-added">238         return 0;</span>
<span class="line-added">239     }</span>
<span class="line-added">240     int32_t offset = 1; // offset into compiledPattern</span>
<span class="line-added">241     int32_t length = 0; // chars added to result</span>
<span class="line-added">242 </span>
<span class="line-added">243     int32_t prefixLength = compiledPattern.charAt(offset);</span>
<span class="line-added">244     offset++;</span>
<span class="line-added">245     if (prefixLength &lt; ARG_NUM_LIMIT) {</span>
<span class="line-added">246         // No prefix</span>
<span class="line-added">247         prefixLength = 0;</span>
<span class="line-added">248     } else {</span>
<span class="line-added">249         prefixLength -= ARG_NUM_LIMIT;</span>
<span class="line-added">250         result.insert(index + length, compiledPattern, offset, offset + prefixLength, field, status);</span>
<span class="line-added">251         offset += prefixLength;</span>
<span class="line-added">252         length += prefixLength;</span>
<span class="line-added">253         offset++;</span>
<span class="line-added">254     }</span>
<span class="line-added">255 </span>
<span class="line-added">256     int32_t infixLength = compiledPattern.charAt(offset);</span>
<span class="line-added">257     offset++;</span>
<span class="line-added">258     if (infixLength &lt; ARG_NUM_LIMIT) {</span>
<span class="line-added">259         // No infix</span>
<span class="line-added">260         infixLength = 0;</span>
<span class="line-added">261     } else {</span>
<span class="line-added">262         infixLength -= ARG_NUM_LIMIT;</span>
<span class="line-added">263         result.insert(index + length, compiledPattern, offset, offset + infixLength, field, status);</span>
<span class="line-added">264         offset += infixLength;</span>
<span class="line-added">265         length += infixLength;</span>
<span class="line-added">266         offset++;</span>
<span class="line-added">267     }</span>
<span class="line-added">268 </span>
<span class="line-added">269     int32_t suffixLength;</span>
<span class="line-added">270     if (offset == compiledPattern.length()) {</span>
<span class="line-added">271         // No suffix</span>
<span class="line-added">272         suffixLength = 0;</span>
<span class="line-added">273     } else {</span>
<span class="line-added">274         suffixLength = compiledPattern.charAt(offset) -  ARG_NUM_LIMIT;</span>
<span class="line-added">275         offset++;</span>
<span class="line-added">276         result.insert(index + length, compiledPattern, offset, offset + suffixLength, field, status);</span>
<span class="line-added">277         length += suffixLength;</span>
<span class="line-added">278     }</span>
<span class="line-added">279 </span>
<span class="line-added">280     *outPrefixLength = prefixLength;</span>
<span class="line-added">281     *outSuffixLength = suffixLength;</span>
<span class="line-added">282 </span>
<span class="line-added">283     return length;</span>
<span class="line-added">284 }</span>
<span class="line-added">285 </span>
<span class="line-added">286 </span>
287 int32_t ConstantMultiFieldModifier::apply(NumberStringBuilder &amp;output, int leftIndex, int rightIndex,
288                                           UErrorCode &amp;status) const {
289     int32_t length = output.insert(leftIndex, fPrefix, status);
290     if (fOverwrite) {
291         length += output.splice(
292             leftIndex + length,
293             rightIndex + length,
294             UnicodeString(), 0, 0,
295             UNUM_FIELD_COUNT, status);
296     }
297     length += output.insert(rightIndex + length, fSuffix, status);
298     return length;
299 }
300 
<a name="19" id="anc19"></a><span class="line-modified">301 int32_t ConstantMultiFieldModifier::getPrefixLength() const {</span>

302     return fPrefix.length();
303 }
304 
<a name="20" id="anc20"></a><span class="line-modified">305 int32_t ConstantMultiFieldModifier::getCodePointCount() const {</span>

306     return fPrefix.codePointCount() + fSuffix.codePointCount();
307 }
308 
309 bool ConstantMultiFieldModifier::isStrong() const {
310     return fStrong;
311 }
312 
<a name="21" id="anc21"></a><span class="line-added">313 bool ConstantMultiFieldModifier::containsField(UNumberFormatFields field) const {</span>
<span class="line-added">314     return fPrefix.containsField(field) || fSuffix.containsField(field);</span>
<span class="line-added">315 }</span>
<span class="line-added">316 </span>
<span class="line-added">317 void ConstantMultiFieldModifier::getParameters(Parameters&amp; output) const {</span>
<span class="line-added">318     output = fParameters;</span>
<span class="line-added">319 }</span>
<span class="line-added">320 </span>
<span class="line-added">321 bool ConstantMultiFieldModifier::semanticallyEquivalent(const Modifier&amp; other) const {</span>
<span class="line-added">322     auto* _other = dynamic_cast&lt;const ConstantMultiFieldModifier*&gt;(&amp;other);</span>
<span class="line-added">323     if (_other == nullptr) {</span>
<span class="line-added">324         return false;</span>
<span class="line-added">325     }</span>
<span class="line-added">326     if (fParameters.obj != nullptr) {</span>
<span class="line-added">327         return fParameters.obj == _other-&gt;fParameters.obj;</span>
<span class="line-added">328     }</span>
<span class="line-added">329     return fPrefix.contentEquals(_other-&gt;fPrefix)</span>
<span class="line-added">330         &amp;&amp; fSuffix.contentEquals(_other-&gt;fSuffix)</span>
<span class="line-added">331         &amp;&amp; fOverwrite == _other-&gt;fOverwrite</span>
<span class="line-added">332         &amp;&amp; fStrong == _other-&gt;fStrong;</span>
<span class="line-added">333 }</span>
<span class="line-added">334 </span>
<span class="line-added">335 </span>
336 CurrencySpacingEnabledModifier::CurrencySpacingEnabledModifier(const NumberStringBuilder &amp;prefix,
337                                                                const NumberStringBuilder &amp;suffix,
338                                                                bool overwrite,
339                                                                bool strong,
340                                                                const DecimalFormatSymbols &amp;symbols,
341                                                                UErrorCode &amp;status)
342         : ConstantMultiFieldModifier(prefix, suffix, overwrite, strong) {
343     // Check for currency spacing. Do not build the UnicodeSets unless there is
344     // a currency code point at a boundary.
345     if (prefix.length() &gt; 0 &amp;&amp; prefix.fieldAt(prefix.length() - 1) == UNUM_CURRENCY_FIELD) {
346         int prefixCp = prefix.getLastCodePoint();
347         UnicodeSet prefixUnicodeSet = getUnicodeSet(symbols, IN_CURRENCY, PREFIX, status);
348         if (prefixUnicodeSet.contains(prefixCp)) {
349             fAfterPrefixUnicodeSet = getUnicodeSet(symbols, IN_NUMBER, PREFIX, status);
350             fAfterPrefixUnicodeSet.freeze();
351             fAfterPrefixInsert = getInsertString(symbols, PREFIX, status);
352         } else {
353             fAfterPrefixUnicodeSet.setToBogus();
354             fAfterPrefixInsert.setToBogus();
355         }
356     } else {
357         fAfterPrefixUnicodeSet.setToBogus();
358         fAfterPrefixInsert.setToBogus();
359     }
360     if (suffix.length() &gt; 0 &amp;&amp; suffix.fieldAt(0) == UNUM_CURRENCY_FIELD) {
361         int suffixCp = suffix.getLastCodePoint();
362         UnicodeSet suffixUnicodeSet = getUnicodeSet(symbols, IN_CURRENCY, SUFFIX, status);
363         if (suffixUnicodeSet.contains(suffixCp)) {
364             fBeforeSuffixUnicodeSet = getUnicodeSet(symbols, IN_NUMBER, SUFFIX, status);
365             fBeforeSuffixUnicodeSet.freeze();
366             fBeforeSuffixInsert = getInsertString(symbols, SUFFIX, status);
367         } else {
368             fBeforeSuffixUnicodeSet.setToBogus();
369             fBeforeSuffixInsert.setToBogus();
370         }
371     } else {
372         fBeforeSuffixUnicodeSet.setToBogus();
373         fBeforeSuffixInsert.setToBogus();
374     }
375 }
376 
377 int32_t CurrencySpacingEnabledModifier::apply(NumberStringBuilder &amp;output, int leftIndex, int rightIndex,
378                                               UErrorCode &amp;status) const {
379     // Currency spacing logic
380     int length = 0;
381     if (rightIndex - leftIndex &gt; 0 &amp;&amp; !fAfterPrefixUnicodeSet.isBogus() &amp;&amp;
382         fAfterPrefixUnicodeSet.contains(output.codePointAt(leftIndex))) {
383         // TODO: Should we use the CURRENCY field here?
384         length += output.insert(leftIndex, fAfterPrefixInsert, UNUM_FIELD_COUNT, status);
385     }
386     if (rightIndex - leftIndex &gt; 0 &amp;&amp; !fBeforeSuffixUnicodeSet.isBogus() &amp;&amp;
387         fBeforeSuffixUnicodeSet.contains(output.codePointBefore(rightIndex))) {
388         // TODO: Should we use the CURRENCY field here?
389         length += output.insert(rightIndex + length, fBeforeSuffixInsert, UNUM_FIELD_COUNT, status);
390     }
391 
392     // Call super for the remaining logic
393     length += ConstantMultiFieldModifier::apply(output, leftIndex, rightIndex + length, status);
394     return length;
395 }
396 
397 int32_t
398 CurrencySpacingEnabledModifier::applyCurrencySpacing(NumberStringBuilder &amp;output, int32_t prefixStart,
399                                                      int32_t prefixLen, int32_t suffixStart,
400                                                      int32_t suffixLen,
401                                                      const DecimalFormatSymbols &amp;symbols,
402                                                      UErrorCode &amp;status) {
403     int length = 0;
404     bool hasPrefix = (prefixLen &gt; 0);
405     bool hasSuffix = (suffixLen &gt; 0);
406     bool hasNumber = (suffixStart - prefixStart - prefixLen &gt; 0); // could be empty string
407     if (hasPrefix &amp;&amp; hasNumber) {
408         length += applyCurrencySpacingAffix(output, prefixStart + prefixLen, PREFIX, symbols, status);
409     }
410     if (hasSuffix &amp;&amp; hasNumber) {
411         length += applyCurrencySpacingAffix(output, suffixStart + length, SUFFIX, symbols, status);
412     }
413     return length;
414 }
415 
416 int32_t
417 CurrencySpacingEnabledModifier::applyCurrencySpacingAffix(NumberStringBuilder &amp;output, int32_t index,
418                                                           EAffix affix,
419                                                           const DecimalFormatSymbols &amp;symbols,
420                                                           UErrorCode &amp;status) {
421     // NOTE: For prefix, output.fieldAt(index-1) gets the last field type in the prefix.
422     // This works even if the last code point in the prefix is 2 code units because the
423     // field value gets populated to both indices in the field array.
424     Field affixField = (affix == PREFIX) ? output.fieldAt(index - 1) : output.fieldAt(index);
425     if (affixField != UNUM_CURRENCY_FIELD) {
426         return 0;
427     }
428     int affixCp = (affix == PREFIX) ? output.codePointBefore(index) : output.codePointAt(index);
429     UnicodeSet affixUniset = getUnicodeSet(symbols, IN_CURRENCY, affix, status);
430     if (!affixUniset.contains(affixCp)) {
431         return 0;
432     }
433     int numberCp = (affix == PREFIX) ? output.codePointAt(index) : output.codePointBefore(index);
434     UnicodeSet numberUniset = getUnicodeSet(symbols, IN_NUMBER, affix, status);
435     if (!numberUniset.contains(numberCp)) {
436         return 0;
437     }
438     UnicodeString spacingString = getInsertString(symbols, affix, status);
439 
440     // NOTE: This next line *inserts* the spacing string, triggering an arraycopy.
441     // It would be more efficient if this could be done before affixes were attached,
442     // so that it could be prepended/appended instead of inserted.
443     // However, the build code path is more efficient, and this is the most natural
444     // place to put currency spacing in the non-build code path.
445     // TODO: Should we use the CURRENCY field here?
446     return output.insert(index, spacingString, UNUM_FIELD_COUNT, status);
447 }
448 
449 UnicodeSet
450 CurrencySpacingEnabledModifier::getUnicodeSet(const DecimalFormatSymbols &amp;symbols, EPosition position,
451                                               EAffix affix, UErrorCode &amp;status) {
452     // Ensure the static defaults are initialized:
453     umtx_initOnce(gDefaultCurrencySpacingInitOnce, &amp;initDefaultCurrencySpacing, status);
454     if (U_FAILURE(status)) {
455         return UnicodeSet();
456     }
457 
458     const UnicodeString&amp; pattern = symbols.getPatternForCurrencySpacing(
459             position == IN_CURRENCY ? UNUM_CURRENCY_MATCH : UNUM_CURRENCY_SURROUNDING_MATCH,
460             affix == SUFFIX,
461             status);
462     if (pattern.compare(u&quot;[:digit:]&quot;, -1) == 0) {
463         return *UNISET_DIGIT;
464     } else if (pattern.compare(u&quot;[:^S:]&quot;, -1) == 0) {
465         return *UNISET_NOTS;
466     } else {
467         return UnicodeSet(pattern, status);
468     }
469 }
470 
471 UnicodeString
472 CurrencySpacingEnabledModifier::getInsertString(const DecimalFormatSymbols &amp;symbols, EAffix affix,
473                                                 UErrorCode &amp;status) {
474     return symbols.getPatternForCurrencySpacing(UNUM_CURRENCY_INSERT, affix == SUFFIX, status);
475 }
476 
477 #endif /* #if !UCONFIG_NO_FORMATTING */
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>