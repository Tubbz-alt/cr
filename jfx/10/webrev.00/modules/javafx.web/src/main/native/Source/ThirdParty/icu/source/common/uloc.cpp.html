<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 1997-2016, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 *
   9 * File ULOC.CPP
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   04/01/97    aliu        Creation.
  15 *   08/21/98    stephen     JDK 1.2 sync
  16 *   12/08/98    rtg         New Locale implementation and C API
  17 *   03/15/99    damiba      overhaul.
  18 *   04/06/99    stephen     changed setDefault() to realloc and copy
  19 *   06/14/99    stephen     Changed calls to ures_open for new params
  20 *   07/21/99    stephen     Modified setDefault() to propagate to C++
  21 *   05/14/04    alan        7 years later: refactored, cleaned up, fixed bugs,
  22 *                           brought canonicalization code into line with spec
  23 *****************************************************************************/
  24 
  25 /*
  26    POSIX&#39;s locale format, from putil.c: [no spaces]
  27 
  28      ll [ _CC ] [ . MM ] [ @ VV]
  29 
  30      l = lang, C = ctry, M = charmap, V = variant
  31 */
  32 
  33 #include &quot;unicode/utypes.h&quot;
  34 #include &quot;unicode/ustring.h&quot;
  35 #include &quot;unicode/uloc.h&quot;
  36 
  37 #include &quot;putilimp.h&quot;
  38 #include &quot;ustr_imp.h&quot;
  39 #include &quot;ulocimp.h&quot;
  40 #include &quot;umutex.h&quot;
  41 #include &quot;cstring.h&quot;
  42 #include &quot;cmemory.h&quot;
  43 #include &quot;locmap.h&quot;
  44 #include &quot;uarrsort.h&quot;
  45 #include &quot;uenumimp.h&quot;
  46 #include &quot;uassert.h&quot;
  47 #include &quot;charstr.h&quot;
  48 
  49 #include &lt;stdio.h&gt; /* for sprintf */
  50 
  51 U_NAMESPACE_USE
  52 
  53 /* ### Declarations **************************************************/
  54 
  55 /* Locale stuff from locid.cpp */
  56 U_CFUNC void locale_set_default(const char *id);
  57 U_CFUNC const char *locale_get_default(void);
  58 U_CFUNC int32_t
  59 locale_getKeywords(const char *localeID,
  60             char prev,
  61             char *keywords, int32_t keywordCapacity,
  62             char *values, int32_t valuesCapacity, int32_t *valLen,
  63             UBool valuesToo,
  64             UErrorCode *status);
  65 
  66 /* ### Data tables **************************************************/
  67 
  68 /**
  69  * Table of language codes, both 2- and 3-letter, with preference
  70  * given to 2-letter codes where possible.  Includes 3-letter codes
  71  * that lack a 2-letter equivalent.
  72  *
  73  * This list must be in sorted order.  This list is returned directly
  74  * to the user by some API.
  75  *
  76  * This list must be kept in sync with LANGUAGES_3, with corresponding
  77  * entries matched.
  78  *
  79  * This table should be terminated with a NULL entry, followed by a
  80  * second list, and another NULL entry.  The first list is visible to
  81  * user code when this array is returned by API.  The second list
  82  * contains codes we support, but do not expose through user API.
  83  *
  84  * Notes
  85  *
  86  * Tables updated per http://lcweb.loc.gov/standards/iso639-2/ to
  87  * include the revisions up to 2001/7/27 *CWB*
  88  *
  89  * The 3 character codes are the terminology codes like RFC 3066.  This
  90  * is compatible with prior ICU codes
  91  *
  92  * &quot;in&quot; &quot;iw&quot; &quot;ji&quot; &quot;jw&quot; &amp; &quot;sh&quot; have been withdrawn but are still in the
  93  * table but now at the end of the table because 3 character codes are
  94  * duplicates.  This avoids bad searches going from 3 to 2 character
  95  * codes.
  96  *
  97  * The range qaa-qtz is reserved for local use
  98  */
  99 /* Generated using org.unicode.cldr.icu.GenerateISO639LanguageTables */
 100 /* ISO639 table version is 20150505 */
 101 /* Subsequent hand addition of selected languages */
 102 static const char * const LANGUAGES[] = {
 103     &quot;aa&quot;,  &quot;ab&quot;,  &quot;ace&quot;, &quot;ach&quot;, &quot;ada&quot;, &quot;ady&quot;, &quot;ae&quot;,  &quot;aeb&quot;,
 104     &quot;af&quot;,  &quot;afh&quot;, &quot;agq&quot;, &quot;ain&quot;, &quot;ak&quot;,  &quot;akk&quot;, &quot;akz&quot;, &quot;ale&quot;,
 105     &quot;aln&quot;, &quot;alt&quot;, &quot;am&quot;,  &quot;an&quot;,  &quot;ang&quot;, &quot;anp&quot;, &quot;ar&quot;,  &quot;arc&quot;,
 106     &quot;arn&quot;, &quot;aro&quot;, &quot;arp&quot;, &quot;arq&quot;, &quot;ars&quot;, &quot;arw&quot;, &quot;ary&quot;, &quot;arz&quot;, &quot;as&quot;,
 107     &quot;asa&quot;, &quot;ase&quot;, &quot;ast&quot;, &quot;av&quot;,  &quot;avk&quot;, &quot;awa&quot;, &quot;ay&quot;,  &quot;az&quot;,
 108     &quot;ba&quot;,  &quot;bal&quot;, &quot;ban&quot;, &quot;bar&quot;, &quot;bas&quot;, &quot;bax&quot;, &quot;bbc&quot;, &quot;bbj&quot;,
 109     &quot;be&quot;,  &quot;bej&quot;, &quot;bem&quot;, &quot;bew&quot;, &quot;bez&quot;, &quot;bfd&quot;, &quot;bfq&quot;, &quot;bg&quot;,
 110     &quot;bgn&quot;, &quot;bho&quot;, &quot;bi&quot;,  &quot;bik&quot;, &quot;bin&quot;, &quot;bjn&quot;, &quot;bkm&quot;, &quot;bla&quot;,
 111     &quot;bm&quot;,  &quot;bn&quot;,  &quot;bo&quot;,  &quot;bpy&quot;, &quot;bqi&quot;, &quot;br&quot;,  &quot;bra&quot;, &quot;brh&quot;,
 112     &quot;brx&quot;, &quot;bs&quot;,  &quot;bss&quot;, &quot;bua&quot;, &quot;bug&quot;, &quot;bum&quot;, &quot;byn&quot;, &quot;byv&quot;,
 113     &quot;ca&quot;,  &quot;cad&quot;, &quot;car&quot;, &quot;cay&quot;, &quot;cch&quot;, &quot;ccp&quot;, &quot;ce&quot;,  &quot;ceb&quot;, &quot;cgg&quot;,
 114     &quot;ch&quot;,  &quot;chb&quot;, &quot;chg&quot;, &quot;chk&quot;, &quot;chm&quot;, &quot;chn&quot;, &quot;cho&quot;, &quot;chp&quot;,
 115     &quot;chr&quot;, &quot;chy&quot;, &quot;ckb&quot;, &quot;co&quot;,  &quot;cop&quot;, &quot;cps&quot;, &quot;cr&quot;,  &quot;crh&quot;,
 116     &quot;cs&quot;,  &quot;csb&quot;, &quot;cu&quot;,  &quot;cv&quot;,  &quot;cy&quot;,
 117     &quot;da&quot;,  &quot;dak&quot;, &quot;dar&quot;, &quot;dav&quot;, &quot;de&quot;,  &quot;del&quot;, &quot;den&quot;, &quot;dgr&quot;,
 118     &quot;din&quot;, &quot;dje&quot;, &quot;doi&quot;, &quot;dsb&quot;, &quot;dtp&quot;, &quot;dua&quot;, &quot;dum&quot;, &quot;dv&quot;,
 119     &quot;dyo&quot;, &quot;dyu&quot;, &quot;dz&quot;,  &quot;dzg&quot;,
 120     &quot;ebu&quot;, &quot;ee&quot;,  &quot;efi&quot;, &quot;egl&quot;, &quot;egy&quot;, &quot;eka&quot;, &quot;el&quot;,  &quot;elx&quot;,
 121     &quot;en&quot;,  &quot;enm&quot;, &quot;eo&quot;,  &quot;es&quot;,  &quot;esu&quot;, &quot;et&quot;,  &quot;eu&quot;,  &quot;ewo&quot;,
 122     &quot;ext&quot;,
 123     &quot;fa&quot;,  &quot;fan&quot;, &quot;fat&quot;, &quot;ff&quot;,  &quot;fi&quot;,  &quot;fil&quot;, &quot;fit&quot;, &quot;fj&quot;,
 124     &quot;fo&quot;,  &quot;fon&quot;, &quot;fr&quot;,  &quot;frc&quot;, &quot;frm&quot;, &quot;fro&quot;, &quot;frp&quot;, &quot;frr&quot;,
 125     &quot;frs&quot;, &quot;fur&quot;, &quot;fy&quot;,
 126     &quot;ga&quot;,  &quot;gaa&quot;, &quot;gag&quot;, &quot;gan&quot;, &quot;gay&quot;, &quot;gba&quot;, &quot;gbz&quot;, &quot;gd&quot;,
 127     &quot;gez&quot;, &quot;gil&quot;, &quot;gl&quot;,  &quot;glk&quot;, &quot;gmh&quot;, &quot;gn&quot;,  &quot;goh&quot;, &quot;gom&quot;,
 128     &quot;gon&quot;, &quot;gor&quot;, &quot;got&quot;, &quot;grb&quot;, &quot;grc&quot;, &quot;gsw&quot;, &quot;gu&quot;,  &quot;guc&quot;,
 129     &quot;gur&quot;, &quot;guz&quot;, &quot;gv&quot;,  &quot;gwi&quot;,
 130     &quot;ha&quot;,  &quot;hai&quot;, &quot;hak&quot;, &quot;haw&quot;, &quot;he&quot;,  &quot;hi&quot;,  &quot;hif&quot;, &quot;hil&quot;,
 131     &quot;hit&quot;, &quot;hmn&quot;, &quot;ho&quot;,  &quot;hr&quot;,  &quot;hsb&quot;, &quot;hsn&quot;, &quot;ht&quot;,  &quot;hu&quot;,
 132     &quot;hup&quot;, &quot;hy&quot;,  &quot;hz&quot;,
 133     &quot;ia&quot;,  &quot;iba&quot;, &quot;ibb&quot;, &quot;id&quot;,  &quot;ie&quot;,  &quot;ig&quot;,  &quot;ii&quot;,  &quot;ik&quot;,
 134     &quot;ilo&quot;, &quot;inh&quot;, &quot;io&quot;,  &quot;is&quot;,  &quot;it&quot;,  &quot;iu&quot;,  &quot;izh&quot;,
 135     &quot;ja&quot;,  &quot;jam&quot;, &quot;jbo&quot;, &quot;jgo&quot;, &quot;jmc&quot;, &quot;jpr&quot;, &quot;jrb&quot;, &quot;jut&quot;,
 136     &quot;jv&quot;,
 137     &quot;ka&quot;,  &quot;kaa&quot;, &quot;kab&quot;, &quot;kac&quot;, &quot;kaj&quot;, &quot;kam&quot;, &quot;kaw&quot;, &quot;kbd&quot;,
 138     &quot;kbl&quot;, &quot;kcg&quot;, &quot;kde&quot;, &quot;kea&quot;, &quot;ken&quot;, &quot;kfo&quot;, &quot;kg&quot;,  &quot;kgp&quot;,
 139     &quot;kha&quot;, &quot;kho&quot;, &quot;khq&quot;, &quot;khw&quot;, &quot;ki&quot;,  &quot;kiu&quot;, &quot;kj&quot;,  &quot;kk&quot;,
 140     &quot;kkj&quot;, &quot;kl&quot;,  &quot;kln&quot;, &quot;km&quot;,  &quot;kmb&quot;, &quot;kn&quot;,  &quot;ko&quot;,  &quot;koi&quot;,
 141     &quot;kok&quot;, &quot;kos&quot;, &quot;kpe&quot;, &quot;kr&quot;,  &quot;krc&quot;, &quot;kri&quot;, &quot;krj&quot;, &quot;krl&quot;,
 142     &quot;kru&quot;, &quot;ks&quot;,  &quot;ksb&quot;, &quot;ksf&quot;, &quot;ksh&quot;, &quot;ku&quot;,  &quot;kum&quot;, &quot;kut&quot;,
 143     &quot;kv&quot;,  &quot;kw&quot;,  &quot;ky&quot;,
 144     &quot;la&quot;,  &quot;lad&quot;, &quot;lag&quot;, &quot;lah&quot;, &quot;lam&quot;, &quot;lb&quot;,  &quot;lez&quot;, &quot;lfn&quot;,
 145     &quot;lg&quot;,  &quot;li&quot;,  &quot;lij&quot;, &quot;liv&quot;, &quot;lkt&quot;, &quot;lmo&quot;, &quot;ln&quot;,  &quot;lo&quot;,
 146     &quot;lol&quot;, &quot;loz&quot;, &quot;lrc&quot;, &quot;lt&quot;,  &quot;ltg&quot;, &quot;lu&quot;,  &quot;lua&quot;, &quot;lui&quot;,
 147     &quot;lun&quot;, &quot;luo&quot;, &quot;lus&quot;, &quot;luy&quot;, &quot;lv&quot;,  &quot;lzh&quot;, &quot;lzz&quot;,
 148     &quot;mad&quot;, &quot;maf&quot;, &quot;mag&quot;, &quot;mai&quot;, &quot;mak&quot;, &quot;man&quot;, &quot;mas&quot;, &quot;mde&quot;,
 149     &quot;mdf&quot;, &quot;mdh&quot;, &quot;mdr&quot;, &quot;men&quot;, &quot;mer&quot;, &quot;mfe&quot;, &quot;mg&quot;,  &quot;mga&quot;,
 150     &quot;mgh&quot;, &quot;mgo&quot;, &quot;mh&quot;,  &quot;mi&quot;,  &quot;mic&quot;, &quot;min&quot;, &quot;mis&quot;, &quot;mk&quot;,
 151     &quot;ml&quot;,  &quot;mn&quot;,  &quot;mnc&quot;, &quot;mni&quot;, &quot;moh&quot;, &quot;mos&quot;, &quot;mr&quot;,  &quot;mrj&quot;,
 152     &quot;ms&quot;,  &quot;mt&quot;,  &quot;mua&quot;, &quot;mul&quot;, &quot;mus&quot;, &quot;mwl&quot;, &quot;mwr&quot;, &quot;mwv&quot;,
 153     &quot;my&quot;,  &quot;mye&quot;, &quot;myv&quot;, &quot;mzn&quot;,
 154     &quot;na&quot;,  &quot;nan&quot;, &quot;nap&quot;, &quot;naq&quot;, &quot;nb&quot;,  &quot;nd&quot;,  &quot;nds&quot;, &quot;ne&quot;,
 155     &quot;new&quot;, &quot;ng&quot;,  &quot;nia&quot;, &quot;niu&quot;, &quot;njo&quot;, &quot;nl&quot;,  &quot;nmg&quot;, &quot;nn&quot;,
 156     &quot;nnh&quot;, &quot;no&quot;,  &quot;nog&quot;, &quot;non&quot;, &quot;nov&quot;, &quot;nqo&quot;, &quot;nr&quot;,  &quot;nso&quot;,
 157     &quot;nus&quot;, &quot;nv&quot;,  &quot;nwc&quot;, &quot;ny&quot;,  &quot;nym&quot;, &quot;nyn&quot;, &quot;nyo&quot;, &quot;nzi&quot;,
 158     &quot;oc&quot;,  &quot;oj&quot;,  &quot;om&quot;,  &quot;or&quot;,  &quot;os&quot;,  &quot;osa&quot;, &quot;ota&quot;,
 159     &quot;pa&quot;,  &quot;pag&quot;, &quot;pal&quot;, &quot;pam&quot;, &quot;pap&quot;, &quot;pau&quot;, &quot;pcd&quot;, &quot;pdc&quot;,
 160     &quot;pdt&quot;, &quot;peo&quot;, &quot;pfl&quot;, &quot;phn&quot;, &quot;pi&quot;,  &quot;pl&quot;,  &quot;pms&quot;, &quot;pnt&quot;,
 161     &quot;pon&quot;, &quot;prg&quot;, &quot;pro&quot;, &quot;ps&quot;,  &quot;pt&quot;,
 162     &quot;qu&quot;,  &quot;quc&quot;, &quot;qug&quot;,
 163     &quot;raj&quot;, &quot;rap&quot;, &quot;rar&quot;, &quot;rgn&quot;, &quot;rif&quot;, &quot;rm&quot;,  &quot;rn&quot;,  &quot;ro&quot;,
 164     &quot;rof&quot;, &quot;rom&quot;, &quot;rtm&quot;, &quot;ru&quot;,  &quot;rue&quot;, &quot;rug&quot;, &quot;rup&quot;,
 165     &quot;rw&quot;,  &quot;rwk&quot;,
 166     &quot;sa&quot;,  &quot;sad&quot;, &quot;sah&quot;, &quot;sam&quot;, &quot;saq&quot;, &quot;sas&quot;, &quot;sat&quot;, &quot;saz&quot;,
 167     &quot;sba&quot;, &quot;sbp&quot;, &quot;sc&quot;,  &quot;scn&quot;, &quot;sco&quot;, &quot;sd&quot;,  &quot;sdc&quot;, &quot;sdh&quot;,
 168     &quot;se&quot;,  &quot;see&quot;, &quot;seh&quot;, &quot;sei&quot;, &quot;sel&quot;, &quot;ses&quot;, &quot;sg&quot;,  &quot;sga&quot;,
 169     &quot;sgs&quot;, &quot;shi&quot;, &quot;shn&quot;, &quot;shu&quot;, &quot;si&quot;,  &quot;sid&quot;, &quot;sk&quot;,
 170     &quot;sl&quot;,  &quot;sli&quot;, &quot;sly&quot;, &quot;sm&quot;,  &quot;sma&quot;, &quot;smj&quot;, &quot;smn&quot;, &quot;sms&quot;,
 171     &quot;sn&quot;,  &quot;snk&quot;, &quot;so&quot;,  &quot;sog&quot;, &quot;sq&quot;,  &quot;sr&quot;,  &quot;srn&quot;, &quot;srr&quot;,
 172     &quot;ss&quot;,  &quot;ssy&quot;, &quot;st&quot;,  &quot;stq&quot;, &quot;su&quot;,  &quot;suk&quot;, &quot;sus&quot;, &quot;sux&quot;,
 173     &quot;sv&quot;,  &quot;sw&quot;,  &quot;swb&quot;, &quot;swc&quot;, &quot;syc&quot;, &quot;syr&quot;, &quot;szl&quot;,
 174     &quot;ta&quot;,  &quot;tcy&quot;, &quot;te&quot;,  &quot;tem&quot;, &quot;teo&quot;, &quot;ter&quot;, &quot;tet&quot;, &quot;tg&quot;,
 175     &quot;th&quot;,  &quot;ti&quot;,  &quot;tig&quot;, &quot;tiv&quot;, &quot;tk&quot;,  &quot;tkl&quot;, &quot;tkr&quot;, &quot;tl&quot;,
 176     &quot;tlh&quot;, &quot;tli&quot;, &quot;tly&quot;, &quot;tmh&quot;, &quot;tn&quot;,  &quot;to&quot;,  &quot;tog&quot;, &quot;tpi&quot;,
 177     &quot;tr&quot;,  &quot;tru&quot;, &quot;trv&quot;, &quot;ts&quot;,  &quot;tsd&quot;, &quot;tsi&quot;, &quot;tt&quot;,  &quot;ttt&quot;,
 178     &quot;tum&quot;, &quot;tvl&quot;, &quot;tw&quot;,  &quot;twq&quot;, &quot;ty&quot;,  &quot;tyv&quot;, &quot;tzm&quot;,
 179     &quot;udm&quot;, &quot;ug&quot;,  &quot;uga&quot;, &quot;uk&quot;,  &quot;umb&quot;, &quot;und&quot;, &quot;ur&quot;,  &quot;uz&quot;,
 180     &quot;vai&quot;, &quot;ve&quot;,  &quot;vec&quot;, &quot;vep&quot;, &quot;vi&quot;,  &quot;vls&quot;, &quot;vmf&quot;, &quot;vo&quot;,
 181     &quot;vot&quot;, &quot;vro&quot;, &quot;vun&quot;,
 182     &quot;wa&quot;,  &quot;wae&quot;, &quot;wal&quot;, &quot;war&quot;, &quot;was&quot;, &quot;wbp&quot;, &quot;wo&quot;,  &quot;wuu&quot;,
 183     &quot;xal&quot;, &quot;xh&quot;,  &quot;xmf&quot;, &quot;xog&quot;,
 184     &quot;yao&quot;, &quot;yap&quot;, &quot;yav&quot;, &quot;ybb&quot;, &quot;yi&quot;,  &quot;yo&quot;,  &quot;yrl&quot;, &quot;yue&quot;,
 185     &quot;za&quot;,  &quot;zap&quot;, &quot;zbl&quot;, &quot;zea&quot;, &quot;zen&quot;, &quot;zgh&quot;, &quot;zh&quot;,  &quot;zu&quot;,
 186     &quot;zun&quot;, &quot;zxx&quot;, &quot;zza&quot;,
 187 NULL,
 188     &quot;in&quot;,  &quot;iw&quot;,  &quot;ji&quot;,  &quot;jw&quot;,  &quot;sh&quot;,    /* obsolete language codes */
 189 NULL
 190 };
 191 
 192 static const char* const DEPRECATED_LANGUAGES[]={
 193     &quot;in&quot;, &quot;iw&quot;, &quot;ji&quot;, &quot;jw&quot;, NULL, NULL
 194 };
 195 static const char* const REPLACEMENT_LANGUAGES[]={
 196     &quot;id&quot;, &quot;he&quot;, &quot;yi&quot;, &quot;jv&quot;, NULL, NULL
 197 };
 198 
 199 /**
 200  * Table of 3-letter language codes.
 201  *
 202  * This is a lookup table used to convert 3-letter language codes to
 203  * their 2-letter equivalent, where possible.  It must be kept in sync
 204  * with LANGUAGES.  For all valid i, LANGUAGES[i] must refer to the
 205  * same language as LANGUAGES_3[i].  The commented-out lines are
 206  * copied from LANGUAGES to make eyeballing this baby easier.
 207  *
 208  * Where a 3-letter language code has no 2-letter equivalent, the
 209  * 3-letter code occupies both LANGUAGES[i] and LANGUAGES_3[i].
 210  *
 211  * This table should be terminated with a NULL entry, followed by a
 212  * second list, and another NULL entry.  The two lists correspond to
 213  * the two lists in LANGUAGES.
 214  */
 215 /* Generated using org.unicode.cldr.icu.GenerateISO639LanguageTables */
 216 /* ISO639 table version is 20150505 */
 217 /* Subsequent hand addition of selected languages */
 218 static const char * const LANGUAGES_3[] = {
 219     &quot;aar&quot;, &quot;abk&quot;, &quot;ace&quot;, &quot;ach&quot;, &quot;ada&quot;, &quot;ady&quot;, &quot;ave&quot;, &quot;aeb&quot;,
 220     &quot;afr&quot;, &quot;afh&quot;, &quot;agq&quot;, &quot;ain&quot;, &quot;aka&quot;, &quot;akk&quot;, &quot;akz&quot;, &quot;ale&quot;,
 221     &quot;aln&quot;, &quot;alt&quot;, &quot;amh&quot;, &quot;arg&quot;, &quot;ang&quot;, &quot;anp&quot;, &quot;ara&quot;, &quot;arc&quot;,
 222     &quot;arn&quot;, &quot;aro&quot;, &quot;arp&quot;, &quot;arq&quot;, &quot;ars&quot;, &quot;arw&quot;, &quot;ary&quot;, &quot;arz&quot;, &quot;asm&quot;,
 223     &quot;asa&quot;, &quot;ase&quot;, &quot;ast&quot;, &quot;ava&quot;, &quot;avk&quot;, &quot;awa&quot;, &quot;aym&quot;, &quot;aze&quot;,
 224     &quot;bak&quot;, &quot;bal&quot;, &quot;ban&quot;, &quot;bar&quot;, &quot;bas&quot;, &quot;bax&quot;, &quot;bbc&quot;, &quot;bbj&quot;,
 225     &quot;bel&quot;, &quot;bej&quot;, &quot;bem&quot;, &quot;bew&quot;, &quot;bez&quot;, &quot;bfd&quot;, &quot;bfq&quot;, &quot;bul&quot;,
 226     &quot;bgn&quot;, &quot;bho&quot;, &quot;bis&quot;, &quot;bik&quot;, &quot;bin&quot;, &quot;bjn&quot;, &quot;bkm&quot;, &quot;bla&quot;,
 227     &quot;bam&quot;, &quot;ben&quot;, &quot;bod&quot;, &quot;bpy&quot;, &quot;bqi&quot;, &quot;bre&quot;, &quot;bra&quot;, &quot;brh&quot;,
 228     &quot;brx&quot;, &quot;bos&quot;, &quot;bss&quot;, &quot;bua&quot;, &quot;bug&quot;, &quot;bum&quot;, &quot;byn&quot;, &quot;byv&quot;,
 229     &quot;cat&quot;, &quot;cad&quot;, &quot;car&quot;, &quot;cay&quot;, &quot;cch&quot;, &quot;ccp&quot;, &quot;che&quot;, &quot;ceb&quot;, &quot;cgg&quot;,
 230     &quot;cha&quot;, &quot;chb&quot;, &quot;chg&quot;, &quot;chk&quot;, &quot;chm&quot;, &quot;chn&quot;, &quot;cho&quot;, &quot;chp&quot;,
 231     &quot;chr&quot;, &quot;chy&quot;, &quot;ckb&quot;, &quot;cos&quot;, &quot;cop&quot;, &quot;cps&quot;, &quot;cre&quot;, &quot;crh&quot;,
 232     &quot;ces&quot;, &quot;csb&quot;, &quot;chu&quot;, &quot;chv&quot;, &quot;cym&quot;,
 233     &quot;dan&quot;, &quot;dak&quot;, &quot;dar&quot;, &quot;dav&quot;, &quot;deu&quot;, &quot;del&quot;, &quot;den&quot;, &quot;dgr&quot;,
 234     &quot;din&quot;, &quot;dje&quot;, &quot;doi&quot;, &quot;dsb&quot;, &quot;dtp&quot;, &quot;dua&quot;, &quot;dum&quot;, &quot;div&quot;,
 235     &quot;dyo&quot;, &quot;dyu&quot;, &quot;dzo&quot;, &quot;dzg&quot;,
 236     &quot;ebu&quot;, &quot;ewe&quot;, &quot;efi&quot;, &quot;egl&quot;, &quot;egy&quot;, &quot;eka&quot;, &quot;ell&quot;, &quot;elx&quot;,
 237     &quot;eng&quot;, &quot;enm&quot;, &quot;epo&quot;, &quot;spa&quot;, &quot;esu&quot;, &quot;est&quot;, &quot;eus&quot;, &quot;ewo&quot;,
 238     &quot;ext&quot;,
 239     &quot;fas&quot;, &quot;fan&quot;, &quot;fat&quot;, &quot;ful&quot;, &quot;fin&quot;, &quot;fil&quot;, &quot;fit&quot;, &quot;fij&quot;,
 240     &quot;fao&quot;, &quot;fon&quot;, &quot;fra&quot;, &quot;frc&quot;, &quot;frm&quot;, &quot;fro&quot;, &quot;frp&quot;, &quot;frr&quot;,
 241     &quot;frs&quot;, &quot;fur&quot;, &quot;fry&quot;,
 242     &quot;gle&quot;, &quot;gaa&quot;, &quot;gag&quot;, &quot;gan&quot;, &quot;gay&quot;, &quot;gba&quot;, &quot;gbz&quot;, &quot;gla&quot;,
 243     &quot;gez&quot;, &quot;gil&quot;, &quot;glg&quot;, &quot;glk&quot;, &quot;gmh&quot;, &quot;grn&quot;, &quot;goh&quot;, &quot;gom&quot;,
 244     &quot;gon&quot;, &quot;gor&quot;, &quot;got&quot;, &quot;grb&quot;, &quot;grc&quot;, &quot;gsw&quot;, &quot;guj&quot;, &quot;guc&quot;,
 245     &quot;gur&quot;, &quot;guz&quot;, &quot;glv&quot;, &quot;gwi&quot;,
 246     &quot;hau&quot;, &quot;hai&quot;, &quot;hak&quot;, &quot;haw&quot;, &quot;heb&quot;, &quot;hin&quot;, &quot;hif&quot;, &quot;hil&quot;,
 247     &quot;hit&quot;, &quot;hmn&quot;, &quot;hmo&quot;, &quot;hrv&quot;, &quot;hsb&quot;, &quot;hsn&quot;, &quot;hat&quot;, &quot;hun&quot;,
 248     &quot;hup&quot;, &quot;hye&quot;, &quot;her&quot;,
 249     &quot;ina&quot;, &quot;iba&quot;, &quot;ibb&quot;, &quot;ind&quot;, &quot;ile&quot;, &quot;ibo&quot;, &quot;iii&quot;, &quot;ipk&quot;,
 250     &quot;ilo&quot;, &quot;inh&quot;, &quot;ido&quot;, &quot;isl&quot;, &quot;ita&quot;, &quot;iku&quot;, &quot;izh&quot;,
 251     &quot;jpn&quot;, &quot;jam&quot;, &quot;jbo&quot;, &quot;jgo&quot;, &quot;jmc&quot;, &quot;jpr&quot;, &quot;jrb&quot;, &quot;jut&quot;,
 252     &quot;jav&quot;,
 253     &quot;kat&quot;, &quot;kaa&quot;, &quot;kab&quot;, &quot;kac&quot;, &quot;kaj&quot;, &quot;kam&quot;, &quot;kaw&quot;, &quot;kbd&quot;,
 254     &quot;kbl&quot;, &quot;kcg&quot;, &quot;kde&quot;, &quot;kea&quot;, &quot;ken&quot;, &quot;kfo&quot;, &quot;kon&quot;, &quot;kgp&quot;,
 255     &quot;kha&quot;, &quot;kho&quot;, &quot;khq&quot;, &quot;khw&quot;, &quot;kik&quot;, &quot;kiu&quot;, &quot;kua&quot;, &quot;kaz&quot;,
 256     &quot;kkj&quot;, &quot;kal&quot;, &quot;kln&quot;, &quot;khm&quot;, &quot;kmb&quot;, &quot;kan&quot;, &quot;kor&quot;, &quot;koi&quot;,
 257     &quot;kok&quot;, &quot;kos&quot;, &quot;kpe&quot;, &quot;kau&quot;, &quot;krc&quot;, &quot;kri&quot;, &quot;krj&quot;, &quot;krl&quot;,
 258     &quot;kru&quot;, &quot;kas&quot;, &quot;ksb&quot;, &quot;ksf&quot;, &quot;ksh&quot;, &quot;kur&quot;, &quot;kum&quot;, &quot;kut&quot;,
 259     &quot;kom&quot;, &quot;cor&quot;, &quot;kir&quot;,
 260     &quot;lat&quot;, &quot;lad&quot;, &quot;lag&quot;, &quot;lah&quot;, &quot;lam&quot;, &quot;ltz&quot;, &quot;lez&quot;, &quot;lfn&quot;,
 261     &quot;lug&quot;, &quot;lim&quot;, &quot;lij&quot;, &quot;liv&quot;, &quot;lkt&quot;, &quot;lmo&quot;, &quot;lin&quot;, &quot;lao&quot;,
 262     &quot;lol&quot;, &quot;loz&quot;, &quot;lrc&quot;, &quot;lit&quot;, &quot;ltg&quot;, &quot;lub&quot;, &quot;lua&quot;, &quot;lui&quot;,
 263     &quot;lun&quot;, &quot;luo&quot;, &quot;lus&quot;, &quot;luy&quot;, &quot;lav&quot;, &quot;lzh&quot;, &quot;lzz&quot;,
 264     &quot;mad&quot;, &quot;maf&quot;, &quot;mag&quot;, &quot;mai&quot;, &quot;mak&quot;, &quot;man&quot;, &quot;mas&quot;, &quot;mde&quot;,
 265     &quot;mdf&quot;, &quot;mdh&quot;, &quot;mdr&quot;, &quot;men&quot;, &quot;mer&quot;, &quot;mfe&quot;, &quot;mlg&quot;, &quot;mga&quot;,
 266     &quot;mgh&quot;, &quot;mgo&quot;, &quot;mah&quot;, &quot;mri&quot;, &quot;mic&quot;, &quot;min&quot;, &quot;mis&quot;, &quot;mkd&quot;,
 267     &quot;mal&quot;, &quot;mon&quot;, &quot;mnc&quot;, &quot;mni&quot;, &quot;moh&quot;, &quot;mos&quot;, &quot;mar&quot;, &quot;mrj&quot;,
 268     &quot;msa&quot;, &quot;mlt&quot;, &quot;mua&quot;, &quot;mul&quot;, &quot;mus&quot;, &quot;mwl&quot;, &quot;mwr&quot;, &quot;mwv&quot;,
 269     &quot;mya&quot;, &quot;mye&quot;, &quot;myv&quot;, &quot;mzn&quot;,
 270     &quot;nau&quot;, &quot;nan&quot;, &quot;nap&quot;, &quot;naq&quot;, &quot;nob&quot;, &quot;nde&quot;, &quot;nds&quot;, &quot;nep&quot;,
 271     &quot;new&quot;, &quot;ndo&quot;, &quot;nia&quot;, &quot;niu&quot;, &quot;njo&quot;, &quot;nld&quot;, &quot;nmg&quot;, &quot;nno&quot;,
 272     &quot;nnh&quot;, &quot;nor&quot;, &quot;nog&quot;, &quot;non&quot;, &quot;nov&quot;, &quot;nqo&quot;, &quot;nbl&quot;, &quot;nso&quot;,
 273     &quot;nus&quot;, &quot;nav&quot;, &quot;nwc&quot;, &quot;nya&quot;, &quot;nym&quot;, &quot;nyn&quot;, &quot;nyo&quot;, &quot;nzi&quot;,
 274     &quot;oci&quot;, &quot;oji&quot;, &quot;orm&quot;, &quot;ori&quot;, &quot;oss&quot;, &quot;osa&quot;, &quot;ota&quot;,
 275     &quot;pan&quot;, &quot;pag&quot;, &quot;pal&quot;, &quot;pam&quot;, &quot;pap&quot;, &quot;pau&quot;, &quot;pcd&quot;, &quot;pdc&quot;,
 276     &quot;pdt&quot;, &quot;peo&quot;, &quot;pfl&quot;, &quot;phn&quot;, &quot;pli&quot;, &quot;pol&quot;, &quot;pms&quot;, &quot;pnt&quot;,
 277     &quot;pon&quot;, &quot;prg&quot;, &quot;pro&quot;, &quot;pus&quot;, &quot;por&quot;,
 278     &quot;que&quot;, &quot;quc&quot;, &quot;qug&quot;,
 279     &quot;raj&quot;, &quot;rap&quot;, &quot;rar&quot;, &quot;rgn&quot;, &quot;rif&quot;, &quot;roh&quot;, &quot;run&quot;, &quot;ron&quot;,
 280     &quot;rof&quot;, &quot;rom&quot;, &quot;rtm&quot;, &quot;rus&quot;, &quot;rue&quot;, &quot;rug&quot;, &quot;rup&quot;,
 281     &quot;kin&quot;, &quot;rwk&quot;,
 282     &quot;san&quot;, &quot;sad&quot;, &quot;sah&quot;, &quot;sam&quot;, &quot;saq&quot;, &quot;sas&quot;, &quot;sat&quot;, &quot;saz&quot;,
 283     &quot;sba&quot;, &quot;sbp&quot;, &quot;srd&quot;, &quot;scn&quot;, &quot;sco&quot;, &quot;snd&quot;, &quot;sdc&quot;, &quot;sdh&quot;,
 284     &quot;sme&quot;, &quot;see&quot;, &quot;seh&quot;, &quot;sei&quot;, &quot;sel&quot;, &quot;ses&quot;, &quot;sag&quot;, &quot;sga&quot;,
 285     &quot;sgs&quot;, &quot;shi&quot;, &quot;shn&quot;, &quot;shu&quot;, &quot;sin&quot;, &quot;sid&quot;, &quot;slk&quot;,
 286     &quot;slv&quot;, &quot;sli&quot;, &quot;sly&quot;, &quot;smo&quot;, &quot;sma&quot;, &quot;smj&quot;, &quot;smn&quot;, &quot;sms&quot;,
 287     &quot;sna&quot;, &quot;snk&quot;, &quot;som&quot;, &quot;sog&quot;, &quot;sqi&quot;, &quot;srp&quot;, &quot;srn&quot;, &quot;srr&quot;,
 288     &quot;ssw&quot;, &quot;ssy&quot;, &quot;sot&quot;, &quot;stq&quot;, &quot;sun&quot;, &quot;suk&quot;, &quot;sus&quot;, &quot;sux&quot;,
 289     &quot;swe&quot;, &quot;swa&quot;, &quot;swb&quot;, &quot;swc&quot;, &quot;syc&quot;, &quot;syr&quot;, &quot;szl&quot;,
 290     &quot;tam&quot;, &quot;tcy&quot;, &quot;tel&quot;, &quot;tem&quot;, &quot;teo&quot;, &quot;ter&quot;, &quot;tet&quot;, &quot;tgk&quot;,
 291     &quot;tha&quot;, &quot;tir&quot;, &quot;tig&quot;, &quot;tiv&quot;, &quot;tuk&quot;, &quot;tkl&quot;, &quot;tkr&quot;, &quot;tgl&quot;,
 292     &quot;tlh&quot;, &quot;tli&quot;, &quot;tly&quot;, &quot;tmh&quot;, &quot;tsn&quot;, &quot;ton&quot;, &quot;tog&quot;, &quot;tpi&quot;,
 293     &quot;tur&quot;, &quot;tru&quot;, &quot;trv&quot;, &quot;tso&quot;, &quot;tsd&quot;, &quot;tsi&quot;, &quot;tat&quot;, &quot;ttt&quot;,
 294     &quot;tum&quot;, &quot;tvl&quot;, &quot;twi&quot;, &quot;twq&quot;, &quot;tah&quot;, &quot;tyv&quot;, &quot;tzm&quot;,
 295     &quot;udm&quot;, &quot;uig&quot;, &quot;uga&quot;, &quot;ukr&quot;, &quot;umb&quot;, &quot;und&quot;, &quot;urd&quot;, &quot;uzb&quot;,
 296     &quot;vai&quot;, &quot;ven&quot;, &quot;vec&quot;, &quot;vep&quot;, &quot;vie&quot;, &quot;vls&quot;, &quot;vmf&quot;, &quot;vol&quot;,
 297     &quot;vot&quot;, &quot;vro&quot;, &quot;vun&quot;,
 298     &quot;wln&quot;, &quot;wae&quot;, &quot;wal&quot;, &quot;war&quot;, &quot;was&quot;, &quot;wbp&quot;, &quot;wol&quot;, &quot;wuu&quot;,
 299     &quot;xal&quot;, &quot;xho&quot;, &quot;xmf&quot;, &quot;xog&quot;,
 300     &quot;yao&quot;, &quot;yap&quot;, &quot;yav&quot;, &quot;ybb&quot;, &quot;yid&quot;, &quot;yor&quot;, &quot;yrl&quot;, &quot;yue&quot;,
 301     &quot;zha&quot;, &quot;zap&quot;, &quot;zbl&quot;, &quot;zea&quot;, &quot;zen&quot;, &quot;zgh&quot;, &quot;zho&quot;, &quot;zul&quot;,
 302     &quot;zun&quot;, &quot;zxx&quot;, &quot;zza&quot;,
 303 NULL,
 304 /*  &quot;in&quot;,  &quot;iw&quot;,  &quot;ji&quot;,  &quot;jw&quot;,  &quot;sh&quot;,                          */
 305     &quot;ind&quot;, &quot;heb&quot;, &quot;yid&quot;, &quot;jaw&quot;, &quot;srp&quot;,
 306 NULL
 307 };
 308 
 309 /**
 310  * Table of 2-letter country codes.
 311  *
 312  * This list must be in sorted order.  This list is returned directly
 313  * to the user by some API.
 314  *
 315  * This list must be kept in sync with COUNTRIES_3, with corresponding
 316  * entries matched.
 317  *
 318  * This table should be terminated with a NULL entry, followed by a
 319  * second list, and another NULL entry.  The first list is visible to
 320  * user code when this array is returned by API.  The second list
 321  * contains codes we support, but do not expose through user API.
 322  *
 323  * Notes:
 324  *
 325  * ZR(ZAR) is now CD(COD) and FX(FXX) is PS(PSE) as per
 326  * http://www.evertype.com/standards/iso3166/iso3166-1-en.html added
 327  * new codes keeping the old ones for compatibility updated to include
 328  * 1999/12/03 revisions *CWB*
 329  *
 330  * RO(ROM) is now RO(ROU) according to
 331  * http://www.iso.org/iso/en/prods-services/iso3166ma/03updates-on-iso-3166/nlv3e-rou.html
 332  */
 333 static const char * const COUNTRIES[] = {
 334     &quot;AD&quot;,  &quot;AE&quot;,  &quot;AF&quot;,  &quot;AG&quot;,  &quot;AI&quot;,  &quot;AL&quot;,  &quot;AM&quot;,
 335     &quot;AO&quot;,  &quot;AQ&quot;,  &quot;AR&quot;,  &quot;AS&quot;,  &quot;AT&quot;,  &quot;AU&quot;,  &quot;AW&quot;,  &quot;AX&quot;,  &quot;AZ&quot;,
 336     &quot;BA&quot;,  &quot;BB&quot;,  &quot;BD&quot;,  &quot;BE&quot;,  &quot;BF&quot;,  &quot;BG&quot;,  &quot;BH&quot;,  &quot;BI&quot;,
 337     &quot;BJ&quot;,  &quot;BL&quot;,  &quot;BM&quot;,  &quot;BN&quot;,  &quot;BO&quot;,  &quot;BQ&quot;,  &quot;BR&quot;,  &quot;BS&quot;,  &quot;BT&quot;,  &quot;BV&quot;,
 338     &quot;BW&quot;,  &quot;BY&quot;,  &quot;BZ&quot;,  &quot;CA&quot;,  &quot;CC&quot;,  &quot;CD&quot;,  &quot;CF&quot;,  &quot;CG&quot;,
 339     &quot;CH&quot;,  &quot;CI&quot;,  &quot;CK&quot;,  &quot;CL&quot;,  &quot;CM&quot;,  &quot;CN&quot;,  &quot;CO&quot;,  &quot;CR&quot;,
 340     &quot;CU&quot;,  &quot;CV&quot;,  &quot;CW&quot;,  &quot;CX&quot;,  &quot;CY&quot;,  &quot;CZ&quot;,  &quot;DE&quot;,  &quot;DJ&quot;,  &quot;DK&quot;,
 341     &quot;DM&quot;,  &quot;DO&quot;,  &quot;DZ&quot;,  &quot;EC&quot;,  &quot;EE&quot;,  &quot;EG&quot;,  &quot;EH&quot;,  &quot;ER&quot;,
 342     &quot;ES&quot;,  &quot;ET&quot;,  &quot;FI&quot;,  &quot;FJ&quot;,  &quot;FK&quot;,  &quot;FM&quot;,  &quot;FO&quot;,  &quot;FR&quot;,
 343     &quot;GA&quot;,  &quot;GB&quot;,  &quot;GD&quot;,  &quot;GE&quot;,  &quot;GF&quot;,  &quot;GG&quot;,  &quot;GH&quot;,  &quot;GI&quot;,  &quot;GL&quot;,
 344     &quot;GM&quot;,  &quot;GN&quot;,  &quot;GP&quot;,  &quot;GQ&quot;,  &quot;GR&quot;,  &quot;GS&quot;,  &quot;GT&quot;,  &quot;GU&quot;,
 345     &quot;GW&quot;,  &quot;GY&quot;,  &quot;HK&quot;,  &quot;HM&quot;,  &quot;HN&quot;,  &quot;HR&quot;,  &quot;HT&quot;,  &quot;HU&quot;,
 346     &quot;ID&quot;,  &quot;IE&quot;,  &quot;IL&quot;,  &quot;IM&quot;,  &quot;IN&quot;,  &quot;IO&quot;,  &quot;IQ&quot;,  &quot;IR&quot;,  &quot;IS&quot;,
 347     &quot;IT&quot;,  &quot;JE&quot;,  &quot;JM&quot;,  &quot;JO&quot;,  &quot;JP&quot;,  &quot;KE&quot;,  &quot;KG&quot;,  &quot;KH&quot;,  &quot;KI&quot;,
 348     &quot;KM&quot;,  &quot;KN&quot;,  &quot;KP&quot;,  &quot;KR&quot;,  &quot;KW&quot;,  &quot;KY&quot;,  &quot;KZ&quot;,  &quot;LA&quot;,
 349     &quot;LB&quot;,  &quot;LC&quot;,  &quot;LI&quot;,  &quot;LK&quot;,  &quot;LR&quot;,  &quot;LS&quot;,  &quot;LT&quot;,  &quot;LU&quot;,
 350     &quot;LV&quot;,  &quot;LY&quot;,  &quot;MA&quot;,  &quot;MC&quot;,  &quot;MD&quot;,  &quot;ME&quot;,  &quot;MF&quot;,  &quot;MG&quot;,  &quot;MH&quot;,  &quot;MK&quot;,
 351     &quot;ML&quot;,  &quot;MM&quot;,  &quot;MN&quot;,  &quot;MO&quot;,  &quot;MP&quot;,  &quot;MQ&quot;,  &quot;MR&quot;,  &quot;MS&quot;,
 352     &quot;MT&quot;,  &quot;MU&quot;,  &quot;MV&quot;,  &quot;MW&quot;,  &quot;MX&quot;,  &quot;MY&quot;,  &quot;MZ&quot;,  &quot;NA&quot;,
 353     &quot;NC&quot;,  &quot;NE&quot;,  &quot;NF&quot;,  &quot;NG&quot;,  &quot;NI&quot;,  &quot;NL&quot;,  &quot;NO&quot;,  &quot;NP&quot;,
 354     &quot;NR&quot;,  &quot;NU&quot;,  &quot;NZ&quot;,  &quot;OM&quot;,  &quot;PA&quot;,  &quot;PE&quot;,  &quot;PF&quot;,  &quot;PG&quot;,
 355     &quot;PH&quot;,  &quot;PK&quot;,  &quot;PL&quot;,  &quot;PM&quot;,  &quot;PN&quot;,  &quot;PR&quot;,  &quot;PS&quot;,  &quot;PT&quot;,
 356     &quot;PW&quot;,  &quot;PY&quot;,  &quot;QA&quot;,  &quot;RE&quot;,  &quot;RO&quot;,  &quot;RS&quot;,  &quot;RU&quot;,  &quot;RW&quot;,  &quot;SA&quot;,
 357     &quot;SB&quot;,  &quot;SC&quot;,  &quot;SD&quot;,  &quot;SE&quot;,  &quot;SG&quot;,  &quot;SH&quot;,  &quot;SI&quot;,  &quot;SJ&quot;,
 358     &quot;SK&quot;,  &quot;SL&quot;,  &quot;SM&quot;,  &quot;SN&quot;,  &quot;SO&quot;,  &quot;SR&quot;,  &quot;SS&quot;,  &quot;ST&quot;,  &quot;SV&quot;,
 359     &quot;SX&quot;,  &quot;SY&quot;,  &quot;SZ&quot;,  &quot;TC&quot;,  &quot;TD&quot;,  &quot;TF&quot;,  &quot;TG&quot;,  &quot;TH&quot;,  &quot;TJ&quot;,
 360     &quot;TK&quot;,  &quot;TL&quot;,  &quot;TM&quot;,  &quot;TN&quot;,  &quot;TO&quot;,  &quot;TR&quot;,  &quot;TT&quot;,  &quot;TV&quot;,
 361     &quot;TW&quot;,  &quot;TZ&quot;,  &quot;UA&quot;,  &quot;UG&quot;,  &quot;UM&quot;,  &quot;US&quot;,  &quot;UY&quot;,  &quot;UZ&quot;,
 362     &quot;VA&quot;,  &quot;VC&quot;,  &quot;VE&quot;,  &quot;VG&quot;,  &quot;VI&quot;,  &quot;VN&quot;,  &quot;VU&quot;,  &quot;WF&quot;,
 363     &quot;WS&quot;,  &quot;YE&quot;,  &quot;YT&quot;,  &quot;ZA&quot;,  &quot;ZM&quot;,  &quot;ZW&quot;,
 364 NULL,
 365     &quot;AN&quot;,  &quot;BU&quot;, &quot;CS&quot;, &quot;FX&quot;, &quot;RO&quot;, &quot;SU&quot;, &quot;TP&quot;, &quot;YD&quot;, &quot;YU&quot;, &quot;ZR&quot;,   /* obsolete country codes */
 366 NULL
 367 };
 368 
 369 static const char* const DEPRECATED_COUNTRIES[] = {
 370     &quot;AN&quot;, &quot;BU&quot;, &quot;CS&quot;, &quot;DD&quot;, &quot;DY&quot;, &quot;FX&quot;, &quot;HV&quot;, &quot;NH&quot;, &quot;RH&quot;, &quot;SU&quot;, &quot;TP&quot;, &quot;UK&quot;, &quot;VD&quot;, &quot;YD&quot;, &quot;YU&quot;, &quot;ZR&quot;, NULL, NULL /* deprecated country list */
 371 };
 372 static const char* const REPLACEMENT_COUNTRIES[] = {
 373 /*  &quot;AN&quot;, &quot;BU&quot;, &quot;CS&quot;, &quot;DD&quot;, &quot;DY&quot;, &quot;FX&quot;, &quot;HV&quot;, &quot;NH&quot;, &quot;RH&quot;, &quot;SU&quot;, &quot;TP&quot;, &quot;UK&quot;, &quot;VD&quot;, &quot;YD&quot;, &quot;YU&quot;, &quot;ZR&quot; */
 374     &quot;CW&quot;, &quot;MM&quot;, &quot;RS&quot;, &quot;DE&quot;, &quot;BJ&quot;, &quot;FR&quot;, &quot;BF&quot;, &quot;VU&quot;, &quot;ZW&quot;, &quot;RU&quot;, &quot;TL&quot;, &quot;GB&quot;, &quot;VN&quot;, &quot;YE&quot;, &quot;RS&quot;, &quot;CD&quot;, NULL, NULL  /* replacement country codes */
 375 };
 376 
 377 /**
 378  * Table of 3-letter country codes.
 379  *
 380  * This is a lookup table used to convert 3-letter country codes to
 381  * their 2-letter equivalent.  It must be kept in sync with COUNTRIES.
 382  * For all valid i, COUNTRIES[i] must refer to the same country as
 383  * COUNTRIES_3[i].  The commented-out lines are copied from COUNTRIES
 384  * to make eyeballing this baby easier.
 385  *
 386  * This table should be terminated with a NULL entry, followed by a
 387  * second list, and another NULL entry.  The two lists correspond to
 388  * the two lists in COUNTRIES.
 389  */
 390 static const char * const COUNTRIES_3[] = {
 391 /*  &quot;AD&quot;,  &quot;AE&quot;,  &quot;AF&quot;,  &quot;AG&quot;,  &quot;AI&quot;,  &quot;AL&quot;,  &quot;AM&quot;,      */
 392     &quot;AND&quot;, &quot;ARE&quot;, &quot;AFG&quot;, &quot;ATG&quot;, &quot;AIA&quot;, &quot;ALB&quot;, &quot;ARM&quot;,
 393 /*  &quot;AO&quot;,  &quot;AQ&quot;,  &quot;AR&quot;,  &quot;AS&quot;,  &quot;AT&quot;,  &quot;AU&quot;,  &quot;AW&quot;,  &quot;AX&quot;,  &quot;AZ&quot;,     */
 394     &quot;AGO&quot;, &quot;ATA&quot;, &quot;ARG&quot;, &quot;ASM&quot;, &quot;AUT&quot;, &quot;AUS&quot;, &quot;ABW&quot;, &quot;ALA&quot;, &quot;AZE&quot;,
 395 /*  &quot;BA&quot;,  &quot;BB&quot;,  &quot;BD&quot;,  &quot;BE&quot;,  &quot;BF&quot;,  &quot;BG&quot;,  &quot;BH&quot;,  &quot;BI&quot;,     */
 396     &quot;BIH&quot;, &quot;BRB&quot;, &quot;BGD&quot;, &quot;BEL&quot;, &quot;BFA&quot;, &quot;BGR&quot;, &quot;BHR&quot;, &quot;BDI&quot;,
 397 /*  &quot;BJ&quot;,  &quot;BL&quot;,  &quot;BM&quot;,  &quot;BN&quot;,  &quot;BO&quot;,  &quot;BQ&quot;,  &quot;BR&quot;,  &quot;BS&quot;,  &quot;BT&quot;,  &quot;BV&quot;,     */
 398     &quot;BEN&quot;, &quot;BLM&quot;, &quot;BMU&quot;, &quot;BRN&quot;, &quot;BOL&quot;, &quot;BES&quot;, &quot;BRA&quot;, &quot;BHS&quot;, &quot;BTN&quot;, &quot;BVT&quot;,
 399 /*  &quot;BW&quot;,  &quot;BY&quot;,  &quot;BZ&quot;,  &quot;CA&quot;,  &quot;CC&quot;,  &quot;CD&quot;,  &quot;CF&quot;,  &quot;CG&quot;,     */
 400     &quot;BWA&quot;, &quot;BLR&quot;, &quot;BLZ&quot;, &quot;CAN&quot;, &quot;CCK&quot;, &quot;COD&quot;, &quot;CAF&quot;, &quot;COG&quot;,
 401 /*  &quot;CH&quot;,  &quot;CI&quot;,  &quot;CK&quot;,  &quot;CL&quot;,  &quot;CM&quot;,  &quot;CN&quot;,  &quot;CO&quot;,  &quot;CR&quot;,     */
 402     &quot;CHE&quot;, &quot;CIV&quot;, &quot;COK&quot;, &quot;CHL&quot;, &quot;CMR&quot;, &quot;CHN&quot;, &quot;COL&quot;, &quot;CRI&quot;,
 403 /*  &quot;CU&quot;,  &quot;CV&quot;,  &quot;CW&quot;,  &quot;CX&quot;,  &quot;CY&quot;,  &quot;CZ&quot;,  &quot;DE&quot;,  &quot;DJ&quot;,  &quot;DK&quot;,     */
 404     &quot;CUB&quot;, &quot;CPV&quot;, &quot;CUW&quot;, &quot;CXR&quot;, &quot;CYP&quot;, &quot;CZE&quot;, &quot;DEU&quot;, &quot;DJI&quot;, &quot;DNK&quot;,
 405 /*  &quot;DM&quot;,  &quot;DO&quot;,  &quot;DZ&quot;,  &quot;EC&quot;,  &quot;EE&quot;,  &quot;EG&quot;,  &quot;EH&quot;,  &quot;ER&quot;,     */
 406     &quot;DMA&quot;, &quot;DOM&quot;, &quot;DZA&quot;, &quot;ECU&quot;, &quot;EST&quot;, &quot;EGY&quot;, &quot;ESH&quot;, &quot;ERI&quot;,
 407 /*  &quot;ES&quot;,  &quot;ET&quot;,  &quot;FI&quot;,  &quot;FJ&quot;,  &quot;FK&quot;,  &quot;FM&quot;,  &quot;FO&quot;,  &quot;FR&quot;,     */
 408     &quot;ESP&quot;, &quot;ETH&quot;, &quot;FIN&quot;, &quot;FJI&quot;, &quot;FLK&quot;, &quot;FSM&quot;, &quot;FRO&quot;, &quot;FRA&quot;,
 409 /*  &quot;GA&quot;,  &quot;GB&quot;,  &quot;GD&quot;,  &quot;GE&quot;,  &quot;GF&quot;,  &quot;GG&quot;,  &quot;GH&quot;,  &quot;GI&quot;,  &quot;GL&quot;,     */
 410     &quot;GAB&quot;, &quot;GBR&quot;, &quot;GRD&quot;, &quot;GEO&quot;, &quot;GUF&quot;, &quot;GGY&quot;, &quot;GHA&quot;, &quot;GIB&quot;, &quot;GRL&quot;,
 411 /*  &quot;GM&quot;,  &quot;GN&quot;,  &quot;GP&quot;,  &quot;GQ&quot;,  &quot;GR&quot;,  &quot;GS&quot;,  &quot;GT&quot;,  &quot;GU&quot;,     */
 412     &quot;GMB&quot;, &quot;GIN&quot;, &quot;GLP&quot;, &quot;GNQ&quot;, &quot;GRC&quot;, &quot;SGS&quot;, &quot;GTM&quot;, &quot;GUM&quot;,
 413 /*  &quot;GW&quot;,  &quot;GY&quot;,  &quot;HK&quot;,  &quot;HM&quot;,  &quot;HN&quot;,  &quot;HR&quot;,  &quot;HT&quot;,  &quot;HU&quot;,     */
 414     &quot;GNB&quot;, &quot;GUY&quot;, &quot;HKG&quot;, &quot;HMD&quot;, &quot;HND&quot;, &quot;HRV&quot;, &quot;HTI&quot;, &quot;HUN&quot;,
 415 /*  &quot;ID&quot;,  &quot;IE&quot;,  &quot;IL&quot;,  &quot;IM&quot;,  &quot;IN&quot;,  &quot;IO&quot;,  &quot;IQ&quot;,  &quot;IR&quot;,  &quot;IS&quot; */
 416     &quot;IDN&quot;, &quot;IRL&quot;, &quot;ISR&quot;, &quot;IMN&quot;, &quot;IND&quot;, &quot;IOT&quot;, &quot;IRQ&quot;, &quot;IRN&quot;, &quot;ISL&quot;,
 417 /*  &quot;IT&quot;,  &quot;JE&quot;,  &quot;JM&quot;,  &quot;JO&quot;,  &quot;JP&quot;,  &quot;KE&quot;,  &quot;KG&quot;,  &quot;KH&quot;,  &quot;KI&quot;,     */
 418     &quot;ITA&quot;, &quot;JEY&quot;, &quot;JAM&quot;, &quot;JOR&quot;, &quot;JPN&quot;, &quot;KEN&quot;, &quot;KGZ&quot;, &quot;KHM&quot;, &quot;KIR&quot;,
 419 /*  &quot;KM&quot;,  &quot;KN&quot;,  &quot;KP&quot;,  &quot;KR&quot;,  &quot;KW&quot;,  &quot;KY&quot;,  &quot;KZ&quot;,  &quot;LA&quot;,     */
 420     &quot;COM&quot;, &quot;KNA&quot;, &quot;PRK&quot;, &quot;KOR&quot;, &quot;KWT&quot;, &quot;CYM&quot;, &quot;KAZ&quot;, &quot;LAO&quot;,
 421 /*  &quot;LB&quot;,  &quot;LC&quot;,  &quot;LI&quot;,  &quot;LK&quot;,  &quot;LR&quot;,  &quot;LS&quot;,  &quot;LT&quot;,  &quot;LU&quot;,     */
 422     &quot;LBN&quot;, &quot;LCA&quot;, &quot;LIE&quot;, &quot;LKA&quot;, &quot;LBR&quot;, &quot;LSO&quot;, &quot;LTU&quot;, &quot;LUX&quot;,
 423 /*  &quot;LV&quot;,  &quot;LY&quot;,  &quot;MA&quot;,  &quot;MC&quot;,  &quot;MD&quot;,  &quot;ME&quot;,  &quot;MF&quot;,  &quot;MG&quot;,  &quot;MH&quot;,  &quot;MK&quot;,     */
 424     &quot;LVA&quot;, &quot;LBY&quot;, &quot;MAR&quot;, &quot;MCO&quot;, &quot;MDA&quot;, &quot;MNE&quot;, &quot;MAF&quot;, &quot;MDG&quot;, &quot;MHL&quot;, &quot;MKD&quot;,
 425 /*  &quot;ML&quot;,  &quot;MM&quot;,  &quot;MN&quot;,  &quot;MO&quot;,  &quot;MP&quot;,  &quot;MQ&quot;,  &quot;MR&quot;,  &quot;MS&quot;,     */
 426     &quot;MLI&quot;, &quot;MMR&quot;, &quot;MNG&quot;, &quot;MAC&quot;, &quot;MNP&quot;, &quot;MTQ&quot;, &quot;MRT&quot;, &quot;MSR&quot;,
 427 /*  &quot;MT&quot;,  &quot;MU&quot;,  &quot;MV&quot;,  &quot;MW&quot;,  &quot;MX&quot;,  &quot;MY&quot;,  &quot;MZ&quot;,  &quot;NA&quot;,     */
 428     &quot;MLT&quot;, &quot;MUS&quot;, &quot;MDV&quot;, &quot;MWI&quot;, &quot;MEX&quot;, &quot;MYS&quot;, &quot;MOZ&quot;, &quot;NAM&quot;,
 429 /*  &quot;NC&quot;,  &quot;NE&quot;,  &quot;NF&quot;,  &quot;NG&quot;,  &quot;NI&quot;,  &quot;NL&quot;,  &quot;NO&quot;,  &quot;NP&quot;,     */
 430     &quot;NCL&quot;, &quot;NER&quot;, &quot;NFK&quot;, &quot;NGA&quot;, &quot;NIC&quot;, &quot;NLD&quot;, &quot;NOR&quot;, &quot;NPL&quot;,
 431 /*  &quot;NR&quot;,  &quot;NU&quot;,  &quot;NZ&quot;,  &quot;OM&quot;,  &quot;PA&quot;,  &quot;PE&quot;,  &quot;PF&quot;,  &quot;PG&quot;,     */
 432     &quot;NRU&quot;, &quot;NIU&quot;, &quot;NZL&quot;, &quot;OMN&quot;, &quot;PAN&quot;, &quot;PER&quot;, &quot;PYF&quot;, &quot;PNG&quot;,
 433 /*  &quot;PH&quot;,  &quot;PK&quot;,  &quot;PL&quot;,  &quot;PM&quot;,  &quot;PN&quot;,  &quot;PR&quot;,  &quot;PS&quot;,  &quot;PT&quot;,     */
 434     &quot;PHL&quot;, &quot;PAK&quot;, &quot;POL&quot;, &quot;SPM&quot;, &quot;PCN&quot;, &quot;PRI&quot;, &quot;PSE&quot;, &quot;PRT&quot;,
 435 /*  &quot;PW&quot;,  &quot;PY&quot;,  &quot;QA&quot;,  &quot;RE&quot;,  &quot;RO&quot;,  &quot;RS&quot;,  &quot;RU&quot;,  &quot;RW&quot;,  &quot;SA&quot;,     */
 436     &quot;PLW&quot;, &quot;PRY&quot;, &quot;QAT&quot;, &quot;REU&quot;, &quot;ROU&quot;, &quot;SRB&quot;, &quot;RUS&quot;, &quot;RWA&quot;, &quot;SAU&quot;,
 437 /*  &quot;SB&quot;,  &quot;SC&quot;,  &quot;SD&quot;,  &quot;SE&quot;,  &quot;SG&quot;,  &quot;SH&quot;,  &quot;SI&quot;,  &quot;SJ&quot;,     */
 438     &quot;SLB&quot;, &quot;SYC&quot;, &quot;SDN&quot;, &quot;SWE&quot;, &quot;SGP&quot;, &quot;SHN&quot;, &quot;SVN&quot;, &quot;SJM&quot;,
 439 /*  &quot;SK&quot;,  &quot;SL&quot;,  &quot;SM&quot;,  &quot;SN&quot;,  &quot;SO&quot;,  &quot;SR&quot;,  &quot;SS&quot;,  &quot;ST&quot;,  &quot;SV&quot;,     */
 440     &quot;SVK&quot;, &quot;SLE&quot;, &quot;SMR&quot;, &quot;SEN&quot;, &quot;SOM&quot;, &quot;SUR&quot;, &quot;SSD&quot;, &quot;STP&quot;, &quot;SLV&quot;,
 441 /*  &quot;SX&quot;,  &quot;SY&quot;,  &quot;SZ&quot;,  &quot;TC&quot;,  &quot;TD&quot;,  &quot;TF&quot;,  &quot;TG&quot;,  &quot;TH&quot;,  &quot;TJ&quot;,     */
 442     &quot;SXM&quot;, &quot;SYR&quot;, &quot;SWZ&quot;, &quot;TCA&quot;, &quot;TCD&quot;, &quot;ATF&quot;, &quot;TGO&quot;, &quot;THA&quot;, &quot;TJK&quot;,
 443 /*  &quot;TK&quot;,  &quot;TL&quot;,  &quot;TM&quot;,  &quot;TN&quot;,  &quot;TO&quot;,  &quot;TR&quot;,  &quot;TT&quot;,  &quot;TV&quot;,     */
 444     &quot;TKL&quot;, &quot;TLS&quot;, &quot;TKM&quot;, &quot;TUN&quot;, &quot;TON&quot;, &quot;TUR&quot;, &quot;TTO&quot;, &quot;TUV&quot;,
 445 /*  &quot;TW&quot;,  &quot;TZ&quot;,  &quot;UA&quot;,  &quot;UG&quot;,  &quot;UM&quot;,  &quot;US&quot;,  &quot;UY&quot;,  &quot;UZ&quot;,     */
 446     &quot;TWN&quot;, &quot;TZA&quot;, &quot;UKR&quot;, &quot;UGA&quot;, &quot;UMI&quot;, &quot;USA&quot;, &quot;URY&quot;, &quot;UZB&quot;,
 447 /*  &quot;VA&quot;,  &quot;VC&quot;,  &quot;VE&quot;,  &quot;VG&quot;,  &quot;VI&quot;,  &quot;VN&quot;,  &quot;VU&quot;,  &quot;WF&quot;,     */
 448     &quot;VAT&quot;, &quot;VCT&quot;, &quot;VEN&quot;, &quot;VGB&quot;, &quot;VIR&quot;, &quot;VNM&quot;, &quot;VUT&quot;, &quot;WLF&quot;,
 449 /*  &quot;WS&quot;,  &quot;YE&quot;,  &quot;YT&quot;,  &quot;ZA&quot;,  &quot;ZM&quot;,  &quot;ZW&quot;,          */
 450     &quot;WSM&quot;, &quot;YEM&quot;, &quot;MYT&quot;, &quot;ZAF&quot;, &quot;ZMB&quot;, &quot;ZWE&quot;,
 451 NULL,
 452 /*  &quot;AN&quot;,  &quot;BU&quot;,  &quot;CS&quot;,  &quot;FX&quot;,  &quot;RO&quot;, &quot;SU&quot;,  &quot;TP&quot;,  &quot;YD&quot;,  &quot;YU&quot;,  &quot;ZR&quot; */
 453     &quot;ANT&quot;, &quot;BUR&quot;, &quot;SCG&quot;, &quot;FXX&quot;, &quot;ROM&quot;, &quot;SUN&quot;, &quot;TMP&quot;, &quot;YMD&quot;, &quot;YUG&quot;, &quot;ZAR&quot;,
 454 NULL
 455 };
 456 
 457 typedef struct CanonicalizationMap {
 458     const char *id;          /* input ID */
 459     const char *canonicalID; /* canonicalized output ID */
 460 } CanonicalizationMap;
 461 
 462 /**
 463  * A map to canonicalize locale IDs.  This handles a variety of
 464  * different semantic kinds of transformations.
 465  */
 466 static const CanonicalizationMap CANONICALIZE_MAP[] = {
 467     { &quot;art_LOJBAN&quot;,     &quot;jbo&quot; }, /* registered name */
 468     { &quot;hy__AREVELA&quot;,    &quot;hy&quot; }, /* Registered IANA variant */
 469     { &quot;hy__AREVMDA&quot;,    &quot;hyw&quot; }, /* Registered IANA variant */
 470     { &quot;zh_GAN&quot;,         &quot;gan&quot; }, /* registered name */
 471     { &quot;zh_GUOYU&quot;,       &quot;zh&quot; }, /* registered name */
 472     { &quot;zh_HAKKA&quot;,       &quot;hak&quot; }, /* registered name */
 473     { &quot;zh_MIN_NAN&quot;,     &quot;nan&quot; }, /* registered name */
 474     { &quot;zh_WUU&quot;,         &quot;wuu&quot; }, /* registered name */
 475     { &quot;zh_XIANG&quot;,       &quot;hsn&quot; }, /* registered name */
 476     { &quot;zh_YUE&quot;,         &quot;yue&quot; }, /* registered name */
 477 };
 478 
 479 /* ### BCP47 Conversion *******************************************/
 480 /* Test if the locale id has BCP47 u extension and does not have &#39;@&#39; */
 481 #define _hasBCP47Extension(id) (id &amp;&amp; uprv_strstr(id, &quot;@&quot;) == NULL &amp;&amp; getShortestSubtagLength(localeID) == 1)
 482 /* Converts the BCP47 id to Unicode id. Does nothing to id if conversion fails */
 483 #define _ConvertBCP47(finalID, id, buffer, length,err) \
 484         if (uloc_forLanguageTag(id, buffer, length, NULL, err) &lt;= 0 ||  \
 485                 U_FAILURE(*err) || *err == U_STRING_NOT_TERMINATED_WARNING) { \
 486             finalID=id; \
 487             if (*err == U_STRING_NOT_TERMINATED_WARNING) { *err = U_BUFFER_OVERFLOW_ERROR; } \
 488         } else { \
 489             finalID=buffer; \
 490         }
 491 /* Gets the size of the shortest subtag in the given localeID. */
 492 static int32_t getShortestSubtagLength(const char *localeID) {
 493     int32_t localeIDLength = static_cast&lt;int32_t&gt;(uprv_strlen(localeID));
 494     int32_t length = localeIDLength;
 495     int32_t tmpLength = 0;
 496     int32_t i;
 497     UBool reset = TRUE;
 498 
 499     for (i = 0; i &lt; localeIDLength; i++) {
 500         if (localeID[i] != &#39;_&#39; &amp;&amp; localeID[i] != &#39;-&#39;) {
 501             if (reset) {
 502                 tmpLength = 0;
 503                 reset = FALSE;
 504             }
 505             tmpLength++;
 506         } else {
 507             if (tmpLength != 0 &amp;&amp; tmpLength &lt; length) {
 508                 length = tmpLength;
 509             }
 510             reset = TRUE;
 511         }
 512     }
 513 
 514     return length;
 515 }
 516 
 517 /* ### Keywords **************************************************/
 518 #define UPRV_ISDIGIT(c) (((c) &gt;= &#39;0&#39;) &amp;&amp; ((c) &lt;= &#39;9&#39;))
 519 #define UPRV_ISALPHANUM(c) (uprv_isASCIILetter(c) || UPRV_ISDIGIT(c) )
 520 /* Punctuation/symbols allowed in legacy key values */
 521 #define UPRV_OK_VALUE_PUNCTUATION(c) ((c) == &#39;_&#39; || (c) == &#39;-&#39; || (c) == &#39;+&#39; || (c) == &#39;/&#39;)
 522 
 523 #define ULOC_KEYWORD_BUFFER_LEN 25
 524 #define ULOC_MAX_NO_KEYWORDS 25
 525 
 526 U_CAPI const char * U_EXPORT2
 527 locale_getKeywordsStart(const char *localeID) {
 528     const char *result = NULL;
 529     if((result = uprv_strchr(localeID, &#39;@&#39;)) != NULL) {
 530         return result;
 531     }
 532 #if (U_CHARSET_FAMILY == U_EBCDIC_FAMILY)
 533     else {
 534         /* We do this because the @ sign is variant, and the @ sign used on one
 535         EBCDIC machine won&#39;t be compiled the same way on other EBCDIC based
 536         machines. */
 537         static const uint8_t ebcdicSigns[] = { 0x7C, 0x44, 0x66, 0x80, 0xAC, 0xAE, 0xAF, 0xB5, 0xEC, 0xEF, 0x00 };
 538         const uint8_t *charToFind = ebcdicSigns;
 539         while(*charToFind) {
 540             if((result = uprv_strchr(localeID, *charToFind)) != NULL) {
 541                 return result;
 542             }
 543             charToFind++;
 544         }
 545     }
 546 #endif
 547     return NULL;
 548 }
 549 
 550 /**
 551  * @param buf buffer of size [ULOC_KEYWORD_BUFFER_LEN]
 552  * @param keywordName incoming name to be canonicalized
 553  * @param status return status (keyword too long)
 554  * @return length of the keyword name
 555  */
 556 static int32_t locale_canonKeywordName(char *buf, const char *keywordName, UErrorCode *status)
 557 {
 558   int32_t keywordNameLen = 0;
 559 
 560   for (; *keywordName != 0; keywordName++) {
 561     if (!UPRV_ISALPHANUM(*keywordName)) {
 562       *status = U_ILLEGAL_ARGUMENT_ERROR; /* malformed keyword name */
 563       return 0;
 564     }
 565     if (keywordNameLen &lt; ULOC_KEYWORD_BUFFER_LEN - 1) {
 566       buf[keywordNameLen++] = uprv_tolower(*keywordName);
 567     } else {
 568       /* keyword name too long for internal buffer */
 569       *status = U_INTERNAL_PROGRAM_ERROR;
 570       return 0;
 571     }
 572   }
 573   if (keywordNameLen == 0) {
 574     *status = U_ILLEGAL_ARGUMENT_ERROR; /* empty keyword name */
 575     return 0;
 576   }
 577   buf[keywordNameLen] = 0; /* terminate */
 578 
 579   return keywordNameLen;
 580 }
 581 
 582 typedef struct {
 583     char keyword[ULOC_KEYWORD_BUFFER_LEN];
 584     int32_t keywordLen;
 585     const char *valueStart;
 586     int32_t valueLen;
 587 } KeywordStruct;
 588 
 589 static int32_t U_CALLCONV
 590 compareKeywordStructs(const void * /*context*/, const void *left, const void *right) {
 591     const char* leftString = ((const KeywordStruct *)left)-&gt;keyword;
 592     const char* rightString = ((const KeywordStruct *)right)-&gt;keyword;
 593     return uprv_strcmp(leftString, rightString);
 594 }
 595 
 596 static int32_t
 597 _getKeywords(const char *localeID,
 598              char prev,
 599              char *keywords, int32_t keywordCapacity,
 600              char *values, int32_t valuesCapacity, int32_t *valLen,
 601              UBool valuesToo,
 602              UErrorCode *status)
 603 {
 604     KeywordStruct keywordList[ULOC_MAX_NO_KEYWORDS];
 605 
 606     int32_t maxKeywords = ULOC_MAX_NO_KEYWORDS;
 607     int32_t numKeywords = 0;
 608     const char* pos = localeID;
 609     const char* equalSign = NULL;
 610     const char* semicolon = NULL;
 611     int32_t i = 0, j, n;
 612     int32_t keywordsLen = 0;
 613     int32_t valuesLen = 0;
 614 
 615     if(prev == &#39;@&#39;) { /* start of keyword definition */
 616         /* we will grab pairs, trim spaces, lowercase keywords, sort and return */
 617         do {
 618             UBool duplicate = FALSE;
 619             /* skip leading spaces */
 620             while(*pos == &#39; &#39;) {
 621                 pos++;
 622             }
 623             if (!*pos) { /* handle trailing &quot;; &quot; */
 624                 break;
 625             }
 626             if(numKeywords == maxKeywords) {
 627                 *status = U_INTERNAL_PROGRAM_ERROR;
 628                 return 0;
 629             }
 630             equalSign = uprv_strchr(pos, &#39;=&#39;);
 631             semicolon = uprv_strchr(pos, &#39;;&#39;);
 632             /* lack of &#39;=&#39; [foo@currency] is illegal */
 633             /* &#39;;&#39; before &#39;=&#39; [foo@currency;collation=pinyin] is illegal */
 634             if(!equalSign || (semicolon &amp;&amp; semicolon&lt;equalSign)) {
 635                 *status = U_INVALID_FORMAT_ERROR;
 636                 return 0;
 637             }
 638             /* need to normalize both keyword and keyword name */
 639             if(equalSign - pos &gt;= ULOC_KEYWORD_BUFFER_LEN) {
 640                 /* keyword name too long for internal buffer */
 641                 *status = U_INTERNAL_PROGRAM_ERROR;
 642                 return 0;
 643             }
 644             for(i = 0, n = 0; i &lt; equalSign - pos; ++i) {
 645                 if (pos[i] != &#39; &#39;) {
 646                     keywordList[numKeywords].keyword[n++] = uprv_tolower(pos[i]);
 647                 }
 648             }
 649 
 650             /* zero-length keyword is an error. */
 651             if (n == 0) {
 652                 *status = U_INVALID_FORMAT_ERROR;
 653                 return 0;
 654             }
 655 
 656             keywordList[numKeywords].keyword[n] = 0;
 657             keywordList[numKeywords].keywordLen = n;
 658             /* now grab the value part. First we skip the &#39;=&#39; */
 659             equalSign++;
 660             /* then we leading spaces */
 661             while(*equalSign == &#39; &#39;) {
 662                 equalSign++;
 663             }
 664 
 665             /* Premature end or zero-length value */
 666             if (!*equalSign || equalSign == semicolon) {
 667                 *status = U_INVALID_FORMAT_ERROR;
 668                 return 0;
 669             }
 670 
 671             keywordList[numKeywords].valueStart = equalSign;
 672 
 673             pos = semicolon;
 674             i = 0;
 675             if(pos) {
 676                 while(*(pos - i - 1) == &#39; &#39;) {
 677                     i++;
 678                 }
 679                 keywordList[numKeywords].valueLen = (int32_t)(pos - equalSign - i);
 680                 pos++;
 681             } else {
 682                 i = (int32_t)uprv_strlen(equalSign);
 683                 while(i &amp;&amp; equalSign[i-1] == &#39; &#39;) {
 684                     i--;
 685                 }
 686                 keywordList[numKeywords].valueLen = i;
 687             }
 688             /* If this is a duplicate keyword, then ignore it */
 689             for (j=0; j&lt;numKeywords; ++j) {
 690                 if (uprv_strcmp(keywordList[j].keyword, keywordList[numKeywords].keyword) == 0) {
 691                     duplicate = TRUE;
 692                     break;
 693                 }
 694             }
 695             if (!duplicate) {
 696                 ++numKeywords;
 697             }
 698         } while(pos);
 699 
 700         /* now we have a list of keywords */
 701         /* we need to sort it */
 702         uprv_sortArray(keywordList, numKeywords, sizeof(KeywordStruct), compareKeywordStructs, NULL, FALSE, status);
 703 
 704         /* Now construct the keyword part */
 705         for(i = 0; i &lt; numKeywords; i++) {
 706             if(keywordsLen + keywordList[i].keywordLen + 1&lt; keywordCapacity) {
 707                 uprv_strcpy(keywords+keywordsLen, keywordList[i].keyword);
 708                 if(valuesToo) {
 709                     keywords[keywordsLen + keywordList[i].keywordLen] = &#39;=&#39;;
 710                 } else {
 711                     keywords[keywordsLen + keywordList[i].keywordLen] = 0;
 712                 }
 713             }
 714             keywordsLen += keywordList[i].keywordLen + 1;
 715             if(valuesToo) {
 716                 if(keywordsLen + keywordList[i].valueLen &lt;= keywordCapacity) {
 717                     uprv_strncpy(keywords+keywordsLen, keywordList[i].valueStart, keywordList[i].valueLen);
 718                 }
 719                 keywordsLen += keywordList[i].valueLen;
 720 
 721                 if(i &lt; numKeywords - 1) {
 722                     if(keywordsLen &lt; keywordCapacity) {
 723                         keywords[keywordsLen] = &#39;;&#39;;
 724                     }
 725                     keywordsLen++;
 726                 }
 727             }
 728             if(values) {
 729                 if(valuesLen + keywordList[i].valueLen + 1&lt; valuesCapacity) {
 730                     uprv_strcpy(values+valuesLen, keywordList[i].valueStart);
 731                     values[valuesLen + keywordList[i].valueLen] = 0;
 732                 }
 733                 valuesLen += keywordList[i].valueLen + 1;
 734             }
 735         }
 736         if(values) {
 737             values[valuesLen] = 0;
 738             if(valLen) {
 739                 *valLen = valuesLen;
 740             }
 741         }
 742         return u_terminateChars(keywords, keywordCapacity, keywordsLen, status);
 743     } else {
 744         return 0;
 745     }
 746 }
 747 
 748 U_CFUNC int32_t
 749 locale_getKeywords(const char *localeID,
 750                    char prev,
 751                    char *keywords, int32_t keywordCapacity,
 752                    char *values, int32_t valuesCapacity, int32_t *valLen,
 753                    UBool valuesToo,
 754                    UErrorCode *status) {
 755     return _getKeywords(localeID, prev, keywords, keywordCapacity,
 756                         values, valuesCapacity, valLen, valuesToo,
 757                         status);
 758 }
 759 
 760 U_CAPI int32_t U_EXPORT2
 761 uloc_getKeywordValue(const char* localeID,
 762                      const char* keywordName,
 763                      char* buffer, int32_t bufferCapacity,
 764                      UErrorCode* status)
 765 {
 766     const char* startSearchHere = NULL;
 767     const char* nextSeparator = NULL;
 768     char keywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 769     char localeKeywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 770     int32_t result = 0;
 771 
 772     if(status &amp;&amp; U_SUCCESS(*status) &amp;&amp; localeID) {
 773       char tempBuffer[ULOC_FULLNAME_CAPACITY];
 774       const char* tmpLocaleID;
 775 
 776       if (keywordName == NULL || keywordName[0] == 0) {
 777         *status = U_ILLEGAL_ARGUMENT_ERROR;
 778         return 0;
 779       }
 780 
 781       locale_canonKeywordName(keywordNameBuffer, keywordName, status);
 782       if(U_FAILURE(*status)) {
 783         return 0;
 784       }
 785 
 786       if (_hasBCP47Extension(localeID)) {
 787           _ConvertBCP47(tmpLocaleID, localeID, tempBuffer, sizeof(tempBuffer), status);
 788       } else {
 789           tmpLocaleID=localeID;
 790       }
 791 
 792       startSearchHere = locale_getKeywordsStart(tmpLocaleID);
 793       if(startSearchHere == NULL) {
 794           /* no keywords, return at once */
 795           return 0;
 796       }
 797 
 798       /* find the first keyword */
 799       while(startSearchHere) {
 800           const char* keyValueTail;
 801           int32_t keyValueLen;
 802 
 803           startSearchHere++; /* skip @ or ; */
 804           nextSeparator = uprv_strchr(startSearchHere, &#39;=&#39;);
 805           if(!nextSeparator) {
 806               *status = U_ILLEGAL_ARGUMENT_ERROR; /* key must have =value */
 807               return 0;
 808           }
 809           /* strip leading &amp; trailing spaces (TC decided to tolerate these) */
 810           while(*startSearchHere == &#39; &#39;) {
 811               startSearchHere++;
 812           }
 813           keyValueTail = nextSeparator;
 814           while (keyValueTail &gt; startSearchHere &amp;&amp; *(keyValueTail-1) == &#39; &#39;) {
 815               keyValueTail--;
 816           }
 817           /* now keyValueTail points to first char after the keyName */
 818           /* copy &amp; normalize keyName from locale */
 819           if (startSearchHere == keyValueTail) {
 820               *status = U_ILLEGAL_ARGUMENT_ERROR; /* empty keyword name in passed-in locale */
 821               return 0;
 822           }
 823           keyValueLen = 0;
 824           while (startSearchHere &lt; keyValueTail) {
 825             if (!UPRV_ISALPHANUM(*startSearchHere)) {
 826               *status = U_ILLEGAL_ARGUMENT_ERROR; /* malformed keyword name */
 827               return 0;
 828             }
 829             if (keyValueLen &lt; ULOC_KEYWORD_BUFFER_LEN - 1) {
 830               localeKeywordNameBuffer[keyValueLen++] = uprv_tolower(*startSearchHere++);
 831             } else {
 832               /* keyword name too long for internal buffer */
 833               *status = U_INTERNAL_PROGRAM_ERROR;
 834               return 0;
 835             }
 836           }
 837           localeKeywordNameBuffer[keyValueLen] = 0; /* terminate */
 838 
 839           startSearchHere = uprv_strchr(nextSeparator, &#39;;&#39;);
 840 
 841           if(uprv_strcmp(keywordNameBuffer, localeKeywordNameBuffer) == 0) {
 842                /* current entry matches the keyword. */
 843              nextSeparator++; /* skip &#39;=&#39; */
 844               /* First strip leading &amp; trailing spaces (TC decided to tolerate these) */
 845               while(*nextSeparator == &#39; &#39;) {
 846                 nextSeparator++;
 847               }
 848               keyValueTail = (startSearchHere)? startSearchHere: nextSeparator + uprv_strlen(nextSeparator);
 849               while(keyValueTail &gt; nextSeparator &amp;&amp; *(keyValueTail-1) == &#39; &#39;) {
 850                 keyValueTail--;
 851               }
 852               /* Now copy the value, but check well-formedness */
 853               if (nextSeparator == keyValueTail) {
 854                 *status = U_ILLEGAL_ARGUMENT_ERROR; /* empty key value name in passed-in locale */
 855                 return 0;
 856               }
 857               keyValueLen = 0;
 858               while (nextSeparator &lt; keyValueTail) {
 859                 if (!UPRV_ISALPHANUM(*nextSeparator) &amp;&amp; !UPRV_OK_VALUE_PUNCTUATION(*nextSeparator)) {
 860                   *status = U_ILLEGAL_ARGUMENT_ERROR; /* malformed key value */
 861                   return 0;
 862                 }
 863                 if (keyValueLen &lt; bufferCapacity) {
 864                   /* Should we lowercase value to return here? Tests expect as-is. */
 865                   buffer[keyValueLen++] = *nextSeparator++;
 866                 } else { /* keep advancing so we return correct length in case of overflow */
 867                   keyValueLen++;
 868                   nextSeparator++;
 869                 }
 870               }
 871               result = u_terminateChars(buffer, bufferCapacity, keyValueLen, status);
 872               return result;
 873           }
 874       }
 875     }
 876     return 0;
 877 }
 878 
 879 U_CAPI int32_t U_EXPORT2
 880 uloc_setKeywordValue(const char* keywordName,
 881                      const char* keywordValue,
 882                      char* buffer, int32_t bufferCapacity,
 883                      UErrorCode* status)
 884 {
 885     /* TODO: sorting. removal. */
 886     int32_t keywordNameLen;
 887     int32_t keywordValueLen;
 888     int32_t bufLen;
 889     int32_t needLen = 0;
 890     char keywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 891     char keywordValueBuffer[ULOC_KEYWORDS_CAPACITY+1];
 892     char localeKeywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 893     int32_t rc;
 894     char* nextSeparator = NULL;
 895     char* nextEqualsign = NULL;
 896     char* startSearchHere = NULL;
 897     char* keywordStart = NULL;
 898     CharString updatedKeysAndValues;
 899     int32_t updatedKeysAndValuesLen;
 900     UBool handledInputKeyAndValue = FALSE;
 901     char keyValuePrefix = &#39;@&#39;;
 902 
 903     if(U_FAILURE(*status)) {
 904         return -1;
 905     }
 906     if (keywordName == NULL || keywordName[0] == 0 || bufferCapacity &lt;= 1) {
 907         *status = U_ILLEGAL_ARGUMENT_ERROR;
 908         return 0;
 909     }
 910     bufLen = (int32_t)uprv_strlen(buffer);
 911     if(bufferCapacity&lt;bufLen) {
 912         /* The capacity is less than the length?! Is this NULL terminated? */
 913         *status = U_ILLEGAL_ARGUMENT_ERROR;
 914         return 0;
 915     }
 916     keywordNameLen = locale_canonKeywordName(keywordNameBuffer, keywordName, status);
 917     if(U_FAILURE(*status)) {
 918         return 0;
 919     }
 920 
 921     keywordValueLen = 0;
 922     if(keywordValue) {
 923         while (*keywordValue != 0) {
 924             if (!UPRV_ISALPHANUM(*keywordValue) &amp;&amp; !UPRV_OK_VALUE_PUNCTUATION(*keywordValue)) {
 925                 *status = U_ILLEGAL_ARGUMENT_ERROR; /* malformed key value */
 926                 return 0;
 927             }
 928             if (keywordValueLen &lt; ULOC_KEYWORDS_CAPACITY) {
 929                 /* Should we force lowercase in value to set? */
 930                 keywordValueBuffer[keywordValueLen++] = *keywordValue++;
 931             } else {
 932                 /* keywordValue too long for internal buffer */
 933                 *status = U_INTERNAL_PROGRAM_ERROR;
 934                 return 0;
 935             }
 936         }
 937     }
 938     keywordValueBuffer[keywordValueLen] = 0; /* terminate */
 939 
 940     startSearchHere = (char*)locale_getKeywordsStart(buffer);
 941     if(startSearchHere == NULL || (startSearchHere[1]==0)) {
 942         if(keywordValueLen == 0) { /* no keywords = nothing to remove */
 943             return bufLen;
 944         }
 945 
 946         needLen = bufLen+1+keywordNameLen+1+keywordValueLen;
 947         if(startSearchHere) { /* had a single @ */
 948             needLen--; /* already had the @ */
 949             /* startSearchHere points at the @ */
 950         } else {
 951             startSearchHere=buffer+bufLen;
 952         }
 953         if(needLen &gt;= bufferCapacity) {
 954             *status = U_BUFFER_OVERFLOW_ERROR;
 955             return needLen; /* no change */
 956         }
 957         *startSearchHere++ = &#39;@&#39;;
 958         uprv_strcpy(startSearchHere, keywordNameBuffer);
 959         startSearchHere += keywordNameLen;
 960         *startSearchHere++ = &#39;=&#39;;
 961         uprv_strcpy(startSearchHere, keywordValueBuffer);
 962         return needLen;
 963     } /* end shortcut - no @ */
 964 
 965     keywordStart = startSearchHere;
 966     /* search for keyword */
 967     while(keywordStart) {
 968         const char* keyValueTail;
 969         int32_t keyValueLen;
 970 
 971         keywordStart++; /* skip @ or ; */
 972         nextEqualsign = uprv_strchr(keywordStart, &#39;=&#39;);
 973         if (!nextEqualsign) {
 974             *status = U_ILLEGAL_ARGUMENT_ERROR; /* key must have =value */
 975             return 0;
 976         }
 977         /* strip leading &amp; trailing spaces (TC decided to tolerate these) */
 978         while(*keywordStart == &#39; &#39;) {
 979             keywordStart++;
 980         }
 981         keyValueTail = nextEqualsign;
 982         while (keyValueTail &gt; keywordStart &amp;&amp; *(keyValueTail-1) == &#39; &#39;) {
 983             keyValueTail--;
 984         }
 985         /* now keyValueTail points to first char after the keyName */
 986         /* copy &amp; normalize keyName from locale */
 987         if (keywordStart == keyValueTail) {
 988             *status = U_ILLEGAL_ARGUMENT_ERROR; /* empty keyword name in passed-in locale */
 989             return 0;
 990         }
 991         keyValueLen = 0;
 992         while (keywordStart &lt; keyValueTail) {
 993             if (!UPRV_ISALPHANUM(*keywordStart)) {
 994                 *status = U_ILLEGAL_ARGUMENT_ERROR; /* malformed keyword name */
 995                 return 0;
 996             }
 997             if (keyValueLen &lt; ULOC_KEYWORD_BUFFER_LEN - 1) {
 998                 localeKeywordNameBuffer[keyValueLen++] = uprv_tolower(*keywordStart++);
 999             } else {
1000                 /* keyword name too long for internal buffer */
1001                 *status = U_INTERNAL_PROGRAM_ERROR;
1002                 return 0;
1003             }
1004         }
1005         localeKeywordNameBuffer[keyValueLen] = 0; /* terminate */
1006 
1007         nextSeparator = uprv_strchr(nextEqualsign, &#39;;&#39;);
1008 
1009         /* start processing the value part */
1010         nextEqualsign++; /* skip &#39;=&#39; */
1011         /* First strip leading &amp; trailing spaces (TC decided to tolerate these) */
1012         while(*nextEqualsign == &#39; &#39;) {
1013             nextEqualsign++;
1014         }
1015         keyValueTail = (nextSeparator)? nextSeparator: nextEqualsign + uprv_strlen(nextEqualsign);
1016         while(keyValueTail &gt; nextEqualsign &amp;&amp; *(keyValueTail-1) == &#39; &#39;) {
1017             keyValueTail--;
1018         }
1019         if (nextEqualsign == keyValueTail) {
1020             *status = U_ILLEGAL_ARGUMENT_ERROR; /* empty key value in passed-in locale */
1021             return 0;
1022         }
1023 
1024         rc = uprv_strcmp(keywordNameBuffer, localeKeywordNameBuffer);
1025         if(rc == 0) {
1026             /* Current entry matches the input keyword. Update the entry */
1027             if(keywordValueLen &gt; 0) { /* updating a value */
1028                 updatedKeysAndValues.append(keyValuePrefix, *status);
1029                 keyValuePrefix = &#39;;&#39;; /* for any subsequent key-value pair */
1030                 updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
1031                 updatedKeysAndValues.append(&#39;=&#39;, *status);
1032                 updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1033             } /* else removing this entry, don&#39;t emit anything */
1034             handledInputKeyAndValue = TRUE;
1035         } else {
1036            /* input keyword sorts earlier than current entry, add before current entry */
1037             if (rc &lt; 0 &amp;&amp; keywordValueLen &gt; 0 &amp;&amp; !handledInputKeyAndValue) {
1038                 /* insert new entry at this location */
1039                 updatedKeysAndValues.append(keyValuePrefix, *status);
1040                 keyValuePrefix = &#39;;&#39;; /* for any subsequent key-value pair */
1041                 updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
1042                 updatedKeysAndValues.append(&#39;=&#39;, *status);
1043                 updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1044                 handledInputKeyAndValue = TRUE;
1045             }
1046             /* copy the current entry */
1047             updatedKeysAndValues.append(keyValuePrefix, *status);
1048             keyValuePrefix = &#39;;&#39;; /* for any subsequent key-value pair */
1049             updatedKeysAndValues.append(localeKeywordNameBuffer, keyValueLen, *status);
1050             updatedKeysAndValues.append(&#39;=&#39;, *status);
1051             updatedKeysAndValues.append(nextEqualsign, static_cast&lt;int32_t&gt;(keyValueTail-nextEqualsign), *status);
1052         }
1053         if (!nextSeparator &amp;&amp; keywordValueLen &gt; 0 &amp;&amp; !handledInputKeyAndValue) {
1054             /* append new entry at the end, it sorts later than existing entries */
1055             updatedKeysAndValues.append(keyValuePrefix, *status);
1056             /* skip keyValuePrefix update, no subsequent key-value pair */
1057             updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
1058             updatedKeysAndValues.append(&#39;=&#39;, *status);
1059             updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1060             handledInputKeyAndValue = TRUE;
1061         }
1062         keywordStart = nextSeparator;
1063     } /* end loop searching */
1064 
1065     /* Any error from updatedKeysAndValues.append above would be internal and not due to
1066      * problems with the passed-in locale. So if we did encounter problems with the
1067      * passed-in locale above, those errors took precedence and overrode any error
1068      * status from updatedKeysAndValues.append, and also caused a return of 0. If there
1069      * are errors here they are from updatedKeysAndValues.append; they do cause an
1070      * error return but the passed-in locale is unmodified and the original bufLen is
1071      * returned.
1072      */
1073     if (!handledInputKeyAndValue || U_FAILURE(*status)) {
1074         /* if input key/value specified removal of a keyword not present in locale, or
1075          * there was an error in CharString.append, leave original locale alone. */
1076         return bufLen;
1077     }
1078 
1079     updatedKeysAndValuesLen = updatedKeysAndValues.length();
1080     /* needLen = length of the part before &#39;@&#39; + length of updated key-value part including &#39;@&#39; */
1081     needLen = (int32_t)(startSearchHere - buffer) + updatedKeysAndValuesLen;
1082     if(needLen &gt;= bufferCapacity) {
1083         *status = U_BUFFER_OVERFLOW_ERROR;
1084         return needLen; /* no change */
1085     }
1086     if (updatedKeysAndValuesLen &gt; 0) {
1087         uprv_strncpy(startSearchHere, updatedKeysAndValues.data(), updatedKeysAndValuesLen);
1088     }
1089     buffer[needLen]=0;
1090     return needLen;
1091 }
1092 
1093 /* ### ID parsing implementation **************************************************/
1094 
1095 #define _isPrefixLetter(a) ((a==&#39;x&#39;)||(a==&#39;X&#39;)||(a==&#39;i&#39;)||(a==&#39;I&#39;))
1096 
1097 /*returns TRUE if one of the special prefixes is here (s=string)
1098   &#39;x-&#39; or &#39;i-&#39; */
1099 #define _isIDPrefix(s) (_isPrefixLetter(s[0])&amp;&amp;_isIDSeparator(s[1]))
1100 
1101 /* Dot terminates it because of POSIX form  where dot precedes the codepage
1102  * except for variant
1103  */
1104 #define _isTerminator(a)  ((a==0)||(a==&#39;.&#39;)||(a==&#39;@&#39;))
1105 
1106 /**
1107  * Lookup &#39;key&#39; in the array &#39;list&#39;.  The array &#39;list&#39; should contain
1108  * a NULL entry, followed by more entries, and a second NULL entry.
1109  *
1110  * The &#39;list&#39; param should be LANGUAGES, LANGUAGES_3, COUNTRIES, or
1111  * COUNTRIES_3.
1112  */
1113 static int16_t _findIndex(const char* const* list, const char* key)
1114 {
1115     const char* const* anchor = list;
1116     int32_t pass = 0;
1117 
1118     /* Make two passes through two NULL-terminated arrays at &#39;list&#39; */
1119     while (pass++ &lt; 2) {
1120         while (*list) {
1121             if (uprv_strcmp(key, *list) == 0) {
1122                 return (int16_t)(list - anchor);
1123             }
1124             list++;
1125         }
1126         ++list;     /* skip final NULL *CWB*/
1127     }
1128     return -1;
1129 }
1130 
1131 /* count the length of src while copying it to dest; return strlen(src) */
1132 static inline int32_t
1133 _copyCount(char *dest, int32_t destCapacity, const char *src) {
1134     const char *anchor;
1135     char c;
1136 
1137     anchor=src;
1138     for(;;) {
1139         if((c=*src)==0) {
1140             return (int32_t)(src-anchor);
1141         }
1142         if(destCapacity&lt;=0) {
1143             return (int32_t)((src-anchor)+uprv_strlen(src));
1144         }
1145         ++src;
1146         *dest++=c;
1147         --destCapacity;
1148     }
1149 }
1150 
1151 U_CFUNC const char*
1152 uloc_getCurrentCountryID(const char* oldID){
1153     int32_t offset = _findIndex(DEPRECATED_COUNTRIES, oldID);
1154     if (offset &gt;= 0) {
1155         return REPLACEMENT_COUNTRIES[offset];
1156     }
1157     return oldID;
1158 }
1159 U_CFUNC const char*
1160 uloc_getCurrentLanguageID(const char* oldID){
1161     int32_t offset = _findIndex(DEPRECATED_LANGUAGES, oldID);
1162     if (offset &gt;= 0) {
1163         return REPLACEMENT_LANGUAGES[offset];
1164     }
1165     return oldID;
1166 }
1167 /*
1168  * the internal functions _getLanguage(), _getCountry(), _getVariant()
1169  * avoid duplicating code to handle the earlier locale ID pieces
1170  * in the functions for the later ones by
1171  * setting the *pEnd pointer to where they stopped parsing
1172  *
1173  * TODO try to use this in Locale
1174  */
1175 U_CFUNC int32_t
1176 ulocimp_getLanguage(const char *localeID,
1177                     char *language, int32_t languageCapacity,
1178                     const char **pEnd) {
1179     int32_t i=0;
1180     int32_t offset;
1181     char lang[4]={ 0, 0, 0, 0 }; /* temporary buffer to hold language code for searching */
1182 
1183     if (uprv_stricmp(localeID, &quot;root&quot;) == 0) {
1184         localeID += 4;
1185     } else if (uprv_strnicmp(localeID, &quot;und&quot;, 3) == 0 &amp;&amp;
1186                (localeID[3] == &#39;\0&#39; ||
1187                 localeID[3] == &#39;-&#39; ||
1188                 localeID[3] == &#39;_&#39; ||
1189                 localeID[3] == &#39;@&#39;)) {
1190         localeID += 3;
1191     }
1192 
1193     /* if it starts with i- or x- then copy that prefix */
1194     if(_isIDPrefix(localeID)) {
1195         if(i&lt;languageCapacity) {
1196             language[i]=(char)uprv_tolower(*localeID);
1197         }
1198         if(i&lt;languageCapacity) {
1199             language[i+1]=&#39;-&#39;;
1200         }
1201         i+=2;
1202         localeID+=2;
1203     }
1204 
1205     /* copy the language as far as possible and count its length */
1206     while(!_isTerminator(*localeID) &amp;&amp; !_isIDSeparator(*localeID)) {
1207         if(i&lt;languageCapacity) {
1208             language[i]=(char)uprv_tolower(*localeID);
1209         }
1210         if(i&lt;3) {
1211             U_ASSERT(i&gt;=0);
1212             lang[i]=(char)uprv_tolower(*localeID);
1213         }
1214         i++;
1215         localeID++;
1216     }
1217 
1218     if(i==3) {
1219         /* convert 3 character code to 2 character code if possible *CWB*/
1220         offset=_findIndex(LANGUAGES_3, lang);
1221         if(offset&gt;=0) {
1222             i=_copyCount(language, languageCapacity, LANGUAGES[offset]);
1223         }
1224     }
1225 
1226     if(pEnd!=NULL) {
1227         *pEnd=localeID;
1228     }
1229     return i;
1230 }
1231 
1232 U_CFUNC int32_t
1233 ulocimp_getScript(const char *localeID,
1234                   char *script, int32_t scriptCapacity,
1235                   const char **pEnd)
1236 {
1237     int32_t idLen = 0;
1238 
1239     if (pEnd != NULL) {
1240         *pEnd = localeID;
1241     }
1242 
1243     /* copy the second item as far as possible and count its length */
1244     while(!_isTerminator(localeID[idLen]) &amp;&amp; !_isIDSeparator(localeID[idLen])
1245             &amp;&amp; uprv_isASCIILetter(localeID[idLen])) {
1246         idLen++;
1247     }
1248 
1249     /* If it&#39;s exactly 4 characters long, then it&#39;s a script and not a country. */
1250     if (idLen == 4) {
1251         int32_t i;
1252         if (pEnd != NULL) {
1253             *pEnd = localeID+idLen;
1254         }
1255         if(idLen &gt; scriptCapacity) {
1256             idLen = scriptCapacity;
1257         }
1258         if (idLen &gt;= 1) {
1259             script[0]=(char)uprv_toupper(*(localeID++));
1260         }
1261         for (i = 1; i &lt; idLen; i++) {
1262             script[i]=(char)uprv_tolower(*(localeID++));
1263         }
1264     }
1265     else {
1266         idLen = 0;
1267     }
1268     return idLen;
1269 }
1270 
1271 U_CFUNC int32_t
1272 ulocimp_getCountry(const char *localeID,
1273                    char *country, int32_t countryCapacity,
1274                    const char **pEnd)
1275 {
1276     int32_t idLen=0;
1277     char cnty[ULOC_COUNTRY_CAPACITY]={ 0, 0, 0, 0 };
1278     int32_t offset;
1279 
1280     /* copy the country as far as possible and count its length */
1281     while(!_isTerminator(localeID[idLen]) &amp;&amp; !_isIDSeparator(localeID[idLen])) {
1282         if(idLen&lt;(ULOC_COUNTRY_CAPACITY-1)) {   /*CWB*/
1283             cnty[idLen]=(char)uprv_toupper(localeID[idLen]);
1284         }
1285         idLen++;
1286     }
1287 
1288     /* the country should be either length 2 or 3 */
1289     if (idLen == 2 || idLen == 3) {
1290         UBool gotCountry = FALSE;
1291         /* convert 3 character code to 2 character code if possible *CWB*/
1292         if(idLen==3) {
1293             offset=_findIndex(COUNTRIES_3, cnty);
1294             if(offset&gt;=0) {
1295                 idLen=_copyCount(country, countryCapacity, COUNTRIES[offset]);
1296                 gotCountry = TRUE;
1297             }
1298         }
1299         if (!gotCountry) {
1300             int32_t i = 0;
1301             for (i = 0; i &lt; idLen; i++) {
1302                 if (i &lt; countryCapacity) {
1303                     country[i]=(char)uprv_toupper(localeID[i]);
1304                 }
1305             }
1306         }
1307         localeID+=idLen;
1308     } else {
1309         idLen = 0;
1310     }
1311 
1312     if(pEnd!=NULL) {
1313         *pEnd=localeID;
1314     }
1315 
1316     return idLen;
1317 }
1318 
1319 /**
1320  * @param needSeparator if true, then add leading &#39;_&#39; if any variants
1321  * are added to &#39;variant&#39;
1322  */
1323 static int32_t
1324 _getVariantEx(const char *localeID,
1325               char prev,
1326               char *variant, int32_t variantCapacity,
1327               UBool needSeparator) {
1328     int32_t i=0;
1329 
1330     /* get one or more variant tags and separate them with &#39;_&#39; */
1331     if(_isIDSeparator(prev)) {
1332         /* get a variant string after a &#39;-&#39; or &#39;_&#39; */
1333         while(!_isTerminator(*localeID)) {
1334             if (needSeparator) {
1335                 if (i&lt;variantCapacity) {
1336                     variant[i] = &#39;_&#39;;
1337                 }
1338                 ++i;
1339                 needSeparator = FALSE;
1340             }
1341             if(i&lt;variantCapacity) {
1342                 variant[i]=(char)uprv_toupper(*localeID);
1343                 if(variant[i]==&#39;-&#39;) {
1344                     variant[i]=&#39;_&#39;;
1345                 }
1346             }
1347             i++;
1348             localeID++;
1349         }
1350     }
1351 
1352     /* if there is no variant tag after a &#39;-&#39; or &#39;_&#39; then look for &#39;@&#39; */
1353     if(i==0) {
1354         if(prev==&#39;@&#39;) {
1355             /* keep localeID */
1356         } else if((localeID=locale_getKeywordsStart(localeID))!=NULL) {
1357             ++localeID; /* point after the &#39;@&#39; */
1358         } else {
1359             return 0;
1360         }
1361         while(!_isTerminator(*localeID)) {
1362             if (needSeparator) {
1363                 if (i&lt;variantCapacity) {
1364                     variant[i] = &#39;_&#39;;
1365                 }
1366                 ++i;
1367                 needSeparator = FALSE;
1368             }
1369             if(i&lt;variantCapacity) {
1370                 variant[i]=(char)uprv_toupper(*localeID);
1371                 if(variant[i]==&#39;-&#39; || variant[i]==&#39;,&#39;) {
1372                     variant[i]=&#39;_&#39;;
1373                 }
1374             }
1375             i++;
1376             localeID++;
1377         }
1378     }
1379 
1380     return i;
1381 }
1382 
1383 static int32_t
1384 _getVariant(const char *localeID,
1385             char prev,
1386             char *variant, int32_t variantCapacity) {
1387     return _getVariantEx(localeID, prev, variant, variantCapacity, FALSE);
1388 }
1389 
1390 /* Keyword enumeration */
1391 
1392 typedef struct UKeywordsContext {
1393     char* keywords;
1394     char* current;
1395 } UKeywordsContext;
1396 
1397 U_CDECL_BEGIN
1398 
1399 static void U_CALLCONV
1400 uloc_kw_closeKeywords(UEnumeration *enumerator) {
1401     uprv_free(((UKeywordsContext *)enumerator-&gt;context)-&gt;keywords);
1402     uprv_free(enumerator-&gt;context);
1403     uprv_free(enumerator);
1404 }
1405 
1406 static int32_t U_CALLCONV
1407 uloc_kw_countKeywords(UEnumeration *en, UErrorCode * /*status*/) {
1408     char *kw = ((UKeywordsContext *)en-&gt;context)-&gt;keywords;
1409     int32_t result = 0;
1410     while(*kw) {
1411         result++;
1412         kw += uprv_strlen(kw)+1;
1413     }
1414     return result;
1415 }
1416 
1417 static const char * U_CALLCONV
1418 uloc_kw_nextKeyword(UEnumeration* en,
1419                     int32_t* resultLength,
1420                     UErrorCode* /*status*/) {
1421     const char* result = ((UKeywordsContext *)en-&gt;context)-&gt;current;
1422     int32_t len = 0;
1423     if(*result) {
1424         len = (int32_t)uprv_strlen(((UKeywordsContext *)en-&gt;context)-&gt;current);
1425         ((UKeywordsContext *)en-&gt;context)-&gt;current += len+1;
1426     } else {
1427         result = NULL;
1428     }
1429     if (resultLength) {
1430         *resultLength = len;
1431     }
1432     return result;
1433 }
1434 
1435 static void U_CALLCONV
1436 uloc_kw_resetKeywords(UEnumeration* en,
1437                       UErrorCode* /*status*/) {
1438     ((UKeywordsContext *)en-&gt;context)-&gt;current = ((UKeywordsContext *)en-&gt;context)-&gt;keywords;
1439 }
1440 
1441 U_CDECL_END
1442 
1443 
1444 static const UEnumeration gKeywordsEnum = {
1445     NULL,
1446     NULL,
1447     uloc_kw_closeKeywords,
1448     uloc_kw_countKeywords,
1449     uenum_unextDefault,
1450     uloc_kw_nextKeyword,
1451     uloc_kw_resetKeywords
1452 };
1453 
1454 U_CAPI UEnumeration* U_EXPORT2
1455 uloc_openKeywordList(const char *keywordList, int32_t keywordListSize, UErrorCode* status)
1456 {
1457     UKeywordsContext *myContext = NULL;
1458     UEnumeration *result = NULL;
1459 
1460     if(U_FAILURE(*status)) {
1461         return NULL;
1462     }
1463     result = (UEnumeration *)uprv_malloc(sizeof(UEnumeration));
1464     /* Null pointer test */
1465     if (result == NULL) {
1466         *status = U_MEMORY_ALLOCATION_ERROR;
1467         return NULL;
1468     }
1469     uprv_memcpy(result, &amp;gKeywordsEnum, sizeof(UEnumeration));
1470     myContext = static_cast&lt;UKeywordsContext *&gt;(uprv_malloc(sizeof(UKeywordsContext)));
1471     if (myContext == NULL) {
1472         *status = U_MEMORY_ALLOCATION_ERROR;
1473         uprv_free(result);
1474         return NULL;
1475     }
1476     myContext-&gt;keywords = (char *)uprv_malloc(keywordListSize+1);
1477     uprv_memcpy(myContext-&gt;keywords, keywordList, keywordListSize);
1478     myContext-&gt;keywords[keywordListSize] = 0;
1479     myContext-&gt;current = myContext-&gt;keywords;
1480     result-&gt;context = myContext;
1481     return result;
1482 }
1483 
1484 U_CAPI UEnumeration* U_EXPORT2
1485 uloc_openKeywords(const char* localeID,
1486                         UErrorCode* status)
1487 {
1488     int32_t i=0;
1489     char keywords[256];
1490     int32_t keywordsCapacity = 256;
1491     char tempBuffer[ULOC_FULLNAME_CAPACITY];
1492     const char* tmpLocaleID;
1493 
1494     if(status==NULL || U_FAILURE(*status)) {
1495         return 0;
1496     }
1497 
1498     if (_hasBCP47Extension(localeID)) {
1499         _ConvertBCP47(tmpLocaleID, localeID, tempBuffer, sizeof(tempBuffer), status);
1500     } else {
1501         if (localeID==NULL) {
1502            localeID=uloc_getDefault();
1503         }
1504         tmpLocaleID=localeID;
1505     }
1506 
1507     /* Skip the language */
1508     ulocimp_getLanguage(tmpLocaleID, NULL, 0, &amp;tmpLocaleID);
1509     if(_isIDSeparator(*tmpLocaleID)) {
1510         const char *scriptID;
1511         /* Skip the script if available */
1512         ulocimp_getScript(tmpLocaleID+1, NULL, 0, &amp;scriptID);
1513         if(scriptID != tmpLocaleID+1) {
1514             /* Found optional script */
1515             tmpLocaleID = scriptID;
1516         }
1517         /* Skip the Country */
1518         if (_isIDSeparator(*tmpLocaleID)) {
1519             ulocimp_getCountry(tmpLocaleID+1, NULL, 0, &amp;tmpLocaleID);
1520             if(_isIDSeparator(*tmpLocaleID)) {
1521                 _getVariant(tmpLocaleID+1, *tmpLocaleID, NULL, 0);
1522             }
1523         }
1524     }
1525 
1526     /* keywords are located after &#39;@&#39; */
1527     if((tmpLocaleID = locale_getKeywordsStart(tmpLocaleID)) != NULL) {
1528         i=locale_getKeywords(tmpLocaleID+1, &#39;@&#39;, keywords, keywordsCapacity, NULL, 0, NULL, FALSE, status);
1529     }
1530 
1531     if(i) {
1532         return uloc_openKeywordList(keywords, i, status);
1533     } else {
1534         return NULL;
1535     }
1536 }
1537 
1538 
1539 /* bit-flags for &#39;options&#39; parameter of _canonicalize */
1540 #define _ULOC_STRIP_KEYWORDS 0x2
1541 #define _ULOC_CANONICALIZE   0x1
1542 
1543 #define OPTION_SET(options, mask) ((options &amp; mask) != 0)
1544 
1545 static const char i_default[] = {&#39;i&#39;, &#39;-&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;a&#39;, &#39;u&#39;, &#39;l&#39;, &#39;t&#39;};
1546 #define I_DEFAULT_LENGTH UPRV_LENGTHOF(i_default)
1547 
1548 /**
1549  * Canonicalize the given localeID, to level 1 or to level 2,
1550  * depending on the options.  To specify level 1, pass in options=0.
1551  * To specify level 2, pass in options=_ULOC_CANONICALIZE.
1552  *
1553  * This is the code underlying uloc_getName and uloc_canonicalize.
1554  */
1555 static int32_t
1556 _canonicalize(const char* localeID,
1557               char* result,
1558               int32_t resultCapacity,
1559               uint32_t options,
1560               UErrorCode* err) {
1561     int32_t j, len, fieldCount=0, scriptSize=0, variantSize=0, nameCapacity;
1562     char localeBuffer[ULOC_FULLNAME_CAPACITY];
1563     char tempBuffer[ULOC_FULLNAME_CAPACITY];
1564     const char* origLocaleID;
1565     const char* tmpLocaleID;
1566     const char* keywordAssign = NULL;
1567     const char* separatorIndicator = NULL;
1568     char* name;
1569     char* variant = NULL; /* pointer into name, or NULL */
1570 
1571     if (U_FAILURE(*err)) {
1572         return 0;
1573     }
1574 
1575     if (_hasBCP47Extension(localeID)) {
1576         _ConvertBCP47(tmpLocaleID, localeID, tempBuffer, sizeof(tempBuffer), err);
1577     } else {
1578         if (localeID==NULL) {
1579            localeID=uloc_getDefault();
1580         }
1581         tmpLocaleID=localeID;
1582     }
1583 
1584     origLocaleID=tmpLocaleID;
1585 
1586     /* if we are doing a full canonicalization, then put results in
1587        localeBuffer, if necessary; otherwise send them to result. */
1588     if (/*OPTION_SET(options, _ULOC_CANONICALIZE) &amp;&amp;*/
1589         (result == NULL || resultCapacity &lt; (int32_t)sizeof(localeBuffer))) {
1590         name = localeBuffer;
1591         nameCapacity = (int32_t)sizeof(localeBuffer);
1592     } else {
1593         name = result;
1594         nameCapacity = resultCapacity;
1595     }
1596 
1597     /* get all pieces, one after another, and separate with &#39;_&#39; */
1598     len=ulocimp_getLanguage(tmpLocaleID, name, nameCapacity, &amp;tmpLocaleID);
1599 
1600     if(len == I_DEFAULT_LENGTH &amp;&amp; uprv_strncmp(origLocaleID, i_default, len) == 0) {
1601         const char *d = uloc_getDefault();
1602 
1603         len = (int32_t)uprv_strlen(d);
1604 
1605         if (name != NULL) {
1606             uprv_memcpy(name, d, len);
1607         }
1608     } else if(_isIDSeparator(*tmpLocaleID)) {
1609         const char *scriptID;
1610 
1611         ++fieldCount;
1612         if(len&lt;nameCapacity) {
1613             name[len]=&#39;_&#39;;
1614         }
1615         ++len;
1616 
1617         scriptSize=ulocimp_getScript(tmpLocaleID+1,
1618             (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len, &amp;scriptID);
1619         if(scriptSize &gt; 0) {
1620             /* Found optional script */
1621             tmpLocaleID = scriptID;
1622             ++fieldCount;
1623             len+=scriptSize;
1624             if (_isIDSeparator(*tmpLocaleID)) {
1625                 /* If there is something else, then we add the _ */
1626                 if(len&lt;nameCapacity) {
1627                     name[len]=&#39;_&#39;;
1628                 }
1629                 ++len;
1630             }
1631         }
1632 
1633         if (_isIDSeparator(*tmpLocaleID)) {
1634             const char *cntryID;
1635             int32_t cntrySize = ulocimp_getCountry(tmpLocaleID+1,
1636                 (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len, &amp;cntryID);
1637             if (cntrySize &gt; 0) {
1638                 /* Found optional country */
1639                 tmpLocaleID = cntryID;
1640                 len+=cntrySize;
1641             }
1642             if(_isIDSeparator(*tmpLocaleID)) {
1643                 /* If there is something else, then we add the _  if we found country before. */
1644                 if (cntrySize &gt;= 0 &amp;&amp; ! _isIDSeparator(*(tmpLocaleID+1)) ) {
1645                     ++fieldCount;
1646                     if(len&lt;nameCapacity) {
1647                         name[len]=&#39;_&#39;;
1648                     }
1649                     ++len;
1650                 }
1651 
1652                 variantSize = _getVariant(tmpLocaleID+1, *tmpLocaleID,
1653                     (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len);
1654                 if (variantSize &gt; 0) {
1655                     variant = len&lt;nameCapacity ? name+len : NULL;
1656                     len += variantSize;
1657                     tmpLocaleID += variantSize + 1; /* skip &#39;_&#39; and variant */
1658                 }
1659             }
1660         }
1661     }
1662 
1663     /* Copy POSIX-style charset specifier, if any [mr.utf8] */
1664     if (!OPTION_SET(options, _ULOC_CANONICALIZE) &amp;&amp; *tmpLocaleID == &#39;.&#39;) {
1665         UBool done = FALSE;
1666         do {
1667             char c = *tmpLocaleID;
1668             switch (c) {
1669             case 0:
1670             case &#39;@&#39;:
1671                 done = TRUE;
1672                 break;
1673             default:
1674                 if (len&lt;nameCapacity) {
1675                     name[len] = c;
1676                 }
1677                 ++len;
1678                 ++tmpLocaleID;
1679                 break;
1680             }
1681         } while (!done);
1682     }
1683 
1684     /* Scan ahead to next &#39;@&#39; and determine if it is followed by &#39;=&#39; and/or &#39;;&#39;
1685        After this, tmpLocaleID either points to &#39;@&#39; or is NULL */
1686     if ((tmpLocaleID=locale_getKeywordsStart(tmpLocaleID))!=NULL) {
1687         keywordAssign = uprv_strchr(tmpLocaleID, &#39;=&#39;);
1688         separatorIndicator = uprv_strchr(tmpLocaleID, &#39;;&#39;);
1689     }
1690 
1691     /* Copy POSIX-style variant, if any [mr@FOO] */
1692     if (!OPTION_SET(options, _ULOC_CANONICALIZE) &amp;&amp;
1693         tmpLocaleID != NULL &amp;&amp; keywordAssign == NULL) {
1694         for (;;) {
1695             char c = *tmpLocaleID;
1696             if (c == 0) {
1697                 break;
1698             }
1699             if (len&lt;nameCapacity) {
1700                 name[len] = c;
1701             }
1702             ++len;
1703             ++tmpLocaleID;
1704         }
1705     }
1706 
1707     if (OPTION_SET(options, _ULOC_CANONICALIZE)) {
1708         /* Handle @FOO variant if @ is present and not followed by = */
1709         if (tmpLocaleID!=NULL &amp;&amp; keywordAssign==NULL) {
1710             int32_t posixVariantSize;
1711             /* Add missing &#39;_&#39; if needed */
1712             if (fieldCount &lt; 2 || (fieldCount &lt; 3 &amp;&amp; scriptSize &gt; 0)) {
1713                 do {
1714                     if(len&lt;nameCapacity) {
1715                         name[len]=&#39;_&#39;;
1716                     }
1717                     ++len;
1718                     ++fieldCount;
1719                 } while(fieldCount&lt;2);
1720             }
1721             posixVariantSize = _getVariantEx(tmpLocaleID+1, &#39;@&#39;, name+len, nameCapacity-len,
1722                                              (UBool)(variantSize &gt; 0));
1723             if (posixVariantSize &gt; 0) {
1724                 if (variant == NULL) {
1725                     variant = name+len;
1726                 }
1727                 len += posixVariantSize;
1728                 variantSize += posixVariantSize;
1729             }
1730         }
1731 
1732         /* Look up the ID in the canonicalization map */
1733         for (j=0; j&lt;UPRV_LENGTHOF(CANONICALIZE_MAP); j++) {
1734             const char* id = CANONICALIZE_MAP[j].id;
1735             int32_t n = (int32_t)uprv_strlen(id);
1736             if (len == n &amp;&amp; uprv_strncmp(name, id, n) == 0) {
1737                 if (n == 0 &amp;&amp; tmpLocaleID != NULL) {
1738                     break; /* Don&#39;t remap &quot;&quot; if keywords present */
1739                 }
1740                 len = _copyCount(name, nameCapacity, CANONICALIZE_MAP[j].canonicalID);
1741                 break;
1742             }
1743         }
1744     }
1745 
1746     if (!OPTION_SET(options, _ULOC_STRIP_KEYWORDS)) {
1747         if (tmpLocaleID!=NULL &amp;&amp; keywordAssign!=NULL &amp;&amp;
1748             (!separatorIndicator || separatorIndicator &gt; keywordAssign)) {
1749             if(len&lt;nameCapacity) {
1750                 name[len]=&#39;@&#39;;
1751             }
1752             ++len;
1753             ++fieldCount;
1754             len += _getKeywords(tmpLocaleID+1, &#39;@&#39;, (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len,
1755                                 NULL, 0, NULL, TRUE, err);
1756         }
1757     }
1758 
1759     if (U_SUCCESS(*err) &amp;&amp; result != NULL &amp;&amp; name == localeBuffer) {
1760         uprv_strncpy(result, localeBuffer, (len &gt; resultCapacity) ? resultCapacity : len);
1761     }
1762 
1763     return u_terminateChars(result, resultCapacity, len, err);
1764 }
1765 
1766 /* ### ID parsing API **************************************************/
1767 
1768 U_CAPI int32_t  U_EXPORT2
1769 uloc_getParent(const char*    localeID,
1770                char* parent,
1771                int32_t parentCapacity,
1772                UErrorCode* err)
1773 {
1774     const char *lastUnderscore;
1775     int32_t i;
1776 
1777     if (U_FAILURE(*err))
1778         return 0;
1779 
1780     if (localeID == NULL)
1781         localeID = uloc_getDefault();
1782 
1783     lastUnderscore=uprv_strrchr(localeID, &#39;_&#39;);
1784     if(lastUnderscore!=NULL) {
1785         i=(int32_t)(lastUnderscore-localeID);
1786     } else {
1787         i=0;
1788     }
1789 
1790     if (i &gt; 0) {
1791         if (uprv_strnicmp(localeID, &quot;und_&quot;, 4) == 0) {
1792             localeID += 3;
1793             i -= 3;
1794             uprv_memmove(parent, localeID, uprv_min(i, parentCapacity));
1795         } else if (parent != localeID) {
1796             uprv_memcpy(parent, localeID, uprv_min(i, parentCapacity));
1797         }
1798     }
1799 
1800     return u_terminateChars(parent, parentCapacity, i, err);
1801 }
1802 
1803 U_CAPI int32_t U_EXPORT2
1804 uloc_getLanguage(const char*    localeID,
1805          char* language,
1806          int32_t languageCapacity,
1807          UErrorCode* err)
1808 {
1809     /* uloc_getLanguage will return a 2 character iso-639 code if one exists. *CWB*/
1810     int32_t i=0;
1811 
1812     if (err==NULL || U_FAILURE(*err)) {
1813         return 0;
1814     }
1815 
1816     if(localeID==NULL) {
1817         localeID=uloc_getDefault();
1818     }
1819 
1820     i=ulocimp_getLanguage(localeID, language, languageCapacity, NULL);
1821     return u_terminateChars(language, languageCapacity, i, err);
1822 }
1823 
1824 U_CAPI int32_t U_EXPORT2
1825 uloc_getScript(const char*    localeID,
1826          char* script,
1827          int32_t scriptCapacity,
1828          UErrorCode* err)
1829 {
1830     int32_t i=0;
1831 
1832     if(err==NULL || U_FAILURE(*err)) {
1833         return 0;
1834     }
1835 
1836     if(localeID==NULL) {
1837         localeID=uloc_getDefault();
1838     }
1839 
1840     /* skip the language */
1841     ulocimp_getLanguage(localeID, NULL, 0, &amp;localeID);
1842     if(_isIDSeparator(*localeID)) {
1843         i=ulocimp_getScript(localeID+1, script, scriptCapacity, NULL);
1844     }
1845     return u_terminateChars(script, scriptCapacity, i, err);
1846 }
1847 
1848 U_CAPI int32_t  U_EXPORT2
1849 uloc_getCountry(const char* localeID,
1850             char* country,
1851             int32_t countryCapacity,
1852             UErrorCode* err)
1853 {
1854     int32_t i=0;
1855 
1856     if(err==NULL || U_FAILURE(*err)) {
1857         return 0;
1858     }
1859 
1860     if(localeID==NULL) {
1861         localeID=uloc_getDefault();
1862     }
1863 
1864     /* Skip the language */
1865     ulocimp_getLanguage(localeID, NULL, 0, &amp;localeID);
1866     if(_isIDSeparator(*localeID)) {
1867         const char *scriptID;
1868         /* Skip the script if available */
1869         ulocimp_getScript(localeID+1, NULL, 0, &amp;scriptID);
1870         if(scriptID != localeID+1) {
1871             /* Found optional script */
1872             localeID = scriptID;
1873         }
1874         if(_isIDSeparator(*localeID)) {
1875             i=ulocimp_getCountry(localeID+1, country, countryCapacity, NULL);
1876         }
1877     }
1878     return u_terminateChars(country, countryCapacity, i, err);
1879 }
1880 
1881 U_CAPI int32_t  U_EXPORT2
1882 uloc_getVariant(const char* localeID,
1883                 char* variant,
1884                 int32_t variantCapacity,
1885                 UErrorCode* err)
1886 {
1887     char tempBuffer[ULOC_FULLNAME_CAPACITY];
1888     const char* tmpLocaleID;
1889     int32_t i=0;
1890 
1891     if(err==NULL || U_FAILURE(*err)) {
1892         return 0;
1893     }
1894 
1895     if (_hasBCP47Extension(localeID)) {
1896         _ConvertBCP47(tmpLocaleID, localeID, tempBuffer, sizeof(tempBuffer), err);
1897     } else {
1898         if (localeID==NULL) {
1899            localeID=uloc_getDefault();
1900         }
1901         tmpLocaleID=localeID;
1902     }
1903 
1904     /* Skip the language */
1905     ulocimp_getLanguage(tmpLocaleID, NULL, 0, &amp;tmpLocaleID);
1906     if(_isIDSeparator(*tmpLocaleID)) {
1907         const char *scriptID;
1908         /* Skip the script if available */
1909         ulocimp_getScript(tmpLocaleID+1, NULL, 0, &amp;scriptID);
1910         if(scriptID != tmpLocaleID+1) {
1911             /* Found optional script */
1912             tmpLocaleID = scriptID;
1913         }
1914         /* Skip the Country */
1915         if (_isIDSeparator(*tmpLocaleID)) {
1916             const char *cntryID;
1917             ulocimp_getCountry(tmpLocaleID+1, NULL, 0, &amp;cntryID);
1918             if (cntryID != tmpLocaleID+1) {
1919                 /* Found optional country */
1920                 tmpLocaleID = cntryID;
1921             }
1922             if(_isIDSeparator(*tmpLocaleID)) {
1923                 /* If there was no country ID, skip a possible extra IDSeparator */
1924                 if (tmpLocaleID != cntryID &amp;&amp; _isIDSeparator(tmpLocaleID[1])) {
1925                     tmpLocaleID++;
1926                 }
1927                 i=_getVariant(tmpLocaleID+1, *tmpLocaleID, variant, variantCapacity);
1928             }
1929         }
1930     }
1931 
1932     /* removed by weiv. We don&#39;t want to handle POSIX variants anymore. Use canonicalization function */
1933     /* if we do not have a variant tag yet then try a POSIX variant after &#39;@&#39; */
1934 /*
1935     if(!haveVariant &amp;&amp; (localeID=uprv_strrchr(localeID, &#39;@&#39;))!=NULL) {
1936         i=_getVariant(localeID+1, &#39;@&#39;, variant, variantCapacity);
1937     }
1938 */
1939     return u_terminateChars(variant, variantCapacity, i, err);
1940 }
1941 
1942 U_CAPI int32_t  U_EXPORT2
1943 uloc_getName(const char* localeID,
1944              char* name,
1945              int32_t nameCapacity,
1946              UErrorCode* err)
1947 {
1948     return _canonicalize(localeID, name, nameCapacity, 0, err);
1949 }
1950 
1951 U_CAPI int32_t  U_EXPORT2
1952 uloc_getBaseName(const char* localeID,
1953                  char* name,
1954                  int32_t nameCapacity,
1955                  UErrorCode* err)
1956 {
1957     return _canonicalize(localeID, name, nameCapacity, _ULOC_STRIP_KEYWORDS, err);
1958 }
1959 
1960 U_CAPI int32_t  U_EXPORT2
1961 uloc_canonicalize(const char* localeID,
1962                   char* name,
1963                   int32_t nameCapacity,
1964                   UErrorCode* err)
1965 {
1966     return _canonicalize(localeID, name, nameCapacity, _ULOC_CANONICALIZE, err);
1967 }
1968 
1969 U_CAPI const char*  U_EXPORT2
1970 uloc_getISO3Language(const char* localeID)
1971 {
1972     int16_t offset;
1973     char lang[ULOC_LANG_CAPACITY];
1974     UErrorCode err = U_ZERO_ERROR;
1975 
1976     if (localeID == NULL)
1977     {
1978         localeID = uloc_getDefault();
1979     }
1980     uloc_getLanguage(localeID, lang, ULOC_LANG_CAPACITY, &amp;err);
1981     if (U_FAILURE(err))
1982         return &quot;&quot;;
1983     offset = _findIndex(LANGUAGES, lang);
1984     if (offset &lt; 0)
1985         return &quot;&quot;;
1986     return LANGUAGES_3[offset];
1987 }
1988 
1989 U_CAPI const char*  U_EXPORT2
1990 uloc_getISO3Country(const char* localeID)
1991 {
1992     int16_t offset;
1993     char cntry[ULOC_LANG_CAPACITY];
1994     UErrorCode err = U_ZERO_ERROR;
1995 
1996     if (localeID == NULL)
1997     {
1998         localeID = uloc_getDefault();
1999     }
2000     uloc_getCountry(localeID, cntry, ULOC_LANG_CAPACITY, &amp;err);
2001     if (U_FAILURE(err))
2002         return &quot;&quot;;
2003     offset = _findIndex(COUNTRIES, cntry);
2004     if (offset &lt; 0)
2005         return &quot;&quot;;
2006 
2007     return COUNTRIES_3[offset];
2008 }
2009 
2010 U_CAPI uint32_t  U_EXPORT2
2011 uloc_getLCID(const char* localeID)
2012 {
2013     UErrorCode status = U_ZERO_ERROR;
2014     char       langID[ULOC_FULLNAME_CAPACITY];
2015     uint32_t   lcid = 0;
2016 
2017     /* Check for incomplete id. */
2018     if (!localeID || uprv_strlen(localeID) &lt; 2) {
2019         return 0;
2020     }
2021 
2022     // First, attempt Windows platform lookup if available, but fall
2023     // through to catch any special cases (ICU vs Windows name differences).
2024     lcid = uprv_convertToLCIDPlatform(localeID, &amp;status);
2025     if (U_FAILURE(status)) {
2026         return 0;
2027     }
2028     if (lcid &gt; 0) {
2029         // Windows found an LCID, return that
2030         return lcid;
2031     }
2032 
2033     uloc_getLanguage(localeID, langID, sizeof(langID), &amp;status);
2034     if (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING) {
2035         return 0;
2036     }
2037 
2038     if (uprv_strchr(localeID, &#39;@&#39;)) {
2039         // uprv_convertToLCID does not support keywords other than collation.
2040         // Remove all keywords except collation.
2041         int32_t len;
2042         char collVal[ULOC_KEYWORDS_CAPACITY];
2043         char tmpLocaleID[ULOC_FULLNAME_CAPACITY];
2044 
2045         len = uloc_getKeywordValue(localeID, &quot;collation&quot;, collVal,
2046             UPRV_LENGTHOF(collVal) - 1, &amp;status);
2047 
2048         if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
2049             collVal[len] = 0;
2050 
2051             len = uloc_getBaseName(localeID, tmpLocaleID,
2052                 UPRV_LENGTHOF(tmpLocaleID) - 1, &amp;status);
2053 
2054             if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
2055                 tmpLocaleID[len] = 0;
2056 
2057                 len = uloc_setKeywordValue(&quot;collation&quot;, collVal, tmpLocaleID,
2058                     UPRV_LENGTHOF(tmpLocaleID) - len - 1, &amp;status);
2059 
2060                 if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
2061                     tmpLocaleID[len] = 0;
2062                     return uprv_convertToLCID(langID, tmpLocaleID, &amp;status);
2063                 }
2064             }
2065         }
2066 
2067         // fall through - all keywords are simply ignored
2068         status = U_ZERO_ERROR;
2069     }
2070 
2071     return uprv_convertToLCID(langID, localeID, &amp;status);
2072 }
2073 
2074 U_CAPI int32_t U_EXPORT2
2075 uloc_getLocaleForLCID(uint32_t hostid, char *locale, int32_t localeCapacity,
2076                 UErrorCode *status)
2077 {
2078     return uprv_convertToPosix(hostid, locale, localeCapacity, status);
2079 }
2080 
2081 /* ### Default locale **************************************************/
2082 
2083 U_CAPI const char*  U_EXPORT2
2084 uloc_getDefault()
2085 {
2086     return locale_get_default();
2087 }
2088 
2089 U_CAPI void  U_EXPORT2
2090 uloc_setDefault(const char*   newDefaultLocale,
2091              UErrorCode* err)
2092 {
2093     if (U_FAILURE(*err))
2094         return;
2095     /* the error code isn&#39;t currently used for anything by this function*/
2096 
2097     /* propagate change to C++ */
2098     locale_set_default(newDefaultLocale);
2099 }
2100 
2101 /**
2102  * Returns a list of all 2-letter language codes defined in ISO 639.  This is a pointer
2103  * to an array of pointers to arrays of char.  All of these pointers are owned
2104  * by ICU-- do not delete them, and do not write through them.  The array is
2105  * terminated with a null pointer.
2106  */
2107 U_CAPI const char* const*  U_EXPORT2
2108 uloc_getISOLanguages()
2109 {
2110     return LANGUAGES;
2111 }
2112 
2113 /**
2114  * Returns a list of all 2-letter country codes defined in ISO 639.  This is a
2115  * pointer to an array of pointers to arrays of char.  All of these pointers are
2116  * owned by ICU-- do not delete them, and do not write through them.  The array is
2117  * terminated with a null pointer.
2118  */
2119 U_CAPI const char* const*  U_EXPORT2
2120 uloc_getISOCountries()
2121 {
2122     return COUNTRIES;
2123 }
2124 
2125 
2126 /* this function to be moved into cstring.c later */
2127 static char gDecimal = 0;
2128 
2129 static /* U_CAPI */
2130 double
2131 /* U_EXPORT2 */
2132 _uloc_strtod(const char *start, char **end) {
2133     char *decimal;
2134     char *myEnd;
2135     char buf[30];
2136     double rv;
2137     if (!gDecimal) {
2138         char rep[5];
2139         /* For machines that decide to change the decimal on you,
2140         and try to be too smart with localization.
2141         This normally should be just a &#39;.&#39;. */
2142         sprintf(rep, &quot;%+1.1f&quot;, 1.0);
2143         gDecimal = rep[2];
2144     }
2145 
2146     if(gDecimal == &#39;.&#39;) {
2147         return uprv_strtod(start, end); /* fall through to OS */
2148     } else {
2149         uprv_strncpy(buf, start, 29);
2150         buf[29]=0;
2151         decimal = uprv_strchr(buf, &#39;.&#39;);
2152         if(decimal) {
2153             *decimal = gDecimal;
2154         } else {
2155             return uprv_strtod(start, end); /* no decimal point */
2156         }
2157         rv = uprv_strtod(buf, &amp;myEnd);
2158         if(end) {
2159             *end = (char*)(start+(myEnd-buf)); /* cast away const (to follow uprv_strtod API.) */
2160         }
2161         return rv;
2162     }
2163 }
2164 
2165 typedef struct {
2166     float q;
2167     int32_t dummy;  /* to avoid uninitialized memory copy from qsort */
2168     char locale[ULOC_FULLNAME_CAPACITY+1];
2169 } _acceptLangItem;
2170 
2171 static int32_t U_CALLCONV
2172 uloc_acceptLanguageCompare(const void * /*context*/, const void *a, const void *b)
2173 {
2174     const _acceptLangItem *aa = (const _acceptLangItem*)a;
2175     const _acceptLangItem *bb = (const _acceptLangItem*)b;
2176 
2177     int32_t rc = 0;
2178     if(bb-&gt;q &lt; aa-&gt;q) {
2179         rc = -1;  /* A &gt; B */
2180     } else if(bb-&gt;q &gt; aa-&gt;q) {
2181         rc = 1;   /* A &lt; B */
2182     } else {
2183         rc = 0;   /* A = B */
2184     }
2185 
2186     if(rc==0) {
2187         rc = uprv_stricmp(aa-&gt;locale, bb-&gt;locale);
2188     }
2189 
2190 #if defined(ULOC_DEBUG)
2191     /*  fprintf(stderr, &quot;a:[%s:%g], b:[%s:%g] -&gt; %d\n&quot;,
2192     aa-&gt;locale, aa-&gt;q,
2193     bb-&gt;locale, bb-&gt;q,
2194     rc);*/
2195 #endif
2196 
2197     return rc;
2198 }
2199 
2200 /*
2201 mt-mt, ja;q=0.76, en-us;q=0.95, en;q=0.92, en-gb;q=0.89, fr;q=0.87, iu-ca;q=0.84, iu;q=0.82, ja-jp;q=0.79, mt;q=0.97, de-de;q=0.74, de;q=0.71, es;q=0.68, it-it;q=0.66, it;q=0.63, vi-vn;q=0.61, vi;q=0.58, nl-nl;q=0.55, nl;q=0.53
2202 */
2203 
2204 U_CAPI int32_t U_EXPORT2
2205 uloc_acceptLanguageFromHTTP(char *result, int32_t resultAvailable, UAcceptResult *outResult,
2206                             const char *httpAcceptLanguage,
2207                             UEnumeration* availableLocales,
2208                             UErrorCode *status)
2209 {
2210   MaybeStackArray&lt;_acceptLangItem, 4&gt; items; // Struct for collecting items.
2211     char tmp[ULOC_FULLNAME_CAPACITY +1];
2212     int32_t n = 0;
2213     const char *itemEnd;
2214     const char *paramEnd;
2215     const char *s;
2216     const char *t;
2217     int32_t res;
2218     int32_t i;
2219     int32_t l = (int32_t)uprv_strlen(httpAcceptLanguage);
2220 
2221     if(U_FAILURE(*status)) {
2222         return -1;
2223     }
2224 
2225     for(s=httpAcceptLanguage;s&amp;&amp;*s;) {
2226         while(isspace(*s)) /* eat space at the beginning */
2227             s++;
2228         itemEnd=uprv_strchr(s,&#39;,&#39;);
2229         paramEnd=uprv_strchr(s,&#39;;&#39;);
2230         if(!itemEnd) {
2231             itemEnd = httpAcceptLanguage+l; /* end of string */
2232         }
2233         if(paramEnd &amp;&amp; paramEnd&lt;itemEnd) {
2234             /* semicolon (;) is closer than end (,) */
2235             t = paramEnd+1;
2236             if(*t==&#39;q&#39;) {
2237                 t++;
2238             }
2239             while(isspace(*t)) {
2240                 t++;
2241             }
2242             if(*t==&#39;=&#39;) {
2243                 t++;
2244             }
2245             while(isspace(*t)) {
2246                 t++;
2247             }
2248             items[n].q = (float)_uloc_strtod(t,NULL);
2249         } else {
2250             /* no semicolon - it&#39;s 1.0 */
2251             items[n].q = 1.0f;
2252             paramEnd = itemEnd;
2253         }
2254         items[n].dummy=0;
2255         /* eat spaces prior to semi */
2256         for(t=(paramEnd-1);(paramEnd&gt;s)&amp;&amp;isspace(*t);t--)
2257             ;
2258         int32_t slen = static_cast&lt;int32_t&gt;(((t+1)-s));
2259         if(slen &gt; ULOC_FULLNAME_CAPACITY) {
2260           *status = U_BUFFER_OVERFLOW_ERROR;
2261           return -1; // too big
2262         }
2263         uprv_strncpy(items[n].locale, s, slen);
2264         items[n].locale[slen]=0; // terminate
2265         int32_t clen = uloc_canonicalize(items[n].locale, tmp, UPRV_LENGTHOF(tmp)-1, status);
2266         if(U_FAILURE(*status)) return -1;
2267         if((clen!=slen) || (uprv_strncmp(items[n].locale, tmp, slen))) {
2268             // canonicalization had an effect- copy back
2269             uprv_strncpy(items[n].locale, tmp, clen);
2270             items[n].locale[clen] = 0; // terminate
2271         }
2272 #if defined(ULOC_DEBUG)
2273         /*fprintf(stderr,&quot;%d: s &lt;%s&gt; q &lt;%g&gt;\n&quot;, n, j[n].locale, j[n].q);*/
2274 #endif
2275         n++;
2276         s = itemEnd;
2277         while(*s==&#39;,&#39;) { /* eat duplicate commas */
2278             s++;
2279         }
2280         if(n&gt;=items.getCapacity()) { // If we need more items
2281           if(NULL == items.resize(items.getCapacity()*2, items.getCapacity())) {
2282               *status = U_MEMORY_ALLOCATION_ERROR;
2283               return -1;
2284           }
2285 #if defined(ULOC_DEBUG)
2286           fprintf(stderr,&quot;malloced at size %d\n&quot;, items.getCapacity());
2287 #endif
2288         }
2289     }
2290     uprv_sortArray(items.getAlias(), n, sizeof(items[0]), uloc_acceptLanguageCompare, NULL, TRUE, status);
2291     if (U_FAILURE(*status)) {
2292         return -1;
2293     }
2294     LocalMemory&lt;const char*&gt; strs(NULL);
2295     if (strs.allocateInsteadAndReset(n) == NULL) {
2296         *status = U_MEMORY_ALLOCATION_ERROR;
2297         return -1;
2298     }
2299     for(i=0;i&lt;n;i++) {
2300 #if defined(ULOC_DEBUG)
2301         /*fprintf(stderr,&quot;%d: s &lt;%s&gt; q &lt;%g&gt;\n&quot;, i, j[i].locale, j[i].q);*/
2302 #endif
2303         strs[i]=items[i].locale;
2304     }
2305     res =  uloc_acceptLanguage(result, resultAvailable, outResult,
2306                                strs.getAlias(), n, availableLocales, status);
2307     return res;
2308 }
2309 
2310 
2311 U_CAPI int32_t U_EXPORT2
2312 uloc_acceptLanguage(char *result, int32_t resultAvailable,
2313                     UAcceptResult *outResult, const char **acceptList,
2314                     int32_t acceptListCount,
2315                     UEnumeration* availableLocales,
2316                     UErrorCode *status)
2317 {
2318     int32_t i,j;
2319     int32_t len;
2320     int32_t maxLen=0;
2321     char tmp[ULOC_FULLNAME_CAPACITY+1];
2322     const char *l;
2323     char **fallbackList;
2324     if(U_FAILURE(*status)) {
2325         return -1;
2326     }
2327     fallbackList = static_cast&lt;char **&gt;(uprv_malloc((size_t)(sizeof(fallbackList[0])*acceptListCount)));
2328     if(fallbackList==NULL) {
2329         *status = U_MEMORY_ALLOCATION_ERROR;
2330         return -1;
2331     }
2332     for(i=0;i&lt;acceptListCount;i++) {
2333 #if defined(ULOC_DEBUG)
2334         fprintf(stderr,&quot;%02d: %s\n&quot;, i, acceptList[i]);
2335 #endif
2336         while((l=uenum_next(availableLocales, NULL, status)) != NULL) {
2337 #if defined(ULOC_DEBUG)
2338             fprintf(stderr,&quot;  %s\n&quot;, l);
2339 #endif
2340             len = (int32_t)uprv_strlen(l);
2341             if(!uprv_strcmp(acceptList[i], l)) {
2342                 if(outResult) {
2343                     *outResult = ULOC_ACCEPT_VALID;
2344                 }
2345 #if defined(ULOC_DEBUG)
2346                 fprintf(stderr, &quot;MATCH! %s\n&quot;, l);
2347 #endif
2348                 if(len&gt;0) {
2349                     uprv_strncpy(result, l, uprv_min(len, resultAvailable));
2350                 }
2351                 for(j=0;j&lt;i;j++) {
2352                     uprv_free(fallbackList[j]);
2353                 }
2354                 uprv_free(fallbackList);
2355                 return u_terminateChars(result, resultAvailable, len, status);
2356             }
2357             if(len&gt;maxLen) {
2358                 maxLen = len;
2359             }
2360         }
2361         uenum_reset(availableLocales, status);
2362         /* save off parent info */
2363         if(uloc_getParent(acceptList[i], tmp, UPRV_LENGTHOF(tmp), status)!=0) {
2364             fallbackList[i] = uprv_strdup(tmp);
2365         } else {
2366             fallbackList[i]=0;
2367         }
2368     }
2369 
2370     for(maxLen--;maxLen&gt;0;maxLen--) {
2371         for(i=0;i&lt;acceptListCount;i++) {
2372             if(fallbackList[i] &amp;&amp; ((int32_t)uprv_strlen(fallbackList[i])==maxLen)) {
2373 #if defined(ULOC_DEBUG)
2374                 fprintf(stderr,&quot;Try: [%s]&quot;, fallbackList[i]);
2375 #endif
2376                 while((l=uenum_next(availableLocales, NULL, status)) != NULL) {
2377 #if defined(ULOC_DEBUG)
2378                     fprintf(stderr,&quot;  %s\n&quot;, l);
2379 #endif
2380                     len = (int32_t)uprv_strlen(l);
2381                     if(!uprv_strcmp(fallbackList[i], l)) {
2382                         if(outResult) {
2383                             *outResult = ULOC_ACCEPT_FALLBACK;
2384                         }
2385 #if defined(ULOC_DEBUG)
2386                         fprintf(stderr, &quot;fallback MATCH! %s\n&quot;, l);
2387 #endif
2388                         if(len&gt;0) {
2389                             uprv_strncpy(result, l, uprv_min(len, resultAvailable));
2390                         }
2391                         for(j=0;j&lt;acceptListCount;j++) {
2392                             uprv_free(fallbackList[j]);
2393                         }
2394                         uprv_free(fallbackList);
2395                         return u_terminateChars(result, resultAvailable, len, status);
2396                     }
2397                 }
2398                 uenum_reset(availableLocales, status);
2399 
2400                 if(uloc_getParent(fallbackList[i], tmp, UPRV_LENGTHOF(tmp), status)!=0) {
2401                     uprv_free(fallbackList[i]);
2402                     fallbackList[i] = uprv_strdup(tmp);
2403                 } else {
2404                     uprv_free(fallbackList[i]);
2405                     fallbackList[i]=0;
2406                 }
2407             }
2408         }
2409         if(outResult) {
2410             *outResult = ULOC_ACCEPT_FAILED;
2411         }
2412     }
2413     for(i=0;i&lt;acceptListCount;i++) {
2414         uprv_free(fallbackList[i]);
2415     }
2416     uprv_free(fallbackList);
2417     return -1;
2418 }
2419 
2420 U_CAPI const char* U_EXPORT2
2421 uloc_toUnicodeLocaleKey(const char* keyword)
2422 {
2423     const char* bcpKey = ulocimp_toBcpKey(keyword);
2424     if (bcpKey == NULL &amp;&amp; ultag_isUnicodeLocaleKey(keyword, -1)) {
2425         // unknown keyword, but syntax is fine..
2426         return keyword;
2427     }
2428     return bcpKey;
2429 }
2430 
2431 U_CAPI const char* U_EXPORT2
2432 uloc_toUnicodeLocaleType(const char* keyword, const char* value)
2433 {
2434     const char* bcpType = ulocimp_toBcpType(keyword, value, NULL, NULL);
2435     if (bcpType == NULL &amp;&amp; ultag_isUnicodeLocaleType(value, -1)) {
2436         // unknown keyword, but syntax is fine..
2437         return value;
2438     }
2439     return bcpType;
2440 }
2441 
2442 static UBool
2443 isWellFormedLegacyKey(const char* legacyKey)
2444 {
2445     const char* p = legacyKey;
2446     while (*p) {
2447         if (!UPRV_ISALPHANUM(*p)) {
2448             return FALSE;
2449         }
2450         p++;
2451     }
2452     return TRUE;
2453 }
2454 
2455 static UBool
2456 isWellFormedLegacyType(const char* legacyType)
2457 {
2458     const char* p = legacyType;
2459     int32_t alphaNumLen = 0;
2460     while (*p) {
2461         if (*p == &#39;_&#39; || *p == &#39;/&#39; || *p == &#39;-&#39;) {
2462             if (alphaNumLen == 0) {
2463                 return FALSE;
2464             }
2465             alphaNumLen = 0;
2466         } else if (UPRV_ISALPHANUM(*p)) {
2467             alphaNumLen++;
2468         } else {
2469             return FALSE;
2470         }
2471         p++;
2472     }
2473     return (alphaNumLen != 0);
2474 }
2475 
2476 U_CAPI const char* U_EXPORT2
2477 uloc_toLegacyKey(const char* keyword)
2478 {
2479     const char* legacyKey = ulocimp_toLegacyKey(keyword);
2480     if (legacyKey == NULL) {
2481         // Checks if the specified locale key is well-formed with the legacy locale syntax.
2482         //
2483         // Note:
2484         //  LDML/CLDR provides some definition of keyword syntax in
2485         //  * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier and
2486         //  * http://www.unicode.org/reports/tr35/#Old_Locale_Extension_Syntax
2487         //  Keys can only consist of [0-9a-zA-Z].
2488         if (isWellFormedLegacyKey(keyword)) {
2489             return keyword;
2490         }
2491     }
2492     return legacyKey;
2493 }
2494 
2495 U_CAPI const char* U_EXPORT2
2496 uloc_toLegacyType(const char* keyword, const char* value)
2497 {
2498     const char* legacyType = ulocimp_toLegacyType(keyword, value, NULL, NULL);
2499     if (legacyType == NULL) {
2500         // Checks if the specified locale type is well-formed with the legacy locale syntax.
2501         //
2502         // Note:
2503         //  LDML/CLDR provides some definition of keyword syntax in
2504         //  * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier and
2505         //  * http://www.unicode.org/reports/tr35/#Old_Locale_Extension_Syntax
2506         //  Values (types) can only consist of [0-9a-zA-Z], plus for legacy values
2507         //  we allow [/_-+] in the middle (e.g. &quot;Etc/GMT+1&quot;, &quot;Asia/Tel_Aviv&quot;)
2508         if (isWellFormedLegacyType(value)) {
2509             return value;
2510         }
2511     }
2512     return legacyType;
2513 }
2514 
2515 /*eof*/
    </pre>
  </body>
</html>