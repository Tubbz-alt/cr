<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/regex.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="rbnf.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="region.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/regex.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,28 ***</span>
  
  /**
   * \file
   * \brief  C++ API:  Regular Expressions
   *
<span class="line-modified">!  * &lt;h2&gt;Regular Expression API&lt;/h2&gt;</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * &lt;p&gt;The ICU API for processing regular expressions consists of two classes,</span>
<span class="line-removed">-  *  &lt;code&gt;RegexPattern&lt;/code&gt; and &lt;code&gt;RegexMatcher&lt;/code&gt;.</span>
<span class="line-removed">-  *  &lt;code&gt;RegexPattern&lt;/code&gt; objects represent a pre-processed, or compiled</span>
   *  regular expression.  They are created from a regular expression pattern string,
<span class="line-modified">!  *  and can be used to create &lt;code&gt;RegexMatcher&lt;/code&gt; objects for the pattern.&lt;/p&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;Class &lt;code&gt;RegexMatcher&lt;/code&gt; bundles together a regular expression</span>
   *  pattern and a target string to which the search pattern will be applied.
<span class="line-modified">!  *  &lt;code&gt;RegexMatcher&lt;/code&gt; includes API for doing plain find or search</span>
   *  operations, for search and replace operations, and for obtaining detailed
<span class="line-modified">!  *  information about bounds of a match. &lt;/p&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;Note that by constructing &lt;code&gt;RegexMatcher&lt;/code&gt; objects directly from regular</span>
   * expression pattern strings application code can be simplified and the explicit
<span class="line-modified">!  * need for &lt;code&gt;RegexPattern&lt;/code&gt; objects can usually be eliminated.</span>
<span class="line-modified">!  * &lt;/p&gt;</span>
   */
  
  #include &quot;unicode/utypes.h&quot;
  
  #if !UCONFIG_NO_REGULAR_EXPRESSIONS
<span class="line-new-header">--- 22,26 ---</span>
  
  /**
   * \file
   * \brief  C++ API:  Regular Expressions
   *
<span class="line-modified">!  * The ICU API for processing regular expressions consists of two classes,</span>
<span class="line-modified">!  *  `RegexPattern` and `RegexMatcher`.</span>
<span class="line-modified">!  *  `RegexPattern` objects represent a pre-processed, or compiled</span>
   *  regular expression.  They are created from a regular expression pattern string,
<span class="line-modified">!  *  and can be used to create `RegexMatcher` objects for the pattern.</span>
   *
<span class="line-modified">!  * Class `RegexMatcher` bundles together a regular expression</span>
   *  pattern and a target string to which the search pattern will be applied.
<span class="line-modified">!  *  `RegexMatcher` includes API for doing plain find or search</span>
   *  operations, for search and replace operations, and for obtaining detailed
<span class="line-modified">!  *  information about bounds of a match.</span>
   *
<span class="line-modified">!  * Note that by constructing `RegexMatcher` objects directly from regular</span>
   * expression pattern strings application code can be simplified and the explicit
<span class="line-modified">!  * need for `RegexPattern` objects can usually be eliminated.</span>
<span class="line-modified">!  *</span>
   */
  
  #include &quot;unicode/utypes.h&quot;
  
  #if !UCONFIG_NO_REGULAR_EXPRESSIONS
</pre>
<hr />
<pre>
<span class="line-old-header">*** 72,27 ***</span>
  class  UVector32;
  class  UVector64;
  
  
  /**
<span class="line-modified">!   * Class &lt;code&gt;RegexPattern&lt;/code&gt; represents a compiled regular expression.  It includes</span>
    * factory methods for creating a RegexPattern object from the source (string) form
    * of a regular expression, methods for creating RegexMatchers that allow the pattern
    * to be applied to input text, and a few convenience methods for simple common
    * uses of regular expressions.
    *
<span class="line-modified">!   * &lt;p&gt;Class RegexPattern is not intended to be subclassed.&lt;/p&gt;</span>
    *
    * @stable ICU 2.4
    */
  class U_I18N_API RegexPattern U_FINAL : public UObject {
  public:
  
      /**
       * default constructor.  Create a RegexPattern object that refers to no actual
       *   pattern.  Not normally needed; RegexPattern objects are usually
<span class="line-modified">!      *   created using the factory method &lt;code&gt;compile()&lt;/code&gt;.</span>
       *
       * @stable ICU 2.4
       */
      RegexPattern();
  
<span class="line-new-header">--- 70,27 ---</span>
  class  UVector32;
  class  UVector64;
  
  
  /**
<span class="line-modified">!   * Class `RegexPattern` represents a compiled regular expression.  It includes</span>
    * factory methods for creating a RegexPattern object from the source (string) form
    * of a regular expression, methods for creating RegexMatchers that allow the pattern
    * to be applied to input text, and a few convenience methods for simple common
    * uses of regular expressions.
    *
<span class="line-modified">!   * Class RegexPattern is not intended to be subclassed.</span>
    *
    * @stable ICU 2.4
    */
  class U_I18N_API RegexPattern U_FINAL : public UObject {
  public:
  
      /**
       * default constructor.  Create a RegexPattern object that refers to no actual
       *   pattern.  Not normally needed; RegexPattern objects are usually
<span class="line-modified">!      *   created using the factory method `compile()`.</span>
       *
       * @stable ICU 2.4
       */
      RegexPattern();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,21 ***</span>
       */
      virtual ~RegexPattern();
  
      /**
       * Comparison operator.  Two RegexPattern objects are considered equal if they
<span class="line-modified">!      * were constructed from identical source patterns using the same match flag</span>
       * settings.
       * @param that a RegexPattern object to compare with &quot;this&quot;.
       * @return TRUE if the objects are equivalent.
       * @stable ICU 2.4
       */
      UBool           operator==(const RegexPattern&amp; that) const;
  
      /**
       * Comparison operator.  Two RegexPattern objects are considered equal if they
<span class="line-modified">!      * were constructed from identical source patterns using the same match flag</span>
       * settings.
       * @param that a RegexPattern object to compare with &quot;this&quot;.
       * @return TRUE if the objects are different.
       * @stable ICU 2.4
       */
<span class="line-new-header">--- 109,21 ---</span>
       */
      virtual ~RegexPattern();
  
      /**
       * Comparison operator.  Two RegexPattern objects are considered equal if they
<span class="line-modified">!      * were constructed from identical source patterns using the same #URegexpFlag</span>
       * settings.
       * @param that a RegexPattern object to compare with &quot;this&quot;.
       * @return TRUE if the objects are equivalent.
       * @stable ICU 2.4
       */
      UBool           operator==(const RegexPattern&amp; that) const;
  
      /**
       * Comparison operator.  Two RegexPattern objects are considered equal if they
<span class="line-modified">!      * were constructed from identical source patterns using the same #URegexpFlag</span>
       * settings.
       * @param that a RegexPattern object to compare with &quot;this&quot;.
       * @return TRUE if the objects are different.
       * @stable ICU 2.4
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,20 ***</span>
     /**
      * Compiles the regular expression in string form into a RegexPattern
      * object.  These compile methods, rather than the constructors, are the usual
      * way that RegexPattern objects are created.
      *
<span class="line-modified">!     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.&lt;/p&gt;</span>
      *
<span class="line-modified">!     * &lt;p&gt;All pattern match mode flags are set to their default values.&lt;/p&gt;</span>
      *
<span class="line-modified">!     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string rather than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
      *
      * @param regex The regular expression to be compiled.
      * @param pe    Receives the position (line and column nubers) of any error
      *              within the regular expression.)
      * @param status A reference to a UErrorCode to receive any errors.
<span class="line-new-header">--- 149,20 ---</span>
     /**
      * Compiles the regular expression in string form into a RegexPattern
      * object.  These compile methods, rather than the constructors, are the usual
      * way that RegexPattern objects are created.
      *
<span class="line-modified">!     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.</span>
      *
<span class="line-modified">!     * All #URegexpFlag pattern match mode flags are set to their default values.</span>
      *
<span class="line-modified">!     * Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string rather than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.</span>
      *
      * @param regex The regular expression to be compiled.
      * @param pe    Receives the position (line and column nubers) of any error
      *              within the regular expression.)
      * @param status A reference to a UErrorCode to receive any errors.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 179,20 ***</span>
     /**
      * Compiles the regular expression in string form into a RegexPattern
      * object.  These compile methods, rather than the constructors, are the usual
      * way that RegexPattern objects are created.
      *
<span class="line-modified">!     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.&lt;/p&gt;</span>
      *
<span class="line-modified">!     * &lt;p&gt;All pattern match mode flags are set to their default values.&lt;/p&gt;</span>
      *
<span class="line-modified">!     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string rather than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
      *
      * @param regex The regular expression to be compiled. Note, the text referred
      *              to by this UText must not be deleted during the lifetime of the
      *              RegexPattern object or any RegexMatcher object created from it.
      * @param pe    Receives the position (line and column nubers) of any error
<span class="line-new-header">--- 177,20 ---</span>
     /**
      * Compiles the regular expression in string form into a RegexPattern
      * object.  These compile methods, rather than the constructors, are the usual
      * way that RegexPattern objects are created.
      *
<span class="line-modified">!     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.</span>
      *
<span class="line-modified">!     * All #URegexpFlag pattern match mode flags are set to their default values.</span>
      *
<span class="line-modified">!     * Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string rather than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.</span>
      *
      * @param regex The regular expression to be compiled. Note, the text referred
      *              to by this UText must not be deleted during the lifetime of the
      *              RegexPattern object or any RegexMatcher object created from it.
      * @param pe    Receives the position (line and column nubers) of any error
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,25 ***</span>
          UParseError          &amp;pe,
          UErrorCode           &amp;status);
  
     /**
      * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified">!     * object using the specified match mode flags.  These compile methods,</span>
      * rather than the constructors, are the usual way that RegexPattern objects
      * are created.
      *
<span class="line-modified">!     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.&lt;/p&gt;</span>
      *
<span class="line-modified">!     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
      *
      * @param regex The regular expression to be compiled.
<span class="line-modified">!     * @param flags The match mode flags to be used.</span>
      * @param pe    Receives the position (line and column numbers) of any error
      *              within the regular expression.)
      * @param status   A reference to a UErrorCode to receive any errors.
      * @return      A regexPattern object for the compiled pattern.
      *
<span class="line-new-header">--- 204,25 ---</span>
          UParseError          &amp;pe,
          UErrorCode           &amp;status);
  
     /**
      * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified">!     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
      * rather than the constructors, are the usual way that RegexPattern objects
      * are created.
      *
<span class="line-modified">!     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.</span>
      *
<span class="line-modified">!     * Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.</span>
      *
      * @param regex The regular expression to be compiled.
<span class="line-modified">!     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
      * @param pe    Receives the position (line and column numbers) of any error
      *              within the regular expression.)
      * @param status   A reference to a UErrorCode to receive any errors.
      * @return      A regexPattern object for the compiled pattern.
      *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,27 ***</span>
          UParseError          &amp;pe,
          UErrorCode           &amp;status);
  
     /**
      * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified">!     * object using the specified match mode flags.  These compile methods,</span>
      * rather than the constructors, are the usual way that RegexPattern objects
      * are created.
      *
<span class="line-modified">!     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.&lt;/p&gt;</span>
      *
<span class="line-modified">!     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
      *
      * @param regex The regular expression to be compiled. Note, the text referred
      *              to by this UText must not be deleted during the lifetime of the
      *              RegexPattern object or any RegexMatcher object created from it.
<span class="line-modified">!     * @param flags The match mode flags to be used.</span>
      * @param pe    Receives the position (line and column numbers) of any error
      *              within the regular expression.)
      * @param status   A reference to a UErrorCode to receive any errors.
      * @return      A regexPattern object for the compiled pattern.
      *
<span class="line-new-header">--- 233,27 ---</span>
          UParseError          &amp;pe,
          UErrorCode           &amp;status);
  
     /**
      * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified">!     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
      * rather than the constructors, are the usual way that RegexPattern objects
      * are created.
      *
<span class="line-modified">!     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.</span>
      *
<span class="line-modified">!     * Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.</span>
      *
      * @param regex The regular expression to be compiled. Note, the text referred
      *              to by this UText must not be deleted during the lifetime of the
      *              RegexPattern object or any RegexMatcher object created from it.
<span class="line-modified">!     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
      * @param pe    Receives the position (line and column numbers) of any error
      *              within the regular expression.)
      * @param status   A reference to a UErrorCode to receive any errors.
      * @return      A regexPattern object for the compiled pattern.
      *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,25 ***</span>
          UParseError          &amp;pe,
          UErrorCode           &amp;status);
  
     /**
      * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified">!     * object using the specified match mode flags.  These compile methods,</span>
      * rather than the constructors, are the usual way that RegexPattern objects
      * are created.
      *
<span class="line-modified">!     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.&lt;/p&gt;</span>
      *
<span class="line-modified">!     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
      *
      * @param regex The regular expression to be compiled.
<span class="line-modified">!     * @param flags The match mode flags to be used.</span>
      * @param status   A reference to a UErrorCode to receive any errors.
      * @return      A regexPattern object for the compiled pattern.
      *
      * @stable ICU 2.6
      */
<span class="line-new-header">--- 264,25 ---</span>
          UParseError          &amp;pe,
          UErrorCode           &amp;status);
  
     /**
      * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified">!     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
      * rather than the constructors, are the usual way that RegexPattern objects
      * are created.
      *
<span class="line-modified">!     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.</span>
      *
<span class="line-modified">!     * Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.</span>
      *
      * @param regex The regular expression to be compiled.
<span class="line-modified">!     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
      * @param status   A reference to a UErrorCode to receive any errors.
      * @return      A regexPattern object for the compiled pattern.
      *
      * @stable ICU 2.6
      */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,49 ***</span>
          uint32_t             flags,
          UErrorCode           &amp;status);
  
     /**
      * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified">!     * object using the specified match mode flags.  These compile methods,</span>
      * rather than the constructors, are the usual way that RegexPattern objects
      * are created.
      *
<span class="line-modified">!     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.&lt;/p&gt;</span>
      *
<span class="line-modified">!     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
      *
      * @param regex The regular expression to be compiled. Note, the text referred
      *              to by this UText must not be deleted during the lifetime of the
      *              RegexPattern object or any RegexMatcher object created from it.
<span class="line-modified">!     * @param flags The match mode flags to be used.</span>
      * @param status   A reference to a UErrorCode to receive any errors.
      * @return      A regexPattern object for the compiled pattern.
      *
      * @stable ICU 4.6
      */
      static RegexPattern * U_EXPORT2 compile( UText *regex,
          uint32_t             flags,
          UErrorCode           &amp;status);
  
     /**
<span class="line-modified">!     * Get the match mode flags that were used when compiling this pattern.</span>
<span class="line-modified">!     * @return  the match mode flags</span>
      * @stable ICU 2.4
      */
      virtual uint32_t flags() const;
  
     /**
      * Creates a RegexMatcher that will match the given input against this pattern.  The
      * RegexMatcher can then be used to perform match, find or replace operations
      * on the input.  Note that a RegexPattern object must not be deleted while
      * RegexMatchers created from it still exist and might possibly be used again.
<span class="line-modified">!     * &lt;p&gt;</span>
      * The matcher will retain a reference to the supplied input string, and all regexp
      * pattern matching operations happen directly on this original string.  It is
      * critical that the string not be altered or deleted before use by the regular
      * expression operations is complete.
      *
<span class="line-new-header">--- 290,49 ---</span>
          uint32_t             flags,
          UErrorCode           &amp;status);
  
     /**
      * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified">!     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
      * rather than the constructors, are the usual way that RegexPattern objects
      * are created.
      *
<span class="line-modified">!     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
      * objects created from the pattern are active.  RegexMatchers keep a pointer
      * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified">!     * catastrophic error.</span>
      *
<span class="line-modified">!     * Note that it is often more convenient to construct a RegexMatcher directly</span>
      *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified">!     *    then creating a RegexMatcher object from the pattern.</span>
      *
      * @param regex The regular expression to be compiled. Note, the text referred
      *              to by this UText must not be deleted during the lifetime of the
      *              RegexPattern object or any RegexMatcher object created from it.
<span class="line-modified">!     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
      * @param status   A reference to a UErrorCode to receive any errors.
      * @return      A regexPattern object for the compiled pattern.
      *
      * @stable ICU 4.6
      */
      static RegexPattern * U_EXPORT2 compile( UText *regex,
          uint32_t             flags,
          UErrorCode           &amp;status);
  
     /**
<span class="line-modified">!     * Get the #URegexpFlag match mode flags that were used when compiling this pattern.</span>
<span class="line-modified">!     * @return  the #URegexpFlag match mode flags</span>
      * @stable ICU 2.4
      */
      virtual uint32_t flags() const;
  
     /**
      * Creates a RegexMatcher that will match the given input against this pattern.  The
      * RegexMatcher can then be used to perform match, find or replace operations
      * on the input.  Note that a RegexPattern object must not be deleted while
      * RegexMatchers created from it still exist and might possibly be used again.
<span class="line-modified">!     *</span>
      * The matcher will retain a reference to the supplied input string, and all regexp
      * pattern matching operations happen directly on this original string.  It is
      * critical that the string not be altered or deleted before use by the regular
      * expression operations is complete.
      *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,16 ***</span>
  private:
      /**
       * Cause a compilation error if an application accidentally attempts to
       *   create a matcher with a (char16_t *) string as input rather than
       *   a UnicodeString.  Avoids a dangling reference to a temporary string.
<span class="line-modified">!      * &lt;p&gt;</span>
       * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
       * using one of the aliasing constructors, such as
<span class="line-modified">!      * &lt;code&gt;UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);&lt;/code&gt;</span>
       * or in a UText, using
<span class="line-modified">!      * &lt;code&gt;utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);&lt;/code&gt;</span>
       *
       */
      RegexMatcher *matcher(const char16_t *input,
          UErrorCode          &amp;status) const;
  public:
<span class="line-new-header">--- 348,16 ---</span>
  private:
      /**
       * Cause a compilation error if an application accidentally attempts to
       *   create a matcher with a (char16_t *) string as input rather than
       *   a UnicodeString.  Avoids a dangling reference to a temporary string.
<span class="line-modified">!      *</span>
       * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
       * using one of the aliasing constructors, such as
<span class="line-modified">!      * `UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);`</span>
       * or in a UText, using
<span class="line-modified">!      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`</span>
       *
       */
      RegexMatcher *matcher(const char16_t *input,
          UErrorCode          &amp;status) const;
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 519,11 ***</span>
          int32_t          destCapacity,
          UErrorCode       &amp;status) const;
  
  
      /**
<span class="line-modified">!      * Split a string into fields.  Somewhat like split() from Perl or Java.</span>
       * Pattern matches identify delimiters that separate the input
       * into fields.  The input data between the delimiters becomes the
       * fields themselves.
       *
       * If the delimiter pattern includes capture groups, the captured text will
<span class="line-new-header">--- 517,11 ---</span>
          int32_t          destCapacity,
          UErrorCode       &amp;status) const;
  
  
      /**
<span class="line-modified">!      * Split a string into fields.  Somewhat like %split() from Perl or Java.</span>
       * Pattern matches identify delimiters that separate the input
       * into fields.  The input data between the delimiters becomes the
       * fields themselves.
       *
       * If the delimiter pattern includes capture groups, the captured text will
</pre>
<hr />
<pre>
<span class="line-old-header">*** 538,11 ***</span>
       * The number of strings produced by the split operation is returned.
       * This count includes the strings from capture groups in the delimiter pattern.
       * This behavior differs from Java, which ignores capture groups.
       *
       *  For the best performance on split() operations,
<span class="line-modified">!      *  &lt;code&gt;RegexMatcher::split&lt;/code&gt; is preferable to this function</span>
       *
       * @param input   The string to be split into fields.  The field delimiters
       *                match the pattern (in the &quot;this&quot; object)
       * @param dest    An array of mutable UText structs to receive the results of the split.
       *                If a field is NULL, a new UText is allocated to contain the results for
<span class="line-new-header">--- 536,11 ---</span>
       * The number of strings produced by the split operation is returned.
       * This count includes the strings from capture groups in the delimiter pattern.
       * This behavior differs from Java, which ignores capture groups.
       *
       *  For the best performance on split() operations,
<span class="line-modified">!      *  `RegexMatcher::split()` is preferable to this function</span>
       *
       * @param input   The string to be split into fields.  The field delimiters
       *                match the pattern (in the &quot;this&quot; object)
       * @param dest    An array of mutable UText structs to receive the results of the split.
       *                If a field is NULL, a new UText is allocated to contain the results for
</pre>
<hr />
<pre>
<span class="line-old-header">*** 671,12 ***</span>
        * created for the same expression, it will be more efficient to
        * separately create and cache a RegexPattern object, and use
        * its matcher() method to create the RegexMatcher objects.
        *
        *  @param regexp The Regular Expression to be compiled.
<span class="line-modified">!       *  @param flags  Regular expression options, such as case insensitive matching.</span>
<span class="line-removed">-       *                @see UREGEX_CASE_INSENSITIVE</span>
        *  @param status Any errors are reported by setting this UErrorCode variable.
        *  @stable ICU 2.6
        */
      RegexMatcher(const UnicodeString &amp;regexp, uint32_t flags, UErrorCode &amp;status);
  
<span class="line-new-header">--- 669,11 ---</span>
        * created for the same expression, it will be more efficient to
        * separately create and cache a RegexPattern object, and use
        * its matcher() method to create the RegexMatcher objects.
        *
        *  @param regexp The Regular Expression to be compiled.
<span class="line-modified">!       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>
        *  @param status Any errors are reported by setting this UErrorCode variable.
        *  @stable ICU 2.6
        */
      RegexMatcher(const UnicodeString &amp;regexp, uint32_t flags, UErrorCode &amp;status);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,12 ***</span>
        * created for the same expression, it will be more efficient to
        * separately create and cache a RegexPattern object, and use
        * its matcher() method to create the RegexMatcher objects.
        *
        *  @param regexp The regular expression to be compiled.
<span class="line-modified">!       *  @param flags  Regular expression options, such as case insensitive matching.</span>
<span class="line-removed">-       *                @see UREGEX_CASE_INSENSITIVE</span>
        *  @param status Any errors are reported by setting this UErrorCode variable.
        *
        *  @stable ICU 4.6
        */
      RegexMatcher(UText *regexp, uint32_t flags, UErrorCode &amp;status);
<span class="line-new-header">--- 684,11 ---</span>
        * created for the same expression, it will be more efficient to
        * separately create and cache a RegexPattern object, and use
        * its matcher() method to create the RegexMatcher objects.
        *
        *  @param regexp The regular expression to be compiled.
<span class="line-modified">!       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>
        *  @param status Any errors are reported by setting this UErrorCode variable.
        *
        *  @stable ICU 4.6
        */
      RegexMatcher(UText *regexp, uint32_t flags, UErrorCode &amp;status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 702,21 ***</span>
        * This is a convenience method that avoids the need to explicitly create
        * a RegexPattern object.  Note that if several RegexMatchers need to be
        * created for the same expression, it will be more efficient to
        * separately create and cache a RegexPattern object, and use
        * its matcher() method to create the RegexMatcher objects.
<span class="line-modified">!       * &lt;p&gt;</span>
        * The matcher will retain a reference to the supplied input string, and all regexp
        * pattern matching operations happen directly on the original string.  It is
        * critical that the string not be altered or deleted before use by the regular
        * expression operations is complete.
        *
        *  @param regexp The Regular Expression to be compiled.
        *  @param input  The string to match.  The matcher retains a reference to the
        *                caller&#39;s string; mo copy is made.
<span class="line-modified">!       *  @param flags  Regular expression options, such as case insensitive matching.</span>
<span class="line-removed">-       *                @see UREGEX_CASE_INSENSITIVE</span>
        *  @param status Any errors are reported by setting this UErrorCode variable.
        *  @stable ICU 2.6
        */
      RegexMatcher(const UnicodeString &amp;regexp, const UnicodeString &amp;input,
          uint32_t flags, UErrorCode &amp;status);
<span class="line-new-header">--- 698,20 ---</span>
        * This is a convenience method that avoids the need to explicitly create
        * a RegexPattern object.  Note that if several RegexMatchers need to be
        * created for the same expression, it will be more efficient to
        * separately create and cache a RegexPattern object, and use
        * its matcher() method to create the RegexMatcher objects.
<span class="line-modified">!       *</span>
        * The matcher will retain a reference to the supplied input string, and all regexp
        * pattern matching operations happen directly on the original string.  It is
        * critical that the string not be altered or deleted before use by the regular
        * expression operations is complete.
        *
        *  @param regexp The Regular Expression to be compiled.
        *  @param input  The string to match.  The matcher retains a reference to the
        *                caller&#39;s string; mo copy is made.
<span class="line-modified">!       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>
        *  @param status Any errors are reported by setting this UErrorCode variable.
        *  @stable ICU 2.6
        */
      RegexMatcher(const UnicodeString &amp;regexp, const UnicodeString &amp;input,
          uint32_t flags, UErrorCode &amp;status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 726,20 ***</span>
        * This is a convenience method that avoids the need to explicitly create
        * a RegexPattern object.  Note that if several RegexMatchers need to be
        * created for the same expression, it will be more efficient to
        * separately create and cache a RegexPattern object, and use
        * its matcher() method to create the RegexMatcher objects.
<span class="line-modified">!       * &lt;p&gt;</span>
        * The matcher will make a shallow clone of the supplied input text, and all regexp
        * pattern matching operations happen on this clone.  While read-only operations on
        * the supplied text are permitted, it is critical that the underlying string not be
        * altered or deleted before use by the regular expression operations is complete.
        *
        *  @param regexp The Regular Expression to be compiled.
        *  @param input  The string to match.  The matcher retains a shallow clone of the text.
<span class="line-modified">!       *  @param flags  Regular expression options, such as case insensitive matching.</span>
<span class="line-removed">-       *                @see UREGEX_CASE_INSENSITIVE</span>
        *  @param status Any errors are reported by setting this UErrorCode variable.
        *
        *  @stable ICU 4.6
        */
      RegexMatcher(UText *regexp, UText *input,
<span class="line-new-header">--- 721,19 ---</span>
        * This is a convenience method that avoids the need to explicitly create
        * a RegexPattern object.  Note that if several RegexMatchers need to be
        * created for the same expression, it will be more efficient to
        * separately create and cache a RegexPattern object, and use
        * its matcher() method to create the RegexMatcher objects.
<span class="line-modified">!       *</span>
        * The matcher will make a shallow clone of the supplied input text, and all regexp
        * pattern matching operations happen on this clone.  While read-only operations on
        * the supplied text are permitted, it is critical that the underlying string not be
        * altered or deleted before use by the regular expression operations is complete.
        *
        *  @param regexp The Regular Expression to be compiled.
        *  @param input  The string to match.  The matcher retains a shallow clone of the text.
<span class="line-modified">!       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>
        *  @param status Any errors are reported by setting this UErrorCode variable.
        *
        *  @stable ICU 4.6
        */
      RegexMatcher(UText *regexp, UText *input,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 748,17 ***</span>
  private:
      /**
       * Cause a compilation error if an application accidentally attempts to
       *   create a matcher with a (char16_t *) string as input rather than
       *   a UnicodeString.    Avoids a dangling reference to a temporary string.
<span class="line-modified">!      * &lt;p&gt;</span>
       * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
       * using one of the aliasing constructors, such as
<span class="line-modified">!      * &lt;code&gt;UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);&lt;/code&gt;</span>
       * or in a UText, using
<span class="line-modified">!      * &lt;code&gt;utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);&lt;/code&gt;</span>
<span class="line-removed">-      *</span>
       */
      RegexMatcher(const UnicodeString &amp;regexp, const char16_t *input,
          uint32_t flags, UErrorCode &amp;status);
  public:
  
<span class="line-new-header">--- 742,16 ---</span>
  private:
      /**
       * Cause a compilation error if an application accidentally attempts to
       *   create a matcher with a (char16_t *) string as input rather than
       *   a UnicodeString.    Avoids a dangling reference to a temporary string.
<span class="line-modified">!      *</span>
       * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
       * using one of the aliasing constructors, such as
<span class="line-modified">!      * `UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);`</span>
       * or in a UText, using
<span class="line-modified">!      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`</span>
       */
      RegexMatcher(const UnicodeString &amp;regexp, const char16_t *input,
          uint32_t flags, UErrorCode &amp;status);
  public:
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 797,12 ***</span>
      *   Attempts to match the input string, starting from the beginning of the region,
      *   against the pattern.  Like the matches() method, this function
      *   always starts at the beginning of the input region;
      *   unlike that function, it does not require that the entire region be matched.
      *
<span class="line-modified">!     *   &lt;p&gt;If the match succeeds then more information can be obtained via the &lt;code&gt;start()&lt;/code&gt;,</span>
<span class="line-modified">!     *     &lt;code&gt;end()&lt;/code&gt;, and &lt;code&gt;group()&lt;/code&gt; functions.&lt;/p&gt;</span>
      *
      *    @param   status     A reference to a UErrorCode to receive any errors.
      *    @return  TRUE if there is a match at the start of the input string.
      *    @stable ICU 2.4
      */
<span class="line-new-header">--- 790,12 ---</span>
      *   Attempts to match the input string, starting from the beginning of the region,
      *   against the pattern.  Like the matches() method, this function
      *   always starts at the beginning of the input region;
      *   unlike that function, it does not require that the entire region be matched.
      *
<span class="line-modified">!     *   If the match succeeds then more information can be obtained via the start(),</span>
<span class="line-modified">!     *   end(), and group() functions.</span>
      *
      *    @param   status     A reference to a UErrorCode to receive any errors.
      *    @return  TRUE if there is a match at the start of the input string.
      *    @stable ICU 2.4
      */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 812,12 ***</span>
    /**
      *   Attempts to match the input string, starting from the specified index, against the pattern.
      *   The match may be of any length, and is not required to extend to the end
      *   of the input string.  Contrast with match().
      *
<span class="line-modified">!     *   &lt;p&gt;If the match succeeds then more information can be obtained via the &lt;code&gt;start()&lt;/code&gt;,</span>
<span class="line-modified">!     *     &lt;code&gt;end()&lt;/code&gt;, and &lt;code&gt;group()&lt;/code&gt; functions.&lt;/p&gt;</span>
      *
      *    @param   startIndex The input string (native) index at which to begin matching.
      *    @param   status     A reference to a UErrorCode to receive any errors.
      *    @return  TRUE if there is a match.
      *    @stable ICU 2.8
<span class="line-new-header">--- 805,12 ---</span>
    /**
      *   Attempts to match the input string, starting from the specified index, against the pattern.
      *   The match may be of any length, and is not required to extend to the end
      *   of the input string.  Contrast with match().
      *
<span class="line-modified">!     *   If the match succeeds then more information can be obtained via the start(),</span>
<span class="line-modified">!     *   end(), and group() functions.</span>
      *
      *    @param   startIndex The input string (native) index at which to begin matching.
      *    @param   status     A reference to a UErrorCode to receive any errors.
      *    @return  TRUE if there is a match.
      *    @stable ICU 2.8
</pre>
<hr />
<pre>
<span class="line-old-header">*** 827,30 ***</span>
  
     /**
      *  Find the next pattern match in the input string.
      *  The find begins searching the input at the location following the end of
      *  the previous match, or at the start of the string if there is no previous match.
<span class="line-modified">!     *  If a match is found, &lt;code&gt;start(), end()&lt;/code&gt; and &lt;code&gt;group()&lt;/code&gt;</span>
      *  will provide more information regarding the match.
<span class="line-modified">!     *  &lt;p&gt;Note that if the input string is changed by the application,</span>
      *     use find(startPos, status) instead of find(), because the saved starting
<span class="line-modified">!     *     position may not be valid with the altered input string.&lt;/p&gt;</span>
      *  @return  TRUE if a match is found.
      *  @stable ICU 2.4
      */
      virtual UBool find();
  
  
     /**
      *  Find the next pattern match in the input string.
      *  The find begins searching the input at the location following the end of
      *  the previous match, or at the start of the string if there is no previous match.
<span class="line-modified">!     *  If a match is found, &lt;code&gt;start(), end()&lt;/code&gt; and &lt;code&gt;group()&lt;/code&gt;</span>
      *  will provide more information regarding the match.
<span class="line-modified">!     *  &lt;p&gt;Note that if the input string is changed by the application,</span>
<span class="line-modified">!     *     use find(startPos, status) instead of find(), because the saved starting</span>
<span class="line-modified">!     *     position may not be valid with the altered input string.&lt;/p&gt;</span>
      *  @param   status  A reference to a UErrorCode to receive any errors.
      *  @return  TRUE if a match is found.
      * @stable ICU 55
      */
      virtual UBool find(UErrorCode &amp;status);
<span class="line-new-header">--- 820,31 ---</span>
  
     /**
      *  Find the next pattern match in the input string.
      *  The find begins searching the input at the location following the end of
      *  the previous match, or at the start of the string if there is no previous match.
<span class="line-modified">!     *  If a match is found, `start()`, `end()` and `group()`</span>
      *  will provide more information regarding the match.
<span class="line-modified">!     *  Note that if the input string is changed by the application,</span>
      *     use find(startPos, status) instead of find(), because the saved starting
<span class="line-modified">!     *     position may not be valid with the altered input string.</span>
      *  @return  TRUE if a match is found.
      *  @stable ICU 2.4
      */
      virtual UBool find();
  
  
     /**
      *  Find the next pattern match in the input string.
      *  The find begins searching the input at the location following the end of
      *  the previous match, or at the start of the string if there is no previous match.
<span class="line-modified">!     *  If a match is found, `start()`, `end()` and `group()`</span>
      *  will provide more information regarding the match.
<span class="line-modified">!     *</span>
<span class="line-modified">!     *  Note that if the input string is changed by the application,</span>
<span class="line-modified">!     *  use find(startPos, status) instead of find(), because the saved starting</span>
<span class="line-added">+     *  position may not be valid with the altered input string.</span>
      *  @param   status  A reference to a UErrorCode to receive any errors.
      *  @return  TRUE if a match is found.
      * @stable ICU 55
      */
      virtual UBool find(UErrorCode &amp;status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1076,14 ***</span>
     /**
      *   Resets this matcher, and set the current input position.
      *   The effect is to remove any memory of previous matches,
      *       and to cause subsequent find() operations to begin at
      *       the specified (native) position in the input string.
<span class="line-modified">!     * &lt;p&gt;</span>
      *   The matcher&#39;s region is reset to its default, which is the entire
      *   input string.
<span class="line-modified">!     * &lt;p&gt;</span>
      *   An alternative to this function is to set a match region
      *   beginning at the desired index.
      *
      *   @return this RegexMatcher.
      *   @stable ICU 2.8
<span class="line-new-header">--- 1070,14 ---</span>
     /**
      *   Resets this matcher, and set the current input position.
      *   The effect is to remove any memory of previous matches,
      *       and to cause subsequent find() operations to begin at
      *       the specified (native) position in the input string.
<span class="line-modified">!     *</span>
      *   The matcher&#39;s region is reset to its default, which is the entire
      *   input string.
<span class="line-modified">!     *</span>
      *   An alternative to this function is to set a match region
      *   beginning at the desired index.
      *
      *   @return this RegexMatcher.
      *   @stable ICU 2.8
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1156,16 ***</span>
  private:
      /**
       * Cause a compilation error if an application accidentally attempts to
       *   reset a matcher with a (char16_t *) string as input rather than
       *   a UnicodeString.    Avoids a dangling reference to a temporary string.
<span class="line-modified">!      * &lt;p&gt;</span>
       * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
       * using one of the aliasing constructors, such as
<span class="line-modified">!      * &lt;code&gt;UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);&lt;/code&gt;</span>
       * or in a UText, using
<span class="line-modified">!      * &lt;code&gt;utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);&lt;/code&gt;</span>
       *
       */
      RegexMatcher &amp;reset(const char16_t *input);
  public:
  
<span class="line-new-header">--- 1150,16 ---</span>
  private:
      /**
       * Cause a compilation error if an application accidentally attempts to
       *   reset a matcher with a (char16_t *) string as input rather than
       *   a UnicodeString.    Avoids a dangling reference to a temporary string.
<span class="line-modified">!      *</span>
       * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
       * using one of the aliasing constructors, such as
<span class="line-modified">!      * `UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);`</span>
       * or in a UText, using
<span class="line-modified">!      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`</span>
       *
       */
      RegexMatcher &amp;reset(const char16_t *input);
  public:
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1410,19 ***</span>
     /**
      * Replaces the first substring of the input that matches
      * the pattern with the replacement string.   This is a convenience
      * function that provides a complete find-and-replace operation.
      *
<span class="line-modified">!     * &lt;p&gt;This function first resets this RegexMatcher. It then scans the input string</span>
      * looking for a match of the pattern. Input that is not part
      * of the match is appended directly to the result string; the match is replaced
      * in the result by the replacement string. The replacement string may contain
<span class="line-modified">!     * references to captured groups.&lt;/p&gt;</span>
      *
<span class="line-modified">!     * &lt;p&gt;The state of the matcher (the position at which a subsequent find()</span>
      *    would begin) after completing a replaceFirst() is not specified.  The
<span class="line-modified">!     *    RegexMatcher should be reset before doing additional find() operations.&lt;/p&gt;</span>
      *
      *    @param   replacement a string containing the replacement text.
      *    @param   status      a reference to a UErrorCode to receive any errors.
      *    @return              a string containing the results of the find and replace.
      *    @stable ICU 2.4
<span class="line-new-header">--- 1404,19 ---</span>
     /**
      * Replaces the first substring of the input that matches
      * the pattern with the replacement string.   This is a convenience
      * function that provides a complete find-and-replace operation.
      *
<span class="line-modified">!     * This function first resets this RegexMatcher. It then scans the input string</span>
      * looking for a match of the pattern. Input that is not part
      * of the match is appended directly to the result string; the match is replaced
      * in the result by the replacement string. The replacement string may contain
<span class="line-modified">!     * references to captured groups.</span>
      *
<span class="line-modified">!     * The state of the matcher (the position at which a subsequent find()</span>
      *    would begin) after completing a replaceFirst() is not specified.  The
<span class="line-modified">!     *    RegexMatcher should be reset before doing additional find() operations.</span>
      *
      *    @param   replacement a string containing the replacement text.
      *    @param   status      a reference to a UErrorCode to receive any errors.
      *    @return              a string containing the results of the find and replace.
      *    @stable ICU 2.4
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1433,19 ***</span>
     /**
      * Replaces the first substring of the input that matches
      * the pattern with the replacement string.   This is a convenience
      * function that provides a complete find-and-replace operation.
      *
<span class="line-modified">!     * &lt;p&gt;This function first resets this RegexMatcher. It then scans the input string</span>
      * looking for a match of the pattern. Input that is not part
      * of the match is appended directly to the result string; the match is replaced
      * in the result by the replacement string. The replacement string may contain
<span class="line-modified">!     * references to captured groups.&lt;/p&gt;</span>
      *
<span class="line-modified">!     * &lt;p&gt;The state of the matcher (the position at which a subsequent find()</span>
      *    would begin) after completing a replaceFirst() is not specified.  The
<span class="line-modified">!     *    RegexMatcher should be reset before doing additional find() operations.&lt;/p&gt;</span>
      *
      *    @param   replacement a string containing the replacement text.
      *    @param   dest        a mutable UText in which the results are placed.
      *                          If NULL, a new UText will be created (which may not be mutable).
      *    @param   status      a reference to a UErrorCode to receive any errors.
<span class="line-new-header">--- 1427,19 ---</span>
     /**
      * Replaces the first substring of the input that matches
      * the pattern with the replacement string.   This is a convenience
      * function that provides a complete find-and-replace operation.
      *
<span class="line-modified">!     * This function first resets this RegexMatcher. It then scans the input string</span>
      * looking for a match of the pattern. Input that is not part
      * of the match is appended directly to the result string; the match is replaced
      * in the result by the replacement string. The replacement string may contain
<span class="line-modified">!     * references to captured groups.</span>
      *
<span class="line-modified">!     * The state of the matcher (the position at which a subsequent find()</span>
      *    would begin) after completing a replaceFirst() is not specified.  The
<span class="line-modified">!     *    RegexMatcher should be reset before doing additional find() operations.</span>
      *
      *    @param   replacement a string containing the replacement text.
      *    @param   dest        a mutable UText in which the results are placed.
      *                          If NULL, a new UText will be created (which may not be mutable).
      *    @param   status      a reference to a UErrorCode to receive any errors.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1459,17 ***</span>
  
     /**
      *   Implements a replace operation intended to be used as part of an
      *   incremental find-and-replace.
      *
<span class="line-modified">!     *   &lt;p&gt;The input string, starting from the end of the previous replacement and ending at</span>
      *   the start of the current match, is appended to the destination string.  Then the
      *   replacement string is appended to the output string,
<span class="line-modified">!     *   including handling any substitutions of captured text.&lt;/p&gt;</span>
      *
<span class="line-modified">!     *   &lt;p&gt;For simple, prepackaged, non-incremental find-and-replace</span>
<span class="line-modified">!     *   operations, see replaceFirst() or replaceAll().&lt;/p&gt;</span>
      *
      *   @param   dest        A UnicodeString to which the results of the find-and-replace are appended.
      *   @param   replacement A UnicodeString that provides the text to be substituted for
      *                        the input text that matched the regexp pattern.  The replacement
      *                        text may contain references to captured text from the
<span class="line-new-header">--- 1453,17 ---</span>
  
     /**
      *   Implements a replace operation intended to be used as part of an
      *   incremental find-and-replace.
      *
<span class="line-modified">!     *   The input string, starting from the end of the previous replacement and ending at</span>
      *   the start of the current match, is appended to the destination string.  Then the
      *   replacement string is appended to the output string,
<span class="line-modified">!     *   including handling any substitutions of captured text.</span>
      *
<span class="line-modified">!     *   For simple, prepackaged, non-incremental find-and-replace</span>
<span class="line-modified">!     *   operations, see replaceFirst() or replaceAll().</span>
      *
      *   @param   dest        A UnicodeString to which the results of the find-and-replace are appended.
      *   @param   replacement A UnicodeString that provides the text to be substituted for
      *                        the input text that matched the regexp pattern.  The replacement
      *                        text may contain references to captured text from the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1490,17 ***</span>
  
     /**
      *   Implements a replace operation intended to be used as part of an
      *   incremental find-and-replace.
      *
<span class="line-modified">!     *   &lt;p&gt;The input string, starting from the end of the previous replacement and ending at</span>
      *   the start of the current match, is appended to the destination string.  Then the
      *   replacement string is appended to the output string,
<span class="line-modified">!     *   including handling any substitutions of captured text.&lt;/p&gt;</span>
      *
<span class="line-modified">!     *   &lt;p&gt;For simple, prepackaged, non-incremental find-and-replace</span>
<span class="line-modified">!     *   operations, see replaceFirst() or replaceAll().&lt;/p&gt;</span>
      *
      *   @param   dest        A mutable UText to which the results of the find-and-replace are appended.
      *                         Must not be NULL.
      *   @param   replacement A UText that provides the text to be substituted for
      *                        the input text that matched the regexp pattern.  The replacement
<span class="line-new-header">--- 1484,17 ---</span>
  
     /**
      *   Implements a replace operation intended to be used as part of an
      *   incremental find-and-replace.
      *
<span class="line-modified">!     *   The input string, starting from the end of the previous replacement and ending at</span>
      *   the start of the current match, is appended to the destination string.  Then the
      *   replacement string is appended to the output string,
<span class="line-modified">!     *   including handling any substitutions of captured text.</span>
      *
<span class="line-modified">!     *   For simple, prepackaged, non-incremental find-and-replace</span>
<span class="line-modified">!     *   operations, see replaceFirst() or replaceAll().</span>
      *
      *   @param   dest        A mutable UText to which the results of the find-and-replace are appended.
      *                         Must not be NULL.
      *   @param   replacement A UText that provides the text to be substituted for
      *                        the input text that matched the regexp pattern.  The replacement
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1520,12 ***</span>
  
  
     /**
      * As the final step in a find-and-replace operation, append the remainder
      * of the input string, starting at the position following the last appendReplacement(),
<span class="line-modified">!     * to the destination string. &lt;code&gt;appendTail()&lt;/code&gt; is intended to be invoked after one</span>
<span class="line-modified">!     * or more invocations of the &lt;code&gt;RegexMatcher::appendReplacement()&lt;/code&gt;.</span>
      *
      *  @param dest A UnicodeString to which the results of the find-and-replace are appended.
      *  @return  the destination string.
      *  @stable ICU 2.4
      */
<span class="line-new-header">--- 1514,12 ---</span>
  
  
     /**
      * As the final step in a find-and-replace operation, append the remainder
      * of the input string, starting at the position following the last appendReplacement(),
<span class="line-modified">!     * to the destination string. `appendTail()` is intended to be invoked after one</span>
<span class="line-modified">!     * or more invocations of the `RegexMatcher::appendReplacement()`.</span>
      *
      *  @param dest A UnicodeString to which the results of the find-and-replace are appended.
      *  @return  the destination string.
      *  @stable ICU 2.4
      */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1533,12 ***</span>
  
  
     /**
      * As the final step in a find-and-replace operation, append the remainder
      * of the input string, starting at the position following the last appendReplacement(),
<span class="line-modified">!     * to the destination string. &lt;code&gt;appendTail()&lt;/code&gt; is intended to be invoked after one</span>
<span class="line-modified">!     * or more invocations of the &lt;code&gt;RegexMatcher::appendReplacement()&lt;/code&gt;.</span>
      *
      *  @param dest A mutable UText to which the results of the find-and-replace are appended.
      *               Must not be NULL.
      *  @param status error cod
      *  @return  the destination string.
<span class="line-new-header">--- 1527,12 ---</span>
  
  
     /**
      * As the final step in a find-and-replace operation, append the remainder
      * of the input string, starting at the position following the last appendReplacement(),
<span class="line-modified">!     * to the destination string. `appendTail()` is intended to be invoked after one</span>
<span class="line-modified">!     * or more invocations of the `RegexMatcher::appendReplacement()`.</span>
      *
      *  @param dest A mutable UText to which the results of the find-and-replace are appended.
      *               Must not be NULL.
      *  @param status error cod
      *  @return  the destination string.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1547,11 ***</span>
      */
      virtual UText *appendTail(UText *dest, UErrorCode &amp;status);
  
  
      /**
<span class="line-modified">!      * Split a string into fields.  Somewhat like split() from Perl.</span>
       * The pattern matches identify delimiters that separate the input
       *  into fields.  The input data between the matches becomes the
       *  fields themselves.
       *
       * @param input   The string to be split into fields.  The field delimiters
<span class="line-new-header">--- 1541,11 ---</span>
      */
      virtual UText *appendTail(UText *dest, UErrorCode &amp;status);
  
  
      /**
<span class="line-modified">!      * Split a string into fields.  Somewhat like %split() from Perl.</span>
       * The pattern matches identify delimiters that separate the input
       *  into fields.  The input data between the matches becomes the
       *  fields themselves.
       *
       * @param input   The string to be split into fields.  The field delimiters
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1576,11 ***</span>
          int32_t          destCapacity,
          UErrorCode       &amp;status);
  
  
      /**
<span class="line-modified">!      * Split a string into fields.  Somewhat like split() from Perl.</span>
       * The pattern matches identify delimiters that separate the input
       *  into fields.  The input data between the matches becomes the
       *  fields themselves.
       *
       * @param input   The string to be split into fields.  The field delimiters
<span class="line-new-header">--- 1570,11 ---</span>
          int32_t          destCapacity,
          UErrorCode       &amp;status);
  
  
      /**
<span class="line-modified">!      * Split a string into fields.  Somewhat like %split() from Perl.</span>
       * The pattern matches identify delimiters that separate the input
       *  into fields.  The input data between the matches becomes the
       *  fields themselves.
       *
       * @param input   The string to be split into fields.  The field delimiters
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1611,18 ***</span>
      *   Some patterns, when matching certain strings, can run in exponential time.
      *   For practical purposes, the match operation may appear to be in an
      *   infinite loop.
      *   When a limit is set a match operation will fail with an error if the
      *   limit is exceeded.
<span class="line-modified">!     *   &lt;p&gt;</span>
      *   The units of the limit are steps of the match engine.
      *   Correspondence with actual processor time will depend on the speed
      *   of the processor and the details of the specific pattern, but will
      *   typically be on the order of milliseconds.
<span class="line-modified">!     *   &lt;p&gt;</span>
      *   By default, the matching time is not limited.
<span class="line-modified">!     *   &lt;p&gt;</span>
      *
      *   @param   limit       The limit value, or 0 for no limit.
      *   @param   status      A reference to a UErrorCode to receive any errors.
      *   @stable ICU 4.0
      */
<span class="line-new-header">--- 1605,18 ---</span>
      *   Some patterns, when matching certain strings, can run in exponential time.
      *   For practical purposes, the match operation may appear to be in an
      *   infinite loop.
      *   When a limit is set a match operation will fail with an error if the
      *   limit is exceeded.
<span class="line-modified">!     *</span>
      *   The units of the limit are steps of the match engine.
      *   Correspondence with actual processor time will depend on the speed
      *   of the processor and the details of the specific pattern, but will
      *   typically be on the order of milliseconds.
<span class="line-modified">!     *</span>
      *   By default, the matching time is not limited.
<span class="line-modified">!     *</span>
      *
      *   @param   limit       The limit value, or 0 for no limit.
      *   @param   status      A reference to a UErrorCode to receive any errors.
      *   @stable ICU 4.0
      */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1637,20 ***</span>
      virtual int32_t getTimeLimit() const;
  
    /**
      *  Set the amount of heap storage available for use by the match backtracking stack.
      *  The matcher is also reset, discarding any results from previous matches.
<span class="line-modified">!     *  &lt;p&gt;</span>
      *  ICU uses a backtracking regular expression engine, with the backtrack stack
      *  maintained on the heap.  This function sets the limit to the amount of memory
<span class="line-modified">!     *  that can be used  for this purpose.  A backtracking stack overflow will</span>
      *  result in an error from the match operation that caused it.
<span class="line-modified">!     *  &lt;p&gt;</span>
      *  A limit is desirable because a malicious or poorly designed pattern can use
      *  excessive memory, potentially crashing the process.  A limit is enabled
      *  by default.
<span class="line-modified">!     *  &lt;p&gt;</span>
      *  @param limit  The maximum size, in bytes, of the matching backtrack stack.
      *                A value of zero means no limit.
      *                The limit must be greater or equal to zero.
      *
      *  @param status   A reference to a UErrorCode to receive any errors.
<span class="line-new-header">--- 1631,20 ---</span>
      virtual int32_t getTimeLimit() const;
  
    /**
      *  Set the amount of heap storage available for use by the match backtracking stack.
      *  The matcher is also reset, discarding any results from previous matches.
<span class="line-modified">!     *</span>
      *  ICU uses a backtracking regular expression engine, with the backtrack stack
      *  maintained on the heap.  This function sets the limit to the amount of memory
<span class="line-modified">!     *  that can be used for this purpose.  A backtracking stack overflow will</span>
      *  result in an error from the match operation that caused it.
<span class="line-modified">!     *</span>
      *  A limit is desirable because a malicious or poorly designed pattern can use
      *  excessive memory, potentially crashing the process.  A limit is enabled
      *  by default.
<span class="line-modified">!     *</span>
      *  @param limit  The maximum size, in bytes, of the matching backtrack stack.
      *                A value of zero means no limit.
      *                The limit must be greater or equal to zero.
      *
      *  @param status   A reference to a UErrorCode to receive any errors.
</pre>
<center><a href="rbnf.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="region.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>