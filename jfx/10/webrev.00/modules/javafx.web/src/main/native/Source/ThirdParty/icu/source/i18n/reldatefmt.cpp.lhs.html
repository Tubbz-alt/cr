<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/reldatefmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ******************************************************************************
   5 * Copyright (C) 2014-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 ******************************************************************************
   8 *
   9 * File reldatefmt.cpp
  10 ******************************************************************************
  11 */
  12 
  13 #include &quot;unicode/reldatefmt.h&quot;
  14 
  15 #if !UCONFIG_NO_FORMATTING &amp;&amp; !UCONFIG_NO_BREAK_ITERATION
  16 
  17 #include &lt;cmath&gt;
<a name="1" id="anc1"></a>
  18 #include &quot;unicode/dtfmtsym.h&quot;
  19 #include &quot;unicode/ucasemap.h&quot;
  20 #include &quot;unicode/ureldatefmt.h&quot;
  21 #include &quot;unicode/udisplaycontext.h&quot;
  22 #include &quot;unicode/unum.h&quot;
  23 #include &quot;unicode/localpointer.h&quot;
  24 #include &quot;unicode/plurrule.h&quot;
  25 #include &quot;unicode/simpleformatter.h&quot;
  26 #include &quot;unicode/decimfmt.h&quot;
  27 #include &quot;unicode/numfmt.h&quot;
  28 #include &quot;unicode/brkiter.h&quot;
  29 #include &quot;unicode/simpleformatter.h&quot;
  30 #include &quot;uresimp.h&quot;
  31 #include &quot;unicode/ures.h&quot;
  32 #include &quot;cstring.h&quot;
  33 #include &quot;ucln_in.h&quot;
  34 #include &quot;mutex.h&quot;
  35 #include &quot;charstr.h&quot;
  36 #include &quot;uassert.h&quot;
  37 #include &quot;quantityformatter.h&quot;
  38 #include &quot;resource.h&quot;
  39 #include &quot;sharedbreakiterator.h&quot;
  40 #include &quot;sharedpluralrules.h&quot;
  41 #include &quot;sharednumberformat.h&quot;
  42 #include &quot;standardplural.h&quot;
  43 #include &quot;unifiedcache.h&quot;
<a name="2" id="anc2"></a>





  44 
  45 // Copied from uscript_props.cpp
  46 
<a name="3" id="anc3"></a><span class="line-removed">  47 static UMutex gBrkIterMutex = U_MUTEX_INITIALIZER;</span>
<span class="line-removed">  48 </span>
  49 U_NAMESPACE_BEGIN
  50 
  51 // RelativeDateTimeFormatter specific data for a single locale
  52 class RelativeDateTimeCacheData: public SharedObject {
  53 public:
<a name="4" id="anc4"></a><span class="line-modified">  54     RelativeDateTimeCacheData() : combinedDateAndTime(NULL) {</span>
  55         // Initialize the cache arrays
  56         for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<a name="5" id="anc5"></a><span class="line-modified">  57             for (int32_t relUnit = 0; relUnit &lt; UDAT_RELATIVE_UNIT_COUNT; ++relUnit) {</span>
  58                 for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
<a name="6" id="anc6"></a><span class="line-modified">  59                     relativeUnitsFormatters[style][relUnit][0][pl] = NULL;</span>
<span class="line-modified">  60                     relativeUnitsFormatters[style][relUnit][1][pl] = NULL;</span>
  61                 }
  62             }
  63         }
  64         for (int32_t i = 0; i &lt; UDAT_STYLE_COUNT; ++i) {
  65           fallBackCache[i] = -1;
  66         }
  67     }
  68     virtual ~RelativeDateTimeCacheData();
  69 
  70     // no numbers: e.g Next Tuesday; Yesterday; etc.
  71     UnicodeString absoluteUnits[UDAT_STYLE_COUNT][UDAT_ABSOLUTE_UNIT_COUNT][UDAT_DIRECTION_COUNT];
  72 
  73     // SimpleFormatter pointers for relative unit format,
  74     // e.g., Next Tuesday; Yesterday; etc. For third index, 0
  75     // means past, e.g., 5 days ago; 1 means future, e.g., in 5 days.
  76     SimpleFormatter *relativeUnitsFormatters[UDAT_STYLE_COUNT]
<a name="7" id="anc7"></a><span class="line-modified">  77         [UDAT_RELATIVE_UNIT_COUNT][2][StandardPlural::COUNT];</span>
  78 
  79     const UnicodeString&amp; getAbsoluteUnitString(int32_t fStyle,
  80                                                UDateAbsoluteUnit unit,
  81                                                UDateDirection direction) const;
  82     const SimpleFormatter* getRelativeUnitFormatter(int32_t fStyle,
  83                                                     UDateRelativeUnit unit,
  84                                                     int32_t pastFutureIndex,
  85                                                     int32_t pluralUnit) const;
<a name="8" id="anc8"></a>



  86 
  87     const UnicodeString emptyString;
  88 
  89     // Mappping from source to target styles for alias fallback.
  90     int32_t fallBackCache[UDAT_STYLE_COUNT];
  91 
  92     void adoptCombinedDateAndTime(SimpleFormatter *fmtToAdopt) {
  93         delete combinedDateAndTime;
  94         combinedDateAndTime = fmtToAdopt;
  95     }
  96     const SimpleFormatter *getCombinedDateAndTime() const {
  97         return combinedDateAndTime;
  98     }
  99 
 100 private:
 101     SimpleFormatter *combinedDateAndTime;
 102     RelativeDateTimeCacheData(const RelativeDateTimeCacheData &amp;other);
 103     RelativeDateTimeCacheData&amp; operator=(
 104             const RelativeDateTimeCacheData &amp;other);
 105 };
 106 
 107 RelativeDateTimeCacheData::~RelativeDateTimeCacheData() {
 108     // clear out the cache arrays
 109     for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<a name="9" id="anc9"></a><span class="line-modified"> 110         for (int32_t relUnit = 0; relUnit &lt; UDAT_RELATIVE_UNIT_COUNT; ++relUnit) {</span>
 111             for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
 112                 delete relativeUnitsFormatters[style][relUnit][0][pl];
 113                 delete relativeUnitsFormatters[style][relUnit][1][pl];
 114             }
 115         }
 116     }
 117     delete combinedDateAndTime;
 118 }
 119 
 120 
 121 // Use fallback cache for absolute units.
 122 const UnicodeString&amp; RelativeDateTimeCacheData::getAbsoluteUnitString(
 123         int32_t fStyle, UDateAbsoluteUnit unit, UDateDirection direction) const {
 124     int32_t style = fStyle;
 125     do {
 126         if (!absoluteUnits[style][unit][direction].isEmpty()) {
 127             return absoluteUnits[style][unit][direction];
 128         }
 129         style = fallBackCache[style];
 130     } while (style != -1);
 131     return emptyString;
 132 }
 133 
<a name="10" id="anc10"></a><span class="line-removed"> 134  // Use fallback cache for SimpleFormatter relativeUnits.</span>
 135  const SimpleFormatter* RelativeDateTimeCacheData::getRelativeUnitFormatter(
 136         int32_t fStyle,
 137         UDateRelativeUnit unit,
 138         int32_t pastFutureIndex,
 139         int32_t pluralUnit) const {
<a name="11" id="anc11"></a><span class="line-modified"> 140     int32_t style = fStyle;</span>
<span class="line-modified"> 141     do {</span>
<span class="line-modified"> 142         if (relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit] != NULL) {</span>
<span class="line-modified"> 143             return relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit];</span>





























 144         }
<a name="12" id="anc12"></a><span class="line-modified"> 145         style = fallBackCache[style];</span>
<span class="line-modified"> 146     } while (style != -1);</span>
<span class="line-modified"> 147     return NULL;  // No formatter found.</span>
 148  }
 149 
 150 static UBool getStringWithFallback(
 151         const UResourceBundle *resource,
 152         const char *key,
 153         UnicodeString &amp;result,
 154         UErrorCode &amp;status) {
 155     int32_t len = 0;
 156     const UChar *resStr = ures_getStringByKeyWithFallback(
 157         resource, key, &amp;len, &amp;status);
 158     if (U_FAILURE(status)) {
 159         return FALSE;
 160     }
 161     result.setTo(TRUE, resStr, len);
 162     return TRUE;
 163 }
 164 
 165 
 166 static UBool getStringByIndex(
 167         const UResourceBundle *resource,
 168         int32_t idx,
 169         UnicodeString &amp;result,
 170         UErrorCode &amp;status) {
 171     int32_t len = 0;
 172     const UChar *resStr = ures_getStringByIndex(
 173             resource, idx, &amp;len, &amp;status);
 174     if (U_FAILURE(status)) {
 175         return FALSE;
 176     }
 177     result.setTo(TRUE, resStr, len);
 178     return TRUE;
 179 }
 180 
 181 namespace {
 182 
 183 /**
 184  * Sink for enumerating all of the measurement unit display names.
 185  *
 186  * More specific bundles (en_GB) are enumerated before their parents (en_001, en, root):
 187  * Only store a value if it is still missing, that is, it has not been overridden.
 188  */
 189 struct RelDateTimeFmtDataSink : public ResourceSink {
 190 
 191     /**
 192      * Sink for patterns for relative dates and times. For example,
 193      * fields/relative/...
 194      */
 195 
 196     // Generic unit enum for storing Unit info.
 197     typedef enum RelAbsUnit {
 198         INVALID_UNIT = -1,
 199         SECOND,
 200         MINUTE,
 201         HOUR,
 202         DAY,
 203         WEEK,
 204         MONTH,
 205         QUARTER,
 206         YEAR,
 207         SUNDAY,
 208         MONDAY,
 209         TUESDAY,
 210         WEDNESDAY,
 211         THURSDAY,
 212         FRIDAY,
 213         SATURDAY
 214     } RelAbsUnit;
 215 
 216     static int32_t relUnitFromGeneric(RelAbsUnit genUnit) {
 217         // Converts the generic units to UDAT_RELATIVE version.
 218         switch (genUnit) {
 219             case SECOND:
<a name="13" id="anc13"></a><span class="line-modified"> 220                 return UDAT_RELATIVE_SECONDS;</span>
 221             case MINUTE:
<a name="14" id="anc14"></a><span class="line-modified"> 222                 return UDAT_RELATIVE_MINUTES;</span>
 223             case HOUR:
<a name="15" id="anc15"></a><span class="line-modified"> 224                 return UDAT_RELATIVE_HOURS;</span>
 225             case DAY:
<a name="16" id="anc16"></a><span class="line-modified"> 226                 return UDAT_RELATIVE_DAYS;</span>
 227             case WEEK:
<a name="17" id="anc17"></a><span class="line-modified"> 228                 return UDAT_RELATIVE_WEEKS;</span>
 229             case MONTH:
<a name="18" id="anc18"></a><span class="line-modified"> 230                 return UDAT_RELATIVE_MONTHS;</span>
<span class="line-modified"> 231             /*</span>
<span class="line-modified"> 232              * case QUARTER:</span>
<span class="line-removed"> 233              * return UDATE_RELATIVE_QUARTERS;</span>
<span class="line-removed"> 234              */</span>
 235             case YEAR:
<a name="19" id="anc19"></a><span class="line-modified"> 236                 return UDAT_RELATIVE_YEARS;</span>














 237             default:
 238                 return -1;
 239         }
 240     }
 241 
 242     static int32_t absUnitFromGeneric(RelAbsUnit genUnit) {
 243         // Converts the generic units to UDAT_RELATIVE version.
 244         switch (genUnit) {
 245             case DAY:
 246                 return UDAT_ABSOLUTE_DAY;
 247             case WEEK:
 248                 return UDAT_ABSOLUTE_WEEK;
 249             case MONTH:
 250                 return UDAT_ABSOLUTE_MONTH;
<a name="20" id="anc20"></a><span class="line-modified"> 251             /* TODO: Add in QUARTER</span>
<span class="line-modified"> 252              *  case QUARTER:</span>
<span class="line-removed"> 253              * return UDAT_ABSOLUTE_QUARTER;</span>
<span class="line-removed"> 254              */</span>
 255             case YEAR:
 256                 return UDAT_ABSOLUTE_YEAR;
 257             case SUNDAY:
 258                 return UDAT_ABSOLUTE_SUNDAY;
 259             case MONDAY:
 260                 return UDAT_ABSOLUTE_MONDAY;
 261             case TUESDAY:
 262                 return UDAT_ABSOLUTE_TUESDAY;
 263             case WEDNESDAY:
 264                 return UDAT_ABSOLUTE_WEDNESDAY;
 265             case THURSDAY:
 266                 return UDAT_ABSOLUTE_THURSDAY;
 267             case FRIDAY:
 268                 return UDAT_ABSOLUTE_FRIDAY;
 269             case SATURDAY:
 270                 return UDAT_ABSOLUTE_SATURDAY;
 271             default:
 272                 return -1;
 273         }
 274     }
 275 
 276     static int32_t keyToDirection(const char* key) {
 277         if (uprv_strcmp(key, &quot;-2&quot;) == 0) {
 278             return UDAT_DIRECTION_LAST_2;
 279         }
 280         if (uprv_strcmp(key, &quot;-1&quot;) == 0) {
 281             return UDAT_DIRECTION_LAST;
 282         }
 283         if (uprv_strcmp(key, &quot;0&quot;) == 0) {
 284             return UDAT_DIRECTION_THIS;
 285         }
 286         if (uprv_strcmp(key, &quot;1&quot;) == 0) {
 287             return UDAT_DIRECTION_NEXT;
 288         }
 289         if (uprv_strcmp(key, &quot;2&quot;) == 0) {
 290             return UDAT_DIRECTION_NEXT_2;
 291         }
 292         return -1;
 293     }
 294 
 295     // Values kept between levels of parsing the CLDR data.
 296     int32_t pastFutureIndex;  // 0 == past or 1 ==  future
 297     UDateRelativeDateTimeFormatterStyle style;  // {LONG, SHORT, NARROW}
 298     RelAbsUnit genericUnit;
 299 
 300     RelativeDateTimeCacheData &amp;outputData;
 301 
 302     // Constructor
 303     RelDateTimeFmtDataSink(RelativeDateTimeCacheData&amp; cacheData)
 304         : outputData(cacheData) {
 305         // Clear cacheData.fallBackCache
 306         cacheData.fallBackCache[UDAT_STYLE_LONG] = -1;
 307         cacheData.fallBackCache[UDAT_STYLE_SHORT] = -1;
 308         cacheData.fallBackCache[UDAT_STYLE_NARROW] = -1;
 309     }
 310 
 311     ~RelDateTimeFmtDataSink();
 312 
 313     // Utility functions
 314     static UDateRelativeDateTimeFormatterStyle styleFromString(const char *s) {
<a name="21" id="anc21"></a><span class="line-modified"> 315         int32_t len = uprv_strlen(s);</span>
 316         if (len &gt;= 7 &amp;&amp; uprv_strcmp(s + len - 7, &quot;-narrow&quot;) == 0) {
 317             return UDAT_STYLE_NARROW;
 318         }
 319         if (len &gt;= 6 &amp;&amp; uprv_strcmp(s + len - 6, &quot;-short&quot;) == 0) {
 320             return UDAT_STYLE_SHORT;
 321         }
 322         return UDAT_STYLE_LONG;
 323     }
 324 
 325     static int32_t styleSuffixLength(UDateRelativeDateTimeFormatterStyle style) {
 326         switch (style) {
 327             case UDAT_STYLE_NARROW:
 328                 return 7;
 329             case UDAT_STYLE_SHORT:
 330                 return 6;
 331             default:
 332                 return 0;
 333         }
 334     }
 335 
 336     // Utility functions
 337     static UDateRelativeDateTimeFormatterStyle styleFromAliasUnicodeString(UnicodeString s) {
 338         static const UChar narrow[7] = {0x002D, 0x006E, 0x0061, 0x0072, 0x0072, 0x006F, 0x0077};
 339         static const UChar sshort[6] = {0x002D, 0x0073, 0x0068, 0x006F, 0x0072, 0x0074,};
 340         if (s.endsWith(narrow, 7)) {
 341             return UDAT_STYLE_NARROW;
 342         }
 343         if (s.endsWith(sshort, 6)) {
 344             return UDAT_STYLE_SHORT;
 345         }
 346         return UDAT_STYLE_LONG;
 347     }
 348 
 349     static RelAbsUnit unitOrNegativeFromString(const char* keyword, int32_t length) {
 350         // Quick check from string to enum.
 351         switch (length) {
 352             case 3:
 353                 if (uprv_strncmp(keyword, &quot;day&quot;, length) == 0) {
 354                     return DAY;
 355                 } else if (uprv_strncmp(keyword, &quot;sun&quot;, length) == 0) {
 356                     return SUNDAY;
 357                 } else if (uprv_strncmp(keyword, &quot;mon&quot;, length) == 0) {
 358                     return MONDAY;
 359                 } else if (uprv_strncmp(keyword, &quot;tue&quot;, length) == 0) {
 360                     return TUESDAY;
 361                 } else if (uprv_strncmp(keyword, &quot;wed&quot;, length) == 0) {
 362                     return WEDNESDAY;
 363                 } else if (uprv_strncmp(keyword, &quot;thu&quot;, length) == 0) {
 364                     return THURSDAY;
 365                 } else if (uprv_strncmp(keyword, &quot;fri&quot;, length) == 0) {
 366                     return FRIDAY;
 367                 } else if (uprv_strncmp(keyword, &quot;sat&quot;, length) == 0) {
 368                     return SATURDAY;
 369                 }
 370                 break;
 371             case 4:
 372                 if (uprv_strncmp(keyword, &quot;hour&quot;, length) == 0) {
 373                     return HOUR;
 374                 } else if (uprv_strncmp(keyword, &quot;week&quot;, length) == 0) {
 375                     return WEEK;
 376                 } else if (uprv_strncmp(keyword, &quot;year&quot;, length) == 0) {
 377                     return YEAR;
 378                 }
 379                 break;
 380             case 5:
 381                 if (uprv_strncmp(keyword, &quot;month&quot;, length) == 0) {
 382                     return MONTH;
 383                 }
 384                 break;
 385             case 6:
 386                 if (uprv_strncmp(keyword, &quot;minute&quot;, length) == 0) {
 387                     return MINUTE;
 388                 } else if (uprv_strncmp(keyword, &quot;second&quot;, length) == 0) {
 389                     return SECOND;
 390                 }
 391                 break;
 392             case 7:
 393                 if (uprv_strncmp(keyword, &quot;quarter&quot;, length) == 0) {
 394                     return QUARTER;  // TODO: Check @provisional
 395                   }
 396                 break;
 397             default:
 398                 break;
 399         }
 400         return INVALID_UNIT;
 401     }
 402 
 403     void handlePlainDirection(ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 404         // Handle Display Name for PLAIN direction for some units.
 405         if (U_FAILURE(errorCode)) { return; }
 406 
 407         int32_t absUnit = absUnitFromGeneric(genericUnit);
 408         if (absUnit &lt; 0) {
 409           return;  // Not interesting.
 410         }
 411 
 412         // Store displayname if not set.
 413         if (outputData.absoluteUnits[style]
 414             [absUnit][UDAT_DIRECTION_PLAIN].isEmpty()) {
 415             outputData.absoluteUnits[style]
 416                 [absUnit][UDAT_DIRECTION_PLAIN].fastCopyFrom(value.getUnicodeString(errorCode));
 417             return;
 418         }
 419     }
 420 
 421     void consumeTableRelative(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 422         ResourceTable unitTypesTable = value.getTable(errorCode);
 423         if (U_FAILURE(errorCode)) { return; }
 424 
 425         for (int32_t i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 426             if (value.getType() == URES_STRING) {
 427                 int32_t direction = keyToDirection(key);
 428                 if (direction &lt; 0) {
 429                   continue;
 430                 }
 431 
 432                 int32_t relUnitIndex = relUnitFromGeneric(genericUnit);
<a name="22" id="anc22"></a><span class="line-modified"> 433                 if (relUnitIndex == UDAT_RELATIVE_SECONDS &amp;&amp; uprv_strcmp(key, &quot;0&quot;) == 0 &amp;&amp;</span>
 434                     outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW][UDAT_DIRECTION_PLAIN].isEmpty()) {
 435                     // Handle &quot;NOW&quot;
 436                     outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW]
 437                         [UDAT_DIRECTION_PLAIN].fastCopyFrom(value.getUnicodeString(errorCode));
 438                 }
 439 
 440                 int32_t absUnitIndex = absUnitFromGeneric(genericUnit);
 441                 if (absUnitIndex &lt; 0) {
 442                     continue;
 443                 }
 444                 // Only reset if slot is empty.
 445                 if (outputData.absoluteUnits[style][absUnitIndex][direction].isEmpty()) {
 446                     outputData.absoluteUnits[style][absUnitIndex]
 447                         [direction].fastCopyFrom(value.getUnicodeString(errorCode));
 448                 }
 449             }
 450         }
 451     }
 452 
 453     void consumeTimeDetail(int32_t relUnitIndex,
 454                            const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 455         ResourceTable unitTypesTable = value.getTable(errorCode);
 456         if (U_FAILURE(errorCode)) { return; }
 457 
 458           for (int32_t i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 459             if (value.getType() == URES_STRING) {
 460                 int32_t pluralIndex = StandardPlural::indexOrNegativeFromString(key);
 461                 if (pluralIndex &gt;= 0) {
 462                     SimpleFormatter **patterns =
 463                         outputData.relativeUnitsFormatters[style][relUnitIndex]
 464                         [pastFutureIndex];
 465                     // Only set if not already established.
<a name="23" id="anc23"></a><span class="line-modified"> 466                     if (patterns[pluralIndex] == NULL) {</span>
 467                         patterns[pluralIndex] = new SimpleFormatter(
 468                             value.getUnicodeString(errorCode), 0, 1, errorCode);
<a name="24" id="anc24"></a><span class="line-modified"> 469                         if (patterns[pluralIndex] == NULL) {</span>
 470                             errorCode = U_MEMORY_ALLOCATION_ERROR;
 471                         }
 472                     }
 473                 }
 474             }
 475         }
 476     }
 477 
 478     void consumeTableRelativeTime(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 479         ResourceTable relativeTimeTable = value.getTable(errorCode);
 480         if (U_FAILURE(errorCode)) { return; }
 481 
 482         int32_t relUnitIndex = relUnitFromGeneric(genericUnit);
 483         if (relUnitIndex &lt; 0) {
 484             return;
 485         }
 486         for (int32_t i = 0; relativeTimeTable.getKeyAndValue(i, key, value); ++i) {
 487             if (uprv_strcmp(key, &quot;past&quot;) == 0) {
 488                 pastFutureIndex = 0;
 489             } else if (uprv_strcmp(key, &quot;future&quot;) == 0) {
 490                 pastFutureIndex = 1;
 491             } else {
 492                 // Unknown key.
 493                 continue;
 494             }
 495             consumeTimeDetail(relUnitIndex, key, value, errorCode);
 496         }
 497     }
 498 
 499     void consumeAlias(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 500 
 501         UDateRelativeDateTimeFormatterStyle sourceStyle = styleFromString(key);
 502         const UnicodeString valueStr = value.getAliasUnicodeString(errorCode);
 503         if (U_FAILURE(errorCode)) { return; }
 504 
 505         UDateRelativeDateTimeFormatterStyle targetStyle =
 506             styleFromAliasUnicodeString(valueStr);
 507 
 508         if (sourceStyle == targetStyle) {
 509             errorCode = U_INVALID_FORMAT_ERROR;
 510             return;
 511         }
 512         if (outputData.fallBackCache[sourceStyle] != -1 &amp;&amp;
 513             outputData.fallBackCache[sourceStyle] != targetStyle) {
 514             errorCode = U_INVALID_FORMAT_ERROR;
 515             return;
 516         }
 517         outputData.fallBackCache[sourceStyle] = targetStyle;
 518     }
 519 
 520     void consumeTimeUnit(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 521         ResourceTable unitTypesTable = value.getTable(errorCode);
 522         if (U_FAILURE(errorCode)) { return; }
 523 
 524         for (int32_t i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 525             // Handle display name.
 526             if (uprv_strcmp(key, &quot;dn&quot;) == 0 &amp;&amp; value.getType() == URES_STRING) {
 527                 handlePlainDirection(value, errorCode);
 528             }
 529             if (value.getType() == URES_TABLE) {
 530                 if (uprv_strcmp(key, &quot;relative&quot;) == 0) {
 531                     consumeTableRelative(key, value, errorCode);
 532                 } else if (uprv_strcmp(key, &quot;relativeTime&quot;) == 0) {
 533                     consumeTableRelativeTime(key, value, errorCode);
 534                 }
 535             }
 536         }
 537     }
 538 
 539     virtual void put(const char *key, ResourceValue &amp;value,
 540                      UBool /*noFallback*/, UErrorCode &amp;errorCode) {
 541         // Main entry point to sink
 542         ResourceTable table = value.getTable(errorCode);
 543         if (U_FAILURE(errorCode)) { return; }
 544         for (int32_t i = 0; table.getKeyAndValue(i, key, value); ++i) {
 545             if (value.getType() == URES_ALIAS) {
 546                 consumeAlias(key, value, errorCode);
 547             } else {
 548                 style = styleFromString(key);
<a name="25" id="anc25"></a><span class="line-modified"> 549                 int32_t unitSize = uprv_strlen(key) - styleSuffixLength(style);</span>
 550                 genericUnit = unitOrNegativeFromString(key, unitSize);
 551                 if (style &gt;= 0 &amp;&amp; genericUnit != INVALID_UNIT) {
 552                     consumeTimeUnit(key, value, errorCode);
 553                 }
 554             }
 555         }
 556     }
 557 
 558 };
 559 
 560 // Virtual destructors must be defined out of line.
 561 RelDateTimeFmtDataSink::~RelDateTimeFmtDataSink() {}
 562 } // namespace
 563 
 564 static const DateFormatSymbols::DtWidthType styleToDateFormatSymbolWidth[UDAT_STYLE_COUNT] = {
 565   DateFormatSymbols::WIDE, DateFormatSymbols::SHORT, DateFormatSymbols::NARROW
 566 };
 567 
 568 // Get days of weeks from the DateFormatSymbols class.
 569 static void loadWeekdayNames(UnicodeString absoluteUnits[UDAT_STYLE_COUNT]
 570                                  [UDAT_ABSOLUTE_UNIT_COUNT][UDAT_DIRECTION_COUNT],
 571                              const char* localeId,
 572                              UErrorCode&amp; status) {
<a name="26" id="anc26"></a>


 573     Locale locale(localeId);
 574     DateFormatSymbols dfSym(locale, status);
<a name="27" id="anc27"></a>


 575     for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
 576         DateFormatSymbols::DtWidthType dtfmtWidth = styleToDateFormatSymbolWidth[style];
 577         int32_t count;
 578         const UnicodeString* weekdayNames =
 579             dfSym.getWeekdays(count, DateFormatSymbols::STANDALONE, dtfmtWidth);
 580         for (int32_t dayIndex = UDAT_ABSOLUTE_SUNDAY;
 581                 dayIndex &lt;= UDAT_ABSOLUTE_SATURDAY; ++ dayIndex) {
 582             int32_t dateSymbolIndex = (dayIndex - UDAT_ABSOLUTE_SUNDAY) + UCAL_SUNDAY;
 583             absoluteUnits[style][dayIndex][UDAT_DIRECTION_PLAIN].fastCopyFrom(
 584                 weekdayNames[dateSymbolIndex]);
 585         }
 586     }
 587 }
 588 
 589 static UBool loadUnitData(
 590         const UResourceBundle *resource,
 591         RelativeDateTimeCacheData &amp;cacheData,
 592         const char* localeId,
 593         UErrorCode &amp;status) {
 594 
 595     RelDateTimeFmtDataSink sink(cacheData);
 596 
 597     ures_getAllItemsWithFallback(resource, &quot;fields&quot;, sink, status);
<a name="28" id="anc28"></a>


 598 
 599     // Get the weekday names from DateFormatSymbols.
 600     loadWeekdayNames(cacheData.absoluteUnits, localeId, status);
 601     return U_SUCCESS(status);
 602 }
 603 
 604 static UBool getDateTimePattern(
 605         const UResourceBundle *resource,
 606         UnicodeString &amp;result,
 607         UErrorCode &amp;status) {
 608     UnicodeString defaultCalendarName;
 609     if (!getStringWithFallback(
 610             resource,
 611             &quot;calendar/default&quot;,
 612             defaultCalendarName,
 613             status)) {
 614         return FALSE;
 615     }
 616     CharString pathBuffer;
 617     pathBuffer.append(&quot;calendar/&quot;, status)
 618             .appendInvariantChars(defaultCalendarName, status)
 619             .append(&quot;/DateTimePatterns&quot;, status);
 620     LocalUResourceBundlePointer topLevel(
 621             ures_getByKeyWithFallback(
<a name="29" id="anc29"></a><span class="line-modified"> 622                     resource, pathBuffer.data(), NULL, &amp;status));</span>
 623     if (U_FAILURE(status)) {
 624         return FALSE;
 625     }
 626     int32_t size = ures_getSize(topLevel.getAlias());
 627     if (size &lt;= 8) {
 628         // Oops, size is too small to access the index that we want, fallback
 629         // to a hard-coded value.
 630         result = UNICODE_STRING_SIMPLE(&quot;{1} {0}&quot;);
 631         return TRUE;
 632     }
 633     return getStringByIndex(topLevel.getAlias(), 8, result, status);
 634 }
 635 
 636 template&lt;&gt; U_I18N_API
 637 const RelativeDateTimeCacheData *LocaleCacheKey&lt;RelativeDateTimeCacheData&gt;::createObject(const void * /*unused*/, UErrorCode &amp;status) const {
 638     const char *localeId = fLoc.getName();
<a name="30" id="anc30"></a><span class="line-modified"> 639     LocalUResourceBundlePointer topLevel(ures_open(NULL, localeId, &amp;status));</span>
 640     if (U_FAILURE(status)) {
<a name="31" id="anc31"></a><span class="line-modified"> 641         return NULL;</span>
 642     }
 643     LocalPointer&lt;RelativeDateTimeCacheData&gt; result(
 644             new RelativeDateTimeCacheData());
 645     if (result.isNull()) {
 646         status = U_MEMORY_ALLOCATION_ERROR;
<a name="32" id="anc32"></a><span class="line-modified"> 647         return NULL;</span>
 648     }
 649     if (!loadUnitData(
 650             topLevel.getAlias(),
 651             *result,
 652             localeId,
 653             status)) {
<a name="33" id="anc33"></a><span class="line-modified"> 654         return NULL;</span>
 655     }
 656     UnicodeString dateTimePattern;
 657     if (!getDateTimePattern(topLevel.getAlias(), dateTimePattern, status)) {
<a name="34" id="anc34"></a><span class="line-modified"> 658         return NULL;</span>
 659     }
 660     result-&gt;adoptCombinedDateAndTime(
 661             new SimpleFormatter(dateTimePattern, 2, 2, status));
 662     if (U_FAILURE(status)) {
<a name="35" id="anc35"></a><span class="line-modified"> 663         return NULL;</span>
 664     }
 665     result-&gt;addRef();
 666     return result.orphan();
 667 }
 668 
<a name="36" id="anc36"></a>



















 669 RelativeDateTimeFormatter::RelativeDateTimeFormatter(UErrorCode&amp; status) :
<a name="37" id="anc37"></a><span class="line-modified"> 670         fCache(NULL),</span>
<span class="line-modified"> 671         fNumberFormat(NULL),</span>
<span class="line-modified"> 672         fPluralRules(NULL),</span>
 673         fStyle(UDAT_STYLE_LONG),
 674         fContext(UDISPCTX_CAPITALIZATION_NONE),
<a name="38" id="anc38"></a><span class="line-modified"> 675         fOptBreakIterator(NULL) {</span>
<span class="line-modified"> 676     init(NULL, NULL, status);</span>
 677 }
 678 
 679 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 680         const Locale&amp; locale, UErrorCode&amp; status) :
<a name="39" id="anc39"></a><span class="line-modified"> 681         fCache(NULL),</span>
<span class="line-modified"> 682         fNumberFormat(NULL),</span>
<span class="line-modified"> 683         fPluralRules(NULL),</span>
 684         fStyle(UDAT_STYLE_LONG),
 685         fContext(UDISPCTX_CAPITALIZATION_NONE),
<a name="40" id="anc40"></a><span class="line-modified"> 686         fOptBreakIterator(NULL),</span>
 687         fLocale(locale) {
<a name="41" id="anc41"></a><span class="line-modified"> 688     init(NULL, NULL, status);</span>
 689 }
 690 
 691 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 692         const Locale&amp; locale, NumberFormat *nfToAdopt, UErrorCode&amp; status) :
<a name="42" id="anc42"></a><span class="line-modified"> 693         fCache(NULL),</span>
<span class="line-modified"> 694         fNumberFormat(NULL),</span>
<span class="line-modified"> 695         fPluralRules(NULL),</span>
 696         fStyle(UDAT_STYLE_LONG),
 697         fContext(UDISPCTX_CAPITALIZATION_NONE),
<a name="43" id="anc43"></a><span class="line-modified"> 698         fOptBreakIterator(NULL),</span>
 699         fLocale(locale) {
<a name="44" id="anc44"></a><span class="line-modified"> 700     init(nfToAdopt, NULL, status);</span>
 701 }
 702 
 703 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 704         const Locale&amp; locale,
 705         NumberFormat *nfToAdopt,
 706         UDateRelativeDateTimeFormatterStyle styl,
 707         UDisplayContext capitalizationContext,
 708         UErrorCode&amp; status) :
<a name="45" id="anc45"></a><span class="line-modified"> 709         fCache(NULL),</span>
<span class="line-modified"> 710         fNumberFormat(NULL),</span>
<span class="line-modified"> 711         fPluralRules(NULL),</span>
 712         fStyle(styl),
 713         fContext(capitalizationContext),
<a name="46" id="anc46"></a><span class="line-modified"> 714         fOptBreakIterator(NULL),</span>
 715         fLocale(locale) {
 716     if (U_FAILURE(status)) {
 717         return;
 718     }
 719     if ((capitalizationContext &gt;&gt; 8) != UDISPCTX_TYPE_CAPITALIZATION) {
 720         status = U_ILLEGAL_ARGUMENT_ERROR;
 721         return;
 722     }
 723     if (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE) {
 724         BreakIterator *bi = BreakIterator::createSentenceInstance(locale, status);
 725         if (U_FAILURE(status)) {
 726             return;
 727         }
 728         init(nfToAdopt, bi, status);
 729     } else {
<a name="47" id="anc47"></a><span class="line-modified"> 730         init(nfToAdopt, NULL, status);</span>
 731     }
 732 }
 733 
 734 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 735         const RelativeDateTimeFormatter&amp; other)
 736         : UObject(other),
 737           fCache(other.fCache),
 738           fNumberFormat(other.fNumberFormat),
 739           fPluralRules(other.fPluralRules),
 740           fStyle(other.fStyle),
 741           fContext(other.fContext),
 742           fOptBreakIterator(other.fOptBreakIterator),
 743           fLocale(other.fLocale) {
 744     fCache-&gt;addRef();
 745     fNumberFormat-&gt;addRef();
 746     fPluralRules-&gt;addRef();
<a name="48" id="anc48"></a><span class="line-modified"> 747     if (fOptBreakIterator != NULL) {</span>
 748       fOptBreakIterator-&gt;addRef();
 749     }
 750 }
 751 
 752 RelativeDateTimeFormatter&amp; RelativeDateTimeFormatter::operator=(
 753         const RelativeDateTimeFormatter&amp; other) {
 754     if (this != &amp;other) {
 755         SharedObject::copyPtr(other.fCache, fCache);
 756         SharedObject::copyPtr(other.fNumberFormat, fNumberFormat);
 757         SharedObject::copyPtr(other.fPluralRules, fPluralRules);
 758         SharedObject::copyPtr(other.fOptBreakIterator, fOptBreakIterator);
 759         fStyle = other.fStyle;
 760         fContext = other.fContext;
 761         fLocale = other.fLocale;
 762     }
 763     return *this;
 764 }
 765 
 766 RelativeDateTimeFormatter::~RelativeDateTimeFormatter() {
<a name="49" id="anc49"></a><span class="line-modified"> 767     if (fCache != NULL) {</span>
 768         fCache-&gt;removeRef();
 769     }
<a name="50" id="anc50"></a><span class="line-modified"> 770     if (fNumberFormat != NULL) {</span>
 771         fNumberFormat-&gt;removeRef();
 772     }
<a name="51" id="anc51"></a><span class="line-modified"> 773     if (fPluralRules != NULL) {</span>
 774         fPluralRules-&gt;removeRef();
 775     }
<a name="52" id="anc52"></a><span class="line-modified"> 776     if (fOptBreakIterator != NULL) {</span>
 777         fOptBreakIterator-&gt;removeRef();
 778     }
 779 }
 780 
 781 const NumberFormat&amp; RelativeDateTimeFormatter::getNumberFormat() const {
 782     return **fNumberFormat;
 783 }
 784 
 785 UDisplayContext RelativeDateTimeFormatter::getCapitalizationContext() const {
 786     return fContext;
 787 }
 788 
 789 UDateRelativeDateTimeFormatterStyle RelativeDateTimeFormatter::getFormatStyle() const {
 790     return fStyle;
 791 }
 792 
<a name="53" id="anc53"></a><span class="line-modified"> 793 UnicodeString&amp; RelativeDateTimeFormatter::format(</span>
<span class="line-modified"> 794         double quantity, UDateDirection direction, UDateRelativeUnit unit,</span>
<span class="line-modified"> 795         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>









 796     if (U_FAILURE(status)) {
 797         return appendTo;
 798     }
<a name="54" id="anc54"></a>


























































 799     if (direction != UDAT_DIRECTION_LAST &amp;&amp; direction != UDAT_DIRECTION_NEXT) {
 800         status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="55" id="anc55"></a><span class="line-modified"> 801         return appendTo;</span>
 802     }
 803     int32_t bFuture = direction == UDAT_DIRECTION_NEXT ? 1 : 0;
<a name="56" id="anc56"></a><span class="line-removed"> 804     FieldPosition pos(FieldPosition::DONT_CARE);</span>
<span class="line-removed"> 805 </span>
<span class="line-removed"> 806     UnicodeString result;</span>
<span class="line-removed"> 807     UnicodeString formattedNumber;</span>
 808 
<a name="57" id="anc57"></a><span class="line-modified"> 809     StandardPlural::Form pluralIndex = QuantityFormatter::selectPlural(</span>
<span class="line-modified"> 810         quantity, **fNumberFormat, **fPluralRules, formattedNumber, pos,</span>





 811         status);
<a name="58" id="anc58"></a>


 812 
 813     const SimpleFormatter* formatter =
<a name="59" id="anc59"></a><span class="line-modified"> 814         fCache-&gt;getRelativeUnitFormatter(fStyle, unit, bFuture, pluralIndex);</span>
<span class="line-modified"> 815     if (formatter == NULL) {</span>
 816         // TODO: WARN - look at quantity formatter&#39;s action with an error.
 817         status = U_INVALID_FORMAT_ERROR;
<a name="60" id="anc60"></a><span class="line-modified"> 818         return appendTo;</span>
 819     }
<a name="61" id="anc61"></a><span class="line-modified"> 820     formatter-&gt;format(formattedNumber, result, status);</span>
<span class="line-modified"> 821     adjustForContext(result);</span>
<span class="line-modified"> 822     return appendTo.append(result);</span>

 823 }
 824 
 825 UnicodeString&amp; RelativeDateTimeFormatter::formatNumeric(
<a name="62" id="anc62"></a><span class="line-modified"> 826         double offset, URelativeDateTimeUnit unit,</span>
<span class="line-modified"> 827         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>


























 828     if (U_FAILURE(status)) {
<a name="63" id="anc63"></a><span class="line-modified"> 829         return appendTo;</span>
<span class="line-removed"> 830     }</span>
<span class="line-removed"> 831     // TODO:</span>
<span class="line-removed"> 832     // The full implementation of this depends on CLDR data that is not yet available,</span>
<span class="line-removed"> 833     // see: http://unicode.org/cldr/trac/ticket/9165 Add more relative field data.</span>
<span class="line-removed"> 834     // In the meantime do a quick bring-up by calling the old format method; this</span>
<span class="line-removed"> 835     // leaves some holes (even for data that is currently available, such as quarter).</span>
<span class="line-removed"> 836     // When the new CLDR data is available, update the data storage accordingly,</span>
<span class="line-removed"> 837     // rewrite this to use it directly, and rewrite the old format method to call this</span>
<span class="line-removed"> 838     // new one; that is covered by http://bugs.icu-project.org/trac/ticket/12171.</span>
<span class="line-removed"> 839     UDateRelativeUnit relunit = UDAT_RELATIVE_UNIT_COUNT;</span>
<span class="line-removed"> 840     switch (unit) {</span>
<span class="line-removed"> 841         case UDAT_REL_UNIT_YEAR:    relunit = UDAT_RELATIVE_YEARS; break;</span>
<span class="line-removed"> 842         case UDAT_REL_UNIT_MONTH:   relunit = UDAT_RELATIVE_MONTHS; break;</span>
<span class="line-removed"> 843         case UDAT_REL_UNIT_WEEK:    relunit = UDAT_RELATIVE_WEEKS; break;</span>
<span class="line-removed"> 844         case UDAT_REL_UNIT_DAY:     relunit = UDAT_RELATIVE_DAYS; break;</span>
<span class="line-removed"> 845         case UDAT_REL_UNIT_HOUR:    relunit = UDAT_RELATIVE_HOURS; break;</span>
<span class="line-removed"> 846         case UDAT_REL_UNIT_MINUTE:  relunit = UDAT_RELATIVE_MINUTES; break;</span>
<span class="line-removed"> 847         case UDAT_REL_UNIT_SECOND:  relunit = UDAT_RELATIVE_SECONDS; break;</span>
<span class="line-removed"> 848         default: // a unit that the above method does not handle</span>
<span class="line-removed"> 849             status = U_UNSUPPORTED_ERROR;</span>
<span class="line-removed"> 850             return appendTo;</span>
 851     }
 852     UDateDirection direction = UDAT_DIRECTION_NEXT;
 853     if (std::signbit(offset)) { // needed to handle -0.0
 854         direction = UDAT_DIRECTION_LAST;
 855         offset = -offset;
 856     }
<a name="64" id="anc64"></a><span class="line-modified"> 857     return format(offset, direction, relunit, appendTo, status);</span>




























 858 }
 859 
 860 UnicodeString&amp; RelativeDateTimeFormatter::format(
<a name="65" id="anc65"></a><span class="line-modified"> 861         UDateDirection direction, UDateAbsoluteUnit unit,</span>
<span class="line-modified"> 862         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>


























 863     if (U_FAILURE(status)) {
<a name="66" id="anc66"></a><span class="line-modified"> 864         return appendTo;</span>
 865     }
 866     if (unit == UDAT_ABSOLUTE_NOW &amp;&amp; direction != UDAT_DIRECTION_PLAIN) {
 867         status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="67" id="anc67"></a><span class="line-modified"> 868         return appendTo;</span>
 869     }
 870 
 871     // Get string using fallback.
<a name="68" id="anc68"></a><span class="line-modified"> 872     UnicodeString result;</span>
<span class="line-modified"> 873     result.fastCopyFrom(fCache-&gt;getAbsoluteUnitString(fStyle, unit, direction));</span>
<span class="line-modified"> 874     if (fOptBreakIterator != NULL) {</span>
<span class="line-modified"> 875         adjustForContext(result);</span>
<span class="line-removed"> 876     }</span>
<span class="line-removed"> 877     return appendTo.append(result);</span>
 878 }
 879 
 880 UnicodeString&amp; RelativeDateTimeFormatter::format(
<a name="69" id="anc69"></a><span class="line-modified"> 881         double offset, URelativeDateTimeUnit unit,</span>
<span class="line-modified"> 882         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>


























 883     if (U_FAILURE(status)) {
<a name="70" id="anc70"></a><span class="line-modified"> 884         return appendTo;</span>
 885     }
 886     // TODO:
 887     // The full implementation of this depends on CLDR data that is not yet available,
 888     // see: http://unicode.org/cldr/trac/ticket/9165 Add more relative field data.
 889     // In the meantime do a quick bring-up by calling the old format method; this
 890     // leaves some holes (even for data that is currently available, such as quarter).
 891     // When the new CLDR data is available, update the data storage accordingly,
 892     // rewrite this to use it directly, and rewrite the old format method to call this
 893     // new one; that is covered by http://bugs.icu-project.org/trac/ticket/12171.
 894     UDateDirection direction = UDAT_DIRECTION_COUNT;
 895     if (offset &gt; -2.1 &amp;&amp; offset &lt; 2.1) {
 896         // Allow a 1% epsilon, so offsets in -1.01..-0.99 map to LAST
 897         double offsetx100 = offset * 100.0;
 898         int32_t intoffset = (offsetx100 &lt; 0)? (int32_t)(offsetx100-0.5) : (int32_t)(offsetx100+0.5);
 899         switch (intoffset) {
 900             case -200/*-2*/: direction = UDAT_DIRECTION_LAST_2; break;
 901             case -100/*-1*/: direction = UDAT_DIRECTION_LAST; break;
 902             case    0/* 0*/: direction = UDAT_DIRECTION_THIS; break;
 903             case  100/* 1*/: direction = UDAT_DIRECTION_NEXT; break;
 904             case  200/* 2*/: direction = UDAT_DIRECTION_NEXT_2; break;
 905             default: break;
 906         }
 907     }
 908     UDateAbsoluteUnit absunit = UDAT_ABSOLUTE_UNIT_COUNT;
 909     switch (unit) {
 910         case UDAT_REL_UNIT_YEAR:    absunit = UDAT_ABSOLUTE_YEAR; break;
<a name="71" id="anc71"></a>
 911         case UDAT_REL_UNIT_MONTH:   absunit = UDAT_ABSOLUTE_MONTH; break;
 912         case UDAT_REL_UNIT_WEEK:    absunit = UDAT_ABSOLUTE_WEEK; break;
 913         case UDAT_REL_UNIT_DAY:     absunit = UDAT_ABSOLUTE_DAY; break;
 914         case UDAT_REL_UNIT_SECOND:
 915             if (direction == UDAT_DIRECTION_THIS) {
 916                 absunit = UDAT_ABSOLUTE_NOW;
 917                 direction = UDAT_DIRECTION_PLAIN;
 918             }
 919             break;
 920         case UDAT_REL_UNIT_SUNDAY:  absunit = UDAT_ABSOLUTE_SUNDAY; break;
 921         case UDAT_REL_UNIT_MONDAY:  absunit = UDAT_ABSOLUTE_MONDAY; break;
 922         case UDAT_REL_UNIT_TUESDAY:  absunit = UDAT_ABSOLUTE_TUESDAY; break;
 923         case UDAT_REL_UNIT_WEDNESDAY:  absunit = UDAT_ABSOLUTE_WEDNESDAY; break;
 924         case UDAT_REL_UNIT_THURSDAY:  absunit = UDAT_ABSOLUTE_THURSDAY; break;
 925         case UDAT_REL_UNIT_FRIDAY:  absunit = UDAT_ABSOLUTE_FRIDAY; break;
 926         case UDAT_REL_UNIT_SATURDAY:  absunit = UDAT_ABSOLUTE_SATURDAY; break;
 927         default: break;
 928     }
 929     if (direction != UDAT_DIRECTION_COUNT &amp;&amp; absunit != UDAT_ABSOLUTE_UNIT_COUNT) {
<a name="72" id="anc72"></a><span class="line-modified"> 930         const UnicodeString &amp;unitFormatString =</span>
<span class="line-modified"> 931             fCache-&gt;getAbsoluteUnitString(fStyle, absunit, direction);</span>
<span class="line-modified"> 932         if (!unitFormatString.isEmpty()) {</span>
<span class="line-removed"> 933             if (fOptBreakIterator != NULL) {</span>
<span class="line-removed"> 934                 UnicodeString result(unitFormatString);</span>
<span class="line-removed"> 935                 adjustForContext(result);</span>
<span class="line-removed"> 936                 return appendTo.append(result);</span>
<span class="line-removed"> 937             } else {</span>
<span class="line-removed"> 938                 return appendTo.append(unitFormatString);</span>
<span class="line-removed"> 939             }</span>
 940         }
 941     }
 942     // otherwise fallback to formatNumeric
<a name="73" id="anc73"></a><span class="line-modified"> 943     return formatNumeric(offset, unit, appendTo, status);</span>
 944 }
 945 
 946 UnicodeString&amp; RelativeDateTimeFormatter::combineDateAndTime(
 947         const UnicodeString&amp; relativeDateString, const UnicodeString&amp; timeString,
 948         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {
 949     return fCache-&gt;getCombinedDateAndTime()-&gt;format(
 950             timeString, relativeDateString, appendTo, status);
 951 }
 952 
<a name="74" id="anc74"></a><span class="line-modified"> 953 void RelativeDateTimeFormatter::adjustForContext(UnicodeString &amp;str) const {</span>
<span class="line-modified"> 954     if (fOptBreakIterator == NULL</span>
 955         || str.length() == 0 || !u_islower(str.char32At(0))) {
<a name="75" id="anc75"></a><span class="line-modified"> 956         return;</span>
 957     }
 958 
 959     // Must guarantee that one thread at a time accesses the shared break
 960     // iterator.
<a name="76" id="anc76"></a>
 961     Mutex lock(&amp;gBrkIterMutex);
 962     str.toTitle(
 963             fOptBreakIterator-&gt;get(),
 964             fLocale,
 965             U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
<a name="77" id="anc77"></a>










 966 }
 967 
 968 void RelativeDateTimeFormatter::init(
 969         NumberFormat *nfToAdopt,
 970         BreakIterator *biToAdopt,
 971         UErrorCode &amp;status) {
 972     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
 973     LocalPointer&lt;BreakIterator&gt; bi(biToAdopt);
 974     UnifiedCache::getByLocale(fLocale, fCache, status);
 975     if (U_FAILURE(status)) {
 976         return;
 977     }
 978     const SharedPluralRules *pr = PluralRules::createSharedInstance(
 979             fLocale, UPLURAL_TYPE_CARDINAL, status);
 980     if (U_FAILURE(status)) {
 981         return;
 982     }
 983     SharedObject::copyPtr(pr, fPluralRules);
 984     pr-&gt;removeRef();
 985     if (nf.isNull()) {
 986        const SharedNumberFormat *shared = NumberFormat::createSharedInstance(
 987                fLocale, UNUM_DECIMAL, status);
 988         if (U_FAILURE(status)) {
 989             return;
 990         }
 991         SharedObject::copyPtr(shared, fNumberFormat);
 992         shared-&gt;removeRef();
 993     } else {
 994         SharedNumberFormat *shared = new SharedNumberFormat(nf.getAlias());
<a name="78" id="anc78"></a><span class="line-modified"> 995         if (shared == NULL) {</span>
 996             status = U_MEMORY_ALLOCATION_ERROR;
 997             return;
 998         }
 999         nf.orphan();
1000         SharedObject::copyPtr(shared, fNumberFormat);
1001     }
1002     if (bi.isNull()) {
1003         SharedObject::clearPtr(fOptBreakIterator);
1004     } else {
1005         SharedBreakIterator *shared = new SharedBreakIterator(bi.getAlias());
<a name="79" id="anc79"></a><span class="line-modified">1006         if (shared == NULL) {</span>
1007             status = U_MEMORY_ALLOCATION_ERROR;
1008             return;
1009         }
1010         bi.orphan();
1011         SharedObject::copyPtr(shared, fOptBreakIterator);
1012     }
1013 }
1014 
1015 U_NAMESPACE_END
1016 
1017 // Plain C API
1018 
1019 U_NAMESPACE_USE
1020 
<a name="80" id="anc80"></a>










1021 U_CAPI URelativeDateTimeFormatter* U_EXPORT2
1022 ureldatefmt_open( const char*          locale,
1023                   UNumberFormat*       nfToAdopt,
1024                   UDateRelativeDateTimeFormatterStyle width,
1025                   UDisplayContext      capitalizationContext,
1026                   UErrorCode*          status )
1027 {
1028     if (U_FAILURE(*status)) {
<a name="81" id="anc81"></a><span class="line-modified">1029         return NULL;</span>
1030     }
1031     LocalPointer&lt;RelativeDateTimeFormatter&gt; formatter(new RelativeDateTimeFormatter(Locale(locale),
1032                                                               (NumberFormat*)nfToAdopt, width,
1033                                                               capitalizationContext, *status), *status);
1034     if (U_FAILURE(*status)) {
<a name="82" id="anc82"></a><span class="line-modified">1035         return NULL;</span>
1036     }
1037     return (URelativeDateTimeFormatter*)formatter.orphan();
1038 }
1039 
1040 U_CAPI void U_EXPORT2
1041 ureldatefmt_close(URelativeDateTimeFormatter *reldatefmt)
1042 {
1043     delete (RelativeDateTimeFormatter*)reldatefmt;
1044 }
1045 
1046 U_CAPI int32_t U_EXPORT2
1047 ureldatefmt_formatNumeric( const URelativeDateTimeFormatter* reldatefmt,
1048                     double                offset,
1049                     URelativeDateTimeUnit unit,
1050                     UChar*                result,
1051                     int32_t               resultCapacity,
1052                     UErrorCode*           status)
1053 {
1054     if (U_FAILURE(*status)) {
1055         return 0;
1056     }
<a name="83" id="anc83"></a><span class="line-modified">1057     if (result == NULL ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
1058         *status = U_ILLEGAL_ARGUMENT_ERROR;
1059         return 0;
1060     }
1061     UnicodeString res;
<a name="84" id="anc84"></a><span class="line-modified">1062     if (result != NULL) {</span>
<span class="line-modified">1063         // NULL destination for pure preflighting: empty dummy string</span>
1064         // otherwise, alias the destination buffer (copied from udat_format)
1065         res.setTo(result, 0, resultCapacity);
1066     }
1067     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;formatNumeric(offset, unit, res, *status);
1068     if (U_FAILURE(*status)) {
1069         return 0;
1070     }
1071     return res.extract(result, resultCapacity, *status);
1072 }
1073 
<a name="85" id="anc85"></a>














1074 U_CAPI int32_t U_EXPORT2
1075 ureldatefmt_format( const URelativeDateTimeFormatter* reldatefmt,
1076                     double                offset,
1077                     URelativeDateTimeUnit unit,
1078                     UChar*                result,
1079                     int32_t               resultCapacity,
1080                     UErrorCode*           status)
1081 {
1082     if (U_FAILURE(*status)) {
1083         return 0;
1084     }
<a name="86" id="anc86"></a><span class="line-modified">1085     if (result == NULL ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
1086         *status = U_ILLEGAL_ARGUMENT_ERROR;
1087         return 0;
1088     }
1089     UnicodeString res;
<a name="87" id="anc87"></a><span class="line-modified">1090     if (result != NULL) {</span>
<span class="line-modified">1091         // NULL destination for pure preflighting: empty dummy string</span>
1092         // otherwise, alias the destination buffer (copied from udat_format)
1093         res.setTo(result, 0, resultCapacity);
1094     }
1095     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;format(offset, unit, res, *status);
1096     if (U_FAILURE(*status)) {
1097         return 0;
1098     }
1099     return res.extract(result, resultCapacity, *status);
1100 }
1101 
<a name="88" id="anc88"></a>














1102 U_CAPI int32_t U_EXPORT2
1103 ureldatefmt_combineDateAndTime( const URelativeDateTimeFormatter* reldatefmt,
1104                     const UChar *     relativeDateString,
1105                     int32_t           relativeDateStringLen,
1106                     const UChar *     timeString,
1107                     int32_t           timeStringLen,
1108                     UChar*            result,
1109                     int32_t           resultCapacity,
1110                     UErrorCode*       status )
1111 {
1112     if (U_FAILURE(*status)) {
1113         return 0;
1114     }
<a name="89" id="anc89"></a><span class="line-modified">1115     if (result == NULL ? resultCapacity != 0 : resultCapacity &lt; 0 ||</span>
<span class="line-modified">1116             (relativeDateString == NULL ? relativeDateStringLen != 0 : relativeDateStringLen &lt; -1) ||</span>
<span class="line-modified">1117             (timeString == NULL ? timeStringLen != 0 : timeStringLen &lt; -1)) {</span>
1118         *status = U_ILLEGAL_ARGUMENT_ERROR;
1119         return 0;
1120     }
1121     UnicodeString relDateStr((UBool)(relativeDateStringLen == -1), relativeDateString, relativeDateStringLen);
1122     UnicodeString timeStr((UBool)(timeStringLen == -1), timeString, timeStringLen);
1123     UnicodeString res(result, 0, resultCapacity);
1124     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;combineDateAndTime(relDateStr, timeStr, res, *status);
1125     if (U_FAILURE(*status)) {
1126         return 0;
1127     }
1128     return res.extract(result, resultCapacity, *status);
1129 }
1130 
1131 #endif /* !UCONFIG_NO_FORMATTING */
<a name="90" id="anc90"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="90" type="hidden" />
</body>
</html>