<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/msgfmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="measunit.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="nounit.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/msgfmt.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  52  * with optional arguments (variables/placeholders).
  53  * The arguments can occur in any order, which is necessary for translation
  54  * into languages with different grammars.
  55  *
  56  * &lt;p&gt;A MessageFormat is constructed from a &lt;em&gt;pattern&lt;/em&gt; string
  57  * with arguments in {curly braces} which will be replaced by formatted values.
  58  *
  59  * &lt;p&gt;&lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
  60  * classes in that you create a &lt;code&gt;MessageFormat&lt;/code&gt; object with one
  61  * of its constructors (not with a &lt;code&gt;createInstance&lt;/code&gt; style factory
  62  * method). Factory methods aren&#39;t necessary because &lt;code&gt;MessageFormat&lt;/code&gt;
  63  * itself doesn&#39;t implement locale-specific behavior. Any locale-specific
  64  * behavior is defined by the pattern that you provide and the
  65  * subformats used for inserted arguments.
  66  *
  67  * &lt;p&gt;Arguments can be named (using identifiers) or numbered (using small ASCII-digit integers).
  68  * Some of the API methods work only with argument numbers and throw an exception
  69  * if the pattern has named arguments (see {@link #usesNamedArguments()}).
  70  *
  71  * &lt;p&gt;An argument might not specify any format type. In this case,
<span class="line-modified">  72  * a Number value is formatted with a default (for the locale) NumberFormat,</span>
<span class="line-modified">  73  * a Date value is formatted with a default (for the locale) DateFormat,</span>
<span class="line-removed">  74  * and for any other value its toString() value is used.</span>
  75  *
  76  * &lt;p&gt;An argument might specify a &quot;simple&quot; type for which the specified
  77  * Format object is created, cached and used.
  78  *
  79  * &lt;p&gt;An argument might have a &quot;complex&quot; type with nested MessageFormat sub-patterns.
  80  * During formatting, one of these sub-messages is selected according to the argument value
  81  * and recursively formatted.
  82  *
  83  * &lt;p&gt;After construction, a custom Format object can be set for
  84  * a top-level argument, overriding the default formatting and parsing behavior
  85  * for that argument.
  86  * However, custom formatting can be achieved more simply by writing
  87  * a typeless argument in the pattern string
  88  * and supplying it with a preformatted string value.
  89  *
  90  * &lt;p&gt;When formatting, MessageFormat takes a collection of argument values
  91  * and writes an output string.
  92  * The argument values may be passed as an array
  93  * (when the pattern contains only numbered arguments)
  94  * or as an array of names and and an array of arguments (which works for both named
</pre>
<hr />
<pre>
 107  * message = messageText (argument messageText)*
 108  * argument = noneArg | simpleArg | complexArg
 109  * complexArg = choiceArg | pluralArg | selectArg | selectordinalArg
 110  *
 111  * noneArg = &#39;{&#39; argNameOrNumber &#39;}&#39;
 112  * simpleArg = &#39;{&#39; argNameOrNumber &#39;,&#39; argType [&#39;,&#39; argStyle] &#39;}&#39;
 113  * choiceArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;choice&quot; &#39;,&#39; choiceStyle &#39;}&#39;
 114  * pluralArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;plural&quot; &#39;,&#39; pluralStyle &#39;}&#39;
 115  * selectArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;select&quot; &#39;,&#39; selectStyle &#39;}&#39;
 116  * selectordinalArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;selectordinal&quot; &#39;,&#39; pluralStyle &#39;}&#39;
 117  *
 118  * choiceStyle: see {@link ChoiceFormat}
 119  * pluralStyle: see {@link PluralFormat}
 120  * selectStyle: see {@link SelectFormat}
 121  *
 122  * argNameOrNumber = argName | argNumber
 123  * argName = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+
 124  * argNumber = &#39;0&#39; | (&#39;1&#39;..&#39;9&#39; (&#39;0&#39;..&#39;9&#39;)*)
 125  *
 126  * argType = &quot;number&quot; | &quot;date&quot; | &quot;time&quot; | &quot;spellout&quot; | &quot;ordinal&quot; | &quot;duration&quot;
<span class="line-modified"> 127  * argStyle = &quot;short&quot; | &quot;medium&quot; | &quot;long&quot; | &quot;full&quot; | &quot;integer&quot; | &quot;currency&quot; | &quot;percent&quot; | argStyleText</span>
 128  * &lt;/pre&gt;
 129  *
 130  * &lt;ul&gt;
 131  *   &lt;li&gt;messageText can contain quoted literal strings including syntax characters.
 132  *       A quoted literal string begins with an ASCII apostrophe and a syntax character
 133  *       (usually a {curly brace}) and continues until the next single apostrophe.
 134  *       A double ASCII apostrohpe inside or outside of a quoted string represents
 135  *       one literal apostrophe.
 136  *   &lt;li&gt;Quotable syntax characters are the {curly braces} in all messageText parts,
 137  *       plus the &#39;#&#39; sign in a messageText immediately inside a pluralStyle,
 138  *       and the &#39;|&#39; symbol in a messageText immediately inside a choiceStyle.
 139  *   &lt;li&gt;See also {@link #UMessagePatternApostropheMode}
 140  *   &lt;li&gt;In argStyleText, every single ASCII apostrophe begins and ends quoted literal text,
 141  *       and unquoted {curly braces} must occur in matched pairs.
 142  * &lt;/ul&gt;
 143  *
 144  * &lt;p&gt;Recommendation: Use the real apostrophe (single quote) character
 145  * \htmlonly&amp;#x2019;\endhtmlonly (U+2019) for
 146  * human-readable text, and use the ASCII apostrophe &#39; (U+0027)
 147  * only in program syntax, like quoting in MessageFormat.
</pre>
<hr />
<pre>
 149  *
 150  * &lt;p&gt;The &lt;code&gt;choice&lt;/code&gt; argument type is deprecated.
 151  * Use &lt;code&gt;plural&lt;/code&gt; arguments for proper plural selection,
 152  * and &lt;code&gt;select&lt;/code&gt; arguments for simple selection among a fixed set of choices.
 153  *
 154  * &lt;p&gt;The &lt;code&gt;argType&lt;/code&gt; and &lt;code&gt;argStyle&lt;/code&gt; values are used to create
 155  * a &lt;code&gt;Format&lt;/code&gt; instance for the format element. The following
 156  * table shows how the values map to Format instances. Combinations not
 157  * shown in the table are illegal. Any &lt;code&gt;argStyleText&lt;/code&gt; must
 158  * be a valid pattern string for the Format subclass used.
 159  *
 160  * &lt;p&gt;&lt;table border=1&gt;
 161  *    &lt;tr&gt;
 162  *       &lt;th&gt;argType
 163  *       &lt;th&gt;argStyle
 164  *       &lt;th&gt;resulting Format object
 165  *    &lt;tr&gt;
 166  *       &lt;td colspan=2&gt;&lt;i&gt;(none)&lt;/i&gt;
 167  *       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
 168  *    &lt;tr&gt;
<span class="line-modified"> 169  *       &lt;td rowspan=5&gt;&lt;code&gt;number&lt;/code&gt;</span>
 170  *       &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;
 171  *       &lt;td&gt;&lt;code&gt;NumberFormat.createInstance(getLocale(), status)&lt;/code&gt;
 172  *    &lt;tr&gt;
 173  *       &lt;td&gt;&lt;code&gt;integer&lt;/code&gt;
 174  *       &lt;td&gt;&lt;code&gt;NumberFormat.createInstance(getLocale(), kNumberStyle, status)&lt;/code&gt;
 175  *    &lt;tr&gt;
 176  *       &lt;td&gt;&lt;code&gt;currency&lt;/code&gt;
 177  *       &lt;td&gt;&lt;code&gt;NumberFormat.createCurrencyInstance(getLocale(), status)&lt;/code&gt;
 178  *    &lt;tr&gt;
 179  *       &lt;td&gt;&lt;code&gt;percent&lt;/code&gt;
 180  *       &lt;td&gt;&lt;code&gt;NumberFormat.createPercentInstance(getLocale(), status)&lt;/code&gt;
 181  *    &lt;tr&gt;
 182  *       &lt;td&gt;&lt;i&gt;argStyleText&lt;/i&gt;
 183  *       &lt;td&gt;&lt;code&gt;new DecimalFormat(argStyleText, new DecimalFormatSymbols(getLocale(), status), status)&lt;/code&gt;
 184  *    &lt;tr&gt;



 185  *       &lt;td rowspan=6&gt;&lt;code&gt;date&lt;/code&gt;
 186  *       &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;
 187  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kDefault, getLocale(), status)&lt;/code&gt;
 188  *    &lt;tr&gt;
 189  *       &lt;td&gt;&lt;code&gt;short&lt;/code&gt;
 190  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kShort, getLocale(), status)&lt;/code&gt;
 191  *    &lt;tr&gt;
 192  *       &lt;td&gt;&lt;code&gt;medium&lt;/code&gt;
 193  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kDefault, getLocale(), status)&lt;/code&gt;
 194  *    &lt;tr&gt;
 195  *       &lt;td&gt;&lt;code&gt;long&lt;/code&gt;
 196  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kLong, getLocale(), status)&lt;/code&gt;
 197  *    &lt;tr&gt;
 198  *       &lt;td&gt;&lt;code&gt;full&lt;/code&gt;
 199  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kFull, getLocale(), status)&lt;/code&gt;
 200  *    &lt;tr&gt;
 201  *       &lt;td&gt;&lt;i&gt;argStyleText&lt;/i&gt;
<span class="line-modified"> 202  *       &lt;td&gt;&lt;code&gt;new SimpleDateFormat(argStyleText, getLocale(), status)</span>



 203  *    &lt;tr&gt;
 204  *       &lt;td rowspan=6&gt;&lt;code&gt;time&lt;/code&gt;
 205  *       &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;
 206  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kDefault, getLocale(), status)&lt;/code&gt;
 207  *    &lt;tr&gt;
 208  *       &lt;td&gt;&lt;code&gt;short&lt;/code&gt;
 209  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kShort, getLocale(), status)&lt;/code&gt;
 210  *    &lt;tr&gt;
 211  *       &lt;td&gt;&lt;code&gt;medium&lt;/code&gt;
 212  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kDefault, getLocale(), status)&lt;/code&gt;
 213  *    &lt;tr&gt;
 214  *       &lt;td&gt;&lt;code&gt;long&lt;/code&gt;
 215  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kLong, getLocale(), status)&lt;/code&gt;
 216  *    &lt;tr&gt;
 217  *       &lt;td&gt;&lt;code&gt;full&lt;/code&gt;
 218  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kFull, getLocale(), status)&lt;/code&gt;
 219  *    &lt;tr&gt;
 220  *       &lt;td&gt;&lt;i&gt;argStyleText&lt;/i&gt;
<span class="line-modified"> 221  *       &lt;td&gt;&lt;code&gt;new SimpleDateFormat(argStyleText, getLocale(), status)</span>
 222  *    &lt;tr&gt;
 223  *       &lt;td&gt;&lt;code&gt;spellout&lt;/code&gt;
 224  *       &lt;td&gt;&lt;i&gt;argStyleText (optional)&lt;/i&gt;
 225  *       &lt;td&gt;&lt;code&gt;new RuleBasedNumberFormat(URBNF_SPELLOUT, getLocale(), status)
 226  *           &lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.setDefaultRuleset(argStyleText, status);&lt;/code&gt;
 227  *    &lt;tr&gt;
 228  *       &lt;td&gt;&lt;code&gt;ordinal&lt;/code&gt;
 229  *       &lt;td&gt;&lt;i&gt;argStyleText (optional)&lt;/i&gt;
 230  *       &lt;td&gt;&lt;code&gt;new RuleBasedNumberFormat(URBNF_ORDINAL, getLocale(), status)
 231  *           &lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.setDefaultRuleset(argStyleText, status);&lt;/code&gt;
 232  *    &lt;tr&gt;
 233  *       &lt;td&gt;&lt;code&gt;duration&lt;/code&gt;
 234  *       &lt;td&gt;&lt;i&gt;argStyleText (optional)&lt;/i&gt;
 235  *       &lt;td&gt;&lt;code&gt;new RuleBasedNumberFormat(URBNF_DURATION, getLocale(), status)
 236  *           &lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.setDefaultRuleset(argStyleText, status);&lt;/code&gt;
 237  * &lt;/table&gt;
 238  * &lt;p&gt;
 239  *













 240  * &lt;h4&gt;Usage Information&lt;/h4&gt;
 241  *
 242  * &lt;p&gt;Here are some examples of usage:
 243  * Example 1:
 244  *
 245  * &lt;pre&gt;
 246  * \code
 247  *     UErrorCode success = U_ZERO_ERROR;
 248  *     GregorianCalendar cal(success);
 249  *     Formattable arguments[] = {
 250  *         7L,
 251  *         Formattable( (Date) cal.getTime(success), Formattable::kIsDate),
 252  *         &quot;a disturbance in the Force&quot;
 253  *     };
 254  *
 255  *     UnicodeString result;
 256  *     MessageFormat::format(
<span class="line-modified"> 257  *          &quot;At {1,time} on {1,date}, there was {2} on planet {0,number}.&quot;,</span>
 258  *          arguments, 3, result, success );
 259  *
 260  *     cout &lt;&lt; &quot;result: &quot; &lt;&lt; result &lt;&lt; endl;
<span class="line-modified"> 261  *     //&lt;output&gt;: At 4:34:20 PM on 23-Mar-98, there was a disturbance</span>
 262  *     //             in the Force on planet 7.
 263  * \endcode
 264  * &lt;/pre&gt;
 265  *
 266  * Typically, the message format will come from resources, and the
 267  * arguments will be dynamically set at runtime.
 268  *
 269  * &lt;p&gt;Example 2:
 270  *
 271  * &lt;pre&gt;
 272  *  \code
 273  *     success = U_ZERO_ERROR;
 274  *     Formattable testArgs[] = {3L, &quot;MyDisk&quot;};
 275  *
 276  *     MessageFormat form(
 277  *         &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;, success );
 278  *
 279  *     UnicodeString string;
 280  *     FieldPosition fpos = 0;
 281  *     cout &lt;&lt; &quot;format: &quot; &lt;&lt; form.format(testArgs, 2, string, fpos, success ) &lt;&lt; endl;
</pre>
<hr />
<pre>
 974                 const void *plNumber,
 975                 const Formattable* arguments,
 976                 const UnicodeString *argumentNames,
 977                 int32_t cnt,
 978                 AppendableWrapper&amp; appendTo,
 979                 FieldPosition* pos,
 980                 UErrorCode&amp; success) const;
 981 
 982     UnicodeString getArgName(int32_t partIndex);
 983 
 984     void setArgStartFormat(int32_t argStart, Format* formatter, UErrorCode&amp; status);
 985 
 986     void setCustomArgStartFormat(int32_t argStart, Format* formatter, UErrorCode&amp; status);
 987 
 988     int32_t nextTopLevelArgStart(int32_t partIndex) const;
 989 
 990     UBool argNameMatches(int32_t partIndex, const UnicodeString&amp; argName, int32_t argNumber);
 991 
 992     void cacheExplicitFormats(UErrorCode&amp; status);
 993 


 994     Format* createAppropriateFormat(UnicodeString&amp; type,
 995                                     UnicodeString&amp; style,
 996                                     Formattable::Type&amp; formattableType,
 997                                     UParseError&amp; parseError,
 998                                     UErrorCode&amp; ec);
 999 
1000     const Formattable* getArgFromListByName(const Formattable* arguments,
1001                                             const UnicodeString *argumentNames,
1002                                             int32_t cnt, UnicodeString&amp; name) const;
1003 
1004     Formattable* parse(int32_t msgStart,
1005                        const UnicodeString&amp; source,
1006                        ParsePosition&amp; pos,
1007                        int32_t&amp; count,
1008                        UErrorCode&amp; ec) const;
1009 
1010     FieldPosition* updateMetaData(AppendableWrapper&amp; dest, int32_t prevLength,
1011                                   FieldPosition* fp, const Formattable* argId) const;
1012 
1013     /**
</pre>
</td>
<td>
<hr />
<pre>
  52  * with optional arguments (variables/placeholders).
  53  * The arguments can occur in any order, which is necessary for translation
  54  * into languages with different grammars.
  55  *
  56  * &lt;p&gt;A MessageFormat is constructed from a &lt;em&gt;pattern&lt;/em&gt; string
  57  * with arguments in {curly braces} which will be replaced by formatted values.
  58  *
  59  * &lt;p&gt;&lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
  60  * classes in that you create a &lt;code&gt;MessageFormat&lt;/code&gt; object with one
  61  * of its constructors (not with a &lt;code&gt;createInstance&lt;/code&gt; style factory
  62  * method). Factory methods aren&#39;t necessary because &lt;code&gt;MessageFormat&lt;/code&gt;
  63  * itself doesn&#39;t implement locale-specific behavior. Any locale-specific
  64  * behavior is defined by the pattern that you provide and the
  65  * subformats used for inserted arguments.
  66  *
  67  * &lt;p&gt;Arguments can be named (using identifiers) or numbered (using small ASCII-digit integers).
  68  * Some of the API methods work only with argument numbers and throw an exception
  69  * if the pattern has named arguments (see {@link #usesNamedArguments()}).
  70  *
  71  * &lt;p&gt;An argument might not specify any format type. In this case,
<span class="line-modified">  72  * a numeric value is formatted with a default (for the locale) NumberFormat,</span>
<span class="line-modified">  73  * and a date/time value is formatted with a default (for the locale) DateFormat.</span>

  74  *
  75  * &lt;p&gt;An argument might specify a &quot;simple&quot; type for which the specified
  76  * Format object is created, cached and used.
  77  *
  78  * &lt;p&gt;An argument might have a &quot;complex&quot; type with nested MessageFormat sub-patterns.
  79  * During formatting, one of these sub-messages is selected according to the argument value
  80  * and recursively formatted.
  81  *
  82  * &lt;p&gt;After construction, a custom Format object can be set for
  83  * a top-level argument, overriding the default formatting and parsing behavior
  84  * for that argument.
  85  * However, custom formatting can be achieved more simply by writing
  86  * a typeless argument in the pattern string
  87  * and supplying it with a preformatted string value.
  88  *
  89  * &lt;p&gt;When formatting, MessageFormat takes a collection of argument values
  90  * and writes an output string.
  91  * The argument values may be passed as an array
  92  * (when the pattern contains only numbered arguments)
  93  * or as an array of names and and an array of arguments (which works for both named
</pre>
<hr />
<pre>
 106  * message = messageText (argument messageText)*
 107  * argument = noneArg | simpleArg | complexArg
 108  * complexArg = choiceArg | pluralArg | selectArg | selectordinalArg
 109  *
 110  * noneArg = &#39;{&#39; argNameOrNumber &#39;}&#39;
 111  * simpleArg = &#39;{&#39; argNameOrNumber &#39;,&#39; argType [&#39;,&#39; argStyle] &#39;}&#39;
 112  * choiceArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;choice&quot; &#39;,&#39; choiceStyle &#39;}&#39;
 113  * pluralArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;plural&quot; &#39;,&#39; pluralStyle &#39;}&#39;
 114  * selectArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;select&quot; &#39;,&#39; selectStyle &#39;}&#39;
 115  * selectordinalArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;selectordinal&quot; &#39;,&#39; pluralStyle &#39;}&#39;
 116  *
 117  * choiceStyle: see {@link ChoiceFormat}
 118  * pluralStyle: see {@link PluralFormat}
 119  * selectStyle: see {@link SelectFormat}
 120  *
 121  * argNameOrNumber = argName | argNumber
 122  * argName = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+
 123  * argNumber = &#39;0&#39; | (&#39;1&#39;..&#39;9&#39; (&#39;0&#39;..&#39;9&#39;)*)
 124  *
 125  * argType = &quot;number&quot; | &quot;date&quot; | &quot;time&quot; | &quot;spellout&quot; | &quot;ordinal&quot; | &quot;duration&quot;
<span class="line-modified"> 126  * argStyle = &quot;short&quot; | &quot;medium&quot; | &quot;long&quot; | &quot;full&quot; | &quot;integer&quot; | &quot;currency&quot; | &quot;percent&quot; | argStyleText | &quot;::&quot; argSkeletonText</span>
 127  * &lt;/pre&gt;
 128  *
 129  * &lt;ul&gt;
 130  *   &lt;li&gt;messageText can contain quoted literal strings including syntax characters.
 131  *       A quoted literal string begins with an ASCII apostrophe and a syntax character
 132  *       (usually a {curly brace}) and continues until the next single apostrophe.
 133  *       A double ASCII apostrohpe inside or outside of a quoted string represents
 134  *       one literal apostrophe.
 135  *   &lt;li&gt;Quotable syntax characters are the {curly braces} in all messageText parts,
 136  *       plus the &#39;#&#39; sign in a messageText immediately inside a pluralStyle,
 137  *       and the &#39;|&#39; symbol in a messageText immediately inside a choiceStyle.
 138  *   &lt;li&gt;See also {@link #UMessagePatternApostropheMode}
 139  *   &lt;li&gt;In argStyleText, every single ASCII apostrophe begins and ends quoted literal text,
 140  *       and unquoted {curly braces} must occur in matched pairs.
 141  * &lt;/ul&gt;
 142  *
 143  * &lt;p&gt;Recommendation: Use the real apostrophe (single quote) character
 144  * \htmlonly&amp;#x2019;\endhtmlonly (U+2019) for
 145  * human-readable text, and use the ASCII apostrophe &#39; (U+0027)
 146  * only in program syntax, like quoting in MessageFormat.
</pre>
<hr />
<pre>
 148  *
 149  * &lt;p&gt;The &lt;code&gt;choice&lt;/code&gt; argument type is deprecated.
 150  * Use &lt;code&gt;plural&lt;/code&gt; arguments for proper plural selection,
 151  * and &lt;code&gt;select&lt;/code&gt; arguments for simple selection among a fixed set of choices.
 152  *
 153  * &lt;p&gt;The &lt;code&gt;argType&lt;/code&gt; and &lt;code&gt;argStyle&lt;/code&gt; values are used to create
 154  * a &lt;code&gt;Format&lt;/code&gt; instance for the format element. The following
 155  * table shows how the values map to Format instances. Combinations not
 156  * shown in the table are illegal. Any &lt;code&gt;argStyleText&lt;/code&gt; must
 157  * be a valid pattern string for the Format subclass used.
 158  *
 159  * &lt;p&gt;&lt;table border=1&gt;
 160  *    &lt;tr&gt;
 161  *       &lt;th&gt;argType
 162  *       &lt;th&gt;argStyle
 163  *       &lt;th&gt;resulting Format object
 164  *    &lt;tr&gt;
 165  *       &lt;td colspan=2&gt;&lt;i&gt;(none)&lt;/i&gt;
 166  *       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
 167  *    &lt;tr&gt;
<span class="line-modified"> 168  *       &lt;td rowspan=6&gt;&lt;code&gt;number&lt;/code&gt;</span>
 169  *       &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;
 170  *       &lt;td&gt;&lt;code&gt;NumberFormat.createInstance(getLocale(), status)&lt;/code&gt;
 171  *    &lt;tr&gt;
 172  *       &lt;td&gt;&lt;code&gt;integer&lt;/code&gt;
 173  *       &lt;td&gt;&lt;code&gt;NumberFormat.createInstance(getLocale(), kNumberStyle, status)&lt;/code&gt;
 174  *    &lt;tr&gt;
 175  *       &lt;td&gt;&lt;code&gt;currency&lt;/code&gt;
 176  *       &lt;td&gt;&lt;code&gt;NumberFormat.createCurrencyInstance(getLocale(), status)&lt;/code&gt;
 177  *    &lt;tr&gt;
 178  *       &lt;td&gt;&lt;code&gt;percent&lt;/code&gt;
 179  *       &lt;td&gt;&lt;code&gt;NumberFormat.createPercentInstance(getLocale(), status)&lt;/code&gt;
 180  *    &lt;tr&gt;
 181  *       &lt;td&gt;&lt;i&gt;argStyleText&lt;/i&gt;
 182  *       &lt;td&gt;&lt;code&gt;new DecimalFormat(argStyleText, new DecimalFormatSymbols(getLocale(), status), status)&lt;/code&gt;
 183  *    &lt;tr&gt;
<span class="line-added"> 184  *       &lt;td&gt;&lt;i&gt;argSkeletonText&lt;/i&gt;</span>
<span class="line-added"> 185  *       &lt;td&gt;&lt;code&gt;NumberFormatter::forSkeleton(argSkeletonText, status).locale(getLocale()).toFormat(status)&lt;/code&gt;</span>
<span class="line-added"> 186  *    &lt;tr&gt;</span>
 187  *       &lt;td rowspan=6&gt;&lt;code&gt;date&lt;/code&gt;
 188  *       &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;
 189  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kDefault, getLocale(), status)&lt;/code&gt;
 190  *    &lt;tr&gt;
 191  *       &lt;td&gt;&lt;code&gt;short&lt;/code&gt;
 192  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kShort, getLocale(), status)&lt;/code&gt;
 193  *    &lt;tr&gt;
 194  *       &lt;td&gt;&lt;code&gt;medium&lt;/code&gt;
 195  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kDefault, getLocale(), status)&lt;/code&gt;
 196  *    &lt;tr&gt;
 197  *       &lt;td&gt;&lt;code&gt;long&lt;/code&gt;
 198  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kLong, getLocale(), status)&lt;/code&gt;
 199  *    &lt;tr&gt;
 200  *       &lt;td&gt;&lt;code&gt;full&lt;/code&gt;
 201  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kFull, getLocale(), status)&lt;/code&gt;
 202  *    &lt;tr&gt;
 203  *       &lt;td&gt;&lt;i&gt;argStyleText&lt;/i&gt;
<span class="line-modified"> 204  *       &lt;td&gt;&lt;code&gt;new SimpleDateFormat(argStyleText, getLocale(), status)&lt;/code&gt;</span>
<span class="line-added"> 205  *    &lt;tr&gt;</span>
<span class="line-added"> 206  *       &lt;td&gt;&lt;i&gt;argSkeletonText&lt;/i&gt;</span>
<span class="line-added"> 207  *       &lt;td&gt;&lt;code&gt;DateFormat::createInstanceForSkeleton(argSkeletonText, getLocale(), status)&lt;/code&gt;</span>
 208  *    &lt;tr&gt;
 209  *       &lt;td rowspan=6&gt;&lt;code&gt;time&lt;/code&gt;
 210  *       &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;
 211  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kDefault, getLocale(), status)&lt;/code&gt;
 212  *    &lt;tr&gt;
 213  *       &lt;td&gt;&lt;code&gt;short&lt;/code&gt;
 214  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kShort, getLocale(), status)&lt;/code&gt;
 215  *    &lt;tr&gt;
 216  *       &lt;td&gt;&lt;code&gt;medium&lt;/code&gt;
 217  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kDefault, getLocale(), status)&lt;/code&gt;
 218  *    &lt;tr&gt;
 219  *       &lt;td&gt;&lt;code&gt;long&lt;/code&gt;
 220  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kLong, getLocale(), status)&lt;/code&gt;
 221  *    &lt;tr&gt;
 222  *       &lt;td&gt;&lt;code&gt;full&lt;/code&gt;
 223  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kFull, getLocale(), status)&lt;/code&gt;
 224  *    &lt;tr&gt;
 225  *       &lt;td&gt;&lt;i&gt;argStyleText&lt;/i&gt;
<span class="line-modified"> 226  *       &lt;td&gt;&lt;code&gt;new SimpleDateFormat(argStyleText, getLocale(), status)&lt;/code&gt;</span>
 227  *    &lt;tr&gt;
 228  *       &lt;td&gt;&lt;code&gt;spellout&lt;/code&gt;
 229  *       &lt;td&gt;&lt;i&gt;argStyleText (optional)&lt;/i&gt;
 230  *       &lt;td&gt;&lt;code&gt;new RuleBasedNumberFormat(URBNF_SPELLOUT, getLocale(), status)
 231  *           &lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.setDefaultRuleset(argStyleText, status);&lt;/code&gt;
 232  *    &lt;tr&gt;
 233  *       &lt;td&gt;&lt;code&gt;ordinal&lt;/code&gt;
 234  *       &lt;td&gt;&lt;i&gt;argStyleText (optional)&lt;/i&gt;
 235  *       &lt;td&gt;&lt;code&gt;new RuleBasedNumberFormat(URBNF_ORDINAL, getLocale(), status)
 236  *           &lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.setDefaultRuleset(argStyleText, status);&lt;/code&gt;
 237  *    &lt;tr&gt;
 238  *       &lt;td&gt;&lt;code&gt;duration&lt;/code&gt;
 239  *       &lt;td&gt;&lt;i&gt;argStyleText (optional)&lt;/i&gt;
 240  *       &lt;td&gt;&lt;code&gt;new RuleBasedNumberFormat(URBNF_DURATION, getLocale(), status)
 241  *           &lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.setDefaultRuleset(argStyleText, status);&lt;/code&gt;
 242  * &lt;/table&gt;
 243  * &lt;p&gt;
 244  *
<span class="line-added"> 245  * &lt;h4&gt;Argument formatting&lt;/h4&gt;</span>
<span class="line-added"> 246  *</span>
<span class="line-added"> 247  * &lt;p&gt;Arguments are formatted according to their type, using the default</span>
<span class="line-added"> 248  * ICU formatters for those types, unless otherwise specified.&lt;/p&gt;</span>
<span class="line-added"> 249  *</span>
<span class="line-added"> 250  * &lt;p&gt;There are also several ways to control the formatting.&lt;/p&gt;</span>
<span class="line-added"> 251  *</span>
<span class="line-added"> 252  * &lt;p&gt;We recommend you use default styles, predefined style values, skeletons,</span>
<span class="line-added"> 253  * or preformatted values, but not pattern strings or custom format objects.&lt;/p&gt;</span>
<span class="line-added"> 254  *</span>
<span class="line-added"> 255  * &lt;p&gt;For more details, see the</span>
<span class="line-added"> 256  * &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages&quot;&gt;ICU User Guide&lt;/a&gt;.&lt;/p&gt;</span>
<span class="line-added"> 257  *</span>
 258  * &lt;h4&gt;Usage Information&lt;/h4&gt;
 259  *
 260  * &lt;p&gt;Here are some examples of usage:
 261  * Example 1:
 262  *
 263  * &lt;pre&gt;
 264  * \code
 265  *     UErrorCode success = U_ZERO_ERROR;
 266  *     GregorianCalendar cal(success);
 267  *     Formattable arguments[] = {
 268  *         7L,
 269  *         Formattable( (Date) cal.getTime(success), Formattable::kIsDate),
 270  *         &quot;a disturbance in the Force&quot;
 271  *     };
 272  *
 273  *     UnicodeString result;
 274  *     MessageFormat::format(
<span class="line-modified"> 275  *          &quot;At {1,time,::jmm} on {1,date,::dMMMM}, there was {2} on planet {0,number}.&quot;,</span>
 276  *          arguments, 3, result, success );
 277  *
 278  *     cout &lt;&lt; &quot;result: &quot; &lt;&lt; result &lt;&lt; endl;
<span class="line-modified"> 279  *     //&lt;output&gt;: At 4:34 PM on March 23, there was a disturbance</span>
 280  *     //             in the Force on planet 7.
 281  * \endcode
 282  * &lt;/pre&gt;
 283  *
 284  * Typically, the message format will come from resources, and the
 285  * arguments will be dynamically set at runtime.
 286  *
 287  * &lt;p&gt;Example 2:
 288  *
 289  * &lt;pre&gt;
 290  *  \code
 291  *     success = U_ZERO_ERROR;
 292  *     Formattable testArgs[] = {3L, &quot;MyDisk&quot;};
 293  *
 294  *     MessageFormat form(
 295  *         &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;, success );
 296  *
 297  *     UnicodeString string;
 298  *     FieldPosition fpos = 0;
 299  *     cout &lt;&lt; &quot;format: &quot; &lt;&lt; form.format(testArgs, 2, string, fpos, success ) &lt;&lt; endl;
</pre>
<hr />
<pre>
 992                 const void *plNumber,
 993                 const Formattable* arguments,
 994                 const UnicodeString *argumentNames,
 995                 int32_t cnt,
 996                 AppendableWrapper&amp; appendTo,
 997                 FieldPosition* pos,
 998                 UErrorCode&amp; success) const;
 999 
1000     UnicodeString getArgName(int32_t partIndex);
1001 
1002     void setArgStartFormat(int32_t argStart, Format* formatter, UErrorCode&amp; status);
1003 
1004     void setCustomArgStartFormat(int32_t argStart, Format* formatter, UErrorCode&amp; status);
1005 
1006     int32_t nextTopLevelArgStart(int32_t partIndex) const;
1007 
1008     UBool argNameMatches(int32_t partIndex, const UnicodeString&amp; argName, int32_t argNumber);
1009 
1010     void cacheExplicitFormats(UErrorCode&amp; status);
1011 
<span class="line-added">1012     int32_t skipLeadingSpaces(UnicodeString&amp; style);</span>
<span class="line-added">1013 </span>
1014     Format* createAppropriateFormat(UnicodeString&amp; type,
1015                                     UnicodeString&amp; style,
1016                                     Formattable::Type&amp; formattableType,
1017                                     UParseError&amp; parseError,
1018                                     UErrorCode&amp; ec);
1019 
1020     const Formattable* getArgFromListByName(const Formattable* arguments,
1021                                             const UnicodeString *argumentNames,
1022                                             int32_t cnt, UnicodeString&amp; name) const;
1023 
1024     Formattable* parse(int32_t msgStart,
1025                        const UnicodeString&amp; source,
1026                        ParsePosition&amp; pos,
1027                        int32_t&amp; count,
1028                        UErrorCode&amp; ec) const;
1029 
1030     FieldPosition* updateMetaData(AppendableWrapper&amp; dest, int32_t prevLength,
1031                                   FieldPosition* fp, const Formattable* argId) const;
1032 
1033     /**
</pre>
</td>
</tr>
</table>
<center><a href="measunit.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="nounit.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>