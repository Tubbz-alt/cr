<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/decNumberLocal.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /* ------------------------------------------------------------------ */
  4 /* decNumber package local type, tuning, and macro definitions        */
  5 /* ------------------------------------------------------------------ */
  6 /* Copyright (c) IBM Corporation, 2000-2016.   All rights reserved.   */
  7 /*                                                                    */
  8 /* This software is made available under the terms of the             */
  9 /* ICU License -- ICU 1.8.1 and later.                                */
 10 /*                                                                    */
 11 /* The description and User&#39;s Guide (&quot;The decNumber C Library&quot;) for   */
 12 /* this software is called decNumber.pdf.  This document is           */
 13 /* available, together with arithmetic and format specifications,     */
 14 /* testcases, and Web links, on the General Decimal Arithmetic page.  */
 15 /*                                                                    */
 16 /* Please send comments, suggestions, and corrections to the author:  */
 17 /*   mfc@uk.ibm.com                                                   */
 18 /*   Mike Cowlishaw, IBM Fellow                                       */
 19 /*   IBM UK, PO Box 31, Birmingham Road, Warwick CV34 5JL, UK         */
 20 /* ------------------------------------------------------------------ */
 21 /* This header file is included by all modules in the decNumber       */
 22 /* library, and contains local type definitions, tuning parameters,   */
 23 /* etc.  It should not need to be used by application programs.       */
 24 /* decNumber.h or one of decDouble (etc.) must be included first.     */
 25 /* ------------------------------------------------------------------ */
 26 
 27 #if !defined(DECNUMBERLOC)
 28   #define DECNUMBERLOC
 29   #define DECVERSION    &quot;decNumber 3.61&quot; /* Package Version [16 max.] */
 30   #define DECNLAUTHOR   &quot;Mike Cowlishaw&quot;              /* Who to blame */
 31 
 32   #include &lt;stdlib.h&gt;         /* for abs                              */
 33   #include &lt;string.h&gt;         /* for memset, strcpy                   */
 34   #include &quot;decContext.h&quot;
 35 
 36   /* Conditional code flag -- set this to match hardware platform     */
 37   #if !defined(DECLITEND)
 38   #define DECLITEND 1         /* 1=little-endian, 0=big-endian        */
 39   #endif
 40 
 41   /* Conditional code flag -- set this to 1 for best performance      */
 42   #if !defined(DECUSE64)
 43   #define DECUSE64  1         /* 1=use int64s, 0=int32 &amp; smaller only */
 44   #endif
 45 
 46   /* Conditional check flags -- set these to 0 for best performance   */
 47   #if !defined(DECCHECK)
 48   #define DECCHECK  0         /* 1 to enable robust checking          */
 49   #endif
 50   #if !defined(DECALLOC)
 51   #define DECALLOC  0         /* 1 to enable memory accounting        */
 52   #endif
 53   #if !defined(DECTRACE)
 54   #define DECTRACE  0         /* 1 to trace certain internals, etc.   */
 55   #endif
 56 
 57   /* Tuning parameter for decNumber (arbitrary precision) module      */
 58   #if !defined(DECBUFFER)
 59   #define DECBUFFER 36        /* Size basis for local buffers.  This  */
 60                               /* should be a common maximum precision */
 61                               /* rounded up to a multiple of 4; must  */
 62                               /* be zero or positive.                 */
 63   #endif
 64 
 65   /* ---------------------------------------------------------------- */
 66   /* Definitions for all modules (general-purpose)                    */
 67   /* ---------------------------------------------------------------- */
 68 
 69   /* Local names for common types -- for safety, decNumber modules do */
 70   /* not use int or long directly.                                    */
 71   #define Flag   uint8_t
 72   #define Byte   int8_t
 73   #define uByte  uint8_t
 74   #define Short  int16_t
 75   #define uShort uint16_t
 76   #define Int    int32_t
 77   #define uInt   uint32_t
 78   #define Unit   decNumberUnit
 79   #if DECUSE64
 80   #define Long   int64_t
 81   #define uLong  uint64_t
 82   #endif
 83 
 84   /* Development-use definitions                                      */
 85   typedef long int LI;        /* for printf arguments only            */
 86   #define DECNOINT  0         /* 1 to check no internal use of &#39;int&#39;  */
 87                               /*   or stdint types                    */
 88   #if DECNOINT
 89     /* if these interfere with your C includes, do not set DECNOINT   */
 90     #define int     ?         /* enable to ensure that plain C &#39;int&#39;  */
 91     #define long    ??        /* .. or &#39;long&#39; types are not used      */
 92   #endif
 93 
 94   /* LONGMUL32HI -- set w=(u*v)&gt;&gt;32, where w, u, and v are uInts      */
 95   /* (that is, sets w to be the high-order word of the 64-bit result; */
 96   /* the low-order word is simply u*v.)                               */
 97   /* This version is derived from Knuth via Hacker&#39;s Delight;         */
 98   /* it seems to optimize better than some others tried               */
 99   #define LONGMUL32HI(w, u, v) {             \
100     uInt u0, u1, v0, v1, w0, w1, w2, t;      \
101     u0=u &amp; 0xffff; u1=u&gt;&gt;16;                 \
102     v0=v &amp; 0xffff; v1=v&gt;&gt;16;                 \
103     w0=u0*v0;                                \
104     t=u1*v0 + (w0&gt;&gt;16);                      \
105     w1=t &amp; 0xffff; w2=t&gt;&gt;16;                 \
106     w1=u0*v1 + w1;                           \
107     (w)=u1*v1 + w2 + (w1&gt;&gt;16);}
108 
109   /* ROUNDUP -- round an integer up to a multiple of n                */
110   #define ROUNDUP(i, n) ((((i)+(n)-1)/n)*n)
111   #define ROUNDUP4(i)   (((i)+3)&amp;~3)    /* special for n=4            */
112 
113   /* ROUNDDOWN -- round an integer down to a multiple of n            */
114   #define ROUNDDOWN(i, n) (((i)/n)*n)
115   #define ROUNDDOWN4(i)   ((i)&amp;~3)      /* special for n=4            */
116 
117   /* References to multi-byte sequences under different sizes; these  */
118   /* require locally declared variables, but do not violate strict    */
119   /* aliasing or alignment (as did the UINTAT simple cast to uInt).   */
120   /* Variables needed are uswork, uiwork, etc. [so do not use at same */
121   /* level in an expression, e.g., UBTOUI(x)==UBTOUI(y) may fail].    */
122 
123   /* Return a uInt, etc., from bytes starting at a char* or uByte*    */
124   #define UBTOUS(b)  (memcpy((void *)&amp;uswork, b, 2), uswork)
125   #define UBTOUI(b)  (memcpy((void *)&amp;uiwork, b, 4), uiwork)
126 
127   /* Store a uInt, etc., into bytes starting at a char* or uByte*.    */
128   /* Returns i, evaluated, for convenience; has to use uiwork because */
129   /* i may be an expression.                                          */
130   #define UBFROMUS(b, i)  (uswork=(i), memcpy(b, (void *)&amp;uswork, 2), uswork)
131   #define UBFROMUI(b, i)  (uiwork=(i), memcpy(b, (void *)&amp;uiwork, 4), uiwork)
132 
133   /* X10 and X100 -- multiply integer i by 10 or 100                  */
134   /* [shifts are usually faster than multiply; could be conditional]  */
135   #define X10(i)  (((i)&lt;&lt;1)+((i)&lt;&lt;3))
136   #define X100(i) (((i)&lt;&lt;2)+((i)&lt;&lt;5)+((i)&lt;&lt;6))
137 
138   /* MAXI and MINI -- general max &amp; min (not in ANSI) for integers    */
139   #define MAXI(x,y) ((x)&lt;(y)?(y):(x))
140   #define MINI(x,y) ((x)&gt;(y)?(y):(x))
141 
142   /* Useful constants                                                 */
143   #define BILLION      1000000000            /* 10**9                 */
144   /* CHARMASK: 0x30303030 for ASCII/UTF8; 0xF0F0F0F0 for EBCDIC       */
145   #define CHARMASK ((((((((uInt)&#39;0&#39;)&lt;&lt;8)+&#39;0&#39;)&lt;&lt;8)+&#39;0&#39;)&lt;&lt;8)+&#39;0&#39;)
146 
147 
148   /* ---------------------------------------------------------------- */
149   /* Definitions for arbitary-precision modules (only valid after     */
150   /* decNumber.h has been included)                                   */
151   /* ---------------------------------------------------------------- */
152 
153   /* Limits and constants                                             */
154   #define DECNUMMAXP 999999999  /* maximum precision code can handle  */
155   #define DECNUMMAXE 999999999  /* maximum adjusted exponent ditto    */
156   #define DECNUMMINE -999999999 /* minimum adjusted exponent ditto    */
157   #if (DECNUMMAXP != DEC_MAX_DIGITS)
158     #error Maximum digits mismatch
159   #endif
160   #if (DECNUMMAXE != DEC_MAX_EMAX)
161     #error Maximum exponent mismatch
162   #endif
163   #if (DECNUMMINE != DEC_MIN_EMIN)
164     #error Minimum exponent mismatch
165   #endif
166 
167   /* Set DECDPUNMAX -- the maximum integer that fits in DECDPUN       */
168   /* digits, and D2UTABLE -- the initializer for the D2U table        */
<a name="1" id="anc1"></a><span class="line-modified">169   #ifndef DECDPUN</span>
<span class="line-added">170     // no-op</span>
<span class="line-added">171   #elif   DECDPUN==1</span>
172     #define DECDPUNMAX 9
173     #define D2UTABLE {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,  \
174                       18,19,20,21,22,23,24,25,26,27,28,29,30,31,32, \
175                       33,34,35,36,37,38,39,40,41,42,43,44,45,46,47, \
176                       48,49}
177   #elif DECDPUN==2
178     #define DECDPUNMAX 99
179     #define D2UTABLE {0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,  \
180                       11,11,12,12,13,13,14,14,15,15,16,16,17,17,18, \
181                       18,19,19,20,20,21,21,22,22,23,23,24,24,25}
182   #elif DECDPUN==3
183     #define DECDPUNMAX 999
184     #define D2UTABLE {0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,  \
185                       8,8,8,9,9,9,10,10,10,11,11,11,12,12,12,13,13, \
186                       13,14,14,14,15,15,15,16,16,16,17}
187   #elif DECDPUN==4
188     #define DECDPUNMAX 9999
189     #define D2UTABLE {0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,  \
190                       6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11, \
191                       11,11,11,12,12,12,12,13}
192   #elif DECDPUN==5
193     #define DECDPUNMAX 99999
194     #define D2UTABLE {0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,  \
195                       5,5,5,5,6,6,6,6,6,7,7,7,7,7,8,8,8,8,8,9,9,9,  \
196                       9,9,10,10,10,10}
197   #elif DECDPUN==6
198     #define DECDPUNMAX 999999
199     #define D2UTABLE {0,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,  \
200                       4,4,4,5,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,8,  \
201                       8,8,8,8,8,9}
202   #elif DECDPUN==7
203     #define DECDPUNMAX 9999999
204     #define D2UTABLE {0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3,  \
205                       4,4,4,4,4,4,4,5,5,5,5,5,5,5,6,6,6,6,6,6,6,7,  \
206                       7,7,7,7,7,7}
207   #elif DECDPUN==8
208     #define DECDPUNMAX 99999999
209     #define D2UTABLE {0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,  \
210                       3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,  \
211                       6,6,6,6,6,7}
212   #elif DECDPUN==9
213     #define DECDPUNMAX 999999999
214     #define D2UTABLE {0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,  \
215                       3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,  \
216                       5,5,6,6,6,6}
<a name="2" id="anc2"></a><span class="line-modified">217   #else</span>
218     #error DECDPUN must be in the range 1-9
219   #endif
220 
221   /* ----- Shared data (in decNumber.c) ----- */
222   /* Public lookup table used by the D2U macro (see below)            */
223   #define DECMAXD2U 49
224   /*extern const uByte d2utable[DECMAXD2U+1];*/
225 
226   /* ----- Macros ----- */
227   /* ISZERO -- return true if decNumber dn is a zero                  */
228   /* [performance-critical in some situations]                        */
229   #define ISZERO(dn) decNumberIsZero(dn)     /* now just a local name */
230 
231   /* D2U -- return the number of Units needed to hold d digits        */
232   /* (runtime version, with table lookaside for small d)              */
<a name="3" id="anc3"></a><span class="line-modified">233   #if defined(DECDPUN) &amp;&amp; DECDPUN==8</span>
234     #define D2U(d) ((unsigned)((d)&lt;=DECMAXD2U?d2utable[d]:((d)+7)&gt;&gt;3))
<a name="4" id="anc4"></a><span class="line-modified">235   #elif defined(DECDPUN) &amp;&amp; DECDPUN==4</span>
236     #define D2U(d) ((unsigned)((d)&lt;=DECMAXD2U?d2utable[d]:((d)+3)&gt;&gt;2))
237   #else
238     #define D2U(d) ((d)&lt;=DECMAXD2U?d2utable[d]:((d)+DECDPUN-1)/DECDPUN)
239   #endif
240   /* SD2U -- static D2U macro (for compile-time calculation)          */
241   #define SD2U(d) (((d)+DECDPUN-1)/DECDPUN)
242 
243   /* MSUDIGITS -- returns digits in msu, from digits, calculated      */
244   /* using D2U                                                        */
245   #define MSUDIGITS(d) ((d)-(D2U(d)-1)*DECDPUN)
246 
247   /* D2N -- return the number of decNumber structs that would be      */
248   /* needed to contain that number of digits (and the initial         */
249   /* decNumber struct) safely.  Note that one Unit is included in the */
250   /* initial structure.  Used for allocating space that is aligned on */
251   /* a decNumber struct boundary. */
252   #define D2N(d) \
253     ((((SD2U(d)-1)*sizeof(Unit))+sizeof(decNumber)*2-1)/sizeof(decNumber))
254 
255   /* TODIGIT -- macro to remove the leading digit from the unsigned   */
256   /* integer u at column cut (counting from the right, LSD=0) and     */
257   /* place it as an ASCII character into the character pointed to by  */
258   /* c.  Note that cut must be &lt;= 9, and the maximum value for u is   */
259   /* 2,000,000,000 (as is needed for negative exponents of            */
260   /* subnormals).  The unsigned integer pow is used as a temporary    */
261   /* variable. */
262   #define TODIGIT(u, cut, c, pow) {       \
263     *(c)=&#39;0&#39;;                             \
264     pow=DECPOWERS[cut]*2;                 \
265     if ((u)&gt;pow) {                        \
266       pow*=4;                             \
267       if ((u)&gt;=pow) {(u)-=pow; *(c)+=8;}  \
268       pow/=2;                             \
269       if ((u)&gt;=pow) {(u)-=pow; *(c)+=4;}  \
270       pow/=2;                             \
271       }                                   \
272     if ((u)&gt;=pow) {(u)-=pow; *(c)+=2;}    \
273     pow/=2;                               \
274     if ((u)&gt;=pow) {(u)-=pow; *(c)+=1;}    \
275     }
276 
277   /* ---------------------------------------------------------------- */
278   /* Definitions for fixed-precision modules (only valid after        */
279   /* decSingle.h, decDouble.h, or decQuad.h has been included)        */
280   /* ---------------------------------------------------------------- */
281 
282   /* bcdnum -- a structure describing a format-independent finite     */
283   /* number, whose coefficient is a string of bcd8 uBytes             */
284   typedef struct {
285     uByte   *msd;             /* -&gt; most significant digit            */
286     uByte   *lsd;             /* -&gt; least ditto                       */
287     uInt     sign;            /* 0=positive, DECFLOAT_Sign=negative   */
288     Int      exponent;        /* Unadjusted signed exponent (q), or   */
289                               /* DECFLOAT_NaN etc. for a special      */
290     } bcdnum;
291 
292   /* Test if exponent or bcdnum exponent must be a special, etc.      */
293   #define EXPISSPECIAL(exp) ((exp)&gt;=DECFLOAT_MinSp)
294   #define EXPISINF(exp) (exp==DECFLOAT_Inf)
295   #define EXPISNAN(exp) (exp==DECFLOAT_qNaN || exp==DECFLOAT_sNaN)
296   #define NUMISSPECIAL(num) (EXPISSPECIAL((num)-&gt;exponent))
297 
298   /* Refer to a 32-bit word or byte in a decFloat (df) by big-endian  */
299   /* (array) notation (the 0 word or byte contains the sign bit),     */
300   /* automatically adjusting for endianness; similarly address a word */
301   /* in the next-wider format (decFloatWider, or dfw)                 */
302   #define DECWORDS  (DECBYTES/4)
303   #define DECWWORDS (DECWBYTES/4)
304   #if DECLITEND
305     #define DFBYTE(df, off)   ((df)-&gt;bytes[DECBYTES-1-(off)])
306     #define DFWORD(df, off)   ((df)-&gt;words[DECWORDS-1-(off)])
307     #define DFWWORD(dfw, off) ((dfw)-&gt;words[DECWWORDS-1-(off)])
308   #else
309     #define DFBYTE(df, off)   ((df)-&gt;bytes[off])
310     #define DFWORD(df, off)   ((df)-&gt;words[off])
311     #define DFWWORD(dfw, off) ((dfw)-&gt;words[off])
312   #endif
313 
314   /* Tests for sign or specials, directly on DECFLOATs                */
315   #define DFISSIGNED(df)   (DFWORD(df, 0)&amp;0x80000000)
316   #define DFISSPECIAL(df) ((DFWORD(df, 0)&amp;0x78000000)==0x78000000)
317   #define DFISINF(df)     ((DFWORD(df, 0)&amp;0x7c000000)==0x78000000)
318   #define DFISNAN(df)     ((DFWORD(df, 0)&amp;0x7c000000)==0x7c000000)
319   #define DFISQNAN(df)    ((DFWORD(df, 0)&amp;0x7e000000)==0x7c000000)
320   #define DFISSNAN(df)    ((DFWORD(df, 0)&amp;0x7e000000)==0x7e000000)
321 
322   /* Shared lookup tables                                             */
323   extern const uInt   DECCOMBMSD[64];   /* Combination field -&gt; MSD   */
324   extern const uInt   DECCOMBFROM[48];  /* exp+msd -&gt; Combination     */
325 
326   /* Private generic (utility) routine                                */
327   #if DECCHECK || DECTRACE
328     extern void decShowNum(const bcdnum *, const char *);
329   #endif
330 
331   /* Format-dependent macros and constants                            */
332   #if defined(DECPMAX)
333 
334     /* Useful constants                                               */
335     #define DECPMAX9  (ROUNDUP(DECPMAX, 9)/9)  /* &#39;Pmax&#39; in 10**9s    */
336     /* Top words for a zero                                           */
337     #define SINGLEZERO   0x22500000
338     #define DOUBLEZERO   0x22380000
339     #define QUADZERO     0x22080000
340     /* [ZEROWORD is defined to be one of these in the DFISZERO macro] */
341 
342     /* Format-dependent common tests:                                 */
343     /*   DFISZERO   -- test for (any) zero                            */
344     /*   DFISCCZERO -- test for coefficient continuation being zero   */
345     /*   DFISCC01   -- test for coefficient contains only 0s and 1s   */
346     /*   DFISINT    -- test for finite and exponent q=0               */
347     /*   DFISUINT01 -- test for sign=0, finite, exponent q=0, and     */
348     /*                 MSD=0 or 1                                     */
349     /*   ZEROWORD is also defined here.                               */
350     /* In DFISZERO the first test checks the least-significant word   */
351     /* (most likely to be non-zero); the penultimate tests MSD and    */
352     /* DPDs in the signword, and the final test excludes specials and */
353     /* MSD&gt;7.  DFISINT similarly has to allow for the two forms of    */
354     /* MSD codes.  DFISUINT01 only has to allow for one form of MSD   */
355     /* code.                                                          */
356     #if DECPMAX==7
357       #define ZEROWORD SINGLEZERO
358       /* [test macros not needed except for Zero]                     */
359       #define DFISZERO(df)  ((DFWORD(df, 0)&amp;0x1c0fffff)==0         \
360                           &amp;&amp; (DFWORD(df, 0)&amp;0x60000000)!=0x60000000)
361     #elif DECPMAX==16
362       #define ZEROWORD DOUBLEZERO
363       #define DFISZERO(df)  ((DFWORD(df, 1)==0                     \
364                           &amp;&amp; (DFWORD(df, 0)&amp;0x1c03ffff)==0         \
365                           &amp;&amp; (DFWORD(df, 0)&amp;0x60000000)!=0x60000000))
366       #define DFISINT(df) ((DFWORD(df, 0)&amp;0x63fc0000)==0x22380000  \
367                          ||(DFWORD(df, 0)&amp;0x7bfc0000)==0x6a380000)
368       #define DFISUINT01(df) ((DFWORD(df, 0)&amp;0xfbfc0000)==0x22380000)
369       #define DFISCCZERO(df) (DFWORD(df, 1)==0                     \
370                           &amp;&amp; (DFWORD(df, 0)&amp;0x0003ffff)==0)
371       #define DFISCC01(df)  ((DFWORD(df, 0)&amp;~0xfffc9124)==0        \
372                           &amp;&amp; (DFWORD(df, 1)&amp;~0x49124491)==0)
373     #elif DECPMAX==34
374       #define ZEROWORD QUADZERO
375       #define DFISZERO(df)  ((DFWORD(df, 3)==0                     \
376                           &amp;&amp;  DFWORD(df, 2)==0                     \
377                           &amp;&amp;  DFWORD(df, 1)==0                     \
378                           &amp;&amp; (DFWORD(df, 0)&amp;0x1c003fff)==0         \
379                           &amp;&amp; (DFWORD(df, 0)&amp;0x60000000)!=0x60000000))
380       #define DFISINT(df) ((DFWORD(df, 0)&amp;0x63ffc000)==0x22080000  \
381                          ||(DFWORD(df, 0)&amp;0x7bffc000)==0x6a080000)
382       #define DFISUINT01(df) ((DFWORD(df, 0)&amp;0xfbffc000)==0x22080000)
383       #define DFISCCZERO(df) (DFWORD(df, 3)==0                     \
384                           &amp;&amp;  DFWORD(df, 2)==0                     \
385                           &amp;&amp;  DFWORD(df, 1)==0                     \
386                           &amp;&amp; (DFWORD(df, 0)&amp;0x00003fff)==0)
387 
388       #define DFISCC01(df)   ((DFWORD(df, 0)&amp;~0xffffc912)==0       \
389                           &amp;&amp;  (DFWORD(df, 1)&amp;~0x44912449)==0       \
390                           &amp;&amp;  (DFWORD(df, 2)&amp;~0x12449124)==0       \
391                           &amp;&amp;  (DFWORD(df, 3)&amp;~0x49124491)==0)
392     #endif
393 
394     /* Macros to test if a certain 10 bits of a uInt or pair of uInts */
395     /* are a canonical declet [higher or lower bits are ignored].     */
396     /* declet is at offset 0 (from the right) in a uInt:              */
397     #define CANONDPD(dpd) (((dpd)&amp;0x300)==0 || ((dpd)&amp;0x6e)!=0x6e)
398     /* declet is at offset k (a multiple of 2) in a uInt:             */
399     #define CANONDPDOFF(dpd, k) (((dpd)&amp;(0x300&lt;&lt;(k)))==0            \
400       || ((dpd)&amp;(((uInt)0x6e)&lt;&lt;(k)))!=(((uInt)0x6e)&lt;&lt;(k)))
401     /* declet is at offset k (a multiple of 2) in a pair of uInts:    */
402     /* [the top 2 bits will always be in the more-significant uInt]   */
403     #define CANONDPDTWO(hi, lo, k) (((hi)&amp;(0x300&gt;&gt;(32-(k))))==0     \
404       || ((hi)&amp;(0x6e&gt;&gt;(32-(k))))!=(0x6e&gt;&gt;(32-(k)))                  \
405       || ((lo)&amp;(((uInt)0x6e)&lt;&lt;(k)))!=(((uInt)0x6e)&lt;&lt;(k)))
406 
407     /* Macro to test whether a full-length (length DECPMAX) BCD8      */
408     /* coefficient, starting at uByte u, is all zeros                 */
409     /* Test just the LSWord first, then the remainder as a sequence   */
410     /* of tests in order to avoid same-level use of UBTOUI            */
411     #if DECPMAX==7
412       #define ISCOEFFZERO(u) (                                      \
413            UBTOUI((u)+DECPMAX-4)==0                                 \
414         &amp;&amp; UBTOUS((u)+DECPMAX-6)==0                                 \
415         &amp;&amp; *(u)==0)
416     #elif DECPMAX==16
417       #define ISCOEFFZERO(u) (                                      \
418            UBTOUI((u)+DECPMAX-4)==0                                 \
419         &amp;&amp; UBTOUI((u)+DECPMAX-8)==0                                 \
420         &amp;&amp; UBTOUI((u)+DECPMAX-12)==0                                \
421         &amp;&amp; UBTOUI(u)==0)
422     #elif DECPMAX==34
423       #define ISCOEFFZERO(u) (                                      \
424            UBTOUI((u)+DECPMAX-4)==0                                 \
425         &amp;&amp; UBTOUI((u)+DECPMAX-8)==0                                 \
426         &amp;&amp; UBTOUI((u)+DECPMAX-12)==0                                \
427         &amp;&amp; UBTOUI((u)+DECPMAX-16)==0                                \
428         &amp;&amp; UBTOUI((u)+DECPMAX-20)==0                                \
429         &amp;&amp; UBTOUI((u)+DECPMAX-24)==0                                \
430         &amp;&amp; UBTOUI((u)+DECPMAX-28)==0                                \
431         &amp;&amp; UBTOUI((u)+DECPMAX-32)==0                                \
432         &amp;&amp; UBTOUS(u)==0)
433     #endif
434 
435     /* Macros and masks for the exponent continuation field and MSD   */
436     /* Get the exponent continuation from a decFloat *df as an Int    */
437     #define GETECON(df) ((Int)((DFWORD((df), 0)&amp;0x03ffffff)&gt;&gt;(32-6-DECECONL)))
438     /* Ditto, from the next-wider format                              */
439     #define GETWECON(df) ((Int)((DFWWORD((df), 0)&amp;0x03ffffff)&gt;&gt;(32-6-DECWECONL)))
440     /* Get the biased exponent similarly                              */
441     #define GETEXP(df)  ((Int)(DECCOMBEXP[DFWORD((df), 0)&gt;&gt;26]+GETECON(df)))
442     /* Get the unbiased exponent similarly                            */
443     #define GETEXPUN(df) ((Int)GETEXP(df)-DECBIAS)
444     /* Get the MSD similarly (as uInt)                                */
445     #define GETMSD(df)   (DECCOMBMSD[DFWORD((df), 0)&gt;&gt;26])
446 
447     /* Compile-time computes of the exponent continuation field masks */
448     /* full exponent continuation field:                              */
449     #define ECONMASK ((0x03ffffff&gt;&gt;(32-6-DECECONL))&lt;&lt;(32-6-DECECONL))
450     /* same, not including its first digit (the qNaN/sNaN selector):  */
451     #define ECONNANMASK ((0x01ffffff&gt;&gt;(32-6-DECECONL))&lt;&lt;(32-6-DECECONL))
452 
453     /* Macros to decode the coefficient in a finite decFloat *df into */
454     /* a BCD string (uByte *bcdin) of length DECPMAX uBytes.          */
455 
456     /* In-line sequence to convert least significant 10 bits of uInt  */
457     /* dpd to three BCD8 digits starting at uByte u.  Note that an    */
458     /* extra byte is written to the right of the three digits because */
459     /* four bytes are moved at a time for speed; the alternative      */
460     /* macro moves exactly three bytes (usually slower).              */
461     #define dpd2bcd8(u, dpd)  memcpy(u, &amp;DPD2BCD8[((dpd)&amp;0x3ff)*4], 4)
462     #define dpd2bcd83(u, dpd) memcpy(u, &amp;DPD2BCD8[((dpd)&amp;0x3ff)*4], 3)
463 
464     /* Decode the declets.  After extracting each one, it is decoded  */
465     /* to BCD8 using a table lookup (also used for variable-length    */
466     /* decode).  Each DPD decode is 3 bytes BCD8 plus a one-byte      */
467     /* length which is not used, here).  Fixed-length 4-byte moves    */
468     /* are fast, however, almost everywhere, and so are used except   */
469     /* for the final three bytes (to avoid overrun).  The code below  */
470     /* is 36 instructions for Doubles and about 70 for Quads, even    */
471     /* on IA32.                                                       */
472 
473     /* Two macros are defined for each format:                        */
474     /*   GETCOEFF extracts the coefficient of the current format      */
475     /*   GETWCOEFF extracts the coefficient of the next-wider format. */
476     /* The latter is a copy of the next-wider GETCOEFF using DFWWORD. */
477 
478     #if DECPMAX==7
479     #define GETCOEFF(df, bcd) {                          \
480       uInt sourhi=DFWORD(df, 0);                         \
481       *(bcd)=(uByte)DECCOMBMSD[sourhi&gt;&gt;26];              \
482       dpd2bcd8(bcd+1, sourhi&gt;&gt;10);                       \
483       dpd2bcd83(bcd+4, sourhi);}
484     #define GETWCOEFF(df, bcd) {                         \
485       uInt sourhi=DFWWORD(df, 0);                        \
486       uInt sourlo=DFWWORD(df, 1);                        \
487       *(bcd)=(uByte)DECCOMBMSD[sourhi&gt;&gt;26];              \
488       dpd2bcd8(bcd+1, sourhi&gt;&gt;8);                        \
489       dpd2bcd8(bcd+4, (sourhi&lt;&lt;2) | (sourlo&gt;&gt;30));       \
490       dpd2bcd8(bcd+7, sourlo&gt;&gt;20);                       \
491       dpd2bcd8(bcd+10, sourlo&gt;&gt;10);                      \
492       dpd2bcd83(bcd+13, sourlo);}
493 
494     #elif DECPMAX==16
495     #define GETCOEFF(df, bcd) {                          \
496       uInt sourhi=DFWORD(df, 0);                         \
497       uInt sourlo=DFWORD(df, 1);                         \
498       *(bcd)=(uByte)DECCOMBMSD[sourhi&gt;&gt;26];              \
499       dpd2bcd8(bcd+1, sourhi&gt;&gt;8);                        \
500       dpd2bcd8(bcd+4, (sourhi&lt;&lt;2) | (sourlo&gt;&gt;30));       \
501       dpd2bcd8(bcd+7, sourlo&gt;&gt;20);                       \
502       dpd2bcd8(bcd+10, sourlo&gt;&gt;10);                      \
503       dpd2bcd83(bcd+13, sourlo);}
504     #define GETWCOEFF(df, bcd) {                         \
505       uInt sourhi=DFWWORD(df, 0);                        \
506       uInt sourmh=DFWWORD(df, 1);                        \
507       uInt sourml=DFWWORD(df, 2);                        \
508       uInt sourlo=DFWWORD(df, 3);                        \
509       *(bcd)=(uByte)DECCOMBMSD[sourhi&gt;&gt;26];              \
510       dpd2bcd8(bcd+1, sourhi&gt;&gt;4);                        \
511       dpd2bcd8(bcd+4, ((sourhi)&lt;&lt;6) | (sourmh&gt;&gt;26));     \
512       dpd2bcd8(bcd+7, sourmh&gt;&gt;16);                       \
513       dpd2bcd8(bcd+10, sourmh&gt;&gt;6);                       \
514       dpd2bcd8(bcd+13, ((sourmh)&lt;&lt;4) | (sourml&gt;&gt;28));    \
515       dpd2bcd8(bcd+16, sourml&gt;&gt;18);                      \
516       dpd2bcd8(bcd+19, sourml&gt;&gt;8);                       \
517       dpd2bcd8(bcd+22, ((sourml)&lt;&lt;2) | (sourlo&gt;&gt;30));    \
518       dpd2bcd8(bcd+25, sourlo&gt;&gt;20);                      \
519       dpd2bcd8(bcd+28, sourlo&gt;&gt;10);                      \
520       dpd2bcd83(bcd+31, sourlo);}
521 
522     #elif DECPMAX==34
523     #define GETCOEFF(df, bcd) {                          \
524       uInt sourhi=DFWORD(df, 0);                         \
525       uInt sourmh=DFWORD(df, 1);                         \
526       uInt sourml=DFWORD(df, 2);                         \
527       uInt sourlo=DFWORD(df, 3);                         \
528       *(bcd)=(uByte)DECCOMBMSD[sourhi&gt;&gt;26];              \
529       dpd2bcd8(bcd+1, sourhi&gt;&gt;4);                        \
530       dpd2bcd8(bcd+4, ((sourhi)&lt;&lt;6) | (sourmh&gt;&gt;26));     \
531       dpd2bcd8(bcd+7, sourmh&gt;&gt;16);                       \
532       dpd2bcd8(bcd+10, sourmh&gt;&gt;6);                       \
533       dpd2bcd8(bcd+13, ((sourmh)&lt;&lt;4) | (sourml&gt;&gt;28));    \
534       dpd2bcd8(bcd+16, sourml&gt;&gt;18);                      \
535       dpd2bcd8(bcd+19, sourml&gt;&gt;8);                       \
536       dpd2bcd8(bcd+22, ((sourml)&lt;&lt;2) | (sourlo&gt;&gt;30));    \
537       dpd2bcd8(bcd+25, sourlo&gt;&gt;20);                      \
538       dpd2bcd8(bcd+28, sourlo&gt;&gt;10);                      \
539       dpd2bcd83(bcd+31, sourlo);}
540 
541       #define GETWCOEFF(df, bcd) {??} /* [should never be used]       */
542     #endif
543 
544     /* Macros to decode the coefficient in a finite decFloat *df into */
545     /* a base-billion uInt array, with the least-significant          */
546     /* 0-999999999 &#39;digit&#39; at offset 0.                               */
547 
548     /* Decode the declets.  After extracting each one, it is decoded  */
549     /* to binary using a table lookup.  Three tables are used; one    */
550     /* the usual DPD to binary, the other two pre-multiplied by 1000  */
551     /* and 1000000 to avoid multiplication during decode.  These      */
552     /* tables can also be used for multiplying up the MSD as the DPD  */
553     /* code for 0 through 9 is the identity.                          */
554     #define DPD2BIN0 DPD2BIN         /* for prettier code             */
555 
556     #if DECPMAX==7
557     #define GETCOEFFBILL(df, buf) {                           \
558       uInt sourhi=DFWORD(df, 0);                              \
559       (buf)[0]=DPD2BIN0[sourhi&amp;0x3ff]                         \
560               +DPD2BINK[(sourhi&gt;&gt;10)&amp;0x3ff]                   \
561               +DPD2BINM[DECCOMBMSD[sourhi&gt;&gt;26]];}
562 
563     #elif DECPMAX==16
564     #define GETCOEFFBILL(df, buf) {                           \
565       uInt sourhi, sourlo;                                    \
566       sourlo=DFWORD(df, 1);                                   \
567       (buf)[0]=DPD2BIN0[sourlo&amp;0x3ff]                         \
568               +DPD2BINK[(sourlo&gt;&gt;10)&amp;0x3ff]                   \
569               +DPD2BINM[(sourlo&gt;&gt;20)&amp;0x3ff];                  \
570       sourhi=DFWORD(df, 0);                                   \
571       (buf)[1]=DPD2BIN0[((sourhi&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff]   \
572               +DPD2BINK[(sourhi&gt;&gt;8)&amp;0x3ff]                    \
573               +DPD2BINM[DECCOMBMSD[sourhi&gt;&gt;26]];}
574 
575     #elif DECPMAX==34
576     #define GETCOEFFBILL(df, buf) {                           \
577       uInt sourhi, sourmh, sourml, sourlo;                    \
578       sourlo=DFWORD(df, 3);                                   \
579       (buf)[0]=DPD2BIN0[sourlo&amp;0x3ff]                         \
580               +DPD2BINK[(sourlo&gt;&gt;10)&amp;0x3ff]                   \
581               +DPD2BINM[(sourlo&gt;&gt;20)&amp;0x3ff];                  \
582       sourml=DFWORD(df, 2);                                   \
583       (buf)[1]=DPD2BIN0[((sourml&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff]   \
584               +DPD2BINK[(sourml&gt;&gt;8)&amp;0x3ff]                    \
585               +DPD2BINM[(sourml&gt;&gt;18)&amp;0x3ff];                  \
586       sourmh=DFWORD(df, 1);                                   \
587       (buf)[2]=DPD2BIN0[((sourmh&lt;&lt;4) | (sourml&gt;&gt;28))&amp;0x3ff]   \
588               +DPD2BINK[(sourmh&gt;&gt;6)&amp;0x3ff]                    \
589               +DPD2BINM[(sourmh&gt;&gt;16)&amp;0x3ff];                  \
590       sourhi=DFWORD(df, 0);                                   \
591       (buf)[3]=DPD2BIN0[((sourhi&lt;&lt;6) | (sourmh&gt;&gt;26))&amp;0x3ff]   \
592               +DPD2BINK[(sourhi&gt;&gt;4)&amp;0x3ff]                    \
593               +DPD2BINM[DECCOMBMSD[sourhi&gt;&gt;26]];}
594 
595     #endif
596 
597     /* Macros to decode the coefficient in a finite decFloat *df into */
598     /* a base-thousand uInt array (of size DECLETS+1, to allow for    */
599     /* the MSD), with the least-significant 0-999 &#39;digit&#39; at offset 0.*/
600 
601     /* Decode the declets.  After extracting each one, it is decoded  */
602     /* to binary using a table lookup.                                */
603     #if DECPMAX==7
604     #define GETCOEFFTHOU(df, buf) {                           \
605       uInt sourhi=DFWORD(df, 0);                              \
606       (buf)[0]=DPD2BIN[sourhi&amp;0x3ff];                         \
607       (buf)[1]=DPD2BIN[(sourhi&gt;&gt;10)&amp;0x3ff];                   \
608       (buf)[2]=DECCOMBMSD[sourhi&gt;&gt;26];}
609 
610     #elif DECPMAX==16
611     #define GETCOEFFTHOU(df, buf) {                           \
612       uInt sourhi, sourlo;                                    \
613       sourlo=DFWORD(df, 1);                                   \
614       (buf)[0]=DPD2BIN[sourlo&amp;0x3ff];                         \
615       (buf)[1]=DPD2BIN[(sourlo&gt;&gt;10)&amp;0x3ff];                   \
616       (buf)[2]=DPD2BIN[(sourlo&gt;&gt;20)&amp;0x3ff];                   \
617       sourhi=DFWORD(df, 0);                                   \
618       (buf)[3]=DPD2BIN[((sourhi&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff];   \
619       (buf)[4]=DPD2BIN[(sourhi&gt;&gt;8)&amp;0x3ff];                    \
620       (buf)[5]=DECCOMBMSD[sourhi&gt;&gt;26];}
621 
622     #elif DECPMAX==34
623     #define GETCOEFFTHOU(df, buf) {                           \
624       uInt sourhi, sourmh, sourml, sourlo;                    \
625       sourlo=DFWORD(df, 3);                                   \
626       (buf)[0]=DPD2BIN[sourlo&amp;0x3ff];                         \
627       (buf)[1]=DPD2BIN[(sourlo&gt;&gt;10)&amp;0x3ff];                   \
628       (buf)[2]=DPD2BIN[(sourlo&gt;&gt;20)&amp;0x3ff];                   \
629       sourml=DFWORD(df, 2);                                   \
630       (buf)[3]=DPD2BIN[((sourml&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff];   \
631       (buf)[4]=DPD2BIN[(sourml&gt;&gt;8)&amp;0x3ff];                    \
632       (buf)[5]=DPD2BIN[(sourml&gt;&gt;18)&amp;0x3ff];                   \
633       sourmh=DFWORD(df, 1);                                   \
634       (buf)[6]=DPD2BIN[((sourmh&lt;&lt;4) | (sourml&gt;&gt;28))&amp;0x3ff];   \
635       (buf)[7]=DPD2BIN[(sourmh&gt;&gt;6)&amp;0x3ff];                    \
636       (buf)[8]=DPD2BIN[(sourmh&gt;&gt;16)&amp;0x3ff];                   \
637       sourhi=DFWORD(df, 0);                                   \
638       (buf)[9]=DPD2BIN[((sourhi&lt;&lt;6) | (sourmh&gt;&gt;26))&amp;0x3ff];   \
639       (buf)[10]=DPD2BIN[(sourhi&gt;&gt;4)&amp;0x3ff];                   \
640       (buf)[11]=DECCOMBMSD[sourhi&gt;&gt;26];}
641     #endif
642 
643 
644     /* Macros to decode the coefficient in a finite decFloat *df and  */
645     /* add to a base-thousand uInt array (as for GETCOEFFTHOU).       */
646     /* After the addition then most significant &#39;digit&#39; in the array  */
647     /* might have a value larger then 10 (with a maximum of 19).      */
648     #if DECPMAX==7
649     #define ADDCOEFFTHOU(df, buf) {                           \
650       uInt sourhi=DFWORD(df, 0);                              \
651       (buf)[0]+=DPD2BIN[sourhi&amp;0x3ff];                        \
652       if (buf[0]&gt;999) {buf[0]-=1000; buf[1]++;}               \
653       (buf)[1]+=DPD2BIN[(sourhi&gt;&gt;10)&amp;0x3ff];                  \
654       if (buf[1]&gt;999) {buf[1]-=1000; buf[2]++;}               \
655       (buf)[2]+=DECCOMBMSD[sourhi&gt;&gt;26];}
656 
657     #elif DECPMAX==16
658     #define ADDCOEFFTHOU(df, buf) {                           \
659       uInt sourhi, sourlo;                                    \
660       sourlo=DFWORD(df, 1);                                   \
661       (buf)[0]+=DPD2BIN[sourlo&amp;0x3ff];                        \
662       if (buf[0]&gt;999) {buf[0]-=1000; buf[1]++;}               \
663       (buf)[1]+=DPD2BIN[(sourlo&gt;&gt;10)&amp;0x3ff];                  \
664       if (buf[1]&gt;999) {buf[1]-=1000; buf[2]++;}               \
665       (buf)[2]+=DPD2BIN[(sourlo&gt;&gt;20)&amp;0x3ff];                  \
666       if (buf[2]&gt;999) {buf[2]-=1000; buf[3]++;}               \
667       sourhi=DFWORD(df, 0);                                   \
668       (buf)[3]+=DPD2BIN[((sourhi&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff];  \
669       if (buf[3]&gt;999) {buf[3]-=1000; buf[4]++;}               \
670       (buf)[4]+=DPD2BIN[(sourhi&gt;&gt;8)&amp;0x3ff];                   \
671       if (buf[4]&gt;999) {buf[4]-=1000; buf[5]++;}               \
672       (buf)[5]+=DECCOMBMSD[sourhi&gt;&gt;26];}
673 
674     #elif DECPMAX==34
675     #define ADDCOEFFTHOU(df, buf) {                           \
676       uInt sourhi, sourmh, sourml, sourlo;                    \
677       sourlo=DFWORD(df, 3);                                   \
678       (buf)[0]+=DPD2BIN[sourlo&amp;0x3ff];                        \
679       if (buf[0]&gt;999) {buf[0]-=1000; buf[1]++;}               \
680       (buf)[1]+=DPD2BIN[(sourlo&gt;&gt;10)&amp;0x3ff];                  \
681       if (buf[1]&gt;999) {buf[1]-=1000; buf[2]++;}               \
682       (buf)[2]+=DPD2BIN[(sourlo&gt;&gt;20)&amp;0x3ff];                  \
683       if (buf[2]&gt;999) {buf[2]-=1000; buf[3]++;}               \
684       sourml=DFWORD(df, 2);                                   \
685       (buf)[3]+=DPD2BIN[((sourml&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff];  \
686       if (buf[3]&gt;999) {buf[3]-=1000; buf[4]++;}               \
687       (buf)[4]+=DPD2BIN[(sourml&gt;&gt;8)&amp;0x3ff];                   \
688       if (buf[4]&gt;999) {buf[4]-=1000; buf[5]++;}               \
689       (buf)[5]+=DPD2BIN[(sourml&gt;&gt;18)&amp;0x3ff];                  \
690       if (buf[5]&gt;999) {buf[5]-=1000; buf[6]++;}               \
691       sourmh=DFWORD(df, 1);                                   \
692       (buf)[6]+=DPD2BIN[((sourmh&lt;&lt;4) | (sourml&gt;&gt;28))&amp;0x3ff];  \
693       if (buf[6]&gt;999) {buf[6]-=1000; buf[7]++;}               \
694       (buf)[7]+=DPD2BIN[(sourmh&gt;&gt;6)&amp;0x3ff];                   \
695       if (buf[7]&gt;999) {buf[7]-=1000; buf[8]++;}               \
696       (buf)[8]+=DPD2BIN[(sourmh&gt;&gt;16)&amp;0x3ff];                  \
697       if (buf[8]&gt;999) {buf[8]-=1000; buf[9]++;}               \
698       sourhi=DFWORD(df, 0);                                   \
699       (buf)[9]+=DPD2BIN[((sourhi&lt;&lt;6) | (sourmh&gt;&gt;26))&amp;0x3ff];  \
700       if (buf[9]&gt;999) {buf[9]-=1000; buf[10]++;}              \
701       (buf)[10]+=DPD2BIN[(sourhi&gt;&gt;4)&amp;0x3ff];                  \
702       if (buf[10]&gt;999) {buf[10]-=1000; buf[11]++;}            \
703       (buf)[11]+=DECCOMBMSD[sourhi&gt;&gt;26];}
704     #endif
705 
706 
707     /* Set a decFloat to the maximum positive finite number (Nmax)    */
708     #if DECPMAX==7
709     #define DFSETNMAX(df)            \
710       {DFWORD(df, 0)=0x77f3fcff;}
711     #elif DECPMAX==16
712     #define DFSETNMAX(df)            \
713       {DFWORD(df, 0)=0x77fcff3f;     \
714        DFWORD(df, 1)=0xcff3fcff;}
715     #elif DECPMAX==34
716     #define DFSETNMAX(df)            \
717       {DFWORD(df, 0)=0x77ffcff3;     \
718        DFWORD(df, 1)=0xfcff3fcf;     \
719        DFWORD(df, 2)=0xf3fcff3f;     \
720        DFWORD(df, 3)=0xcff3fcff;}
721     #endif
722 
723   /* [end of format-dependent macros and constants]                   */
724   #endif
725 
726 #else
727   #error decNumberLocal included more than once
728 #endif
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>