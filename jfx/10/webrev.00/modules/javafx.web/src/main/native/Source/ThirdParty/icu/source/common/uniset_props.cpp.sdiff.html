<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uniset_props.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="uniset_closure.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="unistr.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uniset_props.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19 */
  20 
  21 #include &quot;unicode/utypes.h&quot;
  22 #include &quot;unicode/uniset.h&quot;
  23 #include &quot;unicode/parsepos.h&quot;
  24 #include &quot;unicode/uchar.h&quot;
  25 #include &quot;unicode/uscript.h&quot;
  26 #include &quot;unicode/symtable.h&quot;
  27 #include &quot;unicode/uset.h&quot;
  28 #include &quot;unicode/locid.h&quot;
  29 #include &quot;unicode/brkiter.h&quot;
  30 #include &quot;uset_imp.h&quot;
  31 #include &quot;ruleiter.h&quot;
  32 #include &quot;cmemory.h&quot;
  33 #include &quot;ucln_cmn.h&quot;
  34 #include &quot;util.h&quot;
  35 #include &quot;uvector.h&quot;
  36 #include &quot;uprops.h&quot;
  37 #include &quot;propname.h&quot;
  38 #include &quot;normalizer2impl.h&quot;
<span class="line-removed">  39 #include &quot;ucase.h&quot;</span>
<span class="line-removed">  40 #include &quot;ubidi_props.h&quot;</span>
  41 #include &quot;uinvchar.h&quot;
  42 #include &quot;uprops.h&quot;
  43 #include &quot;charstr.h&quot;
  44 #include &quot;cstring.h&quot;
  45 #include &quot;mutex.h&quot;
  46 #include &quot;umutex.h&quot;
  47 #include &quot;uassert.h&quot;
  48 #include &quot;hash.h&quot;
  49 
  50 U_NAMESPACE_USE
  51 
<span class="line-removed">  52 // initial storage. Must be &gt;= 0</span>
<span class="line-removed">  53 // *** same as in uniset.cpp ! ***</span>
<span class="line-removed">  54 #define START_EXTRA 16</span>
<span class="line-removed">  55 </span>
  56 // Define UChar constants using hex for EBCDIC compatibility
  57 // Used #define to reduce private static exports and memory access time.
  58 #define SET_OPEN        ((UChar)0x005B) /*[*/
  59 #define SET_CLOSE       ((UChar)0x005D) /*]*/
  60 #define HYPHEN          ((UChar)0x002D) /*-*/
  61 #define COMPLEMENT      ((UChar)0x005E) /*^*/
  62 #define COLON           ((UChar)0x003A) /*:*/
  63 #define BACKSLASH       ((UChar)0x005C) /*\*/
  64 #define INTERSECTION    ((UChar)0x0026) /*&amp;*/
  65 #define UPPER_U         ((UChar)0x0055) /*U*/
  66 #define LOWER_U         ((UChar)0x0075) /*u*/
  67 #define OPEN_BRACE      ((UChar)123)    /*{*/
  68 #define CLOSE_BRACE     ((UChar)125)    /*}*/
  69 #define UPPER_P         ((UChar)0x0050) /*P*/
  70 #define LOWER_P         ((UChar)0x0070) /*p*/
  71 #define UPPER_N         ((UChar)78)     /*N*/
  72 #define EQUALS          ((UChar)0x003D) /*=*/
  73 
  74 //static const UChar POSIX_OPEN[]  = { SET_OPEN,COLON,0 };  // &quot;[:&quot;
  75 static const UChar POSIX_CLOSE[] = { COLON,SET_CLOSE,0 };  // &quot;:]&quot;
</pre>
<hr />
<pre>
  81 // Special property set IDs
  82 static const char ANY[]   = &quot;ANY&quot;;   // [\u0000-\U0010FFFF]
  83 static const char ASCII[] = &quot;ASCII&quot;; // [\u0000-\u007F]
  84 static const char ASSIGNED[] = &quot;Assigned&quot;; // [:^Cn:]
  85 
  86 // Unicode name property alias
  87 #define NAME_PROP &quot;na&quot;
  88 #define NAME_PROP_LENGTH 2
  89 
  90 /**
  91  * Delimiter string used in patterns to close a category reference:
  92  * &quot;:]&quot;.  Example: &quot;[:Lu:]&quot;.
  93  */
  94 //static const UChar CATEGORY_CLOSE[] = {COLON, SET_CLOSE, 0x0000}; /* &quot;:]&quot; */
  95 
  96 // Cached sets ------------------------------------------------------------- ***
  97 
  98 U_CDECL_BEGIN
  99 static UBool U_CALLCONV uset_cleanup();
 100 
<span class="line-removed"> 101 struct Inclusion {</span>
<span class="line-removed"> 102     UnicodeSet  *fSet;</span>
<span class="line-removed"> 103     UInitOnce    fInitOnce;</span>
<span class="line-removed"> 104 };</span>
<span class="line-removed"> 105 static Inclusion gInclusions[UPROPS_SRC_COUNT]; // cached getInclusions()</span>
<span class="line-removed"> 106 </span>
 107 static UnicodeSet *uni32Singleton;
 108 static icu::UInitOnce uni32InitOnce = U_INITONCE_INITIALIZER;
 109 
<span class="line-removed"> 110 //----------------------------------------------------------------</span>
<span class="line-removed"> 111 // Inclusions list</span>
<span class="line-removed"> 112 //----------------------------------------------------------------</span>
<span class="line-removed"> 113 </span>
<span class="line-removed"> 114 // USetAdder implementation</span>
<span class="line-removed"> 115 // Does not use uset.h to reduce code dependencies</span>
<span class="line-removed"> 116 static void U_CALLCONV</span>
<span class="line-removed"> 117 _set_add(USet *set, UChar32 c) {</span>
<span class="line-removed"> 118     ((UnicodeSet *)set)-&gt;add(c);</span>
<span class="line-removed"> 119 }</span>
<span class="line-removed"> 120 </span>
<span class="line-removed"> 121 static void U_CALLCONV</span>
<span class="line-removed"> 122 _set_addRange(USet *set, UChar32 start, UChar32 end) {</span>
<span class="line-removed"> 123     ((UnicodeSet *)set)-&gt;add(start, end);</span>
<span class="line-removed"> 124 }</span>
<span class="line-removed"> 125 </span>
<span class="line-removed"> 126 static void U_CALLCONV</span>
<span class="line-removed"> 127 _set_addString(USet *set, const UChar *str, int32_t length) {</span>
<span class="line-removed"> 128     ((UnicodeSet *)set)-&gt;add(UnicodeString((UBool)(length&lt;0), str, length));</span>
<span class="line-removed"> 129 }</span>
<span class="line-removed"> 130 </span>
 131 /**
 132  * Cleanup function for UnicodeSet
 133  */
 134 static UBool U_CALLCONV uset_cleanup(void) {
<span class="line-removed"> 135     for(int32_t i = UPROPS_SRC_NONE; i &lt; UPROPS_SRC_COUNT; ++i) {</span>
<span class="line-removed"> 136         Inclusion &amp;in = gInclusions[i];</span>
<span class="line-removed"> 137         delete in.fSet;</span>
<span class="line-removed"> 138         in.fSet = NULL;</span>
<span class="line-removed"> 139         in.fInitOnce.reset();</span>
<span class="line-removed"> 140     }</span>
<span class="line-removed"> 141 </span>
 142     delete uni32Singleton;
 143     uni32Singleton = NULL;
 144     uni32InitOnce.reset();
 145     return TRUE;
 146 }
 147 
 148 U_CDECL_END
 149 
 150 U_NAMESPACE_BEGIN
 151 
<span class="line-removed"> 152 /*</span>
<span class="line-removed"> 153 Reduce excessive reallocation, and make it easier to detect initialization problems.</span>
<span class="line-removed"> 154 Usually you don&#39;t see smaller sets than this for Unicode 5.0.</span>
<span class="line-removed"> 155 */</span>
<span class="line-removed"> 156 #define DEFAULT_INCLUSION_CAPACITY 3072</span>
<span class="line-removed"> 157 </span>
<span class="line-removed"> 158 void U_CALLCONV UnicodeSet_initInclusion(int32_t src, UErrorCode &amp;status) {</span>
<span class="line-removed"> 159     // This function is invoked only via umtx_initOnce().</span>
<span class="line-removed"> 160     // This function is a friend of class UnicodeSet.</span>
<span class="line-removed"> 161 </span>
<span class="line-removed"> 162     U_ASSERT(src &gt;=0 &amp;&amp; src&lt;UPROPS_SRC_COUNT);</span>
<span class="line-removed"> 163     UnicodeSet * &amp;incl = gInclusions[src].fSet;</span>
<span class="line-removed"> 164     U_ASSERT(incl == NULL);</span>
<span class="line-removed"> 165 </span>
<span class="line-removed"> 166     incl = new UnicodeSet();</span>
<span class="line-removed"> 167     if (incl == NULL) {</span>
<span class="line-removed"> 168         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed"> 169         return;</span>
<span class="line-removed"> 170     }</span>
<span class="line-removed"> 171     USetAdder sa = {</span>
<span class="line-removed"> 172         (USet *)incl,</span>
<span class="line-removed"> 173         _set_add,</span>
<span class="line-removed"> 174         _set_addRange,</span>
<span class="line-removed"> 175         _set_addString,</span>
<span class="line-removed"> 176         NULL, // don&#39;t need remove()</span>
<span class="line-removed"> 177         NULL // don&#39;t need removeRange()</span>
<span class="line-removed"> 178     };</span>
<span class="line-removed"> 179 </span>
<span class="line-removed"> 180     incl-&gt;ensureCapacity(DEFAULT_INCLUSION_CAPACITY, status);</span>
<span class="line-removed"> 181     switch(src) {</span>
<span class="line-removed"> 182     case UPROPS_SRC_CHAR:</span>
<span class="line-removed"> 183         uchar_addPropertyStarts(&amp;sa, &amp;status);</span>
<span class="line-removed"> 184         break;</span>
<span class="line-removed"> 185     case UPROPS_SRC_PROPSVEC:</span>
<span class="line-removed"> 186         upropsvec_addPropertyStarts(&amp;sa, &amp;status);</span>
<span class="line-removed"> 187         break;</span>
<span class="line-removed"> 188     case UPROPS_SRC_CHAR_AND_PROPSVEC:</span>
<span class="line-removed"> 189         uchar_addPropertyStarts(&amp;sa, &amp;status);</span>
<span class="line-removed"> 190         upropsvec_addPropertyStarts(&amp;sa, &amp;status);</span>
<span class="line-removed"> 191         break;</span>
<span class="line-removed"> 192 #if !UCONFIG_NO_NORMALIZATION</span>
<span class="line-removed"> 193     case UPROPS_SRC_CASE_AND_NORM: {</span>
<span class="line-removed"> 194         const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(status);</span>
<span class="line-removed"> 195         if(U_SUCCESS(status)) {</span>
<span class="line-removed"> 196             impl-&gt;addPropertyStarts(&amp;sa, status);</span>
<span class="line-removed"> 197         }</span>
<span class="line-removed"> 198         ucase_addPropertyStarts(&amp;sa, &amp;status);</span>
<span class="line-removed"> 199         break;</span>
<span class="line-removed"> 200     }</span>
<span class="line-removed"> 201     case UPROPS_SRC_NFC: {</span>
<span class="line-removed"> 202         const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(status);</span>
<span class="line-removed"> 203         if(U_SUCCESS(status)) {</span>
<span class="line-removed"> 204             impl-&gt;addPropertyStarts(&amp;sa, status);</span>
<span class="line-removed"> 205         }</span>
<span class="line-removed"> 206         break;</span>
<span class="line-removed"> 207     }</span>
<span class="line-removed"> 208     case UPROPS_SRC_NFKC: {</span>
<span class="line-removed"> 209         const Normalizer2Impl *impl=Normalizer2Factory::getNFKCImpl(status);</span>
<span class="line-removed"> 210         if(U_SUCCESS(status)) {</span>
<span class="line-removed"> 211             impl-&gt;addPropertyStarts(&amp;sa, status);</span>
<span class="line-removed"> 212         }</span>
<span class="line-removed"> 213         break;</span>
<span class="line-removed"> 214     }</span>
<span class="line-removed"> 215     case UPROPS_SRC_NFKC_CF: {</span>
<span class="line-removed"> 216         const Normalizer2Impl *impl=Normalizer2Factory::getNFKC_CFImpl(status);</span>
<span class="line-removed"> 217         if(U_SUCCESS(status)) {</span>
<span class="line-removed"> 218             impl-&gt;addPropertyStarts(&amp;sa, status);</span>
<span class="line-removed"> 219         }</span>
<span class="line-removed"> 220         break;</span>
<span class="line-removed"> 221     }</span>
<span class="line-removed"> 222     case UPROPS_SRC_NFC_CANON_ITER: {</span>
<span class="line-removed"> 223         const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(status);</span>
<span class="line-removed"> 224         if(U_SUCCESS(status)) {</span>
<span class="line-removed"> 225             impl-&gt;addCanonIterPropertyStarts(&amp;sa, status);</span>
<span class="line-removed"> 226         }</span>
<span class="line-removed"> 227         break;</span>
<span class="line-removed"> 228     }</span>
<span class="line-removed"> 229 #endif</span>
<span class="line-removed"> 230     case UPROPS_SRC_CASE:</span>
<span class="line-removed"> 231         ucase_addPropertyStarts(&amp;sa, &amp;status);</span>
<span class="line-removed"> 232         break;</span>
<span class="line-removed"> 233     case UPROPS_SRC_BIDI:</span>
<span class="line-removed"> 234         ubidi_addPropertyStarts(&amp;sa, &amp;status);</span>
<span class="line-removed"> 235         break;</span>
<span class="line-removed"> 236     default:</span>
<span class="line-removed"> 237         status = U_INTERNAL_PROGRAM_ERROR;</span>
<span class="line-removed"> 238         break;</span>
<span class="line-removed"> 239     }</span>
<span class="line-removed"> 240 </span>
<span class="line-removed"> 241     if (U_FAILURE(status)) {</span>
<span class="line-removed"> 242         delete incl;</span>
<span class="line-removed"> 243         incl = NULL;</span>
<span class="line-removed"> 244         return;</span>
<span class="line-removed"> 245     }</span>
<span class="line-removed"> 246     // Compact for caching</span>
<span class="line-removed"> 247     incl-&gt;compact();</span>
<span class="line-removed"> 248     ucln_common_registerCleanup(UCLN_COMMON_USET, uset_cleanup);</span>
<span class="line-removed"> 249 }</span>
<span class="line-removed"> 250 </span>
<span class="line-removed"> 251 </span>
<span class="line-removed"> 252 </span>
<span class="line-removed"> 253 const UnicodeSet* UnicodeSet::getInclusions(int32_t src, UErrorCode &amp;status) {</span>
<span class="line-removed"> 254     U_ASSERT(src &gt;=0 &amp;&amp; src&lt;UPROPS_SRC_COUNT);</span>
<span class="line-removed"> 255     Inclusion &amp;i = gInclusions[src];</span>
<span class="line-removed"> 256     umtx_initOnce(i.fInitOnce, &amp;UnicodeSet_initInclusion, src, status);</span>
<span class="line-removed"> 257     return i.fSet;</span>
<span class="line-removed"> 258 }</span>
<span class="line-removed"> 259 </span>
 260 namespace {
 261 
 262 // Cache some sets for other services -------------------------------------- ***
 263 void U_CALLCONV createUni32Set(UErrorCode &amp;errorCode) {
 264     U_ASSERT(uni32Singleton == NULL);
 265     uni32Singleton = new UnicodeSet(UNICODE_STRING_SIMPLE(&quot;[:age=3.2:]&quot;), errorCode);
 266     if(uni32Singleton==NULL) {
 267         errorCode=U_MEMORY_ALLOCATION_ERROR;
 268     } else {
 269         uni32Singleton-&gt;freeze();
 270     }
 271     ucln_common_registerCleanup(UCLN_COMMON_USET, uset_cleanup);
 272 }
 273 
 274 
 275 U_CFUNC UnicodeSet *
 276 uniset_getUnicode32Instance(UErrorCode &amp;errorCode) {
 277     umtx_initOnce(uni32InitOnce, &amp;createUni32Set, errorCode);
 278     return uni32Singleton;
 279 }
</pre>
<hr />
<pre>
 312 }*/
 313 
 314 // TODO memory debugging provided inside uniset.cpp
 315 // could be made available here but probably obsolete with use of modern
 316 // memory leak checker tools
 317 #define _dbgct(me)
 318 
 319 }  // namespace
 320 
 321 //----------------------------------------------------------------
 322 // Constructors &amp;c
 323 //----------------------------------------------------------------
 324 
 325 /**
 326  * Constructs a set from the given pattern, optionally ignoring
 327  * white space.  See the class description for the syntax of the
 328  * pattern language.
 329  * @param pattern a string specifying what characters are in the set
 330  */
 331 UnicodeSet::UnicodeSet(const UnicodeString&amp; pattern,
<span class="line-modified"> 332                        UErrorCode&amp; status) :</span>
<span class="line-modified"> 333     len(0), capacity(START_EXTRA), list(0), bmpSet(0), buffer(0),</span>
<span class="line-removed"> 334     bufferCapacity(0), patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="line-removed"> 335     fFlags(0)</span>
<span class="line-removed"> 336 {</span>
<span class="line-removed"> 337     if(U_SUCCESS(status)){</span>
<span class="line-removed"> 338         list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="line-removed"> 339         /* test for NULL */</span>
<span class="line-removed"> 340         if(list == NULL) {</span>
<span class="line-removed"> 341             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed"> 342         }else{</span>
<span class="line-removed"> 343             allocateStrings(status);</span>
<span class="line-removed"> 344             applyPattern(pattern, status);</span>
<span class="line-removed"> 345         }</span>
<span class="line-removed"> 346     }</span>
 347     _dbgct(this);
 348 }
 349 
 350 //----------------------------------------------------------------
 351 // Public API
 352 //----------------------------------------------------------------
 353 
 354 UnicodeSet&amp; UnicodeSet::applyPattern(const UnicodeString&amp; pattern,
 355                                      UErrorCode&amp; status) {
 356     // Equivalent to
 357     //   return applyPattern(pattern, USET_IGNORE_SPACE, NULL, status);
 358     // but without dependency on closeOver().
 359     ParsePosition pos(0);
 360     applyPatternIgnoreSpace(pattern, pos, NULL, status);
 361     if (U_FAILURE(status)) return *this;
 362 
 363     int32_t i = pos.getIndex();
 364     // Skip over trailing whitespace
 365     ICU_Utility::skipWhitespace(pattern, i, TRUE);
 366     if (i != pattern.length()) {
</pre>
<hr />
<pre>
 874     UProperty prop;
 875     int32_t value;
 876 } IntPropertyContext;
 877 
 878 static UBool intPropertyFilter(UChar32 ch, void* context) {
 879     IntPropertyContext* c = (IntPropertyContext*)context;
 880     return u_getIntPropertyValue((UChar32) ch, c-&gt;prop) == c-&gt;value;
 881 }
 882 
 883 static UBool scriptExtensionsFilter(UChar32 ch, void* context) {
 884     return uscript_hasScript(ch, *(UScriptCode*)context);
 885 }
 886 
 887 }  // namespace
 888 
 889 /**
 890  * Generic filter-based scanning code for UCD property UnicodeSets.
 891  */
 892 void UnicodeSet::applyFilter(UnicodeSet::Filter filter,
 893                              void* context,
<span class="line-modified"> 894                              int32_t src,</span>
 895                              UErrorCode &amp;status) {
 896     if (U_FAILURE(status)) return;
 897 
 898     // Logically, walk through all Unicode characters, noting the start
 899     // and end of each range for which filter.contain(c) is
 900     // true.  Add each range to a set.
 901     //
 902     // To improve performance, use an inclusions set which
 903     // encodes information about character ranges that are known
 904     // to have identical properties.
<span class="line-modified"> 905     // getInclusions(src) contains exactly the first characters of</span>
<span class="line-modified"> 906     // same-value ranges for the given properties &quot;source&quot;.</span>
<span class="line-removed"> 907     const UnicodeSet* inclusions = getInclusions(src, status);</span>
<span class="line-removed"> 908     if (U_FAILURE(status)) {</span>
<span class="line-removed"> 909         return;</span>
<span class="line-removed"> 910     }</span>
 911 
 912     clear();
 913 
 914     UChar32 startHasProperty = -1;
 915     int32_t limitRange = inclusions-&gt;getRangeCount();
 916 
 917     for (int j=0; j&lt;limitRange; ++j) {
 918         // get current range
 919         UChar32 start = inclusions-&gt;getRangeStart(j);
 920         UChar32 end = inclusions-&gt;getRangeEnd(j);
 921 
 922         // for all the code points in the range, process
 923         for (UChar32 ch = start; ch &lt;= end; ++ch) {
 924             // only add to this UnicodeSet on inflection points --
 925             // where the hasProperty value changes to false
 926             if ((*filter)(ch, context)) {
 927                 if (startHasProperty &lt; 0) {
 928                     startHasProperty = ch;
 929                 }
 930             } else if (startHasProperty &gt;= 0) {
</pre>
<hr />
<pre>
 954             continue;
 955         }
 956         if (j &gt;= dstCapacity) return FALSE;
 957         dst[j++] = ch;
 958     }
 959     if (j &gt; 0 &amp;&amp; dst[j-1] == &#39; &#39;) --j;
 960     dst[j] = 0;
 961     return TRUE;
 962 }
 963 
 964 }  // namespace
 965 
 966 //----------------------------------------------------------------
 967 // Property set API
 968 //----------------------------------------------------------------
 969 
 970 #define FAIL(ec) {ec=U_ILLEGAL_ARGUMENT_ERROR; return *this;}
 971 
 972 UnicodeSet&amp;
 973 UnicodeSet::applyIntPropertyValue(UProperty prop, int32_t value, UErrorCode&amp; ec) {
<span class="line-modified"> 974     if (U_FAILURE(ec) || isFrozen()) return *this;</span>
<span class="line-removed"> 975 </span>
 976     if (prop == UCHAR_GENERAL_CATEGORY_MASK) {
<span class="line-modified"> 977         applyFilter(generalCategoryMaskFilter, &amp;value, UPROPS_SRC_CHAR, ec);</span>

 978     } else if (prop == UCHAR_SCRIPT_EXTENSIONS) {

 979         UScriptCode script = (UScriptCode)value;
<span class="line-modified"> 980         applyFilter(scriptExtensionsFilter, &amp;script, UPROPS_SRC_PROPSVEC, ec);</span>
<span class="line-modified"> 981     } else {</span>












 982         IntPropertyContext c = {prop, value};
<span class="line-modified"> 983         applyFilter(intPropertyFilter, &amp;c, uprops_getSource(prop), ec);</span>


 984     }
 985     return *this;
 986 }
 987 
 988 UnicodeSet&amp;
 989 UnicodeSet::applyPropertyAlias(const UnicodeString&amp; prop,
 990                                const UnicodeString&amp; value,
 991                                UErrorCode&amp; ec) {
 992     if (U_FAILURE(ec) || isFrozen()) return *this;
 993 
 994     // prop and value used to be converted to char * using the default
 995     // converter instead of the invariant conversion.
 996     // This should not be necessary because all Unicode property and value
 997     // names use only invariant characters.
 998     // If there are any variant characters, then we won&#39;t find them anyway.
 999     // Checking first avoids assertion failures in the conversion.
1000     if( !uprv_isInvariantUString(prop.getBuffer(), prop.length()) ||
1001         !uprv_isInvariantUString(value.getBuffer(), value.length())
1002     ) {
1003         FAIL(ec);
</pre>
<hr />
<pre>
1013 
1014     if (value.length() &gt; 0) {
1015         p = u_getPropertyEnum(pname.data());
1016         if (p == UCHAR_INVALID_CODE) FAIL(ec);
1017 
1018         // Treat gc as gcm
1019         if (p == UCHAR_GENERAL_CATEGORY) {
1020             p = UCHAR_GENERAL_CATEGORY_MASK;
1021         }
1022 
1023         if ((p &gt;= UCHAR_BINARY_START &amp;&amp; p &lt; UCHAR_BINARY_LIMIT) ||
1024             (p &gt;= UCHAR_INT_START &amp;&amp; p &lt; UCHAR_INT_LIMIT) ||
1025             (p &gt;= UCHAR_MASK_START &amp;&amp; p &lt; UCHAR_MASK_LIMIT)) {
1026             v = u_getPropertyValueEnum(p, vname.data());
1027             if (v == UCHAR_INVALID_CODE) {
1028                 // Handle numeric CCC
1029                 if (p == UCHAR_CANONICAL_COMBINING_CLASS ||
1030                     p == UCHAR_TRAIL_CANONICAL_COMBINING_CLASS ||
1031                     p == UCHAR_LEAD_CANONICAL_COMBINING_CLASS) {
1032                     char* end;
<span class="line-modified">1033                     double value = uprv_strtod(vname.data(), &amp;end);</span>
1034                     // Anything between 0 and 255 is valid even if unused.
1035                     // Cast double-&gt;int only after range check.
1036                     // We catch NaN here because comparing it with both 0 and 255 will be false
1037                     // (as are all comparisons with NaN).
<span class="line-modified">1038                     if (*end != 0 || !(0 &lt;= value &amp;&amp; value &lt;= 255) ||</span>
<span class="line-modified">1039                             (v = (int32_t)value) != value) {</span>
1040                         // non-integral value or outside 0..255, or trailing junk
1041                         FAIL(ec);
1042                     }
1043                 } else {
1044                     FAIL(ec);
1045                 }
1046             }
1047         }
1048 
1049         else {
1050 
1051             switch (p) {
1052             case UCHAR_NUMERIC_VALUE:
1053                 {
1054                     char* end;
<span class="line-modified">1055                     double value = uprv_strtod(vname.data(), &amp;end);</span>
1056                     if (*end != 0) {
1057                         FAIL(ec);
1058                     }
<span class="line-modified">1059                     applyFilter(numericValueFilter, &amp;value, UPROPS_SRC_CHAR, ec);</span>

1060                     return *this;
1061                 }
1062             case UCHAR_NAME:
1063                 {
1064                     // Must munge name, since u_charFromName() does not do
1065                     // &#39;loose&#39; matching.
1066                     char buf[128]; // it suffices that this be &gt; uprv_getMaxCharNameLength
1067                     if (!mungeCharName(buf, vname.data(), sizeof(buf))) FAIL(ec);
1068                     UChar32 ch = u_charFromName(U_EXTENDED_CHAR_NAME, buf, &amp;ec);
1069                     if (U_SUCCESS(ec)) {
1070                         clear();
1071                         add(ch);
1072                         return *this;
1073                     } else {
1074                         FAIL(ec);
1075                     }
1076                 }
1077             case UCHAR_UNICODE_1_NAME:
1078                 // ICU 49 deprecates the Unicode_1_Name property APIs.
1079                 FAIL(ec);
1080             case UCHAR_AGE:
1081                 {
1082                     // Must munge name, since u_versionFromString() does not do
1083                     // &#39;loose&#39; matching.
1084                     char buf[128];
1085                     if (!mungeCharName(buf, vname.data(), sizeof(buf))) FAIL(ec);
1086                     UVersionInfo version;
1087                     u_versionFromString(version, buf);
<span class="line-modified">1088                     applyFilter(versionFilter, &amp;version, UPROPS_SRC_PROPSVEC, ec);</span>

1089                     return *this;
1090                 }
1091             case UCHAR_SCRIPT_EXTENSIONS:
1092                 v = u_getPropertyValueEnum(UCHAR_SCRIPT, vname.data());
1093                 if (v == UCHAR_INVALID_CODE) {
1094                     FAIL(ec);
1095                 }
1096                 // fall through to calling applyIntPropertyValue()
1097                 break;
1098             default:
1099                 // p is a non-binary, non-enumerated property that we
1100                 // don&#39;t support (yet).
1101                 FAIL(ec);
1102             }
1103         }
1104     }
1105 
1106     else {
1107         // value is empty.  Interpret as General Category, Script, or
1108         // Binary property.
</pre>
</td>
<td>
<hr />
<pre>
  19 */
  20 
  21 #include &quot;unicode/utypes.h&quot;
  22 #include &quot;unicode/uniset.h&quot;
  23 #include &quot;unicode/parsepos.h&quot;
  24 #include &quot;unicode/uchar.h&quot;
  25 #include &quot;unicode/uscript.h&quot;
  26 #include &quot;unicode/symtable.h&quot;
  27 #include &quot;unicode/uset.h&quot;
  28 #include &quot;unicode/locid.h&quot;
  29 #include &quot;unicode/brkiter.h&quot;
  30 #include &quot;uset_imp.h&quot;
  31 #include &quot;ruleiter.h&quot;
  32 #include &quot;cmemory.h&quot;
  33 #include &quot;ucln_cmn.h&quot;
  34 #include &quot;util.h&quot;
  35 #include &quot;uvector.h&quot;
  36 #include &quot;uprops.h&quot;
  37 #include &quot;propname.h&quot;
  38 #include &quot;normalizer2impl.h&quot;


  39 #include &quot;uinvchar.h&quot;
  40 #include &quot;uprops.h&quot;
  41 #include &quot;charstr.h&quot;
  42 #include &quot;cstring.h&quot;
  43 #include &quot;mutex.h&quot;
  44 #include &quot;umutex.h&quot;
  45 #include &quot;uassert.h&quot;
  46 #include &quot;hash.h&quot;
  47 
  48 U_NAMESPACE_USE
  49 




  50 // Define UChar constants using hex for EBCDIC compatibility
  51 // Used #define to reduce private static exports and memory access time.
  52 #define SET_OPEN        ((UChar)0x005B) /*[*/
  53 #define SET_CLOSE       ((UChar)0x005D) /*]*/
  54 #define HYPHEN          ((UChar)0x002D) /*-*/
  55 #define COMPLEMENT      ((UChar)0x005E) /*^*/
  56 #define COLON           ((UChar)0x003A) /*:*/
  57 #define BACKSLASH       ((UChar)0x005C) /*\*/
  58 #define INTERSECTION    ((UChar)0x0026) /*&amp;*/
  59 #define UPPER_U         ((UChar)0x0055) /*U*/
  60 #define LOWER_U         ((UChar)0x0075) /*u*/
  61 #define OPEN_BRACE      ((UChar)123)    /*{*/
  62 #define CLOSE_BRACE     ((UChar)125)    /*}*/
  63 #define UPPER_P         ((UChar)0x0050) /*P*/
  64 #define LOWER_P         ((UChar)0x0070) /*p*/
  65 #define UPPER_N         ((UChar)78)     /*N*/
  66 #define EQUALS          ((UChar)0x003D) /*=*/
  67 
  68 //static const UChar POSIX_OPEN[]  = { SET_OPEN,COLON,0 };  // &quot;[:&quot;
  69 static const UChar POSIX_CLOSE[] = { COLON,SET_CLOSE,0 };  // &quot;:]&quot;
</pre>
<hr />
<pre>
  75 // Special property set IDs
  76 static const char ANY[]   = &quot;ANY&quot;;   // [\u0000-\U0010FFFF]
  77 static const char ASCII[] = &quot;ASCII&quot;; // [\u0000-\u007F]
  78 static const char ASSIGNED[] = &quot;Assigned&quot;; // [:^Cn:]
  79 
  80 // Unicode name property alias
  81 #define NAME_PROP &quot;na&quot;
  82 #define NAME_PROP_LENGTH 2
  83 
  84 /**
  85  * Delimiter string used in patterns to close a category reference:
  86  * &quot;:]&quot;.  Example: &quot;[:Lu:]&quot;.
  87  */
  88 //static const UChar CATEGORY_CLOSE[] = {COLON, SET_CLOSE, 0x0000}; /* &quot;:]&quot; */
  89 
  90 // Cached sets ------------------------------------------------------------- ***
  91 
  92 U_CDECL_BEGIN
  93 static UBool U_CALLCONV uset_cleanup();
  94 






  95 static UnicodeSet *uni32Singleton;
  96 static icu::UInitOnce uni32InitOnce = U_INITONCE_INITIALIZER;
  97 





















  98 /**
  99  * Cleanup function for UnicodeSet
 100  */
 101 static UBool U_CALLCONV uset_cleanup(void) {







 102     delete uni32Singleton;
 103     uni32Singleton = NULL;
 104     uni32InitOnce.reset();
 105     return TRUE;
 106 }
 107 
 108 U_CDECL_END
 109 
 110 U_NAMESPACE_BEGIN
 111 












































































































 112 namespace {
 113 
 114 // Cache some sets for other services -------------------------------------- ***
 115 void U_CALLCONV createUni32Set(UErrorCode &amp;errorCode) {
 116     U_ASSERT(uni32Singleton == NULL);
 117     uni32Singleton = new UnicodeSet(UNICODE_STRING_SIMPLE(&quot;[:age=3.2:]&quot;), errorCode);
 118     if(uni32Singleton==NULL) {
 119         errorCode=U_MEMORY_ALLOCATION_ERROR;
 120     } else {
 121         uni32Singleton-&gt;freeze();
 122     }
 123     ucln_common_registerCleanup(UCLN_COMMON_USET, uset_cleanup);
 124 }
 125 
 126 
 127 U_CFUNC UnicodeSet *
 128 uniset_getUnicode32Instance(UErrorCode &amp;errorCode) {
 129     umtx_initOnce(uni32InitOnce, &amp;createUni32Set, errorCode);
 130     return uni32Singleton;
 131 }
</pre>
<hr />
<pre>
 164 }*/
 165 
 166 // TODO memory debugging provided inside uniset.cpp
 167 // could be made available here but probably obsolete with use of modern
 168 // memory leak checker tools
 169 #define _dbgct(me)
 170 
 171 }  // namespace
 172 
 173 //----------------------------------------------------------------
 174 // Constructors &amp;c
 175 //----------------------------------------------------------------
 176 
 177 /**
 178  * Constructs a set from the given pattern, optionally ignoring
 179  * white space.  See the class description for the syntax of the
 180  * pattern language.
 181  * @param pattern a string specifying what characters are in the set
 182  */
 183 UnicodeSet::UnicodeSet(const UnicodeString&amp; pattern,
<span class="line-modified"> 184                        UErrorCode&amp; status) {</span>
<span class="line-modified"> 185     applyPattern(pattern, status);</span>













 186     _dbgct(this);
 187 }
 188 
 189 //----------------------------------------------------------------
 190 // Public API
 191 //----------------------------------------------------------------
 192 
 193 UnicodeSet&amp; UnicodeSet::applyPattern(const UnicodeString&amp; pattern,
 194                                      UErrorCode&amp; status) {
 195     // Equivalent to
 196     //   return applyPattern(pattern, USET_IGNORE_SPACE, NULL, status);
 197     // but without dependency on closeOver().
 198     ParsePosition pos(0);
 199     applyPatternIgnoreSpace(pattern, pos, NULL, status);
 200     if (U_FAILURE(status)) return *this;
 201 
 202     int32_t i = pos.getIndex();
 203     // Skip over trailing whitespace
 204     ICU_Utility::skipWhitespace(pattern, i, TRUE);
 205     if (i != pattern.length()) {
</pre>
<hr />
<pre>
 713     UProperty prop;
 714     int32_t value;
 715 } IntPropertyContext;
 716 
 717 static UBool intPropertyFilter(UChar32 ch, void* context) {
 718     IntPropertyContext* c = (IntPropertyContext*)context;
 719     return u_getIntPropertyValue((UChar32) ch, c-&gt;prop) == c-&gt;value;
 720 }
 721 
 722 static UBool scriptExtensionsFilter(UChar32 ch, void* context) {
 723     return uscript_hasScript(ch, *(UScriptCode*)context);
 724 }
 725 
 726 }  // namespace
 727 
 728 /**
 729  * Generic filter-based scanning code for UCD property UnicodeSets.
 730  */
 731 void UnicodeSet::applyFilter(UnicodeSet::Filter filter,
 732                              void* context,
<span class="line-modified"> 733                              const UnicodeSet* inclusions,</span>
 734                              UErrorCode &amp;status) {
 735     if (U_FAILURE(status)) return;
 736 
 737     // Logically, walk through all Unicode characters, noting the start
 738     // and end of each range for which filter.contain(c) is
 739     // true.  Add each range to a set.
 740     //
 741     // To improve performance, use an inclusions set which
 742     // encodes information about character ranges that are known
 743     // to have identical properties.
<span class="line-modified"> 744     // inclusions contains the first characters of</span>
<span class="line-modified"> 745     // same-value ranges for the given property.</span>




 746 
 747     clear();
 748 
 749     UChar32 startHasProperty = -1;
 750     int32_t limitRange = inclusions-&gt;getRangeCount();
 751 
 752     for (int j=0; j&lt;limitRange; ++j) {
 753         // get current range
 754         UChar32 start = inclusions-&gt;getRangeStart(j);
 755         UChar32 end = inclusions-&gt;getRangeEnd(j);
 756 
 757         // for all the code points in the range, process
 758         for (UChar32 ch = start; ch &lt;= end; ++ch) {
 759             // only add to this UnicodeSet on inflection points --
 760             // where the hasProperty value changes to false
 761             if ((*filter)(ch, context)) {
 762                 if (startHasProperty &lt; 0) {
 763                     startHasProperty = ch;
 764                 }
 765             } else if (startHasProperty &gt;= 0) {
</pre>
<hr />
<pre>
 789             continue;
 790         }
 791         if (j &gt;= dstCapacity) return FALSE;
 792         dst[j++] = ch;
 793     }
 794     if (j &gt; 0 &amp;&amp; dst[j-1] == &#39; &#39;) --j;
 795     dst[j] = 0;
 796     return TRUE;
 797 }
 798 
 799 }  // namespace
 800 
 801 //----------------------------------------------------------------
 802 // Property set API
 803 //----------------------------------------------------------------
 804 
 805 #define FAIL(ec) {ec=U_ILLEGAL_ARGUMENT_ERROR; return *this;}
 806 
 807 UnicodeSet&amp;
 808 UnicodeSet::applyIntPropertyValue(UProperty prop, int32_t value, UErrorCode&amp; ec) {
<span class="line-modified"> 809     if (U_FAILURE(ec) || isFrozen()) { return *this; }</span>

 810     if (prop == UCHAR_GENERAL_CATEGORY_MASK) {
<span class="line-modified"> 811         const UnicodeSet* inclusions = CharacterProperties::getInclusionsForProperty(prop, ec);</span>
<span class="line-added"> 812         applyFilter(generalCategoryMaskFilter, &amp;value, inclusions, ec);</span>
 813     } else if (prop == UCHAR_SCRIPT_EXTENSIONS) {
<span class="line-added"> 814         const UnicodeSet* inclusions = CharacterProperties::getInclusionsForProperty(prop, ec);</span>
 815         UScriptCode script = (UScriptCode)value;
<span class="line-modified"> 816         applyFilter(scriptExtensionsFilter, &amp;script, inclusions, ec);</span>
<span class="line-modified"> 817     } else if (0 &lt;= prop &amp;&amp; prop &lt; UCHAR_BINARY_LIMIT) {</span>
<span class="line-added"> 818         if (value == 0 || value == 1) {</span>
<span class="line-added"> 819             const USet *set = u_getBinaryPropertySet(prop, &amp;ec);</span>
<span class="line-added"> 820             if (U_FAILURE(ec)) { return *this; }</span>
<span class="line-added"> 821             copyFrom(*UnicodeSet::fromUSet(set), TRUE);</span>
<span class="line-added"> 822             if (value == 0) {</span>
<span class="line-added"> 823                 complement();</span>
<span class="line-added"> 824             }</span>
<span class="line-added"> 825         } else {</span>
<span class="line-added"> 826             clear();</span>
<span class="line-added"> 827         }</span>
<span class="line-added"> 828     } else if (UCHAR_INT_START &lt;= prop &amp;&amp; prop &lt; UCHAR_INT_LIMIT) {</span>
<span class="line-added"> 829         const UnicodeSet* inclusions = CharacterProperties::getInclusionsForProperty(prop, ec);</span>
 830         IntPropertyContext c = {prop, value};
<span class="line-modified"> 831         applyFilter(intPropertyFilter, &amp;c, inclusions, ec);</span>
<span class="line-added"> 832     } else {</span>
<span class="line-added"> 833         ec = U_ILLEGAL_ARGUMENT_ERROR;</span>
 834     }
 835     return *this;
 836 }
 837 
 838 UnicodeSet&amp;
 839 UnicodeSet::applyPropertyAlias(const UnicodeString&amp; prop,
 840                                const UnicodeString&amp; value,
 841                                UErrorCode&amp; ec) {
 842     if (U_FAILURE(ec) || isFrozen()) return *this;
 843 
 844     // prop and value used to be converted to char * using the default
 845     // converter instead of the invariant conversion.
 846     // This should not be necessary because all Unicode property and value
 847     // names use only invariant characters.
 848     // If there are any variant characters, then we won&#39;t find them anyway.
 849     // Checking first avoids assertion failures in the conversion.
 850     if( !uprv_isInvariantUString(prop.getBuffer(), prop.length()) ||
 851         !uprv_isInvariantUString(value.getBuffer(), value.length())
 852     ) {
 853         FAIL(ec);
</pre>
<hr />
<pre>
 863 
 864     if (value.length() &gt; 0) {
 865         p = u_getPropertyEnum(pname.data());
 866         if (p == UCHAR_INVALID_CODE) FAIL(ec);
 867 
 868         // Treat gc as gcm
 869         if (p == UCHAR_GENERAL_CATEGORY) {
 870             p = UCHAR_GENERAL_CATEGORY_MASK;
 871         }
 872 
 873         if ((p &gt;= UCHAR_BINARY_START &amp;&amp; p &lt; UCHAR_BINARY_LIMIT) ||
 874             (p &gt;= UCHAR_INT_START &amp;&amp; p &lt; UCHAR_INT_LIMIT) ||
 875             (p &gt;= UCHAR_MASK_START &amp;&amp; p &lt; UCHAR_MASK_LIMIT)) {
 876             v = u_getPropertyValueEnum(p, vname.data());
 877             if (v == UCHAR_INVALID_CODE) {
 878                 // Handle numeric CCC
 879                 if (p == UCHAR_CANONICAL_COMBINING_CLASS ||
 880                     p == UCHAR_TRAIL_CANONICAL_COMBINING_CLASS ||
 881                     p == UCHAR_LEAD_CANONICAL_COMBINING_CLASS) {
 882                     char* end;
<span class="line-modified"> 883                     double val = uprv_strtod(vname.data(), &amp;end);</span>
 884                     // Anything between 0 and 255 is valid even if unused.
 885                     // Cast double-&gt;int only after range check.
 886                     // We catch NaN here because comparing it with both 0 and 255 will be false
 887                     // (as are all comparisons with NaN).
<span class="line-modified"> 888                     if (*end != 0 || !(0 &lt;= val &amp;&amp; val &lt;= 255) ||</span>
<span class="line-modified"> 889                             (v = (int32_t)val) != val) {</span>
 890                         // non-integral value or outside 0..255, or trailing junk
 891                         FAIL(ec);
 892                     }
 893                 } else {
 894                     FAIL(ec);
 895                 }
 896             }
 897         }
 898 
 899         else {
 900 
 901             switch (p) {
 902             case UCHAR_NUMERIC_VALUE:
 903                 {
 904                     char* end;
<span class="line-modified"> 905                     double val = uprv_strtod(vname.data(), &amp;end);</span>
 906                     if (*end != 0) {
 907                         FAIL(ec);
 908                     }
<span class="line-modified"> 909                     applyFilter(numericValueFilter, &amp;val,</span>
<span class="line-added"> 910                                 CharacterProperties::getInclusionsForProperty(p, ec), ec);</span>
 911                     return *this;
 912                 }
 913             case UCHAR_NAME:
 914                 {
 915                     // Must munge name, since u_charFromName() does not do
 916                     // &#39;loose&#39; matching.
 917                     char buf[128]; // it suffices that this be &gt; uprv_getMaxCharNameLength
 918                     if (!mungeCharName(buf, vname.data(), sizeof(buf))) FAIL(ec);
 919                     UChar32 ch = u_charFromName(U_EXTENDED_CHAR_NAME, buf, &amp;ec);
 920                     if (U_SUCCESS(ec)) {
 921                         clear();
 922                         add(ch);
 923                         return *this;
 924                     } else {
 925                         FAIL(ec);
 926                     }
 927                 }
 928             case UCHAR_UNICODE_1_NAME:
 929                 // ICU 49 deprecates the Unicode_1_Name property APIs.
 930                 FAIL(ec);
 931             case UCHAR_AGE:
 932                 {
 933                     // Must munge name, since u_versionFromString() does not do
 934                     // &#39;loose&#39; matching.
 935                     char buf[128];
 936                     if (!mungeCharName(buf, vname.data(), sizeof(buf))) FAIL(ec);
 937                     UVersionInfo version;
 938                     u_versionFromString(version, buf);
<span class="line-modified"> 939                     applyFilter(versionFilter, &amp;version,</span>
<span class="line-added"> 940                                 CharacterProperties::getInclusionsForProperty(p, ec), ec);</span>
 941                     return *this;
 942                 }
 943             case UCHAR_SCRIPT_EXTENSIONS:
 944                 v = u_getPropertyValueEnum(UCHAR_SCRIPT, vname.data());
 945                 if (v == UCHAR_INVALID_CODE) {
 946                     FAIL(ec);
 947                 }
 948                 // fall through to calling applyIntPropertyValue()
 949                 break;
 950             default:
 951                 // p is a non-binary, non-enumerated property that we
 952                 // don&#39;t support (yet).
 953                 FAIL(ec);
 954             }
 955         }
 956     }
 957 
 958     else {
 959         // value is empty.  Interpret as General Category, Script, or
 960         // Binary property.
</pre>
</td>
</tr>
</table>
<center><a href="uniset_closure.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="unistr.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>