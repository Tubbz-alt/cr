<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/utrie2_builder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="utrie2.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="utrie2_impl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/utrie2_builder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 ******************************************************************************
  10 *   file name:  utrie2_builder.cpp
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 2008sep26 (split off from utrie2.c)
  16 *   created by: Markus W. Scherer
  17 *
  18 *   This is a common implementation of a Unicode trie.
  19 *   It is a kind of compressed, serializable table of 16- or 32-bit values associated with
  20 *   Unicode code points (0..0x10ffff).
  21 *   This is the second common version of a Unicode trie (hence the name UTrie2).
  22 *   See utrie2.h for a comparison.
  23 *
  24 *   This file contains only the builder code.
  25 *   See utrie2.c for the runtime and enumeration code.
  26 */

  27 #ifdef UTRIE2_DEBUG
  28 #   include &lt;stdio.h&gt;
  29 #endif

  30 
  31 #include &quot;unicode/utypes.h&quot;





  32 #include &quot;cmemory.h&quot;
  33 #include &quot;utrie2.h&quot;
  34 #include &quot;utrie2_impl.h&quot;
  35 
<span class="line-modified">  36 #include &quot;utrie.h&quot; /* for utrie2_fromUTrie() and utrie_swap() */</span>
  37 
  38 /* Implementation notes ----------------------------------------------------- */
  39 
  40 /*
  41  * The UTRIE2_SHIFT_1, UTRIE2_SHIFT_2, UTRIE2_INDEX_SHIFT and other values
  42  * have been chosen to minimize trie sizes overall.
  43  * Most of the code is flexible enough to work with a range of values,
  44  * within certain limits.
  45  *
  46  * Exception: Support for separate values for lead surrogate code _units_
  47  * vs. code _points_ was added after the constants were fixed,
  48  * and has not been tested nor particularly designed for different constant values.
  49  * (Especially the utrie2_enum() code that jumps to the special LSCP index-2
  50  * part and back.)
  51  *
  52  * Requires UTRIE2_SHIFT_2&lt;=6. Otherwise 0xc0 which is the top of the ASCII-linear data
  53  * including the bad-UTF-8-data block is not a multiple of UTRIE2_DATA_BLOCK_LENGTH
  54  * and map[block&gt;&gt;UTRIE2_SHIFT_2] (used in reference counting and compaction
  55  * remapping) stops working.
  56  *
</pre>
<hr />
<pre>
 115     if(U_FAILURE(*pErrorCode)) {
 116         return NULL;
 117     }
 118 
 119     trie=(UTrie2 *)uprv_malloc(sizeof(UTrie2));
 120     newTrie=(UNewTrie2 *)uprv_malloc(sizeof(UNewTrie2));
 121     data=(uint32_t *)uprv_malloc(UNEWTRIE2_INITIAL_DATA_LENGTH*4);
 122     if(trie==NULL || newTrie==NULL || data==NULL) {
 123         uprv_free(trie);
 124         uprv_free(newTrie);
 125         uprv_free(data);
 126         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
 127         return 0;
 128     }
 129 
 130     uprv_memset(trie, 0, sizeof(UTrie2));
 131     trie-&gt;initialValue=initialValue;
 132     trie-&gt;errorValue=errorValue;
 133     trie-&gt;highStart=0x110000;
 134     trie-&gt;newTrie=newTrie;



 135 
 136     newTrie-&gt;data=data;



 137     newTrie-&gt;dataCapacity=UNEWTRIE2_INITIAL_DATA_LENGTH;
 138     newTrie-&gt;initialValue=initialValue;
 139     newTrie-&gt;errorValue=errorValue;
 140     newTrie-&gt;highStart=0x110000;
 141     newTrie-&gt;firstFreeBlock=0;  /* no free block in the list */
 142     newTrie-&gt;isCompacted=FALSE;
 143 
 144     /*
 145      * preallocate and reset
 146      * - ASCII
 147      * - the bad-UTF-8-data block
 148      * - the null data block
 149      */
 150     for(i=0; i&lt;0x80; ++i) {
 151         newTrie-&gt;data[i]=initialValue;
 152     }
 153     for(; i&lt;0xc0; ++i) {
 154         newTrie-&gt;data[i]=errorValue;
 155     }
 156     for(i=UNEWTRIE2_DATA_NULL_OFFSET; i&lt;UNEWTRIE2_DATA_START_OFFSET; ++i) {
</pre>
<hr />
<pre>
 229         utrie2_set32(trie, i, initialValue, pErrorCode);
 230     }
 231 
 232     return trie;
 233 }
 234 
 235 static UNewTrie2 *
 236 cloneBuilder(const UNewTrie2 *other) {
 237     UNewTrie2 *trie;
 238 
 239     trie=(UNewTrie2 *)uprv_malloc(sizeof(UNewTrie2));
 240     if(trie==NULL) {
 241         return NULL;
 242     }
 243 
 244     trie-&gt;data=(uint32_t *)uprv_malloc(other-&gt;dataCapacity*4);
 245     if(trie-&gt;data==NULL) {
 246         uprv_free(trie);
 247         return NULL;
 248     }








 249     trie-&gt;dataCapacity=other-&gt;dataCapacity;
 250 
 251     /* clone data */
 252     uprv_memcpy(trie-&gt;index1, other-&gt;index1, sizeof(trie-&gt;index1));
 253     uprv_memcpy(trie-&gt;index2, other-&gt;index2, (size_t)other-&gt;index2Length*4);
 254     trie-&gt;index2NullOffset=other-&gt;index2NullOffset;
 255     trie-&gt;index2Length=other-&gt;index2Length;
 256 
 257     uprv_memcpy(trie-&gt;data, other-&gt;data, (size_t)other-&gt;dataLength*4);
 258     trie-&gt;dataNullOffset=other-&gt;dataNullOffset;
 259     trie-&gt;dataLength=other-&gt;dataLength;
 260 
 261     /* reference counters */
 262     if(other-&gt;isCompacted) {
 263         trie-&gt;firstFreeBlock=0;
 264     } else {
 265         uprv_memcpy(trie-&gt;map, other-&gt;map, ((size_t)other-&gt;dataLength&gt;&gt;UTRIE2_SHIFT_2)*4);
 266         trie-&gt;firstFreeBlock=other-&gt;firstFreeBlock;
 267     }
 268 
</pre>
<hr />
<pre>
 271     trie-&gt;highStart=other-&gt;highStart;
 272     trie-&gt;isCompacted=other-&gt;isCompacted;
 273 
 274     return trie;
 275 }
 276 
 277 U_CAPI UTrie2 * U_EXPORT2
 278 utrie2_clone(const UTrie2 *other, UErrorCode *pErrorCode) {
 279     UTrie2 *trie;
 280 
 281     if(U_FAILURE(*pErrorCode)) {
 282         return NULL;
 283     }
 284     if(other==NULL || (other-&gt;memory==NULL &amp;&amp; other-&gt;newTrie==NULL)) {
 285         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
 286         return NULL;
 287     }
 288 
 289     trie=(UTrie2 *)uprv_malloc(sizeof(UTrie2));
 290     if(trie==NULL) {

 291         return NULL;
 292     }
 293     uprv_memcpy(trie, other, sizeof(UTrie2));
 294 
 295     if(other-&gt;memory!=NULL) {
 296         trie-&gt;memory=uprv_malloc(other-&gt;length);
 297         if(trie-&gt;memory!=NULL) {
 298             trie-&gt;isMemoryOwned=TRUE;
 299             uprv_memcpy(trie-&gt;memory, other-&gt;memory, other-&gt;length);
 300 
 301             /* make the clone&#39;s pointers point to its own memory */
 302             trie-&gt;index=(uint16_t *)trie-&gt;memory+(other-&gt;index-(uint16_t *)other-&gt;memory);
 303             if(other-&gt;data16!=NULL) {
 304                 trie-&gt;data16=(uint16_t *)trie-&gt;memory+(other-&gt;data16-(uint16_t *)other-&gt;memory);
 305             }
 306             if(other-&gt;data32!=NULL) {
 307                 trie-&gt;data32=(uint32_t *)trie-&gt;memory+(other-&gt;data32-(uint32_t *)other-&gt;memory);
 308             }
 309         }
 310     } else /* other-&gt;newTrie!=NULL */ {
 311         trie-&gt;newTrie=cloneBuilder(other-&gt;newTrie);
 312     }
 313 
 314     if(trie-&gt;memory==NULL &amp;&amp; trie-&gt;newTrie==NULL) {

 315         uprv_free(trie);
 316         trie=NULL;
 317     }
 318     return trie;
 319 }
 320 
 321 typedef struct NewTrieAndStatus {
 322     UTrie2 *trie;
 323     UErrorCode errorCode;
 324     UBool exclusiveLimit;  /* rather than inclusive range end */
 325 } NewTrieAndStatus;
 326 
 327 static UBool U_CALLCONV
 328 copyEnumRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {
 329     NewTrieAndStatus *nt=(NewTrieAndStatus *)context;
 330     if(value!=nt-&gt;trie-&gt;initialValue) {
 331         if(nt-&gt;exclusiveLimit) {
 332             --end;
 333         }
 334         if(start==end) {
 335             utrie2_set32(nt-&gt;trie, start, value, &amp;nt-&gt;errorCode);
 336         } else {
 337             utrie2_setRange32(nt-&gt;trie, start, end, value, TRUE, &amp;nt-&gt;errorCode);
 338         }
 339         return U_SUCCESS(nt-&gt;errorCode);
 340     } else {
 341         return TRUE;
 342     }
 343 }
 344 
 345 #ifdef UTRIE2_DEBUG
















 346 static void
 347 utrie_printLengths(const UTrie *trie) {
 348     long indexLength=trie-&gt;indexLength;
 349     long dataLength=(long)trie-&gt;dataLength;
 350     long totalLength=(long)sizeof(UTrieHeader)+indexLength*2+dataLength*(trie-&gt;data32!=NULL ? 4 : 2);
 351     printf(&quot;**UTrieLengths** index:%6ld  data:%6ld  serialized:%6ld\n&quot;,
 352            indexLength, dataLength, totalLength);
 353 }
 354 
 355 static void
 356 utrie2_printLengths(const UTrie2 *trie, const char *which) {
 357     long indexLength=trie-&gt;indexLength;
 358     long dataLength=(long)trie-&gt;dataLength;
 359     long totalLength=(long)sizeof(UTrie2Header)+indexLength*2+dataLength*(trie-&gt;data32!=NULL ? 4 : 2);
<span class="line-modified"> 360     printf(&quot;**UTrie2Lengths(%s)** index:%6ld  data:%6ld  serialized:%6ld\n&quot;,</span>
<span class="line-modified"> 361            which, indexLength, dataLength, totalLength);</span>
 362 }
 363 #endif
 364 
 365 U_CAPI UTrie2 * U_EXPORT2
 366 utrie2_cloneAsThawed(const UTrie2 *other, UErrorCode *pErrorCode) {
 367     NewTrieAndStatus context;
 368     UChar lead;
 369 
 370     if(U_FAILURE(*pErrorCode)) {
 371         return NULL;
 372     }
 373     if(other==NULL || (other-&gt;memory==NULL &amp;&amp; other-&gt;newTrie==NULL)) {
 374         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
 375         return NULL;
 376     }
 377     if(other-&gt;newTrie!=NULL &amp;&amp; !other-&gt;newTrie-&gt;isCompacted) {
 378         return utrie2_clone(other, pErrorCode);  /* clone an unfrozen trie */
 379     }
 380 
 381     /* Clone the frozen trie by enumerating it and building a new one. */
</pre>
<hr />
<pre>
 605         /* out of memory in the data array */
 606         return -1;
 607     }
 608     setIndex2Entry(trie, i2, newBlock);
 609     return newBlock;
 610 }
 611 
 612 /**
 613  * @return TRUE if the value was successfully set
 614  */
 615 static void
 616 set32(UNewTrie2 *trie,
 617       UChar32 c, UBool forLSCP, uint32_t value,
 618       UErrorCode *pErrorCode) {
 619     int32_t block;
 620 
 621     if(trie==NULL || trie-&gt;isCompacted) {
 622         *pErrorCode=U_NO_WRITE_PERMISSION;
 623         return;
 624     }



 625 
 626     block=getDataBlock(trie, c, forLSCP);
 627     if(block&lt;0) {
 628         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
 629         return;
 630     }
 631 
 632     trie-&gt;data[block+(c&amp;UTRIE2_DATA_MASK)]=value;
 633 }
 634 
 635 U_CAPI void U_EXPORT2
 636 utrie2_set32(UTrie2 *trie, UChar32 c, uint32_t value, UErrorCode *pErrorCode) {
 637     if(U_FAILURE(*pErrorCode)) {
 638         return;
 639     }
 640     if((uint32_t)c&gt;0x10ffff) {
 641         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
 642         return;
 643     }
 644     set32(trie-&gt;newTrie, c, TRUE, value, pErrorCode);
</pre>
<hr />
<pre>
 700      * repeat value in [start..end]
 701      * mark index values for repeat-data blocks by setting bit 31 of the index values
 702      * fill around existing values if any, if(overwrite)
 703      */
 704     UNewTrie2 *newTrie;
 705     int32_t block, rest, repeatBlock;
 706     UChar32 limit;
 707 
 708     if(U_FAILURE(*pErrorCode)) {
 709         return;
 710     }
 711     if((uint32_t)start&gt;0x10ffff || (uint32_t)end&gt;0x10ffff || start&gt;end) {
 712         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
 713         return;
 714     }
 715     newTrie=trie-&gt;newTrie;
 716     if(newTrie==NULL || newTrie-&gt;isCompacted) {
 717         *pErrorCode=U_NO_WRITE_PERMISSION;
 718         return;
 719     }



 720     if(!overwrite &amp;&amp; value==newTrie-&gt;initialValue) {
 721         return; /* nothing to do */
 722     }
 723 
 724     limit=end+1;
 725     if(start&amp;UTRIE2_DATA_MASK) {
 726         UChar32 nextStart;
 727 
 728         /* set partial block at [start..following block boundary[ */
 729         block=getDataBlock(newTrie, start, TRUE);
 730         if(block&lt;0) {
 731             *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
 732             return;
 733         }
 734 
<span class="line-modified"> 735         nextStart=(start+UTRIE2_DATA_BLOCK_LENGTH)&amp;~UTRIE2_DATA_MASK;</span>
 736         if(nextStart&lt;=limit) {
 737             fillBlock(newTrie-&gt;data+block, start&amp;UTRIE2_DATA_MASK, UTRIE2_DATA_BLOCK_LENGTH,
 738                       value, newTrie-&gt;initialValue, overwrite);
 739             start=nextStart;
 740         } else {
 741             fillBlock(newTrie-&gt;data+block, start&amp;UTRIE2_DATA_MASK, limit&amp;UTRIE2_DATA_MASK,
 742                       value, newTrie-&gt;initialValue, overwrite);
 743             return;
 744         }
 745     }
 746 
 747     /* number of positions in the last, partial block */
 748     rest=limit&amp;UTRIE2_DATA_MASK;
 749 
 750     /* round down limit to a block boundary */
 751     limit&amp;=~UTRIE2_DATA_MASK;
 752 
 753     /* iterate over all-value blocks */
 754     if(value==newTrie-&gt;initialValue) {
 755         repeatBlock=newTrie-&gt;dataNullOffset;
</pre>
<hr />
<pre>
 966     }
 967 
 968     /* deliver last range */
 969     return 0;
 970 }
 971 
 972 /*
 973  * Compact a build-time trie.
 974  *
 975  * The compaction
 976  * - removes blocks that are identical with earlier ones
 977  * - overlaps adjacent blocks as much as possible (if overlap==TRUE)
 978  * - moves blocks in steps of the data granularity
 979  * - moves and overlaps blocks that overlap with multiple values in the overlap region
 980  *
 981  * It does not
 982  * - try to move and overlap blocks that are not already adjacent
 983  */
 984 static void
 985 compactData(UNewTrie2 *trie) {




 986     int32_t start, newStart, movedStart;
 987     int32_t blockLength, overlap;
 988     int32_t i, mapIndex, blockCount;
 989 
 990     /* do not compact linear-ASCII data */
 991     newStart=UTRIE2_DATA_START_OFFSET;
 992     for(start=0, i=0; start&lt;newStart; start+=UTRIE2_DATA_BLOCK_LENGTH, ++i) {
 993         trie-&gt;map[i]=start;
 994     }
 995 
 996     /*
 997      * Start with a block length of 64 for 2-byte UTF-8,
 998      * then switch to UTRIE2_DATA_BLOCK_LENGTH.
 999      */
1000     blockLength=64;
1001     blockCount=blockLength&gt;&gt;UTRIE2_SHIFT_2;
1002     for(start=newStart; start&lt;trie-&gt;dataLength;) {
1003         /*
1004          * start: index of first entry of current block
1005          * newStart: index where the current block is to be moved
1006          *           (right after current end of already-compacted data)
1007          */
1008         if(start==UNEWTRIE2_DATA_0800_OFFSET) {
1009             blockLength=UTRIE2_DATA_BLOCK_LENGTH;
1010             blockCount=1;
1011         }
1012 
1013         /* skip blocks that are not used */
1014         if(trie-&gt;map[start&gt;&gt;UTRIE2_SHIFT_2]&lt;=0) {
1015             /* advance start to the next block */
1016             start+=blockLength;
1017 
1018             /* leave newStart with the previous block! */
1019             continue;
1020         }
1021 
1022         /* search for an identical block */
1023         if( (movedStart=findSameDataBlock(trie-&gt;data, newStart, start, blockLength))
1024              &gt;=0
1025         ) {



1026             /* found an identical block, set the other block&#39;s index value for the current block */
1027             for(i=blockCount, mapIndex=start&gt;&gt;UTRIE2_SHIFT_2; i&gt;0; --i) {
1028                 trie-&gt;map[mapIndex++]=movedStart;
1029                 movedStart+=UTRIE2_DATA_BLOCK_LENGTH;
1030             }
1031 
1032             /* advance start to the next block */
1033             start+=blockLength;
1034 
1035             /* leave newStart with the previous block! */
1036             continue;
1037         }
1038 
1039         /* see if the beginning of this block can be overlapped with the end of the previous block */
1040         /* look for maximum overlap (modulo granularity) with the previous, adjacent block */
1041         for(overlap=blockLength-UTRIE2_DATA_GRANULARITY;
1042             overlap&gt;0 &amp;&amp; !equal_uint32(trie-&gt;data+(newStart-overlap), trie-&gt;data+start, overlap);
1043             overlap-=UTRIE2_DATA_GRANULARITY) {}
1044 



1045         if(overlap&gt;0 || newStart&lt;start) {
1046             /* some overlap, or just move the whole block */
1047             movedStart=newStart-overlap;
1048             for(i=blockCount, mapIndex=start&gt;&gt;UTRIE2_SHIFT_2; i&gt;0; --i) {
1049                 trie-&gt;map[mapIndex++]=movedStart;
1050                 movedStart+=UTRIE2_DATA_BLOCK_LENGTH;
1051             }
1052 
1053             /* move the non-overlapping indexes to their new positions */
1054             start+=overlap;
1055             for(i=blockLength-overlap; i&gt;0; --i) {
1056                 trie-&gt;data[newStart++]=trie-&gt;data[start++];
1057             }
1058         } else /* no overlap &amp;&amp; newStart==start */ {
1059             for(i=blockCount, mapIndex=start&gt;&gt;UTRIE2_SHIFT_2; i&gt;0; --i) {
1060                 trie-&gt;map[mapIndex++]=start;
1061                 start+=UTRIE2_DATA_BLOCK_LENGTH;
1062             }
1063             newStart=start;
1064         }
1065     }
1066 
1067     /* now adjust the index-2 table */
1068     for(i=0; i&lt;trie-&gt;index2Length; ++i) {
1069         if(i==UNEWTRIE2_INDEX_GAP_OFFSET) {
1070             /* Gap indexes are invalid (-1). Skip over the gap. */
1071             i+=UNEWTRIE2_INDEX_GAP_LENGTH;
1072         }
1073         trie-&gt;index2[i]=trie-&gt;map[trie-&gt;index2[i]&gt;&gt;UTRIE2_SHIFT_2];
1074     }
1075     trie-&gt;dataNullOffset=trie-&gt;map[trie-&gt;dataNullOffset&gt;&gt;UTRIE2_SHIFT_2];
1076 
1077     /* ensure dataLength alignment */
1078     while((newStart&amp;(UTRIE2_DATA_GRANULARITY-1))!=0) {
1079         trie-&gt;data[newStart++]=trie-&gt;initialValue;
1080     }
1081 
1082 #ifdef UTRIE2_DEBUG
1083     /* we saved some space */
<span class="line-modified">1084     printf(&quot;compacting UTrie2: count of 32-bit data words %lu-&gt;%lu\n&quot;,</span>
<span class="line-modified">1085             (long)trie-&gt;dataLength, (long)newStart);</span>
1086 #endif
1087 
1088     trie-&gt;dataLength=newStart;
1089 }
1090 
1091 static void
1092 compactIndex2(UNewTrie2 *trie) {
1093     int32_t i, start, newStart, movedStart, overlap;
1094 
1095     /* do not compact linear-BMP index-2 blocks */
1096     newStart=UTRIE2_INDEX_2_BMP_LENGTH;
1097     for(start=0, i=0; start&lt;newStart; start+=UTRIE2_INDEX_2_BLOCK_LENGTH, ++i) {
1098         trie-&gt;map[i]=start;
1099     }
1100 
1101     /* Reduce the index table gap to what will be needed at runtime. */
1102     newStart+=UTRIE2_UTF8_2B_INDEX_2_LENGTH+((trie-&gt;highStart-0x10000)&gt;&gt;UTRIE2_SHIFT_1);
1103 
1104     for(start=UNEWTRIE2_INDEX_2_NULL_OFFSET; start&lt;trie-&gt;index2Length;) {
1105         /*
</pre>
<hr />
<pre>
1146 
1147     /* now adjust the index-1 table */
1148     for(i=0; i&lt;UNEWTRIE2_INDEX_1_LENGTH; ++i) {
1149         trie-&gt;index1[i]=trie-&gt;map[trie-&gt;index1[i]&gt;&gt;UTRIE2_SHIFT_1_2];
1150     }
1151     trie-&gt;index2NullOffset=trie-&gt;map[trie-&gt;index2NullOffset&gt;&gt;UTRIE2_SHIFT_1_2];
1152 
1153     /*
1154      * Ensure data table alignment:
1155      * Needs to be granularity-aligned for 16-bit trie
1156      * (so that dataMove will be down-shiftable),
1157      * and 2-aligned for uint32_t data.
1158      */
1159     while((newStart&amp;((UTRIE2_DATA_GRANULARITY-1)|1))!=0) {
1160         /* Arbitrary value: 0x3fffc not possible for real data. */
1161         trie-&gt;index2[newStart++]=(int32_t)0xffff&lt;&lt;UTRIE2_INDEX_SHIFT;
1162     }
1163 
1164 #ifdef UTRIE2_DEBUG
1165     /* we saved some space */
<span class="line-modified">1166     printf(&quot;compacting UTrie2: count of 16-bit index-2 words %lu-&gt;%lu\n&quot;,</span>
1167             (long)trie-&gt;index2Length, (long)newStart);
1168 #endif
1169 
1170     trie-&gt;index2Length=newStart;
1171 }
1172 
1173 static void
1174 compactTrie(UTrie2 *trie, UErrorCode *pErrorCode) {
1175     UNewTrie2 *newTrie;
1176     UChar32 highStart, suppHighStart;
1177     uint32_t highValue;
1178 
1179     newTrie=trie-&gt;newTrie;
1180 
1181     /* find highStart and round it up */
1182     highValue=utrie2_get32(trie, 0x10ffff);
1183     highStart=findHighStart(newTrie, highValue);
1184     highStart=(highStart+(UTRIE2_CP_PER_INDEX_1_ENTRY-1))&amp;~(UTRIE2_CP_PER_INDEX_1_ENTRY-1);
1185     if(highStart==0x110000) {
1186         highValue=trie-&gt;errorValue;
1187     }
1188 
1189     /*
1190      * Set trie-&gt;highStart only after utrie2_get32(trie, highStart).
1191      * Otherwise utrie2_get32(trie, highStart) would try to read the highValue.
1192      */
1193     trie-&gt;highStart=newTrie-&gt;highStart=highStart;
1194 
1195 #ifdef UTRIE2_DEBUG
<span class="line-modified">1196     printf(&quot;UTrie2: highStart U+%04lx  highValue 0x%lx  initialValue 0x%lx\n&quot;,</span>
1197             (long)highStart, (long)highValue, (long)trie-&gt;initialValue);
1198 #endif
1199 
1200     if(highStart&lt;0x110000) {
1201         /* Blank out [highStart..10ffff] to release associated data blocks. */
1202         suppHighStart= highStart&lt;=0x10000 ? 0x10000 : highStart;
1203         utrie2_setRange32(trie, suppHighStart, 0x10ffff, trie-&gt;initialValue, TRUE, pErrorCode);
1204         if(U_FAILURE(*pErrorCode)) {
1205             return;
1206         }
1207     }
1208 
1209     compactData(newTrie);
1210     if(highStart&gt;0x10000) {
1211         compactIndex2(newTrie);
1212 #ifdef UTRIE2_DEBUG
1213     } else {
<span class="line-modified">1214         printf(&quot;UTrie2: highStart U+%04lx  count of 16-bit index-2 words %lu-&gt;%lu\n&quot;,</span>
1215                 (long)highStart, (long)trie-&gt;newTrie-&gt;index2Length, (long)UTRIE2_INDEX_1_OFFSET);
1216 #endif
1217     }
1218 
1219     /*
1220      * Store the highValue in the data array and round up the dataLength.
1221      * Must be done after compactData() because that assumes that dataLength
1222      * is a multiple of UTRIE2_DATA_BLOCK_LENGTH.
1223      */
1224     newTrie-&gt;data[newTrie-&gt;dataLength++]=highValue;
1225     while((newTrie-&gt;dataLength&amp;(UTRIE2_DATA_GRANULARITY-1))!=0) {
1226         newTrie-&gt;data[newTrie-&gt;dataLength++]=trie-&gt;initialValue;
1227     }
1228 
1229     newTrie-&gt;isCompacted=TRUE;
1230 }
1231 
1232 /* serialization ------------------------------------------------------------ */
1233 
1234 /**
</pre>
<hr />
<pre>
1317     length=sizeof(UTrie2Header)+allIndexesLength*2;
1318     if(valueBits==UTRIE2_16_VALUE_BITS) {
1319         length+=newTrie-&gt;dataLength*2;
1320     } else {
1321         length+=newTrie-&gt;dataLength*4;
1322     }
1323 
1324     trie-&gt;memory=uprv_malloc(length);
1325     if(trie-&gt;memory==NULL) {
1326         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
1327         return;
1328     }
1329     trie-&gt;length=length;
1330     trie-&gt;isMemoryOwned=TRUE;
1331 
1332     trie-&gt;indexLength=allIndexesLength;
1333     trie-&gt;dataLength=newTrie-&gt;dataLength;
1334     if(highStart&lt;=0x10000) {
1335         trie-&gt;index2NullOffset=0xffff;
1336     } else {
<span class="line-modified">1337         trie-&gt;index2NullOffset=UTRIE2_INDEX_2_OFFSET+newTrie-&gt;index2NullOffset;</span>
1338     }
1339     trie-&gt;dataNullOffset=(uint16_t)(dataMove+newTrie-&gt;dataNullOffset);
1340     trie-&gt;highValueIndex=dataMove+trie-&gt;dataLength-UTRIE2_DATA_GRANULARITY;
1341 
1342     /* set the header fields */
1343     header=(UTrie2Header *)trie-&gt;memory;
1344 
1345     header-&gt;signature=UTRIE2_SIG; /* &quot;Tri2&quot; */
1346     header-&gt;options=(uint16_t)valueBits;
1347 
1348     header-&gt;indexLength=(uint16_t)trie-&gt;indexLength;
1349     header-&gt;shiftedDataLength=(uint16_t)(trie-&gt;dataLength&gt;&gt;UTRIE2_INDEX_SHIFT);
1350     header-&gt;index2NullOffset=trie-&gt;index2NullOffset;
1351     header-&gt;dataNullOffset=trie-&gt;dataNullOffset;
1352     header-&gt;shiftedHighStart=(uint16_t)(highStart&gt;&gt;UTRIE2_SHIFT_1);
1353 
1354     /* fill the index and data arrays */
1355     dest16=(uint16_t *)(header+1);
1356     trie-&gt;index=dest16;
1357 
</pre>
<hr />
<pre>
1394     case UTRIE2_16_VALUE_BITS:
1395         /* write 16-bit data values */
1396         trie-&gt;data16=dest16;
1397         trie-&gt;data32=NULL;
1398         p=newTrie-&gt;data;
1399         for(i=newTrie-&gt;dataLength; i&gt;0; --i) {
1400             *dest16++=(uint16_t)*p++;
1401         }
1402         break;
1403     case UTRIE2_32_VALUE_BITS:
1404         /* write 32-bit data values */
1405         trie-&gt;data16=NULL;
1406         trie-&gt;data32=(uint32_t *)dest16;
1407         uprv_memcpy(dest16, newTrie-&gt;data, (size_t)newTrie-&gt;dataLength*4);
1408         break;
1409     default:
1410         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
1411         return;
1412     }
1413 










1414     /* Delete the UNewTrie2. */
1415     uprv_free(newTrie-&gt;data);
1416     uprv_free(newTrie);
1417     trie-&gt;newTrie=NULL;
1418 }
<span class="line-removed">1419 </span>
<span class="line-removed">1420 /*</span>
<span class="line-removed">1421  * This is here to avoid a dependency from utrie2.cpp on utrie.c.</span>
<span class="line-removed">1422  * This file already depends on utrie.c.</span>
<span class="line-removed">1423  * Otherwise, this should be in utrie2.cpp right after utrie2_swap().</span>
<span class="line-removed">1424  */</span>
<span class="line-removed">1425 U_CAPI int32_t U_EXPORT2</span>
<span class="line-removed">1426 utrie2_swapAnyVersion(const UDataSwapper *ds,</span>
<span class="line-removed">1427                       const void *inData, int32_t length, void *outData,</span>
<span class="line-removed">1428                       UErrorCode *pErrorCode) {</span>
<span class="line-removed">1429     if(U_SUCCESS(*pErrorCode)) {</span>
<span class="line-removed">1430         switch(utrie2_getVersion(inData, length, TRUE)) {</span>
<span class="line-removed">1431         case 1:</span>
<span class="line-removed">1432             return utrie_swap(ds, inData, length, outData, pErrorCode);</span>
<span class="line-removed">1433         case 2:</span>
<span class="line-removed">1434             return utrie2_swap(ds, inData, length, outData, pErrorCode);</span>
<span class="line-removed">1435         default:</span>
<span class="line-removed">1436             *pErrorCode=U_INVALID_FORMAT_ERROR;</span>
<span class="line-removed">1437             return 0;</span>
<span class="line-removed">1438         }</span>
<span class="line-removed">1439     }</span>
<span class="line-removed">1440     return 0;</span>
<span class="line-removed">1441 }</span>
</pre>
</td>
<td>
<hr />
<pre>
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 ******************************************************************************
  10 *   file name:  utrie2_builder.cpp
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 2008sep26 (split off from utrie2.c)
  16 *   created by: Markus W. Scherer
  17 *
  18 *   This is a common implementation of a Unicode trie.
  19 *   It is a kind of compressed, serializable table of 16- or 32-bit values associated with
  20 *   Unicode code points (0..0x10ffff).
  21 *   This is the second common version of a Unicode trie (hence the name UTrie2).
  22 *   See utrie2.h for a comparison.
  23 *
  24 *   This file contains only the builder code.
  25 *   See utrie2.c for the runtime and enumeration code.
  26 */
<span class="line-added">  27 // #define UTRIE2_DEBUG</span>
  28 #ifdef UTRIE2_DEBUG
  29 #   include &lt;stdio.h&gt;
  30 #endif
<span class="line-added">  31 // #define UCPTRIE_DEBUG</span>
  32 
  33 #include &quot;unicode/utypes.h&quot;
<span class="line-added">  34 #ifdef UCPTRIE_DEBUG</span>
<span class="line-added">  35 #include &quot;unicode/ucptrie.h&quot;</span>
<span class="line-added">  36 #include &quot;unicode/umutablecptrie.h&quot;</span>
<span class="line-added">  37 #include &quot;ucptrie_impl.h&quot;</span>
<span class="line-added">  38 #endif</span>
  39 #include &quot;cmemory.h&quot;
  40 #include &quot;utrie2.h&quot;
  41 #include &quot;utrie2_impl.h&quot;
  42 
<span class="line-modified">  43 #include &quot;utrie.h&quot;  // for utrie2_fromUTrie()</span>
  44 
  45 /* Implementation notes ----------------------------------------------------- */
  46 
  47 /*
  48  * The UTRIE2_SHIFT_1, UTRIE2_SHIFT_2, UTRIE2_INDEX_SHIFT and other values
  49  * have been chosen to minimize trie sizes overall.
  50  * Most of the code is flexible enough to work with a range of values,
  51  * within certain limits.
  52  *
  53  * Exception: Support for separate values for lead surrogate code _units_
  54  * vs. code _points_ was added after the constants were fixed,
  55  * and has not been tested nor particularly designed for different constant values.
  56  * (Especially the utrie2_enum() code that jumps to the special LSCP index-2
  57  * part and back.)
  58  *
  59  * Requires UTRIE2_SHIFT_2&lt;=6. Otherwise 0xc0 which is the top of the ASCII-linear data
  60  * including the bad-UTF-8-data block is not a multiple of UTRIE2_DATA_BLOCK_LENGTH
  61  * and map[block&gt;&gt;UTRIE2_SHIFT_2] (used in reference counting and compaction
  62  * remapping) stops working.
  63  *
</pre>
<hr />
<pre>
 122     if(U_FAILURE(*pErrorCode)) {
 123         return NULL;
 124     }
 125 
 126     trie=(UTrie2 *)uprv_malloc(sizeof(UTrie2));
 127     newTrie=(UNewTrie2 *)uprv_malloc(sizeof(UNewTrie2));
 128     data=(uint32_t *)uprv_malloc(UNEWTRIE2_INITIAL_DATA_LENGTH*4);
 129     if(trie==NULL || newTrie==NULL || data==NULL) {
 130         uprv_free(trie);
 131         uprv_free(newTrie);
 132         uprv_free(data);
 133         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
 134         return 0;
 135     }
 136 
 137     uprv_memset(trie, 0, sizeof(UTrie2));
 138     trie-&gt;initialValue=initialValue;
 139     trie-&gt;errorValue=errorValue;
 140     trie-&gt;highStart=0x110000;
 141     trie-&gt;newTrie=newTrie;
<span class="line-added"> 142 #ifdef UTRIE2_DEBUG</span>
<span class="line-added"> 143     trie-&gt;name=&quot;open&quot;;</span>
<span class="line-added"> 144 #endif</span>
 145 
 146     newTrie-&gt;data=data;
<span class="line-added"> 147 #ifdef UCPTRIE_DEBUG</span>
<span class="line-added"> 148     newTrie-&gt;t3=umutablecptrie_open(initialValue, errorValue, pErrorCode);</span>
<span class="line-added"> 149 #endif</span>
 150     newTrie-&gt;dataCapacity=UNEWTRIE2_INITIAL_DATA_LENGTH;
 151     newTrie-&gt;initialValue=initialValue;
 152     newTrie-&gt;errorValue=errorValue;
 153     newTrie-&gt;highStart=0x110000;
 154     newTrie-&gt;firstFreeBlock=0;  /* no free block in the list */
 155     newTrie-&gt;isCompacted=FALSE;
 156 
 157     /*
 158      * preallocate and reset
 159      * - ASCII
 160      * - the bad-UTF-8-data block
 161      * - the null data block
 162      */
 163     for(i=0; i&lt;0x80; ++i) {
 164         newTrie-&gt;data[i]=initialValue;
 165     }
 166     for(; i&lt;0xc0; ++i) {
 167         newTrie-&gt;data[i]=errorValue;
 168     }
 169     for(i=UNEWTRIE2_DATA_NULL_OFFSET; i&lt;UNEWTRIE2_DATA_START_OFFSET; ++i) {
</pre>
<hr />
<pre>
 242         utrie2_set32(trie, i, initialValue, pErrorCode);
 243     }
 244 
 245     return trie;
 246 }
 247 
 248 static UNewTrie2 *
 249 cloneBuilder(const UNewTrie2 *other) {
 250     UNewTrie2 *trie;
 251 
 252     trie=(UNewTrie2 *)uprv_malloc(sizeof(UNewTrie2));
 253     if(trie==NULL) {
 254         return NULL;
 255     }
 256 
 257     trie-&gt;data=(uint32_t *)uprv_malloc(other-&gt;dataCapacity*4);
 258     if(trie-&gt;data==NULL) {
 259         uprv_free(trie);
 260         return NULL;
 261     }
<span class="line-added"> 262 #ifdef UCPTRIE_DEBUG</span>
<span class="line-added"> 263     if(other-&gt;t3==nullptr) {</span>
<span class="line-added"> 264         trie-&gt;t3=nullptr;</span>
<span class="line-added"> 265     } else {</span>
<span class="line-added"> 266         UErrorCode errorCode=U_ZERO_ERROR;</span>
<span class="line-added"> 267         trie-&gt;t3=umutablecptrie_clone(other-&gt;t3, &amp;errorCode);</span>
<span class="line-added"> 268     }</span>
<span class="line-added"> 269 #endif</span>
 270     trie-&gt;dataCapacity=other-&gt;dataCapacity;
 271 
 272     /* clone data */
 273     uprv_memcpy(trie-&gt;index1, other-&gt;index1, sizeof(trie-&gt;index1));
 274     uprv_memcpy(trie-&gt;index2, other-&gt;index2, (size_t)other-&gt;index2Length*4);
 275     trie-&gt;index2NullOffset=other-&gt;index2NullOffset;
 276     trie-&gt;index2Length=other-&gt;index2Length;
 277 
 278     uprv_memcpy(trie-&gt;data, other-&gt;data, (size_t)other-&gt;dataLength*4);
 279     trie-&gt;dataNullOffset=other-&gt;dataNullOffset;
 280     trie-&gt;dataLength=other-&gt;dataLength;
 281 
 282     /* reference counters */
 283     if(other-&gt;isCompacted) {
 284         trie-&gt;firstFreeBlock=0;
 285     } else {
 286         uprv_memcpy(trie-&gt;map, other-&gt;map, ((size_t)other-&gt;dataLength&gt;&gt;UTRIE2_SHIFT_2)*4);
 287         trie-&gt;firstFreeBlock=other-&gt;firstFreeBlock;
 288     }
 289 
</pre>
<hr />
<pre>
 292     trie-&gt;highStart=other-&gt;highStart;
 293     trie-&gt;isCompacted=other-&gt;isCompacted;
 294 
 295     return trie;
 296 }
 297 
 298 U_CAPI UTrie2 * U_EXPORT2
 299 utrie2_clone(const UTrie2 *other, UErrorCode *pErrorCode) {
 300     UTrie2 *trie;
 301 
 302     if(U_FAILURE(*pErrorCode)) {
 303         return NULL;
 304     }
 305     if(other==NULL || (other-&gt;memory==NULL &amp;&amp; other-&gt;newTrie==NULL)) {
 306         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
 307         return NULL;
 308     }
 309 
 310     trie=(UTrie2 *)uprv_malloc(sizeof(UTrie2));
 311     if(trie==NULL) {
<span class="line-added"> 312         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;</span>
 313         return NULL;
 314     }
 315     uprv_memcpy(trie, other, sizeof(UTrie2));
 316 
 317     if(other-&gt;memory!=NULL) {
 318         trie-&gt;memory=uprv_malloc(other-&gt;length);
 319         if(trie-&gt;memory!=NULL) {
 320             trie-&gt;isMemoryOwned=TRUE;
 321             uprv_memcpy(trie-&gt;memory, other-&gt;memory, other-&gt;length);
 322 
 323             /* make the clone&#39;s pointers point to its own memory */
 324             trie-&gt;index=(uint16_t *)trie-&gt;memory+(other-&gt;index-(uint16_t *)other-&gt;memory);
 325             if(other-&gt;data16!=NULL) {
 326                 trie-&gt;data16=(uint16_t *)trie-&gt;memory+(other-&gt;data16-(uint16_t *)other-&gt;memory);
 327             }
 328             if(other-&gt;data32!=NULL) {
 329                 trie-&gt;data32=(uint32_t *)trie-&gt;memory+(other-&gt;data32-(uint32_t *)other-&gt;memory);
 330             }
 331         }
 332     } else /* other-&gt;newTrie!=NULL */ {
 333         trie-&gt;newTrie=cloneBuilder(other-&gt;newTrie);
 334     }
 335 
 336     if(trie-&gt;memory==NULL &amp;&amp; trie-&gt;newTrie==NULL) {
<span class="line-added"> 337         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;</span>
 338         uprv_free(trie);
 339         trie=NULL;
 340     }
 341     return trie;
 342 }
 343 
 344 typedef struct NewTrieAndStatus {
 345     UTrie2 *trie;
 346     UErrorCode errorCode;
 347     UBool exclusiveLimit;  /* rather than inclusive range end */
 348 } NewTrieAndStatus;
 349 
 350 static UBool U_CALLCONV
 351 copyEnumRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {
 352     NewTrieAndStatus *nt=(NewTrieAndStatus *)context;
 353     if(value!=nt-&gt;trie-&gt;initialValue) {
 354         if(nt-&gt;exclusiveLimit) {
 355             --end;
 356         }
 357         if(start==end) {
 358             utrie2_set32(nt-&gt;trie, start, value, &amp;nt-&gt;errorCode);
 359         } else {
 360             utrie2_setRange32(nt-&gt;trie, start, end, value, TRUE, &amp;nt-&gt;errorCode);
 361         }
 362         return U_SUCCESS(nt-&gt;errorCode);
 363     } else {
 364         return TRUE;
 365     }
 366 }
 367 
 368 #ifdef UTRIE2_DEBUG
<span class="line-added"> 369 static long countInitial(const UTrie2 *trie) {</span>
<span class="line-added"> 370     uint32_t initialValue=trie-&gt;initialValue;</span>
<span class="line-added"> 371     int32_t length=trie-&gt;dataLength;</span>
<span class="line-added"> 372     long count=0;</span>
<span class="line-added"> 373     if(trie-&gt;data16!=nullptr) {</span>
<span class="line-added"> 374         for(int32_t i=0; i&lt;length; ++i) {</span>
<span class="line-added"> 375             if(trie-&gt;data16[i]==initialValue) { ++count; }</span>
<span class="line-added"> 376         }</span>
<span class="line-added"> 377     } else {</span>
<span class="line-added"> 378         for(int32_t i=0; i&lt;length; ++i) {</span>
<span class="line-added"> 379             if(trie-&gt;data32[i]==initialValue) { ++count; }</span>
<span class="line-added"> 380         }</span>
<span class="line-added"> 381     }</span>
<span class="line-added"> 382     return count;</span>
<span class="line-added"> 383 }</span>
<span class="line-added"> 384 </span>
 385 static void
 386 utrie_printLengths(const UTrie *trie) {
 387     long indexLength=trie-&gt;indexLength;
 388     long dataLength=(long)trie-&gt;dataLength;
 389     long totalLength=(long)sizeof(UTrieHeader)+indexLength*2+dataLength*(trie-&gt;data32!=NULL ? 4 : 2);
 390     printf(&quot;**UTrieLengths** index:%6ld  data:%6ld  serialized:%6ld\n&quot;,
 391            indexLength, dataLength, totalLength);
 392 }
 393 
 394 static void
 395 utrie2_printLengths(const UTrie2 *trie, const char *which) {
 396     long indexLength=trie-&gt;indexLength;
 397     long dataLength=(long)trie-&gt;dataLength;
 398     long totalLength=(long)sizeof(UTrie2Header)+indexLength*2+dataLength*(trie-&gt;data32!=NULL ? 4 : 2);
<span class="line-modified"> 399     printf(&quot;**UTrie2Lengths(%s %s)** index:%6ld  data:%6ld  countInitial:%6ld  serialized:%6ld\n&quot;,</span>
<span class="line-modified"> 400            which, trie-&gt;name, indexLength, dataLength, countInitial(trie), totalLength);</span>
 401 }
 402 #endif
 403 
 404 U_CAPI UTrie2 * U_EXPORT2
 405 utrie2_cloneAsThawed(const UTrie2 *other, UErrorCode *pErrorCode) {
 406     NewTrieAndStatus context;
 407     UChar lead;
 408 
 409     if(U_FAILURE(*pErrorCode)) {
 410         return NULL;
 411     }
 412     if(other==NULL || (other-&gt;memory==NULL &amp;&amp; other-&gt;newTrie==NULL)) {
 413         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
 414         return NULL;
 415     }
 416     if(other-&gt;newTrie!=NULL &amp;&amp; !other-&gt;newTrie-&gt;isCompacted) {
 417         return utrie2_clone(other, pErrorCode);  /* clone an unfrozen trie */
 418     }
 419 
 420     /* Clone the frozen trie by enumerating it and building a new one. */
</pre>
<hr />
<pre>
 644         /* out of memory in the data array */
 645         return -1;
 646     }
 647     setIndex2Entry(trie, i2, newBlock);
 648     return newBlock;
 649 }
 650 
 651 /**
 652  * @return TRUE if the value was successfully set
 653  */
 654 static void
 655 set32(UNewTrie2 *trie,
 656       UChar32 c, UBool forLSCP, uint32_t value,
 657       UErrorCode *pErrorCode) {
 658     int32_t block;
 659 
 660     if(trie==NULL || trie-&gt;isCompacted) {
 661         *pErrorCode=U_NO_WRITE_PERMISSION;
 662         return;
 663     }
<span class="line-added"> 664 #ifdef UCPTRIE_DEBUG</span>
<span class="line-added"> 665     umutablecptrie_set(trie-&gt;t3, c, value, pErrorCode);</span>
<span class="line-added"> 666 #endif</span>
 667 
 668     block=getDataBlock(trie, c, forLSCP);
 669     if(block&lt;0) {
 670         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
 671         return;
 672     }
 673 
 674     trie-&gt;data[block+(c&amp;UTRIE2_DATA_MASK)]=value;
 675 }
 676 
 677 U_CAPI void U_EXPORT2
 678 utrie2_set32(UTrie2 *trie, UChar32 c, uint32_t value, UErrorCode *pErrorCode) {
 679     if(U_FAILURE(*pErrorCode)) {
 680         return;
 681     }
 682     if((uint32_t)c&gt;0x10ffff) {
 683         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
 684         return;
 685     }
 686     set32(trie-&gt;newTrie, c, TRUE, value, pErrorCode);
</pre>
<hr />
<pre>
 742      * repeat value in [start..end]
 743      * mark index values for repeat-data blocks by setting bit 31 of the index values
 744      * fill around existing values if any, if(overwrite)
 745      */
 746     UNewTrie2 *newTrie;
 747     int32_t block, rest, repeatBlock;
 748     UChar32 limit;
 749 
 750     if(U_FAILURE(*pErrorCode)) {
 751         return;
 752     }
 753     if((uint32_t)start&gt;0x10ffff || (uint32_t)end&gt;0x10ffff || start&gt;end) {
 754         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
 755         return;
 756     }
 757     newTrie=trie-&gt;newTrie;
 758     if(newTrie==NULL || newTrie-&gt;isCompacted) {
 759         *pErrorCode=U_NO_WRITE_PERMISSION;
 760         return;
 761     }
<span class="line-added"> 762 #ifdef UCPTRIE_DEBUG</span>
<span class="line-added"> 763     umutablecptrie_setRange(newTrie-&gt;t3, start, end, value, pErrorCode);</span>
<span class="line-added"> 764 #endif</span>
 765     if(!overwrite &amp;&amp; value==newTrie-&gt;initialValue) {
 766         return; /* nothing to do */
 767     }
 768 
 769     limit=end+1;
 770     if(start&amp;UTRIE2_DATA_MASK) {
 771         UChar32 nextStart;
 772 
 773         /* set partial block at [start..following block boundary[ */
 774         block=getDataBlock(newTrie, start, TRUE);
 775         if(block&lt;0) {
 776             *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
 777             return;
 778         }
 779 
<span class="line-modified"> 780         nextStart=(start+UTRIE2_DATA_MASK)&amp;~UTRIE2_DATA_MASK;</span>
 781         if(nextStart&lt;=limit) {
 782             fillBlock(newTrie-&gt;data+block, start&amp;UTRIE2_DATA_MASK, UTRIE2_DATA_BLOCK_LENGTH,
 783                       value, newTrie-&gt;initialValue, overwrite);
 784             start=nextStart;
 785         } else {
 786             fillBlock(newTrie-&gt;data+block, start&amp;UTRIE2_DATA_MASK, limit&amp;UTRIE2_DATA_MASK,
 787                       value, newTrie-&gt;initialValue, overwrite);
 788             return;
 789         }
 790     }
 791 
 792     /* number of positions in the last, partial block */
 793     rest=limit&amp;UTRIE2_DATA_MASK;
 794 
 795     /* round down limit to a block boundary */
 796     limit&amp;=~UTRIE2_DATA_MASK;
 797 
 798     /* iterate over all-value blocks */
 799     if(value==newTrie-&gt;initialValue) {
 800         repeatBlock=newTrie-&gt;dataNullOffset;
</pre>
<hr />
<pre>
1011     }
1012 
1013     /* deliver last range */
1014     return 0;
1015 }
1016 
1017 /*
1018  * Compact a build-time trie.
1019  *
1020  * The compaction
1021  * - removes blocks that are identical with earlier ones
1022  * - overlaps adjacent blocks as much as possible (if overlap==TRUE)
1023  * - moves blocks in steps of the data granularity
1024  * - moves and overlaps blocks that overlap with multiple values in the overlap region
1025  *
1026  * It does not
1027  * - try to move and overlap blocks that are not already adjacent
1028  */
1029 static void
1030 compactData(UNewTrie2 *trie) {
<span class="line-added">1031 #ifdef UTRIE2_DEBUG</span>
<span class="line-added">1032     int32_t countSame=0, sumOverlaps=0;</span>
<span class="line-added">1033 #endif</span>
<span class="line-added">1034 </span>
1035     int32_t start, newStart, movedStart;
1036     int32_t blockLength, overlap;
1037     int32_t i, mapIndex, blockCount;
1038 
1039     /* do not compact linear-ASCII data */
1040     newStart=UTRIE2_DATA_START_OFFSET;
1041     for(start=0, i=0; start&lt;newStart; start+=UTRIE2_DATA_BLOCK_LENGTH, ++i) {
1042         trie-&gt;map[i]=start;
1043     }
1044 
1045     /*
1046      * Start with a block length of 64 for 2-byte UTF-8,
1047      * then switch to UTRIE2_DATA_BLOCK_LENGTH.
1048      */
1049     blockLength=64;
1050     blockCount=blockLength&gt;&gt;UTRIE2_SHIFT_2;
1051     for(start=newStart; start&lt;trie-&gt;dataLength;) {
1052         /*
1053          * start: index of first entry of current block
1054          * newStart: index where the current block is to be moved
1055          *           (right after current end of already-compacted data)
1056          */
1057         if(start==UNEWTRIE2_DATA_0800_OFFSET) {
1058             blockLength=UTRIE2_DATA_BLOCK_LENGTH;
1059             blockCount=1;
1060         }
1061 
1062         /* skip blocks that are not used */
1063         if(trie-&gt;map[start&gt;&gt;UTRIE2_SHIFT_2]&lt;=0) {
1064             /* advance start to the next block */
1065             start+=blockLength;
1066 
1067             /* leave newStart with the previous block! */
1068             continue;
1069         }
1070 
1071         /* search for an identical block */
1072         if( (movedStart=findSameDataBlock(trie-&gt;data, newStart, start, blockLength))
1073              &gt;=0
1074         ) {
<span class="line-added">1075 #ifdef UTRIE2_DEBUG</span>
<span class="line-added">1076             ++countSame;</span>
<span class="line-added">1077 #endif</span>
1078             /* found an identical block, set the other block&#39;s index value for the current block */
1079             for(i=blockCount, mapIndex=start&gt;&gt;UTRIE2_SHIFT_2; i&gt;0; --i) {
1080                 trie-&gt;map[mapIndex++]=movedStart;
1081                 movedStart+=UTRIE2_DATA_BLOCK_LENGTH;
1082             }
1083 
1084             /* advance start to the next block */
1085             start+=blockLength;
1086 
1087             /* leave newStart with the previous block! */
1088             continue;
1089         }
1090 
1091         /* see if the beginning of this block can be overlapped with the end of the previous block */
1092         /* look for maximum overlap (modulo granularity) with the previous, adjacent block */
1093         for(overlap=blockLength-UTRIE2_DATA_GRANULARITY;
1094             overlap&gt;0 &amp;&amp; !equal_uint32(trie-&gt;data+(newStart-overlap), trie-&gt;data+start, overlap);
1095             overlap-=UTRIE2_DATA_GRANULARITY) {}
1096 
<span class="line-added">1097 #ifdef UTRIE2_DEBUG</span>
<span class="line-added">1098             sumOverlaps+=overlap;</span>
<span class="line-added">1099 #endif</span>
1100         if(overlap&gt;0 || newStart&lt;start) {
1101             /* some overlap, or just move the whole block */
1102             movedStart=newStart-overlap;
1103             for(i=blockCount, mapIndex=start&gt;&gt;UTRIE2_SHIFT_2; i&gt;0; --i) {
1104                 trie-&gt;map[mapIndex++]=movedStart;
1105                 movedStart+=UTRIE2_DATA_BLOCK_LENGTH;
1106             }
1107 
1108             /* move the non-overlapping indexes to their new positions */
1109             start+=overlap;
1110             for(i=blockLength-overlap; i&gt;0; --i) {
1111                 trie-&gt;data[newStart++]=trie-&gt;data[start++];
1112             }
1113         } else /* no overlap &amp;&amp; newStart==start */ {
1114             for(i=blockCount, mapIndex=start&gt;&gt;UTRIE2_SHIFT_2; i&gt;0; --i) {
1115                 trie-&gt;map[mapIndex++]=start;
1116                 start+=UTRIE2_DATA_BLOCK_LENGTH;
1117             }
1118             newStart=start;
1119         }
1120     }
1121 
1122     /* now adjust the index-2 table */
1123     for(i=0; i&lt;trie-&gt;index2Length; ++i) {
1124         if(i==UNEWTRIE2_INDEX_GAP_OFFSET) {
1125             /* Gap indexes are invalid (-1). Skip over the gap. */
1126             i+=UNEWTRIE2_INDEX_GAP_LENGTH;
1127         }
1128         trie-&gt;index2[i]=trie-&gt;map[trie-&gt;index2[i]&gt;&gt;UTRIE2_SHIFT_2];
1129     }
1130     trie-&gt;dataNullOffset=trie-&gt;map[trie-&gt;dataNullOffset&gt;&gt;UTRIE2_SHIFT_2];
1131 
1132     /* ensure dataLength alignment */
1133     while((newStart&amp;(UTRIE2_DATA_GRANULARITY-1))!=0) {
1134         trie-&gt;data[newStart++]=trie-&gt;initialValue;
1135     }
1136 
1137 #ifdef UTRIE2_DEBUG
1138     /* we saved some space */
<span class="line-modified">1139     printf(&quot;compacting UTrie2: count of 32-bit data words %lu-&gt;%lu  countSame=%ld  sumOverlaps=%ld\n&quot;,</span>
<span class="line-modified">1140             (long)trie-&gt;dataLength, (long)newStart, (long)countSame, (long)sumOverlaps);</span>
1141 #endif
1142 
1143     trie-&gt;dataLength=newStart;
1144 }
1145 
1146 static void
1147 compactIndex2(UNewTrie2 *trie) {
1148     int32_t i, start, newStart, movedStart, overlap;
1149 
1150     /* do not compact linear-BMP index-2 blocks */
1151     newStart=UTRIE2_INDEX_2_BMP_LENGTH;
1152     for(start=0, i=0; start&lt;newStart; start+=UTRIE2_INDEX_2_BLOCK_LENGTH, ++i) {
1153         trie-&gt;map[i]=start;
1154     }
1155 
1156     /* Reduce the index table gap to what will be needed at runtime. */
1157     newStart+=UTRIE2_UTF8_2B_INDEX_2_LENGTH+((trie-&gt;highStart-0x10000)&gt;&gt;UTRIE2_SHIFT_1);
1158 
1159     for(start=UNEWTRIE2_INDEX_2_NULL_OFFSET; start&lt;trie-&gt;index2Length;) {
1160         /*
</pre>
<hr />
<pre>
1201 
1202     /* now adjust the index-1 table */
1203     for(i=0; i&lt;UNEWTRIE2_INDEX_1_LENGTH; ++i) {
1204         trie-&gt;index1[i]=trie-&gt;map[trie-&gt;index1[i]&gt;&gt;UTRIE2_SHIFT_1_2];
1205     }
1206     trie-&gt;index2NullOffset=trie-&gt;map[trie-&gt;index2NullOffset&gt;&gt;UTRIE2_SHIFT_1_2];
1207 
1208     /*
1209      * Ensure data table alignment:
1210      * Needs to be granularity-aligned for 16-bit trie
1211      * (so that dataMove will be down-shiftable),
1212      * and 2-aligned for uint32_t data.
1213      */
1214     while((newStart&amp;((UTRIE2_DATA_GRANULARITY-1)|1))!=0) {
1215         /* Arbitrary value: 0x3fffc not possible for real data. */
1216         trie-&gt;index2[newStart++]=(int32_t)0xffff&lt;&lt;UTRIE2_INDEX_SHIFT;
1217     }
1218 
1219 #ifdef UTRIE2_DEBUG
1220     /* we saved some space */
<span class="line-modified">1221     printf(&quot;compacting UTrie2: count of 16-bit index words %lu-&gt;%lu\n&quot;,</span>
1222             (long)trie-&gt;index2Length, (long)newStart);
1223 #endif
1224 
1225     trie-&gt;index2Length=newStart;
1226 }
1227 
1228 static void
1229 compactTrie(UTrie2 *trie, UErrorCode *pErrorCode) {
1230     UNewTrie2 *newTrie;
1231     UChar32 highStart, suppHighStart;
1232     uint32_t highValue;
1233 
1234     newTrie=trie-&gt;newTrie;
1235 
1236     /* find highStart and round it up */
1237     highValue=utrie2_get32(trie, 0x10ffff);
1238     highStart=findHighStart(newTrie, highValue);
1239     highStart=(highStart+(UTRIE2_CP_PER_INDEX_1_ENTRY-1))&amp;~(UTRIE2_CP_PER_INDEX_1_ENTRY-1);
1240     if(highStart==0x110000) {
1241         highValue=trie-&gt;errorValue;
1242     }
1243 
1244     /*
1245      * Set trie-&gt;highStart only after utrie2_get32(trie, highStart).
1246      * Otherwise utrie2_get32(trie, highStart) would try to read the highValue.
1247      */
1248     trie-&gt;highStart=newTrie-&gt;highStart=highStart;
1249 
1250 #ifdef UTRIE2_DEBUG
<span class="line-modified">1251     printf(&quot;UTrie2: highStart U+%06lx  highValue 0x%lx  initialValue 0x%lx\n&quot;,</span>
1252             (long)highStart, (long)highValue, (long)trie-&gt;initialValue);
1253 #endif
1254 
1255     if(highStart&lt;0x110000) {
1256         /* Blank out [highStart..10ffff] to release associated data blocks. */
1257         suppHighStart= highStart&lt;=0x10000 ? 0x10000 : highStart;
1258         utrie2_setRange32(trie, suppHighStart, 0x10ffff, trie-&gt;initialValue, TRUE, pErrorCode);
1259         if(U_FAILURE(*pErrorCode)) {
1260             return;
1261         }
1262     }
1263 
1264     compactData(newTrie);
1265     if(highStart&gt;0x10000) {
1266         compactIndex2(newTrie);
1267 #ifdef UTRIE2_DEBUG
1268     } else {
<span class="line-modified">1269         printf(&quot;UTrie2: highStart U+%04lx  count of 16-bit index words %lu-&gt;%lu\n&quot;,</span>
1270                 (long)highStart, (long)trie-&gt;newTrie-&gt;index2Length, (long)UTRIE2_INDEX_1_OFFSET);
1271 #endif
1272     }
1273 
1274     /*
1275      * Store the highValue in the data array and round up the dataLength.
1276      * Must be done after compactData() because that assumes that dataLength
1277      * is a multiple of UTRIE2_DATA_BLOCK_LENGTH.
1278      */
1279     newTrie-&gt;data[newTrie-&gt;dataLength++]=highValue;
1280     while((newTrie-&gt;dataLength&amp;(UTRIE2_DATA_GRANULARITY-1))!=0) {
1281         newTrie-&gt;data[newTrie-&gt;dataLength++]=trie-&gt;initialValue;
1282     }
1283 
1284     newTrie-&gt;isCompacted=TRUE;
1285 }
1286 
1287 /* serialization ------------------------------------------------------------ */
1288 
1289 /**
</pre>
<hr />
<pre>
1372     length=sizeof(UTrie2Header)+allIndexesLength*2;
1373     if(valueBits==UTRIE2_16_VALUE_BITS) {
1374         length+=newTrie-&gt;dataLength*2;
1375     } else {
1376         length+=newTrie-&gt;dataLength*4;
1377     }
1378 
1379     trie-&gt;memory=uprv_malloc(length);
1380     if(trie-&gt;memory==NULL) {
1381         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
1382         return;
1383     }
1384     trie-&gt;length=length;
1385     trie-&gt;isMemoryOwned=TRUE;
1386 
1387     trie-&gt;indexLength=allIndexesLength;
1388     trie-&gt;dataLength=newTrie-&gt;dataLength;
1389     if(highStart&lt;=0x10000) {
1390         trie-&gt;index2NullOffset=0xffff;
1391     } else {
<span class="line-modified">1392         trie-&gt;index2NullOffset=static_cast&lt;uint16_t&gt;(UTRIE2_INDEX_2_OFFSET+newTrie-&gt;index2NullOffset);</span>
1393     }
1394     trie-&gt;dataNullOffset=(uint16_t)(dataMove+newTrie-&gt;dataNullOffset);
1395     trie-&gt;highValueIndex=dataMove+trie-&gt;dataLength-UTRIE2_DATA_GRANULARITY;
1396 
1397     /* set the header fields */
1398     header=(UTrie2Header *)trie-&gt;memory;
1399 
1400     header-&gt;signature=UTRIE2_SIG; /* &quot;Tri2&quot; */
1401     header-&gt;options=(uint16_t)valueBits;
1402 
1403     header-&gt;indexLength=(uint16_t)trie-&gt;indexLength;
1404     header-&gt;shiftedDataLength=(uint16_t)(trie-&gt;dataLength&gt;&gt;UTRIE2_INDEX_SHIFT);
1405     header-&gt;index2NullOffset=trie-&gt;index2NullOffset;
1406     header-&gt;dataNullOffset=trie-&gt;dataNullOffset;
1407     header-&gt;shiftedHighStart=(uint16_t)(highStart&gt;&gt;UTRIE2_SHIFT_1);
1408 
1409     /* fill the index and data arrays */
1410     dest16=(uint16_t *)(header+1);
1411     trie-&gt;index=dest16;
1412 
</pre>
<hr />
<pre>
1449     case UTRIE2_16_VALUE_BITS:
1450         /* write 16-bit data values */
1451         trie-&gt;data16=dest16;
1452         trie-&gt;data32=NULL;
1453         p=newTrie-&gt;data;
1454         for(i=newTrie-&gt;dataLength; i&gt;0; --i) {
1455             *dest16++=(uint16_t)*p++;
1456         }
1457         break;
1458     case UTRIE2_32_VALUE_BITS:
1459         /* write 32-bit data values */
1460         trie-&gt;data16=NULL;
1461         trie-&gt;data32=(uint32_t *)dest16;
1462         uprv_memcpy(dest16, newTrie-&gt;data, (size_t)newTrie-&gt;dataLength*4);
1463         break;
1464     default:
1465         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
1466         return;
1467     }
1468 
<span class="line-added">1469 #ifdef UTRIE2_DEBUG</span>
<span class="line-added">1470     utrie2_printLengths(trie, &quot;&quot;);</span>
<span class="line-added">1471 #endif</span>
<span class="line-added">1472 </span>
<span class="line-added">1473 #ifdef UCPTRIE_DEBUG</span>
<span class="line-added">1474     umutablecptrie_setName(newTrie-&gt;t3, trie-&gt;name);</span>
<span class="line-added">1475     ucptrie_close(</span>
<span class="line-added">1476         umutablecptrie_buildImmutable(</span>
<span class="line-added">1477             newTrie-&gt;t3, UCPTRIE_TYPE_FAST, (UCPTrieValueWidth)valueBits, pErrorCode));</span>
<span class="line-added">1478 #endif</span>
1479     /* Delete the UNewTrie2. */
1480     uprv_free(newTrie-&gt;data);
1481     uprv_free(newTrie);
1482     trie-&gt;newTrie=NULL;
1483 }























</pre>
</td>
</tr>
</table>
<center><a href="utrie2.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="utrie2_impl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>