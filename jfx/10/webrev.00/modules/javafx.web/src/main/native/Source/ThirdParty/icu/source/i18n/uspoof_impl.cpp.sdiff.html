<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/uspoof_impl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="uspoof_conf.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uspoof_impl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/uspoof_impl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 }
 36 
 37 SpoofImpl::SpoofImpl(UErrorCode&amp; status) {
 38     construct(status);
 39 
 40     // TODO: Call this method where it is actually needed, instead of in the
 41     // constructor, to allow for lazy data loading.  See #12696.
 42     fSpoofData = SpoofData::getDefault(status);
 43 }
 44 
 45 SpoofImpl::SpoofImpl() {
 46     UErrorCode status = U_ZERO_ERROR;
 47     construct(status);
 48 
 49     // TODO: Call this method where it is actually needed, instead of in the
 50     // constructor, to allow for lazy data loading.  See #12696.
 51     fSpoofData = SpoofData::getDefault(status);
 52 }
 53 
 54 void SpoofImpl::construct(UErrorCode&amp; status) {
<span class="line-removed"> 55     fMagic = USPOOF_MAGIC;</span>
 56     fChecks = USPOOF_ALL_CHECKS;
 57     fSpoofData = NULL;
 58     fAllowedCharsSet = NULL;
 59     fAllowedLocales = NULL;
 60     fRestrictionLevel = USPOOF_HIGHLY_RESTRICTIVE;
 61 
 62     if (U_FAILURE(status)) { return; }
 63 
 64     UnicodeSet *allowedCharsSet = new UnicodeSet(0, 0x10ffff);
 65     fAllowedCharsSet = allowedCharsSet;
 66     fAllowedLocales  = uprv_strdup(&quot;&quot;);
 67     if (fAllowedCharsSet == NULL || fAllowedLocales == NULL) {
 68         status = U_MEMORY_ALLOCATION_ERROR;
 69         return;
 70     }
 71     allowedCharsSet-&gt;freeze();
 72 }
 73 
 74 
 75 // Copy Constructor, used by the user level clone() function.
 76 SpoofImpl::SpoofImpl(const SpoofImpl &amp;src, UErrorCode &amp;status)  :
<span class="line-modified"> 77         fMagic(0), fChecks(USPOOF_ALL_CHECKS), fSpoofData(NULL), fAllowedCharsSet(NULL) ,</span>
 78         fAllowedLocales(NULL) {
 79     if (U_FAILURE(status)) {
 80         return;
 81     }
<span class="line-removed"> 82     fMagic = src.fMagic;</span>
 83     fChecks = src.fChecks;
 84     if (src.fSpoofData != NULL) {
 85         fSpoofData = src.fSpoofData-&gt;addReference();
 86     }
 87     fAllowedCharsSet = static_cast&lt;const UnicodeSet *&gt;(src.fAllowedCharsSet-&gt;clone());
 88     fAllowedLocales = uprv_strdup(src.fAllowedLocales);
 89     if (fAllowedCharsSet == NULL || fAllowedLocales == NULL) {
 90         status = U_MEMORY_ALLOCATION_ERROR;
 91     }
 92     fRestrictionLevel = src.fRestrictionLevel;
 93 }
 94 
 95 SpoofImpl::~SpoofImpl() {
<span class="line-removed"> 96     fMagic = 0;                // head off application errors by preventing use of</span>
<span class="line-removed"> 97                                //    of deleted objects.</span>
 98     if (fSpoofData != NULL) {
 99         fSpoofData-&gt;removeReference();   // Will delete if refCount goes to zero.
100     }
101     delete fAllowedCharsSet;
102     uprv_free((void *)fAllowedLocales);
103 }
104 
105 //  Cast this instance as a USpoofChecker for the C API.
106 USpoofChecker *SpoofImpl::asUSpoofChecker() {
<span class="line-modified">107     return reinterpret_cast&lt;USpoofChecker*&gt;(this);</span>
108 }
109 
110 //
111 //  Incoming parameter check on Status and the SpoofChecker object
112 //    received from the C API.
113 //
114 const SpoofImpl *SpoofImpl::validateThis(const USpoofChecker *sc, UErrorCode &amp;status) {

115     if (U_FAILURE(status)) {
116         return NULL;
117     }
<span class="line-removed">118     if (sc == NULL) {</span>
<span class="line-removed">119         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-removed">120         return NULL;</span>
<span class="line-removed">121     }</span>
<span class="line-removed">122     SpoofImpl *This = (SpoofImpl *)sc;</span>
<span class="line-removed">123     if (This-&gt;fMagic != USPOOF_MAGIC) {</span>
<span class="line-removed">124         status = U_INVALID_FORMAT_ERROR;</span>
<span class="line-removed">125         return NULL;</span>
<span class="line-removed">126     }</span>
127     if (This-&gt;fSpoofData != NULL &amp;&amp; !This-&gt;fSpoofData-&gt;validateDataVersion(status)) {
128         return NULL;
129     }
130     return This;
131 }
132 
133 SpoofImpl *SpoofImpl::validateThis(USpoofChecker *sc, UErrorCode &amp;status) {
134     return const_cast&lt;SpoofImpl *&gt;
135         (SpoofImpl::validateThis(const_cast&lt;const USpoofChecker *&gt;(sc), status));
136 }
137 
138 
139 void SpoofImpl::setAllowedLocales(const char *localesList, UErrorCode &amp;status) {
140     UnicodeSet    allowedChars;
141     UnicodeSet    *tmpSet = NULL;
142     const char    *locStart = localesList;
143     const char    *locEnd = NULL;
144     const char    *localesListEnd = localesList + uprv_strlen(localesList);
145     int32_t        localeListCount = 0;   // Number of locales provided by caller.
146 
</pre>
<hr />
<pre>
437             digitVal = 0xa + (s[i] - 0x61);  // Lower Case &#39;a&#39;
438         }
439         U_ASSERT(digitVal &lt;= 0xf);
440         val &lt;&lt;= 4;
441         val += digitVal;
442     }
443     if (val &gt; 0x10ffff) {
444         status = U_PARSE_ERROR;
445         val = 0;
446     }
447     return (UChar32)val;
448 }
449 
450 
451 //-----------------------------------------
452 //
453 //   class CheckResult Implementation
454 //
455 //-----------------------------------------
456 
<span class="line-modified">457 CheckResult::CheckResult() : fMagic(USPOOF_CHECK_MAGIC) {</span>
458     clear();
459 }
460 
461 USpoofCheckResult* CheckResult::asUSpoofCheckResult() {
<span class="line-modified">462     return reinterpret_cast&lt;USpoofCheckResult*&gt;(this);</span>
463 }
464 
465 //
466 //  Incoming parameter check on Status and the CheckResult object
467 //    received from the C API.
468 //
469 const CheckResult* CheckResult::validateThis(const USpoofCheckResult *ptr, UErrorCode &amp;status) {
<span class="line-modified">470     if (U_FAILURE(status)) { return NULL; }</span>
<span class="line-removed">471     if (ptr == NULL) {</span>
<span class="line-removed">472         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-removed">473         return NULL;</span>
<span class="line-removed">474     }</span>
<span class="line-removed">475     CheckResult *This = (CheckResult*) ptr;</span>
<span class="line-removed">476     if (This-&gt;fMagic != USPOOF_CHECK_MAGIC) {</span>
<span class="line-removed">477         status = U_INVALID_FORMAT_ERROR;</span>
<span class="line-removed">478         return NULL;</span>
<span class="line-removed">479     }</span>
<span class="line-removed">480     return This;</span>
481 }
482 
483 CheckResult* CheckResult::validateThis(USpoofCheckResult *ptr, UErrorCode &amp;status) {
<span class="line-modified">484     return const_cast&lt;CheckResult *&gt;</span>
<span class="line-removed">485         (CheckResult::validateThis(const_cast&lt;const USpoofCheckResult*&gt;(ptr), status));</span>
486 }
487 
488 void CheckResult::clear() {
489     fChecks = 0;
490     fNumerics.clear();
491     fRestrictionLevel = USPOOF_UNDEFINED_RESTRICTIVE;
492 }
493 
494 int32_t CheckResult::toCombinedBitmask(int32_t enabledChecks) {
495     if ((enabledChecks &amp; USPOOF_AUX_INFO) != 0 &amp;&amp; fRestrictionLevel != USPOOF_UNDEFINED_RESTRICTIVE) {
496         return fChecks | fRestrictionLevel;
497     } else {
498         return fChecks;
499     }
500 }
501 
502 CheckResult::~CheckResult() {
503 }
504 
505 //----------------------------------------------------------------------------------------------
</pre>
<hr />
<pre>
735 
736 
737 void SpoofData::removeReference() {
738     if (umtx_atomic_dec(&amp;fRefCount) == 0) {
739         delete this;
740     }
741 }
742 
743 
744 SpoofData *SpoofData::addReference() {
745     umtx_atomic_inc(&amp;fRefCount);
746     return this;
747 }
748 
749 
750 void *SpoofData::reserveSpace(int32_t numBytes,  UErrorCode &amp;status) {
751     if (U_FAILURE(status)) {
752         return NULL;
753     }
754     if (!fDataOwned) {
<span class="line-modified">755         U_ASSERT(FALSE);</span>
<span class="line-removed">756         status = U_INTERNAL_PROGRAM_ERROR;</span>
<span class="line-removed">757         return NULL;</span>
758     }
759 
760     numBytes = (numBytes + 15) &amp; ~15;   // Round up to a multiple of 16
761     uint32_t returnOffset = fMemLimit;
762     fMemLimit += numBytes;
763     fRawData = static_cast&lt;SpoofDataHeader *&gt;(uprv_realloc(fRawData, fMemLimit));
764     fRawData-&gt;fLength = fMemLimit;
765     uprv_memset((char *)fRawData + returnOffset, 0, numBytes);
766     initPtrs(status);
767     return (char *)fRawData + returnOffset;
768 }
769 
770 int32_t SpoofData::serialize(void *buf, int32_t capacity, UErrorCode &amp;status) const {
771     int32_t dataSize = fRawData-&gt;fLength;
772     if (capacity &lt; dataSize) {
773         status = U_BUFFER_OVERFLOW_ERROR;
774         return dataSize;
775     }
776     uprv_memcpy(buf, fRawData, dataSize);
777     return dataSize;
</pre>
</td>
<td>
<hr />
<pre>
 35 }
 36 
 37 SpoofImpl::SpoofImpl(UErrorCode&amp; status) {
 38     construct(status);
 39 
 40     // TODO: Call this method where it is actually needed, instead of in the
 41     // constructor, to allow for lazy data loading.  See #12696.
 42     fSpoofData = SpoofData::getDefault(status);
 43 }
 44 
 45 SpoofImpl::SpoofImpl() {
 46     UErrorCode status = U_ZERO_ERROR;
 47     construct(status);
 48 
 49     // TODO: Call this method where it is actually needed, instead of in the
 50     // constructor, to allow for lazy data loading.  See #12696.
 51     fSpoofData = SpoofData::getDefault(status);
 52 }
 53 
 54 void SpoofImpl::construct(UErrorCode&amp; status) {

 55     fChecks = USPOOF_ALL_CHECKS;
 56     fSpoofData = NULL;
 57     fAllowedCharsSet = NULL;
 58     fAllowedLocales = NULL;
 59     fRestrictionLevel = USPOOF_HIGHLY_RESTRICTIVE;
 60 
 61     if (U_FAILURE(status)) { return; }
 62 
 63     UnicodeSet *allowedCharsSet = new UnicodeSet(0, 0x10ffff);
 64     fAllowedCharsSet = allowedCharsSet;
 65     fAllowedLocales  = uprv_strdup(&quot;&quot;);
 66     if (fAllowedCharsSet == NULL || fAllowedLocales == NULL) {
 67         status = U_MEMORY_ALLOCATION_ERROR;
 68         return;
 69     }
 70     allowedCharsSet-&gt;freeze();
 71 }
 72 
 73 
 74 // Copy Constructor, used by the user level clone() function.
 75 SpoofImpl::SpoofImpl(const SpoofImpl &amp;src, UErrorCode &amp;status)  :
<span class="line-modified"> 76         fChecks(USPOOF_ALL_CHECKS), fSpoofData(NULL), fAllowedCharsSet(NULL) ,</span>
 77         fAllowedLocales(NULL) {
 78     if (U_FAILURE(status)) {
 79         return;
 80     }

 81     fChecks = src.fChecks;
 82     if (src.fSpoofData != NULL) {
 83         fSpoofData = src.fSpoofData-&gt;addReference();
 84     }
 85     fAllowedCharsSet = static_cast&lt;const UnicodeSet *&gt;(src.fAllowedCharsSet-&gt;clone());
 86     fAllowedLocales = uprv_strdup(src.fAllowedLocales);
 87     if (fAllowedCharsSet == NULL || fAllowedLocales == NULL) {
 88         status = U_MEMORY_ALLOCATION_ERROR;
 89     }
 90     fRestrictionLevel = src.fRestrictionLevel;
 91 }
 92 
 93 SpoofImpl::~SpoofImpl() {


 94     if (fSpoofData != NULL) {
 95         fSpoofData-&gt;removeReference();   // Will delete if refCount goes to zero.
 96     }
 97     delete fAllowedCharsSet;
 98     uprv_free((void *)fAllowedLocales);
 99 }
100 
101 //  Cast this instance as a USpoofChecker for the C API.
102 USpoofChecker *SpoofImpl::asUSpoofChecker() {
<span class="line-modified">103     return exportForC();</span>
104 }
105 
106 //
107 //  Incoming parameter check on Status and the SpoofChecker object
108 //    received from the C API.
109 //
110 const SpoofImpl *SpoofImpl::validateThis(const USpoofChecker *sc, UErrorCode &amp;status) {
<span class="line-added">111     auto* This = validate(sc, status);</span>
112     if (U_FAILURE(status)) {
113         return NULL;
114     }









115     if (This-&gt;fSpoofData != NULL &amp;&amp; !This-&gt;fSpoofData-&gt;validateDataVersion(status)) {
116         return NULL;
117     }
118     return This;
119 }
120 
121 SpoofImpl *SpoofImpl::validateThis(USpoofChecker *sc, UErrorCode &amp;status) {
122     return const_cast&lt;SpoofImpl *&gt;
123         (SpoofImpl::validateThis(const_cast&lt;const USpoofChecker *&gt;(sc), status));
124 }
125 
126 
127 void SpoofImpl::setAllowedLocales(const char *localesList, UErrorCode &amp;status) {
128     UnicodeSet    allowedChars;
129     UnicodeSet    *tmpSet = NULL;
130     const char    *locStart = localesList;
131     const char    *locEnd = NULL;
132     const char    *localesListEnd = localesList + uprv_strlen(localesList);
133     int32_t        localeListCount = 0;   // Number of locales provided by caller.
134 
</pre>
<hr />
<pre>
425             digitVal = 0xa + (s[i] - 0x61);  // Lower Case &#39;a&#39;
426         }
427         U_ASSERT(digitVal &lt;= 0xf);
428         val &lt;&lt;= 4;
429         val += digitVal;
430     }
431     if (val &gt; 0x10ffff) {
432         status = U_PARSE_ERROR;
433         val = 0;
434     }
435     return (UChar32)val;
436 }
437 
438 
439 //-----------------------------------------
440 //
441 //   class CheckResult Implementation
442 //
443 //-----------------------------------------
444 
<span class="line-modified">445 CheckResult::CheckResult() {</span>
446     clear();
447 }
448 
449 USpoofCheckResult* CheckResult::asUSpoofCheckResult() {
<span class="line-modified">450     return exportForC();</span>
451 }
452 
453 //
454 //  Incoming parameter check on Status and the CheckResult object
455 //    received from the C API.
456 //
457 const CheckResult* CheckResult::validateThis(const USpoofCheckResult *ptr, UErrorCode &amp;status) {
<span class="line-modified">458     return validate(ptr, status);</span>










459 }
460 
461 CheckResult* CheckResult::validateThis(USpoofCheckResult *ptr, UErrorCode &amp;status) {
<span class="line-modified">462     return validate(ptr, status);</span>

463 }
464 
465 void CheckResult::clear() {
466     fChecks = 0;
467     fNumerics.clear();
468     fRestrictionLevel = USPOOF_UNDEFINED_RESTRICTIVE;
469 }
470 
471 int32_t CheckResult::toCombinedBitmask(int32_t enabledChecks) {
472     if ((enabledChecks &amp; USPOOF_AUX_INFO) != 0 &amp;&amp; fRestrictionLevel != USPOOF_UNDEFINED_RESTRICTIVE) {
473         return fChecks | fRestrictionLevel;
474     } else {
475         return fChecks;
476     }
477 }
478 
479 CheckResult::~CheckResult() {
480 }
481 
482 //----------------------------------------------------------------------------------------------
</pre>
<hr />
<pre>
712 
713 
714 void SpoofData::removeReference() {
715     if (umtx_atomic_dec(&amp;fRefCount) == 0) {
716         delete this;
717     }
718 }
719 
720 
721 SpoofData *SpoofData::addReference() {
722     umtx_atomic_inc(&amp;fRefCount);
723     return this;
724 }
725 
726 
727 void *SpoofData::reserveSpace(int32_t numBytes,  UErrorCode &amp;status) {
728     if (U_FAILURE(status)) {
729         return NULL;
730     }
731     if (!fDataOwned) {
<span class="line-modified">732         UPRV_UNREACHABLE;</span>


733     }
734 
735     numBytes = (numBytes + 15) &amp; ~15;   // Round up to a multiple of 16
736     uint32_t returnOffset = fMemLimit;
737     fMemLimit += numBytes;
738     fRawData = static_cast&lt;SpoofDataHeader *&gt;(uprv_realloc(fRawData, fMemLimit));
739     fRawData-&gt;fLength = fMemLimit;
740     uprv_memset((char *)fRawData + returnOffset, 0, numBytes);
741     initPtrs(status);
742     return (char *)fRawData + returnOffset;
743 }
744 
745 int32_t SpoofData::serialize(void *buf, int32_t capacity, UErrorCode &amp;status) const {
746     int32_t dataSize = fRawData-&gt;fLength;
747     if (capacity &lt; dataSize) {
748         status = U_BUFFER_OVERFLOW_ERROR;
749         return dataSize;
750     }
751     uprv_memcpy(buf, fRawData, dataSize);
752     return dataSize;
</pre>
</td>
</tr>
</table>
<center><a href="uspoof_conf.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uspoof_impl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>