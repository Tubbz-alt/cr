<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ulocimp.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 2004-2016, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 **********************************************************************
  8 */
  9 
 10 #ifndef ULOCIMP_H
 11 #define ULOCIMP_H
 12 
 13 #include &quot;unicode/bytestream.h&quot;
 14 #include &quot;unicode/uloc.h&quot;
 15 
 16 /**
 17  * Create an iterator over the specified keywords list
 18  * @param keywordList double-null terminated list. Will be copied.
 19  * @param keywordListSize size in bytes of keywordList
 20  * @param status err code
 21  * @return enumeration (owned by caller) of the keyword list.
 22  * @internal ICU 3.0
 23  */
 24 U_CAPI UEnumeration* U_EXPORT2
 25 uloc_openKeywordList(const char *keywordList, int32_t keywordListSize, UErrorCode* status);
 26 
 27 /**
 28  * Look up a resource bundle table item with fallback on the table level.
 29  * This is accessible so it can be called by C++ code.
 30  */
 31 U_CAPI const UChar * U_EXPORT2
 32 uloc_getTableStringWithFallback(
 33     const char *path,
 34     const char *locale,
 35     const char *tableKey,
 36     const char *subTableKey,
 37     const char *itemKey,
 38     int32_t *pLength,
 39     UErrorCode *pErrorCode);
 40 
 41 /*returns TRUE if a is an ID separator FALSE otherwise*/
 42 #define _isIDSeparator(a) (a == &#39;_&#39; || a == &#39;-&#39;)
 43 
 44 U_CFUNC const char*
 45 uloc_getCurrentCountryID(const char* oldID);
 46 
 47 U_CFUNC const char*
 48 uloc_getCurrentLanguageID(const char* oldID);
 49 
 50 U_CFUNC int32_t
 51 ulocimp_getLanguage(const char *localeID,
 52                     char *language, int32_t languageCapacity,
 53                     const char **pEnd);
 54 
 55 U_CFUNC int32_t
 56 ulocimp_getScript(const char *localeID,
 57                    char *script, int32_t scriptCapacity,
 58                    const char **pEnd);
 59 
 60 U_CFUNC int32_t
 61 ulocimp_getCountry(const char *localeID,
 62                    char *country, int32_t countryCapacity,
 63                    const char **pEnd);
 64 
 65 /**
 66  * Writes a well-formed language tag for this locale ID.
 67  *
 68  * **Note**: When `strict` is FALSE, any locale fields which do not satisfy the
 69  * BCP47 syntax requirement will be omitted from the result.  When `strict` is
 70  * TRUE, this function sets U_ILLEGAL_ARGUMENT_ERROR to the `err` if any locale
 71  * fields do not satisfy the BCP47 syntax requirement.
 72  *
 73  * @param localeID  the input locale ID
 74  * @param sink      the output sink receiving the BCP47 language
 75  *                  tag for this Locale.
 76  * @param strict    boolean value indicating if the function returns
 77  *                  an error for an ill-formed input locale ID.
 78  * @param err       error information if receiving the language
 79  *                  tag failed.
 80  * @return          The length of the BCP47 language tag.
 81  *
 82  * @internal ICU 64
 83  */
 84 U_STABLE void U_EXPORT2
 85 ulocimp_toLanguageTag(const char* localeID,
 86                       icu::ByteSink&amp; sink,
 87                       UBool strict,
 88                       UErrorCode* err);
 89 
 90 /**
 91  * Returns a locale ID for the specified BCP47 language tag string.
 92  * If the specified language tag contains any ill-formed subtags,
 93  * the first such subtag and all following subtags are ignored.
 94  * &lt;p&gt;
 95  * This implements the &#39;Language-Tag&#39; production of BCP47, and so
 96  * supports grandfathered (regular and irregular) as well as private
 97  * use language tags.  Private use tags are represented as &#39;x-whatever&#39;,
 98  * and grandfathered tags are converted to their canonical replacements
 99  * where they exist.  Note that a few grandfathered tags have no modern
100  * replacement, these will be converted using the fallback described in
101  * the first paragraph, so some information might be lost.
102  * @param langtag   the input BCP47 language tag.
103  * @param tagLen    the length of langtag, or -1 to call uprv_strlen().
104  * @param sink      the output sink receiving a locale ID for the
105  *                  specified BCP47 language tag.
106  * @param parsedLength  if not NULL, successfully parsed length
107  *                      for the input language tag is set.
108  * @param err       error information if receiving the locald ID
109  *                  failed.
110  * @internal ICU 63
111  */
112 U_CAPI void U_EXPORT2
113 ulocimp_forLanguageTag(const char* langtag,
114                        int32_t tagLen,
115                        icu::ByteSink&amp; sink,
116                        int32_t* parsedLength,
117                        UErrorCode* err);
118 
119 /**
120  * Get the region to use for supplemental data lookup. Uses
121  * (1) any region specified by locale tag &quot;rg&quot;; if none then
122  * (2) any unicode_region_tag in the locale ID; if none then
123  * (3) if inferRegion is TRUE, the region suggested by
124  * getLikelySubtags on the localeID.
125  * If no region is found, returns length 0.
126  *
127  * @param localeID
128  *     The complete locale ID (with keywords) from which
129  *     to get the region to use for supplemental data.
130  * @param inferRegion
131  *     If TRUE, will try to infer region from localeID if
132  *     no other region is found.
133  * @param region
134  *     Buffer in which to put the region ID found; should
135  *     have a capacity at least ULOC_COUNTRY_CAPACITY.
136  * @param regionCapacity
137  *     The actual capacity of the region buffer.
138  * @param status
139  *     Pointer to in/out UErrorCode value for latest status.
140  * @return
141  *     The length of any region code found, or 0 if none.
142  * @internal ICU 57
143  */
144 U_CAPI int32_t U_EXPORT2
145 ulocimp_getRegionForSupplementalData(const char *localeID, UBool inferRegion,
146                                      char *region, int32_t regionCapacity, UErrorCode* status);
147 
148 /**
149  * Add the likely subtags for a provided locale ID, per the algorithm described
150  * in the following CLDR technical report:
151  *
152  *   http://www.unicode.org/reports/tr35/#Likely_Subtags
153  *
154  * If localeID is already in the maximal form, or there is no data available
155  * for maximization, it will be copied to the output buffer.  For example,
156  * &quot;und-Zzzz&quot; cannot be maximized, since there is no reasonable maximization.
157  *
158  * Examples:
159  *
160  * &quot;en&quot; maximizes to &quot;en_Latn_US&quot;
161  *
162  * &quot;de&quot; maximizes to &quot;de_Latn_US&quot;
163  *
164  * &quot;sr&quot; maximizes to &quot;sr_Cyrl_RS&quot;
165  *
166  * &quot;sh&quot; maximizes to &quot;sr_Latn_RS&quot; (Note this will not reverse.)
167  *
168  * &quot;zh_Hani&quot; maximizes to &quot;zh_Hans_CN&quot; (Note this will not reverse.)
169  *
170  * @param localeID The locale to maximize
171  * @param sink The output sink receiving the maximized locale
172  * @param err Error information if maximizing the locale failed.  If the length
173  * of the localeID and the null-terminator is greater than the maximum allowed size,
174  * or the localeId is not well-formed, the error code is U_ILLEGAL_ARGUMENT_ERROR.
175  * @internal ICU 64
176  */
177 U_STABLE void U_EXPORT2
178 ulocimp_addLikelySubtags(const char* localeID,
179                          icu::ByteSink&amp; sink,
180                          UErrorCode* err);
181 
182 /**
183  * Minimize the subtags for a provided locale ID, per the algorithm described
184  * in the following CLDR technical report:
185  *
186  *   http://www.unicode.org/reports/tr35/#Likely_Subtags
187  *
188  * If localeID is already in the minimal form, or there is no data available
189  * for minimization, it will be copied to the output buffer.  Since the
190  * minimization algorithm relies on proper maximization, see the comments
191  * for ulocimp_addLikelySubtags for reasons why there might not be any data.
192  *
193  * Examples:
194  *
195  * &quot;en_Latn_US&quot; minimizes to &quot;en&quot;
196  *
197  * &quot;de_Latn_US&quot; minimizes to &quot;de&quot;
198  *
199  * &quot;sr_Cyrl_RS&quot; minimizes to &quot;sr&quot;
200  *
201  * &quot;zh_Hant_TW&quot; minimizes to &quot;zh_TW&quot; (The region is preferred to the
202  * script, and minimizing to &quot;zh&quot; would imply &quot;zh_Hans_CN&quot;.)
203  *
204  * @param localeID The locale to minimize
205  * @param sink The output sink receiving the maximized locale
206  * @param err Error information if minimizing the locale failed.  If the length
207  * of the localeID and the null-terminator is greater than the maximum allowed size,
208  * or the localeId is not well-formed, the error code is U_ILLEGAL_ARGUMENT_ERROR.
209  * @internal ICU 64
210  */
211 U_STABLE void U_EXPORT2
212 ulocimp_minimizeSubtags(const char* localeID,
213                         icu::ByteSink&amp; sink,
214                         UErrorCode* err);
215 
216 U_CAPI const char * U_EXPORT2
217 locale_getKeywordsStart(const char *localeID);
218 
219 U_CFUNC UBool
220 ultag_isExtensionSubtags(const char* s, int32_t len);
221 
222 U_CFUNC UBool
223 ultag_isLanguageSubtag(const char* s, int32_t len);
224 
225 U_CFUNC UBool
226 ultag_isPrivateuseValueSubtags(const char* s, int32_t len);
227 
228 U_CFUNC UBool
229 ultag_isRegionSubtag(const char* s, int32_t len);
230 
231 U_CFUNC UBool
232 ultag_isScriptSubtag(const char* s, int32_t len);
233 
234 U_CFUNC UBool
235 ultag_isTransformedExtensionSubtags(const char* s, int32_t len);
236 
237 U_CFUNC UBool
238 ultag_isUnicodeExtensionSubtags(const char* s, int32_t len);
239 
240 U_CFUNC UBool
241 ultag_isUnicodeLocaleAttribute(const char* s, int32_t len);
242 
243 U_CFUNC UBool
244 ultag_isUnicodeLocaleAttributes(const char* s, int32_t len);
245 
246 U_CFUNC UBool
247 ultag_isUnicodeLocaleKey(const char* s, int32_t len);
248 
249 U_CFUNC UBool
250 ultag_isUnicodeLocaleType(const char* s, int32_t len);
251 
252 U_CFUNC UBool
253 ultag_isVariantSubtags(const char* s, int32_t len);
254 
255 U_CFUNC const char*
256 ulocimp_toBcpKey(const char* key);
257 
258 U_CFUNC const char*
259 ulocimp_toLegacyKey(const char* key);
260 
261 U_CFUNC const char*
262 ulocimp_toBcpType(const char* key, const char* type, UBool* isKnownKey, UBool* isSpecialType);
263 
264 U_CFUNC const char*
265 ulocimp_toLegacyType(const char* key, const char* type, UBool* isKnownKey, UBool* isSpecialType);
266 
267 #endif
    </pre>
  </body>
</html>