<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/regexcmp.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="rbtz.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="regexcst.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/regexcmp.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11 //  is used by the match finding engine.
  12 //
  13 
  14 #include &quot;unicode/utypes.h&quot;
  15 
  16 #if !UCONFIG_NO_REGULAR_EXPRESSIONS
  17 
  18 #include &quot;unicode/ustring.h&quot;
  19 #include &quot;unicode/unistr.h&quot;
  20 #include &quot;unicode/uniset.h&quot;
  21 #include &quot;unicode/uchar.h&quot;
  22 #include &quot;unicode/uchriter.h&quot;
  23 #include &quot;unicode/parsepos.h&quot;
  24 #include &quot;unicode/parseerr.h&quot;
  25 #include &quot;unicode/regex.h&quot;
  26 #include &quot;unicode/utf.h&quot;
  27 #include &quot;unicode/utf16.h&quot;
  28 #include &quot;patternprops.h&quot;
  29 #include &quot;putilimp.h&quot;
  30 #include &quot;cmemory.h&quot;

  31 #include &quot;cstring.h&quot;
  32 #include &quot;uvectr32.h&quot;
  33 #include &quot;uvectr64.h&quot;
  34 #include &quot;uassert.h&quot;
  35 #include &quot;uinvchar.h&quot;
  36 
  37 #include &quot;regeximp.h&quot;
  38 #include &quot;regexcst.h&quot;   // Contains state table for the regex pattern parser.
  39                         //   generated by a Perl script.
  40 #include &quot;regexcmp.h&quot;
  41 #include &quot;regexst.h&quot;
  42 #include &quot;regextxt.h&quot;
  43 
  44 
  45 
  46 U_NAMESPACE_BEGIN
  47 
  48 
  49 //------------------------------------------------------------------------------
  50 //
</pre>
<hr />
<pre>
1447 
1448 
1449     case doBeginMatchMode:
1450         fNewModeFlags = fModeFlags;
1451         fSetModeFlag  = TRUE;
1452         break;
1453 
1454     case doMatchMode:   //  (?i)    and similar
1455         {
1456             int32_t  bit = 0;
1457             switch (fC.fChar) {
1458             case 0x69: /* &#39;i&#39; */   bit = UREGEX_CASE_INSENSITIVE; break;
1459             case 0x64: /* &#39;d&#39; */   bit = UREGEX_UNIX_LINES;       break;
1460             case 0x6d: /* &#39;m&#39; */   bit = UREGEX_MULTILINE;        break;
1461             case 0x73: /* &#39;s&#39; */   bit = UREGEX_DOTALL;           break;
1462             case 0x75: /* &#39;u&#39; */   bit = 0; /* Unicode casing */  break;
1463             case 0x77: /* &#39;w&#39; */   bit = UREGEX_UWORD;            break;
1464             case 0x78: /* &#39;x&#39; */   bit = UREGEX_COMMENTS;         break;
1465             case 0x2d: /* &#39;-&#39; */   fSetModeFlag = FALSE;          break;
1466             default:
<span class="line-modified">1467                 U_ASSERT(FALSE);   // Should never happen.  Other chars are filtered out</span>
1468                                    // by the scanner.
1469             }
1470             if (fSetModeFlag) {
1471                 fNewModeFlags |= bit;
1472             } else {
1473                 fNewModeFlags &amp;= ~bit;
1474             }
1475         }
1476         break;
1477 
1478     case doSetMatchMode:
1479         // Emit code to match any pending literals, using the not-yet changed match mode.
1480         fixLiterals();
1481 
1482         // We&#39;ve got a (?i) or similar.  The match mode is being changed, but
1483         //   the change is not scoped to a parenthesized block.
1484         U_ASSERT(fNewModeFlags &lt; 0);
1485         fModeFlags = fNewModeFlags;
1486 
1487         break;
</pre>
<hr />
<pre>
1822         break;
1823 
1824 
1825     case doSetRange:
1826         // We have scanned literal-literal.  Add the range to the set.
1827         // The left character is already in the set, and is saved in fLastSetLiteral.
1828         // The right side is the current character.
1829         // Lower Limit &gt; Upper limit being an error matches both Java
1830         //        and ICU UnicodeSet behavior.
1831         {
1832 
1833         if (fLastSetLiteral == U_SENTINEL || fLastSetLiteral &gt; fC.fChar) {
1834             error(U_REGEX_INVALID_RANGE);
1835         }
1836         UnicodeSet *s = (UnicodeSet *)fSetStack.peek();
1837         s-&gt;add(fLastSetLiteral, fC.fChar);
1838         break;
1839         }
1840 
1841     default:
<span class="line-modified">1842         U_ASSERT(FALSE);</span>
<span class="line-removed">1843         error(U_REGEX_INTERNAL_ERROR);</span>
<span class="line-removed">1844         break;</span>
1845     }
1846 
1847     if (U_FAILURE(*fStatus)) {
1848         returnVal = FALSE;
1849     }
1850 
1851     return returnVal;
1852 }
1853 
1854 
1855 
1856 //------------------------------------------------------------------------------
1857 //
1858 //   literalChar           We&#39;ve encountered a literal character from the pattern,
1859 //                             or an escape sequence that reduces to a character.
1860 //                         Add it to the string containing all literal chars/strings from
1861 //                             the pattern.
1862 //
1863 //------------------------------------------------------------------------------
1864 void RegexCompile::literalChar(UChar32 c)  {
</pre>
<hr />
<pre>
1931         } else {
1932             // TODO here:  add optimization to split case sensitive strings of length two
1933             //             into two single char ops, for efficiency.
1934             appendOp(URX_STRING, fRXPat-&gt;fLiteralText.length());
1935         }
1936         appendOp(URX_STRING_LEN, fLiteralChars.length());
1937 
1938         // Add this string into the accumulated strings of the compiled pattern.
1939         fRXPat-&gt;fLiteralText.append(fLiteralChars);
1940     }
1941 
1942     fLiteralChars.remove();
1943 }
1944 
1945 
1946 int32_t RegexCompile::buildOp(int32_t type, int32_t val) {
1947     if (U_FAILURE(*fStatus)) {
1948         return 0;
1949     }
1950     if (type &lt; 0 || type &gt; 255) {
<span class="line-modified">1951         U_ASSERT(FALSE);</span>
<span class="line-removed">1952         error(U_REGEX_INTERNAL_ERROR);</span>
<span class="line-removed">1953         type = URX_RESERVED_OP;</span>
1954     }
1955     if (val &gt; 0x00ffffff) {
<span class="line-modified">1956         U_ASSERT(FALSE);</span>
<span class="line-removed">1957         error(U_REGEX_INTERNAL_ERROR);</span>
<span class="line-removed">1958         val = 0;</span>
1959     }
1960     if (val &lt; 0) {
1961         if (!(type == URX_RESERVED_OP_N || type == URX_RESERVED_OP)) {
<span class="line-modified">1962             U_ASSERT(FALSE);</span>
<span class="line-removed">1963             error(U_REGEX_INTERNAL_ERROR);</span>
<span class="line-removed">1964             return -1;</span>
1965         }
1966         if (URX_TYPE(val) != 0xff) {
<span class="line-modified">1967             U_ASSERT(FALSE);</span>
<span class="line-removed">1968             error(U_REGEX_INTERNAL_ERROR);</span>
<span class="line-removed">1969             return -1;</span>
1970         }
1971         type = URX_RESERVED_OP_N;
1972     }
1973     return (type &lt;&lt; 24) | val;
1974 }
1975 
1976 
1977 //------------------------------------------------------------------------------
1978 //
1979 //   appendOp()             Append a new instruction onto the compiled pattern
1980 //                          Includes error checking, limiting the size of the
1981 //                          pattern to lengths that can be represented in the
1982 //                          24 bit operand field of an instruction.
1983 //
1984 //------------------------------------------------------------------------------
1985 void RegexCompile::appendOp(int32_t op) {
1986     if (U_FAILURE(*fStatus)) {
1987         return;
1988     }
1989     fRXPat-&gt;fCompiledPat-&gt;addElement(op, *fStatus);
</pre>
<hr />
<pre>
2277             int32_t  startOp = (int32_t)fRXPat-&gt;fCompiledPat-&gt;elementAti(fMatchOpenParen-4);
2278             U_ASSERT(URX_TYPE(startOp) == URX_LB_START);
2279             int32_t dataLoc  = URX_VAL(startOp);
2280             appendOp(URX_LB_END, dataLoc);
2281             appendOp(URX_LA_END, dataLoc);
2282 
2283             // Determine the min and max bounds for the length of the
2284             //  string that the pattern can match.
2285             //  An unbounded upper limit is an error.
2286             int32_t patEnd   = fRXPat-&gt;fCompiledPat-&gt;size() - 1;
2287             int32_t minML    = minMatchLength(fMatchOpenParen, patEnd);
2288             int32_t maxML    = maxMatchLength(fMatchOpenParen, patEnd);
2289             if (URX_TYPE(maxML) != 0) {
2290                 error(U_REGEX_LOOK_BEHIND_LIMIT);
2291                 break;
2292             }
2293             if (maxML == INT32_MAX) {
2294                 error(U_REGEX_LOOK_BEHIND_LIMIT);
2295                 break;
2296             }







2297             U_ASSERT(minML &lt;= maxML);
2298 
2299             // Insert the min and max match len bounds into the URX_LB_CONT op that
2300             //  appears at the top of the look-behind block, at location fMatchOpenParen+1
2301             fRXPat-&gt;fCompiledPat-&gt;setElementAt(minML,  fMatchOpenParen-2);
2302             fRXPat-&gt;fCompiledPat-&gt;setElementAt(maxML,  fMatchOpenParen-1);
2303 
2304         }
2305         break;
2306 
2307 
2308 
2309     case lookBehindN:
2310         {
2311             // See comment at doOpenLookBehindNeg.
2312 
2313             // Append the URX_LBN_END to the compiled pattern.
2314             int32_t  startOp = (int32_t)fRXPat-&gt;fCompiledPat-&gt;elementAti(fMatchOpenParen-5);
2315             U_ASSERT(URX_TYPE(startOp) == URX_LB_START);
2316             int32_t dataLoc  = URX_VAL(startOp);
2317             appendOp(URX_LBN_END, dataLoc);
2318 
2319             // Determine the min and max bounds for the length of the
2320             //  string that the pattern can match.
2321             //  An unbounded upper limit is an error.
2322             int32_t patEnd   = fRXPat-&gt;fCompiledPat-&gt;size() - 1;
2323             int32_t minML    = minMatchLength(fMatchOpenParen, patEnd);
2324             int32_t maxML    = maxMatchLength(fMatchOpenParen, patEnd);
2325             if (URX_TYPE(maxML) != 0) {
2326                 error(U_REGEX_LOOK_BEHIND_LIMIT);
2327                 break;
2328             }
2329             if (maxML == INT32_MAX) {
2330                 error(U_REGEX_LOOK_BEHIND_LIMIT);
2331                 break;
2332             }








2333             U_ASSERT(minML &lt;= maxML);
2334 
2335             // Insert the min and max match len bounds into the URX_LB_CONT op that
2336             //  appears at the top of the look-behind block, at location fMatchOpenParen+1
2337             fRXPat-&gt;fCompiledPat-&gt;setElementAt(minML,  fMatchOpenParen-3);
2338             fRXPat-&gt;fCompiledPat-&gt;setElementAt(maxML,  fMatchOpenParen-2);
2339 
2340             // Insert the pattern location to continue at after a successful match
2341             //  as the last operand of the URX_LBN_CONT
2342             int32_t op = buildOp(URX_RELOC_OPRND, fRXPat-&gt;fCompiledPat-&gt;size());
2343             fRXPat-&gt;fCompiledPat-&gt;setElementAt(op,  fMatchOpenParen-1);
2344         }
2345         break;
2346 
2347 
2348 
2349     default:
<span class="line-modified">2350         U_ASSERT(FALSE);</span>
2351     }
2352 
2353     // remember the next location in the compiled pattern.
2354     // The compilation of Quantifiers will look at this to see whether its looping
2355     //   over a parenthesized block or a single item
2356     fMatchCloseParen = fRXPat-&gt;fCompiledPat-&gt;size();
2357 }
2358 
2359 
2360 
2361 //------------------------------------------------------------------------------
2362 //
2363 //   compileSet       Compile the pattern operations for a reference to a
2364 //                    UnicodeSet.
2365 //
2366 //------------------------------------------------------------------------------
2367 void        RegexCompile::compileSet(UnicodeSet *theSet)
2368 {
2369     if (theSet == NULL) {
2370         return;
</pre>
<hr />
<pre>
2590         0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
2591         0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x1, 0x1, 0x1, 0};
2592 
2593     static const UChar RECaseFixData[] = {
2594         0x1e9a, 0xfb00, 0xfb01, 0xfb02, 0xfb03, 0xfb04, 0x1e96, 0x130, 0x1f0, 0xdf,
2595         0x1e9e, 0xfb05, 0xfb06, 0x1e97, 0x1e98, 0x1e99, 0x149, 0x1fb4, 0x1fc4, 0x1fb3,
2596         0x1fb6, 0x1fb7, 0x1fbc, 0x1fc3, 0x1fc6, 0x1fc7, 0x1fcc, 0x390, 0x1fd2, 0x1fd3,
2597         0x1fd6, 0x1fd7, 0x1fe4, 0x3b0, 0x1f50, 0x1f52, 0x1f54, 0x1f56, 0x1fe2, 0x1fe3,
2598         0x1fe6, 0x1fe7, 0x1ff3, 0x1ff6, 0x1ff7, 0x1ffc, 0x1ff4, 0x587, 0xfb13, 0xfb14,
2599         0xfb15, 0xfb17, 0xfb16, 0x1f80, 0x1f88, 0x1f81, 0x1f89, 0x1f82, 0x1f8a, 0x1f83,
2600         0x1f8b, 0x1f84, 0x1f8c, 0x1f85, 0x1f8d, 0x1f86, 0x1f8e, 0x1f87, 0x1f8f, 0x1f90,
2601         0x1f98, 0x1f91, 0x1f99, 0x1f92, 0x1f9a, 0x1f93, 0x1f9b, 0x1f94, 0x1f9c, 0x1f95,
2602         0x1f9d, 0x1f96, 0x1f9e, 0x1f97, 0x1f9f, 0x1fa0, 0x1fa8, 0x1fa1, 0x1fa9, 0x1fa2,
2603         0x1faa, 0x1fa3, 0x1fab, 0x1fa4, 0x1fac, 0x1fa5, 0x1fad, 0x1fa6, 0x1fae, 0x1fa7,
2604         0x1faf, 0x1fb2, 0x1fc2, 0x1ff2, 0};
2605 
2606 // End of machine generated data.
2607 
2608     if (c &lt; UCHAR_MIN_VALUE || c &gt; UCHAR_MAX_VALUE) {
2609         // This function should never be called with an invalid input character.
<span class="line-modified">2610         U_ASSERT(FALSE);</span>
<span class="line-removed">2611         starterChars-&gt;clear();</span>
2612     } else if (u_hasBinaryProperty(c, UCHAR_CASE_SENSITIVE)) {
2613         UChar32 caseFoldedC  = u_foldCase(c, U_FOLD_CASE_DEFAULT);
2614         starterChars-&gt;set(caseFoldedC, caseFoldedC);
2615 
2616         int32_t i;
2617         for (i=0; RECaseFixCodePoints[i]&lt;c ; i++) {
2618             // Simple linear search through the sorted list of interesting code points.
2619         }
2620 
2621         if (RECaseFixCodePoints[i] == c) {
2622             int32_t dataIndex = RECaseFixStringOffsets[i];
2623             int32_t numCharsToAdd = RECaseFixCounts[i];
2624             UChar32 cpToAdd = 0;
2625             for (int32_t j=0; j&lt;numCharsToAdd; j++) {
2626                 U16_NEXT_UNSAFE(RECaseFixData, dataIndex, cpToAdd);
2627                 starterChars-&gt;add(cpToAdd);
2628             }
2629         }
2630 
2631         starterChars-&gt;closeOver(USET_CASE_INSENSITIVE);
</pre>
<hr />
<pre>
3085                     if (URX_TYPE(op) == URX_STATE_SAVE) {
3086                         // Need this because neg lookahead blocks will FAIL to outside
3087                         //   of the block.
3088                         int32_t  jmpDest = URX_VAL(op);
3089                         if (jmpDest &gt; loc) {
3090                             if (currentLen &lt; forwardedLength.elementAti(jmpDest)) {
3091                                 forwardedLength.setElementAt(currentLen, jmpDest);
3092                             }
3093                         }
3094                     }
3095                     U_ASSERT(loc &lt;= end);
3096                 }
3097             }
3098             break;
3099 
3100         case URX_LA_END:
3101         case URX_LB_CONT:
3102         case URX_LB_END:
3103         case URX_LBN_CONT:
3104         case URX_LBN_END:
<span class="line-modified">3105             U_ASSERT(FALSE);     // Shouldn&#39;t get here.  These ops should be</span>
3106                                  //  consumed by the scan in URX_LA_START and LB_START
<span class="line-removed">3107 </span>
<span class="line-removed">3108             break;</span>
<span class="line-removed">3109 </span>
3110         default:
<span class="line-modified">3111             U_ASSERT(FALSE);</span>
3112             }
3113 
3114         }
3115 
3116 
3117     // We have finished walking through the ops.  Check whether some forward jump
3118     //   propagated a shorter length to location end+1.
3119     if (forwardedLength.elementAti(end+1) &lt; currentLen) {
3120         currentLen = forwardedLength.elementAti(end+1);
3121     }
3122 
3123 
3124     fRXPat-&gt;fInitialChars8-&gt;init(fRXPat-&gt;fInitialChars);
3125 
3126 
3127     // Sort out what we should check for when looking for candidate match start positions.
3128     // In order of preference,
3129     //     1.   Start of input text buffer.
3130     //     2.   A literal string.
3131     //     3.   Start of line in multi-line mode.
</pre>
<hr />
<pre>
3411                             if (currentLen &lt; forwardedLength.elementAti(jmpDest)) {
3412                                 forwardedLength.setElementAt(currentLen, jmpDest);
3413                             }
3414                         }
3415                     }
3416                     U_ASSERT(loc &lt;= end);
3417                 }
3418             }
3419             break;
3420 
3421         case URX_LA_END:
3422         case URX_LB_CONT:
3423         case URX_LB_END:
3424         case URX_LBN_CONT:
3425         case URX_LBN_END:
3426             // Only come here if the matching URX_LA_START or URX_LB_START was not in the
3427             //   range being sized, which happens when measuring size of look-behind blocks.
3428             break;
3429 
3430         default:
<span class="line-modified">3431             U_ASSERT(FALSE);</span>
3432             }
3433 
3434         }
3435 
3436     // We have finished walking through the ops.  Check whether some forward jump
3437     //   propagated a shorter length to location end+1.
3438     if (forwardedLength.elementAti(end+1) &lt; currentLen) {
3439         currentLen = forwardedLength.elementAti(end+1);
3440         U_ASSERT(currentLen&gt;=0 &amp;&amp; currentLen &lt; INT32_MAX);
3441     }
3442 
3443     return currentLen;
3444 }
3445 
3446 //------------------------------------------------------------------------------
3447 //
3448 //   maxMatchLength    Calculate the length of the longest string that could
3449 //                     match the specified pattern.
3450 //                     Length is in 16 bit code units, not code points.
3451 //
</pre>
<hr />
<pre>
3655                     currentLen = INT32_MAX;
3656                     break;
3657                 }
3658 
3659                 U_ASSERT(loopEndLoc &gt;= loc+4);
3660                 int64_t blockLen = maxMatchLength(loc+4, loopEndLoc-1);  // Recursive call.
3661                 int64_t updatedLen = (int64_t)currentLen + blockLen * maxLoopCount;
3662                 if (updatedLen &gt;= INT32_MAX) {
3663                     currentLen = INT32_MAX;
3664                     break;
3665                 }
3666                 currentLen = (int32_t)updatedLen;
3667                 loc = loopEndLoc;
3668                 break;
3669             }
3670 
3671         case URX_CTR_LOOP:
3672         case URX_CTR_LOOP_NG:
3673             // These opcodes will be skipped over by code for URX_CRT_INIT.
3674             // We shouldn&#39;t encounter them here.
<span class="line-modified">3675             U_ASSERT(FALSE);</span>
<span class="line-removed">3676             break;</span>
3677 
3678         case URX_LOOP_SR_I:
3679         case URX_LOOP_DOT_I:
3680         case URX_LOOP_C:
3681             // For anything to do with loops, make the match length unbounded.
3682             currentLen = INT32_MAX;
3683             break;
3684 
3685 
3686 
3687         case URX_LA_START:
3688         case URX_LA_END:
3689             // Look-ahead.  Just ignore, treat the look-ahead block as if
3690             // it were normal pattern.  Gives a too-long match length,
3691             //  but good enough for now.
3692             break;
3693 
3694             // End of look-ahead ops should always be consumed by the processing at
3695             //  the URX_LA_START op.
<span class="line-modified">3696             // U_ASSERT(FALSE);</span>
<span class="line-removed">3697             // break;</span>
3698 
3699         case URX_LB_START:
3700             {
3701                 // Look-behind.  Scan forward until the matching look-around end,
3702                 //   without processing the look-behind block.
3703                 int32_t  depth = 0;
3704                 for (;;) {
3705                     loc++;
3706                     op = (int32_t)fRXPat-&gt;fCompiledPat-&gt;elementAti(loc);
3707                     if (URX_TYPE(op) == URX_LA_START || URX_TYPE(op) == URX_LB_START) {
3708                         depth++;
3709                     }
3710                     if (URX_TYPE(op) == URX_LA_END || URX_TYPE(op)==URX_LBN_END) {
3711                         if (depth == 0) {
3712                             break;
3713                         }
3714                         depth--;
3715                     }
3716                     U_ASSERT(loc &lt; end);
3717                 }
3718             }
3719             break;
3720 
3721         default:
<span class="line-modified">3722             U_ASSERT(FALSE);</span>
3723         }
3724 
3725 
3726         if (currentLen == INT32_MAX) {
3727             //  The maximum length is unbounded.
3728             //  Stop further processing of the pattern.
3729             break;
3730         }
3731 
3732     }
3733     return currentLen;
3734 
3735 }
3736 
3737 
3738 //------------------------------------------------------------------------------
3739 //
3740 //   stripNOPs    Remove any NOP operations from the compiled pattern code.
3741 //                Extra NOPs are inserted for some constructs during the initial
3742 //                code generation to provide locations that may be patched later.
</pre>
<hr />
<pre>
3857         case URX_LB_START:
3858         case URX_LB_CONT:
3859         case URX_LB_END:
3860         case URX_LBN_CONT:
3861         case URX_LBN_END:
3862         case URX_LOOP_SR_I:
3863         case URX_LOOP_DOT_I:
3864         case URX_LOOP_C:
3865         case URX_DOLLAR_D:
3866         case URX_DOLLAR_MD:
3867         case URX_BACKSLASH_H:
3868         case URX_BACKSLASH_R:
3869         case URX_BACKSLASH_V:
3870             // These instructions are unaltered by the relocation.
3871             fRXPat-&gt;fCompiledPat-&gt;setElementAt(op, dst);
3872             dst++;
3873             break;
3874 
3875         default:
3876             // Some op is unaccounted for.
<span class="line-modified">3877             U_ASSERT(FALSE);</span>
<span class="line-removed">3878             error(U_REGEX_INTERNAL_ERROR);</span>
3879         }
3880     }
3881 
3882     fRXPat-&gt;fCompiledPat-&gt;setSize(dst);
3883 }
3884 
3885 
3886 
3887 
3888 //------------------------------------------------------------------------------
3889 //
3890 //  Error         Report a rule parse error.
3891 //                Only report it if no previous error has been recorded.
3892 //
3893 //------------------------------------------------------------------------------
3894 void RegexCompile::error(UErrorCode e) {
<span class="line-modified">3895     if (U_SUCCESS(*fStatus)) {</span>
3896         *fStatus = e;
3897         // Hmm. fParseErr (UParseError) line &amp; offset fields are int32_t in public
3898         // API (see common/unicode/parseerr.h), while fLineNum and fCharNum are
3899         // int64_t. If the values of the latter are out of range for the former,
3900         // set them to the appropriate &quot;field not supported&quot; values.
3901         if (fLineNum &gt; 0x7FFFFFFF) {
3902             fParseErr-&gt;line   = 0;
3903             fParseErr-&gt;offset = -1;
3904         } else if (fCharNum &gt; 0x7FFFFFFF) {
3905             fParseErr-&gt;line   = (int32_t)fLineNum;
3906             fParseErr-&gt;offset = -1;
3907         } else {
3908             fParseErr-&gt;line   = (int32_t)fLineNum;
3909             fParseErr-&gt;offset = (int32_t)fCharNum;
3910         }
3911 
3912         UErrorCode status = U_ZERO_ERROR; // throwaway status for extracting context
3913 
3914         // Fill in the context.
3915         //   Note: extractBetween() pins supplied indicies to the string bounds.
</pre>
<hr />
<pre>
3994 //   peekCharLL    Low Level Character Scanning, sneak a peek at the next
3995 //                 character without actually getting it.
3996 //
3997 //------------------------------------------------------------------------------
3998 UChar32  RegexCompile::peekCharLL() {
3999     if (fPeekChar == -1) {
4000         fPeekChar = nextCharLL();
4001     }
4002     return fPeekChar;
4003 }
4004 
4005 
4006 //------------------------------------------------------------------------------
4007 //
4008 //   nextChar     for pattern scanning.  At this level, we handle stripping
4009 //                out comments and processing some backslash character escapes.
4010 //                The rest of the pattern grammar is handled at the next level up.
4011 //
4012 //------------------------------------------------------------------------------
4013 void RegexCompile::nextChar(RegexPatternChar &amp;c) {
<span class="line-modified">4014 </span>
4015     fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat-&gt;fPattern);
4016     c.fChar    = nextCharLL();
4017     c.fQuoted  = FALSE;
4018 
4019     if (fQuoteMode) {
4020         c.fQuoted = TRUE;
4021         if ((c.fChar==chBackSlash &amp;&amp; peekCharLL()==chE &amp;&amp; ((fModeFlags &amp; UREGEX_LITERAL) == 0)) ||
4022             c.fChar == (UChar32)-1) {
4023             fQuoteMode = FALSE;  //  Exit quote mode,
4024             nextCharLL();        // discard the E
<span class="line-modified">4025             nextChar(c);         // recurse to get the real next char</span>


4026         }
4027     }
4028     else if (fInBackslashQuote) {
4029         // The current character immediately follows a &#39;\&#39;
4030         // Don&#39;t check for any further escapes, just return it as-is.
4031         // Don&#39;t set c.fQuoted, because that would prevent the state machine from
4032         //    dispatching on the character.
4033         fInBackslashQuote = FALSE;
4034     }
4035     else
4036     {
4037         // We are not in a \Q quoted region \E of the source.
4038         //
4039         if (fModeFlags &amp; UREGEX_COMMENTS) {
4040             //
4041             // We are in free-spacing and comments mode.
4042             //  Scan through any white space and comments, until we
4043             //  reach a significant character or the end of inut.
4044             for (;;) {
4045                 if (c.fChar == (UChar32)-1) {
</pre>
<hr />
<pre>
4123                         if (index==0) {
4124                            // \0 is not followed by any octal digits.
4125                            error(U_REGEX_BAD_ESCAPE_SEQUENCE);
4126                         }
4127                         break;
4128                     }
4129                     c.fChar &lt;&lt;= 3;
4130                     c.fChar += ch&amp;7;
4131                     if (c.fChar &lt;= 255) {
4132                         nextCharLL();
4133                     } else {
4134                         // The last digit made the number too big.  Forget we saw it.
4135                         c.fChar &gt;&gt;= 3;
4136                     }
4137                 }
4138                 c.fQuoted = TRUE;
4139             }
4140             else if (peekCharLL() == chQ) {
4141                 //  &quot;\Q&quot;  enter quote mode, which will continue until &quot;\E&quot;
4142                 fQuoteMode = TRUE;
<span class="line-modified">4143                 nextCharLL();       // discard the &#39;Q&#39;.</span>
<span class="line-modified">4144                 nextChar(c);        // recurse to get the real next char.</span>


4145             }
4146             else
4147             {
4148                 // We are in a &#39;\&#39; escape that will be handled by the state table scanner.
4149                 // Just return the backslash, but remember that the following char is to
4150                 //  be taken literally.
4151                 fInBackslashQuote = TRUE;
4152             }
4153         }
4154     }
4155 
4156     // re-enable # to end-of-line comments, in case they were disabled.
4157     // They are disabled by the parser upon seeing &#39;(?&#39;, but this lasts for
4158     //  the fetching of the next character only.
4159     fEOLComments = TRUE;
4160 
4161     // putc(c.fChar, stdout);
4162 }
4163 
4164 
</pre>
<hr />
<pre>
4353         fCharNum          = savedCharNum;
4354         fLastChar         = savedLastChar;
4355         fPeekChar         = savedPeekChar;
4356         fC                = savedfC;
4357         UTEXT_SETNATIVEINDEX(fRXPat-&gt;fPattern, savedNextIndex);
4358     }
4359     return uset;
4360 }
4361 
4362 static inline void addIdentifierIgnorable(UnicodeSet *set, UErrorCode&amp; ec) {
4363     set-&gt;add(0, 8).add(0x0e, 0x1b).add(0x7f, 0x9f);
4364     addCategory(set, U_GC_CF_MASK, ec);
4365 }
4366 
4367 //
4368 //  Create a Unicode Set from a Unicode Property expression.
4369 //     This is common code underlying both \p{...} ane [:...:] expressions.
4370 //     Includes trying the Java &quot;properties&quot; that aren&#39;t supported as
4371 //     normal ICU UnicodeSet properties
4372 //
<span class="line-removed">4373 static const UChar posSetPrefix[] = {0x5b, 0x5c, 0x70, 0x7b, 0}; // &quot;[\p{&quot;</span>
<span class="line-removed">4374 static const UChar negSetPrefix[] = {0x5b, 0x5c, 0x50, 0x7b, 0}; // &quot;[\P{&quot;</span>
4375 UnicodeSet *RegexCompile::createSetForProperty(const UnicodeString &amp;propName, UBool negated) {
<span class="line-removed">4376     UnicodeString   setExpr;</span>
<span class="line-removed">4377     UnicodeSet      *set;</span>
<span class="line-removed">4378     uint32_t        usetFlags = 0;</span>
4379 
4380     if (U_FAILURE(*fStatus)) {
<span class="line-modified">4381         return NULL;</span>
4382     }


4383 
<span class="line-modified">4384     //</span>
<span class="line-modified">4385     //  First try the property as we received it</span>
<span class="line-modified">4386     //</span>
<span class="line-modified">4387     if (negated) {</span>
<span class="line-modified">4388         setExpr.append(negSetPrefix, -1);</span>
<span class="line-modified">4389     } else {</span>
<span class="line-modified">4390         setExpr.append(posSetPrefix, -1);</span>
<span class="line-modified">4391     }</span>
<span class="line-modified">4392     setExpr.append(propName);</span>
<span class="line-modified">4393     setExpr.append(chRBrace);</span>
<span class="line-modified">4394     setExpr.append(chRBracket);</span>
<span class="line-removed">4395     if (fModeFlags &amp; UREGEX_CASE_INSENSITIVE) {</span>
<span class="line-removed">4396         usetFlags |= USET_CASE_INSENSITIVE;</span>
<span class="line-removed">4397     }</span>
<span class="line-removed">4398     set = new UnicodeSet(setExpr, usetFlags, NULL, *fStatus);</span>
<span class="line-removed">4399     if (U_SUCCESS(*fStatus)) {</span>
<span class="line-removed">4400        return set;</span>
<span class="line-removed">4401     }</span>
<span class="line-removed">4402     delete set;</span>
<span class="line-removed">4403     set = NULL;</span>
<span class="line-removed">4404 </span>
<span class="line-removed">4405     //</span>
<span class="line-removed">4406     //  The property as it was didn&#39;t work.</span>
<span class="line-removed">4407 </span>
<span class="line-removed">4408     //  Do [:word:]. It is not recognized as a property by UnicodeSet.  &quot;word&quot; not standard POSIX</span>
<span class="line-removed">4409     //     or standard Java, but many other regular expression packages do recognize it.</span>
<span class="line-removed">4410 </span>
<span class="line-removed">4411     if (propName.caseCompare(UNICODE_STRING_SIMPLE(&quot;word&quot;), 0) == 0) {</span>
<span class="line-removed">4412         *fStatus = U_ZERO_ERROR;</span>
<span class="line-removed">4413         set = new UnicodeSet(*(fRXPat-&gt;fStaticSets[URX_ISWORD_SET]));</span>
<span class="line-removed">4414         if (set == NULL) {</span>
<span class="line-removed">4415             *fStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">4416             return set;</span>
4417         }
<span class="line-modified">4418         if (negated) {</span>
<span class="line-modified">4419             set-&gt;complement();</span>

4420         }
<span class="line-removed">4421         return set;</span>
<span class="line-removed">4422     }</span>
4423 


4424 
<span class="line-modified">4425     //    Do Java fixes -</span>
<span class="line-modified">4426     //       InGreek -&gt; InGreek or Coptic, that being the official Unicode name for that block.</span>
<span class="line-modified">4427     //       InCombiningMarksforSymbols -&gt; InCombiningDiacriticalMarksforSymbols.</span>
<span class="line-removed">4428     //</span>
<span class="line-removed">4429     //       Note on Spaces:  either &quot;InCombiningMarksForSymbols&quot; or &quot;InCombining Marks for Symbols&quot;</span>
<span class="line-removed">4430     //                        is accepted by Java.  The property part of the name is compared</span>
<span class="line-removed">4431     //                        case-insenstively.  The spaces must be exactly as shown, either</span>
<span class="line-removed">4432     //                        all there, or all omitted, with exactly one at each position</span>
<span class="line-removed">4433     //                        if they are present.  From checking against JDK 1.6</span>
<span class="line-removed">4434     //</span>
<span class="line-removed">4435     //       This code should be removed when ICU properties support the Java  compatibility names</span>
<span class="line-removed">4436     //          (ICU 4.0?)</span>
<span class="line-removed">4437     //</span>
<span class="line-removed">4438     UnicodeString mPropName = propName;</span>
<span class="line-removed">4439     if (mPropName.caseCompare(UNICODE_STRING_SIMPLE(&quot;InGreek&quot;), 0) == 0) {</span>
<span class="line-removed">4440         mPropName = UNICODE_STRING_SIMPLE(&quot;InGreek and Coptic&quot;);</span>
<span class="line-removed">4441     }</span>
<span class="line-removed">4442     if (mPropName.caseCompare(UNICODE_STRING_SIMPLE(&quot;InCombining Marks for Symbols&quot;), 0) == 0 ||</span>
<span class="line-removed">4443         mPropName.caseCompare(UNICODE_STRING_SIMPLE(&quot;InCombiningMarksforSymbols&quot;), 0) == 0) {</span>
<span class="line-removed">4444         mPropName = UNICODE_STRING_SIMPLE(&quot;InCombining Diacritical Marks for Symbols&quot;);</span>
<span class="line-removed">4445     }</span>
<span class="line-removed">4446     else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;all&quot;)) == 0) {</span>
<span class="line-removed">4447         mPropName = UNICODE_STRING_SIMPLE(&quot;javaValidCodePoint&quot;);</span>
<span class="line-removed">4448     }</span>
4449 
<span class="line-modified">4450     //    See if the property looks like a Java &quot;InBlockName&quot;, which</span>
<span class="line-modified">4451     //    we will recast as &quot;Block=BlockName&quot;</span>
<span class="line-modified">4452     //</span>
<span class="line-modified">4453     if (mPropName.startsWith(u&quot;In&quot;, 2) &amp;&amp; propName.length()&gt;=3) {</span>
<span class="line-modified">4454         setExpr.truncate(4);   // Leaves &quot;[\p{&quot;, or &quot;[\P{&quot;</span>
<span class="line-modified">4455         setExpr.append(u&quot;Block=&quot;, -1);</span>
<span class="line-modified">4456         setExpr.append(UnicodeString(mPropName, 2));  // Property with the leading &quot;In&quot; removed.</span>
<span class="line-modified">4457         setExpr.append(chRBrace);</span>
<span class="line-removed">4458         setExpr.append(chRBracket);</span>
<span class="line-removed">4459         *fStatus = U_ZERO_ERROR;</span>
<span class="line-removed">4460         set = new UnicodeSet(setExpr, usetFlags, NULL, *fStatus);</span>
<span class="line-removed">4461         if (U_SUCCESS(*fStatus)) {</span>
<span class="line-removed">4462             return set;</span>
4463         }
<span class="line-removed">4464         delete set;</span>
<span class="line-removed">4465         set = NULL;</span>
<span class="line-removed">4466     }</span>
4467 
<span class="line-modified">4468     if (propName.startsWith(UNICODE_STRING_SIMPLE(&quot;java&quot;)) ||</span>
<span class="line-modified">4469         propName.compare(UNICODE_STRING_SIMPLE(&quot;all&quot;)) == 0)</span>
<span class="line-removed">4470     {</span>
<span class="line-removed">4471         UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="line-removed">4472         //setExpr.remove();</span>
<span class="line-removed">4473         set = new UnicodeSet();</span>
<span class="line-removed">4474         //</span>
<span class="line-removed">4475         //  Try the various Java specific properties.</span>
<span class="line-removed">4476         //   These all begin with &quot;java&quot;</span>
4477         //
<span class="line-modified">4478         if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaDefined&quot;)) == 0) {</span>
<span class="line-modified">4479             addCategory(set, U_GC_CN_MASK, localStatus);</span>
<span class="line-modified">4480             set-&gt;complement();</span>
<span class="line-modified">4481         }</span>
<span class="line-modified">4482         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaDigit&quot;)) == 0) {</span>
<span class="line-modified">4483             addCategory(set, U_GC_ND_MASK, localStatus);</span>
<span class="line-modified">4484         }</span>
<span class="line-modified">4485         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaIdentifierIgnorable&quot;)) == 0) {</span>
<span class="line-modified">4486             addIdentifierIgnorable(set, localStatus);</span>
<span class="line-modified">4487         }</span>
<span class="line-removed">4488         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaISOControl&quot;)) == 0) {</span>
<span class="line-removed">4489             set-&gt;add(0, 0x1F).add(0x7F, 0x9F);</span>
<span class="line-removed">4490         }</span>
<span class="line-removed">4491         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaJavaIdentifierPart&quot;)) == 0) {</span>
<span class="line-removed">4492             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">4493             addCategory(set, U_GC_SC_MASK, localStatus);</span>
<span class="line-removed">4494             addCategory(set, U_GC_PC_MASK, localStatus);</span>
<span class="line-removed">4495             addCategory(set, U_GC_ND_MASK, localStatus);</span>
<span class="line-removed">4496             addCategory(set, U_GC_NL_MASK, localStatus);</span>
<span class="line-removed">4497             addCategory(set, U_GC_MC_MASK, localStatus);</span>
<span class="line-removed">4498             addCategory(set, U_GC_MN_MASK, localStatus);</span>
<span class="line-removed">4499             addIdentifierIgnorable(set, localStatus);</span>
<span class="line-removed">4500         }</span>
<span class="line-removed">4501         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaJavaIdentifierStart&quot;)) == 0) {</span>
<span class="line-removed">4502             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">4503             addCategory(set, U_GC_NL_MASK, localStatus);</span>
<span class="line-removed">4504             addCategory(set, U_GC_SC_MASK, localStatus);</span>
<span class="line-removed">4505             addCategory(set, U_GC_PC_MASK, localStatus);</span>
<span class="line-removed">4506         }</span>
<span class="line-removed">4507         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaLetter&quot;)) == 0) {</span>
<span class="line-removed">4508             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">4509         }</span>
<span class="line-removed">4510         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaLetterOrDigit&quot;)) == 0) {</span>
<span class="line-removed">4511             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">4512             addCategory(set, U_GC_ND_MASK, localStatus);</span>
<span class="line-removed">4513         }</span>
<span class="line-removed">4514         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaLowerCase&quot;)) == 0) {</span>
<span class="line-removed">4515             addCategory(set, U_GC_LL_MASK, localStatus);</span>
<span class="line-removed">4516         }</span>
<span class="line-removed">4517         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaMirrored&quot;)) == 0) {</span>
<span class="line-removed">4518             set-&gt;applyIntPropertyValue(UCHAR_BIDI_MIRRORED, 1, localStatus);</span>
<span class="line-removed">4519         }</span>
<span class="line-removed">4520         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaSpaceChar&quot;)) == 0) {</span>
<span class="line-removed">4521             addCategory(set, U_GC_Z_MASK, localStatus);</span>
<span class="line-removed">4522         }</span>
<span class="line-removed">4523         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaSupplementaryCodePoint&quot;)) == 0) {</span>
<span class="line-removed">4524             set-&gt;add(0x10000, UnicodeSet::MAX_VALUE);</span>
<span class="line-removed">4525         }</span>
<span class="line-removed">4526         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaTitleCase&quot;)) == 0) {</span>
<span class="line-removed">4527             addCategory(set, U_GC_LT_MASK, localStatus);</span>
<span class="line-removed">4528         }</span>
<span class="line-removed">4529         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaUnicodeIdentifierStart&quot;)) == 0) {</span>
<span class="line-removed">4530             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">4531             addCategory(set, U_GC_NL_MASK, localStatus);</span>
<span class="line-removed">4532         }</span>
<span class="line-removed">4533         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaUnicodeIdentifierPart&quot;)) == 0) {</span>
<span class="line-removed">4534             addCategory(set, U_GC_L_MASK, localStatus);</span>
<span class="line-removed">4535             addCategory(set, U_GC_PC_MASK, localStatus);</span>
<span class="line-removed">4536             addCategory(set, U_GC_ND_MASK, localStatus);</span>
<span class="line-removed">4537             addCategory(set, U_GC_NL_MASK, localStatus);</span>
<span class="line-removed">4538             addCategory(set, U_GC_MC_MASK, localStatus);</span>
<span class="line-removed">4539             addCategory(set, U_GC_MN_MASK, localStatus);</span>
<span class="line-removed">4540             addIdentifierIgnorable(set, localStatus);</span>
<span class="line-removed">4541         }</span>
<span class="line-removed">4542         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaUpperCase&quot;)) == 0) {</span>
<span class="line-removed">4543             addCategory(set, U_GC_LU_MASK, localStatus);</span>
<span class="line-removed">4544         }</span>
<span class="line-removed">4545         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaValidCodePoint&quot;)) == 0) {</span>
<span class="line-removed">4546             set-&gt;add(0, UnicodeSet::MAX_VALUE);</span>
<span class="line-removed">4547         }</span>
<span class="line-removed">4548         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;javaWhitespace&quot;)) == 0) {</span>
<span class="line-removed">4549             addCategory(set, U_GC_Z_MASK, localStatus);</span>
<span class="line-removed">4550             set-&gt;removeAll(UnicodeSet().add(0xa0).add(0x2007).add(0x202f));</span>
<span class="line-removed">4551             set-&gt;add(9, 0x0d).add(0x1c, 0x1f);</span>
<span class="line-removed">4552         }</span>
<span class="line-removed">4553         else if (mPropName.compare(UNICODE_STRING_SIMPLE(&quot;all&quot;)) == 0) {</span>
<span class="line-removed">4554             set-&gt;add(0, UnicodeSet::MAX_VALUE);</span>
4555         }
4556 
<span class="line-modified">4557         if (U_SUCCESS(localStatus) &amp;&amp; !set-&gt;isEmpty()) {</span>
<span class="line-modified">4558             *fStatus = U_ZERO_ERROR;</span>
<span class="line-modified">4559             if (usetFlags &amp; USET_CASE_INSENSITIVE) {</span>






















4560                 set-&gt;closeOver(USET_CASE_INSENSITIVE);
4561             }
<span class="line-modified">4562             if (negated) {</span>















4563                 set-&gt;complement();
4564             }
<span class="line-modified">4565             return set;</span>
























































































4566         }
<span class="line-modified">4567         delete set;</span>
<span class="line-modified">4568         set = NULL;</span>





4569     }
<span class="line-removed">4570     error(*fStatus);</span>
<span class="line-removed">4571     return NULL;</span>
4572 }
4573 
4574 
<span class="line-removed">4575 </span>
4576 //
4577 //  SetEval   Part of the evaluation of [set expressions].
4578 //            Perform any pending (stacked) operations with precedence
4579 //            equal or greater to that of the next operator encountered
4580 //            in the expression.
4581 //
4582 void RegexCompile::setEval(int32_t nextOp) {
4583     UnicodeSet *rightOperand = NULL;
4584     UnicodeSet *leftOperand  = NULL;
4585     for (;;) {
4586         U_ASSERT(fSetOpStack.empty()==FALSE);
4587         int32_t pendingSetOperation = fSetOpStack.peeki();
4588         if ((pendingSetOperation&amp;0xffff0000) &lt; (nextOp&amp;0xffff0000)) {
4589             break;
4590         }
4591         fSetOpStack.popi();
4592         U_ASSERT(fSetStack.empty() == FALSE);
4593         rightOperand = (UnicodeSet *)fSetStack.peek();
4594         switch (pendingSetOperation) {
4595             case setNegation:
</pre>
<hr />
<pre>
4604             case setDifference2:
4605                 fSetStack.pop();
4606                 leftOperand = (UnicodeSet *)fSetStack.peek();
4607                 leftOperand-&gt;removeAll(*rightOperand);
4608                 delete rightOperand;
4609                 break;
4610             case setIntersection1:
4611             case setIntersection2:
4612                 fSetStack.pop();
4613                 leftOperand = (UnicodeSet *)fSetStack.peek();
4614                 leftOperand-&gt;retainAll(*rightOperand);
4615                 delete rightOperand;
4616                 break;
4617             case setUnion:
4618                 fSetStack.pop();
4619                 leftOperand = (UnicodeSet *)fSetStack.peek();
4620                 leftOperand-&gt;addAll(*rightOperand);
4621                 delete rightOperand;
4622                 break;
4623             default:
<span class="line-modified">4624                 U_ASSERT(FALSE);</span>
<span class="line-removed">4625                 break;</span>
4626             }
4627         }
4628     }
4629 
4630 void RegexCompile::setPushOp(int32_t op) {
4631     setEval(op);
4632     fSetOpStack.push(op, *fStatus);
4633     fSetStack.push(new UnicodeSet(), *fStatus);
4634 }
4635 
4636 U_NAMESPACE_END
4637 #endif  // !UCONFIG_NO_REGULAR_EXPRESSIONS
4638 
</pre>
</td>
<td>
<hr />
<pre>
  11 //  is used by the match finding engine.
  12 //
  13 
  14 #include &quot;unicode/utypes.h&quot;
  15 
  16 #if !UCONFIG_NO_REGULAR_EXPRESSIONS
  17 
  18 #include &quot;unicode/ustring.h&quot;
  19 #include &quot;unicode/unistr.h&quot;
  20 #include &quot;unicode/uniset.h&quot;
  21 #include &quot;unicode/uchar.h&quot;
  22 #include &quot;unicode/uchriter.h&quot;
  23 #include &quot;unicode/parsepos.h&quot;
  24 #include &quot;unicode/parseerr.h&quot;
  25 #include &quot;unicode/regex.h&quot;
  26 #include &quot;unicode/utf.h&quot;
  27 #include &quot;unicode/utf16.h&quot;
  28 #include &quot;patternprops.h&quot;
  29 #include &quot;putilimp.h&quot;
  30 #include &quot;cmemory.h&quot;
<span class="line-added">  31 #include &quot;cstr.h&quot;</span>
  32 #include &quot;cstring.h&quot;
  33 #include &quot;uvectr32.h&quot;
  34 #include &quot;uvectr64.h&quot;
  35 #include &quot;uassert.h&quot;
  36 #include &quot;uinvchar.h&quot;
  37 
  38 #include &quot;regeximp.h&quot;
  39 #include &quot;regexcst.h&quot;   // Contains state table for the regex pattern parser.
  40                         //   generated by a Perl script.
  41 #include &quot;regexcmp.h&quot;
  42 #include &quot;regexst.h&quot;
  43 #include &quot;regextxt.h&quot;
  44 
  45 
  46 
  47 U_NAMESPACE_BEGIN
  48 
  49 
  50 //------------------------------------------------------------------------------
  51 //
</pre>
<hr />
<pre>
1448 
1449 
1450     case doBeginMatchMode:
1451         fNewModeFlags = fModeFlags;
1452         fSetModeFlag  = TRUE;
1453         break;
1454 
1455     case doMatchMode:   //  (?i)    and similar
1456         {
1457             int32_t  bit = 0;
1458             switch (fC.fChar) {
1459             case 0x69: /* &#39;i&#39; */   bit = UREGEX_CASE_INSENSITIVE; break;
1460             case 0x64: /* &#39;d&#39; */   bit = UREGEX_UNIX_LINES;       break;
1461             case 0x6d: /* &#39;m&#39; */   bit = UREGEX_MULTILINE;        break;
1462             case 0x73: /* &#39;s&#39; */   bit = UREGEX_DOTALL;           break;
1463             case 0x75: /* &#39;u&#39; */   bit = 0; /* Unicode casing */  break;
1464             case 0x77: /* &#39;w&#39; */   bit = UREGEX_UWORD;            break;
1465             case 0x78: /* &#39;x&#39; */   bit = UREGEX_COMMENTS;         break;
1466             case 0x2d: /* &#39;-&#39; */   fSetModeFlag = FALSE;          break;
1467             default:
<span class="line-modified">1468                 UPRV_UNREACHABLE;   // Should never happen.  Other chars are filtered out</span>
1469                                    // by the scanner.
1470             }
1471             if (fSetModeFlag) {
1472                 fNewModeFlags |= bit;
1473             } else {
1474                 fNewModeFlags &amp;= ~bit;
1475             }
1476         }
1477         break;
1478 
1479     case doSetMatchMode:
1480         // Emit code to match any pending literals, using the not-yet changed match mode.
1481         fixLiterals();
1482 
1483         // We&#39;ve got a (?i) or similar.  The match mode is being changed, but
1484         //   the change is not scoped to a parenthesized block.
1485         U_ASSERT(fNewModeFlags &lt; 0);
1486         fModeFlags = fNewModeFlags;
1487 
1488         break;
</pre>
<hr />
<pre>
1823         break;
1824 
1825 
1826     case doSetRange:
1827         // We have scanned literal-literal.  Add the range to the set.
1828         // The left character is already in the set, and is saved in fLastSetLiteral.
1829         // The right side is the current character.
1830         // Lower Limit &gt; Upper limit being an error matches both Java
1831         //        and ICU UnicodeSet behavior.
1832         {
1833 
1834         if (fLastSetLiteral == U_SENTINEL || fLastSetLiteral &gt; fC.fChar) {
1835             error(U_REGEX_INVALID_RANGE);
1836         }
1837         UnicodeSet *s = (UnicodeSet *)fSetStack.peek();
1838         s-&gt;add(fLastSetLiteral, fC.fChar);
1839         break;
1840         }
1841 
1842     default:
<span class="line-modified">1843         UPRV_UNREACHABLE;</span>


1844     }
1845 
1846     if (U_FAILURE(*fStatus)) {
1847         returnVal = FALSE;
1848     }
1849 
1850     return returnVal;
1851 }
1852 
1853 
1854 
1855 //------------------------------------------------------------------------------
1856 //
1857 //   literalChar           We&#39;ve encountered a literal character from the pattern,
1858 //                             or an escape sequence that reduces to a character.
1859 //                         Add it to the string containing all literal chars/strings from
1860 //                             the pattern.
1861 //
1862 //------------------------------------------------------------------------------
1863 void RegexCompile::literalChar(UChar32 c)  {
</pre>
<hr />
<pre>
1930         } else {
1931             // TODO here:  add optimization to split case sensitive strings of length two
1932             //             into two single char ops, for efficiency.
1933             appendOp(URX_STRING, fRXPat-&gt;fLiteralText.length());
1934         }
1935         appendOp(URX_STRING_LEN, fLiteralChars.length());
1936 
1937         // Add this string into the accumulated strings of the compiled pattern.
1938         fRXPat-&gt;fLiteralText.append(fLiteralChars);
1939     }
1940 
1941     fLiteralChars.remove();
1942 }
1943 
1944 
1945 int32_t RegexCompile::buildOp(int32_t type, int32_t val) {
1946     if (U_FAILURE(*fStatus)) {
1947         return 0;
1948     }
1949     if (type &lt; 0 || type &gt; 255) {
<span class="line-modified">1950         UPRV_UNREACHABLE;</span>


1951     }
1952     if (val &gt; 0x00ffffff) {
<span class="line-modified">1953         UPRV_UNREACHABLE;</span>


1954     }
1955     if (val &lt; 0) {
1956         if (!(type == URX_RESERVED_OP_N || type == URX_RESERVED_OP)) {
<span class="line-modified">1957             UPRV_UNREACHABLE;</span>


1958         }
1959         if (URX_TYPE(val) != 0xff) {
<span class="line-modified">1960             UPRV_UNREACHABLE;</span>


1961         }
1962         type = URX_RESERVED_OP_N;
1963     }
1964     return (type &lt;&lt; 24) | val;
1965 }
1966 
1967 
1968 //------------------------------------------------------------------------------
1969 //
1970 //   appendOp()             Append a new instruction onto the compiled pattern
1971 //                          Includes error checking, limiting the size of the
1972 //                          pattern to lengths that can be represented in the
1973 //                          24 bit operand field of an instruction.
1974 //
1975 //------------------------------------------------------------------------------
1976 void RegexCompile::appendOp(int32_t op) {
1977     if (U_FAILURE(*fStatus)) {
1978         return;
1979     }
1980     fRXPat-&gt;fCompiledPat-&gt;addElement(op, *fStatus);
</pre>
<hr />
<pre>
2268             int32_t  startOp = (int32_t)fRXPat-&gt;fCompiledPat-&gt;elementAti(fMatchOpenParen-4);
2269             U_ASSERT(URX_TYPE(startOp) == URX_LB_START);
2270             int32_t dataLoc  = URX_VAL(startOp);
2271             appendOp(URX_LB_END, dataLoc);
2272             appendOp(URX_LA_END, dataLoc);
2273 
2274             // Determine the min and max bounds for the length of the
2275             //  string that the pattern can match.
2276             //  An unbounded upper limit is an error.
2277             int32_t patEnd   = fRXPat-&gt;fCompiledPat-&gt;size() - 1;
2278             int32_t minML    = minMatchLength(fMatchOpenParen, patEnd);
2279             int32_t maxML    = maxMatchLength(fMatchOpenParen, patEnd);
2280             if (URX_TYPE(maxML) != 0) {
2281                 error(U_REGEX_LOOK_BEHIND_LIMIT);
2282                 break;
2283             }
2284             if (maxML == INT32_MAX) {
2285                 error(U_REGEX_LOOK_BEHIND_LIMIT);
2286                 break;
2287             }
<span class="line-added">2288             if (minML == INT32_MAX &amp;&amp; maxML == 0) {</span>
<span class="line-added">2289                 // This condition happens when no match is possible, such as with a</span>
<span class="line-added">2290                 // [set] expression containing no elements.</span>
<span class="line-added">2291                 // In principle, the generated code to evaluate the expression could be deleted,</span>
<span class="line-added">2292                 // but it&#39;s probably not worth the complication.</span>
<span class="line-added">2293                 minML = 0;</span>
<span class="line-added">2294             }</span>
2295             U_ASSERT(minML &lt;= maxML);
2296 
2297             // Insert the min and max match len bounds into the URX_LB_CONT op that
2298             //  appears at the top of the look-behind block, at location fMatchOpenParen+1
2299             fRXPat-&gt;fCompiledPat-&gt;setElementAt(minML,  fMatchOpenParen-2);
2300             fRXPat-&gt;fCompiledPat-&gt;setElementAt(maxML,  fMatchOpenParen-1);
2301 
2302         }
2303         break;
2304 
2305 
2306 
2307     case lookBehindN:
2308         {
2309             // See comment at doOpenLookBehindNeg.
2310 
2311             // Append the URX_LBN_END to the compiled pattern.
2312             int32_t  startOp = (int32_t)fRXPat-&gt;fCompiledPat-&gt;elementAti(fMatchOpenParen-5);
2313             U_ASSERT(URX_TYPE(startOp) == URX_LB_START);
2314             int32_t dataLoc  = URX_VAL(startOp);
2315             appendOp(URX_LBN_END, dataLoc);
2316 
2317             // Determine the min and max bounds for the length of the
2318             //  string that the pattern can match.
2319             //  An unbounded upper limit is an error.
2320             int32_t patEnd   = fRXPat-&gt;fCompiledPat-&gt;size() - 1;
2321             int32_t minML    = minMatchLength(fMatchOpenParen, patEnd);
2322             int32_t maxML    = maxMatchLength(fMatchOpenParen, patEnd);
2323             if (URX_TYPE(maxML) != 0) {
2324                 error(U_REGEX_LOOK_BEHIND_LIMIT);
2325                 break;
2326             }
2327             if (maxML == INT32_MAX) {
2328                 error(U_REGEX_LOOK_BEHIND_LIMIT);
2329                 break;
2330             }
<span class="line-added">2331             if (minML == INT32_MAX &amp;&amp; maxML == 0) {</span>
<span class="line-added">2332                 // This condition happens when no match is possible, such as with a</span>
<span class="line-added">2333                 // [set] expression containing no elements.</span>
<span class="line-added">2334                 // In principle, the generated code to evaluate the expression could be deleted,</span>
<span class="line-added">2335                 // but it&#39;s probably not worth the complication.</span>
<span class="line-added">2336                 minML = 0;</span>
<span class="line-added">2337             }</span>
<span class="line-added">2338 </span>
2339             U_ASSERT(minML &lt;= maxML);
2340 
2341             // Insert the min and max match len bounds into the URX_LB_CONT op that
2342             //  appears at the top of the look-behind block, at location fMatchOpenParen+1
2343             fRXPat-&gt;fCompiledPat-&gt;setElementAt(minML,  fMatchOpenParen-3);
2344             fRXPat-&gt;fCompiledPat-&gt;setElementAt(maxML,  fMatchOpenParen-2);
2345 
2346             // Insert the pattern location to continue at after a successful match
2347             //  as the last operand of the URX_LBN_CONT
2348             int32_t op = buildOp(URX_RELOC_OPRND, fRXPat-&gt;fCompiledPat-&gt;size());
2349             fRXPat-&gt;fCompiledPat-&gt;setElementAt(op,  fMatchOpenParen-1);
2350         }
2351         break;
2352 
2353 
2354 
2355     default:
<span class="line-modified">2356         UPRV_UNREACHABLE;</span>
2357     }
2358 
2359     // remember the next location in the compiled pattern.
2360     // The compilation of Quantifiers will look at this to see whether its looping
2361     //   over a parenthesized block or a single item
2362     fMatchCloseParen = fRXPat-&gt;fCompiledPat-&gt;size();
2363 }
2364 
2365 
2366 
2367 //------------------------------------------------------------------------------
2368 //
2369 //   compileSet       Compile the pattern operations for a reference to a
2370 //                    UnicodeSet.
2371 //
2372 //------------------------------------------------------------------------------
2373 void        RegexCompile::compileSet(UnicodeSet *theSet)
2374 {
2375     if (theSet == NULL) {
2376         return;
</pre>
<hr />
<pre>
2596         0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
2597         0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x1, 0x1, 0x1, 0};
2598 
2599     static const UChar RECaseFixData[] = {
2600         0x1e9a, 0xfb00, 0xfb01, 0xfb02, 0xfb03, 0xfb04, 0x1e96, 0x130, 0x1f0, 0xdf,
2601         0x1e9e, 0xfb05, 0xfb06, 0x1e97, 0x1e98, 0x1e99, 0x149, 0x1fb4, 0x1fc4, 0x1fb3,
2602         0x1fb6, 0x1fb7, 0x1fbc, 0x1fc3, 0x1fc6, 0x1fc7, 0x1fcc, 0x390, 0x1fd2, 0x1fd3,
2603         0x1fd6, 0x1fd7, 0x1fe4, 0x3b0, 0x1f50, 0x1f52, 0x1f54, 0x1f56, 0x1fe2, 0x1fe3,
2604         0x1fe6, 0x1fe7, 0x1ff3, 0x1ff6, 0x1ff7, 0x1ffc, 0x1ff4, 0x587, 0xfb13, 0xfb14,
2605         0xfb15, 0xfb17, 0xfb16, 0x1f80, 0x1f88, 0x1f81, 0x1f89, 0x1f82, 0x1f8a, 0x1f83,
2606         0x1f8b, 0x1f84, 0x1f8c, 0x1f85, 0x1f8d, 0x1f86, 0x1f8e, 0x1f87, 0x1f8f, 0x1f90,
2607         0x1f98, 0x1f91, 0x1f99, 0x1f92, 0x1f9a, 0x1f93, 0x1f9b, 0x1f94, 0x1f9c, 0x1f95,
2608         0x1f9d, 0x1f96, 0x1f9e, 0x1f97, 0x1f9f, 0x1fa0, 0x1fa8, 0x1fa1, 0x1fa9, 0x1fa2,
2609         0x1faa, 0x1fa3, 0x1fab, 0x1fa4, 0x1fac, 0x1fa5, 0x1fad, 0x1fa6, 0x1fae, 0x1fa7,
2610         0x1faf, 0x1fb2, 0x1fc2, 0x1ff2, 0};
2611 
2612 // End of machine generated data.
2613 
2614     if (c &lt; UCHAR_MIN_VALUE || c &gt; UCHAR_MAX_VALUE) {
2615         // This function should never be called with an invalid input character.
<span class="line-modified">2616         UPRV_UNREACHABLE;</span>

2617     } else if (u_hasBinaryProperty(c, UCHAR_CASE_SENSITIVE)) {
2618         UChar32 caseFoldedC  = u_foldCase(c, U_FOLD_CASE_DEFAULT);
2619         starterChars-&gt;set(caseFoldedC, caseFoldedC);
2620 
2621         int32_t i;
2622         for (i=0; RECaseFixCodePoints[i]&lt;c ; i++) {
2623             // Simple linear search through the sorted list of interesting code points.
2624         }
2625 
2626         if (RECaseFixCodePoints[i] == c) {
2627             int32_t dataIndex = RECaseFixStringOffsets[i];
2628             int32_t numCharsToAdd = RECaseFixCounts[i];
2629             UChar32 cpToAdd = 0;
2630             for (int32_t j=0; j&lt;numCharsToAdd; j++) {
2631                 U16_NEXT_UNSAFE(RECaseFixData, dataIndex, cpToAdd);
2632                 starterChars-&gt;add(cpToAdd);
2633             }
2634         }
2635 
2636         starterChars-&gt;closeOver(USET_CASE_INSENSITIVE);
</pre>
<hr />
<pre>
3090                     if (URX_TYPE(op) == URX_STATE_SAVE) {
3091                         // Need this because neg lookahead blocks will FAIL to outside
3092                         //   of the block.
3093                         int32_t  jmpDest = URX_VAL(op);
3094                         if (jmpDest &gt; loc) {
3095                             if (currentLen &lt; forwardedLength.elementAti(jmpDest)) {
3096                                 forwardedLength.setElementAt(currentLen, jmpDest);
3097                             }
3098                         }
3099                     }
3100                     U_ASSERT(loc &lt;= end);
3101                 }
3102             }
3103             break;
3104 
3105         case URX_LA_END:
3106         case URX_LB_CONT:
3107         case URX_LB_END:
3108         case URX_LBN_CONT:
3109         case URX_LBN_END:
<span class="line-modified">3110             UPRV_UNREACHABLE;     // Shouldn&#39;t get here.  These ops should be</span>
3111                                  //  consumed by the scan in URX_LA_START and LB_START



3112         default:
<span class="line-modified">3113             UPRV_UNREACHABLE;</span>
3114             }
3115 
3116         }
3117 
3118 
3119     // We have finished walking through the ops.  Check whether some forward jump
3120     //   propagated a shorter length to location end+1.
3121     if (forwardedLength.elementAti(end+1) &lt; currentLen) {
3122         currentLen = forwardedLength.elementAti(end+1);
3123     }
3124 
3125 
3126     fRXPat-&gt;fInitialChars8-&gt;init(fRXPat-&gt;fInitialChars);
3127 
3128 
3129     // Sort out what we should check for when looking for candidate match start positions.
3130     // In order of preference,
3131     //     1.   Start of input text buffer.
3132     //     2.   A literal string.
3133     //     3.   Start of line in multi-line mode.
</pre>
<hr />
<pre>
3413                             if (currentLen &lt; forwardedLength.elementAti(jmpDest)) {
3414                                 forwardedLength.setElementAt(currentLen, jmpDest);
3415                             }
3416                         }
3417                     }
3418                     U_ASSERT(loc &lt;= end);
3419                 }
3420             }
3421             break;
3422 
3423         case URX_LA_END:
3424         case URX_LB_CONT:
3425         case URX_LB_END:
3426         case URX_LBN_CONT:
3427         case URX_LBN_END:
3428             // Only come here if the matching URX_LA_START or URX_LB_START was not in the
3429             //   range being sized, which happens when measuring size of look-behind blocks.
3430             break;
3431 
3432         default:
<span class="line-modified">3433             UPRV_UNREACHABLE;</span>
3434             }
3435 
3436         }
3437 
3438     // We have finished walking through the ops.  Check whether some forward jump
3439     //   propagated a shorter length to location end+1.
3440     if (forwardedLength.elementAti(end+1) &lt; currentLen) {
3441         currentLen = forwardedLength.elementAti(end+1);
3442         U_ASSERT(currentLen&gt;=0 &amp;&amp; currentLen &lt; INT32_MAX);
3443     }
3444 
3445     return currentLen;
3446 }
3447 
3448 //------------------------------------------------------------------------------
3449 //
3450 //   maxMatchLength    Calculate the length of the longest string that could
3451 //                     match the specified pattern.
3452 //                     Length is in 16 bit code units, not code points.
3453 //
</pre>
<hr />
<pre>
3657                     currentLen = INT32_MAX;
3658                     break;
3659                 }
3660 
3661                 U_ASSERT(loopEndLoc &gt;= loc+4);
3662                 int64_t blockLen = maxMatchLength(loc+4, loopEndLoc-1);  // Recursive call.
3663                 int64_t updatedLen = (int64_t)currentLen + blockLen * maxLoopCount;
3664                 if (updatedLen &gt;= INT32_MAX) {
3665                     currentLen = INT32_MAX;
3666                     break;
3667                 }
3668                 currentLen = (int32_t)updatedLen;
3669                 loc = loopEndLoc;
3670                 break;
3671             }
3672 
3673         case URX_CTR_LOOP:
3674         case URX_CTR_LOOP_NG:
3675             // These opcodes will be skipped over by code for URX_CRT_INIT.
3676             // We shouldn&#39;t encounter them here.
<span class="line-modified">3677             UPRV_UNREACHABLE;</span>

3678 
3679         case URX_LOOP_SR_I:
3680         case URX_LOOP_DOT_I:
3681         case URX_LOOP_C:
3682             // For anything to do with loops, make the match length unbounded.
3683             currentLen = INT32_MAX;
3684             break;
3685 
3686 
3687 
3688         case URX_LA_START:
3689         case URX_LA_END:
3690             // Look-ahead.  Just ignore, treat the look-ahead block as if
3691             // it were normal pattern.  Gives a too-long match length,
3692             //  but good enough for now.
3693             break;
3694 
3695             // End of look-ahead ops should always be consumed by the processing at
3696             //  the URX_LA_START op.
<span class="line-modified">3697             // UPRV_UNREACHABLE;</span>

3698 
3699         case URX_LB_START:
3700             {
3701                 // Look-behind.  Scan forward until the matching look-around end,
3702                 //   without processing the look-behind block.
3703                 int32_t  depth = 0;
3704                 for (;;) {
3705                     loc++;
3706                     op = (int32_t)fRXPat-&gt;fCompiledPat-&gt;elementAti(loc);
3707                     if (URX_TYPE(op) == URX_LA_START || URX_TYPE(op) == URX_LB_START) {
3708                         depth++;
3709                     }
3710                     if (URX_TYPE(op) == URX_LA_END || URX_TYPE(op)==URX_LBN_END) {
3711                         if (depth == 0) {
3712                             break;
3713                         }
3714                         depth--;
3715                     }
3716                     U_ASSERT(loc &lt; end);
3717                 }
3718             }
3719             break;
3720 
3721         default:
<span class="line-modified">3722             UPRV_UNREACHABLE;</span>
3723         }
3724 
3725 
3726         if (currentLen == INT32_MAX) {
3727             //  The maximum length is unbounded.
3728             //  Stop further processing of the pattern.
3729             break;
3730         }
3731 
3732     }
3733     return currentLen;
3734 
3735 }
3736 
3737 
3738 //------------------------------------------------------------------------------
3739 //
3740 //   stripNOPs    Remove any NOP operations from the compiled pattern code.
3741 //                Extra NOPs are inserted for some constructs during the initial
3742 //                code generation to provide locations that may be patched later.
</pre>
<hr />
<pre>
3857         case URX_LB_START:
3858         case URX_LB_CONT:
3859         case URX_LB_END:
3860         case URX_LBN_CONT:
3861         case URX_LBN_END:
3862         case URX_LOOP_SR_I:
3863         case URX_LOOP_DOT_I:
3864         case URX_LOOP_C:
3865         case URX_DOLLAR_D:
3866         case URX_DOLLAR_MD:
3867         case URX_BACKSLASH_H:
3868         case URX_BACKSLASH_R:
3869         case URX_BACKSLASH_V:
3870             // These instructions are unaltered by the relocation.
3871             fRXPat-&gt;fCompiledPat-&gt;setElementAt(op, dst);
3872             dst++;
3873             break;
3874 
3875         default:
3876             // Some op is unaccounted for.
<span class="line-modified">3877             UPRV_UNREACHABLE;</span>

3878         }
3879     }
3880 
3881     fRXPat-&gt;fCompiledPat-&gt;setSize(dst);
3882 }
3883 
3884 
3885 
3886 
3887 //------------------------------------------------------------------------------
3888 //
3889 //  Error         Report a rule parse error.
3890 //                Only report it if no previous error has been recorded.
3891 //
3892 //------------------------------------------------------------------------------
3893 void RegexCompile::error(UErrorCode e) {
<span class="line-modified">3894     if (U_SUCCESS(*fStatus) || e == U_MEMORY_ALLOCATION_ERROR) {</span>
3895         *fStatus = e;
3896         // Hmm. fParseErr (UParseError) line &amp; offset fields are int32_t in public
3897         // API (see common/unicode/parseerr.h), while fLineNum and fCharNum are
3898         // int64_t. If the values of the latter are out of range for the former,
3899         // set them to the appropriate &quot;field not supported&quot; values.
3900         if (fLineNum &gt; 0x7FFFFFFF) {
3901             fParseErr-&gt;line   = 0;
3902             fParseErr-&gt;offset = -1;
3903         } else if (fCharNum &gt; 0x7FFFFFFF) {
3904             fParseErr-&gt;line   = (int32_t)fLineNum;
3905             fParseErr-&gt;offset = -1;
3906         } else {
3907             fParseErr-&gt;line   = (int32_t)fLineNum;
3908             fParseErr-&gt;offset = (int32_t)fCharNum;
3909         }
3910 
3911         UErrorCode status = U_ZERO_ERROR; // throwaway status for extracting context
3912 
3913         // Fill in the context.
3914         //   Note: extractBetween() pins supplied indicies to the string bounds.
</pre>
<hr />
<pre>
3993 //   peekCharLL    Low Level Character Scanning, sneak a peek at the next
3994 //                 character without actually getting it.
3995 //
3996 //------------------------------------------------------------------------------
3997 UChar32  RegexCompile::peekCharLL() {
3998     if (fPeekChar == -1) {
3999         fPeekChar = nextCharLL();
4000     }
4001     return fPeekChar;
4002 }
4003 
4004 
4005 //------------------------------------------------------------------------------
4006 //
4007 //   nextChar     for pattern scanning.  At this level, we handle stripping
4008 //                out comments and processing some backslash character escapes.
4009 //                The rest of the pattern grammar is handled at the next level up.
4010 //
4011 //------------------------------------------------------------------------------
4012 void RegexCompile::nextChar(RegexPatternChar &amp;c) {
<span class="line-modified">4013   tailRecursion:</span>
4014     fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat-&gt;fPattern);
4015     c.fChar    = nextCharLL();
4016     c.fQuoted  = FALSE;
4017 
4018     if (fQuoteMode) {
4019         c.fQuoted = TRUE;
4020         if ((c.fChar==chBackSlash &amp;&amp; peekCharLL()==chE &amp;&amp; ((fModeFlags &amp; UREGEX_LITERAL) == 0)) ||
4021             c.fChar == (UChar32)-1) {
4022             fQuoteMode = FALSE;  //  Exit quote mode,
4023             nextCharLL();        // discard the E
<span class="line-modified">4024             // nextChar(c);      // recurse to get the real next char</span>
<span class="line-added">4025             goto tailRecursion;  // Note: fuzz testing produced testcases that</span>
<span class="line-added">4026                                  //       resulted in stack overflow here.</span>
4027         }
4028     }
4029     else if (fInBackslashQuote) {
4030         // The current character immediately follows a &#39;\&#39;
4031         // Don&#39;t check for any further escapes, just return it as-is.
4032         // Don&#39;t set c.fQuoted, because that would prevent the state machine from
4033         //    dispatching on the character.
4034         fInBackslashQuote = FALSE;
4035     }
4036     else
4037     {
4038         // We are not in a \Q quoted region \E of the source.
4039         //
4040         if (fModeFlags &amp; UREGEX_COMMENTS) {
4041             //
4042             // We are in free-spacing and comments mode.
4043             //  Scan through any white space and comments, until we
4044             //  reach a significant character or the end of inut.
4045             for (;;) {
4046                 if (c.fChar == (UChar32)-1) {
</pre>
<hr />
<pre>
4124                         if (index==0) {
4125                            // \0 is not followed by any octal digits.
4126                            error(U_REGEX_BAD_ESCAPE_SEQUENCE);
4127                         }
4128                         break;
4129                     }
4130                     c.fChar &lt;&lt;= 3;
4131                     c.fChar += ch&amp;7;
4132                     if (c.fChar &lt;= 255) {
4133                         nextCharLL();
4134                     } else {
4135                         // The last digit made the number too big.  Forget we saw it.
4136                         c.fChar &gt;&gt;= 3;
4137                     }
4138                 }
4139                 c.fQuoted = TRUE;
4140             }
4141             else if (peekCharLL() == chQ) {
4142                 //  &quot;\Q&quot;  enter quote mode, which will continue until &quot;\E&quot;
4143                 fQuoteMode = TRUE;
<span class="line-modified">4144                 nextCharLL();        // discard the &#39;Q&#39;.</span>
<span class="line-modified">4145                 // nextChar(c);      // recurse to get the real next char.</span>
<span class="line-added">4146                 goto tailRecursion;  // Note: fuzz testing produced test cases that</span>
<span class="line-added">4147                 //                            resulted in stack overflow here.</span>
4148             }
4149             else
4150             {
4151                 // We are in a &#39;\&#39; escape that will be handled by the state table scanner.
4152                 // Just return the backslash, but remember that the following char is to
4153                 //  be taken literally.
4154                 fInBackslashQuote = TRUE;
4155             }
4156         }
4157     }
4158 
4159     // re-enable # to end-of-line comments, in case they were disabled.
4160     // They are disabled by the parser upon seeing &#39;(?&#39;, but this lasts for
4161     //  the fetching of the next character only.
4162     fEOLComments = TRUE;
4163 
4164     // putc(c.fChar, stdout);
4165 }
4166 
4167 
</pre>
<hr />
<pre>
4356         fCharNum          = savedCharNum;
4357         fLastChar         = savedLastChar;
4358         fPeekChar         = savedPeekChar;
4359         fC                = savedfC;
4360         UTEXT_SETNATIVEINDEX(fRXPat-&gt;fPattern, savedNextIndex);
4361     }
4362     return uset;
4363 }
4364 
4365 static inline void addIdentifierIgnorable(UnicodeSet *set, UErrorCode&amp; ec) {
4366     set-&gt;add(0, 8).add(0x0e, 0x1b).add(0x7f, 0x9f);
4367     addCategory(set, U_GC_CF_MASK, ec);
4368 }
4369 
4370 //
4371 //  Create a Unicode Set from a Unicode Property expression.
4372 //     This is common code underlying both \p{...} ane [:...:] expressions.
4373 //     Includes trying the Java &quot;properties&quot; that aren&#39;t supported as
4374 //     normal ICU UnicodeSet properties
4375 //


4376 UnicodeSet *RegexCompile::createSetForProperty(const UnicodeString &amp;propName, UBool negated) {



4377 
4378     if (U_FAILURE(*fStatus)) {
<span class="line-modified">4379         return nullptr;</span>
4380     }
<span class="line-added">4381     LocalPointer&lt;UnicodeSet&gt; set;</span>
<span class="line-added">4382     UErrorCode status = U_ZERO_ERROR;</span>
4383 
<span class="line-modified">4384     do {      // non-loop, exists to allow breaks from the block.</span>
<span class="line-modified">4385         //</span>
<span class="line-modified">4386         //  First try the property as we received it</span>
<span class="line-modified">4387         //</span>
<span class="line-modified">4388         UnicodeString   setExpr;</span>
<span class="line-modified">4389         uint32_t        usetFlags = 0;</span>
<span class="line-modified">4390         setExpr.append(u&quot;[\\p{&quot;, -1);</span>
<span class="line-modified">4391         setExpr.append(propName);</span>
<span class="line-modified">4392         setExpr.append(u&quot;}]&quot;, -1);</span>
<span class="line-modified">4393         if (fModeFlags &amp; UREGEX_CASE_INSENSITIVE) {</span>
<span class="line-modified">4394             usetFlags |= USET_CASE_INSENSITIVE;</span>






















4395         }
<span class="line-modified">4396         set.adoptInsteadAndCheckErrorCode(new UnicodeSet(setExpr, usetFlags, NULL, status), status);</span>
<span class="line-modified">4397         if (U_SUCCESS(status) || status == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">4398             break;</span>
4399         }


4400 
<span class="line-added">4401         //</span>
<span class="line-added">4402         //  The incoming property wasn&#39;t directly recognized by ICU.</span>
4403 
<span class="line-modified">4404         //  Check [:word:] and [:all:]. These are not recognized as a properties by ICU UnicodeSet.</span>
<span class="line-modified">4405         //     Java accepts &#39;word&#39; with mixed case.</span>
<span class="line-modified">4406         //     Java accepts &#39;all&#39; only in all lower case.</span>





















4407 
<span class="line-modified">4408         status = U_ZERO_ERROR;</span>
<span class="line-modified">4409         if (propName.caseCompare(u&quot;word&quot;, -1, 0) == 0) {</span>
<span class="line-modified">4410             set.adoptInsteadAndCheckErrorCode(new UnicodeSet(*(fRXPat-&gt;fStaticSets[URX_ISWORD_SET])), status);</span>
<span class="line-modified">4411             break;</span>
<span class="line-modified">4412         }</span>
<span class="line-modified">4413         if (propName.compare(u&quot;all&quot;, -1) == 0) {</span>
<span class="line-modified">4414             set.adoptInsteadAndCheckErrorCode(new UnicodeSet(0, 0x10ffff), status);</span>
<span class="line-modified">4415             break;</span>





4416         }



4417 
<span class="line-modified">4418 </span>
<span class="line-modified">4419         //    Do Java InBlock expressions</span>







4420         //
<span class="line-modified">4421         UnicodeString mPropName = propName;</span>
<span class="line-modified">4422         if (mPropName.startsWith(u&quot;In&quot;, 2) &amp;&amp; mPropName.length() &gt;= 3) {</span>
<span class="line-modified">4423             status = U_ZERO_ERROR;</span>
<span class="line-modified">4424             set.adoptInsteadAndCheckErrorCode(new UnicodeSet(), status);</span>
<span class="line-modified">4425             if (U_FAILURE(status)) {</span>
<span class="line-modified">4426                 break;</span>
<span class="line-modified">4427             }</span>
<span class="line-modified">4428             UnicodeString blockName(mPropName, 2);  // Property with the leading &quot;In&quot; removed.</span>
<span class="line-modified">4429             set-&gt;applyPropertyAlias(UnicodeString(u&quot;Block&quot;), blockName, status);</span>
<span class="line-modified">4430             break;</span>



































































4431         }
4432 
<span class="line-modified">4433         //  Check for the Java form &quot;IsBooleanPropertyValue&quot;, which we will recast</span>
<span class="line-modified">4434         //  as &quot;BooleanPropertyValue&quot;. The property value can be either a</span>
<span class="line-modified">4435         //  a General Category or a Script Name.</span>
<span class="line-added">4436 </span>
<span class="line-added">4437         if (propName.startsWith(u&quot;Is&quot;, 2) &amp;&amp; propName.length()&gt;=3) {</span>
<span class="line-added">4438             mPropName.remove(0, 2);      // Strip the &quot;Is&quot;</span>
<span class="line-added">4439             if (mPropName.indexOf(u&#39;=&#39;) &gt;= 0) {</span>
<span class="line-added">4440                 // Reject any &quot;Is...&quot; property expression containing an &#39;=&#39;, that is,</span>
<span class="line-added">4441                 // any non-binary property expression.</span>
<span class="line-added">4442                 status = U_REGEX_PROPERTY_SYNTAX;</span>
<span class="line-added">4443                 break;</span>
<span class="line-added">4444             }</span>
<span class="line-added">4445 </span>
<span class="line-added">4446             if (mPropName.caseCompare(u&quot;assigned&quot;, -1, 0) == 0) {</span>
<span class="line-added">4447                 mPropName.setTo(u&quot;unassigned&quot;, -1);</span>
<span class="line-added">4448                 negated = !negated;</span>
<span class="line-added">4449             } else if (mPropName.caseCompare(u&quot;TitleCase&quot;, -1, 0) == 0) {</span>
<span class="line-added">4450                 mPropName.setTo(u&quot;Titlecase_Letter&quot;, -1);</span>
<span class="line-added">4451             }</span>
<span class="line-added">4452 </span>
<span class="line-added">4453             mPropName.insert(0, u&quot;[\\p{&quot;, -1);</span>
<span class="line-added">4454             mPropName.append(u&quot;}]&quot;, -1);</span>
<span class="line-added">4455             set.adoptInsteadAndCheckErrorCode(new UnicodeSet(mPropName, *fStatus), status);</span>
<span class="line-added">4456 </span>
<span class="line-added">4457             if (U_SUCCESS(status) &amp;&amp; !set-&gt;isEmpty() &amp;&amp; (usetFlags &amp; USET_CASE_INSENSITIVE)) {</span>
4458                 set-&gt;closeOver(USET_CASE_INSENSITIVE);
4459             }
<span class="line-modified">4460             break;</span>
<span class="line-added">4461 </span>
<span class="line-added">4462         }</span>
<span class="line-added">4463 </span>
<span class="line-added">4464         if (propName.startsWith(u&quot;java&quot;, -1)) {</span>
<span class="line-added">4465             status = U_ZERO_ERROR;</span>
<span class="line-added">4466             set.adoptInsteadAndCheckErrorCode(new UnicodeSet(), status);</span>
<span class="line-added">4467             if (U_FAILURE(status)) {</span>
<span class="line-added">4468                 break;</span>
<span class="line-added">4469             }</span>
<span class="line-added">4470             //</span>
<span class="line-added">4471             //  Try the various Java specific properties.</span>
<span class="line-added">4472             //   These all begin with &quot;java&quot;</span>
<span class="line-added">4473             //</span>
<span class="line-added">4474             if (propName.compare(u&quot;javaDefined&quot;, -1) == 0) {</span>
<span class="line-added">4475                 addCategory(set.getAlias(), U_GC_CN_MASK, status);</span>
4476                 set-&gt;complement();
4477             }
<span class="line-modified">4478             else if (propName.compare(u&quot;javaDigit&quot;, -1) == 0) {</span>
<span class="line-added">4479                 addCategory(set.getAlias(), U_GC_ND_MASK, status);</span>
<span class="line-added">4480             }</span>
<span class="line-added">4481             else if (propName.compare(u&quot;javaIdentifierIgnorable&quot;, -1) == 0) {</span>
<span class="line-added">4482                 addIdentifierIgnorable(set.getAlias(), status);</span>
<span class="line-added">4483             }</span>
<span class="line-added">4484             else if (propName.compare(u&quot;javaISOControl&quot;, -1) == 0) {</span>
<span class="line-added">4485                 set-&gt;add(0, 0x1F).add(0x7F, 0x9F);</span>
<span class="line-added">4486             }</span>
<span class="line-added">4487             else if (propName.compare(u&quot;javaJavaIdentifierPart&quot;, -1) == 0) {</span>
<span class="line-added">4488                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">4489                 addCategory(set.getAlias(), U_GC_SC_MASK, status);</span>
<span class="line-added">4490                 addCategory(set.getAlias(), U_GC_PC_MASK, status);</span>
<span class="line-added">4491                 addCategory(set.getAlias(), U_GC_ND_MASK, status);</span>
<span class="line-added">4492                 addCategory(set.getAlias(), U_GC_NL_MASK, status);</span>
<span class="line-added">4493                 addCategory(set.getAlias(), U_GC_MC_MASK, status);</span>
<span class="line-added">4494                 addCategory(set.getAlias(), U_GC_MN_MASK, status);</span>
<span class="line-added">4495                 addIdentifierIgnorable(set.getAlias(), status);</span>
<span class="line-added">4496             }</span>
<span class="line-added">4497             else if (propName.compare(u&quot;javaJavaIdentifierStart&quot;, -1) == 0) {</span>
<span class="line-added">4498                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">4499                 addCategory(set.getAlias(), U_GC_NL_MASK, status);</span>
<span class="line-added">4500                 addCategory(set.getAlias(), U_GC_SC_MASK, status);</span>
<span class="line-added">4501                 addCategory(set.getAlias(), U_GC_PC_MASK, status);</span>
<span class="line-added">4502             }</span>
<span class="line-added">4503             else if (propName.compare(u&quot;javaLetter&quot;, -1) == 0) {</span>
<span class="line-added">4504                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">4505             }</span>
<span class="line-added">4506             else if (propName.compare(u&quot;javaLetterOrDigit&quot;, -1) == 0) {</span>
<span class="line-added">4507                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">4508                 addCategory(set.getAlias(), U_GC_ND_MASK, status);</span>
<span class="line-added">4509             }</span>
<span class="line-added">4510             else if (propName.compare(u&quot;javaLowerCase&quot;, -1) == 0) {</span>
<span class="line-added">4511                 addCategory(set.getAlias(), U_GC_LL_MASK, status);</span>
<span class="line-added">4512             }</span>
<span class="line-added">4513             else if (propName.compare(u&quot;javaMirrored&quot;, -1) == 0) {</span>
<span class="line-added">4514                 set-&gt;applyIntPropertyValue(UCHAR_BIDI_MIRRORED, 1, status);</span>
<span class="line-added">4515             }</span>
<span class="line-added">4516             else if (propName.compare(u&quot;javaSpaceChar&quot;, -1) == 0) {</span>
<span class="line-added">4517                 addCategory(set.getAlias(), U_GC_Z_MASK, status);</span>
<span class="line-added">4518             }</span>
<span class="line-added">4519             else if (propName.compare(u&quot;javaSupplementaryCodePoint&quot;, -1) == 0) {</span>
<span class="line-added">4520                 set-&gt;add(0x10000, UnicodeSet::MAX_VALUE);</span>
<span class="line-added">4521             }</span>
<span class="line-added">4522             else if (propName.compare(u&quot;javaTitleCase&quot;, -1) == 0) {</span>
<span class="line-added">4523                 addCategory(set.getAlias(), U_GC_LT_MASK, status);</span>
<span class="line-added">4524             }</span>
<span class="line-added">4525             else if (propName.compare(u&quot;javaUnicodeIdentifierStart&quot;, -1) == 0) {</span>
<span class="line-added">4526                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">4527                 addCategory(set.getAlias(), U_GC_NL_MASK, status);</span>
<span class="line-added">4528             }</span>
<span class="line-added">4529             else if (propName.compare(u&quot;javaUnicodeIdentifierPart&quot;, -1) == 0) {</span>
<span class="line-added">4530                 addCategory(set.getAlias(), U_GC_L_MASK, status);</span>
<span class="line-added">4531                 addCategory(set.getAlias(), U_GC_PC_MASK, status);</span>
<span class="line-added">4532                 addCategory(set.getAlias(), U_GC_ND_MASK, status);</span>
<span class="line-added">4533                 addCategory(set.getAlias(), U_GC_NL_MASK, status);</span>
<span class="line-added">4534                 addCategory(set.getAlias(), U_GC_MC_MASK, status);</span>
<span class="line-added">4535                 addCategory(set.getAlias(), U_GC_MN_MASK, status);</span>
<span class="line-added">4536                 addIdentifierIgnorable(set.getAlias(), status);</span>
<span class="line-added">4537             }</span>
<span class="line-added">4538             else if (propName.compare(u&quot;javaUpperCase&quot;, -1) == 0) {</span>
<span class="line-added">4539                 addCategory(set.getAlias(), U_GC_LU_MASK, status);</span>
<span class="line-added">4540             }</span>
<span class="line-added">4541             else if (propName.compare(u&quot;javaValidCodePoint&quot;, -1) == 0) {</span>
<span class="line-added">4542                 set-&gt;add(0, UnicodeSet::MAX_VALUE);</span>
<span class="line-added">4543             }</span>
<span class="line-added">4544             else if (propName.compare(u&quot;javaWhitespace&quot;, -1) == 0) {</span>
<span class="line-added">4545                 addCategory(set.getAlias(), U_GC_Z_MASK, status);</span>
<span class="line-added">4546                 set-&gt;removeAll(UnicodeSet().add(0xa0).add(0x2007).add(0x202f));</span>
<span class="line-added">4547                 set-&gt;add(9, 0x0d).add(0x1c, 0x1f);</span>
<span class="line-added">4548             } else {</span>
<span class="line-added">4549                 status = U_REGEX_PROPERTY_SYNTAX;</span>
<span class="line-added">4550             }</span>
<span class="line-added">4551 </span>
<span class="line-added">4552             if (U_SUCCESS(status) &amp;&amp; !set-&gt;isEmpty() &amp;&amp; (usetFlags &amp; USET_CASE_INSENSITIVE)) {</span>
<span class="line-added">4553                 set-&gt;closeOver(USET_CASE_INSENSITIVE);</span>
<span class="line-added">4554             }</span>
<span class="line-added">4555             break;</span>
<span class="line-added">4556         }</span>
<span class="line-added">4557 </span>
<span class="line-added">4558         // Unrecognized property. ICU didn&#39;t like it as it was, and none of the Java compatibility</span>
<span class="line-added">4559         // extensions matched it.</span>
<span class="line-added">4560         status = U_REGEX_PROPERTY_SYNTAX;</span>
<span class="line-added">4561     } while (false);   // End of do loop block. Code above breaks out of the block on success or hard failure.</span>
<span class="line-added">4562 </span>
<span class="line-added">4563     if (U_SUCCESS(status)) {</span>
<span class="line-added">4564         U_ASSERT(set.isValid());</span>
<span class="line-added">4565         if (negated) {</span>
<span class="line-added">4566             set-&gt;complement();</span>
4567         }
<span class="line-modified">4568         return set.orphan();</span>
<span class="line-modified">4569     } else {</span>
<span class="line-added">4570         if (status == U_ILLEGAL_ARGUMENT_ERROR) {</span>
<span class="line-added">4571             status = U_REGEX_PROPERTY_SYNTAX;</span>
<span class="line-added">4572         }</span>
<span class="line-added">4573         error(status);</span>
<span class="line-added">4574         return nullptr;</span>
4575     }


4576 }
4577 
4578 

4579 //
4580 //  SetEval   Part of the evaluation of [set expressions].
4581 //            Perform any pending (stacked) operations with precedence
4582 //            equal or greater to that of the next operator encountered
4583 //            in the expression.
4584 //
4585 void RegexCompile::setEval(int32_t nextOp) {
4586     UnicodeSet *rightOperand = NULL;
4587     UnicodeSet *leftOperand  = NULL;
4588     for (;;) {
4589         U_ASSERT(fSetOpStack.empty()==FALSE);
4590         int32_t pendingSetOperation = fSetOpStack.peeki();
4591         if ((pendingSetOperation&amp;0xffff0000) &lt; (nextOp&amp;0xffff0000)) {
4592             break;
4593         }
4594         fSetOpStack.popi();
4595         U_ASSERT(fSetStack.empty() == FALSE);
4596         rightOperand = (UnicodeSet *)fSetStack.peek();
4597         switch (pendingSetOperation) {
4598             case setNegation:
</pre>
<hr />
<pre>
4607             case setDifference2:
4608                 fSetStack.pop();
4609                 leftOperand = (UnicodeSet *)fSetStack.peek();
4610                 leftOperand-&gt;removeAll(*rightOperand);
4611                 delete rightOperand;
4612                 break;
4613             case setIntersection1:
4614             case setIntersection2:
4615                 fSetStack.pop();
4616                 leftOperand = (UnicodeSet *)fSetStack.peek();
4617                 leftOperand-&gt;retainAll(*rightOperand);
4618                 delete rightOperand;
4619                 break;
4620             case setUnion:
4621                 fSetStack.pop();
4622                 leftOperand = (UnicodeSet *)fSetStack.peek();
4623                 leftOperand-&gt;addAll(*rightOperand);
4624                 delete rightOperand;
4625                 break;
4626             default:
<span class="line-modified">4627                 UPRV_UNREACHABLE;</span>

4628             }
4629         }
4630     }
4631 
4632 void RegexCompile::setPushOp(int32_t op) {
4633     setEval(op);
4634     fSetOpStack.push(op, *fStatus);
4635     fSetStack.push(new UnicodeSet(), *fStatus);
4636 }
4637 
4638 U_NAMESPACE_END
4639 #endif  // !UCONFIG_NO_REGULAR_EXPRESSIONS
4640 
</pre>
</td>
</tr>
</table>
<center><a href="rbtz.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="regexcst.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>