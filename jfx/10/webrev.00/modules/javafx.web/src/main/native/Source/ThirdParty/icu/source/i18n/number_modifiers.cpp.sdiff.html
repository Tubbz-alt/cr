<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_modifiers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_microprops.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_modifiers.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_modifiers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36     return TRUE;
 37 }
 38 
 39 void U_CALLCONV initDefaultCurrencySpacing(UErrorCode &amp;status) {
 40     ucln_i18n_registerCleanup(UCLN_I18N_CURRENCY_SPACING, cleanupDefaultCurrencySpacing);
 41     UNISET_DIGIT = new UnicodeSet(UnicodeString(u&quot;[:digit:]&quot;), status);
 42     UNISET_NOTS = new UnicodeSet(UnicodeString(u&quot;[:^S:]&quot;), status);
 43     if (UNISET_DIGIT == nullptr || UNISET_NOTS == nullptr) {
 44         status = U_MEMORY_ALLOCATION_ERROR;
 45         return;
 46     }
 47     UNISET_DIGIT-&gt;freeze();
 48     UNISET_NOTS-&gt;freeze();
 49 }
 50 
 51 }  // namespace
 52 
 53 
 54 Modifier::~Modifier() = default;
 55 















 56 
 57 int32_t ConstantAffixModifier::apply(NumberStringBuilder &amp;output, int leftIndex, int rightIndex,
 58                                      UErrorCode &amp;status) const {
 59     // Insert the suffix first since inserting the prefix will change the rightIndex
 60     int length = output.insert(rightIndex, fSuffix, fField, status);
 61     length += output.insert(leftIndex, fPrefix, fField, status);
 62     return length;
 63 }
 64 
<span class="line-modified"> 65 int32_t ConstantAffixModifier::getPrefixLength(UErrorCode &amp;status) const {</span>
<span class="line-removed"> 66     (void)status;</span>
 67     return fPrefix.length();
 68 }
 69 
<span class="line-modified"> 70 int32_t ConstantAffixModifier::getCodePointCount(UErrorCode &amp;status) const {</span>
<span class="line-removed"> 71     (void)status;</span>
 72     return fPrefix.countChar32() + fSuffix.countChar32();
 73 }
 74 
 75 bool ConstantAffixModifier::isStrong() const {
 76     return fStrong;
 77 }
 78 
























 79 SimpleModifier::SimpleModifier(const SimpleFormatter &amp;simpleFormatter, Field field, bool strong)
<span class="line-modified"> 80         : fCompiledPattern(simpleFormatter.compiledPattern), fField(field), fStrong(strong) {</span>





 81     int32_t argLimit = SimpleFormatter::getArgumentLimit(
 82             fCompiledPattern.getBuffer(), fCompiledPattern.length());
 83     if (argLimit == 0) {
 84         // No arguments in compiled pattern
 85         fPrefixLength = fCompiledPattern.charAt(1) - ARG_NUM_LIMIT;
 86         U_ASSERT(2 + fPrefixLength == fCompiledPattern.length());
 87         // Set suffixOffset = -1 to indicate no arguments in compiled pattern.
 88         fSuffixOffset = -1;
 89         fSuffixLength = 0;
 90     } else {
 91         U_ASSERT(argLimit == 1);
 92         if (fCompiledPattern.charAt(1) != 0) {

 93             fPrefixLength = fCompiledPattern.charAt(1) - ARG_NUM_LIMIT;
 94             fSuffixOffset = 3 + fPrefixLength;
 95         } else {

 96             fPrefixLength = 0;
 97             fSuffixOffset = 2;
 98         }
 99         if (3 + fPrefixLength &lt; fCompiledPattern.length()) {

100             fSuffixLength = fCompiledPattern.charAt(fSuffixOffset) - ARG_NUM_LIMIT;
101         } else {

102             fSuffixLength = 0;
103         }
104     }
105 }
106 
107 SimpleModifier::SimpleModifier()
108         : fField(UNUM_FIELD_COUNT), fStrong(false), fPrefixLength(0), fSuffixLength(0) {
109 }
110 
111 int32_t SimpleModifier::apply(NumberStringBuilder &amp;output, int leftIndex, int rightIndex,
112                               UErrorCode &amp;status) const {
<span class="line-modified">113     return formatAsPrefixSuffix(output, leftIndex, rightIndex, fField, status);</span>
114 }
115 
<span class="line-modified">116 int32_t SimpleModifier::getPrefixLength(UErrorCode &amp;status) const {</span>
<span class="line-removed">117     (void)status;</span>
118     return fPrefixLength;
119 }
120 
<span class="line-modified">121 int32_t SimpleModifier::getCodePointCount(UErrorCode &amp;status) const {</span>
<span class="line-removed">122     (void)status;</span>
123     int32_t count = 0;
124     if (fPrefixLength &gt; 0) {
125         count += fCompiledPattern.countChar32(2, fPrefixLength);
126     }
127     if (fSuffixLength &gt; 0) {
128         count += fCompiledPattern.countChar32(1 + fSuffixOffset, fSuffixLength);
129     }
130     return count;
131 }
132 
133 bool SimpleModifier::isStrong() const {
134     return fStrong;
135 }
136 
























137 int32_t
138 SimpleModifier::formatAsPrefixSuffix(NumberStringBuilder &amp;result, int32_t startIndex, int32_t endIndex,
<span class="line-modified">139                                      Field field, UErrorCode &amp;status) const {</span>
<span class="line-modified">140     if (fSuffixOffset == -1) {</span>
141         // There is no argument for the inner number; overwrite the entire segment with our string.
<span class="line-modified">142         return result.splice(startIndex, endIndex, fCompiledPattern, 2, 2 + fPrefixLength, field, status);</span>
143     } else {
144         if (fPrefixLength &gt; 0) {
<span class="line-modified">145             result.insert(startIndex, fCompiledPattern, 2, 2 + fPrefixLength, field, status);</span>
146         }
147         if (fSuffixLength &gt; 0) {
148             result.insert(
149                     endIndex + fPrefixLength,
150                     fCompiledPattern,
151                     1 + fSuffixOffset,
152                     1 + fSuffixOffset + fSuffixLength,
<span class="line-modified">153                     field,</span>
154                     status);
155         }
156         return fPrefixLength + fSuffixLength;
157     }
158 }
159 



























































160 int32_t ConstantMultiFieldModifier::apply(NumberStringBuilder &amp;output, int leftIndex, int rightIndex,
161                                           UErrorCode &amp;status) const {
162     int32_t length = output.insert(leftIndex, fPrefix, status);
163     if (fOverwrite) {
164         length += output.splice(
165             leftIndex + length,
166             rightIndex + length,
167             UnicodeString(), 0, 0,
168             UNUM_FIELD_COUNT, status);
169     }
170     length += output.insert(rightIndex + length, fSuffix, status);
171     return length;
172 }
173 
<span class="line-modified">174 int32_t ConstantMultiFieldModifier::getPrefixLength(UErrorCode &amp;status) const {</span>
<span class="line-removed">175     (void)status;</span>
176     return fPrefix.length();
177 }
178 
<span class="line-modified">179 int32_t ConstantMultiFieldModifier::getCodePointCount(UErrorCode &amp;status) const {</span>
<span class="line-removed">180     (void)status;</span>
181     return fPrefix.codePointCount() + fSuffix.codePointCount();
182 }
183 
184 bool ConstantMultiFieldModifier::isStrong() const {
185     return fStrong;
186 }
187 























188 CurrencySpacingEnabledModifier::CurrencySpacingEnabledModifier(const NumberStringBuilder &amp;prefix,
189                                                                const NumberStringBuilder &amp;suffix,
190                                                                bool overwrite,
191                                                                bool strong,
192                                                                const DecimalFormatSymbols &amp;symbols,
193                                                                UErrorCode &amp;status)
194         : ConstantMultiFieldModifier(prefix, suffix, overwrite, strong) {
195     // Check for currency spacing. Do not build the UnicodeSets unless there is
196     // a currency code point at a boundary.
197     if (prefix.length() &gt; 0 &amp;&amp; prefix.fieldAt(prefix.length() - 1) == UNUM_CURRENCY_FIELD) {
198         int prefixCp = prefix.getLastCodePoint();
199         UnicodeSet prefixUnicodeSet = getUnicodeSet(symbols, IN_CURRENCY, PREFIX, status);
200         if (prefixUnicodeSet.contains(prefixCp)) {
201             fAfterPrefixUnicodeSet = getUnicodeSet(symbols, IN_NUMBER, PREFIX, status);
202             fAfterPrefixUnicodeSet.freeze();
203             fAfterPrefixInsert = getInsertString(symbols, PREFIX, status);
204         } else {
205             fAfterPrefixUnicodeSet.setToBogus();
206             fAfterPrefixInsert.setToBogus();
207         }
</pre>
</td>
<td>
<hr />
<pre>
 36     return TRUE;
 37 }
 38 
 39 void U_CALLCONV initDefaultCurrencySpacing(UErrorCode &amp;status) {
 40     ucln_i18n_registerCleanup(UCLN_I18N_CURRENCY_SPACING, cleanupDefaultCurrencySpacing);
 41     UNISET_DIGIT = new UnicodeSet(UnicodeString(u&quot;[:digit:]&quot;), status);
 42     UNISET_NOTS = new UnicodeSet(UnicodeString(u&quot;[:^S:]&quot;), status);
 43     if (UNISET_DIGIT == nullptr || UNISET_NOTS == nullptr) {
 44         status = U_MEMORY_ALLOCATION_ERROR;
 45         return;
 46     }
 47     UNISET_DIGIT-&gt;freeze();
 48     UNISET_NOTS-&gt;freeze();
 49 }
 50 
 51 }  // namespace
 52 
 53 
 54 Modifier::~Modifier() = default;
 55 
<span class="line-added"> 56 Modifier::Parameters::Parameters()</span>
<span class="line-added"> 57         : obj(nullptr) {}</span>
<span class="line-added"> 58 </span>
<span class="line-added"> 59 Modifier::Parameters::Parameters(</span>
<span class="line-added"> 60     const ModifierStore* _obj, int8_t _signum, StandardPlural::Form _plural)</span>
<span class="line-added"> 61         : obj(_obj), signum(_signum), plural(_plural) {}</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63 ModifierStore::~ModifierStore() = default;</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65 AdoptingModifierStore::~AdoptingModifierStore()  {</span>
<span class="line-added"> 66     for (const Modifier *mod : mods) {</span>
<span class="line-added"> 67         delete mod;</span>
<span class="line-added"> 68     }</span>
<span class="line-added"> 69 }</span>
<span class="line-added"> 70 </span>
 71 
 72 int32_t ConstantAffixModifier::apply(NumberStringBuilder &amp;output, int leftIndex, int rightIndex,
 73                                      UErrorCode &amp;status) const {
 74     // Insert the suffix first since inserting the prefix will change the rightIndex
 75     int length = output.insert(rightIndex, fSuffix, fField, status);
 76     length += output.insert(leftIndex, fPrefix, fField, status);
 77     return length;
 78 }
 79 
<span class="line-modified"> 80 int32_t ConstantAffixModifier::getPrefixLength() const {</span>

 81     return fPrefix.length();
 82 }
 83 
<span class="line-modified"> 84 int32_t ConstantAffixModifier::getCodePointCount() const {</span>

 85     return fPrefix.countChar32() + fSuffix.countChar32();
 86 }
 87 
 88 bool ConstantAffixModifier::isStrong() const {
 89     return fStrong;
 90 }
 91 
<span class="line-added"> 92 bool ConstantAffixModifier::containsField(UNumberFormatFields field) const {</span>
<span class="line-added"> 93     (void)field;</span>
<span class="line-added"> 94     // This method is not currently used.</span>
<span class="line-added"> 95     UPRV_UNREACHABLE;</span>
<span class="line-added"> 96 }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98 void ConstantAffixModifier::getParameters(Parameters&amp; output) const {</span>
<span class="line-added"> 99     (void)output;</span>
<span class="line-added">100     // This method is not currently used.</span>
<span class="line-added">101     UPRV_UNREACHABLE;</span>
<span class="line-added">102 }</span>
<span class="line-added">103 </span>
<span class="line-added">104 bool ConstantAffixModifier::semanticallyEquivalent(const Modifier&amp; other) const {</span>
<span class="line-added">105     auto* _other = dynamic_cast&lt;const ConstantAffixModifier*&gt;(&amp;other);</span>
<span class="line-added">106     if (_other == nullptr) {</span>
<span class="line-added">107         return false;</span>
<span class="line-added">108     }</span>
<span class="line-added">109     return fPrefix == _other-&gt;fPrefix</span>
<span class="line-added">110         &amp;&amp; fSuffix == _other-&gt;fSuffix</span>
<span class="line-added">111         &amp;&amp; fField == _other-&gt;fField</span>
<span class="line-added">112         &amp;&amp; fStrong == _other-&gt;fStrong;</span>
<span class="line-added">113 }</span>
<span class="line-added">114 </span>
<span class="line-added">115 </span>
116 SimpleModifier::SimpleModifier(const SimpleFormatter &amp;simpleFormatter, Field field, bool strong)
<span class="line-modified">117         : SimpleModifier(simpleFormatter, field, strong, {}) {}</span>
<span class="line-added">118 </span>
<span class="line-added">119 SimpleModifier::SimpleModifier(const SimpleFormatter &amp;simpleFormatter, Field field, bool strong,</span>
<span class="line-added">120                                const Modifier::Parameters parameters)</span>
<span class="line-added">121         : fCompiledPattern(simpleFormatter.compiledPattern), fField(field), fStrong(strong),</span>
<span class="line-added">122           fParameters(parameters) {</span>
123     int32_t argLimit = SimpleFormatter::getArgumentLimit(
124             fCompiledPattern.getBuffer(), fCompiledPattern.length());
125     if (argLimit == 0) {
126         // No arguments in compiled pattern
127         fPrefixLength = fCompiledPattern.charAt(1) - ARG_NUM_LIMIT;
128         U_ASSERT(2 + fPrefixLength == fCompiledPattern.length());
129         // Set suffixOffset = -1 to indicate no arguments in compiled pattern.
130         fSuffixOffset = -1;
131         fSuffixLength = 0;
132     } else {
133         U_ASSERT(argLimit == 1);
134         if (fCompiledPattern.charAt(1) != 0) {
<span class="line-added">135             // Found prefix</span>
136             fPrefixLength = fCompiledPattern.charAt(1) - ARG_NUM_LIMIT;
137             fSuffixOffset = 3 + fPrefixLength;
138         } else {
<span class="line-added">139             // No prefix</span>
140             fPrefixLength = 0;
141             fSuffixOffset = 2;
142         }
143         if (3 + fPrefixLength &lt; fCompiledPattern.length()) {
<span class="line-added">144             // Found suffix</span>
145             fSuffixLength = fCompiledPattern.charAt(fSuffixOffset) - ARG_NUM_LIMIT;
146         } else {
<span class="line-added">147             // No suffix</span>
148             fSuffixLength = 0;
149         }
150     }
151 }
152 
153 SimpleModifier::SimpleModifier()
154         : fField(UNUM_FIELD_COUNT), fStrong(false), fPrefixLength(0), fSuffixLength(0) {
155 }
156 
157 int32_t SimpleModifier::apply(NumberStringBuilder &amp;output, int leftIndex, int rightIndex,
158                               UErrorCode &amp;status) const {
<span class="line-modified">159     return formatAsPrefixSuffix(output, leftIndex, rightIndex, status);</span>
160 }
161 
<span class="line-modified">162 int32_t SimpleModifier::getPrefixLength() const {</span>

163     return fPrefixLength;
164 }
165 
<span class="line-modified">166 int32_t SimpleModifier::getCodePointCount() const {</span>

167     int32_t count = 0;
168     if (fPrefixLength &gt; 0) {
169         count += fCompiledPattern.countChar32(2, fPrefixLength);
170     }
171     if (fSuffixLength &gt; 0) {
172         count += fCompiledPattern.countChar32(1 + fSuffixOffset, fSuffixLength);
173     }
174     return count;
175 }
176 
177 bool SimpleModifier::isStrong() const {
178     return fStrong;
179 }
180 
<span class="line-added">181 bool SimpleModifier::containsField(UNumberFormatFields field) const {</span>
<span class="line-added">182     (void)field;</span>
<span class="line-added">183     // This method is not currently used.</span>
<span class="line-added">184     UPRV_UNREACHABLE;</span>
<span class="line-added">185 }</span>
<span class="line-added">186 </span>
<span class="line-added">187 void SimpleModifier::getParameters(Parameters&amp; output) const {</span>
<span class="line-added">188     output = fParameters;</span>
<span class="line-added">189 }</span>
<span class="line-added">190 </span>
<span class="line-added">191 bool SimpleModifier::semanticallyEquivalent(const Modifier&amp; other) const {</span>
<span class="line-added">192     auto* _other = dynamic_cast&lt;const SimpleModifier*&gt;(&amp;other);</span>
<span class="line-added">193     if (_other == nullptr) {</span>
<span class="line-added">194         return false;</span>
<span class="line-added">195     }</span>
<span class="line-added">196     if (fParameters.obj != nullptr) {</span>
<span class="line-added">197         return fParameters.obj == _other-&gt;fParameters.obj;</span>
<span class="line-added">198     }</span>
<span class="line-added">199     return fCompiledPattern == _other-&gt;fCompiledPattern</span>
<span class="line-added">200         &amp;&amp; fField == _other-&gt;fField</span>
<span class="line-added">201         &amp;&amp; fStrong == _other-&gt;fStrong;</span>
<span class="line-added">202 }</span>
<span class="line-added">203 </span>
<span class="line-added">204 </span>
205 int32_t
206 SimpleModifier::formatAsPrefixSuffix(NumberStringBuilder &amp;result, int32_t startIndex, int32_t endIndex,
<span class="line-modified">207                                      UErrorCode &amp;status) const {</span>
<span class="line-modified">208     if (fSuffixOffset == -1 &amp;&amp; fPrefixLength + fSuffixLength &gt; 0) {</span>
209         // There is no argument for the inner number; overwrite the entire segment with our string.
<span class="line-modified">210         return result.splice(startIndex, endIndex, fCompiledPattern, 2, 2 + fPrefixLength, fField, status);</span>
211     } else {
212         if (fPrefixLength &gt; 0) {
<span class="line-modified">213             result.insert(startIndex, fCompiledPattern, 2, 2 + fPrefixLength, fField, status);</span>
214         }
215         if (fSuffixLength &gt; 0) {
216             result.insert(
217                     endIndex + fPrefixLength,
218                     fCompiledPattern,
219                     1 + fSuffixOffset,
220                     1 + fSuffixOffset + fSuffixLength,
<span class="line-modified">221                     fField,</span>
222                     status);
223         }
224         return fPrefixLength + fSuffixLength;
225     }
226 }
227 
<span class="line-added">228 </span>
<span class="line-added">229 int32_t</span>
<span class="line-added">230 SimpleModifier::formatTwoArgPattern(const SimpleFormatter&amp; compiled, NumberStringBuilder&amp; result,</span>
<span class="line-added">231                                     int32_t index, int32_t* outPrefixLength, int32_t* outSuffixLength,</span>
<span class="line-added">232                                     Field field, UErrorCode&amp; status) {</span>
<span class="line-added">233     const UnicodeString&amp; compiledPattern = compiled.compiledPattern;</span>
<span class="line-added">234     int32_t argLimit = SimpleFormatter::getArgumentLimit(</span>
<span class="line-added">235             compiledPattern.getBuffer(), compiledPattern.length());</span>
<span class="line-added">236     if (argLimit != 2) {</span>
<span class="line-added">237         status = U_INTERNAL_PROGRAM_ERROR;</span>
<span class="line-added">238         return 0;</span>
<span class="line-added">239     }</span>
<span class="line-added">240     int32_t offset = 1; // offset into compiledPattern</span>
<span class="line-added">241     int32_t length = 0; // chars added to result</span>
<span class="line-added">242 </span>
<span class="line-added">243     int32_t prefixLength = compiledPattern.charAt(offset);</span>
<span class="line-added">244     offset++;</span>
<span class="line-added">245     if (prefixLength &lt; ARG_NUM_LIMIT) {</span>
<span class="line-added">246         // No prefix</span>
<span class="line-added">247         prefixLength = 0;</span>
<span class="line-added">248     } else {</span>
<span class="line-added">249         prefixLength -= ARG_NUM_LIMIT;</span>
<span class="line-added">250         result.insert(index + length, compiledPattern, offset, offset + prefixLength, field, status);</span>
<span class="line-added">251         offset += prefixLength;</span>
<span class="line-added">252         length += prefixLength;</span>
<span class="line-added">253         offset++;</span>
<span class="line-added">254     }</span>
<span class="line-added">255 </span>
<span class="line-added">256     int32_t infixLength = compiledPattern.charAt(offset);</span>
<span class="line-added">257     offset++;</span>
<span class="line-added">258     if (infixLength &lt; ARG_NUM_LIMIT) {</span>
<span class="line-added">259         // No infix</span>
<span class="line-added">260         infixLength = 0;</span>
<span class="line-added">261     } else {</span>
<span class="line-added">262         infixLength -= ARG_NUM_LIMIT;</span>
<span class="line-added">263         result.insert(index + length, compiledPattern, offset, offset + infixLength, field, status);</span>
<span class="line-added">264         offset += infixLength;</span>
<span class="line-added">265         length += infixLength;</span>
<span class="line-added">266         offset++;</span>
<span class="line-added">267     }</span>
<span class="line-added">268 </span>
<span class="line-added">269     int32_t suffixLength;</span>
<span class="line-added">270     if (offset == compiledPattern.length()) {</span>
<span class="line-added">271         // No suffix</span>
<span class="line-added">272         suffixLength = 0;</span>
<span class="line-added">273     } else {</span>
<span class="line-added">274         suffixLength = compiledPattern.charAt(offset) -  ARG_NUM_LIMIT;</span>
<span class="line-added">275         offset++;</span>
<span class="line-added">276         result.insert(index + length, compiledPattern, offset, offset + suffixLength, field, status);</span>
<span class="line-added">277         length += suffixLength;</span>
<span class="line-added">278     }</span>
<span class="line-added">279 </span>
<span class="line-added">280     *outPrefixLength = prefixLength;</span>
<span class="line-added">281     *outSuffixLength = suffixLength;</span>
<span class="line-added">282 </span>
<span class="line-added">283     return length;</span>
<span class="line-added">284 }</span>
<span class="line-added">285 </span>
<span class="line-added">286 </span>
287 int32_t ConstantMultiFieldModifier::apply(NumberStringBuilder &amp;output, int leftIndex, int rightIndex,
288                                           UErrorCode &amp;status) const {
289     int32_t length = output.insert(leftIndex, fPrefix, status);
290     if (fOverwrite) {
291         length += output.splice(
292             leftIndex + length,
293             rightIndex + length,
294             UnicodeString(), 0, 0,
295             UNUM_FIELD_COUNT, status);
296     }
297     length += output.insert(rightIndex + length, fSuffix, status);
298     return length;
299 }
300 
<span class="line-modified">301 int32_t ConstantMultiFieldModifier::getPrefixLength() const {</span>

302     return fPrefix.length();
303 }
304 
<span class="line-modified">305 int32_t ConstantMultiFieldModifier::getCodePointCount() const {</span>

306     return fPrefix.codePointCount() + fSuffix.codePointCount();
307 }
308 
309 bool ConstantMultiFieldModifier::isStrong() const {
310     return fStrong;
311 }
312 
<span class="line-added">313 bool ConstantMultiFieldModifier::containsField(UNumberFormatFields field) const {</span>
<span class="line-added">314     return fPrefix.containsField(field) || fSuffix.containsField(field);</span>
<span class="line-added">315 }</span>
<span class="line-added">316 </span>
<span class="line-added">317 void ConstantMultiFieldModifier::getParameters(Parameters&amp; output) const {</span>
<span class="line-added">318     output = fParameters;</span>
<span class="line-added">319 }</span>
<span class="line-added">320 </span>
<span class="line-added">321 bool ConstantMultiFieldModifier::semanticallyEquivalent(const Modifier&amp; other) const {</span>
<span class="line-added">322     auto* _other = dynamic_cast&lt;const ConstantMultiFieldModifier*&gt;(&amp;other);</span>
<span class="line-added">323     if (_other == nullptr) {</span>
<span class="line-added">324         return false;</span>
<span class="line-added">325     }</span>
<span class="line-added">326     if (fParameters.obj != nullptr) {</span>
<span class="line-added">327         return fParameters.obj == _other-&gt;fParameters.obj;</span>
<span class="line-added">328     }</span>
<span class="line-added">329     return fPrefix.contentEquals(_other-&gt;fPrefix)</span>
<span class="line-added">330         &amp;&amp; fSuffix.contentEquals(_other-&gt;fSuffix)</span>
<span class="line-added">331         &amp;&amp; fOverwrite == _other-&gt;fOverwrite</span>
<span class="line-added">332         &amp;&amp; fStrong == _other-&gt;fStrong;</span>
<span class="line-added">333 }</span>
<span class="line-added">334 </span>
<span class="line-added">335 </span>
336 CurrencySpacingEnabledModifier::CurrencySpacingEnabledModifier(const NumberStringBuilder &amp;prefix,
337                                                                const NumberStringBuilder &amp;suffix,
338                                                                bool overwrite,
339                                                                bool strong,
340                                                                const DecimalFormatSymbols &amp;symbols,
341                                                                UErrorCode &amp;status)
342         : ConstantMultiFieldModifier(prefix, suffix, overwrite, strong) {
343     // Check for currency spacing. Do not build the UnicodeSets unless there is
344     // a currency code point at a boundary.
345     if (prefix.length() &gt; 0 &amp;&amp; prefix.fieldAt(prefix.length() - 1) == UNUM_CURRENCY_FIELD) {
346         int prefixCp = prefix.getLastCodePoint();
347         UnicodeSet prefixUnicodeSet = getUnicodeSet(symbols, IN_CURRENCY, PREFIX, status);
348         if (prefixUnicodeSet.contains(prefixCp)) {
349             fAfterPrefixUnicodeSet = getUnicodeSet(symbols, IN_NUMBER, PREFIX, status);
350             fAfterPrefixUnicodeSet.freeze();
351             fAfterPrefixInsert = getInsertString(symbols, PREFIX, status);
352         } else {
353             fAfterPrefixUnicodeSet.setToBogus();
354             fAfterPrefixInsert.setToBogus();
355         }
</pre>
</td>
</tr>
</table>
<center><a href="number_microprops.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_modifiers.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>