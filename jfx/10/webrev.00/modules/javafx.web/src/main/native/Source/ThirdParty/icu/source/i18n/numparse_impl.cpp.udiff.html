<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numparse_impl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="numparse_currency.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numparse_impl.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numparse_impl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -70,11 +70,11 @@</span>
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.nan = {symbols});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.infinity = {symbols});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.padding = {u&quot;@&quot;});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.scientific = {symbols, grouper});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.currency = {currencySymbols, symbols, parseFlags, status});
<span class="udiff-line-modified-removed">- //    parser.addMatcher(new RequireNumberMatcher());</span>
<span class="udiff-line-modified-added">+     parser-&gt;addMatcher(parser-&gt;fLocalValidators.number = {});</span>
  
      parser-&gt;freeze();
      return parser.orphan();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -157,14 +157,14 @@</span>
      /// PERCENT ///
      ///////////////
  
      // ICU-TC meeting, April 11, 2018: accept percent/permille only if it is in the pattern,
      // and to maintain regressive behavior, divide by 100 even if no percent sign is present.
<span class="udiff-line-modified-removed">-     if (affixProvider-&gt;containsSymbolType(AffixPatternType::TYPE_PERCENT, status)) {</span>
<span class="udiff-line-modified-added">+     if (!isStrict &amp;&amp; affixProvider-&gt;containsSymbolType(AffixPatternType::TYPE_PERCENT, status)) {</span>
          parser-&gt;addMatcher(parser-&gt;fLocalMatchers.percent = {symbols});
      }
<span class="udiff-line-modified-removed">-     if (affixProvider-&gt;containsSymbolType(AffixPatternType::TYPE_PERMILLE, status)) {</span>
<span class="udiff-line-modified-added">+     if (!isStrict &amp;&amp; affixProvider-&gt;containsSymbolType(AffixPatternType::TYPE_PERMILLE, status)) {</span>
          parser-&gt;addMatcher(parser-&gt;fLocalMatchers.permille = {symbols});
      }
  
      ///////////////////////////////
      /// OTHER STANDARD MATCHERS ///
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -250,58 +250,71 @@</span>
      U_ASSERT(fFrozen);
      // TODO: Check start &gt;= 0 and start &lt; input.length()
      StringSegment segment(input, 0 != (fParseFlags &amp; PARSE_FLAG_IGNORE_CASE));
      segment.adjustOffset(start);
      if (greedy) {
<span class="udiff-line-modified-removed">-         parseGreedyRecursive(segment, result, status);</span>
<span class="udiff-line-modified-added">+         parseGreedy(segment, result, status);</span>
<span class="udiff-line-added">+     } else if (0 != (fParseFlags &amp; PARSE_FLAG_ALLOW_INFINITE_RECURSION)) {</span>
<span class="udiff-line-added">+         // Start at 1 so that recursionLevels never gets to 0</span>
<span class="udiff-line-added">+         parseLongestRecursive(segment, result, 1, status);</span>
      } else {
<span class="udiff-line-modified-removed">-         parseLongestRecursive(segment, result, status);</span>
<span class="udiff-line-modified-added">+         // Arbitrary recursion safety limit: 100 levels.</span>
<span class="udiff-line-added">+         parseLongestRecursive(segment, result, -100, status);</span>
      }
      for (int32_t i = 0; i &lt; fNumMatchers; i++) {
          fMatchers[i]-&gt;postProcess(result);
      }
      result.postProcess();
  }
  
<span class="udiff-line-modified-removed">- void NumberParserImpl::parseGreedyRecursive(StringSegment&amp; segment, ParsedNumber&amp; result,</span>
<span class="udiff-line-modified-added">+ void NumberParserImpl::parseGreedy(StringSegment&amp; segment, ParsedNumber&amp; result,</span>
                                              UErrorCode&amp; status) const {
<span class="udiff-line-modified-removed">-     // Base Case</span>
<span class="udiff-line-modified-removed">-     if (segment.length() == 0) {</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     int initialOffset = segment.getOffset();</span>
<span class="udiff-line-removed">-     for (int32_t i = 0; i &lt; fNumMatchers; i++) {</span>
<span class="udiff-line-modified-added">+     // Note: this method is not recursive in order to avoid stack overflow.</span>
<span class="udiff-line-modified-added">+     for (int i = 0; i &lt;fNumMatchers;) {</span>
<span class="udiff-line-modified-added">+         // Base Case</span>
<span class="udiff-line-modified-added">+         if (segment.length() == 0) {</span>
<span class="udiff-line-modified-added">+             return;</span>
<span class="udiff-line-modified-added">+         }</span>
          const NumberParseMatcher* matcher = fMatchers[i];
          if (!matcher-&gt;smokeTest(segment)) {
<span class="udiff-line-added">+             // Matcher failed smoke test: try the next one</span>
<span class="udiff-line-added">+             i++;</span>
              continue;
          }
<span class="udiff-line-added">+         int32_t initialOffset = segment.getOffset();</span>
          matcher-&gt;match(segment, result, status);
          if (U_FAILURE(status)) {
              return;
          }
          if (segment.getOffset() != initialOffset) {
<span class="udiff-line-modified-removed">-             // In a greedy parse, recurse on only the first match.</span>
<span class="udiff-line-modified-removed">-             parseGreedyRecursive(segment, result, status);</span>
<span class="udiff-line-modified-removed">-             // The following line resets the offset so that the StringSegment says the same across</span>
<span class="udiff-line-modified-removed">-             // the function</span>
<span class="udiff-line-modified-removed">-             // call boundary. Since we recurse only once, this line is not strictly necessary.</span>
<span class="udiff-line-modified-removed">-             segment.setOffset(initialOffset);</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-added">+             // Greedy heuristic: accept the match and loop back</span>
<span class="udiff-line-modified-added">+             i = 0;</span>
<span class="udiff-line-modified-added">+             continue;</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+             // Matcher did not match: try the next one</span>
<span class="udiff-line-modified-added">+             i++;</span>
<span class="udiff-line-modified-added">+             continue;</span>
          }
<span class="udiff-line-added">+         UPRV_UNREACHABLE;</span>
      }
  
      // NOTE: If we get here, the greedy parse completed without consuming the entire string.
  }
  
<span class="udiff-line-added">+                                              int32_t recursionLevels,</span>
                                               UErrorCode&amp; status) const {
      // Base Case
      if (segment.length() == 0) {
          return;
      }
<span class="udiff-line-added">+     // Safety against stack overflow</span>
<span class="udiff-line-added">+     if (recursionLevels == 0) {</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      // TODO: Give a nice way for the matcher to reset the ParsedNumber?
      ParsedNumber initial(result);
      ParsedNumber candidate;
  
      int initialOffset = segment.getOffset();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -324,11 +337,11 @@</span>
                  return;
              }
  
              // If the entire segment was consumed, recurse.
              if (segment.getOffset() - initialOffset == charsToConsume) {
<span class="udiff-line-modified-removed">-                 parseLongestRecursive(segment, candidate, status);</span>
<span class="udiff-line-modified-added">+                 parseLongestRecursive(segment, candidate, recursionLevels + 1, status);</span>
                  if (U_FAILURE(status)) {
                      return;
                  }
                  if (candidate.isBetterThan(result)) {
                      result = candidate;
</pre>
<center><a href="numparse_currency.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numparse_impl.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>