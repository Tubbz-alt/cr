<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/msgfmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 * Copyright (C) 2007-2013, International Business Machines Corporation and
   5 * others. All Rights Reserved.
   6 ********************************************************************************
   7 *
   8 * File MSGFMT.H
   9 *
  10 * Modification History:
  11 *
  12 *   Date        Name        Description
  13 *   02/19/97    aliu        Converted from java.
  14 *   03/20/97    helena      Finished first cut of implementation.
  15 *   07/22/98    stephen     Removed operator!= (defined in Format)
  16 *   08/19/2002  srl         Removing Javaisms
  17 *******************************************************************************/
  18 
  19 #ifndef MSGFMT_H
  20 #define MSGFMT_H
  21 
  22 #include &quot;unicode/utypes.h&quot;
  23 
  24 /**
  25  * \file
  26  * \brief C++ API: Formats messages in a language-neutral way.
  27  */
  28 
  29 #if !UCONFIG_NO_FORMATTING
  30 
  31 #include &quot;unicode/format.h&quot;
  32 #include &quot;unicode/locid.h&quot;
  33 #include &quot;unicode/messagepattern.h&quot;
  34 #include &quot;unicode/parseerr.h&quot;
  35 #include &quot;unicode/plurfmt.h&quot;
  36 #include &quot;unicode/plurrule.h&quot;
  37 
  38 U_CDECL_BEGIN
  39 // Forward declaration.
  40 struct UHashtable;
  41 typedef struct UHashtable UHashtable; /**&lt; @internal */
  42 U_CDECL_END
  43 
  44 U_NAMESPACE_BEGIN
  45 
  46 class AppendableWrapper;
  47 class DateFormat;
  48 class NumberFormat;
  49 
  50 /**
  51  * &lt;p&gt;MessageFormat prepares strings for display to users,
  52  * with optional arguments (variables/placeholders).
  53  * The arguments can occur in any order, which is necessary for translation
  54  * into languages with different grammars.
  55  *
  56  * &lt;p&gt;A MessageFormat is constructed from a &lt;em&gt;pattern&lt;/em&gt; string
  57  * with arguments in {curly braces} which will be replaced by formatted values.
  58  *
  59  * &lt;p&gt;&lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
  60  * classes in that you create a &lt;code&gt;MessageFormat&lt;/code&gt; object with one
  61  * of its constructors (not with a &lt;code&gt;createInstance&lt;/code&gt; style factory
  62  * method). Factory methods aren&#39;t necessary because &lt;code&gt;MessageFormat&lt;/code&gt;
  63  * itself doesn&#39;t implement locale-specific behavior. Any locale-specific
  64  * behavior is defined by the pattern that you provide and the
  65  * subformats used for inserted arguments.
  66  *
  67  * &lt;p&gt;Arguments can be named (using identifiers) or numbered (using small ASCII-digit integers).
  68  * Some of the API methods work only with argument numbers and throw an exception
  69  * if the pattern has named arguments (see {@link #usesNamedArguments()}).
  70  *
  71  * &lt;p&gt;An argument might not specify any format type. In this case,
  72  * a numeric value is formatted with a default (for the locale) NumberFormat,
  73  * and a date/time value is formatted with a default (for the locale) DateFormat.
  74  *
  75  * &lt;p&gt;An argument might specify a &quot;simple&quot; type for which the specified
  76  * Format object is created, cached and used.
  77  *
  78  * &lt;p&gt;An argument might have a &quot;complex&quot; type with nested MessageFormat sub-patterns.
  79  * During formatting, one of these sub-messages is selected according to the argument value
  80  * and recursively formatted.
  81  *
  82  * &lt;p&gt;After construction, a custom Format object can be set for
  83  * a top-level argument, overriding the default formatting and parsing behavior
  84  * for that argument.
  85  * However, custom formatting can be achieved more simply by writing
  86  * a typeless argument in the pattern string
  87  * and supplying it with a preformatted string value.
  88  *
  89  * &lt;p&gt;When formatting, MessageFormat takes a collection of argument values
  90  * and writes an output string.
  91  * The argument values may be passed as an array
  92  * (when the pattern contains only numbered arguments)
  93  * or as an array of names and and an array of arguments (which works for both named
  94  * and numbered arguments).
  95  *
  96  * &lt;p&gt;Each argument is matched with one of the input values by array index or argument name
  97  * and formatted according to its pattern specification
  98  * (or using a custom Format object if one was set).
  99  * A numbered pattern argument is matched with an argument name that contains that number
 100  * as an ASCII-decimal-digit string (without leading zero).
 101  *
 102  * &lt;h4&gt;&lt;a name=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h4&gt;
 103  *
 104  * &lt;code&gt;MessageFormat&lt;/code&gt; uses patterns of the following form:
 105  * &lt;pre&gt;
 106  * message = messageText (argument messageText)*
 107  * argument = noneArg | simpleArg | complexArg
 108  * complexArg = choiceArg | pluralArg | selectArg | selectordinalArg
 109  *
 110  * noneArg = &#39;{&#39; argNameOrNumber &#39;}&#39;
 111  * simpleArg = &#39;{&#39; argNameOrNumber &#39;,&#39; argType [&#39;,&#39; argStyle] &#39;}&#39;
 112  * choiceArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;choice&quot; &#39;,&#39; choiceStyle &#39;}&#39;
 113  * pluralArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;plural&quot; &#39;,&#39; pluralStyle &#39;}&#39;
 114  * selectArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;select&quot; &#39;,&#39; selectStyle &#39;}&#39;
 115  * selectordinalArg = &#39;{&#39; argNameOrNumber &#39;,&#39; &quot;selectordinal&quot; &#39;,&#39; pluralStyle &#39;}&#39;
 116  *
 117  * choiceStyle: see {@link ChoiceFormat}
 118  * pluralStyle: see {@link PluralFormat}
 119  * selectStyle: see {@link SelectFormat}
 120  *
 121  * argNameOrNumber = argName | argNumber
 122  * argName = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+
 123  * argNumber = &#39;0&#39; | (&#39;1&#39;..&#39;9&#39; (&#39;0&#39;..&#39;9&#39;)*)
 124  *
 125  * argType = &quot;number&quot; | &quot;date&quot; | &quot;time&quot; | &quot;spellout&quot; | &quot;ordinal&quot; | &quot;duration&quot;
 126  * argStyle = &quot;short&quot; | &quot;medium&quot; | &quot;long&quot; | &quot;full&quot; | &quot;integer&quot; | &quot;currency&quot; | &quot;percent&quot; | argStyleText | &quot;::&quot; argSkeletonText
 127  * &lt;/pre&gt;
 128  *
 129  * &lt;ul&gt;
 130  *   &lt;li&gt;messageText can contain quoted literal strings including syntax characters.
 131  *       A quoted literal string begins with an ASCII apostrophe and a syntax character
 132  *       (usually a {curly brace}) and continues until the next single apostrophe.
 133  *       A double ASCII apostrohpe inside or outside of a quoted string represents
 134  *       one literal apostrophe.
 135  *   &lt;li&gt;Quotable syntax characters are the {curly braces} in all messageText parts,
 136  *       plus the &#39;#&#39; sign in a messageText immediately inside a pluralStyle,
 137  *       and the &#39;|&#39; symbol in a messageText immediately inside a choiceStyle.
 138  *   &lt;li&gt;See also {@link #UMessagePatternApostropheMode}
 139  *   &lt;li&gt;In argStyleText, every single ASCII apostrophe begins and ends quoted literal text,
 140  *       and unquoted {curly braces} must occur in matched pairs.
 141  * &lt;/ul&gt;
 142  *
 143  * &lt;p&gt;Recommendation: Use the real apostrophe (single quote) character
 144  * \htmlonly&amp;#x2019;\endhtmlonly (U+2019) for
 145  * human-readable text, and use the ASCII apostrophe &#39; (U+0027)
 146  * only in program syntax, like quoting in MessageFormat.
 147  * See the annotations for U+0027 Apostrophe in The Unicode Standard.
 148  *
 149  * &lt;p&gt;The &lt;code&gt;choice&lt;/code&gt; argument type is deprecated.
 150  * Use &lt;code&gt;plural&lt;/code&gt; arguments for proper plural selection,
 151  * and &lt;code&gt;select&lt;/code&gt; arguments for simple selection among a fixed set of choices.
 152  *
 153  * &lt;p&gt;The &lt;code&gt;argType&lt;/code&gt; and &lt;code&gt;argStyle&lt;/code&gt; values are used to create
 154  * a &lt;code&gt;Format&lt;/code&gt; instance for the format element. The following
 155  * table shows how the values map to Format instances. Combinations not
 156  * shown in the table are illegal. Any &lt;code&gt;argStyleText&lt;/code&gt; must
 157  * be a valid pattern string for the Format subclass used.
 158  *
 159  * &lt;p&gt;&lt;table border=1&gt;
 160  *    &lt;tr&gt;
 161  *       &lt;th&gt;argType
 162  *       &lt;th&gt;argStyle
 163  *       &lt;th&gt;resulting Format object
 164  *    &lt;tr&gt;
 165  *       &lt;td colspan=2&gt;&lt;i&gt;(none)&lt;/i&gt;
 166  *       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
 167  *    &lt;tr&gt;
 168  *       &lt;td rowspan=6&gt;&lt;code&gt;number&lt;/code&gt;
 169  *       &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;
 170  *       &lt;td&gt;&lt;code&gt;NumberFormat.createInstance(getLocale(), status)&lt;/code&gt;
 171  *    &lt;tr&gt;
 172  *       &lt;td&gt;&lt;code&gt;integer&lt;/code&gt;
 173  *       &lt;td&gt;&lt;code&gt;NumberFormat.createInstance(getLocale(), kNumberStyle, status)&lt;/code&gt;
 174  *    &lt;tr&gt;
 175  *       &lt;td&gt;&lt;code&gt;currency&lt;/code&gt;
 176  *       &lt;td&gt;&lt;code&gt;NumberFormat.createCurrencyInstance(getLocale(), status)&lt;/code&gt;
 177  *    &lt;tr&gt;
 178  *       &lt;td&gt;&lt;code&gt;percent&lt;/code&gt;
 179  *       &lt;td&gt;&lt;code&gt;NumberFormat.createPercentInstance(getLocale(), status)&lt;/code&gt;
 180  *    &lt;tr&gt;
 181  *       &lt;td&gt;&lt;i&gt;argStyleText&lt;/i&gt;
 182  *       &lt;td&gt;&lt;code&gt;new DecimalFormat(argStyleText, new DecimalFormatSymbols(getLocale(), status), status)&lt;/code&gt;
 183  *    &lt;tr&gt;
 184  *       &lt;td&gt;&lt;i&gt;argSkeletonText&lt;/i&gt;
 185  *       &lt;td&gt;&lt;code&gt;NumberFormatter::forSkeleton(argSkeletonText, status).locale(getLocale()).toFormat(status)&lt;/code&gt;
 186  *    &lt;tr&gt;
 187  *       &lt;td rowspan=6&gt;&lt;code&gt;date&lt;/code&gt;
 188  *       &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;
 189  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kDefault, getLocale(), status)&lt;/code&gt;
 190  *    &lt;tr&gt;
 191  *       &lt;td&gt;&lt;code&gt;short&lt;/code&gt;
 192  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kShort, getLocale(), status)&lt;/code&gt;
 193  *    &lt;tr&gt;
 194  *       &lt;td&gt;&lt;code&gt;medium&lt;/code&gt;
 195  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kDefault, getLocale(), status)&lt;/code&gt;
 196  *    &lt;tr&gt;
 197  *       &lt;td&gt;&lt;code&gt;long&lt;/code&gt;
 198  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kLong, getLocale(), status)&lt;/code&gt;
 199  *    &lt;tr&gt;
 200  *       &lt;td&gt;&lt;code&gt;full&lt;/code&gt;
 201  *       &lt;td&gt;&lt;code&gt;DateFormat.createDateInstance(kFull, getLocale(), status)&lt;/code&gt;
 202  *    &lt;tr&gt;
 203  *       &lt;td&gt;&lt;i&gt;argStyleText&lt;/i&gt;
 204  *       &lt;td&gt;&lt;code&gt;new SimpleDateFormat(argStyleText, getLocale(), status)&lt;/code&gt;
 205  *    &lt;tr&gt;
 206  *       &lt;td&gt;&lt;i&gt;argSkeletonText&lt;/i&gt;
 207  *       &lt;td&gt;&lt;code&gt;DateFormat::createInstanceForSkeleton(argSkeletonText, getLocale(), status)&lt;/code&gt;
 208  *    &lt;tr&gt;
 209  *       &lt;td rowspan=6&gt;&lt;code&gt;time&lt;/code&gt;
 210  *       &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;
 211  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kDefault, getLocale(), status)&lt;/code&gt;
 212  *    &lt;tr&gt;
 213  *       &lt;td&gt;&lt;code&gt;short&lt;/code&gt;
 214  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kShort, getLocale(), status)&lt;/code&gt;
 215  *    &lt;tr&gt;
 216  *       &lt;td&gt;&lt;code&gt;medium&lt;/code&gt;
 217  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kDefault, getLocale(), status)&lt;/code&gt;
 218  *    &lt;tr&gt;
 219  *       &lt;td&gt;&lt;code&gt;long&lt;/code&gt;
 220  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kLong, getLocale(), status)&lt;/code&gt;
 221  *    &lt;tr&gt;
 222  *       &lt;td&gt;&lt;code&gt;full&lt;/code&gt;
 223  *       &lt;td&gt;&lt;code&gt;DateFormat.createTimeInstance(kFull, getLocale(), status)&lt;/code&gt;
 224  *    &lt;tr&gt;
 225  *       &lt;td&gt;&lt;i&gt;argStyleText&lt;/i&gt;
 226  *       &lt;td&gt;&lt;code&gt;new SimpleDateFormat(argStyleText, getLocale(), status)&lt;/code&gt;
 227  *    &lt;tr&gt;
 228  *       &lt;td&gt;&lt;code&gt;spellout&lt;/code&gt;
 229  *       &lt;td&gt;&lt;i&gt;argStyleText (optional)&lt;/i&gt;
 230  *       &lt;td&gt;&lt;code&gt;new RuleBasedNumberFormat(URBNF_SPELLOUT, getLocale(), status)
 231  *           &lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.setDefaultRuleset(argStyleText, status);&lt;/code&gt;
 232  *    &lt;tr&gt;
 233  *       &lt;td&gt;&lt;code&gt;ordinal&lt;/code&gt;
 234  *       &lt;td&gt;&lt;i&gt;argStyleText (optional)&lt;/i&gt;
 235  *       &lt;td&gt;&lt;code&gt;new RuleBasedNumberFormat(URBNF_ORDINAL, getLocale(), status)
 236  *           &lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.setDefaultRuleset(argStyleText, status);&lt;/code&gt;
 237  *    &lt;tr&gt;
 238  *       &lt;td&gt;&lt;code&gt;duration&lt;/code&gt;
 239  *       &lt;td&gt;&lt;i&gt;argStyleText (optional)&lt;/i&gt;
 240  *       &lt;td&gt;&lt;code&gt;new RuleBasedNumberFormat(URBNF_DURATION, getLocale(), status)
 241  *           &lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.setDefaultRuleset(argStyleText, status);&lt;/code&gt;
 242  * &lt;/table&gt;
 243  * &lt;p&gt;
 244  *
 245  * &lt;h4&gt;Argument formatting&lt;/h4&gt;
 246  *
 247  * &lt;p&gt;Arguments are formatted according to their type, using the default
 248  * ICU formatters for those types, unless otherwise specified.&lt;/p&gt;
 249  *
 250  * &lt;p&gt;There are also several ways to control the formatting.&lt;/p&gt;
 251  *
 252  * &lt;p&gt;We recommend you use default styles, predefined style values, skeletons,
 253  * or preformatted values, but not pattern strings or custom format objects.&lt;/p&gt;
 254  *
 255  * &lt;p&gt;For more details, see the
 256  * &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages&quot;&gt;ICU User Guide&lt;/a&gt;.&lt;/p&gt;
 257  *
 258  * &lt;h4&gt;Usage Information&lt;/h4&gt;
 259  *
 260  * &lt;p&gt;Here are some examples of usage:
 261  * Example 1:
 262  *
 263  * &lt;pre&gt;
 264  * \code
 265  *     UErrorCode success = U_ZERO_ERROR;
 266  *     GregorianCalendar cal(success);
 267  *     Formattable arguments[] = {
 268  *         7L,
 269  *         Formattable( (Date) cal.getTime(success), Formattable::kIsDate),
 270  *         &quot;a disturbance in the Force&quot;
 271  *     };
 272  *
 273  *     UnicodeString result;
 274  *     MessageFormat::format(
 275  *          &quot;At {1,time,::jmm} on {1,date,::dMMMM}, there was {2} on planet {0,number}.&quot;,
 276  *          arguments, 3, result, success );
 277  *
 278  *     cout &lt;&lt; &quot;result: &quot; &lt;&lt; result &lt;&lt; endl;
 279  *     //&lt;output&gt;: At 4:34 PM on March 23, there was a disturbance
 280  *     //             in the Force on planet 7.
 281  * \endcode
 282  * &lt;/pre&gt;
 283  *
 284  * Typically, the message format will come from resources, and the
 285  * arguments will be dynamically set at runtime.
 286  *
 287  * &lt;p&gt;Example 2:
 288  *
 289  * &lt;pre&gt;
 290  *  \code
 291  *     success = U_ZERO_ERROR;
 292  *     Formattable testArgs[] = {3L, &quot;MyDisk&quot;};
 293  *
 294  *     MessageFormat form(
 295  *         &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;, success );
 296  *
 297  *     UnicodeString string;
 298  *     FieldPosition fpos = 0;
 299  *     cout &lt;&lt; &quot;format: &quot; &lt;&lt; form.format(testArgs, 2, string, fpos, success ) &lt;&lt; endl;
 300  *
 301  *     // output, with different testArgs:
 302  *     // output: The disk &quot;MyDisk&quot; contains 0 file(s).
 303  *     // output: The disk &quot;MyDisk&quot; contains 1 file(s).
 304  *     // output: The disk &quot;MyDisk&quot; contains 1,273 file(s).
 305  *  \endcode
 306  *  &lt;/pre&gt;
 307  *
 308  *
 309  * &lt;p&gt;For messages that include plural forms, you can use a plural argument:
 310  * &lt;pre&gt;
 311  * \code
 312  *  success = U_ZERO_ERROR;
 313  *  MessageFormat msgFmt(
 314  *       &quot;{num_files, plural, &quot;
 315  *       &quot;=0{There are no files on disk \&quot;{disk_name}\&quot;.}&quot;
 316  *       &quot;=1{There is one file on disk \&quot;{disk_name}\&quot;.}&quot;
 317  *       &quot;other{There are # files on disk \&quot;{disk_name}\&quot;.}}&quot;,
 318  *      Locale(&quot;en&quot;),
 319  *      success);
 320  *  FieldPosition fpos = 0;
 321  *  Formattable testArgs[] = {0L, &quot;MyDisk&quot;};
 322  *  UnicodeString testArgsNames[] = {&quot;num_files&quot;, &quot;disk_name&quot;};
 323  *  UnicodeString result;
 324  *  cout &lt;&lt; msgFmt.format(testArgs, testArgsNames, 2, result, fpos, 0, success);
 325  *  testArgs[0] = 3L;
 326  *  cout &lt;&lt; msgFmt.format(testArgs, testArgsNames, 2, result, fpos, 0, success);
 327  * \endcode
 328  * &lt;em&gt;output&lt;/em&gt;:
 329  * There are no files on disk &quot;MyDisk&quot;.
 330  * There are 3 files on &quot;MyDisk&quot;.
 331  * &lt;/pre&gt;
 332  * See {@link PluralFormat} and {@link PluralRules} for details.
 333  *
 334  * &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
 335  *
 336  * &lt;p&gt;MessageFormats are not synchronized.
 337  * It is recommended to create separate format instances for each thread.
 338  * If multiple threads access a format concurrently, it must be synchronized
 339  * externally.
 340  *
 341  * @stable ICU 2.0
 342  */
 343 class U_I18N_API MessageFormat : public Format {
 344 public:
 345 #ifndef U_HIDE_OBSOLETE_API
 346     /**
 347      * Enum type for kMaxFormat.
 348      * @obsolete ICU 3.0.  The 10-argument limit was removed as of ICU 2.6,
 349      * rendering this enum type obsolete.
 350      */
 351     enum EFormatNumber {
 352         /**
 353          * The maximum number of arguments.
 354          * @obsolete ICU 3.0.  The 10-argument limit was removed as of ICU 2.6,
 355          * rendering this constant obsolete.
 356          */
 357         kMaxFormat = 10
 358     };
 359 #endif  /* U_HIDE_OBSOLETE_API */
 360 
 361     /**
 362      * Constructs a new MessageFormat using the given pattern and the
 363      * default locale.
 364      *
 365      * @param pattern   Pattern used to construct object.
 366      * @param status    Input/output error code.  If the
 367      *                  pattern cannot be parsed, set to failure code.
 368      * @stable ICU 2.0
 369      */
 370     MessageFormat(const UnicodeString&amp; pattern,
 371                   UErrorCode &amp;status);
 372 
 373     /**
 374      * Constructs a new MessageFormat using the given pattern and locale.
 375      * @param pattern   Pattern used to construct object.
 376      * @param newLocale The locale to use for formatting dates and numbers.
 377      * @param status    Input/output error code.  If the
 378      *                  pattern cannot be parsed, set to failure code.
 379      * @stable ICU 2.0
 380      */
 381     MessageFormat(const UnicodeString&amp; pattern,
 382                   const Locale&amp; newLocale,
 383                         UErrorCode&amp; status);
 384     /**
 385      * Constructs a new MessageFormat using the given pattern and locale.
 386      * @param pattern   Pattern used to construct object.
 387      * @param newLocale The locale to use for formatting dates and numbers.
 388      * @param parseError Struct to receive information on the position
 389      *                   of an error within the pattern.
 390      * @param status    Input/output error code.  If the
 391      *                  pattern cannot be parsed, set to failure code.
 392      * @stable ICU 2.0
 393      */
 394     MessageFormat(const UnicodeString&amp; pattern,
 395                   const Locale&amp; newLocale,
 396                   UParseError&amp; parseError,
 397                   UErrorCode&amp; status);
 398     /**
 399      * Constructs a new MessageFormat from an existing one.
 400      * @stable ICU 2.0
 401      */
 402     MessageFormat(const MessageFormat&amp;);
 403 
 404     /**
 405      * Assignment operator.
 406      * @stable ICU 2.0
 407      */
 408     const MessageFormat&amp; operator=(const MessageFormat&amp;);
 409 
 410     /**
 411      * Destructor.
 412      * @stable ICU 2.0
 413      */
 414     virtual ~MessageFormat();
 415 
 416     /**
 417      * Clones this Format object polymorphically.  The caller owns the
 418      * result and should delete it when done.
 419      * @stable ICU 2.0
 420      */
 421     virtual Format* clone(void) const;
 422 
 423     /**
 424      * Returns true if the given Format objects are semantically equal.
 425      * Objects of different subclasses are considered unequal.
 426      * @param other  the object to be compared with.
 427      * @return       true if the given Format objects are semantically equal.
 428      * @stable ICU 2.0
 429      */
 430     virtual UBool operator==(const Format&amp; other) const;
 431 
 432     /**
 433      * Sets the locale to be used for creating argument Format objects.
 434      * @param theLocale    the new locale value to be set.
 435      * @stable ICU 2.0
 436      */
 437     virtual void setLocale(const Locale&amp; theLocale);
 438 
 439     /**
 440      * Gets the locale used for creating argument Format objects.
 441      * format information.
 442      * @return    the locale of the object.
 443      * @stable ICU 2.0
 444      */
 445     virtual const Locale&amp; getLocale(void) const;
 446 
 447     /**
 448      * Applies the given pattern string to this message format.
 449      *
 450      * @param pattern   The pattern to be applied.
 451      * @param status    Input/output error code.  If the
 452      *                  pattern cannot be parsed, set to failure code.
 453      * @stable ICU 2.0
 454      */
 455     virtual void applyPattern(const UnicodeString&amp; pattern,
 456                               UErrorCode&amp; status);
 457     /**
 458      * Applies the given pattern string to this message format.
 459      *
 460      * @param pattern    The pattern to be applied.
 461      * @param parseError Struct to receive information on the position
 462      *                   of an error within the pattern.
 463      * @param status    Input/output error code.  If the
 464      *                  pattern cannot be parsed, set to failure code.
 465      * @stable ICU 2.0
 466      */
 467     virtual void applyPattern(const UnicodeString&amp; pattern,
 468                              UParseError&amp; parseError,
 469                              UErrorCode&amp; status);
 470 
 471     /**
 472      * Sets the UMessagePatternApostropheMode and the pattern used by this message format.
 473      * Parses the pattern and caches Format objects for simple argument types.
 474      * Patterns and their interpretation are specified in the
 475      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 476      * &lt;p&gt;
 477      * This method is best used only once on a given object to avoid confusion about the mode,
 478      * and after constructing the object with an empty pattern string to minimize overhead.
 479      *
 480      * @param pattern    The pattern to be applied.
 481      * @param aposMode   The new apostrophe mode.
 482      * @param parseError Struct to receive information on the position
 483      *                   of an error within the pattern.
 484      *                   Can be NULL.
 485      * @param status    Input/output error code.  If the
 486      *                  pattern cannot be parsed, set to failure code.
 487      * @stable ICU 4.8
 488      */
 489     virtual void applyPattern(const UnicodeString&amp; pattern,
 490                               UMessagePatternApostropheMode aposMode,
 491                               UParseError* parseError,
 492                               UErrorCode&amp; status);
 493 
 494     /**
 495      * @return this instance&#39;s UMessagePatternApostropheMode.
 496      * @stable ICU 4.8
 497      */
 498     UMessagePatternApostropheMode getApostropheMode() const {
 499         return msgPattern.getApostropheMode();
 500     }
 501 
 502     /**
 503      * Returns a pattern that can be used to recreate this object.
 504      *
 505      * @param appendTo  Output parameter to receive the pattern.
 506      *                  Result is appended to existing contents.
 507      * @return          Reference to &#39;appendTo&#39; parameter.
 508      * @stable ICU 2.0
 509      */
 510     virtual UnicodeString&amp; toPattern(UnicodeString&amp; appendTo) const;
 511 
 512     /**
 513      * Sets subformats.
 514      * See the class description about format numbering.
 515      * The caller should not delete the Format objects after this call.
 516      * &lt;EM&gt;The array formatsToAdopt is not itself adopted.&lt;/EM&gt; Its
 517      * ownership is retained by the caller. If the call fails because
 518      * memory cannot be allocated, then the formats will be deleted
 519      * by this method, and this object will remain unchanged.
 520      *
 521      * &lt;p&gt;If this format uses named arguments, the new formats are discarded
 522      * and this format remains unchanged.
 523      *
 524      * @stable ICU 2.0
 525      * @param formatsToAdopt    the format to be adopted.
 526      * @param count             the size of the array.
 527      */
 528     virtual void adoptFormats(Format** formatsToAdopt, int32_t count);
 529 
 530     /**
 531      * Sets subformats.
 532      * See the class description about format numbering.
 533      * Each item in the array is cloned into the internal array.
 534      * If the call fails because memory cannot be allocated, then this
 535      * object will remain unchanged.
 536      *
 537      * &lt;p&gt;If this format uses named arguments, the new formats are discarded
 538      * and this format remains unchanged.
 539      *
 540      * @stable ICU 2.0
 541      * @param newFormats the new format to be set.
 542      * @param cnt        the size of the array.
 543      */
 544     virtual void setFormats(const Format** newFormats, int32_t cnt);
 545 
 546 
 547     /**
 548      * Sets one subformat.
 549      * See the class description about format numbering.
 550      * The caller should not delete the Format object after this call.
 551      * If the number is over the number of formats already set,
 552      * the item will be deleted and ignored.
 553      *
 554      * &lt;p&gt;If this format uses named arguments, the new format is discarded
 555      * and this format remains unchanged.
 556      *
 557      * @stable ICU 2.0
 558      * @param formatNumber     index of the subformat.
 559      * @param formatToAdopt    the format to be adopted.
 560      */
 561     virtual void adoptFormat(int32_t formatNumber, Format* formatToAdopt);
 562 
 563     /**
 564      * Sets one subformat.
 565      * See the class description about format numbering.
 566      * If the number is over the number of formats already set,
 567      * the item will be ignored.
 568      * @param formatNumber     index of the subformat.
 569      * @param format    the format to be set.
 570      * @stable ICU 2.0
 571      */
 572     virtual void setFormat(int32_t formatNumber, const Format&amp; format);
 573 
 574     /**
 575      * Gets format names. This function returns formatNames in StringEnumerations
 576      * which can be used with getFormat() and setFormat() to export formattable
 577      * array from current MessageFormat to another.  It is the caller&#39;s responsibility
 578      * to delete the returned formatNames.
 579      * @param status  output param set to success/failure code.
 580      * @stable ICU 4.0
 581      */
 582     virtual StringEnumeration* getFormatNames(UErrorCode&amp; status);
 583 
 584     /**
 585      * Gets subformat pointer for given format name.
 586      * This function supports both named and numbered
 587      * arguments. If numbered, the formatName is the
 588      * corresponding UnicodeStrings (e.g. &quot;0&quot;, &quot;1&quot;, &quot;2&quot;...).
 589      * The returned Format object should not be deleted by the caller,
 590      * nor should the ponter of other object .  The pointer and its
 591      * contents remain valid only until the next call to any method
 592      * of this class is made with this object.
 593      * @param formatName the name or number specifying a format
 594      * @param status  output param set to success/failure code.
 595      * @stable ICU 4.0
 596      */
 597     virtual Format* getFormat(const UnicodeString&amp; formatName, UErrorCode&amp; status);
 598 
 599     /**
 600      * Sets one subformat for given format name.
 601      * See the class description about format name.
 602      * This function supports both named and numbered
 603      * arguments-- if numbered, the formatName is the
 604      * corresponding UnicodeStrings (e.g. &quot;0&quot;, &quot;1&quot;, &quot;2&quot;...).
 605      * If there is no matched formatName or wrong type,
 606      * the item will be ignored.
 607      * @param formatName  Name of the subformat.
 608      * @param format      the format to be set.
 609      * @param status  output param set to success/failure code.
 610      * @stable ICU 4.0
 611      */
 612     virtual void setFormat(const UnicodeString&amp; formatName, const Format&amp; format, UErrorCode&amp; status);
 613 
 614     /**
 615      * Sets one subformat for given format name.
 616      * See the class description about format name.
 617      * This function supports both named and numbered
 618      * arguments-- if numbered, the formatName is the
 619      * corresponding UnicodeStrings (e.g. &quot;0&quot;, &quot;1&quot;, &quot;2&quot;...).
 620      * If there is no matched formatName or wrong type,
 621      * the item will be ignored.
 622      * The caller should not delete the Format object after this call.
 623      * @param formatName  Name of the subformat.
 624      * @param formatToAdopt  Format to be adopted.
 625      * @param status      output param set to success/failure code.
 626      * @stable ICU 4.0
 627      */
 628     virtual void adoptFormat(const UnicodeString&amp; formatName, Format* formatToAdopt, UErrorCode&amp; status);
 629 
 630     /**
 631      * Gets an array of subformats of this object.  The returned array
 632      * should not be deleted by the caller, nor should the pointers
 633      * within the array.  The array and its contents remain valid only
 634      * until the next call to this format. See the class description
 635      * about format numbering.
 636      *
 637      * @param count output parameter to receive the size of the array
 638      * @return an array of count Format* objects, or NULL if out of
 639      * memory.  Any or all of the array elements may be NULL.
 640      * @stable ICU 2.0
 641      */
 642     virtual const Format** getFormats(int32_t&amp; count) const;
 643 
 644 
 645     using Format::format;
 646 
 647     /**
 648      * Formats the given array of arguments into a user-readable string.
 649      * Does not take ownership of the Formattable* array or its contents.
 650      *
 651      * &lt;p&gt;If this format uses named arguments, appendTo is unchanged and
 652      * status is set to U_ILLEGAL_ARGUMENT_ERROR.
 653      *
 654      * @param source    An array of objects to be formatted.
 655      * @param count     The number of elements of &#39;source&#39;.
 656      * @param appendTo  Output parameter to receive result.
 657      *                  Result is appended to existing contents.
 658      * @param ignore    Not used; inherited from base class API.
 659      * @param status    Input/output error code.  If the
 660      *                  pattern cannot be parsed, set to failure code.
 661      * @return          Reference to &#39;appendTo&#39; parameter.
 662      * @stable ICU 2.0
 663      */
 664     UnicodeString&amp; format(const Formattable* source,
 665                           int32_t count,
 666                           UnicodeString&amp; appendTo,
 667                           FieldPosition&amp; ignore,
 668                           UErrorCode&amp; status) const;
 669 
 670     /**
 671      * Formats the given array of arguments into a user-readable string
 672      * using the given pattern.
 673      *
 674      * &lt;p&gt;If this format uses named arguments, appendTo is unchanged and
 675      * status is set to U_ILLEGAL_ARGUMENT_ERROR.
 676      *
 677      * @param pattern   The pattern.
 678      * @param arguments An array of objects to be formatted.
 679      * @param count     The number of elements of &#39;source&#39;.
 680      * @param appendTo  Output parameter to receive result.
 681      *                  Result is appended to existing contents.
 682      * @param status    Input/output error code.  If the
 683      *                  pattern cannot be parsed, set to failure code.
 684      * @return          Reference to &#39;appendTo&#39; parameter.
 685      * @stable ICU 2.0
 686      */
 687     static UnicodeString&amp; format(const UnicodeString&amp; pattern,
 688                                  const Formattable* arguments,
 689                                  int32_t count,
 690                                  UnicodeString&amp; appendTo,
 691                                  UErrorCode&amp; status);
 692 
 693     /**
 694      * Formats the given array of arguments into a user-readable
 695      * string.  The array must be stored within a single Formattable
 696      * object of type kArray. If the Formattable object type is not of
 697      * type kArray, then returns a failing UErrorCode.
 698      *
 699      * &lt;p&gt;If this format uses named arguments, appendTo is unchanged and
 700      * status is set to U_ILLEGAL_ARGUMENT_ERROR.
 701      *
 702      * @param obj       A Formattable of type kArray containing
 703      *                  arguments to be formatted.
 704      * @param appendTo  Output parameter to receive result.
 705      *                  Result is appended to existing contents.
 706      * @param pos       On input: an alignment field, if desired.
 707      *                  On output: the offsets of the alignment field.
 708      * @param status    Input/output error code.  If the
 709      *                  pattern cannot be parsed, set to failure code.
 710      * @return          Reference to &#39;appendTo&#39; parameter.
 711      * @stable ICU 2.0
 712      */
 713     virtual UnicodeString&amp; format(const Formattable&amp; obj,
 714                                   UnicodeString&amp; appendTo,
 715                                   FieldPosition&amp; pos,
 716                                   UErrorCode&amp; status) const;
 717 
 718     /**
 719      * Formats the given array of arguments into a user-defined argument name
 720      * array. This function supports both named and numbered
 721      * arguments-- if numbered, the formatName is the
 722      * corresponding UnicodeStrings (e.g. &quot;0&quot;, &quot;1&quot;, &quot;2&quot;...).
 723      *
 724      * @param argumentNames argument name array
 725      * @param arguments An array of objects to be formatted.
 726      * @param count     The number of elements of &#39;argumentNames&#39; and
 727      *                  arguments.  The number of argumentNames and arguments
 728      *                  must be the same.
 729      * @param appendTo  Output parameter to receive result.
 730      *                  Result is appended to existing contents.
 731      * @param status    Input/output error code.  If the
 732      *                  pattern cannot be parsed, set to failure code.
 733      * @return          Reference to &#39;appendTo&#39; parameter.
 734      * @stable ICU 4.0
 735      */
 736     UnicodeString&amp; format(const UnicodeString* argumentNames,
 737                           const Formattable* arguments,
 738                           int32_t count,
 739                           UnicodeString&amp; appendTo,
 740                           UErrorCode&amp; status) const;
 741     /**
 742      * Parses the given string into an array of output arguments.
 743      *
 744      * @param source    String to be parsed.
 745      * @param pos       On input, starting position for parse. On output,
 746      *                  final position after parse.  Unchanged if parse
 747      *                  fails.
 748      * @param count     Output parameter to receive the number of arguments
 749      *                  parsed.
 750      * @return an array of parsed arguments.  The caller owns both
 751      * the array and its contents.
 752      * @stable ICU 2.0
 753      */
 754     virtual Formattable* parse(const UnicodeString&amp; source,
 755                                ParsePosition&amp; pos,
 756                                int32_t&amp; count) const;
 757 
 758     /**
 759      * Parses the given string into an array of output arguments.
 760      *
 761      * &lt;p&gt;If this format uses named arguments, status is set to
 762      * U_ARGUMENT_TYPE_MISMATCH.
 763      *
 764      * @param source    String to be parsed.
 765      * @param count     Output param to receive size of returned array.
 766      * @param status    Input/output error code.  If the
 767      *                  pattern cannot be parsed, set to failure code.
 768      * @return an array of parsed arguments.  The caller owns both
 769      * the array and its contents. Returns NULL if status is not U_ZERO_ERROR.
 770      *
 771      * @stable ICU 2.0
 772      */
 773     virtual Formattable* parse(const UnicodeString&amp; source,
 774                                int32_t&amp; count,
 775                                UErrorCode&amp; status) const;
 776 
 777     /**
 778      * Parses the given string into an array of output arguments
 779      * stored within a single Formattable of type kArray.
 780      *
 781      * @param source    The string to be parsed into an object.
 782      * @param result    Formattable to be set to the parse result.
 783      *                  If parse fails, return contents are undefined.
 784      * @param pos       On input, starting position for parse. On output,
 785      *                  final position after parse.  Unchanged if parse
 786      *                  fails.
 787      * @stable ICU 2.0
 788      */
 789     virtual void parseObject(const UnicodeString&amp; source,
 790                              Formattable&amp; result,
 791                              ParsePosition&amp; pos) const;
 792 
 793     /**
 794      * Convert an &#39;apostrophe-friendly&#39; pattern into a standard
 795      * pattern.  Standard patterns treat all apostrophes as
 796      * quotes, which is problematic in some languages, e.g.
 797      * French, where apostrophe is commonly used.  This utility
 798      * assumes that only an unpaired apostrophe immediately before
 799      * a brace is a true quote.  Other unpaired apostrophes are paired,
 800      * and the resulting standard pattern string is returned.
 801      *
 802      * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt; it is not guaranteed that the returned pattern
 803      * is indeed a valid pattern.  The only effect is to convert
 804      * between patterns having different quoting semantics.
 805      *
 806      * @param pattern the &#39;apostrophe-friendly&#39; patttern to convert
 807      * @param status    Input/output error code.  If the pattern
 808      *                  cannot be parsed, the failure code is set.
 809      * @return the standard equivalent of the original pattern
 810      * @stable ICU 3.4
 811      */
 812     static UnicodeString autoQuoteApostrophe(const UnicodeString&amp; pattern,
 813         UErrorCode&amp; status);
 814 
 815 
 816     /**
 817      * Returns true if this MessageFormat uses named arguments,
 818      * and false otherwise.  See class description.
 819      *
 820      * @return true if named arguments are used.
 821      * @stable ICU 4.0
 822      */
 823     UBool usesNamedArguments() const;
 824 
 825 
 826 #ifndef U_HIDE_INTERNAL_API
 827     /**
 828      * This API is for ICU internal use only.
 829      * Please do not use it.
 830      *
 831      * Returns argument types count in the parsed pattern.
 832      * Used to distinguish pattern &quot;{0} d&quot; and &quot;d&quot;.
 833      *
 834      * @return           The number of formattable types in the pattern
 835      * @internal
 836      */
 837     int32_t getArgTypeCount() const;
 838 #endif  /* U_HIDE_INTERNAL_API */
 839 
 840     /**
 841      * Returns a unique class ID POLYMORPHICALLY.  Pure virtual override.
 842      * This method is to implement a simple version of RTTI, since not all
 843      * C++ compilers support genuine RTTI.  Polymorphic operator==() and
 844      * clone() methods call this method.
 845      *
 846      * @return          The class ID for this object. All objects of a
 847      *                  given class have the same class ID.  Objects of
 848      *                  other classes have different class IDs.
 849      * @stable ICU 2.0
 850      */
 851     virtual UClassID getDynamicClassID(void) const;
 852 
 853     /**
 854      * Return the class ID for this class.  This is useful only for
 855      * comparing to a return value from getDynamicClassID().  For example:
 856      * &lt;pre&gt;
 857      * .   Base* polymorphic_pointer = createPolymorphicObject();
 858      * .   if (polymorphic_pointer-&gt;getDynamicClassID() ==
 859      * .      Derived::getStaticClassID()) ...
 860      * &lt;/pre&gt;
 861      * @return          The class ID for all objects of this class.
 862      * @stable ICU 2.0
 863      */
 864     static UClassID U_EXPORT2 getStaticClassID(void);
 865 
 866 #ifndef U_HIDE_INTERNAL_API
 867     /**
 868      * Compares two Format objects. This is used for constructing the hash
 869      * tables.
 870      *
 871      * @param left pointer to a Format object. Must not be NULL.
 872      * @param right pointer to a Format object. Must not be NULL.
 873      *
 874      * @return whether the two objects are the same
 875      * @internal
 876      */
 877     static UBool equalFormats(const void* left, const void* right);
 878 #endif  /* U_HIDE_INTERNAL_API */
 879 
 880 private:
 881 
 882     Locale              fLocale;
 883     MessagePattern      msgPattern;
 884     Format**            formatAliases; // see getFormats
 885     int32_t             formatAliasesCapacity;
 886 
 887     MessageFormat(); // default constructor not implemented
 888 
 889      /**
 890       * This provider helps defer instantiation of a PluralRules object
 891       * until we actually need to select a keyword.
 892       * For example, if the number matches an explicit-value selector like &quot;=1&quot;
 893       * we do not need any PluralRules.
 894       */
 895     class U_I18N_API PluralSelectorProvider : public PluralFormat::PluralSelector {
 896     public:
 897         PluralSelectorProvider(const MessageFormat &amp;mf, UPluralType type);
 898         virtual ~PluralSelectorProvider();
 899         virtual UnicodeString select(void *ctx, double number, UErrorCode&amp; ec) const;
 900 
 901         void reset();
 902     private:
 903         const MessageFormat &amp;msgFormat;
 904         PluralRules* rules;
 905         UPluralType type;
 906     };
 907 
 908     /**
 909      * A MessageFormat formats an array of arguments.  Each argument
 910      * has an expected type, based on the pattern.  For example, if
 911      * the pattern contains the subformat &quot;{3,number,integer}&quot;, then
 912      * we expect argument 3 to have type Formattable::kLong.  This
 913      * array needs to grow dynamically if the MessageFormat is
 914      * modified.
 915      */
 916     Formattable::Type* argTypes;
 917     int32_t            argTypeCount;
 918     int32_t            argTypeCapacity;
 919 
 920     /**
 921      * TRUE if there are different argTypes for the same argument.
 922      * This only matters when the MessageFormat is used in the plain C (umsg_xxx) API
 923      * where the pattern argTypes determine how the va_arg list is read.
 924      */
 925     UBool hasArgTypeConflicts;
 926 
 927     // Variable-size array management
 928     UBool allocateArgTypes(int32_t capacity, UErrorCode&amp; status);
 929 
 930     /**
 931      * Default Format objects used when no format is specified and a
 932      * numeric or date argument is formatted.  These are volatile
 933      * cache objects maintained only for performance.  They do not
 934      * participate in operator=(), copy constructor(), nor
 935      * operator==().
 936      */
 937     NumberFormat* defaultNumberFormat;
 938     DateFormat*   defaultDateFormat;
 939 
 940     UHashtable* cachedFormatters;
 941     UHashtable* customFormatArgStarts;
 942 
 943     PluralSelectorProvider pluralProvider;
 944     PluralSelectorProvider ordinalProvider;
 945 
 946     /**
 947      * Method to retrieve default formats (or NULL on failure).
 948      * These are semantically const, but may modify *this.
 949      */
 950     const NumberFormat* getDefaultNumberFormat(UErrorCode&amp;) const;
 951     const DateFormat*   getDefaultDateFormat(UErrorCode&amp;) const;
 952 
 953     /**
 954      * Finds the word s, in the keyword list and returns the located index.
 955      * @param s the keyword to be searched for.
 956      * @param list the list of keywords to be searched with.
 957      * @return the index of the list which matches the keyword s.
 958      */
 959     static int32_t findKeyword( const UnicodeString&amp; s,
 960                                 const char16_t * const *list);
 961 
 962     /**
 963      * Thin wrapper around the format(... AppendableWrapper ...) variant.
 964      * Wraps the destination UnicodeString into an AppendableWrapper and
 965      * supplies default values for some other parameters.
 966      */
 967     UnicodeString&amp; format(const Formattable* arguments,
 968                           const UnicodeString *argumentNames,
 969                           int32_t cnt,
 970                           UnicodeString&amp; appendTo,
 971                           FieldPosition* pos,
 972                           UErrorCode&amp; status) const;
 973 
 974     /**
 975      * Formats the arguments and writes the result into the
 976      * AppendableWrapper, updates the field position.
 977      *
 978      * @param msgStart      Index to msgPattern part to start formatting from.
 979      * @param plNumber      NULL except when formatting a plural argument sub-message
 980      *                      where a &#39;#&#39; is replaced by the format string for this number.
 981      * @param arguments     The formattable objects array. (Must not be NULL.)
 982      * @param argumentNames NULL if numbered values are used. Otherwise the same
 983      *                      length as &quot;arguments&quot;, and each entry is the name of the
 984      *                      corresponding argument in &quot;arguments&quot;.
 985      * @param cnt           The length of arguments (and of argumentNames if that is not NULL).
 986      * @param appendTo      Output parameter to receive the result.
 987      *                      The result string is appended to existing contents.
 988      * @param pos           Field position status.
 989      * @param success       The error code status.
 990      */
 991     void format(int32_t msgStart,
 992                 const void *plNumber,
 993                 const Formattable* arguments,
 994                 const UnicodeString *argumentNames,
 995                 int32_t cnt,
 996                 AppendableWrapper&amp; appendTo,
 997                 FieldPosition* pos,
 998                 UErrorCode&amp; success) const;
 999 
1000     UnicodeString getArgName(int32_t partIndex);
1001 
1002     void setArgStartFormat(int32_t argStart, Format* formatter, UErrorCode&amp; status);
1003 
1004     void setCustomArgStartFormat(int32_t argStart, Format* formatter, UErrorCode&amp; status);
1005 
1006     int32_t nextTopLevelArgStart(int32_t partIndex) const;
1007 
1008     UBool argNameMatches(int32_t partIndex, const UnicodeString&amp; argName, int32_t argNumber);
1009 
1010     void cacheExplicitFormats(UErrorCode&amp; status);
1011 
1012     int32_t skipLeadingSpaces(UnicodeString&amp; style);
1013 
1014     Format* createAppropriateFormat(UnicodeString&amp; type,
1015                                     UnicodeString&amp; style,
1016                                     Formattable::Type&amp; formattableType,
1017                                     UParseError&amp; parseError,
1018                                     UErrorCode&amp; ec);
1019 
1020     const Formattable* getArgFromListByName(const Formattable* arguments,
1021                                             const UnicodeString *argumentNames,
1022                                             int32_t cnt, UnicodeString&amp; name) const;
1023 
1024     Formattable* parse(int32_t msgStart,
1025                        const UnicodeString&amp; source,
1026                        ParsePosition&amp; pos,
1027                        int32_t&amp; count,
1028                        UErrorCode&amp; ec) const;
1029 
1030     FieldPosition* updateMetaData(AppendableWrapper&amp; dest, int32_t prevLength,
1031                                   FieldPosition* fp, const Formattable* argId) const;
1032 
1033     /**
1034      * Finds the &quot;other&quot; sub-message.
1035      * @param partIndex the index of the first PluralFormat argument style part.
1036      * @return the &quot;other&quot; sub-message start part index.
1037      */
1038     int32_t findOtherSubMessage(int32_t partIndex) const;
1039 
1040     /**
1041      * Returns the ARG_START index of the first occurrence of the plural number in a sub-message.
1042      * Returns -1 if it is a REPLACE_NUMBER.
1043      * Returns 0 if there is neither.
1044      */
1045     int32_t findFirstPluralNumberArg(int32_t msgStart, const UnicodeString &amp;argName) const;
1046 
1047     Format* getCachedFormatter(int32_t argumentNumber) const;
1048 
1049     UnicodeString getLiteralStringUntilNextArgument(int32_t from) const;
1050 
1051     void copyObjects(const MessageFormat&amp; that, UErrorCode&amp; ec);
1052 
1053     void formatComplexSubMessage(int32_t msgStart,
1054                                  const void *plNumber,
1055                                  const Formattable* arguments,
1056                                  const UnicodeString *argumentNames,
1057                                  int32_t cnt,
1058                                  AppendableWrapper&amp; appendTo,
1059                                  UErrorCode&amp; success) const;
1060 
1061     /**
1062      * Convenience method that ought to be in NumberFormat
1063      */
1064     NumberFormat* createIntegerFormat(const Locale&amp; locale, UErrorCode&amp; status) const;
1065 
1066     /**
1067      * Returns array of argument types in the parsed pattern
1068      * for use in C API.  Only for the use of umsg_vformat().  Not
1069      * for public consumption.
1070      * @param listCount  Output parameter to receive the size of array
1071      * @return           The array of formattable types in the pattern
1072      */
1073     const Formattable::Type* getArgTypeList(int32_t&amp; listCount) const {
1074         listCount = argTypeCount;
1075         return argTypes;
1076     }
1077 
1078     /**
1079      * Resets the internal MessagePattern, and other associated caches.
1080      */
1081     void resetPattern();
1082 
1083     /**
1084      * A DummyFormatter that we use solely to store a NULL value. UHash does
1085      * not support storing NULL values.
1086      */
1087     class U_I18N_API DummyFormat : public Format {
1088     public:
1089         virtual UBool operator==(const Format&amp;) const;
1090         virtual Format* clone() const;
1091         virtual UnicodeString&amp; format(const Formattable&amp; obj,
1092                               UnicodeString&amp; appendTo,
1093                               UErrorCode&amp; status) const;
1094         virtual UnicodeString&amp; format(const Formattable&amp;,
1095                                       UnicodeString&amp; appendTo,
1096                                       FieldPosition&amp;,
1097                                       UErrorCode&amp; status) const;
1098         virtual UnicodeString&amp; format(const Formattable&amp; obj,
1099                                       UnicodeString&amp; appendTo,
1100                                       FieldPositionIterator* posIter,
1101                                       UErrorCode&amp; status) const;
1102         virtual void parseObject(const UnicodeString&amp;,
1103                                  Formattable&amp;,
1104                                  ParsePosition&amp;) const;
1105     };
1106 
1107     friend class MessageFormatAdapter; // getFormatTypeList() access
1108 };
1109 
1110 U_NAMESPACE_END
1111 
1112 #endif /* #if !UCONFIG_NO_FORMATTING */
1113 
1114 #endif // _MSGFMT
1115 //eof
    </pre>
  </body>
</html>