<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbi_cache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="rbbi.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbbi_cache.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbi_cache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 57             fPositionInCache = -1;
 58             return FALSE;
 59         }
 60         r = fBreaks.elementAti(fPositionInCache);
 61         U_ASSERT(r &gt; fromPos);
 62         *result = r;
 63         *statusIndex = fOtherRuleStatusIndex;
 64         return TRUE;
 65     }
 66 
 67     // Random indexing. Linear search for the boundary following the given position.
 68 
 69     for (fPositionInCache = 0; fPositionInCache &lt; fBreaks.size(); ++fPositionInCache) {
 70         r= fBreaks.elementAti(fPositionInCache);
 71         if (r &gt; fromPos) {
 72             *result = r;
 73             *statusIndex = fOtherRuleStatusIndex;
 74             return TRUE;
 75         }
 76     }
<span class="line-modified"> 77     U_ASSERT(FALSE);</span>
<span class="line-removed"> 78     fPositionInCache = -1;</span>
<span class="line-removed"> 79     return FALSE;</span>
 80 }
 81 
 82 
 83 UBool RuleBasedBreakIterator::DictionaryCache::preceding(int32_t fromPos, int32_t *result, int32_t *statusIndex) {
 84     if (fromPos &lt;= fStart || fromPos &gt; fLimit) {
 85         fPositionInCache = -1;
 86         return FALSE;
 87     }
 88 
 89     if (fromPos == fLimit) {
 90         fPositionInCache = fBreaks.size() - 1;
 91         if (fPositionInCache &gt;= 0) {
 92             U_ASSERT(fBreaks.elementAti(fPositionInCache) == fromPos);
 93         }
 94     }
 95 
 96     int32_t r;
 97     if (fPositionInCache &gt; 0 &amp;&amp; fPositionInCache &lt; fBreaks.size() &amp;&amp; fBreaks.elementAti(fPositionInCache) == fromPos) {
 98         --fPositionInCache;
 99         r = fBreaks.elementAti(fPositionInCache);
100         U_ASSERT(r &lt; fromPos);
101         *result = r;
102         *statusIndex = ( r== fStart) ? fFirstRuleStatusIndex : fOtherRuleStatusIndex;
103         return TRUE;
104     }
105 
106     if (fPositionInCache == 0) {
107         fPositionInCache = -1;
108         return FALSE;
109     }
110 
111     for (fPositionInCache = fBreaks.size()-1; fPositionInCache &gt;= 0; --fPositionInCache) {
112         r = fBreaks.elementAti(fPositionInCache);
113         if (r &lt; fromPos) {
114             *result = r;
115             *statusIndex = ( r == fStart) ? fFirstRuleStatusIndex : fOtherRuleStatusIndex;
116             return TRUE;
117         }
118     }
<span class="line-modified">119     U_ASSERT(FALSE);</span>
<span class="line-removed">120     fPositionInCache = -1;</span>
<span class="line-removed">121     return FALSE;</span>
122 }
123 
124 void RuleBasedBreakIterator::DictionaryCache::populateDictionary(int32_t startPos, int32_t endPos,
125                                        int32_t firstRuleStatus, int32_t otherRuleStatus) {
126     if ((endPos - startPos) &lt;= 1) {
127         return;
128     }
129 
130     reset();
131     fFirstRuleStatusIndex = firstRuleStatus;
132     fOtherRuleStatusIndex = otherRuleStatus;
133 
134     int32_t rangeStart = startPos;
135     int32_t rangeEnd = endPos;
136 
137     uint16_t    category;
138     int32_t     current;
139     UErrorCode  status = U_ZERO_ERROR;
140     int32_t     foundBreakCount = 0;
141     UText      *text = &amp;fBI-&gt;fText;
</pre>
<hr />
<pre>
371                     // Four being the length of the longest potential code point, a supplementary in UTF-8
372                     utext_setNativeIndex(&amp;fBI-&gt;fText, aBoundary);
373                     if (backupPos == utext_getPreviousNativeIndex(&amp;fBI-&gt;fText)) {
374                         // The initial handleNext() only advanced by a single code point. Go again.
375                         aBoundary = fBI-&gt;handleNext();   // Safe rules identify safe pairs.
376                     }
377                 }
378                 ruleStatusIndex = fBI-&gt;fRuleStatusIndex;
379             }
380         }
381         reset(aBoundary, ruleStatusIndex);        // Reset cache to hold aBoundary as a single starting point.
382     }
383 
384     // Fill in boundaries between existing cache content and the new requested position.
385 
386     if (fBoundaries[fEndBufIdx] &lt; position) {
387         // The last position in the cache precedes the requested position.
388         // Add following position(s) to the cache.
389         while (fBoundaries[fEndBufIdx] &lt; position) {
390             if (!populateFollowing()) {
<span class="line-modified">391                 U_ASSERT(false);</span>
<span class="line-removed">392                 return false;</span>
393             }
394         }
395         fBufIdx = fEndBufIdx;                      // Set iterator position to the end of the buffer.
396         fTextIdx = fBoundaries[fBufIdx];           // Required because populateFollowing may add extra boundaries.
397         while (fTextIdx &gt; position) {              // Move backwards to a position at or preceding the requested pos.
398             previous(status);
399         }
400         return true;
401     }
402 
403     if (fBoundaries[fStartBufIdx] &gt; position) {
404         // The first position in the cache is beyond the requested position.
405         // back up more until we get a boundary &lt;= the requested position.
406         while (fBoundaries[fStartBufIdx] &gt; position) {
407             populatePreceding(status);
408         }
409         fBufIdx = fStartBufIdx;                    // Set iterator position to the start of the buffer.
410         fTextIdx = fBoundaries[fBufIdx];           // Required because populatePreceding may add extra boundaries.
411         while (fTextIdx &lt; position) {              // Move forwards to a position at or following the requested pos.
412             next();
</pre>
<hr />
<pre>
586         if (!addPreceding(position, positionStatusIdx, RetainCachePosition)) {
587             // No space in circular buffer to hold a new preceding result while
588             // also retaining the current cache (iteration) position.
589             // Bailing out is safe; the cache will refill again if needed.
590             break;
591         }
592     }
593 
594     return success;
595 }
596 
597 
598 void RuleBasedBreakIterator::BreakCache::addFollowing(int32_t position, int32_t ruleStatusIdx, UpdatePositionValues update) {
599     U_ASSERT(position &gt; fBoundaries[fEndBufIdx]);
600     U_ASSERT(ruleStatusIdx &lt;= UINT16_MAX);
601     int32_t nextIdx = modChunkSize(fEndBufIdx + 1);
602     if (nextIdx == fStartBufIdx) {
603         fStartBufIdx = modChunkSize(fStartBufIdx + 6);    // TODO: experiment. Probably revert to 1.
604     }
605     fBoundaries[nextIdx] = position;
<span class="line-modified">606     fStatuses[nextIdx] = ruleStatusIdx;</span>
607     fEndBufIdx = nextIdx;
608     if (update == UpdateCachePosition) {
609         // Set current position to the newly added boundary.
610         fBufIdx = nextIdx;
611         fTextIdx = position;
612     } else {
613         // Retaining the original cache position.
614         // Check if the added boundary wraps around the buffer, and would over-write the original position.
615         // It&#39;s the responsibility of callers of this function to not add too many.
616         U_ASSERT(nextIdx != fBufIdx);
617     }
618 }
619 
620 bool RuleBasedBreakIterator::BreakCache::addPreceding(int32_t position, int32_t ruleStatusIdx, UpdatePositionValues update) {
621     U_ASSERT(position &lt; fBoundaries[fStartBufIdx]);
622     U_ASSERT(ruleStatusIdx &lt;= UINT16_MAX);
623     int32_t nextIdx = modChunkSize(fStartBufIdx - 1);
624     if (nextIdx == fEndBufIdx) {
625         if (fBufIdx == fEndBufIdx &amp;&amp; update == RetainCachePosition) {
626             // Failure. The insertion of the new boundary would claim the buffer position that is the
627             // current iteration position. And we also want to retain the current iteration position.
628             // (The buffer is already completely full of entries that precede the iteration position.)
629             return false;
630         }
631         fEndBufIdx = modChunkSize(fEndBufIdx - 1);
632     }
633     fBoundaries[nextIdx] = position;
<span class="line-modified">634     fStatuses[nextIdx] = ruleStatusIdx;</span>
635     fStartBufIdx = nextIdx;
636     if (update == UpdateCachePosition) {
637         fBufIdx = nextIdx;
638         fTextIdx = position;
639     }
640     return true;
641 }
642 
643 
644 void RuleBasedBreakIterator::BreakCache::dumpCache() {
645 #ifdef RBBI_DEBUG
646     RBBIDebugPrintf(&quot;fTextIdx:%d   fBufIdx:%d\n&quot;, fTextIdx, fBufIdx);
647     for (int32_t i=fStartBufIdx; ; i=modChunkSize(i+1)) {
648         RBBIDebugPrintf(&quot;%d  %d\n&quot;, i, fBoundaries[i]);
649         if (i == fEndBufIdx) {
650             break;
651         }
652     }
653 #endif
654 }
</pre>
</td>
<td>
<hr />
<pre>
 57             fPositionInCache = -1;
 58             return FALSE;
 59         }
 60         r = fBreaks.elementAti(fPositionInCache);
 61         U_ASSERT(r &gt; fromPos);
 62         *result = r;
 63         *statusIndex = fOtherRuleStatusIndex;
 64         return TRUE;
 65     }
 66 
 67     // Random indexing. Linear search for the boundary following the given position.
 68 
 69     for (fPositionInCache = 0; fPositionInCache &lt; fBreaks.size(); ++fPositionInCache) {
 70         r= fBreaks.elementAti(fPositionInCache);
 71         if (r &gt; fromPos) {
 72             *result = r;
 73             *statusIndex = fOtherRuleStatusIndex;
 74             return TRUE;
 75         }
 76     }
<span class="line-modified"> 77     UPRV_UNREACHABLE;</span>


 78 }
 79 
 80 
 81 UBool RuleBasedBreakIterator::DictionaryCache::preceding(int32_t fromPos, int32_t *result, int32_t *statusIndex) {
 82     if (fromPos &lt;= fStart || fromPos &gt; fLimit) {
 83         fPositionInCache = -1;
 84         return FALSE;
 85     }
 86 
 87     if (fromPos == fLimit) {
 88         fPositionInCache = fBreaks.size() - 1;
 89         if (fPositionInCache &gt;= 0) {
 90             U_ASSERT(fBreaks.elementAti(fPositionInCache) == fromPos);
 91         }
 92     }
 93 
 94     int32_t r;
 95     if (fPositionInCache &gt; 0 &amp;&amp; fPositionInCache &lt; fBreaks.size() &amp;&amp; fBreaks.elementAti(fPositionInCache) == fromPos) {
 96         --fPositionInCache;
 97         r = fBreaks.elementAti(fPositionInCache);
 98         U_ASSERT(r &lt; fromPos);
 99         *result = r;
100         *statusIndex = ( r== fStart) ? fFirstRuleStatusIndex : fOtherRuleStatusIndex;
101         return TRUE;
102     }
103 
104     if (fPositionInCache == 0) {
105         fPositionInCache = -1;
106         return FALSE;
107     }
108 
109     for (fPositionInCache = fBreaks.size()-1; fPositionInCache &gt;= 0; --fPositionInCache) {
110         r = fBreaks.elementAti(fPositionInCache);
111         if (r &lt; fromPos) {
112             *result = r;
113             *statusIndex = ( r == fStart) ? fFirstRuleStatusIndex : fOtherRuleStatusIndex;
114             return TRUE;
115         }
116     }
<span class="line-modified">117     UPRV_UNREACHABLE;</span>


118 }
119 
120 void RuleBasedBreakIterator::DictionaryCache::populateDictionary(int32_t startPos, int32_t endPos,
121                                        int32_t firstRuleStatus, int32_t otherRuleStatus) {
122     if ((endPos - startPos) &lt;= 1) {
123         return;
124     }
125 
126     reset();
127     fFirstRuleStatusIndex = firstRuleStatus;
128     fOtherRuleStatusIndex = otherRuleStatus;
129 
130     int32_t rangeStart = startPos;
131     int32_t rangeEnd = endPos;
132 
133     uint16_t    category;
134     int32_t     current;
135     UErrorCode  status = U_ZERO_ERROR;
136     int32_t     foundBreakCount = 0;
137     UText      *text = &amp;fBI-&gt;fText;
</pre>
<hr />
<pre>
367                     // Four being the length of the longest potential code point, a supplementary in UTF-8
368                     utext_setNativeIndex(&amp;fBI-&gt;fText, aBoundary);
369                     if (backupPos == utext_getPreviousNativeIndex(&amp;fBI-&gt;fText)) {
370                         // The initial handleNext() only advanced by a single code point. Go again.
371                         aBoundary = fBI-&gt;handleNext();   // Safe rules identify safe pairs.
372                     }
373                 }
374                 ruleStatusIndex = fBI-&gt;fRuleStatusIndex;
375             }
376         }
377         reset(aBoundary, ruleStatusIndex);        // Reset cache to hold aBoundary as a single starting point.
378     }
379 
380     // Fill in boundaries between existing cache content and the new requested position.
381 
382     if (fBoundaries[fEndBufIdx] &lt; position) {
383         // The last position in the cache precedes the requested position.
384         // Add following position(s) to the cache.
385         while (fBoundaries[fEndBufIdx] &lt; position) {
386             if (!populateFollowing()) {
<span class="line-modified">387                 UPRV_UNREACHABLE;</span>

388             }
389         }
390         fBufIdx = fEndBufIdx;                      // Set iterator position to the end of the buffer.
391         fTextIdx = fBoundaries[fBufIdx];           // Required because populateFollowing may add extra boundaries.
392         while (fTextIdx &gt; position) {              // Move backwards to a position at or preceding the requested pos.
393             previous(status);
394         }
395         return true;
396     }
397 
398     if (fBoundaries[fStartBufIdx] &gt; position) {
399         // The first position in the cache is beyond the requested position.
400         // back up more until we get a boundary &lt;= the requested position.
401         while (fBoundaries[fStartBufIdx] &gt; position) {
402             populatePreceding(status);
403         }
404         fBufIdx = fStartBufIdx;                    // Set iterator position to the start of the buffer.
405         fTextIdx = fBoundaries[fBufIdx];           // Required because populatePreceding may add extra boundaries.
406         while (fTextIdx &lt; position) {              // Move forwards to a position at or following the requested pos.
407             next();
</pre>
<hr />
<pre>
581         if (!addPreceding(position, positionStatusIdx, RetainCachePosition)) {
582             // No space in circular buffer to hold a new preceding result while
583             // also retaining the current cache (iteration) position.
584             // Bailing out is safe; the cache will refill again if needed.
585             break;
586         }
587     }
588 
589     return success;
590 }
591 
592 
593 void RuleBasedBreakIterator::BreakCache::addFollowing(int32_t position, int32_t ruleStatusIdx, UpdatePositionValues update) {
594     U_ASSERT(position &gt; fBoundaries[fEndBufIdx]);
595     U_ASSERT(ruleStatusIdx &lt;= UINT16_MAX);
596     int32_t nextIdx = modChunkSize(fEndBufIdx + 1);
597     if (nextIdx == fStartBufIdx) {
598         fStartBufIdx = modChunkSize(fStartBufIdx + 6);    // TODO: experiment. Probably revert to 1.
599     }
600     fBoundaries[nextIdx] = position;
<span class="line-modified">601     fStatuses[nextIdx] = static_cast&lt;uint16_t&gt;(ruleStatusIdx);</span>
602     fEndBufIdx = nextIdx;
603     if (update == UpdateCachePosition) {
604         // Set current position to the newly added boundary.
605         fBufIdx = nextIdx;
606         fTextIdx = position;
607     } else {
608         // Retaining the original cache position.
609         // Check if the added boundary wraps around the buffer, and would over-write the original position.
610         // It&#39;s the responsibility of callers of this function to not add too many.
611         U_ASSERT(nextIdx != fBufIdx);
612     }
613 }
614 
615 bool RuleBasedBreakIterator::BreakCache::addPreceding(int32_t position, int32_t ruleStatusIdx, UpdatePositionValues update) {
616     U_ASSERT(position &lt; fBoundaries[fStartBufIdx]);
617     U_ASSERT(ruleStatusIdx &lt;= UINT16_MAX);
618     int32_t nextIdx = modChunkSize(fStartBufIdx - 1);
619     if (nextIdx == fEndBufIdx) {
620         if (fBufIdx == fEndBufIdx &amp;&amp; update == RetainCachePosition) {
621             // Failure. The insertion of the new boundary would claim the buffer position that is the
622             // current iteration position. And we also want to retain the current iteration position.
623             // (The buffer is already completely full of entries that precede the iteration position.)
624             return false;
625         }
626         fEndBufIdx = modChunkSize(fEndBufIdx - 1);
627     }
628     fBoundaries[nextIdx] = position;
<span class="line-modified">629     fStatuses[nextIdx] = static_cast&lt;uint16_t&gt;(ruleStatusIdx);</span>
630     fStartBufIdx = nextIdx;
631     if (update == UpdateCachePosition) {
632         fBufIdx = nextIdx;
633         fTextIdx = position;
634     }
635     return true;
636 }
637 
638 
639 void RuleBasedBreakIterator::BreakCache::dumpCache() {
640 #ifdef RBBI_DEBUG
641     RBBIDebugPrintf(&quot;fTextIdx:%d   fBufIdx:%d\n&quot;, fTextIdx, fBufIdx);
642     for (int32_t i=fStartBufIdx; ; i=modChunkSize(i+1)) {
643         RBBIDebugPrintf(&quot;%d  %d\n&quot;, i, fBoundaries[i]);
644         if (i == fEndBufIdx) {
645             break;
646         }
647     }
648 #endif
649 }
</pre>
</td>
</tr>
</table>
<center><a href="rbbi.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbbi_cache.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>