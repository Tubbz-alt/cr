<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_tag.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 2009-2015, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 */
   9 
  10 #include &quot;unicode/bytestream.h&quot;
  11 #include &quot;unicode/utypes.h&quot;
  12 #include &quot;unicode/ures.h&quot;
  13 #include &quot;unicode/localpointer.h&quot;
  14 #include &quot;unicode/putil.h&quot;
  15 #include &quot;unicode/uenum.h&quot;
  16 #include &quot;unicode/uloc.h&quot;
  17 #include &quot;ustr_imp.h&quot;
  18 #include &quot;charstr.h&quot;
  19 #include &quot;cmemory.h&quot;
  20 #include &quot;cstring.h&quot;
  21 #include &quot;putilimp.h&quot;
  22 #include &quot;uinvchar.h&quot;
  23 #include &quot;ulocimp.h&quot;
  24 #include &quot;uassert.h&quot;
  25 
  26 
  27 /* struct holding a single variant */
  28 typedef struct VariantListEntry {
  29     const char              *variant;
  30     struct VariantListEntry *next;
  31 } VariantListEntry;
  32 
  33 /* struct holding a single attribute value */
  34 struct AttributeListEntry : public icu::UMemory {
  35     const char              *attribute;
  36     struct AttributeListEntry *next;
  37 };
  38 
  39 /* struct holding a single extension */
  40 struct ExtensionListEntry : public icu::UMemory {
  41     const char                  *key;
  42     const char                  *value;
  43     struct ExtensionListEntry   *next;
  44 };
  45 
  46 #define MAXEXTLANG 3
  47 typedef struct ULanguageTag {
  48     char                *buf;   /* holding parsed subtags */
  49     const char          *language;
  50     const char          *extlang[MAXEXTLANG];
  51     const char          *script;
  52     const char          *region;
  53     VariantListEntry    *variants;
  54     ExtensionListEntry  *extensions;
  55     const char          *privateuse;
  56     const char          *grandfathered;
  57 } ULanguageTag;
  58 
  59 #define MINLEN 2
  60 #define SEP &#39;-&#39;
  61 #define PRIVATEUSE &#39;x&#39;
  62 #define LDMLEXT &#39;u&#39;
  63 
  64 #define LOCALE_SEP &#39;_&#39;
  65 #define LOCALE_EXT_SEP &#39;@&#39;
  66 #define LOCALE_KEYWORD_SEP &#39;;&#39;
  67 #define LOCALE_KEY_TYPE_SEP &#39;=&#39;
  68 
  69 #define ISALPHA(c) uprv_isASCIILetter(c)
  70 #define ISNUMERIC(c) ((c)&gt;=&#39;0&#39; &amp;&amp; (c)&lt;=&#39;9&#39;)
  71 
  72 static const char EMPTY[] = &quot;&quot;;
  73 static const char LANG_UND[] = &quot;und&quot;;
  74 static const char PRIVATEUSE_KEY[] = &quot;x&quot;;
  75 static const char _POSIX[] = &quot;_POSIX&quot;;
  76 static const char POSIX_KEY[] = &quot;va&quot;;
  77 static const char POSIX_VALUE[] = &quot;posix&quot;;
  78 static const char LOCALE_ATTRIBUTE_KEY[] = &quot;attribute&quot;;
  79 static const char PRIVUSE_VARIANT_PREFIX[] = &quot;lvariant&quot;;
  80 static const char LOCALE_TYPE_YES[] = &quot;yes&quot;;
  81 
  82 #define LANG_UND_LEN 3
  83 
  84 /*
  85  Updated on 2018-09-12 from
  86  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .
  87 
  88  This table has 2 parts. The parts for Grandfathered tags is generated by the
  89  following scripts from the IANA language tag registry.
  90 
  91  curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry |\
  92  egrep -A 7 &#39;Type: grandfathered&#39; | \
  93  egrep &#39;Tag|Prefe&#39; | grep -B1 &#39;Preferred&#39; | grep -v &#39;^--&#39; | \
  94  awk -n &#39;/Tag/ {printf(&quot;    \&quot;%s\&quot;, &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39; |\
  95  tr &#39;A-Z&#39; &#39;a-z&#39;
  96 
  97 
  98  The 2nd part is made of five ICU-specific entries. They&#39;re kept for
  99  the backward compatibility for now, even though there are no preferred
 100  values. They may have to be removed for the strict BCP 47 compliance.
 101 
 102 */
 103 static const char* const GRANDFATHERED[] = {
 104 /*  grandfathered   preferred */
 105     &quot;art-lojban&quot;,   &quot;jbo&quot;,
 106     &quot;en-gb-oed&quot;,    &quot;en-gb-oxendict&quot;,
 107     &quot;i-ami&quot;,        &quot;ami&quot;,
 108     &quot;i-bnn&quot;,        &quot;bnn&quot;,
 109     &quot;i-hak&quot;,        &quot;hak&quot;,
 110     &quot;i-klingon&quot;,    &quot;tlh&quot;,
 111     &quot;i-lux&quot;,        &quot;lb&quot;,
 112     &quot;i-navajo&quot;,     &quot;nv&quot;,
 113     &quot;i-pwn&quot;,        &quot;pwn&quot;,
 114     &quot;i-tao&quot;,        &quot;tao&quot;,
 115     &quot;i-tay&quot;,        &quot;tay&quot;,
 116     &quot;i-tsu&quot;,        &quot;tsu&quot;,
 117     &quot;no-bok&quot;,       &quot;nb&quot;,
 118     &quot;no-nyn&quot;,       &quot;nn&quot;,
 119     &quot;sgn-be-fr&quot;,    &quot;sfb&quot;,
 120     &quot;sgn-be-nl&quot;,    &quot;vgt&quot;,
 121     &quot;sgn-ch-de&quot;,    &quot;sgg&quot;,
 122     &quot;zh-guoyu&quot;,     &quot;cmn&quot;,
 123     &quot;zh-hakka&quot;,     &quot;hak&quot;,
 124     &quot;zh-min-nan&quot;,   &quot;nan&quot;,
 125     &quot;zh-xiang&quot;,     &quot;hsn&quot;,
 126 
 127     // Grandfathered tags with no preferred value in the IANA
 128     // registry. Kept for now for the backward compatibility
 129     // because ICU has mapped them this way.
 130     &quot;cel-gaulish&quot;,  &quot;xtg-x-cel-gaulish&quot;,
 131     &quot;i-default&quot;,    &quot;en-x-i-default&quot;,
 132     &quot;i-enochian&quot;,   &quot;und-x-i-enochian&quot;,
 133     &quot;i-mingo&quot;,      &quot;see-x-i-mingo&quot;,
 134     &quot;zh-min&quot;,       &quot;nan-x-zh-min&quot;,
 135 };
 136 
 137 /*
 138  Updated on 2018-09-12 from
 139  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .
 140 
 141  The table lists redundant tags with preferred value in the IANA languate tag registry.
 142  It&#39;s generated with the following command:
 143 
 144  curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry |\
 145  grep &#39;Type: redundant&#39; -A 5 | egrep &#39;^(Tag:|Prefer)&#39; | grep -B1 &#39;Preferred&#39; | \
 146  awk -n &#39;/Tag/ {printf(&quot;    \&quot;%s\&quot;,       &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39; | \
 147  tr &#39;A-Z&#39; &#39;a-z&#39;
 148 
 149  In addition, ja-latn-hepburn-heploc is mapped to ja-latn-alalc97 because
 150  a variant tag &#39;hepburn-heploc&#39; has the preferred subtag, &#39;alaic97&#39;.
 151 */
 152 
 153 static const char* const REDUNDANT[] = {
 154 //  redundant       preferred
 155     &quot;sgn-br&quot;,       &quot;bzs&quot;,
 156     &quot;sgn-co&quot;,       &quot;csn&quot;,
 157     &quot;sgn-de&quot;,       &quot;gsg&quot;,
 158     &quot;sgn-dk&quot;,       &quot;dsl&quot;,
 159     &quot;sgn-es&quot;,       &quot;ssp&quot;,
 160     &quot;sgn-fr&quot;,       &quot;fsl&quot;,
 161     &quot;sgn-gb&quot;,       &quot;bfi&quot;,
 162     &quot;sgn-gr&quot;,       &quot;gss&quot;,
 163     &quot;sgn-ie&quot;,       &quot;isg&quot;,
 164     &quot;sgn-it&quot;,       &quot;ise&quot;,
 165     &quot;sgn-jp&quot;,       &quot;jsl&quot;,
 166     &quot;sgn-mx&quot;,       &quot;mfs&quot;,
 167     &quot;sgn-ni&quot;,       &quot;ncs&quot;,
 168     &quot;sgn-nl&quot;,       &quot;dse&quot;,
 169     &quot;sgn-no&quot;,       &quot;nsl&quot;,
 170     &quot;sgn-pt&quot;,       &quot;psr&quot;,
 171     &quot;sgn-se&quot;,       &quot;swl&quot;,
 172     &quot;sgn-us&quot;,       &quot;ase&quot;,
 173     &quot;sgn-za&quot;,       &quot;sfs&quot;,
 174     &quot;zh-cmn&quot;,       &quot;cmn&quot;,
 175     &quot;zh-cmn-hans&quot;,  &quot;cmn-hans&quot;,
 176     &quot;zh-cmn-hant&quot;,  &quot;cmn-hant&quot;,
 177     &quot;zh-gan&quot;,       &quot;gan&quot;,
 178     &quot;zh-wuu&quot;,       &quot;wuu&quot;,
 179     &quot;zh-yue&quot;,       &quot;yue&quot;,
 180 
 181     // variant tag with preferred value
 182     &quot;ja-latn-hepburn-heploc&quot;, &quot;ja-latn-alalc97&quot;,
 183 };
 184 
 185 /*
 186   Updated on 2018-09-12 from
 187   https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .
 188 
 189   grep &#39;Type: language&#39; -A 7 language-subtag-registry  | egrep &#39;Subtag|Prefe&#39; | \
 190   grep -B1 &#39;Preferred&#39; | grep -v &#39;^--&#39; | \
 191   awk -n &#39;/Subtag/ {printf(&quot;    \&quot;%s\&quot;,       &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39;
 192 
 193   Make sure that 2-letter language subtags come before 3-letter subtags.
 194 */
 195 static const char DEPRECATEDLANGS[][4] = {
 196 /*  deprecated  new */
 197     &quot;in&quot;,       &quot;id&quot;,
 198     &quot;iw&quot;,       &quot;he&quot;,
 199     &quot;ji&quot;,       &quot;yi&quot;,
 200     &quot;jw&quot;,       &quot;jv&quot;,
 201     &quot;mo&quot;,       &quot;ro&quot;,
 202     &quot;aam&quot;,       &quot;aas&quot;,
 203     &quot;adp&quot;,       &quot;dz&quot;,
 204     &quot;aue&quot;,       &quot;ktz&quot;,
 205     &quot;ayx&quot;,       &quot;nun&quot;,
 206     &quot;bgm&quot;,       &quot;bcg&quot;,
 207     &quot;bjd&quot;,       &quot;drl&quot;,
 208     &quot;ccq&quot;,       &quot;rki&quot;,
 209     &quot;cjr&quot;,       &quot;mom&quot;,
 210     &quot;cka&quot;,       &quot;cmr&quot;,
 211     &quot;cmk&quot;,       &quot;xch&quot;,
 212     &quot;coy&quot;,       &quot;pij&quot;,
 213     &quot;cqu&quot;,       &quot;quh&quot;,
 214     &quot;drh&quot;,       &quot;khk&quot;,
 215     &quot;drw&quot;,       &quot;prs&quot;,
 216     &quot;gav&quot;,       &quot;dev&quot;,
 217     &quot;gfx&quot;,       &quot;vaj&quot;,
 218     &quot;ggn&quot;,       &quot;gvr&quot;,
 219     &quot;gti&quot;,       &quot;nyc&quot;,
 220     &quot;guv&quot;,       &quot;duz&quot;,
 221     &quot;hrr&quot;,       &quot;jal&quot;,
 222     &quot;ibi&quot;,       &quot;opa&quot;,
 223     &quot;ilw&quot;,       &quot;gal&quot;,
 224     &quot;jeg&quot;,       &quot;oyb&quot;,
 225     &quot;kgc&quot;,       &quot;tdf&quot;,
 226     &quot;kgh&quot;,       &quot;kml&quot;,
 227     &quot;koj&quot;,       &quot;kwv&quot;,
 228     &quot;krm&quot;,       &quot;bmf&quot;,
 229     &quot;ktr&quot;,       &quot;dtp&quot;,
 230     &quot;kvs&quot;,       &quot;gdj&quot;,
 231     &quot;kwq&quot;,       &quot;yam&quot;,
 232     &quot;kxe&quot;,       &quot;tvd&quot;,
 233     &quot;kzj&quot;,       &quot;dtp&quot;,
 234     &quot;kzt&quot;,       &quot;dtp&quot;,
 235     &quot;lii&quot;,       &quot;raq&quot;,
 236     &quot;lmm&quot;,       &quot;rmx&quot;,
 237     &quot;meg&quot;,       &quot;cir&quot;,
 238     &quot;mst&quot;,       &quot;mry&quot;,
 239     &quot;mwj&quot;,       &quot;vaj&quot;,
 240     &quot;myt&quot;,       &quot;mry&quot;,
 241     &quot;nad&quot;,       &quot;xny&quot;,
 242     &quot;ncp&quot;,       &quot;kdz&quot;,
 243     &quot;nnx&quot;,       &quot;ngv&quot;,
 244     &quot;nts&quot;,       &quot;pij&quot;,
 245     &quot;oun&quot;,       &quot;vaj&quot;,
 246     &quot;pcr&quot;,       &quot;adx&quot;,
 247     &quot;pmc&quot;,       &quot;huw&quot;,
 248     &quot;pmu&quot;,       &quot;phr&quot;,
 249     &quot;ppa&quot;,       &quot;bfy&quot;,
 250     &quot;ppr&quot;,       &quot;lcq&quot;,
 251     &quot;pry&quot;,       &quot;prt&quot;,
 252     &quot;puz&quot;,       &quot;pub&quot;,
 253     &quot;sca&quot;,       &quot;hle&quot;,
 254     &quot;skk&quot;,       &quot;oyb&quot;,
 255     &quot;tdu&quot;,       &quot;dtp&quot;,
 256     &quot;thc&quot;,       &quot;tpo&quot;,
 257     &quot;thx&quot;,       &quot;oyb&quot;,
 258     &quot;tie&quot;,       &quot;ras&quot;,
 259     &quot;tkk&quot;,       &quot;twm&quot;,
 260     &quot;tlw&quot;,       &quot;weo&quot;,
 261     &quot;tmp&quot;,       &quot;tyj&quot;,
 262     &quot;tne&quot;,       &quot;kak&quot;,
 263     &quot;tnf&quot;,       &quot;prs&quot;,
 264     &quot;tsf&quot;,       &quot;taj&quot;,
 265     &quot;uok&quot;,       &quot;ema&quot;,
 266     &quot;xba&quot;,       &quot;cax&quot;,
 267     &quot;xia&quot;,       &quot;acn&quot;,
 268     &quot;xkh&quot;,       &quot;waw&quot;,
 269     &quot;xsj&quot;,       &quot;suj&quot;,
 270     &quot;ybd&quot;,       &quot;rki&quot;,
 271     &quot;yma&quot;,       &quot;lrr&quot;,
 272     &quot;ymt&quot;,       &quot;mtm&quot;,
 273     &quot;yos&quot;,       &quot;zom&quot;,
 274     &quot;yuu&quot;,       &quot;yug&quot;,
 275 };
 276 
 277 /*
 278   Updated on 2018-04-24 from
 279 
 280   curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry | \
 281   grep &#39;Type: region&#39; -A 7 | egrep &#39;Subtag|Prefe&#39; | \
 282   grep -B1 &#39;Preferred&#39; | \
 283   awk -n &#39;/Subtag/ {printf(&quot;    \&quot;%s\&quot;,       &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39;
 284 */
 285 static const char DEPRECATEDREGIONS[][3] = {
 286 /*  deprecated  new */
 287     &quot;BU&quot;,       &quot;MM&quot;,
 288     &quot;DD&quot;,       &quot;DE&quot;,
 289     &quot;FX&quot;,       &quot;FR&quot;,
 290     &quot;TP&quot;,       &quot;TL&quot;,
 291     &quot;YD&quot;,       &quot;YE&quot;,
 292     &quot;ZR&quot;,       &quot;CD&quot;,
 293 };
 294 
 295 /*
 296 * -------------------------------------------------
 297 *
 298 * These ultag_ functions may be exposed as APIs later
 299 *
 300 * -------------------------------------------------
 301 */
 302 
 303 static ULanguageTag*
 304 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status);
 305 
 306 static void
 307 ultag_close(ULanguageTag* langtag);
 308 
 309 static const char*
 310 ultag_getLanguage(const ULanguageTag* langtag);
 311 
 312 #if 0
 313 static const char*
 314 ultag_getJDKLanguage(const ULanguageTag* langtag);
 315 #endif
 316 
 317 static const char*
 318 ultag_getExtlang(const ULanguageTag* langtag, int32_t idx);
 319 
 320 static int32_t
 321 ultag_getExtlangSize(const ULanguageTag* langtag);
 322 
 323 static const char*
 324 ultag_getScript(const ULanguageTag* langtag);
 325 
 326 static const char*
 327 ultag_getRegion(const ULanguageTag* langtag);
 328 
 329 static const char*
 330 ultag_getVariant(const ULanguageTag* langtag, int32_t idx);
 331 
 332 static int32_t
 333 ultag_getVariantsSize(const ULanguageTag* langtag);
 334 
 335 static const char*
 336 ultag_getExtensionKey(const ULanguageTag* langtag, int32_t idx);
 337 
 338 static const char*
 339 ultag_getExtensionValue(const ULanguageTag* langtag, int32_t idx);
 340 
 341 static int32_t
 342 ultag_getExtensionsSize(const ULanguageTag* langtag);
 343 
 344 static const char*
 345 ultag_getPrivateUse(const ULanguageTag* langtag);
 346 
 347 #if 0
 348 static const char*
 349 ultag_getGrandfathered(const ULanguageTag* langtag);
 350 #endif
 351 
 352 U_NAMESPACE_BEGIN
 353 
 354 /**
 355  * \class LocalULanguageTagPointer
 356  * &quot;Smart pointer&quot; class, closes a ULanguageTag via ultag_close().
 357  * For most methods see the LocalPointerBase base class.
 358  *
 359  * @see LocalPointerBase
 360  * @see LocalPointer
 361  * @internal
 362  */
 363 U_DEFINE_LOCAL_OPEN_POINTER(LocalULanguageTagPointer, ULanguageTag, ultag_close);
 364 
 365 U_NAMESPACE_END
 366 
 367 /*
 368 * -------------------------------------------------
 369 *
 370 * Language subtag syntax validation functions
 371 *
 372 * -------------------------------------------------
 373 */
 374 
 375 static UBool
 376 _isAlphaString(const char* s, int32_t len) {
 377     int32_t i;
 378     for (i = 0; i &lt; len; i++) {
 379         if (!ISALPHA(*(s + i))) {
 380             return FALSE;
 381         }
 382     }
 383     return TRUE;
 384 }
 385 
 386 static UBool
 387 _isNumericString(const char* s, int32_t len) {
 388     int32_t i;
 389     for (i = 0; i &lt; len; i++) {
 390         if (!ISNUMERIC(*(s + i))) {
 391             return FALSE;
 392         }
 393     }
 394     return TRUE;
 395 }
 396 
 397 static UBool
 398 _isAlphaNumericString(const char* s, int32_t len) {
 399     int32_t i;
 400     for (i = 0; i &lt; len; i++) {
 401         if (!ISALPHA(*(s + i)) &amp;&amp; !ISNUMERIC(*(s + i))) {
 402             return FALSE;
 403         }
 404     }
 405     return TRUE;
 406 }
 407 
 408 static UBool
 409 _isAlphaNumericStringLimitedLength(const char* s, int32_t len, int32_t min, int32_t max) {
 410     if (len &lt; 0) {
 411         len = (int32_t)uprv_strlen(s);
 412     }
 413     if (len &gt;= min &amp;&amp; len &lt;= max &amp;&amp; _isAlphaNumericString(s, len)) {
 414         return TRUE;
 415     }
 416     return FALSE;
 417 }
 418 
 419 U_CFUNC UBool
 420 ultag_isLanguageSubtag(const char* s, int32_t len) {
 421     /*
 422      * unicode_language_subtag = alpha{2,3} | alpha{5,8};
 423      * NOTE: Per ICUTC 2019/01/23- accepting alpha 4
 424      * See ICU-20372
 425      */
 426     if (len &lt; 0) {
 427         len = (int32_t)uprv_strlen(s);
 428     }
 429     if (len &gt;= 2 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaString(s, len)) {
 430         return TRUE;
 431     }
 432     return FALSE;
 433 }
 434 
 435 static UBool
 436 _isExtlangSubtag(const char* s, int32_t len) {
 437     /*
 438      * extlang       = 3ALPHA              ; selected ISO 639 codes
 439      *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 440      */
 441     if (len &lt; 0) {
 442         len = (int32_t)uprv_strlen(s);
 443     }
 444     if (len == 3 &amp;&amp; _isAlphaString(s, len)) {
 445         return TRUE;
 446     }
 447     return FALSE;
 448 }
 449 
 450 U_CFUNC UBool
 451 ultag_isScriptSubtag(const char* s, int32_t len) {
 452     /*
 453      * script        = 4ALPHA              ; ISO 15924 code
 454      */
 455     if (len &lt; 0) {
 456         len = (int32_t)uprv_strlen(s);
 457     }
 458     if (len == 4 &amp;&amp; _isAlphaString(s, len)) {
 459         return TRUE;
 460     }
 461     return FALSE;
 462 }
 463 
 464 U_CFUNC UBool
 465 ultag_isRegionSubtag(const char* s, int32_t len) {
 466     /*
 467      * region        = 2ALPHA              ; ISO 3166-1 code
 468      *               / 3DIGIT              ; UN M.49 code
 469      */
 470     if (len &lt; 0) {
 471         len = (int32_t)uprv_strlen(s);
 472     }
 473     if (len == 2 &amp;&amp; _isAlphaString(s, len)) {
 474         return TRUE;
 475     }
 476     if (len == 3 &amp;&amp; _isNumericString(s, len)) {
 477         return TRUE;
 478     }
 479     return FALSE;
 480 }
 481 
 482 static UBool
 483 _isVariantSubtag(const char* s, int32_t len) {
 484     /*
 485      * variant       = 5*8alphanum         ; registered variants
 486      *               / (DIGIT 3alphanum)
 487      */
 488     if (len &lt; 0) {
 489         len = (int32_t)uprv_strlen(s);
 490     }
 491     if (_isAlphaNumericStringLimitedLength(s, len, 5, 8)) {
 492         return TRUE;
 493     }
 494     if (len == 4 &amp;&amp; ISNUMERIC(*s) &amp;&amp; _isAlphaNumericString(s + 1, 3)) {
 495         return TRUE;
 496     }
 497     return FALSE;
 498 }
 499 
 500 static UBool
 501 _isSepListOf(UBool (*test)(const char*, int32_t), const char* s, int32_t len) {
 502     const char *p = s;
 503     const char *pSubtag = NULL;
 504 
 505     if (len &lt; 0) {
 506         len = (int32_t)uprv_strlen(s);
 507     }
 508 
 509     while ((p - s) &lt; len) {
 510         if (*p == SEP) {
 511             if (pSubtag == NULL) {
 512                 return FALSE;
 513             }
 514             if (!test(pSubtag, (int32_t)(p - pSubtag))) {
 515                 return FALSE;
 516             }
 517             pSubtag = NULL;
 518         } else if (pSubtag == NULL) {
 519             pSubtag = p;
 520         }
 521         p++;
 522     }
 523     if (pSubtag == NULL) {
 524         return FALSE;
 525     }
 526     return test(pSubtag, (int32_t)(p - pSubtag));
 527 }
 528 
 529 U_CFUNC UBool
 530 ultag_isVariantSubtags(const char* s, int32_t len) {
 531     return _isSepListOf(&amp;_isVariantSubtag, s, len);
 532 }
 533 
 534 // This is for the ICU-specific &quot;lvariant&quot; handling.
 535 static UBool
 536 _isPrivateuseVariantSubtag(const char* s, int32_t len) {
 537     /*
 538      * variant       = 1*8alphanum         ; registered variants
 539      *               / (DIGIT 3alphanum)
 540      */
 541     return _isAlphaNumericStringLimitedLength(s, len , 1, 8);
 542 }
 543 
 544 static UBool
 545 _isExtensionSingleton(const char* s, int32_t len) {
 546     /*
 547      * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
 548      *
 549      * singleton     = DIGIT               ; 0 - 9
 550      *               / %x41-57             ; A - W
 551      *               / %x59-5A             ; Y - Z
 552      *               / %x61-77             ; a - w
 553      *               / %x79-7A             ; y - z
 554      */
 555     if (len &lt; 0) {
 556         len = (int32_t)uprv_strlen(s);
 557     }
 558     if (len == 1 &amp;&amp; (ISALPHA(*s) || ISNUMERIC(*s)) &amp;&amp; (uprv_tolower(*s) != PRIVATEUSE)) {
 559         return TRUE;
 560     }
 561     return FALSE;
 562 }
 563 
 564 static UBool
 565 _isExtensionSubtag(const char* s, int32_t len) {
 566     /*
 567      * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
 568      */
 569     return _isAlphaNumericStringLimitedLength(s, len, 2, 8);
 570 }
 571 
 572 U_CFUNC UBool
 573 ultag_isExtensionSubtags(const char* s, int32_t len) {
 574     return _isSepListOf(&amp;_isExtensionSubtag, s, len);
 575 }
 576 
 577 static UBool
 578 _isPrivateuseValueSubtag(const char* s, int32_t len) {
 579     /*
 580      * privateuse    = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))
 581      */
 582     return _isAlphaNumericStringLimitedLength(s, len, 1, 8);
 583 }
 584 
 585 U_CFUNC UBool
 586 ultag_isPrivateuseValueSubtags(const char* s, int32_t len) {
 587     return _isSepListOf(&amp;_isPrivateuseValueSubtag, s, len);
 588 }
 589 
 590 U_CFUNC UBool
 591 ultag_isUnicodeLocaleAttribute(const char* s, int32_t len) {
 592     /*
 593      * attribute = alphanum{3,8} ;
 594      */
 595     return _isAlphaNumericStringLimitedLength(s, len , 3, 8);
 596 }
 597 
 598 U_CFUNC UBool
 599 ultag_isUnicodeLocaleAttributes(const char* s, int32_t len) {
 600     return _isSepListOf(&amp;ultag_isUnicodeLocaleAttribute, s, len);
 601 }
 602 
 603 U_CFUNC UBool
 604 ultag_isUnicodeLocaleKey(const char* s, int32_t len) {
 605     /*
 606      * key = alphanum alpha ;
 607      */
 608     if (len &lt; 0) {
 609         len = (int32_t)uprv_strlen(s);
 610     }
 611     if (len == 2 &amp;&amp; (ISALPHA(*s) || ISNUMERIC(*s)) &amp;&amp; ISALPHA(s[1])) {
 612         return TRUE;
 613     }
 614     return FALSE;
 615 }
 616 
 617 U_CFUNC UBool
 618 _isUnicodeLocaleTypeSubtag(const char*s, int32_t len) {
 619     /*
 620      * alphanum{3,8}
 621      */
 622     return _isAlphaNumericStringLimitedLength(s, len , 3, 8);
 623 }
 624 
 625 U_CFUNC UBool
 626 ultag_isUnicodeLocaleType(const char*s, int32_t len) {
 627     /*
 628      * type = alphanum{3,8} (sep alphanum{3,8})* ;
 629      */
 630     return _isSepListOf(&amp;_isUnicodeLocaleTypeSubtag, s, len);
 631 }
 632 
 633 static UBool
 634 _isTKey(const char* s, int32_t len)
 635 {
 636     /*
 637      * tkey = alpha digit ;
 638      */
 639     if (len &lt; 0) {
 640         len = (int32_t)uprv_strlen(s);
 641     }
 642     if (len == 2 &amp;&amp; ISALPHA(*s) &amp;&amp; ISNUMERIC(*(s + 1))) {
 643         return TRUE;
 644     }
 645     return FALSE;
 646 }
 647 
 648 static UBool
 649 _isTValue(const char* s, int32_t len)
 650 {
 651     /*
 652      * tvalue = (sep alphanum{3,8})+ ;
 653      */
 654     return _isAlphaNumericStringLimitedLength(s, len , 3, 8);
 655 }
 656 
 657 static UBool
 658 _isTransformedExtensionSubtag(int32_t&amp; state, const char* s, int32_t len)
 659 {
 660     const int32_t kStart = 0;       // Start, wait for unicode_language_subtag, tkey or end
 661     const int32_t kGotLanguage = 1; // Got unicode_language_subtag, wait for unicode_script_subtag,
 662                                     // unicode_region_subtag, unicode_variant_subtag, tkey or end
 663     const int32_t kGotScript = 2;   // Got unicode_script_subtag, wait for unicode_region_subtag,
 664                                     // unicode_variant_subtag, tkey, or end
 665     const int32_t kGotRegion = 3;   // Got unicode_region_subtag, wait for unicode_variant_subtag,
 666                                     // tkey, or end.
 667     const int32_t kGotVariant = 4;  // Got unicode_variant_subtag, wait for unicode_variant_subtag
 668                                     // tkey or end.
 669     const int32_t kGotTKey = -1;    // Got tkey, wait for tvalue. ERROR if stop here.
 670     const int32_t kGotTValue = 6;   // Got tvalue, wait for tkey, tvalue or end
 671 
 672     switch (state) {
 673         case kStart:
 674             if (ultag_isLanguageSubtag(s, len)) {
 675                 state = kGotLanguage;
 676                 return TRUE;
 677             }
 678             if (_isTKey(s, len)) {
 679                 state = kGotTKey;
 680                 return TRUE;
 681             }
 682             return FALSE;
 683         case kGotLanguage:
 684             if (ultag_isScriptSubtag(s, len)) {
 685                 state = kGotScript;
 686                 return TRUE;
 687             }
 688             U_FALLTHROUGH;
 689         case kGotScript:
 690             if (ultag_isRegionSubtag(s, len)) {
 691                 state = kGotRegion;
 692                 return TRUE;
 693             }
 694             U_FALLTHROUGH;
 695         case kGotRegion:
 696             U_FALLTHROUGH;
 697         case kGotVariant:
 698             if (_isVariantSubtag(s, len)) {
 699                 state = kGotVariant;
 700                 return TRUE;
 701             }
 702             if (_isTKey(s, len)) {
 703                 state = kGotTKey;
 704                 return TRUE;
 705             }
 706             return FALSE;
 707         case kGotTKey:
 708             if (_isTValue(s, len)) {
 709                 state = kGotTValue;
 710                 return TRUE;
 711             }
 712             return FALSE;
 713         case kGotTValue:
 714             if (_isTKey(s, len)) {
 715                 state = kGotTKey;
 716                 return TRUE;
 717             }
 718             if (_isTValue(s, len)) {
 719                 return TRUE;
 720             }
 721             return FALSE;
 722     }
 723     return FALSE;
 724 }
 725 
 726 static UBool
 727 _isUnicodeExtensionSubtag(int32_t&amp; state, const char* s, int32_t len)
 728 {
 729     const int32_t kStart = 0;         // Start, wait for a key or attribute or end
 730     const int32_t kGotKey = 1;        // Got a key, wait for type or key or end
 731     const int32_t kGotType = 2;       // Got a type, wait for key or end
 732 
 733     switch (state) {
 734         case kStart:
 735             if (ultag_isUnicodeLocaleKey(s, len)) {
 736                 state = kGotKey;
 737                 return TRUE;
 738             }
 739             if (ultag_isUnicodeLocaleAttribute(s, len)) {
 740                 return TRUE;
 741             }
 742             return FALSE;
 743         case kGotKey:
 744             if (ultag_isUnicodeLocaleKey(s, len)) {
 745                 return TRUE;
 746             }
 747             if (_isUnicodeLocaleTypeSubtag(s, len)) {
 748                 state = kGotType;
 749                 return TRUE;
 750             }
 751             return FALSE;
 752         case kGotType:
 753             if (ultag_isUnicodeLocaleKey(s, len)) {
 754                 state = kGotKey;
 755                 return TRUE;
 756             }
 757             if (_isUnicodeLocaleTypeSubtag(s, len)) {
 758                 return TRUE;
 759             }
 760             return FALSE;
 761     }
 762     return FALSE;
 763 }
 764 
 765 static UBool
 766 _isStatefulSepListOf(UBool (*test)(int32_t&amp;, const char*, int32_t), const char* s, int32_t len)
 767 {
 768     int32_t state = 0;
 769     const char* p;
 770     const char* start = s;
 771     int32_t subtagLen = 0;
 772 
 773     if (len &lt; 0) {
 774         len = (int32_t)uprv_strlen(s);
 775     }
 776 
 777     for (p = s; len &gt; 0; p++, len--) {
 778         if (*p == SEP) {
 779             if (!test(state, start, subtagLen)) {
 780                 return FALSE;
 781             }
 782             subtagLen = 0;
 783             start = p + 1;
 784         } else {
 785             subtagLen++;
 786         }
 787     }
 788 
 789     if (test(state, start, subtagLen) &amp;&amp; state &gt;= 0) {
 790         return TRUE;
 791     }
 792     return FALSE;
 793 }
 794 
 795 U_CFUNC UBool
 796 ultag_isTransformedExtensionSubtags(const char* s, int32_t len)
 797 {
 798     return _isStatefulSepListOf(&amp;_isTransformedExtensionSubtag, s, len);
 799 }
 800 
 801 U_CFUNC UBool
 802 ultag_isUnicodeExtensionSubtags(const char* s, int32_t len) {
 803     return _isStatefulSepListOf(&amp;_isUnicodeExtensionSubtag, s, len);
 804 }
 805 
 806 
 807 /*
 808 * -------------------------------------------------
 809 *
 810 * Helper functions
 811 *
 812 * -------------------------------------------------
 813 */
 814 
 815 static UBool
 816 _addVariantToList(VariantListEntry **first, VariantListEntry *var) {
 817     UBool bAdded = TRUE;
 818 
 819     if (*first == NULL) {
 820         var-&gt;next = NULL;
 821         *first = var;
 822     } else {
 823         VariantListEntry *prev, *cur;
 824         int32_t cmp;
 825 
 826         /* variants order should be preserved */
 827         prev = NULL;
 828         cur = *first;
 829         while (TRUE) {
 830             if (cur == NULL) {
 831                 prev-&gt;next = var;
 832                 var-&gt;next = NULL;
 833                 break;
 834             }
 835 
 836             /* Checking for duplicate variant */
 837             cmp = uprv_compareInvCharsAsAscii(var-&gt;variant, cur-&gt;variant);
 838             if (cmp == 0) {
 839                 /* duplicated variant */
 840                 bAdded = FALSE;
 841                 break;
 842             }
 843             prev = cur;
 844             cur = cur-&gt;next;
 845         }
 846     }
 847 
 848     return bAdded;
 849 }
 850 
 851 static UBool
 852 _addAttributeToList(AttributeListEntry **first, AttributeListEntry *attr) {
 853     UBool bAdded = TRUE;
 854 
 855     if (*first == NULL) {
 856         attr-&gt;next = NULL;
 857         *first = attr;
 858     } else {
 859         AttributeListEntry *prev, *cur;
 860         int32_t cmp;
 861 
 862         /* reorder variants in alphabetical order */
 863         prev = NULL;
 864         cur = *first;
 865         while (TRUE) {
 866             if (cur == NULL) {
 867                 prev-&gt;next = attr;
 868                 attr-&gt;next = NULL;
 869                 break;
 870             }
 871             cmp = uprv_compareInvCharsAsAscii(attr-&gt;attribute, cur-&gt;attribute);
 872             if (cmp &lt; 0) {
 873                 if (prev == NULL) {
 874                     *first = attr;
 875                 } else {
 876                     prev-&gt;next = attr;
 877                 }
 878                 attr-&gt;next = cur;
 879                 break;
 880             }
 881             if (cmp == 0) {
 882                 /* duplicated variant */
 883                 bAdded = FALSE;
 884                 break;
 885             }
 886             prev = cur;
 887             cur = cur-&gt;next;
 888         }
 889     }
 890 
 891     return bAdded;
 892 }
 893 
 894 
 895 static UBool
 896 _addExtensionToList(ExtensionListEntry **first, ExtensionListEntry *ext, UBool localeToBCP) {
 897     UBool bAdded = TRUE;
 898 
 899     if (*first == NULL) {
 900         ext-&gt;next = NULL;
 901         *first = ext;
 902     } else {
 903         ExtensionListEntry *prev, *cur;
 904         int32_t cmp;
 905 
 906         /* reorder variants in alphabetical order */
 907         prev = NULL;
 908         cur = *first;
 909         while (TRUE) {
 910             if (cur == NULL) {
 911                 prev-&gt;next = ext;
 912                 ext-&gt;next = NULL;
 913                 break;
 914             }
 915             if (localeToBCP) {
 916                 /* special handling for locale to bcp conversion */
 917                 int32_t len, curlen;
 918 
 919                 len = (int32_t)uprv_strlen(ext-&gt;key);
 920                 curlen = (int32_t)uprv_strlen(cur-&gt;key);
 921 
 922                 if (len == 1 &amp;&amp; curlen == 1) {
 923                     if (*(ext-&gt;key) == *(cur-&gt;key)) {
 924                         cmp = 0;
 925                     } else if (*(ext-&gt;key) == PRIVATEUSE) {
 926                         cmp = 1;
 927                     } else if (*(cur-&gt;key) == PRIVATEUSE) {
 928                         cmp = -1;
 929                     } else {
 930                         cmp = *(ext-&gt;key) - *(cur-&gt;key);
 931                     }
 932                 } else if (len == 1) {
 933                     cmp = *(ext-&gt;key) - LDMLEXT;
 934                 } else if (curlen == 1) {
 935                     cmp = LDMLEXT - *(cur-&gt;key);
 936                 } else {
 937                     cmp = uprv_compareInvCharsAsAscii(ext-&gt;key, cur-&gt;key);
 938                     /* Both are u extension keys - we need special handling for &#39;attribute&#39; */
 939                     if (cmp != 0) {
 940                         if (uprv_strcmp(cur-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
 941                             cmp = 1;
 942                         } else if (uprv_strcmp(ext-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
 943                             cmp = -1;
 944                         }
 945                     }
 946                 }
 947             } else {
 948                 cmp = uprv_compareInvCharsAsAscii(ext-&gt;key, cur-&gt;key);
 949             }
 950             if (cmp &lt; 0) {
 951                 if (prev == NULL) {
 952                     *first = ext;
 953                 } else {
 954                     prev-&gt;next = ext;
 955                 }
 956                 ext-&gt;next = cur;
 957                 break;
 958             }
 959             if (cmp == 0) {
 960                 /* duplicated extension key */
 961                 bAdded = FALSE;
 962                 break;
 963             }
 964             prev = cur;
 965             cur = cur-&gt;next;
 966         }
 967     }
 968 
 969     return bAdded;
 970 }
 971 
 972 static void
 973 _initializeULanguageTag(ULanguageTag* langtag) {
 974     int32_t i;
 975 
 976     langtag-&gt;buf = NULL;
 977 
 978     langtag-&gt;language = EMPTY;
 979     for (i = 0; i &lt; MAXEXTLANG; i++) {
 980         langtag-&gt;extlang[i] = NULL;
 981     }
 982 
 983     langtag-&gt;script = EMPTY;
 984     langtag-&gt;region = EMPTY;
 985 
 986     langtag-&gt;variants = NULL;
 987     langtag-&gt;extensions = NULL;
 988 
 989     langtag-&gt;grandfathered = EMPTY;
 990     langtag-&gt;privateuse = EMPTY;
 991 }
 992 
 993 static void
 994 _appendLanguageToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UErrorCode* status) {
 995     char buf[ULOC_LANG_CAPACITY];
 996     UErrorCode tmpStatus = U_ZERO_ERROR;
 997     int32_t len, i;
 998 
 999     if (U_FAILURE(*status)) {
1000         return;
1001     }
1002 
1003     len = uloc_getLanguage(localeID, buf, sizeof(buf), &amp;tmpStatus);
1004     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1005         if (strict) {
1006             *status = U_ILLEGAL_ARGUMENT_ERROR;
1007             return;
1008         }
1009         len = 0;
1010     }
1011 
1012     /* Note: returned language code is in lower case letters */
1013 
1014     if (len == 0) {
1015         sink.Append(LANG_UND, LANG_UND_LEN);
1016     } else if (!ultag_isLanguageSubtag(buf, len)) {
1017             /* invalid language code */
1018         if (strict) {
1019             *status = U_ILLEGAL_ARGUMENT_ERROR;
1020             return;
1021         }
1022         sink.Append(LANG_UND, LANG_UND_LEN);
1023     } else {
1024         /* resolve deprecated */
1025         for (i = 0; i &lt; UPRV_LENGTHOF(DEPRECATEDLANGS); i += 2) {
1026             // 2-letter deprecated subtags are listede before 3-letter
1027             // ones in DEPRECATEDLANGS[]. Get out of loop on coming
1028             // across the 1st 3-letter subtag, if the input is a 2-letter code.
1029             // to avoid continuing to try when there&#39;s no match.
1030             if (uprv_strlen(buf) &lt; uprv_strlen(DEPRECATEDLANGS[i])) break;
1031             if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDLANGS[i]) == 0) {
1032                 uprv_strcpy(buf, DEPRECATEDLANGS[i + 1]);
1033                 len = (int32_t)uprv_strlen(buf);
1034                 break;
1035             }
1036         }
1037         sink.Append(buf, len);
1038     }
1039 }
1040 
1041 static void
1042 _appendScriptToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UErrorCode* status) {
1043     char buf[ULOC_SCRIPT_CAPACITY];
1044     UErrorCode tmpStatus = U_ZERO_ERROR;
1045     int32_t len;
1046 
1047     if (U_FAILURE(*status)) {
1048         return;
1049     }
1050 
1051     len = uloc_getScript(localeID, buf, sizeof(buf), &amp;tmpStatus);
1052     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1053         if (strict) {
1054             *status = U_ILLEGAL_ARGUMENT_ERROR;
1055         }
1056         return;
1057     }
1058 
1059     if (len &gt; 0) {
1060         if (!ultag_isScriptSubtag(buf, len)) {
1061             /* invalid script code */
1062             if (strict) {
1063                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1064             }
1065             return;
1066         } else {
1067             sink.Append(&quot;-&quot;, 1);
1068             sink.Append(buf, len);
1069         }
1070     }
1071 }
1072 
1073 static void
1074 _appendRegionToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UErrorCode* status) {
1075     char buf[ULOC_COUNTRY_CAPACITY];
1076     UErrorCode tmpStatus = U_ZERO_ERROR;
1077     int32_t len;
1078 
1079     if (U_FAILURE(*status)) {
1080         return;
1081     }
1082 
1083     len = uloc_getCountry(localeID, buf, sizeof(buf), &amp;tmpStatus);
1084     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1085         if (strict) {
1086             *status = U_ILLEGAL_ARGUMENT_ERROR;
1087         }
1088         return;
1089     }
1090 
1091     if (len &gt; 0) {
1092         if (!ultag_isRegionSubtag(buf, len)) {
1093             /* invalid region code */
1094             if (strict) {
1095                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1096             }
1097             return;
1098         } else {
1099             sink.Append(&quot;-&quot;, 1);
1100             /* resolve deprecated */
1101             for (int i = 0; i &lt; UPRV_LENGTHOF(DEPRECATEDREGIONS); i += 2) {
1102                 if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDREGIONS[i]) == 0) {
1103                     uprv_strcpy(buf, DEPRECATEDREGIONS[i + 1]);
1104                     len = (int32_t)uprv_strlen(buf);
1105                     break;
1106                 }
1107             }
1108             sink.Append(buf, len);
1109         }
1110     }
1111 }
1112 
1113 static void
1114 _appendVariantsToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UBool *hadPosix, UErrorCode* status) {
1115     char buf[ULOC_FULLNAME_CAPACITY];
1116     UErrorCode tmpStatus = U_ZERO_ERROR;
1117     int32_t len, i;
1118 
1119     if (U_FAILURE(*status)) {
1120         return;
1121     }
1122 
1123     len = uloc_getVariant(localeID, buf, sizeof(buf), &amp;tmpStatus);
1124     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1125         if (strict) {
1126             *status = U_ILLEGAL_ARGUMENT_ERROR;
1127         }
1128         return;
1129     }
1130 
1131     if (len &gt; 0) {
1132         char *p, *pVar;
1133         UBool bNext = TRUE;
1134         VariantListEntry *var;
1135         VariantListEntry *varFirst = NULL;
1136 
1137         pVar = NULL;
1138         p = buf;
1139         while (bNext) {
1140             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
1141                 if (*p == 0) {
1142                     bNext = FALSE;
1143                 } else {
1144                     *p = 0; /* terminate */
1145                 }
1146                 if (pVar == NULL) {
1147                     if (strict) {
1148                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1149                         break;
1150                     }
1151                     /* ignore empty variant */
1152                 } else {
1153                     /* ICU uses upper case letters for variants, but
1154                        the canonical format is lowercase in BCP47 */
1155                     for (i = 0; *(pVar + i) != 0; i++) {
1156                         *(pVar + i) = uprv_tolower(*(pVar + i));
1157                     }
1158 
1159                     /* validate */
1160                     if (_isVariantSubtag(pVar, -1)) {
1161                         if (uprv_strcmp(pVar,POSIX_VALUE) || len != (int32_t)uprv_strlen(POSIX_VALUE)) {
1162                             /* emit the variant to the list */
1163                             var = (VariantListEntry*)uprv_malloc(sizeof(VariantListEntry));
1164                             if (var == NULL) {
1165                                 *status = U_MEMORY_ALLOCATION_ERROR;
1166                                 break;
1167                             }
1168                             var-&gt;variant = pVar;
1169                             if (!_addVariantToList(&amp;varFirst, var)) {
1170                                 /* duplicated variant */
1171                                 uprv_free(var);
1172                                 if (strict) {
1173                                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1174                                     break;
1175                                 }
1176                             }
1177                         } else {
1178                             /* Special handling for POSIX variant, need to remember that we had it and then */
1179                             /* treat it like an extension later. */
1180                             *hadPosix = TRUE;
1181                         }
1182                     } else if (strict) {
1183                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1184                         break;
1185                     } else if (_isPrivateuseValueSubtag(pVar, -1)) {
1186                         /* Handle private use subtags separately */
1187                         break;
1188                     }
1189                 }
1190                 /* reset variant starting position */
1191                 pVar = NULL;
1192             } else if (pVar == NULL) {
1193                 pVar = p;
1194             }
1195             p++;
1196         }
1197 
1198         if (U_SUCCESS(*status)) {
1199             if (varFirst != NULL) {
1200                 int32_t varLen;
1201 
1202                 /* write out validated/normalized variants to the target */
1203                 var = varFirst;
1204                 while (var != NULL) {
1205                     sink.Append(&quot;-&quot;, 1);
1206                     varLen = (int32_t)uprv_strlen(var-&gt;variant);
1207                     sink.Append(var-&gt;variant, varLen);
1208                     var = var-&gt;next;
1209                 }
1210             }
1211         }
1212 
1213         /* clean up */
1214         var = varFirst;
1215         while (var != NULL) {
1216             VariantListEntry *tmpVar = var-&gt;next;
1217             uprv_free(var);
1218             var = tmpVar;
1219         }
1220 
1221         if (U_FAILURE(*status)) {
1222             return;
1223         }
1224     }
1225 }
1226 
1227 static void
1228 _appendKeywordsToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UBool hadPosix, UErrorCode* status) {
1229     char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY] = { 0 };
1230     int32_t attrBufLength = 0;
1231 
1232     icu::MemoryPool&lt;AttributeListEntry&gt; attrPool;
1233     icu::MemoryPool&lt;ExtensionListEntry&gt; extPool;
1234     icu::MemoryPool&lt;icu::CharString&gt; strPool;
1235 
1236     icu::LocalUEnumerationPointer keywordEnum(uloc_openKeywords(localeID, status));
1237     if (U_FAILURE(*status) &amp;&amp; !hadPosix) {
1238         return;
1239     }
1240     if (keywordEnum.isValid() || hadPosix) {
1241         /* reorder extensions */
1242         int32_t len;
1243         const char *key;
1244         ExtensionListEntry *firstExt = NULL;
1245         ExtensionListEntry *ext;
1246         AttributeListEntry *firstAttr = NULL;
1247         AttributeListEntry *attr;
1248         icu::MemoryPool&lt;icu::CharString&gt; extBufPool;
1249         const char *bcpKey=nullptr, *bcpValue=nullptr;
1250         UErrorCode tmpStatus = U_ZERO_ERROR;
1251         int32_t keylen;
1252         UBool isBcpUExt;
1253 
1254         while (TRUE) {
1255             icu::CharString buf;
1256             key = uenum_next(keywordEnum.getAlias(), NULL, status);
1257             if (key == NULL) {
1258                 break;
1259             }
1260             char* buffer;
1261             int32_t resultCapacity = ULOC_KEYWORD_AND_VALUES_CAPACITY;
1262 
1263             for (;;) {
1264                 buffer = buf.getAppendBuffer(
1265                         /*minCapacity=*/resultCapacity,
1266                         /*desiredCapacityHint=*/resultCapacity,
1267                         resultCapacity,
1268                         tmpStatus);
1269 
1270                 if (U_FAILURE(tmpStatus)) {
1271                     break;
1272                 }
1273 
1274                 len = uloc_getKeywordValue(
1275                         localeID, key, buffer, resultCapacity, &amp;tmpStatus);
1276 
1277                 if (tmpStatus != U_BUFFER_OVERFLOW_ERROR) {
1278                     break;
1279                 }
1280 
1281                 resultCapacity = len;
1282                 tmpStatus = U_ZERO_ERROR;
1283             }
1284 
1285             if (U_FAILURE(tmpStatus)) {
1286                 if (tmpStatus == U_MEMORY_ALLOCATION_ERROR) {
1287                     *status = U_MEMORY_ALLOCATION_ERROR;
1288                     break;
1289                 }
1290                 if (strict) {
1291                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1292                     break;
1293                 }
1294                 /* ignore this keyword */
1295                 tmpStatus = U_ZERO_ERROR;
1296                 continue;
1297             }
1298 
1299             buf.append(buffer, len, tmpStatus);
1300             if (tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1301                 tmpStatus = U_ZERO_ERROR;  // Terminators provided by CharString.
1302             }
1303 
1304             keylen = (int32_t)uprv_strlen(key);
1305             isBcpUExt = (keylen &gt; 1);
1306 
1307             /* special keyword used for representing Unicode locale attributes */
1308             if (uprv_strcmp(key, LOCALE_ATTRIBUTE_KEY) == 0) {
1309                 if (len &gt; 0) {
1310                     int32_t i = 0;
1311                     while (TRUE) {
1312                         attrBufLength = 0;
1313                         for (; i &lt; len; i++) {
1314                             if (buf[i] != &#39;-&#39;) {
1315                                 attrBuf[attrBufLength++] = buf[i];
1316                             } else {
1317                                 i++;
1318                                 break;
1319                             }
1320                         }
1321                         if (attrBufLength &gt; 0) {
1322                             attrBuf[attrBufLength] = 0;
1323 
1324                         } else if (i &gt;= len){
1325                             break;
1326                         }
1327 
1328                         /* create AttributeListEntry */
1329                         attr = attrPool.create();
1330                         if (attr == NULL) {
1331                             *status = U_MEMORY_ALLOCATION_ERROR;
1332                             break;
1333                         }
1334                         icu::CharString* attrValue =
1335                                 strPool.create(attrBuf, attrBufLength, *status);
1336                         if (attrValue == NULL) {
1337                             *status = U_MEMORY_ALLOCATION_ERROR;
1338                             break;
1339                         }
1340                         if (U_FAILURE(*status)) {
1341                             break;
1342                         }
1343                         attr-&gt;attribute = attrValue-&gt;data();
1344 
1345                         if (!_addAttributeToList(&amp;firstAttr, attr)) {
1346                             if (strict) {
1347                                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1348                                 break;
1349                             }
1350                         }
1351                     }
1352                     /* for a place holder ExtensionListEntry */
1353                     bcpKey = LOCALE_ATTRIBUTE_KEY;
1354                     bcpValue = NULL;
1355                 }
1356             } else if (isBcpUExt) {
1357                 bcpKey = uloc_toUnicodeLocaleKey(key);
1358                 if (bcpKey == NULL) {
1359                     if (strict) {
1360                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1361                         break;
1362                     }
1363                     continue;
1364                 }
1365 
1366                 /* we&#39;ve checked buf is null-terminated above */
1367                 bcpValue = uloc_toUnicodeLocaleType(key, buf.data());
1368                 if (bcpValue == NULL) {
1369                     if (strict) {
1370                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1371                         break;
1372                     }
1373                     continue;
1374                 }
1375                 if (bcpValue == buf.data()) {
1376                     /*
1377                     When uloc_toUnicodeLocaleType(key, buf) returns the
1378                     input value as is, the value is well-formed, but has
1379                     no known mapping. This implementation normalizes the
1380                     value to lower case
1381                     */
1382                     icu::CharString* extBuf = extBufPool.create();
1383                     if (extBuf == nullptr) {
1384                         *status = U_MEMORY_ALLOCATION_ERROR;
1385                         break;
1386                     }
1387                     int32_t bcpValueLen = static_cast&lt;int32_t&gt;(uprv_strlen(bcpValue));
1388                     int32_t resultCapacity;
1389                     char* pExtBuf = extBuf-&gt;getAppendBuffer(
1390                             /*minCapacity=*/bcpValueLen,
1391                             /*desiredCapacityHint=*/bcpValueLen,
1392                             resultCapacity,
1393                             tmpStatus);
1394                     if (U_FAILURE(tmpStatus)) {
1395                         *status = tmpStatus;
1396                         break;
1397                     }
1398 
1399                     uprv_strcpy(pExtBuf, bcpValue);
1400                     T_CString_toLowerCase(pExtBuf);
1401 
1402                     extBuf-&gt;append(pExtBuf, bcpValueLen, tmpStatus);
1403                     if (U_FAILURE(tmpStatus)) {
1404                         *status = tmpStatus;
1405                         break;
1406                     }
1407 
1408                     bcpValue = extBuf-&gt;data();
1409                 }
1410             } else {
1411                 if (*key == PRIVATEUSE) {
1412                     if (!ultag_isPrivateuseValueSubtags(buf.data(), len)) {
1413                         if (strict) {
1414                             *status = U_ILLEGAL_ARGUMENT_ERROR;
1415                             break;
1416                         }
1417                         continue;
1418                     }
1419                 } else {
1420                     if (!_isExtensionSingleton(key, keylen) || !ultag_isExtensionSubtags(buf.data(), len)) {
1421                         if (strict) {
1422                             *status = U_ILLEGAL_ARGUMENT_ERROR;
1423                             break;
1424                         }
1425                         continue;
1426                     }
1427                 }
1428                 bcpKey = key;
1429                 icu::CharString* extBuf =
1430                     extBufPool.create(buf.data(), len, tmpStatus);
1431                 if (extBuf == nullptr) {
1432                     *status = U_MEMORY_ALLOCATION_ERROR;
1433                     break;
1434                 }
1435                 if (U_FAILURE(tmpStatus)) {
1436                     *status = tmpStatus;
1437                     break;
1438                 }
1439                 bcpValue = extBuf-&gt;data();
1440             }
1441 
1442             /* create ExtensionListEntry */
1443             ext = extPool.create();
1444             if (ext == NULL) {
1445                 *status = U_MEMORY_ALLOCATION_ERROR;
1446                 break;
1447             }
1448             ext-&gt;key = bcpKey;
1449             ext-&gt;value = bcpValue;
1450 
1451             if (!_addExtensionToList(&amp;firstExt, ext, TRUE)) {
1452                 if (strict) {
1453                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1454                     break;
1455                 }
1456             }
1457         }
1458 
1459         /* Special handling for POSIX variant - add the keywords for POSIX */
1460         if (hadPosix) {
1461             /* create ExtensionListEntry for POSIX */
1462             ext = extPool.create();
1463             if (ext == NULL) {
1464                 *status = U_MEMORY_ALLOCATION_ERROR;
1465                 return;
1466             }
1467             ext-&gt;key = POSIX_KEY;
1468             ext-&gt;value = POSIX_VALUE;
1469 
1470             if (!_addExtensionToList(&amp;firstExt, ext, TRUE)) {
1471                 // Silently ignore errors.
1472             }
1473         }
1474 
1475         if (U_SUCCESS(*status) &amp;&amp; (firstExt != NULL || firstAttr != NULL)) {
1476             UBool startLDMLExtension = FALSE;
1477             for (ext = firstExt; ext; ext = ext-&gt;next) {
1478                 if (!startLDMLExtension &amp;&amp; uprv_strlen(ext-&gt;key) &gt; 1) {
1479                     /* first LDML u singlton extension */
1480                    sink.Append(&quot;-u&quot;, 2);
1481                    startLDMLExtension = TRUE;
1482                 }
1483 
1484                 /* write out the sorted BCP47 attributes, extensions and private use */
1485                 if (uprv_strcmp(ext-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
1486                     /* write the value for the attributes */
1487                     for (attr = firstAttr; attr; attr = attr-&gt;next) {
1488                         sink.Append(&quot;-&quot;, 1);
1489                         sink.Append(
1490                                 attr-&gt;attribute, static_cast&lt;int32_t&gt;(uprv_strlen(attr-&gt;attribute)));
1491                     }
1492                 } else {
1493                     sink.Append(&quot;-&quot;, 1);
1494                     sink.Append(ext-&gt;key, static_cast&lt;int32_t&gt;(uprv_strlen(ext-&gt;key)));
1495                     sink.Append(&quot;-&quot;, 1);
1496                     sink.Append(ext-&gt;value, static_cast&lt;int32_t&gt;(uprv_strlen(ext-&gt;value)));
1497                 }
1498             }
1499         }
1500     }
1501 }
1502 
1503 /**
1504  * Append keywords parsed from LDML extension value
1505  * e.g. &quot;u-ca-gregory-co-trad&quot; -&gt; {calendar = gregorian} {collation = traditional}
1506  * Note: char* buf is used for storing keywords
1507  */
1508 static void
1509 _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendTo, icu::MemoryPool&lt;ExtensionListEntry&gt;&amp; extPool, icu::MemoryPool&lt;icu::CharString&gt;&amp; kwdBuf, UBool *posixVariant, UErrorCode *status) {
1510     const char *pTag;   /* beginning of current subtag */
1511     const char *pKwds;  /* beginning of key-type pairs */
1512     UBool variantExists = *posixVariant;
1513 
1514     ExtensionListEntry *kwdFirst = NULL;    /* first LDML keyword */
1515     ExtensionListEntry *kwd, *nextKwd;
1516 
1517     int32_t len;
1518 
1519     /* Reset the posixVariant value */
1520     *posixVariant = FALSE;
1521 
1522     pTag = ldmlext;
1523     pKwds = NULL;
1524 
1525     {
1526         AttributeListEntry *attrFirst = NULL;   /* first attribute */
1527         AttributeListEntry *attr, *nextAttr;
1528 
1529         char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
1530         int32_t attrBufIdx = 0;
1531 
1532         icu::MemoryPool&lt;AttributeListEntry&gt; attrPool;
1533 
1534         /* Iterate through u extension attributes */
1535         while (*pTag) {
1536             /* locate next separator char */
1537             for (len = 0; *(pTag + len) &amp;&amp; *(pTag + len) != SEP; len++);
1538 
1539             if (ultag_isUnicodeLocaleKey(pTag, len)) {
1540                 pKwds = pTag;
1541                 break;
1542             }
1543 
1544             /* add this attribute to the list */
1545             attr = attrPool.create();
1546             if (attr == NULL) {
1547                 *status = U_MEMORY_ALLOCATION_ERROR;
1548                 return;
1549             }
1550 
1551             if (len &lt; (int32_t)sizeof(attrBuf) - attrBufIdx) {
1552                 uprv_memcpy(&amp;attrBuf[attrBufIdx], pTag, len);
1553                 attrBuf[attrBufIdx + len] = 0;
1554                 attr-&gt;attribute = &amp;attrBuf[attrBufIdx];
1555                 attrBufIdx += (len + 1);
1556             } else {
1557                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1558                 return;
1559             }
1560 
1561             if (!_addAttributeToList(&amp;attrFirst, attr)) {
1562                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1563                 return;
1564             }
1565 
1566             /* next tag */
1567             pTag += len;
1568             if (*pTag) {
1569                 /* next to the separator */
1570                 pTag++;
1571             }
1572         }
1573 
1574         if (attrFirst) {
1575             /* emit attributes as an LDML keyword, e.g. attribute=attr1-attr2 */
1576 
1577             kwd = extPool.create();
1578             if (kwd == NULL) {
1579                 *status = U_MEMORY_ALLOCATION_ERROR;
1580                 return;
1581             }
1582 
1583             icu::CharString* value = kwdBuf.create();
1584             if (value == NULL) {
1585                 *status = U_MEMORY_ALLOCATION_ERROR;
1586                 return;
1587             }
1588 
1589             /* attribute subtags sorted in alphabetical order as type */
1590             attr = attrFirst;
1591             while (attr != NULL) {
1592                 nextAttr = attr-&gt;next;
1593                 if (attr != attrFirst) {
1594                     value-&gt;append(&#39;-&#39;, *status);
1595                 }
1596                 value-&gt;append(attr-&gt;attribute, *status);
1597                 attr = nextAttr;
1598             }
1599             if (U_FAILURE(*status)) {
1600                 return;
1601             }
1602 
1603             kwd-&gt;key = LOCALE_ATTRIBUTE_KEY;
1604             kwd-&gt;value = value-&gt;data();
1605 
1606             if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
1607                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1608                 return;
1609             }
1610         }
1611     }
1612 
1613     if (pKwds) {
1614         const char *pBcpKey = NULL;     /* u extenstion key subtag */
1615         const char *pBcpType = NULL;    /* beginning of u extension type subtag(s) */
1616         int32_t bcpKeyLen = 0;
1617         int32_t bcpTypeLen = 0;
1618         UBool isDone = FALSE;
1619 
1620         pTag = pKwds;
1621         /* BCP47 representation of LDML key/type pairs */
1622         while (!isDone) {
1623             const char *pNextBcpKey = NULL;
1624             int32_t nextBcpKeyLen = 0;
1625             UBool emitKeyword = FALSE;
1626 
1627             if (*pTag) {
1628                 /* locate next separator char */
1629                 for (len = 0; *(pTag + len) &amp;&amp; *(pTag + len) != SEP; len++);
1630 
1631                 if (ultag_isUnicodeLocaleKey(pTag, len)) {
1632                     if (pBcpKey) {
1633                         emitKeyword = TRUE;
1634                         pNextBcpKey = pTag;
1635                         nextBcpKeyLen = len;
1636                     } else {
1637                         pBcpKey = pTag;
1638                         bcpKeyLen = len;
1639                     }
1640                 } else {
1641                     U_ASSERT(pBcpKey != NULL);
1642                     /* within LDML type subtags */
1643                     if (pBcpType) {
1644                         bcpTypeLen += (len + 1);
1645                     } else {
1646                         pBcpType = pTag;
1647                         bcpTypeLen = len;
1648                     }
1649                 }
1650 
1651                 /* next tag */
1652                 pTag += len;
1653                 if (*pTag) {
1654                     /* next to the separator */
1655                     pTag++;
1656                 }
1657             } else {
1658                 /* processing last one */
1659                 emitKeyword = TRUE;
1660                 isDone = TRUE;
1661             }
1662 
1663             if (emitKeyword) {
1664                 const char *pKey = NULL;    /* LDML key */
1665                 const char *pType = NULL;   /* LDML type */
1666 
1667                 char bcpKeyBuf[9];          /* BCP key length is always 2 for now */
1668 
1669                 U_ASSERT(pBcpKey != NULL);
1670 
1671                 if (bcpKeyLen &gt;= (int32_t)sizeof(bcpKeyBuf)) {
1672                     /* the BCP key is invalid */
1673                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1674                     return;
1675                 }
1676 
1677                 uprv_strncpy(bcpKeyBuf, pBcpKey, bcpKeyLen);
1678                 bcpKeyBuf[bcpKeyLen] = 0;
1679 
1680                 /* u extension key to LDML key */
1681                 pKey = uloc_toLegacyKey(bcpKeyBuf);
1682                 if (pKey == NULL) {
1683                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1684                     return;
1685                 }
1686                 if (pKey == bcpKeyBuf) {
1687                     /*
1688                     The key returned by toLegacyKey points to the input buffer.
1689                     We normalize the result key to lower case.
1690                     */
1691                     T_CString_toLowerCase(bcpKeyBuf);
1692                     icu::CharString* key = kwdBuf.create(bcpKeyBuf, bcpKeyLen, *status);
1693                     if (key == NULL) {
1694                         *status = U_MEMORY_ALLOCATION_ERROR;
1695                         return;
1696                     }
1697                     if (U_FAILURE(*status)) {
1698                         return;
1699                     }
1700                     pKey = key-&gt;data();
1701                 }
1702 
1703                 if (pBcpType) {
1704                     char bcpTypeBuf[128];       /* practically long enough even considering multiple subtag type */
1705                     if (bcpTypeLen &gt;= (int32_t)sizeof(bcpTypeBuf)) {
1706                         /* the BCP type is too long */
1707                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1708                         return;
1709                     }
1710 
1711                     uprv_strncpy(bcpTypeBuf, pBcpType, bcpTypeLen);
1712                     bcpTypeBuf[bcpTypeLen] = 0;
1713 
1714                     /* BCP type to locale type */
1715                     pType = uloc_toLegacyType(pKey, bcpTypeBuf);
1716                     if (pType == NULL) {
1717                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1718                         return;
1719                     }
1720                     if (pType == bcpTypeBuf) {
1721                         /*
1722                         The type returned by toLegacyType points to the input buffer.
1723                         We normalize the result type to lower case.
1724                         */
1725                         /* normalize to lower case */
1726                         T_CString_toLowerCase(bcpTypeBuf);
1727                         icu::CharString* type = kwdBuf.create(bcpTypeBuf, bcpTypeLen, *status);
1728                         if (type == NULL) {
1729                             *status = U_MEMORY_ALLOCATION_ERROR;
1730                             return;
1731                         }
1732                         if (U_FAILURE(*status)) {
1733                             return;
1734                         }
1735                         pType = type-&gt;data();
1736                     }
1737                 } else {
1738                     /* typeless - default type value is &quot;yes&quot; */
1739                     pType = LOCALE_TYPE_YES;
1740                 }
1741 
1742                 /* Special handling for u-va-posix, since we want to treat this as a variant,
1743                    not as a keyword */
1744                 if (!variantExists &amp;&amp; !uprv_strcmp(pKey, POSIX_KEY) &amp;&amp; !uprv_strcmp(pType, POSIX_VALUE) ) {
1745                     *posixVariant = TRUE;
1746                 } else {
1747                     /* create an ExtensionListEntry for this keyword */
1748                     kwd = extPool.create();
1749                     if (kwd == NULL) {
1750                         *status = U_MEMORY_ALLOCATION_ERROR;
1751                         return;
1752                     }
1753 
1754                     kwd-&gt;key = pKey;
1755                     kwd-&gt;value = pType;
1756 
1757                     if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
1758                         // duplicate keyword is allowed, Only the first
1759                         // is honored.
1760                     }
1761                 }
1762 
1763                 pBcpKey = pNextBcpKey;
1764                 bcpKeyLen = pNextBcpKey != NULL ? nextBcpKeyLen : 0;
1765                 pBcpType = NULL;
1766                 bcpTypeLen = 0;
1767             }
1768         }
1769     }
1770 
1771     kwd = kwdFirst;
1772     while (kwd != NULL) {
1773         nextKwd = kwd-&gt;next;
1774         _addExtensionToList(appendTo, kwd, FALSE);
1775         kwd = nextKwd;
1776     }
1777 }
1778 
1779 
1780 static void
1781 _appendKeywords(ULanguageTag* langtag, icu::ByteSink&amp; sink, UErrorCode* status) {
1782     int32_t i, n;
1783     int32_t len;
1784     ExtensionListEntry *kwdFirst = NULL;
1785     ExtensionListEntry *kwd;
1786     const char *key, *type;
1787     icu::MemoryPool&lt;ExtensionListEntry&gt; extPool;
1788     icu::MemoryPool&lt;icu::CharString&gt; kwdBuf;
1789     UBool posixVariant = FALSE;
1790 
1791     if (U_FAILURE(*status)) {
1792         return;
1793     }
1794 
1795     /* Determine if variants already exists */
1796     if (ultag_getVariantsSize(langtag)) {
1797         posixVariant = TRUE;
1798     }
1799 
1800     n = ultag_getExtensionsSize(langtag);
1801 
1802     /* resolve locale keywords and reordering keys */
1803     for (i = 0; i &lt; n; i++) {
1804         key = ultag_getExtensionKey(langtag, i);
1805         type = ultag_getExtensionValue(langtag, i);
1806         if (*key == LDMLEXT) {
1807             _appendLDMLExtensionAsKeywords(type, &amp;kwdFirst, extPool, kwdBuf, &amp;posixVariant, status);
1808             if (U_FAILURE(*status)) {
1809                 break;
1810             }
1811         } else {
1812             kwd = extPool.create();
1813             if (kwd == NULL) {
1814                 *status = U_MEMORY_ALLOCATION_ERROR;
1815                 break;
1816             }
1817             kwd-&gt;key = key;
1818             kwd-&gt;value = type;
1819             if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
1820                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1821                 break;
1822             }
1823         }
1824     }
1825 
1826     if (U_SUCCESS(*status)) {
1827         type = ultag_getPrivateUse(langtag);
1828         if ((int32_t)uprv_strlen(type) &gt; 0) {
1829             /* add private use as a keyword */
1830             kwd = extPool.create();
1831             if (kwd == NULL) {
1832                 *status = U_MEMORY_ALLOCATION_ERROR;
1833             } else {
1834                 kwd-&gt;key = PRIVATEUSE_KEY;
1835                 kwd-&gt;value = type;
1836                 if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
1837                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1838                 }
1839             }
1840         }
1841     }
1842 
1843     /* If a POSIX variant was in the extensions, write it out before writing the keywords. */
1844 
1845     if (U_SUCCESS(*status) &amp;&amp; posixVariant) {
1846         len = (int32_t) uprv_strlen(_POSIX);
1847         sink.Append(_POSIX, len);
1848     }
1849 
1850     if (U_SUCCESS(*status) &amp;&amp; kwdFirst != NULL) {
1851         /* write out the sorted keywords */
1852         UBool firstValue = TRUE;
1853         kwd = kwdFirst;
1854         do {
1855             if (firstValue) {
1856                 sink.Append(&quot;@&quot;, 1);
1857                 firstValue = FALSE;
1858             } else {
1859                 sink.Append(&quot;;&quot;, 1);
1860             }
1861 
1862             /* key */
1863             len = (int32_t)uprv_strlen(kwd-&gt;key);
1864             sink.Append(kwd-&gt;key, len);
1865             sink.Append(&quot;=&quot;, 1);
1866 
1867             /* type */
1868             len = (int32_t)uprv_strlen(kwd-&gt;value);
1869             sink.Append(kwd-&gt;value, len);
1870 
1871             kwd = kwd-&gt;next;
1872         } while (kwd);
1873     }
1874 }
1875 
1876 static void
1877 _appendPrivateuseToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UBool hadPosix, UErrorCode* status) {
1878     (void)hadPosix;
1879     char buf[ULOC_FULLNAME_CAPACITY];
1880     char tmpAppend[ULOC_FULLNAME_CAPACITY];
1881     UErrorCode tmpStatus = U_ZERO_ERROR;
1882     int32_t len, i;
1883     int32_t reslen = 0;
1884     int32_t capacity = sizeof tmpAppend;
1885 
1886     if (U_FAILURE(*status)) {
1887         return;
1888     }
1889 
1890     len = uloc_getVariant(localeID, buf, sizeof(buf), &amp;tmpStatus);
1891     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1892         if (strict) {
1893             *status = U_ILLEGAL_ARGUMENT_ERROR;
1894         }
1895         return;
1896     }
1897 
1898     if (len &gt; 0) {
1899         char *p, *pPriv;
1900         UBool bNext = TRUE;
1901         UBool firstValue = TRUE;
1902         UBool writeValue;
1903 
1904         pPriv = NULL;
1905         p = buf;
1906         while (bNext) {
1907             writeValue = FALSE;
1908             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
1909                 if (*p == 0) {
1910                     bNext = FALSE;
1911                 } else {
1912                     *p = 0; /* terminate */
1913                 }
1914                 if (pPriv != NULL) {
1915                     /* Private use in the canonical format is lowercase in BCP47 */
1916                     for (i = 0; *(pPriv + i) != 0; i++) {
1917                         *(pPriv + i) = uprv_tolower(*(pPriv + i));
1918                     }
1919 
1920                     /* validate */
1921                     if (_isPrivateuseValueSubtag(pPriv, -1)) {
1922                         if (firstValue) {
1923                             if (!_isVariantSubtag(pPriv, -1)) {
1924                                 writeValue = TRUE;
1925                             }
1926                         } else {
1927                             writeValue = TRUE;
1928                         }
1929                     } else if (strict) {
1930                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1931                         break;
1932                     } else {
1933                         break;
1934                     }
1935 
1936                     if (writeValue) {
1937                         if (reslen &lt; capacity) {
1938                             tmpAppend[reslen++] = SEP;
1939                         }
1940 
1941                         if (firstValue) {
1942                             if (reslen &lt; capacity) {
1943                                 tmpAppend[reslen++] = *PRIVATEUSE_KEY;
1944                             }
1945 
1946                             if (reslen &lt; capacity) {
1947                                 tmpAppend[reslen++] = SEP;
1948                             }
1949 
1950                             len = (int32_t)uprv_strlen(PRIVUSE_VARIANT_PREFIX);
1951                             if (reslen &lt; capacity) {
1952                                 uprv_memcpy(tmpAppend + reslen, PRIVUSE_VARIANT_PREFIX, uprv_min(len, capacity - reslen));
1953                             }
1954                             reslen += len;
1955 
1956                             if (reslen &lt; capacity) {
1957                                 tmpAppend[reslen++] = SEP;
1958                             }
1959 
1960                             firstValue = FALSE;
1961                         }
1962 
1963                         len = (int32_t)uprv_strlen(pPriv);
1964                         if (reslen &lt; capacity) {
1965                             uprv_memcpy(tmpAppend + reslen, pPriv, uprv_min(len, capacity - reslen));
1966                         }
1967                         reslen += len;
1968                     }
1969                 }
1970                 /* reset private use starting position */
1971                 pPriv = NULL;
1972             } else if (pPriv == NULL) {
1973                 pPriv = p;
1974             }
1975             p++;
1976         }
1977 
1978         if (U_FAILURE(*status)) {
1979             return;
1980         }
1981     }
1982 
1983     if (U_SUCCESS(*status)) {
1984         len = reslen;
1985         sink.Append(tmpAppend, len);
1986     }
1987 }
1988 
1989 /*
1990 * -------------------------------------------------
1991 *
1992 * ultag_ functions
1993 *
1994 * -------------------------------------------------
1995 */
1996 
1997 /* Bit flags used by the parser */
1998 #define LANG 0x0001
1999 #define EXTL 0x0002
2000 #define SCRT 0x0004
2001 #define REGN 0x0008
2002 #define VART 0x0010
2003 #define EXTS 0x0020
2004 #define EXTV 0x0040
2005 #define PRIV 0x0080
2006 
2007 /**
2008  * Ticket #12705 - Visual Studio 2015 Update 3 contains a new code optimizer which has problems optimizing
2009  * this function. (See https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/ )
2010  * As a workaround, we will turn off optimization just for this function on VS2015 Update 3 and above.
2011  */
2012 #if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 190024210))
2013 #pragma optimize( &quot;&quot;, off )
2014 #endif
2015 
2016 static ULanguageTag*
2017 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status) {
2018     char *tagBuf;
2019     int16_t next;
2020     char *pSubtag, *pNext, *pLastGoodPosition;
2021     int32_t subtagLen;
2022     int32_t extlangIdx;
2023     ExtensionListEntry *pExtension;
2024     char *pExtValueSubtag, *pExtValueSubtagEnd;
2025     int32_t i;
2026     UBool privateuseVar = FALSE;
2027     int32_t grandfatheredLen = 0;
2028 
2029     if (parsedLen != NULL) {
2030         *parsedLen = 0;
2031     }
2032 
2033     if (U_FAILURE(*status)) {
2034         return NULL;
2035     }
2036 
2037     if (tagLen &lt; 0) {
2038         tagLen = (int32_t)uprv_strlen(tag);
2039     }
2040 
2041     /* copy the entire string */
2042     tagBuf = (char*)uprv_malloc(tagLen + 1);
2043     if (tagBuf == NULL) {
2044         *status = U_MEMORY_ALLOCATION_ERROR;
2045         return NULL;
2046     }
2047     uprv_memcpy(tagBuf, tag, tagLen);
2048     *(tagBuf + tagLen) = 0;
2049 
2050     /* create a ULanguageTag */
2051     icu::LocalULanguageTagPointer t(
2052             (ULanguageTag*)uprv_malloc(sizeof(ULanguageTag)));
2053     if (t.isNull()) {
2054         uprv_free(tagBuf);
2055         *status = U_MEMORY_ALLOCATION_ERROR;
2056         return NULL;
2057     }
2058     _initializeULanguageTag(t.getAlias());
2059     t-&gt;buf = tagBuf;
2060 
2061     if (tagLen &lt; MINLEN) {
2062         /* the input tag is too short - return empty ULanguageTag */
2063         return t.orphan();
2064     }
2065 
2066     size_t parsedLenDelta = 0;
2067     // Grandfathered tag will be consider together. Grandfathered tag with intervening
2068     // script and region such as art-DE-lojban or art-Latn-lojban won&#39;t be
2069     // matched.
2070     /* check if the tag is grandfathered */
2071     for (i = 0; i &lt; UPRV_LENGTHOF(GRANDFATHERED); i += 2) {
2072         int32_t checkGrandfatheredLen = static_cast&lt;int32_t&gt;(uprv_strlen(GRANDFATHERED[i]));
2073         if (tagLen &lt; checkGrandfatheredLen) {
2074             continue;
2075         }
2076         if (tagLen &gt; checkGrandfatheredLen &amp;&amp; tagBuf[checkGrandfatheredLen] != &#39;-&#39;) {
2077             // make sure next char is &#39;-&#39;.
2078             continue;
2079         }
2080         if (uprv_strnicmp(GRANDFATHERED[i], tagBuf, checkGrandfatheredLen) == 0) {
2081             int32_t newTagLength;
2082 
2083             grandfatheredLen = checkGrandfatheredLen;  /* back up for output parsedLen */
2084             int32_t replacementLen = static_cast&lt;int32_t&gt;(uprv_strlen(GRANDFATHERED[i+1]));
2085             newTagLength = replacementLen + tagLen - checkGrandfatheredLen;
2086             if (tagLen &lt; newTagLength) {
2087                 uprv_free(tagBuf);
2088                 tagBuf = (char*)uprv_malloc(newTagLength + 1);
2089                 if (tagBuf == NULL) {
2090                     *status = U_MEMORY_ALLOCATION_ERROR;
2091                     return NULL;
2092                 }
2093                 t-&gt;buf = tagBuf;
2094                 tagLen = newTagLength;
2095             }
2096             parsedLenDelta = checkGrandfatheredLen - replacementLen;
2097             uprv_strcpy(t-&gt;buf, GRANDFATHERED[i + 1]);
2098             if (checkGrandfatheredLen != tagLen) {
2099                 uprv_strcpy(t-&gt;buf + replacementLen, tag + checkGrandfatheredLen);
2100             }
2101             break;
2102         }
2103     }
2104 
2105     if (grandfatheredLen == 0) {
2106         for (i = 0; i &lt; UPRV_LENGTHOF(REDUNDANT); i += 2) {
2107             const char* redundantTag = REDUNDANT[i];
2108             size_t redundantTagLen = uprv_strlen(redundantTag);
2109             // The preferred tag for a redundant tag is always shorter than redundant
2110             // tag. A redundant tag may or may not be followed by other subtags.
2111             // (i.e. &quot;zh-yue&quot; or &quot;zh-yue-u-co-pinyin&quot;).
2112             if (uprv_strnicmp(redundantTag, tagBuf, static_cast&lt;uint32_t&gt;(redundantTagLen)) == 0) {
2113                 const char* redundantTagEnd = tagBuf + redundantTagLen;
2114                 if (*redundantTagEnd  == &#39;\0&#39; || *redundantTagEnd == SEP) {
2115                     const char* preferredTag = REDUNDANT[i + 1];
2116                     size_t preferredTagLen = uprv_strlen(preferredTag);
2117                     uprv_strncpy(t-&gt;buf, preferredTag, preferredTagLen);
2118                     if (*redundantTagEnd == SEP) {
2119                         uprv_memmove(tagBuf + preferredTagLen,
2120                                      redundantTagEnd,
2121                                      tagLen - redundantTagLen + 1);
2122                     } else {
2123                         tagBuf[preferredTagLen] = &#39;\0&#39;;
2124                     }
2125                     // parsedLen should be the length of the input
2126                     // before redundantTag is replaced by preferredTag.
2127                     // Save the delta to add it back later.
2128                     parsedLenDelta = redundantTagLen - preferredTagLen;
2129                     break;
2130                 }
2131             }
2132         }
2133     }
2134 
2135     /*
2136      * langtag      =   language
2137      *                  [&quot;-&quot; script]
2138      *                  [&quot;-&quot; region]
2139      *                  *(&quot;-&quot; variant)
2140      *                  *(&quot;-&quot; extension)
2141      *                  [&quot;-&quot; privateuse]
2142      */
2143 
2144     next = LANG | PRIV;
2145     pNext = pLastGoodPosition = tagBuf;
2146     extlangIdx = 0;
2147     pExtension = NULL;
2148     pExtValueSubtag = NULL;
2149     pExtValueSubtagEnd = NULL;
2150 
2151     while (pNext) {
2152         char *pSep;
2153 
2154         pSubtag = pNext;
2155 
2156         /* locate next separator char */
2157         pSep = pSubtag;
2158         while (*pSep) {
2159             if (*pSep == SEP) {
2160                 break;
2161             }
2162             pSep++;
2163         }
2164         if (*pSep == 0) {
2165             /* last subtag */
2166             pNext = NULL;
2167         } else {
2168             pNext = pSep + 1;
2169         }
2170         subtagLen = (int32_t)(pSep - pSubtag);
2171 
2172         if (next &amp; LANG) {
2173             if (ultag_isLanguageSubtag(pSubtag, subtagLen)) {
2174                 *pSep = 0;  /* terminate */
2175                 // TODO: move deprecated language code handling here.
2176                 t-&gt;language = T_CString_toLowerCase(pSubtag);
2177 
2178                 pLastGoodPosition = pSep;
2179                 next = SCRT | REGN | VART | EXTS | PRIV;
2180                 if (subtagLen &lt;= 3)
2181                   next |= EXTL;
2182                 continue;
2183             }
2184         }
2185         if (next &amp; EXTL) {
2186             if (_isExtlangSubtag(pSubtag, subtagLen)) {
2187                 *pSep = 0;
2188                 t-&gt;extlang[extlangIdx++] = T_CString_toLowerCase(pSubtag);
2189 
2190                 pLastGoodPosition = pSep;
2191                 if (extlangIdx &lt; 3) {
2192                     next = EXTL | SCRT | REGN | VART | EXTS | PRIV;
2193                 } else {
2194                     next = SCRT | REGN | VART | EXTS | PRIV;
2195                 }
2196                 continue;
2197             }
2198         }
2199         if (next &amp; SCRT) {
2200             if (ultag_isScriptSubtag(pSubtag, subtagLen)) {
2201                 char *p = pSubtag;
2202 
2203                 *pSep = 0;
2204 
2205                 /* to title case */
2206                 *p = uprv_toupper(*p);
2207                 p++;
2208                 for (; *p; p++) {
2209                     *p = uprv_tolower(*p);
2210                 }
2211 
2212                 t-&gt;script = pSubtag;
2213 
2214                 pLastGoodPosition = pSep;
2215                 next = REGN | VART | EXTS | PRIV;
2216                 continue;
2217             }
2218         }
2219         if (next &amp; REGN) {
2220             if (ultag_isRegionSubtag(pSubtag, subtagLen)) {
2221                 *pSep = 0;
2222                 // TODO: move deprecated region code handling here.
2223                 t-&gt;region = T_CString_toUpperCase(pSubtag);
2224 
2225                 pLastGoodPosition = pSep;
2226                 next = VART | EXTS | PRIV;
2227                 continue;
2228             }
2229         }
2230         if (next &amp; VART) {
2231             if (_isVariantSubtag(pSubtag, subtagLen) ||
2232                (privateuseVar &amp;&amp; _isPrivateuseVariantSubtag(pSubtag, subtagLen))) {
2233                 VariantListEntry *var;
2234                 UBool isAdded;
2235 
2236                 var = (VariantListEntry*)uprv_malloc(sizeof(VariantListEntry));
2237                 if (var == NULL) {
2238                     *status = U_MEMORY_ALLOCATION_ERROR;
2239                     return NULL;
2240                 }
2241                 *pSep = 0;
2242                 var-&gt;variant = T_CString_toUpperCase(pSubtag);
2243                 isAdded = _addVariantToList(&amp;(t-&gt;variants), var);
2244                 if (!isAdded) {
2245                     /* duplicated variant entry */
2246                     uprv_free(var);
2247                     break;
2248                 }
2249                 pLastGoodPosition = pSep;
2250                 next = VART | EXTS | PRIV;
2251                 continue;
2252             }
2253         }
2254         if (next &amp; EXTS) {
2255             if (_isExtensionSingleton(pSubtag, subtagLen)) {
2256                 if (pExtension != NULL) {
2257                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2258                         /* the previous extension is incomplete */
2259                         uprv_free(pExtension);
2260                         pExtension = NULL;
2261                         break;
2262                     }
2263 
2264                     /* terminate the previous extension value */
2265                     *pExtValueSubtagEnd = 0;
2266                     pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2267 
2268                     /* insert the extension to the list */
2269                     if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2270                         pLastGoodPosition = pExtValueSubtagEnd;
2271                     } else {
2272                         /* stop parsing here */
2273                         uprv_free(pExtension);
2274                         pExtension = NULL;
2275                         break;
2276                     }
2277                 }
2278 
2279                 /* create a new extension */
2280                 pExtension = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
2281                 if (pExtension == NULL) {
2282                     *status = U_MEMORY_ALLOCATION_ERROR;
2283                     return NULL;
2284                 }
2285                 *pSep = 0;
2286                 pExtension-&gt;key = T_CString_toLowerCase(pSubtag);
2287                 pExtension-&gt;value = NULL;   /* will be set later */
2288 
2289                 /*
2290                  * reset the start and the end location of extension value
2291                  * subtags for this extension
2292                  */
2293                 pExtValueSubtag = NULL;
2294                 pExtValueSubtagEnd = NULL;
2295 
2296                 next = EXTV;
2297                 continue;
2298             }
2299         }
2300         if (next &amp; EXTV) {
2301             if (_isExtensionSubtag(pSubtag, subtagLen)) {
2302                 if (pExtValueSubtag == NULL) {
2303                     /* if the start postion of this extension&#39;s value is not yet,
2304                         this one is the first value subtag */
2305                     pExtValueSubtag = pSubtag;
2306                 }
2307 
2308                 /* Mark the end of this subtag */
2309                 pExtValueSubtagEnd = pSep;
2310                 next = EXTS | EXTV | PRIV;
2311 
2312                 continue;
2313             }
2314         }
2315         if (next &amp; PRIV) {
2316             if (uprv_tolower(*pSubtag) == PRIVATEUSE &amp;&amp; subtagLen == 1) {
2317                 char *pPrivuseVal;
2318 
2319                 if (pExtension != NULL) {
2320                     /* Process the last extension */
2321                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2322                         /* the previous extension is incomplete */
2323                         uprv_free(pExtension);
2324                         pExtension = NULL;
2325                         break;
2326                     } else {
2327                         /* terminate the previous extension value */
2328                         *pExtValueSubtagEnd = 0;
2329                         pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2330 
2331                         /* insert the extension to the list */
2332                         if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2333                             pLastGoodPosition = pExtValueSubtagEnd;
2334                             pExtension = NULL;
2335                         } else {
2336                         /* stop parsing here */
2337                             uprv_free(pExtension);
2338                             pExtension = NULL;
2339                             break;
2340                         }
2341                     }
2342                 }
2343 
2344                 /* The rest of part will be private use value subtags */
2345                 if (pNext == NULL) {
2346                     /* empty private use subtag */
2347                     break;
2348                 }
2349                 /* back up the private use value start position */
2350                 pPrivuseVal = pNext;
2351 
2352                 /* validate private use value subtags */
2353                 while (pNext) {
2354                     pSubtag = pNext;
2355                     pSep = pSubtag;
2356                     while (*pSep) {
2357                         if (*pSep == SEP) {
2358                             break;
2359                         }
2360                         pSep++;
2361                     }
2362                     if (*pSep == 0) {
2363                         /* last subtag */
2364                         pNext = NULL;
2365                     } else {
2366                         pNext = pSep + 1;
2367                     }
2368                     subtagLen = (int32_t)(pSep - pSubtag);
2369 
2370                     if (uprv_strncmp(pSubtag, PRIVUSE_VARIANT_PREFIX, uprv_strlen(PRIVUSE_VARIANT_PREFIX)) == 0) {
2371                         *pSep = 0;
2372                         next = VART;
2373                         privateuseVar = TRUE;
2374                         break;
2375                     } else if (_isPrivateuseValueSubtag(pSubtag, subtagLen)) {
2376                         pLastGoodPosition = pSep;
2377                     } else {
2378                         break;
2379                     }
2380                 }
2381 
2382                 if (next == VART) {
2383                     continue;
2384                 }
2385 
2386                 if (pLastGoodPosition - pPrivuseVal &gt; 0) {
2387                     *pLastGoodPosition = 0;
2388                     t-&gt;privateuse = T_CString_toLowerCase(pPrivuseVal);
2389                 }
2390                 /* No more subtags, exiting the parse loop */
2391                 break;
2392             }
2393             break;
2394         }
2395 
2396         /* If we fell through here, it means this subtag is illegal - quit parsing */
2397         break;
2398     }
2399 
2400     if (pExtension != NULL) {
2401         /* Process the last extension */
2402         if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2403             /* the previous extension is incomplete */
2404             uprv_free(pExtension);
2405         } else {
2406             /* terminate the previous extension value */
2407             *pExtValueSubtagEnd = 0;
2408             pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2409             /* insert the extension to the list */
2410             if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2411                 pLastGoodPosition = pExtValueSubtagEnd;
2412             } else {
2413                 uprv_free(pExtension);
2414             }
2415         }
2416     }
2417 
2418     if (parsedLen != NULL) {
2419         *parsedLen = (int32_t)(pLastGoodPosition - t-&gt;buf + parsedLenDelta);
2420     }
2421 
2422     return t.orphan();
2423 }
2424 
2425 /**
2426 * Ticket #12705 - Turn optimization back on.
2427 */
2428 #if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 190024210))
2429 #pragma optimize( &quot;&quot;, on )
2430 #endif
2431 
2432 static void
2433 ultag_close(ULanguageTag* langtag) {
2434 
2435     if (langtag == NULL) {
2436         return;
2437     }
2438 
2439     uprv_free(langtag-&gt;buf);
2440 
2441     if (langtag-&gt;variants) {
2442         VariantListEntry *curVar = langtag-&gt;variants;
2443         while (curVar) {
2444             VariantListEntry *nextVar = curVar-&gt;next;
2445             uprv_free(curVar);
2446             curVar = nextVar;
2447         }
2448     }
2449 
2450     if (langtag-&gt;extensions) {
2451         ExtensionListEntry *curExt = langtag-&gt;extensions;
2452         while (curExt) {
2453             ExtensionListEntry *nextExt = curExt-&gt;next;
2454             uprv_free(curExt);
2455             curExt = nextExt;
2456         }
2457     }
2458 
2459     uprv_free(langtag);
2460 }
2461 
2462 static const char*
2463 ultag_getLanguage(const ULanguageTag* langtag) {
2464     return langtag-&gt;language;
2465 }
2466 
2467 #if 0
2468 static const char*
2469 ultag_getJDKLanguage(const ULanguageTag* langtag) {
2470     int32_t i;
2471     for (i = 0; DEPRECATEDLANGS[i] != NULL; i += 2) {
2472         if (uprv_compareInvCharsAsAscii(DEPRECATEDLANGS[i], langtag-&gt;language) == 0) {
2473             return DEPRECATEDLANGS[i + 1];
2474         }
2475     }
2476     return langtag-&gt;language;
2477 }
2478 #endif
2479 
2480 static const char*
2481 ultag_getExtlang(const ULanguageTag* langtag, int32_t idx) {
2482     if (idx &gt;= 0 &amp;&amp; idx &lt; MAXEXTLANG) {
2483         return langtag-&gt;extlang[idx];
2484     }
2485     return NULL;
2486 }
2487 
2488 static int32_t
2489 ultag_getExtlangSize(const ULanguageTag* langtag) {
2490     int32_t size = 0;
2491     int32_t i;
2492     for (i = 0; i &lt; MAXEXTLANG; i++) {
2493         if (langtag-&gt;extlang[i]) {
2494             size++;
2495         }
2496     }
2497     return size;
2498 }
2499 
2500 static const char*
2501 ultag_getScript(const ULanguageTag* langtag) {
2502     return langtag-&gt;script;
2503 }
2504 
2505 static const char*
2506 ultag_getRegion(const ULanguageTag* langtag) {
2507     return langtag-&gt;region;
2508 }
2509 
2510 static const char*
2511 ultag_getVariant(const ULanguageTag* langtag, int32_t idx) {
2512     const char *var = NULL;
2513     VariantListEntry *cur = langtag-&gt;variants;
2514     int32_t i = 0;
2515     while (cur) {
2516         if (i == idx) {
2517             var = cur-&gt;variant;
2518             break;
2519         }
2520         cur = cur-&gt;next;
2521         i++;
2522     }
2523     return var;
2524 }
2525 
2526 static int32_t
2527 ultag_getVariantsSize(const ULanguageTag* langtag) {
2528     int32_t size = 0;
2529     VariantListEntry *cur = langtag-&gt;variants;
2530     while (TRUE) {
2531         if (cur == NULL) {
2532             break;
2533         }
2534         size++;
2535         cur = cur-&gt;next;
2536     }
2537     return size;
2538 }
2539 
2540 static const char*
2541 ultag_getExtensionKey(const ULanguageTag* langtag, int32_t idx) {
2542     const char *key = NULL;
2543     ExtensionListEntry *cur = langtag-&gt;extensions;
2544     int32_t i = 0;
2545     while (cur) {
2546         if (i == idx) {
2547             key = cur-&gt;key;
2548             break;
2549         }
2550         cur = cur-&gt;next;
2551         i++;
2552     }
2553     return key;
2554 }
2555 
2556 static const char*
2557 ultag_getExtensionValue(const ULanguageTag* langtag, int32_t idx) {
2558     const char *val = NULL;
2559     ExtensionListEntry *cur = langtag-&gt;extensions;
2560     int32_t i = 0;
2561     while (cur) {
2562         if (i == idx) {
2563             val = cur-&gt;value;
2564             break;
2565         }
2566         cur = cur-&gt;next;
2567         i++;
2568     }
2569     return val;
2570 }
2571 
2572 static int32_t
2573 ultag_getExtensionsSize(const ULanguageTag* langtag) {
2574     int32_t size = 0;
2575     ExtensionListEntry *cur = langtag-&gt;extensions;
2576     while (TRUE) {
2577         if (cur == NULL) {
2578             break;
2579         }
2580         size++;
2581         cur = cur-&gt;next;
2582     }
2583     return size;
2584 }
2585 
2586 static const char*
2587 ultag_getPrivateUse(const ULanguageTag* langtag) {
2588     return langtag-&gt;privateuse;
2589 }
2590 
2591 #if 0
2592 static const char*
2593 ultag_getGrandfathered(const ULanguageTag* langtag) {
2594     return langtag-&gt;grandfathered;
2595 }
2596 #endif
2597 
2598 
2599 /*
2600 * -------------------------------------------------
2601 *
2602 * Locale/BCP47 conversion APIs, exposed as uloc_*
2603 *
2604 * -------------------------------------------------
2605 */
2606 U_CAPI int32_t U_EXPORT2
2607 uloc_toLanguageTag(const char* localeID,
2608                    char* langtag,
2609                    int32_t langtagCapacity,
2610                    UBool strict,
2611                    UErrorCode* status) {
2612     if (U_FAILURE(*status)) {
2613         return 0;
2614     }
2615 
2616     icu::CheckedArrayByteSink sink(langtag, langtagCapacity);
2617     ulocimp_toLanguageTag(localeID, sink, strict, status);
2618 
2619     int32_t reslen = sink.NumberOfBytesAppended();
2620 
2621     if (U_FAILURE(*status)) {
2622         return reslen;
2623     }
2624 
2625     if (sink.Overflowed()) {
2626         *status = U_BUFFER_OVERFLOW_ERROR;
2627     } else {
2628         u_terminateChars(langtag, langtagCapacity, reslen, status);
2629     }
2630 
2631     return reslen;
2632 }
2633 
2634 
2635 U_CAPI void U_EXPORT2
2636 ulocimp_toLanguageTag(const char* localeID,
2637                       icu::ByteSink&amp; sink,
2638                       UBool strict,
2639                       UErrorCode* status) {
2640     icu::CharString canonical;
2641     int32_t reslen;
2642     UErrorCode tmpStatus = U_ZERO_ERROR;
2643     UBool hadPosix = FALSE;
2644     const char* pKeywordStart;
2645 
2646     /* Note: uloc_canonicalize returns &quot;en_US_POSIX&quot; for input locale ID &quot;&quot;.  See #6835 */
2647     int32_t resultCapacity = static_cast&lt;int32_t&gt;(uprv_strlen(localeID));
2648     if (resultCapacity &gt; 0) {
2649         char* buffer;
2650 
2651         for (;;) {
2652             buffer = canonical.getAppendBuffer(
2653                     /*minCapacity=*/resultCapacity,
2654                     /*desiredCapacityHint=*/resultCapacity,
2655                     resultCapacity,
2656                     tmpStatus);
2657 
2658             if (U_FAILURE(tmpStatus)) {
2659                 *status = tmpStatus;
2660                 return;
2661             }
2662 
2663             reslen =
2664                 uloc_canonicalize(localeID, buffer, resultCapacity, &amp;tmpStatus);
2665 
2666             if (tmpStatus != U_BUFFER_OVERFLOW_ERROR) {
2667                 break;
2668             }
2669 
2670             resultCapacity = reslen;
2671             tmpStatus = U_ZERO_ERROR;
2672         }
2673 
2674         if (U_FAILURE(tmpStatus)) {
2675             *status = U_ILLEGAL_ARGUMENT_ERROR;
2676             return;
2677         }
2678 
2679         canonical.append(buffer, reslen, tmpStatus);
2680         if (tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
2681             tmpStatus = U_ZERO_ERROR;  // Terminators provided by CharString.
2682         }
2683 
2684         if (U_FAILURE(tmpStatus)) {
2685             *status = tmpStatus;
2686             return;
2687         }
2688     }
2689 
2690     /* For handling special case - private use only tag */
2691     pKeywordStart = locale_getKeywordsStart(canonical.data());
2692     if (pKeywordStart == canonical.data()) {
2693         int kwdCnt = 0;
2694         UBool done = FALSE;
2695 
2696         icu::LocalUEnumerationPointer kwdEnum(uloc_openKeywords(canonical.data(), &amp;tmpStatus));
2697         if (U_SUCCESS(tmpStatus)) {
2698             kwdCnt = uenum_count(kwdEnum.getAlias(), &amp;tmpStatus);
2699             if (kwdCnt == 1) {
2700                 const char *key;
2701                 int32_t len = 0;
2702 
2703                 key = uenum_next(kwdEnum.getAlias(), &amp;len, &amp;tmpStatus);
2704                 if (len == 1 &amp;&amp; *key == PRIVATEUSE) {
2705                     char buf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
2706                     buf[0] = PRIVATEUSE;
2707                     buf[1] = SEP;
2708                     len = uloc_getKeywordValue(localeID, key, &amp;buf[2], sizeof(buf) - 2, &amp;tmpStatus);
2709                     if (U_SUCCESS(tmpStatus)) {
2710                         if (ultag_isPrivateuseValueSubtags(&amp;buf[2], len)) {
2711                             /* return private use only tag */
2712                             sink.Append(buf, len + 2);
2713                             done = TRUE;
2714                         } else if (strict) {
2715                             *status = U_ILLEGAL_ARGUMENT_ERROR;
2716                             done = TRUE;
2717                         }
2718                         /* if not strict mode, then &quot;und&quot; will be returned */
2719                     } else {
2720                         *status = U_ILLEGAL_ARGUMENT_ERROR;
2721                         done = TRUE;
2722                     }
2723                 }
2724             }
2725             if (done) {
2726                 return;
2727             }
2728         }
2729     }
2730 
2731     _appendLanguageToLanguageTag(canonical.data(), sink, strict, status);
2732     _appendScriptToLanguageTag(canonical.data(), sink, strict, status);
2733     _appendRegionToLanguageTag(canonical.data(), sink, strict, status);
2734     _appendVariantsToLanguageTag(canonical.data(), sink, strict, &amp;hadPosix, status);
2735     _appendKeywordsToLanguageTag(canonical.data(), sink, strict, hadPosix, status);
2736     _appendPrivateuseToLanguageTag(canonical.data(), sink, strict, hadPosix, status);
2737 }
2738 
2739 
2740 U_CAPI int32_t U_EXPORT2
2741 uloc_forLanguageTag(const char* langtag,
2742                     char* localeID,
2743                     int32_t localeIDCapacity,
2744                     int32_t* parsedLength,
2745                     UErrorCode* status) {
2746     if (U_FAILURE(*status)) {
2747         return 0;
2748     }
2749 
2750     icu::CheckedArrayByteSink sink(localeID, localeIDCapacity);
2751     ulocimp_forLanguageTag(langtag, -1, sink, parsedLength, status);
2752 
2753     int32_t reslen = sink.NumberOfBytesAppended();
2754 
2755     if (U_FAILURE(*status)) {
2756         return reslen;
2757     }
2758 
2759     if (sink.Overflowed()) {
2760         *status = U_BUFFER_OVERFLOW_ERROR;
2761     } else {
2762         u_terminateChars(localeID, localeIDCapacity, reslen, status);
2763     }
2764 
2765     return reslen;
2766 }
2767 
2768 
2769 U_CAPI void U_EXPORT2
2770 ulocimp_forLanguageTag(const char* langtag,
2771                        int32_t tagLen,
2772                        icu::ByteSink&amp; sink,
2773                        int32_t* parsedLength,
2774                        UErrorCode* status) {
2775     UBool isEmpty = TRUE;
2776     const char *subtag, *p;
2777     int32_t len;
2778     int32_t i, n;
2779     UBool noRegion = TRUE;
2780 
2781     icu::LocalULanguageTagPointer lt(ultag_parse(langtag, tagLen, parsedLength, status));
2782     if (U_FAILURE(*status)) {
2783         return;
2784     }
2785 
2786     /* language */
2787     subtag = ultag_getExtlangSize(lt.getAlias()) &gt; 0 ? ultag_getExtlang(lt.getAlias(), 0) : ultag_getLanguage(lt.getAlias());
2788     if (uprv_compareInvCharsAsAscii(subtag, LANG_UND) != 0) {
2789         len = (int32_t)uprv_strlen(subtag);
2790         if (len &gt; 0) {
2791             sink.Append(subtag, len);
2792             isEmpty = FALSE;
2793         }
2794     }
2795 
2796     /* script */
2797     subtag = ultag_getScript(lt.getAlias());
2798     len = (int32_t)uprv_strlen(subtag);
2799     if (len &gt; 0) {
2800         sink.Append(&quot;_&quot;, 1);
2801         isEmpty = FALSE;
2802 
2803         /* write out the script in title case */
2804         char c = uprv_toupper(*subtag);
2805         sink.Append(&amp;c, 1);
2806         sink.Append(subtag + 1, len - 1);
2807     }
2808 
2809     /* region */
2810     subtag = ultag_getRegion(lt.getAlias());
2811     len = (int32_t)uprv_strlen(subtag);
2812     if (len &gt; 0) {
2813         sink.Append(&quot;_&quot;, 1);
2814         isEmpty = FALSE;
2815 
2816         /* write out the region in upper case */
2817         p = subtag;
2818         while (*p) {
2819             char c = uprv_toupper(*p);
2820             sink.Append(&amp;c, 1);
2821             p++;
2822         }
2823         noRegion = FALSE;
2824     }
2825 
2826     /* variants */
2827     n = ultag_getVariantsSize(lt.getAlias());
2828     if (n &gt; 0) {
2829         if (noRegion) {
2830             sink.Append(&quot;_&quot;, 1);
2831             isEmpty = FALSE;
2832         }
2833 
2834         for (i = 0; i &lt; n; i++) {
2835             subtag = ultag_getVariant(lt.getAlias(), i);
2836             sink.Append(&quot;_&quot;, 1);
2837 
2838             /* write out the variant in upper case */
2839             p = subtag;
2840             while (*p) {
2841                 char c = uprv_toupper(*p);
2842                 sink.Append(&amp;c, 1);
2843                 p++;
2844             }
2845         }
2846     }
2847 
2848     /* keywords */
2849     n = ultag_getExtensionsSize(lt.getAlias());
2850     subtag = ultag_getPrivateUse(lt.getAlias());
2851     if (n &gt; 0 || uprv_strlen(subtag) &gt; 0) {
2852         if (isEmpty &amp;&amp; n &gt; 0) {
2853             /* need a language */
2854             sink.Append(LANG_UND, LANG_UND_LEN);
2855         }
2856         _appendKeywords(lt.getAlias(), sink, status);
2857     }
2858 }
    </pre>
  </body>
</html>