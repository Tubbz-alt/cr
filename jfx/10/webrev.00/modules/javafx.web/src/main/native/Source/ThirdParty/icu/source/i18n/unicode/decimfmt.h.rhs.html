<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/decimfmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ********************************************************************************
   5 *   Copyright (C) 1997-2016, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 ********************************************************************************
   8 *
   9 * File DECIMFMT.H
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   02/19/97    aliu        Converted from java.
  15 *   03/20/97    clhuang     Updated per C++ implementation.
  16 *   04/03/97    aliu        Rewrote parsing and formatting completely, and
  17 *                           cleaned up and debugged.  Actually works now.
  18 *   04/17/97    aliu        Changed DigitCount to int per code review.
  19 *   07/10/97    helena      Made ParsePosition a class and get rid of the function
  20 *                           hiding problems.
  21 *   09/09/97    aliu        Ported over support for exponential formats.
  22 *   07/20/98    stephen     Changed documentation
  23 *   01/30/13    emmons      Added Scaling methods
  24 ********************************************************************************
  25 */
  26 
  27 #ifndef DECIMFMT_H
  28 #define DECIMFMT_H
  29 
  30 #include &quot;unicode/utypes.h&quot;
  31 /**
  32  * \file
  33  * \brief C++ API: Compatibility APIs for decimal formatting.
  34  */
  35 
  36 #if !UCONFIG_NO_FORMATTING
  37 
  38 #include &quot;unicode/dcfmtsym.h&quot;
  39 #include &quot;unicode/numfmt.h&quot;
  40 #include &quot;unicode/locid.h&quot;
  41 #include &quot;unicode/fpositer.h&quot;
  42 #include &quot;unicode/stringpiece.h&quot;
  43 #include &quot;unicode/curramt.h&quot;
  44 #include &quot;unicode/enumset.h&quot;
  45 
  46 U_NAMESPACE_BEGIN
  47 
  48 class CurrencyPluralInfo;
  49 class CompactDecimalFormat;
  50 
  51 namespace number {
  52 class LocalizedNumberFormatter;
  53 class FormattedNumber;
  54 namespace impl {
  55 class DecimalQuantity;
  56 struct DecimalFormatFields;
  57 }
  58 }
  59 
  60 namespace numparse {
  61 namespace impl {
  62 class NumberParserImpl;
  63 }
  64 }
  65 
<a name="1" id="anc1"></a>







  66 /**
<a name="2" id="anc2"></a><span class="line-modified">  67  * **IMPORTANT:** New users are strongly encouraged to see if</span>
  68  * numberformatter.h fits their use case.  Although not deprecated, this header
  69  * is provided for backwards compatibility only.
<a name="3" id="anc3"></a>
  70  *
  71  * DecimalFormat is a concrete subclass of NumberFormat that formats decimal
  72  * numbers. It has a variety of features designed to make it possible to parse
  73  * and format numbers in any locale, including support for Western, Arabic, or
  74  * Indic digits.  It also supports different flavors of numbers, including
  75  * integers (&quot;123&quot;), fixed-point numbers (&quot;123.4&quot;), scientific notation
  76  * (&quot;1.23E4&quot;), percentages (&quot;12%&quot;), and currency amounts (&quot;$123&quot;, &quot;USD123&quot;,
  77  * &quot;123 US dollars&quot;).  All of these flavors can be easily localized.
  78  *
<a name="4" id="anc4"></a><span class="line-modified">  79  * To obtain a NumberFormat for a specific locale (including the default</span>
  80  * locale) call one of NumberFormat&#39;s factory methods such as
  81  * createInstance(). Do not call the DecimalFormat constructors directly, unless
  82  * you know what you are doing, since the NumberFormat factory methods may
  83  * return subclasses other than DecimalFormat.
  84  *
<a name="5" id="anc5"></a><span class="line-modified">  85  * **Example Usage**</span>
  86  *
  87  * \code
  88  *     // Normally we would have a GUI with a menu for this
  89  *     int32_t locCount;
  90  *     const Locale* locales = NumberFormat::getAvailableLocales(locCount);
  91  *
  92  *     double myNumber = -1234.56;
  93  *     UErrorCode success = U_ZERO_ERROR;
  94  *     NumberFormat* form;
  95  *
  96  *     // Print out a number with the localized number, currency and percent
  97  *     // format for each locale.
  98  *     UnicodeString countryName;
  99  *     UnicodeString displayName;
 100  *     UnicodeString str;
 101  *     UnicodeString pattern;
 102  *     Formattable fmtable;
 103  *     for (int32_t j = 0; j &lt; 3; ++j) {
 104  *         cout &lt;&lt; endl &lt;&lt; &quot;FORMAT &quot; &lt;&lt; j &lt;&lt; endl;
 105  *         for (int32_t i = 0; i &lt; locCount; ++i) {
 106  *             if (locales[i].getCountry(countryName).size() == 0) {
 107  *                 // skip language-only
 108  *                 continue;
 109  *             }
 110  *             switch (j) {
 111  *             case 0:
 112  *                 form = NumberFormat::createInstance(locales[i], success ); break;
 113  *             case 1:
 114  *                 form = NumberFormat::createCurrencyInstance(locales[i], success ); break;
 115  *             default:
 116  *                 form = NumberFormat::createPercentInstance(locales[i], success ); break;
 117  *             }
 118  *             if (form) {
 119  *                 str.remove();
 120  *                 pattern = ((DecimalFormat*)form)-&gt;toPattern(pattern);
 121  *                 cout &lt;&lt; locales[i].getDisplayName(displayName) &lt;&lt; &quot;: &quot; &lt;&lt; pattern;
 122  *                 cout &lt;&lt; &quot;  -&gt;  &quot; &lt;&lt; form-&gt;format(myNumber,str) &lt;&lt; endl;
 123  *                 form-&gt;parse(form-&gt;format(myNumber,str), fmtable, success);
 124  *                 delete form;
 125  *             }
 126  *         }
 127  *     }
 128  * \endcode
<a name="6" id="anc6"></a><span class="line-modified"> 129  *</span>
<span class="line-modified"> 130  * **Another example use createInstance(style)**</span>
<span class="line-modified"> 131  *</span>
<span class="line-modified"> 132  * \code</span>
<span class="line-modified"> 133  * // Print out a number using the localized number, currency,</span>
 134  * // percent, scientific, integer, iso currency, and plural currency
 135  * // format for each locale&lt;/strong&gt;
 136  * Locale* locale = new Locale(&quot;en&quot;, &quot;US&quot;);
 137  * double myNumber = 1234.56;
 138  * UErrorCode success = U_ZERO_ERROR;
 139  * UnicodeString str;
 140  * Formattable fmtable;
 141  * for (int j=NumberFormat::kNumberStyle;
 142  *      j&lt;=NumberFormat::kPluralCurrencyStyle;
 143  *      ++j) {
<a name="7" id="anc7"></a><span class="line-modified"> 144  *     NumberFormat* form = NumberFormat::createInstance(locale, j, success);</span>
 145  *     str.remove();
 146  *     cout &lt;&lt; &quot;format result &quot; &lt;&lt; form-&gt;format(myNumber, str) &lt;&lt; endl;
 147  *     format-&gt;parse(form-&gt;format(myNumber, str), fmtable, success);
<a name="8" id="anc8"></a><span class="line-modified"> 148  *     delete form;</span>
<span class="line-added"> 149  * }</span>
<span class="line-added"> 150  * \endcode</span>
 151  *
 152  *
 153  * &lt;p&gt;&lt;strong&gt;Patterns&lt;/strong&gt;
 154  *
 155  * &lt;p&gt;A DecimalFormat consists of a &lt;em&gt;pattern&lt;/em&gt; and a set of
 156  * &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
 157  * applyPattern(), or indirectly using other API methods which
 158  * manipulate aspects of the pattern, such as the minimum number of integer
 159  * digits.  The symbols are stored in a DecimalFormatSymbols
 160  * object.  When using the NumberFormat factory methods, the
 161  * pattern and symbols are read from ICU&#39;s locale data.
 162  *
 163  * &lt;p&gt;&lt;strong&gt;Special Pattern Characters&lt;/strong&gt;
 164  *
 165  * &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
 166  * parsing and output unchanged during formatting.  Special characters, on the
 167  * other hand, stand for other characters, strings, or classes of characters.
 168  * For example, the &#39;#&#39; character is replaced by a localized digit.  Often the
 169  * replacement character is the same as the pattern character; in the U.S. locale,
 170  * the &#39;,&#39; grouping character is replaced by &#39;,&#39;.  However, the replacement is
 171  * still happening, and if the symbols are modified, the grouping character
 172  * changes.  Some special characters affect the behavior of the formatter by
 173  * their presence; for example, if the percent character is seen, then the
 174  * value is multiplied by 100 before being displayed.
 175  *
 176  * &lt;p&gt;To insert a special character in a pattern as a literal, that is, without
 177  * any special meaning, the character must be quoted.  There are some exceptions to
 178  * this which are noted below.
 179  *
 180  * &lt;p&gt;The characters listed here are used in non-localized patterns.  Localized
 181  * patterns use the corresponding characters taken from this formatter&#39;s
 182  * DecimalFormatSymbols object instead, and these characters lose
 183  * their special status.  Two exceptions are the currency sign and quote, which
 184  * are not localized.
 185  *
 186  * &lt;table border=0 cellspacing=3 cellpadding=0&gt;
 187  *   &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
 188  *     &lt;td align=left&gt;&lt;strong&gt;Symbol&lt;/strong&gt;
 189  *     &lt;td align=left&gt;&lt;strong&gt;Location&lt;/strong&gt;
 190  *     &lt;td align=left&gt;&lt;strong&gt;Localized?&lt;/strong&gt;
 191  *     &lt;td align=left&gt;&lt;strong&gt;Meaning&lt;/strong&gt;
 192  *   &lt;tr valign=top&gt;
 193  *     &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
 194  *     &lt;td&gt;Number
 195  *     &lt;td&gt;Yes
 196  *     &lt;td&gt;Digit
 197  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 198  *     &lt;td&gt;&lt;code&gt;1-9&lt;/code&gt;
 199  *     &lt;td&gt;Number
 200  *     &lt;td&gt;Yes
 201  *     &lt;td&gt;&#39;1&#39; through &#39;9&#39; indicate rounding.
 202  *   &lt;tr valign=top&gt;
 203  *     &lt;td&gt;&lt;code&gt;\htmlonly&amp;#x40;\endhtmlonly&lt;/code&gt; &lt;!--doxygen doesn&#39;t like @--&gt;
 204  *     &lt;td&gt;Number
 205  *     &lt;td&gt;No
 206  *     &lt;td&gt;Significant digit
 207  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 208  *     &lt;td&gt;&lt;code&gt;#&lt;/code&gt;
 209  *     &lt;td&gt;Number
 210  *     &lt;td&gt;Yes
 211  *     &lt;td&gt;Digit, zero shows as absent
 212  *   &lt;tr valign=top&gt;
 213  *     &lt;td&gt;&lt;code&gt;.&lt;/code&gt;
 214  *     &lt;td&gt;Number
 215  *     &lt;td&gt;Yes
 216  *     &lt;td&gt;Decimal separator or monetary decimal separator
 217  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 218  *     &lt;td&gt;&lt;code&gt;-&lt;/code&gt;
 219  *     &lt;td&gt;Number
 220  *     &lt;td&gt;Yes
 221  *     &lt;td&gt;Minus sign
 222  *   &lt;tr valign=top&gt;
 223  *     &lt;td&gt;&lt;code&gt;,&lt;/code&gt;
 224  *     &lt;td&gt;Number
 225  *     &lt;td&gt;Yes
 226  *     &lt;td&gt;Grouping separator
 227  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 228  *     &lt;td&gt;&lt;code&gt;E&lt;/code&gt;
 229  *     &lt;td&gt;Number
 230  *     &lt;td&gt;Yes
 231  *     &lt;td&gt;Separates mantissa and exponent in scientific notation.
 232  *         &lt;em&gt;Need not be quoted in prefix or suffix.&lt;/em&gt;
 233  *   &lt;tr valign=top&gt;
 234  *     &lt;td&gt;&lt;code&gt;+&lt;/code&gt;
 235  *     &lt;td&gt;Exponent
 236  *     &lt;td&gt;Yes
 237  *     &lt;td&gt;Prefix positive exponents with localized plus sign.
 238  *         &lt;em&gt;Need not be quoted in prefix or suffix.&lt;/em&gt;
 239  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 240  *     &lt;td&gt;&lt;code&gt;;&lt;/code&gt;
 241  *     &lt;td&gt;Subpattern boundary
 242  *     &lt;td&gt;Yes
 243  *     &lt;td&gt;Separates positive and negative subpatterns
 244  *   &lt;tr valign=top&gt;
 245  *     &lt;td&gt;&lt;code&gt;\%&lt;/code&gt;
 246  *     &lt;td&gt;Prefix or suffix
 247  *     &lt;td&gt;Yes
 248  *     &lt;td&gt;Multiply by 100 and show as percentage
 249  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 250  *     &lt;td&gt;&lt;code&gt;\\u2030&lt;/code&gt;
 251  *     &lt;td&gt;Prefix or suffix
 252  *     &lt;td&gt;Yes
 253  *     &lt;td&gt;Multiply by 1000 and show as per mille
 254  *   &lt;tr valign=top&gt;
 255  *     &lt;td&gt;&lt;code&gt;\htmlonly&amp;curren;\endhtmlonly&lt;/code&gt; (&lt;code&gt;\\u00A4&lt;/code&gt;)
 256  *     &lt;td&gt;Prefix or suffix
 257  *     &lt;td&gt;No
 258  *     &lt;td&gt;Currency sign, replaced by currency symbol.  If
 259  *         doubled, replaced by international currency symbol.
 260  *         If tripled, replaced by currency plural names, for example,
 261  *         &quot;US dollar&quot; or &quot;US dollars&quot; for America.
 262  *         If present in a pattern, the monetary decimal separator
 263  *         is used instead of the decimal separator.
 264  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 265  *     &lt;td&gt;&lt;code&gt;&#39;&lt;/code&gt;
 266  *     &lt;td&gt;Prefix or suffix
 267  *     &lt;td&gt;No
 268  *     &lt;td&gt;Used to quote special characters in a prefix or suffix,
 269  *         for example, &lt;code&gt;&quot;&#39;#&#39;#&quot;&lt;/code&gt; formats 123 to
 270  *         &lt;code&gt;&quot;#123&quot;&lt;/code&gt;.  To create a single quote
 271  *         itself, use two in a row: &lt;code&gt;&quot;# o&#39;&#39;clock&quot;&lt;/code&gt;.
 272  *   &lt;tr valign=top&gt;
 273  *     &lt;td&gt;&lt;code&gt;*&lt;/code&gt;
 274  *     &lt;td&gt;Prefix or suffix boundary
 275  *     &lt;td&gt;Yes
 276  *     &lt;td&gt;Pad escape, precedes pad character
 277  * &lt;/table&gt;
 278  *
<a name="9" id="anc9"></a><span class="line-modified"> 279  * &lt;p&gt;A DecimalFormat pattern contains a positive and negative</span>
 280  * subpattern, for example, &quot;#,##0.00;(#,##0.00)&quot;.  Each subpattern has a
 281  * prefix, a numeric part, and a suffix.  If there is no explicit negative
 282  * subpattern, the negative subpattern is the localized minus sign prefixed to the
 283  * positive subpattern. That is, &quot;0.00&quot; alone is equivalent to &quot;0.00;-0.00&quot;.  If there
 284  * is an explicit negative subpattern, it serves only to specify the negative
 285  * prefix and suffix; the number of digits, minimal digits, and other
 286  * characteristics are ignored in the negative subpattern. That means that
 287  * &quot;#,##0.0#;(#)&quot; has precisely the same result as &quot;#,##0.0#;(#,##0.0#)&quot;.
 288  *
 289  * &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
 290  * thousands separators, decimal separators, etc. may be set to arbitrary
 291  * values, and they will appear properly during formatting.  However, care must
 292  * be taken that the symbols and strings do not conflict, or parsing will be
 293  * unreliable.  For example, either the positive and negative prefixes or the
 294  * suffixes must be distinct for parse() to be able
 295  * to distinguish positive from negative values.  Another example is that the
 296  * decimal separator and thousands separator should be distinct characters, or
 297  * parsing will be impossible.
 298  *
 299  * &lt;p&gt;The &lt;em&gt;grouping separator&lt;/em&gt; is a character that separates clusters of
 300  * integer digits to make large numbers more legible.  It commonly used for
 301  * thousands, but in some locales it separates ten-thousands.  The &lt;em&gt;grouping
 302  * size&lt;/em&gt; is the number of digits between the grouping separators, such as 3
 303  * for &quot;100,000,000&quot; or 4 for &quot;1 0000 0000&quot;. There are actually two different
 304  * grouping sizes: One used for the least significant integer digits, the
 305  * &lt;em&gt;primary grouping size&lt;/em&gt;, and one used for all others, the
 306  * &lt;em&gt;secondary grouping size&lt;/em&gt;.  In most locales these are the same, but
 307  * sometimes they are different. For example, if the primary grouping interval
 308  * is 3, and the secondary is 2, then this corresponds to the pattern
 309  * &quot;#,##,##0&quot;, and the number 123456789 is formatted as &quot;12,34,56,789&quot;.  If a
 310  * pattern contains multiple grouping separators, the interval between the last
 311  * one and the end of the integer defines the primary grouping size, and the
 312  * interval between the last two defines the secondary grouping size. All others
 313  * are ignored, so &quot;#,##,###,####&quot; == &quot;###,###,####&quot; == &quot;##,#,###,####&quot;.
 314  *
 315  * &lt;p&gt;Illegal patterns, such as &quot;#.#.#&quot; or &quot;#.###,###&quot;, will cause
 316  * DecimalFormat to set a failing UErrorCode.
 317  *
 318  * &lt;p&gt;&lt;strong&gt;Pattern BNF&lt;/strong&gt;
 319  *
 320  * &lt;pre&gt;
 321  * pattern    := subpattern (&#39;;&#39; subpattern)?
 322  * subpattern := prefix? number exponent? suffix?
 323  * number     := (integer (&#39;.&#39; fraction)?) | sigDigits
 324  * prefix     := &#39;\\u0000&#39;..&#39;\\uFFFD&#39; - specialCharacters
 325  * suffix     := &#39;\\u0000&#39;..&#39;\\uFFFD&#39; - specialCharacters
 326  * integer    := &#39;#&#39;* &#39;0&#39;* &#39;0&#39;
 327  * fraction   := &#39;0&#39;* &#39;#&#39;*
 328  * sigDigits  := &#39;#&#39;* &#39;@&#39; &#39;@&#39;* &#39;#&#39;*
 329  * exponent   := &#39;E&#39; &#39;+&#39;? &#39;0&#39;* &#39;0&#39;
 330  * padSpec    := &#39;*&#39; padChar
 331  * padChar    := &#39;\\u0000&#39;..&#39;\\uFFFD&#39; - quote
 332  * &amp;nbsp;
 333  * Notation:
 334  *   X*       0 or more instances of X
 335  *   X?       0 or 1 instances of X
 336  *   X|Y      either X or Y
 337  *   C..D     any character from C up to D, inclusive
 338  *   S-T      characters in S, except those in T
 339  * &lt;/pre&gt;
 340  * The first subpattern is for positive numbers. The second (optional)
 341  * subpattern is for negative numbers.
 342  *
 343  * &lt;p&gt;Not indicated in the BNF syntax above:
 344  *
 345  * &lt;ul&gt;&lt;li&gt;The grouping separator &#39;,&#39; can occur inside the integer and
 346  * sigDigits elements, between any two pattern characters of that
 347  * element, as long as the integer or sigDigits element is not
 348  * followed by the exponent element.
 349  *
 350  * &lt;li&gt;Two grouping intervals are recognized: That between the
 351  *     decimal point and the first grouping symbol, and that
 352  *     between the first and second grouping symbols. These
 353  *     intervals are identical in most locales, but in some
 354  *     locales they differ. For example, the pattern
 355  *     &amp;quot;#,##,###&amp;quot; formats the number 123456789 as
 356  *     &amp;quot;12,34,56,789&amp;quot;.&lt;/li&gt;
 357  *
 358  * &lt;li&gt;The pad specifier &lt;code&gt;padSpec&lt;/code&gt; may appear before the prefix,
 359  * after the prefix, before the suffix, after the suffix, or not at all.
 360  *
 361  * &lt;li&gt;In place of &#39;0&#39;, the digits &#39;1&#39; through &#39;9&#39; may be used to
 362  * indicate a rounding increment.
 363  * &lt;/ul&gt;
 364  *
 365  * &lt;p&gt;&lt;strong&gt;Parsing&lt;/strong&gt;
 366  *
 367  * &lt;p&gt;DecimalFormat parses all Unicode characters that represent
 368  * decimal digits, as defined by u_charDigitValue().  In addition,
 369  * DecimalFormat also recognizes as digits the ten consecutive
 370  * characters starting with the localized zero digit defined in the
 371  * DecimalFormatSymbols object.  During formatting, the
 372  * DecimalFormatSymbols-based digits are output.
 373  *
 374  * &lt;p&gt;During parsing, grouping separators are ignored if in lenient mode;
 375  * otherwise, if present, they must be in appropriate positions.
 376  *
 377  * &lt;p&gt;For currency parsing, the formatter is able to parse every currency
 378  * style formats no matter which style the formatter is constructed with.
 379  * For example, a formatter instance gotten from
 380  * NumberFormat.getInstance(ULocale, NumberFormat.CURRENCYSTYLE) can parse
 381  * formats such as &quot;USD1.00&quot; and &quot;3.00 US dollars&quot;.
 382  *
 383  * &lt;p&gt;If parse(UnicodeString&amp;,Formattable&amp;,ParsePosition&amp;)
 384  * fails to parse a string, it leaves the parse position unchanged.
 385  * The convenience method parse(UnicodeString&amp;,Formattable&amp;,UErrorCode&amp;)
 386  * indicates parse failure by setting a failing
 387  * UErrorCode.
 388  *
 389  * &lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;
 390  *
 391  * &lt;p&gt;Formatting is guided by several parameters, all of which can be
 392  * specified either using a pattern or using the API.  The following
 393  * description applies to formats that do not use &lt;a href=&quot;#sci&quot;&gt;scientific
 394  * notation&lt;/a&gt; or &lt;a href=&quot;#sigdig&quot;&gt;significant digits&lt;/a&gt;.
 395  *
 396  * &lt;ul&gt;&lt;li&gt;If the number of actual integer digits exceeds the
 397  * &lt;em&gt;maximum integer digits&lt;/em&gt;, then only the least significant
 398  * digits are shown.  For example, 1997 is formatted as &quot;97&quot; if the
 399  * maximum integer digits is set to 2.
 400  *
 401  * &lt;li&gt;If the number of actual integer digits is less than the
 402  * &lt;em&gt;minimum integer digits&lt;/em&gt;, then leading zeros are added.  For
 403  * example, 1997 is formatted as &quot;01997&quot; if the minimum integer digits
 404  * is set to 5.
 405  *
 406  * &lt;li&gt;If the number of actual fraction digits exceeds the &lt;em&gt;maximum
 407  * fraction digits&lt;/em&gt;, then rounding is performed to the
 408  * maximum fraction digits.  For example, 0.125 is formatted as &quot;0.12&quot;
 409  * if the maximum fraction digits is 2.  This behavior can be changed
 410  * by specifying a rounding increment and/or a rounding mode.
 411  *
 412  * &lt;li&gt;If the number of actual fraction digits is less than the
 413  * &lt;em&gt;minimum fraction digits&lt;/em&gt;, then trailing zeros are added.
<a name="10" id="anc10"></a><span class="line-modified"> 414  * For example, 0.125 is formatted as &quot;0.1250&quot; if the minimum fraction</span>
 415  * digits is set to 4.
 416  *
 417  * &lt;li&gt;Trailing fractional zeros are not displayed if they occur
 418  * &lt;em&gt;j&lt;/em&gt; positions after the decimal, where &lt;em&gt;j&lt;/em&gt; is less
 419  * than the maximum fraction digits. For example, 0.10004 is
 420  * formatted as &quot;0.1&quot; if the maximum fraction digits is four or less.
 421  * &lt;/ul&gt;
 422  *
 423  * &lt;p&gt;&lt;strong&gt;Special Values&lt;/strong&gt;
 424  *
 425  * &lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; is represented as a single character, typically
 426  * &lt;code&gt;\\uFFFD&lt;/code&gt;.  This character is determined by the
 427  * DecimalFormatSymbols object.  This is the only value for which
 428  * the prefixes and suffixes are not used.
 429  *
 430  * &lt;p&gt;Infinity is represented as a single character, typically
 431  * &lt;code&gt;\\u221E&lt;/code&gt;, with the positive or negative prefixes and suffixes
 432  * applied.  The infinity character is determined by the
 433  * DecimalFormatSymbols object.
 434  *
 435  * &lt;a name=&quot;sci&quot;&gt;&lt;strong&gt;Scientific Notation&lt;/strong&gt;&lt;/a&gt;
 436  *
 437  * &lt;p&gt;Numbers in scientific notation are expressed as the product of a mantissa
 438  * and a power of ten, for example, 1234 can be expressed as 1.234 x 10&lt;sup&gt;3&lt;/sup&gt;. The
 439  * mantissa is typically in the half-open interval [1.0, 10.0) or sometimes [0.0, 1.0),
 440  * but it need not be.  DecimalFormat supports arbitrary mantissas.
 441  * DecimalFormat can be instructed to use scientific
 442  * notation through the API or through the pattern.  In a pattern, the exponent
 443  * character immediately followed by one or more digit characters indicates
 444  * scientific notation.  Example: &quot;0.###E0&quot; formats the number 1234 as
 445  * &quot;1.234E3&quot;.
 446  *
 447  * &lt;ul&gt;
 448  * &lt;li&gt;The number of digit characters after the exponent character gives the
 449  * minimum exponent digit count.  There is no maximum.  Negative exponents are
 450  * formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix
 451  * from the pattern.  This allows patterns such as &quot;0.###E0 m/s&quot;.  To prefix
 452  * positive exponents with a localized plus sign, specify &#39;+&#39; between the
 453  * exponent and the digits: &quot;0.###E+0&quot; will produce formats &quot;1E+1&quot;, &quot;1E+0&quot;,
 454  * &quot;1E-1&quot;, etc.  (In localized patterns, use the localized plus sign rather than
 455  * &#39;+&#39;.)
 456  *
 457  * &lt;li&gt;The minimum number of integer digits is achieved by adjusting the
 458  * exponent.  Example: 0.00123 formatted with &quot;00.###E0&quot; yields &quot;12.3E-4&quot;.  This
 459  * only happens if there is no maximum number of integer digits.  If there is a
 460  * maximum, then the minimum number of integer digits is fixed at one.
 461  *
 462  * &lt;li&gt;The maximum number of integer digits, if present, specifies the exponent
 463  * grouping.  The most common use of this is to generate &lt;em&gt;engineering
 464  * notation&lt;/em&gt;, in which the exponent is a multiple of three, e.g.,
 465  * &quot;##0.###E0&quot;.  The number 12345 is formatted using &quot;##0.####E0&quot; as &quot;12.345E3&quot;.
 466  *
 467  * &lt;li&gt;When using scientific notation, the formatter controls the
 468  * digit counts using significant digits logic.  The maximum number of
 469  * significant digits limits the total number of integer and fraction
 470  * digits that will be shown in the mantissa; it does not affect
 471  * parsing.  For example, 12345 formatted with &quot;##0.##E0&quot; is &quot;12.3E3&quot;.
 472  * See the section on significant digits for more details.
 473  *
 474  * &lt;li&gt;The number of significant digits shown is determined as
 475  * follows: If areSignificantDigitsUsed() returns false, then the
 476  * minimum number of significant digits shown is one, and the maximum
 477  * number of significant digits shown is the sum of the &lt;em&gt;minimum
 478  * integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is
 479  * unaffected by the maximum integer digits.  If this sum is zero,
 480  * then all significant digits are shown.  If
 481  * areSignificantDigitsUsed() returns true, then the significant digit
 482  * counts are specified by getMinimumSignificantDigits() and
 483  * getMaximumSignificantDigits().  In this case, the number of
 484  * integer digits is fixed at one, and there is no exponent grouping.
 485  *
 486  * &lt;li&gt;Exponential patterns may not contain grouping separators.
 487  * &lt;/ul&gt;
 488  *
 489  * &lt;a name=&quot;sigdig&quot;&gt;&lt;strong&gt;Significant Digits&lt;/strong&gt;&lt;/a&gt;
 490  *
 491  * &lt;code&gt;DecimalFormat&lt;/code&gt; has two ways of controlling how many
 492  * digits are shows: (a) significant digits counts, or (b) integer and
 493  * fraction digit counts.  Integer and fraction digit counts are
 494  * described above.  When a formatter is using significant digits
 495  * counts, the number of integer and fraction digits is not specified
 496  * directly, and the formatter settings for these counts are ignored.
 497  * Instead, the formatter uses however many integer and fraction
 498  * digits are required to display the specified number of significant
 499  * digits.  Examples:
 500  *
 501  * &lt;table border=0 cellspacing=3 cellpadding=0&gt;
 502  *   &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
 503  *     &lt;td align=left&gt;Pattern
 504  *     &lt;td align=left&gt;Minimum significant digits
 505  *     &lt;td align=left&gt;Maximum significant digits
 506  *     &lt;td align=left&gt;Number
 507  *     &lt;td align=left&gt;Output of format()
 508  *   &lt;tr valign=top&gt;
 509  *     &lt;td&gt;&lt;code&gt;\@\@\@&lt;/code&gt;
 510  *     &lt;td&gt;3
 511  *     &lt;td&gt;3
 512  *     &lt;td&gt;12345
 513  *     &lt;td&gt;&lt;code&gt;12300&lt;/code&gt;
 514  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 515  *     &lt;td&gt;&lt;code&gt;\@\@\@&lt;/code&gt;
 516  *     &lt;td&gt;3
 517  *     &lt;td&gt;3
 518  *     &lt;td&gt;0.12345
 519  *     &lt;td&gt;&lt;code&gt;0.123&lt;/code&gt;
 520  *   &lt;tr valign=top&gt;
 521  *     &lt;td&gt;&lt;code&gt;\@\@##&lt;/code&gt;
 522  *     &lt;td&gt;2
 523  *     &lt;td&gt;4
 524  *     &lt;td&gt;3.14159
 525  *     &lt;td&gt;&lt;code&gt;3.142&lt;/code&gt;
 526  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 527  *     &lt;td&gt;&lt;code&gt;\@\@##&lt;/code&gt;
 528  *     &lt;td&gt;2
 529  *     &lt;td&gt;4
 530  *     &lt;td&gt;1.23004
 531  *     &lt;td&gt;&lt;code&gt;1.23&lt;/code&gt;
 532  * &lt;/table&gt;
 533  *
 534  * &lt;ul&gt;
 535  * &lt;li&gt;Significant digit counts may be expressed using patterns that
 536  * specify a minimum and maximum number of significant digits.  These
 537  * are indicated by the &lt;code&gt;&#39;@&#39;&lt;/code&gt; and &lt;code&gt;&#39;#&#39;&lt;/code&gt;
 538  * characters.  The minimum number of significant digits is the number
 539  * of &lt;code&gt;&#39;@&#39;&lt;/code&gt; characters.  The maximum number of significant
 540  * digits is the number of &lt;code&gt;&#39;@&#39;&lt;/code&gt; characters plus the number
 541  * of &lt;code&gt;&#39;#&#39;&lt;/code&gt; characters following on the right.  For
 542  * example, the pattern &lt;code&gt;&quot;@@@&quot;&lt;/code&gt; indicates exactly 3
 543  * significant digits.  The pattern &lt;code&gt;&quot;@##&quot;&lt;/code&gt; indicates from
 544  * 1 to 3 significant digits.  Trailing zero digits to the right of
 545  * the decimal separator are suppressed after the minimum number of
 546  * significant digits have been shown.  For example, the pattern
 547  * &lt;code&gt;&quot;@##&quot;&lt;/code&gt; formats the number 0.1203 as
 548  * &lt;code&gt;&quot;0.12&quot;&lt;/code&gt;.
 549  *
 550  * &lt;li&gt;If a pattern uses significant digits, it may not contain a
 551  * decimal separator, nor the &lt;code&gt;&#39;0&#39;&lt;/code&gt; pattern character.
 552  * Patterns such as &lt;code&gt;&quot;@00&quot;&lt;/code&gt; or &lt;code&gt;&quot;@.###&quot;&lt;/code&gt; are
 553  * disallowed.
 554  *
 555  * &lt;li&gt;Any number of &lt;code&gt;&#39;#&#39;&lt;/code&gt; characters may be prepended to
 556  * the left of the leftmost &lt;code&gt;&#39;@&#39;&lt;/code&gt; character.  These have no
 557  * effect on the minimum and maximum significant digits counts, but
 558  * may be used to position grouping separators.  For example,
 559  * &lt;code&gt;&quot;#,#@#&quot;&lt;/code&gt; indicates a minimum of one significant digits,
 560  * a maximum of two significant digits, and a grouping size of three.
 561  *
 562  * &lt;li&gt;In order to enable significant digits formatting, use a pattern
 563  * containing the &lt;code&gt;&#39;@&#39;&lt;/code&gt; pattern character.  Alternatively,
 564  * call setSignificantDigitsUsed(TRUE).
 565  *
 566  * &lt;li&gt;In order to disable significant digits formatting, use a
 567  * pattern that does not contain the &lt;code&gt;&#39;@&#39;&lt;/code&gt; pattern
 568  * character. Alternatively, call setSignificantDigitsUsed(FALSE).
 569  *
 570  * &lt;li&gt;The number of significant digits has no effect on parsing.
 571  *
 572  * &lt;li&gt;Significant digits may be used together with exponential notation. Such
 573  * patterns are equivalent to a normal exponential pattern with a minimum and
 574  * maximum integer digit count of one, a minimum fraction digit count of
 575  * &lt;code&gt;getMinimumSignificantDigits() - 1&lt;/code&gt;, and a maximum fraction digit
 576  * count of &lt;code&gt;getMaximumSignificantDigits() - 1&lt;/code&gt;. For example, the
 577  * pattern &lt;code&gt;&quot;@@###E0&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;0.0###E0&quot;&lt;/code&gt;.
 578  *
<a name="11" id="anc11"></a><span class="line-modified"> 579  * &lt;li&gt;If significant digits are in use, then the integer and fraction</span>
 580  * digit counts, as set via the API, are ignored.  If significant
<a name="12" id="anc12"></a><span class="line-modified"> 581  * digits are not in use, then the significant digit counts, as set via</span>
 582  * the API, are ignored.
 583  *
 584  * &lt;/ul&gt;
 585  *
 586  * &lt;p&gt;&lt;strong&gt;Padding&lt;/strong&gt;
 587  *
 588  * &lt;p&gt;DecimalFormat supports padding the result of
 589  * format() to a specific width.  Padding may be specified either
 590  * through the API or through the pattern syntax.  In a pattern the pad escape
 591  * character, followed by a single pad character, causes padding to be parsed
 592  * and formatted.  The pad escape character is &#39;*&#39; in unlocalized patterns, and
 593  * can be localized using DecimalFormatSymbols::setSymbol() with a
 594  * DecimalFormatSymbols::kPadEscapeSymbol
 595  * selector.  For example, &lt;code&gt;&quot;$*x#,##0.00&quot;&lt;/code&gt; formats 123 to
 596  * &lt;code&gt;&quot;$xx123.00&quot;&lt;/code&gt;, and 1234 to &lt;code&gt;&quot;$1,234.00&quot;&lt;/code&gt;.
 597  *
 598  * &lt;ul&gt;
 599  * &lt;li&gt;When padding is in effect, the width of the positive subpattern,
 600  * including prefix and suffix, determines the format width.  For example, in
 601  * the pattern &lt;code&gt;&quot;* #0 o&#39;&#39;clock&quot;&lt;/code&gt;, the format width is 10.
 602  *
 603  * &lt;li&gt;The width is counted in 16-bit code units (char16_ts).
 604  *
 605  * &lt;li&gt;Some parameters which usually do not matter have meaning when padding is
 606  * used, because the pattern width is significant with padding.  In the pattern
 607  * &quot;* ##,##,#,##0.##&quot;, the format width is 14.  The initial characters &quot;##,##,&quot;
 608  * do not affect the grouping size or maximum integer digits, but they do affect
 609  * the format width.
 610  *
 611  * &lt;li&gt;Padding may be inserted at one of four locations: before the prefix,
 612  * after the prefix, before the suffix, or after the suffix.  If padding is
 613  * specified in any other location, applyPattern()
 614  * sets a failing UErrorCode.  If there is no prefix,
 615  * before the prefix and after the prefix are equivalent, likewise for the
 616  * suffix.
 617  *
 618  * &lt;li&gt;When specified in a pattern, the 32-bit code point immediately
 619  * following the pad escape is the pad character. This may be any character,
 620  * including a special pattern character. That is, the pad escape
 621  * &lt;em&gt;escapes&lt;/em&gt; the following character. If there is no character after
 622  * the pad escape, then the pattern is illegal.
 623  *
 624  * &lt;/ul&gt;
 625  *
 626  * &lt;p&gt;&lt;strong&gt;Rounding&lt;/strong&gt;
 627  *
 628  * &lt;p&gt;DecimalFormat supports rounding to a specific increment.  For
 629  * example, 1230 rounded to the nearest 50 is 1250.  1.234 rounded to the
 630  * nearest 0.65 is 1.3.  The rounding increment may be specified through the API
 631  * or in a pattern.  To specify a rounding increment in a pattern, include the
 632  * increment in the pattern itself.  &quot;#,#50&quot; specifies a rounding increment of
 633  * 50.  &quot;#,##0.05&quot; specifies a rounding increment of 0.05.
 634  *
<a name="13" id="anc13"></a><span class="line-modified"> 635  * &lt;p&gt;In the absence of an explicit rounding increment numbers are</span>
 636  * rounded to their formatted width.
 637  *
 638  * &lt;ul&gt;
 639  * &lt;li&gt;Rounding only affects the string produced by formatting.  It does
 640  * not affect parsing or change any numerical values.
 641  *
 642  * &lt;li&gt;A &lt;em&gt;rounding mode&lt;/em&gt; determines how values are rounded; see
 643  * DecimalFormat::ERoundingMode.  The default rounding mode is
 644  * DecimalFormat::kRoundHalfEven.  The rounding mode can only be set
 645  * through the API; it can not be set with a pattern.
 646  *
 647  * &lt;li&gt;Some locales use rounding in their currency formats to reflect the
 648  * smallest currency denomination.
 649  *
 650  * &lt;li&gt;In a pattern, digits &#39;1&#39; through &#39;9&#39; specify rounding, but otherwise
 651  * behave identically to digit &#39;0&#39;.
 652  * &lt;/ul&gt;
 653  *
 654  * &lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;
 655  *
 656  * &lt;p&gt;DecimalFormat objects are not synchronized.  Multiple
 657  * threads should not access one formatter concurrently.
 658  *
 659  * &lt;p&gt;&lt;strong&gt;Subclassing&lt;/strong&gt;
 660  *
 661  * &lt;p&gt;&lt;em&gt;User subclasses are not supported.&lt;/em&gt; While clients may write
 662  * subclasses, such code will not necessarily work and will not be
 663  * guaranteed to work stably from release to release.
 664  */
 665 class U_I18N_API DecimalFormat : public NumberFormat {
 666   public:
 667     /**
 668      * Pad position.
 669      * @stable ICU 2.4
 670      */
 671     enum EPadPosition {
 672         kPadBeforePrefix, kPadAfterPrefix, kPadBeforeSuffix, kPadAfterSuffix
 673     };
 674 
 675     /**
 676      * Create a DecimalFormat using the default pattern and symbols
 677      * for the default locale. This is a convenient way to obtain a
 678      * DecimalFormat when internationalization is not the main concern.
 679      * &lt;P&gt;
 680      * To obtain standard formats for a given locale, use the factory methods
 681      * on NumberFormat such as createInstance. These factories will
 682      * return the most appropriate sub-class of NumberFormat for a given
 683      * locale.
 684      * &lt;p&gt;
 685      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="14" id="anc14"></a><span class="line-modified"> 686      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
 687      * @param status    Output param set to success/failure code. If the
 688      *                  pattern is invalid this will be set to a failure code.
 689      * @stable ICU 2.0
 690      */
 691     DecimalFormat(UErrorCode&amp; status);
 692 
 693     /**
 694      * Create a DecimalFormat from the given pattern and the symbols
 695      * for the default locale. This is a convenient way to obtain a
 696      * DecimalFormat when internationalization is not the main concern.
 697      * &lt;P&gt;
 698      * To obtain standard formats for a given locale, use the factory methods
 699      * on NumberFormat such as createInstance. These factories will
 700      * return the most appropriate sub-class of NumberFormat for a given
 701      * locale.
 702      * &lt;p&gt;
 703      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="15" id="anc15"></a><span class="line-modified"> 704      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
 705      * @param pattern   A non-localized pattern string.
 706      * @param status    Output param set to success/failure code. If the
 707      *                  pattern is invalid this will be set to a failure code.
 708      * @stable ICU 2.0
 709      */
 710     DecimalFormat(const UnicodeString&amp; pattern, UErrorCode&amp; status);
 711 
 712     /**
 713      * Create a DecimalFormat from the given pattern and symbols.
 714      * Use this constructor when you need to completely customize the
 715      * behavior of the format.
 716      * &lt;P&gt;
 717      * To obtain standard formats for a given
 718      * locale, use the factory methods on NumberFormat such as
 719      * createInstance or createCurrencyInstance. If you need only minor adjustments
 720      * to a standard format, you can modify the format returned by
 721      * a NumberFormat factory method.
 722      * &lt;p&gt;
 723      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="16" id="anc16"></a><span class="line-modified"> 724      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
 725      *
 726      * @param pattern           a non-localized pattern string
 727      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
 728      *                          delete this object after making this call.
 729      * @param status            Output param set to success/failure code. If the
 730      *                          pattern is invalid this will be set to a failure code.
 731      * @stable ICU 2.0
 732      */
 733     DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status);
 734 
 735 #ifndef U_HIDE_INTERNAL_API
 736 
 737     /**
 738      * This API is for ICU use only.
 739      * Create a DecimalFormat from the given pattern, symbols, and style.
 740      *
 741      * @param pattern           a non-localized pattern string
 742      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
 743      *                          delete this object after making this call.
 744      * @param style             style of decimal format
 745      * @param status            Output param set to success/failure code. If the
 746      *                          pattern is invalid this will be set to a failure code.
 747      * @internal
 748      */
 749     DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
 750                   UNumberFormatStyle style, UErrorCode&amp; status);
 751 
 752 #if UCONFIG_HAVE_PARSEALLINPUT
 753 
 754     /**
 755      * @internal
 756      */
 757     void setParseAllInput(UNumberFormatAttributeValue value);
 758 
 759 #endif
 760 
 761 #endif  /* U_HIDE_INTERNAL_API */
 762 
 763   private:
 764 
 765     /**
 766      * Internal constructor for DecimalFormat; sets up internal fields. All public constructors should
 767      * call this constructor.
 768      */
 769     DecimalFormat(const DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status);
 770 
 771   public:
 772 
 773     /**
 774      * Set an integer attribute on this DecimalFormat.
 775      * May return U_UNSUPPORTED_ERROR if this instance does not support
 776      * the specified attribute.
 777      * @param attr the attribute to set
<a name="17" id="anc17"></a><span class="line-modified"> 778      * @param newValue new value</span>
 779      * @param status the error type
 780      * @return *this - for chaining (example: format.setAttribute(...).setAttribute(...) )
 781      * @stable ICU 51
 782      */
 783     virtual DecimalFormat&amp; setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode&amp; status);
 784 
 785     /**
 786      * Get an integer
 787      * May return U_UNSUPPORTED_ERROR if this instance does not support
 788      * the specified attribute.
 789      * @param attr the attribute to set
 790      * @param status the error type
 791      * @return the attribute value. Undefined if there is an error.
 792      * @stable ICU 51
 793      */
 794     virtual int32_t getAttribute(UNumberFormatAttribute attr, UErrorCode&amp; status) const;
 795 
 796 
 797     /**
 798      * Set whether or not grouping will be used in this format.
 799      * @param newValue    True, grouping will be used in this format.
 800      * @see getGroupingUsed
 801      * @stable ICU 53
 802      */
 803     void setGroupingUsed(UBool newValue) U_OVERRIDE;
 804 
 805     /**
 806      * Sets whether or not numbers should be parsed as integers only.
 807      * @param value    set True, this format will parse numbers as integers
 808      *                 only.
 809      * @see isParseIntegerOnly
 810      * @stable ICU 53
 811      */
 812     void setParseIntegerOnly(UBool value) U_OVERRIDE;
 813 
 814     /**
 815      * Sets whether lenient parsing should be enabled (it is off by default).
 816      *
 817      * @param enable \c TRUE if lenient parsing should be used,
 818      *               \c FALSE otherwise.
 819      * @stable ICU 4.8
 820      */
 821     void setLenient(UBool enable) U_OVERRIDE;
 822 
 823     /**
 824      * Create a DecimalFormat from the given pattern and symbols.
 825      * Use this constructor when you need to completely customize the
 826      * behavior of the format.
 827      * &lt;P&gt;
 828      * To obtain standard formats for a given
 829      * locale, use the factory methods on NumberFormat such as
 830      * createInstance or createCurrencyInstance. If you need only minor adjustments
 831      * to a standard format, you can modify the format returned by
 832      * a NumberFormat factory method.
 833      * &lt;p&gt;
 834      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="18" id="anc18"></a><span class="line-modified"> 835      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
 836      *
 837      * @param pattern           a non-localized pattern string
 838      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
 839      *                          delete this object after making this call.
<a name="19" id="anc19"></a><span class="line-modified"> 840      * @param parseError        Output param to receive errors occurred during parsing</span>
 841      * @param status            Output param set to success/failure code. If the
 842      *                          pattern is invalid this will be set to a failure code.
 843      * @stable ICU 2.0
 844      */
 845     DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
 846                   UParseError&amp; parseError, UErrorCode&amp; status);
 847 
 848     /**
 849      * Create a DecimalFormat from the given pattern and symbols.
 850      * Use this constructor when you need to completely customize the
 851      * behavior of the format.
 852      * &lt;P&gt;
 853      * To obtain standard formats for a given
 854      * locale, use the factory methods on NumberFormat such as
 855      * createInstance or createCurrencyInstance. If you need only minor adjustments
 856      * to a standard format, you can modify the format returned by
 857      * a NumberFormat factory method.
 858      * &lt;p&gt;
 859      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="20" id="anc20"></a><span class="line-modified"> 860      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
 861      *
 862      * @param pattern           a non-localized pattern string
 863      * @param symbols   the set of symbols to be used
 864      * @param status            Output param set to success/failure code. If the
 865      *                          pattern is invalid this will be set to a failure code.
 866      * @stable ICU 2.0
 867      */
 868     DecimalFormat(const UnicodeString&amp; pattern, const DecimalFormatSymbols&amp; symbols, UErrorCode&amp; status);
 869 
 870     /**
 871      * Copy constructor.
 872      *
 873      * @param source    the DecimalFormat object to be copied from.
 874      * @stable ICU 2.0
 875      */
 876     DecimalFormat(const DecimalFormat&amp; source);
 877 
 878     /**
 879      * Assignment operator.
 880      *
 881      * @param rhs    the DecimalFormat object to be copied.
 882      * @stable ICU 2.0
 883      */
 884     DecimalFormat&amp; operator=(const DecimalFormat&amp; rhs);
 885 
 886     /**
 887      * Destructor.
 888      * @stable ICU 2.0
 889      */
 890     ~DecimalFormat() U_OVERRIDE;
 891 
 892     /**
 893      * Clone this Format object polymorphically. The caller owns the
 894      * result and should delete it when done.
 895      *
 896      * @return    a polymorphic copy of this DecimalFormat.
 897      * @stable ICU 2.0
 898      */
 899     Format* clone(void) const U_OVERRIDE;
 900 
 901     /**
 902      * Return true if the given Format objects are semantically equal.
 903      * Objects of different subclasses are considered unequal.
 904      *
 905      * @param other    the object to be compared with.
 906      * @return         true if the given Format objects are semantically equal.
 907      * @stable ICU 2.0
 908      */
 909     UBool operator==(const Format&amp; other) const U_OVERRIDE;
 910 
 911 
 912     using NumberFormat::format;
 913 
 914     /**
 915      * Format a double or long number using base-10 representation.
 916      *
 917      * @param number    The value to be formatted.
 918      * @param appendTo  Output parameter to receive result.
 919      *                  Result is appended to existing contents.
 920      * @param pos       On input: an alignment field, if desired.
 921      *                  On output: the offsets of the alignment field.
 922      * @return          Reference to &#39;appendTo&#39; parameter.
 923      * @stable ICU 2.0
 924      */
 925     UnicodeString&amp; format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const U_OVERRIDE;
 926 
 927 #ifndef U_HIDE_INTERNAL_API
 928     /**
 929      * Format a double or long number using base-10 representation.
 930      *
 931      * @param number    The value to be formatted.
 932      * @param appendTo  Output parameter to receive result.
 933      *                  Result is appended to existing contents.
 934      * @param pos       On input: an alignment field, if desired.
 935      *                  On output: the offsets of the alignment field.
 936      * @param status
 937      * @return          Reference to &#39;appendTo&#39; parameter.
 938      * @internal
 939      */
 940     UnicodeString&amp; format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 941                           UErrorCode&amp; status) const U_OVERRIDE;
 942 #endif  /* U_HIDE_INTERNAL_API */
 943 
 944     /**
 945      * Format a double or long number using base-10 representation.
 946      *
 947      * @param number    The value to be formatted.
 948      * @param appendTo  Output parameter to receive result.
 949      *                  Result is appended to existing contents.
 950      * @param posIter   On return, can be used to iterate over positions
 951      *                  of fields generated by this format call.
 952      *                  Can be NULL.
 953      * @param status    Output param filled with success/failure status.
 954      * @return          Reference to &#39;appendTo&#39; parameter.
 955      * @stable ICU 4.4
 956      */
 957     UnicodeString&amp; format(double number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 958                           UErrorCode&amp; status) const U_OVERRIDE;
 959 
 960     /**
 961      * Format a long number using base-10 representation.
 962      *
 963      * @param number    The value to be formatted.
 964      * @param appendTo  Output parameter to receive result.
 965      *                  Result is appended to existing contents.
 966      * @param pos       On input: an alignment field, if desired.
 967      *                  On output: the offsets of the alignment field.
 968      * @return          Reference to &#39;appendTo&#39; parameter.
 969      * @stable ICU 2.0
 970      */
 971     UnicodeString&amp; format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const U_OVERRIDE;
 972 
 973 #ifndef U_HIDE_INTERNAL_API
 974     /**
 975      * Format a long number using base-10 representation.
 976      *
 977      * @param number    The value to be formatted.
 978      * @param appendTo  Output parameter to receive result.
 979      *                  Result is appended to existing contents.
 980      * @param pos       On input: an alignment field, if desired.
 981      *                  On output: the offsets of the alignment field.
<a name="21" id="anc21"></a><span class="line-added"> 982      * @param status    Output param filled with success/failure status.</span>
 983      * @return          Reference to &#39;appendTo&#39; parameter.
 984      * @internal
 985      */
 986     UnicodeString&amp; format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 987                           UErrorCode&amp; status) const U_OVERRIDE;
 988 #endif  /* U_HIDE_INTERNAL_API */
 989 
 990     /**
 991      * Format a long number using base-10 representation.
 992      *
 993      * @param number    The value to be formatted.
 994      * @param appendTo  Output parameter to receive result.
 995      *                  Result is appended to existing contents.
 996      * @param posIter   On return, can be used to iterate over positions
 997      *                  of fields generated by this format call.
 998      *                  Can be NULL.
 999      * @param status    Output param filled with success/failure status.
1000      * @return          Reference to &#39;appendTo&#39; parameter.
1001      * @stable ICU 4.4
1002      */
1003     UnicodeString&amp; format(int32_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
1004                           UErrorCode&amp; status) const U_OVERRIDE;
1005 
1006     /**
1007      * Format an int64 number using base-10 representation.
1008      *
1009      * @param number    The value to be formatted.
1010      * @param appendTo  Output parameter to receive result.
1011      *                  Result is appended to existing contents.
1012      * @param pos       On input: an alignment field, if desired.
1013      *                  On output: the offsets of the alignment field.
1014      * @return          Reference to &#39;appendTo&#39; parameter.
1015      * @stable ICU 2.8
1016      */
1017     UnicodeString&amp; format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const U_OVERRIDE;
1018 
1019 #ifndef U_HIDE_INTERNAL_API
1020     /**
1021      * Format an int64 number using base-10 representation.
1022      *
1023      * @param number    The value to be formatted.
1024      * @param appendTo  Output parameter to receive result.
1025      *                  Result is appended to existing contents.
1026      * @param pos       On input: an alignment field, if desired.
1027      *                  On output: the offsets of the alignment field.
<a name="22" id="anc22"></a><span class="line-added">1028      * @param status    Output param filled with success/failure status.</span>
1029      * @return          Reference to &#39;appendTo&#39; parameter.
1030      * @internal
1031      */
1032     UnicodeString&amp; format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
1033                           UErrorCode&amp; status) const U_OVERRIDE;
1034 #endif  /* U_HIDE_INTERNAL_API */
1035 
1036     /**
1037      * Format an int64 number using base-10 representation.
1038      *
1039      * @param number    The value to be formatted.
1040      * @param appendTo  Output parameter to receive result.
1041      *                  Result is appended to existing contents.
1042      * @param posIter   On return, can be used to iterate over positions
1043      *                  of fields generated by this format call.
1044      *                  Can be NULL.
1045      * @param status    Output param filled with success/failure status.
1046      * @return          Reference to &#39;appendTo&#39; parameter.
1047      * @stable ICU 4.4
1048      */
1049     UnicodeString&amp; format(int64_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
1050                           UErrorCode&amp; status) const U_OVERRIDE;
1051 
1052     /**
1053      * Format a decimal number.
1054      * The syntax of the unformatted number is a &quot;numeric string&quot;
1055      * as defined in the Decimal Arithmetic Specification, available at
1056      * http://speleotrove.com/decimal
1057      *
1058      * @param number    The unformatted number, as a string.
1059      * @param appendTo  Output parameter to receive result.
1060      *                  Result is appended to existing contents.
1061      * @param posIter   On return, can be used to iterate over positions
1062      *                  of fields generated by this format call.
1063      *                  Can be NULL.
1064      * @param status    Output param filled with success/failure status.
1065      * @return          Reference to &#39;appendTo&#39; parameter.
1066      * @stable ICU 4.4
1067      */
1068     UnicodeString&amp; format(StringPiece number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
1069                           UErrorCode&amp; status) const U_OVERRIDE;
1070 
1071 #ifndef U_HIDE_INTERNAL_API
1072 
1073     /**
1074      * Format a decimal number.
1075      * The number is a DecimalQuantity wrapper onto a floating point decimal number.
1076      * The default implementation in NumberFormat converts the decimal number
1077      * to a double and formats that.
1078      *
1079      * @param number    The number, a DecimalQuantity format Decimal Floating Point.
1080      * @param appendTo  Output parameter to receive result.
1081      *                  Result is appended to existing contents.
1082      * @param posIter   On return, can be used to iterate over positions
1083      *                  of fields generated by this format call.
1084      * @param status    Output param filled with success/failure status.
1085      * @return          Reference to &#39;appendTo&#39; parameter.
1086      * @internal
1087      */
1088     UnicodeString&amp; format(const number::impl::DecimalQuantity&amp; number, UnicodeString&amp; appendTo,
1089                           FieldPositionIterator* posIter, UErrorCode&amp; status) const U_OVERRIDE;
1090 
1091     /**
1092      * Format a decimal number.
1093      * The number is a DecimalQuantity wrapper onto a floating point decimal number.
1094      * The default implementation in NumberFormat converts the decimal number
1095      * to a double and formats that.
1096      *
1097      * @param number    The number, a DecimalQuantity format Decimal Floating Point.
1098      * @param appendTo  Output parameter to receive result.
1099      *                  Result is appended to existing contents.
1100      * @param pos       On input: an alignment field, if desired.
1101      *                  On output: the offsets of the alignment field.
1102      * @param status    Output param filled with success/failure status.
1103      * @return          Reference to &#39;appendTo&#39; parameter.
1104      * @internal
1105      */
1106     UnicodeString&amp; format(const number::impl::DecimalQuantity&amp; number, UnicodeString&amp; appendTo,
1107                           FieldPosition&amp; pos, UErrorCode&amp; status) const U_OVERRIDE;
1108 
1109 #endif // U_HIDE_INTERNAL_API
1110 
1111     using NumberFormat::parse;
1112 
1113     /**
1114      * Parse the given string using this object&#39;s choices. The method
1115      * does string comparisons to try to find an optimal match.
1116      * If no object can be parsed, index is unchanged, and NULL is
1117      * returned.  The result is returned as the most parsimonious
<a name="23" id="anc23"></a><span class="line-modified">1118      * type of Formattable that will accommodate all of the</span>
1119      * necessary precision.  For example, if the result is exactly 12,
1120      * it will be returned as a long.  However, if it is 1.5, it will
1121      * be returned as a double.
1122      *
1123      * @param text           The text to be parsed.
1124      * @param result         Formattable to be set to the parse result.
1125      *                       If parse fails, return contents are undefined.
1126      * @param parsePosition  The position to start parsing at on input.
1127      *                       On output, moved to after the last successfully
1128      *                       parse character. On parse failure, does not change.
1129      * @see Formattable
1130      * @stable ICU 2.0
1131      */
1132     void parse(const UnicodeString&amp; text, Formattable&amp; result,
1133                ParsePosition&amp; parsePosition) const U_OVERRIDE;
1134 
1135     /**
1136      * Parses text from the given string as a currency amount.  Unlike
1137      * the parse() method, this method will attempt to parse a generic
1138      * currency name, searching for a match of this object&#39;s locale&#39;s
1139      * currency display names, or for a 3-letter ISO currency code.
1140      * This method will fail if this format is not a currency format,
1141      * that is, if it does not contain the currency pattern symbol
1142      * (U+00A4) in its prefix or suffix.
1143      *
1144      * @param text the string to parse
1145      * @param pos  input-output position; on input, the position within text
1146      *             to match; must have 0 &lt;= pos.getIndex() &lt; text.length();
1147      *             on output, the position after the last matched character.
1148      *             If the parse fails, the position in unchanged upon output.
1149      * @return     if parse succeeds, a pointer to a newly-created CurrencyAmount
1150      *             object (owned by the caller) containing information about
1151      *             the parsed currency; if parse fails, this is NULL.
1152      * @stable ICU 49
1153      */
1154     CurrencyAmount* parseCurrency(const UnicodeString&amp; text, ParsePosition&amp; pos) const U_OVERRIDE;
1155 
1156     /**
1157      * Returns the decimal format symbols, which is generally not changed
1158      * by the programmer or user.
1159      * @return desired DecimalFormatSymbols
1160      * @see DecimalFormatSymbols
1161      * @stable ICU 2.0
1162      */
1163     virtual const DecimalFormatSymbols* getDecimalFormatSymbols(void) const;
1164 
1165     /**
1166      * Sets the decimal format symbols, which is generally not changed
1167      * by the programmer or user.
1168      * @param symbolsToAdopt DecimalFormatSymbols to be adopted.
1169      * @stable ICU 2.0
1170      */
1171     virtual void adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt);
1172 
1173     /**
1174      * Sets the decimal format symbols, which is generally not changed
1175      * by the programmer or user.
1176      * @param symbols DecimalFormatSymbols.
1177      * @stable ICU 2.0
1178      */
1179     virtual void setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols);
1180 
1181 
1182     /**
1183      * Returns the currency plural format information,
1184      * which is generally not changed by the programmer or user.
1185      * @return desired CurrencyPluralInfo
1186      * @stable ICU 4.2
1187      */
1188     virtual const CurrencyPluralInfo* getCurrencyPluralInfo(void) const;
1189 
1190     /**
1191      * Sets the currency plural format information,
1192      * which is generally not changed by the programmer or user.
1193      * @param toAdopt CurrencyPluralInfo to be adopted.
1194      * @stable ICU 4.2
1195      */
1196     virtual void adoptCurrencyPluralInfo(CurrencyPluralInfo* toAdopt);
1197 
1198     /**
1199      * Sets the currency plural format information,
1200      * which is generally not changed by the programmer or user.
1201      * @param info Currency Plural Info.
1202      * @stable ICU 4.2
1203      */
1204     virtual void setCurrencyPluralInfo(const CurrencyPluralInfo&amp; info);
1205 
1206 
1207     /**
1208      * Get the positive prefix.
1209      *
1210      * @param result    Output param which will receive the positive prefix.
1211      * @return          A reference to &#39;result&#39;.
1212      * Examples: +123, $123, sFr123
1213      * @stable ICU 2.0
1214      */
1215     UnicodeString&amp; getPositivePrefix(UnicodeString&amp; result) const;
1216 
1217     /**
1218      * Set the positive prefix.
1219      *
1220      * @param newValue    the new value of the the positive prefix to be set.
1221      * Examples: +123, $123, sFr123
1222      * @stable ICU 2.0
1223      */
1224     virtual void setPositivePrefix(const UnicodeString&amp; newValue);
1225 
1226     /**
1227      * Get the negative prefix.
1228      *
1229      * @param result    Output param which will receive the negative prefix.
1230      * @return          A reference to &#39;result&#39;.
1231      * Examples: -123, ($123) (with negative suffix), sFr-123
1232      * @stable ICU 2.0
1233      */
1234     UnicodeString&amp; getNegativePrefix(UnicodeString&amp; result) const;
1235 
1236     /**
1237      * Set the negative prefix.
1238      *
1239      * @param newValue    the new value of the the negative prefix to be set.
1240      * Examples: -123, ($123) (with negative suffix), sFr-123
1241      * @stable ICU 2.0
1242      */
1243     virtual void setNegativePrefix(const UnicodeString&amp; newValue);
1244 
1245     /**
1246      * Get the positive suffix.
1247      *
1248      * @param result    Output param which will receive the positive suffix.
1249      * @return          A reference to &#39;result&#39;.
1250      * Example: 123%
1251      * @stable ICU 2.0
1252      */
1253     UnicodeString&amp; getPositiveSuffix(UnicodeString&amp; result) const;
1254 
1255     /**
1256      * Set the positive suffix.
1257      *
1258      * @param newValue    the new value of the positive suffix to be set.
1259      * Example: 123%
1260      * @stable ICU 2.0
1261      */
1262     virtual void setPositiveSuffix(const UnicodeString&amp; newValue);
1263 
1264     /**
1265      * Get the negative suffix.
1266      *
1267      * @param result    Output param which will receive the negative suffix.
1268      * @return          A reference to &#39;result&#39;.
1269      * Examples: -123%, ($123) (with positive suffixes)
1270      * @stable ICU 2.0
1271      */
1272     UnicodeString&amp; getNegativeSuffix(UnicodeString&amp; result) const;
1273 
1274     /**
1275      * Set the negative suffix.
1276      *
1277      * @param newValue    the new value of the negative suffix to be set.
1278      * Examples: 123%
1279      * @stable ICU 2.0
1280      */
1281     virtual void setNegativeSuffix(const UnicodeString&amp; newValue);
1282 
<a name="24" id="anc24"></a><span class="line-modified">1283 #ifndef U_HIDE_DRAFT_API</span>
1284     /**
1285      * Whether to show the plus sign on positive (non-negative) numbers; for example, &quot;+12&quot;
<a name="25" id="anc25"></a><span class="line-modified">1286      *</span>
<span class="line-added">1287      * For more control over sign display, use NumberFormatter.</span>
<span class="line-added">1288      *</span>
<span class="line-added">1289      * @return Whether the sign is shown on positive numbers and zero.</span>
<span class="line-added">1290      * @draft ICU 64</span>
1291      */
1292     UBool isSignAlwaysShown() const;
<a name="26" id="anc26"></a>
1293 
1294     /**
<a name="27" id="anc27"></a><span class="line-modified">1295      * Set whether to show the plus sign on positive (non-negative) numbers; for example, &quot;+12&quot;.</span>
<span class="line-modified">1296      *</span>
<span class="line-modified">1297      * For more control over sign display, use NumberFormatter.</span>
<span class="line-added">1298      *</span>
<span class="line-added">1299      * @param value true to always show a sign; false to hide the sign on positive numbers and zero.</span>
<span class="line-added">1300      * @draft ICU 64</span>
1301      */
<a name="28" id="anc28"></a><span class="line-modified">1302     void setSignAlwaysShown(UBool value);</span>
<span class="line-added">1303 #endif  /* U_HIDE_DRAFT_API */</span>
1304 
1305     /**
1306      * Get the multiplier for use in percent, permill, etc.
1307      * For a percentage, set the suffixes to have &quot;%&quot; and the multiplier to be 100.
1308      * (For Arabic, use arabic percent symbol).
1309      * For a permill, set the suffixes to have &quot;\\u2031&quot; and the multiplier to be 1000.
1310      *
1311      * The number may also be multiplied by a power of ten; see getMultiplierScale().
1312      *
1313      * @return    the multiplier for use in percent, permill, etc.
1314      * Examples: with 100, 1.23 -&gt; &quot;123&quot;, and &quot;123&quot; -&gt; 1.23
1315      * @stable ICU 2.0
1316      */
1317     int32_t getMultiplier(void) const;
1318 
1319     /**
1320      * Set the multiplier for use in percent, permill, etc.
1321      * For a percentage, set the suffixes to have &quot;%&quot; and the multiplier to be 100.
1322      * (For Arabic, use arabic percent symbol).
1323      * For a permill, set the suffixes to have &quot;\\u2031&quot; and the multiplier to be 1000.
1324      *
1325      * This method only supports integer multipliers. To multiply by a non-integer, pair this
1326      * method with setMultiplierScale().
1327      *
1328      * @param newValue    the new value of the multiplier for use in percent, permill, etc.
1329      * Examples: with 100, 1.23 -&gt; &quot;123&quot;, and &quot;123&quot; -&gt; 1.23
1330      * @stable ICU 2.0
1331      */
1332     virtual void setMultiplier(int32_t newValue);
1333 
1334 #ifndef U_HIDE_DRAFT_API
1335     /**
1336      * Gets the power of ten by which number should be multiplied before formatting, which
1337      * can be combined with setMultiplier() to multiply by any arbitrary decimal value.
1338      *
1339      * A multiplier scale of 2 corresponds to multiplication by 100, and a multiplier scale
1340      * of -2 corresponds to multiplication by 0.01.
1341      *
1342      * This method is analogous to UNUM_SCALE in getAttribute.
1343      *
1344      * @return    the current value of the power-of-ten multiplier.
1345      * @draft ICU 62
1346      */
1347     int32_t getMultiplierScale(void) const;
<a name="29" id="anc29"></a>
1348 
1349     /**
1350      * Sets a power of ten by which number should be multiplied before formatting, which
1351      * can be combined with setMultiplier() to multiply by any arbitrary decimal value.
1352      *
1353      * A multiplier scale of 2 corresponds to multiplication by 100, and a multiplier scale
1354      * of -2 corresponds to multiplication by 0.01.
1355      *
1356      * For example, to multiply numbers by 0.5 before formatting, you can do:
1357      *
1358      * &lt;pre&gt;
1359      * df.setMultiplier(5);
1360      * df.setMultiplierScale(-1);
1361      * &lt;/pre&gt;
1362      *
1363      * This method is analogous to UNUM_SCALE in setAttribute.
1364      *
1365      * @param newValue    the new value of the power-of-ten multiplier.
1366      * @draft ICU 62
1367      */
<a name="30" id="anc30"></a><span class="line-modified">1368     void setMultiplierScale(int32_t newValue);</span>
<span class="line-added">1369 #endif  /* U_HIDE_DRAFT_API */</span>
1370 
1371     /**
1372      * Get the rounding increment.
1373      * @return A positive rounding increment, or 0.0 if a custom rounding
1374      * increment is not in effect.
1375      * @see #setRoundingIncrement
1376      * @see #getRoundingMode
1377      * @see #setRoundingMode
1378      * @stable ICU 2.0
1379      */
1380     virtual double getRoundingIncrement(void) const;
1381 
1382     /**
1383      * Set the rounding increment.  In the absence of a rounding increment,
1384      *    numbers will be rounded to the number of digits displayed.
1385      * @param newValue A positive rounding increment, or 0.0 to
1386      * use the default rounding increment.
1387      * Negative increments are equivalent to 0.0.
1388      * @see #getRoundingIncrement
1389      * @see #getRoundingMode
1390      * @see #setRoundingMode
1391      * @stable ICU 2.0
1392      */
1393     virtual void setRoundingIncrement(double newValue);
1394 
1395     /**
1396      * Get the rounding mode.
1397      * @return A rounding mode
1398      * @see #setRoundingIncrement
1399      * @see #getRoundingIncrement
1400      * @see #setRoundingMode
1401      * @stable ICU 2.0
1402      */
1403     virtual ERoundingMode getRoundingMode(void) const U_OVERRIDE;
1404 
1405     /**
1406      * Set the rounding mode.
1407      * @param roundingMode A rounding mode
1408      * @see #setRoundingIncrement
1409      * @see #getRoundingIncrement
1410      * @see #getRoundingMode
1411      * @stable ICU 2.0
1412      */
1413     virtual void setRoundingMode(ERoundingMode roundingMode) U_OVERRIDE;
1414 
1415     /**
1416      * Get the width to which the output of format() is padded.
1417      * The width is counted in 16-bit code units.
1418      * @return the format width, or zero if no padding is in effect
1419      * @see #setFormatWidth
1420      * @see #getPadCharacterString
1421      * @see #setPadCharacter
1422      * @see #getPadPosition
1423      * @see #setPadPosition
1424      * @stable ICU 2.0
1425      */
1426     virtual int32_t getFormatWidth(void) const;
1427 
1428     /**
1429      * Set the width to which the output of format() is padded.
1430      * The width is counted in 16-bit code units.
1431      * This method also controls whether padding is enabled.
1432      * @param width the width to which to pad the result of
1433      * format(), or zero to disable padding.  A negative
1434      * width is equivalent to 0.
1435      * @see #getFormatWidth
1436      * @see #getPadCharacterString
1437      * @see #setPadCharacter
1438      * @see #getPadPosition
1439      * @see #setPadPosition
1440      * @stable ICU 2.0
1441      */
1442     virtual void setFormatWidth(int32_t width);
1443 
1444     /**
1445      * Get the pad character used to pad to the format width.  The
1446      * default is &#39; &#39;.
1447      * @return a string containing the pad character. This will always
1448      * have a length of one 32-bit code point.
1449      * @see #setFormatWidth
1450      * @see #getFormatWidth
1451      * @see #setPadCharacter
1452      * @see #getPadPosition
1453      * @see #setPadPosition
1454      * @stable ICU 2.0
1455      */
1456     virtual UnicodeString getPadCharacterString() const;
1457 
1458     /**
1459      * Set the character used to pad to the format width.  If padding
1460      * is not enabled, then this will take effect if padding is later
1461      * enabled.
<a name="31" id="anc31"></a><span class="line-modified">1462      * @param padChar a string containing the pad character. If the string</span>
<span class="line-modified">1463      * has length 0, then the pad character is set to &#39; &#39;.  Otherwise</span>
1464      * padChar.char32At(0) will be used as the pad character.
1465      * @see #setFormatWidth
1466      * @see #getFormatWidth
1467      * @see #getPadCharacterString
1468      * @see #getPadPosition
1469      * @see #setPadPosition
1470      * @stable ICU 2.0
1471      */
1472     virtual void setPadCharacter(const UnicodeString&amp; padChar);
1473 
1474     /**
1475      * Get the position at which padding will take place.  This is the location
1476      * at which padding will be inserted if the result of format()
1477      * is shorter than the format width.
1478      * @return the pad position, one of kPadBeforePrefix,
1479      * kPadAfterPrefix, kPadBeforeSuffix, or
1480      * kPadAfterSuffix.
1481      * @see #setFormatWidth
1482      * @see #getFormatWidth
1483      * @see #setPadCharacter
1484      * @see #getPadCharacterString
1485      * @see #setPadPosition
1486      * @see #EPadPosition
1487      * @stable ICU 2.0
1488      */
1489     virtual EPadPosition getPadPosition(void) const;
1490 
1491     /**
1492      * Set the position at which padding will take place.  This is the location
1493      * at which padding will be inserted if the result of format()
1494      * is shorter than the format width.  This has no effect unless padding is
1495      * enabled.
1496      * @param padPos the pad position, one of kPadBeforePrefix,
1497      * kPadAfterPrefix, kPadBeforeSuffix, or
1498      * kPadAfterSuffix.
1499      * @see #setFormatWidth
1500      * @see #getFormatWidth
1501      * @see #setPadCharacter
1502      * @see #getPadCharacterString
1503      * @see #getPadPosition
1504      * @see #EPadPosition
1505      * @stable ICU 2.0
1506      */
1507     virtual void setPadPosition(EPadPosition padPos);
1508 
1509     /**
1510      * Return whether or not scientific notation is used.
1511      * @return TRUE if this object formats and parses scientific notation
1512      * @see #setScientificNotation
1513      * @see #getMinimumExponentDigits
1514      * @see #setMinimumExponentDigits
1515      * @see #isExponentSignAlwaysShown
1516      * @see #setExponentSignAlwaysShown
1517      * @stable ICU 2.0
1518      */
1519     virtual UBool isScientificNotation(void) const;
1520 
1521     /**
1522      * Set whether or not scientific notation is used. When scientific notation
1523      * is used, the effective maximum number of integer digits is &lt;= 8.  If the
1524      * maximum number of integer digits is set to more than 8, the effective
1525      * maximum will be 1.  This allows this call to generate a &#39;default&#39; scientific
1526      * number format without additional changes.
1527      * @param useScientific TRUE if this object formats and parses scientific
1528      * notation
1529      * @see #isScientificNotation
1530      * @see #getMinimumExponentDigits
1531      * @see #setMinimumExponentDigits
1532      * @see #isExponentSignAlwaysShown
1533      * @see #setExponentSignAlwaysShown
1534      * @stable ICU 2.0
1535      */
1536     virtual void setScientificNotation(UBool useScientific);
1537 
1538     /**
1539      * Return the minimum exponent digits that will be shown.
1540      * @return the minimum exponent digits that will be shown
1541      * @see #setScientificNotation
1542      * @see #isScientificNotation
1543      * @see #setMinimumExponentDigits
1544      * @see #isExponentSignAlwaysShown
1545      * @see #setExponentSignAlwaysShown
1546      * @stable ICU 2.0
1547      */
1548     virtual int8_t getMinimumExponentDigits(void) const;
1549 
1550     /**
1551      * Set the minimum exponent digits that will be shown.  This has no
1552      * effect unless scientific notation is in use.
1553      * @param minExpDig a value &gt;= 1 indicating the fewest exponent digits
1554      * that will be shown.  Values less than 1 will be treated as 1.
1555      * @see #setScientificNotation
1556      * @see #isScientificNotation
1557      * @see #getMinimumExponentDigits
1558      * @see #isExponentSignAlwaysShown
1559      * @see #setExponentSignAlwaysShown
1560      * @stable ICU 2.0
1561      */
1562     virtual void setMinimumExponentDigits(int8_t minExpDig);
1563 
1564     /**
1565      * Return whether the exponent sign is always shown.
1566      * @return TRUE if the exponent is always prefixed with either the
1567      * localized minus sign or the localized plus sign, false if only negative
1568      * exponents are prefixed with the localized minus sign.
1569      * @see #setScientificNotation
1570      * @see #isScientificNotation
1571      * @see #setMinimumExponentDigits
1572      * @see #getMinimumExponentDigits
1573      * @see #setExponentSignAlwaysShown
1574      * @stable ICU 2.0
1575      */
1576     virtual UBool isExponentSignAlwaysShown(void) const;
1577 
1578     /**
1579      * Set whether the exponent sign is always shown.  This has no effect
1580      * unless scientific notation is in use.
1581      * @param expSignAlways TRUE if the exponent is always prefixed with either
1582      * the localized minus sign or the localized plus sign, false if only
1583      * negative exponents are prefixed with the localized minus sign.
1584      * @see #setScientificNotation
1585      * @see #isScientificNotation
1586      * @see #setMinimumExponentDigits
1587      * @see #getMinimumExponentDigits
1588      * @see #isExponentSignAlwaysShown
1589      * @stable ICU 2.0
1590      */
1591     virtual void setExponentSignAlwaysShown(UBool expSignAlways);
1592 
1593     /**
1594      * Return the grouping size. Grouping size is the number of digits between
1595      * grouping separators in the integer portion of a number.  For example,
1596      * in the number &quot;123,456.78&quot;, the grouping size is 3.
1597      *
1598      * @return    the grouping size.
1599      * @see setGroupingSize
1600      * @see NumberFormat::isGroupingUsed
1601      * @see DecimalFormatSymbols::getGroupingSeparator
1602      * @stable ICU 2.0
1603      */
1604     int32_t getGroupingSize(void) const;
1605 
1606     /**
1607      * Set the grouping size. Grouping size is the number of digits between
1608      * grouping separators in the integer portion of a number.  For example,
1609      * in the number &quot;123,456.78&quot;, the grouping size is 3.
1610      *
1611      * @param newValue    the new value of the grouping size.
1612      * @see getGroupingSize
1613      * @see NumberFormat::setGroupingUsed
1614      * @see DecimalFormatSymbols::setGroupingSeparator
1615      * @stable ICU 2.0
1616      */
1617     virtual void setGroupingSize(int32_t newValue);
1618 
1619     /**
1620      * Return the secondary grouping size. In some locales one
1621      * grouping interval is used for the least significant integer
1622      * digits (the primary grouping size), and another is used for all
1623      * others (the secondary grouping size).  A formatter supporting a
1624      * secondary grouping size will return a positive integer unequal
1625      * to the primary grouping size returned by
1626      * getGroupingSize().  For example, if the primary
1627      * grouping size is 4, and the secondary grouping size is 2, then
1628      * the number 123456789 formats as &quot;1,23,45,6789&quot;, and the pattern
1629      * appears as &quot;#,##,###0&quot;.
1630      * @return the secondary grouping size, or a value less than
1631      * one if there is none
1632      * @see setSecondaryGroupingSize
1633      * @see NumberFormat::isGroupingUsed
1634      * @see DecimalFormatSymbols::getGroupingSeparator
1635      * @stable ICU 2.4
1636      */
1637     int32_t getSecondaryGroupingSize(void) const;
1638 
1639     /**
1640      * Set the secondary grouping size. If set to a value less than 1,
1641      * then secondary grouping is turned off, and the primary grouping
1642      * size is used for all intervals, not just the least significant.
1643      *
1644      * @param newValue    the new value of the secondary grouping size.
1645      * @see getSecondaryGroupingSize
1646      * @see NumberFormat#setGroupingUsed
1647      * @see DecimalFormatSymbols::setGroupingSeparator
1648      * @stable ICU 2.4
1649      */
1650     virtual void setSecondaryGroupingSize(int32_t newValue);
1651 
<a name="32" id="anc32"></a><span class="line-modified">1652 #ifndef U_HIDE_DRAFT_API</span>

1653     /**
1654      * Returns the minimum number of grouping digits.
1655      * Grouping separators are output if there are at least this many
1656      * digits to the left of the first (rightmost) grouping separator,
1657      * that is, there are at least (minimum grouping + grouping size) integer digits.
1658      * (Subject to isGroupingUsed().)
1659      *
1660      * For example, if this value is 2, and the grouping size is 3, then
1661      * 9999 -&gt; &quot;9999&quot; and 10000 -&gt; &quot;10,000&quot;
1662      *
<a name="33" id="anc33"></a>

1663      * The default value for this attribute is 0.
1664      * A value of 1, 0, or lower, means that the use of grouping separators
1665      * only depends on the grouping size (and on isGroupingUsed()).
<a name="34" id="anc34"></a><span class="line-modified">1666      *</span>
<span class="line-added">1667      * NOTE: The CLDR data is used in NumberFormatter but not in DecimalFormat.</span>
<span class="line-added">1668      * This is for backwards compatibility reasons.</span>
<span class="line-added">1669      *</span>
<span class="line-added">1670      * For more control over grouping strategies, use NumberFormatter.</span>
1671      *
1672      * @see setMinimumGroupingDigits
1673      * @see getGroupingSize
<a name="35" id="anc35"></a><span class="line-modified">1674      * @draft ICU 64</span>
1675      */
1676     int32_t getMinimumGroupingDigits() const;
1677 
<a name="36" id="anc36"></a>


1678     /**
1679      * Sets the minimum grouping digits. Setting to a value less than or
1680      * equal to 1 turns off minimum grouping digits.
1681      *
<a name="37" id="anc37"></a><span class="line-added">1682      * For more control over grouping strategies, use NumberFormatter.</span>
<span class="line-added">1683      *</span>
1684      * @param newValue the new value of minimum grouping digits.
1685      * @see getMinimumGroupingDigits
<a name="38" id="anc38"></a><span class="line-modified">1686      * @draft ICU 64</span>
1687      */
<a name="39" id="anc39"></a><span class="line-modified">1688     void setMinimumGroupingDigits(int32_t newValue);</span>
<span class="line-added">1689 #endif  /* U_HIDE_DRAFT_API */</span>
1690 
1691 
1692     /**
1693      * Allows you to get the behavior of the decimal separator with integers.
1694      * (The decimal separator will always appear with decimals.)
1695      *
1696      * @return    TRUE if the decimal separator always appear with decimals.
1697      * Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345
1698      * @stable ICU 2.0
1699      */
1700     UBool isDecimalSeparatorAlwaysShown(void) const;
1701 
1702     /**
1703      * Allows you to set the behavior of the decimal separator with integers.
1704      * (The decimal separator will always appear with decimals.)
1705      *
1706      * @param newValue    set TRUE if the decimal separator will always appear with decimals.
1707      * Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345
1708      * @stable ICU 2.0
1709      */
1710     virtual void setDecimalSeparatorAlwaysShown(UBool newValue);
1711 
1712     /**
1713      * Allows you to get the parse behavior of the pattern decimal mark.
1714      *
1715      * @return    TRUE if input must contain a match to decimal mark in pattern
1716      * @stable ICU 54
1717      */
1718     UBool isDecimalPatternMatchRequired(void) const;
1719 
1720     /**
1721      * Allows you to set the parse behavior of the pattern decimal mark.
1722      *
1723      * if TRUE, the input must have a decimal mark if one was specified in the pattern. When
1724      * FALSE the decimal mark may be omitted from the input.
1725      *
1726      * @param newValue    set TRUE if input must contain a match to decimal mark in pattern
1727      * @stable ICU 54
1728      */
1729     virtual void setDecimalPatternMatchRequired(UBool newValue);
1730 
<a name="40" id="anc40"></a><span class="line-added">1731 #ifndef U_HIDE_DRAFT_API</span>
1732     /**
<a name="41" id="anc41"></a><span class="line-modified">1733      * Returns whether to ignore exponents when parsing.</span>
1734      *
<a name="42" id="anc42"></a><span class="line-added">1735      * @return Whether to ignore exponents when parsing.</span>
1736      * @see #setParseNoExponent
<a name="43" id="anc43"></a><span class="line-modified">1737      * @draft ICU 64</span>
1738      */
<a name="44" id="anc44"></a><span class="line-modified">1739     UBool isParseNoExponent() const;</span>
1740 
1741     /**
<a name="45" id="anc45"></a><span class="line-modified">1742      * Specifies whether to stop parsing when an exponent separator is encountered. For</span>
1743      * example, parses &quot;123E4&quot; to 123 (with parse position 3) instead of 1230000 (with parse position
1744      * 5).
1745      *
1746      * @param value true to prevent exponents from being parsed; false to allow them to be parsed.
<a name="46" id="anc46"></a><span class="line-modified">1747      * @draft ICU 64</span>
1748      */
<a name="47" id="anc47"></a><span class="line-modified">1749     void setParseNoExponent(UBool value);</span>
1750 
1751     /**
<a name="48" id="anc48"></a><span class="line-modified">1752      * Returns whether parsing is sensitive to case (lowercase/uppercase).</span>
1753      *
<a name="49" id="anc49"></a><span class="line-added">1754      * @return Whether parsing is case-sensitive.</span>
1755      * @see #setParseCaseSensitive
<a name="50" id="anc50"></a><span class="line-modified">1756      * @draft ICU 64</span>
1757      */
<a name="51" id="anc51"></a><span class="line-modified">1758     UBool isParseCaseSensitive() const;</span>
1759 
1760     /**
<a name="52" id="anc52"></a><span class="line-modified">1761      * Whether to pay attention to case when parsing; default is to ignore case (perform</span>
1762      * case-folding). For example, &quot;A&quot; == &quot;a&quot; in case-insensitive but not case-sensitive mode.
1763      *
1764      * Currency symbols are never case-folded. For example, &quot;us$1.00&quot; will not parse in case-insensitive
1765      * mode, even though &quot;US$1.00&quot; parses.
1766      *
<a name="53" id="anc53"></a><span class="line-modified">1767      * @param value true to enable case-sensitive parsing (the default); false to force</span>
<span class="line-added">1768      *              case-sensitive parsing behavior.</span>
<span class="line-added">1769      * @draft ICU 64</span>
1770      */
<a name="54" id="anc54"></a><span class="line-modified">1771     void setParseCaseSensitive(UBool value);</span>
1772 
1773     /**
<a name="55" id="anc55"></a><span class="line-modified">1774      * Returns whether truncation of high-order integer digits should result in an error.</span>
1775      * By default, setMaximumIntegerDigits truncates high-order digits silently.
1776      *
<a name="56" id="anc56"></a><span class="line-added">1777      * @return Whether an error code is set if high-order digits are truncated.</span>
1778      * @see setFormatFailIfMoreThanMaxDigits
<a name="57" id="anc57"></a><span class="line-modified">1779      * @draft ICU 64</span>
1780      */
<a name="58" id="anc58"></a><span class="line-modified">1781     UBool isFormatFailIfMoreThanMaxDigits() const;</span>
1782 
1783     /**
<a name="59" id="anc59"></a><span class="line-modified">1784      * Sets whether truncation of high-order integer digits should result in an error.</span>
1785      * By default, setMaximumIntegerDigits truncates high-order digits silently.
1786      *
<a name="60" id="anc60"></a><span class="line-modified">1787      * @param value Whether to set an error code if high-order digits are truncated.</span>
<span class="line-added">1788      * @draft ICU 64</span>
1789      */
<a name="61" id="anc61"></a><span class="line-modified">1790     void setFormatFailIfMoreThanMaxDigits(UBool value);</span>
<span class="line-added">1791 #endif  /* U_HIDE_DRAFT_API */</span>
1792 
1793 
1794     /**
1795      * Synthesizes a pattern string that represents the current state
1796      * of this Format object.
1797      *
1798      * @param result    Output param which will receive the pattern.
1799      *                  Previous contents are deleted.
1800      * @return          A reference to &#39;result&#39;.
1801      * @see applyPattern
1802      * @stable ICU 2.0
1803      */
1804     virtual UnicodeString&amp; toPattern(UnicodeString&amp; result) const;
1805 
1806     /**
1807      * Synthesizes a localized pattern string that represents the current
1808      * state of this Format object.
1809      *
1810      * @param result    Output param which will receive the localized pattern.
1811      *                  Previous contents are deleted.
1812      * @return          A reference to &#39;result&#39;.
1813      * @see applyPattern
1814      * @stable ICU 2.0
1815      */
1816     virtual UnicodeString&amp; toLocalizedPattern(UnicodeString&amp; result) const;
1817 
1818     /**
1819      * Apply the given pattern to this Format object.  A pattern is a
1820      * short-hand specification for the various formatting properties.
1821      * These properties can also be changed individually through the
1822      * various setter methods.
1823      * &lt;P&gt;
1824      * There is no limit to integer digits are set
1825      * by this routine, since that is the typical end-user desire;
1826      * use setMaximumInteger if you want to set a real value.
1827      * For negative numbers, use a second pattern, separated by a semicolon
1828      * &lt;pre&gt;
1829      * .      Example &quot;#,#00.0#&quot; -&gt; 1,234.56
1830      * &lt;/pre&gt;
1831      * This means a minimum of 2 integer digits, 1 fraction digit, and
1832      * a maximum of 2 fraction digits.
1833      * &lt;pre&gt;
1834      * .      Example: &quot;#,#00.0#;(#,#00.0#)&quot; for negatives in parantheses.
1835      * &lt;/pre&gt;
1836      * In negative patterns, the minimum and maximum counts are ignored;
1837      * these are presumed to be set in the positive pattern.
1838      *
1839      * @param pattern    The pattern to be applied.
1840      * @param parseError Struct to recieve information on position
1841      *                   of error if an error is encountered
1842      * @param status     Output param set to success/failure code on
1843      *                   exit. If the pattern is invalid, this will be
1844      *                   set to a failure result.
1845      * @stable ICU 2.0
1846      */
1847     virtual void applyPattern(const UnicodeString&amp; pattern, UParseError&amp; parseError, UErrorCode&amp; status);
1848 
1849     /**
1850      * Sets the pattern.
1851      * @param pattern   The pattern to be applied.
1852      * @param status    Output param set to success/failure code on
1853      *                  exit. If the pattern is invalid, this will be
1854      *                  set to a failure result.
1855      * @stable ICU 2.0
1856      */
1857     virtual void applyPattern(const UnicodeString&amp; pattern, UErrorCode&amp; status);
1858 
1859     /**
1860      * Apply the given pattern to this Format object.  The pattern
1861      * is assumed to be in a localized notation. A pattern is a
1862      * short-hand specification for the various formatting properties.
1863      * These properties can also be changed individually through the
1864      * various setter methods.
1865      * &lt;P&gt;
1866      * There is no limit to integer digits are set
1867      * by this routine, since that is the typical end-user desire;
1868      * use setMaximumInteger if you want to set a real value.
1869      * For negative numbers, use a second pattern, separated by a semicolon
1870      * &lt;pre&gt;
1871      * .      Example &quot;#,#00.0#&quot; -&gt; 1,234.56
1872      * &lt;/pre&gt;
1873      * This means a minimum of 2 integer digits, 1 fraction digit, and
1874      * a maximum of 2 fraction digits.
1875      *
1876      * Example: &quot;#,#00.0#;(#,#00.0#)&quot; for negatives in parantheses.
1877      *
1878      * In negative patterns, the minimum and maximum counts are ignored;
1879      * these are presumed to be set in the positive pattern.
1880      *
1881      * @param pattern   The localized pattern to be applied.
1882      * @param parseError Struct to recieve information on position
1883      *                   of error if an error is encountered
1884      * @param status    Output param set to success/failure code on
1885      *                  exit. If the pattern is invalid, this will be
1886      *                  set to a failure result.
1887      * @stable ICU 2.0
1888      */
1889     virtual void applyLocalizedPattern(const UnicodeString&amp; pattern, UParseError&amp; parseError,
1890                                        UErrorCode&amp; status);
1891 
1892     /**
1893      * Apply the given pattern to this Format object.
1894      *
1895      * @param pattern   The localized pattern to be applied.
1896      * @param status    Output param set to success/failure code on
1897      *                  exit. If the pattern is invalid, this will be
1898      *                  set to a failure result.
1899      * @stable ICU 2.0
1900      */
1901     virtual void applyLocalizedPattern(const UnicodeString&amp; pattern, UErrorCode&amp; status);
1902 
1903 
1904     /**
1905      * Sets the maximum number of digits allowed in the integer portion of a
1906      * number. This override limits the integer digit count to 309.
1907      *
1908      * @param newValue    the new value of the maximum number of digits
1909      *                      allowed in the integer portion of a number.
1910      * @see NumberFormat#setMaximumIntegerDigits
1911      * @stable ICU 2.0
1912      */
1913     void setMaximumIntegerDigits(int32_t newValue) U_OVERRIDE;
1914 
1915     /**
1916      * Sets the minimum number of digits allowed in the integer portion of a
1917      * number. This override limits the integer digit count to 309.
1918      *
1919      * @param newValue    the new value of the minimum number of digits
1920      *                      allowed in the integer portion of a number.
1921      * @see NumberFormat#setMinimumIntegerDigits
1922      * @stable ICU 2.0
1923      */
1924     void setMinimumIntegerDigits(int32_t newValue) U_OVERRIDE;
1925 
1926     /**
1927      * Sets the maximum number of digits allowed in the fraction portion of a
1928      * number. This override limits the fraction digit count to 340.
1929      *
1930      * @param newValue    the new value of the maximum number of digits
1931      *                    allowed in the fraction portion of a number.
1932      * @see NumberFormat#setMaximumFractionDigits
1933      * @stable ICU 2.0
1934      */
1935     void setMaximumFractionDigits(int32_t newValue) U_OVERRIDE;
1936 
1937     /**
1938      * Sets the minimum number of digits allowed in the fraction portion of a
1939      * number. This override limits the fraction digit count to 340.
1940      *
1941      * @param newValue    the new value of the minimum number of digits
1942      *                    allowed in the fraction portion of a number.
1943      * @see NumberFormat#setMinimumFractionDigits
1944      * @stable ICU 2.0
1945      */
1946     void setMinimumFractionDigits(int32_t newValue) U_OVERRIDE;
1947 
1948     /**
1949      * Returns the minimum number of significant digits that will be
1950      * displayed. This value has no effect unless areSignificantDigitsUsed()
1951      * returns true.
1952      * @return the fewest significant digits that will be shown
1953      * @stable ICU 3.0
1954      */
1955     int32_t getMinimumSignificantDigits() const;
1956 
1957     /**
1958      * Returns the maximum number of significant digits that will be
1959      * displayed. This value has no effect unless areSignificantDigitsUsed()
1960      * returns true.
1961      * @return the most significant digits that will be shown
1962      * @stable ICU 3.0
1963      */
1964     int32_t getMaximumSignificantDigits() const;
1965 
1966     /**
1967      * Sets the minimum number of significant digits that will be
1968      * displayed.  If &lt;code&gt;min&lt;/code&gt; is less than one then it is set
1969      * to one.  If the maximum significant digits count is less than
1970      * &lt;code&gt;min&lt;/code&gt;, then it is set to &lt;code&gt;min&lt;/code&gt;.
1971      * This function also enables the use of significant digits
1972      * by this formatter - areSignificantDigitsUsed() will return TRUE.
1973      * @see #areSignificantDigitsUsed
1974      * @param min the fewest significant digits to be shown
1975      * @stable ICU 3.0
1976      */
1977     void setMinimumSignificantDigits(int32_t min);
1978 
1979     /**
1980      * Sets the maximum number of significant digits that will be
1981      * displayed.  If &lt;code&gt;max&lt;/code&gt; is less than one then it is set
1982      * to one.  If the minimum significant digits count is greater
1983      * than &lt;code&gt;max&lt;/code&gt;, then it is set to &lt;code&gt;max&lt;/code&gt;.
1984      * This function also enables the use of significant digits
1985      * by this formatter - areSignificantDigitsUsed() will return TRUE.
1986      * @see #areSignificantDigitsUsed
1987      * @param max the most significant digits to be shown
1988      * @stable ICU 3.0
1989      */
1990     void setMaximumSignificantDigits(int32_t max);
1991 
1992     /**
1993      * Returns true if significant digits are in use, or false if
1994      * integer and fraction digit counts are in use.
1995      * @return true if significant digits are in use
1996      * @stable ICU 3.0
1997      */
1998     UBool areSignificantDigitsUsed() const;
1999 
2000     /**
2001      * Sets whether significant digits are in use, or integer and
2002      * fraction digit counts are in use.
2003      * @param useSignificantDigits true to use significant digits, or
2004      * false to use integer and fraction digit counts
2005      * @stable ICU 3.0
2006      */
2007     void setSignificantDigitsUsed(UBool useSignificantDigits);
2008 
2009     /**
2010      * Sets the currency used to display currency
2011      * amounts.  This takes effect immediately, if this format is a
2012      * currency format.  If this format is not a currency format, then
2013      * the currency is used if and when this object becomes a
2014      * currency format through the application of a new pattern.
2015      * @param theCurrency a 3-letter ISO code indicating new currency
2016      * to use.  It need not be null-terminated.  May be the empty
2017      * string or NULL to indicate no currency.
2018      * @param ec input-output error code
2019      * @stable ICU 3.0
2020      */
2021     void setCurrency(const char16_t* theCurrency, UErrorCode&amp; ec) U_OVERRIDE;
2022 
2023     /**
2024      * Sets the currency used to display currency amounts.  See
2025      * setCurrency(const char16_t*, UErrorCode&amp;).
2026      * @deprecated ICU 3.0. Use setCurrency(const char16_t*, UErrorCode&amp;).
2027      */
2028     virtual void setCurrency(const char16_t* theCurrency);
2029 
2030     /**
<a name="62" id="anc62"></a><span class="line-modified">2031      * Sets the `Currency Usage` object used to display currency.</span>
2032      * This takes effect immediately, if this format is a
2033      * currency format.
<a name="63" id="anc63"></a><span class="line-modified">2034      * @param newUsage new currency usage object to use.</span>
<span class="line-added">2035      * @param ec input-output error code</span>
2036      * @stable ICU 54
2037      */
2038     void setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec);
2039 
2040     /**
<a name="64" id="anc64"></a><span class="line-modified">2041      * Returns the `Currency Usage` object used to display currency</span>
2042      * @stable ICU 54
2043      */
2044     UCurrencyUsage getCurrencyUsage() const;
2045 
2046 #ifndef U_HIDE_INTERNAL_API
2047 
2048     /**
2049      *  Format a number and save it into the given DecimalQuantity.
2050      *  Internal, not intended for public use.
2051      *  @internal
2052      */
2053     void formatToDecimalQuantity(double number, number::impl::DecimalQuantity&amp; output,
2054                                  UErrorCode&amp; status) const;
2055 
2056     /**
2057      *  Get a DecimalQuantity corresponding to a formattable as it would be
2058      *  formatted by this DecimalFormat.
2059      *  Internal, not intended for public use.
2060      *  @internal
2061      */
2062     void formatToDecimalQuantity(const Formattable&amp; number, number::impl::DecimalQuantity&amp; output,
2063                                  UErrorCode&amp; status) const;
2064 
<a name="65" id="anc65"></a><span class="line-modified">2065 #endif  /* U_HIDE_INTERNAL_API */</span>
2066 
2067 #ifndef U_HIDE_DRAFT_API
2068     /**
<a name="66" id="anc66"></a><span class="line-modified">2069      * Converts this DecimalFormat to a (Localized)NumberFormatter. Starting</span>
<span class="line-modified">2070      * in ICU 60, NumberFormatter is the recommended way to format numbers.</span>
<span class="line-added">2071      * You can use the returned LocalizedNumberFormatter to format numbers and</span>
<span class="line-added">2072      * get a FormattedNumber, which contains a string as well as additional</span>
<span class="line-added">2073      * annotations about the formatted value.</span>
<span class="line-added">2074      *</span>
<span class="line-added">2075      * If a memory allocation failure occurs, the return value of this method</span>
<span class="line-added">2076      * might be null. If you are concerned about correct recovery from</span>
<span class="line-added">2077      * out-of-memory situations, use this pattern:</span>
<span class="line-added">2078      *</span>
<span class="line-added">2079      * &lt;pre&gt;</span>
<span class="line-added">2080      * FormattedNumber result;</span>
<span class="line-added">2081      * if (auto* ptr = df-&gt;toNumberFormatter(status)) {</span>
<span class="line-added">2082      *     result = ptr-&gt;formatDouble(123, status);</span>
<span class="line-added">2083      * }</span>
<span class="line-added">2084      * &lt;/pre&gt;</span>
<span class="line-added">2085      *</span>
<span class="line-added">2086      * If you are not concerned about out-of-memory situations, or if your</span>
<span class="line-added">2087      * environment throws exceptions when memory allocation failure occurs,</span>
<span class="line-added">2088      * you can chain the methods, like this:</span>
<span class="line-added">2089      *</span>
<span class="line-added">2090      * &lt;pre&gt;</span>
<span class="line-added">2091      * FormattedNumber result = df</span>
<span class="line-added">2092      *     -&gt;toNumberFormatter(status)</span>
<span class="line-added">2093      *     -&gt;formatDouble(123, status);</span>
<span class="line-added">2094      * &lt;/pre&gt;</span>
2095      *
2096      * NOTE: The returned LocalizedNumberFormatter is owned by this DecimalFormat.
2097      * If a non-const method is called on the DecimalFormat, or if the DecimalFormat
2098      * is deleted, the object becomes invalid. If you plan to keep the return value
2099      * beyond the lifetime of the DecimalFormat, copy it to a local variable:
2100      *
2101      * &lt;pre&gt;
<a name="67" id="anc67"></a><span class="line-modified">2102      * LocalizedNumberFormatter lnf;</span>
<span class="line-added">2103      * if (auto* ptr = df-&gt;toNumberFormatter(status)) {</span>
<span class="line-added">2104      *     lnf = *ptr;</span>
<span class="line-added">2105      * }</span>
2106      * &lt;/pre&gt;
2107      *
<a name="68" id="anc68"></a><span class="line-modified">2108      * @param status Set on failure, like U_MEMORY_ALLOCATION_ERROR.</span>
<span class="line-added">2109      * @return A pointer to an internal object, or nullptr on failure.</span>
<span class="line-added">2110      *         Do not delete the return value!</span>
<span class="line-added">2111      * @draft ICU 64</span>
<span class="line-added">2112      */</span>
<span class="line-added">2113     const number::LocalizedNumberFormatter* toNumberFormatter(UErrorCode&amp; status) const;</span>
<span class="line-added">2114 #endif  /* U_HIDE_DRAFT_API */</span>
<span class="line-added">2115 </span>
<span class="line-added">2116 #ifndef U_HIDE_DEPRECATED_API</span>
<span class="line-added">2117     /**</span>
<span class="line-added">2118      * Deprecated: Like {@link #toNumberFormatter(UErrorCode&amp;) const},</span>
<span class="line-added">2119      * but does not take an error code.</span>
2120      *
<a name="69" id="anc69"></a><span class="line-modified">2121      * The new signature should be used in case an error occurs while returning the</span>
<span class="line-modified">2122      * LocalizedNumberFormatter.</span>

2123      *
<a name="70" id="anc70"></a><span class="line-modified">2124      * This old signature will be removed in ICU 65.</span>
<span class="line-modified">2125      *</span>
<span class="line-modified">2126      * @return A reference to an internal object.</span>
<span class="line-added">2127      * @deprecated ICU 64</span>
2128      */
2129     const number::LocalizedNumberFormatter&amp; toNumberFormatter() const;
<a name="71" id="anc71"></a><span class="line-modified">2130 #endif  /* U_HIDE_DEPRECATED_API */</span>
2131 
2132     /**
2133      * Return the class ID for this class.  This is useful only for
2134      * comparing to a return value from getDynamicClassID().  For example:
2135      * &lt;pre&gt;
2136      * .      Base* polymorphic_pointer = createPolymorphicObject();
2137      * .      if (polymorphic_pointer-&gt;getDynamicClassID() ==
2138      * .          Derived::getStaticClassID()) ...
2139      * &lt;/pre&gt;
2140      * @return          The class ID for all objects of this class.
2141      * @stable ICU 2.0
2142      */
2143     static UClassID U_EXPORT2 getStaticClassID(void);
2144 
2145     /**
2146      * Returns a unique class ID POLYMORPHICALLY.  Pure virtual override.
2147      * This method is to implement a simple version of RTTI, since not all
2148      * C++ compilers support genuine RTTI.  Polymorphic operator==() and
2149      * clone() methods call this method.
2150      *
2151      * @return          The class ID for this object. All objects of a
2152      *                  given class have the same class ID.  Objects of
2153      *                  other classes have different class IDs.
2154      * @stable ICU 2.0
2155      */
2156     UClassID getDynamicClassID(void) const U_OVERRIDE;
2157 
2158   private:
2159 
2160     /** Rebuilds the formatter object from the property bag. */
2161     void touch(UErrorCode&amp; status);
2162 
<a name="72" id="anc72"></a><span class="line-modified">2163     /** Rebuilds the formatter object, ignoring any error code. */</span>
2164     void touchNoError();
2165 
2166     /**
2167      * Updates the property bag with settings from the given pattern.
2168      *
2169      * @param pattern The pattern string to parse.
2170      * @param ignoreRounding Whether to leave out rounding information (minFrac, maxFrac, and rounding
2171      *     increment) when parsing the pattern. This may be desirable if a custom rounding mode, such
2172      *     as CurrencyUsage, is to be used instead. One of {@link
2173      *     PatternStringParser#IGNORE_ROUNDING_ALWAYS}, {@link PatternStringParser#IGNORE_ROUNDING_IF_CURRENCY},
2174      *     or {@link PatternStringParser#IGNORE_ROUNDING_NEVER}.
2175      * @see PatternAndPropertyUtils#parseToExistingProperties
2176      */
2177     void setPropertiesFromPattern(const UnicodeString&amp; pattern, int32_t ignoreRounding,
2178                                   UErrorCode&amp; status);
2179 
2180     const numparse::impl::NumberParserImpl* getParser(UErrorCode&amp; status) const;
2181 
2182     const numparse::impl::NumberParserImpl* getCurrencyParser(UErrorCode&amp; status) const;
2183 
2184     static void fieldPositionHelper(const number::FormattedNumber&amp; formatted, FieldPosition&amp; fieldPosition,
2185                                     int32_t offset, UErrorCode&amp; status);
2186 
2187     static void fieldPositionIteratorHelper(const number::FormattedNumber&amp; formatted,
2188                                             FieldPositionIterator* fpi, int32_t offset, UErrorCode&amp; status);
2189 
2190     void setupFastFormat();
2191 
2192     bool fastFormatDouble(double input, UnicodeString&amp; output) const;
2193 
2194     bool fastFormatInt64(int64_t input, UnicodeString&amp; output) const;
2195 
2196     void doFastFormatInt32(int32_t input, bool isNegative, UnicodeString&amp; output) const;
2197 
2198     //=====================================================================================//
2199     //                                   INSTANCE FIELDS                                   //
2200     //=====================================================================================//
2201 
<a name="73" id="anc73"></a><span class="line-modified">2202 </span>
<span class="line-modified">2203     // One instance field for the implementation, keep all fields inside of an implementation</span>
<span class="line-added">2204     // class defined in number_mapper.h</span>
<span class="line-added">2205     number::impl::DecimalFormatFields* fields = nullptr;</span>
2206 
2207     // Allow child class CompactDecimalFormat to access fProperties:
2208     friend class CompactDecimalFormat;
2209 
<a name="74" id="anc74"></a><span class="line-added">2210     // Allow MeasureFormat to use fieldPositionHelper:</span>
<span class="line-added">2211     friend class MeasureFormat;</span>
<span class="line-added">2212 </span>
2213 };
2214 
2215 U_NAMESPACE_END
2216 
2217 #endif /* #if !UCONFIG_NO_FORMATTING */
2218 
2219 #endif // _DECIMFMT
2220 //eof
<a name="75" id="anc75"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="75" type="hidden" />
</body>
</html>