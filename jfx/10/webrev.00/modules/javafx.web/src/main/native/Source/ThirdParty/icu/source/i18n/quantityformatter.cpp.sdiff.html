<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/quantityformatter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="plurrule_impl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="quantityformatter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/quantityformatter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8 * quantityformatter.cpp
  9 */
 10 
 11 #include &quot;unicode/utypes.h&quot;
 12 
 13 #if !UCONFIG_NO_FORMATTING
 14 
 15 #include &quot;unicode/simpleformatter.h&quot;
 16 #include &quot;quantityformatter.h&quot;
 17 #include &quot;uassert.h&quot;
 18 #include &quot;unicode/unistr.h&quot;
 19 #include &quot;unicode/decimfmt.h&quot;
 20 #include &quot;cstring.h&quot;
 21 #include &quot;unicode/plurrule.h&quot;
 22 #include &quot;charstr.h&quot;
 23 #include &quot;unicode/fmtable.h&quot;
 24 #include &quot;unicode/fieldpos.h&quot;
 25 #include &quot;standardplural.h&quot;
 26 #include &quot;uassert.h&quot;
 27 #include &quot;number_decimalquantity.h&quot;


 28 
 29 U_NAMESPACE_BEGIN
 30 
 31 QuantityFormatter::QuantityFormatter() {
 32     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(formatters); ++i) {
 33         formatters[i] = NULL;
 34     }
 35 }
 36 
 37 QuantityFormatter::QuantityFormatter(const QuantityFormatter &amp;other) {
 38     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(formatters); ++i) {
 39         if (other.formatters[i] == NULL) {
 40             formatters[i] = NULL;
 41         } else {
 42             formatters[i] = new SimpleFormatter(*other.formatters[i]);
 43         }
 44     }
 45 }
 46 
 47 QuantityFormatter &amp;QuantityFormatter::operator=(
</pre>
<hr />
<pre>
157             return StandardPlural::OTHER;
158         }
159         pluralKeyword = rules.select(dq);
160         decFmt-&gt;format(number, formattedNumber, pos, status);
161     } else {
162         if (number.getType() == Formattable::kDouble) {
163             pluralKeyword = rules.select(number.getDouble());
164         } else if (number.getType() == Formattable::kLong) {
165             pluralKeyword = rules.select(number.getLong());
166         } else if (number.getType() == Formattable::kInt64) {
167             pluralKeyword = rules.select((double) number.getInt64());
168         } else {
169             status = U_ILLEGAL_ARGUMENT_ERROR;
170             return StandardPlural::OTHER;
171         }
172         fmt.format(number, formattedNumber, pos, status);
173     }
174     return StandardPlural::orOtherFromString(pluralKeyword);
175 }
176 

































177 UnicodeString &amp;QuantityFormatter::format(
178             const SimpleFormatter &amp;pattern,
179             const UnicodeString &amp;value,
180             UnicodeString &amp;appendTo,
181             FieldPosition &amp;pos,
182             UErrorCode &amp;status) {
183     if (U_FAILURE(status)) {
184         return appendTo;
185     }
186     const UnicodeString *param = &amp;value;
187     int32_t offset;
188     pattern.formatAndAppend(&amp;param, 1, appendTo, &amp;offset, 1, status);
189     if (pos.getBeginIndex() != 0 || pos.getEndIndex() != 0) {
190         if (offset &gt;= 0) {
191             pos.setBeginIndex(pos.getBeginIndex() + offset);
192             pos.setEndIndex(pos.getEndIndex() + offset);
193         } else {
194             pos.setBeginIndex(0);
195             pos.setEndIndex(0);
196         }
</pre>
</td>
<td>
<hr />
<pre>
  8 * quantityformatter.cpp
  9 */
 10 
 11 #include &quot;unicode/utypes.h&quot;
 12 
 13 #if !UCONFIG_NO_FORMATTING
 14 
 15 #include &quot;unicode/simpleformatter.h&quot;
 16 #include &quot;quantityformatter.h&quot;
 17 #include &quot;uassert.h&quot;
 18 #include &quot;unicode/unistr.h&quot;
 19 #include &quot;unicode/decimfmt.h&quot;
 20 #include &quot;cstring.h&quot;
 21 #include &quot;unicode/plurrule.h&quot;
 22 #include &quot;charstr.h&quot;
 23 #include &quot;unicode/fmtable.h&quot;
 24 #include &quot;unicode/fieldpos.h&quot;
 25 #include &quot;standardplural.h&quot;
 26 #include &quot;uassert.h&quot;
 27 #include &quot;number_decimalquantity.h&quot;
<span class="line-added"> 28 #include &quot;number_utypes.h&quot;</span>
<span class="line-added"> 29 #include &quot;number_stringbuilder.h&quot;</span>
 30 
 31 U_NAMESPACE_BEGIN
 32 
 33 QuantityFormatter::QuantityFormatter() {
 34     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(formatters); ++i) {
 35         formatters[i] = NULL;
 36     }
 37 }
 38 
 39 QuantityFormatter::QuantityFormatter(const QuantityFormatter &amp;other) {
 40     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(formatters); ++i) {
 41         if (other.formatters[i] == NULL) {
 42             formatters[i] = NULL;
 43         } else {
 44             formatters[i] = new SimpleFormatter(*other.formatters[i]);
 45         }
 46     }
 47 }
 48 
 49 QuantityFormatter &amp;QuantityFormatter::operator=(
</pre>
<hr />
<pre>
159             return StandardPlural::OTHER;
160         }
161         pluralKeyword = rules.select(dq);
162         decFmt-&gt;format(number, formattedNumber, pos, status);
163     } else {
164         if (number.getType() == Formattable::kDouble) {
165             pluralKeyword = rules.select(number.getDouble());
166         } else if (number.getType() == Formattable::kLong) {
167             pluralKeyword = rules.select(number.getLong());
168         } else if (number.getType() == Formattable::kInt64) {
169             pluralKeyword = rules.select((double) number.getInt64());
170         } else {
171             status = U_ILLEGAL_ARGUMENT_ERROR;
172             return StandardPlural::OTHER;
173         }
174         fmt.format(number, formattedNumber, pos, status);
175     }
176     return StandardPlural::orOtherFromString(pluralKeyword);
177 }
178 
<span class="line-added">179 void QuantityFormatter::formatAndSelect(</span>
<span class="line-added">180         double quantity,</span>
<span class="line-added">181         const NumberFormat&amp; fmt,</span>
<span class="line-added">182         const PluralRules&amp; rules,</span>
<span class="line-added">183         number::impl::NumberStringBuilder&amp; output,</span>
<span class="line-added">184         StandardPlural::Form&amp; pluralForm,</span>
<span class="line-added">185         UErrorCode&amp; status) {</span>
<span class="line-added">186     UnicodeString pluralKeyword;</span>
<span class="line-added">187     const DecimalFormat* df = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;fmt);</span>
<span class="line-added">188     if (df != nullptr) {</span>
<span class="line-added">189         number::impl::UFormattedNumberData fn;</span>
<span class="line-added">190         fn.quantity.setToDouble(quantity);</span>
<span class="line-added">191         df-&gt;toNumberFormatter().formatImpl(&amp;fn, status);</span>
<span class="line-added">192         if (U_FAILURE(status)) {</span>
<span class="line-added">193             return;</span>
<span class="line-added">194         }</span>
<span class="line-added">195         output = std::move(fn.getStringRef());</span>
<span class="line-added">196         pluralKeyword = rules.select(fn.quantity);</span>
<span class="line-added">197     } else {</span>
<span class="line-added">198         UnicodeString result;</span>
<span class="line-added">199         fmt.format(quantity, result, status);</span>
<span class="line-added">200         if (U_FAILURE(status)) {</span>
<span class="line-added">201             return;</span>
<span class="line-added">202         }</span>
<span class="line-added">203         output.append(result, UNUM_FIELD_COUNT, status);</span>
<span class="line-added">204         if (U_FAILURE(status)) {</span>
<span class="line-added">205             return;</span>
<span class="line-added">206         }</span>
<span class="line-added">207         pluralKeyword = rules.select(quantity);</span>
<span class="line-added">208     }</span>
<span class="line-added">209     pluralForm = StandardPlural::orOtherFromString(pluralKeyword);</span>
<span class="line-added">210 }</span>
<span class="line-added">211 </span>
212 UnicodeString &amp;QuantityFormatter::format(
213             const SimpleFormatter &amp;pattern,
214             const UnicodeString &amp;value,
215             UnicodeString &amp;appendTo,
216             FieldPosition &amp;pos,
217             UErrorCode &amp;status) {
218     if (U_FAILURE(status)) {
219         return appendTo;
220     }
221     const UnicodeString *param = &amp;value;
222     int32_t offset;
223     pattern.formatAndAppend(&amp;param, 1, appendTo, &amp;offset, 1, status);
224     if (pos.getBeginIndex() != 0 || pos.getEndIndex() != 0) {
225         if (offset &gt;= 0) {
226             pos.setBeginIndex(pos.getBeginIndex() + offset);
227             pos.setEndIndex(pos.getEndIndex() + offset);
228         } else {
229             pos.setBeginIndex(0);
230             pos.setEndIndex(0);
231         }
</pre>
</td>
</tr>
</table>
<center><a href="plurrule_impl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="quantityformatter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>