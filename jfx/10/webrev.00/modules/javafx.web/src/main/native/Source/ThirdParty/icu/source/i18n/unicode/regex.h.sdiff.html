<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/regex.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="rbnf.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="region.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/regex.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7 **********************************************************************
   8 *   file name:  regex.h
   9 *   encoding:   UTF-8
  10 *   indentation:4
  11 *
  12 *   created on: 2002oct22
  13 *   created by: Andy Heninger
  14 *
  15 *   ICU Regular Expressions, API for C++
  16 */
  17 
  18 #ifndef REGEX_H
  19 #define REGEX_H
  20 
  21 //#define REGEX_DEBUG
  22 
  23 /**
  24  * \file
  25  * \brief  C++ API:  Regular Expressions
  26  *
<span class="line-modified">  27  * &lt;h2&gt;Regular Expression API&lt;/h2&gt;</span>
<span class="line-modified">  28  *</span>
<span class="line-modified">  29  * &lt;p&gt;The ICU API for processing regular expressions consists of two classes,</span>
<span class="line-removed">  30  *  &lt;code&gt;RegexPattern&lt;/code&gt; and &lt;code&gt;RegexMatcher&lt;/code&gt;.</span>
<span class="line-removed">  31  *  &lt;code&gt;RegexPattern&lt;/code&gt; objects represent a pre-processed, or compiled</span>
  32  *  regular expression.  They are created from a regular expression pattern string,
<span class="line-modified">  33  *  and can be used to create &lt;code&gt;RegexMatcher&lt;/code&gt; objects for the pattern.&lt;/p&gt;</span>
  34  *
<span class="line-modified">  35  * &lt;p&gt;Class &lt;code&gt;RegexMatcher&lt;/code&gt; bundles together a regular expression</span>
  36  *  pattern and a target string to which the search pattern will be applied.
<span class="line-modified">  37  *  &lt;code&gt;RegexMatcher&lt;/code&gt; includes API for doing plain find or search</span>
  38  *  operations, for search and replace operations, and for obtaining detailed
<span class="line-modified">  39  *  information about bounds of a match. &lt;/p&gt;</span>
  40  *
<span class="line-modified">  41  * &lt;p&gt;Note that by constructing &lt;code&gt;RegexMatcher&lt;/code&gt; objects directly from regular</span>
  42  * expression pattern strings application code can be simplified and the explicit
<span class="line-modified">  43  * need for &lt;code&gt;RegexPattern&lt;/code&gt; objects can usually be eliminated.</span>
<span class="line-modified">  44  * &lt;/p&gt;</span>
  45  */
  46 
  47 #include &quot;unicode/utypes.h&quot;
  48 
  49 #if !UCONFIG_NO_REGULAR_EXPRESSIONS
  50 
  51 #include &quot;unicode/uobject.h&quot;
  52 #include &quot;unicode/unistr.h&quot;
  53 #include &quot;unicode/utext.h&quot;
  54 #include &quot;unicode/parseerr.h&quot;
  55 
  56 #include &quot;unicode/uregex.h&quot;
  57 
  58 // Forward Declarations
  59 
  60 struct UHashtable;
  61 
  62 U_NAMESPACE_BEGIN
  63 
  64 struct Regex8BitSet;
  65 class  RegexCImpl;
  66 class  RegexMatcher;
  67 class  RegexPattern;
  68 struct REStackFrame;
  69 class  RuleBasedBreakIterator;
  70 class  UnicodeSet;
  71 class  UVector;
  72 class  UVector32;
  73 class  UVector64;
  74 
  75 
  76 /**
<span class="line-modified">  77   * Class &lt;code&gt;RegexPattern&lt;/code&gt; represents a compiled regular expression.  It includes</span>
  78   * factory methods for creating a RegexPattern object from the source (string) form
  79   * of a regular expression, methods for creating RegexMatchers that allow the pattern
  80   * to be applied to input text, and a few convenience methods for simple common
  81   * uses of regular expressions.
  82   *
<span class="line-modified">  83   * &lt;p&gt;Class RegexPattern is not intended to be subclassed.&lt;/p&gt;</span>
  84   *
  85   * @stable ICU 2.4
  86   */
  87 class U_I18N_API RegexPattern U_FINAL : public UObject {
  88 public:
  89 
  90     /**
  91      * default constructor.  Create a RegexPattern object that refers to no actual
  92      *   pattern.  Not normally needed; RegexPattern objects are usually
<span class="line-modified">  93      *   created using the factory method &lt;code&gt;compile()&lt;/code&gt;.</span>
  94      *
  95      * @stable ICU 2.4
  96      */
  97     RegexPattern();
  98 
  99     /**
 100      * Copy Constructor.  Create a new RegexPattern object that is equivalent
 101      *                    to the source object.
 102      * @param source the pattern object to be copied.
 103      * @stable ICU 2.4
 104      */
 105     RegexPattern(const RegexPattern &amp;source);
 106 
 107     /**
 108      * Destructor.  Note that a RegexPattern object must persist so long as any
 109      *  RegexMatcher objects that were created from the RegexPattern are active.
 110      * @stable ICU 2.4
 111      */
 112     virtual ~RegexPattern();
 113 
 114     /**
 115      * Comparison operator.  Two RegexPattern objects are considered equal if they
<span class="line-modified"> 116      * were constructed from identical source patterns using the same match flag</span>
 117      * settings.
 118      * @param that a RegexPattern object to compare with &quot;this&quot;.
 119      * @return TRUE if the objects are equivalent.
 120      * @stable ICU 2.4
 121      */
 122     UBool           operator==(const RegexPattern&amp; that) const;
 123 
 124     /**
 125      * Comparison operator.  Two RegexPattern objects are considered equal if they
<span class="line-modified"> 126      * were constructed from identical source patterns using the same match flag</span>
 127      * settings.
 128      * @param that a RegexPattern object to compare with &quot;this&quot;.
 129      * @return TRUE if the objects are different.
 130      * @stable ICU 2.4
 131      */
 132     inline UBool    operator!=(const RegexPattern&amp; that) const {return ! operator ==(that);}
 133 
 134     /**
 135      * Assignment operator.  After assignment, this RegexPattern will behave identically
 136      *     to the source object.
 137      * @stable ICU 2.4
 138      */
 139     RegexPattern  &amp;operator =(const RegexPattern &amp;source);
 140 
 141     /**
 142      * Create an exact copy of this RegexPattern object.  Since RegexPattern is not
 143      * intended to be subclassed, &lt;code&gt;clone()&lt;/code&gt; and the copy construction are
 144      * equivalent operations.
 145      * @return the copy of this RegexPattern
 146      * @stable ICU 2.4
 147      */
 148     virtual RegexPattern  *clone() const;
 149 
 150 
 151    /**
 152     * Compiles the regular expression in string form into a RegexPattern
 153     * object.  These compile methods, rather than the constructors, are the usual
 154     * way that RegexPattern objects are created.
 155     *
<span class="line-modified"> 156     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 157     * objects created from the pattern are active.  RegexMatchers keep a pointer
 158     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 159     * catastrophic error.&lt;/p&gt;</span>
 160     *
<span class="line-modified"> 161     * &lt;p&gt;All pattern match mode flags are set to their default values.&lt;/p&gt;</span>
 162     *
<span class="line-modified"> 163     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
 164     *    from a pattern string rather than separately compiling the pattern and
<span class="line-modified"> 165     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
 166     *
 167     * @param regex The regular expression to be compiled.
 168     * @param pe    Receives the position (line and column nubers) of any error
 169     *              within the regular expression.)
 170     * @param status A reference to a UErrorCode to receive any errors.
 171     * @return      A regexPattern object for the compiled pattern.
 172     *
 173     * @stable ICU 2.4
 174     */
 175     static RegexPattern * U_EXPORT2 compile( const UnicodeString &amp;regex,
 176         UParseError          &amp;pe,
 177         UErrorCode           &amp;status);
 178 
 179    /**
 180     * Compiles the regular expression in string form into a RegexPattern
 181     * object.  These compile methods, rather than the constructors, are the usual
 182     * way that RegexPattern objects are created.
 183     *
<span class="line-modified"> 184     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 185     * objects created from the pattern are active.  RegexMatchers keep a pointer
 186     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 187     * catastrophic error.&lt;/p&gt;</span>
 188     *
<span class="line-modified"> 189     * &lt;p&gt;All pattern match mode flags are set to their default values.&lt;/p&gt;</span>
 190     *
<span class="line-modified"> 191     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
 192     *    from a pattern string rather than separately compiling the pattern and
<span class="line-modified"> 193     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
 194     *
 195     * @param regex The regular expression to be compiled. Note, the text referred
 196     *              to by this UText must not be deleted during the lifetime of the
 197     *              RegexPattern object or any RegexMatcher object created from it.
 198     * @param pe    Receives the position (line and column nubers) of any error
 199     *              within the regular expression.)
 200     * @param status A reference to a UErrorCode to receive any errors.
 201     * @return      A regexPattern object for the compiled pattern.
 202     *
 203     * @stable ICU 4.6
 204     */
 205     static RegexPattern * U_EXPORT2 compile( UText *regex,
 206         UParseError          &amp;pe,
 207         UErrorCode           &amp;status);
 208 
 209    /**
 210     * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified"> 211     * object using the specified match mode flags.  These compile methods,</span>
 212     * rather than the constructors, are the usual way that RegexPattern objects
 213     * are created.
 214     *
<span class="line-modified"> 215     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 216     * objects created from the pattern are active.  RegexMatchers keep a pointer
 217     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 218     * catastrophic error.&lt;/p&gt;</span>
 219     *
<span class="line-modified"> 220     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
 221     *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified"> 222     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
 223     *
 224     * @param regex The regular expression to be compiled.
<span class="line-modified"> 225     * @param flags The match mode flags to be used.</span>
 226     * @param pe    Receives the position (line and column numbers) of any error
 227     *              within the regular expression.)
 228     * @param status   A reference to a UErrorCode to receive any errors.
 229     * @return      A regexPattern object for the compiled pattern.
 230     *
 231     * @stable ICU 2.4
 232     */
 233     static RegexPattern * U_EXPORT2 compile( const UnicodeString &amp;regex,
 234         uint32_t             flags,
 235         UParseError          &amp;pe,
 236         UErrorCode           &amp;status);
 237 
 238    /**
 239     * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified"> 240     * object using the specified match mode flags.  These compile methods,</span>
 241     * rather than the constructors, are the usual way that RegexPattern objects
 242     * are created.
 243     *
<span class="line-modified"> 244     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 245     * objects created from the pattern are active.  RegexMatchers keep a pointer
 246     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 247     * catastrophic error.&lt;/p&gt;</span>
 248     *
<span class="line-modified"> 249     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
 250     *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified"> 251     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
 252     *
 253     * @param regex The regular expression to be compiled. Note, the text referred
 254     *              to by this UText must not be deleted during the lifetime of the
 255     *              RegexPattern object or any RegexMatcher object created from it.
<span class="line-modified"> 256     * @param flags The match mode flags to be used.</span>
 257     * @param pe    Receives the position (line and column numbers) of any error
 258     *              within the regular expression.)
 259     * @param status   A reference to a UErrorCode to receive any errors.
 260     * @return      A regexPattern object for the compiled pattern.
 261     *
 262     * @stable ICU 4.6
 263     */
 264     static RegexPattern * U_EXPORT2 compile( UText *regex,
 265         uint32_t             flags,
 266         UParseError          &amp;pe,
 267         UErrorCode           &amp;status);
 268 
 269    /**
 270     * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified"> 271     * object using the specified match mode flags.  These compile methods,</span>
 272     * rather than the constructors, are the usual way that RegexPattern objects
 273     * are created.
 274     *
<span class="line-modified"> 275     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 276     * objects created from the pattern are active.  RegexMatchers keep a pointer
 277     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 278     * catastrophic error.&lt;/p&gt;</span>
 279     *
<span class="line-modified"> 280     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
 281     *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified"> 282     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
 283     *
 284     * @param regex The regular expression to be compiled.
<span class="line-modified"> 285     * @param flags The match mode flags to be used.</span>
 286     * @param status   A reference to a UErrorCode to receive any errors.
 287     * @return      A regexPattern object for the compiled pattern.
 288     *
 289     * @stable ICU 2.6
 290     */
 291     static RegexPattern * U_EXPORT2 compile( const UnicodeString &amp;regex,
 292         uint32_t             flags,
 293         UErrorCode           &amp;status);
 294 
 295    /**
 296     * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified"> 297     * object using the specified match mode flags.  These compile methods,</span>
 298     * rather than the constructors, are the usual way that RegexPattern objects
 299     * are created.
 300     *
<span class="line-modified"> 301     * &lt;p&gt;Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 302     * objects created from the pattern are active.  RegexMatchers keep a pointer
 303     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 304     * catastrophic error.&lt;/p&gt;</span>
 305     *
<span class="line-modified"> 306     * &lt;p&gt;Note that it is often more convenient to construct a RegexMatcher directly</span>
 307     *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified"> 308     *    then creating a RegexMatcher object from the pattern.&lt;/p&gt;</span>
 309     *
 310     * @param regex The regular expression to be compiled. Note, the text referred
 311     *              to by this UText must not be deleted during the lifetime of the
 312     *              RegexPattern object or any RegexMatcher object created from it.
<span class="line-modified"> 313     * @param flags The match mode flags to be used.</span>
 314     * @param status   A reference to a UErrorCode to receive any errors.
 315     * @return      A regexPattern object for the compiled pattern.
 316     *
 317     * @stable ICU 4.6
 318     */
 319     static RegexPattern * U_EXPORT2 compile( UText *regex,
 320         uint32_t             flags,
 321         UErrorCode           &amp;status);
 322 
 323    /**
<span class="line-modified"> 324     * Get the match mode flags that were used when compiling this pattern.</span>
<span class="line-modified"> 325     * @return  the match mode flags</span>
 326     * @stable ICU 2.4
 327     */
 328     virtual uint32_t flags() const;
 329 
 330    /**
 331     * Creates a RegexMatcher that will match the given input against this pattern.  The
 332     * RegexMatcher can then be used to perform match, find or replace operations
 333     * on the input.  Note that a RegexPattern object must not be deleted while
 334     * RegexMatchers created from it still exist and might possibly be used again.
<span class="line-modified"> 335     * &lt;p&gt;</span>
 336     * The matcher will retain a reference to the supplied input string, and all regexp
 337     * pattern matching operations happen directly on this original string.  It is
 338     * critical that the string not be altered or deleted before use by the regular
 339     * expression operations is complete.
 340     *
 341     * @param input    The input string to which the regular expression will be applied.
 342     * @param status   A reference to a UErrorCode to receive any errors.
 343     * @return         A RegexMatcher object for this pattern and input.
 344     *
 345     * @stable ICU 2.4
 346     */
 347     virtual RegexMatcher *matcher(const UnicodeString &amp;input,
 348         UErrorCode          &amp;status) const;
 349 
 350 private:
 351     /**
 352      * Cause a compilation error if an application accidentally attempts to
 353      *   create a matcher with a (char16_t *) string as input rather than
 354      *   a UnicodeString.  Avoids a dangling reference to a temporary string.
<span class="line-modified"> 355      * &lt;p&gt;</span>
 356      * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
 357      * using one of the aliasing constructors, such as
<span class="line-modified"> 358      * &lt;code&gt;UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);&lt;/code&gt;</span>
 359      * or in a UText, using
<span class="line-modified"> 360      * &lt;code&gt;utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);&lt;/code&gt;</span>
 361      *
 362      */
 363     RegexMatcher *matcher(const char16_t *input,
 364         UErrorCode          &amp;status) const;
 365 public:
 366 
 367 
 368    /**
 369     * Creates a RegexMatcher that will match against this pattern.  The
 370     * RegexMatcher can be used to perform match, find or replace operations.
 371     * Note that a RegexPattern object must not be deleted while
 372     * RegexMatchers created from it still exist and might possibly be used again.
 373     *
 374     * @param status   A reference to a UErrorCode to receive any errors.
 375     * @return      A RegexMatcher object for this pattern and input.
 376     *
 377     * @stable ICU 2.6
 378     */
 379     virtual RegexMatcher *matcher(UErrorCode  &amp;status) const;
 380 
</pre>
<hr />
<pre>
 504      *                This is an array of actual UnicodeString objects, not an
 505      *                array of pointers to strings.  Local (stack based) arrays can
 506      *                work well here.
 507      * @param destCapacity  The number of elements in the destination array.
 508      *                If the number of fields found is less than destCapacity, the
 509      *                extra strings in the destination array are not altered.
 510      *                If the number of destination strings is less than the number
 511      *                of fields, the trailing part of the input string, including any
 512      *                field delimiters, is placed in the last destination string.
 513      * @param status  A reference to a UErrorCode to receive any errors.
 514      * @return        The number of fields into which the input string was split.
 515      * @stable ICU 2.4
 516      */
 517     virtual int32_t  split(const UnicodeString &amp;input,
 518         UnicodeString    dest[],
 519         int32_t          destCapacity,
 520         UErrorCode       &amp;status) const;
 521 
 522 
 523     /**
<span class="line-modified"> 524      * Split a string into fields.  Somewhat like split() from Perl or Java.</span>
 525      * Pattern matches identify delimiters that separate the input
 526      * into fields.  The input data between the delimiters becomes the
 527      * fields themselves.
 528      *
 529      * If the delimiter pattern includes capture groups, the captured text will
 530      * also appear in the destination array of output strings, interspersed
 531      * with the fields.  This is similar to Perl, but differs from Java,
 532      * which ignores the presence of capture groups in the pattern.
 533      *
 534      * Trailing empty fields will always be returned, assuming sufficient
 535      * destination capacity.  This differs from the default behavior for Java
 536      * and Perl where trailing empty fields are not returned.
 537      *
 538      * The number of strings produced by the split operation is returned.
 539      * This count includes the strings from capture groups in the delimiter pattern.
 540      * This behavior differs from Java, which ignores capture groups.
 541      *
 542      *  For the best performance on split() operations,
<span class="line-modified"> 543      *  &lt;code&gt;RegexMatcher::split&lt;/code&gt; is preferable to this function</span>
 544      *
 545      * @param input   The string to be split into fields.  The field delimiters
 546      *                match the pattern (in the &quot;this&quot; object)
 547      * @param dest    An array of mutable UText structs to receive the results of the split.
 548      *                If a field is NULL, a new UText is allocated to contain the results for
 549      *                that field. This new UText is not guaranteed to be mutable.
 550      * @param destCapacity  The number of elements in the destination array.
 551      *                If the number of fields found is less than destCapacity, the
 552      *                extra strings in the destination array are not altered.
 553      *                If the number of destination strings is less than the number
 554      *                of fields, the trailing part of the input string, including any
 555      *                field delimiters, is placed in the last destination string.
 556      * @param status  A reference to a UErrorCode to receive any errors.
 557      * @return        The number of destination strings used.
 558      *
 559      * @stable ICU 4.6
 560      */
 561     virtual int32_t  split(UText *input,
 562         UText            *dest[],
 563         int32_t          destCapacity,
</pre>
<hr />
<pre>
 656  *  class RegexMatcher bundles together a regular expression pattern and
 657  *  input text to which the expression can be applied.  It includes methods
 658  *  for testing for matches, and for find and replace operations.
 659  *
 660  * &lt;p&gt;Class RegexMatcher is not intended to be subclassed.&lt;/p&gt;
 661  *
 662  * @stable ICU 2.4
 663  */
 664 class U_I18N_API RegexMatcher U_FINAL : public UObject {
 665 public:
 666 
 667     /**
 668       * Construct a RegexMatcher for a regular expression.
 669       * This is a convenience method that avoids the need to explicitly create
 670       * a RegexPattern object.  Note that if several RegexMatchers need to be
 671       * created for the same expression, it will be more efficient to
 672       * separately create and cache a RegexPattern object, and use
 673       * its matcher() method to create the RegexMatcher objects.
 674       *
 675       *  @param regexp The Regular Expression to be compiled.
<span class="line-modified"> 676       *  @param flags  Regular expression options, such as case insensitive matching.</span>
<span class="line-removed"> 677       *                @see UREGEX_CASE_INSENSITIVE</span>
 678       *  @param status Any errors are reported by setting this UErrorCode variable.
 679       *  @stable ICU 2.6
 680       */
 681     RegexMatcher(const UnicodeString &amp;regexp, uint32_t flags, UErrorCode &amp;status);
 682 
 683     /**
 684       * Construct a RegexMatcher for a regular expression.
 685       * This is a convenience method that avoids the need to explicitly create
 686       * a RegexPattern object.  Note that if several RegexMatchers need to be
 687       * created for the same expression, it will be more efficient to
 688       * separately create and cache a RegexPattern object, and use
 689       * its matcher() method to create the RegexMatcher objects.
 690       *
 691       *  @param regexp The regular expression to be compiled.
<span class="line-modified"> 692       *  @param flags  Regular expression options, such as case insensitive matching.</span>
<span class="line-removed"> 693       *                @see UREGEX_CASE_INSENSITIVE</span>
 694       *  @param status Any errors are reported by setting this UErrorCode variable.
 695       *
 696       *  @stable ICU 4.6
 697       */
 698     RegexMatcher(UText *regexp, uint32_t flags, UErrorCode &amp;status);
 699 
 700     /**
 701       * Construct a RegexMatcher for a regular expression.
 702       * This is a convenience method that avoids the need to explicitly create
 703       * a RegexPattern object.  Note that if several RegexMatchers need to be
 704       * created for the same expression, it will be more efficient to
 705       * separately create and cache a RegexPattern object, and use
 706       * its matcher() method to create the RegexMatcher objects.
<span class="line-modified"> 707       * &lt;p&gt;</span>
 708       * The matcher will retain a reference to the supplied input string, and all regexp
 709       * pattern matching operations happen directly on the original string.  It is
 710       * critical that the string not be altered or deleted before use by the regular
 711       * expression operations is complete.
 712       *
 713       *  @param regexp The Regular Expression to be compiled.
 714       *  @param input  The string to match.  The matcher retains a reference to the
 715       *                caller&#39;s string; mo copy is made.
<span class="line-modified"> 716       *  @param flags  Regular expression options, such as case insensitive matching.</span>
<span class="line-removed"> 717       *                @see UREGEX_CASE_INSENSITIVE</span>
 718       *  @param status Any errors are reported by setting this UErrorCode variable.
 719       *  @stable ICU 2.6
 720       */
 721     RegexMatcher(const UnicodeString &amp;regexp, const UnicodeString &amp;input,
 722         uint32_t flags, UErrorCode &amp;status);
 723 
 724     /**
 725       * Construct a RegexMatcher for a regular expression.
 726       * This is a convenience method that avoids the need to explicitly create
 727       * a RegexPattern object.  Note that if several RegexMatchers need to be
 728       * created for the same expression, it will be more efficient to
 729       * separately create and cache a RegexPattern object, and use
 730       * its matcher() method to create the RegexMatcher objects.
<span class="line-modified"> 731       * &lt;p&gt;</span>
 732       * The matcher will make a shallow clone of the supplied input text, and all regexp
 733       * pattern matching operations happen on this clone.  While read-only operations on
 734       * the supplied text are permitted, it is critical that the underlying string not be
 735       * altered or deleted before use by the regular expression operations is complete.
 736       *
 737       *  @param regexp The Regular Expression to be compiled.
 738       *  @param input  The string to match.  The matcher retains a shallow clone of the text.
<span class="line-modified"> 739       *  @param flags  Regular expression options, such as case insensitive matching.</span>
<span class="line-removed"> 740       *                @see UREGEX_CASE_INSENSITIVE</span>
 741       *  @param status Any errors are reported by setting this UErrorCode variable.
 742       *
 743       *  @stable ICU 4.6
 744       */
 745     RegexMatcher(UText *regexp, UText *input,
 746         uint32_t flags, UErrorCode &amp;status);
 747 
 748 private:
 749     /**
 750      * Cause a compilation error if an application accidentally attempts to
 751      *   create a matcher with a (char16_t *) string as input rather than
 752      *   a UnicodeString.    Avoids a dangling reference to a temporary string.
<span class="line-modified"> 753      * &lt;p&gt;</span>
 754      * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
 755      * using one of the aliasing constructors, such as
<span class="line-modified"> 756      * &lt;code&gt;UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);&lt;/code&gt;</span>
 757      * or in a UText, using
<span class="line-modified"> 758      * &lt;code&gt;utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);&lt;/code&gt;</span>
<span class="line-removed"> 759      *</span>
 760      */
 761     RegexMatcher(const UnicodeString &amp;regexp, const char16_t *input,
 762         uint32_t flags, UErrorCode &amp;status);
 763 public:
 764 
 765 
 766    /**
 767     *   Destructor.
 768     *
 769     *  @stable ICU 2.4
 770     */
 771     virtual ~RegexMatcher();
 772 
 773 
 774    /**
 775     *   Attempts to match the entire input region against the pattern.
 776     *    @param   status     A reference to a UErrorCode to receive any errors.
 777     *    @return TRUE if there is a match
 778     *    @stable ICU 2.4
 779     */
</pre>
<hr />
<pre>
 782 
 783    /**
 784     *   Resets the matcher, then attempts to match the input beginning
 785     *   at the specified startIndex, and extending to the end of the input.
 786     *   The input region is reset to include the entire input string.
 787     *   A successful match must extend to the end of the input.
 788     *    @param   startIndex The input string (native) index at which to begin matching.
 789     *    @param   status     A reference to a UErrorCode to receive any errors.
 790     *    @return TRUE if there is a match
 791     *    @stable ICU 2.8
 792     */
 793     virtual UBool matches(int64_t startIndex, UErrorCode &amp;status);
 794 
 795 
 796    /**
 797     *   Attempts to match the input string, starting from the beginning of the region,
 798     *   against the pattern.  Like the matches() method, this function
 799     *   always starts at the beginning of the input region;
 800     *   unlike that function, it does not require that the entire region be matched.
 801     *
<span class="line-modified"> 802     *   &lt;p&gt;If the match succeeds then more information can be obtained via the &lt;code&gt;start()&lt;/code&gt;,</span>
<span class="line-modified"> 803     *     &lt;code&gt;end()&lt;/code&gt;, and &lt;code&gt;group()&lt;/code&gt; functions.&lt;/p&gt;</span>
 804     *
 805     *    @param   status     A reference to a UErrorCode to receive any errors.
 806     *    @return  TRUE if there is a match at the start of the input string.
 807     *    @stable ICU 2.4
 808     */
 809     virtual UBool lookingAt(UErrorCode &amp;status);
 810 
 811 
 812   /**
 813     *   Attempts to match the input string, starting from the specified index, against the pattern.
 814     *   The match may be of any length, and is not required to extend to the end
 815     *   of the input string.  Contrast with match().
 816     *
<span class="line-modified"> 817     *   &lt;p&gt;If the match succeeds then more information can be obtained via the &lt;code&gt;start()&lt;/code&gt;,</span>
<span class="line-modified"> 818     *     &lt;code&gt;end()&lt;/code&gt;, and &lt;code&gt;group()&lt;/code&gt; functions.&lt;/p&gt;</span>
 819     *
 820     *    @param   startIndex The input string (native) index at which to begin matching.
 821     *    @param   status     A reference to a UErrorCode to receive any errors.
 822     *    @return  TRUE if there is a match.
 823     *    @stable ICU 2.8
 824     */
 825     virtual UBool lookingAt(int64_t startIndex, UErrorCode &amp;status);
 826 
 827 
 828    /**
 829     *  Find the next pattern match in the input string.
 830     *  The find begins searching the input at the location following the end of
 831     *  the previous match, or at the start of the string if there is no previous match.
<span class="line-modified"> 832     *  If a match is found, &lt;code&gt;start(), end()&lt;/code&gt; and &lt;code&gt;group()&lt;/code&gt;</span>
 833     *  will provide more information regarding the match.
<span class="line-modified"> 834     *  &lt;p&gt;Note that if the input string is changed by the application,</span>
 835     *     use find(startPos, status) instead of find(), because the saved starting
<span class="line-modified"> 836     *     position may not be valid with the altered input string.&lt;/p&gt;</span>
 837     *  @return  TRUE if a match is found.
 838     *  @stable ICU 2.4
 839     */
 840     virtual UBool find();
 841 
 842 
 843    /**
 844     *  Find the next pattern match in the input string.
 845     *  The find begins searching the input at the location following the end of
 846     *  the previous match, or at the start of the string if there is no previous match.
<span class="line-modified"> 847     *  If a match is found, &lt;code&gt;start(), end()&lt;/code&gt; and &lt;code&gt;group()&lt;/code&gt;</span>
 848     *  will provide more information regarding the match.
<span class="line-modified"> 849     *  &lt;p&gt;Note that if the input string is changed by the application,</span>
<span class="line-modified"> 850     *     use find(startPos, status) instead of find(), because the saved starting</span>
<span class="line-modified"> 851     *     position may not be valid with the altered input string.&lt;/p&gt;</span>

 852     *  @param   status  A reference to a UErrorCode to receive any errors.
 853     *  @return  TRUE if a match is found.
 854     * @stable ICU 55
 855     */
 856     virtual UBool find(UErrorCode &amp;status);
 857 
 858    /**
 859     *   Resets this RegexMatcher and then attempts to find the next substring of the
 860     *   input string that matches the pattern, starting at the specified index.
 861     *
 862     *   @param   start     The (native) index in the input string to begin the search.
 863     *   @param   status    A reference to a UErrorCode to receive any errors.
 864     *   @return  TRUE if a match is found.
 865     *   @stable ICU 2.4
 866     */
 867     virtual UBool find(int64_t start, UErrorCode &amp;status);
 868 
 869 
 870    /**
 871     *   Returns a string containing the text matched by the previous match.
</pre>
<hr />
<pre>
1061     *   @stable ICU 4.6
1062     */
1063     virtual int64_t end64(int32_t group, UErrorCode &amp;status) const;
1064 
1065    /**
1066     *   Resets this matcher.  The effect is to remove any memory of previous matches,
1067     *       and to cause subsequent find() operations to begin at the beginning of
1068     *       the input string.
1069     *
1070     *   @return this RegexMatcher.
1071     *   @stable ICU 2.4
1072     */
1073     virtual RegexMatcher &amp;reset();
1074 
1075 
1076    /**
1077     *   Resets this matcher, and set the current input position.
1078     *   The effect is to remove any memory of previous matches,
1079     *       and to cause subsequent find() operations to begin at
1080     *       the specified (native) position in the input string.
<span class="line-modified">1081     * &lt;p&gt;</span>
1082     *   The matcher&#39;s region is reset to its default, which is the entire
1083     *   input string.
<span class="line-modified">1084     * &lt;p&gt;</span>
1085     *   An alternative to this function is to set a match region
1086     *   beginning at the desired index.
1087     *
1088     *   @return this RegexMatcher.
1089     *   @stable ICU 2.8
1090     */
1091     virtual RegexMatcher &amp;reset(int64_t index, UErrorCode &amp;status);
1092 
1093 
1094    /**
1095     *   Resets this matcher with a new input string.  This allows instances of RegexMatcher
1096     *     to be reused, which is more efficient than creating a new RegexMatcher for
1097     *     each input string to be processed.
1098     *   @param input The new string on which subsequent pattern matches will operate.
1099     *                The matcher retains a reference to the callers string, and operates
1100     *                directly on that.  Ownership of the string remains with the caller.
1101     *                Because no copy of the string is made, it is essential that the
1102     *                caller not delete the string until after regexp operations on it
1103     *                are done.
1104     *                Note that while a reset on the matcher with an input string that is then
</pre>
<hr />
<pre>
1141     *  of a string being matched, but always operates directly on the original text
1142     *  provided by the user. Refreshing simply drops the references to the old text
1143     *  and replaces them with references to the new.
1144     *
1145     *  Caution:  this function is normally used only by very specialized,
1146     *  system-level code.  One example use case is with garbage collection that moves
1147     *  the text in memory.
1148     *
1149     * @param input      The new (moved) text string.
1150     * @param status     Receives errors detected by this function.
1151     *
1152     * @stable ICU 4.8
1153     */
1154     virtual RegexMatcher &amp;refreshInputText(UText *input, UErrorCode &amp;status);
1155 
1156 private:
1157     /**
1158      * Cause a compilation error if an application accidentally attempts to
1159      *   reset a matcher with a (char16_t *) string as input rather than
1160      *   a UnicodeString.    Avoids a dangling reference to a temporary string.
<span class="line-modified">1161      * &lt;p&gt;</span>
1162      * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
1163      * using one of the aliasing constructors, such as
<span class="line-modified">1164      * &lt;code&gt;UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);&lt;/code&gt;</span>
1165      * or in a UText, using
<span class="line-modified">1166      * &lt;code&gt;utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);&lt;/code&gt;</span>
1167      *
1168      */
1169     RegexMatcher &amp;reset(const char16_t *input);
1170 public:
1171 
1172    /**
1173     *   Returns the input string being matched.  Ownership of the string belongs to
1174     *   the matcher; it should not be altered or deleted. This method will work even if the input
1175     *   was originally supplied as a UText.
1176     *   @return the input string
1177     *   @stable ICU 2.4
1178     */
1179     virtual const UnicodeString &amp;input() const;
1180 
1181    /**
1182     *   Returns the input string being matched.  This is the live input text; it should not be
1183     *   altered or deleted. This method will work even if the input was originally supplied as
1184     *   a UnicodeString.
1185     *   @return the input text
1186     *
</pre>
<hr />
<pre>
1395     *    replacement string. The replacement string may contain references to
1396     *    capture groups.
1397     *
1398     *    @param   replacement a string containing the replacement text.
1399     *    @param   dest        a mutable UText in which the results are placed.
1400     *                          If NULL, a new UText will be created (which may not be mutable).
1401     *    @param   status      a reference to a UErrorCode to receive any errors.
1402     *    @return              a string containing the results of the find and replace.
1403     *                          If a pre-allocated UText was provided, it will always be used and returned.
1404     *
1405     *    @stable ICU 4.6
1406     */
1407     virtual UText *replaceAll(UText *replacement, UText *dest, UErrorCode &amp;status);
1408 
1409 
1410    /**
1411     * Replaces the first substring of the input that matches
1412     * the pattern with the replacement string.   This is a convenience
1413     * function that provides a complete find-and-replace operation.
1414     *
<span class="line-modified">1415     * &lt;p&gt;This function first resets this RegexMatcher. It then scans the input string</span>
1416     * looking for a match of the pattern. Input that is not part
1417     * of the match is appended directly to the result string; the match is replaced
1418     * in the result by the replacement string. The replacement string may contain
<span class="line-modified">1419     * references to captured groups.&lt;/p&gt;</span>
1420     *
<span class="line-modified">1421     * &lt;p&gt;The state of the matcher (the position at which a subsequent find()</span>
1422     *    would begin) after completing a replaceFirst() is not specified.  The
<span class="line-modified">1423     *    RegexMatcher should be reset before doing additional find() operations.&lt;/p&gt;</span>
1424     *
1425     *    @param   replacement a string containing the replacement text.
1426     *    @param   status      a reference to a UErrorCode to receive any errors.
1427     *    @return              a string containing the results of the find and replace.
1428     *    @stable ICU 2.4
1429     */
1430     virtual UnicodeString replaceFirst(const UnicodeString &amp;replacement, UErrorCode &amp;status);
1431 
1432 
1433    /**
1434     * Replaces the first substring of the input that matches
1435     * the pattern with the replacement string.   This is a convenience
1436     * function that provides a complete find-and-replace operation.
1437     *
<span class="line-modified">1438     * &lt;p&gt;This function first resets this RegexMatcher. It then scans the input string</span>
1439     * looking for a match of the pattern. Input that is not part
1440     * of the match is appended directly to the result string; the match is replaced
1441     * in the result by the replacement string. The replacement string may contain
<span class="line-modified">1442     * references to captured groups.&lt;/p&gt;</span>
1443     *
<span class="line-modified">1444     * &lt;p&gt;The state of the matcher (the position at which a subsequent find()</span>
1445     *    would begin) after completing a replaceFirst() is not specified.  The
<span class="line-modified">1446     *    RegexMatcher should be reset before doing additional find() operations.&lt;/p&gt;</span>
1447     *
1448     *    @param   replacement a string containing the replacement text.
1449     *    @param   dest        a mutable UText in which the results are placed.
1450     *                          If NULL, a new UText will be created (which may not be mutable).
1451     *    @param   status      a reference to a UErrorCode to receive any errors.
1452     *    @return              a string containing the results of the find and replace.
1453     *                          If a pre-allocated UText was provided, it will always be used and returned.
1454     *
1455     *    @stable ICU 4.6
1456     */
1457     virtual UText *replaceFirst(UText *replacement, UText *dest, UErrorCode &amp;status);
1458 
1459 
1460    /**
1461     *   Implements a replace operation intended to be used as part of an
1462     *   incremental find-and-replace.
1463     *
<span class="line-modified">1464     *   &lt;p&gt;The input string, starting from the end of the previous replacement and ending at</span>
1465     *   the start of the current match, is appended to the destination string.  Then the
1466     *   replacement string is appended to the output string,
<span class="line-modified">1467     *   including handling any substitutions of captured text.&lt;/p&gt;</span>
1468     *
<span class="line-modified">1469     *   &lt;p&gt;For simple, prepackaged, non-incremental find-and-replace</span>
<span class="line-modified">1470     *   operations, see replaceFirst() or replaceAll().&lt;/p&gt;</span>
1471     *
1472     *   @param   dest        A UnicodeString to which the results of the find-and-replace are appended.
1473     *   @param   replacement A UnicodeString that provides the text to be substituted for
1474     *                        the input text that matched the regexp pattern.  The replacement
1475     *                        text may contain references to captured text from the
1476     *                        input.
1477     *   @param   status      A reference to a UErrorCode to receive any errors.  Possible
1478     *                        errors are  U_REGEX_INVALID_STATE if no match has been
1479     *                        attempted or the last match failed, and U_INDEX_OUTOFBOUNDS_ERROR
1480     *                        if the replacement text specifies a capture group that
1481     *                        does not exist in the pattern.
1482     *
1483     *   @return  this  RegexMatcher
1484     *   @stable ICU 2.4
1485     *
1486     */
1487     virtual RegexMatcher &amp;appendReplacement(UnicodeString &amp;dest,
1488         const UnicodeString &amp;replacement, UErrorCode &amp;status);
1489 
1490 
1491    /**
1492     *   Implements a replace operation intended to be used as part of an
1493     *   incremental find-and-replace.
1494     *
<span class="line-modified">1495     *   &lt;p&gt;The input string, starting from the end of the previous replacement and ending at</span>
1496     *   the start of the current match, is appended to the destination string.  Then the
1497     *   replacement string is appended to the output string,
<span class="line-modified">1498     *   including handling any substitutions of captured text.&lt;/p&gt;</span>
1499     *
<span class="line-modified">1500     *   &lt;p&gt;For simple, prepackaged, non-incremental find-and-replace</span>
<span class="line-modified">1501     *   operations, see replaceFirst() or replaceAll().&lt;/p&gt;</span>
1502     *
1503     *   @param   dest        A mutable UText to which the results of the find-and-replace are appended.
1504     *                         Must not be NULL.
1505     *   @param   replacement A UText that provides the text to be substituted for
1506     *                        the input text that matched the regexp pattern.  The replacement
1507     *                        text may contain references to captured text from the input.
1508     *   @param   status      A reference to a UErrorCode to receive any errors.  Possible
1509     *                        errors are  U_REGEX_INVALID_STATE if no match has been
1510     *                        attempted or the last match failed, and U_INDEX_OUTOFBOUNDS_ERROR
1511     *                        if the replacement text specifies a capture group that
1512     *                        does not exist in the pattern.
1513     *
1514     *   @return  this  RegexMatcher
1515     *
1516     *   @stable ICU 4.6
1517     */
1518     virtual RegexMatcher &amp;appendReplacement(UText *dest,
1519         UText *replacement, UErrorCode &amp;status);
1520 
1521 
1522    /**
1523     * As the final step in a find-and-replace operation, append the remainder
1524     * of the input string, starting at the position following the last appendReplacement(),
<span class="line-modified">1525     * to the destination string. &lt;code&gt;appendTail()&lt;/code&gt; is intended to be invoked after one</span>
<span class="line-modified">1526     * or more invocations of the &lt;code&gt;RegexMatcher::appendReplacement()&lt;/code&gt;.</span>
1527     *
1528     *  @param dest A UnicodeString to which the results of the find-and-replace are appended.
1529     *  @return  the destination string.
1530     *  @stable ICU 2.4
1531     */
1532     virtual UnicodeString &amp;appendTail(UnicodeString &amp;dest);
1533 
1534 
1535    /**
1536     * As the final step in a find-and-replace operation, append the remainder
1537     * of the input string, starting at the position following the last appendReplacement(),
<span class="line-modified">1538     * to the destination string. &lt;code&gt;appendTail()&lt;/code&gt; is intended to be invoked after one</span>
<span class="line-modified">1539     * or more invocations of the &lt;code&gt;RegexMatcher::appendReplacement()&lt;/code&gt;.</span>
1540     *
1541     *  @param dest A mutable UText to which the results of the find-and-replace are appended.
1542     *               Must not be NULL.
1543     *  @param status error cod
1544     *  @return  the destination string.
1545     *
1546     *  @stable ICU 4.6
1547     */
1548     virtual UText *appendTail(UText *dest, UErrorCode &amp;status);
1549 
1550 
1551     /**
<span class="line-modified">1552      * Split a string into fields.  Somewhat like split() from Perl.</span>
1553      * The pattern matches identify delimiters that separate the input
1554      *  into fields.  The input data between the matches becomes the
1555      *  fields themselves.
1556      *
1557      * @param input   The string to be split into fields.  The field delimiters
1558      *                match the pattern (in the &quot;this&quot; object).  This matcher
1559      *                will be reset to this input string.
1560      * @param dest    An array of UnicodeStrings to receive the results of the split.
1561      *                This is an array of actual UnicodeString objects, not an
1562      *                array of pointers to strings.  Local (stack based) arrays can
1563      *                work well here.
1564      * @param destCapacity  The number of elements in the destination array.
1565      *                If the number of fields found is less than destCapacity, the
1566      *                extra strings in the destination array are not altered.
1567      *                If the number of destination strings is less than the number
1568      *                of fields, the trailing part of the input string, including any
1569      *                field delimiters, is placed in the last destination string.
1570      * @param status  A reference to a UErrorCode to receive any errors.
1571      * @return        The number of fields into which the input string was split.
1572      * @stable ICU 2.6
1573      */
1574     virtual int32_t  split(const UnicodeString &amp;input,
1575         UnicodeString    dest[],
1576         int32_t          destCapacity,
1577         UErrorCode       &amp;status);
1578 
1579 
1580     /**
<span class="line-modified">1581      * Split a string into fields.  Somewhat like split() from Perl.</span>
1582      * The pattern matches identify delimiters that separate the input
1583      *  into fields.  The input data between the matches becomes the
1584      *  fields themselves.
1585      *
1586      * @param input   The string to be split into fields.  The field delimiters
1587      *                match the pattern (in the &quot;this&quot; object).  This matcher
1588      *                will be reset to this input string.
1589      * @param dest    An array of mutable UText structs to receive the results of the split.
1590      *                If a field is NULL, a new UText is allocated to contain the results for
1591      *                that field. This new UText is not guaranteed to be mutable.
1592      * @param destCapacity  The number of elements in the destination array.
1593      *                If the number of fields found is less than destCapacity, the
1594      *                extra strings in the destination array are not altered.
1595      *                If the number of destination strings is less than the number
1596      *                of fields, the trailing part of the input string, including any
1597      *                field delimiters, is placed in the last destination string.
1598      * @param status  A reference to a UErrorCode to receive any errors.
1599      * @return        The number of fields into which the input string was split.
1600      *
1601      * @stable ICU 4.6
1602      */
1603     virtual int32_t  split(UText *input,
1604         UText           *dest[],
1605         int32_t          destCapacity,
1606         UErrorCode       &amp;status);
1607 
1608   /**
1609     *   Set a processing time limit for match operations with this Matcher.
1610     *
1611     *   Some patterns, when matching certain strings, can run in exponential time.
1612     *   For practical purposes, the match operation may appear to be in an
1613     *   infinite loop.
1614     *   When a limit is set a match operation will fail with an error if the
1615     *   limit is exceeded.
<span class="line-modified">1616     *   &lt;p&gt;</span>
1617     *   The units of the limit are steps of the match engine.
1618     *   Correspondence with actual processor time will depend on the speed
1619     *   of the processor and the details of the specific pattern, but will
1620     *   typically be on the order of milliseconds.
<span class="line-modified">1621     *   &lt;p&gt;</span>
1622     *   By default, the matching time is not limited.
<span class="line-modified">1623     *   &lt;p&gt;</span>
1624     *
1625     *   @param   limit       The limit value, or 0 for no limit.
1626     *   @param   status      A reference to a UErrorCode to receive any errors.
1627     *   @stable ICU 4.0
1628     */
1629     virtual void setTimeLimit(int32_t limit, UErrorCode &amp;status);
1630 
1631   /**
1632     * Get the time limit, if any, for match operations made with this Matcher.
1633     *
1634     *   @return the maximum allowed time for a match, in units of processing steps.
1635     *   @stable ICU 4.0
1636     */
1637     virtual int32_t getTimeLimit() const;
1638 
1639   /**
1640     *  Set the amount of heap storage available for use by the match backtracking stack.
1641     *  The matcher is also reset, discarding any results from previous matches.
<span class="line-modified">1642     *  &lt;p&gt;</span>
1643     *  ICU uses a backtracking regular expression engine, with the backtrack stack
1644     *  maintained on the heap.  This function sets the limit to the amount of memory
<span class="line-modified">1645     *  that can be used  for this purpose.  A backtracking stack overflow will</span>
1646     *  result in an error from the match operation that caused it.
<span class="line-modified">1647     *  &lt;p&gt;</span>
1648     *  A limit is desirable because a malicious or poorly designed pattern can use
1649     *  excessive memory, potentially crashing the process.  A limit is enabled
1650     *  by default.
<span class="line-modified">1651     *  &lt;p&gt;</span>
1652     *  @param limit  The maximum size, in bytes, of the matching backtrack stack.
1653     *                A value of zero means no limit.
1654     *                The limit must be greater or equal to zero.
1655     *
1656     *  @param status   A reference to a UErrorCode to receive any errors.
1657     *
1658     *  @stable ICU 4.0
1659     */
1660     virtual void setStackLimit(int32_t  limit, UErrorCode &amp;status);
1661 
1662   /**
1663     *  Get the size of the heap storage available for use by the back tracking stack.
1664     *
1665     *  @return  the maximum backtracking stack size, in bytes, or zero if the
1666     *           stack size is unlimited.
1667     *  @stable ICU 4.0
1668     */
1669     virtual int32_t  getStackLimit() const;
1670 
1671 
</pre>
</td>
<td>
<hr />
<pre>
   7 **********************************************************************
   8 *   file name:  regex.h
   9 *   encoding:   UTF-8
  10 *   indentation:4
  11 *
  12 *   created on: 2002oct22
  13 *   created by: Andy Heninger
  14 *
  15 *   ICU Regular Expressions, API for C++
  16 */
  17 
  18 #ifndef REGEX_H
  19 #define REGEX_H
  20 
  21 //#define REGEX_DEBUG
  22 
  23 /**
  24  * \file
  25  * \brief  C++ API:  Regular Expressions
  26  *
<span class="line-modified">  27  * The ICU API for processing regular expressions consists of two classes,</span>
<span class="line-modified">  28  *  `RegexPattern` and `RegexMatcher`.</span>
<span class="line-modified">  29  *  `RegexPattern` objects represent a pre-processed, or compiled</span>


  30  *  regular expression.  They are created from a regular expression pattern string,
<span class="line-modified">  31  *  and can be used to create `RegexMatcher` objects for the pattern.</span>
  32  *
<span class="line-modified">  33  * Class `RegexMatcher` bundles together a regular expression</span>
  34  *  pattern and a target string to which the search pattern will be applied.
<span class="line-modified">  35  *  `RegexMatcher` includes API for doing plain find or search</span>
  36  *  operations, for search and replace operations, and for obtaining detailed
<span class="line-modified">  37  *  information about bounds of a match.</span>
  38  *
<span class="line-modified">  39  * Note that by constructing `RegexMatcher` objects directly from regular</span>
  40  * expression pattern strings application code can be simplified and the explicit
<span class="line-modified">  41  * need for `RegexPattern` objects can usually be eliminated.</span>
<span class="line-modified">  42  *</span>
  43  */
  44 
  45 #include &quot;unicode/utypes.h&quot;
  46 
  47 #if !UCONFIG_NO_REGULAR_EXPRESSIONS
  48 
  49 #include &quot;unicode/uobject.h&quot;
  50 #include &quot;unicode/unistr.h&quot;
  51 #include &quot;unicode/utext.h&quot;
  52 #include &quot;unicode/parseerr.h&quot;
  53 
  54 #include &quot;unicode/uregex.h&quot;
  55 
  56 // Forward Declarations
  57 
  58 struct UHashtable;
  59 
  60 U_NAMESPACE_BEGIN
  61 
  62 struct Regex8BitSet;
  63 class  RegexCImpl;
  64 class  RegexMatcher;
  65 class  RegexPattern;
  66 struct REStackFrame;
  67 class  RuleBasedBreakIterator;
  68 class  UnicodeSet;
  69 class  UVector;
  70 class  UVector32;
  71 class  UVector64;
  72 
  73 
  74 /**
<span class="line-modified">  75   * Class `RegexPattern` represents a compiled regular expression.  It includes</span>
  76   * factory methods for creating a RegexPattern object from the source (string) form
  77   * of a regular expression, methods for creating RegexMatchers that allow the pattern
  78   * to be applied to input text, and a few convenience methods for simple common
  79   * uses of regular expressions.
  80   *
<span class="line-modified">  81   * Class RegexPattern is not intended to be subclassed.</span>
  82   *
  83   * @stable ICU 2.4
  84   */
  85 class U_I18N_API RegexPattern U_FINAL : public UObject {
  86 public:
  87 
  88     /**
  89      * default constructor.  Create a RegexPattern object that refers to no actual
  90      *   pattern.  Not normally needed; RegexPattern objects are usually
<span class="line-modified">  91      *   created using the factory method `compile()`.</span>
  92      *
  93      * @stable ICU 2.4
  94      */
  95     RegexPattern();
  96 
  97     /**
  98      * Copy Constructor.  Create a new RegexPattern object that is equivalent
  99      *                    to the source object.
 100      * @param source the pattern object to be copied.
 101      * @stable ICU 2.4
 102      */
 103     RegexPattern(const RegexPattern &amp;source);
 104 
 105     /**
 106      * Destructor.  Note that a RegexPattern object must persist so long as any
 107      *  RegexMatcher objects that were created from the RegexPattern are active.
 108      * @stable ICU 2.4
 109      */
 110     virtual ~RegexPattern();
 111 
 112     /**
 113      * Comparison operator.  Two RegexPattern objects are considered equal if they
<span class="line-modified"> 114      * were constructed from identical source patterns using the same #URegexpFlag</span>
 115      * settings.
 116      * @param that a RegexPattern object to compare with &quot;this&quot;.
 117      * @return TRUE if the objects are equivalent.
 118      * @stable ICU 2.4
 119      */
 120     UBool           operator==(const RegexPattern&amp; that) const;
 121 
 122     /**
 123      * Comparison operator.  Two RegexPattern objects are considered equal if they
<span class="line-modified"> 124      * were constructed from identical source patterns using the same #URegexpFlag</span>
 125      * settings.
 126      * @param that a RegexPattern object to compare with &quot;this&quot;.
 127      * @return TRUE if the objects are different.
 128      * @stable ICU 2.4
 129      */
 130     inline UBool    operator!=(const RegexPattern&amp; that) const {return ! operator ==(that);}
 131 
 132     /**
 133      * Assignment operator.  After assignment, this RegexPattern will behave identically
 134      *     to the source object.
 135      * @stable ICU 2.4
 136      */
 137     RegexPattern  &amp;operator =(const RegexPattern &amp;source);
 138 
 139     /**
 140      * Create an exact copy of this RegexPattern object.  Since RegexPattern is not
 141      * intended to be subclassed, &lt;code&gt;clone()&lt;/code&gt; and the copy construction are
 142      * equivalent operations.
 143      * @return the copy of this RegexPattern
 144      * @stable ICU 2.4
 145      */
 146     virtual RegexPattern  *clone() const;
 147 
 148 
 149    /**
 150     * Compiles the regular expression in string form into a RegexPattern
 151     * object.  These compile methods, rather than the constructors, are the usual
 152     * way that RegexPattern objects are created.
 153     *
<span class="line-modified"> 154     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 155     * objects created from the pattern are active.  RegexMatchers keep a pointer
 156     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 157     * catastrophic error.</span>
 158     *
<span class="line-modified"> 159     * All #URegexpFlag pattern match mode flags are set to their default values.</span>
 160     *
<span class="line-modified"> 161     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 162     *    from a pattern string rather than separately compiling the pattern and
<span class="line-modified"> 163     *    then creating a RegexMatcher object from the pattern.</span>
 164     *
 165     * @param regex The regular expression to be compiled.
 166     * @param pe    Receives the position (line and column nubers) of any error
 167     *              within the regular expression.)
 168     * @param status A reference to a UErrorCode to receive any errors.
 169     * @return      A regexPattern object for the compiled pattern.
 170     *
 171     * @stable ICU 2.4
 172     */
 173     static RegexPattern * U_EXPORT2 compile( const UnicodeString &amp;regex,
 174         UParseError          &amp;pe,
 175         UErrorCode           &amp;status);
 176 
 177    /**
 178     * Compiles the regular expression in string form into a RegexPattern
 179     * object.  These compile methods, rather than the constructors, are the usual
 180     * way that RegexPattern objects are created.
 181     *
<span class="line-modified"> 182     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 183     * objects created from the pattern are active.  RegexMatchers keep a pointer
 184     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 185     * catastrophic error.</span>
 186     *
<span class="line-modified"> 187     * All #URegexpFlag pattern match mode flags are set to their default values.</span>
 188     *
<span class="line-modified"> 189     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 190     *    from a pattern string rather than separately compiling the pattern and
<span class="line-modified"> 191     *    then creating a RegexMatcher object from the pattern.</span>
 192     *
 193     * @param regex The regular expression to be compiled. Note, the text referred
 194     *              to by this UText must not be deleted during the lifetime of the
 195     *              RegexPattern object or any RegexMatcher object created from it.
 196     * @param pe    Receives the position (line and column nubers) of any error
 197     *              within the regular expression.)
 198     * @param status A reference to a UErrorCode to receive any errors.
 199     * @return      A regexPattern object for the compiled pattern.
 200     *
 201     * @stable ICU 4.6
 202     */
 203     static RegexPattern * U_EXPORT2 compile( UText *regex,
 204         UParseError          &amp;pe,
 205         UErrorCode           &amp;status);
 206 
 207    /**
 208     * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified"> 209     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
 210     * rather than the constructors, are the usual way that RegexPattern objects
 211     * are created.
 212     *
<span class="line-modified"> 213     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 214     * objects created from the pattern are active.  RegexMatchers keep a pointer
 215     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 216     * catastrophic error.</span>
 217     *
<span class="line-modified"> 218     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 219     *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified"> 220     *    then creating a RegexMatcher object from the pattern.</span>
 221     *
 222     * @param regex The regular expression to be compiled.
<span class="line-modified"> 223     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
 224     * @param pe    Receives the position (line and column numbers) of any error
 225     *              within the regular expression.)
 226     * @param status   A reference to a UErrorCode to receive any errors.
 227     * @return      A regexPattern object for the compiled pattern.
 228     *
 229     * @stable ICU 2.4
 230     */
 231     static RegexPattern * U_EXPORT2 compile( const UnicodeString &amp;regex,
 232         uint32_t             flags,
 233         UParseError          &amp;pe,
 234         UErrorCode           &amp;status);
 235 
 236    /**
 237     * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified"> 238     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
 239     * rather than the constructors, are the usual way that RegexPattern objects
 240     * are created.
 241     *
<span class="line-modified"> 242     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 243     * objects created from the pattern are active.  RegexMatchers keep a pointer
 244     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 245     * catastrophic error.</span>
 246     *
<span class="line-modified"> 247     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 248     *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified"> 249     *    then creating a RegexMatcher object from the pattern.</span>
 250     *
 251     * @param regex The regular expression to be compiled. Note, the text referred
 252     *              to by this UText must not be deleted during the lifetime of the
 253     *              RegexPattern object or any RegexMatcher object created from it.
<span class="line-modified"> 254     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
 255     * @param pe    Receives the position (line and column numbers) of any error
 256     *              within the regular expression.)
 257     * @param status   A reference to a UErrorCode to receive any errors.
 258     * @return      A regexPattern object for the compiled pattern.
 259     *
 260     * @stable ICU 4.6
 261     */
 262     static RegexPattern * U_EXPORT2 compile( UText *regex,
 263         uint32_t             flags,
 264         UParseError          &amp;pe,
 265         UErrorCode           &amp;status);
 266 
 267    /**
 268     * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified"> 269     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
 270     * rather than the constructors, are the usual way that RegexPattern objects
 271     * are created.
 272     *
<span class="line-modified"> 273     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 274     * objects created from the pattern are active.  RegexMatchers keep a pointer
 275     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 276     * catastrophic error.</span>
 277     *
<span class="line-modified"> 278     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 279     *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified"> 280     *    then creating a RegexMatcher object from the pattern.</span>
 281     *
 282     * @param regex The regular expression to be compiled.
<span class="line-modified"> 283     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
 284     * @param status   A reference to a UErrorCode to receive any errors.
 285     * @return      A regexPattern object for the compiled pattern.
 286     *
 287     * @stable ICU 2.6
 288     */
 289     static RegexPattern * U_EXPORT2 compile( const UnicodeString &amp;regex,
 290         uint32_t             flags,
 291         UErrorCode           &amp;status);
 292 
 293    /**
 294     * Compiles the regular expression in string form into a RegexPattern
<span class="line-modified"> 295     * object using the specified #URegexpFlag match mode flags.  These compile methods,</span>
 296     * rather than the constructors, are the usual way that RegexPattern objects
 297     * are created.
 298     *
<span class="line-modified"> 299     * Note that RegexPattern objects must not be deleted while RegexMatcher</span>
 300     * objects created from the pattern are active.  RegexMatchers keep a pointer
 301     * back to their pattern, so premature deletion of the pattern is a
<span class="line-modified"> 302     * catastrophic error.</span>
 303     *
<span class="line-modified"> 304     * Note that it is often more convenient to construct a RegexMatcher directly</span>
 305     *    from a pattern string instead of than separately compiling the pattern and
<span class="line-modified"> 306     *    then creating a RegexMatcher object from the pattern.</span>
 307     *
 308     * @param regex The regular expression to be compiled. Note, the text referred
 309     *              to by this UText must not be deleted during the lifetime of the
 310     *              RegexPattern object or any RegexMatcher object created from it.
<span class="line-modified"> 311     * @param flags The #URegexpFlag match mode flags to be used, e.g. #UREGEX_CASE_INSENSITIVE.</span>
 312     * @param status   A reference to a UErrorCode to receive any errors.
 313     * @return      A regexPattern object for the compiled pattern.
 314     *
 315     * @stable ICU 4.6
 316     */
 317     static RegexPattern * U_EXPORT2 compile( UText *regex,
 318         uint32_t             flags,
 319         UErrorCode           &amp;status);
 320 
 321    /**
<span class="line-modified"> 322     * Get the #URegexpFlag match mode flags that were used when compiling this pattern.</span>
<span class="line-modified"> 323     * @return  the #URegexpFlag match mode flags</span>
 324     * @stable ICU 2.4
 325     */
 326     virtual uint32_t flags() const;
 327 
 328    /**
 329     * Creates a RegexMatcher that will match the given input against this pattern.  The
 330     * RegexMatcher can then be used to perform match, find or replace operations
 331     * on the input.  Note that a RegexPattern object must not be deleted while
 332     * RegexMatchers created from it still exist and might possibly be used again.
<span class="line-modified"> 333     *</span>
 334     * The matcher will retain a reference to the supplied input string, and all regexp
 335     * pattern matching operations happen directly on this original string.  It is
 336     * critical that the string not be altered or deleted before use by the regular
 337     * expression operations is complete.
 338     *
 339     * @param input    The input string to which the regular expression will be applied.
 340     * @param status   A reference to a UErrorCode to receive any errors.
 341     * @return         A RegexMatcher object for this pattern and input.
 342     *
 343     * @stable ICU 2.4
 344     */
 345     virtual RegexMatcher *matcher(const UnicodeString &amp;input,
 346         UErrorCode          &amp;status) const;
 347 
 348 private:
 349     /**
 350      * Cause a compilation error if an application accidentally attempts to
 351      *   create a matcher with a (char16_t *) string as input rather than
 352      *   a UnicodeString.  Avoids a dangling reference to a temporary string.
<span class="line-modified"> 353      *</span>
 354      * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
 355      * using one of the aliasing constructors, such as
<span class="line-modified"> 356      * `UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);`</span>
 357      * or in a UText, using
<span class="line-modified"> 358      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`</span>
 359      *
 360      */
 361     RegexMatcher *matcher(const char16_t *input,
 362         UErrorCode          &amp;status) const;
 363 public:
 364 
 365 
 366    /**
 367     * Creates a RegexMatcher that will match against this pattern.  The
 368     * RegexMatcher can be used to perform match, find or replace operations.
 369     * Note that a RegexPattern object must not be deleted while
 370     * RegexMatchers created from it still exist and might possibly be used again.
 371     *
 372     * @param status   A reference to a UErrorCode to receive any errors.
 373     * @return      A RegexMatcher object for this pattern and input.
 374     *
 375     * @stable ICU 2.6
 376     */
 377     virtual RegexMatcher *matcher(UErrorCode  &amp;status) const;
 378 
</pre>
<hr />
<pre>
 502      *                This is an array of actual UnicodeString objects, not an
 503      *                array of pointers to strings.  Local (stack based) arrays can
 504      *                work well here.
 505      * @param destCapacity  The number of elements in the destination array.
 506      *                If the number of fields found is less than destCapacity, the
 507      *                extra strings in the destination array are not altered.
 508      *                If the number of destination strings is less than the number
 509      *                of fields, the trailing part of the input string, including any
 510      *                field delimiters, is placed in the last destination string.
 511      * @param status  A reference to a UErrorCode to receive any errors.
 512      * @return        The number of fields into which the input string was split.
 513      * @stable ICU 2.4
 514      */
 515     virtual int32_t  split(const UnicodeString &amp;input,
 516         UnicodeString    dest[],
 517         int32_t          destCapacity,
 518         UErrorCode       &amp;status) const;
 519 
 520 
 521     /**
<span class="line-modified"> 522      * Split a string into fields.  Somewhat like %split() from Perl or Java.</span>
 523      * Pattern matches identify delimiters that separate the input
 524      * into fields.  The input data between the delimiters becomes the
 525      * fields themselves.
 526      *
 527      * If the delimiter pattern includes capture groups, the captured text will
 528      * also appear in the destination array of output strings, interspersed
 529      * with the fields.  This is similar to Perl, but differs from Java,
 530      * which ignores the presence of capture groups in the pattern.
 531      *
 532      * Trailing empty fields will always be returned, assuming sufficient
 533      * destination capacity.  This differs from the default behavior for Java
 534      * and Perl where trailing empty fields are not returned.
 535      *
 536      * The number of strings produced by the split operation is returned.
 537      * This count includes the strings from capture groups in the delimiter pattern.
 538      * This behavior differs from Java, which ignores capture groups.
 539      *
 540      *  For the best performance on split() operations,
<span class="line-modified"> 541      *  `RegexMatcher::split()` is preferable to this function</span>
 542      *
 543      * @param input   The string to be split into fields.  The field delimiters
 544      *                match the pattern (in the &quot;this&quot; object)
 545      * @param dest    An array of mutable UText structs to receive the results of the split.
 546      *                If a field is NULL, a new UText is allocated to contain the results for
 547      *                that field. This new UText is not guaranteed to be mutable.
 548      * @param destCapacity  The number of elements in the destination array.
 549      *                If the number of fields found is less than destCapacity, the
 550      *                extra strings in the destination array are not altered.
 551      *                If the number of destination strings is less than the number
 552      *                of fields, the trailing part of the input string, including any
 553      *                field delimiters, is placed in the last destination string.
 554      * @param status  A reference to a UErrorCode to receive any errors.
 555      * @return        The number of destination strings used.
 556      *
 557      * @stable ICU 4.6
 558      */
 559     virtual int32_t  split(UText *input,
 560         UText            *dest[],
 561         int32_t          destCapacity,
</pre>
<hr />
<pre>
 654  *  class RegexMatcher bundles together a regular expression pattern and
 655  *  input text to which the expression can be applied.  It includes methods
 656  *  for testing for matches, and for find and replace operations.
 657  *
 658  * &lt;p&gt;Class RegexMatcher is not intended to be subclassed.&lt;/p&gt;
 659  *
 660  * @stable ICU 2.4
 661  */
 662 class U_I18N_API RegexMatcher U_FINAL : public UObject {
 663 public:
 664 
 665     /**
 666       * Construct a RegexMatcher for a regular expression.
 667       * This is a convenience method that avoids the need to explicitly create
 668       * a RegexPattern object.  Note that if several RegexMatchers need to be
 669       * created for the same expression, it will be more efficient to
 670       * separately create and cache a RegexPattern object, and use
 671       * its matcher() method to create the RegexMatcher objects.
 672       *
 673       *  @param regexp The Regular Expression to be compiled.
<span class="line-modified"> 674       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>

 675       *  @param status Any errors are reported by setting this UErrorCode variable.
 676       *  @stable ICU 2.6
 677       */
 678     RegexMatcher(const UnicodeString &amp;regexp, uint32_t flags, UErrorCode &amp;status);
 679 
 680     /**
 681       * Construct a RegexMatcher for a regular expression.
 682       * This is a convenience method that avoids the need to explicitly create
 683       * a RegexPattern object.  Note that if several RegexMatchers need to be
 684       * created for the same expression, it will be more efficient to
 685       * separately create and cache a RegexPattern object, and use
 686       * its matcher() method to create the RegexMatcher objects.
 687       *
 688       *  @param regexp The regular expression to be compiled.
<span class="line-modified"> 689       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>

 690       *  @param status Any errors are reported by setting this UErrorCode variable.
 691       *
 692       *  @stable ICU 4.6
 693       */
 694     RegexMatcher(UText *regexp, uint32_t flags, UErrorCode &amp;status);
 695 
 696     /**
 697       * Construct a RegexMatcher for a regular expression.
 698       * This is a convenience method that avoids the need to explicitly create
 699       * a RegexPattern object.  Note that if several RegexMatchers need to be
 700       * created for the same expression, it will be more efficient to
 701       * separately create and cache a RegexPattern object, and use
 702       * its matcher() method to create the RegexMatcher objects.
<span class="line-modified"> 703       *</span>
 704       * The matcher will retain a reference to the supplied input string, and all regexp
 705       * pattern matching operations happen directly on the original string.  It is
 706       * critical that the string not be altered or deleted before use by the regular
 707       * expression operations is complete.
 708       *
 709       *  @param regexp The Regular Expression to be compiled.
 710       *  @param input  The string to match.  The matcher retains a reference to the
 711       *                caller&#39;s string; mo copy is made.
<span class="line-modified"> 712       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>

 713       *  @param status Any errors are reported by setting this UErrorCode variable.
 714       *  @stable ICU 2.6
 715       */
 716     RegexMatcher(const UnicodeString &amp;regexp, const UnicodeString &amp;input,
 717         uint32_t flags, UErrorCode &amp;status);
 718 
 719     /**
 720       * Construct a RegexMatcher for a regular expression.
 721       * This is a convenience method that avoids the need to explicitly create
 722       * a RegexPattern object.  Note that if several RegexMatchers need to be
 723       * created for the same expression, it will be more efficient to
 724       * separately create and cache a RegexPattern object, and use
 725       * its matcher() method to create the RegexMatcher objects.
<span class="line-modified"> 726       *</span>
 727       * The matcher will make a shallow clone of the supplied input text, and all regexp
 728       * pattern matching operations happen on this clone.  While read-only operations on
 729       * the supplied text are permitted, it is critical that the underlying string not be
 730       * altered or deleted before use by the regular expression operations is complete.
 731       *
 732       *  @param regexp The Regular Expression to be compiled.
 733       *  @param input  The string to match.  The matcher retains a shallow clone of the text.
<span class="line-modified"> 734       *  @param flags  #URegexpFlag options, such as #UREGEX_CASE_INSENSITIVE.</span>

 735       *  @param status Any errors are reported by setting this UErrorCode variable.
 736       *
 737       *  @stable ICU 4.6
 738       */
 739     RegexMatcher(UText *regexp, UText *input,
 740         uint32_t flags, UErrorCode &amp;status);
 741 
 742 private:
 743     /**
 744      * Cause a compilation error if an application accidentally attempts to
 745      *   create a matcher with a (char16_t *) string as input rather than
 746      *   a UnicodeString.    Avoids a dangling reference to a temporary string.
<span class="line-modified"> 747      *</span>
 748      * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
 749      * using one of the aliasing constructors, such as
<span class="line-modified"> 750      * `UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);`</span>
 751      * or in a UText, using
<span class="line-modified"> 752      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`</span>

 753      */
 754     RegexMatcher(const UnicodeString &amp;regexp, const char16_t *input,
 755         uint32_t flags, UErrorCode &amp;status);
 756 public:
 757 
 758 
 759    /**
 760     *   Destructor.
 761     *
 762     *  @stable ICU 2.4
 763     */
 764     virtual ~RegexMatcher();
 765 
 766 
 767    /**
 768     *   Attempts to match the entire input region against the pattern.
 769     *    @param   status     A reference to a UErrorCode to receive any errors.
 770     *    @return TRUE if there is a match
 771     *    @stable ICU 2.4
 772     */
</pre>
<hr />
<pre>
 775 
 776    /**
 777     *   Resets the matcher, then attempts to match the input beginning
 778     *   at the specified startIndex, and extending to the end of the input.
 779     *   The input region is reset to include the entire input string.
 780     *   A successful match must extend to the end of the input.
 781     *    @param   startIndex The input string (native) index at which to begin matching.
 782     *    @param   status     A reference to a UErrorCode to receive any errors.
 783     *    @return TRUE if there is a match
 784     *    @stable ICU 2.8
 785     */
 786     virtual UBool matches(int64_t startIndex, UErrorCode &amp;status);
 787 
 788 
 789    /**
 790     *   Attempts to match the input string, starting from the beginning of the region,
 791     *   against the pattern.  Like the matches() method, this function
 792     *   always starts at the beginning of the input region;
 793     *   unlike that function, it does not require that the entire region be matched.
 794     *
<span class="line-modified"> 795     *   If the match succeeds then more information can be obtained via the start(),</span>
<span class="line-modified"> 796     *   end(), and group() functions.</span>
 797     *
 798     *    @param   status     A reference to a UErrorCode to receive any errors.
 799     *    @return  TRUE if there is a match at the start of the input string.
 800     *    @stable ICU 2.4
 801     */
 802     virtual UBool lookingAt(UErrorCode &amp;status);
 803 
 804 
 805   /**
 806     *   Attempts to match the input string, starting from the specified index, against the pattern.
 807     *   The match may be of any length, and is not required to extend to the end
 808     *   of the input string.  Contrast with match().
 809     *
<span class="line-modified"> 810     *   If the match succeeds then more information can be obtained via the start(),</span>
<span class="line-modified"> 811     *   end(), and group() functions.</span>
 812     *
 813     *    @param   startIndex The input string (native) index at which to begin matching.
 814     *    @param   status     A reference to a UErrorCode to receive any errors.
 815     *    @return  TRUE if there is a match.
 816     *    @stable ICU 2.8
 817     */
 818     virtual UBool lookingAt(int64_t startIndex, UErrorCode &amp;status);
 819 
 820 
 821    /**
 822     *  Find the next pattern match in the input string.
 823     *  The find begins searching the input at the location following the end of
 824     *  the previous match, or at the start of the string if there is no previous match.
<span class="line-modified"> 825     *  If a match is found, `start()`, `end()` and `group()`</span>
 826     *  will provide more information regarding the match.
<span class="line-modified"> 827     *  Note that if the input string is changed by the application,</span>
 828     *     use find(startPos, status) instead of find(), because the saved starting
<span class="line-modified"> 829     *     position may not be valid with the altered input string.</span>
 830     *  @return  TRUE if a match is found.
 831     *  @stable ICU 2.4
 832     */
 833     virtual UBool find();
 834 
 835 
 836    /**
 837     *  Find the next pattern match in the input string.
 838     *  The find begins searching the input at the location following the end of
 839     *  the previous match, or at the start of the string if there is no previous match.
<span class="line-modified"> 840     *  If a match is found, `start()`, `end()` and `group()`</span>
 841     *  will provide more information regarding the match.
<span class="line-modified"> 842     *</span>
<span class="line-modified"> 843     *  Note that if the input string is changed by the application,</span>
<span class="line-modified"> 844     *  use find(startPos, status) instead of find(), because the saved starting</span>
<span class="line-added"> 845     *  position may not be valid with the altered input string.</span>
 846     *  @param   status  A reference to a UErrorCode to receive any errors.
 847     *  @return  TRUE if a match is found.
 848     * @stable ICU 55
 849     */
 850     virtual UBool find(UErrorCode &amp;status);
 851 
 852    /**
 853     *   Resets this RegexMatcher and then attempts to find the next substring of the
 854     *   input string that matches the pattern, starting at the specified index.
 855     *
 856     *   @param   start     The (native) index in the input string to begin the search.
 857     *   @param   status    A reference to a UErrorCode to receive any errors.
 858     *   @return  TRUE if a match is found.
 859     *   @stable ICU 2.4
 860     */
 861     virtual UBool find(int64_t start, UErrorCode &amp;status);
 862 
 863 
 864    /**
 865     *   Returns a string containing the text matched by the previous match.
</pre>
<hr />
<pre>
1055     *   @stable ICU 4.6
1056     */
1057     virtual int64_t end64(int32_t group, UErrorCode &amp;status) const;
1058 
1059    /**
1060     *   Resets this matcher.  The effect is to remove any memory of previous matches,
1061     *       and to cause subsequent find() operations to begin at the beginning of
1062     *       the input string.
1063     *
1064     *   @return this RegexMatcher.
1065     *   @stable ICU 2.4
1066     */
1067     virtual RegexMatcher &amp;reset();
1068 
1069 
1070    /**
1071     *   Resets this matcher, and set the current input position.
1072     *   The effect is to remove any memory of previous matches,
1073     *       and to cause subsequent find() operations to begin at
1074     *       the specified (native) position in the input string.
<span class="line-modified">1075     *</span>
1076     *   The matcher&#39;s region is reset to its default, which is the entire
1077     *   input string.
<span class="line-modified">1078     *</span>
1079     *   An alternative to this function is to set a match region
1080     *   beginning at the desired index.
1081     *
1082     *   @return this RegexMatcher.
1083     *   @stable ICU 2.8
1084     */
1085     virtual RegexMatcher &amp;reset(int64_t index, UErrorCode &amp;status);
1086 
1087 
1088    /**
1089     *   Resets this matcher with a new input string.  This allows instances of RegexMatcher
1090     *     to be reused, which is more efficient than creating a new RegexMatcher for
1091     *     each input string to be processed.
1092     *   @param input The new string on which subsequent pattern matches will operate.
1093     *                The matcher retains a reference to the callers string, and operates
1094     *                directly on that.  Ownership of the string remains with the caller.
1095     *                Because no copy of the string is made, it is essential that the
1096     *                caller not delete the string until after regexp operations on it
1097     *                are done.
1098     *                Note that while a reset on the matcher with an input string that is then
</pre>
<hr />
<pre>
1135     *  of a string being matched, but always operates directly on the original text
1136     *  provided by the user. Refreshing simply drops the references to the old text
1137     *  and replaces them with references to the new.
1138     *
1139     *  Caution:  this function is normally used only by very specialized,
1140     *  system-level code.  One example use case is with garbage collection that moves
1141     *  the text in memory.
1142     *
1143     * @param input      The new (moved) text string.
1144     * @param status     Receives errors detected by this function.
1145     *
1146     * @stable ICU 4.8
1147     */
1148     virtual RegexMatcher &amp;refreshInputText(UText *input, UErrorCode &amp;status);
1149 
1150 private:
1151     /**
1152      * Cause a compilation error if an application accidentally attempts to
1153      *   reset a matcher with a (char16_t *) string as input rather than
1154      *   a UnicodeString.    Avoids a dangling reference to a temporary string.
<span class="line-modified">1155      *</span>
1156      * To efficiently work with char16_t *strings, wrap the data in a UnicodeString
1157      * using one of the aliasing constructors, such as
<span class="line-modified">1158      * `UnicodeString(UBool isTerminated, const char16_t *text, int32_t textLength);`</span>
1159      * or in a UText, using
<span class="line-modified">1160      * `utext_openUChars(UText *ut, const char16_t *text, int64_t textLength, UErrorCode *status);`</span>
1161      *
1162      */
1163     RegexMatcher &amp;reset(const char16_t *input);
1164 public:
1165 
1166    /**
1167     *   Returns the input string being matched.  Ownership of the string belongs to
1168     *   the matcher; it should not be altered or deleted. This method will work even if the input
1169     *   was originally supplied as a UText.
1170     *   @return the input string
1171     *   @stable ICU 2.4
1172     */
1173     virtual const UnicodeString &amp;input() const;
1174 
1175    /**
1176     *   Returns the input string being matched.  This is the live input text; it should not be
1177     *   altered or deleted. This method will work even if the input was originally supplied as
1178     *   a UnicodeString.
1179     *   @return the input text
1180     *
</pre>
<hr />
<pre>
1389     *    replacement string. The replacement string may contain references to
1390     *    capture groups.
1391     *
1392     *    @param   replacement a string containing the replacement text.
1393     *    @param   dest        a mutable UText in which the results are placed.
1394     *                          If NULL, a new UText will be created (which may not be mutable).
1395     *    @param   status      a reference to a UErrorCode to receive any errors.
1396     *    @return              a string containing the results of the find and replace.
1397     *                          If a pre-allocated UText was provided, it will always be used and returned.
1398     *
1399     *    @stable ICU 4.6
1400     */
1401     virtual UText *replaceAll(UText *replacement, UText *dest, UErrorCode &amp;status);
1402 
1403 
1404    /**
1405     * Replaces the first substring of the input that matches
1406     * the pattern with the replacement string.   This is a convenience
1407     * function that provides a complete find-and-replace operation.
1408     *
<span class="line-modified">1409     * This function first resets this RegexMatcher. It then scans the input string</span>
1410     * looking for a match of the pattern. Input that is not part
1411     * of the match is appended directly to the result string; the match is replaced
1412     * in the result by the replacement string. The replacement string may contain
<span class="line-modified">1413     * references to captured groups.</span>
1414     *
<span class="line-modified">1415     * The state of the matcher (the position at which a subsequent find()</span>
1416     *    would begin) after completing a replaceFirst() is not specified.  The
<span class="line-modified">1417     *    RegexMatcher should be reset before doing additional find() operations.</span>
1418     *
1419     *    @param   replacement a string containing the replacement text.
1420     *    @param   status      a reference to a UErrorCode to receive any errors.
1421     *    @return              a string containing the results of the find and replace.
1422     *    @stable ICU 2.4
1423     */
1424     virtual UnicodeString replaceFirst(const UnicodeString &amp;replacement, UErrorCode &amp;status);
1425 
1426 
1427    /**
1428     * Replaces the first substring of the input that matches
1429     * the pattern with the replacement string.   This is a convenience
1430     * function that provides a complete find-and-replace operation.
1431     *
<span class="line-modified">1432     * This function first resets this RegexMatcher. It then scans the input string</span>
1433     * looking for a match of the pattern. Input that is not part
1434     * of the match is appended directly to the result string; the match is replaced
1435     * in the result by the replacement string. The replacement string may contain
<span class="line-modified">1436     * references to captured groups.</span>
1437     *
<span class="line-modified">1438     * The state of the matcher (the position at which a subsequent find()</span>
1439     *    would begin) after completing a replaceFirst() is not specified.  The
<span class="line-modified">1440     *    RegexMatcher should be reset before doing additional find() operations.</span>
1441     *
1442     *    @param   replacement a string containing the replacement text.
1443     *    @param   dest        a mutable UText in which the results are placed.
1444     *                          If NULL, a new UText will be created (which may not be mutable).
1445     *    @param   status      a reference to a UErrorCode to receive any errors.
1446     *    @return              a string containing the results of the find and replace.
1447     *                          If a pre-allocated UText was provided, it will always be used and returned.
1448     *
1449     *    @stable ICU 4.6
1450     */
1451     virtual UText *replaceFirst(UText *replacement, UText *dest, UErrorCode &amp;status);
1452 
1453 
1454    /**
1455     *   Implements a replace operation intended to be used as part of an
1456     *   incremental find-and-replace.
1457     *
<span class="line-modified">1458     *   The input string, starting from the end of the previous replacement and ending at</span>
1459     *   the start of the current match, is appended to the destination string.  Then the
1460     *   replacement string is appended to the output string,
<span class="line-modified">1461     *   including handling any substitutions of captured text.</span>
1462     *
<span class="line-modified">1463     *   For simple, prepackaged, non-incremental find-and-replace</span>
<span class="line-modified">1464     *   operations, see replaceFirst() or replaceAll().</span>
1465     *
1466     *   @param   dest        A UnicodeString to which the results of the find-and-replace are appended.
1467     *   @param   replacement A UnicodeString that provides the text to be substituted for
1468     *                        the input text that matched the regexp pattern.  The replacement
1469     *                        text may contain references to captured text from the
1470     *                        input.
1471     *   @param   status      A reference to a UErrorCode to receive any errors.  Possible
1472     *                        errors are  U_REGEX_INVALID_STATE if no match has been
1473     *                        attempted or the last match failed, and U_INDEX_OUTOFBOUNDS_ERROR
1474     *                        if the replacement text specifies a capture group that
1475     *                        does not exist in the pattern.
1476     *
1477     *   @return  this  RegexMatcher
1478     *   @stable ICU 2.4
1479     *
1480     */
1481     virtual RegexMatcher &amp;appendReplacement(UnicodeString &amp;dest,
1482         const UnicodeString &amp;replacement, UErrorCode &amp;status);
1483 
1484 
1485    /**
1486     *   Implements a replace operation intended to be used as part of an
1487     *   incremental find-and-replace.
1488     *
<span class="line-modified">1489     *   The input string, starting from the end of the previous replacement and ending at</span>
1490     *   the start of the current match, is appended to the destination string.  Then the
1491     *   replacement string is appended to the output string,
<span class="line-modified">1492     *   including handling any substitutions of captured text.</span>
1493     *
<span class="line-modified">1494     *   For simple, prepackaged, non-incremental find-and-replace</span>
<span class="line-modified">1495     *   operations, see replaceFirst() or replaceAll().</span>
1496     *
1497     *   @param   dest        A mutable UText to which the results of the find-and-replace are appended.
1498     *                         Must not be NULL.
1499     *   @param   replacement A UText that provides the text to be substituted for
1500     *                        the input text that matched the regexp pattern.  The replacement
1501     *                        text may contain references to captured text from the input.
1502     *   @param   status      A reference to a UErrorCode to receive any errors.  Possible
1503     *                        errors are  U_REGEX_INVALID_STATE if no match has been
1504     *                        attempted or the last match failed, and U_INDEX_OUTOFBOUNDS_ERROR
1505     *                        if the replacement text specifies a capture group that
1506     *                        does not exist in the pattern.
1507     *
1508     *   @return  this  RegexMatcher
1509     *
1510     *   @stable ICU 4.6
1511     */
1512     virtual RegexMatcher &amp;appendReplacement(UText *dest,
1513         UText *replacement, UErrorCode &amp;status);
1514 
1515 
1516    /**
1517     * As the final step in a find-and-replace operation, append the remainder
1518     * of the input string, starting at the position following the last appendReplacement(),
<span class="line-modified">1519     * to the destination string. `appendTail()` is intended to be invoked after one</span>
<span class="line-modified">1520     * or more invocations of the `RegexMatcher::appendReplacement()`.</span>
1521     *
1522     *  @param dest A UnicodeString to which the results of the find-and-replace are appended.
1523     *  @return  the destination string.
1524     *  @stable ICU 2.4
1525     */
1526     virtual UnicodeString &amp;appendTail(UnicodeString &amp;dest);
1527 
1528 
1529    /**
1530     * As the final step in a find-and-replace operation, append the remainder
1531     * of the input string, starting at the position following the last appendReplacement(),
<span class="line-modified">1532     * to the destination string. `appendTail()` is intended to be invoked after one</span>
<span class="line-modified">1533     * or more invocations of the `RegexMatcher::appendReplacement()`.</span>
1534     *
1535     *  @param dest A mutable UText to which the results of the find-and-replace are appended.
1536     *               Must not be NULL.
1537     *  @param status error cod
1538     *  @return  the destination string.
1539     *
1540     *  @stable ICU 4.6
1541     */
1542     virtual UText *appendTail(UText *dest, UErrorCode &amp;status);
1543 
1544 
1545     /**
<span class="line-modified">1546      * Split a string into fields.  Somewhat like %split() from Perl.</span>
1547      * The pattern matches identify delimiters that separate the input
1548      *  into fields.  The input data between the matches becomes the
1549      *  fields themselves.
1550      *
1551      * @param input   The string to be split into fields.  The field delimiters
1552      *                match the pattern (in the &quot;this&quot; object).  This matcher
1553      *                will be reset to this input string.
1554      * @param dest    An array of UnicodeStrings to receive the results of the split.
1555      *                This is an array of actual UnicodeString objects, not an
1556      *                array of pointers to strings.  Local (stack based) arrays can
1557      *                work well here.
1558      * @param destCapacity  The number of elements in the destination array.
1559      *                If the number of fields found is less than destCapacity, the
1560      *                extra strings in the destination array are not altered.
1561      *                If the number of destination strings is less than the number
1562      *                of fields, the trailing part of the input string, including any
1563      *                field delimiters, is placed in the last destination string.
1564      * @param status  A reference to a UErrorCode to receive any errors.
1565      * @return        The number of fields into which the input string was split.
1566      * @stable ICU 2.6
1567      */
1568     virtual int32_t  split(const UnicodeString &amp;input,
1569         UnicodeString    dest[],
1570         int32_t          destCapacity,
1571         UErrorCode       &amp;status);
1572 
1573 
1574     /**
<span class="line-modified">1575      * Split a string into fields.  Somewhat like %split() from Perl.</span>
1576      * The pattern matches identify delimiters that separate the input
1577      *  into fields.  The input data between the matches becomes the
1578      *  fields themselves.
1579      *
1580      * @param input   The string to be split into fields.  The field delimiters
1581      *                match the pattern (in the &quot;this&quot; object).  This matcher
1582      *                will be reset to this input string.
1583      * @param dest    An array of mutable UText structs to receive the results of the split.
1584      *                If a field is NULL, a new UText is allocated to contain the results for
1585      *                that field. This new UText is not guaranteed to be mutable.
1586      * @param destCapacity  The number of elements in the destination array.
1587      *                If the number of fields found is less than destCapacity, the
1588      *                extra strings in the destination array are not altered.
1589      *                If the number of destination strings is less than the number
1590      *                of fields, the trailing part of the input string, including any
1591      *                field delimiters, is placed in the last destination string.
1592      * @param status  A reference to a UErrorCode to receive any errors.
1593      * @return        The number of fields into which the input string was split.
1594      *
1595      * @stable ICU 4.6
1596      */
1597     virtual int32_t  split(UText *input,
1598         UText           *dest[],
1599         int32_t          destCapacity,
1600         UErrorCode       &amp;status);
1601 
1602   /**
1603     *   Set a processing time limit for match operations with this Matcher.
1604     *
1605     *   Some patterns, when matching certain strings, can run in exponential time.
1606     *   For practical purposes, the match operation may appear to be in an
1607     *   infinite loop.
1608     *   When a limit is set a match operation will fail with an error if the
1609     *   limit is exceeded.
<span class="line-modified">1610     *</span>
1611     *   The units of the limit are steps of the match engine.
1612     *   Correspondence with actual processor time will depend on the speed
1613     *   of the processor and the details of the specific pattern, but will
1614     *   typically be on the order of milliseconds.
<span class="line-modified">1615     *</span>
1616     *   By default, the matching time is not limited.
<span class="line-modified">1617     *</span>
1618     *
1619     *   @param   limit       The limit value, or 0 for no limit.
1620     *   @param   status      A reference to a UErrorCode to receive any errors.
1621     *   @stable ICU 4.0
1622     */
1623     virtual void setTimeLimit(int32_t limit, UErrorCode &amp;status);
1624 
1625   /**
1626     * Get the time limit, if any, for match operations made with this Matcher.
1627     *
1628     *   @return the maximum allowed time for a match, in units of processing steps.
1629     *   @stable ICU 4.0
1630     */
1631     virtual int32_t getTimeLimit() const;
1632 
1633   /**
1634     *  Set the amount of heap storage available for use by the match backtracking stack.
1635     *  The matcher is also reset, discarding any results from previous matches.
<span class="line-modified">1636     *</span>
1637     *  ICU uses a backtracking regular expression engine, with the backtrack stack
1638     *  maintained on the heap.  This function sets the limit to the amount of memory
<span class="line-modified">1639     *  that can be used for this purpose.  A backtracking stack overflow will</span>
1640     *  result in an error from the match operation that caused it.
<span class="line-modified">1641     *</span>
1642     *  A limit is desirable because a malicious or poorly designed pattern can use
1643     *  excessive memory, potentially crashing the process.  A limit is enabled
1644     *  by default.
<span class="line-modified">1645     *</span>
1646     *  @param limit  The maximum size, in bytes, of the matching backtrack stack.
1647     *                A value of zero means no limit.
1648     *                The limit must be greater or equal to zero.
1649     *
1650     *  @param status   A reference to a UErrorCode to receive any errors.
1651     *
1652     *  @stable ICU 4.0
1653     */
1654     virtual void setStackLimit(int32_t  limit, UErrorCode &amp;status);
1655 
1656   /**
1657     *  Get the size of the heap storage available for use by the back tracking stack.
1658     *
1659     *  @return  the maximum backtracking stack size, in bytes, or zero if the
1660     *           stack size is unlimited.
1661     *  @stable ICU 4.0
1662     */
1663     virtual int32_t  getStackLimit() const;
1664 
1665 
</pre>
</td>
</tr>
</table>
<center><a href="rbnf.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="region.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>