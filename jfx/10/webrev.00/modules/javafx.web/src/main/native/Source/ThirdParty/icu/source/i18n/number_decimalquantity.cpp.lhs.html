<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_decimalquantity.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2017 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 
   4 #include &quot;unicode/utypes.h&quot;
   5 
   6 #if !UCONFIG_NO_FORMATTING
   7 
   8 #include &lt;cstdlib&gt;
   9 #include &lt;cmath&gt;
  10 #include &lt;limits&gt;
  11 #include &lt;stdlib.h&gt;
  12 
  13 #include &quot;unicode/plurrule.h&quot;
  14 #include &quot;cmemory.h&quot;
  15 #include &quot;number_decnum.h&quot;
  16 #include &quot;putilimp.h&quot;
  17 #include &quot;number_decimalquantity.h&quot;
  18 #include &quot;number_roundingutils.h&quot;
  19 #include &quot;double-conversion.h&quot;
  20 #include &quot;charstr.h&quot;
  21 #include &quot;number_utils.h&quot;
  22 #include &quot;uassert.h&quot;
  23 
  24 using namespace icu;
  25 using namespace icu::number;
  26 using namespace icu::number::impl;
  27 
  28 using icu::double_conversion::DoubleToStringConverter;
  29 using icu::double_conversion::StringToDoubleConverter;
  30 
  31 namespace {
  32 
  33 int8_t NEGATIVE_FLAG = 1;
  34 int8_t INFINITY_FLAG = 2;
  35 int8_t NAN_FLAG = 4;
  36 
  37 /** Helper function for safe subtraction (no overflow). */
  38 inline int32_t safeSubtract(int32_t a, int32_t b) {
  39     // Note: In C++, signed integer subtraction is undefined behavior.
  40     int32_t diff = static_cast&lt;int32_t&gt;(static_cast&lt;uint32_t&gt;(a) - static_cast&lt;uint32_t&gt;(b));
  41     if (b &lt; 0 &amp;&amp; diff &lt; a) { return INT32_MAX; }
  42     if (b &gt; 0 &amp;&amp; diff &gt; a) { return INT32_MIN; }
  43     return diff;
  44 }
  45 
  46 static double DOUBLE_MULTIPLIERS[] = {
  47         1e0,
  48         1e1,
  49         1e2,
  50         1e3,
  51         1e4,
  52         1e5,
  53         1e6,
  54         1e7,
  55         1e8,
  56         1e9,
  57         1e10,
  58         1e11,
  59         1e12,
  60         1e13,
  61         1e14,
  62         1e15,
  63         1e16,
  64         1e17,
  65         1e18,
  66         1e19,
  67         1e20,
  68         1e21};
  69 
  70 }  // namespace
  71 
  72 icu::IFixedDecimal::~IFixedDecimal() = default;
  73 
  74 DecimalQuantity::DecimalQuantity() {
  75     setBcdToZero();
  76     flags = 0;
  77 }
  78 
  79 DecimalQuantity::~DecimalQuantity() {
  80     if (usingBytes) {
  81         uprv_free(fBCD.bcdBytes.ptr);
  82         fBCD.bcdBytes.ptr = nullptr;
  83         usingBytes = false;
  84     }
  85 }
  86 
  87 DecimalQuantity::DecimalQuantity(const DecimalQuantity &amp;other) {
  88     *this = other;
  89 }
  90 
  91 DecimalQuantity::DecimalQuantity(DecimalQuantity&amp;&amp; src) U_NOEXCEPT {
  92     *this = std::move(src);
  93 }
  94 
  95 DecimalQuantity &amp;DecimalQuantity::operator=(const DecimalQuantity &amp;other) {
  96     if (this == &amp;other) {
  97         return *this;
  98     }
  99     copyBcdFrom(other);
 100     copyFieldsFrom(other);
 101     return *this;
 102 }
 103 
 104 DecimalQuantity&amp; DecimalQuantity::operator=(DecimalQuantity&amp;&amp; src) U_NOEXCEPT {
 105     if (this == &amp;src) {
 106         return *this;
 107     }
 108     moveBcdFrom(src);
 109     copyFieldsFrom(src);
 110     return *this;
 111 }
 112 
 113 void DecimalQuantity::copyFieldsFrom(const DecimalQuantity&amp; other) {
 114     bogus = other.bogus;
<a name="1" id="anc1"></a><span class="line-removed"> 115     lOptPos = other.lOptPos;</span>
 116     lReqPos = other.lReqPos;
 117     rReqPos = other.rReqPos;
<a name="2" id="anc2"></a><span class="line-removed"> 118     rOptPos = other.rOptPos;</span>
 119     scale = other.scale;
 120     precision = other.precision;
 121     flags = other.flags;
 122     origDouble = other.origDouble;
 123     origDelta = other.origDelta;
 124     isApproximate = other.isApproximate;
 125 }
 126 
 127 void DecimalQuantity::clear() {
<a name="3" id="anc3"></a><span class="line-removed"> 128     lOptPos = INT32_MAX;</span>
 129     lReqPos = 0;
 130     rReqPos = 0;
<a name="4" id="anc4"></a><span class="line-removed"> 131     rOptPos = INT32_MIN;</span>
 132     flags = 0;
 133     setBcdToZero(); // sets scale, precision, hasDouble, origDouble, origDelta, and BCD data
 134 }
 135 
<a name="5" id="anc5"></a><span class="line-modified"> 136 void DecimalQuantity::setIntegerLength(int32_t minInt, int32_t maxInt) {</span>
 137     // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.
 138     U_ASSERT(minInt &gt;= 0);
<a name="6" id="anc6"></a><span class="line-removed"> 139     U_ASSERT(maxInt &gt;= minInt);</span>
 140 
 141     // Special behavior: do not set minInt to be less than what is already set.
 142     // This is so significant digits rounding can set the integer length.
 143     if (minInt &lt; lReqPos) {
 144         minInt = lReqPos;
 145     }
 146 
 147     // Save values into internal state
<a name="7" id="anc7"></a><span class="line-removed"> 148     // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE &gt; Integer.MIN_VALUE</span>
<span class="line-removed"> 149     lOptPos = maxInt;</span>
 150     lReqPos = minInt;
 151 }
 152 
<a name="8" id="anc8"></a><span class="line-modified"> 153 void DecimalQuantity::setFractionLength(int32_t minFrac, int32_t maxFrac) {</span>
 154     // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.
 155     U_ASSERT(minFrac &gt;= 0);
<a name="9" id="anc9"></a><span class="line-removed"> 156     U_ASSERT(maxFrac &gt;= minFrac);</span>
 157 
 158     // Save values into internal state
 159     // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE &gt; Integer.MIN_VALUE
 160     rReqPos = -minFrac;
<a name="10" id="anc10"></a><span class="line-modified"> 161     rOptPos = -maxFrac;</span>



















 162 }
 163 
 164 uint64_t DecimalQuantity::getPositionFingerprint() const {
 165     uint64_t fingerprint = 0;
<a name="11" id="anc11"></a><span class="line-removed"> 166     fingerprint ^= lOptPos;</span>
 167     fingerprint ^= (lReqPos &lt;&lt; 16);
 168     fingerprint ^= (static_cast&lt;uint64_t&gt;(rReqPos) &lt;&lt; 32);
<a name="12" id="anc12"></a><span class="line-removed"> 169     fingerprint ^= (static_cast&lt;uint64_t&gt;(rOptPos) &lt;&lt; 48);</span>
 170     return fingerprint;
 171 }
 172 
 173 void DecimalQuantity::roundToIncrement(double roundingIncrement, RoundingMode roundingMode,
<a name="13" id="anc13"></a><span class="line-modified"> 174                                        int32_t maxFrac, UErrorCode&amp; status) {</span>
<span class="line-modified"> 175     // TODO(13701): This is innefficient.  Improve?</span>
<span class="line-modified"> 176     // TODO(13701): Should we convert to decNumber instead?</span>
<span class="line-modified"> 177     roundToInfinity();</span>
<span class="line-modified"> 178     double temp = toDouble();</span>
<span class="line-modified"> 179     temp /= roundingIncrement;</span>
<span class="line-modified"> 180     // Use another DecimalQuantity to perform the actual rounding...</span>
<span class="line-modified"> 181     DecimalQuantity dq;</span>
<span class="line-modified"> 182     dq.setToDouble(temp);</span>
<span class="line-modified"> 183     dq.roundToMagnitude(0, roundingMode, status);</span>
<span class="line-modified"> 184     temp = dq.toDouble();</span>
<span class="line-modified"> 185     temp *= roundingIncrement;</span>
<span class="line-modified"> 186     setToDouble(temp);</span>
<span class="line-modified"> 187     // Since we reset the value to a double, we need to specify the rounding boundary</span>
<span class="line-modified"> 188     // in order to get the DecimalQuantity out of approximation mode.</span>
<span class="line-modified"> 189     // NOTE: In Java, we have minMaxFrac, but in C++, the two are differentiated.</span>
<span class="line-modified"> 190     roundToMagnitude(-maxFrac, roundingMode, status);</span>





 191 }
 192 
 193 void DecimalQuantity::multiplyBy(const DecNum&amp; multiplicand, UErrorCode&amp; status) {
 194     if (isInfinite() || isZero() || isNaN()) {
 195         return;
 196     }
 197     // Convert to DecNum, multiply, and convert back.
 198     DecNum decnum;
 199     toDecNum(decnum, status);
 200     if (U_FAILURE(status)) { return; }
 201     decnum.multiplyBy(multiplicand, status);
 202     if (U_FAILURE(status)) { return; }
 203     setToDecNum(decnum, status);
 204 }
 205 
 206 void DecimalQuantity::divideBy(const DecNum&amp; divisor, UErrorCode&amp; status) {
 207     if (isInfinite() || isZero() || isNaN()) {
 208         return;
 209     }
 210     // Convert to DecNum, multiply, and convert back.
 211     DecNum decnum;
 212     toDecNum(decnum, status);
 213     if (U_FAILURE(status)) { return; }
 214     decnum.divideBy(divisor, status);
 215     if (U_FAILURE(status)) { return; }
 216     setToDecNum(decnum, status);
 217 }
 218 
 219 void DecimalQuantity::negate() {
 220     flags ^= NEGATIVE_FLAG;
 221 }
 222 
 223 int32_t DecimalQuantity::getMagnitude() const {
 224     U_ASSERT(precision != 0);
 225     return scale + precision - 1;
 226 }
 227 
 228 bool DecimalQuantity::adjustMagnitude(int32_t delta) {
 229     if (precision != 0) {
 230         // i.e., scale += delta; origDelta += delta
 231         bool overflow = uprv_add32_overflow(scale, delta, &amp;scale);
 232         overflow = uprv_add32_overflow(origDelta, delta, &amp;origDelta) || overflow;
 233         // Make sure that precision + scale won&#39;t overflow, either
 234         int32_t dummy;
 235         overflow = overflow || uprv_add32_overflow(scale, precision, &amp;dummy);
 236         return overflow;
 237     }
 238     return false;
 239 }
 240 
 241 double DecimalQuantity::getPluralOperand(PluralOperand operand) const {
 242     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 243     // See the comment at the top of this file explaining the &quot;isApproximate&quot; field.
 244     U_ASSERT(!isApproximate);
 245 
 246     switch (operand) {
 247         case PLURAL_OPERAND_I:
 248             // Invert the negative sign if necessary
 249             return static_cast&lt;double&gt;(isNegative() ? -toLong(true) : toLong(true));
 250         case PLURAL_OPERAND_F:
 251             return static_cast&lt;double&gt;(toFractionLong(true));
 252         case PLURAL_OPERAND_T:
 253             return static_cast&lt;double&gt;(toFractionLong(false));
 254         case PLURAL_OPERAND_V:
 255             return fractionCount();
 256         case PLURAL_OPERAND_W:
 257             return fractionCountWithoutTrailingZeros();
 258         default:
 259             return std::abs(toDouble());
 260     }
 261 }
 262 
 263 bool DecimalQuantity::hasIntegerValue() const {
 264     return scale &gt;= 0;
 265 }
 266 
 267 int32_t DecimalQuantity::getUpperDisplayMagnitude() const {
 268     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 269     // See the comment in the header file explaining the &quot;isApproximate&quot; field.
 270     U_ASSERT(!isApproximate);
 271 
 272     int32_t magnitude = scale + precision;
<a name="14" id="anc14"></a><span class="line-modified"> 273     int32_t result = (lReqPos &gt; magnitude) ? lReqPos : (lOptPos &lt; magnitude) ? lOptPos : magnitude;</span>
 274     return result - 1;
 275 }
 276 
 277 int32_t DecimalQuantity::getLowerDisplayMagnitude() const {
 278     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 279     // See the comment in the header file explaining the &quot;isApproximate&quot; field.
 280     U_ASSERT(!isApproximate);
 281 
 282     int32_t magnitude = scale;
<a name="15" id="anc15"></a><span class="line-modified"> 283     int32_t result = (rReqPos &lt; magnitude) ? rReqPos : (rOptPos &gt; magnitude) ? rOptPos : magnitude;</span>
 284     return result;
 285 }
 286 
 287 int8_t DecimalQuantity::getDigit(int32_t magnitude) const {
 288     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 289     // See the comment at the top of this file explaining the &quot;isApproximate&quot; field.
 290     U_ASSERT(!isApproximate);
 291 
 292     return getDigitPos(magnitude - scale);
 293 }
 294 
 295 int32_t DecimalQuantity::fractionCount() const {
 296     return -getLowerDisplayMagnitude();
 297 }
 298 
 299 int32_t DecimalQuantity::fractionCountWithoutTrailingZeros() const {
 300     return -scale &gt; 0 ? -scale : 0;  // max(-scale, 0)
 301 }
 302 
 303 bool DecimalQuantity::isNegative() const {
 304     return (flags &amp; NEGATIVE_FLAG) != 0;
 305 }
 306 
 307 int8_t DecimalQuantity::signum() const {
 308     return isNegative() ? -1 : isZero() ? 0 : 1;
 309 }
 310 
 311 bool DecimalQuantity::isInfinite() const {
 312     return (flags &amp; INFINITY_FLAG) != 0;
 313 }
 314 
 315 bool DecimalQuantity::isNaN() const {
 316     return (flags &amp; NAN_FLAG) != 0;
 317 }
 318 
 319 bool DecimalQuantity::isZero() const {
 320     return precision == 0;
 321 }
 322 
 323 DecimalQuantity &amp;DecimalQuantity::setToInt(int32_t n) {
 324     setBcdToZero();
 325     flags = 0;
 326     if (n == INT32_MIN) {
 327         flags |= NEGATIVE_FLAG;
 328         // leave as INT32_MIN; handled below in _setToInt()
 329     } else if (n &lt; 0) {
 330         flags |= NEGATIVE_FLAG;
 331         n = -n;
 332     }
 333     if (n != 0) {
 334         _setToInt(n);
 335         compact();
 336     }
 337     return *this;
 338 }
 339 
 340 void DecimalQuantity::_setToInt(int32_t n) {
 341     if (n == INT32_MIN) {
 342         readLongToBcd(-static_cast&lt;int64_t&gt;(n));
 343     } else {
 344         readIntToBcd(n);
 345     }
 346 }
 347 
 348 DecimalQuantity &amp;DecimalQuantity::setToLong(int64_t n) {
 349     setBcdToZero();
 350     flags = 0;
 351     if (n &lt; 0 &amp;&amp; n &gt; INT64_MIN) {
 352         flags |= NEGATIVE_FLAG;
 353         n = -n;
 354     }
 355     if (n != 0) {
 356         _setToLong(n);
 357         compact();
 358     }
 359     return *this;
 360 }
 361 
 362 void DecimalQuantity::_setToLong(int64_t n) {
 363     if (n == INT64_MIN) {
 364         DecNum decnum;
 365         UErrorCode localStatus = U_ZERO_ERROR;
 366         decnum.setTo(&quot;9.223372036854775808E+18&quot;, localStatus);
 367         if (U_FAILURE(localStatus)) { return; } // unexpected
 368         flags |= NEGATIVE_FLAG;
 369         readDecNumberToBcd(decnum);
 370     } else if (n &lt;= INT32_MAX) {
 371         readIntToBcd(static_cast&lt;int32_t&gt;(n));
 372     } else {
 373         readLongToBcd(n);
 374     }
 375 }
 376 
 377 DecimalQuantity &amp;DecimalQuantity::setToDouble(double n) {
 378     setBcdToZero();
 379     flags = 0;
 380     // signbit() from &lt;math.h&gt; handles +0.0 vs -0.0
 381     if (std::signbit(n)) {
 382         flags |= NEGATIVE_FLAG;
 383         n = -n;
 384     }
 385     if (std::isnan(n) != 0) {
 386         flags |= NAN_FLAG;
 387     } else if (std::isfinite(n) == 0) {
 388         flags |= INFINITY_FLAG;
 389     } else if (n != 0) {
 390         _setToDoubleFast(n);
 391         compact();
 392     }
 393     return *this;
 394 }
 395 
 396 void DecimalQuantity::_setToDoubleFast(double n) {
 397     isApproximate = true;
 398     origDouble = n;
 399     origDelta = 0;
 400 
 401     // Make sure the double is an IEEE 754 double.  If not, fall back to the slow path right now.
 402     // TODO: Make a fast path for other types of doubles.
 403     if (!std::numeric_limits&lt;double&gt;::is_iec559) {
 404         convertToAccurateDouble();
 405         // Turn off the approximate double flag, since the value is now exact.
 406         isApproximate = false;
 407         origDouble = 0.0;
 408         return;
 409     }
 410 
 411     // To get the bits from the double, use memcpy, which takes care of endianness.
 412     uint64_t ieeeBits;
 413     uprv_memcpy(&amp;ieeeBits, &amp;n, sizeof(n));
 414     int32_t exponent = static_cast&lt;int32_t&gt;((ieeeBits &amp; 0x7ff0000000000000L) &gt;&gt; 52) - 0x3ff;
 415 
 416     // Not all integers can be represented exactly for exponent &gt; 52
 417     if (exponent &lt;= 52 &amp;&amp; static_cast&lt;int64_t&gt;(n) == n) {
 418         _setToLong(static_cast&lt;int64_t&gt;(n));
 419         return;
 420     }
 421 
 422     // 3.3219... is log2(10)
 423     auto fracLength = static_cast&lt;int32_t&gt; ((52 - exponent) / 3.32192809489);
 424     if (fracLength &gt;= 0) {
 425         int32_t i = fracLength;
 426         // 1e22 is the largest exact double.
 427         for (; i &gt;= 22; i -= 22) n *= 1e22;
 428         n *= DOUBLE_MULTIPLIERS[i];
 429     } else {
 430         int32_t i = fracLength;
 431         // 1e22 is the largest exact double.
 432         for (; i &lt;= -22; i += 22) n /= 1e22;
 433         n /= DOUBLE_MULTIPLIERS[-i];
 434     }
 435     auto result = static_cast&lt;int64_t&gt;(std::round(n));
 436     if (result != 0) {
 437         _setToLong(result);
 438         scale -= fracLength;
 439     }
 440 }
 441 
 442 void DecimalQuantity::convertToAccurateDouble() {
 443     U_ASSERT(origDouble != 0);
 444     int32_t delta = origDelta;
 445 
 446     // Call the slow oracle function (Double.toString in Java, DoubleToAscii in C++).
 447     char buffer[DoubleToStringConverter::kBase10MaximalLength + 1];
 448     bool sign; // unused; always positive
 449     int32_t length;
 450     int32_t point;
 451     DoubleToStringConverter::DoubleToAscii(
 452         origDouble,
 453         DoubleToStringConverter::DtoaMode::SHORTEST,
 454         0,
 455         buffer,
 456         sizeof(buffer),
 457         &amp;sign,
 458         &amp;length,
 459         &amp;point
 460     );
 461 
 462     setBcdToZero();
 463     readDoubleConversionToBcd(buffer, length, point);
 464     scale += delta;
 465     explicitExactDouble = true;
 466 }
 467 
 468 DecimalQuantity &amp;DecimalQuantity::setToDecNumber(StringPiece n, UErrorCode&amp; status) {
 469     setBcdToZero();
 470     flags = 0;
 471 
 472     // Compute the decNumber representation
 473     DecNum decnum;
 474     decnum.setTo(n, status);
 475 
 476     _setToDecNum(decnum, status);
 477     return *this;
 478 }
 479 
 480 DecimalQuantity&amp; DecimalQuantity::setToDecNum(const DecNum&amp; decnum, UErrorCode&amp; status) {
 481     setBcdToZero();
 482     flags = 0;
 483 
 484     _setToDecNum(decnum, status);
 485     return *this;
 486 }
 487 
 488 void DecimalQuantity::_setToDecNum(const DecNum&amp; decnum, UErrorCode&amp; status) {
 489     if (U_FAILURE(status)) { return; }
 490     if (decnum.isNegative()) {
 491         flags |= NEGATIVE_FLAG;
 492     }
 493     if (!decnum.isZero()) {
 494         readDecNumberToBcd(decnum);
 495         compact();
 496     }
 497 }
 498 
 499 int64_t DecimalQuantity::toLong(bool truncateIfOverflow) const {
 500     // NOTE: Call sites should be guarded by fitsInLong(), like this:
 501     // if (dq.fitsInLong()) { /* use dq.toLong() */ } else { /* use some fallback */ }
 502     // Fallback behavior upon truncateIfOverflow is to truncate at 17 digits.
 503     uint64_t result = 0L;
<a name="16" id="anc16"></a><span class="line-modified"> 504     int32_t upperMagnitude = std::min(scale + precision, lOptPos) - 1;</span>
 505     if (truncateIfOverflow) {
 506         upperMagnitude = std::min(upperMagnitude, 17);
 507     }
 508     for (int32_t magnitude = upperMagnitude; magnitude &gt;= 0; magnitude--) {
 509         result = result * 10 + getDigitPos(magnitude - scale);
 510     }
 511     if (isNegative()) {
 512         return static_cast&lt;int64_t&gt;(0LL - result); // i.e., -result
 513     }
 514     return static_cast&lt;int64_t&gt;(result);
 515 }
 516 
 517 uint64_t DecimalQuantity::toFractionLong(bool includeTrailingZeros) const {
 518     uint64_t result = 0L;
 519     int32_t magnitude = -1;
<a name="17" id="anc17"></a><span class="line-modified"> 520     int32_t lowerMagnitude = std::max(scale, rOptPos);</span>
 521     if (includeTrailingZeros) {
 522         lowerMagnitude = std::min(lowerMagnitude, rReqPos);
 523     }
 524     for (; magnitude &gt;= lowerMagnitude &amp;&amp; result &lt;= 1e18L; magnitude--) {
 525         result = result * 10 + getDigitPos(magnitude - scale);
 526     }
 527     // Remove trailing zeros; this can happen during integer overflow cases.
 528     if (!includeTrailingZeros) {
 529         while (result &gt; 0 &amp;&amp; (result % 10) == 0) {
 530             result /= 10;
 531         }
 532     }
 533     return result;
 534 }
 535 
 536 bool DecimalQuantity::fitsInLong(bool ignoreFraction) const {
 537     if (isZero()) {
 538         return true;
 539     }
 540     if (scale &lt; 0 &amp;&amp; !ignoreFraction) {
 541         return false;
 542     }
 543     int magnitude = getMagnitude();
 544     if (magnitude &lt; 18) {
 545         return true;
 546     }
 547     if (magnitude &gt; 18) {
 548         return false;
 549     }
 550     // Hard case: the magnitude is 10^18.
 551     // The largest int64 is: 9,223,372,036,854,775,807
 552     for (int p = 0; p &lt; precision; p++) {
 553         int8_t digit = getDigit(18 - p);
 554         static int8_t INT64_BCD[] = { 9, 2, 2, 3, 3, 7, 2, 0, 3, 6, 8, 5, 4, 7, 7, 5, 8, 0, 8 };
 555         if (digit &lt; INT64_BCD[p]) {
 556             return true;
 557         } else if (digit &gt; INT64_BCD[p]) {
 558             return false;
 559         }
 560     }
 561     // Exactly equal to max long plus one.
 562     return isNegative();
 563 }
 564 
 565 double DecimalQuantity::toDouble() const {
 566     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 567     // See the comment in the header file explaining the &quot;isApproximate&quot; field.
 568     U_ASSERT(!isApproximate);
 569 
 570     if (isNaN()) {
 571         return NAN;
 572     } else if (isInfinite()) {
 573         return isNegative() ? -INFINITY : INFINITY;
 574     }
 575 
 576     // We are processing well-formed input, so we don&#39;t need any special options to StringToDoubleConverter.
 577     StringToDoubleConverter converter(0, 0, 0, &quot;&quot;, &quot;&quot;);
 578     UnicodeString numberString = this-&gt;toScientificString();
 579     int32_t count;
 580     return converter.StringToDouble(
 581             reinterpret_cast&lt;const uint16_t*&gt;(numberString.getBuffer()),
 582             numberString.length(),
 583             &amp;count);
 584 }
 585 
 586 void DecimalQuantity::toDecNum(DecNum&amp; output, UErrorCode&amp; status) const {
 587     // Special handling for zero
 588     if (precision == 0) {
 589         output.setTo(&quot;0&quot;, status);
 590     }
 591 
 592     // Use the BCD constructor. We need to do a little bit of work to convert, though.
 593     // The decNumber constructor expects most-significant first, but we store least-significant first.
 594     MaybeStackArray&lt;uint8_t, 20&gt; ubcd(precision);
 595     for (int32_t m = 0; m &lt; precision; m++) {
 596         ubcd[precision - m - 1] = static_cast&lt;uint8_t&gt;(getDigitPos(m));
 597     }
 598     output.setTo(ubcd.getAlias(), precision, scale, isNegative(), status);
 599 }
 600 
 601 void DecimalQuantity::truncate() {
 602     if (scale &lt; 0) {
 603         shiftRight(-scale);
 604         scale = 0;
 605         compact();
 606     }
 607 }
 608 
<a name="18" id="anc18"></a>



 609 void DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, UErrorCode&amp; status) {
<a name="19" id="anc19"></a>



 610     // The position in the BCD at which rounding will be performed; digits to the right of position
 611     // will be rounded away.
<a name="20" id="anc20"></a><span class="line-removed"> 612     // TODO: Andy: There was a test failure because of integer overflow here. Should I do</span>
<span class="line-removed"> 613     // &quot;safe subtraction&quot; everywhere in the code?  What&#39;s the nicest way to do it?</span>
 614     int position = safeSubtract(magnitude, scale);
 615 
<a name="21" id="anc21"></a><span class="line-modified"> 616     if (position &lt;= 0 &amp;&amp; !isApproximate) {</span>



 617         // All digits are to the left of the rounding magnitude.
 618     } else if (precision == 0) {
 619         // No rounding for zero.
 620     } else {
 621         // Perform rounding logic.
 622         // &quot;leading&quot; = most significant digit to the right of rounding
<a name="22" id="anc22"></a><span class="line-removed"> 623         // &quot;trailing&quot; = least significant digit to the left of rounding</span>
 624         int8_t leadingDigit = getDigitPos(safeSubtract(position, 1));
<a name="23" id="anc23"></a><span class="line-removed"> 625         int8_t trailingDigit = getDigitPos(position);</span>
 626 
 627         // Compute which section of the number we are in.
 628         // EDGE means we are at the bottom or top edge, like 1.000 or 1.999 (used by doubles)
 629         // LOWER means we are between the bottom edge and the midpoint, like 1.391
 630         // MIDPOINT means we are exactly in the middle, like 1.500
 631         // UPPER means we are between the midpoint and the top edge, like 1.916
<a name="24" id="anc24"></a><span class="line-modified"> 632         roundingutils::Section section = roundingutils::SECTION_MIDPOINT;</span>
 633         if (!isApproximate) {
<a name="25" id="anc25"></a><span class="line-modified"> 634             if (leadingDigit &lt; 5) {</span>
















 635                 section = roundingutils::SECTION_LOWER;
 636             } else if (leadingDigit &gt; 5) {
<a name="26" id="anc26"></a>
 637                 section = roundingutils::SECTION_UPPER;
 638             } else {
<a name="27" id="anc27"></a>

 639                 for (int p = safeSubtract(position, 2); p &gt;= 0; p--) {
 640                     if (getDigitPos(p) != 0) {
 641                         section = roundingutils::SECTION_UPPER;
 642                         break;
 643                     }
 644                 }
 645             }
 646         } else {
 647             int32_t p = safeSubtract(position, 2);
 648             int32_t minP = uprv_max(0, precision - 14);
<a name="28" id="anc28"></a><span class="line-modified"> 649             if (leadingDigit == 0) {</span>
 650                 section = roundingutils::SECTION_LOWER_EDGE;
 651                 for (; p &gt;= minP; p--) {
 652                     if (getDigitPos(p) != 0) {
 653                         section = roundingutils::SECTION_LOWER;
 654                         break;
 655                     }
 656                 }
<a name="29" id="anc29"></a><span class="line-modified"> 657             } else if (leadingDigit == 4) {</span>

 658                 for (; p &gt;= minP; p--) {
 659                     if (getDigitPos(p) != 9) {
 660                         section = roundingutils::SECTION_LOWER;
 661                         break;
 662                     }
 663                 }
<a name="30" id="anc30"></a><span class="line-modified"> 664             } else if (leadingDigit == 5) {</span>

 665                 for (; p &gt;= minP; p--) {
 666                     if (getDigitPos(p) != 0) {
 667                         section = roundingutils::SECTION_UPPER;
 668                         break;
 669                     }
 670                 }
<a name="31" id="anc31"></a><span class="line-modified"> 671             } else if (leadingDigit == 9) {</span>
 672                 section = roundingutils::SECTION_UPPER_EDGE;
 673                 for (; p &gt;= minP; p--) {
 674                     if (getDigitPos(p) != 9) {
 675                         section = roundingutils::SECTION_UPPER;
 676                         break;
 677                     }
 678                 }
<a name="32" id="anc32"></a>














 679             } else if (leadingDigit &lt; 5) {
<a name="33" id="anc33"></a>
 680                 section = roundingutils::SECTION_LOWER;
 681             } else {
<a name="34" id="anc34"></a>
 682                 section = roundingutils::SECTION_UPPER;
 683             }
 684 
 685             bool roundsAtMidpoint = roundingutils::roundsAtMidpoint(roundingMode);
 686             if (safeSubtract(position, 1) &lt; precision - 14 ||
 687                 (roundsAtMidpoint &amp;&amp; section == roundingutils::SECTION_MIDPOINT) ||
 688                 (!roundsAtMidpoint &amp;&amp; section &lt; 0 /* i.e. at upper or lower edge */)) {
<a name="35" id="anc35"></a><span class="line-modified"> 689                 // Oops! This means that we have to get the exact representation of the double, because</span>
<span class="line-modified"> 690                 // the zone of uncertainty is along the rounding boundary.</span>
 691                 convertToAccurateDouble();
<a name="36" id="anc36"></a><span class="line-modified"> 692                 roundToMagnitude(magnitude, roundingMode, status); // start over</span>
 693                 return;
 694             }
 695 
 696             // Turn off the approximate double flag, since the value is now confirmed to be exact.
 697             isApproximate = false;
 698             origDouble = 0.0;
 699             origDelta = 0;
 700 
<a name="37" id="anc37"></a><span class="line-modified"> 701             if (position &lt;= 0) {</span>
 702                 // All digits are to the left of the rounding magnitude.
 703                 return;
 704             }
 705 
 706             // Good to continue rounding.
 707             if (section == -1) { section = roundingutils::SECTION_LOWER; }
 708             if (section == -2) { section = roundingutils::SECTION_UPPER; }
 709         }
 710 
<a name="38" id="anc38"></a><span class="line-modified"> 711         bool roundDown = roundingutils::getRoundingDirection((trailingDigit % 2) == 0,</span>







 712                 isNegative(),
 713                 section,
 714                 roundingMode,
 715                 status);
 716         if (U_FAILURE(status)) {
 717             return;
 718         }
 719 
 720         // Perform truncation
 721         if (position &gt;= precision) {
 722             setBcdToZero();
 723             scale = magnitude;
 724         } else {
 725             shiftRight(position);
 726         }
 727 
<a name="39" id="anc39"></a>















 728         // Bubble the result to the higher digits
 729         if (!roundDown) {
 730             if (trailingDigit == 9) {
 731                 int bubblePos = 0;
<a name="40" id="anc40"></a><span class="line-modified"> 732                 // Note: in the long implementation, the most digits BCD can have at this point is 15,</span>
<span class="line-modified"> 733                 // so bubblePos &lt;= 15 and getDigitPos(bubblePos) is safe.</span>
 734                 for (; getDigitPos(bubblePos) == 9; bubblePos++) {}
 735                 shiftRight(bubblePos); // shift off the trailing 9s
 736             }
 737             int8_t digit0 = getDigitPos(0);
 738             U_ASSERT(digit0 != 9);
 739             setDigitPos(0, static_cast&lt;int8_t&gt;(digit0 + 1));
 740             precision += 1; // in case an extra digit got added
 741         }
 742 
 743         compact();
 744     }
 745 }
 746 
 747 void DecimalQuantity::roundToInfinity() {
 748     if (isApproximate) {
 749         convertToAccurateDouble();
 750     }
 751 }
 752 
 753 void DecimalQuantity::appendDigit(int8_t value, int32_t leadingZeros, bool appendAsInteger) {
 754     U_ASSERT(leadingZeros &gt;= 0);
 755 
 756     // Zero requires special handling to maintain the invariant that the least-significant digit
 757     // in the BCD is nonzero.
 758     if (value == 0) {
 759         if (appendAsInteger &amp;&amp; precision != 0) {
 760             scale += leadingZeros + 1;
 761         }
 762         return;
 763     }
 764 
 765     // Deal with trailing zeros
 766     if (scale &gt; 0) {
 767         leadingZeros += scale;
 768         if (appendAsInteger) {
 769             scale = 0;
 770         }
 771     }
 772 
 773     // Append digit
 774     shiftLeft(leadingZeros + 1);
 775     setDigitPos(0, value);
 776 
 777     // Fix scale if in integer mode
 778     if (appendAsInteger) {
 779         scale += leadingZeros + 1;
 780     }
 781 }
 782 
 783 UnicodeString DecimalQuantity::toPlainString() const {
 784     U_ASSERT(!isApproximate);
 785     UnicodeString sb;
 786     if (isNegative()) {
 787         sb.append(u&#39;-&#39;);
 788     }
 789     if (precision == 0 || getMagnitude() &lt; 0) {
 790         sb.append(u&#39;0&#39;);
 791     }
 792     for (int m = getUpperDisplayMagnitude(); m &gt;= getLowerDisplayMagnitude(); m--) {
 793         if (m == -1) { sb.append(u&#39;.&#39;); }
 794         sb.append(getDigit(m) + u&#39;0&#39;);
 795     }
 796     return sb;
 797 }
 798 
 799 UnicodeString DecimalQuantity::toScientificString() const {
 800     U_ASSERT(!isApproximate);
 801     UnicodeString result;
 802     if (isNegative()) {
 803         result.append(u&#39;-&#39;);
 804     }
 805     if (precision == 0) {
 806         result.append(u&quot;0E+0&quot;, -1);
 807         return result;
 808     }
<a name="41" id="anc41"></a><span class="line-modified"> 809     // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from</span>
<span class="line-modified"> 810     // rOptPos (aka -maxFrac) due to overflow.</span>
<span class="line-removed"> 811     int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;</span>
<span class="line-removed"> 812     int32_t lowerPos = std::max(scale, rOptPos) - scale;</span>
 813     int32_t p = upperPos;
 814     result.append(u&#39;0&#39; + getDigitPos(p));
 815     if ((--p) &gt;= lowerPos) {
 816         result.append(u&#39;.&#39;);
 817         for (; p &gt;= lowerPos; p--) {
 818             result.append(u&#39;0&#39; + getDigitPos(p));
 819         }
 820     }
 821     result.append(u&#39;E&#39;);
 822     int32_t _scale = upperPos + scale;
<a name="42" id="anc42"></a><span class="line-modified"> 823     if (_scale &lt; 0) {</span>



 824         _scale *= -1;
 825         result.append(u&#39;-&#39;);
 826     } else {
 827         result.append(u&#39;+&#39;);
 828     }
 829     if (_scale == 0) {
 830         result.append(u&#39;0&#39;);
 831     }
 832     int32_t insertIndex = result.length();
 833     while (_scale &gt; 0) {
 834         std::div_t res = std::div(_scale, 10);
 835         result.insert(insertIndex, u&#39;0&#39; + res.rem);
 836         _scale = res.quot;
 837     }
 838     return result;
 839 }
 840 
 841 ////////////////////////////////////////////////////
 842 /// End of DecimalQuantity_AbstractBCD.java      ///
 843 /// Start of DecimalQuantity_DualStorageBCD.java ///
 844 ////////////////////////////////////////////////////
 845 
 846 int8_t DecimalQuantity::getDigitPos(int32_t position) const {
 847     if (usingBytes) {
 848         if (position &lt; 0 || position &gt;= precision) { return 0; }
 849         return fBCD.bcdBytes.ptr[position];
 850     } else {
 851         if (position &lt; 0 || position &gt;= 16) { return 0; }
 852         return (int8_t) ((fBCD.bcdLong &gt;&gt; (position * 4)) &amp; 0xf);
 853     }
 854 }
 855 
 856 void DecimalQuantity::setDigitPos(int32_t position, int8_t value) {
 857     U_ASSERT(position &gt;= 0);
 858     if (usingBytes) {
 859         ensureCapacity(position + 1);
 860         fBCD.bcdBytes.ptr[position] = value;
 861     } else if (position &gt;= 16) {
 862         switchStorage();
 863         ensureCapacity(position + 1);
 864         fBCD.bcdBytes.ptr[position] = value;
 865     } else {
 866         int shift = position * 4;
 867         fBCD.bcdLong = (fBCD.bcdLong &amp; ~(0xfL &lt;&lt; shift)) | ((long) value &lt;&lt; shift);
 868     }
 869 }
 870 
 871 void DecimalQuantity::shiftLeft(int32_t numDigits) {
 872     if (!usingBytes &amp;&amp; precision + numDigits &gt; 16) {
 873         switchStorage();
 874     }
 875     if (usingBytes) {
 876         ensureCapacity(precision + numDigits);
 877         int i = precision + numDigits - 1;
 878         for (; i &gt;= numDigits; i--) {
 879             fBCD.bcdBytes.ptr[i] = fBCD.bcdBytes.ptr[i - numDigits];
 880         }
 881         for (; i &gt;= 0; i--) {
 882             fBCD.bcdBytes.ptr[i] = 0;
 883         }
 884     } else {
 885         fBCD.bcdLong &lt;&lt;= (numDigits * 4);
 886     }
 887     scale -= numDigits;
 888     precision += numDigits;
 889 }
 890 
 891 void DecimalQuantity::shiftRight(int32_t numDigits) {
 892     if (usingBytes) {
 893         int i = 0;
 894         for (; i &lt; precision - numDigits; i++) {
 895             fBCD.bcdBytes.ptr[i] = fBCD.bcdBytes.ptr[i + numDigits];
 896         }
 897         for (; i &lt; precision; i++) {
 898             fBCD.bcdBytes.ptr[i] = 0;
 899         }
 900     } else {
 901         fBCD.bcdLong &gt;&gt;= (numDigits * 4);
 902     }
 903     scale += numDigits;
 904     precision -= numDigits;
 905 }
 906 
<a name="43" id="anc43"></a>












 907 void DecimalQuantity::setBcdToZero() {
 908     if (usingBytes) {
 909         uprv_free(fBCD.bcdBytes.ptr);
 910         fBCD.bcdBytes.ptr = nullptr;
 911         usingBytes = false;
 912     }
 913     fBCD.bcdLong = 0L;
 914     scale = 0;
 915     precision = 0;
 916     isApproximate = false;
 917     origDouble = 0;
 918     origDelta = 0;
 919 }
 920 
 921 void DecimalQuantity::readIntToBcd(int32_t n) {
 922     U_ASSERT(n != 0);
 923     // ints always fit inside the long implementation.
 924     uint64_t result = 0L;
 925     int i = 16;
 926     for (; n != 0; n /= 10, i--) {
 927         result = (result &gt;&gt; 4) + ((static_cast&lt;uint64_t&gt;(n) % 10) &lt;&lt; 60);
 928     }
 929     U_ASSERT(!usingBytes);
 930     fBCD.bcdLong = result &gt;&gt; (i * 4);
 931     scale = 0;
 932     precision = 16 - i;
 933 }
 934 
 935 void DecimalQuantity::readLongToBcd(int64_t n) {
 936     U_ASSERT(n != 0);
 937     if (n &gt;= 10000000000000000L) {
 938         ensureCapacity();
 939         int i = 0;
 940         for (; n != 0L; n /= 10L, i++) {
 941             fBCD.bcdBytes.ptr[i] = static_cast&lt;int8_t&gt;(n % 10);
 942         }
 943         U_ASSERT(usingBytes);
 944         scale = 0;
 945         precision = i;
 946     } else {
 947         uint64_t result = 0L;
 948         int i = 16;
 949         for (; n != 0L; n /= 10L, i--) {
 950             result = (result &gt;&gt; 4) + ((n % 10) &lt;&lt; 60);
 951         }
 952         U_ASSERT(i &gt;= 0);
 953         U_ASSERT(!usingBytes);
 954         fBCD.bcdLong = result &gt;&gt; (i * 4);
 955         scale = 0;
 956         precision = 16 - i;
 957     }
 958 }
 959 
 960 void DecimalQuantity::readDecNumberToBcd(const DecNum&amp; decnum) {
 961     const decNumber* dn = decnum.getRawDecNumber();
 962     if (dn-&gt;digits &gt; 16) {
 963         ensureCapacity(dn-&gt;digits);
 964         for (int32_t i = 0; i &lt; dn-&gt;digits; i++) {
 965             fBCD.bcdBytes.ptr[i] = dn-&gt;lsu[i];
 966         }
 967     } else {
 968         uint64_t result = 0L;
 969         for (int32_t i = 0; i &lt; dn-&gt;digits; i++) {
 970             result |= static_cast&lt;uint64_t&gt;(dn-&gt;lsu[i]) &lt;&lt; (4 * i);
 971         }
 972         fBCD.bcdLong = result;
 973     }
 974     scale = dn-&gt;exponent;
 975     precision = dn-&gt;digits;
 976 }
 977 
 978 void DecimalQuantity::readDoubleConversionToBcd(
 979         const char* buffer, int32_t length, int32_t point) {
 980     // NOTE: Despite the fact that double-conversion&#39;s API is called
 981     // &quot;DoubleToAscii&quot;, they actually use &#39;0&#39; (as opposed to u8&#39;0&#39;).
 982     if (length &gt; 16) {
 983         ensureCapacity(length);
 984         for (int32_t i = 0; i &lt; length; i++) {
 985             fBCD.bcdBytes.ptr[i] = buffer[length-i-1] - &#39;0&#39;;
 986         }
 987     } else {
 988         uint64_t result = 0L;
 989         for (int32_t i = 0; i &lt; length; i++) {
 990             result |= static_cast&lt;uint64_t&gt;(buffer[length-i-1] - &#39;0&#39;) &lt;&lt; (4 * i);
 991         }
 992         fBCD.bcdLong = result;
 993     }
 994     scale = point - length;
 995     precision = length;
 996 }
 997 
 998 void DecimalQuantity::compact() {
 999     if (usingBytes) {
1000         int32_t delta = 0;
1001         for (; delta &lt; precision &amp;&amp; fBCD.bcdBytes.ptr[delta] == 0; delta++);
1002         if (delta == precision) {
1003             // Number is zero
1004             setBcdToZero();
1005             return;
1006         } else {
1007             // Remove trailing zeros
1008             shiftRight(delta);
1009         }
1010 
1011         // Compute precision
1012         int32_t leading = precision - 1;
1013         for (; leading &gt;= 0 &amp;&amp; fBCD.bcdBytes.ptr[leading] == 0; leading--);
1014         precision = leading + 1;
1015 
1016         // Switch storage mechanism if possible
1017         if (precision &lt;= 16) {
1018             switchStorage();
1019         }
1020 
1021     } else {
1022         if (fBCD.bcdLong == 0L) {
1023             // Number is zero
1024             setBcdToZero();
1025             return;
1026         }
1027 
1028         // Compact the number (remove trailing zeros)
1029         // TODO: Use a more efficient algorithm here and below. There is a logarithmic one.
1030         int32_t delta = 0;
1031         for (; delta &lt; precision &amp;&amp; getDigitPos(delta) == 0; delta++);
1032         fBCD.bcdLong &gt;&gt;= delta * 4;
1033         scale += delta;
1034 
1035         // Compute precision
1036         int32_t leading = precision - 1;
1037         for (; leading &gt;= 0 &amp;&amp; getDigitPos(leading) == 0; leading--);
1038         precision = leading + 1;
1039     }
1040 }
1041 
1042 void DecimalQuantity::ensureCapacity() {
1043     ensureCapacity(40);
1044 }
1045 
1046 void DecimalQuantity::ensureCapacity(int32_t capacity) {
1047     if (capacity == 0) { return; }
1048     int32_t oldCapacity = usingBytes ? fBCD.bcdBytes.len : 0;
1049     if (!usingBytes) {
1050         // TODO: There is nothing being done to check for memory allocation failures.
1051         // TODO: Consider indexing by nybbles instead of bytes in C++, so that we can
1052         // make these arrays half the size.
1053         fBCD.bcdBytes.ptr = static_cast&lt;int8_t*&gt;(uprv_malloc(capacity * sizeof(int8_t)));
1054         fBCD.bcdBytes.len = capacity;
1055         // Initialize the byte array to zeros (this is done automatically in Java)
1056         uprv_memset(fBCD.bcdBytes.ptr, 0, capacity * sizeof(int8_t));
1057     } else if (oldCapacity &lt; capacity) {
1058         auto bcd1 = static_cast&lt;int8_t*&gt;(uprv_malloc(capacity * 2 * sizeof(int8_t)));
1059         uprv_memcpy(bcd1, fBCD.bcdBytes.ptr, oldCapacity * sizeof(int8_t));
1060         // Initialize the rest of the byte array to zeros (this is done automatically in Java)
1061         uprv_memset(bcd1 + oldCapacity, 0, (capacity - oldCapacity) * sizeof(int8_t));
1062         uprv_free(fBCD.bcdBytes.ptr);
1063         fBCD.bcdBytes.ptr = bcd1;
1064         fBCD.bcdBytes.len = capacity * 2;
1065     }
1066     usingBytes = true;
1067 }
1068 
1069 void DecimalQuantity::switchStorage() {
1070     if (usingBytes) {
1071         // Change from bytes to long
1072         uint64_t bcdLong = 0L;
1073         for (int i = precision - 1; i &gt;= 0; i--) {
1074             bcdLong &lt;&lt;= 4;
1075             bcdLong |= fBCD.bcdBytes.ptr[i];
1076         }
1077         uprv_free(fBCD.bcdBytes.ptr);
1078         fBCD.bcdBytes.ptr = nullptr;
1079         fBCD.bcdLong = bcdLong;
1080         usingBytes = false;
1081     } else {
1082         // Change from long to bytes
1083         // Copy the long into a local variable since it will get munged when we allocate the bytes
1084         uint64_t bcdLong = fBCD.bcdLong;
1085         ensureCapacity();
1086         for (int i = 0; i &lt; precision; i++) {
1087             fBCD.bcdBytes.ptr[i] = static_cast&lt;int8_t&gt;(bcdLong &amp; 0xf);
1088             bcdLong &gt;&gt;= 4;
1089         }
1090         U_ASSERT(usingBytes);
1091     }
1092 }
1093 
1094 void DecimalQuantity::copyBcdFrom(const DecimalQuantity &amp;other) {
1095     setBcdToZero();
1096     if (other.usingBytes) {
1097         ensureCapacity(other.precision);
1098         uprv_memcpy(fBCD.bcdBytes.ptr, other.fBCD.bcdBytes.ptr, other.precision * sizeof(int8_t));
1099     } else {
1100         fBCD.bcdLong = other.fBCD.bcdLong;
1101     }
1102 }
1103 
1104 void DecimalQuantity::moveBcdFrom(DecimalQuantity &amp;other) {
1105     setBcdToZero();
1106     if (other.usingBytes) {
1107         usingBytes = true;
1108         fBCD.bcdBytes.ptr = other.fBCD.bcdBytes.ptr;
1109         fBCD.bcdBytes.len = other.fBCD.bcdBytes.len;
1110         // Take ownership away from the old instance:
1111         other.fBCD.bcdBytes.ptr = nullptr;
1112         other.usingBytes = false;
1113     } else {
1114         fBCD.bcdLong = other.fBCD.bcdLong;
1115     }
1116 }
1117 
1118 const char16_t* DecimalQuantity::checkHealth() const {
1119     if (usingBytes) {
1120         if (precision == 0) { return u&quot;Zero precision but we are in byte mode&quot;; }
1121         int32_t capacity = fBCD.bcdBytes.len;
1122         if (precision &gt; capacity) { return u&quot;Precision exceeds length of byte array&quot;; }
1123         if (getDigitPos(precision - 1) == 0) { return u&quot;Most significant digit is zero in byte mode&quot;; }
1124         if (getDigitPos(0) == 0) { return u&quot;Least significant digit is zero in long mode&quot;; }
1125         for (int i = 0; i &lt; precision; i++) {
1126             if (getDigitPos(i) &gt;= 10) { return u&quot;Digit exceeding 10 in byte array&quot;; }
1127             if (getDigitPos(i) &lt; 0) { return u&quot;Digit below 0 in byte array&quot;; }
1128         }
1129         for (int i = precision; i &lt; capacity; i++) {
1130             if (getDigitPos(i) != 0) { return u&quot;Nonzero digits outside of range in byte array&quot;; }
1131         }
1132     } else {
1133         if (precision == 0 &amp;&amp; fBCD.bcdLong != 0) {
1134             return u&quot;Value in bcdLong even though precision is zero&quot;;
1135         }
1136         if (precision &gt; 16) { return u&quot;Precision exceeds length of long&quot;; }
1137         if (precision != 0 &amp;&amp; getDigitPos(precision - 1) == 0) {
1138             return u&quot;Most significant digit is zero in long mode&quot;;
1139         }
1140         if (precision != 0 &amp;&amp; getDigitPos(0) == 0) {
1141             return u&quot;Least significant digit is zero in long mode&quot;;
1142         }
1143         for (int i = 0; i &lt; precision; i++) {
1144             if (getDigitPos(i) &gt;= 10) { return u&quot;Digit exceeding 10 in long&quot;; }
1145             if (getDigitPos(i) &lt; 0) { return u&quot;Digit below 0 in long (?!)&quot;; }
1146         }
1147         for (int i = precision; i &lt; 16; i++) {
1148             if (getDigitPos(i) != 0) { return u&quot;Nonzero digits outside of range in long&quot;; }
1149         }
1150     }
1151 
1152     // No error
1153     return nullptr;
1154 }
1155 
1156 bool DecimalQuantity::operator==(const DecimalQuantity&amp; other) const {
<a name="44" id="anc44"></a><span class="line-modified">1157     // FIXME: Make a faster implementation.</span>
<span class="line-modified">1158     return toString() == other.toString();</span>





















1159 }
1160 
1161 UnicodeString DecimalQuantity::toString() const {
1162     MaybeStackArray&lt;char, 30&gt; digits(precision + 1);
1163     for (int32_t i = 0; i &lt; precision; i++) {
1164         digits[i] = getDigitPos(precision - i - 1) + &#39;0&#39;;
1165     }
1166     digits[precision] = 0; // terminate buffer
1167     char buffer8[100];
1168     snprintf(
1169             buffer8,
1170             sizeof(buffer8),
<a name="45" id="anc45"></a><span class="line-modified">1171             &quot;&lt;DecimalQuantity %d:%d:%d:%d %s %s%s%s%d&gt;&quot;,</span>
<span class="line-removed">1172             (lOptPos &gt; 999 ? 999 : lOptPos),</span>
1173             lReqPos,
1174             rReqPos,
<a name="46" id="anc46"></a><span class="line-removed">1175             (rOptPos &lt; -999 ? -999 : rOptPos),</span>
1176             (usingBytes ? &quot;bytes&quot; : &quot;long&quot;),
1177             (isNegative() ? &quot;-&quot; : &quot;&quot;),
1178             (precision == 0 ? &quot;0&quot; : digits.getAlias()),
1179             &quot;E&quot;,
1180             scale);
1181     return UnicodeString(buffer8, -1, US_INV);
1182 }
1183 
1184 #endif /* #if !UCONFIG_NO_FORMATTING */
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>