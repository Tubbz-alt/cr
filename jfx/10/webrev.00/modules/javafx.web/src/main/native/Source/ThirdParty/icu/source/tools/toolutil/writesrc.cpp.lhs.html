<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/writesrc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // © 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 *
  6 *   Copyright (C) 2005-2012, International Business Machines
  7 *   Corporation and others.  All Rights Reserved.
  8 *
  9 *******************************************************************************
 10 *   file name:  writesrc.c
 11 *   encoding:   UTF-8
 12 *   tab size:   8 (not used)
 13 *   indentation:4
 14 *
 15 *   created on: 2005apr23
 16 *   created by: Markus W. Scherer
 17 *
 18 *   Helper functions for writing source code for data.
 19 */
 20 
 21 #include &lt;stdio.h&gt;
 22 #include &lt;time.h&gt;
 23 #include &quot;unicode/utypes.h&quot;
 24 #include &quot;unicode/putil.h&quot;
<a name="1" id="anc1"></a>
 25 #include &quot;utrie2.h&quot;
 26 #include &quot;cstring.h&quot;
 27 #include &quot;writesrc.h&quot;
 28 
 29 static FILE *
 30 usrc_createWithHeader(const char *path, const char *filename,
<a name="2" id="anc2"></a><span class="line-modified"> 31                       const char *generator, const char *header) {</span>
 32     char buffer[1024];
 33     const char *p;
 34     char *q;
 35     FILE *f;
 36     char c;
 37 
 38     if(path==NULL) {
 39         p=filename;
 40     } else {
 41         /* concatenate path and filename, with U_FILE_SEP_CHAR in between if necessary */
 42         uprv_strcpy(buffer, path);
 43         q=buffer+uprv_strlen(buffer);
 44         if(q&gt;buffer &amp;&amp; (c=*(q-1))!=U_FILE_SEP_CHAR &amp;&amp; c!=U_FILE_ALT_SEP_CHAR) {
 45             *q++=U_FILE_SEP_CHAR;
 46         }
 47         uprv_strcpy(q, filename);
 48         p=buffer;
 49     }
 50 
 51     f=fopen(p, &quot;w&quot;);
 52     if(f!=NULL) {
 53         const struct tm *lt;
 54         time_t t;
 55 
 56         time(&amp;t);
 57         lt=localtime(&amp;t);
 58         if(generator==NULL) {
 59             strftime(buffer, sizeof(buffer), &quot;%Y-%m-%d&quot;, lt);
 60             fprintf(f, header, filename, buffer);
 61         } else {
 62             fprintf(f, header, filename, generator);
 63         }
 64     } else {
 65         fprintf(
 66             stderr,
 67             &quot;usrc_create(%s, %s): unable to create file\n&quot;,
 68             path!=NULL ? path : &quot;&quot;, filename);
 69     }
 70     return f;
 71 }
 72 
 73 U_CAPI FILE * U_EXPORT2
<a name="3" id="anc3"></a><span class="line-modified"> 74 usrc_create(const char *path, const char *filename, const char *generator) {</span>
<span class="line-modified"> 75     // TODO: Add parameter for the first year this file was generated, not before 2016.</span>
<span class="line-modified"> 76     static const char *header=</span>
<span class="line-modified"> 77         &quot;// © 2016 and later: Unicode, Inc. and others.\n&quot;</span>
<span class="line-modified"> 78         &quot;// License &amp; terms of use: http://www.unicode.org/copyright.html\n&quot;</span>
<span class="line-modified"> 79         &quot;//\n&quot;</span>
<span class="line-modified"> 80         &quot;// Copyright (C) 1999-2016, International Business Machines\n&quot;</span>
<span class="line-modified"> 81         &quot;// Corporation and others.  All Rights Reserved.\n&quot;</span>
<span class="line-modified"> 82         &quot;//\n&quot;</span>
<span class="line-modified"> 83         &quot;// file name: %s\n&quot;</span>
<span class="line-modified"> 84         &quot;//\n&quot;</span>
<span class="line-modified"> 85         &quot;// machine-generated by: %s\n&quot;</span>
<span class="line-modified"> 86         &quot;\n\n&quot;;</span>
<span class="line-modified"> 87     return usrc_createWithHeader(path, filename, generator, header);</span>














 88 }
 89 
 90 U_CAPI FILE * U_EXPORT2
 91 usrc_createTextData(const char *path, const char *filename, const char *generator) {
 92     // TODO: Add parameter for the first year this file was generated, not before 2016.
 93     static const char *header=
 94         &quot;# Copyright (C) 2016 and later: Unicode, Inc. and others.\n&quot;
 95         &quot;# License &amp; terms of use: http://www.unicode.org/copyright.html\n&quot;
 96         &quot;# Copyright (C) 1999-2016, International Business Machines\n&quot;
 97         &quot;# Corporation and others.  All Rights Reserved.\n&quot;
 98         &quot;#\n&quot;
 99         &quot;# file name: %s\n&quot;
100         &quot;#\n&quot;
101         &quot;# machine-generated by: %s\n&quot;
102         &quot;\n\n&quot;;
<a name="4" id="anc4"></a><span class="line-modified">103     return usrc_createWithHeader(path, filename, generator, header);</span>
104 }
105 
106 U_CAPI void U_EXPORT2
107 usrc_writeArray(FILE *f,
108                 const char *prefix,
109                 const void *p, int32_t width, int32_t length,
110                 const char *postfix) {
111     const uint8_t *p8;
112     const uint16_t *p16;
113     const uint32_t *p32;
114     uint32_t value;
115     int32_t i, col;
116 
117     p8=NULL;
118     p16=NULL;
119     p32=NULL;
120     switch(width) {
121     case 8:
122         p8=(const uint8_t *)p;
123         break;
124     case 16:
125         p16=(const uint16_t *)p;
126         break;
127     case 32:
128         p32=(const uint32_t *)p;
129         break;
130     default:
131         fprintf(stderr, &quot;usrc_writeArray(width=%ld) unrecognized width\n&quot;, (long)width);
132         return;
133     }
134     if(prefix!=NULL) {
135         fprintf(f, prefix, (long)length);
136     }
137     for(i=col=0; i&lt;length; ++i, ++col) {
138         if(i&gt;0) {
139             if(col&lt;16) {
140                 fputc(&#39;,&#39;, f);
141             } else {
142                 fputs(&quot;,\n&quot;, f);
143                 col=0;
144             }
145         }
146         switch(width) {
147         case 8:
148             value=p8[i];
149             break;
150         case 16:
151             value=p16[i];
152             break;
153         case 32:
154             value=p32[i];
155             break;
156         default:
157             value=0; /* unreachable */
158             break;
159         }
160         fprintf(f, value&lt;=9 ? &quot;%lu&quot; : &quot;0x%lx&quot;, (unsigned long)value);
161     }
162     if(postfix!=NULL) {
163         fputs(postfix, f);
164     }
165 }
166 
167 U_CAPI void U_EXPORT2
168 usrc_writeUTrie2Arrays(FILE *f,
169                        const char *indexPrefix, const char *data32Prefix,
170                        const UTrie2 *pTrie,
171                        const char *postfix) {
172     if(pTrie-&gt;data32==NULL) {
173         /* 16-bit trie */
174         usrc_writeArray(f, indexPrefix, pTrie-&gt;index, 16, pTrie-&gt;indexLength+pTrie-&gt;dataLength, postfix);
175     } else {
176         /* 32-bit trie */
177         usrc_writeArray(f, indexPrefix, pTrie-&gt;index, 16, pTrie-&gt;indexLength, postfix);
178         usrc_writeArray(f, data32Prefix, pTrie-&gt;data32, 32, pTrie-&gt;dataLength, postfix);
179     }
180 }
181 
182 U_CAPI void U_EXPORT2
183 usrc_writeUTrie2Struct(FILE *f,
184                        const char *prefix,
185                        const UTrie2 *pTrie,
186                        const char *indexName, const char *data32Name,
187                        const char *postfix) {
188     if(prefix!=NULL) {
189         fputs(prefix, f);
190     }
191     if(pTrie-&gt;data32==NULL) {
192         /* 16-bit trie */
193         fprintf(
194             f,
195             &quot;    %s,\n&quot;         /* index */
196             &quot;    %s+%ld,\n&quot;     /* data16 */
197             &quot;    NULL,\n&quot;,      /* data32 */
198             indexName,
199             indexName,
200             (long)pTrie-&gt;indexLength);
201     } else {
202         /* 32-bit trie */
203         fprintf(
204             f,
205             &quot;    %s,\n&quot;         /* index */
206             &quot;    NULL,\n&quot;       /* data16 */
207             &quot;    %s,\n&quot;,        /* data32 */
208             indexName,
209             data32Name);
210     }
211     fprintf(
212         f,
213         &quot;    %ld,\n&quot;            /* indexLength */
214         &quot;    %ld,\n&quot;            /* dataLength */
215         &quot;    0x%hx,\n&quot;          /* index2NullOffset */
216         &quot;    0x%hx,\n&quot;          /* dataNullOffset */
217         &quot;    0x%lx,\n&quot;          /* initialValue */
218         &quot;    0x%lx,\n&quot;          /* errorValue */
219         &quot;    0x%lx,\n&quot;          /* highStart */
220         &quot;    0x%lx,\n&quot;          /* highValueIndex */
221         &quot;    NULL, 0, FALSE, FALSE, 0, NULL\n&quot;,
222         (long)pTrie-&gt;indexLength, (long)pTrie-&gt;dataLength,
223         (short)pTrie-&gt;index2NullOffset, (short)pTrie-&gt;dataNullOffset,
224         (long)pTrie-&gt;initialValue, (long)pTrie-&gt;errorValue,
225         (long)pTrie-&gt;highStart, (long)pTrie-&gt;highValueIndex);
226     if(postfix!=NULL) {
227         fputs(postfix, f);
228     }
229 }
230 
<a name="5" id="anc5"></a>





























































231 U_CAPI void U_EXPORT2
232 usrc_writeArrayOfMostlyInvChars(FILE *f,
233                                 const char *prefix,
234                                 const char *p, int32_t length,
235                                 const char *postfix) {
236     int32_t i, col;
237     int prev2, prev, c;
238 
239     if(prefix!=NULL) {
240         fprintf(f, prefix, (long)length);
241     }
242     prev2=prev=-1;
243     for(i=col=0; i&lt;length; ++i, ++col) {
244         c=(uint8_t)p[i];
245         if(i&gt;0) {
246             /* Break long lines. Try to break at interesting places, to minimize revision diffs. */
247             if(
248                 /* Very long line. */
249                 col&gt;=32 ||
250                 /* Long line, break after terminating NUL. */
251                 (col&gt;=24 &amp;&amp; prev2&gt;=0x20 &amp;&amp; prev==0) ||
252                 /* Medium-long line, break before non-NUL, non-character byte. */
253                 (col&gt;=16 &amp;&amp; (prev==0 || prev&gt;=0x20) &amp;&amp; 0&lt;c &amp;&amp; c&lt;0x20)
254             ) {
255                 fputs(&quot;,\n&quot;, f);
256                 col=0;
257             } else {
258                 fputc(&#39;,&#39;, f);
259             }
260         }
261         fprintf(f, c&lt;0x20 ? &quot;%u&quot; : &quot;&#39;%c&#39;&quot;, c);
262         prev2=prev;
263         prev=c;
264     }
265     if(postfix!=NULL) {
266         fputs(postfix, f);
267     }
268 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>