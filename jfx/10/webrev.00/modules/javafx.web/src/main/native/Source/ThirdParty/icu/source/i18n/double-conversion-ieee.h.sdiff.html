<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/double-conversion-ieee.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="double-conversion-cached-powers.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion-utils.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/double-conversion-ieee.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
254     if (exponent &gt;= kMaxExponent) {
255       return kInfinity;
256     }
257     if (exponent &lt; kDenormalExponent) {
258       return 0;
259     }
260     while (exponent &gt; kDenormalExponent &amp;&amp; (significand &amp; kHiddenBit) == 0) {
261       significand &lt;&lt;= 1;
262       exponent--;
263     }
264     uint64_t biased_exponent;
265     if (exponent == kDenormalExponent &amp;&amp; (significand &amp; kHiddenBit) == 0) {
266       biased_exponent = 0;
267     } else {
268       biased_exponent = static_cast&lt;uint64_t&gt;(exponent + kExponentBias);
269     }
270     return (significand &amp; kSignificandMask) |
271         (biased_exponent &lt;&lt; kPhysicalSignificandSize);
272   }
273 
<span class="line-modified">274   DISALLOW_COPY_AND_ASSIGN(Double);</span>
275 };
276 
277 class Single {
278  public:
279   static const uint32_t kSignMask = 0x80000000;
280   static const uint32_t kExponentMask = 0x7F800000;
281   static const uint32_t kSignificandMask = 0x007FFFFF;
282   static const uint32_t kHiddenBit = 0x00800000;
283   static const int kPhysicalSignificandSize = 23;  // Excludes the hidden bit.
284   static const int kSignificandSize = 24;
285 
286   Single() : d32_(0) {}
287   explicit Single(float f) : d32_(float_to_uint32(f)) {}
288   explicit Single(uint32_t d32) : d32_(d32) {}
289 
290   // The value encoded by this Single must be greater or equal to +0.0.
291   // It must not be special (infinity, or NaN).
292   DiyFp AsDiyFp() const {
293     ASSERT(Sign() &gt; 0);
294     ASSERT(!IsSpecial());
</pre>
<hr />
<pre>
391 
392   float value() const { return uint32_to_float(d32_); }
393 
394   static float Infinity() {
395     return Single(kInfinity).value();
396   }
397 
398   static float NaN() {
399     return Single(kNaN).value();
400   }
401 
402  private:
403   static const int kExponentBias = 0x7F + kPhysicalSignificandSize;
404   static const int kDenormalExponent = -kExponentBias + 1;
405   static const int kMaxExponent = 0xFF - kExponentBias;
406   static const uint32_t kInfinity = 0x7F800000;
407   static const uint32_t kNaN = 0x7FC00000;
408 
409   const uint32_t d32_;
410 
<span class="line-modified">411   DISALLOW_COPY_AND_ASSIGN(Single);</span>
412 };
413 
414 }  // namespace double_conversion
415 
416 // ICU PATCH: Close ICU namespace
417 U_NAMESPACE_END
418 
419 #endif  // DOUBLE_CONVERSION_DOUBLE_H_
420 #endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING
</pre>
</td>
<td>
<hr />
<pre>
254     if (exponent &gt;= kMaxExponent) {
255       return kInfinity;
256     }
257     if (exponent &lt; kDenormalExponent) {
258       return 0;
259     }
260     while (exponent &gt; kDenormalExponent &amp;&amp; (significand &amp; kHiddenBit) == 0) {
261       significand &lt;&lt;= 1;
262       exponent--;
263     }
264     uint64_t biased_exponent;
265     if (exponent == kDenormalExponent &amp;&amp; (significand &amp; kHiddenBit) == 0) {
266       biased_exponent = 0;
267     } else {
268       biased_exponent = static_cast&lt;uint64_t&gt;(exponent + kExponentBias);
269     }
270     return (significand &amp; kSignificandMask) |
271         (biased_exponent &lt;&lt; kPhysicalSignificandSize);
272   }
273 
<span class="line-modified">274   DC_DISALLOW_COPY_AND_ASSIGN(Double);</span>
275 };
276 
277 class Single {
278  public:
279   static const uint32_t kSignMask = 0x80000000;
280   static const uint32_t kExponentMask = 0x7F800000;
281   static const uint32_t kSignificandMask = 0x007FFFFF;
282   static const uint32_t kHiddenBit = 0x00800000;
283   static const int kPhysicalSignificandSize = 23;  // Excludes the hidden bit.
284   static const int kSignificandSize = 24;
285 
286   Single() : d32_(0) {}
287   explicit Single(float f) : d32_(float_to_uint32(f)) {}
288   explicit Single(uint32_t d32) : d32_(d32) {}
289 
290   // The value encoded by this Single must be greater or equal to +0.0.
291   // It must not be special (infinity, or NaN).
292   DiyFp AsDiyFp() const {
293     ASSERT(Sign() &gt; 0);
294     ASSERT(!IsSpecial());
</pre>
<hr />
<pre>
391 
392   float value() const { return uint32_to_float(d32_); }
393 
394   static float Infinity() {
395     return Single(kInfinity).value();
396   }
397 
398   static float NaN() {
399     return Single(kNaN).value();
400   }
401 
402  private:
403   static const int kExponentBias = 0x7F + kPhysicalSignificandSize;
404   static const int kDenormalExponent = -kExponentBias + 1;
405   static const int kMaxExponent = 0xFF - kExponentBias;
406   static const uint32_t kInfinity = 0x7F800000;
407   static const uint32_t kNaN = 0x7FC00000;
408 
409   const uint32_t d32_;
410 
<span class="line-modified">411   DC_DISALLOW_COPY_AND_ASSIGN(Single);</span>
412 };
413 
414 }  // namespace double_conversion
415 
416 // ICU PATCH: Close ICU namespace
417 U_NAMESPACE_END
418 
419 #endif  // DOUBLE_CONVERSION_DOUBLE_H_
420 #endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING
</pre>
</td>
</tr>
</table>
<center><a href="double-conversion-cached-powers.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion-utils.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>