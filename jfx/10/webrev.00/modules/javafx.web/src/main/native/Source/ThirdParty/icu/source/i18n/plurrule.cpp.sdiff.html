<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/plurrule.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="plurfmt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="plurrule_impl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/plurrule.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18 #include &quot;unicode/upluralrules.h&quot;
  19 #include &quot;unicode/ures.h&quot;
  20 #include &quot;unicode/numfmt.h&quot;
  21 #include &quot;unicode/decimfmt.h&quot;
  22 #include &quot;charstr.h&quot;
  23 #include &quot;cmemory.h&quot;
  24 #include &quot;cstring.h&quot;
  25 #include &quot;hash.h&quot;
  26 #include &quot;locutil.h&quot;
  27 #include &quot;mutex.h&quot;
  28 #include &quot;patternprops.h&quot;
  29 #include &quot;plurrule_impl.h&quot;
  30 #include &quot;putilimp.h&quot;
  31 #include &quot;ucln_in.h&quot;
  32 #include &quot;ustrfmt.h&quot;
  33 #include &quot;uassert.h&quot;
  34 #include &quot;uvectr32.h&quot;
  35 #include &quot;sharedpluralrules.h&quot;
  36 #include &quot;unifiedcache.h&quot;
  37 #include &quot;number_decimalquantity.h&quot;

  38 
  39 #if !UCONFIG_NO_FORMATTING
  40 
  41 U_NAMESPACE_BEGIN
  42 
  43 using namespace icu::pluralimpl;
  44 using icu::number::impl::DecimalQuantity;
  45 
  46 static const UChar PLURAL_KEYWORD_OTHER[]={LOW_O,LOW_T,LOW_H,LOW_E,LOW_R,0};
  47 static const UChar PLURAL_DEFAULT_RULE[]={LOW_O,LOW_T,LOW_H,LOW_E,LOW_R,COLON,SPACE,LOW_N,0};
  48 static const UChar PK_IN[]={LOW_I,LOW_N,0};
  49 static const UChar PK_NOT[]={LOW_N,LOW_O,LOW_T,0};
  50 static const UChar PK_IS[]={LOW_I,LOW_S,0};
  51 static const UChar PK_MOD[]={LOW_M,LOW_O,LOW_D,0};
  52 static const UChar PK_AND[]={LOW_A,LOW_N,LOW_D,0};
  53 static const UChar PK_OR[]={LOW_O,LOW_R,0};
  54 static const UChar PK_VAR_N[]={LOW_N,0};
  55 static const UChar PK_VAR_I[]={LOW_I,0};
  56 static const UChar PK_VAR_F[]={LOW_F,0};
  57 static const UChar PK_VAR_T[]={LOW_T,0};
  58 static const UChar PK_VAR_V[]={LOW_V,0};
  59 static const UChar PK_WITHIN[]={LOW_W,LOW_I,LOW_T,LOW_H,LOW_I,LOW_N,0};
  60 static const UChar PK_DECIMAL[]={LOW_D,LOW_E,LOW_C,LOW_I,LOW_M,LOW_A,LOW_L,0};
  61 static const UChar PK_INTEGER[]={LOW_I,LOW_N,LOW_T,LOW_E,LOW_G,LOW_E,LOW_R,0};
  62 
  63 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(PluralRules)
  64 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(PluralKeywordEnumeration)
  65 
  66 PluralRules::PluralRules(UErrorCode&amp; /*status*/)
  67 :   UObject(),
<span class="line-modified">  68     mRules(NULL)</span>

  69 {
  70 }
  71 
  72 PluralRules::PluralRules(const PluralRules&amp; other)
  73 : UObject(other),
<span class="line-modified">  74     mRules(NULL)</span>

  75 {
  76     *this=other;
  77 }
  78 
  79 PluralRules::~PluralRules() {
  80     delete mRules;
  81 }
  82 
  83 SharedPluralRules::~SharedPluralRules() {
  84     delete ptr;
  85 }
  86 
  87 PluralRules*
  88 PluralRules::clone() const {
<span class="line-modified">  89     return new PluralRules(*this);</span>







  90 }
  91 
  92 PluralRules&amp;
  93 PluralRules::operator=(const PluralRules&amp; other) {
  94     if (this != &amp;other) {
  95         delete mRules;
<span class="line-modified">  96         if (other.mRules==NULL) {</span>
<span class="line-modified">  97             mRules = NULL;</span>



  98         }
<span class="line-modified">  99         else {</span>
 100             mRules = new RuleChain(*other.mRules);







 101         }
 102     }
<span class="line-removed"> 103 </span>
 104     return *this;
 105 }
 106 
 107 StringEnumeration* PluralRules::getAvailableLocales(UErrorCode &amp;status) {
<span class="line-modified"> 108     StringEnumeration *result = new PluralAvailableLocalesEnumeration(status);</span>
<span class="line-modified"> 109     if (result == NULL &amp;&amp; U_SUCCESS(status)) {</span>
<span class="line-removed"> 110         status = U_MEMORY_ALLOCATION_ERROR;</span>
 111     }

 112     if (U_FAILURE(status)) {
<span class="line-modified"> 113         delete result;</span>
<span class="line-removed"> 114         result = NULL;</span>
 115     }
<span class="line-modified"> 116     return result;</span>
 117 }
 118 
 119 
 120 PluralRules* U_EXPORT2
 121 PluralRules::createRules(const UnicodeString&amp; description, UErrorCode&amp; status) {
 122     if (U_FAILURE(status)) {
<span class="line-modified"> 123         return NULL;</span>
 124     }
<span class="line-removed"> 125 </span>
 126     PluralRuleParser parser;
<span class="line-modified"> 127     PluralRules *newRules = new PluralRules(status);</span>
<span class="line-modified"> 128     if (U_SUCCESS(status) &amp;&amp; newRules == NULL) {</span>
<span class="line-modified"> 129         status = U_MEMORY_ALLOCATION_ERROR;</span>
 130     }
<span class="line-modified"> 131     parser.parse(description, newRules, status);</span>
 132     if (U_FAILURE(status)) {
<span class="line-modified"> 133         delete newRules;</span>
<span class="line-removed"> 134         newRules = NULL;</span>
 135     }
<span class="line-modified"> 136     return newRules;</span>
 137 }
 138 
 139 
 140 PluralRules* U_EXPORT2
 141 PluralRules::createDefaultRules(UErrorCode&amp; status) {
 142     return createRules(UnicodeString(TRUE, PLURAL_DEFAULT_RULE, -1), status);
 143 }
 144 
 145 /******************************************************************************/
 146 /* Create PluralRules cache */
 147 
 148 template&lt;&gt; U_I18N_API
 149 const SharedPluralRules *LocaleCacheKey&lt;SharedPluralRules&gt;::createObject(
 150         const void * /*unused*/, UErrorCode &amp;status) const {
 151     const char *localeId = fLoc.getName();
<span class="line-modified"> 152     PluralRules *pr = PluralRules::internalForLocale(</span>
<span class="line-removed"> 153             localeId, UPLURAL_TYPE_CARDINAL, status);</span>
 154     if (U_FAILURE(status)) {
<span class="line-modified"> 155         return NULL;</span>
 156     }
<span class="line-modified"> 157     SharedPluralRules *result = new SharedPluralRules(pr);</span>
<span class="line-modified"> 158     if (result == NULL) {</span>
<span class="line-modified"> 159         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed"> 160         delete pr;</span>
<span class="line-removed"> 161         return NULL;</span>
 162     }

 163     result-&gt;addRef();
<span class="line-modified"> 164     return result;</span>
 165 }
 166 
 167 /* end plural rules cache */
 168 /******************************************************************************/
 169 
 170 const SharedPluralRules* U_EXPORT2
 171 PluralRules::createSharedInstance(
 172         const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
 173     if (U_FAILURE(status)) {
<span class="line-modified"> 174         return NULL;</span>
 175     }
 176     if (type != UPLURAL_TYPE_CARDINAL) {
 177         status = U_UNSUPPORTED_ERROR;
<span class="line-modified"> 178         return NULL;</span>
 179     }
<span class="line-modified"> 180     const SharedPluralRules *result = NULL;</span>
 181     UnifiedCache::getByLocale(locale, result, status);
 182     return result;
 183 }
 184 
 185 PluralRules* U_EXPORT2
 186 PluralRules::forLocale(const Locale&amp; locale, UErrorCode&amp; status) {
 187     return forLocale(locale, UPLURAL_TYPE_CARDINAL, status);
 188 }
 189 
 190 PluralRules* U_EXPORT2
 191 PluralRules::forLocale(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
 192     if (type != UPLURAL_TYPE_CARDINAL) {
 193         return internalForLocale(locale, type, status);
 194     }
 195     const SharedPluralRules *shared = createSharedInstance(
 196             locale, type, status);
 197     if (U_FAILURE(status)) {
<span class="line-modified"> 198         return NULL;</span>
 199     }
 200     PluralRules *result = (*shared)-&gt;clone();
 201     shared-&gt;removeRef();
<span class="line-modified"> 202     if (result == NULL) {</span>
 203         status = U_MEMORY_ALLOCATION_ERROR;
 204     }
 205     return result;
 206 }
 207 
 208 PluralRules* U_EXPORT2
 209 PluralRules::internalForLocale(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
 210     if (U_FAILURE(status)) {
<span class="line-modified"> 211         return NULL;</span>
 212     }
 213     if (type &gt;= UPLURAL_TYPE_COUNT) {
 214         status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 215         return NULL;</span>
 216     }
<span class="line-modified"> 217     PluralRules *newObj = new PluralRules(status);</span>
<span class="line-modified"> 218     if (newObj==NULL || U_FAILURE(status)) {</span>
<span class="line-modified"> 219         delete newObj;</span>
<span class="line-removed"> 220         return NULL;</span>
 221     }
 222     UnicodeString locRule = newObj-&gt;getRuleFromResource(locale, type, status);
<span class="line-modified"> 223     // TODO: which errors, if any, should be returned?</span>
 224     if (locRule.length() == 0) {




 225         // Locales with no specific rules (all numbers have the &quot;other&quot; category
 226         //   will return a U_MISSING_RESOURCE_ERROR at this point. This is not
 227         //   an error.
 228         locRule =  UnicodeString(PLURAL_DEFAULT_RULE);
 229         status = U_ZERO_ERROR;
 230     }
 231     PluralRuleParser parser;
<span class="line-modified"> 232     parser.parse(locRule, newObj, status);</span>
 233         //  TODO: should rule parse errors be returned, or
 234         //        should we silently use default rules?
 235         //        Original impl used default rules.
 236         //        Ask the question to ICU Core.
 237 
<span class="line-modified"> 238     return newObj;</span>
 239 }
 240 
 241 UnicodeString
 242 PluralRules::select(int32_t number) const {
 243     return select(FixedDecimal(number));
 244 }
 245 
 246 UnicodeString
 247 PluralRules::select(double number) const {
 248     return select(FixedDecimal(number));
 249 }
 250 










 251 UnicodeString
 252 PluralRules::select(const IFixedDecimal &amp;number) const {
<span class="line-modified"> 253     if (mRules == NULL) {</span>
 254         return UnicodeString(TRUE, PLURAL_DEFAULT_RULE, -1);
 255     }
 256     else {
 257         return mRules-&gt;select(number);
 258     }
 259 }
 260 
 261 
 262 
 263 StringEnumeration*
 264 PluralRules::getKeywords(UErrorCode&amp; status) const {
<span class="line-removed"> 265     if (U_FAILURE(status))  return NULL;</span>
<span class="line-removed"> 266     StringEnumeration* nameEnumerator = new PluralKeywordEnumeration(mRules, status);</span>
 267     if (U_FAILURE(status)) {
<span class="line-modified"> 268       delete nameEnumerator;</span>
<span class="line-removed"> 269       return NULL;</span>
 270     }
<span class="line-modified"> 271 </span>
<span class="line-modified"> 272     return nameEnumerator;</span>







 273 }
 274 
 275 double
 276 PluralRules::getUniqueKeywordValue(const UnicodeString&amp; /* keyword */) {
 277   // Not Implemented.
 278   return UPLRULES_NO_UNIQUE_VALUE;
 279 }
 280 
 281 int32_t
 282 PluralRules::getAllKeywordValues(const UnicodeString &amp; /* keyword */, double * /* dest */,
 283                                  int32_t /* destCapacity */, UErrorCode&amp; error) {
 284     error = U_UNSUPPORTED_ERROR;
 285     return 0;
 286 }
 287 
 288 
 289 static double scaleForInt(double d) {
 290     double scale = 1.0;
 291     while (d != floor(d)) {
 292         d = d * 10.0;
</pre>
<hr />
<pre>
 350                 //    zeros to the right of the decimal.
 351                 //    This results in test failures with values mapping back to a different keyword.
 352                 double sampleValue = n/scale;
 353                 if (!(sampleValue == floor(sampleValue) &amp;&amp; fixedLo.visibleDecimalDigitCount &gt; 0)) {
 354                     dest[sampleCount++] = sampleValue;
 355                 }
 356                 if (sampleCount &gt;= destCapacity) {
 357                     break;
 358                 }
 359             }
 360         }
 361         sampleStartIdx = sampleEndIdx + 1;
 362     }
 363     return sampleCount;
 364 }
 365 
 366 
 367 int32_t
 368 PluralRules::getSamples(const UnicodeString &amp;keyword, double *dest,
 369                         int32_t destCapacity, UErrorCode&amp; status) {







 370     RuleChain *rc = rulesForKeyword(keyword);
<span class="line-modified"> 371     if (rc == NULL || destCapacity == 0 || U_FAILURE(status)) {</span>
 372         return 0;
 373     }
 374     int32_t numSamples = getSamplesFromString(rc-&gt;fIntegerSamples, dest, destCapacity, status);
 375     if (numSamples == 0) {
 376         numSamples = getSamplesFromString(rc-&gt;fDecimalSamples, dest, destCapacity, status);
 377     }
 378     return numSamples;
 379 }
 380 
 381 
 382 RuleChain *PluralRules::rulesForKeyword(const UnicodeString &amp;keyword) const {
 383     RuleChain *rc;
<span class="line-modified"> 384     for (rc = mRules; rc != NULL; rc = rc-&gt;fNext) {</span>
 385         if (rc-&gt;fKeyword == keyword) {
 386             break;
 387         }
 388     }
 389     return rc;
 390 }
 391 
 392 
 393 UBool
 394 PluralRules::isKeyword(const UnicodeString&amp; keyword) const {
 395     if (0 == keyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
 396         return true;
 397     }
<span class="line-modified"> 398     return rulesForKeyword(keyword) != NULL;</span>
 399 }
 400 
 401 UnicodeString
 402 PluralRules::getKeywordOther() const {
 403     return UnicodeString(TRUE, PLURAL_KEYWORD_OTHER, 5);
 404 }
 405 
 406 UBool
 407 PluralRules::operator==(const PluralRules&amp; other) const  {
 408     const UnicodeString *ptrKeyword;
 409     UErrorCode status= U_ZERO_ERROR;
 410 
 411     if ( this == &amp;other ) {
 412         return TRUE;
 413     }
 414     LocalPointer&lt;StringEnumeration&gt; myKeywordList(getKeywords(status));
 415     LocalPointer&lt;StringEnumeration&gt; otherKeywordList(other.getKeywords(status));
 416     if (U_FAILURE(status)) {
 417         return FALSE;
 418     }
 419 
 420     if (myKeywordList-&gt;count(status)!=otherKeywordList-&gt;count(status)) {
 421         return FALSE;
 422     }
 423     myKeywordList-&gt;reset(status);
<span class="line-modified"> 424     while ((ptrKeyword=myKeywordList-&gt;snext(status))!=NULL) {</span>
 425         if (!other.isKeyword(*ptrKeyword)) {
 426             return FALSE;
 427         }
 428     }
 429     otherKeywordList-&gt;reset(status);
<span class="line-modified"> 430     while ((ptrKeyword=otherKeywordList-&gt;snext(status))!=NULL) {</span>
 431         if (!this-&gt;isKeyword(*ptrKeyword)) {
 432             return FALSE;
 433         }
 434     }
 435     if (U_FAILURE(status)) {
 436         return FALSE;
 437     }
 438 
 439     return TRUE;
 440 }
 441 
 442 
 443 void
 444 PluralRuleParser::parse(const UnicodeString&amp; ruleData, PluralRules *prules, UErrorCode &amp;status)
 445 {
 446     if (U_FAILURE(status)) {
 447         return;
 448     }
 449     U_ASSERT(ruleIndex == 0);    // Parsers are good for a single use only!
 450     ruleSrc = &amp;ruleData;
 451 
 452     while (ruleIndex&lt; ruleSrc-&gt;length()) {
 453         getNextToken(status);
 454         if (U_FAILURE(status)) {
 455             return;
 456         }
 457         checkSyntax(status);
 458         if (U_FAILURE(status)) {
 459             return;
 460         }
 461         switch (type) {
 462         case tAnd:
<span class="line-modified"> 463             U_ASSERT(curAndConstraint != NULL);</span>
<span class="line-modified"> 464             curAndConstraint = curAndConstraint-&gt;add();</span>
 465             break;
 466         case tOr:
 467             {
<span class="line-modified"> 468                 U_ASSERT(currentChain != NULL);</span>
 469                 OrConstraint *orNode=currentChain-&gt;ruleHeader;
<span class="line-modified"> 470                 while (orNode-&gt;next != NULL) {</span>
 471                     orNode = orNode-&gt;next;
 472                 }
 473                 orNode-&gt;next= new OrConstraint();




 474                 orNode=orNode-&gt;next;
<span class="line-modified"> 475                 orNode-&gt;next=NULL;</span>
<span class="line-modified"> 476                 curAndConstraint = orNode-&gt;add();</span>
 477             }
 478             break;
 479         case tIs:
<span class="line-modified"> 480             U_ASSERT(curAndConstraint != NULL);</span>
 481             U_ASSERT(curAndConstraint-&gt;value == -1);
<span class="line-modified"> 482             U_ASSERT(curAndConstraint-&gt;rangeList == NULL);</span>
 483             break;
 484         case tNot:
<span class="line-modified"> 485             U_ASSERT(curAndConstraint != NULL);</span>
 486             curAndConstraint-&gt;negated=TRUE;
 487             break;
 488 
 489         case tNotEqual:
 490             curAndConstraint-&gt;negated=TRUE;
 491             U_FALLTHROUGH;
 492         case tIn:
 493         case tWithin:
 494         case tEqual:
<span class="line-modified"> 495             U_ASSERT(curAndConstraint != NULL);</span>
<span class="line-modified"> 496             curAndConstraint-&gt;rangeList = new UVector32(status);</span>
<span class="line-modified"> 497             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Low</span>
<span class="line-modified"> 498             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Hi</span>
<span class="line-modified"> 499             rangeLowIdx = 0;</span>
<span class="line-modified"> 500             rangeHiIdx  = 1;</span>
<span class="line-modified"> 501             curAndConstraint-&gt;value=PLURAL_RANGE_HIGH;</span>
<span class="line-modified"> 502             curAndConstraint-&gt;integerOnly = (type != tWithin);</span>






 503             break;
 504         case tNumber:
<span class="line-modified"> 505             U_ASSERT(curAndConstraint != NULL);</span>
 506             if ( (curAndConstraint-&gt;op==AndConstraint::MOD)&amp;&amp;
 507                  (curAndConstraint-&gt;opNum == -1 ) ) {
 508                 curAndConstraint-&gt;opNum=getNumberValue(token);
 509             }
 510             else {
<span class="line-modified"> 511                 if (curAndConstraint-&gt;rangeList == NULL) {</span>
 512                     // this is for an &#39;is&#39; rule
 513                     curAndConstraint-&gt;value = getNumberValue(token);
 514                 } else {
 515                     // this is for an &#39;in&#39; or &#39;within&#39; rule
 516                     if (curAndConstraint-&gt;rangeList-&gt;elementAti(rangeLowIdx) == -1) {
 517                         curAndConstraint-&gt;rangeList-&gt;setElementAt(getNumberValue(token), rangeLowIdx);
 518                         curAndConstraint-&gt;rangeList-&gt;setElementAt(getNumberValue(token), rangeHiIdx);
 519                     }
 520                     else {
 521                         curAndConstraint-&gt;rangeList-&gt;setElementAt(getNumberValue(token), rangeHiIdx);
 522                         if (curAndConstraint-&gt;rangeList-&gt;elementAti(rangeLowIdx) &gt;
 523                                 curAndConstraint-&gt;rangeList-&gt;elementAti(rangeHiIdx)) {
 524                             // Range Lower bound &gt; Range Upper bound.
 525                             // U_UNEXPECTED_TOKEN seems a little funny, but it is consistently
 526                             // used for all plural rule parse errors.
 527                             status = U_UNEXPECTED_TOKEN;
 528                             break;
 529                         }
 530                     }
 531                 }
 532             }
 533             break;
 534         case tComma:
 535             // TODO: rule syntax checking is inadequate, can happen with badly formed rules.
 536             //       Catch cases like &quot;n mod 10, is 1&quot; here instead.
<span class="line-modified"> 537             if (curAndConstraint == NULL || curAndConstraint-&gt;rangeList == NULL) {</span>
 538                 status = U_UNEXPECTED_TOKEN;
 539                 break;
 540             }
 541             U_ASSERT(curAndConstraint-&gt;rangeList-&gt;size() &gt;= 2);
 542             rangeLowIdx = curAndConstraint-&gt;rangeList-&gt;size();
 543             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Low
 544             rangeHiIdx = curAndConstraint-&gt;rangeList-&gt;size();
 545             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Hi
 546             break;
 547         case tMod:
<span class="line-modified"> 548             U_ASSERT(curAndConstraint != NULL);</span>
 549             curAndConstraint-&gt;op=AndConstraint::MOD;
 550             break;
 551         case tVariableN:
 552         case tVariableI:
 553         case tVariableF:
 554         case tVariableT:
 555         case tVariableV:
<span class="line-modified"> 556             U_ASSERT(curAndConstraint != NULL);</span>
 557             curAndConstraint-&gt;digitsType = type;
 558             break;
 559         case tKeyword:
 560             {
 561             RuleChain *newChain = new RuleChain;
<span class="line-modified"> 562             if (newChain == NULL) {</span>
 563                 status = U_MEMORY_ALLOCATION_ERROR;
 564                 break;
 565             }
 566             newChain-&gt;fKeyword = token;
<span class="line-modified"> 567             if (prules-&gt;mRules == NULL) {</span>
 568                 prules-&gt;mRules = newChain;
 569             } else {
 570                 // The new rule chain goes at the end of the linked list of rule chains,
 571                 //   unless there is an &quot;other&quot; keyword &amp; chain. &quot;other&quot; must remain last.
 572                 RuleChain *insertAfter = prules-&gt;mRules;
<span class="line-modified"> 573                 while (insertAfter-&gt;fNext!=NULL &amp;&amp;</span>
 574                        insertAfter-&gt;fNext-&gt;fKeyword.compare(PLURAL_KEYWORD_OTHER, 5) != 0 ){
 575                     insertAfter=insertAfter-&gt;fNext;
 576                 }
 577                 newChain-&gt;fNext = insertAfter-&gt;fNext;
 578                 insertAfter-&gt;fNext = newChain;
 579             }
 580             OrConstraint *orNode = new OrConstraint();




 581             newChain-&gt;ruleHeader = orNode;
<span class="line-modified"> 582             curAndConstraint = orNode-&gt;add();</span>
 583             currentChain = newChain;
 584             }
 585             break;
 586 
 587         case tInteger:
 588             for (;;) {
 589                 getNextToken(status);
 590                 if (U_FAILURE(status) || type == tSemiColon || type == tEOF || type == tAt) {
 591                     break;
 592                 }
 593                 if (type == tEllipsis) {
 594                     currentChain-&gt;fIntegerSamplesUnbounded = TRUE;
 595                     continue;
 596                 }
 597                 currentChain-&gt;fIntegerSamples.append(token);
 598             }
 599             break;
 600 
 601         case tDecimal:
 602             for (;;) {
</pre>
<hr />
<pre>
 612             }
 613             break;
 614 
 615         default:
 616             break;
 617         }
 618         prevType=type;
 619         if (U_FAILURE(status)) {
 620             break;
 621         }
 622     }
 623 }
 624 
 625 UnicodeString
 626 PluralRules::getRuleFromResource(const Locale&amp; locale, UPluralType type, UErrorCode&amp; errCode) {
 627     UnicodeString emptyStr;
 628 
 629     if (U_FAILURE(errCode)) {
 630         return emptyStr;
 631     }
<span class="line-modified"> 632     LocalUResourceBundlePointer rb(ures_openDirect(NULL, &quot;plurals&quot;, &amp;errCode));</span>
 633     if(U_FAILURE(errCode)) {
 634         return emptyStr;
 635     }
 636     const char *typeKey;
 637     switch (type) {
 638     case UPLURAL_TYPE_CARDINAL:
 639         typeKey = &quot;locales&quot;;
 640         break;
 641     case UPLURAL_TYPE_ORDINAL:
 642         typeKey = &quot;locales_ordinals&quot;;
 643         break;
 644     default:
 645         // Must not occur: The caller should have checked for valid types.
 646         errCode = U_ILLEGAL_ARGUMENT_ERROR;
 647         return emptyStr;
 648     }
<span class="line-modified"> 649     LocalUResourceBundlePointer locRes(ures_getByKey(rb.getAlias(), typeKey, NULL, &amp;errCode));</span>
 650     if(U_FAILURE(errCode)) {
 651         return emptyStr;
 652     }
 653     int32_t resLen=0;
<span class="line-modified"> 654     const char *curLocaleName=locale.getName();</span>
 655     const UChar* s = ures_getStringByKey(locRes.getAlias(), curLocaleName, &amp;resLen, &amp;errCode);
 656 
<span class="line-modified"> 657     if (s == NULL) {</span>
 658         // Check parent locales.
 659         UErrorCode status = U_ZERO_ERROR;
 660         char parentLocaleName[ULOC_FULLNAME_CAPACITY];
<span class="line-modified"> 661         const char *curLocaleName=locale.getName();</span>
<span class="line-modified"> 662         uprv_strcpy(parentLocaleName, curLocaleName);</span>
 663 
 664         while (uloc_getParent(parentLocaleName, parentLocaleName,
 665                                        ULOC_FULLNAME_CAPACITY, &amp;status) &gt; 0) {
 666             resLen=0;
 667             s = ures_getStringByKey(locRes.getAlias(), parentLocaleName, &amp;resLen, &amp;status);
<span class="line-modified"> 668             if (s != NULL) {</span>
 669                 errCode = U_ZERO_ERROR;
 670                 break;
 671             }
 672             status = U_ZERO_ERROR;
 673         }
 674     }
<span class="line-modified"> 675     if (s==NULL) {</span>
 676         return emptyStr;
 677     }
 678 
 679     char setKey[256];
 680     u_UCharsToChars(s, setKey, resLen + 1);
 681     // printf(&quot;\n PluralRule: %s\n&quot;, setKey);
 682 
<span class="line-modified"> 683     LocalUResourceBundlePointer ruleRes(ures_getByKey(rb.getAlias(), &quot;rules&quot;, NULL, &amp;errCode));</span>
 684     if(U_FAILURE(errCode)) {
 685         return emptyStr;
 686     }
<span class="line-modified"> 687     LocalUResourceBundlePointer setRes(ures_getByKey(ruleRes.getAlias(), setKey, NULL, &amp;errCode));</span>
 688     if (U_FAILURE(errCode)) {
 689         return emptyStr;
 690     }
 691 
 692     int32_t numberKeys = ures_getSize(setRes.getAlias());
 693     UnicodeString result;
<span class="line-modified"> 694     const char *key=NULL;</span>
 695     for(int32_t i=0; i&lt;numberKeys; ++i) {   // Keys are zero, one, few, ...
 696         UnicodeString rules = ures_getNextUnicodeString(setRes.getAlias(), &amp;key, &amp;errCode);
 697         UnicodeString uKey(key, -1, US_INV);
 698         result.append(uKey);
 699         result.append(COLON);
 700         result.append(rules);
 701         result.append(SEMI_COLON);
 702     }
 703     return result;
 704 }
 705 
 706 
 707 UnicodeString
 708 PluralRules::getRules() const {
 709     UnicodeString rules;
<span class="line-modified"> 710     if (mRules != NULL) {</span>
 711         mRules-&gt;dumpRules(rules);
 712     }
 713     return rules;
 714 }
 715 
<span class="line-removed"> 716 </span>
<span class="line-removed"> 717 AndConstraint::AndConstraint() {</span>
<span class="line-removed"> 718     op = AndConstraint::NONE;</span>
<span class="line-removed"> 719     opNum=-1;</span>
<span class="line-removed"> 720     value = -1;</span>
<span class="line-removed"> 721     rangeList = NULL;</span>
<span class="line-removed"> 722     negated = FALSE;</span>
<span class="line-removed"> 723     integerOnly = FALSE;</span>
<span class="line-removed"> 724     digitsType = none;</span>
<span class="line-removed"> 725     next=NULL;</span>
<span class="line-removed"> 726 }</span>
<span class="line-removed"> 727 </span>
<span class="line-removed"> 728 </span>
 729 AndConstraint::AndConstraint(const AndConstraint&amp; other) {




 730     this-&gt;op = other.op;
 731     this-&gt;opNum=other.opNum;
 732     this-&gt;value=other.value;
<span class="line-modified"> 733     this-&gt;rangeList=NULL;</span>
<span class="line-modified"> 734     if (other.rangeList != NULL) {</span>
<span class="line-modified"> 735         UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 736         this-&gt;rangeList = new UVector32(status);</span>
<span class="line-modified"> 737         this-&gt;rangeList-&gt;assign(*other.rangeList, status);</span>


 738     }
 739     this-&gt;integerOnly=other.integerOnly;
 740     this-&gt;negated=other.negated;
 741     this-&gt;digitsType = other.digitsType;
<span class="line-modified"> 742     if (other.next==NULL) {</span>
<span class="line-removed"> 743         this-&gt;next=NULL;</span>
<span class="line-removed"> 744     }</span>
<span class="line-removed"> 745     else {</span>
 746         this-&gt;next = new AndConstraint(*other.next);



 747     }
 748 }
 749 
 750 AndConstraint::~AndConstraint() {
 751     delete rangeList;
<span class="line-modified"> 752     if (next!=NULL) {</span>
<span class="line-modified"> 753         delete next;</span>
<span class="line-modified"> 754     }</span>
 755 }
 756 
<span class="line-removed"> 757 </span>
 758 UBool
 759 AndConstraint::isFulfilled(const IFixedDecimal &amp;number) {
 760     UBool result = TRUE;
 761     if (digitsType == none) {
 762         // An empty AndConstraint, created by a rule with a keyword but no following expression.
 763         return TRUE;
 764     }
 765 
 766     PluralOperand operand = tokenTypeToPluralOperand(digitsType);
 767     double n = number.getPluralOperand(operand);     // pulls n | i | v | f value for the number.
 768                                                      // Will always be positive.
 769                                                      // May be non-integer (n option only)
 770     do {
 771         if (integerOnly &amp;&amp; n != uprv_floor(n)) {
 772             result = FALSE;
 773             break;
 774         }
 775 
 776         if (op == MOD) {
 777             n = fmod(n, opNum);
 778         }
<span class="line-modified"> 779         if (rangeList == NULL) {</span>
 780             result = value == -1 ||    // empty rule
 781                      n == value;       //  &#39;is&#39; rule
 782             break;
 783         }
 784         result = FALSE;                // &#39;in&#39; or &#39;within&#39; rule
 785         for (int32_t r=0; r&lt;rangeList-&gt;size(); r+=2) {
 786             if (rangeList-&gt;elementAti(r) &lt;= n &amp;&amp; n &lt;= rangeList-&gt;elementAti(r+1)) {
 787                 result = TRUE;
 788                 break;
 789             }
 790         }
 791     } while (FALSE);
 792 
 793     if (negated) {
 794         result = !result;
 795     }
 796     return result;
 797 }
 798 
<span class="line-removed"> 799 </span>
 800 AndConstraint*
<span class="line-modified"> 801 AndConstraint::add()</span>
<span class="line-modified"> 802 {</span>



 803     this-&gt;next = new AndConstraint();



 804     return this-&gt;next;
 805 }
 806 
<span class="line-removed"> 807 OrConstraint::OrConstraint() {</span>
<span class="line-removed"> 808     childNode=NULL;</span>
<span class="line-removed"> 809     next=NULL;</span>
<span class="line-removed"> 810 }</span>
 811 
 812 OrConstraint::OrConstraint(const OrConstraint&amp; other) {
<span class="line-modified"> 813     if ( other.childNode == NULL ) {</span>
<span class="line-modified"> 814         this-&gt;childNode = NULL;</span>

 815     }
<span class="line-modified"> 816     else {</span>
 817         this-&gt;childNode = new AndConstraint(*(other.childNode));




 818     }
<span class="line-modified"> 819     if (other.next == NULL ) {</span>
<span class="line-removed"> 820         this-&gt;next = NULL;</span>
<span class="line-removed"> 821     }</span>
<span class="line-removed"> 822     else {</span>
 823         this-&gt;next = new OrConstraint(*(other.next));







 824     }
 825 }
 826 
 827 OrConstraint::~OrConstraint() {
<span class="line-modified"> 828     if (childNode!=NULL) {</span>
<span class="line-modified"> 829         delete childNode;</span>
<span class="line-modified"> 830     }</span>
<span class="line-modified"> 831     if (next!=NULL) {</span>
<span class="line-removed"> 832         delete next;</span>
<span class="line-removed"> 833     }</span>
 834 }
 835 
 836 AndConstraint*
<span class="line-modified"> 837 OrConstraint::add()</span>
<span class="line-modified"> 838 {</span>



 839     OrConstraint *curOrConstraint=this;
 840     {
<span class="line-modified"> 841         while (curOrConstraint-&gt;next!=NULL) {</span>
 842             curOrConstraint = curOrConstraint-&gt;next;
 843         }
<span class="line-modified"> 844         U_ASSERT(curOrConstraint-&gt;childNode == NULL);</span>
 845         curOrConstraint-&gt;childNode = new AndConstraint();



 846     }
 847     return curOrConstraint-&gt;childNode;
 848 }
 849 
 850 UBool
 851 OrConstraint::isFulfilled(const IFixedDecimal &amp;number) {
 852     OrConstraint* orRule=this;
 853     UBool result=FALSE;
 854 
<span class="line-modified"> 855     while (orRule!=NULL &amp;&amp; !result) {</span>
 856         result=TRUE;
 857         AndConstraint* andRule = orRule-&gt;childNode;
<span class="line-modified"> 858         while (andRule!=NULL &amp;&amp; result) {</span>
 859             result = andRule-&gt;isFulfilled(number);
 860             andRule=andRule-&gt;next;
 861         }
 862         orRule = orRule-&gt;next;
 863     }
 864 
 865     return result;
 866 }
 867 
 868 
<span class="line-removed"> 869 RuleChain::RuleChain(): fKeyword(), fNext(NULL), ruleHeader(NULL), fDecimalSamples(), fIntegerSamples(),</span>
<span class="line-removed"> 870                         fDecimalSamplesUnbounded(FALSE), fIntegerSamplesUnbounded(FALSE) {</span>
<span class="line-removed"> 871 }</span>
<span class="line-removed"> 872 </span>
 873 RuleChain::RuleChain(const RuleChain&amp; other) :
<span class="line-modified"> 874         fKeyword(other.fKeyword), fNext(NULL), ruleHeader(NULL), fDecimalSamples(other.fDecimalSamples),</span>
 875         fIntegerSamples(other.fIntegerSamples), fDecimalSamplesUnbounded(other.fDecimalSamplesUnbounded),
<span class="line-modified"> 876         fIntegerSamplesUnbounded(other.fIntegerSamplesUnbounded) {</span>
<span class="line-modified"> 877     if (other.ruleHeader != NULL) {</span>



 878         this-&gt;ruleHeader = new OrConstraint(*(other.ruleHeader));








 879     }
<span class="line-modified"> 880     if (other.fNext != NULL ) {</span>
 881         this-&gt;fNext = new RuleChain(*other.fNext);







 882     }
 883 }
 884 
 885 RuleChain::~RuleChain() {
 886     delete fNext;
 887     delete ruleHeader;
 888 }
 889 
<span class="line-removed"> 890 </span>
 891 UnicodeString
 892 RuleChain::select(const IFixedDecimal &amp;number) const {
 893     if (!number.isNaN() &amp;&amp; !number.isInfinite()) {
<span class="line-modified"> 894         for (const RuleChain *rules = this; rules != NULL; rules = rules-&gt;fNext) {</span>
 895              if (rules-&gt;ruleHeader-&gt;isFulfilled(number)) {
 896                  return rules-&gt;fKeyword;
 897              }
 898         }
 899     }
 900     return UnicodeString(TRUE, PLURAL_KEYWORD_OTHER, 5);
 901 }
 902 
 903 static UnicodeString tokenString(tokenType tok) {
 904     UnicodeString s;
 905     switch (tok) {
 906       case tVariableN:
 907         s.append(LOW_N); break;
 908       case tVariableI:
 909         s.append(LOW_I); break;
 910       case tVariableF:
 911         s.append(LOW_F); break;
 912       case tVariableV:
 913         s.append(LOW_V); break;
 914       case tVariableT:
 915         s.append(LOW_T); break;
 916       default:
 917         s.append(TILDE);
 918     }
 919     return s;
 920 }
 921 
 922 void
 923 RuleChain::dumpRules(UnicodeString&amp; result) {
 924     UChar digitString[16];
 925 
<span class="line-modified"> 926     if ( ruleHeader != NULL ) {</span>
 927         result +=  fKeyword;
 928         result += COLON;
 929         result += SPACE;
 930         OrConstraint* orRule=ruleHeader;
<span class="line-modified"> 931         while ( orRule != NULL ) {</span>
 932             AndConstraint* andRule=orRule-&gt;childNode;
<span class="line-modified"> 933             while ( andRule != NULL ) {</span>
<span class="line-modified"> 934                 if ((andRule-&gt;op==AndConstraint::NONE) &amp;&amp;  (andRule-&gt;rangeList==NULL) &amp;&amp; (andRule-&gt;value == -1)) {</span>
 935                     // Empty Rules.
<span class="line-modified"> 936                 } else if ( (andRule-&gt;op==AndConstraint::NONE) &amp;&amp; (andRule-&gt;rangeList==NULL) ) {</span>
 937                     result += tokenString(andRule-&gt;digitsType);
 938                     result += UNICODE_STRING_SIMPLE(&quot; is &quot;);
 939                     if (andRule-&gt;negated) {
 940                         result += UNICODE_STRING_SIMPLE(&quot;not &quot;);
 941                     }
 942                     uprv_itou(digitString,16, andRule-&gt;value,10,0);
 943                     result += UnicodeString(digitString);
 944                 }
 945                 else {
 946                     result += tokenString(andRule-&gt;digitsType);
 947                     result += SPACE;
 948                     if (andRule-&gt;op==AndConstraint::MOD) {
 949                         result += UNICODE_STRING_SIMPLE(&quot;mod &quot;);
 950                         uprv_itou(digitString,16, andRule-&gt;opNum,10,0);
 951                         result += UnicodeString(digitString);
 952                     }
<span class="line-modified"> 953                     if (andRule-&gt;rangeList==NULL) {</span>
 954                         if (andRule-&gt;negated) {
 955                             result += UNICODE_STRING_SIMPLE(&quot; is not &quot;);
 956                             uprv_itou(digitString,16, andRule-&gt;value,10,0);
 957                             result += UnicodeString(digitString);
 958                         }
 959                         else {
 960                             result += UNICODE_STRING_SIMPLE(&quot; is &quot;);
 961                             uprv_itou(digitString,16, andRule-&gt;value,10,0);
 962                             result += UnicodeString(digitString);
 963                         }
 964                     }
 965                     else {
 966                         if (andRule-&gt;negated) {
 967                             if ( andRule-&gt;integerOnly ) {
 968                                 result += UNICODE_STRING_SIMPLE(&quot; not in &quot;);
 969                             }
 970                             else {
 971                                 result += UNICODE_STRING_SIMPLE(&quot; not within &quot;);
 972                             }
 973                         }
</pre>
<hr />
<pre>
 976                                 result += UNICODE_STRING_SIMPLE(&quot; in &quot;);
 977                             }
 978                             else {
 979                                 result += UNICODE_STRING_SIMPLE(&quot; within &quot;);
 980                             }
 981                         }
 982                         for (int32_t r=0; r&lt;andRule-&gt;rangeList-&gt;size(); r+=2) {
 983                             int32_t rangeLo = andRule-&gt;rangeList-&gt;elementAti(r);
 984                             int32_t rangeHi = andRule-&gt;rangeList-&gt;elementAti(r+1);
 985                             uprv_itou(digitString,16, rangeLo, 10, 0);
 986                             result += UnicodeString(digitString);
 987                             result += UNICODE_STRING_SIMPLE(&quot;..&quot;);
 988                             uprv_itou(digitString,16, rangeHi, 10,0);
 989                             result += UnicodeString(digitString);
 990                             if (r+2 &lt; andRule-&gt;rangeList-&gt;size()) {
 991                                 result += UNICODE_STRING_SIMPLE(&quot;, &quot;);
 992                             }
 993                         }
 994                     }
 995                 }
<span class="line-modified"> 996                 if ( (andRule=andRule-&gt;next) != NULL) {</span>
 997                     result += UNICODE_STRING_SIMPLE(&quot; and &quot;);
 998                 }
 999             }
<span class="line-modified">1000             if ( (orRule = orRule-&gt;next) != NULL ) {</span>
1001                 result += UNICODE_STRING_SIMPLE(&quot; or &quot;);
1002             }
1003         }
1004     }
<span class="line-modified">1005     if ( fNext != NULL ) {</span>
1006         result += UNICODE_STRING_SIMPLE(&quot;; &quot;);
1007         fNext-&gt;dumpRules(result);
1008     }
1009 }
1010 
1011 
1012 UErrorCode
1013 RuleChain::getKeywords(int32_t capacityOfKeywords, UnicodeString* keywords, int32_t&amp; arraySize) const {



1014     if ( arraySize &lt; capacityOfKeywords-1 ) {
1015         keywords[arraySize++]=fKeyword;
1016     }
1017     else {
1018         return U_BUFFER_OVERFLOW_ERROR;
1019     }
1020 
<span class="line-modified">1021     if ( fNext != NULL ) {</span>
1022         return fNext-&gt;getKeywords(capacityOfKeywords, keywords, arraySize);
1023     }
1024     else {
1025         return U_ZERO_ERROR;
1026     }
1027 }
1028 
1029 UBool
1030 RuleChain::isKeyword(const UnicodeString&amp; keywordParam) const {
1031     if ( fKeyword == keywordParam ) {
1032         return TRUE;
1033     }
1034 
<span class="line-modified">1035     if ( fNext != NULL ) {</span>
1036         return fNext-&gt;isKeyword(keywordParam);
1037     }
1038     else {
1039         return FALSE;
1040     }
1041 }
1042 
1043 
1044 PluralRuleParser::PluralRuleParser() :
1045         ruleIndex(0), token(), type(none), prevType(none),
<span class="line-modified">1046         curAndConstraint(NULL), currentChain(NULL), rangeLowIdx(-1), rangeHiIdx(-1)</span>
1047 {
1048 }
1049 
1050 PluralRuleParser::~PluralRuleParser() {
1051 }
1052 
1053 
1054 int32_t
1055 PluralRuleParser::getNumberValue(const UnicodeString&amp; token) {
1056     int32_t i;
1057     char digits[128];
1058 
1059     i = token.extract(0, token.length(), digits, UPRV_LENGTHOF(digits), US_INV);
1060     digits[i]=&#39;\0&#39;;
1061 
1062     return((int32_t)atoi(digits));
1063 }
1064 
1065 
1066 void
</pre>
<hr />
<pre>
1324         keyType = tNot;
1325     } else if (0 == token.compare(PK_MOD, 3)) {
1326         keyType = tMod;
1327     } else if (0 == token.compare(PK_OR, 2)) {
1328         keyType = tOr;
1329     } else if (0 == token.compare(PK_DECIMAL, 7)) {
1330         keyType = tDecimal;
1331     } else if (0 == token.compare(PK_INTEGER, 7)) {
1332         keyType = tInteger;
1333     }
1334     return keyType;
1335 }
1336 
1337 
1338 PluralKeywordEnumeration::PluralKeywordEnumeration(RuleChain *header, UErrorCode&amp; status)
1339         : pos(0), fKeywordNames(status) {
1340     if (U_FAILURE(status)) {
1341         return;
1342     }
1343     fKeywordNames.setDeleter(uprv_deleteUObject);
<span class="line-modified">1344     UBool  addKeywordOther=TRUE;</span>
<span class="line-modified">1345     RuleChain *node=header;</span>
<span class="line-modified">1346     while(node!=NULL) {</span>
<span class="line-modified">1347         fKeywordNames.addElement(new UnicodeString(node-&gt;fKeyword), status);</span>





1348         if (U_FAILURE(status)) {

1349             return;
1350         }
1351         if (0 == node-&gt;fKeyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
<span class="line-modified">1352             addKeywordOther= FALSE;</span>
1353         }
<span class="line-modified">1354         node=node-&gt;fNext;</span>
1355     }
1356 
1357     if (addKeywordOther) {
<span class="line-modified">1358         fKeywordNames.addElement(new UnicodeString(PLURAL_KEYWORD_OTHER), status);</span>









1359     }
1360 }
1361 
1362 const UnicodeString*
1363 PluralKeywordEnumeration::snext(UErrorCode&amp; status) {
1364     if (U_SUCCESS(status) &amp;&amp; pos &lt; fKeywordNames.size()) {
1365         return (const UnicodeString*)fKeywordNames.elementAt(pos++);
1366     }
<span class="line-modified">1367     return NULL;</span>
1368 }
1369 
1370 void
1371 PluralKeywordEnumeration::reset(UErrorCode&amp; /*status*/) {
1372     pos=0;
1373 }
1374 
1375 int32_t
1376 PluralKeywordEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">1377        return fKeywordNames.size();</span>
1378 }
1379 
1380 PluralKeywordEnumeration::~PluralKeywordEnumeration() {
1381 }
1382 
1383 PluralOperand tokenTypeToPluralOperand(tokenType tt) {
1384     switch(tt) {
1385     case tVariableN:
1386         return PLURAL_OPERAND_N;
1387     case tVariableI:
1388         return PLURAL_OPERAND_I;
1389     case tVariableF:
1390         return PLURAL_OPERAND_F;
1391     case tVariableV:
1392         return PLURAL_OPERAND_V;
1393     case tVariableT:
1394         return PLURAL_OPERAND_T;
1395     default:
<span class="line-modified">1396         U_ASSERT(FALSE);  // unexpected.</span>
<span class="line-removed">1397         return PLURAL_OPERAND_N;</span>
1398     }
1399 }
1400 
1401 FixedDecimal::FixedDecimal(double n, int32_t v, int64_t f) {
1402     init(n, v, f);
1403     // check values. TODO make into unit test.
1404     //
1405     //            long visiblePower = (int) Math.pow(10, v);
1406     //            if (decimalDigits &gt; visiblePower) {
1407     //                throw new IllegalArgumentException();
1408     //            }
1409     //            double fraction = intValue + (decimalDigits / (double) visiblePower);
1410     //            if (fraction != source) {
1411     //                double diff = Math.abs(fraction - source)/(Math.abs(fraction) + Math.abs(source));
1412     //                if (diff &gt; 0.00000001d) {
1413     //                    throw new IllegalArgumentException();
1414     //                }
1415     //            }
1416 }
1417 
</pre>
<hr />
<pre>
1589             // Do not let the decimalDigits value overflow if there are many trailing zeros.
1590             // Limit the value to 18 digits, the most that a 64 bit int can fully represent.
1591             if (decimalDigits &gt;= 100000000000000000LL) {
1592                 break;
1593             }
1594             decimalDigits *= 10;
1595         }
1596         visibleDecimalDigitCount += numTrailingFractionZeros;
1597     }
1598 }
1599 
1600 
1601 double FixedDecimal::getPluralOperand(PluralOperand operand) const {
1602     switch(operand) {
1603         case PLURAL_OPERAND_N: return source;
1604         case PLURAL_OPERAND_I: return static_cast&lt;double&gt;(intValue);
1605         case PLURAL_OPERAND_F: return static_cast&lt;double&gt;(decimalDigits);
1606         case PLURAL_OPERAND_T: return static_cast&lt;double&gt;(decimalDigitsWithoutTrailingZeros);
1607         case PLURAL_OPERAND_V: return visibleDecimalDigitCount;
1608         default:
<span class="line-modified">1609              U_ASSERT(FALSE);  // unexpected.</span>
<span class="line-removed">1610              return source;</span>
1611     }
1612 }
1613 
1614 bool FixedDecimal::isNaN() const {
1615     return _isNaN;
1616 }
1617 
1618 bool FixedDecimal::isInfinite() const {
1619     return _isInfinite;
1620 }
1621 
1622 bool FixedDecimal::hasIntegerValue() const {
1623     return _hasIntegerValue;
1624 }
1625 
1626 bool FixedDecimal::isNanOrInfinity() const {
1627     return _isNaN || _isInfinite;
1628 }
1629 
1630 int32_t FixedDecimal::getVisibleFractionDigitCount() const {
1631     return visibleDecimalDigitCount;
1632 }
1633 
1634 
1635 
1636 PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &amp;status) {
<span class="line-removed">1637     fLocales = NULL;</span>
<span class="line-removed">1638     fRes = NULL;</span>
1639     fOpenStatus = status;
1640     if (U_FAILURE(status)) {
1641         return;
1642     }
<span class="line-modified">1643     fOpenStatus = U_ZERO_ERROR;</span>
<span class="line-modified">1644     LocalUResourceBundlePointer rb(ures_openDirect(NULL, &quot;plurals&quot;, &amp;fOpenStatus));</span>
<span class="line-modified">1645     fLocales = ures_getByKey(rb.getAlias(), &quot;locales&quot;, NULL, &amp;fOpenStatus);</span>
1646 }
1647 
1648 PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration() {
1649     ures_close(fLocales);
1650     ures_close(fRes);
<span class="line-modified">1651     fLocales = NULL;</span>
<span class="line-modified">1652     fRes = NULL;</span>
1653 }
1654 
1655 const char *PluralAvailableLocalesEnumeration::next(int32_t *resultLength, UErrorCode &amp;status) {
1656     if (U_FAILURE(status)) {
<span class="line-modified">1657         return NULL;</span>
1658     }
1659     if (U_FAILURE(fOpenStatus)) {
1660         status = fOpenStatus;
<span class="line-modified">1661         return NULL;</span>
1662     }
1663     fRes = ures_getNextResource(fLocales, fRes, &amp;status);
<span class="line-modified">1664     if (fRes == NULL || U_FAILURE(status)) {</span>
1665         if (status == U_INDEX_OUTOFBOUNDS_ERROR) {
1666             status = U_ZERO_ERROR;
1667         }
<span class="line-modified">1668         return NULL;</span>
1669     }
1670     const char *result = ures_getKey(fRes);
<span class="line-modified">1671     if (resultLength != NULL) {</span>
1672         *resultLength = static_cast&lt;int32_t&gt;(uprv_strlen(result));
1673     }
1674     return result;
1675 }
1676 
1677 
1678 void PluralAvailableLocalesEnumeration::reset(UErrorCode &amp;status) {
1679     if (U_FAILURE(status)) {
1680        return;
1681     }
1682     if (U_FAILURE(fOpenStatus)) {
1683         status = fOpenStatus;
1684         return;
1685     }
1686     ures_resetIterator(fLocales);
1687 }
1688 
1689 int32_t PluralAvailableLocalesEnumeration::count(UErrorCode &amp;status) const {
1690     if (U_FAILURE(status)) {
1691         return 0;
</pre>
</td>
<td>
<hr />
<pre>
  18 #include &quot;unicode/upluralrules.h&quot;
  19 #include &quot;unicode/ures.h&quot;
  20 #include &quot;unicode/numfmt.h&quot;
  21 #include &quot;unicode/decimfmt.h&quot;
  22 #include &quot;charstr.h&quot;
  23 #include &quot;cmemory.h&quot;
  24 #include &quot;cstring.h&quot;
  25 #include &quot;hash.h&quot;
  26 #include &quot;locutil.h&quot;
  27 #include &quot;mutex.h&quot;
  28 #include &quot;patternprops.h&quot;
  29 #include &quot;plurrule_impl.h&quot;
  30 #include &quot;putilimp.h&quot;
  31 #include &quot;ucln_in.h&quot;
  32 #include &quot;ustrfmt.h&quot;
  33 #include &quot;uassert.h&quot;
  34 #include &quot;uvectr32.h&quot;
  35 #include &quot;sharedpluralrules.h&quot;
  36 #include &quot;unifiedcache.h&quot;
  37 #include &quot;number_decimalquantity.h&quot;
<span class="line-added">  38 #include &quot;util.h&quot;</span>
  39 
  40 #if !UCONFIG_NO_FORMATTING
  41 
  42 U_NAMESPACE_BEGIN
  43 
  44 using namespace icu::pluralimpl;
  45 using icu::number::impl::DecimalQuantity;
  46 
  47 static const UChar PLURAL_KEYWORD_OTHER[]={LOW_O,LOW_T,LOW_H,LOW_E,LOW_R,0};
  48 static const UChar PLURAL_DEFAULT_RULE[]={LOW_O,LOW_T,LOW_H,LOW_E,LOW_R,COLON,SPACE,LOW_N,0};
  49 static const UChar PK_IN[]={LOW_I,LOW_N,0};
  50 static const UChar PK_NOT[]={LOW_N,LOW_O,LOW_T,0};
  51 static const UChar PK_IS[]={LOW_I,LOW_S,0};
  52 static const UChar PK_MOD[]={LOW_M,LOW_O,LOW_D,0};
  53 static const UChar PK_AND[]={LOW_A,LOW_N,LOW_D,0};
  54 static const UChar PK_OR[]={LOW_O,LOW_R,0};
  55 static const UChar PK_VAR_N[]={LOW_N,0};
  56 static const UChar PK_VAR_I[]={LOW_I,0};
  57 static const UChar PK_VAR_F[]={LOW_F,0};
  58 static const UChar PK_VAR_T[]={LOW_T,0};
  59 static const UChar PK_VAR_V[]={LOW_V,0};
  60 static const UChar PK_WITHIN[]={LOW_W,LOW_I,LOW_T,LOW_H,LOW_I,LOW_N,0};
  61 static const UChar PK_DECIMAL[]={LOW_D,LOW_E,LOW_C,LOW_I,LOW_M,LOW_A,LOW_L,0};
  62 static const UChar PK_INTEGER[]={LOW_I,LOW_N,LOW_T,LOW_E,LOW_G,LOW_E,LOW_R,0};
  63 
  64 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(PluralRules)
  65 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(PluralKeywordEnumeration)
  66 
  67 PluralRules::PluralRules(UErrorCode&amp; /*status*/)
  68 :   UObject(),
<span class="line-modified">  69     mRules(nullptr),</span>
<span class="line-added">  70     mInternalStatus(U_ZERO_ERROR)</span>
  71 {
  72 }
  73 
  74 PluralRules::PluralRules(const PluralRules&amp; other)
  75 : UObject(other),
<span class="line-modified">  76     mRules(nullptr),</span>
<span class="line-added">  77     mInternalStatus(U_ZERO_ERROR)</span>
  78 {
  79     *this=other;
  80 }
  81 
  82 PluralRules::~PluralRules() {
  83     delete mRules;
  84 }
  85 
  86 SharedPluralRules::~SharedPluralRules() {
  87     delete ptr;
  88 }
  89 
  90 PluralRules*
  91 PluralRules::clone() const {
<span class="line-modified">  92     PluralRules* newObj = new PluralRules(*this);</span>
<span class="line-added">  93     // Since clone doesn&#39;t have a &#39;status&#39; parameter, the best we can do is return nullptr if</span>
<span class="line-added">  94     // the newly created object was not fully constructed properly (an error occurred).</span>
<span class="line-added">  95     if (newObj != nullptr &amp;&amp; U_FAILURE(newObj-&gt;mInternalStatus)) {</span>
<span class="line-added">  96         delete newObj;</span>
<span class="line-added">  97         newObj = nullptr;</span>
<span class="line-added">  98     }</span>
<span class="line-added">  99     return newObj;</span>
 100 }
 101 
 102 PluralRules&amp;
 103 PluralRules::operator=(const PluralRules&amp; other) {
 104     if (this != &amp;other) {
 105         delete mRules;
<span class="line-modified"> 106         mRules = nullptr;</span>
<span class="line-modified"> 107         mInternalStatus = other.mInternalStatus;</span>
<span class="line-added"> 108         if (U_FAILURE(mInternalStatus)) {</span>
<span class="line-added"> 109             // bail out early if the object we were copying from was already &#39;invalid&#39;.</span>
<span class="line-added"> 110             return *this;</span>
 111         }
<span class="line-modified"> 112         if (other.mRules != nullptr) {</span>
 113             mRules = new RuleChain(*other.mRules);
<span class="line-added"> 114             if (mRules == nullptr) {</span>
<span class="line-added"> 115                 mInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 116             }</span>
<span class="line-added"> 117             else if (U_FAILURE(mRules-&gt;fInternalStatus)) {</span>
<span class="line-added"> 118                 // If the RuleChain wasn&#39;t fully copied, then set our status to failure as well.</span>
<span class="line-added"> 119                 mInternalStatus = mRules-&gt;fInternalStatus;</span>
<span class="line-added"> 120             }</span>
 121         }
 122     }

 123     return *this;
 124 }
 125 
 126 StringEnumeration* PluralRules::getAvailableLocales(UErrorCode &amp;status) {
<span class="line-modified"> 127     if (U_FAILURE(status)) {</span>
<span class="line-modified"> 128         return nullptr;</span>

 129     }
<span class="line-added"> 130     LocalPointer&lt;StringEnumeration&gt; result(new PluralAvailableLocalesEnumeration(status), status);</span>
 131     if (U_FAILURE(status)) {
<span class="line-modified"> 132         return nullptr;</span>

 133     }
<span class="line-modified"> 134     return result.orphan();</span>
 135 }
 136 
 137 
 138 PluralRules* U_EXPORT2
 139 PluralRules::createRules(const UnicodeString&amp; description, UErrorCode&amp; status) {
 140     if (U_FAILURE(status)) {
<span class="line-modified"> 141         return nullptr;</span>
 142     }

 143     PluralRuleParser parser;
<span class="line-modified"> 144     LocalPointer&lt;PluralRules&gt; newRules(new PluralRules(status), status);</span>
<span class="line-modified"> 145     if (U_FAILURE(status)) {</span>
<span class="line-modified"> 146         return nullptr;</span>
 147     }
<span class="line-modified"> 148     parser.parse(description, newRules.getAlias(), status);</span>
 149     if (U_FAILURE(status)) {
<span class="line-modified"> 150         newRules.adoptInstead(nullptr);</span>

 151     }
<span class="line-modified"> 152     return newRules.orphan();</span>
 153 }
 154 
 155 
 156 PluralRules* U_EXPORT2
 157 PluralRules::createDefaultRules(UErrorCode&amp; status) {
 158     return createRules(UnicodeString(TRUE, PLURAL_DEFAULT_RULE, -1), status);
 159 }
 160 
 161 /******************************************************************************/
 162 /* Create PluralRules cache */
 163 
 164 template&lt;&gt; U_I18N_API
 165 const SharedPluralRules *LocaleCacheKey&lt;SharedPluralRules&gt;::createObject(
 166         const void * /*unused*/, UErrorCode &amp;status) const {
 167     const char *localeId = fLoc.getName();
<span class="line-modified"> 168     LocalPointer&lt;PluralRules&gt; pr(PluralRules::internalForLocale(localeId, UPLURAL_TYPE_CARDINAL, status), status);</span>

 169     if (U_FAILURE(status)) {
<span class="line-modified"> 170         return nullptr;</span>
 171     }
<span class="line-modified"> 172     LocalPointer&lt;SharedPluralRules&gt; result(new SharedPluralRules(pr.getAlias()), status);</span>
<span class="line-modified"> 173     if (U_FAILURE(status)) {</span>
<span class="line-modified"> 174         return nullptr;</span>


 175     }
<span class="line-added"> 176     pr.orphan(); // result was successfully created so it nows pr.</span>
 177     result-&gt;addRef();
<span class="line-modified"> 178     return result.orphan();</span>
 179 }
 180 
 181 /* end plural rules cache */
 182 /******************************************************************************/
 183 
 184 const SharedPluralRules* U_EXPORT2
 185 PluralRules::createSharedInstance(
 186         const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
 187     if (U_FAILURE(status)) {
<span class="line-modified"> 188         return nullptr;</span>
 189     }
 190     if (type != UPLURAL_TYPE_CARDINAL) {
 191         status = U_UNSUPPORTED_ERROR;
<span class="line-modified"> 192         return nullptr;</span>
 193     }
<span class="line-modified"> 194     const SharedPluralRules *result = nullptr;</span>
 195     UnifiedCache::getByLocale(locale, result, status);
 196     return result;
 197 }
 198 
 199 PluralRules* U_EXPORT2
 200 PluralRules::forLocale(const Locale&amp; locale, UErrorCode&amp; status) {
 201     return forLocale(locale, UPLURAL_TYPE_CARDINAL, status);
 202 }
 203 
 204 PluralRules* U_EXPORT2
 205 PluralRules::forLocale(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
 206     if (type != UPLURAL_TYPE_CARDINAL) {
 207         return internalForLocale(locale, type, status);
 208     }
 209     const SharedPluralRules *shared = createSharedInstance(
 210             locale, type, status);
 211     if (U_FAILURE(status)) {
<span class="line-modified"> 212         return nullptr;</span>
 213     }
 214     PluralRules *result = (*shared)-&gt;clone();
 215     shared-&gt;removeRef();
<span class="line-modified"> 216     if (result == nullptr) {</span>
 217         status = U_MEMORY_ALLOCATION_ERROR;
 218     }
 219     return result;
 220 }
 221 
 222 PluralRules* U_EXPORT2
 223 PluralRules::internalForLocale(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
 224     if (U_FAILURE(status)) {
<span class="line-modified"> 225         return nullptr;</span>
 226     }
 227     if (type &gt;= UPLURAL_TYPE_COUNT) {
 228         status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 229         return nullptr;</span>
 230     }
<span class="line-modified"> 231     LocalPointer&lt;PluralRules&gt; newObj(new PluralRules(status), status);</span>
<span class="line-modified"> 232     if (U_FAILURE(status)) {</span>
<span class="line-modified"> 233         return nullptr;</span>

 234     }
 235     UnicodeString locRule = newObj-&gt;getRuleFromResource(locale, type, status);
<span class="line-modified"> 236     // TODO: which other errors, if any, should be returned?</span>
 237     if (locRule.length() == 0) {
<span class="line-added"> 238         // If an out-of-memory error occurred, then stop and report the failure.</span>
<span class="line-added"> 239         if (status == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added"> 240             return nullptr;</span>
<span class="line-added"> 241         }</span>
 242         // Locales with no specific rules (all numbers have the &quot;other&quot; category
 243         //   will return a U_MISSING_RESOURCE_ERROR at this point. This is not
 244         //   an error.
 245         locRule =  UnicodeString(PLURAL_DEFAULT_RULE);
 246         status = U_ZERO_ERROR;
 247     }
 248     PluralRuleParser parser;
<span class="line-modified"> 249     parser.parse(locRule, newObj.getAlias(), status);</span>
 250         //  TODO: should rule parse errors be returned, or
 251         //        should we silently use default rules?
 252         //        Original impl used default rules.
 253         //        Ask the question to ICU Core.
 254 
<span class="line-modified"> 255     return newObj.orphan();</span>
 256 }
 257 
 258 UnicodeString
 259 PluralRules::select(int32_t number) const {
 260     return select(FixedDecimal(number));
 261 }
 262 
 263 UnicodeString
 264 PluralRules::select(double number) const {
 265     return select(FixedDecimal(number));
 266 }
 267 
<span class="line-added"> 268 UnicodeString</span>
<span class="line-added"> 269 PluralRules::select(const number::FormattedNumber&amp; number, UErrorCode&amp; status) const {</span>
<span class="line-added"> 270     DecimalQuantity dq;</span>
<span class="line-added"> 271     number.getDecimalQuantity(dq, status);</span>
<span class="line-added"> 272     if (U_FAILURE(status)) {</span>
<span class="line-added"> 273         return ICU_Utility::makeBogusString();</span>
<span class="line-added"> 274     }</span>
<span class="line-added"> 275     return select(dq);</span>
<span class="line-added"> 276 }</span>
<span class="line-added"> 277 </span>
 278 UnicodeString
 279 PluralRules::select(const IFixedDecimal &amp;number) const {
<span class="line-modified"> 280     if (mRules == nullptr) {</span>
 281         return UnicodeString(TRUE, PLURAL_DEFAULT_RULE, -1);
 282     }
 283     else {
 284         return mRules-&gt;select(number);
 285     }
 286 }
 287 
 288 
 289 
 290 StringEnumeration*
 291 PluralRules::getKeywords(UErrorCode&amp; status) const {


 292     if (U_FAILURE(status)) {
<span class="line-modified"> 293         return nullptr;</span>

 294     }
<span class="line-modified"> 295     if (U_FAILURE(mInternalStatus)) {</span>
<span class="line-modified"> 296         status = mInternalStatus;</span>
<span class="line-added"> 297         return nullptr;</span>
<span class="line-added"> 298     }</span>
<span class="line-added"> 299     LocalPointer&lt;StringEnumeration&gt; nameEnumerator(new PluralKeywordEnumeration(mRules, status), status);</span>
<span class="line-added"> 300     if (U_FAILURE(status)) {</span>
<span class="line-added"> 301         return nullptr;</span>
<span class="line-added"> 302     }</span>
<span class="line-added"> 303     return nameEnumerator.orphan();</span>
 304 }
 305 
 306 double
 307 PluralRules::getUniqueKeywordValue(const UnicodeString&amp; /* keyword */) {
 308   // Not Implemented.
 309   return UPLRULES_NO_UNIQUE_VALUE;
 310 }
 311 
 312 int32_t
 313 PluralRules::getAllKeywordValues(const UnicodeString &amp; /* keyword */, double * /* dest */,
 314                                  int32_t /* destCapacity */, UErrorCode&amp; error) {
 315     error = U_UNSUPPORTED_ERROR;
 316     return 0;
 317 }
 318 
 319 
 320 static double scaleForInt(double d) {
 321     double scale = 1.0;
 322     while (d != floor(d)) {
 323         d = d * 10.0;
</pre>
<hr />
<pre>
 381                 //    zeros to the right of the decimal.
 382                 //    This results in test failures with values mapping back to a different keyword.
 383                 double sampleValue = n/scale;
 384                 if (!(sampleValue == floor(sampleValue) &amp;&amp; fixedLo.visibleDecimalDigitCount &gt; 0)) {
 385                     dest[sampleCount++] = sampleValue;
 386                 }
 387                 if (sampleCount &gt;= destCapacity) {
 388                     break;
 389                 }
 390             }
 391         }
 392         sampleStartIdx = sampleEndIdx + 1;
 393     }
 394     return sampleCount;
 395 }
 396 
 397 
 398 int32_t
 399 PluralRules::getSamples(const UnicodeString &amp;keyword, double *dest,
 400                         int32_t destCapacity, UErrorCode&amp; status) {
<span class="line-added"> 401     if (destCapacity == 0 || U_FAILURE(status)) {</span>
<span class="line-added"> 402         return 0;</span>
<span class="line-added"> 403     }</span>
<span class="line-added"> 404     if (U_FAILURE(mInternalStatus)) {</span>
<span class="line-added"> 405         status = mInternalStatus;</span>
<span class="line-added"> 406         return 0;</span>
<span class="line-added"> 407     }</span>
 408     RuleChain *rc = rulesForKeyword(keyword);
<span class="line-modified"> 409     if (rc == nullptr) {</span>
 410         return 0;
 411     }
 412     int32_t numSamples = getSamplesFromString(rc-&gt;fIntegerSamples, dest, destCapacity, status);
 413     if (numSamples == 0) {
 414         numSamples = getSamplesFromString(rc-&gt;fDecimalSamples, dest, destCapacity, status);
 415     }
 416     return numSamples;
 417 }
 418 
 419 
 420 RuleChain *PluralRules::rulesForKeyword(const UnicodeString &amp;keyword) const {
 421     RuleChain *rc;
<span class="line-modified"> 422     for (rc = mRules; rc != nullptr; rc = rc-&gt;fNext) {</span>
 423         if (rc-&gt;fKeyword == keyword) {
 424             break;
 425         }
 426     }
 427     return rc;
 428 }
 429 
 430 
 431 UBool
 432 PluralRules::isKeyword(const UnicodeString&amp; keyword) const {
 433     if (0 == keyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
 434         return true;
 435     }
<span class="line-modified"> 436     return rulesForKeyword(keyword) != nullptr;</span>
 437 }
 438 
 439 UnicodeString
 440 PluralRules::getKeywordOther() const {
 441     return UnicodeString(TRUE, PLURAL_KEYWORD_OTHER, 5);
 442 }
 443 
 444 UBool
 445 PluralRules::operator==(const PluralRules&amp; other) const  {
 446     const UnicodeString *ptrKeyword;
 447     UErrorCode status= U_ZERO_ERROR;
 448 
 449     if ( this == &amp;other ) {
 450         return TRUE;
 451     }
 452     LocalPointer&lt;StringEnumeration&gt; myKeywordList(getKeywords(status));
 453     LocalPointer&lt;StringEnumeration&gt; otherKeywordList(other.getKeywords(status));
 454     if (U_FAILURE(status)) {
 455         return FALSE;
 456     }
 457 
 458     if (myKeywordList-&gt;count(status)!=otherKeywordList-&gt;count(status)) {
 459         return FALSE;
 460     }
 461     myKeywordList-&gt;reset(status);
<span class="line-modified"> 462     while ((ptrKeyword=myKeywordList-&gt;snext(status))!=nullptr) {</span>
 463         if (!other.isKeyword(*ptrKeyword)) {
 464             return FALSE;
 465         }
 466     }
 467     otherKeywordList-&gt;reset(status);
<span class="line-modified"> 468     while ((ptrKeyword=otherKeywordList-&gt;snext(status))!=nullptr) {</span>
 469         if (!this-&gt;isKeyword(*ptrKeyword)) {
 470             return FALSE;
 471         }
 472     }
 473     if (U_FAILURE(status)) {
 474         return FALSE;
 475     }
 476 
 477     return TRUE;
 478 }
 479 
 480 
 481 void
 482 PluralRuleParser::parse(const UnicodeString&amp; ruleData, PluralRules *prules, UErrorCode &amp;status)
 483 {
 484     if (U_FAILURE(status)) {
 485         return;
 486     }
 487     U_ASSERT(ruleIndex == 0);    // Parsers are good for a single use only!
 488     ruleSrc = &amp;ruleData;
 489 
 490     while (ruleIndex&lt; ruleSrc-&gt;length()) {
 491         getNextToken(status);
 492         if (U_FAILURE(status)) {
 493             return;
 494         }
 495         checkSyntax(status);
 496         if (U_FAILURE(status)) {
 497             return;
 498         }
 499         switch (type) {
 500         case tAnd:
<span class="line-modified"> 501             U_ASSERT(curAndConstraint != nullptr);</span>
<span class="line-modified"> 502             curAndConstraint = curAndConstraint-&gt;add(status);</span>
 503             break;
 504         case tOr:
 505             {
<span class="line-modified"> 506                 U_ASSERT(currentChain != nullptr);</span>
 507                 OrConstraint *orNode=currentChain-&gt;ruleHeader;
<span class="line-modified"> 508                 while (orNode-&gt;next != nullptr) {</span>
 509                     orNode = orNode-&gt;next;
 510                 }
 511                 orNode-&gt;next= new OrConstraint();
<span class="line-added"> 512                 if (orNode-&gt;next == nullptr) {</span>
<span class="line-added"> 513                     status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 514                     break;</span>
<span class="line-added"> 515                 }</span>
 516                 orNode=orNode-&gt;next;
<span class="line-modified"> 517                 orNode-&gt;next=nullptr;</span>
<span class="line-modified"> 518                 curAndConstraint = orNode-&gt;add(status);</span>
 519             }
 520             break;
 521         case tIs:
<span class="line-modified"> 522             U_ASSERT(curAndConstraint != nullptr);</span>
 523             U_ASSERT(curAndConstraint-&gt;value == -1);
<span class="line-modified"> 524             U_ASSERT(curAndConstraint-&gt;rangeList == nullptr);</span>
 525             break;
 526         case tNot:
<span class="line-modified"> 527             U_ASSERT(curAndConstraint != nullptr);</span>
 528             curAndConstraint-&gt;negated=TRUE;
 529             break;
 530 
 531         case tNotEqual:
 532             curAndConstraint-&gt;negated=TRUE;
 533             U_FALLTHROUGH;
 534         case tIn:
 535         case tWithin:
 536         case tEqual:
<span class="line-modified"> 537             {</span>
<span class="line-modified"> 538                 U_ASSERT(curAndConstraint != nullptr);</span>
<span class="line-modified"> 539                 LocalPointer&lt;UVector32&gt; newRangeList(new UVector32(status), status);</span>
<span class="line-modified"> 540                 if (U_FAILURE(status)) {</span>
<span class="line-modified"> 541                     break;</span>
<span class="line-modified"> 542                 }</span>
<span class="line-modified"> 543                 curAndConstraint-&gt;rangeList = newRangeList.orphan();</span>
<span class="line-modified"> 544                 curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Low</span>
<span class="line-added"> 545                 curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Hi</span>
<span class="line-added"> 546                 rangeLowIdx = 0;</span>
<span class="line-added"> 547                 rangeHiIdx  = 1;</span>
<span class="line-added"> 548                 curAndConstraint-&gt;value=PLURAL_RANGE_HIGH;</span>
<span class="line-added"> 549                 curAndConstraint-&gt;integerOnly = (type != tWithin);</span>
<span class="line-added"> 550             }</span>
 551             break;
 552         case tNumber:
<span class="line-modified"> 553             U_ASSERT(curAndConstraint != nullptr);</span>
 554             if ( (curAndConstraint-&gt;op==AndConstraint::MOD)&amp;&amp;
 555                  (curAndConstraint-&gt;opNum == -1 ) ) {
 556                 curAndConstraint-&gt;opNum=getNumberValue(token);
 557             }
 558             else {
<span class="line-modified"> 559                 if (curAndConstraint-&gt;rangeList == nullptr) {</span>
 560                     // this is for an &#39;is&#39; rule
 561                     curAndConstraint-&gt;value = getNumberValue(token);
 562                 } else {
 563                     // this is for an &#39;in&#39; or &#39;within&#39; rule
 564                     if (curAndConstraint-&gt;rangeList-&gt;elementAti(rangeLowIdx) == -1) {
 565                         curAndConstraint-&gt;rangeList-&gt;setElementAt(getNumberValue(token), rangeLowIdx);
 566                         curAndConstraint-&gt;rangeList-&gt;setElementAt(getNumberValue(token), rangeHiIdx);
 567                     }
 568                     else {
 569                         curAndConstraint-&gt;rangeList-&gt;setElementAt(getNumberValue(token), rangeHiIdx);
 570                         if (curAndConstraint-&gt;rangeList-&gt;elementAti(rangeLowIdx) &gt;
 571                                 curAndConstraint-&gt;rangeList-&gt;elementAti(rangeHiIdx)) {
 572                             // Range Lower bound &gt; Range Upper bound.
 573                             // U_UNEXPECTED_TOKEN seems a little funny, but it is consistently
 574                             // used for all plural rule parse errors.
 575                             status = U_UNEXPECTED_TOKEN;
 576                             break;
 577                         }
 578                     }
 579                 }
 580             }
 581             break;
 582         case tComma:
 583             // TODO: rule syntax checking is inadequate, can happen with badly formed rules.
 584             //       Catch cases like &quot;n mod 10, is 1&quot; here instead.
<span class="line-modified"> 585             if (curAndConstraint == nullptr || curAndConstraint-&gt;rangeList == nullptr) {</span>
 586                 status = U_UNEXPECTED_TOKEN;
 587                 break;
 588             }
 589             U_ASSERT(curAndConstraint-&gt;rangeList-&gt;size() &gt;= 2);
 590             rangeLowIdx = curAndConstraint-&gt;rangeList-&gt;size();
 591             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Low
 592             rangeHiIdx = curAndConstraint-&gt;rangeList-&gt;size();
 593             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Hi
 594             break;
 595         case tMod:
<span class="line-modified"> 596             U_ASSERT(curAndConstraint != nullptr);</span>
 597             curAndConstraint-&gt;op=AndConstraint::MOD;
 598             break;
 599         case tVariableN:
 600         case tVariableI:
 601         case tVariableF:
 602         case tVariableT:
 603         case tVariableV:
<span class="line-modified"> 604             U_ASSERT(curAndConstraint != nullptr);</span>
 605             curAndConstraint-&gt;digitsType = type;
 606             break;
 607         case tKeyword:
 608             {
 609             RuleChain *newChain = new RuleChain;
<span class="line-modified"> 610             if (newChain == nullptr) {</span>
 611                 status = U_MEMORY_ALLOCATION_ERROR;
 612                 break;
 613             }
 614             newChain-&gt;fKeyword = token;
<span class="line-modified"> 615             if (prules-&gt;mRules == nullptr) {</span>
 616                 prules-&gt;mRules = newChain;
 617             } else {
 618                 // The new rule chain goes at the end of the linked list of rule chains,
 619                 //   unless there is an &quot;other&quot; keyword &amp; chain. &quot;other&quot; must remain last.
 620                 RuleChain *insertAfter = prules-&gt;mRules;
<span class="line-modified"> 621                 while (insertAfter-&gt;fNext!=nullptr &amp;&amp;</span>
 622                        insertAfter-&gt;fNext-&gt;fKeyword.compare(PLURAL_KEYWORD_OTHER, 5) != 0 ){
 623                     insertAfter=insertAfter-&gt;fNext;
 624                 }
 625                 newChain-&gt;fNext = insertAfter-&gt;fNext;
 626                 insertAfter-&gt;fNext = newChain;
 627             }
 628             OrConstraint *orNode = new OrConstraint();
<span class="line-added"> 629             if (orNode == nullptr) {</span>
<span class="line-added"> 630                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 631                 break;</span>
<span class="line-added"> 632             }</span>
 633             newChain-&gt;ruleHeader = orNode;
<span class="line-modified"> 634             curAndConstraint = orNode-&gt;add(status);</span>
 635             currentChain = newChain;
 636             }
 637             break;
 638 
 639         case tInteger:
 640             for (;;) {
 641                 getNextToken(status);
 642                 if (U_FAILURE(status) || type == tSemiColon || type == tEOF || type == tAt) {
 643                     break;
 644                 }
 645                 if (type == tEllipsis) {
 646                     currentChain-&gt;fIntegerSamplesUnbounded = TRUE;
 647                     continue;
 648                 }
 649                 currentChain-&gt;fIntegerSamples.append(token);
 650             }
 651             break;
 652 
 653         case tDecimal:
 654             for (;;) {
</pre>
<hr />
<pre>
 664             }
 665             break;
 666 
 667         default:
 668             break;
 669         }
 670         prevType=type;
 671         if (U_FAILURE(status)) {
 672             break;
 673         }
 674     }
 675 }
 676 
 677 UnicodeString
 678 PluralRules::getRuleFromResource(const Locale&amp; locale, UPluralType type, UErrorCode&amp; errCode) {
 679     UnicodeString emptyStr;
 680 
 681     if (U_FAILURE(errCode)) {
 682         return emptyStr;
 683     }
<span class="line-modified"> 684     LocalUResourceBundlePointer rb(ures_openDirect(nullptr, &quot;plurals&quot;, &amp;errCode));</span>
 685     if(U_FAILURE(errCode)) {
 686         return emptyStr;
 687     }
 688     const char *typeKey;
 689     switch (type) {
 690     case UPLURAL_TYPE_CARDINAL:
 691         typeKey = &quot;locales&quot;;
 692         break;
 693     case UPLURAL_TYPE_ORDINAL:
 694         typeKey = &quot;locales_ordinals&quot;;
 695         break;
 696     default:
 697         // Must not occur: The caller should have checked for valid types.
 698         errCode = U_ILLEGAL_ARGUMENT_ERROR;
 699         return emptyStr;
 700     }
<span class="line-modified"> 701     LocalUResourceBundlePointer locRes(ures_getByKey(rb.getAlias(), typeKey, nullptr, &amp;errCode));</span>
 702     if(U_FAILURE(errCode)) {
 703         return emptyStr;
 704     }
 705     int32_t resLen=0;
<span class="line-modified"> 706     const char *curLocaleName=locale.getBaseName();</span>
 707     const UChar* s = ures_getStringByKey(locRes.getAlias(), curLocaleName, &amp;resLen, &amp;errCode);
 708 
<span class="line-modified"> 709     if (s == nullptr) {</span>
 710         // Check parent locales.
 711         UErrorCode status = U_ZERO_ERROR;
 712         char parentLocaleName[ULOC_FULLNAME_CAPACITY];
<span class="line-modified"> 713         const char *curLocaleName2=locale.getBaseName();</span>
<span class="line-modified"> 714         uprv_strcpy(parentLocaleName, curLocaleName2);</span>
 715 
 716         while (uloc_getParent(parentLocaleName, parentLocaleName,
 717                                        ULOC_FULLNAME_CAPACITY, &amp;status) &gt; 0) {
 718             resLen=0;
 719             s = ures_getStringByKey(locRes.getAlias(), parentLocaleName, &amp;resLen, &amp;status);
<span class="line-modified"> 720             if (s != nullptr) {</span>
 721                 errCode = U_ZERO_ERROR;
 722                 break;
 723             }
 724             status = U_ZERO_ERROR;
 725         }
 726     }
<span class="line-modified"> 727     if (s==nullptr) {</span>
 728         return emptyStr;
 729     }
 730 
 731     char setKey[256];
 732     u_UCharsToChars(s, setKey, resLen + 1);
 733     // printf(&quot;\n PluralRule: %s\n&quot;, setKey);
 734 
<span class="line-modified"> 735     LocalUResourceBundlePointer ruleRes(ures_getByKey(rb.getAlias(), &quot;rules&quot;, nullptr, &amp;errCode));</span>
 736     if(U_FAILURE(errCode)) {
 737         return emptyStr;
 738     }
<span class="line-modified"> 739     LocalUResourceBundlePointer setRes(ures_getByKey(ruleRes.getAlias(), setKey, nullptr, &amp;errCode));</span>
 740     if (U_FAILURE(errCode)) {
 741         return emptyStr;
 742     }
 743 
 744     int32_t numberKeys = ures_getSize(setRes.getAlias());
 745     UnicodeString result;
<span class="line-modified"> 746     const char *key=nullptr;</span>
 747     for(int32_t i=0; i&lt;numberKeys; ++i) {   // Keys are zero, one, few, ...
 748         UnicodeString rules = ures_getNextUnicodeString(setRes.getAlias(), &amp;key, &amp;errCode);
 749         UnicodeString uKey(key, -1, US_INV);
 750         result.append(uKey);
 751         result.append(COLON);
 752         result.append(rules);
 753         result.append(SEMI_COLON);
 754     }
 755     return result;
 756 }
 757 
 758 
 759 UnicodeString
 760 PluralRules::getRules() const {
 761     UnicodeString rules;
<span class="line-modified"> 762     if (mRules != nullptr) {</span>
 763         mRules-&gt;dumpRules(rules);
 764     }
 765     return rules;
 766 }
 767 













 768 AndConstraint::AndConstraint(const AndConstraint&amp; other) {
<span class="line-added"> 769     this-&gt;fInternalStatus = other.fInternalStatus;</span>
<span class="line-added"> 770     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added"> 771         return; // stop early if the object we are copying from is invalid.</span>
<span class="line-added"> 772     }</span>
 773     this-&gt;op = other.op;
 774     this-&gt;opNum=other.opNum;
 775     this-&gt;value=other.value;
<span class="line-modified"> 776     if (other.rangeList != nullptr) {</span>
<span class="line-modified"> 777         LocalPointer&lt;UVector32&gt; newRangeList(new UVector32(fInternalStatus), fInternalStatus);</span>
<span class="line-modified"> 778         if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-modified"> 779             return;</span>
<span class="line-modified"> 780         }</span>
<span class="line-added"> 781         this-&gt;rangeList = newRangeList.orphan();</span>
<span class="line-added"> 782         this-&gt;rangeList-&gt;assign(*other.rangeList, fInternalStatus);</span>
 783     }
 784     this-&gt;integerOnly=other.integerOnly;
 785     this-&gt;negated=other.negated;
 786     this-&gt;digitsType = other.digitsType;
<span class="line-modified"> 787     if (other.next != nullptr) {</span>



 788         this-&gt;next = new AndConstraint(*other.next);
<span class="line-added"> 789         if (this-&gt;next == nullptr) {</span>
<span class="line-added"> 790             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 791         }</span>
 792     }
 793 }
 794 
 795 AndConstraint::~AndConstraint() {
 796     delete rangeList;
<span class="line-modified"> 797     rangeList = nullptr;</span>
<span class="line-modified"> 798     delete next;</span>
<span class="line-modified"> 799     next = nullptr;</span>
 800 }
 801 

 802 UBool
 803 AndConstraint::isFulfilled(const IFixedDecimal &amp;number) {
 804     UBool result = TRUE;
 805     if (digitsType == none) {
 806         // An empty AndConstraint, created by a rule with a keyword but no following expression.
 807         return TRUE;
 808     }
 809 
 810     PluralOperand operand = tokenTypeToPluralOperand(digitsType);
 811     double n = number.getPluralOperand(operand);     // pulls n | i | v | f value for the number.
 812                                                      // Will always be positive.
 813                                                      // May be non-integer (n option only)
 814     do {
 815         if (integerOnly &amp;&amp; n != uprv_floor(n)) {
 816             result = FALSE;
 817             break;
 818         }
 819 
 820         if (op == MOD) {
 821             n = fmod(n, opNum);
 822         }
<span class="line-modified"> 823         if (rangeList == nullptr) {</span>
 824             result = value == -1 ||    // empty rule
 825                      n == value;       //  &#39;is&#39; rule
 826             break;
 827         }
 828         result = FALSE;                // &#39;in&#39; or &#39;within&#39; rule
 829         for (int32_t r=0; r&lt;rangeList-&gt;size(); r+=2) {
 830             if (rangeList-&gt;elementAti(r) &lt;= n &amp;&amp; n &lt;= rangeList-&gt;elementAti(r+1)) {
 831                 result = TRUE;
 832                 break;
 833             }
 834         }
 835     } while (FALSE);
 836 
 837     if (negated) {
 838         result = !result;
 839     }
 840     return result;
 841 }
 842 

 843 AndConstraint*
<span class="line-modified"> 844 AndConstraint::add(UErrorCode&amp; status) {</span>
<span class="line-modified"> 845     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added"> 846         status = fInternalStatus;</span>
<span class="line-added"> 847         return nullptr;</span>
<span class="line-added"> 848     }</span>
 849     this-&gt;next = new AndConstraint();
<span class="line-added"> 850     if (this-&gt;next == nullptr) {</span>
<span class="line-added"> 851         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 852     }</span>
 853     return this-&gt;next;
 854 }
 855 




 856 
 857 OrConstraint::OrConstraint(const OrConstraint&amp; other) {
<span class="line-modified"> 858     this-&gt;fInternalStatus = other.fInternalStatus;</span>
<span class="line-modified"> 859     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added"> 860         return; // stop early if the object we are copying from is invalid.</span>
 861     }
<span class="line-modified"> 862     if ( other.childNode != nullptr ) {</span>
 863         this-&gt;childNode = new AndConstraint(*(other.childNode));
<span class="line-added"> 864         if (this-&gt;childNode == nullptr) {</span>
<span class="line-added"> 865             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 866             return;</span>
<span class="line-added"> 867         }</span>
 868     }
<span class="line-modified"> 869     if (other.next != nullptr ) {</span>



 870         this-&gt;next = new OrConstraint(*(other.next));
<span class="line-added"> 871         if (this-&gt;next == nullptr) {</span>
<span class="line-added"> 872             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 873             return;</span>
<span class="line-added"> 874         }</span>
<span class="line-added"> 875         if (U_FAILURE(this-&gt;next-&gt;fInternalStatus)) {</span>
<span class="line-added"> 876             this-&gt;fInternalStatus = this-&gt;next-&gt;fInternalStatus;</span>
<span class="line-added"> 877         }</span>
 878     }
 879 }
 880 
 881 OrConstraint::~OrConstraint() {
<span class="line-modified"> 882     delete childNode;</span>
<span class="line-modified"> 883     childNode = nullptr;</span>
<span class="line-modified"> 884     delete next;</span>
<span class="line-modified"> 885     next = nullptr;</span>


 886 }
 887 
 888 AndConstraint*
<span class="line-modified"> 889 OrConstraint::add(UErrorCode&amp; status) {</span>
<span class="line-modified"> 890     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added"> 891         status = fInternalStatus;</span>
<span class="line-added"> 892         return nullptr;</span>
<span class="line-added"> 893     }</span>
 894     OrConstraint *curOrConstraint=this;
 895     {
<span class="line-modified"> 896         while (curOrConstraint-&gt;next!=nullptr) {</span>
 897             curOrConstraint = curOrConstraint-&gt;next;
 898         }
<span class="line-modified"> 899         U_ASSERT(curOrConstraint-&gt;childNode == nullptr);</span>
 900         curOrConstraint-&gt;childNode = new AndConstraint();
<span class="line-added"> 901         if (curOrConstraint-&gt;childNode == nullptr) {</span>
<span class="line-added"> 902             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 903         }</span>
 904     }
 905     return curOrConstraint-&gt;childNode;
 906 }
 907 
 908 UBool
 909 OrConstraint::isFulfilled(const IFixedDecimal &amp;number) {
 910     OrConstraint* orRule=this;
 911     UBool result=FALSE;
 912 
<span class="line-modified"> 913     while (orRule!=nullptr &amp;&amp; !result) {</span>
 914         result=TRUE;
 915         AndConstraint* andRule = orRule-&gt;childNode;
<span class="line-modified"> 916         while (andRule!=nullptr &amp;&amp; result) {</span>
 917             result = andRule-&gt;isFulfilled(number);
 918             andRule=andRule-&gt;next;
 919         }
 920         orRule = orRule-&gt;next;
 921     }
 922 
 923     return result;
 924 }
 925 
 926 




 927 RuleChain::RuleChain(const RuleChain&amp; other) :
<span class="line-modified"> 928         fKeyword(other.fKeyword), fDecimalSamples(other.fDecimalSamples),</span>
 929         fIntegerSamples(other.fIntegerSamples), fDecimalSamplesUnbounded(other.fDecimalSamplesUnbounded),
<span class="line-modified"> 930         fIntegerSamplesUnbounded(other.fIntegerSamplesUnbounded), fInternalStatus(other.fInternalStatus) {</span>
<span class="line-modified"> 931     if (U_FAILURE(this-&gt;fInternalStatus)) {</span>
<span class="line-added"> 932         return; // stop early if the object we are copying from is invalid.</span>
<span class="line-added"> 933     }</span>
<span class="line-added"> 934     if (other.ruleHeader != nullptr) {</span>
 935         this-&gt;ruleHeader = new OrConstraint(*(other.ruleHeader));
<span class="line-added"> 936         if (this-&gt;ruleHeader == nullptr) {</span>
<span class="line-added"> 937             this-&gt;fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 938         }</span>
<span class="line-added"> 939         else if (U_FAILURE(this-&gt;ruleHeader-&gt;fInternalStatus)) {</span>
<span class="line-added"> 940             // If the OrConstraint wasn&#39;t fully copied, then set our status to failure as well.</span>
<span class="line-added"> 941             this-&gt;fInternalStatus = this-&gt;ruleHeader-&gt;fInternalStatus;</span>
<span class="line-added"> 942             return; // exit early.</span>
<span class="line-added"> 943         }</span>
 944     }
<span class="line-modified"> 945     if (other.fNext != nullptr ) {</span>
 946         this-&gt;fNext = new RuleChain(*other.fNext);
<span class="line-added"> 947         if (this-&gt;fNext == nullptr) {</span>
<span class="line-added"> 948             this-&gt;fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 949         }</span>
<span class="line-added"> 950         else if (U_FAILURE(this-&gt;fNext-&gt;fInternalStatus)) {</span>
<span class="line-added"> 951             // If the RuleChain wasn&#39;t fully copied, then set our status to failure as well.</span>
<span class="line-added"> 952             this-&gt;fInternalStatus = this-&gt;fNext-&gt;fInternalStatus;</span>
<span class="line-added"> 953         }</span>
 954     }
 955 }
 956 
 957 RuleChain::~RuleChain() {
 958     delete fNext;
 959     delete ruleHeader;
 960 }
 961 

 962 UnicodeString
 963 RuleChain::select(const IFixedDecimal &amp;number) const {
 964     if (!number.isNaN() &amp;&amp; !number.isInfinite()) {
<span class="line-modified"> 965         for (const RuleChain *rules = this; rules != nullptr; rules = rules-&gt;fNext) {</span>
 966              if (rules-&gt;ruleHeader-&gt;isFulfilled(number)) {
 967                  return rules-&gt;fKeyword;
 968              }
 969         }
 970     }
 971     return UnicodeString(TRUE, PLURAL_KEYWORD_OTHER, 5);
 972 }
 973 
 974 static UnicodeString tokenString(tokenType tok) {
 975     UnicodeString s;
 976     switch (tok) {
 977       case tVariableN:
 978         s.append(LOW_N); break;
 979       case tVariableI:
 980         s.append(LOW_I); break;
 981       case tVariableF:
 982         s.append(LOW_F); break;
 983       case tVariableV:
 984         s.append(LOW_V); break;
 985       case tVariableT:
 986         s.append(LOW_T); break;
 987       default:
 988         s.append(TILDE);
 989     }
 990     return s;
 991 }
 992 
 993 void
 994 RuleChain::dumpRules(UnicodeString&amp; result) {
 995     UChar digitString[16];
 996 
<span class="line-modified"> 997     if ( ruleHeader != nullptr ) {</span>
 998         result +=  fKeyword;
 999         result += COLON;
1000         result += SPACE;
1001         OrConstraint* orRule=ruleHeader;
<span class="line-modified">1002         while ( orRule != nullptr ) {</span>
1003             AndConstraint* andRule=orRule-&gt;childNode;
<span class="line-modified">1004             while ( andRule != nullptr ) {</span>
<span class="line-modified">1005                 if ((andRule-&gt;op==AndConstraint::NONE) &amp;&amp;  (andRule-&gt;rangeList==nullptr) &amp;&amp; (andRule-&gt;value == -1)) {</span>
1006                     // Empty Rules.
<span class="line-modified">1007                 } else if ( (andRule-&gt;op==AndConstraint::NONE) &amp;&amp; (andRule-&gt;rangeList==nullptr) ) {</span>
1008                     result += tokenString(andRule-&gt;digitsType);
1009                     result += UNICODE_STRING_SIMPLE(&quot; is &quot;);
1010                     if (andRule-&gt;negated) {
1011                         result += UNICODE_STRING_SIMPLE(&quot;not &quot;);
1012                     }
1013                     uprv_itou(digitString,16, andRule-&gt;value,10,0);
1014                     result += UnicodeString(digitString);
1015                 }
1016                 else {
1017                     result += tokenString(andRule-&gt;digitsType);
1018                     result += SPACE;
1019                     if (andRule-&gt;op==AndConstraint::MOD) {
1020                         result += UNICODE_STRING_SIMPLE(&quot;mod &quot;);
1021                         uprv_itou(digitString,16, andRule-&gt;opNum,10,0);
1022                         result += UnicodeString(digitString);
1023                     }
<span class="line-modified">1024                     if (andRule-&gt;rangeList==nullptr) {</span>
1025                         if (andRule-&gt;negated) {
1026                             result += UNICODE_STRING_SIMPLE(&quot; is not &quot;);
1027                             uprv_itou(digitString,16, andRule-&gt;value,10,0);
1028                             result += UnicodeString(digitString);
1029                         }
1030                         else {
1031                             result += UNICODE_STRING_SIMPLE(&quot; is &quot;);
1032                             uprv_itou(digitString,16, andRule-&gt;value,10,0);
1033                             result += UnicodeString(digitString);
1034                         }
1035                     }
1036                     else {
1037                         if (andRule-&gt;negated) {
1038                             if ( andRule-&gt;integerOnly ) {
1039                                 result += UNICODE_STRING_SIMPLE(&quot; not in &quot;);
1040                             }
1041                             else {
1042                                 result += UNICODE_STRING_SIMPLE(&quot; not within &quot;);
1043                             }
1044                         }
</pre>
<hr />
<pre>
1047                                 result += UNICODE_STRING_SIMPLE(&quot; in &quot;);
1048                             }
1049                             else {
1050                                 result += UNICODE_STRING_SIMPLE(&quot; within &quot;);
1051                             }
1052                         }
1053                         for (int32_t r=0; r&lt;andRule-&gt;rangeList-&gt;size(); r+=2) {
1054                             int32_t rangeLo = andRule-&gt;rangeList-&gt;elementAti(r);
1055                             int32_t rangeHi = andRule-&gt;rangeList-&gt;elementAti(r+1);
1056                             uprv_itou(digitString,16, rangeLo, 10, 0);
1057                             result += UnicodeString(digitString);
1058                             result += UNICODE_STRING_SIMPLE(&quot;..&quot;);
1059                             uprv_itou(digitString,16, rangeHi, 10,0);
1060                             result += UnicodeString(digitString);
1061                             if (r+2 &lt; andRule-&gt;rangeList-&gt;size()) {
1062                                 result += UNICODE_STRING_SIMPLE(&quot;, &quot;);
1063                             }
1064                         }
1065                     }
1066                 }
<span class="line-modified">1067                 if ( (andRule=andRule-&gt;next) != nullptr) {</span>
1068                     result += UNICODE_STRING_SIMPLE(&quot; and &quot;);
1069                 }
1070             }
<span class="line-modified">1071             if ( (orRule = orRule-&gt;next) != nullptr ) {</span>
1072                 result += UNICODE_STRING_SIMPLE(&quot; or &quot;);
1073             }
1074         }
1075     }
<span class="line-modified">1076     if ( fNext != nullptr ) {</span>
1077         result += UNICODE_STRING_SIMPLE(&quot;; &quot;);
1078         fNext-&gt;dumpRules(result);
1079     }
1080 }
1081 
1082 
1083 UErrorCode
1084 RuleChain::getKeywords(int32_t capacityOfKeywords, UnicodeString* keywords, int32_t&amp; arraySize) const {
<span class="line-added">1085     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added">1086         return fInternalStatus;</span>
<span class="line-added">1087     }</span>
1088     if ( arraySize &lt; capacityOfKeywords-1 ) {
1089         keywords[arraySize++]=fKeyword;
1090     }
1091     else {
1092         return U_BUFFER_OVERFLOW_ERROR;
1093     }
1094 
<span class="line-modified">1095     if ( fNext != nullptr ) {</span>
1096         return fNext-&gt;getKeywords(capacityOfKeywords, keywords, arraySize);
1097     }
1098     else {
1099         return U_ZERO_ERROR;
1100     }
1101 }
1102 
1103 UBool
1104 RuleChain::isKeyword(const UnicodeString&amp; keywordParam) const {
1105     if ( fKeyword == keywordParam ) {
1106         return TRUE;
1107     }
1108 
<span class="line-modified">1109     if ( fNext != nullptr ) {</span>
1110         return fNext-&gt;isKeyword(keywordParam);
1111     }
1112     else {
1113         return FALSE;
1114     }
1115 }
1116 
1117 
1118 PluralRuleParser::PluralRuleParser() :
1119         ruleIndex(0), token(), type(none), prevType(none),
<span class="line-modified">1120         curAndConstraint(nullptr), currentChain(nullptr), rangeLowIdx(-1), rangeHiIdx(-1)</span>
1121 {
1122 }
1123 
1124 PluralRuleParser::~PluralRuleParser() {
1125 }
1126 
1127 
1128 int32_t
1129 PluralRuleParser::getNumberValue(const UnicodeString&amp; token) {
1130     int32_t i;
1131     char digits[128];
1132 
1133     i = token.extract(0, token.length(), digits, UPRV_LENGTHOF(digits), US_INV);
1134     digits[i]=&#39;\0&#39;;
1135 
1136     return((int32_t)atoi(digits));
1137 }
1138 
1139 
1140 void
</pre>
<hr />
<pre>
1398         keyType = tNot;
1399     } else if (0 == token.compare(PK_MOD, 3)) {
1400         keyType = tMod;
1401     } else if (0 == token.compare(PK_OR, 2)) {
1402         keyType = tOr;
1403     } else if (0 == token.compare(PK_DECIMAL, 7)) {
1404         keyType = tDecimal;
1405     } else if (0 == token.compare(PK_INTEGER, 7)) {
1406         keyType = tInteger;
1407     }
1408     return keyType;
1409 }
1410 
1411 
1412 PluralKeywordEnumeration::PluralKeywordEnumeration(RuleChain *header, UErrorCode&amp; status)
1413         : pos(0), fKeywordNames(status) {
1414     if (U_FAILURE(status)) {
1415         return;
1416     }
1417     fKeywordNames.setDeleter(uprv_deleteUObject);
<span class="line-modified">1418     UBool  addKeywordOther = TRUE;</span>
<span class="line-modified">1419     RuleChain *node = header;</span>
<span class="line-modified">1420     while (node != nullptr) {</span>
<span class="line-modified">1421         auto newElem = new UnicodeString(node-&gt;fKeyword);</span>
<span class="line-added">1422         if (newElem == nullptr) {</span>
<span class="line-added">1423             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1424             return;</span>
<span class="line-added">1425         }</span>
<span class="line-added">1426         fKeywordNames.addElement(newElem, status);</span>
1427         if (U_FAILURE(status)) {
<span class="line-added">1428             delete newElem;</span>
1429             return;
1430         }
1431         if (0 == node-&gt;fKeyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
<span class="line-modified">1432             addKeywordOther = FALSE;</span>
1433         }
<span class="line-modified">1434         node = node-&gt;fNext;</span>
1435     }
1436 
1437     if (addKeywordOther) {
<span class="line-modified">1438         auto newElem = new UnicodeString(PLURAL_KEYWORD_OTHER);</span>
<span class="line-added">1439         if (newElem == nullptr) {</span>
<span class="line-added">1440             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1441             return;</span>
<span class="line-added">1442         }</span>
<span class="line-added">1443         fKeywordNames.addElement(newElem, status);</span>
<span class="line-added">1444         if (U_FAILURE(status)) {</span>
<span class="line-added">1445             delete newElem;</span>
<span class="line-added">1446             return;</span>
<span class="line-added">1447         }</span>
1448     }
1449 }
1450 
1451 const UnicodeString*
1452 PluralKeywordEnumeration::snext(UErrorCode&amp; status) {
1453     if (U_SUCCESS(status) &amp;&amp; pos &lt; fKeywordNames.size()) {
1454         return (const UnicodeString*)fKeywordNames.elementAt(pos++);
1455     }
<span class="line-modified">1456     return nullptr;</span>
1457 }
1458 
1459 void
1460 PluralKeywordEnumeration::reset(UErrorCode&amp; /*status*/) {
1461     pos=0;
1462 }
1463 
1464 int32_t
1465 PluralKeywordEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">1466     return fKeywordNames.size();</span>
1467 }
1468 
1469 PluralKeywordEnumeration::~PluralKeywordEnumeration() {
1470 }
1471 
1472 PluralOperand tokenTypeToPluralOperand(tokenType tt) {
1473     switch(tt) {
1474     case tVariableN:
1475         return PLURAL_OPERAND_N;
1476     case tVariableI:
1477         return PLURAL_OPERAND_I;
1478     case tVariableF:
1479         return PLURAL_OPERAND_F;
1480     case tVariableV:
1481         return PLURAL_OPERAND_V;
1482     case tVariableT:
1483         return PLURAL_OPERAND_T;
1484     default:
<span class="line-modified">1485         UPRV_UNREACHABLE;  // unexpected.</span>

1486     }
1487 }
1488 
1489 FixedDecimal::FixedDecimal(double n, int32_t v, int64_t f) {
1490     init(n, v, f);
1491     // check values. TODO make into unit test.
1492     //
1493     //            long visiblePower = (int) Math.pow(10, v);
1494     //            if (decimalDigits &gt; visiblePower) {
1495     //                throw new IllegalArgumentException();
1496     //            }
1497     //            double fraction = intValue + (decimalDigits / (double) visiblePower);
1498     //            if (fraction != source) {
1499     //                double diff = Math.abs(fraction - source)/(Math.abs(fraction) + Math.abs(source));
1500     //                if (diff &gt; 0.00000001d) {
1501     //                    throw new IllegalArgumentException();
1502     //                }
1503     //            }
1504 }
1505 
</pre>
<hr />
<pre>
1677             // Do not let the decimalDigits value overflow if there are many trailing zeros.
1678             // Limit the value to 18 digits, the most that a 64 bit int can fully represent.
1679             if (decimalDigits &gt;= 100000000000000000LL) {
1680                 break;
1681             }
1682             decimalDigits *= 10;
1683         }
1684         visibleDecimalDigitCount += numTrailingFractionZeros;
1685     }
1686 }
1687 
1688 
1689 double FixedDecimal::getPluralOperand(PluralOperand operand) const {
1690     switch(operand) {
1691         case PLURAL_OPERAND_N: return source;
1692         case PLURAL_OPERAND_I: return static_cast&lt;double&gt;(intValue);
1693         case PLURAL_OPERAND_F: return static_cast&lt;double&gt;(decimalDigits);
1694         case PLURAL_OPERAND_T: return static_cast&lt;double&gt;(decimalDigitsWithoutTrailingZeros);
1695         case PLURAL_OPERAND_V: return visibleDecimalDigitCount;
1696         default:
<span class="line-modified">1697              UPRV_UNREACHABLE;  // unexpected.</span>

1698     }
1699 }
1700 
1701 bool FixedDecimal::isNaN() const {
1702     return _isNaN;
1703 }
1704 
1705 bool FixedDecimal::isInfinite() const {
1706     return _isInfinite;
1707 }
1708 
1709 bool FixedDecimal::hasIntegerValue() const {
1710     return _hasIntegerValue;
1711 }
1712 
1713 bool FixedDecimal::isNanOrInfinity() const {
1714     return _isNaN || _isInfinite;
1715 }
1716 
1717 int32_t FixedDecimal::getVisibleFractionDigitCount() const {
1718     return visibleDecimalDigitCount;
1719 }
1720 
1721 
1722 
1723 PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &amp;status) {


1724     fOpenStatus = status;
1725     if (U_FAILURE(status)) {
1726         return;
1727     }
<span class="line-modified">1728     fOpenStatus = U_ZERO_ERROR; // clear any warnings.</span>
<span class="line-modified">1729     LocalUResourceBundlePointer rb(ures_openDirect(nullptr, &quot;plurals&quot;, &amp;fOpenStatus));</span>
<span class="line-modified">1730     fLocales = ures_getByKey(rb.getAlias(), &quot;locales&quot;, nullptr, &amp;fOpenStatus);</span>
1731 }
1732 
1733 PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration() {
1734     ures_close(fLocales);
1735     ures_close(fRes);
<span class="line-modified">1736     fLocales = nullptr;</span>
<span class="line-modified">1737     fRes = nullptr;</span>
1738 }
1739 
1740 const char *PluralAvailableLocalesEnumeration::next(int32_t *resultLength, UErrorCode &amp;status) {
1741     if (U_FAILURE(status)) {
<span class="line-modified">1742         return nullptr;</span>
1743     }
1744     if (U_FAILURE(fOpenStatus)) {
1745         status = fOpenStatus;
<span class="line-modified">1746         return nullptr;</span>
1747     }
1748     fRes = ures_getNextResource(fLocales, fRes, &amp;status);
<span class="line-modified">1749     if (fRes == nullptr || U_FAILURE(status)) {</span>
1750         if (status == U_INDEX_OUTOFBOUNDS_ERROR) {
1751             status = U_ZERO_ERROR;
1752         }
<span class="line-modified">1753         return nullptr;</span>
1754     }
1755     const char *result = ures_getKey(fRes);
<span class="line-modified">1756     if (resultLength != nullptr) {</span>
1757         *resultLength = static_cast&lt;int32_t&gt;(uprv_strlen(result));
1758     }
1759     return result;
1760 }
1761 
1762 
1763 void PluralAvailableLocalesEnumeration::reset(UErrorCode &amp;status) {
1764     if (U_FAILURE(status)) {
1765        return;
1766     }
1767     if (U_FAILURE(fOpenStatus)) {
1768         status = fOpenStatus;
1769         return;
1770     }
1771     ures_resetIterator(fLocales);
1772 }
1773 
1774 int32_t PluralAvailableLocalesEnumeration::count(UErrorCode &amp;status) const {
1775     if (U_FAILURE(status)) {
1776         return 0;
</pre>
</td>
</tr>
</table>
<center><a href="plurfmt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="plurrule_impl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>