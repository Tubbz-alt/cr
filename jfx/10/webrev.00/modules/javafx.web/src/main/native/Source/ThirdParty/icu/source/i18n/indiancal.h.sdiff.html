<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/indiancal.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="indiancal.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="islamcal.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/indiancal.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 51  * 11 Magha       30             January 21
 52  * 12 Phalguna    30             February 20
 53 
 54  * In leap years, Chaitra has 31 days and starts on March 21 instead.
 55  * The leap years of Gregorian calendar and Indian National Calendar are in synchornization.
 56  * So When its a leap year in Gregorian calendar then Chaitra has 31 days.
 57  *
 58  * The Years
 59  * Years are counted in the Saka Era, which starts its year 0 in 78AD (by gregorian calendar).
 60  * So for eg. 9th June 2006 by Gregorian Calendar, is same as 19th of Jyaistha in 1928 of Saka
 61  * era by Indian National Calendar.
 62  * &lt;p&gt;
 63  * The Indian Calendar has only one allowable era: &lt;code&gt;Saka Era&lt;/code&gt;.  If the
 64  * calendar is not in lenient mode (see &lt;code&gt;setLenient&lt;/code&gt;), dates before
 65  * 1/1/1 Saka Era are rejected with an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.
 66  * &lt;p&gt;
 67  * @internal
 68  */
 69 
 70 
<span class="line-modified"> 71 class IndianCalendar : public Calendar {</span>
 72 public:
 73   /**
 74    * Useful constants for IndianCalendar.
 75    * @internal
 76    */
 77   enum EEras {
 78     /**
 79      * Constant for Chaitra, the 1st month of the Indian year.
 80      */
 81       CHAITRA,
 82 
 83       /**
 84      * Constant for Vaisakha, the 2nd month of the Indian year.
 85      */
 86       VAISAKHA,
 87 
 88       /**
 89      * Constant for Jyaistha, the 3rd month of the Indian year.
 90      */
 91       JYAISTHA,
</pre>
<hr />
<pre>
257   // UObject stuff
258  public:
259   /**
260    * @return   The class ID for this object. All objects of a given class have the
261    *           same class ID. Objects of other classes have different class IDs.
262    * @internal
263    */
264   virtual UClassID getDynamicClassID(void) const;
265 
266   /**
267    * Return the class ID for this class. This is useful only for comparing to a return
268    * value from getDynamicClassID(). For example:
269    *
270    *      Base* polymorphic_pointer = createPolymorphicObject();
271    *      if (polymorphic_pointer-&gt;getDynamicClassID() ==
272    *          Derived::getStaticClassID()) ...
273    *
274    * @return   The class ID for all objects of this class.
275    * @internal
276    */
<span class="line-modified">277   U_I18N_API static UClassID U_EXPORT2 getStaticClassID(void);</span>
278 
279   /**
<span class="line-modified">280    * return the calendar type, &quot;buddhist&quot;.</span>
281    *
282    * @return calendar type
283    * @internal
284    */
285   virtual const char * getType() const;
286 
287 private:
288   IndianCalendar(); // default constructor not implemented
289 
290   // Default century.
291 protected:
292 
293   /**
294    * (Overrides Calendar) Return true if the current date for this Calendar is in
295    * Daylight Savings Time. Recognizes DST_OFFSET, if it is set.
296    *
297    * @param status Fill-in parameter which receives the status of this operation.
298    * @return   True if the current date for this Calendar is in Daylight Savings Time,
299    *           false, otherwise.
300    * @internal
</pre>
<hr />
<pre>
303 
304 
305   /**
306    * Returns TRUE because the Indian Calendar does have a default century
307    * @internal
308    */
309   virtual UBool haveDefaultCentury() const;
310 
311   /**
312    * Returns the date of the start of the default century
313    * @return start of century - in milliseconds since epoch, 1970
314    * @internal
315    */
316   virtual UDate defaultCenturyStart() const;
317 
318   /**
319    * Returns the year in which the default century begins
320    * @internal
321    */
322   virtual int32_t defaultCenturyStartYear() const;
<span class="line-removed">323 </span>
<span class="line-removed">324  private: // default century stuff.</span>
<span class="line-removed">325   /**</span>
<span class="line-removed">326    * The system maintains a static default century start date.  This is initialized</span>
<span class="line-removed">327    * the first time it is used.  Before then, it is set to SYSTEM_DEFAULT_CENTURY to</span>
<span class="line-removed">328    * indicate an uninitialized state.  Once the system default century date and year</span>
<span class="line-removed">329    * are set, they do not change.</span>
<span class="line-removed">330    */</span>
<span class="line-removed">331   static UDate         fgSystemDefaultCenturyStart;</span>
<span class="line-removed">332 </span>
<span class="line-removed">333   /**</span>
<span class="line-removed">334    * See documentation for systemDefaultCenturyStart.</span>
<span class="line-removed">335    */</span>
<span class="line-removed">336   static int32_t          fgSystemDefaultCenturyStartYear;</span>
<span class="line-removed">337 </span>
<span class="line-removed">338   /**</span>
<span class="line-removed">339    * Default value that indicates the defaultCenturyStartYear is unitialized</span>
<span class="line-removed">340    */</span>
<span class="line-removed">341   static const int32_t    fgSystemDefaultCenturyYear;</span>
<span class="line-removed">342 </span>
<span class="line-removed">343   /**</span>
<span class="line-removed">344    * start of default century, as a date</span>
<span class="line-removed">345    */</span>
<span class="line-removed">346   static const UDate        fgSystemDefaultCentury;</span>
<span class="line-removed">347 </span>
<span class="line-removed">348   /**</span>
<span class="line-removed">349    * Returns the beginning date of the 100-year window that dates</span>
<span class="line-removed">350    * with 2-digit years are considered to fall within.</span>
<span class="line-removed">351    */</span>
<span class="line-removed">352   UDate         internalGetDefaultCenturyStart(void) const;</span>
<span class="line-removed">353 </span>
<span class="line-removed">354   /**</span>
<span class="line-removed">355    * Returns the first year of the 100-year window that dates with</span>
<span class="line-removed">356    * 2-digit years are considered to fall within.</span>
<span class="line-removed">357    */</span>
<span class="line-removed">358   int32_t          internalGetDefaultCenturyStartYear(void) const;</span>
<span class="line-removed">359 </span>
<span class="line-removed">360   /**</span>
<span class="line-removed">361    * Initializes the 100-year window that dates with 2-digit years</span>
<span class="line-removed">362    * are considered to fall within so that its start date is 80 years</span>
<span class="line-removed">363    * before the current time.</span>
<span class="line-removed">364    */</span>
<span class="line-removed">365   static void  initializeSystemDefaultCentury(void);</span>
366 };
367 
368 U_NAMESPACE_END
369 
370 #endif
371 #endif
372 
373 
374 
</pre>
</td>
<td>
<hr />
<pre>
 51  * 11 Magha       30             January 21
 52  * 12 Phalguna    30             February 20
 53 
 54  * In leap years, Chaitra has 31 days and starts on March 21 instead.
 55  * The leap years of Gregorian calendar and Indian National Calendar are in synchornization.
 56  * So When its a leap year in Gregorian calendar then Chaitra has 31 days.
 57  *
 58  * The Years
 59  * Years are counted in the Saka Era, which starts its year 0 in 78AD (by gregorian calendar).
 60  * So for eg. 9th June 2006 by Gregorian Calendar, is same as 19th of Jyaistha in 1928 of Saka
 61  * era by Indian National Calendar.
 62  * &lt;p&gt;
 63  * The Indian Calendar has only one allowable era: &lt;code&gt;Saka Era&lt;/code&gt;.  If the
 64  * calendar is not in lenient mode (see &lt;code&gt;setLenient&lt;/code&gt;), dates before
 65  * 1/1/1 Saka Era are rejected with an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.
 66  * &lt;p&gt;
 67  * @internal
 68  */
 69 
 70 
<span class="line-modified"> 71 class U_I18N_API IndianCalendar : public Calendar {</span>
 72 public:
 73   /**
 74    * Useful constants for IndianCalendar.
 75    * @internal
 76    */
 77   enum EEras {
 78     /**
 79      * Constant for Chaitra, the 1st month of the Indian year.
 80      */
 81       CHAITRA,
 82 
 83       /**
 84      * Constant for Vaisakha, the 2nd month of the Indian year.
 85      */
 86       VAISAKHA,
 87 
 88       /**
 89      * Constant for Jyaistha, the 3rd month of the Indian year.
 90      */
 91       JYAISTHA,
</pre>
<hr />
<pre>
257   // UObject stuff
258  public:
259   /**
260    * @return   The class ID for this object. All objects of a given class have the
261    *           same class ID. Objects of other classes have different class IDs.
262    * @internal
263    */
264   virtual UClassID getDynamicClassID(void) const;
265 
266   /**
267    * Return the class ID for this class. This is useful only for comparing to a return
268    * value from getDynamicClassID(). For example:
269    *
270    *      Base* polymorphic_pointer = createPolymorphicObject();
271    *      if (polymorphic_pointer-&gt;getDynamicClassID() ==
272    *          Derived::getStaticClassID()) ...
273    *
274    * @return   The class ID for all objects of this class.
275    * @internal
276    */
<span class="line-modified">277   static UClassID U_EXPORT2 getStaticClassID(void);</span>
278 
279   /**
<span class="line-modified">280    * return the calendar type, &quot;indian&quot;.</span>
281    *
282    * @return calendar type
283    * @internal
284    */
285   virtual const char * getType() const;
286 
287 private:
288   IndianCalendar(); // default constructor not implemented
289 
290   // Default century.
291 protected:
292 
293   /**
294    * (Overrides Calendar) Return true if the current date for this Calendar is in
295    * Daylight Savings Time. Recognizes DST_OFFSET, if it is set.
296    *
297    * @param status Fill-in parameter which receives the status of this operation.
298    * @return   True if the current date for this Calendar is in Daylight Savings Time,
299    *           false, otherwise.
300    * @internal
</pre>
<hr />
<pre>
303 
304 
305   /**
306    * Returns TRUE because the Indian Calendar does have a default century
307    * @internal
308    */
309   virtual UBool haveDefaultCentury() const;
310 
311   /**
312    * Returns the date of the start of the default century
313    * @return start of century - in milliseconds since epoch, 1970
314    * @internal
315    */
316   virtual UDate defaultCenturyStart() const;
317 
318   /**
319    * Returns the year in which the default century begins
320    * @internal
321    */
322   virtual int32_t defaultCenturyStartYear() const;











































323 };
324 
325 U_NAMESPACE_END
326 
327 #endif
328 #endif
329 
330 
331 
</pre>
</td>
</tr>
</table>
<center><a href="indiancal.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="islamcal.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>