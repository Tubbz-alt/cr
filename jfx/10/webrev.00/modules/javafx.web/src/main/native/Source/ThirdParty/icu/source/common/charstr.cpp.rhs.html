<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/charstr.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 *   Copyright (C) 2010-2015, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 *******************************************************************************
  8 *   file name:  charstr.cpp
  9 *   encoding:   UTF-8
 10 *   tab size:   8 (not used)
 11 *   indentation:4
 12 *
 13 *   created on: 2010may19
 14 *   created by: Markus W. Scherer
 15 */
 16 
 17 #include &quot;unicode/utypes.h&quot;
 18 #include &quot;unicode/putil.h&quot;
 19 #include &quot;charstr.h&quot;
 20 #include &quot;cmemory.h&quot;
 21 #include &quot;cstring.h&quot;
 22 #include &quot;uinvchar.h&quot;
 23 
 24 U_NAMESPACE_BEGIN
 25 
 26 CharString::CharString(CharString&amp;&amp; src) U_NOEXCEPT
 27         : buffer(std::move(src.buffer)), len(src.len) {
 28     src.len = 0;  // not strictly necessary because we make no guarantees on the source string
 29 }
 30 
 31 CharString&amp; CharString::operator=(CharString&amp;&amp; src) U_NOEXCEPT {
 32     buffer = std::move(src.buffer);
 33     len = src.len;
 34     src.len = 0;  // not strictly necessary because we make no guarantees on the source string
 35     return *this;
 36 }
 37 
 38 CharString &amp;CharString::copyFrom(const CharString &amp;s, UErrorCode &amp;errorCode) {
 39     if(U_SUCCESS(errorCode) &amp;&amp; this!=&amp;s &amp;&amp; ensureCapacity(s.len+1, 0, errorCode)) {
 40         len=s.len;
 41         uprv_memcpy(buffer.getAlias(), s.buffer.getAlias(), len+1);
 42     }
 43     return *this;
 44 }
 45 
 46 int32_t CharString::lastIndexOf(char c) const {
 47     for(int32_t i=len; i&gt;0;) {
 48         if(buffer[--i]==c) {
 49             return i;
 50         }
 51     }
 52     return -1;
 53 }
 54 
 55 CharString &amp;CharString::truncate(int32_t newLength) {
 56     if(newLength&lt;0) {
 57         newLength=0;
 58     }
 59     if(newLength&lt;len) {
 60         buffer[len=newLength]=0;
 61     }
 62     return *this;
 63 }
 64 
 65 CharString &amp;CharString::append(char c, UErrorCode &amp;errorCode) {
 66     if(ensureCapacity(len+2, 0, errorCode)) {
 67         buffer[len++]=c;
 68         buffer[len]=0;
 69     }
 70     return *this;
 71 }
 72 
 73 CharString &amp;CharString::append(const char *s, int32_t sLength, UErrorCode &amp;errorCode) {
 74     if(U_FAILURE(errorCode)) {
 75         return *this;
 76     }
 77     if(sLength&lt;-1 || (s==NULL &amp;&amp; sLength!=0)) {
 78         errorCode=U_ILLEGAL_ARGUMENT_ERROR;
 79         return *this;
 80     }
 81     if(sLength&lt;0) {
<a name="1" id="anc1"></a><span class="line-modified"> 82         sLength= static_cast&lt;int32_t&gt;(uprv_strlen(s));</span>
 83     }
 84     if(sLength&gt;0) {
 85         if(s==(buffer.getAlias()+len)) {
 86             // The caller wrote into the getAppendBuffer().
 87             if(sLength&gt;=(buffer.getCapacity()-len)) {
 88                 // The caller wrote too much.
 89                 errorCode=U_INTERNAL_PROGRAM_ERROR;
 90             } else {
 91                 buffer[len+=sLength]=0;
 92             }
 93         } else if(buffer.getAlias()&lt;=s &amp;&amp; s&lt;(buffer.getAlias()+len) &amp;&amp;
 94                   sLength&gt;=(buffer.getCapacity()-len)
 95         ) {
 96             // (Part of) this string is appended to itself which requires reallocation,
 97             // so we have to make a copy of the substring and append that.
 98             return append(CharString(s, sLength, errorCode), errorCode);
 99         } else if(ensureCapacity(len+sLength+1, 0, errorCode)) {
100             uprv_memcpy(buffer.getAlias()+len, s, sLength);
101             buffer[len+=sLength]=0;
102         }
103     }
104     return *this;
105 }
106 
107 char *CharString::getAppendBuffer(int32_t minCapacity,
108                                   int32_t desiredCapacityHint,
109                                   int32_t &amp;resultCapacity,
110                                   UErrorCode &amp;errorCode) {
111     if(U_FAILURE(errorCode)) {
112         resultCapacity=0;
113         return NULL;
114     }
115     int32_t appendCapacity=buffer.getCapacity()-len-1;  // -1 for NUL
116     if(appendCapacity&gt;=minCapacity) {
117         resultCapacity=appendCapacity;
118         return buffer.getAlias()+len;
119     }
120     if(ensureCapacity(len+minCapacity+1, len+desiredCapacityHint+1, errorCode)) {
121         resultCapacity=buffer.getCapacity()-len-1;
122         return buffer.getAlias()+len;
123     }
124     resultCapacity=0;
125     return NULL;
126 }
127 
128 CharString &amp;CharString::appendInvariantChars(const UnicodeString &amp;s, UErrorCode &amp;errorCode) {
<a name="2" id="anc2"></a><span class="line-added">129     return appendInvariantChars(s.getBuffer(), s.length(), errorCode);</span>
<span class="line-added">130 }</span>
<span class="line-added">131 </span>
<span class="line-added">132 CharString &amp;CharString::appendInvariantChars(const UChar* uchars, int32_t ucharsLen, UErrorCode &amp;errorCode) {</span>
133     if(U_FAILURE(errorCode)) {
134         return *this;
135     }
<a name="3" id="anc3"></a><span class="line-modified">136     if (!uprv_isInvariantUString(uchars, ucharsLen)) {</span>
137         errorCode = U_INVARIANT_CONVERSION_ERROR;
138         return *this;
139     }
<a name="4" id="anc4"></a><span class="line-modified">140     if(ensureCapacity(len+ucharsLen+1, 0, errorCode)) {</span>
<span class="line-modified">141         u_UCharsToChars(uchars, buffer.getAlias()+len, ucharsLen);</span>
<span class="line-added">142         len += ucharsLen;</span>
<span class="line-added">143         buffer[len] = 0;</span>
144     }
145     return *this;
146 }
147 
148 UBool CharString::ensureCapacity(int32_t capacity,
149                                  int32_t desiredCapacityHint,
150                                  UErrorCode &amp;errorCode) {
151     if(U_FAILURE(errorCode)) {
152         return FALSE;
153     }
154     if(capacity&gt;buffer.getCapacity()) {
155         if(desiredCapacityHint==0) {
156             desiredCapacityHint=capacity+buffer.getCapacity();
157         }
158         if( (desiredCapacityHint&lt;=capacity || buffer.resize(desiredCapacityHint, len+1)==NULL) &amp;&amp;
159             buffer.resize(capacity, len+1)==NULL
160         ) {
161             errorCode=U_MEMORY_ALLOCATION_ERROR;
162             return FALSE;
163         }
164     }
165     return TRUE;
166 }
167 
168 CharString &amp;CharString::appendPathPart(StringPiece s, UErrorCode &amp;errorCode) {
169     if(U_FAILURE(errorCode)) {
170         return *this;
171     }
172     if(s.length()==0) {
173         return *this;
174     }
175     char c;
176     if(len&gt;0 &amp;&amp; (c=buffer[len-1])!=U_FILE_SEP_CHAR &amp;&amp; c!=U_FILE_ALT_SEP_CHAR) {
177         append(U_FILE_SEP_CHAR, errorCode);
178     }
179     append(s, errorCode);
180     return *this;
181 }
182 
183 CharString &amp;CharString::ensureEndsWithFileSeparator(UErrorCode &amp;errorCode) {
184     char c;
185     if(U_SUCCESS(errorCode) &amp;&amp; len&gt;0 &amp;&amp;
186             (c=buffer[len-1])!=U_FILE_SEP_CHAR &amp;&amp; c!=U_FILE_ALT_SEP_CHAR) {
187         append(U_FILE_SEP_CHAR, errorCode);
188     }
189     return *this;
190 }
191 
192 U_NAMESPACE_END
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>