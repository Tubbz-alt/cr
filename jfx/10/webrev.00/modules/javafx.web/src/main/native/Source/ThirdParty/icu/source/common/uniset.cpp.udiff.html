<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uniset.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="unifiedcache.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uniset_closure.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uniset.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -12,10 +12,11 @@</span>
  
  #include &quot;unicode/utypes.h&quot;
  #include &quot;unicode/parsepos.h&quot;
  #include &quot;unicode/symtable.h&quot;
  #include &quot;unicode/uniset.h&quot;
<span class="udiff-line-added">+ #include &quot;unicode/ustring.h&quot;</span>
  #include &quot;unicode/utf8.h&quot;
  #include &quot;unicode/utf16.h&quot;
  #include &quot;ruleiter.h&quot;
  #include &quot;cmemory.h&quot;
  #include &quot;cstring.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -51,15 +52,12 @@</span>
  #define UNICODESET_HIGH 0x0110000
  
  // LOW &lt;= all valid values. ZERO for codepoints
  #define UNICODESET_LOW 0x000000
  
<span class="udiff-line-modified-removed">- // initial storage. Must be &gt;= 0</span>
<span class="udiff-line-modified-removed">- #define START_EXTRA 16</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // extra amount for growth. Must be &gt;= 0</span>
<span class="udiff-line-removed">- #define GROW_EXTRA START_EXTRA</span>
<span class="udiff-line-modified-added">+ /** Max list [0, 1, 2, ..., max code point, HIGH] */</span>
<span class="udiff-line-modified-added">+ constexpr int32_t MAX_LENGTH = UNICODESET_HIGH + 1;</span>
  
  U_NAMESPACE_BEGIN
  
  SymbolTable::~SymbolTable() {}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -135,134 +133,86 @@</span>
      const UnicodeString &amp;a = *(const UnicodeString*)t1.pointer;
      const UnicodeString &amp;b = *(const UnicodeString*)t2.pointer;
      return a.compare(b);
  }
  
<span class="udiff-line-added">+ UBool UnicodeSet::hasStrings() const {</span>
<span class="udiff-line-added">+     return strings != nullptr &amp;&amp; !strings-&gt;isEmpty();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int32_t UnicodeSet::stringsSize() const {</span>
<span class="udiff-line-added">+     return strings == nullptr ? 0 : strings-&gt;size();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ UBool UnicodeSet::stringsContains(const UnicodeString &amp;s) const {</span>
<span class="udiff-line-added">+     return strings != nullptr &amp;&amp; strings-&gt;contains((void*) &amp;s);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //----------------------------------------------------------------
  // Constructors &amp;c
  //----------------------------------------------------------------
  
  /**
   * Constructs an empty set.
   */
<span class="udiff-line-modified-removed">- UnicodeSet::UnicodeSet() :</span>
<span class="udiff-line-modified-removed">-     len(1), capacity(1 + START_EXTRA), list(0), bmpSet(0), buffer(0),</span>
<span class="udiff-line-removed">-     bufferCapacity(0), patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="udiff-line-removed">-     fFlags(0)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-removed">-     allocateStrings(status);</span>
<span class="udiff-line-removed">-     if (U_FAILURE(status)) {</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="udiff-line-removed">-     if(list!=NULL){</span>
<span class="udiff-line-removed">-         list[0] = UNICODESET_HIGH;</span>
<span class="udiff-line-removed">-     } else { // If memory allocation failed, set to bogus state.</span>
<span class="udiff-line-removed">-         setToBogus();</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+ UnicodeSet::UnicodeSet() {</span>
<span class="udiff-line-modified-added">+     list[0] = UNICODESET_HIGH;</span>
      _dbgct(this);
  }
  
  /**
   * Constructs a set containing the given range. If &lt;code&gt;end &gt;
   * start&lt;/code&gt; then an empty set is created.
   *
   * @param start first character, inclusive, of range
   * @param end last character, inclusive, of range
   */
<span class="udiff-line-modified-removed">- UnicodeSet::UnicodeSet(UChar32 start, UChar32 end) :</span>
<span class="udiff-line-modified-removed">-     len(1), capacity(1 + START_EXTRA), list(0), bmpSet(0), buffer(0),</span>
<span class="udiff-line-modified-removed">-     bufferCapacity(0), patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="udiff-line-removed">-     fFlags(0)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-removed">-     allocateStrings(status);</span>
<span class="udiff-line-removed">-     if (U_FAILURE(status)) {</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="udiff-line-removed">-     if(list!=NULL){</span>
<span class="udiff-line-removed">-         list[0] = UNICODESET_HIGH;</span>
<span class="udiff-line-removed">-         complement(start, end);</span>
<span class="udiff-line-removed">-     } else { // If memory allocation failed, set to bogus state.</span>
<span class="udiff-line-removed">-         setToBogus();</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+ UnicodeSet::UnicodeSet(UChar32 start, UChar32 end) {</span>
<span class="udiff-line-modified-added">+     list[0] = UNICODESET_HIGH;</span>
<span class="udiff-line-modified-added">+     add(start, end);</span>
      _dbgct(this);
  }
  
  /**
   * Constructs a set that is identical to the given UnicodeSet.
   */
<span class="udiff-line-modified-removed">- UnicodeSet::UnicodeSet(const UnicodeSet&amp; o) :</span>
<span class="udiff-line-modified-removed">-     UnicodeFilter(o),</span>
<span class="udiff-line-removed">-     len(0), capacity(o.isFrozen() ? o.len : o.len + GROW_EXTRA), list(0),</span>
<span class="udiff-line-removed">-     bmpSet(0),</span>
<span class="udiff-line-removed">-     buffer(0), bufferCapacity(0),</span>
<span class="udiff-line-removed">-     patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="udiff-line-removed">-     fFlags(0)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-removed">-     allocateStrings(status);</span>
<span class="udiff-line-removed">-     if (U_FAILURE(status)) {</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="udiff-line-removed">-     if(list!=NULL){</span>
<span class="udiff-line-removed">-         *this = o;</span>
<span class="udiff-line-removed">-     } else { // If memory allocation failed, set to bogus state.</span>
<span class="udiff-line-removed">-         setToBogus();</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+ UnicodeSet::UnicodeSet(const UnicodeSet&amp; o) : UnicodeFilter(o) {</span>
<span class="udiff-line-modified-added">+     *this = o;</span>
      _dbgct(this);
  }
  
  // Copy-construct as thawed.
<span class="udiff-line-modified-removed">- UnicodeSet::UnicodeSet(const UnicodeSet&amp; o, UBool /* asThawed */) :</span>
<span class="udiff-line-modified-removed">-     UnicodeFilter(o),</span>
<span class="udiff-line-removed">-     len(0), capacity(o.len + GROW_EXTRA), list(0),</span>
<span class="udiff-line-removed">-     bmpSet(0),</span>
<span class="udiff-line-removed">-     buffer(0), bufferCapacity(0),</span>
<span class="udiff-line-removed">-     patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="udiff-line-removed">-     fFlags(0)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-removed">-     allocateStrings(status);</span>
<span class="udiff-line-removed">-     if (U_FAILURE(status)) {</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="udiff-line-removed">-     if(list!=NULL){</span>
<span class="udiff-line-modified-added">+ UnicodeSet::UnicodeSet(const UnicodeSet&amp; o, UBool /* asThawed */) : UnicodeFilter(o) {</span>
<span class="udiff-line-modified-added">+     if (ensureCapacity(o.len)) {</span>
          // *this = o except for bmpSet and stringSpan
          len = o.len;
          uprv_memcpy(list, o.list, (size_t)len*sizeof(UChar32));
<span class="udiff-line-modified-removed">-         if (strings != NULL &amp;&amp; o.strings != NULL) {</span>
<span class="udiff-line-modified-removed">-             strings-&gt;assign(*o.strings, cloneUnicodeString, status);</span>
<span class="udiff-line-modified-removed">-         } else { // Invalid strings.</span>
<span class="udiff-line-modified-removed">-             setToBogus();</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-added">+         if (o.hasStrings()) {</span>
<span class="udiff-line-modified-added">+             UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-modified-added">+             if (!allocateStrings(status) ||</span>
<span class="udiff-line-modified-added">+                     (strings-&gt;assign(*o.strings, cloneUnicodeString, status), U_FAILURE(status))) {</span>
<span class="udiff-line-modified-added">+                 setToBogus();</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
          }
          if (o.pat) {
<span class="udiff-line-modified-removed">-             setPattern(UnicodeString(o.pat, o.patLen));</span>
<span class="udiff-line-modified-added">+             setPattern(o.pat, o.patLen);</span>
          }
<span class="udiff-line-modified-removed">-     } else { // If memory allocation failed, set to bogus state.</span>
<span class="udiff-line-removed">-         setToBogus();</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-modified-added">+         _dbgct(this);</span>
      }
<span class="udiff-line-removed">-     _dbgct(this);</span>
  }
  
  /**
   * Destructs the set.
   */
  UnicodeSet::~UnicodeSet() {
      _dbgdt(this); // first!
<span class="udiff-line-modified-removed">-     uprv_free(list);</span>
<span class="udiff-line-modified-added">+     if (list != stackList) {</span>
<span class="udiff-line-added">+         uprv_free(list);</span>
<span class="udiff-line-added">+     }</span>
      delete bmpSet;
<span class="udiff-line-modified-removed">-     if (buffer) {</span>
<span class="udiff-line-modified-added">+     if (buffer != stackList) {</span>
          uprv_free(buffer);
      }
      delete strings;
      delete stringSpan;
      releasePattern();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -270,54 +220,57 @@</span>
  
  /**
   * Assigns this object to be a copy of another.
   */
  UnicodeSet&amp; UnicodeSet::operator=(const UnicodeSet&amp; o) {
<span class="udiff-line-added">+     return copyFrom(o, FALSE);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ UnicodeSet&amp; UnicodeSet::copyFrom(const UnicodeSet&amp; o, UBool asThawed) {</span>
      if (this == &amp;o) {
          return *this;
      }
      if (isFrozen()) {
          return *this;
      }
      if (o.isBogus()) {
          setToBogus();
          return *this;
      }
<span class="udiff-line-modified-removed">-     UErrorCode ec = U_ZERO_ERROR;</span>
<span class="udiff-line-modified-removed">-     ensureCapacity(o.len, ec);</span>
<span class="udiff-line-modified-removed">-     if (U_FAILURE(ec)) {</span>
<span class="udiff-line-removed">-         return *this; // There is no way to report this error :-(</span>
<span class="udiff-line-modified-added">+     if (!ensureCapacity(o.len)) {</span>
<span class="udiff-line-modified-added">+         // ensureCapacity will mark the UnicodeSet as Bogus if OOM failure happens.</span>
<span class="udiff-line-modified-added">+         return *this;</span>
      }
      len = o.len;
      uprv_memcpy(list, o.list, (size_t)len*sizeof(UChar32));
<span class="udiff-line-modified-removed">-     if (o.bmpSet == NULL) {</span>
<span class="udiff-line-removed">-         bmpSet = NULL;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-modified-added">+     if (o.bmpSet != nullptr &amp;&amp; !asThawed) {</span>
          bmpSet = new BMPSet(*o.bmpSet, list, len);
          if (bmpSet == NULL) { // Check for memory allocation error.
              setToBogus();
              return *this;
          }
      }
<span class="udiff-line-modified-removed">-     if (strings != NULL &amp;&amp; o.strings != NULL) {</span>
<span class="udiff-line-modified-removed">-         strings-&gt;assign(*o.strings, cloneUnicodeString, ec);</span>
<span class="udiff-line-modified-removed">-     } else { // Invalid strings.</span>
<span class="udiff-line-modified-removed">-         setToBogus();</span>
<span class="udiff-line-modified-removed">-         return *this;</span>
<span class="udiff-line-modified-added">+     if (o.hasStrings()) {</span>
<span class="udiff-line-modified-added">+         UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-modified-added">+         if ((strings == nullptr &amp;&amp; !allocateStrings(status)) ||</span>
<span class="udiff-line-modified-added">+                 (strings-&gt;assign(*o.strings, cloneUnicodeString, status), U_FAILURE(status))) {</span>
<span class="udiff-line-modified-added">+             setToBogus();</span>
<span class="udiff-line-added">+             return *this;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     } else if (hasStrings()) {</span>
<span class="udiff-line-added">+         strings-&gt;removeAllElements();</span>
      }
<span class="udiff-line-modified-removed">-     if (o.stringSpan == NULL) {</span>
<span class="udiff-line-removed">-         stringSpan = NULL;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-modified-added">+     if (o.stringSpan != nullptr &amp;&amp; !asThawed) {</span>
          stringSpan = new UnicodeSetStringSpan(*o.stringSpan, *strings);
          if (stringSpan == NULL) { // Check for memory allocation error.
              setToBogus();
              return *this;
          }
      }
      releasePattern();
      if (o.pat) {
<span class="udiff-line-modified-removed">-         setPattern(UnicodeString(o.pat, o.patLen));</span>
<span class="udiff-line-modified-added">+         setPattern(o.pat, o.patLen);</span>
      }
      return *this;
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -346,27 +299,28 @@</span>
  UBool UnicodeSet::operator==(const UnicodeSet&amp; o) const {
      if (len != o.len) return FALSE;
      for (int32_t i = 0; i &lt; len; ++i) {
          if (list[i] != o.list[i]) return FALSE;
      }
<span class="udiff-line-modified-removed">-     if (*strings != *o.strings) return FALSE;</span>
<span class="udiff-line-modified-added">+     if (hasStrings() != o.hasStrings()) { return FALSE; }</span>
<span class="udiff-line-added">+     if (hasStrings() &amp;&amp; *strings != *o.strings) return FALSE;</span>
      return TRUE;
  }
  
  /**
   * Returns the hash code value for this set.
   *
   * @return the hash code value for this set.
   * @see Object#hashCode()
   */
  int32_t UnicodeSet::hashCode(void) const {
<span class="udiff-line-modified-removed">-     int32_t result = len;</span>
<span class="udiff-line-modified-added">+     uint32_t result = static_cast&lt;uint32_t&gt;(len);</span>
      for (int32_t i = 0; i &lt; len; ++i) {
<span class="udiff-line-modified-removed">-         result *= 1000003;</span>
<span class="udiff-line-modified-added">+         result *= 1000003u;</span>
          result += list[i];
      }
<span class="udiff-line-modified-removed">-     return result;</span>
<span class="udiff-line-modified-added">+     return static_cast&lt;int32_t&gt;(result);</span>
  }
  
  //----------------------------------------------------------------
  // Public API
  //----------------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -382,20 +336,20 @@</span>
      int32_t n = 0;
      int32_t count = getRangeCount();
      for (int32_t i = 0; i &lt; count; ++i) {
          n += getRangeEnd(i) - getRangeStart(i) + 1;
      }
<span class="udiff-line-modified-removed">-     return n + strings-&gt;size();</span>
<span class="udiff-line-modified-added">+     return n + stringsSize();</span>
  }
  
  /**
   * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements.
   *
   * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements.
   */
  UBool UnicodeSet::isEmpty(void) const {
<span class="udiff-line-modified-removed">-     return len == 1 &amp;&amp; strings-&gt;size() == 0;</span>
<span class="udiff-line-modified-added">+     return len == 1 &amp;&amp; !hasStrings();</span>
  }
  
  /**
   * Returns true if this set contains the given character.
   * @param c character to be checked for containment
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -491,11 +445,11 @@</span>
   */
  UBool UnicodeSet::contains(const UnicodeString&amp; s) const {
      if (s.length() == 0) return FALSE;
      int32_t cp = getSingleCP(s);
      if (cp &lt; 0) {
<span class="udiff-line-modified-removed">-         return strings-&gt;contains((void*) &amp;s);</span>
<span class="udiff-line-modified-added">+         return stringsContains(s);</span>
      } else {
          return contains((UChar32) cp);
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -513,12 +467,11 @@</span>
      for (int i=0; i&lt;n; ++i) {
          if (!contains(c.getRangeStart(i), c.getRangeEnd(i))) {
              return FALSE;
          }
      }
<span class="udiff-line-modified-removed">-     if (!strings-&gt;containsAll(*c.strings)) return FALSE;</span>
<span class="udiff-line-removed">-     return TRUE;</span>
<span class="udiff-line-modified-added">+     return !c.hasStrings() || (strings != nullptr &amp;&amp; strings-&gt;containsAll(*c.strings));</span>
  }
  
  /**
   * Returns true if this set contains all the characters
   * of the given string.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -560,12 +513,11 @@</span>
      for (int32_t i=0; i&lt;n; ++i) {
          if (!containsNone(c.getRangeStart(i), c.getRangeEnd(i))) {
              return FALSE;
          }
      }
<span class="udiff-line-modified-removed">-     if (!strings-&gt;containsNone(*c.strings)) return FALSE;</span>
<span class="udiff-line-removed">-     return TRUE;</span>
<span class="udiff-line-modified-added">+     return strings == nullptr || !c.hasStrings() || strings-&gt;containsNone(*c.strings);</span>
  }
  
  /**
   * Returns true if this set contains none of the characters
   * of the given string.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -602,11 +554,11 @@</span>
              }
          } else if ((low &amp; 0xFF) &lt;= v || v &lt;= (high &amp; 0xFF)) {
              return TRUE;
          }
      }
<span class="udiff-line-modified-removed">-     if (strings-&gt;size() != 0) {</span>
<span class="udiff-line-modified-added">+     if (hasStrings()) {</span>
          for (i=0; i&lt;strings-&gt;size(); ++i) {
              const UnicodeString&amp; s = *(const UnicodeString*)strings-&gt;elementAt(i);
              //if (s.length() == 0) {
              //    // Empty strings match everything
              //    return TRUE;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -637,11 +589,11 @@</span>
              return incremental ? U_PARTIAL_MATCH : U_MATCH;
          } else {
              return U_MISMATCH;
          }
      } else {
<span class="udiff-line-modified-removed">-         if (strings-&gt;size() != 0) { // try strings first</span>
<span class="udiff-line-modified-added">+         if (hasStrings()) { // try strings first</span>
  
              // might separate forward and backward loops later
              // for now they are combined
  
              // TODO Improve efficiency of this, at least in the forward
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -838,11 +790,43 @@</span>
   * @param end last character, inclusive, of range to be added
   * to this set.
   */
  UnicodeSet&amp; UnicodeSet::add(UChar32 start, UChar32 end) {
      if (pinCodePoint(start) &lt; pinCodePoint(end)) {
<span class="udiff-line-modified-removed">-         UChar32 range[3] = { start, end+1, UNICODESET_HIGH };</span>
<span class="udiff-line-modified-added">+         UChar32 limit = end + 1;</span>
<span class="udiff-line-added">+         // Fast path for adding a new range after the last one.</span>
<span class="udiff-line-added">+         // Odd list length: [..., lastStart, lastLimit, HIGH]</span>
<span class="udiff-line-added">+         if ((len &amp; 1) != 0) {</span>
<span class="udiff-line-added">+             // If the list is empty, set lastLimit low enough to not be adjacent to 0.</span>
<span class="udiff-line-added">+             UChar32 lastLimit = len == 1 ? -2 : list[len - 2];</span>
<span class="udiff-line-added">+             if (lastLimit &lt;= start &amp;&amp; !isFrozen() &amp;&amp; !isBogus()) {</span>
<span class="udiff-line-added">+                 if (lastLimit == start) {</span>
<span class="udiff-line-added">+                     // Extend the last range.</span>
<span class="udiff-line-added">+                     list[len - 2] = limit;</span>
<span class="udiff-line-added">+                     if (limit == UNICODESET_HIGH) {</span>
<span class="udiff-line-added">+                         --len;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     list[len - 1] = start;</span>
<span class="udiff-line-added">+                     if (limit &lt; UNICODESET_HIGH) {</span>
<span class="udiff-line-added">+                         if (ensureCapacity(len + 2)) {</span>
<span class="udiff-line-added">+                             list[len++] = limit;</span>
<span class="udiff-line-added">+                             list[len++] = UNICODESET_HIGH;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     } else {  // limit == UNICODESET_HIGH</span>
<span class="udiff-line-added">+                         if (ensureCapacity(len + 1)) {</span>
<span class="udiff-line-added">+                             list[len++] = UNICODESET_HIGH;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 releasePattern();</span>
<span class="udiff-line-added">+                 return *this;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // This is slow. Could be much faster using findCodePoint(start)</span>
<span class="udiff-line-added">+         // and modifying the list, dealing with adjacent &amp; overlapping ranges.</span>
<span class="udiff-line-added">+         UChar32 range[3] = { start, limit, UNICODESET_HIGH };</span>
          add(range, 2, 0);
      } else if (start == end) {
          add(start);
      }
      return *this;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -907,14 +891,13 @@</span>
      if (c == list[i]-1) {
          // c is before start of next range
          list[i] = c;
          // if we touched the HIGH mark, then add a new one
          if (c == (UNICODESET_HIGH - 1)) {
<span class="udiff-line-modified-removed">-             UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-modified-removed">-             ensureCapacity(len+1, status);</span>
<span class="udiff-line-modified-removed">-             if (U_FAILURE(status)) {</span>
<span class="udiff-line-removed">-                 return *this; // There is no way to report this error :-(</span>
<span class="udiff-line-modified-added">+             if (!ensureCapacity(len+1)) {</span>
<span class="udiff-line-modified-added">+                 // ensureCapacity will mark the object as Bogus if OOM failure happens.</span>
<span class="udiff-line-modified-added">+                 return *this;</span>
              }
              list[len++] = UNICODESET_HIGH;
          }
          if (i &gt; 0 &amp;&amp; c == list[i-1]) {
              // collapse adjacent ranges
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -952,24 +935,17 @@</span>
  
          // [..., start_k-1, limit_k-1, c, c+1, start_k, limit_k, ..., HIGH]
          //                             ^
          //                             list[i]
  
<span class="udiff-line-modified-removed">-         UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-modified-removed">-         ensureCapacity(len+2, status);</span>
<span class="udiff-line-modified-removed">-         if (U_FAILURE(status)) {</span>
<span class="udiff-line-removed">-             return *this; // There is no way to report this error :-(</span>
<span class="udiff-line-modified-added">+         if (!ensureCapacity(len+2)) {</span>
<span class="udiff-line-modified-added">+             // ensureCapacity will mark the object as Bogus if OOM failure happens.</span>
<span class="udiff-line-modified-added">+             return *this;</span>
          }
  
<span class="udiff-line-modified-removed">-         //for (int32_t k=len-1; k&gt;=i; --k) {</span>
<span class="udiff-line-modified-removed">-         //    list[k+2] = list[k];</span>
<span class="udiff-line-removed">-         //}</span>
<span class="udiff-line-removed">-         UChar32* src = list + len;</span>
<span class="udiff-line-removed">-         UChar32* dst = src + 2;</span>
<span class="udiff-line-removed">-         UChar32* srclimit = list + i;</span>
<span class="udiff-line-removed">-         while (src &gt; srclimit) *(--dst) = *(--src);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+         UChar32 *p = list + i;</span>
<span class="udiff-line-modified-added">+         uprv_memmove(p + 2, p, (len - i) * sizeof(*p));</span>
          list[i] = c;
          list[i+1] = c+1;
          len += 2;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1001,11 +977,11 @@</span>
   */
  UnicodeSet&amp; UnicodeSet::add(const UnicodeString&amp; s) {
      if (s.length() == 0 || isFrozen() || isBogus()) return *this;
      int32_t cp = getSingleCP(s);
      if (cp &lt; 0) {
<span class="udiff-line-modified-removed">-         if (!strings-&gt;contains((void*) &amp;s)) {</span>
<span class="udiff-line-modified-added">+         if (!stringsContains(s)) {</span>
              _add(s);
              releasePattern();
          }
      } else {
          add((UChar32)cp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1020,16 +996,20 @@</span>
   */
  void UnicodeSet::_add(const UnicodeString&amp; s) {
      if (isFrozen() || isBogus()) {
          return;
      }
<span class="udiff-line-added">+     UErrorCode ec = U_ZERO_ERROR;</span>
<span class="udiff-line-added">+     if (strings == nullptr &amp;&amp; !allocateStrings(ec)) {</span>
<span class="udiff-line-added">+         setToBogus();</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
      UnicodeString* t = new UnicodeString(s);
      if (t == NULL) { // Check for memory allocation error.
          setToBogus();
          return;
      }
<span class="udiff-line-removed">-     UErrorCode ec = U_ZERO_ERROR;</span>
      strings-&gt;sortedInsert(t, compareUnicodeString, ec);
      if (U_FAILURE(ec)) {
          setToBogus();
          delete t;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1108,11 +1088,14 @@</span>
      removeAll(set);
      return *this;
  }
  
  UnicodeSet&amp; UnicodeSet::removeAllStrings() {
<span class="udiff-line-modified-removed">-     strings-&gt;removeAllElements();</span>
<span class="udiff-line-modified-added">+     if (!isFrozen() &amp;&amp; hasStrings()) {</span>
<span class="udiff-line-added">+         strings-&gt;removeAllElements();</span>
<span class="udiff-line-added">+         releasePattern();</span>
<span class="udiff-line-added">+     }</span>
      return *this;
  }
  
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1204,12 +1187,13 @@</span>
   */
  UnicodeSet&amp; UnicodeSet::remove(const UnicodeString&amp; s) {
      if (s.length() == 0 || isFrozen() || isBogus()) return *this;
      int32_t cp = getSingleCP(s);
      if (cp &lt; 0) {
<span class="udiff-line-modified-removed">-         strings-&gt;removeElement((void*) &amp;s);</span>
<span class="udiff-line-modified-removed">-         releasePattern();</span>
<span class="udiff-line-modified-added">+         if (strings != nullptr &amp;&amp; strings-&gt;removeElement((void*) &amp;s)) {</span>
<span class="udiff-line-modified-added">+             releasePattern();</span>
<span class="udiff-line-added">+         }</span>
      } else {
          remove((UChar32)cp, (UChar32)cp);
      }
      return *this;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1247,28 +1231,21 @@</span>
   */
  UnicodeSet&amp; UnicodeSet::complement(void) {
      if (isFrozen() || isBogus()) {
          return *this;
      }
<span class="udiff-line-removed">-     UErrorCode status = U_ZERO_ERROR;</span>
      if (list[0] == UNICODESET_LOW) {
<span class="udiff-line-modified-removed">-         ensureBufferCapacity(len-1, status);</span>
<span class="udiff-line-removed">-         if (U_FAILURE(status)) {</span>
<span class="udiff-line-removed">-             return *this;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         uprv_memcpy(buffer, list + 1, (size_t)(len-1)*sizeof(UChar32));</span>
<span class="udiff-line-modified-added">+         uprv_memmove(list, list + 1, (size_t)(len-1)*sizeof(UChar32));</span>
          --len;
      } else {
<span class="udiff-line-modified-removed">-         ensureBufferCapacity(len+1, status);</span>
<span class="udiff-line-removed">-         if (U_FAILURE(status)) {</span>
<span class="udiff-line-modified-added">+         if (!ensureCapacity(len+1)) {</span>
              return *this;
          }
<span class="udiff-line-modified-removed">-         uprv_memcpy(buffer + 1, list, (size_t)len*sizeof(UChar32));</span>
<span class="udiff-line-modified-removed">-         buffer[0] = UNICODESET_LOW;</span>
<span class="udiff-line-modified-added">+         uprv_memmove(list + 1, list, (size_t)len*sizeof(UChar32));</span>
<span class="udiff-line-modified-added">+         list[0] = UNICODESET_LOW;</span>
          ++len;
      }
<span class="udiff-line-removed">-     swapBuffers();</span>
      releasePattern();
      return *this;
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1281,11 +1258,11 @@</span>
   */
  UnicodeSet&amp; UnicodeSet::complement(const UnicodeString&amp; s) {
      if (s.length() == 0 || isFrozen() || isBogus()) return *this;
      int32_t cp = getSingleCP(s);
      if (cp &lt; 0) {
<span class="udiff-line-modified-removed">-         if (strings-&gt;contains((void*) &amp;s)) {</span>
<span class="udiff-line-modified-added">+         if (stringsContains(s)) {</span>
              strings-&gt;removeElement((void*) &amp;s);
          } else {
              _add(s);
          }
          releasePattern();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1312,11 +1289,11 @@</span>
  
      // Add strings in order
      if ( c.strings!=NULL ) {
          for (int32_t i=0; i&lt;c.strings-&gt;size(); ++i) {
              const UnicodeString* s = (const UnicodeString*)c.strings-&gt;elementAt(i);
<span class="udiff-line-modified-removed">-             if (!strings-&gt;contains((void*) s)) {</span>
<span class="udiff-line-modified-added">+             if (!stringsContains(*s)) {</span>
                  _add(*s);
              }
          }
      }
      return *this;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1334,11 +1311,17 @@</span>
  UnicodeSet&amp; UnicodeSet::retainAll(const UnicodeSet&amp; c) {
      if (isFrozen() || isBogus()) {
          return *this;
      }
      retain(c.list, c.len, 0);
<span class="udiff-line-modified-removed">-     strings-&gt;retainAll(*c.strings);</span>
<span class="udiff-line-modified-added">+     if (hasStrings()) {</span>
<span class="udiff-line-added">+         if (!c.hasStrings()) {</span>
<span class="udiff-line-added">+             strings-&gt;removeAllElements();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             strings-&gt;retainAll(*c.strings);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
      return *this;
  }
  
  /**
   * Removes from this set all of its elements that are contained in the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1352,11 +1335,13 @@</span>
  UnicodeSet&amp; UnicodeSet::removeAll(const UnicodeSet&amp; c) {
      if (isFrozen() || isBogus()) {
          return *this;
      }
      retain(c.list, c.len, 2);
<span class="udiff-line-modified-removed">-     strings-&gt;removeAll(*c.strings);</span>
<span class="udiff-line-modified-added">+     if (hasStrings() &amp;&amp; c.hasStrings()) {</span>
<span class="udiff-line-added">+         strings-&gt;removeAll(*c.strings);</span>
<span class="udiff-line-added">+     }</span>
      return *this;
  }
  
  /**
   * Complements in this set all elements contained in the specified
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1370,14 +1355,16 @@</span>
      if (isFrozen() || isBogus()) {
          return *this;
      }
      exclusiveOr(c.list, c.len, 0);
  
<span class="udiff-line-modified-removed">-     for (int32_t i=0; i&lt;c.strings-&gt;size(); ++i) {</span>
<span class="udiff-line-modified-removed">-         void* e = c.strings-&gt;elementAt(i);</span>
<span class="udiff-line-modified-removed">-         if (!strings-&gt;removeElement(e)) {</span>
<span class="udiff-line-modified-removed">-             _add(*(const UnicodeString*)e);</span>
<span class="udiff-line-modified-added">+     if (c.strings != nullptr) {</span>
<span class="udiff-line-modified-added">+         for (int32_t i=0; i&lt;c.strings-&gt;size(); ++i) {</span>
<span class="udiff-line-modified-added">+             void* e = c.strings-&gt;elementAt(i);</span>
<span class="udiff-line-modified-added">+             if (strings == nullptr || !strings-&gt;removeElement(e)) {</span>
<span class="udiff-line-added">+                 _add(*(const UnicodeString*)e);</span>
<span class="udiff-line-added">+             }</span>
          }
      }
      return *this;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1387,22 +1374,18 @@</span>
   */
  UnicodeSet&amp; UnicodeSet::clear(void) {
      if (isFrozen()) {
          return *this;
      }
<span class="udiff-line-modified-removed">-     if (list != NULL) {</span>
<span class="udiff-line-removed">-         list[0] = UNICODESET_HIGH;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     list[0] = UNICODESET_HIGH;</span>
      len = 1;
      releasePattern();
      if (strings != NULL) {
          strings-&gt;removeAllElements();
      }
<span class="udiff-line-modified-removed">-     if (list != NULL &amp;&amp; strings != NULL) {</span>
<span class="udiff-line-modified-removed">-         // Remove bogus</span>
<span class="udiff-line-removed">-         fFlags = 0;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     // Remove bogus</span>
<span class="udiff-line-modified-added">+     fFlags = 0;</span>
      return *this;
  }
  
  /**
   * Iteration method that returns the number of ranges contained in
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1432,14 +1415,10 @@</span>
   */
  UChar32 UnicodeSet::getRangeEnd(int32_t index) const {
      return list[index*2 + 1] - 1;
  }
  
<span class="udiff-line-removed">- int32_t UnicodeSet::getStringCount() const {</span>
<span class="udiff-line-removed">-     return strings-&gt;size();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  const UnicodeString* UnicodeSet::getString(int32_t index) const {
      return (const UnicodeString*) strings-&gt;elementAt(index);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1449,40 +1428,48 @@</span>
  UnicodeSet&amp; UnicodeSet::compact() {
      if (isFrozen() || isBogus()) {
          return *this;
      }
      // Delete buffer first to defragment memory less.
<span class="udiff-line-modified-removed">-     if (buffer != NULL) {</span>
<span class="udiff-line-modified-added">+     if (buffer != stackList) {</span>
          uprv_free(buffer);
          buffer = NULL;
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     if (len &lt; capacity) {</span>
<span class="udiff-line-modified-removed">-         // Make the capacity equal to len or 1.</span>
<span class="udiff-line-modified-removed">-         // We don&#39;t want to realloc of 0 size.</span>
<span class="udiff-line-modified-removed">-         int32_t newCapacity = len + (len == 0);</span>
<span class="udiff-line-modified-removed">-         UChar32* temp = (UChar32*) uprv_realloc(list, sizeof(UChar32) * newCapacity);</span>
<span class="udiff-line-modified-added">+         bufferCapacity = 0;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     if (list == stackList) {</span>
<span class="udiff-line-modified-added">+         // pass</span>
<span class="udiff-line-modified-added">+     } else if (len &lt;= INITIAL_CAPACITY) {</span>
<span class="udiff-line-modified-added">+         uprv_memcpy(stackList, list, len * sizeof(UChar32));</span>
<span class="udiff-line-added">+         uprv_free(list);</span>
<span class="udiff-line-added">+         list = stackList;</span>
<span class="udiff-line-added">+         capacity = INITIAL_CAPACITY;</span>
<span class="udiff-line-added">+     } else if ((len + 7) &lt; capacity) {</span>
<span class="udiff-line-added">+         // If we have more than a little unused capacity, shrink it to len.</span>
<span class="udiff-line-added">+         UChar32* temp = (UChar32*) uprv_realloc(list, sizeof(UChar32) * len);</span>
          if (temp) {
              list = temp;
<span class="udiff-line-modified-removed">-             capacity = newCapacity;</span>
<span class="udiff-line-modified-added">+             capacity = len;</span>
          }
          // else what the heck happened?! We allocated less memory!
          // Oh well. We&#39;ll keep our original array.
      }
<span class="udiff-line-added">+     if (strings != nullptr &amp;&amp; strings-&gt;isEmpty()) {</span>
<span class="udiff-line-added">+         delete strings;</span>
<span class="udiff-line-added">+         strings = nullptr;</span>
<span class="udiff-line-added">+     }</span>
      return *this;
  }
  
  #ifdef DEBUG_SERIALIZE
  #include &lt;stdio.h&gt;
  #endif
  
  /**
   * Deserialize constructor.
   */
<span class="udiff-line-modified-removed">- UnicodeSet::UnicodeSet(const uint16_t data[], int32_t dataLen, ESerialization serialization, UErrorCode &amp;ec)</span>
<span class="udiff-line-modified-removed">-   : len(1), capacity(1+START_EXTRA), list(0), bmpSet(0), buffer(0),</span>
<span class="udiff-line-removed">-     bufferCapacity(0), patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="udiff-line-removed">-     fFlags(0) {</span>
<span class="udiff-line-modified-added">+ UnicodeSet::UnicodeSet(const uint16_t data[], int32_t dataLen, ESerialization serialization,</span>
<span class="udiff-line-modified-added">+                        UErrorCode &amp;ec) {</span>
  
    if(U_FAILURE(ec)) {
      setToBogus();
      return;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1493,28 +1480,19 @@</span>
      ec = U_ILLEGAL_ARGUMENT_ERROR;
      setToBogus();
      return;
    }
  
<span class="udiff-line-removed">-   allocateStrings(ec);</span>
<span class="udiff-line-removed">-   if (U_FAILURE(ec)) {</span>
<span class="udiff-line-removed">-     setToBogus();</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    // bmp?
    int32_t headerSize = ((data[0]&amp;0x8000)) ?2:1;
    int32_t bmpLength = (headerSize==1)?data[0]:data[1];
  
<span class="udiff-line-modified-removed">-   len = (((data[0]&amp;0x7FFF)-bmpLength)/2)+bmpLength;</span>
<span class="udiff-line-modified-added">+   int32_t newLength = (((data[0]&amp;0x7FFF)-bmpLength)/2)+bmpLength;</span>
  #ifdef DEBUG_SERIALIZE
<span class="udiff-line-modified-removed">-   printf(&quot;dataLen %d headerSize %d bmpLen %d len %d. data[0]=%X/%X/%X/%X\n&quot;, dataLen,headerSize,bmpLength,len, data[0],data[1],data[2],data[3]);</span>
<span class="udiff-line-modified-added">+   printf(&quot;dataLen %d headerSize %d bmpLen %d len %d. data[0]=%X/%X/%X/%X\n&quot;, dataLen,headerSize,bmpLength,newLength, data[0],data[1],data[2],data[3]);</span>
  #endif
<span class="udiff-line-modified-removed">-   capacity = len+1;</span>
<span class="udiff-line-removed">-   list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="udiff-line-removed">-   if(!list || U_FAILURE(ec)) {</span>
<span class="udiff-line-removed">-     setToBogus();</span>
<span class="udiff-line-modified-added">+   if(!ensureCapacity(newLength + 1)) {  // +1 for HIGH</span>
      return;
    }
    // copy bmp
    int32_t i;
    for(i = 0; i&lt; bmpLength;i++) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1522,19 +1500,22 @@</span>
  #ifdef DEBUG_SERIALIZE
      printf(&quot;&lt;&lt;16@%d[%d] %X\n&quot;, i+headerSize, i, list[i]);
  #endif
    }
    // copy smp
<span class="udiff-line-modified-removed">-   for(i=bmpLength;i&lt;len;i++) {</span>
<span class="udiff-line-modified-added">+   for(i=bmpLength;i&lt;newLength;i++) {</span>
      list[i] = ((UChar32)data[headerSize+bmpLength+(i-bmpLength)*2+0] &lt;&lt; 16) +
                ((UChar32)data[headerSize+bmpLength+(i-bmpLength)*2+1]);
  #ifdef DEBUG_SERIALIZE
      printf(&quot;&lt;&lt;32@%d+[%d] %lX\n&quot;, headerSize+bmpLength+i, i, list[i]);
  #endif
    }
<span class="udiff-line-modified-removed">-   // terminator</span>
<span class="udiff-line-modified-removed">-   list[len++]=UNICODESET_HIGH;</span>
<span class="udiff-line-modified-added">+   U_ASSERT(i == newLength);</span>
<span class="udiff-line-modified-added">+   if (i == 0 || list[i - 1] != UNICODESET_HIGH) {</span>
<span class="udiff-line-added">+     list[i++] = UNICODESET_HIGH;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   len = i;</span>
  }
  
  
  int32_t UnicodeSet::serialize(uint16_t *dest, int32_t destCapacity, UErrorCode&amp; ec) const {
      int32_t bmpLength, length, destLength;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1651,36 +1632,69 @@</span>
          return FALSE;
      }
      return TRUE;
  }
  
<span class="udiff-line-modified-removed">- void UnicodeSet::ensureCapacity(int32_t newLen, UErrorCode&amp; ec) {</span>
<span class="udiff-line-modified-removed">-     if (newLen &lt;= capacity)</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-removed">-     UChar32* temp = (UChar32*) uprv_realloc(list, sizeof(UChar32) * (newLen + GROW_EXTRA));</span>
<span class="udiff-line-modified-added">+ int32_t UnicodeSet::nextCapacity(int32_t minCapacity) {</span>
<span class="udiff-line-modified-added">+     // Grow exponentially to reduce the frequency of allocations.</span>
<span class="udiff-line-modified-added">+     if (minCapacity &lt; INITIAL_CAPACITY) {</span>
<span class="udiff-line-modified-added">+         return minCapacity + INITIAL_CAPACITY;</span>
<span class="udiff-line-added">+     } else if (minCapacity &lt;= 2500) {</span>
<span class="udiff-line-added">+         return 5 * minCapacity;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+         int32_t newCapacity = 2 * minCapacity;</span>
<span class="udiff-line-added">+         if (newCapacity &gt; MAX_LENGTH) {</span>
<span class="udiff-line-added">+             newCapacity = MAX_LENGTH;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return newCapacity;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool UnicodeSet::ensureCapacity(int32_t newLen) {</span>
<span class="udiff-line-added">+     if (newLen &gt; MAX_LENGTH) {</span>
<span class="udiff-line-added">+         newLen = MAX_LENGTH;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (newLen &lt;= capacity) {</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     int32_t newCapacity = nextCapacity(newLen);</span>
<span class="udiff-line-added">+     UChar32* temp = (UChar32*) uprv_malloc(newCapacity * sizeof(UChar32));</span>
      if (temp == NULL) {
<span class="udiff-line-modified-removed">-         ec = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="udiff-line-modified-removed">-         setToBogus();</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-added">+         setToBogus(); // set the object to bogus state if an OOM failure occurred.</span>
<span class="udiff-line-modified-added">+         return false;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+     // Copy only the actual contents.</span>
<span class="udiff-line-added">+     uprv_memcpy(temp, list, len * sizeof(UChar32));</span>
<span class="udiff-line-added">+     if (list != stackList) {</span>
<span class="udiff-line-added">+         uprv_free(list);</span>
      }
      list = temp;
<span class="udiff-line-modified-removed">-     capacity = newLen + GROW_EXTRA;</span>
<span class="udiff-line-modified-removed">-     // else we keep the original contents on the memory failure.</span>
<span class="udiff-line-modified-added">+     capacity = newCapacity;</span>
<span class="udiff-line-modified-added">+     return true;</span>
  }
  
<span class="udiff-line-modified-removed">- void UnicodeSet::ensureBufferCapacity(int32_t newLen, UErrorCode&amp; ec) {</span>
<span class="udiff-line-modified-removed">-     if (buffer != NULL &amp;&amp; newLen &lt;= bufferCapacity)</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-removed">-     UChar32* temp = (UChar32*) uprv_realloc(buffer, sizeof(UChar32) * (newLen + GROW_EXTRA));</span>
<span class="udiff-line-modified-added">+ bool UnicodeSet::ensureBufferCapacity(int32_t newLen) {</span>
<span class="udiff-line-modified-added">+     if (newLen &gt; MAX_LENGTH) {</span>
<span class="udiff-line-modified-added">+         newLen = MAX_LENGTH;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+     if (newLen &lt;= bufferCapacity) {</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     int32_t newCapacity = nextCapacity(newLen);</span>
<span class="udiff-line-added">+     UChar32* temp = (UChar32*) uprv_malloc(newCapacity * sizeof(UChar32));</span>
      if (temp == NULL) {
<span class="udiff-line-removed">-         ec = U_MEMORY_ALLOCATION_ERROR;</span>
          setToBogus();
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-added">+         return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // The buffer has no contents to be copied.</span>
<span class="udiff-line-added">+     // It is always filled from scratch after this call.</span>
<span class="udiff-line-added">+     if (buffer != stackList) {</span>
<span class="udiff-line-added">+         uprv_free(buffer);</span>
      }
      buffer = temp;
<span class="udiff-line-modified-removed">-     bufferCapacity = newLen + GROW_EXTRA;</span>
<span class="udiff-line-modified-removed">-     // else we keep the original contents on the memory failure.</span>
<span class="udiff-line-modified-added">+     bufferCapacity = newCapacity;</span>
<span class="udiff-line-modified-added">+     return true;</span>
  }
  
  /**
   * Swap list and buffer.
   */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1713,13 +1727,11 @@</span>
  
  void UnicodeSet::exclusiveOr(const UChar32* other, int32_t otherLen, int8_t polarity) {
      if (isFrozen() || isBogus()) {
          return;
      }
<span class="udiff-line-modified-removed">-     UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-removed">-     ensureBufferCapacity(len + otherLen, status);</span>
<span class="udiff-line-removed">-     if (U_FAILURE(status)) {</span>
<span class="udiff-line-modified-added">+     if (!ensureBufferCapacity(len + otherLen)) {</span>
          return;
      }
  
      int32_t i = 0, j = 0, k = 0;
      UChar32 a = list[i++];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1763,13 +1775,11 @@</span>
  
  void UnicodeSet::add(const UChar32* other, int32_t otherLen, int8_t polarity) {
      if (isFrozen() || isBogus() || other==NULL) {
          return;
      }
<span class="udiff-line-modified-removed">-     UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-removed">-     ensureBufferCapacity(len + otherLen, status);</span>
<span class="udiff-line-removed">-     if (U_FAILURE(status)) {</span>
<span class="udiff-line-modified-added">+     if (!ensureBufferCapacity(len + otherLen)) {</span>
          return;
      }
  
      int32_t i = 0, j = 0, k = 0;
      UChar32 a = list[i++];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1876,13 +1886,11 @@</span>
  
  void UnicodeSet::retain(const UChar32* other, int32_t otherLen, int8_t polarity) {
      if (isFrozen() || isBogus()) {
          return;
      }
<span class="udiff-line-modified-removed">-     UErrorCode status = U_ZERO_ERROR;</span>
<span class="udiff-line-removed">-     ensureBufferCapacity(len + otherLen, status);</span>
<span class="udiff-line-removed">-     if (U_FAILURE(status)) {</span>
<span class="udiff-line-modified-added">+     if (!ensureBufferCapacity(len + otherLen)) {</span>
          return;
      }
  
      int32_t i = 0, j = 0, k = 0;
      UChar32 a = list[i++];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2124,16 +2132,18 @@</span>
                  _appendToPat(result, end, escapeUnprintable);
              }
          }
      }
  
<span class="udiff-line-modified-removed">-     for (int32_t i = 0; i&lt;strings-&gt;size(); ++i) {</span>
<span class="udiff-line-modified-removed">-         result.append(OPEN_BRACE);</span>
<span class="udiff-line-modified-removed">-         _appendToPat(result,</span>
<span class="udiff-line-modified-removed">-                      *(const UnicodeString*) strings-&gt;elementAt(i),</span>
<span class="udiff-line-modified-removed">-                      escapeUnprintable);</span>
<span class="udiff-line-modified-removed">-         result.append(CLOSE_BRACE);</span>
<span class="udiff-line-modified-added">+     if (strings != nullptr) {</span>
<span class="udiff-line-modified-added">+         for (int32_t i = 0; i&lt;strings-&gt;size(); ++i) {</span>
<span class="udiff-line-modified-added">+             result.append(OPEN_BRACE);</span>
<span class="udiff-line-modified-added">+             _appendToPat(result,</span>
<span class="udiff-line-modified-added">+                          *(const UnicodeString*) strings-&gt;elementAt(i),</span>
<span class="udiff-line-modified-added">+                          escapeUnprintable);</span>
<span class="udiff-line-added">+             result.append(CLOSE_BRACE);</span>
<span class="udiff-line-added">+         }</span>
      }
      return result.append(SET_CLOSE);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2148,49 +2158,33 @@</span>
  }
  
  /**
  * Set the new pattern to cache.
  */
<span class="udiff-line-modified-removed">- void UnicodeSet::setPattern(const UnicodeString&amp; newPat) {</span>
<span class="udiff-line-modified-added">+ void UnicodeSet::setPattern(const char16_t *newPat, int32_t newPatLen) {</span>
      releasePattern();
<span class="udiff-line-removed">-     int32_t newPatLen = newPat.length();</span>
      pat = (UChar *)uprv_malloc((newPatLen + 1) * sizeof(UChar));
      if (pat) {
          patLen = newPatLen;
<span class="udiff-line-modified-removed">-         newPat.extractBetween(0, patLen, pat);</span>
<span class="udiff-line-modified-added">+         u_memcpy(pat, newPat, patLen);</span>
          pat[patLen] = 0;
      }
      // else we don&#39;t care if malloc failed. This was just a nice cache.
      // We can regenerate an equivalent pattern later when requested.
  }
  
  UnicodeFunctor *UnicodeSet::freeze() {
      if(!isFrozen() &amp;&amp; !isBogus()) {
<span class="udiff-line-modified-removed">-         // Do most of what compact() does before freezing because</span>
<span class="udiff-line-removed">-         // compact() will not work when the set is frozen.</span>
<span class="udiff-line-removed">-         // Small modification: Don&#39;t shrink if the savings would be tiny (&lt;=GROW_EXTRA).</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Delete buffer first to defragment memory less.</span>
<span class="udiff-line-removed">-         if (buffer != NULL) {</span>
<span class="udiff-line-removed">-             uprv_free(buffer);</span>
<span class="udiff-line-removed">-             buffer = NULL;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (capacity &gt; (len + GROW_EXTRA)) {</span>
<span class="udiff-line-removed">-             // Make the capacity equal to len or 1.</span>
<span class="udiff-line-removed">-             // We don&#39;t want to realloc of 0 size.</span>
<span class="udiff-line-removed">-             capacity = len + (len == 0);</span>
<span class="udiff-line-removed">-             list = (UChar32*) uprv_realloc(list, sizeof(UChar32) * capacity);</span>
<span class="udiff-line-removed">-             if (list == NULL) { // Check for memory allocation error.</span>
<span class="udiff-line-removed">-                 setToBogus();</span>
<span class="udiff-line-removed">-                 return this;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         compact();</span>
  
          // Optimize contains() and span() and similar functions.
<span class="udiff-line-modified-removed">-         if (!strings-&gt;isEmpty()) {</span>
<span class="udiff-line-modified-added">+         if (hasStrings()) {</span>
              stringSpan = new UnicodeSetStringSpan(*this, *strings, UnicodeSetStringSpan::ALL);
<span class="udiff-line-modified-removed">-             if (stringSpan != NULL &amp;&amp; !stringSpan-&gt;needsStringSpanUTF16()) {</span>
<span class="udiff-line-modified-added">+             if (stringSpan == nullptr) {</span>
<span class="udiff-line-added">+                 setToBogus();</span>
<span class="udiff-line-added">+                 return this;</span>
<span class="udiff-line-added">+             } else if (!stringSpan-&gt;needsStringSpanUTF16()) {</span>
                  // All strings are irrelevant for span() etc. because
                  // all of each string&#39;s code points are contained in this set.
                  // Do not check needsStringSpanUTF8() because UTF-8 has at most as
                  // many relevant strings as UTF-16.
                  // (Thus needsStringSpanUTF8() implies needsStringSpanUTF16().)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2219,11 +2213,11 @@</span>
      if(length==0) {
          return 0;
      }
      if(stringSpan!=NULL) {
          return stringSpan-&gt;span(s, length, spanCondition);
<span class="udiff-line-modified-removed">-     } else if(!strings-&gt;isEmpty()) {</span>
<span class="udiff-line-modified-added">+     } else if(hasStrings()) {</span>
          uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
                              UnicodeSetStringSpan::FWD_UTF16_NOT_CONTAINED :
                              UnicodeSetStringSpan::FWD_UTF16_CONTAINED;
          UnicodeSetStringSpan strSpan(*this, *strings, which);
          if(strSpan.needsStringSpanUTF16()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2256,11 +2250,11 @@</span>
      if(length==0) {
          return 0;
      }
      if(stringSpan!=NULL) {
          return stringSpan-&gt;spanBack(s, length, spanCondition);
<span class="udiff-line-modified-removed">-     } else if(!strings-&gt;isEmpty()) {</span>
<span class="udiff-line-modified-added">+     } else if(hasStrings()) {</span>
          uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
                              UnicodeSetStringSpan::BACK_UTF16_NOT_CONTAINED :
                              UnicodeSetStringSpan::BACK_UTF16_CONTAINED;
          UnicodeSetStringSpan strSpan(*this, *strings, which);
          if(strSpan.needsStringSpanUTF16()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2294,11 +2288,11 @@</span>
      if(length==0) {
          return 0;
      }
      if(stringSpan!=NULL) {
          return stringSpan-&gt;spanUTF8((const uint8_t *)s, length, spanCondition);
<span class="udiff-line-modified-removed">-     } else if(!strings-&gt;isEmpty()) {</span>
<span class="udiff-line-modified-added">+     } else if(hasStrings()) {</span>
          uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
                              UnicodeSetStringSpan::FWD_UTF8_NOT_CONTAINED :
                              UnicodeSetStringSpan::FWD_UTF8_CONTAINED;
          UnicodeSetStringSpan strSpan(*this, *strings, which);
          if(strSpan.needsStringSpanUTF8()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2332,11 +2326,11 @@</span>
      if(length==0) {
          return 0;
      }
      if(stringSpan!=NULL) {
          return stringSpan-&gt;spanBackUTF8((const uint8_t *)s, length, spanCondition);
<span class="udiff-line-modified-removed">-     } else if(!strings-&gt;isEmpty()) {</span>
<span class="udiff-line-modified-added">+     } else if(hasStrings()) {</span>
          uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
                              UnicodeSetStringSpan::BACK_UTF8_NOT_CONTAINED :
                              UnicodeSetStringSpan::BACK_UTF8_CONTAINED;
          UnicodeSetStringSpan strSpan(*this, *strings, which);
          if(strSpan.needsStringSpanUTF8()) {
</pre>
<center><a href="unifiedcache.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uniset_closure.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>