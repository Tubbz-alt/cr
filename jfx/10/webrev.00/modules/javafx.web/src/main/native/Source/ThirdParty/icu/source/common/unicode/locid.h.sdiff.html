<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/locid.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="locdspnm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="messagepattern.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/locid.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14 *
  15 * Modification History:
  16 *
  17 *   Date        Name        Description
  18 *   02/11/97    aliu        Changed gLocPath to fgLocPath and added methods to
  19 *                           get and set it.
  20 *   04/02/97    aliu        Made operator!= inline; fixed return value of getName().
  21 *   04/15/97    aliu        Cleanup for AIX/Win32.
  22 *   04/24/97    aliu        Numerous changes per code review.
  23 *   08/18/98    stephen     Added tokenizeString(),changed getDisplayName()
  24 *   09/08/98    stephen     Moved definition of kEmptyString for Mac Port
  25 *   11/09/99    weiv        Added const char * getName() const;
  26 *   04/12/00    srl         removing unicodestring api&#39;s and cached hash code
  27 *   08/10/01    grhoten     Change the static Locales to accessor functions
  28 ******************************************************************************
  29 */
  30 
  31 #ifndef LOCID_H
  32 #define LOCID_H
  33 




  34 #include &quot;unicode/utypes.h&quot;
  35 #include &quot;unicode/uobject.h&quot;
  36 #include &quot;unicode/putil.h&quot;
  37 #include &quot;unicode/uloc.h&quot;
  38 
  39 /**
  40  * \file
  41  * \brief C++ API: Locale ID object.
  42  */
  43 
  44 U_NAMESPACE_BEGIN
  45 
  46 // Forward Declarations
  47 void U_CALLCONV locale_available_init(); /**&lt; @internal */
  48 
  49 class StringEnumeration;
  50 class UnicodeString;
  51 
  52 /**
  53  * A &lt;code&gt;Locale&lt;/code&gt; object represents a specific geographical, political,
</pre>
<hr />
<pre>
 263      * @param keywordsAndValues A string consisting of keyword/values pairs, such as
 264      *                 &quot;collation=phonebook;currency=euro&quot;
 265      *
 266      * @see getDefault
 267      * @see uloc_getDefault
 268      * @stable ICU 2.0
 269      */
 270     Locale( const   char * language,
 271             const   char * country  = 0,
 272             const   char * variant  = 0,
 273             const   char * keywordsAndValues = 0);
 274 
 275     /**
 276      * Initializes a Locale object from another Locale object.
 277      *
 278      * @param other The Locale object being copied in.
 279      * @stable ICU 2.0
 280      */
 281     Locale(const    Locale&amp; other);
 282 










 283 
 284     /**
 285      * Destructor
 286      * @stable ICU 2.0
 287      */
 288     virtual ~Locale() ;
 289 
 290     /**
 291      * Replaces the entire contents of *this with the specified value.
 292      *
 293      * @param other The Locale object being copied in.
 294      * @return      *this
 295      * @stable ICU 2.0
 296      */
 297     Locale&amp; operator=(const Locale&amp; other);
 298 













 299     /**
 300      * Checks if two locale keys are the same.
 301      *
 302      * @param other The locale key object to be compared with this.
 303      * @return      True if the two locale keys are the same, false otherwise.
 304      * @stable ICU 2.0
 305      */
 306     UBool   operator==(const    Locale&amp;     other) const;
 307 
 308     /**
 309      * Checks if two locale keys are not the same.
 310      *
 311      * @param other The locale key object to be compared with this.
 312      * @return      True if the two locale keys are not the same, false
 313      *              otherwise.
 314      * @stable ICU 2.0
 315      */
<span class="line-modified"> 316     UBool   operator!=(const    Locale&amp;     other) const;</span>
 317 
 318     /**
 319      * Clone this object.
 320      * Clones can be used concurrently in multiple threads.
 321      * If an error occurs, then NULL is returned.
 322      * The caller must delete the clone.
 323      *
 324      * @return a clone of this object
 325      *
 326      * @see getDynamicClassID
 327      * @stable ICU 2.8
 328      */
 329     Locale *clone() const;
 330 
 331 #ifndef U_HIDE_SYSTEM_API
 332     /**
 333      * Common methods of getting the current default Locale. Used for the
 334      * presentation: menus, dialogs, etc. Generally set once when your applet or
 335      * application is initialized, then never reset. (If you do reset the
 336      * default locale, you probably want to reload your GUI, so that the change
</pre>
<hr />
<pre>
 345      * @stable ICU 2.0
 346      */
 347     static const Locale&amp; U_EXPORT2 getDefault(void);
 348 
 349     /**
 350      * Sets the default. Normally set once at the beginning of a process,
 351      * then never reset.
 352      * setDefault() only changes ICU&#39;s default locale ID, &lt;strong&gt;not&lt;/strong&gt;
 353      * the default locale ID of the runtime environment.
 354      *
 355      * @param newLocale Locale to set to.  If NULL, set to the value obtained
 356      *                  from the runtime environment.
 357      * @param success The error code.
 358      * @system
 359      * @stable ICU 2.0
 360      */
 361     static void U_EXPORT2 setDefault(const Locale&amp; newLocale,
 362                                      UErrorCode&amp;   success);
 363 #endif  /* U_HIDE_SYSTEM_API */
 364 

















































 365     /**
 366      * Creates a locale which has had minimal canonicalization
 367      * as per uloc_getName().
 368      * @param name The name to create from.  If name is null,
 369      *  the default Locale is used.
 370      * @return new locale object
 371      * @stable ICU 2.0
 372      * @see uloc_getName
 373      */
 374     static Locale U_EXPORT2 createFromName(const char *name);
 375 
 376     /**
 377      * Creates a locale from the given string after canonicalizing
 378      * the string by calling uloc_canonicalize().
 379      * @param name the locale ID to create from.  Must not be NULL.
 380      * @return a new locale object corresponding to the given name
 381      * @stable ICU 3.0
 382      * @see uloc_canonicalize
 383      */
 384     static Locale U_EXPORT2 createCanonical(const char* name);
</pre>
<hr />
<pre>
 415 
 416     /**
 417      * Returns the programmatic name of the entire locale, with the language,
 418      * country and variant separated by underbars. If a field is missing, up
 419      * to two leading underbars will occur. Example: &quot;en&quot;, &quot;de_DE&quot;, &quot;en_US_WIN&quot;,
 420      * &quot;de__POSIX&quot;, &quot;fr__MAC&quot;, &quot;__MAC&quot;, &quot;_MT&quot;, &quot;_FR_EURO&quot;
 421      * @return      A pointer to &quot;name&quot;.
 422      * @stable ICU 2.0
 423      */
 424     inline const char * getName() const;
 425 
 426     /**
 427      * Returns the programmatic name of the entire locale as getName() would return,
 428      * but without keywords.
 429      * @return      A pointer to &quot;name&quot;.
 430      * @see getName
 431      * @stable ICU 2.8
 432      */
 433     const char * getBaseName() const;
 434 































































 435 
 436     /**
 437      * Gets the list of keywords for the specified locale.
 438      *
 439      * @param status the status code
 440      * @return pointer to StringEnumeration class, or NULL if there are no keywords.
 441      * Client must dispose of it by calling delete.

 442      * @stable ICU 2.8
 443      */
 444     StringEnumeration * createKeywords(UErrorCode &amp;status) const;
 445 











































 446     /**
 447      * Gets the value for a keyword.
 448      *





 449      * @param keywordName name of the keyword for which we want the value. Case insensitive.
 450      * @param buffer The buffer to receive the keyword value.
 451      * @param bufferCapacity The capacity of receiving buffer
 452      * @param status Returns any error information while performing this operation.
 453      * @return the length of the keyword value
 454      *
 455      * @stable ICU 2.8
 456      */
 457     int32_t getKeywordValue(const char* keywordName, char *buffer, int32_t bufferCapacity, UErrorCode &amp;status) const;
 458 
































































 459     /**
 460      * Sets or removes the value for a keyword.
 461      *
 462      * For removing all keywords, use getBaseName(),
 463      * and construct a new Locale if it differs from getName().
 464      *





 465      * @param keywordName name of the keyword to be set. Case insensitive.
 466      * @param keywordValue value of the keyword to be set. If 0-length or
 467      *  NULL, will result in the keyword being removed. No error is given if
 468      *  that keyword does not exist.
 469      * @param status Returns any error information while performing this operation.
 470      *
 471      * @stable ICU 49
 472      */
 473     void setKeywordValue(const char* keywordName, const char* keywordValue, UErrorCode &amp;status);
 474 










































 475     /**
 476      * returns the locale&#39;s three-letter language code, as specified
 477      * in ISO draft standard ISO-639-2.
 478      * @return      An alias to the code, or an empty string
 479      * @stable ICU 2.0
 480      */
 481     const char * getISO3Language() const;
 482 
 483     /**
 484      * Fills in &quot;name&quot; with the locale&#39;s three-letter ISO-3166 country code.
 485      * @return      An alias to the code, or an empty string
 486      * @stable ICU 2.0
 487      */
 488     const char * getISO3Country() const;
 489 
 490     /**
 491      * Returns the Windows LCID value corresponding to this locale.
 492      * This value is stored in the resource data for the locale as a one-to-four-digit
 493      * hexadecimal number.  If the resource is missing, in the wrong format, or
 494      * there is no Windows LCID value that corresponds to this locale, returns 0.
</pre>
<hr />
<pre>
 646      * Generates a hash code for the locale.
 647      * @stable ICU 2.0
 648      */
 649     int32_t         hashCode(void) const;
 650 
 651     /**
 652      * Sets the locale to bogus
 653      * A bogus locale represents a non-existing locale associated
 654      * with services that can be instantiated from non-locale data
 655      * in addition to locale (for example, collation can be
 656      * instantiated from a locale and from a rule set).
 657      * @stable ICU 2.1
 658      */
 659     void setToBogus();
 660 
 661     /**
 662      * Gets the bogus state. Locale object can be bogus if it doesn&#39;t exist
 663      * @return FALSE if it is a real locale, TRUE if it is a bogus locale
 664      * @stable ICU 2.1
 665      */
<span class="line-modified"> 666     UBool isBogus(void) const;</span>
 667 
 668     /**
 669      * Returns a list of all installed locales.
 670      * @param count Receives the number of locales in the list.
 671      * @return      A pointer to an array of Locale objects.  This array is the list
 672      *              of all locales with installed resource files.  The called does NOT
 673      *              get ownership of this list, and must NOT delete it.
 674      * @stable ICU 2.0
 675      */
 676     static const Locale* U_EXPORT2 getAvailableLocales(int32_t&amp; count);
 677 
 678     /**
 679      * Gets a list of all available 2-letter country codes defined in ISO 3166.  This is a
 680      * pointer to an array of pointers to arrays of char.  All of these pointers are
 681      * owned by ICU-- do not delete them, and do not write through them.  The array is
 682      * terminated with a null pointer.
 683      * @return a list of all available country codes
 684      * @stable ICU 2.0
 685      */
 686     static const char* const* U_EXPORT2 getISOCountries();
</pre>
<hr />
<pre>
 742      * Initialize the locale cache for commonly used locales
 743      */
 744     static Locale *getLocaleCache(void);
 745 
 746     char language[ULOC_LANG_CAPACITY];
 747     char script[ULOC_SCRIPT_CAPACITY];
 748     char country[ULOC_COUNTRY_CAPACITY];
 749     int32_t variantBegin;
 750     char* fullName;
 751     char fullNameBuffer[ULOC_FULLNAME_CAPACITY];
 752     // name without keywords
 753     char* baseName;
 754     void initBaseName(UErrorCode&amp; status);
 755 
 756     UBool fIsBogus;
 757 
 758     static const Locale &amp;getLocale(int locid);
 759 
 760     /**
 761      * A friend to allow the default locale to be set by either the C or C++ API.
<span class="line-modified"> 762      * @internal</span>
 763      */
 764     friend Locale *locale_set_default_internal(const char *, UErrorCode&amp; status);
 765 
 766     /**
<span class="line-modified"> 767      * @internal</span>
 768      */
 769     friend void U_CALLCONV locale_available_init();
 770 };
 771 
 772 inline UBool
 773 Locale::operator!=(const    Locale&amp;     other) const
 774 {
 775     return !operator==(other);
 776 }
 777 











 778 inline const char *
 779 Locale::getCountry() const
 780 {
 781     return country;
 782 }
 783 
 784 inline const char *
 785 Locale::getLanguage() const
 786 {
 787     return language;
 788 }
 789 
 790 inline const char *
 791 Locale::getScript() const
 792 {
 793     return script;
 794 }
 795 
 796 inline const char *
 797 Locale::getVariant() const
























































 808 inline UBool
 809 Locale::isBogus(void) const {
 810     return fIsBogus;
 811 }
 812 
 813 U_NAMESPACE_END
 814 
 815 #endif
</pre>
</td>
<td>
<hr />
<pre>
  14 *
  15 * Modification History:
  16 *
  17 *   Date        Name        Description
  18 *   02/11/97    aliu        Changed gLocPath to fgLocPath and added methods to
  19 *                           get and set it.
  20 *   04/02/97    aliu        Made operator!= inline; fixed return value of getName().
  21 *   04/15/97    aliu        Cleanup for AIX/Win32.
  22 *   04/24/97    aliu        Numerous changes per code review.
  23 *   08/18/98    stephen     Added tokenizeString(),changed getDisplayName()
  24 *   09/08/98    stephen     Moved definition of kEmptyString for Mac Port
  25 *   11/09/99    weiv        Added const char * getName() const;
  26 *   04/12/00    srl         removing unicodestring api&#39;s and cached hash code
  27 *   08/10/01    grhoten     Change the static Locales to accessor functions
  28 ******************************************************************************
  29 */
  30 
  31 #ifndef LOCID_H
  32 #define LOCID_H
  33 
<span class="line-added">  34 #include &quot;unicode/bytestream.h&quot;</span>
<span class="line-added">  35 #include &quot;unicode/localpointer.h&quot;</span>
<span class="line-added">  36 #include &quot;unicode/strenum.h&quot;</span>
<span class="line-added">  37 #include &quot;unicode/stringpiece.h&quot;</span>
  38 #include &quot;unicode/utypes.h&quot;
  39 #include &quot;unicode/uobject.h&quot;
  40 #include &quot;unicode/putil.h&quot;
  41 #include &quot;unicode/uloc.h&quot;
  42 
  43 /**
  44  * \file
  45  * \brief C++ API: Locale ID object.
  46  */
  47 
  48 U_NAMESPACE_BEGIN
  49 
  50 // Forward Declarations
  51 void U_CALLCONV locale_available_init(); /**&lt; @internal */
  52 
  53 class StringEnumeration;
  54 class UnicodeString;
  55 
  56 /**
  57  * A &lt;code&gt;Locale&lt;/code&gt; object represents a specific geographical, political,
</pre>
<hr />
<pre>
 267      * @param keywordsAndValues A string consisting of keyword/values pairs, such as
 268      *                 &quot;collation=phonebook;currency=euro&quot;
 269      *
 270      * @see getDefault
 271      * @see uloc_getDefault
 272      * @stable ICU 2.0
 273      */
 274     Locale( const   char * language,
 275             const   char * country  = 0,
 276             const   char * variant  = 0,
 277             const   char * keywordsAndValues = 0);
 278 
 279     /**
 280      * Initializes a Locale object from another Locale object.
 281      *
 282      * @param other The Locale object being copied in.
 283      * @stable ICU 2.0
 284      */
 285     Locale(const    Locale&amp; other);
 286 
<span class="line-added"> 287 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added"> 288     /**</span>
<span class="line-added"> 289      * Move constructor; might leave source in bogus state.</span>
<span class="line-added"> 290      * This locale will have the same contents that the source locale had.</span>
<span class="line-added"> 291      *</span>
<span class="line-added"> 292      * @param other The Locale object being moved in.</span>
<span class="line-added"> 293      * @draft ICU 63</span>
<span class="line-added"> 294      */</span>
<span class="line-added"> 295     Locale(Locale&amp;&amp; other) U_NOEXCEPT;</span>
<span class="line-added"> 296 #endif  // U_HIDE_DRAFT_API</span>
 297 
 298     /**
 299      * Destructor
 300      * @stable ICU 2.0
 301      */
 302     virtual ~Locale() ;
 303 
 304     /**
 305      * Replaces the entire contents of *this with the specified value.
 306      *
 307      * @param other The Locale object being copied in.
 308      * @return      *this
 309      * @stable ICU 2.0
 310      */
 311     Locale&amp; operator=(const Locale&amp; other);
 312 
<span class="line-added"> 313 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added"> 314     /**</span>
<span class="line-added"> 315      * Move assignment operator; might leave source in bogus state.</span>
<span class="line-added"> 316      * This locale will have the same contents that the source locale had.</span>
<span class="line-added"> 317      * The behavior is undefined if *this and the source are the same object.</span>
<span class="line-added"> 318      *</span>
<span class="line-added"> 319      * @param other The Locale object being moved in.</span>
<span class="line-added"> 320      * @return      *this</span>
<span class="line-added"> 321      * @draft ICU 63</span>
<span class="line-added"> 322      */</span>
<span class="line-added"> 323     Locale&amp; operator=(Locale&amp;&amp; other) U_NOEXCEPT;</span>
<span class="line-added"> 324 #endif  // U_HIDE_DRAFT_API</span>
<span class="line-added"> 325 </span>
 326     /**
 327      * Checks if two locale keys are the same.
 328      *
 329      * @param other The locale key object to be compared with this.
 330      * @return      True if the two locale keys are the same, false otherwise.
 331      * @stable ICU 2.0
 332      */
 333     UBool   operator==(const    Locale&amp;     other) const;
 334 
 335     /**
 336      * Checks if two locale keys are not the same.
 337      *
 338      * @param other The locale key object to be compared with this.
 339      * @return      True if the two locale keys are not the same, false
 340      *              otherwise.
 341      * @stable ICU 2.0
 342      */
<span class="line-modified"> 343     inline UBool   operator!=(const    Locale&amp;     other) const;</span>
 344 
 345     /**
 346      * Clone this object.
 347      * Clones can be used concurrently in multiple threads.
 348      * If an error occurs, then NULL is returned.
 349      * The caller must delete the clone.
 350      *
 351      * @return a clone of this object
 352      *
 353      * @see getDynamicClassID
 354      * @stable ICU 2.8
 355      */
 356     Locale *clone() const;
 357 
 358 #ifndef U_HIDE_SYSTEM_API
 359     /**
 360      * Common methods of getting the current default Locale. Used for the
 361      * presentation: menus, dialogs, etc. Generally set once when your applet or
 362      * application is initialized, then never reset. (If you do reset the
 363      * default locale, you probably want to reload your GUI, so that the change
</pre>
<hr />
<pre>
 372      * @stable ICU 2.0
 373      */
 374     static const Locale&amp; U_EXPORT2 getDefault(void);
 375 
 376     /**
 377      * Sets the default. Normally set once at the beginning of a process,
 378      * then never reset.
 379      * setDefault() only changes ICU&#39;s default locale ID, &lt;strong&gt;not&lt;/strong&gt;
 380      * the default locale ID of the runtime environment.
 381      *
 382      * @param newLocale Locale to set to.  If NULL, set to the value obtained
 383      *                  from the runtime environment.
 384      * @param success The error code.
 385      * @system
 386      * @stable ICU 2.0
 387      */
 388     static void U_EXPORT2 setDefault(const Locale&amp; newLocale,
 389                                      UErrorCode&amp;   success);
 390 #endif  /* U_HIDE_SYSTEM_API */
 391 
<span class="line-added"> 392 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added"> 393     /**</span>
<span class="line-added"> 394      * Returns a Locale for the specified BCP47 language tag string.</span>
<span class="line-added"> 395      * If the specified language tag contains any ill-formed subtags,</span>
<span class="line-added"> 396      * the first such subtag and all following subtags are ignored.</span>
<span class="line-added"> 397      * &lt;p&gt;</span>
<span class="line-added"> 398      * This implements the &#39;Language-Tag&#39; production of BCP47, and so</span>
<span class="line-added"> 399      * supports grandfathered (regular and irregular) as well as private</span>
<span class="line-added"> 400      * use language tags.  Private use tags are represented as &#39;x-whatever&#39;,</span>
<span class="line-added"> 401      * and grandfathered tags are converted to their canonical replacements</span>
<span class="line-added"> 402      * where they exist.  Note that a few grandfathered tags have no modern</span>
<span class="line-added"> 403      * replacement, these will be converted using the fallback described in</span>
<span class="line-added"> 404      * the first paragraph, so some information might be lost.</span>
<span class="line-added"> 405      * @param tag     the input BCP47 language tag.</span>
<span class="line-added"> 406      * @param status  error information if creating the Locale failed.</span>
<span class="line-added"> 407      * @return        the Locale for the specified BCP47 language tag.</span>
<span class="line-added"> 408      * @draft ICU 63</span>
<span class="line-added"> 409      */</span>
<span class="line-added"> 410     static Locale U_EXPORT2 forLanguageTag(StringPiece tag, UErrorCode&amp; status);</span>
<span class="line-added"> 411 </span>
<span class="line-added"> 412     /**</span>
<span class="line-added"> 413      * Returns a well-formed language tag for this Locale.</span>
<span class="line-added"> 414      * &lt;p&gt;</span>
<span class="line-added"> 415      * &lt;b&gt;Note&lt;/b&gt;: Any locale fields which do not satisfy the BCP47 syntax</span>
<span class="line-added"> 416      * requirement will be silently omitted from the result.</span>
<span class="line-added"> 417      *</span>
<span class="line-added"> 418      * If this function fails, partial output may have been written to the sink.</span>
<span class="line-added"> 419      *</span>
<span class="line-added"> 420      * @param sink    the output sink receiving the BCP47 language</span>
<span class="line-added"> 421      *                tag for this Locale.</span>
<span class="line-added"> 422      * @param status  error information if creating the language tag failed.</span>
<span class="line-added"> 423      * @draft ICU 63</span>
<span class="line-added"> 424      */</span>
<span class="line-added"> 425     void toLanguageTag(ByteSink&amp; sink, UErrorCode&amp; status) const;</span>
<span class="line-added"> 426 </span>
<span class="line-added"> 427     /**</span>
<span class="line-added"> 428      * Returns a well-formed language tag for this Locale.</span>
<span class="line-added"> 429      * &lt;p&gt;</span>
<span class="line-added"> 430      * &lt;b&gt;Note&lt;/b&gt;: Any locale fields which do not satisfy the BCP47 syntax</span>
<span class="line-added"> 431      * requirement will be silently omitted from the result.</span>
<span class="line-added"> 432      *</span>
<span class="line-added"> 433      * @param status  error information if creating the language tag failed.</span>
<span class="line-added"> 434      * @return        the BCP47 language tag for this Locale.</span>
<span class="line-added"> 435      * @draft ICU 63</span>
<span class="line-added"> 436      */</span>
<span class="line-added"> 437     template&lt;typename StringClass&gt;</span>
<span class="line-added"> 438     inline StringClass toLanguageTag(UErrorCode&amp; status) const;</span>
<span class="line-added"> 439 #endif  // U_HIDE_DRAFT_API</span>
<span class="line-added"> 440 </span>
 441     /**
 442      * Creates a locale which has had minimal canonicalization
 443      * as per uloc_getName().
 444      * @param name The name to create from.  If name is null,
 445      *  the default Locale is used.
 446      * @return new locale object
 447      * @stable ICU 2.0
 448      * @see uloc_getName
 449      */
 450     static Locale U_EXPORT2 createFromName(const char *name);
 451 
 452     /**
 453      * Creates a locale from the given string after canonicalizing
 454      * the string by calling uloc_canonicalize().
 455      * @param name the locale ID to create from.  Must not be NULL.
 456      * @return a new locale object corresponding to the given name
 457      * @stable ICU 3.0
 458      * @see uloc_canonicalize
 459      */
 460     static Locale U_EXPORT2 createCanonical(const char* name);
</pre>
<hr />
<pre>
 491 
 492     /**
 493      * Returns the programmatic name of the entire locale, with the language,
 494      * country and variant separated by underbars. If a field is missing, up
 495      * to two leading underbars will occur. Example: &quot;en&quot;, &quot;de_DE&quot;, &quot;en_US_WIN&quot;,
 496      * &quot;de__POSIX&quot;, &quot;fr__MAC&quot;, &quot;__MAC&quot;, &quot;_MT&quot;, &quot;_FR_EURO&quot;
 497      * @return      A pointer to &quot;name&quot;.
 498      * @stable ICU 2.0
 499      */
 500     inline const char * getName() const;
 501 
 502     /**
 503      * Returns the programmatic name of the entire locale as getName() would return,
 504      * but without keywords.
 505      * @return      A pointer to &quot;name&quot;.
 506      * @see getName
 507      * @stable ICU 2.8
 508      */
 509     const char * getBaseName() const;
 510 
<span class="line-added"> 511 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added"> 512     /**</span>
<span class="line-added"> 513      * Add the likely subtags for this Locale, per the algorithm described</span>
<span class="line-added"> 514      * in the following CLDR technical report:</span>
<span class="line-added"> 515      *</span>
<span class="line-added"> 516      *   http://www.unicode.org/reports/tr35/#Likely_Subtags</span>
<span class="line-added"> 517      *</span>
<span class="line-added"> 518      * If this Locale is already in the maximal form, or not valid, or there is</span>
<span class="line-added"> 519      * no data available for maximization, the Locale will be unchanged.</span>
<span class="line-added"> 520      *</span>
<span class="line-added"> 521      * For example, &quot;und-Zzzz&quot; cannot be maximized, since there is no</span>
<span class="line-added"> 522      * reasonable maximization.</span>
<span class="line-added"> 523      *</span>
<span class="line-added"> 524      * Examples:</span>
<span class="line-added"> 525      *</span>
<span class="line-added"> 526      * &quot;en&quot; maximizes to &quot;en_Latn_US&quot;</span>
<span class="line-added"> 527      *</span>
<span class="line-added"> 528      * &quot;de&quot; maximizes to &quot;de_Latn_US&quot;</span>
<span class="line-added"> 529      *</span>
<span class="line-added"> 530      * &quot;sr&quot; maximizes to &quot;sr_Cyrl_RS&quot;</span>
<span class="line-added"> 531      *</span>
<span class="line-added"> 532      * &quot;sh&quot; maximizes to &quot;sr_Latn_RS&quot; (Note this will not reverse.)</span>
<span class="line-added"> 533      *</span>
<span class="line-added"> 534      * &quot;zh_Hani&quot; maximizes to &quot;zh_Hans_CN&quot; (Note this will not reverse.)</span>
<span class="line-added"> 535      *</span>
<span class="line-added"> 536      * @param status  error information if maximizing this Locale failed.</span>
<span class="line-added"> 537      *                If this Locale is not well-formed, the error code is</span>
<span class="line-added"> 538      *                U_ILLEGAL_ARGUMENT_ERROR.</span>
<span class="line-added"> 539      * @draft ICU 63</span>
<span class="line-added"> 540      */</span>
<span class="line-added"> 541     void addLikelySubtags(UErrorCode&amp; status);</span>
<span class="line-added"> 542 </span>
<span class="line-added"> 543     /**</span>
<span class="line-added"> 544      * Minimize the subtags for this Locale, per the algorithm described</span>
<span class="line-added"> 545      * in the following CLDR technical report:</span>
<span class="line-added"> 546      *</span>
<span class="line-added"> 547      *   http://www.unicode.org/reports/tr35/#Likely_Subtags</span>
<span class="line-added"> 548      *</span>
<span class="line-added"> 549      * If this Locale is already in the minimal form, or not valid, or there is</span>
<span class="line-added"> 550      * no data available for minimization, the Locale will be unchanged.</span>
<span class="line-added"> 551      *</span>
<span class="line-added"> 552      * Since the minimization algorithm relies on proper maximization, see the</span>
<span class="line-added"> 553      * comments for addLikelySubtags for reasons why there might not be any</span>
<span class="line-added"> 554      * data.</span>
<span class="line-added"> 555      *</span>
<span class="line-added"> 556      * Examples:</span>
<span class="line-added"> 557      *</span>
<span class="line-added"> 558      * &quot;en_Latn_US&quot; minimizes to &quot;en&quot;</span>
<span class="line-added"> 559      *</span>
<span class="line-added"> 560      * &quot;de_Latn_US&quot; minimizes to &quot;de&quot;</span>
<span class="line-added"> 561      *</span>
<span class="line-added"> 562      * &quot;sr_Cyrl_RS&quot; minimizes to &quot;sr&quot;</span>
<span class="line-added"> 563      *</span>
<span class="line-added"> 564      * &quot;zh_Hant_TW&quot; minimizes to &quot;zh_TW&quot; (The region is preferred to the</span>
<span class="line-added"> 565      * script, and minimizing to &quot;zh&quot; would imply &quot;zh_Hans_CN&quot;.)</span>
<span class="line-added"> 566      *</span>
<span class="line-added"> 567      * @param status  error information if maximizing this Locale failed.</span>
<span class="line-added"> 568      *                If this Locale is not well-formed, the error code is</span>
<span class="line-added"> 569      *                U_ILLEGAL_ARGUMENT_ERROR.</span>
<span class="line-added"> 570      * @draft ICU 63</span>
<span class="line-added"> 571      */</span>
<span class="line-added"> 572     void minimizeSubtags(UErrorCode&amp; status);</span>
<span class="line-added"> 573 #endif  // U_HIDE_DRAFT_API</span>
 574 
 575     /**
 576      * Gets the list of keywords for the specified locale.
 577      *
 578      * @param status the status code
 579      * @return pointer to StringEnumeration class, or NULL if there are no keywords.
 580      * Client must dispose of it by calling delete.
<span class="line-added"> 581      * @see getKeywords</span>
 582      * @stable ICU 2.8
 583      */
 584     StringEnumeration * createKeywords(UErrorCode &amp;status) const;
 585 
<span class="line-added"> 586 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added"> 587 </span>
<span class="line-added"> 588     /**</span>
<span class="line-added"> 589      * Gets the list of Unicode keywords for the specified locale.</span>
<span class="line-added"> 590      *</span>
<span class="line-added"> 591      * @param status the status code</span>
<span class="line-added"> 592      * @return pointer to StringEnumeration class, or NULL if there are no keywords.</span>
<span class="line-added"> 593      * Client must dispose of it by calling delete.</span>
<span class="line-added"> 594      * @see getUnicodeKeywords</span>
<span class="line-added"> 595      * @draft ICU 63</span>
<span class="line-added"> 596      */</span>
<span class="line-added"> 597     StringEnumeration * createUnicodeKeywords(UErrorCode &amp;status) const;</span>
<span class="line-added"> 598 </span>
<span class="line-added"> 599     /**</span>
<span class="line-added"> 600      * Gets the set of keywords for this Locale.</span>
<span class="line-added"> 601      *</span>
<span class="line-added"> 602      * A wrapper to call createKeywords() and write the resulting</span>
<span class="line-added"> 603      * keywords as standard strings (or compatible objects) into any kind of</span>
<span class="line-added"> 604      * container that can be written to by an STL style output iterator.</span>
<span class="line-added"> 605      *</span>
<span class="line-added"> 606      * @param iterator  an STL style output iterator to write the keywords to.</span>
<span class="line-added"> 607      * @param status    error information if creating set of keywords failed.</span>
<span class="line-added"> 608      * @draft ICU 63</span>
<span class="line-added"> 609      */</span>
<span class="line-added"> 610     template&lt;typename StringClass, typename OutputIterator&gt;</span>
<span class="line-added"> 611     inline void getKeywords(OutputIterator iterator, UErrorCode&amp; status) const;</span>
<span class="line-added"> 612 </span>
<span class="line-added"> 613     /**</span>
<span class="line-added"> 614      * Gets the set of Unicode keywords for this Locale.</span>
<span class="line-added"> 615      *</span>
<span class="line-added"> 616      * A wrapper to call createUnicodeKeywords() and write the resulting</span>
<span class="line-added"> 617      * keywords as standard strings (or compatible objects) into any kind of</span>
<span class="line-added"> 618      * container that can be written to by an STL style output iterator.</span>
<span class="line-added"> 619      *</span>
<span class="line-added"> 620      * @param iterator  an STL style output iterator to write the keywords to.</span>
<span class="line-added"> 621      * @param status    error information if creating set of keywords failed.</span>
<span class="line-added"> 622      * @draft ICU 63</span>
<span class="line-added"> 623      */</span>
<span class="line-added"> 624     template&lt;typename StringClass, typename OutputIterator&gt;</span>
<span class="line-added"> 625     inline void getUnicodeKeywords(OutputIterator iterator, UErrorCode&amp; status) const;</span>
<span class="line-added"> 626 </span>
<span class="line-added"> 627 #endif  // U_HIDE_DRAFT_API</span>
<span class="line-added"> 628 </span>
 629     /**
 630      * Gets the value for a keyword.
 631      *
<span class="line-added"> 632      * This uses legacy keyword=value pairs, like &quot;collation=phonebook&quot;.</span>
<span class="line-added"> 633      *</span>
<span class="line-added"> 634      * ICU4C doesn&#39;t do automatic conversion between legacy and Unicode</span>
<span class="line-added"> 635      * keywords and values in getters and setters (as opposed to ICU4J).</span>
<span class="line-added"> 636      *</span>
 637      * @param keywordName name of the keyword for which we want the value. Case insensitive.
 638      * @param buffer The buffer to receive the keyword value.
 639      * @param bufferCapacity The capacity of receiving buffer
 640      * @param status Returns any error information while performing this operation.
 641      * @return the length of the keyword value
 642      *
 643      * @stable ICU 2.8
 644      */
 645     int32_t getKeywordValue(const char* keywordName, char *buffer, int32_t bufferCapacity, UErrorCode &amp;status) const;
 646 
<span class="line-added"> 647 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added"> 648     /**</span>
<span class="line-added"> 649      * Gets the value for a keyword.</span>
<span class="line-added"> 650      *</span>
<span class="line-added"> 651      * This uses legacy keyword=value pairs, like &quot;collation=phonebook&quot;.</span>
<span class="line-added"> 652      *</span>
<span class="line-added"> 653      * ICU4C doesn&#39;t do automatic conversion between legacy and Unicode</span>
<span class="line-added"> 654      * keywords and values in getters and setters (as opposed to ICU4J).</span>
<span class="line-added"> 655      *</span>
<span class="line-added"> 656      * @param keywordName  name of the keyword for which we want the value.</span>
<span class="line-added"> 657      * @param sink         the sink to receive the keyword value.</span>
<span class="line-added"> 658      * @param status       error information if getting the value failed.</span>
<span class="line-added"> 659      * @draft ICU 63</span>
<span class="line-added"> 660      */</span>
<span class="line-added"> 661     void getKeywordValue(StringPiece keywordName, ByteSink&amp; sink, UErrorCode&amp; status) const;</span>
<span class="line-added"> 662 </span>
<span class="line-added"> 663     /**</span>
<span class="line-added"> 664      * Gets the value for a keyword.</span>
<span class="line-added"> 665      *</span>
<span class="line-added"> 666      * This uses legacy keyword=value pairs, like &quot;collation=phonebook&quot;.</span>
<span class="line-added"> 667      *</span>
<span class="line-added"> 668      * ICU4C doesn&#39;t do automatic conversion between legacy and Unicode</span>
<span class="line-added"> 669      * keywords and values in getters and setters (as opposed to ICU4J).</span>
<span class="line-added"> 670      *</span>
<span class="line-added"> 671      * @param keywordName  name of the keyword for which we want the value.</span>
<span class="line-added"> 672      * @param status       error information if getting the value failed.</span>
<span class="line-added"> 673      * @return             the keyword value.</span>
<span class="line-added"> 674      * @draft ICU 63</span>
<span class="line-added"> 675      */</span>
<span class="line-added"> 676     template&lt;typename StringClass&gt;</span>
<span class="line-added"> 677     inline StringClass getKeywordValue(StringPiece keywordName, UErrorCode&amp; status) const;</span>
<span class="line-added"> 678 </span>
<span class="line-added"> 679     /**</span>
<span class="line-added"> 680      * Gets the Unicode value for a Unicode keyword.</span>
<span class="line-added"> 681      *</span>
<span class="line-added"> 682      * This uses Unicode key-value pairs, like &quot;co-phonebk&quot;.</span>
<span class="line-added"> 683      *</span>
<span class="line-added"> 684      * ICU4C doesn&#39;t do automatic conversion between legacy and Unicode</span>
<span class="line-added"> 685      * keywords and values in getters and setters (as opposed to ICU4J).</span>
<span class="line-added"> 686      *</span>
<span class="line-added"> 687      * @param keywordName  name of the keyword for which we want the value.</span>
<span class="line-added"> 688      * @param sink         the sink to receive the keyword value.</span>
<span class="line-added"> 689      * @param status       error information if getting the value failed.</span>
<span class="line-added"> 690      * @draft ICU 63</span>
<span class="line-added"> 691      */</span>
<span class="line-added"> 692     void getUnicodeKeywordValue(StringPiece keywordName, ByteSink&amp; sink, UErrorCode&amp; status) const;</span>
<span class="line-added"> 693 </span>
<span class="line-added"> 694     /**</span>
<span class="line-added"> 695      * Gets the Unicode value for a Unicode keyword.</span>
<span class="line-added"> 696      *</span>
<span class="line-added"> 697      * This uses Unicode key-value pairs, like &quot;co-phonebk&quot;.</span>
<span class="line-added"> 698      *</span>
<span class="line-added"> 699      * ICU4C doesn&#39;t do automatic conversion between legacy and Unicode</span>
<span class="line-added"> 700      * keywords and values in getters and setters (as opposed to ICU4J).</span>
<span class="line-added"> 701      *</span>
<span class="line-added"> 702      * @param keywordName  name of the keyword for which we want the value.</span>
<span class="line-added"> 703      * @param status       error information if getting the value failed.</span>
<span class="line-added"> 704      * @return             the keyword value.</span>
<span class="line-added"> 705      * @draft ICU 63</span>
<span class="line-added"> 706      */</span>
<span class="line-added"> 707     template&lt;typename StringClass&gt;</span>
<span class="line-added"> 708     inline StringClass getUnicodeKeywordValue(StringPiece keywordName, UErrorCode&amp; status) const;</span>
<span class="line-added"> 709 #endif  // U_HIDE_DRAFT_API</span>
<span class="line-added"> 710 </span>
 711     /**
 712      * Sets or removes the value for a keyword.
 713      *
 714      * For removing all keywords, use getBaseName(),
 715      * and construct a new Locale if it differs from getName().
 716      *
<span class="line-added"> 717      * This uses legacy keyword=value pairs, like &quot;collation=phonebook&quot;.</span>
<span class="line-added"> 718      *</span>
<span class="line-added"> 719      * ICU4C doesn&#39;t do automatic conversion between legacy and Unicode</span>
<span class="line-added"> 720      * keywords and values in getters and setters (as opposed to ICU4J).</span>
<span class="line-added"> 721      *</span>
 722      * @param keywordName name of the keyword to be set. Case insensitive.
 723      * @param keywordValue value of the keyword to be set. If 0-length or
 724      *  NULL, will result in the keyword being removed. No error is given if
 725      *  that keyword does not exist.
 726      * @param status Returns any error information while performing this operation.
 727      *
 728      * @stable ICU 49
 729      */
 730     void setKeywordValue(const char* keywordName, const char* keywordValue, UErrorCode &amp;status);
 731 
<span class="line-added"> 732 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added"> 733     /**</span>
<span class="line-added"> 734      * Sets or removes the value for a keyword.</span>
<span class="line-added"> 735      *</span>
<span class="line-added"> 736      * For removing all keywords, use getBaseName(),</span>
<span class="line-added"> 737      * and construct a new Locale if it differs from getName().</span>
<span class="line-added"> 738      *</span>
<span class="line-added"> 739      * This uses legacy keyword=value pairs, like &quot;collation=phonebook&quot;.</span>
<span class="line-added"> 740      *</span>
<span class="line-added"> 741      * ICU4C doesn&#39;t do automatic conversion between legacy and Unicode</span>
<span class="line-added"> 742      * keywords and values in getters and setters (as opposed to ICU4J).</span>
<span class="line-added"> 743      *</span>
<span class="line-added"> 744      * @param keywordName name of the keyword to be set.</span>
<span class="line-added"> 745      * @param keywordValue value of the keyword to be set. If 0-length or</span>
<span class="line-added"> 746      *  NULL, will result in the keyword being removed. No error is given if</span>
<span class="line-added"> 747      *  that keyword does not exist.</span>
<span class="line-added"> 748      * @param status Returns any error information while performing this operation.</span>
<span class="line-added"> 749      * @draft ICU 63</span>
<span class="line-added"> 750      */</span>
<span class="line-added"> 751     void setKeywordValue(StringPiece keywordName, StringPiece keywordValue, UErrorCode&amp; status);</span>
<span class="line-added"> 752 </span>
<span class="line-added"> 753     /**</span>
<span class="line-added"> 754      * Sets or removes the Unicode value for a Unicode keyword.</span>
<span class="line-added"> 755      *</span>
<span class="line-added"> 756      * For removing all keywords, use getBaseName(),</span>
<span class="line-added"> 757      * and construct a new Locale if it differs from getName().</span>
<span class="line-added"> 758      *</span>
<span class="line-added"> 759      * This uses Unicode key-value pairs, like &quot;co-phonebk&quot;.</span>
<span class="line-added"> 760      *</span>
<span class="line-added"> 761      * ICU4C doesn&#39;t do automatic conversion between legacy and Unicode</span>
<span class="line-added"> 762      * keywords and values in getters and setters (as opposed to ICU4J).</span>
<span class="line-added"> 763      *</span>
<span class="line-added"> 764      * @param keywordName name of the keyword to be set.</span>
<span class="line-added"> 765      * @param keywordValue value of the keyword to be set. If 0-length or</span>
<span class="line-added"> 766      *  NULL, will result in the keyword being removed. No error is given if</span>
<span class="line-added"> 767      *  that keyword does not exist.</span>
<span class="line-added"> 768      * @param status Returns any error information while performing this operation.</span>
<span class="line-added"> 769      * @draft ICU 63</span>
<span class="line-added"> 770      */</span>
<span class="line-added"> 771     void setUnicodeKeywordValue(StringPiece keywordName, StringPiece keywordValue, UErrorCode&amp; status);</span>
<span class="line-added"> 772 #endif  // U_HIDE_DRAFT_API</span>
<span class="line-added"> 773 </span>
 774     /**
 775      * returns the locale&#39;s three-letter language code, as specified
 776      * in ISO draft standard ISO-639-2.
 777      * @return      An alias to the code, or an empty string
 778      * @stable ICU 2.0
 779      */
 780     const char * getISO3Language() const;
 781 
 782     /**
 783      * Fills in &quot;name&quot; with the locale&#39;s three-letter ISO-3166 country code.
 784      * @return      An alias to the code, or an empty string
 785      * @stable ICU 2.0
 786      */
 787     const char * getISO3Country() const;
 788 
 789     /**
 790      * Returns the Windows LCID value corresponding to this locale.
 791      * This value is stored in the resource data for the locale as a one-to-four-digit
 792      * hexadecimal number.  If the resource is missing, in the wrong format, or
 793      * there is no Windows LCID value that corresponds to this locale, returns 0.
</pre>
<hr />
<pre>
 945      * Generates a hash code for the locale.
 946      * @stable ICU 2.0
 947      */
 948     int32_t         hashCode(void) const;
 949 
 950     /**
 951      * Sets the locale to bogus
 952      * A bogus locale represents a non-existing locale associated
 953      * with services that can be instantiated from non-locale data
 954      * in addition to locale (for example, collation can be
 955      * instantiated from a locale and from a rule set).
 956      * @stable ICU 2.1
 957      */
 958     void setToBogus();
 959 
 960     /**
 961      * Gets the bogus state. Locale object can be bogus if it doesn&#39;t exist
 962      * @return FALSE if it is a real locale, TRUE if it is a bogus locale
 963      * @stable ICU 2.1
 964      */
<span class="line-modified"> 965     inline UBool isBogus(void) const;</span>
 966 
 967     /**
 968      * Returns a list of all installed locales.
 969      * @param count Receives the number of locales in the list.
 970      * @return      A pointer to an array of Locale objects.  This array is the list
 971      *              of all locales with installed resource files.  The called does NOT
 972      *              get ownership of this list, and must NOT delete it.
 973      * @stable ICU 2.0
 974      */
 975     static const Locale* U_EXPORT2 getAvailableLocales(int32_t&amp; count);
 976 
 977     /**
 978      * Gets a list of all available 2-letter country codes defined in ISO 3166.  This is a
 979      * pointer to an array of pointers to arrays of char.  All of these pointers are
 980      * owned by ICU-- do not delete them, and do not write through them.  The array is
 981      * terminated with a null pointer.
 982      * @return a list of all available country codes
 983      * @stable ICU 2.0
 984      */
 985     static const char* const* U_EXPORT2 getISOCountries();
</pre>
<hr />
<pre>
1041      * Initialize the locale cache for commonly used locales
1042      */
1043     static Locale *getLocaleCache(void);
1044 
1045     char language[ULOC_LANG_CAPACITY];
1046     char script[ULOC_SCRIPT_CAPACITY];
1047     char country[ULOC_COUNTRY_CAPACITY];
1048     int32_t variantBegin;
1049     char* fullName;
1050     char fullNameBuffer[ULOC_FULLNAME_CAPACITY];
1051     // name without keywords
1052     char* baseName;
1053     void initBaseName(UErrorCode&amp; status);
1054 
1055     UBool fIsBogus;
1056 
1057     static const Locale &amp;getLocale(int locid);
1058 
1059     /**
1060      * A friend to allow the default locale to be set by either the C or C++ API.
<span class="line-modified">1061      * @internal (private)</span>
1062      */
1063     friend Locale *locale_set_default_internal(const char *, UErrorCode&amp; status);
1064 
1065     /**
<span class="line-modified">1066      * @internal (private)</span>
1067      */
1068     friend void U_CALLCONV locale_available_init();
1069 };
1070 
1071 inline UBool
1072 Locale::operator!=(const    Locale&amp;     other) const
1073 {
1074     return !operator==(other);
1075 }
1076 
<span class="line-added">1077 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added">1078 template&lt;typename StringClass&gt; inline StringClass</span>
<span class="line-added">1079 Locale::toLanguageTag(UErrorCode&amp; status) const</span>
<span class="line-added">1080 {</span>
<span class="line-added">1081     StringClass result;</span>
<span class="line-added">1082     StringByteSink&lt;StringClass&gt; sink(&amp;result);</span>
<span class="line-added">1083     toLanguageTag(sink, status);</span>
<span class="line-added">1084     return result;</span>
<span class="line-added">1085 }</span>
<span class="line-added">1086 #endif  // U_HIDE_DRAFT_API</span>
<span class="line-added">1087 </span>
1088 inline const char *
1089 Locale::getCountry() const
1090 {
1091     return country;
1092 }
1093 
1094 inline const char *
1095 Locale::getLanguage() const
1096 {
1097     return language;
1098 }
1099 
1100 inline const char *
1101 Locale::getScript() const
1102 {
1103     return script;
1104 }
1105 
1106 inline const char *
1107 Locale::getVariant() const
<span class="line-added">1118 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added">1119 </span>
<span class="line-added">1120 template&lt;typename StringClass, typename OutputIterator&gt; inline void</span>
<span class="line-added">1121 Locale::getKeywords(OutputIterator iterator, UErrorCode&amp; status) const</span>
<span class="line-added">1122 {</span>
<span class="line-added">1123     LocalPointer&lt;StringEnumeration&gt; keys(createKeywords(status));</span>
<span class="line-added">1124     if (U_FAILURE(status)) {</span>
<span class="line-added">1125         return;</span>
<span class="line-added">1126     }</span>
<span class="line-added">1127     for (;;) {</span>
<span class="line-added">1128         int32_t resultLength;</span>
<span class="line-added">1129         const char* buffer = keys-&gt;next(&amp;resultLength, status);</span>
<span class="line-added">1130         if (U_FAILURE(status) || buffer == nullptr) {</span>
<span class="line-added">1131             return;</span>
<span class="line-added">1132         }</span>
<span class="line-added">1133         *iterator++ = StringClass(buffer, resultLength);</span>
<span class="line-added">1134     }</span>
<span class="line-added">1135 }</span>
<span class="line-added">1136 </span>
<span class="line-added">1137 template&lt;typename StringClass, typename OutputIterator&gt; inline void</span>
<span class="line-added">1138 Locale::getUnicodeKeywords(OutputIterator iterator, UErrorCode&amp; status) const</span>
<span class="line-added">1139 {</span>
<span class="line-added">1140     LocalPointer&lt;StringEnumeration&gt; keys(createUnicodeKeywords(status));</span>
<span class="line-added">1141     if (U_FAILURE(status)) {</span>
<span class="line-added">1142         return;</span>
<span class="line-added">1143     }</span>
<span class="line-added">1144     for (;;) {</span>
<span class="line-added">1145         int32_t resultLength;</span>
<span class="line-added">1146         const char* buffer = keys-&gt;next(&amp;resultLength, status);</span>
<span class="line-added">1147         if (U_FAILURE(status) || buffer == nullptr) {</span>
<span class="line-added">1148             return;</span>
<span class="line-added">1149         }</span>
<span class="line-added">1150         *iterator++ = StringClass(buffer, resultLength);</span>
<span class="line-added">1151     }</span>
<span class="line-added">1152 }</span>
<span class="line-added">1153 </span>
<span class="line-added">1154 template&lt;typename StringClass&gt; inline StringClass</span>
<span class="line-added">1155 Locale::getKeywordValue(StringPiece keywordName, UErrorCode&amp; status) const</span>
<span class="line-added">1156 {</span>
<span class="line-added">1157     StringClass result;</span>
<span class="line-added">1158     StringByteSink&lt;StringClass&gt; sink(&amp;result);</span>
<span class="line-added">1159     getKeywordValue(keywordName, sink, status);</span>
<span class="line-added">1160     return result;</span>
<span class="line-added">1161 }</span>
<span class="line-added">1162 </span>
<span class="line-added">1163 template&lt;typename StringClass&gt; inline StringClass</span>
<span class="line-added">1164 Locale::getUnicodeKeywordValue(StringPiece keywordName, UErrorCode&amp; status) const</span>
<span class="line-added">1165 {</span>
<span class="line-added">1166     StringClass result;</span>
<span class="line-added">1167     StringByteSink&lt;StringClass&gt; sink(&amp;result);</span>
<span class="line-added">1168     getUnicodeKeywordValue(keywordName, sink, status);</span>
<span class="line-added">1169     return result;</span>
<span class="line-added">1170 }</span>
<span class="line-added">1171 </span>
<span class="line-added">1172 #endif  // U_HIDE_DRAFT_API</span>
<span class="line-added">1173 </span>
1174 inline UBool
1175 Locale::isBogus(void) const {
1176     return fIsBogus;
1177 }
1178 
1179 U_NAMESPACE_END
1180 
1181 #endif
</pre>
</td>
</tr>
</table>
<center><a href="locdspnm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="messagepattern.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>