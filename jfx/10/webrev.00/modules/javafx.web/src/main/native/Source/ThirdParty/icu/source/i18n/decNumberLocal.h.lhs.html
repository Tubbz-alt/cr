<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/decNumberLocal.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /* ------------------------------------------------------------------ */
  4 /* decNumber package local type, tuning, and macro definitions        */
  5 /* ------------------------------------------------------------------ */
  6 /* Copyright (c) IBM Corporation, 2000-2016.   All rights reserved.   */
  7 /*                                                                    */
  8 /* This software is made available under the terms of the             */
  9 /* ICU License -- ICU 1.8.1 and later.                                */
 10 /*                                                                    */
 11 /* The description and User&#39;s Guide (&quot;The decNumber C Library&quot;) for   */
 12 /* this software is called decNumber.pdf.  This document is           */
 13 /* available, together with arithmetic and format specifications,     */
 14 /* testcases, and Web links, on the General Decimal Arithmetic page.  */
 15 /*                                                                    */
 16 /* Please send comments, suggestions, and corrections to the author:  */
 17 /*   mfc@uk.ibm.com                                                   */
 18 /*   Mike Cowlishaw, IBM Fellow                                       */
 19 /*   IBM UK, PO Box 31, Birmingham Road, Warwick CV34 5JL, UK         */
 20 /* ------------------------------------------------------------------ */
 21 /* This header file is included by all modules in the decNumber       */
 22 /* library, and contains local type definitions, tuning parameters,   */
 23 /* etc.  It should not need to be used by application programs.       */
 24 /* decNumber.h or one of decDouble (etc.) must be included first.     */
 25 /* ------------------------------------------------------------------ */
 26 
 27 #if !defined(DECNUMBERLOC)
 28   #define DECNUMBERLOC
 29   #define DECVERSION    &quot;decNumber 3.61&quot; /* Package Version [16 max.] */
 30   #define DECNLAUTHOR   &quot;Mike Cowlishaw&quot;              /* Who to blame */
 31 
 32   #include &lt;stdlib.h&gt;         /* for abs                              */
 33   #include &lt;string.h&gt;         /* for memset, strcpy                   */
 34   #include &quot;decContext.h&quot;
 35 
 36   /* Conditional code flag -- set this to match hardware platform     */
 37   #if !defined(DECLITEND)
 38   #define DECLITEND 1         /* 1=little-endian, 0=big-endian        */
 39   #endif
 40 
 41   /* Conditional code flag -- set this to 1 for best performance      */
 42   #if !defined(DECUSE64)
 43   #define DECUSE64  1         /* 1=use int64s, 0=int32 &amp; smaller only */
 44   #endif
 45 
 46   /* Conditional check flags -- set these to 0 for best performance   */
 47   #if !defined(DECCHECK)
 48   #define DECCHECK  0         /* 1 to enable robust checking          */
 49   #endif
 50   #if !defined(DECALLOC)
 51   #define DECALLOC  0         /* 1 to enable memory accounting        */
 52   #endif
 53   #if !defined(DECTRACE)
 54   #define DECTRACE  0         /* 1 to trace certain internals, etc.   */
 55   #endif
 56 
 57   /* Tuning parameter for decNumber (arbitrary precision) module      */
 58   #if !defined(DECBUFFER)
 59   #define DECBUFFER 36        /* Size basis for local buffers.  This  */
 60                               /* should be a common maximum precision */
 61                               /* rounded up to a multiple of 4; must  */
 62                               /* be zero or positive.                 */
 63   #endif
 64 
 65   /* ---------------------------------------------------------------- */
 66   /* Definitions for all modules (general-purpose)                    */
 67   /* ---------------------------------------------------------------- */
 68 
 69   /* Local names for common types -- for safety, decNumber modules do */
 70   /* not use int or long directly.                                    */
 71   #define Flag   uint8_t
 72   #define Byte   int8_t
 73   #define uByte  uint8_t
 74   #define Short  int16_t
 75   #define uShort uint16_t
 76   #define Int    int32_t
 77   #define uInt   uint32_t
 78   #define Unit   decNumberUnit
 79   #if DECUSE64
 80   #define Long   int64_t
 81   #define uLong  uint64_t
 82   #endif
 83 
 84   /* Development-use definitions                                      */
 85   typedef long int LI;        /* for printf arguments only            */
 86   #define DECNOINT  0         /* 1 to check no internal use of &#39;int&#39;  */
 87                               /*   or stdint types                    */
 88   #if DECNOINT
 89     /* if these interfere with your C includes, do not set DECNOINT   */
 90     #define int     ?         /* enable to ensure that plain C &#39;int&#39;  */
 91     #define long    ??        /* .. or &#39;long&#39; types are not used      */
 92   #endif
 93 
 94   /* LONGMUL32HI -- set w=(u*v)&gt;&gt;32, where w, u, and v are uInts      */
 95   /* (that is, sets w to be the high-order word of the 64-bit result; */
 96   /* the low-order word is simply u*v.)                               */
 97   /* This version is derived from Knuth via Hacker&#39;s Delight;         */
 98   /* it seems to optimize better than some others tried               */
 99   #define LONGMUL32HI(w, u, v) {             \
100     uInt u0, u1, v0, v1, w0, w1, w2, t;      \
101     u0=u &amp; 0xffff; u1=u&gt;&gt;16;                 \
102     v0=v &amp; 0xffff; v1=v&gt;&gt;16;                 \
103     w0=u0*v0;                                \
104     t=u1*v0 + (w0&gt;&gt;16);                      \
105     w1=t &amp; 0xffff; w2=t&gt;&gt;16;                 \
106     w1=u0*v1 + w1;                           \
107     (w)=u1*v1 + w2 + (w1&gt;&gt;16);}
108 
109   /* ROUNDUP -- round an integer up to a multiple of n                */
110   #define ROUNDUP(i, n) ((((i)+(n)-1)/n)*n)
111   #define ROUNDUP4(i)   (((i)+3)&amp;~3)    /* special for n=4            */
112 
113   /* ROUNDDOWN -- round an integer down to a multiple of n            */
114   #define ROUNDDOWN(i, n) (((i)/n)*n)
115   #define ROUNDDOWN4(i)   ((i)&amp;~3)      /* special for n=4            */
116 
117   /* References to multi-byte sequences under different sizes; these  */
118   /* require locally declared variables, but do not violate strict    */
119   /* aliasing or alignment (as did the UINTAT simple cast to uInt).   */
120   /* Variables needed are uswork, uiwork, etc. [so do not use at same */
121   /* level in an expression, e.g., UBTOUI(x)==UBTOUI(y) may fail].    */
122 
123   /* Return a uInt, etc., from bytes starting at a char* or uByte*    */
124   #define UBTOUS(b)  (memcpy((void *)&amp;uswork, b, 2), uswork)
125   #define UBTOUI(b)  (memcpy((void *)&amp;uiwork, b, 4), uiwork)
126 
127   /* Store a uInt, etc., into bytes starting at a char* or uByte*.    */
128   /* Returns i, evaluated, for convenience; has to use uiwork because */
129   /* i may be an expression.                                          */
130   #define UBFROMUS(b, i)  (uswork=(i), memcpy(b, (void *)&amp;uswork, 2), uswork)
131   #define UBFROMUI(b, i)  (uiwork=(i), memcpy(b, (void *)&amp;uiwork, 4), uiwork)
132 
133   /* X10 and X100 -- multiply integer i by 10 or 100                  */
134   /* [shifts are usually faster than multiply; could be conditional]  */
135   #define X10(i)  (((i)&lt;&lt;1)+((i)&lt;&lt;3))
136   #define X100(i) (((i)&lt;&lt;2)+((i)&lt;&lt;5)+((i)&lt;&lt;6))
137 
138   /* MAXI and MINI -- general max &amp; min (not in ANSI) for integers    */
139   #define MAXI(x,y) ((x)&lt;(y)?(y):(x))
140   #define MINI(x,y) ((x)&gt;(y)?(y):(x))
141 
142   /* Useful constants                                                 */
143   #define BILLION      1000000000            /* 10**9                 */
144   /* CHARMASK: 0x30303030 for ASCII/UTF8; 0xF0F0F0F0 for EBCDIC       */
145   #define CHARMASK ((((((((uInt)&#39;0&#39;)&lt;&lt;8)+&#39;0&#39;)&lt;&lt;8)+&#39;0&#39;)&lt;&lt;8)+&#39;0&#39;)
146 
147 
148   /* ---------------------------------------------------------------- */
149   /* Definitions for arbitary-precision modules (only valid after     */
150   /* decNumber.h has been included)                                   */
151   /* ---------------------------------------------------------------- */
152 
153   /* Limits and constants                                             */
154   #define DECNUMMAXP 999999999  /* maximum precision code can handle  */
155   #define DECNUMMAXE 999999999  /* maximum adjusted exponent ditto    */
156   #define DECNUMMINE -999999999 /* minimum adjusted exponent ditto    */
157   #if (DECNUMMAXP != DEC_MAX_DIGITS)
158     #error Maximum digits mismatch
159   #endif
160   #if (DECNUMMAXE != DEC_MAX_EMAX)
161     #error Maximum exponent mismatch
162   #endif
163   #if (DECNUMMINE != DEC_MIN_EMIN)
164     #error Minimum exponent mismatch
165   #endif
166 
167   /* Set DECDPUNMAX -- the maximum integer that fits in DECDPUN       */
168   /* digits, and D2UTABLE -- the initializer for the D2U table        */
<a name="1" id="anc1"></a><span class="line-modified">169   #if   DECDPUN==1</span>


170     #define DECDPUNMAX 9
171     #define D2UTABLE {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,  \
172                       18,19,20,21,22,23,24,25,26,27,28,29,30,31,32, \
173                       33,34,35,36,37,38,39,40,41,42,43,44,45,46,47, \
174                       48,49}
175   #elif DECDPUN==2
176     #define DECDPUNMAX 99
177     #define D2UTABLE {0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,  \
178                       11,11,12,12,13,13,14,14,15,15,16,16,17,17,18, \
179                       18,19,19,20,20,21,21,22,22,23,23,24,24,25}
180   #elif DECDPUN==3
181     #define DECDPUNMAX 999
182     #define D2UTABLE {0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,  \
183                       8,8,8,9,9,9,10,10,10,11,11,11,12,12,12,13,13, \
184                       13,14,14,14,15,15,15,16,16,16,17}
185   #elif DECDPUN==4
186     #define DECDPUNMAX 9999
187     #define D2UTABLE {0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,  \
188                       6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11, \
189                       11,11,11,12,12,12,12,13}
190   #elif DECDPUN==5
191     #define DECDPUNMAX 99999
192     #define D2UTABLE {0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,  \
193                       5,5,5,5,6,6,6,6,6,7,7,7,7,7,8,8,8,8,8,9,9,9,  \
194                       9,9,10,10,10,10}
195   #elif DECDPUN==6
196     #define DECDPUNMAX 999999
197     #define D2UTABLE {0,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,  \
198                       4,4,4,5,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,8,  \
199                       8,8,8,8,8,9}
200   #elif DECDPUN==7
201     #define DECDPUNMAX 9999999
202     #define D2UTABLE {0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3,  \
203                       4,4,4,4,4,4,4,5,5,5,5,5,5,5,6,6,6,6,6,6,6,7,  \
204                       7,7,7,7,7,7}
205   #elif DECDPUN==8
206     #define DECDPUNMAX 99999999
207     #define D2UTABLE {0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,  \
208                       3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,  \
209                       6,6,6,6,6,7}
210   #elif DECDPUN==9
211     #define DECDPUNMAX 999999999
212     #define D2UTABLE {0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,  \
213                       3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,  \
214                       5,5,6,6,6,6}
<a name="2" id="anc2"></a><span class="line-modified">215   #elif defined(DECDPUN)</span>
216     #error DECDPUN must be in the range 1-9
217   #endif
218 
219   /* ----- Shared data (in decNumber.c) ----- */
220   /* Public lookup table used by the D2U macro (see below)            */
221   #define DECMAXD2U 49
222   /*extern const uByte d2utable[DECMAXD2U+1];*/
223 
224   /* ----- Macros ----- */
225   /* ISZERO -- return true if decNumber dn is a zero                  */
226   /* [performance-critical in some situations]                        */
227   #define ISZERO(dn) decNumberIsZero(dn)     /* now just a local name */
228 
229   /* D2U -- return the number of Units needed to hold d digits        */
230   /* (runtime version, with table lookaside for small d)              */
<a name="3" id="anc3"></a><span class="line-modified">231   #if DECDPUN==8</span>
232     #define D2U(d) ((unsigned)((d)&lt;=DECMAXD2U?d2utable[d]:((d)+7)&gt;&gt;3))
<a name="4" id="anc4"></a><span class="line-modified">233   #elif DECDPUN==4</span>
234     #define D2U(d) ((unsigned)((d)&lt;=DECMAXD2U?d2utable[d]:((d)+3)&gt;&gt;2))
235   #else
236     #define D2U(d) ((d)&lt;=DECMAXD2U?d2utable[d]:((d)+DECDPUN-1)/DECDPUN)
237   #endif
238   /* SD2U -- static D2U macro (for compile-time calculation)          */
239   #define SD2U(d) (((d)+DECDPUN-1)/DECDPUN)
240 
241   /* MSUDIGITS -- returns digits in msu, from digits, calculated      */
242   /* using D2U                                                        */
243   #define MSUDIGITS(d) ((d)-(D2U(d)-1)*DECDPUN)
244 
245   /* D2N -- return the number of decNumber structs that would be      */
246   /* needed to contain that number of digits (and the initial         */
247   /* decNumber struct) safely.  Note that one Unit is included in the */
248   /* initial structure.  Used for allocating space that is aligned on */
249   /* a decNumber struct boundary. */
250   #define D2N(d) \
251     ((((SD2U(d)-1)*sizeof(Unit))+sizeof(decNumber)*2-1)/sizeof(decNumber))
252 
253   /* TODIGIT -- macro to remove the leading digit from the unsigned   */
254   /* integer u at column cut (counting from the right, LSD=0) and     */
255   /* place it as an ASCII character into the character pointed to by  */
256   /* c.  Note that cut must be &lt;= 9, and the maximum value for u is   */
257   /* 2,000,000,000 (as is needed for negative exponents of            */
258   /* subnormals).  The unsigned integer pow is used as a temporary    */
259   /* variable. */
260   #define TODIGIT(u, cut, c, pow) {       \
261     *(c)=&#39;0&#39;;                             \
262     pow=DECPOWERS[cut]*2;                 \
263     if ((u)&gt;pow) {                        \
264       pow*=4;                             \
265       if ((u)&gt;=pow) {(u)-=pow; *(c)+=8;}  \
266       pow/=2;                             \
267       if ((u)&gt;=pow) {(u)-=pow; *(c)+=4;}  \
268       pow/=2;                             \
269       }                                   \
270     if ((u)&gt;=pow) {(u)-=pow; *(c)+=2;}    \
271     pow/=2;                               \
272     if ((u)&gt;=pow) {(u)-=pow; *(c)+=1;}    \
273     }
274 
275   /* ---------------------------------------------------------------- */
276   /* Definitions for fixed-precision modules (only valid after        */
277   /* decSingle.h, decDouble.h, or decQuad.h has been included)        */
278   /* ---------------------------------------------------------------- */
279 
280   /* bcdnum -- a structure describing a format-independent finite     */
281   /* number, whose coefficient is a string of bcd8 uBytes             */
282   typedef struct {
283     uByte   *msd;             /* -&gt; most significant digit            */
284     uByte   *lsd;             /* -&gt; least ditto                       */
285     uInt     sign;            /* 0=positive, DECFLOAT_Sign=negative   */
286     Int      exponent;        /* Unadjusted signed exponent (q), or   */
287                               /* DECFLOAT_NaN etc. for a special      */
288     } bcdnum;
289 
290   /* Test if exponent or bcdnum exponent must be a special, etc.      */
291   #define EXPISSPECIAL(exp) ((exp)&gt;=DECFLOAT_MinSp)
292   #define EXPISINF(exp) (exp==DECFLOAT_Inf)
293   #define EXPISNAN(exp) (exp==DECFLOAT_qNaN || exp==DECFLOAT_sNaN)
294   #define NUMISSPECIAL(num) (EXPISSPECIAL((num)-&gt;exponent))
295 
296   /* Refer to a 32-bit word or byte in a decFloat (df) by big-endian  */
297   /* (array) notation (the 0 word or byte contains the sign bit),     */
298   /* automatically adjusting for endianness; similarly address a word */
299   /* in the next-wider format (decFloatWider, or dfw)                 */
300   #define DECWORDS  (DECBYTES/4)
301   #define DECWWORDS (DECWBYTES/4)
302   #if DECLITEND
303     #define DFBYTE(df, off)   ((df)-&gt;bytes[DECBYTES-1-(off)])
304     #define DFWORD(df, off)   ((df)-&gt;words[DECWORDS-1-(off)])
305     #define DFWWORD(dfw, off) ((dfw)-&gt;words[DECWWORDS-1-(off)])
306   #else
307     #define DFBYTE(df, off)   ((df)-&gt;bytes[off])
308     #define DFWORD(df, off)   ((df)-&gt;words[off])
309     #define DFWWORD(dfw, off) ((dfw)-&gt;words[off])
310   #endif
311 
312   /* Tests for sign or specials, directly on DECFLOATs                */
313   #define DFISSIGNED(df)   (DFWORD(df, 0)&amp;0x80000000)
314   #define DFISSPECIAL(df) ((DFWORD(df, 0)&amp;0x78000000)==0x78000000)
315   #define DFISINF(df)     ((DFWORD(df, 0)&amp;0x7c000000)==0x78000000)
316   #define DFISNAN(df)     ((DFWORD(df, 0)&amp;0x7c000000)==0x7c000000)
317   #define DFISQNAN(df)    ((DFWORD(df, 0)&amp;0x7e000000)==0x7c000000)
318   #define DFISSNAN(df)    ((DFWORD(df, 0)&amp;0x7e000000)==0x7e000000)
319 
320   /* Shared lookup tables                                             */
321   extern const uInt   DECCOMBMSD[64];   /* Combination field -&gt; MSD   */
322   extern const uInt   DECCOMBFROM[48];  /* exp+msd -&gt; Combination     */
323 
324   /* Private generic (utility) routine                                */
325   #if DECCHECK || DECTRACE
326     extern void decShowNum(const bcdnum *, const char *);
327   #endif
328 
329   /* Format-dependent macros and constants                            */
330   #if defined(DECPMAX)
331 
332     /* Useful constants                                               */
333     #define DECPMAX9  (ROUNDUP(DECPMAX, 9)/9)  /* &#39;Pmax&#39; in 10**9s    */
334     /* Top words for a zero                                           */
335     #define SINGLEZERO   0x22500000
336     #define DOUBLEZERO   0x22380000
337     #define QUADZERO     0x22080000
338     /* [ZEROWORD is defined to be one of these in the DFISZERO macro] */
339 
340     /* Format-dependent common tests:                                 */
341     /*   DFISZERO   -- test for (any) zero                            */
342     /*   DFISCCZERO -- test for coefficient continuation being zero   */
343     /*   DFISCC01   -- test for coefficient contains only 0s and 1s   */
344     /*   DFISINT    -- test for finite and exponent q=0               */
345     /*   DFISUINT01 -- test for sign=0, finite, exponent q=0, and     */
346     /*                 MSD=0 or 1                                     */
347     /*   ZEROWORD is also defined here.                               */
348     /* In DFISZERO the first test checks the least-significant word   */
349     /* (most likely to be non-zero); the penultimate tests MSD and    */
350     /* DPDs in the signword, and the final test excludes specials and */
351     /* MSD&gt;7.  DFISINT similarly has to allow for the two forms of    */
352     /* MSD codes.  DFISUINT01 only has to allow for one form of MSD   */
353     /* code.                                                          */
354     #if DECPMAX==7
355       #define ZEROWORD SINGLEZERO
356       /* [test macros not needed except for Zero]                     */
357       #define DFISZERO(df)  ((DFWORD(df, 0)&amp;0x1c0fffff)==0         \
358                           &amp;&amp; (DFWORD(df, 0)&amp;0x60000000)!=0x60000000)
359     #elif DECPMAX==16
360       #define ZEROWORD DOUBLEZERO
361       #define DFISZERO(df)  ((DFWORD(df, 1)==0                     \
362                           &amp;&amp; (DFWORD(df, 0)&amp;0x1c03ffff)==0         \
363                           &amp;&amp; (DFWORD(df, 0)&amp;0x60000000)!=0x60000000))
364       #define DFISINT(df) ((DFWORD(df, 0)&amp;0x63fc0000)==0x22380000  \
365                          ||(DFWORD(df, 0)&amp;0x7bfc0000)==0x6a380000)
366       #define DFISUINT01(df) ((DFWORD(df, 0)&amp;0xfbfc0000)==0x22380000)
367       #define DFISCCZERO(df) (DFWORD(df, 1)==0                     \
368                           &amp;&amp; (DFWORD(df, 0)&amp;0x0003ffff)==0)
369       #define DFISCC01(df)  ((DFWORD(df, 0)&amp;~0xfffc9124)==0        \
370                           &amp;&amp; (DFWORD(df, 1)&amp;~0x49124491)==0)
371     #elif DECPMAX==34
372       #define ZEROWORD QUADZERO
373       #define DFISZERO(df)  ((DFWORD(df, 3)==0                     \
374                           &amp;&amp;  DFWORD(df, 2)==0                     \
375                           &amp;&amp;  DFWORD(df, 1)==0                     \
376                           &amp;&amp; (DFWORD(df, 0)&amp;0x1c003fff)==0         \
377                           &amp;&amp; (DFWORD(df, 0)&amp;0x60000000)!=0x60000000))
378       #define DFISINT(df) ((DFWORD(df, 0)&amp;0x63ffc000)==0x22080000  \
379                          ||(DFWORD(df, 0)&amp;0x7bffc000)==0x6a080000)
380       #define DFISUINT01(df) ((DFWORD(df, 0)&amp;0xfbffc000)==0x22080000)
381       #define DFISCCZERO(df) (DFWORD(df, 3)==0                     \
382                           &amp;&amp;  DFWORD(df, 2)==0                     \
383                           &amp;&amp;  DFWORD(df, 1)==0                     \
384                           &amp;&amp; (DFWORD(df, 0)&amp;0x00003fff)==0)
385 
386       #define DFISCC01(df)   ((DFWORD(df, 0)&amp;~0xffffc912)==0       \
387                           &amp;&amp;  (DFWORD(df, 1)&amp;~0x44912449)==0       \
388                           &amp;&amp;  (DFWORD(df, 2)&amp;~0x12449124)==0       \
389                           &amp;&amp;  (DFWORD(df, 3)&amp;~0x49124491)==0)
390     #endif
391 
392     /* Macros to test if a certain 10 bits of a uInt or pair of uInts */
393     /* are a canonical declet [higher or lower bits are ignored].     */
394     /* declet is at offset 0 (from the right) in a uInt:              */
395     #define CANONDPD(dpd) (((dpd)&amp;0x300)==0 || ((dpd)&amp;0x6e)!=0x6e)
396     /* declet is at offset k (a multiple of 2) in a uInt:             */
397     #define CANONDPDOFF(dpd, k) (((dpd)&amp;(0x300&lt;&lt;(k)))==0            \
398       || ((dpd)&amp;(((uInt)0x6e)&lt;&lt;(k)))!=(((uInt)0x6e)&lt;&lt;(k)))
399     /* declet is at offset k (a multiple of 2) in a pair of uInts:    */
400     /* [the top 2 bits will always be in the more-significant uInt]   */
401     #define CANONDPDTWO(hi, lo, k) (((hi)&amp;(0x300&gt;&gt;(32-(k))))==0     \
402       || ((hi)&amp;(0x6e&gt;&gt;(32-(k))))!=(0x6e&gt;&gt;(32-(k)))                  \
403       || ((lo)&amp;(((uInt)0x6e)&lt;&lt;(k)))!=(((uInt)0x6e)&lt;&lt;(k)))
404 
405     /* Macro to test whether a full-length (length DECPMAX) BCD8      */
406     /* coefficient, starting at uByte u, is all zeros                 */
407     /* Test just the LSWord first, then the remainder as a sequence   */
408     /* of tests in order to avoid same-level use of UBTOUI            */
409     #if DECPMAX==7
410       #define ISCOEFFZERO(u) (                                      \
411            UBTOUI((u)+DECPMAX-4)==0                                 \
412         &amp;&amp; UBTOUS((u)+DECPMAX-6)==0                                 \
413         &amp;&amp; *(u)==0)
414     #elif DECPMAX==16
415       #define ISCOEFFZERO(u) (                                      \
416            UBTOUI((u)+DECPMAX-4)==0                                 \
417         &amp;&amp; UBTOUI((u)+DECPMAX-8)==0                                 \
418         &amp;&amp; UBTOUI((u)+DECPMAX-12)==0                                \
419         &amp;&amp; UBTOUI(u)==0)
420     #elif DECPMAX==34
421       #define ISCOEFFZERO(u) (                                      \
422            UBTOUI((u)+DECPMAX-4)==0                                 \
423         &amp;&amp; UBTOUI((u)+DECPMAX-8)==0                                 \
424         &amp;&amp; UBTOUI((u)+DECPMAX-12)==0                                \
425         &amp;&amp; UBTOUI((u)+DECPMAX-16)==0                                \
426         &amp;&amp; UBTOUI((u)+DECPMAX-20)==0                                \
427         &amp;&amp; UBTOUI((u)+DECPMAX-24)==0                                \
428         &amp;&amp; UBTOUI((u)+DECPMAX-28)==0                                \
429         &amp;&amp; UBTOUI((u)+DECPMAX-32)==0                                \
430         &amp;&amp; UBTOUS(u)==0)
431     #endif
432 
433     /* Macros and masks for the exponent continuation field and MSD   */
434     /* Get the exponent continuation from a decFloat *df as an Int    */
435     #define GETECON(df) ((Int)((DFWORD((df), 0)&amp;0x03ffffff)&gt;&gt;(32-6-DECECONL)))
436     /* Ditto, from the next-wider format                              */
437     #define GETWECON(df) ((Int)((DFWWORD((df), 0)&amp;0x03ffffff)&gt;&gt;(32-6-DECWECONL)))
438     /* Get the biased exponent similarly                              */
439     #define GETEXP(df)  ((Int)(DECCOMBEXP[DFWORD((df), 0)&gt;&gt;26]+GETECON(df)))
440     /* Get the unbiased exponent similarly                            */
441     #define GETEXPUN(df) ((Int)GETEXP(df)-DECBIAS)
442     /* Get the MSD similarly (as uInt)                                */
443     #define GETMSD(df)   (DECCOMBMSD[DFWORD((df), 0)&gt;&gt;26])
444 
445     /* Compile-time computes of the exponent continuation field masks */
446     /* full exponent continuation field:                              */
447     #define ECONMASK ((0x03ffffff&gt;&gt;(32-6-DECECONL))&lt;&lt;(32-6-DECECONL))
448     /* same, not including its first digit (the qNaN/sNaN selector):  */
449     #define ECONNANMASK ((0x01ffffff&gt;&gt;(32-6-DECECONL))&lt;&lt;(32-6-DECECONL))
450 
451     /* Macros to decode the coefficient in a finite decFloat *df into */
452     /* a BCD string (uByte *bcdin) of length DECPMAX uBytes.          */
453 
454     /* In-line sequence to convert least significant 10 bits of uInt  */
455     /* dpd to three BCD8 digits starting at uByte u.  Note that an    */
456     /* extra byte is written to the right of the three digits because */
457     /* four bytes are moved at a time for speed; the alternative      */
458     /* macro moves exactly three bytes (usually slower).              */
459     #define dpd2bcd8(u, dpd)  memcpy(u, &amp;DPD2BCD8[((dpd)&amp;0x3ff)*4], 4)
460     #define dpd2bcd83(u, dpd) memcpy(u, &amp;DPD2BCD8[((dpd)&amp;0x3ff)*4], 3)
461 
462     /* Decode the declets.  After extracting each one, it is decoded  */
463     /* to BCD8 using a table lookup (also used for variable-length    */
464     /* decode).  Each DPD decode is 3 bytes BCD8 plus a one-byte      */
465     /* length which is not used, here).  Fixed-length 4-byte moves    */
466     /* are fast, however, almost everywhere, and so are used except   */
467     /* for the final three bytes (to avoid overrun).  The code below  */
468     /* is 36 instructions for Doubles and about 70 for Quads, even    */
469     /* on IA32.                                                       */
470 
471     /* Two macros are defined for each format:                        */
472     /*   GETCOEFF extracts the coefficient of the current format      */
473     /*   GETWCOEFF extracts the coefficient of the next-wider format. */
474     /* The latter is a copy of the next-wider GETCOEFF using DFWWORD. */
475 
476     #if DECPMAX==7
477     #define GETCOEFF(df, bcd) {                          \
478       uInt sourhi=DFWORD(df, 0);                         \
479       *(bcd)=(uByte)DECCOMBMSD[sourhi&gt;&gt;26];              \
480       dpd2bcd8(bcd+1, sourhi&gt;&gt;10);                       \
481       dpd2bcd83(bcd+4, sourhi);}
482     #define GETWCOEFF(df, bcd) {                         \
483       uInt sourhi=DFWWORD(df, 0);                        \
484       uInt sourlo=DFWWORD(df, 1);                        \
485       *(bcd)=(uByte)DECCOMBMSD[sourhi&gt;&gt;26];              \
486       dpd2bcd8(bcd+1, sourhi&gt;&gt;8);                        \
487       dpd2bcd8(bcd+4, (sourhi&lt;&lt;2) | (sourlo&gt;&gt;30));       \
488       dpd2bcd8(bcd+7, sourlo&gt;&gt;20);                       \
489       dpd2bcd8(bcd+10, sourlo&gt;&gt;10);                      \
490       dpd2bcd83(bcd+13, sourlo);}
491 
492     #elif DECPMAX==16
493     #define GETCOEFF(df, bcd) {                          \
494       uInt sourhi=DFWORD(df, 0);                         \
495       uInt sourlo=DFWORD(df, 1);                         \
496       *(bcd)=(uByte)DECCOMBMSD[sourhi&gt;&gt;26];              \
497       dpd2bcd8(bcd+1, sourhi&gt;&gt;8);                        \
498       dpd2bcd8(bcd+4, (sourhi&lt;&lt;2) | (sourlo&gt;&gt;30));       \
499       dpd2bcd8(bcd+7, sourlo&gt;&gt;20);                       \
500       dpd2bcd8(bcd+10, sourlo&gt;&gt;10);                      \
501       dpd2bcd83(bcd+13, sourlo);}
502     #define GETWCOEFF(df, bcd) {                         \
503       uInt sourhi=DFWWORD(df, 0);                        \
504       uInt sourmh=DFWWORD(df, 1);                        \
505       uInt sourml=DFWWORD(df, 2);                        \
506       uInt sourlo=DFWWORD(df, 3);                        \
507       *(bcd)=(uByte)DECCOMBMSD[sourhi&gt;&gt;26];              \
508       dpd2bcd8(bcd+1, sourhi&gt;&gt;4);                        \
509       dpd2bcd8(bcd+4, ((sourhi)&lt;&lt;6) | (sourmh&gt;&gt;26));     \
510       dpd2bcd8(bcd+7, sourmh&gt;&gt;16);                       \
511       dpd2bcd8(bcd+10, sourmh&gt;&gt;6);                       \
512       dpd2bcd8(bcd+13, ((sourmh)&lt;&lt;4) | (sourml&gt;&gt;28));    \
513       dpd2bcd8(bcd+16, sourml&gt;&gt;18);                      \
514       dpd2bcd8(bcd+19, sourml&gt;&gt;8);                       \
515       dpd2bcd8(bcd+22, ((sourml)&lt;&lt;2) | (sourlo&gt;&gt;30));    \
516       dpd2bcd8(bcd+25, sourlo&gt;&gt;20);                      \
517       dpd2bcd8(bcd+28, sourlo&gt;&gt;10);                      \
518       dpd2bcd83(bcd+31, sourlo);}
519 
520     #elif DECPMAX==34
521     #define GETCOEFF(df, bcd) {                          \
522       uInt sourhi=DFWORD(df, 0);                         \
523       uInt sourmh=DFWORD(df, 1);                         \
524       uInt sourml=DFWORD(df, 2);                         \
525       uInt sourlo=DFWORD(df, 3);                         \
526       *(bcd)=(uByte)DECCOMBMSD[sourhi&gt;&gt;26];              \
527       dpd2bcd8(bcd+1, sourhi&gt;&gt;4);                        \
528       dpd2bcd8(bcd+4, ((sourhi)&lt;&lt;6) | (sourmh&gt;&gt;26));     \
529       dpd2bcd8(bcd+7, sourmh&gt;&gt;16);                       \
530       dpd2bcd8(bcd+10, sourmh&gt;&gt;6);                       \
531       dpd2bcd8(bcd+13, ((sourmh)&lt;&lt;4) | (sourml&gt;&gt;28));    \
532       dpd2bcd8(bcd+16, sourml&gt;&gt;18);                      \
533       dpd2bcd8(bcd+19, sourml&gt;&gt;8);                       \
534       dpd2bcd8(bcd+22, ((sourml)&lt;&lt;2) | (sourlo&gt;&gt;30));    \
535       dpd2bcd8(bcd+25, sourlo&gt;&gt;20);                      \
536       dpd2bcd8(bcd+28, sourlo&gt;&gt;10);                      \
537       dpd2bcd83(bcd+31, sourlo);}
538 
539       #define GETWCOEFF(df, bcd) {??} /* [should never be used]       */
540     #endif
541 
542     /* Macros to decode the coefficient in a finite decFloat *df into */
543     /* a base-billion uInt array, with the least-significant          */
544     /* 0-999999999 &#39;digit&#39; at offset 0.                               */
545 
546     /* Decode the declets.  After extracting each one, it is decoded  */
547     /* to binary using a table lookup.  Three tables are used; one    */
548     /* the usual DPD to binary, the other two pre-multiplied by 1000  */
549     /* and 1000000 to avoid multiplication during decode.  These      */
550     /* tables can also be used for multiplying up the MSD as the DPD  */
551     /* code for 0 through 9 is the identity.                          */
552     #define DPD2BIN0 DPD2BIN         /* for prettier code             */
553 
554     #if DECPMAX==7
555     #define GETCOEFFBILL(df, buf) {                           \
556       uInt sourhi=DFWORD(df, 0);                              \
557       (buf)[0]=DPD2BIN0[sourhi&amp;0x3ff]                         \
558               +DPD2BINK[(sourhi&gt;&gt;10)&amp;0x3ff]                   \
559               +DPD2BINM[DECCOMBMSD[sourhi&gt;&gt;26]];}
560 
561     #elif DECPMAX==16
562     #define GETCOEFFBILL(df, buf) {                           \
563       uInt sourhi, sourlo;                                    \
564       sourlo=DFWORD(df, 1);                                   \
565       (buf)[0]=DPD2BIN0[sourlo&amp;0x3ff]                         \
566               +DPD2BINK[(sourlo&gt;&gt;10)&amp;0x3ff]                   \
567               +DPD2BINM[(sourlo&gt;&gt;20)&amp;0x3ff];                  \
568       sourhi=DFWORD(df, 0);                                   \
569       (buf)[1]=DPD2BIN0[((sourhi&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff]   \
570               +DPD2BINK[(sourhi&gt;&gt;8)&amp;0x3ff]                    \
571               +DPD2BINM[DECCOMBMSD[sourhi&gt;&gt;26]];}
572 
573     #elif DECPMAX==34
574     #define GETCOEFFBILL(df, buf) {                           \
575       uInt sourhi, sourmh, sourml, sourlo;                    \
576       sourlo=DFWORD(df, 3);                                   \
577       (buf)[0]=DPD2BIN0[sourlo&amp;0x3ff]                         \
578               +DPD2BINK[(sourlo&gt;&gt;10)&amp;0x3ff]                   \
579               +DPD2BINM[(sourlo&gt;&gt;20)&amp;0x3ff];                  \
580       sourml=DFWORD(df, 2);                                   \
581       (buf)[1]=DPD2BIN0[((sourml&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff]   \
582               +DPD2BINK[(sourml&gt;&gt;8)&amp;0x3ff]                    \
583               +DPD2BINM[(sourml&gt;&gt;18)&amp;0x3ff];                  \
584       sourmh=DFWORD(df, 1);                                   \
585       (buf)[2]=DPD2BIN0[((sourmh&lt;&lt;4) | (sourml&gt;&gt;28))&amp;0x3ff]   \
586               +DPD2BINK[(sourmh&gt;&gt;6)&amp;0x3ff]                    \
587               +DPD2BINM[(sourmh&gt;&gt;16)&amp;0x3ff];                  \
588       sourhi=DFWORD(df, 0);                                   \
589       (buf)[3]=DPD2BIN0[((sourhi&lt;&lt;6) | (sourmh&gt;&gt;26))&amp;0x3ff]   \
590               +DPD2BINK[(sourhi&gt;&gt;4)&amp;0x3ff]                    \
591               +DPD2BINM[DECCOMBMSD[sourhi&gt;&gt;26]];}
592 
593     #endif
594 
595     /* Macros to decode the coefficient in a finite decFloat *df into */
596     /* a base-thousand uInt array (of size DECLETS+1, to allow for    */
597     /* the MSD), with the least-significant 0-999 &#39;digit&#39; at offset 0.*/
598 
599     /* Decode the declets.  After extracting each one, it is decoded  */
600     /* to binary using a table lookup.                                */
601     #if DECPMAX==7
602     #define GETCOEFFTHOU(df, buf) {                           \
603       uInt sourhi=DFWORD(df, 0);                              \
604       (buf)[0]=DPD2BIN[sourhi&amp;0x3ff];                         \
605       (buf)[1]=DPD2BIN[(sourhi&gt;&gt;10)&amp;0x3ff];                   \
606       (buf)[2]=DECCOMBMSD[sourhi&gt;&gt;26];}
607 
608     #elif DECPMAX==16
609     #define GETCOEFFTHOU(df, buf) {                           \
610       uInt sourhi, sourlo;                                    \
611       sourlo=DFWORD(df, 1);                                   \
612       (buf)[0]=DPD2BIN[sourlo&amp;0x3ff];                         \
613       (buf)[1]=DPD2BIN[(sourlo&gt;&gt;10)&amp;0x3ff];                   \
614       (buf)[2]=DPD2BIN[(sourlo&gt;&gt;20)&amp;0x3ff];                   \
615       sourhi=DFWORD(df, 0);                                   \
616       (buf)[3]=DPD2BIN[((sourhi&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff];   \
617       (buf)[4]=DPD2BIN[(sourhi&gt;&gt;8)&amp;0x3ff];                    \
618       (buf)[5]=DECCOMBMSD[sourhi&gt;&gt;26];}
619 
620     #elif DECPMAX==34
621     #define GETCOEFFTHOU(df, buf) {                           \
622       uInt sourhi, sourmh, sourml, sourlo;                    \
623       sourlo=DFWORD(df, 3);                                   \
624       (buf)[0]=DPD2BIN[sourlo&amp;0x3ff];                         \
625       (buf)[1]=DPD2BIN[(sourlo&gt;&gt;10)&amp;0x3ff];                   \
626       (buf)[2]=DPD2BIN[(sourlo&gt;&gt;20)&amp;0x3ff];                   \
627       sourml=DFWORD(df, 2);                                   \
628       (buf)[3]=DPD2BIN[((sourml&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff];   \
629       (buf)[4]=DPD2BIN[(sourml&gt;&gt;8)&amp;0x3ff];                    \
630       (buf)[5]=DPD2BIN[(sourml&gt;&gt;18)&amp;0x3ff];                   \
631       sourmh=DFWORD(df, 1);                                   \
632       (buf)[6]=DPD2BIN[((sourmh&lt;&lt;4) | (sourml&gt;&gt;28))&amp;0x3ff];   \
633       (buf)[7]=DPD2BIN[(sourmh&gt;&gt;6)&amp;0x3ff];                    \
634       (buf)[8]=DPD2BIN[(sourmh&gt;&gt;16)&amp;0x3ff];                   \
635       sourhi=DFWORD(df, 0);                                   \
636       (buf)[9]=DPD2BIN[((sourhi&lt;&lt;6) | (sourmh&gt;&gt;26))&amp;0x3ff];   \
637       (buf)[10]=DPD2BIN[(sourhi&gt;&gt;4)&amp;0x3ff];                   \
638       (buf)[11]=DECCOMBMSD[sourhi&gt;&gt;26];}
639     #endif
640 
641 
642     /* Macros to decode the coefficient in a finite decFloat *df and  */
643     /* add to a base-thousand uInt array (as for GETCOEFFTHOU).       */
644     /* After the addition then most significant &#39;digit&#39; in the array  */
645     /* might have a value larger then 10 (with a maximum of 19).      */
646     #if DECPMAX==7
647     #define ADDCOEFFTHOU(df, buf) {                           \
648       uInt sourhi=DFWORD(df, 0);                              \
649       (buf)[0]+=DPD2BIN[sourhi&amp;0x3ff];                        \
650       if (buf[0]&gt;999) {buf[0]-=1000; buf[1]++;}               \
651       (buf)[1]+=DPD2BIN[(sourhi&gt;&gt;10)&amp;0x3ff];                  \
652       if (buf[1]&gt;999) {buf[1]-=1000; buf[2]++;}               \
653       (buf)[2]+=DECCOMBMSD[sourhi&gt;&gt;26];}
654 
655     #elif DECPMAX==16
656     #define ADDCOEFFTHOU(df, buf) {                           \
657       uInt sourhi, sourlo;                                    \
658       sourlo=DFWORD(df, 1);                                   \
659       (buf)[0]+=DPD2BIN[sourlo&amp;0x3ff];                        \
660       if (buf[0]&gt;999) {buf[0]-=1000; buf[1]++;}               \
661       (buf)[1]+=DPD2BIN[(sourlo&gt;&gt;10)&amp;0x3ff];                  \
662       if (buf[1]&gt;999) {buf[1]-=1000; buf[2]++;}               \
663       (buf)[2]+=DPD2BIN[(sourlo&gt;&gt;20)&amp;0x3ff];                  \
664       if (buf[2]&gt;999) {buf[2]-=1000; buf[3]++;}               \
665       sourhi=DFWORD(df, 0);                                   \
666       (buf)[3]+=DPD2BIN[((sourhi&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff];  \
667       if (buf[3]&gt;999) {buf[3]-=1000; buf[4]++;}               \
668       (buf)[4]+=DPD2BIN[(sourhi&gt;&gt;8)&amp;0x3ff];                   \
669       if (buf[4]&gt;999) {buf[4]-=1000; buf[5]++;}               \
670       (buf)[5]+=DECCOMBMSD[sourhi&gt;&gt;26];}
671 
672     #elif DECPMAX==34
673     #define ADDCOEFFTHOU(df, buf) {                           \
674       uInt sourhi, sourmh, sourml, sourlo;                    \
675       sourlo=DFWORD(df, 3);                                   \
676       (buf)[0]+=DPD2BIN[sourlo&amp;0x3ff];                        \
677       if (buf[0]&gt;999) {buf[0]-=1000; buf[1]++;}               \
678       (buf)[1]+=DPD2BIN[(sourlo&gt;&gt;10)&amp;0x3ff];                  \
679       if (buf[1]&gt;999) {buf[1]-=1000; buf[2]++;}               \
680       (buf)[2]+=DPD2BIN[(sourlo&gt;&gt;20)&amp;0x3ff];                  \
681       if (buf[2]&gt;999) {buf[2]-=1000; buf[3]++;}               \
682       sourml=DFWORD(df, 2);                                   \
683       (buf)[3]+=DPD2BIN[((sourml&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff];  \
684       if (buf[3]&gt;999) {buf[3]-=1000; buf[4]++;}               \
685       (buf)[4]+=DPD2BIN[(sourml&gt;&gt;8)&amp;0x3ff];                   \
686       if (buf[4]&gt;999) {buf[4]-=1000; buf[5]++;}               \
687       (buf)[5]+=DPD2BIN[(sourml&gt;&gt;18)&amp;0x3ff];                  \
688       if (buf[5]&gt;999) {buf[5]-=1000; buf[6]++;}               \
689       sourmh=DFWORD(df, 1);                                   \
690       (buf)[6]+=DPD2BIN[((sourmh&lt;&lt;4) | (sourml&gt;&gt;28))&amp;0x3ff];  \
691       if (buf[6]&gt;999) {buf[6]-=1000; buf[7]++;}               \
692       (buf)[7]+=DPD2BIN[(sourmh&gt;&gt;6)&amp;0x3ff];                   \
693       if (buf[7]&gt;999) {buf[7]-=1000; buf[8]++;}               \
694       (buf)[8]+=DPD2BIN[(sourmh&gt;&gt;16)&amp;0x3ff];                  \
695       if (buf[8]&gt;999) {buf[8]-=1000; buf[9]++;}               \
696       sourhi=DFWORD(df, 0);                                   \
697       (buf)[9]+=DPD2BIN[((sourhi&lt;&lt;6) | (sourmh&gt;&gt;26))&amp;0x3ff];  \
698       if (buf[9]&gt;999) {buf[9]-=1000; buf[10]++;}              \
699       (buf)[10]+=DPD2BIN[(sourhi&gt;&gt;4)&amp;0x3ff];                  \
700       if (buf[10]&gt;999) {buf[10]-=1000; buf[11]++;}            \
701       (buf)[11]+=DECCOMBMSD[sourhi&gt;&gt;26];}
702     #endif
703 
704 
705     /* Set a decFloat to the maximum positive finite number (Nmax)    */
706     #if DECPMAX==7
707     #define DFSETNMAX(df)            \
708       {DFWORD(df, 0)=0x77f3fcff;}
709     #elif DECPMAX==16
710     #define DFSETNMAX(df)            \
711       {DFWORD(df, 0)=0x77fcff3f;     \
712        DFWORD(df, 1)=0xcff3fcff;}
713     #elif DECPMAX==34
714     #define DFSETNMAX(df)            \
715       {DFWORD(df, 0)=0x77ffcff3;     \
716        DFWORD(df, 1)=0xfcff3fcf;     \
717        DFWORD(df, 2)=0xf3fcff3f;     \
718        DFWORD(df, 3)=0xcff3fcff;}
719     #endif
720 
721   /* [end of format-dependent macros and constants]                   */
722   #endif
723 
724 #else
725   #error decNumberLocal included more than once
726 #endif
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>