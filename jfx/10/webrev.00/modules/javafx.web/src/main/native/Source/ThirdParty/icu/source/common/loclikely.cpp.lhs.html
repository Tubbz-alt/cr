<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/loclikely.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 *
   6 *   Copyright (C) 1997-2016, International Business Machines
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 *******************************************************************************
  10 *   file name:  loclikely.cpp
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 2010feb25
  16 *   created by: Markus W. Scherer
  17 *
  18 *   Code for likely and minimized locale subtags, separated out from other .cpp files
  19 *   that then do not depend on resource bundle code and likely-subtags data.
  20 */
  21 
<a name="1" id="anc1"></a>
  22 #include &quot;unicode/utypes.h&quot;
  23 #include &quot;unicode/locid.h&quot;
  24 #include &quot;unicode/putil.h&quot;
  25 #include &quot;unicode/uchar.h&quot;
  26 #include &quot;unicode/uloc.h&quot;
  27 #include &quot;unicode/ures.h&quot;
  28 #include &quot;unicode/uscript.h&quot;
<a name="2" id="anc2"></a>

  29 #include &quot;cmemory.h&quot;
  30 #include &quot;cstring.h&quot;
  31 #include &quot;ulocimp.h&quot;
  32 #include &quot;ustr_imp.h&quot;
  33 
<a name="3" id="anc3"></a>






  34 /**
  35  * This function looks for the localeID in the likelySubtags resource.
  36  *
  37  * @param localeID The tag to find.
  38  * @param buffer A buffer to hold the matching entry
  39  * @param bufferLength The length of the output buffer
  40  * @return A pointer to &quot;buffer&quot; if found, or a null pointer if not.
  41  */
  42 static const char*  U_CALLCONV
  43 findLikelySubtags(const char* localeID,
  44                   char* buffer,
  45                   int32_t bufferLength,
  46                   UErrorCode* err) {
  47     const char* result = NULL;
  48 
  49     if (!U_FAILURE(*err)) {
  50         int32_t resLen = 0;
  51         const UChar* s = NULL;
  52         UErrorCode tmpErr = U_ZERO_ERROR;
<a name="4" id="anc4"></a><span class="line-modified">  53         UResourceBundle* subtags = ures_openDirect(NULL, &quot;likelySubtags&quot;, &amp;tmpErr);</span>
  54         if (U_SUCCESS(tmpErr)) {
<a name="5" id="anc5"></a><span class="line-modified">  55             s = ures_getStringByKey(subtags, localeID, &amp;resLen, &amp;tmpErr);</span>













  56 
  57             if (U_FAILURE(tmpErr)) {
  58                 /*
  59                  * If a resource is missing, it&#39;s not really an error, it&#39;s
  60                  * just that we don&#39;t have any data for that particular locale ID.
  61                  */
  62                 if (tmpErr != U_MISSING_RESOURCE_ERROR) {
  63                     *err = tmpErr;
  64                 }
  65             }
  66             else if (resLen &gt;= bufferLength) {
  67                 /* The buffer should never overflow. */
  68                 *err = U_INTERNAL_PROGRAM_ERROR;
  69             }
  70             else {
  71                 u_UCharsToChars(s, buffer, resLen + 1);
<a name="6" id="anc6"></a>




  72                 result = buffer;
  73             }
<a name="7" id="anc7"></a><span class="line-removed">  74 </span>
<span class="line-removed">  75             ures_close(subtags);</span>
  76         } else {
  77             *err = tmpErr;
  78         }
  79     }
  80 
  81     return result;
  82 }
  83 
  84 /**
  85  * Append a tag to a buffer, adding the separator if necessary.  The buffer
  86  * must be large enough to contain the resulting tag plus any separator
  87  * necessary. The tag must not be a zero-length string.
  88  *
  89  * @param tag The tag to add.
  90  * @param tagLength The length of the tag.
  91  * @param buffer The output buffer.
  92  * @param bufferLength The length of the output buffer.  This is an input/ouput parameter.
  93  **/
  94 static void U_CALLCONV
  95 appendTag(
  96     const char* tag,
  97     int32_t tagLength,
  98     char* buffer,
<a name="8" id="anc8"></a><span class="line-modified">  99     int32_t* bufferLength) {</span>

 100 
<a name="9" id="anc9"></a><span class="line-modified"> 101     if (*bufferLength &gt; 0) {</span>
 102         buffer[*bufferLength] = &#39;_&#39;;
 103         ++(*bufferLength);
 104     }
 105 
 106     uprv_memmove(
 107         &amp;buffer[*bufferLength],
 108         tag,
 109         tagLength);
 110 
 111     *bufferLength += tagLength;
 112 }
 113 
<a name="10" id="anc10"></a><span class="line-removed"> 114 /**</span>
<span class="line-removed"> 115  * These are the canonical strings for unknown languages, scripts and regions.</span>
<span class="line-removed"> 116  **/</span>
<span class="line-removed"> 117 static const char* const unknownLanguage = &quot;und&quot;;</span>
<span class="line-removed"> 118 static const char* const unknownScript = &quot;Zzzz&quot;;</span>
<span class="line-removed"> 119 static const char* const unknownRegion = &quot;ZZ&quot;;</span>
<span class="line-removed"> 120 </span>
 121 /**
 122  * Create a tag string from the supplied parameters.  The lang, script and region
 123  * parameters may be NULL pointers. If they are, their corresponding length parameters
 124  * must be less than or equal to 0.
 125  *
 126  * If any of the language, script or region parameters are empty, and the alternateTags
 127  * parameter is not NULL, it will be parsed for potential language, script and region tags
 128  * to be used when constructing the new tag.  If the alternateTags parameter is NULL, or
 129  * it contains no language tag, the default tag for the unknown language is used.
 130  *
 131  * If the length of the new string exceeds the capacity of the output buffer,
 132  * the function copies as many bytes to the output buffer as it can, and returns
 133  * the error U_BUFFER_OVERFLOW_ERROR.
 134  *
 135  * If an illegal argument is provided, the function returns the error
 136  * U_ILLEGAL_ARGUMENT_ERROR.
 137  *
 138  * Note that this function can return the warning U_STRING_NOT_TERMINATED_WARNING if
 139  * the tag string fits in the output buffer, but the null terminator doesn&#39;t.
 140  *
 141  * @param lang The language tag to use.
 142  * @param langLength The length of the language tag.
 143  * @param script The script tag to use.
 144  * @param scriptLength The length of the script tag.
 145  * @param region The region tag to use.
 146  * @param regionLength The length of the region tag.
 147  * @param trailing Any trailing data to append to the new tag.
 148  * @param trailingLength The length of the trailing data.
 149  * @param alternateTags A string containing any alternate tags.
<a name="11" id="anc11"></a><span class="line-modified"> 150  * @param tag The output buffer.</span>
<span class="line-removed"> 151  * @param tagCapacity The capacity of the output buffer.</span>
 152  * @param err A pointer to a UErrorCode for error reporting.
<a name="12" id="anc12"></a><span class="line-removed"> 153  * @return The length of the tag string, which may be greater than tagCapacity, or -1 on error.</span>
 154  **/
<a name="13" id="anc13"></a><span class="line-modified"> 155 static int32_t U_CALLCONV</span>
 156 createTagStringWithAlternates(
 157     const char* lang,
 158     int32_t langLength,
 159     const char* script,
 160     int32_t scriptLength,
 161     const char* region,
 162     int32_t regionLength,
 163     const char* trailing,
 164     int32_t trailingLength,
 165     const char* alternateTags,
<a name="14" id="anc14"></a><span class="line-modified"> 166     char* tag,</span>
<span class="line-removed"> 167     int32_t tagCapacity,</span>
 168     UErrorCode* err) {
 169 
 170     if (U_FAILURE(*err)) {
 171         goto error;
 172     }
<a name="15" id="anc15"></a><span class="line-modified"> 173     else if (tag == NULL ||</span>
<span class="line-removed"> 174              tagCapacity &lt;= 0 ||</span>
<span class="line-removed"> 175              langLength &gt;= ULOC_LANG_CAPACITY ||</span>
 176              scriptLength &gt;= ULOC_SCRIPT_CAPACITY ||
 177              regionLength &gt;= ULOC_COUNTRY_CAPACITY) {
 178         goto error;
 179     }
 180     else {
 181         /**
 182          * ULOC_FULLNAME_CAPACITY will provide enough capacity
 183          * that we can build a string that contains the language,
 184          * script and region code without worrying about overrunning
 185          * the user-supplied buffer.
 186          **/
 187         char tagBuffer[ULOC_FULLNAME_CAPACITY];
 188         int32_t tagLength = 0;
<a name="16" id="anc16"></a><span class="line-removed"> 189         int32_t capacityRemaining = tagCapacity;</span>
 190         UBool regionAppended = FALSE;
 191 
 192         if (langLength &gt; 0) {
 193             appendTag(
 194                 lang,
 195                 langLength,
 196                 tagBuffer,
<a name="17" id="anc17"></a><span class="line-modified"> 197                 &amp;tagLength);</span>

 198         }
 199         else if (alternateTags == NULL) {
 200             /*
<a name="18" id="anc18"></a><span class="line-modified"> 201              * Append the value for an unknown language, if</span>
 202              * we found no language.
 203              */
<a name="19" id="anc19"></a><span class="line-removed"> 204             appendTag(</span>
<span class="line-removed"> 205                 unknownLanguage,</span>
<span class="line-removed"> 206                 (int32_t)uprv_strlen(unknownLanguage),</span>
<span class="line-removed"> 207                 tagBuffer,</span>
<span class="line-removed"> 208                 &amp;tagLength);</span>
 209         }
 210         else {
 211             /*
 212              * Parse the alternateTags string for the language.
 213              */
 214             char alternateLang[ULOC_LANG_CAPACITY];
 215             int32_t alternateLangLength = sizeof(alternateLang);
 216 
 217             alternateLangLength =
 218                 uloc_getLanguage(
 219                     alternateTags,
 220                     alternateLang,
 221                     alternateLangLength,
 222                     err);
 223             if(U_FAILURE(*err) ||
 224                 alternateLangLength &gt;= ULOC_LANG_CAPACITY) {
 225                 goto error;
 226             }
 227             else if (alternateLangLength == 0) {
 228                 /*
<a name="20" id="anc20"></a><span class="line-modified"> 229                  * Append the value for an unknown language, if</span>
 230                  * we found no language.
 231                  */
<a name="21" id="anc21"></a><span class="line-removed"> 232                 appendTag(</span>
<span class="line-removed"> 233                     unknownLanguage,</span>
<span class="line-removed"> 234                     (int32_t)uprv_strlen(unknownLanguage),</span>
<span class="line-removed"> 235                     tagBuffer,</span>
<span class="line-removed"> 236                     &amp;tagLength);</span>
 237             }
 238             else {
 239                 appendTag(
 240                     alternateLang,
 241                     alternateLangLength,
 242                     tagBuffer,
<a name="22" id="anc22"></a><span class="line-modified"> 243                     &amp;tagLength);</span>

 244             }
 245         }
 246 
 247         if (scriptLength &gt; 0) {
 248             appendTag(
 249                 script,
 250                 scriptLength,
 251                 tagBuffer,
<a name="23" id="anc23"></a><span class="line-modified"> 252                 &amp;tagLength);</span>

 253         }
 254         else if (alternateTags != NULL) {
 255             /*
 256              * Parse the alternateTags string for the script.
 257              */
 258             char alternateScript[ULOC_SCRIPT_CAPACITY];
 259 
 260             const int32_t alternateScriptLength =
 261                 uloc_getScript(
 262                     alternateTags,
 263                     alternateScript,
 264                     sizeof(alternateScript),
 265                     err);
 266 
 267             if (U_FAILURE(*err) ||
 268                 alternateScriptLength &gt;= ULOC_SCRIPT_CAPACITY) {
 269                 goto error;
 270             }
 271             else if (alternateScriptLength &gt; 0) {
 272                 appendTag(
 273                     alternateScript,
 274                     alternateScriptLength,
 275                     tagBuffer,
<a name="24" id="anc24"></a><span class="line-modified"> 276                     &amp;tagLength);</span>

 277             }
 278         }
 279 
 280         if (regionLength &gt; 0) {
 281             appendTag(
 282                 region,
 283                 regionLength,
 284                 tagBuffer,
<a name="25" id="anc25"></a><span class="line-modified"> 285                 &amp;tagLength);</span>

 286 
 287             regionAppended = TRUE;
 288         }
 289         else if (alternateTags != NULL) {
 290             /*
 291              * Parse the alternateTags string for the region.
 292              */
 293             char alternateRegion[ULOC_COUNTRY_CAPACITY];
 294 
 295             const int32_t alternateRegionLength =
 296                 uloc_getCountry(
 297                     alternateTags,
 298                     alternateRegion,
 299                     sizeof(alternateRegion),
 300                     err);
 301             if (U_FAILURE(*err) ||
 302                 alternateRegionLength &gt;= ULOC_COUNTRY_CAPACITY) {
 303                 goto error;
 304             }
 305             else if (alternateRegionLength &gt; 0) {
 306                 appendTag(
 307                     alternateRegion,
 308                     alternateRegionLength,
 309                     tagBuffer,
<a name="26" id="anc26"></a><span class="line-modified"> 310                     &amp;tagLength);</span>

 311 
 312                 regionAppended = TRUE;
 313             }
 314         }
 315 
<a name="27" id="anc27"></a><span class="line-modified"> 316         {</span>
<span class="line-modified"> 317             const int32_t toCopy =</span>
<span class="line-modified"> 318                 tagLength &gt;= tagCapacity ? tagCapacity : tagLength;</span>
<span class="line-modified"> 319 </span>
<span class="line-modified"> 320             /**</span>
<span class="line-removed"> 321              * Copy the partial tag from our internal buffer to the supplied</span>
<span class="line-removed"> 322              * target.</span>
<span class="line-removed"> 323              **/</span>
<span class="line-removed"> 324             uprv_memcpy(</span>
<span class="line-removed"> 325                 tag,</span>
<span class="line-removed"> 326                 tagBuffer,</span>
<span class="line-removed"> 327                 toCopy);</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329             capacityRemaining -= toCopy;</span>
<span class="line-removed"> 330         }</span>
 331 
 332         if (trailingLength &gt; 0) {
<a name="28" id="anc28"></a><span class="line-modified"> 333             if (*trailing != &#39;@&#39; &amp;&amp; capacityRemaining &gt; 0) {</span>
<span class="line-modified"> 334                 tag[tagLength++] = &#39;_&#39;;</span>
<span class="line-modified"> 335                 --capacityRemaining;</span>
<span class="line-removed"> 336                 if (capacityRemaining &gt; 0 &amp;&amp; !regionAppended) {</span>
 337                     /* extra separator is required */
<a name="29" id="anc29"></a><span class="line-modified"> 338                     tag[tagLength++] = &#39;_&#39;;</span>
<span class="line-removed"> 339                     --capacityRemaining;</span>
 340                 }
 341             }
 342 
<a name="30" id="anc30"></a><span class="line-modified"> 343             if (capacityRemaining &gt; 0) {</span>
<span class="line-modified"> 344                 /*</span>
<span class="line-modified"> 345                  * Copy the trailing data into the supplied buffer.  Use uprv_memmove, since we</span>
<span class="line-modified"> 346                  * don&#39;t know if the user-supplied buffers overlap.</span>
<span class="line-removed"> 347                  */</span>
<span class="line-removed"> 348                 const int32_t toCopy =</span>
<span class="line-removed"> 349                     trailingLength &gt;= capacityRemaining ? capacityRemaining : trailingLength;</span>
<span class="line-removed"> 350 </span>
<span class="line-removed"> 351                 uprv_memmove(</span>
<span class="line-removed"> 352                     &amp;tag[tagLength],</span>
<span class="line-removed"> 353                     trailing,</span>
<span class="line-removed"> 354                     toCopy);</span>
<span class="line-removed"> 355             }</span>
 356         }
 357 
<a name="31" id="anc31"></a><span class="line-modified"> 358         tagLength += trailingLength;</span>
<span class="line-removed"> 359 </span>
<span class="line-removed"> 360         return u_terminateChars(</span>
<span class="line-removed"> 361                     tag,</span>
<span class="line-removed"> 362                     tagCapacity,</span>
<span class="line-removed"> 363                     tagLength,</span>
<span class="line-removed"> 364                     err);</span>
 365     }
 366 
 367 error:
 368 
 369     /**
 370      * An overflow indicates the locale ID passed in
 371      * is ill-formed.  If we got here, and there was
 372      * no previous error, it&#39;s an implicit overflow.
 373      **/
 374     if (*err ==  U_BUFFER_OVERFLOW_ERROR ||
 375         U_SUCCESS(*err)) {
 376         *err = U_ILLEGAL_ARGUMENT_ERROR;
 377     }
<a name="32" id="anc32"></a><span class="line-removed"> 378 </span>
<span class="line-removed"> 379     return -1;</span>
 380 }
 381 
 382 /**
 383  * Create a tag string from the supplied parameters.  The lang, script and region
 384  * parameters may be NULL pointers. If they are, their corresponding length parameters
 385  * must be less than or equal to 0.  If the lang parameter is an empty string, the
 386  * default value for an unknown language is written to the output buffer.
 387  *
 388  * If the length of the new string exceeds the capacity of the output buffer,
 389  * the function copies as many bytes to the output buffer as it can, and returns
 390  * the error U_BUFFER_OVERFLOW_ERROR.
 391  *
 392  * If an illegal argument is provided, the function returns the error
 393  * U_ILLEGAL_ARGUMENT_ERROR.
 394  *
 395  * @param lang The language tag to use.
 396  * @param langLength The length of the language tag.
 397  * @param script The script tag to use.
 398  * @param scriptLength The length of the script tag.
 399  * @param region The region tag to use.
 400  * @param regionLength The length of the region tag.
 401  * @param trailing Any trailing data to append to the new tag.
 402  * @param trailingLength The length of the trailing data.
<a name="33" id="anc33"></a><span class="line-modified"> 403  * @param tag The output buffer.</span>
<span class="line-removed"> 404  * @param tagCapacity The capacity of the output buffer.</span>
 405  * @param err A pointer to a UErrorCode for error reporting.
<a name="34" id="anc34"></a><span class="line-removed"> 406  * @return The length of the tag string, which may be greater than tagCapacity.</span>
 407  **/
<a name="35" id="anc35"></a><span class="line-modified"> 408 static int32_t U_CALLCONV</span>
 409 createTagString(
 410     const char* lang,
 411     int32_t langLength,
 412     const char* script,
 413     int32_t scriptLength,
 414     const char* region,
 415     int32_t regionLength,
 416     const char* trailing,
 417     int32_t trailingLength,
<a name="36" id="anc36"></a><span class="line-modified"> 418     char* tag,</span>
<span class="line-removed"> 419     int32_t tagCapacity,</span>
 420     UErrorCode* err)
 421 {
<a name="37" id="anc37"></a><span class="line-modified"> 422     return createTagStringWithAlternates(</span>
 423                 lang,
 424                 langLength,
 425                 script,
 426                 scriptLength,
 427                 region,
 428                 regionLength,
 429                 trailing,
 430                 trailingLength,
 431                 NULL,
<a name="38" id="anc38"></a><span class="line-modified"> 432                 tag,</span>
<span class="line-removed"> 433                 tagCapacity,</span>
 434                 err);
 435 }
 436 
 437 /**
 438  * Parse the language, script, and region subtags from a tag string, and copy the
 439  * results into the corresponding output parameters. The buffers are null-terminated,
 440  * unless overflow occurs.
 441  *
 442  * The langLength, scriptLength, and regionLength parameters are input/output
 443  * parameters, and must contain the capacity of their corresponding buffers on
 444  * input.  On output, they will contain the actual length of the buffers, not
 445  * including the null terminator.
 446  *
 447  * If the length of any of the output subtags exceeds the capacity of the corresponding
 448  * buffer, the function copies as many bytes to the output buffer as it can, and returns
 449  * the error U_BUFFER_OVERFLOW_ERROR.  It will not parse any more subtags once overflow
 450  * occurs.
 451  *
 452  * If an illegal argument is provided, the function returns the error
 453  * U_ILLEGAL_ARGUMENT_ERROR.
 454  *
 455  * @param localeID The locale ID to parse.
 456  * @param lang The language tag buffer.
 457  * @param langLength The length of the language tag.
 458  * @param script The script tag buffer.
 459  * @param scriptLength The length of the script tag.
 460  * @param region The region tag buffer.
 461  * @param regionLength The length of the region tag.
 462  * @param err A pointer to a UErrorCode for error reporting.
 463  * @return The number of chars of the localeID parameter consumed.
 464  **/
 465 static int32_t U_CALLCONV
 466 parseTagString(
 467     const char* localeID,
 468     char* lang,
 469     int32_t* langLength,
 470     char* script,
 471     int32_t* scriptLength,
 472     char* region,
 473     int32_t* regionLength,
 474     UErrorCode* err)
 475 {
 476     const char* position = localeID;
 477     int32_t subtagLength = 0;
 478 
 479     if(U_FAILURE(*err) ||
 480        localeID == NULL ||
 481        lang == NULL ||
 482        langLength == NULL ||
 483        script == NULL ||
 484        scriptLength == NULL ||
 485        region == NULL ||
 486        regionLength == NULL) {
 487         goto error;
 488     }
 489 
 490     subtagLength = ulocimp_getLanguage(position, lang, *langLength, &amp;position);
 491     u_terminateChars(lang, *langLength, subtagLength, err);
 492 
 493     /*
 494      * Note that we explicit consider U_STRING_NOT_TERMINATED_WARNING
 495      * to be an error, because it indicates the user-supplied tag is
 496      * not well-formed.
 497      */
 498     if(U_FAILURE(*err)) {
 499         goto error;
 500     }
 501 
 502     *langLength = subtagLength;
 503 
 504     /*
<a name="39" id="anc39"></a><span class="line-modified"> 505      * If no language was present, use the value of unknownLanguage</span>
<span class="line-modified"> 506      * instead.  Otherwise, move past any separator.</span>
 507      */
<a name="40" id="anc40"></a><span class="line-removed"> 508     if (*langLength == 0) {</span>
<span class="line-removed"> 509         uprv_strcpy(</span>
<span class="line-removed"> 510             lang,</span>
<span class="line-removed"> 511             unknownLanguage);</span>
<span class="line-removed"> 512         *langLength = (int32_t)uprv_strlen(lang);</span>
<span class="line-removed"> 513     }</span>
 514     if (_isIDSeparator(*position)) {
 515         ++position;
 516     }
 517 
 518     subtagLength = ulocimp_getScript(position, script, *scriptLength, &amp;position);
 519     u_terminateChars(script, *scriptLength, subtagLength, err);
 520 
 521     if(U_FAILURE(*err)) {
 522         goto error;
 523     }
 524 
 525     *scriptLength = subtagLength;
 526 
 527     if (*scriptLength &gt; 0) {
 528         if (uprv_strnicmp(script, unknownScript, *scriptLength) == 0) {
 529             /**
 530              * If the script part is the &quot;unknown&quot; script, then don&#39;t return it.
 531              **/
 532             *scriptLength = 0;
 533         }
 534 
 535         /*
 536          * Move past any separator.
 537          */
 538         if (_isIDSeparator(*position)) {
 539             ++position;
 540         }
 541     }
 542 
 543     subtagLength = ulocimp_getCountry(position, region, *regionLength, &amp;position);
 544     u_terminateChars(region, *regionLength, subtagLength, err);
 545 
 546     if(U_FAILURE(*err)) {
 547         goto error;
 548     }
 549 
 550     *regionLength = subtagLength;
 551 
 552     if (*regionLength &gt; 0) {
 553         if (uprv_strnicmp(region, unknownRegion, *regionLength) == 0) {
 554             /**
 555              * If the region part is the &quot;unknown&quot; region, then don&#39;t return it.
 556              **/
 557             *regionLength = 0;
 558         }
 559     } else if (*position != 0 &amp;&amp; *position != &#39;@&#39;) {
 560         /* back up over consumed trailing separator */
 561         --position;
 562     }
 563 
 564 exit:
 565 
 566     return (int32_t)(position - localeID);
 567 
 568 error:
 569 
 570     /**
 571      * If we get here, we have no explicit error, it&#39;s the result of an
 572      * illegal argument.
 573      **/
 574     if (!U_FAILURE(*err)) {
 575         *err = U_ILLEGAL_ARGUMENT_ERROR;
 576     }
 577 
 578     goto exit;
 579 }
 580 
<a name="41" id="anc41"></a><span class="line-modified"> 581 static int32_t U_CALLCONV</span>
 582 createLikelySubtagsString(
 583     const char* lang,
 584     int32_t langLength,
 585     const char* script,
 586     int32_t scriptLength,
 587     const char* region,
 588     int32_t regionLength,
 589     const char* variants,
 590     int32_t variantsLength,
<a name="42" id="anc42"></a><span class="line-modified"> 591     char* tag,</span>
<span class="line-modified"> 592     int32_t tagCapacity,</span>
<span class="line-removed"> 593     UErrorCode* err)</span>
<span class="line-removed"> 594 {</span>
 595     /**
 596      * ULOC_FULLNAME_CAPACITY will provide enough capacity
 597      * that we can build a string that contains the language,
 598      * script and region code without worrying about overrunning
 599      * the user-supplied buffer.
 600      **/
<a name="43" id="anc43"></a><span class="line-removed"> 601     char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
 602     char likelySubtagsBuffer[ULOC_FULLNAME_CAPACITY];
 603 
 604     if(U_FAILURE(*err)) {
 605         goto error;
 606     }
 607 
 608     /**
 609      * Try the language with the script and region first.
 610      **/
 611     if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
 612 
 613         const char* likelySubtags = NULL;
 614 
<a name="44" id="anc44"></a><span class="line-modified"> 615         createTagString(</span>
<span class="line-modified"> 616             lang,</span>
<span class="line-modified"> 617             langLength,</span>
<span class="line-modified"> 618             script,</span>
<span class="line-modified"> 619             scriptLength,</span>
<span class="line-modified"> 620             region,</span>
<span class="line-modified"> 621             regionLength,</span>
<span class="line-modified"> 622             NULL,</span>
<span class="line-modified"> 623             0,</span>
<span class="line-modified"> 624             tagBuffer,</span>
<span class="line-modified"> 625             sizeof(tagBuffer),</span>
<span class="line-modified"> 626             err);</span>



 627         if(U_FAILURE(*err)) {
 628             goto error;
 629         }
 630 
 631         likelySubtags =
 632             findLikelySubtags(
<a name="45" id="anc45"></a><span class="line-modified"> 633                 tagBuffer,</span>
 634                 likelySubtagsBuffer,
 635                 sizeof(likelySubtagsBuffer),
 636                 err);
 637         if(U_FAILURE(*err)) {
 638             goto error;
 639         }
 640 
 641         if (likelySubtags != NULL) {
 642             /* Always use the language tag from the
 643                maximal string, since it may be more
 644                specific than the one provided. */
<a name="46" id="anc46"></a><span class="line-modified"> 645             return createTagStringWithAlternates(</span>
 646                         NULL,
 647                         0,
 648                         NULL,
 649                         0,
 650                         NULL,
 651                         0,
 652                         variants,
 653                         variantsLength,
 654                         likelySubtags,
<a name="47" id="anc47"></a><span class="line-modified"> 655                         tag,</span>
<span class="line-removed"> 656                         tagCapacity,</span>
 657                         err);
<a name="48" id="anc48"></a>
 658         }
 659     }
 660 
 661     /**
 662      * Try the language with just the script.
 663      **/
 664     if (scriptLength &gt; 0) {
 665 
 666         const char* likelySubtags = NULL;
 667 
<a name="49" id="anc49"></a><span class="line-modified"> 668         createTagString(</span>
<span class="line-modified"> 669             lang,</span>
<span class="line-modified"> 670             langLength,</span>
<span class="line-modified"> 671             script,</span>
<span class="line-modified"> 672             scriptLength,</span>
<span class="line-modified"> 673             NULL,</span>
<span class="line-modified"> 674             0,</span>
<span class="line-modified"> 675             NULL,</span>
<span class="line-modified"> 676             0,</span>
<span class="line-modified"> 677             tagBuffer,</span>
<span class="line-modified"> 678             sizeof(tagBuffer),</span>
<span class="line-modified"> 679             err);</span>



 680         if(U_FAILURE(*err)) {
 681             goto error;
 682         }
 683 
 684         likelySubtags =
 685             findLikelySubtags(
<a name="50" id="anc50"></a><span class="line-modified"> 686                 tagBuffer,</span>
 687                 likelySubtagsBuffer,
 688                 sizeof(likelySubtagsBuffer),
 689                 err);
 690         if(U_FAILURE(*err)) {
 691             goto error;
 692         }
 693 
 694         if (likelySubtags != NULL) {
 695             /* Always use the language tag from the
 696                maximal string, since it may be more
 697                specific than the one provided. */
<a name="51" id="anc51"></a><span class="line-modified"> 698             return createTagStringWithAlternates(</span>
 699                         NULL,
 700                         0,
 701                         NULL,
 702                         0,
 703                         region,
 704                         regionLength,
 705                         variants,
 706                         variantsLength,
 707                         likelySubtags,
<a name="52" id="anc52"></a><span class="line-modified"> 708                         tag,</span>
<span class="line-removed"> 709                         tagCapacity,</span>
 710                         err);
<a name="53" id="anc53"></a>
 711         }
 712     }
 713 
 714     /**
 715      * Try the language with just the region.
 716      **/
 717     if (regionLength &gt; 0) {
 718 
 719         const char* likelySubtags = NULL;
 720 
<a name="54" id="anc54"></a><span class="line-modified"> 721         createTagString(</span>
<span class="line-modified"> 722             lang,</span>
<span class="line-modified"> 723             langLength,</span>
<span class="line-modified"> 724             NULL,</span>
<span class="line-modified"> 725             0,</span>
<span class="line-modified"> 726             region,</span>
<span class="line-modified"> 727             regionLength,</span>
<span class="line-modified"> 728             NULL,</span>
<span class="line-modified"> 729             0,</span>
<span class="line-modified"> 730             tagBuffer,</span>
<span class="line-modified"> 731             sizeof(tagBuffer),</span>
<span class="line-modified"> 732             err);</span>



 733         if(U_FAILURE(*err)) {
 734             goto error;
 735         }
 736 
 737         likelySubtags =
 738             findLikelySubtags(
<a name="55" id="anc55"></a><span class="line-modified"> 739                 tagBuffer,</span>
 740                 likelySubtagsBuffer,
 741                 sizeof(likelySubtagsBuffer),
 742                 err);
 743         if(U_FAILURE(*err)) {
 744             goto error;
 745         }
 746 
 747         if (likelySubtags != NULL) {
 748             /* Always use the language tag from the
 749                maximal string, since it may be more
 750                specific than the one provided. */
<a name="56" id="anc56"></a><span class="line-modified"> 751             return createTagStringWithAlternates(</span>
 752                         NULL,
 753                         0,
 754                         script,
 755                         scriptLength,
 756                         NULL,
 757                         0,
 758                         variants,
 759                         variantsLength,
 760                         likelySubtags,
<a name="57" id="anc57"></a><span class="line-modified"> 761                         tag,</span>
<span class="line-removed"> 762                         tagCapacity,</span>
 763                         err);
<a name="58" id="anc58"></a>
 764         }
 765     }
 766 
 767     /**
 768      * Finally, try just the language.
 769      **/
 770     {
 771         const char* likelySubtags = NULL;
 772 
<a name="59" id="anc59"></a><span class="line-modified"> 773         createTagString(</span>
<span class="line-modified"> 774             lang,</span>
<span class="line-modified"> 775             langLength,</span>
<span class="line-modified"> 776             NULL,</span>
<span class="line-modified"> 777             0,</span>
<span class="line-modified"> 778             NULL,</span>
<span class="line-modified"> 779             0,</span>
<span class="line-modified"> 780             NULL,</span>
<span class="line-modified"> 781             0,</span>
<span class="line-modified"> 782             tagBuffer,</span>
<span class="line-modified"> 783             sizeof(tagBuffer),</span>
<span class="line-modified"> 784             err);</span>



 785         if(U_FAILURE(*err)) {
 786             goto error;
 787         }
 788 
 789         likelySubtags =
 790             findLikelySubtags(
<a name="60" id="anc60"></a><span class="line-modified"> 791                 tagBuffer,</span>
 792                 likelySubtagsBuffer,
 793                 sizeof(likelySubtagsBuffer),
 794                 err);
 795         if(U_FAILURE(*err)) {
 796             goto error;
 797         }
 798 
 799         if (likelySubtags != NULL) {
 800             /* Always use the language tag from the
 801                maximal string, since it may be more
 802                specific than the one provided. */
<a name="61" id="anc61"></a><span class="line-modified"> 803             return createTagStringWithAlternates(</span>
 804                         NULL,
 805                         0,
 806                         script,
 807                         scriptLength,
 808                         region,
 809                         regionLength,
 810                         variants,
 811                         variantsLength,
 812                         likelySubtags,
<a name="62" id="anc62"></a><span class="line-modified"> 813                         tag,</span>
<span class="line-removed"> 814                         tagCapacity,</span>
 815                         err);
<a name="63" id="anc63"></a>
 816         }
 817     }
 818 
<a name="64" id="anc64"></a><span class="line-modified"> 819     return u_terminateChars(</span>
<span class="line-removed"> 820                 tag,</span>
<span class="line-removed"> 821                 tagCapacity,</span>
<span class="line-removed"> 822                 0,</span>
<span class="line-removed"> 823                 err);</span>
 824 
 825 error:
 826 
 827     if (!U_FAILURE(*err)) {
 828         *err = U_ILLEGAL_ARGUMENT_ERROR;
 829     }
 830 
<a name="65" id="anc65"></a><span class="line-modified"> 831     return -1;</span>
 832 }
 833 
 834 #define CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength) \
 835     {   int32_t count = 0; \
 836         int32_t i; \
 837         for (i = 0; i &lt; trailingLength; i++) { \
 838             if (trailing[i] == &#39;-&#39; || trailing[i] == &#39;_&#39;) { \
 839                 count = 0; \
 840                 if (count &gt; 8) { \
 841                     goto error; \
 842                 } \
 843             } else if (trailing[i] == &#39;@&#39;) { \
 844                 break; \
 845             } else if (count &gt; 8) { \
 846                 goto error; \
 847             } else { \
 848                 count++; \
 849             } \
 850         } \
 851     }
 852 
<a name="66" id="anc66"></a><span class="line-modified"> 853 static int32_t</span>
<span class="line-modified"> 854 _uloc_addLikelySubtags(const char*    localeID,</span>
<span class="line-modified"> 855          char* maximizedLocaleID,</span>
<span class="line-modified"> 856          int32_t maximizedLocaleIDCapacity,</span>
<span class="line-removed"> 857          UErrorCode* err)</span>
<span class="line-removed"> 858 {</span>
 859     char lang[ULOC_LANG_CAPACITY];
 860     int32_t langLength = sizeof(lang);
 861     char script[ULOC_SCRIPT_CAPACITY];
 862     int32_t scriptLength = sizeof(script);
 863     char region[ULOC_COUNTRY_CAPACITY];
 864     int32_t regionLength = sizeof(region);
 865     const char* trailing = &quot;&quot;;
 866     int32_t trailingLength = 0;
 867     int32_t trailingIndex = 0;
<a name="67" id="anc67"></a><span class="line-modified"> 868     int32_t resultLength = 0;</span>
 869 
 870     if(U_FAILURE(*err)) {
 871         goto error;
 872     }
<a name="68" id="anc68"></a><span class="line-modified"> 873     else if (localeID == NULL ||</span>
<span class="line-removed"> 874              maximizedLocaleID == NULL ||</span>
<span class="line-removed"> 875              maximizedLocaleIDCapacity &lt;= 0) {</span>
 876         goto error;
 877     }
 878 
 879     trailingIndex = parseTagString(
 880         localeID,
 881         lang,
 882         &amp;langLength,
 883         script,
 884         &amp;scriptLength,
 885         region,
 886         &amp;regionLength,
 887         err);
 888     if(U_FAILURE(*err)) {
 889         /* Overflow indicates an illegal argument error */
 890         if (*err == U_BUFFER_OVERFLOW_ERROR) {
 891             *err = U_ILLEGAL_ARGUMENT_ERROR;
 892         }
 893 
 894         goto error;
 895     }
 896 
 897     /* Find the length of the trailing portion. */
 898     while (_isIDSeparator(localeID[trailingIndex])) {
 899         trailingIndex++;
 900     }
 901     trailing = &amp;localeID[trailingIndex];
 902     trailingLength = (int32_t)uprv_strlen(trailing);
 903 
 904     CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
 905 
<a name="69" id="anc69"></a><span class="line-modified"> 906     resultLength =</span>
 907         createLikelySubtagsString(
 908             lang,
 909             langLength,
 910             script,
 911             scriptLength,
 912             region,
 913             regionLength,
 914             trailing,
 915             trailingLength,
<a name="70" id="anc70"></a><span class="line-modified"> 916             maximizedLocaleID,</span>
<span class="line-removed"> 917             maximizedLocaleIDCapacity,</span>
 918             err);
 919 
<a name="71" id="anc71"></a><span class="line-modified"> 920     if (resultLength == 0) {</span>
 921         const int32_t localIDLength = (int32_t)uprv_strlen(localeID);
 922 
 923         /*
 924          * If we get here, we need to return localeID.
 925          */
<a name="72" id="anc72"></a><span class="line-modified"> 926         uprv_memcpy(</span>
<span class="line-removed"> 927             maximizedLocaleID,</span>
<span class="line-removed"> 928             localeID,</span>
<span class="line-removed"> 929             localIDLength &lt;= maximizedLocaleIDCapacity ?</span>
<span class="line-removed"> 930                 localIDLength : maximizedLocaleIDCapacity);</span>
<span class="line-removed"> 931 </span>
<span class="line-removed"> 932         resultLength =</span>
<span class="line-removed"> 933             u_terminateChars(</span>
<span class="line-removed"> 934                 maximizedLocaleID,</span>
<span class="line-removed"> 935                 maximizedLocaleIDCapacity,</span>
<span class="line-removed"> 936                 localIDLength,</span>
<span class="line-removed"> 937                 err);</span>
 938     }
 939 
<a name="73" id="anc73"></a><span class="line-modified"> 940     return resultLength;</span>
 941 
 942 error:
 943 
 944     if (!U_FAILURE(*err)) {
 945         *err = U_ILLEGAL_ARGUMENT_ERROR;
 946     }
<a name="74" id="anc74"></a><span class="line-removed"> 947 </span>
<span class="line-removed"> 948     return -1;</span>
 949 }
 950 
<a name="75" id="anc75"></a><span class="line-modified"> 951 static int32_t</span>
<span class="line-modified"> 952 _uloc_minimizeSubtags(const char*    localeID,</span>
<span class="line-modified"> 953          char* minimizedLocaleID,</span>
<span class="line-modified"> 954          int32_t minimizedLocaleIDCapacity,</span>
<span class="line-modified"> 955          UErrorCode* err)</span>
<span class="line-removed"> 956 {</span>
<span class="line-removed"> 957     /**</span>
<span class="line-removed"> 958      * ULOC_FULLNAME_CAPACITY will provide enough capacity</span>
<span class="line-removed"> 959      * that we can build a string that contains the language,</span>
<span class="line-removed"> 960      * script and region code without worrying about overrunning</span>
<span class="line-removed"> 961      * the user-supplied buffer.</span>
<span class="line-removed"> 962      **/</span>
<span class="line-removed"> 963     char maximizedTagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-removed"> 964     int32_t maximizedTagBufferLength = sizeof(maximizedTagBuffer);</span>
 965 
 966     char lang[ULOC_LANG_CAPACITY];
 967     int32_t langLength = sizeof(lang);
 968     char script[ULOC_SCRIPT_CAPACITY];
 969     int32_t scriptLength = sizeof(script);
 970     char region[ULOC_COUNTRY_CAPACITY];
 971     int32_t regionLength = sizeof(region);
 972     const char* trailing = &quot;&quot;;
 973     int32_t trailingLength = 0;
 974     int32_t trailingIndex = 0;
 975 
 976     if(U_FAILURE(*err)) {
 977         goto error;
 978     }
<a name="76" id="anc76"></a><span class="line-modified"> 979     else if (localeID == NULL ||</span>
<span class="line-removed"> 980              minimizedLocaleID == NULL ||</span>
<span class="line-removed"> 981              minimizedLocaleIDCapacity &lt;= 0) {</span>
 982         goto error;
 983     }
 984 
 985     trailingIndex =
 986         parseTagString(
 987             localeID,
 988             lang,
 989             &amp;langLength,
 990             script,
 991             &amp;scriptLength,
 992             region,
 993             &amp;regionLength,
 994             err);
 995     if(U_FAILURE(*err)) {
 996 
 997         /* Overflow indicates an illegal argument error */
 998         if (*err == U_BUFFER_OVERFLOW_ERROR) {
 999             *err = U_ILLEGAL_ARGUMENT_ERROR;
1000         }
1001 
1002         goto error;
1003     }
1004 
1005     /* Find the spot where the variants or the keywords begin, if any. */
1006     while (_isIDSeparator(localeID[trailingIndex])) {
1007         trailingIndex++;
1008     }
1009     trailing = &amp;localeID[trailingIndex];
1010     trailingLength = (int32_t)uprv_strlen(trailing);
1011 
1012     CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
1013 
<a name="77" id="anc77"></a><span class="line-modified">1014     createTagString(</span>
<span class="line-modified">1015         lang,</span>
<span class="line-modified">1016         langLength,</span>
<span class="line-modified">1017         script,</span>
<span class="line-modified">1018         scriptLength,</span>
<span class="line-modified">1019         region,</span>
<span class="line-modified">1020         regionLength,</span>
<span class="line-modified">1021         NULL,</span>
<span class="line-modified">1022         0,</span>
<span class="line-modified">1023         maximizedTagBuffer,</span>
<span class="line-modified">1024         maximizedTagBufferLength,</span>
<span class="line-modified">1025         err);</span>
<span class="line-modified">1026     if(U_FAILURE(*err)) {</span>
<span class="line-modified">1027         goto error;</span>
<span class="line-modified">1028     }</span>

1029 
<a name="78" id="anc78"></a><span class="line-modified">1030     /**</span>
<span class="line-modified">1031      * First, we need to first get the maximization</span>
<span class="line-modified">1032      * from AddLikelySubtags.</span>
<span class="line-modified">1033      **/</span>
<span class="line-modified">1034     maximizedTagBufferLength =</span>
<span class="line-modified">1035         uloc_addLikelySubtags(</span>
<span class="line-modified">1036             maximizedTagBuffer,</span>
<span class="line-modified">1037             maximizedTagBuffer,</span>
<span class="line-modified">1038             maximizedTagBufferLength,</span>
<span class="line-removed">1039             err);</span>
1040 
1041     if(U_FAILURE(*err)) {
1042         goto error;
1043     }
1044 
1045     /**
1046      * Start first with just the language.
1047      **/
1048     {
<a name="79" id="anc79"></a><span class="line-modified">1049         char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">1050 </span>
<span class="line-modified">1051         const int32_t tagBufferLength =</span>
1052             createLikelySubtagsString(
1053                 lang,
1054                 langLength,
1055                 NULL,
1056                 0,
1057                 NULL,
1058                 0,
1059                 NULL,
1060                 0,
<a name="80" id="anc80"></a><span class="line-modified">1061                 tagBuffer,</span>
<span class="line-removed">1062                 sizeof(tagBuffer),</span>
1063                 err);
<a name="81" id="anc81"></a>
1064 
1065         if(U_FAILURE(*err)) {
1066             goto error;
1067         }
<a name="82" id="anc82"></a><span class="line-modified">1068         else if (uprv_strnicmp(</span>
<span class="line-modified">1069                     maximizedTagBuffer,</span>
<span class="line-modified">1070                     tagBuffer,</span>
<span class="line-modified">1071                     tagBufferLength) == 0) {</span>
1072 
<a name="83" id="anc83"></a><span class="line-modified">1073             return createTagString(</span>
1074                         lang,
1075                         langLength,
1076                         NULL,
1077                         0,
1078                         NULL,
1079                         0,
1080                         trailing,
1081                         trailingLength,
<a name="84" id="anc84"></a><span class="line-modified">1082                         minimizedLocaleID,</span>
<span class="line-removed">1083                         minimizedLocaleIDCapacity,</span>
1084                         err);
<a name="85" id="anc85"></a>
1085         }
1086     }
1087 
1088     /**
1089      * Next, try the language and region.
1090      **/
1091     if (regionLength &gt; 0) {
1092 
<a name="86" id="anc86"></a><span class="line-modified">1093         char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">1094 </span>
<span class="line-modified">1095         const int32_t tagBufferLength =</span>
1096             createLikelySubtagsString(
1097                 lang,
1098                 langLength,
1099                 NULL,
1100                 0,
1101                 region,
1102                 regionLength,
1103                 NULL,
1104                 0,
<a name="87" id="anc87"></a><span class="line-modified">1105                 tagBuffer,</span>
<span class="line-removed">1106                 sizeof(tagBuffer),</span>
1107                 err);
<a name="88" id="anc88"></a>
1108 
1109         if(U_FAILURE(*err)) {
1110             goto error;
1111         }
1112         else if (uprv_strnicmp(
<a name="89" id="anc89"></a><span class="line-modified">1113                     maximizedTagBuffer,</span>
<span class="line-modified">1114                     tagBuffer,</span>
<span class="line-modified">1115                     tagBufferLength) == 0) {</span>
1116 
<a name="90" id="anc90"></a><span class="line-modified">1117             return createTagString(</span>
1118                         lang,
1119                         langLength,
1120                         NULL,
1121                         0,
1122                         region,
1123                         regionLength,
1124                         trailing,
1125                         trailingLength,
<a name="91" id="anc91"></a><span class="line-modified">1126                         minimizedLocaleID,</span>
<span class="line-removed">1127                         minimizedLocaleIDCapacity,</span>
1128                         err);
<a name="92" id="anc92"></a>
1129         }
1130     }
1131 
1132     /**
1133      * Finally, try the language and script.  This is our last chance,
1134      * since trying with all three subtags would only yield the
1135      * maximal version that we already have.
1136      **/
1137     if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
<a name="93" id="anc93"></a><span class="line-modified">1138         char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">1139 </span>
<span class="line-modified">1140         const int32_t tagBufferLength =</span>
1141             createLikelySubtagsString(
1142                 lang,
1143                 langLength,
1144                 script,
1145                 scriptLength,
1146                 NULL,
1147                 0,
1148                 NULL,
1149                 0,
<a name="94" id="anc94"></a><span class="line-modified">1150                 tagBuffer,</span>
<span class="line-removed">1151                 sizeof(tagBuffer),</span>
1152                 err);
<a name="95" id="anc95"></a>
1153 
1154         if(U_FAILURE(*err)) {
1155             goto error;
1156         }
1157         else if (uprv_strnicmp(
<a name="96" id="anc96"></a><span class="line-modified">1158                     maximizedTagBuffer,</span>
<span class="line-modified">1159                     tagBuffer,</span>
<span class="line-modified">1160                     tagBufferLength) == 0) {</span>
1161 
<a name="97" id="anc97"></a><span class="line-modified">1162             return createTagString(</span>
1163                         lang,
1164                         langLength,
1165                         script,
1166                         scriptLength,
1167                         NULL,
1168                         0,
1169                         trailing,
1170                         trailingLength,
<a name="98" id="anc98"></a><span class="line-modified">1171                         minimizedLocaleID,</span>
<span class="line-removed">1172                         minimizedLocaleIDCapacity,</span>
1173                         err);
<a name="99" id="anc99"></a>
1174         }
1175     }
1176 
1177     {
1178         /**
1179          * If we got here, return the locale ID parameter.
1180          **/
1181         const int32_t localeIDLength = (int32_t)uprv_strlen(localeID);
<a name="100" id="anc100"></a><span class="line-modified">1182 </span>
<span class="line-modified">1183         uprv_memcpy(</span>
<span class="line-removed">1184             minimizedLocaleID,</span>
<span class="line-removed">1185             localeID,</span>
<span class="line-removed">1186             localeIDLength &lt;= minimizedLocaleIDCapacity ?</span>
<span class="line-removed">1187                 localeIDLength : minimizedLocaleIDCapacity);</span>
<span class="line-removed">1188 </span>
<span class="line-removed">1189         return u_terminateChars(</span>
<span class="line-removed">1190                     minimizedLocaleID,</span>
<span class="line-removed">1191                     minimizedLocaleIDCapacity,</span>
<span class="line-removed">1192                     localeIDLength,</span>
<span class="line-removed">1193                     err);</span>
1194     }
1195 
1196 error:
1197 
1198     if (!U_FAILURE(*err)) {
1199         *err = U_ILLEGAL_ARGUMENT_ERROR;
1200     }
<a name="101" id="anc101"></a><span class="line-removed">1201 </span>
<span class="line-removed">1202     return -1;</span>
<span class="line-removed">1203 </span>
<span class="line-removed">1204 </span>
1205 }
1206 
1207 static UBool
1208 do_canonicalize(const char*    localeID,
1209          char* buffer,
1210          int32_t bufferCapacity,
1211          UErrorCode* err)
1212 {
1213     uloc_canonicalize(
1214         localeID,
1215         buffer,
1216         bufferCapacity,
1217         err);
1218 
1219     if (*err == U_STRING_NOT_TERMINATED_WARNING ||
1220         *err == U_BUFFER_OVERFLOW_ERROR) {
1221         *err = U_ILLEGAL_ARGUMENT_ERROR;
1222 
1223         return FALSE;
1224     }
1225     else if (U_FAILURE(*err)) {
1226 
1227         return FALSE;
1228     }
1229     else {
1230         return TRUE;
1231     }
1232 }
1233 
1234 U_CAPI int32_t U_EXPORT2
<a name="102" id="anc102"></a><span class="line-modified">1235 uloc_addLikelySubtags(const char*    localeID,</span>
<span class="line-modified">1236          char* maximizedLocaleID,</span>
<span class="line-modified">1237          int32_t maximizedLocaleIDCapacity,</span>
<span class="line-modified">1238          UErrorCode* err)</span>
<span class="line-modified">1239 {</span>
<span class="line-modified">1240     char localeBuffer[ULOC_FULLNAME_CAPACITY];</span>

1241 
<a name="103" id="anc103"></a><span class="line-modified">1242     if (!do_canonicalize(</span>
<span class="line-modified">1243         localeID,</span>
<span class="line-modified">1244         localeBuffer,</span>
<span class="line-modified">1245         sizeof(localeBuffer),</span>
<span class="line-modified">1246         err)) {</span>
<span class="line-modified">1247         return -1;</span>


1248     }
<a name="104" id="anc104"></a><span class="line-modified">1249     else {</span>
<span class="line-modified">1250         return _uloc_addLikelySubtags(</span>
<span class="line-modified">1251                     localeBuffer,</span>
<span class="line-modified">1252                     maximizedLocaleID,</span>
<span class="line-modified">1253                     maximizedLocaleIDCapacity,</span>
<span class="line-modified">1254                     err);</span>
1255     }
<a name="105" id="anc105"></a>

1256 }
1257 
<a name="106" id="anc106"></a><span class="line-modified">1258 U_CAPI int32_t U_EXPORT2</span>
<span class="line-modified">1259 uloc_minimizeSubtags(const char*    localeID,</span>
<span class="line-modified">1260          char* minimizedLocaleID,</span>
<span class="line-modified">1261          int32_t minimizedLocaleIDCapacity,</span>
<span class="line-removed">1262          UErrorCode* err)</span>
<span class="line-removed">1263 {</span>
1264     char localeBuffer[ULOC_FULLNAME_CAPACITY];
1265 
<a name="107" id="anc107"></a><span class="line-modified">1266     if (!do_canonicalize(</span>
<span class="line-modified">1267         localeID,</span>
<span class="line-removed">1268         localeBuffer,</span>
<span class="line-removed">1269         sizeof(localeBuffer),</span>
<span class="line-removed">1270         err)) {</span>
<span class="line-removed">1271         return -1;</span>
1272     }
<a name="108" id="anc108"></a><span class="line-modified">1273     else {</span>
<span class="line-modified">1274         return _uloc_minimizeSubtags(</span>
<span class="line-modified">1275                     localeBuffer,</span>
<span class="line-modified">1276                     minimizedLocaleID,</span>
<span class="line-modified">1277                     minimizedLocaleIDCapacity,</span>
<span class="line-modified">1278                     err);</span>

































1279     }
1280 }
1281 
1282 // Pairs of (language subtag, + or -) for finding out fast if common languages
1283 // are LTR (minus) or RTL (plus).
1284 static const char LANG_DIR_STRING[] =
1285         &quot;root-en-es-pt-zh-ja-ko-de-fr-it-ar+he+fa+ru-nl-pl-th-tr-&quot;;
1286 
<a name="109" id="anc109"></a><span class="line-modified">1287 // Implemented here because this calls uloc_addLikelySubtags().</span>
1288 U_CAPI UBool U_EXPORT2
1289 uloc_isRightToLeft(const char *locale) {
1290     UErrorCode errorCode = U_ZERO_ERROR;
1291     char script[8];
1292     int32_t scriptLength = uloc_getScript(locale, script, UPRV_LENGTHOF(script), &amp;errorCode);
1293     if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
1294             scriptLength == 0) {
1295         // Fastpath: We know the likely scripts and their writing direction
1296         // for some common languages.
1297         errorCode = U_ZERO_ERROR;
1298         char lang[8];
1299         int32_t langLength = uloc_getLanguage(locale, lang, UPRV_LENGTHOF(lang), &amp;errorCode);
<a name="110" id="anc110"></a><span class="line-modified">1300         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||</span>
<span class="line-removed">1301                 langLength == 0) {</span>
1302             return FALSE;
1303         }
<a name="111" id="anc111"></a><span class="line-modified">1304         const char* langPtr = uprv_strstr(LANG_DIR_STRING, lang);</span>
<span class="line-modified">1305         if (langPtr != NULL) {</span>
<span class="line-modified">1306             switch (langPtr[langLength]) {</span>
<span class="line-modified">1307             case &#39;-&#39;: return FALSE;</span>
<span class="line-modified">1308             case &#39;+&#39;: return TRUE;</span>
<span class="line-modified">1309             default: break;  // partial match of a longer code</span>


1310             }
1311         }
1312         // Otherwise, find the likely script.
1313         errorCode = U_ZERO_ERROR;
<a name="112" id="anc112"></a><span class="line-modified">1314         char likely[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">1315         (void)uloc_addLikelySubtags(locale, likely, UPRV_LENGTHOF(likely), &amp;errorCode);</span>



1316         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {
1317             return FALSE;
1318         }
<a name="113" id="anc113"></a><span class="line-modified">1319         scriptLength = uloc_getScript(likely, script, UPRV_LENGTHOF(script), &amp;errorCode);</span>
1320         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
1321                 scriptLength == 0) {
1322             return FALSE;
1323         }
1324     }
1325     UScriptCode scriptCode = (UScriptCode)u_getPropertyValueEnum(UCHAR_SCRIPT, script);
1326     return uscript_isRightToLeft(scriptCode);
1327 }
1328 
1329 U_NAMESPACE_BEGIN
1330 
1331 UBool
1332 Locale::isRightToLeft() const {
1333     return uloc_isRightToLeft(getBaseName());
1334 }
1335 
1336 U_NAMESPACE_END
1337 
1338 // The following must at least allow for rg key value (6) plus terminator (1).
1339 #define ULOC_RG_BUFLEN 8
1340 
1341 U_CAPI int32_t U_EXPORT2
1342 ulocimp_getRegionForSupplementalData(const char *localeID, UBool inferRegion,
1343                                      char *region, int32_t regionCapacity, UErrorCode* status) {
1344     if (U_FAILURE(*status)) {
1345         return 0;
1346     }
1347     char rgBuf[ULOC_RG_BUFLEN];
1348     UErrorCode rgStatus = U_ZERO_ERROR;
1349 
1350     // First check for rg keyword value
1351     int32_t rgLen = uloc_getKeywordValue(localeID, &quot;rg&quot;, rgBuf, ULOC_RG_BUFLEN, &amp;rgStatus);
1352     if (U_FAILURE(rgStatus) || rgLen != 6) {
1353         rgLen = 0;
1354     } else {
1355         // rgBuf guaranteed to be zero terminated here, with text len 6
1356         char *rgPtr = rgBuf;
1357         for (; *rgPtr!= 0; rgPtr++) {
1358             *rgPtr = uprv_toupper(*rgPtr);
1359         }
1360         rgLen = (uprv_strcmp(rgBuf+2, &quot;ZZZZ&quot;) == 0)? 2: 0;
1361     }
1362 
1363     if (rgLen == 0) {
1364         // No valid rg keyword value, try for unicode_region_subtag
1365         rgLen = uloc_getCountry(localeID, rgBuf, ULOC_RG_BUFLEN, status);
1366         if (U_FAILURE(*status)) {
1367             rgLen = 0;
1368         } else if (rgLen == 0 &amp;&amp; inferRegion) {
1369             // no unicode_region_subtag but inferRegion TRUE, try likely subtags
<a name="114" id="anc114"></a><span class="line-removed">1370             char locBuf[ULOC_FULLNAME_CAPACITY];</span>
1371             rgStatus = U_ZERO_ERROR;
<a name="115" id="anc115"></a><span class="line-modified">1372             (void)uloc_addLikelySubtags(localeID, locBuf, ULOC_FULLNAME_CAPACITY, &amp;rgStatus);</span>




1373             if (U_SUCCESS(rgStatus)) {
<a name="116" id="anc116"></a><span class="line-modified">1374                 rgLen = uloc_getCountry(locBuf, rgBuf, ULOC_RG_BUFLEN, status);</span>
1375                 if (U_FAILURE(*status)) {
1376                     rgLen = 0;
1377                 }
1378             }
1379         }
1380     }
1381 
1382     rgBuf[rgLen] = 0;
1383     uprv_strncpy(region, rgBuf, regionCapacity);
1384     return u_terminateChars(region, regionCapacity, rgLen, status);
1385 }
1386 
<a name="117" id="anc117"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="117" type="hidden" />
</body>
</html>