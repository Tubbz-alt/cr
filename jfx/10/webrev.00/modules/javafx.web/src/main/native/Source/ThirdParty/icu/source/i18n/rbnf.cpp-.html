<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rbnf.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 1997-2015, International Business Machines Corporation
   6 * and others. All Rights Reserved.
   7 *******************************************************************************
   8 */
   9 
  10 #include &quot;unicode/utypes.h&quot;
  11 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  12 
  13 #include &quot;unicode/rbnf.h&quot;
  14 
  15 #if U_HAVE_RBNF
  16 
  17 #include &quot;unicode/normlzr.h&quot;
  18 #include &quot;unicode/plurfmt.h&quot;
  19 #include &quot;unicode/tblcoll.h&quot;
  20 #include &quot;unicode/uchar.h&quot;
  21 #include &quot;unicode/ucol.h&quot;
  22 #include &quot;unicode/uloc.h&quot;
  23 #include &quot;unicode/unum.h&quot;
  24 #include &quot;unicode/ures.h&quot;
  25 #include &quot;unicode/ustring.h&quot;
  26 #include &quot;unicode/utf16.h&quot;
  27 #include &quot;unicode/udata.h&quot;
  28 #include &quot;unicode/udisplaycontext.h&quot;
  29 #include &quot;unicode/brkiter.h&quot;
  30 #include &quot;unicode/ucasemap.h&quot;
  31 
  32 #include &quot;cmemory.h&quot;
  33 #include &quot;cstring.h&quot;
  34 #include &quot;patternprops.h&quot;
  35 #include &quot;uresimp.h&quot;
  36 #include &quot;nfrs.h&quot;
  37 #include &quot;number_decimalquantity.h&quot;
  38 
  39 // debugging
  40 // #define RBNF_DEBUG
  41 
  42 #ifdef RBNF_DEBUG
  43 #include &lt;stdio.h&gt;
  44 #endif
  45 
  46 #define U_ICUDATA_RBNF U_ICUDATA_NAME U_TREE_SEPARATOR_STRING &quot;rbnf&quot;
  47 
  48 static const UChar gPercentPercent[] =
  49 {
  50     0x25, 0x25, 0
  51 }; /* &quot;%%&quot; */
  52 
  53 // All urbnf objects are created through openRules, so we init all of the
  54 // Unicode string constants required by rbnf, nfrs, or nfr here.
  55 static const UChar gLenientParse[] =
  56 {
  57     0x25, 0x25, 0x6C, 0x65, 0x6E, 0x69, 0x65, 0x6E, 0x74, 0x2D, 0x70, 0x61, 0x72, 0x73, 0x65, 0x3A, 0
  58 }; /* &quot;%%lenient-parse:&quot; */
  59 static const UChar gSemiColon = 0x003B;
  60 static const UChar gSemiPercent[] =
  61 {
  62     0x3B, 0x25, 0
  63 }; /* &quot;;%&quot; */
  64 
  65 #define kSomeNumberOfBitsDiv2 22
  66 #define kHalfMaxDouble (double)(1 &lt;&lt; kSomeNumberOfBitsDiv2)
  67 #define kMaxDouble (kHalfMaxDouble * kHalfMaxDouble)
  68 
  69 U_NAMESPACE_BEGIN
  70 
  71 using number::impl::DecimalQuantity;
  72 
  73 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(RuleBasedNumberFormat)
  74 
  75 /*
  76 This is a utility class. It does not use ICU&#39;s RTTI.
  77 If ICU&#39;s RTTI is needed again, you can uncomment the RTTI code and derive from UObject.
  78 Please make sure that intltest passes on Windows in Release mode,
  79 since the string pooling per compilation unit will mess up how RTTI works.
  80 The RTTI code was also removed due to lack of code coverage.
  81 */
  82 class LocalizationInfo : public UMemory {
  83 protected:
  84     virtual ~LocalizationInfo();
  85     uint32_t refcount;
  86 
  87 public:
  88     LocalizationInfo() : refcount(0) {}
  89 
  90     LocalizationInfo* ref(void) {
  91         ++refcount;
  92         return this;
  93     }
  94 
  95     LocalizationInfo* unref(void) {
  96         if (refcount &amp;&amp; --refcount == 0) {
  97             delete this;
  98         }
  99         return NULL;
 100     }
 101 
 102     virtual UBool operator==(const LocalizationInfo* rhs) const;
 103     inline  UBool operator!=(const LocalizationInfo* rhs) const { return !operator==(rhs); }
 104 
 105     virtual int32_t getNumberOfRuleSets(void) const = 0;
 106     virtual const UChar* getRuleSetName(int32_t index) const = 0;
 107     virtual int32_t getNumberOfDisplayLocales(void) const = 0;
 108     virtual const UChar* getLocaleName(int32_t index) const = 0;
 109     virtual const UChar* getDisplayName(int32_t localeIndex, int32_t ruleIndex) const = 0;
 110 
 111     virtual int32_t indexForLocale(const UChar* locale) const;
 112     virtual int32_t indexForRuleSet(const UChar* ruleset) const;
 113 
 114 //    virtual UClassID getDynamicClassID() const = 0;
 115 //    static UClassID getStaticClassID(void);
 116 };
 117 
 118 LocalizationInfo::~LocalizationInfo() {}
 119 
 120 //UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(LocalizationInfo)
 121 
 122 // if both strings are NULL, this returns TRUE
 123 static UBool
 124 streq(const UChar* lhs, const UChar* rhs) {
 125     if (rhs == lhs) {
 126         return TRUE;
 127     }
 128     if (lhs &amp;&amp; rhs) {
 129         return u_strcmp(lhs, rhs) == 0;
 130     }
 131     return FALSE;
 132 }
 133 
 134 UBool
 135 LocalizationInfo::operator==(const LocalizationInfo* rhs) const {
 136     if (rhs) {
 137         if (this == rhs) {
 138             return TRUE;
 139         }
 140 
 141         int32_t rsc = getNumberOfRuleSets();
 142         if (rsc == rhs-&gt;getNumberOfRuleSets()) {
 143             for (int i = 0; i &lt; rsc; ++i) {
 144                 if (!streq(getRuleSetName(i), rhs-&gt;getRuleSetName(i))) {
 145                     return FALSE;
 146                 }
 147             }
 148             int32_t dlc = getNumberOfDisplayLocales();
 149             if (dlc == rhs-&gt;getNumberOfDisplayLocales()) {
 150                 for (int i = 0; i &lt; dlc; ++i) {
 151                     const UChar* locale = getLocaleName(i);
 152                     int32_t ix = rhs-&gt;indexForLocale(locale);
 153                     // if no locale, ix is -1, getLocaleName returns null, so streq returns false
 154                     if (!streq(locale, rhs-&gt;getLocaleName(ix))) {
 155                         return FALSE;
 156                     }
 157                     for (int j = 0; j &lt; rsc; ++j) {
 158                         if (!streq(getDisplayName(i, j), rhs-&gt;getDisplayName(ix, j))) {
 159                             return FALSE;
 160                         }
 161                     }
 162                 }
 163                 return TRUE;
 164             }
 165         }
 166     }
 167     return FALSE;
 168 }
 169 
 170 int32_t
 171 LocalizationInfo::indexForLocale(const UChar* locale) const {
 172     for (int i = 0; i &lt; getNumberOfDisplayLocales(); ++i) {
 173         if (streq(locale, getLocaleName(i))) {
 174             return i;
 175         }
 176     }
 177     return -1;
 178 }
 179 
 180 int32_t
 181 LocalizationInfo::indexForRuleSet(const UChar* ruleset) const {
 182     if (ruleset) {
 183         for (int i = 0; i &lt; getNumberOfRuleSets(); ++i) {
 184             if (streq(ruleset, getRuleSetName(i))) {
 185                 return i;
 186             }
 187         }
 188     }
 189     return -1;
 190 }
 191 
 192 
 193 typedef void (*Fn_Deleter)(void*);
 194 
 195 class VArray {
 196     void** buf;
 197     int32_t cap;
 198     int32_t size;
 199     Fn_Deleter deleter;
 200 public:
 201     VArray() : buf(NULL), cap(0), size(0), deleter(NULL) {}
 202 
 203     VArray(Fn_Deleter del) : buf(NULL), cap(0), size(0), deleter(del) {}
 204 
 205     ~VArray() {
 206         if (deleter) {
 207             for (int i = 0; i &lt; size; ++i) {
 208                 (*deleter)(buf[i]);
 209             }
 210         }
 211         uprv_free(buf);
 212     }
 213 
 214     int32_t length() {
 215         return size;
 216     }
 217 
 218     void add(void* elem, UErrorCode&amp; status) {
 219         if (U_SUCCESS(status)) {
 220             if (size == cap) {
 221                 if (cap == 0) {
 222                     cap = 1;
 223                 } else if (cap &lt; 256) {
 224                     cap *= 2;
 225                 } else {
 226                     cap += 256;
 227                 }
 228                 if (buf == NULL) {
 229                     buf = (void**)uprv_malloc(cap * sizeof(void*));
 230                 } else {
 231                     buf = (void**)uprv_realloc(buf, cap * sizeof(void*));
 232                 }
 233                 if (buf == NULL) {
 234                     // if we couldn&#39;t realloc, we leak the memory we&#39;ve already allocated, but we&#39;re in deep trouble anyway
 235                     status = U_MEMORY_ALLOCATION_ERROR;
 236                     return;
 237                 }
 238                 void* start = &amp;buf[size];
 239                 size_t count = (cap - size) * sizeof(void*);
 240                 uprv_memset(start, 0, count); // fill with nulls, just because
 241             }
 242             buf[size++] = elem;
 243         }
 244     }
 245 
 246     void** release(void) {
 247         void** result = buf;
 248         buf = NULL;
 249         cap = 0;
 250         size = 0;
 251         return result;
 252     }
 253 };
 254 
 255 class LocDataParser;
 256 
 257 class StringLocalizationInfo : public LocalizationInfo {
 258     UChar* info;
 259     UChar*** data;
 260     int32_t numRuleSets;
 261     int32_t numLocales;
 262 
 263 friend class LocDataParser;
 264 
 265     StringLocalizationInfo(UChar* i, UChar*** d, int32_t numRS, int32_t numLocs)
 266         : info(i), data(d), numRuleSets(numRS), numLocales(numLocs)
 267     {
 268     }
 269 
 270 public:
 271     static StringLocalizationInfo* create(const UnicodeString&amp; info, UParseError&amp; perror, UErrorCode&amp; status);
 272 
 273     virtual ~StringLocalizationInfo();
 274     virtual int32_t getNumberOfRuleSets(void) const { return numRuleSets; }
 275     virtual const UChar* getRuleSetName(int32_t index) const;
 276     virtual int32_t getNumberOfDisplayLocales(void) const { return numLocales; }
 277     virtual const UChar* getLocaleName(int32_t index) const;
 278     virtual const UChar* getDisplayName(int32_t localeIndex, int32_t ruleIndex) const;
 279 
 280 //    virtual UClassID getDynamicClassID() const;
 281 //    static UClassID getStaticClassID(void);
 282 
 283 private:
 284     void init(UErrorCode&amp; status) const;
 285 };
 286 
 287 
 288 enum {
 289     OPEN_ANGLE = 0x003c, /* &#39;&lt;&#39; */
 290     CLOSE_ANGLE = 0x003e, /* &#39;&gt;&#39; */
 291     COMMA = 0x002c,
 292     TICK = 0x0027,
 293     QUOTE = 0x0022,
 294     SPACE = 0x0020
 295 };
 296 
 297 /**
 298  * Utility for parsing a localization string and returning a StringLocalizationInfo*.
 299  */
 300 class LocDataParser {
 301     UChar* data;
 302     const UChar* e;
 303     UChar* p;
 304     UChar ch;
 305     UParseError&amp; pe;
 306     UErrorCode&amp; ec;
 307 
 308 public:
 309     LocDataParser(UParseError&amp; parseError, UErrorCode&amp; status)
 310         : data(NULL), e(NULL), p(NULL), ch(0xffff), pe(parseError), ec(status) {}
 311     ~LocDataParser() {}
 312 
 313     /*
 314     * On a successful parse, return a StringLocalizationInfo*, otherwise delete locData, set perror and status,
 315     * and return NULL.  The StringLocalizationInfo will adopt locData if it is created.
 316     */
 317     StringLocalizationInfo* parse(UChar* data, int32_t len);
 318 
 319 private:
 320 
 321     inline void inc(void) {
 322         ++p;
 323         ch = 0xffff;
 324     }
 325     inline UBool checkInc(UChar c) {
 326         if (p &lt; e &amp;&amp; (ch == c || *p == c)) {
 327             inc();
 328             return TRUE;
 329         }
 330         return FALSE;
 331     }
 332     inline UBool check(UChar c) {
 333         return p &lt; e &amp;&amp; (ch == c || *p == c);
 334     }
 335     inline void skipWhitespace(void) {
 336         while (p &lt; e &amp;&amp; PatternProps::isWhiteSpace(ch != 0xffff ? ch : *p)) {
 337             inc();
 338         }
 339     }
 340     inline UBool inList(UChar c, const UChar* list) const {
 341         if (*list == SPACE &amp;&amp; PatternProps::isWhiteSpace(c)) {
 342             return TRUE;
 343         }
 344         while (*list &amp;&amp; *list != c) {
 345             ++list;
 346         }
 347         return *list == c;
 348     }
 349     void parseError(const char* msg);
 350 
 351     StringLocalizationInfo* doParse(void);
 352 
 353     UChar** nextArray(int32_t&amp; requiredLength);
 354     UChar*  nextString(void);
 355 };
 356 
 357 #ifdef RBNF_DEBUG
 358 #define ERROR(msg) parseError(msg); return NULL;
 359 #define EXPLANATION_ARG explanationArg
 360 #else
 361 #define ERROR(msg) parseError(NULL); return NULL;
 362 #define EXPLANATION_ARG
 363 #endif
 364 
 365 
 366 static const UChar DQUOTE_STOPLIST[] = {
 367     QUOTE, 0
 368 };
 369 
 370 static const UChar SQUOTE_STOPLIST[] = {
 371     TICK, 0
 372 };
 373 
 374 static const UChar NOQUOTE_STOPLIST[] = {
 375     SPACE, COMMA, CLOSE_ANGLE, OPEN_ANGLE, TICK, QUOTE, 0
 376 };
 377 
 378 static void
 379 DeleteFn(void* p) {
 380   uprv_free(p);
 381 }
 382 
 383 StringLocalizationInfo*
 384 LocDataParser::parse(UChar* _data, int32_t len) {
 385     if (U_FAILURE(ec)) {
 386         if (_data) uprv_free(_data);
 387         return NULL;
 388     }
 389 
 390     pe.line = 0;
 391     pe.offset = -1;
 392     pe.postContext[0] = 0;
 393     pe.preContext[0] = 0;
 394 
 395     if (_data == NULL) {
 396         ec = U_ILLEGAL_ARGUMENT_ERROR;
 397         return NULL;
 398     }
 399 
 400     if (len &lt;= 0) {
 401         ec = U_ILLEGAL_ARGUMENT_ERROR;
 402         uprv_free(_data);
 403         return NULL;
 404     }
 405 
 406     data = _data;
 407     e = data + len;
 408     p = _data;
 409     ch = 0xffff;
 410 
 411     return doParse();
 412 }
 413 
 414 
 415 StringLocalizationInfo*
 416 LocDataParser::doParse(void) {
 417     skipWhitespace();
 418     if (!checkInc(OPEN_ANGLE)) {
 419         ERROR(&quot;Missing open angle&quot;);
 420     } else {
 421         VArray array(DeleteFn);
 422         UBool mightHaveNext = TRUE;
 423         int32_t requiredLength = -1;
 424         while (mightHaveNext) {
 425             mightHaveNext = FALSE;
 426             UChar** elem = nextArray(requiredLength);
 427             skipWhitespace();
 428             UBool haveComma = check(COMMA);
 429             if (elem) {
 430                 array.add(elem, ec);
 431                 if (haveComma) {
 432                     inc();
 433                     mightHaveNext = TRUE;
 434                 }
 435             } else if (haveComma) {
 436                 ERROR(&quot;Unexpected character&quot;);
 437             }
 438         }
 439 
 440         skipWhitespace();
 441         if (!checkInc(CLOSE_ANGLE)) {
 442             if (check(OPEN_ANGLE)) {
 443                 ERROR(&quot;Missing comma in outer array&quot;);
 444             } else {
 445                 ERROR(&quot;Missing close angle bracket in outer array&quot;);
 446             }
 447         }
 448 
 449         skipWhitespace();
 450         if (p != e) {
 451             ERROR(&quot;Extra text after close of localization data&quot;);
 452         }
 453 
 454         array.add(NULL, ec);
 455         if (U_SUCCESS(ec)) {
 456             int32_t numLocs = array.length() - 2; // subtract first, NULL
 457             UChar*** result = (UChar***)array.release();
 458 
 459             return new StringLocalizationInfo(data, result, requiredLength-2, numLocs); // subtract first, NULL
 460         }
 461     }
 462 
 463     ERROR(&quot;Unknown error&quot;);
 464 }
 465 
 466 UChar**
 467 LocDataParser::nextArray(int32_t&amp; requiredLength) {
 468     if (U_FAILURE(ec)) {
 469         return NULL;
 470     }
 471 
 472     skipWhitespace();
 473     if (!checkInc(OPEN_ANGLE)) {
 474         ERROR(&quot;Missing open angle&quot;);
 475     }
 476 
 477     VArray array;
 478     UBool mightHaveNext = TRUE;
 479     while (mightHaveNext) {
 480         mightHaveNext = FALSE;
 481         UChar* elem = nextString();
 482         skipWhitespace();
 483         UBool haveComma = check(COMMA);
 484         if (elem) {
 485             array.add(elem, ec);
 486             if (haveComma) {
 487                 inc();
 488                 mightHaveNext = TRUE;
 489             }
 490         } else if (haveComma) {
 491             ERROR(&quot;Unexpected comma&quot;);
 492         }
 493     }
 494     skipWhitespace();
 495     if (!checkInc(CLOSE_ANGLE)) {
 496         if (check(OPEN_ANGLE)) {
 497             ERROR(&quot;Missing close angle bracket in inner array&quot;);
 498         } else {
 499             ERROR(&quot;Missing comma in inner array&quot;);
 500         }
 501     }
 502 
 503     array.add(NULL, ec);
 504     if (U_SUCCESS(ec)) {
 505         if (requiredLength == -1) {
 506             requiredLength = array.length() + 1;
 507         } else if (array.length() != requiredLength) {
 508             ec = U_ILLEGAL_ARGUMENT_ERROR;
 509             ERROR(&quot;Array not of required length&quot;);
 510         }
 511 
 512         return (UChar**)array.release();
 513     }
 514     ERROR(&quot;Unknown Error&quot;);
 515 }
 516 
 517 UChar*
 518 LocDataParser::nextString() {
 519     UChar* result = NULL;
 520 
 521     skipWhitespace();
 522     if (p &lt; e) {
 523         const UChar* terminators;
 524         UChar c = *p;
 525         UBool haveQuote = c == QUOTE || c == TICK;
 526         if (haveQuote) {
 527             inc();
 528             terminators = c == QUOTE ? DQUOTE_STOPLIST : SQUOTE_STOPLIST;
 529         } else {
 530             terminators = NOQUOTE_STOPLIST;
 531         }
 532         UChar* start = p;
 533         while (p &lt; e &amp;&amp; !inList(*p, terminators)) ++p;
 534         if (p == e) {
 535             ERROR(&quot;Unexpected end of data&quot;);
 536         }
 537 
 538         UChar x = *p;
 539         if (p &gt; start) {
 540             ch = x;
 541             *p = 0x0; // terminate by writing to data
 542             result = start; // just point into data
 543         }
 544         if (haveQuote) {
 545             if (x != c) {
 546                 ERROR(&quot;Missing matching quote&quot;);
 547             } else if (p == start) {
 548                 ERROR(&quot;Empty string&quot;);
 549             }
 550             inc();
 551         } else if (x == OPEN_ANGLE || x == TICK || x == QUOTE) {
 552             ERROR(&quot;Unexpected character in string&quot;);
 553         }
 554     }
 555 
 556     // ok for there to be no next string
 557     return result;
 558 }
 559 
 560 void LocDataParser::parseError(const char* EXPLANATION_ARG)
 561 {
 562     if (!data) {
 563         return;
 564     }
 565 
 566     const UChar* start = p - U_PARSE_CONTEXT_LEN - 1;
 567     if (start &lt; data) {
 568         start = data;
 569     }
 570     for (UChar* x = p; --x &gt;= start;) {
 571         if (!*x) {
 572             start = x+1;
 573             break;
 574         }
 575     }
 576     const UChar* limit = p + U_PARSE_CONTEXT_LEN - 1;
 577     if (limit &gt; e) {
 578         limit = e;
 579     }
 580     u_strncpy(pe.preContext, start, (int32_t)(p-start));
 581     pe.preContext[p-start] = 0;
 582     u_strncpy(pe.postContext, p, (int32_t)(limit-p));
 583     pe.postContext[limit-p] = 0;
 584     pe.offset = (int32_t)(p - data);
 585 
 586 #ifdef RBNF_DEBUG
 587     fprintf(stderr, &quot;%s at or near character %ld: &quot;, EXPLANATION_ARG, p-data);
 588 
 589     UnicodeString msg;
 590     msg.append(start, p - start);
 591     msg.append((UChar)0x002f); /* SOLIDUS/SLASH */
 592     msg.append(p, limit-p);
 593     msg.append(UNICODE_STRING_SIMPLE(&quot;&#39;&quot;));
 594 
 595     char buf[128];
 596     int32_t len = msg.extract(0, msg.length(), buf, 128);
 597     if (len &gt;= 128) {
 598         buf[127] = 0;
 599     } else {
 600         buf[len] = 0;
 601     }
 602     fprintf(stderr, &quot;%s\n&quot;, buf);
 603     fflush(stderr);
 604 #endif
 605 
 606     uprv_free(data);
 607     data = NULL;
 608     p = NULL;
 609     e = NULL;
 610 
 611     if (U_SUCCESS(ec)) {
 612         ec = U_PARSE_ERROR;
 613     }
 614 }
 615 
 616 //UOBJECT_DEFINE_RTTI_IMPLEMENTATION(StringLocalizationInfo)
 617 
 618 StringLocalizationInfo*
 619 StringLocalizationInfo::create(const UnicodeString&amp; info, UParseError&amp; perror, UErrorCode&amp; status) {
 620     if (U_FAILURE(status)) {
 621         return NULL;
 622     }
 623 
 624     int32_t len = info.length();
 625     if (len == 0) {
 626         return NULL; // no error;
 627     }
 628 
 629     UChar* p = (UChar*)uprv_malloc(len * sizeof(UChar));
 630     if (!p) {
 631         status = U_MEMORY_ALLOCATION_ERROR;
 632         return NULL;
 633     }
 634     info.extract(p, len, status);
 635     if (!U_FAILURE(status)) {
 636         status = U_ZERO_ERROR; // clear warning about non-termination
 637     }
 638 
 639     LocDataParser parser(perror, status);
 640     return parser.parse(p, len);
 641 }
 642 
 643 StringLocalizationInfo::~StringLocalizationInfo() {
 644     for (UChar*** p = (UChar***)data; *p; ++p) {
 645         // remaining data is simply pointer into our unicode string data.
 646         if (*p) uprv_free(*p);
 647     }
 648     if (data) uprv_free(data);
 649     if (info) uprv_free(info);
 650 }
 651 
 652 
 653 const UChar*
 654 StringLocalizationInfo::getRuleSetName(int32_t index) const {
 655     if (index &gt;= 0 &amp;&amp; index &lt; getNumberOfRuleSets()) {
 656         return data[0][index];
 657     }
 658     return NULL;
 659 }
 660 
 661 const UChar*
 662 StringLocalizationInfo::getLocaleName(int32_t index) const {
 663     if (index &gt;= 0 &amp;&amp; index &lt; getNumberOfDisplayLocales()) {
 664         return data[index+1][0];
 665     }
 666     return NULL;
 667 }
 668 
 669 const UChar*
 670 StringLocalizationInfo::getDisplayName(int32_t localeIndex, int32_t ruleIndex) const {
 671     if (localeIndex &gt;= 0 &amp;&amp; localeIndex &lt; getNumberOfDisplayLocales() &amp;&amp;
 672         ruleIndex &gt;= 0 &amp;&amp; ruleIndex &lt; getNumberOfRuleSets()) {
 673         return data[localeIndex+1][ruleIndex+1];
 674     }
 675     return NULL;
 676 }
 677 
 678 // ----------
 679 
 680 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 681                                              const UnicodeString&amp; locs,
 682                                              const Locale&amp; alocale, UParseError&amp; perror, UErrorCode&amp; status)
 683   : ruleSets(NULL)
 684   , ruleSetDescriptions(NULL)
 685   , numRuleSets(0)
 686   , defaultRuleSet(NULL)
 687   , locale(alocale)
 688   , collator(NULL)
 689   , decimalFormatSymbols(NULL)
 690   , defaultInfinityRule(NULL)
 691   , defaultNaNRule(NULL)
 692   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
 693   , lenient(FALSE)
 694   , lenientParseRules(NULL)
 695   , localizations(NULL)
 696   , capitalizationInfoSet(FALSE)
 697   , capitalizationForUIListMenu(FALSE)
 698   , capitalizationForStandAlone(FALSE)
 699   , capitalizationBrkIter(NULL)
 700 {
 701   LocalizationInfo* locinfo = StringLocalizationInfo::create(locs, perror, status);
 702   init(description, locinfo, perror, status);
 703 }
 704 
 705 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 706                                              const UnicodeString&amp; locs,
 707                                              UParseError&amp; perror, UErrorCode&amp; status)
 708   : ruleSets(NULL)
 709   , ruleSetDescriptions(NULL)
 710   , numRuleSets(0)
 711   , defaultRuleSet(NULL)
 712   , locale(Locale::getDefault())
 713   , collator(NULL)
 714   , decimalFormatSymbols(NULL)
 715   , defaultInfinityRule(NULL)
 716   , defaultNaNRule(NULL)
 717   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
 718   , lenient(FALSE)
 719   , lenientParseRules(NULL)
 720   , localizations(NULL)
 721   , capitalizationInfoSet(FALSE)
 722   , capitalizationForUIListMenu(FALSE)
 723   , capitalizationForStandAlone(FALSE)
 724   , capitalizationBrkIter(NULL)
 725 {
 726   LocalizationInfo* locinfo = StringLocalizationInfo::create(locs, perror, status);
 727   init(description, locinfo, perror, status);
 728 }
 729 
 730 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 731                                              LocalizationInfo* info,
 732                                              const Locale&amp; alocale, UParseError&amp; perror, UErrorCode&amp; status)
 733   : ruleSets(NULL)
 734   , ruleSetDescriptions(NULL)
 735   , numRuleSets(0)
 736   , defaultRuleSet(NULL)
 737   , locale(alocale)
 738   , collator(NULL)
 739   , decimalFormatSymbols(NULL)
 740   , defaultInfinityRule(NULL)
 741   , defaultNaNRule(NULL)
 742   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
 743   , lenient(FALSE)
 744   , lenientParseRules(NULL)
 745   , localizations(NULL)
 746   , capitalizationInfoSet(FALSE)
 747   , capitalizationForUIListMenu(FALSE)
 748   , capitalizationForStandAlone(FALSE)
 749   , capitalizationBrkIter(NULL)
 750 {
 751   init(description, info, perror, status);
 752 }
 753 
 754 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 755                          UParseError&amp; perror,
 756                          UErrorCode&amp; status)
 757   : ruleSets(NULL)
 758   , ruleSetDescriptions(NULL)
 759   , numRuleSets(0)
 760   , defaultRuleSet(NULL)
 761   , locale(Locale::getDefault())
 762   , collator(NULL)
 763   , decimalFormatSymbols(NULL)
 764   , defaultInfinityRule(NULL)
 765   , defaultNaNRule(NULL)
 766   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
 767   , lenient(FALSE)
 768   , lenientParseRules(NULL)
 769   , localizations(NULL)
 770   , capitalizationInfoSet(FALSE)
 771   , capitalizationForUIListMenu(FALSE)
 772   , capitalizationForStandAlone(FALSE)
 773   , capitalizationBrkIter(NULL)
 774 {
 775     init(description, NULL, perror, status);
 776 }
 777 
 778 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 779                          const Locale&amp; aLocale,
 780                          UParseError&amp; perror,
 781                          UErrorCode&amp; status)
 782   : ruleSets(NULL)
 783   , ruleSetDescriptions(NULL)
 784   , numRuleSets(0)
 785   , defaultRuleSet(NULL)
 786   , locale(aLocale)
 787   , collator(NULL)
 788   , decimalFormatSymbols(NULL)
 789   , defaultInfinityRule(NULL)
 790   , defaultNaNRule(NULL)
 791   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
 792   , lenient(FALSE)
 793   , lenientParseRules(NULL)
 794   , localizations(NULL)
 795   , capitalizationInfoSet(FALSE)
 796   , capitalizationForUIListMenu(FALSE)
 797   , capitalizationForStandAlone(FALSE)
 798   , capitalizationBrkIter(NULL)
 799 {
 800     init(description, NULL, perror, status);
 801 }
 802 
 803 RuleBasedNumberFormat::RuleBasedNumberFormat(URBNFRuleSetTag tag, const Locale&amp; alocale, UErrorCode&amp; status)
 804   : ruleSets(NULL)
 805   , ruleSetDescriptions(NULL)
 806   , numRuleSets(0)
 807   , defaultRuleSet(NULL)
 808   , locale(alocale)
 809   , collator(NULL)
 810   , decimalFormatSymbols(NULL)
 811   , defaultInfinityRule(NULL)
 812   , defaultNaNRule(NULL)
 813   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
 814   , lenient(FALSE)
 815   , lenientParseRules(NULL)
 816   , localizations(NULL)
 817   , capitalizationInfoSet(FALSE)
 818   , capitalizationForUIListMenu(FALSE)
 819   , capitalizationForStandAlone(FALSE)
 820   , capitalizationBrkIter(NULL)
 821 {
 822     if (U_FAILURE(status)) {
 823         return;
 824     }
 825 
 826     const char* rules_tag = &quot;RBNFRules&quot;;
 827     const char* fmt_tag = &quot;&quot;;
 828     switch (tag) {
 829     case URBNF_SPELLOUT: fmt_tag = &quot;SpelloutRules&quot;; break;
 830     case URBNF_ORDINAL: fmt_tag = &quot;OrdinalRules&quot;; break;
 831     case URBNF_DURATION: fmt_tag = &quot;DurationRules&quot;; break;
 832     case URBNF_NUMBERING_SYSTEM: fmt_tag = &quot;NumberingSystemRules&quot;; break;
 833     default: status = U_ILLEGAL_ARGUMENT_ERROR; return;
 834     }
 835 
 836     // TODO: read localization info from resource
 837     LocalizationInfo* locinfo = NULL;
 838 
 839     UResourceBundle* nfrb = ures_open(U_ICUDATA_RBNF, locale.getName(), &amp;status);
 840     if (U_SUCCESS(status)) {
 841         setLocaleIDs(ures_getLocaleByType(nfrb, ULOC_VALID_LOCALE, &amp;status),
 842                      ures_getLocaleByType(nfrb, ULOC_ACTUAL_LOCALE, &amp;status));
 843 
 844         UResourceBundle* rbnfRules = ures_getByKeyWithFallback(nfrb, rules_tag, NULL, &amp;status);
 845         if (U_FAILURE(status)) {
 846             ures_close(nfrb);
 847         }
 848         UResourceBundle* ruleSets = ures_getByKeyWithFallback(rbnfRules, fmt_tag, NULL, &amp;status);
 849         if (U_FAILURE(status)) {
 850             ures_close(rbnfRules);
 851             ures_close(nfrb);
 852             return;
 853         }
 854 
 855         UnicodeString desc;
 856         while (ures_hasNext(ruleSets)) {
 857            desc.append(ures_getNextUnicodeString(ruleSets,NULL,&amp;status));
 858         }
 859         UParseError perror;
 860 
 861         init(desc, locinfo, perror, status);
 862 
 863         ures_close(ruleSets);
 864         ures_close(rbnfRules);
 865     }
 866     ures_close(nfrb);
 867 }
 868 
 869 RuleBasedNumberFormat::RuleBasedNumberFormat(const RuleBasedNumberFormat&amp; rhs)
 870   : NumberFormat(rhs)
 871   , ruleSets(NULL)
 872   , ruleSetDescriptions(NULL)
 873   , numRuleSets(0)
 874   , defaultRuleSet(NULL)
 875   , locale(rhs.locale)
 876   , collator(NULL)
 877   , decimalFormatSymbols(NULL)
 878   , defaultInfinityRule(NULL)
 879   , defaultNaNRule(NULL)
 880   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)
 881   , lenient(FALSE)
 882   , lenientParseRules(NULL)
 883   , localizations(NULL)
 884   , capitalizationInfoSet(FALSE)
 885   , capitalizationForUIListMenu(FALSE)
 886   , capitalizationForStandAlone(FALSE)
 887   , capitalizationBrkIter(NULL)
 888 {
 889     this-&gt;operator=(rhs);
 890 }
 891 
 892 // --------
 893 
 894 RuleBasedNumberFormat&amp;
 895 RuleBasedNumberFormat::operator=(const RuleBasedNumberFormat&amp; rhs)
 896 {
 897     if (this == &amp;rhs) {
 898         return *this;
 899     }
 900     NumberFormat::operator=(rhs);
 901     UErrorCode status = U_ZERO_ERROR;
 902     dispose();
 903     locale = rhs.locale;
 904     lenient = rhs.lenient;
 905 
 906     UParseError perror;
 907     setDecimalFormatSymbols(*rhs.getDecimalFormatSymbols());
 908     init(rhs.originalDescription, rhs.localizations ? rhs.localizations-&gt;ref() : NULL, perror, status);
 909     setDefaultRuleSet(rhs.getDefaultRuleSetName(), status);
 910     setRoundingMode(rhs.getRoundingMode());
 911 
 912     capitalizationInfoSet = rhs.capitalizationInfoSet;
 913     capitalizationForUIListMenu = rhs.capitalizationForUIListMenu;
 914     capitalizationForStandAlone = rhs.capitalizationForStandAlone;
 915 #if !UCONFIG_NO_BREAK_ITERATION
 916     capitalizationBrkIter = (rhs.capitalizationBrkIter!=NULL)? rhs.capitalizationBrkIter-&gt;clone(): NULL;
 917 #endif
 918 
 919     return *this;
 920 }
 921 
 922 RuleBasedNumberFormat::~RuleBasedNumberFormat()
 923 {
 924     dispose();
 925 }
 926 
 927 Format*
 928 RuleBasedNumberFormat::clone(void) const
 929 {
 930     return new RuleBasedNumberFormat(*this);
 931 }
 932 
 933 UBool
 934 RuleBasedNumberFormat::operator==(const Format&amp; other) const
 935 {
 936     if (this == &amp;other) {
 937         return TRUE;
 938     }
 939 
 940     if (typeid(*this) == typeid(other)) {
 941         const RuleBasedNumberFormat&amp; rhs = (const RuleBasedNumberFormat&amp;)other;
 942         // test for capitalization info equality is adequately handled
 943         // by the NumberFormat test for fCapitalizationContext equality;
 944         // the info here is just derived from that.
 945         if (locale == rhs.locale &amp;&amp;
 946             lenient == rhs.lenient &amp;&amp;
 947             (localizations == NULL
 948                 ? rhs.localizations == NULL
 949                 : (rhs.localizations == NULL
 950                     ? FALSE
 951                     : *localizations == rhs.localizations))) {
 952 
 953             NFRuleSet** p = ruleSets;
 954             NFRuleSet** q = rhs.ruleSets;
 955             if (p == NULL) {
 956                 return q == NULL;
 957             } else if (q == NULL) {
 958                 return FALSE;
 959             }
 960             while (*p &amp;&amp; *q &amp;&amp; (**p == **q)) {
 961                 ++p;
 962                 ++q;
 963             }
 964             return *q == NULL &amp;&amp; *p == NULL;
 965         }
 966     }
 967 
 968     return FALSE;
 969 }
 970 
 971 UnicodeString
 972 RuleBasedNumberFormat::getRules() const
 973 {
 974     UnicodeString result;
 975     if (ruleSets != NULL) {
 976         for (NFRuleSet** p = ruleSets; *p; ++p) {
 977             (*p)-&gt;appendRules(result);
 978         }
 979     }
 980     return result;
 981 }
 982 
 983 UnicodeString
 984 RuleBasedNumberFormat::getRuleSetName(int32_t index) const
 985 {
 986     if (localizations) {
 987         UnicodeString string(TRUE, localizations-&gt;getRuleSetName(index), (int32_t)-1);
 988         return string;
 989     }
 990     else if (ruleSets) {
 991         UnicodeString result;
 992         for (NFRuleSet** p = ruleSets; *p; ++p) {
 993             NFRuleSet* rs = *p;
 994             if (rs-&gt;isPublic()) {
 995                 if (--index == -1) {
 996                     rs-&gt;getName(result);
 997                     return result;
 998                 }
 999             }
1000         }
1001     }
1002     UnicodeString empty;
1003     return empty;
1004 }
1005 
1006 int32_t
1007 RuleBasedNumberFormat::getNumberOfRuleSetNames() const
1008 {
1009     int32_t result = 0;
1010     if (localizations) {
1011         result = localizations-&gt;getNumberOfRuleSets();
1012     }
1013     else if (ruleSets) {
1014         for (NFRuleSet** p = ruleSets; *p; ++p) {
1015             if ((**p).isPublic()) {
1016                 ++result;
1017             }
1018         }
1019     }
1020     return result;
1021 }
1022 
1023 int32_t
1024 RuleBasedNumberFormat::getNumberOfRuleSetDisplayNameLocales(void) const {
1025     if (localizations) {
1026         return localizations-&gt;getNumberOfDisplayLocales();
1027     }
1028     return 0;
1029 }
1030 
1031 Locale
1032 RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int32_t index, UErrorCode&amp; status) const {
1033     if (U_FAILURE(status)) {
1034         return Locale(&quot;&quot;);
1035     }
1036     if (localizations &amp;&amp; index &gt;= 0 &amp;&amp; index &lt; localizations-&gt;getNumberOfDisplayLocales()) {
1037         UnicodeString name(TRUE, localizations-&gt;getLocaleName(index), -1);
1038         char buffer[64];
1039         int32_t cap = name.length() + 1;
1040         char* bp = buffer;
1041         if (cap &gt; 64) {
1042             bp = (char *)uprv_malloc(cap);
1043             if (bp == NULL) {
1044                 status = U_MEMORY_ALLOCATION_ERROR;
1045                 return Locale(&quot;&quot;);
1046             }
1047         }
1048         name.extract(0, name.length(), bp, cap, UnicodeString::kInvariant);
1049         Locale retLocale(bp);
1050         if (bp != buffer) {
1051             uprv_free(bp);
1052         }
1053         return retLocale;
1054     }
1055     status = U_ILLEGAL_ARGUMENT_ERROR;
1056     Locale retLocale;
1057     return retLocale;
1058 }
1059 
1060 UnicodeString
1061 RuleBasedNumberFormat::getRuleSetDisplayName(int32_t index, const Locale&amp; localeParam) {
1062     if (localizations &amp;&amp; index &gt;= 0 &amp;&amp; index &lt; localizations-&gt;getNumberOfRuleSets()) {
1063         UnicodeString localeName(localeParam.getBaseName(), -1, UnicodeString::kInvariant);
1064         int32_t len = localeName.length();
1065         UChar* localeStr = localeName.getBuffer(len + 1);
1066         while (len &gt;= 0) {
1067             localeStr[len] = 0;
1068             int32_t ix = localizations-&gt;indexForLocale(localeStr);
1069             if (ix &gt;= 0) {
1070                 UnicodeString name(TRUE, localizations-&gt;getDisplayName(ix, index), -1);
1071                 return name;
1072             }
1073 
1074             // trim trailing portion, skipping over ommitted sections
1075             do { --len;} while (len &gt; 0 &amp;&amp; localeStr[len] != 0x005f); // underscore
1076             while (len &gt; 0 &amp;&amp; localeStr[len-1] == 0x005F) --len;
1077         }
1078         UnicodeString name(TRUE, localizations-&gt;getRuleSetName(index), -1);
1079         return name;
1080     }
1081     UnicodeString bogus;
1082     bogus.setToBogus();
1083     return bogus;
1084 }
1085 
1086 UnicodeString
1087 RuleBasedNumberFormat::getRuleSetDisplayName(const UnicodeString&amp; ruleSetName, const Locale&amp; localeParam) {
1088     if (localizations) {
1089         UnicodeString rsn(ruleSetName);
1090         int32_t ix = localizations-&gt;indexForRuleSet(rsn.getTerminatedBuffer());
1091         return getRuleSetDisplayName(ix, localeParam);
1092     }
1093     UnicodeString bogus;
1094     bogus.setToBogus();
1095     return bogus;
1096 }
1097 
1098 NFRuleSet*
1099 RuleBasedNumberFormat::findRuleSet(const UnicodeString&amp; name, UErrorCode&amp; status) const
1100 {
1101     if (U_SUCCESS(status) &amp;&amp; ruleSets) {
1102         for (NFRuleSet** p = ruleSets; *p; ++p) {
1103             NFRuleSet* rs = *p;
1104             if (rs-&gt;isNamed(name)) {
1105                 return rs;
1106             }
1107         }
1108         status = U_ILLEGAL_ARGUMENT_ERROR;
1109     }
1110     return NULL;
1111 }
1112 
1113 UnicodeString&amp;
1114 RuleBasedNumberFormat::format(const DecimalQuantity &amp;number,
1115                       UnicodeString &amp;appendTo,
1116                       FieldPositionIterator *posIter,
1117                       UErrorCode &amp;status) const {
1118     if (U_FAILURE(status)) {
1119         return appendTo;
1120     }
1121     DecimalQuantity copy(number);
1122     if (copy.fitsInLong()) {
1123         format(number.toLong(), appendTo, posIter, status);
1124     }
1125     else {
1126         copy.roundToMagnitude(0, number::impl::RoundingMode::UNUM_ROUND_HALFEVEN, status);
1127         if (copy.fitsInLong()) {
1128             format(number.toDouble(), appendTo, posIter, status);
1129         }
1130         else {
1131             // We&#39;re outside of our normal range that this framework can handle.
1132             // The DecimalFormat will provide more accurate results.
1133 
1134             // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
1135             NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);
1136             Formattable f;
1137             f.adoptDecimalQuantity(new DecimalQuantity(number));
1138             decimalFormat-&gt;format(f, appendTo, posIter, status);
1139             delete decimalFormat;
1140         }
1141     }
1142     return appendTo;
1143 }
1144 
1145 
1146 UnicodeString&amp;
1147 RuleBasedNumberFormat::format(const DecimalQuantity &amp;number,
1148                      UnicodeString&amp; appendTo,
1149                      FieldPosition&amp; pos,
1150                      UErrorCode &amp;status) const {
1151     if (U_FAILURE(status)) {
1152         return appendTo;
1153     }
1154     DecimalQuantity copy(number);
1155     if (copy.fitsInLong()) {
1156         format(number.toLong(), appendTo, pos, status);
1157     }
1158     else {
1159         copy.roundToMagnitude(0, number::impl::RoundingMode::UNUM_ROUND_HALFEVEN, status);
1160         if (copy.fitsInLong()) {
1161             format(number.toDouble(), appendTo, pos, status);
1162         }
1163         else {
1164             // We&#39;re outside of our normal range that this framework can handle.
1165             // The DecimalFormat will provide more accurate results.
1166 
1167             // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
1168             NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);
1169             Formattable f;
1170             f.adoptDecimalQuantity(new DecimalQuantity(number));
1171             decimalFormat-&gt;format(f, appendTo, pos, status);
1172             delete decimalFormat;
1173         }
1174     }
1175     return appendTo;
1176 }
1177 
1178 UnicodeString&amp;
1179 RuleBasedNumberFormat::format(int32_t number,
1180                               UnicodeString&amp; toAppendTo,
1181                               FieldPosition&amp; pos) const
1182 {
1183     return format((int64_t)number, toAppendTo, pos);
1184 }
1185 
1186 
1187 UnicodeString&amp;
1188 RuleBasedNumberFormat::format(int64_t number,
1189                               UnicodeString&amp; toAppendTo,
1190                               FieldPosition&amp; /* pos */) const
1191 {
1192     if (defaultRuleSet) {
1193         UErrorCode status = U_ZERO_ERROR;
1194         format(number, defaultRuleSet, toAppendTo, status);
1195     }
1196     return toAppendTo;
1197 }
1198 
1199 
1200 UnicodeString&amp;
1201 RuleBasedNumberFormat::format(double number,
1202                               UnicodeString&amp; toAppendTo,
1203                               FieldPosition&amp; /* pos */) const
1204 {
1205     UErrorCode status = U_ZERO_ERROR;
1206     if (defaultRuleSet) {
1207         format(number, *defaultRuleSet, toAppendTo, status);
1208     }
1209     return toAppendTo;
1210 }
1211 
1212 
1213 UnicodeString&amp;
1214 RuleBasedNumberFormat::format(int32_t number,
1215                               const UnicodeString&amp; ruleSetName,
1216                               UnicodeString&amp; toAppendTo,
1217                               FieldPosition&amp; pos,
1218                               UErrorCode&amp; status) const
1219 {
1220     return format((int64_t)number, ruleSetName, toAppendTo, pos, status);
1221 }
1222 
1223 
1224 UnicodeString&amp;
1225 RuleBasedNumberFormat::format(int64_t number,
1226                               const UnicodeString&amp; ruleSetName,
1227                               UnicodeString&amp; toAppendTo,
1228                               FieldPosition&amp; /* pos */,
1229                               UErrorCode&amp; status) const
1230 {
1231     if (U_SUCCESS(status)) {
1232         if (ruleSetName.indexOf(gPercentPercent, 2, 0) == 0) {
1233             // throw new IllegalArgumentException(&quot;Can&#39;t use internal rule set&quot;);
1234             status = U_ILLEGAL_ARGUMENT_ERROR;
1235         } else {
1236             NFRuleSet *rs = findRuleSet(ruleSetName, status);
1237             if (rs) {
1238                 format(number, rs, toAppendTo, status);
1239             }
1240         }
1241     }
1242     return toAppendTo;
1243 }
1244 
1245 
1246 UnicodeString&amp;
1247 RuleBasedNumberFormat::format(double number,
1248                               const UnicodeString&amp; ruleSetName,
1249                               UnicodeString&amp; toAppendTo,
1250                               FieldPosition&amp; /* pos */,
1251                               UErrorCode&amp; status) const
1252 {
1253     if (U_SUCCESS(status)) {
1254         if (ruleSetName.indexOf(gPercentPercent, 2, 0) == 0) {
1255             // throw new IllegalArgumentException(&quot;Can&#39;t use internal rule set&quot;);
1256             status = U_ILLEGAL_ARGUMENT_ERROR;
1257         } else {
1258             NFRuleSet *rs = findRuleSet(ruleSetName, status);
1259             if (rs) {
1260                 format(number, *rs, toAppendTo, status);
1261             }
1262         }
1263     }
1264     return toAppendTo;
1265 }
1266 
1267 void
1268 RuleBasedNumberFormat::format(double number,
1269                               NFRuleSet&amp; rs,
1270                               UnicodeString&amp; toAppendTo,
1271                               UErrorCode&amp; status) const
1272 {
1273     int32_t startPos = toAppendTo.length();
1274     if (getRoundingMode() != DecimalFormat::ERoundingMode::kRoundUnnecessary &amp;&amp; !uprv_isNaN(number) &amp;&amp; !uprv_isInfinite(number)) {
1275         DecimalQuantity digitList;
1276         digitList.setToDouble(number);
1277         digitList.roundToMagnitude(
1278                 -getMaximumFractionDigits(),
1279                 static_cast&lt;UNumberFormatRoundingMode&gt;(getRoundingMode()),
1280                 status);
1281         number = digitList.toDouble();
1282     }
1283     rs.format(number, toAppendTo, toAppendTo.length(), 0, status);
1284     adjustForCapitalizationContext(startPos, toAppendTo, status);
1285 }
1286 
1287 /**
1288  * Bottleneck through which all the public format() methods
1289  * that take a long pass. By the time we get here, we know
1290  * which rule set we&#39;re using to do the formatting.
1291  * @param number The number to format
1292  * @param ruleSet The rule set to use to format the number
1293  * @return The text that resulted from formatting the number
1294  */
1295 UnicodeString&amp;
1296 RuleBasedNumberFormat::format(int64_t number, NFRuleSet *ruleSet, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const
1297 {
1298     // all API format() routines that take a double vector through
1299     // here.  We have these two identical functions-- one taking a
1300     // double and one taking a long-- the couple digits of precision
1301     // that long has but double doesn&#39;t (both types are 8 bytes long,
1302     // but double has to borrow some of the mantissa bits to hold
1303     // the exponent).
1304     // Create an empty string buffer where the result will
1305     // be built, and pass it to the rule set (along with an insertion
1306     // position of 0 and the number being formatted) to the rule set
1307     // for formatting
1308 
1309     if (U_SUCCESS(status)) {
1310         if (number == U_INT64_MIN) {
1311             // We can&#39;t handle this value right now. Provide an accurate default value.
1312 
1313             // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
1314             NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);
1315             Formattable f;
1316             FieldPosition pos(FieldPosition::DONT_CARE);
1317             DecimalQuantity *digitList = new DecimalQuantity();
1318             digitList-&gt;setToLong(number);
1319             f.adoptDecimalQuantity(digitList);
1320             decimalFormat-&gt;format(f, toAppendTo, pos, status);
1321             delete decimalFormat;
1322         }
1323         else {
1324             int32_t startPos = toAppendTo.length();
1325             ruleSet-&gt;format(number, toAppendTo, toAppendTo.length(), 0, status);
1326             adjustForCapitalizationContext(startPos, toAppendTo, status);
1327         }
1328     }
1329     return toAppendTo;
1330 }
1331 
1332 UnicodeString&amp;
1333 RuleBasedNumberFormat::adjustForCapitalizationContext(int32_t startPos,
1334                                                       UnicodeString&amp; currentResult,
1335                                                       UErrorCode&amp; status) const
1336 {
1337 #if !UCONFIG_NO_BREAK_ITERATION
1338     UDisplayContext capitalizationContext = getContext(UDISPCTX_TYPE_CAPITALIZATION, status);
1339     if (capitalizationContext != UDISPCTX_CAPITALIZATION_NONE &amp;&amp; startPos == 0 &amp;&amp; currentResult.length() &gt; 0) {
1340         // capitalize currentResult according to context
1341         UChar32 ch = currentResult.char32At(0);
1342         if (u_islower(ch) &amp;&amp; U_SUCCESS(status) &amp;&amp; capitalizationBrkIter != NULL &amp;&amp;
1343               ( capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
1344                 (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU &amp;&amp; capitalizationForUIListMenu) ||
1345                 (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_STANDALONE &amp;&amp; capitalizationForStandAlone)) ) {
1346             // titlecase first word of currentResult, here use sentence iterator unlike current implementations
1347             // in LocaleDisplayNamesImpl::adjustForUsageAndContext and RelativeDateFormat::format
1348             currentResult.toTitle(capitalizationBrkIter, locale, U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
1349         }
1350     }
1351 #endif
1352     return currentResult;
1353 }
1354 
1355 
1356 void
1357 RuleBasedNumberFormat::parse(const UnicodeString&amp; text,
1358                              Formattable&amp; result,
1359                              ParsePosition&amp; parsePosition) const
1360 {
1361     if (!ruleSets) {
1362         parsePosition.setErrorIndex(0);
1363         return;
1364     }
1365 
1366     UnicodeString workingText(text, parsePosition.getIndex());
1367     ParsePosition workingPos(0);
1368 
1369     ParsePosition high_pp(0);
1370     Formattable high_result;
1371 
1372     for (NFRuleSet** p = ruleSets; *p; ++p) {
1373         NFRuleSet *rp = *p;
1374         if (rp-&gt;isPublic() &amp;&amp; rp-&gt;isParseable()) {
1375             ParsePosition working_pp(0);
1376             Formattable working_result;
1377 
1378             rp-&gt;parse(workingText, working_pp, kMaxDouble, 0, working_result);
1379             if (working_pp.getIndex() &gt; high_pp.getIndex()) {
1380                 high_pp = working_pp;
1381                 high_result = working_result;
1382 
1383                 if (high_pp.getIndex() == workingText.length()) {
1384                     break;
1385                 }
1386             }
1387         }
1388     }
1389 
1390     int32_t startIndex = parsePosition.getIndex();
1391     parsePosition.setIndex(startIndex + high_pp.getIndex());
1392     if (high_pp.getIndex() &gt; 0) {
1393         parsePosition.setErrorIndex(-1);
1394     } else {
1395         int32_t errorIndex = (high_pp.getErrorIndex()&gt;0)? high_pp.getErrorIndex(): 0;
1396         parsePosition.setErrorIndex(startIndex + errorIndex);
1397     }
1398     result = high_result;
1399     if (result.getType() == Formattable::kDouble) {
1400         double d = result.getDouble();
1401         if (!uprv_isNaN(d) &amp;&amp; d == uprv_trunc(d) &amp;&amp; INT32_MIN &lt;= d &amp;&amp; d &lt;= INT32_MAX) {
1402             // Note: casting a double to an int when the double is too large or small
1403             //       to fit the destination is undefined behavior. The explicit range checks,
1404             //       above, are required. Just casting and checking the result value is undefined.
1405             result.setLong(static_cast&lt;int32_t&gt;(d));
1406         }
1407     }
1408 }
1409 
1410 #if !UCONFIG_NO_COLLATION
1411 
1412 void
1413 RuleBasedNumberFormat::setLenient(UBool enabled)
1414 {
1415     lenient = enabled;
1416     if (!enabled &amp;&amp; collator) {
1417         delete collator;
1418         collator = NULL;
1419     }
1420 }
1421 
1422 #endif
1423 
1424 void
1425 RuleBasedNumberFormat::setDefaultRuleSet(const UnicodeString&amp; ruleSetName, UErrorCode&amp; status) {
1426     if (U_SUCCESS(status)) {
1427         if (ruleSetName.isEmpty()) {
1428           if (localizations) {
1429               UnicodeString name(TRUE, localizations-&gt;getRuleSetName(0), -1);
1430               defaultRuleSet = findRuleSet(name, status);
1431           } else {
1432             initDefaultRuleSet();
1433           }
1434         } else if (ruleSetName.startsWith(UNICODE_STRING_SIMPLE(&quot;%%&quot;))) {
1435             status = U_ILLEGAL_ARGUMENT_ERROR;
1436         } else {
1437             NFRuleSet* result = findRuleSet(ruleSetName, status);
1438             if (result != NULL) {
1439                 defaultRuleSet = result;
1440             }
1441         }
1442     }
1443 }
1444 
1445 UnicodeString
1446 RuleBasedNumberFormat::getDefaultRuleSetName() const {
1447     UnicodeString result;
1448     if (defaultRuleSet &amp;&amp; defaultRuleSet-&gt;isPublic()) {
1449         defaultRuleSet-&gt;getName(result);
1450     } else {
1451         result.setToBogus();
1452     }
1453     return result;
1454 }
1455 
1456 void
1457 RuleBasedNumberFormat::initDefaultRuleSet()
1458 {
1459     defaultRuleSet = NULL;
1460     if (!ruleSets) {
1461         return;
1462     }
1463 
1464     const UnicodeString spellout(UNICODE_STRING_SIMPLE(&quot;%spellout-numbering&quot;));
1465     const UnicodeString ordinal(UNICODE_STRING_SIMPLE(&quot;%digits-ordinal&quot;));
1466     const UnicodeString duration(UNICODE_STRING_SIMPLE(&quot;%duration&quot;));
1467 
1468     NFRuleSet**p = &amp;ruleSets[0];
1469     while (*p) {
1470         if ((*p)-&gt;isNamed(spellout) || (*p)-&gt;isNamed(ordinal) || (*p)-&gt;isNamed(duration)) {
1471             defaultRuleSet = *p;
1472             return;
1473         } else {
1474             ++p;
1475         }
1476     }
1477 
1478     defaultRuleSet = *--p;
1479     if (!defaultRuleSet-&gt;isPublic()) {
1480         while (p != ruleSets) {
1481             if ((*--p)-&gt;isPublic()) {
1482                 defaultRuleSet = *p;
1483                 break;
1484             }
1485         }
1486     }
1487 }
1488 
1489 
1490 void
1491 RuleBasedNumberFormat::init(const UnicodeString&amp; rules, LocalizationInfo* localizationInfos,
1492                             UParseError&amp; pErr, UErrorCode&amp; status)
1493 {
1494     // TODO: implement UParseError
1495     uprv_memset(&amp;pErr, 0, sizeof(UParseError));
1496     // Note: this can leave ruleSets == NULL, so remaining code should check
1497     if (U_FAILURE(status)) {
1498         return;
1499     }
1500 
1501     initializeDecimalFormatSymbols(status);
1502     initializeDefaultInfinityRule(status);
1503     initializeDefaultNaNRule(status);
1504     if (U_FAILURE(status)) {
1505         return;
1506     }
1507 
1508     this-&gt;localizations = localizationInfos == NULL ? NULL : localizationInfos-&gt;ref();
1509 
1510     UnicodeString description(rules);
1511     if (!description.length()) {
1512         status = U_MEMORY_ALLOCATION_ERROR;
1513         return;
1514     }
1515 
1516     // start by stripping the trailing whitespace from all the rules
1517     // (this is all the whitespace follwing each semicolon in the
1518     // description).  This allows us to look for rule-set boundaries
1519     // by searching for &quot;;%&quot; without having to worry about whitespace
1520     // between the ; and the %
1521     stripWhitespace(description);
1522 
1523     // check to see if there&#39;s a set of lenient-parse rules.  If there
1524     // is, pull them out into our temporary holding place for them,
1525     // and delete them from the description before the real desciption-
1526     // parsing code sees them
1527     int32_t lp = description.indexOf(gLenientParse, -1, 0);
1528     if (lp != -1) {
1529         // we&#39;ve got to make sure we&#39;re not in the middle of a rule
1530         // (where &quot;%%lenient-parse&quot; would actually get treated as
1531         // rule text)
1532         if (lp == 0 || description.charAt(lp - 1) == gSemiColon) {
1533             // locate the beginning and end of the actual collation
1534             // rules (there may be whitespace between the name and
1535             // the first token in the description)
1536             int lpEnd = description.indexOf(gSemiPercent, 2, lp);
1537 
1538             if (lpEnd == -1) {
1539                 lpEnd = description.length() - 1;
1540             }
1541             int lpStart = lp + u_strlen(gLenientParse);
1542             while (PatternProps::isWhiteSpace(description.charAt(lpStart))) {
1543                 ++lpStart;
1544             }
1545 
1546             // copy out the lenient-parse rules and delete them
1547             // from the description
1548             lenientParseRules = new UnicodeString();
1549             /* test for NULL */
1550             if (lenientParseRules == 0) {
1551                 status = U_MEMORY_ALLOCATION_ERROR;
1552                 return;
1553             }
1554             lenientParseRules-&gt;setTo(description, lpStart, lpEnd - lpStart);
1555 
1556             description.remove(lp, lpEnd + 1 - lp);
1557         }
1558     }
1559 
1560     // pre-flight parsing the description and count the number of
1561     // rule sets (&quot;;%&quot; marks the end of one rule set and the beginning
1562     // of the next)
1563     numRuleSets = 0;
1564     for (int32_t p = description.indexOf(gSemiPercent, 2, 0); p != -1; p = description.indexOf(gSemiPercent, 2, p)) {
1565         ++numRuleSets;
1566         ++p;
1567     }
1568     ++numRuleSets;
1569 
1570     // our rule list is an array of the appropriate size
1571     ruleSets = (NFRuleSet **)uprv_malloc((numRuleSets + 1) * sizeof(NFRuleSet *));
1572     /* test for NULL */
1573     if (ruleSets == 0) {
1574         status = U_MEMORY_ALLOCATION_ERROR;
1575         return;
1576     }
1577 
1578     for (int i = 0; i &lt;= numRuleSets; ++i) {
1579         ruleSets[i] = NULL;
1580     }
1581 
1582     // divide up the descriptions into individual rule-set descriptions
1583     // and store them in a temporary array.  At each step, we also
1584     // new up a rule set, but all this does is initialize its name
1585     // and remove it from its description.  We can&#39;t actually parse
1586     // the rest of the descriptions and finish initializing everything
1587     // because we have to know the names and locations of all the rule
1588     // sets before we can actually set everything up
1589     if(!numRuleSets) {
1590         status = U_ILLEGAL_ARGUMENT_ERROR;
1591         return;
1592     }
1593 
1594     ruleSetDescriptions = new UnicodeString[numRuleSets];
1595     if (ruleSetDescriptions == 0) {
1596         status = U_MEMORY_ALLOCATION_ERROR;
1597         return;
1598     }
1599 
1600     {
1601         int curRuleSet = 0;
1602         int32_t start = 0;
1603         for (int32_t p = description.indexOf(gSemiPercent, 2, 0); p != -1; p = description.indexOf(gSemiPercent, 2, start)) {
1604             ruleSetDescriptions[curRuleSet].setTo(description, start, p + 1 - start);
1605             ruleSets[curRuleSet] = new NFRuleSet(this, ruleSetDescriptions, curRuleSet, status);
1606             if (ruleSets[curRuleSet] == 0) {
1607                 status = U_MEMORY_ALLOCATION_ERROR;
1608                 return;
1609             }
1610             ++curRuleSet;
1611             start = p + 1;
1612         }
1613         ruleSetDescriptions[curRuleSet].setTo(description, start, description.length() - start);
1614         ruleSets[curRuleSet] = new NFRuleSet(this, ruleSetDescriptions, curRuleSet, status);
1615         if (ruleSets[curRuleSet] == 0) {
1616             status = U_MEMORY_ALLOCATION_ERROR;
1617             return;
1618         }
1619     }
1620 
1621     // now we can take note of the formatter&#39;s default rule set, which
1622     // is the last public rule set in the description (it&#39;s the last
1623     // rather than the first so that a user can create a new formatter
1624     // from an existing formatter and change its default behavior just
1625     // by appending more rule sets to the end)
1626 
1627     // {dlf} Initialization of a fraction rule set requires the default rule
1628     // set to be known.  For purposes of initialization, this is always the
1629     // last public rule set, no matter what the localization data says.
1630     initDefaultRuleSet();
1631 
1632     // finally, we can go back through the temporary descriptions
1633     // list and finish seting up the substructure (and we throw
1634     // away the temporary descriptions as we go)
1635     {
1636         for (int i = 0; i &lt; numRuleSets; i++) {
1637             ruleSets[i]-&gt;parseRules(ruleSetDescriptions[i], status);
1638         }
1639     }
1640 
1641     // Now that the rules are initialized, the &#39;real&#39; default rule
1642     // set can be adjusted by the localization data.
1643 
1644     // The C code keeps the localization array as is, rather than building
1645     // a separate array of the public rule set names, so we have less work
1646     // to do here-- but we still need to check the names.
1647 
1648     if (localizationInfos) {
1649         // confirm the names, if any aren&#39;t in the rules, that&#39;s an error
1650         // it is ok if the rules contain public rule sets that are not in this list
1651         for (int32_t i = 0; i &lt; localizationInfos-&gt;getNumberOfRuleSets(); ++i) {
1652             UnicodeString name(TRUE, localizationInfos-&gt;getRuleSetName(i), -1);
1653             NFRuleSet* rs = findRuleSet(name, status);
1654             if (rs == NULL) {
1655                 break; // error
1656             }
1657             if (i == 0) {
1658                 defaultRuleSet = rs;
1659             }
1660         }
1661     } else {
1662         defaultRuleSet = getDefaultRuleSet();
1663     }
1664     originalDescription = rules;
1665 }
1666 
1667 // override the NumberFormat implementation in order to
1668 // lazily initialize relevant items
1669 void
1670 RuleBasedNumberFormat::setContext(UDisplayContext value, UErrorCode&amp; status)
1671 {
1672     NumberFormat::setContext(value, status);
1673     if (U_SUCCESS(status)) {
1674         if (!capitalizationInfoSet &amp;&amp;
1675                 (value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU || value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE)) {
1676             initCapitalizationContextInfo(locale);
1677             capitalizationInfoSet = TRUE;
1678         }
1679 #if !UCONFIG_NO_BREAK_ITERATION
1680         if ( capitalizationBrkIter == NULL &amp;&amp; (value==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
1681                 (value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU &amp;&amp; capitalizationForUIListMenu) ||
1682                 (value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE &amp;&amp; capitalizationForStandAlone)) ) {
1683             UErrorCode status = U_ZERO_ERROR;
1684             capitalizationBrkIter = BreakIterator::createSentenceInstance(locale, status);
1685             if (U_FAILURE(status)) {
1686                 delete capitalizationBrkIter;
1687                 capitalizationBrkIter = NULL;
1688             }
1689         }
1690 #endif
1691     }
1692 }
1693 
1694 void
1695 RuleBasedNumberFormat::initCapitalizationContextInfo(const Locale&amp; thelocale)
1696 {
1697 #if !UCONFIG_NO_BREAK_ITERATION
1698     const char * localeID = (thelocale != NULL)? thelocale.getBaseName(): NULL;
1699     UErrorCode status = U_ZERO_ERROR;
1700     UResourceBundle *rb = ures_open(NULL, localeID, &amp;status);
1701     rb = ures_getByKeyWithFallback(rb, &quot;contextTransforms&quot;, rb, &amp;status);
1702     rb = ures_getByKeyWithFallback(rb, &quot;number-spellout&quot;, rb, &amp;status);
1703     if (U_SUCCESS(status) &amp;&amp; rb != NULL) {
1704         int32_t len = 0;
1705         const int32_t * intVector = ures_getIntVector(rb, &amp;len, &amp;status);
1706         if (U_SUCCESS(status) &amp;&amp; intVector != NULL &amp;&amp; len &gt;= 2) {
1707             capitalizationForUIListMenu = intVector[0];
1708             capitalizationForStandAlone = intVector[1];
1709         }
1710     }
1711     ures_close(rb);
1712 #endif
1713 }
1714 
1715 void
1716 RuleBasedNumberFormat::stripWhitespace(UnicodeString&amp; description)
1717 {
1718     // iterate through the characters...
1719     UnicodeString result;
1720 
1721     int start = 0;
1722     while (start != -1 &amp;&amp; start &lt; description.length()) {
1723         // seek to the first non-whitespace character...
1724         while (start &lt; description.length()
1725             &amp;&amp; PatternProps::isWhiteSpace(description.charAt(start))) {
1726             ++start;
1727         }
1728 
1729         // locate the next semicolon in the text and copy the text from
1730         // our current position up to that semicolon into the result
1731         int32_t p = description.indexOf(gSemiColon, start);
1732         if (p == -1) {
1733             // or if we don&#39;t find a semicolon, just copy the rest of
1734             // the string into the result
1735             result.append(description, start, description.length() - start);
1736             start = -1;
1737         }
1738         else if (p &lt; description.length()) {
1739             result.append(description, start, p + 1 - start);
1740             start = p + 1;
1741         }
1742 
1743         // when we get here, we&#39;ve seeked off the end of the sring, and
1744         // we terminate the loop (we continue until *start* is -1 rather
1745         // than until *p* is -1, because otherwise we&#39;d miss the last
1746         // rule in the description)
1747         else {
1748             start = -1;
1749         }
1750     }
1751 
1752     description.setTo(result);
1753 }
1754 
1755 
1756 void
1757 RuleBasedNumberFormat::dispose()
1758 {
1759     if (ruleSets) {
1760         for (NFRuleSet** p = ruleSets; *p; ++p) {
1761             delete *p;
1762         }
1763         uprv_free(ruleSets);
1764         ruleSets = NULL;
1765     }
1766 
1767     if (ruleSetDescriptions) {
1768         delete [] ruleSetDescriptions;
1769         ruleSetDescriptions = NULL;
1770     }
1771 
1772 #if !UCONFIG_NO_COLLATION
1773     delete collator;
1774 #endif
1775     collator = NULL;
1776 
1777     delete decimalFormatSymbols;
1778     decimalFormatSymbols = NULL;
1779 
1780     delete defaultInfinityRule;
1781     defaultInfinityRule = NULL;
1782 
1783     delete defaultNaNRule;
1784     defaultNaNRule = NULL;
1785 
1786     delete lenientParseRules;
1787     lenientParseRules = NULL;
1788 
1789 #if !UCONFIG_NO_BREAK_ITERATION
1790     delete capitalizationBrkIter;
1791     capitalizationBrkIter = NULL;
1792 #endif
1793 
1794     if (localizations) {
1795         localizations = localizations-&gt;unref();
1796     }
1797 }
1798 
1799 
1800 //-----------------------------------------------------------------------
1801 // package-internal API
1802 //-----------------------------------------------------------------------
1803 
1804 /**
1805  * Returns the collator to use for lenient parsing.  The collator is lazily created:
1806  * this function creates it the first time it&#39;s called.
1807  * @return The collator to use for lenient parsing, or null if lenient parsing
1808  * is turned off.
1809 */
1810 const RuleBasedCollator*
1811 RuleBasedNumberFormat::getCollator() const
1812 {
1813 #if !UCONFIG_NO_COLLATION
1814     if (!ruleSets) {
1815         return NULL;
1816     }
1817 
1818     // lazy-evaluate the collator
1819     if (collator == NULL &amp;&amp; lenient) {
1820         // create a default collator based on the formatter&#39;s locale,
1821         // then pull out that collator&#39;s rules, append any additional
1822         // rules specified in the description, and create a _new_
1823         // collator based on the combinaiton of those rules
1824 
1825         UErrorCode status = U_ZERO_ERROR;
1826 
1827         Collator* temp = Collator::createInstance(locale, status);
1828         RuleBasedCollator* newCollator;
1829         if (U_SUCCESS(status) &amp;&amp; (newCollator = dynamic_cast&lt;RuleBasedCollator*&gt;(temp)) != NULL) {
1830             if (lenientParseRules) {
1831                 UnicodeString rules(newCollator-&gt;getRules());
1832                 rules.append(*lenientParseRules);
1833 
1834                 newCollator = new RuleBasedCollator(rules, status);
1835                 // Exit if newCollator could not be created.
1836                 if (newCollator == NULL) {
1837                     return NULL;
1838                 }
1839             } else {
1840                 temp = NULL;
1841             }
1842             if (U_SUCCESS(status)) {
1843                 newCollator-&gt;setAttribute(UCOL_DECOMPOSITION_MODE, UCOL_ON, status);
1844                 // cast away const
1845                 ((RuleBasedNumberFormat*)this)-&gt;collator = newCollator;
1846             } else {
1847                 delete newCollator;
1848             }
1849         }
1850         delete temp;
1851     }
1852 #endif
1853 
1854     // if lenient-parse mode is off, this will be null
1855     // (see setLenientParseMode())
1856     return collator;
1857 }
1858 
1859 
1860 DecimalFormatSymbols*
1861 RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &amp;status)
1862 {
1863     // lazy-evaluate the DecimalFormatSymbols object.  This object
1864     // is shared by all DecimalFormat instances belonging to this
1865     // formatter
1866     if (decimalFormatSymbols == NULL) {
1867         DecimalFormatSymbols* temp = new DecimalFormatSymbols(locale, status);
1868         if (U_SUCCESS(status)) {
1869             decimalFormatSymbols = temp;
1870         }
1871         else {
1872             delete temp;
1873         }
1874     }
1875     return decimalFormatSymbols;
1876 }
1877 
1878 /**
1879  * Returns the DecimalFormatSymbols object that should be used by all DecimalFormat
1880  * instances owned by this formatter.
1881 */
1882 const DecimalFormatSymbols*
1883 RuleBasedNumberFormat::getDecimalFormatSymbols() const
1884 {
1885     return decimalFormatSymbols;
1886 }
1887 
1888 NFRule*
1889 RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &amp;status)
1890 {
1891     if (U_FAILURE(status)) {
1892         return NULL;
1893     }
1894     if (defaultInfinityRule == NULL) {
1895         UnicodeString rule(UNICODE_STRING_SIMPLE(&quot;Inf: &quot;));
1896         rule.append(getDecimalFormatSymbols()-&gt;getSymbol(DecimalFormatSymbols::kInfinitySymbol));
1897         NFRule* temp = new NFRule(this, rule, status);
1898         if (U_SUCCESS(status)) {
1899             defaultInfinityRule = temp;
1900         }
1901         else {
1902             delete temp;
1903         }
1904     }
1905     return defaultInfinityRule;
1906 }
1907 
1908 const NFRule*
1909 RuleBasedNumberFormat::getDefaultInfinityRule() const
1910 {
1911     return defaultInfinityRule;
1912 }
1913 
1914 NFRule*
1915 RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode &amp;status)
1916 {
1917     if (U_FAILURE(status)) {
1918         return NULL;
1919     }
1920     if (defaultNaNRule == NULL) {
1921         UnicodeString rule(UNICODE_STRING_SIMPLE(&quot;NaN: &quot;));
1922         rule.append(getDecimalFormatSymbols()-&gt;getSymbol(DecimalFormatSymbols::kNaNSymbol));
1923         NFRule* temp = new NFRule(this, rule, status);
1924         if (U_SUCCESS(status)) {
1925             defaultNaNRule = temp;
1926         }
1927         else {
1928             delete temp;
1929         }
1930     }
1931     return defaultNaNRule;
1932 }
1933 
1934 const NFRule*
1935 RuleBasedNumberFormat::getDefaultNaNRule() const
1936 {
1937     return defaultNaNRule;
1938 }
1939 
1940 // De-owning the current localized symbols and adopt the new symbols.
1941 void
1942 RuleBasedNumberFormat::adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt)
1943 {
1944     if (symbolsToAdopt == NULL) {
1945         return; // do not allow caller to set decimalFormatSymbols to NULL
1946     }
1947 
1948     if (decimalFormatSymbols != NULL) {
1949         delete decimalFormatSymbols;
1950     }
1951 
1952     decimalFormatSymbols = symbolsToAdopt;
1953 
1954     {
1955         // Apply the new decimalFormatSymbols by reparsing the rulesets
1956         UErrorCode status = U_ZERO_ERROR;
1957 
1958         delete defaultInfinityRule;
1959         defaultInfinityRule = NULL;
1960         initializeDefaultInfinityRule(status); // Reset with the new DecimalFormatSymbols
1961 
1962         delete defaultNaNRule;
1963         defaultNaNRule = NULL;
1964         initializeDefaultNaNRule(status); // Reset with the new DecimalFormatSymbols
1965 
1966         if (ruleSets) {
1967             for (int32_t i = 0; i &lt; numRuleSets; i++) {
1968                 ruleSets[i]-&gt;setDecimalFormatSymbols(*symbolsToAdopt, status);
1969             }
1970         }
1971     }
1972 }
1973 
1974 // Setting the symbols is equlivalent to adopting a newly created localized symbols.
1975 void
1976 RuleBasedNumberFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols)
1977 {
1978     adoptDecimalFormatSymbols(new DecimalFormatSymbols(symbols));
1979 }
1980 
1981 PluralFormat *
1982 RuleBasedNumberFormat::createPluralFormat(UPluralType pluralType,
1983                                           const UnicodeString &amp;pattern,
1984                                           UErrorCode&amp; status) const
1985 {
1986     return new PluralFormat(locale, pluralType, pattern, status);
1987 }
1988 
1989 /**
1990  * Get the rounding mode.
1991  * @return A rounding mode
1992  */
1993 DecimalFormat::ERoundingMode RuleBasedNumberFormat::getRoundingMode() const {
1994     return roundingMode;
1995 }
1996 
1997 /**
1998  * Set the rounding mode.  This has no effect unless the rounding
1999  * increment is greater than zero.
2000  * @param roundingMode A rounding mode
2001  */
2002 void RuleBasedNumberFormat::setRoundingMode(DecimalFormat::ERoundingMode roundingMode) {
2003     this-&gt;roundingMode = roundingMode;
2004 }
2005 
2006 U_NAMESPACE_END
2007 
2008 /* U_HAVE_RBNF */
2009 #endif
    </pre>
  </body>
</html>