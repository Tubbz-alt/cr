<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rbnf.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="quantityformatter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbt.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rbnf.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 663     if (index &gt;= 0 &amp;&amp; index &lt; getNumberOfDisplayLocales()) {
 664         return data[index+1][0];
 665     }
 666     return NULL;
 667 }
 668 
 669 const UChar*
 670 StringLocalizationInfo::getDisplayName(int32_t localeIndex, int32_t ruleIndex) const {
 671     if (localeIndex &gt;= 0 &amp;&amp; localeIndex &lt; getNumberOfDisplayLocales() &amp;&amp;
 672         ruleIndex &gt;= 0 &amp;&amp; ruleIndex &lt; getNumberOfRuleSets()) {
 673         return data[localeIndex+1][ruleIndex+1];
 674     }
 675     return NULL;
 676 }
 677 
 678 // ----------
 679 
 680 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 681                                              const UnicodeString&amp; locs,
 682                                              const Locale&amp; alocale, UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified"> 683   : ruleSets(NULL)</span>
 684   , ruleSetDescriptions(NULL)
 685   , numRuleSets(0)
 686   , defaultRuleSet(NULL)
 687   , locale(alocale)
 688   , collator(NULL)
 689   , decimalFormatSymbols(NULL)
 690   , defaultInfinityRule(NULL)
 691   , defaultNaNRule(NULL)
<span class="line-modified"> 692   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 693   , lenient(FALSE)
 694   , lenientParseRules(NULL)
 695   , localizations(NULL)
 696   , capitalizationInfoSet(FALSE)
 697   , capitalizationForUIListMenu(FALSE)
 698   , capitalizationForStandAlone(FALSE)
 699   , capitalizationBrkIter(NULL)
 700 {
 701   LocalizationInfo* locinfo = StringLocalizationInfo::create(locs, perror, status);
 702   init(description, locinfo, perror, status);
 703 }
 704 
 705 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 706                                              const UnicodeString&amp; locs,
 707                                              UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified"> 708   : ruleSets(NULL)</span>
 709   , ruleSetDescriptions(NULL)
 710   , numRuleSets(0)
 711   , defaultRuleSet(NULL)
 712   , locale(Locale::getDefault())
 713   , collator(NULL)
 714   , decimalFormatSymbols(NULL)
 715   , defaultInfinityRule(NULL)
 716   , defaultNaNRule(NULL)
<span class="line-modified"> 717   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 718   , lenient(FALSE)
 719   , lenientParseRules(NULL)
 720   , localizations(NULL)
 721   , capitalizationInfoSet(FALSE)
 722   , capitalizationForUIListMenu(FALSE)
 723   , capitalizationForStandAlone(FALSE)
 724   , capitalizationBrkIter(NULL)
 725 {
 726   LocalizationInfo* locinfo = StringLocalizationInfo::create(locs, perror, status);
 727   init(description, locinfo, perror, status);
 728 }
 729 
 730 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 731                                              LocalizationInfo* info,
 732                                              const Locale&amp; alocale, UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified"> 733   : ruleSets(NULL)</span>
 734   , ruleSetDescriptions(NULL)
 735   , numRuleSets(0)
 736   , defaultRuleSet(NULL)
 737   , locale(alocale)
 738   , collator(NULL)
 739   , decimalFormatSymbols(NULL)
 740   , defaultInfinityRule(NULL)
 741   , defaultNaNRule(NULL)
<span class="line-modified"> 742   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 743   , lenient(FALSE)
 744   , lenientParseRules(NULL)
 745   , localizations(NULL)
 746   , capitalizationInfoSet(FALSE)
 747   , capitalizationForUIListMenu(FALSE)
 748   , capitalizationForStandAlone(FALSE)
 749   , capitalizationBrkIter(NULL)
 750 {
 751   init(description, info, perror, status);
 752 }
 753 
 754 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 755                          UParseError&amp; perror,
 756                          UErrorCode&amp; status)
<span class="line-modified"> 757   : ruleSets(NULL)</span>
 758   , ruleSetDescriptions(NULL)
 759   , numRuleSets(0)
 760   , defaultRuleSet(NULL)
 761   , locale(Locale::getDefault())
 762   , collator(NULL)
 763   , decimalFormatSymbols(NULL)
 764   , defaultInfinityRule(NULL)
 765   , defaultNaNRule(NULL)
<span class="line-modified"> 766   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 767   , lenient(FALSE)
 768   , lenientParseRules(NULL)
 769   , localizations(NULL)
 770   , capitalizationInfoSet(FALSE)
 771   , capitalizationForUIListMenu(FALSE)
 772   , capitalizationForStandAlone(FALSE)
 773   , capitalizationBrkIter(NULL)
 774 {
 775     init(description, NULL, perror, status);
 776 }
 777 
 778 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 779                          const Locale&amp; aLocale,
 780                          UParseError&amp; perror,
 781                          UErrorCode&amp; status)
<span class="line-modified"> 782   : ruleSets(NULL)</span>
 783   , ruleSetDescriptions(NULL)
 784   , numRuleSets(0)
 785   , defaultRuleSet(NULL)
 786   , locale(aLocale)
 787   , collator(NULL)
 788   , decimalFormatSymbols(NULL)
 789   , defaultInfinityRule(NULL)
 790   , defaultNaNRule(NULL)
<span class="line-modified"> 791   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 792   , lenient(FALSE)
 793   , lenientParseRules(NULL)
 794   , localizations(NULL)
 795   , capitalizationInfoSet(FALSE)
 796   , capitalizationForUIListMenu(FALSE)
 797   , capitalizationForStandAlone(FALSE)
 798   , capitalizationBrkIter(NULL)
 799 {
 800     init(description, NULL, perror, status);
 801 }
 802 
 803 RuleBasedNumberFormat::RuleBasedNumberFormat(URBNFRuleSetTag tag, const Locale&amp; alocale, UErrorCode&amp; status)
<span class="line-modified"> 804   : ruleSets(NULL)</span>
 805   , ruleSetDescriptions(NULL)
 806   , numRuleSets(0)
 807   , defaultRuleSet(NULL)
 808   , locale(alocale)
 809   , collator(NULL)
 810   , decimalFormatSymbols(NULL)
 811   , defaultInfinityRule(NULL)
 812   , defaultNaNRule(NULL)
<span class="line-modified"> 813   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 814   , lenient(FALSE)
 815   , lenientParseRules(NULL)
 816   , localizations(NULL)
 817   , capitalizationInfoSet(FALSE)
 818   , capitalizationForUIListMenu(FALSE)
 819   , capitalizationForStandAlone(FALSE)
 820   , capitalizationBrkIter(NULL)
 821 {
 822     if (U_FAILURE(status)) {
 823         return;
 824     }
 825 
 826     const char* rules_tag = &quot;RBNFRules&quot;;
 827     const char* fmt_tag = &quot;&quot;;
 828     switch (tag) {
 829     case URBNF_SPELLOUT: fmt_tag = &quot;SpelloutRules&quot;; break;
 830     case URBNF_ORDINAL: fmt_tag = &quot;OrdinalRules&quot;; break;
 831     case URBNF_DURATION: fmt_tag = &quot;DurationRules&quot;; break;
 832     case URBNF_NUMBERING_SYSTEM: fmt_tag = &quot;NumberingSystemRules&quot;; break;
 833     default: status = U_ILLEGAL_ARGUMENT_ERROR; return;
</pre>
<hr />
<pre>
 851             ures_close(nfrb);
 852             return;
 853         }
 854 
 855         UnicodeString desc;
 856         while (ures_hasNext(ruleSets)) {
 857            desc.append(ures_getNextUnicodeString(ruleSets,NULL,&amp;status));
 858         }
 859         UParseError perror;
 860 
 861         init(desc, locinfo, perror, status);
 862 
 863         ures_close(ruleSets);
 864         ures_close(rbnfRules);
 865     }
 866     ures_close(nfrb);
 867 }
 868 
 869 RuleBasedNumberFormat::RuleBasedNumberFormat(const RuleBasedNumberFormat&amp; rhs)
 870   : NumberFormat(rhs)
<span class="line-modified"> 871   , ruleSets(NULL)</span>
 872   , ruleSetDescriptions(NULL)
 873   , numRuleSets(0)
 874   , defaultRuleSet(NULL)
 875   , locale(rhs.locale)
 876   , collator(NULL)
 877   , decimalFormatSymbols(NULL)
 878   , defaultInfinityRule(NULL)
 879   , defaultNaNRule(NULL)
<span class="line-modified"> 880   , roundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 881   , lenient(FALSE)
 882   , lenientParseRules(NULL)
 883   , localizations(NULL)
 884   , capitalizationInfoSet(FALSE)
 885   , capitalizationForUIListMenu(FALSE)
 886   , capitalizationForStandAlone(FALSE)
 887   , capitalizationBrkIter(NULL)
 888 {
 889     this-&gt;operator=(rhs);
 890 }
 891 
 892 // --------
 893 
 894 RuleBasedNumberFormat&amp;
 895 RuleBasedNumberFormat::operator=(const RuleBasedNumberFormat&amp; rhs)
 896 {
 897     if (this == &amp;rhs) {
 898         return *this;
 899     }
 900     NumberFormat::operator=(rhs);
</pre>
<hr />
<pre>
 933 UBool
 934 RuleBasedNumberFormat::operator==(const Format&amp; other) const
 935 {
 936     if (this == &amp;other) {
 937         return TRUE;
 938     }
 939 
 940     if (typeid(*this) == typeid(other)) {
 941         const RuleBasedNumberFormat&amp; rhs = (const RuleBasedNumberFormat&amp;)other;
 942         // test for capitalization info equality is adequately handled
 943         // by the NumberFormat test for fCapitalizationContext equality;
 944         // the info here is just derived from that.
 945         if (locale == rhs.locale &amp;&amp;
 946             lenient == rhs.lenient &amp;&amp;
 947             (localizations == NULL
 948                 ? rhs.localizations == NULL
 949                 : (rhs.localizations == NULL
 950                     ? FALSE
 951                     : *localizations == rhs.localizations))) {
 952 
<span class="line-modified"> 953             NFRuleSet** p = ruleSets;</span>
<span class="line-modified"> 954             NFRuleSet** q = rhs.ruleSets;</span>
 955             if (p == NULL) {
 956                 return q == NULL;
 957             } else if (q == NULL) {
 958                 return FALSE;
 959             }
 960             while (*p &amp;&amp; *q &amp;&amp; (**p == **q)) {
 961                 ++p;
 962                 ++q;
 963             }
 964             return *q == NULL &amp;&amp; *p == NULL;
 965         }
 966     }
 967 
 968     return FALSE;
 969 }
 970 
 971 UnicodeString
 972 RuleBasedNumberFormat::getRules() const
 973 {
 974     UnicodeString result;
<span class="line-modified"> 975     if (ruleSets != NULL) {</span>
<span class="line-modified"> 976         for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
 977             (*p)-&gt;appendRules(result);
 978         }
 979     }
 980     return result;
 981 }
 982 
 983 UnicodeString
 984 RuleBasedNumberFormat::getRuleSetName(int32_t index) const
 985 {
 986     if (localizations) {
 987         UnicodeString string(TRUE, localizations-&gt;getRuleSetName(index), (int32_t)-1);
 988         return string;
 989     }
<span class="line-modified"> 990     else if (ruleSets) {</span>
 991         UnicodeString result;
<span class="line-modified"> 992         for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
 993             NFRuleSet* rs = *p;
 994             if (rs-&gt;isPublic()) {
 995                 if (--index == -1) {
 996                     rs-&gt;getName(result);
 997                     return result;
 998                 }
 999             }
1000         }
1001     }
1002     UnicodeString empty;
1003     return empty;
1004 }
1005 
1006 int32_t
1007 RuleBasedNumberFormat::getNumberOfRuleSetNames() const
1008 {
1009     int32_t result = 0;
1010     if (localizations) {
1011         result = localizations-&gt;getNumberOfRuleSets();
1012     }
<span class="line-modified">1013     else if (ruleSets) {</span>
<span class="line-modified">1014         for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
1015             if ((**p).isPublic()) {
1016                 ++result;
1017             }
1018         }
1019     }
1020     return result;
1021 }
1022 
1023 int32_t
1024 RuleBasedNumberFormat::getNumberOfRuleSetDisplayNameLocales(void) const {
1025     if (localizations) {
1026         return localizations-&gt;getNumberOfDisplayLocales();
1027     }
1028     return 0;
1029 }
1030 
1031 Locale
1032 RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int32_t index, UErrorCode&amp; status) const {
1033     if (U_FAILURE(status)) {
1034         return Locale(&quot;&quot;);
</pre>
<hr />
<pre>
1081     UnicodeString bogus;
1082     bogus.setToBogus();
1083     return bogus;
1084 }
1085 
1086 UnicodeString
1087 RuleBasedNumberFormat::getRuleSetDisplayName(const UnicodeString&amp; ruleSetName, const Locale&amp; localeParam) {
1088     if (localizations) {
1089         UnicodeString rsn(ruleSetName);
1090         int32_t ix = localizations-&gt;indexForRuleSet(rsn.getTerminatedBuffer());
1091         return getRuleSetDisplayName(ix, localeParam);
1092     }
1093     UnicodeString bogus;
1094     bogus.setToBogus();
1095     return bogus;
1096 }
1097 
1098 NFRuleSet*
1099 RuleBasedNumberFormat::findRuleSet(const UnicodeString&amp; name, UErrorCode&amp; status) const
1100 {
<span class="line-modified">1101     if (U_SUCCESS(status) &amp;&amp; ruleSets) {</span>
<span class="line-modified">1102         for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
1103             NFRuleSet* rs = *p;
1104             if (rs-&gt;isNamed(name)) {
1105                 return rs;
1106             }
1107         }
1108         status = U_ILLEGAL_ARGUMENT_ERROR;
1109     }
1110     return NULL;
1111 }
1112 
1113 UnicodeString&amp;
1114 RuleBasedNumberFormat::format(const DecimalQuantity &amp;number,
1115                       UnicodeString &amp;appendTo,
1116                       FieldPositionIterator *posIter,
1117                       UErrorCode &amp;status) const {
1118     if (U_FAILURE(status)) {
1119         return appendTo;
1120     }
1121     DecimalQuantity copy(number);
1122     if (copy.fitsInLong()) {
1123         format(number.toLong(), appendTo, posIter, status);
1124     }
1125     else {
1126         copy.roundToMagnitude(0, number::impl::RoundingMode::UNUM_ROUND_HALFEVEN, status);
1127         if (copy.fitsInLong()) {
1128             format(number.toDouble(), appendTo, posIter, status);
1129         }
1130         else {
1131             // We&#39;re outside of our normal range that this framework can handle.
1132             // The DecimalFormat will provide more accurate results.
1133 
1134             // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
<span class="line-modified">1135             NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);</span>



1136             Formattable f;
<span class="line-modified">1137             f.adoptDecimalQuantity(new DecimalQuantity(number));</span>




1138             decimalFormat-&gt;format(f, appendTo, posIter, status);
<span class="line-removed">1139             delete decimalFormat;</span>
1140         }
1141     }
1142     return appendTo;
1143 }
1144 
1145 
1146 UnicodeString&amp;
1147 RuleBasedNumberFormat::format(const DecimalQuantity &amp;number,
1148                      UnicodeString&amp; appendTo,
1149                      FieldPosition&amp; pos,
1150                      UErrorCode &amp;status) const {
1151     if (U_FAILURE(status)) {
1152         return appendTo;
1153     }
1154     DecimalQuantity copy(number);
1155     if (copy.fitsInLong()) {
1156         format(number.toLong(), appendTo, pos, status);
1157     }
1158     else {
1159         copy.roundToMagnitude(0, number::impl::RoundingMode::UNUM_ROUND_HALFEVEN, status);
1160         if (copy.fitsInLong()) {
1161             format(number.toDouble(), appendTo, pos, status);
1162         }
1163         else {
1164             // We&#39;re outside of our normal range that this framework can handle.
1165             // The DecimalFormat will provide more accurate results.
1166 
1167             // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
<span class="line-modified">1168             NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);</span>



1169             Formattable f;
<span class="line-modified">1170             f.adoptDecimalQuantity(new DecimalQuantity(number));</span>




1171             decimalFormat-&gt;format(f, appendTo, pos, status);
<span class="line-removed">1172             delete decimalFormat;</span>
1173         }
1174     }
1175     return appendTo;
1176 }
1177 
1178 UnicodeString&amp;
1179 RuleBasedNumberFormat::format(int32_t number,
1180                               UnicodeString&amp; toAppendTo,
1181                               FieldPosition&amp; pos) const
1182 {
1183     return format((int64_t)number, toAppendTo, pos);
1184 }
1185 
1186 
1187 UnicodeString&amp;
1188 RuleBasedNumberFormat::format(int64_t number,
1189                               UnicodeString&amp; toAppendTo,
1190                               FieldPosition&amp; /* pos */) const
1191 {
1192     if (defaultRuleSet) {
</pre>
<hr />
<pre>
1295 UnicodeString&amp;
1296 RuleBasedNumberFormat::format(int64_t number, NFRuleSet *ruleSet, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const
1297 {
1298     // all API format() routines that take a double vector through
1299     // here.  We have these two identical functions-- one taking a
1300     // double and one taking a long-- the couple digits of precision
1301     // that long has but double doesn&#39;t (both types are 8 bytes long,
1302     // but double has to borrow some of the mantissa bits to hold
1303     // the exponent).
1304     // Create an empty string buffer where the result will
1305     // be built, and pass it to the rule set (along with an insertion
1306     // position of 0 and the number being formatted) to the rule set
1307     // for formatting
1308 
1309     if (U_SUCCESS(status)) {
1310         if (number == U_INT64_MIN) {
1311             // We can&#39;t handle this value right now. Provide an accurate default value.
1312 
1313             // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
1314             NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);



1315             Formattable f;
1316             FieldPosition pos(FieldPosition::DONT_CARE);
<span class="line-modified">1317             DecimalQuantity *digitList = new DecimalQuantity();</span>
<span class="line-modified">1318             digitList-&gt;setToLong(number);</span>
<span class="line-modified">1319             f.adoptDecimalQuantity(digitList);</span>





1320             decimalFormat-&gt;format(f, toAppendTo, pos, status);
1321             delete decimalFormat;
1322         }
1323         else {
1324             int32_t startPos = toAppendTo.length();
1325             ruleSet-&gt;format(number, toAppendTo, toAppendTo.length(), 0, status);
1326             adjustForCapitalizationContext(startPos, toAppendTo, status);
1327         }
1328     }
1329     return toAppendTo;
1330 }
1331 
1332 UnicodeString&amp;
1333 RuleBasedNumberFormat::adjustForCapitalizationContext(int32_t startPos,
1334                                                       UnicodeString&amp; currentResult,
1335                                                       UErrorCode&amp; status) const
1336 {
1337 #if !UCONFIG_NO_BREAK_ITERATION
1338     UDisplayContext capitalizationContext = getContext(UDISPCTX_TYPE_CAPITALIZATION, status);
1339     if (capitalizationContext != UDISPCTX_CAPITALIZATION_NONE &amp;&amp; startPos == 0 &amp;&amp; currentResult.length() &gt; 0) {
</pre>
<hr />
<pre>
1341         UChar32 ch = currentResult.char32At(0);
1342         if (u_islower(ch) &amp;&amp; U_SUCCESS(status) &amp;&amp; capitalizationBrkIter != NULL &amp;&amp;
1343               ( capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
1344                 (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU &amp;&amp; capitalizationForUIListMenu) ||
1345                 (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_STANDALONE &amp;&amp; capitalizationForStandAlone)) ) {
1346             // titlecase first word of currentResult, here use sentence iterator unlike current implementations
1347             // in LocaleDisplayNamesImpl::adjustForUsageAndContext and RelativeDateFormat::format
1348             currentResult.toTitle(capitalizationBrkIter, locale, U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
1349         }
1350     }
1351 #endif
1352     return currentResult;
1353 }
1354 
1355 
1356 void
1357 RuleBasedNumberFormat::parse(const UnicodeString&amp; text,
1358                              Formattable&amp; result,
1359                              ParsePosition&amp; parsePosition) const
1360 {
<span class="line-modified">1361     if (!ruleSets) {</span>
1362         parsePosition.setErrorIndex(0);
1363         return;
1364     }
1365 
1366     UnicodeString workingText(text, parsePosition.getIndex());
1367     ParsePosition workingPos(0);
1368 
1369     ParsePosition high_pp(0);
1370     Formattable high_result;
1371 
<span class="line-modified">1372     for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
1373         NFRuleSet *rp = *p;
1374         if (rp-&gt;isPublic() &amp;&amp; rp-&gt;isParseable()) {
1375             ParsePosition working_pp(0);
1376             Formattable working_result;
1377 
1378             rp-&gt;parse(workingText, working_pp, kMaxDouble, 0, working_result);
1379             if (working_pp.getIndex() &gt; high_pp.getIndex()) {
1380                 high_pp = working_pp;
1381                 high_result = working_result;
1382 
1383                 if (high_pp.getIndex() == workingText.length()) {
1384                     break;
1385                 }
1386             }
1387         }
1388     }
1389 
1390     int32_t startIndex = parsePosition.getIndex();
1391     parsePosition.setIndex(startIndex + high_pp.getIndex());
1392     if (high_pp.getIndex() &gt; 0) {
</pre>
<hr />
<pre>
1440             }
1441         }
1442     }
1443 }
1444 
1445 UnicodeString
1446 RuleBasedNumberFormat::getDefaultRuleSetName() const {
1447     UnicodeString result;
1448     if (defaultRuleSet &amp;&amp; defaultRuleSet-&gt;isPublic()) {
1449         defaultRuleSet-&gt;getName(result);
1450     } else {
1451         result.setToBogus();
1452     }
1453     return result;
1454 }
1455 
1456 void
1457 RuleBasedNumberFormat::initDefaultRuleSet()
1458 {
1459     defaultRuleSet = NULL;
<span class="line-modified">1460     if (!ruleSets) {</span>
1461         return;
1462     }
1463 
1464     const UnicodeString spellout(UNICODE_STRING_SIMPLE(&quot;%spellout-numbering&quot;));
1465     const UnicodeString ordinal(UNICODE_STRING_SIMPLE(&quot;%digits-ordinal&quot;));
1466     const UnicodeString duration(UNICODE_STRING_SIMPLE(&quot;%duration&quot;));
1467 
<span class="line-modified">1468     NFRuleSet**p = &amp;ruleSets[0];</span>
1469     while (*p) {
1470         if ((*p)-&gt;isNamed(spellout) || (*p)-&gt;isNamed(ordinal) || (*p)-&gt;isNamed(duration)) {
1471             defaultRuleSet = *p;
1472             return;
1473         } else {
1474             ++p;
1475         }
1476     }
1477 
1478     defaultRuleSet = *--p;
1479     if (!defaultRuleSet-&gt;isPublic()) {
<span class="line-modified">1480         while (p != ruleSets) {</span>
1481             if ((*--p)-&gt;isPublic()) {
1482                 defaultRuleSet = *p;
1483                 break;
1484             }
1485         }
1486     }
1487 }
1488 
1489 
1490 void
1491 RuleBasedNumberFormat::init(const UnicodeString&amp; rules, LocalizationInfo* localizationInfos,
1492                             UParseError&amp; pErr, UErrorCode&amp; status)
1493 {
1494     // TODO: implement UParseError
1495     uprv_memset(&amp;pErr, 0, sizeof(UParseError));
1496     // Note: this can leave ruleSets == NULL, so remaining code should check
1497     if (U_FAILURE(status)) {
1498         return;
1499     }
1500 
</pre>
<hr />
<pre>
1530         // (where &quot;%%lenient-parse&quot; would actually get treated as
1531         // rule text)
1532         if (lp == 0 || description.charAt(lp - 1) == gSemiColon) {
1533             // locate the beginning and end of the actual collation
1534             // rules (there may be whitespace between the name and
1535             // the first token in the description)
1536             int lpEnd = description.indexOf(gSemiPercent, 2, lp);
1537 
1538             if (lpEnd == -1) {
1539                 lpEnd = description.length() - 1;
1540             }
1541             int lpStart = lp + u_strlen(gLenientParse);
1542             while (PatternProps::isWhiteSpace(description.charAt(lpStart))) {
1543                 ++lpStart;
1544             }
1545 
1546             // copy out the lenient-parse rules and delete them
1547             // from the description
1548             lenientParseRules = new UnicodeString();
1549             /* test for NULL */
<span class="line-modified">1550             if (lenientParseRules == 0) {</span>
1551                 status = U_MEMORY_ALLOCATION_ERROR;
1552                 return;
1553             }
1554             lenientParseRules-&gt;setTo(description, lpStart, lpEnd - lpStart);
1555 
1556             description.remove(lp, lpEnd + 1 - lp);
1557         }
1558     }
1559 
1560     // pre-flight parsing the description and count the number of
1561     // rule sets (&quot;;%&quot; marks the end of one rule set and the beginning
1562     // of the next)
1563     numRuleSets = 0;
1564     for (int32_t p = description.indexOf(gSemiPercent, 2, 0); p != -1; p = description.indexOf(gSemiPercent, 2, p)) {
1565         ++numRuleSets;
1566         ++p;
1567     }
1568     ++numRuleSets;
1569 
1570     // our rule list is an array of the appropriate size
<span class="line-modified">1571     ruleSets = (NFRuleSet **)uprv_malloc((numRuleSets + 1) * sizeof(NFRuleSet *));</span>
1572     /* test for NULL */
<span class="line-modified">1573     if (ruleSets == 0) {</span>
1574         status = U_MEMORY_ALLOCATION_ERROR;
1575         return;
1576     }
1577 
1578     for (int i = 0; i &lt;= numRuleSets; ++i) {
<span class="line-modified">1579         ruleSets[i] = NULL;</span>
1580     }
1581 
1582     // divide up the descriptions into individual rule-set descriptions
1583     // and store them in a temporary array.  At each step, we also
1584     // new up a rule set, but all this does is initialize its name
1585     // and remove it from its description.  We can&#39;t actually parse
1586     // the rest of the descriptions and finish initializing everything
1587     // because we have to know the names and locations of all the rule
1588     // sets before we can actually set everything up
1589     if(!numRuleSets) {
1590         status = U_ILLEGAL_ARGUMENT_ERROR;
1591         return;
1592     }
1593 
1594     ruleSetDescriptions = new UnicodeString[numRuleSets];
<span class="line-modified">1595     if (ruleSetDescriptions == 0) {</span>
1596         status = U_MEMORY_ALLOCATION_ERROR;
1597         return;
1598     }
1599 
1600     {
1601         int curRuleSet = 0;
1602         int32_t start = 0;
1603         for (int32_t p = description.indexOf(gSemiPercent, 2, 0); p != -1; p = description.indexOf(gSemiPercent, 2, start)) {
1604             ruleSetDescriptions[curRuleSet].setTo(description, start, p + 1 - start);
<span class="line-modified">1605             ruleSets[curRuleSet] = new NFRuleSet(this, ruleSetDescriptions, curRuleSet, status);</span>
<span class="line-modified">1606             if (ruleSets[curRuleSet] == 0) {</span>
1607                 status = U_MEMORY_ALLOCATION_ERROR;
1608                 return;
1609             }
1610             ++curRuleSet;
1611             start = p + 1;
1612         }
1613         ruleSetDescriptions[curRuleSet].setTo(description, start, description.length() - start);
<span class="line-modified">1614         ruleSets[curRuleSet] = new NFRuleSet(this, ruleSetDescriptions, curRuleSet, status);</span>
<span class="line-modified">1615         if (ruleSets[curRuleSet] == 0) {</span>
1616             status = U_MEMORY_ALLOCATION_ERROR;
1617             return;
1618         }
1619     }
1620 
1621     // now we can take note of the formatter&#39;s default rule set, which
1622     // is the last public rule set in the description (it&#39;s the last
1623     // rather than the first so that a user can create a new formatter
1624     // from an existing formatter and change its default behavior just
1625     // by appending more rule sets to the end)
1626 
1627     // {dlf} Initialization of a fraction rule set requires the default rule
1628     // set to be known.  For purposes of initialization, this is always the
1629     // last public rule set, no matter what the localization data says.
1630     initDefaultRuleSet();
1631 
1632     // finally, we can go back through the temporary descriptions
<span class="line-modified">1633     // list and finish seting up the substructure (and we throw</span>
1634     // away the temporary descriptions as we go)
1635     {
1636         for (int i = 0; i &lt; numRuleSets; i++) {
<span class="line-modified">1637             ruleSets[i]-&gt;parseRules(ruleSetDescriptions[i], status);</span>
1638         }
1639     }
1640 
1641     // Now that the rules are initialized, the &#39;real&#39; default rule
1642     // set can be adjusted by the localization data.
1643 
1644     // The C code keeps the localization array as is, rather than building
1645     // a separate array of the public rule set names, so we have less work
1646     // to do here-- but we still need to check the names.
1647 
1648     if (localizationInfos) {
1649         // confirm the names, if any aren&#39;t in the rules, that&#39;s an error
1650         // it is ok if the rules contain public rule sets that are not in this list
1651         for (int32_t i = 0; i &lt; localizationInfos-&gt;getNumberOfRuleSets(); ++i) {
1652             UnicodeString name(TRUE, localizationInfos-&gt;getRuleSetName(i), -1);
1653             NFRuleSet* rs = findRuleSet(name, status);
1654             if (rs == NULL) {
1655                 break; // error
1656             }
1657             if (i == 0) {
</pre>
<hr />
<pre>
1663     }
1664     originalDescription = rules;
1665 }
1666 
1667 // override the NumberFormat implementation in order to
1668 // lazily initialize relevant items
1669 void
1670 RuleBasedNumberFormat::setContext(UDisplayContext value, UErrorCode&amp; status)
1671 {
1672     NumberFormat::setContext(value, status);
1673     if (U_SUCCESS(status)) {
1674         if (!capitalizationInfoSet &amp;&amp;
1675                 (value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU || value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE)) {
1676             initCapitalizationContextInfo(locale);
1677             capitalizationInfoSet = TRUE;
1678         }
1679 #if !UCONFIG_NO_BREAK_ITERATION
1680         if ( capitalizationBrkIter == NULL &amp;&amp; (value==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
1681                 (value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU &amp;&amp; capitalizationForUIListMenu) ||
1682                 (value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE &amp;&amp; capitalizationForStandAlone)) ) {
<span class="line-modified">1683             UErrorCode status = U_ZERO_ERROR;</span>
1684             capitalizationBrkIter = BreakIterator::createSentenceInstance(locale, status);
1685             if (U_FAILURE(status)) {
1686                 delete capitalizationBrkIter;
1687                 capitalizationBrkIter = NULL;
1688             }
1689         }
1690 #endif
1691     }
1692 }
1693 
1694 void
1695 RuleBasedNumberFormat::initCapitalizationContextInfo(const Locale&amp; thelocale)
1696 {
1697 #if !UCONFIG_NO_BREAK_ITERATION
1698     const char * localeID = (thelocale != NULL)? thelocale.getBaseName(): NULL;
1699     UErrorCode status = U_ZERO_ERROR;
1700     UResourceBundle *rb = ures_open(NULL, localeID, &amp;status);
1701     rb = ures_getByKeyWithFallback(rb, &quot;contextTransforms&quot;, rb, &amp;status);
1702     rb = ures_getByKeyWithFallback(rb, &quot;number-spellout&quot;, rb, &amp;status);
1703     if (U_SUCCESS(status) &amp;&amp; rb != NULL) {
1704         int32_t len = 0;
1705         const int32_t * intVector = ures_getIntVector(rb, &amp;len, &amp;status);
1706         if (U_SUCCESS(status) &amp;&amp; intVector != NULL &amp;&amp; len &gt;= 2) {
<span class="line-modified">1707             capitalizationForUIListMenu = intVector[0];</span>
<span class="line-modified">1708             capitalizationForStandAlone = intVector[1];</span>
1709         }
1710     }
1711     ures_close(rb);
1712 #endif
1713 }
1714 
1715 void
1716 RuleBasedNumberFormat::stripWhitespace(UnicodeString&amp; description)
1717 {
1718     // iterate through the characters...
1719     UnicodeString result;
1720 
1721     int start = 0;
1722     while (start != -1 &amp;&amp; start &lt; description.length()) {
1723         // seek to the first non-whitespace character...
1724         while (start &lt; description.length()
1725             &amp;&amp; PatternProps::isWhiteSpace(description.charAt(start))) {
1726             ++start;
1727         }
1728 
1729         // locate the next semicolon in the text and copy the text from
1730         // our current position up to that semicolon into the result
1731         int32_t p = description.indexOf(gSemiColon, start);
1732         if (p == -1) {
1733             // or if we don&#39;t find a semicolon, just copy the rest of
1734             // the string into the result
1735             result.append(description, start, description.length() - start);
1736             start = -1;
1737         }
1738         else if (p &lt; description.length()) {
1739             result.append(description, start, p + 1 - start);
1740             start = p + 1;
1741         }
1742 
<span class="line-modified">1743         // when we get here, we&#39;ve seeked off the end of the sring, and</span>
1744         // we terminate the loop (we continue until *start* is -1 rather
1745         // than until *p* is -1, because otherwise we&#39;d miss the last
1746         // rule in the description)
1747         else {
1748             start = -1;
1749         }
1750     }
1751 
1752     description.setTo(result);
1753 }
1754 
1755 
1756 void
1757 RuleBasedNumberFormat::dispose()
1758 {
<span class="line-modified">1759     if (ruleSets) {</span>
<span class="line-modified">1760         for (NFRuleSet** p = ruleSets; *p; ++p) {</span>
1761             delete *p;
1762         }
<span class="line-modified">1763         uprv_free(ruleSets);</span>
<span class="line-modified">1764         ruleSets = NULL;</span>
1765     }
1766 
1767     if (ruleSetDescriptions) {
1768         delete [] ruleSetDescriptions;
1769         ruleSetDescriptions = NULL;
1770     }
1771 
1772 #if !UCONFIG_NO_COLLATION
1773     delete collator;
1774 #endif
1775     collator = NULL;
1776 
1777     delete decimalFormatSymbols;
1778     decimalFormatSymbols = NULL;
1779 
1780     delete defaultInfinityRule;
1781     defaultInfinityRule = NULL;
1782 
1783     delete defaultNaNRule;
1784     defaultNaNRule = NULL;
</pre>
<hr />
<pre>
1794     if (localizations) {
1795         localizations = localizations-&gt;unref();
1796     }
1797 }
1798 
1799 
1800 //-----------------------------------------------------------------------
1801 // package-internal API
1802 //-----------------------------------------------------------------------
1803 
1804 /**
1805  * Returns the collator to use for lenient parsing.  The collator is lazily created:
1806  * this function creates it the first time it&#39;s called.
1807  * @return The collator to use for lenient parsing, or null if lenient parsing
1808  * is turned off.
1809 */
1810 const RuleBasedCollator*
1811 RuleBasedNumberFormat::getCollator() const
1812 {
1813 #if !UCONFIG_NO_COLLATION
<span class="line-modified">1814     if (!ruleSets) {</span>
1815         return NULL;
1816     }
1817 
1818     // lazy-evaluate the collator
1819     if (collator == NULL &amp;&amp; lenient) {
1820         // create a default collator based on the formatter&#39;s locale,
1821         // then pull out that collator&#39;s rules, append any additional
1822         // rules specified in the description, and create a _new_
<span class="line-modified">1823         // collator based on the combinaiton of those rules</span>
1824 
1825         UErrorCode status = U_ZERO_ERROR;
1826 
1827         Collator* temp = Collator::createInstance(locale, status);
1828         RuleBasedCollator* newCollator;
1829         if (U_SUCCESS(status) &amp;&amp; (newCollator = dynamic_cast&lt;RuleBasedCollator*&gt;(temp)) != NULL) {
1830             if (lenientParseRules) {
1831                 UnicodeString rules(newCollator-&gt;getRules());
1832                 rules.append(*lenientParseRules);
1833 
1834                 newCollator = new RuleBasedCollator(rules, status);
1835                 // Exit if newCollator could not be created.
1836                 if (newCollator == NULL) {
1837                     return NULL;
1838                 }
1839             } else {
1840                 temp = NULL;
1841             }
1842             if (U_SUCCESS(status)) {
1843                 newCollator-&gt;setAttribute(UCOL_DECOMPOSITION_MODE, UCOL_ON, status);
</pre>
<hr />
<pre>
1846             } else {
1847                 delete newCollator;
1848             }
1849         }
1850         delete temp;
1851     }
1852 #endif
1853 
1854     // if lenient-parse mode is off, this will be null
1855     // (see setLenientParseMode())
1856     return collator;
1857 }
1858 
1859 
1860 DecimalFormatSymbols*
1861 RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &amp;status)
1862 {
1863     // lazy-evaluate the DecimalFormatSymbols object.  This object
1864     // is shared by all DecimalFormat instances belonging to this
1865     // formatter
<span class="line-modified">1866     if (decimalFormatSymbols == NULL) {</span>
<span class="line-modified">1867         DecimalFormatSymbols* temp = new DecimalFormatSymbols(locale, status);</span>
1868         if (U_SUCCESS(status)) {
<span class="line-modified">1869             decimalFormatSymbols = temp;</span>
<span class="line-removed">1870         }</span>
<span class="line-removed">1871         else {</span>
<span class="line-removed">1872             delete temp;</span>
1873         }
1874     }
1875     return decimalFormatSymbols;
1876 }
1877 
1878 /**
1879  * Returns the DecimalFormatSymbols object that should be used by all DecimalFormat
1880  * instances owned by this formatter.
1881 */
1882 const DecimalFormatSymbols*
1883 RuleBasedNumberFormat::getDecimalFormatSymbols() const
1884 {
1885     return decimalFormatSymbols;
1886 }
1887 
1888 NFRule*
1889 RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &amp;status)
1890 {
1891     if (U_FAILURE(status)) {
<span class="line-modified">1892         return NULL;</span>
1893     }
1894     if (defaultInfinityRule == NULL) {
1895         UnicodeString rule(UNICODE_STRING_SIMPLE(&quot;Inf: &quot;));
1896         rule.append(getDecimalFormatSymbols()-&gt;getSymbol(DecimalFormatSymbols::kInfinitySymbol));
<span class="line-modified">1897         NFRule* temp = new NFRule(this, rule, status);</span>
1898         if (U_SUCCESS(status)) {
<span class="line-modified">1899             defaultInfinityRule = temp;</span>
<span class="line-removed">1900         }</span>
<span class="line-removed">1901         else {</span>
<span class="line-removed">1902             delete temp;</span>
1903         }
1904     }
1905     return defaultInfinityRule;
1906 }
1907 
1908 const NFRule*
1909 RuleBasedNumberFormat::getDefaultInfinityRule() const
1910 {
1911     return defaultInfinityRule;
1912 }
1913 
1914 NFRule*
1915 RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode &amp;status)
1916 {
1917     if (U_FAILURE(status)) {
<span class="line-modified">1918         return NULL;</span>
1919     }
<span class="line-modified">1920     if (defaultNaNRule == NULL) {</span>
1921         UnicodeString rule(UNICODE_STRING_SIMPLE(&quot;NaN: &quot;));
1922         rule.append(getDecimalFormatSymbols()-&gt;getSymbol(DecimalFormatSymbols::kNaNSymbol));
<span class="line-modified">1923         NFRule* temp = new NFRule(this, rule, status);</span>
1924         if (U_SUCCESS(status)) {
<span class="line-modified">1925             defaultNaNRule = temp;</span>
<span class="line-removed">1926         }</span>
<span class="line-removed">1927         else {</span>
<span class="line-removed">1928             delete temp;</span>
1929         }
1930     }
1931     return defaultNaNRule;
1932 }
1933 
1934 const NFRule*
1935 RuleBasedNumberFormat::getDefaultNaNRule() const
1936 {
1937     return defaultNaNRule;
1938 }
1939 
1940 // De-owning the current localized symbols and adopt the new symbols.
1941 void
1942 RuleBasedNumberFormat::adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt)
1943 {
1944     if (symbolsToAdopt == NULL) {
1945         return; // do not allow caller to set decimalFormatSymbols to NULL
1946     }
1947 
1948     if (decimalFormatSymbols != NULL) {
1949         delete decimalFormatSymbols;
1950     }
1951 
1952     decimalFormatSymbols = symbolsToAdopt;
1953 
1954     {
1955         // Apply the new decimalFormatSymbols by reparsing the rulesets
1956         UErrorCode status = U_ZERO_ERROR;
1957 
1958         delete defaultInfinityRule;
1959         defaultInfinityRule = NULL;
1960         initializeDefaultInfinityRule(status); // Reset with the new DecimalFormatSymbols
1961 
1962         delete defaultNaNRule;
1963         defaultNaNRule = NULL;
1964         initializeDefaultNaNRule(status); // Reset with the new DecimalFormatSymbols
1965 
<span class="line-modified">1966         if (ruleSets) {</span>
1967             for (int32_t i = 0; i &lt; numRuleSets; i++) {
<span class="line-modified">1968                 ruleSets[i]-&gt;setDecimalFormatSymbols(*symbolsToAdopt, status);</span>
1969             }
1970         }
1971     }
1972 }
1973 
<span class="line-modified">1974 // Setting the symbols is equlivalent to adopting a newly created localized symbols.</span>
1975 void
1976 RuleBasedNumberFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols)
1977 {
1978     adoptDecimalFormatSymbols(new DecimalFormatSymbols(symbols));
1979 }
1980 
1981 PluralFormat *
1982 RuleBasedNumberFormat::createPluralFormat(UPluralType pluralType,
1983                                           const UnicodeString &amp;pattern,
1984                                           UErrorCode&amp; status) const
1985 {
<span class="line-modified">1986     return new PluralFormat(locale, pluralType, pattern, status);</span>




1987 }
1988 
1989 /**
1990  * Get the rounding mode.
1991  * @return A rounding mode
1992  */
1993 DecimalFormat::ERoundingMode RuleBasedNumberFormat::getRoundingMode() const {
<span class="line-modified">1994     return roundingMode;</span>
1995 }
1996 
1997 /**
1998  * Set the rounding mode.  This has no effect unless the rounding
1999  * increment is greater than zero.
2000  * @param roundingMode A rounding mode
2001  */
2002 void RuleBasedNumberFormat::setRoundingMode(DecimalFormat::ERoundingMode roundingMode) {
<span class="line-modified">2003     this-&gt;roundingMode = roundingMode;</span>
2004 }
2005 
2006 U_NAMESPACE_END
2007 
2008 /* U_HAVE_RBNF */
2009 #endif
</pre>
</td>
<td>
<hr />
<pre>
 663     if (index &gt;= 0 &amp;&amp; index &lt; getNumberOfDisplayLocales()) {
 664         return data[index+1][0];
 665     }
 666     return NULL;
 667 }
 668 
 669 const UChar*
 670 StringLocalizationInfo::getDisplayName(int32_t localeIndex, int32_t ruleIndex) const {
 671     if (localeIndex &gt;= 0 &amp;&amp; localeIndex &lt; getNumberOfDisplayLocales() &amp;&amp;
 672         ruleIndex &gt;= 0 &amp;&amp; ruleIndex &lt; getNumberOfRuleSets()) {
 673         return data[localeIndex+1][ruleIndex+1];
 674     }
 675     return NULL;
 676 }
 677 
 678 // ----------
 679 
 680 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 681                                              const UnicodeString&amp; locs,
 682                                              const Locale&amp; alocale, UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified"> 683   : fRuleSets(NULL)</span>
 684   , ruleSetDescriptions(NULL)
 685   , numRuleSets(0)
 686   , defaultRuleSet(NULL)
 687   , locale(alocale)
 688   , collator(NULL)
 689   , decimalFormatSymbols(NULL)
 690   , defaultInfinityRule(NULL)
 691   , defaultNaNRule(NULL)
<span class="line-modified"> 692   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 693   , lenient(FALSE)
 694   , lenientParseRules(NULL)
 695   , localizations(NULL)
 696   , capitalizationInfoSet(FALSE)
 697   , capitalizationForUIListMenu(FALSE)
 698   , capitalizationForStandAlone(FALSE)
 699   , capitalizationBrkIter(NULL)
 700 {
 701   LocalizationInfo* locinfo = StringLocalizationInfo::create(locs, perror, status);
 702   init(description, locinfo, perror, status);
 703 }
 704 
 705 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 706                                              const UnicodeString&amp; locs,
 707                                              UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified"> 708   : fRuleSets(NULL)</span>
 709   , ruleSetDescriptions(NULL)
 710   , numRuleSets(0)
 711   , defaultRuleSet(NULL)
 712   , locale(Locale::getDefault())
 713   , collator(NULL)
 714   , decimalFormatSymbols(NULL)
 715   , defaultInfinityRule(NULL)
 716   , defaultNaNRule(NULL)
<span class="line-modified"> 717   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 718   , lenient(FALSE)
 719   , lenientParseRules(NULL)
 720   , localizations(NULL)
 721   , capitalizationInfoSet(FALSE)
 722   , capitalizationForUIListMenu(FALSE)
 723   , capitalizationForStandAlone(FALSE)
 724   , capitalizationBrkIter(NULL)
 725 {
 726   LocalizationInfo* locinfo = StringLocalizationInfo::create(locs, perror, status);
 727   init(description, locinfo, perror, status);
 728 }
 729 
 730 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 731                                              LocalizationInfo* info,
 732                                              const Locale&amp; alocale, UParseError&amp; perror, UErrorCode&amp; status)
<span class="line-modified"> 733   : fRuleSets(NULL)</span>
 734   , ruleSetDescriptions(NULL)
 735   , numRuleSets(0)
 736   , defaultRuleSet(NULL)
 737   , locale(alocale)
 738   , collator(NULL)
 739   , decimalFormatSymbols(NULL)
 740   , defaultInfinityRule(NULL)
 741   , defaultNaNRule(NULL)
<span class="line-modified"> 742   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 743   , lenient(FALSE)
 744   , lenientParseRules(NULL)
 745   , localizations(NULL)
 746   , capitalizationInfoSet(FALSE)
 747   , capitalizationForUIListMenu(FALSE)
 748   , capitalizationForStandAlone(FALSE)
 749   , capitalizationBrkIter(NULL)
 750 {
 751   init(description, info, perror, status);
 752 }
 753 
 754 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 755                          UParseError&amp; perror,
 756                          UErrorCode&amp; status)
<span class="line-modified"> 757   : fRuleSets(NULL)</span>
 758   , ruleSetDescriptions(NULL)
 759   , numRuleSets(0)
 760   , defaultRuleSet(NULL)
 761   , locale(Locale::getDefault())
 762   , collator(NULL)
 763   , decimalFormatSymbols(NULL)
 764   , defaultInfinityRule(NULL)
 765   , defaultNaNRule(NULL)
<span class="line-modified"> 766   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 767   , lenient(FALSE)
 768   , lenientParseRules(NULL)
 769   , localizations(NULL)
 770   , capitalizationInfoSet(FALSE)
 771   , capitalizationForUIListMenu(FALSE)
 772   , capitalizationForStandAlone(FALSE)
 773   , capitalizationBrkIter(NULL)
 774 {
 775     init(description, NULL, perror, status);
 776 }
 777 
 778 RuleBasedNumberFormat::RuleBasedNumberFormat(const UnicodeString&amp; description,
 779                          const Locale&amp; aLocale,
 780                          UParseError&amp; perror,
 781                          UErrorCode&amp; status)
<span class="line-modified"> 782   : fRuleSets(NULL)</span>
 783   , ruleSetDescriptions(NULL)
 784   , numRuleSets(0)
 785   , defaultRuleSet(NULL)
 786   , locale(aLocale)
 787   , collator(NULL)
 788   , decimalFormatSymbols(NULL)
 789   , defaultInfinityRule(NULL)
 790   , defaultNaNRule(NULL)
<span class="line-modified"> 791   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 792   , lenient(FALSE)
 793   , lenientParseRules(NULL)
 794   , localizations(NULL)
 795   , capitalizationInfoSet(FALSE)
 796   , capitalizationForUIListMenu(FALSE)
 797   , capitalizationForStandAlone(FALSE)
 798   , capitalizationBrkIter(NULL)
 799 {
 800     init(description, NULL, perror, status);
 801 }
 802 
 803 RuleBasedNumberFormat::RuleBasedNumberFormat(URBNFRuleSetTag tag, const Locale&amp; alocale, UErrorCode&amp; status)
<span class="line-modified"> 804   : fRuleSets(NULL)</span>
 805   , ruleSetDescriptions(NULL)
 806   , numRuleSets(0)
 807   , defaultRuleSet(NULL)
 808   , locale(alocale)
 809   , collator(NULL)
 810   , decimalFormatSymbols(NULL)
 811   , defaultInfinityRule(NULL)
 812   , defaultNaNRule(NULL)
<span class="line-modified"> 813   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 814   , lenient(FALSE)
 815   , lenientParseRules(NULL)
 816   , localizations(NULL)
 817   , capitalizationInfoSet(FALSE)
 818   , capitalizationForUIListMenu(FALSE)
 819   , capitalizationForStandAlone(FALSE)
 820   , capitalizationBrkIter(NULL)
 821 {
 822     if (U_FAILURE(status)) {
 823         return;
 824     }
 825 
 826     const char* rules_tag = &quot;RBNFRules&quot;;
 827     const char* fmt_tag = &quot;&quot;;
 828     switch (tag) {
 829     case URBNF_SPELLOUT: fmt_tag = &quot;SpelloutRules&quot;; break;
 830     case URBNF_ORDINAL: fmt_tag = &quot;OrdinalRules&quot;; break;
 831     case URBNF_DURATION: fmt_tag = &quot;DurationRules&quot;; break;
 832     case URBNF_NUMBERING_SYSTEM: fmt_tag = &quot;NumberingSystemRules&quot;; break;
 833     default: status = U_ILLEGAL_ARGUMENT_ERROR; return;
</pre>
<hr />
<pre>
 851             ures_close(nfrb);
 852             return;
 853         }
 854 
 855         UnicodeString desc;
 856         while (ures_hasNext(ruleSets)) {
 857            desc.append(ures_getNextUnicodeString(ruleSets,NULL,&amp;status));
 858         }
 859         UParseError perror;
 860 
 861         init(desc, locinfo, perror, status);
 862 
 863         ures_close(ruleSets);
 864         ures_close(rbnfRules);
 865     }
 866     ures_close(nfrb);
 867 }
 868 
 869 RuleBasedNumberFormat::RuleBasedNumberFormat(const RuleBasedNumberFormat&amp; rhs)
 870   : NumberFormat(rhs)
<span class="line-modified"> 871   , fRuleSets(NULL)</span>
 872   , ruleSetDescriptions(NULL)
 873   , numRuleSets(0)
 874   , defaultRuleSet(NULL)
 875   , locale(rhs.locale)
 876   , collator(NULL)
 877   , decimalFormatSymbols(NULL)
 878   , defaultInfinityRule(NULL)
 879   , defaultNaNRule(NULL)
<span class="line-modified"> 880   , fRoundingMode(DecimalFormat::ERoundingMode::kRoundUnnecessary)</span>
 881   , lenient(FALSE)
 882   , lenientParseRules(NULL)
 883   , localizations(NULL)
 884   , capitalizationInfoSet(FALSE)
 885   , capitalizationForUIListMenu(FALSE)
 886   , capitalizationForStandAlone(FALSE)
 887   , capitalizationBrkIter(NULL)
 888 {
 889     this-&gt;operator=(rhs);
 890 }
 891 
 892 // --------
 893 
 894 RuleBasedNumberFormat&amp;
 895 RuleBasedNumberFormat::operator=(const RuleBasedNumberFormat&amp; rhs)
 896 {
 897     if (this == &amp;rhs) {
 898         return *this;
 899     }
 900     NumberFormat::operator=(rhs);
</pre>
<hr />
<pre>
 933 UBool
 934 RuleBasedNumberFormat::operator==(const Format&amp; other) const
 935 {
 936     if (this == &amp;other) {
 937         return TRUE;
 938     }
 939 
 940     if (typeid(*this) == typeid(other)) {
 941         const RuleBasedNumberFormat&amp; rhs = (const RuleBasedNumberFormat&amp;)other;
 942         // test for capitalization info equality is adequately handled
 943         // by the NumberFormat test for fCapitalizationContext equality;
 944         // the info here is just derived from that.
 945         if (locale == rhs.locale &amp;&amp;
 946             lenient == rhs.lenient &amp;&amp;
 947             (localizations == NULL
 948                 ? rhs.localizations == NULL
 949                 : (rhs.localizations == NULL
 950                     ? FALSE
 951                     : *localizations == rhs.localizations))) {
 952 
<span class="line-modified"> 953             NFRuleSet** p = fRuleSets;</span>
<span class="line-modified"> 954             NFRuleSet** q = rhs.fRuleSets;</span>
 955             if (p == NULL) {
 956                 return q == NULL;
 957             } else if (q == NULL) {
 958                 return FALSE;
 959             }
 960             while (*p &amp;&amp; *q &amp;&amp; (**p == **q)) {
 961                 ++p;
 962                 ++q;
 963             }
 964             return *q == NULL &amp;&amp; *p == NULL;
 965         }
 966     }
 967 
 968     return FALSE;
 969 }
 970 
 971 UnicodeString
 972 RuleBasedNumberFormat::getRules() const
 973 {
 974     UnicodeString result;
<span class="line-modified"> 975     if (fRuleSets != NULL) {</span>
<span class="line-modified"> 976         for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
 977             (*p)-&gt;appendRules(result);
 978         }
 979     }
 980     return result;
 981 }
 982 
 983 UnicodeString
 984 RuleBasedNumberFormat::getRuleSetName(int32_t index) const
 985 {
 986     if (localizations) {
 987         UnicodeString string(TRUE, localizations-&gt;getRuleSetName(index), (int32_t)-1);
 988         return string;
 989     }
<span class="line-modified"> 990     else if (fRuleSets) {</span>
 991         UnicodeString result;
<span class="line-modified"> 992         for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
 993             NFRuleSet* rs = *p;
 994             if (rs-&gt;isPublic()) {
 995                 if (--index == -1) {
 996                     rs-&gt;getName(result);
 997                     return result;
 998                 }
 999             }
1000         }
1001     }
1002     UnicodeString empty;
1003     return empty;
1004 }
1005 
1006 int32_t
1007 RuleBasedNumberFormat::getNumberOfRuleSetNames() const
1008 {
1009     int32_t result = 0;
1010     if (localizations) {
1011         result = localizations-&gt;getNumberOfRuleSets();
1012     }
<span class="line-modified">1013     else if (fRuleSets) {</span>
<span class="line-modified">1014         for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
1015             if ((**p).isPublic()) {
1016                 ++result;
1017             }
1018         }
1019     }
1020     return result;
1021 }
1022 
1023 int32_t
1024 RuleBasedNumberFormat::getNumberOfRuleSetDisplayNameLocales(void) const {
1025     if (localizations) {
1026         return localizations-&gt;getNumberOfDisplayLocales();
1027     }
1028     return 0;
1029 }
1030 
1031 Locale
1032 RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int32_t index, UErrorCode&amp; status) const {
1033     if (U_FAILURE(status)) {
1034         return Locale(&quot;&quot;);
</pre>
<hr />
<pre>
1081     UnicodeString bogus;
1082     bogus.setToBogus();
1083     return bogus;
1084 }
1085 
1086 UnicodeString
1087 RuleBasedNumberFormat::getRuleSetDisplayName(const UnicodeString&amp; ruleSetName, const Locale&amp; localeParam) {
1088     if (localizations) {
1089         UnicodeString rsn(ruleSetName);
1090         int32_t ix = localizations-&gt;indexForRuleSet(rsn.getTerminatedBuffer());
1091         return getRuleSetDisplayName(ix, localeParam);
1092     }
1093     UnicodeString bogus;
1094     bogus.setToBogus();
1095     return bogus;
1096 }
1097 
1098 NFRuleSet*
1099 RuleBasedNumberFormat::findRuleSet(const UnicodeString&amp; name, UErrorCode&amp; status) const
1100 {
<span class="line-modified">1101     if (U_SUCCESS(status) &amp;&amp; fRuleSets) {</span>
<span class="line-modified">1102         for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
1103             NFRuleSet* rs = *p;
1104             if (rs-&gt;isNamed(name)) {
1105                 return rs;
1106             }
1107         }
1108         status = U_ILLEGAL_ARGUMENT_ERROR;
1109     }
1110     return NULL;
1111 }
1112 
1113 UnicodeString&amp;
1114 RuleBasedNumberFormat::format(const DecimalQuantity &amp;number,
1115                       UnicodeString &amp;appendTo,
1116                       FieldPositionIterator *posIter,
1117                       UErrorCode &amp;status) const {
1118     if (U_FAILURE(status)) {
1119         return appendTo;
1120     }
1121     DecimalQuantity copy(number);
1122     if (copy.fitsInLong()) {
1123         format(number.toLong(), appendTo, posIter, status);
1124     }
1125     else {
1126         copy.roundToMagnitude(0, number::impl::RoundingMode::UNUM_ROUND_HALFEVEN, status);
1127         if (copy.fitsInLong()) {
1128             format(number.toDouble(), appendTo, posIter, status);
1129         }
1130         else {
1131             // We&#39;re outside of our normal range that this framework can handle.
1132             // The DecimalFormat will provide more accurate results.
1133 
1134             // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
<span class="line-modified">1135             LocalPointer&lt;NumberFormat&gt; decimalFormat(NumberFormat::createInstance(locale, UNUM_DECIMAL, status), status);</span>
<span class="line-added">1136             if (decimalFormat.isNull()) {</span>
<span class="line-added">1137                 return appendTo;</span>
<span class="line-added">1138             }</span>
1139             Formattable f;
<span class="line-modified">1140             LocalPointer&lt;DecimalQuantity&gt; decimalQuantity(new DecimalQuantity(number), status);</span>
<span class="line-added">1141             if (decimalQuantity.isNull()) {</span>
<span class="line-added">1142                 return appendTo;</span>
<span class="line-added">1143             }</span>
<span class="line-added">1144             f.adoptDecimalQuantity(decimalQuantity.orphan()); // f now owns decimalQuantity.</span>
1145             decimalFormat-&gt;format(f, appendTo, posIter, status);

1146         }
1147     }
1148     return appendTo;
1149 }
1150 
1151 
1152 UnicodeString&amp;
1153 RuleBasedNumberFormat::format(const DecimalQuantity &amp;number,
1154                      UnicodeString&amp; appendTo,
1155                      FieldPosition&amp; pos,
1156                      UErrorCode &amp;status) const {
1157     if (U_FAILURE(status)) {
1158         return appendTo;
1159     }
1160     DecimalQuantity copy(number);
1161     if (copy.fitsInLong()) {
1162         format(number.toLong(), appendTo, pos, status);
1163     }
1164     else {
1165         copy.roundToMagnitude(0, number::impl::RoundingMode::UNUM_ROUND_HALFEVEN, status);
1166         if (copy.fitsInLong()) {
1167             format(number.toDouble(), appendTo, pos, status);
1168         }
1169         else {
1170             // We&#39;re outside of our normal range that this framework can handle.
1171             // The DecimalFormat will provide more accurate results.
1172 
1173             // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
<span class="line-modified">1174             LocalPointer&lt;NumberFormat&gt; decimalFormat(NumberFormat::createInstance(locale, UNUM_DECIMAL, status), status);</span>
<span class="line-added">1175             if (decimalFormat.isNull()) {</span>
<span class="line-added">1176                 return appendTo;</span>
<span class="line-added">1177             }</span>
1178             Formattable f;
<span class="line-modified">1179             LocalPointer&lt;DecimalQuantity&gt; decimalQuantity(new DecimalQuantity(number), status);</span>
<span class="line-added">1180             if (decimalQuantity.isNull()) {</span>
<span class="line-added">1181                 return appendTo;</span>
<span class="line-added">1182             }</span>
<span class="line-added">1183             f.adoptDecimalQuantity(decimalQuantity.orphan()); // f now owns decimalQuantity.</span>
1184             decimalFormat-&gt;format(f, appendTo, pos, status);

1185         }
1186     }
1187     return appendTo;
1188 }
1189 
1190 UnicodeString&amp;
1191 RuleBasedNumberFormat::format(int32_t number,
1192                               UnicodeString&amp; toAppendTo,
1193                               FieldPosition&amp; pos) const
1194 {
1195     return format((int64_t)number, toAppendTo, pos);
1196 }
1197 
1198 
1199 UnicodeString&amp;
1200 RuleBasedNumberFormat::format(int64_t number,
1201                               UnicodeString&amp; toAppendTo,
1202                               FieldPosition&amp; /* pos */) const
1203 {
1204     if (defaultRuleSet) {
</pre>
<hr />
<pre>
1307 UnicodeString&amp;
1308 RuleBasedNumberFormat::format(int64_t number, NFRuleSet *ruleSet, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const
1309 {
1310     // all API format() routines that take a double vector through
1311     // here.  We have these two identical functions-- one taking a
1312     // double and one taking a long-- the couple digits of precision
1313     // that long has but double doesn&#39;t (both types are 8 bytes long,
1314     // but double has to borrow some of the mantissa bits to hold
1315     // the exponent).
1316     // Create an empty string buffer where the result will
1317     // be built, and pass it to the rule set (along with an insertion
1318     // position of 0 and the number being formatted) to the rule set
1319     // for formatting
1320 
1321     if (U_SUCCESS(status)) {
1322         if (number == U_INT64_MIN) {
1323             // We can&#39;t handle this value right now. Provide an accurate default value.
1324 
1325             // TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.
1326             NumberFormat *decimalFormat = NumberFormat::createInstance(locale, UNUM_DECIMAL, status);
<span class="line-added">1327             if (decimalFormat == nullptr) {</span>
<span class="line-added">1328                 return toAppendTo;</span>
<span class="line-added">1329             }</span>
1330             Formattable f;
1331             FieldPosition pos(FieldPosition::DONT_CARE);
<span class="line-modified">1332             DecimalQuantity *decimalQuantity = new DecimalQuantity();</span>
<span class="line-modified">1333             if (decimalQuantity == nullptr) {</span>
<span class="line-modified">1334                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1335                 delete decimalFormat;</span>
<span class="line-added">1336                 return toAppendTo;</span>
<span class="line-added">1337             }</span>
<span class="line-added">1338             decimalQuantity-&gt;setToLong(number);</span>
<span class="line-added">1339             f.adoptDecimalQuantity(decimalQuantity); // f now owns decimalQuantity.</span>
1340             decimalFormat-&gt;format(f, toAppendTo, pos, status);
1341             delete decimalFormat;
1342         }
1343         else {
1344             int32_t startPos = toAppendTo.length();
1345             ruleSet-&gt;format(number, toAppendTo, toAppendTo.length(), 0, status);
1346             adjustForCapitalizationContext(startPos, toAppendTo, status);
1347         }
1348     }
1349     return toAppendTo;
1350 }
1351 
1352 UnicodeString&amp;
1353 RuleBasedNumberFormat::adjustForCapitalizationContext(int32_t startPos,
1354                                                       UnicodeString&amp; currentResult,
1355                                                       UErrorCode&amp; status) const
1356 {
1357 #if !UCONFIG_NO_BREAK_ITERATION
1358     UDisplayContext capitalizationContext = getContext(UDISPCTX_TYPE_CAPITALIZATION, status);
1359     if (capitalizationContext != UDISPCTX_CAPITALIZATION_NONE &amp;&amp; startPos == 0 &amp;&amp; currentResult.length() &gt; 0) {
</pre>
<hr />
<pre>
1361         UChar32 ch = currentResult.char32At(0);
1362         if (u_islower(ch) &amp;&amp; U_SUCCESS(status) &amp;&amp; capitalizationBrkIter != NULL &amp;&amp;
1363               ( capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
1364                 (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU &amp;&amp; capitalizationForUIListMenu) ||
1365                 (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_STANDALONE &amp;&amp; capitalizationForStandAlone)) ) {
1366             // titlecase first word of currentResult, here use sentence iterator unlike current implementations
1367             // in LocaleDisplayNamesImpl::adjustForUsageAndContext and RelativeDateFormat::format
1368             currentResult.toTitle(capitalizationBrkIter, locale, U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
1369         }
1370     }
1371 #endif
1372     return currentResult;
1373 }
1374 
1375 
1376 void
1377 RuleBasedNumberFormat::parse(const UnicodeString&amp; text,
1378                              Formattable&amp; result,
1379                              ParsePosition&amp; parsePosition) const
1380 {
<span class="line-modified">1381     if (!fRuleSets) {</span>
1382         parsePosition.setErrorIndex(0);
1383         return;
1384     }
1385 
1386     UnicodeString workingText(text, parsePosition.getIndex());
1387     ParsePosition workingPos(0);
1388 
1389     ParsePosition high_pp(0);
1390     Formattable high_result;
1391 
<span class="line-modified">1392     for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
1393         NFRuleSet *rp = *p;
1394         if (rp-&gt;isPublic() &amp;&amp; rp-&gt;isParseable()) {
1395             ParsePosition working_pp(0);
1396             Formattable working_result;
1397 
1398             rp-&gt;parse(workingText, working_pp, kMaxDouble, 0, working_result);
1399             if (working_pp.getIndex() &gt; high_pp.getIndex()) {
1400                 high_pp = working_pp;
1401                 high_result = working_result;
1402 
1403                 if (high_pp.getIndex() == workingText.length()) {
1404                     break;
1405                 }
1406             }
1407         }
1408     }
1409 
1410     int32_t startIndex = parsePosition.getIndex();
1411     parsePosition.setIndex(startIndex + high_pp.getIndex());
1412     if (high_pp.getIndex() &gt; 0) {
</pre>
<hr />
<pre>
1460             }
1461         }
1462     }
1463 }
1464 
1465 UnicodeString
1466 RuleBasedNumberFormat::getDefaultRuleSetName() const {
1467     UnicodeString result;
1468     if (defaultRuleSet &amp;&amp; defaultRuleSet-&gt;isPublic()) {
1469         defaultRuleSet-&gt;getName(result);
1470     } else {
1471         result.setToBogus();
1472     }
1473     return result;
1474 }
1475 
1476 void
1477 RuleBasedNumberFormat::initDefaultRuleSet()
1478 {
1479     defaultRuleSet = NULL;
<span class="line-modified">1480     if (!fRuleSets) {</span>
1481         return;
1482     }
1483 
1484     const UnicodeString spellout(UNICODE_STRING_SIMPLE(&quot;%spellout-numbering&quot;));
1485     const UnicodeString ordinal(UNICODE_STRING_SIMPLE(&quot;%digits-ordinal&quot;));
1486     const UnicodeString duration(UNICODE_STRING_SIMPLE(&quot;%duration&quot;));
1487 
<span class="line-modified">1488     NFRuleSet**p = &amp;fRuleSets[0];</span>
1489     while (*p) {
1490         if ((*p)-&gt;isNamed(spellout) || (*p)-&gt;isNamed(ordinal) || (*p)-&gt;isNamed(duration)) {
1491             defaultRuleSet = *p;
1492             return;
1493         } else {
1494             ++p;
1495         }
1496     }
1497 
1498     defaultRuleSet = *--p;
1499     if (!defaultRuleSet-&gt;isPublic()) {
<span class="line-modified">1500         while (p != fRuleSets) {</span>
1501             if ((*--p)-&gt;isPublic()) {
1502                 defaultRuleSet = *p;
1503                 break;
1504             }
1505         }
1506     }
1507 }
1508 
1509 
1510 void
1511 RuleBasedNumberFormat::init(const UnicodeString&amp; rules, LocalizationInfo* localizationInfos,
1512                             UParseError&amp; pErr, UErrorCode&amp; status)
1513 {
1514     // TODO: implement UParseError
1515     uprv_memset(&amp;pErr, 0, sizeof(UParseError));
1516     // Note: this can leave ruleSets == NULL, so remaining code should check
1517     if (U_FAILURE(status)) {
1518         return;
1519     }
1520 
</pre>
<hr />
<pre>
1550         // (where &quot;%%lenient-parse&quot; would actually get treated as
1551         // rule text)
1552         if (lp == 0 || description.charAt(lp - 1) == gSemiColon) {
1553             // locate the beginning and end of the actual collation
1554             // rules (there may be whitespace between the name and
1555             // the first token in the description)
1556             int lpEnd = description.indexOf(gSemiPercent, 2, lp);
1557 
1558             if (lpEnd == -1) {
1559                 lpEnd = description.length() - 1;
1560             }
1561             int lpStart = lp + u_strlen(gLenientParse);
1562             while (PatternProps::isWhiteSpace(description.charAt(lpStart))) {
1563                 ++lpStart;
1564             }
1565 
1566             // copy out the lenient-parse rules and delete them
1567             // from the description
1568             lenientParseRules = new UnicodeString();
1569             /* test for NULL */
<span class="line-modified">1570             if (lenientParseRules == nullptr) {</span>
1571                 status = U_MEMORY_ALLOCATION_ERROR;
1572                 return;
1573             }
1574             lenientParseRules-&gt;setTo(description, lpStart, lpEnd - lpStart);
1575 
1576             description.remove(lp, lpEnd + 1 - lp);
1577         }
1578     }
1579 
1580     // pre-flight parsing the description and count the number of
1581     // rule sets (&quot;;%&quot; marks the end of one rule set and the beginning
1582     // of the next)
1583     numRuleSets = 0;
1584     for (int32_t p = description.indexOf(gSemiPercent, 2, 0); p != -1; p = description.indexOf(gSemiPercent, 2, p)) {
1585         ++numRuleSets;
1586         ++p;
1587     }
1588     ++numRuleSets;
1589 
1590     // our rule list is an array of the appropriate size
<span class="line-modified">1591     fRuleSets = (NFRuleSet **)uprv_malloc((numRuleSets + 1) * sizeof(NFRuleSet *));</span>
1592     /* test for NULL */
<span class="line-modified">1593     if (fRuleSets == 0) {</span>
1594         status = U_MEMORY_ALLOCATION_ERROR;
1595         return;
1596     }
1597 
1598     for (int i = 0; i &lt;= numRuleSets; ++i) {
<span class="line-modified">1599         fRuleSets[i] = NULL;</span>
1600     }
1601 
1602     // divide up the descriptions into individual rule-set descriptions
1603     // and store them in a temporary array.  At each step, we also
1604     // new up a rule set, but all this does is initialize its name
1605     // and remove it from its description.  We can&#39;t actually parse
1606     // the rest of the descriptions and finish initializing everything
1607     // because we have to know the names and locations of all the rule
1608     // sets before we can actually set everything up
1609     if(!numRuleSets) {
1610         status = U_ILLEGAL_ARGUMENT_ERROR;
1611         return;
1612     }
1613 
1614     ruleSetDescriptions = new UnicodeString[numRuleSets];
<span class="line-modified">1615     if (ruleSetDescriptions == nullptr) {</span>
1616         status = U_MEMORY_ALLOCATION_ERROR;
1617         return;
1618     }
1619 
1620     {
1621         int curRuleSet = 0;
1622         int32_t start = 0;
1623         for (int32_t p = description.indexOf(gSemiPercent, 2, 0); p != -1; p = description.indexOf(gSemiPercent, 2, start)) {
1624             ruleSetDescriptions[curRuleSet].setTo(description, start, p + 1 - start);
<span class="line-modified">1625             fRuleSets[curRuleSet] = new NFRuleSet(this, ruleSetDescriptions, curRuleSet, status);</span>
<span class="line-modified">1626             if (fRuleSets[curRuleSet] == nullptr) {</span>
1627                 status = U_MEMORY_ALLOCATION_ERROR;
1628                 return;
1629             }
1630             ++curRuleSet;
1631             start = p + 1;
1632         }
1633         ruleSetDescriptions[curRuleSet].setTo(description, start, description.length() - start);
<span class="line-modified">1634         fRuleSets[curRuleSet] = new NFRuleSet(this, ruleSetDescriptions, curRuleSet, status);</span>
<span class="line-modified">1635         if (fRuleSets[curRuleSet] == nullptr) {</span>
1636             status = U_MEMORY_ALLOCATION_ERROR;
1637             return;
1638         }
1639     }
1640 
1641     // now we can take note of the formatter&#39;s default rule set, which
1642     // is the last public rule set in the description (it&#39;s the last
1643     // rather than the first so that a user can create a new formatter
1644     // from an existing formatter and change its default behavior just
1645     // by appending more rule sets to the end)
1646 
1647     // {dlf} Initialization of a fraction rule set requires the default rule
1648     // set to be known.  For purposes of initialization, this is always the
1649     // last public rule set, no matter what the localization data says.
1650     initDefaultRuleSet();
1651 
1652     // finally, we can go back through the temporary descriptions
<span class="line-modified">1653     // list and finish setting up the substructure (and we throw</span>
1654     // away the temporary descriptions as we go)
1655     {
1656         for (int i = 0; i &lt; numRuleSets; i++) {
<span class="line-modified">1657             fRuleSets[i]-&gt;parseRules(ruleSetDescriptions[i], status);</span>
1658         }
1659     }
1660 
1661     // Now that the rules are initialized, the &#39;real&#39; default rule
1662     // set can be adjusted by the localization data.
1663 
1664     // The C code keeps the localization array as is, rather than building
1665     // a separate array of the public rule set names, so we have less work
1666     // to do here-- but we still need to check the names.
1667 
1668     if (localizationInfos) {
1669         // confirm the names, if any aren&#39;t in the rules, that&#39;s an error
1670         // it is ok if the rules contain public rule sets that are not in this list
1671         for (int32_t i = 0; i &lt; localizationInfos-&gt;getNumberOfRuleSets(); ++i) {
1672             UnicodeString name(TRUE, localizationInfos-&gt;getRuleSetName(i), -1);
1673             NFRuleSet* rs = findRuleSet(name, status);
1674             if (rs == NULL) {
1675                 break; // error
1676             }
1677             if (i == 0) {
</pre>
<hr />
<pre>
1683     }
1684     originalDescription = rules;
1685 }
1686 
1687 // override the NumberFormat implementation in order to
1688 // lazily initialize relevant items
1689 void
1690 RuleBasedNumberFormat::setContext(UDisplayContext value, UErrorCode&amp; status)
1691 {
1692     NumberFormat::setContext(value, status);
1693     if (U_SUCCESS(status)) {
1694         if (!capitalizationInfoSet &amp;&amp;
1695                 (value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU || value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE)) {
1696             initCapitalizationContextInfo(locale);
1697             capitalizationInfoSet = TRUE;
1698         }
1699 #if !UCONFIG_NO_BREAK_ITERATION
1700         if ( capitalizationBrkIter == NULL &amp;&amp; (value==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
1701                 (value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU &amp;&amp; capitalizationForUIListMenu) ||
1702                 (value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE &amp;&amp; capitalizationForStandAlone)) ) {
<span class="line-modified">1703             status = U_ZERO_ERROR;</span>
1704             capitalizationBrkIter = BreakIterator::createSentenceInstance(locale, status);
1705             if (U_FAILURE(status)) {
1706                 delete capitalizationBrkIter;
1707                 capitalizationBrkIter = NULL;
1708             }
1709         }
1710 #endif
1711     }
1712 }
1713 
1714 void
1715 RuleBasedNumberFormat::initCapitalizationContextInfo(const Locale&amp; thelocale)
1716 {
1717 #if !UCONFIG_NO_BREAK_ITERATION
1718     const char * localeID = (thelocale != NULL)? thelocale.getBaseName(): NULL;
1719     UErrorCode status = U_ZERO_ERROR;
1720     UResourceBundle *rb = ures_open(NULL, localeID, &amp;status);
1721     rb = ures_getByKeyWithFallback(rb, &quot;contextTransforms&quot;, rb, &amp;status);
1722     rb = ures_getByKeyWithFallback(rb, &quot;number-spellout&quot;, rb, &amp;status);
1723     if (U_SUCCESS(status) &amp;&amp; rb != NULL) {
1724         int32_t len = 0;
1725         const int32_t * intVector = ures_getIntVector(rb, &amp;len, &amp;status);
1726         if (U_SUCCESS(status) &amp;&amp; intVector != NULL &amp;&amp; len &gt;= 2) {
<span class="line-modified">1727             capitalizationForUIListMenu = static_cast&lt;UBool&gt;(intVector[0]);</span>
<span class="line-modified">1728             capitalizationForStandAlone = static_cast&lt;UBool&gt;(intVector[1]);</span>
1729         }
1730     }
1731     ures_close(rb);
1732 #endif
1733 }
1734 
1735 void
1736 RuleBasedNumberFormat::stripWhitespace(UnicodeString&amp; description)
1737 {
1738     // iterate through the characters...
1739     UnicodeString result;
1740 
1741     int start = 0;
1742     while (start != -1 &amp;&amp; start &lt; description.length()) {
1743         // seek to the first non-whitespace character...
1744         while (start &lt; description.length()
1745             &amp;&amp; PatternProps::isWhiteSpace(description.charAt(start))) {
1746             ++start;
1747         }
1748 
1749         // locate the next semicolon in the text and copy the text from
1750         // our current position up to that semicolon into the result
1751         int32_t p = description.indexOf(gSemiColon, start);
1752         if (p == -1) {
1753             // or if we don&#39;t find a semicolon, just copy the rest of
1754             // the string into the result
1755             result.append(description, start, description.length() - start);
1756             start = -1;
1757         }
1758         else if (p &lt; description.length()) {
1759             result.append(description, start, p + 1 - start);
1760             start = p + 1;
1761         }
1762 
<span class="line-modified">1763         // when we get here, we&#39;ve seeked off the end of the string, and</span>
1764         // we terminate the loop (we continue until *start* is -1 rather
1765         // than until *p* is -1, because otherwise we&#39;d miss the last
1766         // rule in the description)
1767         else {
1768             start = -1;
1769         }
1770     }
1771 
1772     description.setTo(result);
1773 }
1774 
1775 
1776 void
1777 RuleBasedNumberFormat::dispose()
1778 {
<span class="line-modified">1779     if (fRuleSets) {</span>
<span class="line-modified">1780         for (NFRuleSet** p = fRuleSets; *p; ++p) {</span>
1781             delete *p;
1782         }
<span class="line-modified">1783         uprv_free(fRuleSets);</span>
<span class="line-modified">1784         fRuleSets = NULL;</span>
1785     }
1786 
1787     if (ruleSetDescriptions) {
1788         delete [] ruleSetDescriptions;
1789         ruleSetDescriptions = NULL;
1790     }
1791 
1792 #if !UCONFIG_NO_COLLATION
1793     delete collator;
1794 #endif
1795     collator = NULL;
1796 
1797     delete decimalFormatSymbols;
1798     decimalFormatSymbols = NULL;
1799 
1800     delete defaultInfinityRule;
1801     defaultInfinityRule = NULL;
1802 
1803     delete defaultNaNRule;
1804     defaultNaNRule = NULL;
</pre>
<hr />
<pre>
1814     if (localizations) {
1815         localizations = localizations-&gt;unref();
1816     }
1817 }
1818 
1819 
1820 //-----------------------------------------------------------------------
1821 // package-internal API
1822 //-----------------------------------------------------------------------
1823 
1824 /**
1825  * Returns the collator to use for lenient parsing.  The collator is lazily created:
1826  * this function creates it the first time it&#39;s called.
1827  * @return The collator to use for lenient parsing, or null if lenient parsing
1828  * is turned off.
1829 */
1830 const RuleBasedCollator*
1831 RuleBasedNumberFormat::getCollator() const
1832 {
1833 #if !UCONFIG_NO_COLLATION
<span class="line-modified">1834     if (!fRuleSets) {</span>
1835         return NULL;
1836     }
1837 
1838     // lazy-evaluate the collator
1839     if (collator == NULL &amp;&amp; lenient) {
1840         // create a default collator based on the formatter&#39;s locale,
1841         // then pull out that collator&#39;s rules, append any additional
1842         // rules specified in the description, and create a _new_
<span class="line-modified">1843         // collator based on the combination of those rules</span>
1844 
1845         UErrorCode status = U_ZERO_ERROR;
1846 
1847         Collator* temp = Collator::createInstance(locale, status);
1848         RuleBasedCollator* newCollator;
1849         if (U_SUCCESS(status) &amp;&amp; (newCollator = dynamic_cast&lt;RuleBasedCollator*&gt;(temp)) != NULL) {
1850             if (lenientParseRules) {
1851                 UnicodeString rules(newCollator-&gt;getRules());
1852                 rules.append(*lenientParseRules);
1853 
1854                 newCollator = new RuleBasedCollator(rules, status);
1855                 // Exit if newCollator could not be created.
1856                 if (newCollator == NULL) {
1857                     return NULL;
1858                 }
1859             } else {
1860                 temp = NULL;
1861             }
1862             if (U_SUCCESS(status)) {
1863                 newCollator-&gt;setAttribute(UCOL_DECOMPOSITION_MODE, UCOL_ON, status);
</pre>
<hr />
<pre>
1866             } else {
1867                 delete newCollator;
1868             }
1869         }
1870         delete temp;
1871     }
1872 #endif
1873 
1874     // if lenient-parse mode is off, this will be null
1875     // (see setLenientParseMode())
1876     return collator;
1877 }
1878 
1879 
1880 DecimalFormatSymbols*
1881 RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &amp;status)
1882 {
1883     // lazy-evaluate the DecimalFormatSymbols object.  This object
1884     // is shared by all DecimalFormat instances belonging to this
1885     // formatter
<span class="line-modified">1886     if (decimalFormatSymbols == nullptr) {</span>
<span class="line-modified">1887         LocalPointer&lt;DecimalFormatSymbols&gt; temp(new DecimalFormatSymbols(locale, status), status);</span>
1888         if (U_SUCCESS(status)) {
<span class="line-modified">1889             decimalFormatSymbols = temp.orphan();</span>



1890         }
1891     }
1892     return decimalFormatSymbols;
1893 }
1894 
1895 /**
1896  * Returns the DecimalFormatSymbols object that should be used by all DecimalFormat
1897  * instances owned by this formatter.
1898 */
1899 const DecimalFormatSymbols*
1900 RuleBasedNumberFormat::getDecimalFormatSymbols() const
1901 {
1902     return decimalFormatSymbols;
1903 }
1904 
1905 NFRule*
1906 RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &amp;status)
1907 {
1908     if (U_FAILURE(status)) {
<span class="line-modified">1909         return nullptr;</span>
1910     }
1911     if (defaultInfinityRule == NULL) {
1912         UnicodeString rule(UNICODE_STRING_SIMPLE(&quot;Inf: &quot;));
1913         rule.append(getDecimalFormatSymbols()-&gt;getSymbol(DecimalFormatSymbols::kInfinitySymbol));
<span class="line-modified">1914         LocalPointer&lt;NFRule&gt; temp(new NFRule(this, rule, status), status);</span>
1915         if (U_SUCCESS(status)) {
<span class="line-modified">1916             defaultInfinityRule = temp.orphan();</span>



1917         }
1918     }
1919     return defaultInfinityRule;
1920 }
1921 
1922 const NFRule*
1923 RuleBasedNumberFormat::getDefaultInfinityRule() const
1924 {
1925     return defaultInfinityRule;
1926 }
1927 
1928 NFRule*
1929 RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode &amp;status)
1930 {
1931     if (U_FAILURE(status)) {
<span class="line-modified">1932         return nullptr;</span>
1933     }
<span class="line-modified">1934     if (defaultNaNRule == nullptr) {</span>
1935         UnicodeString rule(UNICODE_STRING_SIMPLE(&quot;NaN: &quot;));
1936         rule.append(getDecimalFormatSymbols()-&gt;getSymbol(DecimalFormatSymbols::kNaNSymbol));
<span class="line-modified">1937         LocalPointer&lt;NFRule&gt; temp(new NFRule(this, rule, status), status);</span>
1938         if (U_SUCCESS(status)) {
<span class="line-modified">1939             defaultNaNRule = temp.orphan();</span>



1940         }
1941     }
1942     return defaultNaNRule;
1943 }
1944 
1945 const NFRule*
1946 RuleBasedNumberFormat::getDefaultNaNRule() const
1947 {
1948     return defaultNaNRule;
1949 }
1950 
1951 // De-owning the current localized symbols and adopt the new symbols.
1952 void
1953 RuleBasedNumberFormat::adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt)
1954 {
1955     if (symbolsToAdopt == NULL) {
1956         return; // do not allow caller to set decimalFormatSymbols to NULL
1957     }
1958 
1959     if (decimalFormatSymbols != NULL) {
1960         delete decimalFormatSymbols;
1961     }
1962 
1963     decimalFormatSymbols = symbolsToAdopt;
1964 
1965     {
1966         // Apply the new decimalFormatSymbols by reparsing the rulesets
1967         UErrorCode status = U_ZERO_ERROR;
1968 
1969         delete defaultInfinityRule;
1970         defaultInfinityRule = NULL;
1971         initializeDefaultInfinityRule(status); // Reset with the new DecimalFormatSymbols
1972 
1973         delete defaultNaNRule;
1974         defaultNaNRule = NULL;
1975         initializeDefaultNaNRule(status); // Reset with the new DecimalFormatSymbols
1976 
<span class="line-modified">1977         if (fRuleSets) {</span>
1978             for (int32_t i = 0; i &lt; numRuleSets; i++) {
<span class="line-modified">1979                 fRuleSets[i]-&gt;setDecimalFormatSymbols(*symbolsToAdopt, status);</span>
1980             }
1981         }
1982     }
1983 }
1984 
<span class="line-modified">1985 // Setting the symbols is equivalent to adopting a newly created localized symbols.</span>
1986 void
1987 RuleBasedNumberFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols)
1988 {
1989     adoptDecimalFormatSymbols(new DecimalFormatSymbols(symbols));
1990 }
1991 
1992 PluralFormat *
1993 RuleBasedNumberFormat::createPluralFormat(UPluralType pluralType,
1994                                           const UnicodeString &amp;pattern,
1995                                           UErrorCode&amp; status) const
1996 {
<span class="line-modified">1997     auto *pf = new PluralFormat(locale, pluralType, pattern, status);</span>
<span class="line-added">1998     if (pf == nullptr) {</span>
<span class="line-added">1999         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">2000     }</span>
<span class="line-added">2001     return pf;</span>
2002 }
2003 
2004 /**
2005  * Get the rounding mode.
2006  * @return A rounding mode
2007  */
2008 DecimalFormat::ERoundingMode RuleBasedNumberFormat::getRoundingMode() const {
<span class="line-modified">2009     return fRoundingMode;</span>
2010 }
2011 
2012 /**
2013  * Set the rounding mode.  This has no effect unless the rounding
2014  * increment is greater than zero.
2015  * @param roundingMode A rounding mode
2016  */
2017 void RuleBasedNumberFormat::setRoundingMode(DecimalFormat::ERoundingMode roundingMode) {
<span class="line-modified">2018     fRoundingMode = roundingMode;</span>
2019 }
2020 
2021 U_NAMESPACE_END
2022 
2023 /* U_HAVE_RBNF */
2024 #endif
</pre>
</td>
</tr>
</table>
<center><a href="quantityformatter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbt.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>