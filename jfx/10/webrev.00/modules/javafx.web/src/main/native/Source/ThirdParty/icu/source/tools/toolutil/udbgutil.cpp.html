<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/udbgutil.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /********************************************************************
  4  * COPYRIGHT:
  5  * Copyright (c) 2007-2016, International Business Machines Corporation and
  6  * others. All Rights Reserved.
  7  ********************************************************************/
  8 
  9 #include &quot;udbgutil.h&quot;
 10 #include &lt;string.h&gt;
 11 #include &quot;ustr_imp.h&quot;
 12 #include &quot;cmemory.h&quot;
 13 #include &quot;cstring.h&quot;
 14 #include &quot;putilimp.h&quot;
 15 #include &quot;unicode/ulocdata.h&quot;
 16 #include &quot;unicode/ucnv.h&quot;
 17 #include &quot;unicode/unistr.h&quot;
 18 #include &quot;cstr.h&quot;
 19 
 20 /*
 21 To add a new enum type
 22       (For example: UShoeSize  with values USHOE_WIDE=0, USHOE_REGULAR, USHOE_NARROW, USHOE_COUNT)
 23 
 24     0. Make sure that all lines you add are protected with appropriate uconfig guards,
 25         such as &#39;#if !UCONFIG_NO_SHOES&#39;.
 26     1. udbgutil.h:  add  UDBG_UShoeSize to the UDebugEnumType enum before UDBG_ENUM_COUNT
 27       ( The subsequent steps involve this file, udbgutil.cpp )
 28     2. Find the marker &quot;Add new enum types above this line&quot;
 29     3. Before that marker, add a #include of any header file you need.
 30     4. Each enum type has three things in this section:  a #define, a count_, and an array of Fields.
 31        It may help to copy and paste a previous definition.
 32     5. In the case of the USHOE_... strings above, &quot;USHOE_&quot; is common to all values- six characters
 33          &quot; #define LEN_USHOE 6 &quot;
 34        6 characters will strip off &quot;USHOE_&quot; leaving enum values of WIDE, REGULAR, and NARROW.
 35     6. Define the &#39;count_&#39; variable, with the number of enum values. If the enum has a _MAX or _COUNT value,
 36         that can be helpful for automatically defining the count. Otherwise define it manually.
 37         &quot; static const int32_t count_UShoeSize = USHOE_COUNT; &quot;
 38     7. Define the field names, in order.
 39         &quot; static const Field names_UShoeSize[] =  {
 40         &quot;  FIELD_NAME_STR( LEN_USHOE, USHOE_WIDE ),
 41         &quot;  FIELD_NAME_STR( LEN_USHOE, USHOE_REGULAR ),
 42         &quot;  FIELD_NAME_STR( LEN_USHOE, USHOE_NARROW ),
 43         &quot; };
 44       ( The following command  was usedfor converting ucol.h into partially correct entities )
 45       grep &quot;^[  ]*UCOL&quot; &lt; unicode/ucol.h  |
 46          sed -e &#39;s%^[  ]*\([A-Z]*\)_\([A-Z_]*\).*%   FIELD_NAME_STR( LEN_\1, \1_\2 ),%g&#39;
 47     8. Now, a bit farther down, add the name of the enum itself to the end of names_UDebugEnumType
 48           ( UDebugEnumType is an enum, too!)
 49         names_UDebugEnumType[] { ...
 50             &quot; FIELD_NAME_STR( LEN_UDBG, UDBG_UShoeSize ),   &quot;
 51     9. Find the function _udbg_enumCount  and add the count macro:
 52             &quot; COUNT_CASE(UShoeSize)
 53    10. Find the function _udbg_enumFields  and add the field macro:
 54             &quot; FIELD_CASE(UShoeSize)
 55    11. verify that your test code, and Java data generation, works properly.
 56 */
 57 
 58 /**
 59  * Structure representing an enum value
 60  */
 61 struct Field {
 62     int32_t prefix;   /**&lt; how many characters to remove in the prefix - i.e. UCHAR_ = 5 */
 63     const char *str;  /**&lt; The actual string value */
 64     int32_t num;      /**&lt; The numeric value */
 65 };
 66 
 67 /**
 68  * Define another field name. Used in an array of Field s
 69  * @param y the common prefix length (i.e. 6 for &quot;USHOE_&quot; )
 70  * @param x the actual enum value - it will be copied in both string and symbolic form.
 71  * @see Field
 72  */
 73 #define FIELD_NAME_STR(y,x)  { y, #x, x }
 74 
 75 
 76 // TODO: Currently, this whole functionality goes away with UCONFIG_NO_FORMATTING. Should be split up.
 77 #if !UCONFIG_NO_FORMATTING
 78 
 79 // Calendar
 80 #include &quot;unicode/ucal.h&quot;
 81 
 82 // &#39;UCAL_&#39; = 5
 83 #define LEN_UCAL 5 /* UCAL_ */
 84 static const int32_t count_UCalendarDateFields = UCAL_FIELD_COUNT;
 85 static const Field names_UCalendarDateFields[] =
 86 {
 87     FIELD_NAME_STR( LEN_UCAL, UCAL_ERA ),
 88     FIELD_NAME_STR( LEN_UCAL, UCAL_YEAR ),
 89     FIELD_NAME_STR( LEN_UCAL, UCAL_MONTH ),
 90     FIELD_NAME_STR( LEN_UCAL, UCAL_WEEK_OF_YEAR ),
 91     FIELD_NAME_STR( LEN_UCAL, UCAL_WEEK_OF_MONTH ),
 92     FIELD_NAME_STR( LEN_UCAL, UCAL_DATE ),
 93     FIELD_NAME_STR( LEN_UCAL, UCAL_DAY_OF_YEAR ),
 94     FIELD_NAME_STR( LEN_UCAL, UCAL_DAY_OF_WEEK ),
 95     FIELD_NAME_STR( LEN_UCAL, UCAL_DAY_OF_WEEK_IN_MONTH ),
 96     FIELD_NAME_STR( LEN_UCAL, UCAL_AM_PM ),
 97     FIELD_NAME_STR( LEN_UCAL, UCAL_HOUR ),
 98     FIELD_NAME_STR( LEN_UCAL, UCAL_HOUR_OF_DAY ),
 99     FIELD_NAME_STR( LEN_UCAL, UCAL_MINUTE ),
100     FIELD_NAME_STR( LEN_UCAL, UCAL_SECOND ),
101     FIELD_NAME_STR( LEN_UCAL, UCAL_MILLISECOND ),
102     FIELD_NAME_STR( LEN_UCAL, UCAL_ZONE_OFFSET ),
103     FIELD_NAME_STR( LEN_UCAL, UCAL_DST_OFFSET ),
104     FIELD_NAME_STR( LEN_UCAL, UCAL_YEAR_WOY ),
105     FIELD_NAME_STR( LEN_UCAL, UCAL_DOW_LOCAL ),
106     FIELD_NAME_STR( LEN_UCAL, UCAL_EXTENDED_YEAR ),
107     FIELD_NAME_STR( LEN_UCAL, UCAL_JULIAN_DAY ),
108     FIELD_NAME_STR( LEN_UCAL, UCAL_MILLISECONDS_IN_DAY ),
109     FIELD_NAME_STR( LEN_UCAL, UCAL_IS_LEAP_MONTH ),
110 };
111 
112 
113 static const int32_t count_UCalendarMonths = UCAL_UNDECIMBER+1;
114 static const Field names_UCalendarMonths[] =
115 {
116   FIELD_NAME_STR( LEN_UCAL, UCAL_JANUARY ),
117   FIELD_NAME_STR( LEN_UCAL, UCAL_FEBRUARY ),
118   FIELD_NAME_STR( LEN_UCAL, UCAL_MARCH ),
119   FIELD_NAME_STR( LEN_UCAL, UCAL_APRIL ),
120   FIELD_NAME_STR( LEN_UCAL, UCAL_MAY ),
121   FIELD_NAME_STR( LEN_UCAL, UCAL_JUNE ),
122   FIELD_NAME_STR( LEN_UCAL, UCAL_JULY ),
123   FIELD_NAME_STR( LEN_UCAL, UCAL_AUGUST ),
124   FIELD_NAME_STR( LEN_UCAL, UCAL_SEPTEMBER ),
125   FIELD_NAME_STR( LEN_UCAL, UCAL_OCTOBER ),
126   FIELD_NAME_STR( LEN_UCAL, UCAL_NOVEMBER ),
127   FIELD_NAME_STR( LEN_UCAL, UCAL_DECEMBER ),
128   FIELD_NAME_STR( LEN_UCAL, UCAL_UNDECIMBER)
129 };
130 
131 #include &quot;unicode/udat.h&quot;
132 
133 #define LEN_UDAT 5 /* &quot;UDAT_&quot; */
134 static const int32_t count_UDateFormatStyle = UDAT_SHORT+1;
135 static const Field names_UDateFormatStyle[] =
136 {
137         FIELD_NAME_STR( LEN_UDAT, UDAT_FULL ),
138         FIELD_NAME_STR( LEN_UDAT, UDAT_LONG ),
139         FIELD_NAME_STR( LEN_UDAT, UDAT_MEDIUM ),
140         FIELD_NAME_STR( LEN_UDAT, UDAT_SHORT ),
141         /* end regular */
142     /*
143      *  negative enums.. leave out for now.
144         FIELD_NAME_STR( LEN_UDAT, UDAT_NONE ),
145         FIELD_NAME_STR( LEN_UDAT, UDAT_PATTERN ),
146      */
147 };
148 
149 #endif
150 
151 #include &quot;unicode/uloc.h&quot;
152 
153 #define LEN_UAR 12 /* &quot;ULOC_ACCEPT_&quot; */
154 static const int32_t count_UAcceptResult = 3;
155 static const Field names_UAcceptResult[] =
156 {
157         FIELD_NAME_STR( LEN_UAR, ULOC_ACCEPT_FAILED ),
158         FIELD_NAME_STR( LEN_UAR, ULOC_ACCEPT_VALID ),
159         FIELD_NAME_STR( LEN_UAR, ULOC_ACCEPT_FALLBACK ),
160 };
161 
162 #if !UCONFIG_NO_COLLATION
163 #include &quot;unicode/ucol.h&quot;
164 #define LEN_UCOL 5 /* UCOL_ */
165 static const int32_t count_UColAttributeValue = UCOL_ATTRIBUTE_VALUE_COUNT;
166 static const Field names_UColAttributeValue[]  = {
167    FIELD_NAME_STR( LEN_UCOL, UCOL_PRIMARY ),
168    FIELD_NAME_STR( LEN_UCOL, UCOL_SECONDARY ),
169    FIELD_NAME_STR( LEN_UCOL, UCOL_TERTIARY ),
170 //   FIELD_NAME_STR( LEN_UCOL, UCOL_CE_STRENGTH_LIMIT ),
171    FIELD_NAME_STR( LEN_UCOL, UCOL_QUATERNARY ),
172    // gap
173    FIELD_NAME_STR( LEN_UCOL, UCOL_IDENTICAL ),
174 //   FIELD_NAME_STR( LEN_UCOL, UCOL_STRENGTH_LIMIT ),
175    FIELD_NAME_STR( LEN_UCOL, UCOL_OFF ),
176    FIELD_NAME_STR( LEN_UCOL, UCOL_ON ),
177    // gap
178    FIELD_NAME_STR( LEN_UCOL, UCOL_SHIFTED ),
179    FIELD_NAME_STR( LEN_UCOL, UCOL_NON_IGNORABLE ),
180    // gap
181    FIELD_NAME_STR( LEN_UCOL, UCOL_LOWER_FIRST ),
182    FIELD_NAME_STR( LEN_UCOL, UCOL_UPPER_FIRST ),
183 };
184 
185 #endif
186 
187 
188 #if UCONFIG_ENABLE_PLUGINS
189 #include &quot;unicode/icuplug.h&quot;
190 
191 #define LEN_UPLUG_REASON 13 /* UPLUG_REASON_ */
192 static const int32_t count_UPlugReason = UPLUG_REASON_COUNT;
193 static const Field names_UPlugReason[]  = {
194    FIELD_NAME_STR( LEN_UPLUG_REASON, UPLUG_REASON_QUERY ),
195    FIELD_NAME_STR( LEN_UPLUG_REASON, UPLUG_REASON_LOAD ),
196    FIELD_NAME_STR( LEN_UPLUG_REASON, UPLUG_REASON_UNLOAD ),
197 };
198 
199 #define LEN_UPLUG_LEVEL 12 /* UPLUG_LEVEL_ */
200 static const int32_t count_UPlugLevel = UPLUG_LEVEL_COUNT;
201 static const Field names_UPlugLevel[]  = {
202    FIELD_NAME_STR( LEN_UPLUG_LEVEL, UPLUG_LEVEL_INVALID ),
203    FIELD_NAME_STR( LEN_UPLUG_LEVEL, UPLUG_LEVEL_UNKNOWN ),
204    FIELD_NAME_STR( LEN_UPLUG_LEVEL, UPLUG_LEVEL_LOW ),
205    FIELD_NAME_STR( LEN_UPLUG_LEVEL, UPLUG_LEVEL_HIGH ),
206 };
207 #endif
208 
209 #define LEN_UDBG 5 /* &quot;UDBG_&quot; */
210 static const int32_t count_UDebugEnumType = UDBG_ENUM_COUNT;
211 static const Field names_UDebugEnumType[] =
212 {
213     FIELD_NAME_STR( LEN_UDBG, UDBG_UDebugEnumType ),
214 #if !UCONFIG_NO_FORMATTING
215     FIELD_NAME_STR( LEN_UDBG, UDBG_UCalendarDateFields ),
216     FIELD_NAME_STR( LEN_UDBG, UDBG_UCalendarMonths ),
217     FIELD_NAME_STR( LEN_UDBG, UDBG_UDateFormatStyle ),
218 #endif
219 #if UCONFIG_ENABLE_PLUGINS
220     FIELD_NAME_STR( LEN_UDBG, UDBG_UPlugReason ),
221     FIELD_NAME_STR( LEN_UDBG, UDBG_UPlugLevel ),
222 #endif
223     FIELD_NAME_STR( LEN_UDBG, UDBG_UAcceptResult ),
224 #if !UCONFIG_NO_COLLATION
225     FIELD_NAME_STR( LEN_UDBG, UDBG_UColAttributeValue ),
226 #endif
227 };
228 
229 
230 // --- Add new enum types above this line ---
231 
232 #define COUNT_CASE(x)  case UDBG_##x: return (actual?count_##x:UPRV_LENGTHOF(names_##x));
233 #define COUNT_FAIL_CASE(x) case UDBG_##x: return -1;
234 
235 #define FIELD_CASE(x)  case UDBG_##x: return names_##x;
236 #define FIELD_FAIL_CASE(x) case UDBG_##x: return NULL;
237 
238 // low level
239 
240 /**
241  * @param type type of item
242  * @param actual TRUE: for the actual enum&#39;s type (UCAL_FIELD_COUNT, etc), or FALSE for the string count
243  */
244 static int32_t _udbg_enumCount(UDebugEnumType type, UBool actual) {
245     switch(type) {
246         COUNT_CASE(UDebugEnumType)
247 #if !UCONFIG_NO_FORMATTING
248         COUNT_CASE(UCalendarDateFields)
249         COUNT_CASE(UCalendarMonths)
250         COUNT_CASE(UDateFormatStyle)
251 #endif
252 #if UCONFIG_ENABLE_PLUGINS
253         COUNT_CASE(UPlugReason)
254         COUNT_CASE(UPlugLevel)
255 #endif
256         COUNT_CASE(UAcceptResult)
257 #if !UCONFIG_NO_COLLATION
258         COUNT_CASE(UColAttributeValue)
259 #endif
260         // COUNT_FAIL_CASE(UNonExistentEnum)
261     default:
262         return -1;
263     }
264 }
265 
266 static const Field* _udbg_enumFields(UDebugEnumType type) {
267     switch(type) {
268         FIELD_CASE(UDebugEnumType)
269 #if !UCONFIG_NO_FORMATTING
270         FIELD_CASE(UCalendarDateFields)
271         FIELD_CASE(UCalendarMonths)
272         FIELD_CASE(UDateFormatStyle)
273 #endif
274 #if UCONFIG_ENABLE_PLUGINS
275         FIELD_CASE(UPlugReason)
276         FIELD_CASE(UPlugLevel)
277 #endif
278         FIELD_CASE(UAcceptResult)
279        // FIELD_FAIL_CASE(UNonExistentEnum)
280 #if !UCONFIG_NO_COLLATION
281         FIELD_CASE(UColAttributeValue)
282 #endif
283     default:
284         return NULL;
285     }
286 }
287 
288 // implementation
289 
290 int32_t  udbg_enumCount(UDebugEnumType type) {
291     return _udbg_enumCount(type, FALSE);
292 }
293 
294 int32_t  udbg_enumExpectedCount(UDebugEnumType type) {
295     return _udbg_enumCount(type, TRUE);
296 }
297 
298 const char *  udbg_enumName(UDebugEnumType type, int32_t field) {
299     if(field&lt;0 ||
300                 field&gt;=_udbg_enumCount(type,FALSE)) { // also will catch unsupported items
301         return NULL;
302     } else {
303         const Field *fields = _udbg_enumFields(type);
304         if(fields == NULL) {
305             return NULL;
306         } else {
307             return fields[field].str + fields[field].prefix;
308         }
309     }
310 }
311 
312 int32_t  udbg_enumArrayValue(UDebugEnumType type, int32_t field) {
313     if(field&lt;0 ||
314                 field&gt;=_udbg_enumCount(type,FALSE)) { // also will catch unsupported items
315         return -1;
316     } else {
317         const Field *fields = _udbg_enumFields(type);
318         if(fields == NULL) {
319             return -1;
320         } else {
321             return fields[field].num;
322         }
323     }
324 }
325 
326 int32_t udbg_enumByName(UDebugEnumType type, const char *value) {
327     if(type&lt;0||type&gt;=_udbg_enumCount(UDBG_UDebugEnumType, TRUE)) {
328         return -1; // type out of range
329     }
330     const Field *fields = _udbg_enumFields(type);
331     if (fields != NULL) {
332         for(int32_t field = 0;field&lt;_udbg_enumCount(type, FALSE);field++) {
333             if(!strcmp(value, fields[field].str + fields[field].prefix)) {
334                 return fields[field].num;
335             }
336         }
337         // try with the prefix
338         for(int32_t field = 0;field&lt;_udbg_enumCount(type, FALSE);field++) {
339             if(!strcmp(value, fields[field].str)) {
340                 return fields[field].num;
341             }
342         }
343     }
344     // fail
345     return -1;
346 }
347 
348 /* platform info */
349 /**
350  * Print the current platform
351  */
352 U_CAPI const char *udbg_getPlatform(void)
353 {
354 #if U_PLATFORM_USES_ONLY_WIN32_API
355     return &quot;Windows&quot;;
356 #elif U_PLATFORM == U_PF_CYGWIN
357     return &quot;Cygwin&quot;;
358 #elif U_PLATFORM == U_PF_UNKNOWN
359     return &quot;unknown&quot;;
360 #elif U_PLATFORM == U_PF_DARWIN
361     return &quot;Darwin&quot;;
362 #elif U_PLATFORM == U_PF_BSD
363     return &quot;BSD&quot;;
364 #elif U_PLATFORM == U_PF_QNX
365     return &quot;QNX&quot;;
366 #elif U_PLATFORM == U_PF_LINUX
367     return &quot;Linux&quot;;
368 #elif U_PLATFORM == U_PF_ANDROID
369     return &quot;Android&quot;;
370 #elif U_PLATFORM == U_PF_CLASSIC_MACOS
371     return &quot;MacOS (Classic)&quot;;
372 #elif U_PLATFORM == U_PF_OS390
373     return &quot;IBM z&quot;;
374 #elif U_PLATFORM == U_PF_OS400
375     return &quot;IBM i&quot;;
376 #else
377     return &quot;Other (POSIX-like)&quot;;
378 #endif
379 }
380 
381 struct USystemParams;
382 
383 typedef int32_t U_CALLCONV USystemParameterCallback(const USystemParams *param, char *target, int32_t targetCapacity, UErrorCode *status);
384 
385 struct USystemParams {
386   const char *paramName;
387   USystemParameterCallback *paramFunction;
388   const char *paramStr;
389   int32_t paramInt;
390 };
391 
392 /* parameter types */
393 U_CAPI  int32_t
394 paramEmpty(const USystemParams * /* param */, char *target, int32_t targetCapacity, UErrorCode *status) {
395   if(U_FAILURE(*status))return 0;
396   return u_terminateChars(target, targetCapacity, 0, status);
397 }
398 
399 U_CAPI  int32_t
400 paramStatic(const USystemParams *param, char *target, int32_t targetCapacity, UErrorCode *status) {
401   if(param-&gt;paramStr==NULL) return paramEmpty(param,target,targetCapacity,status);
402   if(U_FAILURE(*status))return 0;
403   int32_t len = static_cast&lt;int32_t&gt;(uprv_strlen(param-&gt;paramStr));
404   if(target!=NULL) {
405     uprv_strncpy(target,param-&gt;paramStr,uprv_min(len,targetCapacity));
406   }
407   return u_terminateChars(target, targetCapacity, len, status);
408 }
409 
410 static const char *nullString = &quot;(null)&quot;;
411 
412 static int32_t stringToStringBuffer(char *target, int32_t targetCapacity, const char *str, UErrorCode *status) {
413   if(str==NULL) str=nullString;
414 
415   int32_t len = static_cast&lt;int32_t&gt;(uprv_strlen(str));
416   if (U_SUCCESS(*status)) {
417     if(target!=NULL) {
418       uprv_strncpy(target,str,uprv_min(len,targetCapacity));
419     }
420   } else {
421     const char *s = u_errorName(*status);
422     len = static_cast&lt;int32_t&gt;(uprv_strlen(s));
423     if(target!=NULL) {
424       uprv_strncpy(target,s,uprv_min(len,targetCapacity));
425     }
426   }
427   return u_terminateChars(target, targetCapacity, len, status);
428 }
429 
430 static int32_t integerToStringBuffer(char *target, int32_t targetCapacity, int32_t n, int32_t radix, UErrorCode *status) {
431   if(U_FAILURE(*status)) return 0;
432   char str[300];
433   T_CString_integerToString(str,n,radix);
434   return stringToStringBuffer(target,targetCapacity,str,status);
435 }
436 
437 U_CAPI  int32_t
438 paramInteger(const USystemParams *param, char *target, int32_t targetCapacity, UErrorCode *status) {
439   if(U_FAILURE(*status))return 0;
440   if(param-&gt;paramStr==NULL || param-&gt;paramStr[0]==&#39;d&#39;) {
441     return integerToStringBuffer(target,targetCapacity,param-&gt;paramInt, 10,status);
442   } else if(param-&gt;paramStr[0]==&#39;x&#39;) {
443     return integerToStringBuffer(target,targetCapacity,param-&gt;paramInt, 16,status);
444   } else if(param-&gt;paramStr[0]==&#39;o&#39;) {
445     return integerToStringBuffer(target,targetCapacity,param-&gt;paramInt, 8,status);
446   } else if(param-&gt;paramStr[0]==&#39;b&#39;) {
447     return integerToStringBuffer(target,targetCapacity,param-&gt;paramInt, 2,status);
448   } else {
449     *status = U_INTERNAL_PROGRAM_ERROR;
450     return 0;
451   }
452 }
453 
454 
455 U_CAPI  int32_t
456 paramCldrVersion(const USystemParams * /* param */, char *target, int32_t targetCapacity, UErrorCode *status) {
457   if(U_FAILURE(*status))return 0;
458   char str[200]=&quot;&quot;;
459   UVersionInfo icu;
460 
461   ulocdata_getCLDRVersion(icu, status);
462   if(U_SUCCESS(*status)) {
463     u_versionToString(icu, str);
464     return stringToStringBuffer(target,targetCapacity,str,status);
465   } else {
466     return 0;
467   }
468 }
469 
470 
471 #if !UCONFIG_NO_FORMATTING
472 U_CAPI  int32_t
473 paramTimezoneDefault(const USystemParams * /* param */, char *target, int32_t targetCapacity, UErrorCode *status) {
474   if(U_FAILURE(*status))return 0;
475   UChar buf[100];
476   char buf2[100];
477   int32_t len;
478 
479   len = ucal_getDefaultTimeZone(buf, 100, status);
480   if(U_SUCCESS(*status)&amp;&amp;len&gt;0) {
481     u_UCharsToChars(buf, buf2, len+1);
482     return stringToStringBuffer(target,targetCapacity, buf2,status);
483   } else {
484     return 0;
485   }
486 }
487 #endif
488 
489 U_CAPI  int32_t
490 paramLocaleDefaultBcp47(const USystemParams * /* param */, char *target, int32_t targetCapacity, UErrorCode *status) {
491   if(U_FAILURE(*status))return 0;
492   const char *def = uloc_getDefault();
493   return uloc_toLanguageTag(def,target,targetCapacity,FALSE,status);
494 }
495 
496 
497 /* simple 1-liner param functions */
498 #define STRING_PARAM(func, str) U_CAPI  int32_t \
499   func(const USystemParams *, char *target, int32_t targetCapacity, UErrorCode *status) \
500   {  return stringToStringBuffer(target,targetCapacity,(str),status); }
501 
502 STRING_PARAM(paramIcudataPath, u_getDataDirectory())
503 STRING_PARAM(paramPlatform, udbg_getPlatform())
504 STRING_PARAM(paramLocaleDefault, uloc_getDefault())
505 #if !UCONFIG_NO_CONVERSION
506 STRING_PARAM(paramConverterDefault, ucnv_getDefaultName())
507 #endif
508 
509 #if !UCONFIG_NO_FORMATTING
510 STRING_PARAM(paramTimezoneVersion, ucal_getTZDataVersion(status))
511 #endif
512 
513 static const USystemParams systemParams[] = {
514   { &quot;copyright&quot;,    paramStatic, U_COPYRIGHT_STRING,0 },
515   { &quot;product&quot;,      paramStatic, &quot;icu4c&quot;,0 },
516   { &quot;product.full&quot;, paramStatic, &quot;International Components for Unicode for C/C++&quot;,0 },
517   { &quot;version&quot;,      paramStatic, U_ICU_VERSION,0 },
518   { &quot;version.unicode&quot;, paramStatic, U_UNICODE_VERSION,0 },
519   { &quot;platform.number&quot;, paramInteger, &quot;d&quot;,U_PLATFORM},
520   { &quot;platform.type&quot;, paramPlatform, NULL ,0},
521   { &quot;locale.default&quot;, paramLocaleDefault, NULL, 0},
522   { &quot;locale.default.bcp47&quot;, paramLocaleDefaultBcp47, NULL, 0},
523 #if !UCONFIG_NO_CONVERSION
524   { &quot;converter.default&quot;, paramConverterDefault, NULL, 0},
525 #endif
526   { &quot;icudata.name&quot;, paramStatic, U_ICUDATA_NAME, 0},
527   { &quot;icudata.path&quot;, paramIcudataPath, NULL, 0},
528 
529   { &quot;cldr.version&quot;, paramCldrVersion, NULL, 0},
530 
531 #if !UCONFIG_NO_FORMATTING
532   { &quot;tz.version&quot;, paramTimezoneVersion, NULL, 0},
533   { &quot;tz.default&quot;, paramTimezoneDefault, NULL, 0},
534 #endif
535 
536   { &quot;cpu.bits&quot;,       paramInteger, &quot;d&quot;, (sizeof(void*))*8},
537   { &quot;cpu.big_endian&quot;, paramInteger, &quot;b&quot;, U_IS_BIG_ENDIAN},
538   { &quot;os.wchar_width&quot;, paramInteger, &quot;d&quot;, U_SIZEOF_WCHAR_T},
539   { &quot;os.charset_family&quot;, paramInteger, &quot;d&quot;, U_CHARSET_FAMILY},
540 #if defined (U_HOST)
541   { &quot;os.host&quot;, paramStatic, U_HOST, 0},
542 #endif
543 #if defined (U_BUILD)
544   { &quot;build.build&quot;, paramStatic, U_BUILD, 0},
545 #endif
546 #if defined (U_CC)
547   { &quot;build.cc&quot;, paramStatic, U_CC, 0},
548 #endif
549 #if defined (U_CXX)
550   { &quot;build.cxx&quot;, paramStatic, U_CXX, 0},
551 #endif
552 #if defined (CYGWINMSVC)
553   { &quot;build.cygwinmsvc&quot;, paramInteger, &quot;b&quot;, 1},
554 #endif
555   { &quot;uconfig.internal_digitlist&quot;, paramInteger, &quot;b&quot;, 1}, /* always 1 */
556   { &quot;uconfig.have_parseallinput&quot;, paramInteger, &quot;b&quot;, UCONFIG_HAVE_PARSEALLINPUT},
557 
558 
559 };
560 
561 #define U_SYSPARAM_COUNT UPRV_LENGTHOF(systemParams)
562 
563 U_CAPI const char *udbg_getSystemParameterNameByIndex(int32_t i) {
564   if(i&gt;=0 &amp;&amp; i &lt; (int32_t)U_SYSPARAM_COUNT) {
565     return systemParams[i].paramName;
566   } else {
567     return NULL;
568   }
569 }
570 
571 
572 U_CAPI int32_t udbg_getSystemParameterValueByIndex(int32_t i, char *buffer, int32_t bufferCapacity, UErrorCode *status) {
573   if(i&gt;=0 &amp;&amp; i&lt; (int32_t)U_SYSPARAM_COUNT) {
574     return systemParams[i].paramFunction(&amp;(systemParams[i]),buffer,bufferCapacity,status);
575   } else {
576     return 0;
577   }
578 }
579 
580 U_CAPI void udbg_writeIcuInfo(FILE *out) {
581   char str[2000];
582   /* todo: API for writing DTD? */
583   fprintf(out, &quot; &lt;icuSystemParams type=\&quot;icu4c\&quot;&gt;\n&quot;);
584   const char *paramName;
585   for(int32_t i=0;(paramName=udbg_getSystemParameterNameByIndex(i))!=NULL;i++) {
586     UErrorCode status2 = U_ZERO_ERROR;
587     udbg_getSystemParameterValueByIndex(i, str,2000,&amp;status2);
588     if(U_SUCCESS(status2)) {
589       fprintf(out,&quot;    &lt;param name=\&quot;%s\&quot;&gt;%s&lt;/param&gt;\n&quot;, paramName,str);
590     } else {
591       fprintf(out,&quot;  &lt;!-- n=\&quot;%s\&quot; ERROR: %s --&gt;\n&quot;, paramName, u_errorName(status2));
592     }
593   }
594   fprintf(out, &quot; &lt;/icuSystemParams&gt;\n&quot;);
595 }
596 
597 #define ICU_TRAC_URL &quot;http://bugs.icu-project.org/trac/ticket/&quot;
598 #define CLDR_TRAC_URL &quot;http://unicode.org/cldr/trac/ticket/&quot;
599 #define CLDR_TICKET_PREFIX &quot;cldrbug:&quot;
600 
601 U_CAPI char *udbg_knownIssueURLFrom(const char *ticket, char *buf) {
602   if( ticket==NULL ) {
603     return NULL;
604   }
605 
606   if( !strncmp(ticket, CLDR_TICKET_PREFIX, strlen(CLDR_TICKET_PREFIX)) ) {
607     strcpy( buf, CLDR_TRAC_URL );
608     strcat( buf, ticket+strlen(CLDR_TICKET_PREFIX) );
609   } else {
610     strcpy( buf, ICU_TRAC_URL );
611     strcat( buf, ticket );
612   }
613   return buf;
614 }
615 
616 
617 #include &lt;set&gt;
618 #include &lt;map&gt;
619 #include &lt;string&gt;
620 #include &lt;ostream&gt;
621 #include &lt;iostream&gt;
622 
623 class KnownIssues {
624 public:
625   KnownIssues();
626   ~KnownIssues();
627   void add(const char *ticket, const char *where, const UChar *msg, UBool *firstForTicket, UBool *firstForWhere);
628   void add(const char *ticket, const char *where, const char *msg, UBool *firstForTicket, UBool *firstForWhere);
629   UBool print();
630 private:
631   std::map&lt; std::string,
632             std::map &lt; std::string, std::set &lt; std::string &gt; &gt; &gt; fTable;
633 };
634 
635 KnownIssues::KnownIssues()
636   : fTable()
637 {
638 }
639 
640 KnownIssues::~KnownIssues()
641 {
642 }
643 
644 void KnownIssues::add(const char *ticket, const char *where, const UChar *msg, UBool *firstForTicket, UBool *firstForWhere)
645 {
646   if(fTable.find(ticket) == fTable.end()) {
647     if(firstForTicket!=NULL) *firstForTicket = TRUE;
648     fTable[ticket] = std::map &lt; std::string, std::set &lt; std::string &gt; &gt;();
649   } else {
650     if(firstForTicket!=NULL) *firstForTicket = FALSE;
651   }
652   if(where==NULL) return;
653 
654   if(fTable[ticket].find(where) == fTable[ticket].end()) {
655     if(firstForWhere!=NULL) *firstForWhere = TRUE;
656     fTable[ticket][where] = std::set &lt; std::string &gt;();
657   } else {
658     if(firstForWhere!=NULL) *firstForWhere = FALSE;
659   }
660   if(msg==NULL || !*msg) return;
661 
662   const icu::UnicodeString ustr(msg);
663 
664   fTable[ticket][where].insert(std::string(icu::CStr(ustr)()));
665 }
666 
667 void KnownIssues::add(const char *ticket, const char *where, const char *msg, UBool *firstForTicket, UBool *firstForWhere)
668 {
669   if(fTable.find(ticket) == fTable.end()) {
670     if(firstForTicket!=NULL) *firstForTicket = TRUE;
671     fTable[ticket] = std::map &lt; std::string, std::set &lt; std::string &gt; &gt;();
672   } else {
673     if(firstForTicket!=NULL) *firstForTicket = FALSE;
674   }
675   if(where==NULL) return;
676 
677   if(fTable[ticket].find(where) == fTable[ticket].end()) {
678     if(firstForWhere!=NULL) *firstForWhere = TRUE;
679     fTable[ticket][where] = std::set &lt; std::string &gt;();
680   } else {
681     if(firstForWhere!=NULL) *firstForWhere = FALSE;
682   }
683   if(msg==NULL || !*msg) return;
684 
685   std::string str(msg);
686   fTable[ticket][where].insert(str);
687 }
688 
689 UBool KnownIssues::print()
690 {
691   if(fTable.empty()) {
692     return FALSE;
693   }
694 
695   std::cout &lt;&lt; &quot;KNOWN ISSUES&quot; &lt;&lt; std::endl;
696   for( std::map&lt;  std::string,
697           std::map &lt;  std::string,  std::set &lt;  std::string &gt; &gt; &gt;::iterator i = fTable.begin();
698        i != fTable.end();
699        i++ ) {
700     char URL[1024];
701     std::cout &lt;&lt; &#39;#&#39; &lt;&lt; (*i).first &lt;&lt; &quot; &lt;&quot; &lt;&lt; udbg_knownIssueURLFrom( (*i).first.c_str(), URL ) &lt;&lt; &quot;&gt;&quot; &lt;&lt; std::endl;
702 
703     for( std::map&lt; std::string, std::set &lt; std::string &gt; &gt;::iterator ii = (*i).second.begin();
704          ii != (*i).second.end();
705          ii++ ) {
706       std::cout &lt;&lt; &quot;  &quot; &lt;&lt; (*ii).first &lt;&lt; std::endl;
707       for ( std::set &lt; std::string &gt;::iterator iii = (*ii).second.begin();
708             iii != (*ii).second.end();
709             iii++ ) {
710         std::cout &lt;&lt; &quot;     &quot; &lt;&lt; &#39;&quot;&#39; &lt;&lt; (*iii) &lt;&lt; &#39;&quot;&#39; &lt;&lt; std::endl;
711       }
712     }
713   }
714   return TRUE;
715 }
716 
717 U_CAPI void *udbg_knownIssue_openU(void *ptr, const char *ticket, char *where, const UChar *msg, UBool *firstForTicket,
718                                    UBool *firstForWhere) {
719   KnownIssues *t = static_cast&lt;KnownIssues*&gt;(ptr);
720   if(t==NULL) {
721     t = new KnownIssues();
722   }
723 
724   t-&gt;add(ticket, where, msg, firstForTicket, firstForWhere);
725 
726   return static_cast&lt;void*&gt;(t);
727 }
728 
729 U_CAPI void *udbg_knownIssue_open(void *ptr, const char *ticket, char *where, const char *msg, UBool *firstForTicket,
730                                    UBool *firstForWhere) {
731   KnownIssues *t = static_cast&lt;KnownIssues*&gt;(ptr);
732   if(t==NULL) {
733     t = new KnownIssues();
734   }
735 
736   t-&gt;add(ticket, where, msg, firstForTicket, firstForWhere);
737 
738   return static_cast&lt;void*&gt;(t);
739 }
740 
741 U_CAPI UBool udbg_knownIssue_print(void *ptr) {
742   KnownIssues *t = static_cast&lt;KnownIssues*&gt;(ptr);
743   if(t==NULL) {
744     return FALSE;
745   } else {
746     t-&gt;print();
747     return TRUE;
748   }
749 }
750 
751 U_CAPI void udbg_knownIssue_close(void *ptr) {
752   KnownIssues *t = static_cast&lt;KnownIssues*&gt;(ptr);
753   delete t;
754 }
    </pre>
  </body>
</html>