<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rematch.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="reldtfmt.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rulebasedcollator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rematch.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 700             MatchAt(startPos, FALSE, status);
 701             if (U_FAILURE(status)) {
 702                 return FALSE;
 703             }
 704             if (fMatch) {
 705                 return TRUE;
 706             }
 707             if (startPos &gt;= testStartLimit) {
 708                 fHitEnd = TRUE;
 709                 return FALSE;
 710             }
 711             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 712             (void)UTEXT_NEXT32(fInputText);
 713             startPos = UTEXT_GETNATIVEINDEX(fInputText);
 714             // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 715             //   match at the end of a string, so we must make sure that the loop
 716             //   runs with startPos == testStartLimit the last time through.
 717             if  (findProgressInterrupt(startPos, status))
 718                 return FALSE;
 719         }
<span class="line-modified"> 720         U_ASSERT(FALSE);</span>
 721 
 722     case START_START:
 723         // Matches are only possible at the start of the input string
 724         //   (pattern begins with ^ or \A)
 725         if (startPos &gt; fActiveStart) {
 726             fMatch = FALSE;
 727             return FALSE;
 728         }
 729         MatchAt(startPos, FALSE, status);
 730         if (U_FAILURE(status)) {
 731             return FALSE;
 732         }
 733         return fMatch;
 734 
 735 
 736     case START_SET:
 737         {
 738             // Match may start on any char from a pre-computed set.
 739             U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
 740             UTEXT_SETNATIVEINDEX(fInputText, startPos);
</pre>
<hr />
<pre>
 748                 if (c &gt;= 0 &amp;&amp; ((c&lt;256 &amp;&amp; fPattern-&gt;fInitialChars8-&gt;contains(c)) ||
 749                               (c&gt;=256 &amp;&amp; fPattern-&gt;fInitialChars-&gt;contains(c)))) {
 750                     MatchAt(pos, FALSE, status);
 751                     if (U_FAILURE(status)) {
 752                         return FALSE;
 753                     }
 754                     if (fMatch) {
 755                         return TRUE;
 756                     }
 757                     UTEXT_SETNATIVEINDEX(fInputText, pos);
 758                 }
 759                 if (startPos &gt; testStartLimit) {
 760                     fMatch = FALSE;
 761                     fHitEnd = TRUE;
 762                     return FALSE;
 763                 }
 764                 if  (findProgressInterrupt(startPos, status))
 765                     return FALSE;
 766             }
 767         }
<span class="line-modified"> 768         U_ASSERT(FALSE);</span>
 769 
 770     case START_STRING:
 771     case START_CHAR:
 772         {
 773             // Match starts on exactly one char.
 774             U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
 775             UChar32 theChar = fPattern-&gt;fInitialChar;
 776             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 777             for (;;) {
 778                 int64_t pos = startPos;
 779                 c = UTEXT_NEXT32(fInputText);
 780                 startPos = UTEXT_GETNATIVEINDEX(fInputText);
 781                 if (c == theChar) {
 782                     MatchAt(pos, FALSE, status);
 783                     if (U_FAILURE(status)) {
 784                         return FALSE;
 785                     }
 786                     if (fMatch) {
 787                         return TRUE;
 788                     }
 789                     UTEXT_SETNATIVEINDEX(fInputText, startPos);
 790                 }
 791                 if (startPos &gt; testStartLimit) {
 792                     fMatch = FALSE;
 793                     fHitEnd = TRUE;
 794                     return FALSE;
 795                 }
 796                 if  (findProgressInterrupt(startPos, status))
 797                     return FALSE;
 798            }
 799         }
<span class="line-modified"> 800         U_ASSERT(FALSE);</span>
 801 
 802     case START_LINE:
 803         {
<span class="line-modified"> 804             UChar32  c;</span>
 805             if (startPos == fAnchorStart) {
 806                 MatchAt(startPos, FALSE, status);
 807                 if (U_FAILURE(status)) {
 808                     return FALSE;
 809                 }
 810                 if (fMatch) {
 811                     return TRUE;
 812                 }
 813                 UTEXT_SETNATIVEINDEX(fInputText, startPos);
<span class="line-modified"> 814                 c = UTEXT_NEXT32(fInputText);</span>
 815                 startPos = UTEXT_GETNATIVEINDEX(fInputText);
 816             } else {
 817                 UTEXT_SETNATIVEINDEX(fInputText, startPos);
<span class="line-modified"> 818                 c = UTEXT_PREVIOUS32(fInputText);</span>
 819                 UTEXT_SETNATIVEINDEX(fInputText, startPos);
 820             }
 821 
 822             if (fPattern-&gt;fFlags &amp; UREGEX_UNIX_LINES) {
 823                 for (;;) {
<span class="line-modified"> 824                     if (c == 0x0a) {</span>
 825                             MatchAt(startPos, FALSE, status);
 826                             if (U_FAILURE(status)) {
 827                                 return FALSE;
 828                             }
 829                             if (fMatch) {
 830                                 return TRUE;
 831                             }
 832                             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 833                     }
 834                     if (startPos &gt;= testStartLimit) {
 835                         fMatch = FALSE;
 836                         fHitEnd = TRUE;
 837                         return FALSE;
 838                     }
<span class="line-modified"> 839                     c = UTEXT_NEXT32(fInputText);</span>
 840                     startPos = UTEXT_GETNATIVEINDEX(fInputText);
 841                     // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 842                     //   match at the end of a string, so we must make sure that the loop
 843                     //   runs with startPos == testStartLimit the last time through.
 844                     if  (findProgressInterrupt(startPos, status))
 845                         return FALSE;
 846                 }
 847             } else {
 848                 for (;;) {
<span class="line-modified"> 849                     if (isLineTerminator(c)) {</span>
<span class="line-modified"> 850                         if (c == 0x0d &amp;&amp; startPos &lt; fActiveLimit &amp;&amp; UTEXT_CURRENT32(fInputText) == 0x0a) {</span>
 851                             (void)UTEXT_NEXT32(fInputText);
 852                             startPos = UTEXT_GETNATIVEINDEX(fInputText);
 853                         }
 854                         MatchAt(startPos, FALSE, status);
 855                         if (U_FAILURE(status)) {
 856                             return FALSE;
 857                         }
 858                         if (fMatch) {
 859                             return TRUE;
 860                         }
 861                         UTEXT_SETNATIVEINDEX(fInputText, startPos);
 862                     }
 863                     if (startPos &gt;= testStartLimit) {
 864                         fMatch = FALSE;
 865                         fHitEnd = TRUE;
 866                         return FALSE;
 867                     }
<span class="line-modified"> 868                     c = UTEXT_NEXT32(fInputText);</span>
 869                     startPos = UTEXT_GETNATIVEINDEX(fInputText);
 870                     // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 871                     //   match at the end of a string, so we must make sure that the loop
 872                     //   runs with startPos == testStartLimit the last time through.
 873                     if  (findProgressInterrupt(startPos, status))
 874                         return FALSE;
 875                 }
 876             }
 877         }
 878 
 879     default:
<span class="line-modified"> 880         U_ASSERT(FALSE);</span>
 881     }
 882 
<span class="line-modified"> 883     U_ASSERT(FALSE);</span>
<span class="line-removed"> 884     return FALSE;</span>
 885 }
 886 
 887 
 888 
 889 UBool RegexMatcher::find(int64_t start, UErrorCode &amp;status) {
 890     if (U_FAILURE(status)) {
 891         return FALSE;
 892     }
 893     if (U_FAILURE(fDeferredStatus)) {
 894         status = fDeferredStatus;
 895         return FALSE;
 896     }
 897     this-&gt;reset();                        // Note:  Reset() is specified by Java Matcher documentation.
 898                                           //        This will reset the region to be the full input length.
 899     if (start &lt; 0) {
 900         status = U_INDEX_OUTOFBOUNDS_ERROR;
 901         return FALSE;
 902     }
 903 
 904     int64_t nativeStart = start;
</pre>
<hr />
<pre>
 975         //  Try a match at each input position.
 976         for (;;) {
 977             MatchChunkAt(startPos, FALSE, status);
 978             if (U_FAILURE(status)) {
 979                 return FALSE;
 980             }
 981             if (fMatch) {
 982                 return TRUE;
 983             }
 984             if (startPos &gt;= testLen) {
 985                 fHitEnd = TRUE;
 986                 return FALSE;
 987             }
 988             U16_FWD_1(inputBuf, startPos, fActiveLimit);
 989             // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 990             //   match at the end of a string, so we must make sure that the loop
 991             //   runs with startPos == testLen the last time through.
 992             if  (findProgressInterrupt(startPos, status))
 993                 return FALSE;
 994         }
<span class="line-modified"> 995         U_ASSERT(FALSE);</span>
 996 
 997     case START_START:
 998         // Matches are only possible at the start of the input string
 999         //   (pattern begins with ^ or \A)
1000         if (startPos &gt; fActiveStart) {
1001             fMatch = FALSE;
1002             return FALSE;
1003         }
1004         MatchChunkAt(startPos, FALSE, status);
1005         if (U_FAILURE(status)) {
1006             return FALSE;
1007         }
1008         return fMatch;
1009 
1010 
1011     case START_SET:
1012     {
1013         // Match may start on any char from a pre-computed set.
1014         U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
1015         for (;;) {
</pre>
<hr />
<pre>
1017             U16_NEXT(inputBuf, startPos, fActiveLimit, c);  // like c = inputBuf[startPos++];
1018             if ((c&lt;256 &amp;&amp; fPattern-&gt;fInitialChars8-&gt;contains(c)) ||
1019                 (c&gt;=256 &amp;&amp; fPattern-&gt;fInitialChars-&gt;contains(c))) {
1020                 MatchChunkAt(pos, FALSE, status);
1021                 if (U_FAILURE(status)) {
1022                     return FALSE;
1023                 }
1024                 if (fMatch) {
1025                     return TRUE;
1026                 }
1027             }
1028             if (startPos &gt; testLen) {
1029                 fMatch = FALSE;
1030                 fHitEnd = TRUE;
1031                 return FALSE;
1032             }
1033             if  (findProgressInterrupt(startPos, status))
1034                 return FALSE;
1035         }
1036     }
<span class="line-modified">1037         U_ASSERT(FALSE);</span>
1038 
1039     case START_STRING:
1040     case START_CHAR:
1041     {
1042         // Match starts on exactly one char.
1043         U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
1044         UChar32 theChar = fPattern-&gt;fInitialChar;
1045         for (;;) {
1046             int32_t pos = startPos;
1047             U16_NEXT(inputBuf, startPos, fActiveLimit, c);  // like c = inputBuf[startPos++];
1048             if (c == theChar) {
1049                 MatchChunkAt(pos, FALSE, status);
1050                 if (U_FAILURE(status)) {
1051                     return FALSE;
1052                 }
1053                 if (fMatch) {
1054                     return TRUE;
1055                 }
1056             }
1057             if (startPos &gt; testLen) {
1058                 fMatch = FALSE;
1059                 fHitEnd = TRUE;
1060                 return FALSE;
1061             }
1062             if  (findProgressInterrupt(startPos, status))
1063                 return FALSE;
1064         }
1065     }
<span class="line-modified">1066     U_ASSERT(FALSE);</span>
1067 
1068     case START_LINE:
1069     {
<span class="line-modified">1070         UChar32  c;</span>
1071         if (startPos == fAnchorStart) {
1072             MatchChunkAt(startPos, FALSE, status);
1073             if (U_FAILURE(status)) {
1074                 return FALSE;
1075             }
1076             if (fMatch) {
1077                 return TRUE;
1078             }
1079             U16_FWD_1(inputBuf, startPos, fActiveLimit);
1080         }
1081 
1082         if (fPattern-&gt;fFlags &amp; UREGEX_UNIX_LINES) {
1083             for (;;) {
<span class="line-modified">1084                 c = inputBuf[startPos-1];</span>
<span class="line-modified">1085                 if (c == 0x0a) {</span>
1086                     MatchChunkAt(startPos, FALSE, status);
1087                     if (U_FAILURE(status)) {
1088                         return FALSE;
1089                     }
1090                     if (fMatch) {
1091                         return TRUE;
1092                     }
1093                 }
1094                 if (startPos &gt;= testLen) {
1095                     fMatch = FALSE;
1096                     fHitEnd = TRUE;
1097                     return FALSE;
1098                 }
1099                 U16_FWD_1(inputBuf, startPos, fActiveLimit);
1100                 // Note that it&#39;s perfectly OK for a pattern to have a zero-length
1101                 //   match at the end of a string, so we must make sure that the loop
1102                 //   runs with startPos == testLen the last time through.
1103                 if  (findProgressInterrupt(startPos, status))
1104                     return FALSE;
1105             }
1106         } else {
1107             for (;;) {
<span class="line-modified">1108                 c = inputBuf[startPos-1];</span>
<span class="line-modified">1109                 if (isLineTerminator(c)) {</span>
<span class="line-modified">1110                     if (c == 0x0d &amp;&amp; startPos &lt; fActiveLimit &amp;&amp; inputBuf[startPos] == 0x0a) {</span>
1111                         startPos++;
1112                     }
1113                     MatchChunkAt(startPos, FALSE, status);
1114                     if (U_FAILURE(status)) {
1115                         return FALSE;
1116                     }
1117                     if (fMatch) {
1118                         return TRUE;
1119                     }
1120                 }
1121                 if (startPos &gt;= testLen) {
1122                     fMatch = FALSE;
1123                     fHitEnd = TRUE;
1124                     return FALSE;
1125                 }
1126                 U16_FWD_1(inputBuf, startPos, fActiveLimit);
1127                 // Note that it&#39;s perfectly OK for a pattern to have a zero-length
1128                 //   match at the end of a string, so we must make sure that the loop
1129                 //   runs with startPos == testLen the last time through.
1130                 if  (findProgressInterrupt(startPos, status))
1131                     return FALSE;
1132             }
1133         }
1134     }
1135 
1136     default:
<span class="line-modified">1137         U_ASSERT(FALSE);</span>
1138     }
1139 
<span class="line-modified">1140     U_ASSERT(FALSE);</span>
<span class="line-removed">1141     return FALSE;</span>
1142 }
1143 
1144 
1145 
1146 //--------------------------------------------------------------------------------
1147 //
1148 //  group()
1149 //
1150 //--------------------------------------------------------------------------------
1151 UnicodeString RegexMatcher::group(UErrorCode &amp;status) const {
1152     return group(0, status);
1153 }
1154 
1155 //  Return immutable shallow clone
1156 UText *RegexMatcher::group(UText *dest, int64_t &amp;group_len, UErrorCode &amp;status) const {
1157     return group(0, dest, group_len, status);
1158 }
1159 
1160 //  Return immutable shallow clone
1161 UText *RegexMatcher::group(int32_t groupNum, UText *dest, int64_t &amp;group_len, UErrorCode &amp;status) const {
</pre>
<hr />
<pre>
2757     int32_t     opType;                //    the opcode
2758     int32_t     opValue;               //    and the operand value.
2759 
2760 #ifdef REGEX_RUN_DEBUG
2761     if (fTraceDebug) {
2762         printf(&quot;MatchAt(startIdx=%ld)\n&quot;, startIdx);
2763         printf(&quot;Original Pattern: \&quot;%s\&quot;\n&quot;, CStr(StringFromUText(fPattern-&gt;fPattern))());
2764         printf(&quot;Input String:     \&quot;%s\&quot;\n\n&quot;, CStr(StringFromUText(fInputText))());
2765     }
2766 #endif
2767 
2768     if (U_FAILURE(status)) {
2769         return;
2770     }
2771 
2772     //  Cache frequently referenced items from the compiled pattern
2773     //
2774     int64_t             *pat           = fPattern-&gt;fCompiledPat-&gt;getBuffer();
2775 
2776     const UChar         *litText       = fPattern-&gt;fLiteralText.getBuffer();
<span class="line-modified">2777     UVector             *sets          = fPattern-&gt;fSets;</span>
2778 
2779     fFrameSize = fPattern-&gt;fFrameSize;
2780     REStackFrame        *fp            = resetStack();
2781     if (U_FAILURE(fDeferredStatus)) {
2782         status = fDeferredStatus;
2783         return;
2784     }
2785 
2786     fp-&gt;fPatIdx   = 0;
2787     fp-&gt;fInputIdx = startIdx;
2788 
2789     // Zero out the pattern&#39;s static data
2790     int32_t i;
2791     for (i = 0; i&lt;fPattern-&gt;fDataSize; i++) {
2792         fData[i] = 0;
2793     }
2794 
2795     //
2796     //  Main loop for interpreting the compiled pattern.
2797     //  One iteration of the loop per pattern operation performed.
</pre>
<hr />
<pre>
3359                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3360                         break;
3361                     }
3362                 }
3363                 // the character wasn&#39;t in the set.
3364                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3365             }
3366             break;
3367 
3368 
3369         case URX_SETREF:
3370             if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3371                 fHitEnd = TRUE;
3372                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3373                 break;
3374             } else {
3375                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3376 
3377                 // There is input left.  Pick up one char and test it for set membership.
3378                 UChar32 c = UTEXT_NEXT32(fInputText);
<span class="line-modified">3379                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; sets-&gt;size());</span>
3380                 if (c&lt;256) {
3381                     Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
3382                     if (s8-&gt;contains(c)) {
3383                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3384                         break;
3385                     }
3386                 } else {
<span class="line-modified">3387                     UnicodeSet *s = (UnicodeSet *)sets-&gt;elementAt(opValue);</span>
3388                     if (s-&gt;contains(c)) {
3389                         // The character is in the set.  A Match.
3390                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3391                         break;
3392                     }
3393                 }
3394 
3395                 // the character wasn&#39;t in the set.
3396                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3397             }
3398             break;
3399 
3400 
3401         case URX_DOTANY:
3402             {
3403                 // . matches anything, but stops at end-of-line.
3404                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3405                     // At end of input.  Match failed.  Backtrack out.
3406                     fHitEnd = TRUE;
3407                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
</pre>
<hr />
<pre>
3654                     //   in the following pattern will try another iteration of the loop.
3655                     fp = StateSave(fp, opValue + 4, status);
3656                 }
3657             }
3658             break;
3659 
3660         case URX_STO_SP:
3661             U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
3662             fData[opValue] = fStack-&gt;size();
3663             break;
3664 
3665         case URX_LD_SP:
3666             {
3667                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
3668                 int32_t newStackSize = (int32_t)fData[opValue];
3669                 U_ASSERT(newStackSize &lt;= fStack-&gt;size());
3670                 int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
3671                 if (newFP == (int64_t *)fp) {
3672                     break;
3673                 }
<span class="line-modified">3674                 int32_t i;</span>
<span class="line-modified">3675                 for (i=0; i&lt;fFrameSize; i++) {</span>
<span class="line-modified">3676                     newFP[i] = ((int64_t *)fp)[i];</span>
3677                 }
3678                 fp = (REStackFrame *)newFP;
3679                 fStack-&gt;setSize(newStackSize);
3680             }
3681             break;
3682 
3683         case URX_BACKREF:
3684             {
3685                 U_ASSERT(opValue &lt; fFrameSize);
3686                 int64_t groupStartIdx = fp-&gt;fExtra[opValue];
3687                 int64_t groupEndIdx   = fp-&gt;fExtra[opValue+1];
3688                 U_ASSERT(groupStartIdx &lt;= groupEndIdx);
3689                 if (groupStartIdx &lt; 0) {
3690                     // This capture group has not participated in the match thus far,
3691                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);   // FAIL, no match.
3692                     break;
3693                 }
3694                 UTEXT_SETNATIVEINDEX(fAltInputText, groupStartIdx);
3695                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3696 
</pre>
<hr />
<pre>
3813                 fData[opValue]   = fStack-&gt;size();
3814                 fData[opValue+1] = fp-&gt;fInputIdx;
3815                 fActiveStart     = fLookStart;          // Set the match region change for
3816                 fActiveLimit     = fLookLimit;          //   transparent bounds.
3817             }
3818             break;
3819 
3820         case URX_LA_END:
3821             {
3822                 // Leaving a look-ahead block.
3823                 //  restore Stack Ptr, Input Pos to positions they had on entry to block.
3824                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
3825                 int32_t stackSize = fStack-&gt;size();
3826                 int32_t newStackSize =(int32_t)fData[opValue];
3827                 U_ASSERT(stackSize &gt;= newStackSize);
3828                 if (stackSize &gt; newStackSize) {
3829                     // Copy the current top frame back to the new (cut back) top frame.
3830                     //   This makes the capture groups from within the look-ahead
3831                     //   expression available.
3832                     int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
<span class="line-modified">3833                     int32_t i;</span>
<span class="line-modified">3834                     for (i=0; i&lt;fFrameSize; i++) {</span>
<span class="line-modified">3835                         newFP[i] = ((int64_t *)fp)[i];</span>
3836                     }
3837                     fp = (REStackFrame *)newFP;
3838                     fStack-&gt;setSize(newStackSize);
3839                 }
3840                 fp-&gt;fInputIdx = fData[opValue+1];
3841 
3842                 // Restore the active region bounds in the input string; they may have
3843                 //    been changed because of transparent bounds on a Region.
3844                 fActiveStart = fRegionStart;
3845                 fActiveLimit = fRegionLimit;
3846             }
3847             break;
3848 
3849         case URX_ONECHAR_I:
3850             // Case insensitive one char.  The char from the pattern is already case folded.
3851             // Input text is not, but case folding the input can not reduce two or more code
3852             // points to one.
3853             if (fp-&gt;fInputIdx &lt; fActiveLimit) {
3854                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3855 
</pre>
<hr />
<pre>
4106                 // Restore original stack position, discarding any state saved
4107                 //   by the successful pattern match.
4108                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
4109                 int32_t newStackSize = (int32_t)fData[opValue];
4110                 U_ASSERT(fStack-&gt;size() &gt; newStackSize);
4111                 fStack-&gt;setSize(newStackSize);
4112 
4113                 //  FAIL, which will take control back to someplace
4114                 //  prior to entering the look-behind test.
4115                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4116             }
4117             break;
4118 
4119 
4120         case URX_LOOP_SR_I:
4121             // Loop Initialization for the optimized implementation of
4122             //     [some character set]*
4123             //   This op scans through all matching input.
4124             //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
4125             {
<span class="line-modified">4126                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; sets-&gt;size());</span>
4127                 Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
<span class="line-modified">4128                 UnicodeSet   *s  = (UnicodeSet *)sets-&gt;elementAt(opValue);</span>
4129 
4130                 // Loop through input, until either the input is exhausted or
4131                 //   we reach a character that is not a member of the set.
4132                 int64_t ix = fp-&gt;fInputIdx;
4133                 UTEXT_SETNATIVEINDEX(fInputText, ix);
4134                 for (;;) {
4135                     if (ix &gt;= fActiveLimit) {
4136                         fHitEnd = TRUE;
4137                         break;
4138                     }
4139                     UChar32 c = UTEXT_NEXT32(fInputText);
4140                     if (c&lt;256) {
4141                         if (s8-&gt;contains(c) == FALSE) {
4142                             break;
4143                         }
4144                     } else {
4145                         if (s-&gt;contains(c) == FALSE) {
4146                             break;
4147                         }
4148                     }
</pre>
<hr />
<pre>
4261                 if (prevC == 0x0a &amp;&amp;
4262                     fp-&gt;fInputIdx &gt; backSearchIndex &amp;&amp;
4263                     twoPrevC == 0x0d) {
4264                     int32_t prevOp = (int32_t)pat[fp-&gt;fPatIdx-2];
4265                     if (URX_TYPE(prevOp) == URX_LOOP_DOT_I) {
4266                         // .*, stepping back over CRLF pair.
4267                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
4268                     }
4269                 }
4270 
4271 
4272                 fp = StateSave(fp, fp-&gt;fPatIdx-1, status);
4273             }
4274             break;
4275 
4276 
4277 
4278         default:
4279             // Trouble.  The compiled pattern contains an entry with an
4280             //           unrecognized type tag.
<span class="line-modified">4281             U_ASSERT(FALSE);</span>
4282         }
4283 
4284         if (U_FAILURE(status)) {
4285             isMatch = FALSE;
4286             break;
4287         }
4288     }
4289 
4290 breakFromLoop:
4291     fMatch = isMatch;
4292     if (isMatch) {
4293         fLastMatchEnd = fMatchEnd;
4294         fMatchStart   = startIdx;
4295         fMatchEnd     = fp-&gt;fInputIdx;
4296     }
4297 
4298 #ifdef REGEX_RUN_DEBUG
4299     if (fTraceDebug) {
4300         if (isMatch) {
4301             printf(&quot;Match.  start=%ld   end=%ld\n\n&quot;, fMatchStart, fMatchEnd);
</pre>
<hr />
<pre>
4333     int32_t     opType;                //    the opcode
4334     int32_t     opValue;               //    and the operand value.
4335 
4336 #ifdef REGEX_RUN_DEBUG
4337     if (fTraceDebug) {
4338         printf(&quot;MatchAt(startIdx=%d)\n&quot;, startIdx);
4339         printf(&quot;Original Pattern: \&quot;%s\&quot;\n&quot;, CStr(StringFromUText(fPattern-&gt;fPattern))());
4340         printf(&quot;Input String:     \&quot;%s\&quot;\n\n&quot;, CStr(StringFromUText(fInputText))());
4341     }
4342 #endif
4343 
4344     if (U_FAILURE(status)) {
4345         return;
4346     }
4347 
4348     //  Cache frequently referenced items from the compiled pattern
4349     //
4350     int64_t             *pat           = fPattern-&gt;fCompiledPat-&gt;getBuffer();
4351 
4352     const UChar         *litText       = fPattern-&gt;fLiteralText.getBuffer();
<span class="line-modified">4353     UVector             *sets          = fPattern-&gt;fSets;</span>
4354 
4355     const UChar         *inputBuf      = fInputText-&gt;chunkContents;
4356 
4357     fFrameSize = fPattern-&gt;fFrameSize;
4358     REStackFrame        *fp            = resetStack();
4359     if (U_FAILURE(fDeferredStatus)) {
4360         status = fDeferredStatus;
4361         return;
4362     }
4363 
4364     fp-&gt;fPatIdx   = 0;
4365     fp-&gt;fInputIdx = startIdx;
4366 
4367     // Zero out the pattern&#39;s static data
4368     int32_t i;
4369     for (i = 0; i&lt;fPattern-&gt;fDataSize; i++) {
4370         fData[i] = 0;
4371     }
4372 
4373     //
</pre>
<hr />
<pre>
4911                     }
4912                 } else {
4913                     const UnicodeSet *s = fPattern-&gt;fStaticSets[opValue];
4914                     if (s-&gt;contains(c) == FALSE) {
4915                         break;
4916                     }
4917                 }
4918                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4919             }
4920             break;
4921 
4922 
4923         case URX_SETREF:
4924             {
4925                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4926                     fHitEnd = TRUE;
4927                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4928                     break;
4929                 }
4930 
<span class="line-modified">4931                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; sets-&gt;size());</span>
4932 
4933                 // There is input left.  Pick up one char and test it for set membership.
4934                 UChar32  c;
4935                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4936                 if (c&lt;256) {
4937                     Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
4938                     if (s8-&gt;contains(c)) {
4939                         // The character is in the set.  A Match.
4940                         break;
4941                     }
4942                 } else {
<span class="line-modified">4943                     UnicodeSet *s = (UnicodeSet *)sets-&gt;elementAt(opValue);</span>
4944                     if (s-&gt;contains(c)) {
4945                         // The character is in the set.  A Match.
4946                         break;
4947                     }
4948                 }
4949 
4950                 // the character wasn&#39;t in the set.
4951                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4952             }
4953             break;
4954 
4955 
4956         case URX_DOTANY:
4957             {
4958                 // . matches anything, but stops at end-of-line.
4959                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4960                     // At end of input.  Match failed.  Backtrack out.
4961                     fHitEnd = TRUE;
4962                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4963                     break;
</pre>
<hr />
<pre>
5197                     //   in the following pattern will try another iteration of the loop.
5198                     fp = StateSave(fp, opValue + 4, status);
5199                 }
5200             }
5201             break;
5202 
5203         case URX_STO_SP:
5204             U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
5205             fData[opValue] = fStack-&gt;size();
5206             break;
5207 
5208         case URX_LD_SP:
5209             {
5210                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
5211                 int32_t newStackSize = (int32_t)fData[opValue];
5212                 U_ASSERT(newStackSize &lt;= fStack-&gt;size());
5213                 int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
5214                 if (newFP == (int64_t *)fp) {
5215                     break;
5216                 }
<span class="line-modified">5217                 int32_t i;</span>
<span class="line-modified">5218                 for (i=0; i&lt;fFrameSize; i++) {</span>
<span class="line-modified">5219                     newFP[i] = ((int64_t *)fp)[i];</span>
5220                 }
5221                 fp = (REStackFrame *)newFP;
5222                 fStack-&gt;setSize(newStackSize);
5223             }
5224             break;
5225 
5226         case URX_BACKREF:
5227             {
5228                 U_ASSERT(opValue &lt; fFrameSize);
5229                 int64_t groupStartIdx = fp-&gt;fExtra[opValue];
5230                 int64_t groupEndIdx   = fp-&gt;fExtra[opValue+1];
5231                 U_ASSERT(groupStartIdx &lt;= groupEndIdx);
5232                 int64_t inputIndex = fp-&gt;fInputIdx;
5233                 if (groupStartIdx &lt; 0) {
5234                     // This capture group has not participated in the match thus far,
5235                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);   // FAIL, no match.
5236                     break;
5237                 }
5238                 UBool success = TRUE;
5239                 for (int64_t groupIndex = groupStartIdx; groupIndex &lt; groupEndIdx; ++groupIndex,++inputIndex) {
</pre>
<hr />
<pre>
5344                 fData[opValue]   = fStack-&gt;size();
5345                 fData[opValue+1] = fp-&gt;fInputIdx;
5346                 fActiveStart     = fLookStart;          // Set the match region change for
5347                 fActiveLimit     = fLookLimit;          //   transparent bounds.
5348             }
5349             break;
5350 
5351         case URX_LA_END:
5352             {
5353                 // Leaving a look-ahead block.
5354                 //  restore Stack Ptr, Input Pos to positions they had on entry to block.
5355                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5356                 int32_t stackSize = fStack-&gt;size();
5357                 int32_t newStackSize = (int32_t)fData[opValue];
5358                 U_ASSERT(stackSize &gt;= newStackSize);
5359                 if (stackSize &gt; newStackSize) {
5360                     // Copy the current top frame back to the new (cut back) top frame.
5361                     //   This makes the capture groups from within the look-ahead
5362                     //   expression available.
5363                     int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
<span class="line-modified">5364                     int32_t i;</span>
<span class="line-modified">5365                     for (i=0; i&lt;fFrameSize; i++) {</span>
<span class="line-modified">5366                         newFP[i] = ((int64_t *)fp)[i];</span>
5367                     }
5368                     fp = (REStackFrame *)newFP;
5369                     fStack-&gt;setSize(newStackSize);
5370                 }
5371                 fp-&gt;fInputIdx = fData[opValue+1];
5372 
5373                 // Restore the active region bounds in the input string; they may have
5374                 //    been changed because of transparent bounds on a Region.
5375                 fActiveStart = fRegionStart;
5376                 fActiveLimit = fRegionLimit;
5377             }
5378             break;
5379 
5380         case URX_ONECHAR_I:
5381             if (fp-&gt;fInputIdx &lt; fActiveLimit) {
5382                 UChar32 c;
5383                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
5384                 if (u_foldCase(c, U_FOLD_CASE_DEFAULT) == opValue) {
5385                     break;
5386                 }
</pre>
<hr />
<pre>
5606                 // Restore original stack position, discarding any state saved
5607                 //   by the successful pattern match.
5608                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5609                 int32_t newStackSize = (int32_t)fData[opValue];
5610                 U_ASSERT(fStack-&gt;size() &gt; newStackSize);
5611                 fStack-&gt;setSize(newStackSize);
5612 
5613                 //  FAIL, which will take control back to someplace
5614                 //  prior to entering the look-behind test.
5615                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5616             }
5617             break;
5618 
5619 
5620         case URX_LOOP_SR_I:
5621             // Loop Initialization for the optimized implementation of
5622             //     [some character set]*
5623             //   This op scans through all matching input.
5624             //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
5625             {
<span class="line-modified">5626                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; sets-&gt;size());</span>
5627                 Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
<span class="line-modified">5628                 UnicodeSet   *s  = (UnicodeSet *)sets-&gt;elementAt(opValue);</span>
5629 
5630                 // Loop through input, until either the input is exhausted or
5631                 //   we reach a character that is not a member of the set.
5632                 int32_t ix = (int32_t)fp-&gt;fInputIdx;
5633                 for (;;) {
5634                     if (ix &gt;= fActiveLimit) {
5635                         fHitEnd = TRUE;
5636                         break;
5637                     }
5638                     UChar32   c;
5639                     U16_NEXT(inputBuf, ix, fActiveLimit, c);
5640                     if (c&lt;256) {
5641                         if (s8-&gt;contains(c) == FALSE) {
5642                             U16_BACK_1(inputBuf, 0, ix);
5643                             break;
5644                         }
5645                     } else {
5646                         if (s-&gt;contains(c) == FALSE) {
5647                             U16_BACK_1(inputBuf, 0, ix);
5648                             break;
</pre>
<hr />
<pre>
5761                 if (prevC == 0x0a &amp;&amp;
5762                     fp-&gt;fInputIdx &gt; backSearchIndex &amp;&amp;
5763                     inputBuf[fp-&gt;fInputIdx-1] == 0x0d) {
5764                     int32_t prevOp = (int32_t)pat[fp-&gt;fPatIdx-2];
5765                     if (URX_TYPE(prevOp) == URX_LOOP_DOT_I) {
5766                         // .*, stepping back over CRLF pair.
5767                         U16_BACK_1(inputBuf, 0, fp-&gt;fInputIdx);
5768                     }
5769                 }
5770 
5771 
5772                 fp = StateSave(fp, fp-&gt;fPatIdx-1, status);
5773             }
5774             break;
5775 
5776 
5777 
5778         default:
5779             // Trouble.  The compiled pattern contains an entry with an
5780             //           unrecognized type tag.
<span class="line-modified">5781             U_ASSERT(FALSE);</span>
5782         }
5783 
5784         if (U_FAILURE(status)) {
5785             isMatch = FALSE;
5786             break;
5787         }
5788     }
5789 
5790 breakFromLoop:
5791     fMatch = isMatch;
5792     if (isMatch) {
5793         fLastMatchEnd = fMatchEnd;
5794         fMatchStart   = startIdx;
5795         fMatchEnd     = fp-&gt;fInputIdx;
5796     }
5797 
5798 #ifdef REGEX_RUN_DEBUG
5799     if (fTraceDebug) {
5800         if (isMatch) {
5801             printf(&quot;Match.  start=%ld   end=%ld\n\n&quot;, fMatchStart, fMatchEnd);
</pre>
</td>
<td>
<hr />
<pre>
 700             MatchAt(startPos, FALSE, status);
 701             if (U_FAILURE(status)) {
 702                 return FALSE;
 703             }
 704             if (fMatch) {
 705                 return TRUE;
 706             }
 707             if (startPos &gt;= testStartLimit) {
 708                 fHitEnd = TRUE;
 709                 return FALSE;
 710             }
 711             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 712             (void)UTEXT_NEXT32(fInputText);
 713             startPos = UTEXT_GETNATIVEINDEX(fInputText);
 714             // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 715             //   match at the end of a string, so we must make sure that the loop
 716             //   runs with startPos == testStartLimit the last time through.
 717             if  (findProgressInterrupt(startPos, status))
 718                 return FALSE;
 719         }
<span class="line-modified"> 720         UPRV_UNREACHABLE;</span>
 721 
 722     case START_START:
 723         // Matches are only possible at the start of the input string
 724         //   (pattern begins with ^ or \A)
 725         if (startPos &gt; fActiveStart) {
 726             fMatch = FALSE;
 727             return FALSE;
 728         }
 729         MatchAt(startPos, FALSE, status);
 730         if (U_FAILURE(status)) {
 731             return FALSE;
 732         }
 733         return fMatch;
 734 
 735 
 736     case START_SET:
 737         {
 738             // Match may start on any char from a pre-computed set.
 739             U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
 740             UTEXT_SETNATIVEINDEX(fInputText, startPos);
</pre>
<hr />
<pre>
 748                 if (c &gt;= 0 &amp;&amp; ((c&lt;256 &amp;&amp; fPattern-&gt;fInitialChars8-&gt;contains(c)) ||
 749                               (c&gt;=256 &amp;&amp; fPattern-&gt;fInitialChars-&gt;contains(c)))) {
 750                     MatchAt(pos, FALSE, status);
 751                     if (U_FAILURE(status)) {
 752                         return FALSE;
 753                     }
 754                     if (fMatch) {
 755                         return TRUE;
 756                     }
 757                     UTEXT_SETNATIVEINDEX(fInputText, pos);
 758                 }
 759                 if (startPos &gt; testStartLimit) {
 760                     fMatch = FALSE;
 761                     fHitEnd = TRUE;
 762                     return FALSE;
 763                 }
 764                 if  (findProgressInterrupt(startPos, status))
 765                     return FALSE;
 766             }
 767         }
<span class="line-modified"> 768         UPRV_UNREACHABLE;</span>
 769 
 770     case START_STRING:
 771     case START_CHAR:
 772         {
 773             // Match starts on exactly one char.
 774             U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
 775             UChar32 theChar = fPattern-&gt;fInitialChar;
 776             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 777             for (;;) {
 778                 int64_t pos = startPos;
 779                 c = UTEXT_NEXT32(fInputText);
 780                 startPos = UTEXT_GETNATIVEINDEX(fInputText);
 781                 if (c == theChar) {
 782                     MatchAt(pos, FALSE, status);
 783                     if (U_FAILURE(status)) {
 784                         return FALSE;
 785                     }
 786                     if (fMatch) {
 787                         return TRUE;
 788                     }
 789                     UTEXT_SETNATIVEINDEX(fInputText, startPos);
 790                 }
 791                 if (startPos &gt; testStartLimit) {
 792                     fMatch = FALSE;
 793                     fHitEnd = TRUE;
 794                     return FALSE;
 795                 }
 796                 if  (findProgressInterrupt(startPos, status))
 797                     return FALSE;
 798            }
 799         }
<span class="line-modified"> 800         UPRV_UNREACHABLE;</span>
 801 
 802     case START_LINE:
 803         {
<span class="line-modified"> 804             UChar32 ch;</span>
 805             if (startPos == fAnchorStart) {
 806                 MatchAt(startPos, FALSE, status);
 807                 if (U_FAILURE(status)) {
 808                     return FALSE;
 809                 }
 810                 if (fMatch) {
 811                     return TRUE;
 812                 }
 813                 UTEXT_SETNATIVEINDEX(fInputText, startPos);
<span class="line-modified"> 814                 ch = UTEXT_NEXT32(fInputText);</span>
 815                 startPos = UTEXT_GETNATIVEINDEX(fInputText);
 816             } else {
 817                 UTEXT_SETNATIVEINDEX(fInputText, startPos);
<span class="line-modified"> 818                 ch = UTEXT_PREVIOUS32(fInputText);</span>
 819                 UTEXT_SETNATIVEINDEX(fInputText, startPos);
 820             }
 821 
 822             if (fPattern-&gt;fFlags &amp; UREGEX_UNIX_LINES) {
 823                 for (;;) {
<span class="line-modified"> 824                     if (ch == 0x0a) {</span>
 825                             MatchAt(startPos, FALSE, status);
 826                             if (U_FAILURE(status)) {
 827                                 return FALSE;
 828                             }
 829                             if (fMatch) {
 830                                 return TRUE;
 831                             }
 832                             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 833                     }
 834                     if (startPos &gt;= testStartLimit) {
 835                         fMatch = FALSE;
 836                         fHitEnd = TRUE;
 837                         return FALSE;
 838                     }
<span class="line-modified"> 839                     ch = UTEXT_NEXT32(fInputText);</span>
 840                     startPos = UTEXT_GETNATIVEINDEX(fInputText);
 841                     // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 842                     //   match at the end of a string, so we must make sure that the loop
 843                     //   runs with startPos == testStartLimit the last time through.
 844                     if  (findProgressInterrupt(startPos, status))
 845                         return FALSE;
 846                 }
 847             } else {
 848                 for (;;) {
<span class="line-modified"> 849                     if (isLineTerminator(ch)) {</span>
<span class="line-modified"> 850                         if (ch == 0x0d &amp;&amp; startPos &lt; fActiveLimit &amp;&amp; UTEXT_CURRENT32(fInputText) == 0x0a) {</span>
 851                             (void)UTEXT_NEXT32(fInputText);
 852                             startPos = UTEXT_GETNATIVEINDEX(fInputText);
 853                         }
 854                         MatchAt(startPos, FALSE, status);
 855                         if (U_FAILURE(status)) {
 856                             return FALSE;
 857                         }
 858                         if (fMatch) {
 859                             return TRUE;
 860                         }
 861                         UTEXT_SETNATIVEINDEX(fInputText, startPos);
 862                     }
 863                     if (startPos &gt;= testStartLimit) {
 864                         fMatch = FALSE;
 865                         fHitEnd = TRUE;
 866                         return FALSE;
 867                     }
<span class="line-modified"> 868                     ch = UTEXT_NEXT32(fInputText);</span>
 869                     startPos = UTEXT_GETNATIVEINDEX(fInputText);
 870                     // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 871                     //   match at the end of a string, so we must make sure that the loop
 872                     //   runs with startPos == testStartLimit the last time through.
 873                     if  (findProgressInterrupt(startPos, status))
 874                         return FALSE;
 875                 }
 876             }
 877         }
 878 
 879     default:
<span class="line-modified"> 880         UPRV_UNREACHABLE;</span>
 881     }
 882 
<span class="line-modified"> 883     UPRV_UNREACHABLE;</span>

 884 }
 885 
 886 
 887 
 888 UBool RegexMatcher::find(int64_t start, UErrorCode &amp;status) {
 889     if (U_FAILURE(status)) {
 890         return FALSE;
 891     }
 892     if (U_FAILURE(fDeferredStatus)) {
 893         status = fDeferredStatus;
 894         return FALSE;
 895     }
 896     this-&gt;reset();                        // Note:  Reset() is specified by Java Matcher documentation.
 897                                           //        This will reset the region to be the full input length.
 898     if (start &lt; 0) {
 899         status = U_INDEX_OUTOFBOUNDS_ERROR;
 900         return FALSE;
 901     }
 902 
 903     int64_t nativeStart = start;
</pre>
<hr />
<pre>
 974         //  Try a match at each input position.
 975         for (;;) {
 976             MatchChunkAt(startPos, FALSE, status);
 977             if (U_FAILURE(status)) {
 978                 return FALSE;
 979             }
 980             if (fMatch) {
 981                 return TRUE;
 982             }
 983             if (startPos &gt;= testLen) {
 984                 fHitEnd = TRUE;
 985                 return FALSE;
 986             }
 987             U16_FWD_1(inputBuf, startPos, fActiveLimit);
 988             // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 989             //   match at the end of a string, so we must make sure that the loop
 990             //   runs with startPos == testLen the last time through.
 991             if  (findProgressInterrupt(startPos, status))
 992                 return FALSE;
 993         }
<span class="line-modified"> 994         UPRV_UNREACHABLE;</span>
 995 
 996     case START_START:
 997         // Matches are only possible at the start of the input string
 998         //   (pattern begins with ^ or \A)
 999         if (startPos &gt; fActiveStart) {
1000             fMatch = FALSE;
1001             return FALSE;
1002         }
1003         MatchChunkAt(startPos, FALSE, status);
1004         if (U_FAILURE(status)) {
1005             return FALSE;
1006         }
1007         return fMatch;
1008 
1009 
1010     case START_SET:
1011     {
1012         // Match may start on any char from a pre-computed set.
1013         U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
1014         for (;;) {
</pre>
<hr />
<pre>
1016             U16_NEXT(inputBuf, startPos, fActiveLimit, c);  // like c = inputBuf[startPos++];
1017             if ((c&lt;256 &amp;&amp; fPattern-&gt;fInitialChars8-&gt;contains(c)) ||
1018                 (c&gt;=256 &amp;&amp; fPattern-&gt;fInitialChars-&gt;contains(c))) {
1019                 MatchChunkAt(pos, FALSE, status);
1020                 if (U_FAILURE(status)) {
1021                     return FALSE;
1022                 }
1023                 if (fMatch) {
1024                     return TRUE;
1025                 }
1026             }
1027             if (startPos &gt; testLen) {
1028                 fMatch = FALSE;
1029                 fHitEnd = TRUE;
1030                 return FALSE;
1031             }
1032             if  (findProgressInterrupt(startPos, status))
1033                 return FALSE;
1034         }
1035     }
<span class="line-modified">1036     UPRV_UNREACHABLE;</span>
1037 
1038     case START_STRING:
1039     case START_CHAR:
1040     {
1041         // Match starts on exactly one char.
1042         U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
1043         UChar32 theChar = fPattern-&gt;fInitialChar;
1044         for (;;) {
1045             int32_t pos = startPos;
1046             U16_NEXT(inputBuf, startPos, fActiveLimit, c);  // like c = inputBuf[startPos++];
1047             if (c == theChar) {
1048                 MatchChunkAt(pos, FALSE, status);
1049                 if (U_FAILURE(status)) {
1050                     return FALSE;
1051                 }
1052                 if (fMatch) {
1053                     return TRUE;
1054                 }
1055             }
1056             if (startPos &gt; testLen) {
1057                 fMatch = FALSE;
1058                 fHitEnd = TRUE;
1059                 return FALSE;
1060             }
1061             if  (findProgressInterrupt(startPos, status))
1062                 return FALSE;
1063         }
1064     }
<span class="line-modified">1065     UPRV_UNREACHABLE;</span>
1066 
1067     case START_LINE:
1068     {
<span class="line-modified">1069         UChar32 ch;</span>
1070         if (startPos == fAnchorStart) {
1071             MatchChunkAt(startPos, FALSE, status);
1072             if (U_FAILURE(status)) {
1073                 return FALSE;
1074             }
1075             if (fMatch) {
1076                 return TRUE;
1077             }
1078             U16_FWD_1(inputBuf, startPos, fActiveLimit);
1079         }
1080 
1081         if (fPattern-&gt;fFlags &amp; UREGEX_UNIX_LINES) {
1082             for (;;) {
<span class="line-modified">1083                 ch = inputBuf[startPos-1];</span>
<span class="line-modified">1084                 if (ch == 0x0a) {</span>
1085                     MatchChunkAt(startPos, FALSE, status);
1086                     if (U_FAILURE(status)) {
1087                         return FALSE;
1088                     }
1089                     if (fMatch) {
1090                         return TRUE;
1091                     }
1092                 }
1093                 if (startPos &gt;= testLen) {
1094                     fMatch = FALSE;
1095                     fHitEnd = TRUE;
1096                     return FALSE;
1097                 }
1098                 U16_FWD_1(inputBuf, startPos, fActiveLimit);
1099                 // Note that it&#39;s perfectly OK for a pattern to have a zero-length
1100                 //   match at the end of a string, so we must make sure that the loop
1101                 //   runs with startPos == testLen the last time through.
1102                 if  (findProgressInterrupt(startPos, status))
1103                     return FALSE;
1104             }
1105         } else {
1106             for (;;) {
<span class="line-modified">1107                 ch = inputBuf[startPos-1];</span>
<span class="line-modified">1108                 if (isLineTerminator(ch)) {</span>
<span class="line-modified">1109                     if (ch == 0x0d &amp;&amp; startPos &lt; fActiveLimit &amp;&amp; inputBuf[startPos] == 0x0a) {</span>
1110                         startPos++;
1111                     }
1112                     MatchChunkAt(startPos, FALSE, status);
1113                     if (U_FAILURE(status)) {
1114                         return FALSE;
1115                     }
1116                     if (fMatch) {
1117                         return TRUE;
1118                     }
1119                 }
1120                 if (startPos &gt;= testLen) {
1121                     fMatch = FALSE;
1122                     fHitEnd = TRUE;
1123                     return FALSE;
1124                 }
1125                 U16_FWD_1(inputBuf, startPos, fActiveLimit);
1126                 // Note that it&#39;s perfectly OK for a pattern to have a zero-length
1127                 //   match at the end of a string, so we must make sure that the loop
1128                 //   runs with startPos == testLen the last time through.
1129                 if  (findProgressInterrupt(startPos, status))
1130                     return FALSE;
1131             }
1132         }
1133     }
1134 
1135     default:
<span class="line-modified">1136         UPRV_UNREACHABLE;</span>
1137     }
1138 
<span class="line-modified">1139     UPRV_UNREACHABLE;</span>

1140 }
1141 
1142 
1143 
1144 //--------------------------------------------------------------------------------
1145 //
1146 //  group()
1147 //
1148 //--------------------------------------------------------------------------------
1149 UnicodeString RegexMatcher::group(UErrorCode &amp;status) const {
1150     return group(0, status);
1151 }
1152 
1153 //  Return immutable shallow clone
1154 UText *RegexMatcher::group(UText *dest, int64_t &amp;group_len, UErrorCode &amp;status) const {
1155     return group(0, dest, group_len, status);
1156 }
1157 
1158 //  Return immutable shallow clone
1159 UText *RegexMatcher::group(int32_t groupNum, UText *dest, int64_t &amp;group_len, UErrorCode &amp;status) const {
</pre>
<hr />
<pre>
2755     int32_t     opType;                //    the opcode
2756     int32_t     opValue;               //    and the operand value.
2757 
2758 #ifdef REGEX_RUN_DEBUG
2759     if (fTraceDebug) {
2760         printf(&quot;MatchAt(startIdx=%ld)\n&quot;, startIdx);
2761         printf(&quot;Original Pattern: \&quot;%s\&quot;\n&quot;, CStr(StringFromUText(fPattern-&gt;fPattern))());
2762         printf(&quot;Input String:     \&quot;%s\&quot;\n\n&quot;, CStr(StringFromUText(fInputText))());
2763     }
2764 #endif
2765 
2766     if (U_FAILURE(status)) {
2767         return;
2768     }
2769 
2770     //  Cache frequently referenced items from the compiled pattern
2771     //
2772     int64_t             *pat           = fPattern-&gt;fCompiledPat-&gt;getBuffer();
2773 
2774     const UChar         *litText       = fPattern-&gt;fLiteralText.getBuffer();
<span class="line-modified">2775     UVector             *fSets         = fPattern-&gt;fSets;</span>
2776 
2777     fFrameSize = fPattern-&gt;fFrameSize;
2778     REStackFrame        *fp            = resetStack();
2779     if (U_FAILURE(fDeferredStatus)) {
2780         status = fDeferredStatus;
2781         return;
2782     }
2783 
2784     fp-&gt;fPatIdx   = 0;
2785     fp-&gt;fInputIdx = startIdx;
2786 
2787     // Zero out the pattern&#39;s static data
2788     int32_t i;
2789     for (i = 0; i&lt;fPattern-&gt;fDataSize; i++) {
2790         fData[i] = 0;
2791     }
2792 
2793     //
2794     //  Main loop for interpreting the compiled pattern.
2795     //  One iteration of the loop per pattern operation performed.
</pre>
<hr />
<pre>
3357                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3358                         break;
3359                     }
3360                 }
3361                 // the character wasn&#39;t in the set.
3362                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3363             }
3364             break;
3365 
3366 
3367         case URX_SETREF:
3368             if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3369                 fHitEnd = TRUE;
3370                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3371                 break;
3372             } else {
3373                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3374 
3375                 // There is input left.  Pick up one char and test it for set membership.
3376                 UChar32 c = UTEXT_NEXT32(fInputText);
<span class="line-modified">3377                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
3378                 if (c&lt;256) {
3379                     Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
3380                     if (s8-&gt;contains(c)) {
3381                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3382                         break;
3383                     }
3384                 } else {
<span class="line-modified">3385                     UnicodeSet *s = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
3386                     if (s-&gt;contains(c)) {
3387                         // The character is in the set.  A Match.
3388                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3389                         break;
3390                     }
3391                 }
3392 
3393                 // the character wasn&#39;t in the set.
3394                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3395             }
3396             break;
3397 
3398 
3399         case URX_DOTANY:
3400             {
3401                 // . matches anything, but stops at end-of-line.
3402                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3403                     // At end of input.  Match failed.  Backtrack out.
3404                     fHitEnd = TRUE;
3405                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
</pre>
<hr />
<pre>
3652                     //   in the following pattern will try another iteration of the loop.
3653                     fp = StateSave(fp, opValue + 4, status);
3654                 }
3655             }
3656             break;
3657 
3658         case URX_STO_SP:
3659             U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
3660             fData[opValue] = fStack-&gt;size();
3661             break;
3662 
3663         case URX_LD_SP:
3664             {
3665                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
3666                 int32_t newStackSize = (int32_t)fData[opValue];
3667                 U_ASSERT(newStackSize &lt;= fStack-&gt;size());
3668                 int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
3669                 if (newFP == (int64_t *)fp) {
3670                     break;
3671                 }
<span class="line-modified">3672                 int32_t j;</span>
<span class="line-modified">3673                 for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">3674                     newFP[j] = ((int64_t *)fp)[j];</span>
3675                 }
3676                 fp = (REStackFrame *)newFP;
3677                 fStack-&gt;setSize(newStackSize);
3678             }
3679             break;
3680 
3681         case URX_BACKREF:
3682             {
3683                 U_ASSERT(opValue &lt; fFrameSize);
3684                 int64_t groupStartIdx = fp-&gt;fExtra[opValue];
3685                 int64_t groupEndIdx   = fp-&gt;fExtra[opValue+1];
3686                 U_ASSERT(groupStartIdx &lt;= groupEndIdx);
3687                 if (groupStartIdx &lt; 0) {
3688                     // This capture group has not participated in the match thus far,
3689                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);   // FAIL, no match.
3690                     break;
3691                 }
3692                 UTEXT_SETNATIVEINDEX(fAltInputText, groupStartIdx);
3693                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3694 
</pre>
<hr />
<pre>
3811                 fData[opValue]   = fStack-&gt;size();
3812                 fData[opValue+1] = fp-&gt;fInputIdx;
3813                 fActiveStart     = fLookStart;          // Set the match region change for
3814                 fActiveLimit     = fLookLimit;          //   transparent bounds.
3815             }
3816             break;
3817 
3818         case URX_LA_END:
3819             {
3820                 // Leaving a look-ahead block.
3821                 //  restore Stack Ptr, Input Pos to positions they had on entry to block.
3822                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
3823                 int32_t stackSize = fStack-&gt;size();
3824                 int32_t newStackSize =(int32_t)fData[opValue];
3825                 U_ASSERT(stackSize &gt;= newStackSize);
3826                 if (stackSize &gt; newStackSize) {
3827                     // Copy the current top frame back to the new (cut back) top frame.
3828                     //   This makes the capture groups from within the look-ahead
3829                     //   expression available.
3830                     int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
<span class="line-modified">3831                     int32_t j;</span>
<span class="line-modified">3832                     for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">3833                         newFP[j] = ((int64_t *)fp)[j];</span>
3834                     }
3835                     fp = (REStackFrame *)newFP;
3836                     fStack-&gt;setSize(newStackSize);
3837                 }
3838                 fp-&gt;fInputIdx = fData[opValue+1];
3839 
3840                 // Restore the active region bounds in the input string; they may have
3841                 //    been changed because of transparent bounds on a Region.
3842                 fActiveStart = fRegionStart;
3843                 fActiveLimit = fRegionLimit;
3844             }
3845             break;
3846 
3847         case URX_ONECHAR_I:
3848             // Case insensitive one char.  The char from the pattern is already case folded.
3849             // Input text is not, but case folding the input can not reduce two or more code
3850             // points to one.
3851             if (fp-&gt;fInputIdx &lt; fActiveLimit) {
3852                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3853 
</pre>
<hr />
<pre>
4104                 // Restore original stack position, discarding any state saved
4105                 //   by the successful pattern match.
4106                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
4107                 int32_t newStackSize = (int32_t)fData[opValue];
4108                 U_ASSERT(fStack-&gt;size() &gt; newStackSize);
4109                 fStack-&gt;setSize(newStackSize);
4110 
4111                 //  FAIL, which will take control back to someplace
4112                 //  prior to entering the look-behind test.
4113                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4114             }
4115             break;
4116 
4117 
4118         case URX_LOOP_SR_I:
4119             // Loop Initialization for the optimized implementation of
4120             //     [some character set]*
4121             //   This op scans through all matching input.
4122             //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
4123             {
<span class="line-modified">4124                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
4125                 Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
<span class="line-modified">4126                 UnicodeSet   *s  = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
4127 
4128                 // Loop through input, until either the input is exhausted or
4129                 //   we reach a character that is not a member of the set.
4130                 int64_t ix = fp-&gt;fInputIdx;
4131                 UTEXT_SETNATIVEINDEX(fInputText, ix);
4132                 for (;;) {
4133                     if (ix &gt;= fActiveLimit) {
4134                         fHitEnd = TRUE;
4135                         break;
4136                     }
4137                     UChar32 c = UTEXT_NEXT32(fInputText);
4138                     if (c&lt;256) {
4139                         if (s8-&gt;contains(c) == FALSE) {
4140                             break;
4141                         }
4142                     } else {
4143                         if (s-&gt;contains(c) == FALSE) {
4144                             break;
4145                         }
4146                     }
</pre>
<hr />
<pre>
4259                 if (prevC == 0x0a &amp;&amp;
4260                     fp-&gt;fInputIdx &gt; backSearchIndex &amp;&amp;
4261                     twoPrevC == 0x0d) {
4262                     int32_t prevOp = (int32_t)pat[fp-&gt;fPatIdx-2];
4263                     if (URX_TYPE(prevOp) == URX_LOOP_DOT_I) {
4264                         // .*, stepping back over CRLF pair.
4265                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
4266                     }
4267                 }
4268 
4269 
4270                 fp = StateSave(fp, fp-&gt;fPatIdx-1, status);
4271             }
4272             break;
4273 
4274 
4275 
4276         default:
4277             // Trouble.  The compiled pattern contains an entry with an
4278             //           unrecognized type tag.
<span class="line-modified">4279             UPRV_UNREACHABLE;</span>
4280         }
4281 
4282         if (U_FAILURE(status)) {
4283             isMatch = FALSE;
4284             break;
4285         }
4286     }
4287 
4288 breakFromLoop:
4289     fMatch = isMatch;
4290     if (isMatch) {
4291         fLastMatchEnd = fMatchEnd;
4292         fMatchStart   = startIdx;
4293         fMatchEnd     = fp-&gt;fInputIdx;
4294     }
4295 
4296 #ifdef REGEX_RUN_DEBUG
4297     if (fTraceDebug) {
4298         if (isMatch) {
4299             printf(&quot;Match.  start=%ld   end=%ld\n\n&quot;, fMatchStart, fMatchEnd);
</pre>
<hr />
<pre>
4331     int32_t     opType;                //    the opcode
4332     int32_t     opValue;               //    and the operand value.
4333 
4334 #ifdef REGEX_RUN_DEBUG
4335     if (fTraceDebug) {
4336         printf(&quot;MatchAt(startIdx=%d)\n&quot;, startIdx);
4337         printf(&quot;Original Pattern: \&quot;%s\&quot;\n&quot;, CStr(StringFromUText(fPattern-&gt;fPattern))());
4338         printf(&quot;Input String:     \&quot;%s\&quot;\n\n&quot;, CStr(StringFromUText(fInputText))());
4339     }
4340 #endif
4341 
4342     if (U_FAILURE(status)) {
4343         return;
4344     }
4345 
4346     //  Cache frequently referenced items from the compiled pattern
4347     //
4348     int64_t             *pat           = fPattern-&gt;fCompiledPat-&gt;getBuffer();
4349 
4350     const UChar         *litText       = fPattern-&gt;fLiteralText.getBuffer();
<span class="line-modified">4351     UVector             *fSets         = fPattern-&gt;fSets;</span>
4352 
4353     const UChar         *inputBuf      = fInputText-&gt;chunkContents;
4354 
4355     fFrameSize = fPattern-&gt;fFrameSize;
4356     REStackFrame        *fp            = resetStack();
4357     if (U_FAILURE(fDeferredStatus)) {
4358         status = fDeferredStatus;
4359         return;
4360     }
4361 
4362     fp-&gt;fPatIdx   = 0;
4363     fp-&gt;fInputIdx = startIdx;
4364 
4365     // Zero out the pattern&#39;s static data
4366     int32_t i;
4367     for (i = 0; i&lt;fPattern-&gt;fDataSize; i++) {
4368         fData[i] = 0;
4369     }
4370 
4371     //
</pre>
<hr />
<pre>
4909                     }
4910                 } else {
4911                     const UnicodeSet *s = fPattern-&gt;fStaticSets[opValue];
4912                     if (s-&gt;contains(c) == FALSE) {
4913                         break;
4914                     }
4915                 }
4916                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4917             }
4918             break;
4919 
4920 
4921         case URX_SETREF:
4922             {
4923                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4924                     fHitEnd = TRUE;
4925                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4926                     break;
4927                 }
4928 
<span class="line-modified">4929                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
4930 
4931                 // There is input left.  Pick up one char and test it for set membership.
4932                 UChar32  c;
4933                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4934                 if (c&lt;256) {
4935                     Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
4936                     if (s8-&gt;contains(c)) {
4937                         // The character is in the set.  A Match.
4938                         break;
4939                     }
4940                 } else {
<span class="line-modified">4941                     UnicodeSet *s = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
4942                     if (s-&gt;contains(c)) {
4943                         // The character is in the set.  A Match.
4944                         break;
4945                     }
4946                 }
4947 
4948                 // the character wasn&#39;t in the set.
4949                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4950             }
4951             break;
4952 
4953 
4954         case URX_DOTANY:
4955             {
4956                 // . matches anything, but stops at end-of-line.
4957                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4958                     // At end of input.  Match failed.  Backtrack out.
4959                     fHitEnd = TRUE;
4960                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4961                     break;
</pre>
<hr />
<pre>
5195                     //   in the following pattern will try another iteration of the loop.
5196                     fp = StateSave(fp, opValue + 4, status);
5197                 }
5198             }
5199             break;
5200 
5201         case URX_STO_SP:
5202             U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
5203             fData[opValue] = fStack-&gt;size();
5204             break;
5205 
5206         case URX_LD_SP:
5207             {
5208                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
5209                 int32_t newStackSize = (int32_t)fData[opValue];
5210                 U_ASSERT(newStackSize &lt;= fStack-&gt;size());
5211                 int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
5212                 if (newFP == (int64_t *)fp) {
5213                     break;
5214                 }
<span class="line-modified">5215                 int32_t j;</span>
<span class="line-modified">5216                 for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">5217                     newFP[j] = ((int64_t *)fp)[j];</span>
5218                 }
5219                 fp = (REStackFrame *)newFP;
5220                 fStack-&gt;setSize(newStackSize);
5221             }
5222             break;
5223 
5224         case URX_BACKREF:
5225             {
5226                 U_ASSERT(opValue &lt; fFrameSize);
5227                 int64_t groupStartIdx = fp-&gt;fExtra[opValue];
5228                 int64_t groupEndIdx   = fp-&gt;fExtra[opValue+1];
5229                 U_ASSERT(groupStartIdx &lt;= groupEndIdx);
5230                 int64_t inputIndex = fp-&gt;fInputIdx;
5231                 if (groupStartIdx &lt; 0) {
5232                     // This capture group has not participated in the match thus far,
5233                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);   // FAIL, no match.
5234                     break;
5235                 }
5236                 UBool success = TRUE;
5237                 for (int64_t groupIndex = groupStartIdx; groupIndex &lt; groupEndIdx; ++groupIndex,++inputIndex) {
</pre>
<hr />
<pre>
5342                 fData[opValue]   = fStack-&gt;size();
5343                 fData[opValue+1] = fp-&gt;fInputIdx;
5344                 fActiveStart     = fLookStart;          // Set the match region change for
5345                 fActiveLimit     = fLookLimit;          //   transparent bounds.
5346             }
5347             break;
5348 
5349         case URX_LA_END:
5350             {
5351                 // Leaving a look-ahead block.
5352                 //  restore Stack Ptr, Input Pos to positions they had on entry to block.
5353                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5354                 int32_t stackSize = fStack-&gt;size();
5355                 int32_t newStackSize = (int32_t)fData[opValue];
5356                 U_ASSERT(stackSize &gt;= newStackSize);
5357                 if (stackSize &gt; newStackSize) {
5358                     // Copy the current top frame back to the new (cut back) top frame.
5359                     //   This makes the capture groups from within the look-ahead
5360                     //   expression available.
5361                     int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
<span class="line-modified">5362                     int32_t j;</span>
<span class="line-modified">5363                     for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">5364                         newFP[j] = ((int64_t *)fp)[j];</span>
5365                     }
5366                     fp = (REStackFrame *)newFP;
5367                     fStack-&gt;setSize(newStackSize);
5368                 }
5369                 fp-&gt;fInputIdx = fData[opValue+1];
5370 
5371                 // Restore the active region bounds in the input string; they may have
5372                 //    been changed because of transparent bounds on a Region.
5373                 fActiveStart = fRegionStart;
5374                 fActiveLimit = fRegionLimit;
5375             }
5376             break;
5377 
5378         case URX_ONECHAR_I:
5379             if (fp-&gt;fInputIdx &lt; fActiveLimit) {
5380                 UChar32 c;
5381                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
5382                 if (u_foldCase(c, U_FOLD_CASE_DEFAULT) == opValue) {
5383                     break;
5384                 }
</pre>
<hr />
<pre>
5604                 // Restore original stack position, discarding any state saved
5605                 //   by the successful pattern match.
5606                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5607                 int32_t newStackSize = (int32_t)fData[opValue];
5608                 U_ASSERT(fStack-&gt;size() &gt; newStackSize);
5609                 fStack-&gt;setSize(newStackSize);
5610 
5611                 //  FAIL, which will take control back to someplace
5612                 //  prior to entering the look-behind test.
5613                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5614             }
5615             break;
5616 
5617 
5618         case URX_LOOP_SR_I:
5619             // Loop Initialization for the optimized implementation of
5620             //     [some character set]*
5621             //   This op scans through all matching input.
5622             //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
5623             {
<span class="line-modified">5624                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
5625                 Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
<span class="line-modified">5626                 UnicodeSet   *s  = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
5627 
5628                 // Loop through input, until either the input is exhausted or
5629                 //   we reach a character that is not a member of the set.
5630                 int32_t ix = (int32_t)fp-&gt;fInputIdx;
5631                 for (;;) {
5632                     if (ix &gt;= fActiveLimit) {
5633                         fHitEnd = TRUE;
5634                         break;
5635                     }
5636                     UChar32   c;
5637                     U16_NEXT(inputBuf, ix, fActiveLimit, c);
5638                     if (c&lt;256) {
5639                         if (s8-&gt;contains(c) == FALSE) {
5640                             U16_BACK_1(inputBuf, 0, ix);
5641                             break;
5642                         }
5643                     } else {
5644                         if (s-&gt;contains(c) == FALSE) {
5645                             U16_BACK_1(inputBuf, 0, ix);
5646                             break;
</pre>
<hr />
<pre>
5759                 if (prevC == 0x0a &amp;&amp;
5760                     fp-&gt;fInputIdx &gt; backSearchIndex &amp;&amp;
5761                     inputBuf[fp-&gt;fInputIdx-1] == 0x0d) {
5762                     int32_t prevOp = (int32_t)pat[fp-&gt;fPatIdx-2];
5763                     if (URX_TYPE(prevOp) == URX_LOOP_DOT_I) {
5764                         // .*, stepping back over CRLF pair.
5765                         U16_BACK_1(inputBuf, 0, fp-&gt;fInputIdx);
5766                     }
5767                 }
5768 
5769 
5770                 fp = StateSave(fp, fp-&gt;fPatIdx-1, status);
5771             }
5772             break;
5773 
5774 
5775 
5776         default:
5777             // Trouble.  The compiled pattern contains an entry with an
5778             //           unrecognized type tag.
<span class="line-modified">5779             UPRV_UNREACHABLE;</span>
5780         }
5781 
5782         if (U_FAILURE(status)) {
5783             isMatch = FALSE;
5784             break;
5785         }
5786     }
5787 
5788 breakFromLoop:
5789     fMatch = isMatch;
5790     if (isMatch) {
5791         fLastMatchEnd = fMatchEnd;
5792         fMatchStart   = startIdx;
5793         fMatchEnd     = fp-&gt;fInputIdx;
5794     }
5795 
5796 #ifdef REGEX_RUN_DEBUG
5797     if (fTraceDebug) {
5798         if (isMatch) {
5799             printf(&quot;Match.  start=%ld   end=%ld\n\n&quot;, fMatchStart, fMatchEnd);
</pre>
</td>
</tr>
</table>
<center><a href="reldtfmt.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rulebasedcollator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>