diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_rounding.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_rounding.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_rounding.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_rounding.cpp
@@ -53,11 +53,11 @@
 
 
 MultiplierProducer::~MultiplierProducer() = default;
 
 
-digits_t roundingutils::doubleFractionLength(double input) {
+digits_t roundingutils::doubleFractionLength(double input, int8_t* singleDigit) {
     char buffer[DoubleToStringConverter::kBase10MaximalLength + 1];
     bool sign; // unused; always positive
     int32_t length;
     int32_t point;
     DoubleToStringConverter::DoubleToAscii(
@@ -69,10 +69,18 @@
             &sign,
             &length,
             &point
     );
 
+    if (singleDigit == nullptr) {
+        // no-op
+    } else if (length == 1) {
+        *singleDigit = buffer[0] - '0';
+    } else {
+        *singleDigit = -1;
+    }
+
     return static_cast<digits_t>(length - point);
 }
 
 
 Precision Precision::unlimited() {
@@ -159,17 +167,10 @@
 
 CurrencyPrecision Precision::currency(UCurrencyUsage currencyUsage) {
     return constructCurrency(currencyUsage);
 }
 
-Precision Precision::withMode(RoundingMode roundingMode) const {
-    if (fType == RND_ERROR) { return *this; } // no-op in error state
-    Precision retval = *this;
-    retval.fRoundingMode = roundingMode;
-    return retval;
-}
-
 Precision FractionPrecision::withMinDigits(int32_t minSignificantDigits) const {
     if (fType == RND_ERROR) { return *this; } // no-op in error state
     if (minSignificantDigits >= 1 && minSignificantDigits <= kMaxIntFracSig) {
         return constructFractionSignificant(*this, minSignificantDigits, -1);
     } else {
@@ -252,18 +253,31 @@
     return {RND_FRACTION_SIGNIFICANT, union_, kDefaultMode};
 }
 
 IncrementPrecision Precision::constructIncrement(double increment, int32_t minFrac) {
     IncrementSettings settings;
+    // Note: For number formatting, fIncrement is used for RND_INCREMENT but not
+    // RND_INCREMENT_ONE or RND_INCREMENT_FIVE. However, fIncrement is used in all
+    // three when constructing a skeleton.
     settings.fIncrement = increment;
     settings.fMinFrac = static_cast<digits_t>(minFrac);
     // One of the few pre-computed quantities:
     // Note: it is possible for minFrac to be more than maxFrac... (misleading)
-    settings.fMaxFrac = roundingutils::doubleFractionLength(increment);
+    int8_t singleDigit;
+    settings.fMaxFrac = roundingutils::doubleFractionLength(increment, &singleDigit);
     PrecisionUnion union_;
     union_.increment = settings;
-    return {RND_INCREMENT, union_, kDefaultMode};
+    if (singleDigit == 1) {
+        // NOTE: In C++, we must return the correct value type with the correct union.
+        // It would be invalid to return a RND_FRACTION here because the methods on the
+        // IncrementPrecision type assume that the union is backed by increment data.
+        return {RND_INCREMENT_ONE, union_, kDefaultMode};
+    } else if (singleDigit == 5) {
+        return {RND_INCREMENT_FIVE, union_, kDefaultMode};
+    } else {
+        return {RND_INCREMENT, union_, kDefaultMode};
+    }
 }
 
 CurrencyPrecision Precision::constructCurrency(UCurrencyUsage usage) {
     PrecisionUnion union_;
     union_.currencyUsage = usage;
@@ -346,26 +360,24 @@
         case Precision::RND_FRACTION:
             value.roundToMagnitude(
                     getRoundingMagnitudeFraction(fPrecision.fUnion.fracSig.fMaxFrac),
                     fRoundingMode,
                     status);
-            value.setFractionLength(
-                    uprv_max(0, -getDisplayMagnitudeFraction(fPrecision.fUnion.fracSig.fMinFrac)),
-                    INT32_MAX);
+            value.setMinFraction(
+                    uprv_max(0, -getDisplayMagnitudeFraction(fPrecision.fUnion.fracSig.fMinFrac)));
             break;
 
         case Precision::RND_SIGNIFICANT:
             value.roundToMagnitude(
                     getRoundingMagnitudeSignificant(value, fPrecision.fUnion.fracSig.fMaxSig),
                     fRoundingMode,
                     status);
-            value.setFractionLength(
-                    uprv_max(0, -getDisplayMagnitudeSignificant(value, fPrecision.fUnion.fracSig.fMinSig)),
-                    INT32_MAX);
+            value.setMinFraction(
+                    uprv_max(0, -getDisplayMagnitudeSignificant(value, fPrecision.fUnion.fracSig.fMinSig)));
             // Make sure that digits are displayed on zero.
             if (value.isZero() && fPrecision.fUnion.fracSig.fMinSig > 0) {
-                value.setIntegerLength(1, INT32_MAX);
+                value.setMinInteger(1);
             }
             break;
 
         case Precision::RND_FRACTION_SIGNIFICANT: {
             int32_t displayMag = getDisplayMagnitudeFraction(fPrecision.fUnion.fracSig.fMinFrac);
@@ -382,33 +394,50 @@
                         value,
                         fPrecision.fUnion.fracSig.fMinSig);
                 roundingMag = uprv_min(roundingMag, candidate);
             }
             value.roundToMagnitude(roundingMag, fRoundingMode, status);
-            value.setFractionLength(uprv_max(0, -displayMag), INT32_MAX);
+            value.setMinFraction(uprv_max(0, -displayMag));
             break;
         }
 
         case Precision::RND_INCREMENT:
             value.roundToIncrement(
                     fPrecision.fUnion.increment.fIncrement,
                     fRoundingMode,
-                    fPrecision.fUnion.increment.fMaxFrac,
                     status);
-            value.setFractionLength(fPrecision.fUnion.increment.fMinFrac, INT32_MAX);
+            value.setMinFraction(fPrecision.fUnion.increment.fMinFrac);
+            break;
+
+        case Precision::RND_INCREMENT_ONE:
+            value.roundToMagnitude(
+                    -fPrecision.fUnion.increment.fMaxFrac,
+                    fRoundingMode,
+                    status);
+            value.setMinFraction(fPrecision.fUnion.increment.fMinFrac);
+            break;
+
+        case Precision::RND_INCREMENT_FIVE:
+            value.roundToNickel(
+                    -fPrecision.fUnion.increment.fMaxFrac,
+                    fRoundingMode,
+                    status);
+            value.setMinFraction(fPrecision.fUnion.increment.fMinFrac);
             break;
 
         case Precision::RND_CURRENCY:
             // Call .withCurrency() before .apply()!
-            U_ASSERT(false);
-            break;
+            UPRV_UNREACHABLE;
+
+        default:
+            UPRV_UNREACHABLE;
     }
 }
 
 void RoundingImpl::apply(impl::DecimalQuantity &value, int32_t minInt, UErrorCode /*status*/) {
     // This method is intended for the one specific purpose of helping print "00.000E0".
     U_ASSERT(isSignificantDigits());
     U_ASSERT(value.isZero());
-    value.setFractionLength(fPrecision.fUnion.fracSig.fMinSig - minInt, INT32_MAX);
+    value.setMinFraction(fPrecision.fUnion.fracSig.fMinSig - minInt);
 }
 
 #endif /* #if !UCONFIG_NO_FORMATTING */
