<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/putil.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="propname_data.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="putilimp.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/putil.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  85 #endif
  86 
  87 
  88 /* include system headers */
  89 #if U_PLATFORM_USES_ONLY_WIN32_API
  90     /*
  91      * TODO: U_PLATFORM_USES_ONLY_WIN32_API includes MinGW.
  92      * Should Cygwin be included as well (U_PLATFORM_HAS_WIN32_API)
  93      * to use native APIs as much as possible?
  94      */
  95 #ifndef WIN32_LEAN_AND_MEAN
  96 #   define WIN32_LEAN_AND_MEAN
  97 #endif
  98 #   define VC_EXTRALEAN
  99 #   define NOUSER
 100 #   define NOSERVICE
 101 #   define NOIME
 102 #   define NOMCX
 103 #   include &lt;windows.h&gt;
 104 #   include &quot;unicode/uloc.h&quot;
<span class="line-removed"> 105 #if U_PLATFORM_HAS_WINUWP_API == 0</span>
 106 #   include &quot;wintz.h&quot;
<span class="line-removed"> 107 #else // U_PLATFORM_HAS_WINUWP_API</span>
<span class="line-removed"> 108 typedef PVOID LPMSG; // TODO: figure out how to get rid of this typedef</span>
<span class="line-removed"> 109 #include &lt;Windows.Globalization.h&gt;</span>
<span class="line-removed"> 110 #include &lt;windows.system.userprofile.h&gt;</span>
<span class="line-removed"> 111 #include &lt;wrl/wrappers/corewrappers.h&gt;</span>
<span class="line-removed"> 112 #include &lt;wrl/client.h&gt;</span>
<span class="line-removed"> 113 </span>
<span class="line-removed"> 114 using namespace ABI::Windows::Foundation;</span>
<span class="line-removed"> 115 using namespace Microsoft::WRL;</span>
<span class="line-removed"> 116 using namespace Microsoft::WRL::Wrappers;</span>
<span class="line-removed"> 117 #endif</span>
 118 #elif U_PLATFORM == U_PF_OS400
 119 #   include &lt;float.h&gt;
 120 #   include &lt;qusec.h&gt;       /* error code structure */
 121 #   include &lt;qusrjobi.h&gt;
 122 #   include &lt;qliept.h&gt;      /* EPT_CALL macro  - this include must be after all other &quot;QSYSINCs&quot; */
 123 #   include &lt;mih/testptr.h&gt; /* For uprv_maximumPtr */
 124 #elif U_PLATFORM == U_PF_OS390
 125 #   include &quot;unicode/ucnv.h&quot;   /* Needed for UCNV_SWAP_LFNL_OPTION_STRING */
 126 #elif U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS
 127 #   include &lt;limits.h&gt;
 128 #   include &lt;unistd.h&gt;
 129 #   if U_PLATFORM == U_PF_SOLARIS
 130 #       ifndef _XPG4_2
 131 #           define _XPG4_2
 132 #       endif
 133 #   endif
 134 #elif U_PLATFORM == U_PF_QNX
 135 #   include &lt;sys/neutrino.h&gt;
 136 #endif
 137 
</pre>
<hr />
<pre>
 236 u_signBit(double d) {
 237     uint8_t hiByte;
 238 #if U_IS_BIG_ENDIAN
 239     hiByte = *(uint8_t *)&amp;d;
 240 #else
 241     hiByte = *(((uint8_t *)&amp;d) + sizeof(double) - 1);
 242 #endif
 243     return (hiByte &amp; 0x80) != 0;
 244 }
 245 #endif
 246 
 247 
 248 
 249 #if defined (U_DEBUG_FAKETIME)
 250 /* Override the clock to test things without having to move the system clock.
 251  * Assumes POSIX gettimeofday() will function
 252  */
 253 UDate fakeClock_t0 = 0; /** Time to start the clock from **/
 254 UDate fakeClock_dt = 0; /** Offset (fake time - real time) **/
 255 UBool fakeClock_set = FALSE; /** True if fake clock has spun up **/
<span class="line-removed"> 256 static UMutex fakeClockMutex = U_MUTEX_INTIALIZER;</span>
 257 
 258 static UDate getUTCtime_real() {
 259     struct timeval posixTime;
 260     gettimeofday(&amp;posixTime, NULL);
 261     return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));
 262 }
 263 
 264 static UDate getUTCtime_fake() {

 265     umtx_lock(&amp;fakeClockMutex);
 266     if(!fakeClock_set) {
 267         UDate real = getUTCtime_real();
 268         const char *fake_start = getenv(&quot;U_FAKETIME_START&quot;);
 269         if((fake_start!=NULL) &amp;&amp; (fake_start[0]!=0)) {
 270             sscanf(fake_start,&quot;%lf&quot;,&amp;fakeClock_t0);
 271             fakeClock_dt = fakeClock_t0 - real;
 272             fprintf(stderr,&quot;U_DEBUG_FAKETIME was set at compile time, so the ICU clock will start at a preset value\n&quot;
 273                     &quot;env variable U_FAKETIME_START=%.0f (%s) for an offset of %.0f ms from the current time %.0f\n&quot;,
 274                     fakeClock_t0, fake_start, fakeClock_dt, real);
 275         } else {
 276           fakeClock_dt = 0;
 277             fprintf(stderr,&quot;U_DEBUG_FAKETIME was set at compile time, but U_FAKETIME_START was not set.\n&quot;
 278                     &quot;Set U_FAKETIME_START to the number of milliseconds since 1/1/1970 to set the ICU clock.\n&quot;);
 279         }
 280         fakeClock_set = TRUE;
 281     }
 282     umtx_unlock(&amp;fakeClockMutex);
 283 
 284     return getUTCtime_real() + fakeClock_dt;
</pre>
<hr />
<pre>
 981     if (U_FAILURE(status)) {
 982         goto cleanupAndReturn;
 983     }
 984 
 985     dirp = opendir(path);
 986     if (dirp == NULL) {
 987         goto cleanupAndReturn;
 988     }
 989 
 990     if (gSearchTZFileResult == NULL) {
 991         gSearchTZFileResult = new CharString;
 992         if (gSearchTZFileResult == NULL) {
 993             goto cleanupAndReturn;
 994         }
 995         ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
 996     }
 997 
 998     /* Check each entry in the directory. */
 999     while((dirEntry = readdir(dirp)) != NULL) {
1000         const char* dirName = dirEntry-&gt;d_name;
<span class="line-modified">1001         if (uprv_strcmp(dirName, SKIP1) != 0 &amp;&amp; uprv_strcmp(dirName, SKIP2) != 0) {</span>

1002             /* Create a newpath with the new entry to test each entry in the directory. */
1003             CharString newpath(curpath, status);
1004             newpath.append(dirName, -1, status);
1005             if (U_FAILURE(status)) {
1006                 break;
1007             }
1008 
1009             DIR* subDirp = NULL;
1010             if ((subDirp = opendir(newpath.data())) != NULL) {
1011                 /* If this new path is a directory, make a recursive call with the newpath. */
1012                 closedir(subDirp);
1013                 newpath.append(&#39;/&#39;, status);
1014                 if (U_FAILURE(status)) {
1015                     break;
1016                 }
1017                 result = searchForTZFile(newpath.data(), tzInfo);
1018                 /*
1019                  Have to get out here. Otherwise, we&#39;d keep looking
1020                  and return the first match in the top-level directory
1021                  if there&#39;s a match in the top-level. If not, this function
1022                  would return NULL and set gTimeZoneBufferPtr to NULL in initDefault().
1023                  It worked without this in most cases because we have a fallback of calling
1024                  localtime_r to figure out the default timezone.
1025                 */
1026                 if (result != NULL)
1027                     break;
<span class="line-modified">1028             } else if (uprv_strcmp(TZFILE_SKIP, dirName) != 0 &amp;&amp; uprv_strcmp(TZFILE_SKIP2, dirName) != 0) {</span>
1029                 if(compareBinaryFiles(TZDEFAULT, newpath.data(), tzInfo)) {
1030                     int32_t amountToSkip = sizeof(TZZONEINFO) - 1;
1031                     if (amountToSkip &gt; newpath.length()) {
1032                         amountToSkip = newpath.length();
1033                     }
1034                     const char* zoneid = newpath.data() + amountToSkip;
1035                     skipZoneIDPrefix(&amp;zoneid);
1036                     gSearchTZFileResult-&gt;clear();
1037                     gSearchTZFileResult-&gt;append(zoneid, -1, status);
1038                     if (U_FAILURE(status)) {
1039                         break;
1040                     }
1041                     result = gSearchTZFileResult-&gt;data();
1042                     /* Get out after the first one found. */
1043                     break;
1044                 }
1045             }
1046         }
1047     }
1048 
1049   cleanupAndReturn:
1050     if (dirp) {
1051         closedir(dirp);
1052     }
1053     return result;
1054 }
1055 #endif
1056 
1057 U_CAPI void U_EXPORT2
1058 uprv_tzname_clear_cache()
1059 {
1060 #if defined(CHECK_LOCALTIME_LINK) &amp;&amp; !defined(DEBUG_SKIP_LOCALTIME_LINK)
1061     gTimeZoneBufferPtr = NULL;
1062 #endif
1063 }
1064 
<span class="line-removed">1065 // With the Universal Windows Platform we can just ask Windows for the name</span>
<span class="line-removed">1066 #if U_PLATFORM_HAS_WINUWP_API</span>
<span class="line-removed">1067 U_CAPI const char* U_EXPORT2</span>
<span class="line-removed">1068 uprv_getWindowsTimeZone()</span>
<span class="line-removed">1069 {</span>
<span class="line-removed">1070     // Get default Windows timezone.</span>
<span class="line-removed">1071     ComPtr&lt;IInspectable&gt; calendar;</span>
<span class="line-removed">1072     HRESULT hr = RoActivateInstance(</span>
<span class="line-removed">1073         HStringReference(RuntimeClass_Windows_Globalization_Calendar).Get(),</span>
<span class="line-removed">1074         &amp;calendar);</span>
<span class="line-removed">1075     if (SUCCEEDED(hr))</span>
<span class="line-removed">1076     {</span>
<span class="line-removed">1077         ComPtr&lt;ABI::Windows::Globalization::ITimeZoneOnCalendar&gt; timezone;</span>
<span class="line-removed">1078         hr = calendar.As(&amp;timezone);</span>
<span class="line-removed">1079         if (SUCCEEDED(hr))</span>
<span class="line-removed">1080         {</span>
<span class="line-removed">1081             HString timezoneString;</span>
<span class="line-removed">1082             hr = timezone-&gt;GetTimeZone(timezoneString.GetAddressOf());</span>
<span class="line-removed">1083             if (SUCCEEDED(hr))</span>
<span class="line-removed">1084             {</span>
<span class="line-removed">1085                 int32_t length = static_cast&lt;int32_t&gt;(wcslen(timezoneString.GetRawBuffer(NULL)));</span>
<span class="line-removed">1086                 char* asciiId = (char*)uprv_calloc(length + 1, sizeof(char));</span>
<span class="line-removed">1087                 if (asciiId != nullptr)</span>
<span class="line-removed">1088                 {</span>
<span class="line-removed">1089                     u_UCharsToChars((UChar*)timezoneString.GetRawBuffer(NULL), asciiId, length);</span>
<span class="line-removed">1090                     return asciiId;</span>
<span class="line-removed">1091                 }</span>
<span class="line-removed">1092             }</span>
<span class="line-removed">1093         }</span>
<span class="line-removed">1094     }</span>
<span class="line-removed">1095 </span>
<span class="line-removed">1096     // Failed</span>
<span class="line-removed">1097     return nullptr;</span>
<span class="line-removed">1098 }</span>
<span class="line-removed">1099 #endif</span>
<span class="line-removed">1100 </span>
1101 U_CAPI const char* U_EXPORT2
1102 uprv_tzname(int n)
1103 {
1104     (void)n; // Avoid unreferenced parameter warning.
1105     const char *tzid = NULL;
1106 #if U_PLATFORM_USES_ONLY_WIN32_API
<span class="line-removed">1107 #if U_PLATFORM_HAS_WINUWP_API &gt; 0</span>
<span class="line-removed">1108     tzid = uprv_getWindowsTimeZone();</span>
<span class="line-removed">1109 #else</span>
1110     tzid = uprv_detectWindowsTimeZone();
<span class="line-removed">1111 #endif</span>
1112 
1113     if (tzid != NULL) {
1114         return tzid;
1115     }
1116 
1117 #ifndef U_TZNAME
1118     // The return value is free&#39;d in timezone.cpp on Windows because
1119     // the other code path returns a pointer to a heap location.
1120     // If we don&#39;t have a name already, then tzname wouldn&#39;t be any
1121     // better, so just fall back.
<span class="line-modified">1122     return uprv_strdup(&quot;Etc/UTC&quot;);</span>
1123 #endif // !U_TZNAME
1124 
1125 #else
1126 
1127 /*#if U_PLATFORM_IS_DARWIN_BASED
1128     int ret;
1129 
1130     tzid = getenv(&quot;TZFILE&quot;);
1131     if (tzid != NULL) {
1132         return tzid;
1133     }
1134 #endif*/
1135 
1136 /* This code can be temporarily disabled to test tzname resolution later on. */
1137 #ifndef DEBUG_TZNAME
1138     tzid = getenv(&quot;TZ&quot;);
1139     if (tzid != NULL &amp;&amp; isValidOlsonID(tzid)
1140 #if U_PLATFORM == U_PF_SOLARIS
1141     /* When TZ equals localtime on Solaris, check the /etc/localtime file. */
1142         &amp;&amp; uprv_strcmp(tzid, TZ_ENV_CHECK) != 0
</pre>
<hr />
<pre>
1341     return TRUE;
1342   }
1343 
1344 #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
1345   if(*path == U_FILE_ALT_SEP_CHAR) {
1346     return TRUE;
1347   }
1348 #endif
1349 
1350 #if U_PLATFORM_USES_ONLY_WIN32_API
1351   if( (((path[0] &gt;= &#39;A&#39;) &amp;&amp; (path[0] &lt;= &#39;Z&#39;)) ||
1352        ((path[0] &gt;= &#39;a&#39;) &amp;&amp; (path[0] &lt;= &#39;z&#39;))) &amp;&amp;
1353       path[1] == &#39;:&#39; ) {
1354     return TRUE;
1355   }
1356 #endif
1357 
1358   return FALSE;
1359 }
1360 
<span class="line-modified">1361 /* Temporary backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR</span>
<span class="line-modified">1362    until some client wrapper makefiles are updated */</span>
<span class="line-modified">1363 #if U_PLATFORM_IS_DARWIN_BASED &amp;&amp; TARGET_IPHONE_SIMULATOR</span>
1364 # if !defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1365 #  define ICU_DATA_DIR_PREFIX_ENV_VAR &quot;IPHONE_SIMULATOR_ROOT&quot;
1366 # endif
1367 #endif
1368 





































1369 static void U_CALLCONV dataDirectoryInitFn() {
1370     /* If we already have the directory, then return immediately. Will happen if user called
1371      * u_setDataDirectory().
1372      */
1373     if (gDataDirectory) {
1374         return;
1375     }
1376 
1377     const char *path = NULL;
1378 #if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1379     char datadir_path_buffer[PATH_MAX];
1380 #endif
1381 
1382     /*
1383     When ICU_NO_USER_DATA_OVERRIDE is defined, users aren&#39;t allowed to
1384     override ICU&#39;s data with the ICU_DATA environment variable. This prevents
1385     problems where multiple custom copies of ICU&#39;s specific version of data
1386     are installed on a system. Either the application must define the data
1387     directory with u_setDataDirectory, define ICU_DATA_DIR when compiling
1388     ICU, set the data with udata_setCommonData or trust that all of the
</pre>
<hr />
<pre>
1408      */
1409 #if defined(ICU_DATA_DIR) || defined(U_ICU_DATA_DEFAULT_DIR)
1410     if(path==NULL || *path==0) {
1411 # if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1412         const char *prefix = getenv(ICU_DATA_DIR_PREFIX_ENV_VAR);
1413 # endif
1414 # ifdef ICU_DATA_DIR
1415         path=ICU_DATA_DIR;
1416 # else
1417         path=U_ICU_DATA_DEFAULT_DIR;
1418 # endif
1419 # if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1420         if (prefix != NULL) {
1421             snprintf(datadir_path_buffer, PATH_MAX, &quot;%s%s&quot;, prefix, path);
1422             path=datadir_path_buffer;
1423         }
1424 # endif
1425     }
1426 #endif
1427 
<span class="line-modified">1428 #if defined(ICU_DATA_DIR_WINDOWS) &amp;&amp; U_PLATFORM_HAS_WINUWP_API != 0</span>
<span class="line-removed">1429     // Use data from the %windir%\globalization\icu directory</span>
<span class="line-removed">1430     // This is only available if ICU is built as a system component</span>
1431     char datadir_path_buffer[MAX_PATH];
<span class="line-modified">1432     UINT length = GetWindowsDirectoryA(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer));</span>
<span class="line-modified">1433     if (length &gt; 0 &amp;&amp; length &lt; (UPRV_LENGTHOF(datadir_path_buffer) - sizeof(ICU_DATA_DIR_WINDOWS) - 1))</span>
<span class="line-removed">1434     {</span>
<span class="line-removed">1435         if (datadir_path_buffer[length - 1] != &#39;\\&#39;)</span>
<span class="line-removed">1436         {</span>
<span class="line-removed">1437             datadir_path_buffer[length++] = &#39;\\&#39;;</span>
<span class="line-removed">1438             datadir_path_buffer[length] = &#39;\0&#39;;</span>
<span class="line-removed">1439         }</span>
<span class="line-removed">1440 </span>
<span class="line-removed">1441         if ((length + 1 + sizeof(ICU_DATA_DIR_WINDOWS)) &lt; UPRV_LENGTHOF(datadir_path_buffer))</span>
<span class="line-removed">1442         {</span>
<span class="line-removed">1443             uprv_strcat(datadir_path_buffer, ICU_DATA_DIR_WINDOWS);</span>
<span class="line-removed">1444             path = datadir_path_buffer;</span>
<span class="line-removed">1445         }</span>
1446     }
1447 #endif
1448 
1449     if(path==NULL) {
1450         /* It looks really bad, set it to something. */
<span class="line-removed">1451 #if U_PLATFORM_HAS_WIN32_API</span>
<span class="line-removed">1452         // Windows UWP will require icudtl.dat file in same directory as icuuc.dll</span>
<span class="line-removed">1453         path = &quot;.\\&quot;;</span>
<span class="line-removed">1454 #else</span>
1455         path = &quot;&quot;;
<span class="line-removed">1456 #endif</span>
1457     }
1458 
1459     u_setDataDirectory(path);
1460     return;
1461 }
1462 
1463 U_CAPI const char * U_EXPORT2
1464 u_getDataDirectory(void) {
1465     umtx_initOnce(gDataDirInitOnce, &amp;dataDirectoryInitFn);
1466     return gDataDirectory;
1467 }
1468 
1469 static void setTimeZoneFilesDir(const char *path, UErrorCode &amp;status) {
1470     if (U_FAILURE(status)) {
1471         return;
1472     }
1473     gTimeZoneFilesDirectory-&gt;clear();
1474     gTimeZoneFilesDirectory-&gt;append(path, status);
1475 #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
1476     char *p = gTimeZoneFilesDirectory-&gt;data();
1477     while ((p = uprv_strchr(p, U_FILE_ALT_SEP_CHAR)) != NULL) {
1478         *p = U_FILE_SEP_CHAR;
1479     }
1480 #endif
1481 }
1482 
1483 #define TO_STRING(x) TO_STRING_2(x)
1484 #define TO_STRING_2(x) #x
1485 
1486 static void U_CALLCONV TimeZoneDataDirInitFn(UErrorCode &amp;status) {
1487     U_ASSERT(gTimeZoneFilesDirectory == NULL);
1488     ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
1489     gTimeZoneFilesDirectory = new CharString();
1490     if (gTimeZoneFilesDirectory == NULL) {
1491         status = U_MEMORY_ALLOCATION_ERROR;
1492         return;
1493     }
<span class="line-modified">1494 #if U_PLATFORM_HAS_WINUWP_API == 0</span>
<span class="line-removed">1495     const char *dir = getenv(&quot;ICU_TIMEZONE_FILES_DIR&quot;);</span>
<span class="line-removed">1496 #else</span>
<span class="line-removed">1497     // TODO: UWP does not support alternate timezone data directories at this time</span>
1498     const char *dir = &quot;&quot;;









1499 #endif // U_PLATFORM_HAS_WINUWP_API

1500 #if defined(U_TIMEZONE_FILES_DIR)
1501     if (dir == NULL) {

1502         dir = TO_STRING(U_TIMEZONE_FILES_DIR);
1503     }
1504 #endif

1505     if (dir == NULL) {
1506         dir = &quot;&quot;;
1507     }

1508     setTimeZoneFilesDir(dir, status);
1509 }
1510 
1511 
1512 U_CAPI const char * U_EXPORT2
1513 u_getTimeZoneFilesDirectory(UErrorCode *status) {
1514     umtx_initOnce(gTimeZoneFilesInitOnce, &amp;TimeZoneDataDirInitFn, *status);
1515     return U_SUCCESS(*status) ? gTimeZoneFilesDirectory-&gt;data() : &quot;&quot;;
1516 }
1517 
1518 U_CAPI void U_EXPORT2
1519 u_setTimeZoneFilesDirectory(const char *path, UErrorCode *status) {
1520     umtx_initOnce(gTimeZoneFilesInitOnce, &amp;TimeZoneDataDirInitFn, *status);
1521     setTimeZoneFilesDir(path, *status);
1522 
1523     // Note: this function does some extra churn, first setting based on the
1524     //       environment, then immediately replacing with the value passed in.
1525     //       The logic is simpler that way, and performance shouldn&#39;t be an issue.
1526 }
1527 
</pre>
<hr />
<pre>
1624      LC_ALL  ----&gt;     default_loc          codepage
1625 --------------------------------------------------------
1626      ab.CD             ab                   CD
1627      ab@CD             ab__CD               -
1628      ab@CD.EF          ab__CD               EF
1629 
1630      ab_CD.EF@GH       ab_CD_GH             EF
1631 
1632 Some &#39;improper&#39; ways to do the same as above:
1633   !  ab_CD@GH.EF       ab_CD_GH             EF
1634   !  ab_CD.EF@GH.IJ    ab_CD_GH             EF
1635   !  ab_CD@ZZ.EF@GH.IJ ab_CD_GH             EF
1636 
1637      _CD@GH            _CD_GH               -
1638      _CD.EF@GH         _CD_GH               EF
1639 
1640 The variant cannot have dots in it.
1641 The &#39;rightmost&#39; variant (@xxx) wins.
1642 The leftmost codepage (.xxx) wins.
1643 */
<span class="line-removed">1644     char *correctedPOSIXLocale = 0;</span>
1645     const char* posixID = uprv_getPOSIXIDForDefaultLocale();
<span class="line-removed">1646     const char *p;</span>
<span class="line-removed">1647     const char *q;</span>
<span class="line-removed">1648     int32_t len;</span>
1649 
1650     /* Format: (no spaces)
1651     ll [ _CC ] [ . MM ] [ @ VV]
1652 
1653       l = lang, C = ctry, M = charmap, V = variant
1654     */
1655 
<span class="line-modified">1656     if (gCorrectedPOSIXLocale != NULL) {</span>
1657         return gCorrectedPOSIXLocale;
1658     }
1659 
<span class="line-modified">1660     if ((p = uprv_strchr(posixID, &#39;.&#39;)) != NULL) {</span>
<span class="line-modified">1661         /* assume new locale can&#39;t be larger than old one? */</span>
<span class="line-modified">1662         correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(uprv_strlen(posixID)+1));</span>
<span class="line-modified">1663         /* Exit on memory allocation error. */</span>
<span class="line-modified">1664         if (correctedPOSIXLocale == NULL) {</span>
<span class="line-modified">1665             return NULL;</span>
<span class="line-modified">1666         }</span>
<span class="line-removed">1667         uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);</span>
<span class="line-removed">1668         correctedPOSIXLocale[p-posixID] = 0;</span>
1669 
<span class="line-modified">1670         /* do not copy after the @ */</span>
<span class="line-modified">1671         if ((p = uprv_strchr(correctedPOSIXLocale, &#39;@&#39;)) != NULL) {</span>
<span class="line-modified">1672             correctedPOSIXLocale[p-correctedPOSIXLocale] = 0;</span>


1673         }
1674     }
1675 
1676     /* Note that we scan the *uncorrected* ID. */
<span class="line-modified">1677     if ((p = uprv_strrchr(posixID, &#39;@&#39;)) != NULL) {</span>
<span class="line-modified">1678         if (correctedPOSIXLocale == NULL) {</span>
<span class="line-removed">1679             correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(uprv_strlen(posixID)+1));</span>
<span class="line-removed">1680             /* Exit on memory allocation error. */</span>
<span class="line-removed">1681             if (correctedPOSIXLocale == NULL) {</span>
<span class="line-removed">1682                 return NULL;</span>
<span class="line-removed">1683             }</span>
<span class="line-removed">1684             uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);</span>
<span class="line-removed">1685             correctedPOSIXLocale[p-posixID] = 0;</span>
<span class="line-removed">1686         }</span>
1687         p++;
1688 
1689         /* Take care of any special cases here.. */
1690         if (!uprv_strcmp(p, &quot;nynorsk&quot;)) {
1691             p = &quot;NY&quot;;
1692             /* Don&#39;t worry about no__NY. In practice, it won&#39;t appear. */
1693         }
1694 
<span class="line-modified">1695         if (uprv_strchr(correctedPOSIXLocale,&#39;_&#39;) == NULL) {</span>
<span class="line-modified">1696             uprv_strcat(correctedPOSIXLocale, &quot;__&quot;); /* aa@b -&gt; aa__b */</span>
1697         }
1698         else {
1699             uprv_strcat(correctedPOSIXLocale, &quot;_&quot;); /* aa_CC@b -&gt; aa_CC_b */
1700         }
1701 
<span class="line-modified">1702         if ((q = uprv_strchr(p, &#39;.&#39;)) != NULL) {</span>

1703             /* How big will the resulting string be? */
<span class="line-modified">1704             len = (int32_t)(uprv_strlen(correctedPOSIXLocale) + (q-p));</span>
1705             uprv_strncat(correctedPOSIXLocale, p, q-p);
1706             correctedPOSIXLocale[len] = 0;
1707         }
1708         else {
1709             /* Anything following the @ sign */
1710             uprv_strcat(correctedPOSIXLocale, p);
1711         }
1712 
1713         /* Should there be a map from &#39;no@nynorsk&#39; -&gt; no_NO_NY here?
1714          * How about &#39;russian&#39; -&gt; &#39;ru&#39;?
1715          * Many of the other locales using ISO codes will be handled by the
1716          * canonicalization functions in uloc_getDefault.
1717          */
1718     }
1719 
<span class="line-modified">1720     /* Was a correction made? */</span>
<span class="line-removed">1721     if (correctedPOSIXLocale != NULL) {</span>
<span class="line-removed">1722         posixID = correctedPOSIXLocale;</span>
<span class="line-removed">1723     }</span>
<span class="line-removed">1724     else {</span>
<span class="line-removed">1725         /* copy it, just in case the original pointer goes away.  See j2395 */</span>
<span class="line-removed">1726         correctedPOSIXLocale = (char *)uprv_malloc(uprv_strlen(posixID) + 1);</span>
<span class="line-removed">1727         /* Exit on memory allocation error. */</span>
<span class="line-removed">1728         if (correctedPOSIXLocale == NULL) {</span>
<span class="line-removed">1729             return NULL;</span>
<span class="line-removed">1730         }</span>
<span class="line-removed">1731         posixID = uprv_strcpy(correctedPOSIXLocale, posixID);</span>
<span class="line-removed">1732     }</span>
<span class="line-removed">1733 </span>
<span class="line-removed">1734     if (gCorrectedPOSIXLocale == NULL) {</span>
1735         gCorrectedPOSIXLocale = correctedPOSIXLocale;
1736         gCorrectedPOSIXLocaleHeapAllocated = true;
1737         ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
<span class="line-modified">1738         correctedPOSIXLocale = NULL;</span>
1739     }

1740 
<span class="line-modified">1741     if (correctedPOSIXLocale != NULL) {  /* Was already set - clean up. */</span>
1742         uprv_free(correctedPOSIXLocale);
1743     }
1744 
1745     return posixID;
1746 
1747 #elif U_PLATFORM_USES_ONLY_WIN32_API
1748 #define POSIX_LOCALE_CAPACITY 64
1749     UErrorCode status = U_ZERO_ERROR;
<span class="line-modified">1750     char *correctedPOSIXLocale = 0;</span>
1751 
1752     // If we have already figured this out just use the cached value
<span class="line-modified">1753     if (gCorrectedPOSIXLocale != NULL) {</span>
1754         return gCorrectedPOSIXLocale;
1755     }
1756 
1757     // No cached value, need to determine the current value
<span class="line-modified">1758     static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH];</span>
<span class="line-modified">1759 #if U_PLATFORM_HAS_WINUWP_API == 0</span>
<span class="line-removed">1760     // If not a Universal Windows App, we&#39;ll need user default language.</span>
<span class="line-removed">1761     // Vista and above should use Locale Names instead of LCIDs</span>
<span class="line-removed">1762     int length = GetUserDefaultLocaleName(windowsLocale, UPRV_LENGTHOF(windowsLocale));</span>
<span class="line-removed">1763 #else</span>
<span class="line-removed">1764     // In a UWP app, we want the top language that the application and user agreed upon</span>
<span class="line-removed">1765     ComPtr&lt;ABI::Windows::Foundation::Collections::IVectorView&lt;HSTRING&gt;&gt; languageList;</span>
<span class="line-removed">1766 </span>
<span class="line-removed">1767     ComPtr&lt;ABI::Windows::Globalization::IApplicationLanguagesStatics&gt; applicationLanguagesStatics;</span>
<span class="line-removed">1768     HRESULT hr = GetActivationFactory(</span>
<span class="line-removed">1769         HStringReference(RuntimeClass_Windows_Globalization_ApplicationLanguages).Get(),</span>
<span class="line-removed">1770         &amp;applicationLanguagesStatics);</span>
<span class="line-removed">1771     if (SUCCEEDED(hr))</span>
<span class="line-removed">1772     {</span>
<span class="line-removed">1773         hr = applicationLanguagesStatics-&gt;get_Languages(&amp;languageList);</span>
<span class="line-removed">1774     }</span>
<span class="line-removed">1775 </span>
<span class="line-removed">1776     if (FAILED(hr))</span>
<span class="line-removed">1777     {</span>
<span class="line-removed">1778         // If there is no application context, then use the top language from the user language profile</span>
<span class="line-removed">1779         ComPtr&lt;ABI::Windows::System::UserProfile::IGlobalizationPreferencesStatics&gt; globalizationPreferencesStatics;</span>
<span class="line-removed">1780         hr = GetActivationFactory(</span>
<span class="line-removed">1781             HStringReference(RuntimeClass_Windows_System_UserProfile_GlobalizationPreferences).Get(),</span>
<span class="line-removed">1782             &amp;globalizationPreferencesStatics);</span>
<span class="line-removed">1783         if (SUCCEEDED(hr))</span>
<span class="line-removed">1784         {</span>
<span class="line-removed">1785             hr = globalizationPreferencesStatics-&gt;get_Languages(&amp;languageList);</span>
<span class="line-removed">1786         }</span>
<span class="line-removed">1787     }</span>
<span class="line-removed">1788 </span>
<span class="line-removed">1789     // We have a list of languages, ICU knows one, so use the top one for our locale</span>
<span class="line-removed">1790     HString topLanguage;</span>
<span class="line-removed">1791     if (SUCCEEDED(hr))</span>
<span class="line-removed">1792     {</span>
<span class="line-removed">1793         hr = languageList-&gt;GetAt(0, topLanguage.GetAddressOf());</span>
<span class="line-removed">1794     }</span>
<span class="line-removed">1795 </span>
<span class="line-removed">1796     if (FAILED(hr))</span>
<span class="line-removed">1797     {</span>
<span class="line-removed">1798         // Unexpected, use en-US by default</span>
<span class="line-removed">1799         if (gCorrectedPOSIXLocale == NULL) {</span>
<span class="line-removed">1800             gCorrectedPOSIXLocale = &quot;en_US&quot;;</span>
<span class="line-removed">1801         }</span>
1802 
<span class="line-modified">1803         return gCorrectedPOSIXLocale;</span>
<span class="line-modified">1804     }</span>
<span class="line-removed">1805 </span>
<span class="line-removed">1806     // ResolveLocaleName will get a likely subtags form consistent with Windows behavior.</span>
<span class="line-removed">1807     int length = ResolveLocaleName(topLanguage.GetRawBuffer(NULL), windowsLocale, UPRV_LENGTHOF(windowsLocale));</span>
<span class="line-removed">1808 #endif</span>
<span class="line-removed">1809     // Now we should have a Windows locale name that needs converted to the POSIX style,</span>
<span class="line-removed">1810     if (length &gt; 0)</span>
1811     {
1812         // First we need to go from UTF-16 to char (and also convert from _ to - while we&#39;re at it.)
<span class="line-modified">1813         char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH];</span>
1814 
1815         int32_t i;
1816         for (i = 0; i &lt; UPRV_LENGTHOF(modifiedWindowsLocale); i++)
1817         {
1818             if (windowsLocale[i] == &#39;_&#39;)
1819             {
1820                 modifiedWindowsLocale[i] = &#39;-&#39;;
1821             }
1822             else
1823             {
1824                 modifiedWindowsLocale[i] = static_cast&lt;char&gt;(windowsLocale[i]);
1825             }
1826 
1827             if (modifiedWindowsLocale[i] == &#39;\0&#39;)
1828             {
1829                 break;
1830             }
1831         }
1832 
1833         if (i &gt;= UPRV_LENGTHOF(modifiedWindowsLocale))
</pre>
<hr />
<pre>
1841         correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(POSIX_LOCALE_CAPACITY + 1));
1842         /* TODO: Should we just exit on memory allocation failure? */
1843         if (correctedPOSIXLocale)
1844         {
1845             int32_t posixLen = uloc_canonicalize(modifiedWindowsLocale, correctedPOSIXLocale, POSIX_LOCALE_CAPACITY, &amp;status);
1846             if (U_SUCCESS(status))
1847             {
1848                 *(correctedPOSIXLocale + posixLen) = 0;
1849                 gCorrectedPOSIXLocale = correctedPOSIXLocale;
1850                 gCorrectedPOSIXLocaleHeapAllocated = true;
1851                 ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
1852             }
1853             else
1854             {
1855                 uprv_free(correctedPOSIXLocale);
1856             }
1857         }
1858     }
1859 
1860     // If unable to find a locale we can agree upon, use en-US by default
<span class="line-modified">1861     if (gCorrectedPOSIXLocale == NULL) {</span>
1862         gCorrectedPOSIXLocale = &quot;en_US&quot;;
1863     }
1864     return gCorrectedPOSIXLocale;
1865 
1866 #elif U_PLATFORM == U_PF_OS400
1867     /* locales are process scoped and are by definition thread safe */
1868     static char correctedLocale[64];
1869     const  char *localeID = getenv(&quot;LC_ALL&quot;);
1870            char *p;
1871 
1872     if (localeID == NULL)
1873         localeID = getenv(&quot;LANG&quot;);
1874     if (localeID == NULL)
1875         localeID = setlocale(LC_ALL, NULL);
1876     /* Make sure we have something... */
1877     if (localeID == NULL)
1878         return &quot;en_US_POSIX&quot;;
1879 
1880     /* Extract the locale name from the path. */
1881     if((p = uprv_strrchr(localeID, &#39;/&#39;)) != NULL)
</pre>
</td>
<td>
<hr />
<pre>
  85 #endif
  86 
  87 
  88 /* include system headers */
  89 #if U_PLATFORM_USES_ONLY_WIN32_API
  90     /*
  91      * TODO: U_PLATFORM_USES_ONLY_WIN32_API includes MinGW.
  92      * Should Cygwin be included as well (U_PLATFORM_HAS_WIN32_API)
  93      * to use native APIs as much as possible?
  94      */
  95 #ifndef WIN32_LEAN_AND_MEAN
  96 #   define WIN32_LEAN_AND_MEAN
  97 #endif
  98 #   define VC_EXTRALEAN
  99 #   define NOUSER
 100 #   define NOSERVICE
 101 #   define NOIME
 102 #   define NOMCX
 103 #   include &lt;windows.h&gt;
 104 #   include &quot;unicode/uloc.h&quot;

 105 #   include &quot;wintz.h&quot;











 106 #elif U_PLATFORM == U_PF_OS400
 107 #   include &lt;float.h&gt;
 108 #   include &lt;qusec.h&gt;       /* error code structure */
 109 #   include &lt;qusrjobi.h&gt;
 110 #   include &lt;qliept.h&gt;      /* EPT_CALL macro  - this include must be after all other &quot;QSYSINCs&quot; */
 111 #   include &lt;mih/testptr.h&gt; /* For uprv_maximumPtr */
 112 #elif U_PLATFORM == U_PF_OS390
 113 #   include &quot;unicode/ucnv.h&quot;   /* Needed for UCNV_SWAP_LFNL_OPTION_STRING */
 114 #elif U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS
 115 #   include &lt;limits.h&gt;
 116 #   include &lt;unistd.h&gt;
 117 #   if U_PLATFORM == U_PF_SOLARIS
 118 #       ifndef _XPG4_2
 119 #           define _XPG4_2
 120 #       endif
 121 #   endif
 122 #elif U_PLATFORM == U_PF_QNX
 123 #   include &lt;sys/neutrino.h&gt;
 124 #endif
 125 
</pre>
<hr />
<pre>
 224 u_signBit(double d) {
 225     uint8_t hiByte;
 226 #if U_IS_BIG_ENDIAN
 227     hiByte = *(uint8_t *)&amp;d;
 228 #else
 229     hiByte = *(((uint8_t *)&amp;d) + sizeof(double) - 1);
 230 #endif
 231     return (hiByte &amp; 0x80) != 0;
 232 }
 233 #endif
 234 
 235 
 236 
 237 #if defined (U_DEBUG_FAKETIME)
 238 /* Override the clock to test things without having to move the system clock.
 239  * Assumes POSIX gettimeofday() will function
 240  */
 241 UDate fakeClock_t0 = 0; /** Time to start the clock from **/
 242 UDate fakeClock_dt = 0; /** Offset (fake time - real time) **/
 243 UBool fakeClock_set = FALSE; /** True if fake clock has spun up **/

 244 
 245 static UDate getUTCtime_real() {
 246     struct timeval posixTime;
 247     gettimeofday(&amp;posixTime, NULL);
 248     return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));
 249 }
 250 
 251 static UDate getUTCtime_fake() {
<span class="line-added"> 252     static UMutex fakeClockMutex = U_MUTEX_INTIALIZER;</span>
 253     umtx_lock(&amp;fakeClockMutex);
 254     if(!fakeClock_set) {
 255         UDate real = getUTCtime_real();
 256         const char *fake_start = getenv(&quot;U_FAKETIME_START&quot;);
 257         if((fake_start!=NULL) &amp;&amp; (fake_start[0]!=0)) {
 258             sscanf(fake_start,&quot;%lf&quot;,&amp;fakeClock_t0);
 259             fakeClock_dt = fakeClock_t0 - real;
 260             fprintf(stderr,&quot;U_DEBUG_FAKETIME was set at compile time, so the ICU clock will start at a preset value\n&quot;
 261                     &quot;env variable U_FAKETIME_START=%.0f (%s) for an offset of %.0f ms from the current time %.0f\n&quot;,
 262                     fakeClock_t0, fake_start, fakeClock_dt, real);
 263         } else {
 264           fakeClock_dt = 0;
 265             fprintf(stderr,&quot;U_DEBUG_FAKETIME was set at compile time, but U_FAKETIME_START was not set.\n&quot;
 266                     &quot;Set U_FAKETIME_START to the number of milliseconds since 1/1/1970 to set the ICU clock.\n&quot;);
 267         }
 268         fakeClock_set = TRUE;
 269     }
 270     umtx_unlock(&amp;fakeClockMutex);
 271 
 272     return getUTCtime_real() + fakeClock_dt;
</pre>
<hr />
<pre>
 969     if (U_FAILURE(status)) {
 970         goto cleanupAndReturn;
 971     }
 972 
 973     dirp = opendir(path);
 974     if (dirp == NULL) {
 975         goto cleanupAndReturn;
 976     }
 977 
 978     if (gSearchTZFileResult == NULL) {
 979         gSearchTZFileResult = new CharString;
 980         if (gSearchTZFileResult == NULL) {
 981             goto cleanupAndReturn;
 982         }
 983         ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
 984     }
 985 
 986     /* Check each entry in the directory. */
 987     while((dirEntry = readdir(dirp)) != NULL) {
 988         const char* dirName = dirEntry-&gt;d_name;
<span class="line-modified"> 989         if (uprv_strcmp(dirName, SKIP1) != 0 &amp;&amp; uprv_strcmp(dirName, SKIP2) != 0</span>
<span class="line-added"> 990             &amp;&amp; uprv_strcmp(TZFILE_SKIP, dirName) != 0 &amp;&amp; uprv_strcmp(TZFILE_SKIP2, dirName) != 0) {</span>
 991             /* Create a newpath with the new entry to test each entry in the directory. */
 992             CharString newpath(curpath, status);
 993             newpath.append(dirName, -1, status);
 994             if (U_FAILURE(status)) {
 995                 break;
 996             }
 997 
 998             DIR* subDirp = NULL;
 999             if ((subDirp = opendir(newpath.data())) != NULL) {
1000                 /* If this new path is a directory, make a recursive call with the newpath. */
1001                 closedir(subDirp);
1002                 newpath.append(&#39;/&#39;, status);
1003                 if (U_FAILURE(status)) {
1004                     break;
1005                 }
1006                 result = searchForTZFile(newpath.data(), tzInfo);
1007                 /*
1008                  Have to get out here. Otherwise, we&#39;d keep looking
1009                  and return the first match in the top-level directory
1010                  if there&#39;s a match in the top-level. If not, this function
1011                  would return NULL and set gTimeZoneBufferPtr to NULL in initDefault().
1012                  It worked without this in most cases because we have a fallback of calling
1013                  localtime_r to figure out the default timezone.
1014                 */
1015                 if (result != NULL)
1016                     break;
<span class="line-modified">1017             } else {</span>
1018                 if(compareBinaryFiles(TZDEFAULT, newpath.data(), tzInfo)) {
1019                     int32_t amountToSkip = sizeof(TZZONEINFO) - 1;
1020                     if (amountToSkip &gt; newpath.length()) {
1021                         amountToSkip = newpath.length();
1022                     }
1023                     const char* zoneid = newpath.data() + amountToSkip;
1024                     skipZoneIDPrefix(&amp;zoneid);
1025                     gSearchTZFileResult-&gt;clear();
1026                     gSearchTZFileResult-&gt;append(zoneid, -1, status);
1027                     if (U_FAILURE(status)) {
1028                         break;
1029                     }
1030                     result = gSearchTZFileResult-&gt;data();
1031                     /* Get out after the first one found. */
1032                     break;
1033                 }
1034             }
1035         }
1036     }
1037 
1038   cleanupAndReturn:
1039     if (dirp) {
1040         closedir(dirp);
1041     }
1042     return result;
1043 }
1044 #endif
1045 
1046 U_CAPI void U_EXPORT2
1047 uprv_tzname_clear_cache()
1048 {
1049 #if defined(CHECK_LOCALTIME_LINK) &amp;&amp; !defined(DEBUG_SKIP_LOCALTIME_LINK)
1050     gTimeZoneBufferPtr = NULL;
1051 #endif
1052 }
1053 




































1054 U_CAPI const char* U_EXPORT2
1055 uprv_tzname(int n)
1056 {
1057     (void)n; // Avoid unreferenced parameter warning.
1058     const char *tzid = NULL;
1059 #if U_PLATFORM_USES_ONLY_WIN32_API



1060     tzid = uprv_detectWindowsTimeZone();

1061 
1062     if (tzid != NULL) {
1063         return tzid;
1064     }
1065 
1066 #ifndef U_TZNAME
1067     // The return value is free&#39;d in timezone.cpp on Windows because
1068     // the other code path returns a pointer to a heap location.
1069     // If we don&#39;t have a name already, then tzname wouldn&#39;t be any
1070     // better, so just fall back.
<span class="line-modified">1071     return uprv_strdup(&quot;&quot;);</span>
1072 #endif // !U_TZNAME
1073 
1074 #else
1075 
1076 /*#if U_PLATFORM_IS_DARWIN_BASED
1077     int ret;
1078 
1079     tzid = getenv(&quot;TZFILE&quot;);
1080     if (tzid != NULL) {
1081         return tzid;
1082     }
1083 #endif*/
1084 
1085 /* This code can be temporarily disabled to test tzname resolution later on. */
1086 #ifndef DEBUG_TZNAME
1087     tzid = getenv(&quot;TZ&quot;);
1088     if (tzid != NULL &amp;&amp; isValidOlsonID(tzid)
1089 #if U_PLATFORM == U_PF_SOLARIS
1090     /* When TZ equals localtime on Solaris, check the /etc/localtime file. */
1091         &amp;&amp; uprv_strcmp(tzid, TZ_ENV_CHECK) != 0
</pre>
<hr />
<pre>
1290     return TRUE;
1291   }
1292 
1293 #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
1294   if(*path == U_FILE_ALT_SEP_CHAR) {
1295     return TRUE;
1296   }
1297 #endif
1298 
1299 #if U_PLATFORM_USES_ONLY_WIN32_API
1300   if( (((path[0] &gt;= &#39;A&#39;) &amp;&amp; (path[0] &lt;= &#39;Z&#39;)) ||
1301        ((path[0] &gt;= &#39;a&#39;) &amp;&amp; (path[0] &lt;= &#39;z&#39;))) &amp;&amp;
1302       path[1] == &#39;:&#39; ) {
1303     return TRUE;
1304   }
1305 #endif
1306 
1307   return FALSE;
1308 }
1309 
<span class="line-modified">1310 /* Backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR</span>
<span class="line-modified">1311    (needed for some Darwin ICU build environments) */</span>
<span class="line-modified">1312 #if U_PLATFORM_IS_DARWIN_BASED &amp;&amp; TARGET_OS_SIMULATOR</span>
1313 # if !defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1314 #  define ICU_DATA_DIR_PREFIX_ENV_VAR &quot;IPHONE_SIMULATOR_ROOT&quot;
1315 # endif
1316 #endif
1317 
<span class="line-added">1318 #if U_PLATFORM_HAS_WINUWP_API != 0</span>
<span class="line-added">1319 // Helper function to get the ICU Data Directory under the Windows directory location.</span>
<span class="line-added">1320 static BOOL U_CALLCONV getIcuDataDirectoryUnderWindowsDirectory(char* directoryBuffer, UINT bufferLength)</span>
<span class="line-added">1321 {</span>
<span class="line-added">1322 #if defined(ICU_DATA_DIR_WINDOWS)</span>
<span class="line-added">1323     wchar_t windowsPath[MAX_PATH];</span>
<span class="line-added">1324     char windowsPathUtf8[MAX_PATH];</span>
<span class="line-added">1325 </span>
<span class="line-added">1326     UINT length = GetSystemWindowsDirectoryW(windowsPath, UPRV_LENGTHOF(windowsPath));</span>
<span class="line-added">1327     if ((length &gt; 0) &amp;&amp; (length &lt; (UPRV_LENGTHOF(windowsPath) - 1))) {</span>
<span class="line-added">1328         // Convert UTF-16 to a UTF-8 string.</span>
<span class="line-added">1329         UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added">1330         int32_t windowsPathUtf8Len = 0;</span>
<span class="line-added">1331         u_strToUTF8(windowsPathUtf8, static_cast&lt;int32_t&gt;(UPRV_LENGTHOF(windowsPathUtf8)),</span>
<span class="line-added">1332             &amp;windowsPathUtf8Len, reinterpret_cast&lt;const UChar*&gt;(windowsPath), -1, &amp;status);</span>
<span class="line-added">1333 </span>
<span class="line-added">1334         if (U_SUCCESS(status) &amp;&amp; (status != U_STRING_NOT_TERMINATED_WARNING) &amp;&amp;</span>
<span class="line-added">1335             (windowsPathUtf8Len &lt; (UPRV_LENGTHOF(windowsPathUtf8) - 1))) {</span>
<span class="line-added">1336             // Ensure it always has a separator, so we can append the ICU data path.</span>
<span class="line-added">1337             if (windowsPathUtf8[windowsPathUtf8Len - 1] != U_FILE_SEP_CHAR) {</span>
<span class="line-added">1338                 windowsPathUtf8[windowsPathUtf8Len++] = U_FILE_SEP_CHAR;</span>
<span class="line-added">1339                 windowsPathUtf8[windowsPathUtf8Len] = &#39;\0&#39;;</span>
<span class="line-added">1340             }</span>
<span class="line-added">1341             // Check if the concatenated string will fit.</span>
<span class="line-added">1342             if ((windowsPathUtf8Len + UPRV_LENGTHOF(ICU_DATA_DIR_WINDOWS)) &lt; bufferLength) {</span>
<span class="line-added">1343                 uprv_strcpy(directoryBuffer, windowsPathUtf8);</span>
<span class="line-added">1344                 uprv_strcat(directoryBuffer, ICU_DATA_DIR_WINDOWS);</span>
<span class="line-added">1345                 return TRUE;</span>
<span class="line-added">1346             }</span>
<span class="line-added">1347         }</span>
<span class="line-added">1348     }</span>
<span class="line-added">1349 #endif</span>
<span class="line-added">1350 </span>
<span class="line-added">1351     return FALSE;</span>
<span class="line-added">1352 }</span>
<span class="line-added">1353 #endif</span>
<span class="line-added">1354 </span>
1355 static void U_CALLCONV dataDirectoryInitFn() {
1356     /* If we already have the directory, then return immediately. Will happen if user called
1357      * u_setDataDirectory().
1358      */
1359     if (gDataDirectory) {
1360         return;
1361     }
1362 
1363     const char *path = NULL;
1364 #if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1365     char datadir_path_buffer[PATH_MAX];
1366 #endif
1367 
1368     /*
1369     When ICU_NO_USER_DATA_OVERRIDE is defined, users aren&#39;t allowed to
1370     override ICU&#39;s data with the ICU_DATA environment variable. This prevents
1371     problems where multiple custom copies of ICU&#39;s specific version of data
1372     are installed on a system. Either the application must define the data
1373     directory with u_setDataDirectory, define ICU_DATA_DIR when compiling
1374     ICU, set the data with udata_setCommonData or trust that all of the
</pre>
<hr />
<pre>
1394      */
1395 #if defined(ICU_DATA_DIR) || defined(U_ICU_DATA_DEFAULT_DIR)
1396     if(path==NULL || *path==0) {
1397 # if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1398         const char *prefix = getenv(ICU_DATA_DIR_PREFIX_ENV_VAR);
1399 # endif
1400 # ifdef ICU_DATA_DIR
1401         path=ICU_DATA_DIR;
1402 # else
1403         path=U_ICU_DATA_DEFAULT_DIR;
1404 # endif
1405 # if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1406         if (prefix != NULL) {
1407             snprintf(datadir_path_buffer, PATH_MAX, &quot;%s%s&quot;, prefix, path);
1408             path=datadir_path_buffer;
1409         }
1410 # endif
1411     }
1412 #endif
1413 
<span class="line-modified">1414 #if U_PLATFORM_HAS_WINUWP_API != 0  &amp;&amp; defined(ICU_DATA_DIR_WINDOWS)</span>


1415     char datadir_path_buffer[MAX_PATH];
<span class="line-modified">1416     if (getIcuDataDirectoryUnderWindowsDirectory(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer))) {</span>
<span class="line-modified">1417         path = datadir_path_buffer;</span>












1418     }
1419 #endif
1420 
1421     if(path==NULL) {
1422         /* It looks really bad, set it to something. */




1423         path = &quot;&quot;;

1424     }
1425 
1426     u_setDataDirectory(path);
1427     return;
1428 }
1429 
1430 U_CAPI const char * U_EXPORT2
1431 u_getDataDirectory(void) {
1432     umtx_initOnce(gDataDirInitOnce, &amp;dataDirectoryInitFn);
1433     return gDataDirectory;
1434 }
1435 
1436 static void setTimeZoneFilesDir(const char *path, UErrorCode &amp;status) {
1437     if (U_FAILURE(status)) {
1438         return;
1439     }
1440     gTimeZoneFilesDirectory-&gt;clear();
1441     gTimeZoneFilesDirectory-&gt;append(path, status);
1442 #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
1443     char *p = gTimeZoneFilesDirectory-&gt;data();
1444     while ((p = uprv_strchr(p, U_FILE_ALT_SEP_CHAR)) != NULL) {
1445         *p = U_FILE_SEP_CHAR;
1446     }
1447 #endif
1448 }
1449 
1450 #define TO_STRING(x) TO_STRING_2(x)
1451 #define TO_STRING_2(x) #x
1452 
1453 static void U_CALLCONV TimeZoneDataDirInitFn(UErrorCode &amp;status) {
1454     U_ASSERT(gTimeZoneFilesDirectory == NULL);
1455     ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
1456     gTimeZoneFilesDirectory = new CharString();
1457     if (gTimeZoneFilesDirectory == NULL) {
1458         status = U_MEMORY_ALLOCATION_ERROR;
1459         return;
1460     }
<span class="line-modified">1461 </span>



1462     const char *dir = &quot;&quot;;
<span class="line-added">1463 </span>
<span class="line-added">1464 #if U_PLATFORM_HAS_WINUWP_API != 0</span>
<span class="line-added">1465     // The UWP version does not support the environment variable setting, but can possibly pick them up from the Windows directory.</span>
<span class="line-added">1466     char datadir_path_buffer[MAX_PATH];</span>
<span class="line-added">1467     if (getIcuDataDirectoryUnderWindowsDirectory(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer))) {</span>
<span class="line-added">1468         dir = datadir_path_buffer;</span>
<span class="line-added">1469     }</span>
<span class="line-added">1470 #else</span>
<span class="line-added">1471     dir = getenv(&quot;ICU_TIMEZONE_FILES_DIR&quot;);</span>
1472 #endif // U_PLATFORM_HAS_WINUWP_API
<span class="line-added">1473 </span>
1474 #if defined(U_TIMEZONE_FILES_DIR)
1475     if (dir == NULL) {
<span class="line-added">1476         // Build time configuration setting.</span>
1477         dir = TO_STRING(U_TIMEZONE_FILES_DIR);
1478     }
1479 #endif
<span class="line-added">1480 </span>
1481     if (dir == NULL) {
1482         dir = &quot;&quot;;
1483     }
<span class="line-added">1484 </span>
1485     setTimeZoneFilesDir(dir, status);
1486 }
1487 
1488 
1489 U_CAPI const char * U_EXPORT2
1490 u_getTimeZoneFilesDirectory(UErrorCode *status) {
1491     umtx_initOnce(gTimeZoneFilesInitOnce, &amp;TimeZoneDataDirInitFn, *status);
1492     return U_SUCCESS(*status) ? gTimeZoneFilesDirectory-&gt;data() : &quot;&quot;;
1493 }
1494 
1495 U_CAPI void U_EXPORT2
1496 u_setTimeZoneFilesDirectory(const char *path, UErrorCode *status) {
1497     umtx_initOnce(gTimeZoneFilesInitOnce, &amp;TimeZoneDataDirInitFn, *status);
1498     setTimeZoneFilesDir(path, *status);
1499 
1500     // Note: this function does some extra churn, first setting based on the
1501     //       environment, then immediately replacing with the value passed in.
1502     //       The logic is simpler that way, and performance shouldn&#39;t be an issue.
1503 }
1504 
</pre>
<hr />
<pre>
1601      LC_ALL  ----&gt;     default_loc          codepage
1602 --------------------------------------------------------
1603      ab.CD             ab                   CD
1604      ab@CD             ab__CD               -
1605      ab@CD.EF          ab__CD               EF
1606 
1607      ab_CD.EF@GH       ab_CD_GH             EF
1608 
1609 Some &#39;improper&#39; ways to do the same as above:
1610   !  ab_CD@GH.EF       ab_CD_GH             EF
1611   !  ab_CD.EF@GH.IJ    ab_CD_GH             EF
1612   !  ab_CD@ZZ.EF@GH.IJ ab_CD_GH             EF
1613 
1614      _CD@GH            _CD_GH               -
1615      _CD.EF@GH         _CD_GH               EF
1616 
1617 The variant cannot have dots in it.
1618 The &#39;rightmost&#39; variant (@xxx) wins.
1619 The leftmost codepage (.xxx) wins.
1620 */

1621     const char* posixID = uprv_getPOSIXIDForDefaultLocale();



1622 
1623     /* Format: (no spaces)
1624     ll [ _CC ] [ . MM ] [ @ VV]
1625 
1626       l = lang, C = ctry, M = charmap, V = variant
1627     */
1628 
<span class="line-modified">1629     if (gCorrectedPOSIXLocale != nullptr) {</span>
1630         return gCorrectedPOSIXLocale;
1631     }
1632 
<span class="line-modified">1633     // Copy the ID into owned memory.</span>
<span class="line-modified">1634     // Over-allocate in case we replace &quot;@&quot; with &quot;__&quot;.</span>
<span class="line-modified">1635     char *correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(uprv_strlen(posixID) + 1 + 1));</span>
<span class="line-modified">1636     if (correctedPOSIXLocale == nullptr) {</span>
<span class="line-modified">1637         return nullptr;</span>
<span class="line-modified">1638     }</span>
<span class="line-modified">1639     uprv_strcpy(correctedPOSIXLocale, posixID);</span>


1640 
<span class="line-modified">1641     char *limit;</span>
<span class="line-modified">1642     if ((limit = uprv_strchr(correctedPOSIXLocale, &#39;.&#39;)) != nullptr) {</span>
<span class="line-modified">1643         *limit = 0;</span>
<span class="line-added">1644         if ((limit = uprv_strchr(correctedPOSIXLocale, &#39;@&#39;)) != nullptr) {</span>
<span class="line-added">1645             *limit = 0;</span>
1646         }
1647     }
1648 
1649     /* Note that we scan the *uncorrected* ID. */
<span class="line-modified">1650     const char *p;</span>
<span class="line-modified">1651     if ((p = uprv_strrchr(posixID, &#39;@&#39;)) != nullptr) {</span>








1652         p++;
1653 
1654         /* Take care of any special cases here.. */
1655         if (!uprv_strcmp(p, &quot;nynorsk&quot;)) {
1656             p = &quot;NY&quot;;
1657             /* Don&#39;t worry about no__NY. In practice, it won&#39;t appear. */
1658         }
1659 
<span class="line-modified">1660         if (uprv_strchr(correctedPOSIXLocale,&#39;_&#39;) == nullptr) {</span>
<span class="line-modified">1661             uprv_strcat(correctedPOSIXLocale, &quot;__&quot;); /* aa@b -&gt; aa__b (note this can make the new locale 1 char longer) */</span>
1662         }
1663         else {
1664             uprv_strcat(correctedPOSIXLocale, &quot;_&quot;); /* aa_CC@b -&gt; aa_CC_b */
1665         }
1666 
<span class="line-modified">1667         const char *q;</span>
<span class="line-added">1668         if ((q = uprv_strchr(p, &#39;.&#39;)) != nullptr) {</span>
1669             /* How big will the resulting string be? */
<span class="line-modified">1670             int32_t len = (int32_t)(uprv_strlen(correctedPOSIXLocale) + (q-p));</span>
1671             uprv_strncat(correctedPOSIXLocale, p, q-p);
1672             correctedPOSIXLocale[len] = 0;
1673         }
1674         else {
1675             /* Anything following the @ sign */
1676             uprv_strcat(correctedPOSIXLocale, p);
1677         }
1678 
1679         /* Should there be a map from &#39;no@nynorsk&#39; -&gt; no_NO_NY here?
1680          * How about &#39;russian&#39; -&gt; &#39;ru&#39;?
1681          * Many of the other locales using ISO codes will be handled by the
1682          * canonicalization functions in uloc_getDefault.
1683          */
1684     }
1685 
<span class="line-modified">1686     if (gCorrectedPOSIXLocale == nullptr) {</span>














1687         gCorrectedPOSIXLocale = correctedPOSIXLocale;
1688         gCorrectedPOSIXLocaleHeapAllocated = true;
1689         ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
<span class="line-modified">1690         correctedPOSIXLocale = nullptr;</span>
1691     }
<span class="line-added">1692     posixID = gCorrectedPOSIXLocale;</span>
1693 
<span class="line-modified">1694     if (correctedPOSIXLocale != nullptr) {  /* Was already set - clean up. */</span>
1695         uprv_free(correctedPOSIXLocale);
1696     }
1697 
1698     return posixID;
1699 
1700 #elif U_PLATFORM_USES_ONLY_WIN32_API
1701 #define POSIX_LOCALE_CAPACITY 64
1702     UErrorCode status = U_ZERO_ERROR;
<span class="line-modified">1703     char *correctedPOSIXLocale = nullptr;</span>
1704 
1705     // If we have already figured this out just use the cached value
<span class="line-modified">1706     if (gCorrectedPOSIXLocale != nullptr) {</span>
1707         return gCorrectedPOSIXLocale;
1708     }
1709 
1710     // No cached value, need to determine the current value
<span class="line-modified">1711     static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH] = {};</span>
<span class="line-modified">1712     int length = GetLocaleInfoEx(LOCALE_NAME_USER_DEFAULT, LOCALE_SNAME, windowsLocale, LOCALE_NAME_MAX_LENGTH);</span>










































1713 
<span class="line-modified">1714     // Now we should have a Windows locale name that needs converted to the POSIX style.</span>
<span class="line-modified">1715     if (length &gt; 0) // If length is 0, then the GetLocaleInfoEx failed.</span>






1716     {
1717         // First we need to go from UTF-16 to char (and also convert from _ to - while we&#39;re at it.)
<span class="line-modified">1718         char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH] = {};</span>
1719 
1720         int32_t i;
1721         for (i = 0; i &lt; UPRV_LENGTHOF(modifiedWindowsLocale); i++)
1722         {
1723             if (windowsLocale[i] == &#39;_&#39;)
1724             {
1725                 modifiedWindowsLocale[i] = &#39;-&#39;;
1726             }
1727             else
1728             {
1729                 modifiedWindowsLocale[i] = static_cast&lt;char&gt;(windowsLocale[i]);
1730             }
1731 
1732             if (modifiedWindowsLocale[i] == &#39;\0&#39;)
1733             {
1734                 break;
1735             }
1736         }
1737 
1738         if (i &gt;= UPRV_LENGTHOF(modifiedWindowsLocale))
</pre>
<hr />
<pre>
1746         correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(POSIX_LOCALE_CAPACITY + 1));
1747         /* TODO: Should we just exit on memory allocation failure? */
1748         if (correctedPOSIXLocale)
1749         {
1750             int32_t posixLen = uloc_canonicalize(modifiedWindowsLocale, correctedPOSIXLocale, POSIX_LOCALE_CAPACITY, &amp;status);
1751             if (U_SUCCESS(status))
1752             {
1753                 *(correctedPOSIXLocale + posixLen) = 0;
1754                 gCorrectedPOSIXLocale = correctedPOSIXLocale;
1755                 gCorrectedPOSIXLocaleHeapAllocated = true;
1756                 ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
1757             }
1758             else
1759             {
1760                 uprv_free(correctedPOSIXLocale);
1761             }
1762         }
1763     }
1764 
1765     // If unable to find a locale we can agree upon, use en-US by default
<span class="line-modified">1766     if (gCorrectedPOSIXLocale == nullptr) {</span>
1767         gCorrectedPOSIXLocale = &quot;en_US&quot;;
1768     }
1769     return gCorrectedPOSIXLocale;
1770 
1771 #elif U_PLATFORM == U_PF_OS400
1772     /* locales are process scoped and are by definition thread safe */
1773     static char correctedLocale[64];
1774     const  char *localeID = getenv(&quot;LC_ALL&quot;);
1775            char *p;
1776 
1777     if (localeID == NULL)
1778         localeID = getenv(&quot;LANG&quot;);
1779     if (localeID == NULL)
1780         localeID = setlocale(LC_ALL, NULL);
1781     /* Make sure we have something... */
1782     if (localeID == NULL)
1783         return &quot;en_US_POSIX&quot;;
1784 
1785     /* Extract the locale name from the path. */
1786     if((p = uprv_strrchr(localeID, &#39;/&#39;)) != NULL)
</pre>
</td>
</tr>
</table>
<center><a href="propname_data.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="putilimp.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>