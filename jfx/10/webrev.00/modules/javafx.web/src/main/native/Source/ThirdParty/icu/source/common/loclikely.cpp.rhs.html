<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/loclikely.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 *
   6 *   Copyright (C) 1997-2016, International Business Machines
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 *******************************************************************************
  10 *   file name:  loclikely.cpp
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 2010feb25
  16 *   created by: Markus W. Scherer
  17 *
  18 *   Code for likely and minimized locale subtags, separated out from other .cpp files
  19 *   that then do not depend on resource bundle code and likely-subtags data.
  20 */
  21 
<a name="1" id="anc1"></a><span class="line-added">  22 #include &quot;unicode/bytestream.h&quot;</span>
  23 #include &quot;unicode/utypes.h&quot;
  24 #include &quot;unicode/locid.h&quot;
  25 #include &quot;unicode/putil.h&quot;
  26 #include &quot;unicode/uchar.h&quot;
  27 #include &quot;unicode/uloc.h&quot;
  28 #include &quot;unicode/ures.h&quot;
  29 #include &quot;unicode/uscript.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  30 #include &quot;bytesinkutil.h&quot;</span>
<span class="line-added">  31 #include &quot;charstr.h&quot;</span>
  32 #include &quot;cmemory.h&quot;
  33 #include &quot;cstring.h&quot;
  34 #include &quot;ulocimp.h&quot;
  35 #include &quot;ustr_imp.h&quot;
  36 
<a name="3" id="anc3"></a><span class="line-added">  37 /**</span>
<span class="line-added">  38  * These are the canonical strings for unknown languages, scripts and regions.</span>
<span class="line-added">  39  **/</span>
<span class="line-added">  40 static const char* const unknownLanguage = &quot;und&quot;;</span>
<span class="line-added">  41 static const char* const unknownScript = &quot;Zzzz&quot;;</span>
<span class="line-added">  42 static const char* const unknownRegion = &quot;ZZ&quot;;</span>
<span class="line-added">  43 </span>
  44 /**
  45  * This function looks for the localeID in the likelySubtags resource.
  46  *
  47  * @param localeID The tag to find.
  48  * @param buffer A buffer to hold the matching entry
  49  * @param bufferLength The length of the output buffer
  50  * @return A pointer to &quot;buffer&quot; if found, or a null pointer if not.
  51  */
  52 static const char*  U_CALLCONV
  53 findLikelySubtags(const char* localeID,
  54                   char* buffer,
  55                   int32_t bufferLength,
  56                   UErrorCode* err) {
  57     const char* result = NULL;
  58 
  59     if (!U_FAILURE(*err)) {
  60         int32_t resLen = 0;
  61         const UChar* s = NULL;
  62         UErrorCode tmpErr = U_ZERO_ERROR;
<a name="4" id="anc4"></a><span class="line-modified">  63         icu::LocalUResourceBundlePointer subtags(ures_openDirect(NULL, &quot;likelySubtags&quot;, &amp;tmpErr));</span>
  64         if (U_SUCCESS(tmpErr)) {
<a name="5" id="anc5"></a><span class="line-modified">  65             icu::CharString und;</span>
<span class="line-added">  66             if (localeID != NULL) {</span>
<span class="line-added">  67                 if (*localeID == &#39;\0&#39;) {</span>
<span class="line-added">  68                     localeID = unknownLanguage;</span>
<span class="line-added">  69                 } else if (*localeID == &#39;_&#39;) {</span>
<span class="line-added">  70                     und.append(unknownLanguage, *err);</span>
<span class="line-added">  71                     und.append(localeID, *err);</span>
<span class="line-added">  72                     if (U_FAILURE(*err)) {</span>
<span class="line-added">  73                         return NULL;</span>
<span class="line-added">  74                     }</span>
<span class="line-added">  75                     localeID = und.data();</span>
<span class="line-added">  76                 }</span>
<span class="line-added">  77             }</span>
<span class="line-added">  78             s = ures_getStringByKey(subtags.getAlias(), localeID, &amp;resLen, &amp;tmpErr);</span>
  79 
  80             if (U_FAILURE(tmpErr)) {
  81                 /*
  82                  * If a resource is missing, it&#39;s not really an error, it&#39;s
  83                  * just that we don&#39;t have any data for that particular locale ID.
  84                  */
  85                 if (tmpErr != U_MISSING_RESOURCE_ERROR) {
  86                     *err = tmpErr;
  87                 }
  88             }
  89             else if (resLen &gt;= bufferLength) {
  90                 /* The buffer should never overflow. */
  91                 *err = U_INTERNAL_PROGRAM_ERROR;
  92             }
  93             else {
  94                 u_UCharsToChars(s, buffer, resLen + 1);
<a name="6" id="anc6"></a><span class="line-added">  95                 if (resLen &gt;= 3 &amp;&amp;</span>
<span class="line-added">  96                     uprv_strnicmp(buffer, unknownLanguage, 3) == 0 &amp;&amp;</span>
<span class="line-added">  97                     (resLen == 3 || buffer[3] == &#39;_&#39;)) {</span>
<span class="line-added">  98                     uprv_memmove(buffer, buffer + 3, resLen - 3 + 1);</span>
<span class="line-added">  99                 }</span>
 100                 result = buffer;
 101             }
<a name="7" id="anc7"></a>

 102         } else {
 103             *err = tmpErr;
 104         }
 105     }
 106 
 107     return result;
 108 }
 109 
 110 /**
 111  * Append a tag to a buffer, adding the separator if necessary.  The buffer
 112  * must be large enough to contain the resulting tag plus any separator
 113  * necessary. The tag must not be a zero-length string.
 114  *
 115  * @param tag The tag to add.
 116  * @param tagLength The length of the tag.
 117  * @param buffer The output buffer.
 118  * @param bufferLength The length of the output buffer.  This is an input/ouput parameter.
 119  **/
 120 static void U_CALLCONV
 121 appendTag(
 122     const char* tag,
 123     int32_t tagLength,
 124     char* buffer,
<a name="8" id="anc8"></a><span class="line-modified"> 125     int32_t* bufferLength,</span>
<span class="line-added"> 126     UBool withSeparator) {</span>
 127 
<a name="9" id="anc9"></a><span class="line-modified"> 128     if (withSeparator) {</span>
 129         buffer[*bufferLength] = &#39;_&#39;;
 130         ++(*bufferLength);
 131     }
 132 
 133     uprv_memmove(
 134         &amp;buffer[*bufferLength],
 135         tag,
 136         tagLength);
 137 
 138     *bufferLength += tagLength;
 139 }
 140 
<a name="10" id="anc10"></a>






 141 /**
 142  * Create a tag string from the supplied parameters.  The lang, script and region
 143  * parameters may be NULL pointers. If they are, their corresponding length parameters
 144  * must be less than or equal to 0.
 145  *
 146  * If any of the language, script or region parameters are empty, and the alternateTags
 147  * parameter is not NULL, it will be parsed for potential language, script and region tags
 148  * to be used when constructing the new tag.  If the alternateTags parameter is NULL, or
 149  * it contains no language tag, the default tag for the unknown language is used.
 150  *
 151  * If the length of the new string exceeds the capacity of the output buffer,
 152  * the function copies as many bytes to the output buffer as it can, and returns
 153  * the error U_BUFFER_OVERFLOW_ERROR.
 154  *
 155  * If an illegal argument is provided, the function returns the error
 156  * U_ILLEGAL_ARGUMENT_ERROR.
 157  *
 158  * Note that this function can return the warning U_STRING_NOT_TERMINATED_WARNING if
 159  * the tag string fits in the output buffer, but the null terminator doesn&#39;t.
 160  *
 161  * @param lang The language tag to use.
 162  * @param langLength The length of the language tag.
 163  * @param script The script tag to use.
 164  * @param scriptLength The length of the script tag.
 165  * @param region The region tag to use.
 166  * @param regionLength The length of the region tag.
 167  * @param trailing Any trailing data to append to the new tag.
 168  * @param trailingLength The length of the trailing data.
 169  * @param alternateTags A string containing any alternate tags.
<a name="11" id="anc11"></a><span class="line-modified"> 170  * @param sink The output sink receiving the tag string.</span>

 171  * @param err A pointer to a UErrorCode for error reporting.
<a name="12" id="anc12"></a>
 172  **/
<a name="13" id="anc13"></a><span class="line-modified"> 173 static void U_CALLCONV</span>
 174 createTagStringWithAlternates(
 175     const char* lang,
 176     int32_t langLength,
 177     const char* script,
 178     int32_t scriptLength,
 179     const char* region,
 180     int32_t regionLength,
 181     const char* trailing,
 182     int32_t trailingLength,
 183     const char* alternateTags,
<a name="14" id="anc14"></a><span class="line-modified"> 184     icu::ByteSink&amp; sink,</span>

 185     UErrorCode* err) {
 186 
 187     if (U_FAILURE(*err)) {
 188         goto error;
 189     }
<a name="15" id="anc15"></a><span class="line-modified"> 190     else if (langLength &gt;= ULOC_LANG_CAPACITY ||</span>


 191              scriptLength &gt;= ULOC_SCRIPT_CAPACITY ||
 192              regionLength &gt;= ULOC_COUNTRY_CAPACITY) {
 193         goto error;
 194     }
 195     else {
 196         /**
 197          * ULOC_FULLNAME_CAPACITY will provide enough capacity
 198          * that we can build a string that contains the language,
 199          * script and region code without worrying about overrunning
 200          * the user-supplied buffer.
 201          **/
 202         char tagBuffer[ULOC_FULLNAME_CAPACITY];
 203         int32_t tagLength = 0;
<a name="16" id="anc16"></a>
 204         UBool regionAppended = FALSE;
 205 
 206         if (langLength &gt; 0) {
 207             appendTag(
 208                 lang,
 209                 langLength,
 210                 tagBuffer,
<a name="17" id="anc17"></a><span class="line-modified"> 211                 &amp;tagLength,</span>
<span class="line-added"> 212                 /*withSeparator=*/FALSE);</span>
 213         }
 214         else if (alternateTags == NULL) {
 215             /*
<a name="18" id="anc18"></a><span class="line-modified"> 216              * Use the empty string for an unknown language, if</span>
 217              * we found no language.
 218              */
<a name="19" id="anc19"></a>




 219         }
 220         else {
 221             /*
 222              * Parse the alternateTags string for the language.
 223              */
 224             char alternateLang[ULOC_LANG_CAPACITY];
 225             int32_t alternateLangLength = sizeof(alternateLang);
 226 
 227             alternateLangLength =
 228                 uloc_getLanguage(
 229                     alternateTags,
 230                     alternateLang,
 231                     alternateLangLength,
 232                     err);
 233             if(U_FAILURE(*err) ||
 234                 alternateLangLength &gt;= ULOC_LANG_CAPACITY) {
 235                 goto error;
 236             }
 237             else if (alternateLangLength == 0) {
 238                 /*
<a name="20" id="anc20"></a><span class="line-modified"> 239                  * Use the empty string for an unknown language, if</span>
 240                  * we found no language.
 241                  */
<a name="21" id="anc21"></a>




 242             }
 243             else {
 244                 appendTag(
 245                     alternateLang,
 246                     alternateLangLength,
 247                     tagBuffer,
<a name="22" id="anc22"></a><span class="line-modified"> 248                     &amp;tagLength,</span>
<span class="line-added"> 249                     /*withSeparator=*/FALSE);</span>
 250             }
 251         }
 252 
 253         if (scriptLength &gt; 0) {
 254             appendTag(
 255                 script,
 256                 scriptLength,
 257                 tagBuffer,
<a name="23" id="anc23"></a><span class="line-modified"> 258                 &amp;tagLength,</span>
<span class="line-added"> 259                 /*withSeparator=*/TRUE);</span>
 260         }
 261         else if (alternateTags != NULL) {
 262             /*
 263              * Parse the alternateTags string for the script.
 264              */
 265             char alternateScript[ULOC_SCRIPT_CAPACITY];
 266 
 267             const int32_t alternateScriptLength =
 268                 uloc_getScript(
 269                     alternateTags,
 270                     alternateScript,
 271                     sizeof(alternateScript),
 272                     err);
 273 
 274             if (U_FAILURE(*err) ||
 275                 alternateScriptLength &gt;= ULOC_SCRIPT_CAPACITY) {
 276                 goto error;
 277             }
 278             else if (alternateScriptLength &gt; 0) {
 279                 appendTag(
 280                     alternateScript,
 281                     alternateScriptLength,
 282                     tagBuffer,
<a name="24" id="anc24"></a><span class="line-modified"> 283                     &amp;tagLength,</span>
<span class="line-added"> 284                     /*withSeparator=*/TRUE);</span>
 285             }
 286         }
 287 
 288         if (regionLength &gt; 0) {
 289             appendTag(
 290                 region,
 291                 regionLength,
 292                 tagBuffer,
<a name="25" id="anc25"></a><span class="line-modified"> 293                 &amp;tagLength,</span>
<span class="line-added"> 294                 /*withSeparator=*/TRUE);</span>
 295 
 296             regionAppended = TRUE;
 297         }
 298         else if (alternateTags != NULL) {
 299             /*
 300              * Parse the alternateTags string for the region.
 301              */
 302             char alternateRegion[ULOC_COUNTRY_CAPACITY];
 303 
 304             const int32_t alternateRegionLength =
 305                 uloc_getCountry(
 306                     alternateTags,
 307                     alternateRegion,
 308                     sizeof(alternateRegion),
 309                     err);
 310             if (U_FAILURE(*err) ||
 311                 alternateRegionLength &gt;= ULOC_COUNTRY_CAPACITY) {
 312                 goto error;
 313             }
 314             else if (alternateRegionLength &gt; 0) {
 315                 appendTag(
 316                     alternateRegion,
 317                     alternateRegionLength,
 318                     tagBuffer,
<a name="26" id="anc26"></a><span class="line-modified"> 319                     &amp;tagLength,</span>
<span class="line-added"> 320                     /*withSeparator=*/TRUE);</span>
 321 
 322                 regionAppended = TRUE;
 323             }
 324         }
 325 
<a name="27" id="anc27"></a><span class="line-modified"> 326         /**</span>
<span class="line-modified"> 327          * Copy the partial tag from our internal buffer to the supplied</span>
<span class="line-modified"> 328          * target.</span>
<span class="line-modified"> 329          **/</span>
<span class="line-modified"> 330         sink.Append(tagBuffer, tagLength);</span>










 331 
 332         if (trailingLength &gt; 0) {
<a name="28" id="anc28"></a><span class="line-modified"> 333             if (*trailing != &#39;@&#39;) {</span>
<span class="line-modified"> 334                 sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified"> 335                 if (!regionAppended) {</span>

 336                     /* extra separator is required */
<a name="29" id="anc29"></a><span class="line-modified"> 337                     sink.Append(&quot;_&quot;, 1);</span>

 338                 }
 339             }
 340 
<a name="30" id="anc30"></a><span class="line-modified"> 341             /*</span>
<span class="line-modified"> 342              * Copy the trailing data into the supplied buffer.</span>
<span class="line-modified"> 343              */</span>
<span class="line-modified"> 344             sink.Append(trailing, trailingLength);</span>









 345         }
 346 
<a name="31" id="anc31"></a><span class="line-modified"> 347         return;</span>






 348     }
 349 
 350 error:
 351 
 352     /**
 353      * An overflow indicates the locale ID passed in
 354      * is ill-formed.  If we got here, and there was
 355      * no previous error, it&#39;s an implicit overflow.
 356      **/
 357     if (*err ==  U_BUFFER_OVERFLOW_ERROR ||
 358         U_SUCCESS(*err)) {
 359         *err = U_ILLEGAL_ARGUMENT_ERROR;
 360     }
<a name="32" id="anc32"></a>

 361 }
 362 
 363 /**
 364  * Create a tag string from the supplied parameters.  The lang, script and region
 365  * parameters may be NULL pointers. If they are, their corresponding length parameters
 366  * must be less than or equal to 0.  If the lang parameter is an empty string, the
 367  * default value for an unknown language is written to the output buffer.
 368  *
 369  * If the length of the new string exceeds the capacity of the output buffer,
 370  * the function copies as many bytes to the output buffer as it can, and returns
 371  * the error U_BUFFER_OVERFLOW_ERROR.
 372  *
 373  * If an illegal argument is provided, the function returns the error
 374  * U_ILLEGAL_ARGUMENT_ERROR.
 375  *
 376  * @param lang The language tag to use.
 377  * @param langLength The length of the language tag.
 378  * @param script The script tag to use.
 379  * @param scriptLength The length of the script tag.
 380  * @param region The region tag to use.
 381  * @param regionLength The length of the region tag.
 382  * @param trailing Any trailing data to append to the new tag.
 383  * @param trailingLength The length of the trailing data.
<a name="33" id="anc33"></a><span class="line-modified"> 384  * @param sink The output sink receiving the tag string.</span>

 385  * @param err A pointer to a UErrorCode for error reporting.
<a name="34" id="anc34"></a>
 386  **/
<a name="35" id="anc35"></a><span class="line-modified"> 387 static void U_CALLCONV</span>
 388 createTagString(
 389     const char* lang,
 390     int32_t langLength,
 391     const char* script,
 392     int32_t scriptLength,
 393     const char* region,
 394     int32_t regionLength,
 395     const char* trailing,
 396     int32_t trailingLength,
<a name="36" id="anc36"></a><span class="line-modified"> 397     icu::ByteSink&amp; sink,</span>

 398     UErrorCode* err)
 399 {
<a name="37" id="anc37"></a><span class="line-modified"> 400     createTagStringWithAlternates(</span>
 401                 lang,
 402                 langLength,
 403                 script,
 404                 scriptLength,
 405                 region,
 406                 regionLength,
 407                 trailing,
 408                 trailingLength,
 409                 NULL,
<a name="38" id="anc38"></a><span class="line-modified"> 410                 sink,</span>

 411                 err);
 412 }
 413 
 414 /**
 415  * Parse the language, script, and region subtags from a tag string, and copy the
 416  * results into the corresponding output parameters. The buffers are null-terminated,
 417  * unless overflow occurs.
 418  *
 419  * The langLength, scriptLength, and regionLength parameters are input/output
 420  * parameters, and must contain the capacity of their corresponding buffers on
 421  * input.  On output, they will contain the actual length of the buffers, not
 422  * including the null terminator.
 423  *
 424  * If the length of any of the output subtags exceeds the capacity of the corresponding
 425  * buffer, the function copies as many bytes to the output buffer as it can, and returns
 426  * the error U_BUFFER_OVERFLOW_ERROR.  It will not parse any more subtags once overflow
 427  * occurs.
 428  *
 429  * If an illegal argument is provided, the function returns the error
 430  * U_ILLEGAL_ARGUMENT_ERROR.
 431  *
 432  * @param localeID The locale ID to parse.
 433  * @param lang The language tag buffer.
 434  * @param langLength The length of the language tag.
 435  * @param script The script tag buffer.
 436  * @param scriptLength The length of the script tag.
 437  * @param region The region tag buffer.
 438  * @param regionLength The length of the region tag.
 439  * @param err A pointer to a UErrorCode for error reporting.
 440  * @return The number of chars of the localeID parameter consumed.
 441  **/
 442 static int32_t U_CALLCONV
 443 parseTagString(
 444     const char* localeID,
 445     char* lang,
 446     int32_t* langLength,
 447     char* script,
 448     int32_t* scriptLength,
 449     char* region,
 450     int32_t* regionLength,
 451     UErrorCode* err)
 452 {
 453     const char* position = localeID;
 454     int32_t subtagLength = 0;
 455 
 456     if(U_FAILURE(*err) ||
 457        localeID == NULL ||
 458        lang == NULL ||
 459        langLength == NULL ||
 460        script == NULL ||
 461        scriptLength == NULL ||
 462        region == NULL ||
 463        regionLength == NULL) {
 464         goto error;
 465     }
 466 
 467     subtagLength = ulocimp_getLanguage(position, lang, *langLength, &amp;position);
 468     u_terminateChars(lang, *langLength, subtagLength, err);
 469 
 470     /*
 471      * Note that we explicit consider U_STRING_NOT_TERMINATED_WARNING
 472      * to be an error, because it indicates the user-supplied tag is
 473      * not well-formed.
 474      */
 475     if(U_FAILURE(*err)) {
 476         goto error;
 477     }
 478 
 479     *langLength = subtagLength;
 480 
 481     /*
<a name="39" id="anc39"></a><span class="line-modified"> 482      * If no language was present, use the empty string instead.</span>
<span class="line-modified"> 483      * Otherwise, move past any separator.</span>
 484      */
<a name="40" id="anc40"></a>





 485     if (_isIDSeparator(*position)) {
 486         ++position;
 487     }
 488 
 489     subtagLength = ulocimp_getScript(position, script, *scriptLength, &amp;position);
 490     u_terminateChars(script, *scriptLength, subtagLength, err);
 491 
 492     if(U_FAILURE(*err)) {
 493         goto error;
 494     }
 495 
 496     *scriptLength = subtagLength;
 497 
 498     if (*scriptLength &gt; 0) {
 499         if (uprv_strnicmp(script, unknownScript, *scriptLength) == 0) {
 500             /**
 501              * If the script part is the &quot;unknown&quot; script, then don&#39;t return it.
 502              **/
 503             *scriptLength = 0;
 504         }
 505 
 506         /*
 507          * Move past any separator.
 508          */
 509         if (_isIDSeparator(*position)) {
 510             ++position;
 511         }
 512     }
 513 
 514     subtagLength = ulocimp_getCountry(position, region, *regionLength, &amp;position);
 515     u_terminateChars(region, *regionLength, subtagLength, err);
 516 
 517     if(U_FAILURE(*err)) {
 518         goto error;
 519     }
 520 
 521     *regionLength = subtagLength;
 522 
 523     if (*regionLength &gt; 0) {
 524         if (uprv_strnicmp(region, unknownRegion, *regionLength) == 0) {
 525             /**
 526              * If the region part is the &quot;unknown&quot; region, then don&#39;t return it.
 527              **/
 528             *regionLength = 0;
 529         }
 530     } else if (*position != 0 &amp;&amp; *position != &#39;@&#39;) {
 531         /* back up over consumed trailing separator */
 532         --position;
 533     }
 534 
 535 exit:
 536 
 537     return (int32_t)(position - localeID);
 538 
 539 error:
 540 
 541     /**
 542      * If we get here, we have no explicit error, it&#39;s the result of an
 543      * illegal argument.
 544      **/
 545     if (!U_FAILURE(*err)) {
 546         *err = U_ILLEGAL_ARGUMENT_ERROR;
 547     }
 548 
 549     goto exit;
 550 }
 551 
<a name="41" id="anc41"></a><span class="line-modified"> 552 static UBool U_CALLCONV</span>
 553 createLikelySubtagsString(
 554     const char* lang,
 555     int32_t langLength,
 556     const char* script,
 557     int32_t scriptLength,
 558     const char* region,
 559     int32_t regionLength,
 560     const char* variants,
 561     int32_t variantsLength,
<a name="42" id="anc42"></a><span class="line-modified"> 562     icu::ByteSink&amp; sink,</span>
<span class="line-modified"> 563     UErrorCode* err) {</span>


 564     /**
 565      * ULOC_FULLNAME_CAPACITY will provide enough capacity
 566      * that we can build a string that contains the language,
 567      * script and region code without worrying about overrunning
 568      * the user-supplied buffer.
 569      **/
<a name="43" id="anc43"></a>
 570     char likelySubtagsBuffer[ULOC_FULLNAME_CAPACITY];
 571 
 572     if(U_FAILURE(*err)) {
 573         goto error;
 574     }
 575 
 576     /**
 577      * Try the language with the script and region first.
 578      **/
 579     if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
 580 
 581         const char* likelySubtags = NULL;
 582 
<a name="44" id="anc44"></a><span class="line-modified"> 583         icu::CharString tagBuffer;</span>
<span class="line-modified"> 584         {</span>
<span class="line-modified"> 585             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified"> 586             createTagString(</span>
<span class="line-modified"> 587                 lang,</span>
<span class="line-modified"> 588                 langLength,</span>
<span class="line-modified"> 589                 script,</span>
<span class="line-modified"> 590                 scriptLength,</span>
<span class="line-modified"> 591                 region,</span>
<span class="line-modified"> 592                 regionLength,</span>
<span class="line-modified"> 593                 NULL,</span>
<span class="line-modified"> 594                 0,</span>
<span class="line-added"> 595                 sink,</span>
<span class="line-added"> 596                 err);</span>
<span class="line-added"> 597         }</span>
 598         if(U_FAILURE(*err)) {
 599             goto error;
 600         }
 601 
 602         likelySubtags =
 603             findLikelySubtags(
<a name="45" id="anc45"></a><span class="line-modified"> 604                 tagBuffer.data(),</span>
 605                 likelySubtagsBuffer,
 606                 sizeof(likelySubtagsBuffer),
 607                 err);
 608         if(U_FAILURE(*err)) {
 609             goto error;
 610         }
 611 
 612         if (likelySubtags != NULL) {
 613             /* Always use the language tag from the
 614                maximal string, since it may be more
 615                specific than the one provided. */
<a name="46" id="anc46"></a><span class="line-modified"> 616             createTagStringWithAlternates(</span>
 617                         NULL,
 618                         0,
 619                         NULL,
 620                         0,
 621                         NULL,
 622                         0,
 623                         variants,
 624                         variantsLength,
 625                         likelySubtags,
<a name="47" id="anc47"></a><span class="line-modified"> 626                         sink,</span>

 627                         err);
<a name="48" id="anc48"></a><span class="line-added"> 628             return TRUE;</span>
 629         }
 630     }
 631 
 632     /**
 633      * Try the language with just the script.
 634      **/
 635     if (scriptLength &gt; 0) {
 636 
 637         const char* likelySubtags = NULL;
 638 
<a name="49" id="anc49"></a><span class="line-modified"> 639         icu::CharString tagBuffer;</span>
<span class="line-modified"> 640         {</span>
<span class="line-modified"> 641             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified"> 642             createTagString(</span>
<span class="line-modified"> 643                 lang,</span>
<span class="line-modified"> 644                 langLength,</span>
<span class="line-modified"> 645                 script,</span>
<span class="line-modified"> 646                 scriptLength,</span>
<span class="line-modified"> 647                 NULL,</span>
<span class="line-modified"> 648                 0,</span>
<span class="line-modified"> 649                 NULL,</span>
<span class="line-modified"> 650                 0,</span>
<span class="line-added"> 651                 sink,</span>
<span class="line-added"> 652                 err);</span>
<span class="line-added"> 653         }</span>
 654         if(U_FAILURE(*err)) {
 655             goto error;
 656         }
 657 
 658         likelySubtags =
 659             findLikelySubtags(
<a name="50" id="anc50"></a><span class="line-modified"> 660                 tagBuffer.data(),</span>
 661                 likelySubtagsBuffer,
 662                 sizeof(likelySubtagsBuffer),
 663                 err);
 664         if(U_FAILURE(*err)) {
 665             goto error;
 666         }
 667 
 668         if (likelySubtags != NULL) {
 669             /* Always use the language tag from the
 670                maximal string, since it may be more
 671                specific than the one provided. */
<a name="51" id="anc51"></a><span class="line-modified"> 672             createTagStringWithAlternates(</span>
 673                         NULL,
 674                         0,
 675                         NULL,
 676                         0,
 677                         region,
 678                         regionLength,
 679                         variants,
 680                         variantsLength,
 681                         likelySubtags,
<a name="52" id="anc52"></a><span class="line-modified"> 682                         sink,</span>

 683                         err);
<a name="53" id="anc53"></a><span class="line-added"> 684             return TRUE;</span>
 685         }
 686     }
 687 
 688     /**
 689      * Try the language with just the region.
 690      **/
 691     if (regionLength &gt; 0) {
 692 
 693         const char* likelySubtags = NULL;
 694 
<a name="54" id="anc54"></a><span class="line-modified"> 695         icu::CharString tagBuffer;</span>
<span class="line-modified"> 696         {</span>
<span class="line-modified"> 697             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified"> 698             createTagString(</span>
<span class="line-modified"> 699                 lang,</span>
<span class="line-modified"> 700                 langLength,</span>
<span class="line-modified"> 701                 NULL,</span>
<span class="line-modified"> 702                 0,</span>
<span class="line-modified"> 703                 region,</span>
<span class="line-modified"> 704                 regionLength,</span>
<span class="line-modified"> 705                 NULL,</span>
<span class="line-modified"> 706                 0,</span>
<span class="line-added"> 707                 sink,</span>
<span class="line-added"> 708                 err);</span>
<span class="line-added"> 709         }</span>
 710         if(U_FAILURE(*err)) {
 711             goto error;
 712         }
 713 
 714         likelySubtags =
 715             findLikelySubtags(
<a name="55" id="anc55"></a><span class="line-modified"> 716                 tagBuffer.data(),</span>
 717                 likelySubtagsBuffer,
 718                 sizeof(likelySubtagsBuffer),
 719                 err);
 720         if(U_FAILURE(*err)) {
 721             goto error;
 722         }
 723 
 724         if (likelySubtags != NULL) {
 725             /* Always use the language tag from the
 726                maximal string, since it may be more
 727                specific than the one provided. */
<a name="56" id="anc56"></a><span class="line-modified"> 728             createTagStringWithAlternates(</span>
 729                         NULL,
 730                         0,
 731                         script,
 732                         scriptLength,
 733                         NULL,
 734                         0,
 735                         variants,
 736                         variantsLength,
 737                         likelySubtags,
<a name="57" id="anc57"></a><span class="line-modified"> 738                         sink,</span>

 739                         err);
<a name="58" id="anc58"></a><span class="line-added"> 740             return TRUE;</span>
 741         }
 742     }
 743 
 744     /**
 745      * Finally, try just the language.
 746      **/
 747     {
 748         const char* likelySubtags = NULL;
 749 
<a name="59" id="anc59"></a><span class="line-modified"> 750         icu::CharString tagBuffer;</span>
<span class="line-modified"> 751         {</span>
<span class="line-modified"> 752             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified"> 753             createTagString(</span>
<span class="line-modified"> 754                 lang,</span>
<span class="line-modified"> 755                 langLength,</span>
<span class="line-modified"> 756                 NULL,</span>
<span class="line-modified"> 757                 0,</span>
<span class="line-modified"> 758                 NULL,</span>
<span class="line-modified"> 759                 0,</span>
<span class="line-modified"> 760                 NULL,</span>
<span class="line-modified"> 761                 0,</span>
<span class="line-added"> 762                 sink,</span>
<span class="line-added"> 763                 err);</span>
<span class="line-added"> 764         }</span>
 765         if(U_FAILURE(*err)) {
 766             goto error;
 767         }
 768 
 769         likelySubtags =
 770             findLikelySubtags(
<a name="60" id="anc60"></a><span class="line-modified"> 771                 tagBuffer.data(),</span>
 772                 likelySubtagsBuffer,
 773                 sizeof(likelySubtagsBuffer),
 774                 err);
 775         if(U_FAILURE(*err)) {
 776             goto error;
 777         }
 778 
 779         if (likelySubtags != NULL) {
 780             /* Always use the language tag from the
 781                maximal string, since it may be more
 782                specific than the one provided. */
<a name="61" id="anc61"></a><span class="line-modified"> 783             createTagStringWithAlternates(</span>
 784                         NULL,
 785                         0,
 786                         script,
 787                         scriptLength,
 788                         region,
 789                         regionLength,
 790                         variants,
 791                         variantsLength,
 792                         likelySubtags,
<a name="62" id="anc62"></a><span class="line-modified"> 793                         sink,</span>

 794                         err);
<a name="63" id="anc63"></a><span class="line-added"> 795             return TRUE;</span>
 796         }
 797     }
 798 
<a name="64" id="anc64"></a><span class="line-modified"> 799     return FALSE;</span>




 800 
 801 error:
 802 
 803     if (!U_FAILURE(*err)) {
 804         *err = U_ILLEGAL_ARGUMENT_ERROR;
 805     }
 806 
<a name="65" id="anc65"></a><span class="line-modified"> 807     return FALSE;</span>
 808 }
 809 
 810 #define CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength) \
 811     {   int32_t count = 0; \
 812         int32_t i; \
 813         for (i = 0; i &lt; trailingLength; i++) { \
 814             if (trailing[i] == &#39;-&#39; || trailing[i] == &#39;_&#39;) { \
 815                 count = 0; \
 816                 if (count &gt; 8) { \
 817                     goto error; \
 818                 } \
 819             } else if (trailing[i] == &#39;@&#39;) { \
 820                 break; \
 821             } else if (count &gt; 8) { \
 822                 goto error; \
 823             } else { \
 824                 count++; \
 825             } \
 826         } \
 827     }
 828 
<a name="66" id="anc66"></a><span class="line-modified"> 829 static void</span>
<span class="line-modified"> 830 _uloc_addLikelySubtags(const char* localeID,</span>
<span class="line-modified"> 831                        icu::ByteSink&amp; sink,</span>
<span class="line-modified"> 832                        UErrorCode* err) {</span>


 833     char lang[ULOC_LANG_CAPACITY];
 834     int32_t langLength = sizeof(lang);
 835     char script[ULOC_SCRIPT_CAPACITY];
 836     int32_t scriptLength = sizeof(script);
 837     char region[ULOC_COUNTRY_CAPACITY];
 838     int32_t regionLength = sizeof(region);
 839     const char* trailing = &quot;&quot;;
 840     int32_t trailingLength = 0;
 841     int32_t trailingIndex = 0;
<a name="67" id="anc67"></a><span class="line-modified"> 842     UBool success = FALSE;</span>
 843 
 844     if(U_FAILURE(*err)) {
 845         goto error;
 846     }
<a name="68" id="anc68"></a><span class="line-modified"> 847     if (localeID == NULL) {</span>


 848         goto error;
 849     }
 850 
 851     trailingIndex = parseTagString(
 852         localeID,
 853         lang,
 854         &amp;langLength,
 855         script,
 856         &amp;scriptLength,
 857         region,
 858         &amp;regionLength,
 859         err);
 860     if(U_FAILURE(*err)) {
 861         /* Overflow indicates an illegal argument error */
 862         if (*err == U_BUFFER_OVERFLOW_ERROR) {
 863             *err = U_ILLEGAL_ARGUMENT_ERROR;
 864         }
 865 
 866         goto error;
 867     }
 868 
 869     /* Find the length of the trailing portion. */
 870     while (_isIDSeparator(localeID[trailingIndex])) {
 871         trailingIndex++;
 872     }
 873     trailing = &amp;localeID[trailingIndex];
 874     trailingLength = (int32_t)uprv_strlen(trailing);
 875 
 876     CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
 877 
<a name="69" id="anc69"></a><span class="line-modified"> 878     success =</span>
 879         createLikelySubtagsString(
 880             lang,
 881             langLength,
 882             script,
 883             scriptLength,
 884             region,
 885             regionLength,
 886             trailing,
 887             trailingLength,
<a name="70" id="anc70"></a><span class="line-modified"> 888             sink,</span>

 889             err);
 890 
<a name="71" id="anc71"></a><span class="line-modified"> 891     if (!success) {</span>
 892         const int32_t localIDLength = (int32_t)uprv_strlen(localeID);
 893 
 894         /*
 895          * If we get here, we need to return localeID.
 896          */
<a name="72" id="anc72"></a><span class="line-modified"> 897         sink.Append(localeID, localIDLength);</span>











 898     }
 899 
<a name="73" id="anc73"></a><span class="line-modified"> 900     return;</span>
 901 
 902 error:
 903 
 904     if (!U_FAILURE(*err)) {
 905         *err = U_ILLEGAL_ARGUMENT_ERROR;
 906     }
<a name="74" id="anc74"></a>

 907 }
 908 
<a name="75" id="anc75"></a><span class="line-modified"> 909 static void</span>
<span class="line-modified"> 910 _uloc_minimizeSubtags(const char* localeID,</span>
<span class="line-modified"> 911                       icu::ByteSink&amp; sink,</span>
<span class="line-modified"> 912                       UErrorCode* err) {</span>
<span class="line-modified"> 913     icu::CharString maximizedTagBuffer;</span>









 914 
 915     char lang[ULOC_LANG_CAPACITY];
 916     int32_t langLength = sizeof(lang);
 917     char script[ULOC_SCRIPT_CAPACITY];
 918     int32_t scriptLength = sizeof(script);
 919     char region[ULOC_COUNTRY_CAPACITY];
 920     int32_t regionLength = sizeof(region);
 921     const char* trailing = &quot;&quot;;
 922     int32_t trailingLength = 0;
 923     int32_t trailingIndex = 0;
 924 
 925     if(U_FAILURE(*err)) {
 926         goto error;
 927     }
<a name="76" id="anc76"></a><span class="line-modified"> 928     else if (localeID == NULL) {</span>


 929         goto error;
 930     }
 931 
 932     trailingIndex =
 933         parseTagString(
 934             localeID,
 935             lang,
 936             &amp;langLength,
 937             script,
 938             &amp;scriptLength,
 939             region,
 940             &amp;regionLength,
 941             err);
 942     if(U_FAILURE(*err)) {
 943 
 944         /* Overflow indicates an illegal argument error */
 945         if (*err == U_BUFFER_OVERFLOW_ERROR) {
 946             *err = U_ILLEGAL_ARGUMENT_ERROR;
 947         }
 948 
 949         goto error;
 950     }
 951 
 952     /* Find the spot where the variants or the keywords begin, if any. */
 953     while (_isIDSeparator(localeID[trailingIndex])) {
 954         trailingIndex++;
 955     }
 956     trailing = &amp;localeID[trailingIndex];
 957     trailingLength = (int32_t)uprv_strlen(trailing);
 958 
 959     CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
 960 
<a name="77" id="anc77"></a><span class="line-modified"> 961     {</span>
<span class="line-modified"> 962         icu::CharString base;</span>
<span class="line-modified"> 963         {</span>
<span class="line-modified"> 964             icu::CharStringByteSink sink(&amp;base);</span>
<span class="line-modified"> 965             createTagString(</span>
<span class="line-modified"> 966                 lang,</span>
<span class="line-modified"> 967                 langLength,</span>
<span class="line-modified"> 968                 script,</span>
<span class="line-modified"> 969                 scriptLength,</span>
<span class="line-modified"> 970                 region,</span>
<span class="line-modified"> 971                 regionLength,</span>
<span class="line-modified"> 972                 NULL,</span>
<span class="line-modified"> 973                 0,</span>
<span class="line-modified"> 974                 sink,</span>
<span class="line-modified"> 975                 err);</span>
<span class="line-added"> 976         }</span>
 977 
<a name="78" id="anc78"></a><span class="line-modified"> 978         /**</span>
<span class="line-modified"> 979          * First, we need to first get the maximization</span>
<span class="line-modified"> 980          * from AddLikelySubtags.</span>
<span class="line-modified"> 981          **/</span>
<span class="line-modified"> 982         {</span>
<span class="line-modified"> 983             icu::CharStringByteSink sink(&amp;maximizedTagBuffer);</span>
<span class="line-modified"> 984             ulocimp_addLikelySubtags(base.data(), sink, err);</span>
<span class="line-modified"> 985         }</span>
<span class="line-modified"> 986     }</span>

 987 
 988     if(U_FAILURE(*err)) {
 989         goto error;
 990     }
 991 
 992     /**
 993      * Start first with just the language.
 994      **/
 995     {
<a name="79" id="anc79"></a><span class="line-modified"> 996         icu::CharString tagBuffer;</span>
<span class="line-modified"> 997         {</span>
<span class="line-modified"> 998             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
 999             createLikelySubtagsString(
1000                 lang,
1001                 langLength,
1002                 NULL,
1003                 0,
1004                 NULL,
1005                 0,
1006                 NULL,
1007                 0,
<a name="80" id="anc80"></a><span class="line-modified">1008                 sink,</span>

1009                 err);
<a name="81" id="anc81"></a><span class="line-added">1010         }</span>
1011 
1012         if(U_FAILURE(*err)) {
1013             goto error;
1014         }
<a name="82" id="anc82"></a><span class="line-modified">1015         else if (!tagBuffer.isEmpty() &amp;&amp; uprv_strnicmp(</span>
<span class="line-modified">1016                     maximizedTagBuffer.data(),</span>
<span class="line-modified">1017                     tagBuffer.data(),</span>
<span class="line-modified">1018                     tagBuffer.length()) == 0) {</span>
1019 
<a name="83" id="anc83"></a><span class="line-modified">1020             createTagString(</span>
1021                         lang,
1022                         langLength,
1023                         NULL,
1024                         0,
1025                         NULL,
1026                         0,
1027                         trailing,
1028                         trailingLength,
<a name="84" id="anc84"></a><span class="line-modified">1029                         sink,</span>

1030                         err);
<a name="85" id="anc85"></a><span class="line-added">1031             return;</span>
1032         }
1033     }
1034 
1035     /**
1036      * Next, try the language and region.
1037      **/
1038     if (regionLength &gt; 0) {
1039 
<a name="86" id="anc86"></a><span class="line-modified">1040         icu::CharString tagBuffer;</span>
<span class="line-modified">1041         {</span>
<span class="line-modified">1042             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
1043             createLikelySubtagsString(
1044                 lang,
1045                 langLength,
1046                 NULL,
1047                 0,
1048                 region,
1049                 regionLength,
1050                 NULL,
1051                 0,
<a name="87" id="anc87"></a><span class="line-modified">1052                 sink,</span>

1053                 err);
<a name="88" id="anc88"></a><span class="line-added">1054         }</span>
1055 
1056         if(U_FAILURE(*err)) {
1057             goto error;
1058         }
1059         else if (uprv_strnicmp(
<a name="89" id="anc89"></a><span class="line-modified">1060                     maximizedTagBuffer.data(),</span>
<span class="line-modified">1061                     tagBuffer.data(),</span>
<span class="line-modified">1062                     tagBuffer.length()) == 0) {</span>
1063 
<a name="90" id="anc90"></a><span class="line-modified">1064             createTagString(</span>
1065                         lang,
1066                         langLength,
1067                         NULL,
1068                         0,
1069                         region,
1070                         regionLength,
1071                         trailing,
1072                         trailingLength,
<a name="91" id="anc91"></a><span class="line-modified">1073                         sink,</span>

1074                         err);
<a name="92" id="anc92"></a><span class="line-added">1075             return;</span>
1076         }
1077     }
1078 
1079     /**
1080      * Finally, try the language and script.  This is our last chance,
1081      * since trying with all three subtags would only yield the
1082      * maximal version that we already have.
1083      **/
1084     if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
<a name="93" id="anc93"></a><span class="line-modified">1085         icu::CharString tagBuffer;</span>
<span class="line-modified">1086         {</span>
<span class="line-modified">1087             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
1088             createLikelySubtagsString(
1089                 lang,
1090                 langLength,
1091                 script,
1092                 scriptLength,
1093                 NULL,
1094                 0,
1095                 NULL,
1096                 0,
<a name="94" id="anc94"></a><span class="line-modified">1097                 sink,</span>

1098                 err);
<a name="95" id="anc95"></a><span class="line-added">1099         }</span>
1100 
1101         if(U_FAILURE(*err)) {
1102             goto error;
1103         }
1104         else if (uprv_strnicmp(
<a name="96" id="anc96"></a><span class="line-modified">1105                     maximizedTagBuffer.data(),</span>
<span class="line-modified">1106                     tagBuffer.data(),</span>
<span class="line-modified">1107                     tagBuffer.length()) == 0) {</span>
1108 
<a name="97" id="anc97"></a><span class="line-modified">1109             createTagString(</span>
1110                         lang,
1111                         langLength,
1112                         script,
1113                         scriptLength,
1114                         NULL,
1115                         0,
1116                         trailing,
1117                         trailingLength,
<a name="98" id="anc98"></a><span class="line-modified">1118                         sink,</span>

1119                         err);
<a name="99" id="anc99"></a><span class="line-added">1120             return;</span>
1121         }
1122     }
1123 
1124     {
1125         /**
1126          * If we got here, return the locale ID parameter.
1127          **/
1128         const int32_t localeIDLength = (int32_t)uprv_strlen(localeID);
<a name="100" id="anc100"></a><span class="line-modified">1129         sink.Append(localeID, localeIDLength);</span>
<span class="line-modified">1130         return;</span>










1131     }
1132 
1133 error:
1134 
1135     if (!U_FAILURE(*err)) {
1136         *err = U_ILLEGAL_ARGUMENT_ERROR;
1137     }
<a name="101" id="anc101"></a>



1138 }
1139 
1140 static UBool
1141 do_canonicalize(const char*    localeID,
1142          char* buffer,
1143          int32_t bufferCapacity,
1144          UErrorCode* err)
1145 {
1146     uloc_canonicalize(
1147         localeID,
1148         buffer,
1149         bufferCapacity,
1150         err);
1151 
1152     if (*err == U_STRING_NOT_TERMINATED_WARNING ||
1153         *err == U_BUFFER_OVERFLOW_ERROR) {
1154         *err = U_ILLEGAL_ARGUMENT_ERROR;
1155 
1156         return FALSE;
1157     }
1158     else if (U_FAILURE(*err)) {
1159 
1160         return FALSE;
1161     }
1162     else {
1163         return TRUE;
1164     }
1165 }
1166 
1167 U_CAPI int32_t U_EXPORT2
<a name="102" id="anc102"></a><span class="line-modified">1168 uloc_addLikelySubtags(const char* localeID,</span>
<span class="line-modified">1169                       char* maximizedLocaleID,</span>
<span class="line-modified">1170                       int32_t maximizedLocaleIDCapacity,</span>
<span class="line-modified">1171                       UErrorCode* status) {</span>
<span class="line-modified">1172     if (U_FAILURE(*status)) {</span>
<span class="line-modified">1173         return 0;</span>
<span class="line-added">1174     }</span>
1175 
<a name="103" id="anc103"></a><span class="line-modified">1176     icu::CheckedArrayByteSink sink(</span>
<span class="line-modified">1177             maximizedLocaleID, maximizedLocaleIDCapacity);</span>
<span class="line-modified">1178 </span>
<span class="line-modified">1179     ulocimp_addLikelySubtags(localeID, sink, status);</span>
<span class="line-modified">1180     int32_t reslen = sink.NumberOfBytesAppended();</span>
<span class="line-modified">1181 </span>
<span class="line-added">1182     if (U_FAILURE(*status)) {</span>
<span class="line-added">1183         return sink.Overflowed() ? reslen : -1;</span>
1184     }
<a name="104" id="anc104"></a><span class="line-modified">1185 </span>
<span class="line-modified">1186     if (sink.Overflowed()) {</span>
<span class="line-modified">1187         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-modified">1188     } else {</span>
<span class="line-modified">1189         u_terminateChars(</span>
<span class="line-modified">1190                 maximizedLocaleID, maximizedLocaleIDCapacity, reslen, status);</span>
1191     }
<a name="105" id="anc105"></a><span class="line-added">1192 </span>
<span class="line-added">1193     return reslen;</span>
1194 }
1195 
<a name="106" id="anc106"></a><span class="line-modified">1196 U_CAPI void U_EXPORT2</span>
<span class="line-modified">1197 ulocimp_addLikelySubtags(const char* localeID,</span>
<span class="line-modified">1198                          icu::ByteSink&amp; sink,</span>
<span class="line-modified">1199                          UErrorCode* status) {</span>


1200     char localeBuffer[ULOC_FULLNAME_CAPACITY];
1201 
<a name="107" id="anc107"></a><span class="line-modified">1202     if (do_canonicalize(localeID, localeBuffer, sizeof localeBuffer, status)) {</span>
<span class="line-modified">1203         _uloc_addLikelySubtags(localeBuffer, sink, status);</span>




1204     }
<a name="108" id="anc108"></a><span class="line-modified">1205 }</span>
<span class="line-modified">1206 </span>
<span class="line-modified">1207 U_CAPI int32_t U_EXPORT2</span>
<span class="line-modified">1208 uloc_minimizeSubtags(const char* localeID,</span>
<span class="line-modified">1209                      char* minimizedLocaleID,</span>
<span class="line-modified">1210                      int32_t minimizedLocaleIDCapacity,</span>
<span class="line-added">1211                      UErrorCode* status) {</span>
<span class="line-added">1212     if (U_FAILURE(*status)) {</span>
<span class="line-added">1213         return 0;</span>
<span class="line-added">1214     }</span>
<span class="line-added">1215 </span>
<span class="line-added">1216     icu::CheckedArrayByteSink sink(</span>
<span class="line-added">1217             minimizedLocaleID, minimizedLocaleIDCapacity);</span>
<span class="line-added">1218 </span>
<span class="line-added">1219     ulocimp_minimizeSubtags(localeID, sink, status);</span>
<span class="line-added">1220     int32_t reslen = sink.NumberOfBytesAppended();</span>
<span class="line-added">1221 </span>
<span class="line-added">1222     if (U_FAILURE(*status)) {</span>
<span class="line-added">1223         return sink.Overflowed() ? reslen : -1;</span>
<span class="line-added">1224     }</span>
<span class="line-added">1225 </span>
<span class="line-added">1226     if (sink.Overflowed()) {</span>
<span class="line-added">1227         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-added">1228     } else {</span>
<span class="line-added">1229         u_terminateChars(</span>
<span class="line-added">1230                 minimizedLocaleID, minimizedLocaleIDCapacity, reslen, status);</span>
<span class="line-added">1231     }</span>
<span class="line-added">1232 </span>
<span class="line-added">1233     return reslen;</span>
<span class="line-added">1234 }</span>
<span class="line-added">1235 </span>
<span class="line-added">1236 U_CAPI void U_EXPORT2</span>
<span class="line-added">1237 ulocimp_minimizeSubtags(const char* localeID,</span>
<span class="line-added">1238                         icu::ByteSink&amp; sink,</span>
<span class="line-added">1239                         UErrorCode* status) {</span>
<span class="line-added">1240     char localeBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-added">1241 </span>
<span class="line-added">1242     if (do_canonicalize(localeID, localeBuffer, sizeof localeBuffer, status)) {</span>
<span class="line-added">1243         _uloc_minimizeSubtags(localeBuffer, sink, status);</span>
1244     }
1245 }
1246 
1247 // Pairs of (language subtag, + or -) for finding out fast if common languages
1248 // are LTR (minus) or RTL (plus).
1249 static const char LANG_DIR_STRING[] =
1250         &quot;root-en-es-pt-zh-ja-ko-de-fr-it-ar+he+fa+ru-nl-pl-th-tr-&quot;;
1251 
<a name="109" id="anc109"></a><span class="line-modified">1252 // Implemented here because this calls ulocimp_addLikelySubtags().</span>
1253 U_CAPI UBool U_EXPORT2
1254 uloc_isRightToLeft(const char *locale) {
1255     UErrorCode errorCode = U_ZERO_ERROR;
1256     char script[8];
1257     int32_t scriptLength = uloc_getScript(locale, script, UPRV_LENGTHOF(script), &amp;errorCode);
1258     if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
1259             scriptLength == 0) {
1260         // Fastpath: We know the likely scripts and their writing direction
1261         // for some common languages.
1262         errorCode = U_ZERO_ERROR;
1263         char lang[8];
1264         int32_t langLength = uloc_getLanguage(locale, lang, UPRV_LENGTHOF(lang), &amp;errorCode);
<a name="110" id="anc110"></a><span class="line-modified">1265         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {</span>

1266             return FALSE;
1267         }
<a name="111" id="anc111"></a><span class="line-modified">1268         if (langLength &gt; 0) {</span>
<span class="line-modified">1269             const char* langPtr = uprv_strstr(LANG_DIR_STRING, lang);</span>
<span class="line-modified">1270             if (langPtr != NULL) {</span>
<span class="line-modified">1271                 switch (langPtr[langLength]) {</span>
<span class="line-modified">1272                 case &#39;-&#39;: return FALSE;</span>
<span class="line-modified">1273                 case &#39;+&#39;: return TRUE;</span>
<span class="line-added">1274                 default: break;  // partial match of a longer code</span>
<span class="line-added">1275                 }</span>
1276             }
1277         }
1278         // Otherwise, find the likely script.
1279         errorCode = U_ZERO_ERROR;
<a name="112" id="anc112"></a><span class="line-modified">1280         icu::CharString likely;</span>
<span class="line-modified">1281         {</span>
<span class="line-added">1282             icu::CharStringByteSink sink(&amp;likely);</span>
<span class="line-added">1283             ulocimp_addLikelySubtags(locale, sink, &amp;errorCode);</span>
<span class="line-added">1284         }</span>
1285         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {
1286             return FALSE;
1287         }
<a name="113" id="anc113"></a><span class="line-modified">1288         scriptLength = uloc_getScript(likely.data(), script, UPRV_LENGTHOF(script), &amp;errorCode);</span>
1289         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
1290                 scriptLength == 0) {
1291             return FALSE;
1292         }
1293     }
1294     UScriptCode scriptCode = (UScriptCode)u_getPropertyValueEnum(UCHAR_SCRIPT, script);
1295     return uscript_isRightToLeft(scriptCode);
1296 }
1297 
1298 U_NAMESPACE_BEGIN
1299 
1300 UBool
1301 Locale::isRightToLeft() const {
1302     return uloc_isRightToLeft(getBaseName());
1303 }
1304 
1305 U_NAMESPACE_END
1306 
1307 // The following must at least allow for rg key value (6) plus terminator (1).
1308 #define ULOC_RG_BUFLEN 8
1309 
1310 U_CAPI int32_t U_EXPORT2
1311 ulocimp_getRegionForSupplementalData(const char *localeID, UBool inferRegion,
1312                                      char *region, int32_t regionCapacity, UErrorCode* status) {
1313     if (U_FAILURE(*status)) {
1314         return 0;
1315     }
1316     char rgBuf[ULOC_RG_BUFLEN];
1317     UErrorCode rgStatus = U_ZERO_ERROR;
1318 
1319     // First check for rg keyword value
1320     int32_t rgLen = uloc_getKeywordValue(localeID, &quot;rg&quot;, rgBuf, ULOC_RG_BUFLEN, &amp;rgStatus);
1321     if (U_FAILURE(rgStatus) || rgLen != 6) {
1322         rgLen = 0;
1323     } else {
1324         // rgBuf guaranteed to be zero terminated here, with text len 6
1325         char *rgPtr = rgBuf;
1326         for (; *rgPtr!= 0; rgPtr++) {
1327             *rgPtr = uprv_toupper(*rgPtr);
1328         }
1329         rgLen = (uprv_strcmp(rgBuf+2, &quot;ZZZZ&quot;) == 0)? 2: 0;
1330     }
1331 
1332     if (rgLen == 0) {
1333         // No valid rg keyword value, try for unicode_region_subtag
1334         rgLen = uloc_getCountry(localeID, rgBuf, ULOC_RG_BUFLEN, status);
1335         if (U_FAILURE(*status)) {
1336             rgLen = 0;
1337         } else if (rgLen == 0 &amp;&amp; inferRegion) {
1338             // no unicode_region_subtag but inferRegion TRUE, try likely subtags
<a name="114" id="anc114"></a>
1339             rgStatus = U_ZERO_ERROR;
<a name="115" id="anc115"></a><span class="line-modified">1340             icu::CharString locBuf;</span>
<span class="line-added">1341             {</span>
<span class="line-added">1342                 icu::CharStringByteSink sink(&amp;locBuf);</span>
<span class="line-added">1343                 ulocimp_addLikelySubtags(localeID, sink, &amp;rgStatus);</span>
<span class="line-added">1344             }</span>
1345             if (U_SUCCESS(rgStatus)) {
<a name="116" id="anc116"></a><span class="line-modified">1346                 rgLen = uloc_getCountry(locBuf.data(), rgBuf, ULOC_RG_BUFLEN, status);</span>
1347                 if (U_FAILURE(*status)) {
1348                     rgLen = 0;
1349                 }
1350             }
1351         }
1352     }
1353 
1354     rgBuf[rgLen] = 0;
1355     uprv_strncpy(region, rgBuf, regionCapacity);
1356     return u_terminateChars(region, regionCapacity, rgLen, status);
1357 }
1358 
<a name="117" id="anc117"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="117" type="hidden" />
</body>
</html>