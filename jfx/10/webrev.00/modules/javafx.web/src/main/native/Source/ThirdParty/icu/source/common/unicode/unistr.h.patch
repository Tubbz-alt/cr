diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/unistr.h b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/unistr.h
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/unistr.h
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/unistr.h
@@ -104,11 +104,11 @@
  * only latin letters, digits, and some punctuation.
  * See utypes.h for details.
  *
  * The string parameter must be a C string literal.
  * The length of the string, not including the terminating
- * <code>NUL</code>, must be specified as a constant.
+ * `NUL`, must be specified as a constant.
  * @stable ICU 2.0
  */
 #if !U_CHAR16_IS_TYPEDEF
 # define UNICODE_STRING(cs, _length) icu::UnicodeString(TRUE, u ## cs, _length)
 #else
@@ -219,36 +219,39 @@
  * For details see the description of storage models at the end of the class API docs
  * and in the User Guide chapter linked from there.
  *
  * The UnicodeString class is not suitable for subclassing.
  *
- * <p>For an overview of Unicode strings in C and C++ see the
- * <a href="http://userguide.icu-project.org/strings#TOC-Strings-in-C-C-">User Guide Strings chapter</a>.</p>
+ * For an overview of Unicode strings in C and C++ see the
+ * [User Guide Strings chapter](http://userguide.icu-project.org/strings#TOC-Strings-in-C-C-).
  *
- * <p>In ICU, a Unicode string consists of 16-bit Unicode <em>code units</em>.
+ * In ICU, a Unicode string consists of 16-bit Unicode *code units*.
  * A Unicode character may be stored with either one code unit
  * (the most common case) or with a matched pair of special code units
  * ("surrogates"). The data type for code units is char16_t.
- * For single-character handling, a Unicode character code <em>point</em> is a value
- * in the range 0..0x10ffff. ICU uses the UChar32 type for code points.</p>
+ * For single-character handling, a Unicode character code *point* is a value
+ * in the range 0..0x10ffff. ICU uses the UChar32 type for code points.
  *
- * <p>Indexes and offsets into and lengths of strings always count code units, not code points.
+ * Indexes and offsets into and lengths of strings always count code units, not code points.
  * This is the same as with multi-byte char* strings in traditional string handling.
  * Operations on partial strings typically do not test for code point boundaries.
  * If necessary, the user needs to take care of such boundaries by testing for the code unit
  * values or by using functions like
  * UnicodeString::getChar32Start() and UnicodeString::getChar32Limit()
- * (or, in C, the equivalent macros U16_SET_CP_START() and U16_SET_CP_LIMIT(), see utf.h).</p>
+ * (or, in C, the equivalent macros U16_SET_CP_START() and U16_SET_CP_LIMIT(), see utf.h).
  *
  * UnicodeString methods are more lenient with regard to input parameter values
  * than other ICU APIs. In particular:
  * - If indexes are out of bounds for a UnicodeString object
- *   (<0 or >length()) then they are "pinned" to the nearest boundary.
+ *   (< 0 or > length()) then they are "pinned" to the nearest boundary.
+ * - If the buffer passed to an insert/append/replace operation is owned by the
+ *   target object, e.g., calling str.append(str), an extra copy may take place
+ *   to ensure safety.
  * - If primitive string pointer values (e.g., const char16_t * or char *)
  *   for input strings are NULL, then those input string parameters are treated
  *   as if they pointed to an empty string.
- *   However, this is <em>not</em> the case for char * parameters for charset names
+ *   However, this is *not* the case for char * parameters for charset names
  *   or other IDs.
  * - Most UnicodeString methods do not take a UErrorCode parameter because
  *   there are usually very few opportunities for failure other than a shortage
  *   of memory, error codes in low-level C++ string methods would be inconvenient,
  *   and the error code as the last parameter (ICU convention) would prevent
@@ -268,18 +271,18 @@
  * Similarly, const UnicodeString & parameters are thread-safe.
  * One object may be passed in as such a parameter concurrently in multiple threads.
  * This includes the const UnicodeString & parameters for
  * copy construction, assignment, and cloning.
  *
- * <p>UnicodeString uses several storage methods.
+ * UnicodeString uses several storage methods.
  * String contents can be stored inside the UnicodeString object itself,
  * in an allocated and shared buffer, or in an outside buffer that is "aliased".
  * Most of this is done transparently, but careful aliasing in particular provides
  * significant performance improvements.
  * Also, the internal buffer is accessible via special functions.
  * For details see the
- * <a href="http://userguide.icu-project.org/strings#TOC-Maximizing-Performance-with-the-UnicodeString-Storage-Model">User Guide Strings chapter</a>.</p>
+ * [User Guide Strings chapter](http://userguide.icu-project.org/strings#TOC-Maximizing-Performance-with-the-UnicodeString-Storage-Model).
  *
  * @see utf.h
  * @see CharacterIterator
  * @stable ICU 2.0
  */
@@ -310,187 +313,187 @@
   /* Comparison - bitwise only - for international comparison use collation */
 
   /**
    * Equality operator. Performs only bitwise comparison.
    * @param text The UnicodeString to compare to this one.
-   * @return TRUE if <TT>text</TT> contains the same characters as this one,
+   * @return TRUE if `text` contains the same characters as this one,
    * FALSE otherwise.
    * @stable ICU 2.0
    */
   inline UBool operator== (const UnicodeString& text) const;
 
   /**
    * Inequality operator. Performs only bitwise comparison.
    * @param text The UnicodeString to compare to this one.
-   * @return FALSE if <TT>text</TT> contains the same characters as this one,
+   * @return FALSE if `text` contains the same characters as this one,
    * TRUE otherwise.
    * @stable ICU 2.0
    */
   inline UBool operator!= (const UnicodeString& text) const;
 
   /**
    * Greater than operator. Performs only bitwise comparison.
    * @param text The UnicodeString to compare to this one.
    * @return TRUE if the characters in this are bitwise
-   * greater than the characters in <code>text</code>, FALSE otherwise
+   * greater than the characters in `text`, FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool operator> (const UnicodeString& text) const;
 
   /**
    * Less than operator. Performs only bitwise comparison.
    * @param text The UnicodeString to compare to this one.
    * @return TRUE if the characters in this are bitwise
-   * less than the characters in <code>text</code>, FALSE otherwise
+   * less than the characters in `text`, FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool operator< (const UnicodeString& text) const;
 
   /**
    * Greater than or equal operator. Performs only bitwise comparison.
    * @param text The UnicodeString to compare to this one.
    * @return TRUE if the characters in this are bitwise
-   * greater than or equal to the characters in <code>text</code>, FALSE otherwise
+   * greater than or equal to the characters in `text`, FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool operator>= (const UnicodeString& text) const;
 
   /**
    * Less than or equal operator. Performs only bitwise comparison.
    * @param text The UnicodeString to compare to this one.
    * @return TRUE if the characters in this are bitwise
-   * less than or equal to the characters in <code>text</code>, FALSE otherwise
+   * less than or equal to the characters in `text`, FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool operator<= (const UnicodeString& text) const;
 
   /**
    * Compare the characters bitwise in this UnicodeString to
-   * the characters in <code>text</code>.
+   * the characters in `text`.
    * @param text The UnicodeString to compare to this one.
    * @return The result of bitwise character comparison: 0 if this
-   * contains the same characters as <code>text</code>, -1 if the characters in
-   * this are bitwise less than the characters in <code>text</code>, +1 if the
+   * contains the same characters as `text`, -1 if the characters in
+   * this are bitwise less than the characters in `text`, +1 if the
    * characters in this are bitwise greater than the characters
-   * in <code>text</code>.
+   * in `text`.
    * @stable ICU 2.0
    */
   inline int8_t compare(const UnicodeString& text) const;
 
   /**
    * Compare the characters bitwise in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) with the characters
-   * in the <b>entire string</b> <TT>text</TT>.
+   * [`start`, `start + length`) with the characters
+   * in the **entire string** `text`.
    * (The parameters "start" and "length" are not applied to the other text "text".)
    * @param start the offset at which the compare operation begins
    * @param length the number of characters of text to compare.
    * @param text the other text to be compared against this string.
    * @return The result of bitwise character comparison: 0 if this
-   * contains the same characters as <code>text</code>, -1 if the characters in
-   * this are bitwise less than the characters in <code>text</code>, +1 if the
+   * contains the same characters as `text`, -1 if the characters in
+   * this are bitwise less than the characters in `text`, +1 if the
    * characters in this are bitwise greater than the characters
-   * in <code>text</code>.
+   * in `text`.
    * @stable ICU 2.0
    */
   inline int8_t compare(int32_t start,
          int32_t length,
          const UnicodeString& text) const;
 
   /**
    * Compare the characters bitwise in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) with the characters
-   * in <TT>srcText</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>).
+   * [`start`, `start + length`) with the characters
+   * in `srcText` in the range
+   * [`srcStart`, `srcStart + srcLength`).
    * @param start the offset at which the compare operation begins
    * @param length the number of characters in this to compare.
    * @param srcText the text to be compared
-   * @param srcStart the offset into <TT>srcText</TT> to start comparison
-   * @param srcLength the number of characters in <TT>src</TT> to compare
+   * @param srcStart the offset into `srcText` to start comparison
+   * @param srcLength the number of characters in `src` to compare
    * @return The result of bitwise character comparison: 0 if this
-   * contains the same characters as <code>srcText</code>, -1 if the characters in
-   * this are bitwise less than the characters in <code>srcText</code>, +1 if the
+   * contains the same characters as `srcText`, -1 if the characters in
+   * this are bitwise less than the characters in `srcText`, +1 if the
    * characters in this are bitwise greater than the characters
-   * in <code>srcText</code>.
+   * in `srcText`.
    * @stable ICU 2.0
    */
    inline int8_t compare(int32_t start,
          int32_t length,
          const UnicodeString& srcText,
          int32_t srcStart,
          int32_t srcLength) const;
 
   /**
    * Compare the characters bitwise in this UnicodeString with the first
-   * <TT>srcLength</TT> characters in <TT>srcChars</TT>.
+   * `srcLength` characters in `srcChars`.
    * @param srcChars The characters to compare to this UnicodeString.
-   * @param srcLength the number of characters in <TT>srcChars</TT> to compare
+   * @param srcLength the number of characters in `srcChars` to compare
    * @return The result of bitwise character comparison: 0 if this
-   * contains the same characters as <code>srcChars</code>, -1 if the characters in
-   * this are bitwise less than the characters in <code>srcChars</code>, +1 if the
+   * contains the same characters as `srcChars`, -1 if the characters in
+   * this are bitwise less than the characters in `srcChars`, +1 if the
    * characters in this are bitwise greater than the characters
-   * in <code>srcChars</code>.
+   * in `srcChars`.
    * @stable ICU 2.0
    */
   inline int8_t compare(ConstChar16Ptr srcChars,
          int32_t srcLength) const;
 
   /**
    * Compare the characters bitwise in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) with the first
-   * <TT>length</TT> characters in <TT>srcChars</TT>
+   * [`start`, `start + length`) with the first
+   * `length` characters in `srcChars`
    * @param start the offset at which the compare operation begins
    * @param length the number of characters to compare.
    * @param srcChars the characters to be compared
    * @return The result of bitwise character comparison: 0 if this
-   * contains the same characters as <code>srcChars</code>, -1 if the characters in
-   * this are bitwise less than the characters in <code>srcChars</code>, +1 if the
+   * contains the same characters as `srcChars`, -1 if the characters in
+   * this are bitwise less than the characters in `srcChars`, +1 if the
    * characters in this are bitwise greater than the characters
-   * in <code>srcChars</code>.
+   * in `srcChars`.
    * @stable ICU 2.0
    */
   inline int8_t compare(int32_t start,
          int32_t length,
          const char16_t *srcChars) const;
 
   /**
    * Compare the characters bitwise in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) with the characters
-   * in <TT>srcChars</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>).
+   * [`start`, `start + length`) with the characters
+   * in `srcChars` in the range
+   * [`srcStart`, `srcStart + srcLength`).
    * @param start the offset at which the compare operation begins
    * @param length the number of characters in this to compare
    * @param srcChars the characters to be compared
-   * @param srcStart the offset into <TT>srcChars</TT> to start comparison
-   * @param srcLength the number of characters in <TT>srcChars</TT> to compare
+   * @param srcStart the offset into `srcChars` to start comparison
+   * @param srcLength the number of characters in `srcChars` to compare
    * @return The result of bitwise character comparison: 0 if this
-   * contains the same characters as <code>srcChars</code>, -1 if the characters in
-   * this are bitwise less than the characters in <code>srcChars</code>, +1 if the
+   * contains the same characters as `srcChars`, -1 if the characters in
+   * this are bitwise less than the characters in `srcChars`, +1 if the
    * characters in this are bitwise greater than the characters
-   * in <code>srcChars</code>.
+   * in `srcChars`.
    * @stable ICU 2.0
    */
   inline int8_t compare(int32_t start,
          int32_t length,
          const char16_t *srcChars,
          int32_t srcStart,
          int32_t srcLength) const;
 
   /**
    * Compare the characters bitwise in the range
-   * [<TT>start</TT>, <TT>limit</TT>) with the characters
-   * in <TT>srcText</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcLimit</TT>).
+   * [`start`, `limit`) with the characters
+   * in `srcText` in the range
+   * [`srcStart`, `srcLimit`).
    * @param start the offset at which the compare operation begins
    * @param limit the offset immediately following the compare operation
    * @param srcText the text to be compared
-   * @param srcStart the offset into <TT>srcText</TT> to start comparison
-   * @param srcLimit the offset into <TT>srcText</TT> to limit comparison
+   * @param srcStart the offset into `srcText` to start comparison
+   * @param srcLimit the offset into `srcText` to limit comparison
    * @return The result of bitwise character comparison: 0 if this
-   * contains the same characters as <code>srcText</code>, -1 if the characters in
-   * this are bitwise less than the characters in <code>srcText</code>, +1 if the
+   * contains the same characters as `srcText`, -1 if the characters in
+   * this are bitwise less than the characters in `srcText`, +1 if the
    * characters in this are bitwise greater than the characters
-   * in <code>srcText</code>.
+   * in `srcText`.
    * @stable ICU 2.0
    */
   inline int8_t compareBetween(int32_t start,
             int32_t limit,
             const UnicodeString& srcText,
@@ -843,97 +846,97 @@
             int32_t srcStart,
             int32_t srcLimit,
             uint32_t options) const;
 
   /**
-   * Determine if this starts with the characters in <TT>text</TT>
+   * Determine if this starts with the characters in `text`
    * @param text The text to match.
-   * @return TRUE if this starts with the characters in <TT>text</TT>,
+   * @return TRUE if this starts with the characters in `text`,
    * FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool startsWith(const UnicodeString& text) const;
 
   /**
-   * Determine if this starts with the characters in <TT>srcText</TT>
-   * in the range [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>).
+   * Determine if this starts with the characters in `srcText`
+   * in the range [`srcStart`, `srcStart + srcLength`).
    * @param srcText The text to match.
-   * @param srcStart the offset into <TT>srcText</TT> to start matching
-   * @param srcLength the number of characters in <TT>srcText</TT> to match
-   * @return TRUE if this starts with the characters in <TT>text</TT>,
+   * @param srcStart the offset into `srcText` to start matching
+   * @param srcLength the number of characters in `srcText` to match
+   * @return TRUE if this starts with the characters in `text`,
    * FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool startsWith(const UnicodeString& srcText,
             int32_t srcStart,
             int32_t srcLength) const;
 
   /**
-   * Determine if this starts with the characters in <TT>srcChars</TT>
+   * Determine if this starts with the characters in `srcChars`
    * @param srcChars The characters to match.
-   * @param srcLength the number of characters in <TT>srcChars</TT>
-   * @return TRUE if this starts with the characters in <TT>srcChars</TT>,
+   * @param srcLength the number of characters in `srcChars`
+   * @return TRUE if this starts with the characters in `srcChars`,
    * FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool startsWith(ConstChar16Ptr srcChars,
             int32_t srcLength) const;
 
   /**
-   * Determine if this ends with the characters in <TT>srcChars</TT>
-   * in the range  [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>).
+   * Determine if this ends with the characters in `srcChars`
+   * in the range  [`srcStart`, `srcStart + srcLength`).
    * @param srcChars The characters to match.
-   * @param srcStart the offset into <TT>srcText</TT> to start matching
-   * @param srcLength the number of characters in <TT>srcChars</TT> to match
-   * @return TRUE if this ends with the characters in <TT>srcChars</TT>, FALSE otherwise
+   * @param srcStart the offset into `srcText` to start matching
+   * @param srcLength the number of characters in `srcChars` to match
+   * @return TRUE if this ends with the characters in `srcChars`, FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool startsWith(const char16_t *srcChars,
             int32_t srcStart,
             int32_t srcLength) const;
 
   /**
-   * Determine if this ends with the characters in <TT>text</TT>
+   * Determine if this ends with the characters in `text`
    * @param text The text to match.
-   * @return TRUE if this ends with the characters in <TT>text</TT>,
+   * @return TRUE if this ends with the characters in `text`,
    * FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool endsWith(const UnicodeString& text) const;
 
   /**
-   * Determine if this ends with the characters in <TT>srcText</TT>
-   * in the range [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>).
+   * Determine if this ends with the characters in `srcText`
+   * in the range [`srcStart`, `srcStart + srcLength`).
    * @param srcText The text to match.
-   * @param srcStart the offset into <TT>srcText</TT> to start matching
-   * @param srcLength the number of characters in <TT>srcText</TT> to match
-   * @return TRUE if this ends with the characters in <TT>text</TT>,
+   * @param srcStart the offset into `srcText` to start matching
+   * @param srcLength the number of characters in `srcText` to match
+   * @return TRUE if this ends with the characters in `text`,
    * FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool endsWith(const UnicodeString& srcText,
           int32_t srcStart,
           int32_t srcLength) const;
 
   /**
-   * Determine if this ends with the characters in <TT>srcChars</TT>
+   * Determine if this ends with the characters in `srcChars`
    * @param srcChars The characters to match.
-   * @param srcLength the number of characters in <TT>srcChars</TT>
-   * @return TRUE if this ends with the characters in <TT>srcChars</TT>,
+   * @param srcLength the number of characters in `srcChars`
+   * @return TRUE if this ends with the characters in `srcChars`,
    * FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool endsWith(ConstChar16Ptr srcChars,
           int32_t srcLength) const;
 
   /**
-   * Determine if this ends with the characters in <TT>srcChars</TT>
-   * in the range  [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>).
+   * Determine if this ends with the characters in `srcChars`
+   * in the range  [`srcStart`, `srcStart + srcLength`).
    * @param srcChars The characters to match.
-   * @param srcStart the offset into <TT>srcText</TT> to start matching
-   * @param srcLength the number of characters in <TT>srcChars</TT> to match
-   * @return TRUE if this ends with the characters in <TT>srcChars</TT>,
+   * @param srcStart the offset into `srcText` to start matching
+   * @param srcLength the number of characters in `srcChars` to match
+   * @return TRUE if this ends with the characters in `srcChars`,
    * FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool endsWith(const char16_t *srcChars,
           int32_t srcStart,
@@ -941,59 +944,59 @@
 
 
   /* Searching - bitwise only */
 
   /**
-   * Locate in this the first occurrence of the characters in <TT>text</TT>,
+   * Locate in this the first occurrence of the characters in `text`,
    * using bitwise comparison.
    * @param text The text to search for.
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(const UnicodeString& text) const;
 
   /**
-   * Locate in this the first occurrence of the characters in <TT>text</TT>
-   * starting at offset <TT>start</TT>, using bitwise comparison.
+   * Locate in this the first occurrence of the characters in `text`
+   * starting at offset `start`, using bitwise comparison.
    * @param text The text to search for.
    * @param start The offset at which searching will start.
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(const UnicodeString& text,
               int32_t start) const;
 
   /**
    * Locate in this the first occurrence in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) of the characters
-   * in <TT>text</TT>, using bitwise comparison.
+   * [`start`, `start + length`) of the characters
+   * in `text`, using bitwise comparison.
    * @param text The text to search for.
    * @param start The offset at which searching will start.
    * @param length The number of characters to search
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(const UnicodeString& text,
               int32_t start,
               int32_t length) const;
 
   /**
    * Locate in this the first occurrence in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) of the characters
-   *  in <TT>srcText</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>),
+   * [`start`, `start + length`) of the characters
+   *  in `srcText` in the range
+   * [`srcStart`, `srcStart + srcLength`),
    * using bitwise comparison.
    * @param srcText The text to search for.
-   * @param srcStart the offset into <TT>srcText</TT> at which
+   * @param srcStart the offset into `srcText` at which
    * to start matching
-   * @param srcLength the number of characters in <TT>srcText</TT> to match
+   * @param srcLength the number of characters in `srcText` to match
    * @param start the offset into this at which to start matching
    * @param length the number of characters in this to search
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(const UnicodeString& srcText,
               int32_t srcStart,
@@ -1001,346 +1004,346 @@
               int32_t start,
               int32_t length) const;
 
   /**
    * Locate in this the first occurrence of the characters in
-   * <TT>srcChars</TT>
-   * starting at offset <TT>start</TT>, using bitwise comparison.
+   * `srcChars`
+   * starting at offset `start`, using bitwise comparison.
    * @param srcChars The text to search for.
-   * @param srcLength the number of characters in <TT>srcChars</TT> to match
+   * @param srcLength the number of characters in `srcChars` to match
    * @param start the offset into this at which to start matching
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(const char16_t *srcChars,
               int32_t srcLength,
               int32_t start) const;
 
   /**
    * Locate in this the first occurrence in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) of the characters
-   * in <TT>srcChars</TT>, using bitwise comparison.
+   * [`start`, `start + length`) of the characters
+   * in `srcChars`, using bitwise comparison.
    * @param srcChars The text to search for.
-   * @param srcLength the number of characters in <TT>srcChars</TT>
+   * @param srcLength the number of characters in `srcChars`
    * @param start The offset at which searching will start.
    * @param length The number of characters to search
-   * @return The offset into this of the start of <TT>srcChars</TT>,
+   * @return The offset into this of the start of `srcChars`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(ConstChar16Ptr srcChars,
               int32_t srcLength,
               int32_t start,
               int32_t length) const;
 
   /**
    * Locate in this the first occurrence in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) of the characters
-   * in <TT>srcChars</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>),
+   * [`start`, `start + length`) of the characters
+   * in `srcChars` in the range
+   * [`srcStart`, `srcStart + srcLength`),
    * using bitwise comparison.
    * @param srcChars The text to search for.
-   * @param srcStart the offset into <TT>srcChars</TT> at which
+   * @param srcStart the offset into `srcChars` at which
    * to start matching
-   * @param srcLength the number of characters in <TT>srcChars</TT> to match
+   * @param srcLength the number of characters in `srcChars` to match
    * @param start the offset into this at which to start matching
    * @param length the number of characters in this to search
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   int32_t indexOf(const char16_t *srcChars,
               int32_t srcStart,
               int32_t srcLength,
               int32_t start,
               int32_t length) const;
 
   /**
-   * Locate in this the first occurrence of the BMP code point <code>c</code>,
+   * Locate in this the first occurrence of the BMP code point `c`,
    * using bitwise comparison.
    * @param c The code unit to search for.
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(char16_t c) const;
 
   /**
-   * Locate in this the first occurrence of the code point <TT>c</TT>,
+   * Locate in this the first occurrence of the code point `c`,
    * using bitwise comparison.
    *
    * @param c The code point to search for.
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(UChar32 c) const;
 
   /**
-   * Locate in this the first occurrence of the BMP code point <code>c</code>,
-   * starting at offset <TT>start</TT>, using bitwise comparison.
+   * Locate in this the first occurrence of the BMP code point `c`,
+   * starting at offset `start`, using bitwise comparison.
    * @param c The code unit to search for.
    * @param start The offset at which searching will start.
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(char16_t c,
               int32_t start) const;
 
   /**
-   * Locate in this the first occurrence of the code point <TT>c</TT>
-   * starting at offset <TT>start</TT>, using bitwise comparison.
+   * Locate in this the first occurrence of the code point `c`
+   * starting at offset `start`, using bitwise comparison.
    *
    * @param c The code point to search for.
    * @param start The offset at which searching will start.
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(UChar32 c,
               int32_t start) const;
 
   /**
-   * Locate in this the first occurrence of the BMP code point <code>c</code>
-   * in the range [<TT>start</TT>, <TT>start + length</TT>),
+   * Locate in this the first occurrence of the BMP code point `c`
+   * in the range [`start`, `start + length`),
    * using bitwise comparison.
    * @param c The code unit to search for.
    * @param start the offset into this at which to start matching
    * @param length the number of characters in this to search
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(char16_t c,
               int32_t start,
               int32_t length) const;
 
   /**
-   * Locate in this the first occurrence of the code point <TT>c</TT>
-   * in the range [<TT>start</TT>, <TT>start + length</TT>),
+   * Locate in this the first occurrence of the code point `c`
+   * in the range [`start`, `start + length`),
    * using bitwise comparison.
    *
    * @param c The code point to search for.
    * @param start the offset into this at which to start matching
    * @param length the number of characters in this to search
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t indexOf(UChar32 c,
               int32_t start,
               int32_t length) const;
 
   /**
-   * Locate in this the last occurrence of the characters in <TT>text</TT>,
+   * Locate in this the last occurrence of the characters in `text`,
    * using bitwise comparison.
    * @param text The text to search for.
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(const UnicodeString& text) const;
 
   /**
-   * Locate in this the last occurrence of the characters in <TT>text</TT>
-   * starting at offset <TT>start</TT>, using bitwise comparison.
+   * Locate in this the last occurrence of the characters in `text`
+   * starting at offset `start`, using bitwise comparison.
    * @param text The text to search for.
    * @param start The offset at which searching will start.
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(const UnicodeString& text,
               int32_t start) const;
 
   /**
    * Locate in this the last occurrence in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) of the characters
-   * in <TT>text</TT>, using bitwise comparison.
+   * [`start`, `start + length`) of the characters
+   * in `text`, using bitwise comparison.
    * @param text The text to search for.
    * @param start The offset at which searching will start.
    * @param length The number of characters to search
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(const UnicodeString& text,
               int32_t start,
               int32_t length) const;
 
   /**
    * Locate in this the last occurrence in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) of the characters
-   * in <TT>srcText</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>),
+   * [`start`, `start + length`) of the characters
+   * in `srcText` in the range
+   * [`srcStart`, `srcStart + srcLength`),
    * using bitwise comparison.
    * @param srcText The text to search for.
-   * @param srcStart the offset into <TT>srcText</TT> at which
+   * @param srcStart the offset into `srcText` at which
    * to start matching
-   * @param srcLength the number of characters in <TT>srcText</TT> to match
+   * @param srcLength the number of characters in `srcText` to match
    * @param start the offset into this at which to start matching
    * @param length the number of characters in this to search
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(const UnicodeString& srcText,
               int32_t srcStart,
               int32_t srcLength,
               int32_t start,
               int32_t length) const;
 
   /**
-   * Locate in this the last occurrence of the characters in <TT>srcChars</TT>
-   * starting at offset <TT>start</TT>, using bitwise comparison.
+   * Locate in this the last occurrence of the characters in `srcChars`
+   * starting at offset `start`, using bitwise comparison.
    * @param srcChars The text to search for.
-   * @param srcLength the number of characters in <TT>srcChars</TT> to match
+   * @param srcLength the number of characters in `srcChars` to match
    * @param start the offset into this at which to start matching
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(const char16_t *srcChars,
               int32_t srcLength,
               int32_t start) const;
 
   /**
    * Locate in this the last occurrence in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) of the characters
-   * in <TT>srcChars</TT>, using bitwise comparison.
+   * [`start`, `start + length`) of the characters
+   * in `srcChars`, using bitwise comparison.
    * @param srcChars The text to search for.
-   * @param srcLength the number of characters in <TT>srcChars</TT>
+   * @param srcLength the number of characters in `srcChars`
    * @param start The offset at which searching will start.
    * @param length The number of characters to search
-   * @return The offset into this of the start of <TT>srcChars</TT>,
+   * @return The offset into this of the start of `srcChars`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(ConstChar16Ptr srcChars,
               int32_t srcLength,
               int32_t start,
               int32_t length) const;
 
   /**
    * Locate in this the last occurrence in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) of the characters
-   * in <TT>srcChars</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>),
+   * [`start`, `start + length`) of the characters
+   * in `srcChars` in the range
+   * [`srcStart`, `srcStart + srcLength`),
    * using bitwise comparison.
    * @param srcChars The text to search for.
-   * @param srcStart the offset into <TT>srcChars</TT> at which
+   * @param srcStart the offset into `srcChars` at which
    * to start matching
-   * @param srcLength the number of characters in <TT>srcChars</TT> to match
+   * @param srcLength the number of characters in `srcChars` to match
    * @param start the offset into this at which to start matching
    * @param length the number of characters in this to search
-   * @return The offset into this of the start of <TT>text</TT>,
+   * @return The offset into this of the start of `text`,
    * or -1 if not found.
    * @stable ICU 2.0
    */
   int32_t lastIndexOf(const char16_t *srcChars,
               int32_t srcStart,
               int32_t srcLength,
               int32_t start,
               int32_t length) const;
 
   /**
-   * Locate in this the last occurrence of the BMP code point <code>c</code>,
+   * Locate in this the last occurrence of the BMP code point `c`,
    * using bitwise comparison.
    * @param c The code unit to search for.
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(char16_t c) const;
 
   /**
-   * Locate in this the last occurrence of the code point <TT>c</TT>,
+   * Locate in this the last occurrence of the code point `c`,
    * using bitwise comparison.
    *
    * @param c The code point to search for.
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(UChar32 c) const;
 
   /**
-   * Locate in this the last occurrence of the BMP code point <code>c</code>
-   * starting at offset <TT>start</TT>, using bitwise comparison.
+   * Locate in this the last occurrence of the BMP code point `c`
+   * starting at offset `start`, using bitwise comparison.
    * @param c The code unit to search for.
    * @param start The offset at which searching will start.
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(char16_t c,
               int32_t start) const;
 
   /**
-   * Locate in this the last occurrence of the code point <TT>c</TT>
-   * starting at offset <TT>start</TT>, using bitwise comparison.
+   * Locate in this the last occurrence of the code point `c`
+   * starting at offset `start`, using bitwise comparison.
    *
    * @param c The code point to search for.
    * @param start The offset at which searching will start.
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(UChar32 c,
               int32_t start) const;
 
   /**
-   * Locate in this the last occurrence of the BMP code point <code>c</code>
-   * in the range [<TT>start</TT>, <TT>start + length</TT>),
+   * Locate in this the last occurrence of the BMP code point `c`
+   * in the range [`start`, `start + length`),
    * using bitwise comparison.
    * @param c The code unit to search for.
    * @param start the offset into this at which to start matching
    * @param length the number of characters in this to search
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(char16_t c,
               int32_t start,
               int32_t length) const;
 
   /**
-   * Locate in this the last occurrence of the code point <TT>c</TT>
-   * in the range [<TT>start</TT>, <TT>start + length</TT>),
+   * Locate in this the last occurrence of the code point `c`
+   * in the range [`start`, `start + length`),
    * using bitwise comparison.
    *
    * @param c The code point to search for.
    * @param start the offset into this at which to start matching
    * @param length the number of characters in this to search
-   * @return The offset into this of <TT>c</TT>, or -1 if not found.
+   * @return The offset into this of `c`, or -1 if not found.
    * @stable ICU 2.0
    */
   inline int32_t lastIndexOf(UChar32 c,
               int32_t start,
               int32_t length) const;
 
 
   /* Character access */
 
   /**
-   * Return the code unit at offset <tt>offset</tt>.
+   * Return the code unit at offset `offset`.
    * If the offset is not valid (0..length()-1) then U+ffff is returned.
    * @param offset a valid offset into the text
-   * @return the code unit at offset <tt>offset</tt>
+   * @return the code unit at offset `offset`
    *         or 0xffff if the offset is not valid for this string
    * @stable ICU 2.0
    */
   inline char16_t charAt(int32_t offset) const;
 
   /**
-   * Return the code unit at offset <tt>offset</tt>.
+   * Return the code unit at offset `offset`.
    * If the offset is not valid (0..length()-1) then U+ffff is returned.
    * @param offset a valid offset into the text
-   * @return the code unit at offset <tt>offset</tt>
+   * @return the code unit at offset `offset`
    * @stable ICU 2.0
    */
   inline char16_t operator[] (int32_t offset) const;
 
   /**
    * Return the code point that contains the code unit
-   * at offset <tt>offset</tt>.
+   * at offset `offset`.
    * If the offset is not valid (0..length()-1) then U+ffff is returned.
    * @param offset a valid offset into the text
    * that indicates the text offset of any of the code units
    * that will be assembled into a code point (21-bit value) and returned
-   * @return the code point of text at <tt>offset</tt>
+   * @return the code point of text at `offset`
    *         or 0xffff if the offset is not valid for this string
    * @stable ICU 2.0
    */
   UChar32 char32At(int32_t offset) const;
 
@@ -1393,37 +1396,37 @@
    * If delta>0 then the index is moved forward (toward the end of the string).
    *
    * This behaves like CharacterIterator::move32(delta, kCurrent).
    *
    * Behavior for out-of-bounds indexes:
-   * <code>moveIndex32</code> pins the input index to 0..length(), i.e.,
+   * `moveIndex32` pins the input index to 0..length(), i.e.,
    * if the input index<0 then it is pinned to 0;
    * if it is index>length() then it is pinned to length().
-   * Afterwards, the index is moved by <code>delta</code> code points
+   * Afterwards, the index is moved by `delta` code points
    * forward or backward,
    * but no further backward than to 0 and no further forward than to length().
    * The resulting index return value will be in between 0 and length(), inclusively.
    *
    * Examples:
-   * <pre>
-   * // s has code points 'a' U+10000 'b' U+10ffff U+2029
-   * UnicodeString s=UNICODE_STRING("a\\U00010000b\\U0010ffff\\u2029", 31).unescape();
+   * \code
+   *     // s has code points 'a' U+10000 'b' U+10ffff U+2029
+   *     UnicodeString s(u"a\U00010000b\U0010ffff\u2029");
    *
-   * // initial index: position of U+10000
-   * int32_t index=1;
+   *     // initial index: position of U+10000
+   *     int32_t index=1;
    *
-   * // the following examples will all result in index==4, position of U+10ffff
+   *     // the following examples will all result in index==4, position of U+10ffff
    *
-   * // skip 2 code points from some position in the string
-   * index=s.moveIndex32(index, 2); // skips U+10000 and 'b'
+   *     // skip 2 code points from some position in the string
+   *     index=s.moveIndex32(index, 2); // skips U+10000 and 'b'
    *
-   * // go to the 3rd code point from the start of s (0-based)
-   * index=s.moveIndex32(0, 3); // skips 'a', U+10000, and 'b'
+   *     // go to the 3rd code point from the start of s (0-based)
+   *     index=s.moveIndex32(0, 3); // skips 'a', U+10000, and 'b'
    *
-   * // go to the next-to-last code point of s
-   * index=s.moveIndex32(s.length(), -2); // backward-skips U+2029 and U+10ffff
-   * </pre>
+   *     // go to the next-to-last code point of s
+   *     index=s.moveIndex32(s.length(), -2); // backward-skips U+2029 and U+10ffff
+   * \endcode
    *
    * @param index input code unit index
    * @param delta (signed) code point count to move the index forward or backward
    *        in the string
    * @return the resulting code unit index
@@ -1433,20 +1436,20 @@
 
   /* Substring extraction */
 
   /**
    * Copy the characters in the range
-   * [<tt>start</tt>, <tt>start + length</tt>) into the array <tt>dst</tt>,
-   * beginning at <tt>dstStart</tt>.
-   * If the string aliases to <code>dst</code> itself as an external buffer,
+   * [`start`, `start + length`) into the array `dst`,
+   * beginning at `dstStart`.
+   * If the string aliases to `dst` itself as an external buffer,
    * then extract() will not copy the contents.
    *
    * @param start offset of first character which will be copied into the array
    * @param length the number of characters to extract
-   * @param dst array in which to copy characters.  The length of <tt>dst</tt>
-   * must be at least (<tt>dstStart + length</tt>).
-   * @param dstStart the offset in <TT>dst</TT> where the first character
+   * @param dst array in which to copy characters.  The length of `dst`
+   * must be at least (`dstStart + length`).
+   * @param dstStart the offset in `dst` where the first character
    * will be extracted
    * @stable ICU 2.0
    */
   inline void extract(int32_t start,
            int32_t length,
@@ -1463,11 +1466,11 @@
    * If the string fits into dest but cannot be NUL-terminated
    * (length()==destCapacity) then the error code is set to U_STRING_NOT_TERMINATED_WARNING.
    * If the string itself does not fit into dest
    * (length()>destCapacity) then the error code is set to U_BUFFER_OVERFLOW_ERROR.
    *
-   * If the string aliases to <code>dest</code> itself as an external buffer,
+   * If the string aliases to `dest` itself as an external buffer,
    * then extract() will not copy the contents.
    *
    * @param dest Destination string buffer.
    * @param destCapacity Number of char16_ts available at dest.
    * @param errorCode ICU error code.
@@ -1478,58 +1481,56 @@
   extract(Char16Ptr dest, int32_t destCapacity,
           UErrorCode &errorCode) const;
 
   /**
    * Copy the characters in the range
-   * [<tt>start</tt>, <tt>start + length</tt>) into the  UnicodeString
-   * <tt>target</tt>.
+   * [`start`, `start + length`) into the  UnicodeString
+   * `target`.
    * @param start offset of first character which will be copied
    * @param length the number of characters to extract
    * @param target UnicodeString into which to copy characters.
-   * @return A reference to <TT>target</TT>
    * @stable ICU 2.0
    */
   inline void extract(int32_t start,
            int32_t length,
            UnicodeString& target) const;
 
   /**
-   * Copy the characters in the range [<tt>start</tt>, <tt>limit</tt>)
-   * into the array <tt>dst</tt>, beginning at <tt>dstStart</tt>.
+   * Copy the characters in the range [`start`, `limit`)
+   * into the array `dst`, beginning at `dstStart`.
    * @param start offset of first character which will be copied into the array
    * @param limit offset immediately following the last character to be copied
-   * @param dst array in which to copy characters.  The length of <tt>dst</tt>
-   * must be at least (<tt>dstStart + (limit - start)</tt>).
-   * @param dstStart the offset in <TT>dst</TT> where the first character
+   * @param dst array in which to copy characters.  The length of `dst`
+   * must be at least (`dstStart + (limit - start)`).
+   * @param dstStart the offset in `dst` where the first character
    * will be extracted
    * @stable ICU 2.0
    */
   inline void extractBetween(int32_t start,
               int32_t limit,
               char16_t *dst,
               int32_t dstStart = 0) const;
 
   /**
-   * Copy the characters in the range [<tt>start</tt>, <tt>limit</tt>)
-   * into the UnicodeString <tt>target</tt>.  Replaceable API.
+   * Copy the characters in the range [`start`, `limit`)
+   * into the UnicodeString `target`.  Replaceable API.
    * @param start offset of first character which will be copied
    * @param limit offset immediately following the last character to be copied
    * @param target UnicodeString into which to copy characters.
-   * @return A reference to <TT>target</TT>
    * @stable ICU 2.0
    */
   virtual void extractBetween(int32_t start,
               int32_t limit,
               UnicodeString& target) const;
 
   /**
    * Copy the characters in the range
-   * [<tt>start</TT>, <tt>start + startLength</TT>) into an array of characters.
+   * [`start`, `start + startLength`) into an array of characters.
    * All characters must be invariant (see utypes.h).
    * Use US_INV as the last, signature-distinguishing parameter.
    *
-   * This function does not write any more than <code>targetCapacity</code>
+   * This function does not write any more than `targetCapacity`
    * characters but returns the length of the entire output string
    * so that one can allocate a larger buffer and call the function again
    * if necessary.
    * The output string is NUL-terminated if possible.
    *
@@ -1550,24 +1551,24 @@
 
 #if U_CHARSET_IS_UTF8 || !UCONFIG_NO_CONVERSION
 
   /**
    * Copy the characters in the range
-   * [<tt>start</TT>, <tt>start + length</TT>) into an array of characters
+   * [`start`, `start + length`) into an array of characters
    * in the platform's default codepage.
-   * This function does not write any more than <code>targetLength</code>
+   * This function does not write any more than `targetLength`
    * characters but returns the length of the entire output string
    * so that one can allocate a larger buffer and call the function again
    * if necessary.
    * The output string is NUL-terminated if possible.
    *
    * @param start offset of first character which will be copied
    * @param startLength the number of characters to extract
    * @param target the target buffer for extraction
    * @param targetLength the length of the target buffer
-   * If <TT>target</TT> is NULL, then the number of bytes required for
-   * <TT>target</TT> is returned.
+   * If `target` is NULL, then the number of bytes required for
+   * `target` is returned.
    * @return the output string length, not including the terminating NUL
    * @stable ICU 2.0
    */
   int32_t extract(int32_t start,
            int32_t startLength,
@@ -1578,11 +1579,11 @@
 
 #if !UCONFIG_NO_CONVERSION
 
   /**
    * Copy the characters in the range
-   * [<tt>start</TT>, <tt>start + length</TT>) into an array of characters
+   * [`start`, `start + length`) into an array of characters
    * in a specified codepage.
    * The output string is NUL-terminated.
    *
    * Recommendation: For invariant-character strings use
    * extract(int32_t start, int32_t length, char *target, int32_t targetCapacity, enum EInvariant inv) const
@@ -1592,15 +1593,15 @@
    * @param start offset of first character which will be copied
    * @param startLength the number of characters to extract
    * @param target the target buffer for extraction
    * @param codepage the desired codepage for the characters.  0 has
    * the special meaning of the default codepage
-   * If <code>codepage</code> is an empty string (<code>""</code>),
+   * If `codepage` is an empty string (`""`),
    * then a simple conversion is performed on the codepage-invariant
    * subset ("invariant characters") of the platform encoding. See utypes.h.
-   * If <TT>target</TT> is NULL, then the number of bytes required for
-   * <TT>target</TT> is returned. It is assumed that the target is big enough
+   * If `target` is NULL, then the number of bytes required for
+   * `target` is returned. It is assumed that the target is big enough
    * to fit all of the characters.
    * @return the output string length, not including the terminating NUL
    * @stable ICU 2.0
    */
   inline int32_t extract(int32_t start,
@@ -1608,13 +1609,13 @@
                  char *target,
                  const char *codepage = 0) const;
 
   /**
    * Copy the characters in the range
-   * [<tt>start</TT>, <tt>start + length</TT>) into an array of characters
+   * [`start`, `start + length`) into an array of characters
    * in a specified codepage.
-   * This function does not write any more than <code>targetLength</code>
+   * This function does not write any more than `targetLength`
    * characters but returns the length of the entire output string
    * so that one can allocate a larger buffer and call the function again
    * if necessary.
    * The output string is NUL-terminated if possible.
    *
@@ -1627,15 +1628,15 @@
    * @param startLength the number of characters to extract
    * @param target the target buffer for extraction
    * @param targetLength the length of the target buffer
    * @param codepage the desired codepage for the characters.  0 has
    * the special meaning of the default codepage
-   * If <code>codepage</code> is an empty string (<code>""</code>),
+   * If `codepage` is an empty string (`""`),
    * then a simple conversion is performed on the codepage-invariant
    * subset ("invariant characters") of the platform encoding. See utypes.h.
-   * If <TT>target</TT> is NULL, then the number of bytes required for
-   * <TT>target</TT> is returned.
+   * If `target` is NULL, then the number of bytes required for
+   * `target` is returned.
    * @return the output string length, not including the terminating NUL
    * @stable ICU 2.0
    */
   int32_t extract(int32_t start,
            int32_t startLength,
@@ -1844,11 +1845,11 @@
 
   /* Assignment operations */
 
   /**
    * Assignment operator.  Replace the characters in this UnicodeString
-   * with the characters from <TT>srcText</TT>.
+   * with the characters from `srcText`.
    *
    * Starting with ICU 2.4, the assignment operator and the copy constructor
    * allocate a new buffer and copy the buffer contents even for readonly aliases.
    * By contrast, the fastCopyFrom() function implements the old,
    * more efficient but less safe behavior
@@ -1865,11 +1866,11 @@
   UnicodeString &operator=(const UnicodeString &srcText);
 
   /**
    * Almost the same as the assignment operator.
    * Replace the characters in this UnicodeString
-   * with the characters from <code>srcText</code>.
+   * with the characters from `srcText`.
    *
    * This function works the same as the assignment operator
    * for all strings except for ones that are readonly aliases.
    *
    * Starting with ICU 2.4, the assignment operator and the copy constructor
@@ -1897,26 +1898,11 @@
    * The behavior is undefined if *this and src are the same object.
    * @param src source string
    * @return *this
    * @stable ICU 56
    */
-  UnicodeString &operator=(UnicodeString &&src) U_NOEXCEPT {
-    return moveFrom(src);
-  }
-
-  // do not use #ifndef U_HIDE_DRAFT_API for moveFrom, needed by non-draft API
-  /**
-   * Move assignment; might leave src in bogus state.
-   * This string will have the same contents and state that the source string had.
-   * The behavior is undefined if *this and src are the same object.
-   *
-   * Can be called explicitly, does not need C++11 support.
-   * @param src source string
-   * @return *this
-   * @draft ICU 56
-   */
-  UnicodeString &moveFrom(UnicodeString &src) U_NOEXCEPT;
+  UnicodeString &operator=(UnicodeString &&src) U_NOEXCEPT;
 
   /**
    * Swap strings.
    * @param other other string
    * @stable ICU 56
@@ -1927,104 +1913,104 @@
    * Non-member UnicodeString swap function.
    * @param s1 will get s2's contents and state
    * @param s2 will get s1's contents and state
    * @stable ICU 56
    */
-  friend U_COMMON_API inline void U_EXPORT2
+  friend inline void U_EXPORT2
   swap(UnicodeString &s1, UnicodeString &s2) U_NOEXCEPT {
     s1.swap(s2);
   }
 
   /**
    * Assignment operator.  Replace the characters in this UnicodeString
-   * with the code unit <TT>ch</TT>.
+   * with the code unit `ch`.
    * @param ch the code unit to replace
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& operator= (char16_t ch);
 
   /**
    * Assignment operator.  Replace the characters in this UnicodeString
-   * with the code point <TT>ch</TT>.
+   * with the code point `ch`.
    * @param ch the code point to replace
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& operator= (UChar32 ch);
 
   /**
    * Set the text in the UnicodeString object to the characters
-   * in <TT>srcText</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcText.length()</TT>).
-   * <TT>srcText</TT> is not modified.
+   * in `srcText` in the range
+   * [`srcStart`, `srcText.length()`).
+   * `srcText` is not modified.
    * @param srcText the source for the new characters
-   * @param srcStart the offset into <TT>srcText</TT> where new characters
+   * @param srcStart the offset into `srcText` where new characters
    * will be obtained
    * @return a reference to this
    * @stable ICU 2.2
    */
   inline UnicodeString& setTo(const UnicodeString& srcText,
                int32_t srcStart);
 
   /**
    * Set the text in the UnicodeString object to the characters
-   * in <TT>srcText</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>).
-   * <TT>srcText</TT> is not modified.
+   * in `srcText` in the range
+   * [`srcStart`, `srcStart + srcLength`).
+   * `srcText` is not modified.
    * @param srcText the source for the new characters
-   * @param srcStart the offset into <TT>srcText</TT> where new characters
+   * @param srcStart the offset into `srcText` where new characters
    * will be obtained
-   * @param srcLength the number of characters in <TT>srcText</TT> in the
+   * @param srcLength the number of characters in `srcText` in the
    * replace string.
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& setTo(const UnicodeString& srcText,
                int32_t srcStart,
                int32_t srcLength);
 
   /**
    * Set the text in the UnicodeString object to the characters in
-   * <TT>srcText</TT>.
-   * <TT>srcText</TT> is not modified.
+   * `srcText`.
+   * `srcText` is not modified.
    * @param srcText the source for the new characters
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& setTo(const UnicodeString& srcText);
 
   /**
    * Set the characters in the UnicodeString object to the characters
-   * in <TT>srcChars</TT>. <TT>srcChars</TT> is not modified.
+   * in `srcChars`. `srcChars` is not modified.
    * @param srcChars the source for the new characters
    * @param srcLength the number of Unicode characters in srcChars.
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& setTo(const char16_t *srcChars,
                int32_t srcLength);
 
   /**
    * Set the characters in the UnicodeString object to the code unit
-   * <TT>srcChar</TT>.
+   * `srcChar`.
    * @param srcChar the code unit which becomes the UnicodeString's character
    * content
    * @return a reference to this
    * @stable ICU 2.0
    */
-  UnicodeString& setTo(char16_t srcChar);
+  inline UnicodeString& setTo(char16_t srcChar);
 
   /**
    * Set the characters in the UnicodeString object to the code point
-   * <TT>srcChar</TT>.
+   * `srcChar`.
    * @param srcChar the code point which becomes the UnicodeString's character
    * content
    * @return a reference to this
    * @stable ICU 2.0
    */
-  UnicodeString& setTo(UChar32 srcChar);
+  inline UnicodeString& setTo(UChar32 srcChar);
 
   /**
    * Aliasing setTo() function, analogous to the readonly-aliasing char16_t* constructor.
    * The text will be used for the UnicodeString object, but
    * it will not be released when the UnicodeString is destroyed.
@@ -2036,16 +2022,16 @@
    * In an assignment to another UnicodeString, when using the copy constructor
    * or the assignment operator, the text will be copied.
    * When using fastCopyFrom(), the text will be aliased again,
    * so that both strings then alias the same readonly-text.
    *
-   * @param isTerminated specifies if <code>text</code> is <code>NUL</code>-terminated.
-   *                     This must be true if <code>textLength==-1</code>.
+   * @param isTerminated specifies if `text` is `NUL`-terminated.
+   *                     This must be true if `textLength==-1`.
    * @param text The characters to alias for the UnicodeString.
-   * @param textLength The number of Unicode characters in <code>text</code> to alias.
+   * @param textLength The number of Unicode characters in `text` to alias.
    *                   If -1, then this constructor will determine the length
-   *                   by calling <code>u_strlen()</code>.
+   *                   by calling `u_strlen()`.
    * @return a reference to this
    * @stable ICU 2.0
    */
   UnicodeString &setTo(UBool isTerminated,
                        ConstChar16Ptr text,
@@ -2063,12 +2049,12 @@
    * In an assignment to another UnicodeString, the buffer will be copied.
    * The extract(Char16Ptr dst) function detects whether the dst pointer is the same
    * as the string buffer itself and will in this case not copy the contents.
    *
    * @param buffer The characters to alias for the UnicodeString.
-   * @param buffLength The number of Unicode characters in <code>buffer</code> to alias.
-   * @param buffCapacity The size of <code>buffer</code> in char16_ts.
+   * @param buffLength The number of Unicode characters in `buffer` to alias.
+   * @param buffCapacity The size of `buffer` in char16_ts.
    * @return a reference to this
    * @stable ICU 2.0
    */
   UnicodeString &setTo(char16_t *buffer,
                        int32_t buffLength,
@@ -2128,161 +2114,161 @@
 
 
   /* Append operations */
 
   /**
-   * Append operator. Append the code unit <TT>ch</TT> to the UnicodeString
+   * Append operator. Append the code unit `ch` to the UnicodeString
    * object.
    * @param ch the code unit to be appended
    * @return a reference to this
    * @stable ICU 2.0
    */
  inline  UnicodeString& operator+= (char16_t ch);
 
   /**
-   * Append operator. Append the code point <TT>ch</TT> to the UnicodeString
+   * Append operator. Append the code point `ch` to the UnicodeString
    * object.
    * @param ch the code point to be appended
    * @return a reference to this
    * @stable ICU 2.0
    */
  inline  UnicodeString& operator+= (UChar32 ch);
 
   /**
-   * Append operator. Append the characters in <TT>srcText</TT> to the
-   * UnicodeString object. <TT>srcText</TT> is not modified.
+   * Append operator. Append the characters in `srcText` to the
+   * UnicodeString object. `srcText` is not modified.
    * @param srcText the source for the new characters
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& operator+= (const UnicodeString& srcText);
 
   /**
    * Append the characters
-   * in <TT>srcText</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>) to the
-   * UnicodeString object at offset <TT>start</TT>. <TT>srcText</TT>
+   * in `srcText` in the range
+   * [`srcStart`, `srcStart + srcLength`) to the
+   * UnicodeString object at offset `start`. `srcText`
    * is not modified.
    * @param srcText the source for the new characters
-   * @param srcStart the offset into <TT>srcText</TT> where new characters
+   * @param srcStart the offset into `srcText` where new characters
    * will be obtained
-   * @param srcLength the number of characters in <TT>srcText</TT> in
+   * @param srcLength the number of characters in `srcText` in
    * the append string
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& append(const UnicodeString& srcText,
             int32_t srcStart,
             int32_t srcLength);
 
   /**
-   * Append the characters in <TT>srcText</TT> to the UnicodeString object.
-   * <TT>srcText</TT> is not modified.
+   * Append the characters in `srcText` to the UnicodeString object.
+   * `srcText` is not modified.
    * @param srcText the source for the new characters
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& append(const UnicodeString& srcText);
 
   /**
-   * Append the characters in <TT>srcChars</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>) to the UnicodeString
+   * Append the characters in `srcChars` in the range
+   * [`srcStart`, `srcStart + srcLength`) to the UnicodeString
    * object at offset
-   * <TT>start</TT>. <TT>srcChars</TT> is not modified.
+   * `start`. `srcChars` is not modified.
    * @param srcChars the source for the new characters
-   * @param srcStart the offset into <TT>srcChars</TT> where new characters
+   * @param srcStart the offset into `srcChars` where new characters
    * will be obtained
-   * @param srcLength the number of characters in <TT>srcChars</TT> in
-   *                  the append string; can be -1 if <TT>srcChars</TT> is NUL-terminated
+   * @param srcLength the number of characters in `srcChars` in
+   *                  the append string; can be -1 if `srcChars` is NUL-terminated
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& append(const char16_t *srcChars,
             int32_t srcStart,
             int32_t srcLength);
 
   /**
-   * Append the characters in <TT>srcChars</TT> to the UnicodeString object
-   * at offset <TT>start</TT>. <TT>srcChars</TT> is not modified.
+   * Append the characters in `srcChars` to the UnicodeString object
+   * at offset `start`. `srcChars` is not modified.
    * @param srcChars the source for the new characters
-   * @param srcLength the number of Unicode characters in <TT>srcChars</TT>;
-   *                  can be -1 if <TT>srcChars</TT> is NUL-terminated
+   * @param srcLength the number of Unicode characters in `srcChars`;
+   *                  can be -1 if `srcChars` is NUL-terminated
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& append(ConstChar16Ptr srcChars,
             int32_t srcLength);
 
   /**
-   * Append the code unit <TT>srcChar</TT> to the UnicodeString object.
+   * Append the code unit `srcChar` to the UnicodeString object.
    * @param srcChar the code unit to append
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& append(char16_t srcChar);
 
   /**
-   * Append the code point <TT>srcChar</TT> to the UnicodeString object.
+   * Append the code point `srcChar` to the UnicodeString object.
    * @param srcChar the code point to append
    * @return a reference to this
    * @stable ICU 2.0
    */
   UnicodeString& append(UChar32 srcChar);
 
 
   /* Insert operations */
 
   /**
-   * Insert the characters in <TT>srcText</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>) into the UnicodeString
-   * object at offset <TT>start</TT>. <TT>srcText</TT> is not modified.
+   * Insert the characters in `srcText` in the range
+   * [`srcStart`, `srcStart + srcLength`) into the UnicodeString
+   * object at offset `start`. `srcText` is not modified.
    * @param start the offset where the insertion begins
    * @param srcText the source for the new characters
-   * @param srcStart the offset into <TT>srcText</TT> where new characters
+   * @param srcStart the offset into `srcText` where new characters
    * will be obtained
-   * @param srcLength the number of characters in <TT>srcText</TT> in
+   * @param srcLength the number of characters in `srcText` in
    * the insert string
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& insert(int32_t start,
             const UnicodeString& srcText,
             int32_t srcStart,
             int32_t srcLength);
 
   /**
-   * Insert the characters in <TT>srcText</TT> into the UnicodeString object
-   * at offset <TT>start</TT>. <TT>srcText</TT> is not modified.
+   * Insert the characters in `srcText` into the UnicodeString object
+   * at offset `start`. `srcText` is not modified.
    * @param start the offset where the insertion begins
    * @param srcText the source for the new characters
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& insert(int32_t start,
             const UnicodeString& srcText);
 
   /**
-   * Insert the characters in <TT>srcChars</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>) into the UnicodeString
-   *  object at offset <TT>start</TT>. <TT>srcChars</TT> is not modified.
+   * Insert the characters in `srcChars` in the range
+   * [`srcStart`, `srcStart + srcLength`) into the UnicodeString
+   *  object at offset `start`. `srcChars` is not modified.
    * @param start the offset at which the insertion begins
    * @param srcChars the source for the new characters
-   * @param srcStart the offset into <TT>srcChars</TT> where new characters
+   * @param srcStart the offset into `srcChars` where new characters
    * will be obtained
-   * @param srcLength the number of characters in <TT>srcChars</TT>
+   * @param srcLength the number of characters in `srcChars`
    * in the insert string
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& insert(int32_t start,
             const char16_t *srcChars,
             int32_t srcStart,
             int32_t srcLength);
 
   /**
-   * Insert the characters in <TT>srcChars</TT> into the UnicodeString object
-   * at offset <TT>start</TT>. <TT>srcChars</TT> is not modified.
+   * Insert the characters in `srcChars` into the UnicodeString object
+   * at offset `start`. `srcChars` is not modified.
    * @param start the offset where the insertion begins
    * @param srcChars the source for the new characters
    * @param srcLength the number of Unicode characters in srcChars.
    * @return a reference to this
    * @stable ICU 2.0
@@ -2290,23 +2276,23 @@
   inline UnicodeString& insert(int32_t start,
             ConstChar16Ptr srcChars,
             int32_t srcLength);
 
   /**
-   * Insert the code unit <TT>srcChar</TT> into the UnicodeString object at
-   * offset <TT>start</TT>.
+   * Insert the code unit `srcChar` into the UnicodeString object at
+   * offset `start`.
    * @param start the offset at which the insertion occurs
    * @param srcChar the code unit to insert
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& insert(int32_t start,
             char16_t srcChar);
 
   /**
-   * Insert the code point <TT>srcChar</TT> into the UnicodeString object at
-   * offset <TT>start</TT>.
+   * Insert the code point `srcChar` into the UnicodeString object at
+   * offset `start`.
    * @param start the offset at which the insertion occurs
    * @param srcChar the code point to insert
    * @return a reference to this
    * @stable ICU 2.0
    */
@@ -2316,77 +2302,77 @@
 
   /* Replace operations */
 
   /**
    * Replace the characters in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) with the characters in
-   * <TT>srcText</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>).
-   * <TT>srcText</TT> is not modified.
+   * [`start`, `start + length`) with the characters in
+   * `srcText` in the range
+   * [`srcStart`, `srcStart + srcLength`).
+   * `srcText` is not modified.
    * @param start the offset at which the replace operation begins
    * @param length the number of characters to replace. The character at
-   * <TT>start + length</TT> is not modified.
+   * `start + length` is not modified.
    * @param srcText the source for the new characters
-   * @param srcStart the offset into <TT>srcText</TT> where new characters
+   * @param srcStart the offset into `srcText` where new characters
    * will be obtained
-   * @param srcLength the number of characters in <TT>srcText</TT> in
+   * @param srcLength the number of characters in `srcText` in
    * the replace string
    * @return a reference to this
    * @stable ICU 2.0
    */
-  UnicodeString& replace(int32_t start,
+  inline UnicodeString& replace(int32_t start,
              int32_t length,
              const UnicodeString& srcText,
              int32_t srcStart,
              int32_t srcLength);
 
   /**
    * Replace the characters in the range
-   * [<TT>start</TT>, <TT>start + length</TT>)
-   * with the characters in <TT>srcText</TT>.  <TT>srcText</TT> is
+   * [`start`, `start + length`)
+   * with the characters in `srcText`.  `srcText` is
    *  not modified.
    * @param start the offset at which the replace operation begins
    * @param length the number of characters to replace. The character at
-   * <TT>start + length</TT> is not modified.
+   * `start + length` is not modified.
    * @param srcText the source for the new characters
    * @return a reference to this
    * @stable ICU 2.0
    */
-  UnicodeString& replace(int32_t start,
+  inline UnicodeString& replace(int32_t start,
              int32_t length,
              const UnicodeString& srcText);
 
   /**
    * Replace the characters in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) with the characters in
-   * <TT>srcChars</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcStart + srcLength</TT>). <TT>srcChars</TT>
+   * [`start`, `start + length`) with the characters in
+   * `srcChars` in the range
+   * [`srcStart`, `srcStart + srcLength`). `srcChars`
    * is not modified.
    * @param start the offset at which the replace operation begins
    * @param length the number of characters to replace.  The character at
-   * <TT>start + length</TT> is not modified.
+   * `start + length` is not modified.
    * @param srcChars the source for the new characters
-   * @param srcStart the offset into <TT>srcChars</TT> where new characters
+   * @param srcStart the offset into `srcChars` where new characters
    * will be obtained
-   * @param srcLength the number of characters in <TT>srcChars</TT>
+   * @param srcLength the number of characters in `srcChars`
    * in the replace string
    * @return a reference to this
    * @stable ICU 2.0
    */
-  UnicodeString& replace(int32_t start,
+  inline UnicodeString& replace(int32_t start,
              int32_t length,
              const char16_t *srcChars,
              int32_t srcStart,
              int32_t srcLength);
 
   /**
    * Replace the characters in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) with the characters in
-   * <TT>srcChars</TT>.  <TT>srcChars</TT> is not modified.
+   * [`start`, `start + length`) with the characters in
+   * `srcChars`.  `srcChars` is not modified.
    * @param start the offset at which the replace operation begins
    * @param length number of characters to replace.  The character at
-   * <TT>start + length</TT> is not modified.
+   * `start + length` is not modified.
    * @param srcChars the source for the new characters
    * @param srcLength the number of Unicode characters in srcChars
    * @return a reference to this
    * @stable ICU 2.0
    */
@@ -2395,39 +2381,39 @@
              ConstChar16Ptr srcChars,
              int32_t srcLength);
 
   /**
    * Replace the characters in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) with the code unit
-   * <TT>srcChar</TT>.
+   * [`start`, `start + length`) with the code unit
+   * `srcChar`.
    * @param start the offset at which the replace operation begins
    * @param length the number of characters to replace.  The character at
-   * <TT>start + length</TT> is not modified.
+   * `start + length` is not modified.
    * @param srcChar the new code unit
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& replace(int32_t start,
              int32_t length,
              char16_t srcChar);
 
   /**
    * Replace the characters in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) with the code point
-   * <TT>srcChar</TT>.
+   * [`start`, `start + length`) with the code point
+   * `srcChar`.
    * @param start the offset at which the replace operation begins
    * @param length the number of characters to replace.  The character at
-   * <TT>start + length</TT> is not modified.
+   * `start + length` is not modified.
    * @param srcChar the new code point
    * @return a reference to this
    * @stable ICU 2.0
    */
   UnicodeString& replace(int32_t start, int32_t length, UChar32 srcChar);
 
   /**
-   * Replace the characters in the range [<TT>start</TT>, <TT>limit</TT>)
-   * with the characters in <TT>srcText</TT>. <TT>srcText</TT> is not modified.
+   * Replace the characters in the range [`start`, `limit`)
+   * with the characters in `srcText`. `srcText` is not modified.
    * @param start the offset at which the replace operation begins
    * @param limit the offset immediately following the replace range
    * @param srcText the source for the new characters
    * @return a reference to this
    * @stable ICU 2.0
@@ -2435,20 +2421,20 @@
   inline UnicodeString& replaceBetween(int32_t start,
                 int32_t limit,
                 const UnicodeString& srcText);
 
   /**
-   * Replace the characters in the range [<TT>start</TT>, <TT>limit</TT>)
-   * with the characters in <TT>srcText</TT> in the range
-   * [<TT>srcStart</TT>, <TT>srcLimit</TT>). <TT>srcText</TT> is not modified.
+   * Replace the characters in the range [`start`, `limit`)
+   * with the characters in `srcText` in the range
+   * [`srcStart`, `srcLimit`). `srcText` is not modified.
    * @param start the offset at which the replace operation begins
    * @param limit the offset immediately following the replace range
    * @param srcText the source for the new characters
-   * @param srcStart the offset into <TT>srcChars</TT> where new characters
+   * @param srcStart the offset into `srcChars` where new characters
    * will be obtained
    * @param srcLimit the offset immediately following the range to copy
-   * in <TT>srcText</TT>
+   * in `srcText`
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& replaceBetween(int32_t start,
                 int32_t limit,
@@ -2456,16 +2442,13 @@
                 int32_t srcStart,
                 int32_t srcLimit);
 
   /**
    * Replace a substring of this object with the given text.
-   * @param start the beginning index, inclusive; <code>0 <= start
-   * <= limit</code>.
-   * @param limit the ending index, exclusive; <code>start <= limit
-   * <= length()</code>.
-   * @param text the text to replace characters <code>start</code>
-   * to <code>limit - 1</code>
+   * @param start the beginning index, inclusive; `0 <= start <= limit`.
+   * @param limit the ending index, exclusive; `start <= limit <= length()`.
+   * @param text the text to replace characters `start` to `limit - 1`
    * @stable ICU 2.0
    */
   virtual void handleReplaceBetween(int32_t start,
                                     int32_t limit,
                                     const UnicodeString& text);
@@ -2480,18 +2463,16 @@
   /**
    * Copy a substring of this object, retaining attribute (out-of-band)
    * information.  This method is used to duplicate or reorder substrings.
    * The destination index must not overlap the source range.
    *
-   * @param start the beginning index, inclusive; <code>0 <= start <=
-   * limit</code>.
-   * @param limit the ending index, exclusive; <code>start <= limit <=
-   * length()</code>.
+   * @param start the beginning index, inclusive; `0 <= start <= limit`.
+   * @param limit the ending index, exclusive; `start <= limit <= length()`.
    * @param dest the destination index.  The characters from
-   * <code>start..limit-1</code> will be copied to <code>dest</code>.
-   * Implementations of this method may assume that <code>dest <= start ||
-   * dest >= limit</code>.
+   *             `start..limit-1` will be copied to `dest`.
+   * Implementations of this method may assume that `dest <= start ||
+   * dest >= limit`.
    * @stable ICU 2.0
    */
   virtual void copy(int32_t start, int32_t limit, int32_t dest);
 
   /* Search and replace operations */
@@ -2508,11 +2489,11 @@
                 const UnicodeString& newText);
 
   /**
    * Replace all occurrences of characters in oldText with characters
    * in newText
-   * in the range [<TT>start</TT>, <TT>start + length</TT>).
+   * in the range [`start`, `start + length`).
    * @param start the start of the range in which replace will performed
    * @param length the length of the range in which replace will be performed
    * @param oldText the text containing the search text
    * @param newText the text containing the replacement text
    * @return a reference to this
@@ -2523,22 +2504,22 @@
                 const UnicodeString& oldText,
                 const UnicodeString& newText);
 
   /**
    * Replace all occurrences of characters in oldText in the range
-   * [<TT>oldStart</TT>, <TT>oldStart + oldLength</TT>) with the characters
+   * [`oldStart`, `oldStart + oldLength`) with the characters
    * in newText in the range
-   * [<TT>newStart</TT>, <TT>newStart + newLength</TT>)
-   * in the range [<TT>start</TT>, <TT>start + length</TT>).
+   * [`newStart`, `newStart + newLength`)
+   * in the range [`start`, `start + length`).
    * @param start the start of the range in which replace will performed
    * @param length the length of the range in which replace will be performed
    * @param oldText the text containing the search text
-   * @param oldStart the start of the search range in <TT>oldText</TT>
-   * @param oldLength the length of the search range in <TT>oldText</TT>
+   * @param oldStart the start of the search range in `oldText`
+   * @param oldLength the length of the search range in `oldText`
    * @param newText the text containing the replacement text
-   * @param newStart the start of the replacement range in <TT>newText</TT>
-   * @param newLength the length of the replacement range in <TT>newText</TT>
+   * @param newStart the start of the replacement range in `newText`
+   * @param newLength the length of the replacement range in `newText`
    * @return a reference to this
    * @stable ICU 2.0
    */
   UnicodeString& findAndReplace(int32_t start,
                 int32_t length,
@@ -2559,45 +2540,45 @@
    */
   inline UnicodeString& remove(void);
 
   /**
    * Remove the characters in the range
-   * [<TT>start</TT>, <TT>start + length</TT>) from the UnicodeString object.
+   * [`start`, `start + length`) from the UnicodeString object.
    * @param start the offset of the first character to remove
    * @param length the number of characters to remove
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& remove(int32_t start,
                                int32_t length = (int32_t)INT32_MAX);
 
   /**
    * Remove the characters in the range
-   * [<TT>start</TT>, <TT>limit</TT>) from the UnicodeString object.
+   * [`start`, `limit`) from the UnicodeString object.
    * @param start the offset of the first character to remove
    * @param limit the offset immediately following the range to remove
    * @return a reference to this
    * @stable ICU 2.0
    */
   inline UnicodeString& removeBetween(int32_t start,
                                       int32_t limit = (int32_t)INT32_MAX);
 
   /**
    * Retain only the characters in the range
-   * [<code>start</code>, <code>limit</code>) from the UnicodeString object.
-   * Removes characters before <code>start</code> and at and after <code>limit</code>.
+   * [`start`, `limit`) from the UnicodeString object.
+   * Removes characters before `start` and at and after `limit`.
    * @param start the offset of the first character to retain
    * @param limit the offset immediately following the range to retain
    * @return a reference to this
    * @stable ICU 4.4
    */
   inline UnicodeString &retainBetween(int32_t start, int32_t limit = INT32_MAX);
 
   /* Length operations */
 
   /**
-   * Pad the start of this UnicodeString with the character <TT>padChar</TT>.
+   * Pad the start of this UnicodeString with the character `padChar`.
    * If the length of this UnicodeString is less than targetLength,
    * length() - targetLength copies of padChar will be added to the
    * beginning of this UnicodeString.
    * @param targetLength the desired length of the string
    * @param padChar the character to use for padding. Defaults to
@@ -2607,11 +2588,11 @@
    */
   UBool padLeading(int32_t targetLength,
                     char16_t padChar = 0x0020);
 
   /**
-   * Pad the end of this UnicodeString with the character <TT>padChar</TT>.
+   * Pad the end of this UnicodeString with the character `padChar`.
    * If the length of this UnicodeString is less than targetLength,
    * length() - targetLength copies of padChar will be added to the
    * end of this UnicodeString.
    * @param targetLength the desired length of the string
    * @param padChar the character to use for padding. Defaults to
@@ -2621,11 +2602,11 @@
    */
   UBool padTrailing(int32_t targetLength,
                      char16_t padChar = 0x0020);
 
   /**
-   * Truncate this UnicodeString to the <TT>targetLength</TT>.
+   * Truncate this UnicodeString to the `targetLength`.
    * @param targetLength the desired length of this UnicodeString.
    * @return TRUE if the text was truncated, FALSE otherwise
    * @stable ICU 2.0
    */
   inline UBool truncate(int32_t targetLength);
@@ -2646,11 +2627,11 @@
    * @stable ICU 2.0
    */
   inline UnicodeString& reverse(void);
 
   /**
-   * Reverse the range [<TT>start</TT>, <TT>start + length</TT>) in
+   * Reverse the range [`start`, `start + length`) in
    * this UnicodeString.
    * @param start the start of the range to reverse
    * @param length the number of characters to to reverse
    * @return a reference to this
    * @stable ICU 2.0
@@ -2831,11 +2812,11 @@
    * - The previous string contents will still be in the buffer;
    *   if you want to use it, then you need to call length() before getBuffer(minCapacity).
    *   If the length() was greater than minCapacity, then any contents after minCapacity
    *   may be lost.
    *   The buffer contents is not NUL-terminated by getBuffer().
-   *   If length()<getCapacity() then you can terminate it by writing a NUL
+   *   If length() < getCapacity() then you can terminate it by writing a NUL
    *   at index length().
    * - You must call releaseBuffer(newLength) before and in order to
    *   return to normal UnicodeString operation.
    *
    * @param minCapacity the minimum number of char16_ts that are to be available
@@ -2887,11 +2868,11 @@
    * The part after length() may or may not be initialized and valid,
    * depending on the history of the UnicodeString object.
    *
    * The buffer contents is (probably) not NUL-terminated.
    * You can check if it is with
-   * <code>(s.length()<s.getCapacity() && buffer[s.length()]==0)</code>.
+   * `(s.length() < s.getCapacity() && buffer[s.length()]==0)`.
    * (See getTerminatedBuffer().)
    *
    * The buffer may reside in read-only memory. Its contents must not
    * be modified.
    *
@@ -2947,11 +2928,11 @@
    * @stable ICU 2.0
    */
   inline UnicodeString();
 
   /**
-   * Construct a UnicodeString with capacity to hold <TT>capacity</TT> char16_ts
+   * Construct a UnicodeString with capacity to hold `capacity` char16_ts
    * @param capacity the number of char16_ts this UnicodeString should hold
    * before a resize is necessary; if count is greater than 0 and count
    * code points c take up more space than capacity, then capacity is adjusted
    * accordingly.
    * @param c is used to initially fill the string
@@ -2963,35 +2944,35 @@
 
   /**
    * Single char16_t (code unit) constructor.
    *
    * It is recommended to mark this constructor "explicit" by
-   * <code>-DUNISTR_FROM_CHAR_EXPLICIT=explicit</code>
+   * `-DUNISTR_FROM_CHAR_EXPLICIT=explicit`
    * on the compiler command line or similar.
    * @param ch the character to place in the UnicodeString
    * @stable ICU 2.0
    */
   UNISTR_FROM_CHAR_EXPLICIT UnicodeString(char16_t ch);
 
   /**
    * Single UChar32 (code point) constructor.
    *
    * It is recommended to mark this constructor "explicit" by
-   * <code>-DUNISTR_FROM_CHAR_EXPLICIT=explicit</code>
+   * `-DUNISTR_FROM_CHAR_EXPLICIT=explicit`
    * on the compiler command line or similar.
    * @param ch the character to place in the UnicodeString
    * @stable ICU 2.0
    */
   UNISTR_FROM_CHAR_EXPLICIT UnicodeString(UChar32 ch);
 
   /**
    * char16_t* constructor.
    *
    * It is recommended to mark this constructor "explicit" by
-   * <code>-DUNISTR_FROM_STRING_EXPLICIT=explicit</code>
+   * `-DUNISTR_FROM_STRING_EXPLICIT=explicit`
    * on the compiler command line or similar.
-   * @param text The characters to place in the UnicodeString.  <TT>text</TT>
+   * @param text The characters to place in the UnicodeString.  `text`
    * must be NULL (U+0000) terminated.
    * @stable ICU 2.0
    */
   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const char16_t *text);
 
@@ -2999,11 +2980,11 @@
   /**
    * uint16_t * constructor.
    * Delegates to UnicodeString(const char16_t *).
    *
    * It is recommended to mark this constructor "explicit" by
-   * <code>-DUNISTR_FROM_STRING_EXPLICIT=explicit</code>
+   * `-DUNISTR_FROM_STRING_EXPLICIT=explicit`
    * on the compiler command line or similar.
    * @param text NUL-terminated UTF-16 string
    * @stable ICU 59
    */
   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const uint16_t *text) :
@@ -3015,11 +2996,11 @@
    * wchar_t * constructor.
    * (Only defined if U_SIZEOF_WCHAR_T==2.)
    * Delegates to UnicodeString(const char16_t *).
    *
    * It is recommended to mark this constructor "explicit" by
-   * <code>-DUNISTR_FROM_STRING_EXPLICIT=explicit</code>
+   * `-DUNISTR_FROM_STRING_EXPLICIT=explicit`
    * on the compiler command line or similar.
    * @param text NUL-terminated UTF-16 string
    * @stable ICU 59
    */
   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const wchar_t *text) :
@@ -3029,21 +3010,21 @@
   /**
    * nullptr_t constructor.
    * Effectively the same as the default constructor, makes an empty string object.
    *
    * It is recommended to mark this constructor "explicit" by
-   * <code>-DUNISTR_FROM_STRING_EXPLICIT=explicit</code>
+   * `-DUNISTR_FROM_STRING_EXPLICIT=explicit`
    * on the compiler command line or similar.
    * @param text nullptr
    * @stable ICU 59
    */
   UNISTR_FROM_STRING_EXPLICIT inline UnicodeString(const std::nullptr_t text);
 
   /**
    * char16_t* constructor.
    * @param text The characters to place in the UnicodeString.
-   * @param textLength The number of Unicode characters in <TT>text</TT>
+   * @param textLength The number of Unicode characters in `text`
    * to copy.
    * @stable ICU 2.0
    */
   UnicodeString(const char16_t *text,
         int32_t textLength);
@@ -3094,16 +3075,16 @@
    * In an assignment to another UnicodeString, when using the copy constructor
    * or the assignment operator, the text will be copied.
    * When using fastCopyFrom(), the text will be aliased again,
    * so that both strings then alias the same readonly-text.
    *
-   * @param isTerminated specifies if <code>text</code> is <code>NUL</code>-terminated.
-   *                     This must be true if <code>textLength==-1</code>.
+   * @param isTerminated specifies if `text` is `NUL`-terminated.
+   *                     This must be true if `textLength==-1`.
    * @param text The characters to alias for the UnicodeString.
-   * @param textLength The number of Unicode characters in <code>text</code> to alias.
+   * @param textLength The number of Unicode characters in `text` to alias.
    *                   If -1, then this constructor will determine the length
-   *                   by calling <code>u_strlen()</code>.
+   *                   by calling `u_strlen()`.
    * @stable ICU 2.0
    */
   UnicodeString(UBool isTerminated,
                 ConstChar16Ptr text,
                 int32_t textLength);
@@ -3120,12 +3101,12 @@
    * In an assignment to another UnicodeString, the buffer will be copied.
    * The extract(Char16Ptr dst) function detects whether the dst pointer is the same
    * as the string buffer itself and will in this case not copy the contents.
    *
    * @param buffer The characters to alias for the UnicodeString.
-   * @param buffLength The number of Unicode characters in <code>buffer</code> to alias.
-   * @param buffCapacity The size of <code>buffer</code> in char16_ts.
+   * @param buffLength The number of Unicode characters in `buffer` to alias.
+   * @param buffCapacity The size of `buffer` in char16_ts.
    * @stable ICU 2.0
    */
   UnicodeString(char16_t *buffer, int32_t buffLength, int32_t buffCapacity);
 
 #if !U_CHAR16_IS_TYPEDEF
@@ -3176,11 +3157,11 @@
    * the constructor that takes a US_INV (for its enum EInvariant).
    * For ASCII (invariant-character) string literals, see UNICODE_STRING and
    * UNICODE_STRING_SIMPLE.
    *
    * It is recommended to mark this constructor "explicit" by
-   * <code>-DUNISTR_FROM_STRING_EXPLICIT=explicit</code>
+   * `-DUNISTR_FROM_STRING_EXPLICIT=explicit`
    * on the compiler command line or similar.
    * @param codepageData an array of bytes, null-terminated,
    *                     in the platform's default codepage.
    * @stable ICU 2.0
    * @see UNICODE_STRING
@@ -3191,11 +3172,11 @@
   /**
    * char* constructor.
    * Uses the default converter (and thus depends on the ICU conversion code)
    * unless U_CHARSET_IS_UTF8 is set to 1.
    * @param codepageData an array of bytes in the platform's default codepage.
-   * @param dataLength The number of bytes in <TT>codepageData</TT>.
+   * @param dataLength The number of bytes in `codepageData`.
    * @stable ICU 2.0
    */
   UnicodeString(const char *codepageData, int32_t dataLength);
 
 #endif
@@ -3203,15 +3184,15 @@
 #if !UCONFIG_NO_CONVERSION
 
   /**
    * char* constructor.
    * @param codepageData an array of bytes, null-terminated
-   * @param codepage the encoding of <TT>codepageData</TT>.  The special
-   * value 0 for <TT>codepage</TT> indicates that the text is in the
+   * @param codepage the encoding of `codepageData`.  The special
+   * value 0 for `codepage` indicates that the text is in the
    * platform's default codepage.
    *
-   * If <code>codepage</code> is an empty string (<code>""</code>),
+   * If `codepage` is an empty string (`""`),
    * then a simple conversion is performed on the codepage-invariant
    * subset ("invariant characters") of the platform encoding. See utypes.h.
    * Recommendation: For invariant-character strings use the constructor
    * UnicodeString(const char *src, int32_t length, enum EInvariant inv)
    * because it avoids object code dependencies of UnicodeString on
@@ -3222,15 +3203,15 @@
   UnicodeString(const char *codepageData, const char *codepage);
 
   /**
    * char* constructor.
    * @param codepageData an array of bytes.
-   * @param dataLength The number of bytes in <TT>codepageData</TT>.
-   * @param codepage the encoding of <TT>codepageData</TT>.  The special
-   * value 0 for <TT>codepage</TT> indicates that the text is in the
+   * @param dataLength The number of bytes in `codepageData`.
+   * @param codepage the encoding of `codepageData`.  The special
+   * value 0 for `codepage` indicates that the text is in the
    * platform's default codepage.
-   * If <code>codepage</code> is an empty string (<code>""</code>),
+   * If `codepage` is an empty string (`""`),
    * then a simple conversion is performed on the codepage-invariant
    * subset ("invariant characters") of the platform encoding. See utypes.h.
    * Recommendation: For invariant-character strings use the constructor
    * UnicodeString(const char *src, int32_t length, enum EInvariant inv)
    * because it avoids object code dependencies of UnicodeString on
@@ -3277,16 +3258,15 @@
    *
    * Use the macro US_INV as the third, signature-distinguishing parameter.
    *
    * For example:
    * \code
-   * void fn(const char *s) {
-   *   UnicodeString ustr(s, -1, US_INV);
-   *   // use ustr ...
-   * }
+   *     void fn(const char *s) {
+   *       UnicodeString ustr(s, -1, US_INV);
+   *       // use ustr ...
+   *     }
    * \endcode
-   *
    * @param src String using only invariant characters.
    * @param length Length of src, or -1 if NUL-terminated.
    * @param inv Signature-distinguishing paramater, use US_INV.
    *
    * @see US_INV
@@ -3322,20 +3302,20 @@
   UnicodeString(UnicodeString &&src) U_NOEXCEPT;
 
   /**
    * 'Substring' constructor from tail of source string.
    * @param src The UnicodeString object to copy.
-   * @param srcStart The offset into <tt>src</tt> at which to start copying.
+   * @param srcStart The offset into `src` at which to start copying.
    * @stable ICU 2.2
    */
   UnicodeString(const UnicodeString& src, int32_t srcStart);
 
   /**
    * 'Substring' constructor from subrange of source string.
    * @param src The UnicodeString object to copy.
-   * @param srcStart The offset into <tt>src</tt> at which to start copying.
-   * @param srcLength The number of characters from <tt>src</tt> to copy.
+   * @param srcStart The offset into `src` at which to start copying.
+   * @param srcLength The number of characters from `src` to copy.
    * @stable ICU 2.2
    */
   UnicodeString(const UnicodeString& src, int32_t srcStart, int32_t srcLength);
 
   /**
@@ -3403,11 +3383,11 @@
    *
    * as well as the standard ANSI C escapes:
    *
    * \\a => U+0007, \\b => U+0008, \\t => U+0009, \\n => U+000A,
    * \\v => U+000B, \\f => U+000C, \\r => U+000D, \\e => U+001B,
-   * \\&quot; => U+0022, \\' => U+0027, \\? => U+003F, \\\\ => U+005C
+   * \\" => U+0022, \\' => U+0027, \\? => U+003F, \\\\ => U+005C
    *
    * Anything else following a backslash is generically escaped.  For
    * example, "[a\\-z]" returns "[a-z]".
    *
    * If an escape sequence is ill-formed, this method returns an empty
@@ -3651,13 +3631,13 @@
 
   /*
    * Real constructor for converting from codepage data.
    * It assumes that it is called with !fRefCounted.
    *
-   * If <code>codepage==0</code>, then the default converter
+   * If `codepage==0`, then the default converter
    * is used for the platform encoding.
-   * If <code>codepage</code> is an empty string (<code>""</code>),
+   * If `codepage` is an empty string (`""`),
    * then a simple conversion is performed on the codepage-invariant
    * subset ("invariant characters") of the platform encoding. See utypes.h.
    */
   void doCodepageCreate(const char *codepageData,
                         int32_t dataLength,
