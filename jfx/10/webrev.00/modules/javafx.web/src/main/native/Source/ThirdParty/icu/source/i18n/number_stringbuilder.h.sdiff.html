<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_stringbuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_stringbuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_types.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_stringbuilder.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 68     NumberStringBuilder &amp;clear();
 69 
 70     int32_t appendCodePoint(UChar32 codePoint, Field field, UErrorCode &amp;status);
 71 
 72     int32_t insertCodePoint(int32_t index, UChar32 codePoint, Field field, UErrorCode &amp;status);
 73 
 74     int32_t append(const UnicodeString &amp;unistr, Field field, UErrorCode &amp;status);
 75 
 76     int32_t insert(int32_t index, const UnicodeString &amp;unistr, Field field, UErrorCode &amp;status);
 77 
 78     int32_t insert(int32_t index, const UnicodeString &amp;unistr, int32_t start, int32_t end, Field field,
 79                    UErrorCode &amp;status);
 80 
 81     int32_t splice(int32_t startThis, int32_t endThis,  const UnicodeString &amp;unistr,
 82                    int32_t startOther, int32_t endOther, Field field, UErrorCode&amp; status);
 83 
 84     int32_t append(const NumberStringBuilder &amp;other, UErrorCode &amp;status);
 85 
 86     int32_t insert(int32_t index, const NumberStringBuilder &amp;other, UErrorCode &amp;status);
 87 


 88     /**
 89      * Gets a &quot;safe&quot; UnicodeString that can be used even after the NumberStringBuilder is destructed.
 90      * */
 91     UnicodeString toUnicodeString() const;
 92 
 93     /**
 94      * Gets an &quot;unsafe&quot; UnicodeString that is valid only as long as the NumberStringBuilder is alive and
 95      * unchanged. Slightly faster than toUnicodeString().
 96      */
 97     const UnicodeString toTempUnicodeString() const;
 98 
 99     UnicodeString toDebugString() const;
100 
101     const char16_t *chars() const;
102 
103     bool contentEquals(const NumberStringBuilder &amp;other) const;
104 
105     bool nextFieldPosition(FieldPosition&amp; fp, UErrorCode&amp; status) const;
106 
107     void getAllFieldPositions(FieldPositionIteratorHandler&amp; fpih, UErrorCode&amp; status) const;




109   private:
110     bool fUsingHeap = false;
111     ValueOrHeapArray&lt;char16_t&gt; fChars;
112     ValueOrHeapArray&lt;Field&gt; fFields;
113     int32_t fZero = DEFAULT_CAPACITY / 2;
114     int32_t fLength = 0;
115 
116     inline char16_t *getCharPtr() {
117         return fUsingHeap ? fChars.heap.ptr : fChars.value;
118     }
119 
120     inline const char16_t *getCharPtr() const {
121         return fUsingHeap ? fChars.heap.ptr : fChars.value;
122     }
123 
124     inline Field *getFieldPtr() {
125         return fUsingHeap ? fFields.heap.ptr : fFields.value;
126     }
127 
128     inline const Field *getFieldPtr() const {








141 };
142 
143 } // namespace impl
144 } // namespace number
145 U_NAMESPACE_END
146 
147 
148 #endif //__NUMBER_STRINGBUILDER_H__
149 
150 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
<td>
<hr />
<pre>
 68     NumberStringBuilder &amp;clear();
 69 
 70     int32_t appendCodePoint(UChar32 codePoint, Field field, UErrorCode &amp;status);
 71 
 72     int32_t insertCodePoint(int32_t index, UChar32 codePoint, Field field, UErrorCode &amp;status);
 73 
 74     int32_t append(const UnicodeString &amp;unistr, Field field, UErrorCode &amp;status);
 75 
 76     int32_t insert(int32_t index, const UnicodeString &amp;unistr, Field field, UErrorCode &amp;status);
 77 
 78     int32_t insert(int32_t index, const UnicodeString &amp;unistr, int32_t start, int32_t end, Field field,
 79                    UErrorCode &amp;status);
 80 
 81     int32_t splice(int32_t startThis, int32_t endThis,  const UnicodeString &amp;unistr,
 82                    int32_t startOther, int32_t endOther, Field field, UErrorCode&amp; status);
 83 
 84     int32_t append(const NumberStringBuilder &amp;other, UErrorCode &amp;status);
 85 
 86     int32_t insert(int32_t index, const NumberStringBuilder &amp;other, UErrorCode &amp;status);
 87 
<span class="line-added"> 88     void writeTerminator(UErrorCode&amp; status);</span>
<span class="line-added"> 89 </span>
 90     /**
 91      * Gets a &quot;safe&quot; UnicodeString that can be used even after the NumberStringBuilder is destructed.
 92      * */
 93     UnicodeString toUnicodeString() const;
 94 
 95     /**
 96      * Gets an &quot;unsafe&quot; UnicodeString that is valid only as long as the NumberStringBuilder is alive and
 97      * unchanged. Slightly faster than toUnicodeString().
 98      */
 99     const UnicodeString toTempUnicodeString() const;
100 
101     UnicodeString toDebugString() const;
102 
103     const char16_t *chars() const;
104 
105     bool contentEquals(const NumberStringBuilder &amp;other) const;
106 
107     bool nextFieldPosition(FieldPosition&amp; fp, UErrorCode&amp; status) const;
108 
109     void getAllFieldPositions(FieldPositionIteratorHandler&amp; fpih, UErrorCode&amp; status) const;
<span class="line-added">111     bool nextPosition(ConstrainedFieldPosition&amp; cfpos, Field numericField, UErrorCode&amp; status) const;</span>
<span class="line-added">112 </span>
<span class="line-added">113     bool containsField(Field field) const;</span>
<span class="line-added">114 </span>
115   private:
116     bool fUsingHeap = false;
117     ValueOrHeapArray&lt;char16_t&gt; fChars;
118     ValueOrHeapArray&lt;Field&gt; fFields;
119     int32_t fZero = DEFAULT_CAPACITY / 2;
120     int32_t fLength = 0;
121 
122     inline char16_t *getCharPtr() {
123         return fUsingHeap ? fChars.heap.ptr : fChars.value;
124     }
125 
126     inline const char16_t *getCharPtr() const {
127         return fUsingHeap ? fChars.heap.ptr : fChars.value;
128     }
129 
130     inline Field *getFieldPtr() {
131         return fUsingHeap ? fFields.heap.ptr : fFields.value;
132     }
133 
134     inline const Field *getFieldPtr() const {
<span class="line-added">147 </span>
<span class="line-added">148     static bool isIntOrGroup(Field field);</span>
<span class="line-added">149 </span>
<span class="line-added">150     static bool isNumericField(Field field);</span>
<span class="line-added">151 </span>
<span class="line-added">152     int32_t trimBack(int32_t limit) const;</span>
<span class="line-added">153 </span>
<span class="line-added">154     int32_t trimFront(int32_t start) const;</span>
155 };
156 
157 } // namespace impl
158 } // namespace number
159 U_NAMESPACE_END
160 
161 
162 #endif //__NUMBER_STRINGBUILDER_H__
163 
164 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
</tr>
</table>
<center><a href="number_stringbuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_types.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>