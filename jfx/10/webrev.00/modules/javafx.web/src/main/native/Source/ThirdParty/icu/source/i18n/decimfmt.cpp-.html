<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/decimfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2018 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 
   4 #include &quot;unicode/utypes.h&quot;
   5 
   6 #if !UCONFIG_NO_FORMATTING
   7 
   8 // Allow implicit conversion from char16_t* to UnicodeString for this file:
   9 // Helpful in toString methods and elsewhere.
  10 #define UNISTR_FROM_STRING_EXPLICIT
  11 
  12 #include &lt;cmath&gt;
  13 #include &lt;cstdlib&gt;
  14 #include &lt;stdlib.h&gt;
  15 #include &quot;unicode/errorcode.h&quot;
  16 #include &quot;unicode/decimfmt.h&quot;
  17 #include &quot;number_decimalquantity.h&quot;
  18 #include &quot;number_types.h&quot;
  19 #include &quot;numparse_impl.h&quot;
  20 #include &quot;number_mapper.h&quot;
  21 #include &quot;number_patternstring.h&quot;
  22 #include &quot;putilimp.h&quot;
  23 #include &quot;number_utils.h&quot;
  24 #include &quot;number_utypes.h&quot;
  25 
  26 using namespace icu;
  27 using namespace icu::number;
  28 using namespace icu::number::impl;
  29 using namespace icu::numparse;
  30 using namespace icu::numparse::impl;
  31 using ERoundingMode = icu::DecimalFormat::ERoundingMode;
  32 using EPadPosition = icu::DecimalFormat::EPadPosition;
  33 
  34 // MSVC warns C4805 when comparing bool with UBool
  35 // TODO: Move this macro into a better place?
  36 #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN
  37 #define UBOOL_TO_BOOL(b) static_cast&lt;bool&gt;(b)
  38 #else
  39 #define UBOOL_TO_BOOL(b) b
  40 #endif
  41 
  42 
  43 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DecimalFormat)
  44 
  45 
  46 DecimalFormat::DecimalFormat(UErrorCode&amp; status)
  47         : DecimalFormat(nullptr, status) {
  48     // Use the default locale and decimal pattern.
  49     const char* localeName = Locale::getDefault().getName();
  50     LocalPointer&lt;NumberingSystem&gt; ns(NumberingSystem::createInstance(status));
  51     UnicodeString patternString = utils::getPatternForStyle(
  52             localeName,
  53             ns-&gt;getName(),
  54             CLDR_PATTERN_STYLE_DECIMAL,
  55             status);
  56     setPropertiesFromPattern(patternString, IGNORE_ROUNDING_IF_CURRENCY, status);
  57     touch(status);
  58 }
  59 
  60 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, UErrorCode&amp; status)
  61         : DecimalFormat(nullptr, status) {
  62     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  63     touch(status);
  64 }
  65 
  66 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
  67                              UErrorCode&amp; status)
  68         : DecimalFormat(symbolsToAdopt, status) {
  69     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  70     touch(status);
  71 }
  72 
  73 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
  74                              UNumberFormatStyle style, UErrorCode&amp; status)
  75         : DecimalFormat(symbolsToAdopt, status) {
  76     // If choice is a currency type, ignore the rounding information.
  77     if (style == UNumberFormatStyle::UNUM_CURRENCY || style == UNumberFormatStyle::UNUM_CURRENCY_ISO ||
  78         style == UNumberFormatStyle::UNUM_CURRENCY_ACCOUNTING ||
  79         style == UNumberFormatStyle::UNUM_CASH_CURRENCY ||
  80         style == UNumberFormatStyle::UNUM_CURRENCY_STANDARD ||
  81         style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {
  82         setPropertiesFromPattern(pattern, IGNORE_ROUNDING_ALWAYS, status);
  83     } else {
  84         setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  85     }
  86     // Note: in Java, CurrencyPluralInfo is set in NumberFormat.java, but in C++, it is not set there,
  87     // so we have to set it here.
  88     if (style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {
  89         LocalPointer&lt;CurrencyPluralInfo&gt; cpi(
  90                 new CurrencyPluralInfo(fields-&gt;symbols-&gt;getLocale(), status),
  91                 status);
  92         if (U_FAILURE(status)) { return; }
  93         fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(cpi.orphan());
  94     }
  95     touch(status);
  96 }
  97 
  98 DecimalFormat::DecimalFormat(const DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status) {
  99     LocalPointer&lt;const DecimalFormatSymbols&gt; adoptedSymbols(symbolsToAdopt);
 100     fields = new DecimalFormatFields();
 101     if (U_FAILURE(status)) {
 102         return;
 103     }
 104     if (fields == nullptr) {
 105         status = U_MEMORY_ALLOCATION_ERROR;
 106         return;
 107     }
 108     fields-&gt;properties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
 109     fields-&gt;exportedProperties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
 110     if (adoptedSymbols.isNull()) {
 111         fields-&gt;symbols.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(status), status);
 112     } else {
 113         fields-&gt;symbols.adoptInsteadAndCheckErrorCode(adoptedSymbols.orphan(), status);
 114     }
 115 }
 116 
 117 #if UCONFIG_HAVE_PARSEALLINPUT
 118 
 119 void DecimalFormat::setParseAllInput(UNumberFormatAttributeValue value) {
 120     if (value == fields-&gt;properties-&gt;parseAllInput) { return; }
 121     fields-&gt;properties-&gt;parseAllInput = value;
 122 }
 123 
 124 #endif
 125 
 126 DecimalFormat&amp;
 127 DecimalFormat::setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode&amp; status) {
 128     if (U_FAILURE(status)) { return *this; }
 129 
 130     switch (attr) {
 131         case UNUM_LENIENT_PARSE:
 132             setLenient(newValue != 0);
 133             break;
 134 
 135         case UNUM_PARSE_INT_ONLY:
 136             setParseIntegerOnly(newValue != 0);
 137             break;
 138 
 139         case UNUM_GROUPING_USED:
 140             setGroupingUsed(newValue != 0);
 141             break;
 142 
 143         case UNUM_DECIMAL_ALWAYS_SHOWN:
 144             setDecimalSeparatorAlwaysShown(newValue != 0);
 145             break;
 146 
 147         case UNUM_MAX_INTEGER_DIGITS:
 148             setMaximumIntegerDigits(newValue);
 149             break;
 150 
 151         case UNUM_MIN_INTEGER_DIGITS:
 152             setMinimumIntegerDigits(newValue);
 153             break;
 154 
 155         case UNUM_INTEGER_DIGITS:
 156             setMinimumIntegerDigits(newValue);
 157             setMaximumIntegerDigits(newValue);
 158             break;
 159 
 160         case UNUM_MAX_FRACTION_DIGITS:
 161             setMaximumFractionDigits(newValue);
 162             break;
 163 
 164         case UNUM_MIN_FRACTION_DIGITS:
 165             setMinimumFractionDigits(newValue);
 166             break;
 167 
 168         case UNUM_FRACTION_DIGITS:
 169             setMinimumFractionDigits(newValue);
 170             setMaximumFractionDigits(newValue);
 171             break;
 172 
 173         case UNUM_SIGNIFICANT_DIGITS_USED:
 174             setSignificantDigitsUsed(newValue != 0);
 175             break;
 176 
 177         case UNUM_MAX_SIGNIFICANT_DIGITS:
 178             setMaximumSignificantDigits(newValue);
 179             break;
 180 
 181         case UNUM_MIN_SIGNIFICANT_DIGITS:
 182             setMinimumSignificantDigits(newValue);
 183             break;
 184 
 185         case UNUM_MULTIPLIER:
 186             setMultiplier(newValue);
 187             break;
 188 
 189         case UNUM_SCALE:
 190             setMultiplierScale(newValue);
 191             break;
 192 
 193         case UNUM_GROUPING_SIZE:
 194             setGroupingSize(newValue);
 195             break;
 196 
 197         case UNUM_ROUNDING_MODE:
 198             setRoundingMode((DecimalFormat::ERoundingMode) newValue);
 199             break;
 200 
 201         case UNUM_FORMAT_WIDTH:
 202             setFormatWidth(newValue);
 203             break;
 204 
 205         case UNUM_PADDING_POSITION:
 206             /** The position at which padding will take place. */
 207             setPadPosition((DecimalFormat::EPadPosition) newValue);
 208             break;
 209 
 210         case UNUM_SECONDARY_GROUPING_SIZE:
 211             setSecondaryGroupingSize(newValue);
 212             break;
 213 
 214 #if UCONFIG_HAVE_PARSEALLINPUT
 215         case UNUM_PARSE_ALL_INPUT:
 216             setParseAllInput((UNumberFormatAttributeValue) newValue);
 217             break;
 218 #endif
 219 
 220         case UNUM_PARSE_NO_EXPONENT:
 221             setParseNoExponent((UBool) newValue);
 222             break;
 223 
 224         case UNUM_PARSE_DECIMAL_MARK_REQUIRED:
 225             setDecimalPatternMatchRequired((UBool) newValue);
 226             break;
 227 
 228         case UNUM_CURRENCY_USAGE:
 229             setCurrencyUsage((UCurrencyUsage) newValue, &amp;status);
 230             break;
 231 
 232         case UNUM_MINIMUM_GROUPING_DIGITS:
 233             setMinimumGroupingDigits(newValue);
 234             break;
 235 
 236         case UNUM_PARSE_CASE_SENSITIVE:
 237             setParseCaseSensitive(static_cast&lt;UBool&gt;(newValue));
 238             break;
 239 
 240         case UNUM_SIGN_ALWAYS_SHOWN:
 241             setSignAlwaysShown(static_cast&lt;UBool&gt;(newValue));
 242             break;
 243 
 244         case UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS:
 245             setFormatFailIfMoreThanMaxDigits(static_cast&lt;UBool&gt;(newValue));
 246             break;
 247 
 248         default:
 249             status = U_UNSUPPORTED_ERROR;
 250             break;
 251     }
 252     return *this;
 253 }
 254 
 255 int32_t DecimalFormat::getAttribute(UNumberFormatAttribute attr, UErrorCode&amp; status) const {
 256     if (U_FAILURE(status)) { return -1; }
 257     switch (attr) {
 258         case UNUM_LENIENT_PARSE:
 259             return isLenient();
 260 
 261         case UNUM_PARSE_INT_ONLY:
 262             return isParseIntegerOnly();
 263 
 264         case UNUM_GROUPING_USED:
 265             return isGroupingUsed();
 266 
 267         case UNUM_DECIMAL_ALWAYS_SHOWN:
 268             return isDecimalSeparatorAlwaysShown();
 269 
 270         case UNUM_MAX_INTEGER_DIGITS:
 271             return getMaximumIntegerDigits();
 272 
 273         case UNUM_MIN_INTEGER_DIGITS:
 274             return getMinimumIntegerDigits();
 275 
 276         case UNUM_INTEGER_DIGITS:
 277             // TBD: what should this return?
 278             return getMinimumIntegerDigits();
 279 
 280         case UNUM_MAX_FRACTION_DIGITS:
 281             return getMaximumFractionDigits();
 282 
 283         case UNUM_MIN_FRACTION_DIGITS:
 284             return getMinimumFractionDigits();
 285 
 286         case UNUM_FRACTION_DIGITS:
 287             // TBD: what should this return?
 288             return getMinimumFractionDigits();
 289 
 290         case UNUM_SIGNIFICANT_DIGITS_USED:
 291             return areSignificantDigitsUsed();
 292 
 293         case UNUM_MAX_SIGNIFICANT_DIGITS:
 294             return getMaximumSignificantDigits();
 295 
 296         case UNUM_MIN_SIGNIFICANT_DIGITS:
 297             return getMinimumSignificantDigits();
 298 
 299         case UNUM_MULTIPLIER:
 300             return getMultiplier();
 301 
 302         case UNUM_SCALE:
 303             return getMultiplierScale();
 304 
 305         case UNUM_GROUPING_SIZE:
 306             return getGroupingSize();
 307 
 308         case UNUM_ROUNDING_MODE:
 309             return getRoundingMode();
 310 
 311         case UNUM_FORMAT_WIDTH:
 312             return getFormatWidth();
 313 
 314         case UNUM_PADDING_POSITION:
 315             return getPadPosition();
 316 
 317         case UNUM_SECONDARY_GROUPING_SIZE:
 318             return getSecondaryGroupingSize();
 319 
 320         case UNUM_PARSE_NO_EXPONENT:
 321             return isParseNoExponent();
 322 
 323         case UNUM_PARSE_DECIMAL_MARK_REQUIRED:
 324             return isDecimalPatternMatchRequired();
 325 
 326         case UNUM_CURRENCY_USAGE:
 327             return getCurrencyUsage();
 328 
 329         case UNUM_MINIMUM_GROUPING_DIGITS:
 330             return getMinimumGroupingDigits();
 331 
 332         case UNUM_PARSE_CASE_SENSITIVE:
 333             return isParseCaseSensitive();
 334 
 335         case UNUM_SIGN_ALWAYS_SHOWN:
 336             return isSignAlwaysShown();
 337 
 338         case UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS:
 339             return isFormatFailIfMoreThanMaxDigits();
 340 
 341         default:
 342             status = U_UNSUPPORTED_ERROR;
 343             break;
 344     }
 345 
 346     return -1; /* undefined */
 347 }
 348 
 349 void DecimalFormat::setGroupingUsed(UBool enabled) {
 350     if (UBOOL_TO_BOOL(enabled) == fields-&gt;properties-&gt;groupingUsed) { return; }
 351     NumberFormat::setGroupingUsed(enabled); // to set field for compatibility
 352     fields-&gt;properties-&gt;groupingUsed = enabled;
 353     touchNoError();
 354 }
 355 
 356 void DecimalFormat::setParseIntegerOnly(UBool value) {
 357     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseIntegerOnly) { return; }
 358     NumberFormat::setParseIntegerOnly(value); // to set field for compatibility
 359     fields-&gt;properties-&gt;parseIntegerOnly = value;
 360     touchNoError();
 361 }
 362 
 363 void DecimalFormat::setLenient(UBool enable) {
 364     ParseMode mode = enable ? PARSE_MODE_LENIENT : PARSE_MODE_STRICT;
 365     if (!fields-&gt;properties-&gt;parseMode.isNull() &amp;&amp; mode == fields-&gt;properties-&gt;parseMode.getNoError()) { return; }
 366     NumberFormat::setLenient(enable); // to set field for compatibility
 367     fields-&gt;properties-&gt;parseMode = mode;
 368     touchNoError();
 369 }
 370 
 371 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
 372                              UParseError&amp;, UErrorCode&amp; status)
 373         : DecimalFormat(symbolsToAdopt, status) {
 374     // TODO: What is parseError for?
 375     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
 376     touch(status);
 377 }
 378 
 379 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, const DecimalFormatSymbols&amp; symbols,
 380                              UErrorCode&amp; status)
 381         : DecimalFormat(new DecimalFormatSymbols(symbols), status) {
 382     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
 383     touch(status);
 384 }
 385 
 386 DecimalFormat::DecimalFormat(const DecimalFormat&amp; source) : NumberFormat(source) {
 387     // Note: it is not safe to copy fields-&gt;formatter or fWarehouse directly because fields-&gt;formatter might have
 388     // dangling pointers to fields inside fWarehouse. The safe thing is to re-construct fields-&gt;formatter from
 389     // the property bag, despite being somewhat slower.
 390     fields = new DecimalFormatFields();
 391     if (fields == nullptr) {
 392         return;
 393     }
 394     fields-&gt;properties.adoptInstead(new DecimalFormatProperties(*source.fields-&gt;properties));
 395     fields-&gt;symbols.adoptInstead(new DecimalFormatSymbols(*source.fields-&gt;symbols));
 396     fields-&gt;exportedProperties.adoptInstead(new DecimalFormatProperties());
 397     if (fields-&gt;properties == nullptr || fields-&gt;symbols == nullptr || fields-&gt;exportedProperties == nullptr) {
 398         return;
 399     }
 400     touchNoError();
 401 }
 402 
 403 DecimalFormat&amp; DecimalFormat::operator=(const DecimalFormat&amp; rhs) {
 404     *fields-&gt;properties = *rhs.fields-&gt;properties;
 405     fields-&gt;exportedProperties-&gt;clear();
 406     fields-&gt;symbols.adoptInstead(new DecimalFormatSymbols(*rhs.fields-&gt;symbols));
 407     touchNoError();
 408     return *this;
 409 }
 410 
 411 DecimalFormat::~DecimalFormat() {
 412     delete fields-&gt;atomicParser.exchange(nullptr);
 413     delete fields-&gt;atomicCurrencyParser.exchange(nullptr);
 414     delete fields;
 415 }
 416 
 417 Format* DecimalFormat::clone() const {
 418     return new DecimalFormat(*this);
 419 }
 420 
 421 UBool DecimalFormat::operator==(const Format&amp; other) const {
 422     auto* otherDF = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;other);
 423     if (otherDF == nullptr) {
 424         return false;
 425     }
 426     return *fields-&gt;properties == *otherDF-&gt;fields-&gt;properties &amp;&amp; *fields-&gt;symbols == *otherDF-&gt;fields-&gt;symbols;
 427 }
 428 
 429 UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
 430     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
 431         return appendTo;
 432     }
 433     UErrorCode localStatus = U_ZERO_ERROR;
 434     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, localStatus);
 435     fieldPositionHelper(output, pos, appendTo.length(), localStatus);
 436     auto appendable = UnicodeStringAppendable(appendTo);
 437     output.appendTo(appendable);
 438     return appendTo;
 439 }
 440 
 441 UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 442                                      UErrorCode&amp; status) const {
 443     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
 444         return appendTo;
 445     }
 446     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
 447     fieldPositionHelper(output, pos, appendTo.length(), status);
 448     auto appendable = UnicodeStringAppendable(appendTo);
 449     output.appendTo(appendable);
 450     return appendTo;
 451 }
 452 
 453 UnicodeString&amp;
 454 DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 455                       UErrorCode&amp; status) const {
 456     if (posIter == nullptr &amp;&amp; fastFormatDouble(number, appendTo)) {
 457         return appendTo;
 458     }
 459     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
 460     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 461     auto appendable = UnicodeStringAppendable(appendTo);
 462     output.appendTo(appendable);
 463     return appendTo;
 464 }
 465 
 466 UnicodeString&amp; DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
 467     return format(static_cast&lt;int64_t&gt; (number), appendTo, pos);
 468 }
 469 
 470 UnicodeString&amp; DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 471                                      UErrorCode&amp; status) const {
 472     return format(static_cast&lt;int64_t&gt; (number), appendTo, pos, status);
 473 }
 474 
 475 UnicodeString&amp;
 476 DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 477                       UErrorCode&amp; status) const {
 478     return format(static_cast&lt;int64_t&gt; (number), appendTo, posIter, status);
 479 }
 480 
 481 UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
 482     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
 483         return appendTo;
 484     }
 485     UErrorCode localStatus = U_ZERO_ERROR;
 486     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, localStatus);
 487     fieldPositionHelper(output, pos, appendTo.length(), localStatus);
 488     auto appendable = UnicodeStringAppendable(appendTo);
 489     output.appendTo(appendable);
 490     return appendTo;
 491 }
 492 
 493 UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 494                                      UErrorCode&amp; status) const {
 495     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
 496         return appendTo;
 497     }
 498     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
 499     fieldPositionHelper(output, pos, appendTo.length(), status);
 500     auto appendable = UnicodeStringAppendable(appendTo);
 501     output.appendTo(appendable);
 502     return appendTo;
 503 }
 504 
 505 UnicodeString&amp;
 506 DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 507                       UErrorCode&amp; status) const {
 508     if (posIter == nullptr &amp;&amp; fastFormatInt64(number, appendTo)) {
 509         return appendTo;
 510     }
 511     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
 512     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 513     auto appendable = UnicodeStringAppendable(appendTo);
 514     output.appendTo(appendable);
 515     return appendTo;
 516 }
 517 
 518 UnicodeString&amp;
 519 DecimalFormat::format(StringPiece number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 520                       UErrorCode&amp; status) const {
 521     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimal(number, status);
 522     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 523     auto appendable = UnicodeStringAppendable(appendTo);
 524     output.appendTo(appendable);
 525     return appendTo;
 526 }
 527 
 528 UnicodeString&amp; DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo,
 529                                      FieldPositionIterator* posIter, UErrorCode&amp; status) const {
 530     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
 531     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 532     auto appendable = UnicodeStringAppendable(appendTo);
 533     output.appendTo(appendable);
 534     return appendTo;
 535 }
 536 
 537 UnicodeString&amp;
 538 DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 539                       UErrorCode&amp; status) const {
 540     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
 541     fieldPositionHelper(output, pos, appendTo.length(), status);
 542     auto appendable = UnicodeStringAppendable(appendTo);
 543     output.appendTo(appendable);
 544     return appendTo;
 545 }
 546 
 547 void DecimalFormat::parse(const UnicodeString&amp; text, Formattable&amp; output,
 548                           ParsePosition&amp; parsePosition) const {
 549     if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
 550         return;
 551     }
 552 
 553     ErrorCode status;
 554     ParsedNumber result;
 555     // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
 556     // parseCurrency method (backwards compatibility)
 557     int32_t startIndex = parsePosition.getIndex();
 558     const NumberParserImpl* parser = getParser(status);
 559     if (U_FAILURE(status)) { return; }
 560     parser-&gt;parse(text, startIndex, true, result, status);
 561     // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
 562     if (result.success()) {
 563         parsePosition.setIndex(result.charEnd);
 564         result.populateFormattable(output, parser-&gt;getParseFlags());
 565     } else {
 566         parsePosition.setErrorIndex(startIndex + result.charEnd);
 567     }
 568 }
 569 
 570 CurrencyAmount* DecimalFormat::parseCurrency(const UnicodeString&amp; text, ParsePosition&amp; parsePosition) const {
 571     if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
 572         return nullptr;
 573     }
 574 
 575     ErrorCode status;
 576     ParsedNumber result;
 577     // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
 578     // parseCurrency method (backwards compatibility)
 579     int32_t startIndex = parsePosition.getIndex();
 580     const NumberParserImpl* parser = getCurrencyParser(status);
 581     if (U_FAILURE(status)) { return nullptr; }
 582     parser-&gt;parse(text, startIndex, true, result, status);
 583     // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
 584     if (result.success()) {
 585         parsePosition.setIndex(result.charEnd);
 586         Formattable formattable;
 587         result.populateFormattable(formattable, parser-&gt;getParseFlags());
 588         return new CurrencyAmount(formattable, result.currencyCode, status);
 589     } else {
 590         parsePosition.setErrorIndex(startIndex + result.charEnd);
 591         return nullptr;
 592     }
 593 }
 594 
 595 const DecimalFormatSymbols* DecimalFormat::getDecimalFormatSymbols(void) const {
 596     return fields-&gt;symbols.getAlias();
 597 }
 598 
 599 void DecimalFormat::adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt) {
 600     if (symbolsToAdopt == nullptr) {
 601         return; // do not allow caller to set fields-&gt;symbols to NULL
 602     }
 603     fields-&gt;symbols.adoptInstead(symbolsToAdopt);
 604     touchNoError();
 605 }
 606 
 607 void DecimalFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols) {
 608     fields-&gt;symbols.adoptInstead(new DecimalFormatSymbols(symbols));
 609     touchNoError();
 610 }
 611 
 612 const CurrencyPluralInfo* DecimalFormat::getCurrencyPluralInfo(void) const {
 613     return fields-&gt;properties-&gt;currencyPluralInfo.fPtr.getAlias();
 614 }
 615 
 616 void DecimalFormat::adoptCurrencyPluralInfo(CurrencyPluralInfo* toAdopt) {
 617     fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(toAdopt);
 618     touchNoError();
 619 }
 620 
 621 void DecimalFormat::setCurrencyPluralInfo(const CurrencyPluralInfo&amp; info) {
 622     if (fields-&gt;properties-&gt;currencyPluralInfo.fPtr.isNull()) {
 623         fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(info.clone());
 624     } else {
 625         *fields-&gt;properties-&gt;currencyPluralInfo.fPtr = info; // copy-assignment operator
 626     }
 627     touchNoError();
 628 }
 629 
 630 UnicodeString&amp; DecimalFormat::getPositivePrefix(UnicodeString&amp; result) const {
 631     ErrorCode localStatus;
 632     fields-&gt;formatter-&gt;getAffixImpl(true, false, result, localStatus);
 633     return result;
 634 }
 635 
 636 void DecimalFormat::setPositivePrefix(const UnicodeString&amp; newValue) {
 637     if (newValue == fields-&gt;properties-&gt;positivePrefix) { return; }
 638     fields-&gt;properties-&gt;positivePrefix = newValue;
 639     touchNoError();
 640 }
 641 
 642 UnicodeString&amp; DecimalFormat::getNegativePrefix(UnicodeString&amp; result) const {
 643     ErrorCode localStatus;
 644     fields-&gt;formatter-&gt;getAffixImpl(true, true, result, localStatus);
 645     return result;
 646 }
 647 
 648 void DecimalFormat::setNegativePrefix(const UnicodeString&amp; newValue) {
 649     if (newValue == fields-&gt;properties-&gt;negativePrefix) { return; }
 650     fields-&gt;properties-&gt;negativePrefix = newValue;
 651     touchNoError();
 652 }
 653 
 654 UnicodeString&amp; DecimalFormat::getPositiveSuffix(UnicodeString&amp; result) const {
 655     ErrorCode localStatus;
 656     fields-&gt;formatter-&gt;getAffixImpl(false, false, result, localStatus);
 657     return result;
 658 }
 659 
 660 void DecimalFormat::setPositiveSuffix(const UnicodeString&amp; newValue) {
 661     if (newValue == fields-&gt;properties-&gt;positiveSuffix) { return; }
 662     fields-&gt;properties-&gt;positiveSuffix = newValue;
 663     touchNoError();
 664 }
 665 
 666 UnicodeString&amp; DecimalFormat::getNegativeSuffix(UnicodeString&amp; result) const {
 667     ErrorCode localStatus;
 668     fields-&gt;formatter-&gt;getAffixImpl(false, true, result, localStatus);
 669     return result;
 670 }
 671 
 672 void DecimalFormat::setNegativeSuffix(const UnicodeString&amp; newValue) {
 673     if (newValue == fields-&gt;properties-&gt;negativeSuffix) { return; }
 674     fields-&gt;properties-&gt;negativeSuffix = newValue;
 675     touchNoError();
 676 }
 677 
 678 UBool DecimalFormat::isSignAlwaysShown() const {
 679     return fields-&gt;properties-&gt;signAlwaysShown;
 680 }
 681 
 682 void DecimalFormat::setSignAlwaysShown(UBool value) {
 683     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;signAlwaysShown) { return; }
 684     fields-&gt;properties-&gt;signAlwaysShown = value;
 685     touchNoError();
 686 }
 687 
 688 int32_t DecimalFormat::getMultiplier(void) const {
 689     if (fields-&gt;properties-&gt;multiplier != 1) {
 690         return fields-&gt;properties-&gt;multiplier;
 691     } else if (fields-&gt;properties-&gt;magnitudeMultiplier != 0) {
 692         return static_cast&lt;int32_t&gt;(uprv_pow10(fields-&gt;properties-&gt;magnitudeMultiplier));
 693     } else {
 694         return 1;
 695     }
 696 }
 697 
 698 void DecimalFormat::setMultiplier(int32_t multiplier) {
 699     if (multiplier == 0) {
 700         multiplier = 1;     // one being the benign default value for a multiplier.
 701     }
 702 
 703     // Try to convert to a magnitude multiplier first
 704     int delta = 0;
 705     int value = multiplier;
 706     while (value != 1) {
 707         delta++;
 708         int temp = value / 10;
 709         if (temp * 10 != value) {
 710             delta = -1;
 711             break;
 712         }
 713         value = temp;
 714     }
 715     if (delta != -1) {
 716         fields-&gt;properties-&gt;magnitudeMultiplier = delta;
 717         fields-&gt;properties-&gt;multiplier = 1;
 718     } else {
 719         fields-&gt;properties-&gt;magnitudeMultiplier = 0;
 720         fields-&gt;properties-&gt;multiplier = multiplier;
 721     }
 722     touchNoError();
 723 }
 724 
 725 int32_t DecimalFormat::getMultiplierScale() const {
 726     return fields-&gt;properties-&gt;multiplierScale;
 727 }
 728 
 729 void DecimalFormat::setMultiplierScale(int32_t newValue) {
 730     if (newValue == fields-&gt;properties-&gt;multiplierScale) { return; }
 731     fields-&gt;properties-&gt;multiplierScale = newValue;
 732     touchNoError();
 733 }
 734 
 735 double DecimalFormat::getRoundingIncrement(void) const {
 736     return fields-&gt;exportedProperties-&gt;roundingIncrement;
 737 }
 738 
 739 void DecimalFormat::setRoundingIncrement(double newValue) {
 740     if (newValue == fields-&gt;properties-&gt;roundingIncrement) { return; }
 741     fields-&gt;properties-&gt;roundingIncrement = newValue;
 742     touchNoError();
 743 }
 744 
 745 ERoundingMode DecimalFormat::getRoundingMode(void) const {
 746     // UNumberFormatRoundingMode and ERoundingMode have the same values.
 747     return static_cast&lt;ERoundingMode&gt;(fields-&gt;exportedProperties-&gt;roundingMode.getNoError());
 748 }
 749 
 750 void DecimalFormat::setRoundingMode(ERoundingMode roundingMode) {
 751     auto uRoundingMode = static_cast&lt;UNumberFormatRoundingMode&gt;(roundingMode);
 752     if (!fields-&gt;properties-&gt;roundingMode.isNull() &amp;&amp; uRoundingMode == fields-&gt;properties-&gt;roundingMode.getNoError()) {
 753         return;
 754     }
 755     NumberFormat::setMaximumIntegerDigits(roundingMode); // to set field for compatibility
 756     fields-&gt;properties-&gt;roundingMode = uRoundingMode;
 757     touchNoError();
 758 }
 759 
 760 int32_t DecimalFormat::getFormatWidth(void) const {
 761     return fields-&gt;properties-&gt;formatWidth;
 762 }
 763 
 764 void DecimalFormat::setFormatWidth(int32_t width) {
 765     if (width == fields-&gt;properties-&gt;formatWidth) { return; }
 766     fields-&gt;properties-&gt;formatWidth = width;
 767     touchNoError();
 768 }
 769 
 770 UnicodeString DecimalFormat::getPadCharacterString() const {
 771     if (fields-&gt;properties-&gt;padString.isBogus()) {
 772         // Readonly-alias the static string kFallbackPaddingString
 773         return {TRUE, kFallbackPaddingString, -1};
 774     } else {
 775         return fields-&gt;properties-&gt;padString;
 776     }
 777 }
 778 
 779 void DecimalFormat::setPadCharacter(const UnicodeString&amp; padChar) {
 780     if (padChar == fields-&gt;properties-&gt;padString) { return; }
 781     if (padChar.length() &gt; 0) {
 782         fields-&gt;properties-&gt;padString = UnicodeString(padChar.char32At(0));
 783     } else {
 784         fields-&gt;properties-&gt;padString.setToBogus();
 785     }
 786     touchNoError();
 787 }
 788 
 789 EPadPosition DecimalFormat::getPadPosition(void) const {
 790     if (fields-&gt;properties-&gt;padPosition.isNull()) {
 791         return EPadPosition::kPadBeforePrefix;
 792     } else {
 793         // UNumberFormatPadPosition and EPadPosition have the same values.
 794         return static_cast&lt;EPadPosition&gt;(fields-&gt;properties-&gt;padPosition.getNoError());
 795     }
 796 }
 797 
 798 void DecimalFormat::setPadPosition(EPadPosition padPos) {
 799     auto uPadPos = static_cast&lt;UNumberFormatPadPosition&gt;(padPos);
 800     if (!fields-&gt;properties-&gt;padPosition.isNull() &amp;&amp; uPadPos == fields-&gt;properties-&gt;padPosition.getNoError()) {
 801         return;
 802     }
 803     fields-&gt;properties-&gt;padPosition = uPadPos;
 804     touchNoError();
 805 }
 806 
 807 UBool DecimalFormat::isScientificNotation(void) const {
 808     return fields-&gt;properties-&gt;minimumExponentDigits != -1;
 809 }
 810 
 811 void DecimalFormat::setScientificNotation(UBool useScientific) {
 812     int32_t minExp = useScientific ? 1 : -1;
 813     if (fields-&gt;properties-&gt;minimumExponentDigits == minExp) { return; }
 814     if (useScientific) {
 815         fields-&gt;properties-&gt;minimumExponentDigits = 1;
 816     } else {
 817         fields-&gt;properties-&gt;minimumExponentDigits = -1;
 818     }
 819     touchNoError();
 820 }
 821 
 822 int8_t DecimalFormat::getMinimumExponentDigits(void) const {
 823     return static_cast&lt;int8_t&gt;(fields-&gt;properties-&gt;minimumExponentDigits);
 824 }
 825 
 826 void DecimalFormat::setMinimumExponentDigits(int8_t minExpDig) {
 827     if (minExpDig == fields-&gt;properties-&gt;minimumExponentDigits) { return; }
 828     fields-&gt;properties-&gt;minimumExponentDigits = minExpDig;
 829     touchNoError();
 830 }
 831 
 832 UBool DecimalFormat::isExponentSignAlwaysShown(void) const {
 833     return fields-&gt;properties-&gt;exponentSignAlwaysShown;
 834 }
 835 
 836 void DecimalFormat::setExponentSignAlwaysShown(UBool expSignAlways) {
 837     if (UBOOL_TO_BOOL(expSignAlways) == fields-&gt;properties-&gt;exponentSignAlwaysShown) { return; }
 838     fields-&gt;properties-&gt;exponentSignAlwaysShown = expSignAlways;
 839     touchNoError();
 840 }
 841 
 842 int32_t DecimalFormat::getGroupingSize(void) const {
 843     if (fields-&gt;properties-&gt;groupingSize &lt; 0) {
 844         return 0;
 845     }
 846     return fields-&gt;properties-&gt;groupingSize;
 847 }
 848 
 849 void DecimalFormat::setGroupingSize(int32_t newValue) {
 850     if (newValue == fields-&gt;properties-&gt;groupingSize) { return; }
 851     fields-&gt;properties-&gt;groupingSize = newValue;
 852     touchNoError();
 853 }
 854 
 855 int32_t DecimalFormat::getSecondaryGroupingSize(void) const {
 856     int grouping2 = fields-&gt;properties-&gt;secondaryGroupingSize;
 857     if (grouping2 &lt; 0) {
 858         return 0;
 859     }
 860     return grouping2;
 861 }
 862 
 863 void DecimalFormat::setSecondaryGroupingSize(int32_t newValue) {
 864     if (newValue == fields-&gt;properties-&gt;secondaryGroupingSize) { return; }
 865     fields-&gt;properties-&gt;secondaryGroupingSize = newValue;
 866     touchNoError();
 867 }
 868 
 869 int32_t DecimalFormat::getMinimumGroupingDigits() const {
 870     return fields-&gt;properties-&gt;minimumGroupingDigits;
 871 }
 872 
 873 void DecimalFormat::setMinimumGroupingDigits(int32_t newValue) {
 874     if (newValue == fields-&gt;properties-&gt;minimumGroupingDigits) { return; }
 875     fields-&gt;properties-&gt;minimumGroupingDigits = newValue;
 876     touchNoError();
 877 }
 878 
 879 UBool DecimalFormat::isDecimalSeparatorAlwaysShown(void) const {
 880     return fields-&gt;properties-&gt;decimalSeparatorAlwaysShown;
 881 }
 882 
 883 void DecimalFormat::setDecimalSeparatorAlwaysShown(UBool newValue) {
 884     if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalSeparatorAlwaysShown) { return; }
 885     fields-&gt;properties-&gt;decimalSeparatorAlwaysShown = newValue;
 886     touchNoError();
 887 }
 888 
 889 UBool DecimalFormat::isDecimalPatternMatchRequired(void) const {
 890     return fields-&gt;properties-&gt;decimalPatternMatchRequired;
 891 }
 892 
 893 void DecimalFormat::setDecimalPatternMatchRequired(UBool newValue) {
 894     if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalPatternMatchRequired) { return; }
 895     fields-&gt;properties-&gt;decimalPatternMatchRequired = newValue;
 896     touchNoError();
 897 }
 898 
 899 UBool DecimalFormat::isParseNoExponent() const {
 900     return fields-&gt;properties-&gt;parseNoExponent;
 901 }
 902 
 903 void DecimalFormat::setParseNoExponent(UBool value) {
 904     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseNoExponent) { return; }
 905     fields-&gt;properties-&gt;parseNoExponent = value;
 906     touchNoError();
 907 }
 908 
 909 UBool DecimalFormat::isParseCaseSensitive() const {
 910     return fields-&gt;properties-&gt;parseCaseSensitive;
 911 }
 912 
 913 void DecimalFormat::setParseCaseSensitive(UBool value) {
 914     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseCaseSensitive) { return; }
 915     fields-&gt;properties-&gt;parseCaseSensitive = value;
 916     touchNoError();
 917 }
 918 
 919 UBool DecimalFormat::isFormatFailIfMoreThanMaxDigits() const {
 920     return fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits;
 921 }
 922 
 923 void DecimalFormat::setFormatFailIfMoreThanMaxDigits(UBool value) {
 924     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits) { return; }
 925     fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits = value;
 926     touchNoError();
 927 }
 928 
 929 UnicodeString&amp; DecimalFormat::toPattern(UnicodeString&amp; result) const {
 930     // Pull some properties from exportedProperties and others from properties
 931     // to keep affix patterns intact.  In particular, pull rounding properties
 932     // so that CurrencyUsage is reflected properly.
 933     // TODO: Consider putting this logic in number_patternstring.cpp instead.
 934     ErrorCode localStatus;
 935     DecimalFormatProperties tprops(*fields-&gt;properties);
 936     bool useCurrency = ((!tprops.currency.isNull()) || !tprops.currencyPluralInfo.fPtr.isNull() ||
 937                         !tprops.currencyUsage.isNull() || AffixUtils::hasCurrencySymbols(
 938             tprops.positivePrefixPattern, localStatus) || AffixUtils::hasCurrencySymbols(
 939             tprops.positiveSuffixPattern, localStatus) || AffixUtils::hasCurrencySymbols(
 940             tprops.negativePrefixPattern, localStatus) || AffixUtils::hasCurrencySymbols(
 941             tprops.negativeSuffixPattern, localStatus));
 942     if (useCurrency) {
 943         tprops.minimumFractionDigits = fields-&gt;exportedProperties-&gt;minimumFractionDigits;
 944         tprops.maximumFractionDigits = fields-&gt;exportedProperties-&gt;maximumFractionDigits;
 945         tprops.roundingIncrement = fields-&gt;exportedProperties-&gt;roundingIncrement;
 946     }
 947     result = PatternStringUtils::propertiesToPatternString(tprops, localStatus);
 948     return result;
 949 }
 950 
 951 UnicodeString&amp; DecimalFormat::toLocalizedPattern(UnicodeString&amp; result) const {
 952     ErrorCode localStatus;
 953     result = toPattern(result);
 954     result = PatternStringUtils::convertLocalized(result, *fields-&gt;symbols, true, localStatus);
 955     return result;
 956 }
 957 
 958 void DecimalFormat::applyPattern(const UnicodeString&amp; pattern, UParseError&amp;, UErrorCode&amp; status) {
 959     // TODO: What is parseError for?
 960     applyPattern(pattern, status);
 961 }
 962 
 963 void DecimalFormat::applyPattern(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
 964     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_NEVER, status);
 965     touch(status);
 966 }
 967 
 968 void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UParseError&amp;,
 969                                           UErrorCode&amp; status) {
 970     // TODO: What is parseError for?
 971     applyLocalizedPattern(localizedPattern, status);
 972 }
 973 
 974 void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UErrorCode&amp; status) {
 975     if (U_SUCCESS(status)) {
 976         UnicodeString pattern = PatternStringUtils::convertLocalized(
 977                 localizedPattern, *fields-&gt;symbols, false, status);
 978         applyPattern(pattern, status);
 979     }
 980 }
 981 
 982 void DecimalFormat::setMaximumIntegerDigits(int32_t newValue) {
 983     if (newValue == fields-&gt;properties-&gt;maximumIntegerDigits) { return; }
 984     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
 985     int32_t min = fields-&gt;properties-&gt;minimumIntegerDigits;
 986     if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
 987         fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
 988     }
 989     fields-&gt;properties-&gt;maximumIntegerDigits = newValue;
 990     touchNoError();
 991 }
 992 
 993 void DecimalFormat::setMinimumIntegerDigits(int32_t newValue) {
 994     if (newValue == fields-&gt;properties-&gt;minimumIntegerDigits) { return; }
 995     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
 996     int32_t max = fields-&gt;properties-&gt;maximumIntegerDigits;
 997     if (max &gt;= 0 &amp;&amp; max &lt; newValue) {
 998         fields-&gt;properties-&gt;maximumIntegerDigits = newValue;
 999     }
1000     fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
1001     touchNoError();
1002 }
1003 
1004 void DecimalFormat::setMaximumFractionDigits(int32_t newValue) {
1005     if (newValue == fields-&gt;properties-&gt;maximumFractionDigits) { return; }
1006     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1007     int32_t min = fields-&gt;properties-&gt;minimumFractionDigits;
1008     if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
1009         fields-&gt;properties-&gt;minimumFractionDigits = newValue;
1010     }
1011     fields-&gt;properties-&gt;maximumFractionDigits = newValue;
1012     touchNoError();
1013 }
1014 
1015 void DecimalFormat::setMinimumFractionDigits(int32_t newValue) {
1016     if (newValue == fields-&gt;properties-&gt;minimumFractionDigits) { return; }
1017     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1018     int32_t max = fields-&gt;properties-&gt;maximumFractionDigits;
1019     if (max &gt;= 0 &amp;&amp; max &lt; newValue) {
1020         fields-&gt;properties-&gt;maximumFractionDigits = newValue;
1021     }
1022     fields-&gt;properties-&gt;minimumFractionDigits = newValue;
1023     touchNoError();
1024 }
1025 
1026 int32_t DecimalFormat::getMinimumSignificantDigits() const {
1027     return fields-&gt;exportedProperties-&gt;minimumSignificantDigits;
1028 }
1029 
1030 int32_t DecimalFormat::getMaximumSignificantDigits() const {
1031     return fields-&gt;exportedProperties-&gt;maximumSignificantDigits;
1032 }
1033 
1034 void DecimalFormat::setMinimumSignificantDigits(int32_t value) {
1035     if (value == fields-&gt;properties-&gt;minimumSignificantDigits) { return; }
1036     int32_t max = fields-&gt;properties-&gt;maximumSignificantDigits;
1037     if (max &gt;= 0 &amp;&amp; max &lt; value) {
1038         fields-&gt;properties-&gt;maximumSignificantDigits = value;
1039     }
1040     fields-&gt;properties-&gt;minimumSignificantDigits = value;
1041     touchNoError();
1042 }
1043 
1044 void DecimalFormat::setMaximumSignificantDigits(int32_t value) {
1045     if (value == fields-&gt;properties-&gt;maximumSignificantDigits) { return; }
1046     int32_t min = fields-&gt;properties-&gt;minimumSignificantDigits;
1047     if (min &gt;= 0 &amp;&amp; min &gt; value) {
1048         fields-&gt;properties-&gt;minimumSignificantDigits = value;
1049     }
1050     fields-&gt;properties-&gt;maximumSignificantDigits = value;
1051     touchNoError();
1052 }
1053 
1054 UBool DecimalFormat::areSignificantDigitsUsed() const {
1055     return fields-&gt;properties-&gt;minimumSignificantDigits != -1 || fields-&gt;properties-&gt;maximumSignificantDigits != -1;
1056 }
1057 
1058 void DecimalFormat::setSignificantDigitsUsed(UBool useSignificantDigits) {
1059     // These are the default values from the old implementation.
1060     int32_t minSig = useSignificantDigits ? 1 : -1;
1061     int32_t maxSig = useSignificantDigits ? 6 : -1;
1062     if (fields-&gt;properties-&gt;minimumSignificantDigits == minSig &amp;&amp;
1063         fields-&gt;properties-&gt;maximumSignificantDigits == maxSig) {
1064         return;
1065     }
1066     fields-&gt;properties-&gt;minimumSignificantDigits = minSig;
1067     fields-&gt;properties-&gt;maximumSignificantDigits = maxSig;
1068     touchNoError();
1069 }
1070 
1071 void DecimalFormat::setCurrency(const char16_t* theCurrency, UErrorCode&amp; ec) {
1072     CurrencyUnit currencyUnit(theCurrency, ec);
1073     if (U_FAILURE(ec)) { return; }
1074     if (!fields-&gt;properties-&gt;currency.isNull() &amp;&amp; fields-&gt;properties-&gt;currency.getNoError() == currencyUnit) {
1075         return;
1076     }
1077     NumberFormat::setCurrency(theCurrency, ec); // to set field for compatibility
1078     fields-&gt;properties-&gt;currency = currencyUnit;
1079     // TODO: Set values in fields-&gt;symbols, too?
1080     touchNoError();
1081 }
1082 
1083 void DecimalFormat::setCurrency(const char16_t* theCurrency) {
1084     ErrorCode localStatus;
1085     setCurrency(theCurrency, localStatus);
1086 }
1087 
1088 void DecimalFormat::setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec) {
1089     if (U_FAILURE(*ec)) {
1090         return;
1091     }
1092     if (!fields-&gt;properties-&gt;currencyUsage.isNull() &amp;&amp; newUsage == fields-&gt;properties-&gt;currencyUsage.getNoError()) {
1093         return;
1094     }
1095     fields-&gt;properties-&gt;currencyUsage = newUsage;
1096     touch(*ec);
1097 }
1098 
1099 UCurrencyUsage DecimalFormat::getCurrencyUsage() const {
1100     // CurrencyUsage is not exported, so we have to get it from the input property bag.
1101     // TODO: Should we export CurrencyUsage instead?
1102     if (fields-&gt;properties-&gt;currencyUsage.isNull()) {
1103         return UCURR_USAGE_STANDARD;
1104     }
1105     return fields-&gt;properties-&gt;currencyUsage.getNoError();
1106 }
1107 
1108 void
1109 DecimalFormat::formatToDecimalQuantity(double number, DecimalQuantity&amp; output, UErrorCode&amp; status) const {
1110     fields-&gt;formatter-&gt;formatDouble(number, status).getDecimalQuantity(output, status);
1111 }
1112 
1113 void DecimalFormat::formatToDecimalQuantity(const Formattable&amp; number, DecimalQuantity&amp; output,
1114                                             UErrorCode&amp; status) const {
1115     UFormattedNumberData obj;
1116     number.populateDecimalQuantity(obj.quantity, status);
1117     fields-&gt;formatter-&gt;formatImpl(&amp;obj, status);
1118     output = std::move(obj.quantity);
1119 }
1120 
1121 const number::LocalizedNumberFormatter&amp; DecimalFormat::toNumberFormatter() const {
1122     return *fields-&gt;formatter;
1123 }
1124 
1125 /** Rebuilds the formatter object from the property bag. */
1126 void DecimalFormat::touch(UErrorCode&amp; status) {
1127     if (fields-&gt;exportedProperties == nullptr) {
1128         // fields-&gt;exportedProperties is null only when the formatter is not ready yet.
1129         // The only time when this happens is during legacy deserialization.
1130         return;
1131     }
1132 
1133     // In C++, fields-&gt;symbols is the source of truth for the locale.
1134     Locale locale = fields-&gt;symbols-&gt;getLocale();
1135 
1136     // Note: The formatter is relatively cheap to create, and we need it to populate fields-&gt;exportedProperties,
1137     // so automatically compute it here. The parser is a bit more expensive and is not needed until the
1138     // parse method is called, so defer that until needed.
1139     // TODO: Only update the pieces that changed instead of re-computing the whole formatter?
1140     fields-&gt;formatter.adoptInstead(
1141             new LocalizedNumberFormatter(
1142                     NumberPropertyMapper::create(
1143                             *fields-&gt;properties, *fields-&gt;symbols, fields-&gt;warehouse, *fields-&gt;exportedProperties, status).locale(
1144                             locale)));
1145 
1146     // Do this after fields-&gt;exportedProperties are set up
1147     setupFastFormat();
1148 
1149     // Delete the parsers if they were made previously
1150     delete fields-&gt;atomicParser.exchange(nullptr);
1151     delete fields-&gt;atomicCurrencyParser.exchange(nullptr);
1152 
1153     // In order for the getters to work, we need to populate some fields in NumberFormat.
1154     NumberFormat::setCurrency(fields-&gt;exportedProperties-&gt;currency.get(status).getISOCurrency(), status);
1155     NumberFormat::setMaximumIntegerDigits(fields-&gt;exportedProperties-&gt;maximumIntegerDigits);
1156     NumberFormat::setMinimumIntegerDigits(fields-&gt;exportedProperties-&gt;minimumIntegerDigits);
1157     NumberFormat::setMaximumFractionDigits(fields-&gt;exportedProperties-&gt;maximumFractionDigits);
1158     NumberFormat::setMinimumFractionDigits(fields-&gt;exportedProperties-&gt;minimumFractionDigits);
1159     // fImpl-&gt;properties, not fields-&gt;exportedProperties, since this information comes from the pattern:
1160     NumberFormat::setGroupingUsed(fields-&gt;properties-&gt;groupingUsed);
1161 }
1162 
1163 void DecimalFormat::touchNoError() {
1164     UErrorCode localStatus = U_ZERO_ERROR;
1165     touch(localStatus);
1166 }
1167 
1168 void DecimalFormat::setPropertiesFromPattern(const UnicodeString&amp; pattern, int32_t ignoreRounding,
1169                                              UErrorCode&amp; status) {
1170     if (U_SUCCESS(status)) {
1171         // Cast workaround to get around putting the enum in the public header file
1172         auto actualIgnoreRounding = static_cast&lt;IgnoreRounding&gt;(ignoreRounding);
1173         PatternParser::parseToExistingProperties(pattern, *fields-&gt;properties,  actualIgnoreRounding, status);
1174     }
1175 }
1176 
1177 const numparse::impl::NumberParserImpl* DecimalFormat::getParser(UErrorCode&amp; status) const {
1178     if (U_FAILURE(status)) { return nullptr; }
1179 
1180     // First try to get the pre-computed parser
1181     auto* ptr = fields-&gt;atomicParser.load();
1182     if (ptr != nullptr) {
1183         return ptr;
1184     }
1185 
1186     // Try computing the parser on our own
1187     auto* temp = NumberParserImpl::createParserFromProperties(*fields-&gt;properties, *fields-&gt;symbols, false, status);
1188     if (temp == nullptr) {
1189         status = U_MEMORY_ALLOCATION_ERROR;
1190         // although we may still dereference, call sites should be guarded
1191     }
1192 
1193     // Note: ptr starts as nullptr; during compare_exchange, it is set to what is actually stored in the
1194     // atomic if another thread beat us to computing the parser object.
1195     auto* nonConstThis = const_cast&lt;DecimalFormat*&gt;(this);
1196     if (!nonConstThis-&gt;fields-&gt;atomicParser.compare_exchange_strong(ptr, temp)) {
1197         // Another thread beat us to computing the parser
1198         delete temp;
1199         return ptr;
1200     } else {
1201         // Our copy of the parser got stored in the atomic
1202         return temp;
1203     }
1204 }
1205 
1206 const numparse::impl::NumberParserImpl* DecimalFormat::getCurrencyParser(UErrorCode&amp; status) const {
1207     if (U_FAILURE(status)) { return nullptr; }
1208 
1209     // First try to get the pre-computed parser
1210     auto* ptr = fields-&gt;atomicCurrencyParser.load();
1211     if (ptr != nullptr) {
1212         return ptr;
1213     }
1214 
1215     // Try computing the parser on our own
1216     auto* temp = NumberParserImpl::createParserFromProperties(*fields-&gt;properties, *fields-&gt;symbols, true, status);
1217     if (temp == nullptr) {
1218         status = U_MEMORY_ALLOCATION_ERROR;
1219         // although we may still dereference, call sites should be guarded
1220     }
1221 
1222     // Note: ptr starts as nullptr; during compare_exchange, it is set to what is actually stored in the
1223     // atomic if another thread beat us to computing the parser object.
1224     auto* nonConstThis = const_cast&lt;DecimalFormat*&gt;(this);
1225     if (!nonConstThis-&gt;fields-&gt;atomicCurrencyParser.compare_exchange_strong(ptr, temp)) {
1226         // Another thread beat us to computing the parser
1227         delete temp;
1228         return ptr;
1229     } else {
1230         // Our copy of the parser got stored in the atomic
1231         return temp;
1232     }
1233 }
1234 
1235 void
1236 DecimalFormat::fieldPositionHelper(const number::FormattedNumber&amp; formatted, FieldPosition&amp; fieldPosition,
1237                                    int32_t offset, UErrorCode&amp; status) {
1238     // always return first occurrence:
1239     fieldPosition.setBeginIndex(0);
1240     fieldPosition.setEndIndex(0);
1241     bool found = formatted.nextFieldPosition(fieldPosition, status);
1242     if (found &amp;&amp; offset != 0) {
1243         FieldPositionOnlyHandler fpoh(fieldPosition);
1244         fpoh.shiftLast(offset);
1245     }
1246 }
1247 
1248 void
1249 DecimalFormat::fieldPositionIteratorHelper(const number::FormattedNumber&amp; formatted, FieldPositionIterator* fpi,
1250                                            int32_t offset, UErrorCode&amp; status) {
1251     if (fpi != nullptr) {
1252         FieldPositionIteratorHandler fpih(fpi, status);
1253         fpih.setShift(offset);
1254         formatted.getAllFieldPositionsImpl(fpih, status);
1255     }
1256 }
1257 
1258 // To debug fast-format, change void(x) to printf(x)
1259 #define trace(x) void(x)
1260 
1261 void DecimalFormat::setupFastFormat() {
1262     // Check the majority of properties:
1263     if (!fields-&gt;properties-&gt;equalsDefaultExceptFastFormat()) {
1264         trace(&quot;no fast format: equality\n&quot;);
1265         fields-&gt;canUseFastFormat = false;
1266         return;
1267     }
1268 
1269     // Now check the remaining properties.
1270     // Nontrivial affixes:
1271     UBool trivialPP = fields-&gt;properties-&gt;positivePrefixPattern.isEmpty();
1272     UBool trivialPS = fields-&gt;properties-&gt;positiveSuffixPattern.isEmpty();
1273     UBool trivialNP = fields-&gt;properties-&gt;negativePrefixPattern.isBogus() || (
1274             fields-&gt;properties-&gt;negativePrefixPattern.length() == 1 &amp;&amp;
1275             fields-&gt;properties-&gt;negativePrefixPattern.charAt(0) == u&#39;-&#39;);
1276     UBool trivialNS = fields-&gt;properties-&gt;negativeSuffixPattern.isEmpty();
1277     if (!trivialPP || !trivialPS || !trivialNP || !trivialNS) {
1278         trace(&quot;no fast format: affixes\n&quot;);
1279         fields-&gt;canUseFastFormat = false;
1280         return;
1281     }
1282 
1283     // Grouping (secondary grouping is forbidden in equalsDefaultExceptFastFormat):
1284     bool groupingUsed = fields-&gt;properties-&gt;groupingUsed;
1285     int32_t groupingSize = fields-&gt;properties-&gt;groupingSize;
1286     bool unusualGroupingSize = groupingSize &gt; 0 &amp;&amp; groupingSize != 3;
1287     const UnicodeString&amp; groupingString = fields-&gt;symbols-&gt;getConstSymbol(DecimalFormatSymbols::kGroupingSeparatorSymbol);
1288     if (groupingUsed &amp;&amp; (unusualGroupingSize || groupingString.length() != 1)) {
1289         trace(&quot;no fast format: grouping\n&quot;);
1290         fields-&gt;canUseFastFormat = false;
1291         return;
1292     }
1293 
1294     // Integer length:
1295     int32_t minInt = fields-&gt;exportedProperties-&gt;minimumIntegerDigits;
1296     int32_t maxInt = fields-&gt;exportedProperties-&gt;maximumIntegerDigits;
1297     // Fastpath supports up to only 10 digits (length of INT32_MIN)
1298     if (minInt &gt; 10) {
1299         trace(&quot;no fast format: integer\n&quot;);
1300         fields-&gt;canUseFastFormat = false;
1301         return;
1302     }
1303 
1304     // Fraction length (no fraction part allowed in fast path):
1305     int32_t minFrac = fields-&gt;exportedProperties-&gt;minimumFractionDigits;
1306     if (minFrac &gt; 0) {
1307         trace(&quot;no fast format: fraction\n&quot;);
1308         fields-&gt;canUseFastFormat = false;
1309         return;
1310     }
1311 
1312     // Other symbols:
1313     const UnicodeString&amp; minusSignString = fields-&gt;symbols-&gt;getConstSymbol(DecimalFormatSymbols::kMinusSignSymbol);
1314     UChar32 codePointZero = fields-&gt;symbols-&gt;getCodePointZero();
1315     if (minusSignString.length() != 1 || U16_LENGTH(codePointZero) != 1) {
1316         trace(&quot;no fast format: symbols\n&quot;);
1317         fields-&gt;canUseFastFormat = false;
1318         return;
1319     }
1320 
1321     // Good to go!
1322     trace(&quot;can use fast format!\n&quot;);
1323     fields-&gt;canUseFastFormat = true;
1324     fields-&gt;fastData.cpZero = static_cast&lt;char16_t&gt;(codePointZero);
1325     fields-&gt;fastData.cpGroupingSeparator = groupingUsed &amp;&amp; groupingSize == 3 ? groupingString.charAt(0) : 0;
1326     fields-&gt;fastData.cpMinusSign = minusSignString.charAt(0);
1327     fields-&gt;fastData.minInt = (minInt &lt; 0 || minInt &gt; 127) ? 0 : static_cast&lt;int8_t&gt;(minInt);
1328     fields-&gt;fastData.maxInt = (maxInt &lt; 0 || maxInt &gt; 127) ? 127 : static_cast&lt;int8_t&gt;(maxInt);
1329 }
1330 
1331 bool DecimalFormat::fastFormatDouble(double input, UnicodeString&amp; output) const {
1332     if (!fields-&gt;canUseFastFormat) {
1333         return false;
1334     }
1335     if (std::isnan(input)
1336             || std::trunc(input) != input
1337             || input &lt;= INT32_MIN
1338             || input &gt; INT32_MAX) {
1339         return false;
1340     }
1341     doFastFormatInt32(static_cast&lt;int32_t&gt;(input), std::signbit(input), output);
1342     return true;
1343 }
1344 
1345 bool DecimalFormat::fastFormatInt64(int64_t input, UnicodeString&amp; output) const {
1346     if (!fields-&gt;canUseFastFormat) {
1347         return false;
1348     }
1349     if (input &lt;= INT32_MIN || input &gt; INT32_MAX) {
1350         return false;
1351     }
1352     doFastFormatInt32(static_cast&lt;int32_t&gt;(input), input &lt; 0, output);
1353     return true;
1354 }
1355 
1356 void DecimalFormat::doFastFormatInt32(int32_t input, bool isNegative, UnicodeString&amp; output) const {
1357     U_ASSERT(fields-&gt;canUseFastFormat);
1358     if (isNegative) {
1359         output.append(fields-&gt;fastData.cpMinusSign);
1360         U_ASSERT(input != INT32_MIN);  // handled by callers
1361         input = -input;
1362     }
1363     // Cap at int32_t to make the buffer small and operations fast.
1364     // Longest string: &quot;2,147,483,648&quot; (13 chars in length)
1365     static constexpr int32_t localCapacity = 13;
1366     char16_t localBuffer[localCapacity];
1367     char16_t* ptr = localBuffer + localCapacity;
1368     int8_t group = 0;
1369     for (int8_t i = 0; i &lt; fields-&gt;fastData.maxInt &amp;&amp; (input != 0 || i &lt; fields-&gt;fastData.minInt); i++) {
1370         if (group++ == 3 &amp;&amp; fields-&gt;fastData.cpGroupingSeparator != 0) {
1371             *(--ptr) = fields-&gt;fastData.cpGroupingSeparator;
1372             group = 1;
1373         }
1374         std::div_t res = std::div(input, 10);
1375         *(--ptr) = static_cast&lt;char16_t&gt;(fields-&gt;fastData.cpZero + res.rem);
1376         input = res.quot;
1377     }
1378     int32_t len = localCapacity - static_cast&lt;int32_t&gt;(ptr - localBuffer);
1379     output.append(ptr, len);
1380 }
1381 
1382 
1383 #endif /* #if !UCONFIG_NO_FORMATTING */
    </pre>
  </body>
</html>