<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uresbund.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="uprops.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uresdata.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uresbund.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   4 ******************************************************************************
   5 * Copyright (C) 1997-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 ******************************************************************************
   8 *
   9 * File uresbund.cpp
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   04/01/97    aliu        Creation.
  15 *   06/14/99    stephen     Removed functions taking a filename suffix.
  16 *   07/20/99    stephen     Changed for UResourceBundle typedef&#39;d to void*
  17 *   11/09/99    weiv            Added ures_getLocale()
  18 *   March 2000  weiv        Total overhaul - using data in DLLs
  19 *   06/20/2000  helena      OS/400 port changes; mostly typecast.
  20 *   06/24/02    weiv        Added support for resource sharing
  21 ******************************************************************************
  22 */
  23 

  24 #include &quot;unicode/ustring.h&quot;
  25 #include &quot;unicode/ucnv.h&quot;
  26 #include &quot;charstr.h&quot;
  27 #include &quot;uresimp.h&quot;
  28 #include &quot;ustr_imp.h&quot;
  29 #include &quot;cwchar.h&quot;
  30 #include &quot;ucln_cmn.h&quot;
  31 #include &quot;cmemory.h&quot;
  32 #include &quot;cstring.h&quot;
  33 #include &quot;uhash.h&quot;
  34 #include &quot;unicode/uenum.h&quot;
  35 #include &quot;uenumimp.h&quot;
  36 #include &quot;ulocimp.h&quot;
  37 #include &quot;umutex.h&quot;
  38 #include &quot;putilimp.h&quot;
  39 #include &quot;uassert.h&quot;
  40 
  41 using namespace icu;
  42 
  43 /*
  44 Static cache for already opened resource bundles - mostly for keeping fallback info
  45 TODO: This cache should probably be removed when the deprecated code is
  46       completely removed.
  47 */
  48 static UHashtable *cache = NULL;
  49 static icu::UInitOnce gCacheInitOnce;
  50 
<span class="line-modified">  51 static UMutex resbMutex = U_MUTEX_INITIALIZER;</span>



  52 
  53 /* INTERNAL: hashes an entry  */
  54 static int32_t U_CALLCONV hashEntry(const UHashTok parm) {
  55     UResourceDataEntry *b = (UResourceDataEntry *)parm.pointer;
  56     UHashTok namekey, pathkey;
  57     namekey.pointer = b-&gt;fName;
  58     pathkey.pointer = b-&gt;fPath;
  59     return uhash_hashChars(namekey)+37u*uhash_hashChars(pathkey);
  60 }
  61 
  62 /* INTERNAL: compares two entries */
  63 static UBool U_CALLCONV compareEntries(const UHashTok p1, const UHashTok p2) {
  64     UResourceDataEntry *b1 = (UResourceDataEntry *)p1.pointer;
  65     UResourceDataEntry *b2 = (UResourceDataEntry *)p2.pointer;
  66     UHashTok name1, name2, path1, path2;
  67     name1.pointer = b1-&gt;fName;
  68     name2.pointer = b2-&gt;fName;
  69     path1.pointer = b1-&gt;fPath;
  70     path2.pointer = b2-&gt;fPath;
  71     return (UBool)(uhash_compareChars(name1, name2) &amp;&amp;
</pre>
<hr />
<pre>
  75 
  76 /**
  77  *  Internal function, gets parts of locale name according
  78  *  to the position of &#39;_&#39; character
  79  */
  80 static UBool chopLocale(char *name) {
  81     char *i = uprv_strrchr(name, &#39;_&#39;);
  82 
  83     if(i != NULL) {
  84         *i = &#39;\0&#39;;
  85         return TRUE;
  86     }
  87 
  88     return FALSE;
  89 }
  90 
  91 /**
  92  *  Internal function
  93  */
  94 static void entryIncrease(UResourceDataEntry *entry) {
<span class="line-modified">  95     umtx_lock(&amp;resbMutex);</span>
  96     entry-&gt;fCountExisting++;
  97     while(entry-&gt;fParent != NULL) {
  98       entry = entry-&gt;fParent;
  99       entry-&gt;fCountExisting++;
 100     }
<span class="line-modified"> 101     umtx_unlock(&amp;resbMutex);</span>
 102 }
 103 
 104 /**
 105  *  Internal function. Tries to find a resource in given Resource
 106  *  Bundle, as well as in its parents
 107  */
 108 static const ResourceData *getFallbackData(const UResourceBundle* resBundle, const char* * resTag, UResourceDataEntry* *realData, Resource *res, UErrorCode *status) {
 109     UResourceDataEntry *resB = resBundle-&gt;fData;
 110     int32_t indexR = -1;
 111     int32_t i = 0;
 112     *res = RES_BOGUS;
 113     if(resB != NULL) {
 114         if(resB-&gt;fBogus == U_ZERO_ERROR) { /* if this resource is real, */
 115             *res = res_getTableItemByKey(&amp;(resB-&gt;fData), resB-&gt;fData.rootRes, &amp;indexR, resTag); /* try to get data from there */
 116             i++;
 117         }
 118         if(resBundle-&gt;fHasFallback == TRUE) {
 119             while(*res == RES_BOGUS &amp;&amp; resB-&gt;fParent != NULL) { /* Otherwise, we&#39;ll look in parents */
 120                 resB = resB-&gt;fParent;
 121                 if(resB-&gt;fBogus == U_ZERO_ERROR) {
</pre>
<hr />
<pre>
 163         while(alias-&gt;fAlias != NULL) {
 164             alias = alias-&gt;fAlias;
 165         }
 166         --alias-&gt;fCountExisting;
 167     }
 168     uprv_free(entry);
 169 }
 170 
 171 /* Works just like ucnv_flushCache() */
 172 static int32_t ures_flushCache()
 173 {
 174     UResourceDataEntry *resB;
 175     int32_t pos;
 176     int32_t rbDeletedNum = 0;
 177     const UHashElement *e;
 178     UBool deletedMore;
 179 
 180     /*if shared data hasn&#39;t even been lazy evaluated yet
 181     * return 0
 182     */
<span class="line-modified"> 183     umtx_lock(&amp;resbMutex);</span>
 184     if (cache == NULL) {
<span class="line-modified"> 185         umtx_unlock(&amp;resbMutex);</span>
 186         return 0;
 187     }
 188 
 189     do {
 190         deletedMore = FALSE;
 191         /*creates an enumeration to iterate through every element in the table */
 192         pos = UHASH_FIRST;
 193         while ((e = uhash_nextElement(cache, &amp;pos)) != NULL)
 194         {
 195             resB = (UResourceDataEntry *) e-&gt;value.pointer;
 196             /* Deletes only if reference counter == 0
 197              * Don&#39;t worry about the children of this node.
 198              * Those will eventually get deleted too, if not already.
 199              * Don&#39;t worry about the parents of this node.
 200              * Those will eventually get deleted too, if not already.
 201              */
 202             /* 04/05/2002 [weiv] fCountExisting should now be accurate. If it&#39;s not zero, that means that    */
 203             /* some resource bundles are still open somewhere. */
 204 
 205             if (resB-&gt;fCountExisting == 0) {
 206                 rbDeletedNum++;
 207                 deletedMore = TRUE;
 208                 uhash_removeElement(cache, e);
 209                 free_entry(resB);
 210             }
 211         }
 212         /*
 213          * Do it again to catch bundles (aliases, pool bundle) whose fCountExisting
 214          * got decremented by free_entry().
 215          */
 216     } while(deletedMore);
<span class="line-modified"> 217     umtx_unlock(&amp;resbMutex);</span>
 218 
 219     return rbDeletedNum;
 220 }
 221 
 222 #ifdef URES_DEBUG
 223 #include &lt;stdio.h&gt;
 224 
 225 U_CAPI UBool U_EXPORT2 ures_dumpCacheContents(void) {
 226   UBool cacheNotEmpty = FALSE;
 227   int32_t pos = UHASH_FIRST;
 228   const UHashElement *e;
 229   UResourceDataEntry *resB;
 230 
<span class="line-modified"> 231     umtx_lock(&amp;resbMutex);</span>
 232     if (cache == NULL) {
<span class="line-modified"> 233       umtx_unlock(&amp;resbMutex);</span>
 234       fprintf(stderr,&quot;%s:%d: RB Cache is NULL.\n&quot;, __FILE__, __LINE__);
 235       return FALSE;
 236     }
 237 
 238     while ((e = uhash_nextElement(cache, &amp;pos)) != NULL) {
 239       cacheNotEmpty=TRUE;
 240       resB = (UResourceDataEntry *) e-&gt;value.pointer;
 241       fprintf(stderr,&quot;%s:%d: RB Cache: Entry @0x%p, refcount %d, name %s:%s.  Pool 0x%p, alias 0x%p, parent 0x%p\n&quot;,
 242               __FILE__, __LINE__,
 243               (void*)resB, resB-&gt;fCountExisting,
 244               resB-&gt;fName?resB-&gt;fName:&quot;NULL&quot;,
 245               resB-&gt;fPath?resB-&gt;fPath:&quot;NULL&quot;,
 246               (void*)resB-&gt;fPool,
 247               (void*)resB-&gt;fAlias,
 248               (void*)resB-&gt;fParent);
 249     }
 250 
 251     fprintf(stderr,&quot;%s:%d: RB Cache still contains %d items.\n&quot;, __FILE__, __LINE__, uhash_count(cache));
 252 
<span class="line-modified"> 253     umtx_unlock(&amp;resbMutex);</span>
 254 
 255     return cacheNotEmpty;
 256 }
 257 
 258 #endif
 259 
 260 static UBool U_CALLCONV ures_cleanup(void)
 261 {
 262     if (cache != NULL) {
 263         ures_flushCache();
 264         uhash_close(cache);
 265         cache = NULL;
 266     }
 267     gCacheInitOnce.reset();
 268     return TRUE;
 269 }
 270 
 271 /** INTERNAL: Initializes the cache for resources */
 272 static void U_CALLCONV createCache(UErrorCode &amp;status) {
 273     U_ASSERT(cache == NULL);
</pre>
<hr />
<pre>
 351 
 352         setEntryName(r, name, status);
 353         if (U_FAILURE(*status)) {
 354             uprv_free(r);
 355             return NULL;
 356         }
 357 
 358         if(path != NULL) {
 359             r-&gt;fPath = (char *)uprv_strdup(path);
 360             if(r-&gt;fPath == NULL) {
 361                 *status = U_MEMORY_ALLOCATION_ERROR;
 362                 uprv_free(r);
 363                 return NULL;
 364             }
 365         }
 366 
 367         /* this is the actual loading */
 368         res_load(&amp;(r-&gt;fData), r-&gt;fPath, r-&gt;fName, status);
 369 
 370         if (U_FAILURE(*status)) {





 371             /* we have no such entry in dll, so it will always use fallback */
 372             *status = U_USING_FALLBACK_WARNING;
 373             r-&gt;fBogus = U_USING_FALLBACK_WARNING;
 374         } else { /* if we have a regular entry */
 375             Resource aliasres;
 376             if (r-&gt;fData.usesPoolBundle) {
 377                 r-&gt;fPool = getPoolEntry(r-&gt;fPath, status);
 378                 if (U_SUCCESS(*status)) {
 379                     const int32_t *poolIndexes = r-&gt;fPool-&gt;fData.pRoot + 1;
 380                     if(r-&gt;fData.pRoot[1 + URES_INDEX_POOL_CHECKSUM] == poolIndexes[URES_INDEX_POOL_CHECKSUM]) {
 381                         r-&gt;fData.poolBundleKeys = (const char *)(poolIndexes + (poolIndexes[URES_INDEX_LENGTH] &amp; 0xff));
 382                         r-&gt;fData.poolBundleStrings = r-&gt;fPool-&gt;fData.p16BitUnits;
 383                     } else {
 384                         r-&gt;fBogus = *status = U_INVALID_FORMAT_ERROR;
 385                     }
 386                 } else {
 387                     r-&gt;fBogus = *status;
 388                 }
 389             }
 390             if (U_SUCCESS(*status)) {
</pre>
<hr />
<pre>
 466         *isDefault = (UBool)(uprv_strncmp(name, defaultLoc, uprv_strlen(name)) == 0);
 467         hasRealData = (UBool)(r-&gt;fBogus == U_ZERO_ERROR);
 468         if(!hasRealData) {
 469             /* this entry is not real. We will discard it. */
 470             /* However, the parent line for this entry is  */
 471             /* not to be used - as there might be parent   */
 472             /* lines in cache from previous openings that  */
 473             /* are not updated yet. */
 474             r-&gt;fCountExisting--;
 475             /*entryCloseInt(r);*/
 476             r = NULL;
 477             *status = U_USING_FALLBACK_WARNING;
 478         } else {
 479             uprv_strcpy(name, r-&gt;fName); /* this is needed for supporting aliases */
 480         }
 481 
 482         *isRoot = (UBool)(uprv_strcmp(name, kRootLocaleName) == 0);
 483 
 484         /*Fallback data stuff*/
 485         *hasChopped = chopLocale(name);



 486     }
 487     return r;
 488 }
 489 
 490 static void ures_setIsStackObject( UResourceBundle* resB, UBool state) {
 491     if(state) {
 492         resB-&gt;fMagic1 = 0;
 493         resB-&gt;fMagic2 = 0;
 494     } else {
 495         resB-&gt;fMagic1 = MAGIC1;
 496         resB-&gt;fMagic2 = MAGIC2;
 497     }
 498 }
 499 
 500 static UBool ures_isStackObject(const UResourceBundle* resB) {
 501   return((resB-&gt;fMagic1 == MAGIC1 &amp;&amp; resB-&gt;fMagic2 == MAGIC2)?FALSE:TRUE);
 502 }
 503 
 504 
 505 U_CFUNC void ures_initStackObject(UResourceBundle* resB) {












 510 static UBool  // returns U_SUCCESS(*status)
 511 loadParentsExceptRoot(UResourceDataEntry *&amp;t1,
 512                       char name[], int32_t nameCapacity,
 513                       UBool usingUSRData, char usrDataPath[], UErrorCode *status) {
 514     if (U_FAILURE(*status)) { return FALSE; }
 515     UBool hasChopped = TRUE;
 516     while (hasChopped &amp;&amp; t1-&gt;fParent == NULL &amp;&amp; !t1-&gt;fData.noFallback &amp;&amp;
 517             res_getResource(&amp;t1-&gt;fData,&quot;%%ParentIsRoot&quot;) == RES_BOGUS) {
 518         Resource parentRes = res_getResource(&amp;t1-&gt;fData, &quot;%%Parent&quot;);
 519         if (parentRes != RES_BOGUS) {  // An explicit parent was found.
 520             int32_t parentLocaleLen = 0;
 521             const UChar *parentLocaleName = res_getString(&amp;(t1-&gt;fData), parentRes, &amp;parentLocaleLen);
 522             if(parentLocaleName != NULL &amp;&amp; 0 &lt; parentLocaleLen &amp;&amp; parentLocaleLen &lt; nameCapacity) {
 523                 u_UCharsToChars(parentLocaleName, name, parentLocaleLen + 1);
 524                 if (uprv_strcmp(name, kRootLocaleName) == 0) {
 525                     return TRUE;
 526                 }
 527             }
 528         }
 529         // Insert regular parents.





 540         }
 541 
 542         if (usingUSRData &amp;&amp; U_SUCCESS(usrStatus) &amp;&amp; u2-&gt;fBogus == U_ZERO_ERROR) {
 543             t1-&gt;fParent = u2;
 544             u2-&gt;fParent = t2;
 545         } else {
 546             t1-&gt;fParent = t2;
 547             if (usingUSRData) {
 548                 // The USR override data wasn&#39;t found, set it to be deleted.
 549                 u2-&gt;fCountExisting = 0;
 550             }
 551         }
 552         t1 = t2;
 553         hasChopped = chopLocale(name);
 554     }
 555     return TRUE;
 556 }
 557 
 558 static UBool  // returns U_SUCCESS(*status)
 559 insertRootBundle(UResourceDataEntry *&amp;t1, UErrorCode *status) {
</pre>
<hr />
<pre>
 620 
 621     if(U_FAILURE(*status)) {
 622         return NULL;
 623     }
 624 
 625     uprv_strncpy(name, localeID, sizeof(name) - 1);
 626     name[sizeof(name) - 1] = 0;
 627 
 628     if ( usingUSRData ) {
 629         if ( path == NULL ) {
 630             uprv_strcpy(usrDataPath, U_USRDATA_NAME);
 631         } else {
 632             uprv_strncpy(usrDataPath, path, sizeof(usrDataPath) - 1);
 633             usrDataPath[0] = &#39;u&#39;;
 634             usrDataPath[1] = &#39;s&#39;;
 635             usrDataPath[2] = &#39;r&#39;;
 636             usrDataPath[sizeof(usrDataPath) - 1] = 0;
 637         }
 638     }
 639 
<span class="line-modified"> 640     umtx_lock(&amp;resbMutex);</span>
 641     { /* umtx_lock */
 642         /* We&#39;re going to skip all the locales that do not have any data */
 643         r = findFirstExisting(path, name, &amp;isRoot, &amp;hasChopped, &amp;isDefault, &amp;intStatus);
 644 






 645         if(r != NULL) { /* if there is one real locale, we can look for parents. */
 646             t1 = r;
 647             hasRealData = TRUE;
 648             if ( usingUSRData ) {  /* This code inserts user override data into the inheritance chain */
 649                 UErrorCode usrStatus = U_ZERO_ERROR;
 650                 UResourceDataEntry *u1 = init_entry(t1-&gt;fName, usrDataPath, &amp;usrStatus);
<span class="line-modified"> 651                if ( u1 != NULL ) {</span>
<span class="line-modified"> 652                  if(u1-&gt;fBogus == U_ZERO_ERROR) {</span>
<span class="line-modified"> 653                    u1-&gt;fParent = t1;</span>
<span class="line-modified"> 654                    r = u1;</span>
<span class="line-modified"> 655                  } else {</span>
<span class="line-modified"> 656                    /* the USR override data wasn&#39;t found, set it to be deleted */</span>
<span class="line-modified"> 657                    u1-&gt;fCountExisting = 0;</span>
<span class="line-modified"> 658                  }</span>
<span class="line-modified"> 659                }</span>





 660             }
 661             if (hasChopped &amp;&amp; !isRoot) {
 662                 if (!loadParentsExceptRoot(t1, name, UPRV_LENGTHOF(name), usingUSRData, usrDataPath, status)) {
 663                     goto finishUnlock;
 664                 }
 665             }
 666         }
 667 
 668         /* we could have reached this point without having any real data */
 669         /* if that is the case, we need to chain in the default locale   */
 670         if(r==NULL &amp;&amp; openType == URES_OPEN_LOCALE_DEFAULT_ROOT &amp;&amp; !isDefault &amp;&amp; !isRoot) {
 671             /* insert default locale */
 672             uprv_strcpy(name, uloc_getDefault());
 673             r = findFirstExisting(path, name, &amp;isRoot, &amp;hasChopped, &amp;isDefault, &amp;intStatus);





 674             intStatus = U_USING_DEFAULT_WARNING;
 675             if(r != NULL) { /* the default locale exists */
 676                 t1 = r;
 677                 hasRealData = TRUE;
 678                 isDefault = TRUE;
 679                 // TODO: Why not if (usingUSRData) { ... } like in the non-default-locale code path?
 680                 if (hasChopped &amp;&amp; !isRoot) {
 681                     if (!loadParentsExceptRoot(t1, name, UPRV_LENGTHOF(name), usingUSRData, usrDataPath, status)) {
 682                         goto finishUnlock;
 683                     }
 684                 }
 685             }
 686         }
 687 
 688         /* we could still have r == NULL at this point - maybe even default locale is not */
 689         /* present */
 690         if(r == NULL) {
 691             uprv_strcpy(name, kRootLocaleName);
 692             r = findFirstExisting(path, name, &amp;isRoot, &amp;hasChopped, &amp;isDefault, &amp;intStatus);





 693             if(r != NULL) {
 694                 t1 = r;
 695                 intStatus = U_USING_DEFAULT_WARNING;
 696                 hasRealData = TRUE;
 697             } else { /* we don&#39;t even have the root locale */
 698                 *status = U_MISSING_RESOURCE_ERROR;
 699                 goto finishUnlock;
 700             }
 701         } else if(!isRoot &amp;&amp; uprv_strcmp(t1-&gt;fName, kRootLocaleName) != 0 &amp;&amp;
 702                 t1-&gt;fParent == NULL &amp;&amp; !r-&gt;fData.noFallback) {
 703             if (!insertRootBundle(t1, status)) {
 704                 goto finishUnlock;
 705             }
 706             if(!hasRealData) {
 707                 r-&gt;fBogus = U_USING_DEFAULT_WARNING;
 708             }
 709         }
 710 
 711         // TODO: Does this ever loop?
 712         while(r != NULL &amp;&amp; !isRoot &amp;&amp; t1-&gt;fParent != NULL) {
 713             t1-&gt;fParent-&gt;fCountExisting++;
 714             t1 = t1-&gt;fParent;
 715         }
 716     } /* umtx_lock */
 717 finishUnlock:
<span class="line-modified"> 718     umtx_unlock(&amp;resbMutex);</span>
 719 
 720     if(U_SUCCESS(*status)) {
 721         if(intStatus != U_ZERO_ERROR) {
 722             *status = intStatus;
 723         }
 724         return r;
 725     } else {
 726         return NULL;
 727     }
 728 }
 729 
 730 /**
 731  * Version of entryOpen() and findFirstExisting() for ures_openDirect(),
 732  * with no fallbacks.
 733  * Parent and root locale bundles are loaded if
 734  * the requested bundle does not have the &quot;nofallback&quot; flag.
 735  */
 736 static UResourceDataEntry *
 737 entryOpenDirect(const char* path, const char* localeID, UErrorCode* status) {
 738     initCache(status);
 739     if(U_FAILURE(*status)) {
 740         return NULL;
 741     }
 742 
<span class="line-modified"> 743     umtx_lock(&amp;resbMutex);</span>
 744     // findFirstExisting() without fallbacks.
 745     UResourceDataEntry *r = init_entry(localeID, path, status);
 746     if(U_SUCCESS(*status)) {
 747         if(r-&gt;fBogus != U_ZERO_ERROR) {
 748             r-&gt;fCountExisting--;
 749             r = NULL;
 750         }
 751     } else {
 752         r = NULL;
 753     }
 754 
 755     // Some code depends on the ures_openDirect() bundle to have a parent bundle chain,
 756     // unless it is marked with &quot;nofallback&quot;.
 757     UResourceDataEntry *t1 = r;
 758     if(r != NULL &amp;&amp; uprv_strcmp(localeID, kRootLocaleName) != 0 &amp;&amp;  // not root
 759             r-&gt;fParent == NULL &amp;&amp; !r-&gt;fData.noFallback &amp;&amp;
 760             uprv_strlen(localeID) &lt; ULOC_FULLNAME_CAPACITY) {
 761         char name[ULOC_FULLNAME_CAPACITY];
 762         uprv_strcpy(name, localeID);
 763         if(!chopLocale(name) || uprv_strcmp(name, kRootLocaleName) == 0 ||
 764                 loadParentsExceptRoot(t1, name, UPRV_LENGTHOF(name), FALSE, NULL, status)) {
 765             if(uprv_strcmp(t1-&gt;fName, kRootLocaleName) != 0 &amp;&amp; t1-&gt;fParent == NULL) {
 766                 insertRootBundle(t1, status);
 767             }
 768         }
 769         if(U_FAILURE(*status)) {
 770             r = NULL;
 771         }
 772     }
 773 
 774     if(r != NULL) {
 775         // TODO: Does this ever loop?
 776         while(t1-&gt;fParent != NULL) {
 777             t1-&gt;fParent-&gt;fCountExisting++;
 778             t1 = t1-&gt;fParent;
 779         }
 780     }
<span class="line-modified"> 781     umtx_unlock(&amp;resbMutex);</span>
 782     return r;
 783 }
 784 
 785 /**
 786  * Functions to create and destroy resource bundles.
 787  *     CAUTION:  resbMutex must be locked when calling this function.
 788  */
 789 /* INTERNAL: */
 790 static void entryCloseInt(UResourceDataEntry *resB) {
 791     UResourceDataEntry *p = resB;
 792 
 793     while(resB != NULL) {
 794         p = resB-&gt;fParent;
 795         resB-&gt;fCountExisting--;
 796 
 797         /* Entries are left in the cache. TODO: add ures_flushCache() to force a flush
 798          of the cache. */
 799 /*
 800         if(resB-&gt;fCountExisting &lt;= 0) {
 801             uhash_remove(cache, resB);
</pre>
<hr />
<pre>
 804             }
 805             if(resB-&gt;fName != NULL) {
 806                 uprv_free(resB-&gt;fName);
 807             }
 808             if(resB-&gt;fPath != NULL) {
 809                 uprv_free(resB-&gt;fPath);
 810             }
 811             uprv_free(resB);
 812         }
 813 */
 814 
 815         resB = p;
 816     }
 817 }
 818 
 819 /**
 820  *  API: closes a resource bundle and cleans up.
 821  */
 822 
 823 static void entryClose(UResourceDataEntry *resB) {
<span class="line-modified"> 824   umtx_lock(&amp;resbMutex);</span>
 825   entryCloseInt(resB);
<span class="line-modified"> 826   umtx_unlock(&amp;resbMutex);</span>
 827 }
 828 
 829 /*
 830 U_CFUNC void ures_setResPath(UResourceBundle *resB, const char* toAdd) {
 831   if(resB-&gt;fResPath == NULL) {
 832     resB-&gt;fResPath = resB-&gt;fResBuf;
 833     *(resB-&gt;fResPath) = 0;
 834   }
 835   resB-&gt;fResPathLen = uprv_strlen(toAdd);
 836   if(RES_BUFSIZE &lt;= resB-&gt;fResPathLen+1) {
 837     if(resB-&gt;fResPath == resB-&gt;fResBuf) {
 838       resB-&gt;fResPath = (char *)uprv_malloc((resB-&gt;fResPathLen+1)*sizeof(char));
 839     } else {
 840       resB-&gt;fResPath = (char *)uprv_realloc(resB-&gt;fResPath, (resB-&gt;fResPathLen+1)*sizeof(char));
 841     }
 842   }
 843   uprv_strcpy(resB-&gt;fResPath, toAdd);
 844 }
 845 */
 846 static void ures_appendResPath(UResourceBundle *resB, const char* toAdd, int32_t lenToAdd, UErrorCode *status) {
</pre>
<hr />
<pre>
1062                                     r = res_getArrayItem(&amp;(mainRes-&gt;fResData), r, idx);
1063                                 }
1064                             }
1065                             if(r != RES_BOGUS) {
1066                                 result = init_resb_result(&amp;(mainRes-&gt;fResData), r, temp, -1, mainRes-&gt;fData, mainRes, noAlias+1, resB, status);
1067                             } else {
1068                                 *status = U_MISSING_RESOURCE_ERROR;
1069                                 result = resB;
1070                             }
1071                         } else {
1072                             /* this one is a bit trickier.
1073                             * we start finding keys, but after we resolve one alias, the path might continue.
1074                             * Consider:
1075                             *     aliastest:alias { &quot;testtypes/anotheralias/Sequence&quot; }
1076                             *     anotheralias:alias { &quot;/ICUDATA/sh/CollationElements&quot; }
1077                             * aliastest resource should finally have the sequence, not collation elements.
1078                             */
1079                             UResourceDataEntry *dataEntry = mainRes-&gt;fData;
1080                             char stackPath[URES_MAX_BUFFER_SIZE];
1081                             char *pathBuf = stackPath, *myPath = pathBuf;
<span class="line-modified">1082                             if(uprv_strlen(keyPath) &gt; URES_MAX_BUFFER_SIZE) {</span>
1083                                 pathBuf = (char *)uprv_malloc((uprv_strlen(keyPath)+1)*sizeof(char));
1084                                 if(pathBuf == NULL) {
1085                                     *status = U_MEMORY_ALLOCATION_ERROR;
1086                                     ures_close(mainRes);
1087                                     return NULL;
1088                                 }
1089                             }
1090                             uprv_strcpy(pathBuf, keyPath);
1091                             result = mainRes;
1092                             /* now we have fallback following here */
1093                             do {
1094                                 r = dataEntry-&gt;fData.rootRes;
1095                                 /* this loop handles &#39;found&#39; resources over several levels */
1096                                 while(*myPath &amp;&amp; U_SUCCESS(*status)) {
1097                                     r = res_findResource(&amp;(dataEntry-&gt;fData), r, &amp;myPath, &amp;temp);
1098                                     if(r != RES_BOGUS) { /* found a resource, but it might be an indirection */
1099                                         resB = init_resb_result(&amp;(dataEntry-&gt;fData), r, temp, -1, dataEntry, result, noAlias+1, resB, status);
1100                                         result = resB;
1101                                         if(result) {
1102                                             r = result-&gt;fRes; /* switch to a new resource, possibly a new tree */
</pre>
<hr />
<pre>
2252 U_CAPI UResourceBundle* U_EXPORT2
2253 ures_open(const char* path, const char* localeID, UErrorCode* status) {
2254     return ures_openWithType(NULL, path, localeID, URES_OPEN_LOCALE_DEFAULT_ROOT, status);
2255 }
2256 
2257 U_CAPI UResourceBundle* U_EXPORT2
2258 ures_openNoDefault(const char* path, const char* localeID, UErrorCode* status) {
2259     return ures_openWithType(NULL, path, localeID, URES_OPEN_LOCALE_ROOT, status);
2260 }
2261 
2262 /**
2263  *  Opens a resource bundle without &quot;canonicalizing&quot; the locale name. No fallback will be performed
2264  *  or sought. However, alias substitution will happen!
2265  */
2266 U_CAPI UResourceBundle*  U_EXPORT2
2267 ures_openDirect(const char* path, const char* localeID, UErrorCode* status) {
2268     return ures_openWithType(NULL, path, localeID, URES_OPEN_DIRECT, status);
2269 }
2270 
2271 /**
<span class="line-modified">2272  *  API: This function is used to open a resource bundle</span>
2273  *  proper fallback chaining is executed while initialization.
2274  *  The result is stored in cache for later fallback search.


2275  */
<span class="line-modified">2276 U_CAPI void U_EXPORT2</span>
2277 ures_openFillIn(UResourceBundle *r, const char* path,
2278                 const char* localeID, UErrorCode* status) {
2279     if(U_SUCCESS(*status) &amp;&amp; r == NULL) {
2280         *status = U_ILLEGAL_ARGUMENT_ERROR;
2281         return;
2282     }
2283     ures_openWithType(r, path, localeID, URES_OPEN_LOCALE_DEFAULT_ROOT, status);
2284 }
2285 












2286 /**
2287  *  API: Counts members. For arrays and tables, returns number of resources.
2288  *  For strings, returns 1.
2289  */
2290 U_CAPI int32_t  U_EXPORT2
2291 ures_countArrayItems(const UResourceBundle* resourceBundle,
2292                   const char* resourceKey,
2293                   UErrorCode* status)
2294 {
2295     UResourceBundle resData;
2296     ures_initStackObject(&amp;resData);
2297     if (status==NULL || U_FAILURE(*status)) {
2298         return 0;
2299     }
2300     if(resourceBundle == NULL) {
2301         *status = U_ILLEGAL_ARGUMENT_ERROR;
2302         return 0;
2303     }
2304     ures_getByKey(resourceBundle, resourceKey, &amp;resData, status);
2305 
</pre>
<hr />
<pre>
2404 }
2405 
2406 static int32_t U_CALLCONV
2407 ures_loc_countLocales(UEnumeration *en, UErrorCode * /*status*/) {
2408     ULocalesContext *ctx = (ULocalesContext *)en-&gt;context;
2409     return ures_getSize(&amp;ctx-&gt;installed);
2410 }
2411 
2412 U_CDECL_BEGIN
2413 
2414 
2415 static const char * U_CALLCONV
2416 ures_loc_nextLocale(UEnumeration* en,
2417                     int32_t* resultLength,
2418                     UErrorCode* status) {
2419     ULocalesContext *ctx = (ULocalesContext *)en-&gt;context;
2420     UResourceBundle *res = &amp;(ctx-&gt;installed);
2421     UResourceBundle *k = NULL;
2422     const char *result = NULL;
2423     int32_t len = 0;
<span class="line-modified">2424     if(ures_hasNext(res) &amp;&amp; (k = ures_getNextResource(res, &amp;ctx-&gt;curr, status))) {</span>
2425         result = ures_getKey(k);
2426         len = (int32_t)uprv_strlen(result);
2427     }
2428     if (resultLength) {
2429         *resultLength = len;
2430     }
2431     return result;
2432 }
2433 
2434 static void U_CALLCONV
2435 ures_loc_resetLocales(UEnumeration* en,
2436                       UErrorCode* /*status*/) {
2437     UResourceBundle *res = &amp;((ULocalesContext *)en-&gt;context)-&gt;installed;
2438     ures_resetIterator(res);
2439 }
2440 
2441 U_CDECL_END
2442 
2443 static const UEnumeration gLocalesEnum = {
2444     NULL,
</pre>
<hr />
<pre>
2826     int32_t     locLen;
2827 
2828     UEnumeration *locs = NULL;
2829 
2830     UResourceBundle    item;
2831     UResourceBundle    subItem;
2832 
2833     ures_initStackObject(&amp;item);
2834     ures_initStackObject(&amp;subItem);
2835     locs = ures_openAvailableLocales(path, status);
2836 
2837     if(U_FAILURE(*status)) {
2838         ures_close(&amp;item);
2839         ures_close(&amp;subItem);
2840         return NULL;
2841     }
2842 
2843     valuesBuf[0]=0;
2844     valuesBuf[1]=0;
2845 
<span class="line-modified">2846     while((locale = uenum_next(locs, &amp;locLen, status))) {</span>
2847         UResourceBundle   *bund = NULL;
2848         UResourceBundle   *subPtr = NULL;
2849         UErrorCode subStatus = U_ZERO_ERROR; /* don&#39;t fail if a bundle is unopenable */
2850         bund = ures_openDirect(path, locale, &amp;subStatus);
2851 
2852 #if defined(URES_TREE_DEBUG)
2853         if(!bund || U_FAILURE(subStatus)) {
2854             fprintf(stderr, &quot;%s-%s values: Can&#39;t open %s locale - skipping. (%s)\n&quot;,
2855                 path?path:&quot;&lt;ICUDATA&gt;&quot;, keyword, locale, u_errorName(subStatus));
2856         }
2857 #endif
2858 
2859         ures_getByKey(bund, keyword, &amp;item, &amp;subStatus);
2860 
2861         if(!bund || U_FAILURE(subStatus)) {
2862 #if defined(URES_TREE_DEBUG)
2863             fprintf(stderr, &quot;%s-%s values: Can&#39;t find in %s - skipping. (%s)\n&quot;,
2864                 path?path:&quot;&lt;ICUDATA&gt;&quot;, keyword, locale, u_errorName(subStatus));
2865 #endif
2866             ures_close(bund);
2867             bund = NULL;
2868             continue;
2869         }
2870 
<span class="line-modified">2871         while((subPtr = ures_getNextResource(&amp;item,&amp;subItem,&amp;subStatus))</span>
2872             &amp;&amp; U_SUCCESS(subStatus)) {
2873             const char *k;
2874             int32_t i;
2875             k = ures_getKey(subPtr);
2876 
2877 #if defined(URES_TREE_DEBUG)
2878             /* fprintf(stderr, &quot;%s | %s | %s | %s\n&quot;, path?path:&quot;&lt;ICUDATA&gt;&quot;, keyword, locale, k); */
2879 #endif
2880             if(k == NULL || *k == 0 ||
2881                     uprv_strcmp(k, DEFAULT_TAG) == 0 || uprv_strncmp(k, &quot;private-&quot;, 8) == 0) {
2882                 // empty or &quot;default&quot; or unlisted type
2883                 continue;
2884             }
2885             for(i=0; i&lt;valuesCount; i++) {
2886                 if(!uprv_strcmp(valuesList[i],k)) {
2887                     k = NULL; /* found duplicate */
2888                     break;
2889                 }
2890             }
2891             if(k != NULL) {
</pre>
</td>
<td>
<hr />
<pre>
   4 ******************************************************************************
   5 * Copyright (C) 1997-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 ******************************************************************************
   8 *
   9 * File uresbund.cpp
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   04/01/97    aliu        Creation.
  15 *   06/14/99    stephen     Removed functions taking a filename suffix.
  16 *   07/20/99    stephen     Changed for UResourceBundle typedef&#39;d to void*
  17 *   11/09/99    weiv            Added ures_getLocale()
  18 *   March 2000  weiv        Total overhaul - using data in DLLs
  19 *   06/20/2000  helena      OS/400 port changes; mostly typecast.
  20 *   06/24/02    weiv        Added support for resource sharing
  21 ******************************************************************************
  22 */
  23 
<span class="line-added">  24 #include &quot;unicode/ures.h&quot;</span>
  25 #include &quot;unicode/ustring.h&quot;
  26 #include &quot;unicode/ucnv.h&quot;
  27 #include &quot;charstr.h&quot;
  28 #include &quot;uresimp.h&quot;
  29 #include &quot;ustr_imp.h&quot;
  30 #include &quot;cwchar.h&quot;
  31 #include &quot;ucln_cmn.h&quot;
  32 #include &quot;cmemory.h&quot;
  33 #include &quot;cstring.h&quot;
  34 #include &quot;uhash.h&quot;
  35 #include &quot;unicode/uenum.h&quot;
  36 #include &quot;uenumimp.h&quot;
  37 #include &quot;ulocimp.h&quot;
  38 #include &quot;umutex.h&quot;
  39 #include &quot;putilimp.h&quot;
  40 #include &quot;uassert.h&quot;
  41 
  42 using namespace icu;
  43 
  44 /*
  45 Static cache for already opened resource bundles - mostly for keeping fallback info
  46 TODO: This cache should probably be removed when the deprecated code is
  47       completely removed.
  48 */
  49 static UHashtable *cache = NULL;
  50 static icu::UInitOnce gCacheInitOnce;
  51 
<span class="line-modified">  52 static UMutex *resbMutex() {</span>
<span class="line-added">  53     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added">  54     return &amp;m;</span>
<span class="line-added">  55 }</span>
  56 
  57 /* INTERNAL: hashes an entry  */
  58 static int32_t U_CALLCONV hashEntry(const UHashTok parm) {
  59     UResourceDataEntry *b = (UResourceDataEntry *)parm.pointer;
  60     UHashTok namekey, pathkey;
  61     namekey.pointer = b-&gt;fName;
  62     pathkey.pointer = b-&gt;fPath;
  63     return uhash_hashChars(namekey)+37u*uhash_hashChars(pathkey);
  64 }
  65 
  66 /* INTERNAL: compares two entries */
  67 static UBool U_CALLCONV compareEntries(const UHashTok p1, const UHashTok p2) {
  68     UResourceDataEntry *b1 = (UResourceDataEntry *)p1.pointer;
  69     UResourceDataEntry *b2 = (UResourceDataEntry *)p2.pointer;
  70     UHashTok name1, name2, path1, path2;
  71     name1.pointer = b1-&gt;fName;
  72     name2.pointer = b2-&gt;fName;
  73     path1.pointer = b1-&gt;fPath;
  74     path2.pointer = b2-&gt;fPath;
  75     return (UBool)(uhash_compareChars(name1, name2) &amp;&amp;
</pre>
<hr />
<pre>
  79 
  80 /**
  81  *  Internal function, gets parts of locale name according
  82  *  to the position of &#39;_&#39; character
  83  */
  84 static UBool chopLocale(char *name) {
  85     char *i = uprv_strrchr(name, &#39;_&#39;);
  86 
  87     if(i != NULL) {
  88         *i = &#39;\0&#39;;
  89         return TRUE;
  90     }
  91 
  92     return FALSE;
  93 }
  94 
  95 /**
  96  *  Internal function
  97  */
  98 static void entryIncrease(UResourceDataEntry *entry) {
<span class="line-modified">  99     umtx_lock(resbMutex());</span>
 100     entry-&gt;fCountExisting++;
 101     while(entry-&gt;fParent != NULL) {
 102       entry = entry-&gt;fParent;
 103       entry-&gt;fCountExisting++;
 104     }
<span class="line-modified"> 105     umtx_unlock(resbMutex());</span>
 106 }
 107 
 108 /**
 109  *  Internal function. Tries to find a resource in given Resource
 110  *  Bundle, as well as in its parents
 111  */
 112 static const ResourceData *getFallbackData(const UResourceBundle* resBundle, const char* * resTag, UResourceDataEntry* *realData, Resource *res, UErrorCode *status) {
 113     UResourceDataEntry *resB = resBundle-&gt;fData;
 114     int32_t indexR = -1;
 115     int32_t i = 0;
 116     *res = RES_BOGUS;
 117     if(resB != NULL) {
 118         if(resB-&gt;fBogus == U_ZERO_ERROR) { /* if this resource is real, */
 119             *res = res_getTableItemByKey(&amp;(resB-&gt;fData), resB-&gt;fData.rootRes, &amp;indexR, resTag); /* try to get data from there */
 120             i++;
 121         }
 122         if(resBundle-&gt;fHasFallback == TRUE) {
 123             while(*res == RES_BOGUS &amp;&amp; resB-&gt;fParent != NULL) { /* Otherwise, we&#39;ll look in parents */
 124                 resB = resB-&gt;fParent;
 125                 if(resB-&gt;fBogus == U_ZERO_ERROR) {
</pre>
<hr />
<pre>
 167         while(alias-&gt;fAlias != NULL) {
 168             alias = alias-&gt;fAlias;
 169         }
 170         --alias-&gt;fCountExisting;
 171     }
 172     uprv_free(entry);
 173 }
 174 
 175 /* Works just like ucnv_flushCache() */
 176 static int32_t ures_flushCache()
 177 {
 178     UResourceDataEntry *resB;
 179     int32_t pos;
 180     int32_t rbDeletedNum = 0;
 181     const UHashElement *e;
 182     UBool deletedMore;
 183 
 184     /*if shared data hasn&#39;t even been lazy evaluated yet
 185     * return 0
 186     */
<span class="line-modified"> 187     umtx_lock(resbMutex());</span>
 188     if (cache == NULL) {
<span class="line-modified"> 189         umtx_unlock(resbMutex());</span>
 190         return 0;
 191     }
 192 
 193     do {
 194         deletedMore = FALSE;
 195         /*creates an enumeration to iterate through every element in the table */
 196         pos = UHASH_FIRST;
 197         while ((e = uhash_nextElement(cache, &amp;pos)) != NULL)
 198         {
 199             resB = (UResourceDataEntry *) e-&gt;value.pointer;
 200             /* Deletes only if reference counter == 0
 201              * Don&#39;t worry about the children of this node.
 202              * Those will eventually get deleted too, if not already.
 203              * Don&#39;t worry about the parents of this node.
 204              * Those will eventually get deleted too, if not already.
 205              */
 206             /* 04/05/2002 [weiv] fCountExisting should now be accurate. If it&#39;s not zero, that means that    */
 207             /* some resource bundles are still open somewhere. */
 208 
 209             if (resB-&gt;fCountExisting == 0) {
 210                 rbDeletedNum++;
 211                 deletedMore = TRUE;
 212                 uhash_removeElement(cache, e);
 213                 free_entry(resB);
 214             }
 215         }
 216         /*
 217          * Do it again to catch bundles (aliases, pool bundle) whose fCountExisting
 218          * got decremented by free_entry().
 219          */
 220     } while(deletedMore);
<span class="line-modified"> 221     umtx_unlock(resbMutex());</span>
 222 
 223     return rbDeletedNum;
 224 }
 225 
 226 #ifdef URES_DEBUG
 227 #include &lt;stdio.h&gt;
 228 
 229 U_CAPI UBool U_EXPORT2 ures_dumpCacheContents(void) {
 230   UBool cacheNotEmpty = FALSE;
 231   int32_t pos = UHASH_FIRST;
 232   const UHashElement *e;
 233   UResourceDataEntry *resB;
 234 
<span class="line-modified"> 235     umtx_lock(resbMutex());</span>
 236     if (cache == NULL) {
<span class="line-modified"> 237       umtx_unlock(resbMutex());</span>
 238       fprintf(stderr,&quot;%s:%d: RB Cache is NULL.\n&quot;, __FILE__, __LINE__);
 239       return FALSE;
 240     }
 241 
 242     while ((e = uhash_nextElement(cache, &amp;pos)) != NULL) {
 243       cacheNotEmpty=TRUE;
 244       resB = (UResourceDataEntry *) e-&gt;value.pointer;
 245       fprintf(stderr,&quot;%s:%d: RB Cache: Entry @0x%p, refcount %d, name %s:%s.  Pool 0x%p, alias 0x%p, parent 0x%p\n&quot;,
 246               __FILE__, __LINE__,
 247               (void*)resB, resB-&gt;fCountExisting,
 248               resB-&gt;fName?resB-&gt;fName:&quot;NULL&quot;,
 249               resB-&gt;fPath?resB-&gt;fPath:&quot;NULL&quot;,
 250               (void*)resB-&gt;fPool,
 251               (void*)resB-&gt;fAlias,
 252               (void*)resB-&gt;fParent);
 253     }
 254 
 255     fprintf(stderr,&quot;%s:%d: RB Cache still contains %d items.\n&quot;, __FILE__, __LINE__, uhash_count(cache));
 256 
<span class="line-modified"> 257     umtx_unlock(resbMutex());</span>
 258 
 259     return cacheNotEmpty;
 260 }
 261 
 262 #endif
 263 
 264 static UBool U_CALLCONV ures_cleanup(void)
 265 {
 266     if (cache != NULL) {
 267         ures_flushCache();
 268         uhash_close(cache);
 269         cache = NULL;
 270     }
 271     gCacheInitOnce.reset();
 272     return TRUE;
 273 }
 274 
 275 /** INTERNAL: Initializes the cache for resources */
 276 static void U_CALLCONV createCache(UErrorCode &amp;status) {
 277     U_ASSERT(cache == NULL);
</pre>
<hr />
<pre>
 355 
 356         setEntryName(r, name, status);
 357         if (U_FAILURE(*status)) {
 358             uprv_free(r);
 359             return NULL;
 360         }
 361 
 362         if(path != NULL) {
 363             r-&gt;fPath = (char *)uprv_strdup(path);
 364             if(r-&gt;fPath == NULL) {
 365                 *status = U_MEMORY_ALLOCATION_ERROR;
 366                 uprv_free(r);
 367                 return NULL;
 368             }
 369         }
 370 
 371         /* this is the actual loading */
 372         res_load(&amp;(r-&gt;fData), r-&gt;fPath, r-&gt;fName, status);
 373 
 374         if (U_FAILURE(*status)) {
<span class="line-added"> 375             /* if we failed to load due to an out-of-memory error, exit early. */</span>
<span class="line-added"> 376             if (*status == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added"> 377                 uprv_free(r);</span>
<span class="line-added"> 378                 return NULL;</span>
<span class="line-added"> 379             }</span>
 380             /* we have no such entry in dll, so it will always use fallback */
 381             *status = U_USING_FALLBACK_WARNING;
 382             r-&gt;fBogus = U_USING_FALLBACK_WARNING;
 383         } else { /* if we have a regular entry */
 384             Resource aliasres;
 385             if (r-&gt;fData.usesPoolBundle) {
 386                 r-&gt;fPool = getPoolEntry(r-&gt;fPath, status);
 387                 if (U_SUCCESS(*status)) {
 388                     const int32_t *poolIndexes = r-&gt;fPool-&gt;fData.pRoot + 1;
 389                     if(r-&gt;fData.pRoot[1 + URES_INDEX_POOL_CHECKSUM] == poolIndexes[URES_INDEX_POOL_CHECKSUM]) {
 390                         r-&gt;fData.poolBundleKeys = (const char *)(poolIndexes + (poolIndexes[URES_INDEX_LENGTH] &amp; 0xff));
 391                         r-&gt;fData.poolBundleStrings = r-&gt;fPool-&gt;fData.p16BitUnits;
 392                     } else {
 393                         r-&gt;fBogus = *status = U_INVALID_FORMAT_ERROR;
 394                     }
 395                 } else {
 396                     r-&gt;fBogus = *status;
 397                 }
 398             }
 399             if (U_SUCCESS(*status)) {
</pre>
<hr />
<pre>
 475         *isDefault = (UBool)(uprv_strncmp(name, defaultLoc, uprv_strlen(name)) == 0);
 476         hasRealData = (UBool)(r-&gt;fBogus == U_ZERO_ERROR);
 477         if(!hasRealData) {
 478             /* this entry is not real. We will discard it. */
 479             /* However, the parent line for this entry is  */
 480             /* not to be used - as there might be parent   */
 481             /* lines in cache from previous openings that  */
 482             /* are not updated yet. */
 483             r-&gt;fCountExisting--;
 484             /*entryCloseInt(r);*/
 485             r = NULL;
 486             *status = U_USING_FALLBACK_WARNING;
 487         } else {
 488             uprv_strcpy(name, r-&gt;fName); /* this is needed for supporting aliases */
 489         }
 490 
 491         *isRoot = (UBool)(uprv_strcmp(name, kRootLocaleName) == 0);
 492 
 493         /*Fallback data stuff*/
 494         *hasChopped = chopLocale(name);
<span class="line-added"> 495         if (*hasChopped &amp;&amp; *name == &#39;\0&#39;) {</span>
<span class="line-added"> 496             uprv_strcpy(name, &quot;und&quot;);</span>
<span class="line-added"> 497         }</span>
 498     }
 499     return r;
 500 }
 501 
 502 static void ures_setIsStackObject( UResourceBundle* resB, UBool state) {
 503     if(state) {
 504         resB-&gt;fMagic1 = 0;
 505         resB-&gt;fMagic2 = 0;
 506     } else {
 507         resB-&gt;fMagic1 = MAGIC1;
 508         resB-&gt;fMagic2 = MAGIC2;
 509     }
 510 }
 511 
 512 static UBool ures_isStackObject(const UResourceBundle* resB) {
 513   return((resB-&gt;fMagic1 == MAGIC1 &amp;&amp; resB-&gt;fMagic2 == MAGIC2)?FALSE:TRUE);
 514 }
 515 
 516 
 517 U_CFUNC void ures_initStackObject(UResourceBundle* resB) {
<span class="line-added"> 522 U_NAMESPACE_BEGIN</span>
<span class="line-added"> 523 </span>
<span class="line-added"> 524 StackUResourceBundle::StackUResourceBundle() {</span>
<span class="line-added"> 525     ures_initStackObject(&amp;bundle);</span>
<span class="line-added"> 526 }</span>
<span class="line-added"> 527 </span>
<span class="line-added"> 528 StackUResourceBundle::~StackUResourceBundle() {</span>
<span class="line-added"> 529     ures_close(&amp;bundle);</span>
<span class="line-added"> 530 }</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532 U_NAMESPACE_END</span>
<span class="line-added"> 533 </span>
 534 static UBool  // returns U_SUCCESS(*status)
 535 loadParentsExceptRoot(UResourceDataEntry *&amp;t1,
 536                       char name[], int32_t nameCapacity,
 537                       UBool usingUSRData, char usrDataPath[], UErrorCode *status) {
 538     if (U_FAILURE(*status)) { return FALSE; }
 539     UBool hasChopped = TRUE;
 540     while (hasChopped &amp;&amp; t1-&gt;fParent == NULL &amp;&amp; !t1-&gt;fData.noFallback &amp;&amp;
 541             res_getResource(&amp;t1-&gt;fData,&quot;%%ParentIsRoot&quot;) == RES_BOGUS) {
 542         Resource parentRes = res_getResource(&amp;t1-&gt;fData, &quot;%%Parent&quot;);
 543         if (parentRes != RES_BOGUS) {  // An explicit parent was found.
 544             int32_t parentLocaleLen = 0;
 545             const UChar *parentLocaleName = res_getString(&amp;(t1-&gt;fData), parentRes, &amp;parentLocaleLen);
 546             if(parentLocaleName != NULL &amp;&amp; 0 &lt; parentLocaleLen &amp;&amp; parentLocaleLen &lt; nameCapacity) {
 547                 u_UCharsToChars(parentLocaleName, name, parentLocaleLen + 1);
 548                 if (uprv_strcmp(name, kRootLocaleName) == 0) {
 549                     return TRUE;
 550                 }
 551             }
 552         }
 553         // Insert regular parents.
<span class="line-added"> 564             // If we failed due to out-of-memory, report that to the caller and exit early.</span>
<span class="line-added"> 565             if (usrStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added"> 566                 *status = usrStatus;</span>
<span class="line-added"> 567                 return FALSE;</span>
<span class="line-added"> 568             }</span>
 569         }
 570 
 571         if (usingUSRData &amp;&amp; U_SUCCESS(usrStatus) &amp;&amp; u2-&gt;fBogus == U_ZERO_ERROR) {
 572             t1-&gt;fParent = u2;
 573             u2-&gt;fParent = t2;
 574         } else {
 575             t1-&gt;fParent = t2;
 576             if (usingUSRData) {
 577                 // The USR override data wasn&#39;t found, set it to be deleted.
 578                 u2-&gt;fCountExisting = 0;
 579             }
 580         }
 581         t1 = t2;
 582         hasChopped = chopLocale(name);
 583     }
 584     return TRUE;
 585 }
 586 
 587 static UBool  // returns U_SUCCESS(*status)
 588 insertRootBundle(UResourceDataEntry *&amp;t1, UErrorCode *status) {
</pre>
<hr />
<pre>
 649 
 650     if(U_FAILURE(*status)) {
 651         return NULL;
 652     }
 653 
 654     uprv_strncpy(name, localeID, sizeof(name) - 1);
 655     name[sizeof(name) - 1] = 0;
 656 
 657     if ( usingUSRData ) {
 658         if ( path == NULL ) {
 659             uprv_strcpy(usrDataPath, U_USRDATA_NAME);
 660         } else {
 661             uprv_strncpy(usrDataPath, path, sizeof(usrDataPath) - 1);
 662             usrDataPath[0] = &#39;u&#39;;
 663             usrDataPath[1] = &#39;s&#39;;
 664             usrDataPath[2] = &#39;r&#39;;
 665             usrDataPath[sizeof(usrDataPath) - 1] = 0;
 666         }
 667     }
 668 
<span class="line-modified"> 669     umtx_lock(resbMutex());</span>
 670     { /* umtx_lock */
 671         /* We&#39;re going to skip all the locales that do not have any data */
 672         r = findFirstExisting(path, name, &amp;isRoot, &amp;hasChopped, &amp;isDefault, &amp;intStatus);
 673 
<span class="line-added"> 674         // If we failed due to out-of-memory, report the failure and exit early.</span>
<span class="line-added"> 675         if (intStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added"> 676             *status = intStatus;</span>
<span class="line-added"> 677             goto finishUnlock;</span>
<span class="line-added"> 678         }</span>
<span class="line-added"> 679 </span>
 680         if(r != NULL) { /* if there is one real locale, we can look for parents. */
 681             t1 = r;
 682             hasRealData = TRUE;
 683             if ( usingUSRData ) {  /* This code inserts user override data into the inheritance chain */
 684                 UErrorCode usrStatus = U_ZERO_ERROR;
 685                 UResourceDataEntry *u1 = init_entry(t1-&gt;fName, usrDataPath, &amp;usrStatus);
<span class="line-modified"> 686                 // If we failed due to out-of-memory, report the failure and exit early.</span>
<span class="line-modified"> 687                 if (intStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-modified"> 688                     *status = intStatus;</span>
<span class="line-modified"> 689                     goto finishUnlock;</span>
<span class="line-modified"> 690                 }</span>
<span class="line-modified"> 691                 if ( u1 != NULL ) {</span>
<span class="line-modified"> 692                     if(u1-&gt;fBogus == U_ZERO_ERROR) {</span>
<span class="line-modified"> 693                         u1-&gt;fParent = t1;</span>
<span class="line-modified"> 694                         r = u1;</span>
<span class="line-added"> 695                     } else {</span>
<span class="line-added"> 696                         /* the USR override data wasn&#39;t found, set it to be deleted */</span>
<span class="line-added"> 697                         u1-&gt;fCountExisting = 0;</span>
<span class="line-added"> 698                     }</span>
<span class="line-added"> 699                 }</span>
 700             }
 701             if (hasChopped &amp;&amp; !isRoot) {
 702                 if (!loadParentsExceptRoot(t1, name, UPRV_LENGTHOF(name), usingUSRData, usrDataPath, status)) {
 703                     goto finishUnlock;
 704                 }
 705             }
 706         }
 707 
 708         /* we could have reached this point without having any real data */
 709         /* if that is the case, we need to chain in the default locale   */
 710         if(r==NULL &amp;&amp; openType == URES_OPEN_LOCALE_DEFAULT_ROOT &amp;&amp; !isDefault &amp;&amp; !isRoot) {
 711             /* insert default locale */
 712             uprv_strcpy(name, uloc_getDefault());
 713             r = findFirstExisting(path, name, &amp;isRoot, &amp;hasChopped, &amp;isDefault, &amp;intStatus);
<span class="line-added"> 714             // If we failed due to out-of-memory, report the failure and exit early.</span>
<span class="line-added"> 715             if (intStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added"> 716                 *status = intStatus;</span>
<span class="line-added"> 717                 goto finishUnlock;</span>
<span class="line-added"> 718             }</span>
 719             intStatus = U_USING_DEFAULT_WARNING;
 720             if(r != NULL) { /* the default locale exists */
 721                 t1 = r;
 722                 hasRealData = TRUE;
 723                 isDefault = TRUE;
 724                 // TODO: Why not if (usingUSRData) { ... } like in the non-default-locale code path?
 725                 if (hasChopped &amp;&amp; !isRoot) {
 726                     if (!loadParentsExceptRoot(t1, name, UPRV_LENGTHOF(name), usingUSRData, usrDataPath, status)) {
 727                         goto finishUnlock;
 728                     }
 729                 }
 730             }
 731         }
 732 
 733         /* we could still have r == NULL at this point - maybe even default locale is not */
 734         /* present */
 735         if(r == NULL) {
 736             uprv_strcpy(name, kRootLocaleName);
 737             r = findFirstExisting(path, name, &amp;isRoot, &amp;hasChopped, &amp;isDefault, &amp;intStatus);
<span class="line-added"> 738             // If we failed due to out-of-memory, report the failure and exit early.</span>
<span class="line-added"> 739             if (intStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added"> 740                 *status = intStatus;</span>
<span class="line-added"> 741                 goto finishUnlock;</span>
<span class="line-added"> 742             }</span>
 743             if(r != NULL) {
 744                 t1 = r;
 745                 intStatus = U_USING_DEFAULT_WARNING;
 746                 hasRealData = TRUE;
 747             } else { /* we don&#39;t even have the root locale */
 748                 *status = U_MISSING_RESOURCE_ERROR;
 749                 goto finishUnlock;
 750             }
 751         } else if(!isRoot &amp;&amp; uprv_strcmp(t1-&gt;fName, kRootLocaleName) != 0 &amp;&amp;
 752                 t1-&gt;fParent == NULL &amp;&amp; !r-&gt;fData.noFallback) {
 753             if (!insertRootBundle(t1, status)) {
 754                 goto finishUnlock;
 755             }
 756             if(!hasRealData) {
 757                 r-&gt;fBogus = U_USING_DEFAULT_WARNING;
 758             }
 759         }
 760 
 761         // TODO: Does this ever loop?
 762         while(r != NULL &amp;&amp; !isRoot &amp;&amp; t1-&gt;fParent != NULL) {
 763             t1-&gt;fParent-&gt;fCountExisting++;
 764             t1 = t1-&gt;fParent;
 765         }
 766     } /* umtx_lock */
 767 finishUnlock:
<span class="line-modified"> 768     umtx_unlock(resbMutex());</span>
 769 
 770     if(U_SUCCESS(*status)) {
 771         if(intStatus != U_ZERO_ERROR) {
 772             *status = intStatus;
 773         }
 774         return r;
 775     } else {
 776         return NULL;
 777     }
 778 }
 779 
 780 /**
 781  * Version of entryOpen() and findFirstExisting() for ures_openDirect(),
 782  * with no fallbacks.
 783  * Parent and root locale bundles are loaded if
 784  * the requested bundle does not have the &quot;nofallback&quot; flag.
 785  */
 786 static UResourceDataEntry *
 787 entryOpenDirect(const char* path, const char* localeID, UErrorCode* status) {
 788     initCache(status);
 789     if(U_FAILURE(*status)) {
 790         return NULL;
 791     }
 792 
<span class="line-modified"> 793     umtx_lock(resbMutex());</span>
 794     // findFirstExisting() without fallbacks.
 795     UResourceDataEntry *r = init_entry(localeID, path, status);
 796     if(U_SUCCESS(*status)) {
 797         if(r-&gt;fBogus != U_ZERO_ERROR) {
 798             r-&gt;fCountExisting--;
 799             r = NULL;
 800         }
 801     } else {
 802         r = NULL;
 803     }
 804 
 805     // Some code depends on the ures_openDirect() bundle to have a parent bundle chain,
 806     // unless it is marked with &quot;nofallback&quot;.
 807     UResourceDataEntry *t1 = r;
 808     if(r != NULL &amp;&amp; uprv_strcmp(localeID, kRootLocaleName) != 0 &amp;&amp;  // not root
 809             r-&gt;fParent == NULL &amp;&amp; !r-&gt;fData.noFallback &amp;&amp;
 810             uprv_strlen(localeID) &lt; ULOC_FULLNAME_CAPACITY) {
 811         char name[ULOC_FULLNAME_CAPACITY];
 812         uprv_strcpy(name, localeID);
 813         if(!chopLocale(name) || uprv_strcmp(name, kRootLocaleName) == 0 ||
 814                 loadParentsExceptRoot(t1, name, UPRV_LENGTHOF(name), FALSE, NULL, status)) {
 815             if(uprv_strcmp(t1-&gt;fName, kRootLocaleName) != 0 &amp;&amp; t1-&gt;fParent == NULL) {
 816                 insertRootBundle(t1, status);
 817             }
 818         }
 819         if(U_FAILURE(*status)) {
 820             r = NULL;
 821         }
 822     }
 823 
 824     if(r != NULL) {
 825         // TODO: Does this ever loop?
 826         while(t1-&gt;fParent != NULL) {
 827             t1-&gt;fParent-&gt;fCountExisting++;
 828             t1 = t1-&gt;fParent;
 829         }
 830     }
<span class="line-modified"> 831     umtx_unlock(resbMutex());</span>
 832     return r;
 833 }
 834 
 835 /**
 836  * Functions to create and destroy resource bundles.
 837  *     CAUTION:  resbMutex must be locked when calling this function.
 838  */
 839 /* INTERNAL: */
 840 static void entryCloseInt(UResourceDataEntry *resB) {
 841     UResourceDataEntry *p = resB;
 842 
 843     while(resB != NULL) {
 844         p = resB-&gt;fParent;
 845         resB-&gt;fCountExisting--;
 846 
 847         /* Entries are left in the cache. TODO: add ures_flushCache() to force a flush
 848          of the cache. */
 849 /*
 850         if(resB-&gt;fCountExisting &lt;= 0) {
 851             uhash_remove(cache, resB);
</pre>
<hr />
<pre>
 854             }
 855             if(resB-&gt;fName != NULL) {
 856                 uprv_free(resB-&gt;fName);
 857             }
 858             if(resB-&gt;fPath != NULL) {
 859                 uprv_free(resB-&gt;fPath);
 860             }
 861             uprv_free(resB);
 862         }
 863 */
 864 
 865         resB = p;
 866     }
 867 }
 868 
 869 /**
 870  *  API: closes a resource bundle and cleans up.
 871  */
 872 
 873 static void entryClose(UResourceDataEntry *resB) {
<span class="line-modified"> 874   umtx_lock(resbMutex());</span>
 875   entryCloseInt(resB);
<span class="line-modified"> 876   umtx_unlock(resbMutex());</span>
 877 }
 878 
 879 /*
 880 U_CFUNC void ures_setResPath(UResourceBundle *resB, const char* toAdd) {
 881   if(resB-&gt;fResPath == NULL) {
 882     resB-&gt;fResPath = resB-&gt;fResBuf;
 883     *(resB-&gt;fResPath) = 0;
 884   }
 885   resB-&gt;fResPathLen = uprv_strlen(toAdd);
 886   if(RES_BUFSIZE &lt;= resB-&gt;fResPathLen+1) {
 887     if(resB-&gt;fResPath == resB-&gt;fResBuf) {
 888       resB-&gt;fResPath = (char *)uprv_malloc((resB-&gt;fResPathLen+1)*sizeof(char));
 889     } else {
 890       resB-&gt;fResPath = (char *)uprv_realloc(resB-&gt;fResPath, (resB-&gt;fResPathLen+1)*sizeof(char));
 891     }
 892   }
 893   uprv_strcpy(resB-&gt;fResPath, toAdd);
 894 }
 895 */
 896 static void ures_appendResPath(UResourceBundle *resB, const char* toAdd, int32_t lenToAdd, UErrorCode *status) {
</pre>
<hr />
<pre>
1112                                     r = res_getArrayItem(&amp;(mainRes-&gt;fResData), r, idx);
1113                                 }
1114                             }
1115                             if(r != RES_BOGUS) {
1116                                 result = init_resb_result(&amp;(mainRes-&gt;fResData), r, temp, -1, mainRes-&gt;fData, mainRes, noAlias+1, resB, status);
1117                             } else {
1118                                 *status = U_MISSING_RESOURCE_ERROR;
1119                                 result = resB;
1120                             }
1121                         } else {
1122                             /* this one is a bit trickier.
1123                             * we start finding keys, but after we resolve one alias, the path might continue.
1124                             * Consider:
1125                             *     aliastest:alias { &quot;testtypes/anotheralias/Sequence&quot; }
1126                             *     anotheralias:alias { &quot;/ICUDATA/sh/CollationElements&quot; }
1127                             * aliastest resource should finally have the sequence, not collation elements.
1128                             */
1129                             UResourceDataEntry *dataEntry = mainRes-&gt;fData;
1130                             char stackPath[URES_MAX_BUFFER_SIZE];
1131                             char *pathBuf = stackPath, *myPath = pathBuf;
<span class="line-modified">1132                             if(uprv_strlen(keyPath) &gt;= UPRV_LENGTHOF(stackPath)) {</span>
1133                                 pathBuf = (char *)uprv_malloc((uprv_strlen(keyPath)+1)*sizeof(char));
1134                                 if(pathBuf == NULL) {
1135                                     *status = U_MEMORY_ALLOCATION_ERROR;
1136                                     ures_close(mainRes);
1137                                     return NULL;
1138                                 }
1139                             }
1140                             uprv_strcpy(pathBuf, keyPath);
1141                             result = mainRes;
1142                             /* now we have fallback following here */
1143                             do {
1144                                 r = dataEntry-&gt;fData.rootRes;
1145                                 /* this loop handles &#39;found&#39; resources over several levels */
1146                                 while(*myPath &amp;&amp; U_SUCCESS(*status)) {
1147                                     r = res_findResource(&amp;(dataEntry-&gt;fData), r, &amp;myPath, &amp;temp);
1148                                     if(r != RES_BOGUS) { /* found a resource, but it might be an indirection */
1149                                         resB = init_resb_result(&amp;(dataEntry-&gt;fData), r, temp, -1, dataEntry, result, noAlias+1, resB, status);
1150                                         result = resB;
1151                                         if(result) {
1152                                             r = result-&gt;fRes; /* switch to a new resource, possibly a new tree */
</pre>
<hr />
<pre>
2302 U_CAPI UResourceBundle* U_EXPORT2
2303 ures_open(const char* path, const char* localeID, UErrorCode* status) {
2304     return ures_openWithType(NULL, path, localeID, URES_OPEN_LOCALE_DEFAULT_ROOT, status);
2305 }
2306 
2307 U_CAPI UResourceBundle* U_EXPORT2
2308 ures_openNoDefault(const char* path, const char* localeID, UErrorCode* status) {
2309     return ures_openWithType(NULL, path, localeID, URES_OPEN_LOCALE_ROOT, status);
2310 }
2311 
2312 /**
2313  *  Opens a resource bundle without &quot;canonicalizing&quot; the locale name. No fallback will be performed
2314  *  or sought. However, alias substitution will happen!
2315  */
2316 U_CAPI UResourceBundle*  U_EXPORT2
2317 ures_openDirect(const char* path, const char* localeID, UErrorCode* status) {
2318     return ures_openWithType(NULL, path, localeID, URES_OPEN_DIRECT, status);
2319 }
2320 
2321 /**
<span class="line-modified">2322  *  Internal API: This function is used to open a resource bundle</span>
2323  *  proper fallback chaining is executed while initialization.
2324  *  The result is stored in cache for later fallback search.
<span class="line-added">2325  *</span>
<span class="line-added">2326  * Same as ures_open(), but uses the fill-in parameter and does not allocate a new bundle.</span>
2327  */
<span class="line-modified">2328 U_INTERNAL void U_EXPORT2</span>
2329 ures_openFillIn(UResourceBundle *r, const char* path,
2330                 const char* localeID, UErrorCode* status) {
2331     if(U_SUCCESS(*status) &amp;&amp; r == NULL) {
2332         *status = U_ILLEGAL_ARGUMENT_ERROR;
2333         return;
2334     }
2335     ures_openWithType(r, path, localeID, URES_OPEN_LOCALE_DEFAULT_ROOT, status);
2336 }
2337 
<span class="line-added">2338 /**</span>
<span class="line-added">2339  * Same as ures_openDirect(), but uses the fill-in parameter and does not allocate a new bundle.</span>
<span class="line-added">2340  */</span>
<span class="line-added">2341 U_INTERNAL void U_EXPORT2</span>
<span class="line-added">2342 ures_openDirectFillIn(UResourceBundle *r, const char* path, const char* localeID, UErrorCode* status) {</span>
<span class="line-added">2343     if(U_SUCCESS(*status) &amp;&amp; r == NULL) {</span>
<span class="line-added">2344         *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">2345         return;</span>
<span class="line-added">2346     }</span>
<span class="line-added">2347     ures_openWithType(r, path, localeID, URES_OPEN_DIRECT, status);</span>
<span class="line-added">2348 }</span>
<span class="line-added">2349 </span>
2350 /**
2351  *  API: Counts members. For arrays and tables, returns number of resources.
2352  *  For strings, returns 1.
2353  */
2354 U_CAPI int32_t  U_EXPORT2
2355 ures_countArrayItems(const UResourceBundle* resourceBundle,
2356                   const char* resourceKey,
2357                   UErrorCode* status)
2358 {
2359     UResourceBundle resData;
2360     ures_initStackObject(&amp;resData);
2361     if (status==NULL || U_FAILURE(*status)) {
2362         return 0;
2363     }
2364     if(resourceBundle == NULL) {
2365         *status = U_ILLEGAL_ARGUMENT_ERROR;
2366         return 0;
2367     }
2368     ures_getByKey(resourceBundle, resourceKey, &amp;resData, status);
2369 
</pre>
<hr />
<pre>
2468 }
2469 
2470 static int32_t U_CALLCONV
2471 ures_loc_countLocales(UEnumeration *en, UErrorCode * /*status*/) {
2472     ULocalesContext *ctx = (ULocalesContext *)en-&gt;context;
2473     return ures_getSize(&amp;ctx-&gt;installed);
2474 }
2475 
2476 U_CDECL_BEGIN
2477 
2478 
2479 static const char * U_CALLCONV
2480 ures_loc_nextLocale(UEnumeration* en,
2481                     int32_t* resultLength,
2482                     UErrorCode* status) {
2483     ULocalesContext *ctx = (ULocalesContext *)en-&gt;context;
2484     UResourceBundle *res = &amp;(ctx-&gt;installed);
2485     UResourceBundle *k = NULL;
2486     const char *result = NULL;
2487     int32_t len = 0;
<span class="line-modified">2488     if(ures_hasNext(res) &amp;&amp; (k = ures_getNextResource(res, &amp;ctx-&gt;curr, status)) != 0) {</span>
2489         result = ures_getKey(k);
2490         len = (int32_t)uprv_strlen(result);
2491     }
2492     if (resultLength) {
2493         *resultLength = len;
2494     }
2495     return result;
2496 }
2497 
2498 static void U_CALLCONV
2499 ures_loc_resetLocales(UEnumeration* en,
2500                       UErrorCode* /*status*/) {
2501     UResourceBundle *res = &amp;((ULocalesContext *)en-&gt;context)-&gt;installed;
2502     ures_resetIterator(res);
2503 }
2504 
2505 U_CDECL_END
2506 
2507 static const UEnumeration gLocalesEnum = {
2508     NULL,
</pre>
<hr />
<pre>
2890     int32_t     locLen;
2891 
2892     UEnumeration *locs = NULL;
2893 
2894     UResourceBundle    item;
2895     UResourceBundle    subItem;
2896 
2897     ures_initStackObject(&amp;item);
2898     ures_initStackObject(&amp;subItem);
2899     locs = ures_openAvailableLocales(path, status);
2900 
2901     if(U_FAILURE(*status)) {
2902         ures_close(&amp;item);
2903         ures_close(&amp;subItem);
2904         return NULL;
2905     }
2906 
2907     valuesBuf[0]=0;
2908     valuesBuf[1]=0;
2909 
<span class="line-modified">2910     while((locale = uenum_next(locs, &amp;locLen, status)) != 0) {</span>
2911         UResourceBundle   *bund = NULL;
2912         UResourceBundle   *subPtr = NULL;
2913         UErrorCode subStatus = U_ZERO_ERROR; /* don&#39;t fail if a bundle is unopenable */
2914         bund = ures_openDirect(path, locale, &amp;subStatus);
2915 
2916 #if defined(URES_TREE_DEBUG)
2917         if(!bund || U_FAILURE(subStatus)) {
2918             fprintf(stderr, &quot;%s-%s values: Can&#39;t open %s locale - skipping. (%s)\n&quot;,
2919                 path?path:&quot;&lt;ICUDATA&gt;&quot;, keyword, locale, u_errorName(subStatus));
2920         }
2921 #endif
2922 
2923         ures_getByKey(bund, keyword, &amp;item, &amp;subStatus);
2924 
2925         if(!bund || U_FAILURE(subStatus)) {
2926 #if defined(URES_TREE_DEBUG)
2927             fprintf(stderr, &quot;%s-%s values: Can&#39;t find in %s - skipping. (%s)\n&quot;,
2928                 path?path:&quot;&lt;ICUDATA&gt;&quot;, keyword, locale, u_errorName(subStatus));
2929 #endif
2930             ures_close(bund);
2931             bund = NULL;
2932             continue;
2933         }
2934 
<span class="line-modified">2935         while((subPtr = ures_getNextResource(&amp;item,&amp;subItem,&amp;subStatus)) != 0</span>
2936             &amp;&amp; U_SUCCESS(subStatus)) {
2937             const char *k;
2938             int32_t i;
2939             k = ures_getKey(subPtr);
2940 
2941 #if defined(URES_TREE_DEBUG)
2942             /* fprintf(stderr, &quot;%s | %s | %s | %s\n&quot;, path?path:&quot;&lt;ICUDATA&gt;&quot;, keyword, locale, k); */
2943 #endif
2944             if(k == NULL || *k == 0 ||
2945                     uprv_strcmp(k, DEFAULT_TAG) == 0 || uprv_strncmp(k, &quot;private-&quot;, 8) == 0) {
2946                 // empty or &quot;default&quot; or unlisted type
2947                 continue;
2948             }
2949             for(i=0; i&lt;valuesCount; i++) {
2950                 if(!uprv_strcmp(valuesList[i],k)) {
2951                     k = NULL; /* found duplicate */
2952                     break;
2953                 }
2954             }
2955             if(k != NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="uprops.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uresdata.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>