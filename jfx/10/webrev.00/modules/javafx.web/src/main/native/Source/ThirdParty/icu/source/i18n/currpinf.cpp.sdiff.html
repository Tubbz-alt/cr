<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/currpinf.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="currfmt.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="currunit.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/currpinf.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4  *******************************************************************************
  5  * Copyright (C) 2009-2014, International Business Machines Corporation and
  6  * others. All Rights Reserved.
  7  *******************************************************************************
  8  */
  9 
 10 #include &quot;unicode/currpinf.h&quot;
 11 
 12 #if !UCONFIG_NO_FORMATTING
 13 
 14 //#define CURRENCY_PLURAL_INFO_DEBUG 1
 15 
 16 #ifdef CURRENCY_PLURAL_INFO_DEBUG
 17 #include &lt;iostream&gt;
 18 #endif
 19 
<span class="line-removed"> 20 </span>
 21 #include &quot;unicode/locid.h&quot;
 22 #include &quot;unicode/plurrule.h&quot;
 23 #include &quot;unicode/strenum.h&quot;
 24 #include &quot;unicode/ures.h&quot;
 25 #include &quot;unicode/numsys.h&quot;
 26 #include &quot;cstring.h&quot;
 27 #include &quot;hash.h&quot;
 28 #include &quot;uresimp.h&quot;
 29 #include &quot;ureslocs.h&quot;
 30 
 31 U_NAMESPACE_BEGIN
 32 
<span class="line-removed"> 33 </span>
 34 static const UChar gNumberPatternSeparator = 0x3B; // ;
 35 
 36 U_CDECL_BEGIN
 37 
 38 /**
 39  * @internal ICU 4.2
 40  */
 41 static UBool U_CALLCONV ValueComparator(UHashTok val1, UHashTok val2);
 42 
 43 UBool
 44 U_CALLCONV ValueComparator(UHashTok val1, UHashTok val2) {
 45     const UnicodeString* affix_1 = (UnicodeString*)val1.pointer;
 46     const UnicodeString* affix_2 = (UnicodeString*)val2.pointer;
 47     return  *affix_1 == *affix_2;
 48 }
 49 
 50 U_CDECL_END
 51 
 52 
 53 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(CurrencyPluralInfo)
 54 
 55 static const UChar gDefaultCurrencyPluralPattern[] = {&#39;0&#39;, &#39;.&#39;, &#39;#&#39;, &#39;#&#39;, &#39; &#39;, 0xA4, 0xA4, 0xA4, 0};
 56 static const UChar gTripleCurrencySign[] = {0xA4, 0xA4, 0xA4, 0};
 57 static const UChar gPluralCountOther[] = {0x6F, 0x74, 0x68, 0x65, 0x72, 0};
 58 static const UChar gPart0[] = {0x7B, 0x30, 0x7D, 0};
 59 static const UChar gPart1[] = {0x7B, 0x31, 0x7D, 0};
 60 
 61 static const char gNumberElementsTag[]=&quot;NumberElements&quot;;
 62 static const char gLatnTag[]=&quot;latn&quot;;
 63 static const char gPatternsTag[]=&quot;patterns&quot;;
 64 static const char gDecimalFormatTag[]=&quot;decimalFormat&quot;;
 65 static const char gCurrUnitPtnTag[]=&quot;CurrencyUnitPatterns&quot;;
 66 
 67 CurrencyPluralInfo::CurrencyPluralInfo(UErrorCode&amp; status)
<span class="line-modified"> 68 :   fPluralCountToCurrencyUnitPattern(NULL),</span>
<span class="line-modified"> 69     fPluralRules(NULL),</span>
<span class="line-modified"> 70     fLocale(NULL) {</span>

 71     initialize(Locale::getDefault(), status);
 72 }
 73 
 74 CurrencyPluralInfo::CurrencyPluralInfo(const Locale&amp; locale, UErrorCode&amp; status)
<span class="line-modified"> 75 :   fPluralCountToCurrencyUnitPattern(NULL),</span>
<span class="line-modified"> 76     fPluralRules(NULL),</span>
<span class="line-modified"> 77     fLocale(NULL) {</span>

 78     initialize(locale, status);
 79 }
 80 
 81 CurrencyPluralInfo::CurrencyPluralInfo(const CurrencyPluralInfo&amp; info)
 82 :   UObject(info),
<span class="line-modified"> 83     fPluralCountToCurrencyUnitPattern(NULL),</span>
<span class="line-modified"> 84     fPluralRules(NULL),</span>
<span class="line-modified"> 85     fLocale(NULL) {</span>

 86     *this = info;
 87 }
 88 
<span class="line-removed"> 89 </span>
 90 CurrencyPluralInfo&amp;
 91 CurrencyPluralInfo::operator=(const CurrencyPluralInfo&amp; info) {
 92     if (this == &amp;info) {
 93         return *this;
 94     }
 95 






 96     deleteHash(fPluralCountToCurrencyUnitPattern);
<span class="line-modified"> 97     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-removed"> 98     fPluralCountToCurrencyUnitPattern = initHash(status);</span>
 99     copyHash(info.fPluralCountToCurrencyUnitPattern,
<span class="line-modified">100              fPluralCountToCurrencyUnitPattern, status);</span>
<span class="line-modified">101     if ( U_FAILURE(status) ) {</span>
102         return *this;
103     }
104 
105     delete fPluralRules;

106     delete fLocale;
<span class="line-modified">107     if (info.fPluralRules) {</span>


108         fPluralRules = info.fPluralRules-&gt;clone();
<span class="line-modified">109     } else {</span>
<span class="line-modified">110         fPluralRules = NULL;</span>


111     }
<span class="line-modified">112     if (info.fLocale) {</span>
113         fLocale = info.fLocale-&gt;clone();
<span class="line-modified">114     } else {</span>
<span class="line-modified">115         fLocale = NULL;</span>









116     }
117     return *this;
118 }
119 
<span class="line-removed">120 </span>
121 CurrencyPluralInfo::~CurrencyPluralInfo() {
122     deleteHash(fPluralCountToCurrencyUnitPattern);
<span class="line-modified">123     fPluralCountToCurrencyUnitPattern = NULL;</span>
124     delete fPluralRules;
125     delete fLocale;
<span class="line-modified">126     fPluralRules = NULL;</span>
<span class="line-modified">127     fLocale = NULL;</span>
128 }
129 
130 UBool
131 CurrencyPluralInfo::operator==(const CurrencyPluralInfo&amp; info) const {
132 #ifdef CURRENCY_PLURAL_INFO_DEBUG
133     if (*fPluralRules == *info.fPluralRules) {
134         std::cout &lt;&lt; &quot;same plural rules\n&quot;;
135     }
136     if (*fLocale == *info.fLocale) {
137         std::cout &lt;&lt; &quot;same locale\n&quot;;
138     }
139     if (fPluralCountToCurrencyUnitPattern-&gt;equals(*info.fPluralCountToCurrencyUnitPattern)) {
140         std::cout &lt;&lt; &quot;same pattern\n&quot;;
141     }
142 #endif
143     return *fPluralRules == *info.fPluralRules &amp;&amp;
144            *fLocale == *info.fLocale &amp;&amp;
145            fPluralCountToCurrencyUnitPattern-&gt;equals(*info.fPluralCountToCurrencyUnitPattern);
146 }
147 
148 
149 CurrencyPluralInfo*
150 CurrencyPluralInfo::clone() const {
<span class="line-modified">151     return new CurrencyPluralInfo(*this);</span>







152 }
153 
154 const PluralRules*
155 CurrencyPluralInfo::getPluralRules() const {
156     return fPluralRules;
157 }
158 
159 UnicodeString&amp;
160 CurrencyPluralInfo::getCurrencyPluralPattern(const UnicodeString&amp;  pluralCount,
161                                              UnicodeString&amp; result) const {
162     const UnicodeString* currencyPluralPattern =
163         (UnicodeString*)fPluralCountToCurrencyUnitPattern-&gt;get(pluralCount);
<span class="line-modified">164     if (currencyPluralPattern == NULL) {</span>
165         // fall back to &quot;other&quot;
166         if (pluralCount.compare(gPluralCountOther, 5)) {
167             currencyPluralPattern =
168                 (UnicodeString*)fPluralCountToCurrencyUnitPattern-&gt;get(UnicodeString(TRUE, gPluralCountOther, 5));
169         }
<span class="line-modified">170         if (currencyPluralPattern == NULL) {</span>
171             // no currencyUnitPatterns defined,
<span class="line-modified">172             // fallback to predefined defult.</span>
173             // This should never happen when ICU resource files are
174             // available, since currencyUnitPattern of &quot;other&quot; is always
175             // defined in root.
176             result = UnicodeString(gDefaultCurrencyPluralPattern);
177             return result;
178         }
179     }
180     result = *currencyPluralPattern;
181     return result;
182 }
183 
184 const Locale&amp;
185 CurrencyPluralInfo::getLocale() const {
186     return *fLocale;
187 }
188 
189 void
190 CurrencyPluralInfo::setPluralRules(const UnicodeString&amp; ruleDescription,
191                                    UErrorCode&amp; status) {
192     if (U_SUCCESS(status)) {
<span class="line-modified">193         if (fPluralRules) {</span>
<span class="line-removed">194             delete fPluralRules;</span>
<span class="line-removed">195         }</span>
196         fPluralRules = PluralRules::createRules(ruleDescription, status);
197     }
198 }
199 
<span class="line-removed">200 </span>
201 void
202 CurrencyPluralInfo::setCurrencyPluralPattern(const UnicodeString&amp; pluralCount,
203                                              const UnicodeString&amp; pattern,
204                                              UErrorCode&amp; status) {
205     if (U_SUCCESS(status)) {
206         UnicodeString* oldValue = static_cast&lt;UnicodeString*&gt;(
207             fPluralCountToCurrencyUnitPattern-&gt;get(pluralCount));
208         delete oldValue;
<span class="line-modified">209         fPluralCountToCurrencyUnitPattern-&gt;put(pluralCount, new UnicodeString(pattern), status);</span>





210     }
211 }
212 
<span class="line-removed">213 </span>
214 void
215 CurrencyPluralInfo::setLocale(const Locale&amp; loc, UErrorCode&amp; status) {
216     initialize(loc, status);
217 }
218 
<span class="line-removed">219 </span>
220 void
221 CurrencyPluralInfo::initialize(const Locale&amp; loc, UErrorCode&amp; status) {
222     if (U_FAILURE(status)) {
223         return;
224     }
225     delete fLocale;




226     fLocale = loc.clone();
<span class="line-modified">227     if (fPluralRules) {</span>
<span class="line-modified">228         delete fPluralRules;</span>







229     }
230     fPluralRules = PluralRules::forLocale(loc, status);
231     setupCurrencyPluralPattern(loc, status);
232 }
233 
<span class="line-removed">234 </span>
235 void
236 CurrencyPluralInfo::setupCurrencyPluralPattern(const Locale&amp; loc, UErrorCode&amp; status) {
237     if (U_FAILURE(status)) {
238         return;
239     }
240 
<span class="line-modified">241     if (fPluralCountToCurrencyUnitPattern) {</span>
<span class="line-removed">242         deleteHash(fPluralCountToCurrencyUnitPattern);</span>
<span class="line-removed">243     }</span>
244     fPluralCountToCurrencyUnitPattern = initHash(status);
245     if (U_FAILURE(status)) {
246         return;
247     }
248 
<span class="line-modified">249     NumberingSystem *ns = NumberingSystem::createInstance(loc,status);</span>



250     UErrorCode ec = U_ZERO_ERROR;
<span class="line-modified">251     UResourceBundle *rb = ures_open(NULL, loc.getName(), &amp;ec);</span>
<span class="line-modified">252     UResourceBundle *numElements = ures_getByKeyWithFallback(rb, gNumberElementsTag, NULL, &amp;ec);</span>
<span class="line-modified">253     rb = ures_getByKeyWithFallback(numElements, ns-&gt;getName(), rb, &amp;ec);</span>
<span class="line-modified">254     rb = ures_getByKeyWithFallback(rb, gPatternsTag, rb, &amp;ec);</span>
255     int32_t ptnLen;
<span class="line-modified">256     const UChar* numberStylePattern = ures_getStringByKeyWithFallback(rb, gDecimalFormatTag, &amp;ptnLen, &amp;ec);</span>
257     // Fall back to &quot;latn&quot; if num sys specific pattern isn&#39;t there.
<span class="line-modified">258     if ( ec == U_MISSING_RESOURCE_ERROR &amp;&amp; uprv_strcmp(ns-&gt;getName(),gLatnTag)) {</span>
259         ec = U_ZERO_ERROR;
<span class="line-modified">260         rb = ures_getByKeyWithFallback(numElements, gLatnTag, rb, &amp;ec);</span>
<span class="line-modified">261         rb = ures_getByKeyWithFallback(rb, gPatternsTag, rb, &amp;ec);</span>
<span class="line-modified">262         numberStylePattern = ures_getStringByKeyWithFallback(rb, gDecimalFormatTag, &amp;ptnLen, &amp;ec);</span>
263     }
264     int32_t numberStylePatternLen = ptnLen;
<span class="line-modified">265     const UChar* negNumberStylePattern = NULL;</span>
266     int32_t negNumberStylePatternLen = 0;
267     // TODO: Java
268     // parse to check whether there is &quot;;&quot; separator in the numberStylePattern
269     UBool hasSeparator = false;
270     if (U_SUCCESS(ec)) {
271         for (int32_t styleCharIndex = 0; styleCharIndex &lt; ptnLen; ++styleCharIndex) {
272             if (numberStylePattern[styleCharIndex] == gNumberPatternSeparator) {
273                 hasSeparator = true;
274                 // split the number style pattern into positive and negative
275                 negNumberStylePattern = numberStylePattern + styleCharIndex + 1;
276                 negNumberStylePatternLen = ptnLen - styleCharIndex - 1;
277                 numberStylePatternLen = styleCharIndex;
278             }
279         }
280     }
281 
<span class="line-removed">282     ures_close(numElements);</span>
<span class="line-removed">283     ures_close(rb);</span>
<span class="line-removed">284     delete ns;</span>
<span class="line-removed">285 </span>
286     if (U_FAILURE(ec)) {




287         return;
288     }
289 
<span class="line-modified">290     UResourceBundle *currRb = ures_open(U_ICUDATA_CURR, loc.getName(), &amp;ec);</span>
<span class="line-modified">291     UResourceBundle *currencyRes = ures_getByKeyWithFallback(currRb, gCurrUnitPtnTag, NULL, &amp;ec);</span>
292 
293 #ifdef CURRENCY_PLURAL_INFO_DEBUG
294     std::cout &lt;&lt; &quot;in set up\n&quot;;
295 #endif
<span class="line-modified">296     StringEnumeration* keywords = fPluralRules-&gt;getKeywords(ec);</span>
297     if (U_SUCCESS(ec)) {
298         const char* pluralCount;
<span class="line-modified">299         while ((pluralCount = keywords-&gt;next(NULL, ec)) != NULL) {</span>
<span class="line-modified">300             if ( U_SUCCESS(ec) ) {</span>
<span class="line-modified">301                 int32_t ptnLen;</span>
<span class="line-modified">302                 UErrorCode err = U_ZERO_ERROR;</span>
<span class="line-modified">303                 const UChar* patternChars = ures_getStringByKeyWithFallback(</span>
<span class="line-modified">304                     currencyRes, pluralCount, &amp;ptnLen, &amp;err);</span>
<span class="line-modified">305                 if (U_SUCCESS(err) &amp;&amp; ptnLen &gt; 0) {</span>
<span class="line-modified">306                     UnicodeString* pattern = new UnicodeString(patternChars, ptnLen);</span>






307 #ifdef CURRENCY_PLURAL_INFO_DEBUG
<span class="line-modified">308                     char result_1[1000];</span>
<span class="line-modified">309                     pattern-&gt;extract(0, pattern-&gt;length(), result_1, &quot;UTF-8&quot;);</span>
<span class="line-modified">310                     std::cout &lt;&lt; &quot;pluralCount: &quot; &lt;&lt; pluralCount &lt;&lt; &quot;; pattern: &quot; &lt;&lt; result_1 &lt;&lt; &quot;\n&quot;;</span>
311 #endif
<span class="line-modified">312                     pattern-&gt;findAndReplace(UnicodeString(TRUE, gPart0, 3),</span>
<span class="line-modified">313                       UnicodeString(numberStylePattern, numberStylePatternLen));</span>
<span class="line-modified">314                     pattern-&gt;findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));</span>
<span class="line-modified">315 </span>
<span class="line-modified">316                     if (hasSeparator) {</span>
<span class="line-modified">317                         UnicodeString negPattern(patternChars, ptnLen);</span>
<span class="line-modified">318                         negPattern.findAndReplace(UnicodeString(TRUE, gPart0, 3),</span>
<span class="line-modified">319                           UnicodeString(negNumberStylePattern, negNumberStylePatternLen));</span>
<span class="line-modified">320                         negPattern.findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));</span>
<span class="line-modified">321                         pattern-&gt;append(gNumberPatternSeparator);</span>
<span class="line-modified">322                         pattern-&gt;append(negPattern);</span>
<span class="line-modified">323                     }</span>
324 #ifdef CURRENCY_PLURAL_INFO_DEBUG
<span class="line-modified">325                     pattern-&gt;extract(0, pattern-&gt;length(), result_1, &quot;UTF-8&quot;);</span>
<span class="line-modified">326                     std::cout &lt;&lt; &quot;pluralCount: &quot; &lt;&lt; pluralCount &lt;&lt; &quot;; pattern: &quot; &lt;&lt; result_1 &lt;&lt; &quot;\n&quot;;</span>
327 #endif
<span class="line-modified">328 </span>
<span class="line-modified">329                     fPluralCountToCurrencyUnitPattern-&gt;put(UnicodeString(pluralCount, -1, US_INV), pattern, status);</span>
<span class="line-modified">330                 }</span>
331             }
332         }
333     }
<span class="line-modified">334     delete keywords;</span>
<span class="line-modified">335     ures_close(currencyRes);</span>
<span class="line-modified">336     ures_close(currRb);</span>

337 }
338 
<span class="line-removed">339 </span>
<span class="line-removed">340 </span>
341 void
<span class="line-modified">342 CurrencyPluralInfo::deleteHash(Hashtable* hTable)</span>
<span class="line-modified">343 {</span>
<span class="line-removed">344     if ( hTable == NULL ) {</span>
345         return;
346     }
347     int32_t pos = UHASH_FIRST;
<span class="line-modified">348     const UHashElement* element = NULL;</span>
<span class="line-modified">349     while ( (element = hTable-&gt;nextElement(pos)) != NULL ) {</span>
350         const UHashTok valueTok = element-&gt;value;
351         const UnicodeString* value = (UnicodeString*)valueTok.pointer;
352         delete value;
353     }
354     delete hTable;
<span class="line-modified">355     hTable = NULL;</span>
356 }
357 
<span class="line-removed">358 </span>
359 Hashtable*
360 CurrencyPluralInfo::initHash(UErrorCode&amp; status) {
<span class="line-modified">361     if ( U_FAILURE(status) ) {</span>
<span class="line-modified">362         return NULL;</span>
<span class="line-removed">363     }</span>
<span class="line-removed">364     Hashtable* hTable;</span>
<span class="line-removed">365     if ( (hTable = new Hashtable(TRUE, status)) == NULL ) {</span>
<span class="line-removed">366         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">367         return NULL;</span>
368     }
<span class="line-modified">369     if ( U_FAILURE(status) ) {</span>
<span class="line-modified">370         delete hTable;</span>
<span class="line-modified">371         return NULL;</span>
372     }
373     hTable-&gt;setValueComparator(ValueComparator);
<span class="line-modified">374     return hTable;</span>
375 }
376 
<span class="line-removed">377 </span>
378 void
379 CurrencyPluralInfo::copyHash(const Hashtable* source,
380                            Hashtable* target,
381                            UErrorCode&amp; status) {
<span class="line-modified">382     if ( U_FAILURE(status) ) {</span>
383         return;
384     }
385     int32_t pos = UHASH_FIRST;
<span class="line-modified">386     const UHashElement* element = NULL;</span>
<span class="line-modified">387     if ( source ) {</span>
<span class="line-modified">388         while ( (element = source-&gt;nextElement(pos)) != NULL ) {</span>
389             const UHashTok keyTok = element-&gt;key;
390             const UnicodeString* key = (UnicodeString*)keyTok.pointer;
391             const UHashTok valueTok = element-&gt;value;
392             const UnicodeString* value = (UnicodeString*)valueTok.pointer;
<span class="line-modified">393             UnicodeString* copy = new UnicodeString(*value);</span>
<span class="line-modified">394             target-&gt;put(UnicodeString(*key), copy, status);</span>
<span class="line-modified">395             if ( U_FAILURE(status) ) {</span>




396                 return;
397             }
398         }
399     }
400 }
401 
<span class="line-removed">402 </span>
403 U_NAMESPACE_END
404 
405 #endif
</pre>
</td>
<td>
<hr />
<pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4  *******************************************************************************
  5  * Copyright (C) 2009-2014, International Business Machines Corporation and
  6  * others. All Rights Reserved.
  7  *******************************************************************************
  8  */
  9 
 10 #include &quot;unicode/currpinf.h&quot;
 11 
 12 #if !UCONFIG_NO_FORMATTING
 13 
 14 //#define CURRENCY_PLURAL_INFO_DEBUG 1
 15 
 16 #ifdef CURRENCY_PLURAL_INFO_DEBUG
 17 #include &lt;iostream&gt;
 18 #endif
 19 

 20 #include &quot;unicode/locid.h&quot;
 21 #include &quot;unicode/plurrule.h&quot;
 22 #include &quot;unicode/strenum.h&quot;
 23 #include &quot;unicode/ures.h&quot;
 24 #include &quot;unicode/numsys.h&quot;
 25 #include &quot;cstring.h&quot;
 26 #include &quot;hash.h&quot;
 27 #include &quot;uresimp.h&quot;
 28 #include &quot;ureslocs.h&quot;
 29 
 30 U_NAMESPACE_BEGIN
 31 

 32 static const UChar gNumberPatternSeparator = 0x3B; // ;
 33 
 34 U_CDECL_BEGIN
 35 
 36 /**
 37  * @internal ICU 4.2
 38  */
 39 static UBool U_CALLCONV ValueComparator(UHashTok val1, UHashTok val2);
 40 
 41 UBool
 42 U_CALLCONV ValueComparator(UHashTok val1, UHashTok val2) {
 43     const UnicodeString* affix_1 = (UnicodeString*)val1.pointer;
 44     const UnicodeString* affix_2 = (UnicodeString*)val2.pointer;
 45     return  *affix_1 == *affix_2;
 46 }
 47 
 48 U_CDECL_END
 49 
 50 
 51 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(CurrencyPluralInfo)
 52 
 53 static const UChar gDefaultCurrencyPluralPattern[] = {&#39;0&#39;, &#39;.&#39;, &#39;#&#39;, &#39;#&#39;, &#39; &#39;, 0xA4, 0xA4, 0xA4, 0};
 54 static const UChar gTripleCurrencySign[] = {0xA4, 0xA4, 0xA4, 0};
 55 static const UChar gPluralCountOther[] = {0x6F, 0x74, 0x68, 0x65, 0x72, 0};
 56 static const UChar gPart0[] = {0x7B, 0x30, 0x7D, 0};
 57 static const UChar gPart1[] = {0x7B, 0x31, 0x7D, 0};
 58 
 59 static const char gNumberElementsTag[]=&quot;NumberElements&quot;;
 60 static const char gLatnTag[]=&quot;latn&quot;;
 61 static const char gPatternsTag[]=&quot;patterns&quot;;
 62 static const char gDecimalFormatTag[]=&quot;decimalFormat&quot;;
 63 static const char gCurrUnitPtnTag[]=&quot;CurrencyUnitPatterns&quot;;
 64 
 65 CurrencyPluralInfo::CurrencyPluralInfo(UErrorCode&amp; status)
<span class="line-modified"> 66 :   fPluralCountToCurrencyUnitPattern(nullptr),</span>
<span class="line-modified"> 67     fPluralRules(nullptr),</span>
<span class="line-modified"> 68     fLocale(nullptr),</span>
<span class="line-added"> 69     fInternalStatus(U_ZERO_ERROR) {</span>
 70     initialize(Locale::getDefault(), status);
 71 }
 72 
 73 CurrencyPluralInfo::CurrencyPluralInfo(const Locale&amp; locale, UErrorCode&amp; status)
<span class="line-modified"> 74 :   fPluralCountToCurrencyUnitPattern(nullptr),</span>
<span class="line-modified"> 75     fPluralRules(nullptr),</span>
<span class="line-modified"> 76     fLocale(nullptr),</span>
<span class="line-added"> 77     fInternalStatus(U_ZERO_ERROR) {</span>
 78     initialize(locale, status);
 79 }
 80 
 81 CurrencyPluralInfo::CurrencyPluralInfo(const CurrencyPluralInfo&amp; info)
 82 :   UObject(info),
<span class="line-modified"> 83     fPluralCountToCurrencyUnitPattern(nullptr),</span>
<span class="line-modified"> 84     fPluralRules(nullptr),</span>
<span class="line-modified"> 85     fLocale(nullptr),</span>
<span class="line-added"> 86     fInternalStatus(U_ZERO_ERROR) {</span>
 87     *this = info;
 88 }
 89 

 90 CurrencyPluralInfo&amp;
 91 CurrencyPluralInfo::operator=(const CurrencyPluralInfo&amp; info) {
 92     if (this == &amp;info) {
 93         return *this;
 94     }
 95 
<span class="line-added"> 96     fInternalStatus = info.fInternalStatus;</span>
<span class="line-added"> 97     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added"> 98         // bail out early if the object we were copying from was already &#39;invalid&#39;.</span>
<span class="line-added"> 99         return *this;</span>
<span class="line-added">100     }</span>
<span class="line-added">101 </span>
102     deleteHash(fPluralCountToCurrencyUnitPattern);
<span class="line-modified">103     fPluralCountToCurrencyUnitPattern = initHash(fInternalStatus);</span>

104     copyHash(info.fPluralCountToCurrencyUnitPattern,
<span class="line-modified">105              fPluralCountToCurrencyUnitPattern, fInternalStatus);</span>
<span class="line-modified">106     if ( U_FAILURE(fInternalStatus) ) {</span>
107         return *this;
108     }
109 
110     delete fPluralRules;
<span class="line-added">111     fPluralRules = nullptr;</span>
112     delete fLocale;
<span class="line-modified">113     fLocale = nullptr;</span>
<span class="line-added">114 </span>
<span class="line-added">115     if (info.fPluralRules != nullptr) {</span>
116         fPluralRules = info.fPluralRules-&gt;clone();
<span class="line-modified">117         if (fPluralRules == nullptr) {</span>
<span class="line-modified">118             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">119             return *this;</span>
<span class="line-added">120         }</span>
121     }
<span class="line-modified">122     if (info.fLocale != nullptr) {</span>
123         fLocale = info.fLocale-&gt;clone();
<span class="line-modified">124         if (fLocale == nullptr) {</span>
<span class="line-modified">125             // Note: If clone had an error parameter, then we could check/set that instead.</span>
<span class="line-added">126             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">127             return *this;</span>
<span class="line-added">128         }</span>
<span class="line-added">129         // If the other locale wasn&#39;t bogus, but our clone&#39;d locale is bogus, then OOM happened</span>
<span class="line-added">130         // during the call to clone().</span>
<span class="line-added">131         if (!info.fLocale-&gt;isBogus() &amp;&amp; fLocale-&gt;isBogus()) {</span>
<span class="line-added">132             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">133             return *this;</span>
<span class="line-added">134         }</span>
135     }
136     return *this;
137 }
138 

139 CurrencyPluralInfo::~CurrencyPluralInfo() {
140     deleteHash(fPluralCountToCurrencyUnitPattern);
<span class="line-modified">141     fPluralCountToCurrencyUnitPattern = nullptr;</span>
142     delete fPluralRules;
143     delete fLocale;
<span class="line-modified">144     fPluralRules = nullptr;</span>
<span class="line-modified">145     fLocale = nullptr;</span>
146 }
147 
148 UBool
149 CurrencyPluralInfo::operator==(const CurrencyPluralInfo&amp; info) const {
150 #ifdef CURRENCY_PLURAL_INFO_DEBUG
151     if (*fPluralRules == *info.fPluralRules) {
152         std::cout &lt;&lt; &quot;same plural rules\n&quot;;
153     }
154     if (*fLocale == *info.fLocale) {
155         std::cout &lt;&lt; &quot;same locale\n&quot;;
156     }
157     if (fPluralCountToCurrencyUnitPattern-&gt;equals(*info.fPluralCountToCurrencyUnitPattern)) {
158         std::cout &lt;&lt; &quot;same pattern\n&quot;;
159     }
160 #endif
161     return *fPluralRules == *info.fPluralRules &amp;&amp;
162            *fLocale == *info.fLocale &amp;&amp;
163            fPluralCountToCurrencyUnitPattern-&gt;equals(*info.fPluralCountToCurrencyUnitPattern);
164 }
165 
166 
167 CurrencyPluralInfo*
168 CurrencyPluralInfo::clone() const {
<span class="line-modified">169     CurrencyPluralInfo* newObj = new CurrencyPluralInfo(*this);</span>
<span class="line-added">170     // Since clone doesn&#39;t have a &#39;status&#39; parameter, the best we can do is return nullptr</span>
<span class="line-added">171     // if the new object was not full constructed properly (an error occurred).</span>
<span class="line-added">172     if (newObj != nullptr &amp;&amp; U_FAILURE(newObj-&gt;fInternalStatus)) {</span>
<span class="line-added">173         delete newObj;</span>
<span class="line-added">174         newObj = nullptr;</span>
<span class="line-added">175     }</span>
<span class="line-added">176     return newObj;</span>
177 }
178 
179 const PluralRules*
180 CurrencyPluralInfo::getPluralRules() const {
181     return fPluralRules;
182 }
183 
184 UnicodeString&amp;
185 CurrencyPluralInfo::getCurrencyPluralPattern(const UnicodeString&amp;  pluralCount,
186                                              UnicodeString&amp; result) const {
187     const UnicodeString* currencyPluralPattern =
188         (UnicodeString*)fPluralCountToCurrencyUnitPattern-&gt;get(pluralCount);
<span class="line-modified">189     if (currencyPluralPattern == nullptr) {</span>
190         // fall back to &quot;other&quot;
191         if (pluralCount.compare(gPluralCountOther, 5)) {
192             currencyPluralPattern =
193                 (UnicodeString*)fPluralCountToCurrencyUnitPattern-&gt;get(UnicodeString(TRUE, gPluralCountOther, 5));
194         }
<span class="line-modified">195         if (currencyPluralPattern == nullptr) {</span>
196             // no currencyUnitPatterns defined,
<span class="line-modified">197             // fallback to predefined default.</span>
198             // This should never happen when ICU resource files are
199             // available, since currencyUnitPattern of &quot;other&quot; is always
200             // defined in root.
201             result = UnicodeString(gDefaultCurrencyPluralPattern);
202             return result;
203         }
204     }
205     result = *currencyPluralPattern;
206     return result;
207 }
208 
209 const Locale&amp;
210 CurrencyPluralInfo::getLocale() const {
211     return *fLocale;
212 }
213 
214 void
215 CurrencyPluralInfo::setPluralRules(const UnicodeString&amp; ruleDescription,
216                                    UErrorCode&amp; status) {
217     if (U_SUCCESS(status)) {
<span class="line-modified">218         delete fPluralRules;</span>


219         fPluralRules = PluralRules::createRules(ruleDescription, status);
220     }
221 }
222 

223 void
224 CurrencyPluralInfo::setCurrencyPluralPattern(const UnicodeString&amp; pluralCount,
225                                              const UnicodeString&amp; pattern,
226                                              UErrorCode&amp; status) {
227     if (U_SUCCESS(status)) {
228         UnicodeString* oldValue = static_cast&lt;UnicodeString*&gt;(
229             fPluralCountToCurrencyUnitPattern-&gt;get(pluralCount));
230         delete oldValue;
<span class="line-modified">231         LocalPointer&lt;UnicodeString&gt; p(new UnicodeString(pattern), status);</span>
<span class="line-added">232         if (U_SUCCESS(status)) {</span>
<span class="line-added">233             // the p object allocated above will be owned by fPluralCountToCurrencyUnitPattern</span>
<span class="line-added">234             // after the call to put(), even if the method returns failure.</span>
<span class="line-added">235             fPluralCountToCurrencyUnitPattern-&gt;put(pluralCount, p.orphan(), status);</span>
<span class="line-added">236         }</span>
237     }
238 }
239 

240 void
241 CurrencyPluralInfo::setLocale(const Locale&amp; loc, UErrorCode&amp; status) {
242     initialize(loc, status);
243 }
244 

245 void
246 CurrencyPluralInfo::initialize(const Locale&amp; loc, UErrorCode&amp; status) {
247     if (U_FAILURE(status)) {
248         return;
249     }
250     delete fLocale;
<span class="line-added">251     fLocale = nullptr;</span>
<span class="line-added">252     delete fPluralRules;</span>
<span class="line-added">253     fPluralRules = nullptr;</span>
<span class="line-added">254 </span>
255     fLocale = loc.clone();
<span class="line-modified">256     if (fLocale == nullptr) {</span>
<span class="line-modified">257         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">258         return;</span>
<span class="line-added">259     }</span>
<span class="line-added">260     // If the locale passed in wasn&#39;t bogus, but our clone&#39;d locale is bogus, then OOM happened</span>
<span class="line-added">261     // during the call to loc.clone().</span>
<span class="line-added">262     if (!loc.isBogus() &amp;&amp; fLocale-&gt;isBogus()) {</span>
<span class="line-added">263         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">264         return;</span>
265     }
266     fPluralRules = PluralRules::forLocale(loc, status);
267     setupCurrencyPluralPattern(loc, status);
268 }
269 

270 void
271 CurrencyPluralInfo::setupCurrencyPluralPattern(const Locale&amp; loc, UErrorCode&amp; status) {
272     if (U_FAILURE(status)) {
273         return;
274     }
275 
<span class="line-modified">276     deleteHash(fPluralCountToCurrencyUnitPattern);</span>


277     fPluralCountToCurrencyUnitPattern = initHash(status);
278     if (U_FAILURE(status)) {
279         return;
280     }
281 
<span class="line-modified">282     LocalPointer&lt;NumberingSystem&gt; ns(NumberingSystem::createInstance(loc, status), status);</span>
<span class="line-added">283     if (U_FAILURE(status)) {</span>
<span class="line-added">284         return;</span>
<span class="line-added">285     }</span>
286     UErrorCode ec = U_ZERO_ERROR;
<span class="line-modified">287     LocalUResourceBundlePointer rb(ures_open(nullptr, loc.getName(), &amp;ec));</span>
<span class="line-modified">288     LocalUResourceBundlePointer numElements(ures_getByKeyWithFallback(rb.getAlias(), gNumberElementsTag, nullptr, &amp;ec));</span>
<span class="line-modified">289     ures_getByKeyWithFallback(numElements.getAlias(), ns-&gt;getName(), rb.getAlias(), &amp;ec);</span>
<span class="line-modified">290     ures_getByKeyWithFallback(rb.getAlias(), gPatternsTag, rb.getAlias(), &amp;ec);</span>
291     int32_t ptnLen;
<span class="line-modified">292     const UChar* numberStylePattern = ures_getStringByKeyWithFallback(rb.getAlias(), gDecimalFormatTag, &amp;ptnLen, &amp;ec);</span>
293     // Fall back to &quot;latn&quot; if num sys specific pattern isn&#39;t there.
<span class="line-modified">294     if ( ec == U_MISSING_RESOURCE_ERROR &amp;&amp; (uprv_strcmp(ns-&gt;getName(), gLatnTag) != 0)) {</span>
295         ec = U_ZERO_ERROR;
<span class="line-modified">296         ures_getByKeyWithFallback(numElements.getAlias(), gLatnTag, rb.getAlias(), &amp;ec);</span>
<span class="line-modified">297         ures_getByKeyWithFallback(rb.getAlias(), gPatternsTag, rb.getAlias(), &amp;ec);</span>
<span class="line-modified">298         numberStylePattern = ures_getStringByKeyWithFallback(rb.getAlias(), gDecimalFormatTag, &amp;ptnLen, &amp;ec);</span>
299     }
300     int32_t numberStylePatternLen = ptnLen;
<span class="line-modified">301     const UChar* negNumberStylePattern = nullptr;</span>
302     int32_t negNumberStylePatternLen = 0;
303     // TODO: Java
304     // parse to check whether there is &quot;;&quot; separator in the numberStylePattern
305     UBool hasSeparator = false;
306     if (U_SUCCESS(ec)) {
307         for (int32_t styleCharIndex = 0; styleCharIndex &lt; ptnLen; ++styleCharIndex) {
308             if (numberStylePattern[styleCharIndex] == gNumberPatternSeparator) {
309                 hasSeparator = true;
310                 // split the number style pattern into positive and negative
311                 negNumberStylePattern = numberStylePattern + styleCharIndex + 1;
312                 negNumberStylePatternLen = ptnLen - styleCharIndex - 1;
313                 numberStylePatternLen = styleCharIndex;
314             }
315         }
316     }
317 




318     if (U_FAILURE(ec)) {
<span class="line-added">319         // If OOM occurred during the above code, then we want to report that back to the caller.</span>
<span class="line-added">320         if (ec == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">321             status = ec;</span>
<span class="line-added">322         }</span>
323         return;
324     }
325 
<span class="line-modified">326     LocalUResourceBundlePointer currRb(ures_open(U_ICUDATA_CURR, loc.getName(), &amp;ec));</span>
<span class="line-modified">327     LocalUResourceBundlePointer currencyRes(ures_getByKeyWithFallback(currRb.getAlias(), gCurrUnitPtnTag, nullptr, &amp;ec));</span>
328 
329 #ifdef CURRENCY_PLURAL_INFO_DEBUG
330     std::cout &lt;&lt; &quot;in set up\n&quot;;
331 #endif
<span class="line-modified">332     LocalPointer&lt;StringEnumeration&gt; keywords(fPluralRules-&gt;getKeywords(ec), ec);</span>
333     if (U_SUCCESS(ec)) {
334         const char* pluralCount;
<span class="line-modified">335         while (((pluralCount = keywords-&gt;next(nullptr, ec)) != nullptr) &amp;&amp; U_SUCCESS(ec)) {</span>
<span class="line-modified">336             int32_t ptnLength;</span>
<span class="line-modified">337             UErrorCode err = U_ZERO_ERROR;</span>
<span class="line-modified">338             const UChar* patternChars = ures_getStringByKeyWithFallback(currencyRes.getAlias(), pluralCount, &amp;ptnLength, &amp;err);</span>
<span class="line-modified">339             if (err == U_MEMORY_ALLOCATION_ERROR || patternChars == nullptr) {</span>
<span class="line-modified">340                 ec = err;</span>
<span class="line-modified">341                 break;</span>
<span class="line-modified">342             }</span>
<span class="line-added">343             if (U_SUCCESS(err) &amp;&amp; ptnLength &gt; 0) {</span>
<span class="line-added">344                 UnicodeString* pattern = new UnicodeString(patternChars, ptnLength);</span>
<span class="line-added">345                 if (pattern == nullptr) {</span>
<span class="line-added">346                     ec = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">347                     break;</span>
<span class="line-added">348                 }</span>
349 #ifdef CURRENCY_PLURAL_INFO_DEBUG
<span class="line-modified">350                 char result_1[1000];</span>
<span class="line-modified">351                 pattern-&gt;extract(0, pattern-&gt;length(), result_1, &quot;UTF-8&quot;);</span>
<span class="line-modified">352                 std::cout &lt;&lt; &quot;pluralCount: &quot; &lt;&lt; pluralCount &lt;&lt; &quot;; pattern: &quot; &lt;&lt; result_1 &lt;&lt; &quot;\n&quot;;</span>
353 #endif
<span class="line-modified">354                 pattern-&gt;findAndReplace(UnicodeString(TRUE, gPart0, 3),</span>
<span class="line-modified">355                     UnicodeString(numberStylePattern, numberStylePatternLen));</span>
<span class="line-modified">356                 pattern-&gt;findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));</span>
<span class="line-modified">357 </span>
<span class="line-modified">358                 if (hasSeparator) {</span>
<span class="line-modified">359                     UnicodeString negPattern(patternChars, ptnLength);</span>
<span class="line-modified">360                     negPattern.findAndReplace(UnicodeString(TRUE, gPart0, 3),</span>
<span class="line-modified">361                         UnicodeString(negNumberStylePattern, negNumberStylePatternLen));</span>
<span class="line-modified">362                     negPattern.findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));</span>
<span class="line-modified">363                     pattern-&gt;append(gNumberPatternSeparator);</span>
<span class="line-modified">364                     pattern-&gt;append(negPattern);</span>
<span class="line-modified">365                 }</span>
366 #ifdef CURRENCY_PLURAL_INFO_DEBUG
<span class="line-modified">367                 pattern-&gt;extract(0, pattern-&gt;length(), result_1, &quot;UTF-8&quot;);</span>
<span class="line-modified">368                 std::cout &lt;&lt; &quot;pluralCount: &quot; &lt;&lt; pluralCount &lt;&lt; &quot;; pattern: &quot; &lt;&lt; result_1 &lt;&lt; &quot;\n&quot;;</span>
369 #endif
<span class="line-modified">370                 // the &#39;pattern&#39; object allocated above will be owned by the fPluralCountToCurrencyUnitPattern after the call to</span>
<span class="line-modified">371                 // put(), even if the method returns failure.</span>
<span class="line-modified">372                 fPluralCountToCurrencyUnitPattern-&gt;put(UnicodeString(pluralCount, -1, US_INV), pattern, status);</span>
373             }
374         }
375     }
<span class="line-modified">376     // If OOM occurred during the above code, then we want to report that back to the caller.</span>
<span class="line-modified">377     if (ec == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-modified">378         status = ec;</span>
<span class="line-added">379     }</span>
380 }
381 


382 void
<span class="line-modified">383 CurrencyPluralInfo::deleteHash(Hashtable* hTable) {</span>
<span class="line-modified">384     if ( hTable == nullptr ) {</span>

385         return;
386     }
387     int32_t pos = UHASH_FIRST;
<span class="line-modified">388     const UHashElement* element = nullptr;</span>
<span class="line-modified">389     while ( (element = hTable-&gt;nextElement(pos)) != nullptr ) {</span>
390         const UHashTok valueTok = element-&gt;value;
391         const UnicodeString* value = (UnicodeString*)valueTok.pointer;
392         delete value;
393     }
394     delete hTable;
<span class="line-modified">395     hTable = nullptr;</span>
396 }
397 

398 Hashtable*
399 CurrencyPluralInfo::initHash(UErrorCode&amp; status) {
<span class="line-modified">400     if (U_FAILURE(status)) {</span>
<span class="line-modified">401         return nullptr;</span>





402     }
<span class="line-modified">403     LocalPointer&lt;Hashtable&gt; hTable(new Hashtable(TRUE, status), status);</span>
<span class="line-modified">404     if (U_FAILURE(status)) {</span>
<span class="line-modified">405         return nullptr;</span>
406     }
407     hTable-&gt;setValueComparator(ValueComparator);
<span class="line-modified">408     return hTable.orphan();</span>
409 }
410 

411 void
412 CurrencyPluralInfo::copyHash(const Hashtable* source,
413                            Hashtable* target,
414                            UErrorCode&amp; status) {
<span class="line-modified">415     if (U_FAILURE(status)) {</span>
416         return;
417     }
418     int32_t pos = UHASH_FIRST;
<span class="line-modified">419     const UHashElement* element = nullptr;</span>
<span class="line-modified">420     if (source) {</span>
<span class="line-modified">421         while ( (element = source-&gt;nextElement(pos)) != nullptr ) {</span>
422             const UHashTok keyTok = element-&gt;key;
423             const UnicodeString* key = (UnicodeString*)keyTok.pointer;
424             const UHashTok valueTok = element-&gt;value;
425             const UnicodeString* value = (UnicodeString*)valueTok.pointer;
<span class="line-modified">426             LocalPointer&lt;UnicodeString&gt; copy(new UnicodeString(*value), status);</span>
<span class="line-modified">427             if (U_FAILURE(status)) {</span>
<span class="line-modified">428                 return;</span>
<span class="line-added">429             }</span>
<span class="line-added">430             // The HashTable owns the &#39;copy&#39; object after the call to put().</span>
<span class="line-added">431             target-&gt;put(UnicodeString(*key), copy.orphan(), status);</span>
<span class="line-added">432             if (U_FAILURE(status)) {</span>
433                 return;
434             }
435         }
436     }
437 }
438 

439 U_NAMESPACE_END
440 
441 #endif
</pre>
</td>
</tr>
</table>
<center><a href="currfmt.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="currunit.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>