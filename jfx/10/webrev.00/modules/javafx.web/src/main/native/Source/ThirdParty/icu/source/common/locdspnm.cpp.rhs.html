<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/locdspnm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 2010-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 *******************************************************************************
   8 */
   9 
  10 #include &quot;unicode/utypes.h&quot;
  11 
  12 #if !UCONFIG_NO_FORMATTING
  13 
  14 #include &quot;unicode/locdspnm.h&quot;
  15 #include &quot;unicode/simpleformatter.h&quot;
  16 #include &quot;unicode/ucasemap.h&quot;
  17 #include &quot;unicode/ures.h&quot;
  18 #include &quot;unicode/udisplaycontext.h&quot;
  19 #include &quot;unicode/brkiter.h&quot;
  20 #include &quot;unicode/ucurr.h&quot;
  21 #include &quot;cmemory.h&quot;
  22 #include &quot;cstring.h&quot;
  23 #include &quot;mutex.h&quot;
  24 #include &quot;ulocimp.h&quot;
  25 #include &quot;umutex.h&quot;
  26 #include &quot;ureslocs.h&quot;
  27 #include &quot;uresimp.h&quot;
  28 
  29 #include &lt;stdarg.h&gt;
  30 
  31 /**
  32  * Concatenate a number of null-terminated strings to buffer, leaving a
  33  * null-terminated string.  The last argument should be the null pointer.
  34  * Return the length of the string in the buffer, not counting the trailing
  35  * null.  Return -1 if there is an error (buffer is null, or buflen &lt; 1).
  36  */
  37 static int32_t ncat(char *buffer, uint32_t buflen, ...) {
  38   va_list args;
  39   char *str;
  40   char *p = buffer;
  41   const char* e = buffer + buflen - 1;
  42 
  43   if (buffer == NULL || buflen &lt; 1) {
  44     return -1;
  45   }
  46 
  47   va_start(args, buflen);
<a name="1" id="anc1"></a><span class="line-modified">  48   while ((str = va_arg(args, char *)) != 0) {</span>
  49     char c;
<a name="2" id="anc2"></a><span class="line-modified">  50     while (p != e &amp;&amp; (c = *str++) != 0) {</span>
  51       *p++ = c;
  52     }
  53   }
  54   *p = 0;
  55   va_end(args);
  56 
  57   return static_cast&lt;int32_t&gt;(p - buffer);
  58 }
  59 
  60 U_NAMESPACE_BEGIN
  61 
  62 ////////////////////////////////////////////////////////////////////////////////////////////////////
  63 
  64 // Access resource data for locale components.
  65 // Wrap code in uloc.c for now.
  66 class ICUDataTable {
  67     const char* path;
  68     Locale locale;
  69 
  70 public:
  71     ICUDataTable(const char* path, const Locale&amp; locale);
  72     ~ICUDataTable();
  73 
  74     const Locale&amp; getLocale();
  75 
  76     UnicodeString&amp; get(const char* tableKey, const char* itemKey,
  77                         UnicodeString&amp; result) const;
  78     UnicodeString&amp; get(const char* tableKey, const char* subTableKey, const char* itemKey,
  79                         UnicodeString&amp; result) const;
  80 
  81     UnicodeString&amp; getNoFallback(const char* tableKey, const char* itemKey,
  82                                 UnicodeString &amp;result) const;
  83     UnicodeString&amp; getNoFallback(const char* tableKey, const char* subTableKey, const char* itemKey,
  84                                 UnicodeString &amp;result) const;
  85 };
  86 
  87 inline UnicodeString &amp;
  88 ICUDataTable::get(const char* tableKey, const char* itemKey, UnicodeString&amp; result) const {
  89     return get(tableKey, NULL, itemKey, result);
  90 }
  91 
  92 inline UnicodeString &amp;
  93 ICUDataTable::getNoFallback(const char* tableKey, const char* itemKey, UnicodeString&amp; result) const {
  94     return getNoFallback(tableKey, NULL, itemKey, result);
  95 }
  96 
  97 ICUDataTable::ICUDataTable(const char* path, const Locale&amp; locale)
  98     : path(NULL), locale(Locale::getRoot())
  99 {
 100   if (path) {
<a name="3" id="anc3"></a><span class="line-modified"> 101     int32_t len = static_cast&lt;int32_t&gt;(uprv_strlen(path));</span>
 102     this-&gt;path = (const char*) uprv_malloc(len + 1);
 103     if (this-&gt;path) {
 104       uprv_strcpy((char *)this-&gt;path, path);
 105       this-&gt;locale = locale;
 106     }
 107   }
 108 }
 109 
 110 ICUDataTable::~ICUDataTable() {
 111   if (path) {
 112     uprv_free((void*) path);
 113     path = NULL;
 114   }
 115 }
 116 
 117 const Locale&amp;
 118 ICUDataTable::getLocale() {
 119   return locale;
 120 }
 121 
 122 UnicodeString &amp;
 123 ICUDataTable::get(const char* tableKey, const char* subTableKey, const char* itemKey,
 124                   UnicodeString &amp;result) const {
 125   UErrorCode status = U_ZERO_ERROR;
 126   int32_t len = 0;
 127 
 128   const UChar *s = uloc_getTableStringWithFallback(path, locale.getName(),
 129                                                    tableKey, subTableKey, itemKey,
 130                                                    &amp;len, &amp;status);
 131   if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
 132     return result.setTo(s, len);
 133   }
 134   return result.setTo(UnicodeString(itemKey, -1, US_INV));
 135 }
 136 
 137 UnicodeString &amp;
 138 ICUDataTable::getNoFallback(const char* tableKey, const char* subTableKey, const char* itemKey,
 139                             UnicodeString&amp; result) const {
 140   UErrorCode status = U_ZERO_ERROR;
 141   int32_t len = 0;
 142 
 143   const UChar *s = uloc_getTableStringWithFallback(path, locale.getName(),
 144                                                    tableKey, subTableKey, itemKey,
 145                                                    &amp;len, &amp;status);
 146   if (U_SUCCESS(status)) {
 147     return result.setTo(s, len);
 148   }
 149 
 150   result.setToBogus();
 151   return result;
 152 }
 153 
 154 ////////////////////////////////////////////////////////////////////////////////////////////////////
 155 
 156 LocaleDisplayNames::~LocaleDisplayNames() {}
 157 
 158 ////////////////////////////////////////////////////////////////////////////////////////////////////
 159 
 160 #if 0  // currently unused
 161 
 162 class DefaultLocaleDisplayNames : public LocaleDisplayNames {
 163   UDialectHandling dialectHandling;
 164 
 165 public:
 166   // constructor
 167   DefaultLocaleDisplayNames(UDialectHandling dialectHandling);
 168 
 169   virtual ~DefaultLocaleDisplayNames();
 170 
 171   virtual const Locale&amp; getLocale() const;
 172   virtual UDialectHandling getDialectHandling() const;
 173 
 174   virtual UnicodeString&amp; localeDisplayName(const Locale&amp; locale,
 175                                            UnicodeString&amp; result) const;
 176   virtual UnicodeString&amp; localeDisplayName(const char* localeId,
 177                                            UnicodeString&amp; result) const;
 178   virtual UnicodeString&amp; languageDisplayName(const char* lang,
 179                                              UnicodeString&amp; result) const;
 180   virtual UnicodeString&amp; scriptDisplayName(const char* script,
 181                                            UnicodeString&amp; result) const;
 182   virtual UnicodeString&amp; scriptDisplayName(UScriptCode scriptCode,
 183                                            UnicodeString&amp; result) const;
 184   virtual UnicodeString&amp; regionDisplayName(const char* region,
 185                                            UnicodeString&amp; result) const;
 186   virtual UnicodeString&amp; variantDisplayName(const char* variant,
 187                                             UnicodeString&amp; result) const;
 188   virtual UnicodeString&amp; keyDisplayName(const char* key,
 189                                         UnicodeString&amp; result) const;
 190   virtual UnicodeString&amp; keyValueDisplayName(const char* key,
 191                                              const char* value,
 192                                              UnicodeString&amp; result) const;
 193 };
 194 
 195 DefaultLocaleDisplayNames::DefaultLocaleDisplayNames(UDialectHandling dialectHandling)
 196     : dialectHandling(dialectHandling) {
 197 }
 198 
 199 DefaultLocaleDisplayNames::~DefaultLocaleDisplayNames() {
 200 }
 201 
 202 const Locale&amp;
 203 DefaultLocaleDisplayNames::getLocale() const {
 204   return Locale::getRoot();
 205 }
 206 
 207 UDialectHandling
 208 DefaultLocaleDisplayNames::getDialectHandling() const {
 209   return dialectHandling;
 210 }
 211 
 212 UnicodeString&amp;
 213 DefaultLocaleDisplayNames::localeDisplayName(const Locale&amp; locale,
 214                                              UnicodeString&amp; result) const {
 215   return result = UnicodeString(locale.getName(), -1, US_INV);
 216 }
 217 
 218 UnicodeString&amp;
 219 DefaultLocaleDisplayNames::localeDisplayName(const char* localeId,
 220                                              UnicodeString&amp; result) const {
 221   return result = UnicodeString(localeId, -1, US_INV);
 222 }
 223 
 224 UnicodeString&amp;
 225 DefaultLocaleDisplayNames::languageDisplayName(const char* lang,
 226                                                UnicodeString&amp; result) const {
 227   return result = UnicodeString(lang, -1, US_INV);
 228 }
 229 
 230 UnicodeString&amp;
 231 DefaultLocaleDisplayNames::scriptDisplayName(const char* script,
 232                                              UnicodeString&amp; result) const {
 233   return result = UnicodeString(script, -1, US_INV);
 234 }
 235 
 236 UnicodeString&amp;
 237 DefaultLocaleDisplayNames::scriptDisplayName(UScriptCode scriptCode,
 238                                              UnicodeString&amp; result) const {
 239   const char* name = uscript_getName(scriptCode);
 240   if (name) {
 241     return result = UnicodeString(name, -1, US_INV);
 242   }
 243   return result.remove();
 244 }
 245 
 246 UnicodeString&amp;
 247 DefaultLocaleDisplayNames::regionDisplayName(const char* region,
 248                                              UnicodeString&amp; result) const {
 249   return result = UnicodeString(region, -1, US_INV);
 250 }
 251 
 252 UnicodeString&amp;
 253 DefaultLocaleDisplayNames::variantDisplayName(const char* variant,
 254                                               UnicodeString&amp; result) const {
 255   return result = UnicodeString(variant, -1, US_INV);
 256 }
 257 
 258 UnicodeString&amp;
 259 DefaultLocaleDisplayNames::keyDisplayName(const char* key,
 260                                           UnicodeString&amp; result) const {
 261   return result = UnicodeString(key, -1, US_INV);
 262 }
 263 
 264 UnicodeString&amp;
 265 DefaultLocaleDisplayNames::keyValueDisplayName(const char* /* key */,
 266                                                const char* value,
 267                                                UnicodeString&amp; result) const {
 268   return result = UnicodeString(value, -1, US_INV);
 269 }
 270 
 271 #endif  // currently unused class DefaultLocaleDisplayNames
 272 
 273 ////////////////////////////////////////////////////////////////////////////////////////////////////
 274 
 275 class LocaleDisplayNamesImpl : public LocaleDisplayNames {
 276     Locale locale;
 277     UDialectHandling dialectHandling;
 278     ICUDataTable langData;
 279     ICUDataTable regionData;
 280     SimpleFormatter separatorFormat;
 281     SimpleFormatter format;
 282     SimpleFormatter keyTypeFormat;
 283     UDisplayContext capitalizationContext;
 284 #if !UCONFIG_NO_BREAK_ITERATION
 285     BreakIterator* capitalizationBrkIter;
 286 #else
 287     UObject* capitalizationBrkIter;
 288 #endif
<a name="4" id="anc4"></a>
 289     UnicodeString formatOpenParen;
 290     UnicodeString formatReplaceOpenParen;
 291     UnicodeString formatCloseParen;
 292     UnicodeString formatReplaceCloseParen;
 293     UDisplayContext nameLength;
 294 
 295     // Constants for capitalization context usage types.
 296     enum CapContextUsage {
 297         kCapContextUsageLanguage,
 298         kCapContextUsageScript,
 299         kCapContextUsageTerritory,
 300         kCapContextUsageVariant,
 301         kCapContextUsageKey,
 302         kCapContextUsageKeyValue,
 303         kCapContextUsageCount
 304     };
 305     // Capitalization transforms. For each usage type, indicates whether to titlecase for
 306     // the context specified in capitalizationContext (which we know at construction time)
 307      UBool fCapitalization[kCapContextUsageCount];
 308 
 309 public:
 310     // constructor
 311     LocaleDisplayNamesImpl(const Locale&amp; locale, UDialectHandling dialectHandling);
 312     LocaleDisplayNamesImpl(const Locale&amp; locale, UDisplayContext *contexts, int32_t length);
 313     virtual ~LocaleDisplayNamesImpl();
 314 
 315     virtual const Locale&amp; getLocale() const;
 316     virtual UDialectHandling getDialectHandling() const;
 317     virtual UDisplayContext getContext(UDisplayContextType type) const;
 318 
 319     virtual UnicodeString&amp; localeDisplayName(const Locale&amp; locale,
 320                                                 UnicodeString&amp; result) const;
 321     virtual UnicodeString&amp; localeDisplayName(const char* localeId,
 322                                                 UnicodeString&amp; result) const;
 323     virtual UnicodeString&amp; languageDisplayName(const char* lang,
 324                                                UnicodeString&amp; result) const;
 325     virtual UnicodeString&amp; scriptDisplayName(const char* script,
 326                                                 UnicodeString&amp; result) const;
 327     virtual UnicodeString&amp; scriptDisplayName(UScriptCode scriptCode,
 328                                                 UnicodeString&amp; result) const;
 329     virtual UnicodeString&amp; regionDisplayName(const char* region,
 330                                                 UnicodeString&amp; result) const;
 331     virtual UnicodeString&amp; variantDisplayName(const char* variant,
 332                                                 UnicodeString&amp; result) const;
 333     virtual UnicodeString&amp; keyDisplayName(const char* key,
 334                                                 UnicodeString&amp; result) const;
 335     virtual UnicodeString&amp; keyValueDisplayName(const char* key,
 336                                                 const char* value,
 337                                                 UnicodeString&amp; result) const;
 338 private:
 339     UnicodeString&amp; localeIdName(const char* localeId,
 340                                 UnicodeString&amp; result) const;
 341     UnicodeString&amp; appendWithSep(UnicodeString&amp; buffer, const UnicodeString&amp; src) const;
 342     UnicodeString&amp; adjustForUsageAndContext(CapContextUsage usage, UnicodeString&amp; result) const;
 343     UnicodeString&amp; scriptDisplayName(const char* script, UnicodeString&amp; result, UBool skipAdjust) const;
 344     UnicodeString&amp; regionDisplayName(const char* region, UnicodeString&amp; result, UBool skipAdjust) const;
 345     UnicodeString&amp; variantDisplayName(const char* variant, UnicodeString&amp; result, UBool skipAdjust) const;
 346     UnicodeString&amp; keyDisplayName(const char* key, UnicodeString&amp; result, UBool skipAdjust) const;
 347     UnicodeString&amp; keyValueDisplayName(const char* key, const char* value,
 348                                         UnicodeString&amp; result, UBool skipAdjust) const;
 349     void initialize(void);
 350 
 351     struct CapitalizationContextSink;
 352 };
 353 
<a name="5" id="anc5"></a>

 354 LocaleDisplayNamesImpl::LocaleDisplayNamesImpl(const Locale&amp; locale,
 355                                                UDialectHandling dialectHandling)
 356     : dialectHandling(dialectHandling)
 357     , langData(U_ICUDATA_LANG, locale)
 358     , regionData(U_ICUDATA_REGION, locale)
 359     , capitalizationContext(UDISPCTX_CAPITALIZATION_NONE)
 360     , capitalizationBrkIter(NULL)
 361     , nameLength(UDISPCTX_LENGTH_FULL)
 362 {
 363     initialize();
 364 }
 365 
 366 LocaleDisplayNamesImpl::LocaleDisplayNamesImpl(const Locale&amp; locale,
 367                                                UDisplayContext *contexts, int32_t length)
 368     : dialectHandling(ULDN_STANDARD_NAMES)
 369     , langData(U_ICUDATA_LANG, locale)
 370     , regionData(U_ICUDATA_REGION, locale)
 371     , capitalizationContext(UDISPCTX_CAPITALIZATION_NONE)
 372     , capitalizationBrkIter(NULL)
 373     , nameLength(UDISPCTX_LENGTH_FULL)
 374 {
 375     while (length-- &gt; 0) {
 376         UDisplayContext value = *contexts++;
 377         UDisplayContextType selector = (UDisplayContextType)((uint32_t)value &gt;&gt; 8);
 378         switch (selector) {
 379             case UDISPCTX_TYPE_DIALECT_HANDLING:
 380                 dialectHandling = (UDialectHandling)value;
 381                 break;
 382             case UDISPCTX_TYPE_CAPITALIZATION:
 383                 capitalizationContext = value;
 384                 break;
 385             case UDISPCTX_TYPE_DISPLAY_LENGTH:
 386                 nameLength = value;
 387                 break;
 388             default:
 389                 break;
 390         }
 391     }
 392     initialize();
 393 }
 394 
 395 struct LocaleDisplayNamesImpl::CapitalizationContextSink : public ResourceSink {
 396     UBool hasCapitalizationUsage;
 397     LocaleDisplayNamesImpl&amp; parent;
 398 
 399     CapitalizationContextSink(LocaleDisplayNamesImpl&amp; _parent)
 400       : hasCapitalizationUsage(FALSE), parent(_parent) {}
 401     virtual ~CapitalizationContextSink();
 402 
 403     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,
 404             UErrorCode &amp;errorCode) {
 405         ResourceTable contexts = value.getTable(errorCode);
 406         if (U_FAILURE(errorCode)) { return; }
 407         for (int i = 0; contexts.getKeyAndValue(i, key, value); ++i) {
 408 
 409             CapContextUsage usageEnum;
 410             if (uprv_strcmp(key, &quot;key&quot;) == 0) {
 411                 usageEnum = kCapContextUsageKey;
 412             } else if (uprv_strcmp(key, &quot;keyValue&quot;) == 0) {
 413                 usageEnum = kCapContextUsageKeyValue;
 414             } else if (uprv_strcmp(key, &quot;languages&quot;) == 0) {
 415                 usageEnum = kCapContextUsageLanguage;
 416             } else if (uprv_strcmp(key, &quot;script&quot;) == 0) {
 417                 usageEnum = kCapContextUsageScript;
 418             } else if (uprv_strcmp(key, &quot;territory&quot;) == 0) {
 419                 usageEnum = kCapContextUsageTerritory;
 420             } else if (uprv_strcmp(key, &quot;variant&quot;) == 0) {
 421                 usageEnum = kCapContextUsageVariant;
 422             } else {
 423                 continue;
 424             }
 425 
 426             int32_t len = 0;
 427             const int32_t* intVector = value.getIntVector(len, errorCode);
 428             if (U_FAILURE(errorCode)) { return; }
 429             if (len &lt; 2) { continue; }
 430 
 431             int32_t titlecaseInt = (parent.capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU) ? intVector[0] : intVector[1];
 432             if (titlecaseInt == 0) { continue; }
 433 
 434             parent.fCapitalization[usageEnum] = TRUE;
 435             hasCapitalizationUsage = TRUE;
 436         }
 437     }
 438 };
 439 
 440 // Virtual destructors must be defined out of line.
 441 LocaleDisplayNamesImpl::CapitalizationContextSink::~CapitalizationContextSink() {}
 442 
 443 void
 444 LocaleDisplayNamesImpl::initialize(void) {
 445     LocaleDisplayNamesImpl *nonConstThis = (LocaleDisplayNamesImpl *)this;
 446     nonConstThis-&gt;locale = langData.getLocale() == Locale::getRoot()
 447         ? regionData.getLocale()
 448         : langData.getLocale();
 449 
 450     UnicodeString sep;
 451     langData.getNoFallback(&quot;localeDisplayPattern&quot;, &quot;separator&quot;, sep);
 452     if (sep.isBogus()) {
 453         sep = UnicodeString(&quot;{0}, {1}&quot;, -1, US_INV);
 454     }
 455     UErrorCode status = U_ZERO_ERROR;
 456     separatorFormat.applyPatternMinMaxArguments(sep, 2, 2, status);
 457 
 458     UnicodeString pattern;
 459     langData.getNoFallback(&quot;localeDisplayPattern&quot;, &quot;pattern&quot;, pattern);
 460     if (pattern.isBogus()) {
 461         pattern = UnicodeString(&quot;{0} ({1})&quot;, -1, US_INV);
 462     }
 463     format.applyPatternMinMaxArguments(pattern, 2, 2, status);
 464     if (pattern.indexOf((UChar)0xFF08) &gt;= 0) {
 465         formatOpenParen.setTo((UChar)0xFF08);         // fullwidth (
 466         formatReplaceOpenParen.setTo((UChar)0xFF3B);  // fullwidth [
 467         formatCloseParen.setTo((UChar)0xFF09);        // fullwidth )
 468         formatReplaceCloseParen.setTo((UChar)0xFF3D); // fullwidth ]
 469     } else {
 470         formatOpenParen.setTo((UChar)0x0028);         // (
 471         formatReplaceOpenParen.setTo((UChar)0x005B);  // [
 472         formatCloseParen.setTo((UChar)0x0029);        // )
 473         formatReplaceCloseParen.setTo((UChar)0x005D); // ]
 474     }
 475 
 476     UnicodeString ktPattern;
 477     langData.get(&quot;localeDisplayPattern&quot;, &quot;keyTypePattern&quot;, ktPattern);
 478     if (ktPattern.isBogus()) {
 479         ktPattern = UnicodeString(&quot;{0}={1}&quot;, -1, US_INV);
 480     }
 481     keyTypeFormat.applyPatternMinMaxArguments(ktPattern, 2, 2, status);
 482 
 483     uprv_memset(fCapitalization, 0, sizeof(fCapitalization));
 484 #if !UCONFIG_NO_BREAK_ITERATION
 485     // Only get the context data if we need it! This is a const object so we know now...
 486     // Also check whether we will need a break iterator (depends on the data)
 487     UBool needBrkIter = FALSE;
 488     if (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU || capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_STANDALONE) {
 489         LocalUResourceBundlePointer resource(ures_open(NULL, locale.getName(), &amp;status));
 490         if (U_FAILURE(status)) { return; }
 491         CapitalizationContextSink sink(*this);
 492         ures_getAllItemsWithFallback(resource.getAlias(), &quot;contextTransforms&quot;, sink, status);
 493         if (status == U_MISSING_RESOURCE_ERROR) {
 494             // Silently ignore.  Not every locale has contextTransforms.
 495             status = U_ZERO_ERROR;
 496         } else if (U_FAILURE(status)) {
 497             return;
 498         }
 499         needBrkIter = sink.hasCapitalizationUsage;
 500     }
 501     // Get a sentence break iterator if we will need it
 502     if (needBrkIter || capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE) {
 503         status = U_ZERO_ERROR;
 504         capitalizationBrkIter = BreakIterator::createSentenceInstance(locale, status);
 505         if (U_FAILURE(status)) {
 506             delete capitalizationBrkIter;
 507             capitalizationBrkIter = NULL;
 508         }
 509     }
 510 #endif
 511 }
 512 
 513 LocaleDisplayNamesImpl::~LocaleDisplayNamesImpl() {
 514 #if !UCONFIG_NO_BREAK_ITERATION
 515     delete capitalizationBrkIter;
 516 #endif
 517 }
 518 
 519 const Locale&amp;
 520 LocaleDisplayNamesImpl::getLocale() const {
 521     return locale;
 522 }
 523 
 524 UDialectHandling
 525 LocaleDisplayNamesImpl::getDialectHandling() const {
 526     return dialectHandling;
 527 }
 528 
 529 UDisplayContext
 530 LocaleDisplayNamesImpl::getContext(UDisplayContextType type) const {
 531     switch (type) {
 532         case UDISPCTX_TYPE_DIALECT_HANDLING:
 533             return (UDisplayContext)dialectHandling;
 534         case UDISPCTX_TYPE_CAPITALIZATION:
 535             return capitalizationContext;
 536         case UDISPCTX_TYPE_DISPLAY_LENGTH:
 537             return nameLength;
 538         default:
 539             break;
 540     }
 541     return (UDisplayContext)0;
 542 }
 543 
 544 UnicodeString&amp;
 545 LocaleDisplayNamesImpl::adjustForUsageAndContext(CapContextUsage usage,
 546                                                 UnicodeString&amp; result) const {
 547 #if !UCONFIG_NO_BREAK_ITERATION
 548     // check to see whether we need to titlecase result
 549     if ( result.length() &gt; 0 &amp;&amp; u_islower(result.char32At(0)) &amp;&amp; capitalizationBrkIter!= NULL &amp;&amp;
 550           ( capitalizationContext==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE || fCapitalization[usage] ) ) {
 551         // note fCapitalization[usage] won&#39;t be set unless capitalizationContext is UI_LIST_OR_MENU or STANDALONE
<a name="6" id="anc6"></a><span class="line-added"> 552         static UMutex capitalizationBrkIterLock = U_MUTEX_INITIALIZER;</span>
 553         Mutex lock(&amp;capitalizationBrkIterLock);
 554         result.toTitle(capitalizationBrkIter, locale, U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
 555     }
 556 #endif
 557     return result;
 558 }
 559 
 560 UnicodeString&amp;
<a name="7" id="anc7"></a><span class="line-modified"> 561 LocaleDisplayNamesImpl::localeDisplayName(const Locale&amp; loc,</span>
 562                                           UnicodeString&amp; result) const {
<a name="8" id="anc8"></a><span class="line-modified"> 563   if (loc.isBogus()) {</span>
 564     result.setToBogus();
 565     return result;
 566   }
 567   UnicodeString resultName;
 568 
<a name="9" id="anc9"></a><span class="line-modified"> 569   const char* lang = loc.getLanguage();</span>
 570   if (uprv_strlen(lang) == 0) {
 571     lang = &quot;root&quot;;
 572   }
<a name="10" id="anc10"></a><span class="line-modified"> 573   const char* script = loc.getScript();</span>
<span class="line-modified"> 574   const char* country = loc.getCountry();</span>
<span class="line-modified"> 575   const char* variant = loc.getVariant();</span>
 576 
 577   UBool hasScript = uprv_strlen(script) &gt; 0;
 578   UBool hasCountry = uprv_strlen(country) &gt; 0;
 579   UBool hasVariant = uprv_strlen(variant) &gt; 0;
 580 
 581   if (dialectHandling == ULDN_DIALECT_NAMES) {
 582     char buffer[ULOC_FULLNAME_CAPACITY];
 583     do { // loop construct is so we can break early out of search
 584       if (hasScript &amp;&amp; hasCountry) {
 585         ncat(buffer, ULOC_FULLNAME_CAPACITY, lang, &quot;_&quot;, script, &quot;_&quot;, country, (char *)0);
 586         localeIdName(buffer, resultName);
 587         if (!resultName.isBogus()) {
 588           hasScript = FALSE;
 589           hasCountry = FALSE;
 590           break;
 591         }
 592       }
 593       if (hasScript) {
 594         ncat(buffer, ULOC_FULLNAME_CAPACITY, lang, &quot;_&quot;, script, (char *)0);
 595         localeIdName(buffer, resultName);
 596         if (!resultName.isBogus()) {
 597           hasScript = FALSE;
 598           break;
 599         }
 600       }
 601       if (hasCountry) {
 602         ncat(buffer, ULOC_FULLNAME_CAPACITY, lang, &quot;_&quot;, country, (char*)0);
 603         localeIdName(buffer, resultName);
 604         if (!resultName.isBogus()) {
 605           hasCountry = FALSE;
 606           break;
 607         }
 608       }
 609     } while (FALSE);
 610   }
 611   if (resultName.isBogus() || resultName.isEmpty()) {
 612     localeIdName(lang, resultName);
 613   }
 614 
 615   UnicodeString resultRemainder;
 616   UnicodeString temp;
 617   UErrorCode status = U_ZERO_ERROR;
 618 
 619   if (hasScript) {
 620     resultRemainder.append(scriptDisplayName(script, temp, TRUE));
 621   }
 622   if (hasCountry) {
 623     appendWithSep(resultRemainder, regionDisplayName(country, temp, TRUE));
 624   }
 625   if (hasVariant) {
 626     appendWithSep(resultRemainder, variantDisplayName(variant, temp, TRUE));
 627   }
 628   resultRemainder.findAndReplace(formatOpenParen, formatReplaceOpenParen);
 629   resultRemainder.findAndReplace(formatCloseParen, formatReplaceCloseParen);
 630 
<a name="11" id="anc11"></a><span class="line-modified"> 631   LocalPointer&lt;StringEnumeration&gt; e(loc.createKeywords(status));</span>
 632   if (e.isValid() &amp;&amp; U_SUCCESS(status)) {
 633     UnicodeString temp2;
 634     char value[ULOC_KEYWORD_AND_VALUES_CAPACITY]; // sigh, no ULOC_VALUE_CAPACITY
 635     const char* key;
 636     while ((key = e-&gt;next((int32_t *)0, status)) != NULL) {
 637       value[0] = 0;
<a name="12" id="anc12"></a><span class="line-modified"> 638       loc.getKeywordValue(key, value, ULOC_KEYWORD_AND_VALUES_CAPACITY, status);</span>
 639       if (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING) {
 640         return result;
 641       }
 642       keyDisplayName(key, temp, TRUE);
 643       temp.findAndReplace(formatOpenParen, formatReplaceOpenParen);
 644       temp.findAndReplace(formatCloseParen, formatReplaceCloseParen);
 645       keyValueDisplayName(key, value, temp2, TRUE);
 646       temp2.findAndReplace(formatOpenParen, formatReplaceOpenParen);
 647       temp2.findAndReplace(formatCloseParen, formatReplaceCloseParen);
 648       if (temp2 != UnicodeString(value, -1, US_INV)) {
 649         appendWithSep(resultRemainder, temp2);
 650       } else if (temp != UnicodeString(key, -1, US_INV)) {
 651         UnicodeString temp3;
 652         keyTypeFormat.format(temp, temp2, temp3, status);
 653         appendWithSep(resultRemainder, temp3);
 654       } else {
 655         appendWithSep(resultRemainder, temp)
 656           .append((UChar)0x3d /* = */)
 657           .append(temp2);
 658       }
 659     }
 660   }
 661 
 662   if (!resultRemainder.isEmpty()) {
 663     format.format(resultName, resultRemainder, result.remove(), status);
 664     return adjustForUsageAndContext(kCapContextUsageLanguage, result);
 665   }
 666 
 667   result = resultName;
 668   return adjustForUsageAndContext(kCapContextUsageLanguage, result);
 669 }
 670 
 671 UnicodeString&amp;
 672 LocaleDisplayNamesImpl::appendWithSep(UnicodeString&amp; buffer, const UnicodeString&amp; src) const {
 673     if (buffer.isEmpty()) {
 674         buffer.setTo(src);
 675     } else {
 676         const UnicodeString *values[2] = { &amp;buffer, &amp;src };
 677         UErrorCode status = U_ZERO_ERROR;
 678         separatorFormat.formatAndReplace(values, 2, buffer, NULL, 0, status);
 679     }
 680     return buffer;
 681 }
 682 
 683 UnicodeString&amp;
 684 LocaleDisplayNamesImpl::localeDisplayName(const char* localeId,
 685                                           UnicodeString&amp; result) const {
 686     return localeDisplayName(Locale(localeId), result);
 687 }
 688 
 689 // private
 690 UnicodeString&amp;
 691 LocaleDisplayNamesImpl::localeIdName(const char* localeId,
 692                                      UnicodeString&amp; result) const {
 693     if (nameLength == UDISPCTX_LENGTH_SHORT) {
 694         langData.getNoFallback(&quot;Languages%short&quot;, localeId, result);
 695         if (!result.isBogus()) {
 696             return result;
 697         }
 698     }
 699     return langData.getNoFallback(&quot;Languages&quot;, localeId, result);
 700 }
 701 
 702 UnicodeString&amp;
 703 LocaleDisplayNamesImpl::languageDisplayName(const char* lang,
 704                                             UnicodeString&amp; result) const {
 705     if (uprv_strcmp(&quot;root&quot;, lang) == 0 || uprv_strchr(lang, &#39;_&#39;) != NULL) {
 706         return result = UnicodeString(lang, -1, US_INV);
 707     }
 708     if (nameLength == UDISPCTX_LENGTH_SHORT) {
 709         langData.get(&quot;Languages%short&quot;, lang, result);
 710         if (!result.isBogus()) {
 711             return adjustForUsageAndContext(kCapContextUsageLanguage, result);
 712         }
 713     }
 714     langData.get(&quot;Languages&quot;, lang, result);
 715     return adjustForUsageAndContext(kCapContextUsageLanguage, result);
 716 }
 717 
 718 UnicodeString&amp;
 719 LocaleDisplayNamesImpl::scriptDisplayName(const char* script,
 720                                           UnicodeString&amp; result,
 721                                           UBool skipAdjust) const {
 722     if (nameLength == UDISPCTX_LENGTH_SHORT) {
 723         langData.get(&quot;Scripts%short&quot;, script, result);
 724         if (!result.isBogus()) {
 725             return skipAdjust? result: adjustForUsageAndContext(kCapContextUsageScript, result);
 726         }
 727     }
 728     langData.get(&quot;Scripts&quot;, script, result);
 729     return skipAdjust? result: adjustForUsageAndContext(kCapContextUsageScript, result);
 730 }
 731 
 732 UnicodeString&amp;
 733 LocaleDisplayNamesImpl::scriptDisplayName(const char* script,
 734                                           UnicodeString&amp; result) const {
 735     return scriptDisplayName(script, result, FALSE);
 736 }
 737 
 738 UnicodeString&amp;
 739 LocaleDisplayNamesImpl::scriptDisplayName(UScriptCode scriptCode,
 740                                           UnicodeString&amp; result) const {
 741     return scriptDisplayName(uscript_getName(scriptCode), result, FALSE);
 742 }
 743 
 744 UnicodeString&amp;
 745 LocaleDisplayNamesImpl::regionDisplayName(const char* region,
 746                                           UnicodeString&amp; result,
 747                                           UBool skipAdjust) const {
 748     if (nameLength == UDISPCTX_LENGTH_SHORT) {
 749         regionData.get(&quot;Countries%short&quot;, region, result);
 750         if (!result.isBogus()) {
 751             return skipAdjust? result: adjustForUsageAndContext(kCapContextUsageTerritory, result);
 752         }
 753     }
 754     regionData.get(&quot;Countries&quot;, region, result);
 755     return skipAdjust? result: adjustForUsageAndContext(kCapContextUsageTerritory, result);
 756 }
 757 
 758 UnicodeString&amp;
 759 LocaleDisplayNamesImpl::regionDisplayName(const char* region,
 760                                           UnicodeString&amp; result) const {
 761     return regionDisplayName(region, result, FALSE);
 762 }
 763 
 764 
 765 UnicodeString&amp;
 766 LocaleDisplayNamesImpl::variantDisplayName(const char* variant,
 767                                            UnicodeString&amp; result,
 768                                            UBool skipAdjust) const {
 769     // don&#39;t have a resource for short variant names
 770     langData.get(&quot;Variants&quot;, variant, result);
 771     return skipAdjust? result: adjustForUsageAndContext(kCapContextUsageVariant, result);
 772 }
 773 
 774 UnicodeString&amp;
 775 LocaleDisplayNamesImpl::variantDisplayName(const char* variant,
 776                                            UnicodeString&amp; result) const {
 777     return variantDisplayName(variant, result, FALSE);
 778 }
 779 
 780 UnicodeString&amp;
 781 LocaleDisplayNamesImpl::keyDisplayName(const char* key,
 782                                        UnicodeString&amp; result,
 783                                        UBool skipAdjust) const {
 784     // don&#39;t have a resource for short key names
 785     langData.get(&quot;Keys&quot;, key, result);
 786     return skipAdjust? result: adjustForUsageAndContext(kCapContextUsageKey, result);
 787 }
 788 
 789 UnicodeString&amp;
 790 LocaleDisplayNamesImpl::keyDisplayName(const char* key,
 791                                        UnicodeString&amp; result) const {
 792     return keyDisplayName(key, result, FALSE);
 793 }
 794 
 795 UnicodeString&amp;
 796 LocaleDisplayNamesImpl::keyValueDisplayName(const char* key,
 797                                             const char* value,
 798                                             UnicodeString&amp; result,
 799                                             UBool skipAdjust) const {
 800     if (uprv_strcmp(key, &quot;currency&quot;) == 0) {
 801         // ICU4C does not have ICU4J CurrencyDisplayInfo equivalent for now.
 802         UErrorCode sts = U_ZERO_ERROR;
 803         UnicodeString ustrValue(value, -1, US_INV);
 804         int32_t len;
 805         UBool isChoice = FALSE;
 806         const UChar *currencyName = ucurr_getName(ustrValue.getTerminatedBuffer(),
 807             locale.getBaseName(), UCURR_LONG_NAME, &amp;isChoice, &amp;len, &amp;sts);
 808         if (U_FAILURE(sts)) {
 809             // Return the value as is on failure
 810             result = ustrValue;
 811             return result;
 812         }
 813         result.setTo(currencyName, len);
 814         return skipAdjust? result: adjustForUsageAndContext(kCapContextUsageKeyValue, result);
 815     }
 816 
 817     if (nameLength == UDISPCTX_LENGTH_SHORT) {
 818         langData.get(&quot;Types%short&quot;, key, value, result);
 819         if (!result.isBogus()) {
 820             return skipAdjust? result: adjustForUsageAndContext(kCapContextUsageKeyValue, result);
 821         }
 822     }
 823     langData.get(&quot;Types&quot;, key, value, result);
 824     return skipAdjust? result: adjustForUsageAndContext(kCapContextUsageKeyValue, result);
 825 }
 826 
 827 UnicodeString&amp;
 828 LocaleDisplayNamesImpl::keyValueDisplayName(const char* key,
 829                                             const char* value,
 830                                             UnicodeString&amp; result) const {
 831     return keyValueDisplayName(key, value, result, FALSE);
 832 }
 833 
 834 ////////////////////////////////////////////////////////////////////////////////////////////////////
 835 
 836 LocaleDisplayNames*
 837 LocaleDisplayNames::createInstance(const Locale&amp; locale,
 838                                    UDialectHandling dialectHandling) {
 839     return new LocaleDisplayNamesImpl(locale, dialectHandling);
 840 }
 841 
 842 LocaleDisplayNames*
 843 LocaleDisplayNames::createInstance(const Locale&amp; locale,
 844                                    UDisplayContext *contexts, int32_t length) {
 845     if (contexts == NULL) {
 846         length = 0;
 847     }
 848     return new LocaleDisplayNamesImpl(locale, contexts, length);
 849 }
 850 
 851 U_NAMESPACE_END
 852 
 853 ////////////////////////////////////////////////////////////////////////////////////////////////////
 854 
 855 U_NAMESPACE_USE
 856 
 857 U_CAPI ULocaleDisplayNames * U_EXPORT2
 858 uldn_open(const char * locale,
 859           UDialectHandling dialectHandling,
 860           UErrorCode *pErrorCode) {
 861   if (U_FAILURE(*pErrorCode)) {
 862     return 0;
 863   }
 864   if (locale == NULL) {
 865     locale = uloc_getDefault();
 866   }
 867   return (ULocaleDisplayNames *)LocaleDisplayNames::createInstance(Locale(locale), dialectHandling);
 868 }
 869 
 870 U_CAPI ULocaleDisplayNames * U_EXPORT2
 871 uldn_openForContext(const char * locale,
 872                     UDisplayContext *contexts, int32_t length,
 873                     UErrorCode *pErrorCode) {
 874   if (U_FAILURE(*pErrorCode)) {
 875     return 0;
 876   }
 877   if (locale == NULL) {
 878     locale = uloc_getDefault();
 879   }
 880   return (ULocaleDisplayNames *)LocaleDisplayNames::createInstance(Locale(locale), contexts, length);
 881 }
 882 
 883 
 884 U_CAPI void U_EXPORT2
 885 uldn_close(ULocaleDisplayNames *ldn) {
 886   delete (LocaleDisplayNames *)ldn;
 887 }
 888 
 889 U_CAPI const char * U_EXPORT2
 890 uldn_getLocale(const ULocaleDisplayNames *ldn) {
 891   if (ldn) {
 892     return ((const LocaleDisplayNames *)ldn)-&gt;getLocale().getName();
 893   }
 894   return NULL;
 895 }
 896 
 897 U_CAPI UDialectHandling U_EXPORT2
 898 uldn_getDialectHandling(const ULocaleDisplayNames *ldn) {
 899   if (ldn) {
 900     return ((const LocaleDisplayNames *)ldn)-&gt;getDialectHandling();
 901   }
 902   return ULDN_STANDARD_NAMES;
 903 }
 904 
 905 U_CAPI UDisplayContext U_EXPORT2
 906 uldn_getContext(const ULocaleDisplayNames *ldn,
 907               UDisplayContextType type,
 908               UErrorCode *pErrorCode) {
 909   if (U_FAILURE(*pErrorCode)) {
 910     return (UDisplayContext)0;
 911   }
 912   return ((const LocaleDisplayNames *)ldn)-&gt;getContext(type);
 913 }
 914 
 915 U_CAPI int32_t U_EXPORT2
 916 uldn_localeDisplayName(const ULocaleDisplayNames *ldn,
 917                        const char *locale,
 918                        UChar *result,
 919                        int32_t maxResultSize,
 920                        UErrorCode *pErrorCode) {
 921   if (U_FAILURE(*pErrorCode)) {
 922     return 0;
 923   }
 924   if (ldn == NULL || locale == NULL || (result == NULL &amp;&amp; maxResultSize &gt; 0) || maxResultSize &lt; 0) {
 925     *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
 926     return 0;
 927   }
 928   UnicodeString temp(result, 0, maxResultSize);
 929   ((const LocaleDisplayNames *)ldn)-&gt;localeDisplayName(locale, temp);
 930   if (temp.isBogus()) {
 931     *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
 932     return 0;
 933   }
 934   return temp.extract(result, maxResultSize, *pErrorCode);
 935 }
 936 
 937 U_CAPI int32_t U_EXPORT2
 938 uldn_languageDisplayName(const ULocaleDisplayNames *ldn,
 939                          const char *lang,
 940                          UChar *result,
 941                          int32_t maxResultSize,
 942                          UErrorCode *pErrorCode) {
 943   if (U_FAILURE(*pErrorCode)) {
 944     return 0;
 945   }
 946   if (ldn == NULL || lang == NULL || (result == NULL &amp;&amp; maxResultSize &gt; 0) || maxResultSize &lt; 0) {
 947     *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
 948     return 0;
 949   }
 950   UnicodeString temp(result, 0, maxResultSize);
 951   ((const LocaleDisplayNames *)ldn)-&gt;languageDisplayName(lang, temp);
 952   return temp.extract(result, maxResultSize, *pErrorCode);
 953 }
 954 
 955 U_CAPI int32_t U_EXPORT2
 956 uldn_scriptDisplayName(const ULocaleDisplayNames *ldn,
 957                        const char *script,
 958                        UChar *result,
 959                        int32_t maxResultSize,
 960                        UErrorCode *pErrorCode) {
 961   if (U_FAILURE(*pErrorCode)) {
 962     return 0;
 963   }
 964   if (ldn == NULL || script == NULL || (result == NULL &amp;&amp; maxResultSize &gt; 0) || maxResultSize &lt; 0) {
 965     *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
 966     return 0;
 967   }
 968   UnicodeString temp(result, 0, maxResultSize);
 969   ((const LocaleDisplayNames *)ldn)-&gt;scriptDisplayName(script, temp);
 970   return temp.extract(result, maxResultSize, *pErrorCode);
 971 }
 972 
 973 U_CAPI int32_t U_EXPORT2
 974 uldn_scriptCodeDisplayName(const ULocaleDisplayNames *ldn,
 975                            UScriptCode scriptCode,
 976                            UChar *result,
 977                            int32_t maxResultSize,
 978                            UErrorCode *pErrorCode) {
 979   return uldn_scriptDisplayName(ldn, uscript_getName(scriptCode), result, maxResultSize, pErrorCode);
 980 }
 981 
 982 U_CAPI int32_t U_EXPORT2
 983 uldn_regionDisplayName(const ULocaleDisplayNames *ldn,
 984                        const char *region,
 985                        UChar *result,
 986                        int32_t maxResultSize,
 987                        UErrorCode *pErrorCode) {
 988   if (U_FAILURE(*pErrorCode)) {
 989     return 0;
 990   }
 991   if (ldn == NULL || region == NULL || (result == NULL &amp;&amp; maxResultSize &gt; 0) || maxResultSize &lt; 0) {
 992     *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
 993     return 0;
 994   }
 995   UnicodeString temp(result, 0, maxResultSize);
 996   ((const LocaleDisplayNames *)ldn)-&gt;regionDisplayName(region, temp);
 997   return temp.extract(result, maxResultSize, *pErrorCode);
 998 }
 999 
1000 U_CAPI int32_t U_EXPORT2
1001 uldn_variantDisplayName(const ULocaleDisplayNames *ldn,
1002                         const char *variant,
1003                         UChar *result,
1004                         int32_t maxResultSize,
1005                         UErrorCode *pErrorCode) {
1006   if (U_FAILURE(*pErrorCode)) {
1007     return 0;
1008   }
1009   if (ldn == NULL || variant == NULL || (result == NULL &amp;&amp; maxResultSize &gt; 0) || maxResultSize &lt; 0) {
1010     *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
1011     return 0;
1012   }
1013   UnicodeString temp(result, 0, maxResultSize);
1014   ((const LocaleDisplayNames *)ldn)-&gt;variantDisplayName(variant, temp);
1015   return temp.extract(result, maxResultSize, *pErrorCode);
1016 }
1017 
1018 U_CAPI int32_t U_EXPORT2
1019 uldn_keyDisplayName(const ULocaleDisplayNames *ldn,
1020                     const char *key,
1021                     UChar *result,
1022                     int32_t maxResultSize,
1023                     UErrorCode *pErrorCode) {
1024   if (U_FAILURE(*pErrorCode)) {
1025     return 0;
1026   }
1027   if (ldn == NULL || key == NULL || (result == NULL &amp;&amp; maxResultSize &gt; 0) || maxResultSize &lt; 0) {
1028     *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
1029     return 0;
1030   }
1031   UnicodeString temp(result, 0, maxResultSize);
1032   ((const LocaleDisplayNames *)ldn)-&gt;keyDisplayName(key, temp);
1033   return temp.extract(result, maxResultSize, *pErrorCode);
1034 }
1035 
1036 U_CAPI int32_t U_EXPORT2
1037 uldn_keyValueDisplayName(const ULocaleDisplayNames *ldn,
1038                          const char *key,
1039                          const char *value,
1040                          UChar *result,
1041                          int32_t maxResultSize,
1042                          UErrorCode *pErrorCode) {
1043   if (U_FAILURE(*pErrorCode)) {
1044     return 0;
1045   }
1046   if (ldn == NULL || key == NULL || value == NULL || (result == NULL &amp;&amp; maxResultSize &gt; 0)
1047       || maxResultSize &lt; 0) {
1048     *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
1049     return 0;
1050   }
1051   UnicodeString temp(result, 0, maxResultSize);
1052   ((const LocaleDisplayNames *)ldn)-&gt;keyValueDisplayName(key, value, temp);
1053   return temp.extract(result, maxResultSize, *pErrorCode);
1054 }
1055 
1056 #endif
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>