<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 1997-2016, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 *
   9 * File ULOC.CPP
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   04/01/97    aliu        Creation.
  15 *   08/21/98    stephen     JDK 1.2 sync
  16 *   12/08/98    rtg         New Locale implementation and C API
  17 *   03/15/99    damiba      overhaul.
  18 *   04/06/99    stephen     changed setDefault() to realloc and copy
  19 *   06/14/99    stephen     Changed calls to ures_open for new params
  20 *   07/21/99    stephen     Modified setDefault() to propagate to C++
  21 *   05/14/04    alan        7 years later: refactored, cleaned up, fixed bugs,
  22 *                           brought canonicalization code into line with spec
  23 *****************************************************************************/
  24 
  25 /*
  26    POSIX&#39;s locale format, from putil.c: [no spaces]
  27 
  28      ll [ _CC ] [ . MM ] [ @ VV]
  29 
  30      l = lang, C = ctry, M = charmap, V = variant
  31 */
  32 
  33 #include &quot;unicode/utypes.h&quot;
  34 #include &quot;unicode/ustring.h&quot;
  35 #include &quot;unicode/uloc.h&quot;
  36 
  37 #include &quot;putilimp.h&quot;
  38 #include &quot;ustr_imp.h&quot;
  39 #include &quot;ulocimp.h&quot;
  40 #include &quot;umutex.h&quot;
  41 #include &quot;cstring.h&quot;
  42 #include &quot;cmemory.h&quot;
  43 #include &quot;locmap.h&quot;
  44 #include &quot;uarrsort.h&quot;
  45 #include &quot;uenumimp.h&quot;
  46 #include &quot;uassert.h&quot;
  47 #include &quot;charstr.h&quot;
  48 
  49 #include &lt;stdio.h&gt; /* for sprintf */
  50 
  51 U_NAMESPACE_USE
  52 
  53 /* ### Declarations **************************************************/
  54 
  55 /* Locale stuff from locid.cpp */
  56 U_CFUNC void locale_set_default(const char *id);
  57 U_CFUNC const char *locale_get_default(void);
  58 U_CFUNC int32_t
  59 locale_getKeywords(const char *localeID,
  60             char prev,
  61             char *keywords, int32_t keywordCapacity,
  62             char *values, int32_t valuesCapacity, int32_t *valLen,
  63             UBool valuesToo,
  64             UErrorCode *status);
  65 
  66 /* ### Data tables **************************************************/
  67 
  68 /**
  69  * Table of language codes, both 2- and 3-letter, with preference
  70  * given to 2-letter codes where possible.  Includes 3-letter codes
  71  * that lack a 2-letter equivalent.
  72  *
  73  * This list must be in sorted order.  This list is returned directly
  74  * to the user by some API.
  75  *
  76  * This list must be kept in sync with LANGUAGES_3, with corresponding
  77  * entries matched.
  78  *
  79  * This table should be terminated with a NULL entry, followed by a
  80  * second list, and another NULL entry.  The first list is visible to
  81  * user code when this array is returned by API.  The second list
  82  * contains codes we support, but do not expose through user API.
  83  *
  84  * Notes
  85  *
  86  * Tables updated per http://lcweb.loc.gov/standards/iso639-2/ to
  87  * include the revisions up to 2001/7/27 *CWB*
  88  *
  89  * The 3 character codes are the terminology codes like RFC 3066.  This
  90  * is compatible with prior ICU codes
  91  *
  92  * &quot;in&quot; &quot;iw&quot; &quot;ji&quot; &quot;jw&quot; &amp; &quot;sh&quot; have been withdrawn but are still in the
  93  * table but now at the end of the table because 3 character codes are
  94  * duplicates.  This avoids bad searches going from 3 to 2 character
  95  * codes.
  96  *
  97  * The range qaa-qtz is reserved for local use
  98  */
  99 /* Generated using org.unicode.cldr.icu.GenerateISO639LanguageTables */
 100 /* ISO639 table version is 20150505 */
 101 /* Subsequent hand addition of selected languages */
 102 static const char * const LANGUAGES[] = {
 103     &quot;aa&quot;,  &quot;ab&quot;,  &quot;ace&quot;, &quot;ach&quot;, &quot;ada&quot;, &quot;ady&quot;, &quot;ae&quot;,  &quot;aeb&quot;,
 104     &quot;af&quot;,  &quot;afh&quot;, &quot;agq&quot;, &quot;ain&quot;, &quot;ak&quot;,  &quot;akk&quot;, &quot;akz&quot;, &quot;ale&quot;,
 105     &quot;aln&quot;, &quot;alt&quot;, &quot;am&quot;,  &quot;an&quot;,  &quot;ang&quot;, &quot;anp&quot;, &quot;ar&quot;,  &quot;arc&quot;,
 106     &quot;arn&quot;, &quot;aro&quot;, &quot;arp&quot;, &quot;arq&quot;, &quot;ars&quot;, &quot;arw&quot;, &quot;ary&quot;, &quot;arz&quot;, &quot;as&quot;,
 107     &quot;asa&quot;, &quot;ase&quot;, &quot;ast&quot;, &quot;av&quot;,  &quot;avk&quot;, &quot;awa&quot;, &quot;ay&quot;,  &quot;az&quot;,
 108     &quot;ba&quot;,  &quot;bal&quot;, &quot;ban&quot;, &quot;bar&quot;, &quot;bas&quot;, &quot;bax&quot;, &quot;bbc&quot;, &quot;bbj&quot;,
 109     &quot;be&quot;,  &quot;bej&quot;, &quot;bem&quot;, &quot;bew&quot;, &quot;bez&quot;, &quot;bfd&quot;, &quot;bfq&quot;, &quot;bg&quot;,
 110     &quot;bgn&quot;, &quot;bho&quot;, &quot;bi&quot;,  &quot;bik&quot;, &quot;bin&quot;, &quot;bjn&quot;, &quot;bkm&quot;, &quot;bla&quot;,
 111     &quot;bm&quot;,  &quot;bn&quot;,  &quot;bo&quot;,  &quot;bpy&quot;, &quot;bqi&quot;, &quot;br&quot;,  &quot;bra&quot;, &quot;brh&quot;,
 112     &quot;brx&quot;, &quot;bs&quot;,  &quot;bss&quot;, &quot;bua&quot;, &quot;bug&quot;, &quot;bum&quot;, &quot;byn&quot;, &quot;byv&quot;,
 113     &quot;ca&quot;,  &quot;cad&quot;, &quot;car&quot;, &quot;cay&quot;, &quot;cch&quot;, &quot;ccp&quot;, &quot;ce&quot;,  &quot;ceb&quot;, &quot;cgg&quot;,
 114     &quot;ch&quot;,  &quot;chb&quot;, &quot;chg&quot;, &quot;chk&quot;, &quot;chm&quot;, &quot;chn&quot;, &quot;cho&quot;, &quot;chp&quot;,
 115     &quot;chr&quot;, &quot;chy&quot;, &quot;ckb&quot;, &quot;co&quot;,  &quot;cop&quot;, &quot;cps&quot;, &quot;cr&quot;,  &quot;crh&quot;,
 116     &quot;cs&quot;,  &quot;csb&quot;, &quot;cu&quot;,  &quot;cv&quot;,  &quot;cy&quot;,
 117     &quot;da&quot;,  &quot;dak&quot;, &quot;dar&quot;, &quot;dav&quot;, &quot;de&quot;,  &quot;del&quot;, &quot;den&quot;, &quot;dgr&quot;,
 118     &quot;din&quot;, &quot;dje&quot;, &quot;doi&quot;, &quot;dsb&quot;, &quot;dtp&quot;, &quot;dua&quot;, &quot;dum&quot;, &quot;dv&quot;,
 119     &quot;dyo&quot;, &quot;dyu&quot;, &quot;dz&quot;,  &quot;dzg&quot;,
 120     &quot;ebu&quot;, &quot;ee&quot;,  &quot;efi&quot;, &quot;egl&quot;, &quot;egy&quot;, &quot;eka&quot;, &quot;el&quot;,  &quot;elx&quot;,
 121     &quot;en&quot;,  &quot;enm&quot;, &quot;eo&quot;,  &quot;es&quot;,  &quot;esu&quot;, &quot;et&quot;,  &quot;eu&quot;,  &quot;ewo&quot;,
 122     &quot;ext&quot;,
 123     &quot;fa&quot;,  &quot;fan&quot;, &quot;fat&quot;, &quot;ff&quot;,  &quot;fi&quot;,  &quot;fil&quot;, &quot;fit&quot;, &quot;fj&quot;,
 124     &quot;fo&quot;,  &quot;fon&quot;, &quot;fr&quot;,  &quot;frc&quot;, &quot;frm&quot;, &quot;fro&quot;, &quot;frp&quot;, &quot;frr&quot;,
 125     &quot;frs&quot;, &quot;fur&quot;, &quot;fy&quot;,
 126     &quot;ga&quot;,  &quot;gaa&quot;, &quot;gag&quot;, &quot;gan&quot;, &quot;gay&quot;, &quot;gba&quot;, &quot;gbz&quot;, &quot;gd&quot;,
 127     &quot;gez&quot;, &quot;gil&quot;, &quot;gl&quot;,  &quot;glk&quot;, &quot;gmh&quot;, &quot;gn&quot;,  &quot;goh&quot;, &quot;gom&quot;,
 128     &quot;gon&quot;, &quot;gor&quot;, &quot;got&quot;, &quot;grb&quot;, &quot;grc&quot;, &quot;gsw&quot;, &quot;gu&quot;,  &quot;guc&quot;,
 129     &quot;gur&quot;, &quot;guz&quot;, &quot;gv&quot;,  &quot;gwi&quot;,
 130     &quot;ha&quot;,  &quot;hai&quot;, &quot;hak&quot;, &quot;haw&quot;, &quot;he&quot;,  &quot;hi&quot;,  &quot;hif&quot;, &quot;hil&quot;,
 131     &quot;hit&quot;, &quot;hmn&quot;, &quot;ho&quot;,  &quot;hr&quot;,  &quot;hsb&quot;, &quot;hsn&quot;, &quot;ht&quot;,  &quot;hu&quot;,
 132     &quot;hup&quot;, &quot;hy&quot;,  &quot;hz&quot;,
 133     &quot;ia&quot;,  &quot;iba&quot;, &quot;ibb&quot;, &quot;id&quot;,  &quot;ie&quot;,  &quot;ig&quot;,  &quot;ii&quot;,  &quot;ik&quot;,
 134     &quot;ilo&quot;, &quot;inh&quot;, &quot;io&quot;,  &quot;is&quot;,  &quot;it&quot;,  &quot;iu&quot;,  &quot;izh&quot;,
 135     &quot;ja&quot;,  &quot;jam&quot;, &quot;jbo&quot;, &quot;jgo&quot;, &quot;jmc&quot;, &quot;jpr&quot;, &quot;jrb&quot;, &quot;jut&quot;,
 136     &quot;jv&quot;,
 137     &quot;ka&quot;,  &quot;kaa&quot;, &quot;kab&quot;, &quot;kac&quot;, &quot;kaj&quot;, &quot;kam&quot;, &quot;kaw&quot;, &quot;kbd&quot;,
 138     &quot;kbl&quot;, &quot;kcg&quot;, &quot;kde&quot;, &quot;kea&quot;, &quot;ken&quot;, &quot;kfo&quot;, &quot;kg&quot;,  &quot;kgp&quot;,
 139     &quot;kha&quot;, &quot;kho&quot;, &quot;khq&quot;, &quot;khw&quot;, &quot;ki&quot;,  &quot;kiu&quot;, &quot;kj&quot;,  &quot;kk&quot;,
 140     &quot;kkj&quot;, &quot;kl&quot;,  &quot;kln&quot;, &quot;km&quot;,  &quot;kmb&quot;, &quot;kn&quot;,  &quot;ko&quot;,  &quot;koi&quot;,
 141     &quot;kok&quot;, &quot;kos&quot;, &quot;kpe&quot;, &quot;kr&quot;,  &quot;krc&quot;, &quot;kri&quot;, &quot;krj&quot;, &quot;krl&quot;,
 142     &quot;kru&quot;, &quot;ks&quot;,  &quot;ksb&quot;, &quot;ksf&quot;, &quot;ksh&quot;, &quot;ku&quot;,  &quot;kum&quot;, &quot;kut&quot;,
 143     &quot;kv&quot;,  &quot;kw&quot;,  &quot;ky&quot;,
 144     &quot;la&quot;,  &quot;lad&quot;, &quot;lag&quot;, &quot;lah&quot;, &quot;lam&quot;, &quot;lb&quot;,  &quot;lez&quot;, &quot;lfn&quot;,
 145     &quot;lg&quot;,  &quot;li&quot;,  &quot;lij&quot;, &quot;liv&quot;, &quot;lkt&quot;, &quot;lmo&quot;, &quot;ln&quot;,  &quot;lo&quot;,
 146     &quot;lol&quot;, &quot;loz&quot;, &quot;lrc&quot;, &quot;lt&quot;,  &quot;ltg&quot;, &quot;lu&quot;,  &quot;lua&quot;, &quot;lui&quot;,
 147     &quot;lun&quot;, &quot;luo&quot;, &quot;lus&quot;, &quot;luy&quot;, &quot;lv&quot;,  &quot;lzh&quot;, &quot;lzz&quot;,
 148     &quot;mad&quot;, &quot;maf&quot;, &quot;mag&quot;, &quot;mai&quot;, &quot;mak&quot;, &quot;man&quot;, &quot;mas&quot;, &quot;mde&quot;,
 149     &quot;mdf&quot;, &quot;mdh&quot;, &quot;mdr&quot;, &quot;men&quot;, &quot;mer&quot;, &quot;mfe&quot;, &quot;mg&quot;,  &quot;mga&quot;,
 150     &quot;mgh&quot;, &quot;mgo&quot;, &quot;mh&quot;,  &quot;mi&quot;,  &quot;mic&quot;, &quot;min&quot;, &quot;mis&quot;, &quot;mk&quot;,
 151     &quot;ml&quot;,  &quot;mn&quot;,  &quot;mnc&quot;, &quot;mni&quot;, &quot;moh&quot;, &quot;mos&quot;, &quot;mr&quot;,  &quot;mrj&quot;,
 152     &quot;ms&quot;,  &quot;mt&quot;,  &quot;mua&quot;, &quot;mul&quot;, &quot;mus&quot;, &quot;mwl&quot;, &quot;mwr&quot;, &quot;mwv&quot;,
 153     &quot;my&quot;,  &quot;mye&quot;, &quot;myv&quot;, &quot;mzn&quot;,
 154     &quot;na&quot;,  &quot;nan&quot;, &quot;nap&quot;, &quot;naq&quot;, &quot;nb&quot;,  &quot;nd&quot;,  &quot;nds&quot;, &quot;ne&quot;,
 155     &quot;new&quot;, &quot;ng&quot;,  &quot;nia&quot;, &quot;niu&quot;, &quot;njo&quot;, &quot;nl&quot;,  &quot;nmg&quot;, &quot;nn&quot;,
 156     &quot;nnh&quot;, &quot;no&quot;,  &quot;nog&quot;, &quot;non&quot;, &quot;nov&quot;, &quot;nqo&quot;, &quot;nr&quot;,  &quot;nso&quot;,
 157     &quot;nus&quot;, &quot;nv&quot;,  &quot;nwc&quot;, &quot;ny&quot;,  &quot;nym&quot;, &quot;nyn&quot;, &quot;nyo&quot;, &quot;nzi&quot;,
 158     &quot;oc&quot;,  &quot;oj&quot;,  &quot;om&quot;,  &quot;or&quot;,  &quot;os&quot;,  &quot;osa&quot;, &quot;ota&quot;,
 159     &quot;pa&quot;,  &quot;pag&quot;, &quot;pal&quot;, &quot;pam&quot;, &quot;pap&quot;, &quot;pau&quot;, &quot;pcd&quot;, &quot;pdc&quot;,
 160     &quot;pdt&quot;, &quot;peo&quot;, &quot;pfl&quot;, &quot;phn&quot;, &quot;pi&quot;,  &quot;pl&quot;,  &quot;pms&quot;, &quot;pnt&quot;,
 161     &quot;pon&quot;, &quot;prg&quot;, &quot;pro&quot;, &quot;ps&quot;,  &quot;pt&quot;,
 162     &quot;qu&quot;,  &quot;quc&quot;, &quot;qug&quot;,
 163     &quot;raj&quot;, &quot;rap&quot;, &quot;rar&quot;, &quot;rgn&quot;, &quot;rif&quot;, &quot;rm&quot;,  &quot;rn&quot;,  &quot;ro&quot;,
 164     &quot;rof&quot;, &quot;rom&quot;, &quot;rtm&quot;, &quot;ru&quot;,  &quot;rue&quot;, &quot;rug&quot;, &quot;rup&quot;,
 165     &quot;rw&quot;,  &quot;rwk&quot;,
 166     &quot;sa&quot;,  &quot;sad&quot;, &quot;sah&quot;, &quot;sam&quot;, &quot;saq&quot;, &quot;sas&quot;, &quot;sat&quot;, &quot;saz&quot;,
 167     &quot;sba&quot;, &quot;sbp&quot;, &quot;sc&quot;,  &quot;scn&quot;, &quot;sco&quot;, &quot;sd&quot;,  &quot;sdc&quot;, &quot;sdh&quot;,
 168     &quot;se&quot;,  &quot;see&quot;, &quot;seh&quot;, &quot;sei&quot;, &quot;sel&quot;, &quot;ses&quot;, &quot;sg&quot;,  &quot;sga&quot;,
 169     &quot;sgs&quot;, &quot;shi&quot;, &quot;shn&quot;, &quot;shu&quot;, &quot;si&quot;,  &quot;sid&quot;, &quot;sk&quot;,
 170     &quot;sl&quot;,  &quot;sli&quot;, &quot;sly&quot;, &quot;sm&quot;,  &quot;sma&quot;, &quot;smj&quot;, &quot;smn&quot;, &quot;sms&quot;,
 171     &quot;sn&quot;,  &quot;snk&quot;, &quot;so&quot;,  &quot;sog&quot;, &quot;sq&quot;,  &quot;sr&quot;,  &quot;srn&quot;, &quot;srr&quot;,
 172     &quot;ss&quot;,  &quot;ssy&quot;, &quot;st&quot;,  &quot;stq&quot;, &quot;su&quot;,  &quot;suk&quot;, &quot;sus&quot;, &quot;sux&quot;,
 173     &quot;sv&quot;,  &quot;sw&quot;,  &quot;swb&quot;, &quot;swc&quot;, &quot;syc&quot;, &quot;syr&quot;, &quot;szl&quot;,
 174     &quot;ta&quot;,  &quot;tcy&quot;, &quot;te&quot;,  &quot;tem&quot;, &quot;teo&quot;, &quot;ter&quot;, &quot;tet&quot;, &quot;tg&quot;,
 175     &quot;th&quot;,  &quot;ti&quot;,  &quot;tig&quot;, &quot;tiv&quot;, &quot;tk&quot;,  &quot;tkl&quot;, &quot;tkr&quot;, &quot;tl&quot;,
 176     &quot;tlh&quot;, &quot;tli&quot;, &quot;tly&quot;, &quot;tmh&quot;, &quot;tn&quot;,  &quot;to&quot;,  &quot;tog&quot;, &quot;tpi&quot;,
 177     &quot;tr&quot;,  &quot;tru&quot;, &quot;trv&quot;, &quot;ts&quot;,  &quot;tsd&quot;, &quot;tsi&quot;, &quot;tt&quot;,  &quot;ttt&quot;,
 178     &quot;tum&quot;, &quot;tvl&quot;, &quot;tw&quot;,  &quot;twq&quot;, &quot;ty&quot;,  &quot;tyv&quot;, &quot;tzm&quot;,
 179     &quot;udm&quot;, &quot;ug&quot;,  &quot;uga&quot;, &quot;uk&quot;,  &quot;umb&quot;, &quot;und&quot;, &quot;ur&quot;,  &quot;uz&quot;,
 180     &quot;vai&quot;, &quot;ve&quot;,  &quot;vec&quot;, &quot;vep&quot;, &quot;vi&quot;,  &quot;vls&quot;, &quot;vmf&quot;, &quot;vo&quot;,
 181     &quot;vot&quot;, &quot;vro&quot;, &quot;vun&quot;,
 182     &quot;wa&quot;,  &quot;wae&quot;, &quot;wal&quot;, &quot;war&quot;, &quot;was&quot;, &quot;wbp&quot;, &quot;wo&quot;,  &quot;wuu&quot;,
 183     &quot;xal&quot;, &quot;xh&quot;,  &quot;xmf&quot;, &quot;xog&quot;,
 184     &quot;yao&quot;, &quot;yap&quot;, &quot;yav&quot;, &quot;ybb&quot;, &quot;yi&quot;,  &quot;yo&quot;,  &quot;yrl&quot;, &quot;yue&quot;,
 185     &quot;za&quot;,  &quot;zap&quot;, &quot;zbl&quot;, &quot;zea&quot;, &quot;zen&quot;, &quot;zgh&quot;, &quot;zh&quot;,  &quot;zu&quot;,
 186     &quot;zun&quot;, &quot;zxx&quot;, &quot;zza&quot;,
 187 NULL,
 188     &quot;in&quot;,  &quot;iw&quot;,  &quot;ji&quot;,  &quot;jw&quot;,  &quot;sh&quot;,    /* obsolete language codes */
 189 NULL
 190 };
 191 
 192 static const char* const DEPRECATED_LANGUAGES[]={
 193     &quot;in&quot;, &quot;iw&quot;, &quot;ji&quot;, &quot;jw&quot;, NULL, NULL
 194 };
 195 static const char* const REPLACEMENT_LANGUAGES[]={
 196     &quot;id&quot;, &quot;he&quot;, &quot;yi&quot;, &quot;jv&quot;, NULL, NULL
 197 };
 198 
 199 /**
 200  * Table of 3-letter language codes.
 201  *
 202  * This is a lookup table used to convert 3-letter language codes to
 203  * their 2-letter equivalent, where possible.  It must be kept in sync
 204  * with LANGUAGES.  For all valid i, LANGUAGES[i] must refer to the
 205  * same language as LANGUAGES_3[i].  The commented-out lines are
 206  * copied from LANGUAGES to make eyeballing this baby easier.
 207  *
 208  * Where a 3-letter language code has no 2-letter equivalent, the
 209  * 3-letter code occupies both LANGUAGES[i] and LANGUAGES_3[i].
 210  *
 211  * This table should be terminated with a NULL entry, followed by a
 212  * second list, and another NULL entry.  The two lists correspond to
 213  * the two lists in LANGUAGES.
 214  */
 215 /* Generated using org.unicode.cldr.icu.GenerateISO639LanguageTables */
 216 /* ISO639 table version is 20150505 */
 217 /* Subsequent hand addition of selected languages */
 218 static const char * const LANGUAGES_3[] = {
 219     &quot;aar&quot;, &quot;abk&quot;, &quot;ace&quot;, &quot;ach&quot;, &quot;ada&quot;, &quot;ady&quot;, &quot;ave&quot;, &quot;aeb&quot;,
 220     &quot;afr&quot;, &quot;afh&quot;, &quot;agq&quot;, &quot;ain&quot;, &quot;aka&quot;, &quot;akk&quot;, &quot;akz&quot;, &quot;ale&quot;,
 221     &quot;aln&quot;, &quot;alt&quot;, &quot;amh&quot;, &quot;arg&quot;, &quot;ang&quot;, &quot;anp&quot;, &quot;ara&quot;, &quot;arc&quot;,
 222     &quot;arn&quot;, &quot;aro&quot;, &quot;arp&quot;, &quot;arq&quot;, &quot;ars&quot;, &quot;arw&quot;, &quot;ary&quot;, &quot;arz&quot;, &quot;asm&quot;,
 223     &quot;asa&quot;, &quot;ase&quot;, &quot;ast&quot;, &quot;ava&quot;, &quot;avk&quot;, &quot;awa&quot;, &quot;aym&quot;, &quot;aze&quot;,
 224     &quot;bak&quot;, &quot;bal&quot;, &quot;ban&quot;, &quot;bar&quot;, &quot;bas&quot;, &quot;bax&quot;, &quot;bbc&quot;, &quot;bbj&quot;,
 225     &quot;bel&quot;, &quot;bej&quot;, &quot;bem&quot;, &quot;bew&quot;, &quot;bez&quot;, &quot;bfd&quot;, &quot;bfq&quot;, &quot;bul&quot;,
 226     &quot;bgn&quot;, &quot;bho&quot;, &quot;bis&quot;, &quot;bik&quot;, &quot;bin&quot;, &quot;bjn&quot;, &quot;bkm&quot;, &quot;bla&quot;,
 227     &quot;bam&quot;, &quot;ben&quot;, &quot;bod&quot;, &quot;bpy&quot;, &quot;bqi&quot;, &quot;bre&quot;, &quot;bra&quot;, &quot;brh&quot;,
 228     &quot;brx&quot;, &quot;bos&quot;, &quot;bss&quot;, &quot;bua&quot;, &quot;bug&quot;, &quot;bum&quot;, &quot;byn&quot;, &quot;byv&quot;,
 229     &quot;cat&quot;, &quot;cad&quot;, &quot;car&quot;, &quot;cay&quot;, &quot;cch&quot;, &quot;ccp&quot;, &quot;che&quot;, &quot;ceb&quot;, &quot;cgg&quot;,
 230     &quot;cha&quot;, &quot;chb&quot;, &quot;chg&quot;, &quot;chk&quot;, &quot;chm&quot;, &quot;chn&quot;, &quot;cho&quot;, &quot;chp&quot;,
 231     &quot;chr&quot;, &quot;chy&quot;, &quot;ckb&quot;, &quot;cos&quot;, &quot;cop&quot;, &quot;cps&quot;, &quot;cre&quot;, &quot;crh&quot;,
 232     &quot;ces&quot;, &quot;csb&quot;, &quot;chu&quot;, &quot;chv&quot;, &quot;cym&quot;,
 233     &quot;dan&quot;, &quot;dak&quot;, &quot;dar&quot;, &quot;dav&quot;, &quot;deu&quot;, &quot;del&quot;, &quot;den&quot;, &quot;dgr&quot;,
 234     &quot;din&quot;, &quot;dje&quot;, &quot;doi&quot;, &quot;dsb&quot;, &quot;dtp&quot;, &quot;dua&quot;, &quot;dum&quot;, &quot;div&quot;,
 235     &quot;dyo&quot;, &quot;dyu&quot;, &quot;dzo&quot;, &quot;dzg&quot;,
 236     &quot;ebu&quot;, &quot;ewe&quot;, &quot;efi&quot;, &quot;egl&quot;, &quot;egy&quot;, &quot;eka&quot;, &quot;ell&quot;, &quot;elx&quot;,
 237     &quot;eng&quot;, &quot;enm&quot;, &quot;epo&quot;, &quot;spa&quot;, &quot;esu&quot;, &quot;est&quot;, &quot;eus&quot;, &quot;ewo&quot;,
 238     &quot;ext&quot;,
 239     &quot;fas&quot;, &quot;fan&quot;, &quot;fat&quot;, &quot;ful&quot;, &quot;fin&quot;, &quot;fil&quot;, &quot;fit&quot;, &quot;fij&quot;,
 240     &quot;fao&quot;, &quot;fon&quot;, &quot;fra&quot;, &quot;frc&quot;, &quot;frm&quot;, &quot;fro&quot;, &quot;frp&quot;, &quot;frr&quot;,
 241     &quot;frs&quot;, &quot;fur&quot;, &quot;fry&quot;,
 242     &quot;gle&quot;, &quot;gaa&quot;, &quot;gag&quot;, &quot;gan&quot;, &quot;gay&quot;, &quot;gba&quot;, &quot;gbz&quot;, &quot;gla&quot;,
 243     &quot;gez&quot;, &quot;gil&quot;, &quot;glg&quot;, &quot;glk&quot;, &quot;gmh&quot;, &quot;grn&quot;, &quot;goh&quot;, &quot;gom&quot;,
 244     &quot;gon&quot;, &quot;gor&quot;, &quot;got&quot;, &quot;grb&quot;, &quot;grc&quot;, &quot;gsw&quot;, &quot;guj&quot;, &quot;guc&quot;,
 245     &quot;gur&quot;, &quot;guz&quot;, &quot;glv&quot;, &quot;gwi&quot;,
 246     &quot;hau&quot;, &quot;hai&quot;, &quot;hak&quot;, &quot;haw&quot;, &quot;heb&quot;, &quot;hin&quot;, &quot;hif&quot;, &quot;hil&quot;,
 247     &quot;hit&quot;, &quot;hmn&quot;, &quot;hmo&quot;, &quot;hrv&quot;, &quot;hsb&quot;, &quot;hsn&quot;, &quot;hat&quot;, &quot;hun&quot;,
 248     &quot;hup&quot;, &quot;hye&quot;, &quot;her&quot;,
 249     &quot;ina&quot;, &quot;iba&quot;, &quot;ibb&quot;, &quot;ind&quot;, &quot;ile&quot;, &quot;ibo&quot;, &quot;iii&quot;, &quot;ipk&quot;,
 250     &quot;ilo&quot;, &quot;inh&quot;, &quot;ido&quot;, &quot;isl&quot;, &quot;ita&quot;, &quot;iku&quot;, &quot;izh&quot;,
 251     &quot;jpn&quot;, &quot;jam&quot;, &quot;jbo&quot;, &quot;jgo&quot;, &quot;jmc&quot;, &quot;jpr&quot;, &quot;jrb&quot;, &quot;jut&quot;,
 252     &quot;jav&quot;,
 253     &quot;kat&quot;, &quot;kaa&quot;, &quot;kab&quot;, &quot;kac&quot;, &quot;kaj&quot;, &quot;kam&quot;, &quot;kaw&quot;, &quot;kbd&quot;,
 254     &quot;kbl&quot;, &quot;kcg&quot;, &quot;kde&quot;, &quot;kea&quot;, &quot;ken&quot;, &quot;kfo&quot;, &quot;kon&quot;, &quot;kgp&quot;,
 255     &quot;kha&quot;, &quot;kho&quot;, &quot;khq&quot;, &quot;khw&quot;, &quot;kik&quot;, &quot;kiu&quot;, &quot;kua&quot;, &quot;kaz&quot;,
 256     &quot;kkj&quot;, &quot;kal&quot;, &quot;kln&quot;, &quot;khm&quot;, &quot;kmb&quot;, &quot;kan&quot;, &quot;kor&quot;, &quot;koi&quot;,
 257     &quot;kok&quot;, &quot;kos&quot;, &quot;kpe&quot;, &quot;kau&quot;, &quot;krc&quot;, &quot;kri&quot;, &quot;krj&quot;, &quot;krl&quot;,
 258     &quot;kru&quot;, &quot;kas&quot;, &quot;ksb&quot;, &quot;ksf&quot;, &quot;ksh&quot;, &quot;kur&quot;, &quot;kum&quot;, &quot;kut&quot;,
 259     &quot;kom&quot;, &quot;cor&quot;, &quot;kir&quot;,
 260     &quot;lat&quot;, &quot;lad&quot;, &quot;lag&quot;, &quot;lah&quot;, &quot;lam&quot;, &quot;ltz&quot;, &quot;lez&quot;, &quot;lfn&quot;,
 261     &quot;lug&quot;, &quot;lim&quot;, &quot;lij&quot;, &quot;liv&quot;, &quot;lkt&quot;, &quot;lmo&quot;, &quot;lin&quot;, &quot;lao&quot;,
 262     &quot;lol&quot;, &quot;loz&quot;, &quot;lrc&quot;, &quot;lit&quot;, &quot;ltg&quot;, &quot;lub&quot;, &quot;lua&quot;, &quot;lui&quot;,
 263     &quot;lun&quot;, &quot;luo&quot;, &quot;lus&quot;, &quot;luy&quot;, &quot;lav&quot;, &quot;lzh&quot;, &quot;lzz&quot;,
 264     &quot;mad&quot;, &quot;maf&quot;, &quot;mag&quot;, &quot;mai&quot;, &quot;mak&quot;, &quot;man&quot;, &quot;mas&quot;, &quot;mde&quot;,
 265     &quot;mdf&quot;, &quot;mdh&quot;, &quot;mdr&quot;, &quot;men&quot;, &quot;mer&quot;, &quot;mfe&quot;, &quot;mlg&quot;, &quot;mga&quot;,
 266     &quot;mgh&quot;, &quot;mgo&quot;, &quot;mah&quot;, &quot;mri&quot;, &quot;mic&quot;, &quot;min&quot;, &quot;mis&quot;, &quot;mkd&quot;,
 267     &quot;mal&quot;, &quot;mon&quot;, &quot;mnc&quot;, &quot;mni&quot;, &quot;moh&quot;, &quot;mos&quot;, &quot;mar&quot;, &quot;mrj&quot;,
 268     &quot;msa&quot;, &quot;mlt&quot;, &quot;mua&quot;, &quot;mul&quot;, &quot;mus&quot;, &quot;mwl&quot;, &quot;mwr&quot;, &quot;mwv&quot;,
 269     &quot;mya&quot;, &quot;mye&quot;, &quot;myv&quot;, &quot;mzn&quot;,
 270     &quot;nau&quot;, &quot;nan&quot;, &quot;nap&quot;, &quot;naq&quot;, &quot;nob&quot;, &quot;nde&quot;, &quot;nds&quot;, &quot;nep&quot;,
 271     &quot;new&quot;, &quot;ndo&quot;, &quot;nia&quot;, &quot;niu&quot;, &quot;njo&quot;, &quot;nld&quot;, &quot;nmg&quot;, &quot;nno&quot;,
 272     &quot;nnh&quot;, &quot;nor&quot;, &quot;nog&quot;, &quot;non&quot;, &quot;nov&quot;, &quot;nqo&quot;, &quot;nbl&quot;, &quot;nso&quot;,
 273     &quot;nus&quot;, &quot;nav&quot;, &quot;nwc&quot;, &quot;nya&quot;, &quot;nym&quot;, &quot;nyn&quot;, &quot;nyo&quot;, &quot;nzi&quot;,
 274     &quot;oci&quot;, &quot;oji&quot;, &quot;orm&quot;, &quot;ori&quot;, &quot;oss&quot;, &quot;osa&quot;, &quot;ota&quot;,
 275     &quot;pan&quot;, &quot;pag&quot;, &quot;pal&quot;, &quot;pam&quot;, &quot;pap&quot;, &quot;pau&quot;, &quot;pcd&quot;, &quot;pdc&quot;,
 276     &quot;pdt&quot;, &quot;peo&quot;, &quot;pfl&quot;, &quot;phn&quot;, &quot;pli&quot;, &quot;pol&quot;, &quot;pms&quot;, &quot;pnt&quot;,
 277     &quot;pon&quot;, &quot;prg&quot;, &quot;pro&quot;, &quot;pus&quot;, &quot;por&quot;,
 278     &quot;que&quot;, &quot;quc&quot;, &quot;qug&quot;,
 279     &quot;raj&quot;, &quot;rap&quot;, &quot;rar&quot;, &quot;rgn&quot;, &quot;rif&quot;, &quot;roh&quot;, &quot;run&quot;, &quot;ron&quot;,
 280     &quot;rof&quot;, &quot;rom&quot;, &quot;rtm&quot;, &quot;rus&quot;, &quot;rue&quot;, &quot;rug&quot;, &quot;rup&quot;,
 281     &quot;kin&quot;, &quot;rwk&quot;,
 282     &quot;san&quot;, &quot;sad&quot;, &quot;sah&quot;, &quot;sam&quot;, &quot;saq&quot;, &quot;sas&quot;, &quot;sat&quot;, &quot;saz&quot;,
 283     &quot;sba&quot;, &quot;sbp&quot;, &quot;srd&quot;, &quot;scn&quot;, &quot;sco&quot;, &quot;snd&quot;, &quot;sdc&quot;, &quot;sdh&quot;,
 284     &quot;sme&quot;, &quot;see&quot;, &quot;seh&quot;, &quot;sei&quot;, &quot;sel&quot;, &quot;ses&quot;, &quot;sag&quot;, &quot;sga&quot;,
 285     &quot;sgs&quot;, &quot;shi&quot;, &quot;shn&quot;, &quot;shu&quot;, &quot;sin&quot;, &quot;sid&quot;, &quot;slk&quot;,
 286     &quot;slv&quot;, &quot;sli&quot;, &quot;sly&quot;, &quot;smo&quot;, &quot;sma&quot;, &quot;smj&quot;, &quot;smn&quot;, &quot;sms&quot;,
 287     &quot;sna&quot;, &quot;snk&quot;, &quot;som&quot;, &quot;sog&quot;, &quot;sqi&quot;, &quot;srp&quot;, &quot;srn&quot;, &quot;srr&quot;,
 288     &quot;ssw&quot;, &quot;ssy&quot;, &quot;sot&quot;, &quot;stq&quot;, &quot;sun&quot;, &quot;suk&quot;, &quot;sus&quot;, &quot;sux&quot;,
 289     &quot;swe&quot;, &quot;swa&quot;, &quot;swb&quot;, &quot;swc&quot;, &quot;syc&quot;, &quot;syr&quot;, &quot;szl&quot;,
 290     &quot;tam&quot;, &quot;tcy&quot;, &quot;tel&quot;, &quot;tem&quot;, &quot;teo&quot;, &quot;ter&quot;, &quot;tet&quot;, &quot;tgk&quot;,
 291     &quot;tha&quot;, &quot;tir&quot;, &quot;tig&quot;, &quot;tiv&quot;, &quot;tuk&quot;, &quot;tkl&quot;, &quot;tkr&quot;, &quot;tgl&quot;,
 292     &quot;tlh&quot;, &quot;tli&quot;, &quot;tly&quot;, &quot;tmh&quot;, &quot;tsn&quot;, &quot;ton&quot;, &quot;tog&quot;, &quot;tpi&quot;,
 293     &quot;tur&quot;, &quot;tru&quot;, &quot;trv&quot;, &quot;tso&quot;, &quot;tsd&quot;, &quot;tsi&quot;, &quot;tat&quot;, &quot;ttt&quot;,
 294     &quot;tum&quot;, &quot;tvl&quot;, &quot;twi&quot;, &quot;twq&quot;, &quot;tah&quot;, &quot;tyv&quot;, &quot;tzm&quot;,
 295     &quot;udm&quot;, &quot;uig&quot;, &quot;uga&quot;, &quot;ukr&quot;, &quot;umb&quot;, &quot;und&quot;, &quot;urd&quot;, &quot;uzb&quot;,
 296     &quot;vai&quot;, &quot;ven&quot;, &quot;vec&quot;, &quot;vep&quot;, &quot;vie&quot;, &quot;vls&quot;, &quot;vmf&quot;, &quot;vol&quot;,
 297     &quot;vot&quot;, &quot;vro&quot;, &quot;vun&quot;,
 298     &quot;wln&quot;, &quot;wae&quot;, &quot;wal&quot;, &quot;war&quot;, &quot;was&quot;, &quot;wbp&quot;, &quot;wol&quot;, &quot;wuu&quot;,
 299     &quot;xal&quot;, &quot;xho&quot;, &quot;xmf&quot;, &quot;xog&quot;,
 300     &quot;yao&quot;, &quot;yap&quot;, &quot;yav&quot;, &quot;ybb&quot;, &quot;yid&quot;, &quot;yor&quot;, &quot;yrl&quot;, &quot;yue&quot;,
 301     &quot;zha&quot;, &quot;zap&quot;, &quot;zbl&quot;, &quot;zea&quot;, &quot;zen&quot;, &quot;zgh&quot;, &quot;zho&quot;, &quot;zul&quot;,
 302     &quot;zun&quot;, &quot;zxx&quot;, &quot;zza&quot;,
 303 NULL,
 304 /*  &quot;in&quot;,  &quot;iw&quot;,  &quot;ji&quot;,  &quot;jw&quot;,  &quot;sh&quot;,                          */
 305     &quot;ind&quot;, &quot;heb&quot;, &quot;yid&quot;, &quot;jaw&quot;, &quot;srp&quot;,
 306 NULL
 307 };
 308 
 309 /**
 310  * Table of 2-letter country codes.
 311  *
 312  * This list must be in sorted order.  This list is returned directly
 313  * to the user by some API.
 314  *
 315  * This list must be kept in sync with COUNTRIES_3, with corresponding
 316  * entries matched.
 317  *
 318  * This table should be terminated with a NULL entry, followed by a
 319  * second list, and another NULL entry.  The first list is visible to
 320  * user code when this array is returned by API.  The second list
 321  * contains codes we support, but do not expose through user API.
 322  *
 323  * Notes:
 324  *
 325  * ZR(ZAR) is now CD(COD) and FX(FXX) is PS(PSE) as per
 326  * http://www.evertype.com/standards/iso3166/iso3166-1-en.html added
 327  * new codes keeping the old ones for compatibility updated to include
 328  * 1999/12/03 revisions *CWB*
 329  *
 330  * RO(ROM) is now RO(ROU) according to
 331  * http://www.iso.org/iso/en/prods-services/iso3166ma/03updates-on-iso-3166/nlv3e-rou.html
 332  */
 333 static const char * const COUNTRIES[] = {
 334     &quot;AD&quot;,  &quot;AE&quot;,  &quot;AF&quot;,  &quot;AG&quot;,  &quot;AI&quot;,  &quot;AL&quot;,  &quot;AM&quot;,
 335     &quot;AO&quot;,  &quot;AQ&quot;,  &quot;AR&quot;,  &quot;AS&quot;,  &quot;AT&quot;,  &quot;AU&quot;,  &quot;AW&quot;,  &quot;AX&quot;,  &quot;AZ&quot;,
 336     &quot;BA&quot;,  &quot;BB&quot;,  &quot;BD&quot;,  &quot;BE&quot;,  &quot;BF&quot;,  &quot;BG&quot;,  &quot;BH&quot;,  &quot;BI&quot;,
 337     &quot;BJ&quot;,  &quot;BL&quot;,  &quot;BM&quot;,  &quot;BN&quot;,  &quot;BO&quot;,  &quot;BQ&quot;,  &quot;BR&quot;,  &quot;BS&quot;,  &quot;BT&quot;,  &quot;BV&quot;,
 338     &quot;BW&quot;,  &quot;BY&quot;,  &quot;BZ&quot;,  &quot;CA&quot;,  &quot;CC&quot;,  &quot;CD&quot;,  &quot;CF&quot;,  &quot;CG&quot;,
 339     &quot;CH&quot;,  &quot;CI&quot;,  &quot;CK&quot;,  &quot;CL&quot;,  &quot;CM&quot;,  &quot;CN&quot;,  &quot;CO&quot;,  &quot;CR&quot;,
 340     &quot;CU&quot;,  &quot;CV&quot;,  &quot;CW&quot;,  &quot;CX&quot;,  &quot;CY&quot;,  &quot;CZ&quot;,  &quot;DE&quot;,  &quot;DJ&quot;,  &quot;DK&quot;,
 341     &quot;DM&quot;,  &quot;DO&quot;,  &quot;DZ&quot;,  &quot;EC&quot;,  &quot;EE&quot;,  &quot;EG&quot;,  &quot;EH&quot;,  &quot;ER&quot;,
 342     &quot;ES&quot;,  &quot;ET&quot;,  &quot;FI&quot;,  &quot;FJ&quot;,  &quot;FK&quot;,  &quot;FM&quot;,  &quot;FO&quot;,  &quot;FR&quot;,
 343     &quot;GA&quot;,  &quot;GB&quot;,  &quot;GD&quot;,  &quot;GE&quot;,  &quot;GF&quot;,  &quot;GG&quot;,  &quot;GH&quot;,  &quot;GI&quot;,  &quot;GL&quot;,
 344     &quot;GM&quot;,  &quot;GN&quot;,  &quot;GP&quot;,  &quot;GQ&quot;,  &quot;GR&quot;,  &quot;GS&quot;,  &quot;GT&quot;,  &quot;GU&quot;,
 345     &quot;GW&quot;,  &quot;GY&quot;,  &quot;HK&quot;,  &quot;HM&quot;,  &quot;HN&quot;,  &quot;HR&quot;,  &quot;HT&quot;,  &quot;HU&quot;,
 346     &quot;ID&quot;,  &quot;IE&quot;,  &quot;IL&quot;,  &quot;IM&quot;,  &quot;IN&quot;,  &quot;IO&quot;,  &quot;IQ&quot;,  &quot;IR&quot;,  &quot;IS&quot;,
 347     &quot;IT&quot;,  &quot;JE&quot;,  &quot;JM&quot;,  &quot;JO&quot;,  &quot;JP&quot;,  &quot;KE&quot;,  &quot;KG&quot;,  &quot;KH&quot;,  &quot;KI&quot;,
 348     &quot;KM&quot;,  &quot;KN&quot;,  &quot;KP&quot;,  &quot;KR&quot;,  &quot;KW&quot;,  &quot;KY&quot;,  &quot;KZ&quot;,  &quot;LA&quot;,
 349     &quot;LB&quot;,  &quot;LC&quot;,  &quot;LI&quot;,  &quot;LK&quot;,  &quot;LR&quot;,  &quot;LS&quot;,  &quot;LT&quot;,  &quot;LU&quot;,
 350     &quot;LV&quot;,  &quot;LY&quot;,  &quot;MA&quot;,  &quot;MC&quot;,  &quot;MD&quot;,  &quot;ME&quot;,  &quot;MF&quot;,  &quot;MG&quot;,  &quot;MH&quot;,  &quot;MK&quot;,
 351     &quot;ML&quot;,  &quot;MM&quot;,  &quot;MN&quot;,  &quot;MO&quot;,  &quot;MP&quot;,  &quot;MQ&quot;,  &quot;MR&quot;,  &quot;MS&quot;,
 352     &quot;MT&quot;,  &quot;MU&quot;,  &quot;MV&quot;,  &quot;MW&quot;,  &quot;MX&quot;,  &quot;MY&quot;,  &quot;MZ&quot;,  &quot;NA&quot;,
 353     &quot;NC&quot;,  &quot;NE&quot;,  &quot;NF&quot;,  &quot;NG&quot;,  &quot;NI&quot;,  &quot;NL&quot;,  &quot;NO&quot;,  &quot;NP&quot;,
 354     &quot;NR&quot;,  &quot;NU&quot;,  &quot;NZ&quot;,  &quot;OM&quot;,  &quot;PA&quot;,  &quot;PE&quot;,  &quot;PF&quot;,  &quot;PG&quot;,
 355     &quot;PH&quot;,  &quot;PK&quot;,  &quot;PL&quot;,  &quot;PM&quot;,  &quot;PN&quot;,  &quot;PR&quot;,  &quot;PS&quot;,  &quot;PT&quot;,
 356     &quot;PW&quot;,  &quot;PY&quot;,  &quot;QA&quot;,  &quot;RE&quot;,  &quot;RO&quot;,  &quot;RS&quot;,  &quot;RU&quot;,  &quot;RW&quot;,  &quot;SA&quot;,
 357     &quot;SB&quot;,  &quot;SC&quot;,  &quot;SD&quot;,  &quot;SE&quot;,  &quot;SG&quot;,  &quot;SH&quot;,  &quot;SI&quot;,  &quot;SJ&quot;,
 358     &quot;SK&quot;,  &quot;SL&quot;,  &quot;SM&quot;,  &quot;SN&quot;,  &quot;SO&quot;,  &quot;SR&quot;,  &quot;SS&quot;,  &quot;ST&quot;,  &quot;SV&quot;,
 359     &quot;SX&quot;,  &quot;SY&quot;,  &quot;SZ&quot;,  &quot;TC&quot;,  &quot;TD&quot;,  &quot;TF&quot;,  &quot;TG&quot;,  &quot;TH&quot;,  &quot;TJ&quot;,
 360     &quot;TK&quot;,  &quot;TL&quot;,  &quot;TM&quot;,  &quot;TN&quot;,  &quot;TO&quot;,  &quot;TR&quot;,  &quot;TT&quot;,  &quot;TV&quot;,
 361     &quot;TW&quot;,  &quot;TZ&quot;,  &quot;UA&quot;,  &quot;UG&quot;,  &quot;UM&quot;,  &quot;US&quot;,  &quot;UY&quot;,  &quot;UZ&quot;,
 362     &quot;VA&quot;,  &quot;VC&quot;,  &quot;VE&quot;,  &quot;VG&quot;,  &quot;VI&quot;,  &quot;VN&quot;,  &quot;VU&quot;,  &quot;WF&quot;,
 363     &quot;WS&quot;,  &quot;YE&quot;,  &quot;YT&quot;,  &quot;ZA&quot;,  &quot;ZM&quot;,  &quot;ZW&quot;,
 364 NULL,
 365     &quot;AN&quot;,  &quot;BU&quot;, &quot;CS&quot;, &quot;FX&quot;, &quot;RO&quot;, &quot;SU&quot;, &quot;TP&quot;, &quot;YD&quot;, &quot;YU&quot;, &quot;ZR&quot;,   /* obsolete country codes */
 366 NULL
 367 };
 368 
 369 static const char* const DEPRECATED_COUNTRIES[] = {
 370     &quot;AN&quot;, &quot;BU&quot;, &quot;CS&quot;, &quot;DD&quot;, &quot;DY&quot;, &quot;FX&quot;, &quot;HV&quot;, &quot;NH&quot;, &quot;RH&quot;, &quot;SU&quot;, &quot;TP&quot;, &quot;UK&quot;, &quot;VD&quot;, &quot;YD&quot;, &quot;YU&quot;, &quot;ZR&quot;, NULL, NULL /* deprecated country list */
 371 };
 372 static const char* const REPLACEMENT_COUNTRIES[] = {
 373 /*  &quot;AN&quot;, &quot;BU&quot;, &quot;CS&quot;, &quot;DD&quot;, &quot;DY&quot;, &quot;FX&quot;, &quot;HV&quot;, &quot;NH&quot;, &quot;RH&quot;, &quot;SU&quot;, &quot;TP&quot;, &quot;UK&quot;, &quot;VD&quot;, &quot;YD&quot;, &quot;YU&quot;, &quot;ZR&quot; */
 374     &quot;CW&quot;, &quot;MM&quot;, &quot;RS&quot;, &quot;DE&quot;, &quot;BJ&quot;, &quot;FR&quot;, &quot;BF&quot;, &quot;VU&quot;, &quot;ZW&quot;, &quot;RU&quot;, &quot;TL&quot;, &quot;GB&quot;, &quot;VN&quot;, &quot;YE&quot;, &quot;RS&quot;, &quot;CD&quot;, NULL, NULL  /* replacement country codes */
 375 };
 376 
 377 /**
 378  * Table of 3-letter country codes.
 379  *
 380  * This is a lookup table used to convert 3-letter country codes to
 381  * their 2-letter equivalent.  It must be kept in sync with COUNTRIES.
 382  * For all valid i, COUNTRIES[i] must refer to the same country as
 383  * COUNTRIES_3[i].  The commented-out lines are copied from COUNTRIES
 384  * to make eyeballing this baby easier.
 385  *
 386  * This table should be terminated with a NULL entry, followed by a
 387  * second list, and another NULL entry.  The two lists correspond to
 388  * the two lists in COUNTRIES.
 389  */
 390 static const char * const COUNTRIES_3[] = {
 391 /*  &quot;AD&quot;,  &quot;AE&quot;,  &quot;AF&quot;,  &quot;AG&quot;,  &quot;AI&quot;,  &quot;AL&quot;,  &quot;AM&quot;,      */
 392     &quot;AND&quot;, &quot;ARE&quot;, &quot;AFG&quot;, &quot;ATG&quot;, &quot;AIA&quot;, &quot;ALB&quot;, &quot;ARM&quot;,
 393 /*  &quot;AO&quot;,  &quot;AQ&quot;,  &quot;AR&quot;,  &quot;AS&quot;,  &quot;AT&quot;,  &quot;AU&quot;,  &quot;AW&quot;,  &quot;AX&quot;,  &quot;AZ&quot;,     */
 394     &quot;AGO&quot;, &quot;ATA&quot;, &quot;ARG&quot;, &quot;ASM&quot;, &quot;AUT&quot;, &quot;AUS&quot;, &quot;ABW&quot;, &quot;ALA&quot;, &quot;AZE&quot;,
 395 /*  &quot;BA&quot;,  &quot;BB&quot;,  &quot;BD&quot;,  &quot;BE&quot;,  &quot;BF&quot;,  &quot;BG&quot;,  &quot;BH&quot;,  &quot;BI&quot;,     */
 396     &quot;BIH&quot;, &quot;BRB&quot;, &quot;BGD&quot;, &quot;BEL&quot;, &quot;BFA&quot;, &quot;BGR&quot;, &quot;BHR&quot;, &quot;BDI&quot;,
 397 /*  &quot;BJ&quot;,  &quot;BL&quot;,  &quot;BM&quot;,  &quot;BN&quot;,  &quot;BO&quot;,  &quot;BQ&quot;,  &quot;BR&quot;,  &quot;BS&quot;,  &quot;BT&quot;,  &quot;BV&quot;,     */
 398     &quot;BEN&quot;, &quot;BLM&quot;, &quot;BMU&quot;, &quot;BRN&quot;, &quot;BOL&quot;, &quot;BES&quot;, &quot;BRA&quot;, &quot;BHS&quot;, &quot;BTN&quot;, &quot;BVT&quot;,
 399 /*  &quot;BW&quot;,  &quot;BY&quot;,  &quot;BZ&quot;,  &quot;CA&quot;,  &quot;CC&quot;,  &quot;CD&quot;,  &quot;CF&quot;,  &quot;CG&quot;,     */
 400     &quot;BWA&quot;, &quot;BLR&quot;, &quot;BLZ&quot;, &quot;CAN&quot;, &quot;CCK&quot;, &quot;COD&quot;, &quot;CAF&quot;, &quot;COG&quot;,
 401 /*  &quot;CH&quot;,  &quot;CI&quot;,  &quot;CK&quot;,  &quot;CL&quot;,  &quot;CM&quot;,  &quot;CN&quot;,  &quot;CO&quot;,  &quot;CR&quot;,     */
 402     &quot;CHE&quot;, &quot;CIV&quot;, &quot;COK&quot;, &quot;CHL&quot;, &quot;CMR&quot;, &quot;CHN&quot;, &quot;COL&quot;, &quot;CRI&quot;,
 403 /*  &quot;CU&quot;,  &quot;CV&quot;,  &quot;CW&quot;,  &quot;CX&quot;,  &quot;CY&quot;,  &quot;CZ&quot;,  &quot;DE&quot;,  &quot;DJ&quot;,  &quot;DK&quot;,     */
 404     &quot;CUB&quot;, &quot;CPV&quot;, &quot;CUW&quot;, &quot;CXR&quot;, &quot;CYP&quot;, &quot;CZE&quot;, &quot;DEU&quot;, &quot;DJI&quot;, &quot;DNK&quot;,
 405 /*  &quot;DM&quot;,  &quot;DO&quot;,  &quot;DZ&quot;,  &quot;EC&quot;,  &quot;EE&quot;,  &quot;EG&quot;,  &quot;EH&quot;,  &quot;ER&quot;,     */
 406     &quot;DMA&quot;, &quot;DOM&quot;, &quot;DZA&quot;, &quot;ECU&quot;, &quot;EST&quot;, &quot;EGY&quot;, &quot;ESH&quot;, &quot;ERI&quot;,
 407 /*  &quot;ES&quot;,  &quot;ET&quot;,  &quot;FI&quot;,  &quot;FJ&quot;,  &quot;FK&quot;,  &quot;FM&quot;,  &quot;FO&quot;,  &quot;FR&quot;,     */
 408     &quot;ESP&quot;, &quot;ETH&quot;, &quot;FIN&quot;, &quot;FJI&quot;, &quot;FLK&quot;, &quot;FSM&quot;, &quot;FRO&quot;, &quot;FRA&quot;,
 409 /*  &quot;GA&quot;,  &quot;GB&quot;,  &quot;GD&quot;,  &quot;GE&quot;,  &quot;GF&quot;,  &quot;GG&quot;,  &quot;GH&quot;,  &quot;GI&quot;,  &quot;GL&quot;,     */
 410     &quot;GAB&quot;, &quot;GBR&quot;, &quot;GRD&quot;, &quot;GEO&quot;, &quot;GUF&quot;, &quot;GGY&quot;, &quot;GHA&quot;, &quot;GIB&quot;, &quot;GRL&quot;,
 411 /*  &quot;GM&quot;,  &quot;GN&quot;,  &quot;GP&quot;,  &quot;GQ&quot;,  &quot;GR&quot;,  &quot;GS&quot;,  &quot;GT&quot;,  &quot;GU&quot;,     */
 412     &quot;GMB&quot;, &quot;GIN&quot;, &quot;GLP&quot;, &quot;GNQ&quot;, &quot;GRC&quot;, &quot;SGS&quot;, &quot;GTM&quot;, &quot;GUM&quot;,
 413 /*  &quot;GW&quot;,  &quot;GY&quot;,  &quot;HK&quot;,  &quot;HM&quot;,  &quot;HN&quot;,  &quot;HR&quot;,  &quot;HT&quot;,  &quot;HU&quot;,     */
 414     &quot;GNB&quot;, &quot;GUY&quot;, &quot;HKG&quot;, &quot;HMD&quot;, &quot;HND&quot;, &quot;HRV&quot;, &quot;HTI&quot;, &quot;HUN&quot;,
 415 /*  &quot;ID&quot;,  &quot;IE&quot;,  &quot;IL&quot;,  &quot;IM&quot;,  &quot;IN&quot;,  &quot;IO&quot;,  &quot;IQ&quot;,  &quot;IR&quot;,  &quot;IS&quot; */
 416     &quot;IDN&quot;, &quot;IRL&quot;, &quot;ISR&quot;, &quot;IMN&quot;, &quot;IND&quot;, &quot;IOT&quot;, &quot;IRQ&quot;, &quot;IRN&quot;, &quot;ISL&quot;,
 417 /*  &quot;IT&quot;,  &quot;JE&quot;,  &quot;JM&quot;,  &quot;JO&quot;,  &quot;JP&quot;,  &quot;KE&quot;,  &quot;KG&quot;,  &quot;KH&quot;,  &quot;KI&quot;,     */
 418     &quot;ITA&quot;, &quot;JEY&quot;, &quot;JAM&quot;, &quot;JOR&quot;, &quot;JPN&quot;, &quot;KEN&quot;, &quot;KGZ&quot;, &quot;KHM&quot;, &quot;KIR&quot;,
 419 /*  &quot;KM&quot;,  &quot;KN&quot;,  &quot;KP&quot;,  &quot;KR&quot;,  &quot;KW&quot;,  &quot;KY&quot;,  &quot;KZ&quot;,  &quot;LA&quot;,     */
 420     &quot;COM&quot;, &quot;KNA&quot;, &quot;PRK&quot;, &quot;KOR&quot;, &quot;KWT&quot;, &quot;CYM&quot;, &quot;KAZ&quot;, &quot;LAO&quot;,
 421 /*  &quot;LB&quot;,  &quot;LC&quot;,  &quot;LI&quot;,  &quot;LK&quot;,  &quot;LR&quot;,  &quot;LS&quot;,  &quot;LT&quot;,  &quot;LU&quot;,     */
 422     &quot;LBN&quot;, &quot;LCA&quot;, &quot;LIE&quot;, &quot;LKA&quot;, &quot;LBR&quot;, &quot;LSO&quot;, &quot;LTU&quot;, &quot;LUX&quot;,
 423 /*  &quot;LV&quot;,  &quot;LY&quot;,  &quot;MA&quot;,  &quot;MC&quot;,  &quot;MD&quot;,  &quot;ME&quot;,  &quot;MF&quot;,  &quot;MG&quot;,  &quot;MH&quot;,  &quot;MK&quot;,     */
 424     &quot;LVA&quot;, &quot;LBY&quot;, &quot;MAR&quot;, &quot;MCO&quot;, &quot;MDA&quot;, &quot;MNE&quot;, &quot;MAF&quot;, &quot;MDG&quot;, &quot;MHL&quot;, &quot;MKD&quot;,
 425 /*  &quot;ML&quot;,  &quot;MM&quot;,  &quot;MN&quot;,  &quot;MO&quot;,  &quot;MP&quot;,  &quot;MQ&quot;,  &quot;MR&quot;,  &quot;MS&quot;,     */
 426     &quot;MLI&quot;, &quot;MMR&quot;, &quot;MNG&quot;, &quot;MAC&quot;, &quot;MNP&quot;, &quot;MTQ&quot;, &quot;MRT&quot;, &quot;MSR&quot;,
 427 /*  &quot;MT&quot;,  &quot;MU&quot;,  &quot;MV&quot;,  &quot;MW&quot;,  &quot;MX&quot;,  &quot;MY&quot;,  &quot;MZ&quot;,  &quot;NA&quot;,     */
 428     &quot;MLT&quot;, &quot;MUS&quot;, &quot;MDV&quot;, &quot;MWI&quot;, &quot;MEX&quot;, &quot;MYS&quot;, &quot;MOZ&quot;, &quot;NAM&quot;,
 429 /*  &quot;NC&quot;,  &quot;NE&quot;,  &quot;NF&quot;,  &quot;NG&quot;,  &quot;NI&quot;,  &quot;NL&quot;,  &quot;NO&quot;,  &quot;NP&quot;,     */
 430     &quot;NCL&quot;, &quot;NER&quot;, &quot;NFK&quot;, &quot;NGA&quot;, &quot;NIC&quot;, &quot;NLD&quot;, &quot;NOR&quot;, &quot;NPL&quot;,
 431 /*  &quot;NR&quot;,  &quot;NU&quot;,  &quot;NZ&quot;,  &quot;OM&quot;,  &quot;PA&quot;,  &quot;PE&quot;,  &quot;PF&quot;,  &quot;PG&quot;,     */
 432     &quot;NRU&quot;, &quot;NIU&quot;, &quot;NZL&quot;, &quot;OMN&quot;, &quot;PAN&quot;, &quot;PER&quot;, &quot;PYF&quot;, &quot;PNG&quot;,
 433 /*  &quot;PH&quot;,  &quot;PK&quot;,  &quot;PL&quot;,  &quot;PM&quot;,  &quot;PN&quot;,  &quot;PR&quot;,  &quot;PS&quot;,  &quot;PT&quot;,     */
 434     &quot;PHL&quot;, &quot;PAK&quot;, &quot;POL&quot;, &quot;SPM&quot;, &quot;PCN&quot;, &quot;PRI&quot;, &quot;PSE&quot;, &quot;PRT&quot;,
 435 /*  &quot;PW&quot;,  &quot;PY&quot;,  &quot;QA&quot;,  &quot;RE&quot;,  &quot;RO&quot;,  &quot;RS&quot;,  &quot;RU&quot;,  &quot;RW&quot;,  &quot;SA&quot;,     */
 436     &quot;PLW&quot;, &quot;PRY&quot;, &quot;QAT&quot;, &quot;REU&quot;, &quot;ROU&quot;, &quot;SRB&quot;, &quot;RUS&quot;, &quot;RWA&quot;, &quot;SAU&quot;,
 437 /*  &quot;SB&quot;,  &quot;SC&quot;,  &quot;SD&quot;,  &quot;SE&quot;,  &quot;SG&quot;,  &quot;SH&quot;,  &quot;SI&quot;,  &quot;SJ&quot;,     */
 438     &quot;SLB&quot;, &quot;SYC&quot;, &quot;SDN&quot;, &quot;SWE&quot;, &quot;SGP&quot;, &quot;SHN&quot;, &quot;SVN&quot;, &quot;SJM&quot;,
 439 /*  &quot;SK&quot;,  &quot;SL&quot;,  &quot;SM&quot;,  &quot;SN&quot;,  &quot;SO&quot;,  &quot;SR&quot;,  &quot;SS&quot;,  &quot;ST&quot;,  &quot;SV&quot;,     */
 440     &quot;SVK&quot;, &quot;SLE&quot;, &quot;SMR&quot;, &quot;SEN&quot;, &quot;SOM&quot;, &quot;SUR&quot;, &quot;SSD&quot;, &quot;STP&quot;, &quot;SLV&quot;,
 441 /*  &quot;SX&quot;,  &quot;SY&quot;,  &quot;SZ&quot;,  &quot;TC&quot;,  &quot;TD&quot;,  &quot;TF&quot;,  &quot;TG&quot;,  &quot;TH&quot;,  &quot;TJ&quot;,     */
 442     &quot;SXM&quot;, &quot;SYR&quot;, &quot;SWZ&quot;, &quot;TCA&quot;, &quot;TCD&quot;, &quot;ATF&quot;, &quot;TGO&quot;, &quot;THA&quot;, &quot;TJK&quot;,
 443 /*  &quot;TK&quot;,  &quot;TL&quot;,  &quot;TM&quot;,  &quot;TN&quot;,  &quot;TO&quot;,  &quot;TR&quot;,  &quot;TT&quot;,  &quot;TV&quot;,     */
 444     &quot;TKL&quot;, &quot;TLS&quot;, &quot;TKM&quot;, &quot;TUN&quot;, &quot;TON&quot;, &quot;TUR&quot;, &quot;TTO&quot;, &quot;TUV&quot;,
 445 /*  &quot;TW&quot;,  &quot;TZ&quot;,  &quot;UA&quot;,  &quot;UG&quot;,  &quot;UM&quot;,  &quot;US&quot;,  &quot;UY&quot;,  &quot;UZ&quot;,     */
 446     &quot;TWN&quot;, &quot;TZA&quot;, &quot;UKR&quot;, &quot;UGA&quot;, &quot;UMI&quot;, &quot;USA&quot;, &quot;URY&quot;, &quot;UZB&quot;,
 447 /*  &quot;VA&quot;,  &quot;VC&quot;,  &quot;VE&quot;,  &quot;VG&quot;,  &quot;VI&quot;,  &quot;VN&quot;,  &quot;VU&quot;,  &quot;WF&quot;,     */
 448     &quot;VAT&quot;, &quot;VCT&quot;, &quot;VEN&quot;, &quot;VGB&quot;, &quot;VIR&quot;, &quot;VNM&quot;, &quot;VUT&quot;, &quot;WLF&quot;,
 449 /*  &quot;WS&quot;,  &quot;YE&quot;,  &quot;YT&quot;,  &quot;ZA&quot;,  &quot;ZM&quot;,  &quot;ZW&quot;,          */
 450     &quot;WSM&quot;, &quot;YEM&quot;, &quot;MYT&quot;, &quot;ZAF&quot;, &quot;ZMB&quot;, &quot;ZWE&quot;,
 451 NULL,
 452 /*  &quot;AN&quot;,  &quot;BU&quot;,  &quot;CS&quot;,  &quot;FX&quot;,  &quot;RO&quot;, &quot;SU&quot;,  &quot;TP&quot;,  &quot;YD&quot;,  &quot;YU&quot;,  &quot;ZR&quot; */
 453     &quot;ANT&quot;, &quot;BUR&quot;, &quot;SCG&quot;, &quot;FXX&quot;, &quot;ROM&quot;, &quot;SUN&quot;, &quot;TMP&quot;, &quot;YMD&quot;, &quot;YUG&quot;, &quot;ZAR&quot;,
 454 NULL
 455 };
 456 
 457 typedef struct CanonicalizationMap {
 458     const char *id;          /* input ID */
 459     const char *canonicalID; /* canonicalized output ID */
<a name="1" id="anc1"></a><span class="line-removed"> 460     const char *keyword;     /* keyword, or NULL if none */</span>
<span class="line-removed"> 461     const char *value;       /* keyword value, or NULL if kw==NULL */</span>
 462 } CanonicalizationMap;
 463 
 464 /**
 465  * A map to canonicalize locale IDs.  This handles a variety of
 466  * different semantic kinds of transformations.
 467  */
 468 static const CanonicalizationMap CANONICALIZE_MAP[] = {
<a name="2" id="anc2"></a><span class="line-modified"> 469     { &quot;&quot;,               &quot;en_US_POSIX&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-modified"> 470     { &quot;c&quot;,              &quot;en_US_POSIX&quot;, NULL, NULL }, /* POSIX name */</span>
<span class="line-modified"> 471     { &quot;posix&quot;,          &quot;en_US_POSIX&quot;, NULL, NULL }, /* POSIX name (alias of C) */</span>
<span class="line-modified"> 472     { &quot;art_LOJBAN&quot;,     &quot;jbo&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-modified"> 473     { &quot;az_AZ_CYRL&quot;,     &quot;az_Cyrl_AZ&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-modified"> 474     { &quot;az_AZ_LATN&quot;,     &quot;az_Latn_AZ&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-modified"> 475     { &quot;ca_ES_PREEURO&quot;,  &quot;ca_ES&quot;, &quot;currency&quot;, &quot;ESP&quot; },</span>
<span class="line-modified"> 476     { &quot;de__PHONEBOOK&quot;,  &quot;de&quot;, &quot;collation&quot;, &quot;phonebook&quot; }, /* Old ICU name */</span>
<span class="line-modified"> 477     { &quot;de_AT_PREEURO&quot;,  &quot;de_AT&quot;, &quot;currency&quot;, &quot;ATS&quot; },</span>
<span class="line-modified"> 478     { &quot;de_DE_PREEURO&quot;,  &quot;de_DE&quot;, &quot;currency&quot;, &quot;DEM&quot; },</span>
<span class="line-removed"> 479     { &quot;de_LU_PREEURO&quot;,  &quot;de_LU&quot;, &quot;currency&quot;, &quot;LUF&quot; },</span>
<span class="line-removed"> 480     { &quot;el_GR_PREEURO&quot;,  &quot;el_GR&quot;, &quot;currency&quot;, &quot;GRD&quot; },</span>
<span class="line-removed"> 481     { &quot;en_BE_PREEURO&quot;,  &quot;en_BE&quot;, &quot;currency&quot;, &quot;BEF&quot; },</span>
<span class="line-removed"> 482     { &quot;en_IE_PREEURO&quot;,  &quot;en_IE&quot;, &quot;currency&quot;, &quot;IEP&quot; },</span>
<span class="line-removed"> 483     { &quot;es__TRADITIONAL&quot;, &quot;es&quot;, &quot;collation&quot;, &quot;traditional&quot; }, /* Old ICU name */</span>
<span class="line-removed"> 484     { &quot;es_ES_PREEURO&quot;,  &quot;es_ES&quot;, &quot;currency&quot;, &quot;ESP&quot; },</span>
<span class="line-removed"> 485     { &quot;eu_ES_PREEURO&quot;,  &quot;eu_ES&quot;, &quot;currency&quot;, &quot;ESP&quot; },</span>
<span class="line-removed"> 486     { &quot;fi_FI_PREEURO&quot;,  &quot;fi_FI&quot;, &quot;currency&quot;, &quot;FIM&quot; },</span>
<span class="line-removed"> 487     { &quot;fr_BE_PREEURO&quot;,  &quot;fr_BE&quot;, &quot;currency&quot;, &quot;BEF&quot; },</span>
<span class="line-removed"> 488     { &quot;fr_FR_PREEURO&quot;,  &quot;fr_FR&quot;, &quot;currency&quot;, &quot;FRF&quot; },</span>
<span class="line-removed"> 489     { &quot;fr_LU_PREEURO&quot;,  &quot;fr_LU&quot;, &quot;currency&quot;, &quot;LUF&quot; },</span>
<span class="line-removed"> 490     { &quot;ga_IE_PREEURO&quot;,  &quot;ga_IE&quot;, &quot;currency&quot;, &quot;IEP&quot; },</span>
<span class="line-removed"> 491     { &quot;gl_ES_PREEURO&quot;,  &quot;gl_ES&quot;, &quot;currency&quot;, &quot;ESP&quot; },</span>
<span class="line-removed"> 492     { &quot;hi__DIRECT&quot;,     &quot;hi&quot;, &quot;collation&quot;, &quot;direct&quot; }, /* Old ICU name */</span>
<span class="line-removed"> 493     { &quot;it_IT_PREEURO&quot;,  &quot;it_IT&quot;, &quot;currency&quot;, &quot;ITL&quot; },</span>
<span class="line-removed"> 494     { &quot;ja_JP_TRADITIONAL&quot;, &quot;ja_JP&quot;, &quot;calendar&quot;, &quot;japanese&quot; }, /* Old ICU name */</span>
<span class="line-removed"> 495     { &quot;nb_NO_NY&quot;,       &quot;nn_NO&quot;, NULL, NULL },  /* &quot;markus said this was ok&quot; :-) */</span>
<span class="line-removed"> 496     { &quot;nl_BE_PREEURO&quot;,  &quot;nl_BE&quot;, &quot;currency&quot;, &quot;BEF&quot; },</span>
<span class="line-removed"> 497     { &quot;nl_NL_PREEURO&quot;,  &quot;nl_NL&quot;, &quot;currency&quot;, &quot;NLG&quot; },</span>
<span class="line-removed"> 498     { &quot;pt_PT_PREEURO&quot;,  &quot;pt_PT&quot;, &quot;currency&quot;, &quot;PTE&quot; },</span>
<span class="line-removed"> 499     { &quot;sr_SP_CYRL&quot;,     &quot;sr_Cyrl_RS&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 500     { &quot;sr_SP_LATN&quot;,     &quot;sr_Latn_RS&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 501     { &quot;sr_YU_CYRILLIC&quot;, &quot;sr_Cyrl_RS&quot;, NULL, NULL }, /* Linux name */</span>
<span class="line-removed"> 502     { &quot;th_TH_TRADITIONAL&quot;, &quot;th_TH&quot;, &quot;calendar&quot;, &quot;buddhist&quot; }, /* Old ICU name */</span>
<span class="line-removed"> 503     { &quot;uz_UZ_CYRILLIC&quot;, &quot;uz_Cyrl_UZ&quot;, NULL, NULL }, /* Linux name */</span>
<span class="line-removed"> 504     { &quot;uz_UZ_CYRL&quot;,     &quot;uz_Cyrl_UZ&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 505     { &quot;uz_UZ_LATN&quot;,     &quot;uz_Latn_UZ&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 506     { &quot;zh_CHS&quot;,         &quot;zh_Hans&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 507     { &quot;zh_CHT&quot;,         &quot;zh_Hant&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 508     { &quot;zh_GAN&quot;,         &quot;gan&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 509     { &quot;zh_GUOYU&quot;,       &quot;zh&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 510     { &quot;zh_HAKKA&quot;,       &quot;hak&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 511     { &quot;zh_MIN_NAN&quot;,     &quot;nan&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 512     { &quot;zh_WUU&quot;,         &quot;wuu&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 513     { &quot;zh_XIANG&quot;,       &quot;hsn&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 514     { &quot;zh_YUE&quot;,         &quot;yue&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 515 };</span>
<span class="line-removed"> 516 </span>
<span class="line-removed"> 517 typedef struct VariantMap {</span>
<span class="line-removed"> 518     const char *variant;          /* input ID */</span>
<span class="line-removed"> 519     const char *keyword;     /* keyword, or NULL if none */</span>
<span class="line-removed"> 520     const char *value;       /* keyword value, or NULL if kw==NULL */</span>
<span class="line-removed"> 521 } VariantMap;</span>
<span class="line-removed"> 522 </span>
<span class="line-removed"> 523 static const VariantMap VARIANT_MAP[] = {</span>
<span class="line-removed"> 524     { &quot;EURO&quot;,   &quot;currency&quot;, &quot;EUR&quot; },</span>
<span class="line-removed"> 525     { &quot;PINYIN&quot;, &quot;collation&quot;, &quot;pinyin&quot; }, /* Solaris variant */</span>
<span class="line-removed"> 526     { &quot;STROKE&quot;, &quot;collation&quot;, &quot;stroke&quot; }  /* Solaris variant */</span>
 527 };
 528 
 529 /* ### BCP47 Conversion *******************************************/
 530 /* Test if the locale id has BCP47 u extension and does not have &#39;@&#39; */
 531 #define _hasBCP47Extension(id) (id &amp;&amp; uprv_strstr(id, &quot;@&quot;) == NULL &amp;&amp; getShortestSubtagLength(localeID) == 1)
 532 /* Converts the BCP47 id to Unicode id. Does nothing to id if conversion fails */
 533 #define _ConvertBCP47(finalID, id, buffer, length,err) \
 534         if (uloc_forLanguageTag(id, buffer, length, NULL, err) &lt;= 0 ||  \
 535                 U_FAILURE(*err) || *err == U_STRING_NOT_TERMINATED_WARNING) { \
 536             finalID=id; \
 537             if (*err == U_STRING_NOT_TERMINATED_WARNING) { *err = U_BUFFER_OVERFLOW_ERROR; } \
 538         } else { \
 539             finalID=buffer; \
 540         }
 541 /* Gets the size of the shortest subtag in the given localeID. */
 542 static int32_t getShortestSubtagLength(const char *localeID) {
 543     int32_t localeIDLength = static_cast&lt;int32_t&gt;(uprv_strlen(localeID));
 544     int32_t length = localeIDLength;
 545     int32_t tmpLength = 0;
 546     int32_t i;
 547     UBool reset = TRUE;
 548 
 549     for (i = 0; i &lt; localeIDLength; i++) {
 550         if (localeID[i] != &#39;_&#39; &amp;&amp; localeID[i] != &#39;-&#39;) {
 551             if (reset) {
 552                 tmpLength = 0;
 553                 reset = FALSE;
 554             }
 555             tmpLength++;
 556         } else {
 557             if (tmpLength != 0 &amp;&amp; tmpLength &lt; length) {
 558                 length = tmpLength;
 559             }
 560             reset = TRUE;
 561         }
 562     }
 563 
 564     return length;
 565 }
 566 
 567 /* ### Keywords **************************************************/
 568 #define UPRV_ISDIGIT(c) (((c) &gt;= &#39;0&#39;) &amp;&amp; ((c) &lt;= &#39;9&#39;))
 569 #define UPRV_ISALPHANUM(c) (uprv_isASCIILetter(c) || UPRV_ISDIGIT(c) )
 570 /* Punctuation/symbols allowed in legacy key values */
 571 #define UPRV_OK_VALUE_PUNCTUATION(c) ((c) == &#39;_&#39; || (c) == &#39;-&#39; || (c) == &#39;+&#39; || (c) == &#39;/&#39;)
 572 
 573 #define ULOC_KEYWORD_BUFFER_LEN 25
 574 #define ULOC_MAX_NO_KEYWORDS 25
 575 
 576 U_CAPI const char * U_EXPORT2
 577 locale_getKeywordsStart(const char *localeID) {
 578     const char *result = NULL;
 579     if((result = uprv_strchr(localeID, &#39;@&#39;)) != NULL) {
 580         return result;
 581     }
 582 #if (U_CHARSET_FAMILY == U_EBCDIC_FAMILY)
 583     else {
 584         /* We do this because the @ sign is variant, and the @ sign used on one
 585         EBCDIC machine won&#39;t be compiled the same way on other EBCDIC based
 586         machines. */
 587         static const uint8_t ebcdicSigns[] = { 0x7C, 0x44, 0x66, 0x80, 0xAC, 0xAE, 0xAF, 0xB5, 0xEC, 0xEF, 0x00 };
 588         const uint8_t *charToFind = ebcdicSigns;
 589         while(*charToFind) {
 590             if((result = uprv_strchr(localeID, *charToFind)) != NULL) {
 591                 return result;
 592             }
 593             charToFind++;
 594         }
 595     }
 596 #endif
 597     return NULL;
 598 }
 599 
 600 /**
 601  * @param buf buffer of size [ULOC_KEYWORD_BUFFER_LEN]
 602  * @param keywordName incoming name to be canonicalized
 603  * @param status return status (keyword too long)
 604  * @return length of the keyword name
 605  */
 606 static int32_t locale_canonKeywordName(char *buf, const char *keywordName, UErrorCode *status)
 607 {
 608   int32_t keywordNameLen = 0;
 609 
 610   for (; *keywordName != 0; keywordName++) {
 611     if (!UPRV_ISALPHANUM(*keywordName)) {
 612       *status = U_ILLEGAL_ARGUMENT_ERROR; /* malformed keyword name */
 613       return 0;
 614     }
 615     if (keywordNameLen &lt; ULOC_KEYWORD_BUFFER_LEN - 1) {
 616       buf[keywordNameLen++] = uprv_tolower(*keywordName);
 617     } else {
 618       /* keyword name too long for internal buffer */
 619       *status = U_INTERNAL_PROGRAM_ERROR;
 620       return 0;
 621     }
 622   }
 623   if (keywordNameLen == 0) {
 624     *status = U_ILLEGAL_ARGUMENT_ERROR; /* empty keyword name */
 625     return 0;
 626   }
 627   buf[keywordNameLen] = 0; /* terminate */
 628 
 629   return keywordNameLen;
 630 }
 631 
 632 typedef struct {
 633     char keyword[ULOC_KEYWORD_BUFFER_LEN];
 634     int32_t keywordLen;
 635     const char *valueStart;
 636     int32_t valueLen;
 637 } KeywordStruct;
 638 
 639 static int32_t U_CALLCONV
 640 compareKeywordStructs(const void * /*context*/, const void *left, const void *right) {
 641     const char* leftString = ((const KeywordStruct *)left)-&gt;keyword;
 642     const char* rightString = ((const KeywordStruct *)right)-&gt;keyword;
 643     return uprv_strcmp(leftString, rightString);
 644 }
 645 
<a name="3" id="anc3"></a><span class="line-removed"> 646 /**</span>
<span class="line-removed"> 647  * Both addKeyword and addValue must already be in canonical form.</span>
<span class="line-removed"> 648  * Either both addKeyword and addValue are NULL, or neither is NULL.</span>
<span class="line-removed"> 649  * If they are not NULL they must be zero terminated.</span>
<span class="line-removed"> 650  * If addKeyword is not NULL is must have length small enough to fit in KeywordStruct.keyword.</span>
<span class="line-removed"> 651  */</span>
 652 static int32_t
 653 _getKeywords(const char *localeID,
 654              char prev,
 655              char *keywords, int32_t keywordCapacity,
 656              char *values, int32_t valuesCapacity, int32_t *valLen,
 657              UBool valuesToo,
<a name="4" id="anc4"></a><span class="line-removed"> 658              const char* addKeyword,</span>
<span class="line-removed"> 659              const char* addValue,</span>
 660              UErrorCode *status)
 661 {
 662     KeywordStruct keywordList[ULOC_MAX_NO_KEYWORDS];
 663 
 664     int32_t maxKeywords = ULOC_MAX_NO_KEYWORDS;
 665     int32_t numKeywords = 0;
 666     const char* pos = localeID;
 667     const char* equalSign = NULL;
 668     const char* semicolon = NULL;
 669     int32_t i = 0, j, n;
 670     int32_t keywordsLen = 0;
 671     int32_t valuesLen = 0;
 672 
 673     if(prev == &#39;@&#39;) { /* start of keyword definition */
 674         /* we will grab pairs, trim spaces, lowercase keywords, sort and return */
 675         do {
 676             UBool duplicate = FALSE;
 677             /* skip leading spaces */
 678             while(*pos == &#39; &#39;) {
 679                 pos++;
 680             }
 681             if (!*pos) { /* handle trailing &quot;; &quot; */
 682                 break;
 683             }
 684             if(numKeywords == maxKeywords) {
 685                 *status = U_INTERNAL_PROGRAM_ERROR;
 686                 return 0;
 687             }
 688             equalSign = uprv_strchr(pos, &#39;=&#39;);
 689             semicolon = uprv_strchr(pos, &#39;;&#39;);
 690             /* lack of &#39;=&#39; [foo@currency] is illegal */
 691             /* &#39;;&#39; before &#39;=&#39; [foo@currency;collation=pinyin] is illegal */
 692             if(!equalSign || (semicolon &amp;&amp; semicolon&lt;equalSign)) {
 693                 *status = U_INVALID_FORMAT_ERROR;
 694                 return 0;
 695             }
 696             /* need to normalize both keyword and keyword name */
 697             if(equalSign - pos &gt;= ULOC_KEYWORD_BUFFER_LEN) {
 698                 /* keyword name too long for internal buffer */
 699                 *status = U_INTERNAL_PROGRAM_ERROR;
 700                 return 0;
 701             }
 702             for(i = 0, n = 0; i &lt; equalSign - pos; ++i) {
 703                 if (pos[i] != &#39; &#39;) {
 704                     keywordList[numKeywords].keyword[n++] = uprv_tolower(pos[i]);
 705                 }
 706             }
 707 
 708             /* zero-length keyword is an error. */
 709             if (n == 0) {
 710                 *status = U_INVALID_FORMAT_ERROR;
 711                 return 0;
 712             }
 713 
 714             keywordList[numKeywords].keyword[n] = 0;
 715             keywordList[numKeywords].keywordLen = n;
 716             /* now grab the value part. First we skip the &#39;=&#39; */
 717             equalSign++;
 718             /* then we leading spaces */
 719             while(*equalSign == &#39; &#39;) {
 720                 equalSign++;
 721             }
 722 
 723             /* Premature end or zero-length value */
 724             if (!*equalSign || equalSign == semicolon) {
 725                 *status = U_INVALID_FORMAT_ERROR;
 726                 return 0;
 727             }
 728 
 729             keywordList[numKeywords].valueStart = equalSign;
 730 
 731             pos = semicolon;
 732             i = 0;
 733             if(pos) {
 734                 while(*(pos - i - 1) == &#39; &#39;) {
 735                     i++;
 736                 }
 737                 keywordList[numKeywords].valueLen = (int32_t)(pos - equalSign - i);
 738                 pos++;
 739             } else {
 740                 i = (int32_t)uprv_strlen(equalSign);
 741                 while(i &amp;&amp; equalSign[i-1] == &#39; &#39;) {
 742                     i--;
 743                 }
 744                 keywordList[numKeywords].valueLen = i;
 745             }
 746             /* If this is a duplicate keyword, then ignore it */
 747             for (j=0; j&lt;numKeywords; ++j) {
 748                 if (uprv_strcmp(keywordList[j].keyword, keywordList[numKeywords].keyword) == 0) {
 749                     duplicate = TRUE;
 750                     break;
 751                 }
 752             }
 753             if (!duplicate) {
 754                 ++numKeywords;
 755             }
 756         } while(pos);
 757 
<a name="5" id="anc5"></a><span class="line-removed"> 758         /* Handle addKeyword/addValue. */</span>
<span class="line-removed"> 759         if (addKeyword != NULL) {</span>
<span class="line-removed"> 760             UBool duplicate = FALSE;</span>
<span class="line-removed"> 761             U_ASSERT(addValue != NULL);</span>
<span class="line-removed"> 762             /* Search for duplicate; if found, do nothing. Explicit keyword</span>
<span class="line-removed"> 763                overrides addKeyword. */</span>
<span class="line-removed"> 764             for (j=0; j&lt;numKeywords; ++j) {</span>
<span class="line-removed"> 765                 if (uprv_strcmp(keywordList[j].keyword, addKeyword) == 0) {</span>
<span class="line-removed"> 766                     duplicate = TRUE;</span>
<span class="line-removed"> 767                     break;</span>
<span class="line-removed"> 768                 }</span>
<span class="line-removed"> 769             }</span>
<span class="line-removed"> 770             if (!duplicate) {</span>
<span class="line-removed"> 771                 if (numKeywords == maxKeywords) {</span>
<span class="line-removed"> 772                     *status = U_INTERNAL_PROGRAM_ERROR;</span>
<span class="line-removed"> 773                     return 0;</span>
<span class="line-removed"> 774                 }</span>
<span class="line-removed"> 775                 uprv_strcpy(keywordList[numKeywords].keyword, addKeyword);</span>
<span class="line-removed"> 776                 keywordList[numKeywords].keywordLen = (int32_t)uprv_strlen(addKeyword);</span>
<span class="line-removed"> 777                 keywordList[numKeywords].valueStart = addValue;</span>
<span class="line-removed"> 778                 keywordList[numKeywords].valueLen = (int32_t)uprv_strlen(addValue);</span>
<span class="line-removed"> 779                 ++numKeywords;</span>
<span class="line-removed"> 780             }</span>
<span class="line-removed"> 781         } else {</span>
<span class="line-removed"> 782             U_ASSERT(addValue == NULL);</span>
<span class="line-removed"> 783         }</span>
<span class="line-removed"> 784 </span>
 785         /* now we have a list of keywords */
 786         /* we need to sort it */
 787         uprv_sortArray(keywordList, numKeywords, sizeof(KeywordStruct), compareKeywordStructs, NULL, FALSE, status);
 788 
 789         /* Now construct the keyword part */
 790         for(i = 0; i &lt; numKeywords; i++) {
 791             if(keywordsLen + keywordList[i].keywordLen + 1&lt; keywordCapacity) {
 792                 uprv_strcpy(keywords+keywordsLen, keywordList[i].keyword);
 793                 if(valuesToo) {
 794                     keywords[keywordsLen + keywordList[i].keywordLen] = &#39;=&#39;;
 795                 } else {
 796                     keywords[keywordsLen + keywordList[i].keywordLen] = 0;
 797                 }
 798             }
 799             keywordsLen += keywordList[i].keywordLen + 1;
 800             if(valuesToo) {
<a name="6" id="anc6"></a><span class="line-modified"> 801                 if(keywordsLen + keywordList[i].valueLen &lt; keywordCapacity) {</span>
 802                     uprv_strncpy(keywords+keywordsLen, keywordList[i].valueStart, keywordList[i].valueLen);
 803                 }
 804                 keywordsLen += keywordList[i].valueLen;
 805 
 806                 if(i &lt; numKeywords - 1) {
 807                     if(keywordsLen &lt; keywordCapacity) {
 808                         keywords[keywordsLen] = &#39;;&#39;;
 809                     }
 810                     keywordsLen++;
 811                 }
 812             }
 813             if(values) {
 814                 if(valuesLen + keywordList[i].valueLen + 1&lt; valuesCapacity) {
 815                     uprv_strcpy(values+valuesLen, keywordList[i].valueStart);
 816                     values[valuesLen + keywordList[i].valueLen] = 0;
 817                 }
 818                 valuesLen += keywordList[i].valueLen + 1;
 819             }
 820         }
 821         if(values) {
 822             values[valuesLen] = 0;
 823             if(valLen) {
 824                 *valLen = valuesLen;
 825             }
 826         }
 827         return u_terminateChars(keywords, keywordCapacity, keywordsLen, status);
 828     } else {
 829         return 0;
 830     }
 831 }
 832 
 833 U_CFUNC int32_t
 834 locale_getKeywords(const char *localeID,
 835                    char prev,
 836                    char *keywords, int32_t keywordCapacity,
 837                    char *values, int32_t valuesCapacity, int32_t *valLen,
 838                    UBool valuesToo,
 839                    UErrorCode *status) {
 840     return _getKeywords(localeID, prev, keywords, keywordCapacity,
 841                         values, valuesCapacity, valLen, valuesToo,
<a name="7" id="anc7"></a><span class="line-modified"> 842                         NULL, NULL, status);</span>
 843 }
 844 
 845 U_CAPI int32_t U_EXPORT2
 846 uloc_getKeywordValue(const char* localeID,
 847                      const char* keywordName,
 848                      char* buffer, int32_t bufferCapacity,
 849                      UErrorCode* status)
 850 {
 851     const char* startSearchHere = NULL;
 852     const char* nextSeparator = NULL;
 853     char keywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 854     char localeKeywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 855     int32_t result = 0;
 856 
 857     if(status &amp;&amp; U_SUCCESS(*status) &amp;&amp; localeID) {
 858       char tempBuffer[ULOC_FULLNAME_CAPACITY];
 859       const char* tmpLocaleID;
 860 
 861       if (keywordName == NULL || keywordName[0] == 0) {
 862         *status = U_ILLEGAL_ARGUMENT_ERROR;
 863         return 0;
 864       }
 865 
 866       locale_canonKeywordName(keywordNameBuffer, keywordName, status);
 867       if(U_FAILURE(*status)) {
 868         return 0;
 869       }
 870 
 871       if (_hasBCP47Extension(localeID)) {
 872           _ConvertBCP47(tmpLocaleID, localeID, tempBuffer, sizeof(tempBuffer), status);
 873       } else {
 874           tmpLocaleID=localeID;
 875       }
 876 
 877       startSearchHere = locale_getKeywordsStart(tmpLocaleID);
 878       if(startSearchHere == NULL) {
 879           /* no keywords, return at once */
 880           return 0;
 881       }
 882 
 883       /* find the first keyword */
 884       while(startSearchHere) {
 885           const char* keyValueTail;
 886           int32_t keyValueLen;
 887 
 888           startSearchHere++; /* skip @ or ; */
 889           nextSeparator = uprv_strchr(startSearchHere, &#39;=&#39;);
 890           if(!nextSeparator) {
 891               *status = U_ILLEGAL_ARGUMENT_ERROR; /* key must have =value */
 892               return 0;
 893           }
 894           /* strip leading &amp; trailing spaces (TC decided to tolerate these) */
 895           while(*startSearchHere == &#39; &#39;) {
 896               startSearchHere++;
 897           }
 898           keyValueTail = nextSeparator;
 899           while (keyValueTail &gt; startSearchHere &amp;&amp; *(keyValueTail-1) == &#39; &#39;) {
 900               keyValueTail--;
 901           }
 902           /* now keyValueTail points to first char after the keyName */
 903           /* copy &amp; normalize keyName from locale */
 904           if (startSearchHere == keyValueTail) {
 905               *status = U_ILLEGAL_ARGUMENT_ERROR; /* empty keyword name in passed-in locale */
 906               return 0;
 907           }
 908           keyValueLen = 0;
 909           while (startSearchHere &lt; keyValueTail) {
 910             if (!UPRV_ISALPHANUM(*startSearchHere)) {
 911               *status = U_ILLEGAL_ARGUMENT_ERROR; /* malformed keyword name */
 912               return 0;
 913             }
 914             if (keyValueLen &lt; ULOC_KEYWORD_BUFFER_LEN - 1) {
 915               localeKeywordNameBuffer[keyValueLen++] = uprv_tolower(*startSearchHere++);
 916             } else {
 917               /* keyword name too long for internal buffer */
 918               *status = U_INTERNAL_PROGRAM_ERROR;
 919               return 0;
 920             }
 921           }
 922           localeKeywordNameBuffer[keyValueLen] = 0; /* terminate */
 923 
 924           startSearchHere = uprv_strchr(nextSeparator, &#39;;&#39;);
 925 
 926           if(uprv_strcmp(keywordNameBuffer, localeKeywordNameBuffer) == 0) {
 927                /* current entry matches the keyword. */
 928              nextSeparator++; /* skip &#39;=&#39; */
 929               /* First strip leading &amp; trailing spaces (TC decided to tolerate these) */
 930               while(*nextSeparator == &#39; &#39;) {
 931                 nextSeparator++;
 932               }
 933               keyValueTail = (startSearchHere)? startSearchHere: nextSeparator + uprv_strlen(nextSeparator);
 934               while(keyValueTail &gt; nextSeparator &amp;&amp; *(keyValueTail-1) == &#39; &#39;) {
 935                 keyValueTail--;
 936               }
 937               /* Now copy the value, but check well-formedness */
 938               if (nextSeparator == keyValueTail) {
 939                 *status = U_ILLEGAL_ARGUMENT_ERROR; /* empty key value name in passed-in locale */
 940                 return 0;
 941               }
 942               keyValueLen = 0;
 943               while (nextSeparator &lt; keyValueTail) {
 944                 if (!UPRV_ISALPHANUM(*nextSeparator) &amp;&amp; !UPRV_OK_VALUE_PUNCTUATION(*nextSeparator)) {
 945                   *status = U_ILLEGAL_ARGUMENT_ERROR; /* malformed key value */
 946                   return 0;
 947                 }
 948                 if (keyValueLen &lt; bufferCapacity) {
 949                   /* Should we lowercase value to return here? Tests expect as-is. */
 950                   buffer[keyValueLen++] = *nextSeparator++;
 951                 } else { /* keep advancing so we return correct length in case of overflow */
 952                   keyValueLen++;
 953                   nextSeparator++;
 954                 }
 955               }
 956               result = u_terminateChars(buffer, bufferCapacity, keyValueLen, status);
 957               return result;
 958           }
 959       }
 960     }
 961     return 0;
 962 }
 963 
 964 U_CAPI int32_t U_EXPORT2
 965 uloc_setKeywordValue(const char* keywordName,
 966                      const char* keywordValue,
 967                      char* buffer, int32_t bufferCapacity,
 968                      UErrorCode* status)
 969 {
 970     /* TODO: sorting. removal. */
 971     int32_t keywordNameLen;
 972     int32_t keywordValueLen;
 973     int32_t bufLen;
 974     int32_t needLen = 0;
 975     char keywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 976     char keywordValueBuffer[ULOC_KEYWORDS_CAPACITY+1];
 977     char localeKeywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 978     int32_t rc;
 979     char* nextSeparator = NULL;
 980     char* nextEqualsign = NULL;
 981     char* startSearchHere = NULL;
 982     char* keywordStart = NULL;
 983     CharString updatedKeysAndValues;
 984     int32_t updatedKeysAndValuesLen;
 985     UBool handledInputKeyAndValue = FALSE;
 986     char keyValuePrefix = &#39;@&#39;;
 987 
 988     if(U_FAILURE(*status)) {
 989         return -1;
 990     }
 991     if (keywordName == NULL || keywordName[0] == 0 || bufferCapacity &lt;= 1) {
 992         *status = U_ILLEGAL_ARGUMENT_ERROR;
 993         return 0;
 994     }
 995     bufLen = (int32_t)uprv_strlen(buffer);
 996     if(bufferCapacity&lt;bufLen) {
 997         /* The capacity is less than the length?! Is this NULL terminated? */
 998         *status = U_ILLEGAL_ARGUMENT_ERROR;
 999         return 0;
1000     }
1001     keywordNameLen = locale_canonKeywordName(keywordNameBuffer, keywordName, status);
1002     if(U_FAILURE(*status)) {
1003         return 0;
1004     }
1005 
1006     keywordValueLen = 0;
1007     if(keywordValue) {
1008         while (*keywordValue != 0) {
1009             if (!UPRV_ISALPHANUM(*keywordValue) &amp;&amp; !UPRV_OK_VALUE_PUNCTUATION(*keywordValue)) {
1010                 *status = U_ILLEGAL_ARGUMENT_ERROR; /* malformed key value */
1011                 return 0;
1012             }
1013             if (keywordValueLen &lt; ULOC_KEYWORDS_CAPACITY) {
1014                 /* Should we force lowercase in value to set? */
1015                 keywordValueBuffer[keywordValueLen++] = *keywordValue++;
1016             } else {
1017                 /* keywordValue too long for internal buffer */
1018                 *status = U_INTERNAL_PROGRAM_ERROR;
1019                 return 0;
1020             }
1021         }
1022     }
1023     keywordValueBuffer[keywordValueLen] = 0; /* terminate */
1024 
1025     startSearchHere = (char*)locale_getKeywordsStart(buffer);
1026     if(startSearchHere == NULL || (startSearchHere[1]==0)) {
1027         if(keywordValueLen == 0) { /* no keywords = nothing to remove */
1028             return bufLen;
1029         }
1030 
1031         needLen = bufLen+1+keywordNameLen+1+keywordValueLen;
1032         if(startSearchHere) { /* had a single @ */
1033             needLen--; /* already had the @ */
1034             /* startSearchHere points at the @ */
1035         } else {
1036             startSearchHere=buffer+bufLen;
1037         }
1038         if(needLen &gt;= bufferCapacity) {
1039             *status = U_BUFFER_OVERFLOW_ERROR;
1040             return needLen; /* no change */
1041         }
1042         *startSearchHere++ = &#39;@&#39;;
1043         uprv_strcpy(startSearchHere, keywordNameBuffer);
1044         startSearchHere += keywordNameLen;
1045         *startSearchHere++ = &#39;=&#39;;
1046         uprv_strcpy(startSearchHere, keywordValueBuffer);
1047         return needLen;
1048     } /* end shortcut - no @ */
1049 
1050     keywordStart = startSearchHere;
1051     /* search for keyword */
1052     while(keywordStart) {
1053         const char* keyValueTail;
1054         int32_t keyValueLen;
1055 
1056         keywordStart++; /* skip @ or ; */
1057         nextEqualsign = uprv_strchr(keywordStart, &#39;=&#39;);
1058         if (!nextEqualsign) {
1059             *status = U_ILLEGAL_ARGUMENT_ERROR; /* key must have =value */
1060             return 0;
1061         }
1062         /* strip leading &amp; trailing spaces (TC decided to tolerate these) */
1063         while(*keywordStart == &#39; &#39;) {
1064             keywordStart++;
1065         }
1066         keyValueTail = nextEqualsign;
1067         while (keyValueTail &gt; keywordStart &amp;&amp; *(keyValueTail-1) == &#39; &#39;) {
1068             keyValueTail--;
1069         }
1070         /* now keyValueTail points to first char after the keyName */
1071         /* copy &amp; normalize keyName from locale */
1072         if (keywordStart == keyValueTail) {
1073             *status = U_ILLEGAL_ARGUMENT_ERROR; /* empty keyword name in passed-in locale */
1074             return 0;
1075         }
1076         keyValueLen = 0;
1077         while (keywordStart &lt; keyValueTail) {
1078             if (!UPRV_ISALPHANUM(*keywordStart)) {
1079                 *status = U_ILLEGAL_ARGUMENT_ERROR; /* malformed keyword name */
1080                 return 0;
1081             }
1082             if (keyValueLen &lt; ULOC_KEYWORD_BUFFER_LEN - 1) {
1083                 localeKeywordNameBuffer[keyValueLen++] = uprv_tolower(*keywordStart++);
1084             } else {
1085                 /* keyword name too long for internal buffer */
1086                 *status = U_INTERNAL_PROGRAM_ERROR;
1087                 return 0;
1088             }
1089         }
1090         localeKeywordNameBuffer[keyValueLen] = 0; /* terminate */
1091 
1092         nextSeparator = uprv_strchr(nextEqualsign, &#39;;&#39;);
1093 
1094         /* start processing the value part */
1095         nextEqualsign++; /* skip &#39;=&#39; */
1096         /* First strip leading &amp; trailing spaces (TC decided to tolerate these) */
1097         while(*nextEqualsign == &#39; &#39;) {
1098             nextEqualsign++;
1099         }
1100         keyValueTail = (nextSeparator)? nextSeparator: nextEqualsign + uprv_strlen(nextEqualsign);
1101         while(keyValueTail &gt; nextEqualsign &amp;&amp; *(keyValueTail-1) == &#39; &#39;) {
1102             keyValueTail--;
1103         }
1104         if (nextEqualsign == keyValueTail) {
1105             *status = U_ILLEGAL_ARGUMENT_ERROR; /* empty key value in passed-in locale */
1106             return 0;
1107         }
1108 
1109         rc = uprv_strcmp(keywordNameBuffer, localeKeywordNameBuffer);
1110         if(rc == 0) {
1111             /* Current entry matches the input keyword. Update the entry */
1112             if(keywordValueLen &gt; 0) { /* updating a value */
1113                 updatedKeysAndValues.append(keyValuePrefix, *status);
1114                 keyValuePrefix = &#39;;&#39;; /* for any subsequent key-value pair */
1115                 updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
1116                 updatedKeysAndValues.append(&#39;=&#39;, *status);
1117                 updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1118             } /* else removing this entry, don&#39;t emit anything */
1119             handledInputKeyAndValue = TRUE;
1120         } else {
1121            /* input keyword sorts earlier than current entry, add before current entry */
1122             if (rc &lt; 0 &amp;&amp; keywordValueLen &gt; 0 &amp;&amp; !handledInputKeyAndValue) {
1123                 /* insert new entry at this location */
1124                 updatedKeysAndValues.append(keyValuePrefix, *status);
1125                 keyValuePrefix = &#39;;&#39;; /* for any subsequent key-value pair */
1126                 updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
1127                 updatedKeysAndValues.append(&#39;=&#39;, *status);
1128                 updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1129                 handledInputKeyAndValue = TRUE;
1130             }
1131             /* copy the current entry */
1132             updatedKeysAndValues.append(keyValuePrefix, *status);
1133             keyValuePrefix = &#39;;&#39;; /* for any subsequent key-value pair */
1134             updatedKeysAndValues.append(localeKeywordNameBuffer, keyValueLen, *status);
1135             updatedKeysAndValues.append(&#39;=&#39;, *status);
<a name="8" id="anc8"></a><span class="line-modified">1136             updatedKeysAndValues.append(nextEqualsign, keyValueTail-nextEqualsign, *status);</span>
1137         }
1138         if (!nextSeparator &amp;&amp; keywordValueLen &gt; 0 &amp;&amp; !handledInputKeyAndValue) {
1139             /* append new entry at the end, it sorts later than existing entries */
1140             updatedKeysAndValues.append(keyValuePrefix, *status);
1141             /* skip keyValuePrefix update, no subsequent key-value pair */
1142             updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
1143             updatedKeysAndValues.append(&#39;=&#39;, *status);
1144             updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1145             handledInputKeyAndValue = TRUE;
1146         }
1147         keywordStart = nextSeparator;
1148     } /* end loop searching */
1149 
1150     /* Any error from updatedKeysAndValues.append above would be internal and not due to
1151      * problems with the passed-in locale. So if we did encounter problems with the
1152      * passed-in locale above, those errors took precedence and overrode any error
1153      * status from updatedKeysAndValues.append, and also caused a return of 0. If there
1154      * are errors here they are from updatedKeysAndValues.append; they do cause an
1155      * error return but the passed-in locale is unmodified and the original bufLen is
1156      * returned.
1157      */
1158     if (!handledInputKeyAndValue || U_FAILURE(*status)) {
1159         /* if input key/value specified removal of a keyword not present in locale, or
1160          * there was an error in CharString.append, leave original locale alone. */
1161         return bufLen;
1162     }
1163 
1164     updatedKeysAndValuesLen = updatedKeysAndValues.length();
1165     /* needLen = length of the part before &#39;@&#39; + length of updated key-value part including &#39;@&#39; */
1166     needLen = (int32_t)(startSearchHere - buffer) + updatedKeysAndValuesLen;
1167     if(needLen &gt;= bufferCapacity) {
1168         *status = U_BUFFER_OVERFLOW_ERROR;
1169         return needLen; /* no change */
1170     }
1171     if (updatedKeysAndValuesLen &gt; 0) {
1172         uprv_strncpy(startSearchHere, updatedKeysAndValues.data(), updatedKeysAndValuesLen);
1173     }
1174     buffer[needLen]=0;
1175     return needLen;
1176 }
1177 
1178 /* ### ID parsing implementation **************************************************/
1179 
1180 #define _isPrefixLetter(a) ((a==&#39;x&#39;)||(a==&#39;X&#39;)||(a==&#39;i&#39;)||(a==&#39;I&#39;))
1181 
1182 /*returns TRUE if one of the special prefixes is here (s=string)
1183   &#39;x-&#39; or &#39;i-&#39; */
1184 #define _isIDPrefix(s) (_isPrefixLetter(s[0])&amp;&amp;_isIDSeparator(s[1]))
1185 
1186 /* Dot terminates it because of POSIX form  where dot precedes the codepage
1187  * except for variant
1188  */
1189 #define _isTerminator(a)  ((a==0)||(a==&#39;.&#39;)||(a==&#39;@&#39;))
1190 
<a name="9" id="anc9"></a><span class="line-removed">1191 static char* _strnchr(const char* str, int32_t len, char c) {</span>
<span class="line-removed">1192     U_ASSERT(str != 0 &amp;&amp; len &gt;= 0);</span>
<span class="line-removed">1193     while (len-- != 0) {</span>
<span class="line-removed">1194         char d = *str;</span>
<span class="line-removed">1195         if (d == c) {</span>
<span class="line-removed">1196             return (char*) str;</span>
<span class="line-removed">1197         } else if (d == 0) {</span>
<span class="line-removed">1198             break;</span>
<span class="line-removed">1199         }</span>
<span class="line-removed">1200         ++str;</span>
<span class="line-removed">1201     }</span>
<span class="line-removed">1202     return NULL;</span>
<span class="line-removed">1203 }</span>
<span class="line-removed">1204 </span>
1205 /**
1206  * Lookup &#39;key&#39; in the array &#39;list&#39;.  The array &#39;list&#39; should contain
1207  * a NULL entry, followed by more entries, and a second NULL entry.
1208  *
1209  * The &#39;list&#39; param should be LANGUAGES, LANGUAGES_3, COUNTRIES, or
1210  * COUNTRIES_3.
1211  */
1212 static int16_t _findIndex(const char* const* list, const char* key)
1213 {
1214     const char* const* anchor = list;
1215     int32_t pass = 0;
1216 
1217     /* Make two passes through two NULL-terminated arrays at &#39;list&#39; */
1218     while (pass++ &lt; 2) {
1219         while (*list) {
1220             if (uprv_strcmp(key, *list) == 0) {
1221                 return (int16_t)(list - anchor);
1222             }
1223             list++;
1224         }
1225         ++list;     /* skip final NULL *CWB*/
1226     }
1227     return -1;
1228 }
1229 
1230 /* count the length of src while copying it to dest; return strlen(src) */
1231 static inline int32_t
1232 _copyCount(char *dest, int32_t destCapacity, const char *src) {
1233     const char *anchor;
1234     char c;
1235 
1236     anchor=src;
1237     for(;;) {
1238         if((c=*src)==0) {
1239             return (int32_t)(src-anchor);
1240         }
1241         if(destCapacity&lt;=0) {
1242             return (int32_t)((src-anchor)+uprv_strlen(src));
1243         }
1244         ++src;
1245         *dest++=c;
1246         --destCapacity;
1247     }
1248 }
1249 
1250 U_CFUNC const char*
1251 uloc_getCurrentCountryID(const char* oldID){
1252     int32_t offset = _findIndex(DEPRECATED_COUNTRIES, oldID);
1253     if (offset &gt;= 0) {
1254         return REPLACEMENT_COUNTRIES[offset];
1255     }
1256     return oldID;
1257 }
1258 U_CFUNC const char*
1259 uloc_getCurrentLanguageID(const char* oldID){
1260     int32_t offset = _findIndex(DEPRECATED_LANGUAGES, oldID);
1261     if (offset &gt;= 0) {
1262         return REPLACEMENT_LANGUAGES[offset];
1263     }
1264     return oldID;
1265 }
1266 /*
1267  * the internal functions _getLanguage(), _getCountry(), _getVariant()
1268  * avoid duplicating code to handle the earlier locale ID pieces
1269  * in the functions for the later ones by
1270  * setting the *pEnd pointer to where they stopped parsing
1271  *
1272  * TODO try to use this in Locale
1273  */
1274 U_CFUNC int32_t
1275 ulocimp_getLanguage(const char *localeID,
1276                     char *language, int32_t languageCapacity,
1277                     const char **pEnd) {
1278     int32_t i=0;
1279     int32_t offset;
1280     char lang[4]={ 0, 0, 0, 0 }; /* temporary buffer to hold language code for searching */
1281 
<a name="10" id="anc10"></a>









1282     /* if it starts with i- or x- then copy that prefix */
1283     if(_isIDPrefix(localeID)) {
1284         if(i&lt;languageCapacity) {
1285             language[i]=(char)uprv_tolower(*localeID);
1286         }
1287         if(i&lt;languageCapacity) {
1288             language[i+1]=&#39;-&#39;;
1289         }
1290         i+=2;
1291         localeID+=2;
1292     }
1293 
1294     /* copy the language as far as possible and count its length */
1295     while(!_isTerminator(*localeID) &amp;&amp; !_isIDSeparator(*localeID)) {
1296         if(i&lt;languageCapacity) {
1297             language[i]=(char)uprv_tolower(*localeID);
1298         }
1299         if(i&lt;3) {
1300             U_ASSERT(i&gt;=0);
1301             lang[i]=(char)uprv_tolower(*localeID);
1302         }
1303         i++;
1304         localeID++;
1305     }
1306 
1307     if(i==3) {
1308         /* convert 3 character code to 2 character code if possible *CWB*/
1309         offset=_findIndex(LANGUAGES_3, lang);
1310         if(offset&gt;=0) {
1311             i=_copyCount(language, languageCapacity, LANGUAGES[offset]);
1312         }
1313     }
1314 
1315     if(pEnd!=NULL) {
1316         *pEnd=localeID;
1317     }
1318     return i;
1319 }
1320 
1321 U_CFUNC int32_t
1322 ulocimp_getScript(const char *localeID,
1323                   char *script, int32_t scriptCapacity,
1324                   const char **pEnd)
1325 {
1326     int32_t idLen = 0;
1327 
1328     if (pEnd != NULL) {
1329         *pEnd = localeID;
1330     }
1331 
1332     /* copy the second item as far as possible and count its length */
1333     while(!_isTerminator(localeID[idLen]) &amp;&amp; !_isIDSeparator(localeID[idLen])
1334             &amp;&amp; uprv_isASCIILetter(localeID[idLen])) {
1335         idLen++;
1336     }
1337 
1338     /* If it&#39;s exactly 4 characters long, then it&#39;s a script and not a country. */
1339     if (idLen == 4) {
1340         int32_t i;
1341         if (pEnd != NULL) {
1342             *pEnd = localeID+idLen;
1343         }
1344         if(idLen &gt; scriptCapacity) {
1345             idLen = scriptCapacity;
1346         }
1347         if (idLen &gt;= 1) {
1348             script[0]=(char)uprv_toupper(*(localeID++));
1349         }
1350         for (i = 1; i &lt; idLen; i++) {
1351             script[i]=(char)uprv_tolower(*(localeID++));
1352         }
1353     }
1354     else {
1355         idLen = 0;
1356     }
1357     return idLen;
1358 }
1359 
1360 U_CFUNC int32_t
1361 ulocimp_getCountry(const char *localeID,
1362                    char *country, int32_t countryCapacity,
1363                    const char **pEnd)
1364 {
1365     int32_t idLen=0;
1366     char cnty[ULOC_COUNTRY_CAPACITY]={ 0, 0, 0, 0 };
1367     int32_t offset;
1368 
1369     /* copy the country as far as possible and count its length */
1370     while(!_isTerminator(localeID[idLen]) &amp;&amp; !_isIDSeparator(localeID[idLen])) {
1371         if(idLen&lt;(ULOC_COUNTRY_CAPACITY-1)) {   /*CWB*/
1372             cnty[idLen]=(char)uprv_toupper(localeID[idLen]);
1373         }
1374         idLen++;
1375     }
1376 
1377     /* the country should be either length 2 or 3 */
1378     if (idLen == 2 || idLen == 3) {
1379         UBool gotCountry = FALSE;
1380         /* convert 3 character code to 2 character code if possible *CWB*/
1381         if(idLen==3) {
1382             offset=_findIndex(COUNTRIES_3, cnty);
1383             if(offset&gt;=0) {
1384                 idLen=_copyCount(country, countryCapacity, COUNTRIES[offset]);
1385                 gotCountry = TRUE;
1386             }
1387         }
1388         if (!gotCountry) {
1389             int32_t i = 0;
1390             for (i = 0; i &lt; idLen; i++) {
1391                 if (i &lt; countryCapacity) {
1392                     country[i]=(char)uprv_toupper(localeID[i]);
1393                 }
1394             }
1395         }
1396         localeID+=idLen;
1397     } else {
1398         idLen = 0;
1399     }
1400 
1401     if(pEnd!=NULL) {
1402         *pEnd=localeID;
1403     }
1404 
1405     return idLen;
1406 }
1407 
1408 /**
1409  * @param needSeparator if true, then add leading &#39;_&#39; if any variants
1410  * are added to &#39;variant&#39;
1411  */
1412 static int32_t
1413 _getVariantEx(const char *localeID,
1414               char prev,
1415               char *variant, int32_t variantCapacity,
1416               UBool needSeparator) {
1417     int32_t i=0;
1418 
1419     /* get one or more variant tags and separate them with &#39;_&#39; */
1420     if(_isIDSeparator(prev)) {
1421         /* get a variant string after a &#39;-&#39; or &#39;_&#39; */
1422         while(!_isTerminator(*localeID)) {
1423             if (needSeparator) {
1424                 if (i&lt;variantCapacity) {
1425                     variant[i] = &#39;_&#39;;
1426                 }
1427                 ++i;
1428                 needSeparator = FALSE;
1429             }
1430             if(i&lt;variantCapacity) {
1431                 variant[i]=(char)uprv_toupper(*localeID);
1432                 if(variant[i]==&#39;-&#39;) {
1433                     variant[i]=&#39;_&#39;;
1434                 }
1435             }
1436             i++;
1437             localeID++;
1438         }
1439     }
1440 
1441     /* if there is no variant tag after a &#39;-&#39; or &#39;_&#39; then look for &#39;@&#39; */
1442     if(i==0) {
1443         if(prev==&#39;@&#39;) {
1444             /* keep localeID */
1445         } else if((localeID=locale_getKeywordsStart(localeID))!=NULL) {
1446             ++localeID; /* point after the &#39;@&#39; */
1447         } else {
1448             return 0;
1449         }
1450         while(!_isTerminator(*localeID)) {
1451             if (needSeparator) {
1452                 if (i&lt;variantCapacity) {
1453                     variant[i] = &#39;_&#39;;
1454                 }
1455                 ++i;
1456                 needSeparator = FALSE;
1457             }
1458             if(i&lt;variantCapacity) {
1459                 variant[i]=(char)uprv_toupper(*localeID);
1460                 if(variant[i]==&#39;-&#39; || variant[i]==&#39;,&#39;) {
1461                     variant[i]=&#39;_&#39;;
1462                 }
1463             }
1464             i++;
1465             localeID++;
1466         }
1467     }
1468 
1469     return i;
1470 }
1471 
1472 static int32_t
1473 _getVariant(const char *localeID,
1474             char prev,
1475             char *variant, int32_t variantCapacity) {
1476     return _getVariantEx(localeID, prev, variant, variantCapacity, FALSE);
1477 }
1478 
<a name="11" id="anc11"></a><span class="line-removed">1479 /**</span>
<span class="line-removed">1480  * Delete ALL instances of a variant from the given list of one or</span>
<span class="line-removed">1481  * more variants.  Example: &quot;FOO_EURO_BAR_EURO&quot; =&gt; &quot;FOO_BAR&quot;.</span>
<span class="line-removed">1482  * @param variants the source string of one or more variants,</span>
<span class="line-removed">1483  * separated by &#39;_&#39;.  This will be MODIFIED IN PLACE.  Not zero</span>
<span class="line-removed">1484  * terminated; if it is, trailing zero will NOT be maintained.</span>
<span class="line-removed">1485  * @param variantsLen length of variants</span>
<span class="line-removed">1486  * @param toDelete variant to delete, without separators, e.g.  &quot;EURO&quot;</span>
<span class="line-removed">1487  * or &quot;PREEURO&quot;; not zero terminated</span>
<span class="line-removed">1488  * @param toDeleteLen length of toDelete</span>
<span class="line-removed">1489  * @return number of characters deleted from variants</span>
<span class="line-removed">1490  */</span>
<span class="line-removed">1491 static int32_t</span>
<span class="line-removed">1492 _deleteVariant(char* variants, int32_t variantsLen,</span>
<span class="line-removed">1493                const char* toDelete, int32_t toDeleteLen)</span>
<span class="line-removed">1494 {</span>
<span class="line-removed">1495     int32_t delta = 0; /* number of chars deleted */</span>
<span class="line-removed">1496     for (;;) {</span>
<span class="line-removed">1497         UBool flag = FALSE;</span>
<span class="line-removed">1498         if (variantsLen &lt; toDeleteLen) {</span>
<span class="line-removed">1499             return delta;</span>
<span class="line-removed">1500         }</span>
<span class="line-removed">1501         if (uprv_strncmp(variants, toDelete, toDeleteLen) == 0 &amp;&amp;</span>
<span class="line-removed">1502             (variantsLen == toDeleteLen ||</span>
<span class="line-removed">1503              (flag=(variants[toDeleteLen] == &#39;_&#39;))))</span>
<span class="line-removed">1504         {</span>
<span class="line-removed">1505             int32_t d = toDeleteLen + (flag?1:0);</span>
<span class="line-removed">1506             variantsLen -= d;</span>
<span class="line-removed">1507             delta += d;</span>
<span class="line-removed">1508             if (variantsLen &gt; 0) {</span>
<span class="line-removed">1509                 uprv_memmove(variants, variants+d, variantsLen);</span>
<span class="line-removed">1510             }</span>
<span class="line-removed">1511         } else {</span>
<span class="line-removed">1512             char* p = _strnchr(variants, variantsLen, &#39;_&#39;);</span>
<span class="line-removed">1513             if (p == NULL) {</span>
<span class="line-removed">1514                 return delta;</span>
<span class="line-removed">1515             }</span>
<span class="line-removed">1516             ++p;</span>
<span class="line-removed">1517             variantsLen -= (int32_t)(p - variants);</span>
<span class="line-removed">1518             variants = p;</span>
<span class="line-removed">1519         }</span>
<span class="line-removed">1520     }</span>
<span class="line-removed">1521 }</span>
<span class="line-removed">1522 </span>
1523 /* Keyword enumeration */
1524 
1525 typedef struct UKeywordsContext {
1526     char* keywords;
1527     char* current;
1528 } UKeywordsContext;
1529 
1530 U_CDECL_BEGIN
1531 
1532 static void U_CALLCONV
1533 uloc_kw_closeKeywords(UEnumeration *enumerator) {
1534     uprv_free(((UKeywordsContext *)enumerator-&gt;context)-&gt;keywords);
1535     uprv_free(enumerator-&gt;context);
1536     uprv_free(enumerator);
1537 }
1538 
1539 static int32_t U_CALLCONV
1540 uloc_kw_countKeywords(UEnumeration *en, UErrorCode * /*status*/) {
1541     char *kw = ((UKeywordsContext *)en-&gt;context)-&gt;keywords;
1542     int32_t result = 0;
1543     while(*kw) {
1544         result++;
1545         kw += uprv_strlen(kw)+1;
1546     }
1547     return result;
1548 }
1549 
1550 static const char * U_CALLCONV
1551 uloc_kw_nextKeyword(UEnumeration* en,
1552                     int32_t* resultLength,
1553                     UErrorCode* /*status*/) {
1554     const char* result = ((UKeywordsContext *)en-&gt;context)-&gt;current;
1555     int32_t len = 0;
1556     if(*result) {
1557         len = (int32_t)uprv_strlen(((UKeywordsContext *)en-&gt;context)-&gt;current);
1558         ((UKeywordsContext *)en-&gt;context)-&gt;current += len+1;
1559     } else {
1560         result = NULL;
1561     }
1562     if (resultLength) {
1563         *resultLength = len;
1564     }
1565     return result;
1566 }
1567 
1568 static void U_CALLCONV
1569 uloc_kw_resetKeywords(UEnumeration* en,
1570                       UErrorCode* /*status*/) {
1571     ((UKeywordsContext *)en-&gt;context)-&gt;current = ((UKeywordsContext *)en-&gt;context)-&gt;keywords;
1572 }
1573 
1574 U_CDECL_END
1575 
1576 
1577 static const UEnumeration gKeywordsEnum = {
1578     NULL,
1579     NULL,
1580     uloc_kw_closeKeywords,
1581     uloc_kw_countKeywords,
1582     uenum_unextDefault,
1583     uloc_kw_nextKeyword,
1584     uloc_kw_resetKeywords
1585 };
1586 
1587 U_CAPI UEnumeration* U_EXPORT2
1588 uloc_openKeywordList(const char *keywordList, int32_t keywordListSize, UErrorCode* status)
1589 {
1590     UKeywordsContext *myContext = NULL;
1591     UEnumeration *result = NULL;
1592 
1593     if(U_FAILURE(*status)) {
1594         return NULL;
1595     }
1596     result = (UEnumeration *)uprv_malloc(sizeof(UEnumeration));
1597     /* Null pointer test */
1598     if (result == NULL) {
1599         *status = U_MEMORY_ALLOCATION_ERROR;
1600         return NULL;
1601     }
1602     uprv_memcpy(result, &amp;gKeywordsEnum, sizeof(UEnumeration));
1603     myContext = static_cast&lt;UKeywordsContext *&gt;(uprv_malloc(sizeof(UKeywordsContext)));
1604     if (myContext == NULL) {
1605         *status = U_MEMORY_ALLOCATION_ERROR;
1606         uprv_free(result);
1607         return NULL;
1608     }
1609     myContext-&gt;keywords = (char *)uprv_malloc(keywordListSize+1);
1610     uprv_memcpy(myContext-&gt;keywords, keywordList, keywordListSize);
1611     myContext-&gt;keywords[keywordListSize] = 0;
1612     myContext-&gt;current = myContext-&gt;keywords;
1613     result-&gt;context = myContext;
1614     return result;
1615 }
1616 
1617 U_CAPI UEnumeration* U_EXPORT2
1618 uloc_openKeywords(const char* localeID,
1619                         UErrorCode* status)
1620 {
1621     int32_t i=0;
1622     char keywords[256];
1623     int32_t keywordsCapacity = 256;
1624     char tempBuffer[ULOC_FULLNAME_CAPACITY];
1625     const char* tmpLocaleID;
1626 
1627     if(status==NULL || U_FAILURE(*status)) {
1628         return 0;
1629     }
1630 
1631     if (_hasBCP47Extension(localeID)) {
1632         _ConvertBCP47(tmpLocaleID, localeID, tempBuffer, sizeof(tempBuffer), status);
1633     } else {
1634         if (localeID==NULL) {
1635            localeID=uloc_getDefault();
1636         }
1637         tmpLocaleID=localeID;
1638     }
1639 
1640     /* Skip the language */
1641     ulocimp_getLanguage(tmpLocaleID, NULL, 0, &amp;tmpLocaleID);
1642     if(_isIDSeparator(*tmpLocaleID)) {
1643         const char *scriptID;
1644         /* Skip the script if available */
1645         ulocimp_getScript(tmpLocaleID+1, NULL, 0, &amp;scriptID);
1646         if(scriptID != tmpLocaleID+1) {
1647             /* Found optional script */
1648             tmpLocaleID = scriptID;
1649         }
1650         /* Skip the Country */
1651         if (_isIDSeparator(*tmpLocaleID)) {
1652             ulocimp_getCountry(tmpLocaleID+1, NULL, 0, &amp;tmpLocaleID);
1653             if(_isIDSeparator(*tmpLocaleID)) {
1654                 _getVariant(tmpLocaleID+1, *tmpLocaleID, NULL, 0);
1655             }
1656         }
1657     }
1658 
1659     /* keywords are located after &#39;@&#39; */
1660     if((tmpLocaleID = locale_getKeywordsStart(tmpLocaleID)) != NULL) {
1661         i=locale_getKeywords(tmpLocaleID+1, &#39;@&#39;, keywords, keywordsCapacity, NULL, 0, NULL, FALSE, status);
1662     }
1663 
1664     if(i) {
1665         return uloc_openKeywordList(keywords, i, status);
1666     } else {
1667         return NULL;
1668     }
1669 }
1670 
1671 
1672 /* bit-flags for &#39;options&#39; parameter of _canonicalize */
1673 #define _ULOC_STRIP_KEYWORDS 0x2
1674 #define _ULOC_CANONICALIZE   0x1
1675 
1676 #define OPTION_SET(options, mask) ((options &amp; mask) != 0)
1677 
1678 static const char i_default[] = {&#39;i&#39;, &#39;-&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;a&#39;, &#39;u&#39;, &#39;l&#39;, &#39;t&#39;};
1679 #define I_DEFAULT_LENGTH UPRV_LENGTHOF(i_default)
1680 
1681 /**
1682  * Canonicalize the given localeID, to level 1 or to level 2,
1683  * depending on the options.  To specify level 1, pass in options=0.
1684  * To specify level 2, pass in options=_ULOC_CANONICALIZE.
1685  *
1686  * This is the code underlying uloc_getName and uloc_canonicalize.
1687  */
1688 static int32_t
1689 _canonicalize(const char* localeID,
1690               char* result,
1691               int32_t resultCapacity,
1692               uint32_t options,
1693               UErrorCode* err) {
1694     int32_t j, len, fieldCount=0, scriptSize=0, variantSize=0, nameCapacity;
1695     char localeBuffer[ULOC_FULLNAME_CAPACITY];
1696     char tempBuffer[ULOC_FULLNAME_CAPACITY];
1697     const char* origLocaleID;
1698     const char* tmpLocaleID;
1699     const char* keywordAssign = NULL;
1700     const char* separatorIndicator = NULL;
<a name="12" id="anc12"></a><span class="line-removed">1701     const char* addKeyword = NULL;</span>
<span class="line-removed">1702     const char* addValue = NULL;</span>
1703     char* name;
1704     char* variant = NULL; /* pointer into name, or NULL */
1705 
1706     if (U_FAILURE(*err)) {
1707         return 0;
1708     }
1709 
1710     if (_hasBCP47Extension(localeID)) {
1711         _ConvertBCP47(tmpLocaleID, localeID, tempBuffer, sizeof(tempBuffer), err);
1712     } else {
1713         if (localeID==NULL) {
1714            localeID=uloc_getDefault();
1715         }
1716         tmpLocaleID=localeID;
1717     }
1718 
1719     origLocaleID=tmpLocaleID;
1720 
1721     /* if we are doing a full canonicalization, then put results in
1722        localeBuffer, if necessary; otherwise send them to result. */
1723     if (/*OPTION_SET(options, _ULOC_CANONICALIZE) &amp;&amp;*/
1724         (result == NULL || resultCapacity &lt; (int32_t)sizeof(localeBuffer))) {
1725         name = localeBuffer;
1726         nameCapacity = (int32_t)sizeof(localeBuffer);
1727     } else {
1728         name = result;
1729         nameCapacity = resultCapacity;
1730     }
1731 
1732     /* get all pieces, one after another, and separate with &#39;_&#39; */
1733     len=ulocimp_getLanguage(tmpLocaleID, name, nameCapacity, &amp;tmpLocaleID);
1734 
1735     if(len == I_DEFAULT_LENGTH &amp;&amp; uprv_strncmp(origLocaleID, i_default, len) == 0) {
1736         const char *d = uloc_getDefault();
1737 
1738         len = (int32_t)uprv_strlen(d);
1739 
1740         if (name != NULL) {
<a name="13" id="anc13"></a><span class="line-modified">1741             uprv_strncpy(name, d, len);</span>
1742         }
1743     } else if(_isIDSeparator(*tmpLocaleID)) {
1744         const char *scriptID;
1745 
1746         ++fieldCount;
1747         if(len&lt;nameCapacity) {
1748             name[len]=&#39;_&#39;;
1749         }
1750         ++len;
1751 
1752         scriptSize=ulocimp_getScript(tmpLocaleID+1,
1753             (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len, &amp;scriptID);
1754         if(scriptSize &gt; 0) {
1755             /* Found optional script */
1756             tmpLocaleID = scriptID;
1757             ++fieldCount;
1758             len+=scriptSize;
1759             if (_isIDSeparator(*tmpLocaleID)) {
1760                 /* If there is something else, then we add the _ */
1761                 if(len&lt;nameCapacity) {
1762                     name[len]=&#39;_&#39;;
1763                 }
1764                 ++len;
1765             }
1766         }
1767 
1768         if (_isIDSeparator(*tmpLocaleID)) {
1769             const char *cntryID;
1770             int32_t cntrySize = ulocimp_getCountry(tmpLocaleID+1,
1771                 (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len, &amp;cntryID);
1772             if (cntrySize &gt; 0) {
1773                 /* Found optional country */
1774                 tmpLocaleID = cntryID;
1775                 len+=cntrySize;
1776             }
1777             if(_isIDSeparator(*tmpLocaleID)) {
1778                 /* If there is something else, then we add the _  if we found country before. */
1779                 if (cntrySize &gt;= 0 &amp;&amp; ! _isIDSeparator(*(tmpLocaleID+1)) ) {
1780                     ++fieldCount;
1781                     if(len&lt;nameCapacity) {
1782                         name[len]=&#39;_&#39;;
1783                     }
1784                     ++len;
1785                 }
1786 
1787                 variantSize = _getVariant(tmpLocaleID+1, *tmpLocaleID,
1788                     (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len);
1789                 if (variantSize &gt; 0) {
1790                     variant = len&lt;nameCapacity ? name+len : NULL;
1791                     len += variantSize;
1792                     tmpLocaleID += variantSize + 1; /* skip &#39;_&#39; and variant */
1793                 }
1794             }
1795         }
1796     }
1797 
1798     /* Copy POSIX-style charset specifier, if any [mr.utf8] */
1799     if (!OPTION_SET(options, _ULOC_CANONICALIZE) &amp;&amp; *tmpLocaleID == &#39;.&#39;) {
1800         UBool done = FALSE;
1801         do {
1802             char c = *tmpLocaleID;
1803             switch (c) {
1804             case 0:
1805             case &#39;@&#39;:
1806                 done = TRUE;
1807                 break;
1808             default:
1809                 if (len&lt;nameCapacity) {
1810                     name[len] = c;
1811                 }
1812                 ++len;
1813                 ++tmpLocaleID;
1814                 break;
1815             }
1816         } while (!done);
1817     }
1818 
1819     /* Scan ahead to next &#39;@&#39; and determine if it is followed by &#39;=&#39; and/or &#39;;&#39;
1820        After this, tmpLocaleID either points to &#39;@&#39; or is NULL */
1821     if ((tmpLocaleID=locale_getKeywordsStart(tmpLocaleID))!=NULL) {
1822         keywordAssign = uprv_strchr(tmpLocaleID, &#39;=&#39;);
1823         separatorIndicator = uprv_strchr(tmpLocaleID, &#39;;&#39;);
1824     }
1825 
1826     /* Copy POSIX-style variant, if any [mr@FOO] */
1827     if (!OPTION_SET(options, _ULOC_CANONICALIZE) &amp;&amp;
1828         tmpLocaleID != NULL &amp;&amp; keywordAssign == NULL) {
1829         for (;;) {
1830             char c = *tmpLocaleID;
1831             if (c == 0) {
1832                 break;
1833             }
1834             if (len&lt;nameCapacity) {
1835                 name[len] = c;
1836             }
1837             ++len;
1838             ++tmpLocaleID;
1839         }
1840     }
1841 
1842     if (OPTION_SET(options, _ULOC_CANONICALIZE)) {
1843         /* Handle @FOO variant if @ is present and not followed by = */
1844         if (tmpLocaleID!=NULL &amp;&amp; keywordAssign==NULL) {
1845             int32_t posixVariantSize;
1846             /* Add missing &#39;_&#39; if needed */
1847             if (fieldCount &lt; 2 || (fieldCount &lt; 3 &amp;&amp; scriptSize &gt; 0)) {
1848                 do {
1849                     if(len&lt;nameCapacity) {
1850                         name[len]=&#39;_&#39;;
1851                     }
1852                     ++len;
1853                     ++fieldCount;
1854                 } while(fieldCount&lt;2);
1855             }
1856             posixVariantSize = _getVariantEx(tmpLocaleID+1, &#39;@&#39;, name+len, nameCapacity-len,
1857                                              (UBool)(variantSize &gt; 0));
1858             if (posixVariantSize &gt; 0) {
1859                 if (variant == NULL) {
1860                     variant = name+len;
1861                 }
1862                 len += posixVariantSize;
1863                 variantSize += posixVariantSize;
1864             }
1865         }
1866 
<a name="14" id="anc14"></a><span class="line-removed">1867         /* Handle generic variants first */</span>
<span class="line-removed">1868         if (variant) {</span>
<span class="line-removed">1869             for (j=0; j&lt;UPRV_LENGTHOF(VARIANT_MAP); j++) {</span>
<span class="line-removed">1870                 const char* variantToCompare = VARIANT_MAP[j].variant;</span>
<span class="line-removed">1871                 int32_t n = (int32_t)uprv_strlen(variantToCompare);</span>
<span class="line-removed">1872                 int32_t variantLen = _deleteVariant(variant, uprv_min(variantSize, (nameCapacity-len)), variantToCompare, n);</span>
<span class="line-removed">1873                 len -= variantLen;</span>
<span class="line-removed">1874                 if (variantLen &gt; 0) {</span>
<span class="line-removed">1875                     if (len &gt; 0 &amp;&amp; name[len-1] == &#39;_&#39;) { /* delete trailing &#39;_&#39; */</span>
<span class="line-removed">1876                         --len;</span>
<span class="line-removed">1877                     }</span>
<span class="line-removed">1878                     addKeyword = VARIANT_MAP[j].keyword;</span>
<span class="line-removed">1879                     addValue = VARIANT_MAP[j].value;</span>
<span class="line-removed">1880                     break;</span>
<span class="line-removed">1881                 }</span>
<span class="line-removed">1882             }</span>
<span class="line-removed">1883             if (len &gt; 0 &amp;&amp; len &lt;= nameCapacity &amp;&amp; name[len-1] == &#39;_&#39;) { /* delete trailing &#39;_&#39; */</span>
<span class="line-removed">1884                 --len;</span>
<span class="line-removed">1885             }</span>
<span class="line-removed">1886         }</span>
<span class="line-removed">1887 </span>
1888         /* Look up the ID in the canonicalization map */
1889         for (j=0; j&lt;UPRV_LENGTHOF(CANONICALIZE_MAP); j++) {
1890             const char* id = CANONICALIZE_MAP[j].id;
1891             int32_t n = (int32_t)uprv_strlen(id);
1892             if (len == n &amp;&amp; uprv_strncmp(name, id, n) == 0) {
1893                 if (n == 0 &amp;&amp; tmpLocaleID != NULL) {
1894                     break; /* Don&#39;t remap &quot;&quot; if keywords present */
1895                 }
1896                 len = _copyCount(name, nameCapacity, CANONICALIZE_MAP[j].canonicalID);
<a name="15" id="anc15"></a><span class="line-removed">1897                 if (CANONICALIZE_MAP[j].keyword) {</span>
<span class="line-removed">1898                     addKeyword = CANONICALIZE_MAP[j].keyword;</span>
<span class="line-removed">1899                     addValue = CANONICALIZE_MAP[j].value;</span>
<span class="line-removed">1900                 }</span>
1901                 break;
1902             }
1903         }
1904     }
1905 
1906     if (!OPTION_SET(options, _ULOC_STRIP_KEYWORDS)) {
1907         if (tmpLocaleID!=NULL &amp;&amp; keywordAssign!=NULL &amp;&amp;
1908             (!separatorIndicator || separatorIndicator &gt; keywordAssign)) {
1909             if(len&lt;nameCapacity) {
1910                 name[len]=&#39;@&#39;;
1911             }
1912             ++len;
1913             ++fieldCount;
1914             len += _getKeywords(tmpLocaleID+1, &#39;@&#39;, (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len,
<a name="16" id="anc16"></a><span class="line-modified">1915                                 NULL, 0, NULL, TRUE, addKeyword, addValue, err);</span>
<span class="line-removed">1916         } else if (addKeyword != NULL) {</span>
<span class="line-removed">1917             U_ASSERT(addValue != NULL &amp;&amp; len &lt; nameCapacity);</span>
<span class="line-removed">1918             /* inelegant but works -- later make _getKeywords do this? */</span>
<span class="line-removed">1919             len += _copyCount(name+len, nameCapacity-len, &quot;@&quot;);</span>
<span class="line-removed">1920             len += _copyCount(name+len, nameCapacity-len, addKeyword);</span>
<span class="line-removed">1921             len += _copyCount(name+len, nameCapacity-len, &quot;=&quot;);</span>
<span class="line-removed">1922             len += _copyCount(name+len, nameCapacity-len, addValue);</span>
1923         }
1924     }
1925 
1926     if (U_SUCCESS(*err) &amp;&amp; result != NULL &amp;&amp; name == localeBuffer) {
1927         uprv_strncpy(result, localeBuffer, (len &gt; resultCapacity) ? resultCapacity : len);
1928     }
1929 
1930     return u_terminateChars(result, resultCapacity, len, err);
1931 }
1932 
1933 /* ### ID parsing API **************************************************/
1934 
1935 U_CAPI int32_t  U_EXPORT2
1936 uloc_getParent(const char*    localeID,
1937                char* parent,
1938                int32_t parentCapacity,
1939                UErrorCode* err)
1940 {
1941     const char *lastUnderscore;
1942     int32_t i;
1943 
1944     if (U_FAILURE(*err))
1945         return 0;
1946 
1947     if (localeID == NULL)
1948         localeID = uloc_getDefault();
1949 
1950     lastUnderscore=uprv_strrchr(localeID, &#39;_&#39;);
1951     if(lastUnderscore!=NULL) {
1952         i=(int32_t)(lastUnderscore-localeID);
1953     } else {
1954         i=0;
1955     }
1956 
<a name="17" id="anc17"></a><span class="line-modified">1957     if(i&gt;0 &amp;&amp; parent != localeID) {</span>
<span class="line-modified">1958         uprv_memcpy(parent, localeID, uprv_min(i, parentCapacity));</span>






1959     }
<a name="18" id="anc18"></a>
1960     return u_terminateChars(parent, parentCapacity, i, err);
1961 }
1962 
1963 U_CAPI int32_t U_EXPORT2
1964 uloc_getLanguage(const char*    localeID,
1965          char* language,
1966          int32_t languageCapacity,
1967          UErrorCode* err)
1968 {
1969     /* uloc_getLanguage will return a 2 character iso-639 code if one exists. *CWB*/
1970     int32_t i=0;
1971 
1972     if (err==NULL || U_FAILURE(*err)) {
1973         return 0;
1974     }
1975 
1976     if(localeID==NULL) {
1977         localeID=uloc_getDefault();
1978     }
1979 
1980     i=ulocimp_getLanguage(localeID, language, languageCapacity, NULL);
1981     return u_terminateChars(language, languageCapacity, i, err);
1982 }
1983 
1984 U_CAPI int32_t U_EXPORT2
1985 uloc_getScript(const char*    localeID,
1986          char* script,
1987          int32_t scriptCapacity,
1988          UErrorCode* err)
1989 {
1990     int32_t i=0;
1991 
1992     if(err==NULL || U_FAILURE(*err)) {
1993         return 0;
1994     }
1995 
1996     if(localeID==NULL) {
1997         localeID=uloc_getDefault();
1998     }
1999 
2000     /* skip the language */
2001     ulocimp_getLanguage(localeID, NULL, 0, &amp;localeID);
2002     if(_isIDSeparator(*localeID)) {
2003         i=ulocimp_getScript(localeID+1, script, scriptCapacity, NULL);
2004     }
2005     return u_terminateChars(script, scriptCapacity, i, err);
2006 }
2007 
2008 U_CAPI int32_t  U_EXPORT2
2009 uloc_getCountry(const char* localeID,
2010             char* country,
2011             int32_t countryCapacity,
2012             UErrorCode* err)
2013 {
2014     int32_t i=0;
2015 
2016     if(err==NULL || U_FAILURE(*err)) {
2017         return 0;
2018     }
2019 
2020     if(localeID==NULL) {
2021         localeID=uloc_getDefault();
2022     }
2023 
2024     /* Skip the language */
2025     ulocimp_getLanguage(localeID, NULL, 0, &amp;localeID);
2026     if(_isIDSeparator(*localeID)) {
2027         const char *scriptID;
2028         /* Skip the script if available */
2029         ulocimp_getScript(localeID+1, NULL, 0, &amp;scriptID);
2030         if(scriptID != localeID+1) {
2031             /* Found optional script */
2032             localeID = scriptID;
2033         }
2034         if(_isIDSeparator(*localeID)) {
2035             i=ulocimp_getCountry(localeID+1, country, countryCapacity, NULL);
2036         }
2037     }
2038     return u_terminateChars(country, countryCapacity, i, err);
2039 }
2040 
2041 U_CAPI int32_t  U_EXPORT2
2042 uloc_getVariant(const char* localeID,
2043                 char* variant,
2044                 int32_t variantCapacity,
2045                 UErrorCode* err)
2046 {
2047     char tempBuffer[ULOC_FULLNAME_CAPACITY];
2048     const char* tmpLocaleID;
2049     int32_t i=0;
2050 
2051     if(err==NULL || U_FAILURE(*err)) {
2052         return 0;
2053     }
2054 
2055     if (_hasBCP47Extension(localeID)) {
2056         _ConvertBCP47(tmpLocaleID, localeID, tempBuffer, sizeof(tempBuffer), err);
2057     } else {
2058         if (localeID==NULL) {
2059            localeID=uloc_getDefault();
2060         }
2061         tmpLocaleID=localeID;
2062     }
2063 
2064     /* Skip the language */
2065     ulocimp_getLanguage(tmpLocaleID, NULL, 0, &amp;tmpLocaleID);
2066     if(_isIDSeparator(*tmpLocaleID)) {
2067         const char *scriptID;
2068         /* Skip the script if available */
2069         ulocimp_getScript(tmpLocaleID+1, NULL, 0, &amp;scriptID);
2070         if(scriptID != tmpLocaleID+1) {
2071             /* Found optional script */
2072             tmpLocaleID = scriptID;
2073         }
2074         /* Skip the Country */
2075         if (_isIDSeparator(*tmpLocaleID)) {
2076             const char *cntryID;
2077             ulocimp_getCountry(tmpLocaleID+1, NULL, 0, &amp;cntryID);
2078             if (cntryID != tmpLocaleID+1) {
2079                 /* Found optional country */
2080                 tmpLocaleID = cntryID;
2081             }
2082             if(_isIDSeparator(*tmpLocaleID)) {
2083                 /* If there was no country ID, skip a possible extra IDSeparator */
2084                 if (tmpLocaleID != cntryID &amp;&amp; _isIDSeparator(tmpLocaleID[1])) {
2085                     tmpLocaleID++;
2086                 }
2087                 i=_getVariant(tmpLocaleID+1, *tmpLocaleID, variant, variantCapacity);
2088             }
2089         }
2090     }
2091 
2092     /* removed by weiv. We don&#39;t want to handle POSIX variants anymore. Use canonicalization function */
2093     /* if we do not have a variant tag yet then try a POSIX variant after &#39;@&#39; */
2094 /*
2095     if(!haveVariant &amp;&amp; (localeID=uprv_strrchr(localeID, &#39;@&#39;))!=NULL) {
2096         i=_getVariant(localeID+1, &#39;@&#39;, variant, variantCapacity);
2097     }
2098 */
2099     return u_terminateChars(variant, variantCapacity, i, err);
2100 }
2101 
2102 U_CAPI int32_t  U_EXPORT2
2103 uloc_getName(const char* localeID,
2104              char* name,
2105              int32_t nameCapacity,
2106              UErrorCode* err)
2107 {
2108     return _canonicalize(localeID, name, nameCapacity, 0, err);
2109 }
2110 
2111 U_CAPI int32_t  U_EXPORT2
2112 uloc_getBaseName(const char* localeID,
2113                  char* name,
2114                  int32_t nameCapacity,
2115                  UErrorCode* err)
2116 {
2117     return _canonicalize(localeID, name, nameCapacity, _ULOC_STRIP_KEYWORDS, err);
2118 }
2119 
2120 U_CAPI int32_t  U_EXPORT2
2121 uloc_canonicalize(const char* localeID,
2122                   char* name,
2123                   int32_t nameCapacity,
2124                   UErrorCode* err)
2125 {
2126     return _canonicalize(localeID, name, nameCapacity, _ULOC_CANONICALIZE, err);
2127 }
2128 
2129 U_CAPI const char*  U_EXPORT2
2130 uloc_getISO3Language(const char* localeID)
2131 {
2132     int16_t offset;
2133     char lang[ULOC_LANG_CAPACITY];
2134     UErrorCode err = U_ZERO_ERROR;
2135 
2136     if (localeID == NULL)
2137     {
2138         localeID = uloc_getDefault();
2139     }
2140     uloc_getLanguage(localeID, lang, ULOC_LANG_CAPACITY, &amp;err);
2141     if (U_FAILURE(err))
2142         return &quot;&quot;;
2143     offset = _findIndex(LANGUAGES, lang);
2144     if (offset &lt; 0)
2145         return &quot;&quot;;
2146     return LANGUAGES_3[offset];
2147 }
2148 
2149 U_CAPI const char*  U_EXPORT2
2150 uloc_getISO3Country(const char* localeID)
2151 {
2152     int16_t offset;
2153     char cntry[ULOC_LANG_CAPACITY];
2154     UErrorCode err = U_ZERO_ERROR;
2155 
2156     if (localeID == NULL)
2157     {
2158         localeID = uloc_getDefault();
2159     }
2160     uloc_getCountry(localeID, cntry, ULOC_LANG_CAPACITY, &amp;err);
2161     if (U_FAILURE(err))
2162         return &quot;&quot;;
2163     offset = _findIndex(COUNTRIES, cntry);
2164     if (offset &lt; 0)
2165         return &quot;&quot;;
2166 
2167     return COUNTRIES_3[offset];
2168 }
2169 
2170 U_CAPI uint32_t  U_EXPORT2
2171 uloc_getLCID(const char* localeID)
2172 {
2173     UErrorCode status = U_ZERO_ERROR;
2174     char       langID[ULOC_FULLNAME_CAPACITY];
2175     uint32_t   lcid = 0;
2176 
2177     /* Check for incomplete id. */
2178     if (!localeID || uprv_strlen(localeID) &lt; 2) {
2179         return 0;
2180     }
2181 
<a name="19" id="anc19"></a><span class="line-modified">2182     // Attempt platform lookup if available</span>
<span class="line-modified">2183     lcid = uprv_convertToLCIDPlatform(localeID);</span>
<span class="line-modified">2184     if (lcid &gt; 0)</span>
<span class="line-modified">2185     {</span>



2186         // Windows found an LCID, return that
2187         return lcid;
2188     }
2189 
2190     uloc_getLanguage(localeID, langID, sizeof(langID), &amp;status);
<a name="20" id="anc20"></a><span class="line-modified">2191     if (U_FAILURE(status)) {</span>
2192         return 0;
2193     }
2194 
2195     if (uprv_strchr(localeID, &#39;@&#39;)) {
2196         // uprv_convertToLCID does not support keywords other than collation.
2197         // Remove all keywords except collation.
2198         int32_t len;
2199         char collVal[ULOC_KEYWORDS_CAPACITY];
2200         char tmpLocaleID[ULOC_FULLNAME_CAPACITY];
2201 
2202         len = uloc_getKeywordValue(localeID, &quot;collation&quot;, collVal,
2203             UPRV_LENGTHOF(collVal) - 1, &amp;status);
2204 
2205         if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
2206             collVal[len] = 0;
2207 
2208             len = uloc_getBaseName(localeID, tmpLocaleID,
2209                 UPRV_LENGTHOF(tmpLocaleID) - 1, &amp;status);
2210 
2211             if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
2212                 tmpLocaleID[len] = 0;
2213 
2214                 len = uloc_setKeywordValue(&quot;collation&quot;, collVal, tmpLocaleID,
2215                     UPRV_LENGTHOF(tmpLocaleID) - len - 1, &amp;status);
2216 
2217                 if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
2218                     tmpLocaleID[len] = 0;
2219                     return uprv_convertToLCID(langID, tmpLocaleID, &amp;status);
2220                 }
2221             }
2222         }
2223 
2224         // fall through - all keywords are simply ignored
2225         status = U_ZERO_ERROR;
2226     }
2227 
2228     return uprv_convertToLCID(langID, localeID, &amp;status);
2229 }
2230 
2231 U_CAPI int32_t U_EXPORT2
2232 uloc_getLocaleForLCID(uint32_t hostid, char *locale, int32_t localeCapacity,
2233                 UErrorCode *status)
2234 {
2235     return uprv_convertToPosix(hostid, locale, localeCapacity, status);
2236 }
2237 
2238 /* ### Default locale **************************************************/
2239 
2240 U_CAPI const char*  U_EXPORT2
2241 uloc_getDefault()
2242 {
2243     return locale_get_default();
2244 }
2245 
2246 U_CAPI void  U_EXPORT2
2247 uloc_setDefault(const char*   newDefaultLocale,
2248              UErrorCode* err)
2249 {
2250     if (U_FAILURE(*err))
2251         return;
2252     /* the error code isn&#39;t currently used for anything by this function*/
2253 
2254     /* propagate change to C++ */
2255     locale_set_default(newDefaultLocale);
2256 }
2257 
2258 /**
2259  * Returns a list of all 2-letter language codes defined in ISO 639.  This is a pointer
2260  * to an array of pointers to arrays of char.  All of these pointers are owned
2261  * by ICU-- do not delete them, and do not write through them.  The array is
2262  * terminated with a null pointer.
2263  */
2264 U_CAPI const char* const*  U_EXPORT2
2265 uloc_getISOLanguages()
2266 {
2267     return LANGUAGES;
2268 }
2269 
2270 /**
2271  * Returns a list of all 2-letter country codes defined in ISO 639.  This is a
2272  * pointer to an array of pointers to arrays of char.  All of these pointers are
2273  * owned by ICU-- do not delete them, and do not write through them.  The array is
2274  * terminated with a null pointer.
2275  */
2276 U_CAPI const char* const*  U_EXPORT2
2277 uloc_getISOCountries()
2278 {
2279     return COUNTRIES;
2280 }
2281 
2282 
2283 /* this function to be moved into cstring.c later */
2284 static char gDecimal = 0;
2285 
2286 static /* U_CAPI */
2287 double
2288 /* U_EXPORT2 */
2289 _uloc_strtod(const char *start, char **end) {
2290     char *decimal;
2291     char *myEnd;
2292     char buf[30];
2293     double rv;
2294     if (!gDecimal) {
2295         char rep[5];
2296         /* For machines that decide to change the decimal on you,
2297         and try to be too smart with localization.
2298         This normally should be just a &#39;.&#39;. */
2299         sprintf(rep, &quot;%+1.1f&quot;, 1.0);
2300         gDecimal = rep[2];
2301     }
2302 
2303     if(gDecimal == &#39;.&#39;) {
2304         return uprv_strtod(start, end); /* fall through to OS */
2305     } else {
2306         uprv_strncpy(buf, start, 29);
2307         buf[29]=0;
2308         decimal = uprv_strchr(buf, &#39;.&#39;);
2309         if(decimal) {
2310             *decimal = gDecimal;
2311         } else {
2312             return uprv_strtod(start, end); /* no decimal point */
2313         }
2314         rv = uprv_strtod(buf, &amp;myEnd);
2315         if(end) {
2316             *end = (char*)(start+(myEnd-buf)); /* cast away const (to follow uprv_strtod API.) */
2317         }
2318         return rv;
2319     }
2320 }
2321 
2322 typedef struct {
2323     float q;
2324     int32_t dummy;  /* to avoid uninitialized memory copy from qsort */
2325     char locale[ULOC_FULLNAME_CAPACITY+1];
2326 } _acceptLangItem;
2327 
2328 static int32_t U_CALLCONV
2329 uloc_acceptLanguageCompare(const void * /*context*/, const void *a, const void *b)
2330 {
2331     const _acceptLangItem *aa = (const _acceptLangItem*)a;
2332     const _acceptLangItem *bb = (const _acceptLangItem*)b;
2333 
2334     int32_t rc = 0;
2335     if(bb-&gt;q &lt; aa-&gt;q) {
2336         rc = -1;  /* A &gt; B */
2337     } else if(bb-&gt;q &gt; aa-&gt;q) {
2338         rc = 1;   /* A &lt; B */
2339     } else {
2340         rc = 0;   /* A = B */
2341     }
2342 
2343     if(rc==0) {
2344         rc = uprv_stricmp(aa-&gt;locale, bb-&gt;locale);
2345     }
2346 
2347 #if defined(ULOC_DEBUG)
2348     /*  fprintf(stderr, &quot;a:[%s:%g], b:[%s:%g] -&gt; %d\n&quot;,
2349     aa-&gt;locale, aa-&gt;q,
2350     bb-&gt;locale, bb-&gt;q,
2351     rc);*/
2352 #endif
2353 
2354     return rc;
2355 }
2356 
2357 /*
2358 mt-mt, ja;q=0.76, en-us;q=0.95, en;q=0.92, en-gb;q=0.89, fr;q=0.87, iu-ca;q=0.84, iu;q=0.82, ja-jp;q=0.79, mt;q=0.97, de-de;q=0.74, de;q=0.71, es;q=0.68, it-it;q=0.66, it;q=0.63, vi-vn;q=0.61, vi;q=0.58, nl-nl;q=0.55, nl;q=0.53
2359 */
2360 
2361 U_CAPI int32_t U_EXPORT2
2362 uloc_acceptLanguageFromHTTP(char *result, int32_t resultAvailable, UAcceptResult *outResult,
2363                             const char *httpAcceptLanguage,
2364                             UEnumeration* availableLocales,
2365                             UErrorCode *status)
2366 {
2367   MaybeStackArray&lt;_acceptLangItem, 4&gt; items; // Struct for collecting items.
2368     char tmp[ULOC_FULLNAME_CAPACITY +1];
2369     int32_t n = 0;
2370     const char *itemEnd;
2371     const char *paramEnd;
2372     const char *s;
2373     const char *t;
2374     int32_t res;
2375     int32_t i;
2376     int32_t l = (int32_t)uprv_strlen(httpAcceptLanguage);
2377 
2378     if(U_FAILURE(*status)) {
2379         return -1;
2380     }
2381 
2382     for(s=httpAcceptLanguage;s&amp;&amp;*s;) {
2383         while(isspace(*s)) /* eat space at the beginning */
2384             s++;
2385         itemEnd=uprv_strchr(s,&#39;,&#39;);
2386         paramEnd=uprv_strchr(s,&#39;;&#39;);
2387         if(!itemEnd) {
2388             itemEnd = httpAcceptLanguage+l; /* end of string */
2389         }
2390         if(paramEnd &amp;&amp; paramEnd&lt;itemEnd) {
2391             /* semicolon (;) is closer than end (,) */
2392             t = paramEnd+1;
2393             if(*t==&#39;q&#39;) {
2394                 t++;
2395             }
2396             while(isspace(*t)) {
2397                 t++;
2398             }
2399             if(*t==&#39;=&#39;) {
2400                 t++;
2401             }
2402             while(isspace(*t)) {
2403                 t++;
2404             }
2405             items[n].q = (float)_uloc_strtod(t,NULL);
2406         } else {
2407             /* no semicolon - it&#39;s 1.0 */
2408             items[n].q = 1.0f;
2409             paramEnd = itemEnd;
2410         }
2411         items[n].dummy=0;
2412         /* eat spaces prior to semi */
2413         for(t=(paramEnd-1);(paramEnd&gt;s)&amp;&amp;isspace(*t);t--)
2414             ;
<a name="21" id="anc21"></a><span class="line-modified">2415         int32_t slen = ((t+1)-s);</span>
2416         if(slen &gt; ULOC_FULLNAME_CAPACITY) {
2417           *status = U_BUFFER_OVERFLOW_ERROR;
2418           return -1; // too big
2419         }
2420         uprv_strncpy(items[n].locale, s, slen);
2421         items[n].locale[slen]=0; // terminate
2422         int32_t clen = uloc_canonicalize(items[n].locale, tmp, UPRV_LENGTHOF(tmp)-1, status);
2423         if(U_FAILURE(*status)) return -1;
2424         if((clen!=slen) || (uprv_strncmp(items[n].locale, tmp, slen))) {
2425             // canonicalization had an effect- copy back
2426             uprv_strncpy(items[n].locale, tmp, clen);
2427             items[n].locale[clen] = 0; // terminate
2428         }
2429 #if defined(ULOC_DEBUG)
2430         /*fprintf(stderr,&quot;%d: s &lt;%s&gt; q &lt;%g&gt;\n&quot;, n, j[n].locale, j[n].q);*/
2431 #endif
2432         n++;
2433         s = itemEnd;
2434         while(*s==&#39;,&#39;) { /* eat duplicate commas */
2435             s++;
2436         }
2437         if(n&gt;=items.getCapacity()) { // If we need more items
2438           if(NULL == items.resize(items.getCapacity()*2, items.getCapacity())) {
2439               *status = U_MEMORY_ALLOCATION_ERROR;
2440               return -1;
2441           }
2442 #if defined(ULOC_DEBUG)
2443           fprintf(stderr,&quot;malloced at size %d\n&quot;, items.getCapacity());
2444 #endif
2445         }
2446     }
2447     uprv_sortArray(items.getAlias(), n, sizeof(items[0]), uloc_acceptLanguageCompare, NULL, TRUE, status);
2448     if (U_FAILURE(*status)) {
2449         return -1;
2450     }
2451     LocalMemory&lt;const char*&gt; strs(NULL);
2452     if (strs.allocateInsteadAndReset(n) == NULL) {
2453         *status = U_MEMORY_ALLOCATION_ERROR;
2454         return -1;
2455     }
2456     for(i=0;i&lt;n;i++) {
2457 #if defined(ULOC_DEBUG)
2458         /*fprintf(stderr,&quot;%d: s &lt;%s&gt; q &lt;%g&gt;\n&quot;, i, j[i].locale, j[i].q);*/
2459 #endif
2460         strs[i]=items[i].locale;
2461     }
2462     res =  uloc_acceptLanguage(result, resultAvailable, outResult,
2463                                strs.getAlias(), n, availableLocales, status);
2464     return res;
2465 }
2466 
2467 
2468 U_CAPI int32_t U_EXPORT2
2469 uloc_acceptLanguage(char *result, int32_t resultAvailable,
2470                     UAcceptResult *outResult, const char **acceptList,
2471                     int32_t acceptListCount,
2472                     UEnumeration* availableLocales,
2473                     UErrorCode *status)
2474 {
2475     int32_t i,j;
2476     int32_t len;
2477     int32_t maxLen=0;
2478     char tmp[ULOC_FULLNAME_CAPACITY+1];
2479     const char *l;
2480     char **fallbackList;
2481     if(U_FAILURE(*status)) {
2482         return -1;
2483     }
2484     fallbackList = static_cast&lt;char **&gt;(uprv_malloc((size_t)(sizeof(fallbackList[0])*acceptListCount)));
2485     if(fallbackList==NULL) {
2486         *status = U_MEMORY_ALLOCATION_ERROR;
2487         return -1;
2488     }
2489     for(i=0;i&lt;acceptListCount;i++) {
2490 #if defined(ULOC_DEBUG)
2491         fprintf(stderr,&quot;%02d: %s\n&quot;, i, acceptList[i]);
2492 #endif
2493         while((l=uenum_next(availableLocales, NULL, status)) != NULL) {
2494 #if defined(ULOC_DEBUG)
2495             fprintf(stderr,&quot;  %s\n&quot;, l);
2496 #endif
2497             len = (int32_t)uprv_strlen(l);
2498             if(!uprv_strcmp(acceptList[i], l)) {
2499                 if(outResult) {
2500                     *outResult = ULOC_ACCEPT_VALID;
2501                 }
2502 #if defined(ULOC_DEBUG)
2503                 fprintf(stderr, &quot;MATCH! %s\n&quot;, l);
2504 #endif
2505                 if(len&gt;0) {
2506                     uprv_strncpy(result, l, uprv_min(len, resultAvailable));
2507                 }
2508                 for(j=0;j&lt;i;j++) {
2509                     uprv_free(fallbackList[j]);
2510                 }
2511                 uprv_free(fallbackList);
2512                 return u_terminateChars(result, resultAvailable, len, status);
2513             }
2514             if(len&gt;maxLen) {
2515                 maxLen = len;
2516             }
2517         }
2518         uenum_reset(availableLocales, status);
2519         /* save off parent info */
2520         if(uloc_getParent(acceptList[i], tmp, UPRV_LENGTHOF(tmp), status)!=0) {
2521             fallbackList[i] = uprv_strdup(tmp);
2522         } else {
2523             fallbackList[i]=0;
2524         }
2525     }
2526 
2527     for(maxLen--;maxLen&gt;0;maxLen--) {
2528         for(i=0;i&lt;acceptListCount;i++) {
2529             if(fallbackList[i] &amp;&amp; ((int32_t)uprv_strlen(fallbackList[i])==maxLen)) {
2530 #if defined(ULOC_DEBUG)
2531                 fprintf(stderr,&quot;Try: [%s]&quot;, fallbackList[i]);
2532 #endif
2533                 while((l=uenum_next(availableLocales, NULL, status)) != NULL) {
2534 #if defined(ULOC_DEBUG)
2535                     fprintf(stderr,&quot;  %s\n&quot;, l);
2536 #endif
2537                     len = (int32_t)uprv_strlen(l);
2538                     if(!uprv_strcmp(fallbackList[i], l)) {
2539                         if(outResult) {
2540                             *outResult = ULOC_ACCEPT_FALLBACK;
2541                         }
2542 #if defined(ULOC_DEBUG)
2543                         fprintf(stderr, &quot;fallback MATCH! %s\n&quot;, l);
2544 #endif
2545                         if(len&gt;0) {
2546                             uprv_strncpy(result, l, uprv_min(len, resultAvailable));
2547                         }
2548                         for(j=0;j&lt;acceptListCount;j++) {
2549                             uprv_free(fallbackList[j]);
2550                         }
2551                         uprv_free(fallbackList);
2552                         return u_terminateChars(result, resultAvailable, len, status);
2553                     }
2554                 }
2555                 uenum_reset(availableLocales, status);
2556 
2557                 if(uloc_getParent(fallbackList[i], tmp, UPRV_LENGTHOF(tmp), status)!=0) {
2558                     uprv_free(fallbackList[i]);
2559                     fallbackList[i] = uprv_strdup(tmp);
2560                 } else {
2561                     uprv_free(fallbackList[i]);
2562                     fallbackList[i]=0;
2563                 }
2564             }
2565         }
2566         if(outResult) {
2567             *outResult = ULOC_ACCEPT_FAILED;
2568         }
2569     }
2570     for(i=0;i&lt;acceptListCount;i++) {
2571         uprv_free(fallbackList[i]);
2572     }
2573     uprv_free(fallbackList);
2574     return -1;
2575 }
2576 
2577 U_CAPI const char* U_EXPORT2
2578 uloc_toUnicodeLocaleKey(const char* keyword)
2579 {
2580     const char* bcpKey = ulocimp_toBcpKey(keyword);
2581     if (bcpKey == NULL &amp;&amp; ultag_isUnicodeLocaleKey(keyword, -1)) {
2582         // unknown keyword, but syntax is fine..
2583         return keyword;
2584     }
2585     return bcpKey;
2586 }
2587 
2588 U_CAPI const char* U_EXPORT2
2589 uloc_toUnicodeLocaleType(const char* keyword, const char* value)
2590 {
2591     const char* bcpType = ulocimp_toBcpType(keyword, value, NULL, NULL);
2592     if (bcpType == NULL &amp;&amp; ultag_isUnicodeLocaleType(value, -1)) {
2593         // unknown keyword, but syntax is fine..
2594         return value;
2595     }
2596     return bcpType;
2597 }
2598 
2599 static UBool
2600 isWellFormedLegacyKey(const char* legacyKey)
2601 {
2602     const char* p = legacyKey;
2603     while (*p) {
2604         if (!UPRV_ISALPHANUM(*p)) {
2605             return FALSE;
2606         }
2607         p++;
2608     }
2609     return TRUE;
2610 }
2611 
2612 static UBool
2613 isWellFormedLegacyType(const char* legacyType)
2614 {
2615     const char* p = legacyType;
2616     int32_t alphaNumLen = 0;
2617     while (*p) {
2618         if (*p == &#39;_&#39; || *p == &#39;/&#39; || *p == &#39;-&#39;) {
2619             if (alphaNumLen == 0) {
2620                 return FALSE;
2621             }
2622             alphaNumLen = 0;
2623         } else if (UPRV_ISALPHANUM(*p)) {
2624             alphaNumLen++;
2625         } else {
2626             return FALSE;
2627         }
2628         p++;
2629     }
2630     return (alphaNumLen != 0);
2631 }
2632 
2633 U_CAPI const char* U_EXPORT2
2634 uloc_toLegacyKey(const char* keyword)
2635 {
2636     const char* legacyKey = ulocimp_toLegacyKey(keyword);
2637     if (legacyKey == NULL) {
2638         // Checks if the specified locale key is well-formed with the legacy locale syntax.
2639         //
2640         // Note:
2641         //  LDML/CLDR provides some definition of keyword syntax in
2642         //  * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier and
2643         //  * http://www.unicode.org/reports/tr35/#Old_Locale_Extension_Syntax
2644         //  Keys can only consist of [0-9a-zA-Z].
2645         if (isWellFormedLegacyKey(keyword)) {
2646             return keyword;
2647         }
2648     }
2649     return legacyKey;
2650 }
2651 
2652 U_CAPI const char* U_EXPORT2
2653 uloc_toLegacyType(const char* keyword, const char* value)
2654 {
2655     const char* legacyType = ulocimp_toLegacyType(keyword, value, NULL, NULL);
2656     if (legacyType == NULL) {
2657         // Checks if the specified locale type is well-formed with the legacy locale syntax.
2658         //
2659         // Note:
2660         //  LDML/CLDR provides some definition of keyword syntax in
2661         //  * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier and
2662         //  * http://www.unicode.org/reports/tr35/#Old_Locale_Extension_Syntax
2663         //  Values (types) can only consist of [0-9a-zA-Z], plus for legacy values
2664         //  we allow [/_-+] in the middle (e.g. &quot;Etc/GMT+1&quot;, &quot;Asia/Tel_Aviv&quot;)
2665         if (isWellFormedLegacyType(value)) {
2666             return value;
2667         }
2668     }
2669     return legacyType;
2670 }
2671 
2672 /*eof*/
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>