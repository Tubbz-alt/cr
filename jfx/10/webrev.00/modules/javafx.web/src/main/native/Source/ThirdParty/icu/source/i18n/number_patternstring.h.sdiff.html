<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_patternstring.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_patternstring.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_rounding.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_patternstring.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 81     UnicodeString getString(int32_t flags) const U_OVERRIDE;
 82 
 83     bool positiveHasPlusSign() const U_OVERRIDE;
 84 
 85     bool hasNegativeSubpattern() const U_OVERRIDE;
 86 
 87     bool negativeHasMinusSign() const U_OVERRIDE;
 88 
 89     bool hasCurrencySign() const U_OVERRIDE;
 90 
 91     bool containsSymbolType(AffixPatternType type, UErrorCode&amp; status) const U_OVERRIDE;
 92 
 93     bool hasBody() const U_OVERRIDE;
 94 
 95   private:
 96     struct U_I18N_API ParserState {
 97         const UnicodeString&amp; pattern; // reference to the parent
 98         int32_t offset = 0;
 99 
100         explicit ParserState(const UnicodeString&amp; _pattern)
<span class="line-modified">101                 : pattern(_pattern) {};</span>
102 
103         ParserState&amp; operator=(ParserState&amp;&amp; src) U_NOEXCEPT {
104             // Leave pattern reference alone; it will continue to point to the same place in memory,
105             // which gets overwritten by ParsedPatternInfo&#39;s implicit move assignment.
106             offset = src.offset;
107             return *this;
108         }
109 
110         UChar32 peek();
111 
112         UChar32 next();
113 
114         // TODO: We don&#39;t currently do anything with the message string.
115         // This method is here as a shell for Java compatibility.
116         inline void toParseException(const char16_t* message) { (void) message; }
117     } state;
118 
119     // NOTE: In Java, these are written as pure functions.
120     // In C++, they&#39;re written as methods.
121     // The behavior is the same.
</pre>
<hr />
<pre>
205      * @throws IllegalArgumentException
206      *             If there was a syntax error in the pattern string.
207      */
208     static void parseToExistingProperties(const UnicodeString&amp; pattern,
209                                           DecimalFormatProperties&amp; properties,
210                                           IgnoreRounding ignoreRounding, UErrorCode&amp; status);
211 
212   private:
213     static void parseToExistingPropertiesImpl(const UnicodeString&amp; pattern,
214                                               DecimalFormatProperties&amp; properties,
215                                               IgnoreRounding ignoreRounding, UErrorCode&amp; status);
216 
217     /** Finalizes the temporary data stored in the ParsedPatternInfo to the Properties. */
218     static void patternInfoToProperties(DecimalFormatProperties&amp; properties,
219                                         ParsedPatternInfo&amp; patternInfo, IgnoreRounding _ignoreRounding,
220                                         UErrorCode&amp; status);
221 };
222 
223 class U_I18N_API PatternStringUtils {
224   public:






















225     /**
226      * Creates a pattern string from a property bag.
227      *
228      * &lt;p&gt;
229      * Since pattern strings support only a subset of the functionality available in a property bag, a new property bag
230      * created from the string returned by this function may not be the same as the original property bag.
231      *
232      * @param properties
233      *            The property bag to serialize.
234      * @return A pattern string approximately serializing the property bag.
235      */
236     static UnicodeString propertiesToPatternString(const DecimalFormatProperties&amp; properties,
237                                                    UErrorCode&amp; status);
238 
239 
240     /**
241      * Converts a pattern between standard notation and localized notation. Localized notation means that instead of
242      * using generic placeholders in the pattern, you use the corresponding locale-specific characters instead. For
243      * example, in locale &lt;em&gt;fr-FR&lt;/em&gt;, the period in the pattern &quot;0.000&quot; means &quot;decimal&quot; in standard notation (as it
244      * does in every other locale), but it means &quot;grouping&quot; in localized notation.
</pre>
</td>
<td>
<hr />
<pre>
 81     UnicodeString getString(int32_t flags) const U_OVERRIDE;
 82 
 83     bool positiveHasPlusSign() const U_OVERRIDE;
 84 
 85     bool hasNegativeSubpattern() const U_OVERRIDE;
 86 
 87     bool negativeHasMinusSign() const U_OVERRIDE;
 88 
 89     bool hasCurrencySign() const U_OVERRIDE;
 90 
 91     bool containsSymbolType(AffixPatternType type, UErrorCode&amp; status) const U_OVERRIDE;
 92 
 93     bool hasBody() const U_OVERRIDE;
 94 
 95   private:
 96     struct U_I18N_API ParserState {
 97         const UnicodeString&amp; pattern; // reference to the parent
 98         int32_t offset = 0;
 99 
100         explicit ParserState(const UnicodeString&amp; _pattern)
<span class="line-modified">101                 : pattern(_pattern) {}</span>
102 
103         ParserState&amp; operator=(ParserState&amp;&amp; src) U_NOEXCEPT {
104             // Leave pattern reference alone; it will continue to point to the same place in memory,
105             // which gets overwritten by ParsedPatternInfo&#39;s implicit move assignment.
106             offset = src.offset;
107             return *this;
108         }
109 
110         UChar32 peek();
111 
112         UChar32 next();
113 
114         // TODO: We don&#39;t currently do anything with the message string.
115         // This method is here as a shell for Java compatibility.
116         inline void toParseException(const char16_t* message) { (void) message; }
117     } state;
118 
119     // NOTE: In Java, these are written as pure functions.
120     // In C++, they&#39;re written as methods.
121     // The behavior is the same.
</pre>
<hr />
<pre>
205      * @throws IllegalArgumentException
206      *             If there was a syntax error in the pattern string.
207      */
208     static void parseToExistingProperties(const UnicodeString&amp; pattern,
209                                           DecimalFormatProperties&amp; properties,
210                                           IgnoreRounding ignoreRounding, UErrorCode&amp; status);
211 
212   private:
213     static void parseToExistingPropertiesImpl(const UnicodeString&amp; pattern,
214                                               DecimalFormatProperties&amp; properties,
215                                               IgnoreRounding ignoreRounding, UErrorCode&amp; status);
216 
217     /** Finalizes the temporary data stored in the ParsedPatternInfo to the Properties. */
218     static void patternInfoToProperties(DecimalFormatProperties&amp; properties,
219                                         ParsedPatternInfo&amp; patternInfo, IgnoreRounding _ignoreRounding,
220                                         UErrorCode&amp; status);
221 };
222 
223 class U_I18N_API PatternStringUtils {
224   public:
<span class="line-added">225     /**</span>
<span class="line-added">226      * Determine whether a given roundingIncrement should be ignored for formatting</span>
<span class="line-added">227      * based on the current maxFrac value (maximum fraction digits). For example a</span>
<span class="line-added">228      * roundingIncrement of 0.01 should be ignored if maxFrac is 1, but not if maxFrac</span>
<span class="line-added">229      * is 2 or more. Note that roundingIncrements are rounded up in significance, so</span>
<span class="line-added">230      * a roundingIncrement of 0.006 is treated like 0.01 for this determination, i.e.</span>
<span class="line-added">231      * it should not be ignored if maxFrac is 2 or more (but a roundingIncrement of</span>
<span class="line-added">232      * 0.005 is treated like 0.001 for significance).</span>
<span class="line-added">233      *</span>
<span class="line-added">234      * This test is needed for both NumberPropertyMapper::oldToNew and</span>
<span class="line-added">235      * PatternStringUtils::propertiesToPatternString. In Java it cannot be</span>
<span class="line-added">236      * exported by NumberPropertyMapper (package provate) so it is in</span>
<span class="line-added">237      * PatternStringUtils, do the same in C.</span>
<span class="line-added">238      *</span>
<span class="line-added">239      * @param roundIncr</span>
<span class="line-added">240      *            The roundingIncrement to be checked. Must be non-zero.</span>
<span class="line-added">241      * @param maxFrac</span>
<span class="line-added">242      *            The current maximum fraction digits value.</span>
<span class="line-added">243      * @return true if roundIncr should be ignored for formatting.</span>
<span class="line-added">244      */</span>
<span class="line-added">245      static bool ignoreRoundingIncrement(double roundIncr, int32_t maxFrac);</span>
<span class="line-added">246 </span>
247     /**
248      * Creates a pattern string from a property bag.
249      *
250      * &lt;p&gt;
251      * Since pattern strings support only a subset of the functionality available in a property bag, a new property bag
252      * created from the string returned by this function may not be the same as the original property bag.
253      *
254      * @param properties
255      *            The property bag to serialize.
256      * @return A pattern string approximately serializing the property bag.
257      */
258     static UnicodeString propertiesToPatternString(const DecimalFormatProperties&amp; properties,
259                                                    UErrorCode&amp; status);
260 
261 
262     /**
263      * Converts a pattern between standard notation and localized notation. Localized notation means that instead of
264      * using generic placeholders in the pattern, you use the corresponding locale-specific characters instead. For
265      * example, in locale &lt;em&gt;fr-FR&lt;/em&gt;, the period in the pattern &quot;0.000&quot; means &quot;decimal&quot; in standard notation (as it
266      * does in every other locale), but it means &quot;grouping&quot; in localized notation.
</pre>
</td>
</tr>
</table>
<center><a href="number_patternstring.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_rounding.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>