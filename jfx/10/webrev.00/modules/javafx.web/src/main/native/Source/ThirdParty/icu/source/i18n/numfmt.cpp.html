<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 1997-2015, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 *******************************************************************************
   8 *
   9 * File NUMFMT.CPP
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   02/19/97    aliu        Converted from java.
  15 *   03/18/97    clhuang     Implemented with C++ APIs.
  16 *   04/17/97    aliu        Enlarged MAX_INTEGER_DIGITS to fully accomodate the
  17 *                           largest double, by default.
  18 *                           Changed DigitCount to int per code review.
  19 *    07/20/98    stephen        Changed operator== to check for grouping
  20 *                            Changed setMaxIntegerDigits per Java implementation.
  21 *                            Changed setMinIntegerDigits per Java implementation.
  22 *                            Changed setMinFractionDigits per Java implementation.
  23 *                            Changed setMaxFractionDigits per Java implementation.
  24 ********************************************************************************
  25 */
  26 
  27 #include &quot;unicode/utypes.h&quot;
  28 
  29 #if !UCONFIG_NO_FORMATTING
  30 
  31 #include &quot;unicode/numfmt.h&quot;
  32 #include &quot;unicode/locid.h&quot;
  33 #include &quot;unicode/dcfmtsym.h&quot;
  34 #include &quot;unicode/decimfmt.h&quot;
  35 #include &quot;unicode/ustring.h&quot;
  36 #include &quot;unicode/ucurr.h&quot;
  37 #include &quot;unicode/curramt.h&quot;
  38 #include &quot;unicode/numsys.h&quot;
  39 #include &quot;unicode/rbnf.h&quot;
  40 #include &quot;unicode/localpointer.h&quot;
  41 #include &quot;unicode/udisplaycontext.h&quot;
  42 #include &quot;charstr.h&quot;
  43 #include &quot;winnmfmt.h&quot;
  44 #include &quot;uresimp.h&quot;
  45 #include &quot;uhash.h&quot;
  46 #include &quot;cmemory.h&quot;
  47 #include &quot;servloc.h&quot;
  48 #include &quot;ucln_in.h&quot;
  49 #include &quot;cstring.h&quot;
  50 #include &quot;putilimp.h&quot;
  51 #include &quot;uassert.h&quot;
  52 #include &quot;umutex.h&quot;
  53 #include &quot;mutex.h&quot;
  54 #include &lt;float.h&gt;
  55 #include &quot;sharednumberformat.h&quot;
  56 #include &quot;unifiedcache.h&quot;
  57 #include &quot;number_decimalquantity.h&quot;
  58 #include &quot;number_utils.h&quot;
  59 
  60 //#define FMT_DEBUG
  61 
  62 #ifdef FMT_DEBUG
  63 #include &lt;stdio.h&gt;
  64 static inline void debugout(UnicodeString s) {
  65     char buf[2000];
  66     s.extract((int32_t) 0, s.length(), buf);
  67     printf(&quot;%s&quot;, buf);
  68 }
  69 #define debug(x) printf(&quot;%s&quot;, x);
  70 #else
  71 #define debugout(x)
  72 #define debug(x)
  73 #endif
  74 
  75 // If no number pattern can be located for a locale, this is the last
  76 // resort. The patterns are same as the ones in root locale.
  77 static const UChar gLastResortDecimalPat[] = {
  78     0x23, 0x2C, 0x23, 0x23, 0x30, 0x2E, 0x23, 0x23, 0x23, 0 /* &quot;#,##0.###&quot; */
  79 };
  80 static const UChar gLastResortCurrencyPat[] = {
  81     0xA4, 0xA0, 0x23, 0x2C, 0x23, 0x23, 0x30, 0x2E, 0x30, 0x30, 0 /* &quot;\u00A4\u00A0#,##0.00&quot; */
  82 };
  83 static const UChar gLastResortPercentPat[] = {
  84     0x23, 0x2C, 0x23, 0x23, 0x30, 0x25, 0 /* &quot;#,##0%&quot; */
  85 };
  86 static const UChar gLastResortScientificPat[] = {
  87     0x23, 0x45, 0x30, 0 /* &quot;#E0&quot; */
  88 };
  89 static const UChar gLastResortIsoCurrencyPat[] = {
  90     0xA4, 0xA4, 0xA0, 0x23, 0x2C, 0x23, 0x23, 0x30, 0x2E, 0x30, 0x30, 0  /* &quot;\u00A4\u00A4\u00A0#,##0.00&quot; */
  91 };
  92 static const UChar gLastResortPluralCurrencyPat[] = {
  93     0x23, 0x2C, 0x23, 0x23, 0x30, 0x2E, 0x23, 0x23, 0x23, 0x20, 0xA4, 0xA4, 0xA4, 0 /* &quot;#,##0.### \u00A4\u00A4\u00A4*/
  94 };
  95 static const UChar gLastResortAccountingCurrencyPat[] =  {
  96     0xA4, 0xA0, 0x23, 0x2C, 0x23, 0x23, 0x30, 0x2E, 0x30, 0x30, 0 /* &quot;\u00A4\u00A0#,##0.00&quot; */
  97 };
  98 
  99 static const UChar gSingleCurrencySign[] = {0xA4, 0};
 100 static const UChar gDoubleCurrencySign[] = {0xA4, 0xA4, 0};
 101 
 102 static const UChar gSlash = 0x2f;
 103 
 104 // If the maximum base 10 exponent were 4, then the largest number would
 105 // be 99,999 which has 5 digits.
 106 // On IEEE754 systems gMaxIntegerDigits is 308 + possible denormalized 15 digits + rounding digit
 107 // With big decimal, the max exponent is 999,999,999 and the max number of digits is the same, 999,999,999
 108 const int32_t icu::NumberFormat::gDefaultMaxIntegerDigits = 2000000000;
 109 const int32_t icu::NumberFormat::gDefaultMinIntegerDigits = 127;
 110 
 111 static const UChar * const gLastResortNumberPatterns[UNUM_FORMAT_STYLE_COUNT] = {
 112     NULL,  // UNUM_PATTERN_DECIMAL
 113     gLastResortDecimalPat,  // UNUM_DECIMAL
 114     gLastResortCurrencyPat,  // UNUM_CURRENCY
 115     gLastResortPercentPat,  // UNUM_PERCENT
 116     gLastResortScientificPat,  // UNUM_SCIENTIFIC
 117     NULL,  // UNUM_SPELLOUT
 118     NULL,  // UNUM_ORDINAL
 119     NULL,  // UNUM_DURATION
 120     NULL,  // UNUM_NUMBERING_SYSTEM
 121     NULL,  // UNUM_PATTERN_RULEBASED
 122     gLastResortIsoCurrencyPat,  // UNUM_CURRENCY_ISO
 123     gLastResortPluralCurrencyPat,  // UNUM_CURRENCY_PLURAL
 124     gLastResortAccountingCurrencyPat, // UNUM_CURRENCY_ACCOUNTING
 125     gLastResortCurrencyPat,  // UNUM_CASH_CURRENCY
 126     NULL,  // UNUM_DECIMAL_COMPACT_SHORT
 127     NULL,  // UNUM_DECIMAL_COMPACT_LONG
 128     gLastResortCurrencyPat,  // UNUM_CURRENCY_STANDARD
 129 };
 130 
 131 // Keys used for accessing resource bundles
 132 
 133 static const icu::number::impl::CldrPatternStyle gFormatCldrStyles[UNUM_FORMAT_STYLE_COUNT] = {
 134     /* NULL */ icu::number::impl::CLDR_PATTERN_STYLE_COUNT,  // UNUM_PATTERN_DECIMAL
 135     icu::number::impl::CLDR_PATTERN_STYLE_DECIMAL,  // UNUM_DECIMAL
 136     icu::number::impl::CLDR_PATTERN_STYLE_CURRENCY,  // UNUM_CURRENCY
 137     icu::number::impl::CLDR_PATTERN_STYLE_PERCENT,  // UNUM_PERCENT
 138     icu::number::impl::CLDR_PATTERN_STYLE_SCIENTIFIC,  // UNUM_SCIENTIFIC
 139     /* NULL */ icu::number::impl::CLDR_PATTERN_STYLE_COUNT,  // UNUM_SPELLOUT
 140     /* NULL */ icu::number::impl::CLDR_PATTERN_STYLE_COUNT,  // UNUM_ORDINAL
 141     /* NULL */ icu::number::impl::CLDR_PATTERN_STYLE_COUNT,  // UNUM_DURATION
 142     /* NULL */ icu::number::impl::CLDR_PATTERN_STYLE_COUNT,  // UNUM_NUMBERING_SYSTEM
 143     /* NULL */ icu::number::impl::CLDR_PATTERN_STYLE_COUNT,  // UNUM_PATTERN_RULEBASED
 144     // For UNUM_CURRENCY_ISO and UNUM_CURRENCY_PLURAL,
 145     // the pattern is the same as the pattern of UNUM_CURRENCY
 146     // except for replacing the single currency sign with
 147     // double currency sign or triple currency sign.
 148     icu::number::impl::CLDR_PATTERN_STYLE_CURRENCY,  // UNUM_CURRENCY_ISO
 149     icu::number::impl::CLDR_PATTERN_STYLE_CURRENCY,  // UNUM_CURRENCY_PLURAL
 150     icu::number::impl::CLDR_PATTERN_STYLE_ACCOUNTING,  // UNUM_CURRENCY_ACCOUNTING
 151     icu::number::impl::CLDR_PATTERN_STYLE_CURRENCY,  // UNUM_CASH_CURRENCY
 152     /* NULL */ icu::number::impl::CLDR_PATTERN_STYLE_COUNT,  // UNUM_DECIMAL_COMPACT_SHORT
 153     /* NULL */ icu::number::impl::CLDR_PATTERN_STYLE_COUNT,  // UNUM_DECIMAL_COMPACT_LONG
 154     icu::number::impl::CLDR_PATTERN_STYLE_CURRENCY,  // UNUM_CURRENCY_STANDARD
 155 };
 156 
 157 // Static hashtable cache of NumberingSystem objects used by NumberFormat
 158 static UHashtable * NumberingSystem_cache = NULL;
 159 static icu::UInitOnce gNSCacheInitOnce = U_INITONCE_INITIALIZER;
 160 
 161 #if !UCONFIG_NO_SERVICE
 162 static icu::ICULocaleService* gService = NULL;
 163 static icu::UInitOnce gServiceInitOnce = U_INITONCE_INITIALIZER;
 164 #endif
 165 
 166 /**
 167  * Release all static memory held by Number Format.
 168  */
 169 U_CDECL_BEGIN
 170 static void U_CALLCONV
 171 deleteNumberingSystem(void *obj) {
 172     delete (icu::NumberingSystem *)obj;
 173 }
 174 
 175 static UBool U_CALLCONV numfmt_cleanup(void) {
 176 #if !UCONFIG_NO_SERVICE
 177     gServiceInitOnce.reset();
 178     if (gService) {
 179         delete gService;
 180         gService = NULL;
 181     }
 182 #endif
 183     gNSCacheInitOnce.reset();
 184     if (NumberingSystem_cache) {
 185         // delete NumberingSystem_cache;
 186         uhash_close(NumberingSystem_cache);
 187         NumberingSystem_cache = NULL;
 188     }
 189     return TRUE;
 190 }
 191 U_CDECL_END
 192 
 193 // *****************************************************************************
 194 // class NumberFormat
 195 // *****************************************************************************
 196 
 197 U_NAMESPACE_BEGIN
 198 
 199 UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(NumberFormat)
 200 
 201 #if !UCONFIG_NO_SERVICE
 202 // -------------------------------------
 203 // SimpleNumberFormatFactory implementation
 204 NumberFormatFactory::~NumberFormatFactory() {}
 205 SimpleNumberFormatFactory::SimpleNumberFormatFactory(const Locale&amp; locale, UBool visible)
 206     : _visible(visible)
 207 {
 208     LocaleUtility::initNameFromLocale(locale, _id);
 209 }
 210 
 211 SimpleNumberFormatFactory::~SimpleNumberFormatFactory() {}
 212 
 213 UBool SimpleNumberFormatFactory::visible(void) const {
 214     return _visible;
 215 }
 216 
 217 const UnicodeString *
 218 SimpleNumberFormatFactory::getSupportedIDs(int32_t &amp;count, UErrorCode&amp; status) const
 219 {
 220     if (U_SUCCESS(status)) {
 221         count = 1;
 222         return &amp;_id;
 223     }
 224     count = 0;
 225     return NULL;
 226 }
 227 #endif /* #if !UCONFIG_NO_SERVICE */
 228 
 229 // -------------------------------------
 230 // default constructor
 231 NumberFormat::NumberFormat()
 232 :   fGroupingUsed(TRUE),
 233     fMaxIntegerDigits(gDefaultMaxIntegerDigits),
 234     fMinIntegerDigits(1),
 235     fMaxFractionDigits(3), // invariant, &gt;= minFractionDigits
 236     fMinFractionDigits(0),
 237     fParseIntegerOnly(FALSE),
 238     fLenient(FALSE),
 239     fCapitalizationContext(UDISPCTX_CAPITALIZATION_NONE)
 240 {
 241     fCurrency[0] = 0;
 242 }
 243 
 244 // -------------------------------------
 245 
 246 NumberFormat::~NumberFormat()
 247 {
 248 }
 249 
 250 SharedNumberFormat::~SharedNumberFormat() {
 251     delete ptr;
 252 }
 253 
 254 // -------------------------------------
 255 // copy constructor
 256 
 257 NumberFormat::NumberFormat(const NumberFormat &amp;source)
 258 :   Format(source)
 259 {
 260     *this = source;
 261 }
 262 
 263 // -------------------------------------
 264 // assignment operator
 265 
 266 NumberFormat&amp;
 267 NumberFormat::operator=(const NumberFormat&amp; rhs)
 268 {
 269     if (this != &amp;rhs)
 270     {
 271         Format::operator=(rhs);
 272         fGroupingUsed = rhs.fGroupingUsed;
 273         fMaxIntegerDigits = rhs.fMaxIntegerDigits;
 274         fMinIntegerDigits = rhs.fMinIntegerDigits;
 275         fMaxFractionDigits = rhs.fMaxFractionDigits;
 276         fMinFractionDigits = rhs.fMinFractionDigits;
 277         fParseIntegerOnly = rhs.fParseIntegerOnly;
 278         u_strncpy(fCurrency, rhs.fCurrency, 3);
 279         fCurrency[3] = 0;
 280         fLenient = rhs.fLenient;
 281         fCapitalizationContext = rhs.fCapitalizationContext;
 282     }
 283     return *this;
 284 }
 285 
 286 // -------------------------------------
 287 
 288 UBool
 289 NumberFormat::operator==(const Format&amp; that) const
 290 {
 291     // Format::operator== guarantees this cast is safe
 292     NumberFormat* other = (NumberFormat*)&amp;that;
 293 
 294 #ifdef FMT_DEBUG
 295     // This code makes it easy to determine why two format objects that should
 296     // be equal aren&#39;t.
 297     UBool first = TRUE;
 298     if (!Format::operator==(that)) {
 299         if (first) { printf(&quot;[ &quot;); first = FALSE; } else { printf(&quot;, &quot;); }
 300         debug(&quot;Format::!=&quot;);
 301     }
 302     if (!(fMaxIntegerDigits == other-&gt;fMaxIntegerDigits &amp;&amp;
 303           fMinIntegerDigits == other-&gt;fMinIntegerDigits)) {
 304         if (first) { printf(&quot;[ &quot;); first = FALSE; } else { printf(&quot;, &quot;); }
 305         debug(&quot;Integer digits !=&quot;);
 306     }
 307     if (!(fMaxFractionDigits == other-&gt;fMaxFractionDigits &amp;&amp;
 308           fMinFractionDigits == other-&gt;fMinFractionDigits)) {
 309         if (first) { printf(&quot;[ &quot;); first = FALSE; } else { printf(&quot;, &quot;); }
 310         debug(&quot;Fraction digits !=&quot;);
 311     }
 312     if (!(fGroupingUsed == other-&gt;fGroupingUsed)) {
 313         if (first) { printf(&quot;[ &quot;); first = FALSE; } else { printf(&quot;, &quot;); }
 314         debug(&quot;fGroupingUsed != &quot;);
 315     }
 316     if (!(fParseIntegerOnly == other-&gt;fParseIntegerOnly)) {
 317         if (first) { printf(&quot;[ &quot;); first = FALSE; } else { printf(&quot;, &quot;); }
 318         debug(&quot;fParseIntegerOnly != &quot;);
 319     }
 320     if (!(u_strcmp(fCurrency, other-&gt;fCurrency) == 0)) {
 321         if (first) { printf(&quot;[ &quot;); first = FALSE; } else { printf(&quot;, &quot;); }
 322         debug(&quot;fCurrency !=&quot;);
 323     }
 324     if (!(fLenient == other-&gt;fLenient)) {
 325         if (first) { printf(&quot;[ &quot;); first = FALSE; } else { printf(&quot;, &quot;); }
 326         debug(&quot;fLenient != &quot;);
 327     }
 328     if (!(fCapitalizationContext == other-&gt;fCapitalizationContext)) {
 329         if (first) { printf(&quot;[ &quot;); first = FALSE; } else { printf(&quot;, &quot;); }
 330         debug(&quot;fCapitalizationContext != &quot;);
 331     }
 332     if (!first) { printf(&quot; ]&quot;); }
 333 #endif
 334 
 335     return ((this == &amp;that) ||
 336             ((Format::operator==(that) &amp;&amp;
 337               fMaxIntegerDigits == other-&gt;fMaxIntegerDigits &amp;&amp;
 338               fMinIntegerDigits == other-&gt;fMinIntegerDigits &amp;&amp;
 339               fMaxFractionDigits == other-&gt;fMaxFractionDigits &amp;&amp;
 340               fMinFractionDigits == other-&gt;fMinFractionDigits &amp;&amp;
 341               fGroupingUsed == other-&gt;fGroupingUsed &amp;&amp;
 342               fParseIntegerOnly == other-&gt;fParseIntegerOnly &amp;&amp;
 343               u_strcmp(fCurrency, other-&gt;fCurrency) == 0 &amp;&amp;
 344               fLenient == other-&gt;fLenient &amp;&amp;
 345               fCapitalizationContext == other-&gt;fCapitalizationContext)));
 346 }
 347 
 348 // -------------------------------------
 349 // Default implementation sets unsupported error; subclasses should
 350 // override.
 351 
 352 UnicodeString&amp;
 353 NumberFormat::format(double /* unused number */,
 354                      UnicodeString&amp; toAppendTo,
 355                      FieldPositionIterator* /* unused posIter */,
 356                      UErrorCode&amp; status) const
 357 {
 358     if (!U_FAILURE(status)) {
 359         status = U_UNSUPPORTED_ERROR;
 360     }
 361     return toAppendTo;
 362 }
 363 
 364 // -------------------------------------
 365 // Default implementation sets unsupported error; subclasses should
 366 // override.
 367 
 368 UnicodeString&amp;
 369 NumberFormat::format(int32_t /* unused number */,
 370                      UnicodeString&amp; toAppendTo,
 371                      FieldPositionIterator* /* unused posIter */,
 372                      UErrorCode&amp; status) const
 373 {
 374     if (!U_FAILURE(status)) {
 375         status = U_UNSUPPORTED_ERROR;
 376     }
 377     return toAppendTo;
 378 }
 379 
 380 // -------------------------------------
 381 // Default implementation sets unsupported error; subclasses should
 382 // override.
 383 
 384 UnicodeString&amp;
 385 NumberFormat::format(int64_t /* unused number */,
 386                      UnicodeString&amp; toAppendTo,
 387                      FieldPositionIterator* /* unused posIter */,
 388                      UErrorCode&amp; status) const
 389 {
 390     if (!U_FAILURE(status)) {
 391         status = U_UNSUPPORTED_ERROR;
 392     }
 393     return toAppendTo;
 394 }
 395 
 396 // ------------------------------------------
 397 // These functions add the status code, just fall back to the non-status versions
 398 UnicodeString&amp;
 399 NumberFormat::format(double number,
 400                      UnicodeString&amp; appendTo,
 401                      FieldPosition&amp; pos,
 402                      UErrorCode &amp;status) const {
 403     if(U_SUCCESS(status)) {
 404         return format(number,appendTo,pos);
 405     } else {
 406         return appendTo;
 407     }
 408 }
 409 
 410 UnicodeString&amp;
 411 NumberFormat::format(int32_t number,
 412                      UnicodeString&amp; appendTo,
 413                      FieldPosition&amp; pos,
 414                      UErrorCode &amp;status) const {
 415     if(U_SUCCESS(status)) {
 416         return format(number,appendTo,pos);
 417     } else {
 418         return appendTo;
 419     }
 420 }
 421 
 422 UnicodeString&amp;
 423 NumberFormat::format(int64_t number,
 424                      UnicodeString&amp; appendTo,
 425                      FieldPosition&amp; pos,
 426                      UErrorCode &amp;status) const {
 427     if(U_SUCCESS(status)) {
 428         return format(number,appendTo,pos);
 429     } else {
 430         return appendTo;
 431     }
 432 }
 433 
 434 
 435 
 436 // -------------------------------------
 437 // Decimal Number format() default implementation
 438 // Subclasses do not normally override this function, but rather the DigitList
 439 // formatting functions..
 440 //   The expected call chain from here is
 441 //      this function -&gt;
 442 //      NumberFormat::format(Formattable  -&gt;
 443 //      DecimalFormat::format(DigitList
 444 //
 445 //   Or, for subclasses of Formattable that do not know about DigitList,
 446 //       this Function -&gt;
 447 //       NumberFormat::format(Formattable  -&gt;
 448 //       NumberFormat::format(DigitList  -&gt;
 449 //       XXXFormat::format(double
 450 
 451 UnicodeString&amp;
 452 NumberFormat::format(StringPiece decimalNum,
 453                      UnicodeString&amp; toAppendTo,
 454                      FieldPositionIterator* fpi,
 455                      UErrorCode&amp; status) const
 456 {
 457     Formattable f;
 458     f.setDecimalNumber(decimalNum, status);
 459     format(f, toAppendTo, fpi, status);
 460     return toAppendTo;
 461 }
 462 
 463 /**
 464  *
 465 // Formats the number object and save the format
 466 // result in the toAppendTo string buffer.
 467 
 468 // utility to save/restore state, used in two overloads
 469 // of format(const Formattable&amp;...) below.
 470 *
 471 * Old purpose of ArgExtractor was to avoid const. Not thread safe!
 472 *
 473 * keeping it around as a shim.
 474 */
 475 class ArgExtractor {
 476   const Formattable* num;
 477   UChar save[4];
 478   UBool fWasCurrency;
 479 
 480  public:
 481   ArgExtractor(const NumberFormat&amp; nf, const Formattable&amp; obj, UErrorCode&amp; status);
 482   ~ArgExtractor();
 483 
 484   const Formattable* number(void) const;
 485   const UChar *iso(void) const;
 486   UBool wasCurrency(void) const;
 487 };
 488 
 489 inline const Formattable*
 490 ArgExtractor::number(void) const {
 491   return num;
 492 }
 493 
 494 inline UBool
 495 ArgExtractor::wasCurrency(void) const {
 496   return fWasCurrency;
 497 }
 498 
 499 inline const UChar *
 500 ArgExtractor::iso(void) const {
 501   return save;
 502 }
 503 
 504 ArgExtractor::ArgExtractor(const NumberFormat&amp; /*nf*/, const Formattable&amp; obj, UErrorCode&amp; /*status*/)
 505   : num(&amp;obj), fWasCurrency(FALSE) {
 506 
 507     const UObject* o = obj.getObject(); // most commonly o==NULL
 508     const CurrencyAmount* amt;
 509     if (o != NULL &amp;&amp; (amt = dynamic_cast&lt;const CurrencyAmount*&gt;(o)) != NULL) {
 510         // getISOCurrency() returns a pointer to internal storage, so we
 511         // copy it to retain it across the call to setCurrency().
 512         //const UChar* curr = amt-&gt;getISOCurrency();
 513         u_strcpy(save, amt-&gt;getISOCurrency());
 514         num = &amp;amt-&gt;getNumber();
 515         fWasCurrency=TRUE;
 516     } else {
 517       save[0]=0;
 518     }
 519 }
 520 
 521 ArgExtractor::~ArgExtractor() {
 522 }
 523 
 524 UnicodeString&amp; NumberFormat::format(const number::impl::DecimalQuantity &amp;number,
 525                       UnicodeString&amp; appendTo,
 526                       FieldPositionIterator* posIter,
 527                       UErrorCode&amp; status) const {
 528     // DecimalFormat overrides this function, and handles DigitList based big decimals.
 529     // Other subclasses (ChoiceFormat) do not (yet) handle DigitLists,
 530     // so this default implementation falls back to formatting decimal numbers as doubles.
 531     if (U_FAILURE(status)) {
 532         return appendTo;
 533     }
 534     double dnum = number.toDouble();
 535     format(dnum, appendTo, posIter, status);
 536     return appendTo;
 537 }
 538 
 539 
 540 
 541 UnicodeString&amp;
 542 NumberFormat::format(const number::impl::DecimalQuantity &amp;number,
 543                      UnicodeString&amp; appendTo,
 544                      FieldPosition&amp; pos,
 545                      UErrorCode &amp;status) const {
 546     // DecimalFormat overrides this function, and handles DigitList based big decimals.
 547     // Other subclasses (ChoiceFormat) do not (yet) handle DigitLists,
 548     // so this default implementation falls back to formatting decimal numbers as doubles.
 549     if (U_FAILURE(status)) {
 550         return appendTo;
 551     }
 552     double dnum = number.toDouble();
 553     format(dnum, appendTo, pos, status);
 554     return appendTo;
 555 }
 556 
 557 UnicodeString&amp;
 558 NumberFormat::format(const Formattable&amp; obj,
 559                         UnicodeString&amp; appendTo,
 560                         FieldPosition&amp; pos,
 561                         UErrorCode&amp; status) const
 562 {
 563     if (U_FAILURE(status)) return appendTo;
 564 
 565     ArgExtractor arg(*this, obj, status);
 566     const Formattable *n = arg.number();
 567     const UChar *iso = arg.iso();
 568 
 569     if(arg.wasCurrency() &amp;&amp; u_strcmp(iso, getCurrency())) {
 570       // trying to format a different currency.
 571       // Right now, we clone.
 572       LocalPointer&lt;NumberFormat&gt; cloneFmt((NumberFormat*)this-&gt;clone());
 573       cloneFmt-&gt;setCurrency(iso, status);
 574       // next line should NOT recurse, because n is numeric whereas obj was a wrapper around currency amount.
 575       return cloneFmt-&gt;format(*n, appendTo, pos, status);
 576     }
 577 
 578     if (n-&gt;isNumeric() &amp;&amp; n-&gt;getDecimalQuantity() != NULL) {
 579         // Decimal Number.  We will have a DigitList available if the value was
 580         //   set to a decimal number, or if the value originated with a parse.
 581         //
 582         // The default implementation for formatting a DigitList converts it
 583         // to a double, and formats that, allowing formatting classes that don&#39;t
 584         // know about DigitList to continue to operate as they had.
 585         //
 586         // DecimalFormat overrides the DigitList formatting functions.
 587         format(*n-&gt;getDecimalQuantity(), appendTo, pos, status);
 588     } else {
 589         switch (n-&gt;getType()) {
 590         case Formattable::kDouble:
 591             format(n-&gt;getDouble(), appendTo, pos, status);
 592             break;
 593         case Formattable::kLong:
 594             format(n-&gt;getLong(), appendTo, pos, status);
 595             break;
 596         case Formattable::kInt64:
 597             format(n-&gt;getInt64(), appendTo, pos, status);
 598             break;
 599         default:
 600             status = U_INVALID_FORMAT_ERROR;
 601             break;
 602         }
 603     }
 604 
 605     return appendTo;
 606 }
 607 
 608 // -------------------------------------x
 609 // Formats the number object and save the format
 610 // result in the toAppendTo string buffer.
 611 
 612 UnicodeString&amp;
 613 NumberFormat::format(const Formattable&amp; obj,
 614                         UnicodeString&amp; appendTo,
 615                         FieldPositionIterator* posIter,
 616                         UErrorCode&amp; status) const
 617 {
 618     if (U_FAILURE(status)) return appendTo;
 619 
 620     ArgExtractor arg(*this, obj, status);
 621     const Formattable *n = arg.number();
 622     const UChar *iso = arg.iso();
 623 
 624     if(arg.wasCurrency() &amp;&amp; u_strcmp(iso, getCurrency())) {
 625       // trying to format a different currency.
 626       // Right now, we clone.
 627       LocalPointer&lt;NumberFormat&gt; cloneFmt((NumberFormat*)this-&gt;clone());
 628       cloneFmt-&gt;setCurrency(iso, status);
 629       // next line should NOT recurse, because n is numeric whereas obj was a wrapper around currency amount.
 630       return cloneFmt-&gt;format(*n, appendTo, posIter, status);
 631     }
 632 
 633     if (n-&gt;isNumeric() &amp;&amp; n-&gt;getDecimalQuantity() != NULL) {
 634         // Decimal Number
 635         format(*n-&gt;getDecimalQuantity(), appendTo, posIter, status);
 636     } else {
 637         switch (n-&gt;getType()) {
 638         case Formattable::kDouble:
 639             format(n-&gt;getDouble(), appendTo, posIter, status);
 640             break;
 641         case Formattable::kLong:
 642             format(n-&gt;getLong(), appendTo, posIter, status);
 643             break;
 644         case Formattable::kInt64:
 645             format(n-&gt;getInt64(), appendTo, posIter, status);
 646             break;
 647         default:
 648             status = U_INVALID_FORMAT_ERROR;
 649             break;
 650         }
 651     }
 652 
 653     return appendTo;
 654 }
 655 
 656 // -------------------------------------
 657 
 658 UnicodeString&amp;
 659 NumberFormat::format(int64_t number,
 660                      UnicodeString&amp; appendTo,
 661                      FieldPosition&amp; pos) const
 662 {
 663     // default so we don&#39;t introduce a new abstract method
 664     return format((int32_t)number, appendTo, pos);
 665 }
 666 
 667 // -------------------------------------
 668 // Parses the string and save the result object as well
 669 // as the final parsed position.
 670 
 671 void
 672 NumberFormat::parseObject(const UnicodeString&amp; source,
 673                              Formattable&amp; result,
 674                              ParsePosition&amp; parse_pos) const
 675 {
 676     parse(source, result, parse_pos);
 677 }
 678 
 679 // -------------------------------------
 680 // Formats a double number and save the result in a string.
 681 
 682 UnicodeString&amp;
 683 NumberFormat::format(double number, UnicodeString&amp; appendTo) const
 684 {
 685     FieldPosition pos(FieldPosition::DONT_CARE);
 686     return format(number, appendTo, pos);
 687 }
 688 
 689 // -------------------------------------
 690 // Formats a long number and save the result in a string.
 691 
 692 UnicodeString&amp;
 693 NumberFormat::format(int32_t number, UnicodeString&amp; appendTo) const
 694 {
 695     FieldPosition pos(FieldPosition::DONT_CARE);
 696     return format(number, appendTo, pos);
 697 }
 698 
 699 // -------------------------------------
 700 // Formats a long number and save the result in a string.
 701 
 702 UnicodeString&amp;
 703 NumberFormat::format(int64_t number, UnicodeString&amp; appendTo) const
 704 {
 705     FieldPosition pos(FieldPosition::DONT_CARE);
 706     return format(number, appendTo, pos);
 707 }
 708 
 709 // -------------------------------------
 710 // Parses the text and save the result object.  If the returned
 711 // parse position is 0, that means the parsing failed, the status
 712 // code needs to be set to failure.  Ignores the returned parse
 713 // position, otherwise.
 714 
 715 void
 716 NumberFormat::parse(const UnicodeString&amp; text,
 717                         Formattable&amp; result,
 718                         UErrorCode&amp; status) const
 719 {
 720     if (U_FAILURE(status)) return;
 721 
 722     ParsePosition parsePosition(0);
 723     parse(text, result, parsePosition);
 724     if (parsePosition.getIndex() == 0) {
 725         status = U_INVALID_FORMAT_ERROR;
 726     }
 727 }
 728 
 729 CurrencyAmount* NumberFormat::parseCurrency(const UnicodeString&amp; text,
 730                                             ParsePosition&amp; pos) const {
 731     // Default implementation only -- subclasses should override
 732     Formattable parseResult;
 733     int32_t start = pos.getIndex();
 734     parse(text, parseResult, pos);
 735     if (pos.getIndex() != start) {
 736         UChar curr[4];
 737         UErrorCode ec = U_ZERO_ERROR;
 738         getEffectiveCurrency(curr, ec);
 739         if (U_SUCCESS(ec)) {
 740             LocalPointer&lt;CurrencyAmount&gt; currAmt(new CurrencyAmount(parseResult, curr, ec), ec);
 741             if (U_FAILURE(ec)) {
 742                 pos.setIndex(start); // indicate failure
 743             } else {
 744                 return currAmt.orphan();
 745             }
 746         }
 747     }
 748     return NULL;
 749 }
 750 
 751 // -------------------------------------
 752 // Sets to only parse integers.
 753 
 754 void
 755 NumberFormat::setParseIntegerOnly(UBool value)
 756 {
 757     fParseIntegerOnly = value;
 758 }
 759 
 760 // -------------------------------------
 761 // Sets whether lenient parse is enabled.
 762 
 763 void
 764 NumberFormat::setLenient(UBool enable)
 765 {
 766     fLenient = enable;
 767 }
 768 
 769 // -------------------------------------
 770 // Create a number style NumberFormat instance with the default locale.
 771 
 772 NumberFormat* U_EXPORT2
 773 NumberFormat::createInstance(UErrorCode&amp; status)
 774 {
 775     return createInstance(Locale::getDefault(), UNUM_DECIMAL, status);
 776 }
 777 
 778 // -------------------------------------
 779 // Create a number style NumberFormat instance with the inLocale locale.
 780 
 781 NumberFormat* U_EXPORT2
 782 NumberFormat::createInstance(const Locale&amp; inLocale, UErrorCode&amp; status)
 783 {
 784     return createInstance(inLocale, UNUM_DECIMAL, status);
 785 }
 786 
 787 // -------------------------------------
 788 // Create a currency style NumberFormat instance with the default locale.
 789 
 790 NumberFormat* U_EXPORT2
 791 NumberFormat::createCurrencyInstance(UErrorCode&amp; status)
 792 {
 793     return createCurrencyInstance(Locale::getDefault(),  status);
 794 }
 795 
 796 // -------------------------------------
 797 // Create a currency style NumberFormat instance with the inLocale locale.
 798 
 799 NumberFormat* U_EXPORT2
 800 NumberFormat::createCurrencyInstance(const Locale&amp; inLocale, UErrorCode&amp; status)
 801 {
 802     return createInstance(inLocale, UNUM_CURRENCY, status);
 803 }
 804 
 805 // -------------------------------------
 806 // Create a percent style NumberFormat instance with the default locale.
 807 
 808 NumberFormat* U_EXPORT2
 809 NumberFormat::createPercentInstance(UErrorCode&amp; status)
 810 {
 811     return createInstance(Locale::getDefault(), UNUM_PERCENT, status);
 812 }
 813 
 814 // -------------------------------------
 815 // Create a percent style NumberFormat instance with the inLocale locale.
 816 
 817 NumberFormat* U_EXPORT2
 818 NumberFormat::createPercentInstance(const Locale&amp; inLocale, UErrorCode&amp; status)
 819 {
 820     return createInstance(inLocale, UNUM_PERCENT, status);
 821 }
 822 
 823 // -------------------------------------
 824 // Create a scientific style NumberFormat instance with the default locale.
 825 
 826 NumberFormat* U_EXPORT2
 827 NumberFormat::createScientificInstance(UErrorCode&amp; status)
 828 {
 829     return createInstance(Locale::getDefault(), UNUM_SCIENTIFIC, status);
 830 }
 831 
 832 // -------------------------------------
 833 // Create a scientific style NumberFormat instance with the inLocale locale.
 834 
 835 NumberFormat* U_EXPORT2
 836 NumberFormat::createScientificInstance(const Locale&amp; inLocale, UErrorCode&amp; status)
 837 {
 838     return createInstance(inLocale, UNUM_SCIENTIFIC, status);
 839 }
 840 
 841 // -------------------------------------
 842 
 843 const Locale* U_EXPORT2
 844 NumberFormat::getAvailableLocales(int32_t&amp; count)
 845 {
 846     return Locale::getAvailableLocales(count);
 847 }
 848 
 849 // ------------------------------------------
 850 //
 851 // Registration
 852 //
 853 //-------------------------------------------
 854 
 855 #if !UCONFIG_NO_SERVICE
 856 
 857 // -------------------------------------
 858 
 859 class ICUNumberFormatFactory : public ICUResourceBundleFactory {
 860 public:
 861     virtual ~ICUNumberFormatFactory();
 862 protected:
 863     virtual UObject* handleCreate(const Locale&amp; loc, int32_t kind, const ICUService* /* service */, UErrorCode&amp; status) const {
 864         return NumberFormat::makeInstance(loc, (UNumberFormatStyle)kind, status);
 865     }
 866 };
 867 
 868 ICUNumberFormatFactory::~ICUNumberFormatFactory() {}
 869 
 870 // -------------------------------------
 871 
 872 class NFFactory : public LocaleKeyFactory {
 873 private:
 874     NumberFormatFactory* _delegate;
 875     Hashtable* _ids;
 876 
 877 public:
 878     NFFactory(NumberFormatFactory* delegate)
 879         : LocaleKeyFactory(delegate-&gt;visible() ? VISIBLE : INVISIBLE)
 880         , _delegate(delegate)
 881         , _ids(NULL)
 882     {
 883     }
 884 
 885     virtual ~NFFactory();
 886 
 887     virtual UObject* create(const ICUServiceKey&amp; key, const ICUService* service, UErrorCode&amp; status) const
 888     {
 889         if (handlesKey(key, status)) {
 890             const LocaleKey&amp; lkey = (const LocaleKey&amp;)key;
 891             Locale loc;
 892             lkey.canonicalLocale(loc);
 893             int32_t kind = lkey.kind();
 894 
 895             UObject* result = _delegate-&gt;createFormat(loc, (UNumberFormatStyle)kind);
 896             if (result == NULL) {
 897                 result = service-&gt;getKey((ICUServiceKey&amp;)key /* cast away const */, NULL, this, status);
 898             }
 899             return result;
 900         }
 901         return NULL;
 902     }
 903 
 904 protected:
 905     /**
 906      * Return the set of ids that this factory supports (visible or
 907      * otherwise).  This can be called often and might need to be
 908      * cached if it is expensive to create.
 909      */
 910     virtual const Hashtable* getSupportedIDs(UErrorCode&amp; status) const
 911     {
 912         if (U_SUCCESS(status)) {
 913             if (!_ids) {
 914                 int32_t count = 0;
 915                 const UnicodeString * const idlist = _delegate-&gt;getSupportedIDs(count, status);
 916                 ((NFFactory*)this)-&gt;_ids = new Hashtable(status); /* cast away const */
 917                 if (_ids) {
 918                     for (int i = 0; i &lt; count; ++i) {
 919                         _ids-&gt;put(idlist[i], (void*)this, status);
 920                     }
 921                 }
 922             }
 923             return _ids;
 924         }
 925         return NULL;
 926     }
 927 };
 928 
 929 NFFactory::~NFFactory()
 930 {
 931     delete _delegate;
 932     delete _ids;
 933 }
 934 
 935 class ICUNumberFormatService : public ICULocaleService {
 936 public:
 937     ICUNumberFormatService()
 938         : ICULocaleService(UNICODE_STRING_SIMPLE(&quot;Number Format&quot;))
 939     {
 940         UErrorCode status = U_ZERO_ERROR;
 941         registerFactory(new ICUNumberFormatFactory(), status);
 942     }
 943 
 944     virtual ~ICUNumberFormatService();
 945 
 946     virtual UObject* cloneInstance(UObject* instance) const {
 947         return ((NumberFormat*)instance)-&gt;clone();
 948     }
 949 
 950     virtual UObject* handleDefault(const ICUServiceKey&amp; key, UnicodeString* /* actualID */, UErrorCode&amp; status) const {
 951         LocaleKey&amp; lkey = (LocaleKey&amp;)key;
 952         int32_t kind = lkey.kind();
 953         Locale loc;
 954         lkey.currentLocale(loc);
 955         return NumberFormat::makeInstance(loc, (UNumberFormatStyle)kind, status);
 956     }
 957 
 958     virtual UBool isDefault() const {
 959         return countFactories() == 1;
 960     }
 961 };
 962 
 963 ICUNumberFormatService::~ICUNumberFormatService() {}
 964 
 965 // -------------------------------------
 966 
 967 static void U_CALLCONV initNumberFormatService() {
 968     U_ASSERT(gService == NULL);
 969     ucln_i18n_registerCleanup(UCLN_I18N_NUMFMT, numfmt_cleanup);
 970     gService = new ICUNumberFormatService();
 971 }
 972 
 973 static ICULocaleService*
 974 getNumberFormatService(void)
 975 {
 976     umtx_initOnce(gServiceInitOnce, &amp;initNumberFormatService);
 977     return gService;
 978 }
 979 
 980 static UBool haveService() {
 981     return !gServiceInitOnce.isReset() &amp;&amp; (getNumberFormatService() != NULL);
 982 }
 983 
 984 // -------------------------------------
 985 
 986 URegistryKey U_EXPORT2
 987 NumberFormat::registerFactory(NumberFormatFactory* toAdopt, UErrorCode&amp; status)
 988 {
 989   ICULocaleService *service = getNumberFormatService();
 990   if (service) {
 991       NFFactory *tempnnf = new NFFactory(toAdopt);
 992       if (tempnnf != NULL) {
 993           return service-&gt;registerFactory(tempnnf, status);
 994       }
 995   }
 996   status = U_MEMORY_ALLOCATION_ERROR;
 997   return NULL;
 998 }
 999 
1000 // -------------------------------------
1001 
1002 UBool U_EXPORT2
1003 NumberFormat::unregister(URegistryKey key, UErrorCode&amp; status)
1004 {
1005     if (U_FAILURE(status)) {
1006         return FALSE;
1007     }
1008     if (haveService()) {
1009         return gService-&gt;unregister(key, status);
1010     } else {
1011         status = U_ILLEGAL_ARGUMENT_ERROR;
1012         return FALSE;
1013     }
1014 }
1015 
1016 // -------------------------------------
1017 StringEnumeration* U_EXPORT2
1018 NumberFormat::getAvailableLocales(void)
1019 {
1020   ICULocaleService *service = getNumberFormatService();
1021   if (service) {
1022       return service-&gt;getAvailableLocales();
1023   }
1024   return NULL; // no way to return error condition
1025 }
1026 #endif /* UCONFIG_NO_SERVICE */
1027 // -------------------------------------
1028 
1029 enum { kKeyValueLenMax = 32 };
1030 
1031 NumberFormat*
1032 NumberFormat::internalCreateInstance(const Locale&amp; loc, UNumberFormatStyle kind, UErrorCode&amp; status) {
1033     if (kind == UNUM_CURRENCY) {
1034         char cfKeyValue[kKeyValueLenMax] = {0};
1035         UErrorCode kvStatus = U_ZERO_ERROR;
1036         int32_t kLen = loc.getKeywordValue(&quot;cf&quot;, cfKeyValue, kKeyValueLenMax, kvStatus);
1037         if (U_SUCCESS(kvStatus) &amp;&amp; kLen &gt; 0 &amp;&amp; uprv_strcmp(cfKeyValue,&quot;account&quot;)==0) {
1038             kind = UNUM_CURRENCY_ACCOUNTING;
1039         }
1040     }
1041 #if !UCONFIG_NO_SERVICE
1042     if (haveService()) {
1043         return (NumberFormat*)gService-&gt;get(loc, kind, status);
1044     }
1045 #endif
1046     return makeInstance(loc, kind, status);
1047 }
1048 
1049 NumberFormat* U_EXPORT2
1050 NumberFormat::createInstance(const Locale&amp; loc, UNumberFormatStyle kind, UErrorCode&amp; status) {
1051     if (kind != UNUM_DECIMAL) {
1052         return internalCreateInstance(loc, kind, status);
1053     }
1054     const SharedNumberFormat *shared = createSharedInstance(loc, kind, status);
1055     if (U_FAILURE(status)) {
1056         return NULL;
1057     }
1058     NumberFormat *result = static_cast&lt;NumberFormat *&gt;((*shared)-&gt;clone());
1059     shared-&gt;removeRef();
1060     if (result == NULL) {
1061         status = U_MEMORY_ALLOCATION_ERROR;
1062     }
1063     return result;
1064 }
1065 
1066 
1067 // -------------------------------------
1068 // Checks if the thousand/10 thousand grouping is used in the
1069 // NumberFormat instance.
1070 
1071 UBool
1072 NumberFormat::isGroupingUsed() const
1073 {
1074     return fGroupingUsed;
1075 }
1076 
1077 // -------------------------------------
1078 // Sets to use the thousand/10 thousand grouping in the
1079 // NumberFormat instance.
1080 
1081 void
1082 NumberFormat::setGroupingUsed(UBool newValue)
1083 {
1084     fGroupingUsed = newValue;
1085 }
1086 
1087 // -------------------------------------
1088 // Gets the maximum number of digits for the integral part for
1089 // this NumberFormat instance.
1090 
1091 int32_t NumberFormat::getMaximumIntegerDigits() const
1092 {
1093     return fMaxIntegerDigits;
1094 }
1095 
1096 // -------------------------------------
1097 // Sets the maximum number of digits for the integral part for
1098 // this NumberFormat instance.
1099 
1100 void
1101 NumberFormat::setMaximumIntegerDigits(int32_t newValue)
1102 {
1103     fMaxIntegerDigits = uprv_max(0, uprv_min(newValue, gDefaultMaxIntegerDigits));
1104     if(fMinIntegerDigits &gt; fMaxIntegerDigits)
1105         fMinIntegerDigits = fMaxIntegerDigits;
1106 }
1107 
1108 // -------------------------------------
1109 // Gets the minimum number of digits for the integral part for
1110 // this NumberFormat instance.
1111 
1112 int32_t
1113 NumberFormat::getMinimumIntegerDigits() const
1114 {
1115     return fMinIntegerDigits;
1116 }
1117 
1118 // -------------------------------------
1119 // Sets the minimum number of digits for the integral part for
1120 // this NumberFormat instance.
1121 
1122 void
1123 NumberFormat::setMinimumIntegerDigits(int32_t newValue)
1124 {
1125     fMinIntegerDigits = uprv_max(0, uprv_min(newValue, gDefaultMinIntegerDigits));
1126     if(fMinIntegerDigits &gt; fMaxIntegerDigits)
1127         fMaxIntegerDigits = fMinIntegerDigits;
1128 }
1129 
1130 // -------------------------------------
1131 // Gets the maximum number of digits for the fractional part for
1132 // this NumberFormat instance.
1133 
1134 int32_t
1135 NumberFormat::getMaximumFractionDigits() const
1136 {
1137     return fMaxFractionDigits;
1138 }
1139 
1140 // -------------------------------------
1141 // Sets the maximum number of digits for the fractional part for
1142 // this NumberFormat instance.
1143 
1144 void
1145 NumberFormat::setMaximumFractionDigits(int32_t newValue)
1146 {
1147     fMaxFractionDigits = uprv_max(0, uprv_min(newValue, gDefaultMaxIntegerDigits));
1148     if(fMaxFractionDigits &lt; fMinFractionDigits)
1149         fMinFractionDigits = fMaxFractionDigits;
1150 }
1151 
1152 // -------------------------------------
1153 // Gets the minimum number of digits for the fractional part for
1154 // this NumberFormat instance.
1155 
1156 int32_t
1157 NumberFormat::getMinimumFractionDigits() const
1158 {
1159     return fMinFractionDigits;
1160 }
1161 
1162 // -------------------------------------
1163 // Sets the minimum number of digits for the fractional part for
1164 // this NumberFormat instance.
1165 
1166 void
1167 NumberFormat::setMinimumFractionDigits(int32_t newValue)
1168 {
1169     fMinFractionDigits = uprv_max(0, uprv_min(newValue, gDefaultMinIntegerDigits));
1170     if (fMaxFractionDigits &lt; fMinFractionDigits)
1171         fMaxFractionDigits = fMinFractionDigits;
1172 }
1173 
1174 // -------------------------------------
1175 
1176 void NumberFormat::setCurrency(const UChar* theCurrency, UErrorCode&amp; ec) {
1177     if (U_FAILURE(ec)) {
1178         return;
1179     }
1180     if (theCurrency) {
1181         u_strncpy(fCurrency, theCurrency, 3);
1182         fCurrency[3] = 0;
1183     } else {
1184         fCurrency[0] = 0;
1185     }
1186 }
1187 
1188 const char16_t* NumberFormat::getCurrency() const {
1189     return fCurrency;
1190 }
1191 
1192 void NumberFormat::getEffectiveCurrency(UChar* result, UErrorCode&amp; ec) const {
1193     const UChar* c = getCurrency();
1194     if (*c != 0) {
1195         u_strncpy(result, c, 3);
1196         result[3] = 0;
1197     } else {
1198         const char* loc = getLocaleID(ULOC_VALID_LOCALE, ec);
1199         if (loc == NULL) {
1200             loc = uloc_getDefault();
1201         }
1202         ucurr_forLocale(loc, result, 4, &amp;ec);
1203     }
1204 }
1205 
1206 //----------------------------------------------------------------------
1207 
1208 
1209 void NumberFormat::setContext(UDisplayContext value, UErrorCode&amp; status)
1210 {
1211     if (U_FAILURE(status))
1212         return;
1213     if ( (UDisplayContextType)((uint32_t)value &gt;&gt; 8) == UDISPCTX_TYPE_CAPITALIZATION ) {
1214         fCapitalizationContext = value;
1215     } else {
1216         status = U_ILLEGAL_ARGUMENT_ERROR;
1217    }
1218 }
1219 
1220 
1221 UDisplayContext NumberFormat::getContext(UDisplayContextType type, UErrorCode&amp; status) const
1222 {
1223     if (U_FAILURE(status))
1224         return (UDisplayContext)0;
1225     if (type != UDISPCTX_TYPE_CAPITALIZATION) {
1226         status = U_ILLEGAL_ARGUMENT_ERROR;
1227         return (UDisplayContext)0;
1228     }
1229     return fCapitalizationContext;
1230 }
1231 
1232 
1233 // -------------------------------------
1234 // Creates the NumberFormat instance of the specified style (number, currency,
1235 // or percent) for the desired locale.
1236 
1237 static void U_CALLCONV nscacheInit() {
1238     U_ASSERT(NumberingSystem_cache == NULL);
1239     ucln_i18n_registerCleanup(UCLN_I18N_NUMFMT, numfmt_cleanup);
1240     UErrorCode status = U_ZERO_ERROR;
1241     NumberingSystem_cache = uhash_open(uhash_hashLong,
1242                                        uhash_compareLong,
1243                                        NULL,
1244                                        &amp;status);
1245     if (U_FAILURE(status)) {
1246         // Number Format code will run with no cache if creation fails.
1247         NumberingSystem_cache = NULL;
1248         return;
1249     }
1250     uhash_setValueDeleter(NumberingSystem_cache, deleteNumberingSystem);
1251 }
1252 
1253 template&lt;&gt; U_I18N_API
1254 const SharedNumberFormat *LocaleCacheKey&lt;SharedNumberFormat&gt;::createObject(
1255         const void * /*unused*/, UErrorCode &amp;status) const {
1256     const char *localeId = fLoc.getName();
1257     NumberFormat *nf = NumberFormat::internalCreateInstance(
1258             localeId, UNUM_DECIMAL, status);
1259     if (U_FAILURE(status)) {
1260         return NULL;
1261     }
1262     SharedNumberFormat *result = new SharedNumberFormat(nf);
1263     if (result == NULL) {
1264         status = U_MEMORY_ALLOCATION_ERROR;
1265         delete nf;
1266         return NULL;
1267     }
1268     result-&gt;addRef();
1269     return result;
1270 }
1271 
1272 const SharedNumberFormat* U_EXPORT2
1273 NumberFormat::createSharedInstance(const Locale&amp; loc, UNumberFormatStyle kind, UErrorCode&amp; status) {
1274     if (U_FAILURE(status)) {
1275         return NULL;
1276     }
1277     if (kind != UNUM_DECIMAL) {
1278         status = U_UNSUPPORTED_ERROR;
1279         return NULL;
1280     }
1281     const SharedNumberFormat *result = NULL;
1282     UnifiedCache::getByLocale(loc, result, status);
1283     return result;
1284 }
1285 
1286 UBool
1287 NumberFormat::isStyleSupported(UNumberFormatStyle style) {
1288     return gLastResortNumberPatterns[style] != NULL;
1289 }
1290 
1291 NumberFormat*
1292 NumberFormat::makeInstance(const Locale&amp; desiredLocale,
1293                            UNumberFormatStyle style,
1294                            UErrorCode&amp; status) {
1295   return makeInstance(desiredLocale, style, false, status);
1296 }
1297 
1298 NumberFormat*
1299 NumberFormat::makeInstance(const Locale&amp; desiredLocale,
1300                            UNumberFormatStyle style,
1301                            UBool mustBeDecimalFormat,
1302                            UErrorCode&amp; status) {
1303     if (U_FAILURE(status)) return NULL;
1304 
1305     if (style &lt; 0 || style &gt;= UNUM_FORMAT_STYLE_COUNT) {
1306         status = U_ILLEGAL_ARGUMENT_ERROR;
1307         return NULL;
1308     }
1309 
1310     // Some styles are not supported. This is a result of merging
1311     // the @draft ICU 4.2 NumberFormat::EStyles into the long-existing UNumberFormatStyle.
1312     // Ticket #8503 is for reviewing/fixing/merging the two relevant implementations:
1313     // this one and unum_open().
1314     // The UNUM_PATTERN_ styles are not supported here
1315     // because this method does not take a pattern string.
1316     if (!isStyleSupported(style)) {
1317         status = U_UNSUPPORTED_ERROR;
1318         return NULL;
1319     }
1320 
1321 #if U_PLATFORM_USES_ONLY_WIN32_API
1322     if (!mustBeDecimalFormat) {
1323         char buffer[8];
1324         int32_t count = desiredLocale.getKeywordValue(&quot;compat&quot;, buffer, sizeof(buffer), status);
1325 
1326         // if the locale has &quot;@compat=host&quot;, create a host-specific NumberFormat
1327         if (U_SUCCESS(status) &amp;&amp; count &gt; 0 &amp;&amp; uprv_strcmp(buffer, &quot;host&quot;) == 0) {
1328             UBool curr = TRUE;
1329 
1330             switch (style) {
1331             case UNUM_DECIMAL:
1332                 curr = FALSE;
1333                 // fall-through
1334                 U_FALLTHROUGH;
1335 
1336             case UNUM_CURRENCY:
1337             case UNUM_CURRENCY_ISO: // do not support plural formatting here
1338             case UNUM_CURRENCY_PLURAL:
1339             case UNUM_CURRENCY_ACCOUNTING:
1340             case UNUM_CASH_CURRENCY:
1341             case UNUM_CURRENCY_STANDARD:
1342             {
1343                 LocalPointer&lt;Win32NumberFormat&gt; f(new Win32NumberFormat(desiredLocale, curr, status), status);
1344                 if (U_SUCCESS(status)) {
1345                     return f.orphan();
1346                 }
1347             }
1348             break;
1349             default:
1350                 break;
1351             }
1352         }
1353     }
1354 #endif
1355     // Use numbering system cache hashtable
1356     umtx_initOnce(gNSCacheInitOnce, &amp;nscacheInit);
1357 
1358     // Get cached numbering system
1359     LocalPointer&lt;NumberingSystem&gt; ownedNs;
1360     NumberingSystem *ns = NULL;
1361     if (NumberingSystem_cache != NULL) {
1362         // TODO: Bad hash key usage, see ticket #8504.
1363         int32_t hashKey = desiredLocale.hashCode();
1364 
1365         static icu::UMutex nscacheMutex = U_MUTEX_INITIALIZER;
1366         Mutex lock(&amp;nscacheMutex);
1367         ns = (NumberingSystem *)uhash_iget(NumberingSystem_cache, hashKey);
1368         if (ns == NULL) {
1369             ns = NumberingSystem::createInstance(desiredLocale,status);
1370             uhash_iput(NumberingSystem_cache, hashKey, (void*)ns, &amp;status);
1371         }
1372     } else {
1373         ownedNs.adoptInstead(NumberingSystem::createInstance(desiredLocale,status));
1374         ns = ownedNs.getAlias();
1375     }
1376 
1377     // check results of getting a numbering system
1378     if (U_FAILURE(status)) {
1379         return NULL;
1380     }
1381 
1382     if (mustBeDecimalFormat &amp;&amp; ns-&gt;isAlgorithmic()) {
1383         status = U_UNSUPPORTED_ERROR;
1384         return NULL;
1385     }
1386 
1387     LocalPointer&lt;DecimalFormatSymbols&gt; symbolsToAdopt;
1388     UnicodeString pattern;
1389     LocalUResourceBundlePointer ownedResource(ures_open(NULL, desiredLocale.getName(), &amp;status));
1390     if (U_FAILURE(status)) {
1391         return NULL;
1392     }
1393     else {
1394         // Loads the decimal symbols of the desired locale.
1395         symbolsToAdopt.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(desiredLocale, status), status);
1396         if (U_FAILURE(status)) {
1397             return NULL;
1398         }
1399 
1400         // Load the pattern from data using the common library function
1401         const char16_t* patternPtr = number::impl::utils::getPatternForStyle(
1402                 desiredLocale,
1403                 ns-&gt;getName(),
1404                 gFormatCldrStyles[style],
1405                 status);
1406         pattern = UnicodeString(TRUE, patternPtr, -1);
1407     }
1408     if (U_FAILURE(status)) {
1409         return NULL;
1410     }
1411     if(style==UNUM_CURRENCY || style == UNUM_CURRENCY_ISO || style == UNUM_CURRENCY_ACCOUNTING
1412         || style == UNUM_CASH_CURRENCY || style == UNUM_CURRENCY_STANDARD){
1413         const UChar* currPattern = symbolsToAdopt-&gt;getCurrencyPattern();
1414         if(currPattern!=NULL){
1415             pattern.setTo(currPattern, u_strlen(currPattern));
1416         }
1417     }
1418 
1419     LocalPointer&lt;NumberFormat&gt; f;
1420     if (ns-&gt;isAlgorithmic()) {
1421         UnicodeString nsDesc;
1422         UnicodeString nsRuleSetGroup;
1423         UnicodeString nsRuleSetName;
1424         Locale nsLoc;
1425         URBNFRuleSetTag desiredRulesType = URBNF_NUMBERING_SYSTEM;
1426 
1427         nsDesc.setTo(ns-&gt;getDescription());
1428         int32_t firstSlash = nsDesc.indexOf(gSlash);
1429         int32_t lastSlash = nsDesc.lastIndexOf(gSlash);
1430         if ( lastSlash &gt; firstSlash ) {
1431             CharString nsLocID;
1432 
1433             nsLocID.appendInvariantChars(nsDesc.tempSubString(0, firstSlash), status);
1434             nsRuleSetGroup.setTo(nsDesc,firstSlash+1,lastSlash-firstSlash-1);
1435             nsRuleSetName.setTo(nsDesc,lastSlash+1);
1436 
1437             nsLoc = Locale::createFromName(nsLocID.data());
1438 
1439             UnicodeString SpelloutRules = UNICODE_STRING_SIMPLE(&quot;SpelloutRules&quot;);
1440             if ( nsRuleSetGroup.compare(SpelloutRules) == 0 ) {
1441                 desiredRulesType = URBNF_SPELLOUT;
1442             }
1443         } else {
1444             nsLoc = desiredLocale;
1445             nsRuleSetName.setTo(nsDesc);
1446         }
1447 
1448         RuleBasedNumberFormat *r = new RuleBasedNumberFormat(desiredRulesType,nsLoc,status);
1449         if (r == NULL) {
1450             status = U_MEMORY_ALLOCATION_ERROR;
1451             return NULL;
1452         }
1453         r-&gt;setDefaultRuleSet(nsRuleSetName,status);
1454         f.adoptInstead(r);
1455     } else {
1456         // replace single currency sign in the pattern with double currency sign
1457         // if the style is UNUM_CURRENCY_ISO
1458         if (style == UNUM_CURRENCY_ISO) {
1459             pattern.findAndReplace(UnicodeString(TRUE, gSingleCurrencySign, 1),
1460                                    UnicodeString(TRUE, gDoubleCurrencySign, 2));
1461         }
1462 
1463         // &quot;new DecimalFormat()&quot; does not adopt the symbols argument if its memory allocation fails.
1464         // So we can&#39;t use adoptInsteadAndCheckErrorCode as we need to know if the &#39;new&#39; failed.
1465         DecimalFormatSymbols *syms = symbolsToAdopt.getAlias();
1466         LocalPointer&lt;DecimalFormat&gt; df(new DecimalFormat(pattern, syms, style, status));
1467 
1468         if (df.isValid()) {
1469             // if the DecimalFormat object was successfully new&#39;ed, then it will own symbolsToAdopt, even if the status is a failure.
1470             symbolsToAdopt.orphan();
1471         }
1472         else {
1473             status = U_MEMORY_ALLOCATION_ERROR;
1474         }
1475 
1476         if (U_FAILURE(status)) {
1477             return nullptr;
1478         }
1479 
1480         // if it is cash currency style, setCurrencyUsage with usage
1481         if (style == UNUM_CASH_CURRENCY){
1482             df-&gt;setCurrencyUsage(UCURR_USAGE_CASH, &amp;status);
1483         }
1484 
1485         if (U_FAILURE(status)) {
1486             return nullptr;
1487         }
1488 
1489         f.adoptInstead(df.orphan());
1490     }
1491 
1492     f-&gt;setLocaleIDs(ures_getLocaleByType(ownedResource.getAlias(), ULOC_VALID_LOCALE, &amp;status),
1493                     ures_getLocaleByType(ownedResource.getAlias(), ULOC_ACTUAL_LOCALE, &amp;status));
1494     if (U_FAILURE(status)) {
1495         return NULL;
1496     }
1497     return f.orphan();
1498 }
1499 
1500 /**
1501  * Get the rounding mode.
1502  * @return A rounding mode
1503  */
1504 NumberFormat::ERoundingMode NumberFormat::getRoundingMode() const {
1505     // Default value. ICU4J throws an exception and we can&#39;t change this API.
1506     return NumberFormat::ERoundingMode::kRoundUnnecessary;
1507 }
1508 
1509 /**
1510  * Set the rounding mode.  This has no effect unless the rounding
1511  * increment is greater than zero.
1512  * @param roundingMode A rounding mode
1513  */
1514 void NumberFormat::setRoundingMode(NumberFormat::ERoundingMode /*roundingMode*/) {
1515     // No-op ICU4J throws an exception, and we can&#39;t change this API.
1516 }
1517 
1518 U_NAMESPACE_END
1519 
1520 #endif /* #if !UCONFIG_NO_FORMATTING */
1521 
1522 //eof
    </pre>
  </body>
</html>