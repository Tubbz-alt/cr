<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tzfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 2011-2015, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 *******************************************************************************
   8 */
   9 
  10 #include &quot;unicode/utypes.h&quot;
  11 
  12 #if !UCONFIG_NO_FORMATTING
  13 
  14 #include &quot;unicode/calendar.h&quot;
  15 #include &quot;unicode/tzfmt.h&quot;
  16 #include &quot;unicode/numsys.h&quot;
  17 #include &quot;unicode/strenum.h&quot;
  18 #include &quot;unicode/uchar.h&quot;
  19 #include &quot;unicode/udat.h&quot;
  20 #include &quot;unicode/ustring.h&quot;
  21 #include &quot;unicode/utf16.h&quot;
  22 #include &quot;tzgnames.h&quot;
  23 #include &quot;cmemory.h&quot;
  24 #include &quot;cstring.h&quot;
  25 #include &quot;putilimp.h&quot;
  26 #include &quot;uassert.h&quot;
  27 #include &quot;ucln_in.h&quot;
  28 #include &quot;umutex.h&quot;
  29 #include &quot;uresimp.h&quot;
  30 #include &quot;ureslocs.h&quot;
  31 #include &quot;uvector.h&quot;
  32 #include &quot;zonemeta.h&quot;
  33 #include &quot;tznames_impl.h&quot;   // TextTrieMap
  34 #include &quot;patternprops.h&quot;
  35 
  36 U_NAMESPACE_BEGIN
  37 
  38 // Bit flags used by the parse method.
  39 // The order must match UTimeZoneFormatStyle enum.
  40 #define ISO_Z_STYLE_FLAG 0x0080
  41 #define ISO_LOCAL_STYLE_FLAG 0x0100
  42 static const int16_t STYLE_PARSE_FLAGS[] = {
  43     0x0001, // UTZFMT_STYLE_GENERIC_LOCATION,
  44     0x0002, // UTZFMT_STYLE_GENERIC_LONG,
  45     0x0004, // UTZFMT_STYLE_GENERIC_SHORT,
  46     0x0008, // UTZFMT_STYLE_SPECIFIC_LONG,
  47     0x0010, // UTZFMT_STYLE_SPECIFIC_SHORT,
  48     0x0020, // UTZFMT_STYLE_LOCALIZED_GMT,
  49     0x0040, // UTZFMT_STYLE_LOCALIZED_GMT_SHORT,
  50     ISO_Z_STYLE_FLAG,       // UTZFMT_STYLE_ISO_BASIC_SHORT,
  51     ISO_LOCAL_STYLE_FLAG,   // UTZFMT_STYLE_ISO_BASIC_LOCAL_SHORT,
  52     ISO_Z_STYLE_FLAG,       // UTZFMT_STYLE_ISO_BASIC_FIXED,
  53     ISO_LOCAL_STYLE_FLAG,   // UTZFMT_STYLE_ISO_BASIC_LOCAL_FIXED,
  54     ISO_Z_STYLE_FLAG,       // UTZFMT_STYLE_ISO_BASIC_FULL,
  55     ISO_LOCAL_STYLE_FLAG,   // UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL,
  56     ISO_Z_STYLE_FLAG,       // UTZFMT_STYLE_ISO_EXTENDED_FIXED,
  57     ISO_LOCAL_STYLE_FLAG,   // UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FIXED,
  58     ISO_Z_STYLE_FLAG,       // UTZFMT_STYLE_ISO_EXTENDED_FULL,
  59     ISO_LOCAL_STYLE_FLAG,   // UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FULL,
  60     0x0200, // UTZFMT_STYLE_ZONE_ID,
  61     0x0400, // UTZFMT_STYLE_ZONE_ID_SHORT,
  62     0x0800  // UTZFMT_STYLE_EXEMPLAR_LOCATION
  63 };
  64 
  65 static const char gZoneStringsTag[] = &quot;zoneStrings&quot;;
  66 static const char gGmtFormatTag[]= &quot;gmtFormat&quot;;
  67 static const char gGmtZeroFormatTag[] = &quot;gmtZeroFormat&quot;;
  68 static const char gHourFormatTag[]= &quot;hourFormat&quot;;
  69 
  70 static const UChar TZID_GMT[] = {0x0045, 0x0074, 0x0063, 0x002F, 0x0047, 0x004D, 0x0054, 0};    // Etc/GMT
  71 static const UChar UNKNOWN_ZONE_ID[] = {
  72     0x0045, 0x0074, 0x0063, 0x002F, 0x0055, 0x006E, 0x006B, 0x006E, 0x006F, 0x0077, 0x006E, 0}; // Etc/Unknown
  73 static const UChar UNKNOWN_SHORT_ZONE_ID[] = {0x0075, 0x006E, 0x006B, 0};   // unk
  74 static const UChar UNKNOWN_LOCATION[] = {0x0055, 0x006E, 0x006B, 0x006E, 0x006F, 0x0077, 0x006E, 0};    // Unknown
  75 
  76 static const UChar DEFAULT_GMT_PATTERN[] = {0x0047, 0x004D, 0x0054, 0x007B, 0x0030, 0x007D, 0}; // GMT{0}
  77 //static const UChar DEFAULT_GMT_ZERO[] = {0x0047, 0x004D, 0x0054, 0}; // GMT
  78 static const UChar DEFAULT_GMT_POSITIVE_HM[] = {0x002B, 0x0048, 0x003A, 0x006D, 0x006D, 0}; // +H:mm
  79 static const UChar DEFAULT_GMT_POSITIVE_HMS[] = {0x002B, 0x0048, 0x003A, 0x006D, 0x006D, 0x003A, 0x0073, 0x0073, 0}; // +H:mm:ss
  80 static const UChar DEFAULT_GMT_NEGATIVE_HM[] = {0x002D, 0x0048, 0x003A, 0x006D, 0x006D, 0}; // -H:mm
  81 static const UChar DEFAULT_GMT_NEGATIVE_HMS[] = {0x002D, 0x0048, 0x003A, 0x006D, 0x006D, 0x003A, 0x0073, 0x0073, 0}; // -H:mm:ss
  82 static const UChar DEFAULT_GMT_POSITIVE_H[] = {0x002B, 0x0048, 0}; // +H
  83 static const UChar DEFAULT_GMT_NEGATIVE_H[] = {0x002D, 0x0048, 0}; // -H
  84 
  85 static const UChar32 DEFAULT_GMT_DIGITS[] = {
  86     0x0030, 0x0031, 0x0032, 0x0033, 0x0034,
  87     0x0035, 0x0036, 0x0037, 0x0038, 0x0039
  88 };
  89 
  90 static const UChar DEFAULT_GMT_OFFSET_SEP = 0x003A; // &#39;:&#39;
  91 
  92 static const UChar ARG0[] = {0x007B, 0x0030, 0x007D};   // &quot;{0}&quot;
  93 static const int32_t ARG0_LEN = 3;
  94 
  95 static const UChar DEFAULT_GMT_OFFSET_MINUTE_PATTERN[] = {0x006D, 0x006D, 0};   // &quot;mm&quot;
  96 static const UChar DEFAULT_GMT_OFFSET_SECOND_PATTERN[] = {0x0073, 0x0073, 0};   // &quot;ss&quot;
  97 
  98 static const UChar ALT_GMT_STRINGS[][4] = {
  99     {0x0047, 0x004D, 0x0054, 0},    // GMT
 100     {0x0055, 0x0054, 0x0043, 0},    // UTC
 101     {0x0055, 0x0054, 0, 0},         // UT
 102     {0, 0, 0, 0}
 103 };
 104 
 105 // Order of GMT offset pattern parsing, *_HMS must be evaluated first
 106 // because *_HM is most likely a substring of *_HMS
 107 static const int32_t PARSE_GMT_OFFSET_TYPES[] = {
 108     UTZFMT_PAT_POSITIVE_HMS,
 109     UTZFMT_PAT_NEGATIVE_HMS,
 110     UTZFMT_PAT_POSITIVE_HM,
 111     UTZFMT_PAT_NEGATIVE_HM,
 112     UTZFMT_PAT_POSITIVE_H,
 113     UTZFMT_PAT_NEGATIVE_H,
 114     -1
 115 };
 116 
 117 static const UChar SINGLEQUOTE  = 0x0027;
 118 static const UChar PLUS         = 0x002B;
 119 static const UChar MINUS        = 0x002D;
 120 static const UChar ISO8601_UTC  = 0x005A;   // &#39;Z&#39;
 121 static const UChar ISO8601_SEP  = 0x003A;   // &#39;:&#39;
 122 
 123 static const int32_t MILLIS_PER_HOUR = 60 * 60 * 1000;
 124 static const int32_t MILLIS_PER_MINUTE = 60 * 1000;
 125 static const int32_t MILLIS_PER_SECOND = 1000;
 126 
 127 // Maximum offset (exclusive) in millisecond supported by offset formats
 128 static int32_t MAX_OFFSET = 24 * MILLIS_PER_HOUR;
 129 
 130 // Maximum values for GMT offset fields
 131 static const int32_t MAX_OFFSET_HOUR = 23;
 132 static const int32_t MAX_OFFSET_MINUTE = 59;
 133 static const int32_t MAX_OFFSET_SECOND = 59;
 134 
 135 static const int32_t UNKNOWN_OFFSET = 0x7FFFFFFF;
 136 
 137 static const int32_t ALL_SIMPLE_NAME_TYPES = UTZNM_LONG_STANDARD | UTZNM_LONG_DAYLIGHT | UTZNM_SHORT_STANDARD | UTZNM_SHORT_DAYLIGHT | UTZNM_EXEMPLAR_LOCATION;
 138 static const int32_t ALL_GENERIC_NAME_TYPES = UTZGNM_LOCATION | UTZGNM_LONG | UTZGNM_SHORT;
 139 
 140 #define DIGIT_VAL(c) (0x0030 &lt;= (c) &amp;&amp; (c) &lt;= 0x0039 ? (c) - 0x0030 : -1)
 141 #define MAX_OFFSET_DIGITS 6
 142 
 143 // Time Zone ID/Short ID trie
 144 static TextTrieMap *gZoneIdTrie = NULL;
 145 static icu::UInitOnce gZoneIdTrieInitOnce = U_INITONCE_INITIALIZER;
 146 
 147 static TextTrieMap *gShortZoneIdTrie = NULL;
 148 static icu::UInitOnce gShortZoneIdTrieInitOnce = U_INITONCE_INITIALIZER;
 149 
<a name="1" id="anc1"></a><span class="line-modified"> 150 static UMutex *gLock() {</span>
<span class="line-added"> 151     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added"> 152     return &amp;m;</span>
<span class="line-added"> 153 }</span>
 154 
 155 U_CDECL_BEGIN
 156 /**
 157  * Cleanup callback func
 158  */
 159 static UBool U_CALLCONV tzfmt_cleanup(void)
 160 {
 161     if (gZoneIdTrie != NULL) {
 162         delete gZoneIdTrie;
 163     }
 164     gZoneIdTrie = NULL;
 165     gZoneIdTrieInitOnce.reset();
 166 
 167     if (gShortZoneIdTrie != NULL) {
 168         delete gShortZoneIdTrie;
 169     }
 170     gShortZoneIdTrie = NULL;
 171     gShortZoneIdTrieInitOnce.reset();
 172 
 173     return TRUE;
 174 }
 175 U_CDECL_END
 176 
 177 // ------------------------------------------------------------------
 178 // GMTOffsetField
 179 //
 180 // This class represents a localized GMT offset pattern
 181 // item and used by TimeZoneFormat
 182 // ------------------------------------------------------------------
 183 class GMTOffsetField : public UMemory {
 184 public:
 185     enum FieldType {
 186         TEXT = 0,
 187         HOUR = 1,
 188         MINUTE = 2,
 189         SECOND = 4
 190     };
 191 
 192     virtual ~GMTOffsetField();
 193 
 194     static GMTOffsetField* createText(const UnicodeString&amp; text, UErrorCode&amp; status);
 195     static GMTOffsetField* createTimeField(FieldType type, uint8_t width, UErrorCode&amp; status);
 196     static UBool isValid(FieldType type, int32_t width);
 197     static FieldType getTypeByLetter(UChar ch);
 198 
 199     FieldType getType() const;
 200     uint8_t getWidth() const;
 201     const UChar* getPatternText(void) const;
 202 
 203 private:
 204     UChar* fText;
 205     FieldType fType;
 206     uint8_t fWidth;
 207 
 208     GMTOffsetField();
 209 };
 210 
 211 GMTOffsetField::GMTOffsetField()
 212 : fText(NULL), fType(TEXT), fWidth(0) {
 213 }
 214 
 215 GMTOffsetField::~GMTOffsetField() {
 216     if (fText) {
 217         uprv_free(fText);
 218     }
 219 }
 220 
 221 GMTOffsetField*
 222 GMTOffsetField::createText(const UnicodeString&amp; text, UErrorCode&amp; status) {
 223     if (U_FAILURE(status)) {
 224         return NULL;
 225     }
 226     GMTOffsetField* result = new GMTOffsetField();
 227     if (result == NULL) {
 228         status = U_MEMORY_ALLOCATION_ERROR;
 229         return NULL;
 230     }
 231 
 232     int32_t len = text.length();
 233     result-&gt;fText = (UChar*)uprv_malloc((len + 1) * sizeof(UChar));
 234     if (result-&gt;fText == NULL) {
 235         status = U_MEMORY_ALLOCATION_ERROR;
 236         delete result;
 237         return NULL;
 238     }
 239     u_strncpy(result-&gt;fText, text.getBuffer(), len);
 240     result-&gt;fText[len] = 0;
 241     result-&gt;fType = TEXT;
 242 
 243     return result;
 244 }
 245 
 246 GMTOffsetField*
 247 GMTOffsetField::createTimeField(FieldType type, uint8_t width, UErrorCode&amp; status) {
 248     U_ASSERT(type != TEXT);
 249     if (U_FAILURE(status)) {
 250         return NULL;
 251     }
 252     GMTOffsetField* result = new GMTOffsetField();
 253     if (result == NULL) {
 254         status = U_MEMORY_ALLOCATION_ERROR;
 255         return NULL;
 256     }
 257 
 258     result-&gt;fType = type;
 259     result-&gt;fWidth = width;
 260 
 261     return result;
 262 }
 263 
 264 UBool
 265 GMTOffsetField::isValid(FieldType type, int32_t width) {
 266     switch (type) {
 267     case HOUR:
 268         return (width == 1 || width == 2);
 269     case MINUTE:
 270     case SECOND:
 271         return (width == 2);
 272     default:
<a name="2" id="anc2"></a><span class="line-modified"> 273         UPRV_UNREACHABLE;</span>
 274     }
 275     return (width &gt; 0);
 276 }
 277 
 278 GMTOffsetField::FieldType
 279 GMTOffsetField::getTypeByLetter(UChar ch) {
 280     if (ch == 0x0048 /* H */) {
 281         return HOUR;
 282     } else if (ch == 0x006D /* m */) {
 283         return MINUTE;
 284     } else if (ch == 0x0073 /* s */) {
 285         return SECOND;
 286     }
 287     return TEXT;
 288 }
 289 
 290 inline GMTOffsetField::FieldType
 291 GMTOffsetField::getType() const {
 292      return fType;
 293  }
 294 
 295 inline uint8_t
 296 GMTOffsetField::getWidth() const {
 297     return fWidth;
 298 }
 299 
 300 inline const UChar*
 301 GMTOffsetField::getPatternText(void) const {
 302     return fText;
 303 }
 304 
 305 
 306 U_CDECL_BEGIN
 307 static void U_CALLCONV
 308 deleteGMTOffsetField(void *obj) {
 309     delete static_cast&lt;GMTOffsetField *&gt;(obj);
 310 }
 311 U_CDECL_END
 312 
 313 
 314 // ------------------------------------------------------------------
 315 // TimeZoneFormat
 316 // ------------------------------------------------------------------
 317 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(TimeZoneFormat)
 318 
 319 TimeZoneFormat::TimeZoneFormat(const Locale&amp; locale, UErrorCode&amp; status)
 320 : fLocale(locale), fTimeZoneNames(NULL), fTimeZoneGenericNames(NULL),
 321   fDefParseOptionFlags(0), fTZDBTimeZoneNames(NULL) {
 322 
 323     for (int32_t i = 0; i &lt; UTZFMT_PAT_COUNT; i++) {
 324         fGMTOffsetPatternItems[i] = NULL;
 325     }
 326 
 327     const char* region = fLocale.getCountry();
 328     int32_t regionLen = static_cast&lt;int32_t&gt;(uprv_strlen(region));
 329     if (regionLen == 0) {
 330         char loc[ULOC_FULLNAME_CAPACITY];
 331         uloc_addLikelySubtags(fLocale.getName(), loc, sizeof(loc), &amp;status);
 332 
 333         regionLen = uloc_getCountry(loc, fTargetRegion, sizeof(fTargetRegion), &amp;status);
 334         if (U_SUCCESS(status)) {
 335             fTargetRegion[regionLen] = 0;
 336         } else {
 337             return;
 338         }
 339     } else if (regionLen &lt; (int32_t)sizeof(fTargetRegion)) {
 340         uprv_strcpy(fTargetRegion, region);
 341     } else {
 342         fTargetRegion[0] = 0;
 343     }
 344 
 345     fTimeZoneNames = TimeZoneNames::createInstance(locale, status);
 346     // fTimeZoneGenericNames is lazily instantiated
 347     if (U_FAILURE(status)) {
 348         return;
 349     }
 350 
 351     const UChar* gmtPattern = NULL;
 352     const UChar* hourFormats = NULL;
 353 
 354     UResourceBundle *zoneBundle = ures_open(U_ICUDATA_ZONE, locale.getName(), &amp;status);
 355     UResourceBundle *zoneStringsArray = ures_getByKeyWithFallback(zoneBundle, gZoneStringsTag, NULL, &amp;status);
 356     if (U_SUCCESS(status)) {
 357         const UChar* resStr;
 358         int32_t len;
 359         resStr = ures_getStringByKeyWithFallback(zoneStringsArray, gGmtFormatTag, &amp;len, &amp;status);
 360         if (len &gt; 0) {
 361             gmtPattern = resStr;
 362         }
 363         resStr = ures_getStringByKeyWithFallback(zoneStringsArray, gGmtZeroFormatTag, &amp;len, &amp;status);
 364         if (len &gt; 0) {
 365             fGMTZeroFormat.setTo(TRUE, resStr, len);
 366         }
 367         resStr = ures_getStringByKeyWithFallback(zoneStringsArray, gHourFormatTag, &amp;len, &amp;status);
 368         if (len &gt; 0) {
 369             hourFormats = resStr;
 370         }
 371         ures_close(zoneStringsArray);
 372         ures_close(zoneBundle);
 373     }
 374 
 375     if (gmtPattern == NULL) {
 376         gmtPattern = DEFAULT_GMT_PATTERN;
 377     }
 378     initGMTPattern(UnicodeString(TRUE, gmtPattern, -1), status);
 379 
 380     UBool useDefaultOffsetPatterns = TRUE;
 381     if (hourFormats) {
 382         UChar *sep = u_strchr(hourFormats, (UChar)0x003B /* &#39;;&#39; */);
 383         if (sep != NULL) {
 384             UErrorCode tmpStatus = U_ZERO_ERROR;
 385             fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HM].setTo(FALSE, hourFormats, (int32_t)(sep - hourFormats));
 386             fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HM].setTo(TRUE, sep + 1, -1);
 387             expandOffsetPattern(fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HM], fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HMS], tmpStatus);
 388             expandOffsetPattern(fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HM], fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HMS], tmpStatus);
 389             truncateOffsetPattern(fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HM], fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_H], tmpStatus);
 390             truncateOffsetPattern(fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HM], fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_H], tmpStatus);
 391             if (U_SUCCESS(tmpStatus)) {
 392                 useDefaultOffsetPatterns = FALSE;
 393             }
 394         }
 395     }
 396     if (useDefaultOffsetPatterns) {
 397         fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_H].setTo(TRUE, DEFAULT_GMT_POSITIVE_H, -1);
 398         fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HM].setTo(TRUE, DEFAULT_GMT_POSITIVE_HM, -1);
 399         fGMTOffsetPatterns[UTZFMT_PAT_POSITIVE_HMS].setTo(TRUE, DEFAULT_GMT_POSITIVE_HMS, -1);
 400         fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_H].setTo(TRUE, DEFAULT_GMT_NEGATIVE_H, -1);
 401         fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HM].setTo(TRUE, DEFAULT_GMT_NEGATIVE_HM, -1);
 402         fGMTOffsetPatterns[UTZFMT_PAT_NEGATIVE_HMS].setTo(TRUE, DEFAULT_GMT_NEGATIVE_HMS, -1);
 403     }
 404     initGMTOffsetPatterns(status);
 405 
 406     NumberingSystem* ns = NumberingSystem::createInstance(locale, status);
 407     UBool useDefDigits = TRUE;
 408     if (ns &amp;&amp; !ns-&gt;isAlgorithmic()) {
 409         UnicodeString digits = ns-&gt;getDescription();
 410         useDefDigits = !toCodePoints(digits, fGMTOffsetDigits, 10);
 411     }
 412     if (useDefDigits) {
 413         uprv_memcpy(fGMTOffsetDigits, DEFAULT_GMT_DIGITS, sizeof(UChar32) * 10);
 414     }
 415     delete ns;
 416 }
 417 
 418 TimeZoneFormat::TimeZoneFormat(const TimeZoneFormat&amp; other)
 419 : Format(other), fTimeZoneNames(NULL), fTimeZoneGenericNames(NULL),
 420   fTZDBTimeZoneNames(NULL) {
 421 
 422     for (int32_t i = 0; i &lt; UTZFMT_PAT_COUNT; i++) {
 423         fGMTOffsetPatternItems[i] = NULL;
 424     }
 425     *this = other;
 426 }
 427 
 428 
 429 TimeZoneFormat::~TimeZoneFormat() {
 430     delete fTimeZoneNames;
 431     delete fTimeZoneGenericNames;
 432     delete fTZDBTimeZoneNames;
 433     for (int32_t i = 0; i &lt; UTZFMT_PAT_COUNT; i++) {
 434         delete fGMTOffsetPatternItems[i];
 435     }
 436 }
 437 
 438 TimeZoneFormat&amp;
 439 TimeZoneFormat::operator=(const TimeZoneFormat&amp; other) {
 440     if (this == &amp;other) {
 441         return *this;
 442     }
 443 
 444     delete fTimeZoneNames;
 445     delete fTimeZoneGenericNames;
 446     fTimeZoneGenericNames = NULL;
 447     delete fTZDBTimeZoneNames;
 448     fTZDBTimeZoneNames = NULL;
 449 
 450     fLocale = other.fLocale;
 451     uprv_memcpy(fTargetRegion, other.fTargetRegion, sizeof(fTargetRegion));
 452 
 453     fTimeZoneNames = other.fTimeZoneNames-&gt;clone();
 454     if (other.fTimeZoneGenericNames) {
 455         // TODO: this test has dubious thread safety.
 456         fTimeZoneGenericNames = other.fTimeZoneGenericNames-&gt;clone();
 457     }
 458 
 459     fGMTPattern = other.fGMTPattern;
 460     fGMTPatternPrefix = other.fGMTPatternPrefix;
 461     fGMTPatternSuffix = other.fGMTPatternSuffix;
 462 
 463     UErrorCode status = U_ZERO_ERROR;
 464     for (int32_t i = 0; i &lt; UTZFMT_PAT_COUNT; i++) {
 465         fGMTOffsetPatterns[i] = other.fGMTOffsetPatterns[i];
 466         delete fGMTOffsetPatternItems[i];
 467         fGMTOffsetPatternItems[i] = NULL;
 468     }
 469     initGMTOffsetPatterns(status);
 470     U_ASSERT(U_SUCCESS(status));
 471 
 472     fGMTZeroFormat = other.fGMTZeroFormat;
 473 
 474     uprv_memcpy(fGMTOffsetDigits, other.fGMTOffsetDigits, sizeof(fGMTOffsetDigits));
 475 
 476     fDefParseOptionFlags = other.fDefParseOptionFlags;
 477 
 478     return *this;
 479 }
 480 
 481 
 482 UBool
 483 TimeZoneFormat::operator==(const Format&amp; other) const {
 484     TimeZoneFormat* tzfmt = (TimeZoneFormat*)&amp;other;
 485 
 486     UBool isEqual =
 487             fLocale == tzfmt-&gt;fLocale
 488             &amp;&amp; fGMTPattern == tzfmt-&gt;fGMTPattern
 489             &amp;&amp; fGMTZeroFormat == tzfmt-&gt;fGMTZeroFormat
 490             &amp;&amp; *fTimeZoneNames == *tzfmt-&gt;fTimeZoneNames;
 491 
 492     for (int32_t i = 0; i &lt; UTZFMT_PAT_COUNT &amp;&amp; isEqual; i++) {
 493         isEqual = fGMTOffsetPatterns[i] == tzfmt-&gt;fGMTOffsetPatterns[i];
 494     }
 495     for (int32_t i = 0; i &lt; 10 &amp;&amp; isEqual; i++) {
 496         isEqual = fGMTOffsetDigits[i] == tzfmt-&gt;fGMTOffsetDigits[i];
 497     }
 498     // TODO
 499     // Check fTimeZoneGenericNames. For now,
 500     // if fTimeZoneNames is same, fTimeZoneGenericNames should
 501     // be also equivalent.
 502     return isEqual;
 503 }
 504 
 505 Format*
 506 TimeZoneFormat::clone() const {
 507     return new TimeZoneFormat(*this);
 508 }
 509 
 510 TimeZoneFormat* U_EXPORT2
 511 TimeZoneFormat::createInstance(const Locale&amp; locale, UErrorCode&amp; status) {
 512     TimeZoneFormat* tzfmt = new TimeZoneFormat(locale, status);
 513     if (U_SUCCESS(status)) {
 514         return tzfmt;
 515     }
 516     delete tzfmt;
 517     return NULL;
 518 }
 519 
 520 // ------------------------------------------------------------------
 521 // Setter and Getter
 522 
 523 const TimeZoneNames*
 524 TimeZoneFormat::getTimeZoneNames() const {
 525     return (const TimeZoneNames*)fTimeZoneNames;
 526 }
 527 
 528 void
 529 TimeZoneFormat::adoptTimeZoneNames(TimeZoneNames *tznames) {
 530     delete fTimeZoneNames;
 531     fTimeZoneNames = tznames;
 532 
 533     // TODO - We should also update fTimeZoneGenericNames
 534 }
 535 
 536 void
 537 TimeZoneFormat::setTimeZoneNames(const TimeZoneNames &amp;tznames) {
 538     delete fTimeZoneNames;
 539     fTimeZoneNames = tznames.clone();
 540 
 541     // TODO - We should also update fTimeZoneGenericNames
 542 }
 543 
 544 void
 545 TimeZoneFormat::setDefaultParseOptions(uint32_t flags) {
 546     fDefParseOptionFlags = flags;
 547 }
 548 
 549 uint32_t
 550 TimeZoneFormat::getDefaultParseOptions(void) const {
 551     return fDefParseOptionFlags;
 552 }
 553 
 554 
 555 UnicodeString&amp;
 556 TimeZoneFormat::getGMTPattern(UnicodeString&amp; pattern) const {
 557     return pattern.setTo(fGMTPattern);
 558 }
 559 
 560 void
 561 TimeZoneFormat::setGMTPattern(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
 562     initGMTPattern(pattern, status);
 563 }
 564 
 565 UnicodeString&amp;
 566 TimeZoneFormat::getGMTOffsetPattern(UTimeZoneFormatGMTOffsetPatternType type, UnicodeString&amp; pattern) const {
 567     return pattern.setTo(fGMTOffsetPatterns[type]);
 568 }
 569 
 570 void
 571 TimeZoneFormat::setGMTOffsetPattern(UTimeZoneFormatGMTOffsetPatternType type, const UnicodeString&amp; pattern, UErrorCode&amp; status) {
 572     if (U_FAILURE(status)) {
 573         return;
 574     }
 575     if (pattern == fGMTOffsetPatterns[type]) {
 576         // No need to reset
 577         return;
 578     }
 579 
 580     OffsetFields required = FIELDS_HM;
 581     switch (type) {
 582     case UTZFMT_PAT_POSITIVE_H:
 583     case UTZFMT_PAT_NEGATIVE_H:
 584         required = FIELDS_H;
 585         break;
 586     case UTZFMT_PAT_POSITIVE_HM:
 587     case UTZFMT_PAT_NEGATIVE_HM:
 588         required = FIELDS_HM;
 589         break;
 590     case UTZFMT_PAT_POSITIVE_HMS:
 591     case UTZFMT_PAT_NEGATIVE_HMS:
 592         required = FIELDS_HMS;
 593         break;
 594     default:
<a name="3" id="anc3"></a><span class="line-modified"> 595         UPRV_UNREACHABLE;</span>

 596     }
 597 
 598     UVector* patternItems = parseOffsetPattern(pattern, required, status);
 599     if (patternItems == NULL) {
 600         return;
 601     }
 602 
 603     fGMTOffsetPatterns[type].setTo(pattern);
 604     delete fGMTOffsetPatternItems[type];
 605     fGMTOffsetPatternItems[type] = patternItems;
 606     checkAbuttingHoursAndMinutes();
 607 }
 608 
 609 UnicodeString&amp;
 610 TimeZoneFormat::getGMTOffsetDigits(UnicodeString&amp; digits) const {
 611     digits.remove();
 612     for (int32_t i = 0; i &lt; 10; i++) {
 613         digits.append(fGMTOffsetDigits[i]);
 614     }
 615     return digits;
 616 }
 617 
 618 void
 619 TimeZoneFormat::setGMTOffsetDigits(const UnicodeString&amp; digits, UErrorCode&amp; status) {
 620     if (U_FAILURE(status)) {
 621         return;
 622     }
 623     UChar32 digitArray[10];
 624     if (!toCodePoints(digits, digitArray, 10)) {
 625         status = U_ILLEGAL_ARGUMENT_ERROR;
 626         return;
 627     }
 628     uprv_memcpy(fGMTOffsetDigits, digitArray, sizeof(UChar32)*10);
 629 }
 630 
 631 UnicodeString&amp;
 632 TimeZoneFormat::getGMTZeroFormat(UnicodeString&amp; gmtZeroFormat) const {
 633     return gmtZeroFormat.setTo(fGMTZeroFormat);
 634 }
 635 
 636 void
 637 TimeZoneFormat::setGMTZeroFormat(const UnicodeString&amp; gmtZeroFormat, UErrorCode&amp; status) {
 638     if (U_SUCCESS(status)) {
 639         if (gmtZeroFormat.isEmpty()) {
 640             status = U_ILLEGAL_ARGUMENT_ERROR;
 641         } else if (gmtZeroFormat != fGMTZeroFormat) {
 642             fGMTZeroFormat.setTo(gmtZeroFormat);
 643         }
 644     }
 645 }
 646 
 647 // ------------------------------------------------------------------
 648 // Format and Parse
 649 
 650 UnicodeString&amp;
 651 TimeZoneFormat::format(UTimeZoneFormatStyle style, const TimeZone&amp; tz, UDate date,
 652         UnicodeString&amp; name, UTimeZoneFormatTimeType* timeType /* = NULL */) const {
 653     if (timeType) {
 654         *timeType = UTZFMT_TIME_TYPE_UNKNOWN;
 655     }
 656 
 657     UBool noOffsetFormatFallback = FALSE;
 658 
 659     switch (style) {
 660     case UTZFMT_STYLE_GENERIC_LOCATION:
 661         formatGeneric(tz, UTZGNM_LOCATION, date, name);
 662         break;
 663     case UTZFMT_STYLE_GENERIC_LONG:
 664         formatGeneric(tz, UTZGNM_LONG, date, name);
 665         break;
 666     case UTZFMT_STYLE_GENERIC_SHORT:
 667         formatGeneric(tz, UTZGNM_SHORT, date, name);
 668         break;
 669     case UTZFMT_STYLE_SPECIFIC_LONG:
 670         formatSpecific(tz, UTZNM_LONG_STANDARD, UTZNM_LONG_DAYLIGHT, date, name, timeType);
 671         break;
 672     case UTZFMT_STYLE_SPECIFIC_SHORT:
 673         formatSpecific(tz, UTZNM_SHORT_STANDARD, UTZNM_SHORT_DAYLIGHT, date, name, timeType);
 674         break;
 675 
 676     case UTZFMT_STYLE_ZONE_ID:
 677         tz.getID(name);
 678         noOffsetFormatFallback = TRUE;
 679         break;
 680     case UTZFMT_STYLE_ZONE_ID_SHORT:
 681         {
 682             const UChar* shortID = ZoneMeta::getShortID(tz);
 683             if (shortID == NULL) {
 684                 shortID = UNKNOWN_SHORT_ZONE_ID;
 685             }
 686             name.setTo(shortID, -1);
 687         }
 688         noOffsetFormatFallback = TRUE;
 689         break;
 690 
 691     case UTZFMT_STYLE_EXEMPLAR_LOCATION:
 692         formatExemplarLocation(tz, name);
 693         noOffsetFormatFallback = TRUE;
 694         break;
 695 
 696     default:
 697         // will be handled below
 698         break;
 699     }
 700 
 701     if (name.isEmpty() &amp;&amp; !noOffsetFormatFallback) {
 702         UErrorCode status = U_ZERO_ERROR;
 703         int32_t rawOffset, dstOffset;
 704         tz.getOffset(date, FALSE, rawOffset, dstOffset, status);
 705         int32_t offset = rawOffset + dstOffset;
 706         if (U_SUCCESS(status)) {
 707             switch (style) {
 708             case UTZFMT_STYLE_GENERIC_LOCATION:
 709             case UTZFMT_STYLE_GENERIC_LONG:
 710             case UTZFMT_STYLE_SPECIFIC_LONG:
 711             case UTZFMT_STYLE_LOCALIZED_GMT:
 712                 formatOffsetLocalizedGMT(offset, name, status);
 713                 break;
 714 
 715             case UTZFMT_STYLE_GENERIC_SHORT:
 716             case UTZFMT_STYLE_SPECIFIC_SHORT:
 717             case UTZFMT_STYLE_LOCALIZED_GMT_SHORT:
 718                 formatOffsetShortLocalizedGMT(offset, name, status);
 719                 break;
 720 
 721             case UTZFMT_STYLE_ISO_BASIC_SHORT:
 722                 formatOffsetISO8601Basic(offset, TRUE, TRUE, TRUE, name, status);
 723                 break;
 724 
 725             case UTZFMT_STYLE_ISO_BASIC_LOCAL_SHORT:
 726                 formatOffsetISO8601Basic(offset, FALSE, TRUE, TRUE, name, status);
 727                 break;
 728 
 729             case UTZFMT_STYLE_ISO_BASIC_FIXED:
 730                 formatOffsetISO8601Basic(offset, TRUE, FALSE, TRUE, name, status);
 731                 break;
 732 
 733             case UTZFMT_STYLE_ISO_BASIC_LOCAL_FIXED:
 734                 formatOffsetISO8601Basic(offset, FALSE, FALSE, TRUE, name, status);
 735                 break;
 736 
 737             case UTZFMT_STYLE_ISO_EXTENDED_FIXED:
 738                 formatOffsetISO8601Extended(offset, TRUE, FALSE, TRUE, name, status);
 739                 break;
 740 
 741             case UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FIXED:
 742                 formatOffsetISO8601Extended(offset, FALSE, FALSE, TRUE, name, status);
 743                 break;
 744 
 745             case UTZFMT_STYLE_ISO_BASIC_FULL:
 746                 formatOffsetISO8601Basic(offset, TRUE, FALSE, FALSE, name, status);
 747                 break;
 748 
 749             case UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL:
 750                 formatOffsetISO8601Basic(offset, FALSE, FALSE, FALSE, name, status);
 751                 break;
 752 
 753             case UTZFMT_STYLE_ISO_EXTENDED_FULL:
 754                 formatOffsetISO8601Extended(offset, TRUE, FALSE, FALSE, name, status);
 755                 break;
 756 
 757             case UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FULL:
 758                 formatOffsetISO8601Extended(offset, FALSE, FALSE, FALSE, name, status);
 759                 break;
 760 
 761             default:
 762               // UTZFMT_STYLE_ZONE_ID, UTZFMT_STYLE_ZONE_ID_SHORT, UTZFMT_STYLE_EXEMPLAR_LOCATION
 763               break;
 764             }
 765 
 766             if (timeType) {
 767                 *timeType = (dstOffset != 0) ? UTZFMT_TIME_TYPE_DAYLIGHT : UTZFMT_TIME_TYPE_STANDARD;
 768             }
 769         }
 770     }
 771 
 772     return name;
 773 }
 774 
 775 UnicodeString&amp;
 776 TimeZoneFormat::format(const Formattable&amp; obj, UnicodeString&amp; appendTo,
 777         FieldPosition&amp; pos, UErrorCode&amp; status) const {
 778     if (U_FAILURE(status)) {
 779         return appendTo;
 780     }
 781     UDate date = Calendar::getNow();
 782     if (obj.getType() == Formattable::kObject) {
 783         const UObject* formatObj = obj.getObject();
 784         const TimeZone* tz = dynamic_cast&lt;const TimeZone*&gt;(formatObj);
 785         if (tz == NULL) {
 786             const Calendar* cal = dynamic_cast&lt;const Calendar*&gt;(formatObj);
 787             if (cal != NULL) {
 788                 tz = &amp;cal-&gt;getTimeZone();
 789                 date = cal-&gt;getTime(status);
 790             }
 791         }
 792         if (tz != NULL) {
 793             int32_t rawOffset, dstOffset;
 794             tz-&gt;getOffset(date, FALSE, rawOffset, dstOffset, status);
 795             UChar buf[ZONE_NAME_U16_MAX];
 796             UnicodeString result(buf, 0, UPRV_LENGTHOF(buf));
 797             formatOffsetLocalizedGMT(rawOffset + dstOffset, result, status);
 798             if (U_SUCCESS(status)) {
 799                 appendTo.append(result);
 800                 if (pos.getField() == UDAT_TIMEZONE_FIELD) {
 801                     pos.setBeginIndex(0);
 802                     pos.setEndIndex(result.length());
 803                 }
 804             }
 805         }
 806     }
 807     return appendTo;
 808 }
 809 
 810 TimeZone*
 811 TimeZoneFormat::parse(UTimeZoneFormatStyle style, const UnicodeString&amp; text, ParsePosition&amp; pos,
 812         UTimeZoneFormatTimeType* timeType /*= NULL*/) const {
 813     return parse(style, text, pos, getDefaultParseOptions(), timeType);
 814 }
 815 
 816 TimeZone*
 817 TimeZoneFormat::parse(UTimeZoneFormatStyle style, const UnicodeString&amp; text, ParsePosition&amp; pos,
 818         int32_t parseOptions, UTimeZoneFormatTimeType* timeType /* = NULL */) const {
 819     if (timeType) {
 820         *timeType = UTZFMT_TIME_TYPE_UNKNOWN;
 821     }
 822 
 823     int32_t startIdx = pos.getIndex();
 824     int32_t maxPos = text.length();
 825     int32_t offset;
 826 
 827     // Styles using localized GMT format as fallback
 828     UBool fallbackLocalizedGMT =
 829         (style == UTZFMT_STYLE_SPECIFIC_LONG || style == UTZFMT_STYLE_GENERIC_LONG || style == UTZFMT_STYLE_GENERIC_LOCATION);
 830     UBool fallbackShortLocalizedGMT =
 831         (style == UTZFMT_STYLE_SPECIFIC_SHORT || style == UTZFMT_STYLE_GENERIC_SHORT);
 832 
 833     int32_t evaluated = 0;  // bit flags representing already evaluated styles
 834     ParsePosition tmpPos(startIdx);
 835 
 836     int32_t parsedOffset = UNKNOWN_OFFSET;  // stores successfully parsed offset for later use
 837     int32_t parsedPos = -1;                 // stores successfully parsed offset position for later use
 838 
 839     // Try localized GMT format first if necessary
 840     if (fallbackLocalizedGMT || fallbackShortLocalizedGMT) {
 841         UBool hasDigitOffset = FALSE;
 842         offset = parseOffsetLocalizedGMT(text, tmpPos, fallbackShortLocalizedGMT, &amp;hasDigitOffset);
 843         if (tmpPos.getErrorIndex() == -1) {
 844             // Even when the input text was successfully parsed as a localized GMT format text,
 845             // we may still need to evaluate the specified style if -
 846             //   1) GMT zero format was used, and
 847             //   2) The input text was not completely processed
 848             if (tmpPos.getIndex() == maxPos || hasDigitOffset) {
 849                 pos.setIndex(tmpPos.getIndex());
 850                 return createTimeZoneForOffset(offset);
 851             }
 852             parsedOffset = offset;
 853             parsedPos = tmpPos.getIndex();
 854         }
 855         // Note: For now, no distinction between long/short localized GMT format in the parser.
 856         // This might be changed in future.
 857         // evaluated |= (fallbackLocalizedGMT ? STYLE_PARSE_FLAGS[UTZFMT_STYLE_LOCALIZED_GMT] : STYLE_PARSE_FLAGS[UTZFMT_STYLE_LOCALIZED_GMT_SHORT]);
 858         evaluated |= STYLE_PARSE_FLAGS[UTZFMT_STYLE_LOCALIZED_GMT] | STYLE_PARSE_FLAGS[UTZFMT_STYLE_LOCALIZED_GMT_SHORT];
 859     }
 860 
 861     UErrorCode status = U_ZERO_ERROR;
 862     UChar tzIDBuf[32];
 863     UnicodeString tzID(tzIDBuf, 0, UPRV_LENGTHOF(tzIDBuf));
 864 
 865     UBool parseTZDBAbbrev = ((parseOptions &amp; UTZFMT_PARSE_OPTION_TZ_DATABASE_ABBREVIATIONS) != 0);
 866 
 867     // Try the specified style
 868     switch (style) {
 869     case UTZFMT_STYLE_LOCALIZED_GMT:
 870         {
 871             tmpPos.setIndex(startIdx);
 872             tmpPos.setErrorIndex(-1);
 873 
 874             offset = parseOffsetLocalizedGMT(text, tmpPos);
 875             if (tmpPos.getErrorIndex() == -1) {
 876                 pos.setIndex(tmpPos.getIndex());
 877                 return createTimeZoneForOffset(offset);
 878             }
 879 
 880             // Note: For now, no distinction between long/short localized GMT format in the parser.
 881             // This might be changed in future.
 882             evaluated |= STYLE_PARSE_FLAGS[UTZFMT_STYLE_LOCALIZED_GMT_SHORT];
 883 
 884             break;
 885         }
 886     case UTZFMT_STYLE_LOCALIZED_GMT_SHORT:
 887         {
 888             tmpPos.setIndex(startIdx);
 889             tmpPos.setErrorIndex(-1);
 890 
 891             offset = parseOffsetShortLocalizedGMT(text, tmpPos);
 892             if (tmpPos.getErrorIndex() == -1) {
 893                 pos.setIndex(tmpPos.getIndex());
 894                 return createTimeZoneForOffset(offset);
 895             }
 896 
 897             // Note: For now, no distinction between long/short localized GMT format in the parser.
 898             // This might be changed in future.
 899             evaluated |= STYLE_PARSE_FLAGS[UTZFMT_STYLE_LOCALIZED_GMT];
 900 
 901             break;
 902         }
 903     case UTZFMT_STYLE_ISO_BASIC_SHORT:
 904     case UTZFMT_STYLE_ISO_BASIC_FIXED:
 905     case UTZFMT_STYLE_ISO_BASIC_FULL:
 906     case UTZFMT_STYLE_ISO_EXTENDED_FIXED:
 907     case UTZFMT_STYLE_ISO_EXTENDED_FULL:
 908         {
 909             tmpPos.setIndex(startIdx);
 910             tmpPos.setErrorIndex(-1);
 911 
 912             offset = parseOffsetISO8601(text, tmpPos);
 913             if (tmpPos.getErrorIndex() == -1) {
 914                 pos.setIndex(tmpPos.getIndex());
 915                 return createTimeZoneForOffset(offset);
 916             }
 917 
 918             break;
 919         }
 920 
 921     case UTZFMT_STYLE_ISO_BASIC_LOCAL_SHORT:
 922     case UTZFMT_STYLE_ISO_BASIC_LOCAL_FIXED:
 923     case UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL:
 924     case UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FIXED:
 925     case UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FULL:
 926         {
 927             tmpPos.setIndex(startIdx);
 928             tmpPos.setErrorIndex(-1);
 929 
 930             // Exclude the case of UTC Indicator &quot;Z&quot; here
 931             UBool hasDigitOffset = FALSE;
 932             offset = parseOffsetISO8601(text, tmpPos, FALSE, &amp;hasDigitOffset);
 933             if (tmpPos.getErrorIndex() == -1 &amp;&amp; hasDigitOffset) {
 934                 pos.setIndex(tmpPos.getIndex());
 935                 return createTimeZoneForOffset(offset);
 936             }
 937 
 938             break;
 939         }
 940 
 941     case UTZFMT_STYLE_SPECIFIC_LONG:
 942     case UTZFMT_STYLE_SPECIFIC_SHORT:
 943         {
 944             // Specific styles
 945             int32_t nameTypes = 0;
 946             if (style == UTZFMT_STYLE_SPECIFIC_LONG) {
 947                 nameTypes = (UTZNM_LONG_STANDARD | UTZNM_LONG_DAYLIGHT);
 948             } else {
 949                 U_ASSERT(style == UTZFMT_STYLE_SPECIFIC_SHORT);
 950                 nameTypes = (UTZNM_SHORT_STANDARD | UTZNM_SHORT_DAYLIGHT);
 951             }
 952             LocalPointer&lt;TimeZoneNames::MatchInfoCollection&gt; specificMatches(fTimeZoneNames-&gt;find(text, startIdx, nameTypes, status));
 953             if (U_FAILURE(status)) {
 954                 pos.setErrorIndex(startIdx);
 955                 return NULL;
 956             }
 957             if (!specificMatches.isNull()) {
 958                 int32_t matchIdx = -1;
 959                 int32_t matchPos = -1;
 960                 for (int32_t i = 0; i &lt; specificMatches-&gt;size(); i++) {
 961                     matchPos  = startIdx + specificMatches-&gt;getMatchLengthAt(i);
 962                     if (matchPos &gt; parsedPos) {
 963                         matchIdx = i;
 964                         parsedPos = matchPos;
 965                     }
 966                 }
 967                 if (matchIdx &gt;= 0) {
 968                     if (timeType) {
 969                         *timeType = getTimeType(specificMatches-&gt;getNameTypeAt(matchIdx));
 970                     }
 971                     pos.setIndex(matchPos);
 972                     getTimeZoneID(specificMatches.getAlias(), matchIdx, tzID);
 973                     U_ASSERT(!tzID.isEmpty());
 974                     return TimeZone::createTimeZone(tzID);
 975                 }
 976             }
 977 
 978             if (parseTZDBAbbrev &amp;&amp; style == UTZFMT_STYLE_SPECIFIC_SHORT) {
 979                 U_ASSERT((nameTypes &amp; UTZNM_SHORT_STANDARD) != 0);
 980                 U_ASSERT((nameTypes &amp; UTZNM_SHORT_DAYLIGHT) != 0);
 981 
 982                 const TZDBTimeZoneNames *tzdbTimeZoneNames = getTZDBTimeZoneNames(status);
 983                 if (U_SUCCESS(status)) {
 984                     LocalPointer&lt;TimeZoneNames::MatchInfoCollection&gt; tzdbNameMatches(
 985                         tzdbTimeZoneNames-&gt;find(text, startIdx, nameTypes, status));
 986                     if (U_FAILURE(status)) {
 987                         pos.setErrorIndex(startIdx);
 988                         return NULL;
 989                     }
 990                     if (!tzdbNameMatches.isNull()) {
 991                         int32_t matchIdx = -1;
 992                         int32_t matchPos = -1;
 993                         for (int32_t i = 0; i &lt; tzdbNameMatches-&gt;size(); i++) {
 994                             matchPos = startIdx + tzdbNameMatches-&gt;getMatchLengthAt(i);
 995                             if (matchPos &gt; parsedPos) {
 996                                 matchIdx = i;
 997                                 parsedPos = matchPos;
 998                             }
 999                         }
1000                         if (matchIdx &gt;= 0) {
1001                             if (timeType) {
1002                                 *timeType = getTimeType(tzdbNameMatches-&gt;getNameTypeAt(matchIdx));
1003                             }
1004                             pos.setIndex(matchPos);
1005                             getTimeZoneID(tzdbNameMatches.getAlias(), matchIdx, tzID);
1006                             U_ASSERT(!tzID.isEmpty());
1007                             return TimeZone::createTimeZone(tzID);
1008                         }
1009                     }
1010                 }
1011             }
1012             break;
1013         }
1014     case UTZFMT_STYLE_GENERIC_LONG:
1015     case UTZFMT_STYLE_GENERIC_SHORT:
1016     case UTZFMT_STYLE_GENERIC_LOCATION:
1017         {
1018             int32_t genericNameTypes = 0;
1019             switch (style) {
1020             case UTZFMT_STYLE_GENERIC_LOCATION:
1021                 genericNameTypes = UTZGNM_LOCATION;
1022                 break;
1023 
1024             case UTZFMT_STYLE_GENERIC_LONG:
1025                 genericNameTypes = UTZGNM_LONG | UTZGNM_LOCATION;
1026                 break;
1027 
1028             case UTZFMT_STYLE_GENERIC_SHORT:
1029                 genericNameTypes = UTZGNM_SHORT | UTZGNM_LOCATION;
1030                 break;
1031 
1032             default:
<a name="4" id="anc4"></a><span class="line-modified">1033                 UPRV_UNREACHABLE;</span>
1034             }
1035 
1036             int32_t len = 0;
1037             UTimeZoneFormatTimeType tt = UTZFMT_TIME_TYPE_UNKNOWN;
1038             const TimeZoneGenericNames *gnames = getTimeZoneGenericNames(status);
1039             if (U_SUCCESS(status)) {
1040                 len = gnames-&gt;findBestMatch(text, startIdx, genericNameTypes, tzID, tt, status);
1041             }
1042             if (U_FAILURE(status)) {
1043                 pos.setErrorIndex(startIdx);
1044                 return NULL;
1045             }
1046             if (len &gt; 0) {
1047                 // Found a match
1048                 if (timeType) {
1049                     *timeType = tt;
1050                 }
1051                 pos.setIndex(startIdx + len);
1052                 U_ASSERT(!tzID.isEmpty());
1053                 return TimeZone::createTimeZone(tzID);
1054             }
1055 
1056             break;
1057         }
1058     case UTZFMT_STYLE_ZONE_ID:
1059         {
1060             tmpPos.setIndex(startIdx);
1061             tmpPos.setErrorIndex(-1);
1062 
1063             parseZoneID(text, tmpPos, tzID);
1064             if (tmpPos.getErrorIndex() == -1) {
1065                 pos.setIndex(tmpPos.getIndex());
1066                 return TimeZone::createTimeZone(tzID);
1067             }
1068             break;
1069         }
1070     case UTZFMT_STYLE_ZONE_ID_SHORT:
1071         {
1072             tmpPos.setIndex(startIdx);
1073             tmpPos.setErrorIndex(-1);
1074 
1075             parseShortZoneID(text, tmpPos, tzID);
1076             if (tmpPos.getErrorIndex() == -1) {
1077                 pos.setIndex(tmpPos.getIndex());
1078                 return TimeZone::createTimeZone(tzID);
1079             }
1080             break;
1081         }
1082     case UTZFMT_STYLE_EXEMPLAR_LOCATION:
1083         {
1084             tmpPos.setIndex(startIdx);
1085             tmpPos.setErrorIndex(-1);
1086 
1087             parseExemplarLocation(text, tmpPos, tzID);
1088             if (tmpPos.getErrorIndex() == -1) {
1089                 pos.setIndex(tmpPos.getIndex());
1090                 return TimeZone::createTimeZone(tzID);
1091             }
1092             break;
1093         }
1094     }
1095     evaluated |= STYLE_PARSE_FLAGS[style];
1096 
1097 
1098     if (parsedPos &gt; startIdx) {
1099         // When the specified style is one of SPECIFIC_XXX or GENERIC_XXX, we tried to parse the input
1100         // as localized GMT format earlier. If parsedOffset is positive, it means it was successfully
1101         // parsed as localized GMT format, but offset digits were not detected (more specifically, GMT
1102         // zero format). Then, it tried to find a match within the set of display names, but could not
1103         // find a match. At this point, we can safely assume the input text contains the localized
1104         // GMT format.
1105         U_ASSERT(parsedOffset != UNKNOWN_OFFSET);
1106         pos.setIndex(parsedPos);
1107         return createTimeZoneForOffset(parsedOffset);
1108     }
1109 
1110     // Failed to parse the input text as the time zone format in the specified style.
1111     // Check the longest match among other styles below.
1112     UChar parsedIDBuf[32];
1113     UnicodeString parsedID(parsedIDBuf, 0, UPRV_LENGTHOF(parsedIDBuf));
1114     UTimeZoneFormatTimeType parsedTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
1115 
1116     U_ASSERT(parsedPos &lt; 0);
1117     U_ASSERT(parsedOffset == UNKNOWN_OFFSET);
1118 
1119     // ISO 8601
1120     if (parsedPos &lt; maxPos &amp;&amp;
1121         ((evaluated &amp; ISO_Z_STYLE_FLAG) == 0 || (evaluated &amp; ISO_LOCAL_STYLE_FLAG) == 0)) {
1122         tmpPos.setIndex(startIdx);
1123         tmpPos.setErrorIndex(-1);
1124 
1125         UBool hasDigitOffset = FALSE;
1126         offset = parseOffsetISO8601(text, tmpPos, FALSE, &amp;hasDigitOffset);
1127         if (tmpPos.getErrorIndex() == -1) {
1128             if (tmpPos.getIndex() == maxPos || hasDigitOffset) {
1129                 pos.setIndex(tmpPos.getIndex());
1130                 return createTimeZoneForOffset(offset);
1131             }
1132             // Note: When ISO 8601 format contains offset digits, it should not
1133             // collide with other formats. However, ISO 8601 UTC format &quot;Z&quot; (single letter)
1134             // may collide with other names. In this case, we need to evaluate other names.
1135             if (parsedPos &lt; tmpPos.getIndex()) {
1136                 parsedOffset = offset;
1137                 parsedID.setToBogus();
1138                 parsedTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
1139                 parsedPos = tmpPos.getIndex();
1140                 U_ASSERT(parsedPos == startIdx + 1);    // only when &quot;Z&quot; is used
1141             }
1142         }
1143     }
1144 
1145     // Localized GMT format
1146     if (parsedPos &lt; maxPos &amp;&amp;
1147         (evaluated &amp; STYLE_PARSE_FLAGS[UTZFMT_STYLE_LOCALIZED_GMT]) == 0) {
1148         tmpPos.setIndex(startIdx);
1149         tmpPos.setErrorIndex(-1);
1150 
1151         UBool hasDigitOffset = FALSE;
1152         offset = parseOffsetLocalizedGMT(text, tmpPos, FALSE, &amp;hasDigitOffset);
1153         if (tmpPos.getErrorIndex() == -1) {
1154             if (tmpPos.getIndex() == maxPos || hasDigitOffset) {
1155                 pos.setIndex(tmpPos.getIndex());
1156                 return createTimeZoneForOffset(offset);
1157             }
1158             // Evaluate other names - see the comment earlier in this method.
1159             if (parsedPos &lt; tmpPos.getIndex()) {
1160                 parsedOffset = offset;
1161                 parsedID.setToBogus();
1162                 parsedTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
1163                 parsedPos = tmpPos.getIndex();
1164             }
1165         }
1166     }
1167 
1168     if (parsedPos &lt; maxPos &amp;&amp;
1169         (evaluated &amp; STYLE_PARSE_FLAGS[UTZFMT_STYLE_LOCALIZED_GMT_SHORT]) == 0) {
1170         tmpPos.setIndex(startIdx);
1171         tmpPos.setErrorIndex(-1);
1172 
1173         UBool hasDigitOffset = FALSE;
1174         offset = parseOffsetLocalizedGMT(text, tmpPos, TRUE, &amp;hasDigitOffset);
1175         if (tmpPos.getErrorIndex() == -1) {
1176             if (tmpPos.getIndex() == maxPos || hasDigitOffset) {
1177                 pos.setIndex(tmpPos.getIndex());
1178                 return createTimeZoneForOffset(offset);
1179             }
1180             // Evaluate other names - see the comment earlier in this method.
1181             if (parsedPos &lt; tmpPos.getIndex()) {
1182                 parsedOffset = offset;
1183                 parsedID.setToBogus();
1184                 parsedTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
1185                 parsedPos = tmpPos.getIndex();
1186             }
1187         }
1188     }
1189 
1190     // When ParseOption.ALL_STYLES is available, we also try to look all possible display names and IDs.
1191     // For example, when style is GENERIC_LONG, &quot;EST&quot; (SPECIFIC_SHORT) is never
1192     // used for America/New_York. With parseAllStyles true, this code parses &quot;EST&quot;
1193     // as America/New_York.
1194 
1195     // Note: Adding all possible names into the trie used by the implementation is quite heavy operation,
1196     // which we want to avoid normally (note that we cache the trie, so this is applicable to the
1197     // first time only as long as the cache does not expire).
1198 
1199     if (parseOptions &amp; UTZFMT_PARSE_OPTION_ALL_STYLES) {
1200         // Try all specific names and exemplar location names
1201         if (parsedPos &lt; maxPos) {
1202             LocalPointer&lt;TimeZoneNames::MatchInfoCollection&gt; specificMatches(fTimeZoneNames-&gt;find(text, startIdx, ALL_SIMPLE_NAME_TYPES, status));
1203             if (U_FAILURE(status)) {
1204                 pos.setErrorIndex(startIdx);
1205                 return NULL;
1206             }
1207             int32_t specificMatchIdx = -1;
1208             int32_t matchPos = -1;
1209             if (!specificMatches.isNull()) {
1210                 for (int32_t i = 0; i &lt; specificMatches-&gt;size(); i++) {
1211                     if (startIdx + specificMatches-&gt;getMatchLengthAt(i) &gt; matchPos) {
1212                         specificMatchIdx = i;
1213                         matchPos = startIdx + specificMatches-&gt;getMatchLengthAt(i);
1214                     }
1215                 }
1216             }
1217             if (parsedPos &lt; matchPos) {
1218                 U_ASSERT(specificMatchIdx &gt;= 0);
1219                 parsedPos = matchPos;
1220                 getTimeZoneID(specificMatches.getAlias(), specificMatchIdx, parsedID);
1221                 parsedTimeType = getTimeType(specificMatches-&gt;getNameTypeAt(specificMatchIdx));
1222                 parsedOffset = UNKNOWN_OFFSET;
1223             }
1224         }
1225         if (parseTZDBAbbrev &amp;&amp; parsedPos &lt; maxPos &amp;&amp; (evaluated &amp; STYLE_PARSE_FLAGS[UTZFMT_STYLE_SPECIFIC_SHORT]) == 0) {
1226             const TZDBTimeZoneNames *tzdbTimeZoneNames = getTZDBTimeZoneNames(status);
1227             if (U_SUCCESS(status)) {
1228                 LocalPointer&lt;TimeZoneNames::MatchInfoCollection&gt; tzdbNameMatches(
1229                     tzdbTimeZoneNames-&gt;find(text, startIdx, ALL_SIMPLE_NAME_TYPES, status));
1230                 if (U_FAILURE(status)) {
1231                     pos.setErrorIndex(startIdx);
1232                     return NULL;
1233                 }
1234                 int32_t tzdbNameMatchIdx = -1;
1235                 int32_t matchPos = -1;
1236                 if (!tzdbNameMatches.isNull()) {
1237                     for (int32_t i = 0; i &lt; tzdbNameMatches-&gt;size(); i++) {
1238                         if (startIdx + tzdbNameMatches-&gt;getMatchLengthAt(i) &gt; matchPos) {
1239                             tzdbNameMatchIdx = i;
1240                             matchPos = startIdx + tzdbNameMatches-&gt;getMatchLengthAt(i);
1241                         }
1242                     }
1243                 }
1244                 if (parsedPos &lt; matchPos) {
1245                     U_ASSERT(tzdbNameMatchIdx &gt;= 0);
1246                     parsedPos = matchPos;
1247                     getTimeZoneID(tzdbNameMatches.getAlias(), tzdbNameMatchIdx, parsedID);
1248                     parsedTimeType = getTimeType(tzdbNameMatches-&gt;getNameTypeAt(tzdbNameMatchIdx));
1249                     parsedOffset = UNKNOWN_OFFSET;
1250                 }
1251             }
1252         }
1253         // Try generic names
1254         if (parsedPos &lt; maxPos) {
1255             int32_t genMatchLen = -1;
1256             UTimeZoneFormatTimeType tt = UTZFMT_TIME_TYPE_UNKNOWN;
1257 
1258             const TimeZoneGenericNames *gnames = getTimeZoneGenericNames(status);
1259             if (U_SUCCESS(status)) {
1260                 genMatchLen = gnames-&gt;findBestMatch(text, startIdx, ALL_GENERIC_NAME_TYPES, tzID, tt, status);
1261             }
1262             if (U_FAILURE(status)) {
1263                 pos.setErrorIndex(startIdx);
1264                 return NULL;
1265             }
1266 
1267             if (genMatchLen &gt; 0 &amp;&amp; parsedPos &lt; startIdx + genMatchLen) {
1268                 parsedPos = startIdx + genMatchLen;
1269                 parsedID.setTo(tzID);
1270                 parsedTimeType = tt;
1271                 parsedOffset = UNKNOWN_OFFSET;
1272             }
1273         }
1274 
1275         // Try time zone ID
1276         if (parsedPos &lt; maxPos &amp;&amp; (evaluated &amp; STYLE_PARSE_FLAGS[UTZFMT_STYLE_ZONE_ID]) == 0) {
1277             tmpPos.setIndex(startIdx);
1278             tmpPos.setErrorIndex(-1);
1279 
1280             parseZoneID(text, tmpPos, tzID);
1281             if (tmpPos.getErrorIndex() == -1 &amp;&amp; parsedPos &lt; tmpPos.getIndex()) {
1282                 parsedPos = tmpPos.getIndex();
1283                 parsedID.setTo(tzID);
1284                 parsedTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
1285                 parsedOffset = UNKNOWN_OFFSET;
1286             }
1287         }
1288         // Try short time zone ID
1289         if (parsedPos &lt; maxPos &amp;&amp; (evaluated &amp; STYLE_PARSE_FLAGS[UTZFMT_STYLE_ZONE_ID]) == 0) {
1290             tmpPos.setIndex(startIdx);
1291             tmpPos.setErrorIndex(-1);
1292 
1293             parseShortZoneID(text, tmpPos, tzID);
1294             if (tmpPos.getErrorIndex() == -1 &amp;&amp; parsedPos &lt; tmpPos.getIndex()) {
1295                 parsedPos = tmpPos.getIndex();
1296                 parsedID.setTo(tzID);
1297                 parsedTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
1298                 parsedOffset = UNKNOWN_OFFSET;
1299             }
1300         }
1301     }
1302 
1303     if (parsedPos &gt; startIdx) {
1304         // Parsed successfully
1305         TimeZone* parsedTZ;
1306         if (parsedID.length() &gt; 0) {
1307             parsedTZ = TimeZone::createTimeZone(parsedID);
1308         } else {
1309             U_ASSERT(parsedOffset != UNKNOWN_OFFSET);
1310             parsedTZ = createTimeZoneForOffset(parsedOffset);
1311         }
1312         if (timeType) {
1313             *timeType = parsedTimeType;
1314         }
1315         pos.setIndex(parsedPos);
1316         return parsedTZ;
1317     }
1318 
1319     pos.setErrorIndex(startIdx);
1320     return NULL;
1321 }
1322 
1323 void
1324 TimeZoneFormat::parseObject(const UnicodeString&amp; source, Formattable&amp; result,
1325         ParsePosition&amp; parse_pos) const {
1326     result.adoptObject(parse(UTZFMT_STYLE_GENERIC_LOCATION, source, parse_pos, UTZFMT_PARSE_OPTION_ALL_STYLES));
1327 }
1328 
1329 
1330 // ------------------------------------------------------------------
1331 // Private zone name format/parse implementation
1332 
1333 UnicodeString&amp;
1334 TimeZoneFormat::formatGeneric(const TimeZone&amp; tz, int32_t genType, UDate date, UnicodeString&amp; name) const {
1335     UErrorCode status = U_ZERO_ERROR;
1336     const TimeZoneGenericNames* gnames = getTimeZoneGenericNames(status);
1337     if (U_FAILURE(status)) {
1338         name.setToBogus();
1339         return name;
1340     }
1341 
1342     if (genType == UTZGNM_LOCATION) {
1343         const UChar* canonicalID = ZoneMeta::getCanonicalCLDRID(tz);
1344         if (canonicalID == NULL) {
1345             name.setToBogus();
1346             return name;
1347         }
1348         return gnames-&gt;getGenericLocationName(UnicodeString(TRUE, canonicalID, -1), name);
1349     }
1350     return gnames-&gt;getDisplayName(tz, (UTimeZoneGenericNameType)genType, date, name);
1351 }
1352 
1353 UnicodeString&amp;
1354 TimeZoneFormat::formatSpecific(const TimeZone&amp; tz, UTimeZoneNameType stdType, UTimeZoneNameType dstType,
1355         UDate date, UnicodeString&amp; name, UTimeZoneFormatTimeType *timeType) const {
1356     if (fTimeZoneNames == NULL) {
1357         name.setToBogus();
1358         return name;
1359     }
1360 
1361     UErrorCode status = U_ZERO_ERROR;
1362     UBool isDaylight = tz.inDaylightTime(date, status);
1363     const UChar* canonicalID = ZoneMeta::getCanonicalCLDRID(tz);
1364 
1365     if (U_FAILURE(status) || canonicalID == NULL) {
1366         name.setToBogus();
1367         return name;
1368     }
1369 
1370     if (isDaylight) {
1371         fTimeZoneNames-&gt;getDisplayName(UnicodeString(TRUE, canonicalID, -1), dstType, date, name);
1372     } else {
1373         fTimeZoneNames-&gt;getDisplayName(UnicodeString(TRUE, canonicalID, -1), stdType, date, name);
1374     }
1375 
1376     if (timeType &amp;&amp; !name.isEmpty()) {
1377         *timeType = isDaylight ? UTZFMT_TIME_TYPE_DAYLIGHT : UTZFMT_TIME_TYPE_STANDARD;
1378     }
1379     return name;
1380 }
1381 
1382 const TimeZoneGenericNames*
1383 TimeZoneFormat::getTimeZoneGenericNames(UErrorCode&amp; status) const {
1384     if (U_FAILURE(status)) {
1385         return NULL;
1386     }
1387 
<a name="5" id="anc5"></a><span class="line-modified">1388     umtx_lock(gLock());</span>
1389     if (fTimeZoneGenericNames == NULL) {
1390         TimeZoneFormat *nonConstThis = const_cast&lt;TimeZoneFormat *&gt;(this);
1391         nonConstThis-&gt;fTimeZoneGenericNames = TimeZoneGenericNames::createInstance(fLocale, status);
1392     }
<a name="6" id="anc6"></a><span class="line-modified">1393     umtx_unlock(gLock());</span>
1394 
1395     return fTimeZoneGenericNames;
1396 }
1397 
1398 const TZDBTimeZoneNames*
1399 TimeZoneFormat::getTZDBTimeZoneNames(UErrorCode&amp; status) const {
1400     if (U_FAILURE(status)) {
1401         return NULL;
1402     }
1403 
<a name="7" id="anc7"></a><span class="line-modified">1404     umtx_lock(gLock());</span>
1405     if (fTZDBTimeZoneNames == NULL) {
1406         TZDBTimeZoneNames *tzdbNames = new TZDBTimeZoneNames(fLocale);
1407         if (tzdbNames == NULL) {
1408             status = U_MEMORY_ALLOCATION_ERROR;
1409         } else {
1410             TimeZoneFormat *nonConstThis = const_cast&lt;TimeZoneFormat *&gt;(this);
1411             nonConstThis-&gt;fTZDBTimeZoneNames = tzdbNames;
1412         }
1413     }
<a name="8" id="anc8"></a><span class="line-modified">1414     umtx_unlock(gLock());</span>
1415 
1416     return fTZDBTimeZoneNames;
1417 }
1418 
1419 UnicodeString&amp;
1420 TimeZoneFormat::formatExemplarLocation(const TimeZone&amp; tz, UnicodeString&amp; name) const {
1421     UChar locationBuf[ZONE_NAME_U16_MAX];
1422     UnicodeString location(locationBuf, 0, UPRV_LENGTHOF(locationBuf));
1423     const UChar* canonicalID = ZoneMeta::getCanonicalCLDRID(tz);
1424 
1425     if (canonicalID) {
1426         fTimeZoneNames-&gt;getExemplarLocationName(UnicodeString(TRUE, canonicalID, -1), location);
1427     }
1428     if (location.length() &gt; 0) {
1429         name.setTo(location);
1430     } else {
1431         // Use &quot;unknown&quot; location
1432         fTimeZoneNames-&gt;getExemplarLocationName(UnicodeString(TRUE, UNKNOWN_ZONE_ID, -1), location);
1433         if (location.length() &gt; 0) {
1434             name.setTo(location);
1435         } else {
1436             // last resort
1437             name.setTo(UNKNOWN_LOCATION, -1);
1438         }
1439     }
1440     return name;
1441 }
1442 
1443 
1444 // ------------------------------------------------------------------
1445 // Zone offset format and parse
1446 
1447 UnicodeString&amp;
1448 TimeZoneFormat::formatOffsetISO8601Basic(int32_t offset, UBool useUtcIndicator, UBool isShort, UBool ignoreSeconds,
1449         UnicodeString&amp; result, UErrorCode&amp; status) const {
1450     return formatOffsetISO8601(offset, TRUE, useUtcIndicator, isShort, ignoreSeconds, result, status);
1451 }
1452 
1453 UnicodeString&amp;
1454 TimeZoneFormat::formatOffsetISO8601Extended(int32_t offset, UBool useUtcIndicator, UBool isShort, UBool ignoreSeconds,
1455         UnicodeString&amp; result, UErrorCode&amp; status) const {
1456     return formatOffsetISO8601(offset, FALSE, useUtcIndicator, isShort, ignoreSeconds, result, status);
1457 }
1458 
1459 UnicodeString&amp;
1460 TimeZoneFormat::formatOffsetLocalizedGMT(int32_t offset, UnicodeString&amp; result, UErrorCode&amp; status) const {
1461     return formatOffsetLocalizedGMT(offset, FALSE, result, status);
1462 }
1463 
1464 UnicodeString&amp;
1465 TimeZoneFormat::formatOffsetShortLocalizedGMT(int32_t offset, UnicodeString&amp; result, UErrorCode&amp; status) const {
1466     return formatOffsetLocalizedGMT(offset, TRUE, result, status);
1467 }
1468 
1469 int32_t
1470 TimeZoneFormat::parseOffsetISO8601(const UnicodeString&amp; text, ParsePosition&amp; pos) const {
1471     return parseOffsetISO8601(text, pos, FALSE);
1472 }
1473 
1474 int32_t
1475 TimeZoneFormat::parseOffsetLocalizedGMT(const UnicodeString&amp; text, ParsePosition&amp; pos) const {
1476     return parseOffsetLocalizedGMT(text, pos, FALSE, NULL);
1477 }
1478 
1479 int32_t
1480 TimeZoneFormat::parseOffsetShortLocalizedGMT(const UnicodeString&amp; text, ParsePosition&amp; pos) const {
1481     return parseOffsetLocalizedGMT(text, pos, TRUE, NULL);
1482 }
1483 
1484 // ------------------------------------------------------------------
1485 // Private zone offset format/parse implementation
1486 
1487 UnicodeString&amp;
1488 TimeZoneFormat::formatOffsetISO8601(int32_t offset, UBool isBasic, UBool useUtcIndicator,
1489         UBool isShort, UBool ignoreSeconds, UnicodeString&amp; result, UErrorCode&amp; status) const {
1490     if (U_FAILURE(status)) {
1491         result.setToBogus();
1492         return result;
1493     }
1494     int32_t absOffset = offset &lt; 0 ? -offset : offset;
1495     if (useUtcIndicator &amp;&amp; (absOffset &lt; MILLIS_PER_SECOND || (ignoreSeconds &amp;&amp; absOffset &lt; MILLIS_PER_MINUTE))) {
1496         result.setTo(ISO8601_UTC);
1497         return result;
1498     }
1499 
1500     OffsetFields minFields = isShort ? FIELDS_H : FIELDS_HM;
1501     OffsetFields maxFields = ignoreSeconds ? FIELDS_HM : FIELDS_HMS;
1502     UChar sep = isBasic ? 0 : ISO8601_SEP;
1503 
1504     // Note: FIELDS_HMS as maxFields is a CLDR/ICU extension. ISO 8601 specification does
1505     // not support seconds field.
1506 
1507     if (absOffset &gt;= MAX_OFFSET) {
1508         result.setToBogus();
1509         status = U_ILLEGAL_ARGUMENT_ERROR;
1510         return result;
1511     }
1512 
1513     int fields[3];
1514     fields[0] = absOffset / MILLIS_PER_HOUR;
1515     absOffset = absOffset % MILLIS_PER_HOUR;
1516     fields[1] = absOffset / MILLIS_PER_MINUTE;
1517     absOffset = absOffset % MILLIS_PER_MINUTE;
1518     fields[2] = absOffset / MILLIS_PER_SECOND;
1519 
1520     U_ASSERT(fields[0] &gt;= 0 &amp;&amp; fields[0] &lt;= MAX_OFFSET_HOUR);
1521     U_ASSERT(fields[1] &gt;= 0 &amp;&amp; fields[1] &lt;= MAX_OFFSET_MINUTE);
1522     U_ASSERT(fields[2] &gt;= 0 &amp;&amp; fields[2] &lt;= MAX_OFFSET_SECOND);
1523 
1524     int32_t lastIdx = maxFields;
1525     while (lastIdx &gt; minFields) {
1526         if (fields[lastIdx] != 0) {
1527             break;
1528         }
1529         lastIdx--;
1530     }
1531 
1532     UChar sign = PLUS;
1533     if (offset &lt; 0) {
1534         // if all output fields are 0s, do not use negative sign
1535         for (int32_t idx = 0; idx &lt;= lastIdx; idx++) {
1536             if (fields[idx] != 0) {
1537                 sign = MINUS;
1538                 break;
1539             }
1540         }
1541     }
1542     result.setTo(sign);
1543 
1544     for (int32_t idx = 0; idx &lt;= lastIdx; idx++) {
1545         if (sep &amp;&amp; idx != 0) {
1546             result.append(sep);
1547         }
1548         result.append((UChar)(0x0030 + fields[idx]/10));
1549         result.append((UChar)(0x0030 + fields[idx]%10));
1550     }
1551 
1552     return result;
1553 }
1554 
1555 UnicodeString&amp;
1556 TimeZoneFormat::formatOffsetLocalizedGMT(int32_t offset, UBool isShort, UnicodeString&amp; result, UErrorCode&amp; status) const {
1557     if (U_FAILURE(status)) {
1558         result.setToBogus();
1559         return result;
1560     }
1561     if (offset &lt;= -MAX_OFFSET || offset &gt;= MAX_OFFSET) {
1562         result.setToBogus();
1563         status = U_ILLEGAL_ARGUMENT_ERROR;
1564         return result;
1565     }
1566 
1567     if (offset == 0) {
1568         result.setTo(fGMTZeroFormat);
1569         return result;
1570     }
1571 
1572     UBool positive = TRUE;
1573     if (offset &lt; 0) {
1574         offset = -offset;
1575         positive = FALSE;
1576     }
1577 
1578     int32_t offsetH = offset / MILLIS_PER_HOUR;
1579     offset = offset % MILLIS_PER_HOUR;
1580     int32_t offsetM = offset / MILLIS_PER_MINUTE;
1581     offset = offset % MILLIS_PER_MINUTE;
1582     int32_t offsetS = offset / MILLIS_PER_SECOND;
1583 
1584     U_ASSERT(offsetH &lt;= MAX_OFFSET_HOUR &amp;&amp; offsetM &lt;= MAX_OFFSET_MINUTE &amp;&amp; offsetS &lt;= MAX_OFFSET_SECOND);
1585 
1586     const UVector* offsetPatternItems = NULL;
1587     if (positive) {
1588         if (offsetS != 0) {
1589             offsetPatternItems = fGMTOffsetPatternItems[UTZFMT_PAT_POSITIVE_HMS];
1590         } else if (offsetM != 0 || !isShort) {
1591             offsetPatternItems = fGMTOffsetPatternItems[UTZFMT_PAT_POSITIVE_HM];
1592         } else {
1593             offsetPatternItems = fGMTOffsetPatternItems[UTZFMT_PAT_POSITIVE_H];
1594         }
1595     } else {
1596         if (offsetS != 0) {
1597             offsetPatternItems = fGMTOffsetPatternItems[UTZFMT_PAT_NEGATIVE_HMS];
1598         } else if (offsetM != 0 || !isShort) {
1599             offsetPatternItems = fGMTOffsetPatternItems[UTZFMT_PAT_NEGATIVE_HM];
1600         } else {
1601             offsetPatternItems = fGMTOffsetPatternItems[UTZFMT_PAT_NEGATIVE_H];
1602         }
1603     }
1604 
1605     U_ASSERT(offsetPatternItems != NULL);
1606 
1607     // Building the GMT format string
1608     result.setTo(fGMTPatternPrefix);
1609 
1610     for (int32_t i = 0; i &lt; offsetPatternItems-&gt;size(); i++) {
1611         const GMTOffsetField* item = (GMTOffsetField*)offsetPatternItems-&gt;elementAt(i);
1612         GMTOffsetField::FieldType type = item-&gt;getType();
1613 
1614         switch (type) {
1615         case GMTOffsetField::TEXT:
1616             result.append(item-&gt;getPatternText(), -1);
1617             break;
1618 
1619         case GMTOffsetField::HOUR:
1620             appendOffsetDigits(result, offsetH, (isShort ? 1 : 2));
1621             break;
1622 
1623         case GMTOffsetField::MINUTE:
1624             appendOffsetDigits(result, offsetM, 2);
1625             break;
1626 
1627         case GMTOffsetField::SECOND:
1628             appendOffsetDigits(result, offsetS, 2);
1629             break;
1630         }
1631     }
1632 
1633     result.append(fGMTPatternSuffix);
1634     return result;
1635 }
1636 
1637 int32_t
1638 TimeZoneFormat::parseOffsetISO8601(const UnicodeString&amp; text, ParsePosition&amp; pos, UBool extendedOnly, UBool* hasDigitOffset /* = NULL */) const {
1639     if (hasDigitOffset) {
1640         *hasDigitOffset = FALSE;
1641     }
1642     int32_t start = pos.getIndex();
1643     if (start &gt;= text.length()) {
1644         pos.setErrorIndex(start);
1645         return 0;
1646     }
1647 
1648     UChar firstChar = text.charAt(start);
1649     if (firstChar == ISO8601_UTC || firstChar == (UChar)(ISO8601_UTC + 0x20)) {
1650         // &quot;Z&quot; (or &quot;z&quot;) - indicates UTC
1651         pos.setIndex(start + 1);
1652         return 0;
1653     }
1654 
1655     int32_t sign = 1;
1656     if (firstChar == PLUS) {
1657         sign = 1;
1658     } else if (firstChar == MINUS) {
1659         sign = -1;
1660     } else {
1661         // Not an ISO 8601 offset string
1662         pos.setErrorIndex(start);
1663         return 0;
1664     }
1665     ParsePosition posOffset(start + 1);
1666     int32_t offset = parseAsciiOffsetFields(text, posOffset, ISO8601_SEP, FIELDS_H, FIELDS_HMS);
1667     if (posOffset.getErrorIndex() == -1 &amp;&amp; !extendedOnly &amp;&amp; (posOffset.getIndex() - start &lt;= 3)) {
1668         // If the text is successfully parsed as extended format with the options above, it can be also parsed
1669         // as basic format. For example, &quot;0230&quot; can be parsed as offset 2:00 (only first digits are valid for
1670         // extended format), but it can be parsed as offset 2:30 with basic format. We use longer result.
1671         ParsePosition posBasic(start + 1);
1672         int32_t tmpOffset = parseAbuttingAsciiOffsetFields(text, posBasic, FIELDS_H, FIELDS_HMS, FALSE);
1673         if (posBasic.getErrorIndex() == -1 &amp;&amp; posBasic.getIndex() &gt; posOffset.getIndex()) {
1674             offset = tmpOffset;
1675             posOffset.setIndex(posBasic.getIndex());
1676         }
1677     }
1678 
1679     if (posOffset.getErrorIndex() != -1) {
1680         pos.setErrorIndex(start);
1681         return 0;
1682     }
1683 
1684     pos.setIndex(posOffset.getIndex());
1685     if (hasDigitOffset) {
1686         *hasDigitOffset = TRUE;
1687     }
1688     return sign * offset;
1689 }
1690 
1691 int32_t
1692 TimeZoneFormat::parseOffsetLocalizedGMT(const UnicodeString&amp; text, ParsePosition&amp; pos, UBool isShort, UBool* hasDigitOffset) const {
1693     int32_t start = pos.getIndex();
1694     int32_t offset = 0;
1695     int32_t parsedLength = 0;
1696 
1697     if (hasDigitOffset) {
1698         *hasDigitOffset = FALSE;
1699     }
1700 
1701     offset = parseOffsetLocalizedGMTPattern(text, start, isShort, parsedLength);
1702 
1703     // For now, parseOffsetLocalizedGMTPattern handles both long and short
1704     // formats, no matter isShort is true or false. This might be changed in future
1705     // when strict parsing is necessary, or different set of patterns are used for
1706     // short/long formats.
1707 #if 0
1708     if (parsedLength == 0) {
1709         offset = parseOffsetLocalizedGMTPattern(text, start, !isShort, parsedLength);
1710     }
1711 #endif
1712 
1713     if (parsedLength &gt; 0) {
1714         if (hasDigitOffset) {
1715             *hasDigitOffset = TRUE;
1716         }
1717         pos.setIndex(start + parsedLength);
1718         return offset;
1719     }
1720 
1721     // Try the default patterns
1722     offset = parseOffsetDefaultLocalizedGMT(text, start, parsedLength);
1723     if (parsedLength &gt; 0) {
1724         if (hasDigitOffset) {
1725             *hasDigitOffset = TRUE;
1726         }
1727         pos.setIndex(start + parsedLength);
1728         return offset;
1729     }
1730 
1731     // Check if this is a GMT zero format
1732     if (text.caseCompare(start, fGMTZeroFormat.length(), fGMTZeroFormat, 0) == 0) {
1733         pos.setIndex(start + fGMTZeroFormat.length());
1734         return 0;
1735     }
1736 
1737     // Check if this is a default GMT zero format
1738     for (int32_t i = 0; ALT_GMT_STRINGS[i][0] != 0; i++) {
1739         const UChar* defGMTZero = ALT_GMT_STRINGS[i];
1740         int32_t defGMTZeroLen = u_strlen(defGMTZero);
1741         if (text.caseCompare(start, defGMTZeroLen, defGMTZero, 0) == 0) {
1742             pos.setIndex(start + defGMTZeroLen);
1743             return 0;
1744         }
1745     }
1746 
1747     // Nothing matched
1748     pos.setErrorIndex(start);
1749     return 0;
1750 }
1751 
1752 int32_t
1753 TimeZoneFormat::parseOffsetLocalizedGMTPattern(const UnicodeString&amp; text, int32_t start, UBool /*isShort*/, int32_t&amp; parsedLen) const {
1754     int32_t idx = start;
1755     int32_t offset = 0;
1756     UBool parsed = FALSE;
1757 
1758     do {
1759         // Prefix part
1760         int32_t len = fGMTPatternPrefix.length();
1761         if (len &gt; 0 &amp;&amp; text.caseCompare(idx, len, fGMTPatternPrefix, 0) != 0) {
1762             // prefix match failed
1763             break;
1764         }
1765         idx += len;
1766 
1767         // Offset part
1768         offset = parseOffsetFields(text, idx, FALSE, len);
1769         if (len == 0) {
1770             // offset field match failed
1771             break;
1772         }
1773         idx += len;
1774 
1775         len = fGMTPatternSuffix.length();
1776         if (len &gt; 0 &amp;&amp; text.caseCompare(idx, len, fGMTPatternSuffix, 0) != 0) {
1777             // no suffix match
1778             break;
1779         }
1780         idx += len;
1781         parsed = TRUE;
1782     } while (FALSE);
1783 
1784     parsedLen = parsed ? idx - start : 0;
1785     return offset;
1786 }
1787 
1788 int32_t
1789 TimeZoneFormat::parseOffsetFields(const UnicodeString&amp; text, int32_t start, UBool /*isShort*/, int32_t&amp; parsedLen) const {
1790     int32_t outLen = 0;
1791     int32_t offset = 0;
1792     int32_t sign = 1;
1793 
1794     parsedLen = 0;
1795 
1796     int32_t offsetH, offsetM, offsetS;
1797     offsetH = offsetM = offsetS = 0;
1798 
1799     for (int32_t patidx = 0; PARSE_GMT_OFFSET_TYPES[patidx] &gt;= 0; patidx++) {
1800         int32_t gmtPatType = PARSE_GMT_OFFSET_TYPES[patidx];
1801         UVector* items = fGMTOffsetPatternItems[gmtPatType];
1802         U_ASSERT(items != NULL);
1803 
1804         outLen = parseOffsetFieldsWithPattern(text, start, items, FALSE, offsetH, offsetM, offsetS);
1805         if (outLen &gt; 0) {
1806             sign = (gmtPatType == UTZFMT_PAT_POSITIVE_H || gmtPatType == UTZFMT_PAT_POSITIVE_HM || gmtPatType == UTZFMT_PAT_POSITIVE_HMS) ?
1807                 1 : -1;
1808             break;
1809         }
1810     }
1811 
1812     if (outLen &gt; 0 &amp;&amp; fAbuttingOffsetHoursAndMinutes) {
1813         // When hours field is sabutting minutes field,
1814         // the parse result above may not be appropriate.
1815         // For example, &quot;01020&quot; is parsed as 01:02: above,
1816         // but it should be parsed as 00:10:20.
1817         int32_t tmpLen = 0;
1818         int32_t tmpSign = 1;
1819         int32_t tmpH = 0;
1820         int32_t tmpM = 0;
1821         int32_t tmpS = 0;
1822 
1823         for (int32_t patidx = 0; PARSE_GMT_OFFSET_TYPES[patidx] &gt;= 0; patidx++) {
1824             int32_t gmtPatType = PARSE_GMT_OFFSET_TYPES[patidx];
1825             UVector* items = fGMTOffsetPatternItems[gmtPatType];
1826             U_ASSERT(items != NULL);
1827 
1828             // forcing parse to use single hour digit
1829             tmpLen = parseOffsetFieldsWithPattern(text, start, items, TRUE, tmpH, tmpM, tmpS);
1830             if (tmpLen &gt; 0) {
1831                 tmpSign = (gmtPatType == UTZFMT_PAT_POSITIVE_H || gmtPatType == UTZFMT_PAT_POSITIVE_HM || gmtPatType == UTZFMT_PAT_POSITIVE_HMS) ?
1832                     1 : -1;
1833                 break;
1834             }
1835         }
1836         if (tmpLen &gt; outLen) {
1837             // Better parse result with single hour digit
1838             outLen = tmpLen;
1839             sign = tmpSign;
1840             offsetH = tmpH;
1841             offsetM = tmpM;
1842             offsetS = tmpS;
1843         }
1844     }
1845 
1846     if (outLen &gt; 0) {
1847         offset = ((((offsetH * 60) + offsetM) * 60) + offsetS) * 1000 * sign;
1848         parsedLen = outLen;
1849     }
1850 
1851     return offset;
1852 }
1853 
1854 int32_t
1855 TimeZoneFormat::parseOffsetFieldsWithPattern(const UnicodeString&amp; text, int32_t start,
1856         UVector* patternItems, UBool forceSingleHourDigit, int32_t&amp; hour, int32_t&amp; min, int32_t&amp; sec) const {
1857     UBool failed = FALSE;
1858     int32_t offsetH, offsetM, offsetS;
1859     offsetH = offsetM = offsetS = 0;
1860     int32_t idx = start;
1861 
1862     for (int32_t i = 0; i &lt; patternItems-&gt;size(); i++) {
1863         int32_t len = 0;
1864         const GMTOffsetField* field = (const GMTOffsetField*)patternItems-&gt;elementAt(i);
1865         GMTOffsetField::FieldType fieldType = field-&gt;getType();
1866         if (fieldType == GMTOffsetField::TEXT) {
1867             const UChar* patStr = field-&gt;getPatternText();
1868             len = u_strlen(patStr);
1869             if (i == 0) {
1870                 // When TimeZoneFormat parse() is called from SimpleDateFormat,
1871                 // leading space characters might be truncated. If the first pattern text
1872                 // starts with such character (e.g. Bidi control), then we need to
1873                 // skip the leading space charcters.
1874                 if (idx &lt; text.length() &amp;&amp; !PatternProps::isWhiteSpace(text.char32At(idx))) {
1875                     while (len &gt; 0) {
1876                         UChar32 ch;
1877                         int32_t chLen;
1878                         U16_GET(patStr, 0, 0, len, ch)
1879                         if (PatternProps::isWhiteSpace(ch)) {
1880                             chLen = U16_LENGTH(ch);
1881                             len -= chLen;
1882                             patStr += chLen;
1883                         }
1884                         else {
1885                             break;
1886                         }
1887                     }
1888                 }
1889             }
1890             if (text.caseCompare(idx, len, patStr, 0) != 0) {
1891                 failed = TRUE;
1892                 break;
1893             }
1894             idx += len;
1895         } else {
1896             if (fieldType == GMTOffsetField::HOUR) {
1897                 uint8_t maxDigits = forceSingleHourDigit ? 1 : 2;
1898                 offsetH = parseOffsetFieldWithLocalizedDigits(text, idx, 1, maxDigits, 0, MAX_OFFSET_HOUR, len);
1899             } else if (fieldType == GMTOffsetField::MINUTE) {
1900                 offsetM = parseOffsetFieldWithLocalizedDigits(text, idx, 2, 2, 0, MAX_OFFSET_MINUTE, len);
1901             } else if (fieldType == GMTOffsetField::SECOND) {
1902                 offsetS = parseOffsetFieldWithLocalizedDigits(text, idx, 2, 2, 0, MAX_OFFSET_SECOND, len);
1903             }
1904 
1905             if (len == 0) {
1906                 failed = TRUE;
1907                 break;
1908             }
1909             idx += len;
1910         }
1911     }
1912 
1913     if (failed) {
1914         hour = min = sec = 0;
1915         return 0;
1916     }
1917 
1918     hour = offsetH;
1919     min = offsetM;
1920     sec = offsetS;
1921 
1922     return idx - start;
1923 }
1924 
1925 int32_t
1926 TimeZoneFormat::parseAbuttingOffsetFields(const UnicodeString&amp; text, int32_t start, int32_t&amp; parsedLen) const {
1927     int32_t digits[MAX_OFFSET_DIGITS];
1928     int32_t parsed[MAX_OFFSET_DIGITS];  // accumulative offsets
1929 
1930     // Parse digits into int[]
1931     int32_t idx = start;
1932     int32_t len = 0;
1933     int32_t numDigits = 0;
1934     for (int32_t i = 0; i &lt; MAX_OFFSET_DIGITS; i++) {
1935         digits[i] = parseSingleLocalizedDigit(text, idx, len);
1936         if (digits[i] &lt; 0) {
1937             break;
1938         }
1939         idx += len;
1940         parsed[i] = idx - start;
1941         numDigits++;
1942     }
1943 
1944     if (numDigits == 0) {
1945         parsedLen = 0;
1946         return 0;
1947     }
1948 
1949     int32_t offset = 0;
1950     while (numDigits &gt; 0) {
1951         int32_t hour = 0;
1952         int32_t min = 0;
1953         int32_t sec = 0;
1954 
1955         U_ASSERT(numDigits &gt; 0 &amp;&amp; numDigits &lt;= MAX_OFFSET_DIGITS);
1956         switch (numDigits) {
1957         case 1: // H
1958             hour = digits[0];
1959             break;
1960         case 2: // HH
1961             hour = digits[0] * 10 + digits[1];
1962             break;
1963         case 3: // Hmm
1964             hour = digits[0];
1965             min = digits[1] * 10 + digits[2];
1966             break;
1967         case 4: // HHmm
1968             hour = digits[0] * 10 + digits[1];
1969             min = digits[2] * 10 + digits[3];
1970             break;
1971         case 5: // Hmmss
1972             hour = digits[0];
1973             min = digits[1] * 10 + digits[2];
1974             sec = digits[3] * 10 + digits[4];
1975             break;
1976         case 6: // HHmmss
1977             hour = digits[0] * 10 + digits[1];
1978             min = digits[2] * 10 + digits[3];
1979             sec = digits[4] * 10 + digits[5];
1980             break;
1981         }
1982         if (hour &lt;= MAX_OFFSET_HOUR &amp;&amp; min &lt;= MAX_OFFSET_MINUTE &amp;&amp; sec &lt;= MAX_OFFSET_SECOND) {
1983             // found a valid combination
1984             offset = hour * MILLIS_PER_HOUR + min * MILLIS_PER_MINUTE + sec * MILLIS_PER_SECOND;
1985             parsedLen = parsed[numDigits - 1];
1986             break;
1987         }
1988         numDigits--;
1989     }
1990     return offset;
1991 }
1992 
1993 int32_t
1994 TimeZoneFormat::parseOffsetDefaultLocalizedGMT(const UnicodeString&amp; text, int start, int32_t&amp; parsedLen) const {
1995     int32_t idx = start;
1996     int32_t offset = 0;
1997     int32_t parsed = 0;
1998 
1999     do {
2000         // check global default GMT alternatives
2001         int32_t gmtLen = 0;
2002 
2003         for (int32_t i = 0; ALT_GMT_STRINGS[i][0] != 0; i++) {
2004             const UChar* gmt = ALT_GMT_STRINGS[i];
2005             int32_t len = u_strlen(gmt);
2006             if (text.caseCompare(start, len, gmt, 0) == 0) {
2007                 gmtLen = len;
2008                 break;
2009             }
2010         }
2011         if (gmtLen == 0) {
2012             break;
2013         }
2014         idx += gmtLen;
2015 
2016         // offset needs a sign char and a digit at minimum
2017         if (idx + 1 &gt;= text.length()) {
2018             break;
2019         }
2020 
2021         // parse sign
2022         int32_t sign = 1;
2023         UChar c = text.charAt(idx);
2024         if (c == PLUS) {
2025             sign = 1;
2026         } else if (c == MINUS) {
2027             sign = -1;
2028         } else {
2029             break;
2030         }
2031         idx++;
2032 
2033         // offset part
2034         // try the default pattern with the separator first
2035         int32_t lenWithSep = 0;
2036         int32_t offsetWithSep = parseDefaultOffsetFields(text, idx, DEFAULT_GMT_OFFSET_SEP, lenWithSep);
2037         if (lenWithSep == text.length() - idx) {
2038             // maximum match
2039             offset = offsetWithSep * sign;
2040             idx += lenWithSep;
2041         } else {
2042             // try abutting field pattern
2043             int32_t lenAbut = 0;
2044             int32_t offsetAbut = parseAbuttingOffsetFields(text, idx, lenAbut);
2045 
2046             if (lenWithSep &gt; lenAbut) {
2047                 offset = offsetWithSep * sign;
2048                 idx += lenWithSep;
2049             } else {
2050                 offset = offsetAbut * sign;
2051                 idx += lenAbut;
2052             }
2053         }
2054         parsed = idx - start;
2055     } while (false);
2056 
2057     parsedLen = parsed;
2058     return offset;
2059 }
2060 
2061 int32_t
2062 TimeZoneFormat::parseDefaultOffsetFields(const UnicodeString&amp; text, int32_t start, UChar separator, int32_t&amp; parsedLen) const {
2063     int32_t max = text.length();
2064     int32_t idx = start;
2065     int32_t len = 0;
2066     int32_t hour = 0, min = 0, sec = 0;
2067 
2068     parsedLen = 0;
2069 
2070     do {
2071         hour = parseOffsetFieldWithLocalizedDigits(text, idx, 1, 2, 0, MAX_OFFSET_HOUR, len);
2072         if (len == 0) {
2073             break;
2074         }
2075         idx += len;
2076 
2077         if (idx + 1 &lt; max &amp;&amp; text.charAt(idx) == separator) {
2078             min = parseOffsetFieldWithLocalizedDigits(text, idx + 1, 2, 2, 0, MAX_OFFSET_MINUTE, len);
2079             if (len == 0) {
2080                 break;
2081             }
2082             idx += (1 + len);
2083 
2084             if (idx + 1 &lt; max &amp;&amp; text.charAt(idx) == separator) {
2085                 sec = parseOffsetFieldWithLocalizedDigits(text, idx + 1, 2, 2, 0, MAX_OFFSET_SECOND, len);
2086                 if (len == 0) {
2087                     break;
2088                 }
2089                 idx += (1 + len);
2090             }
2091         }
2092     } while (FALSE);
2093 
2094     if (idx == start) {
2095         return 0;
2096     }
2097 
2098     parsedLen = idx - start;
2099     return hour * MILLIS_PER_HOUR + min * MILLIS_PER_MINUTE + sec * MILLIS_PER_SECOND;
2100 }
2101 
2102 int32_t
2103 TimeZoneFormat::parseOffsetFieldWithLocalizedDigits(const UnicodeString&amp; text, int32_t start, uint8_t minDigits, uint8_t maxDigits, uint16_t minVal, uint16_t maxVal, int32_t&amp; parsedLen) const {
2104     parsedLen = 0;
2105 
2106     int32_t decVal = 0;
2107     int32_t numDigits = 0;
2108     int32_t idx = start;
2109     int32_t digitLen = 0;
2110 
2111     while (idx &lt; text.length() &amp;&amp; numDigits &lt; maxDigits) {
2112         int32_t digit = parseSingleLocalizedDigit(text, idx, digitLen);
2113         if (digit &lt; 0) {
2114             break;
2115         }
2116         int32_t tmpVal = decVal * 10 + digit;
2117         if (tmpVal &gt; maxVal) {
2118             break;
2119         }
2120         decVal = tmpVal;
2121         numDigits++;
2122         idx += digitLen;
2123     }
2124 
2125     // Note: maxVal is checked in the while loop
2126     if (numDigits &lt; minDigits || decVal &lt; minVal) {
2127         decVal = -1;
2128         numDigits = 0;
2129     } else {
2130         parsedLen = idx - start;
2131     }
2132 
2133     return decVal;
2134 }
2135 
2136 int32_t
2137 TimeZoneFormat::parseSingleLocalizedDigit(const UnicodeString&amp; text, int32_t start, int32_t&amp; len) const {
2138     int32_t digit = -1;
2139     len = 0;
2140     if (start &lt; text.length()) {
2141         UChar32 cp = text.char32At(start);
2142 
2143         // First, try digits configured for this instance
2144         for (int32_t i = 0; i &lt; 10; i++) {
2145             if (cp == fGMTOffsetDigits[i]) {
2146                 digit = i;
2147                 break;
2148             }
2149         }
2150         // If failed, check if this is a Unicode digit
2151         if (digit &lt; 0) {
2152             int32_t tmp = u_charDigitValue(cp);
2153             digit = (tmp &gt;= 0 &amp;&amp; tmp &lt;= 9) ? tmp : -1;
2154         }
2155 
2156         if (digit &gt;= 0) {
2157             int32_t next = text.moveIndex32(start, 1);
2158             len = next - start;
2159         }
2160     }
2161     return digit;
2162 }
2163 
2164 UnicodeString&amp;
2165 TimeZoneFormat::formatOffsetWithAsciiDigits(int32_t offset, UChar sep, OffsetFields minFields, OffsetFields maxFields, UnicodeString&amp; result) {
2166     U_ASSERT(maxFields &gt;= minFields);
2167     U_ASSERT(offset &gt; -MAX_OFFSET &amp;&amp; offset &lt; MAX_OFFSET);
2168 
2169     UChar sign = PLUS;
2170     if (offset &lt; 0) {
2171         sign = MINUS;
2172         offset = -offset;
2173     }
2174     result.setTo(sign);
2175 
2176     int fields[3];
2177     fields[0] = offset / MILLIS_PER_HOUR;
2178     offset = offset % MILLIS_PER_HOUR;
2179     fields[1] = offset / MILLIS_PER_MINUTE;
2180     offset = offset % MILLIS_PER_MINUTE;
2181     fields[2] = offset / MILLIS_PER_SECOND;
2182 
2183     U_ASSERT(fields[0] &gt;= 0 &amp;&amp; fields[0] &lt;= MAX_OFFSET_HOUR);
2184     U_ASSERT(fields[1] &gt;= 0 &amp;&amp; fields[1] &lt;= MAX_OFFSET_MINUTE);
2185     U_ASSERT(fields[2] &gt;= 0 &amp;&amp; fields[2] &lt;= MAX_OFFSET_SECOND);
2186 
2187     int32_t lastIdx = maxFields;
2188     while (lastIdx &gt; minFields) {
2189         if (fields[lastIdx] != 0) {
2190             break;
2191         }
2192         lastIdx--;
2193     }
2194 
2195     for (int32_t idx = 0; idx &lt;= lastIdx; idx++) {
2196         if (sep &amp;&amp; idx != 0) {
2197             result.append(sep);
2198         }
2199         result.append((UChar)(0x0030 + fields[idx]/10));
2200         result.append((UChar)(0x0030 + fields[idx]%10));
2201     }
2202 
2203     return result;
2204 }
2205 
2206 int32_t
2207 TimeZoneFormat::parseAbuttingAsciiOffsetFields(const UnicodeString&amp; text, ParsePosition&amp; pos, OffsetFields minFields, OffsetFields maxFields, UBool fixedHourWidth) {
2208     int32_t start = pos.getIndex();
2209 
2210     int32_t minDigits = 2 * (minFields + 1) - (fixedHourWidth ? 0 : 1);
2211     int32_t maxDigits = 2 * (maxFields + 1);
2212 
2213     U_ASSERT(maxDigits &lt;= MAX_OFFSET_DIGITS);
2214 
2215     int32_t digits[MAX_OFFSET_DIGITS] = {};
2216     int32_t numDigits = 0;
2217     int32_t idx = start;
2218     while (numDigits &lt; maxDigits &amp;&amp; idx &lt; text.length()) {
2219         UChar uch = text.charAt(idx);
2220         int32_t digit = DIGIT_VAL(uch);
2221         if (digit &lt; 0) {
2222             break;
2223         }
2224         digits[numDigits] = digit;
2225         numDigits++;
2226         idx++;
2227     }
2228 
2229     if (fixedHourWidth &amp;&amp; (numDigits &amp; 1)) {
2230         // Fixed digits, so the number of digits must be even number. Truncating.
2231         numDigits--;
2232     }
2233 
2234     if (numDigits &lt; minDigits) {
2235         pos.setErrorIndex(start);
2236         return 0;
2237     }
2238 
2239     int32_t hour = 0, min = 0, sec = 0;
2240     UBool bParsed = FALSE;
2241     while (numDigits &gt;= minDigits) {
2242         switch (numDigits) {
2243         case 1: //H
2244             hour = digits[0];
2245             break;
2246         case 2: //HH
2247             hour = digits[0] * 10 + digits[1];
2248             break;
2249         case 3: //Hmm
2250             hour = digits[0];
2251             min = digits[1] * 10 + digits[2];
2252             break;
2253         case 4: //HHmm
2254             hour = digits[0] * 10 + digits[1];
2255             min = digits[2] * 10 + digits[3];
2256             break;
2257         case 5: //Hmmss
2258             hour = digits[0];
2259             min = digits[1] * 10 + digits[2];
2260             sec = digits[3] * 10 + digits[4];
2261             break;
2262         case 6: //HHmmss
2263             hour = digits[0] * 10 + digits[1];
2264             min = digits[2] * 10 + digits[3];
2265             sec = digits[4] * 10 + digits[5];
2266             break;
2267         }
2268 
2269         if (hour &lt;= MAX_OFFSET_HOUR &amp;&amp; min &lt;= MAX_OFFSET_MINUTE &amp;&amp; sec &lt;= MAX_OFFSET_SECOND) {
2270             // Successfully parsed
2271             bParsed = true;
2272             break;
2273         }
2274 
2275         // Truncating
2276         numDigits -= (fixedHourWidth ? 2 : 1);
2277         hour = min = sec = 0;
2278     }
2279 
2280     if (!bParsed) {
2281         pos.setErrorIndex(start);
2282         return 0;
2283     }
2284     pos.setIndex(start + numDigits);
2285     return ((((hour * 60) + min) * 60) + sec) * 1000;
2286 }
2287 
2288 int32_t
2289 TimeZoneFormat::parseAsciiOffsetFields(const UnicodeString&amp; text, ParsePosition&amp; pos, UChar sep, OffsetFields minFields, OffsetFields maxFields) {
2290     int32_t start = pos.getIndex();
2291     int32_t fieldVal[] = {0, 0, 0};
2292     int32_t fieldLen[] = {0, -1, -1};
2293     for (int32_t idx = start, fieldIdx = 0; idx &lt; text.length() &amp;&amp; fieldIdx &lt;= maxFields; idx++) {
2294         UChar c = text.charAt(idx);
2295         if (c == sep) {
2296             if (fieldIdx == 0) {
2297                 if (fieldLen[0] == 0) {
2298                     // no hours field
2299                     break;
2300                 }
2301                 // 1 digit hour, move to next field
2302             } else {
2303                 if (fieldLen[fieldIdx] != -1) {
2304                     // premature minute or seconds field
2305                     break;
2306                 }
2307                 fieldLen[fieldIdx] = 0;
2308             }
2309             continue;
2310         } else if (fieldLen[fieldIdx] == -1) {
2311             // no separator after 2 digit field
2312             break;
2313         }
2314         int32_t digit = DIGIT_VAL(c);
2315         if (digit &lt; 0) {
2316             // not a digit
2317             break;
2318         }
2319         fieldVal[fieldIdx] = fieldVal[fieldIdx] * 10 + digit;
2320         fieldLen[fieldIdx]++;
2321         if (fieldLen[fieldIdx] &gt;= 2) {
2322             // parsed 2 digits, move to next field
2323             fieldIdx++;
2324         }
2325     }
2326 
2327     int32_t offset = 0;
2328     int32_t parsedLen = 0;
2329     int32_t parsedFields = -1;
2330     do {
2331         // hour
2332         if (fieldLen[0] == 0) {
2333             break;
2334         }
2335         if (fieldVal[0] &gt; MAX_OFFSET_HOUR) {
2336             offset = (fieldVal[0] / 10) * MILLIS_PER_HOUR;
2337             parsedFields = FIELDS_H;
2338             parsedLen = 1;
2339             break;
2340         }
2341         offset = fieldVal[0] * MILLIS_PER_HOUR;
2342         parsedLen = fieldLen[0];
2343         parsedFields = FIELDS_H;
2344 
2345         // minute
2346         if (fieldLen[1] != 2 || fieldVal[1] &gt; MAX_OFFSET_MINUTE) {
2347             break;
2348         }
2349         offset += fieldVal[1] * MILLIS_PER_MINUTE;
2350         parsedLen += (1 + fieldLen[1]);
2351         parsedFields = FIELDS_HM;
2352 
2353         // second
2354         if (fieldLen[2] != 2 || fieldVal[2] &gt; MAX_OFFSET_SECOND) {
2355             break;
2356         }
2357         offset += fieldVal[2] * MILLIS_PER_SECOND;
2358         parsedLen += (1 + fieldLen[2]);
2359         parsedFields = FIELDS_HMS;
2360     } while (false);
2361 
2362     if (parsedFields &lt; minFields) {
2363         pos.setErrorIndex(start);
2364         return 0;
2365     }
2366 
2367     pos.setIndex(start + parsedLen);
2368     return offset;
2369 }
2370 
2371 void
2372 TimeZoneFormat::appendOffsetDigits(UnicodeString&amp; buf, int32_t n, uint8_t minDigits) const {
2373     U_ASSERT(n &gt;= 0 &amp;&amp; n &lt; 60);
2374     int32_t numDigits = n &gt;= 10 ? 2 : 1;
2375     for (int32_t i = 0; i &lt; minDigits - numDigits; i++) {
2376         buf.append(fGMTOffsetDigits[0]);
2377     }
2378     if (numDigits == 2) {
2379         buf.append(fGMTOffsetDigits[n / 10]);
2380     }
2381     buf.append(fGMTOffsetDigits[n % 10]);
2382 }
2383 
2384 // ------------------------------------------------------------------
2385 // Private misc
2386 void
2387 TimeZoneFormat::initGMTPattern(const UnicodeString&amp; gmtPattern, UErrorCode&amp; status) {
2388     if (U_FAILURE(status)) {
2389         return;
2390     }
2391     // This implementation not perfect, but sufficient practically.
2392     int32_t idx = gmtPattern.indexOf(ARG0, ARG0_LEN, 0);
2393     if (idx &lt; 0) {
2394         status = U_ILLEGAL_ARGUMENT_ERROR;
2395         return;
2396     }
2397     fGMTPattern.setTo(gmtPattern);
2398     unquote(gmtPattern.tempSubString(0, idx), fGMTPatternPrefix);
2399     unquote(gmtPattern.tempSubString(idx + ARG0_LEN), fGMTPatternSuffix);
2400 }
2401 
2402 UnicodeString&amp;
2403 TimeZoneFormat::unquote(const UnicodeString&amp; pattern, UnicodeString&amp; result) {
2404     if (pattern.indexOf(SINGLEQUOTE) &lt; 0) {
2405         result.setTo(pattern);
2406         return result;
2407     }
2408     result.remove();
2409     UBool isPrevQuote = FALSE;
2410     UBool inQuote = FALSE;
2411     for (int32_t i = 0; i &lt; pattern.length(); i++) {
2412         UChar c = pattern.charAt(i);
2413         if (c == SINGLEQUOTE) {
2414             if (isPrevQuote) {
2415                 result.append(c);
2416                 isPrevQuote = FALSE;
2417             } else {
2418                 isPrevQuote = TRUE;
2419             }
2420             inQuote = !inQuote;
2421         } else {
2422             isPrevQuote = FALSE;
2423             result.append(c);
2424         }
2425     }
2426     return result;
2427 }
2428 
2429 UVector*
2430 TimeZoneFormat::parseOffsetPattern(const UnicodeString&amp; pattern, OffsetFields required, UErrorCode&amp; status) {
2431     if (U_FAILURE(status)) {
2432         return NULL;
2433     }
2434     UVector* result = new UVector(deleteGMTOffsetField, NULL, status);
2435     if (result == NULL) {
2436         status = U_MEMORY_ALLOCATION_ERROR;
2437         return NULL;
2438     }
2439 
2440     int32_t checkBits = 0;
2441     UBool isPrevQuote = FALSE;
2442     UBool inQuote = FALSE;
2443     UChar textBuf[32];
2444     UnicodeString text(textBuf, 0, UPRV_LENGTHOF(textBuf));
2445     GMTOffsetField::FieldType itemType = GMTOffsetField::TEXT;
2446     int32_t itemLength = 1;
2447 
2448     for (int32_t i = 0; i &lt; pattern.length(); i++) {
2449         UChar ch = pattern.charAt(i);
2450         if (ch == SINGLEQUOTE) {
2451             if (isPrevQuote) {
2452                 text.append(SINGLEQUOTE);
2453                 isPrevQuote = FALSE;
2454             } else {
2455                 isPrevQuote = TRUE;
2456                 if (itemType != GMTOffsetField::TEXT) {
2457                     if (GMTOffsetField::isValid(itemType, itemLength)) {
2458                         GMTOffsetField* fld = GMTOffsetField::createTimeField(itemType, static_cast&lt;uint8_t&gt;(itemLength), status);
2459                         result-&gt;addElement(fld, status);
2460                         if (U_FAILURE(status)) {
2461                             break;
2462                         }
2463                     } else {
2464                         status = U_ILLEGAL_ARGUMENT_ERROR;
2465                         break;
2466                     }
2467                     itemType = GMTOffsetField::TEXT;
2468                 }
2469             }
2470             inQuote = !inQuote;
2471         } else {
2472             isPrevQuote = FALSE;
2473             if (inQuote) {
2474                 text.append(ch);
2475             } else {
2476                 GMTOffsetField::FieldType tmpType = GMTOffsetField::getTypeByLetter(ch);
2477                 if (tmpType != GMTOffsetField::TEXT) {
2478                     // an offset time pattern character
2479                     if (tmpType == itemType) {
2480                         itemLength++;
2481                     } else {
2482                         if (itemType == GMTOffsetField::TEXT) {
2483                             if (text.length() &gt; 0) {
2484                                 GMTOffsetField* textfld = GMTOffsetField::createText(text, status);
2485                                 result-&gt;addElement(textfld, status);
2486                                 if (U_FAILURE(status)) {
2487                                     break;
2488                                 }
2489                                 text.remove();
2490                             }
2491                         } else {
2492                             if (GMTOffsetField::isValid(itemType, itemLength)) {
2493                                 GMTOffsetField* fld = GMTOffsetField::createTimeField(itemType, static_cast&lt;uint8_t&gt;(itemLength), status);
2494                                 result-&gt;addElement(fld, status);
2495                                 if (U_FAILURE(status)) {
2496                                     break;
2497                                 }
2498                             } else {
2499                                 status = U_ILLEGAL_ARGUMENT_ERROR;
2500                                 break;
2501                             }
2502                         }
2503                         itemType = tmpType;
2504                         itemLength = 1;
2505                         checkBits |= tmpType;
2506                     }
2507                 } else {
2508                     // a string literal
2509                     if (itemType != GMTOffsetField::TEXT) {
2510                         if (GMTOffsetField::isValid(itemType, itemLength)) {
2511                             GMTOffsetField* fld = GMTOffsetField::createTimeField(itemType, static_cast&lt;uint8_t&gt;(itemLength), status);
2512                             result-&gt;addElement(fld, status);
2513                             if (U_FAILURE(status)) {
2514                                 break;
2515                             }
2516                         } else {
2517                             status = U_ILLEGAL_ARGUMENT_ERROR;
2518                             break;
2519                         }
2520                         itemType = GMTOffsetField::TEXT;
2521                     }
2522                     text.append(ch);
2523                 }
2524             }
2525         }
2526     }
2527     // handle last item
2528     if (U_SUCCESS(status)) {
2529         if (itemType == GMTOffsetField::TEXT) {
2530             if (text.length() &gt; 0) {
2531                 GMTOffsetField* tfld = GMTOffsetField::createText(text, status);
2532                 result-&gt;addElement(tfld, status);
2533             }
2534         } else {
2535             if (GMTOffsetField::isValid(itemType, itemLength)) {
2536                 GMTOffsetField* fld = GMTOffsetField::createTimeField(itemType, static_cast&lt;uint8_t&gt;(itemLength), status);
2537                 result-&gt;addElement(fld, status);
2538             } else {
2539                 status = U_ILLEGAL_ARGUMENT_ERROR;
2540             }
2541         }
2542 
2543         // Check all required fields are set
2544         if (U_SUCCESS(status)) {
2545             int32_t reqBits = 0;
2546             switch (required) {
2547             case FIELDS_H:
2548                 reqBits = GMTOffsetField::HOUR;
2549                 break;
2550             case FIELDS_HM:
2551                 reqBits = GMTOffsetField::HOUR | GMTOffsetField::MINUTE;
2552                 break;
2553             case FIELDS_HMS:
2554                 reqBits = GMTOffsetField::HOUR | GMTOffsetField::MINUTE | GMTOffsetField::SECOND;
2555                 break;
2556             }
2557             if (checkBits == reqBits) {
2558                 // all required fields are set, no extra fields
2559                 return result;
2560             }
2561         }
2562     }
2563 
2564     // error
2565     delete result;
2566     return NULL;
2567 }
2568 
2569 UnicodeString&amp;
2570 TimeZoneFormat::expandOffsetPattern(const UnicodeString&amp; offsetHM, UnicodeString&amp; result, UErrorCode&amp; status) {
2571     result.setToBogus();
2572     if (U_FAILURE(status)) {
2573         return result;
2574     }
2575     U_ASSERT(u_strlen(DEFAULT_GMT_OFFSET_MINUTE_PATTERN) == 2);
2576 
2577     int32_t idx_mm = offsetHM.indexOf(DEFAULT_GMT_OFFSET_MINUTE_PATTERN, 2, 0);
2578     if (idx_mm &lt; 0) {
2579         // Bad time zone hour pattern data
2580         status = U_ILLEGAL_ARGUMENT_ERROR;
2581         return result;
2582     }
2583 
2584     UnicodeString sep;
2585     int32_t idx_H = offsetHM.tempSubString(0, idx_mm).lastIndexOf((UChar)0x0048 /* H */);
2586     if (idx_H &gt;= 0) {
2587         sep = offsetHM.tempSubString(idx_H + 1, idx_mm - (idx_H + 1));
2588     }
2589     result.setTo(offsetHM.tempSubString(0, idx_mm + 2));
2590     result.append(sep);
2591     result.append(DEFAULT_GMT_OFFSET_SECOND_PATTERN, -1);
2592     result.append(offsetHM.tempSubString(idx_mm + 2));
2593     return result;
2594 }
2595 
2596 UnicodeString&amp;
2597 TimeZoneFormat::truncateOffsetPattern(const UnicodeString&amp; offsetHM, UnicodeString&amp; result, UErrorCode&amp; status) {
2598     result.setToBogus();
2599     if (U_FAILURE(status)) {
2600         return result;
2601     }
2602     U_ASSERT(u_strlen(DEFAULT_GMT_OFFSET_MINUTE_PATTERN) == 2);
2603 
2604     int32_t idx_mm = offsetHM.indexOf(DEFAULT_GMT_OFFSET_MINUTE_PATTERN, 2, 0);
2605     if (idx_mm &lt; 0) {
2606         // Bad time zone hour pattern data
2607         status = U_ILLEGAL_ARGUMENT_ERROR;
2608         return result;
2609     }
2610     UChar HH[] = {0x0048, 0x0048};
2611     int32_t idx_HH = offsetHM.tempSubString(0, idx_mm).lastIndexOf(HH, 2, 0);
2612     if (idx_HH &gt;= 0) {
2613         return result.setTo(offsetHM.tempSubString(0, idx_HH + 2));
2614     }
2615     int32_t idx_H = offsetHM.tempSubString(0, idx_mm).lastIndexOf((UChar)0x0048, 0);
2616     if (idx_H &gt;= 0) {
2617         return result.setTo(offsetHM.tempSubString(0, idx_H + 1));
2618     }
2619     // Bad time zone hour pattern data
2620     status = U_ILLEGAL_ARGUMENT_ERROR;
2621     return result;
2622 }
2623 
2624 void
2625 TimeZoneFormat::initGMTOffsetPatterns(UErrorCode&amp; status) {
2626     for (int32_t type = 0; type &lt; UTZFMT_PAT_COUNT; type++) {
2627         switch (type) {
2628         case UTZFMT_PAT_POSITIVE_H:
2629         case UTZFMT_PAT_NEGATIVE_H:
2630             fGMTOffsetPatternItems[type] = parseOffsetPattern(fGMTOffsetPatterns[type], FIELDS_H, status);
2631             break;
2632         case UTZFMT_PAT_POSITIVE_HM:
2633         case UTZFMT_PAT_NEGATIVE_HM:
2634             fGMTOffsetPatternItems[type] = parseOffsetPattern(fGMTOffsetPatterns[type], FIELDS_HM, status);
2635             break;
2636         case UTZFMT_PAT_POSITIVE_HMS:
2637         case UTZFMT_PAT_NEGATIVE_HMS:
2638             fGMTOffsetPatternItems[type] = parseOffsetPattern(fGMTOffsetPatterns[type], FIELDS_HMS, status);
2639             break;
2640         }
2641     }
2642     checkAbuttingHoursAndMinutes();
2643 }
2644 
2645 void
2646 TimeZoneFormat::checkAbuttingHoursAndMinutes() {
2647     fAbuttingOffsetHoursAndMinutes= FALSE;
2648     for (int32_t type = 0; type &lt; UTZFMT_PAT_COUNT; type++) {
2649         UBool afterH = FALSE;
2650         UVector *items = fGMTOffsetPatternItems[type];
2651         for (int32_t i = 0; i &lt; items-&gt;size(); i++) {
2652             const GMTOffsetField* item = (GMTOffsetField*)items-&gt;elementAt(i);
<a name="9" id="anc9"></a><span class="line-modified">2653             GMTOffsetField::FieldType fieldType = item-&gt;getType();</span>
<span class="line-modified">2654             if (fieldType != GMTOffsetField::TEXT) {</span>
2655                 if (afterH) {
2656                     fAbuttingOffsetHoursAndMinutes = TRUE;
2657                     break;
<a name="10" id="anc10"></a><span class="line-modified">2658                 } else if (fieldType == GMTOffsetField::HOUR) {</span>
2659                     afterH = TRUE;
2660                 }
2661             } else if (afterH) {
2662                 break;
2663             }
2664         }
2665         if (fAbuttingOffsetHoursAndMinutes) {
2666             break;
2667         }
2668     }
2669 }
2670 
2671 UBool
2672 TimeZoneFormat::toCodePoints(const UnicodeString&amp; str, UChar32* codeArray, int32_t size) {
2673     int32_t count = str.countChar32();
2674     if (count != size) {
2675         return FALSE;
2676     }
2677 
2678     for (int32_t idx = 0, start = 0; idx &lt; size; idx++) {
2679         codeArray[idx] = str.char32At(start);
2680         start = str.moveIndex32(start, 1);
2681     }
2682 
2683     return TRUE;
2684 }
2685 
2686 TimeZone*
2687 TimeZoneFormat::createTimeZoneForOffset(int32_t offset) const {
2688     if (offset == 0) {
2689         // when offset is 0, we should use &quot;Etc/GMT&quot;
2690         return TimeZone::createTimeZone(UnicodeString(TRUE, TZID_GMT, -1));
2691     }
2692     return ZoneMeta::createCustomTimeZone(offset);
2693 }
2694 
2695 UTimeZoneFormatTimeType
2696 TimeZoneFormat::getTimeType(UTimeZoneNameType nameType) {
2697     switch (nameType) {
2698     case UTZNM_LONG_STANDARD:
2699     case UTZNM_SHORT_STANDARD:
2700         return UTZFMT_TIME_TYPE_STANDARD;
2701 
2702     case UTZNM_LONG_DAYLIGHT:
2703     case UTZNM_SHORT_DAYLIGHT:
2704         return UTZFMT_TIME_TYPE_DAYLIGHT;
2705 
2706     default:
2707         return UTZFMT_TIME_TYPE_UNKNOWN;
2708     }
2709 }
2710 
2711 UnicodeString&amp;
2712 TimeZoneFormat::getTimeZoneID(const TimeZoneNames::MatchInfoCollection* matches, int32_t idx, UnicodeString&amp; tzID) const {
2713     if (!matches-&gt;getTimeZoneIDAt(idx, tzID)) {
2714         UChar mzIDBuf[32];
2715         UnicodeString mzID(mzIDBuf, 0, UPRV_LENGTHOF(mzIDBuf));
2716         if (matches-&gt;getMetaZoneIDAt(idx, mzID)) {
2717             fTimeZoneNames-&gt;getReferenceZoneID(mzID, fTargetRegion, tzID);
2718         }
2719     }
2720     return tzID;
2721 }
2722 
2723 
2724 class ZoneIdMatchHandler : public TextTrieMapSearchResultHandler {
2725 public:
2726     ZoneIdMatchHandler();
2727     virtual ~ZoneIdMatchHandler();
2728 
2729     UBool handleMatch(int32_t matchLength, const CharacterNode *node, UErrorCode &amp;status);
2730     const UChar* getID();
2731     int32_t getMatchLen();
2732 private:
2733     int32_t fLen;
2734     const UChar* fID;
2735 };
2736 
2737 ZoneIdMatchHandler::ZoneIdMatchHandler()
2738 : fLen(0), fID(NULL) {
2739 }
2740 
2741 ZoneIdMatchHandler::~ZoneIdMatchHandler() {
2742 }
2743 
2744 UBool
2745 ZoneIdMatchHandler::handleMatch(int32_t matchLength, const CharacterNode *node, UErrorCode &amp;status) {
2746     if (U_FAILURE(status)) {
2747         return FALSE;
2748     }
2749     if (node-&gt;hasValues()) {
2750         const UChar* id = (const UChar*)node-&gt;getValue(0);
2751         if (id != NULL) {
2752             if (fLen &lt; matchLength) {
2753                 fID = id;
2754                 fLen = matchLength;
2755             }
2756         }
2757     }
2758     return TRUE;
2759 }
2760 
2761 const UChar*
2762 ZoneIdMatchHandler::getID() {
2763     return fID;
2764 }
2765 
2766 int32_t
2767 ZoneIdMatchHandler::getMatchLen() {
2768     return fLen;
2769 }
2770 
2771 
2772 static void U_CALLCONV initZoneIdTrie(UErrorCode &amp;status) {
2773     U_ASSERT(gZoneIdTrie == NULL);
2774     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONEFORMAT, tzfmt_cleanup);
2775     gZoneIdTrie = new TextTrieMap(TRUE, NULL);    // No deleter, because values are pooled by ZoneMeta
2776     if (gZoneIdTrie == NULL) {
2777         status = U_MEMORY_ALLOCATION_ERROR;
2778         return;
2779     }
2780     StringEnumeration *tzenum = TimeZone::createEnumeration();
2781     const UnicodeString *id;
2782     while ((id = tzenum-&gt;snext(status)) != NULL) {
2783         const UChar* uid = ZoneMeta::findTimeZoneID(*id);
2784         if (uid) {
2785             gZoneIdTrie-&gt;put(uid, const_cast&lt;UChar *&gt;(uid), status);
2786         }
2787     }
2788     delete tzenum;
2789 }
2790 
2791 
2792 UnicodeString&amp;
2793 TimeZoneFormat::parseZoneID(const UnicodeString&amp; text, ParsePosition&amp; pos, UnicodeString&amp; tzID) const {
2794     UErrorCode status = U_ZERO_ERROR;
2795     umtx_initOnce(gZoneIdTrieInitOnce, &amp;initZoneIdTrie, status);
2796 
2797     int32_t start = pos.getIndex();
2798     int32_t len = 0;
2799     tzID.setToBogus();
2800 
2801     if (U_SUCCESS(status)) {
2802         LocalPointer&lt;ZoneIdMatchHandler&gt; handler(new ZoneIdMatchHandler());
2803         gZoneIdTrie-&gt;search(text, start, handler.getAlias(), status);
2804         len = handler-&gt;getMatchLen();
2805         if (len &gt; 0) {
2806             tzID.setTo(handler-&gt;getID(), -1);
2807         }
2808     }
2809 
2810     if (len &gt; 0) {
2811         pos.setIndex(start + len);
2812     } else {
2813         pos.setErrorIndex(start);
2814     }
2815 
2816     return tzID;
2817 }
2818 
2819 static void U_CALLCONV initShortZoneIdTrie(UErrorCode &amp;status) {
2820     U_ASSERT(gShortZoneIdTrie == NULL);
2821     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONEFORMAT, tzfmt_cleanup);
2822     StringEnumeration *tzenum = TimeZone::createTimeZoneIDEnumeration(UCAL_ZONE_TYPE_CANONICAL, NULL, NULL, status);
2823     if (U_SUCCESS(status)) {
2824         gShortZoneIdTrie = new TextTrieMap(TRUE, NULL);    // No deleter, because values are pooled by ZoneMeta
2825         if (gShortZoneIdTrie == NULL) {
2826             status = U_MEMORY_ALLOCATION_ERROR;
2827         } else {
2828             const UnicodeString *id;
2829             while ((id = tzenum-&gt;snext(status)) != NULL) {
2830                 const UChar* uID = ZoneMeta::findTimeZoneID(*id);
2831                 const UChar* shortID = ZoneMeta::getShortID(*id);
2832                 if (shortID &amp;&amp; uID) {
2833                     gShortZoneIdTrie-&gt;put(shortID, const_cast&lt;UChar *&gt;(uID), status);
2834                 }
2835             }
2836         }
2837     }
2838     delete tzenum;
2839 }
2840 
2841 
2842 UnicodeString&amp;
2843 TimeZoneFormat::parseShortZoneID(const UnicodeString&amp; text, ParsePosition&amp; pos, UnicodeString&amp; tzID) const {
2844     UErrorCode status = U_ZERO_ERROR;
2845     umtx_initOnce(gShortZoneIdTrieInitOnce, &amp;initShortZoneIdTrie, status);
2846 
2847     int32_t start = pos.getIndex();
2848     int32_t len = 0;
2849     tzID.setToBogus();
2850 
2851     if (U_SUCCESS(status)) {
2852         LocalPointer&lt;ZoneIdMatchHandler&gt; handler(new ZoneIdMatchHandler());
2853         gShortZoneIdTrie-&gt;search(text, start, handler.getAlias(), status);
2854         len = handler-&gt;getMatchLen();
2855         if (len &gt; 0) {
2856             tzID.setTo(handler-&gt;getID(), -1);
2857         }
2858     }
2859 
2860     if (len &gt; 0) {
2861         pos.setIndex(start + len);
2862     } else {
2863         pos.setErrorIndex(start);
2864     }
2865 
2866     return tzID;
2867 }
2868 
2869 
2870 UnicodeString&amp;
2871 TimeZoneFormat::parseExemplarLocation(const UnicodeString&amp; text, ParsePosition&amp; pos, UnicodeString&amp; tzID) const {
2872     int32_t startIdx = pos.getIndex();
2873     int32_t parsedPos = -1;
2874     tzID.setToBogus();
2875 
2876     UErrorCode status = U_ZERO_ERROR;
2877     LocalPointer&lt;TimeZoneNames::MatchInfoCollection&gt; exemplarMatches(fTimeZoneNames-&gt;find(text, startIdx, UTZNM_EXEMPLAR_LOCATION, status));
2878     if (U_FAILURE(status)) {
2879         pos.setErrorIndex(startIdx);
2880         return tzID;
2881     }
2882     int32_t matchIdx = -1;
2883     if (!exemplarMatches.isNull()) {
2884         for (int32_t i = 0; i &lt; exemplarMatches-&gt;size(); i++) {
2885             if (startIdx + exemplarMatches-&gt;getMatchLengthAt(i) &gt; parsedPos) {
2886                 matchIdx = i;
2887                 parsedPos = startIdx + exemplarMatches-&gt;getMatchLengthAt(i);
2888             }
2889         }
2890         if (parsedPos &gt; 0) {
2891             pos.setIndex(parsedPos);
2892             getTimeZoneID(exemplarMatches.getAlias(), matchIdx, tzID);
2893         }
2894     }
2895 
2896     if (tzID.length() == 0) {
2897         pos.setErrorIndex(startIdx);
2898     }
2899 
2900     return tzID;
2901 }
2902 
2903 U_NAMESPACE_END
2904 
2905 #endif
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>