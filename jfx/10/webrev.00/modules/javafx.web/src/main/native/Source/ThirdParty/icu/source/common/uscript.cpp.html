<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uscript.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 1997-2014, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 **********************************************************************
  8 *
  9 * File USCRIPT.C
 10 *
 11 * Modification History:
 12 *
 13 *   Date        Name        Description
 14 *   07/06/2001    Ram         Creation.
 15 ******************************************************************************
 16 */
 17 
 18 #include &quot;unicode/uchar.h&quot;
 19 #include &quot;unicode/uscript.h&quot;
 20 #include &quot;unicode/uloc.h&quot;
 21 #include &quot;bytesinkutil.h&quot;
 22 #include &quot;charstr.h&quot;
 23 #include &quot;cmemory.h&quot;
 24 #include &quot;cstring.h&quot;
 25 #include &quot;ulocimp.h&quot;
 26 
 27 static const UScriptCode JAPANESE[3] = { USCRIPT_KATAKANA, USCRIPT_HIRAGANA, USCRIPT_HAN };
 28 static const UScriptCode KOREAN[2] = { USCRIPT_HANGUL, USCRIPT_HAN };
 29 static const UScriptCode HAN_BOPO[2] = { USCRIPT_HAN, USCRIPT_BOPOMOFO };
 30 
 31 static int32_t
 32 setCodes(const UScriptCode *src, int32_t length,
 33          UScriptCode *dest, int32_t capacity, UErrorCode *err) {
 34     int32_t i;
 35     if(U_FAILURE(*err)) { return 0; }
 36     if(length &gt; capacity) {
 37         *err = U_BUFFER_OVERFLOW_ERROR;
 38         return length;
 39     }
 40     for(i = 0; i &lt; length; ++i) {
 41         dest[i] = src[i];
 42     }
 43     return length;
 44 }
 45 
 46 static int32_t
 47 setOneCode(UScriptCode script, UScriptCode *scripts, int32_t capacity, UErrorCode *err) {
 48     if(U_FAILURE(*err)) { return 0; }
 49     if(1 &gt; capacity) {
 50         *err = U_BUFFER_OVERFLOW_ERROR;
 51         return 1;
 52     }
 53     scripts[0] = script;
 54     return 1;
 55 }
 56 
 57 static int32_t
 58 getCodesFromLocale(const char *locale,
 59                    UScriptCode *scripts, int32_t capacity, UErrorCode *err) {
 60     UErrorCode internalErrorCode = U_ZERO_ERROR;
 61     char lang[8];
 62     char script[8];
 63     int32_t scriptLength;
 64     if(U_FAILURE(*err)) { return 0; }
 65     // Multi-script languages, equivalent to the LocaleScript data
 66     // that we used to load from locale resource bundles.
 67     /*length = */ uloc_getLanguage(locale, lang, UPRV_LENGTHOF(lang), &amp;internalErrorCode);
 68     if(U_FAILURE(internalErrorCode) || internalErrorCode == U_STRING_NOT_TERMINATED_WARNING) {
 69         return 0;
 70     }
 71     if(0 == uprv_strcmp(lang, &quot;ja&quot;)) {
 72         return setCodes(JAPANESE, UPRV_LENGTHOF(JAPANESE), scripts, capacity, err);
 73     }
 74     if(0 == uprv_strcmp(lang, &quot;ko&quot;)) {
 75         return setCodes(KOREAN, UPRV_LENGTHOF(KOREAN), scripts, capacity, err);
 76     }
 77     scriptLength = uloc_getScript(locale, script, UPRV_LENGTHOF(script), &amp;internalErrorCode);
 78     if(U_FAILURE(internalErrorCode) || internalErrorCode == U_STRING_NOT_TERMINATED_WARNING) {
 79         return 0;
 80     }
 81     if(0 == uprv_strcmp(lang, &quot;zh&quot;) &amp;&amp; 0 == uprv_strcmp(script, &quot;Hant&quot;)) {
 82         return setCodes(HAN_BOPO, UPRV_LENGTHOF(HAN_BOPO), scripts, capacity, err);
 83     }
 84     // Explicit script code.
 85     if(scriptLength != 0) {
 86         UScriptCode scriptCode = (UScriptCode)u_getPropertyValueEnum(UCHAR_SCRIPT, script);
 87         if(scriptCode != USCRIPT_INVALID_CODE) {
 88             if(scriptCode == USCRIPT_SIMPLIFIED_HAN || scriptCode == USCRIPT_TRADITIONAL_HAN) {
 89                 scriptCode = USCRIPT_HAN;
 90             }
 91             return setOneCode(scriptCode, scripts, capacity, err);
 92         }
 93     }
 94     return 0;
 95 }
 96 
 97 /* TODO: this is a bad API and should be deprecated, ticket #11141 */
 98 U_CAPI int32_t  U_EXPORT2
 99 uscript_getCode(const char* nameOrAbbrOrLocale,
100                 UScriptCode* fillIn,
101                 int32_t capacity,
102                 UErrorCode* err){
103     UBool triedCode;
104     UErrorCode internalErrorCode;
105     int32_t length;
106 
107     if(U_FAILURE(*err)) {
108         return 0;
109     }
110     if(nameOrAbbrOrLocale==NULL ||
111             (fillIn == NULL ? capacity != 0 : capacity &lt; 0)) {
112         *err = U_ILLEGAL_ARGUMENT_ERROR;
113         return 0;
114     }
115 
116     triedCode = FALSE;
117     if(uprv_strchr(nameOrAbbrOrLocale, &#39;-&#39;)==NULL &amp;&amp; uprv_strchr(nameOrAbbrOrLocale, &#39;_&#39;)==NULL ){
118         /* try long and abbreviated script names first */
119         UScriptCode code = (UScriptCode) u_getPropertyValueEnum(UCHAR_SCRIPT, nameOrAbbrOrLocale);
120         if(code!=USCRIPT_INVALID_CODE) {
121             return setOneCode(code, fillIn, capacity, err);
122         }
123         triedCode = TRUE;
124     }
125     internalErrorCode = U_ZERO_ERROR;
126     length = getCodesFromLocale(nameOrAbbrOrLocale, fillIn, capacity, err);
127     if(U_FAILURE(*err) || length != 0) {
128         return length;
129     }
130     icu::CharString likely;
131     {
132         icu::CharStringByteSink sink(&amp;likely);
133         ulocimp_addLikelySubtags(nameOrAbbrOrLocale, sink, &amp;internalErrorCode);
134     }
135     if(U_SUCCESS(internalErrorCode) &amp;&amp; internalErrorCode != U_STRING_NOT_TERMINATED_WARNING) {
136         length = getCodesFromLocale(likely.data(), fillIn, capacity, err);
137         if(U_FAILURE(*err) || length != 0) {
138             return length;
139         }
140     }
141     if(!triedCode) {
142         /* still not found .. try long and abbreviated script names again */
143         UScriptCode code = (UScriptCode) u_getPropertyValueEnum(UCHAR_SCRIPT, nameOrAbbrOrLocale);
144         if(code!=USCRIPT_INVALID_CODE) {
145             return setOneCode(code, fillIn, capacity, err);
146         }
147     }
148     return 0;
149 }
    </pre>
  </body>
</html>