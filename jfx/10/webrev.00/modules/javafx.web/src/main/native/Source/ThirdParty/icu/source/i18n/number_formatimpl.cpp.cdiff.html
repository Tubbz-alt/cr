<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_formatimpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_fluent.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_formatimpl.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_formatimpl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 65,18 ***</span>
  
  
  MicroPropsGenerator::~MicroPropsGenerator() = default;
  
  
<span class="line-modified">! NumberFormatterImpl* NumberFormatterImpl::fromMacros(const MacroProps&amp; macros, UErrorCode&amp; status) {</span>
<span class="line-modified">!     return new NumberFormatterImpl(macros, true, status);</span>
  }
  
<span class="line-modified">! void NumberFormatterImpl::applyStatic(const MacroProps&amp; macros, DecimalQuantity&amp; inValue,</span>
<span class="line-modified">!                                       NumberStringBuilder&amp; outString, UErrorCode&amp; status) {</span>
      NumberFormatterImpl impl(macros, false, status);
<span class="line-modified">!     impl.applyUnsafe(inValue, outString, status);</span>
  }
  
  int32_t NumberFormatterImpl::getPrefixSuffixStatic(const MacroProps&amp; macros, int8_t signum,
                                                     StandardPlural::Form plural,
                                                     NumberStringBuilder&amp; outString, UErrorCode&amp; status) {
<span class="line-new-header">--- 65,22 ---</span>
  
  
  MicroPropsGenerator::~MicroPropsGenerator() = default;
  
  
<span class="line-modified">! NumberFormatterImpl::NumberFormatterImpl(const MacroProps&amp; macros, UErrorCode&amp; status)</span>
<span class="line-modified">!     : NumberFormatterImpl(macros, true, status) {</span>
  }
  
<span class="line-modified">! int32_t NumberFormatterImpl::formatStatic(const MacroProps&amp; macros, DecimalQuantity&amp; inValue,</span>
<span class="line-modified">!                                        NumberStringBuilder&amp; outString, UErrorCode&amp; status) {</span>
      NumberFormatterImpl impl(macros, false, status);
<span class="line-modified">!     MicroProps&amp; micros = impl.preProcessUnsafe(inValue, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { return 0; }</span>
<span class="line-added">+     int32_t length = writeNumber(micros, inValue, outString, 0, status);</span>
<span class="line-added">+     length += writeAffixes(micros, outString, 0, length, status);</span>
<span class="line-added">+     return length;</span>
  }
  
  int32_t NumberFormatterImpl::getPrefixSuffixStatic(const MacroProps&amp; macros, int8_t signum,
                                                     StandardPlural::Form plural,
                                                     NumberStringBuilder&amp; outString, UErrorCode&amp; status) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,48 ***</span>
  // NOTE: C++ SPECIFIC DIFFERENCE FROM JAVA:
  // The &quot;safe&quot; apply method uses a new MicroProps. In the MicroPropsGenerator, fMicros is copied into the new instance.
  // The &quot;unsafe&quot; method simply re-uses fMicros, eliminating the extra copy operation.
  // See MicroProps::processQuantity() for details.
  
<span class="line-modified">! void NumberFormatterImpl::apply(DecimalQuantity&amp; inValue, NumberStringBuilder&amp; outString,</span>
                                  UErrorCode&amp; status) const {
<span class="line-removed">-     if (U_FAILURE(status)) { return; }</span>
      MicroProps micros;
<span class="line-modified">!     if (!fMicroPropsGenerator) { return; }</span>
<span class="line-modified">!     fMicroPropsGenerator-&gt;processQuantity(inValue, micros, status);</span>
<span class="line-modified">!     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">!     microsToString(micros, inValue, outString, status);</span>
  }
  
<span class="line-modified">! void NumberFormatterImpl::applyUnsafe(DecimalQuantity&amp; inValue, NumberStringBuilder&amp; outString,</span>
<span class="line-modified">!                                       UErrorCode&amp; status) {</span>
      if (U_FAILURE(status)) { return; }
      fMicroPropsGenerator-&gt;processQuantity(inValue, fMicros, status);
<span class="line-modified">!     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">!     microsToString(fMicros, inValue, outString, status);</span>
  }
  
  int32_t NumberFormatterImpl::getPrefixSuffix(int8_t signum, StandardPlural::Form plural,
                                               NumberStringBuilder&amp; outString, UErrorCode&amp; status) const {
      if (U_FAILURE(status)) { return 0; }
      // #13453: DecimalFormat wants the affixes from the pattern only (modMiddle, aka pattern modifier).
      // Safe path: use fImmutablePatternModifier.
      const Modifier* modifier = fImmutablePatternModifier-&gt;getModifier(signum, plural);
      modifier-&gt;apply(outString, 0, 0, status);
      if (U_FAILURE(status)) { return 0; }
<span class="line-modified">!     return modifier-&gt;getPrefixLength(status);</span>
  }
  
  int32_t NumberFormatterImpl::getPrefixSuffixUnsafe(int8_t signum, StandardPlural::Form plural,
                                                     NumberStringBuilder&amp; outString, UErrorCode&amp; status) {
      if (U_FAILURE(status)) { return 0; }
      // #13453: DecimalFormat wants the affixes from the pattern only (modMiddle, aka pattern modifier).
      // Unsafe path: use fPatternModifier.
      fPatternModifier-&gt;setNumberProperties(signum, plural);
      fPatternModifier-&gt;apply(outString, 0, 0, status);
      if (U_FAILURE(status)) { return 0; }
<span class="line-modified">!     return fPatternModifier-&gt;getPrefixLength(status);</span>
  }
  
  NumberFormatterImpl::NumberFormatterImpl(const MacroProps&amp; macros, bool safe, UErrorCode&amp; status) {
      fMicroPropsGenerator = macrosToMicroGenerator(macros, safe, status);
  }
<span class="line-new-header">--- 91,66 ---</span>
  // NOTE: C++ SPECIFIC DIFFERENCE FROM JAVA:
  // The &quot;safe&quot; apply method uses a new MicroProps. In the MicroPropsGenerator, fMicros is copied into the new instance.
  // The &quot;unsafe&quot; method simply re-uses fMicros, eliminating the extra copy operation.
  // See MicroProps::processQuantity() for details.
  
<span class="line-modified">! int32_t NumberFormatterImpl::format(DecimalQuantity&amp; inValue, NumberStringBuilder&amp; outString,</span>
                                  UErrorCode&amp; status) const {
      MicroProps micros;
<span class="line-modified">!     preProcess(inValue, micros, status);</span>
<span class="line-modified">!     if (U_FAILURE(status)) { return 0; }</span>
<span class="line-modified">!     int32_t length = writeNumber(micros, inValue, outString, 0, status);</span>
<span class="line-modified">!     length += writeAffixes(micros, outString, 0, length, status);</span>
<span class="line-added">+     return length;</span>
  }
  
<span class="line-modified">! void NumberFormatterImpl::preProcess(DecimalQuantity&amp; inValue, MicroProps&amp; microsOut,</span>
<span class="line-modified">!                                      UErrorCode&amp; status) const {</span>
      if (U_FAILURE(status)) { return; }
<span class="line-added">+     if (fMicroPropsGenerator == nullptr) {</span>
<span class="line-added">+         status = U_INTERNAL_PROGRAM_ERROR;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     fMicroPropsGenerator-&gt;processQuantity(inValue, microsOut, status);</span>
<span class="line-added">+     microsOut.rounder.apply(inValue, status);</span>
<span class="line-added">+     microsOut.integerWidth.apply(inValue, status);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ MicroProps&amp; NumberFormatterImpl::preProcessUnsafe(DecimalQuantity&amp; inValue, UErrorCode&amp; status) {</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return fMicros; // must always return a value</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (fMicroPropsGenerator == nullptr) {</span>
<span class="line-added">+         status = U_INTERNAL_PROGRAM_ERROR;</span>
<span class="line-added">+         return fMicros; // must always return a value</span>
<span class="line-added">+     }</span>
      fMicroPropsGenerator-&gt;processQuantity(inValue, fMicros, status);
<span class="line-modified">!     fMicros.rounder.apply(inValue, status);</span>
<span class="line-modified">!     fMicros.integerWidth.apply(inValue, status);</span>
<span class="line-added">+     return fMicros;</span>
  }
  
  int32_t NumberFormatterImpl::getPrefixSuffix(int8_t signum, StandardPlural::Form plural,
                                               NumberStringBuilder&amp; outString, UErrorCode&amp; status) const {
      if (U_FAILURE(status)) { return 0; }
      // #13453: DecimalFormat wants the affixes from the pattern only (modMiddle, aka pattern modifier).
      // Safe path: use fImmutablePatternModifier.
      const Modifier* modifier = fImmutablePatternModifier-&gt;getModifier(signum, plural);
      modifier-&gt;apply(outString, 0, 0, status);
      if (U_FAILURE(status)) { return 0; }
<span class="line-modified">!     return modifier-&gt;getPrefixLength();</span>
  }
  
  int32_t NumberFormatterImpl::getPrefixSuffixUnsafe(int8_t signum, StandardPlural::Form plural,
                                                     NumberStringBuilder&amp; outString, UErrorCode&amp; status) {
      if (U_FAILURE(status)) { return 0; }
      // #13453: DecimalFormat wants the affixes from the pattern only (modMiddle, aka pattern modifier).
      // Unsafe path: use fPatternModifier.
      fPatternModifier-&gt;setNumberProperties(signum, plural);
      fPatternModifier-&gt;apply(outString, 0, 0, status);
      if (U_FAILURE(status)) { return 0; }
<span class="line-modified">!     return fPatternModifier-&gt;getPrefixLength();</span>
  }
  
  NumberFormatterImpl::NumberFormatterImpl(const MacroProps&amp; macros, bool safe, UErrorCode&amp; status) {
      fMicroPropsGenerator = macrosToMicroGenerator(macros, safe, status);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,17 ***</span>
      // TODO: Accept currency symbols from DecimalFormatSymbols?
  
      // Pre-compute a few values for efficiency.
      bool isCurrency = utils::unitIsCurrency(macros.unit);
      bool isNoUnit = utils::unitIsNoUnit(macros.unit);
<span class="line-modified">!     bool isPercent = isNoUnit &amp;&amp; utils::unitIsPercent(macros.unit);</span>
<span class="line-modified">!     bool isPermille = isNoUnit &amp;&amp; utils::unitIsPermille(macros.unit);</span>
<span class="line-removed">-     bool isCldrUnit = !isCurrency &amp;&amp; !isNoUnit;</span>
      bool isAccounting =
              macros.sign == UNUM_SIGN_ACCOUNTING || macros.sign == UNUM_SIGN_ACCOUNTING_ALWAYS ||
              macros.sign == UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO;
<span class="line-modified">!     CurrencyUnit currency(nullptr, status);</span>
      if (isCurrency) {
          currency = CurrencyUnit(macros.unit, status); // Restore CurrencyUnit from MeasureUnit
      }
      const CurrencySymbols* currencySymbols;
      if (macros.currencySymbols != nullptr) {
<span class="line-new-header">--- 170,16 ---</span>
      // TODO: Accept currency symbols from DecimalFormatSymbols?
  
      // Pre-compute a few values for efficiency.
      bool isCurrency = utils::unitIsCurrency(macros.unit);
      bool isNoUnit = utils::unitIsNoUnit(macros.unit);
<span class="line-modified">!     bool isPercent = utils::unitIsPercent(macros.unit);</span>
<span class="line-modified">!     bool isPermille = utils::unitIsPermille(macros.unit);</span>
      bool isAccounting =
              macros.sign == UNUM_SIGN_ACCOUNTING || macros.sign == UNUM_SIGN_ACCOUNTING_ALWAYS ||
              macros.sign == UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO;
<span class="line-modified">!     CurrencyUnit currency(u&quot;&quot;, status);</span>
      if (isCurrency) {
          currency = CurrencyUnit(macros.unit, status); // Restore CurrencyUnit from MeasureUnit
      }
      const CurrencySymbols* currencySymbols;
      if (macros.currencySymbols != nullptr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 170,10 ***</span>
<span class="line-new-header">--- 191,12 ---</span>
      }
      UNumberUnitWidth unitWidth = UNUM_UNIT_WIDTH_SHORT;
      if (macros.unitWidth != UNUM_UNIT_WIDTH_COUNT) {
          unitWidth = macros.unitWidth;
      }
<span class="line-added">+     bool isCldrUnit = !isCurrency &amp;&amp; !isNoUnit &amp;&amp;</span>
<span class="line-added">+         (unitWidth == UNUM_UNIT_WIDTH_FULL_NAME || !(isPercent || isPermille));</span>
  
      // Select the numbering system.
      LocalPointer&lt;const NumberingSystem&gt; nsLocal;
      const NumberingSystem* ns;
      if (macros.symbols.isNumberingSystem()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 183,10 ***</span>
<span class="line-new-header">--- 206,12 ---</span>
          ns = NumberingSystem::createInstance(macros.locale, status);
          // Give ownership to the function scope.
          nsLocal.adoptInstead(ns);
      }
      const char* nsName = U_SUCCESS(status) ? ns-&gt;getName() : &quot;latn&quot;;
<span class="line-added">+     uprv_strncpy(fMicros.nsName, nsName, 8);</span>
<span class="line-added">+     fMicros.nsName[8] = 0; // guarantee NUL-terminated</span>
  
      // Resolve the symbols. Do this here because currency may need to customize them.
      if (macros.symbols.isDecimalFormatSymbols()) {
          fMicros.symbols = macros.symbols.getDecimalFormatSymbols();
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,11 ***</span>
                      FALSE);
          }
      }
      if (pattern == nullptr) {
          CldrPatternStyle patternStyle;
<span class="line-modified">!         if (isPercent || isPermille) {</span>
              patternStyle = CLDR_PATTERN_STYLE_PERCENT;
          } else if (!isCurrency || unitWidth == UNUM_UNIT_WIDTH_FULL_NAME) {
              patternStyle = CLDR_PATTERN_STYLE_DECIMAL;
          } else if (isAccounting) {
              // NOTE: Although ACCOUNTING and ACCOUNTING_ALWAYS are only supported in currencies right now,
<span class="line-new-header">--- 242,13 ---</span>
                      FALSE);
          }
      }
      if (pattern == nullptr) {
          CldrPatternStyle patternStyle;
<span class="line-modified">!         if (isCldrUnit) {</span>
<span class="line-added">+             patternStyle = CLDR_PATTERN_STYLE_DECIMAL;</span>
<span class="line-added">+         } else if (isPercent || isPermille) {</span>
              patternStyle = CLDR_PATTERN_STYLE_PERCENT;
          } else if (!isCurrency || unitWidth == UNUM_UNIT_WIDTH_FULL_NAME) {
              patternStyle = CLDR_PATTERN_STYLE_DECIMAL;
          } else if (isAccounting) {
              // NOTE: Although ACCOUNTING and ACCOUNTING_ALWAYS are only supported in currencies right now,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,11 ***</span>
      // Middle modifier (patterns, positive/negative, currency symbols, percent)
      auto patternModifier = new MutablePatternModifier(false);
      fPatternModifier.adoptInstead(patternModifier);
      patternModifier-&gt;setPatternInfo(
              macros.affixProvider != nullptr ? macros.affixProvider
<span class="line-modified">!                                             : static_cast&lt;const AffixPatternProvider*&gt;(fPatternInfo.getAlias()));</span>
      patternModifier-&gt;setPatternAttributes(fMicros.sign, isPermille);
      if (patternModifier-&gt;needsPlurals()) {
          patternModifier-&gt;setSymbols(
                  fMicros.symbols,
                  currencySymbols,
<span class="line-new-header">--- 347,12 ---</span>
      // Middle modifier (patterns, positive/negative, currency symbols, percent)
      auto patternModifier = new MutablePatternModifier(false);
      fPatternModifier.adoptInstead(patternModifier);
      patternModifier-&gt;setPatternInfo(
              macros.affixProvider != nullptr ? macros.affixProvider
<span class="line-modified">!                                             : static_cast&lt;const AffixPatternProvider*&gt;(fPatternInfo.getAlias()),</span>
<span class="line-added">+             UNUM_FIELD_COUNT);</span>
      patternModifier-&gt;setPatternAttributes(fMicros.sign, isPermille);
      if (patternModifier-&gt;needsPlurals()) {
          patternModifier-&gt;setSymbols(
                  fMicros.symbols,
                  currencySymbols,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 342,29 ***</span>
      }
  
      // Outer modifier (CLDR units and currency long names)
      if (isCldrUnit) {
          fLongNameHandler.adoptInstead(
<span class="line-modified">!                 new LongNameHandler(</span>
<span class="line-modified">!                         LongNameHandler::forMeasureUnit(</span>
<span class="line-modified">!                                 macros.locale,</span>
<span class="line-modified">!                                 macros.unit,</span>
<span class="line-modified">!                                 macros.perUnit,</span>
<span class="line-modified">!                                 unitWidth,</span>
<span class="line-modified">!                                 resolvePluralRules(macros.rules, macros.locale, status),</span>
<span class="line-modified">!                                 chain,</span>
<span class="line-removed">-                                 status)));</span>
          chain = fLongNameHandler.getAlias();
      } else if (isCurrency &amp;&amp; unitWidth == UNUM_UNIT_WIDTH_FULL_NAME) {
          fLongNameHandler.adoptInstead(
<span class="line-modified">!                 new LongNameHandler(</span>
<span class="line-modified">!                         LongNameHandler::forCurrencyLongNames(</span>
<span class="line-modified">!                                 macros.locale,</span>
<span class="line-modified">!                                 currency,</span>
<span class="line-modified">!                                 resolvePluralRules(macros.rules, macros.locale, status),</span>
<span class="line-modified">!                                 chain,</span>
<span class="line-removed">-                                 status)));</span>
          chain = fLongNameHandler.getAlias();
      } else {
          // No outer modifier required
          fMicros.modOuter = &amp;fMicros.helpers.emptyWeakModifier;
      }
<span class="line-new-header">--- 370,27 ---</span>
      }
  
      // Outer modifier (CLDR units and currency long names)
      if (isCldrUnit) {
          fLongNameHandler.adoptInstead(
<span class="line-modified">!                 LongNameHandler::forMeasureUnit(</span>
<span class="line-modified">!                         macros.locale,</span>
<span class="line-modified">!                         macros.unit,</span>
<span class="line-modified">!                         macros.perUnit,</span>
<span class="line-modified">!                         unitWidth,</span>
<span class="line-modified">!                         resolvePluralRules(macros.rules, macros.locale, status),</span>
<span class="line-modified">!                         chain,</span>
<span class="line-modified">!                         status));</span>
          chain = fLongNameHandler.getAlias();
      } else if (isCurrency &amp;&amp; unitWidth == UNUM_UNIT_WIDTH_FULL_NAME) {
          fLongNameHandler.adoptInstead(
<span class="line-modified">!                 LongNameHandler::forCurrencyLongNames(</span>
<span class="line-modified">!                         macros.locale,</span>
<span class="line-modified">!                         currency,</span>
<span class="line-modified">!                         resolvePluralRules(macros.rules, macros.locale, status),</span>
<span class="line-modified">!                         chain,</span>
<span class="line-modified">!                         status));</span>
          chain = fLongNameHandler.getAlias();
      } else {
          // No outer modifier required
          fMicros.modOuter = &amp;fMicros.helpers.emptyWeakModifier;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 402,79 ***</span>
          fRules.adoptInstead(PluralRules::forLocale(locale, status));
      }
      return fRules.getAlias();
  }
  
<span class="line-modified">! int32_t NumberFormatterImpl::microsToString(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,</span>
<span class="line-modified">!                                             NumberStringBuilder&amp; string, UErrorCode&amp; status) {</span>
<span class="line-removed">-     micros.rounder.apply(quantity, status);</span>
<span class="line-removed">-     micros.integerWidth.apply(quantity, status);</span>
<span class="line-removed">-     int32_t length = writeNumber(micros, quantity, string, status);</span>
<span class="line-removed">-     // NOTE: When range formatting is added, these modifiers can bubble up.</span>
<span class="line-removed">-     // For now, apply them all here at once.</span>
      // Always apply the inner modifier (which is &quot;strong&quot;).
<span class="line-modified">!     length += micros.modInner-&gt;apply(string, 0, length, status);</span>
      if (micros.padding.isValid()) {
          length += micros.padding
<span class="line-modified">!                 .padAndApply(*micros.modMiddle, *micros.modOuter, string, 0, length, status);</span>
      } else {
<span class="line-modified">!         length += micros.modMiddle-&gt;apply(string, 0, length, status);</span>
<span class="line-modified">!         length += micros.modOuter-&gt;apply(string, 0, length, status);</span>
      }
      return length;
  }
  
  int32_t NumberFormatterImpl::writeNumber(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">!                                          NumberStringBuilder&amp; string, UErrorCode&amp; status) {</span>
      int32_t length = 0;
      if (quantity.isInfinite()) {
          length += string.insert(
<span class="line-modified">!                 length,</span>
                  micros.symbols-&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kInfinitySymbol),
                  UNUM_INTEGER_FIELD,
                  status);
  
      } else if (quantity.isNaN()) {
          length += string.insert(
<span class="line-modified">!                 length,</span>
                  micros.symbols-&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kNaNSymbol),
                  UNUM_INTEGER_FIELD,
                  status);
  
      } else {
          // Add the integer digits
<span class="line-modified">!         length += writeIntegerDigits(micros, quantity, string, status);</span>
  
          // Add the decimal point
          if (quantity.getLowerDisplayMagnitude() &lt; 0 || micros.decimal == UNUM_DECIMAL_SEPARATOR_ALWAYS) {
              length += string.insert(
<span class="line-modified">!                     length,</span>
                      micros.useCurrency ? micros.symbols-&gt;getSymbol(
                              DecimalFormatSymbols::ENumberFormatSymbol::kMonetarySeparatorSymbol) : micros
                              .symbols
                              -&gt;getSymbol(
                                      DecimalFormatSymbols::ENumberFormatSymbol::kDecimalSeparatorSymbol),
                      UNUM_DECIMAL_SEPARATOR_FIELD,
                      status);
          }
  
          // Add the fraction digits
<span class="line-modified">!         length += writeFractionDigits(micros, quantity, string, status);</span>
      }
  
      return length;
  }
  
  int32_t NumberFormatterImpl::writeIntegerDigits(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">!                                                 NumberStringBuilder&amp; string, UErrorCode&amp; status) {</span>
      int length = 0;
      int integerCount = quantity.getUpperDisplayMagnitude() + 1;
      for (int i = 0; i &lt; integerCount; i++) {
          // Add grouping separator
          if (micros.grouping.groupAtPosition(i, quantity)) {
              length += string.insert(
<span class="line-modified">!                     0,</span>
                      micros.useCurrency ? micros.symbols-&gt;getSymbol(
                              DecimalFormatSymbols::ENumberFormatSymbol::kMonetaryGroupingSeparatorSymbol)
                                         : micros.symbols-&gt;getSymbol(
                              DecimalFormatSymbols::ENumberFormatSymbol::kGroupingSeparatorSymbol),
                      UNUM_GROUPING_SEPARATOR_FIELD,
<span class="line-new-header">--- 428,76 ---</span>
          fRules.adoptInstead(PluralRules::forLocale(locale, status));
      }
      return fRules.getAlias();
  }
  
<span class="line-modified">! int32_t NumberFormatterImpl::writeAffixes(const MicroProps&amp; micros, NumberStringBuilder&amp; string,</span>
<span class="line-modified">!                                           int32_t start, int32_t end, UErrorCode&amp; status) {</span>
      // Always apply the inner modifier (which is &quot;strong&quot;).
<span class="line-modified">!     int32_t length = micros.modInner-&gt;apply(string, start, end, status);</span>
      if (micros.padding.isValid()) {
          length += micros.padding
<span class="line-modified">!                 .padAndApply(*micros.modMiddle, *micros.modOuter, string, start, length + end, status);</span>
      } else {
<span class="line-modified">!         length += micros.modMiddle-&gt;apply(string, start, length + end, status);</span>
<span class="line-modified">!         length += micros.modOuter-&gt;apply(string, start, length + end, status);</span>
      }
      return length;
  }
  
  int32_t NumberFormatterImpl::writeNumber(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">!                                          NumberStringBuilder&amp; string, int32_t index,</span>
<span class="line-added">+                                          UErrorCode&amp; status) {</span>
      int32_t length = 0;
      if (quantity.isInfinite()) {
          length += string.insert(
<span class="line-modified">!                 length + index,</span>
                  micros.symbols-&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kInfinitySymbol),
                  UNUM_INTEGER_FIELD,
                  status);
  
      } else if (quantity.isNaN()) {
          length += string.insert(
<span class="line-modified">!                 length + index,</span>
                  micros.symbols-&gt;getSymbol(DecimalFormatSymbols::ENumberFormatSymbol::kNaNSymbol),
                  UNUM_INTEGER_FIELD,
                  status);
  
      } else {
          // Add the integer digits
<span class="line-modified">!         length += writeIntegerDigits(micros, quantity, string, length + index, status);</span>
  
          // Add the decimal point
          if (quantity.getLowerDisplayMagnitude() &lt; 0 || micros.decimal == UNUM_DECIMAL_SEPARATOR_ALWAYS) {
              length += string.insert(
<span class="line-modified">!                     length + index,</span>
                      micros.useCurrency ? micros.symbols-&gt;getSymbol(
                              DecimalFormatSymbols::ENumberFormatSymbol::kMonetarySeparatorSymbol) : micros
                              .symbols
                              -&gt;getSymbol(
                                      DecimalFormatSymbols::ENumberFormatSymbol::kDecimalSeparatorSymbol),
                      UNUM_DECIMAL_SEPARATOR_FIELD,
                      status);
          }
  
          // Add the fraction digits
<span class="line-modified">!         length += writeFractionDigits(micros, quantity, string, length + index, status);</span>
      }
  
      return length;
  }
  
  int32_t NumberFormatterImpl::writeIntegerDigits(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">!                                                 NumberStringBuilder&amp; string, int32_t index,</span>
<span class="line-added">+                                                 UErrorCode&amp; status) {</span>
      int length = 0;
      int integerCount = quantity.getUpperDisplayMagnitude() + 1;
      for (int i = 0; i &lt; integerCount; i++) {
          // Add grouping separator
          if (micros.grouping.groupAtPosition(i, quantity)) {
              length += string.insert(
<span class="line-modified">!                     index,</span>
                      micros.useCurrency ? micros.symbols-&gt;getSymbol(
                              DecimalFormatSymbols::ENumberFormatSymbol::kMonetaryGroupingSeparatorSymbol)
                                         : micros.symbols-&gt;getSymbol(
                              DecimalFormatSymbols::ENumberFormatSymbol::kGroupingSeparatorSymbol),
                      UNUM_GROUPING_SEPARATOR_FIELD,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,24 ***</span>
          }
  
          // Get and append the next digit value
          int8_t nextDigit = quantity.getDigit(i);
          length += utils::insertDigitFromSymbols(
<span class="line-modified">!                 string, 0, nextDigit, *micros.symbols, UNUM_INTEGER_FIELD, status);</span>
      }
      return length;
  }
  
  int32_t NumberFormatterImpl::writeFractionDigits(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">!                                                  NumberStringBuilder&amp; string, UErrorCode&amp; status) {</span>
      int length = 0;
      int fractionCount = -quantity.getLowerDisplayMagnitude();
      for (int i = 0; i &lt; fractionCount; i++) {
          // Get and append the next digit value
          int8_t nextDigit = quantity.getDigit(-i - 1);
          length += utils::insertDigitFromSymbols(
<span class="line-modified">!                 string, string.length(), nextDigit, *micros.symbols, UNUM_FRACTION_FIELD, status);</span>
      }
      return length;
  }
  
  #endif /* #if !UCONFIG_NO_FORMATTING */
<span class="line-new-header">--- 505,25 ---</span>
          }
  
          // Get and append the next digit value
          int8_t nextDigit = quantity.getDigit(i);
          length += utils::insertDigitFromSymbols(
<span class="line-modified">!                 string, index, nextDigit, *micros.symbols, UNUM_INTEGER_FIELD, status);</span>
      }
      return length;
  }
  
  int32_t NumberFormatterImpl::writeFractionDigits(const MicroProps&amp; micros, DecimalQuantity&amp; quantity,
<span class="line-modified">!                                                  NumberStringBuilder&amp; string, int32_t index,</span>
<span class="line-added">+                                                  UErrorCode&amp; status) {</span>
      int length = 0;
      int fractionCount = -quantity.getLowerDisplayMagnitude();
      for (int i = 0; i &lt; fractionCount; i++) {
          // Get and append the next digit value
          int8_t nextDigit = quantity.getDigit(-i - 1);
          length += utils::insertDigitFromSymbols(
<span class="line-modified">!                 string, length + index, nextDigit, *micros.symbols, UNUM_FRACTION_FIELD, status);</span>
      }
      return length;
  }
  
  #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
<center><a href="number_fluent.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_formatimpl.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>