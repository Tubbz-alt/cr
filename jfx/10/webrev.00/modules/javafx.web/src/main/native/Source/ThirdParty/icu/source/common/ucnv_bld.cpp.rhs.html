<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ucnv_bld.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4  ********************************************************************
   5  * COPYRIGHT:
   6  * Copyright (c) 1996-2016, International Business Machines Corporation and
   7  * others. All Rights Reserved.
   8  ********************************************************************
   9  *
  10  *  ucnv_bld.cpp:
  11  *
  12  *  Defines functions that are used in the creation/initialization/deletion
  13  *  of converters and related structures.
  14  *  uses uconv_io.h routines to access disk information
  15  *  is used by ucnv.h to implement public API create/delete/flushCache routines
  16  * Modification History:
  17  *
  18  *   Date        Name        Description
  19  *
  20  *   06/20/2000  helena      OS/400 port changes; mostly typecast.
  21  *   06/29/2000  helena      Major rewrite of the callback interface.
  22 */
  23 
  24 #include &quot;unicode/utypes.h&quot;
  25 
  26 #if !UCONFIG_NO_CONVERSION
  27 
  28 #include &quot;unicode/putil.h&quot;
  29 #include &quot;unicode/udata.h&quot;
  30 #include &quot;unicode/ucnv.h&quot;
  31 #include &quot;unicode/uloc.h&quot;
  32 #include &quot;mutex.h&quot;
  33 #include &quot;putilimp.h&quot;
  34 #include &quot;uassert.h&quot;
  35 #include &quot;utracimp.h&quot;
  36 #include &quot;ucnv_io.h&quot;
  37 #include &quot;ucnv_bld.h&quot;
  38 #include &quot;ucnvmbcs.h&quot;
  39 #include &quot;ucnv_ext.h&quot;
  40 #include &quot;ucnv_cnv.h&quot;
  41 #include &quot;ucnv_imp.h&quot;
  42 #include &quot;uhash.h&quot;
  43 #include &quot;umutex.h&quot;
  44 #include &quot;cstring.h&quot;
  45 #include &quot;cmemory.h&quot;
  46 #include &quot;ucln_cmn.h&quot;
  47 #include &quot;ustr_cnv.h&quot;
  48 
  49 
  50 #if 0
  51 #include &lt;stdio.h&gt;
  52 extern void UCNV_DEBUG_LOG(char *what, char *who, void *p, int l);
  53 #define UCNV_DEBUG_LOG(x,y,z) UCNV_DEBUG_LOG(x,y,z,__LINE__)
  54 #else
  55 # define UCNV_DEBUG_LOG(x,y,z)
  56 #endif
  57 
  58 static const UConverterSharedData * const
  59 converterData[UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES]={
  60     NULL, NULL,
  61 
  62 #if UCONFIG_NO_LEGACY_CONVERSION
  63     NULL,
  64 #else
  65     &amp;_MBCSData,
  66 #endif
  67 
  68     &amp;_Latin1Data,
  69     &amp;_UTF8Data, &amp;_UTF16BEData, &amp;_UTF16LEData,
  70 #if UCONFIG_ONLY_HTML_CONVERSION
  71     NULL, NULL,
  72 #else
  73     &amp;_UTF32BEData, &amp;_UTF32LEData,
  74 #endif
  75     NULL,
  76 
  77 #if UCONFIG_NO_LEGACY_CONVERSION
  78     NULL,
  79 #else
  80     &amp;_ISO2022Data,
  81 #endif
  82 
  83 #if UCONFIG_NO_LEGACY_CONVERSION || UCONFIG_ONLY_HTML_CONVERSION
  84     NULL, NULL, NULL, NULL, NULL, NULL,
  85     NULL, NULL, NULL, NULL, NULL, NULL,
  86     NULL,
  87 #else
  88     &amp;_LMBCSData1,&amp;_LMBCSData2, &amp;_LMBCSData3, &amp;_LMBCSData4, &amp;_LMBCSData5, &amp;_LMBCSData6,
  89     &amp;_LMBCSData8,&amp;_LMBCSData11,&amp;_LMBCSData16,&amp;_LMBCSData17,&amp;_LMBCSData18,&amp;_LMBCSData19,
  90     &amp;_HZData,
  91 #endif
  92 
  93 #if UCONFIG_ONLY_HTML_CONVERSION
  94     NULL,
  95 #else
  96     &amp;_SCSUData,
  97 #endif
  98 
  99 
 100 #if UCONFIG_NO_LEGACY_CONVERSION || UCONFIG_ONLY_HTML_CONVERSION
 101     NULL,
 102 #else
 103     &amp;_ISCIIData,
 104 #endif
 105 
 106     &amp;_ASCIIData,
 107 #if UCONFIG_ONLY_HTML_CONVERSION
 108     NULL, NULL, &amp;_UTF16Data, NULL, NULL, NULL,
 109 #else
 110     &amp;_UTF7Data, &amp;_Bocu1Data, &amp;_UTF16Data, &amp;_UTF32Data, &amp;_CESU8Data, &amp;_IMAPData,
 111 #endif
 112 
 113 #if UCONFIG_NO_LEGACY_CONVERSION || UCONFIG_ONLY_HTML_CONVERSION
 114     NULL,
 115 #else
 116     &amp;_CompoundTextData
 117 #endif
 118 };
 119 
 120 /* Please keep this in binary sorted order for getAlgorithmicTypeFromName.
 121    Also the name should be in lower case and all spaces, dashes and underscores
 122    removed
 123 */
 124 static struct {
 125   const char *name;
 126   const UConverterType type;
 127 } const cnvNameType[] = {
 128 #if !UCONFIG_ONLY_HTML_CONVERSION
 129   { &quot;bocu1&quot;, UCNV_BOCU1 },
 130   { &quot;cesu8&quot;, UCNV_CESU8 },
 131 #endif
 132 #if !UCONFIG_NO_LEGACY_CONVERSION &amp;&amp; !UCONFIG_ONLY_HTML_CONVERSION
 133   { &quot;hz&quot;,UCNV_HZ },
 134 #endif
 135 #if !UCONFIG_ONLY_HTML_CONVERSION
 136   { &quot;imapmailboxname&quot;, UCNV_IMAP_MAILBOX },
 137 #endif
 138 #if !UCONFIG_NO_LEGACY_CONVERSION &amp;&amp; !UCONFIG_ONLY_HTML_CONVERSION
 139   { &quot;iscii&quot;, UCNV_ISCII },
 140 #endif
 141 #if !UCONFIG_NO_LEGACY_CONVERSION
 142   { &quot;iso2022&quot;, UCNV_ISO_2022 },
 143 #endif
 144   { &quot;iso88591&quot;, UCNV_LATIN_1 },
 145 #if !UCONFIG_NO_LEGACY_CONVERSION &amp;&amp; !UCONFIG_ONLY_HTML_CONVERSION
 146   { &quot;lmbcs1&quot;, UCNV_LMBCS_1 },
 147   { &quot;lmbcs11&quot;,UCNV_LMBCS_11 },
 148   { &quot;lmbcs16&quot;,UCNV_LMBCS_16 },
 149   { &quot;lmbcs17&quot;,UCNV_LMBCS_17 },
 150   { &quot;lmbcs18&quot;,UCNV_LMBCS_18 },
 151   { &quot;lmbcs19&quot;,UCNV_LMBCS_19 },
 152   { &quot;lmbcs2&quot;, UCNV_LMBCS_2 },
 153   { &quot;lmbcs3&quot;, UCNV_LMBCS_3 },
 154   { &quot;lmbcs4&quot;, UCNV_LMBCS_4 },
 155   { &quot;lmbcs5&quot;, UCNV_LMBCS_5 },
 156   { &quot;lmbcs6&quot;, UCNV_LMBCS_6 },
 157   { &quot;lmbcs8&quot;, UCNV_LMBCS_8 },
 158 #endif
 159 #if !UCONFIG_ONLY_HTML_CONVERSION
 160   { &quot;scsu&quot;, UCNV_SCSU },
 161 #endif
 162   { &quot;usascii&quot;, UCNV_US_ASCII },
 163   { &quot;utf16&quot;, UCNV_UTF16 },
 164   { &quot;utf16be&quot;, UCNV_UTF16_BigEndian },
 165   { &quot;utf16le&quot;, UCNV_UTF16_LittleEndian },
 166 #if U_IS_BIG_ENDIAN
 167   { &quot;utf16oppositeendian&quot;, UCNV_UTF16_LittleEndian },
 168   { &quot;utf16platformendian&quot;, UCNV_UTF16_BigEndian },
 169 #else
 170   { &quot;utf16oppositeendian&quot;, UCNV_UTF16_BigEndian},
 171   { &quot;utf16platformendian&quot;, UCNV_UTF16_LittleEndian },
 172 #endif
 173 #if !UCONFIG_ONLY_HTML_CONVERSION
 174   { &quot;utf32&quot;, UCNV_UTF32 },
 175   { &quot;utf32be&quot;, UCNV_UTF32_BigEndian },
 176   { &quot;utf32le&quot;, UCNV_UTF32_LittleEndian },
 177 #if U_IS_BIG_ENDIAN
 178   { &quot;utf32oppositeendian&quot;, UCNV_UTF32_LittleEndian },
 179   { &quot;utf32platformendian&quot;, UCNV_UTF32_BigEndian },
 180 #else
 181   { &quot;utf32oppositeendian&quot;, UCNV_UTF32_BigEndian },
 182   { &quot;utf32platformendian&quot;, UCNV_UTF32_LittleEndian },
 183 #endif
 184 #endif
 185 #if !UCONFIG_ONLY_HTML_CONVERSION
 186   { &quot;utf7&quot;, UCNV_UTF7 },
 187 #endif
 188   { &quot;utf8&quot;, UCNV_UTF8 },
 189 #if !UCONFIG_ONLY_HTML_CONVERSION
 190   { &quot;x11compoundtext&quot;, UCNV_COMPOUND_TEXT}
 191 #endif
 192 };
 193 
 194 
 195 /*initializes some global variables */
 196 static UHashtable *SHARED_DATA_HASHTABLE = NULL;
<a name="1" id="anc1"></a><span class="line-modified"> 197 static icu::UMutex *cnvCacheMutex() {                 /* Mutex for synchronizing cnv cache access. */</span>
<span class="line-modified"> 198     static icu::UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-modified"> 199     return &amp;m;</span>
<span class="line-added"> 200 }</span>
<span class="line-added"> 201 /*  Note:  the global mutex is used for      */</span>
<span class="line-added"> 202 /*         reference count updates.          */</span>
 203 
 204 static const char **gAvailableConverters = NULL;
 205 static uint16_t gAvailableConverterCount = 0;
 206 static icu::UInitOnce gAvailableConvertersInitOnce = U_INITONCE_INITIALIZER;
 207 
 208 #if !U_CHARSET_IS_UTF8
 209 
 210 /* This contains the resolved converter name. So no further alias lookup is needed again. */
 211 static char gDefaultConverterNameBuffer[UCNV_MAX_CONVERTER_NAME_LENGTH + 1]; /* +1 for NULL */
 212 static const char *gDefaultConverterName = NULL;
 213 
 214 /*
 215 If the default converter is an algorithmic converter, this is the cached value.
 216 We don&#39;t cache a full UConverter and clone it because ucnv_clone doesn&#39;t have
 217 less overhead than an algorithmic open. We don&#39;t cache non-algorithmic converters
 218 because ucnv_flushCache must be able to unload the default converter and its table.
 219 */
 220 static const UConverterSharedData *gDefaultAlgorithmicSharedData = NULL;
 221 
 222 /* Does gDefaultConverterName have a converter option and require extra parsing? */
 223 static UBool gDefaultConverterContainsOption;
 224 
 225 #endif  /* !U_CHARSET_IS_UTF8 */
 226 
 227 static const char DATA_TYPE[] = &quot;cnv&quot;;
 228 
 229 /* ucnv_flushAvailableConverterCache. This is only called from ucnv_cleanup().
 230  *                       If it is ever to be called from elsewhere, synchronization
 231  *                       will need to be considered.
 232  */
 233 static void
 234 ucnv_flushAvailableConverterCache() {
 235     gAvailableConverterCount = 0;
 236     if (gAvailableConverters) {
 237         uprv_free((char **)gAvailableConverters);
 238         gAvailableConverters = NULL;
 239     }
 240     gAvailableConvertersInitOnce.reset();
 241 }
 242 
 243 /* ucnv_cleanup - delete all storage held by the converter cache, except any  */
 244 /*                in use by open converters.                                  */
 245 /*                Not thread safe.                                            */
 246 /*                Not supported API.                                          */
 247 static UBool U_CALLCONV ucnv_cleanup(void) {
 248     ucnv_flushCache();
 249     if (SHARED_DATA_HASHTABLE != NULL &amp;&amp; uhash_count(SHARED_DATA_HASHTABLE) == 0) {
 250         uhash_close(SHARED_DATA_HASHTABLE);
 251         SHARED_DATA_HASHTABLE = NULL;
 252     }
 253 
 254     /* Isn&#39;t called from flushCache because other threads may have preexisting references to the table. */
 255     ucnv_flushAvailableConverterCache();
 256 
 257 #if !U_CHARSET_IS_UTF8
 258     gDefaultConverterName = NULL;
 259     gDefaultConverterNameBuffer[0] = 0;
 260     gDefaultConverterContainsOption = FALSE;
 261     gDefaultAlgorithmicSharedData = NULL;
 262 #endif
 263 
 264     return (SHARED_DATA_HASHTABLE == NULL);
 265 }
 266 
 267 U_CAPI void U_EXPORT2
 268 ucnv_enableCleanup() {
 269     ucln_common_registerCleanup(UCLN_COMMON_UCNV, ucnv_cleanup);
 270 }
 271 
 272 static UBool U_CALLCONV
 273 isCnvAcceptable(void * /*context*/,
 274                 const char * /*type*/, const char * /*name*/,
 275                 const UDataInfo *pInfo) {
 276     return (UBool)(
 277         pInfo-&gt;size&gt;=20 &amp;&amp;
 278         pInfo-&gt;isBigEndian==U_IS_BIG_ENDIAN &amp;&amp;
 279         pInfo-&gt;charsetFamily==U_CHARSET_FAMILY &amp;&amp;
 280         pInfo-&gt;sizeofUChar==U_SIZEOF_UCHAR &amp;&amp;
 281         pInfo-&gt;dataFormat[0]==0x63 &amp;&amp;   /* dataFormat=&quot;cnvt&quot; */
 282         pInfo-&gt;dataFormat[1]==0x6e &amp;&amp;
 283         pInfo-&gt;dataFormat[2]==0x76 &amp;&amp;
 284         pInfo-&gt;dataFormat[3]==0x74 &amp;&amp;
 285         pInfo-&gt;formatVersion[0]==6);  /* Everything will be version 6 */
 286 }
 287 
 288 /**
 289  * Un flatten shared data from a UDATA..
 290  */
 291 static UConverterSharedData*
 292 ucnv_data_unFlattenClone(UConverterLoadArgs *pArgs, UDataMemory *pData, UErrorCode *status)
 293 {
 294     /* UDataInfo info; -- necessary only if some converters have different formatVersion */
 295     const uint8_t *raw = (const uint8_t *)udata_getMemory(pData);
 296     const UConverterStaticData *source = (const UConverterStaticData *) raw;
 297     UConverterSharedData *data;
 298     UConverterType type = (UConverterType)source-&gt;conversionType;
 299 
 300     if(U_FAILURE(*status))
 301         return NULL;
 302 
 303     if( (uint16_t)type &gt;= UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES ||
 304         converterData[type] == NULL ||
 305         !converterData[type]-&gt;isReferenceCounted ||
 306         converterData[type]-&gt;referenceCounter != 1 ||
 307         source-&gt;structSize != sizeof(UConverterStaticData))
 308     {
 309         *status = U_INVALID_TABLE_FORMAT;
 310         return NULL;
 311     }
 312 
 313     data = (UConverterSharedData *)uprv_malloc(sizeof(UConverterSharedData));
 314     if(data == NULL) {
 315         *status = U_MEMORY_ALLOCATION_ERROR;
 316         return NULL;
 317     }
 318 
 319     /* copy initial values from the static structure for this type */
 320     uprv_memcpy(data, converterData[type], sizeof(UConverterSharedData));
 321 
 322     data-&gt;staticData = source;
 323 
 324     data-&gt;sharedDataCached = FALSE;
 325 
 326     /* fill in fields from the loaded data */
 327     data-&gt;dataMemory = (void*)pData; /* for future use */
 328 
 329     if(data-&gt;impl-&gt;load != NULL) {
 330         data-&gt;impl-&gt;load(data, pArgs, raw + source-&gt;structSize, status);
 331         if(U_FAILURE(*status)) {
 332             uprv_free(data);
 333             return NULL;
 334         }
 335     }
 336     return data;
 337 }
 338 
 339 /*Takes an alias name gets an actual converter file name
 340  *goes to disk and opens it.
 341  *allocates the memory and returns a new UConverter object
 342  */
 343 static UConverterSharedData *createConverterFromFile(UConverterLoadArgs *pArgs, UErrorCode * err)
 344 {
 345     UDataMemory *data;
 346     UConverterSharedData *sharedData;
 347 
 348     UTRACE_ENTRY_OC(UTRACE_UCNV_LOAD);
 349 
 350     if (U_FAILURE (*err)) {
 351         UTRACE_EXIT_STATUS(*err);
 352         return NULL;
 353     }
 354 
 355     UTRACE_DATA2(UTRACE_OPEN_CLOSE, &quot;load converter %s from package %s&quot;, pArgs-&gt;name, pArgs-&gt;pkg);
 356 
 357     data = udata_openChoice(pArgs-&gt;pkg, DATA_TYPE, pArgs-&gt;name, isCnvAcceptable, NULL, err);
 358     if(U_FAILURE(*err))
 359     {
 360         UTRACE_EXIT_STATUS(*err);
 361         return NULL;
 362     }
 363 
 364     sharedData = ucnv_data_unFlattenClone(pArgs, data, err);
 365     if(U_FAILURE(*err))
 366     {
 367         udata_close(data);
 368         UTRACE_EXIT_STATUS(*err);
 369         return NULL;
 370     }
 371 
 372     /*
 373      * TODO Store pkg in a field in the shared data so that delta-only converters
 374      * can load base converters from the same package.
 375      * If the pkg name is longer than the field, then either do not load the converter
 376      * in the first place, or just set the pkg field to &quot;&quot;.
 377      */
 378 
 379     UTRACE_EXIT_PTR_STATUS(sharedData, *err);
 380     return sharedData;
 381 }
 382 
 383 /*returns a converter type from a string
 384  */
 385 static const UConverterSharedData *
 386 getAlgorithmicTypeFromName(const char *realName)
 387 {
 388     uint32_t mid, start, limit;
 389     uint32_t lastMid;
 390     int result;
 391     char strippedName[UCNV_MAX_CONVERTER_NAME_LENGTH];
 392 
 393     /* Lower case and remove ignoreable characters. */
 394     ucnv_io_stripForCompare(strippedName, realName);
 395 
 396     /* do a binary search for the alias */
 397     start = 0;
 398     limit = UPRV_LENGTHOF(cnvNameType);
 399     mid = limit;
 400     lastMid = UINT32_MAX;
 401 
 402     for (;;) {
 403         mid = (uint32_t)((start + limit) / 2);
 404         if (lastMid == mid) {   /* Have we moved? */
 405             break;  /* We haven&#39;t moved, and it wasn&#39;t found. */
 406         }
 407         lastMid = mid;
 408         result = uprv_strcmp(strippedName, cnvNameType[mid].name);
 409 
 410         if (result &lt; 0) {
 411             limit = mid;
 412         } else if (result &gt; 0) {
 413             start = mid;
 414         } else {
 415             return converterData[cnvNameType[mid].type];
 416         }
 417     }
 418 
 419     return NULL;
 420 }
 421 
 422 /*
 423 * Based on the number of known converters, this determines how many times larger
 424 * the shared data hash table should be. When on small platforms, or just a couple
 425 * of converters are used, this number should be 2. When memory is plentiful, or
 426 * when ucnv_countAvailable is ever used with a lot of available converters,
 427 * this should be 4.
 428 * Larger numbers reduce the number of hash collisions, but use more memory.
 429 */
 430 #define UCNV_CACHE_LOAD_FACTOR 2
 431 
 432 /* Puts the shared data in the static hashtable SHARED_DATA_HASHTABLE */
 433 /*   Will always be called with the cnvCacheMutex alrady being held   */
 434 /*     by the calling function.                                       */
 435 /* Stores the shared data in the SHARED_DATA_HASHTABLE
 436  * @param data The shared data
 437  */
 438 static void
 439 ucnv_shareConverterData(UConverterSharedData * data)
 440 {
 441     UErrorCode err = U_ZERO_ERROR;
 442     /*Lazy evaluates the Hashtable itself */
 443     /*void *sanity = NULL;*/
 444 
 445     if (SHARED_DATA_HASHTABLE == NULL)
 446     {
 447         SHARED_DATA_HASHTABLE = uhash_openSize(uhash_hashChars, uhash_compareChars, NULL,
 448                             ucnv_io_countKnownConverters(&amp;err)*UCNV_CACHE_LOAD_FACTOR,
 449                             &amp;err);
 450         ucnv_enableCleanup();
 451 
 452         if (U_FAILURE(err))
 453             return;
 454     }
 455 
 456     /* ### check to see if the element is not already there! */
 457 
 458     /*
 459     sanity =   ucnv_getSharedConverterData (data-&gt;staticData-&gt;name);
 460     if(sanity != NULL)
 461     {
 462     UCNV_DEBUG_LOG(&quot;put:overwrite!&quot;,data-&gt;staticData-&gt;name,sanity);
 463     }
 464     UCNV_DEBUG_LOG(&quot;put:chk&quot;,data-&gt;staticData-&gt;name,sanity);
 465     */
 466 
 467     /* Mark it shared */
 468     data-&gt;sharedDataCached = TRUE;
 469 
 470     uhash_put(SHARED_DATA_HASHTABLE,
 471             (void*) data-&gt;staticData-&gt;name, /* Okay to cast away const as long as
 472             keyDeleter == NULL */
 473             data,
 474             &amp;err);
 475     UCNV_DEBUG_LOG(&quot;put&quot;, data-&gt;staticData-&gt;name,data);
 476 
 477 }
 478 
 479 /*  Look up a converter name in the shared data cache.                    */
 480 /*    cnvCacheMutex must be held by the caller to protect the hash table. */
 481 /* gets the shared data from the SHARED_DATA_HASHTABLE (might return NULL if it isn&#39;t there)
 482  * @param name The name of the shared data
 483  * @return the shared data from the SHARED_DATA_HASHTABLE
 484  */
 485 static UConverterSharedData *
 486 ucnv_getSharedConverterData(const char *name)
 487 {
 488     /*special case when no Table has yet been created we return NULL */
 489     if (SHARED_DATA_HASHTABLE == NULL)
 490     {
 491         return NULL;
 492     }
 493     else
 494     {
 495         UConverterSharedData *rc;
 496 
 497         rc = (UConverterSharedData*)uhash_get(SHARED_DATA_HASHTABLE, name);
 498         UCNV_DEBUG_LOG(&quot;get&quot;,name,rc);
 499         return rc;
 500     }
 501 }
 502 
 503 /*frees the string of memory blocks associates with a sharedConverter
 504  *if and only if the referenceCounter == 0
 505  */
 506 /* Deletes (frees) the Shared data it&#39;s passed. first it checks the referenceCounter to
 507  * see if anyone is using it, if not it frees all the memory stemming from sharedConverterData and
 508  * returns TRUE,
 509  * otherwise returns FALSE
 510  * @param sharedConverterData The shared data
 511  * @return if not it frees all the memory stemming from sharedConverterData and
 512  * returns TRUE, otherwise returns FALSE
 513  */
 514 static UBool
 515 ucnv_deleteSharedConverterData(UConverterSharedData * deadSharedData)
 516 {
 517     UTRACE_ENTRY_OC(UTRACE_UCNV_UNLOAD);
 518     UTRACE_DATA2(UTRACE_OPEN_CLOSE, &quot;unload converter %s shared data %p&quot;, deadSharedData-&gt;staticData-&gt;name, deadSharedData);
 519 
 520     if (deadSharedData-&gt;referenceCounter &gt; 0) {
 521         UTRACE_EXIT_VALUE((int32_t)FALSE);
 522         return FALSE;
 523     }
 524 
 525     if (deadSharedData-&gt;impl-&gt;unload != NULL) {
 526         deadSharedData-&gt;impl-&gt;unload(deadSharedData);
 527     }
 528 
 529     if(deadSharedData-&gt;dataMemory != NULL)
 530     {
 531         UDataMemory *data = (UDataMemory*)deadSharedData-&gt;dataMemory;
 532         udata_close(data);
 533     }
 534 
 535     uprv_free(deadSharedData);
 536 
 537     UTRACE_EXIT_VALUE((int32_t)TRUE);
 538     return TRUE;
 539 }
 540 
 541 /**
 542  * Load a non-algorithmic converter.
 543  * If pkg==NULL, then this function must be called inside umtx_lock(&amp;cnvCacheMutex).
 544  */
 545 UConverterSharedData *
 546 ucnv_load(UConverterLoadArgs *pArgs, UErrorCode *err) {
 547     UConverterSharedData *mySharedConverterData;
 548 
 549     if(err == NULL || U_FAILURE(*err)) {
 550         return NULL;
 551     }
 552 
 553     if(pArgs-&gt;pkg != NULL &amp;&amp; *pArgs-&gt;pkg != 0) {
 554         /* application-provided converters are not currently cached */
 555         return createConverterFromFile(pArgs, err);
 556     }
 557 
 558     mySharedConverterData = ucnv_getSharedConverterData(pArgs-&gt;name);
 559     if (mySharedConverterData == NULL)
 560     {
 561         /*Not cached, we need to stream it in from file */
 562         mySharedConverterData = createConverterFromFile(pArgs, err);
 563         if (U_FAILURE (*err) || (mySharedConverterData == NULL))
 564         {
 565             return NULL;
 566         }
 567         else if (!pArgs-&gt;onlyTestIsLoadable)
 568         {
 569             /* share it with other library clients */
 570             ucnv_shareConverterData(mySharedConverterData);
 571         }
 572     }
 573     else
 574     {
 575         /* The data for this converter was already in the cache.            */
 576         /* Update the reference counter on the shared data: one more client */
 577         mySharedConverterData-&gt;referenceCounter++;
 578     }
 579 
 580     return mySharedConverterData;
 581 }
 582 
 583 /**
 584  * Unload a non-algorithmic converter.
 585  * It must be sharedData-&gt;isReferenceCounted
 586  * and this function must be called inside umtx_lock(&amp;cnvCacheMutex).
 587  */
 588 U_CAPI void
 589 ucnv_unload(UConverterSharedData *sharedData) {
 590     if(sharedData != NULL) {
 591         if (sharedData-&gt;referenceCounter &gt; 0) {
 592             sharedData-&gt;referenceCounter--;
 593         }
 594 
 595         if((sharedData-&gt;referenceCounter &lt;= 0)&amp;&amp;(sharedData-&gt;sharedDataCached == FALSE)) {
 596             ucnv_deleteSharedConverterData(sharedData);
 597         }
 598     }
 599 }
 600 
 601 U_CFUNC void
 602 ucnv_unloadSharedDataIfReady(UConverterSharedData *sharedData)
 603 {
 604     if(sharedData != NULL &amp;&amp; sharedData-&gt;isReferenceCounted) {
<a name="2" id="anc2"></a><span class="line-modified"> 605         umtx_lock(cnvCacheMutex());</span>
 606         ucnv_unload(sharedData);
<a name="3" id="anc3"></a><span class="line-modified"> 607         umtx_unlock(cnvCacheMutex());</span>
 608     }
 609 }
 610 
 611 U_CFUNC void
 612 ucnv_incrementRefCount(UConverterSharedData *sharedData)
 613 {
 614     if(sharedData != NULL &amp;&amp; sharedData-&gt;isReferenceCounted) {
<a name="4" id="anc4"></a><span class="line-modified"> 615         umtx_lock(cnvCacheMutex());</span>
 616         sharedData-&gt;referenceCounter++;
<a name="5" id="anc5"></a><span class="line-modified"> 617         umtx_unlock(cnvCacheMutex());</span>
 618     }
 619 }
 620 
 621 /*
 622  * *pPieces must be initialized.
 623  * The name without options will be copied to pPieces-&gt;cnvName.
 624  * The locale and options will be copied to pPieces only if present in inName,
 625  * otherwise the existing values in pPieces remain.
 626  * *pArgs will be set to the pPieces values.
 627  */
 628 static void
 629 parseConverterOptions(const char *inName,
 630                       UConverterNamePieces *pPieces,
 631                       UConverterLoadArgs *pArgs,
 632                       UErrorCode *err)
 633 {
 634     char *cnvName = pPieces-&gt;cnvName;
 635     char c;
 636     int32_t len = 0;
 637 
 638     pArgs-&gt;name=inName;
 639     pArgs-&gt;locale=pPieces-&gt;locale;
 640     pArgs-&gt;options=pPieces-&gt;options;
 641 
 642     /* copy the converter name itself to cnvName */
 643     while((c=*inName)!=0 &amp;&amp; c!=UCNV_OPTION_SEP_CHAR) {
 644         if (++len&gt;=UCNV_MAX_CONVERTER_NAME_LENGTH) {
 645             *err = U_ILLEGAL_ARGUMENT_ERROR;    /* bad name */
 646             pPieces-&gt;cnvName[0]=0;
 647             return;
 648         }
 649         *cnvName++=c;
 650         inName++;
 651     }
 652     *cnvName=0;
 653     pArgs-&gt;name=pPieces-&gt;cnvName;
 654 
 655     /* parse options. No more name copying should occur. */
 656     while((c=*inName)!=0) {
 657         if(c==UCNV_OPTION_SEP_CHAR) {
 658             ++inName;
 659         }
 660 
 661         /* inName is behind an option separator */
 662         if(uprv_strncmp(inName, &quot;locale=&quot;, 7)==0) {
 663             /* do not modify locale itself in case we have multiple locale options */
 664             char *dest=pPieces-&gt;locale;
 665 
 666             /* copy the locale option value */
 667             inName+=7;
 668             len=0;
 669             while((c=*inName)!=0 &amp;&amp; c!=UCNV_OPTION_SEP_CHAR) {
 670                 ++inName;
 671 
 672                 if(++len&gt;=ULOC_FULLNAME_CAPACITY) {
 673                     *err=U_ILLEGAL_ARGUMENT_ERROR;    /* bad name */
 674                     pPieces-&gt;locale[0]=0;
 675                     return;
 676                 }
 677 
 678                 *dest++=c;
 679             }
 680             *dest=0;
 681         } else if(uprv_strncmp(inName, &quot;version=&quot;, 8)==0) {
 682             /* copy the version option value into bits 3..0 of pPieces-&gt;options */
 683             inName+=8;
 684             c=*inName;
 685             if(c==0) {
 686                 pArgs-&gt;options=(pPieces-&gt;options&amp;=~UCNV_OPTION_VERSION);
 687                 return;
 688             } else if((uint8_t)(c-&#39;0&#39;)&lt;10) {
 689                 pArgs-&gt;options=pPieces-&gt;options=(pPieces-&gt;options&amp;~UCNV_OPTION_VERSION)|(uint32_t)(c-&#39;0&#39;);
 690                 ++inName;
 691             }
 692         } else if(uprv_strncmp(inName, &quot;swaplfnl&quot;, 8)==0) {
 693             inName+=8;
 694             pArgs-&gt;options=(pPieces-&gt;options|=UCNV_OPTION_SWAP_LFNL);
 695         /* add processing for new options here with another } else if(uprv_strncmp(inName, &quot;option-name=&quot;, XX)==0) { */
 696         } else {
 697             /* ignore any other options until we define some */
 698             while(((c = *inName++) != 0) &amp;&amp; (c != UCNV_OPTION_SEP_CHAR)) {
 699             }
 700             if(c==0) {
 701                 return;
 702             }
 703         }
 704     }
 705 }
 706 
 707 /*Logic determines if the converter is Algorithmic AND/OR cached
 708  *depending on that:
 709  * -we either go to get data from disk and cache it (Data=TRUE, Cached=False)
 710  * -Get it from a Hashtable (Data=X, Cached=TRUE)
 711  * -Call dataConverter initializer (Data=TRUE, Cached=TRUE)
 712  * -Call AlgorithmicConverter initializer (Data=FALSE, Cached=TRUE)
 713  */
 714 U_CFUNC UConverterSharedData *
 715 ucnv_loadSharedData(const char *converterName,
 716                     UConverterNamePieces *pPieces,
 717                     UConverterLoadArgs *pArgs,
 718                     UErrorCode * err) {
 719     UConverterNamePieces stackPieces;
 720     UConverterLoadArgs stackArgs;
 721     UConverterSharedData *mySharedConverterData = NULL;
 722     UErrorCode internalErrorCode = U_ZERO_ERROR;
 723     UBool mayContainOption = TRUE;
 724     UBool checkForAlgorithmic = TRUE;
 725 
 726     if (U_FAILURE (*err)) {
 727         return NULL;
 728     }
 729 
 730     if(pPieces == NULL) {
 731         if(pArgs != NULL) {
 732             /*
 733              * Bad: We may set pArgs pointers to stackPieces fields
 734              * which will be invalid after this function returns.
 735              */
 736             *err = U_INTERNAL_PROGRAM_ERROR;
 737             return NULL;
 738         }
 739         pPieces = &amp;stackPieces;
 740     }
 741     if(pArgs == NULL) {
 742         uprv_memset(&amp;stackArgs, 0, sizeof(stackArgs));
 743         stackArgs.size = (int32_t)sizeof(stackArgs);
 744         pArgs = &amp;stackArgs;
 745     }
 746 
 747     pPieces-&gt;cnvName[0] = 0;
 748     pPieces-&gt;locale[0] = 0;
 749     pPieces-&gt;options = 0;
 750 
 751     pArgs-&gt;name = converterName;
 752     pArgs-&gt;locale = pPieces-&gt;locale;
 753     pArgs-&gt;options = pPieces-&gt;options;
 754 
 755     /* In case &quot;name&quot; is NULL we want to open the default converter. */
 756     if (converterName == NULL) {
 757 #if U_CHARSET_IS_UTF8
 758         pArgs-&gt;name = &quot;UTF-8&quot;;
 759         return (UConverterSharedData *)converterData[UCNV_UTF8];
 760 #else
 761         /* Call ucnv_getDefaultName first to query the name from the OS. */
 762         pArgs-&gt;name = ucnv_getDefaultName();
 763         if (pArgs-&gt;name == NULL) {
 764             *err = U_MISSING_RESOURCE_ERROR;
 765             return NULL;
 766         }
 767         mySharedConverterData = (UConverterSharedData *)gDefaultAlgorithmicSharedData;
 768         checkForAlgorithmic = FALSE;
 769         mayContainOption = gDefaultConverterContainsOption;
 770         /* the default converter name is already canonical */
 771 #endif
 772     }
 773     else if(UCNV_FAST_IS_UTF8(converterName)) {
 774         /* fastpath for UTF-8 */
 775         pArgs-&gt;name = &quot;UTF-8&quot;;
 776         return (UConverterSharedData *)converterData[UCNV_UTF8];
 777     }
 778     else {
 779         /* separate the converter name from the options */
 780         parseConverterOptions(converterName, pPieces, pArgs, err);
 781         if (U_FAILURE(*err)) {
 782             /* Very bad name used. */
 783             return NULL;
 784         }
 785 
 786         /* get the canonical converter name */
 787         pArgs-&gt;name = ucnv_io_getConverterName(pArgs-&gt;name, &amp;mayContainOption, &amp;internalErrorCode);
 788         if (U_FAILURE(internalErrorCode) || pArgs-&gt;name == NULL) {
 789             /*
 790             * set the input name in case the converter was added
 791             * without updating the alias table, or when there is no alias table
 792             */
 793             pArgs-&gt;name = pPieces-&gt;cnvName;
 794         } else if (internalErrorCode == U_AMBIGUOUS_ALIAS_WARNING) {
 795             *err = U_AMBIGUOUS_ALIAS_WARNING;
 796         }
 797     }
 798 
 799     /* separate the converter name from the options */
 800     if(mayContainOption &amp;&amp; pArgs-&gt;name != pPieces-&gt;cnvName) {
 801         parseConverterOptions(pArgs-&gt;name, pPieces, pArgs, err);
 802     }
 803 
 804     /* get the shared data for an algorithmic converter, if it is one */
 805     if (checkForAlgorithmic) {
 806         mySharedConverterData = (UConverterSharedData *)getAlgorithmicTypeFromName(pArgs-&gt;name);
 807     }
 808     if (mySharedConverterData == NULL)
 809     {
 810         /* it is a data-based converter, get its shared data.               */
 811         /* Hold the cnvCacheMutex through the whole process of checking the */
 812         /*   converter data cache, and adding new entries to the cache      */
 813         /*   to prevent other threads from modifying the cache during the   */
 814         /*   process.                                                       */
 815         pArgs-&gt;nestedLoads=1;
 816         pArgs-&gt;pkg=NULL;
 817 
<a name="6" id="anc6"></a><span class="line-modified"> 818         umtx_lock(cnvCacheMutex());</span>
 819         mySharedConverterData = ucnv_load(pArgs, err);
<a name="7" id="anc7"></a><span class="line-modified"> 820         umtx_unlock(cnvCacheMutex());</span>
 821         if (U_FAILURE (*err) || (mySharedConverterData == NULL))
 822         {
 823             return NULL;
 824         }
 825     }
 826 
 827     return mySharedConverterData;
 828 }
 829 
 830 U_CAPI UConverter *
 831 ucnv_createConverter(UConverter *myUConverter, const char *converterName, UErrorCode * err)
 832 {
 833     UConverterNamePieces stackPieces;
 834     UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;
 835     UConverterSharedData *mySharedConverterData;
 836 
 837     UTRACE_ENTRY_OC(UTRACE_UCNV_OPEN);
 838 
 839     if(U_SUCCESS(*err)) {
 840         UTRACE_DATA1(UTRACE_OPEN_CLOSE, &quot;open converter %s&quot;, converterName);
 841 
 842         mySharedConverterData = ucnv_loadSharedData(converterName, &amp;stackPieces, &amp;stackArgs, err);
 843 
 844         myUConverter = ucnv_createConverterFromSharedData(
 845             myUConverter, mySharedConverterData,
 846             &amp;stackArgs,
 847             err);
 848 
 849         if(U_SUCCESS(*err)) {
 850             UTRACE_EXIT_PTR_STATUS(myUConverter, *err);
 851             return myUConverter;
 852         }
 853     }
 854 
 855     /* exit with error */
 856     UTRACE_EXIT_STATUS(*err);
 857     return NULL;
 858 }
 859 
 860 U_CFUNC UBool
 861 ucnv_canCreateConverter(const char *converterName, UErrorCode *err) {
 862     UConverter myUConverter;
 863     UConverterNamePieces stackPieces;
 864     UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;
 865     UConverterSharedData *mySharedConverterData;
 866 
 867     UTRACE_ENTRY_OC(UTRACE_UCNV_OPEN);
 868 
 869     if(U_SUCCESS(*err)) {
 870         UTRACE_DATA1(UTRACE_OPEN_CLOSE, &quot;test if can open converter %s&quot;, converterName);
 871 
 872         stackArgs.onlyTestIsLoadable=TRUE;
 873         mySharedConverterData = ucnv_loadSharedData(converterName, &amp;stackPieces, &amp;stackArgs, err);
 874         ucnv_createConverterFromSharedData(
 875             &amp;myUConverter, mySharedConverterData,
 876             &amp;stackArgs,
 877             err);
 878         ucnv_unloadSharedDataIfReady(mySharedConverterData);
 879     }
 880 
 881     UTRACE_EXIT_STATUS(*err);
 882     return U_SUCCESS(*err);
 883 }
 884 
 885 UConverter *
 886 ucnv_createAlgorithmicConverter(UConverter *myUConverter,
 887                                 UConverterType type,
 888                                 const char *locale, uint32_t options,
 889                                 UErrorCode *err) {
 890     UConverter *cnv;
 891     const UConverterSharedData *sharedData;
 892     UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;
 893 
 894     UTRACE_ENTRY_OC(UTRACE_UCNV_OPEN_ALGORITHMIC);
 895     UTRACE_DATA1(UTRACE_OPEN_CLOSE, &quot;open algorithmic converter type %d&quot;, (int32_t)type);
 896 
 897     if(type&lt;0 || UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES&lt;=type) {
 898         *err = U_ILLEGAL_ARGUMENT_ERROR;
 899         UTRACE_EXIT_STATUS(U_ILLEGAL_ARGUMENT_ERROR);
 900         return NULL;
 901     }
 902 
 903     sharedData = converterData[type];
 904     if(sharedData == NULL || sharedData-&gt;isReferenceCounted) {
 905         /* not a valid type, or not an algorithmic converter */
 906         *err = U_ILLEGAL_ARGUMENT_ERROR;
 907         UTRACE_EXIT_STATUS(U_ILLEGAL_ARGUMENT_ERROR);
 908         return NULL;
 909     }
 910 
 911     stackArgs.name = &quot;&quot;;
 912     stackArgs.options = options;
 913     stackArgs.locale=locale;
 914     cnv = ucnv_createConverterFromSharedData(
 915             myUConverter, (UConverterSharedData *)sharedData,
 916             &amp;stackArgs, err);
 917 
 918     UTRACE_EXIT_PTR_STATUS(cnv, *err);
 919     return cnv;
 920 }
 921 
 922 U_CFUNC UConverter*
 923 ucnv_createConverterFromPackage(const char *packageName, const char *converterName, UErrorCode * err)
 924 {
 925     UConverter *myUConverter;
 926     UConverterSharedData *mySharedConverterData;
 927     UConverterNamePieces stackPieces;
 928     UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;
 929 
 930     UTRACE_ENTRY_OC(UTRACE_UCNV_OPEN_PACKAGE);
 931 
 932     if(U_FAILURE(*err)) {
 933         UTRACE_EXIT_STATUS(*err);
 934         return NULL;
 935     }
 936 
 937     UTRACE_DATA2(UTRACE_OPEN_CLOSE, &quot;open converter %s from package %s&quot;, converterName, packageName);
 938 
 939     /* first, get the options out of the converterName string */
 940     stackPieces.cnvName[0] = 0;
 941     stackPieces.locale[0] = 0;
 942     stackPieces.options = 0;
 943     parseConverterOptions(converterName, &amp;stackPieces, &amp;stackArgs, err);
 944     if (U_FAILURE(*err)) {
 945         /* Very bad name used. */
 946         UTRACE_EXIT_STATUS(*err);
 947         return NULL;
 948     }
 949     stackArgs.nestedLoads=1;
 950     stackArgs.pkg=packageName;
 951 
 952     /* open the data, unflatten the shared structure */
 953     mySharedConverterData = createConverterFromFile(&amp;stackArgs, err);
 954 
 955     if (U_FAILURE(*err)) {
 956         UTRACE_EXIT_STATUS(*err);
 957         return NULL;
 958     }
 959 
 960     /* create the actual converter */
 961     myUConverter = ucnv_createConverterFromSharedData(NULL, mySharedConverterData, &amp;stackArgs, err);
 962 
 963     if (U_FAILURE(*err)) {
 964         ucnv_close(myUConverter);
 965         UTRACE_EXIT_STATUS(*err);
 966         return NULL;
 967     }
 968 
 969     UTRACE_EXIT_PTR_STATUS(myUConverter, *err);
 970     return myUConverter;
 971 }
 972 
 973 
 974 U_CFUNC UConverter*
 975 ucnv_createConverterFromSharedData(UConverter *myUConverter,
 976                                    UConverterSharedData *mySharedConverterData,
 977                                    UConverterLoadArgs *pArgs,
 978                                    UErrorCode *err)
 979 {
 980     UBool isCopyLocal;
 981 
 982     if(U_FAILURE(*err)) {
 983         ucnv_unloadSharedDataIfReady(mySharedConverterData);
 984         return myUConverter;
 985     }
 986     if(myUConverter == NULL)
 987     {
 988         myUConverter = (UConverter *) uprv_malloc (sizeof (UConverter));
 989         if(myUConverter == NULL)
 990         {
 991             *err = U_MEMORY_ALLOCATION_ERROR;
 992             ucnv_unloadSharedDataIfReady(mySharedConverterData);
 993             return NULL;
 994         }
 995         isCopyLocal = FALSE;
 996     } else {
 997         isCopyLocal = TRUE;
 998     }
 999 
1000     /* initialize the converter */
1001     uprv_memset(myUConverter, 0, sizeof(UConverter));
1002     myUConverter-&gt;isCopyLocal = isCopyLocal;
1003     /*myUConverter-&gt;isExtraLocal = FALSE;*/ /* Set by the memset call */
1004     myUConverter-&gt;sharedData = mySharedConverterData;
1005     myUConverter-&gt;options = pArgs-&gt;options;
1006     if(!pArgs-&gt;onlyTestIsLoadable) {
1007         myUConverter-&gt;preFromUFirstCP = U_SENTINEL;
1008         myUConverter-&gt;fromCharErrorBehaviour = UCNV_TO_U_DEFAULT_CALLBACK;
1009         myUConverter-&gt;fromUCharErrorBehaviour = UCNV_FROM_U_DEFAULT_CALLBACK;
1010         myUConverter-&gt;toUnicodeStatus = mySharedConverterData-&gt;toUnicodeStatus;
1011         myUConverter-&gt;maxBytesPerUChar = mySharedConverterData-&gt;staticData-&gt;maxBytesPerChar;
1012         myUConverter-&gt;subChar1 = mySharedConverterData-&gt;staticData-&gt;subChar1;
1013         myUConverter-&gt;subCharLen = mySharedConverterData-&gt;staticData-&gt;subCharLen;
1014         myUConverter-&gt;subChars = (uint8_t *)myUConverter-&gt;subUChars;
1015         uprv_memcpy(myUConverter-&gt;subChars, mySharedConverterData-&gt;staticData-&gt;subChar, myUConverter-&gt;subCharLen);
1016         myUConverter-&gt;toUCallbackReason = UCNV_ILLEGAL; /* default reason to invoke (*fromCharErrorBehaviour) */
1017     }
1018 
1019     if(mySharedConverterData-&gt;impl-&gt;open != NULL) {
1020         mySharedConverterData-&gt;impl-&gt;open(myUConverter, pArgs, err);
1021         if(U_FAILURE(*err) &amp;&amp; !pArgs-&gt;onlyTestIsLoadable) {
1022             /* don&#39;t ucnv_close() if onlyTestIsLoadable because not fully initialized */
1023             ucnv_close(myUConverter);
1024             return NULL;
1025         }
1026     }
1027 
1028     return myUConverter;
1029 }
1030 
1031 /*Frees all shared immutable objects that aren&#39;t referred to (reference count = 0)
1032  */
1033 U_CAPI int32_t U_EXPORT2
1034 ucnv_flushCache ()
1035 {
1036     UConverterSharedData *mySharedData = NULL;
1037     int32_t pos;
1038     int32_t tableDeletedNum = 0;
1039     const UHashElement *e;
1040     /*UErrorCode status = U_ILLEGAL_ARGUMENT_ERROR;*/
1041     int32_t i, remaining;
1042 
1043     UTRACE_ENTRY_OC(UTRACE_UCNV_FLUSH_CACHE);
1044 
1045     /* Close the default converter without creating a new one so that everything will be flushed. */
1046     u_flushDefaultConverter();
1047 
1048     /*if shared data hasn&#39;t even been lazy evaluated yet
1049     * return 0
1050     */
1051     if (SHARED_DATA_HASHTABLE == NULL) {
1052         UTRACE_EXIT_VALUE((int32_t)0);
1053         return 0;
1054     }
1055 
1056     /*creates an enumeration to iterate through every element in the
1057     * table
1058     *
1059     * Synchronization:  holding cnvCacheMutex will prevent any other thread from
1060     *                   accessing or modifying the hash table during the iteration.
1061     *                   The reference count of an entry may be decremented by
1062     *                   ucnv_close while the iteration is in process, but this is
1063     *                   benign.  It can&#39;t be incremented (in ucnv_createConverter())
1064     *                   because the sequence of looking up in the cache + incrementing
1065     *                   is protected by cnvCacheMutex.
1066     */
<a name="8" id="anc8"></a><span class="line-modified">1067     umtx_lock(cnvCacheMutex());</span>
1068     /*
1069      * double loop: A delta/extension-only converter has a pointer to its base table&#39;s
1070      * shared data; the first iteration of the outer loop may see the delta converter
1071      * before the base converter, and unloading the delta converter may get the base
1072      * converter&#39;s reference counter down to 0.
1073      */
1074     i = 0;
1075     do {
1076         remaining = 0;
1077         pos = UHASH_FIRST;
1078         while ((e = uhash_nextElement (SHARED_DATA_HASHTABLE, &amp;pos)) != NULL)
1079         {
1080             mySharedData = (UConverterSharedData *) e-&gt;value.pointer;
1081             /*deletes only if reference counter == 0 */
1082             if (mySharedData-&gt;referenceCounter == 0)
1083             {
1084                 tableDeletedNum++;
1085 
1086                 UCNV_DEBUG_LOG(&quot;del&quot;,mySharedData-&gt;staticData-&gt;name,mySharedData);
1087 
1088                 uhash_removeElement(SHARED_DATA_HASHTABLE, e);
1089                 mySharedData-&gt;sharedDataCached = FALSE;
1090                 ucnv_deleteSharedConverterData (mySharedData);
1091             } else {
1092                 ++remaining;
1093             }
1094         }
1095     } while(++i == 1 &amp;&amp; remaining &gt; 0);
<a name="9" id="anc9"></a><span class="line-modified">1096     umtx_unlock(cnvCacheMutex());</span>
1097 
1098     UTRACE_DATA1(UTRACE_INFO, &quot;ucnv_flushCache() exits with %d converters remaining&quot;, remaining);
1099 
1100     UTRACE_EXIT_VALUE(tableDeletedNum);
1101     return tableDeletedNum;
1102 }
1103 
1104 /* available converters list --------------------------------------------------- */
1105 
1106 static void U_CALLCONV initAvailableConvertersList(UErrorCode &amp;errCode) {
1107     U_ASSERT(gAvailableConverterCount == 0);
1108     U_ASSERT(gAvailableConverters == NULL);
1109 
1110     ucnv_enableCleanup();
1111     UEnumeration *allConvEnum = ucnv_openAllNames(&amp;errCode);
1112     int32_t allConverterCount = uenum_count(allConvEnum, &amp;errCode);
1113     if (U_FAILURE(errCode)) {
1114         return;
1115     }
1116 
1117     /* We can&#39;t have more than &quot;*converterTable&quot; converters to open */
1118     gAvailableConverters = (const char **) uprv_malloc(allConverterCount * sizeof(char*));
1119     if (!gAvailableConverters) {
1120         errCode = U_MEMORY_ALLOCATION_ERROR;
1121         return;
1122     }
1123 
1124     /* Open the default converter to make sure that it has first dibs in the hash table. */
1125     UErrorCode localStatus = U_ZERO_ERROR;
1126     UConverter tempConverter;
1127     ucnv_close(ucnv_createConverter(&amp;tempConverter, NULL, &amp;localStatus));
1128 
1129     gAvailableConverterCount = 0;
1130 
1131     for (int32_t idx = 0; idx &lt; allConverterCount; idx++) {
1132         localStatus = U_ZERO_ERROR;
1133         const char *converterName = uenum_next(allConvEnum, NULL, &amp;localStatus);
1134         if (ucnv_canCreateConverter(converterName, &amp;localStatus)) {
1135             gAvailableConverters[gAvailableConverterCount++] = converterName;
1136         }
1137     }
1138 
1139     uenum_close(allConvEnum);
1140 }
1141 
1142 
1143 static UBool haveAvailableConverterList(UErrorCode *pErrorCode) {
1144     umtx_initOnce(gAvailableConvertersInitOnce, &amp;initAvailableConvertersList, *pErrorCode);
1145     return U_SUCCESS(*pErrorCode);
1146 }
1147 
1148 U_CFUNC uint16_t
1149 ucnv_bld_countAvailableConverters(UErrorCode *pErrorCode) {
1150     if (haveAvailableConverterList(pErrorCode)) {
1151         return gAvailableConverterCount;
1152     }
1153     return 0;
1154 }
1155 
1156 U_CFUNC const char *
1157 ucnv_bld_getAvailableConverter(uint16_t n, UErrorCode *pErrorCode) {
1158     if (haveAvailableConverterList(pErrorCode)) {
1159         if (n &lt; gAvailableConverterCount) {
1160             return gAvailableConverters[n];
1161         }
1162         *pErrorCode = U_INDEX_OUTOFBOUNDS_ERROR;
1163     }
1164     return NULL;
1165 }
1166 
1167 /* default converter name --------------------------------------------------- */
1168 
1169 #if !U_CHARSET_IS_UTF8
1170 /*
1171 Copy the canonical converter name.
1172 ucnv_getDefaultName must be thread safe, which can call this function.
1173 
1174 ucnv_setDefaultName calls this function and it doesn&#39;t have to be
1175 thread safe because there is no reliable/safe way to reset the
1176 converter in use in all threads. If you did reset the converter, you
1177 would not be sure that retrieving a default converter for one string
1178 would be the same type of default converter for a successive string.
1179 Since the name is a returned via ucnv_getDefaultName without copying,
1180 you shouldn&#39;t be modifying or deleting the string from a separate thread.
1181 */
1182 static inline void
1183 internalSetName(const char *name, UErrorCode *status) {
1184     UConverterNamePieces stackPieces;
1185     UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;
1186     int32_t length=(int32_t)(uprv_strlen(name));
1187     UBool containsOption = (UBool)(uprv_strchr(name, UCNV_OPTION_SEP_CHAR) != NULL);
1188     const UConverterSharedData *algorithmicSharedData;
1189 
1190     stackArgs.name = name;
1191     if(containsOption) {
1192         stackPieces.cnvName[0] = 0;
1193         stackPieces.locale[0] = 0;
1194         stackPieces.options = 0;
1195         parseConverterOptions(name, &amp;stackPieces, &amp;stackArgs, status);
1196         if(U_FAILURE(*status)) {
1197             return;
1198         }
1199     }
1200     algorithmicSharedData = getAlgorithmicTypeFromName(stackArgs.name);
1201 
<a name="10" id="anc10"></a><span class="line-modified">1202     umtx_lock(cnvCacheMutex());</span>
1203 
1204     gDefaultAlgorithmicSharedData = algorithmicSharedData;
1205     gDefaultConverterContainsOption = containsOption;
1206     uprv_memcpy(gDefaultConverterNameBuffer, name, length);
1207     gDefaultConverterNameBuffer[length]=0;
1208 
1209     /* gDefaultConverterName MUST be the last global var set by this function.  */
1210     /*    It is the variable checked in ucnv_getDefaultName() to see if initialization is required. */
1211     //    But there is nothing here preventing that from being reordered, either by the compiler
1212     //             or hardware. I&#39;m adding the mutex to ucnv_getDefaultName for now. UMTX_CHECK is not enough.
1213     //             -- Andy
1214     gDefaultConverterName = gDefaultConverterNameBuffer;
1215 
1216     ucnv_enableCleanup();
1217 
<a name="11" id="anc11"></a><span class="line-modified">1218     umtx_unlock(cnvCacheMutex());</span>
1219 }
1220 #endif
1221 
1222 /*
1223  * In order to be really thread-safe, the get function would have to take
1224  * a buffer parameter and copy the current string inside a mutex block.
1225  * This implementation only tries to be really thread-safe while
1226  * setting the name.
1227  * It assumes that setting a pointer is atomic.
1228  */
1229 
1230 U_CAPI const char*  U_EXPORT2
1231 ucnv_getDefaultName() {
1232 #if U_CHARSET_IS_UTF8
1233     return &quot;UTF-8&quot;;
1234 #else
1235     /* local variable to be thread-safe */
1236     const char *name;
1237 
1238     /*
1239     Concurrent calls to ucnv_getDefaultName must be thread safe,
1240     but ucnv_setDefaultName is not thread safe.
1241     */
1242     {
<a name="12" id="anc12"></a><span class="line-modified">1243         icu::Mutex lock(cnvCacheMutex());</span>
1244         name = gDefaultConverterName;
1245     }
1246     if(name==NULL) {
1247         UErrorCode errorCode = U_ZERO_ERROR;
1248         UConverter *cnv = NULL;
1249 
1250         name = uprv_getDefaultCodepage();
1251 
1252         /* if the name is there, test it out and get the canonical name with options */
1253         if(name != NULL) {
1254             cnv = ucnv_open(name, &amp;errorCode);
1255             if(U_SUCCESS(errorCode) &amp;&amp; cnv != NULL) {
1256                 name = ucnv_getName(cnv, &amp;errorCode);
1257             }
1258         }
1259 
1260         if(name == NULL || name[0] == 0
1261             || U_FAILURE(errorCode) || cnv == NULL
1262             || uprv_strlen(name)&gt;=sizeof(gDefaultConverterNameBuffer))
1263         {
1264             /* Panic time, let&#39;s use a fallback. */
1265 #if (U_CHARSET_FAMILY == U_ASCII_FAMILY)
1266             name = &quot;US-ASCII&quot;;
1267             /* there is no &#39;algorithmic&#39; converter for EBCDIC */
1268 #elif U_PLATFORM == U_PF_OS390
1269             name = &quot;ibm-1047_P100-1995&quot; UCNV_SWAP_LFNL_OPTION_STRING;
1270 #else
1271             name = &quot;ibm-37_P100-1995&quot;;
1272 #endif
1273         }
1274 
1275         internalSetName(name, &amp;errorCode);
1276 
1277         /* The close may make the current name go away. */
1278         ucnv_close(cnv);
1279     }
1280 
1281     return name;
1282 #endif
1283 }
1284 
1285 #if U_CHARSET_IS_UTF8
1286 U_CAPI void U_EXPORT2 ucnv_setDefaultName(const char *) {}
1287 #else
1288 /*
1289 This function is not thread safe, and it can&#39;t be thread safe.
1290 See internalSetName or the API reference for details.
1291 */
1292 U_CAPI void U_EXPORT2
1293 ucnv_setDefaultName(const char *converterName) {
1294     if(converterName==NULL) {
1295         /* reset to the default codepage */
1296         gDefaultConverterName=NULL;
1297     } else {
1298         UErrorCode errorCode = U_ZERO_ERROR;
1299         UConverter *cnv = NULL;
1300         const char *name = NULL;
1301 
1302         /* if the name is there, test it out and get the canonical name with options */
1303         cnv = ucnv_open(converterName, &amp;errorCode);
1304         if(U_SUCCESS(errorCode) &amp;&amp; cnv != NULL) {
1305             name = ucnv_getName(cnv, &amp;errorCode);
1306         }
1307 
1308         if(U_SUCCESS(errorCode) &amp;&amp; name!=NULL) {
1309             internalSetName(name, &amp;errorCode);
1310         }
1311         /* else this converter is bad to use. Don&#39;t change it to a bad value. */
1312 
1313         /* The close may make the current name go away. */
1314         ucnv_close(cnv);
1315 
1316         /* reset the converter cache */
1317         u_flushDefaultConverter();
1318     }
1319 }
1320 #endif
1321 
1322 /* data swapping ------------------------------------------------------------ */
1323 
1324 /* most of this might belong more properly into ucnvmbcs.c, but that is so large */
1325 
1326 #if !UCONFIG_NO_LEGACY_CONVERSION
1327 
1328 U_CAPI int32_t U_EXPORT2
1329 ucnv_swap(const UDataSwapper *ds,
1330           const void *inData, int32_t length, void *outData,
1331           UErrorCode *pErrorCode) {
1332     const UDataInfo *pInfo;
1333     int32_t headerSize;
1334 
1335     const uint8_t *inBytes;
1336     uint8_t *outBytes;
1337 
1338     uint32_t offset, count, staticDataSize;
1339     int32_t size;
1340 
1341     const UConverterStaticData *inStaticData;
1342     UConverterStaticData *outStaticData;
1343 
1344     const _MBCSHeader *inMBCSHeader;
1345     _MBCSHeader *outMBCSHeader;
1346     _MBCSHeader mbcsHeader;
1347     uint32_t mbcsHeaderLength;
1348     UBool noFromU=FALSE;
1349 
1350     uint8_t outputType;
1351 
1352     int32_t maxFastUChar, mbcsIndexLength;
1353 
1354     const int32_t *inExtIndexes;
1355     int32_t extOffset;
1356 
1357     /* udata_swapDataHeader checks the arguments */
1358     headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
1359     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
1360         return 0;
1361     }
1362 
1363     /* check data format and format version */
1364     pInfo=(const UDataInfo *)((const char *)inData+4);
1365     if(!(
1366         pInfo-&gt;dataFormat[0]==0x63 &amp;&amp;   /* dataFormat=&quot;cnvt&quot; */
1367         pInfo-&gt;dataFormat[1]==0x6e &amp;&amp;
1368         pInfo-&gt;dataFormat[2]==0x76 &amp;&amp;
1369         pInfo-&gt;dataFormat[3]==0x74 &amp;&amp;
1370         pInfo-&gt;formatVersion[0]==6 &amp;&amp;
1371         pInfo-&gt;formatVersion[1]&gt;=2
1372     )) {
1373         udata_printError(ds, &quot;ucnv_swap(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not recognized as an ICU .cnv conversion table\n&quot;,
1374                          pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
1375                          pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
1376                          pInfo-&gt;formatVersion[0], pInfo-&gt;formatVersion[1]);
1377         *pErrorCode=U_UNSUPPORTED_ERROR;
1378         return 0;
1379     }
1380 
1381     inBytes=(const uint8_t *)inData+headerSize;
1382     outBytes=(uint8_t *)outData+headerSize;
1383 
1384     /* read the initial UConverterStaticData structure after the UDataInfo header */
1385     inStaticData=(const UConverterStaticData *)inBytes;
1386     outStaticData=(UConverterStaticData *)outBytes;
1387 
1388     if(length&lt;0) {
1389         staticDataSize=ds-&gt;readUInt32(inStaticData-&gt;structSize);
1390     } else {
1391         length-=headerSize;
1392         if( length&lt;(int32_t)sizeof(UConverterStaticData) ||
1393             (uint32_t)length&lt;(staticDataSize=ds-&gt;readUInt32(inStaticData-&gt;structSize))
1394         ) {
1395             udata_printError(ds, &quot;ucnv_swap(): too few bytes (%d after header) for an ICU .cnv conversion table\n&quot;,
1396                              length);
1397             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
1398             return 0;
1399         }
1400     }
1401 
1402     if(length&gt;=0) {
1403         /* swap the static data */
1404         if(inStaticData!=outStaticData) {
1405             uprv_memcpy(outStaticData, inStaticData, staticDataSize);
1406         }
1407 
1408         ds-&gt;swapArray32(ds, &amp;inStaticData-&gt;structSize, 4,
1409                            &amp;outStaticData-&gt;structSize, pErrorCode);
1410         ds-&gt;swapArray32(ds, &amp;inStaticData-&gt;codepage, 4,
1411                            &amp;outStaticData-&gt;codepage, pErrorCode);
1412 
1413         ds-&gt;swapInvChars(ds, inStaticData-&gt;name, (int32_t)uprv_strlen(inStaticData-&gt;name),
1414                             outStaticData-&gt;name, pErrorCode);
1415         if(U_FAILURE(*pErrorCode)) {
1416             udata_printError(ds, &quot;ucnv_swap(): error swapping converter name\n&quot;);
1417             return 0;
1418         }
1419     }
1420 
1421     inBytes+=staticDataSize;
1422     outBytes+=staticDataSize;
1423     if(length&gt;=0) {
1424         length-=(int32_t)staticDataSize;
1425     }
1426 
1427     /* check for supported conversionType values */
1428     if(inStaticData-&gt;conversionType==UCNV_MBCS) {
1429         /* swap MBCS data */
1430         inMBCSHeader=(const _MBCSHeader *)inBytes;
1431         outMBCSHeader=(_MBCSHeader *)outBytes;
1432 
1433         if(0&lt;=length &amp;&amp; length&lt;(int32_t)sizeof(_MBCSHeader)) {
1434             udata_printError(ds, &quot;ucnv_swap(): too few bytes (%d after headers) for an ICU MBCS .cnv conversion table\n&quot;,
1435                                 length);
1436             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
1437             return 0;
1438         }
1439         if(inMBCSHeader-&gt;version[0]==4 &amp;&amp; inMBCSHeader-&gt;version[1]&gt;=1) {
1440             mbcsHeaderLength=MBCS_HEADER_V4_LENGTH;
1441         } else if(inMBCSHeader-&gt;version[0]==5 &amp;&amp; inMBCSHeader-&gt;version[1]&gt;=3 &amp;&amp;
1442                   ((mbcsHeader.options=ds-&gt;readUInt32(inMBCSHeader-&gt;options))&amp;
1443                    MBCS_OPT_UNKNOWN_INCOMPATIBLE_MASK)==0
1444         ) {
1445             mbcsHeaderLength=mbcsHeader.options&amp;MBCS_OPT_LENGTH_MASK;
1446             noFromU=(UBool)((mbcsHeader.options&amp;MBCS_OPT_NO_FROM_U)!=0);
1447         } else {
1448             udata_printError(ds, &quot;ucnv_swap(): unsupported _MBCSHeader.version %d.%d\n&quot;,
1449                              inMBCSHeader-&gt;version[0], inMBCSHeader-&gt;version[1]);
1450             *pErrorCode=U_UNSUPPORTED_ERROR;
1451             return 0;
1452         }
1453 
1454         uprv_memcpy(mbcsHeader.version, inMBCSHeader-&gt;version, 4);
1455         mbcsHeader.countStates=         ds-&gt;readUInt32(inMBCSHeader-&gt;countStates);
1456         mbcsHeader.countToUFallbacks=   ds-&gt;readUInt32(inMBCSHeader-&gt;countToUFallbacks);
1457         mbcsHeader.offsetToUCodeUnits=  ds-&gt;readUInt32(inMBCSHeader-&gt;offsetToUCodeUnits);
1458         mbcsHeader.offsetFromUTable=    ds-&gt;readUInt32(inMBCSHeader-&gt;offsetFromUTable);
1459         mbcsHeader.offsetFromUBytes=    ds-&gt;readUInt32(inMBCSHeader-&gt;offsetFromUBytes);
1460         mbcsHeader.flags=               ds-&gt;readUInt32(inMBCSHeader-&gt;flags);
1461         mbcsHeader.fromUBytesLength=    ds-&gt;readUInt32(inMBCSHeader-&gt;fromUBytesLength);
1462         /* mbcsHeader.options have been read above */
1463 
1464         extOffset=(int32_t)(mbcsHeader.flags&gt;&gt;8);
1465         outputType=(uint8_t)mbcsHeader.flags;
1466         if(noFromU &amp;&amp; outputType==MBCS_OUTPUT_1) {
1467             udata_printError(ds, &quot;ucnv_swap(): unsupported combination of makeconv --small with SBCS\n&quot;);
1468             *pErrorCode=U_UNSUPPORTED_ERROR;
1469             return 0;
1470         }
1471 
1472         /* make sure that the output type is known */
1473         switch(outputType) {
1474         case MBCS_OUTPUT_1:
1475         case MBCS_OUTPUT_2:
1476         case MBCS_OUTPUT_3:
1477         case MBCS_OUTPUT_4:
1478         case MBCS_OUTPUT_3_EUC:
1479         case MBCS_OUTPUT_4_EUC:
1480         case MBCS_OUTPUT_2_SISO:
1481         case MBCS_OUTPUT_EXT_ONLY:
1482             /* OK */
1483             break;
1484         default:
1485             udata_printError(ds, &quot;ucnv_swap(): unsupported MBCS output type 0x%x\n&quot;,
1486                              outputType);
1487             *pErrorCode=U_UNSUPPORTED_ERROR;
1488             return 0;
1489         }
1490 
1491         /* calculate the length of the MBCS data */
1492 
1493         /*
1494          * utf8Friendly MBCS files (mbcsHeader.version 4.3)
1495          * contain an additional mbcsIndex table:
1496          *   uint16_t[(maxFastUChar+1)&gt;&gt;6];
1497          * where maxFastUChar=((mbcsHeader.version[2]&lt;&lt;8)|0xff).
1498          */
1499         maxFastUChar=0;
1500         mbcsIndexLength=0;
1501         if( outputType!=MBCS_OUTPUT_EXT_ONLY &amp;&amp; outputType!=MBCS_OUTPUT_1 &amp;&amp;
1502             mbcsHeader.version[1]&gt;=3 &amp;&amp; (maxFastUChar=mbcsHeader.version[2])!=0
1503         ) {
1504             maxFastUChar=(maxFastUChar&lt;&lt;8)|0xff;
1505             mbcsIndexLength=((maxFastUChar+1)&gt;&gt;6)*2;  /* number of bytes */
1506         }
1507 
1508         if(extOffset==0) {
1509             size=(int32_t)(mbcsHeader.offsetFromUBytes+mbcsIndexLength);
1510             if(!noFromU) {
1511                 size+=(int32_t)mbcsHeader.fromUBytesLength;
1512             }
1513 
1514             /* avoid compiler warnings - not otherwise necessary, and the value does not matter */
1515             inExtIndexes=NULL;
1516         } else {
1517             /* there is extension data after the base data, see ucnv_ext.h */
1518             if(length&gt;=0 &amp;&amp; length&lt;(extOffset+UCNV_EXT_INDEXES_MIN_LENGTH*4)) {
1519                 udata_printError(ds, &quot;ucnv_swap(): too few bytes (%d after headers) for an ICU MBCS .cnv conversion table with extension data\n&quot;,
1520                                  length);
1521                 *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
1522                 return 0;
1523             }
1524 
1525             inExtIndexes=(const int32_t *)(inBytes+extOffset);
1526             size=extOffset+udata_readInt32(ds, inExtIndexes[UCNV_EXT_SIZE]);
1527         }
1528 
1529         if(length&gt;=0) {
1530             if(length&lt;size) {
1531                 udata_printError(ds, &quot;ucnv_swap(): too few bytes (%d after headers) for an ICU MBCS .cnv conversion table\n&quot;,
1532                                  length);
1533                 *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
1534                 return 0;
1535             }
1536 
1537             /* copy the data for inaccessible bytes */
1538             if(inBytes!=outBytes) {
1539                 uprv_memcpy(outBytes, inBytes, size);
1540             }
1541 
1542             /* swap the MBCSHeader, except for the version field */
1543             count=mbcsHeaderLength*4;
1544             ds-&gt;swapArray32(ds, &amp;inMBCSHeader-&gt;countStates, count-4,
1545                                &amp;outMBCSHeader-&gt;countStates, pErrorCode);
1546 
1547             if(outputType==MBCS_OUTPUT_EXT_ONLY) {
1548                 /*
1549                  * extension-only file,
1550                  * contains a base name instead of normal base table data
1551                  */
1552 
1553                 /* swap the base name, between the header and the extension data */
1554                 const char *inBaseName=(const char *)inBytes+count;
1555                 char *outBaseName=(char *)outBytes+count;
1556                 ds-&gt;swapInvChars(ds, inBaseName, (int32_t)uprv_strlen(inBaseName),
1557                                     outBaseName, pErrorCode);
1558             } else {
1559                 /* normal file with base table data */
1560 
1561                 /* swap the state table, 1kB per state */
1562                 offset=count;
1563                 count=mbcsHeader.countStates*1024;
1564                 ds-&gt;swapArray32(ds, inBytes+offset, (int32_t)count,
1565                                    outBytes+offset, pErrorCode);
1566 
1567                 /* swap the toUFallbacks[] */
1568                 offset+=count;
1569                 count=mbcsHeader.countToUFallbacks*8;
1570                 ds-&gt;swapArray32(ds, inBytes+offset, (int32_t)count,
1571                                    outBytes+offset, pErrorCode);
1572 
1573                 /* swap the unicodeCodeUnits[] */
1574                 offset=mbcsHeader.offsetToUCodeUnits;
1575                 count=mbcsHeader.offsetFromUTable-offset;
1576                 ds-&gt;swapArray16(ds, inBytes+offset, (int32_t)count,
1577                                    outBytes+offset, pErrorCode);
1578 
1579                 /* offset to the stage 1 table, independent of the outputType */
1580                 offset=mbcsHeader.offsetFromUTable;
1581 
1582                 if(outputType==MBCS_OUTPUT_1) {
1583                     /* SBCS: swap the fromU tables, all 16 bits wide */
1584                     count=(mbcsHeader.offsetFromUBytes-offset)+mbcsHeader.fromUBytesLength;
1585                     ds-&gt;swapArray16(ds, inBytes+offset, (int32_t)count,
1586                                        outBytes+offset, pErrorCode);
1587                 } else {
1588                     /* otherwise: swap the stage tables separately */
1589 
1590                     /* stage 1 table: uint16_t[0x440 or 0x40] */
1591                     if(inStaticData-&gt;unicodeMask&amp;UCNV_HAS_SUPPLEMENTARY) {
1592                         count=0x440*2; /* for all of Unicode */
1593                     } else {
1594                         count=0x40*2; /* only BMP */
1595                     }
1596                     ds-&gt;swapArray16(ds, inBytes+offset, (int32_t)count,
1597                                        outBytes+offset, pErrorCode);
1598 
1599                     /* stage 2 table: uint32_t[] */
1600                     offset+=count;
1601                     count=mbcsHeader.offsetFromUBytes-offset;
1602                     ds-&gt;swapArray32(ds, inBytes+offset, (int32_t)count,
1603                                        outBytes+offset, pErrorCode);
1604 
1605                     /* stage 3/result bytes: sometimes uint16_t[] or uint32_t[] */
1606                     offset=mbcsHeader.offsetFromUBytes;
1607                     count= noFromU ? 0 : mbcsHeader.fromUBytesLength;
1608                     switch(outputType) {
1609                     case MBCS_OUTPUT_2:
1610                     case MBCS_OUTPUT_3_EUC:
1611                     case MBCS_OUTPUT_2_SISO:
1612                         ds-&gt;swapArray16(ds, inBytes+offset, (int32_t)count,
1613                                            outBytes+offset, pErrorCode);
1614                         break;
1615                     case MBCS_OUTPUT_4:
1616                         ds-&gt;swapArray32(ds, inBytes+offset, (int32_t)count,
1617                                            outBytes+offset, pErrorCode);
1618                         break;
1619                     default:
1620                         /* just uint8_t[], nothing to swap */
1621                         break;
1622                     }
1623 
1624                     if(mbcsIndexLength!=0) {
1625                         offset+=count;
1626                         count=mbcsIndexLength;
1627                         ds-&gt;swapArray16(ds, inBytes+offset, (int32_t)count,
1628                                            outBytes+offset, pErrorCode);
1629                     }
1630                 }
1631             }
1632 
1633             if(extOffset!=0) {
1634                 /* swap the extension data */
1635                 inBytes+=extOffset;
1636                 outBytes+=extOffset;
1637 
1638                 /* swap toUTable[] */
1639                 offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_TO_U_INDEX]);
1640                 length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_TO_U_LENGTH]);
1641                 ds-&gt;swapArray32(ds, inBytes+offset, length*4, outBytes+offset, pErrorCode);
1642 
1643                 /* swap toUUChars[] */
1644                 offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_TO_U_UCHARS_INDEX]);
1645                 length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_TO_U_UCHARS_LENGTH]);
1646                 ds-&gt;swapArray16(ds, inBytes+offset, length*2, outBytes+offset, pErrorCode);
1647 
1648                 /* swap fromUTableUChars[] */
1649                 offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_UCHARS_INDEX]);
1650                 length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_LENGTH]);
1651                 ds-&gt;swapArray16(ds, inBytes+offset, length*2, outBytes+offset, pErrorCode);
1652 
1653                 /* swap fromUTableValues[] */
1654                 offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_VALUES_INDEX]);
1655                 /* same length as for fromUTableUChars[] */
1656                 ds-&gt;swapArray32(ds, inBytes+offset, length*4, outBytes+offset, pErrorCode);
1657 
1658                 /* no need to swap fromUBytes[] */
1659 
1660                 /* swap fromUStage12[] */
1661                 offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_12_INDEX]);
1662                 length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_12_LENGTH]);
1663                 ds-&gt;swapArray16(ds, inBytes+offset, length*2, outBytes+offset, pErrorCode);
1664 
1665                 /* swap fromUStage3[] */
1666                 offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_3_INDEX]);
1667                 length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_3_LENGTH]);
1668                 ds-&gt;swapArray16(ds, inBytes+offset, length*2, outBytes+offset, pErrorCode);
1669 
1670                 /* swap fromUStage3b[] */
1671                 offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_3B_INDEX]);
1672                 length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_3B_LENGTH]);
1673                 ds-&gt;swapArray32(ds, inBytes+offset, length*4, outBytes+offset, pErrorCode);
1674 
1675                 /* swap indexes[] */
1676                 length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_INDEXES_LENGTH]);
1677                 ds-&gt;swapArray32(ds, inBytes, length*4, outBytes, pErrorCode);
1678             }
1679         }
1680     } else {
1681         udata_printError(ds, &quot;ucnv_swap(): unknown conversionType=%d!=UCNV_MBCS\n&quot;,
1682                          inStaticData-&gt;conversionType);
1683         *pErrorCode=U_UNSUPPORTED_ERROR;
1684         return 0;
1685     }
1686 
1687     return headerSize+(int32_t)staticDataSize+size;
1688 }
1689 
1690 #endif /* #if !UCONFIG_NO_LEGACY_CONVERSION */
1691 
1692 #endif
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>