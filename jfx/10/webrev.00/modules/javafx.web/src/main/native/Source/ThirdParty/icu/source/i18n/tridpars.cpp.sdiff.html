<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tridpars.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="transreg.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="tzfmt.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tridpars.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 
 34 static const UChar ID_DELIM    = 0x003B; // ;
 35 static const UChar TARGET_SEP  = 0x002D; // -
 36 static const UChar VARIANT_SEP = 0x002F; // /
 37 static const UChar OPEN_REV    = 0x0028; // (
 38 static const UChar CLOSE_REV   = 0x0029; // )
 39 
 40 //static const UChar EMPTY[]     = {0}; // &quot;&quot;
 41 static const UChar ANY[]       = {65,110,121,0}; // &quot;Any&quot;
 42 static const UChar ANY_NULL[]  = {65,110,121,45,78,117,108,108,0}; // &quot;Any-Null&quot;
 43 
 44 static const int32_t FORWARD = UTRANS_FORWARD;
 45 static const int32_t REVERSE = UTRANS_REVERSE;
 46 
 47 static Hashtable* SPECIAL_INVERSES = NULL;
 48 static UInitOnce gSpecialInversesInitOnce = U_INITONCE_INITIALIZER;
 49 
 50 /**
 51  * The mutex controlling access to SPECIAL_INVERSES
 52  */
<span class="line-modified"> 53 static UMutex LOCK = U_MUTEX_INITIALIZER;</span>



 54 
 55 TransliteratorIDParser::Specs::Specs(const UnicodeString&amp; s, const UnicodeString&amp; t,
 56                                      const UnicodeString&amp; v, UBool sawS,
 57                                      const UnicodeString&amp; f) {
 58     source = s;
 59     target = t;
 60     variant = v;
 61     sawSource = sawS;
 62     filter = f;
 63 }
 64 
 65 TransliteratorIDParser::SingleID::SingleID(const UnicodeString&amp; c, const UnicodeString&amp; b,
 66                                            const UnicodeString&amp; f) {
 67     canonID = c;
 68     basicID = b;
 69     filter = f;
 70 }
 71 
 72 TransliteratorIDParser::SingleID::SingleID(const UnicodeString&amp; c, const UnicodeString&amp; b) {
 73     canonID = c;
</pre>
<hr />
<pre>
642  * @param target the target against which to register the inverse
643  * @param inverseTarget the inverse of target, that is
644  * Any-target.getInverse() =&gt; Any-inverseTarget
645  * @param bidirectional if TRUE, register the reverse relation
646  * as well, that is, Any-inverseTarget.getInverse() =&gt; Any-target
647  */
648 void TransliteratorIDParser::registerSpecialInverse(const UnicodeString&amp; target,
649                                                     const UnicodeString&amp; inverseTarget,
650                                                     UBool bidirectional,
651                                                     UErrorCode &amp;status) {
652     umtx_initOnce(gSpecialInversesInitOnce, init, status);
653     if (U_FAILURE(status)) {
654         return;
655     }
656 
657     // If target == inverseTarget then force bidirectional =&gt; FALSE
658     if (bidirectional &amp;&amp; 0==target.caseCompare(inverseTarget, U_FOLD_CASE_DEFAULT)) {
659         bidirectional = FALSE;
660     }
661 
<span class="line-modified">662     Mutex lock(&amp;LOCK);</span>
663 
664     UnicodeString *tempus = new UnicodeString(inverseTarget);  // Used for null pointer check before usage.
665     if (tempus == NULL) {
666         status = U_MEMORY_ALLOCATION_ERROR;
667         return;
668     }
669     SPECIAL_INVERSES-&gt;put(target, tempus, status);
670     if (bidirectional) {
671         tempus = new UnicodeString(target);
672         if (tempus == NULL) {
673             status = U_MEMORY_ALLOCATION_ERROR;
674             return;
675         }
676         SPECIAL_INVERSES-&gt;put(inverseTarget, tempus, status);
677     }
678 }
679 
680 //----------------------------------------------------------------
681 // Private implementation
682 //----------------------------------------------------------------
</pre>
<hr />
<pre>
846 
847 /**
848  * Given a Specs object, return a SingleID representing the
849  * special inverse of that ID.  If there is no special inverse
850  * then return NULL.
851  * @return a SingleID or NULL.  Returned object always has
852  * &#39;filter&#39; field of NULL.
853  */
854 TransliteratorIDParser::SingleID*
855 TransliteratorIDParser::specsToSpecialInverse(const Specs&amp; specs, UErrorCode &amp;status) {
856     if (0!=specs.source.caseCompare(ANY, 3, U_FOLD_CASE_DEFAULT)) {
857         return NULL;
858     }
859     umtx_initOnce(gSpecialInversesInitOnce, init, status);
860     if (U_FAILURE(status)) {
861         return NULL;
862     }
863 
864     UnicodeString* inverseTarget;
865 
<span class="line-modified">866     umtx_lock(&amp;LOCK);</span>
867     inverseTarget = (UnicodeString*) SPECIAL_INVERSES-&gt;get(specs.target);
<span class="line-modified">868     umtx_unlock(&amp;LOCK);</span>
869 
870     if (inverseTarget != NULL) {
871         // If the original ID contained &quot;Any-&quot; then make the
872         // special inverse &quot;Any-Foo&quot;; otherwise make it &quot;Foo&quot;.
873         // So &quot;Any-NFC&quot; =&gt; &quot;Any-NFD&quot; but &quot;NFC&quot; =&gt; &quot;NFD&quot;.
874         UnicodeString buf;
875         if (specs.filter.length() != 0) {
876             buf.append(specs.filter);
877         }
878         if (specs.sawSource) {
879             buf.append(ANY, 3).append(TARGET_SEP);
880         }
881         buf.append(*inverseTarget);
882 
883         UnicodeString basicID(TRUE, ANY, 3);
884         basicID.append(TARGET_SEP).append(*inverseTarget);
885 
886         if (specs.variant.length() != 0) {
887             buf.append(VARIANT_SEP).append(specs.variant);
888             basicID.append(VARIANT_SEP).append(specs.variant);
</pre>
</td>
<td>
<hr />
<pre>
 33 
 34 static const UChar ID_DELIM    = 0x003B; // ;
 35 static const UChar TARGET_SEP  = 0x002D; // -
 36 static const UChar VARIANT_SEP = 0x002F; // /
 37 static const UChar OPEN_REV    = 0x0028; // (
 38 static const UChar CLOSE_REV   = 0x0029; // )
 39 
 40 //static const UChar EMPTY[]     = {0}; // &quot;&quot;
 41 static const UChar ANY[]       = {65,110,121,0}; // &quot;Any&quot;
 42 static const UChar ANY_NULL[]  = {65,110,121,45,78,117,108,108,0}; // &quot;Any-Null&quot;
 43 
 44 static const int32_t FORWARD = UTRANS_FORWARD;
 45 static const int32_t REVERSE = UTRANS_REVERSE;
 46 
 47 static Hashtable* SPECIAL_INVERSES = NULL;
 48 static UInitOnce gSpecialInversesInitOnce = U_INITONCE_INITIALIZER;
 49 
 50 /**
 51  * The mutex controlling access to SPECIAL_INVERSES
 52  */
<span class="line-modified"> 53 static UMutex *LOCK() {</span>
<span class="line-added"> 54     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added"> 55     return &amp;m;</span>
<span class="line-added"> 56 }</span>
 57 
 58 TransliteratorIDParser::Specs::Specs(const UnicodeString&amp; s, const UnicodeString&amp; t,
 59                                      const UnicodeString&amp; v, UBool sawS,
 60                                      const UnicodeString&amp; f) {
 61     source = s;
 62     target = t;
 63     variant = v;
 64     sawSource = sawS;
 65     filter = f;
 66 }
 67 
 68 TransliteratorIDParser::SingleID::SingleID(const UnicodeString&amp; c, const UnicodeString&amp; b,
 69                                            const UnicodeString&amp; f) {
 70     canonID = c;
 71     basicID = b;
 72     filter = f;
 73 }
 74 
 75 TransliteratorIDParser::SingleID::SingleID(const UnicodeString&amp; c, const UnicodeString&amp; b) {
 76     canonID = c;
</pre>
<hr />
<pre>
645  * @param target the target against which to register the inverse
646  * @param inverseTarget the inverse of target, that is
647  * Any-target.getInverse() =&gt; Any-inverseTarget
648  * @param bidirectional if TRUE, register the reverse relation
649  * as well, that is, Any-inverseTarget.getInverse() =&gt; Any-target
650  */
651 void TransliteratorIDParser::registerSpecialInverse(const UnicodeString&amp; target,
652                                                     const UnicodeString&amp; inverseTarget,
653                                                     UBool bidirectional,
654                                                     UErrorCode &amp;status) {
655     umtx_initOnce(gSpecialInversesInitOnce, init, status);
656     if (U_FAILURE(status)) {
657         return;
658     }
659 
660     // If target == inverseTarget then force bidirectional =&gt; FALSE
661     if (bidirectional &amp;&amp; 0==target.caseCompare(inverseTarget, U_FOLD_CASE_DEFAULT)) {
662         bidirectional = FALSE;
663     }
664 
<span class="line-modified">665     Mutex lock(LOCK());</span>
666 
667     UnicodeString *tempus = new UnicodeString(inverseTarget);  // Used for null pointer check before usage.
668     if (tempus == NULL) {
669         status = U_MEMORY_ALLOCATION_ERROR;
670         return;
671     }
672     SPECIAL_INVERSES-&gt;put(target, tempus, status);
673     if (bidirectional) {
674         tempus = new UnicodeString(target);
675         if (tempus == NULL) {
676             status = U_MEMORY_ALLOCATION_ERROR;
677             return;
678         }
679         SPECIAL_INVERSES-&gt;put(inverseTarget, tempus, status);
680     }
681 }
682 
683 //----------------------------------------------------------------
684 // Private implementation
685 //----------------------------------------------------------------
</pre>
<hr />
<pre>
849 
850 /**
851  * Given a Specs object, return a SingleID representing the
852  * special inverse of that ID.  If there is no special inverse
853  * then return NULL.
854  * @return a SingleID or NULL.  Returned object always has
855  * &#39;filter&#39; field of NULL.
856  */
857 TransliteratorIDParser::SingleID*
858 TransliteratorIDParser::specsToSpecialInverse(const Specs&amp; specs, UErrorCode &amp;status) {
859     if (0!=specs.source.caseCompare(ANY, 3, U_FOLD_CASE_DEFAULT)) {
860         return NULL;
861     }
862     umtx_initOnce(gSpecialInversesInitOnce, init, status);
863     if (U_FAILURE(status)) {
864         return NULL;
865     }
866 
867     UnicodeString* inverseTarget;
868 
<span class="line-modified">869     umtx_lock(LOCK());</span>
870     inverseTarget = (UnicodeString*) SPECIAL_INVERSES-&gt;get(specs.target);
<span class="line-modified">871     umtx_unlock(LOCK());</span>
872 
873     if (inverseTarget != NULL) {
874         // If the original ID contained &quot;Any-&quot; then make the
875         // special inverse &quot;Any-Foo&quot;; otherwise make it &quot;Foo&quot;.
876         // So &quot;Any-NFC&quot; =&gt; &quot;Any-NFD&quot; but &quot;NFC&quot; =&gt; &quot;NFD&quot;.
877         UnicodeString buf;
878         if (specs.filter.length() != 0) {
879             buf.append(specs.filter);
880         }
881         if (specs.sawSource) {
882             buf.append(ANY, 3).append(TARGET_SEP);
883         }
884         buf.append(*inverseTarget);
885 
886         UnicodeString basicID(TRUE, ANY, 3);
887         basicID.append(TARGET_SEP).append(*inverseTarget);
888 
889         if (specs.variant.length() != 0) {
890             buf.append(VARIANT_SEP).append(specs.variant);
891             basicID.append(VARIANT_SEP).append(specs.variant);
</pre>
</td>
</tr>
</table>
<center><a href="transreg.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="tzfmt.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>