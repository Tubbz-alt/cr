<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/measfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 * Copyright (c) 2004-2016, International Business Machines
   6 * Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 * Author: Alan Liu
   9 * Created: April 20, 2004
  10 * Since: ICU 3.0
  11 **********************************************************************
  12 */
  13 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  14 #include &quot;unicode/utypes.h&quot;
  15 
  16 #if !UCONFIG_NO_FORMATTING
  17 
  18 #include &quot;unicode/measfmt.h&quot;
  19 #include &quot;unicode/numfmt.h&quot;
  20 #include &quot;currfmt.h&quot;
  21 #include &quot;unicode/localpointer.h&quot;
  22 #include &quot;resource.h&quot;
  23 #include &quot;unicode/simpleformatter.h&quot;
  24 #include &quot;quantityformatter.h&quot;
  25 #include &quot;unicode/plurrule.h&quot;
  26 #include &quot;unicode/decimfmt.h&quot;
  27 #include &quot;uresimp.h&quot;
  28 #include &quot;unicode/ures.h&quot;
  29 #include &quot;unicode/ustring.h&quot;
  30 #include &quot;ureslocs.h&quot;
  31 #include &quot;cstring.h&quot;
  32 #include &quot;mutex.h&quot;
  33 #include &quot;ucln_in.h&quot;
  34 #include &quot;unicode/listformatter.h&quot;
  35 #include &quot;charstr.h&quot;
  36 #include &quot;unicode/putil.h&quot;
  37 #include &quot;unicode/smpdtfmt.h&quot;
  38 #include &quot;uassert.h&quot;
  39 
  40 #include &quot;sharednumberformat.h&quot;
  41 #include &quot;sharedpluralrules.h&quot;
  42 #include &quot;standardplural.h&quot;
  43 #include &quot;unifiedcache.h&quot;
  44 
  45 
  46 U_NAMESPACE_BEGIN
  47 
  48 static constexpr int32_t PER_UNIT_INDEX = StandardPlural::COUNT;
  49 static constexpr int32_t PATTERN_COUNT = PER_UNIT_INDEX + 1;
  50 static constexpr int32_t MEAS_UNIT_COUNT = 138;  // see assertion in MeasureFormatCacheData constructor
  51 static constexpr int32_t WIDTH_INDEX_COUNT = UMEASFMT_WIDTH_NARROW + 1;
  52 
  53 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(MeasureFormat)
  54 
  55 // Used to format durations like 5:47 or 21:35:42.
  56 class NumericDateFormatters : public UMemory {
  57 public:
  58     // Formats like H:mm
  59     SimpleDateFormat hourMinute;
  60 
  61     // formats like M:ss
  62     SimpleDateFormat minuteSecond;
  63 
  64     // formats like H:mm:ss
  65     SimpleDateFormat hourMinuteSecond;
  66 
  67     // Constructor that takes the actual patterns for hour-minute,
  68     // minute-second, and hour-minute-second respectively.
  69     NumericDateFormatters(
  70             const UnicodeString &amp;hm,
  71             const UnicodeString &amp;ms,
  72             const UnicodeString &amp;hms,
  73             UErrorCode &amp;status) :
  74             hourMinute(hm, status),
  75             minuteSecond(ms, status),
  76             hourMinuteSecond(hms, status) {
  77         const TimeZone *gmt = TimeZone::getGMT();
  78         hourMinute.setTimeZone(*gmt);
  79         minuteSecond.setTimeZone(*gmt);
  80         hourMinuteSecond.setTimeZone(*gmt);
  81     }
  82 private:
  83     NumericDateFormatters(const NumericDateFormatters &amp;other);
  84     NumericDateFormatters &amp;operator=(const NumericDateFormatters &amp;other);
  85 };
  86 
  87 static UMeasureFormatWidth getRegularWidth(UMeasureFormatWidth width) {
  88     if (width &gt;= WIDTH_INDEX_COUNT) {
  89         return UMEASFMT_WIDTH_NARROW;
  90     }
  91     return width;
  92 }
  93 
  94 /**
  95  * Instances contain all MeasureFormat specific data for a particular locale.
  96  * This data is cached. It is never copied, but is shared via shared pointers.
  97  *
  98  * Note: We might change the cache data to have an array[WIDTH_INDEX_COUNT] of
  99  * complete sets of unit &amp; per patterns,
 100  * to correspond to the resource data and its aliases.
 101  *
 102  * TODO: Maybe store more sparsely in general, with pointers rather than potentially-empty objects.
 103  */
 104 class MeasureFormatCacheData : public SharedObject {
 105 public:
 106 
 107     /**
 108      * Redirection data from root-bundle, top-level sideways aliases.
 109      * - UMEASFMT_WIDTH_COUNT: initial value, just fall back to root
 110      * - UMEASFMT_WIDTH_WIDE/SHORT/NARROW: sideways alias for missing data
 111      */
 112     UMeasureFormatWidth widthFallback[WIDTH_INDEX_COUNT];
 113     /** Measure unit -&gt; format width -&gt; array of patterns (&quot;{0} meters&quot;) (plurals + PER_UNIT_INDEX) */
 114     SimpleFormatter* patterns[MEAS_UNIT_COUNT][WIDTH_INDEX_COUNT][PATTERN_COUNT];
 115     const UChar* dnams[MEAS_UNIT_COUNT][WIDTH_INDEX_COUNT];
 116     SimpleFormatter perFormatters[WIDTH_INDEX_COUNT];
 117 
 118     MeasureFormatCacheData();
 119     virtual ~MeasureFormatCacheData();
 120 
 121     UBool hasPerFormatter(int32_t width) const {
 122         // TODO: Create a more obvious way to test if the per-formatter has been set?
 123         // Use pointers, check for NULL? Or add an isValid() method?
 124         return perFormatters[width].getArgumentLimit() == 2;
 125     }
 126 
 127     void adoptCurrencyFormat(int32_t widthIndex, NumberFormat *nfToAdopt) {
 128         delete currencyFormats[widthIndex];
 129         currencyFormats[widthIndex] = nfToAdopt;
 130     }
 131     const NumberFormat *getCurrencyFormat(UMeasureFormatWidth width) const {
 132         return currencyFormats[getRegularWidth(width)];
 133     }
 134     void adoptIntegerFormat(NumberFormat *nfToAdopt) {
 135         delete integerFormat;
 136         integerFormat = nfToAdopt;
 137     }
 138     const NumberFormat *getIntegerFormat() const {
 139         return integerFormat;
 140     }
 141     void adoptNumericDateFormatters(NumericDateFormatters *formattersToAdopt) {
 142         delete numericDateFormatters;
 143         numericDateFormatters = formattersToAdopt;
 144     }
 145     const NumericDateFormatters *getNumericDateFormatters() const {
 146         return numericDateFormatters;
 147     }
 148 
 149 private:
 150     NumberFormat* currencyFormats[WIDTH_INDEX_COUNT];
 151     NumberFormat* integerFormat;
 152     NumericDateFormatters* numericDateFormatters;
 153 
 154     MeasureFormatCacheData(const MeasureFormatCacheData &amp;other);
 155     MeasureFormatCacheData &amp;operator=(const MeasureFormatCacheData &amp;other);
 156 };
 157 
 158 MeasureFormatCacheData::MeasureFormatCacheData()
 159         : integerFormat(nullptr), numericDateFormatters(nullptr) {
 160     // Please update MEAS_UNIT_COUNT if it gets out of sync with the true count!
 161     U_ASSERT(MEAS_UNIT_COUNT == MeasureUnit::getIndexCount());
 162 
 163     for (int32_t i = 0; i &lt; WIDTH_INDEX_COUNT; ++i) {
 164         widthFallback[i] = UMEASFMT_WIDTH_COUNT;
 165     }
 166     memset(&amp;patterns[0][0][0], 0, sizeof(patterns));
 167     memset(&amp;dnams[0][0], 0, sizeof(dnams));
 168     memset(currencyFormats, 0, sizeof(currencyFormats));
 169 }
 170 
 171 MeasureFormatCacheData::~MeasureFormatCacheData() {
 172     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(currencyFormats); ++i) {
 173         delete currencyFormats[i];
 174     }
 175     for (int32_t i = 0; i &lt; MEAS_UNIT_COUNT; ++i) {
 176         for (int32_t j = 0; j &lt; WIDTH_INDEX_COUNT; ++j) {
 177             for (int32_t k = 0; k &lt; PATTERN_COUNT; ++k) {
 178                 delete patterns[i][j][k];
 179             }
 180         }
 181     }
 182     // Note: the contents of &#39;dnams&#39; are pointers into the resource bundle
 183     delete integerFormat;
 184     delete numericDateFormatters;
 185 }
 186 
 187 static UBool isCurrency(const MeasureUnit &amp;unit) {
 188     return (uprv_strcmp(unit.getType(), &quot;currency&quot;) == 0);
 189 }
 190 
 191 static UBool getString(
 192         const UResourceBundle *resource,
 193         UnicodeString &amp;result,
 194         UErrorCode &amp;status) {
 195     int32_t len = 0;
 196     const UChar *resStr = ures_getString(resource, &amp;len, &amp;status);
 197     if (U_FAILURE(status)) {
 198         return FALSE;
 199     }
 200     result.setTo(TRUE, resStr, len);
 201     return TRUE;
 202 }
 203 
 204 namespace {
 205 
 206 static const UChar g_LOCALE_units[] = {
 207     0x2F, 0x4C, 0x4F, 0x43, 0x41, 0x4C, 0x45, 0x2F,
 208     0x75, 0x6E, 0x69, 0x74, 0x73
 209 };
 210 static const UChar gShort[] = { 0x53, 0x68, 0x6F, 0x72, 0x74 };
 211 static const UChar gNarrow[] = { 0x4E, 0x61, 0x72, 0x72, 0x6F, 0x77 };
 212 
 213 /**
 214  * Sink for enumerating all of the measurement unit display names.
 215  * Contains inner sink classes, each one corresponding to a type of resource table.
 216  * The outer sink handles the top-level units, unitsNarrow, and unitsShort tables.
 217  *
 218  * More specific bundles (en_GB) are enumerated before their parents (en_001, en, root):
 219  * Only store a value if it is still missing, that is, it has not been overridden.
 220  *
 221  * C++: Each inner sink class has a reference to the main outer sink.
 222  * Java: Use non-static inner classes instead.
 223  */
 224 struct UnitDataSink : public ResourceSink {
 225 
 226     // Output data.
 227     MeasureFormatCacheData &amp;cacheData;
 228 
 229     // Path to current data.
 230     UMeasureFormatWidth width;
 231     const char *type;
 232     int32_t unitIndex;
 233 
 234     UnitDataSink(MeasureFormatCacheData &amp;outputData)
 235             : cacheData(outputData),
 236               width(UMEASFMT_WIDTH_COUNT), type(NULL), unitIndex(0) {}
 237     ~UnitDataSink();
 238 
 239     void setFormatterIfAbsent(int32_t index, const ResourceValue &amp;value,
 240                                 int32_t minPlaceholders, UErrorCode &amp;errorCode) {
 241         U_ASSERT(unitIndex &lt; MEAS_UNIT_COUNT);
 242         U_ASSERT(width &lt; WIDTH_INDEX_COUNT);
 243         U_ASSERT(index &lt; PATTERN_COUNT);
 244         SimpleFormatter **patterns = &amp;cacheData.patterns[unitIndex][width][0];
 245         if (U_SUCCESS(errorCode) &amp;&amp; patterns[index] == NULL) {
 246             if (minPlaceholders &gt;= 0) {
 247                 patterns[index] = new SimpleFormatter(
 248                         value.getUnicodeString(errorCode), minPlaceholders, 1, errorCode);
 249             }
 250             if (U_SUCCESS(errorCode) &amp;&amp; patterns[index] == NULL) {
 251                 errorCode = U_MEMORY_ALLOCATION_ERROR;
 252             }
 253         }
 254     }
 255 
 256     void setDnamIfAbsent(const ResourceValue &amp;value, UErrorCode&amp; errorCode) {
 257         U_ASSERT(unitIndex &lt; MEAS_UNIT_COUNT);
 258         U_ASSERT(width &lt; WIDTH_INDEX_COUNT);
 259         if (cacheData.dnams[unitIndex][width] == NULL) {
 260             int32_t length;
 261             cacheData.dnams[unitIndex][width] = value.getString(length, errorCode);
 262         }
 263     }
 264 
 265     /**
 266      * Consume a display pattern. For example,
 267      * unitsShort/duration/hour contains other{&quot;{0} hrs&quot;}.
 268      */
 269     void consumePattern(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 270         if (U_FAILURE(errorCode)) { return; }
 271         if (uprv_strcmp(key, &quot;dnam&quot;) == 0) {
 272             // The display name for the unit in the current width.
 273             setDnamIfAbsent(value, errorCode);
 274         } else if (uprv_strcmp(key, &quot;per&quot;) == 0) {
 275             // For example, &quot;{0}/h&quot;.
 276             setFormatterIfAbsent(PER_UNIT_INDEX, value, 1, errorCode);
 277         } else {
 278             // The key must be one of the plural form strings. For example:
 279             // one{&quot;{0} hr&quot;}
 280             // other{&quot;{0} hrs&quot;}
 281             setFormatterIfAbsent(StandardPlural::indexFromString(key, errorCode), value, 0,
 282                                     errorCode);
 283         }
 284     }
 285 
 286     /**
 287      * Consume a table of per-unit tables. For example,
 288      * unitsShort/duration contains tables for duration-unit subtypes day &amp; hour.
 289      */
 290     void consumeSubtypeTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 291         if (U_FAILURE(errorCode)) { return; }
 292         unitIndex = MeasureUnit::internalGetIndexForTypeAndSubtype(type, key);
 293         if (unitIndex &lt; 0) {
 294             // TODO: How to handle unexpected data?
 295             // See http://bugs.icu-project.org/trac/ticket/12597
 296             return;
 297         }
 298 
 299         // We no longer handle units like &quot;coordinate&quot; here (which do not have plural variants)
 300         if (value.getType() == URES_TABLE) {
 301             // Units that have plural variants
 302             ResourceTable patternTableTable = value.getTable(errorCode);
 303             if (U_FAILURE(errorCode)) { return; }
 304             for (int i = 0; patternTableTable.getKeyAndValue(i, key, value); ++i) {
 305                 consumePattern(key, value, errorCode);
 306             }
 307         } else {
 308             // TODO: How to handle unexpected data?
 309             // See http://bugs.icu-project.org/trac/ticket/12597
 310             return;
 311         }
 312     }
 313 
 314     /**
 315      * Consume compound x-per-y display pattern. For example,
 316      * unitsShort/compound/per may be &quot;{0}/{1}&quot;.
 317      */
 318     void consumeCompoundPattern(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 319         if (U_SUCCESS(errorCode) &amp;&amp; uprv_strcmp(key, &quot;per&quot;) == 0) {
 320             cacheData.perFormatters[width].
 321                     applyPatternMinMaxArguments(value.getUnicodeString(errorCode), 2, 2, errorCode);
 322         }
 323     }
 324 
 325     /**
 326      * Consume a table of unit type tables. For example,
 327      * unitsShort contains tables for area &amp; duration.
 328      * It also contains a table for the compound/per pattern.
 329      */
 330     void consumeUnitTypesTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 331         if (U_FAILURE(errorCode)) { return; }
 332         if (uprv_strcmp(key, &quot;currency&quot;) == 0) {
 333             // Skip.
 334         } else if (uprv_strcmp(key, &quot;compound&quot;) == 0) {
 335             if (!cacheData.hasPerFormatter(width)) {
 336                 ResourceTable compoundTable = value.getTable(errorCode);
 337                 if (U_FAILURE(errorCode)) { return; }
 338                 for (int i = 0; compoundTable.getKeyAndValue(i, key, value); ++i) {
 339                     consumeCompoundPattern(key, value, errorCode);
 340                 }
 341             }
 342         } else if (uprv_strcmp(key, &quot;coordinate&quot;) == 0) {
 343             // special handling but we need to determine what that is
 344         } else {
 345             type = key;
 346             ResourceTable subtypeTable = value.getTable(errorCode);
 347             if (U_FAILURE(errorCode)) { return; }
 348             for (int i = 0; subtypeTable.getKeyAndValue(i, key, value); ++i) {
 349                 consumeSubtypeTable(key, value, errorCode);
 350             }
 351         }
 352     }
 353 
 354     void consumeAlias(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 355         // Handle aliases like
 356         // units:alias{&quot;/LOCALE/unitsShort&quot;}
 357         // which should only occur in the root bundle.
 358         UMeasureFormatWidth sourceWidth = widthFromKey(key);
 359         if (sourceWidth == UMEASFMT_WIDTH_COUNT) {
 360             // Alias from something we don&#39;t care about.
 361             return;
 362         }
 363         UMeasureFormatWidth targetWidth = widthFromAlias(value, errorCode);
 364         if (targetWidth == UMEASFMT_WIDTH_COUNT) {
 365             // We do not recognize what to fall back to.
 366             errorCode = U_INVALID_FORMAT_ERROR;
 367             return;
 368         }
 369         // Check that we do not fall back to another fallback.
 370         if (cacheData.widthFallback[targetWidth] != UMEASFMT_WIDTH_COUNT) {
 371             errorCode = U_INVALID_FORMAT_ERROR;
 372             return;
 373         }
 374         cacheData.widthFallback[sourceWidth] = targetWidth;
 375     }
 376 
 377     void consumeTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 378         if (U_SUCCESS(errorCode) &amp;&amp; (width = widthFromKey(key)) != UMEASFMT_WIDTH_COUNT) {
 379             ResourceTable unitTypesTable = value.getTable(errorCode);
 380             if (U_FAILURE(errorCode)) { return; }
 381             for (int i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 382                 consumeUnitTypesTable(key, value, errorCode);
 383             }
 384         }
 385     }
 386 
 387     static UMeasureFormatWidth widthFromKey(const char *key) {
 388         if (uprv_strncmp(key, &quot;units&quot;, 5) == 0) {
 389             key += 5;
 390             if (*key == 0) {
 391                 return UMEASFMT_WIDTH_WIDE;
 392             } else if (uprv_strcmp(key, &quot;Short&quot;) == 0) {
 393                 return UMEASFMT_WIDTH_SHORT;
 394             } else if (uprv_strcmp(key, &quot;Narrow&quot;) == 0) {
 395                 return UMEASFMT_WIDTH_NARROW;
 396             }
 397         }
 398         return UMEASFMT_WIDTH_COUNT;
 399     }
 400 
 401     static UMeasureFormatWidth widthFromAlias(const ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 402         int32_t length;
 403         const UChar *s = value.getAliasString(length, errorCode);
 404         // For example: &quot;/LOCALE/unitsShort&quot;
 405         if (U_SUCCESS(errorCode) &amp;&amp; length &gt;= 13 &amp;&amp; u_memcmp(s, g_LOCALE_units, 13) == 0) {
 406             s += 13;
 407             length -= 13;
 408             if (*s == 0) {
 409                 return UMEASFMT_WIDTH_WIDE;
 410             } else if (u_strCompare(s, length, gShort, 5, FALSE) == 0) {
 411                 return UMEASFMT_WIDTH_SHORT;
 412             } else if (u_strCompare(s, length, gNarrow, 6, FALSE) == 0) {
 413                 return UMEASFMT_WIDTH_NARROW;
 414             }
 415         }
 416         return UMEASFMT_WIDTH_COUNT;
 417     }
 418 
 419     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,
 420             UErrorCode &amp;errorCode) {
 421         // Main entry point to sink
 422         ResourceTable widthsTable = value.getTable(errorCode);
 423         if (U_FAILURE(errorCode)) { return; }
 424         for (int i = 0; widthsTable.getKeyAndValue(i, key, value); ++i) {
 425             if (value.getType() == URES_ALIAS) {
 426                 consumeAlias(key, value, errorCode);
 427             } else {
 428                 consumeTable(key, value, errorCode);
 429             }
 430         }
 431     }
 432 };
 433 
 434 // Virtual destructors must be defined out of line.
 435 UnitDataSink::~UnitDataSink() {}
 436 
 437 }  // namespace
 438 
 439 static UBool loadMeasureUnitData(
 440         const UResourceBundle *resource,
 441         MeasureFormatCacheData &amp;cacheData,
 442         UErrorCode &amp;status) {
 443     UnitDataSink sink(cacheData);
 444     ures_getAllItemsWithFallback(resource, &quot;&quot;, sink, status);
 445     return U_SUCCESS(status);
 446 }
 447 
 448 static UnicodeString loadNumericDateFormatterPattern(
 449         const UResourceBundle *resource,
 450         const char *pattern,
 451         UErrorCode &amp;status) {
 452     UnicodeString result;
 453     if (U_FAILURE(status)) {
 454         return result;
 455     }
 456     CharString chs;
 457     chs.append(&quot;durationUnits&quot;, status)
 458             .append(&quot;/&quot;, status).append(pattern, status);
 459     LocalUResourceBundlePointer patternBundle(
 460             ures_getByKeyWithFallback(
 461                 resource,
 462                 chs.data(),
 463                 NULL,
 464                 &amp;status));
 465     if (U_FAILURE(status)) {
 466         return result;
 467     }
 468     getString(patternBundle.getAlias(), result, status);
 469     // Replace &#39;h&#39; with &#39;H&#39;
 470     int32_t len = result.length();
 471     UChar *buffer = result.getBuffer(len);
 472     for (int32_t i = 0; i &lt; len; ++i) {
 473         if (buffer[i] == 0x68) { // &#39;h&#39;
 474             buffer[i] = 0x48; // &#39;H&#39;
 475         }
 476     }
 477     result.releaseBuffer(len);
 478     return result;
 479 }
 480 
 481 static NumericDateFormatters *loadNumericDateFormatters(
 482         const UResourceBundle *resource,
 483         UErrorCode &amp;status) {
 484     if (U_FAILURE(status)) {
 485         return NULL;
 486     }
 487     NumericDateFormatters *result = new NumericDateFormatters(
 488         loadNumericDateFormatterPattern(resource, &quot;hm&quot;, status),
 489         loadNumericDateFormatterPattern(resource, &quot;ms&quot;, status),
 490         loadNumericDateFormatterPattern(resource, &quot;hms&quot;, status),
 491         status);
 492     if (U_FAILURE(status)) {
 493         delete result;
 494         return NULL;
 495     }
 496     return result;
 497 }
 498 
 499 template&lt;&gt; U_I18N_API
 500 const MeasureFormatCacheData *LocaleCacheKey&lt;MeasureFormatCacheData&gt;::createObject(
 501         const void * /*unused*/, UErrorCode &amp;status) const {
 502     const char *localeId = fLoc.getName();
 503     LocalUResourceBundlePointer unitsBundle(ures_open(U_ICUDATA_UNIT, localeId, &amp;status));
 504     static UNumberFormatStyle currencyStyles[] = {
 505             UNUM_CURRENCY_PLURAL, UNUM_CURRENCY_ISO, UNUM_CURRENCY};
 506     LocalPointer&lt;MeasureFormatCacheData&gt; result(new MeasureFormatCacheData(), status);
 507     if (U_FAILURE(status)) {
 508         return NULL;
 509     }
 510     if (!loadMeasureUnitData(
 511             unitsBundle.getAlias(),
 512             *result,
 513             status)) {
 514         return NULL;
 515     }
 516     result-&gt;adoptNumericDateFormatters(loadNumericDateFormatters(
 517             unitsBundle.getAlias(), status));
 518     if (U_FAILURE(status)) {
 519         return NULL;
 520     }
 521 
 522     for (int32_t i = 0; i &lt; WIDTH_INDEX_COUNT; ++i) {
 523         // NumberFormat::createInstance can erase warning codes from status, so pass it
 524         // a separate status instance
 525         UErrorCode localStatus = U_ZERO_ERROR;
 526         result-&gt;adoptCurrencyFormat(i, NumberFormat::createInstance(
 527                 localeId, currencyStyles[i], localStatus));
 528         if (localStatus != U_ZERO_ERROR) {
 529             status = localStatus;
 530         }
 531         if (U_FAILURE(status)) {
 532             return NULL;
 533         }
 534     }
 535     NumberFormat *inf = NumberFormat::createInstance(
 536             localeId, UNUM_DECIMAL, status);
 537     if (U_FAILURE(status)) {
 538         return NULL;
 539     }
 540     inf-&gt;setMaximumFractionDigits(0);
 541     DecimalFormat *decfmt = dynamic_cast&lt;DecimalFormat *&gt;(inf);
 542     if (decfmt != NULL) {
 543         decfmt-&gt;setRoundingMode(DecimalFormat::kRoundDown);
 544     }
 545     result-&gt;adoptIntegerFormat(inf);
 546     result-&gt;addRef();
 547     return result.orphan();
 548 }
 549 
 550 static UBool isTimeUnit(const MeasureUnit &amp;mu, const char *tu) {
 551     return uprv_strcmp(mu.getType(), &quot;duration&quot;) == 0 &amp;&amp;
 552             uprv_strcmp(mu.getSubtype(), tu) == 0;
 553 }
 554 
 555 // Converts a composite measure into hours-minutes-seconds and stores at hms
 556 // array. [0] is hours; [1] is minutes; [2] is seconds. Returns a bit map of
 557 // units found: 1=hours, 2=minutes, 4=seconds. For example, if measures
 558 // contains hours-minutes, this function would return 3.
 559 //
 560 // If measures cannot be converted into hours, minutes, seconds or if amounts
 561 // are negative, or if hours, minutes, seconds are out of order, returns 0.
 562 static int32_t toHMS(
 563         const Measure *measures,
 564         int32_t measureCount,
 565         Formattable *hms,
 566         UErrorCode &amp;status) {
 567     if (U_FAILURE(status)) {
 568         return 0;
 569     }
 570     int32_t result = 0;
 571     if (U_FAILURE(status)) {
 572         return 0;
 573     }
 574     // We use copy constructor to ensure that both sides of equality operator
 575     // are instances of MeasureUnit base class and not a subclass. Otherwise,
 576     // operator== will immediately return false.
 577     for (int32_t i = 0; i &lt; measureCount; ++i) {
 578         if (isTimeUnit(measures[i].getUnit(), &quot;hour&quot;)) {
 579             // hour must come first
 580             if (result &gt;= 1) {
 581                 return 0;
 582             }
 583             hms[0] = measures[i].getNumber();
 584             if (hms[0].getDouble() &lt; 0.0) {
 585                 return 0;
 586             }
 587             result |= 1;
 588         } else if (isTimeUnit(measures[i].getUnit(), &quot;minute&quot;)) {
 589             // minute must come after hour
 590             if (result &gt;= 2) {
 591                 return 0;
 592             }
 593             hms[1] = measures[i].getNumber();
 594             if (hms[1].getDouble() &lt; 0.0) {
 595                 return 0;
 596             }
 597             result |= 2;
 598         } else if (isTimeUnit(measures[i].getUnit(), &quot;second&quot;)) {
 599             // second must come after hour and minute
 600             if (result &gt;= 4) {
 601                 return 0;
 602             }
 603             hms[2] = measures[i].getNumber();
 604             if (hms[2].getDouble() &lt; 0.0) {
 605                 return 0;
 606             }
 607             result |= 4;
 608         } else {
 609             return 0;
 610         }
 611     }
 612     return result;
 613 }
 614 
 615 
 616 MeasureFormat::MeasureFormat(
 617         const Locale &amp;locale, UMeasureFormatWidth w, UErrorCode &amp;status)
 618         : cache(NULL),
 619           numberFormat(NULL),
 620           pluralRules(NULL),
 621           width(w),
 622           listFormatter(NULL) {
 623     initMeasureFormat(locale, w, NULL, status);
 624 }
 625 
 626 MeasureFormat::MeasureFormat(
 627         const Locale &amp;locale,
 628         UMeasureFormatWidth w,
 629         NumberFormat *nfToAdopt,
 630         UErrorCode &amp;status)
 631         : cache(NULL),
 632           numberFormat(NULL),
 633           pluralRules(NULL),
 634           width(w),
 635           listFormatter(NULL) {
 636     initMeasureFormat(locale, w, nfToAdopt, status);
 637 }
 638 
 639 MeasureFormat::MeasureFormat(const MeasureFormat &amp;other) :
 640         Format(other),
 641         cache(other.cache),
 642         numberFormat(other.numberFormat),
 643         pluralRules(other.pluralRules),
 644         width(other.width),
 645         listFormatter(NULL) {
 646     cache-&gt;addRef();
 647     numberFormat-&gt;addRef();
 648     pluralRules-&gt;addRef();
 649     if (other.listFormatter != NULL) {
 650         listFormatter = new ListFormatter(*other.listFormatter);
 651     }
 652 }
 653 
 654 MeasureFormat &amp;MeasureFormat::operator=(const MeasureFormat &amp;other) {
 655     if (this == &amp;other) {
 656         return *this;
 657     }
 658     Format::operator=(other);
 659     SharedObject::copyPtr(other.cache, cache);
 660     SharedObject::copyPtr(other.numberFormat, numberFormat);
 661     SharedObject::copyPtr(other.pluralRules, pluralRules);
 662     width = other.width;
 663     delete listFormatter;
 664     if (other.listFormatter != NULL) {
 665         listFormatter = new ListFormatter(*other.listFormatter);
 666     } else {
 667         listFormatter = NULL;
 668     }
 669     return *this;
 670 }
 671 
 672 MeasureFormat::MeasureFormat() :
 673         cache(NULL),
 674         numberFormat(NULL),
 675         pluralRules(NULL),
 676         width(UMEASFMT_WIDTH_SHORT),
 677         listFormatter(NULL) {
 678 }
 679 
 680 MeasureFormat::~MeasureFormat() {
 681     if (cache != NULL) {
 682         cache-&gt;removeRef();
 683     }
 684     if (numberFormat != NULL) {
 685         numberFormat-&gt;removeRef();
 686     }
 687     if (pluralRules != NULL) {
 688         pluralRules-&gt;removeRef();
 689     }
 690     delete listFormatter;
 691 }
 692 
 693 UBool MeasureFormat::operator==(const Format &amp;other) const {
 694     if (this == &amp;other) { // Same object, equal
 695         return TRUE;
 696     }
 697     if (!Format::operator==(other)) {
 698         return FALSE;
 699     }
 700     const MeasureFormat &amp;rhs = static_cast&lt;const MeasureFormat &amp;&gt;(other);
 701 
 702     // Note: Since the ListFormatter depends only on Locale and width, we
 703     // don&#39;t have to check it here.
 704 
 705     // differing widths aren&#39;t equivalent
 706     if (width != rhs.width) {
 707         return FALSE;
 708     }
 709     // Width the same check locales.
 710     // We don&#39;t need to check locales if both objects have same cache.
 711     if (cache != rhs.cache) {
 712         UErrorCode status = U_ZERO_ERROR;
 713         const char *localeId = getLocaleID(status);
 714         const char *rhsLocaleId = rhs.getLocaleID(status);
 715         if (U_FAILURE(status)) {
 716             // On failure, assume not equal
 717             return FALSE;
 718         }
 719         if (uprv_strcmp(localeId, rhsLocaleId) != 0) {
 720             return FALSE;
 721         }
 722     }
 723     // Locales same, check NumberFormat if shared data differs.
 724     return (
 725             numberFormat == rhs.numberFormat ||
 726             **numberFormat == **rhs.numberFormat);
 727 }
 728 
 729 Format *MeasureFormat::clone() const {
 730     return new MeasureFormat(*this);
 731 }
 732 
 733 UnicodeString &amp;MeasureFormat::format(
 734         const Formattable &amp;obj,
 735         UnicodeString &amp;appendTo,
 736         FieldPosition &amp;pos,
 737         UErrorCode &amp;status) const {
 738     if (U_FAILURE(status)) return appendTo;
 739     if (obj.getType() == Formattable::kObject) {
 740         const UObject* formatObj = obj.getObject();
 741         const Measure* amount = dynamic_cast&lt;const Measure*&gt;(formatObj);
 742         if (amount != NULL) {
 743             return formatMeasure(
 744                     *amount, **numberFormat, appendTo, pos, status);
 745         }
 746     }
 747     status = U_ILLEGAL_ARGUMENT_ERROR;
 748     return appendTo;
 749 }
 750 
 751 void MeasureFormat::parseObject(
 752         const UnicodeString &amp; /*source*/,
 753         Formattable &amp; /*result*/,
 754         ParsePosition&amp; /*pos*/) const {
 755     return;
 756 }
 757 
 758 UnicodeString &amp;MeasureFormat::formatMeasurePerUnit(
 759         const Measure &amp;measure,
 760         const MeasureUnit &amp;perUnit,
 761         UnicodeString &amp;appendTo,
 762         FieldPosition &amp;pos,
 763         UErrorCode &amp;status) const {
 764     if (U_FAILURE(status)) {
 765         return appendTo;
 766     }
 767     bool isResolved = false;
 768     MeasureUnit resolvedUnit =
 769         MeasureUnit::resolveUnitPerUnit(measure.getUnit(), perUnit, &amp;isResolved);
 770     if (isResolved) {
 771         Measure newMeasure(measure.getNumber(), new MeasureUnit(resolvedUnit), status);
 772         return formatMeasure(
 773                 newMeasure, **numberFormat, appendTo, pos, status);
 774     }
 775     FieldPosition fpos(pos.getField());
 776     UnicodeString result;
 777     int32_t offset = withPerUnitAndAppend(
 778             formatMeasure(
 779                     measure, **numberFormat, result, fpos, status),
 780             perUnit,
 781             appendTo,
 782             status);
 783     if (U_FAILURE(status)) {
 784         return appendTo;
 785     }
 786     if (fpos.getBeginIndex() != 0 || fpos.getEndIndex() != 0) {
 787         pos.setBeginIndex(fpos.getBeginIndex() + offset);
 788         pos.setEndIndex(fpos.getEndIndex() + offset);
 789     }
 790     return appendTo;
 791 }
 792 
 793 UnicodeString &amp;MeasureFormat::formatMeasures(
 794         const Measure *measures,
 795         int32_t measureCount,
 796         UnicodeString &amp;appendTo,
 797         FieldPosition &amp;pos,
 798         UErrorCode &amp;status) const {
 799     if (U_FAILURE(status)) {
 800         return appendTo;
 801     }
 802     if (measureCount == 0) {
 803         return appendTo;
 804     }
 805     if (measureCount == 1) {
 806         return formatMeasure(measures[0], **numberFormat, appendTo, pos, status);
 807     }
 808     if (width == UMEASFMT_WIDTH_NUMERIC) {
 809         Formattable hms[3];
 810         int32_t bitMap = toHMS(measures, measureCount, hms, status);
 811         if (bitMap &gt; 0) {
 812             return formatNumeric(hms, bitMap, appendTo, status);
 813         }
 814     }
 815     if (pos.getField() != FieldPosition::DONT_CARE) {
 816         return formatMeasuresSlowTrack(
 817                 measures, measureCount, appendTo, pos, status);
 818     }
 819     UnicodeString *results = new UnicodeString[measureCount];
 820     if (results == NULL) {
 821         status = U_MEMORY_ALLOCATION_ERROR;
 822         return appendTo;
 823     }
 824     for (int32_t i = 0; i &lt; measureCount; ++i) {
 825         const NumberFormat *nf = cache-&gt;getIntegerFormat();
 826         if (i == measureCount - 1) {
 827             nf = numberFormat-&gt;get();
 828         }
 829         formatMeasure(
 830                 measures[i],
 831                 *nf,
 832                 results[i],
 833                 pos,
 834                 status);
 835     }
 836     listFormatter-&gt;format(results, measureCount, appendTo, status);
 837     delete [] results;
 838     return appendTo;
 839 }
 840 
 841 UnicodeString MeasureFormat::getUnitDisplayName(const MeasureUnit&amp; unit, UErrorCode&amp; /*status*/) const {
 842     UMeasureFormatWidth width = getRegularWidth(this-&gt;width);
 843     const UChar* const* styleToDnam = cache-&gt;dnams[unit.getIndex()];
 844     const UChar* dnam = styleToDnam[width];
 845     if (dnam == NULL) {
 846         int32_t fallbackWidth = cache-&gt;widthFallback[width];
 847         dnam = styleToDnam[fallbackWidth];
 848     }
 849 
 850     UnicodeString result;
 851     if (dnam == NULL) {
 852         result.setToBogus();
 853     } else {
 854         result.setTo(dnam, -1);
 855     }
 856     return result;
 857 }
 858 
 859 void MeasureFormat::initMeasureFormat(
 860         const Locale &amp;locale,
 861         UMeasureFormatWidth w,
 862         NumberFormat *nfToAdopt,
 863         UErrorCode &amp;status) {
 864     static const char *listStyles[] = {&quot;unit&quot;, &quot;unit-short&quot;, &quot;unit-narrow&quot;};
 865     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
 866     if (U_FAILURE(status)) {
 867         return;
 868     }
 869     const char *name = locale.getName();
 870     setLocaleIDs(name, name);
 871 
 872     UnifiedCache::getByLocale(locale, cache, status);
 873     if (U_FAILURE(status)) {
 874         return;
 875     }
 876 
 877     const SharedPluralRules *pr = PluralRules::createSharedInstance(
 878             locale, UPLURAL_TYPE_CARDINAL, status);
 879     if (U_FAILURE(status)) {
 880         return;
 881     }
 882     SharedObject::copyPtr(pr, pluralRules);
 883     pr-&gt;removeRef();
 884     if (nf.isNull()) {
 885         const SharedNumberFormat *shared = NumberFormat::createSharedInstance(
 886                 locale, UNUM_DECIMAL, status);
 887         if (U_FAILURE(status)) {
 888             return;
 889         }
 890         SharedObject::copyPtr(shared, numberFormat);
 891         shared-&gt;removeRef();
 892     } else {
 893         adoptNumberFormat(nf.orphan(), status);
 894         if (U_FAILURE(status)) {
 895             return;
 896         }
 897     }
 898     width = w;
 899     delete listFormatter;
 900     listFormatter = ListFormatter::createInstance(
 901             locale,
 902             listStyles[getRegularWidth(width)],
 903             status);
 904 }
 905 
 906 void MeasureFormat::adoptNumberFormat(
 907         NumberFormat *nfToAdopt, UErrorCode &amp;status) {
 908     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
 909     if (U_FAILURE(status)) {
 910         return;
 911     }
 912     SharedNumberFormat *shared = new SharedNumberFormat(nf.getAlias());
 913     if (shared == NULL) {
 914         status = U_MEMORY_ALLOCATION_ERROR;
 915         return;
 916     }
 917     nf.orphan();
 918     SharedObject::copyPtr(shared, numberFormat);
 919 }
 920 
 921 UBool MeasureFormat::setMeasureFormatLocale(const Locale &amp;locale, UErrorCode &amp;status) {
 922     if (U_FAILURE(status) || locale == getLocale(status)) {
 923         return FALSE;
 924     }
 925     initMeasureFormat(locale, width, NULL, status);
 926     return U_SUCCESS(status);
 927 }
 928 
 929 const NumberFormat &amp;MeasureFormat::getNumberFormat() const {
 930     return **numberFormat;
 931 }
 932 
 933 const PluralRules &amp;MeasureFormat::getPluralRules() const {
 934     return **pluralRules;
 935 }
 936 
 937 Locale MeasureFormat::getLocale(UErrorCode &amp;status) const {
 938     return Format::getLocale(ULOC_VALID_LOCALE, status);
 939 }
 940 
 941 const char *MeasureFormat::getLocaleID(UErrorCode &amp;status) const {
 942     return Format::getLocaleID(ULOC_VALID_LOCALE, status);
 943 }
 944 
 945 UnicodeString &amp;MeasureFormat::formatMeasure(
 946         const Measure &amp;measure,
 947         const NumberFormat &amp;nf,
 948         UnicodeString &amp;appendTo,
 949         FieldPosition &amp;pos,
 950         UErrorCode &amp;status) const {
 951     if (U_FAILURE(status)) {
 952         return appendTo;
 953     }
 954     const Formattable&amp; amtNumber = measure.getNumber();
 955     const MeasureUnit&amp; amtUnit = measure.getUnit();
 956     if (isCurrency(amtUnit)) {
 957         UChar isoCode[4];
 958         u_charsToUChars(amtUnit.getSubtype(), isoCode, 4);
 959         return cache-&gt;getCurrencyFormat(width)-&gt;format(
 960                 new CurrencyAmount(amtNumber, isoCode, status),
 961                 appendTo,
 962                 pos,
 963                 status);
 964     }
 965     UnicodeString formattedNumber;
 966     StandardPlural::Form pluralForm = QuantityFormatter::selectPlural(
 967             amtNumber, nf, **pluralRules, formattedNumber, pos, status);
 968     const SimpleFormatter *formatter = getPluralFormatter(amtUnit, width, pluralForm, status);
 969     return QuantityFormatter::format(*formatter, formattedNumber, appendTo, pos, status);
 970 }
 971 
 972 // Formats hours-minutes-seconds as 5:37:23 or similar.
 973 UnicodeString &amp;MeasureFormat::formatNumeric(
 974         const Formattable *hms,  // always length 3
 975         int32_t bitMap,   // 1=hourset, 2=minuteset, 4=secondset
 976         UnicodeString &amp;appendTo,
 977         UErrorCode &amp;status) const {
 978     if (U_FAILURE(status)) {
 979         return appendTo;
 980     }
 981     UDate millis =
 982         (UDate) (((uprv_trunc(hms[0].getDouble(status)) * 60.0
 983              + uprv_trunc(hms[1].getDouble(status))) * 60.0
 984                   + uprv_trunc(hms[2].getDouble(status))) * 1000.0);
 985     switch (bitMap) {
 986     case 5: // hs
 987     case 7: // hms
 988         return formatNumeric(
 989                 millis,
 990                 cache-&gt;getNumericDateFormatters()-&gt;hourMinuteSecond,
 991                 UDAT_SECOND_FIELD,
 992                 hms[2],
 993                 appendTo,
 994                 status);
 995         break;
 996     case 6: // ms
 997         return formatNumeric(
 998                 millis,
 999                 cache-&gt;getNumericDateFormatters()-&gt;minuteSecond,
1000                 UDAT_SECOND_FIELD,
1001                 hms[2],
1002                 appendTo,
1003                 status);
1004         break;
1005     case 3: // hm
1006         return formatNumeric(
1007                 millis,
1008                 cache-&gt;getNumericDateFormatters()-&gt;hourMinute,
1009                 UDAT_MINUTE_FIELD,
1010                 hms[1],
1011                 appendTo,
1012                 status);
1013         break;
1014     default:
1015         status = U_INTERNAL_PROGRAM_ERROR;
1016         return appendTo;
1017         break;
1018     }
1019     return appendTo;
1020 }
1021 
1022 static void appendRange(
1023         const UnicodeString &amp;src,
1024         int32_t start,
1025         int32_t end,
1026         UnicodeString &amp;dest) {
1027     dest.append(src, start, end - start);
1028 }
1029 
1030 static void appendRange(
1031         const UnicodeString &amp;src,
1032         int32_t end,
1033         UnicodeString &amp;dest) {
1034     dest.append(src, end, src.length() - end);
1035 }
1036 
1037 // Formats time like 5:37:23
1038 UnicodeString &amp;MeasureFormat::formatNumeric(
1039         UDate date, // Time since epoch 1:30:00 would be 5400000
1040         const DateFormat &amp;dateFmt, // h:mm, m:ss, or h:mm:ss
1041         UDateFormatField smallestField, // seconds in 5:37:23.5
1042         const Formattable &amp;smallestAmount, // 23.5 for 5:37:23.5
1043         UnicodeString &amp;appendTo,
1044         UErrorCode &amp;status) const {
1045     if (U_FAILURE(status)) {
1046         return appendTo;
1047     }
1048     // Format the smallest amount with this object&#39;s NumberFormat
1049     UnicodeString smallestAmountFormatted;
1050 
1051     // We keep track of the integer part of smallest amount so that
1052     // we can replace it later so that we get &#39;0:00:09.3&#39; instead of
1053     // &#39;0:00:9.3&#39;
1054     FieldPosition intFieldPosition(UNUM_INTEGER_FIELD);
1055     (*numberFormat)-&gt;format(
1056             smallestAmount, smallestAmountFormatted, intFieldPosition, status);
1057     if (
1058             intFieldPosition.getBeginIndex() == 0 &amp;&amp;
1059             intFieldPosition.getEndIndex() == 0) {
1060         status = U_INTERNAL_PROGRAM_ERROR;
1061         return appendTo;
1062     }
1063 
1064     // Format time. draft becomes something like &#39;5:30:45&#39;
1065     // #13606: DateFormat is not thread-safe, but MeasureFormat advertises itself as thread-safe.
1066     FieldPosition smallestFieldPosition(smallestField);
1067     UnicodeString draft;
1068     static UMutex dateFmtMutex = U_MUTEX_INITIALIZER;
1069     umtx_lock(&amp;dateFmtMutex);
1070     dateFmt.format(date, draft, smallestFieldPosition, status);
1071     umtx_unlock(&amp;dateFmtMutex);
1072 
1073     // If we find field for smallest amount replace it with the formatted
1074     // smallest amount from above taking care to replace the integer part
1075     // with what is in original time. For example, If smallest amount
1076     // is 9.35s and the formatted time is 0:00:09 then 9.35 becomes 09.35
1077     // and replacing yields 0:00:09.35
1078     if (smallestFieldPosition.getBeginIndex() != 0 ||
1079             smallestFieldPosition.getEndIndex() != 0) {
1080         appendRange(draft, 0, smallestFieldPosition.getBeginIndex(), appendTo);
1081         appendRange(
1082                 smallestAmountFormatted,
1083                 0,
1084                 intFieldPosition.getBeginIndex(),
1085                 appendTo);
1086         appendRange(
1087                 draft,
1088                 smallestFieldPosition.getBeginIndex(),
1089                 smallestFieldPosition.getEndIndex(),
1090                 appendTo);
1091         appendRange(
1092                 smallestAmountFormatted,
1093                 intFieldPosition.getEndIndex(),
1094                 appendTo);
1095         appendRange(
1096                 draft,
1097                 smallestFieldPosition.getEndIndex(),
1098                 appendTo);
1099     } else {
1100         appendTo.append(draft);
1101     }
1102     return appendTo;
1103 }
1104 
1105 const SimpleFormatter *MeasureFormat::getFormatterOrNull(
1106         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index) const {
1107     width = getRegularWidth(width);
1108     SimpleFormatter *const (*unitPatterns)[PATTERN_COUNT] = &amp;cache-&gt;patterns[unit.getIndex()][0];
1109     if (unitPatterns[width][index] != NULL) {
1110         return unitPatterns[width][index];
1111     }
1112     int32_t fallbackWidth = cache-&gt;widthFallback[width];
1113     if (fallbackWidth != UMEASFMT_WIDTH_COUNT &amp;&amp; unitPatterns[fallbackWidth][index] != NULL) {
1114         return unitPatterns[fallbackWidth][index];
1115     }
1116     return NULL;
1117 }
1118 
1119 const SimpleFormatter *MeasureFormat::getFormatter(
1120         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index,
1121         UErrorCode &amp;errorCode) const {
1122     if (U_FAILURE(errorCode)) {
1123         return NULL;
1124     }
1125     const SimpleFormatter *pattern = getFormatterOrNull(unit, width, index);
1126     if (pattern == NULL) {
1127         errorCode = U_MISSING_RESOURCE_ERROR;
1128     }
1129     return pattern;
1130 }
1131 
1132 const SimpleFormatter *MeasureFormat::getPluralFormatter(
1133         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index,
1134         UErrorCode &amp;errorCode) const {
1135     if (U_FAILURE(errorCode)) {
1136         return NULL;
1137     }
1138     if (index != StandardPlural::OTHER) {
1139         const SimpleFormatter *pattern = getFormatterOrNull(unit, width, index);
1140         if (pattern != NULL) {
1141             return pattern;
1142         }
1143     }
1144     return getFormatter(unit, width, StandardPlural::OTHER, errorCode);
1145 }
1146 
1147 const SimpleFormatter *MeasureFormat::getPerFormatter(
1148         UMeasureFormatWidth width,
1149         UErrorCode &amp;status) const {
1150     if (U_FAILURE(status)) {
1151         return NULL;
1152     }
1153     width = getRegularWidth(width);
1154     const SimpleFormatter * perFormatters = cache-&gt;perFormatters;
1155     if (perFormatters[width].getArgumentLimit() == 2) {
1156         return &amp;perFormatters[width];
1157     }
1158     int32_t fallbackWidth = cache-&gt;widthFallback[width];
1159     if (fallbackWidth != UMEASFMT_WIDTH_COUNT &amp;&amp;
1160             perFormatters[fallbackWidth].getArgumentLimit() == 2) {
1161         return &amp;perFormatters[fallbackWidth];
1162     }
1163     status = U_MISSING_RESOURCE_ERROR;
1164     return NULL;
1165 }
1166 
1167 int32_t MeasureFormat::withPerUnitAndAppend(
1168         const UnicodeString &amp;formatted,
1169         const MeasureUnit &amp;perUnit,
1170         UnicodeString &amp;appendTo,
1171         UErrorCode &amp;status) const {
1172     int32_t offset = -1;
1173     if (U_FAILURE(status)) {
1174         return offset;
1175     }
1176     const SimpleFormatter *perUnitFormatter = getFormatterOrNull(perUnit, width, PER_UNIT_INDEX);
1177     if (perUnitFormatter != NULL) {
1178         const UnicodeString *params[] = {&amp;formatted};
1179         perUnitFormatter-&gt;formatAndAppend(
1180                 params,
1181                 UPRV_LENGTHOF(params),
1182                 appendTo,
1183                 &amp;offset,
1184                 1,
1185                 status);
1186         return offset;
1187     }
1188     const SimpleFormatter *perFormatter = getPerFormatter(width, status);
1189     const SimpleFormatter *pattern =
1190             getPluralFormatter(perUnit, width, StandardPlural::ONE, status);
1191     if (U_FAILURE(status)) {
1192         return offset;
1193     }
1194     UnicodeString perUnitString = pattern-&gt;getTextWithNoArguments();
1195     perUnitString.trim();
1196     const UnicodeString *params[] = {&amp;formatted, &amp;perUnitString};
1197     perFormatter-&gt;formatAndAppend(
1198             params,
1199             UPRV_LENGTHOF(params),
1200             appendTo,
1201             &amp;offset,
1202             1,
1203             status);
1204     return offset;
1205 }
1206 
1207 UnicodeString &amp;MeasureFormat::formatMeasuresSlowTrack(
1208         const Measure *measures,
1209         int32_t measureCount,
1210         UnicodeString&amp; appendTo,
1211         FieldPosition&amp; pos,
1212         UErrorCode&amp; status) const {
1213     if (U_FAILURE(status)) {
1214         return appendTo;
1215     }
1216     FieldPosition dontCare(FieldPosition::DONT_CARE);
1217     FieldPosition fpos(pos.getField());
1218     UnicodeString *results = new UnicodeString[measureCount];
1219     int32_t fieldPositionFoundIndex = -1;
1220     for (int32_t i = 0; i &lt; measureCount; ++i) {
1221         const NumberFormat *nf = cache-&gt;getIntegerFormat();
1222         if (i == measureCount - 1) {
1223             nf = numberFormat-&gt;get();
1224         }
1225         if (fieldPositionFoundIndex == -1) {
1226             formatMeasure(measures[i], *nf, results[i], fpos, status);
1227             if (U_FAILURE(status)) {
1228                 delete [] results;
1229                 return appendTo;
1230             }
1231             if (fpos.getBeginIndex() != 0 || fpos.getEndIndex() != 0) {
1232                 fieldPositionFoundIndex = i;
1233             }
1234         } else {
1235             formatMeasure(measures[i], *nf, results[i], dontCare, status);
1236         }
1237     }
1238     int32_t offset;
1239     listFormatter-&gt;format(
1240             results,
1241             measureCount,
1242             appendTo,
1243             fieldPositionFoundIndex,
1244             offset,
1245             status);
1246     if (U_FAILURE(status)) {
1247         delete [] results;
1248         return appendTo;
1249     }
1250     if (offset != -1) {
1251         pos.setBeginIndex(fpos.getBeginIndex() + offset);
1252         pos.setEndIndex(fpos.getEndIndex() + offset);
1253     }
1254     delete [] results;
1255     return appendTo;
1256 }
1257 
1258 MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(const Locale&amp; locale,
1259                                                    UErrorCode&amp; ec) {
1260     CurrencyFormat* fmt = NULL;
1261     if (U_SUCCESS(ec)) {
1262         fmt = new CurrencyFormat(locale, ec);
1263         if (U_FAILURE(ec)) {
1264             delete fmt;
1265             fmt = NULL;
1266         }
1267     }
1268     return fmt;
1269 }
1270 
1271 MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(UErrorCode&amp; ec) {
1272     if (U_FAILURE(ec)) {
1273         return NULL;
1274     }
1275     return MeasureFormat::createCurrencyFormat(Locale::getDefault(), ec);
1276 }
1277 
1278 U_NAMESPACE_END
1279 
1280 #endif /* #if !UCONFIG_NO_FORMATTING */
    </pre>
  </body>
</html>