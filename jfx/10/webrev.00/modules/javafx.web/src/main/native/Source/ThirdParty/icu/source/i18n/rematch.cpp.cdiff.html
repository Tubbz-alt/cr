<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rematch.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="reldtfmt.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rulebasedcollator.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rematch.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 715,11 ***</span>
              //   match at the end of a string, so we must make sure that the loop
              //   runs with startPos == testStartLimit the last time through.
              if  (findProgressInterrupt(startPos, status))
                  return FALSE;
          }
<span class="line-modified">!         U_ASSERT(FALSE);</span>
  
      case START_START:
          // Matches are only possible at the start of the input string
          //   (pattern begins with ^ or \A)
          if (startPos &gt; fActiveStart) {
<span class="line-new-header">--- 715,11 ---</span>
              //   match at the end of a string, so we must make sure that the loop
              //   runs with startPos == testStartLimit the last time through.
              if  (findProgressInterrupt(startPos, status))
                  return FALSE;
          }
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
  
      case START_START:
          // Matches are only possible at the start of the input string
          //   (pattern begins with ^ or \A)
          if (startPos &gt; fActiveStart) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 763,11 ***</span>
                  }
                  if  (findProgressInterrupt(startPos, status))
                      return FALSE;
              }
          }
<span class="line-modified">!         U_ASSERT(FALSE);</span>
  
      case START_STRING:
      case START_CHAR:
          {
              // Match starts on exactly one char.
<span class="line-new-header">--- 763,11 ---</span>
                  }
                  if  (findProgressInterrupt(startPos, status))
                      return FALSE;
              }
          }
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
  
      case START_STRING:
      case START_CHAR:
          {
              // Match starts on exactly one char.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 795,35 ***</span>
                  }
                  if  (findProgressInterrupt(startPos, status))
                      return FALSE;
             }
          }
<span class="line-modified">!         U_ASSERT(FALSE);</span>
  
      case START_LINE:
          {
<span class="line-modified">!             UChar32  c;</span>
              if (startPos == fAnchorStart) {
                  MatchAt(startPos, FALSE, status);
                  if (U_FAILURE(status)) {
                      return FALSE;
                  }
                  if (fMatch) {
                      return TRUE;
                  }
                  UTEXT_SETNATIVEINDEX(fInputText, startPos);
<span class="line-modified">!                 c = UTEXT_NEXT32(fInputText);</span>
                  startPos = UTEXT_GETNATIVEINDEX(fInputText);
              } else {
                  UTEXT_SETNATIVEINDEX(fInputText, startPos);
<span class="line-modified">!                 c = UTEXT_PREVIOUS32(fInputText);</span>
                  UTEXT_SETNATIVEINDEX(fInputText, startPos);
              }
  
              if (fPattern-&gt;fFlags &amp; UREGEX_UNIX_LINES) {
                  for (;;) {
<span class="line-modified">!                     if (c == 0x0a) {</span>
                              MatchAt(startPos, FALSE, status);
                              if (U_FAILURE(status)) {
                                  return FALSE;
                              }
                              if (fMatch) {
<span class="line-new-header">--- 795,35 ---</span>
                  }
                  if  (findProgressInterrupt(startPos, status))
                      return FALSE;
             }
          }
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
  
      case START_LINE:
          {
<span class="line-modified">!             UChar32 ch;</span>
              if (startPos == fAnchorStart) {
                  MatchAt(startPos, FALSE, status);
                  if (U_FAILURE(status)) {
                      return FALSE;
                  }
                  if (fMatch) {
                      return TRUE;
                  }
                  UTEXT_SETNATIVEINDEX(fInputText, startPos);
<span class="line-modified">!                 ch = UTEXT_NEXT32(fInputText);</span>
                  startPos = UTEXT_GETNATIVEINDEX(fInputText);
              } else {
                  UTEXT_SETNATIVEINDEX(fInputText, startPos);
<span class="line-modified">!                 ch = UTEXT_PREVIOUS32(fInputText);</span>
                  UTEXT_SETNATIVEINDEX(fInputText, startPos);
              }
  
              if (fPattern-&gt;fFlags &amp; UREGEX_UNIX_LINES) {
                  for (;;) {
<span class="line-modified">!                     if (ch == 0x0a) {</span>
                              MatchAt(startPos, FALSE, status);
                              if (U_FAILURE(status)) {
                                  return FALSE;
                              }
                              if (fMatch) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 834,22 ***</span>
                      if (startPos &gt;= testStartLimit) {
                          fMatch = FALSE;
                          fHitEnd = TRUE;
                          return FALSE;
                      }
<span class="line-modified">!                     c = UTEXT_NEXT32(fInputText);</span>
                      startPos = UTEXT_GETNATIVEINDEX(fInputText);
                      // Note that it&#39;s perfectly OK for a pattern to have a zero-length
                      //   match at the end of a string, so we must make sure that the loop
                      //   runs with startPos == testStartLimit the last time through.
                      if  (findProgressInterrupt(startPos, status))
                          return FALSE;
                  }
              } else {
                  for (;;) {
<span class="line-modified">!                     if (isLineTerminator(c)) {</span>
<span class="line-modified">!                         if (c == 0x0d &amp;&amp; startPos &lt; fActiveLimit &amp;&amp; UTEXT_CURRENT32(fInputText) == 0x0a) {</span>
                              (void)UTEXT_NEXT32(fInputText);
                              startPos = UTEXT_GETNATIVEINDEX(fInputText);
                          }
                          MatchAt(startPos, FALSE, status);
                          if (U_FAILURE(status)) {
<span class="line-new-header">--- 834,22 ---</span>
                      if (startPos &gt;= testStartLimit) {
                          fMatch = FALSE;
                          fHitEnd = TRUE;
                          return FALSE;
                      }
<span class="line-modified">!                     ch = UTEXT_NEXT32(fInputText);</span>
                      startPos = UTEXT_GETNATIVEINDEX(fInputText);
                      // Note that it&#39;s perfectly OK for a pattern to have a zero-length
                      //   match at the end of a string, so we must make sure that the loop
                      //   runs with startPos == testStartLimit the last time through.
                      if  (findProgressInterrupt(startPos, status))
                          return FALSE;
                  }
              } else {
                  for (;;) {
<span class="line-modified">!                     if (isLineTerminator(ch)) {</span>
<span class="line-modified">!                         if (ch == 0x0d &amp;&amp; startPos &lt; fActiveLimit &amp;&amp; UTEXT_CURRENT32(fInputText) == 0x0a) {</span>
                              (void)UTEXT_NEXT32(fInputText);
                              startPos = UTEXT_GETNATIVEINDEX(fInputText);
                          }
                          MatchAt(startPos, FALSE, status);
                          if (U_FAILURE(status)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 863,11 ***</span>
                      if (startPos &gt;= testStartLimit) {
                          fMatch = FALSE;
                          fHitEnd = TRUE;
                          return FALSE;
                      }
<span class="line-modified">!                     c = UTEXT_NEXT32(fInputText);</span>
                      startPos = UTEXT_GETNATIVEINDEX(fInputText);
                      // Note that it&#39;s perfectly OK for a pattern to have a zero-length
                      //   match at the end of a string, so we must make sure that the loop
                      //   runs with startPos == testStartLimit the last time through.
                      if  (findProgressInterrupt(startPos, status))
<span class="line-new-header">--- 863,11 ---</span>
                      if (startPos &gt;= testStartLimit) {
                          fMatch = FALSE;
                          fHitEnd = TRUE;
                          return FALSE;
                      }
<span class="line-modified">!                     ch = UTEXT_NEXT32(fInputText);</span>
                      startPos = UTEXT_GETNATIVEINDEX(fInputText);
                      // Note that it&#39;s perfectly OK for a pattern to have a zero-length
                      //   match at the end of a string, so we must make sure that the loop
                      //   runs with startPos == testStartLimit the last time through.
                      if  (findProgressInterrupt(startPos, status))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 875,15 ***</span>
                  }
              }
          }
  
      default:
<span class="line-modified">!         U_ASSERT(FALSE);</span>
      }
  
<span class="line-modified">!     U_ASSERT(FALSE);</span>
<span class="line-removed">-     return FALSE;</span>
  }
  
  
  
  UBool RegexMatcher::find(int64_t start, UErrorCode &amp;status) {
<span class="line-new-header">--- 875,14 ---</span>
                  }
              }
          }
  
      default:
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
      }
  
<span class="line-modified">!     UPRV_UNREACHABLE;</span>
  }
  
  
  
  UBool RegexMatcher::find(int64_t start, UErrorCode &amp;status) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 990,11 ***</span>
              //   match at the end of a string, so we must make sure that the loop
              //   runs with startPos == testLen the last time through.
              if  (findProgressInterrupt(startPos, status))
                  return FALSE;
          }
<span class="line-modified">!         U_ASSERT(FALSE);</span>
  
      case START_START:
          // Matches are only possible at the start of the input string
          //   (pattern begins with ^ or \A)
          if (startPos &gt; fActiveStart) {
<span class="line-new-header">--- 989,11 ---</span>
              //   match at the end of a string, so we must make sure that the loop
              //   runs with startPos == testLen the last time through.
              if  (findProgressInterrupt(startPos, status))
                  return FALSE;
          }
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
  
      case START_START:
          // Matches are only possible at the start of the input string
          //   (pattern begins with ^ or \A)
          if (startPos &gt; fActiveStart) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1032,11 ***</span>
              }
              if  (findProgressInterrupt(startPos, status))
                  return FALSE;
          }
      }
<span class="line-modified">!         U_ASSERT(FALSE);</span>
  
      case START_STRING:
      case START_CHAR:
      {
          // Match starts on exactly one char.
<span class="line-new-header">--- 1031,11 ---</span>
              }
              if  (findProgressInterrupt(startPos, status))
                  return FALSE;
          }
      }
<span class="line-modified">!     UPRV_UNREACHABLE;</span>
  
      case START_STRING:
      case START_CHAR:
      {
          // Match starts on exactly one char.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1061,15 ***</span>
              }
              if  (findProgressInterrupt(startPos, status))
                  return FALSE;
          }
      }
<span class="line-modified">!     U_ASSERT(FALSE);</span>
  
      case START_LINE:
      {
<span class="line-modified">!         UChar32  c;</span>
          if (startPos == fAnchorStart) {
              MatchChunkAt(startPos, FALSE, status);
              if (U_FAILURE(status)) {
                  return FALSE;
              }
<span class="line-new-header">--- 1060,15 ---</span>
              }
              if  (findProgressInterrupt(startPos, status))
                  return FALSE;
          }
      }
<span class="line-modified">!     UPRV_UNREACHABLE;</span>
  
      case START_LINE:
      {
<span class="line-modified">!         UChar32 ch;</span>
          if (startPos == fAnchorStart) {
              MatchChunkAt(startPos, FALSE, status);
              if (U_FAILURE(status)) {
                  return FALSE;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1079,12 ***</span>
              U16_FWD_1(inputBuf, startPos, fActiveLimit);
          }
  
          if (fPattern-&gt;fFlags &amp; UREGEX_UNIX_LINES) {
              for (;;) {
<span class="line-modified">!                 c = inputBuf[startPos-1];</span>
<span class="line-modified">!                 if (c == 0x0a) {</span>
                      MatchChunkAt(startPos, FALSE, status);
                      if (U_FAILURE(status)) {
                          return FALSE;
                      }
                      if (fMatch) {
<span class="line-new-header">--- 1078,12 ---</span>
              U16_FWD_1(inputBuf, startPos, fActiveLimit);
          }
  
          if (fPattern-&gt;fFlags &amp; UREGEX_UNIX_LINES) {
              for (;;) {
<span class="line-modified">!                 ch = inputBuf[startPos-1];</span>
<span class="line-modified">!                 if (ch == 0x0a) {</span>
                      MatchChunkAt(startPos, FALSE, status);
                      if (U_FAILURE(status)) {
                          return FALSE;
                      }
                      if (fMatch) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1103,13 ***</span>
                  if  (findProgressInterrupt(startPos, status))
                      return FALSE;
              }
          } else {
              for (;;) {
<span class="line-modified">!                 c = inputBuf[startPos-1];</span>
<span class="line-modified">!                 if (isLineTerminator(c)) {</span>
<span class="line-modified">!                     if (c == 0x0d &amp;&amp; startPos &lt; fActiveLimit &amp;&amp; inputBuf[startPos] == 0x0a) {</span>
                          startPos++;
                      }
                      MatchChunkAt(startPos, FALSE, status);
                      if (U_FAILURE(status)) {
                          return FALSE;
<span class="line-new-header">--- 1102,13 ---</span>
                  if  (findProgressInterrupt(startPos, status))
                      return FALSE;
              }
          } else {
              for (;;) {
<span class="line-modified">!                 ch = inputBuf[startPos-1];</span>
<span class="line-modified">!                 if (isLineTerminator(ch)) {</span>
<span class="line-modified">!                     if (ch == 0x0d &amp;&amp; startPos &lt; fActiveLimit &amp;&amp; inputBuf[startPos] == 0x0a) {</span>
                          startPos++;
                      }
                      MatchChunkAt(startPos, FALSE, status);
                      if (U_FAILURE(status)) {
                          return FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1132,15 ***</span>
              }
          }
      }
  
      default:
<span class="line-modified">!         U_ASSERT(FALSE);</span>
      }
  
<span class="line-modified">!     U_ASSERT(FALSE);</span>
<span class="line-removed">-     return FALSE;</span>
  }
  
  
  
  //--------------------------------------------------------------------------------
<span class="line-new-header">--- 1131,14 ---</span>
              }
          }
      }
  
      default:
<span class="line-modified">!         UPRV_UNREACHABLE;</span>
      }
  
<span class="line-modified">!     UPRV_UNREACHABLE;</span>
  }
  
  
  
  //--------------------------------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2772,11 ***</span>
      //  Cache frequently referenced items from the compiled pattern
      //
      int64_t             *pat           = fPattern-&gt;fCompiledPat-&gt;getBuffer();
  
      const UChar         *litText       = fPattern-&gt;fLiteralText.getBuffer();
<span class="line-modified">!     UVector             *sets          = fPattern-&gt;fSets;</span>
  
      fFrameSize = fPattern-&gt;fFrameSize;
      REStackFrame        *fp            = resetStack();
      if (U_FAILURE(fDeferredStatus)) {
          status = fDeferredStatus;
<span class="line-new-header">--- 2770,11 ---</span>
      //  Cache frequently referenced items from the compiled pattern
      //
      int64_t             *pat           = fPattern-&gt;fCompiledPat-&gt;getBuffer();
  
      const UChar         *litText       = fPattern-&gt;fLiteralText.getBuffer();
<span class="line-modified">!     UVector             *fSets         = fPattern-&gt;fSets;</span>
  
      fFrameSize = fPattern-&gt;fFrameSize;
      REStackFrame        *fp            = resetStack();
      if (U_FAILURE(fDeferredStatus)) {
          status = fDeferredStatus;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3374,19 ***</span>
              } else {
                  UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
  
                  // There is input left.  Pick up one char and test it for set membership.
                  UChar32 c = UTEXT_NEXT32(fInputText);
<span class="line-modified">!                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; sets-&gt;size());</span>
                  if (c&lt;256) {
                      Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
                      if (s8-&gt;contains(c)) {
                          fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
                          break;
                      }
                  } else {
<span class="line-modified">!                     UnicodeSet *s = (UnicodeSet *)sets-&gt;elementAt(opValue);</span>
                      if (s-&gt;contains(c)) {
                          // The character is in the set.  A Match.
                          fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
                          break;
                      }
<span class="line-new-header">--- 3372,19 ---</span>
              } else {
                  UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
  
                  // There is input left.  Pick up one char and test it for set membership.
                  UChar32 c = UTEXT_NEXT32(fInputText);
<span class="line-modified">!                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
                  if (c&lt;256) {
                      Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
                      if (s8-&gt;contains(c)) {
                          fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
                          break;
                      }
                  } else {
<span class="line-modified">!                     UnicodeSet *s = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
                      if (s-&gt;contains(c)) {
                          // The character is in the set.  A Match.
                          fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
                          break;
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3669,13 ***</span>
                  U_ASSERT(newStackSize &lt;= fStack-&gt;size());
                  int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
                  if (newFP == (int64_t *)fp) {
                      break;
                  }
<span class="line-modified">!                 int32_t i;</span>
<span class="line-modified">!                 for (i=0; i&lt;fFrameSize; i++) {</span>
<span class="line-modified">!                     newFP[i] = ((int64_t *)fp)[i];</span>
                  }
                  fp = (REStackFrame *)newFP;
                  fStack-&gt;setSize(newStackSize);
              }
              break;
<span class="line-new-header">--- 3667,13 ---</span>
                  U_ASSERT(newStackSize &lt;= fStack-&gt;size());
                  int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
                  if (newFP == (int64_t *)fp) {
                      break;
                  }
<span class="line-modified">!                 int32_t j;</span>
<span class="line-modified">!                 for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">!                     newFP[j] = ((int64_t *)fp)[j];</span>
                  }
                  fp = (REStackFrame *)newFP;
                  fStack-&gt;setSize(newStackSize);
              }
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3828,13 ***</span>
                  if (stackSize &gt; newStackSize) {
                      // Copy the current top frame back to the new (cut back) top frame.
                      //   This makes the capture groups from within the look-ahead
                      //   expression available.
                      int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
<span class="line-modified">!                     int32_t i;</span>
<span class="line-modified">!                     for (i=0; i&lt;fFrameSize; i++) {</span>
<span class="line-modified">!                         newFP[i] = ((int64_t *)fp)[i];</span>
                      }
                      fp = (REStackFrame *)newFP;
                      fStack-&gt;setSize(newStackSize);
                  }
                  fp-&gt;fInputIdx = fData[opValue+1];
<span class="line-new-header">--- 3826,13 ---</span>
                  if (stackSize &gt; newStackSize) {
                      // Copy the current top frame back to the new (cut back) top frame.
                      //   This makes the capture groups from within the look-ahead
                      //   expression available.
                      int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
<span class="line-modified">!                     int32_t j;</span>
<span class="line-modified">!                     for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">!                         newFP[j] = ((int64_t *)fp)[j];</span>
                      }
                      fp = (REStackFrame *)newFP;
                      fStack-&gt;setSize(newStackSize);
                  }
                  fp-&gt;fInputIdx = fData[opValue+1];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4121,13 ***</span>
              // Loop Initialization for the optimized implementation of
              //     [some character set]*
              //   This op scans through all matching input.
              //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
              {
<span class="line-modified">!                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; sets-&gt;size());</span>
                  Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
<span class="line-modified">!                 UnicodeSet   *s  = (UnicodeSet *)sets-&gt;elementAt(opValue);</span>
  
                  // Loop through input, until either the input is exhausted or
                  //   we reach a character that is not a member of the set.
                  int64_t ix = fp-&gt;fInputIdx;
                  UTEXT_SETNATIVEINDEX(fInputText, ix);
<span class="line-new-header">--- 4119,13 ---</span>
              // Loop Initialization for the optimized implementation of
              //     [some character set]*
              //   This op scans through all matching input.
              //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
              {
<span class="line-modified">!                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
                  Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
<span class="line-modified">!                 UnicodeSet   *s  = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
  
                  // Loop through input, until either the input is exhausted or
                  //   we reach a character that is not a member of the set.
                  int64_t ix = fp-&gt;fInputIdx;
                  UTEXT_SETNATIVEINDEX(fInputText, ix);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4276,11 ***</span>
  
  
          default:
              // Trouble.  The compiled pattern contains an entry with an
              //           unrecognized type tag.
<span class="line-modified">!             U_ASSERT(FALSE);</span>
          }
  
          if (U_FAILURE(status)) {
              isMatch = FALSE;
              break;
<span class="line-new-header">--- 4274,11 ---</span>
  
  
          default:
              // Trouble.  The compiled pattern contains an entry with an
              //           unrecognized type tag.
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
          }
  
          if (U_FAILURE(status)) {
              isMatch = FALSE;
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4348,11 ***</span>
      //  Cache frequently referenced items from the compiled pattern
      //
      int64_t             *pat           = fPattern-&gt;fCompiledPat-&gt;getBuffer();
  
      const UChar         *litText       = fPattern-&gt;fLiteralText.getBuffer();
<span class="line-modified">!     UVector             *sets          = fPattern-&gt;fSets;</span>
  
      const UChar         *inputBuf      = fInputText-&gt;chunkContents;
  
      fFrameSize = fPattern-&gt;fFrameSize;
      REStackFrame        *fp            = resetStack();
<span class="line-new-header">--- 4346,11 ---</span>
      //  Cache frequently referenced items from the compiled pattern
      //
      int64_t             *pat           = fPattern-&gt;fCompiledPat-&gt;getBuffer();
  
      const UChar         *litText       = fPattern-&gt;fLiteralText.getBuffer();
<span class="line-modified">!     UVector             *fSets         = fPattern-&gt;fSets;</span>
  
      const UChar         *inputBuf      = fInputText-&gt;chunkContents;
  
      fFrameSize = fPattern-&gt;fFrameSize;
      REStackFrame        *fp            = resetStack();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4926,11 ***</span>
                      fHitEnd = TRUE;
                      fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
                      break;
                  }
  
<span class="line-modified">!                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; sets-&gt;size());</span>
  
                  // There is input left.  Pick up one char and test it for set membership.
                  UChar32  c;
                  U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
                  if (c&lt;256) {
<span class="line-new-header">--- 4924,11 ---</span>
                      fHitEnd = TRUE;
                      fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
                      break;
                  }
  
<span class="line-modified">!                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
  
                  // There is input left.  Pick up one char and test it for set membership.
                  UChar32  c;
                  U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
                  if (c&lt;256) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4938,11 ***</span>
                      if (s8-&gt;contains(c)) {
                          // The character is in the set.  A Match.
                          break;
                      }
                  } else {
<span class="line-modified">!                     UnicodeSet *s = (UnicodeSet *)sets-&gt;elementAt(opValue);</span>
                      if (s-&gt;contains(c)) {
                          // The character is in the set.  A Match.
                          break;
                      }
                  }
<span class="line-new-header">--- 4936,11 ---</span>
                      if (s8-&gt;contains(c)) {
                          // The character is in the set.  A Match.
                          break;
                      }
                  } else {
<span class="line-modified">!                     UnicodeSet *s = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
                      if (s-&gt;contains(c)) {
                          // The character is in the set.  A Match.
                          break;
                      }
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5212,13 ***</span>
                  U_ASSERT(newStackSize &lt;= fStack-&gt;size());
                  int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
                  if (newFP == (int64_t *)fp) {
                      break;
                  }
<span class="line-modified">!                 int32_t i;</span>
<span class="line-modified">!                 for (i=0; i&lt;fFrameSize; i++) {</span>
<span class="line-modified">!                     newFP[i] = ((int64_t *)fp)[i];</span>
                  }
                  fp = (REStackFrame *)newFP;
                  fStack-&gt;setSize(newStackSize);
              }
              break;
<span class="line-new-header">--- 5210,13 ---</span>
                  U_ASSERT(newStackSize &lt;= fStack-&gt;size());
                  int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
                  if (newFP == (int64_t *)fp) {
                      break;
                  }
<span class="line-modified">!                 int32_t j;</span>
<span class="line-modified">!                 for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">!                     newFP[j] = ((int64_t *)fp)[j];</span>
                  }
                  fp = (REStackFrame *)newFP;
                  fStack-&gt;setSize(newStackSize);
              }
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5359,13 ***</span>
                  if (stackSize &gt; newStackSize) {
                      // Copy the current top frame back to the new (cut back) top frame.
                      //   This makes the capture groups from within the look-ahead
                      //   expression available.
                      int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
<span class="line-modified">!                     int32_t i;</span>
<span class="line-modified">!                     for (i=0; i&lt;fFrameSize; i++) {</span>
<span class="line-modified">!                         newFP[i] = ((int64_t *)fp)[i];</span>
                      }
                      fp = (REStackFrame *)newFP;
                      fStack-&gt;setSize(newStackSize);
                  }
                  fp-&gt;fInputIdx = fData[opValue+1];
<span class="line-new-header">--- 5357,13 ---</span>
                  if (stackSize &gt; newStackSize) {
                      // Copy the current top frame back to the new (cut back) top frame.
                      //   This makes the capture groups from within the look-ahead
                      //   expression available.
                      int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
<span class="line-modified">!                     int32_t j;</span>
<span class="line-modified">!                     for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">!                         newFP[j] = ((int64_t *)fp)[j];</span>
                      }
                      fp = (REStackFrame *)newFP;
                      fStack-&gt;setSize(newStackSize);
                  }
                  fp-&gt;fInputIdx = fData[opValue+1];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5621,13 ***</span>
              // Loop Initialization for the optimized implementation of
              //     [some character set]*
              //   This op scans through all matching input.
              //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
              {
<span class="line-modified">!                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; sets-&gt;size());</span>
                  Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
<span class="line-modified">!                 UnicodeSet   *s  = (UnicodeSet *)sets-&gt;elementAt(opValue);</span>
  
                  // Loop through input, until either the input is exhausted or
                  //   we reach a character that is not a member of the set.
                  int32_t ix = (int32_t)fp-&gt;fInputIdx;
                  for (;;) {
<span class="line-new-header">--- 5619,13 ---</span>
              // Loop Initialization for the optimized implementation of
              //     [some character set]*
              //   This op scans through all matching input.
              //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
              {
<span class="line-modified">!                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
                  Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
<span class="line-modified">!                 UnicodeSet   *s  = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
  
                  // Loop through input, until either the input is exhausted or
                  //   we reach a character that is not a member of the set.
                  int32_t ix = (int32_t)fp-&gt;fInputIdx;
                  for (;;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5776,11 ***</span>
  
  
          default:
              // Trouble.  The compiled pattern contains an entry with an
              //           unrecognized type tag.
<span class="line-modified">!             U_ASSERT(FALSE);</span>
          }
  
          if (U_FAILURE(status)) {
              isMatch = FALSE;
              break;
<span class="line-new-header">--- 5774,11 ---</span>
  
  
          default:
              // Trouble.  The compiled pattern contains an entry with an
              //           unrecognized type tag.
<span class="line-modified">!             UPRV_UNREACHABLE;</span>
          }
  
          if (U_FAILURE(status)) {
              isMatch = FALSE;
              break;
</pre>
<center><a href="reldtfmt.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rulebasedcollator.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>