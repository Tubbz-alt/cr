<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/numberformatter.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="nounit.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="numfmt.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/numberformatter.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 // © 2017 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 
   4 #include &quot;unicode/utypes.h&quot;
   5 
   6 #if !UCONFIG_NO_FORMATTING
   7 #ifndef __NUMBERFORMATTER_H__
   8 #define __NUMBERFORMATTER_H__
   9 
  10 #include &quot;unicode/appendable.h&quot;
  11 #include &quot;unicode/dcfmtsym.h&quot;
  12 #include &quot;unicode/currunit.h&quot;
  13 #include &quot;unicode/fieldpos.h&quot;

  14 #include &quot;unicode/fpositer.h&quot;
  15 #include &quot;unicode/measunit.h&quot;
  16 #include &quot;unicode/nounit.h&quot;

  17 #include &quot;unicode/plurrule.h&quot;
  18 #include &quot;unicode/ucurr.h&quot;
  19 #include &quot;unicode/unum.h&quot;
  20 #include &quot;unicode/unumberformatter.h&quot;
  21 #include &quot;unicode/uobject.h&quot;
  22 
  23 #ifndef U_HIDE_DRAFT_API
  24 
  25 /**
  26  * \file
  27  * \brief C++ API: Library for localized number formatting introduced in ICU 60.
  28  *
  29  * This library was introduced in ICU 60 to simplify the process of formatting localized number strings.
  30  * Basic usage examples:
  31  *
  32  * &lt;pre&gt;
  33  * // Most basic usage:
  34  * NumberFormatter::withLocale(...).format(123).toString();  // 1,234 in en-US
  35  *
  36  * // Custom notation, unit, and rounding precision:
  37  * NumberFormatter::with()
  38  *     .notation(Notation::compactShort())
  39  *     .unit(CurrencyUnit(&quot;EUR&quot;, status))
  40  *     .precision(Precision::maxDigits(2))
  41  *     .locale(...)
  42  *     .format(1234)
  43  *     .toString();  // €1.2K in en-US
  44  *
<span class="line-modified">  45  * // Create a formatter in a singleton for use later:</span>
  46  * static const LocalizedNumberFormatter formatter = NumberFormatter::withLocale(...)
  47  *     .unit(NoUnit::percent())
  48  *     .precision(Precision::fixedFraction(3));
  49  * formatter.format(5.9831).toString();  // 5.983% in en-US
  50  *
<span class="line-modified">  51  * // Create a &quot;template&quot; in a singleton but without setting a locale until the call site:</span>
<span class="line-modified">  52  * static const UnlocalizedNumberFormatter template = NumberFormatter::with()</span>
  53  *     .sign(UNumberSignDisplay::UNUM_SIGN_ALWAYS)
<span class="line-modified">  54  *     .adoptUnit(MeasureUnit::createMeter(status))</span>
<span class="line-modified">  55  *     .unitWidth(UNumberUnitWidth::UNUM_UNIT_WIDTH_FULL_NAME);</span>
<span class="line-modified">  56  * template.locale(...).format(1234).toString();  // +1,234 meters in en-US</span>

  57  * &lt;/pre&gt;
  58  *
  59  * &lt;p&gt;
  60  * This API offers more features than DecimalFormat and is geared toward new users of ICU.
  61  *
  62  * &lt;p&gt;
<span class="line-modified">  63  * NumberFormatter instances are immutable and thread safe. This means that invoking a configuration method has no</span>

  64  * effect on the receiving instance; you must store and use the new number formatter instance it returns instead.
  65  *
  66  * &lt;pre&gt;
  67  * UnlocalizedNumberFormatter formatter = UnlocalizedNumberFormatter::with().notation(Notation::scientific());
  68  * formatter.precision(Precision.maxFraction(2)); // does nothing!
  69  * formatter.locale(Locale.getEnglish()).format(9.8765).toString(); // prints &quot;9.8765E0&quot;, not &quot;9.88E0&quot;
  70  * &lt;/pre&gt;
  71  *
  72  * &lt;p&gt;
  73  * This API is based on the &lt;em&gt;fluent&lt;/em&gt; design pattern popularized by libraries such as Google&#39;s Guava. For
  74  * extensive details on the design of this API, read &lt;a href=&quot;https://goo.gl/szi5VB&quot;&gt;the design doc&lt;/a&gt;.
  75  *
  76  * @author Shane Carr
  77  */
  78 
  79 U_NAMESPACE_BEGIN
  80 
  81 // Forward declarations:
  82 class IFixedDecimal;
  83 class FieldPositionIteratorHandler;
</pre>
<hr />
<pre>
  91 
  92 }
  93 }
  94 
  95 namespace number {  // icu::number
  96 
  97 // Forward declarations:
  98 class UnlocalizedNumberFormatter;
  99 class LocalizedNumberFormatter;
 100 class FormattedNumber;
 101 class Notation;
 102 class ScientificNotation;
 103 class Precision;
 104 class FractionPrecision;
 105 class CurrencyPrecision;
 106 class IncrementPrecision;
 107 class IntegerWidth;
 108 
 109 namespace impl {
 110 

 111 /**
 112  * Datatype for minimum/maximum fraction digits. Must be able to hold kMaxIntFracSig.
 113  *
 114  * @internal
 115  */
 116 typedef int16_t digits_t;
 117 

 118 /**
 119  * Use a default threshold of 3. This means that the third time .format() is called, the data structures get built
 120  * using the &quot;safe&quot; code path. The first two calls to .format() will trigger the unsafe code path.
 121  *
 122  * @internal
 123  */
<span class="line-modified"> 124 static constexpr int32_t DEFAULT_THRESHOLD = 3;</span>
 125 
 126 // Forward declarations:
 127 class Padder;
 128 struct MacroProps;
 129 struct MicroProps;
 130 class DecimalQuantity;
<span class="line-modified"> 131 struct UFormattedNumberData;</span>
 132 class NumberFormatterImpl;
 133 struct ParsedPatternInfo;
 134 class ScientificModifier;
 135 class MultiplierProducer;
 136 class RoundingImpl;
 137 class ScientificHandler;
 138 class Modifier;
 139 class NumberStringBuilder;
 140 class AffixPatternProvider;
 141 class NumberPropertyMapper;
 142 struct DecimalFormatProperties;
 143 class MultiplierFormatHandler;
 144 class CurrencySymbols;
 145 class GeneratorHelpers;
 146 class DecNum;











 147 
 148 } // namespace impl
 149 
<span class="line-modified"> 150 // Reserve extra names in case they are added as classes in the future:</span>




 151 typedef Notation CompactNotation;






 152 typedef Notation SimpleNotation;
 153 
 154 /**
 155  * A class that defines the notation style to be used when formatting numbers in NumberFormatter.
 156  *
 157  * @draft ICU 60
 158  */
 159 class U_I18N_API Notation : public UMemory {
 160   public:
 161     /**
 162      * Print the number using scientific notation (also known as scientific form, standard index form, or standard form
 163      * in the UK). The format for scientific notation varies by locale; for example, many Western locales display the
 164      * number in the form &quot;#E0&quot;, where the number is displayed with one digit before the decimal separator, zero or more
 165      * digits after the decimal separator, and the corresponding power of 10 displayed after the &quot;E&quot;.
 166      *
 167      * &lt;p&gt;
 168      * Example outputs in &lt;em&gt;en-US&lt;/em&gt; when printing 8.765E4 through 8.765E-3:
 169      *
 170      * &lt;pre&gt;
 171      * 8.765E4
</pre>
<hr />
<pre>
 291      * 876,500
 292      * 87,650
 293      * 8,765
 294      * 876.5
 295      * 87.65
 296      * 8.765
 297      * &lt;/pre&gt;
 298      *
 299      * @return A SimpleNotation for passing to the NumberFormatter notation() setter.
 300      * @draft ICU 60
 301      */
 302     static SimpleNotation simple();
 303 
 304   private:
 305     enum NotationType {
 306         NTN_SCIENTIFIC, NTN_COMPACT, NTN_SIMPLE, NTN_ERROR
 307     } fType;
 308 
 309     union NotationUnion {
 310         // For NTN_SCIENTIFIC

 311         struct ScientificSettings {

 312             int8_t fEngineeringInterval;

 313             bool fRequireMinInt;

 314             impl::digits_t fMinExponentDigits;

 315             UNumberSignDisplay fExponentSignDisplay;
 316         } scientific;
 317 
 318         // For NTN_COMPACT
 319         UNumberCompactStyle compactStyle;
 320 
 321         // For NTN_ERROR
 322         UErrorCode errorCode;
 323     } fUnion;
 324 
 325     typedef NotationUnion::ScientificSettings ScientificSettings;
 326 
 327     Notation(const NotationType &amp;type, const NotationUnion &amp;union_) : fType(type), fUnion(union_) {}
 328 
 329     Notation(UErrorCode errorCode) : fType(NTN_ERROR) {
 330         fUnion.errorCode = errorCode;
 331     }
 332 
 333     Notation() : fType(NTN_SIMPLE), fUnion() {}
 334 
</pre>
<hr />
<pre>
 390      *            The strategy for displaying the sign in the exponent.
 391      * @return A ScientificNotation, for chaining.
 392      * @draft ICU 60
 393      */
 394     ScientificNotation withExponentSignDisplay(UNumberSignDisplay exponentSignDisplay) const;
 395 
 396   private:
 397     // Inherit constructor
 398     using Notation::Notation;
 399 
 400     // Raw constructor for NumberPropertyMapper
 401     ScientificNotation(int8_t fEngineeringInterval, bool fRequireMinInt, impl::digits_t fMinExponentDigits,
 402                        UNumberSignDisplay fExponentSignDisplay);
 403 
 404     friend class Notation;
 405 
 406     // So that NumberPropertyMapper can create instances
 407     friend class impl::NumberPropertyMapper;
 408 };
 409 
<span class="line-modified"> 410 // Reserve extra names in case they are added as classes in the future:</span>




 411 typedef Precision SignificantDigitsPrecision;
 412 
<span class="line-removed"> 413 // Typedefs for ICU 60/61 compatibility.</span>
<span class="line-removed"> 414 // These will be removed in ICU 64.</span>
<span class="line-removed"> 415 // See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed"> 416 typedef Precision Rounder;</span>
<span class="line-removed"> 417 typedef FractionPrecision FractionRounder;</span>
<span class="line-removed"> 418 typedef IncrementPrecision IncrementRounder;</span>
<span class="line-removed"> 419 typedef CurrencyPrecision CurrencyRounder;</span>
<span class="line-removed"> 420 </span>
 421 /**
 422  * A class that defines the rounding precision to be used when formatting numbers in NumberFormatter.
 423  *
 424  * &lt;p&gt;
 425  * To create a Precision, use one of the factory methods.
 426  *
 427  * @draft ICU 60
 428  */
 429 class U_I18N_API Precision : public UMemory {
 430 
 431   public:
 432     /**
 433      * Show all available digits to full precision.
 434      *
 435      * &lt;p&gt;
 436      * &lt;strong&gt;NOTE:&lt;/strong&gt; When formatting a &lt;em&gt;double&lt;/em&gt;, this method, along with {@link #minFraction} and
<span class="line-modified"> 437      * {@link #minDigits}, will trigger complex algorithm similar to &lt;em&gt;Dragon4&lt;/em&gt; to determine the low-order digits</span>
<span class="line-modified"> 438      * and the number of digits to display based on the value of the double. If the number of fraction places or</span>
<span class="line-modified"> 439      * significant digits can be bounded, consider using {@link #maxFraction} or {@link #maxDigits} instead to maximize</span>
<span class="line-modified"> 440      * performance. For more information, read the following blog post.</span>

 441      *
 442      * &lt;p&gt;
 443      * http://www.serpentine.com/blog/2011/06/29/here-be-dragons-advances-in-problems-you-didnt-even-know-you-had/
 444      *
 445      * @return A Precision for chaining or passing to the NumberFormatter precision() setter.
 446      * @draft ICU 60
 447      */
 448     static Precision unlimited();
 449 
 450     /**
 451      * Show numbers rounded if necessary to the nearest integer.
 452      *
 453      * @return A FractionPrecision for chaining or passing to the NumberFormatter precision() setter.
 454      * @draft ICU 60
 455      */
 456     static FractionPrecision integer();
 457 
 458     /**
 459      * Show numbers rounded if necessary to a certain number of fraction places (numerals after the decimal separator).
 460      * Additionally, pad with zeros to ensure that this number of places are always shown.
</pre>
<hr />
<pre>
 514     /**
 515      * Show numbers rounded if necessary to a certain number of fraction places (numerals after the decimal separator);
 516      * in addition, always show at least a certain number of places after the decimal separator, padding with zeros if
 517      * necessary.
 518      *
 519      * @param minFractionPlaces
 520      *            The minimum number of numerals to display after the decimal separator (padding with zeros if
 521      *            necessary).
 522      * @param maxFractionPlaces
 523      *            The maximum number of numerals to display after the decimal separator (rounding if necessary).
 524      * @return A FractionPrecision for chaining or passing to the NumberFormatter precision() setter.
 525      * @draft ICU 60
 526      */
 527     static FractionPrecision minMaxFraction(int32_t minFractionPlaces, int32_t maxFractionPlaces);
 528 
 529     /**
 530      * Show numbers rounded if necessary to a certain number of significant digits or significant figures. Additionally,
 531      * pad with zeros to ensure that this number of significant digits/figures are always shown.
 532      *
 533      * &lt;p&gt;
<span class="line-modified"> 534      * This method is equivalent to {@link #minMaxDigits} with both arguments equal.</span>
 535      *
 536      * @param minMaxSignificantDigits
 537      *            The minimum and maximum number of significant digits to display (rounding if too long or padding with
 538      *            zeros if too short).
 539      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 540      * @draft ICU 62
 541      */
 542     static SignificantDigitsPrecision fixedSignificantDigits(int32_t minMaxSignificantDigits);
 543 
 544     /**
 545      * Always show at least a certain number of significant digits/figures, padding with zeros if necessary. Do not
 546      * perform rounding (display numbers to their full precision).
 547      *
 548      * &lt;p&gt;
 549      * &lt;strong&gt;NOTE:&lt;/strong&gt; If you are formatting &lt;em&gt;doubles&lt;/em&gt;, see the performance note in {@link #unlimited}.
 550      *
 551      * @param minSignificantDigits
 552      *            The minimum number of significant digits to display (padding with zeros if too short).
 553      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 554      * @draft ICU 62
</pre>
<hr />
<pre>
 562      *            The maximum number of significant digits to display (rounding if too long).
 563      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 564      * @draft ICU 62
 565      */
 566     static SignificantDigitsPrecision maxSignificantDigits(int32_t maxSignificantDigits);
 567 
 568     /**
 569      * Show numbers rounded if necessary to a certain number of significant digits/figures; in addition, always show at
 570      * least a certain number of significant digits, padding with zeros if necessary.
 571      *
 572      * @param minSignificantDigits
 573      *            The minimum number of significant digits to display (padding with zeros if necessary).
 574      * @param maxSignificantDigits
 575      *            The maximum number of significant digits to display (rounding if necessary).
 576      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 577      * @draft ICU 62
 578      */
 579     static SignificantDigitsPrecision minMaxSignificantDigits(int32_t minSignificantDigits,
 580                                                               int32_t maxSignificantDigits);
 581 
<span class="line-removed"> 582 #ifndef U_HIDE_DEPRECATED_API</span>
<span class="line-removed"> 583     // Compatiblity methods that will be removed in ICU 64.</span>
<span class="line-removed"> 584     // See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed"> 585 </span>
<span class="line-removed"> 586     /** @deprecated ICU 62 */</span>
<span class="line-removed"> 587     static inline SignificantDigitsPrecision fixedDigits(int32_t a) {</span>
<span class="line-removed"> 588         return fixedSignificantDigits(a);</span>
<span class="line-removed"> 589     }</span>
<span class="line-removed"> 590 </span>
<span class="line-removed"> 591     /** @deprecated ICU 62 */</span>
<span class="line-removed"> 592     static inline SignificantDigitsPrecision minDigits(int32_t a) {</span>
<span class="line-removed"> 593         return minSignificantDigits(a);</span>
<span class="line-removed"> 594     }</span>
<span class="line-removed"> 595 </span>
<span class="line-removed"> 596     /** @deprecated ICU 62 */</span>
<span class="line-removed"> 597     static inline SignificantDigitsPrecision maxDigits(int32_t a) {</span>
<span class="line-removed"> 598         return maxSignificantDigits(a);</span>
<span class="line-removed"> 599     }</span>
<span class="line-removed"> 600 </span>
<span class="line-removed"> 601     /** @deprecated ICU 62 */</span>
<span class="line-removed"> 602     static inline SignificantDigitsPrecision minMaxDigits(int32_t a, int32_t b) {</span>
<span class="line-removed"> 603         return minMaxSignificantDigits(a, b);</span>
<span class="line-removed"> 604     }</span>
<span class="line-removed"> 605 #endif  /* U_HIDE_DEPRECATED_API */</span>
<span class="line-removed"> 606 </span>
 607     /**
 608      * Show numbers rounded if necessary to the closest multiple of a certain rounding increment. For example, if the
 609      * rounding increment is 0.5, then round 1.2 to 1 and round 1.3 to 1.5.
 610      *
 611      * &lt;p&gt;
 612      * In order to ensure that numbers are padded to the appropriate number of fraction places, call
 613      * withMinFraction() on the return value of this method.
 614      * For example, to round to the nearest 0.5 and always display 2 numerals after the
 615      * decimal separator (to display 1.2 as &quot;1.00&quot; and 1.3 as &quot;1.50&quot;), you can run:
 616      *
 617      * &lt;pre&gt;
 618      * Precision::increment(0.5).withMinFraction(2)
 619      * &lt;/pre&gt;
 620      *
 621      * @param roundingIncrement
 622      *            The increment to which to round numbers.
 623      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 624      * @draft ICU 60
 625      */
 626     static IncrementPrecision increment(double roundingIncrement);
 627 
 628     /**
 629      * Show numbers rounded and padded according to the rules for the currency unit. The most common
 630      * rounding precision settings for currencies include &lt;code&gt;Precision::fixedFraction(2)&lt;/code&gt;,
 631      * &lt;code&gt;Precision::integer()&lt;/code&gt;, and &lt;code&gt;Precision::increment(0.05)&lt;/code&gt; for cash transactions
 632      * (&quot;nickel rounding&quot;).
 633      *
 634      * &lt;p&gt;
 635      * The exact rounding details will be resolved at runtime based on the currency unit specified in the
 636      * NumberFormatter chain. To round according to the rules for one currency while displaying the symbol for another
 637      * currency, the withCurrency() method can be called on the return value of this method.
 638      *
 639      * @param currencyUsage
 640      *            Either STANDARD (for digital transactions) or CASH (for transactions where the rounding increment may
 641      *            be limited by the available denominations of cash or coins).
 642      * @return A CurrencyPrecision for chaining or passing to the NumberFormatter precision() setter.
 643      * @draft ICU 60
 644      */
 645     static CurrencyPrecision currency(UCurrencyUsage currencyUsage);
 646 
<span class="line-removed"> 647 #ifndef U_HIDE_DEPRECATED_API</span>
<span class="line-removed"> 648     /**</span>
<span class="line-removed"> 649      * Sets the rounding mode to use when picking the direction to round (up or down). Common values</span>
<span class="line-removed"> 650      * include HALF_EVEN, HALF_UP, and FLOOR. The default is HALF_EVEN.</span>
<span class="line-removed"> 651      *</span>
<span class="line-removed"> 652      * @param roundingMode</span>
<span class="line-removed"> 653      *            The RoundingMode to use.</span>
<span class="line-removed"> 654      * @return A Precision for passing to the NumberFormatter precision() setter.</span>
<span class="line-removed"> 655      * @deprecated ICU 62 Use the top-level roundingMode() setting instead.</span>
<span class="line-removed"> 656      *            This method will be removed in ICU 64.</span>
<span class="line-removed"> 657      *            See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed"> 658      */</span>
<span class="line-removed"> 659     Precision withMode(UNumberFormatRoundingMode roundingMode) const;</span>
<span class="line-removed"> 660 #endif  /* U_HIDE_DEPRECATED_API */</span>
<span class="line-removed"> 661 </span>
 662   private:
 663     enum PrecisionType {
 664         RND_BOGUS,
 665         RND_NONE,
 666         RND_FRACTION,
 667         RND_SIGNIFICANT,
 668         RND_FRACTION_SIGNIFICANT,


 669         RND_INCREMENT,









 670         RND_CURRENCY,
 671         RND_ERROR
 672     } fType;
 673 
 674     union PrecisionUnion {

 675         struct FractionSignificantSettings {
 676             // For RND_FRACTION, RND_SIGNIFICANT, and RND_FRACTION_SIGNIFICANT

 677             impl::digits_t fMinFrac;

 678             impl::digits_t fMaxFrac;

 679             impl::digits_t fMinSig;

 680             impl::digits_t fMaxSig;
 681         } fracSig;

 682         struct IncrementSettings {


 683             double fIncrement;

 684             impl::digits_t fMinFrac;

 685             impl::digits_t fMaxFrac;
<span class="line-modified"> 686         } increment; // For RND_INCREMENT</span>
 687         UCurrencyUsage currencyUsage; // For RND_CURRENCY
 688         UErrorCode errorCode; // For RND_ERROR
 689     } fUnion;
 690 
 691     typedef PrecisionUnion::FractionSignificantSettings FractionSignificantSettings;
 692     typedef PrecisionUnion::IncrementSettings IncrementSettings;
 693 
 694     /** The Precision encapsulates the RoundingMode when used within the implementation. */
 695     UNumberFormatRoundingMode fRoundingMode;
 696 
 697     Precision(const PrecisionType&amp; type, const PrecisionUnion&amp; union_,
 698               UNumberFormatRoundingMode roundingMode)
 699             : fType(type), fUnion(union_), fRoundingMode(roundingMode) {}
 700 
 701     Precision(UErrorCode errorCode) : fType(RND_ERROR) {
 702         fUnion.errorCode = errorCode;
 703     }
 704 
 705     Precision() : fType(RND_BOGUS) {}
 706 
</pre>
<hr />
<pre>
1188     } fType;
1189 
1190     union {
1191         const DecimalFormatSymbols *dfs;
1192         const NumberingSystem *ns;
1193     } fPtr;
1194 
1195     void doCopyFrom(const SymbolsWrapper &amp;other);
1196 
1197     void doMoveFrom(SymbolsWrapper&amp;&amp; src);
1198 
1199     void doCleanup();
1200 };
1201 
1202 // Do not enclose entire Grouper with #ifndef U_HIDE_INTERNAL_API, needed for a protected field
1203 /** @internal */
1204 class U_I18N_API Grouper : public UMemory {
1205   public:
1206 #ifndef U_HIDE_INTERNAL_API
1207     /** @internal */
<span class="line-modified">1208     static Grouper forStrategy(UGroupingStrategy grouping);</span>
1209 
1210     /**
1211      * Resolve the values in Properties to a Grouper object.
1212      * @internal
1213      */
1214     static Grouper forProperties(const DecimalFormatProperties&amp; properties);
1215 
1216     // Future: static Grouper forProperties(DecimalFormatProperties&amp; properties);
1217 
1218     /** @internal */
<span class="line-modified">1219     Grouper(int16_t grouping1, int16_t grouping2, int16_t minGrouping, UGroupingStrategy strategy)</span>
1220             : fGrouping1(grouping1),
1221               fGrouping2(grouping2),
1222               fMinGrouping(minGrouping),
1223               fStrategy(strategy) {}
1224 #endif  // U_HIDE_INTERNAL_API
1225 
1226     /** @internal */
1227     int16_t getPrimary() const;
1228 
1229     /** @internal */
1230     int16_t getSecondary() const;
1231 
1232   private:
1233     /**
1234      * The grouping sizes, with the following special values:
1235      * &lt;ul&gt;
1236      * &lt;li&gt;-1 = no grouping
1237      * &lt;li&gt;-2 = needs locale data
1238      * &lt;li&gt;-4 = fall back to Western grouping if not in locale
1239      * &lt;/ul&gt;
1240      */
1241     int16_t fGrouping1;
1242     int16_t fGrouping2;
1243 
1244     /**
1245      * The minimum grouping size, with the following special values:
1246      * &lt;ul&gt;
1247      * &lt;li&gt;-2 = needs locale data
1248      * &lt;li&gt;-3 = no less than 2
1249      * &lt;/ul&gt;
1250      */
1251     int16_t fMinGrouping;
1252 
1253     /**
<span class="line-modified">1254      * The UGroupingStrategy that was used to create this Grouper, or UNUM_GROUPING_COUNT if this</span>
<span class="line-modified">1255      * was not created from a UGroupingStrategy.</span>
1256      */
<span class="line-modified">1257     UGroupingStrategy fStrategy;</span>
1258 
<span class="line-modified">1259     Grouper() : fGrouping1(-3) {};</span>
1260 
1261     bool isBogus() const {
1262         return fGrouping1 == -3;
1263     }
1264 
1265     /** NON-CONST: mutates the current instance. */
1266     void setLocaleData(const impl::ParsedPatternInfo &amp;patternInfo, const Locale&amp; locale);
1267 
1268     bool groupAtPosition(int32_t position, const impl::DecimalQuantity &amp;value) const;
1269 
1270     // To allow MacroProps/MicroProps to initialize empty instances:
1271     friend struct MacroProps;
1272     friend struct MicroProps;
1273 
1274     // To allow NumberFormatterImpl to access isBogus() and perform other operations:
1275     friend class NumberFormatterImpl;
1276 
1277     // To allow NumberParserImpl to perform setLocaleData():
1278     friend class ::icu::numparse::impl::NumberParserImpl;
1279 
</pre>
<hr />
<pre>
1384 
1385     /** @internal */
1386     UNumberSignDisplay sign = UNUM_SIGN_COUNT;
1387 
1388     /** @internal */
1389     UNumberDecimalSeparatorDisplay decimal = UNUM_DECIMAL_SEPARATOR_COUNT;
1390 
1391     /** @internal */
1392     Scale scale;  // = Scale();  (benign value)
1393 
1394     /** @internal */
1395     const AffixPatternProvider* affixProvider = nullptr;  // no ownership
1396 
1397     /** @internal */
1398     const PluralRules* rules = nullptr;  // no ownership
1399 
1400     /** @internal */
1401     const CurrencySymbols* currencySymbols = nullptr;  // no ownership
1402 
1403     /** @internal */
<span class="line-modified">1404     int32_t threshold = DEFAULT_THRESHOLD;</span>
1405 
1406     /** @internal */
1407     Locale locale;
1408 
1409     // NOTE: Uses default copy and move constructors.
1410 
1411     /**
1412      * Check all members for errors.
1413      * @internal
1414      */
1415     bool copyErrorTo(UErrorCode &amp;status) const {
1416         return notation.copyErrorTo(status) || precision.copyErrorTo(status) ||
1417                padder.copyErrorTo(status) || integerWidth.copyErrorTo(status) ||
1418                symbols.copyErrorTo(status) || scale.copyErrorTo(status);
1419     }
1420 };
1421 
1422 } // namespace impl
1423 
1424 /**
1425  * An abstract base class for specifying settings related to number formatting. This class is implemented by
<span class="line-modified">1426  * {@link UnlocalizedNumberFormatter} and {@link LocalizedNumberFormatter}.</span>

1427  */
1428 template&lt;typename Derived&gt;
1429 class U_I18N_API NumberFormatterSettings {
1430   public:
1431     /**
1432      * Specifies the notation style (simple, scientific, or compact) for rendering numbers.
1433      *
1434      * &lt;ul&gt;
1435      * &lt;li&gt;Simple notation: &quot;12,300&quot;
1436      * &lt;li&gt;Scientific notation: &quot;1.23E4&quot;
1437      * &lt;li&gt;Compact notation: &quot;12K&quot;
1438      * &lt;/ul&gt;
1439      *
1440      * &lt;p&gt;
1441      * All notation styles will be properly localized with locale data, and all notation styles are compatible with
1442      * units, rounding precisions, and other number formatter settings.
1443      *
1444      * &lt;p&gt;
1445      * Pass this method the return value of a {@link Notation} factory method. For example:
1446      *
</pre>
<hr />
<pre>
1464      * @param notation
1465      *            The notation strategy to use.
1466      * @return The fluent chain.
1467      * @see #notation
1468      * @draft ICU 62
1469      */
1470     Derived notation(const Notation &amp;notation) &amp;&amp;;
1471 
1472     /**
1473      * Specifies the unit (unit of measure, currency, or percent) to associate with rendered numbers.
1474      *
1475      * &lt;ul&gt;
1476      * &lt;li&gt;Unit of measure: &quot;12.3 meters&quot;
1477      * &lt;li&gt;Currency: &quot;$12.30&quot;
1478      * &lt;li&gt;Percent: &quot;12.3%&quot;
1479      * &lt;/ul&gt;
1480      *
1481      * All units will be properly localized with locale data, and all units are compatible with notation styles,
1482      * rounding precisions, and other number formatter settings.
1483      *
<span class="line-modified">1484      * Pass this method any instance of {@link MeasureUnit}. For units of measure (which often involve the</span>
<span class="line-removed">1485      * factory methods that return a pointer):</span>
1486      *
1487      * &lt;pre&gt;
<span class="line-modified">1488      * NumberFormatter::with().adoptUnit(MeasureUnit::createMeter(status))</span>
1489      * &lt;/pre&gt;
1490      *
1491      * Currency:
1492      *
1493      * &lt;pre&gt;
1494      * NumberFormatter::with().unit(CurrencyUnit(u&quot;USD&quot;, status))
1495      * &lt;/pre&gt;
1496      *
1497      * Percent:
1498      *
1499      * &lt;pre&gt;
1500      * NumberFormatter::with().unit(NoUnit.percent())
1501      * &lt;/pre&gt;
1502      *
1503      * See {@link #perUnit} for information on how to format strings like &quot;5 meters per second&quot;.
1504      *
1505      * The default is to render without units (equivalent to NoUnit.base()).
1506      *
1507      * @param unit
1508      *            The unit to render.
</pre>
<hr />
<pre>
1511      * @see Currency
1512      * @see NoUnit
1513      * @see #perUnit
1514      * @draft ICU 60
1515      */
1516     Derived unit(const icu::MeasureUnit &amp;unit) const &amp;;
1517 
1518     /**
1519      * Overload of unit() for use on an rvalue reference.
1520      *
1521      * @param unit
1522      *            The unit to render.
1523      * @return The fluent chain.
1524      * @see #unit
1525      * @draft ICU 62
1526      */
1527     Derived unit(const icu::MeasureUnit &amp;unit) &amp;&amp;;
1528 
1529     /**
1530      * Like unit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory
<span class="line-modified">1531      * methods, which return pointers that need ownership.  Example:</span>
1532      *
<span class="line-modified">1533      * &lt;pre&gt;</span>
<span class="line-removed">1534      * NumberFormatter::with().adoptUnit(MeasureUnit::createMeter(status))</span>
<span class="line-removed">1535      * &lt;/pre&gt;</span>
1536      *
1537      * @param unit
1538      *            The unit to render.
1539      * @return The fluent chain.
1540      * @see #unit
1541      * @see MeasureUnit
1542      * @draft ICU 60
1543      */
1544     Derived adoptUnit(icu::MeasureUnit *unit) const &amp;;
1545 
1546     /**
1547      * Overload of adoptUnit() for use on an rvalue reference.
1548      *
1549      * @param unit
1550      *            The unit to render.
1551      * @return The fluent chain.
1552      * @see #adoptUnit
1553      * @draft ICU 62
1554      */
1555     Derived adoptUnit(icu::MeasureUnit *unit) &amp;&amp;;
1556 
1557     /**
1558      * Sets a unit to be used in the denominator. For example, to format &quot;3 m/s&quot;, pass METER to the unit and SECOND to
1559      * the perUnit.
1560      *
<span class="line-modified">1561      * Pass this method any instance of {@link MeasureUnit}.  Since MeasureUnit factory methods return pointers, the</span>
<span class="line-modified">1562      * {@link #adoptPerUnit} version of this method is often more useful.</span>





1563      *
1564      * The default is not to display any unit in the denominator.
1565      *
1566      * If a per-unit is specified without a primary unit via {@link #unit}, the behavior is undefined.
1567      *
1568      * @param perUnit
1569      *            The unit to render in the denominator.
1570      * @return The fluent chain
1571      * @see #unit
1572      * @draft ICU 61
1573      */
1574     Derived perUnit(const icu::MeasureUnit &amp;perUnit) const &amp;;
1575 
1576     /**
1577      * Overload of perUnit() for use on an rvalue reference.
1578      *
1579      * @param perUnit
1580      *            The unit to render in the denominator.
1581      * @return The fluent chain.
1582      * @see #perUnit
1583      * @draft ICU 62
1584      */
1585     Derived perUnit(const icu::MeasureUnit &amp;perUnit) &amp;&amp;;
1586 
1587     /**
1588      * Like perUnit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory
<span class="line-modified">1589      * methods, which return pointers that need ownership.  Example:</span>
1590      *
<span class="line-modified">1591      * &lt;pre&gt;</span>
<span class="line-removed">1592      * NumberFormatter::with()</span>
<span class="line-removed">1593      *      .adoptUnit(MeasureUnit::createMeter(status))</span>
<span class="line-removed">1594      *      .adoptPerUnit(MeasureUnit::createSecond(status))</span>
<span class="line-removed">1595      * &lt;/pre&gt;</span>
1596      *
1597      * @param perUnit
1598      *            The unit to render in the denominator.
1599      * @return The fluent chain.
1600      * @see #perUnit
1601      * @see MeasureUnit
1602      * @draft ICU 61
1603      */
1604     Derived adoptPerUnit(icu::MeasureUnit *perUnit) const &amp;;
1605 
1606     /**
1607      * Overload of adoptPerUnit() for use on an rvalue reference.
1608      *
1609      * @param perUnit
1610      *            The unit to render in the denominator.
1611      * @return The fluent chain.
1612      * @see #adoptPerUnit
1613      * @draft ICU 62
1614      */
1615     Derived adoptPerUnit(icu::MeasureUnit *perUnit) &amp;&amp;;
</pre>
<hr />
<pre>
1640      *
1641      * @param precision
1642      *            The rounding precision to use.
1643      * @return The fluent chain.
1644      * @see Precision
1645      * @draft ICU 62
1646      */
1647     Derived precision(const Precision&amp; precision) const &amp;;
1648 
1649     /**
1650      * Overload of precision() for use on an rvalue reference.
1651      *
1652      * @param precision
1653      *            The rounding precision to use.
1654      * @return The fluent chain.
1655      * @see #precision
1656      * @draft ICU 62
1657      */
1658     Derived precision(const Precision&amp; precision) &amp;&amp;;
1659 
<span class="line-removed">1660 #ifndef U_HIDE_DEPRECATED_API</span>
<span class="line-removed">1661     // Compatibility method that will be removed in ICU 64.</span>
<span class="line-removed">1662     // Use precision() instead.</span>
<span class="line-removed">1663     // See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">1664     /** @deprecated ICU 62 */</span>
<span class="line-removed">1665     Derived rounding(const Rounder&amp; rounder) const &amp; {</span>
<span class="line-removed">1666         return precision(rounder);</span>
<span class="line-removed">1667     }</span>
<span class="line-removed">1668 #endif  /* U_HIDE_DEPRECATED_API */</span>
<span class="line-removed">1669 </span>
1670     /**
1671      * Specifies how to determine the direction to round a number when it has more digits than fit in the
1672      * desired precision.  When formatting 1.235:
1673      *
1674      * &lt;ul&gt;
1675      * &lt;li&gt;Ceiling rounding mode with integer precision: &quot;2&quot;
1676      * &lt;li&gt;Half-down rounding mode with 2 fixed fraction digits: &quot;1.23&quot;
1677      * &lt;li&gt;Half-up rounding mode with 2 fixed fraction digits: &quot;1.24&quot;
1678      * &lt;/ul&gt;
1679      *
1680      * The default is HALF_EVEN. For more information on rounding mode, see the ICU userguide here:
1681      *
1682      * http://userguide.icu-project.org/formatparse/numbers/rounding-modes
1683      *
1684      * @param roundingMode The rounding mode to use.
1685      * @return The fluent chain.
1686      * @draft ICU 62
1687      */
1688     Derived roundingMode(UNumberFormatRoundingMode roundingMode) const &amp;;
1689 
</pre>
<hr />
<pre>
1693      * @param roundingMode The rounding mode to use.
1694      * @return The fluent chain.
1695      * @see #roundingMode
1696      * @draft ICU 62
1697      */
1698     Derived roundingMode(UNumberFormatRoundingMode roundingMode) &amp;&amp;;
1699 
1700     /**
1701      * Specifies the grouping strategy to use when formatting numbers.
1702      *
1703      * &lt;ul&gt;
1704      * &lt;li&gt;Default grouping: &quot;12,300&quot; and &quot;1,230&quot;
1705      * &lt;li&gt;Grouping with at least 2 digits: &quot;12,300&quot; and &quot;1230&quot;
1706      * &lt;li&gt;No grouping: &quot;12300&quot; and &quot;1230&quot;
1707      * &lt;/ul&gt;
1708      *
1709      * &lt;p&gt;
1710      * The exact grouping widths will be chosen based on the locale.
1711      *
1712      * &lt;p&gt;
<span class="line-modified">1713      * Pass this method an element from the {@link UGroupingStrategy} enum. For example:</span>
1714      *
1715      * &lt;pre&gt;
1716      * NumberFormatter::with().grouping(UNUM_GROUPING_MIN2)
1717      * &lt;/pre&gt;
1718      *
1719      * The default is to perform grouping according to locale data; most locales, but not all locales,
1720      * enable it by default.
1721      *
1722      * @param strategy
1723      *            The grouping strategy to use.
1724      * @return The fluent chain.
1725      * @draft ICU 61
1726      */
<span class="line-modified">1727     Derived grouping(UGroupingStrategy strategy) const &amp;;</span>
1728 
1729     /**
1730      * Overload of grouping() for use on an rvalue reference.
1731      *
1732      * @param strategy
1733      *            The grouping strategy to use.
1734      * @return The fluent chain.
1735      * @see #grouping
<span class="line-removed">1736      * @provisional This API might change or be removed in a future release.</span>
1737      * @draft ICU 62
1738      */
<span class="line-modified">1739     Derived grouping(UGroupingStrategy strategy) &amp;&amp;;</span>
1740 
1741     /**
1742      * Specifies the minimum and maximum number of digits to render before the decimal mark.
1743      *
1744      * &lt;ul&gt;
1745      * &lt;li&gt;Zero minimum integer digits: &quot;.08&quot;
1746      * &lt;li&gt;One minimum integer digit: &quot;0.08&quot;
1747      * &lt;li&gt;Two minimum integer digits: &quot;00.08&quot;
1748      * &lt;/ul&gt;
1749      *
1750      * &lt;p&gt;
<span class="line-modified">1751      * Pass this method the return value of {@link IntegerWidth#zeroFillTo(int)}. For example:</span>
1752      *
1753      * &lt;pre&gt;
1754      * NumberFormatter::with().integerWidth(IntegerWidth::zeroFillTo(2))
1755      * &lt;/pre&gt;
1756      *
1757      * The default is to have one minimum integer digit.
1758      *
1759      * @param style
1760      *            The integer width to use.
1761      * @return The fluent chain.
1762      * @see IntegerWidth
1763      * @draft ICU 60
1764      */
1765     Derived integerWidth(const IntegerWidth &amp;style) const &amp;;
1766 
1767     /**
1768      * Overload of integerWidth() for use on an rvalue reference.
1769      *
1770      * @param style
1771      *            The integer width to use.
</pre>
<hr />
<pre>
2065     Derived macros(impl::MacroProps&amp;&amp; macros) &amp;&amp;;
2066 
2067 #endif  /* U_HIDE_INTERNAL_API */
2068 
2069     /**
2070      * Creates a skeleton string representation of this number formatter. A skeleton string is a
2071      * locale-agnostic serialized form of a number formatter.
2072      *
2073      * Not all options are capable of being represented in the skeleton string; for example, a
2074      * DecimalFormatSymbols object. If any such option is encountered, the error code is set to
2075      * U_UNSUPPORTED_ERROR.
2076      *
2077      * The returned skeleton is in normalized form, such that two number formatters with equivalent
2078      * behavior should produce the same skeleton.
2079      *
2080      * @return A number skeleton string with behavior corresponding to this number formatter.
2081      * @draft ICU 62
2082      */
2083     UnicodeString toSkeleton(UErrorCode&amp; status) const;
2084 






















2085     /**
2086      * Sets the UErrorCode if an error occurred in the fluent chain.
2087      * Preserves older error codes in the outErrorCode.
2088      * @return TRUE if U_FAILURE(outErrorCode)
2089      * @draft ICU 60
2090      */
2091     UBool copyErrorTo(UErrorCode &amp;outErrorCode) const {
2092         if (U_FAILURE(outErrorCode)) {
2093             // Do not overwrite the older error code
2094             return TRUE;
2095         }
2096         fMacros.copyErrorTo(outErrorCode);
2097         return U_FAILURE(outErrorCode);
<span class="line-modified">2098     };</span>
2099 
2100     // NOTE: Uses default copy and move constructors.
2101 
<span class="line-modified">2102   protected:</span>
2103     impl::MacroProps fMacros;
2104 
<span class="line-removed">2105   private:</span>
2106     // Don&#39;t construct me directly!  Use (Un)LocalizedNumberFormatter.
2107     NumberFormatterSettings() = default;
2108 
2109     friend class LocalizedNumberFormatter;
2110     friend class UnlocalizedNumberFormatter;




2111 };
2112 
2113 /**
2114  * A NumberFormatter that does not yet have a locale. In order to format numbers, a locale must be specified.
2115  *


2116  * @see NumberFormatter
2117  * @draft ICU 60
2118  */
2119 class U_I18N_API UnlocalizedNumberFormatter
2120         : public NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;, public UMemory {
2121 
2122   public:
2123     /**
2124      * Associate the given locale with the number formatter. The locale is used for picking the appropriate symbols,
2125      * formats, and other data for number display.
2126      *
<span class="line-removed">2127      * &lt;p&gt;</span>
<span class="line-removed">2128      * To use the Java default locale, call Locale::getDefault():</span>
<span class="line-removed">2129      *</span>
<span class="line-removed">2130      * &lt;pre&gt;</span>
<span class="line-removed">2131      * NumberFormatter::with(). ... .locale(Locale::getDefault())</span>
<span class="line-removed">2132      * &lt;/pre&gt;</span>
<span class="line-removed">2133      *</span>
2134      * @param locale
2135      *            The locale to use when loading data for number formatting.
2136      * @return The fluent chain.
2137      * @draft ICU 60
2138      */
2139     LocalizedNumberFormatter locale(const icu::Locale &amp;locale) const &amp;;
2140 
2141     /**
2142      * Overload of locale() for use on an rvalue reference.
2143      *
2144      * @param locale
2145      *            The locale to use when loading data for number formatting.
2146      * @return The fluent chain.
2147      * @see #locale
2148      * @draft ICU 62
2149      */
2150     LocalizedNumberFormatter locale(const icu::Locale &amp;locale) &amp;&amp;;
2151 
2152     /**
2153      * Default constructor: puts the formatter into a valid but undefined state.
<span class="line-removed">2159     // Make default copy constructor call the NumberFormatterSettings copy constructor.</span>
2160     /**
2161      * Returns a copy of this UnlocalizedNumberFormatter.
2162      * @draft ICU 60
2163      */
2164     UnlocalizedNumberFormatter(const UnlocalizedNumberFormatter &amp;other);
2165 
2166     /**
2167      * Move constructor:
2168      * The source UnlocalizedNumberFormatter will be left in a valid but undefined state.
2169      * @draft ICU 62
2170      */
2171     UnlocalizedNumberFormatter(UnlocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2172 
2173     /**
2174      * Copy assignment operator.
2175      * @draft ICU 62
2176      */
2177     UnlocalizedNumberFormatter&amp; operator=(const UnlocalizedNumberFormatter&amp; other);
2178 
2179     /**
</pre>
<hr />
<pre>
2182      * @draft ICU 62
2183      */
2184     UnlocalizedNumberFormatter&amp; operator=(UnlocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2185 
2186   private:
2187     explicit UnlocalizedNumberFormatter(const NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;&amp; other);
2188 
2189     explicit UnlocalizedNumberFormatter(
2190             NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;&amp;&amp; src) U_NOEXCEPT;
2191 
2192     // To give the fluent setters access to this class&#39;s constructor:
2193     friend class NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;;
2194 
2195     // To give NumberFormatter::with() access to this class&#39;s constructor:
2196     friend class NumberFormatter;
2197 };
2198 
2199 /**
2200  * A NumberFormatter that has a locale associated with it; this means .format() methods are available.
2201  *


2202  * @see NumberFormatter
2203  * @draft ICU 60
2204  */
2205 class U_I18N_API LocalizedNumberFormatter
2206         : public NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;, public UMemory {
2207   public:
2208     /**
2209      * Format the given integer number to a string using the settings specified in the NumberFormatter fluent
2210      * setting chain.
2211      *
2212      * @param value
2213      *            The number to format.
2214      * @param status
2215      *            Set to an ErrorCode if one occurred in the setter chain or during formatting.
2216      * @return A FormattedNumber object; call .toString() to get the string.
2217      * @draft ICU 60
2218      */
2219     FormattedNumber formatInt(int64_t value, UErrorCode &amp;status) const;
2220 
2221     /**
</pre>
<hr />
<pre>
2254      */
2255     FormattedNumber formatDecimalQuantity(const impl::DecimalQuantity&amp; dq, UErrorCode&amp; status) const;
2256 
2257     /** Internal method for DecimalFormat compatibility.
2258      * @internal
2259      */
2260     void getAffixImpl(bool isPrefix, bool isNegative, UnicodeString&amp; result, UErrorCode&amp; status) const;
2261 
2262     /**
2263      * Internal method for testing.
2264      * @internal
2265      */
2266     const impl::NumberFormatterImpl* getCompiled() const;
2267 
2268     /**
2269      * Internal method for testing.
2270      * @internal
2271      */
2272     int32_t getCallCount() const;
2273 
<span class="line-modified">2274 #endif</span>
2275 
2276     /**
2277      * Creates a representation of this LocalizedNumberFormat as an icu::Format, enabling the use
2278      * of this number formatter with APIs that need an object of that type, such as MessageFormat.
2279      *
2280      * This API is not intended to be used other than for enabling API compatibility. The formatDouble,
2281      * formatInt, and formatDecimal methods should normally be used when formatting numbers, not the Format
2282      * object returned by this method.
2283      *
2284      * The caller owns the returned object and must delete it when finished.
2285      *
2286      * @return A Format wrapping this LocalizedNumberFormatter.
2287      * @draft ICU 62
2288      */
2289     Format* toFormat(UErrorCode&amp; status) const;
2290 
2291     /**
2292      * Default constructor: puts the formatter into a valid but undefined state.
2293      *
2294      * @draft ICU 62
2295      */
2296     LocalizedNumberFormatter() = default;
2297 
<span class="line-removed">2298     // Make default copy constructor call the NumberFormatterSettings copy constructor.</span>
2299     /**
2300      * Returns a copy of this LocalizedNumberFormatter.
2301      * @draft ICU 60
2302      */
2303     LocalizedNumberFormatter(const LocalizedNumberFormatter &amp;other);
2304 
2305     /**
2306      * Move constructor:
2307      * The source LocalizedNumberFormatter will be left in a valid but undefined state.
2308      * @draft ICU 62
2309      */
2310     LocalizedNumberFormatter(LocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2311 
2312     /**
2313      * Copy assignment operator.
2314      * @draft ICU 62
2315      */
2316     LocalizedNumberFormatter&amp; operator=(const LocalizedNumberFormatter&amp; other);
2317 
2318     /**
2319      * Move assignment operator:
2320      * The source LocalizedNumberFormatter will be left in a valid but undefined state.
2321      * @draft ICU 62
2322      */
2323     LocalizedNumberFormatter&amp; operator=(LocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2324 
2325 #ifndef U_HIDE_INTERNAL_API
2326 
2327     /**
2328      * This is the core entrypoint to the number formatting pipeline. It performs self-regulation: a static code path
2329      * for the first few calls, and compiling a more efficient data structure if called repeatedly.
2330      *
2331      * &lt;p&gt;
2332      * This function is very hot, being called in every call to the number formatting pipeline.
2333      *
2334      * @param results
2335      *            The results object. This method will mutate it to save the results.

2336      * @internal
2337      */
2338     void formatImpl(impl::UFormattedNumberData *results, UErrorCode &amp;status) const;
2339 
<span class="line-modified">2340 #endif</span>
2341 
2342     /**
2343      * Destruct this LocalizedNumberFormatter, cleaning up any memory it might own.
2344      * @draft ICU 60
2345      */
2346     ~LocalizedNumberFormatter();
2347 
2348   private:
2349     // Note: fCompiled can&#39;t be a LocalPointer because impl::NumberFormatterImpl is defined in an internal
2350     // header, and LocalPointer needs the full class definition in order to delete the instance.
2351     const impl::NumberFormatterImpl* fCompiled {nullptr};
2352     char fUnsafeCallCount[8] {};  // internally cast to u_atomic_int32_t
2353 
2354     explicit LocalizedNumberFormatter(const NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;&amp; other);
2355 
2356     explicit LocalizedNumberFormatter(NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;&amp;&amp; src) U_NOEXCEPT;
2357 
2358     LocalizedNumberFormatter(const impl::MacroProps &amp;macros, const Locale &amp;locale);
2359 
2360     LocalizedNumberFormatter(impl::MacroProps &amp;&amp;macros, const Locale &amp;locale);
2361 


2362     void lnfMoveHelper(LocalizedNumberFormatter&amp;&amp; src);
2363 
2364     /**
2365      * @return true if the compiled formatter is available.
2366      */
2367     bool computeCompiled(UErrorCode&amp; status) const;
2368 
2369     // To give the fluent setters access to this class&#39;s constructor:
2370     friend class NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;;
2371     friend class NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;;
2372 
2373     // To give UnlocalizedNumberFormatter::locale() access to this class&#39;s constructor:
2374     friend class UnlocalizedNumberFormatter;
2375 };
2376 
2377 /**
2378  * The result of a number formatting operation. This class allows the result to be exported in several data types,
2379  * including a UnicodeString and a FieldPositionIterator.
2380  *


2381  * @draft ICU 60
2382  */
<span class="line-modified">2383 class U_I18N_API FormattedNumber : public UMemory {</span>
2384   public:
<span class="line-modified">2385 #ifndef U_HIDE_DEPRECATED_API</span>
2386     /**
<span class="line-modified">2387      * Returns a UnicodeString representation of the formatted number.</span>
<span class="line-modified">2388      *</span>
<span class="line-removed">2389      * @return a UnicodeString containing the localized number.</span>
<span class="line-removed">2390      * @deprecated ICU 62 Use the version of this method with an error code instead.</span>
<span class="line-removed">2391      *                This method was never @stable and will be removed in a future release.</span>
<span class="line-removed">2392      *                See http://bugs.icu-project.org/trac/ticket/13746</span>
2393      */
<span class="line-modified">2394     UnicodeString toString() const;</span>
<span class="line-modified">2395 #endif  /* U_HIDE_DEPRECATED_API */</span>
2396 
2397     /**
<span class="line-modified">2398      * Returns a UnicodeString representation of the formatted number.</span>
<span class="line-removed">2399      *</span>
<span class="line-removed">2400      * @param status</span>
<span class="line-removed">2401      *            Set if an error occurs while formatting the number to the UnicodeString.</span>
<span class="line-removed">2402      * @return a UnicodeString containing the localized number.</span>
2403      * @draft ICU 62
2404      */
<span class="line-modified">2405     UnicodeString toString(UErrorCode&amp; status) const;</span>












2406 
<span class="line-removed">2407 #ifndef U_HIDE_DEPRECATED_API</span>
2408     /**
<span class="line-modified">2409      * Appends the formatted number to an Appendable.</span>
<span class="line-modified">2410      *</span>
<span class="line-removed">2411      * @param appendable</span>
<span class="line-removed">2412      *            The Appendable to which to append the formatted number string.</span>
<span class="line-removed">2413      * @return The same Appendable, for chaining.</span>
<span class="line-removed">2414      * @deprecated ICU 62 Use the version of this method with an error code instead.</span>
<span class="line-removed">2415      *                This method was never @stable and will be removed in a future release.</span>
<span class="line-removed">2416      *                See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">2417      * @see Appendable</span>
2418      */
<span class="line-modified">2419     Appendable &amp;appendTo(Appendable &amp;appendable);</span>
<span class="line-removed">2420 #endif  /* U_HIDE_DEPRECATED_API */</span>
2421 

2422     /**
<span class="line-modified">2423      * Appends the formatted number to an Appendable.</span>


2424      *
<span class="line-removed">2425      * @param appendable</span>
<span class="line-removed">2426      *            The Appendable to which to append the formatted number string.</span>
<span class="line-removed">2427      * @param status</span>
<span class="line-removed">2428      *            Set if an error occurs while formatting the number to the Appendable.</span>
<span class="line-removed">2429      * @return The same Appendable, for chaining.</span>
2430      * @draft ICU 62
<span class="line-removed">2431      * @see Appendable</span>
2432      */
<span class="line-modified">2433     Appendable &amp;appendTo(Appendable &amp;appendable, UErrorCode&amp; status);</span>
2434 
<span class="line-modified">2435 #ifndef U_HIDE_DEPRECATED_API</span>




2436     /**
<span class="line-modified">2437      * Determine the start and end indices of the first occurrence of the given &lt;em&gt;field&lt;/em&gt; in the output string.</span>
<span class="line-removed">2438      * This allows you to determine the locations of the integer part, fraction part, and sign.</span>
2439      *
<span class="line-modified">2440      * &lt;p&gt;</span>
<span class="line-removed">2441      * If multiple different field attributes are needed, this method can be called repeatedly, or if &lt;em&gt;all&lt;/em&gt; field</span>
<span class="line-removed">2442      * attributes are needed, consider using populateFieldPositionIterator().</span>
2443      *
<span class="line-modified">2444      * &lt;p&gt;</span>
<span class="line-removed">2445      * If a field occurs multiple times in an output string, such as a grouping separator, this method will only ever</span>
<span class="line-removed">2446      * return the first occurrence. Use populateFieldPositionIterator() to access all occurrences of an attribute.</span>
<span class="line-removed">2447      *</span>
<span class="line-removed">2448      * @param fieldPosition</span>
<span class="line-removed">2449      *            The FieldPosition to populate with the start and end indices of the desired field.</span>
<span class="line-removed">2450      * @param status</span>
<span class="line-removed">2451      *            Set if an error occurs while populating the FieldPosition.</span>
<span class="line-removed">2452      * @deprecated ICU 62 Use {@link #nextFieldPosition} instead. This method will be removed in a future</span>
<span class="line-removed">2453      *             release. See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">2454      * @see UNumberFormatFields</span>
2455      */
<span class="line-modified">2456     void populateFieldPosition(FieldPosition &amp;fieldPosition, UErrorCode &amp;status);</span>
<span class="line-modified">2457 #endif  /* U_HIDE_DEPRECATED_API */</span>



2458 
2459     /**
<span class="line-modified">2460      * Determines the start and end indices of the next occurrence of the given &lt;em&gt;field&lt;/em&gt; in the</span>
<span class="line-modified">2461      * output string. This allows you to determine the locations of, for example, the integer part,</span>
<span class="line-modified">2462      * fraction part, or symbols.</span>


2463      *
2464      * If a field occurs just once, calling this method will find that occurrence and return it. If a
2465      * field occurs multiple times, this method may be called repeatedly with the following pattern:
2466      *
2467      * &lt;pre&gt;
2468      * FieldPosition fpos(UNUM_GROUPING_SEPARATOR_FIELD);
2469      * while (formattedNumber.nextFieldPosition(fpos, status)) {
2470      *   // do something with fpos.
2471      * }
2472      * &lt;/pre&gt;
2473      *
2474      * This method is useful if you know which field to query. If you want all available field position
<span class="line-modified">2475      * information, use #getAllFieldPositions().</span>
2476      *
2477      * @param fieldPosition
2478      *            Input+output variable. On input, the &quot;field&quot; property determines which field to look
2479      *            up, and the &quot;beginIndex&quot; and &quot;endIndex&quot; properties determine where to begin the search.
2480      *            On output, the &quot;beginIndex&quot; is set to the beginning of the first occurrence of the
<span class="line-modified">2481      *            field with either begin or end indices after the input indices, &quot;endIndex&quot; is set to</span>
2482      *            the end of that occurrence of the field (exclusive index). If a field position is not
2483      *            found, the method returns FALSE and the FieldPosition may or may not be changed.
2484      * @param status
2485      *            Set if an error occurs while populating the FieldPosition.
2486      * @return TRUE if a new occurrence of the field was found; FALSE otherwise.
2487      * @draft ICU 62
2488      * @see UNumberFormatFields
2489      */
2490     UBool nextFieldPosition(FieldPosition&amp; fieldPosition, UErrorCode&amp; status) const;
2491 
<span class="line-removed">2492 #ifndef U_HIDE_DEPRECATED_API</span>
2493     /**
2494      * Export the formatted number to a FieldPositionIterator. This allows you to determine which characters in
2495      * the output string correspond to which &lt;em&gt;fields&lt;/em&gt;, such as the integer part, fraction part, and sign.
2496      *
<span class="line-modified">2497      * &lt;p&gt;</span>
<span class="line-removed">2498      * If information on only one field is needed, consider using populateFieldPosition() instead.</span>
<span class="line-removed">2499      *</span>
<span class="line-removed">2500      * @param iterator</span>
<span class="line-removed">2501      *            The FieldPositionIterator to populate with all of the fields present in the formatted number.</span>
<span class="line-removed">2502      * @param status</span>
<span class="line-removed">2503      *            Set if an error occurs while populating the FieldPositionIterator.</span>
<span class="line-removed">2504      * @deprecated ICU 62 Use {@link #getAllFieldPositions} instead. This method will be removed in a</span>
<span class="line-removed">2505      *             future release. See http://bugs.icu-project.org/trac/ticket/13746</span>
<span class="line-removed">2506      * @see UNumberFormatFields</span>
<span class="line-removed">2507      */</span>
<span class="line-removed">2508     void populateFieldPositionIterator(FieldPositionIterator &amp;iterator, UErrorCode &amp;status);</span>
<span class="line-removed">2509 #endif  /* U_HIDE_DEPRECATED_API */</span>
<span class="line-removed">2510 </span>
<span class="line-removed">2511     /**</span>
<span class="line-removed">2512      * Export the formatted number to a FieldPositionIterator. This allows you to determine which characters in</span>
<span class="line-removed">2513      * the output string correspond to which &lt;em&gt;fields&lt;/em&gt;, such as the integer part, fraction part, and sign.</span>
2514      *
<span class="line-modified">2515      * If information on only one field is needed, use #nextFieldPosition() instead.</span>
2516      *
2517      * @param iterator
2518      *            The FieldPositionIterator to populate with all of the fields present in the formatted number.
2519      * @param status
2520      *            Set if an error occurs while populating the FieldPositionIterator.
2521      * @draft ICU 62
2522      * @see UNumberFormatFields
2523      */
2524     void getAllFieldPositions(FieldPositionIterator &amp;iterator, UErrorCode &amp;status) const;
2525 
2526 #ifndef U_HIDE_INTERNAL_API
2527 
2528     /**
2529      *  Gets the raw DecimalQuantity for plural rule selection.
2530      *  @internal
2531      */
2532     void getDecimalQuantity(impl::DecimalQuantity&amp; output, UErrorCode&amp; status) const;
2533 
2534     /**
2535      * Populates the mutable builder type FieldPositionIteratorHandler.
2536      * @internal
2537      */
2538     void getAllFieldPositionsImpl(FieldPositionIteratorHandler&amp; fpih, UErrorCode&amp; status) const;
2539 
<span class="line-modified">2540 #endif</span>
<span class="line-removed">2541 </span>
<span class="line-removed">2542     /**</span>
<span class="line-removed">2543      * Copying not supported; use move constructor instead.</span>
<span class="line-removed">2544      */</span>
<span class="line-removed">2545     FormattedNumber(const FormattedNumber&amp;) = delete;</span>
<span class="line-removed">2546 </span>
<span class="line-removed">2547     /**</span>
<span class="line-removed">2548      * Copying not supported; use move assignment instead.</span>
<span class="line-removed">2549      */</span>
<span class="line-removed">2550     FormattedNumber&amp; operator=(const FormattedNumber&amp;) = delete;</span>
<span class="line-removed">2551 </span>
<span class="line-removed">2552     /**</span>
<span class="line-removed">2553      * Move constructor:</span>
<span class="line-removed">2554      * Leaves the source FormattedNumber in an undefined state.</span>
<span class="line-removed">2555      * @draft ICU 62</span>
<span class="line-removed">2556      */</span>
<span class="line-removed">2557     FormattedNumber(FormattedNumber&amp;&amp; src) U_NOEXCEPT;</span>
<span class="line-removed">2558 </span>
<span class="line-removed">2559     /**</span>
<span class="line-removed">2560      * Move assignment:</span>
<span class="line-removed">2561      * Leaves the source FormattedNumber in an undefined state.</span>
<span class="line-removed">2562      * @draft ICU 62</span>
<span class="line-removed">2563      */</span>
<span class="line-removed">2564     FormattedNumber&amp; operator=(FormattedNumber&amp;&amp; src) U_NOEXCEPT;</span>
<span class="line-removed">2565 </span>
<span class="line-removed">2566     /**</span>
<span class="line-removed">2567      * Destruct an instance of FormattedNumber, cleaning up any memory it might own.</span>
<span class="line-removed">2568      * @draft ICU 60</span>
<span class="line-removed">2569      */</span>
<span class="line-removed">2570     ~FormattedNumber();</span>
2571 
2572   private:
2573     // Can&#39;t use LocalPointer because UFormattedNumberData is forward-declared
<span class="line-modified">2574     const impl::UFormattedNumberData *fResults;</span>
2575 
2576     // Error code for the terminal methods
2577     UErrorCode fErrorCode;
2578 
2579     /**
2580      * Internal constructor from data type. Adopts the data pointer.
2581      * @internal
2582      */
2583     explicit FormattedNumber(impl::UFormattedNumberData *results)
<span class="line-modified">2584         : fResults(results), fErrorCode(U_ZERO_ERROR) {};</span>
2585 
2586     explicit FormattedNumber(UErrorCode errorCode)
<span class="line-modified">2587         : fResults(nullptr), fErrorCode(errorCode) {};</span>
2588 
2589     // To give LocalizedNumberFormatter format methods access to this class&#39;s constructor:
2590     friend class LocalizedNumberFormatter;



2591 };
2592 
2593 /**
2594  * See the main description in numberformatter.h for documentation and examples.
2595  *
2596  * @draft ICU 60
2597  */
2598 class U_I18N_API NumberFormatter final {
2599   public:
2600     /**
2601      * Call this method at the beginning of a NumberFormatter fluent chain in which the locale is not currently known at
2602      * the call site.
2603      *
2604      * @return An {@link UnlocalizedNumberFormatter}, to be used for chaining.
2605      * @draft ICU 60
2606      */
2607     static UnlocalizedNumberFormatter with();
2608 
2609     /**
2610      * Call this method at the beginning of a NumberFormatter fluent chain in which the locale is known at the call



2624      * @param skeleton
2625      *            The skeleton string off of which to base this NumberFormatter.
2626      * @param status
2627      *            Set to U_NUMBER_SKELETON_SYNTAX_ERROR if the skeleton was invalid.
2628      * @return An UnlocalizedNumberFormatter, to be used for chaining.
2629      * @draft ICU 62
2630      */
2631     static UnlocalizedNumberFormatter forSkeleton(const UnicodeString&amp; skeleton, UErrorCode&amp; status);
2632 




















2633     /**
2634      * Use factory methods instead of the constructor to create a NumberFormatter.
2635      */
2636     NumberFormatter() = delete;
2637 };
2638 
2639 }  // namespace number
2640 U_NAMESPACE_END
2641 
2642 #endif  // U_HIDE_DRAFT_API
2643 
2644 #endif // __NUMBERFORMATTER_H__
2645 
2646 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
<td>
<hr />
<pre>
   1 // © 2017 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 
   4 #include &quot;unicode/utypes.h&quot;
   5 
   6 #if !UCONFIG_NO_FORMATTING
   7 #ifndef __NUMBERFORMATTER_H__
   8 #define __NUMBERFORMATTER_H__
   9 
  10 #include &quot;unicode/appendable.h&quot;
  11 #include &quot;unicode/dcfmtsym.h&quot;
  12 #include &quot;unicode/currunit.h&quot;
  13 #include &quot;unicode/fieldpos.h&quot;
<span class="line-added">  14 #include &quot;unicode/formattedvalue.h&quot;</span>
  15 #include &quot;unicode/fpositer.h&quot;
  16 #include &quot;unicode/measunit.h&quot;
  17 #include &quot;unicode/nounit.h&quot;
<span class="line-added">  18 #include &quot;unicode/parseerr.h&quot;</span>
  19 #include &quot;unicode/plurrule.h&quot;
  20 #include &quot;unicode/ucurr.h&quot;
  21 #include &quot;unicode/unum.h&quot;
  22 #include &quot;unicode/unumberformatter.h&quot;
  23 #include &quot;unicode/uobject.h&quot;
  24 
  25 #ifndef U_HIDE_DRAFT_API
  26 
  27 /**
  28  * \file
  29  * \brief C++ API: Library for localized number formatting introduced in ICU 60.
  30  *
  31  * This library was introduced in ICU 60 to simplify the process of formatting localized number strings.
  32  * Basic usage examples:
  33  *
  34  * &lt;pre&gt;
  35  * // Most basic usage:
  36  * NumberFormatter::withLocale(...).format(123).toString();  // 1,234 in en-US
  37  *
  38  * // Custom notation, unit, and rounding precision:
  39  * NumberFormatter::with()
  40  *     .notation(Notation::compactShort())
  41  *     .unit(CurrencyUnit(&quot;EUR&quot;, status))
  42  *     .precision(Precision::maxDigits(2))
  43  *     .locale(...)
  44  *     .format(1234)
  45  *     .toString();  // €1.2K in en-US
  46  *
<span class="line-modified">  47  * // Create a formatter in a singleton by value for use later:</span>
  48  * static const LocalizedNumberFormatter formatter = NumberFormatter::withLocale(...)
  49  *     .unit(NoUnit::percent())
  50  *     .precision(Precision::fixedFraction(3));
  51  * formatter.format(5.9831).toString();  // 5.983% in en-US
  52  *
<span class="line-modified">  53  * // Create a &quot;template&quot; in a singleton unique_ptr but without setting a locale until the call site:</span>
<span class="line-modified">  54  * std::unique_ptr&lt;UnlocalizedNumberFormatter&gt; template = NumberFormatter::with()</span>
  55  *     .sign(UNumberSignDisplay::UNUM_SIGN_ALWAYS)
<span class="line-modified">  56  *     .unit(MeasureUnit::getMeter())</span>
<span class="line-modified">  57  *     .unitWidth(UNumberUnitWidth::UNUM_UNIT_WIDTH_FULL_NAME)</span>
<span class="line-modified">  58  *     .clone();</span>
<span class="line-added">  59  * template-&gt;locale(...).format(1234).toString();  // +1,234 meters in en-US</span>
  60  * &lt;/pre&gt;
  61  *
  62  * &lt;p&gt;
  63  * This API offers more features than DecimalFormat and is geared toward new users of ICU.
  64  *
  65  * &lt;p&gt;
<span class="line-modified">  66  * NumberFormatter instances (i.e., LocalizedNumberFormatter and UnlocalizedNumberFormatter)</span>
<span class="line-added">  67  * are immutable and thread safe. This means that invoking a configuration method has no</span>
  68  * effect on the receiving instance; you must store and use the new number formatter instance it returns instead.
  69  *
  70  * &lt;pre&gt;
  71  * UnlocalizedNumberFormatter formatter = UnlocalizedNumberFormatter::with().notation(Notation::scientific());
  72  * formatter.precision(Precision.maxFraction(2)); // does nothing!
  73  * formatter.locale(Locale.getEnglish()).format(9.8765).toString(); // prints &quot;9.8765E0&quot;, not &quot;9.88E0&quot;
  74  * &lt;/pre&gt;
  75  *
  76  * &lt;p&gt;
  77  * This API is based on the &lt;em&gt;fluent&lt;/em&gt; design pattern popularized by libraries such as Google&#39;s Guava. For
  78  * extensive details on the design of this API, read &lt;a href=&quot;https://goo.gl/szi5VB&quot;&gt;the design doc&lt;/a&gt;.
  79  *
  80  * @author Shane Carr
  81  */
  82 
  83 U_NAMESPACE_BEGIN
  84 
  85 // Forward declarations:
  86 class IFixedDecimal;
  87 class FieldPositionIteratorHandler;
</pre>
<hr />
<pre>
  95 
  96 }
  97 }
  98 
  99 namespace number {  // icu::number
 100 
 101 // Forward declarations:
 102 class UnlocalizedNumberFormatter;
 103 class LocalizedNumberFormatter;
 104 class FormattedNumber;
 105 class Notation;
 106 class ScientificNotation;
 107 class Precision;
 108 class FractionPrecision;
 109 class CurrencyPrecision;
 110 class IncrementPrecision;
 111 class IntegerWidth;
 112 
 113 namespace impl {
 114 
<span class="line-added"> 115 // can&#39;t be #ifndef U_HIDE_INTERNAL_API; referenced throughout this file in public classes</span>
 116 /**
 117  * Datatype for minimum/maximum fraction digits. Must be able to hold kMaxIntFracSig.
 118  *
 119  * @internal
 120  */
 121 typedef int16_t digits_t;
 122 
<span class="line-added"> 123 // can&#39;t be #ifndef U_HIDE_INTERNAL_API; needed for struct initialization</span>
 124 /**
 125  * Use a default threshold of 3. This means that the third time .format() is called, the data structures get built
 126  * using the &quot;safe&quot; code path. The first two calls to .format() will trigger the unsafe code path.
 127  *
 128  * @internal
 129  */
<span class="line-modified"> 130 static constexpr int32_t kInternalDefaultThreshold = 3;</span>
 131 
 132 // Forward declarations:
 133 class Padder;
 134 struct MacroProps;
 135 struct MicroProps;
 136 class DecimalQuantity;
<span class="line-modified"> 137 class UFormattedNumberData;</span>
 138 class NumberFormatterImpl;
 139 struct ParsedPatternInfo;
 140 class ScientificModifier;
 141 class MultiplierProducer;
 142 class RoundingImpl;
 143 class ScientificHandler;
 144 class Modifier;
 145 class NumberStringBuilder;
 146 class AffixPatternProvider;
 147 class NumberPropertyMapper;
 148 struct DecimalFormatProperties;
 149 class MultiplierFormatHandler;
 150 class CurrencySymbols;
 151 class GeneratorHelpers;
 152 class DecNum;
<span class="line-added"> 153 class NumberRangeFormatterImpl;</span>
<span class="line-added"> 154 struct RangeMacroProps;</span>
<span class="line-added"> 155 struct UFormattedNumberImpl;</span>
<span class="line-added"> 156 </span>
<span class="line-added"> 157 /**</span>
<span class="line-added"> 158  * Used for NumberRangeFormatter and implemented in numrange_fluent.cpp.</span>
<span class="line-added"> 159  * Declared here so it can be friended.</span>
<span class="line-added"> 160  *</span>
<span class="line-added"> 161  * @internal</span>
<span class="line-added"> 162  */</span>
<span class="line-added"> 163 void touchRangeLocales(impl::RangeMacroProps&amp; macros);</span>
 164 
 165 } // namespace impl
 166 
<span class="line-modified"> 167 /**</span>
<span class="line-added"> 168  * Extra name reserved in case it is needed in the future.</span>
<span class="line-added"> 169  *</span>
<span class="line-added"> 170  * @draft ICU 63</span>
<span class="line-added"> 171  */</span>
 172 typedef Notation CompactNotation;
<span class="line-added"> 173 </span>
<span class="line-added"> 174 /**</span>
<span class="line-added"> 175  * Extra name reserved in case it is needed in the future.</span>
<span class="line-added"> 176  *</span>
<span class="line-added"> 177  * @draft ICU 63</span>
<span class="line-added"> 178  */</span>
 179 typedef Notation SimpleNotation;
 180 
 181 /**
 182  * A class that defines the notation style to be used when formatting numbers in NumberFormatter.
 183  *
 184  * @draft ICU 60
 185  */
 186 class U_I18N_API Notation : public UMemory {
 187   public:
 188     /**
 189      * Print the number using scientific notation (also known as scientific form, standard index form, or standard form
 190      * in the UK). The format for scientific notation varies by locale; for example, many Western locales display the
 191      * number in the form &quot;#E0&quot;, where the number is displayed with one digit before the decimal separator, zero or more
 192      * digits after the decimal separator, and the corresponding power of 10 displayed after the &quot;E&quot;.
 193      *
 194      * &lt;p&gt;
 195      * Example outputs in &lt;em&gt;en-US&lt;/em&gt; when printing 8.765E4 through 8.765E-3:
 196      *
 197      * &lt;pre&gt;
 198      * 8.765E4
</pre>
<hr />
<pre>
 318      * 876,500
 319      * 87,650
 320      * 8,765
 321      * 876.5
 322      * 87.65
 323      * 8.765
 324      * &lt;/pre&gt;
 325      *
 326      * @return A SimpleNotation for passing to the NumberFormatter notation() setter.
 327      * @draft ICU 60
 328      */
 329     static SimpleNotation simple();
 330 
 331   private:
 332     enum NotationType {
 333         NTN_SCIENTIFIC, NTN_COMPACT, NTN_SIMPLE, NTN_ERROR
 334     } fType;
 335 
 336     union NotationUnion {
 337         // For NTN_SCIENTIFIC
<span class="line-added"> 338         /** @internal */</span>
 339         struct ScientificSettings {
<span class="line-added"> 340             /** @internal */</span>
 341             int8_t fEngineeringInterval;
<span class="line-added"> 342             /** @internal */</span>
 343             bool fRequireMinInt;
<span class="line-added"> 344             /** @internal */</span>
 345             impl::digits_t fMinExponentDigits;
<span class="line-added"> 346             /** @internal */</span>
 347             UNumberSignDisplay fExponentSignDisplay;
 348         } scientific;
 349 
 350         // For NTN_COMPACT
 351         UNumberCompactStyle compactStyle;
 352 
 353         // For NTN_ERROR
 354         UErrorCode errorCode;
 355     } fUnion;
 356 
 357     typedef NotationUnion::ScientificSettings ScientificSettings;
 358 
 359     Notation(const NotationType &amp;type, const NotationUnion &amp;union_) : fType(type), fUnion(union_) {}
 360 
 361     Notation(UErrorCode errorCode) : fType(NTN_ERROR) {
 362         fUnion.errorCode = errorCode;
 363     }
 364 
 365     Notation() : fType(NTN_SIMPLE), fUnion() {}
 366 
</pre>
<hr />
<pre>
 422      *            The strategy for displaying the sign in the exponent.
 423      * @return A ScientificNotation, for chaining.
 424      * @draft ICU 60
 425      */
 426     ScientificNotation withExponentSignDisplay(UNumberSignDisplay exponentSignDisplay) const;
 427 
 428   private:
 429     // Inherit constructor
 430     using Notation::Notation;
 431 
 432     // Raw constructor for NumberPropertyMapper
 433     ScientificNotation(int8_t fEngineeringInterval, bool fRequireMinInt, impl::digits_t fMinExponentDigits,
 434                        UNumberSignDisplay fExponentSignDisplay);
 435 
 436     friend class Notation;
 437 
 438     // So that NumberPropertyMapper can create instances
 439     friend class impl::NumberPropertyMapper;
 440 };
 441 
<span class="line-modified"> 442 /**</span>
<span class="line-added"> 443  * Extra name reserved in case it is needed in the future.</span>
<span class="line-added"> 444  *</span>
<span class="line-added"> 445  * @draft ICU 63</span>
<span class="line-added"> 446  */</span>
 447 typedef Precision SignificantDigitsPrecision;
 448 








 449 /**
 450  * A class that defines the rounding precision to be used when formatting numbers in NumberFormatter.
 451  *
 452  * &lt;p&gt;
 453  * To create a Precision, use one of the factory methods.
 454  *
 455  * @draft ICU 60
 456  */
 457 class U_I18N_API Precision : public UMemory {
 458 
 459   public:
 460     /**
 461      * Show all available digits to full precision.
 462      *
 463      * &lt;p&gt;
 464      * &lt;strong&gt;NOTE:&lt;/strong&gt; When formatting a &lt;em&gt;double&lt;/em&gt;, this method, along with {@link #minFraction} and
<span class="line-modified"> 465      * {@link #minSignificantDigits}, will trigger complex algorithm similar to &lt;em&gt;Dragon4&lt;/em&gt; to determine the</span>
<span class="line-modified"> 466      * low-order digits and the number of digits to display based on the value of the double.</span>
<span class="line-modified"> 467      * If the number of fraction places or significant digits can be bounded, consider using {@link #maxFraction}</span>
<span class="line-modified"> 468      * or {@link #maxSignificantDigits} instead to maximize performance.</span>
<span class="line-added"> 469      * For more information, read the following blog post.</span>
 470      *
 471      * &lt;p&gt;
 472      * http://www.serpentine.com/blog/2011/06/29/here-be-dragons-advances-in-problems-you-didnt-even-know-you-had/
 473      *
 474      * @return A Precision for chaining or passing to the NumberFormatter precision() setter.
 475      * @draft ICU 60
 476      */
 477     static Precision unlimited();
 478 
 479     /**
 480      * Show numbers rounded if necessary to the nearest integer.
 481      *
 482      * @return A FractionPrecision for chaining or passing to the NumberFormatter precision() setter.
 483      * @draft ICU 60
 484      */
 485     static FractionPrecision integer();
 486 
 487     /**
 488      * Show numbers rounded if necessary to a certain number of fraction places (numerals after the decimal separator).
 489      * Additionally, pad with zeros to ensure that this number of places are always shown.
</pre>
<hr />
<pre>
 543     /**
 544      * Show numbers rounded if necessary to a certain number of fraction places (numerals after the decimal separator);
 545      * in addition, always show at least a certain number of places after the decimal separator, padding with zeros if
 546      * necessary.
 547      *
 548      * @param minFractionPlaces
 549      *            The minimum number of numerals to display after the decimal separator (padding with zeros if
 550      *            necessary).
 551      * @param maxFractionPlaces
 552      *            The maximum number of numerals to display after the decimal separator (rounding if necessary).
 553      * @return A FractionPrecision for chaining or passing to the NumberFormatter precision() setter.
 554      * @draft ICU 60
 555      */
 556     static FractionPrecision minMaxFraction(int32_t minFractionPlaces, int32_t maxFractionPlaces);
 557 
 558     /**
 559      * Show numbers rounded if necessary to a certain number of significant digits or significant figures. Additionally,
 560      * pad with zeros to ensure that this number of significant digits/figures are always shown.
 561      *
 562      * &lt;p&gt;
<span class="line-modified"> 563      * This method is equivalent to {@link #minMaxSignificantDigits} with both arguments equal.</span>
 564      *
 565      * @param minMaxSignificantDigits
 566      *            The minimum and maximum number of significant digits to display (rounding if too long or padding with
 567      *            zeros if too short).
 568      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 569      * @draft ICU 62
 570      */
 571     static SignificantDigitsPrecision fixedSignificantDigits(int32_t minMaxSignificantDigits);
 572 
 573     /**
 574      * Always show at least a certain number of significant digits/figures, padding with zeros if necessary. Do not
 575      * perform rounding (display numbers to their full precision).
 576      *
 577      * &lt;p&gt;
 578      * &lt;strong&gt;NOTE:&lt;/strong&gt; If you are formatting &lt;em&gt;doubles&lt;/em&gt;, see the performance note in {@link #unlimited}.
 579      *
 580      * @param minSignificantDigits
 581      *            The minimum number of significant digits to display (padding with zeros if too short).
 582      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 583      * @draft ICU 62
</pre>
<hr />
<pre>
 591      *            The maximum number of significant digits to display (rounding if too long).
 592      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 593      * @draft ICU 62
 594      */
 595     static SignificantDigitsPrecision maxSignificantDigits(int32_t maxSignificantDigits);
 596 
 597     /**
 598      * Show numbers rounded if necessary to a certain number of significant digits/figures; in addition, always show at
 599      * least a certain number of significant digits, padding with zeros if necessary.
 600      *
 601      * @param minSignificantDigits
 602      *            The minimum number of significant digits to display (padding with zeros if necessary).
 603      * @param maxSignificantDigits
 604      *            The maximum number of significant digits to display (rounding if necessary).
 605      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 606      * @draft ICU 62
 607      */
 608     static SignificantDigitsPrecision minMaxSignificantDigits(int32_t minSignificantDigits,
 609                                                               int32_t maxSignificantDigits);
 610 

























 611     /**
 612      * Show numbers rounded if necessary to the closest multiple of a certain rounding increment. For example, if the
 613      * rounding increment is 0.5, then round 1.2 to 1 and round 1.3 to 1.5.
 614      *
 615      * &lt;p&gt;
 616      * In order to ensure that numbers are padded to the appropriate number of fraction places, call
 617      * withMinFraction() on the return value of this method.
 618      * For example, to round to the nearest 0.5 and always display 2 numerals after the
 619      * decimal separator (to display 1.2 as &quot;1.00&quot; and 1.3 as &quot;1.50&quot;), you can run:
 620      *
 621      * &lt;pre&gt;
 622      * Precision::increment(0.5).withMinFraction(2)
 623      * &lt;/pre&gt;
 624      *
 625      * @param roundingIncrement
 626      *            The increment to which to round numbers.
 627      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 628      * @draft ICU 60
 629      */
 630     static IncrementPrecision increment(double roundingIncrement);
 631 
 632     /**
 633      * Show numbers rounded and padded according to the rules for the currency unit. The most common
 634      * rounding precision settings for currencies include &lt;code&gt;Precision::fixedFraction(2)&lt;/code&gt;,
 635      * &lt;code&gt;Precision::integer()&lt;/code&gt;, and &lt;code&gt;Precision::increment(0.05)&lt;/code&gt; for cash transactions
 636      * (&quot;nickel rounding&quot;).
 637      *
 638      * &lt;p&gt;
 639      * The exact rounding details will be resolved at runtime based on the currency unit specified in the
 640      * NumberFormatter chain. To round according to the rules for one currency while displaying the symbol for another
 641      * currency, the withCurrency() method can be called on the return value of this method.
 642      *
 643      * @param currencyUsage
 644      *            Either STANDARD (for digital transactions) or CASH (for transactions where the rounding increment may
 645      *            be limited by the available denominations of cash or coins).
 646      * @return A CurrencyPrecision for chaining or passing to the NumberFormatter precision() setter.
 647      * @draft ICU 60
 648      */
 649     static CurrencyPrecision currency(UCurrencyUsage currencyUsage);
 650 















 651   private:
 652     enum PrecisionType {
 653         RND_BOGUS,
 654         RND_NONE,
 655         RND_FRACTION,
 656         RND_SIGNIFICANT,
 657         RND_FRACTION_SIGNIFICANT,
<span class="line-added"> 658 </span>
<span class="line-added"> 659         // Used for strange increments like 3.14.</span>
 660         RND_INCREMENT,
<span class="line-added"> 661 </span>
<span class="line-added"> 662         // Used for increments with 1 as the only digit. This is different than fraction</span>
<span class="line-added"> 663         // rounding because it supports having additional trailing zeros. For example, this</span>
<span class="line-added"> 664         // class is used to round with the increment 0.010.</span>
<span class="line-added"> 665         RND_INCREMENT_ONE,</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667         // Used for increments with 5 as the only digit (nickel rounding).</span>
<span class="line-added"> 668         RND_INCREMENT_FIVE,</span>
<span class="line-added"> 669 </span>
 670         RND_CURRENCY,
 671         RND_ERROR
 672     } fType;
 673 
 674     union PrecisionUnion {
<span class="line-added"> 675         /** @internal */</span>
 676         struct FractionSignificantSettings {
 677             // For RND_FRACTION, RND_SIGNIFICANT, and RND_FRACTION_SIGNIFICANT
<span class="line-added"> 678             /** @internal */</span>
 679             impl::digits_t fMinFrac;
<span class="line-added"> 680             /** @internal */</span>
 681             impl::digits_t fMaxFrac;
<span class="line-added"> 682             /** @internal */</span>
 683             impl::digits_t fMinSig;
<span class="line-added"> 684             /** @internal */</span>
 685             impl::digits_t fMaxSig;
 686         } fracSig;
<span class="line-added"> 687         /** @internal */</span>
 688         struct IncrementSettings {
<span class="line-added"> 689             // For RND_INCREMENT, RND_INCREMENT_ONE, and RND_INCREMENT_FIVE</span>
<span class="line-added"> 690             /** @internal */</span>
 691             double fIncrement;
<span class="line-added"> 692             /** @internal */</span>
 693             impl::digits_t fMinFrac;
<span class="line-added"> 694             /** @internal */</span>
 695             impl::digits_t fMaxFrac;
<span class="line-modified"> 696         } increment;</span>
 697         UCurrencyUsage currencyUsage; // For RND_CURRENCY
 698         UErrorCode errorCode; // For RND_ERROR
 699     } fUnion;
 700 
 701     typedef PrecisionUnion::FractionSignificantSettings FractionSignificantSettings;
 702     typedef PrecisionUnion::IncrementSettings IncrementSettings;
 703 
 704     /** The Precision encapsulates the RoundingMode when used within the implementation. */
 705     UNumberFormatRoundingMode fRoundingMode;
 706 
 707     Precision(const PrecisionType&amp; type, const PrecisionUnion&amp; union_,
 708               UNumberFormatRoundingMode roundingMode)
 709             : fType(type), fUnion(union_), fRoundingMode(roundingMode) {}
 710 
 711     Precision(UErrorCode errorCode) : fType(RND_ERROR) {
 712         fUnion.errorCode = errorCode;
 713     }
 714 
 715     Precision() : fType(RND_BOGUS) {}
 716 
</pre>
<hr />
<pre>
1198     } fType;
1199 
1200     union {
1201         const DecimalFormatSymbols *dfs;
1202         const NumberingSystem *ns;
1203     } fPtr;
1204 
1205     void doCopyFrom(const SymbolsWrapper &amp;other);
1206 
1207     void doMoveFrom(SymbolsWrapper&amp;&amp; src);
1208 
1209     void doCleanup();
1210 };
1211 
1212 // Do not enclose entire Grouper with #ifndef U_HIDE_INTERNAL_API, needed for a protected field
1213 /** @internal */
1214 class U_I18N_API Grouper : public UMemory {
1215   public:
1216 #ifndef U_HIDE_INTERNAL_API
1217     /** @internal */
<span class="line-modified">1218     static Grouper forStrategy(UNumberGroupingStrategy grouping);</span>
1219 
1220     /**
1221      * Resolve the values in Properties to a Grouper object.
1222      * @internal
1223      */
1224     static Grouper forProperties(const DecimalFormatProperties&amp; properties);
1225 
1226     // Future: static Grouper forProperties(DecimalFormatProperties&amp; properties);
1227 
1228     /** @internal */
<span class="line-modified">1229     Grouper(int16_t grouping1, int16_t grouping2, int16_t minGrouping, UNumberGroupingStrategy strategy)</span>
1230             : fGrouping1(grouping1),
1231               fGrouping2(grouping2),
1232               fMinGrouping(minGrouping),
1233               fStrategy(strategy) {}
1234 #endif  // U_HIDE_INTERNAL_API
1235 
1236     /** @internal */
1237     int16_t getPrimary() const;
1238 
1239     /** @internal */
1240     int16_t getSecondary() const;
1241 
1242   private:
1243     /**
1244      * The grouping sizes, with the following special values:
1245      * &lt;ul&gt;
1246      * &lt;li&gt;-1 = no grouping
1247      * &lt;li&gt;-2 = needs locale data
1248      * &lt;li&gt;-4 = fall back to Western grouping if not in locale
1249      * &lt;/ul&gt;
1250      */
1251     int16_t fGrouping1;
1252     int16_t fGrouping2;
1253 
1254     /**
1255      * The minimum grouping size, with the following special values:
1256      * &lt;ul&gt;
1257      * &lt;li&gt;-2 = needs locale data
1258      * &lt;li&gt;-3 = no less than 2
1259      * &lt;/ul&gt;
1260      */
1261     int16_t fMinGrouping;
1262 
1263     /**
<span class="line-modified">1264      * The UNumberGroupingStrategy that was used to create this Grouper, or UNUM_GROUPING_COUNT if this</span>
<span class="line-modified">1265      * was not created from a UNumberGroupingStrategy.</span>
1266      */
<span class="line-modified">1267     UNumberGroupingStrategy fStrategy;</span>
1268 
<span class="line-modified">1269     Grouper() : fGrouping1(-3) {}</span>
1270 
1271     bool isBogus() const {
1272         return fGrouping1 == -3;
1273     }
1274 
1275     /** NON-CONST: mutates the current instance. */
1276     void setLocaleData(const impl::ParsedPatternInfo &amp;patternInfo, const Locale&amp; locale);
1277 
1278     bool groupAtPosition(int32_t position, const impl::DecimalQuantity &amp;value) const;
1279 
1280     // To allow MacroProps/MicroProps to initialize empty instances:
1281     friend struct MacroProps;
1282     friend struct MicroProps;
1283 
1284     // To allow NumberFormatterImpl to access isBogus() and perform other operations:
1285     friend class NumberFormatterImpl;
1286 
1287     // To allow NumberParserImpl to perform setLocaleData():
1288     friend class ::icu::numparse::impl::NumberParserImpl;
1289 
</pre>
<hr />
<pre>
1394 
1395     /** @internal */
1396     UNumberSignDisplay sign = UNUM_SIGN_COUNT;
1397 
1398     /** @internal */
1399     UNumberDecimalSeparatorDisplay decimal = UNUM_DECIMAL_SEPARATOR_COUNT;
1400 
1401     /** @internal */
1402     Scale scale;  // = Scale();  (benign value)
1403 
1404     /** @internal */
1405     const AffixPatternProvider* affixProvider = nullptr;  // no ownership
1406 
1407     /** @internal */
1408     const PluralRules* rules = nullptr;  // no ownership
1409 
1410     /** @internal */
1411     const CurrencySymbols* currencySymbols = nullptr;  // no ownership
1412 
1413     /** @internal */
<span class="line-modified">1414     int32_t threshold = kInternalDefaultThreshold;</span>
1415 
1416     /** @internal */
1417     Locale locale;
1418 
1419     // NOTE: Uses default copy and move constructors.
1420 
1421     /**
1422      * Check all members for errors.
1423      * @internal
1424      */
1425     bool copyErrorTo(UErrorCode &amp;status) const {
1426         return notation.copyErrorTo(status) || precision.copyErrorTo(status) ||
1427                padder.copyErrorTo(status) || integerWidth.copyErrorTo(status) ||
1428                symbols.copyErrorTo(status) || scale.copyErrorTo(status);
1429     }
1430 };
1431 
1432 } // namespace impl
1433 
1434 /**
1435  * An abstract base class for specifying settings related to number formatting. This class is implemented by
<span class="line-modified">1436  * {@link UnlocalizedNumberFormatter} and {@link LocalizedNumberFormatter}. This class is not intended for</span>
<span class="line-added">1437  * public subclassing.</span>
1438  */
1439 template&lt;typename Derived&gt;
1440 class U_I18N_API NumberFormatterSettings {
1441   public:
1442     /**
1443      * Specifies the notation style (simple, scientific, or compact) for rendering numbers.
1444      *
1445      * &lt;ul&gt;
1446      * &lt;li&gt;Simple notation: &quot;12,300&quot;
1447      * &lt;li&gt;Scientific notation: &quot;1.23E4&quot;
1448      * &lt;li&gt;Compact notation: &quot;12K&quot;
1449      * &lt;/ul&gt;
1450      *
1451      * &lt;p&gt;
1452      * All notation styles will be properly localized with locale data, and all notation styles are compatible with
1453      * units, rounding precisions, and other number formatter settings.
1454      *
1455      * &lt;p&gt;
1456      * Pass this method the return value of a {@link Notation} factory method. For example:
1457      *
</pre>
<hr />
<pre>
1475      * @param notation
1476      *            The notation strategy to use.
1477      * @return The fluent chain.
1478      * @see #notation
1479      * @draft ICU 62
1480      */
1481     Derived notation(const Notation &amp;notation) &amp;&amp;;
1482 
1483     /**
1484      * Specifies the unit (unit of measure, currency, or percent) to associate with rendered numbers.
1485      *
1486      * &lt;ul&gt;
1487      * &lt;li&gt;Unit of measure: &quot;12.3 meters&quot;
1488      * &lt;li&gt;Currency: &quot;$12.30&quot;
1489      * &lt;li&gt;Percent: &quot;12.3%&quot;
1490      * &lt;/ul&gt;
1491      *
1492      * All units will be properly localized with locale data, and all units are compatible with notation styles,
1493      * rounding precisions, and other number formatter settings.
1494      *
<span class="line-modified">1495      * Pass this method any instance of {@link MeasureUnit}. For units of measure:</span>

1496      *
1497      * &lt;pre&gt;
<span class="line-modified">1498      * NumberFormatter::with().unit(MeasureUnit::getMeter())</span>
1499      * &lt;/pre&gt;
1500      *
1501      * Currency:
1502      *
1503      * &lt;pre&gt;
1504      * NumberFormatter::with().unit(CurrencyUnit(u&quot;USD&quot;, status))
1505      * &lt;/pre&gt;
1506      *
1507      * Percent:
1508      *
1509      * &lt;pre&gt;
1510      * NumberFormatter::with().unit(NoUnit.percent())
1511      * &lt;/pre&gt;
1512      *
1513      * See {@link #perUnit} for information on how to format strings like &quot;5 meters per second&quot;.
1514      *
1515      * The default is to render without units (equivalent to NoUnit.base()).
1516      *
1517      * @param unit
1518      *            The unit to render.
</pre>
<hr />
<pre>
1521      * @see Currency
1522      * @see NoUnit
1523      * @see #perUnit
1524      * @draft ICU 60
1525      */
1526     Derived unit(const icu::MeasureUnit &amp;unit) const &amp;;
1527 
1528     /**
1529      * Overload of unit() for use on an rvalue reference.
1530      *
1531      * @param unit
1532      *            The unit to render.
1533      * @return The fluent chain.
1534      * @see #unit
1535      * @draft ICU 62
1536      */
1537     Derived unit(const icu::MeasureUnit &amp;unit) &amp;&amp;;
1538 
1539     /**
1540      * Like unit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory
<span class="line-modified">1541      * methods that return pointers that need ownership.</span>
1542      *
<span class="line-modified">1543      * Note: consider using the MeasureFormat factory methods that return by value.</span>


1544      *
1545      * @param unit
1546      *            The unit to render.
1547      * @return The fluent chain.
1548      * @see #unit
1549      * @see MeasureUnit
1550      * @draft ICU 60
1551      */
1552     Derived adoptUnit(icu::MeasureUnit *unit) const &amp;;
1553 
1554     /**
1555      * Overload of adoptUnit() for use on an rvalue reference.
1556      *
1557      * @param unit
1558      *            The unit to render.
1559      * @return The fluent chain.
1560      * @see #adoptUnit
1561      * @draft ICU 62
1562      */
1563     Derived adoptUnit(icu::MeasureUnit *unit) &amp;&amp;;
1564 
1565     /**
1566      * Sets a unit to be used in the denominator. For example, to format &quot;3 m/s&quot;, pass METER to the unit and SECOND to
1567      * the perUnit.
1568      *
<span class="line-modified">1569      * Pass this method any instance of {@link MeasureUnit}. Example:</span>
<span class="line-modified">1570      *</span>
<span class="line-added">1571      * &lt;pre&gt;</span>
<span class="line-added">1572      * NumberFormatter::with()</span>
<span class="line-added">1573      *      .unit(MeasureUnit::getMeter())</span>
<span class="line-added">1574      *      .perUnit(MeasureUnit::getSecond())</span>
<span class="line-added">1575      * &lt;/pre&gt;</span>
1576      *
1577      * The default is not to display any unit in the denominator.
1578      *
1579      * If a per-unit is specified without a primary unit via {@link #unit}, the behavior is undefined.
1580      *
1581      * @param perUnit
1582      *            The unit to render in the denominator.
1583      * @return The fluent chain
1584      * @see #unit
1585      * @draft ICU 61
1586      */
1587     Derived perUnit(const icu::MeasureUnit &amp;perUnit) const &amp;;
1588 
1589     /**
1590      * Overload of perUnit() for use on an rvalue reference.
1591      *
1592      * @param perUnit
1593      *            The unit to render in the denominator.
1594      * @return The fluent chain.
1595      * @see #perUnit
1596      * @draft ICU 62
1597      */
1598     Derived perUnit(const icu::MeasureUnit &amp;perUnit) &amp;&amp;;
1599 
1600     /**
1601      * Like perUnit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory
<span class="line-modified">1602      * methods that return pointers that need ownership.</span>
1603      *
<span class="line-modified">1604      * Note: consider using the MeasureFormat factory methods that return by value.</span>




1605      *
1606      * @param perUnit
1607      *            The unit to render in the denominator.
1608      * @return The fluent chain.
1609      * @see #perUnit
1610      * @see MeasureUnit
1611      * @draft ICU 61
1612      */
1613     Derived adoptPerUnit(icu::MeasureUnit *perUnit) const &amp;;
1614 
1615     /**
1616      * Overload of adoptPerUnit() for use on an rvalue reference.
1617      *
1618      * @param perUnit
1619      *            The unit to render in the denominator.
1620      * @return The fluent chain.
1621      * @see #adoptPerUnit
1622      * @draft ICU 62
1623      */
1624     Derived adoptPerUnit(icu::MeasureUnit *perUnit) &amp;&amp;;
</pre>
<hr />
<pre>
1649      *
1650      * @param precision
1651      *            The rounding precision to use.
1652      * @return The fluent chain.
1653      * @see Precision
1654      * @draft ICU 62
1655      */
1656     Derived precision(const Precision&amp; precision) const &amp;;
1657 
1658     /**
1659      * Overload of precision() for use on an rvalue reference.
1660      *
1661      * @param precision
1662      *            The rounding precision to use.
1663      * @return The fluent chain.
1664      * @see #precision
1665      * @draft ICU 62
1666      */
1667     Derived precision(const Precision&amp; precision) &amp;&amp;;
1668 










1669     /**
1670      * Specifies how to determine the direction to round a number when it has more digits than fit in the
1671      * desired precision.  When formatting 1.235:
1672      *
1673      * &lt;ul&gt;
1674      * &lt;li&gt;Ceiling rounding mode with integer precision: &quot;2&quot;
1675      * &lt;li&gt;Half-down rounding mode with 2 fixed fraction digits: &quot;1.23&quot;
1676      * &lt;li&gt;Half-up rounding mode with 2 fixed fraction digits: &quot;1.24&quot;
1677      * &lt;/ul&gt;
1678      *
1679      * The default is HALF_EVEN. For more information on rounding mode, see the ICU userguide here:
1680      *
1681      * http://userguide.icu-project.org/formatparse/numbers/rounding-modes
1682      *
1683      * @param roundingMode The rounding mode to use.
1684      * @return The fluent chain.
1685      * @draft ICU 62
1686      */
1687     Derived roundingMode(UNumberFormatRoundingMode roundingMode) const &amp;;
1688 
</pre>
<hr />
<pre>
1692      * @param roundingMode The rounding mode to use.
1693      * @return The fluent chain.
1694      * @see #roundingMode
1695      * @draft ICU 62
1696      */
1697     Derived roundingMode(UNumberFormatRoundingMode roundingMode) &amp;&amp;;
1698 
1699     /**
1700      * Specifies the grouping strategy to use when formatting numbers.
1701      *
1702      * &lt;ul&gt;
1703      * &lt;li&gt;Default grouping: &quot;12,300&quot; and &quot;1,230&quot;
1704      * &lt;li&gt;Grouping with at least 2 digits: &quot;12,300&quot; and &quot;1230&quot;
1705      * &lt;li&gt;No grouping: &quot;12300&quot; and &quot;1230&quot;
1706      * &lt;/ul&gt;
1707      *
1708      * &lt;p&gt;
1709      * The exact grouping widths will be chosen based on the locale.
1710      *
1711      * &lt;p&gt;
<span class="line-modified">1712      * Pass this method an element from the {@link UNumberGroupingStrategy} enum. For example:</span>
1713      *
1714      * &lt;pre&gt;
1715      * NumberFormatter::with().grouping(UNUM_GROUPING_MIN2)
1716      * &lt;/pre&gt;
1717      *
1718      * The default is to perform grouping according to locale data; most locales, but not all locales,
1719      * enable it by default.
1720      *
1721      * @param strategy
1722      *            The grouping strategy to use.
1723      * @return The fluent chain.
1724      * @draft ICU 61
1725      */
<span class="line-modified">1726     Derived grouping(UNumberGroupingStrategy strategy) const &amp;;</span>
1727 
1728     /**
1729      * Overload of grouping() for use on an rvalue reference.
1730      *
1731      * @param strategy
1732      *            The grouping strategy to use.
1733      * @return The fluent chain.
1734      * @see #grouping

1735      * @draft ICU 62
1736      */
<span class="line-modified">1737     Derived grouping(UNumberGroupingStrategy strategy) &amp;&amp;;</span>
1738 
1739     /**
1740      * Specifies the minimum and maximum number of digits to render before the decimal mark.
1741      *
1742      * &lt;ul&gt;
1743      * &lt;li&gt;Zero minimum integer digits: &quot;.08&quot;
1744      * &lt;li&gt;One minimum integer digit: &quot;0.08&quot;
1745      * &lt;li&gt;Two minimum integer digits: &quot;00.08&quot;
1746      * &lt;/ul&gt;
1747      *
1748      * &lt;p&gt;
<span class="line-modified">1749      * Pass this method the return value of {@link IntegerWidth#zeroFillTo}. For example:</span>
1750      *
1751      * &lt;pre&gt;
1752      * NumberFormatter::with().integerWidth(IntegerWidth::zeroFillTo(2))
1753      * &lt;/pre&gt;
1754      *
1755      * The default is to have one minimum integer digit.
1756      *
1757      * @param style
1758      *            The integer width to use.
1759      * @return The fluent chain.
1760      * @see IntegerWidth
1761      * @draft ICU 60
1762      */
1763     Derived integerWidth(const IntegerWidth &amp;style) const &amp;;
1764 
1765     /**
1766      * Overload of integerWidth() for use on an rvalue reference.
1767      *
1768      * @param style
1769      *            The integer width to use.
</pre>
<hr />
<pre>
2063     Derived macros(impl::MacroProps&amp;&amp; macros) &amp;&amp;;
2064 
2065 #endif  /* U_HIDE_INTERNAL_API */
2066 
2067     /**
2068      * Creates a skeleton string representation of this number formatter. A skeleton string is a
2069      * locale-agnostic serialized form of a number formatter.
2070      *
2071      * Not all options are capable of being represented in the skeleton string; for example, a
2072      * DecimalFormatSymbols object. If any such option is encountered, the error code is set to
2073      * U_UNSUPPORTED_ERROR.
2074      *
2075      * The returned skeleton is in normalized form, such that two number formatters with equivalent
2076      * behavior should produce the same skeleton.
2077      *
2078      * @return A number skeleton string with behavior corresponding to this number formatter.
2079      * @draft ICU 62
2080      */
2081     UnicodeString toSkeleton(UErrorCode&amp; status) const;
2082 
<span class="line-added">2083     /**</span>
<span class="line-added">2084      * Returns the current (Un)LocalizedNumberFormatter as a LocalPointer</span>
<span class="line-added">2085      * wrapping a heap-allocated copy of the current object.</span>
<span class="line-added">2086      *</span>
<span class="line-added">2087      * This is equivalent to new-ing the move constructor with a value object</span>
<span class="line-added">2088      * as the argument.</span>
<span class="line-added">2089      *</span>
<span class="line-added">2090      * @return A wrapped (Un)LocalizedNumberFormatter pointer, or a wrapped</span>
<span class="line-added">2091      *         nullptr on failure.</span>
<span class="line-added">2092      * @draft ICU 64</span>
<span class="line-added">2093      */</span>
<span class="line-added">2094     LocalPointer&lt;Derived&gt; clone() const &amp;;</span>
<span class="line-added">2095 </span>
<span class="line-added">2096     /**</span>
<span class="line-added">2097      * Overload of clone for use on an rvalue reference.</span>
<span class="line-added">2098      *</span>
<span class="line-added">2099      * @return A wrapped (Un)LocalizedNumberFormatter pointer, or a wrapped</span>
<span class="line-added">2100      *         nullptr on failure.</span>
<span class="line-added">2101      * @draft ICU 64</span>
<span class="line-added">2102      */</span>
<span class="line-added">2103     LocalPointer&lt;Derived&gt; clone() &amp;&amp;;</span>
<span class="line-added">2104 </span>
2105     /**
2106      * Sets the UErrorCode if an error occurred in the fluent chain.
2107      * Preserves older error codes in the outErrorCode.
2108      * @return TRUE if U_FAILURE(outErrorCode)
2109      * @draft ICU 60
2110      */
2111     UBool copyErrorTo(UErrorCode &amp;outErrorCode) const {
2112         if (U_FAILURE(outErrorCode)) {
2113             // Do not overwrite the older error code
2114             return TRUE;
2115         }
2116         fMacros.copyErrorTo(outErrorCode);
2117         return U_FAILURE(outErrorCode);
<span class="line-modified">2118     }</span>
2119 
2120     // NOTE: Uses default copy and move constructors.
2121 
<span class="line-modified">2122   private:</span>
2123     impl::MacroProps fMacros;
2124 

2125     // Don&#39;t construct me directly!  Use (Un)LocalizedNumberFormatter.
2126     NumberFormatterSettings() = default;
2127 
2128     friend class LocalizedNumberFormatter;
2129     friend class UnlocalizedNumberFormatter;
<span class="line-added">2130 </span>
<span class="line-added">2131     // Give NumberRangeFormatter access to the MacroProps</span>
<span class="line-added">2132     friend void impl::touchRangeLocales(impl::RangeMacroProps&amp; macros);</span>
<span class="line-added">2133     friend class impl::NumberRangeFormatterImpl;</span>
2134 };
2135 
2136 /**
2137  * A NumberFormatter that does not yet have a locale. In order to format numbers, a locale must be specified.
2138  *
<span class="line-added">2139  * Instances of this class are immutable and thread-safe.</span>
<span class="line-added">2140  *</span>
2141  * @see NumberFormatter
2142  * @draft ICU 60
2143  */
2144 class U_I18N_API UnlocalizedNumberFormatter
2145         : public NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;, public UMemory {
2146 
2147   public:
2148     /**
2149      * Associate the given locale with the number formatter. The locale is used for picking the appropriate symbols,
2150      * formats, and other data for number display.
2151      *







2152      * @param locale
2153      *            The locale to use when loading data for number formatting.
2154      * @return The fluent chain.
2155      * @draft ICU 60
2156      */
2157     LocalizedNumberFormatter locale(const icu::Locale &amp;locale) const &amp;;
2158 
2159     /**
2160      * Overload of locale() for use on an rvalue reference.
2161      *
2162      * @param locale
2163      *            The locale to use when loading data for number formatting.
2164      * @return The fluent chain.
2165      * @see #locale
2166      * @draft ICU 62
2167      */
2168     LocalizedNumberFormatter locale(const icu::Locale &amp;locale) &amp;&amp;;
2169 
2170     /**
2171      * Default constructor: puts the formatter into a valid but undefined state.

2177     /**
2178      * Returns a copy of this UnlocalizedNumberFormatter.
2179      * @draft ICU 60
2180      */
2181     UnlocalizedNumberFormatter(const UnlocalizedNumberFormatter &amp;other);
2182 
2183     /**
2184      * Move constructor:
2185      * The source UnlocalizedNumberFormatter will be left in a valid but undefined state.
2186      * @draft ICU 62
2187      */
2188     UnlocalizedNumberFormatter(UnlocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2189 
2190     /**
2191      * Copy assignment operator.
2192      * @draft ICU 62
2193      */
2194     UnlocalizedNumberFormatter&amp; operator=(const UnlocalizedNumberFormatter&amp; other);
2195 
2196     /**
</pre>
<hr />
<pre>
2199      * @draft ICU 62
2200      */
2201     UnlocalizedNumberFormatter&amp; operator=(UnlocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2202 
2203   private:
2204     explicit UnlocalizedNumberFormatter(const NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;&amp; other);
2205 
2206     explicit UnlocalizedNumberFormatter(
2207             NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;&amp;&amp; src) U_NOEXCEPT;
2208 
2209     // To give the fluent setters access to this class&#39;s constructor:
2210     friend class NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;;
2211 
2212     // To give NumberFormatter::with() access to this class&#39;s constructor:
2213     friend class NumberFormatter;
2214 };
2215 
2216 /**
2217  * A NumberFormatter that has a locale associated with it; this means .format() methods are available.
2218  *
<span class="line-added">2219  * Instances of this class are immutable and thread-safe.</span>
<span class="line-added">2220  *</span>
2221  * @see NumberFormatter
2222  * @draft ICU 60
2223  */
2224 class U_I18N_API LocalizedNumberFormatter
2225         : public NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;, public UMemory {
2226   public:
2227     /**
2228      * Format the given integer number to a string using the settings specified in the NumberFormatter fluent
2229      * setting chain.
2230      *
2231      * @param value
2232      *            The number to format.
2233      * @param status
2234      *            Set to an ErrorCode if one occurred in the setter chain or during formatting.
2235      * @return A FormattedNumber object; call .toString() to get the string.
2236      * @draft ICU 60
2237      */
2238     FormattedNumber formatInt(int64_t value, UErrorCode &amp;status) const;
2239 
2240     /**
</pre>
<hr />
<pre>
2273      */
2274     FormattedNumber formatDecimalQuantity(const impl::DecimalQuantity&amp; dq, UErrorCode&amp; status) const;
2275 
2276     /** Internal method for DecimalFormat compatibility.
2277      * @internal
2278      */
2279     void getAffixImpl(bool isPrefix, bool isNegative, UnicodeString&amp; result, UErrorCode&amp; status) const;
2280 
2281     /**
2282      * Internal method for testing.
2283      * @internal
2284      */
2285     const impl::NumberFormatterImpl* getCompiled() const;
2286 
2287     /**
2288      * Internal method for testing.
2289      * @internal
2290      */
2291     int32_t getCallCount() const;
2292 
<span class="line-modified">2293 #endif  /* U_HIDE_INTERNAL_API */</span>
2294 
2295     /**
2296      * Creates a representation of this LocalizedNumberFormat as an icu::Format, enabling the use
2297      * of this number formatter with APIs that need an object of that type, such as MessageFormat.
2298      *
2299      * This API is not intended to be used other than for enabling API compatibility. The formatDouble,
2300      * formatInt, and formatDecimal methods should normally be used when formatting numbers, not the Format
2301      * object returned by this method.
2302      *
2303      * The caller owns the returned object and must delete it when finished.
2304      *
2305      * @return A Format wrapping this LocalizedNumberFormatter.
2306      * @draft ICU 62
2307      */
2308     Format* toFormat(UErrorCode&amp; status) const;
2309 
2310     /**
2311      * Default constructor: puts the formatter into a valid but undefined state.
2312      *
2313      * @draft ICU 62
2314      */
2315     LocalizedNumberFormatter() = default;
2316 

2317     /**
2318      * Returns a copy of this LocalizedNumberFormatter.
2319      * @draft ICU 60
2320      */
2321     LocalizedNumberFormatter(const LocalizedNumberFormatter &amp;other);
2322 
2323     /**
2324      * Move constructor:
2325      * The source LocalizedNumberFormatter will be left in a valid but undefined state.
2326      * @draft ICU 62
2327      */
2328     LocalizedNumberFormatter(LocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2329 
2330     /**
2331      * Copy assignment operator.
2332      * @draft ICU 62
2333      */
2334     LocalizedNumberFormatter&amp; operator=(const LocalizedNumberFormatter&amp; other);
2335 
2336     /**
2337      * Move assignment operator:
2338      * The source LocalizedNumberFormatter will be left in a valid but undefined state.
2339      * @draft ICU 62
2340      */
2341     LocalizedNumberFormatter&amp; operator=(LocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2342 
2343 #ifndef U_HIDE_INTERNAL_API
2344 
2345     /**
2346      * This is the core entrypoint to the number formatting pipeline. It performs self-regulation: a static code path
2347      * for the first few calls, and compiling a more efficient data structure if called repeatedly.
2348      *
2349      * &lt;p&gt;
2350      * This function is very hot, being called in every call to the number formatting pipeline.
2351      *
2352      * @param results
2353      *            The results object. This method will mutate it to save the results.
<span class="line-added">2354      * @param status</span>
2355      * @internal
2356      */
2357     void formatImpl(impl::UFormattedNumberData *results, UErrorCode &amp;status) const;
2358 
<span class="line-modified">2359 #endif  /* U_HIDE_INTERNAL_API */</span>
2360 
2361     /**
2362      * Destruct this LocalizedNumberFormatter, cleaning up any memory it might own.
2363      * @draft ICU 60
2364      */
2365     ~LocalizedNumberFormatter();
2366 
2367   private:
2368     // Note: fCompiled can&#39;t be a LocalPointer because impl::NumberFormatterImpl is defined in an internal
2369     // header, and LocalPointer needs the full class definition in order to delete the instance.
2370     const impl::NumberFormatterImpl* fCompiled {nullptr};
2371     char fUnsafeCallCount[8] {};  // internally cast to u_atomic_int32_t
2372 
2373     explicit LocalizedNumberFormatter(const NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;&amp; other);
2374 
2375     explicit LocalizedNumberFormatter(NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;&amp;&amp; src) U_NOEXCEPT;
2376 
2377     LocalizedNumberFormatter(const impl::MacroProps &amp;macros, const Locale &amp;locale);
2378 
2379     LocalizedNumberFormatter(impl::MacroProps &amp;&amp;macros, const Locale &amp;locale);
2380 
<span class="line-added">2381     void clear();</span>
<span class="line-added">2382 </span>
2383     void lnfMoveHelper(LocalizedNumberFormatter&amp;&amp; src);
2384 
2385     /**
2386      * @return true if the compiled formatter is available.
2387      */
2388     bool computeCompiled(UErrorCode&amp; status) const;
2389 
2390     // To give the fluent setters access to this class&#39;s constructor:
2391     friend class NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;;
2392     friend class NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;;
2393 
2394     // To give UnlocalizedNumberFormatter::locale() access to this class&#39;s constructor:
2395     friend class UnlocalizedNumberFormatter;
2396 };
2397 
2398 /**
2399  * The result of a number formatting operation. This class allows the result to be exported in several data types,
2400  * including a UnicodeString and a FieldPositionIterator.
2401  *
<span class="line-added">2402  * Instances of this class are immutable and thread-safe.</span>
<span class="line-added">2403  *</span>
2404  * @draft ICU 60
2405  */
<span class="line-modified">2406 class U_I18N_API FormattedNumber : public UMemory, public FormattedValue {</span>
2407   public:
<span class="line-modified">2408 </span>
2409     /**
<span class="line-modified">2410      * Default constructor; makes an empty FormattedNumber.</span>
<span class="line-modified">2411      * @draft ICU 64</span>




2412      */
<span class="line-modified">2413     FormattedNumber()</span>
<span class="line-modified">2414         : fData(nullptr), fErrorCode(U_INVALID_STATE_ERROR) {}</span>
2415 
2416     /**
<span class="line-modified">2417      * Move constructor: Leaves the source FormattedNumber in an undefined state.</span>




2418      * @draft ICU 62
2419      */
<span class="line-modified">2420     FormattedNumber(FormattedNumber&amp;&amp; src) U_NOEXCEPT;</span>
<span class="line-added">2421 </span>
<span class="line-added">2422     /**</span>
<span class="line-added">2423      * Destruct an instance of FormattedNumber.</span>
<span class="line-added">2424      * @draft ICU 60</span>
<span class="line-added">2425      */</span>
<span class="line-added">2426     virtual ~FormattedNumber() U_OVERRIDE;</span>
<span class="line-added">2427 </span>
<span class="line-added">2428     /** Copying not supported; use move constructor instead. */</span>
<span class="line-added">2429     FormattedNumber(const FormattedNumber&amp;) = delete;</span>
<span class="line-added">2430 </span>
<span class="line-added">2431     /** Copying not supported; use move assignment instead. */</span>
<span class="line-added">2432     FormattedNumber&amp; operator=(const FormattedNumber&amp;) = delete;</span>
2433 

2434     /**
<span class="line-modified">2435      * Move assignment: Leaves the source FormattedNumber in an undefined state.</span>
<span class="line-modified">2436      * @draft ICU 62</span>







2437      */
<span class="line-modified">2438     FormattedNumber&amp; operator=(FormattedNumber&amp;&amp; src) U_NOEXCEPT;</span>

2439 
<span class="line-added">2440     // Copybrief: this method is older than the parent method</span>
2441     /**
<span class="line-modified">2442      * @copybrief FormattedValue::toString()</span>
<span class="line-added">2443      *</span>
<span class="line-added">2444      * For more information, see FormattedValue::toString()</span>
2445      *





2446      * @draft ICU 62

2447      */
<span class="line-modified">2448     UnicodeString toString(UErrorCode&amp; status) const U_OVERRIDE;</span>
2449 
<span class="line-modified">2450     // Copydoc: this method is new in ICU 64</span>
<span class="line-added">2451     /** @copydoc FormattedValue::toTempString() */</span>
<span class="line-added">2452     UnicodeString toTempString(UErrorCode&amp; status) const U_OVERRIDE;</span>
<span class="line-added">2453 </span>
<span class="line-added">2454     // Copybrief: this method is older than the parent method</span>
2455     /**
<span class="line-modified">2456      * @copybrief FormattedValue::appendTo()</span>

2457      *
<span class="line-modified">2458      * For more information, see FormattedValue::appendTo()</span>


2459      *
<span class="line-modified">2460      * @draft ICU 62</span>










2461      */
<span class="line-modified">2462     Appendable &amp;appendTo(Appendable&amp; appendable, UErrorCode&amp; status) const U_OVERRIDE;</span>
<span class="line-modified">2463 </span>
<span class="line-added">2464     // Copydoc: this method is new in ICU 64</span>
<span class="line-added">2465     /** @copydoc FormattedValue::nextPosition() */</span>
<span class="line-added">2466     UBool nextPosition(ConstrainedFieldPosition&amp; cfpos, UErrorCode&amp; status) const U_OVERRIDE;</span>
2467 
2468     /**
<span class="line-modified">2469      * Determines the start (inclusive) and end (exclusive) indices of the next occurrence of the given</span>
<span class="line-modified">2470      * &lt;em&gt;field&lt;/em&gt; in the output string. This allows you to determine the locations of, for example,</span>
<span class="line-modified">2471      * the integer part, fraction part, or symbols.</span>
<span class="line-added">2472      *</span>
<span class="line-added">2473      * This is a simpler but less powerful alternative to {@link #nextPosition}.</span>
2474      *
2475      * If a field occurs just once, calling this method will find that occurrence and return it. If a
2476      * field occurs multiple times, this method may be called repeatedly with the following pattern:
2477      *
2478      * &lt;pre&gt;
2479      * FieldPosition fpos(UNUM_GROUPING_SEPARATOR_FIELD);
2480      * while (formattedNumber.nextFieldPosition(fpos, status)) {
2481      *   // do something with fpos.
2482      * }
2483      * &lt;/pre&gt;
2484      *
2485      * This method is useful if you know which field to query. If you want all available field position
<span class="line-modified">2486      * information, use {@link #nextPosition} or {@link #getAllFieldPositions}.</span>
2487      *
2488      * @param fieldPosition
2489      *            Input+output variable. On input, the &quot;field&quot; property determines which field to look
2490      *            up, and the &quot;beginIndex&quot; and &quot;endIndex&quot; properties determine where to begin the search.
2491      *            On output, the &quot;beginIndex&quot; is set to the beginning of the first occurrence of the
<span class="line-modified">2492      *            field with either begin or end indices after the input indices; &quot;endIndex&quot; is set to</span>
2493      *            the end of that occurrence of the field (exclusive index). If a field position is not
2494      *            found, the method returns FALSE and the FieldPosition may or may not be changed.
2495      * @param status
2496      *            Set if an error occurs while populating the FieldPosition.
2497      * @return TRUE if a new occurrence of the field was found; FALSE otherwise.
2498      * @draft ICU 62
2499      * @see UNumberFormatFields
2500      */
2501     UBool nextFieldPosition(FieldPosition&amp; fieldPosition, UErrorCode&amp; status) const;
2502 

2503     /**
2504      * Export the formatted number to a FieldPositionIterator. This allows you to determine which characters in
2505      * the output string correspond to which &lt;em&gt;fields&lt;/em&gt;, such as the integer part, fraction part, and sign.
2506      *
<span class="line-modified">2507      * This is an alternative to the more powerful #nextPosition() API.</span>
















2508      *
<span class="line-modified">2509      * If information on only one field is needed, use #nextPosition() or #nextFieldPosition() instead.</span>
2510      *
2511      * @param iterator
2512      *            The FieldPositionIterator to populate with all of the fields present in the formatted number.
2513      * @param status
2514      *            Set if an error occurs while populating the FieldPositionIterator.
2515      * @draft ICU 62
2516      * @see UNumberFormatFields
2517      */
2518     void getAllFieldPositions(FieldPositionIterator &amp;iterator, UErrorCode &amp;status) const;
2519 
2520 #ifndef U_HIDE_INTERNAL_API
2521 
2522     /**
2523      *  Gets the raw DecimalQuantity for plural rule selection.
2524      *  @internal
2525      */
2526     void getDecimalQuantity(impl::DecimalQuantity&amp; output, UErrorCode&amp; status) const;
2527 
2528     /**
2529      * Populates the mutable builder type FieldPositionIteratorHandler.
2530      * @internal
2531      */
2532     void getAllFieldPositionsImpl(FieldPositionIteratorHandler&amp; fpih, UErrorCode&amp; status) const;
2533 
<span class="line-modified">2534 #endif  /* U_HIDE_INTERNAL_API */</span>






























2535 
2536   private:
2537     // Can&#39;t use LocalPointer because UFormattedNumberData is forward-declared
<span class="line-modified">2538     const impl::UFormattedNumberData *fData;</span>
2539 
2540     // Error code for the terminal methods
2541     UErrorCode fErrorCode;
2542 
2543     /**
2544      * Internal constructor from data type. Adopts the data pointer.
2545      * @internal
2546      */
2547     explicit FormattedNumber(impl::UFormattedNumberData *results)
<span class="line-modified">2548         : fData(results), fErrorCode(U_ZERO_ERROR) {}</span>
2549 
2550     explicit FormattedNumber(UErrorCode errorCode)
<span class="line-modified">2551         : fData(nullptr), fErrorCode(errorCode) {}</span>
2552 
2553     // To give LocalizedNumberFormatter format methods access to this class&#39;s constructor:
2554     friend class LocalizedNumberFormatter;
<span class="line-added">2555 </span>
<span class="line-added">2556     // To give C API access to internals</span>
<span class="line-added">2557     friend struct impl::UFormattedNumberImpl;</span>
2558 };
2559 
2560 /**
2561  * See the main description in numberformatter.h for documentation and examples.
2562  *
2563  * @draft ICU 60
2564  */
2565 class U_I18N_API NumberFormatter final {
2566   public:
2567     /**
2568      * Call this method at the beginning of a NumberFormatter fluent chain in which the locale is not currently known at
2569      * the call site.
2570      *
2571      * @return An {@link UnlocalizedNumberFormatter}, to be used for chaining.
2572      * @draft ICU 60
2573      */
2574     static UnlocalizedNumberFormatter with();
2575 
2576     /**
2577      * Call this method at the beginning of a NumberFormatter fluent chain in which the locale is known at the call
<span class="line-added">2591      * It is possible for an error to occur while parsing. See the overload of this method if you are</span>
<span class="line-added">2592      * interested in the location of a possible parse error.</span>
<span class="line-added">2593      *</span>
2594      * @param skeleton
2595      *            The skeleton string off of which to base this NumberFormatter.
2596      * @param status
2597      *            Set to U_NUMBER_SKELETON_SYNTAX_ERROR if the skeleton was invalid.
2598      * @return An UnlocalizedNumberFormatter, to be used for chaining.
2599      * @draft ICU 62
2600      */
2601     static UnlocalizedNumberFormatter forSkeleton(const UnicodeString&amp; skeleton, UErrorCode&amp; status);
2602 
<span class="line-added">2603     /**</span>
<span class="line-added">2604      * Call this method at the beginning of a NumberFormatter fluent chain to create an instance based</span>
<span class="line-added">2605      * on a given number skeleton string.</span>
<span class="line-added">2606      *</span>
<span class="line-added">2607      * If an error occurs while parsing the skeleton string, the offset into the skeleton string at</span>
<span class="line-added">2608      * which the error occurred will be saved into the UParseError, if provided.</span>
<span class="line-added">2609      *</span>
<span class="line-added">2610      * @param skeleton</span>
<span class="line-added">2611      *            The skeleton string off of which to base this NumberFormatter.</span>
<span class="line-added">2612      * @param perror</span>
<span class="line-added">2613      *            A parse error struct populated if an error occurs when parsing.</span>
<span class="line-added">2614  *                If no error occurs, perror.offset will be set to -1.</span>
<span class="line-added">2615      * @param status</span>
<span class="line-added">2616      *            Set to U_NUMBER_SKELETON_SYNTAX_ERROR if the skeleton was invalid.</span>
<span class="line-added">2617      * @return An UnlocalizedNumberFormatter, to be used for chaining.</span>
<span class="line-added">2618      * @draft ICU 64</span>
<span class="line-added">2619      */</span>
<span class="line-added">2620     static UnlocalizedNumberFormatter forSkeleton(const UnicodeString&amp; skeleton,</span>
<span class="line-added">2621                                                   UParseError&amp; perror, UErrorCode&amp; status);</span>
<span class="line-added">2622 </span>
2623     /**
2624      * Use factory methods instead of the constructor to create a NumberFormatter.
2625      */
2626     NumberFormatter() = delete;
2627 };
2628 
2629 }  // namespace number
2630 U_NAMESPACE_END
2631 
2632 #endif  // U_HIDE_DRAFT_API
2633 
2634 #endif // __NUMBERFORMATTER_H__
2635 
2636 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
</tr>
</table>
<center><a href="nounit.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="numfmt.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>