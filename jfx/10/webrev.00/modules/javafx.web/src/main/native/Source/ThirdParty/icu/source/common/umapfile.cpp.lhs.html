<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/umapfile.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 ******************************************************************************
  5 *
  6 *   Copyright (C) 1999-2013, International Business Machines
  7 *   Corporation and others.  All Rights Reserved.
  8 *
  9 ******************************************************************************/
 10 
 11 
 12 /*----------------------------------------------------------------------------
 13  *
 14  *       Memory mapped file wrappers for use by the ICU Data Implementation
 15  *       All of the platform-specific implementation for mapping data files
 16  *         is here.  The rest of the ICU Data implementation uses only the
 17  *         wrapper functions.
 18  *
 19  *----------------------------------------------------------------------------*/
 20 /* Defines _XOPEN_SOURCE for access to POSIX functions.
 21  * Must be before any other #includes. */
 22 #include &quot;uposixdefs.h&quot;
 23 
 24 #include &quot;unicode/putil.h&quot;
<a name="1" id="anc1"></a>
 25 #include &quot;udatamem.h&quot;
 26 #include &quot;umapfile.h&quot;
 27 
 28 /* memory-mapping base definitions ------------------------------------------ */
 29 
 30 #if MAP_IMPLEMENTATION==MAP_WIN32
 31 #ifndef WIN32_LEAN_AND_MEAN
 32 #   define WIN32_LEAN_AND_MEAN
 33 #endif
 34 #   define VC_EXTRALEAN
 35 #   define NOUSER
 36 #   define NOSERVICE
 37 #   define NOIME
 38 #   define NOMCX
<a name="2" id="anc2"></a>













 39 #   include &lt;windows.h&gt;
<a name="3" id="anc3"></a>




 40 #   include &quot;cmemory.h&quot;
 41 
<a name="4" id="anc4"></a><span class="line-modified"> 42     typedef HANDLE MemoryMap;</span>


 43 
<a name="5" id="anc5"></a><span class="line-removed"> 44 #   define IS_MAP(map) ((map)!=NULL)</span>
 45 #elif MAP_IMPLEMENTATION==MAP_POSIX || MAP_IMPLEMENTATION==MAP_390DLL
 46     typedef size_t MemoryMap;
 47 
 48 #   define IS_MAP(map) ((map)!=0)
 49 
 50 #   include &lt;unistd.h&gt;
 51 #   include &lt;sys/mman.h&gt;
 52 #   include &lt;sys/stat.h&gt;
 53 #   include &lt;fcntl.h&gt;
 54 
 55 #   ifndef MAP_FAILED
 56 #       define MAP_FAILED ((void*)-1)
 57 #   endif
 58 
 59 #   if MAP_IMPLEMENTATION==MAP_390DLL
 60         /*   No memory mapping for 390 batch mode.  Fake it using dll loading.  */
 61 #       include &lt;dll.h&gt;
 62 #       include &quot;cstring.h&quot;
 63 #       include &quot;cmemory.h&quot;
 64 #       include &quot;unicode/udata.h&quot;
 65 #       define LIB_PREFIX &quot;lib&quot;
 66 #       define LIB_SUFFIX &quot;.dll&quot;
<a name="6" id="anc6"></a><span class="line-modified"> 67         /* This is inconvienient until we figure out what to do with U_ICUDATA_NAME in utypes.h */</span>
 68 #       define U_ICUDATA_ENTRY_NAME &quot;icudt&quot; U_ICU_VERSION_SHORT U_LIB_SUFFIX_C_NAME_STRING &quot;_dat&quot;
 69 #   endif
 70 #elif MAP_IMPLEMENTATION==MAP_STDIO
 71 #   include &lt;stdio.h&gt;
 72 #   include &quot;cmemory.h&quot;
 73 
 74     typedef void *MemoryMap;
 75 
<a name="7" id="anc7"></a><span class="line-modified"> 76 #   define IS_MAP(map) ((map)!=NULL)</span>
 77 #endif
 78 
 79 /*----------------------------------------------------------------------------*
 80  *                                                                            *
 81  *   Memory Mapped File support.  Platform dependent implementation of        *
 82  *                           functions used by the rest of the implementation.*
 83  *                                                                            *
 84  *----------------------------------------------------------------------------*/
 85 #if MAP_IMPLEMENTATION==MAP_NONE
 86     U_CFUNC UBool
<a name="8" id="anc8"></a><span class="line-modified"> 87     uprv_mapFile(UDataMemory *pData, const char *path) {</span>



 88         UDataMemory_init(pData); /* Clear the output struct. */
 89         return FALSE;            /* no file access */
 90     }
 91 
 92     U_CFUNC void uprv_unmapFile(UDataMemory *pData) {
 93         /* nothing to do */
 94     }
 95 #elif MAP_IMPLEMENTATION==MAP_WIN32
 96     U_CFUNC UBool
 97     uprv_mapFile(
 98          UDataMemory *pData,    /* Fill in with info on the result doing the mapping. */
 99                                 /*   Output only; any original contents are cleared.  */
<a name="9" id="anc9"></a><span class="line-modified">100          const char *path       /* File path to be opened/mapped                      */</span>

101          )
102     {
<a name="10" id="anc10"></a><span class="line-modified">103         HANDLE map;</span>
<span class="line-modified">104         HANDLE file;</span>




105 
106         UDataMemory_init(pData); /* Clear the output struct.        */
107 
108         /* open the input file */
109 #if U_PLATFORM_HAS_WINUWP_API == 0
<a name="11" id="anc11"></a><span class="line-modified">110         file=CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, NULL,</span>




111             OPEN_EXISTING,
<a name="12" id="anc12"></a><span class="line-modified">112             FILE_ATTRIBUTE_NORMAL|FILE_FLAG_RANDOM_ACCESS, NULL);</span>
113 #else
<a name="13" id="anc13"></a><span class="line-modified">114         // First we need to go from char to UTF-16</span>
<span class="line-modified">115         // u_UCharsToChars could work but it requires length.</span>
<span class="line-modified">116         WCHAR utf16Path[MAX_PATH];</span>
<span class="line-modified">117         int32_t i;</span>
<span class="line-removed">118         for (i = 0; i &lt; UPRV_LENGTHOF(utf16Path); i++)</span>
<span class="line-removed">119         {</span>
<span class="line-removed">120             utf16Path[i] = path[i];</span>
<span class="line-removed">121             if (path[i] == &#39;\0&#39;)</span>
<span class="line-removed">122             {</span>
<span class="line-removed">123                 break;</span>
<span class="line-removed">124             }</span>
<span class="line-removed">125         }</span>
<span class="line-removed">126         if (i &gt;= UPRV_LENGTHOF(utf16Path))</span>
<span class="line-removed">127         {</span>
<span class="line-removed">128             // Ran out of room, unlikely but be safe</span>
<span class="line-removed">129             utf16Path[UPRV_LENGTHOF(utf16Path) - 1] = &#39;\0&#39;;</span>
<span class="line-removed">130         }</span>
131 
<a name="14" id="anc14"></a><span class="line-modified">132         // TODO: Is it worth setting extended parameters to specify random access?</span>
<span class="line-modified">133         file = CreateFile2(utf16Path, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, NULL);</span>
<span class="line-modified">134 #endif</span>
<span class="line-modified">135         if(file==INVALID_HANDLE_VALUE) {</span>


136             return FALSE;
137         }
138 
<a name="15" id="anc15"></a><span class="line-modified">139         /* Declare and initialize a security descriptor.</span>
<span class="line-modified">140            This is required for multiuser systems on Windows 2000 SP4 and beyond */</span>
<span class="line-modified">141         // TODO: UWP does not have this function and I do not think it is required?</span>
<span class="line-modified">142 #if U_PLATFORM_HAS_WINUWP_API == 0</span>
<span class="line-modified">143 </span>
<span class="line-modified">144         SECURITY_ATTRIBUTES mappingAttributes;</span>
<span class="line-modified">145         SECURITY_ATTRIBUTES *mappingAttributesPtr = NULL;</span>
<span class="line-modified">146         SECURITY_DESCRIPTOR securityDesc;</span>
<span class="line-modified">147 </span>
<span class="line-removed">148         if (InitializeSecurityDescriptor(&amp;securityDesc, SECURITY_DESCRIPTOR_REVISION)) {</span>
<span class="line-removed">149             /* give the security descriptor a Null Dacl done using the  &quot;TRUE, (PACL)NULL&quot; here */</span>
<span class="line-removed">150             if (SetSecurityDescriptorDacl(&amp;securityDesc, TRUE, (PACL)NULL, FALSE)) {</span>
<span class="line-removed">151                 /* Make the security attributes point to the security descriptor */</span>
<span class="line-removed">152                 uprv_memset(&amp;mappingAttributes, 0, sizeof(mappingAttributes));</span>
<span class="line-removed">153                 mappingAttributes.nLength = sizeof(mappingAttributes);</span>
<span class="line-removed">154                 mappingAttributes.lpSecurityDescriptor = &amp;securityDesc;</span>
<span class="line-removed">155                 mappingAttributes.bInheritHandle = FALSE; /* object uninheritable */</span>
<span class="line-removed">156                 mappingAttributesPtr = &amp;mappingAttributes;</span>
157             }
<a name="16" id="anc16"></a>
158         }
<a name="17" id="anc17"></a><span class="line-removed">159         /* else creating security descriptors can fail when we are on Windows 98,</span>
<span class="line-removed">160            and mappingAttributesPtr == NULL for that case. */</span>
161 
<a name="18" id="anc18"></a>

162         /* create an unnamed Windows file-mapping object for the specified file */
<a name="19" id="anc19"></a><span class="line-modified">163         map=CreateFileMapping(file, mappingAttributesPtr, PAGE_READONLY, 0, 0, NULL);</span>
<span class="line-modified">164 #else</span>
<span class="line-removed">165         map = CreateFileMappingFromApp(file, NULL, PAGE_READONLY, 0, NULL);</span>
<span class="line-removed">166 #endif</span>
167         CloseHandle(file);
<a name="20" id="anc20"></a><span class="line-modified">168         if(map==NULL) {</span>





169             return FALSE;
170         }
171 
172         /* map a view of the file into our address space */
<a name="21" id="anc21"></a><span class="line-modified">173         pData-&gt;pHeader=(const DataHeader *)MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);</span>
<span class="line-modified">174         if(pData-&gt;pHeader==NULL) {</span>
175             CloseHandle(map);
176             return FALSE;
177         }
<a name="22" id="anc22"></a><span class="line-modified">178         pData-&gt;map=map;</span>
179         return TRUE;
180     }
181 
182     U_CFUNC void
183     uprv_unmapFile(UDataMemory *pData) {
<a name="23" id="anc23"></a><span class="line-modified">184         if(pData!=NULL &amp;&amp; pData-&gt;map!=NULL) {</span>
185             UnmapViewOfFile(pData-&gt;pHeader);
186             CloseHandle(pData-&gt;map);
<a name="24" id="anc24"></a><span class="line-modified">187             pData-&gt;pHeader=NULL;</span>
<span class="line-modified">188             pData-&gt;map=NULL;</span>
189         }
190     }
191 
192 
193 
194 #elif MAP_IMPLEMENTATION==MAP_POSIX
195     U_CFUNC UBool
<a name="25" id="anc25"></a><span class="line-modified">196     uprv_mapFile(UDataMemory *pData, const char *path) {</span>
197         int fd;
198         int length;
199         struct stat mystat;
200         void *data;
201 
<a name="26" id="anc26"></a>



202         UDataMemory_init(pData); /* Clear the output struct.        */
203 
204         /* determine the length of the file */
205         if(stat(path, &amp;mystat)!=0 || mystat.st_size&lt;=0) {
206             return FALSE;
207         }
208         length=mystat.st_size;
209 
210         /* open the file */
211         fd=open(path, O_RDONLY);
212         if(fd==-1) {
213             return FALSE;
214         }
215 
216         /* get a view of the mapping */
217 #if U_PLATFORM != U_PF_HPUX
218         data=mmap(0, length, PROT_READ, MAP_SHARED,  fd, 0);
219 #else
220         data=mmap(0, length, PROT_READ, MAP_PRIVATE, fd, 0);
221 #endif
222         close(fd); /* no longer needed */
223         if(data==MAP_FAILED) {
<a name="27" id="anc27"></a>
224             return FALSE;
225         }
226 
227         pData-&gt;map = (char *)data + length;
228         pData-&gt;pHeader=(const DataHeader *)data;
229         pData-&gt;mapAddr = data;
230 #if U_PLATFORM == U_PF_IPHONE
231         posix_madvise(data, length, POSIX_MADV_RANDOM);
232 #endif
233         return TRUE;
234     }
235 
236     U_CFUNC void
237     uprv_unmapFile(UDataMemory *pData) {
<a name="28" id="anc28"></a><span class="line-modified">238         if(pData!=NULL &amp;&amp; pData-&gt;map!=NULL) {</span>
239             size_t dataLen = (char *)pData-&gt;map - (char *)pData-&gt;mapAddr;
240             if(munmap(pData-&gt;mapAddr, dataLen)==-1) {
241             }
<a name="29" id="anc29"></a><span class="line-modified">242             pData-&gt;pHeader=NULL;</span>
243             pData-&gt;map=0;
<a name="30" id="anc30"></a><span class="line-modified">244             pData-&gt;mapAddr=NULL;</span>
245         }
246     }
247 
248 
249 
250 #elif MAP_IMPLEMENTATION==MAP_STDIO
251     /* copy of the filestrm.c/T_FileStream_size() implementation */
252     static int32_t
253     umap_fsize(FILE *f) {
254         int32_t savedPos = ftell(f);
255         int32_t size = 0;
256 
257         /*Changes by Bertrand A. D. doesn&#39;t affect the current position
258         goes to the end of the file before ftell*/
259         fseek(f, 0, SEEK_END);
260         size = (int32_t)ftell(f);
261         fseek(f, savedPos, SEEK_SET);
262         return size;
263     }
264 
265     U_CFUNC UBool
<a name="31" id="anc31"></a><span class="line-modified">266     uprv_mapFile(UDataMemory *pData, const char *path) {</span>
267         FILE *file;
268         int32_t fileLength;
269         void *p;
270 
<a name="32" id="anc32"></a>



271         UDataMemory_init(pData); /* Clear the output struct.        */
272         /* open the input file */
273         file=fopen(path, &quot;rb&quot;);
<a name="33" id="anc33"></a><span class="line-modified">274         if(file==NULL) {</span>
275             return FALSE;
276         }
277 
278         /* get the file length */
279         fileLength=umap_fsize(file);
280         if(ferror(file) || fileLength&lt;=20) {
281             fclose(file);
282             return FALSE;
283         }
284 
285         /* allocate the memory to hold the file data */
286         p=uprv_malloc(fileLength);
<a name="34" id="anc34"></a><span class="line-modified">287         if(p==NULL) {</span>
288             fclose(file);
<a name="35" id="anc35"></a>
289             return FALSE;
290         }
291 
292         /* read the file */
293         if(fileLength!=fread(p, 1, fileLength, file)) {
294             uprv_free(p);
295             fclose(file);
296             return FALSE;
297         }
298 
299         fclose(file);
300         pData-&gt;map=p;
301         pData-&gt;pHeader=(const DataHeader *)p;
302         pData-&gt;mapAddr=p;
303         return TRUE;
304     }
305 
306     U_CFUNC void
307     uprv_unmapFile(UDataMemory *pData) {
<a name="36" id="anc36"></a><span class="line-modified">308         if(pData!=NULL &amp;&amp; pData-&gt;map!=NULL) {</span>
309             uprv_free(pData-&gt;map);
<a name="37" id="anc37"></a><span class="line-modified">310             pData-&gt;map     = NULL;</span>
<span class="line-modified">311             pData-&gt;mapAddr = NULL;</span>
<span class="line-modified">312             pData-&gt;pHeader = NULL;</span>
313         }
314     }
315 
316 
317 #elif MAP_IMPLEMENTATION==MAP_390DLL
318     /*  390 specific Library Loading.
319      *  This is the only platform left that dynamically loads an ICU Data Library.
320      *  All other platforms use .data files when dynamic loading is required, but
321      *  this turn out to be awkward to support in 390 batch mode.
322      *
323      *  The idea here is to hide the fact that 390 is using dll loading from the
324      *   rest of ICU, and make it look like there is file loading happening.
325      *
326      */
327 
328     static char *strcpy_returnEnd(char *dest, const char *src)
329     {
330         while((*dest=*src)!=0) {
331             ++dest;
332             ++src;
333         }
334         return dest;
335     }
336 
337     /*------------------------------------------------------------------------------
338      *
339      *  computeDirPath   given a user-supplied path of an item to be opened,
340      *                         compute and return
341      *                            - the full directory path to be used
342      *                              when opening the file.
343      *                            - Pointer to null at end of above returned path
344      *
345      *                       Parameters:
346      *                          path:        input path.  Buffer is not altered.
347      *                          pathBuffer:  Output buffer.  Any contents are overwritten.
348      *
349      *                       Returns:
350      *                          Pointer to null termination in returned pathBuffer.
351      *
352      *                    TODO:  This works the way ICU historically has, but the
353      *                           whole data fallback search path is so complicated that
<a name="38" id="anc38"></a><span class="line-modified">354      *                           proabably almost no one will ever really understand it,</span>
355      *                           the potential for confusion is large.  (It&#39;s not just
356      *                           this one function, but the whole scheme.)
357      *
358      *------------------------------------------------------------------------------*/
359     static char *uprv_computeDirPath(const char *path, char *pathBuffer)
360     {
361         char   *finalSlash;       /* Ptr to last dir separator in input path, or null if none. */
362         int32_t pathLen;          /* Length of the returned directory path                     */
363 
364         finalSlash = 0;
365         if (path != 0) {
366             finalSlash = uprv_strrchr(path, U_FILE_SEP_CHAR);
367         }
368 
369         *pathBuffer = 0;
370         if (finalSlash == 0) {
371         /* No user-supplied path.
372             * Copy the ICU_DATA path to the path buffer and return that*/
373             const char *icuDataDir;
374             icuDataDir=u_getDataDirectory();
<a name="39" id="anc39"></a><span class="line-modified">375             if(icuDataDir!=NULL &amp;&amp; *icuDataDir!=0) {</span>
376                 return strcpy_returnEnd(pathBuffer, icuDataDir);
377             } else {
378                 /* there is no icuDataDir either.  Just return the empty pathBuffer. */
379                 return pathBuffer;
380             }
381         }
382 
383         /* User supplied path did contain a directory portion.
384         * Copy it to the output path buffer */
385         pathLen = (int32_t)(finalSlash - path + 1);
386         uprv_memcpy(pathBuffer, path, pathLen);
387         *(pathBuffer+pathLen) = 0;
388         return pathBuffer+pathLen;
389     }
390 
391 
392 #   define DATA_TYPE &quot;dat&quot;
393 
<a name="40" id="anc40"></a><span class="line-modified">394     U_CFUNC UBool uprv_mapFile(UDataMemory *pData, const char *path) {</span>
395         const char *inBasename;
396         char *basename;
397         char pathBuffer[1024];
398         const DataHeader *pHeader;
399         dllhandle *handle;
400         void *val=0;
401 
<a name="41" id="anc41"></a>



402         inBasename=uprv_strrchr(path, U_FILE_SEP_CHAR);
<a name="42" id="anc42"></a><span class="line-modified">403         if(inBasename==NULL) {</span>
404             inBasename = path;
405         } else {
406             inBasename++;
407         }
408         basename=uprv_computeDirPath(path, pathBuffer);
409         if(uprv_strcmp(inBasename, U_ICUDATA_NAME&quot;.dat&quot;) != 0) {
410             /* must mmap file... for build */
411             int fd;
412             int length;
413             struct stat mystat;
414             void *data;
415             UDataMemory_init(pData); /* Clear the output struct. */
416 
417             /* determine the length of the file */
418             if(stat(path, &amp;mystat)!=0 || mystat.st_size&lt;=0) {
419                 return FALSE;
420             }
421             length=mystat.st_size;
422 
423             /* open the file */
424             fd=open(path, O_RDONLY);
425             if(fd==-1) {
426                 return FALSE;
427             }
428 
429             /* get a view of the mapping */
430             data=mmap(0, length, PROT_READ, MAP_PRIVATE, fd, 0);
431             close(fd); /* no longer needed */
432             if(data==MAP_FAILED) {
<a name="43" id="anc43"></a>
433                 return FALSE;
434             }
435             pData-&gt;map = (char *)data + length;
436             pData-&gt;pHeader=(const DataHeader *)data;
437             pData-&gt;mapAddr = data;
438             return TRUE;
439         }
440 
441 #       ifdef OS390BATCH
442             /* ### hack: we still need to get u_getDataDirectory() fixed
443             for OS/390 (batch mode - always return &quot;//&quot;? )
444             and this here straightened out with LIB_PREFIX and LIB_SUFFIX (both empty?!)
445             This is probably due to the strange file system on OS/390.  It&#39;s more like
446             a database with short entry names than a typical file system. */
447             /* U_ICUDATA_NAME should always have the correct name */
448             /* BUT FOR BATCH MODE IT IS AN EXCEPTION BECAUSE */
449             /* THE FIRST THREE LETTERS ARE PREASSIGNED TO THE */
450             /* PROJECT!!!!! */
451             uprv_strcpy(pathBuffer, &quot;IXMI&quot; U_ICU_VERSION_SHORT &quot;DA&quot;);
452 #       else
453             /* set up the library name */
454             uprv_strcpy(basename, LIB_PREFIX U_LIBICUDATA_NAME U_ICU_VERSION_SHORT LIB_SUFFIX);
455 #       endif
456 
457 #       ifdef UDATA_DEBUG
458              fprintf(stderr, &quot;dllload: %s &quot;, pathBuffer);
459 #       endif
460 
461         handle=dllload(pathBuffer);
462 
463 #       ifdef UDATA_DEBUG
464                fprintf(stderr, &quot; -&gt; %08X\n&quot;, handle );
465 #       endif
466 
<a name="44" id="anc44"></a><span class="line-modified">467         if(handle != NULL) {</span>
468                /* we have a data DLL - what kind of lookup do we need here? */
469                /* try to find the Table of Contents */
470                UDataMemory_init(pData); /* Clear the output struct.        */
471                val=dllqueryvar((dllhandle*)handle, U_ICUDATA_ENTRY_NAME);
472                if(val == 0) {
473                     /* failed... so keep looking */
474                     return FALSE;
475                }
476 #              ifdef UDATA_DEBUG
477                     fprintf(stderr, &quot;dllqueryvar(%08X, %s) -&gt; %08X\n&quot;, handle, U_ICUDATA_ENTRY_NAME, val);
478 #              endif
479 
480                pData-&gt;pHeader=(const DataHeader *)val;
481                return TRUE;
482          } else {
483                return FALSE; /* no handle */
484          }
485     }
486 
487     U_CFUNC void uprv_unmapFile(UDataMemory *pData) {
<a name="45" id="anc45"></a><span class="line-modified">488         if(pData!=NULL &amp;&amp; pData-&gt;map!=NULL) {</span>
489             uprv_free(pData-&gt;map);
<a name="46" id="anc46"></a><span class="line-modified">490             pData-&gt;map     = NULL;</span>
<span class="line-modified">491             pData-&gt;mapAddr = NULL;</span>
<span class="line-modified">492             pData-&gt;pHeader = NULL;</span>
493         }
494     }
495 
496 #else
497 #   error MAP_IMPLEMENTATION is set incorrectly
498 #endif
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>