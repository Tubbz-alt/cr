<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbiscan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="rbbirpt.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbbiscan.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbiscan.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 363             thisRule-&gt;fChainIn = TRUE;
 364         }
 365 
 366 
 367         // All rule expressions are ORed together.
 368         // The &#39;;&#39; that terminates an expression really just functions as a &#39;|&#39; with
 369         //   a low operator prededence.
 370         //
 371         // Each of the four sets of rules are collected separately.
 372         //  (forward, reverse, safe_forward, safe_reverse)
 373         //  OR this rule into the appropriate group of them.
 374         //
 375         RBBINode **destRules = (fReverseRule? &amp;fRB-&gt;fSafeRevTree : fRB-&gt;fDefaultTree);
 376 
 377         if (*destRules != NULL) {
 378             // This is not the first rule encounted.
 379             // OR previous stuff  (from *destRules)
 380             // with the current rule expression (on the Node Stack)
 381             //  with the resulting OR expression going to *destRules
 382             //
<span class="line-modified"> 383             RBBINode  *thisRule    = fNodeStack[fNodeStackPtr];</span>
 384             RBBINode  *prevRules   = *destRules;
 385             RBBINode  *orNode      = pushNewNode(RBBINode::opOr);
 386             if (U_FAILURE(*fRB-&gt;fStatus)) {
 387                 break;
 388             }
 389             orNode-&gt;fLeftChild     = prevRules;
 390             prevRules-&gt;fParent     = orNode;
 391             orNode-&gt;fRightChild    = thisRule;
 392             thisRule-&gt;fParent      = orNode;
 393             *destRules             = orNode;
 394         }
 395         else
 396         {
 397             // This is the first rule encountered (for this direction).
 398             // Just move its parse tree from the stack to *destRules.
 399             *destRules = fNodeStack[fNodeStackPtr];
 400         }
 401         fReverseRule   = FALSE;   // in preparation for the next rule.
 402         fLookAheadRule = FALSE;
 403         fNoChainInRule = FALSE;
</pre>
</td>
<td>
<hr />
<pre>
 363             thisRule-&gt;fChainIn = TRUE;
 364         }
 365 
 366 
 367         // All rule expressions are ORed together.
 368         // The &#39;;&#39; that terminates an expression really just functions as a &#39;|&#39; with
 369         //   a low operator prededence.
 370         //
 371         // Each of the four sets of rules are collected separately.
 372         //  (forward, reverse, safe_forward, safe_reverse)
 373         //  OR this rule into the appropriate group of them.
 374         //
 375         RBBINode **destRules = (fReverseRule? &amp;fRB-&gt;fSafeRevTree : fRB-&gt;fDefaultTree);
 376 
 377         if (*destRules != NULL) {
 378             // This is not the first rule encounted.
 379             // OR previous stuff  (from *destRules)
 380             // with the current rule expression (on the Node Stack)
 381             //  with the resulting OR expression going to *destRules
 382             //
<span class="line-modified"> 383                        thisRule    = fNodeStack[fNodeStackPtr];</span>
 384             RBBINode  *prevRules   = *destRules;
 385             RBBINode  *orNode      = pushNewNode(RBBINode::opOr);
 386             if (U_FAILURE(*fRB-&gt;fStatus)) {
 387                 break;
 388             }
 389             orNode-&gt;fLeftChild     = prevRules;
 390             prevRules-&gt;fParent     = orNode;
 391             orNode-&gt;fRightChild    = thisRule;
 392             thisRule-&gt;fParent      = orNode;
 393             *destRules             = orNode;
 394         }
 395         else
 396         {
 397             // This is the first rule encountered (for this direction).
 398             // Just move its parse tree from the stack to *destRules.
 399             *destRules = fNodeStack[fNodeStackPtr];
 400         }
 401         fReverseRule   = FALSE;   // in preparation for the next rule.
 402         fLookAheadRule = FALSE;
 403         fNoChainInRule = FALSE;
</pre>
</td>
</tr>
</table>
<center><a href="rbbirpt.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbbiscan.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>