<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbicst.pl</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 #**************************************************************************
  2 #   Copyright (C) 2016 and later: Unicode, Inc. and others.
  3 #   License &amp; terms of use: http://www.unicode.org/copyright.html#License
  4 #**************************************************************************
  5 #**************************************************************************
  6 #   Copyright (C) 2002-2016 International Business Machines Corporation
  7 #   and others. All rights reserved.
  8 #**************************************************************************
  9 #
 10 #  rbbicst   Compile the RBBI rule paser state table data into initialized C data.
 11 #            Usage:
 12 #                   cd icu/source/common
 13 #                   perl rbbicst.pl    &lt; rbbirpt.txt &gt; rbbirpt.h
 14 #                   perl rbbicst.pl -j &lt; rbbirpt.txt &gt; RBBIRuleParseTable.java
 15 #
 16 #             The output file, rbbrpt.h, is included by some of the .cpp rbbi
 17 #             implementation files.   This perl script is NOT run as part
 18 #             of a normal ICU build.  It is run by hand when needed, and the
 19 #             rbbirpt.h generated file is put back into cvs.
 20 #
 21 #             See rbbirpt.txt for a description of the input format for this script.
 22 #
 23 
 24 if ($ARGV[0] eq &quot;-j&quot;) {
 25     $javaOutput = 1;
 26     shift @ARGV;
 27 }
 28 
 29 
 30 $num_states = 1;     # Always the state number for the line being compiled.
 31 $line_num  = 0;      # The line number in the input file.
 32 
 33 $states{&quot;pop&quot;} = 255;    # Add the &quot;pop&quot;  to the list of defined state names.
 34                          # This prevents any state from being labelled with &quot;pop&quot;,
 35                          #  and resolves references to &quot;pop&quot; in the next state field.
 36 
 37 line_loop: while (&lt;&gt;) {
 38     chomp();
 39     $line = $_;
 40     @fields = split();
 41     $line_num++;
 42 
 43     # Remove # comments, which are any fields beginning with a #, plus all
 44     #  that follow on the line.
 45     for ($i=0; $i&lt;@fields; $i++) {
 46         if ($fields[$i] =~ /^#/) {
 47             @fields = @fields[0 .. $i-1];
 48             last;
 49         }
 50     }
 51     # ignore blank lines, and those with no fields left after stripping comments..
 52     if (@fields == 0) {
 53         next;
 54     }
 55 
 56     #
 57     # State Label:  handling.
 58     #    Does the first token end with a &quot;:&quot;?  If so, it&#39;s the name  of a state.
 59     #    Put in a hash, together with the current state number,
 60     #        so that we can later look up the number from the name.
 61     #
 62     if (@fields[0] =~ /.*:$/) {
 63         $state_name = @fields[0];
 64         $state_name =~ s/://;        # strip off the colon from the state name.
 65 
 66         if ($states{$state_name} != 0) {
 67             print &quot;  rbbicst: at line $line-num duplicate definition of state $state_name\n&quot;;
 68         }
 69         $states{$state_name} = $num_states;
 70         $stateNames[$num_states] = $state_name;
 71 
 72         # if the label was the only thing on this line, go on to the next line,
 73         # otherwise assume that a state definition is on the same line and fall through.
 74         if (@fields == 1) {
 75             next line_loop;
 76         }
 77         shift @fields;                       # shift off label field in preparation
 78                                              #  for handling the rest of the line.
 79     }
 80 
 81     #
 82     # State Transition line.
 83     #   syntax is this,
 84     #       character   [n]  target-state  [^push-state]  [function-name]
 85     #   where
 86     #      [something]   is an optional something
 87     #      character     is either a single quoted character e.g. &#39;[&#39;
 88     #                       or a name of a character class, e.g. white_space
 89     #
 90 
 91     $state_line_num[$num_states] = $line_num;   # remember line number with each state
 92                                                 #  so we can make better error messages later.
 93     #
 94     # First field, character class or literal character for this transition.
 95     #
 96     if ($fields[0] =~ /^&#39;.&#39;$/) {
 97         # We&#39;ve got a quoted literal character.
 98         $state_literal_chars[$num_states] = $fields[0];
 99         $state_literal_chars[$num_states] =~ s/&#39;//g;
100     } else {
101         # We&#39;ve got the name of a character class.
102         $state_char_class[$num_states] = $fields[0];
103         if ($fields[0] =~ /[\W]/) {
104             print &quot;  rbbicsts:  at line $line_num, bad character literal or character class name.\n&quot;;
105             print &quot;     scanning $fields[0]\n&quot;;
106             exit(-1);
107         }
108     }
109     shift @fields;
110 
111     #
112     # do the &#39;n&#39; flag
113     #
114     $state_flag[$num_states] = $javaOutput? &quot;false&quot; : &quot;FALSE&quot;;
115     if ($fields[0] eq &quot;n&quot;) {
116         $state_flag[$num_states] = $javaOutput? &quot;true&quot;: &quot;TRUE&quot;;
117         shift @fields;
118     }
119 
120     #
121     # do the destination state.
122     #
123     $state_dest_state[$num_states] = $fields[0];
124     if ($fields[0] eq &quot;&quot;) {
125         print &quot;  rbbicsts:  at line $line_num, destination state missing.\n&quot;;
126         exit(-1);
127     }
128     shift @fields;
129 
130     #
131     # do the push state, if present.
132     #
133     if ($fields[0] =~ /^\^/) {
134         $fields[0] =~ s/^\^//;
135         $state_push_state[$num_states] = $fields[0];
136         if ($fields[0] eq &quot;&quot; ) {
137             print &quot;  rbbicsts:  at line $line_num, expected state after ^ (no spaces).\n&quot;;
138             exit(-1);
139         }
140         shift @fields;
141     }
142 
143     #
144     # Lastly, do the optional action name.
145     #
146     if ($fields[0] ne &quot;&quot;) {
147         $state_func_name[$num_states] = $fields[0];
148         shift @fields;
149     }
150 
151     #
152     #  There should be no fields left on the line at this point.
153     #
154     if (@fields &gt; 0) {
155        print &quot;  rbbicsts:  at line $line_num, unexpected extra stuff on input line.\n&quot;;
156        print &quot;     scanning $fields[0]\n&quot;;
157    }
158    $num_states++;
159 }
160 
161 #
162 # We&#39;ve read in the whole file, now go back and output the
163 #   C source code for the state transition table.
164 #
165 # We read all states first, before writing anything,  so that the state numbers
166 # for the destination states are all available to be written.
167 #
168 
169 #
170 # Make hashes for the names of the character classes and
171 #      for the names of the actions that appeared.
172 #
173 for ($state=1; $state &lt; $num_states; $state++) {
174     if ($state_char_class[$state] ne &quot;&quot;) {
175         if ($charClasses{$state_char_class[$state]} == 0) {
176             $charClasses{$state_char_class[$state]} = 1;
177         }
178     }
179     if ($state_func_name[$state] eq &quot;&quot;) {
180         $state_func_name[$state] = &quot;doNOP&quot;;
181     }
182     if ($actions{$state_action_name[$state]} == 0) {
183         $actions{$state_func_name[$state]} = 1;
184     }
185 }
186 
187 #
188 # Check that all of the destination states have been defined
189 #
190 #
191 $states{&quot;exit&quot;} = 0;              # Predefined state name, terminates state machine.
192 for ($state=1; $state&lt;$num_states; $state++) {
193    if ($states{$state_dest_state[$state]} == 0 &amp;&amp; $state_dest_state[$state] ne &quot;exit&quot;) {
194        print &quot;Error at line $state_line_num[$state]: target state \&quot;$state_dest_state[$state]\&quot; is not defined.\n&quot;;
195        $errors++;
196    }
197    if ($state_push_state[$state] ne &quot;&quot; &amp;&amp; $states{$state_push_state[$state]} == 0) {
198        print &quot;Error at line $state_line_num[$state]: target state \&quot;$state_push_state[$state]\&quot; is not defined.\n&quot;;
199        $errors++;
200    }
201 }
202 
203 die if ($errors&gt;0);
204 
205 #
206 # Assign numbers to each of the character classes classes  used.
207 #   Sets are numbered from 128 - 250
208 #   The values 0-127 in the state table are used for matching
209 #     individual ASCII characters (the only thing that can appear in the rules.)
210 #   The &quot;set&quot; names appearing in the code below (default, etc.)  need special
211 #     handling because they do not correspond to a normal set of characters,
212 #     but trigger special handling by code in the state machine.
213 #
214 $i = 128;
215 foreach $setName (sort keys %charClasses) {
216     if ($setName eq &quot;default&quot;) {
217         $charClasses{$setName} = 255;}
218     elsif ($setName eq &quot;escaped&quot;) {
219         $charClasses{$setName} = 254;}
220     elsif ($setName eq &quot;escapedP&quot;) {
221         $charClasses{$setName} = 253;}
222     elsif ($setName eq &quot;eof&quot;) {
223         $charClasses{$setName} = 252;}
224     else {
225         # Normal (single) character class.  Number them.
226         $charClasses{$setName} = $i;
227         $i++;
228     }
229 }
230 
231 
232 my ($sec, $min, $hour, , $day, $mon, $year, $wday, $yday, $isdst) = localtime;
233 $year += 1900;
234 
235 if ($javaOutput) {
236     print &quot;/*\n&quot;;
237     print &quot; *******************************************************************************\n&quot;;
238     print &quot; * Copyright (C) 2003-$year,\n&quot;;
239     print &quot; * International Business Machines Corporation and others. All Rights Reserved.\n&quot;;
240     print &quot; *******************************************************************************\n&quot;;
241     print &quot; */\n&quot;;
242     print &quot; \n&quot;;
243     print &quot;package com.ibm.icu.text;\n&quot;;
244     print &quot; \n&quot;;
245     print &quot;/**\n&quot;;
246     print &quot; * Generated Java File.  Do not edit by hand.\n&quot;;
247     print &quot; * This file contains the state table for the ICU Rule Based Break Iterator\n&quot;;
248     print &quot; * rule parser.\n&quot;;
249     print &quot; * It is generated by the Perl script \&quot;rbbicst.pl\&quot; from\n&quot;;
250     print &quot; * the rule parser state definitions file \&quot;rbbirpt.txt\&quot;.\n&quot;;
251     print &quot; * \@internal \n&quot;;
252     print &quot; *\n&quot;;
253     print &quot; */\n&quot;;
254 
255     print &quot;class RBBIRuleParseTable\n&quot;;
256     print &quot;{\n&quot;;
257 
258      #
259     # Emit the constants for the actions to be performed.
260     #
261     $n = 1;
262     foreach $act (sort keys %actions) {
263         print &quot;     static final short $act = $n;\n&quot;;
264         $n++;
265     }
266     print &quot; \n&quot;;
267 
268     #
269     # Emit constants for char class names
270     #
271     foreach $setName (sort keys %charClasses) {
272        print &quot;     static final short kRuleSet_$setName = $charClasses{$setName};\n&quot;;
273     }
274     print &quot;\n\n&quot;;
275 
276 
277     print &quot;   static class RBBIRuleTableElement { \n&quot;;
278     print &quot;      short      fAction; \n&quot;;
279     print &quot;      short      fCharClass; \n&quot;;
280     print &quot;      short      fNextState; \n&quot;;
281     print &quot;      short      fPushState; \n&quot;;
282     print &quot;      boolean    fNextChar;  \n&quot;;
283     print &quot;      String     fStateName; \n&quot;;
284     print &quot;      RBBIRuleTableElement(short a, int cc, int ns, int ps, boolean nc, String sn) {  \n&quot;;
285     print &quot;      fAction = a; \n&quot;;
286     print &quot;      fCharClass = (short)cc; \n&quot;;
287     print &quot;      fNextState = (short)ns; \n&quot;;
288     print &quot;      fPushState = (short)ps; \n&quot;;
289     print &quot;      fNextChar  = nc; \n&quot;;
290     print &quot;      fStateName = sn; \n&quot;;
291     print &quot;   } \n&quot;;
292     print &quot;   }; \n&quot;;
293     print &quot;  \n&quot;;
294 
295 
296     print &quot;    static RBBIRuleTableElement[] gRuleParseStateTable = { \n &quot;;
297     print &quot;      new RBBIRuleTableElement(doNOP, 0, 0,0,  true,   null )     //  0 \n&quot;;  #output the unused state 0.
298     for ($state=1; $state &lt; $num_states; $state++) {
299         print &quot;     , new RBBIRuleTableElement($state_func_name[$state],&quot;;
300         if ($state_literal_chars[$state] ne &quot;&quot;) {
301             $c = $state_literal_chars[$state];
302             print(&quot;&#39;$c&#39;, &quot;);
303         }else {
304             print &quot; $charClasses{$state_char_class[$state]},&quot;;
305         }
306         print &quot; $states{$state_dest_state[$state]},&quot;;
307 
308         # The push-state field is optional.  If omitted, fill field with a zero, which flags
309         #   the state machine that there is no push state.
310         if ($state_push_state[$state] eq &quot;&quot;) {
311             print &quot;0, &quot;;
312         } else {
313             print &quot; $states{$state_push_state[$state]},&quot;;
314         }
315         print &quot; $state_flag[$state], &quot;;
316 
317         # if this is the first row of the table for this state, put out the state name.
318         if ($stateNames[$state] ne &quot;&quot;) {
319             print &quot;  \&quot;$stateNames[$state]\&quot;) &quot;;
320         } else {
321             print &quot;  null ) &quot;;
322         }
323 
324         # Put out a comment showing the number (index) of this state row,
325         print &quot;    //  $state &quot;;
326         print &quot;\n&quot;;
327     }
328     print &quot; };\n&quot;;
329 
330     print &quot;}; \n&quot;;
331 
332 }
333 else
334 {
335     #
336     #  C++ Output ...
337     #
338 
339 
340     print &quot;//---------------------------------------------------------------------------------\n&quot;;
341     print &quot;//\n&quot;;
342     print &quot;// Generated Header File.  Do not edit by hand.\n&quot;;
343     print &quot;//    This file contains the state table for the ICU Rule Based Break Iterator\n&quot;;
344     print &quot;//    rule parser.\n&quot;;
345     print &quot;//    It is generated by the Perl script \&quot;rbbicst.pl\&quot; from\n&quot;;
346     print &quot;//    the rule parser state definitions file \&quot;rbbirpt.txt\&quot;.\n&quot;;
347     print &quot;//\n&quot;;
348     print &quot;//   Copyright (C) 2002-$year International Business Machines Corporation \n&quot;;
349     print &quot;//   and others. All rights reserved.  \n&quot;;
350     print &quot;//\n&quot;;
351     print &quot;//---------------------------------------------------------------------------------\n&quot;;
352     print &quot;#ifndef RBBIRPT_H\n&quot;;
353     print &quot;#define RBBIRPT_H\n&quot;;
354     print &quot;\n&quot;;
355     print &quot;#include \&quot;unicode/utypes.h\&quot;\n&quot;;
356     print &quot;\n&quot;;
357     print &quot;U_NAMESPACE_BEGIN\n&quot;;
358 
359     #
360     # Emit the constants for indicies of Unicode Sets
361     #   Define one constant for each of the character classes encountered.
362     #   At the same time, store the index corresponding to the set name back into hash.
363     #
364     print &quot;//\n&quot;;
365     print &quot;// Character classes for RBBI rule scanning.\n&quot;;
366     print &quot;//\n&quot;;
367     foreach $setName (sort keys %charClasses) {
368         if ($charClasses{$setName} &lt; 250) {
369            # Normal character class.
370            print &quot;    static const uint8_t kRuleSet_$setName = $charClasses{$setName};\n&quot;;
371         }
372     }
373     print &quot;\n\n&quot;;
374 
375     #
376     # Emit the enum for the actions to be performed.
377     #
378     print &quot;enum RBBI_RuleParseAction {\n&quot;;
379     foreach $act (sort keys %actions) {
380         print &quot;    $act,\n&quot;;
381     }
382     print &quot;    rbbiLastAction};\n\n&quot;;
383 
384     #
385     # Emit the struct definition for transtion table elements.
386     #
387     print &quot;//-------------------------------------------------------------------------------\n&quot;;
388     print &quot;//\n&quot;;
389     print &quot;//  RBBIRuleTableEl    represents the structure of a row in the transition table\n&quot;;
390     print &quot;//                     for the rule parser state machine.\n&quot;;
391     print &quot;//-------------------------------------------------------------------------------\n&quot;;
392     print &quot;struct RBBIRuleTableEl {\n&quot;;
393     print &quot;    RBBI_RuleParseAction          fAction;\n&quot;;
394     print &quot;    uint8_t                       fCharClass;       // 0-127:    an individual ASCII character\n&quot;;
395     print &quot;                                                    // 128-255:  character class index\n&quot;;
396     print &quot;    uint8_t                       fNextState;       // 0-250:    normal next-stat numbers\n&quot;;
397     print &quot;                                                    // 255:      pop next-state from stack.\n&quot;;
398     print &quot;    uint8_t                       fPushState;\n&quot;;
399     print &quot;    UBool                         fNextChar;\n&quot;;
400     print &quot;};\n\n&quot;;
401 
402     #
403     # emit the state transition table
404     #
405     print &quot;static const struct RBBIRuleTableEl gRuleParseStateTable[] = {\n&quot;;
406     print &quot;    {doNOP, 0, 0, 0, TRUE}\n&quot;;    # State 0 is a dummy.  Real states start with index = 1.
407     for ($state=1; $state &lt; $num_states; $state++) {
408         print &quot;    , {$state_func_name[$state],&quot;;
409         if ($state_literal_chars[$state] ne &quot;&quot;) {
410             $c = $state_literal_chars[$state];
411             printf(&quot; %d /* $c */,&quot;, ord($c));   #  use numeric value, so EBCDIC machines are ok.
412         }else {
413             print &quot; $charClasses{$state_char_class[$state]},&quot;;
414         }
415         print &quot; $states{$state_dest_state[$state]},&quot;;
416 
417         # The push-state field is optional.  If omitted, fill field with a zero, which flags
418         #   the state machine that there is no push state.
419         if ($state_push_state[$state] eq &quot;&quot;) {
420             print &quot;0, &quot;;
421         } else {
422             print &quot; $states{$state_push_state[$state]},&quot;;
423         }
424         print &quot; $state_flag[$state]} &quot;;
425 
426         # Put out a C++ comment showing the number (index) of this state row,
427         #   and, if this is the first row of the table for this state, the state name.
428         print &quot;    //  $state &quot;;
429         if ($stateNames[$state] ne &quot;&quot;) {
430             print &quot;     $stateNames[$state]&quot;;
431         }
432         print &quot;\n&quot;;
433     };
434     print &quot; };\n&quot;;
435 
436 
437     #
438     # emit a mapping array from state numbers to state names.
439     #
440     #    This array is used for producing debugging output from the rule parser.
441     #
442     print &quot;#ifdef RBBI_DEBUG\n&quot;;
443     print &quot;static const char * const RBBIRuleStateNames[] = {&quot;;
444     for ($state=0; $state&lt;$num_states; $state++) {
445         if ($stateNames[$state] ne &quot;&quot;) {
446             print &quot;     \&quot;$stateNames[$state]\&quot;,\n&quot;;
447         } else {
448             print &quot;    0,\n&quot;;
449         }
450     }
451     print &quot;    0};\n&quot;;
452     print &quot;#endif\n\n&quot;;
453 
454     print &quot;U_NAMESPACE_END\n&quot;;
455     print &quot;#endif\n&quot;;
456 }
457 
458 
459 
    </pre>
  </body>
</html>