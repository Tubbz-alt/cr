<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/cmemory.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="charstr.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="common.rc.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/cmemory.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 #include &quot;unicode/localpointer.h&quot;
 34 
 35 #if U_DEBUG &amp;&amp; defined(UPRV_MALLOC_COUNT)
 36 #include &lt;stdio.h&gt;
 37 #endif
 38 
 39 
 40 #define uprv_memcpy(dst, src, size) U_STANDARD_CPP_NAMESPACE memcpy(dst, src, size)
 41 #define uprv_memmove(dst, src, size) U_STANDARD_CPP_NAMESPACE memmove(dst, src, size)
 42 
 43 /**
 44  * \def UPRV_LENGTHOF
 45  * Convenience macro to determine the length of a fixed array at compile-time.
 46  * @param array A fixed length array
 47  * @return The length of the array, in elements
 48  * @internal
 49  */
 50 #define UPRV_LENGTHOF(array) (int32_t)(sizeof(array)/sizeof((array)[0]))
 51 #define uprv_memset(buffer, mark, size) U_STANDARD_CPP_NAMESPACE memset(buffer, mark, size)
 52 #define uprv_memcmp(buffer1, buffer2, size) U_STANDARD_CPP_NAMESPACE memcmp(buffer1, buffer2,size)

 53 
 54 U_CAPI void * U_EXPORT2
 55 uprv_malloc(size_t s) U_MALLOC_ATTR U_ALLOC_SIZE_ATTR(1);
 56 
 57 U_CAPI void * U_EXPORT2
 58 uprv_realloc(void *mem, size_t size) U_ALLOC_SIZE_ATTR(2);
 59 
 60 U_CAPI void U_EXPORT2
 61 uprv_free(void *mem);
 62 
 63 U_CAPI void * U_EXPORT2
 64 uprv_calloc(size_t num, size_t size) U_MALLOC_ATTR U_ALLOC_SIZE_ATTR2(1,2);
 65 
 66 /**
 67  * This should align the memory properly on any machine.
 68  * This is very useful for the safeClone functions.
 69  */
 70 typedef union {
 71     long    t1;
 72     double  t2;
</pre>
<hr />
<pre>
105 cmemory_cleanup(void);
106 
107 /**
108  * A function called by &lt;TT&gt;uhash_remove&lt;/TT&gt;,
109  * &lt;TT&gt;uhash_close&lt;/TT&gt;, or &lt;TT&gt;uhash_put&lt;/TT&gt; to delete
110  * an existing key or value.
111  * @param obj A key or value stored in a hashtable
112  * @see uprv_deleteUObject
113  */
114 typedef void U_CALLCONV UObjectDeleter(void* obj);
115 
116 /**
117  * Deleter for UObject instances.
118  * Works for all subclasses of UObject because it has a virtual destructor.
119  */
120 U_CAPI void U_EXPORT2
121 uprv_deleteUObject(void *obj);
122 
123 #ifdef __cplusplus
124 



125 U_NAMESPACE_BEGIN
126 
127 /**
128  * &quot;Smart pointer&quot; class, deletes memory via uprv_free().
129  * For most methods see the LocalPointerBase base class.
130  * Adds operator[] for array item access.
131  *
132  * @see LocalPointerBase
133  */
134 template&lt;typename T&gt;
135 class LocalMemory : public LocalPointerBase&lt;T&gt; {
136 public:
137     using LocalPointerBase&lt;T&gt;::operator*;
138     using LocalPointerBase&lt;T&gt;::operator-&gt;;
139     /**
140      * Constructor takes ownership.
141      * @param p simple pointer to an array of T items that is adopted
142      */
143     explicit LocalMemory(T *p=NULL) : LocalPointerBase&lt;T&gt;(p) {}
144     /**
145      * Move constructor, leaves src with isNull().
146      * @param src source smart pointer
147      */
148     LocalMemory(LocalMemory&lt;T&gt; &amp;&amp;src) U_NOEXCEPT : LocalPointerBase&lt;T&gt;(src.ptr) {
149         src.ptr=NULL;
150     }
151     /**
152      * Destructor deletes the memory it owns.
153      */
154     ~LocalMemory() {
155         uprv_free(LocalPointerBase&lt;T&gt;::ptr);
156     }
157     /**
158      * Move assignment operator, leaves src with isNull().
159      * The behavior is undefined if *this and src are the same object.
160      * @param src source smart pointer
161      * @return *this
162      */
163     LocalMemory&lt;T&gt; &amp;operator=(LocalMemory&lt;T&gt; &amp;&amp;src) U_NOEXCEPT {
<span class="line-modified">164         return moveFrom(src);</span>
<span class="line-removed">165     }</span>
<span class="line-removed">166     /**</span>
<span class="line-removed">167      * Move assignment, leaves src with isNull().</span>
<span class="line-removed">168      * The behavior is undefined if *this and src are the same object.</span>
<span class="line-removed">169      *</span>
<span class="line-removed">170      * Can be called explicitly, does not need C++11 support.</span>
<span class="line-removed">171      * @param src source smart pointer</span>
<span class="line-removed">172      * @return *this</span>
<span class="line-removed">173      */</span>
<span class="line-removed">174     LocalMemory&lt;T&gt; &amp;moveFrom(LocalMemory&lt;T&gt; &amp;src) U_NOEXCEPT {</span>
<span class="line-removed">175         delete[] LocalPointerBase&lt;T&gt;::ptr;</span>
176         LocalPointerBase&lt;T&gt;::ptr=src.ptr;
177         src.ptr=NULL;
178         return *this;
179     }
180     /**
181      * Swap pointers.
182      * @param other other smart pointer
183      */
184     void swap(LocalMemory&lt;T&gt; &amp;other) U_NOEXCEPT {
185         T *temp=LocalPointerBase&lt;T&gt;::ptr;
186         LocalPointerBase&lt;T&gt;::ptr=other.ptr;
187         other.ptr=temp;
188     }
189     /**
190      * Non-member LocalMemory swap function.
191      * @param p1 will get p2&#39;s pointer
192      * @param p2 will get p1&#39;s pointer
193      */
194     friend inline void swap(LocalMemory&lt;T&gt; &amp;p1, LocalMemory&lt;T&gt; &amp;p2) U_NOEXCEPT {
195         p1.swap(p2);
</pre>
<hr />
<pre>
262             }
263             uprv_free(LocalPointerBase&lt;T&gt;::ptr);
264             LocalPointerBase&lt;T&gt;::ptr=p;
265         }
266         return p;
267     } else {
268         return NULL;
269     }
270 }
271 
272 /**
273  * Simple array/buffer management class using uprv_malloc() and uprv_free().
274  * Provides an internal array with fixed capacity. Can alias another array
275  * or allocate one.
276  *
277  * The array address is properly aligned for type T. It might not be properly
278  * aligned for types larger than T (or larger than the largest subtype of T).
279  *
280  * Unlike LocalMemory and LocalArray, this class never adopts
281  * (takes ownership of) another array.




282  */
283 template&lt;typename T, int32_t stackCapacity&gt;
284 class MaybeStackArray {
285 public:







286     /**
287      * Default constructor initializes with internal T[stackCapacity] buffer.
288      */
289     MaybeStackArray() : ptr(stackArray), capacity(stackCapacity), needToRelease(FALSE) {}
290     /**
291      * Automatically allocates the heap array if the argument is larger than the stack capacity.
292      * Intended for use when an approximate capacity is known at compile time but the true
293      * capacity is not known until runtime.
294      */
295     MaybeStackArray(int32_t newCapacity) : MaybeStackArray() {
296         if (capacity &lt; newCapacity) { resize(newCapacity); }
<span class="line-modified">297     };</span>
298     /**
299      * Destructor deletes the array (if owned).
300      */
301     ~MaybeStackArray() { releaseArray(); }
302     /**
303      * Move constructor: transfers ownership or copies the stack array.
304      */
305     MaybeStackArray(MaybeStackArray&lt;T, stackCapacity&gt; &amp;&amp;src) U_NOEXCEPT;
306     /**
307      * Move assignment: transfers ownership or copies the stack array.
308      */
309     MaybeStackArray&lt;T, stackCapacity&gt; &amp;operator=(MaybeStackArray&lt;T, stackCapacity&gt; &amp;&amp;src) U_NOEXCEPT;
310     /**
311      * Returns the array capacity (number of T items).
312      * @return array capacity
313      */
314     int32_t getCapacity() const { return capacity; }
315     /**
316      * Access without ownership change.
317      * @return the array pointer
</pre>
<hr />
<pre>
378     T *ptr;
379     int32_t capacity;
380     UBool needToRelease;
381     T stackArray[stackCapacity];
382     void releaseArray() {
383         if(needToRelease) {
384             uprv_free(ptr);
385         }
386     }
387     void resetToStackArray() {
388         ptr=stackArray;
389         capacity=stackCapacity;
390         needToRelease=FALSE;
391     }
392     /* No comparison operators with other MaybeStackArray&#39;s. */
393     bool operator==(const MaybeStackArray &amp; /*other*/) {return FALSE;}
394     bool operator!=(const MaybeStackArray &amp; /*other*/) {return TRUE;}
395     /* No ownership transfer: No copy constructor, no assignment operator. */
396     MaybeStackArray(const MaybeStackArray &amp; /*other*/) {}
397     void operator=(const MaybeStackArray &amp; /*other*/) {}
<span class="line-removed">398 </span>
<span class="line-removed">399     // No heap allocation. Use only on the stack.</span>
<span class="line-removed">400     //   (Declaring these functions private triggers a cascade of problems:</span>
<span class="line-removed">401     //      MSVC insists on exporting an instantiation of MaybeStackArray, which</span>
<span class="line-removed">402     //      requires that all functions be defined.</span>
<span class="line-removed">403     //      An empty implementation of new() is rejected, it must return a value.</span>
<span class="line-removed">404     //      Returning NULL is rejected by gcc for operator new.</span>
<span class="line-removed">405     //      The expedient thing is just not to override operator new.</span>
<span class="line-removed">406     //      While relatively pointless, heap allocated instances will function.</span>
<span class="line-removed">407     // static void * U_EXPORT2 operator new(size_t size);</span>
<span class="line-removed">408     // static void * U_EXPORT2 operator new[](size_t size);</span>
<span class="line-removed">409 #if U_HAVE_PLACEMENT_NEW</span>
<span class="line-removed">410     // static void * U_EXPORT2 operator new(size_t, void *ptr);</span>
<span class="line-removed">411 #endif</span>
412 };
413 
414 template&lt;typename T, int32_t stackCapacity&gt;
415 icu::MaybeStackArray&lt;T, stackCapacity&gt;::MaybeStackArray(
416         MaybeStackArray &lt;T, stackCapacity&gt;&amp;&amp; src) U_NOEXCEPT
417         : ptr(src.ptr), capacity(src.capacity), needToRelease(src.needToRelease) {
418     if (src.ptr == src.stackArray) {
419         ptr = stackArray;
420         uprv_memcpy(stackArray, src.stackArray, sizeof(T) * src.capacity);
421     } else {
422         src.resetToStackArray();  // take ownership away from src
423     }
424 }
425 
426 template&lt;typename T, int32_t stackCapacity&gt;
427 inline MaybeStackArray &lt;T, stackCapacity&gt;&amp;
428 MaybeStackArray&lt;T, stackCapacity&gt;::operator=(MaybeStackArray &lt;T, stackCapacity&gt;&amp;&amp; src) U_NOEXCEPT {
429     releaseArray();  // in case this instance had its own memory allocated
430     capacity = src.capacity;
431     needToRelease = src.needToRelease;
</pre>
<hr />
<pre>
488         uprv_memcpy(p, ptr, (size_t)length*sizeof(T));
489     }
490     resultCapacity=length;
491     resetToStackArray();
492     return p;
493 }
494 
495 /**
496  * Variant of MaybeStackArray that allocates a header struct and an array
497  * in one contiguous memory block, using uprv_malloc() and uprv_free().
498  * Provides internal memory with fixed array capacity. Can alias another memory
499  * block or allocate one.
500  * The stackCapacity is the number of T items in the internal memory,
501  * not counting the H header.
502  * Unlike LocalMemory and LocalArray, this class never adopts
503  * (takes ownership of) another memory block.
504  */
505 template&lt;typename H, typename T, int32_t stackCapacity&gt;
506 class MaybeStackHeaderAndArray {
507 public:







508     /**
509      * Default constructor initializes with internal H+T[stackCapacity] buffer.
510      */
511     MaybeStackHeaderAndArray() : ptr(&amp;stackHeader), capacity(stackCapacity), needToRelease(FALSE) {}
512     /**
513      * Destructor deletes the memory (if owned).
514      */
515     ~MaybeStackHeaderAndArray() { releaseMemory(); }
516     /**
517      * Returns the array capacity (number of T items).
518      * @return array capacity
519      */
520     int32_t getCapacity() const { return capacity; }
521     /**
522      * Access without ownership change.
523      * @return the header pointer
524      */
525     H *getAlias() const { return ptr; }
526     /**
527      * Returns the array start.
</pre>
<hr />
<pre>
584      */
585     inline H *orphanOrClone(int32_t length, int32_t &amp;resultCapacity);
586 private:
587     H *ptr;
588     int32_t capacity;
589     UBool needToRelease;
590     // stackHeader must precede stackArray immediately.
591     H stackHeader;
592     T stackArray[stackCapacity];
593     void releaseMemory() {
594         if(needToRelease) {
595             uprv_free(ptr);
596         }
597     }
598     /* No comparison operators with other MaybeStackHeaderAndArray&#39;s. */
599     bool operator==(const MaybeStackHeaderAndArray &amp; /*other*/) {return FALSE;}
600     bool operator!=(const MaybeStackHeaderAndArray &amp; /*other*/) {return TRUE;}
601     /* No ownership transfer: No copy constructor, no assignment operator. */
602     MaybeStackHeaderAndArray(const MaybeStackHeaderAndArray &amp; /*other*/) {}
603     void operator=(const MaybeStackHeaderAndArray &amp; /*other*/) {}
<span class="line-removed">604 </span>
<span class="line-removed">605     // No heap allocation. Use only on the stack.</span>
<span class="line-removed">606     //   (Declaring these functions private triggers a cascade of problems;</span>
<span class="line-removed">607     //    see the MaybeStackArray class for details.)</span>
<span class="line-removed">608     // static void * U_EXPORT2 operator new(size_t size);</span>
<span class="line-removed">609     // static void * U_EXPORT2 operator new[](size_t size);</span>
<span class="line-removed">610 #if U_HAVE_PLACEMENT_NEW</span>
<span class="line-removed">611     // static void * U_EXPORT2 operator new(size_t, void *ptr);</span>
<span class="line-removed">612 #endif</span>
613 };
614 
615 template&lt;typename H, typename T, int32_t stackCapacity&gt;
616 inline H *MaybeStackHeaderAndArray&lt;H, T, stackCapacity&gt;::resize(int32_t newCapacity,
617                                                                 int32_t length) {
618     if(newCapacity&gt;=0) {
619 #if U_DEBUG &amp;&amp; defined(UPRV_MALLOC_COUNT)
620       ::fprintf(::stderr,&quot;MaybeStackHeaderAndArray alloc %d + %d * %ul\n&quot;, sizeof(H),newCapacity,sizeof(T));
621 #endif
622         H *p=(H *)uprv_malloc(sizeof(H)+newCapacity*sizeof(T));
623         if(p!=NULL) {
624             if(length&lt;0) {
625                 length=0;
626             } else if(length&gt;0) {
627                 if(length&gt;capacity) {
628                     length=capacity;
629                 }
630                 if(length&gt;newCapacity) {
631                     length=newCapacity;
632                 }
</pre>
<hr />
<pre>
654             length=0;
655         } else if(length&gt;capacity) {
656             length=capacity;
657         }
658 #if U_DEBUG &amp;&amp; defined(UPRV_MALLOC_COUNT)
659       ::fprintf(::stderr,&quot;MaybeStackHeaderAndArray (orphan) alloc %ul + %d * %lu\n&quot;, sizeof(H),length,sizeof(T));
660 #endif
661         p=(H *)uprv_malloc(sizeof(H)+length*sizeof(T));
662         if(p==NULL) {
663             return NULL;
664         }
665         uprv_memcpy(p, ptr, sizeof(H)+(size_t)length*sizeof(T));
666     }
667     resultCapacity=length;
668     ptr=&amp;stackHeader;
669     capacity=stackCapacity;
670     needToRelease=FALSE;
671     return p;
672 }
673 








































































674 U_NAMESPACE_END
675 
676 #endif  /* __cplusplus */
677 #endif  /* CMEMORY_H */
</pre>
</td>
<td>
<hr />
<pre>
 33 #include &quot;unicode/localpointer.h&quot;
 34 
 35 #if U_DEBUG &amp;&amp; defined(UPRV_MALLOC_COUNT)
 36 #include &lt;stdio.h&gt;
 37 #endif
 38 
 39 
 40 #define uprv_memcpy(dst, src, size) U_STANDARD_CPP_NAMESPACE memcpy(dst, src, size)
 41 #define uprv_memmove(dst, src, size) U_STANDARD_CPP_NAMESPACE memmove(dst, src, size)
 42 
 43 /**
 44  * \def UPRV_LENGTHOF
 45  * Convenience macro to determine the length of a fixed array at compile-time.
 46  * @param array A fixed length array
 47  * @return The length of the array, in elements
 48  * @internal
 49  */
 50 #define UPRV_LENGTHOF(array) (int32_t)(sizeof(array)/sizeof((array)[0]))
 51 #define uprv_memset(buffer, mark, size) U_STANDARD_CPP_NAMESPACE memset(buffer, mark, size)
 52 #define uprv_memcmp(buffer1, buffer2, size) U_STANDARD_CPP_NAMESPACE memcmp(buffer1, buffer2,size)
<span class="line-added"> 53 #define uprv_memchr(ptr, value, num) U_STANDARD_CPP_NAMESPACE memchr(ptr, value, num)</span>
 54 
 55 U_CAPI void * U_EXPORT2
 56 uprv_malloc(size_t s) U_MALLOC_ATTR U_ALLOC_SIZE_ATTR(1);
 57 
 58 U_CAPI void * U_EXPORT2
 59 uprv_realloc(void *mem, size_t size) U_ALLOC_SIZE_ATTR(2);
 60 
 61 U_CAPI void U_EXPORT2
 62 uprv_free(void *mem);
 63 
 64 U_CAPI void * U_EXPORT2
 65 uprv_calloc(size_t num, size_t size) U_MALLOC_ATTR U_ALLOC_SIZE_ATTR2(1,2);
 66 
 67 /**
 68  * This should align the memory properly on any machine.
 69  * This is very useful for the safeClone functions.
 70  */
 71 typedef union {
 72     long    t1;
 73     double  t2;
</pre>
<hr />
<pre>
106 cmemory_cleanup(void);
107 
108 /**
109  * A function called by &lt;TT&gt;uhash_remove&lt;/TT&gt;,
110  * &lt;TT&gt;uhash_close&lt;/TT&gt;, or &lt;TT&gt;uhash_put&lt;/TT&gt; to delete
111  * an existing key or value.
112  * @param obj A key or value stored in a hashtable
113  * @see uprv_deleteUObject
114  */
115 typedef void U_CALLCONV UObjectDeleter(void* obj);
116 
117 /**
118  * Deleter for UObject instances.
119  * Works for all subclasses of UObject because it has a virtual destructor.
120  */
121 U_CAPI void U_EXPORT2
122 uprv_deleteUObject(void *obj);
123 
124 #ifdef __cplusplus
125 
<span class="line-added">126 #include &lt;utility&gt;</span>
<span class="line-added">127 #include &quot;unicode/uobject.h&quot;</span>
<span class="line-added">128 </span>
129 U_NAMESPACE_BEGIN
130 
131 /**
132  * &quot;Smart pointer&quot; class, deletes memory via uprv_free().
133  * For most methods see the LocalPointerBase base class.
134  * Adds operator[] for array item access.
135  *
136  * @see LocalPointerBase
137  */
138 template&lt;typename T&gt;
139 class LocalMemory : public LocalPointerBase&lt;T&gt; {
140 public:
141     using LocalPointerBase&lt;T&gt;::operator*;
142     using LocalPointerBase&lt;T&gt;::operator-&gt;;
143     /**
144      * Constructor takes ownership.
145      * @param p simple pointer to an array of T items that is adopted
146      */
147     explicit LocalMemory(T *p=NULL) : LocalPointerBase&lt;T&gt;(p) {}
148     /**
149      * Move constructor, leaves src with isNull().
150      * @param src source smart pointer
151      */
152     LocalMemory(LocalMemory&lt;T&gt; &amp;&amp;src) U_NOEXCEPT : LocalPointerBase&lt;T&gt;(src.ptr) {
153         src.ptr=NULL;
154     }
155     /**
156      * Destructor deletes the memory it owns.
157      */
158     ~LocalMemory() {
159         uprv_free(LocalPointerBase&lt;T&gt;::ptr);
160     }
161     /**
162      * Move assignment operator, leaves src with isNull().
163      * The behavior is undefined if *this and src are the same object.
164      * @param src source smart pointer
165      * @return *this
166      */
167     LocalMemory&lt;T&gt; &amp;operator=(LocalMemory&lt;T&gt; &amp;&amp;src) U_NOEXCEPT {
<span class="line-modified">168         uprv_free(LocalPointerBase&lt;T&gt;::ptr);</span>











169         LocalPointerBase&lt;T&gt;::ptr=src.ptr;
170         src.ptr=NULL;
171         return *this;
172     }
173     /**
174      * Swap pointers.
175      * @param other other smart pointer
176      */
177     void swap(LocalMemory&lt;T&gt; &amp;other) U_NOEXCEPT {
178         T *temp=LocalPointerBase&lt;T&gt;::ptr;
179         LocalPointerBase&lt;T&gt;::ptr=other.ptr;
180         other.ptr=temp;
181     }
182     /**
183      * Non-member LocalMemory swap function.
184      * @param p1 will get p2&#39;s pointer
185      * @param p2 will get p1&#39;s pointer
186      */
187     friend inline void swap(LocalMemory&lt;T&gt; &amp;p1, LocalMemory&lt;T&gt; &amp;p2) U_NOEXCEPT {
188         p1.swap(p2);
</pre>
<hr />
<pre>
255             }
256             uprv_free(LocalPointerBase&lt;T&gt;::ptr);
257             LocalPointerBase&lt;T&gt;::ptr=p;
258         }
259         return p;
260     } else {
261         return NULL;
262     }
263 }
264 
265 /**
266  * Simple array/buffer management class using uprv_malloc() and uprv_free().
267  * Provides an internal array with fixed capacity. Can alias another array
268  * or allocate one.
269  *
270  * The array address is properly aligned for type T. It might not be properly
271  * aligned for types larger than T (or larger than the largest subtype of T).
272  *
273  * Unlike LocalMemory and LocalArray, this class never adopts
274  * (takes ownership of) another array.
<span class="line-added">275  *</span>
<span class="line-added">276  * WARNING: MaybeStackArray only works with primitive (plain-old data) types.</span>
<span class="line-added">277  * It does NOT know how to call a destructor! If you work with classes with</span>
<span class="line-added">278  * destructors, consider LocalArray in localpointer.h or MemoryPool.</span>
279  */
280 template&lt;typename T, int32_t stackCapacity&gt;
281 class MaybeStackArray {
282 public:
<span class="line-added">283     // No heap allocation. Use only on the stack.</span>
<span class="line-added">284     static void* U_EXPORT2 operator new(size_t) U_NOEXCEPT = delete;</span>
<span class="line-added">285     static void* U_EXPORT2 operator new[](size_t) U_NOEXCEPT = delete;</span>
<span class="line-added">286 #if U_HAVE_PLACEMENT_NEW</span>
<span class="line-added">287     static void* U_EXPORT2 operator new(size_t, void*) U_NOEXCEPT = delete;</span>
<span class="line-added">288 #endif</span>
<span class="line-added">289 </span>
290     /**
291      * Default constructor initializes with internal T[stackCapacity] buffer.
292      */
293     MaybeStackArray() : ptr(stackArray), capacity(stackCapacity), needToRelease(FALSE) {}
294     /**
295      * Automatically allocates the heap array if the argument is larger than the stack capacity.
296      * Intended for use when an approximate capacity is known at compile time but the true
297      * capacity is not known until runtime.
298      */
299     MaybeStackArray(int32_t newCapacity) : MaybeStackArray() {
300         if (capacity &lt; newCapacity) { resize(newCapacity); }
<span class="line-modified">301     }</span>
302     /**
303      * Destructor deletes the array (if owned).
304      */
305     ~MaybeStackArray() { releaseArray(); }
306     /**
307      * Move constructor: transfers ownership or copies the stack array.
308      */
309     MaybeStackArray(MaybeStackArray&lt;T, stackCapacity&gt; &amp;&amp;src) U_NOEXCEPT;
310     /**
311      * Move assignment: transfers ownership or copies the stack array.
312      */
313     MaybeStackArray&lt;T, stackCapacity&gt; &amp;operator=(MaybeStackArray&lt;T, stackCapacity&gt; &amp;&amp;src) U_NOEXCEPT;
314     /**
315      * Returns the array capacity (number of T items).
316      * @return array capacity
317      */
318     int32_t getCapacity() const { return capacity; }
319     /**
320      * Access without ownership change.
321      * @return the array pointer
</pre>
<hr />
<pre>
382     T *ptr;
383     int32_t capacity;
384     UBool needToRelease;
385     T stackArray[stackCapacity];
386     void releaseArray() {
387         if(needToRelease) {
388             uprv_free(ptr);
389         }
390     }
391     void resetToStackArray() {
392         ptr=stackArray;
393         capacity=stackCapacity;
394         needToRelease=FALSE;
395     }
396     /* No comparison operators with other MaybeStackArray&#39;s. */
397     bool operator==(const MaybeStackArray &amp; /*other*/) {return FALSE;}
398     bool operator!=(const MaybeStackArray &amp; /*other*/) {return TRUE;}
399     /* No ownership transfer: No copy constructor, no assignment operator. */
400     MaybeStackArray(const MaybeStackArray &amp; /*other*/) {}
401     void operator=(const MaybeStackArray &amp; /*other*/) {}














402 };
403 
404 template&lt;typename T, int32_t stackCapacity&gt;
405 icu::MaybeStackArray&lt;T, stackCapacity&gt;::MaybeStackArray(
406         MaybeStackArray &lt;T, stackCapacity&gt;&amp;&amp; src) U_NOEXCEPT
407         : ptr(src.ptr), capacity(src.capacity), needToRelease(src.needToRelease) {
408     if (src.ptr == src.stackArray) {
409         ptr = stackArray;
410         uprv_memcpy(stackArray, src.stackArray, sizeof(T) * src.capacity);
411     } else {
412         src.resetToStackArray();  // take ownership away from src
413     }
414 }
415 
416 template&lt;typename T, int32_t stackCapacity&gt;
417 inline MaybeStackArray &lt;T, stackCapacity&gt;&amp;
418 MaybeStackArray&lt;T, stackCapacity&gt;::operator=(MaybeStackArray &lt;T, stackCapacity&gt;&amp;&amp; src) U_NOEXCEPT {
419     releaseArray();  // in case this instance had its own memory allocated
420     capacity = src.capacity;
421     needToRelease = src.needToRelease;
</pre>
<hr />
<pre>
478         uprv_memcpy(p, ptr, (size_t)length*sizeof(T));
479     }
480     resultCapacity=length;
481     resetToStackArray();
482     return p;
483 }
484 
485 /**
486  * Variant of MaybeStackArray that allocates a header struct and an array
487  * in one contiguous memory block, using uprv_malloc() and uprv_free().
488  * Provides internal memory with fixed array capacity. Can alias another memory
489  * block or allocate one.
490  * The stackCapacity is the number of T items in the internal memory,
491  * not counting the H header.
492  * Unlike LocalMemory and LocalArray, this class never adopts
493  * (takes ownership of) another memory block.
494  */
495 template&lt;typename H, typename T, int32_t stackCapacity&gt;
496 class MaybeStackHeaderAndArray {
497 public:
<span class="line-added">498     // No heap allocation. Use only on the stack.</span>
<span class="line-added">499     static void* U_EXPORT2 operator new(size_t) U_NOEXCEPT = delete;</span>
<span class="line-added">500     static void* U_EXPORT2 operator new[](size_t) U_NOEXCEPT = delete;</span>
<span class="line-added">501 #if U_HAVE_PLACEMENT_NEW</span>
<span class="line-added">502     static void* U_EXPORT2 operator new(size_t, void*) U_NOEXCEPT = delete;</span>
<span class="line-added">503 #endif</span>
<span class="line-added">504 </span>
505     /**
506      * Default constructor initializes with internal H+T[stackCapacity] buffer.
507      */
508     MaybeStackHeaderAndArray() : ptr(&amp;stackHeader), capacity(stackCapacity), needToRelease(FALSE) {}
509     /**
510      * Destructor deletes the memory (if owned).
511      */
512     ~MaybeStackHeaderAndArray() { releaseMemory(); }
513     /**
514      * Returns the array capacity (number of T items).
515      * @return array capacity
516      */
517     int32_t getCapacity() const { return capacity; }
518     /**
519      * Access without ownership change.
520      * @return the header pointer
521      */
522     H *getAlias() const { return ptr; }
523     /**
524      * Returns the array start.
</pre>
<hr />
<pre>
581      */
582     inline H *orphanOrClone(int32_t length, int32_t &amp;resultCapacity);
583 private:
584     H *ptr;
585     int32_t capacity;
586     UBool needToRelease;
587     // stackHeader must precede stackArray immediately.
588     H stackHeader;
589     T stackArray[stackCapacity];
590     void releaseMemory() {
591         if(needToRelease) {
592             uprv_free(ptr);
593         }
594     }
595     /* No comparison operators with other MaybeStackHeaderAndArray&#39;s. */
596     bool operator==(const MaybeStackHeaderAndArray &amp; /*other*/) {return FALSE;}
597     bool operator!=(const MaybeStackHeaderAndArray &amp; /*other*/) {return TRUE;}
598     /* No ownership transfer: No copy constructor, no assignment operator. */
599     MaybeStackHeaderAndArray(const MaybeStackHeaderAndArray &amp; /*other*/) {}
600     void operator=(const MaybeStackHeaderAndArray &amp; /*other*/) {}









601 };
602 
603 template&lt;typename H, typename T, int32_t stackCapacity&gt;
604 inline H *MaybeStackHeaderAndArray&lt;H, T, stackCapacity&gt;::resize(int32_t newCapacity,
605                                                                 int32_t length) {
606     if(newCapacity&gt;=0) {
607 #if U_DEBUG &amp;&amp; defined(UPRV_MALLOC_COUNT)
608       ::fprintf(::stderr,&quot;MaybeStackHeaderAndArray alloc %d + %d * %ul\n&quot;, sizeof(H),newCapacity,sizeof(T));
609 #endif
610         H *p=(H *)uprv_malloc(sizeof(H)+newCapacity*sizeof(T));
611         if(p!=NULL) {
612             if(length&lt;0) {
613                 length=0;
614             } else if(length&gt;0) {
615                 if(length&gt;capacity) {
616                     length=capacity;
617                 }
618                 if(length&gt;newCapacity) {
619                     length=newCapacity;
620                 }
</pre>
<hr />
<pre>
642             length=0;
643         } else if(length&gt;capacity) {
644             length=capacity;
645         }
646 #if U_DEBUG &amp;&amp; defined(UPRV_MALLOC_COUNT)
647       ::fprintf(::stderr,&quot;MaybeStackHeaderAndArray (orphan) alloc %ul + %d * %lu\n&quot;, sizeof(H),length,sizeof(T));
648 #endif
649         p=(H *)uprv_malloc(sizeof(H)+length*sizeof(T));
650         if(p==NULL) {
651             return NULL;
652         }
653         uprv_memcpy(p, ptr, sizeof(H)+(size_t)length*sizeof(T));
654     }
655     resultCapacity=length;
656     ptr=&amp;stackHeader;
657     capacity=stackCapacity;
658     needToRelease=FALSE;
659     return p;
660 }
661 
<span class="line-added">662 /**</span>
<span class="line-added">663  * A simple memory management class that creates new heap allocated objects (of</span>
<span class="line-added">664  * any class that has a public constructor), keeps track of them and eventually</span>
<span class="line-added">665  * deletes them all in its own destructor.</span>
<span class="line-added">666  *</span>
<span class="line-added">667  * A typical use-case would be code like this:</span>
<span class="line-added">668  *</span>
<span class="line-added">669  *     MemoryPool&lt;MyType&gt; pool;</span>
<span class="line-added">670  *</span>
<span class="line-added">671  *     MyType* o1 = pool.create();</span>
<span class="line-added">672  *     if (o1 != nullptr) {</span>
<span class="line-added">673  *         foo(o1);</span>
<span class="line-added">674  *     }</span>
<span class="line-added">675  *</span>
<span class="line-added">676  *     MyType* o2 = pool.create(1, 2, 3);</span>
<span class="line-added">677  *     if (o2 != nullptr) {</span>
<span class="line-added">678  *         bar(o2);</span>
<span class="line-added">679  *     }</span>
<span class="line-added">680  *</span>
<span class="line-added">681  *     // MemoryPool will take care of deleting the MyType objects.</span>
<span class="line-added">682  *</span>
<span class="line-added">683  * It doesn&#39;t do anything more than that, and is intentionally kept minimalist.</span>
<span class="line-added">684  */</span>
<span class="line-added">685 template&lt;typename T, int32_t stackCapacity = 8&gt;</span>
<span class="line-added">686 class MemoryPool : public UMemory {</span>
<span class="line-added">687 public:</span>
<span class="line-added">688     MemoryPool() : count(0), pool() {}</span>
<span class="line-added">689 </span>
<span class="line-added">690     ~MemoryPool() {</span>
<span class="line-added">691         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-added">692             delete pool[i];</span>
<span class="line-added">693         }</span>
<span class="line-added">694     }</span>
<span class="line-added">695 </span>
<span class="line-added">696     MemoryPool(const MemoryPool&amp;) = delete;</span>
<span class="line-added">697     MemoryPool&amp; operator=(const MemoryPool&amp;) = delete;</span>
<span class="line-added">698 </span>
<span class="line-added">699     MemoryPool(MemoryPool&amp;&amp; other) U_NOEXCEPT : count(other.count),</span>
<span class="line-added">700                                                 pool(std::move(other.pool)) {</span>
<span class="line-added">701         other.count = 0;</span>
<span class="line-added">702     }</span>
<span class="line-added">703 </span>
<span class="line-added">704     MemoryPool&amp; operator=(MemoryPool&amp;&amp; other) U_NOEXCEPT {</span>
<span class="line-added">705         count = other.count;</span>
<span class="line-added">706         pool = std::move(other.pool);</span>
<span class="line-added">707         other.count = 0;</span>
<span class="line-added">708         return *this;</span>
<span class="line-added">709     }</span>
<span class="line-added">710 </span>
<span class="line-added">711     /**</span>
<span class="line-added">712      * Creates a new object of typename T, by forwarding any and all arguments</span>
<span class="line-added">713      * to the typename T constructor.</span>
<span class="line-added">714      *</span>
<span class="line-added">715      * @param args Arguments to be forwarded to the typename T constructor.</span>
<span class="line-added">716      * @return A pointer to the newly created object, or nullptr on error.</span>
<span class="line-added">717      */</span>
<span class="line-added">718     template&lt;typename... Args&gt;</span>
<span class="line-added">719     T* create(Args&amp;&amp;... args) {</span>
<span class="line-added">720         int32_t capacity = pool.getCapacity();</span>
<span class="line-added">721         if (count == capacity &amp;&amp;</span>
<span class="line-added">722             pool.resize(capacity == stackCapacity ? 4 * capacity : 2 * capacity,</span>
<span class="line-added">723                         capacity) == nullptr) {</span>
<span class="line-added">724             return nullptr;</span>
<span class="line-added">725         }</span>
<span class="line-added">726         return pool[count++] = new T(std::forward&lt;Args&gt;(args)...);</span>
<span class="line-added">727     }</span>
<span class="line-added">728 </span>
<span class="line-added">729 private:</span>
<span class="line-added">730     int32_t count;</span>
<span class="line-added">731     MaybeStackArray&lt;T*, stackCapacity&gt; pool;</span>
<span class="line-added">732 };</span>
<span class="line-added">733 </span>
734 U_NAMESPACE_END
735 
736 #endif  /* __cplusplus */
737 #endif  /* CMEMORY_H */
</pre>
</td>
</tr>
</table>
<center><a href="charstr.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="common.rc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>