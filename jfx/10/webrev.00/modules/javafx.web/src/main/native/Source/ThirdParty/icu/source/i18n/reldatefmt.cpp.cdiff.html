<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/reldatefmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="region.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="reldtfmt.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/reldatefmt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 13,10 ***</span>
<span class="line-new-header">--- 13,11 ---</span>
  #include &quot;unicode/reldatefmt.h&quot;
  
  #if !UCONFIG_NO_FORMATTING &amp;&amp; !UCONFIG_NO_BREAK_ITERATION
  
  #include &lt;cmath&gt;
<span class="line-added">+ #include &lt;functional&gt;</span>
  #include &quot;unicode/dtfmtsym.h&quot;
  #include &quot;unicode/ucasemap.h&quot;
  #include &quot;unicode/ureldatefmt.h&quot;
  #include &quot;unicode/udisplaycontext.h&quot;
  #include &quot;unicode/unum.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 39,27 ***</span>
  #include &quot;sharedbreakiterator.h&quot;
  #include &quot;sharedpluralrules.h&quot;
  #include &quot;sharednumberformat.h&quot;
  #include &quot;standardplural.h&quot;
  #include &quot;unifiedcache.h&quot;
  
  // Copied from uscript_props.cpp
  
<span class="line-removed">- static UMutex gBrkIterMutex = U_MUTEX_INITIALIZER;</span>
<span class="line-removed">- </span>
  U_NAMESPACE_BEGIN
  
  // RelativeDateTimeFormatter specific data for a single locale
  class RelativeDateTimeCacheData: public SharedObject {
  public:
<span class="line-modified">!     RelativeDateTimeCacheData() : combinedDateAndTime(NULL) {</span>
          // Initialize the cache arrays
          for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<span class="line-modified">!             for (int32_t relUnit = 0; relUnit &lt; UDAT_RELATIVE_UNIT_COUNT; ++relUnit) {</span>
                  for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
<span class="line-modified">!                     relativeUnitsFormatters[style][relUnit][0][pl] = NULL;</span>
<span class="line-modified">!                     relativeUnitsFormatters[style][relUnit][1][pl] = NULL;</span>
                  }
              }
          }
          for (int32_t i = 0; i &lt; UDAT_STYLE_COUNT; ++i) {
            fallBackCache[i] = -1;
<span class="line-new-header">--- 40,31 ---</span>
  #include &quot;sharedbreakiterator.h&quot;
  #include &quot;sharedpluralrules.h&quot;
  #include &quot;sharednumberformat.h&quot;
  #include &quot;standardplural.h&quot;
  #include &quot;unifiedcache.h&quot;
<span class="line-added">+ #include &quot;util.h&quot;</span>
<span class="line-added">+ #include &quot;number_stringbuilder.h&quot;</span>
<span class="line-added">+ #include &quot;number_utypes.h&quot;</span>
<span class="line-added">+ #include &quot;number_modifiers.h&quot;</span>
<span class="line-added">+ #include &quot;formattedval_impl.h&quot;</span>
<span class="line-added">+ #include &quot;number_utils.h&quot;</span>
  
  // Copied from uscript_props.cpp
  
  U_NAMESPACE_BEGIN
  
  // RelativeDateTimeFormatter specific data for a single locale
  class RelativeDateTimeCacheData: public SharedObject {
  public:
<span class="line-modified">!     RelativeDateTimeCacheData() : combinedDateAndTime(nullptr) {</span>
          // Initialize the cache arrays
          for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<span class="line-modified">!             for (int32_t relUnit = 0; relUnit &lt; UDAT_REL_UNIT_COUNT; ++relUnit) {</span>
                  for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
<span class="line-modified">!                     relativeUnitsFormatters[style][relUnit][0][pl] = nullptr;</span>
<span class="line-modified">!                     relativeUnitsFormatters[style][relUnit][1][pl] = nullptr;</span>
                  }
              }
          }
          for (int32_t i = 0; i &lt; UDAT_STYLE_COUNT; ++i) {
            fallBackCache[i] = -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 72,19 ***</span>
  
      // SimpleFormatter pointers for relative unit format,
      // e.g., Next Tuesday; Yesterday; etc. For third index, 0
      // means past, e.g., 5 days ago; 1 means future, e.g., in 5 days.
      SimpleFormatter *relativeUnitsFormatters[UDAT_STYLE_COUNT]
<span class="line-modified">!         [UDAT_RELATIVE_UNIT_COUNT][2][StandardPlural::COUNT];</span>
  
      const UnicodeString&amp; getAbsoluteUnitString(int32_t fStyle,
                                                 UDateAbsoluteUnit unit,
                                                 UDateDirection direction) const;
      const SimpleFormatter* getRelativeUnitFormatter(int32_t fStyle,
  
      const UnicodeString emptyString;
  
      // Mappping from source to target styles for alias fallback.
      int32_t fallBackCache[UDAT_STYLE_COUNT];
<span class="line-new-header">--- 77,23 ---</span>
  
      // SimpleFormatter pointers for relative unit format,
      // e.g., Next Tuesday; Yesterday; etc. For third index, 0
      // means past, e.g., 5 days ago; 1 means future, e.g., in 5 days.
      SimpleFormatter *relativeUnitsFormatters[UDAT_STYLE_COUNT]
<span class="line-modified">!         [UDAT_REL_UNIT_COUNT][2][StandardPlural::COUNT];</span>
  
      const UnicodeString&amp; getAbsoluteUnitString(int32_t fStyle,
                                                 UDateAbsoluteUnit unit,
                                                 UDateDirection direction) const;
      const SimpleFormatter* getRelativeUnitFormatter(int32_t fStyle,
<span class="line-added">+     const SimpleFormatter* getRelativeDateTimeUnitFormatter(int32_t fStyle,</span>
<span class="line-added">+                                                     URelativeDateTimeUnit unit,</span>
<span class="line-added">+                                                     int32_t pastFutureIndex,</span>
<span class="line-added">+                                                     int32_t pluralUnit) const;</span>
  
      const UnicodeString emptyString;
  
      // Mappping from source to target styles for alias fallback.
      int32_t fallBackCache[UDAT_STYLE_COUNT];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,11 ***</span>
  };
  
  RelativeDateTimeCacheData::~RelativeDateTimeCacheData() {
      // clear out the cache arrays
      for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<span class="line-modified">!         for (int32_t relUnit = 0; relUnit &lt; UDAT_RELATIVE_UNIT_COUNT; ++relUnit) {</span>
              for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
                  delete relativeUnitsFormatters[style][relUnit][0][pl];
                  delete relativeUnitsFormatters[style][relUnit][1][pl];
              }
          }
<span class="line-new-header">--- 114,11 ---</span>
  };
  
  RelativeDateTimeCacheData::~RelativeDateTimeCacheData() {
      // clear out the cache arrays
      for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<span class="line-modified">!         for (int32_t relUnit = 0; relUnit &lt; UDAT_REL_UNIT_COUNT; ++relUnit) {</span>
              for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
                  delete relativeUnitsFormatters[style][relUnit][0][pl];
                  delete relativeUnitsFormatters[style][relUnit][1][pl];
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,24 ***</span>
          style = fallBackCache[style];
      } while (style != -1);
      return emptyString;
  }
  
<span class="line-removed">-  // Use fallback cache for SimpleFormatter relativeUnits.</span>
   const SimpleFormatter* RelativeDateTimeCacheData::getRelativeUnitFormatter(
          int32_t fStyle,
          UDateRelativeUnit unit,
          int32_t pastFutureIndex,
          int32_t pluralUnit) const {
<span class="line-modified">!     int32_t style = fStyle;</span>
<span class="line-modified">!     do {</span>
<span class="line-modified">!         if (relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit] != NULL) {</span>
<span class="line-modified">!             return relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit];</span>
          }
<span class="line-modified">!         style = fallBackCache[style];</span>
<span class="line-modified">!     } while (style != -1);</span>
<span class="line-modified">!     return NULL;  // No formatter found.</span>
   }
  
  static UBool getStringWithFallback(
          const UResourceBundle *resource,
          const char *key,
<span class="line-new-header">--- 138,52 ---</span>
          style = fallBackCache[style];
      } while (style != -1);
      return emptyString;
  }
  
   const SimpleFormatter* RelativeDateTimeCacheData::getRelativeUnitFormatter(
          int32_t fStyle,
          UDateRelativeUnit unit,
          int32_t pastFutureIndex,
          int32_t pluralUnit) const {
<span class="line-modified">!    URelativeDateTimeUnit rdtunit = UDAT_REL_UNIT_COUNT;</span>
<span class="line-modified">!    switch (unit) {</span>
<span class="line-modified">!        case UDAT_RELATIVE_YEARS:   rdtunit = UDAT_REL_UNIT_YEAR; break;</span>
<span class="line-modified">!        case UDAT_RELATIVE_MONTHS:  rdtunit = UDAT_REL_UNIT_MONTH; break;</span>
<span class="line-added">+        case UDAT_RELATIVE_WEEKS:   rdtunit = UDAT_REL_UNIT_WEEK; break;</span>
<span class="line-added">+        case UDAT_RELATIVE_DAYS:    rdtunit = UDAT_REL_UNIT_DAY; break;</span>
<span class="line-added">+        case UDAT_RELATIVE_HOURS:   rdtunit = UDAT_REL_UNIT_HOUR; break;</span>
<span class="line-added">+        case UDAT_RELATIVE_MINUTES: rdtunit = UDAT_REL_UNIT_MINUTE; break;</span>
<span class="line-added">+        case UDAT_RELATIVE_SECONDS: rdtunit = UDAT_REL_UNIT_SECOND; break;</span>
<span class="line-added">+        default: // a unit that the above method does not handle</span>
<span class="line-added">+             return nullptr;</span>
<span class="line-added">+    }</span>
<span class="line-added">+ </span>
<span class="line-added">+    return getRelativeDateTimeUnitFormatter(fStyle, rdtunit, pastFutureIndex, pluralUnit);</span>
<span class="line-added">+  }</span>
<span class="line-added">+ </span>
<span class="line-added">+  // Use fallback cache for SimpleFormatter relativeUnits.</span>
<span class="line-added">+  const SimpleFormatter* RelativeDateTimeCacheData::getRelativeDateTimeUnitFormatter(</span>
<span class="line-added">+         int32_t fStyle,</span>
<span class="line-added">+         URelativeDateTimeUnit unit,</span>
<span class="line-added">+         int32_t pastFutureIndex,</span>
<span class="line-added">+         int32_t pluralUnit) const {</span>
<span class="line-added">+     while (true) {</span>
<span class="line-added">+         int32_t style = fStyle;</span>
<span class="line-added">+         do {</span>
<span class="line-added">+             if (relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit] != nullptr) {</span>
<span class="line-added">+                 return relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit];</span>
<span class="line-added">+             }</span>
<span class="line-added">+             style = fallBackCache[style];</span>
<span class="line-added">+         } while (style != -1);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (pluralUnit == StandardPlural::OTHER) {</span>
<span class="line-added">+             break;</span>
          }
<span class="line-modified">!         pluralUnit = StandardPlural::OTHER;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     return nullptr;  // No formatter found.</span>
   }
  
  static UBool getStringWithFallback(
          const UResourceBundle *resource,
          const char *key,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,27 ***</span>
  
      static int32_t relUnitFromGeneric(RelAbsUnit genUnit) {
          // Converts the generic units to UDAT_RELATIVE version.
          switch (genUnit) {
              case SECOND:
<span class="line-modified">!                 return UDAT_RELATIVE_SECONDS;</span>
              case MINUTE:
<span class="line-modified">!                 return UDAT_RELATIVE_MINUTES;</span>
              case HOUR:
<span class="line-modified">!                 return UDAT_RELATIVE_HOURS;</span>
              case DAY:
<span class="line-modified">!                 return UDAT_RELATIVE_DAYS;</span>
              case WEEK:
<span class="line-modified">!                 return UDAT_RELATIVE_WEEKS;</span>
              case MONTH:
<span class="line-modified">!                 return UDAT_RELATIVE_MONTHS;</span>
<span class="line-modified">!             /*</span>
<span class="line-modified">!              * case QUARTER:</span>
<span class="line-removed">-              * return UDATE_RELATIVE_QUARTERS;</span>
<span class="line-removed">-              */</span>
              case YEAR:
<span class="line-modified">!                 return UDAT_RELATIVE_YEARS;</span>
              default:
                  return -1;
          }
      }
  
<span class="line-new-header">--- 252,39 ---</span>
  
      static int32_t relUnitFromGeneric(RelAbsUnit genUnit) {
          // Converts the generic units to UDAT_RELATIVE version.
          switch (genUnit) {
              case SECOND:
<span class="line-modified">!                 return UDAT_REL_UNIT_SECOND;</span>
              case MINUTE:
<span class="line-modified">!                 return UDAT_REL_UNIT_MINUTE;</span>
              case HOUR:
<span class="line-modified">!                 return UDAT_REL_UNIT_HOUR;</span>
              case DAY:
<span class="line-modified">!                 return UDAT_REL_UNIT_DAY;</span>
              case WEEK:
<span class="line-modified">!                 return UDAT_REL_UNIT_WEEK;</span>
              case MONTH:
<span class="line-modified">!                 return UDAT_REL_UNIT_MONTH;</span>
<span class="line-modified">!             case QUARTER:</span>
<span class="line-modified">!                 return UDAT_REL_UNIT_QUARTER;</span>
              case YEAR:
<span class="line-modified">!                 return UDAT_REL_UNIT_YEAR;</span>
<span class="line-added">+             case SUNDAY:</span>
<span class="line-added">+                 return UDAT_REL_UNIT_SUNDAY;</span>
<span class="line-added">+             case MONDAY:</span>
<span class="line-added">+                 return UDAT_REL_UNIT_MONDAY;</span>
<span class="line-added">+             case TUESDAY:</span>
<span class="line-added">+                 return UDAT_REL_UNIT_TUESDAY;</span>
<span class="line-added">+             case WEDNESDAY:</span>
<span class="line-added">+                 return UDAT_REL_UNIT_WEDNESDAY;</span>
<span class="line-added">+             case THURSDAY:</span>
<span class="line-added">+                 return UDAT_REL_UNIT_THURSDAY;</span>
<span class="line-added">+             case FRIDAY:</span>
<span class="line-added">+                 return UDAT_REL_UNIT_FRIDAY;</span>
<span class="line-added">+             case SATURDAY:</span>
<span class="line-added">+                 return UDAT_REL_UNIT_SATURDAY;</span>
              default:
                  return -1;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,14 ***</span>
                  return UDAT_ABSOLUTE_DAY;
              case WEEK:
                  return UDAT_ABSOLUTE_WEEK;
              case MONTH:
                  return UDAT_ABSOLUTE_MONTH;
<span class="line-modified">!             /* TODO: Add in QUARTER</span>
<span class="line-modified">!              *  case QUARTER:</span>
<span class="line-removed">-              * return UDAT_ABSOLUTE_QUARTER;</span>
<span class="line-removed">-              */</span>
              case YEAR:
                  return UDAT_ABSOLUTE_YEAR;
              case SUNDAY:
                  return UDAT_ABSOLUTE_SUNDAY;
              case MONDAY:
<span class="line-new-header">--- 295,12 ---</span>
                  return UDAT_ABSOLUTE_DAY;
              case WEEK:
                  return UDAT_ABSOLUTE_WEEK;
              case MONTH:
                  return UDAT_ABSOLUTE_MONTH;
<span class="line-modified">!             case QUARTER:</span>
<span class="line-modified">!                 return UDAT_ABSOLUTE_QUARTER;</span>
              case YEAR:
                  return UDAT_ABSOLUTE_YEAR;
              case SUNDAY:
                  return UDAT_ABSOLUTE_SUNDAY;
              case MONDAY:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,11 ***</span>
  
      ~RelDateTimeFmtDataSink();
  
      // Utility functions
      static UDateRelativeDateTimeFormatterStyle styleFromString(const char *s) {
<span class="line-modified">!         int32_t len = uprv_strlen(s);</span>
          if (len &gt;= 7 &amp;&amp; uprv_strcmp(s + len - 7, &quot;-narrow&quot;) == 0) {
              return UDAT_STYLE_NARROW;
          }
          if (len &gt;= 6 &amp;&amp; uprv_strcmp(s + len - 6, &quot;-short&quot;) == 0) {
              return UDAT_STYLE_SHORT;
<span class="line-new-header">--- 357,11 ---</span>
  
      ~RelDateTimeFmtDataSink();
  
      // Utility functions
      static UDateRelativeDateTimeFormatterStyle styleFromString(const char *s) {
<span class="line-modified">!         int32_t len = static_cast&lt;int32_t&gt;(uprv_strlen(s));</span>
          if (len &gt;= 7 &amp;&amp; uprv_strcmp(s + len - 7, &quot;-narrow&quot;) == 0) {
              return UDAT_STYLE_NARROW;
          }
          if (len &gt;= 6 &amp;&amp; uprv_strcmp(s + len - 6, &quot;-short&quot;) == 0) {
              return UDAT_STYLE_SHORT;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 428,11 ***</span>
                  if (direction &lt; 0) {
                    continue;
                  }
  
                  int32_t relUnitIndex = relUnitFromGeneric(genericUnit);
<span class="line-modified">!                 if (relUnitIndex == UDAT_RELATIVE_SECONDS &amp;&amp; uprv_strcmp(key, &quot;0&quot;) == 0 &amp;&amp;</span>
                      outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW][UDAT_DIRECTION_PLAIN].isEmpty()) {
                      // Handle &quot;NOW&quot;
                      outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW]
                          [UDAT_DIRECTION_PLAIN].fastCopyFrom(value.getUnicodeString(errorCode));
                  }
<span class="line-new-header">--- 475,11 ---</span>
                  if (direction &lt; 0) {
                    continue;
                  }
  
                  int32_t relUnitIndex = relUnitFromGeneric(genericUnit);
<span class="line-modified">!                 if (relUnitIndex == UDAT_REL_UNIT_SECOND &amp;&amp; uprv_strcmp(key, &quot;0&quot;) == 0 &amp;&amp;</span>
                      outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW][UDAT_DIRECTION_PLAIN].isEmpty()) {
                      // Handle &quot;NOW&quot;
                      outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW]
                          [UDAT_DIRECTION_PLAIN].fastCopyFrom(value.getUnicodeString(errorCode));
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 461,14 ***</span>
                  if (pluralIndex &gt;= 0) {
                      SimpleFormatter **patterns =
                          outputData.relativeUnitsFormatters[style][relUnitIndex]
                          [pastFutureIndex];
                      // Only set if not already established.
<span class="line-modified">!                     if (patterns[pluralIndex] == NULL) {</span>
                          patterns[pluralIndex] = new SimpleFormatter(
                              value.getUnicodeString(errorCode), 0, 1, errorCode);
<span class="line-modified">!                         if (patterns[pluralIndex] == NULL) {</span>
                              errorCode = U_MEMORY_ALLOCATION_ERROR;
                          }
                      }
                  }
              }
<span class="line-new-header">--- 508,14 ---</span>
                  if (pluralIndex &gt;= 0) {
                      SimpleFormatter **patterns =
                          outputData.relativeUnitsFormatters[style][relUnitIndex]
                          [pastFutureIndex];
                      // Only set if not already established.
<span class="line-modified">!                     if (patterns[pluralIndex] == nullptr) {</span>
                          patterns[pluralIndex] = new SimpleFormatter(
                              value.getUnicodeString(errorCode), 0, 1, errorCode);
<span class="line-modified">!                         if (patterns[pluralIndex] == nullptr) {</span>
                              errorCode = U_MEMORY_ALLOCATION_ERROR;
                          }
                      }
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 544,11 ***</span>
          for (int32_t i = 0; table.getKeyAndValue(i, key, value); ++i) {
              if (value.getType() == URES_ALIAS) {
                  consumeAlias(key, value, errorCode);
              } else {
                  style = styleFromString(key);
<span class="line-modified">!                 int32_t unitSize = uprv_strlen(key) - styleSuffixLength(style);</span>
                  genericUnit = unitOrNegativeFromString(key, unitSize);
                  if (style &gt;= 0 &amp;&amp; genericUnit != INVALID_UNIT) {
                      consumeTimeUnit(key, value, errorCode);
                  }
              }
<span class="line-new-header">--- 591,11 ---</span>
          for (int32_t i = 0; table.getKeyAndValue(i, key, value); ++i) {
              if (value.getType() == URES_ALIAS) {
                  consumeAlias(key, value, errorCode);
              } else {
                  style = styleFromString(key);
<span class="line-modified">!                 int32_t unitSize = static_cast&lt;int32_t&gt;(uprv_strlen(key)) - styleSuffixLength(style);</span>
                  genericUnit = unitOrNegativeFromString(key, unitSize);
                  if (style &gt;= 0 &amp;&amp; genericUnit != INVALID_UNIT) {
                      consumeTimeUnit(key, value, errorCode);
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 568,12 ***</span>
<span class="line-new-header">--- 615,18 ---</span>
  // Get days of weeks from the DateFormatSymbols class.
  static void loadWeekdayNames(UnicodeString absoluteUnits[UDAT_STYLE_COUNT]
                                   [UDAT_ABSOLUTE_UNIT_COUNT][UDAT_DIRECTION_COUNT],
                               const char* localeId,
                               UErrorCode&amp; status) {
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      Locale locale(localeId);
      DateFormatSymbols dfSym(locale, status);
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
          DateFormatSymbols::DtWidthType dtfmtWidth = styleToDateFormatSymbolWidth[style];
          int32_t count;
          const UnicodeString* weekdayNames =
              dfSym.getWeekdays(count, DateFormatSymbols::STANDALONE, dtfmtWidth);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 593,10 ***</span>
<span class="line-new-header">--- 646,13 ---</span>
          UErrorCode &amp;status) {
  
      RelDateTimeFmtDataSink sink(cacheData);
  
      ures_getAllItemsWithFallback(resource, &quot;fields&quot;, sink, status);
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
  
      // Get the weekday names from DateFormatSymbols.
      loadWeekdayNames(cacheData.absoluteUnits, localeId, status);
      return U_SUCCESS(status);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 617,11 ***</span>
      pathBuffer.append(&quot;calendar/&quot;, status)
              .appendInvariantChars(defaultCalendarName, status)
              .append(&quot;/DateTimePatterns&quot;, status);
      LocalUResourceBundlePointer topLevel(
              ures_getByKeyWithFallback(
<span class="line-modified">!                     resource, pathBuffer.data(), NULL, &amp;status));</span>
      if (U_FAILURE(status)) {
          return FALSE;
      }
      int32_t size = ures_getSize(topLevel.getAlias());
      if (size &lt;= 8) {
<span class="line-new-header">--- 673,11 ---</span>
      pathBuffer.append(&quot;calendar/&quot;, status)
              .appendInvariantChars(defaultCalendarName, status)
              .append(&quot;/DateTimePatterns&quot;, status);
      LocalUResourceBundlePointer topLevel(
              ures_getByKeyWithFallback(
<span class="line-modified">!                     resource, pathBuffer.data(), nullptr, &amp;status));</span>
      if (U_FAILURE(status)) {
          return FALSE;
      }
      int32_t size = ures_getSize(topLevel.getAlias());
      if (size &lt;= 8) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 634,86 ***</span>
  }
  
  template&lt;&gt; U_I18N_API
  const RelativeDateTimeCacheData *LocaleCacheKey&lt;RelativeDateTimeCacheData&gt;::createObject(const void * /*unused*/, UErrorCode &amp;status) const {
      const char *localeId = fLoc.getName();
<span class="line-modified">!     LocalUResourceBundlePointer topLevel(ures_open(NULL, localeId, &amp;status));</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
      LocalPointer&lt;RelativeDateTimeCacheData&gt; result(
              new RelativeDateTimeCacheData());
      if (result.isNull()) {
          status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">!         return NULL;</span>
      }
      if (!loadUnitData(
              topLevel.getAlias(),
              *result,
              localeId,
              status)) {
<span class="line-modified">!         return NULL;</span>
      }
      UnicodeString dateTimePattern;
      if (!getDateTimePattern(topLevel.getAlias(), dateTimePattern, status)) {
<span class="line-modified">!         return NULL;</span>
      }
      result-&gt;adoptCombinedDateAndTime(
              new SimpleFormatter(dateTimePattern, 2, 2, status));
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
      result-&gt;addRef();
      return result.orphan();
  }
  
  RelativeDateTimeFormatter::RelativeDateTimeFormatter(UErrorCode&amp; status) :
<span class="line-modified">!         fCache(NULL),</span>
<span class="line-modified">!         fNumberFormat(NULL),</span>
<span class="line-modified">!         fPluralRules(NULL),</span>
          fStyle(UDAT_STYLE_LONG),
          fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified">!         fOptBreakIterator(NULL) {</span>
<span class="line-modified">!     init(NULL, NULL, status);</span>
  }
  
  RelativeDateTimeFormatter::RelativeDateTimeFormatter(
          const Locale&amp; locale, UErrorCode&amp; status) :
<span class="line-modified">!         fCache(NULL),</span>
<span class="line-modified">!         fNumberFormat(NULL),</span>
<span class="line-modified">!         fPluralRules(NULL),</span>
          fStyle(UDAT_STYLE_LONG),
          fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified">!         fOptBreakIterator(NULL),</span>
          fLocale(locale) {
<span class="line-modified">!     init(NULL, NULL, status);</span>
  }
  
  RelativeDateTimeFormatter::RelativeDateTimeFormatter(
          const Locale&amp; locale, NumberFormat *nfToAdopt, UErrorCode&amp; status) :
<span class="line-modified">!         fCache(NULL),</span>
<span class="line-modified">!         fNumberFormat(NULL),</span>
<span class="line-modified">!         fPluralRules(NULL),</span>
          fStyle(UDAT_STYLE_LONG),
          fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified">!         fOptBreakIterator(NULL),</span>
          fLocale(locale) {
<span class="line-modified">!     init(nfToAdopt, NULL, status);</span>
  }
  
  RelativeDateTimeFormatter::RelativeDateTimeFormatter(
          const Locale&amp; locale,
          NumberFormat *nfToAdopt,
          UDateRelativeDateTimeFormatterStyle styl,
          UDisplayContext capitalizationContext,
          UErrorCode&amp; status) :
<span class="line-modified">!         fCache(NULL),</span>
<span class="line-modified">!         fNumberFormat(NULL),</span>
<span class="line-modified">!         fPluralRules(NULL),</span>
          fStyle(styl),
          fContext(capitalizationContext),
<span class="line-modified">!         fOptBreakIterator(NULL),</span>
          fLocale(locale) {
      if (U_FAILURE(status)) {
          return;
      }
      if ((capitalizationContext &gt;&gt; 8) != UDISPCTX_TYPE_CAPITALIZATION) {
<span class="line-new-header">--- 690,106 ---</span>
  }
  
  template&lt;&gt; U_I18N_API
  const RelativeDateTimeCacheData *LocaleCacheKey&lt;RelativeDateTimeCacheData&gt;::createObject(const void * /*unused*/, UErrorCode &amp;status) const {
      const char *localeId = fLoc.getName();
<span class="line-modified">!     LocalUResourceBundlePointer topLevel(ures_open(nullptr, localeId, &amp;status));</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      LocalPointer&lt;RelativeDateTimeCacheData&gt; result(
              new RelativeDateTimeCacheData());
      if (result.isNull()) {
          status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">!         return nullptr;</span>
      }
      if (!loadUnitData(
              topLevel.getAlias(),
              *result,
              localeId,
              status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      UnicodeString dateTimePattern;
      if (!getDateTimePattern(topLevel.getAlias(), dateTimePattern, status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      result-&gt;adoptCombinedDateAndTime(
              new SimpleFormatter(dateTimePattern, 2, 2, status));
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      result-&gt;addRef();
      return result.orphan();
  }
  
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ static constexpr number::impl::Field kRDTNumericField</span>
<span class="line-added">+     = number::impl::NumFieldUtils::compress&lt;UFIELD_CATEGORY_RELATIVE_DATETIME, UDAT_REL_NUMERIC_FIELD&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+ static constexpr number::impl::Field kRDTLiteralField</span>
<span class="line-added">+     = number::impl::NumFieldUtils::compress&lt;UFIELD_CATEGORY_RELATIVE_DATETIME, UDAT_REL_LITERAL_FIELD&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+ class FormattedRelativeDateTimeData : public FormattedValueNumberStringBuilderImpl {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     FormattedRelativeDateTimeData() : FormattedValueNumberStringBuilderImpl(kRDTNumericField) {}</span>
<span class="line-added">+     virtual ~FormattedRelativeDateTimeData();</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ FormattedRelativeDateTimeData::~FormattedRelativeDateTimeData() = default;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ UPRV_FORMATTED_VALUE_SUBCLASS_AUTO_IMPL(FormattedRelativeDateTime)</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  RelativeDateTimeFormatter::RelativeDateTimeFormatter(UErrorCode&amp; status) :
<span class="line-modified">!         fCache(nullptr),</span>
<span class="line-modified">!         fNumberFormat(nullptr),</span>
<span class="line-modified">!         fPluralRules(nullptr),</span>
          fStyle(UDAT_STYLE_LONG),
          fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified">!         fOptBreakIterator(nullptr) {</span>
<span class="line-modified">!     init(nullptr, nullptr, status);</span>
  }
  
  RelativeDateTimeFormatter::RelativeDateTimeFormatter(
          const Locale&amp; locale, UErrorCode&amp; status) :
<span class="line-modified">!         fCache(nullptr),</span>
<span class="line-modified">!         fNumberFormat(nullptr),</span>
<span class="line-modified">!         fPluralRules(nullptr),</span>
          fStyle(UDAT_STYLE_LONG),
          fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified">!         fOptBreakIterator(nullptr),</span>
          fLocale(locale) {
<span class="line-modified">!     init(nullptr, nullptr, status);</span>
  }
  
  RelativeDateTimeFormatter::RelativeDateTimeFormatter(
          const Locale&amp; locale, NumberFormat *nfToAdopt, UErrorCode&amp; status) :
<span class="line-modified">!         fCache(nullptr),</span>
<span class="line-modified">!         fNumberFormat(nullptr),</span>
<span class="line-modified">!         fPluralRules(nullptr),</span>
          fStyle(UDAT_STYLE_LONG),
          fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified">!         fOptBreakIterator(nullptr),</span>
          fLocale(locale) {
<span class="line-modified">!     init(nfToAdopt, nullptr, status);</span>
  }
  
  RelativeDateTimeFormatter::RelativeDateTimeFormatter(
          const Locale&amp; locale,
          NumberFormat *nfToAdopt,
          UDateRelativeDateTimeFormatterStyle styl,
          UDisplayContext capitalizationContext,
          UErrorCode&amp; status) :
<span class="line-modified">!         fCache(nullptr),</span>
<span class="line-modified">!         fNumberFormat(nullptr),</span>
<span class="line-modified">!         fPluralRules(nullptr),</span>
          fStyle(styl),
          fContext(capitalizationContext),
<span class="line-modified">!         fOptBreakIterator(nullptr),</span>
          fLocale(locale) {
      if (U_FAILURE(status)) {
          return;
      }
      if ((capitalizationContext &gt;&gt; 8) != UDISPCTX_TYPE_CAPITALIZATION) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 725,11 ***</span>
          if (U_FAILURE(status)) {
              return;
          }
          init(nfToAdopt, bi, status);
      } else {
<span class="line-modified">!         init(nfToAdopt, NULL, status);</span>
      }
  }
  
  RelativeDateTimeFormatter::RelativeDateTimeFormatter(
          const RelativeDateTimeFormatter&amp; other)
<span class="line-new-header">--- 801,11 ---</span>
          if (U_FAILURE(status)) {
              return;
          }
          init(nfToAdopt, bi, status);
      } else {
<span class="line-modified">!         init(nfToAdopt, nullptr, status);</span>
      }
  }
  
  RelativeDateTimeFormatter::RelativeDateTimeFormatter(
          const RelativeDateTimeFormatter&amp; other)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 742,11 ***</span>
            fOptBreakIterator(other.fOptBreakIterator),
            fLocale(other.fLocale) {
      fCache-&gt;addRef();
      fNumberFormat-&gt;addRef();
      fPluralRules-&gt;addRef();
<span class="line-modified">!     if (fOptBreakIterator != NULL) {</span>
        fOptBreakIterator-&gt;addRef();
      }
  }
  
  RelativeDateTimeFormatter&amp; RelativeDateTimeFormatter::operator=(
<span class="line-new-header">--- 818,11 ---</span>
            fOptBreakIterator(other.fOptBreakIterator),
            fLocale(other.fLocale) {
      fCache-&gt;addRef();
      fNumberFormat-&gt;addRef();
      fPluralRules-&gt;addRef();
<span class="line-modified">!     if (fOptBreakIterator != nullptr) {</span>
        fOptBreakIterator-&gt;addRef();
      }
  }
  
  RelativeDateTimeFormatter&amp; RelativeDateTimeFormatter::operator=(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,20 ***</span>
      }
      return *this;
  }
  
  RelativeDateTimeFormatter::~RelativeDateTimeFormatter() {
<span class="line-modified">!     if (fCache != NULL) {</span>
          fCache-&gt;removeRef();
      }
<span class="line-modified">!     if (fNumberFormat != NULL) {</span>
          fNumberFormat-&gt;removeRef();
      }
<span class="line-modified">!     if (fPluralRules != NULL) {</span>
          fPluralRules-&gt;removeRef();
      }
<span class="line-modified">!     if (fOptBreakIterator != NULL) {</span>
          fOptBreakIterator-&gt;removeRef();
      }
  }
  
  const NumberFormat&amp; RelativeDateTimeFormatter::getNumberFormat() const {
<span class="line-new-header">--- 838,20 ---</span>
      }
      return *this;
  }
  
  RelativeDateTimeFormatter::~RelativeDateTimeFormatter() {
<span class="line-modified">!     if (fCache != nullptr) {</span>
          fCache-&gt;removeRef();
      }
<span class="line-modified">!     if (fNumberFormat != nullptr) {</span>
          fNumberFormat-&gt;removeRef();
      }
<span class="line-modified">!     if (fPluralRules != nullptr) {</span>
          fPluralRules-&gt;removeRef();
      }
<span class="line-modified">!     if (fOptBreakIterator != nullptr) {</span>
          fOptBreakIterator-&gt;removeRef();
      }
  }
  
  const NumberFormat&amp; RelativeDateTimeFormatter::getNumberFormat() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 788,102 ***</span>
  
  UDateRelativeDateTimeFormatterStyle RelativeDateTimeFormatter::getFormatStyle() const {
      return fStyle;
  }
  
<span class="line-modified">! UnicodeString&amp; RelativeDateTimeFormatter::format(</span>
<span class="line-modified">!         double quantity, UDateDirection direction, UDateRelativeUnit unit,</span>
<span class="line-modified">!         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>
      if (U_FAILURE(status)) {
          return appendTo;
      }
      if (direction != UDAT_DIRECTION_LAST &amp;&amp; direction != UDAT_DIRECTION_NEXT) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">!         return appendTo;</span>
      }
      int32_t bFuture = direction == UDAT_DIRECTION_NEXT ? 1 : 0;
<span class="line-removed">-     FieldPosition pos(FieldPosition::DONT_CARE);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     UnicodeString result;</span>
<span class="line-removed">-     UnicodeString formattedNumber;</span>
  
<span class="line-modified">!     StandardPlural::Form pluralIndex = QuantityFormatter::selectPlural(</span>
<span class="line-modified">!         quantity, **fNumberFormat, **fPluralRules, formattedNumber, pos,</span>
          status);
  
      const SimpleFormatter* formatter =
<span class="line-modified">!         fCache-&gt;getRelativeUnitFormatter(fStyle, unit, bFuture, pluralIndex);</span>
<span class="line-modified">!     if (formatter == NULL) {</span>
          // TODO: WARN - look at quantity formatter&#39;s action with an error.
          status = U_INVALID_FORMAT_ERROR;
<span class="line-modified">!         return appendTo;</span>
      }
<span class="line-modified">!     formatter-&gt;format(formattedNumber, result, status);</span>
<span class="line-modified">!     adjustForContext(result);</span>
<span class="line-modified">!     return appendTo.append(result);</span>
  }
  
  UnicodeString&amp; RelativeDateTimeFormatter::formatNumeric(
<span class="line-modified">!         double offset, URelativeDateTimeUnit unit,</span>
<span class="line-modified">!         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return appendTo;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // TODO:</span>
<span class="line-removed">-     // The full implementation of this depends on CLDR data that is not yet available,</span>
<span class="line-removed">-     // see: http://unicode.org/cldr/trac/ticket/9165 Add more relative field data.</span>
<span class="line-removed">-     // In the meantime do a quick bring-up by calling the old format method; this</span>
<span class="line-removed">-     // leaves some holes (even for data that is currently available, such as quarter).</span>
<span class="line-removed">-     // When the new CLDR data is available, update the data storage accordingly,</span>
<span class="line-removed">-     // rewrite this to use it directly, and rewrite the old format method to call this</span>
<span class="line-removed">-     // new one; that is covered by http://bugs.icu-project.org/trac/ticket/12171.</span>
<span class="line-removed">-     UDateRelativeUnit relunit = UDAT_RELATIVE_UNIT_COUNT;</span>
<span class="line-removed">-     switch (unit) {</span>
<span class="line-removed">-         case UDAT_REL_UNIT_YEAR:    relunit = UDAT_RELATIVE_YEARS; break;</span>
<span class="line-removed">-         case UDAT_REL_UNIT_MONTH:   relunit = UDAT_RELATIVE_MONTHS; break;</span>
<span class="line-removed">-         case UDAT_REL_UNIT_WEEK:    relunit = UDAT_RELATIVE_WEEKS; break;</span>
<span class="line-removed">-         case UDAT_REL_UNIT_DAY:     relunit = UDAT_RELATIVE_DAYS; break;</span>
<span class="line-removed">-         case UDAT_REL_UNIT_HOUR:    relunit = UDAT_RELATIVE_HOURS; break;</span>
<span class="line-removed">-         case UDAT_REL_UNIT_MINUTE:  relunit = UDAT_RELATIVE_MINUTES; break;</span>
<span class="line-removed">-         case UDAT_REL_UNIT_SECOND:  relunit = UDAT_RELATIVE_SECONDS; break;</span>
<span class="line-removed">-         default: // a unit that the above method does not handle</span>
<span class="line-removed">-             status = U_UNSUPPORTED_ERROR;</span>
<span class="line-removed">-             return appendTo;</span>
      }
      UDateDirection direction = UDAT_DIRECTION_NEXT;
      if (std::signbit(offset)) { // needed to handle -0.0
          direction = UDAT_DIRECTION_LAST;
          offset = -offset;
      }
<span class="line-modified">!     return format(offset, direction, relunit, appendTo, status);</span>
  }
  
  UnicodeString&amp; RelativeDateTimeFormatter::format(
<span class="line-modified">!         UDateDirection direction, UDateAbsoluteUnit unit,</span>
<span class="line-modified">!         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return appendTo;</span>
      }
      if (unit == UDAT_ABSOLUTE_NOW &amp;&amp; direction != UDAT_DIRECTION_PLAIN) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">!         return appendTo;</span>
      }
  
      // Get string using fallback.
<span class="line-modified">!     UnicodeString result;</span>
<span class="line-modified">!     result.fastCopyFrom(fCache-&gt;getAbsoluteUnitString(fStyle, unit, direction));</span>
<span class="line-modified">!     if (fOptBreakIterator != NULL) {</span>
<span class="line-modified">!         adjustForContext(result);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return appendTo.append(result);</span>
  }
  
  UnicodeString&amp; RelativeDateTimeFormatter::format(
<span class="line-modified">!         double offset, URelativeDateTimeUnit unit,</span>
<span class="line-modified">!         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return appendTo;</span>
      }
      // TODO:
      // The full implementation of this depends on CLDR data that is not yet available,
      // see: http://unicode.org/cldr/trac/ticket/9165 Add more relative field data.
      // In the meantime do a quick bring-up by calling the old format method; this
<span class="line-new-header">--- 864,258 ---</span>
  
  UDateRelativeDateTimeFormatterStyle RelativeDateTimeFormatter::getFormatStyle() const {
      return fStyle;
  }
  
<span class="line-modified">! </span>
<span class="line-modified">! // To reduce boilerplate code, we use a helper function that forwards variadic</span>
<span class="line-modified">! // arguments to the formatImpl function.</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename F, typename... Args&gt;</span>
<span class="line-added">+ UnicodeString&amp; RelativeDateTimeFormatter::doFormat(</span>
<span class="line-added">+         F callback,</span>
<span class="line-added">+         UnicodeString&amp; appendTo,</span>
<span class="line-added">+         UErrorCode&amp; status,</span>
<span class="line-added">+         Args... args) const {</span>
<span class="line-added">+     FormattedRelativeDateTimeData output;</span>
<span class="line-added">+     (this-&gt;*callback)(std::forward&lt;Args&gt;(args)..., output, status);</span>
      if (U_FAILURE(status)) {
          return appendTo;
      }
<span class="line-added">+     UnicodeString result = output.getStringRef().toUnicodeString();</span>
<span class="line-added">+     return appendTo.append(adjustForContext(result));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename F, typename... Args&gt;</span>
<span class="line-added">+ FormattedRelativeDateTime RelativeDateTimeFormatter::doFormatToValue(</span>
<span class="line-added">+         F callback,</span>
<span class="line-added">+         UErrorCode&amp; status,</span>
<span class="line-added">+         Args... args) const {</span>
<span class="line-added">+     if (!checkNoAdjustForContext(status)) {</span>
<span class="line-added">+         return FormattedRelativeDateTime(status);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     LocalPointer&lt;FormattedRelativeDateTimeData&gt; output(</span>
<span class="line-added">+         new FormattedRelativeDateTimeData(), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return FormattedRelativeDateTime(status);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     (this-&gt;*callback)(std::forward&lt;Args&gt;(args)..., *output, status);</span>
<span class="line-added">+     output-&gt;getStringRef().writeTerminator(status);</span>
<span class="line-added">+     return FormattedRelativeDateTime(output.orphan());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ UnicodeString&amp; RelativeDateTimeFormatter::format(</span>
<span class="line-added">+         double quantity,</span>
<span class="line-added">+         UDateDirection direction,</span>
<span class="line-added">+         UDateRelativeUnit unit,</span>
<span class="line-added">+         UnicodeString&amp; appendTo,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     return doFormat(</span>
<span class="line-added">+         &amp;RelativeDateTimeFormatter::formatImpl,</span>
<span class="line-added">+         appendTo,</span>
<span class="line-added">+         status,</span>
<span class="line-added">+         quantity,</span>
<span class="line-added">+         direction,</span>
<span class="line-added">+         unit);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FormattedRelativeDateTime RelativeDateTimeFormatter::formatToValue(</span>
<span class="line-added">+         double quantity,</span>
<span class="line-added">+         UDateDirection direction,</span>
<span class="line-added">+         UDateRelativeUnit unit,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     return doFormatToValue(</span>
<span class="line-added">+         &amp;RelativeDateTimeFormatter::formatImpl,</span>
<span class="line-added">+         status,</span>
<span class="line-added">+         quantity,</span>
<span class="line-added">+         direction,</span>
<span class="line-added">+         unit);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RelativeDateTimeFormatter::formatImpl(</span>
<span class="line-added">+         double quantity,</span>
<span class="line-added">+         UDateDirection direction,</span>
<span class="line-added">+         UDateRelativeUnit unit,</span>
<span class="line-added">+         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (direction != UDAT_DIRECTION_LAST &amp;&amp; direction != UDAT_DIRECTION_NEXT) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">!         return;</span>
      }
      int32_t bFuture = direction == UDAT_DIRECTION_NEXT ? 1 : 0;
  
<span class="line-modified">!     StandardPlural::Form pluralForm;</span>
<span class="line-modified">!     QuantityFormatter::formatAndSelect(</span>
<span class="line-added">+         quantity,</span>
<span class="line-added">+         **fNumberFormat,</span>
<span class="line-added">+         **fPluralRules,</span>
<span class="line-added">+         output.getStringRef(),</span>
<span class="line-added">+         pluralForm,</span>
          status);
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
      const SimpleFormatter* formatter =
<span class="line-modified">!         fCache-&gt;getRelativeUnitFormatter(fStyle, unit, bFuture, pluralForm);</span>
<span class="line-modified">!     if (formatter == nullptr) {</span>
          // TODO: WARN - look at quantity formatter&#39;s action with an error.
          status = U_INVALID_FORMAT_ERROR;
<span class="line-modified">!         return;</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     number::impl::SimpleModifier modifier(*formatter, kRDTLiteralField, false);</span>
<span class="line-modified">!     modifier.formatAsPrefixSuffix(</span>
<span class="line-added">+         output.getStringRef(), 0, output.getStringRef().length(), status);</span>
  }
  
  UnicodeString&amp; RelativeDateTimeFormatter::formatNumeric(
<span class="line-modified">!         double offset,</span>
<span class="line-modified">!         URelativeDateTimeUnit unit,</span>
<span class="line-added">+         UnicodeString&amp; appendTo,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     return doFormat(</span>
<span class="line-added">+         &amp;RelativeDateTimeFormatter::formatNumericImpl,</span>
<span class="line-added">+         appendTo,</span>
<span class="line-added">+         status,</span>
<span class="line-added">+         offset,</span>
<span class="line-added">+         unit);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FormattedRelativeDateTime RelativeDateTimeFormatter::formatNumericToValue(</span>
<span class="line-added">+         double offset,</span>
<span class="line-added">+         URelativeDateTimeUnit unit,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     return doFormatToValue(</span>
<span class="line-added">+         &amp;RelativeDateTimeFormatter::formatNumericImpl,</span>
<span class="line-added">+         status,</span>
<span class="line-added">+         offset,</span>
<span class="line-added">+         unit);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RelativeDateTimeFormatter::formatNumericImpl(</span>
<span class="line-added">+         double offset,</span>
<span class="line-added">+         URelativeDateTimeUnit unit,</span>
<span class="line-added">+         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return;</span>
      }
      UDateDirection direction = UDAT_DIRECTION_NEXT;
      if (std::signbit(offset)) { // needed to handle -0.0
          direction = UDAT_DIRECTION_LAST;
          offset = -offset;
      }
<span class="line-modified">!     if (direction != UDAT_DIRECTION_LAST &amp;&amp; direction != UDAT_DIRECTION_NEXT) {</span>
<span class="line-added">+         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     int32_t bFuture = direction == UDAT_DIRECTION_NEXT ? 1 : 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     StandardPlural::Form pluralForm;</span>
<span class="line-added">+     QuantityFormatter::formatAndSelect(</span>
<span class="line-added">+         offset,</span>
<span class="line-added">+         **fNumberFormat,</span>
<span class="line-added">+         **fPluralRules,</span>
<span class="line-added">+         output.getStringRef(),</span>
<span class="line-added">+         pluralForm,</span>
<span class="line-added">+         status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     const SimpleFormatter* formatter =</span>
<span class="line-added">+         fCache-&gt;getRelativeDateTimeUnitFormatter(fStyle, unit, bFuture, pluralForm);</span>
<span class="line-added">+     if (formatter == nullptr) {</span>
<span class="line-added">+         // TODO: WARN - look at quantity formatter&#39;s action with an error.</span>
<span class="line-added">+         status = U_INVALID_FORMAT_ERROR;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     number::impl::SimpleModifier modifier(*formatter, kRDTLiteralField, false);</span>
<span class="line-added">+     modifier.formatAsPrefixSuffix(</span>
<span class="line-added">+         output.getStringRef(), 0, output.getStringRef().length(), status);</span>
  }
  
  UnicodeString&amp; RelativeDateTimeFormatter::format(
<span class="line-modified">!         UDateDirection direction,</span>
<span class="line-modified">!         UDateAbsoluteUnit unit,</span>
<span class="line-added">+         UnicodeString&amp; appendTo,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     return doFormat(</span>
<span class="line-added">+         &amp;RelativeDateTimeFormatter::formatAbsoluteImpl,</span>
<span class="line-added">+         appendTo,</span>
<span class="line-added">+         status,</span>
<span class="line-added">+         direction,</span>
<span class="line-added">+         unit);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FormattedRelativeDateTime RelativeDateTimeFormatter::formatToValue(</span>
<span class="line-added">+         UDateDirection direction,</span>
<span class="line-added">+         UDateAbsoluteUnit unit,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     return doFormatToValue(</span>
<span class="line-added">+         &amp;RelativeDateTimeFormatter::formatAbsoluteImpl,</span>
<span class="line-added">+         status,</span>
<span class="line-added">+         direction,</span>
<span class="line-added">+         unit);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RelativeDateTimeFormatter::formatAbsoluteImpl(</span>
<span class="line-added">+         UDateDirection direction,</span>
<span class="line-added">+         UDateAbsoluteUnit unit,</span>
<span class="line-added">+         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return;</span>
      }
      if (unit == UDAT_ABSOLUTE_NOW &amp;&amp; direction != UDAT_DIRECTION_PLAIN) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">!         return;</span>
      }
  
      // Get string using fallback.
<span class="line-modified">!     output.getStringRef().append(</span>
<span class="line-modified">!         fCache-&gt;getAbsoluteUnitString(fStyle, unit, direction),</span>
<span class="line-modified">!         kRDTLiteralField,</span>
<span class="line-modified">!         status);</span>
  }
  
  UnicodeString&amp; RelativeDateTimeFormatter::format(
<span class="line-modified">!         double offset,</span>
<span class="line-modified">!         URelativeDateTimeUnit unit,</span>
<span class="line-added">+         UnicodeString&amp; appendTo,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     return doFormat(</span>
<span class="line-added">+         &amp;RelativeDateTimeFormatter::formatRelativeImpl,</span>
<span class="line-added">+         appendTo,</span>
<span class="line-added">+         status,</span>
<span class="line-added">+         offset,</span>
<span class="line-added">+         unit);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FormattedRelativeDateTime RelativeDateTimeFormatter::formatToValue(</span>
<span class="line-added">+         double offset,</span>
<span class="line-added">+         URelativeDateTimeUnit unit,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     return doFormatToValue(</span>
<span class="line-added">+         &amp;RelativeDateTimeFormatter::formatRelativeImpl,</span>
<span class="line-added">+         status,</span>
<span class="line-added">+         offset,</span>
<span class="line-added">+         unit);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RelativeDateTimeFormatter::formatRelativeImpl(</span>
<span class="line-added">+         double offset,</span>
<span class="line-added">+         URelativeDateTimeUnit unit,</span>
<span class="line-added">+         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return;</span>
      }
      // TODO:
      // The full implementation of this depends on CLDR data that is not yet available,
      // see: http://unicode.org/cldr/trac/ticket/9165 Add more relative field data.
      // In the meantime do a quick bring-up by calling the old format method; this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 906,10 ***</span>
<span class="line-new-header">--- 1138,11 ---</span>
          }
      }
      UDateAbsoluteUnit absunit = UDAT_ABSOLUTE_UNIT_COUNT;
      switch (unit) {
          case UDAT_REL_UNIT_YEAR:    absunit = UDAT_ABSOLUTE_YEAR; break;
<span class="line-added">+         case UDAT_REL_UNIT_QUARTER: absunit = UDAT_ABSOLUTE_QUARTER; break;</span>
          case UDAT_REL_UNIT_MONTH:   absunit = UDAT_ABSOLUTE_MONTH; break;
          case UDAT_REL_UNIT_WEEK:    absunit = UDAT_ABSOLUTE_WEEK; break;
          case UDAT_REL_UNIT_DAY:     absunit = UDAT_ABSOLUTE_DAY; break;
          case UDAT_REL_UNIT_SECOND:
              if (direction == UDAT_DIRECTION_THIS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 925,46 ***</span>
          case UDAT_REL_UNIT_FRIDAY:  absunit = UDAT_ABSOLUTE_FRIDAY; break;
          case UDAT_REL_UNIT_SATURDAY:  absunit = UDAT_ABSOLUTE_SATURDAY; break;
          default: break;
      }
      if (direction != UDAT_DIRECTION_COUNT &amp;&amp; absunit != UDAT_ABSOLUTE_UNIT_COUNT) {
<span class="line-modified">!         const UnicodeString &amp;unitFormatString =</span>
<span class="line-modified">!             fCache-&gt;getAbsoluteUnitString(fStyle, absunit, direction);</span>
<span class="line-modified">!         if (!unitFormatString.isEmpty()) {</span>
<span class="line-removed">-             if (fOptBreakIterator != NULL) {</span>
<span class="line-removed">-                 UnicodeString result(unitFormatString);</span>
<span class="line-removed">-                 adjustForContext(result);</span>
<span class="line-removed">-                 return appendTo.append(result);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 return appendTo.append(unitFormatString);</span>
<span class="line-removed">-             }</span>
          }
      }
      // otherwise fallback to formatNumeric
<span class="line-modified">!     return formatNumeric(offset, unit, appendTo, status);</span>
  }
  
  UnicodeString&amp; RelativeDateTimeFormatter::combineDateAndTime(
          const UnicodeString&amp; relativeDateString, const UnicodeString&amp; timeString,
          UnicodeString&amp; appendTo, UErrorCode&amp; status) const {
      return fCache-&gt;getCombinedDateAndTime()-&gt;format(
              timeString, relativeDateString, appendTo, status);
  }
  
<span class="line-modified">! void RelativeDateTimeFormatter::adjustForContext(UnicodeString &amp;str) const {</span>
<span class="line-modified">!     if (fOptBreakIterator == NULL</span>
          || str.length() == 0 || !u_islower(str.char32At(0))) {
<span class="line-modified">!         return;</span>
      }
  
      // Must guarantee that one thread at a time accesses the shared break
      // iterator.
      Mutex lock(&amp;gBrkIterMutex);
      str.toTitle(
              fOptBreakIterator-&gt;get(),
              fLocale,
              U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
  }
  
  void RelativeDateTimeFormatter::init(
          NumberFormat *nfToAdopt,
          BreakIterator *biToAdopt,
<span class="line-new-header">--- 1158,51 ---</span>
          case UDAT_REL_UNIT_FRIDAY:  absunit = UDAT_ABSOLUTE_FRIDAY; break;
          case UDAT_REL_UNIT_SATURDAY:  absunit = UDAT_ABSOLUTE_SATURDAY; break;
          default: break;
      }
      if (direction != UDAT_DIRECTION_COUNT &amp;&amp; absunit != UDAT_ABSOLUTE_UNIT_COUNT) {
<span class="line-modified">!         formatAbsoluteImpl(direction, absunit, output, status);</span>
<span class="line-modified">!         if (output.getStringRef().length() != 0) {</span>
<span class="line-modified">!             return;</span>
          }
      }
      // otherwise fallback to formatNumeric
<span class="line-modified">!     formatNumericImpl(offset, unit, output, status);</span>
  }
  
  UnicodeString&amp; RelativeDateTimeFormatter::combineDateAndTime(
          const UnicodeString&amp; relativeDateString, const UnicodeString&amp; timeString,
          UnicodeString&amp; appendTo, UErrorCode&amp; status) const {
      return fCache-&gt;getCombinedDateAndTime()-&gt;format(
              timeString, relativeDateString, appendTo, status);
  }
  
<span class="line-modified">! UnicodeString&amp; RelativeDateTimeFormatter::adjustForContext(UnicodeString &amp;str) const {</span>
<span class="line-modified">!     if (fOptBreakIterator == nullptr</span>
          || str.length() == 0 || !u_islower(str.char32At(0))) {
<span class="line-modified">!         return str;</span>
      }
  
      // Must guarantee that one thread at a time accesses the shared break
      // iterator.
<span class="line-added">+     static icu::UMutex gBrkIterMutex = U_MUTEX_INITIALIZER;</span>
      Mutex lock(&amp;gBrkIterMutex);
      str.toTitle(
              fOptBreakIterator-&gt;get(),
              fLocale,
              U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
<span class="line-added">+     return str;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ UBool RelativeDateTimeFormatter::checkNoAdjustForContext(UErrorCode&amp; status) const {</span>
<span class="line-added">+     // This is unsupported because it&#39;s hard to keep fields in sync with title</span>
<span class="line-added">+     // casing. The code could be written and tested if there is demand.</span>
<span class="line-added">+     if (fOptBreakIterator != nullptr) {</span>
<span class="line-added">+         status = U_UNSUPPORTED_ERROR;</span>
<span class="line-added">+         return FALSE;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return TRUE;</span>
  }
  
  void RelativeDateTimeFormatter::init(
          NumberFormat *nfToAdopt,
          BreakIterator *biToAdopt,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 990,22 ***</span>
          }
          SharedObject::copyPtr(shared, fNumberFormat);
          shared-&gt;removeRef();
      } else {
          SharedNumberFormat *shared = new SharedNumberFormat(nf.getAlias());
<span class="line-modified">!         if (shared == NULL) {</span>
              status = U_MEMORY_ALLOCATION_ERROR;
              return;
          }
          nf.orphan();
          SharedObject::copyPtr(shared, fNumberFormat);
      }
      if (bi.isNull()) {
          SharedObject::clearPtr(fOptBreakIterator);
      } else {
          SharedBreakIterator *shared = new SharedBreakIterator(bi.getAlias());
<span class="line-modified">!         if (shared == NULL) {</span>
              status = U_MEMORY_ALLOCATION_ERROR;
              return;
          }
          bi.orphan();
          SharedObject::copyPtr(shared, fOptBreakIterator);
<span class="line-new-header">--- 1228,22 ---</span>
          }
          SharedObject::copyPtr(shared, fNumberFormat);
          shared-&gt;removeRef();
      } else {
          SharedNumberFormat *shared = new SharedNumberFormat(nf.getAlias());
<span class="line-modified">!         if (shared == nullptr) {</span>
              status = U_MEMORY_ALLOCATION_ERROR;
              return;
          }
          nf.orphan();
          SharedObject::copyPtr(shared, fNumberFormat);
      }
      if (bi.isNull()) {
          SharedObject::clearPtr(fOptBreakIterator);
      } else {
          SharedBreakIterator *shared = new SharedBreakIterator(bi.getAlias());
<span class="line-modified">!         if (shared == nullptr) {</span>
              status = U_MEMORY_ALLOCATION_ERROR;
              return;
          }
          bi.orphan();
          SharedObject::copyPtr(shared, fOptBreakIterator);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1016,25 ***</span>
  
  // Plain C API
  
  U_NAMESPACE_USE
  
  U_CAPI URelativeDateTimeFormatter* U_EXPORT2
  ureldatefmt_open( const char*          locale,
                    UNumberFormat*       nfToAdopt,
                    UDateRelativeDateTimeFormatterStyle width,
                    UDisplayContext      capitalizationContext,
                    UErrorCode*          status )
  {
      if (U_FAILURE(*status)) {
<span class="line-modified">!         return NULL;</span>
      }
      LocalPointer&lt;RelativeDateTimeFormatter&gt; formatter(new RelativeDateTimeFormatter(Locale(locale),
                                                                (NumberFormat*)nfToAdopt, width,
                                                                capitalizationContext, *status), *status);
      if (U_FAILURE(*status)) {
<span class="line-modified">!         return NULL;</span>
      }
      return (URelativeDateTimeFormatter*)formatter.orphan();
  }
  
  U_CAPI void U_EXPORT2
<span class="line-new-header">--- 1254,36 ---</span>
  
  // Plain C API
  
  U_NAMESPACE_USE
  
<span class="line-added">+ </span>
<span class="line-added">+ // Magic number: &quot;FRDT&quot; (FormattedRelativeDateTime) in ASCII</span>
<span class="line-added">+ UPRV_FORMATTED_VALUE_CAPI_AUTO_IMPL(</span>
<span class="line-added">+     FormattedRelativeDateTime,</span>
<span class="line-added">+     UFormattedRelativeDateTime,</span>
<span class="line-added">+     UFormattedRelativeDateTimeImpl,</span>
<span class="line-added">+     UFormattedRelativeDateTimeApiHelper,</span>
<span class="line-added">+     ureldatefmt,</span>
<span class="line-added">+     0x46524454)</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  U_CAPI URelativeDateTimeFormatter* U_EXPORT2
  ureldatefmt_open( const char*          locale,
                    UNumberFormat*       nfToAdopt,
                    UDateRelativeDateTimeFormatterStyle width,
                    UDisplayContext      capitalizationContext,
                    UErrorCode*          status )
  {
      if (U_FAILURE(*status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      LocalPointer&lt;RelativeDateTimeFormatter&gt; formatter(new RelativeDateTimeFormatter(Locale(locale),
                                                                (NumberFormat*)nfToAdopt, width,
                                                                capitalizationContext, *status), *status);
      if (U_FAILURE(*status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      return (URelativeDateTimeFormatter*)formatter.orphan();
  }
  
  U_CAPI void U_EXPORT2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1052,27 ***</span>
                      UErrorCode*           status)
  {
      if (U_FAILURE(*status)) {
          return 0;
      }
<span class="line-modified">!     if (result == NULL ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
          *status = U_ILLEGAL_ARGUMENT_ERROR;
          return 0;
      }
      UnicodeString res;
<span class="line-modified">!     if (result != NULL) {</span>
<span class="line-modified">!         // NULL destination for pure preflighting: empty dummy string</span>
          // otherwise, alias the destination buffer (copied from udat_format)
          res.setTo(result, 0, resultCapacity);
      }
      ((RelativeDateTimeFormatter*)reldatefmt)-&gt;formatNumeric(offset, unit, res, *status);
      if (U_FAILURE(*status)) {
  U_CAPI int32_t U_EXPORT2
  ureldatefmt_format( const URelativeDateTimeFormatter* reldatefmt,
                      double                offset,
                      URelativeDateTimeUnit unit,
                      UChar*                result,
<span class="line-new-header">--- 1301,42 ---</span>
                      UErrorCode*           status)
  {
      if (U_FAILURE(*status)) {
          return 0;
      }
<span class="line-modified">!     if (result == nullptr ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
          *status = U_ILLEGAL_ARGUMENT_ERROR;
          return 0;
      }
      UnicodeString res;
<span class="line-modified">!     if (result != nullptr) {</span>
<span class="line-modified">!         // nullptr destination for pure preflighting: empty dummy string</span>
          // otherwise, alias the destination buffer (copied from udat_format)
          res.setTo(result, 0, resultCapacity);
      }
      ((RelativeDateTimeFormatter*)reldatefmt)-&gt;formatNumeric(offset, unit, res, *status);
      if (U_FAILURE(*status)) {
<span class="line-added">+ U_STABLE void U_EXPORT2</span>
<span class="line-added">+ ureldatefmt_formatNumericToResult(</span>
<span class="line-added">+         const URelativeDateTimeFormatter* reldatefmt,</span>
<span class="line-added">+         double                            offset,</span>
<span class="line-added">+         URelativeDateTimeUnit             unit,</span>
<span class="line-added">+         UFormattedRelativeDateTime*       result,</span>
<span class="line-added">+         UErrorCode*                       status) {</span>
<span class="line-added">+     if (U_FAILURE(*status)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     auto* fmt = reinterpret_cast&lt;const RelativeDateTimeFormatter*&gt;(reldatefmt);</span>
<span class="line-added">+     auto* resultImpl = UFormattedRelativeDateTimeApiHelper::validate(result, *status);</span>
<span class="line-added">+     resultImpl-&gt;fImpl = fmt-&gt;formatNumericToValue(offset, unit, *status);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  U_CAPI int32_t U_EXPORT2
  ureldatefmt_format( const URelativeDateTimeFormatter* reldatefmt,
                      double                offset,
                      URelativeDateTimeUnit unit,
                      UChar*                result,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1080,27 ***</span>
                      UErrorCode*           status)
  {
      if (U_FAILURE(*status)) {
          return 0;
      }
<span class="line-modified">!     if (result == NULL ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
          *status = U_ILLEGAL_ARGUMENT_ERROR;
          return 0;
      }
      UnicodeString res;
<span class="line-modified">!     if (result != NULL) {</span>
<span class="line-modified">!         // NULL destination for pure preflighting: empty dummy string</span>
          // otherwise, alias the destination buffer (copied from udat_format)
          res.setTo(result, 0, resultCapacity);
      }
      ((RelativeDateTimeFormatter*)reldatefmt)-&gt;format(offset, unit, res, *status);
      if (U_FAILURE(*status)) {
  U_CAPI int32_t U_EXPORT2
  ureldatefmt_combineDateAndTime( const URelativeDateTimeFormatter* reldatefmt,
                      const UChar *     relativeDateString,
                      int32_t           relativeDateStringLen,
                      const UChar *     timeString,
<span class="line-new-header">--- 1344,42 ---</span>
                      UErrorCode*           status)
  {
      if (U_FAILURE(*status)) {
          return 0;
      }
<span class="line-modified">!     if (result == nullptr ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
          *status = U_ILLEGAL_ARGUMENT_ERROR;
          return 0;
      }
      UnicodeString res;
<span class="line-modified">!     if (result != nullptr) {</span>
<span class="line-modified">!         // nullptr destination for pure preflighting: empty dummy string</span>
          // otherwise, alias the destination buffer (copied from udat_format)
          res.setTo(result, 0, resultCapacity);
      }
      ((RelativeDateTimeFormatter*)reldatefmt)-&gt;format(offset, unit, res, *status);
      if (U_FAILURE(*status)) {
<span class="line-added">+ U_DRAFT void U_EXPORT2</span>
<span class="line-added">+ ureldatefmt_formatToResult(</span>
<span class="line-added">+         const URelativeDateTimeFormatter* reldatefmt,</span>
<span class="line-added">+         double                            offset,</span>
<span class="line-added">+         URelativeDateTimeUnit             unit,</span>
<span class="line-added">+         UFormattedRelativeDateTime*       result,</span>
<span class="line-added">+         UErrorCode*                       status) {</span>
<span class="line-added">+     if (U_FAILURE(*status)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     auto* fmt = reinterpret_cast&lt;const RelativeDateTimeFormatter*&gt;(reldatefmt);</span>
<span class="line-added">+     auto* resultImpl = UFormattedRelativeDateTimeApiHelper::validate(result, *status);</span>
<span class="line-added">+     resultImpl-&gt;fImpl = fmt-&gt;formatToValue(offset, unit, *status);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  U_CAPI int32_t U_EXPORT2
  ureldatefmt_combineDateAndTime( const URelativeDateTimeFormatter* reldatefmt,
                      const UChar *     relativeDateString,
                      int32_t           relativeDateStringLen,
                      const UChar *     timeString,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1110,13 ***</span>
                      UErrorCode*       status )
  {
      if (U_FAILURE(*status)) {
          return 0;
      }
<span class="line-modified">!     if (result == NULL ? resultCapacity != 0 : resultCapacity &lt; 0 ||</span>
<span class="line-modified">!             (relativeDateString == NULL ? relativeDateStringLen != 0 : relativeDateStringLen &lt; -1) ||</span>
<span class="line-modified">!             (timeString == NULL ? timeStringLen != 0 : timeStringLen &lt; -1)) {</span>
          *status = U_ILLEGAL_ARGUMENT_ERROR;
          return 0;
      }
      UnicodeString relDateStr((UBool)(relativeDateStringLen == -1), relativeDateString, relativeDateStringLen);
      UnicodeString timeStr((UBool)(timeStringLen == -1), timeString, timeStringLen);
<span class="line-new-header">--- 1389,13 ---</span>
                      UErrorCode*       status )
  {
      if (U_FAILURE(*status)) {
          return 0;
      }
<span class="line-modified">!     if (result == nullptr ? resultCapacity != 0 : resultCapacity &lt; 0 ||</span>
<span class="line-modified">!             (relativeDateString == nullptr ? relativeDateStringLen != 0 : relativeDateStringLen &lt; -1) ||</span>
<span class="line-modified">!             (timeString == nullptr ? timeStringLen != 0 : timeStringLen &lt; -1)) {</span>
          *status = U_ILLEGAL_ARGUMENT_ERROR;
          return 0;
      }
      UnicodeString relDateStr((UBool)(relativeDateStringLen == -1), relativeDateString, relativeDateStringLen);
      UnicodeString timeStr((UBool)(timeStringLen == -1), timeString, timeStringLen);
</pre>
<center><a href="region.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="reldtfmt.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>