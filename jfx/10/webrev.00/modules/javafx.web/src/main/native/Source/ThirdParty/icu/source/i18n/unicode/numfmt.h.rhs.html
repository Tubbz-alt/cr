<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/numfmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ********************************************************************************
   5 * Copyright (C) 1997-2016, International Business Machines Corporation and others.
   6 * All Rights Reserved.
   7 ********************************************************************************
   8 *
   9 * File NUMFMT.H
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   02/19/97    aliu        Converted from java.
  15 *   03/18/97    clhuang     Updated per C++ implementation.
  16 *   04/17/97    aliu        Changed DigitCount to int per code review.
  17 *    07/20/98    stephen        JDK 1.2 sync up. Added scientific support.
  18 *                            Changed naming conventions to match C++ guidelines
  19 *                            Derecated Java style constants (eg, INTEGER_FIELD)
  20 ********************************************************************************
  21 */
  22 
  23 #ifndef NUMFMT_H
  24 #define NUMFMT_H
  25 
  26 
  27 #include &quot;unicode/utypes.h&quot;
  28 
  29 /**
  30  * \file
  31  * \brief C++ API: Compatibility APIs for number formatting.
  32  */
  33 
  34 #if !UCONFIG_NO_FORMATTING
  35 
  36 #include &quot;unicode/unistr.h&quot;
  37 #include &quot;unicode/format.h&quot;
  38 #include &quot;unicode/unum.h&quot; // UNumberFormatStyle
  39 #include &quot;unicode/locid.h&quot;
  40 #include &quot;unicode/stringpiece.h&quot;
  41 #include &quot;unicode/curramt.h&quot;
  42 #include &quot;unicode/udisplaycontext.h&quot;
  43 
  44 class NumberFormatTest;
  45 
  46 U_NAMESPACE_BEGIN
  47 
  48 class SharedNumberFormat;
  49 
  50 #if !UCONFIG_NO_SERVICE
  51 class NumberFormatFactory;
  52 class StringEnumeration;
  53 #endif
  54 
  55 /**
  56  * &lt;p&gt;&lt;strong&gt;IMPORTANT:&lt;/strong&gt; New users are strongly encouraged to see if
  57  * numberformatter.h fits their use case.  Although not deprecated, this header
  58  * is provided for backwards compatibility only.
<a name="1" id="anc1"></a>
  59  *
  60  * Abstract base class for all number formats.  Provides interface for
  61  * formatting and parsing a number.  Also provides methods for
  62  * determining which locales have number formats, and what their names
  63  * are.
  64  *
  65  * \headerfile unicode/numfmt.h &quot;unicode/numfmt.h&quot;
  66  * &lt;P&gt;
  67  * NumberFormat helps you to format and parse numbers for any locale.
  68  * Your code can be completely independent of the locale conventions
  69  * for decimal points, thousands-separators, or even the particular
  70  * decimal digits used, or whether the number format is even decimal.
  71  * &lt;P&gt;
  72  * To format a number for the current Locale, use one of the static
  73  * factory methods:
  74  * \code
  75  *    #include &lt;iostream&gt;
  76  *    #include &quot;unicode/numfmt.h&quot;
  77  *    #include &quot;unicode/unistr.h&quot;
  78  *    #include &quot;unicode/ustream.h&quot;
  79  *    using namespace std;
  80  *
  81  *    int main() {
  82  *        double myNumber = 7.0;
  83  *        UnicodeString myString;
  84  *        UErrorCode success = U_ZERO_ERROR;
  85  *        NumberFormat* nf = NumberFormat::createInstance(success);
  86  *        nf-&gt;format(myNumber, myString);
  87  *        cout &lt;&lt; &quot; Example 1: &quot; &lt;&lt; myString &lt;&lt; endl;
  88  *    }
  89  * \endcode
  90  * Note that there are additional factory methods within subclasses of
  91  * NumberFormat.
  92  * &lt;P&gt;
  93  * If you are formatting multiple numbers, it is more efficient to get
  94  * the format and use it multiple times so that the system doesn&#39;t
  95  * have to fetch the information about the local language and country
  96  * conventions multiple times.
  97  * \code
  98  *     UnicodeString myString;
  99  *     UErrorCode success = U_ZERO_ERROR;
 100  *     NumberFormat *nf = NumberFormat::createInstance( success );
 101  *     for (int32_t number: {123, 3333, -1234567}) {
 102  *         nf-&gt;format(number, myString);
 103  *         myString += &quot;; &quot;;
 104  *     }
 105  *     cout &lt;&lt; &quot; Example 2: &quot; &lt;&lt; myString &lt;&lt; endl;
 106  * \endcode
 107  * To format a number for a different Locale, specify it in the
 108  * call to \c createInstance().
 109  * \code
 110  *     nf = NumberFormat::createInstance(Locale::getFrench(), success);
 111  * \endcode
 112  * You can use a \c NumberFormat to parse also.
 113  * \code
 114  *    UErrorCode success;
 115  *    Formattable result(-999);  // initialized with error code
 116  *    nf-&gt;parse(myString, result, success);
 117  * \endcode
 118  * Use \c createInstance() to get the normal number format for a \c Locale.
 119  * There are other static factory methods available.  Use \c createCurrencyInstance()
 120  * to get the currency number format for that country.  Use \c createPercentInstance()
 121  * to get a format for displaying percentages. With this format, a
 122  * fraction from 0.53 is displayed as 53%.
 123  * &lt;P&gt;
 124  * The type of number formatting can be specified by passing a &#39;style&#39; parameter to \c createInstance().
 125  * For example, use\n
 126  * \c createInstance(locale, UNUM_DECIMAL, errorCode) to get the normal number format,\n
 127  * \c createInstance(locale, UNUM_PERCENT, errorCode) to get a format for displaying percentage,\n
 128  * \c createInstance(locale, UNUM_SCIENTIFIC, errorCode) to get a format for displaying scientific number,\n
 129  * \c createInstance(locale, UNUM_CURRENCY, errorCode) to get the currency number format,
 130  * in which the currency is represented by its symbol, for example, &quot;$3.00&quot;.\n
 131  * \c createInstance(locale, UNUM_CURRENCY_ISO, errorCode)  to get the currency number format,
 132  * in which the currency is represented by its ISO code, for example &quot;USD3.00&quot;.\n
 133  * \c createInstance(locale, UNUM_CURRENCY_PLURAL, errorCode) to get the currency number format,
 134  * in which the currency is represented by its full name in plural format,
 135  * for example, &quot;3.00 US dollars&quot; or &quot;1.00 US dollar&quot;.
 136  * &lt;P&gt;
 137  * You can also control the display of numbers with such methods as
 138  * \c getMinimumFractionDigits().  If you want even more control over the
 139  * format or parsing, or want to give your users more control, you can
 140  * try dynamic_casting the \c NumberFormat you get from the factory methods to a
 141  * \c DecimalFormat. This will work for the vast majority of
 142  * countries; just remember to test for NULL in case you
 143  * encounter an unusual one.
 144  * &lt;P&gt;
 145  * You can also use forms of the parse and format methods with
 146  * \c ParsePosition and \c FieldPosition to allow you to:
 147  * &lt;ul type=round&gt;
 148  *   &lt;li&gt;(a) progressively parse through pieces of a string.
 149  *   &lt;li&gt;(b) align the decimal point and other areas.
 150  * &lt;/ul&gt;
 151  * For example, you can align numbers in two ways.
 152  * &lt;P&gt;
 153  * If you are using a monospaced font with spacing for alignment, you
 154  * can pass the \c FieldPosition in your format call, with field =
 155  * \c UNUM_INTEGER_FIELD. On output, \c getEndIndex will be set to the offset
 156  * between the last character of the integer and the decimal. Add
 157  * (desiredSpaceCount - getEndIndex) spaces at the front of the
 158  * string.
 159  * &lt;P&gt;
 160  * If you are using proportional fonts, instead of padding with
 161  * spaces, measure the width of the string in pixels from the start to
 162  * getEndIndex.  Then move the pen by (desiredPixelWidth -
 163  * widthToAlignmentPoint) before drawing the text.  It also works
 164  * where there is no decimal, but possibly additional characters at
 165  * the end, e.g. with parentheses in negative numbers: &quot;(12)&quot; for -12.
 166  * &lt;p&gt;
 167  * &lt;em&gt;User subclasses are not supported.&lt;/em&gt; While clients may write
 168  * subclasses, such code will not necessarily work and will not be
 169  * guaranteed to work stably from release to release.
 170  *
 171  * @stable ICU 2.0
 172  */
 173 class U_I18N_API NumberFormat : public Format {
 174 public:
 175     /**
 176      * Rounding mode.
 177      *
 178      * &lt;p&gt;
 179      * For more detail on rounding modes, see:
 180      * http://userguide.icu-project.org/formatparse/numbers/rounding-modes
 181      *
 182      * @stable ICU 2.4
 183      */
 184     enum ERoundingMode {
 185         kRoundCeiling,  /**&lt; Round towards positive infinity */
 186         kRoundFloor,    /**&lt; Round towards negative infinity */
 187         kRoundDown,     /**&lt; Round towards zero */
 188         kRoundUp,       /**&lt; Round away from zero */
 189         kRoundHalfEven, /**&lt; Round towards the nearest integer, or
 190                              towards the nearest even integer if equidistant */
 191         kRoundHalfDown, /**&lt; Round towards the nearest integer, or
 192                              towards zero if equidistant */
 193         kRoundHalfUp,   /**&lt; Round towards the nearest integer, or
 194                              away from zero if equidistant */
 195         /**
 196           *  Return U_FORMAT_INEXACT_ERROR if number does not format exactly.
 197           *  @stable ICU 4.8
 198           */
 199         kRoundUnnecessary
 200     };
 201 
 202     /**
 203      * Alignment Field constants used to construct a FieldPosition object.
 204      * Signifies that the position of the integer part or fraction part of
 205      * a formatted number should be returned.
 206      *
 207      * Note: as of ICU 4.4, the values in this enum have been extended to
 208      * support identification of all number format fields, not just those
 209      * pertaining to alignment.
 210      *
 211      * These constants are provided for backwards compatibility only.
 212      * Please use the C style constants defined in the header file unum.h.
 213      *
 214      * @see FieldPosition
 215      * @stable ICU 2.0
 216      */
 217     enum EAlignmentFields {
 218         /** @stable ICU 2.0 */
 219         kIntegerField = UNUM_INTEGER_FIELD,
 220         /** @stable ICU 2.0 */
 221         kFractionField = UNUM_FRACTION_FIELD,
 222         /** @stable ICU 2.0 */
 223         kDecimalSeparatorField = UNUM_DECIMAL_SEPARATOR_FIELD,
 224         /** @stable ICU 2.0 */
 225         kExponentSymbolField = UNUM_EXPONENT_SYMBOL_FIELD,
 226         /** @stable ICU 2.0 */
 227         kExponentSignField = UNUM_EXPONENT_SIGN_FIELD,
 228         /** @stable ICU 2.0 */
 229         kExponentField = UNUM_EXPONENT_FIELD,
 230         /** @stable ICU 2.0 */
 231         kGroupingSeparatorField = UNUM_GROUPING_SEPARATOR_FIELD,
 232         /** @stable ICU 2.0 */
 233         kCurrencyField = UNUM_CURRENCY_FIELD,
 234         /** @stable ICU 2.0 */
 235         kPercentField = UNUM_PERCENT_FIELD,
 236         /** @stable ICU 2.0 */
 237         kPermillField = UNUM_PERMILL_FIELD,
 238         /** @stable ICU 2.0 */
 239         kSignField = UNUM_SIGN_FIELD,
<a name="2" id="anc2"></a><span class="line-added"> 240 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added"> 241         /** @draft ICU 64 */</span>
<span class="line-added"> 242         kMeasureUnitField = UNUM_MEASURE_UNIT_FIELD,</span>
<span class="line-added"> 243         /** @draft ICU 64 */</span>
<span class="line-added"> 244         kCompactField = UNUM_COMPACT_FIELD,</span>
<span class="line-added"> 245 #endif  // U_HIDE_DRAFT_API</span>
 246 
 247     /**
 248      * These constants are provided for backwards compatibility only.
 249      * Please use the constants defined in the header file unum.h.
 250      */
 251         /** @stable ICU 2.0 */
 252         INTEGER_FIELD        = UNUM_INTEGER_FIELD,
 253         /** @stable ICU 2.0 */
 254         FRACTION_FIELD       = UNUM_FRACTION_FIELD
 255     };
 256 
 257     /**
 258      * Destructor.
 259      * @stable ICU 2.0
 260      */
 261     virtual ~NumberFormat();
 262 
 263     /**
 264      * Return true if the given Format objects are semantically equal.
 265      * Objects of different subclasses are considered unequal.
 266      * @return    true if the given Format objects are semantically equal.
 267      * @stable ICU 2.0
 268      */
 269     virtual UBool operator==(const Format&amp; other) const;
 270 
 271 
 272     using Format::format;
 273 
 274     /**
 275      * Format an object to produce a string.  This method handles
 276      * Formattable objects with numeric types. If the Formattable
 277      * object type is not a numeric type, then it returns a failing
 278      * UErrorCode.
 279      *
 280      * @param obj       The object to format.
 281      * @param appendTo  Output parameter to receive result.
 282      *                  Result is appended to existing contents.
 283      * @param pos       On input: an alignment field, if desired.
 284      *                  On output: the offsets of the alignment field.
 285      * @param status    Output param filled with success/failure status.
 286      * @return          Reference to &#39;appendTo&#39; parameter.
 287      * @stable ICU 2.0
 288      */
 289     virtual UnicodeString&amp; format(const Formattable&amp; obj,
 290                                   UnicodeString&amp; appendTo,
 291                                   FieldPosition&amp; pos,
 292                                   UErrorCode&amp; status) const;
 293 
 294     /**
 295      * Format an object to produce a string.  This method handles
 296      * Formattable objects with numeric types. If the Formattable
 297      * object type is not a numeric type, then it returns a failing
 298      * UErrorCode.
 299      *
 300      * @param obj       The object to format.
 301      * @param appendTo  Output parameter to receive result.
 302      *                  Result is appended to existing contents.
 303      * @param posIter   On return, can be used to iterate over positions
 304      *                  of fields generated by this format call.  Can be
 305      *                  NULL.
 306      * @param status    Output param filled with success/failure status.
 307      * @return          Reference to &#39;appendTo&#39; parameter.
 308      * @stable ICU 4.4
 309      */
 310     virtual UnicodeString&amp; format(const Formattable&amp; obj,
 311                                   UnicodeString&amp; appendTo,
 312                                   FieldPositionIterator* posIter,
 313                                   UErrorCode&amp; status) const;
 314 
 315     /**
 316      * Parse a string to produce an object.  This methods handles
 317      * parsing of numeric strings into Formattable objects with numeric
 318      * types.
 319      * &lt;P&gt;
 320      * Before calling, set parse_pos.index to the offset you want to
 321      * start parsing at in the source. After calling, parse_pos.index
 322      * indicates the position after the successfully parsed text.  If
 323      * an error occurs, parse_pos.index is unchanged.
 324      * &lt;P&gt;
 325      * When parsing, leading whitespace is discarded (with successful
 326      * parse), while trailing whitespace is left as is.
 327      * &lt;P&gt;
 328      * See Format::parseObject() for more.
 329      *
 330      * @param source    The string to be parsed into an object.
 331      * @param result    Formattable to be set to the parse result.
 332      *                  If parse fails, return contents are undefined.
 333      * @param parse_pos The position to start parsing at. Upon return
 334      *                  this param is set to the position after the
 335      *                  last character successfully parsed. If the
 336      *                  source is not parsed successfully, this param
 337      *                  will remain unchanged.
 338      * @return          A newly created Formattable* object, or NULL
 339      *                  on failure.  The caller owns this and should
 340      *                  delete it when done.
 341      * @stable ICU 2.0
 342      */
 343     virtual void parseObject(const UnicodeString&amp; source,
 344                              Formattable&amp; result,
 345                              ParsePosition&amp; parse_pos) const;
 346 
 347     /**
 348      * Format a double number. These methods call the NumberFormat
 349      * pure virtual format() methods with the default FieldPosition.
 350      *
 351      * @param number    The value to be formatted.
 352      * @param appendTo  Output parameter to receive result.
 353      *                  Result is appended to existing contents.
 354      * @return          Reference to &#39;appendTo&#39; parameter.
 355      * @stable ICU 2.0
 356      */
 357     UnicodeString&amp; format(  double number,
 358                             UnicodeString&amp; appendTo) const;
 359 
 360     /**
 361      * Format a long number. These methods call the NumberFormat
 362      * pure virtual format() methods with the default FieldPosition.
 363      *
 364      * @param number    The value to be formatted.
 365      * @param appendTo  Output parameter to receive result.
 366      *                  Result is appended to existing contents.
 367      * @return          Reference to &#39;appendTo&#39; parameter.
 368      * @stable ICU 2.0
 369      */
 370     UnicodeString&amp; format(  int32_t number,
 371                             UnicodeString&amp; appendTo) const;
 372 
 373     /**
 374      * Format an int64 number. These methods call the NumberFormat
 375      * pure virtual format() methods with the default FieldPosition.
 376      *
 377      * @param number    The value to be formatted.
 378      * @param appendTo  Output parameter to receive result.
 379      *                  Result is appended to existing contents.
 380      * @return          Reference to &#39;appendTo&#39; parameter.
 381      * @stable ICU 2.8
 382      */
 383     UnicodeString&amp; format(  int64_t number,
 384                             UnicodeString&amp; appendTo) const;
 385 
 386     /**
 387      * Format a double number. Concrete subclasses must implement
 388      * these pure virtual methods.
 389      *
 390      * @param number    The value to be formatted.
 391      * @param appendTo  Output parameter to receive result.
 392      *                  Result is appended to existing contents.
 393      * @param pos       On input: an alignment field, if desired.
 394      *                  On output: the offsets of the alignment field.
 395      * @return          Reference to &#39;appendTo&#39; parameter.
 396      * @stable ICU 2.0
 397      */
 398     virtual UnicodeString&amp; format(double number,
 399                                   UnicodeString&amp; appendTo,
 400                                   FieldPosition&amp; pos) const = 0;
 401     /**
 402      * Format a double number. By default, the parent function simply
 403      * calls the base class and does not return an error status.
 404      * Therefore, the status may be ignored in some subclasses.
 405      *
 406      * @param number    The value to be formatted.
 407      * @param appendTo  Output parameter to receive result.
 408      *                  Result is appended to existing contents.
 409      * @param pos       On input: an alignment field, if desired.
 410      *                  On output: the offsets of the alignment field.
 411      * @param status    error status
 412      * @return          Reference to &#39;appendTo&#39; parameter.
 413      * @internal
 414      */
 415     virtual UnicodeString&amp; format(double number,
 416                                   UnicodeString&amp; appendTo,
 417                                   FieldPosition&amp; pos,
 418                                   UErrorCode &amp;status) const;
 419     /**
 420      * Format a double number. Subclasses must implement
 421      * this method.
 422      *
 423      * @param number    The value to be formatted.
 424      * @param appendTo  Output parameter to receive result.
 425      *                  Result is appended to existing contents.
 426      * @param posIter   On return, can be used to iterate over positions
 427      *                  of fields generated by this format call.
 428      *                  Can be NULL.
 429      * @param status    Output param filled with success/failure status.
 430      * @return          Reference to &#39;appendTo&#39; parameter.
 431      * @stable ICU 4.4
 432      */
 433     virtual UnicodeString&amp; format(double number,
 434                                   UnicodeString&amp; appendTo,
 435                                   FieldPositionIterator* posIter,
 436                                   UErrorCode&amp; status) const;
 437     /**
 438      * Format a long number. Concrete subclasses must implement
 439      * these pure virtual methods.
 440      *
 441      * @param number    The value to be formatted.
 442      * @param appendTo  Output parameter to receive result.
 443      *                  Result is appended to existing contents.
 444      * @param pos       On input: an alignment field, if desired.
 445      *                  On output: the offsets of the alignment field.
 446      * @return          Reference to &#39;appendTo&#39; parameter.
 447      * @stable ICU 2.0
 448     */
 449     virtual UnicodeString&amp; format(int32_t number,
 450                                   UnicodeString&amp; appendTo,
 451                                   FieldPosition&amp; pos) const = 0;
 452 
 453     /**
 454      * Format a long number. Concrete subclasses may override
 455      * this function to provide status return.
 456      *
 457      * @param number    The value to be formatted.
 458      * @param appendTo  Output parameter to receive result.
 459      *                  Result is appended to existing contents.
 460      * @param pos       On input: an alignment field, if desired.
 461      *                  On output: the offsets of the alignment field.
 462      * @param status the output status.
 463      * @return          Reference to &#39;appendTo&#39; parameter.
 464      * @internal
 465     */
 466     virtual UnicodeString&amp; format(int32_t number,
 467                                   UnicodeString&amp; appendTo,
 468                                   FieldPosition&amp; pos,
 469                                   UErrorCode &amp;status) const;
 470 
 471     /**
 472      * Format an int32 number. Subclasses must implement
 473      * this method.
 474      *
 475      * @param number    The value to be formatted.
 476      * @param appendTo  Output parameter to receive result.
 477      *                  Result is appended to existing contents.
 478      * @param posIter   On return, can be used to iterate over positions
 479      *                  of fields generated by this format call.
 480      *                  Can be NULL.
 481      * @param status    Output param filled with success/failure status.
 482      * @return          Reference to &#39;appendTo&#39; parameter.
 483      * @stable ICU 4.4
 484      */
 485     virtual UnicodeString&amp; format(int32_t number,
 486                                   UnicodeString&amp; appendTo,
 487                                   FieldPositionIterator* posIter,
 488                                   UErrorCode&amp; status) const;
 489     /**
 490      * Format an int64 number. (Not abstract to retain compatibility
 491      * with earlier releases, however subclasses should override this
 492      * method as it just delegates to format(int32_t number...);
 493      *
 494      * @param number    The value to be formatted.
 495      * @param appendTo  Output parameter to receive result.
 496      *                  Result is appended to existing contents.
 497      * @param pos       On input: an alignment field, if desired.
 498      *                  On output: the offsets of the alignment field.
 499      * @return          Reference to &#39;appendTo&#39; parameter.
 500      * @stable ICU 2.8
 501     */
 502     virtual UnicodeString&amp; format(int64_t number,
 503                                   UnicodeString&amp; appendTo,
 504                                   FieldPosition&amp; pos) const;
 505 
 506     /**
 507      * Format an int64 number. (Not abstract to retain compatibility
 508      * with earlier releases, however subclasses should override this
 509      * method as it just delegates to format(int32_t number...);
 510      *
 511      * @param number    The value to be formatted.
 512      * @param appendTo  Output parameter to receive result.
 513      *                  Result is appended to existing contents.
 514      * @param pos       On input: an alignment field, if desired.
 515      *                  On output: the offsets of the alignment field.
 516      * @param status    Output param filled with success/failure status.
 517      * @return          Reference to &#39;appendTo&#39; parameter.
 518      * @internal
 519     */
 520     virtual UnicodeString&amp; format(int64_t number,
 521                                   UnicodeString&amp; appendTo,
 522                                   FieldPosition&amp; pos,
 523                                   UErrorCode&amp; status) const;
 524     /**
 525      * Format an int64 number. Subclasses must implement
 526      * this method.
 527      *
 528      * @param number    The value to be formatted.
 529      * @param appendTo  Output parameter to receive result.
 530      *                  Result is appended to existing contents.
 531      * @param posIter   On return, can be used to iterate over positions
 532      *                  of fields generated by this format call.
 533      *                  Can be NULL.
 534      * @param status    Output param filled with success/failure status.
 535      * @return          Reference to &#39;appendTo&#39; parameter.
 536      * @stable ICU 4.4
 537      */
 538     virtual UnicodeString&amp; format(int64_t number,
 539                                   UnicodeString&amp; appendTo,
 540                                   FieldPositionIterator* posIter,
 541                                   UErrorCode&amp; status) const;
 542 
 543     /**
 544      * Format a decimal number. Subclasses must implement
 545      * this method.  The syntax of the unformatted number is a &quot;numeric string&quot;
 546      * as defined in the Decimal Arithmetic Specification, available at
 547      * http://speleotrove.com/decimal
 548      *
 549      * @param number    The unformatted number, as a string, to be formatted.
 550      * @param appendTo  Output parameter to receive result.
 551      *                  Result is appended to existing contents.
 552      * @param posIter   On return, can be used to iterate over positions
 553      *                  of fields generated by this format call.
 554      *                  Can be NULL.
 555      * @param status    Output param filled with success/failure status.
 556      * @return          Reference to &#39;appendTo&#39; parameter.
 557      * @stable ICU 4.4
 558      */
 559     virtual UnicodeString&amp; format(StringPiece number,
 560                                   UnicodeString&amp; appendTo,
 561                                   FieldPositionIterator* posIter,
 562                                   UErrorCode&amp; status) const;
 563 
 564 // Can&#39;t use #ifndef U_HIDE_INTERNAL_API because these are virtual methods
 565 
 566     /**
 567      * Format a decimal number.
 568      * The number is a DecimalQuantity wrapper onto a floating point decimal number.
 569      * The default implementation in NumberFormat converts the decimal number
 570      * to a double and formats that.  Subclasses of NumberFormat that want
 571      * to specifically handle big decimal numbers must override this method.
 572      * class DecimalFormat does so.
 573      *
 574      * @param number    The number, a DecimalQuantity format Decimal Floating Point.
 575      * @param appendTo  Output parameter to receive result.
 576      *                  Result is appended to existing contents.
 577      * @param posIter   On return, can be used to iterate over positions
 578      *                  of fields generated by this format call.
 579      * @param status    Output param filled with success/failure status.
 580      * @return          Reference to &#39;appendTo&#39; parameter.
 581      * @internal
 582      */
 583     virtual UnicodeString&amp; format(const number::impl::DecimalQuantity &amp;number,
 584                                   UnicodeString&amp; appendTo,
 585                                   FieldPositionIterator* posIter,
 586                                   UErrorCode&amp; status) const;
 587 
 588     /**
 589      * Format a decimal number.
 590      * The number is a DecimalQuantity wrapper onto a floating point decimal number.
 591      * The default implementation in NumberFormat converts the decimal number
 592      * to a double and formats that.  Subclasses of NumberFormat that want
 593      * to specifically handle big decimal numbers must override this method.
 594      * class DecimalFormat does so.
 595      *
 596      * @param number    The number, a DecimalQuantity format Decimal Floating Point.
 597      * @param appendTo  Output parameter to receive result.
 598      *                  Result is appended to existing contents.
 599      * @param pos       On input: an alignment field, if desired.
 600      *                  On output: the offsets of the alignment field.
 601      * @param status    Output param filled with success/failure status.
 602      * @return          Reference to &#39;appendTo&#39; parameter.
 603      * @internal
 604      */
 605     virtual UnicodeString&amp; format(const number::impl::DecimalQuantity &amp;number,
 606                                   UnicodeString&amp; appendTo,
 607                                   FieldPosition&amp; pos,
 608                                   UErrorCode&amp; status) const;
 609 
 610    /**
 611     * Return a long if possible (e.g. within range LONG_MAX,
 612     * LONG_MAX], and with no decimals), otherwise a double.  If
 613     * IntegerOnly is set, will stop at a decimal point (or equivalent;
 614     * e.g. for rational numbers &quot;1 2/3&quot;, will stop after the 1).
 615     * &lt;P&gt;
 616     * If no object can be parsed, index is unchanged, and NULL is
 617     * returned.
 618     * &lt;P&gt;
 619     * This is a pure virtual which concrete subclasses must implement.
 620     *
 621     * @param text           The text to be parsed.
 622     * @param result         Formattable to be set to the parse result.
 623     *                       If parse fails, return contents are undefined.
 624     * @param parsePosition  The position to start parsing at on input.
 625     *                       On output, moved to after the last successfully
 626     *                       parse character. On parse failure, does not change.
 627     * @stable ICU 2.0
 628     */
 629     virtual void parse(const UnicodeString&amp; text,
 630                        Formattable&amp; result,
 631                        ParsePosition&amp; parsePosition) const = 0;
 632 
 633     /**
 634      * Parse a string as a numeric value, and return a Formattable
 635      * numeric object. This method parses integers only if IntegerOnly
 636      * is set.
 637      *
 638      * @param text          The text to be parsed.
 639      * @param result        Formattable to be set to the parse result.
 640      *                      If parse fails, return contents are undefined.
 641      * @param status        Output parameter set to a failure error code
 642      *                      when a failure occurs.
 643      * @see                 NumberFormat::isParseIntegerOnly
 644      * @stable ICU 2.0
 645      */
 646     virtual void parse(const UnicodeString&amp; text,
 647                        Formattable&amp; result,
 648                        UErrorCode&amp; status) const;
 649 
 650     /**
 651      * Parses text from the given string as a currency amount.  Unlike
 652      * the parse() method, this method will attempt to parse a generic
 653      * currency name, searching for a match of this object&#39;s locale&#39;s
 654      * currency display names, or for a 3-letter ISO currency code.
 655      * This method will fail if this format is not a currency format,
 656      * that is, if it does not contain the currency pattern symbol
 657      * (U+00A4) in its prefix or suffix.
 658      *
 659      * @param text the string to parse
 660      * @param pos  input-output position; on input, the position within text
 661      *             to match; must have 0 &lt;= pos.getIndex() &lt; text.length();
 662      *             on output, the position after the last matched character.
 663      *             If the parse fails, the position in unchanged upon output.
 664      * @return     if parse succeeds, a pointer to a newly-created CurrencyAmount
 665      *             object (owned by the caller) containing information about
 666      *             the parsed currency; if parse fails, this is NULL.
 667      * @stable ICU 49
 668      */
 669     virtual CurrencyAmount* parseCurrency(const UnicodeString&amp; text,
 670                                           ParsePosition&amp; pos) const;
 671 
 672     /**
 673      * Return true if this format will parse numbers as integers
 674      * only.  For example in the English locale, with ParseIntegerOnly
 675      * true, the string &quot;1234.&quot; would be parsed as the integer value
 676      * 1234 and parsing would stop at the &quot;.&quot; character.  Of course,
 677      * the exact format accepted by the parse operation is locale
 678      * dependant and determined by sub-classes of NumberFormat.
 679      * @return    true if this format will parse numbers as integers
 680      *            only.
 681      * @stable ICU 2.0
 682      */
 683     UBool isParseIntegerOnly(void) const;
 684 
 685     /**
 686      * Sets whether or not numbers should be parsed as integers only.
 687      * @param value    set True, this format will parse numbers as integers
 688      *                 only.
 689      * @see isParseIntegerOnly
 690      * @stable ICU 2.0
 691      */
 692     virtual void setParseIntegerOnly(UBool value);
 693 
 694     /**
 695      * Sets whether lenient parsing should be enabled (it is off by default).
 696      *
 697      * @param enable \c TRUE if lenient parsing should be used,
 698      *               \c FALSE otherwise.
 699      * @stable ICU 4.8
 700      */
 701     virtual void setLenient(UBool enable);
 702 
 703     /**
 704      * Returns whether lenient parsing is enabled (it is off by default).
 705      *
 706      * @return \c TRUE if lenient parsing is enabled,
 707      *         \c FALSE otherwise.
 708      * @see #setLenient
 709      * @stable ICU 4.8
 710      */
 711     virtual UBool isLenient(void) const;
 712 
 713     /**
 714      * Create a default style NumberFormat for the current default locale.
 715      * The default formatting style is locale dependent.
 716      * &lt;p&gt;
 717      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="3" id="anc3"></a><span class="line-modified"> 718      * {@link icu::number::NumberFormatter} instead of NumberFormat.</span>
 719      * @stable ICU 2.0
 720      */
 721     static NumberFormat* U_EXPORT2 createInstance(UErrorCode&amp;);
 722 
 723     /**
 724      * Create a default style NumberFormat for the specified locale.
 725      * The default formatting style is locale dependent.
 726      * @param inLocale    the given locale.
 727      * &lt;p&gt;
 728      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="4" id="anc4"></a><span class="line-modified"> 729      * {@link icu::number::NumberFormatter} instead of NumberFormat.</span>
 730      * @stable ICU 2.0
 731      */
 732     static NumberFormat* U_EXPORT2 createInstance(const Locale&amp; inLocale,
 733                                         UErrorCode&amp;);
 734 
 735     /**
 736      * Create a specific style NumberFormat for the specified locale.
 737      * &lt;p&gt;
 738      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="5" id="anc5"></a><span class="line-modified"> 739      * {@link icu::number::NumberFormatter} instead of NumberFormat.</span>
 740      * @param desiredLocale    the given locale.
 741      * @param style            the given style.
 742      * @param errorCode        Output param filled with success/failure status.
 743      * @return                 A new NumberFormat instance.
 744      * @stable ICU 4.8
 745      */
 746     static NumberFormat* U_EXPORT2 createInstance(const Locale&amp; desiredLocale,
 747                                                   UNumberFormatStyle style,
 748                                                   UErrorCode&amp; errorCode);
 749 
 750 #ifndef U_HIDE_INTERNAL_API
 751 
 752     /**
 753      * ICU use only.
 754      * Creates NumberFormat instance without using the cache.
 755      * @internal
 756      */
 757     static NumberFormat* internalCreateInstance(
 758             const Locale&amp; desiredLocale,
 759             UNumberFormatStyle style,
 760             UErrorCode&amp; errorCode);
 761 
 762     /**
 763      * ICU use only.
 764      * Returns handle to the shared, cached NumberFormat instance for given
 765      * locale. On success, caller must call removeRef() on returned value
 766      * once it is done with the shared instance.
 767      * @internal
 768      */
 769     static const SharedNumberFormat* U_EXPORT2 createSharedInstance(
 770             const Locale&amp; inLocale, UNumberFormatStyle style, UErrorCode&amp; status);
 771 
 772 #endif  /* U_HIDE_INTERNAL_API */
 773 
 774     /**
 775      * Returns a currency format for the current default locale.
 776      * &lt;p&gt;
 777      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="6" id="anc6"></a><span class="line-modified"> 778      * {@link icu::number::NumberFormatter} instead of NumberFormat.</span>
 779      * @stable ICU 2.0
 780      */
 781     static NumberFormat* U_EXPORT2 createCurrencyInstance(UErrorCode&amp;);
 782 
 783     /**
 784      * Returns a currency format for the specified locale.
 785      * &lt;p&gt;
 786      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="7" id="anc7"></a><span class="line-modified"> 787      * {@link icu::number::NumberFormatter} instead of NumberFormat.</span>
 788      * @param inLocale    the given locale.
 789      * @stable ICU 2.0
 790      */
 791     static NumberFormat* U_EXPORT2 createCurrencyInstance(const Locale&amp; inLocale,
 792                                                 UErrorCode&amp;);
 793 
 794     /**
 795      * Returns a percentage format for the current default locale.
 796      * &lt;p&gt;
 797      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="8" id="anc8"></a><span class="line-modified"> 798      * {@link icu::number::NumberFormatter} instead of NumberFormat.</span>
 799      * @stable ICU 2.0
 800      */
 801     static NumberFormat* U_EXPORT2 createPercentInstance(UErrorCode&amp;);
 802 
 803     /**
 804      * Returns a percentage format for the specified locale.
 805      * &lt;p&gt;
 806      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="9" id="anc9"></a><span class="line-modified"> 807      * {@link icu::number::NumberFormatter} instead of NumberFormat.</span>
 808      * @param inLocale    the given locale.
 809      * @stable ICU 2.0
 810      */
 811     static NumberFormat* U_EXPORT2 createPercentInstance(const Locale&amp; inLocale,
 812                                                UErrorCode&amp;);
 813 
 814     /**
 815      * Returns a scientific format for the current default locale.
 816      * &lt;p&gt;
 817      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="10" id="anc10"></a><span class="line-modified"> 818      * {@link icu::number::NumberFormatter} instead of NumberFormat.</span>
 819      * @stable ICU 2.0
 820      */
 821     static NumberFormat* U_EXPORT2 createScientificInstance(UErrorCode&amp;);
 822 
 823     /**
 824      * Returns a scientific format for the specified locale.
 825      * &lt;p&gt;
 826      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="11" id="anc11"></a><span class="line-modified"> 827      * {@link icu::number::NumberFormatter} instead of NumberFormat.</span>
 828      * @param inLocale    the given locale.
 829      * @stable ICU 2.0
 830      */
 831     static NumberFormat* U_EXPORT2 createScientificInstance(const Locale&amp; inLocale,
 832                                                 UErrorCode&amp;);
 833 
 834     /**
 835      * Get the set of Locales for which NumberFormats are installed.
 836      * @param count    Output param to receive the size of the locales
 837      * @stable ICU 2.0
 838      */
 839     static const Locale* U_EXPORT2 getAvailableLocales(int32_t&amp; count);
 840 
 841 #if !UCONFIG_NO_SERVICE
 842     /**
 843      * Register a new NumberFormatFactory.  The factory will be adopted.
 844      * Because ICU may choose to cache NumberFormat objects internally,
 845      * this must be called at application startup, prior to any calls to
 846      * NumberFormat::createInstance to avoid undefined behavior.
 847      * @param toAdopt the NumberFormatFactory instance to be adopted
 848      * @param status the in/out status code, no special meanings are assigned
 849      * @return a registry key that can be used to unregister this factory
 850      * @stable ICU 2.6
 851      */
 852     static URegistryKey U_EXPORT2 registerFactory(NumberFormatFactory* toAdopt, UErrorCode&amp; status);
 853 
 854     /**
 855      * Unregister a previously-registered NumberFormatFactory using the key returned from the
 856      * register call.  Key becomes invalid after a successful call and should not be used again.
 857      * The NumberFormatFactory corresponding to the key will be deleted.
 858      * Because ICU may choose to cache NumberFormat objects internally,
 859      * this should be called during application shutdown, after all calls to
 860      * NumberFormat::createInstance to avoid undefined behavior.
 861      * @param key the registry key returned by a previous call to registerFactory
 862      * @param status the in/out status code, no special meanings are assigned
 863      * @return TRUE if the factory for the key was successfully unregistered
 864      * @stable ICU 2.6
 865      */
 866     static UBool U_EXPORT2 unregister(URegistryKey key, UErrorCode&amp; status);
 867 
 868     /**
 869      * Return a StringEnumeration over the locales available at the time of the call,
 870      * including registered locales.
 871      * @return a StringEnumeration over the locales available at the time of the call
 872      * @stable ICU 2.6
 873      */
 874     static StringEnumeration* U_EXPORT2 getAvailableLocales(void);
 875 #endif /* UCONFIG_NO_SERVICE */
 876 
 877     /**
 878      * Returns true if grouping is used in this format. For example,
 879      * in the English locale, with grouping on, the number 1234567
 880      * might be formatted as &quot;1,234,567&quot;. The grouping separator as
 881      * well as the size of each group is locale dependent and is
 882      * determined by sub-classes of NumberFormat.
 883      * @see setGroupingUsed
 884      * @stable ICU 2.0
 885      */
 886     UBool isGroupingUsed(void) const;
 887 
 888     /**
 889      * Set whether or not grouping will be used in this format.
 890      * @param newValue    True, grouping will be used in this format.
 891      * @see getGroupingUsed
 892      * @stable ICU 2.0
 893      */
 894     virtual void setGroupingUsed(UBool newValue);
 895 
 896     /**
 897      * Returns the maximum number of digits allowed in the integer portion of a
 898      * number.
 899      * @return     the maximum number of digits allowed in the integer portion of a
 900      *             number.
 901      * @see setMaximumIntegerDigits
 902      * @stable ICU 2.0
 903      */
 904     int32_t getMaximumIntegerDigits(void) const;
 905 
 906     /**
 907      * Sets the maximum number of digits allowed in the integer portion of a
 908      * number. maximumIntegerDigits must be &gt;= minimumIntegerDigits.  If the
 909      * new value for maximumIntegerDigits is less than the current value
 910      * of minimumIntegerDigits, then minimumIntegerDigits will also be set to
 911      * the new value.
 912      *
 913      * @param newValue    the new value for the maximum number of digits
 914      *                    allowed in the integer portion of a number.
 915      * @see getMaximumIntegerDigits
 916      * @stable ICU 2.0
 917      */
 918     virtual void setMaximumIntegerDigits(int32_t newValue);
 919 
 920     /**
 921      * Returns the minimum number of digits allowed in the integer portion of a
 922      * number.
 923      * @return    the minimum number of digits allowed in the integer portion of a
 924      *            number.
 925      * @see setMinimumIntegerDigits
 926      * @stable ICU 2.0
 927      */
 928     int32_t getMinimumIntegerDigits(void) const;
 929 
 930     /**
 931      * Sets the minimum number of digits allowed in the integer portion of a
 932      * number. minimumIntegerDigits must be &amp;lt;= maximumIntegerDigits.  If the
 933      * new value for minimumIntegerDigits exceeds the current value
 934      * of maximumIntegerDigits, then maximumIntegerDigits will also be set to
 935      * the new value.
 936      * @param newValue    the new value to be set.
 937      * @see getMinimumIntegerDigits
 938      * @stable ICU 2.0
 939      */
 940     virtual void setMinimumIntegerDigits(int32_t newValue);
 941 
 942     /**
 943      * Returns the maximum number of digits allowed in the fraction portion of a
 944      * number.
 945      * @return    the maximum number of digits allowed in the fraction portion of a
 946      *            number.
 947      * @see setMaximumFractionDigits
 948      * @stable ICU 2.0
 949      */
 950     int32_t getMaximumFractionDigits(void) const;
 951 
 952     /**
 953      * Sets the maximum number of digits allowed in the fraction portion of a
 954      * number. maximumFractionDigits must be &gt;= minimumFractionDigits.  If the
 955      * new value for maximumFractionDigits is less than the current value
 956      * of minimumFractionDigits, then minimumFractionDigits will also be set to
 957      * the new value.
 958      * @param newValue    the new value to be set.
 959      * @see getMaximumFractionDigits
 960      * @stable ICU 2.0
 961      */
 962     virtual void setMaximumFractionDigits(int32_t newValue);
 963 
 964     /**
 965      * Returns the minimum number of digits allowed in the fraction portion of a
 966      * number.
 967      * @return    the minimum number of digits allowed in the fraction portion of a
 968      *            number.
 969      * @see setMinimumFractionDigits
 970      * @stable ICU 2.0
 971      */
 972     int32_t getMinimumFractionDigits(void) const;
 973 
 974     /**
 975      * Sets the minimum number of digits allowed in the fraction portion of a
 976      * number. minimumFractionDigits must be &amp;lt;= maximumFractionDigits.   If the
 977      * new value for minimumFractionDigits exceeds the current value
 978      * of maximumFractionDigits, then maximumIntegerDigits will also be set to
 979      * the new value
 980      * @param newValue    the new value to be set.
 981      * @see getMinimumFractionDigits
 982      * @stable ICU 2.0
 983      */
 984     virtual void setMinimumFractionDigits(int32_t newValue);
 985 
 986     /**
 987      * Sets the currency used to display currency
 988      * amounts.  This takes effect immediately, if this format is a
 989      * currency format.  If this format is not a currency format, then
 990      * the currency is used if and when this object becomes a
 991      * currency format.
 992      * @param theCurrency a 3-letter ISO code indicating new currency
 993      * to use.  It need not be null-terminated.  May be the empty
 994      * string or NULL to indicate no currency.
 995      * @param ec input-output error code
 996      * @stable ICU 3.0
 997      */
 998     virtual void setCurrency(const char16_t* theCurrency, UErrorCode&amp; ec);
 999 
1000     /**
1001      * Gets the currency used to display currency
1002      * amounts.  This may be an empty string for some subclasses.
1003      * @return a 3-letter null-terminated ISO code indicating
1004      * the currency in use, or a pointer to the empty string.
1005      * @stable ICU 2.6
1006      */
1007     const char16_t* getCurrency() const;
1008 
1009     /**
1010      * Set a particular UDisplayContext value in the formatter, such as
1011      * UDISPCTX_CAPITALIZATION_FOR_STANDALONE.
1012      * @param value The UDisplayContext value to set.
1013      * @param status Input/output status. If at entry this indicates a failure
1014      *               status, the function will do nothing; otherwise this will be
1015      *               updated with any new status from the function.
1016      * @stable ICU 53
1017      */
1018     virtual void setContext(UDisplayContext value, UErrorCode&amp; status);
1019 
1020     /**
1021      * Get the formatter&#39;s UDisplayContext value for the specified UDisplayContextType,
1022      * such as UDISPCTX_TYPE_CAPITALIZATION.
1023      * @param type The UDisplayContextType whose value to return
1024      * @param status Input/output status. If at entry this indicates a failure
1025      *               status, the function will do nothing; otherwise this will be
1026      *               updated with any new status from the function.
1027      * @return The UDisplayContextValue for the specified type.
1028      * @stable ICU 53
1029      */
1030     virtual UDisplayContext getContext(UDisplayContextType type, UErrorCode&amp; status) const;
1031 
1032     /**
1033      * Get the rounding mode. This will always return NumberFormat::ERoundingMode::kRoundUnnecessary
1034      * if the subclass does not support rounding.
1035      * @return A rounding mode
<a name="12" id="anc12"></a><span class="line-modified">1036      * @stable ICU 60</span>
1037      */
1038     virtual ERoundingMode getRoundingMode(void) const;
1039 
1040     /**
1041      * Set the rounding mode. If a subclass does not support rounding, this will do nothing.
1042      * @param roundingMode A rounding mode
<a name="13" id="anc13"></a><span class="line-modified">1043      * @stable ICU 60</span>
1044      */
1045     virtual void setRoundingMode(ERoundingMode roundingMode);
1046 
1047 public:
1048 
1049     /**
1050      * Return the class ID for this class.  This is useful for
1051      * comparing to a return value from getDynamicClassID(). Note that,
1052      * because NumberFormat is an abstract base class, no fully constructed object
1053      * will have the class ID returned by NumberFormat::getStaticClassID().
1054      * @return The class ID for all objects of this class.
1055      * @stable ICU 2.0
1056      */
1057     static UClassID U_EXPORT2 getStaticClassID(void);
1058 
1059     /**
1060      * Returns a unique class ID POLYMORPHICALLY.  Pure virtual override.
1061      * This method is to implement a simple version of RTTI, since not all
1062      * C++ compilers support genuine RTTI.  Polymorphic operator==() and
1063      * clone() methods call this method.
1064      * &lt;P&gt;
1065      * @return The class ID for this object. All objects of a
1066      * given class have the same class ID.  Objects of
1067      * other classes have different class IDs.
1068      * @stable ICU 2.0
1069      */
1070     virtual UClassID getDynamicClassID(void) const = 0;
1071 
1072 protected:
1073 
1074     /**
1075      * Default constructor for subclass use only.
1076      * @stable ICU 2.0
1077      */
1078     NumberFormat();
1079 
1080     /**
1081      * Copy constructor.
1082      * @stable ICU 2.0
1083      */
1084     NumberFormat(const NumberFormat&amp;);
1085 
1086     /**
1087      * Assignment operator.
1088      * @stable ICU 2.0
1089      */
1090     NumberFormat&amp; operator=(const NumberFormat&amp;);
1091 
1092     /**
1093      * Returns the currency in effect for this formatter.  Subclasses
1094      * should override this method as needed.  Unlike getCurrency(),
1095      * this method should never return &quot;&quot;.
1096      * @result output parameter for null-terminated result, which must
1097      * have a capacity of at least 4
1098      * @internal
1099      */
1100     virtual void getEffectiveCurrency(char16_t* result, UErrorCode&amp; ec) const;
1101 
1102 #ifndef U_HIDE_INTERNAL_API
1103     /**
1104      * Creates the specified number format style of the desired locale.
1105      * If mustBeDecimalFormat is TRUE, then the returned pointer is
1106      * either a DecimalFormat or it is NULL.
1107      * @internal
1108      */
1109     static NumberFormat* makeInstance(const Locale&amp; desiredLocale,
1110                                       UNumberFormatStyle style,
1111                                       UBool mustBeDecimalFormat,
1112                                       UErrorCode&amp; errorCode);
1113 #endif  /* U_HIDE_INTERNAL_API */
1114 
1115 private:
1116 
1117     static UBool isStyleSupported(UNumberFormatStyle style);
1118 
1119     /**
1120      * Creates the specified decimal format style of the desired locale.
1121      * @param desiredLocale    the given locale.
1122      * @param style            the given style.
1123      * @param errorCode        Output param filled with success/failure status.
1124      * @return                 A new NumberFormat instance.
1125      */
1126     static NumberFormat* makeInstance(const Locale&amp; desiredLocale,
1127                                       UNumberFormatStyle style,
1128                                       UErrorCode&amp; errorCode);
1129 
1130     UBool       fGroupingUsed;
1131     int32_t     fMaxIntegerDigits;
1132     int32_t     fMinIntegerDigits;
1133     int32_t     fMaxFractionDigits;
1134     int32_t     fMinFractionDigits;
1135 
1136   protected:
1137     /** \internal */
1138     static const int32_t gDefaultMaxIntegerDigits;
1139     /** \internal */
1140     static const int32_t gDefaultMinIntegerDigits;
1141 
1142   private:
1143     UBool      fParseIntegerOnly;
1144     UBool      fLenient; // TRUE =&gt; lenient parse is enabled
1145 
1146     // ISO currency code
1147     char16_t      fCurrency[4];
1148 
1149     UDisplayContext fCapitalizationContext;
1150 
1151     friend class ICUNumberFormatFactory; // access to makeInstance
1152     friend class ICUNumberFormatService;
1153     friend class ::NumberFormatTest;  // access to isStyleSupported()
1154 };
1155 
1156 #if !UCONFIG_NO_SERVICE
1157 /**
1158  * A NumberFormatFactory is used to register new number formats.  The factory
1159  * should be able to create any of the predefined formats for each locale it
1160  * supports.  When registered, the locales it supports extend or override the
1161  * locale already supported by ICU.
1162  *
1163  * @stable ICU 2.6
1164  */
1165 class U_I18N_API NumberFormatFactory : public UObject {
1166 public:
1167 
1168     /**
1169      * Destructor
1170      * @stable ICU 3.0
1171      */
1172     virtual ~NumberFormatFactory();
1173 
1174     /**
1175      * Return true if this factory will be visible.  Default is true.
1176      * If not visible, the locales supported by this factory will not
1177      * be listed by getAvailableLocales.
1178      * @stable ICU 2.6
1179      */
1180     virtual UBool visible(void) const = 0;
1181 
1182     /**
1183      * Return the locale names directly supported by this factory.  The number of names
1184      * is returned in count;
1185      * @stable ICU 2.6
1186      */
1187     virtual const UnicodeString * getSupportedIDs(int32_t &amp;count, UErrorCode&amp; status) const = 0;
1188 
1189     /**
1190      * Return a number format of the appropriate type.  If the locale
1191      * is not supported, return null.  If the locale is supported, but
1192      * the type is not provided by this service, return null.  Otherwise
1193      * return an appropriate instance of NumberFormat.
1194      * @stable ICU 2.6
1195      */
1196     virtual NumberFormat* createFormat(const Locale&amp; loc, UNumberFormatStyle formatType) = 0;
1197 };
1198 
1199 /**
1200  * A NumberFormatFactory that supports a single locale.  It can be visible or invisible.
1201  * @stable ICU 2.6
1202  */
1203 class U_I18N_API SimpleNumberFormatFactory : public NumberFormatFactory {
1204 protected:
1205     /**
1206      * True if the locale supported by this factory is visible.
1207      * @stable ICU 2.6
1208      */
1209     const UBool _visible;
1210 
1211     /**
1212      * The locale supported by this factory, as a UnicodeString.
1213      * @stable ICU 2.6
1214      */
1215     UnicodeString _id;
1216 
1217 public:
1218     /**
1219      * @stable ICU 2.6
1220      */
1221     SimpleNumberFormatFactory(const Locale&amp; locale, UBool visible = TRUE);
1222 
1223     /**
1224      * @stable ICU 3.0
1225      */
1226     virtual ~SimpleNumberFormatFactory();
1227 
1228     /**
1229      * @stable ICU 2.6
1230      */
1231     virtual UBool visible(void) const;
1232 
1233     /**
1234      * @stable ICU 2.6
1235      */
1236     virtual const UnicodeString * getSupportedIDs(int32_t &amp;count, UErrorCode&amp; status) const;
1237 };
1238 #endif /* #if !UCONFIG_NO_SERVICE */
1239 
1240 // -------------------------------------
1241 
1242 inline UBool
1243 NumberFormat::isParseIntegerOnly() const
1244 {
1245     return fParseIntegerOnly;
1246 }
1247 
1248 inline UBool
1249 NumberFormat::isLenient() const
1250 {
1251     return fLenient;
1252 }
1253 
1254 U_NAMESPACE_END
1255 
1256 #endif /* #if !UCONFIG_NO_FORMATTING */
1257 
1258 #endif // _NUMFMT
1259 //eof
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>