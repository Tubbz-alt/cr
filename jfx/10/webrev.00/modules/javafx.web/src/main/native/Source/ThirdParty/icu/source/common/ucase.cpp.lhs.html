<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ucase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 *
   6 *   Copyright (C) 2004-2014, International Business Machines
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 *******************************************************************************
  10 *   file name:  ucase.cpp
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 2004aug30
  16 *   created by: Markus W. Scherer
  17 *
  18 *   Low-level Unicode character/string case mapping code.
  19 *   Much code moved here (and modified) from uchar.c.
  20 */
  21 
  22 #include &quot;unicode/utypes.h&quot;
  23 #include &quot;unicode/unistr.h&quot;
  24 #include &quot;unicode/uset.h&quot;
  25 #include &quot;unicode/udata.h&quot; /* UDataInfo */
  26 #include &quot;unicode/utf16.h&quot;
  27 #include &quot;ucmndata.h&quot; /* DataHeader */
  28 #include &quot;udatamem.h&quot;
  29 #include &quot;umutex.h&quot;
  30 #include &quot;uassert.h&quot;
  31 #include &quot;cmemory.h&quot;
  32 #include &quot;utrie2.h&quot;
  33 #include &quot;ucase.h&quot;
  34 
  35 struct UCaseProps {
  36     UDataMemory *mem;
  37     const int32_t *indexes;
  38     const uint16_t *exceptions;
  39     const uint16_t *unfold;
  40 
  41     UTrie2 trie;
  42     uint8_t formatVersion[4];
  43 };
  44 
  45 /* ucase_props_data.h is machine-generated by gencase --csource */
  46 #define INCLUDED_FROM_UCASE_CPP
  47 #include &quot;ucase_props_data.h&quot;
  48 
  49 /* set of property starts for UnicodeSet ------------------------------------ */
  50 
  51 static UBool U_CALLCONV
  52 _enumPropertyStartsRange(const void *context, UChar32 start, UChar32 /*end*/, uint32_t /*value*/) {
  53     /* add the start code point to the USet */
  54     const USetAdder *sa=(const USetAdder *)context;
  55     sa-&gt;add(sa-&gt;set, start);
  56     return TRUE;
  57 }
  58 
  59 U_CFUNC void U_EXPORT2
  60 ucase_addPropertyStarts(const USetAdder *sa, UErrorCode *pErrorCode) {
  61     if(U_FAILURE(*pErrorCode)) {
  62         return;
  63     }
  64 
  65     /* add the start code point of each same-value range of the trie */
  66     utrie2_enum(&amp;ucase_props_singleton.trie, NULL, _enumPropertyStartsRange, sa);
  67 
  68     /* add code points with hardcoded properties, plus the ones following them */
  69 
  70     /* (none right now, see comment below) */
  71 
  72     /*
  73      * Omit code points with hardcoded specialcasing properties
  74      * because we do not build property UnicodeSets for them right now.
  75      */
  76 }
  77 
  78 /* data access primitives --------------------------------------------------- */
  79 
  80 U_CFUNC const UTrie2 * U_EXPORT2
  81 ucase_getTrie() {
  82     return &amp;ucase_props_singleton.trie;
  83 }
  84 
  85 #define GET_EXCEPTIONS(csp, props) ((csp)-&gt;exceptions+((props)&gt;&gt;UCASE_EXC_SHIFT))
  86 
  87 /* number of bits in an 8-bit integer value */
  88 static const uint8_t flagsOffset[256]={
  89     0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
  90     1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
  91     1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
  92     2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
  93     1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
  94     2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
  95     2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
  96     3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
  97     1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
  98     2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
  99     2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
 100     3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
 101     2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
 102     3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
 103     3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
 104     4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
 105 };
 106 
 107 #define HAS_SLOT(flags, idx) ((flags)&amp;(1&lt;&lt;(idx)))
 108 #define SLOT_OFFSET(flags, idx) flagsOffset[(flags)&amp;((1&lt;&lt;(idx))-1)]
 109 
 110 /*
 111  * Get the value of an optional-value slot where HAS_SLOT(excWord, idx).
 112  *
 113  * @param excWord (in) initial exceptions word
 114  * @param idx (in) desired slot index
 115  * @param pExc16 (in/out) const uint16_t * after excWord=*pExc16++;
 116  *               moved to the last uint16_t of the value, use +1 for beginning of next slot
 117  * @param value (out) int32_t or uint32_t output if hasSlot, otherwise not modified
 118  */
 119 #define GET_SLOT_VALUE(excWord, idx, pExc16, value) \
 120     if(((excWord)&amp;UCASE_EXC_DOUBLE_SLOTS)==0) { \
 121         (pExc16)+=SLOT_OFFSET(excWord, idx); \
 122         (value)=*pExc16; \
 123     } else { \
 124         (pExc16)+=2*SLOT_OFFSET(excWord, idx); \
 125         (value)=*pExc16++; \
 126         (value)=((value)&lt;&lt;16)|*pExc16; \
 127     }
 128 
 129 /* simple case mappings ----------------------------------------------------- */
 130 
 131 U_CAPI UChar32 U_EXPORT2
 132 ucase_tolower(UChar32 c) {
 133     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
 134     if(!UCASE_HAS_EXCEPTION(props)) {
 135         if(UCASE_IS_UPPER_OR_TITLE(props)) {
 136             c+=UCASE_GET_DELTA(props);
 137         }
 138     } else {
 139         const uint16_t *pe=GET_EXCEPTIONS(&amp;ucase_props_singleton, props);
 140         uint16_t excWord=*pe++;
 141         if(HAS_SLOT(excWord, UCASE_EXC_DELTA) &amp;&amp; UCASE_IS_UPPER_OR_TITLE(props)) {
 142             int32_t delta;
 143             GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);
 144             return (excWord&amp;UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta;
 145         }
 146         if(HAS_SLOT(excWord, UCASE_EXC_LOWER)) {
 147             GET_SLOT_VALUE(excWord, UCASE_EXC_LOWER, pe, c);
 148         }
 149     }
 150     return c;
 151 }
 152 
 153 U_CAPI UChar32 U_EXPORT2
 154 ucase_toupper(UChar32 c) {
 155     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
 156     if(!UCASE_HAS_EXCEPTION(props)) {
 157         if(UCASE_GET_TYPE(props)==UCASE_LOWER) {
 158             c+=UCASE_GET_DELTA(props);
 159         }
 160     } else {
 161         const uint16_t *pe=GET_EXCEPTIONS(&amp;ucase_props_singleton, props);
 162         uint16_t excWord=*pe++;
 163         if(HAS_SLOT(excWord, UCASE_EXC_DELTA) &amp;&amp; UCASE_GET_TYPE(props)==UCASE_LOWER) {
 164             int32_t delta;
 165             GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);
 166             return (excWord&amp;UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta;
 167         }
 168         if(HAS_SLOT(excWord, UCASE_EXC_UPPER)) {
 169             GET_SLOT_VALUE(excWord, UCASE_EXC_UPPER, pe, c);
 170         }
 171     }
 172     return c;
 173 }
 174 
 175 U_CAPI UChar32 U_EXPORT2
 176 ucase_totitle(UChar32 c) {
 177     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
 178     if(!UCASE_HAS_EXCEPTION(props)) {
 179         if(UCASE_GET_TYPE(props)==UCASE_LOWER) {
 180             c+=UCASE_GET_DELTA(props);
 181         }
 182     } else {
 183         const uint16_t *pe=GET_EXCEPTIONS(&amp;ucase_props_singleton, props);
 184         uint16_t excWord=*pe++;
 185         if(HAS_SLOT(excWord, UCASE_EXC_DELTA) &amp;&amp; UCASE_GET_TYPE(props)==UCASE_LOWER) {
 186             int32_t delta;
 187             GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);
 188             return (excWord&amp;UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta;
 189         }
 190         int32_t idx;
 191         if(HAS_SLOT(excWord, UCASE_EXC_TITLE)) {
 192             idx=UCASE_EXC_TITLE;
 193         } else if(HAS_SLOT(excWord, UCASE_EXC_UPPER)) {
 194             idx=UCASE_EXC_UPPER;
 195         } else {
 196             return c;
 197         }
 198         GET_SLOT_VALUE(excWord, idx, pe, c);
 199     }
 200     return c;
 201 }
 202 
 203 static const UChar iDot[2] = { 0x69, 0x307 };
 204 static const UChar jDot[2] = { 0x6a, 0x307 };
 205 static const UChar iOgonekDot[3] = { 0x12f, 0x307 };
 206 static const UChar iDotGrave[3] = { 0x69, 0x307, 0x300 };
 207 static const UChar iDotAcute[3] = { 0x69, 0x307, 0x301 };
 208 static const UChar iDotTilde[3] = { 0x69, 0x307, 0x303 };
 209 
 210 
 211 U_CFUNC void U_EXPORT2
 212 ucase_addCaseClosure(UChar32 c, const USetAdder *sa) {
 213     uint16_t props;
 214 
 215     /*
 216      * Hardcode the case closure of i and its relatives and ignore the
 217      * data file data for these characters.
 218      * The Turkic dotless i and dotted I with their case mapping conditions
 219      * and case folding option make the related characters behave specially.
 220      * This code matches their closure behavior to their case folding behavior.
 221      */
 222 
 223     switch(c) {
 224     case 0x49:
 225         /* regular i and I are in one equivalence class */
 226         sa-&gt;add(sa-&gt;set, 0x69);
 227         return;
 228     case 0x69:
 229         sa-&gt;add(sa-&gt;set, 0x49);
 230         return;
 231     case 0x130:
 232         /* dotted I is in a class with &lt;0069 0307&gt; (for canonical equivalence with &lt;0049 0307&gt;) */
 233         sa-&gt;addString(sa-&gt;set, iDot, 2);
 234         return;
 235     case 0x131:
 236         /* dotless i is in a class by itself */
 237         return;
 238     default:
 239         /* otherwise use the data file data */
 240         break;
 241     }
 242 
 243     props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
 244     if(!UCASE_HAS_EXCEPTION(props)) {
 245         if(UCASE_GET_TYPE(props)!=UCASE_NONE) {
 246             /* add the one simple case mapping, no matter what type it is */
 247             int32_t delta=UCASE_GET_DELTA(props);
 248             if(delta!=0) {
 249                 sa-&gt;add(sa-&gt;set, c+delta);
 250             }
 251         }
 252     } else {
 253         /*
 254          * c has exceptions, so there may be multiple simple and/or
 255          * full case mappings. Add them all.
 256          */
 257         const uint16_t *pe0, *pe=GET_EXCEPTIONS(&amp;ucase_props_singleton, props);
 258         const UChar *closure;
 259         uint16_t excWord=*pe++;
 260         int32_t idx, closureLength, fullLength, length;
 261 
 262         pe0=pe;
 263 
 264         /* add all simple case mappings */
 265         for(idx=UCASE_EXC_LOWER; idx&lt;=UCASE_EXC_TITLE; ++idx) {
 266             if(HAS_SLOT(excWord, idx)) {
 267                 pe=pe0;
 268                 GET_SLOT_VALUE(excWord, idx, pe, c);
 269                 sa-&gt;add(sa-&gt;set, c);
 270             }
 271         }
 272         if(HAS_SLOT(excWord, UCASE_EXC_DELTA)) {
<a name="1" id="anc1"></a>
 273             int32_t delta;
 274             GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);
 275             sa-&gt;add(sa-&gt;set, (excWord&amp;UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta);
 276         }
 277 
 278         /* get the closure string pointer &amp; length */
 279         if(HAS_SLOT(excWord, UCASE_EXC_CLOSURE)) {
 280             pe=pe0;
 281             GET_SLOT_VALUE(excWord, UCASE_EXC_CLOSURE, pe, closureLength);
 282             closureLength&amp;=UCASE_CLOSURE_MAX_LENGTH; /* higher bits are reserved */
 283             closure=(const UChar *)pe+1; /* behind this slot, unless there are full case mappings */
 284         } else {
 285             closureLength=0;
 286             closure=NULL;
 287         }
 288 
 289         /* add the full case folding */
 290         if(HAS_SLOT(excWord, UCASE_EXC_FULL_MAPPINGS)) {
 291             pe=pe0;
 292             GET_SLOT_VALUE(excWord, UCASE_EXC_FULL_MAPPINGS, pe, fullLength);
 293 
 294             /* start of full case mapping strings */
 295             ++pe;
 296 
 297             fullLength&amp;=0xffff; /* bits 16 and higher are reserved */
 298 
 299             /* skip the lowercase result string */
 300             pe+=fullLength&amp;UCASE_FULL_LOWER;
 301             fullLength&gt;&gt;=4;
 302 
 303             /* add the full case folding string */
 304             length=fullLength&amp;0xf;
 305             if(length!=0) {
 306                 sa-&gt;addString(sa-&gt;set, (const UChar *)pe, length);
 307                 pe+=length;
 308             }
 309 
 310             /* skip the uppercase and titlecase strings */
 311             fullLength&gt;&gt;=4;
 312             pe+=fullLength&amp;0xf;
 313             fullLength&gt;&gt;=4;
 314             pe+=fullLength;
 315 
 316             closure=(const UChar *)pe; /* behind full case mappings */
 317         }
 318 
 319         /* add each code point in the closure string */
 320         for(idx=0; idx&lt;closureLength;) {
 321             U16_NEXT_UNSAFE(closure, idx, c);
 322             sa-&gt;add(sa-&gt;set, c);
 323         }
 324     }
 325 }
 326 
 327 /*
 328  * compare s, which has a length, with t, which has a maximum length or is NUL-terminated
 329  * must be length&gt;0 and max&gt;0 and length&lt;=max
 330  */
 331 static inline int32_t
 332 strcmpMax(const UChar *s, int32_t length, const UChar *t, int32_t max) {
 333     int32_t c1, c2;
 334 
 335     max-=length; /* we require length&lt;=max, so no need to decrement max in the loop */
 336     do {
 337         c1=*s++;
 338         c2=*t++;
 339         if(c2==0) {
 340             return 1; /* reached the end of t but not of s */
 341         }
 342         c1-=c2;
 343         if(c1!=0) {
 344             return c1; /* return difference result */
 345         }
 346     } while(--length&gt;0);
 347     /* ends with length==0 */
 348 
 349     if(max==0 || *t==0) {
 350         return 0; /* equal to length of both strings */
 351     } else {
 352         return -max; /* return lengh difference */
 353     }
 354 }
 355 
 356 U_CFUNC UBool U_EXPORT2
 357 ucase_addStringCaseClosure(const UChar *s, int32_t length, const USetAdder *sa) {
 358     int32_t i, start, limit, result, unfoldRows, unfoldRowWidth, unfoldStringWidth;
 359 
 360     if(ucase_props_singleton.unfold==NULL || s==NULL) {
 361         return FALSE; /* no reverse case folding data, or no string */
 362     }
 363     if(length&lt;=1) {
 364         /* the string is too short to find any match */
 365         /*
 366          * more precise would be:
 367          * if(!u_strHasMoreChar32Than(s, length, 1))
 368          * but this does not make much practical difference because
 369          * a single supplementary code point would just not be found
 370          */
 371         return FALSE;
 372     }
 373 
 374     const uint16_t *unfold=ucase_props_singleton.unfold;
 375     unfoldRows=unfold[UCASE_UNFOLD_ROWS];
 376     unfoldRowWidth=unfold[UCASE_UNFOLD_ROW_WIDTH];
 377     unfoldStringWidth=unfold[UCASE_UNFOLD_STRING_WIDTH];
 378     unfold+=unfoldRowWidth;
 379 
 380     if(length&gt;unfoldStringWidth) {
 381         /* the string is too long to find any match */
 382         return FALSE;
 383     }
 384 
 385     /* do a binary search for the string */
 386     start=0;
 387     limit=unfoldRows;
 388     while(start&lt;limit) {
 389         i=(start+limit)/2;
 390         const UChar *p=reinterpret_cast&lt;const UChar *&gt;(unfold+(i*unfoldRowWidth));
 391         result=strcmpMax(s, length, p, unfoldStringWidth);
 392 
 393         if(result==0) {
 394             /* found the string: add each code point, and its case closure */
 395             UChar32 c;
 396 
 397             for(i=unfoldStringWidth; i&lt;unfoldRowWidth &amp;&amp; p[i]!=0;) {
 398                 U16_NEXT_UNSAFE(p, i, c);
 399                 sa-&gt;add(sa-&gt;set, c);
 400                 ucase_addCaseClosure(c, sa);
 401             }
 402             return TRUE;
 403         } else if(result&lt;0) {
 404             limit=i;
 405         } else /* result&gt;0 */ {
 406             start=i+1;
 407         }
 408     }
 409 
 410     return FALSE; /* string not found */
 411 }
 412 
 413 U_NAMESPACE_BEGIN
 414 
 415 FullCaseFoldingIterator::FullCaseFoldingIterator()
 416         : unfold(reinterpret_cast&lt;const UChar *&gt;(ucase_props_singleton.unfold)),
 417           unfoldRows(unfold[UCASE_UNFOLD_ROWS]),
 418           unfoldRowWidth(unfold[UCASE_UNFOLD_ROW_WIDTH]),
 419           unfoldStringWidth(unfold[UCASE_UNFOLD_STRING_WIDTH]),
 420           currentRow(0),
 421           rowCpIndex(unfoldStringWidth) {
 422     unfold+=unfoldRowWidth;
 423 }
 424 
 425 UChar32
 426 FullCaseFoldingIterator::next(UnicodeString &amp;full) {
 427     // Advance past the last-delivered code point.
 428     const UChar *p=unfold+(currentRow*unfoldRowWidth);
 429     if(rowCpIndex&gt;=unfoldRowWidth || p[rowCpIndex]==0) {
 430         ++currentRow;
 431         p+=unfoldRowWidth;
 432         rowCpIndex=unfoldStringWidth;
 433     }
 434     if(currentRow&gt;=unfoldRows) { return U_SENTINEL; }
 435     // Set &quot;full&quot; to the NUL-terminated string in the first unfold column.
 436     int32_t length=unfoldStringWidth;
 437     while(length&gt;0 &amp;&amp; p[length-1]==0) { --length; }
 438     full.setTo(FALSE, p, length);
 439     // Return the code point.
 440     UChar32 c;
 441     U16_NEXT_UNSAFE(p, rowCpIndex, c);
 442     return c;
 443 }
 444 
 445 namespace LatinCase {
 446 
 447 const int8_t TO_LOWER_NORMAL[LIMIT] = {
 448     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 449     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 450     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 451     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 452 
 453     0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
 454     32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 0, 0, 0, 0,
 455     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 456     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 457 
 458     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 459     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 460     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 461     0, 0, 0, 0, 0, EXC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 462 
 463     32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
 464     32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, EXC,
 465     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 466     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 467 
 468     1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
 469     1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
 470     1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
 471     EXC, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1,
 472 
 473     0, 1, 0, 1, 0, 1, 0, 1, 0, EXC, 1, 0, 1, 0, 1, 0,
 474     1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
 475     1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
 476     1, 0, 1, 0, 1, 0, 1, 0, -121, 1, 0, 1, 0, 1, 0, EXC
 477 };
 478 
 479 const int8_t TO_LOWER_TR_LT[LIMIT] = {
 480     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 481     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 482     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 483     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 484 
 485     0, 32, 32, 32, 32, 32, 32, 32, 32, EXC, EXC, 32, 32, 32, 32, 32,
 486     32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 0, 0, 0, 0,
 487     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 488     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 489 
 490     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 491     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 492     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 493     0, 0, 0, 0, 0, EXC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 494 
 495     32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, EXC, EXC, 32, 32,
 496     32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, EXC,
 497     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 498     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 499 
 500     1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
 501     1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
 502     1, 0, 1, 0, 1, 0, 1, 0, EXC, 0, 1, 0, 1, 0, EXC, 0,
 503     EXC, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1,
 504 
 505     0, 1, 0, 1, 0, 1, 0, 1, 0, EXC, 1, 0, 1, 0, 1, 0,
 506     1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
 507     1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
 508     1, 0, 1, 0, 1, 0, 1, 0, -121, 1, 0, 1, 0, 1, 0, EXC
 509 };
 510 
 511 const int8_t TO_UPPER_NORMAL[LIMIT] = {
 512     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 513     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 514     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 515     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 516 
 517     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 518     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 519     0, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32,
 520     -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, 0, 0, 0, 0, 0,
 521 
 522     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 523     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 524     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 525     0, 0, 0, 0, 0, EXC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 526 
 527     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 528     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, EXC,
 529     -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32,
 530     -32, -32, -32, -32, -32, -32, -32, 0, -32, -32, -32, -32, -32, -32, -32, 121,
 531 
 532     0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
 533     0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
 534     0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
 535     0, EXC, 0, -1, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1, 0,
 536 
 537     -1, 0, -1, 0, -1, 0, -1, 0, -1, EXC, 0, -1, 0, -1, 0, -1,
 538     0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
 539     0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
 540     0, -1, 0, -1, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1, EXC
 541 };
 542 
 543 const int8_t TO_UPPER_TR[LIMIT] = {
 544     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 545     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 546     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 547     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 548 
 549     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 550     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 551     0, -32, -32, -32, -32, -32, -32, -32, -32, EXC, -32, -32, -32, -32, -32, -32,
 552     -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, 0, 0, 0, 0, 0,
 553 
 554     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 555     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 556     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 557     0, 0, 0, 0, 0, EXC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 558 
 559     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 560     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, EXC,
 561     -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32,
 562     -32, -32, -32, -32, -32, -32, -32, 0, -32, -32, -32, -32, -32, -32, -32, 121,
 563 
 564     0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
 565     0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
 566     0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
 567     0, EXC, 0, -1, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1, 0,
 568 
 569     -1, 0, -1, 0, -1, 0, -1, 0, -1, EXC, 0, -1, 0, -1, 0, -1,
 570     0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
 571     0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
 572     0, -1, 0, -1, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1, EXC
 573 };
 574 
 575 }  // namespace LatinCase
 576 
 577 U_NAMESPACE_END
 578 
 579 /** @return UCASE_NONE, UCASE_LOWER, UCASE_UPPER, UCASE_TITLE */
 580 U_CAPI int32_t U_EXPORT2
 581 ucase_getType(UChar32 c) {
 582     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
 583     return UCASE_GET_TYPE(props);
 584 }
 585 
 586 /** @return same as ucase_getType() and set bit 2 if c is case-ignorable */
 587 U_CAPI int32_t U_EXPORT2
 588 ucase_getTypeOrIgnorable(UChar32 c) {
 589     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
 590     return UCASE_GET_TYPE_AND_IGNORABLE(props);
 591 }
 592 
 593 /** @return UCASE_NO_DOT, UCASE_SOFT_DOTTED, UCASE_ABOVE, UCASE_OTHER_ACCENT */
 594 static inline int32_t
 595 getDotType(UChar32 c) {
 596     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
 597     if(!UCASE_HAS_EXCEPTION(props)) {
 598         return props&amp;UCASE_DOT_MASK;
 599     } else {
 600         const uint16_t *pe=GET_EXCEPTIONS(&amp;ucase_props_singleton, props);
 601         return (*pe&gt;&gt;UCASE_EXC_DOT_SHIFT)&amp;UCASE_DOT_MASK;
 602     }
 603 }
 604 
 605 U_CAPI UBool U_EXPORT2
 606 ucase_isSoftDotted(UChar32 c) {
 607     return (UBool)(getDotType(c)==UCASE_SOFT_DOTTED);
 608 }
 609 
 610 U_CAPI UBool U_EXPORT2
 611 ucase_isCaseSensitive(UChar32 c) {
 612     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
 613     if(!UCASE_HAS_EXCEPTION(props)) {
 614         return (UBool)((props&amp;UCASE_SENSITIVE)!=0);
 615     } else {
 616         const uint16_t *pe=GET_EXCEPTIONS(&amp;ucase_props_singleton, props);
 617         return (UBool)((*pe&amp;UCASE_EXC_SENSITIVE)!=0);
 618     }
 619 }
 620 
 621 /* string casing ------------------------------------------------------------ */
 622 
 623 /*
 624  * These internal functions form the core of string case mappings.
 625  * They map single code points to result code points or strings and take
 626  * all necessary conditions (context, locale ID, options) into account.
 627  *
 628  * They do not iterate over the source or write to the destination
 629  * so that the same functions are useful for non-standard string storage,
 630  * such as in a Replaceable (for Transliterator) or UTF-8/32 strings etc.
 631  * For the same reason, the &quot;surrounding text&quot; context is passed in as a
 632  * UCaseContextIterator which does not make any assumptions about
 633  * the underlying storage.
 634  *
 635  * This section contains helper functions that check for conditions
 636  * in the input text surrounding the current code point
 637  * according to SpecialCasing.txt.
 638  *
 639  * Each helper function gets the index
 640  * - after the current code point if it looks at following text
 641  * - before the current code point if it looks at preceding text
 642  *
 643  * Unicode 3.2 UAX 21 &quot;Case Mappings&quot; defines the conditions as follows:
 644  *
 645  * Final_Sigma
 646  *   C is preceded by a sequence consisting of
 647  *     a cased letter and a case-ignorable sequence,
 648  *   and C is not followed by a sequence consisting of
 649  *     an ignorable sequence and then a cased letter.
 650  *
 651  * More_Above
 652  *   C is followed by one or more characters of combining class 230 (ABOVE)
 653  *   in the combining character sequence.
 654  *
 655  * After_Soft_Dotted
 656  *   The last preceding character with combining class of zero before C
 657  *   was Soft_Dotted,
 658  *   and there is no intervening combining character class 230 (ABOVE).
 659  *
 660  * Before_Dot
 661  *   C is followed by combining dot above (U+0307).
 662  *   Any sequence of characters with a combining class that is neither 0 nor 230
 663  *   may intervene between the current character and the combining dot above.
 664  *
 665  * The erratum from 2002-10-31 adds the condition
 666  *
 667  * After_I
 668  *   The last preceding base character was an uppercase I, and there is no
 669  *   intervening combining character class 230 (ABOVE).
 670  *
 671  *   (See Jitterbug 2344 and the comments on After_I below.)
 672  *
 673  * Helper definitions in Unicode 3.2 UAX 21:
 674  *
 675  * D1. A character C is defined to be cased
 676  *     if it meets any of the following criteria:
 677  *
 678  *   - The general category of C is Titlecase Letter (Lt)
 679  *   - In [CoreProps], C has one of the properties Uppercase, or Lowercase
 680  *   - Given D = NFD(C), then it is not the case that:
 681  *     D = UCD_lower(D) = UCD_upper(D) = UCD_title(D)
 682  *     (This third criterium does not add any characters to the list
 683  *      for Unicode 3.2. Ignored.)
 684  *
 685  * D2. A character C is defined to be case-ignorable
 686  *     if it meets either of the following criteria:
 687  *
 688  *   - The general category of C is
 689  *     Nonspacing Mark (Mn), or Enclosing Mark (Me), or Format Control (Cf), or
 690  *     Letter Modifier (Lm), or Symbol Modifier (Sk)
 691  *   - C is one of the following characters
 692  *     U+0027 APOSTROPHE
 693  *     U+00AD SOFT HYPHEN (SHY)
 694  *     U+2019 RIGHT SINGLE QUOTATION MARK
 695  *            (the preferred character for apostrophe)
 696  *
 697  * D3. A case-ignorable sequence is a sequence of
 698  *     zero or more case-ignorable characters.
 699  */
 700 
 701 #define is_d(c) ((c)==&#39;d&#39; || (c)==&#39;D&#39;)
 702 #define is_e(c) ((c)==&#39;e&#39; || (c)==&#39;E&#39;)
 703 #define is_i(c) ((c)==&#39;i&#39; || (c)==&#39;I&#39;)
 704 #define is_l(c) ((c)==&#39;l&#39; || (c)==&#39;L&#39;)
 705 #define is_r(c) ((c)==&#39;r&#39; || (c)==&#39;R&#39;)
 706 #define is_t(c) ((c)==&#39;t&#39; || (c)==&#39;T&#39;)
 707 #define is_u(c) ((c)==&#39;u&#39; || (c)==&#39;U&#39;)
 708 #define is_z(c) ((c)==&#39;z&#39; || (c)==&#39;Z&#39;)
 709 
 710 /* separator? */
 711 #define is_sep(c) ((c)==&#39;_&#39; || (c)==&#39;-&#39; || (c)==0)
 712 
 713 /**
 714  * Requires non-NULL locale ID but otherwise does the equivalent of
 715  * checking for language codes as if uloc_getLanguage() were called:
 716  * Accepts both 2- and 3-letter codes and accepts case variants.
 717  */
 718 U_CFUNC int32_t
 719 ucase_getCaseLocale(const char *locale) {
 720     /*
 721      * This function used to use uloc_getLanguage(), but the current code
 722      * removes the dependency of this low-level code on uloc implementation code
 723      * and is faster because not the whole locale ID has to be
 724      * examined and copied/transformed.
 725      *
 726      * Because this code does not want to depend on uloc, the caller must
 727      * pass in a non-NULL locale, i.e., may need to call uloc_getDefault().
 728      */
 729     char c=*locale++;
 730     // Fastpath for English &quot;en&quot; which is often used for default (=root locale) case mappings,
 731     // and for Chinese &quot;zh&quot;: Very common but no special case mapping behavior.
 732     // Then check lowercase vs. uppercase to reduce the number of comparisons
 733     // for other locales without special behavior.
 734     if(c==&#39;e&#39;) {
 735         /* el or ell? */
 736         c=*locale++;
 737         if(is_l(c)) {
 738             c=*locale++;
 739             if(is_l(c)) {
 740                 c=*locale;
 741             }
 742             if(is_sep(c)) {
 743                 return UCASE_LOC_GREEK;
 744             }
 745         }
 746         // en, es, ... -&gt; root
 747     } else if(c==&#39;z&#39;) {
 748         return UCASE_LOC_ROOT;
 749 #if U_CHARSET_FAMILY==U_ASCII_FAMILY
 750     } else if(c&gt;=&#39;a&#39;) {  // ASCII a-z = 0x61..0x7a, after A-Z
 751 #elif U_CHARSET_FAMILY==U_EBCDIC_FAMILY
 752     } else if(c&lt;=&#39;z&#39;) {  // EBCDIC a-z = 0x81..0xa9 with two gaps, before A-Z
 753 #else
 754 #   error Unknown charset family!
 755 #endif
 756         // lowercase c
 757         if(c==&#39;t&#39;) {
 758             /* tr or tur? */
 759             c=*locale++;
 760             if(is_u(c)) {
 761                 c=*locale++;
 762             }
 763             if(is_r(c)) {
 764                 c=*locale;
 765                 if(is_sep(c)) {
 766                     return UCASE_LOC_TURKISH;
 767                 }
 768             }
 769         } else if(c==&#39;a&#39;) {
 770             /* az or aze? */
 771             c=*locale++;
 772             if(is_z(c)) {
 773                 c=*locale++;
 774                 if(is_e(c)) {
 775                     c=*locale;
 776                 }
 777                 if(is_sep(c)) {
 778                     return UCASE_LOC_TURKISH;
 779                 }
 780             }
 781         } else if(c==&#39;l&#39;) {
 782             /* lt or lit? */
 783             c=*locale++;
 784             if(is_i(c)) {
 785                 c=*locale++;
 786             }
 787             if(is_t(c)) {
 788                 c=*locale;
 789                 if(is_sep(c)) {
 790                     return UCASE_LOC_LITHUANIAN;
 791                 }
 792             }
 793         } else if(c==&#39;n&#39;) {
 794             /* nl or nld? */
 795             c=*locale++;
 796             if(is_l(c)) {
 797                 c=*locale++;
 798                 if(is_d(c)) {
 799                     c=*locale;
 800                 }
 801                 if(is_sep(c)) {
 802                     return UCASE_LOC_DUTCH;
 803                 }
 804             }
 805         }
 806     } else {
 807         // uppercase c
 808         // Same code as for lowercase c but also check for &#39;E&#39;.
 809         if(c==&#39;T&#39;) {
 810             /* tr or tur? */
 811             c=*locale++;
 812             if(is_u(c)) {
 813                 c=*locale++;
 814             }
 815             if(is_r(c)) {
 816                 c=*locale;
 817                 if(is_sep(c)) {
 818                     return UCASE_LOC_TURKISH;
 819                 }
 820             }
 821         } else if(c==&#39;A&#39;) {
 822             /* az or aze? */
 823             c=*locale++;
 824             if(is_z(c)) {
 825                 c=*locale++;
 826                 if(is_e(c)) {
 827                     c=*locale;
 828                 }
 829                 if(is_sep(c)) {
 830                     return UCASE_LOC_TURKISH;
 831                 }
 832             }
 833         } else if(c==&#39;L&#39;) {
 834             /* lt or lit? */
 835             c=*locale++;
 836             if(is_i(c)) {
 837                 c=*locale++;
 838             }
 839             if(is_t(c)) {
 840                 c=*locale;
 841                 if(is_sep(c)) {
 842                     return UCASE_LOC_LITHUANIAN;
 843                 }
 844             }
 845         } else if(c==&#39;E&#39;) {
 846             /* el or ell? */
 847             c=*locale++;
 848             if(is_l(c)) {
 849                 c=*locale++;
 850                 if(is_l(c)) {
 851                     c=*locale;
 852                 }
 853                 if(is_sep(c)) {
 854                     return UCASE_LOC_GREEK;
 855                 }
 856             }
 857         } else if(c==&#39;N&#39;) {
 858             /* nl or nld? */
 859             c=*locale++;
 860             if(is_l(c)) {
 861                 c=*locale++;
 862                 if(is_d(c)) {
 863                     c=*locale;
 864                 }
 865                 if(is_sep(c)) {
 866                     return UCASE_LOC_DUTCH;
 867                 }
 868             }
 869         }
 870     }
 871     return UCASE_LOC_ROOT;
 872 }
 873 
 874 /*
 875  * Is followed by
 876  *   {case-ignorable}* cased
 877  * ?
 878  * (dir determines looking forward/backward)
 879  * If a character is case-ignorable, it is skipped regardless of whether
 880  * it is also cased or not.
 881  */
 882 static UBool
 883 isFollowedByCasedLetter(UCaseContextIterator *iter, void *context, int8_t dir) {
 884     UChar32 c;
 885 
 886     if(iter==NULL) {
 887         return FALSE;
 888     }
 889 
 890     for(/* dir!=0 sets direction */; (c=iter(context, dir))&gt;=0; dir=0) {
 891         int32_t type=ucase_getTypeOrIgnorable(c);
 892         if(type&amp;4) {
 893             /* case-ignorable, continue with the loop */
 894         } else if(type!=UCASE_NONE) {
 895             return TRUE; /* followed by cased letter */
 896         } else {
 897             return FALSE; /* uncased and not case-ignorable */
 898         }
 899     }
 900 
 901     return FALSE; /* not followed by cased letter */
 902 }
 903 
 904 /* Is preceded by Soft_Dotted character with no intervening cc=230 ? */
 905 static UBool
 906 isPrecededBySoftDotted(UCaseContextIterator *iter, void *context) {
 907     UChar32 c;
 908     int32_t dotType;
 909     int8_t dir;
 910 
 911     if(iter==NULL) {
 912         return FALSE;
 913     }
 914 
 915     for(dir=-1; (c=iter(context, dir))&gt;=0; dir=0) {
 916         dotType=getDotType(c);
 917         if(dotType==UCASE_SOFT_DOTTED) {
 918             return TRUE; /* preceded by TYPE_i */
 919         } else if(dotType!=UCASE_OTHER_ACCENT) {
 920             return FALSE; /* preceded by different base character (not TYPE_i), or intervening cc==230 */
 921         }
 922     }
 923 
 924     return FALSE; /* not preceded by TYPE_i */
 925 }
 926 
 927 /*
 928  * See Jitterbug 2344:
 929  * The condition After_I for Turkic-lowercasing of U+0307 combining dot above
 930  * is checked in ICU 2.0, 2.1, 2.6 but was not in 2.2 &amp; 2.4 because
 931  * we made those releases compatible with Unicode 3.2 which had not fixed
 932  * a related bug in SpecialCasing.txt.
 933  *
 934  * From the Jitterbug 2344 text:
 935  * ... this bug is listed as a Unicode erratum
 936  * from 2002-10-31 at http://www.unicode.org/uni2errata/UnicodeErrata.html
 937  * &lt;quote&gt;
 938  * There are two errors in SpecialCasing.txt.
 939  * 1. Missing semicolons on two lines. ... [irrelevant for ICU]
 940  * 2. An incorrect context definition. Correct as follows:
 941  * &lt; 0307; ; 0307; 0307; tr After_Soft_Dotted; # COMBINING DOT ABOVE
 942  * &lt; 0307; ; 0307; 0307; az After_Soft_Dotted; # COMBINING DOT ABOVE
 943  * ---
 944  * &gt; 0307; ; 0307; 0307; tr After_I; # COMBINING DOT ABOVE
 945  * &gt; 0307; ; 0307; 0307; az After_I; # COMBINING DOT ABOVE
 946  * where the context After_I is defined as:
 947  * The last preceding base character was an uppercase I, and there is no
 948  * intervening combining character class 230 (ABOVE).
 949  * &lt;/quote&gt;
 950  *
 951  * Note that SpecialCasing.txt even in Unicode 3.2 described the condition as:
 952  *
 953  * # When lowercasing, remove dot_above in the sequence I + dot_above, which will turn into i.
 954  * # This matches the behavior of the canonically equivalent I-dot_above
 955  *
 956  * See also the description in this place in older versions of uchar.c (revision 1.100).
 957  *
 958  * Markus W. Scherer 2003-feb-15
 959  */
 960 
 961 /* Is preceded by base character &#39;I&#39; with no intervening cc=230 ? */
 962 static UBool
 963 isPrecededBy_I(UCaseContextIterator *iter, void *context) {
 964     UChar32 c;
 965     int32_t dotType;
 966     int8_t dir;
 967 
 968     if(iter==NULL) {
 969         return FALSE;
 970     }
 971 
 972     for(dir=-1; (c=iter(context, dir))&gt;=0; dir=0) {
 973         if(c==0x49) {
 974             return TRUE; /* preceded by I */
 975         }
 976         dotType=getDotType(c);
 977         if(dotType!=UCASE_OTHER_ACCENT) {
 978             return FALSE; /* preceded by different base character (not I), or intervening cc==230 */
 979         }
 980     }
 981 
 982     return FALSE; /* not preceded by I */
 983 }
 984 
 985 /* Is followed by one or more cc==230 ? */
 986 static UBool
 987 isFollowedByMoreAbove(UCaseContextIterator *iter, void *context) {
 988     UChar32 c;
 989     int32_t dotType;
 990     int8_t dir;
 991 
 992     if(iter==NULL) {
 993         return FALSE;
 994     }
 995 
 996     for(dir=1; (c=iter(context, dir))&gt;=0; dir=0) {
 997         dotType=getDotType(c);
 998         if(dotType==UCASE_ABOVE) {
 999             return TRUE; /* at least one cc==230 following */
1000         } else if(dotType!=UCASE_OTHER_ACCENT) {
1001             return FALSE; /* next base character, no more cc==230 following */
1002         }
1003     }
1004 
1005     return FALSE; /* no more cc==230 following */
1006 }
1007 
1008 /* Is followed by a dot above (without cc==230 in between) ? */
1009 static UBool
1010 isFollowedByDotAbove(UCaseContextIterator *iter, void *context) {
1011     UChar32 c;
1012     int32_t dotType;
1013     int8_t dir;
1014 
1015     if(iter==NULL) {
1016         return FALSE;
1017     }
1018 
1019     for(dir=1; (c=iter(context, dir))&gt;=0; dir=0) {
1020         if(c==0x307) {
1021             return TRUE;
1022         }
1023         dotType=getDotType(c);
1024         if(dotType!=UCASE_OTHER_ACCENT) {
1025             return FALSE; /* next base character or cc==230 in between */
1026         }
1027     }
1028 
1029     return FALSE; /* no dot above following */
1030 }
1031 
1032 U_CAPI int32_t U_EXPORT2
1033 ucase_toFullLower(UChar32 c,
1034                   UCaseContextIterator *iter, void *context,
1035                   const UChar **pString,
1036                   int32_t loc) {
1037     // The sign of the result has meaning, input must be non-negative so that it can be returned as is.
1038     U_ASSERT(c &gt;= 0);
1039     UChar32 result=c;
1040     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
1041     if(!UCASE_HAS_EXCEPTION(props)) {
1042         if(UCASE_IS_UPPER_OR_TITLE(props)) {
1043             result=c+UCASE_GET_DELTA(props);
1044         }
1045     } else {
1046         const uint16_t *pe=GET_EXCEPTIONS(&amp;ucase_props_singleton, props), *pe2;
1047         uint16_t excWord=*pe++;
1048         int32_t full;
1049 
1050         pe2=pe;
1051 
1052         if(excWord&amp;UCASE_EXC_CONDITIONAL_SPECIAL) {
1053             /* use hardcoded conditions and mappings */
1054 
1055             /*
1056              * Test for conditional mappings first
1057              *   (otherwise the unconditional default mappings are always taken),
1058              * then test for characters that have unconditional mappings in SpecialCasing.txt,
1059              * then get the UnicodeData.txt mappings.
1060              */
1061             if( loc==UCASE_LOC_LITHUANIAN &amp;&amp;
1062                     /* base characters, find accents above */
1063                     (((c==0x49 || c==0x4a || c==0x12e) &amp;&amp;
1064                         isFollowedByMoreAbove(iter, context)) ||
1065                     /* precomposed with accent above, no need to find one */
1066                     (c==0xcc || c==0xcd || c==0x128))
1067             ) {
1068                 /*
1069                     # Lithuanian
1070 
1071                     # Lithuanian retains the dot in a lowercase i when followed by accents.
1072 
1073                     # Introduce an explicit dot above when lowercasing capital I&#39;s and J&#39;s
1074                     # whenever there are more accents above.
1075                     # (of the accents used in Lithuanian: grave, acute, tilde above, and ogonek)
1076 
1077                     0049; 0069 0307; 0049; 0049; lt More_Above; # LATIN CAPITAL LETTER I
1078                     004A; 006A 0307; 004A; 004A; lt More_Above; # LATIN CAPITAL LETTER J
1079                     012E; 012F 0307; 012E; 012E; lt More_Above; # LATIN CAPITAL LETTER I WITH OGONEK
1080                     00CC; 0069 0307 0300; 00CC; 00CC; lt; # LATIN CAPITAL LETTER I WITH GRAVE
1081                     00CD; 0069 0307 0301; 00CD; 00CD; lt; # LATIN CAPITAL LETTER I WITH ACUTE
1082                     0128; 0069 0307 0303; 0128; 0128; lt; # LATIN CAPITAL LETTER I WITH TILDE
1083                  */
1084                 switch(c) {
1085                 case 0x49:  /* LATIN CAPITAL LETTER I */
1086                     *pString=iDot;
1087                     return 2;
1088                 case 0x4a:  /* LATIN CAPITAL LETTER J */
1089                     *pString=jDot;
1090                     return 2;
1091                 case 0x12e: /* LATIN CAPITAL LETTER I WITH OGONEK */
1092                     *pString=iOgonekDot;
1093                     return 2;
1094                 case 0xcc:  /* LATIN CAPITAL LETTER I WITH GRAVE */
1095                     *pString=iDotGrave;
1096                     return 3;
1097                 case 0xcd:  /* LATIN CAPITAL LETTER I WITH ACUTE */
1098                     *pString=iDotAcute;
1099                     return 3;
1100                 case 0x128: /* LATIN CAPITAL LETTER I WITH TILDE */
1101                     *pString=iDotTilde;
1102                     return 3;
1103                 default:
1104                     return 0; /* will not occur */
1105                 }
1106             /* # Turkish and Azeri */
1107             } else if(loc==UCASE_LOC_TURKISH &amp;&amp; c==0x130) {
1108                 /*
1109                     # I and i-dotless; I-dot and i are case pairs in Turkish and Azeri
1110                     # The following rules handle those cases.
1111 
1112                     0130; 0069; 0130; 0130; tr # LATIN CAPITAL LETTER I WITH DOT ABOVE
1113                     0130; 0069; 0130; 0130; az # LATIN CAPITAL LETTER I WITH DOT ABOVE
1114                  */
1115                 return 0x69;
1116             } else if(loc==UCASE_LOC_TURKISH &amp;&amp; c==0x307 &amp;&amp; isPrecededBy_I(iter, context)) {
1117                 /*
1118                     # When lowercasing, remove dot_above in the sequence I + dot_above, which will turn into i.
1119                     # This matches the behavior of the canonically equivalent I-dot_above
1120 
1121                     0307; ; 0307; 0307; tr After_I; # COMBINING DOT ABOVE
1122                     0307; ; 0307; 0307; az After_I; # COMBINING DOT ABOVE
1123                  */
1124                 *pString=nullptr;
1125                 return 0; /* remove the dot (continue without output) */
1126             } else if(loc==UCASE_LOC_TURKISH &amp;&amp; c==0x49 &amp;&amp; !isFollowedByDotAbove(iter, context)) {
1127                 /*
1128                     # When lowercasing, unless an I is before a dot_above, it turns into a dotless i.
1129 
1130                     0049; 0131; 0049; 0049; tr Not_Before_Dot; # LATIN CAPITAL LETTER I
1131                     0049; 0131; 0049; 0049; az Not_Before_Dot; # LATIN CAPITAL LETTER I
1132                  */
1133                 return 0x131;
1134             } else if(c==0x130) {
1135                 /*
1136                     # Preserve canonical equivalence for I with dot. Turkic is handled below.
1137 
1138                     0130; 0069 0307; 0130; 0130; # LATIN CAPITAL LETTER I WITH DOT ABOVE
1139                  */
1140                 *pString=iDot;
1141                 return 2;
1142             } else if(  c==0x3a3 &amp;&amp;
1143                         !isFollowedByCasedLetter(iter, context, 1) &amp;&amp;
1144                         isFollowedByCasedLetter(iter, context, -1) /* -1=preceded */
1145             ) {
1146                 /* greek capital sigma maps depending on surrounding cased letters (see SpecialCasing.txt) */
1147                 /*
1148                     # Special case for final form of sigma
1149 
1150                     03A3; 03C2; 03A3; 03A3; Final_Sigma; # GREEK CAPITAL LETTER SIGMA
1151                  */
1152                 return 0x3c2; /* greek small final sigma */
1153             } else {
1154                 /* no known conditional special case mapping, use a normal mapping */
1155             }
1156         } else if(HAS_SLOT(excWord, UCASE_EXC_FULL_MAPPINGS)) {
1157             GET_SLOT_VALUE(excWord, UCASE_EXC_FULL_MAPPINGS, pe, full);
1158             full&amp;=UCASE_FULL_LOWER;
1159             if(full!=0) {
1160                 /* set the output pointer to the lowercase mapping */
1161                 *pString=reinterpret_cast&lt;const UChar *&gt;(pe+1);
1162 
1163                 /* return the string length */
1164                 return full;
1165             }
1166         }
1167 
1168         if(HAS_SLOT(excWord, UCASE_EXC_DELTA) &amp;&amp; UCASE_IS_UPPER_OR_TITLE(props)) {
1169             int32_t delta;
<a name="2" id="anc2"></a><span class="line-modified">1170             GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);</span>
1171             return (excWord&amp;UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta;
1172         }
1173         if(HAS_SLOT(excWord, UCASE_EXC_LOWER)) {
1174             GET_SLOT_VALUE(excWord, UCASE_EXC_LOWER, pe2, result);
1175         }
1176     }
1177 
1178     return (result==c) ? ~result : result;
1179 }
1180 
1181 /* internal */
1182 static int32_t
1183 toUpperOrTitle(UChar32 c,
1184                UCaseContextIterator *iter, void *context,
1185                const UChar **pString,
1186                int32_t loc,
1187                UBool upperNotTitle) {
1188     // The sign of the result has meaning, input must be non-negative so that it can be returned as is.
1189     U_ASSERT(c &gt;= 0);
1190     UChar32 result=c;
1191     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
1192     if(!UCASE_HAS_EXCEPTION(props)) {
1193         if(UCASE_GET_TYPE(props)==UCASE_LOWER) {
1194             result=c+UCASE_GET_DELTA(props);
1195         }
1196     } else {
1197         const uint16_t *pe=GET_EXCEPTIONS(&amp;ucase_props_singleton, props), *pe2;
1198         uint16_t excWord=*pe++;
1199         int32_t full, idx;
1200 
1201         pe2=pe;
1202 
1203         if(excWord&amp;UCASE_EXC_CONDITIONAL_SPECIAL) {
1204             /* use hardcoded conditions and mappings */
1205             if(loc==UCASE_LOC_TURKISH &amp;&amp; c==0x69) {
1206                 /*
1207                     # Turkish and Azeri
1208 
1209                     # I and i-dotless; I-dot and i are case pairs in Turkish and Azeri
1210                     # The following rules handle those cases.
1211 
1212                     # When uppercasing, i turns into a dotted capital I
1213 
1214                     0069; 0069; 0130; 0130; tr; # LATIN SMALL LETTER I
1215                     0069; 0069; 0130; 0130; az; # LATIN SMALL LETTER I
1216                 */
1217                 return 0x130;
1218             } else if(loc==UCASE_LOC_LITHUANIAN &amp;&amp; c==0x307 &amp;&amp; isPrecededBySoftDotted(iter, context)) {
1219                 /*
1220                     # Lithuanian
1221 
1222                     # Lithuanian retains the dot in a lowercase i when followed by accents.
1223 
1224                     # Remove DOT ABOVE after &quot;i&quot; with upper or titlecase
1225 
1226                     0307; 0307; ; ; lt After_Soft_Dotted; # COMBINING DOT ABOVE
1227                  */
1228                 *pString=nullptr;
1229                 return 0; /* remove the dot (continue without output) */
1230             } else {
1231                 /* no known conditional special case mapping, use a normal mapping */
1232             }
1233         } else if(HAS_SLOT(excWord, UCASE_EXC_FULL_MAPPINGS)) {
1234             GET_SLOT_VALUE(excWord, UCASE_EXC_FULL_MAPPINGS, pe, full);
1235 
1236             /* start of full case mapping strings */
1237             ++pe;
1238 
1239             /* skip the lowercase and case-folding result strings */
1240             pe+=full&amp;UCASE_FULL_LOWER;
1241             full&gt;&gt;=4;
1242             pe+=full&amp;0xf;
1243             full&gt;&gt;=4;
1244 
1245             if(upperNotTitle) {
1246                 full&amp;=0xf;
1247             } else {
1248                 /* skip the uppercase result string */
1249                 pe+=full&amp;0xf;
1250                 full=(full&gt;&gt;4)&amp;0xf;
1251             }
1252 
1253             if(full!=0) {
1254                 /* set the output pointer to the result string */
1255                 *pString=reinterpret_cast&lt;const UChar *&gt;(pe);
1256 
1257                 /* return the string length */
1258                 return full;
1259             }
1260         }
1261 
1262         if(HAS_SLOT(excWord, UCASE_EXC_DELTA) &amp;&amp; UCASE_GET_TYPE(props)==UCASE_LOWER) {
1263             int32_t delta;
<a name="3" id="anc3"></a><span class="line-modified">1264             GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);</span>
1265             return (excWord&amp;UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta;
1266         }
1267         if(!upperNotTitle &amp;&amp; HAS_SLOT(excWord, UCASE_EXC_TITLE)) {
1268             idx=UCASE_EXC_TITLE;
1269         } else if(HAS_SLOT(excWord, UCASE_EXC_UPPER)) {
1270             /* here, titlecase is same as uppercase */
1271             idx=UCASE_EXC_UPPER;
1272         } else {
1273             return ~c;
1274         }
1275         GET_SLOT_VALUE(excWord, idx, pe2, result);
1276     }
1277 
1278     return (result==c) ? ~result : result;
1279 }
1280 
1281 U_CAPI int32_t U_EXPORT2
1282 ucase_toFullUpper(UChar32 c,
1283                   UCaseContextIterator *iter, void *context,
1284                   const UChar **pString,
1285                   int32_t caseLocale) {
1286     return toUpperOrTitle(c, iter, context, pString, caseLocale, TRUE);
1287 }
1288 
1289 U_CAPI int32_t U_EXPORT2
1290 ucase_toFullTitle(UChar32 c,
1291                   UCaseContextIterator *iter, void *context,
1292                   const UChar **pString,
1293                   int32_t caseLocale) {
1294     return toUpperOrTitle(c, iter, context, pString, caseLocale, FALSE);
1295 }
1296 
1297 /* case folding ------------------------------------------------------------- */
1298 
1299 /*
1300  * Case folding is similar to lowercasing.
1301  * The result may be a simple mapping, i.e., a single code point, or
1302  * a full mapping, i.e., a string.
1303  * If the case folding for a code point is the same as its simple (1:1) lowercase mapping,
1304  * then only the lowercase mapping is stored.
1305  *
1306  * Some special cases are hardcoded because their conditions cannot be
1307  * parsed and processed from CaseFolding.txt.
1308  *
1309  * Unicode 3.2 CaseFolding.txt specifies for its status field:
1310 
1311 # C: common case folding, common mappings shared by both simple and full mappings.
1312 # F: full case folding, mappings that cause strings to grow in length. Multiple characters are separated by spaces.
1313 # S: simple case folding, mappings to single characters where different from F.
1314 # T: special case for uppercase I and dotted uppercase I
1315 #    - For non-Turkic languages, this mapping is normally not used.
1316 #    - For Turkic languages (tr, az), this mapping can be used instead of the normal mapping for these characters.
1317 #
1318 # Usage:
1319 #  A. To do a simple case folding, use the mappings with status C + S.
1320 #  B. To do a full case folding, use the mappings with status C + F.
1321 #
1322 #    The mappings with status T can be used or omitted depending on the desired case-folding
1323 #    behavior. (The default option is to exclude them.)
1324 
1325  * Unicode 3.2 has &#39;T&#39; mappings as follows:
1326 
1327 0049; T; 0131; # LATIN CAPITAL LETTER I
1328 0130; T; 0069; # LATIN CAPITAL LETTER I WITH DOT ABOVE
1329 
1330  * while the default mappings for these code points are:
1331 
1332 0049; C; 0069; # LATIN CAPITAL LETTER I
1333 0130; F; 0069 0307; # LATIN CAPITAL LETTER I WITH DOT ABOVE
1334 
1335  * U+0130 has no simple case folding (simple-case-folds to itself).
1336  */
1337 
1338 /* return the simple case folding mapping for c */
1339 U_CAPI UChar32 U_EXPORT2
1340 ucase_fold(UChar32 c, uint32_t options) {
1341     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
1342     if(!UCASE_HAS_EXCEPTION(props)) {
1343         if(UCASE_IS_UPPER_OR_TITLE(props)) {
1344             c+=UCASE_GET_DELTA(props);
1345         }
1346     } else {
1347         const uint16_t *pe=GET_EXCEPTIONS(&amp;ucase_props_singleton, props);
1348         uint16_t excWord=*pe++;
1349         int32_t idx;
1350         if(excWord&amp;UCASE_EXC_CONDITIONAL_FOLD) {
1351             /* special case folding mappings, hardcoded */
1352             if((options&amp;_FOLD_CASE_OPTIONS_MASK)==U_FOLD_CASE_DEFAULT) {
1353                 /* default mappings */
1354                 if(c==0x49) {
1355                     /* 0049; C; 0069; # LATIN CAPITAL LETTER I */
1356                     return 0x69;
1357                 } else if(c==0x130) {
1358                     /* no simple case folding for U+0130 */
1359                     return c;
1360                 }
1361             } else {
1362                 /* Turkic mappings */
1363                 if(c==0x49) {
1364                     /* 0049; T; 0131; # LATIN CAPITAL LETTER I */
1365                     return 0x131;
1366                 } else if(c==0x130) {
1367                     /* 0130; T; 0069; # LATIN CAPITAL LETTER I WITH DOT ABOVE */
1368                     return 0x69;
1369                 }
1370             }
1371         }
1372         if((excWord&amp;UCASE_EXC_NO_SIMPLE_CASE_FOLDING)!=0) {
1373             return c;
1374         }
1375         if(HAS_SLOT(excWord, UCASE_EXC_DELTA) &amp;&amp; UCASE_IS_UPPER_OR_TITLE(props)) {
1376             int32_t delta;
1377             GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);
1378             return (excWord&amp;UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta;
1379         }
1380         if(HAS_SLOT(excWord, UCASE_EXC_FOLD)) {
1381             idx=UCASE_EXC_FOLD;
1382         } else if(HAS_SLOT(excWord, UCASE_EXC_LOWER)) {
1383             idx=UCASE_EXC_LOWER;
1384         } else {
1385             return c;
1386         }
1387         GET_SLOT_VALUE(excWord, idx, pe, c);
1388     }
1389     return c;
1390 }
1391 
1392 /*
1393  * Issue for canonical caseless match (UAX #21):
1394  * Turkic casefolding (using &quot;T&quot; mappings in CaseFolding.txt) does not preserve
1395  * canonical equivalence, unlike default-option casefolding.
1396  * For example, I-grave and I + grave fold to strings that are not canonically
1397  * equivalent.
1398  * For more details, see the comment in unorm_compare() in unorm.cpp
1399  * and the intermediate prototype changes for Jitterbug 2021.
1400  * (For example, revision 1.104 of uchar.c and 1.4 of CaseFolding.txt.)
1401  *
1402  * This did not get fixed because it appears that it is not possible to fix
1403  * it for uppercase and lowercase characters (I-grave vs. i-grave)
1404  * together in a way that they still fold to common result strings.
1405  */
1406 
1407 U_CAPI int32_t U_EXPORT2
1408 ucase_toFullFolding(UChar32 c,
1409                     const UChar **pString,
1410                     uint32_t options) {
1411     // The sign of the result has meaning, input must be non-negative so that it can be returned as is.
1412     U_ASSERT(c &gt;= 0);
1413     UChar32 result=c;
1414     uint16_t props=UTRIE2_GET16(&amp;ucase_props_singleton.trie, c);
1415     if(!UCASE_HAS_EXCEPTION(props)) {
1416         if(UCASE_IS_UPPER_OR_TITLE(props)) {
1417             result=c+UCASE_GET_DELTA(props);
1418         }
1419     } else {
1420         const uint16_t *pe=GET_EXCEPTIONS(&amp;ucase_props_singleton, props), *pe2;
1421         uint16_t excWord=*pe++;
1422         int32_t full, idx;
1423 
1424         pe2=pe;
1425 
1426         if(excWord&amp;UCASE_EXC_CONDITIONAL_FOLD) {
1427             /* use hardcoded conditions and mappings */
1428             if((options&amp;_FOLD_CASE_OPTIONS_MASK)==U_FOLD_CASE_DEFAULT) {
1429                 /* default mappings */
1430                 if(c==0x49) {
1431                     /* 0049; C; 0069; # LATIN CAPITAL LETTER I */
1432                     return 0x69;
1433                 } else if(c==0x130) {
1434                     /* 0130; F; 0069 0307; # LATIN CAPITAL LETTER I WITH DOT ABOVE */
1435                     *pString=iDot;
1436                     return 2;
1437                 }
1438             } else {
1439                 /* Turkic mappings */
1440                 if(c==0x49) {
1441                     /* 0049; T; 0131; # LATIN CAPITAL LETTER I */
1442                     return 0x131;
1443                 } else if(c==0x130) {
1444                     /* 0130; T; 0069; # LATIN CAPITAL LETTER I WITH DOT ABOVE */
1445                     return 0x69;
1446                 }
1447             }
1448         } else if(HAS_SLOT(excWord, UCASE_EXC_FULL_MAPPINGS)) {
1449             GET_SLOT_VALUE(excWord, UCASE_EXC_FULL_MAPPINGS, pe, full);
1450 
1451             /* start of full case mapping strings */
1452             ++pe;
1453 
1454             /* skip the lowercase result string */
1455             pe+=full&amp;UCASE_FULL_LOWER;
1456             full=(full&gt;&gt;4)&amp;0xf;
1457 
1458             if(full!=0) {
1459                 /* set the output pointer to the result string */
1460                 *pString=reinterpret_cast&lt;const UChar *&gt;(pe);
1461 
1462                 /* return the string length */
1463                 return full;
1464             }
1465         }
1466 
1467         if((excWord&amp;UCASE_EXC_NO_SIMPLE_CASE_FOLDING)!=0) {
1468             return ~c;
1469         }
1470         if(HAS_SLOT(excWord, UCASE_EXC_DELTA) &amp;&amp; UCASE_IS_UPPER_OR_TITLE(props)) {
1471             int32_t delta;
<a name="4" id="anc4"></a><span class="line-modified">1472             GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);</span>
1473             return (excWord&amp;UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta;
1474         }
1475         if(HAS_SLOT(excWord, UCASE_EXC_FOLD)) {
1476             idx=UCASE_EXC_FOLD;
1477         } else if(HAS_SLOT(excWord, UCASE_EXC_LOWER)) {
1478             idx=UCASE_EXC_LOWER;
1479         } else {
1480             return ~c;
1481         }
1482         GET_SLOT_VALUE(excWord, idx, pe2, result);
1483     }
1484 
1485     return (result==c) ? ~result : result;
1486 }
1487 
1488 /* case mapping properties API ---------------------------------------------- */
1489 
1490 /* public API (see uchar.h) */
1491 
1492 U_CAPI UBool U_EXPORT2
1493 u_isULowercase(UChar32 c) {
1494     return (UBool)(UCASE_LOWER==ucase_getType(c));
1495 }
1496 
1497 U_CAPI UBool U_EXPORT2
1498 u_isUUppercase(UChar32 c) {
1499     return (UBool)(UCASE_UPPER==ucase_getType(c));
1500 }
1501 
1502 /* Transforms the Unicode character to its lower case equivalent.*/
1503 U_CAPI UChar32 U_EXPORT2
1504 u_tolower(UChar32 c) {
1505     return ucase_tolower(c);
1506 }
1507 
1508 /* Transforms the Unicode character to its upper case equivalent.*/
1509 U_CAPI UChar32 U_EXPORT2
1510 u_toupper(UChar32 c) {
1511     return ucase_toupper(c);
1512 }
1513 
1514 /* Transforms the Unicode character to its title case equivalent.*/
1515 U_CAPI UChar32 U_EXPORT2
1516 u_totitle(UChar32 c) {
1517     return ucase_totitle(c);
1518 }
1519 
1520 /* return the simple case folding mapping for c */
1521 U_CAPI UChar32 U_EXPORT2
1522 u_foldCase(UChar32 c, uint32_t options) {
1523     return ucase_fold(c, options);
1524 }
1525 
1526 U_CFUNC int32_t U_EXPORT2
1527 ucase_hasBinaryProperty(UChar32 c, UProperty which) {
1528     /* case mapping properties */
1529     const UChar *resultString;
1530     switch(which) {
1531     case UCHAR_LOWERCASE:
1532         return (UBool)(UCASE_LOWER==ucase_getType(c));
1533     case UCHAR_UPPERCASE:
1534         return (UBool)(UCASE_UPPER==ucase_getType(c));
1535     case UCHAR_SOFT_DOTTED:
1536         return ucase_isSoftDotted(c);
1537     case UCHAR_CASE_SENSITIVE:
1538         return ucase_isCaseSensitive(c);
1539     case UCHAR_CASED:
1540         return (UBool)(UCASE_NONE!=ucase_getType(c));
1541     case UCHAR_CASE_IGNORABLE:
1542         return (UBool)(ucase_getTypeOrIgnorable(c)&gt;&gt;2);
1543     /*
1544      * Note: The following Changes_When_Xyz are defined as testing whether
1545      * the NFD form of the input changes when Xyz-case-mapped.
1546      * However, this simpler implementation of these properties,
1547      * ignoring NFD, passes the tests.
1548      * The implementation needs to be changed if the tests start failing.
1549      * When that happens, optimizations should be used to work with the
1550      * per-single-code point ucase_toFullXyz() functions unless
1551      * the NFD form has more than one code point,
1552      * and the property starts set needs to be the union of the
1553      * start sets for normalization and case mappings.
1554      */
1555     case UCHAR_CHANGES_WHEN_LOWERCASED:
1556         return (UBool)(ucase_toFullLower(c, NULL, NULL, &amp;resultString, UCASE_LOC_ROOT)&gt;=0);
1557     case UCHAR_CHANGES_WHEN_UPPERCASED:
1558         return (UBool)(ucase_toFullUpper(c, NULL, NULL, &amp;resultString, UCASE_LOC_ROOT)&gt;=0);
1559     case UCHAR_CHANGES_WHEN_TITLECASED:
1560         return (UBool)(ucase_toFullTitle(c, NULL, NULL, &amp;resultString, UCASE_LOC_ROOT)&gt;=0);
1561     /* case UCHAR_CHANGES_WHEN_CASEFOLDED: -- in uprops.c */
1562     case UCHAR_CHANGES_WHEN_CASEMAPPED:
1563         return (UBool)(
1564             ucase_toFullLower(c, NULL, NULL, &amp;resultString, UCASE_LOC_ROOT)&gt;=0 ||
1565             ucase_toFullUpper(c, NULL, NULL, &amp;resultString, UCASE_LOC_ROOT)&gt;=0 ||
1566             ucase_toFullTitle(c, NULL, NULL, &amp;resultString, UCASE_LOC_ROOT)&gt;=0);
1567     default:
1568         return FALSE;
1569     }
1570 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>