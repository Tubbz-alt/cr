<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/region.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="regexcst.txt.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="reldatefmt.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/region.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 166,33 ***</span>
      while ( ures_hasNext(worldContainment.getAlias()) ) {
          UnicodeString *continentName = new UnicodeString(ures_getNextUnicodeString(worldContainment.getAlias(),NULL,&amp;status));
          continents-&gt;addElement(continentName,status);
      }
  
      while ( ures_hasNext(groupingContainment.getAlias()) ) {
<span class="line-modified">!         UnicodeString *groupingName = new UnicodeString(ures_getNextUnicodeString(groupingContainment.getAlias(),NULL,&amp;status));</span>
<span class="line-modified">!         groupings-&gt;addElement(groupingName,status);</span>
      }
  
      for ( int32_t i = 0 ; i &lt; allRegions-&gt;size() ; i++ ) {
          LocalPointer&lt;Region&gt; r(new Region(), status);
          if ( U_FAILURE(status) ) {
             return;
          }
          UnicodeString *regionName = (UnicodeString *)allRegions-&gt;elementAt(i);
          r-&gt;idStr = *regionName;
  
          r-&gt;idStr.extract(0,r-&gt;idStr.length(),r-&gt;id,sizeof(r-&gt;id),US_INV);
<span class="line-modified">!         r-&gt;type = URGN_TERRITORY; // Only temporary - figure out the real type later once the aliases are known.</span>
  
          Formattable result;
          UErrorCode ps = U_ZERO_ERROR;
          df-&gt;parse(r-&gt;idStr,result,ps);
          if ( U_SUCCESS(ps) ) {
              r-&gt;code = result.getLong(); // Convert string to number
              uhash_iput(newNumericCodeMap.getAlias(),r-&gt;code,(void *)(r.getAlias()),&amp;status);
<span class="line-modified">!             r-&gt;type = URGN_SUBCONTINENT;</span>
          } else {
              r-&gt;code = -1;
          }
          void* idStrAlias = (void*)&amp;(r-&gt;idStr); // about to orphan &#39;r&#39;. Save this off.
          uhash_put(newRegionIDMap.getAlias(),idStrAlias,(void *)(r.orphan()),&amp;status); // regionIDMap takes ownership
<span class="line-new-header">--- 166,41 ---</span>
      while ( ures_hasNext(worldContainment.getAlias()) ) {
          UnicodeString *continentName = new UnicodeString(ures_getNextUnicodeString(worldContainment.getAlias(),NULL,&amp;status));
          continents-&gt;addElement(continentName,status);
      }
  
<span class="line-added">+     UResourceBundle *groupingBundle = nullptr;</span>
      while ( ures_hasNext(groupingContainment.getAlias()) ) {
<span class="line-modified">!         groupingBundle = ures_getNextResource(groupingContainment.getAlias(), groupingBundle, &amp;status);</span>
<span class="line-modified">!         if (U_FAILURE(status)) {</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         UnicodeString *groupingName = new UnicodeString(ures_getKey(groupingBundle), -1, US_INV);</span>
<span class="line-added">+         if (groupingName) {</span>
<span class="line-added">+             groupings-&gt;addElement(groupingName,status);</span>
<span class="line-added">+         }</span>
      }
<span class="line-added">+     ures_close(groupingBundle);</span>
  
      for ( int32_t i = 0 ; i &lt; allRegions-&gt;size() ; i++ ) {
          LocalPointer&lt;Region&gt; r(new Region(), status);
          if ( U_FAILURE(status) ) {
             return;
          }
          UnicodeString *regionName = (UnicodeString *)allRegions-&gt;elementAt(i);
          r-&gt;idStr = *regionName;
  
          r-&gt;idStr.extract(0,r-&gt;idStr.length(),r-&gt;id,sizeof(r-&gt;id),US_INV);
<span class="line-modified">!         r-&gt;fType = URGN_TERRITORY; // Only temporary - figure out the real type later once the aliases are known.</span>
  
          Formattable result;
          UErrorCode ps = U_ZERO_ERROR;
          df-&gt;parse(r-&gt;idStr,result,ps);
          if ( U_SUCCESS(ps) ) {
              r-&gt;code = result.getLong(); // Convert string to number
              uhash_iput(newNumericCodeMap.getAlias(),r-&gt;code,(void *)(r.getAlias()),&amp;status);
<span class="line-modified">!             r-&gt;fType = URGN_SUBCONTINENT;</span>
          } else {
              r-&gt;code = -1;
          }
          void* idStrAlias = (void*)&amp;(r-&gt;idStr); // about to orphan &#39;r&#39;. Save this off.
          uhash_put(newRegionIDMap.getAlias(),idStrAlias,(void *)(r.orphan()),&amp;status); // regionIDMap takes ownership
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,13 ***</span>
                      aliasFromRegion-&gt;code = result.getLong(); // Convert string to number
                      uhash_iput(newNumericCodeMap.getAlias(),aliasFromRegion-&gt;code,(void *)aliasFromRegion,&amp;status);
                  } else {
                      aliasFromRegion-&gt;code = -1;
                  }
<span class="line-modified">!                 aliasFromRegion-&gt;type = URGN_DEPRECATED;</span>
              } else {
<span class="line-modified">!                 aliasFromRegion-&gt;type = URGN_DEPRECATED;</span>
              }
  
              {
                  LocalPointer&lt;UVector&gt; newPreferredValues(new UVector(uprv_deleteUObject, uhash_compareUnicodeString, status), status);
                  aliasFromRegion-&gt;preferredValues = newPreferredValues.orphan();
<span class="line-new-header">--- 237,13 ---</span>
                      aliasFromRegion-&gt;code = result.getLong(); // Convert string to number
                      uhash_iput(newNumericCodeMap.getAlias(),aliasFromRegion-&gt;code,(void *)aliasFromRegion,&amp;status);
                  } else {
                      aliasFromRegion-&gt;code = -1;
                  }
<span class="line-modified">!                 aliasFromRegion-&gt;fType = URGN_DEPRECATED;</span>
              } else {
<span class="line-modified">!                 aliasFromRegion-&gt;fType = URGN_DEPRECATED;</span>
              }
  
              {
                  LocalPointer&lt;UVector&gt; newPreferredValues(new UVector(uprv_deleteUObject, uhash_compareUnicodeString, status), status);
                  aliasFromRegion-&gt;preferredValues = newPreferredValues.orphan();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 288,40 ***</span>
      // Now fill in the special cases for WORLD, UNKNOWN, CONTINENTS, and GROUPINGS
      Region *r;
      UnicodeString WORLD_ID_STRING(WORLD_ID);
      r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;WORLD_ID_STRING);
      if ( r ) {
<span class="line-modified">!         r-&gt;type = URGN_WORLD;</span>
      }
  
      UnicodeString UNKNOWN_REGION_ID_STRING(UNKNOWN_REGION_ID);
      r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;UNKNOWN_REGION_ID_STRING);
      if ( r ) {
<span class="line-modified">!         r-&gt;type = URGN_UNKNOWN;</span>
      }
  
      for ( int32_t i = 0 ; i &lt; continents-&gt;size() ; i++ ) {
          r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)continents-&gt;elementAt(i));
          if ( r ) {
<span class="line-modified">!             r-&gt;type = URGN_CONTINENT;</span>
          }
      }
  
      for ( int32_t i = 0 ; i &lt; groupings-&gt;size() ; i++ ) {
          r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)groupings-&gt;elementAt(i));
          if ( r ) {
<span class="line-modified">!             r-&gt;type = URGN_GROUPING;</span>
          }
      }
  
      // Special case: The region code &quot;QO&quot; (Outlying Oceania) is a subcontinent code added by CLDR
      // even though it looks like a territory code.  Need to handle it here.
  
      UnicodeString OUTLYING_OCEANIA_REGION_ID_STRING(OUTLYING_OCEANIA_REGION_ID);
      r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;OUTLYING_OCEANIA_REGION_ID_STRING);
      if ( r ) {
<span class="line-modified">!         r-&gt;type = URGN_SUBCONTINENT;</span>
      }
  
      // Load territory containment info from the supplemental data.
      while ( ures_hasNext(territoryContainment.getAlias()) ) {
          LocalUResourceBundlePointer mapping(ures_getNextResource(territoryContainment.getAlias(),NULL,&amp;status));
<span class="line-new-header">--- 296,40 ---</span>
      // Now fill in the special cases for WORLD, UNKNOWN, CONTINENTS, and GROUPINGS
      Region *r;
      UnicodeString WORLD_ID_STRING(WORLD_ID);
      r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;WORLD_ID_STRING);
      if ( r ) {
<span class="line-modified">!         r-&gt;fType = URGN_WORLD;</span>
      }
  
      UnicodeString UNKNOWN_REGION_ID_STRING(UNKNOWN_REGION_ID);
      r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;UNKNOWN_REGION_ID_STRING);
      if ( r ) {
<span class="line-modified">!         r-&gt;fType = URGN_UNKNOWN;</span>
      }
  
      for ( int32_t i = 0 ; i &lt; continents-&gt;size() ; i++ ) {
          r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)continents-&gt;elementAt(i));
          if ( r ) {
<span class="line-modified">!             r-&gt;fType = URGN_CONTINENT;</span>
          }
      }
  
      for ( int32_t i = 0 ; i &lt; groupings-&gt;size() ; i++ ) {
          r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)groupings-&gt;elementAt(i));
          if ( r ) {
<span class="line-modified">!             r-&gt;fType = URGN_GROUPING;</span>
          }
      }
  
      // Special case: The region code &quot;QO&quot; (Outlying Oceania) is a subcontinent code added by CLDR
      // even though it looks like a territory code.  Need to handle it here.
  
      UnicodeString OUTLYING_OCEANIA_REGION_ID_STRING(OUTLYING_OCEANIA_REGION_ID);
      r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;OUTLYING_OCEANIA_REGION_ID_STRING);
      if ( r ) {
<span class="line-modified">!         r-&gt;fType = URGN_SUBCONTINENT;</span>
      }
  
      // Load territory containment info from the supplemental data.
      while ( ures_hasNext(territoryContainment.getAlias()) ) {
          LocalUResourceBundlePointer mapping(ures_getNextResource(territoryContainment.getAlias(),NULL,&amp;status));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 354,30 ***</span>
                  parentRegion-&gt;containedRegions-&gt;addElement((void *)childStr.orphan(),status);
  
                  // Set the parent region to be the containing region of the child.
                  // Regions of type GROUPING can&#39;t be set as the parent, since another region
                  // such as a SUBCONTINENT, CONTINENT, or WORLD must always be the parent.
<span class="line-modified">!                 if ( parentRegion-&gt;type != URGN_GROUPING) {</span>
                      childRegion-&gt;containingRegion = parentRegion;
                  }
              }
          }
      }
  
      // Create the availableRegions lists
      int32_t pos = UHASH_FIRST;
      while ( const UHashElement* element = uhash_nextElement(newRegionIDMap.getAlias(),&amp;pos)) {
          Region *ar = (Region *)element-&gt;value.pointer;
<span class="line-modified">!         if ( availableRegions[ar-&gt;type] == NULL ) {</span>
              LocalPointer&lt;UVector&gt; newAr(new UVector(uprv_deleteUObject, uhash_compareUnicodeString, status), status);
<span class="line-modified">!             availableRegions[ar-&gt;type] = newAr.orphan();</span>
          }
          LocalPointer&lt;UnicodeString&gt; arString(new UnicodeString(ar-&gt;idStr), status);
          if( U_FAILURE(status) ) {
              return;  // error out
          }
<span class="line-modified">!         availableRegions[ar-&gt;type]-&gt;addElement((void *)arString.orphan(),status);</span>
      }
  
      ucln_i18n_registerCleanup(UCLN_I18N_REGION, region_cleanup);
      // copy hashtables
      numericCodeMap = newNumericCodeMap.orphan();
<span class="line-new-header">--- 362,30 ---</span>
                  parentRegion-&gt;containedRegions-&gt;addElement((void *)childStr.orphan(),status);
  
                  // Set the parent region to be the containing region of the child.
                  // Regions of type GROUPING can&#39;t be set as the parent, since another region
                  // such as a SUBCONTINENT, CONTINENT, or WORLD must always be the parent.
<span class="line-modified">!                 if ( parentRegion-&gt;fType != URGN_GROUPING) {</span>
                      childRegion-&gt;containingRegion = parentRegion;
                  }
              }
          }
      }
  
      // Create the availableRegions lists
      int32_t pos = UHASH_FIRST;
      while ( const UHashElement* element = uhash_nextElement(newRegionIDMap.getAlias(),&amp;pos)) {
          Region *ar = (Region *)element-&gt;value.pointer;
<span class="line-modified">!         if ( availableRegions[ar-&gt;fType] == NULL ) {</span>
              LocalPointer&lt;UVector&gt; newAr(new UVector(uprv_deleteUObject, uhash_compareUnicodeString, status), status);
<span class="line-modified">!             availableRegions[ar-&gt;fType] = newAr.orphan();</span>
          }
          LocalPointer&lt;UnicodeString&gt; arString(new UnicodeString(ar-&gt;idStr), status);
          if( U_FAILURE(status) ) {
              return;  // error out
          }
<span class="line-modified">!         availableRegions[ar-&gt;fType]-&gt;addElement((void *)arString.orphan(),status);</span>
      }
  
      ucln_i18n_registerCleanup(UCLN_I18N_REGION, region_cleanup);
      // copy hashtables
      numericCodeMap = newNumericCodeMap.orphan();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 414,11 ***</span>
      gRegionDataInitOnce.reset();
  }
  
  Region::Region ()
          : code(-1),
<span class="line-modified">!           type(URGN_UNKNOWN),</span>
            containingRegion(NULL),
            containedRegions(NULL),
            preferredValues(NULL) {
      id[0] = 0;
  }
<span class="line-new-header">--- 422,11 ---</span>
      gRegionDataInitOnce.reset();
  }
  
  Region::Region ()
          : code(-1),
<span class="line-modified">!           fType(URGN_UNKNOWN),</span>
            containingRegion(NULL),
            containedRegions(NULL),
            preferredValues(NULL) {
      id[0] = 0;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 479,11 ***</span>
      if ( !r ) { // Unknown region code
          status = U_ILLEGAL_ARGUMENT_ERROR;
          return NULL;
      }
  
<span class="line-modified">!     if ( r-&gt;type == URGN_DEPRECATED &amp;&amp; r-&gt;preferredValues-&gt;size() == 1) {</span>
          StringEnumeration *pv = r-&gt;getPreferredValues(status);
          pv-&gt;reset(status);
          const UnicodeString *ustr = pv-&gt;snext(status);
          r = (Region *)uhash_get(regionIDMap,(void *)ustr);
          delete pv;
<span class="line-new-header">--- 487,11 ---</span>
      if ( !r ) { // Unknown region code
          status = U_ILLEGAL_ARGUMENT_ERROR;
          return NULL;
      }
  
<span class="line-modified">!     if ( r-&gt;fType == URGN_DEPRECATED &amp;&amp; r-&gt;preferredValues-&gt;size() == 1) {</span>
          StringEnumeration *pv = r-&gt;getPreferredValues(status);
          pv-&gt;reset(status);
          const UnicodeString *ustr = pv-&gt;snext(status);
          r = (Region *)uhash_get(regionIDMap,(void *)ustr);
          delete pv;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 527,11 ***</span>
      if ( !r ) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
          return NULL;
      }
  
<span class="line-modified">!     if ( r-&gt;type == URGN_DEPRECATED &amp;&amp; r-&gt;preferredValues-&gt;size() == 1) {</span>
          StringEnumeration *pv = r-&gt;getPreferredValues(status);
          pv-&gt;reset(status);
          const UnicodeString *ustr = pv-&gt;snext(status);
          r = (Region *)uhash_get(regionIDMap,(void *)ustr);
          delete pv;
<span class="line-new-header">--- 535,11 ---</span>
      if ( !r ) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
          return NULL;
      }
  
<span class="line-modified">!     if ( r-&gt;fType == URGN_DEPRECATED &amp;&amp; r-&gt;preferredValues-&gt;size() == 1) {</span>
          StringEnumeration *pv = r-&gt;getPreferredValues(status);
          pv-&gt;reset(status);
          const UnicodeString *ustr = pv-&gt;snext(status);
          r = (Region *)uhash_get(regionIDMap,(void *)ustr);
          delete pv;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 578,11 ***</span>
      umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status);
      if ( containingRegion == NULL ) {
          return NULL;
      }
  
<span class="line-modified">!     return ( containingRegion-&gt;type == type )? containingRegion: containingRegion-&gt;getContainingRegion(type);</span>
  }
  
  /**
   * Return an enumeration over the IDs of all the regions that are immediate children of this region in the
   * region hierarchy. These returned regions could be either macro regions, territories, or a mixture of the two,
<span class="line-new-header">--- 586,11 ---</span>
      umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status);
      if ( containingRegion == NULL ) {
          return NULL;
      }
  
<span class="line-modified">!     return ( containingRegion-&gt;fType == type)? containingRegion: containingRegion-&gt;getContainingRegion(type);</span>
  }
  
  /**
   * Return an enumeration over the IDs of all the regions that are immediate children of this region in the
   * region hierarchy. These returned regions could be either macro regions, territories, or a mixture of the two,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 616,13 ***</span>
      UVector *result = new UVector(NULL, uhash_compareChars, status);
  
      StringEnumeration *cr = getContainedRegions(status);
  
      for ( int32_t i = 0 ; i &lt; cr-&gt;count(status) ; i++ ) {
<span class="line-modified">!         const char *id = cr-&gt;next(NULL,status);</span>
<span class="line-modified">!         const Region *r = Region::getInstance(id,status);</span>
<span class="line-modified">!         if ( r-&gt;getType() == type ) {</span>
              result-&gt;addElement((void *)&amp;r-&gt;idStr,status);
          } else {
              StringEnumeration *children = r-&gt;getContainedRegions(type, status);
              for ( int32_t j = 0 ; j &lt; children-&gt;count(status) ; j++ ) {
                  const char *id2 = children-&gt;next(NULL,status);
<span class="line-new-header">--- 624,13 ---</span>
      UVector *result = new UVector(NULL, uhash_compareChars, status);
  
      StringEnumeration *cr = getContainedRegions(status);
  
      for ( int32_t i = 0 ; i &lt; cr-&gt;count(status) ; i++ ) {
<span class="line-modified">!         const char *regionId = cr-&gt;next(NULL,status);</span>
<span class="line-modified">!         const Region *r = Region::getInstance(regionId,status);</span>
<span class="line-modified">!         if ( r-&gt;getType() == type) {</span>
              result-&gt;addElement((void *)&amp;r-&gt;idStr,status);
          } else {
              StringEnumeration *children = r-&gt;getContainedRegions(type, status);
              for ( int32_t j = 0 ; j &lt; children-&gt;count(status) ; j++ ) {
                  const char *id2 = children-&gt;next(NULL,status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 670,11 ***</span>
   * &quot;SU&quot; (Soviet Union) would return a list of the regions containing &quot;RU&quot; (Russia), &quot;AM&quot; (Armenia), &quot;AZ&quot; (Azerbaijan), etc...
   */
  StringEnumeration*
  Region::getPreferredValues(UErrorCode &amp;status) const {
      umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status); // returns immediately if U_FAILURE(status)
<span class="line-modified">!     if (U_FAILURE(status) ||  type != URGN_DEPRECATED) {</span>
          return NULL;
      }
      return new RegionNameEnumeration(preferredValues,status);
  }
  
<span class="line-new-header">--- 678,11 ---</span>
   * &quot;SU&quot; (Soviet Union) would return a list of the regions containing &quot;RU&quot; (Russia), &quot;AM&quot; (Armenia), &quot;AZ&quot; (Azerbaijan), etc...
   */
  StringEnumeration*
  Region::getPreferredValues(UErrorCode &amp;status) const {
      umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status); // returns immediately if U_FAILURE(status)
<span class="line-modified">!     if (U_FAILURE(status) || fType != URGN_DEPRECATED) {</span>
          return NULL;
      }
      return new RegionNameEnumeration(preferredValues,status);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 695,11 ***</span>
  /**
   * Returns the region type of this region.
   */
  URegionType
  Region::getType() const {
<span class="line-modified">!     return type;</span>
  }
  
  RegionNameEnumeration::RegionNameEnumeration(UVector *fNameList, UErrorCode&amp; status) {
      pos=0;
      if (fNameList &amp;&amp; U_SUCCESS(status)) {
<span class="line-new-header">--- 703,11 ---</span>
  /**
   * Returns the region type of this region.
   */
  URegionType
  Region::getType() const {
<span class="line-modified">!     return fType;</span>
  }
  
  RegionNameEnumeration::RegionNameEnumeration(UVector *fNameList, UErrorCode&amp; status) {
      pos=0;
      if (fNameList &amp;&amp; U_SUCCESS(status)) {
</pre>
<center><a href="regexcst.txt.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="reldatefmt.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>