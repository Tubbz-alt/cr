<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtitvinf.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="dtitvfmt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtptngen.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtitvinf.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
309     static void getCalendarTypeFromPath(const UnicodeString &amp;path, UnicodeString &amp;calendarType,
310                                         UErrorCode &amp;errorCode) {
311         if (U_FAILURE(errorCode)) { return; }
312 
313         if (!path.startsWith(PATH_PREFIX, PATH_PREFIX_LENGTH) || !path.endsWith(PATH_SUFFIX, PATH_SUFFIX_LENGTH)) {
314             errorCode = U_INVALID_FORMAT_ERROR;
315             return;
316         }
317 
318         path.extractBetween(PATH_PREFIX_LENGTH, path.length() - PATH_SUFFIX_LENGTH, calendarType);
319     }
320 
321     /**
322      * Validates and processes the pattern letter
323      */
324     UCalendarDateFields validateAndProcessPatternLetter(const char *patternLetter) {
325         // Check that patternLetter is just one letter
326         char c0;
327         if ((c0 = patternLetter[0]) != 0 &amp;&amp; patternLetter[1] == 0) {
328             // Check that the pattern letter is accepted
<span class="line-modified">329             if (c0 == &#39;y&#39;) {</span>


330                 return UCAL_YEAR;
331             } else if (c0 == &#39;M&#39;) {
332                 return UCAL_MONTH;
333             } else if (c0 == &#39;d&#39;) {
334                 return UCAL_DATE;
335             } else if (c0 == &#39;a&#39;) {
336                 return UCAL_AM_PM;
337             } else if (c0 == &#39;h&#39; || c0 == &#39;H&#39;) {
338                 return UCAL_HOUR;
339             } else if (c0 == &#39;m&#39;) {
340                 return UCAL_MINUTE;
341             }// TODO(ticket:12190): Why icu4c doesn&#39;t accept the calendar field &quot;s&quot; but icu4j does?
342         }
343         return UCAL_FIELD_COUNT;
344     }
345 
346     /**
347      * Stores the interval pattern for the current skeleton in the internal data structure
348      * if it&#39;s not present.
349      */
</pre>
<hr />
<pre>
577         copySkeleton.findAndReplace(UnicodeString(CHAR_Z), UnicodeString(CHAR_V));
578         inputSkeleton = &amp;copySkeleton;
579         replaceZWithV = true;
580     }
581 
582     parseSkeleton(*inputSkeleton, inputSkeletonFieldWidth);
583     int32_t bestDistance = MAX_POSITIVE_INT;
584     const UnicodeString* bestSkeleton = NULL;
585 
586     // 0 means exact the same skeletons;
587     // 1 means having the same field, but with different length,
588     // 2 means only z/v differs
589     // -1 means having different field.
590     bestMatchDistanceInfo = 0;
591     int8_t fieldLength = UPRV_LENGTHOF(skeletonFieldWidth);
592 
593     int32_t pos = UHASH_FIRST;
594     const UHashElement* elem = NULL;
595     while ( (elem = fIntervalPatterns-&gt;nextElement(pos)) != NULL ) {
596         const UHashTok keyTok = elem-&gt;key;
<span class="line-modified">597         UnicodeString* skeleton = (UnicodeString*)keyTok.pointer;</span>
598 #ifdef DTITVINF_DEBUG
599     skeleton-&gt;extract(0,  skeleton-&gt;length(), result, &quot;UTF-8&quot;);
600     sprintf(mesg, &quot;available skeletons: skeleton: %s; \n&quot;, result);
601     PRINTMESG(mesg)
602 #endif
603 
604         // clear skeleton field width
605         int8_t i;
606         for ( i = 0; i &lt; fieldLength; ++i ) {
607             skeletonFieldWidth[i] = 0;
608         }
<span class="line-modified">609         parseSkeleton(*skeleton, skeletonFieldWidth);</span>
610         // calculate distance
611         int32_t distance = 0;
612         int8_t fieldDifference = 1;
613         for ( i = 0; i &lt; fieldLength; ++i ) {
614             int32_t inputFieldWidth = inputSkeletonFieldWidth[i];
615             int32_t fieldWidth = skeletonFieldWidth[i];
616             if ( inputFieldWidth == fieldWidth ) {
617                 continue;
618             }
619             if ( inputFieldWidth == 0 ) {
620                 fieldDifference = -1;
621                 distance += DIFFERENT_FIELD;
622             } else if ( fieldWidth == 0 ) {
623                 fieldDifference = -1;
624                 distance += DIFFERENT_FIELD;
625             } else if (stringNumeric(inputFieldWidth, fieldWidth,
626                                      (char)(i+BASE) ) ) {
627                 distance += STRING_NUMERIC_DIFFERENCE;
628             } else {
629                 distance += (inputFieldWidth &gt; fieldWidth) ?
630                             (inputFieldWidth - fieldWidth) :
631                             (fieldWidth - inputFieldWidth);
632             }
633         }
634         if ( distance &lt; bestDistance ) {
<span class="line-modified">635             bestSkeleton = skeleton;</span>
636             bestDistance = distance;
637             bestMatchDistanceInfo = fieldDifference;
638         }
639         if ( distance == 0 ) {
640             bestMatchDistanceInfo = 0;
641             break;
642         }
643     }
644     if ( replaceZWithV &amp;&amp; bestMatchDistanceInfo != -1 ) {
645         bestMatchDistanceInfo = 2;
646     }
647     return bestSkeleton;
648 }
649 
650 
651 
652 DateIntervalInfo::IntervalPatternIndex
653 DateIntervalInfo::calendarFieldToIntervalIndex(UCalendarDateFields field,
654                                                UErrorCode&amp; status) {
655     if ( U_FAILURE(status) ) {
</pre>
</td>
<td>
<hr />
<pre>
309     static void getCalendarTypeFromPath(const UnicodeString &amp;path, UnicodeString &amp;calendarType,
310                                         UErrorCode &amp;errorCode) {
311         if (U_FAILURE(errorCode)) { return; }
312 
313         if (!path.startsWith(PATH_PREFIX, PATH_PREFIX_LENGTH) || !path.endsWith(PATH_SUFFIX, PATH_SUFFIX_LENGTH)) {
314             errorCode = U_INVALID_FORMAT_ERROR;
315             return;
316         }
317 
318         path.extractBetween(PATH_PREFIX_LENGTH, path.length() - PATH_SUFFIX_LENGTH, calendarType);
319     }
320 
321     /**
322      * Validates and processes the pattern letter
323      */
324     UCalendarDateFields validateAndProcessPatternLetter(const char *patternLetter) {
325         // Check that patternLetter is just one letter
326         char c0;
327         if ((c0 = patternLetter[0]) != 0 &amp;&amp; patternLetter[1] == 0) {
328             // Check that the pattern letter is accepted
<span class="line-modified">329             if (c0 == &#39;G&#39;) {</span>
<span class="line-added">330                 return UCAL_ERA;</span>
<span class="line-added">331             } else if (c0 == &#39;y&#39;) {</span>
332                 return UCAL_YEAR;
333             } else if (c0 == &#39;M&#39;) {
334                 return UCAL_MONTH;
335             } else if (c0 == &#39;d&#39;) {
336                 return UCAL_DATE;
337             } else if (c0 == &#39;a&#39;) {
338                 return UCAL_AM_PM;
339             } else if (c0 == &#39;h&#39; || c0 == &#39;H&#39;) {
340                 return UCAL_HOUR;
341             } else if (c0 == &#39;m&#39;) {
342                 return UCAL_MINUTE;
343             }// TODO(ticket:12190): Why icu4c doesn&#39;t accept the calendar field &quot;s&quot; but icu4j does?
344         }
345         return UCAL_FIELD_COUNT;
346     }
347 
348     /**
349      * Stores the interval pattern for the current skeleton in the internal data structure
350      * if it&#39;s not present.
351      */
</pre>
<hr />
<pre>
579         copySkeleton.findAndReplace(UnicodeString(CHAR_Z), UnicodeString(CHAR_V));
580         inputSkeleton = &amp;copySkeleton;
581         replaceZWithV = true;
582     }
583 
584     parseSkeleton(*inputSkeleton, inputSkeletonFieldWidth);
585     int32_t bestDistance = MAX_POSITIVE_INT;
586     const UnicodeString* bestSkeleton = NULL;
587 
588     // 0 means exact the same skeletons;
589     // 1 means having the same field, but with different length,
590     // 2 means only z/v differs
591     // -1 means having different field.
592     bestMatchDistanceInfo = 0;
593     int8_t fieldLength = UPRV_LENGTHOF(skeletonFieldWidth);
594 
595     int32_t pos = UHASH_FIRST;
596     const UHashElement* elem = NULL;
597     while ( (elem = fIntervalPatterns-&gt;nextElement(pos)) != NULL ) {
598         const UHashTok keyTok = elem-&gt;key;
<span class="line-modified">599         UnicodeString* newSkeleton = (UnicodeString*)keyTok.pointer;</span>
600 #ifdef DTITVINF_DEBUG
601     skeleton-&gt;extract(0,  skeleton-&gt;length(), result, &quot;UTF-8&quot;);
602     sprintf(mesg, &quot;available skeletons: skeleton: %s; \n&quot;, result);
603     PRINTMESG(mesg)
604 #endif
605 
606         // clear skeleton field width
607         int8_t i;
608         for ( i = 0; i &lt; fieldLength; ++i ) {
609             skeletonFieldWidth[i] = 0;
610         }
<span class="line-modified">611         parseSkeleton(*newSkeleton, skeletonFieldWidth);</span>
612         // calculate distance
613         int32_t distance = 0;
614         int8_t fieldDifference = 1;
615         for ( i = 0; i &lt; fieldLength; ++i ) {
616             int32_t inputFieldWidth = inputSkeletonFieldWidth[i];
617             int32_t fieldWidth = skeletonFieldWidth[i];
618             if ( inputFieldWidth == fieldWidth ) {
619                 continue;
620             }
621             if ( inputFieldWidth == 0 ) {
622                 fieldDifference = -1;
623                 distance += DIFFERENT_FIELD;
624             } else if ( fieldWidth == 0 ) {
625                 fieldDifference = -1;
626                 distance += DIFFERENT_FIELD;
627             } else if (stringNumeric(inputFieldWidth, fieldWidth,
628                                      (char)(i+BASE) ) ) {
629                 distance += STRING_NUMERIC_DIFFERENCE;
630             } else {
631                 distance += (inputFieldWidth &gt; fieldWidth) ?
632                             (inputFieldWidth - fieldWidth) :
633                             (fieldWidth - inputFieldWidth);
634             }
635         }
636         if ( distance &lt; bestDistance ) {
<span class="line-modified">637             bestSkeleton = newSkeleton;</span>
638             bestDistance = distance;
639             bestMatchDistanceInfo = fieldDifference;
640         }
641         if ( distance == 0 ) {
642             bestMatchDistanceInfo = 0;
643             break;
644         }
645     }
646     if ( replaceZWithV &amp;&amp; bestMatchDistanceInfo != -1 ) {
647         bestMatchDistanceInfo = 2;
648     }
649     return bestSkeleton;
650 }
651 
652 
653 
654 DateIntervalInfo::IntervalPatternIndex
655 DateIntervalInfo::calendarFieldToIntervalIndex(UCalendarDateFields field,
656                                                UErrorCode&amp; status) {
657     if ( U_FAILURE(status) ) {
</pre>
</td>
</tr>
</table>
<center><a href="dtitvfmt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtptngen.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>