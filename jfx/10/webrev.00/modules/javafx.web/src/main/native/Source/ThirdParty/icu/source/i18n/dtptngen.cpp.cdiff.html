<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtptngen.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="dtitvinf.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtptngen_impl.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtptngen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 16,10 ***</span>
<span class="line-new-header">--- 16,11 ---</span>
  
  #include &quot;unicode/datefmt.h&quot;
  #include &quot;unicode/decimfmt.h&quot;
  #include &quot;unicode/dtfmtsym.h&quot;
  #include &quot;unicode/dtptngen.h&quot;
<span class="line-added">+ #include &quot;unicode/localpointer.h&quot;</span>
  #include &quot;unicode/simpleformatter.h&quot;
  #include &quot;unicode/smpdtfmt.h&quot;
  #include &quot;unicode/udat.h&quot;
  #include &quot;unicode/udatpg.h&quot;
  #include &quot;unicode/uniset.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,21 ***</span>
      }
      aiter-&gt;bund = bund;
      aiter-&gt;num = ures_getSize(aiter-&gt;bund);
      aiter-&gt;cursor = 0;
  #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)
<span class="line-modified">!     aiter-&gt;entries = NULL;</span>
  #else
      aiter-&gt;entries = (UResAEntry*)uprv_malloc(sizeof(UResAEntry)*aiter-&gt;num);
      for(int i=0;i&lt;aiter-&gt;num;i++) {
<span class="line-modified">!         aiter-&gt;entries[i].item = ures_getByIndex(aiter-&gt;bund, i, NULL, status);</span>
          const char *akey = ures_getKey(aiter-&gt;entries[i].item);
          int32_t len = uprv_strlen(akey)+1;
          aiter-&gt;entries[i].key = (UChar*)uprv_malloc(len*sizeof(UChar));
          u_charsToUChars(akey, aiter-&gt;entries[i].key, len);
      }
<span class="line-modified">!     uprv_sortArray(aiter-&gt;entries, aiter-&gt;num, sizeof(UResAEntry), ures_a_codepointSort, NULL, TRUE, status);</span>
  #endif
  }
  
  static void ures_a_close(UResourceBundleAIterator *aiter) {
  #if defined(U_SORT_ASCII_BUNDLE_ITERATOR)
<span class="line-new-header">--- 87,21 ---</span>
      }
      aiter-&gt;bund = bund;
      aiter-&gt;num = ures_getSize(aiter-&gt;bund);
      aiter-&gt;cursor = 0;
  #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)
<span class="line-modified">!     aiter-&gt;entries = nullptr;</span>
  #else
      aiter-&gt;entries = (UResAEntry*)uprv_malloc(sizeof(UResAEntry)*aiter-&gt;num);
      for(int i=0;i&lt;aiter-&gt;num;i++) {
<span class="line-modified">!         aiter-&gt;entries[i].item = ures_getByIndex(aiter-&gt;bund, i, nullptr, status);</span>
          const char *akey = ures_getKey(aiter-&gt;entries[i].item);
          int32_t len = uprv_strlen(akey)+1;
          aiter-&gt;entries[i].key = (UChar*)uprv_malloc(len*sizeof(UChar));
          u_charsToUChars(akey, aiter-&gt;entries[i].key, len);
      }
<span class="line-modified">!     uprv_sortArray(aiter-&gt;entries, aiter-&gt;num, sizeof(UResAEntry), ures_a_codepointSort, nullptr, TRUE, status);</span>
  #endif
  }
  
  static void ures_a_close(UResourceBundleAIterator *aiter) {
  #if defined(U_SORT_ASCII_BUNDLE_ITERATOR)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,11 ***</span>
  
  static const UChar *ures_a_getNextString(UResourceBundleAIterator *aiter, int32_t *len, const char **key, UErrorCode *err) {
  #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)
      return ures_getNextString(aiter-&gt;bund, len, key, err);
  #else
<span class="line-modified">!     if(U_FAILURE(*err)) return NULL;</span>
      UResourceBundle *item = aiter-&gt;entries[aiter-&gt;cursor].item;
      const UChar* ret = ures_getString(item, len, err);
      *key = ures_getKey(item);
      aiter-&gt;cursor++;
      return ret;
<span class="line-new-header">--- 114,11 ---</span>
  
  static const UChar *ures_a_getNextString(UResourceBundleAIterator *aiter, int32_t *len, const char **key, UErrorCode *err) {
  #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)
      return ures_getNextString(aiter-&gt;bund, len, key, err);
  #else
<span class="line-modified">!     if(U_FAILURE(*err)) return nullptr;</span>
      UResourceBundle *item = aiter-&gt;entries[aiter-&gt;cursor].item;
      const UChar* ret = ures_getString(item, len, err);
      *key = ures_getKey(item);
      aiter-&gt;cursor++;
      return ret;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,77 ***</span>
  }
  
  DateTimePatternGenerator* U_EXPORT2
  DateTimePatternGenerator::createInstance(const Locale&amp; locale, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
      LocalPointer&lt;DateTimePatternGenerator&gt; result(
              new DateTimePatternGenerator(locale, status), status);
<span class="line-modified">!     return U_SUCCESS(status) ? result.orphan() : NULL;</span>
  }
  
  DateTimePatternGenerator*  U_EXPORT2
  DateTimePatternGenerator::createEmptyInstance(UErrorCode&amp; status) {
<span class="line-removed">-     DateTimePatternGenerator *result = new DateTimePatternGenerator(status);</span>
<span class="line-removed">-     if (result == NULL) {</span>
<span class="line-removed">-         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">-     }</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         delete result;</span>
<span class="line-removed">-         result = NULL;</span>
      }
<span class="line-modified">!     return result;</span>
  }
  
  DateTimePatternGenerator::DateTimePatternGenerator(UErrorCode &amp;status) :
<span class="line-modified">!     skipMatcher(NULL),</span>
<span class="line-modified">!     fAvailableFormatKeyHash(NULL)</span>
  {
      fp = new FormatParser();
      dtMatcher = new DateTimeMatcher();
      distanceInfo = new DistanceInfo();
      patternMap = new PatternMap();
<span class="line-modified">!     if (fp == NULL || dtMatcher == NULL || distanceInfo == NULL || patternMap == NULL) {</span>
<span class="line-modified">!         status = U_MEMORY_ALLOCATION_ERROR;</span>
      }
  }
  
  DateTimePatternGenerator::DateTimePatternGenerator(const Locale&amp; locale, UErrorCode &amp;status) :
<span class="line-modified">!     skipMatcher(NULL),</span>
<span class="line-modified">!     fAvailableFormatKeyHash(NULL)</span>
  {
      fp = new FormatParser();
      dtMatcher = new DateTimeMatcher();
      distanceInfo = new DistanceInfo();
      patternMap = new PatternMap();
<span class="line-modified">!     if (fp == NULL || dtMatcher == NULL || distanceInfo == NULL || patternMap == NULL) {</span>
<span class="line-modified">!         status = U_MEMORY_ALLOCATION_ERROR;</span>
      }
      else {
          initData(locale, status);
      }
  }
  
  DateTimePatternGenerator::DateTimePatternGenerator(const DateTimePatternGenerator&amp; other) :
      UObject(),
<span class="line-modified">!     skipMatcher(NULL),</span>
<span class="line-modified">!     fAvailableFormatKeyHash(NULL)</span>
  {
      fp = new FormatParser();
      dtMatcher = new DateTimeMatcher();
      distanceInfo = new DistanceInfo();
      patternMap = new PatternMap();
      *this=other;
  }
  
  DateTimePatternGenerator&amp;
  DateTimePatternGenerator::operator=(const DateTimePatternGenerator&amp; other) {
      pLocale = other.pLocale;
      fDefaultHourFormatChar = other.fDefaultHourFormatChar;
      *fp = *(other.fp);
      dtMatcher-&gt;copyFrom(other.dtMatcher-&gt;skeleton);
      *distanceInfo = *(other.distanceInfo);
<span class="line-new-header">--- 301,81 ---</span>
  }
  
  DateTimePatternGenerator* U_EXPORT2
  DateTimePatternGenerator::createInstance(const Locale&amp; locale, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      LocalPointer&lt;DateTimePatternGenerator&gt; result(
              new DateTimePatternGenerator(locale, status), status);
<span class="line-modified">!     return U_SUCCESS(status) ? result.orphan() : nullptr;</span>
  }
  
  DateTimePatternGenerator*  U_EXPORT2
  DateTimePatternGenerator::createEmptyInstance(UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-modified">!     LocalPointer&lt;DateTimePatternGenerator&gt; result(</span>
<span class="line-added">+             new DateTimePatternGenerator(status), status);</span>
<span class="line-added">+     return U_SUCCESS(status) ? result.orphan() : nullptr;</span>
  }
  
  DateTimePatternGenerator::DateTimePatternGenerator(UErrorCode &amp;status) :
<span class="line-modified">!     skipMatcher(nullptr),</span>
<span class="line-modified">!     fAvailableFormatKeyHash(nullptr),</span>
<span class="line-added">+     internalErrorCode(U_ZERO_ERROR)</span>
  {
      fp = new FormatParser();
      dtMatcher = new DateTimeMatcher();
      distanceInfo = new DistanceInfo();
      patternMap = new PatternMap();
<span class="line-modified">!     if (fp == nullptr || dtMatcher == nullptr || distanceInfo == nullptr || patternMap == nullptr) {</span>
<span class="line-modified">!         internalErrorCode = status = U_MEMORY_ALLOCATION_ERROR;</span>
      }
  }
  
  DateTimePatternGenerator::DateTimePatternGenerator(const Locale&amp; locale, UErrorCode &amp;status) :
<span class="line-modified">!     skipMatcher(nullptr),</span>
<span class="line-modified">!     fAvailableFormatKeyHash(nullptr),</span>
<span class="line-added">+     internalErrorCode(U_ZERO_ERROR)</span>
  {
      fp = new FormatParser();
      dtMatcher = new DateTimeMatcher();
      distanceInfo = new DistanceInfo();
      patternMap = new PatternMap();
<span class="line-modified">!     if (fp == nullptr || dtMatcher == nullptr || distanceInfo == nullptr || patternMap == nullptr) {</span>
<span class="line-modified">!         internalErrorCode = status = U_MEMORY_ALLOCATION_ERROR;</span>
      }
      else {
          initData(locale, status);
      }
  }
  
  DateTimePatternGenerator::DateTimePatternGenerator(const DateTimePatternGenerator&amp; other) :
      UObject(),
<span class="line-modified">!     skipMatcher(nullptr),</span>
<span class="line-modified">!     fAvailableFormatKeyHash(nullptr),</span>
<span class="line-added">+     internalErrorCode(U_ZERO_ERROR)</span>
  {
      fp = new FormatParser();
      dtMatcher = new DateTimeMatcher();
      distanceInfo = new DistanceInfo();
      patternMap = new PatternMap();
<span class="line-added">+     if (fp == nullptr || dtMatcher == nullptr || distanceInfo == nullptr || patternMap == nullptr) {</span>
<span class="line-added">+         internalErrorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+     }</span>
      *this=other;
  }
  
  DateTimePatternGenerator&amp;
  DateTimePatternGenerator::operator=(const DateTimePatternGenerator&amp; other) {
<span class="line-added">+     internalErrorCode = other.internalErrorCode;</span>
      pLocale = other.pLocale;
      fDefaultHourFormatChar = other.fDefaultHourFormatChar;
      *fp = *(other.fp);
      dtMatcher-&gt;copyFrom(other.dtMatcher-&gt;skeleton);
      *distanceInfo = *(other.distanceInfo);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,27 ***</span>
      decimal = other.decimal;
      // NUL-terminate for the C API.
      dateTimeFormat.getTerminatedBuffer();
      decimal.getTerminatedBuffer();
      delete skipMatcher;
<span class="line-modified">!     if ( other.skipMatcher == NULL ) {</span>
<span class="line-modified">!         skipMatcher = NULL;</span>
      }
      else {
          skipMatcher = new DateTimeMatcher(*other.skipMatcher);
      }
      for (int32_t i=0; i&lt; UDATPG_FIELD_COUNT; ++i ) {
          appendItemFormats[i] = other.appendItemFormats[i];
          appendItemFormats[i].getTerminatedBuffer(); // NUL-terminate for the C API.
          for (int32_t j=0; j&lt; UDATPG_WIDTH_COUNT; ++j ) {
              fieldDisplayNames[i][j] = other.fieldDisplayNames[i][j];
              fieldDisplayNames[i][j].getTerminatedBuffer(); // NUL-terminate for the C API.
          }
      }
<span class="line-modified">!     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified">!     patternMap-&gt;copyFrom(*other.patternMap, status);</span>
<span class="line-removed">-     copyHashtable(other.fAvailableFormatKeyHash, status);</span>
      return *this;
  }
  
  
  UBool
<span class="line-new-header">--- 383,31 ---</span>
      decimal = other.decimal;
      // NUL-terminate for the C API.
      dateTimeFormat.getTerminatedBuffer();
      decimal.getTerminatedBuffer();
      delete skipMatcher;
<span class="line-modified">!     if ( other.skipMatcher == nullptr ) {</span>
<span class="line-modified">!         skipMatcher = nullptr;</span>
      }
      else {
          skipMatcher = new DateTimeMatcher(*other.skipMatcher);
<span class="line-added">+         if (skipMatcher == nullptr)</span>
<span class="line-added">+         {</span>
<span class="line-added">+             internalErrorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+             return *this;</span>
<span class="line-added">+         }</span>
      }
      for (int32_t i=0; i&lt; UDATPG_FIELD_COUNT; ++i ) {
          appendItemFormats[i] = other.appendItemFormats[i];
          appendItemFormats[i].getTerminatedBuffer(); // NUL-terminate for the C API.
          for (int32_t j=0; j&lt; UDATPG_WIDTH_COUNT; ++j ) {
              fieldDisplayNames[i][j] = other.fieldDisplayNames[i][j];
              fieldDisplayNames[i][j].getTerminatedBuffer(); // NUL-terminate for the C API.
          }
      }
<span class="line-modified">!     patternMap-&gt;copyFrom(*other.patternMap, internalErrorCode);</span>
<span class="line-modified">!     copyHashtable(other.fAvailableFormatKeyHash, internalErrorCode);</span>
      return *this;
  }
  
  
  UBool
</pre>
<hr />
<pre>
<span class="line-old-header">*** 429,25 ***</span>
  DateTimePatternGenerator::operator!=(const DateTimePatternGenerator&amp; other) const {
      return  !operator==(other);
  }
  
  DateTimePatternGenerator::~DateTimePatternGenerator() {
<span class="line-modified">!     if (fAvailableFormatKeyHash!=NULL) {</span>
          delete fAvailableFormatKeyHash;
      }
  
<span class="line-modified">!     if (fp != NULL) delete fp;</span>
<span class="line-modified">!     if (dtMatcher != NULL) delete dtMatcher;</span>
<span class="line-modified">!     if (distanceInfo != NULL) delete distanceInfo;</span>
<span class="line-modified">!     if (patternMap != NULL) delete patternMap;</span>
<span class="line-modified">!     if (skipMatcher != NULL) delete skipMatcher;</span>
  }
  
  namespace {
  
  UInitOnce initOnce = U_INITONCE_INITIALIZER;
<span class="line-modified">! UHashtable *localeToAllowedHourFormatsMap = NULL;</span>
  
  // Value deleter for hashmap.
  U_CFUNC void U_CALLCONV deleteAllowedHourFormats(void *ptr) {
      uprv_free(ptr);
  }
<span class="line-new-header">--- 438,25 ---</span>
  DateTimePatternGenerator::operator!=(const DateTimePatternGenerator&amp; other) const {
      return  !operator==(other);
  }
  
  DateTimePatternGenerator::~DateTimePatternGenerator() {
<span class="line-modified">!     if (fAvailableFormatKeyHash!=nullptr) {</span>
          delete fAvailableFormatKeyHash;
      }
  
<span class="line-modified">!     if (fp != nullptr) delete fp;</span>
<span class="line-modified">!     if (dtMatcher != nullptr) delete dtMatcher;</span>
<span class="line-modified">!     if (distanceInfo != nullptr) delete distanceInfo;</span>
<span class="line-modified">!     if (patternMap != nullptr) delete patternMap;</span>
<span class="line-modified">!     if (skipMatcher != nullptr) delete skipMatcher;</span>
  }
  
  namespace {
  
  UInitOnce initOnce = U_INITONCE_INITIALIZER;
<span class="line-modified">! UHashtable *localeToAllowedHourFormatsMap = nullptr;</span>
  
  // Value deleter for hashmap.
  U_CFUNC void U_CALLCONV deleteAllowedHourFormats(void *ptr) {
      uprv_free(ptr);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 460,31 ***</span>
  
  enum AllowedHourFormat{
      ALLOWED_HOUR_FORMAT_UNKNOWN = -1,
      ALLOWED_HOUR_FORMAT_h,
      ALLOWED_HOUR_FORMAT_H,
      ALLOWED_HOUR_FORMAT_hb,
<span class="line-removed">-     ALLOWED_HOUR_FORMAT_Hb,</span>
      ALLOWED_HOUR_FORMAT_hB,
      ALLOWED_HOUR_FORMAT_HB
  };
  
  }  // namespace
  
  void
  DateTimePatternGenerator::initData(const Locale&amp; locale, UErrorCode &amp;status) {
      //const char *baseLangName = locale.getBaseName(); // unused
  
<span class="line-modified">!     skipMatcher = NULL;</span>
<span class="line-modified">!     fAvailableFormatKeyHash=NULL;</span>
      addCanonicalItems(status);
      addICUPatterns(locale, status);
      addCLDRData(locale, status);
      setDateTimeFromCalendar(locale, status);
      setDecimalSymbols(locale, status);
  } // DateTimePatternGenerator::initData
  
  namespace {
  
  struct AllowedHourFormatsSink : public ResourceSink {
<span class="line-new-header">--- 469,38 ---</span>
  
  enum AllowedHourFormat{
      ALLOWED_HOUR_FORMAT_UNKNOWN = -1,
      ALLOWED_HOUR_FORMAT_h,
      ALLOWED_HOUR_FORMAT_H,
<span class="line-added">+     ALLOWED_HOUR_FORMAT_K,  // Added ICU-20383, used by JP</span>
<span class="line-added">+     ALLOWED_HOUR_FORMAT_k,  // Added ICU-20383, not currently used</span>
      ALLOWED_HOUR_FORMAT_hb,
      ALLOWED_HOUR_FORMAT_hB,
<span class="line-added">+     ALLOWED_HOUR_FORMAT_Kb, // Added ICU-20383, not currently used</span>
<span class="line-added">+     ALLOWED_HOUR_FORMAT_KB, // Added ICU-20383, not currently used</span>
<span class="line-added">+     // ICU-20383 The following are unlikely and not currently used</span>
<span class="line-added">+     ALLOWED_HOUR_FORMAT_Hb,</span>
      ALLOWED_HOUR_FORMAT_HB
  };
  
  }  // namespace
  
  void
  DateTimePatternGenerator::initData(const Locale&amp; locale, UErrorCode &amp;status) {
      //const char *baseLangName = locale.getBaseName(); // unused
  
<span class="line-modified">!     skipMatcher = nullptr;</span>
<span class="line-modified">!     fAvailableFormatKeyHash=nullptr;</span>
      addCanonicalItems(status);
      addICUPatterns(locale, status);
      addCLDRData(locale, status);
      setDateTimeFromCalendar(locale, status);
      setDecimalSymbols(locale, status);
<span class="line-added">+     // If any of the above methods failed then the object is in an invalid state.</span>
<span class="line-added">+     internalErrorCode = status;</span>
  } // DateTimePatternGenerator::initData
  
  namespace {
  
  struct AllowedHourFormatsSink : public ResourceSink {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 498,51 ***</span>
          if (U_FAILURE(errorCode)) { return; }
          for (int32_t i = 0; timeData.getKeyAndValue(i, key, value); ++i) {
              const char *regionOrLocale = key;
              ResourceTable formatList = value.getTable(errorCode);
              if (U_FAILURE(errorCode)) { return; }
              for (int32_t j = 0; formatList.getKeyAndValue(j, key, value); ++j) {
<span class="line-modified">!                 if (uprv_strcmp(key, &quot;allowed&quot;) == 0) {  // Ignore &quot;preferred&quot; list.</span>
<span class="line-removed">-                     LocalMemory&lt;int32_t&gt; list;</span>
<span class="line-removed">-                     int32_t length;</span>
                      if (value.getType() == URES_STRING) {
<span class="line-modified">!                         if (list.allocateInsteadAndReset(2) == NULL) {</span>
                              errorCode = U_MEMORY_ALLOCATION_ERROR;
                              return;
                          }
<span class="line-modified">!                         list[0] = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));</span>
<span class="line-removed">-                         length = 1;</span>
                      }
                      else {
                          ResourceArray allowedFormats = value.getArray(errorCode);
<span class="line-modified">!                         length = allowedFormats.getSize();</span>
<span class="line-modified">!                         if (list.allocateInsteadAndReset(length + 1) == NULL) {</span>
                              errorCode = U_MEMORY_ALLOCATION_ERROR;
                              return;
                          }
<span class="line-modified">!                         for (int32_t k = 0; k &lt; length; ++k) {</span>
<span class="line-modified">!                             allowedFormats.getValue(k, value);</span>
                              list[k] = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));
                          }
                      }
<span class="line-modified">!                     list[length] = ALLOWED_HOUR_FORMAT_UNKNOWN;</span>
<span class="line-modified">!                     uhash_put(localeToAllowedHourFormatsMap,</span>
<span class="line-removed">-                               const_cast&lt;char *&gt;(regionOrLocale), list.orphan(), &amp;errorCode);</span>
<span class="line-removed">-                     if (U_FAILURE(errorCode)) { return; }</span>
                  }
              }
          }
      }
  
      AllowedHourFormat getHourFormatFromUnicodeString(const UnicodeString &amp;s) {
          if (s.length() == 1) {
              if (s[0] == LOW_H) { return ALLOWED_HOUR_FORMAT_h; }
              if (s[0] == CAP_H) { return ALLOWED_HOUR_FORMAT_H; }
          } else if (s.length() == 2) {
              if (s[0] == LOW_H &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_hb; }
<span class="line-removed">-             if (s[0] == CAP_H &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_Hb; }</span>
              if (s[0] == LOW_H &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_hB; }
              if (s[0] == CAP_H &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_HB; }
          }
  
          return ALLOWED_HOUR_FORMAT_UNKNOWN;
      }
<span class="line-new-header">--- 514,74 ---</span>
          if (U_FAILURE(errorCode)) { return; }
          for (int32_t i = 0; timeData.getKeyAndValue(i, key, value); ++i) {
              const char *regionOrLocale = key;
              ResourceTable formatList = value.getTable(errorCode);
              if (U_FAILURE(errorCode)) { return; }
<span class="line-added">+             // below we construct a list[] that has an entry for the &quot;preferred&quot; value at [0],</span>
<span class="line-added">+             // followed by 1 or more entries for the &quot;allowed&quot; values, terminated with an</span>
<span class="line-added">+             // entry for ALLOWED_HOUR_FORMAT_UNKNOWN (not included in length below)</span>
<span class="line-added">+             LocalMemory&lt;int32_t&gt; list;</span>
<span class="line-added">+             int32_t length = 0;</span>
<span class="line-added">+             int32_t preferredFormat = ALLOWED_HOUR_FORMAT_UNKNOWN;</span>
              for (int32_t j = 0; formatList.getKeyAndValue(j, key, value); ++j) {
<span class="line-modified">!                 if (uprv_strcmp(key, &quot;allowed&quot;) == 0) {</span>
                      if (value.getType() == URES_STRING) {
<span class="line-modified">!                         length = 2; // 1 preferred to add later, 1 allowed to add now</span>
<span class="line-added">+                         if (list.allocateInsteadAndReset(length + 1) == nullptr) {</span>
                              errorCode = U_MEMORY_ALLOCATION_ERROR;
                              return;
                          }
<span class="line-modified">!                         list[1] = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));</span>
                      }
                      else {
                          ResourceArray allowedFormats = value.getArray(errorCode);
<span class="line-modified">!                         length = allowedFormats.getSize() + 1; // 1 preferred, getSize allowed</span>
<span class="line-modified">!                         if (list.allocateInsteadAndReset(length + 1) == nullptr) {</span>
                              errorCode = U_MEMORY_ALLOCATION_ERROR;
                              return;
                          }
<span class="line-modified">!                         for (int32_t k = 1; k &lt; length; ++k) {</span>
<span class="line-modified">!                             allowedFormats.getValue(k-1, value);</span>
                              list[k] = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));
                          }
                      }
<span class="line-modified">!                 } else if (uprv_strcmp(key, &quot;preferred&quot;) == 0) {</span>
<span class="line-modified">!                     preferredFormat = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));</span>
                  }
              }
<span class="line-added">+             if (length &gt; 1) {</span>
<span class="line-added">+                 list[0] = (preferredFormat!=ALLOWED_HOUR_FORMAT_UNKNOWN)? preferredFormat: list[1];</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 // fallback handling for missing data</span>
<span class="line-added">+                 length = 2; // 1 preferred, 1 allowed</span>
<span class="line-added">+                 if (list.allocateInsteadAndReset(length + 1) == nullptr) {</span>
<span class="line-added">+                     errorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+                     return;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 list[0] = (preferredFormat!=ALLOWED_HOUR_FORMAT_UNKNOWN)? preferredFormat: ALLOWED_HOUR_FORMAT_H;</span>
<span class="line-added">+                 list[1] = list[0];</span>
<span class="line-added">+             }</span>
<span class="line-added">+             list[length] = ALLOWED_HOUR_FORMAT_UNKNOWN;</span>
<span class="line-added">+             // At this point list[] will have at least two non-ALLOWED_HOUR_FORMAT_UNKNOWN entries,</span>
<span class="line-added">+             // followed by ALLOWED_HOUR_FORMAT_UNKNOWN.</span>
<span class="line-added">+             uhash_put(localeToAllowedHourFormatsMap, const_cast&lt;char *&gt;(regionOrLocale), list.orphan(), &amp;errorCode);</span>
<span class="line-added">+             if (U_FAILURE(errorCode)) { return; }</span>
          }
      }
  
      AllowedHourFormat getHourFormatFromUnicodeString(const UnicodeString &amp;s) {
          if (s.length() == 1) {
              if (s[0] == LOW_H) { return ALLOWED_HOUR_FORMAT_h; }
              if (s[0] == CAP_H) { return ALLOWED_HOUR_FORMAT_H; }
<span class="line-added">+             if (s[0] == CAP_K) { return ALLOWED_HOUR_FORMAT_K; }</span>
<span class="line-added">+             if (s[0] == LOW_K) { return ALLOWED_HOUR_FORMAT_k; }</span>
          } else if (s.length() == 2) {
              if (s[0] == LOW_H &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_hb; }
              if (s[0] == LOW_H &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_hB; }
<span class="line-added">+             if (s[0] == CAP_K &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_Kb; }</span>
<span class="line-added">+             if (s[0] == CAP_K &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_KB; }</span>
<span class="line-added">+             if (s[0] == CAP_H &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_Hb; }</span>
              if (s[0] == CAP_H &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_HB; }
          }
  
          return ALLOWED_HOUR_FORMAT_UNKNOWN;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 553,74 ***</span>
  AllowedHourFormatsSink::~AllowedHourFormatsSink() {}
  
  U_CFUNC void U_CALLCONV DateTimePatternGenerator::loadAllowedHourFormatsData(UErrorCode &amp;status) {
      if (U_FAILURE(status)) { return; }
      localeToAllowedHourFormatsMap = uhash_open(
<span class="line-modified">!         uhash_hashChars, uhash_compareChars, NULL, &amp;status);</span>
      uhash_setValueDeleter(localeToAllowedHourFormatsMap, deleteAllowedHourFormats);
<span class="line-modified">!     LocalUResourceBundlePointer rb(ures_openDirect(NULL, &quot;supplementalData&quot;, &amp;status));</span>
  
      AllowedHourFormatsSink sink;
      // TODO: Currently in the enumeration each table allocates a new array.
      // Try to reduce the number of memory allocations. Consider storing a
      // UVector32 with the concatenation of all of the sub-arrays, put the start index
      // into the hashmap, store 6 single-value sub-arrays right at the beginning of the
      // vector (at index enum*2) for easy data sharing, copy sub-arrays into runtime
      // object. Remember to clean up the vector, too.
      ures_getAllItemsWithFallback(rb.getAlias(), &quot;timeData&quot;, sink, status);
<span class="line-removed">- </span>
<span class="line-removed">-     ucln_i18n_registerCleanup(UCLN_I18N_ALLOWED_HOUR_FORMATS, allowedHourFormatsCleanup);</span>
  }
  
  void DateTimePatternGenerator::getAllowedHourFormats(const Locale &amp;locale, UErrorCode &amp;status) {
      if (U_FAILURE(status)) { return; }
<span class="line-modified">!     const char *localeID = locale.getName();</span>
<span class="line-modified">!     char maxLocaleID[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-removed">-     int32_t length = uloc_addLikelySubtags(localeID, maxLocaleID, ULOC_FULLNAME_CAPACITY, &amp;status);</span>
      if (U_FAILURE(status)) {
          return;
<span class="line-removed">-     } else if (length == ULOC_FULLNAME_CAPACITY) {  // no room for NUL</span>
<span class="line-removed">-         status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-removed">-         return;</span>
      }
<span class="line-removed">-     Locale maxLocale = Locale(maxLocaleID);</span>
  
      const char *country = maxLocale.getCountry();
      if (*country == &#39;\0&#39;) { country = &quot;001&quot;; }
      const char *language = maxLocale.getLanguage();
  
      CharString langCountry;
<span class="line-modified">!     langCountry.append(language, uprv_strlen(language), status);</span>
      langCountry.append(&#39;_&#39;, status);
<span class="line-modified">!     langCountry.append(country, uprv_strlen(country), status);</span>
  
      int32_t *allowedFormats;
      allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, langCountry.data());
<span class="line-modified">!     if (allowedFormats == NULL) {</span>
          allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, const_cast&lt;char *&gt;(country));
      }
  
<span class="line-modified">!     if (allowedFormats != NULL) {  // Lookup is successful</span>
          for (int32_t i = 0; i &lt; UPRV_LENGTHOF(fAllowedHourFormats); ++i) {
<span class="line-modified">!             fAllowedHourFormats[i] = allowedFormats[i];</span>
<span class="line-modified">!             if (allowedFormats[i] == ALLOWED_HOUR_FORMAT_UNKNOWN) {</span>
                  break;
              }
          }
      } else {  // Lookup failed, twice
          fAllowedHourFormats[0] = ALLOWED_HOUR_FORMAT_H;
          fAllowedHourFormats[1] = ALLOWED_HOUR_FORMAT_UNKNOWN;
      }
  }
  
  UnicodeString
  DateTimePatternGenerator::getSkeleton(const UnicodeString&amp; pattern, UErrorCode&amp;
  /*status*/) {
<span class="line-modified">!     FormatParser fp;</span>
      DateTimeMatcher matcher;
      PtnSkeleton localSkeleton;
<span class="line-modified">!     matcher.set(pattern, &amp;fp, localSkeleton);</span>
      return localSkeleton.getSkeleton();
  }
  
  UnicodeString
  DateTimePatternGenerator::staticGetSkeleton(
<span class="line-new-header">--- 592,82 ---</span>
  AllowedHourFormatsSink::~AllowedHourFormatsSink() {}
  
  U_CFUNC void U_CALLCONV DateTimePatternGenerator::loadAllowedHourFormatsData(UErrorCode &amp;status) {
      if (U_FAILURE(status)) { return; }
      localeToAllowedHourFormatsMap = uhash_open(
<span class="line-modified">!         uhash_hashChars, uhash_compareChars, nullptr, &amp;status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">+ </span>
      uhash_setValueDeleter(localeToAllowedHourFormatsMap, deleteAllowedHourFormats);
<span class="line-modified">!     ucln_i18n_registerCleanup(UCLN_I18N_ALLOWED_HOUR_FORMATS, allowedHourFormatsCleanup);</span>
<span class="line-added">+ </span>
<span class="line-added">+     LocalUResourceBundlePointer rb(ures_openDirect(nullptr, &quot;supplementalData&quot;, &amp;status));</span>
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
  
      AllowedHourFormatsSink sink;
      // TODO: Currently in the enumeration each table allocates a new array.
      // Try to reduce the number of memory allocations. Consider storing a
      // UVector32 with the concatenation of all of the sub-arrays, put the start index
      // into the hashmap, store 6 single-value sub-arrays right at the beginning of the
      // vector (at index enum*2) for easy data sharing, copy sub-arrays into runtime
      // object. Remember to clean up the vector, too.
      ures_getAllItemsWithFallback(rb.getAlias(), &quot;timeData&quot;, sink, status);
  }
  
  void DateTimePatternGenerator::getAllowedHourFormats(const Locale &amp;locale, UErrorCode &amp;status) {
      if (U_FAILURE(status)) { return; }
<span class="line-modified">!     Locale maxLocale(locale);</span>
<span class="line-modified">!     maxLocale.addLikelySubtags(status);</span>
      if (U_FAILURE(status)) {
          return;
      }
  
      const char *country = maxLocale.getCountry();
      if (*country == &#39;\0&#39;) { country = &quot;001&quot;; }
      const char *language = maxLocale.getLanguage();
  
      CharString langCountry;
<span class="line-modified">!     langCountry.append(language, static_cast&lt;int32_t&gt;(uprv_strlen(language)), status);</span>
      langCountry.append(&#39;_&#39;, status);
<span class="line-modified">!     langCountry.append(country, static_cast&lt;int32_t&gt;(uprv_strlen(country)), status);</span>
  
      int32_t *allowedFormats;
      allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, langCountry.data());
<span class="line-modified">!     if (allowedFormats == nullptr) {</span>
          allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, const_cast&lt;char *&gt;(country));
      }
  
<span class="line-modified">!     if (allowedFormats != nullptr) {  // Lookup is successful</span>
<span class="line-added">+         // Here allowedFormats points to a list consisting of key for preferredFormat,</span>
<span class="line-added">+         // followed by one or more keys for allowedFormats, then followed by ALLOWED_HOUR_FORMAT_UNKNOWN.</span>
<span class="line-added">+         switch (allowedFormats[0]) {</span>
<span class="line-added">+             case ALLOWED_HOUR_FORMAT_h: fDefaultHourFormatChar = LOW_H; break;</span>
<span class="line-added">+             case ALLOWED_HOUR_FORMAT_H: fDefaultHourFormatChar = CAP_H; break;</span>
<span class="line-added">+             case ALLOWED_HOUR_FORMAT_K: fDefaultHourFormatChar = CAP_K; break;</span>
<span class="line-added">+             case ALLOWED_HOUR_FORMAT_k: fDefaultHourFormatChar = LOW_K; break;</span>
<span class="line-added">+             default: fDefaultHourFormatChar = CAP_H; break;</span>
<span class="line-added">+         }</span>
          for (int32_t i = 0; i &lt; UPRV_LENGTHOF(fAllowedHourFormats); ++i) {
<span class="line-modified">!             fAllowedHourFormats[i] = allowedFormats[i + 1];</span>
<span class="line-modified">!             if (fAllowedHourFormats[i] == ALLOWED_HOUR_FORMAT_UNKNOWN) {</span>
                  break;
              }
          }
      } else {  // Lookup failed, twice
<span class="line-added">+         fDefaultHourFormatChar = CAP_H;</span>
          fAllowedHourFormats[0] = ALLOWED_HOUR_FORMAT_H;
          fAllowedHourFormats[1] = ALLOWED_HOUR_FORMAT_UNKNOWN;
      }
  }
  
  UnicodeString
  DateTimePatternGenerator::getSkeleton(const UnicodeString&amp; pattern, UErrorCode&amp;
  /*status*/) {
<span class="line-modified">!     FormatParser fp2;</span>
      DateTimeMatcher matcher;
      PtnSkeleton localSkeleton;
<span class="line-modified">!     matcher.set(pattern, &amp;fp2, localSkeleton);</span>
      return localSkeleton.getSkeleton();
  }
  
  UnicodeString
  DateTimePatternGenerator::staticGetSkeleton(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 632,14 ***</span>
      return localSkeleton.getSkeleton();
  }
  
  UnicodeString
  DateTimePatternGenerator::getBaseSkeleton(const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
<span class="line-modified">!     FormatParser fp;</span>
      DateTimeMatcher matcher;
      PtnSkeleton localSkeleton;
<span class="line-modified">!     matcher.set(pattern, &amp;fp, localSkeleton);</span>
      return localSkeleton.getBaseSkeleton();
  }
  
  UnicodeString
  DateTimePatternGenerator::staticGetBaseSkeleton(
<span class="line-new-header">--- 679,14 ---</span>
      return localSkeleton.getSkeleton();
  }
  
  UnicodeString
  DateTimePatternGenerator::getBaseSkeleton(const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
<span class="line-modified">!     FormatParser fp2;</span>
      DateTimeMatcher matcher;
      PtnSkeleton localSkeleton;
<span class="line-modified">!     matcher.set(pattern, &amp;fp2, localSkeleton);</span>
      return localSkeleton.getBaseSkeleton();
  }
  
  UnicodeString
  DateTimePatternGenerator::staticGetBaseSkeleton(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 661,20 ***</span>
      // Load with ICU patterns
      for (int32_t i=DateFormat::kFull; i&lt;=DateFormat::kShort; i++) {
          DateFormat::EStyle style = (DateFormat::EStyle)i;
          df = DateFormat::createDateInstance(style, locale);
          SimpleDateFormat* sdf;
<span class="line-modified">!         if (df != NULL &amp;&amp; (sdf = dynamic_cast&lt;SimpleDateFormat*&gt;(df)) != NULL) {</span>
              sdf-&gt;toPattern(dfPattern);
              addPattern(dfPattern, FALSE, conflictingString, status);
          }
          // TODO Maybe we should return an error when the date format isn&#39;t simple.
          delete df;
          if (U_FAILURE(status)) { return; }
  
          df = DateFormat::createTimeInstance(style, locale);
<span class="line-modified">!         if (df != NULL &amp;&amp; (sdf = dynamic_cast&lt;SimpleDateFormat*&gt;(df)) != NULL) {</span>
              sdf-&gt;toPattern(dfPattern);
              addPattern(dfPattern, FALSE, conflictingString, status);
  
              // TODO: C++ and Java are inconsistent (see #12568).
              // C++ uses MEDIUM, but Java uses SHORT.
<span class="line-new-header">--- 708,20 ---</span>
      // Load with ICU patterns
      for (int32_t i=DateFormat::kFull; i&lt;=DateFormat::kShort; i++) {
          DateFormat::EStyle style = (DateFormat::EStyle)i;
          df = DateFormat::createDateInstance(style, locale);
          SimpleDateFormat* sdf;
<span class="line-modified">!         if (df != nullptr &amp;&amp; (sdf = dynamic_cast&lt;SimpleDateFormat*&gt;(df)) != nullptr) {</span>
              sdf-&gt;toPattern(dfPattern);
              addPattern(dfPattern, FALSE, conflictingString, status);
          }
          // TODO Maybe we should return an error when the date format isn&#39;t simple.
          delete df;
          if (U_FAILURE(status)) { return; }
  
          df = DateFormat::createTimeInstance(style, locale);
<span class="line-modified">!         if (df != nullptr &amp;&amp; (sdf = dynamic_cast&lt;SimpleDateFormat*&gt;(df)) != nullptr) {</span>
              sdf-&gt;toPattern(dfPattern);
              addPattern(dfPattern, FALSE, conflictingString, status);
  
              // TODO: C++ and Java are inconsistent (see #12568).
              // C++ uses MEDIUM, but Java uses SHORT.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 734,61 ***</span>
      }
  }
  
  #define ULOC_LOCALE_IDENTIFIER_CAPACITY (ULOC_FULLNAME_CAPACITY + 1 + ULOC_KEYWORD_AND_VALUES_CAPACITY)
  
<span class="line-removed">- static const UChar hourFormatChars[] = { CAP_H, LOW_H, CAP_K, LOW_K, 0 }; // HhKk, the hour format characters</span>
<span class="line-removed">- </span>
  void
  DateTimePatternGenerator::getCalendarTypeToUse(const Locale&amp; locale, CharString&amp; destination, UErrorCode&amp; err) {
      destination.clear().append(DT_DateTimeGregorianTag, -1, err); // initial default
      if ( U_SUCCESS(err) ) {
          char localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY];
          // obtain a locale that always has the calendar key value that should be used
          ures_getFunctionalEquivalent(
              localeWithCalendarKey,
              ULOC_LOCALE_IDENTIFIER_CAPACITY,
<span class="line-modified">!             NULL,</span>
              &quot;calendar&quot;,
              &quot;calendar&quot;,
              locale.getName(),
<span class="line-modified">!             NULL,</span>
              FALSE,
              &amp;err);
          localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY-1] = 0; // ensure null termination
          // now get the calendar key value from that locale
          char calendarType[ULOC_KEYWORDS_CAPACITY];
          int32_t calendarTypeLen = uloc_getKeywordValue(
              localeWithCalendarKey,
              &quot;calendar&quot;,
              calendarType,
              ULOC_KEYWORDS_CAPACITY,
              &amp;err);
<span class="line-modified">!         if (U_SUCCESS(err) &amp;&amp; calendarTypeLen &lt; ULOC_KEYWORDS_CAPACITY) {</span>
              destination.clear().append(calendarType, -1, err);
              if (U_FAILURE(err)) { return; }
          }
          err = U_ZERO_ERROR;
      }
  }
  
  void
  DateTimePatternGenerator::consumeShortTimePattern(const UnicodeString&amp; shortTimePattern,
          UErrorCode&amp; status) {
<span class="line-modified">! </span>
<span class="line-modified">!     // set fDefaultHourFormatChar to the hour format character from this pattern</span>
<span class="line-modified">!     int32_t tfIdx, tfLen = shortTimePattern.length();</span>
<span class="line-modified">!     UBool ignoreChars = FALSE;</span>
<span class="line-removed">-     for (tfIdx = 0; tfIdx &lt; tfLen; tfIdx++) {</span>
<span class="line-removed">-         UChar tfChar = shortTimePattern.charAt(tfIdx);</span>
<span class="line-removed">-         if ( tfChar == SINGLE_QUOTE ) {</span>
<span class="line-removed">-             ignoreChars = !ignoreChars; // toggle (handle quoted literals &amp; &#39;&#39; for single quote)</span>
<span class="line-removed">-         } else if ( !ignoreChars &amp;&amp; u_strchr(hourFormatChars, tfChar) != NULL ) {</span>
<span class="line-removed">-             fDefaultHourFormatChar = tfChar;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  
      // HACK for hh:ss
      hackTimes(shortTimePattern, status);
  }
  
<span class="line-new-header">--- 781,52 ---</span>
      }
  }
  
  #define ULOC_LOCALE_IDENTIFIER_CAPACITY (ULOC_FULLNAME_CAPACITY + 1 + ULOC_KEYWORD_AND_VALUES_CAPACITY)
  
  void
  DateTimePatternGenerator::getCalendarTypeToUse(const Locale&amp; locale, CharString&amp; destination, UErrorCode&amp; err) {
      destination.clear().append(DT_DateTimeGregorianTag, -1, err); // initial default
      if ( U_SUCCESS(err) ) {
          char localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY];
          // obtain a locale that always has the calendar key value that should be used
          ures_getFunctionalEquivalent(
              localeWithCalendarKey,
              ULOC_LOCALE_IDENTIFIER_CAPACITY,
<span class="line-modified">!             nullptr,</span>
              &quot;calendar&quot;,
              &quot;calendar&quot;,
              locale.getName(),
<span class="line-modified">!             nullptr,</span>
              FALSE,
              &amp;err);
<span class="line-added">+         if (U_FAILURE(err)) { return; }</span>
          localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY-1] = 0; // ensure null termination
          // now get the calendar key value from that locale
          char calendarType[ULOC_KEYWORDS_CAPACITY];
          int32_t calendarTypeLen = uloc_getKeywordValue(
              localeWithCalendarKey,
              &quot;calendar&quot;,
              calendarType,
              ULOC_KEYWORDS_CAPACITY,
              &amp;err);
<span class="line-modified">!         if (U_FAILURE(err)) { return; }</span>
<span class="line-added">+         if (calendarTypeLen &lt; ULOC_KEYWORDS_CAPACITY) {</span>
              destination.clear().append(calendarType, -1, err);
              if (U_FAILURE(err)) { return; }
          }
          err = U_ZERO_ERROR;
      }
  }
  
  void
  DateTimePatternGenerator::consumeShortTimePattern(const UnicodeString&amp; shortTimePattern,
          UErrorCode&amp; status) {
<span class="line-modified">!     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">!     // ICU-20383 No longer set fDefaultHourFormatChar to the hour format character from</span>
<span class="line-modified">!     // this pattern; instead it is set from localeToAllowedHourFormatsMap which now</span>
<span class="line-modified">!     // includes entries for both preferred and allowed formats.</span>
  
      // HACK for hh:ss
      hackTimes(shortTimePattern, status);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 870,13 ***</span>
                  }
                  // NUL-terminate for the C API.
                  valueStr.getTerminatedBuffer();
              }
              for (int32_t j = 1; j &lt; UDATPG_WIDTH_COUNT; j++) {
<span class="line-modified">!                 UnicodeString&amp; valueStr = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)j);</span>
<span class="line-modified">!                 if (valueStr.isEmpty()) {</span>
<span class="line-modified">!                     valueStr = dtpg.getFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)(j-1));</span>
                  }
              }
          }
      }
  };
<span class="line-new-header">--- 908,13 ---</span>
                  }
                  // NUL-terminate for the C API.
                  valueStr.getTerminatedBuffer();
              }
              for (int32_t j = 1; j &lt; UDATPG_WIDTH_COUNT; j++) {
<span class="line-modified">!                 UnicodeString&amp; valueStr2 = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)j);</span>
<span class="line-modified">!                 if (valueStr2.isEmpty()) {</span>
<span class="line-modified">!                     valueStr2 = dtpg.getFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)(j-1));</span>
                  }
              }
          }
      }
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 919,11 ***</span>
  DateTimePatternGenerator::addCLDRData(const Locale&amp; locale, UErrorCode&amp; errorCode) {
      if (U_FAILURE(errorCode)) { return; }
      UnicodeString rbPattern, value, field;
      CharString path;
  
<span class="line-modified">!     LocalUResourceBundlePointer rb(ures_open(NULL, locale.getName(), &amp;errorCode));</span>
      if (U_FAILURE(errorCode)) { return; }
  
      CharString calendarTypeToUse; // to be filled in with the type to use, if all goes well
      getCalendarTypeToUse(locale, calendarTypeToUse, errorCode);
      if (U_FAILURE(errorCode)) { return; }
<span class="line-new-header">--- 957,11 ---</span>
  DateTimePatternGenerator::addCLDRData(const Locale&amp; locale, UErrorCode&amp; errorCode) {
      if (U_FAILURE(errorCode)) { return; }
      UnicodeString rbPattern, value, field;
      CharString path;
  
<span class="line-modified">!     LocalUResourceBundlePointer rb(ures_open(nullptr, locale.getName(), &amp;errorCode));</span>
      if (U_FAILURE(errorCode)) { return; }
  
      CharString calendarTypeToUse; // to be filled in with the type to use, if all goes well
      getCalendarTypeToUse(locale, calendarTypeToUse, errorCode);
      if (U_FAILURE(errorCode)) { return; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 964,16 ***</span>
      ures_getAllItemsWithFallback(rb.getAlias(), path.data(), availableFormatsSink, err);
  }
  
  void
  DateTimePatternGenerator::initHashtable(UErrorCode&amp; err) {
<span class="line-modified">!     if (fAvailableFormatKeyHash!=NULL) {</span>
          return;
      }
<span class="line-modified">!     if ((fAvailableFormatKeyHash = new Hashtable(FALSE, err))==NULL) {</span>
<span class="line-modified">!         err=U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">!         return;</span>
      }
  }
  
  void
  DateTimePatternGenerator::setAppendItemFormat(UDateTimePatternField field, const UnicodeString&amp; value) {
<span class="line-new-header">--- 1002,17 ---</span>
      ures_getAllItemsWithFallback(rb.getAlias(), path.data(), availableFormatsSink, err);
  }
  
  void
  DateTimePatternGenerator::initHashtable(UErrorCode&amp; err) {
<span class="line-modified">!     if (U_FAILURE(err)) { return; }</span>
<span class="line-added">+     if (fAvailableFormatKeyHash!=nullptr) {</span>
          return;
      }
<span class="line-modified">!     LocalPointer&lt;Hashtable&gt; hash(new Hashtable(FALSE, err), err);</span>
<span class="line-modified">!     if (U_SUCCESS(err)) {</span>
<span class="line-modified">!         fAvailableFormatKeyHash = hash.orphan();</span>
      }
  }
  
  void
  DateTimePatternGenerator::setAppendItemFormat(UDateTimePatternField field, const UnicodeString&amp; value) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1026,11 ***</span>
      return getBestPattern(patternForm, UDATPG_MATCH_NO_OPTIONS, status);
  }
  
  UnicodeString
  DateTimePatternGenerator::getBestPattern(const UnicodeString&amp; patternForm, UDateTimePatternMatchOptions options, UErrorCode&amp; status) {
<span class="line-modified">!     const UnicodeString *bestPattern=NULL;</span>
      UnicodeString dtFormat;
      UnicodeString resultPattern;
      int32_t flags = kDTPGNoFlags;
  
      int32_t dateMask=(1&lt;&lt;UDATPG_DAYPERIOD_FIELD) - 1;
<span class="line-new-header">--- 1065,18 ---</span>
      return getBestPattern(patternForm, UDATPG_MATCH_NO_OPTIONS, status);
  }
  
  UnicodeString
  DateTimePatternGenerator::getBestPattern(const UnicodeString&amp; patternForm, UDateTimePatternMatchOptions options, UErrorCode&amp; status) {
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return UnicodeString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">+         status = internalErrorCode;</span>
<span class="line-added">+         return UnicodeString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     const UnicodeString *bestPattern = nullptr;</span>
      UnicodeString dtFormat;
      UnicodeString resultPattern;
      int32_t flags = kDTPGNoFlags;
  
      int32_t dateMask=(1&lt;&lt;UDATPG_DAYPERIOD_FIELD) - 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1042,20 ***</span>
          return UnicodeString();
      }
  
      resultPattern.remove();
      dtMatcher-&gt;set(patternFormMapped, fp);
<span class="line-modified">!     const PtnSkeleton* specifiedSkeleton=NULL;</span>
<span class="line-modified">!     bestPattern=getBestRaw(*dtMatcher, -1, distanceInfo, &amp;specifiedSkeleton);</span>
      if ( distanceInfo-&gt;missingFieldMask==0 &amp;&amp; distanceInfo-&gt;extraFieldMask==0 ) {
          resultPattern = adjustFieldTypes(*bestPattern, specifiedSkeleton, flags, options);
  
          return resultPattern;
      }
      int32_t neededFields = dtMatcher-&gt;getFieldMask();
<span class="line-modified">!     UnicodeString datePattern=getBestAppending(neededFields &amp; dateMask, flags, options);</span>
<span class="line-modified">!     UnicodeString timePattern=getBestAppending(neededFields &amp; timeMask, flags, options);</span>
      if (datePattern.length()==0) {
          if (timePattern.length()==0) {
              resultPattern.remove();
          }
          else {
<span class="line-new-header">--- 1088,27 ---</span>
          return UnicodeString();
      }
  
      resultPattern.remove();
      dtMatcher-&gt;set(patternFormMapped, fp);
<span class="line-modified">!     const PtnSkeleton* specifiedSkeleton = nullptr;</span>
<span class="line-modified">!     bestPattern=getBestRaw(*dtMatcher, -1, distanceInfo, status, &amp;specifiedSkeleton);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return UnicodeString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if ( distanceInfo-&gt;missingFieldMask==0 &amp;&amp; distanceInfo-&gt;extraFieldMask==0 ) {
          resultPattern = adjustFieldTypes(*bestPattern, specifiedSkeleton, flags, options);
  
          return resultPattern;
      }
      int32_t neededFields = dtMatcher-&gt;getFieldMask();
<span class="line-modified">!     UnicodeString datePattern=getBestAppending(neededFields &amp; dateMask, flags, status, options);</span>
<span class="line-modified">!     UnicodeString timePattern=getBestAppending(neededFields &amp; timeMask, flags, status, options);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return UnicodeString();</span>
<span class="line-added">+     }</span>
      if (datePattern.length()==0) {
          if (timePattern.length()==0) {
              resultPattern.remove();
          }
          else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1072,11 ***</span>
      return resultPattern;
  }
  
  /*
   * Map a skeleton that may have metacharacters jJC to one without, by replacing
<span class="line-modified">!  * the metacharacters with locale-appropriate fields of of h/H/k/K and of a/b/B</span>
   * (depends on fDefaultHourFormatChar and fAllowedHourFormats being set, which in
   * turn depends on initData having been run). This method also updates the flags
   * as necessary. Returns the updated skeleton.
   */
  UnicodeString
<span class="line-new-header">--- 1125,11 ---</span>
      return resultPattern;
  }
  
  /*
   * Map a skeleton that may have metacharacters jJC to one without, by replacing
<span class="line-modified">!  * the metacharacters with locale-appropriate fields of h/H/k/K and of a/b/B</span>
   * (depends on fDefaultHourFormatChar and fAllowedHourFormats being set, which in
   * turn depends on initData having been run). This method also updates the flags
   * as necessary. Returns the updated skeleton.
   */
  UnicodeString
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1107,24 ***</span>
                  UChar hourChar = LOW_H;
                  UChar dayPeriodChar = LOW_A;
                  if (patChr == LOW_J) {
                      hourChar = fDefaultHourFormatChar;
                  } else {
<span class="line-modified">!                     AllowedHourFormat preferred;</span>
                      if (fAllowedHourFormats[0] != ALLOWED_HOUR_FORMAT_UNKNOWN) {
<span class="line-modified">!                         preferred = (AllowedHourFormat)fAllowedHourFormats[0];</span>
                      } else {
                          status = U_INVALID_FORMAT_ERROR;
                          return UnicodeString();
                      }
<span class="line-modified">!                     if (preferred == ALLOWED_HOUR_FORMAT_H || preferred == ALLOWED_HOUR_FORMAT_HB || preferred == ALLOWED_HOUR_FORMAT_Hb) {</span>
                          hourChar = CAP_H;
                      }
                      // in #13183 just add b/B to skeleton, no longer need to set special flags
<span class="line-modified">!                     if (preferred == ALLOWED_HOUR_FORMAT_HB || preferred == ALLOWED_HOUR_FORMAT_hB) {</span>
                          dayPeriodChar = CAP_B;
<span class="line-modified">!                     } else if (preferred == ALLOWED_HOUR_FORMAT_Hb || preferred == ALLOWED_HOUR_FORMAT_hb) {</span>
                          dayPeriodChar = LOW_B;
                      }
                  }
                  if (hourChar==CAP_H || hourChar==LOW_K) {
                      dayPeriodLen = 0;
<span class="line-new-header">--- 1160,28 ---</span>
                  UChar hourChar = LOW_H;
                  UChar dayPeriodChar = LOW_A;
                  if (patChr == LOW_J) {
                      hourChar = fDefaultHourFormatChar;
                  } else {
<span class="line-modified">!                     AllowedHourFormat bestAllowed;</span>
                      if (fAllowedHourFormats[0] != ALLOWED_HOUR_FORMAT_UNKNOWN) {
<span class="line-modified">!                         bestAllowed = (AllowedHourFormat)fAllowedHourFormats[0];</span>
                      } else {
                          status = U_INVALID_FORMAT_ERROR;
                          return UnicodeString();
                      }
<span class="line-modified">!                     if (bestAllowed == ALLOWED_HOUR_FORMAT_H || bestAllowed == ALLOWED_HOUR_FORMAT_HB || bestAllowed == ALLOWED_HOUR_FORMAT_Hb) {</span>
                          hourChar = CAP_H;
<span class="line-added">+                     } else if (bestAllowed == ALLOWED_HOUR_FORMAT_K || bestAllowed == ALLOWED_HOUR_FORMAT_KB || bestAllowed == ALLOWED_HOUR_FORMAT_Kb) {</span>
<span class="line-added">+                         hourChar = CAP_K;</span>
<span class="line-added">+                     } else if (bestAllowed == ALLOWED_HOUR_FORMAT_k) {</span>
<span class="line-added">+                         hourChar = LOW_K;</span>
                      }
                      // in #13183 just add b/B to skeleton, no longer need to set special flags
<span class="line-modified">!                     if (bestAllowed == ALLOWED_HOUR_FORMAT_HB || bestAllowed == ALLOWED_HOUR_FORMAT_hB || bestAllowed == ALLOWED_HOUR_FORMAT_KB) {</span>
                          dayPeriodChar = CAP_B;
<span class="line-modified">!                     } else if (bestAllowed == ALLOWED_HOUR_FORMAT_Hb || bestAllowed == ALLOWED_HOUR_FORMAT_hb || bestAllowed == ALLOWED_HOUR_FORMAT_Kb) {</span>
                          dayPeriodChar = LOW_B;
                      }
                  }
                  if (hourChar==CAP_H || hourChar==LOW_K) {
                      dayPeriodLen = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1157,13 ***</span>
  
  UnicodeString
  DateTimePatternGenerator::replaceFieldTypes(const UnicodeString&amp; pattern,
                                              const UnicodeString&amp; skeleton,
                                              UDateTimePatternMatchOptions options,
<span class="line-modified">!                                             UErrorCode&amp; /*status*/) {</span>
      dtMatcher-&gt;set(skeleton, fp);
<span class="line-modified">!     UnicodeString result = adjustFieldTypes(pattern, NULL, kDTPGNoFlags, options);</span>
      return result;
  }
  
  void
  DateTimePatternGenerator::setDecimal(const UnicodeString&amp; newDecimal) {
<span class="line-new-header">--- 1214,20 ---</span>
  
  UnicodeString
  DateTimePatternGenerator::replaceFieldTypes(const UnicodeString&amp; pattern,
                                              const UnicodeString&amp; skeleton,
                                              UDateTimePatternMatchOptions options,
<span class="line-modified">!                                             UErrorCode&amp; status) {</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return UnicodeString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">+         status = internalErrorCode;</span>
<span class="line-added">+         return UnicodeString();</span>
<span class="line-added">+     }</span>
      dtMatcher-&gt;set(skeleton, fp);
<span class="line-modified">!     UnicodeString result = adjustFieldTypes(pattern, nullptr, kDTPGNoFlags, options);</span>
      return result;
  }
  
  void
  DateTimePatternGenerator::setDecimal(const UnicodeString&amp; newDecimal) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1202,24 ***</span>
      return dateTimeFormat;
  }
  
  void
  DateTimePatternGenerator::setDateTimeFromCalendar(const Locale&amp; locale, UErrorCode&amp; status) {
      const UChar *resStr;
      int32_t resStrLen = 0;
  
<span class="line-modified">!     Calendar* fCalendar = Calendar::createInstance(locale, status);</span>
      if (U_FAILURE(status)) { return; }
  
<span class="line-modified">!     LocalUResourceBundlePointer calData(ures_open(NULL, locale.getBaseName(), &amp;status));</span>
      ures_getByKey(calData.getAlias(), DT_DateTimeCalendarTag, calData.getAlias(), &amp;status);
  
      LocalUResourceBundlePointer dateTimePatterns;
<span class="line-modified">!     if (fCalendar != NULL &amp;&amp; fCalendar-&gt;getType() != NULL &amp;&amp; *fCalendar-&gt;getType() != &#39;\0&#39;</span>
              &amp;&amp; uprv_strcmp(fCalendar-&gt;getType(), DT_DateTimeGregorianTag) != 0) {
          dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), fCalendar-&gt;getType(),
<span class="line-modified">!                                                                 NULL, &amp;status));</span>
          ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,
                                    dateTimePatterns.getAlias(), &amp;status);
      }
  
      if (dateTimePatterns.isNull() || status == U_MISSING_RESOURCE_ERROR) {
<span class="line-new-header">--- 1266,28 ---</span>
      return dateTimeFormat;
  }
  
  void
  DateTimePatternGenerator::setDateTimeFromCalendar(const Locale&amp; locale, UErrorCode&amp; status) {
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">+ </span>
      const UChar *resStr;
      int32_t resStrLen = 0;
  
<span class="line-modified">!     LocalPointer&lt;Calendar&gt; fCalendar(Calendar::createInstance(locale, status), status);</span>
      if (U_FAILURE(status)) { return; }
  
<span class="line-modified">!     LocalUResourceBundlePointer calData(ures_open(nullptr, locale.getBaseName(), &amp;status));</span>
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
      ures_getByKey(calData.getAlias(), DT_DateTimeCalendarTag, calData.getAlias(), &amp;status);
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
  
      LocalUResourceBundlePointer dateTimePatterns;
<span class="line-modified">!     if (fCalendar-&gt;getType() != nullptr &amp;&amp; *fCalendar-&gt;getType() != &#39;\0&#39;</span>
              &amp;&amp; uprv_strcmp(fCalendar-&gt;getType(), DT_DateTimeGregorianTag) != 0) {
          dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), fCalendar-&gt;getType(),
<span class="line-modified">!                                                                 nullptr, &amp;status));</span>
          ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,
                                    dateTimePatterns.getAlias(), &amp;status);
      }
  
      if (dateTimePatterns.isNull() || status == U_MISSING_RESOURCE_ERROR) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1236,12 ***</span>
          status = U_INVALID_FORMAT_ERROR;
          return;
      }
      resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), (int32_t)DateFormat::kDateTime, &amp;resStrLen, &amp;status);
      setDateTimeFormat(UnicodeString(TRUE, resStr, resStrLen));
<span class="line-removed">- </span>
<span class="line-removed">-     delete fCalendar;</span>
  }
  
  void
  DateTimePatternGenerator::setDecimalSymbols(const Locale&amp; locale, UErrorCode&amp; status) {
      DecimalFormatSymbols dfs = DecimalFormatSymbols(locale, status);
<span class="line-new-header">--- 1304,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1257,11 ***</span>
      const UnicodeString&amp; pattern,
      UBool override,
      UnicodeString &amp;conflictingPattern,
      UErrorCode&amp; status)
  {
<span class="line-modified">!     return addPatternWithSkeleton(pattern, NULL, override, conflictingPattern, status);</span>
  }
  
  // For DateTimePatternGenerator::addPatternWithSkeleton -
  // If skeletonToUse is specified, then an availableFormats entry is being added. In this case:
  // 1. We pass that skeleton to matcher.set instead of having it derive a skeleton from the pattern.
<span class="line-new-header">--- 1323,16 ---</span>
      const UnicodeString&amp; pattern,
      UBool override,
      UnicodeString &amp;conflictingPattern,
      UErrorCode&amp; status)
  {
<span class="line-modified">!     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">+         status = internalErrorCode;</span>
<span class="line-added">+         return UDATPG_NO_CONFLICT;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return addPatternWithSkeleton(pattern, nullptr, override, conflictingPattern, status);</span>
  }
  
  // For DateTimePatternGenerator::addPatternWithSkeleton -
  // If skeletonToUse is specified, then an availableFormats entry is being added. In this case:
  // 1. We pass that skeleton to matcher.set instead of having it derive a skeleton from the pattern.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1278,17 ***</span>
      const UnicodeString* skeletonToUse,
      UBool override,
      UnicodeString&amp; conflictingPattern,
      UErrorCode&amp; status)
  {
  
      UnicodeString basePattern;
      PtnSkeleton   skeleton;
      UDateTimePatternConflict conflictingStatus = UDATPG_NO_CONFLICT;
  
      DateTimeMatcher matcher;
<span class="line-modified">!     if ( skeletonToUse == NULL ) {</span>
          matcher.set(pattern, fp, skeleton);
          matcher.getBasePattern(basePattern);
      } else {
          matcher.set(*skeletonToUse, fp, skeleton); // no longer trims skeleton fields to max len 3, per #7930
          matcher.getBasePattern(basePattern); // or perhaps instead: basePattern = *skeletonToUse;
<span class="line-new-header">--- 1349,21 ---</span>
      const UnicodeString* skeletonToUse,
      UBool override,
      UnicodeString&amp; conflictingPattern,
      UErrorCode&amp; status)
  {
<span class="line-added">+     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">+         status = internalErrorCode;</span>
<span class="line-added">+         return UDATPG_NO_CONFLICT;</span>
<span class="line-added">+     }</span>
  
      UnicodeString basePattern;
      PtnSkeleton   skeleton;
      UDateTimePatternConflict conflictingStatus = UDATPG_NO_CONFLICT;
  
      DateTimeMatcher matcher;
<span class="line-modified">!     if ( skeletonToUse == nullptr ) {</span>
          matcher.set(pattern, fp, skeleton);
          matcher.getBasePattern(basePattern);
      } else {
          matcher.set(*skeletonToUse, fp, skeleton); // no longer trims skeleton fields to max len 3, per #7930
          matcher.getBasePattern(basePattern); // or perhaps instead: basePattern = *skeletonToUse;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1300,31 ***</span>
      // if we are getting here from a subsequent call to addPattern).
      // 2. a skeleton is specified for the current pattern, but override=false; in that case we are checking
      // availableFormats items from root, which should not override any previous entry with the same base.
      UBool entryHadSpecifiedSkeleton;
      const UnicodeString *duplicatePattern = patternMap-&gt;getPatternFromBasePattern(basePattern, entryHadSpecifiedSkeleton);
<span class="line-modified">!     if (duplicatePattern != NULL &amp;&amp; (!entryHadSpecifiedSkeleton || (skeletonToUse != NULL &amp;&amp; !override))) {</span>
          conflictingStatus = UDATPG_BASE_CONFLICT;
          conflictingPattern = *duplicatePattern;
          if (!override) {
              return conflictingStatus;
          }
      }
      // The only time we get here with override=true and skeletonToUse!=null is when adding availableFormats
      // items from CLDR data. In that case, we don&#39;t want an item from a parent locale to replace an item with
      // same skeleton from the specified locale, so skip the current item if skeletonWasSpecified is true for
      // the previously-specified conflicting item.
<span class="line-modified">!     const PtnSkeleton* entrySpecifiedSkeleton = NULL;</span>
      duplicatePattern = patternMap-&gt;getPatternFromSkeleton(skeleton, &amp;entrySpecifiedSkeleton);
<span class="line-modified">!     if (duplicatePattern != NULL ) {</span>
          conflictingStatus = UDATPG_CONFLICT;
          conflictingPattern = *duplicatePattern;
<span class="line-modified">!         if (!override || (skeletonToUse != NULL &amp;&amp; entrySpecifiedSkeleton != NULL)) {</span>
              return conflictingStatus;
          }
      }
<span class="line-modified">!     patternMap-&gt;add(basePattern, skeleton, pattern, skeletonToUse != NULL, status);</span>
      if(U_FAILURE(status)) {
          return conflictingStatus;
      }
  
      return UDATPG_NO_CONFLICT;
<span class="line-new-header">--- 1375,31 ---</span>
      // if we are getting here from a subsequent call to addPattern).
      // 2. a skeleton is specified for the current pattern, but override=false; in that case we are checking
      // availableFormats items from root, which should not override any previous entry with the same base.
      UBool entryHadSpecifiedSkeleton;
      const UnicodeString *duplicatePattern = patternMap-&gt;getPatternFromBasePattern(basePattern, entryHadSpecifiedSkeleton);
<span class="line-modified">!     if (duplicatePattern != nullptr &amp;&amp; (!entryHadSpecifiedSkeleton || (skeletonToUse != nullptr &amp;&amp; !override))) {</span>
          conflictingStatus = UDATPG_BASE_CONFLICT;
          conflictingPattern = *duplicatePattern;
          if (!override) {
              return conflictingStatus;
          }
      }
      // The only time we get here with override=true and skeletonToUse!=null is when adding availableFormats
      // items from CLDR data. In that case, we don&#39;t want an item from a parent locale to replace an item with
      // same skeleton from the specified locale, so skip the current item if skeletonWasSpecified is true for
      // the previously-specified conflicting item.
<span class="line-modified">!     const PtnSkeleton* entrySpecifiedSkeleton = nullptr;</span>
      duplicatePattern = patternMap-&gt;getPatternFromSkeleton(skeleton, &amp;entrySpecifiedSkeleton);
<span class="line-modified">!     if (duplicatePattern != nullptr ) {</span>
          conflictingStatus = UDATPG_CONFLICT;
          conflictingPattern = *duplicatePattern;
<span class="line-modified">!         if (!override || (skeletonToUse != nullptr &amp;&amp; entrySpecifiedSkeleton != nullptr)) {</span>
              return conflictingStatus;
          }
      }
<span class="line-modified">!     patternMap-&gt;add(basePattern, skeleton, pattern, skeletonToUse != nullptr, status);</span>
      if(U_FAILURE(status)) {
          return conflictingStatus;
      }
  
      return UDATPG_NO_CONFLICT;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1367,17 ***</span>
  
  const UnicodeString*
  DateTimePatternGenerator::getBestRaw(DateTimeMatcher&amp; source,
                                       int32_t includeMask,
                                       DistanceInfo* missingFields,
                                       const PtnSkeleton** specifiedSkeletonPtr) {
      int32_t bestDistance = 0x7fffffff;
      DistanceInfo tempInfo;
<span class="line-modified">!     const UnicodeString *bestPattern=NULL;</span>
<span class="line-modified">!     const PtnSkeleton* specifiedSkeleton=NULL;</span>
  
<span class="line-removed">-     PatternMapIterator it;</span>
      for (it.set(*patternMap); it.hasNext(); ) {
          DateTimeMatcher trial = it.next();
          if (trial.equals(skipMatcher)) {
              continue;
          }
<span class="line-new-header">--- 1442,20 ---</span>
  
  const UnicodeString*
  DateTimePatternGenerator::getBestRaw(DateTimeMatcher&amp; source,
                                       int32_t includeMask,
                                       DistanceInfo* missingFields,
<span class="line-added">+                                      UErrorCode &amp;status,</span>
                                       const PtnSkeleton** specifiedSkeletonPtr) {
      int32_t bestDistance = 0x7fffffff;
      DistanceInfo tempInfo;
<span class="line-modified">!     const UnicodeString *bestPattern=nullptr;</span>
<span class="line-modified">!     const PtnSkeleton* specifiedSkeleton=nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     PatternMapIterator it(status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { return nullptr; }</span>
  
      for (it.set(*patternMap); it.hasNext(); ) {
          DateTimeMatcher trial = it.next();
          if (trial.equals(skipMatcher)) {
              continue;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1483,29 ***</span>
                              : field.charAt(0);
                      if (typeValue == UDATPG_HOUR_FIELD &amp;&amp; (flags &amp; kDTPGSkeletonUsesCapJ) != 0) {
                          c = fDefaultHourFormatChar;
                      }
                      field.remove();
<span class="line-modified">!                     for (int32_t i=adjFieldLen; i&gt;0; --i) {</span>
<span class="line-modified">!                         field+=c;</span>
                      }
              }
              newPattern+=field;
          }
      }
      return newPattern;
  }
  
  UnicodeString
<span class="line-modified">! DateTimePatternGenerator::getBestAppending(int32_t missingFields, int32_t flags, UDateTimePatternMatchOptions options) {</span>
      UnicodeString  resultPattern, tempPattern;
<span class="line-modified">!     UErrorCode err=U_ZERO_ERROR;</span>
      int32_t lastMissingFieldMask=0;
      if (missingFields!=0) {
          resultPattern=UnicodeString();
<span class="line-modified">!         const PtnSkeleton* specifiedSkeleton=NULL;</span>
<span class="line-modified">!         tempPattern = *getBestRaw(*dtMatcher, missingFields, distanceInfo, &amp;specifiedSkeleton);</span>
          resultPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);
          if ( distanceInfo-&gt;missingFieldMask==0 ) {
              return resultPattern;
          }
          while (distanceInfo-&gt;missingFieldMask!=0) { // precondition: EVERY single field must work!
<span class="line-new-header">--- 1561,36 ---</span>
                              : field.charAt(0);
                      if (typeValue == UDATPG_HOUR_FIELD &amp;&amp; (flags &amp; kDTPGSkeletonUsesCapJ) != 0) {
                          c = fDefaultHourFormatChar;
                      }
                      field.remove();
<span class="line-modified">!                     for (int32_t j=adjFieldLen; j&gt;0; --j) {</span>
<span class="line-modified">!                         field += c;</span>
                      }
              }
              newPattern+=field;
          }
      }
      return newPattern;
  }
  
  UnicodeString
<span class="line-modified">! DateTimePatternGenerator::getBestAppending(int32_t missingFields, int32_t flags, UErrorCode &amp;status, UDateTimePatternMatchOptions options) {</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return UnicodeString();</span>
<span class="line-added">+     }</span>
      UnicodeString  resultPattern, tempPattern;
<span class="line-modified">!     const UnicodeString* tempPatternPtr;</span>
      int32_t lastMissingFieldMask=0;
      if (missingFields!=0) {
          resultPattern=UnicodeString();
<span class="line-modified">!         const PtnSkeleton* specifiedSkeleton=nullptr;</span>
<span class="line-modified">!         tempPatternPtr = getBestRaw(*dtMatcher, missingFields, distanceInfo, status, &amp;specifiedSkeleton);</span>
<span class="line-added">+         if (U_FAILURE(status)) {</span>
<span class="line-added">+             return UnicodeString();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         tempPattern = *tempPatternPtr;</span>
          resultPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);
          if ( distanceInfo-&gt;missingFieldMask==0 ) {
              return resultPattern;
          }
          while (distanceInfo-&gt;missingFieldMask!=0) { // precondition: EVERY single field must work!
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1517,31 ***</span>
                  resultPattern = adjustFieldTypes(resultPattern, specifiedSkeleton, flags | kDTPGFixFractionalSeconds, options);
                  distanceInfo-&gt;missingFieldMask &amp;= ~UDATPG_FRACTIONAL_MASK;
                  continue;
              }
              int32_t startingMask = distanceInfo-&gt;missingFieldMask;
<span class="line-modified">!             tempPattern = *getBestRaw(*dtMatcher, distanceInfo-&gt;missingFieldMask, distanceInfo, &amp;specifiedSkeleton);</span>
              tempPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);
              int32_t foundMask=startingMask&amp; ~distanceInfo-&gt;missingFieldMask;
              int32_t topField=getTopBitNumber(foundMask);
<span class="line-modified">!             UnicodeString appendName;</span>
<span class="line-modified">!             getAppendName((UDateTimePatternField)topField, appendName);</span>
<span class="line-modified">!             const UnicodeString *values[3] = {</span>
<span class="line-modified">!                 &amp;resultPattern,</span>
<span class="line-modified">!                 &amp;tempPattern,</span>
<span class="line-modified">!                 &amp;appendName</span>
<span class="line-modified">!             };</span>
<span class="line-modified">!             SimpleFormatter(appendItemFormats[topField], 2, 3, err).</span>
<span class="line-modified">!                     formatAndReplace(values, 3, resultPattern, NULL, 0, err);</span>
              lastMissingFieldMask = distanceInfo-&gt;missingFieldMask;
          }
      }
      return resultPattern;
  }
  
  int32_t
<span class="line-modified">! DateTimePatternGenerator::getTopBitNumber(int32_t foundMask) {</span>
      if ( foundMask==0 ) {
          return 0;
      }
      int32_t i=0;
      while (foundMask!=0) {
<span class="line-new-header">--- 1602,38 ---</span>
                  resultPattern = adjustFieldTypes(resultPattern, specifiedSkeleton, flags | kDTPGFixFractionalSeconds, options);
                  distanceInfo-&gt;missingFieldMask &amp;= ~UDATPG_FRACTIONAL_MASK;
                  continue;
              }
              int32_t startingMask = distanceInfo-&gt;missingFieldMask;
<span class="line-modified">!             tempPatternPtr = getBestRaw(*dtMatcher, distanceInfo-&gt;missingFieldMask, distanceInfo, status, &amp;specifiedSkeleton);</span>
<span class="line-added">+             if (U_FAILURE(status)) {</span>
<span class="line-added">+                 return UnicodeString();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             tempPattern = *tempPatternPtr;</span>
              tempPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);
              int32_t foundMask=startingMask&amp; ~distanceInfo-&gt;missingFieldMask;
              int32_t topField=getTopBitNumber(foundMask);
<span class="line-modified">! </span>
<span class="line-modified">!             if (appendItemFormats[topField].length() != 0) {</span>
<span class="line-modified">!                 UnicodeString appendName;</span>
<span class="line-modified">!                 getAppendName((UDateTimePatternField)topField, appendName);</span>
<span class="line-modified">!                 const UnicodeString *values[3] = {</span>
<span class="line-modified">!                     &amp;resultPattern,</span>
<span class="line-modified">!                     &amp;tempPattern,</span>
<span class="line-modified">!                     &amp;appendName</span>
<span class="line-modified">!                 };</span>
<span class="line-added">+                 SimpleFormatter(appendItemFormats[topField], 2, 3, status).</span>
<span class="line-added">+                     formatAndReplace(values, 3, resultPattern, nullptr, 0, status);</span>
<span class="line-added">+             }</span>
              lastMissingFieldMask = distanceInfo-&gt;missingFieldMask;
          }
      }
      return resultPattern;
  }
  
  int32_t
<span class="line-modified">! DateTimePatternGenerator::getTopBitNumber(int32_t foundMask) const {</span>
      if ( foundMask==0 ) {
          return 0;
      }
      int32_t i=0;
      while (foundMask!=0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1566,26 ***</span>
      return (UBool)(fAvailableFormatKeyHash-&gt;geti(key) == 1);
  }
  
  void
  DateTimePatternGenerator::copyHashtable(Hashtable *other, UErrorCode &amp;status) {
<span class="line-modified">! </span>
<span class="line-removed">-     if (other == NULL) {</span>
          return;
      }
<span class="line-modified">!     if (fAvailableFormatKeyHash != NULL) {</span>
          delete fAvailableFormatKeyHash;
<span class="line-modified">!         fAvailableFormatKeyHash = NULL;</span>
      }
      initHashtable(status);
      if(U_FAILURE(status)){
          return;
      }
      int32_t pos = UHASH_FIRST;
<span class="line-modified">!     const UHashElement* elem = NULL;</span>
      // walk through the hash table and create a deep clone
<span class="line-modified">!     while((elem = other-&gt;nextElement(pos))!= NULL){</span>
          const UHashTok otherKeyTok = elem-&gt;key;
          UnicodeString* otherKey = (UnicodeString*)otherKeyTok.pointer;
          fAvailableFormatKeyHash-&gt;puti(*otherKey, 1, status);
          if(U_FAILURE(status)){
              return;
<span class="line-new-header">--- 1658,25 ---</span>
      return (UBool)(fAvailableFormatKeyHash-&gt;geti(key) == 1);
  }
  
  void
  DateTimePatternGenerator::copyHashtable(Hashtable *other, UErrorCode &amp;status) {
<span class="line-modified">!     if (other == nullptr || U_FAILURE(status)) {</span>
          return;
      }
<span class="line-modified">!     if (fAvailableFormatKeyHash != nullptr) {</span>
          delete fAvailableFormatKeyHash;
<span class="line-modified">!         fAvailableFormatKeyHash = nullptr;</span>
      }
      initHashtable(status);
      if(U_FAILURE(status)){
          return;
      }
      int32_t pos = UHASH_FIRST;
<span class="line-modified">!     const UHashElement* elem = nullptr;</span>
      // walk through the hash table and create a deep clone
<span class="line-modified">!     while((elem = other-&gt;nextElement(pos))!= nullptr){</span>
          const UHashTok otherKeyTok = elem-&gt;key;
          UnicodeString* otherKey = (UnicodeString*)otherKeyTok.pointer;
          fAvailableFormatKeyHash-&gt;puti(*otherKey, 1, status);
          if(U_FAILURE(status)){
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1593,63 ***</span>
      }
  }
  
  StringEnumeration*
  DateTimePatternGenerator::getSkeletons(UErrorCode&amp; status) const {
<span class="line-modified">!     StringEnumeration* skeletonEnumerator = new DTSkeletonEnumeration(*patternMap, DT_SKELETON, status);</span>
<span class="line-modified">!     return skeletonEnumerator;</span>
  }
  
  const UnicodeString&amp;
  DateTimePatternGenerator::getPatternForSkeleton(const UnicodeString&amp; skeleton) const {
      PtnElem *curElem;
  
      if (skeleton.length() ==0) {
          return emptyString;
      }
      curElem = patternMap-&gt;getHeader(skeleton.charAt(0));
<span class="line-modified">!     while ( curElem != NULL ) {</span>
          if ( curElem-&gt;skeleton-&gt;getSkeleton()==skeleton ) {
              return curElem-&gt;pattern;
          }
<span class="line-modified">!         curElem=curElem-&gt;next;</span>
      }
      return emptyString;
  }
  
  StringEnumeration*
  DateTimePatternGenerator::getBaseSkeletons(UErrorCode&amp; status) const {
<span class="line-modified">!     StringEnumeration* baseSkeletonEnumerator = new DTSkeletonEnumeration(*patternMap, DT_BASESKELETON, status);</span>
<span class="line-modified">!     return baseSkeletonEnumerator;</span>
  }
  
  StringEnumeration*
  DateTimePatternGenerator::getRedundants(UErrorCode&amp; status) {
<span class="line-modified">!     StringEnumeration* output = new DTRedundantEnumeration();</span>
      const UnicodeString *pattern;
<span class="line-modified">!     PatternMapIterator it;</span>
      for (it.set(*patternMap); it.hasNext(); ) {
          DateTimeMatcher current = it.next();
          pattern = patternMap-&gt;getPatternFromSkeleton(*(it.getSkeleton()));
          if ( isCanonicalItem(*pattern) ) {
              continue;
          }
<span class="line-modified">!         if ( skipMatcher == NULL ) {</span>
              skipMatcher = new DateTimeMatcher(current);
          }
          else {
              *skipMatcher = current;
          }
          UnicodeString trial = getBestPattern(current.getPattern(), status);
          if (trial == *pattern) {
<span class="line-modified">!             ((DTRedundantEnumeration *)output)-&gt;add(*pattern, status);</span>
          }
          if (current.equals(skipMatcher)) {
              continue;
          }
      }
<span class="line-modified">!     return output;</span>
  }
  
  UBool
  DateTimePatternGenerator::isCanonicalItem(const UnicodeString&amp; item) const {
      if ( item.length() != 1 ) {
<span class="line-new-header">--- 1684,95 ---</span>
      }
  }
  
  StringEnumeration*
  DateTimePatternGenerator::getSkeletons(UErrorCode&amp; status) const {
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">+         status = internalErrorCode;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     LocalPointer&lt;StringEnumeration&gt; skeletonEnumerator(</span>
<span class="line-added">+         new DTSkeletonEnumeration(*patternMap, DT_SKELETON, status), status);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return U_SUCCESS(status) ? skeletonEnumerator.orphan() : nullptr;</span>
  }
  
  const UnicodeString&amp;
  DateTimePatternGenerator::getPatternForSkeleton(const UnicodeString&amp; skeleton) const {
      PtnElem *curElem;
  
      if (skeleton.length() ==0) {
          return emptyString;
      }
      curElem = patternMap-&gt;getHeader(skeleton.charAt(0));
<span class="line-modified">!     while ( curElem != nullptr ) {</span>
          if ( curElem-&gt;skeleton-&gt;getSkeleton()==skeleton ) {
              return curElem-&gt;pattern;
          }
<span class="line-modified">!         curElem = curElem-&gt;next.getAlias();</span>
      }
      return emptyString;
  }
  
  StringEnumeration*
  DateTimePatternGenerator::getBaseSkeletons(UErrorCode&amp; status) const {
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">+         status = internalErrorCode;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     LocalPointer&lt;StringEnumeration&gt; baseSkeletonEnumerator(</span>
<span class="line-added">+         new DTSkeletonEnumeration(*patternMap, DT_BASESKELETON, status), status);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return U_SUCCESS(status) ? baseSkeletonEnumerator.orphan() : nullptr;</span>
  }
  
  StringEnumeration*
  DateTimePatternGenerator::getRedundants(UErrorCode&amp; status) {
<span class="line-modified">!     if (U_FAILURE(status)) { return nullptr; }</span>
<span class="line-added">+     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">+         status = internalErrorCode;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     LocalPointer&lt;StringEnumeration&gt; output(new DTRedundantEnumeration(), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { return nullptr; }</span>
      const UnicodeString *pattern;
<span class="line-modified">!     PatternMapIterator it(status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { return nullptr; }</span>
<span class="line-added">+ </span>
      for (it.set(*patternMap); it.hasNext(); ) {
          DateTimeMatcher current = it.next();
          pattern = patternMap-&gt;getPatternFromSkeleton(*(it.getSkeleton()));
          if ( isCanonicalItem(*pattern) ) {
              continue;
          }
<span class="line-modified">!         if ( skipMatcher == nullptr ) {</span>
              skipMatcher = new DateTimeMatcher(current);
<span class="line-added">+             if (skipMatcher == nullptr) {</span>
<span class="line-added">+                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+             }</span>
          }
          else {
              *skipMatcher = current;
          }
          UnicodeString trial = getBestPattern(current.getPattern(), status);
<span class="line-added">+         if (U_FAILURE(status)) { return nullptr; }</span>
          if (trial == *pattern) {
<span class="line-modified">!             ((DTRedundantEnumeration *)output.getAlias())-&gt;add(*pattern, status);</span>
<span class="line-added">+             if (U_FAILURE(status)) { return nullptr; }</span>
          }
          if (current.equals(skipMatcher)) {
              continue;
          }
      }
<span class="line-modified">!     return output.orphan();</span>
  }
  
  UBool
  DateTimePatternGenerator::isCanonicalItem(const UnicodeString&amp; item) const {
      if ( item.length() != 1 ) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1669,70 ***</span>
      return new DateTimePatternGenerator(*this);
  }
  
  PatternMap::PatternMap() {
     for (int32_t i=0; i &lt; MAX_PATTERN_ENTRIES; ++i ) {
<span class="line-modified">!       boot[i]=NULL;</span>
     }
     isDupAllowed = TRUE;
  }
  
  void
  PatternMap::copyFrom(const PatternMap&amp; other, UErrorCode&amp; status) {
      this-&gt;isDupAllowed = other.isDupAllowed;
<span class="line-modified">!     for (int32_t bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {</span>
<span class="line-modified">!         PtnElem *curElem, *otherElem, *prevElem=NULL;</span>
          otherElem = other.boot[bootIndex];
<span class="line-modified">!         while (otherElem!=NULL) {</span>
<span class="line-modified">!             if ((curElem = new PtnElem(otherElem-&gt;basePattern, otherElem-&gt;pattern))==NULL) {</span>
<span class="line-modified">!                 // out of memory</span>
<span class="line-modified">!                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">-                 return;</span>
              }
<span class="line-modified">!             if ( this-&gt;boot[bootIndex]== NULL ) {</span>
<span class="line-modified">!                 this-&gt;boot[bootIndex] = curElem;</span>
              }
<span class="line-modified">!             if ((curElem-&gt;skeleton=new PtnSkeleton(*(otherElem-&gt;skeleton))) == NULL ) {</span>
<span class="line-modified">!                 // out of memory</span>
<span class="line-modified">!                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             curElem-&gt;skeletonWasSpecified = otherElem-&gt;skeletonWasSpecified;</span>
<span class="line-modified">!             if (prevElem!=NULL) {</span>
<span class="line-modified">!                 prevElem-&gt;next=curElem;</span>
              }
<span class="line-removed">-             curElem-&gt;next=NULL;</span>
              prevElem = curElem;
<span class="line-modified">!             otherElem = otherElem-&gt;next;</span>
          }
  
      }
  }
  
  PtnElem*
<span class="line-modified">! PatternMap::getHeader(UChar baseChar) {</span>
      PtnElem* curElem;
  
      if ( (baseChar &gt;= CAP_A) &amp;&amp; (baseChar &lt;= CAP_Z) ) {
           curElem = boot[baseChar-CAP_A];
      }
      else {
          if ( (baseChar &gt;=LOW_A) &amp;&amp; (baseChar &lt;= LOW_Z) ) {
              curElem = boot[26+baseChar-LOW_A];
          }
          else {
<span class="line-modified">!             return NULL;</span>
          }
      }
      return curElem;
  }
  
  PatternMap::~PatternMap() {
     for (int32_t i=0; i &lt; MAX_PATTERN_ENTRIES; ++i ) {
<span class="line-modified">!        if (boot[i]!=NULL ) {</span>
             delete boot[i];
<span class="line-modified">!            boot[i]=NULL;</span>
         }
     }
  }  // PatternMap destructor
  
  void
<span class="line-new-header">--- 1792,79 ---</span>
      return new DateTimePatternGenerator(*this);
  }
  
  PatternMap::PatternMap() {
     for (int32_t i=0; i &lt; MAX_PATTERN_ENTRIES; ++i ) {
<span class="line-modified">!        boot[i] = nullptr;</span>
     }
     isDupAllowed = TRUE;
  }
  
  void
  PatternMap::copyFrom(const PatternMap&amp; other, UErrorCode&amp; status) {
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      this-&gt;isDupAllowed = other.isDupAllowed;
<span class="line-modified">!     for (int32_t bootIndex = 0; bootIndex &lt; MAX_PATTERN_ENTRIES; ++bootIndex) {</span>
<span class="line-modified">!         PtnElem *curElem, *otherElem, *prevElem=nullptr;</span>
          otherElem = other.boot[bootIndex];
<span class="line-modified">!         while (otherElem != nullptr) {</span>
<span class="line-modified">!             LocalPointer&lt;PtnElem&gt; newElem(new PtnElem(otherElem-&gt;basePattern, otherElem-&gt;pattern), status);</span>
<span class="line-modified">!             if (U_FAILURE(status)) {</span>
<span class="line-modified">!                 return; // out of memory</span>
              }
<span class="line-modified">!             newElem-&gt;skeleton.adoptInsteadAndCheckErrorCode(new PtnSkeleton(*(otherElem-&gt;skeleton)), status);</span>
<span class="line-modified">!             if (U_FAILURE(status)) {</span>
<span class="line-added">+                 return; // out of memory</span>
              }
<span class="line-modified">!             newElem-&gt;skeletonWasSpecified = otherElem-&gt;skeletonWasSpecified;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // Release ownership from the LocalPointer of the PtnElem object.</span>
<span class="line-modified">!             // The PtnElem will now be owned by either the boot (for the first entry in the linked-list)</span>
<span class="line-modified">!             // or owned by the previous PtnElem object in the linked-list.</span>
<span class="line-modified">!             curElem = newElem.orphan();</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (this-&gt;boot[bootIndex] == nullptr) {</span>
<span class="line-added">+                 this-&gt;boot[bootIndex] = curElem;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 if (prevElem != nullptr) {</span>
<span class="line-added">+                     prevElem-&gt;next.adoptInstead(curElem);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     UPRV_UNREACHABLE;</span>
<span class="line-added">+                 }</span>
              }
              prevElem = curElem;
<span class="line-modified">!             otherElem = otherElem-&gt;next.getAlias();</span>
          }
  
      }
  }
  
  PtnElem*
<span class="line-modified">! PatternMap::getHeader(UChar baseChar) const {</span>
      PtnElem* curElem;
  
      if ( (baseChar &gt;= CAP_A) &amp;&amp; (baseChar &lt;= CAP_Z) ) {
           curElem = boot[baseChar-CAP_A];
      }
      else {
          if ( (baseChar &gt;=LOW_A) &amp;&amp; (baseChar &lt;= LOW_Z) ) {
              curElem = boot[26+baseChar-LOW_A];
          }
          else {
<span class="line-modified">!             return nullptr;</span>
          }
      }
      return curElem;
  }
  
  PatternMap::~PatternMap() {
     for (int32_t i=0; i &lt; MAX_PATTERN_ENTRIES; ++i ) {
<span class="line-modified">!        if (boot[i] != nullptr ) {</span>
             delete boot[i];
<span class="line-modified">!            boot[i] = nullptr;</span>
         }
     }
  }  // PatternMap destructor
  
  void
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1757,43 ***</span>
               status = U_ILLEGAL_CHARACTER;
               return;
           }
      }
  
<span class="line-modified">!     if (baseElem == NULL) {</span>
<span class="line-modified">!         if ((curElem = new PtnElem(basePattern, value)) == NULL ) {</span>
<span class="line-modified">!             // out of memory</span>
<span class="line-modified">!             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">!             return;</span>
          }
          if (baseChar &gt;= LOW_A) {
<span class="line-modified">!             boot[26 + (baseChar-LOW_A)] = curElem;</span>
          }
          else {
<span class="line-modified">!             boot[baseChar-CAP_A] = curElem;</span>
          }
<span class="line-removed">-         curElem-&gt;skeleton = new PtnSkeleton(skeleton);</span>
<span class="line-removed">-         curElem-&gt;skeletonWasSpecified = skeletonWasSpecified;</span>
      }
<span class="line-modified">!     if ( baseElem != NULL ) {</span>
          curElem = getDuplicateElem(basePattern, skeleton, baseElem);
  
<span class="line-modified">!         if (curElem == NULL) {</span>
              // add new element to the list.
              curElem = baseElem;
<span class="line-modified">!             while( curElem -&gt; next != NULL )</span>
              {
<span class="line-modified">!                 curElem = curElem-&gt;next;</span>
              }
<span class="line-modified">!             if ((curElem-&gt;next = new PtnElem(basePattern, value)) == NULL ) {</span>
<span class="line-modified">!                 // out of memory</span>
<span class="line-modified">!                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">!                 return;</span>
              }
<span class="line-modified">!             curElem=curElem-&gt;next;</span>
<span class="line-modified">!             curElem-&gt;skeleton = new PtnSkeleton(skeleton);</span>
<span class="line-modified">!             curElem-&gt;skeletonWasSpecified = skeletonWasSpecified;</span>
          }
          else {
              // Pattern exists in the list already.
              if ( !isDupAllowed ) {
                  return;
<span class="line-new-header">--- 1889,49 ---</span>
               status = U_ILLEGAL_CHARACTER;
               return;
           }
      }
  
<span class="line-modified">!     if (baseElem == nullptr) {</span>
<span class="line-modified">!         LocalPointer&lt;PtnElem&gt; newElem(new PtnElem(basePattern, value), status);</span>
<span class="line-modified">!         if (U_FAILURE(status)) {</span>
<span class="line-modified">!             return; // out of memory</span>
<span class="line-modified">!         }</span>
<span class="line-added">+         newElem-&gt;skeleton.adoptInsteadAndCheckErrorCode(new PtnSkeleton(skeleton), status);</span>
<span class="line-added">+         if (U_FAILURE(status)) {</span>
<span class="line-added">+             return; // out of memory</span>
          }
<span class="line-added">+         newElem-&gt;skeletonWasSpecified = skeletonWasSpecified;</span>
          if (baseChar &gt;= LOW_A) {
<span class="line-modified">!             boot[26 + (baseChar - LOW_A)] = newElem.orphan(); // the boot array now owns the PtnElem.</span>
          }
          else {
<span class="line-modified">!             boot[baseChar - CAP_A] = newElem.orphan(); // the boot array now owns the PtnElem.</span>
          }
      }
<span class="line-modified">!     if ( baseElem != nullptr ) {</span>
          curElem = getDuplicateElem(basePattern, skeleton, baseElem);
  
<span class="line-modified">!         if (curElem == nullptr) {</span>
              // add new element to the list.
              curElem = baseElem;
<span class="line-modified">!             while( curElem -&gt; next != nullptr )</span>
              {
<span class="line-modified">!                 curElem = curElem-&gt;next.getAlias();</span>
              }
<span class="line-modified">! </span>
<span class="line-modified">!             LocalPointer&lt;PtnElem&gt; newElem(new PtnElem(basePattern, value), status);</span>
<span class="line-modified">!             if (U_FAILURE(status)) {</span>
<span class="line-modified">!                 return; // out of memory</span>
              }
<span class="line-modified">!             newElem-&gt;skeleton.adoptInsteadAndCheckErrorCode(new PtnSkeleton(skeleton), status);</span>
<span class="line-modified">!             if (U_FAILURE(status)) {</span>
<span class="line-modified">!                 return; // out of memory</span>
<span class="line-added">+             }</span>
<span class="line-added">+             newElem-&gt;skeletonWasSpecified = skeletonWasSpecified;</span>
<span class="line-added">+             curElem-&gt;next.adoptInstead(newElem.orphan());</span>
<span class="line-added">+             curElem = curElem-&gt;next.getAlias();</span>
          }
          else {
              // Pattern exists in the list already.
              if ( !isDupAllowed ) {
                  return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1807,99 ***</span>
      }
  }  // PatternMap::add
  
  // Find the pattern from the given basePattern string.
  const UnicodeString *
<span class="line-modified">! PatternMap::getPatternFromBasePattern(UnicodeString&amp; basePattern, UBool&amp; skeletonWasSpecified) { // key to search for</span>
     PtnElem *curElem;
  
<span class="line-modified">!    if ((curElem=getHeader(basePattern.charAt(0)))==NULL) {</span>
<span class="line-modified">!        return NULL;  // no match</span>
     }
  
     do  {
         if ( basePattern.compare(curElem-&gt;basePattern)==0 ) {
            skeletonWasSpecified = curElem-&gt;skeletonWasSpecified;
            return &amp;(curElem-&gt;pattern);
         }
<span class="line-modified">!        curElem=curElem-&gt;next;</span>
<span class="line-modified">!    }while (curElem != NULL);</span>
  
<span class="line-modified">!    return NULL;</span>
  }  // PatternMap::getFromBasePattern
  
  
  // Find the pattern from the given skeleton.
  // At least when this is called from getBestRaw &amp; addPattern (in which case specifiedSkeletonPtr is non-NULL),
  // the comparison should be based on skeleton.original (which is unique and tied to the distance measurement in bestRaw)
  // and not skeleton.baseOriginal (which is not unique); otherwise we may pick a different skeleton than the one with the
  // optimum distance value in getBestRaw. When this is called from public getRedundants (specifiedSkeletonPtr is NULL),
  // for now it will continue to compare based on baseOriginal so as not to change the behavior unnecessarily.
  const UnicodeString *
<span class="line-modified">! PatternMap::getPatternFromSkeleton(PtnSkeleton&amp; skeleton, const PtnSkeleton** specifiedSkeletonPtr) { // key to search for</span>
     PtnElem *curElem;
  
     if (specifiedSkeletonPtr) {
<span class="line-modified">!        *specifiedSkeletonPtr = NULL;</span>
     }
  
     // find boot entry
     UChar baseChar = skeleton.getFirstChar();
<span class="line-modified">!    if ((curElem=getHeader(baseChar))==NULL) {</span>
<span class="line-modified">!        return NULL;  // no match</span>
     }
  
     do  {
         UBool equal;
<span class="line-modified">!        if (specifiedSkeletonPtr != NULL) { // called from DateTimePatternGenerator::getBestRaw or addPattern, use original</span>
             equal = curElem-&gt;skeleton-&gt;original == skeleton.original;
         } else { // called from DateTimePatternGenerator::getRedundants, use baseOriginal
             equal = curElem-&gt;skeleton-&gt;baseOriginal == skeleton.baseOriginal;
         }
         if (equal) {
             if (specifiedSkeletonPtr &amp;&amp; curElem-&gt;skeletonWasSpecified) {
<span class="line-modified">!                *specifiedSkeletonPtr = curElem-&gt;skeleton;</span>
             }
             return &amp;(curElem-&gt;pattern);
         }
<span class="line-modified">!        curElem=curElem-&gt;next;</span>
<span class="line-modified">!    }while (curElem != NULL);</span>
  
<span class="line-modified">!    return NULL;</span>
  }
  
  UBool
<span class="line-modified">! PatternMap::equals(const PatternMap&amp; other) {</span>
      if ( this==&amp;other ) {
          return TRUE;
      }
<span class="line-modified">!     for (int32_t bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {</span>
<span class="line-modified">!         if ( boot[bootIndex]==other.boot[bootIndex] ) {</span>
              continue;
          }
<span class="line-modified">!         if ( (boot[bootIndex]==NULL)||(other.boot[bootIndex]==NULL) ) {</span>
              return FALSE;
          }
          PtnElem *otherElem = other.boot[bootIndex];
          PtnElem *myElem = boot[bootIndex];
<span class="line-modified">!         while ((otherElem!=NULL) || (myElem!=NULL)) {</span>
              if ( myElem == otherElem ) {
                  break;
              }
<span class="line-modified">!             if ((otherElem==NULL) || (myElem==NULL)) {</span>
                  return FALSE;
              }
              if ( (myElem-&gt;basePattern != otherElem-&gt;basePattern) ||
                   (myElem-&gt;pattern != otherElem-&gt;pattern) ) {
                  return FALSE;
              }
<span class="line-modified">!             if ((myElem-&gt;skeleton!=otherElem-&gt;skeleton)&amp;&amp;</span>
                  !myElem-&gt;skeleton-&gt;equals(*(otherElem-&gt;skeleton))) {
                  return FALSE;
              }
<span class="line-modified">!             myElem = myElem-&gt;next;</span>
<span class="line-modified">!             otherElem=otherElem-&gt;next;</span>
          }
      }
      return TRUE;
  }
  
<span class="line-new-header">--- 1945,99 ---</span>
      }
  }  // PatternMap::add
  
  // Find the pattern from the given basePattern string.
  const UnicodeString *
<span class="line-modified">! PatternMap::getPatternFromBasePattern(const UnicodeString&amp; basePattern, UBool&amp; skeletonWasSpecified) const { // key to search for</span>
     PtnElem *curElem;
  
<span class="line-modified">!    if ((curElem=getHeader(basePattern.charAt(0)))==nullptr) {</span>
<span class="line-modified">!        return nullptr;  // no match</span>
     }
  
     do  {
         if ( basePattern.compare(curElem-&gt;basePattern)==0 ) {
            skeletonWasSpecified = curElem-&gt;skeletonWasSpecified;
            return &amp;(curElem-&gt;pattern);
         }
<span class="line-modified">!        curElem = curElem-&gt;next.getAlias();</span>
<span class="line-modified">!    } while (curElem != nullptr);</span>
  
<span class="line-modified">!    return nullptr;</span>
  }  // PatternMap::getFromBasePattern
  
  
  // Find the pattern from the given skeleton.
  // At least when this is called from getBestRaw &amp; addPattern (in which case specifiedSkeletonPtr is non-NULL),
  // the comparison should be based on skeleton.original (which is unique and tied to the distance measurement in bestRaw)
  // and not skeleton.baseOriginal (which is not unique); otherwise we may pick a different skeleton than the one with the
  // optimum distance value in getBestRaw. When this is called from public getRedundants (specifiedSkeletonPtr is NULL),
  // for now it will continue to compare based on baseOriginal so as not to change the behavior unnecessarily.
  const UnicodeString *
<span class="line-modified">! PatternMap::getPatternFromSkeleton(const PtnSkeleton&amp; skeleton, const PtnSkeleton** specifiedSkeletonPtr) const { // key to search for</span>
     PtnElem *curElem;
  
     if (specifiedSkeletonPtr) {
<span class="line-modified">!        *specifiedSkeletonPtr = nullptr;</span>
     }
  
     // find boot entry
     UChar baseChar = skeleton.getFirstChar();
<span class="line-modified">!    if ((curElem=getHeader(baseChar))==nullptr) {</span>
<span class="line-modified">!        return nullptr;  // no match</span>
     }
  
     do  {
         UBool equal;
<span class="line-modified">!        if (specifiedSkeletonPtr != nullptr) { // called from DateTimePatternGenerator::getBestRaw or addPattern, use original</span>
             equal = curElem-&gt;skeleton-&gt;original == skeleton.original;
         } else { // called from DateTimePatternGenerator::getRedundants, use baseOriginal
             equal = curElem-&gt;skeleton-&gt;baseOriginal == skeleton.baseOriginal;
         }
         if (equal) {
             if (specifiedSkeletonPtr &amp;&amp; curElem-&gt;skeletonWasSpecified) {
<span class="line-modified">!                *specifiedSkeletonPtr = curElem-&gt;skeleton.getAlias();</span>
             }
             return &amp;(curElem-&gt;pattern);
         }
<span class="line-modified">!        curElem = curElem-&gt;next.getAlias();</span>
<span class="line-modified">!    } while (curElem != nullptr);</span>
  
<span class="line-modified">!    return nullptr;</span>
  }
  
  UBool
<span class="line-modified">! PatternMap::equals(const PatternMap&amp; other) const {</span>
      if ( this==&amp;other ) {
          return TRUE;
      }
<span class="line-modified">!     for (int32_t bootIndex = 0; bootIndex &lt; MAX_PATTERN_ENTRIES; ++bootIndex) {</span>
<span class="line-modified">!         if (boot[bootIndex] == other.boot[bootIndex]) {</span>
              continue;
          }
<span class="line-modified">!         if ((boot[bootIndex] == nullptr) || (other.boot[bootIndex] == nullptr)) {</span>
              return FALSE;
          }
          PtnElem *otherElem = other.boot[bootIndex];
          PtnElem *myElem = boot[bootIndex];
<span class="line-modified">!         while ((otherElem != nullptr) || (myElem != nullptr)) {</span>
              if ( myElem == otherElem ) {
                  break;
              }
<span class="line-modified">!             if ((otherElem == nullptr) || (myElem == nullptr)) {</span>
                  return FALSE;
              }
              if ( (myElem-&gt;basePattern != otherElem-&gt;basePattern) ||
                   (myElem-&gt;pattern != otherElem-&gt;pattern) ) {
                  return FALSE;
              }
<span class="line-modified">!             if ((myElem-&gt;skeleton.getAlias() != otherElem-&gt;skeleton.getAlias()) &amp;&amp;</span>
                  !myElem-&gt;skeleton-&gt;equals(*(otherElem-&gt;skeleton))) {
                  return FALSE;
              }
<span class="line-modified">!             myElem = myElem-&gt;next.getAlias();</span>
<span class="line-modified">!             otherElem = otherElem-&gt;next.getAlias();</span>
          }
      }
      return TRUE;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1907,37 ***</span>
  // return TRUE if there is an existing key, otherwise return FALSE.
  PtnElem*
  PatternMap::getDuplicateElem(
              const UnicodeString &amp;basePattern,
              const PtnSkeleton &amp;skeleton,
<span class="line-modified">!             PtnElem *baseElem)  {</span>
     PtnElem *curElem;
  
<span class="line-modified">!    if ( baseElem == (PtnElem *)NULL )  {</span>
<span class="line-modified">!          return (PtnElem*)NULL;</span>
     }
     else {
           curElem = baseElem;
     }
     do {
       if ( basePattern.compare(curElem-&gt;basePattern)==0 ) {
<span class="line-modified">!         UBool isEqual=TRUE;</span>
<span class="line-modified">!         for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {</span>
              if (curElem-&gt;skeleton-&gt;type[i] != skeleton.type[i] ) {
<span class="line-modified">!                 isEqual=FALSE;</span>
                  break;
              }
          }
          if (isEqual) {
              return curElem;
          }
       }
<span class="line-modified">!      curElem = curElem-&gt;next;</span>
<span class="line-modified">!    } while( curElem != (PtnElem *)NULL );</span>
  
     // end of the list
<span class="line-modified">!    return (PtnElem*)NULL;</span>
  
  }  // PatternMap::getDuplicateElem
  
  DateTimeMatcher::DateTimeMatcher(void) {
  }
<span class="line-new-header">--- 2045,37 ---</span>
  // return TRUE if there is an existing key, otherwise return FALSE.
  PtnElem*
  PatternMap::getDuplicateElem(
              const UnicodeString &amp;basePattern,
              const PtnSkeleton &amp;skeleton,
<span class="line-modified">!             PtnElem *baseElem) {</span>
     PtnElem *curElem;
  
<span class="line-modified">!    if ( baseElem == nullptr ) {</span>
<span class="line-modified">!          return nullptr;</span>
     }
     else {
           curElem = baseElem;
     }
     do {
       if ( basePattern.compare(curElem-&gt;basePattern)==0 ) {
<span class="line-modified">!          UBool isEqual = TRUE;</span>
<span class="line-modified">!          for (int32_t i = 0; i &lt; UDATPG_FIELD_COUNT; ++i) {</span>
              if (curElem-&gt;skeleton-&gt;type[i] != skeleton.type[i] ) {
<span class="line-modified">!                 isEqual = FALSE;</span>
                  break;
              }
          }
          if (isEqual) {
              return curElem;
          }
       }
<span class="line-modified">!      curElem = curElem-&gt;next.getAlias();</span>
<span class="line-modified">!    } while( curElem != nullptr );</span>
  
     // end of the list
<span class="line-modified">!    return nullptr;</span>
  
  }  // PatternMap::getDuplicateElem
  
  DateTimeMatcher::DateTimeMatcher(void) {
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1974,22 ***</span>
              UnicodeString quoteLiteral;
              fp-&gt;getQuoteLiteral(quoteLiteral, &amp;i);
              continue;
          }
          int32_t canonicalIndex = fp-&gt;getCanonicalIndex(value);
<span class="line-modified">!         if (canonicalIndex &lt; 0 ) {</span>
              continue;
          }
          const dtTypeElem *row = &amp;dtTypes[canonicalIndex];
          int32_t field = row-&gt;field;
          skeletonResult.original.populate(field, value);
          UChar repeatChar = row-&gt;patternChar;
          int32_t repeatCount = row-&gt;minLen;
          skeletonResult.baseOriginal.populate(field, repeatChar, repeatCount);
          int16_t subField = row-&gt;type;
<span class="line-modified">!         if ( row-&gt;type &gt; 0) {</span>
<span class="line-modified">!             subField += value.length();</span>
          }
          skeletonResult.type[field] = subField;
      }
      // #13183, handle special behavior for day period characters (a, b, B)
      if (!skeletonResult.original.isFieldEmpty(UDATPG_HOUR_FIELD)) {
<span class="line-new-header">--- 2112,23 ---</span>
              UnicodeString quoteLiteral;
              fp-&gt;getQuoteLiteral(quoteLiteral, &amp;i);
              continue;
          }
          int32_t canonicalIndex = fp-&gt;getCanonicalIndex(value);
<span class="line-modified">!         if (canonicalIndex &lt; 0) {</span>
              continue;
          }
          const dtTypeElem *row = &amp;dtTypes[canonicalIndex];
          int32_t field = row-&gt;field;
          skeletonResult.original.populate(field, value);
          UChar repeatChar = row-&gt;patternChar;
          int32_t repeatCount = row-&gt;minLen;
          skeletonResult.baseOriginal.populate(field, repeatChar, repeatCount);
          int16_t subField = row-&gt;type;
<span class="line-modified">!         if (row-&gt;type &gt; 0) {</span>
<span class="line-modified">!             U_ASSERT(value.length() &lt; INT16_MAX);</span>
<span class="line-added">+             subField += static_cast&lt;int16_t&gt;(value.length());</span>
          }
          skeletonResult.type[field] = subField;
      }
      // #13183, handle special behavior for day period characters (a, b, B)
      if (!skeletonResult.original.isFieldEmpty(UDATPG_HOUR_FIELD)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2029,12 ***</span>
      UnicodeString result;
      return skeleton.original.appendTo(result);
  }
  
  int32_t
<span class="line-modified">! DateTimeMatcher::getDistance(const DateTimeMatcher&amp; other, int32_t includeMask, DistanceInfo&amp; distanceInfo) {</span>
<span class="line-modified">!     int32_t result=0;</span>
      distanceInfo.clear();
      for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
          int32_t myType = (includeMask&amp;(1&lt;&lt;i))==0 ? 0 : skeleton.type[i];
          int32_t otherType = other.skeleton.type[i];
          if (myType==otherType) {
<span class="line-new-header">--- 2168,12 ---</span>
      UnicodeString result;
      return skeleton.original.appendTo(result);
  }
  
  int32_t
<span class="line-modified">! DateTimeMatcher::getDistance(const DateTimeMatcher&amp; other, int32_t includeMask, DistanceInfo&amp; distanceInfo) const {</span>
<span class="line-modified">!     int32_t result = 0;</span>
      distanceInfo.clear();
      for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
          int32_t myType = (includeMask&amp;(1&lt;&lt;i))==0 ? 0 : skeleton.type[i];
          int32_t otherType = other.skeleton.type[i];
          if (myType==otherType) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2069,17 ***</span>
      skeleton.clear();
  }
  
  UBool
  DateTimeMatcher::equals(const DateTimeMatcher* other) const {
<span class="line-modified">!     if (other==NULL) { return FALSE; }</span>
      return skeleton.original == other-&gt;skeleton.original;
  }
  
  int32_t
<span class="line-modified">! DateTimeMatcher::getFieldMask() {</span>
<span class="line-modified">!     int32_t result=0;</span>
  
      for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
          if (skeleton.type[i]!=0) {
              result |= (1&lt;&lt;i);
          }
<span class="line-new-header">--- 2208,17 ---</span>
      skeleton.clear();
  }
  
  UBool
  DateTimeMatcher::equals(const DateTimeMatcher* other) const {
<span class="line-modified">!     if (other==nullptr) { return FALSE; }</span>
      return skeleton.original == other-&gt;skeleton.original;
  }
  
  int32_t
<span class="line-modified">! DateTimeMatcher::getFieldMask() const {</span>
<span class="line-modified">!     int32_t result = 0;</span>
  
      for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
          if (skeleton.type[i]!=0) {
              result |= (1&lt;&lt;i);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2092,11 ***</span>
      return &amp;skeleton;
  }
  
  FormatParser::FormatParser () {
      status = START;
<span class="line-modified">!     itemNumber=0;</span>
  }
  
  
  FormatParser::~FormatParser () {
  }
<span class="line-new-header">--- 2231,11 ---</span>
      return &amp;skeleton;
  }
  
  FormatParser::FormatParser () {
      status = START;
<span class="line-modified">!     itemNumber = 0;</span>
  }
  
  
  FormatParser::~FormatParser () {
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2104,11 ***</span>
  
  // Find the next token with the starting position and length
  // Note: the startPos may
  FormatParser::TokenStatus
  FormatParser::setTokens(const UnicodeString&amp; pattern, int32_t startPos, int32_t *len) {
<span class="line-modified">!     int32_t  curLoc = startPos;</span>
      if ( curLoc &gt;= pattern.length()) {
          return DONE;
      }
      // check the current char is between A-Z or a-z
      do {
<span class="line-new-header">--- 2243,11 ---</span>
  
  // Find the next token with the starting position and length
  // Note: the startPos may
  FormatParser::TokenStatus
  FormatParser::setTokens(const UnicodeString&amp; pattern, int32_t startPos, int32_t *len) {
<span class="line-modified">!     int32_t curLoc = startPos;</span>
      if ( curLoc &gt;= pattern.length()) {
          return DONE;
      }
      // check the current char is between A-Z or a-z
      do {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2130,14 ***</span>
      return ADD_TOKEN;
  }
  
  void
  FormatParser::set(const UnicodeString&amp; pattern) {
<span class="line-modified">!     int32_t startPos=0;</span>
<span class="line-modified">!     TokenStatus result=START;</span>
<span class="line-modified">!     int32_t len=0;</span>
<span class="line-modified">!     itemNumber =0;</span>
  
      do {
          result = setTokens( pattern, startPos, &amp;len );
          if ( result == ADD_TOKEN )
          {
<span class="line-new-header">--- 2269,14 ---</span>
      return ADD_TOKEN;
  }
  
  void
  FormatParser::set(const UnicodeString&amp; pattern) {
<span class="line-modified">!     int32_t startPos = 0;</span>
<span class="line-modified">!     TokenStatus result = START;</span>
<span class="line-modified">!     int32_t len = 0;</span>
<span class="line-modified">!     itemNumber = 0;</span>
  
      do {
          result = setTokens( pattern, startPos, &amp;len );
          if ( result == ADD_TOKEN )
          {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2184,18 ***</span>
      return strict ? -1 : bestRow;
  }
  
  UBool
  FormatParser::isQuoteLiteral(const UnicodeString&amp; s) {
<span class="line-modified">!     return (UBool)(s.charAt(0)==SINGLE_QUOTE);</span>
  }
  
<span class="line-modified">! // This function aussumes the current itemIndex points to the quote literal.</span>
  // Please call isQuoteLiteral prior to this function.
  void
  FormatParser::getQuoteLiteral(UnicodeString&amp; quote, int32_t *itemIndex) {
<span class="line-modified">!     int32_t i=*itemIndex;</span>
  
      quote.remove();
      if (items[i].charAt(0)==SINGLE_QUOTE) {
          quote += items[i];
          ++i;
<span class="line-new-header">--- 2323,18 ---</span>
      return strict ? -1 : bestRow;
  }
  
  UBool
  FormatParser::isQuoteLiteral(const UnicodeString&amp; s) {
<span class="line-modified">!     return (UBool)(s.charAt(0) == SINGLE_QUOTE);</span>
  }
  
<span class="line-modified">! // This function assumes the current itemIndex points to the quote literal.</span>
  // Please call isQuoteLiteral prior to this function.
  void
  FormatParser::getQuoteLiteral(UnicodeString&amp; quote, int32_t *itemIndex) {
<span class="line-modified">!     int32_t i = *itemIndex;</span>
  
      quote.remove();
      if (items[i].charAt(0)==SINGLE_QUOTE) {
          quote += items[i];
          ++i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2220,11 ***</span>
      }
      *itemIndex=i;
  }
  
  UBool
<span class="line-modified">! FormatParser::isPatternSeparator(UnicodeString&amp; field) {</span>
      for (int32_t i=0; i&lt;field.length(); ++i ) {
          UChar c= field.charAt(i);
          if ( (c==SINGLE_QUOTE) || (c==BACKSLASH) || (c==SPACE) || (c==COLON) ||
               (c==QUOTATION_MARK) || (c==COMMA) || (c==HYPHEN) ||(items[i].charAt(0)==DOT) ) {
              continue;
<span class="line-new-header">--- 2359,11 ---</span>
      }
      *itemIndex=i;
  }
  
  UBool
<span class="line-modified">! FormatParser::isPatternSeparator(const UnicodeString&amp; field) const {</span>
      for (int32_t i=0; i&lt;field.length(); ++i ) {
          UChar c= field.charAt(i);
          if ( (c==SINGLE_QUOTE) || (c==BACKSLASH) || (c==SPACE) || (c==COLON) ||
               (c==QUOTATION_MARK) || (c==COMMA) || (c==HYPHEN) ||(items[i].charAt(0)==DOT) ) {
              continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2237,101 ***</span>
  }
  
  DistanceInfo::~DistanceInfo() {}
  
  void
<span class="line-modified">! DistanceInfo::setTo(DistanceInfo &amp;other) {</span>
      missingFieldMask = other.missingFieldMask;
      extraFieldMask= other.extraFieldMask;
  }
  
<span class="line-modified">! PatternMapIterator::PatternMapIterator() {</span>
<span class="line-modified">!     bootIndex = 0;</span>
<span class="line-modified">!     nodePtr = NULL;</span>
<span class="line-modified">!     patternMap=NULL;</span>
<span class="line-modified">!     matcher= new DateTimeMatcher();</span>
  }
  
<span class="line-removed">- </span>
  PatternMapIterator::~PatternMapIterator() {
<span class="line-removed">-     delete matcher;</span>
  }
  
  void
  PatternMapIterator::set(PatternMap&amp; newPatternMap) {
      this-&gt;patternMap=&amp;newPatternMap;
  }
  
  PtnSkeleton*
<span class="line-modified">! PatternMapIterator::getSkeleton() {</span>
<span class="line-modified">!     if ( nodePtr == NULL ) {</span>
<span class="line-modified">!         return NULL;</span>
      }
      else {
<span class="line-modified">!         return nodePtr-&gt;skeleton;</span>
      }
  }
  
  UBool
<span class="line-modified">! PatternMapIterator::hasNext() {</span>
<span class="line-modified">!     int32_t headIndex=bootIndex;</span>
<span class="line-modified">!     PtnElem *curPtr=nodePtr;</span>
  
<span class="line-modified">!     if (patternMap==NULL) {</span>
          return FALSE;
      }
      while ( headIndex &lt; MAX_PATTERN_ENTRIES ) {
<span class="line-modified">!         if ( curPtr != NULL ) {</span>
<span class="line-modified">!             if ( curPtr-&gt;next != NULL ) {</span>
                  return TRUE;
              }
              else {
                  headIndex++;
<span class="line-modified">!                 curPtr=NULL;</span>
                  continue;
              }
          }
          else {
<span class="line-modified">!             if ( patternMap-&gt;boot[headIndex] != NULL ) {</span>
                  return TRUE;
              }
              else {
                  headIndex++;
                  continue;
              }
          }
<span class="line-removed">- </span>
      }
      return FALSE;
  }
  
  DateTimeMatcher&amp;
  PatternMapIterator::next() {
      while ( bootIndex &lt; MAX_PATTERN_ENTRIES ) {
<span class="line-modified">!         if ( nodePtr != NULL ) {</span>
<span class="line-modified">!             if ( nodePtr-&gt;next != NULL ) {</span>
<span class="line-modified">!                 nodePtr = nodePtr-&gt;next;</span>
                  break;
              }
              else {
                  bootIndex++;
<span class="line-modified">!                 nodePtr=NULL;</span>
                  continue;
              }
          }
          else {
<span class="line-modified">!             if ( patternMap-&gt;boot[bootIndex] != NULL ) {</span>
                  nodePtr = patternMap-&gt;boot[bootIndex];
                  break;
              }
              else {
                  bootIndex++;
                  continue;
              }
          }
      }
<span class="line-modified">!     if (nodePtr!=NULL) {</span>
          matcher-&gt;copyFrom(*nodePtr-&gt;skeleton);
      }
      else {
          matcher-&gt;copyFrom();
      }
<span class="line-new-header">--- 2376,98 ---</span>
  }
  
  DistanceInfo::~DistanceInfo() {}
  
  void
<span class="line-modified">! DistanceInfo::setTo(const DistanceInfo&amp; other) {</span>
      missingFieldMask = other.missingFieldMask;
      extraFieldMask= other.extraFieldMask;
  }
  
<span class="line-modified">! PatternMapIterator::PatternMapIterator(UErrorCode&amp; status) :</span>
<span class="line-modified">!     bootIndex(0), nodePtr(nullptr), matcher(nullptr), patternMap(nullptr)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">!     matcher.adoptInsteadAndCheckErrorCode(new DateTimeMatcher(), status);</span>
  }
  
  PatternMapIterator::~PatternMapIterator() {
  }
  
  void
  PatternMapIterator::set(PatternMap&amp; newPatternMap) {
      this-&gt;patternMap=&amp;newPatternMap;
  }
  
  PtnSkeleton*
<span class="line-modified">! PatternMapIterator::getSkeleton() const {</span>
<span class="line-modified">!     if ( nodePtr == nullptr ) {</span>
<span class="line-modified">!         return nullptr;</span>
      }
      else {
<span class="line-modified">!         return nodePtr-&gt;skeleton.getAlias();</span>
      }
  }
  
  UBool
<span class="line-modified">! PatternMapIterator::hasNext() const {</span>
<span class="line-modified">!     int32_t headIndex = bootIndex;</span>
<span class="line-modified">!     PtnElem *curPtr = nodePtr;</span>
  
<span class="line-modified">!     if (patternMap==nullptr) {</span>
          return FALSE;
      }
      while ( headIndex &lt; MAX_PATTERN_ENTRIES ) {
<span class="line-modified">!         if ( curPtr != nullptr ) {</span>
<span class="line-modified">!             if ( curPtr-&gt;next != nullptr ) {</span>
                  return TRUE;
              }
              else {
                  headIndex++;
<span class="line-modified">!                 curPtr=nullptr;</span>
                  continue;
              }
          }
          else {
<span class="line-modified">!             if ( patternMap-&gt;boot[headIndex] != nullptr ) {</span>
                  return TRUE;
              }
              else {
                  headIndex++;
                  continue;
              }
          }
      }
      return FALSE;
  }
  
  DateTimeMatcher&amp;
  PatternMapIterator::next() {
      while ( bootIndex &lt; MAX_PATTERN_ENTRIES ) {
<span class="line-modified">!         if ( nodePtr != nullptr ) {</span>
<span class="line-modified">!             if ( nodePtr-&gt;next != nullptr ) {</span>
<span class="line-modified">!                 nodePtr = nodePtr-&gt;next.getAlias();</span>
                  break;
              }
              else {
                  bootIndex++;
<span class="line-modified">!                 nodePtr=nullptr;</span>
                  continue;
              }
          }
          else {
<span class="line-modified">!             if ( patternMap-&gt;boot[bootIndex] != nullptr ) {</span>
                  nodePtr = patternMap-&gt;boot[bootIndex];
                  break;
              }
              else {
                  bootIndex++;
                  continue;
              }
          }
      }
<span class="line-modified">!     if (nodePtr!=nullptr) {</span>
          matcher-&gt;copyFrom(*nodePtr-&gt;skeleton);
      }
      else {
          matcher-&gt;copyFrom();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2466,84 ***</span>
  
  PtnSkeleton::~PtnSkeleton() {
  }
  
  PtnElem::PtnElem(const UnicodeString &amp;basePat, const UnicodeString &amp;pat) :
<span class="line-modified">! basePattern(basePat),</span>
<span class="line-removed">- skeleton(NULL),</span>
<span class="line-removed">- pattern(pat),</span>
<span class="line-removed">- next(NULL)</span>
  {
  }
  
  PtnElem::~PtnElem() {
<span class="line-removed">- </span>
<span class="line-removed">-     if (next!=NULL) {</span>
<span class="line-removed">-         delete next;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     delete skeleton;</span>
  }
  
<span class="line-modified">! DTSkeletonEnumeration::DTSkeletonEnumeration(PatternMap &amp;patternMap, dtStrEnum type, UErrorCode&amp; status) {</span>
      PtnElem  *curElem;
      PtnSkeleton *curSkeleton;
      UnicodeString s;
      int32_t bootIndex;
  
      pos=0;
<span class="line-modified">!     fSkeletons = new UVector(status);</span>
      if (U_FAILURE(status)) {
<span class="line-removed">-         delete fSkeletons;</span>
          return;
      }
      for (bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {
          curElem = patternMap.boot[bootIndex];
<span class="line-modified">!         while (curElem!=NULL) {</span>
              switch(type) {
                  case DT_BASESKELETON:
                      s=curElem-&gt;basePattern;
                      break;
                  case DT_PATTERN:
                      s=curElem-&gt;pattern;
                      break;
                  case DT_SKELETON:
<span class="line-modified">!                     curSkeleton=curElem-&gt;skeleton;</span>
                      s=curSkeleton-&gt;getSkeleton();
                      break;
              }
              if ( !isCanonicalItem(s) ) {
<span class="line-modified">!                 fSkeletons-&gt;addElement(new UnicodeString(s), status);</span>
                  if (U_FAILURE(status)) {
<span class="line-modified">!                     delete fSkeletons;</span>
<span class="line-removed">-                     fSkeletons = NULL;</span>
                      return;
                  }
              }
<span class="line-modified">!             curElem = curElem-&gt;next;</span>
          }
      }
<span class="line-modified">!     if ((bootIndex==MAX_PATTERN_ENTRIES) &amp;&amp; (curElem!=NULL) ) {</span>
          status = U_BUFFER_OVERFLOW_ERROR;
      }
  }
  
  const UnicodeString*
  DTSkeletonEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">!     if (U_SUCCESS(status) &amp;&amp; pos &lt; fSkeletons-&gt;size()) {</span>
          return (const UnicodeString*)fSkeletons-&gt;elementAt(pos++);
      }
<span class="line-modified">!     return NULL;</span>
  }
  
  void
  DTSkeletonEnumeration::reset(UErrorCode&amp; /*status*/) {
      pos=0;
  }
  
  int32_t
  DTSkeletonEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">!    return (fSkeletons==NULL) ? 0 : fSkeletons-&gt;size();</span>
  }
  
  UBool
  DTSkeletonEnumeration::isCanonicalItem(const UnicodeString&amp; item) {
      if ( item.length() != 1 ) {
<span class="line-new-header">--- 2602,80 ---</span>
  
  PtnSkeleton::~PtnSkeleton() {
  }
  
  PtnElem::PtnElem(const UnicodeString &amp;basePat, const UnicodeString &amp;pat) :
<span class="line-modified">!     basePattern(basePat), skeleton(nullptr), pattern(pat), next(nullptr)</span>
  {
  }
  
  PtnElem::~PtnElem() {
  }
  
<span class="line-modified">! DTSkeletonEnumeration::DTSkeletonEnumeration(PatternMap&amp; patternMap, dtStrEnum type, UErrorCode&amp; status) : fSkeletons(nullptr) {</span>
      PtnElem  *curElem;
      PtnSkeleton *curSkeleton;
      UnicodeString s;
      int32_t bootIndex;
  
      pos=0;
<span class="line-modified">!     fSkeletons.adoptInsteadAndCheckErrorCode(new UVector(status), status);</span>
      if (U_FAILURE(status)) {
          return;
      }
<span class="line-added">+ </span>
      for (bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {
          curElem = patternMap.boot[bootIndex];
<span class="line-modified">!         while (curElem!=nullptr) {</span>
              switch(type) {
                  case DT_BASESKELETON:
                      s=curElem-&gt;basePattern;
                      break;
                  case DT_PATTERN:
                      s=curElem-&gt;pattern;
                      break;
                  case DT_SKELETON:
<span class="line-modified">!                     curSkeleton=curElem-&gt;skeleton.getAlias();</span>
                      s=curSkeleton-&gt;getSkeleton();
                      break;
              }
              if ( !isCanonicalItem(s) ) {
<span class="line-modified">!                 LocalPointer&lt;UnicodeString&gt; newElem(new UnicodeString(s), status);</span>
<span class="line-added">+                 if (U_FAILURE(status)) {</span>
<span class="line-added">+                     return;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 fSkeletons-&gt;addElement(newElem.getAlias(), status);</span>
                  if (U_FAILURE(status)) {
<span class="line-modified">!                     fSkeletons.adoptInstead(nullptr);</span>
                      return;
                  }
<span class="line-added">+                 newElem.orphan(); // fSkeletons vector now owns the UnicodeString.</span>
              }
<span class="line-modified">!             curElem = curElem-&gt;next.getAlias();</span>
          }
      }
<span class="line-modified">!     if ((bootIndex==MAX_PATTERN_ENTRIES) &amp;&amp; (curElem!=nullptr) ) {</span>
          status = U_BUFFER_OVERFLOW_ERROR;
      }
  }
  
  const UnicodeString*
  DTSkeletonEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">!     if (U_SUCCESS(status) &amp;&amp; fSkeletons.isValid() &amp;&amp; pos &lt; fSkeletons-&gt;size()) {</span>
          return (const UnicodeString*)fSkeletons-&gt;elementAt(pos++);
      }
<span class="line-modified">!     return nullptr;</span>
  }
  
  void
  DTSkeletonEnumeration::reset(UErrorCode&amp; /*status*/) {
      pos=0;
  }
  
  int32_t
  DTSkeletonEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">!    return (fSkeletons.isNull()) ? 0 : fSkeletons-&gt;size();</span>
  }
  
  UBool
  DTSkeletonEnumeration::isCanonicalItem(const UnicodeString&amp; item) {
      if ( item.length() != 1 ) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2557,62 ***</span>
      return FALSE;
  }
  
  DTSkeletonEnumeration::~DTSkeletonEnumeration() {
      UnicodeString *s;
<span class="line-modified">!     for (int32_t i=0; i&lt;fSkeletons-&gt;size(); ++i) {</span>
<span class="line-modified">!         if ((s=(UnicodeString *)fSkeletons-&gt;elementAt(i))!=NULL) {</span>
<span class="line-modified">!             delete s;</span>
          }
      }
<span class="line-removed">-     delete fSkeletons;</span>
  }
  
<span class="line-modified">! DTRedundantEnumeration::DTRedundantEnumeration() {</span>
<span class="line-removed">-     pos=0;</span>
<span class="line-removed">-     fPatterns = NULL;</span>
  }
  
  void
  DTRedundantEnumeration::add(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
<span class="line-modified">!     if (U_FAILURE(status)) return;</span>
<span class="line-modified">!     if (fPatterns == NULL)  {</span>
<span class="line-modified">!         fPatterns = new UVector(status);</span>
          if (U_FAILURE(status)) {
<span class="line-removed">-             delete fPatterns;</span>
<span class="line-removed">-             fPatterns = NULL;</span>
              return;
         }
      }
<span class="line-modified">!     fPatterns-&gt;addElement(new UnicodeString(pattern), status);</span>
      if (U_FAILURE(status)) {
<span class="line-removed">-         delete fPatterns;</span>
<span class="line-removed">-         fPatterns = NULL;</span>
          return;
      }
  }
  
  const UnicodeString*
  DTRedundantEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">!     if (U_SUCCESS(status) &amp;&amp; pos &lt; fPatterns-&gt;size()) {</span>
          return (const UnicodeString*)fPatterns-&gt;elementAt(pos++);
      }
<span class="line-modified">!     return NULL;</span>
  }
  
  void
  DTRedundantEnumeration::reset(UErrorCode&amp; /*status*/) {
      pos=0;
  }
  
  int32_t
  DTRedundantEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">!        return (fPatterns==NULL) ? 0 : fPatterns-&gt;size();</span>
  }
  
  UBool
<span class="line-modified">! DTRedundantEnumeration::isCanonicalItem(const UnicodeString&amp; item) {</span>
      if ( item.length() != 1 ) {
          return FALSE;
      }
      for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
          if (item.charAt(0)==Canonical_Items[i]) {
<span class="line-new-header">--- 2689,63 ---</span>
      return FALSE;
  }
  
  DTSkeletonEnumeration::~DTSkeletonEnumeration() {
      UnicodeString *s;
<span class="line-modified">!     if (fSkeletons.isValid()) {</span>
<span class="line-modified">!         for (int32_t i = 0; i &lt; fSkeletons-&gt;size(); ++i) {</span>
<span class="line-modified">!             if ((s = (UnicodeString *)fSkeletons-&gt;elementAt(i)) != nullptr) {</span>
<span class="line-added">+                 delete s;</span>
<span class="line-added">+             }</span>
          }
      }
  }
  
<span class="line-modified">! DTRedundantEnumeration::DTRedundantEnumeration() : pos(0), fPatterns(nullptr) {</span>
  }
  
  void
  DTRedundantEnumeration::add(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
<span class="line-modified">!     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">!     if (fPatterns.isNull())  {</span>
<span class="line-modified">!         fPatterns.adoptInsteadAndCheckErrorCode(new UVector(status), status);</span>
          if (U_FAILURE(status)) {
              return;
         }
      }
<span class="line-modified">!     LocalPointer&lt;UnicodeString&gt; newElem(new UnicodeString(pattern), status);</span>
      if (U_FAILURE(status)) {
          return;
      }
<span class="line-added">+     fPatterns-&gt;addElement(newElem.getAlias(), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         fPatterns.adoptInstead(nullptr);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     newElem.orphan(); // fPatterns now owns the string.</span>
  }
  
  const UnicodeString*
  DTRedundantEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">!     if (U_SUCCESS(status) &amp;&amp; fPatterns.isValid() &amp;&amp; pos &lt; fPatterns-&gt;size()) {</span>
          return (const UnicodeString*)fPatterns-&gt;elementAt(pos++);
      }
<span class="line-modified">!     return nullptr;</span>
  }
  
  void
  DTRedundantEnumeration::reset(UErrorCode&amp; /*status*/) {
      pos=0;
  }
  
  int32_t
  DTRedundantEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">!     return (fPatterns.isNull()) ? 0 : fPatterns-&gt;size();</span>
  }
  
  UBool
<span class="line-modified">! DTRedundantEnumeration::isCanonicalItem(const UnicodeString&amp; item) const {</span>
      if ( item.length() != 1 ) {
          return FALSE;
      }
      for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
          if (item.charAt(0)==Canonical_Items[i]) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2622,16 ***</span>
      return FALSE;
  }
  
  DTRedundantEnumeration::~DTRedundantEnumeration() {
      UnicodeString *s;
<span class="line-modified">!     for (int32_t i=0; i&lt;fPatterns-&gt;size(); ++i) {</span>
<span class="line-modified">!         if ((s=(UnicodeString *)fPatterns-&gt;elementAt(i))!=NULL) {</span>
<span class="line-modified">!             delete s;</span>
          }
      }
<span class="line-removed">-     delete fPatterns;</span>
  }
  
  U_NAMESPACE_END
  
  
<span class="line-new-header">--- 2755,17 ---</span>
      return FALSE;
  }
  
  DTRedundantEnumeration::~DTRedundantEnumeration() {
      UnicodeString *s;
<span class="line-modified">!     if (fPatterns.isValid()) {</span>
<span class="line-modified">!         for (int32_t i = 0; i &lt; fPatterns-&gt;size(); ++i) {</span>
<span class="line-modified">!             if ((s = (UnicodeString *)fPatterns-&gt;elementAt(i)) != nullptr) {</span>
<span class="line-added">+                 delete s;</span>
<span class="line-added">+             }</span>
          }
      }
  }
  
  U_NAMESPACE_END
  
  
</pre>
<center><a href="dtitvinf.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtptngen_impl.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>