<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/measfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="japancal.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="measunit.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/measfmt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19 #include &quot;unicode/numfmt.h&quot;
  20 #include &quot;currfmt.h&quot;
  21 #include &quot;unicode/localpointer.h&quot;
  22 #include &quot;resource.h&quot;
  23 #include &quot;unicode/simpleformatter.h&quot;
  24 #include &quot;quantityformatter.h&quot;
  25 #include &quot;unicode/plurrule.h&quot;
  26 #include &quot;unicode/decimfmt.h&quot;
  27 #include &quot;uresimp.h&quot;
  28 #include &quot;unicode/ures.h&quot;
  29 #include &quot;unicode/ustring.h&quot;
  30 #include &quot;ureslocs.h&quot;
  31 #include &quot;cstring.h&quot;
  32 #include &quot;mutex.h&quot;
  33 #include &quot;ucln_in.h&quot;
  34 #include &quot;unicode/listformatter.h&quot;
  35 #include &quot;charstr.h&quot;
  36 #include &quot;unicode/putil.h&quot;
  37 #include &quot;unicode/smpdtfmt.h&quot;
  38 #include &quot;uassert.h&quot;


  39 
  40 #include &quot;sharednumberformat.h&quot;
  41 #include &quot;sharedpluralrules.h&quot;
  42 #include &quot;standardplural.h&quot;
  43 #include &quot;unifiedcache.h&quot;
  44 
  45 
  46 U_NAMESPACE_BEGIN
  47 
<span class="line-removed">  48 static constexpr int32_t PER_UNIT_INDEX = StandardPlural::COUNT;</span>
<span class="line-removed">  49 static constexpr int32_t PATTERN_COUNT = PER_UNIT_INDEX + 1;</span>
<span class="line-removed">  50 static constexpr int32_t MEAS_UNIT_COUNT = 138;  // see assertion in MeasureFormatCacheData constructor</span>
  51 static constexpr int32_t WIDTH_INDEX_COUNT = UMEASFMT_WIDTH_NARROW + 1;
  52 
  53 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(MeasureFormat)
  54 
  55 // Used to format durations like 5:47 or 21:35:42.
  56 class NumericDateFormatters : public UMemory {
  57 public:
  58     // Formats like H:mm
  59     SimpleDateFormat hourMinute;
  60 
  61     // formats like M:ss
  62     SimpleDateFormat minuteSecond;
  63 
  64     // formats like H:mm:ss
  65     SimpleDateFormat hourMinuteSecond;
  66 
  67     // Constructor that takes the actual patterns for hour-minute,
  68     // minute-second, and hour-minute-second respectively.
  69     NumericDateFormatters(
  70             const UnicodeString &amp;hm,
</pre>
<hr />
<pre>
  74             hourMinute(hm, status),
  75             minuteSecond(ms, status),
  76             hourMinuteSecond(hms, status) {
  77         const TimeZone *gmt = TimeZone::getGMT();
  78         hourMinute.setTimeZone(*gmt);
  79         minuteSecond.setTimeZone(*gmt);
  80         hourMinuteSecond.setTimeZone(*gmt);
  81     }
  82 private:
  83     NumericDateFormatters(const NumericDateFormatters &amp;other);
  84     NumericDateFormatters &amp;operator=(const NumericDateFormatters &amp;other);
  85 };
  86 
  87 static UMeasureFormatWidth getRegularWidth(UMeasureFormatWidth width) {
  88     if (width &gt;= WIDTH_INDEX_COUNT) {
  89         return UMEASFMT_WIDTH_NARROW;
  90     }
  91     return width;
  92 }
  93 













  94 /**
  95  * Instances contain all MeasureFormat specific data for a particular locale.
  96  * This data is cached. It is never copied, but is shared via shared pointers.
  97  *
  98  * Note: We might change the cache data to have an array[WIDTH_INDEX_COUNT] of
  99  * complete sets of unit &amp; per patterns,
 100  * to correspond to the resource data and its aliases.
 101  *
 102  * TODO: Maybe store more sparsely in general, with pointers rather than potentially-empty objects.
 103  */
 104 class MeasureFormatCacheData : public SharedObject {
 105 public:
 106 
 107     /**
 108      * Redirection data from root-bundle, top-level sideways aliases.
 109      * - UMEASFMT_WIDTH_COUNT: initial value, just fall back to root
 110      * - UMEASFMT_WIDTH_WIDE/SHORT/NARROW: sideways alias for missing data
 111      */
 112     UMeasureFormatWidth widthFallback[WIDTH_INDEX_COUNT];
<span class="line-removed"> 113     /** Measure unit -&gt; format width -&gt; array of patterns (&quot;{0} meters&quot;) (plurals + PER_UNIT_INDEX) */</span>
<span class="line-removed"> 114     SimpleFormatter* patterns[MEAS_UNIT_COUNT][WIDTH_INDEX_COUNT][PATTERN_COUNT];</span>
<span class="line-removed"> 115     const UChar* dnams[MEAS_UNIT_COUNT][WIDTH_INDEX_COUNT];</span>
<span class="line-removed"> 116     SimpleFormatter perFormatters[WIDTH_INDEX_COUNT];</span>
 117 
 118     MeasureFormatCacheData();
 119     virtual ~MeasureFormatCacheData();
 120 
<span class="line-removed"> 121     UBool hasPerFormatter(int32_t width) const {</span>
<span class="line-removed"> 122         // TODO: Create a more obvious way to test if the per-formatter has been set?</span>
<span class="line-removed"> 123         // Use pointers, check for NULL? Or add an isValid() method?</span>
<span class="line-removed"> 124         return perFormatters[width].getArgumentLimit() == 2;</span>
<span class="line-removed"> 125     }</span>
<span class="line-removed"> 126 </span>
 127     void adoptCurrencyFormat(int32_t widthIndex, NumberFormat *nfToAdopt) {
 128         delete currencyFormats[widthIndex];
 129         currencyFormats[widthIndex] = nfToAdopt;
 130     }
 131     const NumberFormat *getCurrencyFormat(UMeasureFormatWidth width) const {
 132         return currencyFormats[getRegularWidth(width)];
 133     }
 134     void adoptIntegerFormat(NumberFormat *nfToAdopt) {
 135         delete integerFormat;
 136         integerFormat = nfToAdopt;
 137     }
 138     const NumberFormat *getIntegerFormat() const {
 139         return integerFormat;
 140     }
 141     void adoptNumericDateFormatters(NumericDateFormatters *formattersToAdopt) {
 142         delete numericDateFormatters;
 143         numericDateFormatters = formattersToAdopt;
 144     }
 145     const NumericDateFormatters *getNumericDateFormatters() const {
 146         return numericDateFormatters;
<span class="line-removed"> 160     // Please update MEAS_UNIT_COUNT if it gets out of sync with the true count!</span>
<span class="line-removed"> 161     U_ASSERT(MEAS_UNIT_COUNT == MeasureUnit::getIndexCount());</span>
<span class="line-removed"> 162 </span>
 163     for (int32_t i = 0; i &lt; WIDTH_INDEX_COUNT; ++i) {
 164         widthFallback[i] = UMEASFMT_WIDTH_COUNT;
 165     }
<span class="line-removed"> 166     memset(&amp;patterns[0][0][0], 0, sizeof(patterns));</span>
<span class="line-removed"> 167     memset(&amp;dnams[0][0], 0, sizeof(dnams));</span>
 168     memset(currencyFormats, 0, sizeof(currencyFormats));
 169 }
 170 
 171 MeasureFormatCacheData::~MeasureFormatCacheData() {
 172     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(currencyFormats); ++i) {
 173         delete currencyFormats[i];
 174     }
<span class="line-removed"> 175     for (int32_t i = 0; i &lt; MEAS_UNIT_COUNT; ++i) {</span>
<span class="line-removed"> 176         for (int32_t j = 0; j &lt; WIDTH_INDEX_COUNT; ++j) {</span>
<span class="line-removed"> 177             for (int32_t k = 0; k &lt; PATTERN_COUNT; ++k) {</span>
<span class="line-removed"> 178                 delete patterns[i][j][k];</span>
<span class="line-removed"> 179             }</span>
<span class="line-removed"> 180         }</span>
<span class="line-removed"> 181     }</span>
 182     // Note: the contents of &#39;dnams&#39; are pointers into the resource bundle
 183     delete integerFormat;
 184     delete numericDateFormatters;
 185 }
 186 
 187 static UBool isCurrency(const MeasureUnit &amp;unit) {
 188     return (uprv_strcmp(unit.getType(), &quot;currency&quot;) == 0);
 189 }
 190 
 191 static UBool getString(
 192         const UResourceBundle *resource,
 193         UnicodeString &amp;result,
 194         UErrorCode &amp;status) {
 195     int32_t len = 0;
 196     const UChar *resStr = ures_getString(resource, &amp;len, &amp;status);
 197     if (U_FAILURE(status)) {
 198         return FALSE;
 199     }
 200     result.setTo(TRUE, resStr, len);
 201     return TRUE;
<span class="line-removed"> 204 namespace {</span>
<span class="line-removed"> 205 </span>
<span class="line-removed"> 206 static const UChar g_LOCALE_units[] = {</span>
<span class="line-removed"> 207     0x2F, 0x4C, 0x4F, 0x43, 0x41, 0x4C, 0x45, 0x2F,</span>
<span class="line-removed"> 208     0x75, 0x6E, 0x69, 0x74, 0x73</span>
<span class="line-removed"> 209 };</span>
<span class="line-removed"> 210 static const UChar gShort[] = { 0x53, 0x68, 0x6F, 0x72, 0x74 };</span>
<span class="line-removed"> 211 static const UChar gNarrow[] = { 0x4E, 0x61, 0x72, 0x72, 0x6F, 0x77 };</span>
<span class="line-removed"> 212 </span>
<span class="line-removed"> 213 /**</span>
<span class="line-removed"> 214  * Sink for enumerating all of the measurement unit display names.</span>
<span class="line-removed"> 215  * Contains inner sink classes, each one corresponding to a type of resource table.</span>
<span class="line-removed"> 216  * The outer sink handles the top-level units, unitsNarrow, and unitsShort tables.</span>
<span class="line-removed"> 217  *</span>
<span class="line-removed"> 218  * More specific bundles (en_GB) are enumerated before their parents (en_001, en, root):</span>
<span class="line-removed"> 219  * Only store a value if it is still missing, that is, it has not been overridden.</span>
<span class="line-removed"> 220  *</span>
<span class="line-removed"> 221  * C++: Each inner sink class has a reference to the main outer sink.</span>
<span class="line-removed"> 222  * Java: Use non-static inner classes instead.</span>
<span class="line-removed"> 223  */</span>
<span class="line-removed"> 224 struct UnitDataSink : public ResourceSink {</span>
<span class="line-removed"> 225 </span>
<span class="line-removed"> 226     // Output data.</span>
<span class="line-removed"> 227     MeasureFormatCacheData &amp;cacheData;</span>
<span class="line-removed"> 228 </span>
<span class="line-removed"> 229     // Path to current data.</span>
<span class="line-removed"> 230     UMeasureFormatWidth width;</span>
<span class="line-removed"> 231     const char *type;</span>
<span class="line-removed"> 232     int32_t unitIndex;</span>
<span class="line-removed"> 233 </span>
<span class="line-removed"> 234     UnitDataSink(MeasureFormatCacheData &amp;outputData)</span>
<span class="line-removed"> 235             : cacheData(outputData),</span>
<span class="line-removed"> 236               width(UMEASFMT_WIDTH_COUNT), type(NULL), unitIndex(0) {}</span>
<span class="line-removed"> 237     ~UnitDataSink();</span>
<span class="line-removed"> 238 </span>
<span class="line-removed"> 239     void setFormatterIfAbsent(int32_t index, const ResourceValue &amp;value,</span>
<span class="line-removed"> 240                                 int32_t minPlaceholders, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 241         U_ASSERT(unitIndex &lt; MEAS_UNIT_COUNT);</span>
<span class="line-removed"> 242         U_ASSERT(width &lt; WIDTH_INDEX_COUNT);</span>
<span class="line-removed"> 243         U_ASSERT(index &lt; PATTERN_COUNT);</span>
<span class="line-removed"> 244         SimpleFormatter **patterns = &amp;cacheData.patterns[unitIndex][width][0];</span>
<span class="line-removed"> 245         if (U_SUCCESS(errorCode) &amp;&amp; patterns[index] == NULL) {</span>
<span class="line-removed"> 246             if (minPlaceholders &gt;= 0) {</span>
<span class="line-removed"> 247                 patterns[index] = new SimpleFormatter(</span>
<span class="line-removed"> 248                         value.getUnicodeString(errorCode), minPlaceholders, 1, errorCode);</span>
<span class="line-removed"> 249             }</span>
<span class="line-removed"> 250             if (U_SUCCESS(errorCode) &amp;&amp; patterns[index] == NULL) {</span>
<span class="line-removed"> 251                 errorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed"> 252             }</span>
<span class="line-removed"> 253         }</span>
<span class="line-removed"> 254     }</span>
<span class="line-removed"> 255 </span>
<span class="line-removed"> 256     void setDnamIfAbsent(const ResourceValue &amp;value, UErrorCode&amp; errorCode) {</span>
<span class="line-removed"> 257         U_ASSERT(unitIndex &lt; MEAS_UNIT_COUNT);</span>
<span class="line-removed"> 258         U_ASSERT(width &lt; WIDTH_INDEX_COUNT);</span>
<span class="line-removed"> 259         if (cacheData.dnams[unitIndex][width] == NULL) {</span>
<span class="line-removed"> 260             int32_t length;</span>
<span class="line-removed"> 261             cacheData.dnams[unitIndex][width] = value.getString(length, errorCode);</span>
<span class="line-removed"> 262         }</span>
<span class="line-removed"> 263     }</span>
<span class="line-removed"> 264 </span>
<span class="line-removed"> 265     /**</span>
<span class="line-removed"> 266      * Consume a display pattern. For example,</span>
<span class="line-removed"> 267      * unitsShort/duration/hour contains other{&quot;{0} hrs&quot;}.</span>
<span class="line-removed"> 268      */</span>
<span class="line-removed"> 269     void consumePattern(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 270         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 271         if (uprv_strcmp(key, &quot;dnam&quot;) == 0) {</span>
<span class="line-removed"> 272             // The display name for the unit in the current width.</span>
<span class="line-removed"> 273             setDnamIfAbsent(value, errorCode);</span>
<span class="line-removed"> 274         } else if (uprv_strcmp(key, &quot;per&quot;) == 0) {</span>
<span class="line-removed"> 275             // For example, &quot;{0}/h&quot;.</span>
<span class="line-removed"> 276             setFormatterIfAbsent(PER_UNIT_INDEX, value, 1, errorCode);</span>
<span class="line-removed"> 277         } else {</span>
<span class="line-removed"> 278             // The key must be one of the plural form strings. For example:</span>
<span class="line-removed"> 279             // one{&quot;{0} hr&quot;}</span>
<span class="line-removed"> 280             // other{&quot;{0} hrs&quot;}</span>
<span class="line-removed"> 281             setFormatterIfAbsent(StandardPlural::indexFromString(key, errorCode), value, 0,</span>
<span class="line-removed"> 282                                     errorCode);</span>
<span class="line-removed"> 283         }</span>
<span class="line-removed"> 284     }</span>
<span class="line-removed"> 285 </span>
<span class="line-removed"> 286     /**</span>
<span class="line-removed"> 287      * Consume a table of per-unit tables. For example,</span>
<span class="line-removed"> 288      * unitsShort/duration contains tables for duration-unit subtypes day &amp; hour.</span>
<span class="line-removed"> 289      */</span>
<span class="line-removed"> 290     void consumeSubtypeTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 291         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 292         unitIndex = MeasureUnit::internalGetIndexForTypeAndSubtype(type, key);</span>
<span class="line-removed"> 293         if (unitIndex &lt; 0) {</span>
<span class="line-removed"> 294             // TODO: How to handle unexpected data?</span>
<span class="line-removed"> 295             // See http://bugs.icu-project.org/trac/ticket/12597</span>
<span class="line-removed"> 296             return;</span>
<span class="line-removed"> 297         }</span>
<span class="line-removed"> 298 </span>
<span class="line-removed"> 299         // We no longer handle units like &quot;coordinate&quot; here (which do not have plural variants)</span>
<span class="line-removed"> 300         if (value.getType() == URES_TABLE) {</span>
<span class="line-removed"> 301             // Units that have plural variants</span>
<span class="line-removed"> 302             ResourceTable patternTableTable = value.getTable(errorCode);</span>
<span class="line-removed"> 303             if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 304             for (int i = 0; patternTableTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed"> 305                 consumePattern(key, value, errorCode);</span>
<span class="line-removed"> 306             }</span>
<span class="line-removed"> 307         } else {</span>
<span class="line-removed"> 308             // TODO: How to handle unexpected data?</span>
<span class="line-removed"> 309             // See http://bugs.icu-project.org/trac/ticket/12597</span>
<span class="line-removed"> 310             return;</span>
<span class="line-removed"> 311         }</span>
<span class="line-removed"> 312     }</span>
<span class="line-removed"> 313 </span>
<span class="line-removed"> 314     /**</span>
<span class="line-removed"> 315      * Consume compound x-per-y display pattern. For example,</span>
<span class="line-removed"> 316      * unitsShort/compound/per may be &quot;{0}/{1}&quot;.</span>
<span class="line-removed"> 317      */</span>
<span class="line-removed"> 318     void consumeCompoundPattern(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 319         if (U_SUCCESS(errorCode) &amp;&amp; uprv_strcmp(key, &quot;per&quot;) == 0) {</span>
<span class="line-removed"> 320             cacheData.perFormatters[width].</span>
<span class="line-removed"> 321                     applyPatternMinMaxArguments(value.getUnicodeString(errorCode), 2, 2, errorCode);</span>
<span class="line-removed"> 322         }</span>
<span class="line-removed"> 323     }</span>
<span class="line-removed"> 324 </span>
<span class="line-removed"> 325     /**</span>
<span class="line-removed"> 326      * Consume a table of unit type tables. For example,</span>
<span class="line-removed"> 327      * unitsShort contains tables for area &amp; duration.</span>
<span class="line-removed"> 328      * It also contains a table for the compound/per pattern.</span>
<span class="line-removed"> 329      */</span>
<span class="line-removed"> 330     void consumeUnitTypesTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 331         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 332         if (uprv_strcmp(key, &quot;currency&quot;) == 0) {</span>
<span class="line-removed"> 333             // Skip.</span>
<span class="line-removed"> 334         } else if (uprv_strcmp(key, &quot;compound&quot;) == 0) {</span>
<span class="line-removed"> 335             if (!cacheData.hasPerFormatter(width)) {</span>
<span class="line-removed"> 336                 ResourceTable compoundTable = value.getTable(errorCode);</span>
<span class="line-removed"> 337                 if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 338                 for (int i = 0; compoundTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed"> 339                     consumeCompoundPattern(key, value, errorCode);</span>
<span class="line-removed"> 340                 }</span>
<span class="line-removed"> 341             }</span>
<span class="line-removed"> 342         } else if (uprv_strcmp(key, &quot;coordinate&quot;) == 0) {</span>
<span class="line-removed"> 343             // special handling but we need to determine what that is</span>
<span class="line-removed"> 344         } else {</span>
<span class="line-removed"> 345             type = key;</span>
<span class="line-removed"> 346             ResourceTable subtypeTable = value.getTable(errorCode);</span>
<span class="line-removed"> 347             if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 348             for (int i = 0; subtypeTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed"> 349                 consumeSubtypeTable(key, value, errorCode);</span>
<span class="line-removed"> 350             }</span>
<span class="line-removed"> 351         }</span>
<span class="line-removed"> 352     }</span>
<span class="line-removed"> 353 </span>
<span class="line-removed"> 354     void consumeAlias(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 355         // Handle aliases like</span>
<span class="line-removed"> 356         // units:alias{&quot;/LOCALE/unitsShort&quot;}</span>
<span class="line-removed"> 357         // which should only occur in the root bundle.</span>
<span class="line-removed"> 358         UMeasureFormatWidth sourceWidth = widthFromKey(key);</span>
<span class="line-removed"> 359         if (sourceWidth == UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed"> 360             // Alias from something we don&#39;t care about.</span>
<span class="line-removed"> 361             return;</span>
<span class="line-removed"> 362         }</span>
<span class="line-removed"> 363         UMeasureFormatWidth targetWidth = widthFromAlias(value, errorCode);</span>
<span class="line-removed"> 364         if (targetWidth == UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed"> 365             // We do not recognize what to fall back to.</span>
<span class="line-removed"> 366             errorCode = U_INVALID_FORMAT_ERROR;</span>
<span class="line-removed"> 367             return;</span>
<span class="line-removed"> 368         }</span>
<span class="line-removed"> 369         // Check that we do not fall back to another fallback.</span>
<span class="line-removed"> 370         if (cacheData.widthFallback[targetWidth] != UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed"> 371             errorCode = U_INVALID_FORMAT_ERROR;</span>
<span class="line-removed"> 372             return;</span>
<span class="line-removed"> 373         }</span>
<span class="line-removed"> 374         cacheData.widthFallback[sourceWidth] = targetWidth;</span>
<span class="line-removed"> 375     }</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377     void consumeTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 378         if (U_SUCCESS(errorCode) &amp;&amp; (width = widthFromKey(key)) != UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed"> 379             ResourceTable unitTypesTable = value.getTable(errorCode);</span>
<span class="line-removed"> 380             if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 381             for (int i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed"> 382                 consumeUnitTypesTable(key, value, errorCode);</span>
<span class="line-removed"> 383             }</span>
<span class="line-removed"> 384         }</span>
<span class="line-removed"> 385     }</span>
<span class="line-removed"> 386 </span>
<span class="line-removed"> 387     static UMeasureFormatWidth widthFromKey(const char *key) {</span>
<span class="line-removed"> 388         if (uprv_strncmp(key, &quot;units&quot;, 5) == 0) {</span>
<span class="line-removed"> 389             key += 5;</span>
<span class="line-removed"> 390             if (*key == 0) {</span>
<span class="line-removed"> 391                 return UMEASFMT_WIDTH_WIDE;</span>
<span class="line-removed"> 392             } else if (uprv_strcmp(key, &quot;Short&quot;) == 0) {</span>
<span class="line-removed"> 393                 return UMEASFMT_WIDTH_SHORT;</span>
<span class="line-removed"> 394             } else if (uprv_strcmp(key, &quot;Narrow&quot;) == 0) {</span>
<span class="line-removed"> 395                 return UMEASFMT_WIDTH_NARROW;</span>
<span class="line-removed"> 396             }</span>
<span class="line-removed"> 397         }</span>
<span class="line-removed"> 398         return UMEASFMT_WIDTH_COUNT;</span>
<span class="line-removed"> 399     }</span>
<span class="line-removed"> 400 </span>
<span class="line-removed"> 401     static UMeasureFormatWidth widthFromAlias(const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 402         int32_t length;</span>
<span class="line-removed"> 403         const UChar *s = value.getAliasString(length, errorCode);</span>
<span class="line-removed"> 404         // For example: &quot;/LOCALE/unitsShort&quot;</span>
<span class="line-removed"> 405         if (U_SUCCESS(errorCode) &amp;&amp; length &gt;= 13 &amp;&amp; u_memcmp(s, g_LOCALE_units, 13) == 0) {</span>
<span class="line-removed"> 406             s += 13;</span>
<span class="line-removed"> 407             length -= 13;</span>
<span class="line-removed"> 408             if (*s == 0) {</span>
<span class="line-removed"> 409                 return UMEASFMT_WIDTH_WIDE;</span>
<span class="line-removed"> 410             } else if (u_strCompare(s, length, gShort, 5, FALSE) == 0) {</span>
<span class="line-removed"> 411                 return UMEASFMT_WIDTH_SHORT;</span>
<span class="line-removed"> 412             } else if (u_strCompare(s, length, gNarrow, 6, FALSE) == 0) {</span>
<span class="line-removed"> 413                 return UMEASFMT_WIDTH_NARROW;</span>
<span class="line-removed"> 414             }</span>
<span class="line-removed"> 415         }</span>
<span class="line-removed"> 416         return UMEASFMT_WIDTH_COUNT;</span>
<span class="line-removed"> 417     }</span>
<span class="line-removed"> 418 </span>
<span class="line-removed"> 419     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,</span>
<span class="line-removed"> 420             UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 421         // Main entry point to sink</span>
<span class="line-removed"> 422         ResourceTable widthsTable = value.getTable(errorCode);</span>
<span class="line-removed"> 423         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 424         for (int i = 0; widthsTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed"> 425             if (value.getType() == URES_ALIAS) {</span>
<span class="line-removed"> 426                 consumeAlias(key, value, errorCode);</span>
<span class="line-removed"> 427             } else {</span>
<span class="line-removed"> 428                 consumeTable(key, value, errorCode);</span>
<span class="line-removed"> 429             }</span>
<span class="line-removed"> 430         }</span>
<span class="line-removed"> 431     }</span>
<span class="line-removed"> 432 };</span>
<span class="line-removed"> 433 </span>
<span class="line-removed"> 434 // Virtual destructors must be defined out of line.</span>
<span class="line-removed"> 435 UnitDataSink::~UnitDataSink() {}</span>
<span class="line-removed"> 436 </span>
<span class="line-removed"> 437 }  // namespace</span>
<span class="line-removed"> 438 </span>
<span class="line-removed"> 439 static UBool loadMeasureUnitData(</span>
<span class="line-removed"> 440         const UResourceBundle *resource,</span>
<span class="line-removed"> 441         MeasureFormatCacheData &amp;cacheData,</span>
<span class="line-removed"> 442         UErrorCode &amp;status) {</span>
<span class="line-removed"> 443     UnitDataSink sink(cacheData);</span>
<span class="line-removed"> 444     ures_getAllItemsWithFallback(resource, &quot;&quot;, sink, status);</span>
<span class="line-removed"> 445     return U_SUCCESS(status);</span>
<span class="line-removed"> 446 }</span>
<span class="line-removed"> 447 </span>
 448 static UnicodeString loadNumericDateFormatterPattern(
 449         const UResourceBundle *resource,
 450         const char *pattern,
 451         UErrorCode &amp;status) {
 452     UnicodeString result;
 453     if (U_FAILURE(status)) {
 454         return result;
 455     }
 456     CharString chs;
 457     chs.append(&quot;durationUnits&quot;, status)
 458             .append(&quot;/&quot;, status).append(pattern, status);
 459     LocalUResourceBundlePointer patternBundle(
 460             ures_getByKeyWithFallback(
 461                 resource,
 462                 chs.data(),
 463                 NULL,
 464                 &amp;status));
 465     if (U_FAILURE(status)) {
 466         return result;
 467     }
</pre>
<hr />
<pre>
 490         loadNumericDateFormatterPattern(resource, &quot;hms&quot;, status),
 491         status);
 492     if (U_FAILURE(status)) {
 493         delete result;
 494         return NULL;
 495     }
 496     return result;
 497 }
 498 
 499 template&lt;&gt; U_I18N_API
 500 const MeasureFormatCacheData *LocaleCacheKey&lt;MeasureFormatCacheData&gt;::createObject(
 501         const void * /*unused*/, UErrorCode &amp;status) const {
 502     const char *localeId = fLoc.getName();
 503     LocalUResourceBundlePointer unitsBundle(ures_open(U_ICUDATA_UNIT, localeId, &amp;status));
 504     static UNumberFormatStyle currencyStyles[] = {
 505             UNUM_CURRENCY_PLURAL, UNUM_CURRENCY_ISO, UNUM_CURRENCY};
 506     LocalPointer&lt;MeasureFormatCacheData&gt; result(new MeasureFormatCacheData(), status);
 507     if (U_FAILURE(status)) {
 508         return NULL;
 509     }
<span class="line-removed"> 510     if (!loadMeasureUnitData(</span>
<span class="line-removed"> 511             unitsBundle.getAlias(),</span>
<span class="line-removed"> 512             *result,</span>
<span class="line-removed"> 513             status)) {</span>
<span class="line-removed"> 514         return NULL;</span>
<span class="line-removed"> 515     }</span>
 516     result-&gt;adoptNumericDateFormatters(loadNumericDateFormatters(
 517             unitsBundle.getAlias(), status));
 518     if (U_FAILURE(status)) {
 519         return NULL;
 520     }
 521 
 522     for (int32_t i = 0; i &lt; WIDTH_INDEX_COUNT; ++i) {
 523         // NumberFormat::createInstance can erase warning codes from status, so pass it
 524         // a separate status instance
 525         UErrorCode localStatus = U_ZERO_ERROR;
 526         result-&gt;adoptCurrencyFormat(i, NumberFormat::createInstance(
 527                 localeId, currencyStyles[i], localStatus));
 528         if (localStatus != U_ZERO_ERROR) {
 529             status = localStatus;
 530         }
 531         if (U_FAILURE(status)) {
 532             return NULL;
 533         }
 534     }
 535     NumberFormat *inf = NumberFormat::createInstance(
</pre>
<hr />
<pre>
 601                 return 0;
 602             }
 603             hms[2] = measures[i].getNumber();
 604             if (hms[2].getDouble() &lt; 0.0) {
 605                 return 0;
 606             }
 607             result |= 4;
 608         } else {
 609             return 0;
 610         }
 611     }
 612     return result;
 613 }
 614 
 615 
 616 MeasureFormat::MeasureFormat(
 617         const Locale &amp;locale, UMeasureFormatWidth w, UErrorCode &amp;status)
 618         : cache(NULL),
 619           numberFormat(NULL),
 620           pluralRules(NULL),
<span class="line-modified"> 621           width(w),</span>
 622           listFormatter(NULL) {
 623     initMeasureFormat(locale, w, NULL, status);
 624 }
 625 
 626 MeasureFormat::MeasureFormat(
 627         const Locale &amp;locale,
 628         UMeasureFormatWidth w,
 629         NumberFormat *nfToAdopt,
 630         UErrorCode &amp;status)
 631         : cache(NULL),
 632           numberFormat(NULL),
 633           pluralRules(NULL),
<span class="line-modified"> 634           width(w),</span>
 635           listFormatter(NULL) {
 636     initMeasureFormat(locale, w, nfToAdopt, status);
 637 }
 638 
 639 MeasureFormat::MeasureFormat(const MeasureFormat &amp;other) :
 640         Format(other),
 641         cache(other.cache),
 642         numberFormat(other.numberFormat),
 643         pluralRules(other.pluralRules),
<span class="line-modified"> 644         width(other.width),</span>
 645         listFormatter(NULL) {
 646     cache-&gt;addRef();
 647     numberFormat-&gt;addRef();
 648     pluralRules-&gt;addRef();
 649     if (other.listFormatter != NULL) {
 650         listFormatter = new ListFormatter(*other.listFormatter);
 651     }
 652 }
 653 
 654 MeasureFormat &amp;MeasureFormat::operator=(const MeasureFormat &amp;other) {
 655     if (this == &amp;other) {
 656         return *this;
 657     }
 658     Format::operator=(other);
 659     SharedObject::copyPtr(other.cache, cache);
 660     SharedObject::copyPtr(other.numberFormat, numberFormat);
 661     SharedObject::copyPtr(other.pluralRules, pluralRules);
<span class="line-modified"> 662     width = other.width;</span>
 663     delete listFormatter;
 664     if (other.listFormatter != NULL) {
 665         listFormatter = new ListFormatter(*other.listFormatter);
 666     } else {
 667         listFormatter = NULL;
 668     }
 669     return *this;
 670 }
 671 
 672 MeasureFormat::MeasureFormat() :
 673         cache(NULL),
 674         numberFormat(NULL),
 675         pluralRules(NULL),
<span class="line-modified"> 676         width(UMEASFMT_WIDTH_SHORT),</span>
 677         listFormatter(NULL) {
 678 }
 679 
 680 MeasureFormat::~MeasureFormat() {
 681     if (cache != NULL) {
 682         cache-&gt;removeRef();
 683     }
 684     if (numberFormat != NULL) {
 685         numberFormat-&gt;removeRef();
 686     }
 687     if (pluralRules != NULL) {
 688         pluralRules-&gt;removeRef();
 689     }
 690     delete listFormatter;
 691 }
 692 
 693 UBool MeasureFormat::operator==(const Format &amp;other) const {
 694     if (this == &amp;other) { // Same object, equal
 695         return TRUE;
 696     }
 697     if (!Format::operator==(other)) {
 698         return FALSE;
 699     }
 700     const MeasureFormat &amp;rhs = static_cast&lt;const MeasureFormat &amp;&gt;(other);
 701 
 702     // Note: Since the ListFormatter depends only on Locale and width, we
 703     // don&#39;t have to check it here.
 704 
 705     // differing widths aren&#39;t equivalent
<span class="line-modified"> 706     if (width != rhs.width) {</span>
 707         return FALSE;
 708     }
 709     // Width the same check locales.
 710     // We don&#39;t need to check locales if both objects have same cache.
 711     if (cache != rhs.cache) {
 712         UErrorCode status = U_ZERO_ERROR;
 713         const char *localeId = getLocaleID(status);
 714         const char *rhsLocaleId = rhs.getLocaleID(status);
 715         if (U_FAILURE(status)) {
 716             // On failure, assume not equal
 717             return FALSE;
 718         }
 719         if (uprv_strcmp(localeId, rhsLocaleId) != 0) {
 720             return FALSE;
 721         }
 722     }
 723     // Locales same, check NumberFormat if shared data differs.
 724     return (
 725             numberFormat == rhs.numberFormat ||
 726             **numberFormat == **rhs.numberFormat);
</pre>
<hr />
<pre>
 747     status = U_ILLEGAL_ARGUMENT_ERROR;
 748     return appendTo;
 749 }
 750 
 751 void MeasureFormat::parseObject(
 752         const UnicodeString &amp; /*source*/,
 753         Formattable &amp; /*result*/,
 754         ParsePosition&amp; /*pos*/) const {
 755     return;
 756 }
 757 
 758 UnicodeString &amp;MeasureFormat::formatMeasurePerUnit(
 759         const Measure &amp;measure,
 760         const MeasureUnit &amp;perUnit,
 761         UnicodeString &amp;appendTo,
 762         FieldPosition &amp;pos,
 763         UErrorCode &amp;status) const {
 764     if (U_FAILURE(status)) {
 765         return appendTo;
 766     }
<span class="line-modified"> 767     bool isResolved = false;</span>
<span class="line-modified"> 768     MeasureUnit resolvedUnit =</span>
<span class="line-modified"> 769         MeasureUnit::resolveUnitPerUnit(measure.getUnit(), perUnit, &amp;isResolved);</span>
<span class="line-modified"> 770     if (isResolved) {</span>
<span class="line-removed"> 771         Measure newMeasure(measure.getNumber(), new MeasureUnit(resolvedUnit), status);</span>
<span class="line-removed"> 772         return formatMeasure(</span>
<span class="line-removed"> 773                 newMeasure, **numberFormat, appendTo, pos, status);</span>
<span class="line-removed"> 774     }</span>
<span class="line-removed"> 775     FieldPosition fpos(pos.getField());</span>
<span class="line-removed"> 776     UnicodeString result;</span>
<span class="line-removed"> 777     int32_t offset = withPerUnitAndAppend(</span>
<span class="line-removed"> 778             formatMeasure(</span>
<span class="line-removed"> 779                     measure, **numberFormat, result, fpos, status),</span>
<span class="line-removed"> 780             perUnit,</span>
<span class="line-removed"> 781             appendTo,</span>
<span class="line-removed"> 782             status);</span>
<span class="line-removed"> 783     if (U_FAILURE(status)) {</span>
 784         return appendTo;
 785     }
<span class="line-modified"> 786     if (fpos.getBeginIndex() != 0 || fpos.getEndIndex() != 0) {</span>
<span class="line-modified"> 787         pos.setBeginIndex(fpos.getBeginIndex() + offset);</span>
<span class="line-modified"> 788         pos.setEndIndex(fpos.getEndIndex() + offset);</span>



 789     }


 790     return appendTo;
 791 }
 792 
 793 UnicodeString &amp;MeasureFormat::formatMeasures(
 794         const Measure *measures,
 795         int32_t measureCount,
 796         UnicodeString &amp;appendTo,
 797         FieldPosition &amp;pos,
 798         UErrorCode &amp;status) const {
 799     if (U_FAILURE(status)) {
 800         return appendTo;
 801     }
 802     if (measureCount == 0) {
 803         return appendTo;
 804     }
 805     if (measureCount == 1) {
 806         return formatMeasure(measures[0], **numberFormat, appendTo, pos, status);
 807     }
<span class="line-modified"> 808     if (width == UMEASFMT_WIDTH_NUMERIC) {</span>
 809         Formattable hms[3];
 810         int32_t bitMap = toHMS(measures, measureCount, hms, status);
 811         if (bitMap &gt; 0) {
 812             return formatNumeric(hms, bitMap, appendTo, status);
 813         }
 814     }
 815     if (pos.getField() != FieldPosition::DONT_CARE) {
 816         return formatMeasuresSlowTrack(
 817                 measures, measureCount, appendTo, pos, status);
 818     }
 819     UnicodeString *results = new UnicodeString[measureCount];
 820     if (results == NULL) {
 821         status = U_MEMORY_ALLOCATION_ERROR;
 822         return appendTo;
 823     }
 824     for (int32_t i = 0; i &lt; measureCount; ++i) {
 825         const NumberFormat *nf = cache-&gt;getIntegerFormat();
 826         if (i == measureCount - 1) {
 827             nf = numberFormat-&gt;get();
 828         }
 829         formatMeasure(
 830                 measures[i],
 831                 *nf,
 832                 results[i],
 833                 pos,
 834                 status);
 835     }
 836     listFormatter-&gt;format(results, measureCount, appendTo, status);
 837     delete [] results;
 838     return appendTo;
 839 }
 840 
<span class="line-modified"> 841 UnicodeString MeasureFormat::getUnitDisplayName(const MeasureUnit&amp; unit, UErrorCode&amp; /*status*/) const {</span>
<span class="line-modified"> 842     UMeasureFormatWidth width = getRegularWidth(this-&gt;width);</span>
<span class="line-modified"> 843     const UChar* const* styleToDnam = cache-&gt;dnams[unit.getIndex()];</span>
<span class="line-modified"> 844     const UChar* dnam = styleToDnam[width];</span>
<span class="line-modified"> 845     if (dnam == NULL) {</span>
<span class="line-modified"> 846         int32_t fallbackWidth = cache-&gt;widthFallback[width];</span>
<span class="line-removed"> 847         dnam = styleToDnam[fallbackWidth];</span>
<span class="line-removed"> 848     }</span>
<span class="line-removed"> 849 </span>
<span class="line-removed"> 850     UnicodeString result;</span>
<span class="line-removed"> 851     if (dnam == NULL) {</span>
<span class="line-removed"> 852         result.setToBogus();</span>
<span class="line-removed"> 853     } else {</span>
<span class="line-removed"> 854         result.setTo(dnam, -1);</span>
<span class="line-removed"> 855     }</span>
<span class="line-removed"> 856     return result;</span>
 857 }
 858 
 859 void MeasureFormat::initMeasureFormat(
 860         const Locale &amp;locale,
 861         UMeasureFormatWidth w,
 862         NumberFormat *nfToAdopt,
 863         UErrorCode &amp;status) {
 864     static const char *listStyles[] = {&quot;unit&quot;, &quot;unit-short&quot;, &quot;unit-narrow&quot;};
 865     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
 866     if (U_FAILURE(status)) {
 867         return;
 868     }
 869     const char *name = locale.getName();
 870     setLocaleIDs(name, name);
 871 
 872     UnifiedCache::getByLocale(locale, cache, status);
 873     if (U_FAILURE(status)) {
 874         return;
 875     }
 876 
 877     const SharedPluralRules *pr = PluralRules::createSharedInstance(
 878             locale, UPLURAL_TYPE_CARDINAL, status);
 879     if (U_FAILURE(status)) {
 880         return;
 881     }
 882     SharedObject::copyPtr(pr, pluralRules);
 883     pr-&gt;removeRef();
 884     if (nf.isNull()) {

 885         const SharedNumberFormat *shared = NumberFormat::createSharedInstance(
 886                 locale, UNUM_DECIMAL, status);
 887         if (U_FAILURE(status)) {
 888             return;
 889         }
 890         SharedObject::copyPtr(shared, numberFormat);
 891         shared-&gt;removeRef();
 892     } else {
 893         adoptNumberFormat(nf.orphan(), status);
 894         if (U_FAILURE(status)) {
 895             return;
 896         }
 897     }
<span class="line-modified"> 898     width = w;</span>
 899     delete listFormatter;
 900     listFormatter = ListFormatter::createInstance(
 901             locale,
<span class="line-modified"> 902             listStyles[getRegularWidth(width)],</span>
 903             status);
 904 }
 905 
 906 void MeasureFormat::adoptNumberFormat(
 907         NumberFormat *nfToAdopt, UErrorCode &amp;status) {
 908     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
 909     if (U_FAILURE(status)) {
 910         return;
 911     }
 912     SharedNumberFormat *shared = new SharedNumberFormat(nf.getAlias());
 913     if (shared == NULL) {
 914         status = U_MEMORY_ALLOCATION_ERROR;
 915         return;
 916     }
 917     nf.orphan();
 918     SharedObject::copyPtr(shared, numberFormat);
 919 }
 920 
 921 UBool MeasureFormat::setMeasureFormatLocale(const Locale &amp;locale, UErrorCode &amp;status) {
 922     if (U_FAILURE(status) || locale == getLocale(status)) {
 923         return FALSE;
 924     }
<span class="line-modified"> 925     initMeasureFormat(locale, width, NULL, status);</span>
 926     return U_SUCCESS(status);
 927 }
 928 
<span class="line-modified"> 929 const NumberFormat &amp;MeasureFormat::getNumberFormat() const {</span>
 930     return **numberFormat;
 931 }
 932 




 933 const PluralRules &amp;MeasureFormat::getPluralRules() const {
 934     return **pluralRules;
 935 }
 936 
 937 Locale MeasureFormat::getLocale(UErrorCode &amp;status) const {
 938     return Format::getLocale(ULOC_VALID_LOCALE, status);
 939 }
 940 
 941 const char *MeasureFormat::getLocaleID(UErrorCode &amp;status) const {
 942     return Format::getLocaleID(ULOC_VALID_LOCALE, status);
 943 }
 944 
 945 UnicodeString &amp;MeasureFormat::formatMeasure(
 946         const Measure &amp;measure,
 947         const NumberFormat &amp;nf,
 948         UnicodeString &amp;appendTo,
 949         FieldPosition &amp;pos,
 950         UErrorCode &amp;status) const {
 951     if (U_FAILURE(status)) {
 952         return appendTo;
 953     }
 954     const Formattable&amp; amtNumber = measure.getNumber();
 955     const MeasureUnit&amp; amtUnit = measure.getUnit();
 956     if (isCurrency(amtUnit)) {
 957         UChar isoCode[4];
 958         u_charsToUChars(amtUnit.getSubtype(), isoCode, 4);
<span class="line-modified"> 959         return cache-&gt;getCurrencyFormat(width)-&gt;format(</span>
 960                 new CurrencyAmount(amtNumber, isoCode, status),
 961                 appendTo,
 962                 pos,
 963                 status);
 964     }
<span class="line-modified"> 965     UnicodeString formattedNumber;</span>
<span class="line-modified"> 966     StandardPlural::Form pluralForm = QuantityFormatter::selectPlural(</span>
<span class="line-modified"> 967             amtNumber, nf, **pluralRules, formattedNumber, pos, status);</span>
<span class="line-modified"> 968     const SimpleFormatter *formatter = getPluralFormatter(amtUnit, width, pluralForm, status);</span>
<span class="line-modified"> 969     return QuantityFormatter::format(*formatter, formattedNumber, appendTo, pos, status);</span>










 970 }
 971 
 972 // Formats hours-minutes-seconds as 5:37:23 or similar.
 973 UnicodeString &amp;MeasureFormat::formatNumeric(
 974         const Formattable *hms,  // always length 3
 975         int32_t bitMap,   // 1=hourset, 2=minuteset, 4=secondset
 976         UnicodeString &amp;appendTo,
 977         UErrorCode &amp;status) const {
 978     if (U_FAILURE(status)) {
 979         return appendTo;
 980     }
 981     UDate millis =
 982         (UDate) (((uprv_trunc(hms[0].getDouble(status)) * 60.0
 983              + uprv_trunc(hms[1].getDouble(status))) * 60.0
 984                   + uprv_trunc(hms[2].getDouble(status))) * 1000.0);
 985     switch (bitMap) {
 986     case 5: // hs
 987     case 7: // hms
 988         return formatNumeric(
 989                 millis,
</pre>
<hr />
<pre>
 999                 cache-&gt;getNumericDateFormatters()-&gt;minuteSecond,
1000                 UDAT_SECOND_FIELD,
1001                 hms[2],
1002                 appendTo,
1003                 status);
1004         break;
1005     case 3: // hm
1006         return formatNumeric(
1007                 millis,
1008                 cache-&gt;getNumericDateFormatters()-&gt;hourMinute,
1009                 UDAT_MINUTE_FIELD,
1010                 hms[1],
1011                 appendTo,
1012                 status);
1013         break;
1014     default:
1015         status = U_INTERNAL_PROGRAM_ERROR;
1016         return appendTo;
1017         break;
1018     }
<span class="line-removed">1019     return appendTo;</span>
1020 }
1021 
1022 static void appendRange(
1023         const UnicodeString &amp;src,
1024         int32_t start,
1025         int32_t end,
1026         UnicodeString &amp;dest) {
1027     dest.append(src, start, end - start);
1028 }
1029 
1030 static void appendRange(
1031         const UnicodeString &amp;src,
1032         int32_t end,
1033         UnicodeString &amp;dest) {
1034     dest.append(src, end, src.length() - end);
1035 }
1036 
1037 // Formats time like 5:37:23
1038 UnicodeString &amp;MeasureFormat::formatNumeric(
1039         UDate date, // Time since epoch 1:30:00 would be 5400000
</pre>
<hr />
<pre>
1085                 appendTo);
1086         appendRange(
1087                 draft,
1088                 smallestFieldPosition.getBeginIndex(),
1089                 smallestFieldPosition.getEndIndex(),
1090                 appendTo);
1091         appendRange(
1092                 smallestAmountFormatted,
1093                 intFieldPosition.getEndIndex(),
1094                 appendTo);
1095         appendRange(
1096                 draft,
1097                 smallestFieldPosition.getEndIndex(),
1098                 appendTo);
1099     } else {
1100         appendTo.append(draft);
1101     }
1102     return appendTo;
1103 }
1104 
<span class="line-removed">1105 const SimpleFormatter *MeasureFormat::getFormatterOrNull(</span>
<span class="line-removed">1106         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index) const {</span>
<span class="line-removed">1107     width = getRegularWidth(width);</span>
<span class="line-removed">1108     SimpleFormatter *const (*unitPatterns)[PATTERN_COUNT] = &amp;cache-&gt;patterns[unit.getIndex()][0];</span>
<span class="line-removed">1109     if (unitPatterns[width][index] != NULL) {</span>
<span class="line-removed">1110         return unitPatterns[width][index];</span>
<span class="line-removed">1111     }</span>
<span class="line-removed">1112     int32_t fallbackWidth = cache-&gt;widthFallback[width];</span>
<span class="line-removed">1113     if (fallbackWidth != UMEASFMT_WIDTH_COUNT &amp;&amp; unitPatterns[fallbackWidth][index] != NULL) {</span>
<span class="line-removed">1114         return unitPatterns[fallbackWidth][index];</span>
<span class="line-removed">1115     }</span>
<span class="line-removed">1116     return NULL;</span>
<span class="line-removed">1117 }</span>
<span class="line-removed">1118 </span>
<span class="line-removed">1119 const SimpleFormatter *MeasureFormat::getFormatter(</span>
<span class="line-removed">1120         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index,</span>
<span class="line-removed">1121         UErrorCode &amp;errorCode) const {</span>
<span class="line-removed">1122     if (U_FAILURE(errorCode)) {</span>
<span class="line-removed">1123         return NULL;</span>
<span class="line-removed">1124     }</span>
<span class="line-removed">1125     const SimpleFormatter *pattern = getFormatterOrNull(unit, width, index);</span>
<span class="line-removed">1126     if (pattern == NULL) {</span>
<span class="line-removed">1127         errorCode = U_MISSING_RESOURCE_ERROR;</span>
<span class="line-removed">1128     }</span>
<span class="line-removed">1129     return pattern;</span>
<span class="line-removed">1130 }</span>
<span class="line-removed">1131 </span>
<span class="line-removed">1132 const SimpleFormatter *MeasureFormat::getPluralFormatter(</span>
<span class="line-removed">1133         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index,</span>
<span class="line-removed">1134         UErrorCode &amp;errorCode) const {</span>
<span class="line-removed">1135     if (U_FAILURE(errorCode)) {</span>
<span class="line-removed">1136         return NULL;</span>
<span class="line-removed">1137     }</span>
<span class="line-removed">1138     if (index != StandardPlural::OTHER) {</span>
<span class="line-removed">1139         const SimpleFormatter *pattern = getFormatterOrNull(unit, width, index);</span>
<span class="line-removed">1140         if (pattern != NULL) {</span>
<span class="line-removed">1141             return pattern;</span>
<span class="line-removed">1142         }</span>
<span class="line-removed">1143     }</span>
<span class="line-removed">1144     return getFormatter(unit, width, StandardPlural::OTHER, errorCode);</span>
<span class="line-removed">1145 }</span>
<span class="line-removed">1146 </span>
<span class="line-removed">1147 const SimpleFormatter *MeasureFormat::getPerFormatter(</span>
<span class="line-removed">1148         UMeasureFormatWidth width,</span>
<span class="line-removed">1149         UErrorCode &amp;status) const {</span>
<span class="line-removed">1150     if (U_FAILURE(status)) {</span>
<span class="line-removed">1151         return NULL;</span>
<span class="line-removed">1152     }</span>
<span class="line-removed">1153     width = getRegularWidth(width);</span>
<span class="line-removed">1154     const SimpleFormatter * perFormatters = cache-&gt;perFormatters;</span>
<span class="line-removed">1155     if (perFormatters[width].getArgumentLimit() == 2) {</span>
<span class="line-removed">1156         return &amp;perFormatters[width];</span>
<span class="line-removed">1157     }</span>
<span class="line-removed">1158     int32_t fallbackWidth = cache-&gt;widthFallback[width];</span>
<span class="line-removed">1159     if (fallbackWidth != UMEASFMT_WIDTH_COUNT &amp;&amp;</span>
<span class="line-removed">1160             perFormatters[fallbackWidth].getArgumentLimit() == 2) {</span>
<span class="line-removed">1161         return &amp;perFormatters[fallbackWidth];</span>
<span class="line-removed">1162     }</span>
<span class="line-removed">1163     status = U_MISSING_RESOURCE_ERROR;</span>
<span class="line-removed">1164     return NULL;</span>
<span class="line-removed">1165 }</span>
<span class="line-removed">1166 </span>
<span class="line-removed">1167 int32_t MeasureFormat::withPerUnitAndAppend(</span>
<span class="line-removed">1168         const UnicodeString &amp;formatted,</span>
<span class="line-removed">1169         const MeasureUnit &amp;perUnit,</span>
<span class="line-removed">1170         UnicodeString &amp;appendTo,</span>
<span class="line-removed">1171         UErrorCode &amp;status) const {</span>
<span class="line-removed">1172     int32_t offset = -1;</span>
<span class="line-removed">1173     if (U_FAILURE(status)) {</span>
<span class="line-removed">1174         return offset;</span>
<span class="line-removed">1175     }</span>
<span class="line-removed">1176     const SimpleFormatter *perUnitFormatter = getFormatterOrNull(perUnit, width, PER_UNIT_INDEX);</span>
<span class="line-removed">1177     if (perUnitFormatter != NULL) {</span>
<span class="line-removed">1178         const UnicodeString *params[] = {&amp;formatted};</span>
<span class="line-removed">1179         perUnitFormatter-&gt;formatAndAppend(</span>
<span class="line-removed">1180                 params,</span>
<span class="line-removed">1181                 UPRV_LENGTHOF(params),</span>
<span class="line-removed">1182                 appendTo,</span>
<span class="line-removed">1183                 &amp;offset,</span>
<span class="line-removed">1184                 1,</span>
<span class="line-removed">1185                 status);</span>
<span class="line-removed">1186         return offset;</span>
<span class="line-removed">1187     }</span>
<span class="line-removed">1188     const SimpleFormatter *perFormatter = getPerFormatter(width, status);</span>
<span class="line-removed">1189     const SimpleFormatter *pattern =</span>
<span class="line-removed">1190             getPluralFormatter(perUnit, width, StandardPlural::ONE, status);</span>
<span class="line-removed">1191     if (U_FAILURE(status)) {</span>
<span class="line-removed">1192         return offset;</span>
<span class="line-removed">1193     }</span>
<span class="line-removed">1194     UnicodeString perUnitString = pattern-&gt;getTextWithNoArguments();</span>
<span class="line-removed">1195     perUnitString.trim();</span>
<span class="line-removed">1196     const UnicodeString *params[] = {&amp;formatted, &amp;perUnitString};</span>
<span class="line-removed">1197     perFormatter-&gt;formatAndAppend(</span>
<span class="line-removed">1198             params,</span>
<span class="line-removed">1199             UPRV_LENGTHOF(params),</span>
<span class="line-removed">1200             appendTo,</span>
<span class="line-removed">1201             &amp;offset,</span>
<span class="line-removed">1202             1,</span>
<span class="line-removed">1203             status);</span>
<span class="line-removed">1204     return offset;</span>
<span class="line-removed">1205 }</span>
<span class="line-removed">1206 </span>
1207 UnicodeString &amp;MeasureFormat::formatMeasuresSlowTrack(
1208         const Measure *measures,
1209         int32_t measureCount,
1210         UnicodeString&amp; appendTo,
1211         FieldPosition&amp; pos,
1212         UErrorCode&amp; status) const {
1213     if (U_FAILURE(status)) {
1214         return appendTo;
1215     }
1216     FieldPosition dontCare(FieldPosition::DONT_CARE);
1217     FieldPosition fpos(pos.getField());
<span class="line-modified">1218     UnicodeString *results = new UnicodeString[measureCount];</span>
1219     int32_t fieldPositionFoundIndex = -1;
1220     for (int32_t i = 0; i &lt; measureCount; ++i) {
1221         const NumberFormat *nf = cache-&gt;getIntegerFormat();
1222         if (i == measureCount - 1) {
1223             nf = numberFormat-&gt;get();
1224         }
1225         if (fieldPositionFoundIndex == -1) {
1226             formatMeasure(measures[i], *nf, results[i], fpos, status);
1227             if (U_FAILURE(status)) {
<span class="line-removed">1228                 delete [] results;</span>
1229                 return appendTo;
1230             }
1231             if (fpos.getBeginIndex() != 0 || fpos.getEndIndex() != 0) {
1232                 fieldPositionFoundIndex = i;
1233             }
1234         } else {
1235             formatMeasure(measures[i], *nf, results[i], dontCare, status);
1236         }
1237     }
1238     int32_t offset;
1239     listFormatter-&gt;format(
<span class="line-modified">1240             results,</span>
1241             measureCount,
1242             appendTo,
1243             fieldPositionFoundIndex,
1244             offset,
1245             status);
1246     if (U_FAILURE(status)) {
<span class="line-removed">1247         delete [] results;</span>
1248         return appendTo;
1249     }

1250     if (offset != -1) {
1251         pos.setBeginIndex(fpos.getBeginIndex() + offset);
1252         pos.setEndIndex(fpos.getEndIndex() + offset);
1253     }
<span class="line-removed">1254     delete [] results;</span>
1255     return appendTo;
1256 }
1257 
1258 MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(const Locale&amp; locale,
1259                                                    UErrorCode&amp; ec) {
<span class="line-modified">1260     CurrencyFormat* fmt = NULL;</span>
<span class="line-modified">1261     if (U_SUCCESS(ec)) {</span>
<span class="line-removed">1262         fmt = new CurrencyFormat(locale, ec);</span>
<span class="line-removed">1263         if (U_FAILURE(ec)) {</span>
<span class="line-removed">1264             delete fmt;</span>
<span class="line-removed">1265             fmt = NULL;</span>
<span class="line-removed">1266         }</span>
1267     }
<span class="line-modified">1268     return fmt;</span>

1269 }
1270 
1271 MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(UErrorCode&amp; ec) {
1272     if (U_FAILURE(ec)) {
<span class="line-modified">1273         return NULL;</span>
1274     }
1275     return MeasureFormat::createCurrencyFormat(Locale::getDefault(), ec);
1276 }
1277 
1278 U_NAMESPACE_END
1279 
1280 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
<td>
<hr />
<pre>
  19 #include &quot;unicode/numfmt.h&quot;
  20 #include &quot;currfmt.h&quot;
  21 #include &quot;unicode/localpointer.h&quot;
  22 #include &quot;resource.h&quot;
  23 #include &quot;unicode/simpleformatter.h&quot;
  24 #include &quot;quantityformatter.h&quot;
  25 #include &quot;unicode/plurrule.h&quot;
  26 #include &quot;unicode/decimfmt.h&quot;
  27 #include &quot;uresimp.h&quot;
  28 #include &quot;unicode/ures.h&quot;
  29 #include &quot;unicode/ustring.h&quot;
  30 #include &quot;ureslocs.h&quot;
  31 #include &quot;cstring.h&quot;
  32 #include &quot;mutex.h&quot;
  33 #include &quot;ucln_in.h&quot;
  34 #include &quot;unicode/listformatter.h&quot;
  35 #include &quot;charstr.h&quot;
  36 #include &quot;unicode/putil.h&quot;
  37 #include &quot;unicode/smpdtfmt.h&quot;
  38 #include &quot;uassert.h&quot;
<span class="line-added">  39 #include &quot;unicode/numberformatter.h&quot;</span>
<span class="line-added">  40 #include &quot;number_longnames.h&quot;</span>
  41 
  42 #include &quot;sharednumberformat.h&quot;
  43 #include &quot;sharedpluralrules.h&quot;
  44 #include &quot;standardplural.h&quot;
  45 #include &quot;unifiedcache.h&quot;
  46 
  47 
  48 U_NAMESPACE_BEGIN
  49 



  50 static constexpr int32_t WIDTH_INDEX_COUNT = UMEASFMT_WIDTH_NARROW + 1;
  51 
  52 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(MeasureFormat)
  53 
  54 // Used to format durations like 5:47 or 21:35:42.
  55 class NumericDateFormatters : public UMemory {
  56 public:
  57     // Formats like H:mm
  58     SimpleDateFormat hourMinute;
  59 
  60     // formats like M:ss
  61     SimpleDateFormat minuteSecond;
  62 
  63     // formats like H:mm:ss
  64     SimpleDateFormat hourMinuteSecond;
  65 
  66     // Constructor that takes the actual patterns for hour-minute,
  67     // minute-second, and hour-minute-second respectively.
  68     NumericDateFormatters(
  69             const UnicodeString &amp;hm,
</pre>
<hr />
<pre>
  73             hourMinute(hm, status),
  74             minuteSecond(ms, status),
  75             hourMinuteSecond(hms, status) {
  76         const TimeZone *gmt = TimeZone::getGMT();
  77         hourMinute.setTimeZone(*gmt);
  78         minuteSecond.setTimeZone(*gmt);
  79         hourMinuteSecond.setTimeZone(*gmt);
  80     }
  81 private:
  82     NumericDateFormatters(const NumericDateFormatters &amp;other);
  83     NumericDateFormatters &amp;operator=(const NumericDateFormatters &amp;other);
  84 };
  85 
  86 static UMeasureFormatWidth getRegularWidth(UMeasureFormatWidth width) {
  87     if (width &gt;= WIDTH_INDEX_COUNT) {
  88         return UMEASFMT_WIDTH_NARROW;
  89     }
  90     return width;
  91 }
  92 
<span class="line-added">  93 static UNumberUnitWidth getUnitWidth(UMeasureFormatWidth width) {</span>
<span class="line-added">  94     switch (width) {</span>
<span class="line-added">  95     case UMEASFMT_WIDTH_WIDE:</span>
<span class="line-added">  96         return UNUM_UNIT_WIDTH_FULL_NAME;</span>
<span class="line-added">  97     case UMEASFMT_WIDTH_NARROW:</span>
<span class="line-added">  98     case UMEASFMT_WIDTH_NUMERIC:</span>
<span class="line-added">  99         return UNUM_UNIT_WIDTH_NARROW;</span>
<span class="line-added"> 100     case UMEASFMT_WIDTH_SHORT:</span>
<span class="line-added"> 101     default:</span>
<span class="line-added"> 102         return UNUM_UNIT_WIDTH_SHORT;</span>
<span class="line-added"> 103     }</span>
<span class="line-added"> 104 }</span>
<span class="line-added"> 105 </span>
 106 /**
 107  * Instances contain all MeasureFormat specific data for a particular locale.
 108  * This data is cached. It is never copied, but is shared via shared pointers.
 109  *
 110  * Note: We might change the cache data to have an array[WIDTH_INDEX_COUNT] of
 111  * complete sets of unit &amp; per patterns,
 112  * to correspond to the resource data and its aliases.
 113  *
 114  * TODO: Maybe store more sparsely in general, with pointers rather than potentially-empty objects.
 115  */
 116 class MeasureFormatCacheData : public SharedObject {
 117 public:
 118 
 119     /**
 120      * Redirection data from root-bundle, top-level sideways aliases.
 121      * - UMEASFMT_WIDTH_COUNT: initial value, just fall back to root
 122      * - UMEASFMT_WIDTH_WIDE/SHORT/NARROW: sideways alias for missing data
 123      */
 124     UMeasureFormatWidth widthFallback[WIDTH_INDEX_COUNT];




 125 
 126     MeasureFormatCacheData();
 127     virtual ~MeasureFormatCacheData();
 128 






 129     void adoptCurrencyFormat(int32_t widthIndex, NumberFormat *nfToAdopt) {
 130         delete currencyFormats[widthIndex];
 131         currencyFormats[widthIndex] = nfToAdopt;
 132     }
 133     const NumberFormat *getCurrencyFormat(UMeasureFormatWidth width) const {
 134         return currencyFormats[getRegularWidth(width)];
 135     }
 136     void adoptIntegerFormat(NumberFormat *nfToAdopt) {
 137         delete integerFormat;
 138         integerFormat = nfToAdopt;
 139     }
 140     const NumberFormat *getIntegerFormat() const {
 141         return integerFormat;
 142     }
 143     void adoptNumericDateFormatters(NumericDateFormatters *formattersToAdopt) {
 144         delete numericDateFormatters;
 145         numericDateFormatters = formattersToAdopt;
 146     }
 147     const NumericDateFormatters *getNumericDateFormatters() const {
 148         return numericDateFormatters;



 162     for (int32_t i = 0; i &lt; WIDTH_INDEX_COUNT; ++i) {
 163         widthFallback[i] = UMEASFMT_WIDTH_COUNT;
 164     }


 165     memset(currencyFormats, 0, sizeof(currencyFormats));
 166 }
 167 
 168 MeasureFormatCacheData::~MeasureFormatCacheData() {
 169     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(currencyFormats); ++i) {
 170         delete currencyFormats[i];
 171     }







 172     // Note: the contents of &#39;dnams&#39; are pointers into the resource bundle
 173     delete integerFormat;
 174     delete numericDateFormatters;
 175 }
 176 
 177 static UBool isCurrency(const MeasureUnit &amp;unit) {
 178     return (uprv_strcmp(unit.getType(), &quot;currency&quot;) == 0);
 179 }
 180 
 181 static UBool getString(
 182         const UResourceBundle *resource,
 183         UnicodeString &amp;result,
 184         UErrorCode &amp;status) {
 185     int32_t len = 0;
 186     const UChar *resStr = ures_getString(resource, &amp;len, &amp;status);
 187     if (U_FAILURE(status)) {
 188         return FALSE;
 189     }
 190     result.setTo(TRUE, resStr, len);
 191     return TRUE;




















































































































































































































































 194 static UnicodeString loadNumericDateFormatterPattern(
 195         const UResourceBundle *resource,
 196         const char *pattern,
 197         UErrorCode &amp;status) {
 198     UnicodeString result;
 199     if (U_FAILURE(status)) {
 200         return result;
 201     }
 202     CharString chs;
 203     chs.append(&quot;durationUnits&quot;, status)
 204             .append(&quot;/&quot;, status).append(pattern, status);
 205     LocalUResourceBundlePointer patternBundle(
 206             ures_getByKeyWithFallback(
 207                 resource,
 208                 chs.data(),
 209                 NULL,
 210                 &amp;status));
 211     if (U_FAILURE(status)) {
 212         return result;
 213     }
</pre>
<hr />
<pre>
 236         loadNumericDateFormatterPattern(resource, &quot;hms&quot;, status),
 237         status);
 238     if (U_FAILURE(status)) {
 239         delete result;
 240         return NULL;
 241     }
 242     return result;
 243 }
 244 
 245 template&lt;&gt; U_I18N_API
 246 const MeasureFormatCacheData *LocaleCacheKey&lt;MeasureFormatCacheData&gt;::createObject(
 247         const void * /*unused*/, UErrorCode &amp;status) const {
 248     const char *localeId = fLoc.getName();
 249     LocalUResourceBundlePointer unitsBundle(ures_open(U_ICUDATA_UNIT, localeId, &amp;status));
 250     static UNumberFormatStyle currencyStyles[] = {
 251             UNUM_CURRENCY_PLURAL, UNUM_CURRENCY_ISO, UNUM_CURRENCY};
 252     LocalPointer&lt;MeasureFormatCacheData&gt; result(new MeasureFormatCacheData(), status);
 253     if (U_FAILURE(status)) {
 254         return NULL;
 255     }






 256     result-&gt;adoptNumericDateFormatters(loadNumericDateFormatters(
 257             unitsBundle.getAlias(), status));
 258     if (U_FAILURE(status)) {
 259         return NULL;
 260     }
 261 
 262     for (int32_t i = 0; i &lt; WIDTH_INDEX_COUNT; ++i) {
 263         // NumberFormat::createInstance can erase warning codes from status, so pass it
 264         // a separate status instance
 265         UErrorCode localStatus = U_ZERO_ERROR;
 266         result-&gt;adoptCurrencyFormat(i, NumberFormat::createInstance(
 267                 localeId, currencyStyles[i], localStatus));
 268         if (localStatus != U_ZERO_ERROR) {
 269             status = localStatus;
 270         }
 271         if (U_FAILURE(status)) {
 272             return NULL;
 273         }
 274     }
 275     NumberFormat *inf = NumberFormat::createInstance(
</pre>
<hr />
<pre>
 341                 return 0;
 342             }
 343             hms[2] = measures[i].getNumber();
 344             if (hms[2].getDouble() &lt; 0.0) {
 345                 return 0;
 346             }
 347             result |= 4;
 348         } else {
 349             return 0;
 350         }
 351     }
 352     return result;
 353 }
 354 
 355 
 356 MeasureFormat::MeasureFormat(
 357         const Locale &amp;locale, UMeasureFormatWidth w, UErrorCode &amp;status)
 358         : cache(NULL),
 359           numberFormat(NULL),
 360           pluralRules(NULL),
<span class="line-modified"> 361           fWidth(w),</span>
 362           listFormatter(NULL) {
 363     initMeasureFormat(locale, w, NULL, status);
 364 }
 365 
 366 MeasureFormat::MeasureFormat(
 367         const Locale &amp;locale,
 368         UMeasureFormatWidth w,
 369         NumberFormat *nfToAdopt,
 370         UErrorCode &amp;status)
 371         : cache(NULL),
 372           numberFormat(NULL),
 373           pluralRules(NULL),
<span class="line-modified"> 374           fWidth(w),</span>
 375           listFormatter(NULL) {
 376     initMeasureFormat(locale, w, nfToAdopt, status);
 377 }
 378 
 379 MeasureFormat::MeasureFormat(const MeasureFormat &amp;other) :
 380         Format(other),
 381         cache(other.cache),
 382         numberFormat(other.numberFormat),
 383         pluralRules(other.pluralRules),
<span class="line-modified"> 384         fWidth(other.fWidth),</span>
 385         listFormatter(NULL) {
 386     cache-&gt;addRef();
 387     numberFormat-&gt;addRef();
 388     pluralRules-&gt;addRef();
 389     if (other.listFormatter != NULL) {
 390         listFormatter = new ListFormatter(*other.listFormatter);
 391     }
 392 }
 393 
 394 MeasureFormat &amp;MeasureFormat::operator=(const MeasureFormat &amp;other) {
 395     if (this == &amp;other) {
 396         return *this;
 397     }
 398     Format::operator=(other);
 399     SharedObject::copyPtr(other.cache, cache);
 400     SharedObject::copyPtr(other.numberFormat, numberFormat);
 401     SharedObject::copyPtr(other.pluralRules, pluralRules);
<span class="line-modified"> 402     fWidth = other.fWidth;</span>
 403     delete listFormatter;
 404     if (other.listFormatter != NULL) {
 405         listFormatter = new ListFormatter(*other.listFormatter);
 406     } else {
 407         listFormatter = NULL;
 408     }
 409     return *this;
 410 }
 411 
 412 MeasureFormat::MeasureFormat() :
 413         cache(NULL),
 414         numberFormat(NULL),
 415         pluralRules(NULL),
<span class="line-modified"> 416         fWidth(UMEASFMT_WIDTH_SHORT),</span>
 417         listFormatter(NULL) {
 418 }
 419 
 420 MeasureFormat::~MeasureFormat() {
 421     if (cache != NULL) {
 422         cache-&gt;removeRef();
 423     }
 424     if (numberFormat != NULL) {
 425         numberFormat-&gt;removeRef();
 426     }
 427     if (pluralRules != NULL) {
 428         pluralRules-&gt;removeRef();
 429     }
 430     delete listFormatter;
 431 }
 432 
 433 UBool MeasureFormat::operator==(const Format &amp;other) const {
 434     if (this == &amp;other) { // Same object, equal
 435         return TRUE;
 436     }
 437     if (!Format::operator==(other)) {
 438         return FALSE;
 439     }
 440     const MeasureFormat &amp;rhs = static_cast&lt;const MeasureFormat &amp;&gt;(other);
 441 
 442     // Note: Since the ListFormatter depends only on Locale and width, we
 443     // don&#39;t have to check it here.
 444 
 445     // differing widths aren&#39;t equivalent
<span class="line-modified"> 446     if (fWidth != rhs.fWidth) {</span>
 447         return FALSE;
 448     }
 449     // Width the same check locales.
 450     // We don&#39;t need to check locales if both objects have same cache.
 451     if (cache != rhs.cache) {
 452         UErrorCode status = U_ZERO_ERROR;
 453         const char *localeId = getLocaleID(status);
 454         const char *rhsLocaleId = rhs.getLocaleID(status);
 455         if (U_FAILURE(status)) {
 456             // On failure, assume not equal
 457             return FALSE;
 458         }
 459         if (uprv_strcmp(localeId, rhsLocaleId) != 0) {
 460             return FALSE;
 461         }
 462     }
 463     // Locales same, check NumberFormat if shared data differs.
 464     return (
 465             numberFormat == rhs.numberFormat ||
 466             **numberFormat == **rhs.numberFormat);
</pre>
<hr />
<pre>
 487     status = U_ILLEGAL_ARGUMENT_ERROR;
 488     return appendTo;
 489 }
 490 
 491 void MeasureFormat::parseObject(
 492         const UnicodeString &amp; /*source*/,
 493         Formattable &amp; /*result*/,
 494         ParsePosition&amp; /*pos*/) const {
 495     return;
 496 }
 497 
 498 UnicodeString &amp;MeasureFormat::formatMeasurePerUnit(
 499         const Measure &amp;measure,
 500         const MeasureUnit &amp;perUnit,
 501         UnicodeString &amp;appendTo,
 502         FieldPosition &amp;pos,
 503         UErrorCode &amp;status) const {
 504     if (U_FAILURE(status)) {
 505         return appendTo;
 506     }
<span class="line-modified"> 507     auto* df = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;getNumberFormatInternal());</span>
<span class="line-modified"> 508     if (df == nullptr) {</span>
<span class="line-modified"> 509         // Don&#39;t know how to handle other types of NumberFormat</span>
<span class="line-modified"> 510         status = U_UNSUPPORTED_ERROR;</span>













 511         return appendTo;
 512     }
<span class="line-modified"> 513     number::FormattedNumber result;</span>
<span class="line-modified"> 514     if (auto* lnf = df-&gt;toNumberFormatter(status)) {</span>
<span class="line-modified"> 515         result = lnf-&gt;unit(measure.getUnit())</span>
<span class="line-added"> 516             .perUnit(perUnit)</span>
<span class="line-added"> 517             .unitWidth(getUnitWidth(fWidth))</span>
<span class="line-added"> 518             .formatDouble(measure.getNumber().getDouble(status), status);</span>
 519     }
<span class="line-added"> 520     DecimalFormat::fieldPositionHelper(result, pos, appendTo.length(), status);</span>
<span class="line-added"> 521     appendTo.append(result.toTempString(status));</span>
 522     return appendTo;
 523 }
 524 
 525 UnicodeString &amp;MeasureFormat::formatMeasures(
 526         const Measure *measures,
 527         int32_t measureCount,
 528         UnicodeString &amp;appendTo,
 529         FieldPosition &amp;pos,
 530         UErrorCode &amp;status) const {
 531     if (U_FAILURE(status)) {
 532         return appendTo;
 533     }
 534     if (measureCount == 0) {
 535         return appendTo;
 536     }
 537     if (measureCount == 1) {
 538         return formatMeasure(measures[0], **numberFormat, appendTo, pos, status);
 539     }
<span class="line-modified"> 540     if (fWidth == UMEASFMT_WIDTH_NUMERIC) {</span>
 541         Formattable hms[3];
 542         int32_t bitMap = toHMS(measures, measureCount, hms, status);
 543         if (bitMap &gt; 0) {
 544             return formatNumeric(hms, bitMap, appendTo, status);
 545         }
 546     }
 547     if (pos.getField() != FieldPosition::DONT_CARE) {
 548         return formatMeasuresSlowTrack(
 549                 measures, measureCount, appendTo, pos, status);
 550     }
 551     UnicodeString *results = new UnicodeString[measureCount];
 552     if (results == NULL) {
 553         status = U_MEMORY_ALLOCATION_ERROR;
 554         return appendTo;
 555     }
 556     for (int32_t i = 0; i &lt; measureCount; ++i) {
 557         const NumberFormat *nf = cache-&gt;getIntegerFormat();
 558         if (i == measureCount - 1) {
 559             nf = numberFormat-&gt;get();
 560         }
 561         formatMeasure(
 562                 measures[i],
 563                 *nf,
 564                 results[i],
 565                 pos,
 566                 status);
 567     }
 568     listFormatter-&gt;format(results, measureCount, appendTo, status);
 569     delete [] results;
 570     return appendTo;
 571 }
 572 
<span class="line-modified"> 573 UnicodeString MeasureFormat::getUnitDisplayName(const MeasureUnit&amp; unit, UErrorCode&amp; status) const {</span>
<span class="line-modified"> 574     return number::impl::LongNameHandler::getUnitDisplayName(</span>
<span class="line-modified"> 575         getLocale(status),</span>
<span class="line-modified"> 576         unit,</span>
<span class="line-modified"> 577         getUnitWidth(fWidth),</span>
<span class="line-modified"> 578         status);</span>










 579 }
 580 
 581 void MeasureFormat::initMeasureFormat(
 582         const Locale &amp;locale,
 583         UMeasureFormatWidth w,
 584         NumberFormat *nfToAdopt,
 585         UErrorCode &amp;status) {
 586     static const char *listStyles[] = {&quot;unit&quot;, &quot;unit-short&quot;, &quot;unit-narrow&quot;};
 587     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
 588     if (U_FAILURE(status)) {
 589         return;
 590     }
 591     const char *name = locale.getName();
 592     setLocaleIDs(name, name);
 593 
 594     UnifiedCache::getByLocale(locale, cache, status);
 595     if (U_FAILURE(status)) {
 596         return;
 597     }
 598 
 599     const SharedPluralRules *pr = PluralRules::createSharedInstance(
 600             locale, UPLURAL_TYPE_CARDINAL, status);
 601     if (U_FAILURE(status)) {
 602         return;
 603     }
 604     SharedObject::copyPtr(pr, pluralRules);
 605     pr-&gt;removeRef();
 606     if (nf.isNull()) {
<span class="line-added"> 607         // TODO: Clean this up</span>
 608         const SharedNumberFormat *shared = NumberFormat::createSharedInstance(
 609                 locale, UNUM_DECIMAL, status);
 610         if (U_FAILURE(status)) {
 611             return;
 612         }
 613         SharedObject::copyPtr(shared, numberFormat);
 614         shared-&gt;removeRef();
 615     } else {
 616         adoptNumberFormat(nf.orphan(), status);
 617         if (U_FAILURE(status)) {
 618             return;
 619         }
 620     }
<span class="line-modified"> 621     fWidth = w;</span>
 622     delete listFormatter;
 623     listFormatter = ListFormatter::createInstance(
 624             locale,
<span class="line-modified"> 625             listStyles[getRegularWidth(fWidth)],</span>
 626             status);
 627 }
 628 
 629 void MeasureFormat::adoptNumberFormat(
 630         NumberFormat *nfToAdopt, UErrorCode &amp;status) {
 631     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
 632     if (U_FAILURE(status)) {
 633         return;
 634     }
 635     SharedNumberFormat *shared = new SharedNumberFormat(nf.getAlias());
 636     if (shared == NULL) {
 637         status = U_MEMORY_ALLOCATION_ERROR;
 638         return;
 639     }
 640     nf.orphan();
 641     SharedObject::copyPtr(shared, numberFormat);
 642 }
 643 
 644 UBool MeasureFormat::setMeasureFormatLocale(const Locale &amp;locale, UErrorCode &amp;status) {
 645     if (U_FAILURE(status) || locale == getLocale(status)) {
 646         return FALSE;
 647     }
<span class="line-modified"> 648     initMeasureFormat(locale, fWidth, NULL, status);</span>
 649     return U_SUCCESS(status);
 650 }
 651 
<span class="line-modified"> 652 const NumberFormat &amp;MeasureFormat::getNumberFormatInternal() const {</span>
 653     return **numberFormat;
 654 }
 655 
<span class="line-added"> 656 const NumberFormat &amp;MeasureFormat::getCurrencyFormatInternal() const {</span>
<span class="line-added"> 657     return *cache-&gt;getCurrencyFormat(UMEASFMT_WIDTH_NARROW);</span>
<span class="line-added"> 658 }</span>
<span class="line-added"> 659 </span>
 660 const PluralRules &amp;MeasureFormat::getPluralRules() const {
 661     return **pluralRules;
 662 }
 663 
 664 Locale MeasureFormat::getLocale(UErrorCode &amp;status) const {
 665     return Format::getLocale(ULOC_VALID_LOCALE, status);
 666 }
 667 
 668 const char *MeasureFormat::getLocaleID(UErrorCode &amp;status) const {
 669     return Format::getLocaleID(ULOC_VALID_LOCALE, status);
 670 }
 671 
 672 UnicodeString &amp;MeasureFormat::formatMeasure(
 673         const Measure &amp;measure,
 674         const NumberFormat &amp;nf,
 675         UnicodeString &amp;appendTo,
 676         FieldPosition &amp;pos,
 677         UErrorCode &amp;status) const {
 678     if (U_FAILURE(status)) {
 679         return appendTo;
 680     }
 681     const Formattable&amp; amtNumber = measure.getNumber();
 682     const MeasureUnit&amp; amtUnit = measure.getUnit();
 683     if (isCurrency(amtUnit)) {
 684         UChar isoCode[4];
 685         u_charsToUChars(amtUnit.getSubtype(), isoCode, 4);
<span class="line-modified"> 686         return cache-&gt;getCurrencyFormat(fWidth)-&gt;format(</span>
 687                 new CurrencyAmount(amtNumber, isoCode, status),
 688                 appendTo,
 689                 pos,
 690                 status);
 691     }
<span class="line-modified"> 692     auto* df = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;nf);</span>
<span class="line-modified"> 693     if (df == nullptr) {</span>
<span class="line-modified"> 694         // Don&#39;t know how to handle other types of NumberFormat</span>
<span class="line-modified"> 695         status = U_UNSUPPORTED_ERROR;</span>
<span class="line-modified"> 696         return appendTo;</span>
<span class="line-added"> 697     }</span>
<span class="line-added"> 698     number::FormattedNumber result;</span>
<span class="line-added"> 699     if (auto* lnf = df-&gt;toNumberFormatter(status)) {</span>
<span class="line-added"> 700         result = lnf-&gt;unit(amtUnit)</span>
<span class="line-added"> 701             .unitWidth(getUnitWidth(fWidth))</span>
<span class="line-added"> 702             .formatDouble(amtNumber.getDouble(status), status);</span>
<span class="line-added"> 703     }</span>
<span class="line-added"> 704     DecimalFormat::fieldPositionHelper(result, pos, appendTo.length(), status);</span>
<span class="line-added"> 705     appendTo.append(result.toTempString(status));</span>
<span class="line-added"> 706     return appendTo;</span>
 707 }
 708 
 709 // Formats hours-minutes-seconds as 5:37:23 or similar.
 710 UnicodeString &amp;MeasureFormat::formatNumeric(
 711         const Formattable *hms,  // always length 3
 712         int32_t bitMap,   // 1=hourset, 2=minuteset, 4=secondset
 713         UnicodeString &amp;appendTo,
 714         UErrorCode &amp;status) const {
 715     if (U_FAILURE(status)) {
 716         return appendTo;
 717     }
 718     UDate millis =
 719         (UDate) (((uprv_trunc(hms[0].getDouble(status)) * 60.0
 720              + uprv_trunc(hms[1].getDouble(status))) * 60.0
 721                   + uprv_trunc(hms[2].getDouble(status))) * 1000.0);
 722     switch (bitMap) {
 723     case 5: // hs
 724     case 7: // hms
 725         return formatNumeric(
 726                 millis,
</pre>
<hr />
<pre>
 736                 cache-&gt;getNumericDateFormatters()-&gt;minuteSecond,
 737                 UDAT_SECOND_FIELD,
 738                 hms[2],
 739                 appendTo,
 740                 status);
 741         break;
 742     case 3: // hm
 743         return formatNumeric(
 744                 millis,
 745                 cache-&gt;getNumericDateFormatters()-&gt;hourMinute,
 746                 UDAT_MINUTE_FIELD,
 747                 hms[1],
 748                 appendTo,
 749                 status);
 750         break;
 751     default:
 752         status = U_INTERNAL_PROGRAM_ERROR;
 753         return appendTo;
 754         break;
 755     }

 756 }
 757 
 758 static void appendRange(
 759         const UnicodeString &amp;src,
 760         int32_t start,
 761         int32_t end,
 762         UnicodeString &amp;dest) {
 763     dest.append(src, start, end - start);
 764 }
 765 
 766 static void appendRange(
 767         const UnicodeString &amp;src,
 768         int32_t end,
 769         UnicodeString &amp;dest) {
 770     dest.append(src, end, src.length() - end);
 771 }
 772 
 773 // Formats time like 5:37:23
 774 UnicodeString &amp;MeasureFormat::formatNumeric(
 775         UDate date, // Time since epoch 1:30:00 would be 5400000
</pre>
<hr />
<pre>
 821                 appendTo);
 822         appendRange(
 823                 draft,
 824                 smallestFieldPosition.getBeginIndex(),
 825                 smallestFieldPosition.getEndIndex(),
 826                 appendTo);
 827         appendRange(
 828                 smallestAmountFormatted,
 829                 intFieldPosition.getEndIndex(),
 830                 appendTo);
 831         appendRange(
 832                 draft,
 833                 smallestFieldPosition.getEndIndex(),
 834                 appendTo);
 835     } else {
 836         appendTo.append(draft);
 837     }
 838     return appendTo;
 839 }
 840 






































































































 841 UnicodeString &amp;MeasureFormat::formatMeasuresSlowTrack(
 842         const Measure *measures,
 843         int32_t measureCount,
 844         UnicodeString&amp; appendTo,
 845         FieldPosition&amp; pos,
 846         UErrorCode&amp; status) const {
 847     if (U_FAILURE(status)) {
 848         return appendTo;
 849     }
 850     FieldPosition dontCare(FieldPosition::DONT_CARE);
 851     FieldPosition fpos(pos.getField());
<span class="line-modified"> 852     LocalArray&lt;UnicodeString&gt; results(new UnicodeString[measureCount], status);</span>
 853     int32_t fieldPositionFoundIndex = -1;
 854     for (int32_t i = 0; i &lt; measureCount; ++i) {
 855         const NumberFormat *nf = cache-&gt;getIntegerFormat();
 856         if (i == measureCount - 1) {
 857             nf = numberFormat-&gt;get();
 858         }
 859         if (fieldPositionFoundIndex == -1) {
 860             formatMeasure(measures[i], *nf, results[i], fpos, status);
 861             if (U_FAILURE(status)) {

 862                 return appendTo;
 863             }
 864             if (fpos.getBeginIndex() != 0 || fpos.getEndIndex() != 0) {
 865                 fieldPositionFoundIndex = i;
 866             }
 867         } else {
 868             formatMeasure(measures[i], *nf, results[i], dontCare, status);
 869         }
 870     }
 871     int32_t offset;
 872     listFormatter-&gt;format(
<span class="line-modified"> 873             results.getAlias(),</span>
 874             measureCount,
 875             appendTo,
 876             fieldPositionFoundIndex,
 877             offset,
 878             status);
 879     if (U_FAILURE(status)) {

 880         return appendTo;
 881     }
<span class="line-added"> 882     // Fix up FieldPosition indexes if our field is found.</span>
 883     if (offset != -1) {
 884         pos.setBeginIndex(fpos.getBeginIndex() + offset);
 885         pos.setEndIndex(fpos.getEndIndex() + offset);
 886     }

 887     return appendTo;
 888 }
 889 
 890 MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(const Locale&amp; locale,
 891                                                    UErrorCode&amp; ec) {
<span class="line-modified"> 892     if (U_FAILURE(ec)) {</span>
<span class="line-modified"> 893         return nullptr;</span>





 894     }
<span class="line-modified"> 895     LocalPointer&lt;CurrencyFormat&gt; fmt(new CurrencyFormat(locale, ec), ec);</span>
<span class="line-added"> 896     return fmt.orphan();</span>
 897 }
 898 
 899 MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(UErrorCode&amp; ec) {
 900     if (U_FAILURE(ec)) {
<span class="line-modified"> 901         return nullptr;</span>
 902     }
 903     return MeasureFormat::createCurrencyFormat(Locale::getDefault(), ec);
 904 }
 905 
 906 U_NAMESPACE_END
 907 
 908 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
</tr>
</table>
<center><a href="japancal.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="measunit.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>