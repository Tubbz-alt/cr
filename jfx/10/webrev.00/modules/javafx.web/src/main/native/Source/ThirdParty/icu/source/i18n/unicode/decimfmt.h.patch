diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/decimfmt.h b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/decimfmt.h
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/decimfmt.h
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/decimfmt.h
@@ -61,39 +61,30 @@
 namespace impl {
 class NumberParserImpl;
 }
 }
 
-// explicit template instantiation. see digitlst.h
-// (When building DLLs for Windows this is required.)
-#if U_PF_WINDOWS <= U_PLATFORM && U_PLATFORM <= U_PF_CYGWIN
-template class U_I18N_API    EnumSet<UNumberFormatAttribute,
-            UNUM_MAX_NONBOOLEAN_ATTRIBUTE+1,
-            UNUM_LIMIT_BOOLEAN_ATTRIBUTE>;
-#endif
-
 /**
- * <p><strong>IMPORTANT:</strong> New users are strongly encouraged to see if
+ * **IMPORTANT:** New users are strongly encouraged to see if
  * numberformatter.h fits their use case.  Although not deprecated, this header
  * is provided for backwards compatibility only.
- * <hr/>
  *
  * DecimalFormat is a concrete subclass of NumberFormat that formats decimal
  * numbers. It has a variety of features designed to make it possible to parse
  * and format numbers in any locale, including support for Western, Arabic, or
  * Indic digits.  It also supports different flavors of numbers, including
  * integers ("123"), fixed-point numbers ("123.4"), scientific notation
  * ("1.23E4"), percentages ("12%"), and currency amounts ("$123", "USD123",
  * "123 US dollars").  All of these flavors can be easily localized.
  *
- * <p>To obtain a NumberFormat for a specific locale (including the default
+ * To obtain a NumberFormat for a specific locale (including the default
  * locale) call one of NumberFormat's factory methods such as
  * createInstance(). Do not call the DecimalFormat constructors directly, unless
  * you know what you are doing, since the NumberFormat factory methods may
  * return subclasses other than DecimalFormat.
  *
- * <p><strong>Example Usage</strong>
+ * **Example Usage**
  *
  * \code
  *     // Normally we would have a GUI with a menu for this
  *     int32_t locCount;
  *     const Locale* locales = NumberFormat::getAvailableLocales(locCount);
@@ -133,30 +124,32 @@
  *                 delete form;
  *             }
  *         }
  *     }
  * \endcode
- * <P>
- * Another example use createInstance(style)
- * <P>
- * <pre>
- * <strong>// Print out a number using the localized number, currency,
+ *
+ * **Another example use createInstance(style)**
+ *
+ * \code
+ * // Print out a number using the localized number, currency,
  * // percent, scientific, integer, iso currency, and plural currency
  * // format for each locale</strong>
  * Locale* locale = new Locale("en", "US");
  * double myNumber = 1234.56;
  * UErrorCode success = U_ZERO_ERROR;
  * UnicodeString str;
  * Formattable fmtable;
  * for (int j=NumberFormat::kNumberStyle;
  *      j<=NumberFormat::kPluralCurrencyStyle;
  *      ++j) {
- *     NumberFormat* format = NumberFormat::createInstance(locale, j, success);
+ *     NumberFormat* form = NumberFormat::createInstance(locale, j, success);
  *     str.remove();
  *     cout << "format result " << form->format(myNumber, str) << endl;
  *     format->parse(form->format(myNumber, str), fmtable, success);
- * }</pre>
+ *     delete form;
+ * }
+ * \endcode
  *
  *
  * <p><strong>Patterns</strong>
  *
  * <p>A DecimalFormat consists of a <em>pattern</em> and a set of
@@ -281,11 +274,11 @@
  *     <td>Prefix or suffix boundary
  *     <td>Yes
  *     <td>Pad escape, precedes pad character
  * </table>
  *
- * <p>A DecimalFormat pattern contains a postive and negative
+ * <p>A DecimalFormat pattern contains a positive and negative
  * subpattern, for example, "#,##0.00;(#,##0.00)".  Each subpattern has a
  * prefix, a numeric part, and a suffix.  If there is no explicit negative
  * subpattern, the negative subpattern is the localized minus sign prefixed to the
  * positive subpattern. That is, "0.00" alone is equivalent to "0.00;-0.00".  If there
  * is an explicit negative subpattern, it serves only to specify the negative
@@ -416,11 +409,11 @@
  * if the maximum fraction digits is 2.  This behavior can be changed
  * by specifying a rounding increment and/or a rounding mode.
  *
  * <li>If the number of actual fraction digits is less than the
  * <em>minimum fraction digits</em>, then trailing zeros are added.
- * For example, 0.125 is formatted as "0.1250" if the mimimum fraction
+ * For example, 0.125 is formatted as "0.1250" if the minimum fraction
  * digits is set to 4.
  *
  * <li>Trailing fractional zeros are not displayed if they occur
  * <em>j</em> positions after the decimal, where <em>j</em> is less
  * than the maximum fraction digits. For example, 0.10004 is
@@ -581,13 +574,13 @@
  * maximum integer digit count of one, a minimum fraction digit count of
  * <code>getMinimumSignificantDigits() - 1</code>, and a maximum fraction digit
  * count of <code>getMaximumSignificantDigits() - 1</code>. For example, the
  * pattern <code>"@@###E0"</code> is equivalent to <code>"0.0###E0"</code>.
  *
- * <li>If signficant digits are in use, then the integer and fraction
+ * <li>If significant digits are in use, then the integer and fraction
  * digit counts, as set via the API, are ignored.  If significant
- * digits are not in use, then the signficant digit counts, as set via
+ * digits are not in use, then the significant digit counts, as set via
  * the API, are ignored.
  *
  * </ul>
  *
  * <p><strong>Padding</strong>
@@ -637,11 +630,11 @@
  * nearest 0.65 is 1.3.  The rounding increment may be specified through the API
  * or in a pattern.  To specify a rounding increment in a pattern, include the
  * increment in the pattern itself.  "#,#50" specifies a rounding increment of
  * 50.  "#,##0.05" specifies a rounding increment of 0.05.
  *
- * <p>In the absense of an explicit rounding increment numbers are
+ * <p>In the absence of an explicit rounding increment numbers are
  * rounded to their formatted width.
  *
  * <ul>
  * <li>Rounding only affects the string produced by formatting.  It does
  * not affect parsing or change any numerical values.
@@ -688,11 +681,11 @@
      * on NumberFormat such as createInstance. These factories will
      * return the most appropriate sub-class of NumberFormat for a given
      * locale.
      * <p>
      * <strong>NOTE:</strong> New users are strongly encouraged to use
-     * {@link NumberFormatter} instead of DecimalFormat.
+     * #icu::number::NumberFormatter instead of DecimalFormat.
      * @param status    Output param set to success/failure code. If the
      *                  pattern is invalid this will be set to a failure code.
      * @stable ICU 2.0
      */
     DecimalFormat(UErrorCode& status);
@@ -706,11 +699,11 @@
      * on NumberFormat such as createInstance. These factories will
      * return the most appropriate sub-class of NumberFormat for a given
      * locale.
      * <p>
      * <strong>NOTE:</strong> New users are strongly encouraged to use
-     * {@link NumberFormatter} instead of DecimalFormat.
+     * #icu::number::NumberFormatter instead of DecimalFormat.
      * @param pattern   A non-localized pattern string.
      * @param status    Output param set to success/failure code. If the
      *                  pattern is invalid this will be set to a failure code.
      * @stable ICU 2.0
      */
@@ -726,11 +719,11 @@
      * createInstance or createCurrencyInstance. If you need only minor adjustments
      * to a standard format, you can modify the format returned by
      * a NumberFormat factory method.
      * <p>
      * <strong>NOTE:</strong> New users are strongly encouraged to use
-     * {@link NumberFormatter} instead of DecimalFormat.
+     * #icu::number::NumberFormatter instead of DecimalFormat.
      *
      * @param pattern           a non-localized pattern string
      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
      *                          delete this object after making this call.
      * @param status            Output param set to success/failure code. If the
@@ -780,11 +773,11 @@
     /**
      * Set an integer attribute on this DecimalFormat.
      * May return U_UNSUPPORTED_ERROR if this instance does not support
      * the specified attribute.
      * @param attr the attribute to set
-     * @param newvalue new value
+     * @param newValue new value
      * @param status the error type
      * @return *this - for chaining (example: format.setAttribute(...).setAttribute(...) )
      * @stable ICU 51
      */
     virtual DecimalFormat& setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode& status);
@@ -837,16 +830,16 @@
      * createInstance or createCurrencyInstance. If you need only minor adjustments
      * to a standard format, you can modify the format returned by
      * a NumberFormat factory method.
      * <p>
      * <strong>NOTE:</strong> New users are strongly encouraged to use
-     * {@link NumberFormatter} instead of DecimalFormat.
+     * #icu::number::NumberFormatter instead of DecimalFormat.
      *
      * @param pattern           a non-localized pattern string
      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
      *                          delete this object after making this call.
-     * @param parseError        Output param to receive errors occured during parsing
+     * @param parseError        Output param to receive errors occurred during parsing
      * @param status            Output param set to success/failure code. If the
      *                          pattern is invalid this will be set to a failure code.
      * @stable ICU 2.0
      */
     DecimalFormat(const UnicodeString& pattern, DecimalFormatSymbols* symbolsToAdopt,
@@ -862,11 +855,11 @@
      * createInstance or createCurrencyInstance. If you need only minor adjustments
      * to a standard format, you can modify the format returned by
      * a NumberFormat factory method.
      * <p>
      * <strong>NOTE:</strong> New users are strongly encouraged to use
-     * {@link NumberFormatter} instead of DecimalFormat.
+     * #icu::number::NumberFormatter instead of DecimalFormat.
      *
      * @param pattern           a non-localized pattern string
      * @param symbols   the set of symbols to be used
      * @param status            Output param set to success/failure code. If the
      *                          pattern is invalid this will be set to a failure code.
@@ -984,10 +977,11 @@
      * @param number    The value to be formatted.
      * @param appendTo  Output parameter to receive result.
      *                  Result is appended to existing contents.
      * @param pos       On input: an alignment field, if desired.
      *                  On output: the offsets of the alignment field.
+     * @param status    Output param filled with success/failure status.
      * @return          Reference to 'appendTo' parameter.
      * @internal
      */
     UnicodeString& format(int32_t number, UnicodeString& appendTo, FieldPosition& pos,
                           UErrorCode& status) const U_OVERRIDE;
@@ -1029,10 +1023,11 @@
      * @param number    The value to be formatted.
      * @param appendTo  Output parameter to receive result.
      *                  Result is appended to existing contents.
      * @param pos       On input: an alignment field, if desired.
      *                  On output: the offsets of the alignment field.
+     * @param status    Output param filled with success/failure status.
      * @return          Reference to 'appendTo' parameter.
      * @internal
      */
     UnicodeString& format(int64_t number, UnicodeString& appendTo, FieldPosition& pos,
                           UErrorCode& status) const U_OVERRIDE;
@@ -1118,11 +1113,11 @@
     /**
      * Parse the given string using this object's choices. The method
      * does string comparisons to try to find an optimal match.
      * If no object can be parsed, index is unchanged, and NULL is
      * returned.  The result is returned as the most parsimonious
-     * type of Formattable that will accomodate all of the
+     * type of Formattable that will accommodate all of the
      * necessary precision.  For example, if the result is exactly 12,
      * it will be returned as a long.  However, if it is 1.5, it will
      * be returned as a double.
      *
      * @param text           The text to be parsed.
@@ -1283,24 +1278,31 @@
      * Examples: 123%
      * @stable ICU 2.0
      */
     virtual void setNegativeSuffix(const UnicodeString& newValue);
 
-#ifndef U_HIDE_INTERNAL_API
+#ifndef U_HIDE_DRAFT_API
     /**
      * Whether to show the plus sign on positive (non-negative) numbers; for example, "+12"
-     * @internal Technical Preview
+     *
+     * For more control over sign display, use NumberFormatter.
+     *
+     * @return Whether the sign is shown on positive numbers and zero.
+     * @draft ICU 64
      */
     UBool isSignAlwaysShown() const;
-#endif  /* U_HIDE_INTERNAL_API */
 
     /**
-     * Set whether to show the plus sign on positive (non-negative) numbers; for example, "+12"
-     * @param value The new setting for whether to show plus sign on positive numbers
-     * @internal Technical Preview
+     * Set whether to show the plus sign on positive (non-negative) numbers; for example, "+12".
+     *
+     * For more control over sign display, use NumberFormatter.
+     *
+     * @param value true to always show a sign; false to hide the sign on positive numbers and zero.
+     * @draft ICU 64
      */
-    virtual void setSignAlwaysShown(UBool value);
+    void setSignAlwaysShown(UBool value);
+#endif  /* U_HIDE_DRAFT_API */
 
     /**
      * Get the multiplier for use in percent, permill, etc.
      * For a percentage, set the suffixes to have "%" and the multiplier to be 100.
      * (For Arabic, use arabic percent symbol).
@@ -1341,11 +1343,10 @@
      *
      * @return    the current value of the power-of-ten multiplier.
      * @draft ICU 62
      */
     int32_t getMultiplierScale(void) const;
-#endif  /* U_HIDE_DRAFT_API */
 
     /**
      * Sets a power of ten by which number should be multiplied before formatting, which
      * can be combined with setMultiplier() to multiply by any arbitrary decimal value.
      *
@@ -1362,11 +1363,12 @@
      * This method is analogous to UNUM_SCALE in setAttribute.
      *
      * @param newValue    the new value of the power-of-ten multiplier.
      * @draft ICU 62
      */
-    virtual void setMultiplierScale(int32_t newValue);
+    void setMultiplierScale(int32_t newValue);
+#endif  /* U_HIDE_DRAFT_API */
 
     /**
      * Get the rounding increment.
      * @return A positive rounding increment, or 0.0 if a custom rounding
      * increment is not in effect.
@@ -1455,12 +1457,12 @@
 
     /**
      * Set the character used to pad to the format width.  If padding
      * is not enabled, then this will take effect if padding is later
      * enabled.
-     * @param padChar a string containing the pad charcter. If the string
-     * has length 0, then the pad characer is set to ' '.  Otherwise
+     * @param padChar a string containing the pad character. If the string
+     * has length 0, then the pad character is set to ' '.  Otherwise
      * padChar.char32At(0) will be used as the pad character.
      * @see #setFormatWidth
      * @see #getFormatWidth
      * @see #getPadCharacterString
      * @see #getPadPosition
@@ -1645,47 +1647,48 @@
      * @see DecimalFormatSymbols::setGroupingSeparator
      * @stable ICU 2.4
      */
     virtual void setSecondaryGroupingSize(int32_t newValue);
 
-#ifndef U_HIDE_INTERNAL_API
-
+#ifndef U_HIDE_DRAFT_API
     /**
      * Returns the minimum number of grouping digits.
      * Grouping separators are output if there are at least this many
      * digits to the left of the first (rightmost) grouping separator,
      * that is, there are at least (minimum grouping + grouping size) integer digits.
      * (Subject to isGroupingUsed().)
      *
      * For example, if this value is 2, and the grouping size is 3, then
      * 9999 -> "9999" and 10000 -> "10,000"
      *
-     * This is a technology preview. This API may change behavior or may be removed.
-     *
      * The default value for this attribute is 0.
      * A value of 1, 0, or lower, means that the use of grouping separators
      * only depends on the grouping size (and on isGroupingUsed()).
-     * Currently, the corresponding CLDR data is not used; this is likely to change.
+     *
+     * NOTE: The CLDR data is used in NumberFormatter but not in DecimalFormat.
+     * This is for backwards compatibility reasons.
+     *
+     * For more control over grouping strategies, use NumberFormatter.
      *
      * @see setMinimumGroupingDigits
      * @see getGroupingSize
-     * @internal technology preview
+     * @draft ICU 64
      */
     int32_t getMinimumGroupingDigits() const;
 
-#endif  /* U_HIDE_INTERNAL_API */
-
-    /* Cannot use #ifndef U_HIDE_INTERNAL_API for the following draft method since it is virtual. */
     /**
      * Sets the minimum grouping digits. Setting to a value less than or
      * equal to 1 turns off minimum grouping digits.
      *
+     * For more control over grouping strategies, use NumberFormatter.
+     *
      * @param newValue the new value of minimum grouping digits.
      * @see getMinimumGroupingDigits
-     * @internal technology preview
+     * @draft ICU 64
      */
-    virtual void setMinimumGroupingDigits(int32_t newValue);
+    void setMinimumGroupingDigits(int32_t newValue);
+#endif  /* U_HIDE_DRAFT_API */
 
 
     /**
      * Allows you to get the behavior of the decimal separator with integers.
      * (The decimal separator will always appear with decimals.)
@@ -1723,63 +1726,71 @@
      * @param newValue    set TRUE if input must contain a match to decimal mark in pattern
      * @stable ICU 54
      */
     virtual void setDecimalPatternMatchRequired(UBool newValue);
 
+#ifndef U_HIDE_DRAFT_API
     /**
-     * {@icu} Returns whether to ignore exponents when parsing.
+     * Returns whether to ignore exponents when parsing.
      *
+     * @return Whether to ignore exponents when parsing.
      * @see #setParseNoExponent
-     * @internal This API is a technical preview. It may change in an upcoming release.
+     * @draft ICU 64
      */
-    virtual UBool isParseNoExponent() const;
+    UBool isParseNoExponent() const;
 
     /**
-     * {@icu} Specifies whether to stop parsing when an exponent separator is encountered. For
+     * Specifies whether to stop parsing when an exponent separator is encountered. For
      * example, parses "123E4" to 123 (with parse position 3) instead of 1230000 (with parse position
      * 5).
      *
      * @param value true to prevent exponents from being parsed; false to allow them to be parsed.
-     * @internal This API is a technical preview. It may change in an upcoming release.
+     * @draft ICU 64
      */
-    virtual void setParseNoExponent(UBool value);
+    void setParseNoExponent(UBool value);
 
     /**
-     * {@icu} Returns whether parsing is sensitive to case (lowercase/uppercase).
+     * Returns whether parsing is sensitive to case (lowercase/uppercase).
      *
+     * @return Whether parsing is case-sensitive.
      * @see #setParseCaseSensitive
-     * @internal This API is a technical preview. It may change in an upcoming release.
+     * @draft ICU 64
      */
-    virtual UBool isParseCaseSensitive() const;
+    UBool isParseCaseSensitive() const;
 
     /**
-     * {@icu} Whether to pay attention to case when parsing; default is to ignore case (perform
+     * Whether to pay attention to case when parsing; default is to ignore case (perform
      * case-folding). For example, "A" == "a" in case-insensitive but not case-sensitive mode.
      *
      * Currency symbols are never case-folded. For example, "us$1.00" will not parse in case-insensitive
      * mode, even though "US$1.00" parses.
      *
-     * @internal This API is a technical preview. It may change in an upcoming release.
+     * @param value true to enable case-sensitive parsing (the default); false to force
+     *              case-sensitive parsing behavior.
+     * @draft ICU 64
      */
-    virtual void setParseCaseSensitive(UBool value);
+    void setParseCaseSensitive(UBool value);
 
     /**
-     * {@icu} Returns whether truncation of high-order integer digits should result in an error.
+     * Returns whether truncation of high-order integer digits should result in an error.
      * By default, setMaximumIntegerDigits truncates high-order digits silently.
      *
+     * @return Whether an error code is set if high-order digits are truncated.
      * @see setFormatFailIfMoreThanMaxDigits
-     * @internal This API is a technical preview. It may change in an upcoming release.
+     * @draft ICU 64
      */
-    virtual UBool isFormatFailIfMoreThanMaxDigits() const;
+    UBool isFormatFailIfMoreThanMaxDigits() const;
 
     /**
-     * {@icu} Sets whether truncation of high-order integer digits should result in an error.
+     * Sets whether truncation of high-order integer digits should result in an error.
      * By default, setMaximumIntegerDigits truncates high-order digits silently.
      *
-     * @internal This API is a technical preview. It may change in an upcoming release.
+     * @param value Whether to set an error code if high-order digits are truncated.
+     * @draft ICU 64
      */
-    virtual void setFormatFailIfMoreThanMaxDigits(UBool value);
+    void setFormatFailIfMoreThanMaxDigits(UBool value);
+#endif  /* U_HIDE_DRAFT_API */
 
 
     /**
      * Synthesizes a pattern string that represents the current state
      * of this Format object.
@@ -2015,20 +2026,21 @@
      * @deprecated ICU 3.0. Use setCurrency(const char16_t*, UErrorCode&).
      */
     virtual void setCurrency(const char16_t* theCurrency);
 
     /**
-     * Sets the <tt>Currency Context</tt> object used to display currency.
+     * Sets the `Currency Usage` object used to display currency.
      * This takes effect immediately, if this format is a
      * currency format.
-     * @param currencyContext new currency context object to use.
+     * @param newUsage new currency usage object to use.
+     * @param ec input-output error code
      * @stable ICU 54
      */
     void setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec);
 
     /**
-     * Returns the <tt>Currency Context</tt> object used to display currency
+     * Returns the `Currency Usage` object used to display currency
      * @stable ICU 54
      */
     UCurrencyUsage getCurrencyUsage() const;
 
 #ifndef U_HIDE_INTERNAL_API
@@ -2048,38 +2060,76 @@
      *  @internal
      */
     void formatToDecimalQuantity(const Formattable& number, number::impl::DecimalQuantity& output,
                                  UErrorCode& status) const;
 
-#endif
+#endif  /* U_HIDE_INTERNAL_API */
 
 #ifndef U_HIDE_DRAFT_API
     /**
-     * Converts this DecimalFormat to a NumberFormatter.  Starting in ICU 60,
-     * NumberFormatter is the recommended way to format numbers.
+     * Converts this DecimalFormat to a (Localized)NumberFormatter. Starting
+     * in ICU 60, NumberFormatter is the recommended way to format numbers.
+     * You can use the returned LocalizedNumberFormatter to format numbers and
+     * get a FormattedNumber, which contains a string as well as additional
+     * annotations about the formatted value.
+     *
+     * If a memory allocation failure occurs, the return value of this method
+     * might be null. If you are concerned about correct recovery from
+     * out-of-memory situations, use this pattern:
+     *
+     * <pre>
+     * FormattedNumber result;
+     * if (auto* ptr = df->toNumberFormatter(status)) {
+     *     result = ptr->formatDouble(123, status);
+     * }
+     * </pre>
+     *
+     * If you are not concerned about out-of-memory situations, or if your
+     * environment throws exceptions when memory allocation failure occurs,
+     * you can chain the methods, like this:
+     *
+     * <pre>
+     * FormattedNumber result = df
+     *     ->toNumberFormatter(status)
+     *     ->formatDouble(123, status);
+     * </pre>
      *
      * NOTE: The returned LocalizedNumberFormatter is owned by this DecimalFormat.
      * If a non-const method is called on the DecimalFormat, or if the DecimalFormat
      * is deleted, the object becomes invalid. If you plan to keep the return value
      * beyond the lifetime of the DecimalFormat, copy it to a local variable:
      *
      * <pre>
-     * LocalizedNumberFormatter f = df->toNumberFormatter();
+     * LocalizedNumberFormatter lnf;
+     * if (auto* ptr = df->toNumberFormatter(status)) {
+     *     lnf = *ptr;
+     * }
      * </pre>
      *
-     * It is, however, safe to use the return value for chaining:
+     * @param status Set on failure, like U_MEMORY_ALLOCATION_ERROR.
+     * @return A pointer to an internal object, or nullptr on failure.
+     *         Do not delete the return value!
+     * @draft ICU 64
+     */
+    const number::LocalizedNumberFormatter* toNumberFormatter(UErrorCode& status) const;
+#endif  /* U_HIDE_DRAFT_API */
+
+#ifndef U_HIDE_DEPRECATED_API
+    /**
+     * Deprecated: Like {@link #toNumberFormatter(UErrorCode&) const},
+     * but does not take an error code.
      *
-     * <pre>
-     * FormattedNumber result = df->toNumberFormatter().formatDouble(123, status);
-     * </pre>
+     * The new signature should be used in case an error occurs while returning the
+     * LocalizedNumberFormatter.
      *
-     * @param output The variable into which to store the LocalizedNumberFormatter.
-     * @return The output variable, for chaining.
-     * @draft ICU 62
+     * This old signature will be removed in ICU 65.
+     *
+     * @return A reference to an internal object.
+     * @deprecated ICU 64
      */
     const number::LocalizedNumberFormatter& toNumberFormatter() const;
-#endif  /* U_HIDE_DRAFT_API */
+#endif  /* U_HIDE_DEPRECATED_API */
 
     /**
      * Return the class ID for this class.  This is useful only for
      * comparing to a return value from getDynamicClassID().  For example:
      * <pre>
@@ -2108,11 +2158,11 @@
   private:
 
     /** Rebuilds the formatter object from the property bag. */
     void touch(UErrorCode& status);
 
-    /** Rebuilds the formatter object, hiding the error code. */
+    /** Rebuilds the formatter object, ignoring any error code. */
     void touchNoError();
 
     /**
      * Updates the property bag with settings from the given pattern.
      *
@@ -2147,16 +2197,21 @@
 
     //=====================================================================================//
     //                                   INSTANCE FIELDS                                   //
     //=====================================================================================//
 
-    // Only one instance field: keep all fields inside of an implementation class defined in number_mapper.h
-    number::impl::DecimalFormatFields* fields;
+
+    // One instance field for the implementation, keep all fields inside of an implementation
+    // class defined in number_mapper.h
+    number::impl::DecimalFormatFields* fields = nullptr;
 
     // Allow child class CompactDecimalFormat to access fProperties:
     friend class CompactDecimalFormat;
 
+    // Allow MeasureFormat to use fieldPositionHelper:
+    friend class MeasureFormat;
+
 };
 
 U_NAMESPACE_END
 
 #endif /* #if !UCONFIG_NO_FORMATTING */
