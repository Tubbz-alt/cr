<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/pkg_genc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="package.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="pkg_gencmn.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/pkg_genc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 292     if(optEntryPoint != NULL) {
 293         uprv_strcpy(entry, optEntryPoint);
 294         uprv_strcat(entry, &quot;_dat&quot;);
 295     }
 296 
 297     /* turn dashes or dots in the entry name into underscores */
 298     length=uprv_strlen(entry);
 299     for(i=0; i&lt;length; ++i) {
 300         if(entry[i]==&#39;-&#39; || entry[i]==&#39;.&#39;) {
 301             entry[i]=&#39;_&#39;;
 302         }
 303     }
 304 
 305     sprintf(bufferStr, assemblyHeader[assemblyHeaderIndex].header,
 306         entry, entry, entry, entry,
 307         entry, entry, entry, entry);
 308     T_FileStream_writeLine(out, bufferStr);
 309     T_FileStream_writeLine(out, assemblyHeader[assemblyHeaderIndex].beginLine);
 310 
 311     for(;;) {

 312         length=T_FileStream_read(in, buffer, sizeof(buffer));
 313         if(length==0) {
 314             break;
 315         }
<span class="line-removed"> 316         if (length != sizeof(buffer)) {</span>
<span class="line-removed"> 317             /* pad with extra 0&#39;s when at the end of the file */</span>
<span class="line-removed"> 318             for(i=0; i &lt; (length % sizeof(uint32_t)); ++i) {</span>
<span class="line-removed"> 319                 buffer[length+i] = 0;</span>
<span class="line-removed"> 320             }</span>
<span class="line-removed"> 321         }</span>
 322         for(i=0; i&lt;(length/sizeof(buffer[0])); i++) {
 323             column = write32(out, buffer[i], column);
 324         }
 325     }
 326 
 327     T_FileStream_writeLine(out, &quot;\n&quot;);
 328 
 329     sprintf(bufferStr, assemblyHeader[assemblyHeaderIndex].footer,
 330         entry, entry, entry, entry,
 331         entry, entry, entry, entry);
 332     T_FileStream_writeLine(out, bufferStr);
 333 
 334     if(T_FileStream_error(in)) {
 335         fprintf(stderr, &quot;genccode: file read error while generating from file %s\n&quot;, filename);
 336         exit(U_FILE_ACCESS_ERROR);
 337     }
 338 
 339     if(T_FileStream_error(out)) {
 340         fprintf(stderr, &quot;genccode: file write error while generating from file %s\n&quot;, filename);
 341         exit(U_FILE_ACCESS_ERROR);
</pre>
<hr />
<pre>
 668     int32_t length;
 669 
 670 #ifdef U_ELF
 671 
 672 #elif U_PLATFORM_HAS_WIN32_API
 673     const IMAGE_FILE_HEADER *pHeader;
 674 #else
 675 #   error &quot;Unknown platform for CAN_GENERATE_OBJECTS.&quot;
 676 #endif
 677 
 678     if(optMatchArch != NULL) {
 679         filename=optMatchArch;
 680     } else {
 681         /* set defaults */
 682 #ifdef U_ELF
 683         /* set EM_386 because elf.h does not provide better defaults */
 684         *pCPU=EM_386;
 685         *pBits=32;
 686         *pIsBigEndian=(UBool)(U_IS_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB);
 687 #elif U_PLATFORM_HAS_WIN32_API
<span class="line-modified"> 688 /* _M_IA64 should be defined in windows.h */</span>
<span class="line-modified"> 689 #   if defined(_M_IA64)</span>
<span class="line-modified"> 690         *pCPU=IMAGE_FILE_MACHINE_IA64;</span>
<span class="line-modified"> 691         *pBits = 64;</span>
<span class="line-modified"> 692 #   elif defined(_M_AMD64)</span>
<span class="line-modified"> 693 // link.exe does not really care about the .obj machine type and this will</span>
<span class="line-modified"> 694 // allow us to build a dll for both ARM &amp; x64 with an amd64 built tool</span>
<span class="line-modified"> 695 // ARM is same as x64 except for first 2 bytes of object file</span>
<span class="line-modified"> 696         *pCPU = IMAGE_FILE_MACHINE_UNKNOWN;</span>
<span class="line-modified"> 697         // *pCPU = IMAGE_FILE_MACHINE_ARMNT;   // If we wanted to be explicit</span>
<span class="line-modified"> 698         // *pCPU = IMAGE_FILE_MACHINE_AMD64;   // We would use one of these names</span>
<span class="line-modified"> 699         *pBits = 64;                           // Doesn&#39;t seem to be used for anything interesting?</span>


 700 #   else
<span class="line-modified"> 701         *pCPU=IMAGE_FILE_MACHINE_I386;    // We would use one of these names</span>




 702         *pBits = 32;


 703 #   endif
<span class="line-removed"> 704         *pIsBigEndian=FALSE;</span>
 705 #else
 706 #   error &quot;Unknown platform for CAN_GENERATE_OBJECTS.&quot;
 707 #endif
 708         return;
 709     }
 710 
 711     in=T_FileStream_open(filename, &quot;rb&quot;);
 712     if(in==NULL) {
 713         fprintf(stderr, &quot;genccode: unable to open match-arch file %s\n&quot;, filename);
 714         exit(U_FILE_ACCESS_ERROR);
 715     }
 716     length=T_FileStream_read(in, buffer.bytes, sizeof(buffer.bytes));
 717 
 718 #ifdef U_ELF
 719     if(length&lt;(int32_t)sizeof(Elf32_Ehdr)) {
 720         fprintf(stderr, &quot;genccode: match-arch file %s is too short\n&quot;, filename);
 721         exit(U_UNSUPPORTED_ERROR);
 722     }
 723     if(
 724         buffer.header32.e_ident[0]!=ELFMAG0 ||
</pre>
</td>
<td>
<hr />
<pre>
 292     if(optEntryPoint != NULL) {
 293         uprv_strcpy(entry, optEntryPoint);
 294         uprv_strcat(entry, &quot;_dat&quot;);
 295     }
 296 
 297     /* turn dashes or dots in the entry name into underscores */
 298     length=uprv_strlen(entry);
 299     for(i=0; i&lt;length; ++i) {
 300         if(entry[i]==&#39;-&#39; || entry[i]==&#39;.&#39;) {
 301             entry[i]=&#39;_&#39;;
 302         }
 303     }
 304 
 305     sprintf(bufferStr, assemblyHeader[assemblyHeaderIndex].header,
 306         entry, entry, entry, entry,
 307         entry, entry, entry, entry);
 308     T_FileStream_writeLine(out, bufferStr);
 309     T_FileStream_writeLine(out, assemblyHeader[assemblyHeaderIndex].beginLine);
 310 
 311     for(;;) {
<span class="line-added"> 312         memset(buffer, 0, sizeof(buffer));</span>
 313         length=T_FileStream_read(in, buffer, sizeof(buffer));
 314         if(length==0) {
 315             break;
 316         }






 317         for(i=0; i&lt;(length/sizeof(buffer[0])); i++) {
 318             column = write32(out, buffer[i], column);
 319         }
 320     }
 321 
 322     T_FileStream_writeLine(out, &quot;\n&quot;);
 323 
 324     sprintf(bufferStr, assemblyHeader[assemblyHeaderIndex].footer,
 325         entry, entry, entry, entry,
 326         entry, entry, entry, entry);
 327     T_FileStream_writeLine(out, bufferStr);
 328 
 329     if(T_FileStream_error(in)) {
 330         fprintf(stderr, &quot;genccode: file read error while generating from file %s\n&quot;, filename);
 331         exit(U_FILE_ACCESS_ERROR);
 332     }
 333 
 334     if(T_FileStream_error(out)) {
 335         fprintf(stderr, &quot;genccode: file write error while generating from file %s\n&quot;, filename);
 336         exit(U_FILE_ACCESS_ERROR);
</pre>
<hr />
<pre>
 663     int32_t length;
 664 
 665 #ifdef U_ELF
 666 
 667 #elif U_PLATFORM_HAS_WIN32_API
 668     const IMAGE_FILE_HEADER *pHeader;
 669 #else
 670 #   error &quot;Unknown platform for CAN_GENERATE_OBJECTS.&quot;
 671 #endif
 672 
 673     if(optMatchArch != NULL) {
 674         filename=optMatchArch;
 675     } else {
 676         /* set defaults */
 677 #ifdef U_ELF
 678         /* set EM_386 because elf.h does not provide better defaults */
 679         *pCPU=EM_386;
 680         *pBits=32;
 681         *pIsBigEndian=(UBool)(U_IS_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB);
 682 #elif U_PLATFORM_HAS_WIN32_API
<span class="line-modified"> 683         // Windows always runs in little-endian mode.</span>
<span class="line-modified"> 684         *pIsBigEndian = FALSE;</span>
<span class="line-modified"> 685 </span>
<span class="line-modified"> 686         // Note: The various _M_&lt;arch&gt; macros are predefined by the MSVC compiler based</span>
<span class="line-modified"> 687         // on the target compilation architecture.</span>
<span class="line-modified"> 688         // https://docs.microsoft.com/cpp/preprocessor/predefined-macros</span>
<span class="line-modified"> 689 </span>
<span class="line-modified"> 690         // link.exe will link an IMAGE_FILE_MACHINE_UNKNOWN data-only .obj file</span>
<span class="line-modified"> 691         // no matter what architecture it is targeting (though other values are</span>
<span class="line-modified"> 692         // required to match). Unfortunately, the variable name decoration/mangling</span>
<span class="line-modified"> 693         // is slightly different on x86, which means we can&#39;t use the UNKNOWN type</span>
<span class="line-modified"> 694         // for all architectures though.</span>
<span class="line-added"> 695 #   if defined(_M_IX86)</span>
<span class="line-added"> 696         *pCPU = IMAGE_FILE_MACHINE_I386;</span>
 697 #   else
<span class="line-modified"> 698         *pCPU = IMAGE_FILE_MACHINE_UNKNOWN;</span>
<span class="line-added"> 699 #   endif</span>
<span class="line-added"> 700 #   if defined(_M_IA64) || defined(_M_AMD64) || defined (_M_ARM64)</span>
<span class="line-added"> 701         *pBits = 64; // Doesn&#39;t seem to be used for anything interesting though?</span>
<span class="line-added"> 702 #   elif defined(_M_IX86) || defined(_M_ARM)</span>
 703         *pBits = 32;
<span class="line-added"> 704 #   else</span>
<span class="line-added"> 705 #      error &quot;Unknown platform for CAN_GENERATE_OBJECTS.&quot;</span>
 706 #   endif

 707 #else
 708 #   error &quot;Unknown platform for CAN_GENERATE_OBJECTS.&quot;
 709 #endif
 710         return;
 711     }
 712 
 713     in=T_FileStream_open(filename, &quot;rb&quot;);
 714     if(in==NULL) {
 715         fprintf(stderr, &quot;genccode: unable to open match-arch file %s\n&quot;, filename);
 716         exit(U_FILE_ACCESS_ERROR);
 717     }
 718     length=T_FileStream_read(in, buffer.bytes, sizeof(buffer.bytes));
 719 
 720 #ifdef U_ELF
 721     if(length&lt;(int32_t)sizeof(Elf32_Ehdr)) {
 722         fprintf(stderr, &quot;genccode: match-arch file %s is too short\n&quot;, filename);
 723         exit(U_UNSUPPORTED_ERROR);
 724     }
 725     if(
 726         buffer.header32.e_ident[0]!=ELFMAG0 ||
</pre>
</td>
</tr>
</table>
<center><a href="package.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="pkg_gencmn.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>