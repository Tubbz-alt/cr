<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/normalizer2impl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="normalizer2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="normalizer2impl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/normalizer2impl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 *
   6 *   Copyright (C) 2009-2014, International Business Machines
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 *******************************************************************************
  10 *   file name:  normalizer2impl.cpp
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 2009nov22
  16 *   created by: Markus W. Scherer
  17 */
  18 


  19 #include &quot;unicode/utypes.h&quot;
  20 
  21 #if !UCONFIG_NO_NORMALIZATION
  22 
  23 #include &quot;unicode/bytestream.h&quot;
  24 #include &quot;unicode/edits.h&quot;
  25 #include &quot;unicode/normalizer2.h&quot;
  26 #include &quot;unicode/stringoptions.h&quot;

  27 #include &quot;unicode/udata.h&quot;

  28 #include &quot;unicode/ustring.h&quot;
  29 #include &quot;unicode/utf16.h&quot;
  30 #include &quot;unicode/utf8.h&quot;
  31 #include &quot;bytesinkutil.h&quot;
  32 #include &quot;cmemory.h&quot;
  33 #include &quot;mutex.h&quot;
  34 #include &quot;normalizer2impl.h&quot;
  35 #include &quot;putilimp.h&quot;
  36 #include &quot;uassert.h&quot;

  37 #include &quot;uset_imp.h&quot;
<span class="line-removed">  38 #include &quot;utrie2.h&quot;</span>
  39 #include &quot;uvector.h&quot;
  40 
  41 U_NAMESPACE_BEGIN
  42 
  43 namespace {
  44 
  45 /**
  46  * UTF-8 lead byte for minNoMaybeCP.
  47  * Can be lower than the actual lead byte for c.
  48  * Typically U+0300 for NFC/NFD, U+00A0 for NFKC/NFKD, U+0041 for NFKC_Casefold.
  49  */
  50 inline uint8_t leadByteForCP(UChar32 c) {
  51     if (c &lt;= 0x7f) {
  52         return (uint8_t)c;
  53     } else if (c &lt;= 0x7ff) {
  54         return (uint8_t)(0xc0+(c&gt;&gt;6));
  55     } else {
  56         // Should not occur because ccc(U+0300)!=0.
  57         return 0xe0;
  58     }
  59 }
  60 
  61 /**
  62  * Returns the code point from one single well-formed UTF-8 byte sequence
  63  * between cpStart and cpLimit.
  64  *
<span class="line-modified">  65  * UTrie2 UTF-8 macros do not assemble whole code points (for efficiency).</span>
  66  * When we do need the code point, we call this function.
  67  * We should not need it for normalization-inert data (norm16==0).
  68  * Illegal sequences yield the error value norm16==0 just like real normalization-inert code points.
  69  */
  70 UChar32 codePointFromValidUTF8(const uint8_t *cpStart, const uint8_t *cpLimit) {
  71     // Similar to U8_NEXT_UNSAFE(s, i, c).
  72     U_ASSERT(cpStart &lt; cpLimit);
  73     uint8_t c = *cpStart;
  74     switch(cpLimit-cpStart) {
  75     case 1:
  76         return c;
  77     case 2:
  78         return ((c&amp;0x1f)&lt;&lt;6) | (cpStart[1]&amp;0x3f);
  79     case 3:
  80         // no need for (c&amp;0xf) because the upper bits are truncated after &lt;&lt;12 in the cast to (UChar)
  81         return (UChar)((c&lt;&lt;12) | ((cpStart[1]&amp;0x3f)&lt;&lt;6) | (cpStart[2]&amp;0x3f));
  82     case 4:
  83         return ((c&amp;7)&lt;&lt;18) | ((cpStart[1]&amp;0x3f)&lt;&lt;12) | ((cpStart[2]&amp;0x3f)&lt;&lt;6) | (cpStart[3]&amp;0x3f);
  84     default:
<span class="line-modified">  85         U_ASSERT(FALSE);  // Should not occur.</span>
<span class="line-removed">  86         return U_SENTINEL;</span>
  87     }
  88 }
  89 
  90 /**
  91  * Returns the last code point in [start, p[ if it is valid and in U+1000..U+D7FF.
  92  * Otherwise returns a negative value.
  93  */
  94 UChar32 previousHangulOrJamo(const uint8_t *start, const uint8_t *p) {
  95     if ((p - start) &gt;= 3) {
  96         p -= 3;
  97         uint8_t l = *p;
  98         uint8_t t1, t2;
  99         if (0xe1 &lt;= l &amp;&amp; l &lt;= 0xed &amp;&amp;
 100                 (t1 = (uint8_t)(p[1] - 0x80)) &lt;= 0x3f &amp;&amp;
 101                 (t2 = (uint8_t)(p[2] - 0x80)) &lt;= 0x3f &amp;&amp;
 102                 (l &lt; 0xed || t1 &lt;= 0x1f)) {
 103             return ((l &amp; 0xf) &lt;&lt; 12) | (t1 &lt;&lt; 6) | t2;
 104         }
 105     }
 106     return U_SENTINEL;
 107 }
 108 
 109 /**
 110  * Returns the offset from the Jamo T base if [src, limit[ starts with a single Jamo T code point.
 111  * Otherwise returns a negative value.
 112  */
 113 int32_t getJamoTMinusBase(const uint8_t *src, const uint8_t *limit) {
 114     // Jamo T: E1 86 A8..E1 87 82
 115     if ((limit - src) &gt;= 3 &amp;&amp; *src == 0xe1) {
 116         if (src[1] == 0x86) {
 117             uint8_t t = src[2];
 118             // The first Jamo T is U+11A8 but JAMO_T_BASE is 11A7.
 119             // Offset 0 does not correspond to any conjoining Jamo.
 120             if (0xa8 &lt;= t &amp;&amp; t &lt;= 0xbf) {
 121                 return t - 0xa7;
 122             }
 123         } else if (src[1] == 0x87) {
 124             uint8_t t = src[2];
<span class="line-modified"> 125             if ((int8_t)t &lt;= (int8_t)0x82) {</span>
 126                 return t - (0xa7 - 0x40);
 127             }
 128         }
 129     }
 130     return -1;
 131 }
 132 
 133 void
 134 appendCodePointDelta(const uint8_t *cpStart, const uint8_t *cpLimit, int32_t delta,
 135                      ByteSink &amp;sink, Edits *edits) {
 136     char buffer[U8_MAX_LENGTH];
 137     int32_t length;
 138     int32_t cpLength = (int32_t)(cpLimit - cpStart);
 139     if (cpLength == 1) {
 140         // The builder makes ASCII map to ASCII.
 141         buffer[0] = (uint8_t)(*cpStart + delta);
 142         length = 1;
 143     } else {
 144         int32_t trail = *(cpLimit-1) + delta;
 145         if (0x80 &lt;= trail &amp;&amp; trail &lt;= 0xbf) {
</pre>
<hr />
<pre>
 236 
 237 UBool ReorderingBuffer::appendSupplementary(UChar32 c, uint8_t cc, UErrorCode &amp;errorCode) {
 238     if(remainingCapacity&lt;2 &amp;&amp; !resize(2, errorCode)) {
 239         return FALSE;
 240     }
 241     if(lastCC&lt;=cc || cc==0) {
 242         limit[0]=U16_LEAD(c);
 243         limit[1]=U16_TRAIL(c);
 244         limit+=2;
 245         lastCC=cc;
 246         if(cc&lt;=1) {
 247             reorderStart=limit;
 248         }
 249     } else {
 250         insert(c, cc);
 251     }
 252     remainingCapacity-=2;
 253     return TRUE;
 254 }
 255 
<span class="line-modified"> 256 UBool ReorderingBuffer::append(const UChar *s, int32_t length,</span>
 257                                uint8_t leadCC, uint8_t trailCC,
 258                                UErrorCode &amp;errorCode) {
 259     if(length==0) {
 260         return TRUE;
 261     }
 262     if(remainingCapacity&lt;length &amp;&amp; !resize(length, errorCode)) {
 263         return FALSE;
 264     }
 265     remainingCapacity-=length;
 266     if(lastCC&lt;=leadCC || leadCC==0) {
 267         if(trailCC&lt;=1) {
 268             reorderStart=limit+length;
 269         } else if(leadCC&lt;=1) {
 270             reorderStart=limit+1;  // Ok if not a code point boundary.
 271         }
 272         const UChar *sLimit=s+length;
 273         do { *limit++=*s++; } while(s!=sLimit);
 274         lastCC=trailCC;
 275     } else {
 276         int32_t i=0;
 277         UChar32 c;
 278         U16_NEXT(s, i, length, c);
 279         insert(c, leadCC);  // insert first code point
 280         while(i&lt;length) {
 281             U16_NEXT(s, i, length, c);
 282             if(i&lt;length) {
<span class="line-modified"> 283                 // s must be in NFD, otherwise we need to use getCC().</span>
<span class="line-modified"> 284                 leadCC=Normalizer2Impl::getCCFromYesOrMaybe(impl.getNorm16(c));</span>



 285             } else {
 286                 leadCC=trailCC;
 287             }
 288             append(c, leadCC, errorCode);
 289         }
 290     }
 291     return TRUE;
 292 }
 293 
 294 UBool ReorderingBuffer::appendZeroCC(UChar32 c, UErrorCode &amp;errorCode) {
 295     int32_t cpLength=U16_LENGTH(c);
 296     if(remainingCapacity&lt;cpLength &amp;&amp; !resize(cpLength, errorCode)) {
 297         return FALSE;
 298     }
 299     remainingCapacity-=cpLength;
 300     if(cpLength==1) {
 301         *limit++=(UChar)c;
 302     } else {
 303         limit[0]=U16_LEAD(c);
 304         limit[1]=U16_TRAIL(c);
</pre>
<hr />
<pre>
 394 void ReorderingBuffer::insert(UChar32 c, uint8_t cc) {
 395     for(setIterator(), skipPrevious(); previousCC()&gt;cc;) {}
 396     // insert c at codePointLimit, after the character with prevCC&lt;=cc
 397     UChar *q=limit;
 398     UChar *r=limit+=U16_LENGTH(c);
 399     do {
 400         *--r=*--q;
 401     } while(codePointLimit!=q);
 402     writeCodePoint(q, c);
 403     if(cc&lt;=1) {
 404         reorderStart=r;
 405     }
 406 }
 407 
 408 // Normalizer2Impl --------------------------------------------------------- ***
 409 
 410 struct CanonIterData : public UMemory {
 411     CanonIterData(UErrorCode &amp;errorCode);
 412     ~CanonIterData();
 413     void addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode &amp;errorCode);
<span class="line-modified"> 414     UTrie2 *trie;</span>

 415     UVector canonStartSets;  // contains UnicodeSet *
 416 };
 417 
 418 Normalizer2Impl::~Normalizer2Impl() {
 419     delete fCanonIterData;
 420 }
 421 
 422 void
<span class="line-modified"> 423 Normalizer2Impl::init(const int32_t *inIndexes, const UTrie2 *inTrie,</span>
 424                       const uint16_t *inExtraData, const uint8_t *inSmallFCD) {
<span class="line-modified"> 425     minDecompNoCP=inIndexes[IX_MIN_DECOMP_NO_CP];</span>
<span class="line-modified"> 426     minCompNoMaybeCP=inIndexes[IX_MIN_COMP_NO_MAYBE_CP];</span>
<span class="line-modified"> 427     minLcccCP=inIndexes[IX_MIN_LCCC_CP];</span>
<span class="line-modified"> 428 </span>
<span class="line-modified"> 429     minYesNo=inIndexes[IX_MIN_YES_NO];</span>
<span class="line-modified"> 430     minYesNoMappingsOnly=inIndexes[IX_MIN_YES_NO_MAPPINGS_ONLY];</span>
<span class="line-modified"> 431     minNoNo=inIndexes[IX_MIN_NO_NO];</span>
<span class="line-modified"> 432     minNoNoCompBoundaryBefore=inIndexes[IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE];</span>
<span class="line-modified"> 433     minNoNoCompNoMaybeCC=inIndexes[IX_MIN_NO_NO_COMP_NO_MAYBE_CC];</span>
<span class="line-modified"> 434     minNoNoEmpty=inIndexes[IX_MIN_NO_NO_EMPTY];</span>
<span class="line-modified"> 435     limitNoNo=inIndexes[IX_LIMIT_NO_NO];</span>
<span class="line-modified"> 436     minMaybeYes=inIndexes[IX_MIN_MAYBE_YES];</span>
<span class="line-modified"> 437     U_ASSERT((minMaybeYes&amp;7)==0);  // 8-aligned for noNoDelta bit fields</span>
<span class="line-modified"> 438     centerNoNoDelta=(minMaybeYes&gt;&gt;DELTA_SHIFT)-MAX_DELTA-1;</span>
 439 
 440     normTrie=inTrie;
 441 
 442     maybeYesCompositions=inExtraData;
 443     extraData=maybeYesCompositions+((MIN_NORMAL_MAYBE_YES-minMaybeYes)&gt;&gt;OFFSET_SHIFT);
 444 
 445     smallFCD=inSmallFCD;
 446 }
 447 
<span class="line-removed"> 448 class LcccContext {</span>
<span class="line-removed"> 449 public:</span>
<span class="line-removed"> 450     LcccContext(const Normalizer2Impl &amp;ni, UnicodeSet &amp;s) : impl(ni), set(s) {}</span>
<span class="line-removed"> 451 </span>
<span class="line-removed"> 452     void handleRange(UChar32 start, UChar32 end, uint16_t norm16) {</span>
<span class="line-removed"> 453         if (norm16 &gt; Normalizer2Impl::MIN_NORMAL_MAYBE_YES &amp;&amp;</span>
<span class="line-removed"> 454                 norm16 != Normalizer2Impl::JAMO_VT) {</span>
<span class="line-removed"> 455             set.add(start, end);</span>
<span class="line-removed"> 456         } else if (impl.minNoNoCompNoMaybeCC &lt;= norm16 &amp;&amp; norm16 &lt; impl.limitNoNo) {</span>
<span class="line-removed"> 457             uint16_t fcd16=impl.getFCD16(start);</span>
<span class="line-removed"> 458             if(fcd16&gt;0xff) { set.add(start, end); }</span>
<span class="line-removed"> 459         }</span>
<span class="line-removed"> 460     }</span>
<span class="line-removed"> 461 </span>
<span class="line-removed"> 462 private:</span>
<span class="line-removed"> 463     const Normalizer2Impl &amp;impl;</span>
<span class="line-removed"> 464     UnicodeSet &amp;set;</span>
<span class="line-removed"> 465 };</span>
<span class="line-removed"> 466 </span>
<span class="line-removed"> 467 namespace {</span>
<span class="line-removed"> 468 </span>
<span class="line-removed"> 469 struct PropertyStartsContext {</span>
<span class="line-removed"> 470     PropertyStartsContext(const Normalizer2Impl &amp;ni, const USetAdder *adder)</span>
<span class="line-removed"> 471             : impl(ni), sa(adder) {}</span>
<span class="line-removed"> 472 </span>
<span class="line-removed"> 473     const Normalizer2Impl &amp;impl;</span>
<span class="line-removed"> 474     const USetAdder *sa;</span>
<span class="line-removed"> 475 };</span>
<span class="line-removed"> 476 </span>
<span class="line-removed"> 477 }  // namespace</span>
<span class="line-removed"> 478 </span>
 479 U_CDECL_BEGIN
 480 
<span class="line-removed"> 481 static UBool U_CALLCONV</span>
<span class="line-removed"> 482 enumLcccRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {</span>
<span class="line-removed"> 483     ((LcccContext *)context)-&gt;handleRange(start, end, (uint16_t)value);</span>
<span class="line-removed"> 484     return TRUE;</span>
<span class="line-removed"> 485 }</span>
<span class="line-removed"> 486 </span>
<span class="line-removed"> 487 static UBool U_CALLCONV</span>
<span class="line-removed"> 488 enumNorm16PropertyStartsRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {</span>
<span class="line-removed"> 489     /* add the start code point to the USet */</span>
<span class="line-removed"> 490     const PropertyStartsContext *ctx=(const PropertyStartsContext *)context;</span>
<span class="line-removed"> 491     const USetAdder *sa=ctx-&gt;sa;</span>
<span class="line-removed"> 492     sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-removed"> 493     if (start != end &amp;&amp; ctx-&gt;impl.isAlgorithmicNoNo((uint16_t)value) &amp;&amp;</span>
<span class="line-removed"> 494             (value &amp; Normalizer2Impl::DELTA_TCCC_MASK) &gt; Normalizer2Impl::DELTA_TCCC_1) {</span>
<span class="line-removed"> 495         // Range of code points with same-norm16-value algorithmic decompositions.</span>
<span class="line-removed"> 496         // They might have different non-zero FCD16 values.</span>
<span class="line-removed"> 497         uint16_t prevFCD16=ctx-&gt;impl.getFCD16(start);</span>
<span class="line-removed"> 498         while(++start&lt;=end) {</span>
<span class="line-removed"> 499             uint16_t fcd16=ctx-&gt;impl.getFCD16(start);</span>
<span class="line-removed"> 500             if(fcd16!=prevFCD16) {</span>
<span class="line-removed"> 501                 sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-removed"> 502                 prevFCD16=fcd16;</span>
<span class="line-removed"> 503             }</span>
<span class="line-removed"> 504         }</span>
<span class="line-removed"> 505     }</span>
<span class="line-removed"> 506     return TRUE;</span>
<span class="line-removed"> 507 }</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509 static UBool U_CALLCONV</span>
<span class="line-removed"> 510 enumPropertyStartsRange(const void *context, UChar32 start, UChar32 /*end*/, uint32_t /*value*/) {</span>
<span class="line-removed"> 511     /* add the start code point to the USet */</span>
<span class="line-removed"> 512     const USetAdder *sa=(const USetAdder *)context;</span>
<span class="line-removed"> 513     sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-removed"> 514     return TRUE;</span>
<span class="line-removed"> 515 }</span>
<span class="line-removed"> 516 </span>
 517 static uint32_t U_CALLCONV
 518 segmentStarterMapper(const void * /*context*/, uint32_t value) {
 519     return value&amp;CANON_NOT_SEGMENT_STARTER;
 520 }
 521 
 522 U_CDECL_END
 523 
 524 void
 525 Normalizer2Impl::addLcccChars(UnicodeSet &amp;set) const {
<span class="line-modified"> 526     LcccContext context(*this, set);</span>
<span class="line-modified"> 527     utrie2_enum(normTrie, NULL, enumLcccRange, &amp;context);</span>











 528 }
 529 
 530 void
 531 Normalizer2Impl::addPropertyStarts(const USetAdder *sa, UErrorCode &amp; /*errorCode*/) const {
<span class="line-modified"> 532     /* add the start code point of each same-value range of each trie */</span>
<span class="line-modified"> 533     PropertyStartsContext context(*this, sa);</span>
<span class="line-modified"> 534     utrie2_enum(normTrie, NULL, enumNorm16PropertyStartsRange, &amp;context);</span>


















 535 
 536     /* add Hangul LV syllables and LV+1 because of skippables */
 537     for(UChar c=Hangul::HANGUL_BASE; c&lt;Hangul::HANGUL_LIMIT; c+=Hangul::JAMO_T_COUNT) {
 538         sa-&gt;add(sa-&gt;set, c);
 539         sa-&gt;add(sa-&gt;set, c+1);
 540     }
 541     sa-&gt;add(sa-&gt;set, Hangul::HANGUL_LIMIT); /* add Hangul+1 to continue with other properties */
 542 }
 543 
 544 void
 545 Normalizer2Impl::addCanonIterPropertyStarts(const USetAdder *sa, UErrorCode &amp;errorCode) const {
<span class="line-modified"> 546     /* add the start code point of each same-value range of the canonical iterator data trie */</span>
<span class="line-modified"> 547     if(ensureCanonIterData(errorCode)) {</span>
<span class="line-modified"> 548         // currently only used for the SEGMENT_STARTER property</span>
<span class="line-modified"> 549         utrie2_enum(fCanonIterData-&gt;trie, segmentStarterMapper, enumPropertyStartsRange, sa);</span>





 550     }
 551 }
 552 
 553 const UChar *
 554 Normalizer2Impl::copyLowPrefixFromNulTerminated(const UChar *src,
 555                                                 UChar32 minNeedDataCP,
 556                                                 ReorderingBuffer *buffer,
 557                                                 UErrorCode &amp;errorCode) const {
 558     // Make some effort to support NUL-terminated strings reasonably.
 559     // Take the part of the fast quick check loop that does not look up
 560     // data and check the first part of the string.
 561     // After this prefix, determine the string length to simplify the rest
 562     // of the code.
 563     const UChar *prevSrc=src;
 564     UChar c;
 565     while((c=*src++)&lt;minNeedDataCP &amp;&amp; c!=0) {}
 566     // Back out the last character for full processing.
 567     // Copy this prefix.
 568     if(--src!=prevSrc) {
 569         if(buffer!=NULL) {
</pre>
<hr />
<pre>
 616     if(limit==NULL) {
 617         src=copyLowPrefixFromNulTerminated(src, minNoCP, buffer, errorCode);
 618         if(U_FAILURE(errorCode)) {
 619             return src;
 620         }
 621         limit=u_strchr(src, 0);
 622     }
 623 
 624     const UChar *prevSrc;
 625     UChar32 c=0;
 626     uint16_t norm16=0;
 627 
 628     // only for quick check
 629     const UChar *prevBoundary=src;
 630     uint8_t prevCC=0;
 631 
 632     for(;;) {
 633         // count code units below the minimum or with irrelevant data for the quick check
 634         for(prevSrc=src; src!=limit;) {
 635             if( (c=*src)&lt;minNoCP ||
<span class="line-modified"> 636                 isMostDecompYesAndZeroCC(norm16=UTRIE2_GET16_FROM_U16_SINGLE_LEAD(normTrie, c))</span>
 637             ) {
 638                 ++src;
<span class="line-modified"> 639             } else if(!U16_IS_SURROGATE(c)) {</span>
 640                 break;
 641             } else {
 642                 UChar c2;
<span class="line-modified"> 643                 if(U16_IS_SURROGATE_LEAD(c)) {</span>
<span class="line-modified"> 644                     if((src+1)!=limit &amp;&amp; U16_IS_TRAIL(c2=src[1])) {</span>
<span class="line-modified"> 645                         c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified"> 646                     }</span>
<span class="line-modified"> 647                 } else /* trail surrogate */ {</span>
<span class="line-modified"> 648                     if(prevSrc&lt;src &amp;&amp; U16_IS_LEAD(c2=*(src-1))) {</span>
<span class="line-modified"> 649                         --src;</span>
<span class="line-removed"> 650                         c=U16_GET_SUPPLEMENTARY(c2, c);</span>
 651                     }
<span class="line-removed"> 652                 }</span>
<span class="line-removed"> 653                 if(isMostDecompYesAndZeroCC(norm16=getNorm16(c))) {</span>
<span class="line-removed"> 654                     src+=U16_LENGTH(c);</span>
 655                 } else {
<span class="line-modified"> 656                     break;</span>
 657                 }
 658             }
 659         }
 660         // copy these code units all at once
 661         if(src!=prevSrc) {
 662             if(buffer!=NULL) {
 663                 if(!buffer-&gt;appendZeroCC(prevSrc, src, errorCode)) {
 664                     break;
 665                 }
 666             } else {
 667                 prevCC=0;
 668                 prevBoundary=src;
 669             }
 670         }
 671         if(src==limit) {
 672             break;
 673         }
 674 
 675         // Check one above-minimum, relevant code point.
 676         src+=U16_LENGTH(c);
</pre>
<hr />
<pre>
 696 }
 697 
 698 // Decompose a short piece of text which is likely to contain characters that
 699 // fail the quick check loop and/or where the quick check loop&#39;s overhead
 700 // is unlikely to be amortized.
 701 // Called by the compose() and makeFCD() implementations.
 702 const UChar *
 703 Normalizer2Impl::decomposeShort(const UChar *src, const UChar *limit,
 704                                 UBool stopAtCompBoundary, UBool onlyContiguous,
 705                                 ReorderingBuffer &amp;buffer, UErrorCode &amp;errorCode) const {
 706     if (U_FAILURE(errorCode)) {
 707         return nullptr;
 708     }
 709     while(src&lt;limit) {
 710         if (stopAtCompBoundary &amp;&amp; *src &lt; minCompNoMaybeCP) {
 711             return src;
 712         }
 713         const UChar *prevSrc = src;
 714         UChar32 c;
 715         uint16_t norm16;
<span class="line-modified"> 716         UTRIE2_U16_NEXT16(normTrie, src, limit, c, norm16);</span>
 717         if (stopAtCompBoundary &amp;&amp; norm16HasCompBoundaryBefore(norm16)) {
 718             return prevSrc;
 719         }
 720         if(!decompose(c, norm16, buffer, errorCode)) {
 721             return nullptr;
 722         }
 723         if (stopAtCompBoundary &amp;&amp; norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
 724             return src;
 725         }
 726     }
 727     return src;
 728 }
 729 
 730 UBool Normalizer2Impl::decompose(UChar32 c, uint16_t norm16,
 731                                  ReorderingBuffer &amp;buffer,
 732                                  UErrorCode &amp;errorCode) const {
 733     // get the decomposition and the lead and trail cc&#39;s
 734     if (norm16 &gt;= limitNoNo) {
 735         if (isMaybeOrNonZeroCC(norm16)) {
 736             return buffer.append(c, getCCFromYesOrMaybe(norm16), errorCode);
 737         }
 738         // Maps to an isCompYesAndZeroCC.
 739         c=mapAlgorithmic(c, norm16);
<span class="line-modified"> 740         norm16=getNorm16(c);</span>
 741     }
 742     if (norm16 &lt; minYesNo) {
 743         // c does not decompose
 744         return buffer.append(c, 0, errorCode);
 745     } else if(isHangulLV(norm16) || isHangulLVT(norm16)) {
 746         // Hangul syllable: decompose algorithmically
 747         UChar jamos[3];
 748         return buffer.appendZeroCC(jamos, jamos+Hangul::decompose(c, jamos), errorCode);
 749     }
 750     // c decomposes, get everything from the variable-length extra data
 751     const uint16_t *mapping=getMapping(norm16);
 752     uint16_t firstUnit=*mapping;
 753     int32_t length=firstUnit&amp;MAPPING_LENGTH_MASK;
 754     uint8_t leadCC, trailCC;
 755     trailCC=(uint8_t)(firstUnit&gt;&gt;8);
 756     if(firstUnit&amp;MAPPING_HAS_CCC_LCCC_WORD) {
 757         leadCC=(uint8_t)(*(mapping-1)&gt;&gt;8);
 758     } else {
 759         leadCC=0;
 760     }
<span class="line-modified"> 761     return buffer.append((const UChar *)mapping+1, length, leadCC, trailCC, errorCode);</span>
 762 }
 763 
 764 const uint8_t *
 765 Normalizer2Impl::decomposeShort(const uint8_t *src, const uint8_t *limit,
 766                                 UBool stopAtCompBoundary, UBool onlyContiguous,
 767                                 ReorderingBuffer &amp;buffer, UErrorCode &amp;errorCode) const {
 768     if (U_FAILURE(errorCode)) {
 769         return nullptr;
 770     }
 771     while (src &lt; limit) {
 772         const uint8_t *prevSrc = src;
 773         uint16_t norm16;
<span class="line-modified"> 774         UTRIE2_U8_NEXT16(normTrie, src, limit, norm16);</span>
 775         // Get the decomposition and the lead and trail cc&#39;s.
 776         UChar32 c = U_SENTINEL;
 777         if (norm16 &gt;= limitNoNo) {
 778             if (isMaybeOrNonZeroCC(norm16)) {
 779                 // No boundaries around this character.
 780                 c = codePointFromValidUTF8(prevSrc, src);
 781                 if (!buffer.append(c, getCCFromYesOrMaybe(norm16), errorCode)) {
 782                     return nullptr;
 783                 }
 784                 continue;
 785             }
 786             // Maps to an isCompYesAndZeroCC.
 787             if (stopAtCompBoundary) {
 788                 return prevSrc;
 789             }
 790             c = codePointFromValidUTF8(prevSrc, src);
 791             c = mapAlgorithmic(c, norm16);
<span class="line-modified"> 792             norm16 = getNorm16(c);</span>
 793         } else if (stopAtCompBoundary &amp;&amp; norm16 &lt; minNoNoCompNoMaybeCC) {
 794             return prevSrc;
 795         }
 796         // norm16!=INERT guarantees that [prevSrc, src[ is valid UTF-8.
 797         // We do not see invalid UTF-8 here because
 798         // its norm16==INERT is normalization-inert,
 799         // so it gets copied unchanged in the fast path,
 800         // and we stop the slow path where invalid UTF-8 begins.
 801         U_ASSERT(norm16 != INERT);
 802         if (norm16 &lt; minYesNo) {
 803             if (c &lt; 0) {
 804                 c = codePointFromValidUTF8(prevSrc, src);
 805             }
 806             // does not decompose
 807             if (!buffer.append(c, 0, errorCode)) {
 808                 return nullptr;
 809             }
 810         } else if (isHangulLV(norm16) || isHangulLVT(norm16)) {
 811             // Hangul syllable: decompose algorithmically
 812             if (c &lt; 0) {
 813                 c = codePointFromValidUTF8(prevSrc, src);
 814             }
 815             char16_t jamos[3];
 816             if (!buffer.appendZeroCC(jamos, jamos+Hangul::decompose(c, jamos), errorCode)) {
 817                 return nullptr;
 818             }
 819         } else {
 820             // The character decomposes, get everything from the variable-length extra data.
 821             const uint16_t *mapping = getMapping(norm16);
 822             uint16_t firstUnit = *mapping;
 823             int32_t length = firstUnit &amp; MAPPING_LENGTH_MASK;
 824             uint8_t trailCC = (uint8_t)(firstUnit &gt;&gt; 8);
 825             uint8_t leadCC;
 826             if (firstUnit &amp; MAPPING_HAS_CCC_LCCC_WORD) {
 827                 leadCC = (uint8_t)(*(mapping-1) &gt;&gt; 8);
 828             } else {
 829                 leadCC = 0;
 830             }
<span class="line-modified"> 831             if (!buffer.append((const char16_t *)mapping+1, length, leadCC, trailCC, errorCode)) {</span>
 832                 return nullptr;
 833             }
 834         }
 835         if (stopAtCompBoundary &amp;&amp; norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
 836             return src;
 837         }
 838     }
 839     return src;
 840 }
 841 
 842 const UChar *
 843 Normalizer2Impl::getDecomposition(UChar32 c, UChar buffer[4], int32_t &amp;length) const {
 844     uint16_t norm16;
 845     if(c&lt;minDecompNoCP || isMaybeOrNonZeroCC(norm16=getNorm16(c))) {
 846         // c does not decompose
 847         return nullptr;
 848     }
 849     const UChar *decomp = nullptr;
 850     if(isDecompNoAlgorithmic(norm16)) {
 851         // Maps to an isCompYesAndZeroCC.
 852         c=mapAlgorithmic(c, norm16);
 853         decomp=buffer;
 854         length=0;
 855         U16_APPEND_UNSAFE(buffer, length, c);
 856         // The mapping might decompose further.
<span class="line-modified"> 857         norm16 = getNorm16(c);</span>
 858     }
 859     if (norm16 &lt; minYesNo) {
 860         return decomp;
 861     } else if(isHangulLV(norm16) || isHangulLVT(norm16)) {
 862         // Hangul syllable: decompose algorithmically
 863         length=Hangul::decompose(c, buffer);
 864         return buffer;
 865     }
 866     // c decomposes, get everything from the variable-length extra data
 867     const uint16_t *mapping=getMapping(norm16);
 868     length=*mapping&amp;MAPPING_LENGTH_MASK;
 869     return (const UChar *)mapping+1;
 870 }
 871 
 872 // The capacity of the buffer must be 30=MAPPING_LENGTH_MASK-1
 873 // so that a raw mapping fits that consists of one unit (&quot;rm0&quot;)
 874 // plus all but the first two code units of the normal mapping.
 875 // The maximum length of a normal mapping is 31=MAPPING_LENGTH_MASK.
 876 const UChar *
 877 Normalizer2Impl::getRawDecomposition(UChar32 c, UChar buffer[30], int32_t &amp;length) const {
</pre>
<hr />
<pre>
 909             length=mLength-1;
 910             return buffer;
 911         }
 912     } else {
 913         length=mLength;
 914         return (const UChar *)mapping+1;
 915     }
 916 }
 917 
 918 void Normalizer2Impl::decomposeAndAppend(const UChar *src, const UChar *limit,
 919                                          UBool doDecompose,
 920                                          UnicodeString &amp;safeMiddle,
 921                                          ReorderingBuffer &amp;buffer,
 922                                          UErrorCode &amp;errorCode) const {
 923     buffer.copyReorderableSuffixTo(safeMiddle);
 924     if(doDecompose) {
 925         decompose(src, limit, &amp;buffer, errorCode);
 926         return;
 927     }
 928     // Just merge the strings at the boundary.
<span class="line-modified"> 929     ForwardUTrie2StringIterator iter(normTrie, src, limit);</span>
<span class="line-modified"> 930     uint8_t firstCC, prevCC, cc;</span>
<span class="line-modified"> 931     firstCC=prevCC=cc=getCC(iter.next16());</span>
<span class="line-modified"> 932     while(cc!=0) {</span>
<span class="line-modified"> 933         prevCC=cc;</span>
<span class="line-modified"> 934         cc=getCC(iter.next16());</span>
<span class="line-modified"> 935     };</span>











 936     if(limit==NULL) {  // appendZeroCC() needs limit!=NULL
<span class="line-modified"> 937         limit=u_strchr(iter.codePointStart, 0);</span>
 938     }
 939 
<span class="line-modified"> 940     if (buffer.append(src, (int32_t)(iter.codePointStart-src), firstCC, prevCC, errorCode)) {</span>
<span class="line-modified"> 941         buffer.appendZeroCC(iter.codePointStart, limit, errorCode);</span>
 942     }
 943 }
 944 
 945 UBool Normalizer2Impl::hasDecompBoundaryBefore(UChar32 c) const {
 946     return c &lt; minLcccCP || (c &lt;= 0xffff &amp;&amp; !singleLeadMightHaveNonZeroFCD16(c)) ||
 947         norm16HasDecompBoundaryBefore(getNorm16(c));
 948 }
 949 
 950 UBool Normalizer2Impl::norm16HasDecompBoundaryBefore(uint16_t norm16) const {
 951     if (norm16 &lt; minNoNoCompNoMaybeCC) {
 952         return TRUE;
 953     }
 954     if (norm16 &gt;= limitNoNo) {
 955         return norm16 &lt;= MIN_NORMAL_MAYBE_YES || norm16 == JAMO_VT;
 956     }
 957     // c decomposes, get everything from the variable-length extra data
 958     const uint16_t *mapping=getMapping(norm16);
 959     uint16_t firstUnit=*mapping;
 960     // TRUE if leadCC==0 (hasFCDBoundaryBefore())
 961     return (firstUnit&amp;MAPPING_HAS_CCC_LCCC_WORD)==0 || (*(mapping-1)&amp;0xff00)==0;
</pre>
<hr />
<pre>
1068 }
1069 
1070 /**
1071   * @param list some character&#39;s compositions list
1072   * @param set recursively receives the composites from these compositions
1073   */
1074 void Normalizer2Impl::addComposites(const uint16_t *list, UnicodeSet &amp;set) const {
1075     uint16_t firstUnit;
1076     int32_t compositeAndFwd;
1077     do {
1078         firstUnit=*list;
1079         if((firstUnit&amp;COMP_1_TRIPLE)==0) {
1080             compositeAndFwd=list[1];
1081             list+=2;
1082         } else {
1083             compositeAndFwd=(((int32_t)list[1]&amp;~COMP_2_TRAIL_MASK)&lt;&lt;16)|list[2];
1084             list+=3;
1085         }
1086         UChar32 composite=compositeAndFwd&gt;&gt;1;
1087         if((compositeAndFwd&amp;1)!=0) {
<span class="line-modified">1088             addComposites(getCompositionsListForComposite(getNorm16(composite)), set);</span>
1089         }
1090         set.add(composite);
1091     } while((firstUnit&amp;COMP_1_LAST_TUPLE)==0);
1092 }
1093 
1094 /*
1095  * Recomposes the buffer text starting at recomposeStartIndex
1096  * (which is in NFD - decomposed and canonically ordered),
1097  * and truncates the buffer contents.
1098  *
1099  * Note that recomposition never lengthens the text:
1100  * Any character consists of either one or two code units;
1101  * a composition may contain at most one more code unit than the original starter,
1102  * while the combining mark that is removed has at least one code unit.
1103  */
1104 void Normalizer2Impl::recompose(ReorderingBuffer &amp;buffer, int32_t recomposeStartIndex,
1105                                 UBool onlyContiguous) const {
1106     UChar *p=buffer.getStart()+recomposeStartIndex;
1107     UChar *limit=buffer.getLimit();
1108     if(p==limit) {
1109         return;
1110     }
1111 
1112     UChar *starter, *pRemove, *q, *r;
1113     const uint16_t *compositionsList;
1114     UChar32 c, compositeAndFwd;
1115     uint16_t norm16;
1116     uint8_t cc, prevCC;
1117     UBool starterIsSupplementary;
1118 
1119     // Some of the following variables are not used until we have a forward-combining starter
1120     // and are only initialized now to avoid compiler warnings.
1121     compositionsList=NULL;  // used as indicator for whether we have a forward-combining starter
1122     starter=NULL;
1123     starterIsSupplementary=FALSE;
1124     prevCC=0;
1125 
1126     for(;;) {
<span class="line-modified">1127         UTRIE2_U16_NEXT16(normTrie, p, limit, c, norm16);</span>
1128         cc=getCCFromYesOrMaybe(norm16);
1129         if( // this character combines backward and
1130             isMaybe(norm16) &amp;&amp;
1131             // we have seen a starter that combines forward and
1132             compositionsList!=NULL &amp;&amp;
1133             // the backward-combining character is not blocked
1134             (prevCC&lt;cc || prevCC==0)
1135         ) {
1136             if(isJamoVT(norm16)) {
1137                 // c is a Jamo V/T, see if we can compose it with the previous character.
1138                 if(c&lt;Hangul::JAMO_T_BASE) {
1139                     // c is a Jamo Vowel, compose with previous Jamo L and following Jamo T.
1140                     UChar prev=(UChar)(*starter-Hangul::JAMO_L_BASE);
1141                     if(prev&lt;Hangul::JAMO_L_COUNT) {
1142                         pRemove=p-1;
1143                         UChar syllable=(UChar)
1144                             (Hangul::HANGUL_BASE+
1145                              (prev*Hangul::JAMO_V_COUNT+(c-Hangul::JAMO_V_BASE))*
1146                              Hangul::JAMO_T_COUNT);
1147                         UChar t;
</pre>
<hr />
<pre>
1212                 }
1213 
1214                 /* remove the combining mark by moving the following text over it */
1215                 if(pRemove&lt;p) {
1216                     q=pRemove;
1217                     r=p;
1218                     while(r&lt;limit) {
1219                         *q++=*r++;
1220                     }
1221                     limit=q;
1222                     p=pRemove;
1223                 }
1224                 // Keep prevCC because we removed the combining mark.
1225 
1226                 if(p==limit) {
1227                     break;
1228                 }
1229                 // Is the composite a starter that combines forward?
1230                 if(compositeAndFwd&amp;1) {
1231                     compositionsList=
<span class="line-modified">1232                         getCompositionsListForComposite(getNorm16(composite));</span>
1233                 } else {
1234                     compositionsList=NULL;
1235                 }
1236 
1237                 // We combined; continue with looking for compositions.
1238                 continue;
1239             }
1240         }
1241 
1242         // no combination this time
1243         prevCC=cc;
1244         if(p==limit) {
1245             break;
1246         }
1247 
1248         // If c did not combine, then check if it is a starter.
1249         if(cc==0) {
1250             // Found a new starter.
1251             if((compositionsList=getCompositionsListForDecompYes(norm16))!=NULL) {
1252                 // It may combine with something, prepare for it.
1253                 if(U_IS_BMP(c)) {
1254                     starterIsSupplementary=FALSE;
1255                     starter=p-1;
1256                 } else {
1257                     starterIsSupplementary=TRUE;
1258                     starter=p-2;
1259                 }
1260             }
1261         } else if(onlyContiguous) {
1262             // FCC: no discontiguous compositions; any intervening character blocks.
1263             compositionsList=NULL;
1264         }
1265     }
1266     buffer.setReorderingLimit(limit);
1267 }
1268 
1269 UChar32
1270 Normalizer2Impl::composePair(UChar32 a, UChar32 b) const {
<span class="line-modified">1271     uint16_t norm16=getNorm16(a);  // maps an out-of-range &#39;a&#39; to inert norm16=0</span>
1272     const uint16_t *list;
1273     if(isInert(norm16)) {
1274         return U_SENTINEL;
1275     } else if(norm16&lt;minYesNoMappingsOnly) {
1276         // a combines forward.
1277         if(isJamoL(norm16)) {
1278             b-=Hangul::JAMO_V_BASE;
1279             if(0&lt;=b &amp;&amp; b&lt;Hangul::JAMO_V_COUNT) {
1280                 return
1281                     (Hangul::HANGUL_BASE+
1282                      ((a-Hangul::JAMO_L_BASE)*Hangul::JAMO_V_COUNT+b)*
1283                      Hangul::JAMO_T_COUNT);
1284             } else {
1285                 return U_SENTINEL;
1286             }
1287         } else if(isHangulLV(norm16)) {
1288             b-=Hangul::JAMO_T_BASE;
1289             if(0&lt;b &amp;&amp; b&lt;Hangul::JAMO_T_COUNT) {  // not b==0!
1290                 return a+b;
1291             } else {
</pre>
<hr />
<pre>
1342                 buffer.removeSuffix(1);
1343                 prevBoundary = --src;
1344             }
1345         }
1346     }
1347 
1348     for (;;) {
1349         // Fast path: Scan over a sequence of characters below the minimum &quot;no or maybe&quot; code point,
1350         // or with (compYes &amp;&amp; ccc==0) properties.
1351         const UChar *prevSrc;
1352         UChar32 c = 0;
1353         uint16_t norm16 = 0;
1354         for (;;) {
1355             if (src == limit) {
1356                 if (prevBoundary != limit &amp;&amp; doCompose) {
1357                     buffer.appendZeroCC(prevBoundary, limit, errorCode);
1358                 }
1359                 return TRUE;
1360             }
1361             if( (c=*src)&lt;minNoMaybeCP ||
<span class="line-modified">1362                 isCompYesAndZeroCC(norm16=UTRIE2_GET16_FROM_U16_SINGLE_LEAD(normTrie, c))</span>
1363             ) {
1364                 ++src;
1365             } else {
1366                 prevSrc = src++;
<span class="line-modified">1367                 if(!U16_IS_SURROGATE(c)) {</span>
1368                     break;
1369                 } else {
1370                     UChar c2;
<span class="line-modified">1371                     if(U16_IS_SURROGATE_LEAD(c)) {</span>
<span class="line-modified">1372                         if(src!=limit &amp;&amp; U16_IS_TRAIL(c2=*src)) {</span>
<span class="line-modified">1373                             ++src;</span>
<span class="line-modified">1374                             c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified">1375                         }</span>
<span class="line-modified">1376                     } else /* trail surrogate */ {</span>
<span class="line-removed">1377                         if(prevBoundary&lt;prevSrc &amp;&amp; U16_IS_LEAD(c2=*(prevSrc-1))) {</span>
<span class="line-removed">1378                             --prevSrc;</span>
<span class="line-removed">1379                             c=U16_GET_SUPPLEMENTARY(c2, c);</span>
1380                         }
1381                     }
<span class="line-removed">1382                     if(!isCompYesAndZeroCC(norm16=getNorm16(c))) {</span>
<span class="line-removed">1383                         break;</span>
<span class="line-removed">1384                     }</span>
1385                 }
1386             }
1387         }
1388         // isCompYesAndZeroCC(norm16) is false, that is, norm16&gt;=minNoNo.
1389         // The current character is either a &quot;noNo&quot; (has a mapping)
1390         // or a &quot;maybeYes&quot; (combines backward)
1391         // or a &quot;yesYes&quot; with ccc!=0.
1392         // It is not a Hangul syllable or Jamo L because those have &quot;yes&quot; properties.
1393 
1394         // Medium-fast path: Handle cases that do not require full decomposition and recomposition.
1395         if (!isMaybeOrNonZeroCC(norm16)) {  // minNoNo &lt;= norm16 &lt; minMaybeYes
1396             if (!doCompose) {
1397                 return FALSE;
1398             }
1399             // Fast path for mapping a character that is immediately surrounded by boundaries.
1400             // In this case, we need not decompose around the current character.
1401             if (isDecompNoAlgorithmic(norm16)) {
1402                 // Maps to a single isCompYesAndZeroCC character
1403                 // which also implies hasCompBoundaryBefore.
1404                 if (norm16HasCompBoundaryAfter(norm16, onlyContiguous) ||
</pre>
<hr />
<pre>
1512             uint8_t cc = getCCFromNormalYesOrMaybe(norm16);  // cc!=0
1513             if (onlyContiguous /* FCC */ &amp;&amp; getPreviousTrailCC(prevBoundary, prevSrc) &gt; cc) {
1514                 // Fails FCD test, need to decompose and contiguously recompose.
1515                 if (!doCompose) {
1516                     return FALSE;
1517                 }
1518             } else {
1519                 // If !onlyContiguous (not FCC), then we ignore the tccc of
1520                 // the previous character which passed the quick check &quot;yes &amp;&amp; ccc==0&quot; test.
1521                 const UChar *nextSrc;
1522                 uint16_t n16;
1523                 for (;;) {
1524                     if (src == limit) {
1525                         if (doCompose) {
1526                             buffer.appendZeroCC(prevBoundary, limit, errorCode);
1527                         }
1528                         return TRUE;
1529                     }
1530                     uint8_t prevCC = cc;
1531                     nextSrc = src;
<span class="line-modified">1532                     UTRIE2_U16_NEXT16(normTrie, nextSrc, limit, c, n16);</span>
1533                     if (n16 &gt;= MIN_YES_YES_WITH_CC) {
1534                         cc = getCCFromNormalYesOrMaybe(n16);
1535                         if (prevCC &gt; cc) {
1536                             if (!doCompose) {
1537                                 return FALSE;
1538                             }
1539                             break;
1540                         }
1541                     } else {
1542                         break;
1543                     }
1544                     src = nextSrc;
1545                 }
1546                 // src is after the last in-order combining mark.
1547                 // If there is a boundary here, then we continue with no change.
1548                 if (norm16HasCompBoundaryBefore(n16)) {
1549                     if (isCompYesAndZeroCC(n16)) {
1550                         src = nextSrc;
1551                     }
1552                     continue;
1553                 }
1554                 // Use the slow path. There is no boundary in [prevSrc, src[.
1555             }
1556         }
1557 
1558         // Slow path: Find the nearest boundaries around the current character,
1559         // decompose and recompose.
1560         if (prevBoundary != prevSrc &amp;&amp; !norm16HasCompBoundaryBefore(norm16)) {
1561             const UChar *p = prevSrc;
<span class="line-modified">1562             UTRIE2_U16_PREV16(normTrie, prevBoundary, p, c, norm16);</span>
1563             if (!norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
1564                 prevSrc = p;
1565             }
1566         }
1567         if (doCompose &amp;&amp; prevBoundary != prevSrc &amp;&amp; !buffer.appendZeroCC(prevBoundary, prevSrc, errorCode)) {
1568             break;
1569         }
1570         int32_t recomposeStartIndex=buffer.length();
1571         // We know there is not a boundary here.
1572         decomposeShort(prevSrc, src, FALSE /* !stopAtCompBoundary */, onlyContiguous,
1573                        buffer, errorCode);
1574         // Decompose until the next boundary.
1575         src = decomposeShort(src, limit, TRUE /* stopAtCompBoundary */, onlyContiguous,
1576                              buffer, errorCode);
1577         if (U_FAILURE(errorCode)) {
1578             break;
1579         }
1580         if ((src - prevSrc) &gt; INT32_MAX) {  // guard before buffer.equals()
1581             errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
1582             return TRUE;
</pre>
<hr />
<pre>
1609         if (prevBoundary != src) {
1610             if (hasCompBoundaryAfter(*(src-1), onlyContiguous)) {
1611                 prevBoundary = src;
1612             } else {
1613                 prevBoundary = --src;
1614             }
1615         }
1616     }
1617 
1618     for(;;) {
1619         // Fast path: Scan over a sequence of characters below the minimum &quot;no or maybe&quot; code point,
1620         // or with (compYes &amp;&amp; ccc==0) properties.
1621         const UChar *prevSrc;
1622         UChar32 c = 0;
1623         uint16_t norm16 = 0;
1624         for (;;) {
1625             if(src==limit) {
1626                 return src;
1627             }
1628             if( (c=*src)&lt;minNoMaybeCP ||
<span class="line-modified">1629                 isCompYesAndZeroCC(norm16=UTRIE2_GET16_FROM_U16_SINGLE_LEAD(normTrie, c))</span>
1630             ) {
1631                 ++src;
1632             } else {
1633                 prevSrc = src++;
<span class="line-modified">1634                 if(!U16_IS_SURROGATE(c)) {</span>
1635                     break;
1636                 } else {
1637                     UChar c2;
<span class="line-modified">1638                     if(U16_IS_SURROGATE_LEAD(c)) {</span>
<span class="line-modified">1639                         if(src!=limit &amp;&amp; U16_IS_TRAIL(c2=*src)) {</span>
<span class="line-modified">1640                             ++src;</span>
<span class="line-modified">1641                             c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified">1642                         }</span>
<span class="line-modified">1643                     } else /* trail surrogate */ {</span>
<span class="line-removed">1644                         if(prevBoundary&lt;prevSrc &amp;&amp; U16_IS_LEAD(c2=*(prevSrc-1))) {</span>
<span class="line-removed">1645                             --prevSrc;</span>
<span class="line-removed">1646                             c=U16_GET_SUPPLEMENTARY(c2, c);</span>
1647                         }
1648                     }
<span class="line-removed">1649                     if(!isCompYesAndZeroCC(norm16=getNorm16(c))) {</span>
<span class="line-removed">1650                         break;</span>
<span class="line-removed">1651                     }</span>
1652                 }
1653             }
1654         }
1655         // isCompYesAndZeroCC(norm16) is false, that is, norm16&gt;=minNoNo.
1656         // The current character is either a &quot;noNo&quot; (has a mapping)
1657         // or a &quot;maybeYes&quot; (combines backward)
1658         // or a &quot;yesYes&quot; with ccc!=0.
1659         // It is not a Hangul syllable or Jamo L because those have &quot;yes&quot; properties.
1660 
1661         uint16_t prevNorm16 = INERT;
1662         if (prevBoundary != prevSrc) {
1663             if (norm16HasCompBoundaryBefore(norm16)) {
1664                 prevBoundary = prevSrc;
1665             } else {
1666                 const UChar *p = prevSrc;
1667                 uint16_t n16;
<span class="line-modified">1668                 UTRIE2_U16_PREV16(normTrie, prevBoundary, p, c, n16);</span>
1669                 if (norm16HasCompBoundaryAfter(n16, onlyContiguous)) {
1670                     prevBoundary = prevSrc;
1671                 } else {
1672                     prevBoundary = p;
1673                     prevNorm16 = n16;
1674                 }
1675             }
1676         }
1677 
1678         if(isMaybeOrNonZeroCC(norm16)) {
1679             uint8_t cc=getCCFromYesOrMaybe(norm16);
1680             if (onlyContiguous /* FCC */ &amp;&amp; cc != 0 &amp;&amp;
1681                     getTrailCCFromCompYesAndZeroCC(prevNorm16) &gt; cc) {
1682                 // The [prevBoundary..prevSrc[ character
1683                 // passed the quick check &quot;yes &amp;&amp; ccc==0&quot; test
1684                 // but is out of canonical order with the current combining mark.
1685             } else {
1686                 // If !onlyContiguous (not FCC), then we ignore the tccc of
1687                 // the previous character which passed the quick check &quot;yes &amp;&amp; ccc==0&quot; test.
1688                 const UChar *nextSrc;
1689                 for (;;) {
1690                     if (norm16 &lt; MIN_YES_YES_WITH_CC) {
1691                         if (pQCResult != nullptr) {
1692                             *pQCResult = UNORM_MAYBE;
1693                         } else {
1694                             return prevBoundary;
1695                         }
1696                     }
1697                     if (src == limit) {
1698                         return src;
1699                     }
1700                     uint8_t prevCC = cc;
1701                     nextSrc = src;
<span class="line-modified">1702                     UTRIE2_U16_NEXT16(normTrie, nextSrc, limit, c, norm16);</span>
1703                     if (isMaybeOrNonZeroCC(norm16)) {
1704                         cc = getCCFromYesOrMaybe(norm16);
1705                         if (!(prevCC &lt;= cc || cc == 0)) {
1706                             break;
1707                         }
1708                     } else {
1709                         break;
1710                     }
1711                     src = nextSrc;
1712                 }
1713                 // src is after the last in-order combining mark.
1714                 if (isCompYesAndZeroCC(norm16)) {
1715                     prevBoundary = src;
1716                     src = nextSrc;
1717                     continue;
1718                 }
1719             }
1720         }
1721         if(pQCResult!=NULL) {
1722             *pQCResult=UNORM_NO;
</pre>
<hr />
<pre>
1769     uint8_t minNoMaybeLead = leadByteForCP(minCompNoMaybeCP);
1770     const uint8_t *prevBoundary = src;
1771 
1772     for (;;) {
1773         // Fast path: Scan over a sequence of characters below the minimum &quot;no or maybe&quot; code point,
1774         // or with (compYes &amp;&amp; ccc==0) properties.
1775         const uint8_t *prevSrc;
1776         uint16_t norm16 = 0;
1777         for (;;) {
1778             if (src == limit) {
1779                 if (prevBoundary != limit &amp;&amp; sink != nullptr) {
1780                     ByteSinkUtil::appendUnchanged(prevBoundary, limit,
1781                                                   *sink, options, edits, errorCode);
1782                 }
1783                 return TRUE;
1784             }
1785             if (*src &lt; minNoMaybeLead) {
1786                 ++src;
1787             } else {
1788                 prevSrc = src;
<span class="line-modified">1789                 UTRIE2_U8_NEXT16(normTrie, src, limit, norm16);</span>
1790                 if (!isCompYesAndZeroCC(norm16)) {
1791                     break;
1792                 }
1793             }
1794         }
1795         // isCompYesAndZeroCC(norm16) is false, that is, norm16&gt;=minNoNo.
1796         // The current character is either a &quot;noNo&quot; (has a mapping)
1797         // or a &quot;maybeYes&quot; (combines backward)
1798         // or a &quot;yesYes&quot; with ccc!=0.
1799         // It is not a Hangul syllable or Jamo L because those have &quot;yes&quot; properties.
1800 
1801         // Medium-fast path: Handle cases that do not require full decomposition and recomposition.
1802         if (!isMaybeOrNonZeroCC(norm16)) {  // minNoNo &lt;= norm16 &lt; minMaybeYes
1803             if (sink == nullptr) {
1804                 return FALSE;
1805             }
1806             // Fast path for mapping a character that is immediately surrounded by boundaries.
1807             // In this case, we need not decompose around the current character.
1808             if (isDecompNoAlgorithmic(norm16)) {
1809                 // Maps to a single isCompYesAndZeroCC character
</pre>
<hr />
<pre>
1928             if (onlyContiguous /* FCC */ &amp;&amp; getPreviousTrailCC(prevBoundary, prevSrc) &gt; cc) {
1929                 // Fails FCD test, need to decompose and contiguously recompose.
1930                 if (sink == nullptr) {
1931                     return FALSE;
1932                 }
1933             } else {
1934                 // If !onlyContiguous (not FCC), then we ignore the tccc of
1935                 // the previous character which passed the quick check &quot;yes &amp;&amp; ccc==0&quot; test.
1936                 const uint8_t *nextSrc;
1937                 uint16_t n16;
1938                 for (;;) {
1939                     if (src == limit) {
1940                         if (sink != nullptr) {
1941                             ByteSinkUtil::appendUnchanged(prevBoundary, limit,
1942                                                           *sink, options, edits, errorCode);
1943                         }
1944                         return TRUE;
1945                     }
1946                     uint8_t prevCC = cc;
1947                     nextSrc = src;
<span class="line-modified">1948                     UTRIE2_U8_NEXT16(normTrie, nextSrc, limit, n16);</span>
1949                     if (n16 &gt;= MIN_YES_YES_WITH_CC) {
1950                         cc = getCCFromNormalYesOrMaybe(n16);
1951                         if (prevCC &gt; cc) {
1952                             if (sink == nullptr) {
1953                                 return FALSE;
1954                             }
1955                             break;
1956                         }
1957                     } else {
1958                         break;
1959                     }
1960                     src = nextSrc;
1961                 }
1962                 // src is after the last in-order combining mark.
1963                 // If there is a boundary here, then we continue with no change.
1964                 if (norm16HasCompBoundaryBefore(n16)) {
1965                     if (isCompYesAndZeroCC(n16)) {
1966                         src = nextSrc;
1967                     }
1968                     continue;
1969                 }
1970                 // Use the slow path. There is no boundary in [prevSrc, src[.
1971             }
1972         }
1973 
1974         // Slow path: Find the nearest boundaries around the current character,
1975         // decompose and recompose.
1976         if (prevBoundary != prevSrc &amp;&amp; !norm16HasCompBoundaryBefore(norm16)) {
1977             const uint8_t *p = prevSrc;
<span class="line-modified">1978             UTRIE2_U8_PREV16(normTrie, prevBoundary, p, norm16);</span>
1979             if (!norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
1980                 prevSrc = p;
1981             }
1982         }
1983         ReorderingBuffer buffer(*this, s16, errorCode);
1984         if (U_FAILURE(errorCode)) {
1985             break;
1986         }
1987         // We know there is not a boundary here.
1988         decomposeShort(prevSrc, src, FALSE /* !stopAtCompBoundary */, onlyContiguous,
1989                        buffer, errorCode);
1990         // Decompose until the next boundary.
1991         src = decomposeShort(src, limit, TRUE /* stopAtCompBoundary */, onlyContiguous,
1992                              buffer, errorCode);
1993         if (U_FAILURE(errorCode)) {
1994             break;
1995         }
1996         if ((src - prevSrc) &gt; INT32_MAX) {  // guard before buffer.equals()
1997             errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
1998             return TRUE;
</pre>
<hr />
<pre>
2006                     !ByteSinkUtil::appendUnchanged(prevBoundary, prevSrc,
2007                                                    *sink, options, edits, errorCode)) {
2008                 break;
2009             }
2010             if (!ByteSinkUtil::appendChange(prevSrc, src, buffer.getStart(), buffer.length(),
2011                                             *sink, edits, errorCode)) {
2012                 break;
2013             }
2014             prevBoundary = src;
2015         }
2016     }
2017     return TRUE;
2018 }
2019 
2020 UBool Normalizer2Impl::hasCompBoundaryBefore(const UChar *src, const UChar *limit) const {
2021     if (src == limit || *src &lt; minCompNoMaybeCP) {
2022         return TRUE;
2023     }
2024     UChar32 c;
2025     uint16_t norm16;
<span class="line-modified">2026     UTRIE2_U16_NEXT16(normTrie, src, limit, c, norm16);</span>
2027     return norm16HasCompBoundaryBefore(norm16);
2028 }
2029 
2030 UBool Normalizer2Impl::hasCompBoundaryBefore(const uint8_t *src, const uint8_t *limit) const {
2031     if (src == limit) {
2032         return TRUE;
2033     }
2034     uint16_t norm16;
<span class="line-modified">2035     UTRIE2_U8_NEXT16(normTrie, src, limit, norm16);</span>
2036     return norm16HasCompBoundaryBefore(norm16);
2037 }
2038 
2039 UBool Normalizer2Impl::hasCompBoundaryAfter(const UChar *start, const UChar *p,
2040                                             UBool onlyContiguous) const {
2041     if (start == p) {
2042         return TRUE;
2043     }
2044     UChar32 c;
2045     uint16_t norm16;
<span class="line-modified">2046     UTRIE2_U16_PREV16(normTrie, start, p, c, norm16);</span>
2047     return norm16HasCompBoundaryAfter(norm16, onlyContiguous);
2048 }
2049 
2050 UBool Normalizer2Impl::hasCompBoundaryAfter(const uint8_t *start, const uint8_t *p,
2051                                             UBool onlyContiguous) const {
2052     if (start == p) {
2053         return TRUE;
2054     }
2055     uint16_t norm16;
<span class="line-modified">2056     UTRIE2_U8_PREV16(normTrie, start, p, norm16);</span>
2057     return norm16HasCompBoundaryAfter(norm16, onlyContiguous);
2058 }
2059 
2060 const UChar *Normalizer2Impl::findPreviousCompBoundary(const UChar *start, const UChar *p,
2061                                                        UBool onlyContiguous) const {
<span class="line-modified">2062     BackwardUTrie2StringIterator iter(normTrie, start, p);</span>
<span class="line-modified">2063     for(;;) {</span>
<span class="line-modified">2064         uint16_t norm16=iter.previous16();</span>


2065         if (norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
<span class="line-modified">2066             return iter.codePointLimit;</span>
2067         }
<span class="line-modified">2068         if (hasCompBoundaryBefore(iter.codePoint, norm16)) {</span>
<span class="line-modified">2069             return iter.codePointStart;</span>
2070         }
2071     }

2072 }
2073 
2074 const UChar *Normalizer2Impl::findNextCompBoundary(const UChar *p, const UChar *limit,
2075                                                    UBool onlyContiguous) const {
<span class="line-modified">2076     ForwardUTrie2StringIterator iter(normTrie, p, limit);</span>
<span class="line-modified">2077     for(;;) {</span>
<span class="line-modified">2078         uint16_t norm16=iter.next16();</span>
<span class="line-modified">2079         if (hasCompBoundaryBefore(iter.codePoint, norm16)) {</span>
<span class="line-modified">2080             return iter.codePointStart;</span>


2081         }
2082         if (norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
<span class="line-modified">2083             return iter.codePointLimit;</span>
2084         }
2085     }

2086 }
2087 
2088 uint8_t Normalizer2Impl::getPreviousTrailCC(const UChar *start, const UChar *p) const {
2089     if (start == p) {
2090         return 0;
2091     }
2092     int32_t i = (int32_t)(p - start);
2093     UChar32 c;
2094     U16_PREV(start, 0, i, c);
2095     return (uint8_t)getFCD16(c);
2096 }
2097 
2098 uint8_t Normalizer2Impl::getPreviousTrailCC(const uint8_t *start, const uint8_t *p) const {
2099     if (start == p) {
2100         return 0;
2101     }
2102     int32_t i = (int32_t)(p - start);
2103     UChar32 c;
2104     U8_PREV(start, 0, i, c);
2105     return (uint8_t)getFCD16(c);
</pre>
<hr />
<pre>
2113 // minDecompNoCP etc. and smallFCD[] are intended to help with any loss of performance,
2114 // at least for ASCII &amp; CJK.
2115 
2116 // Gets the FCD value from the regular normalization data.
2117 uint16_t Normalizer2Impl::getFCD16FromNormData(UChar32 c) const {
2118     uint16_t norm16=getNorm16(c);
2119     if (norm16 &gt;= limitNoNo) {
2120         if(norm16&gt;=MIN_NORMAL_MAYBE_YES) {
2121             // combining mark
2122             norm16=getCCFromNormalYesOrMaybe(norm16);
2123             return norm16|(norm16&lt;&lt;8);
2124         } else if(norm16&gt;=minMaybeYes) {
2125             return 0;
2126         } else {  // isDecompNoAlgorithmic(norm16)
2127             uint16_t deltaTrailCC = norm16 &amp; DELTA_TCCC_MASK;
2128             if (deltaTrailCC &lt;= DELTA_TCCC_1) {
2129                 return deltaTrailCC &gt;&gt; OFFSET_SHIFT;
2130             }
2131             // Maps to an isCompYesAndZeroCC.
2132             c=mapAlgorithmic(c, norm16);
<span class="line-modified">2133             norm16=getNorm16(c);</span>
2134         }
2135     }
2136     if(norm16&lt;=minYesNo || isHangulLVT(norm16)) {
2137         // no decomposition or Hangul syllable, all zeros
2138         return 0;
2139     }
2140     // c decomposes, get everything from the variable-length extra data
2141     const uint16_t *mapping=getMapping(norm16);
2142     uint16_t firstUnit=*mapping;
2143     norm16=firstUnit&gt;&gt;8;  // tccc
2144     if(firstUnit&amp;MAPPING_HAS_CCC_LCCC_WORD) {
2145         norm16|=*(mapping-1)&amp;0xff00;  // lccc
2146     }
2147     return norm16;
2148 }
2149 
2150 // Dual functionality:
2151 // buffer!=NULL: normalize
2152 // buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes
2153 const UChar *
</pre>
<hr />
<pre>
2178     // Note: In this function we use buffer-&gt;appendZeroCC() because we track
2179     // the lead and trail combining classes here, rather than leaving it to
2180     // the ReorderingBuffer.
2181     // The exception is the call to decomposeShort() which uses the buffer
2182     // in the normal way.
2183 
2184     const UChar *prevSrc;
2185     UChar32 c=0;
2186     uint16_t fcd16=0;
2187 
2188     for(;;) {
2189         // count code units with lccc==0
2190         for(prevSrc=src; src!=limit;) {
2191             if((c=*src)&lt;minLcccCP) {
2192                 prevFCD16=~c;
2193                 ++src;
2194             } else if(!singleLeadMightHaveNonZeroFCD16(c)) {
2195                 prevFCD16=0;
2196                 ++src;
2197             } else {
<span class="line-modified">2198                 if(U16_IS_SURROGATE(c)) {</span>
2199                     UChar c2;
<span class="line-modified">2200                     if(U16_IS_SURROGATE_LEAD(c)) {</span>
<span class="line-modified">2201                         if((src+1)!=limit &amp;&amp; U16_IS_TRAIL(c2=src[1])) {</span>
<span class="line-removed">2202                             c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-removed">2203                         }</span>
<span class="line-removed">2204                     } else /* trail surrogate */ {</span>
<span class="line-removed">2205                         if(prevSrc&lt;src &amp;&amp; U16_IS_LEAD(c2=*(src-1))) {</span>
<span class="line-removed">2206                             --src;</span>
<span class="line-removed">2207                             c=U16_GET_SUPPLEMENTARY(c2, c);</span>
<span class="line-removed">2208                         }</span>
2209                     }
2210                 }
2211                 if((fcd16=getFCD16FromNormData(c))&lt;=0xff) {
2212                     prevFCD16=fcd16;
2213                     src+=U16_LENGTH(c);
2214                 } else {
2215                     break;
2216                 }
2217             }
2218         }
2219         // copy these code units all at once
2220         if(src!=prevSrc) {
2221             if(buffer!=NULL &amp;&amp; !buffer-&gt;appendZeroCC(prevSrc, src, errorCode)) {
2222                 break;
2223             }
2224             if(src==limit) {
2225                 break;
2226             }
2227             prevBoundary=src;
2228             // We know that the previous character&#39;s lccc==0.
</pre>
<hr />
<pre>
2319                 return;
2320             }
2321             src=firstBoundaryInSrc;
2322         }
2323     }
2324     if(doMakeFCD) {
2325         makeFCD(src, limit, &amp;buffer, errorCode);
2326     } else {
2327         if(limit==NULL) {  // appendZeroCC() needs limit!=NULL
2328             limit=u_strchr(src, 0);
2329         }
2330         buffer.appendZeroCC(src, limit, errorCode);
2331     }
2332 }
2333 
2334 const UChar *Normalizer2Impl::findPreviousFCDBoundary(const UChar *start, const UChar *p) const {
2335     while(start&lt;p) {
2336         const UChar *codePointLimit = p;
2337         UChar32 c;
2338         uint16_t norm16;
<span class="line-modified">2339         UTRIE2_U16_PREV16(normTrie, start, p, c, norm16);</span>
2340         if (c &lt; minDecompNoCP || norm16HasDecompBoundaryAfter(norm16)) {
2341             return codePointLimit;
2342         }
2343         if (norm16HasDecompBoundaryBefore(norm16)) {
2344             return p;
2345         }
2346     }
2347     return p;
2348 }
2349 
2350 const UChar *Normalizer2Impl::findNextFCDBoundary(const UChar *p, const UChar *limit) const {
2351     while(p&lt;limit) {
2352         const UChar *codePointStart=p;
2353         UChar32 c;
2354         uint16_t norm16;
<span class="line-modified">2355         UTRIE2_U16_NEXT16(normTrie, p, limit, c, norm16);</span>
2356         if (c &lt; minLcccCP || norm16HasDecompBoundaryBefore(norm16)) {
2357             return codePointStart;
2358         }
2359         if (norm16HasDecompBoundaryAfter(norm16)) {
2360             return p;
2361         }
2362     }
2363     return p;
2364 }
2365 
2366 // CanonicalIterator data -------------------------------------------------- ***
2367 
2368 CanonIterData::CanonIterData(UErrorCode &amp;errorCode) :
<span class="line-modified">2369         trie(utrie2_open(0, 0, &amp;errorCode)),</span>
2370         canonStartSets(uprv_deleteUObject, NULL, errorCode) {}
2371 
2372 CanonIterData::~CanonIterData() {
<span class="line-modified">2373     utrie2_close(trie);</span>

2374 }
2375 
2376 void CanonIterData::addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode &amp;errorCode) {
<span class="line-modified">2377     uint32_t canonValue=utrie2_get32(trie, decompLead);</span>
2378     if((canonValue&amp;(CANON_HAS_SET|CANON_VALUE_MASK))==0 &amp;&amp; origin!=0) {
2379         // origin is the first character whose decomposition starts with
2380         // the character for which we are setting the value.
<span class="line-modified">2381         utrie2_set32(trie, decompLead, canonValue|origin, &amp;errorCode);</span>
2382     } else {
2383         // origin is not the first character, or it is U+0000.
2384         UnicodeSet *set;
2385         if((canonValue&amp;CANON_HAS_SET)==0) {
2386             set=new UnicodeSet;
2387             if(set==NULL) {
2388                 errorCode=U_MEMORY_ALLOCATION_ERROR;
2389                 return;
2390             }
2391             UChar32 firstOrigin=(UChar32)(canonValue&amp;CANON_VALUE_MASK);
2392             canonValue=(canonValue&amp;~CANON_VALUE_MASK)|CANON_HAS_SET|(uint32_t)canonStartSets.size();
<span class="line-modified">2393             utrie2_set32(trie, decompLead, canonValue, &amp;errorCode);</span>
2394             canonStartSets.addElement(set, errorCode);
2395             if(firstOrigin!=0) {
2396                 set-&gt;add(firstOrigin);
2397             }
2398         } else {
2399             set=(UnicodeSet *)canonStartSets[(int32_t)(canonValue&amp;CANON_VALUE_MASK)];
2400         }
2401         set-&gt;add(origin);
2402     }
2403 }
2404 
2405 // C++ class for friend access to private Normalizer2Impl members.
2406 class InitCanonIterData {
2407 public:
2408     static void doInit(Normalizer2Impl *impl, UErrorCode &amp;errorCode);
<span class="line-removed">2409     static void handleRange(Normalizer2Impl *impl, UChar32 start, UChar32 end, uint16_t value, UErrorCode &amp;errorCode);</span>
2410 };
2411 
2412 U_CDECL_BEGIN
2413 
2414 // UInitOnce instantiation function for CanonIterData
2415 static void U_CALLCONV
2416 initCanonIterData(Normalizer2Impl *impl, UErrorCode &amp;errorCode) {
2417     InitCanonIterData::doInit(impl, errorCode);
2418 }
2419 
<span class="line-removed">2420 // Call Normalizer2Impl::makeCanonIterDataFromNorm16() for a range of same-norm16 characters.</span>
<span class="line-removed">2421 //     context: the Normalizer2Impl</span>
<span class="line-removed">2422 static UBool U_CALLCONV</span>
<span class="line-removed">2423 enumCIDRangeHandler(const void *context, UChar32 start, UChar32 end, uint32_t value) {</span>
<span class="line-removed">2424     UErrorCode errorCode = U_ZERO_ERROR;</span>
<span class="line-removed">2425     if (value != Normalizer2Impl::INERT) {</span>
<span class="line-removed">2426         Normalizer2Impl *impl = (Normalizer2Impl *)context;</span>
<span class="line-removed">2427         InitCanonIterData::handleRange(impl, start, end, (uint16_t)value, errorCode);</span>
<span class="line-removed">2428     }</span>
<span class="line-removed">2429     return U_SUCCESS(errorCode);</span>
<span class="line-removed">2430 }</span>
<span class="line-removed">2431 </span>
2432 U_CDECL_END
2433 
2434 void InitCanonIterData::doInit(Normalizer2Impl *impl, UErrorCode &amp;errorCode) {
2435     U_ASSERT(impl-&gt;fCanonIterData == NULL);
2436     impl-&gt;fCanonIterData = new CanonIterData(errorCode);
2437     if (impl-&gt;fCanonIterData == NULL) {
2438         errorCode=U_MEMORY_ALLOCATION_ERROR;
2439     }
2440     if (U_SUCCESS(errorCode)) {
<span class="line-modified">2441         utrie2_enum(impl-&gt;normTrie, NULL, enumCIDRangeHandler, impl);</span>
<span class="line-modified">2442         utrie2_freeze(impl-&gt;fCanonIterData-&gt;trie, UTRIE2_32_VALUE_BITS, &amp;errorCode);</span>
















2443     }
2444     if (U_FAILURE(errorCode)) {
2445         delete impl-&gt;fCanonIterData;
2446         impl-&gt;fCanonIterData = NULL;
2447     }
2448 }
2449 
<span class="line-removed">2450 void InitCanonIterData::handleRange(</span>
<span class="line-removed">2451         Normalizer2Impl *impl, UChar32 start, UChar32 end, uint16_t value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed">2452     impl-&gt;makeCanonIterDataFromNorm16(start, end, value, *impl-&gt;fCanonIterData, errorCode);</span>
<span class="line-removed">2453 }</span>
<span class="line-removed">2454 </span>
2455 void Normalizer2Impl::makeCanonIterDataFromNorm16(UChar32 start, UChar32 end, const uint16_t norm16,
2456                                                   CanonIterData &amp;newData,
2457                                                   UErrorCode &amp;errorCode) const {
2458     if(isInert(norm16) || (minYesNo&lt;=norm16 &amp;&amp; norm16&lt;minNoNo)) {
2459         // Inert, or 2-way mapping (including Hangul syllable).
2460         // We do not write a canonStartSet for any yesNo character.
2461         // Composites from 2-way mappings are added at runtime from the
2462         // starter&#39;s compositions list, and the other characters in
2463         // 2-way mappings get CANON_NOT_SEGMENT_STARTER set because they are
2464         // &quot;maybe&quot; characters.
2465         return;
2466     }
2467     for(UChar32 c=start; c&lt;=end; ++c) {
<span class="line-modified">2468         uint32_t oldValue=utrie2_get32(newData.trie, c);</span>
2469         uint32_t newValue=oldValue;
2470         if(isMaybeOrNonZeroCC(norm16)) {
2471             // not a segment starter if it occurs in a decomposition or has cc!=0
2472             newValue|=CANON_NOT_SEGMENT_STARTER;
2473             if(norm16&lt;MIN_NORMAL_MAYBE_YES) {
2474                 newValue|=CANON_HAS_COMPOSITIONS;
2475             }
2476         } else if(norm16&lt;minYesNo) {
2477             newValue|=CANON_HAS_COMPOSITIONS;
2478         } else {
2479             // c has a one-way decomposition
2480             UChar32 c2=c;
2481             // Do not modify the whole-range norm16 value.
2482             uint16_t norm16_2=norm16;
2483             if (isDecompNoAlgorithmic(norm16_2)) {
2484                 // Maps to an isCompYesAndZeroCC.
2485                 c2 = mapAlgorithmic(c2, norm16_2);
<span class="line-modified">2486                 norm16_2 = getNorm16(c2);</span>
2487                 // No compatibility mappings for the CanonicalIterator.
2488                 U_ASSERT(!(isHangulLV(norm16_2) || isHangulLVT(norm16_2)));
2489             }
2490             if (norm16_2 &gt; minYesNo) {
2491                 // c decomposes, get everything from the variable-length extra data
2492                 const uint16_t *mapping=getMapping(norm16_2);
2493                 uint16_t firstUnit=*mapping;
2494                 int32_t length=firstUnit&amp;MAPPING_LENGTH_MASK;
2495                 if((firstUnit&amp;MAPPING_HAS_CCC_LCCC_WORD)!=0) {
2496                     if(c==c2 &amp;&amp; (*(mapping-1)&amp;0xff)!=0) {
2497                         newValue|=CANON_NOT_SEGMENT_STARTER;  // original c has cc!=0
2498                     }
2499                 }
2500                 // Skip empty mappings (no characters in the decomposition).
2501                 if(length!=0) {
2502                     ++mapping;  // skip over the firstUnit
2503                     // add c to first code point&#39;s start set
2504                     int32_t i=0;
2505                     U16_NEXT_UNSAFE(mapping, i, c2);
2506                     newData.addToStartSet(c, c2, errorCode);
2507                     // Set CANON_NOT_SEGMENT_STARTER for each remaining code point of a
2508                     // one-way mapping. A 2-way mapping is possible here after
2509                     // intermediate algorithmic mapping.
2510                     if(norm16_2&gt;=minNoNo) {
2511                         while(i&lt;length) {
2512                             U16_NEXT_UNSAFE(mapping, i, c2);
<span class="line-modified">2513                             uint32_t c2Value=utrie2_get32(newData.trie, c2);</span>
2514                             if((c2Value&amp;CANON_NOT_SEGMENT_STARTER)==0) {
<span class="line-modified">2515                                 utrie2_set32(newData.trie, c2, c2Value|CANON_NOT_SEGMENT_STARTER,</span>
<span class="line-modified">2516                                              &amp;errorCode);</span>
2517                             }
2518                         }
2519                     }
2520                 }
2521             } else {
2522                 // c decomposed to c2 algorithmically; c has cc==0
2523                 newData.addToStartSet(c, c2, errorCode);
2524             }
2525         }
2526         if(newValue!=oldValue) {
<span class="line-modified">2527             utrie2_set32(newData.trie, c, newValue, &amp;errorCode);</span>
2528         }
2529     }
2530 }
2531 
2532 UBool Normalizer2Impl::ensureCanonIterData(UErrorCode &amp;errorCode) const {
2533     // Logically const: Synchronized instantiation.
2534     Normalizer2Impl *me=const_cast&lt;Normalizer2Impl *&gt;(this);
2535     umtx_initOnce(me-&gt;fCanonIterDataInitOnce, &amp;initCanonIterData, me, errorCode);
2536     return U_SUCCESS(errorCode);
2537 }
2538 
2539 int32_t Normalizer2Impl::getCanonValue(UChar32 c) const {
<span class="line-modified">2540     return (int32_t)utrie2_get32(fCanonIterData-&gt;trie, c);</span>
2541 }
2542 
2543 const UnicodeSet &amp;Normalizer2Impl::getCanonStartSet(int32_t n) const {
2544     return *(const UnicodeSet *)fCanonIterData-&gt;canonStartSets[n];
2545 }
2546 
2547 UBool Normalizer2Impl::isCanonSegmentStarter(UChar32 c) const {
2548     return getCanonValue(c)&gt;=0;
2549 }
2550 
2551 UBool Normalizer2Impl::getCanonStartSet(UChar32 c, UnicodeSet &amp;set) const {
2552     int32_t canonValue=getCanonValue(c)&amp;~CANON_NOT_SEGMENT_STARTER;
2553     if(canonValue==0) {
2554         return FALSE;
2555     }
2556     set.clear();
2557     int32_t value=canonValue&amp;CANON_VALUE_MASK;
2558     if((canonValue&amp;CANON_HAS_SET)!=0) {
2559         set.addAll(getCanonStartSet(value));
2560     } else if(value!=0) {
2561         set.add(value);
2562     }
2563     if((canonValue&amp;CANON_HAS_COMPOSITIONS)!=0) {
<span class="line-modified">2564         uint16_t norm16=getNorm16(c);</span>
2565         if(norm16==JAMO_L) {
2566             UChar32 syllable=
2567                 (UChar32)(Hangul::HANGUL_BASE+(c-Hangul::JAMO_L_BASE)*Hangul::JAMO_VT_COUNT);
2568             set.add(syllable, syllable+Hangul::JAMO_VT_COUNT-1);
2569         } else {
2570             addComposites(getCompositionsList(norm16), set);
2571         }
2572     }
2573     return TRUE;
2574 }
2575 
2576 U_NAMESPACE_END
2577 
2578 // Normalizer2 data swapping ----------------------------------------------- ***
2579 
2580 U_NAMESPACE_USE
2581 
2582 U_CAPI int32_t U_EXPORT2
2583 unorm2_swap(const UDataSwapper *ds,
2584             const void *inData, int32_t length, void *outData,
</pre>
<hr />
<pre>
2591 
2592     const int32_t *inIndexes;
2593     int32_t indexes[Normalizer2Impl::IX_TOTAL_SIZE+1];
2594 
2595     int32_t i, offset, nextOffset, size;
2596 
2597     /* udata_swapDataHeader checks the arguments */
2598     headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
2599     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
2600         return 0;
2601     }
2602 
2603     /* check data format and format version */
2604     pInfo=(const UDataInfo *)((const char *)inData+4);
2605     uint8_t formatVersion0=pInfo-&gt;formatVersion[0];
2606     if(!(
2607         pInfo-&gt;dataFormat[0]==0x4e &amp;&amp;   /* dataFormat=&quot;Nrm2&quot; */
2608         pInfo-&gt;dataFormat[1]==0x72 &amp;&amp;
2609         pInfo-&gt;dataFormat[2]==0x6d &amp;&amp;
2610         pInfo-&gt;dataFormat[3]==0x32 &amp;&amp;
<span class="line-modified">2611         (1&lt;=formatVersion0 &amp;&amp; formatVersion0&lt;=3)</span>
2612     )) {
2613         udata_printError(ds, &quot;unorm2_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as Normalizer2 data\n&quot;,
2614                          pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
2615                          pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
2616                          pInfo-&gt;formatVersion[0]);
2617         *pErrorCode=U_UNSUPPORTED_ERROR;
2618         return 0;
2619     }
2620 
2621     inBytes=(const uint8_t *)inData+headerSize;
2622     outBytes=(uint8_t *)outData+headerSize;
2623 
2624     inIndexes=(const int32_t *)inBytes;
2625     int32_t minIndexesLength;
2626     if(formatVersion0==1) {
2627         minIndexesLength=Normalizer2Impl::IX_MIN_MAYBE_YES+1;
2628     } else if(formatVersion0==2) {
2629         minIndexesLength=Normalizer2Impl::IX_MIN_YES_NO_MAPPINGS_ONLY+1;
2630     } else {
2631         minIndexesLength=Normalizer2Impl::IX_MIN_LCCC_CP+1;
</pre>
<hr />
<pre>
2652     if(length&gt;=0) {
2653         if(length&lt;size) {
2654             udata_printError(ds, &quot;unorm2_swap(): too few bytes (%d after header) for all of Normalizer2 data\n&quot;,
2655                              length);
2656             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
2657             return 0;
2658         }
2659 
2660         /* copy the data for inaccessible bytes */
2661         if(inBytes!=outBytes) {
2662             uprv_memcpy(outBytes, inBytes, size);
2663         }
2664 
2665         offset=0;
2666 
2667         /* swap the int32_t indexes[] */
2668         nextOffset=indexes[Normalizer2Impl::IX_NORM_TRIE_OFFSET];
2669         ds-&gt;swapArray32(ds, inBytes, nextOffset-offset, outBytes, pErrorCode);
2670         offset=nextOffset;
2671 
<span class="line-modified">2672         /* swap the UTrie2 */</span>
2673         nextOffset=indexes[Normalizer2Impl::IX_EXTRA_DATA_OFFSET];
<span class="line-modified">2674         utrie2_swap(ds, inBytes+offset, nextOffset-offset, outBytes+offset, pErrorCode);</span>
2675         offset=nextOffset;
2676 
2677         /* swap the uint16_t extraData[] */
2678         nextOffset=indexes[Normalizer2Impl::IX_SMALL_FCD_OFFSET];
2679         ds-&gt;swapArray16(ds, inBytes+offset, nextOffset-offset, outBytes+offset, pErrorCode);
2680         offset=nextOffset;
2681 
2682         /* no need to swap the uint8_t smallFCD[] (new in formatVersion 2) */
2683         nextOffset=indexes[Normalizer2Impl::IX_SMALL_FCD_OFFSET+1];
2684         offset=nextOffset;
2685 
2686         U_ASSERT(offset==size);
2687     }
2688 
2689     return headerSize+size;
2690 }
2691 
2692 #endif  // !UCONFIG_NO_NORMALIZATION
</pre>
</td>
<td>
<hr />
<pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 *
   6 *   Copyright (C) 2009-2014, International Business Machines
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 *******************************************************************************
  10 *   file name:  normalizer2impl.cpp
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 2009nov22
  16 *   created by: Markus W. Scherer
  17 */
  18 
<span class="line-added">  19 // #define UCPTRIE_DEBUG</span>
<span class="line-added">  20 </span>
  21 #include &quot;unicode/utypes.h&quot;
  22 
  23 #if !UCONFIG_NO_NORMALIZATION
  24 
  25 #include &quot;unicode/bytestream.h&quot;
  26 #include &quot;unicode/edits.h&quot;
  27 #include &quot;unicode/normalizer2.h&quot;
  28 #include &quot;unicode/stringoptions.h&quot;
<span class="line-added">  29 #include &quot;unicode/ucptrie.h&quot;</span>
  30 #include &quot;unicode/udata.h&quot;
<span class="line-added">  31 #include &quot;unicode/umutablecptrie.h&quot;</span>
  32 #include &quot;unicode/ustring.h&quot;
  33 #include &quot;unicode/utf16.h&quot;
  34 #include &quot;unicode/utf8.h&quot;
  35 #include &quot;bytesinkutil.h&quot;
  36 #include &quot;cmemory.h&quot;
  37 #include &quot;mutex.h&quot;
  38 #include &quot;normalizer2impl.h&quot;
  39 #include &quot;putilimp.h&quot;
  40 #include &quot;uassert.h&quot;
<span class="line-added">  41 #include &quot;ucptrie_impl.h&quot;</span>
  42 #include &quot;uset_imp.h&quot;

  43 #include &quot;uvector.h&quot;
  44 
  45 U_NAMESPACE_BEGIN
  46 
  47 namespace {
  48 
  49 /**
  50  * UTF-8 lead byte for minNoMaybeCP.
  51  * Can be lower than the actual lead byte for c.
  52  * Typically U+0300 for NFC/NFD, U+00A0 for NFKC/NFKD, U+0041 for NFKC_Casefold.
  53  */
  54 inline uint8_t leadByteForCP(UChar32 c) {
  55     if (c &lt;= 0x7f) {
  56         return (uint8_t)c;
  57     } else if (c &lt;= 0x7ff) {
  58         return (uint8_t)(0xc0+(c&gt;&gt;6));
  59     } else {
  60         // Should not occur because ccc(U+0300)!=0.
  61         return 0xe0;
  62     }
  63 }
  64 
  65 /**
  66  * Returns the code point from one single well-formed UTF-8 byte sequence
  67  * between cpStart and cpLimit.
  68  *
<span class="line-modified">  69  * Trie UTF-8 macros do not assemble whole code points (for efficiency).</span>
  70  * When we do need the code point, we call this function.
  71  * We should not need it for normalization-inert data (norm16==0).
  72  * Illegal sequences yield the error value norm16==0 just like real normalization-inert code points.
  73  */
  74 UChar32 codePointFromValidUTF8(const uint8_t *cpStart, const uint8_t *cpLimit) {
  75     // Similar to U8_NEXT_UNSAFE(s, i, c).
  76     U_ASSERT(cpStart &lt; cpLimit);
  77     uint8_t c = *cpStart;
  78     switch(cpLimit-cpStart) {
  79     case 1:
  80         return c;
  81     case 2:
  82         return ((c&amp;0x1f)&lt;&lt;6) | (cpStart[1]&amp;0x3f);
  83     case 3:
  84         // no need for (c&amp;0xf) because the upper bits are truncated after &lt;&lt;12 in the cast to (UChar)
  85         return (UChar)((c&lt;&lt;12) | ((cpStart[1]&amp;0x3f)&lt;&lt;6) | (cpStart[2]&amp;0x3f));
  86     case 4:
  87         return ((c&amp;7)&lt;&lt;18) | ((cpStart[1]&amp;0x3f)&lt;&lt;12) | ((cpStart[2]&amp;0x3f)&lt;&lt;6) | (cpStart[3]&amp;0x3f);
  88     default:
<span class="line-modified">  89         UPRV_UNREACHABLE;  // Should not occur.</span>

  90     }
  91 }
  92 
  93 /**
  94  * Returns the last code point in [start, p[ if it is valid and in U+1000..U+D7FF.
  95  * Otherwise returns a negative value.
  96  */
  97 UChar32 previousHangulOrJamo(const uint8_t *start, const uint8_t *p) {
  98     if ((p - start) &gt;= 3) {
  99         p -= 3;
 100         uint8_t l = *p;
 101         uint8_t t1, t2;
 102         if (0xe1 &lt;= l &amp;&amp; l &lt;= 0xed &amp;&amp;
 103                 (t1 = (uint8_t)(p[1] - 0x80)) &lt;= 0x3f &amp;&amp;
 104                 (t2 = (uint8_t)(p[2] - 0x80)) &lt;= 0x3f &amp;&amp;
 105                 (l &lt; 0xed || t1 &lt;= 0x1f)) {
 106             return ((l &amp; 0xf) &lt;&lt; 12) | (t1 &lt;&lt; 6) | t2;
 107         }
 108     }
 109     return U_SENTINEL;
 110 }
 111 
 112 /**
 113  * Returns the offset from the Jamo T base if [src, limit[ starts with a single Jamo T code point.
 114  * Otherwise returns a negative value.
 115  */
 116 int32_t getJamoTMinusBase(const uint8_t *src, const uint8_t *limit) {
 117     // Jamo T: E1 86 A8..E1 87 82
 118     if ((limit - src) &gt;= 3 &amp;&amp; *src == 0xe1) {
 119         if (src[1] == 0x86) {
 120             uint8_t t = src[2];
 121             // The first Jamo T is U+11A8 but JAMO_T_BASE is 11A7.
 122             // Offset 0 does not correspond to any conjoining Jamo.
 123             if (0xa8 &lt;= t &amp;&amp; t &lt;= 0xbf) {
 124                 return t - 0xa7;
 125             }
 126         } else if (src[1] == 0x87) {
 127             uint8_t t = src[2];
<span class="line-modified"> 128             if ((int8_t)t &lt;= (int8_t)0x82u) {</span>
 129                 return t - (0xa7 - 0x40);
 130             }
 131         }
 132     }
 133     return -1;
 134 }
 135 
 136 void
 137 appendCodePointDelta(const uint8_t *cpStart, const uint8_t *cpLimit, int32_t delta,
 138                      ByteSink &amp;sink, Edits *edits) {
 139     char buffer[U8_MAX_LENGTH];
 140     int32_t length;
 141     int32_t cpLength = (int32_t)(cpLimit - cpStart);
 142     if (cpLength == 1) {
 143         // The builder makes ASCII map to ASCII.
 144         buffer[0] = (uint8_t)(*cpStart + delta);
 145         length = 1;
 146     } else {
 147         int32_t trail = *(cpLimit-1) + delta;
 148         if (0x80 &lt;= trail &amp;&amp; trail &lt;= 0xbf) {
</pre>
<hr />
<pre>
 239 
 240 UBool ReorderingBuffer::appendSupplementary(UChar32 c, uint8_t cc, UErrorCode &amp;errorCode) {
 241     if(remainingCapacity&lt;2 &amp;&amp; !resize(2, errorCode)) {
 242         return FALSE;
 243     }
 244     if(lastCC&lt;=cc || cc==0) {
 245         limit[0]=U16_LEAD(c);
 246         limit[1]=U16_TRAIL(c);
 247         limit+=2;
 248         lastCC=cc;
 249         if(cc&lt;=1) {
 250             reorderStart=limit;
 251         }
 252     } else {
 253         insert(c, cc);
 254     }
 255     remainingCapacity-=2;
 256     return TRUE;
 257 }
 258 
<span class="line-modified"> 259 UBool ReorderingBuffer::append(const UChar *s, int32_t length, UBool isNFD,</span>
 260                                uint8_t leadCC, uint8_t trailCC,
 261                                UErrorCode &amp;errorCode) {
 262     if(length==0) {
 263         return TRUE;
 264     }
 265     if(remainingCapacity&lt;length &amp;&amp; !resize(length, errorCode)) {
 266         return FALSE;
 267     }
 268     remainingCapacity-=length;
 269     if(lastCC&lt;=leadCC || leadCC==0) {
 270         if(trailCC&lt;=1) {
 271             reorderStart=limit+length;
 272         } else if(leadCC&lt;=1) {
 273             reorderStart=limit+1;  // Ok if not a code point boundary.
 274         }
 275         const UChar *sLimit=s+length;
 276         do { *limit++=*s++; } while(s!=sLimit);
 277         lastCC=trailCC;
 278     } else {
 279         int32_t i=0;
 280         UChar32 c;
 281         U16_NEXT(s, i, length, c);
 282         insert(c, leadCC);  // insert first code point
 283         while(i&lt;length) {
 284             U16_NEXT(s, i, length, c);
 285             if(i&lt;length) {
<span class="line-modified"> 286                 if (isNFD) {</span>
<span class="line-modified"> 287                     leadCC = Normalizer2Impl::getCCFromYesOrMaybe(impl.getRawNorm16(c));</span>
<span class="line-added"> 288                 } else {</span>
<span class="line-added"> 289                     leadCC = impl.getCC(impl.getNorm16(c));</span>
<span class="line-added"> 290                 }</span>
 291             } else {
 292                 leadCC=trailCC;
 293             }
 294             append(c, leadCC, errorCode);
 295         }
 296     }
 297     return TRUE;
 298 }
 299 
 300 UBool ReorderingBuffer::appendZeroCC(UChar32 c, UErrorCode &amp;errorCode) {
 301     int32_t cpLength=U16_LENGTH(c);
 302     if(remainingCapacity&lt;cpLength &amp;&amp; !resize(cpLength, errorCode)) {
 303         return FALSE;
 304     }
 305     remainingCapacity-=cpLength;
 306     if(cpLength==1) {
 307         *limit++=(UChar)c;
 308     } else {
 309         limit[0]=U16_LEAD(c);
 310         limit[1]=U16_TRAIL(c);
</pre>
<hr />
<pre>
 400 void ReorderingBuffer::insert(UChar32 c, uint8_t cc) {
 401     for(setIterator(), skipPrevious(); previousCC()&gt;cc;) {}
 402     // insert c at codePointLimit, after the character with prevCC&lt;=cc
 403     UChar *q=limit;
 404     UChar *r=limit+=U16_LENGTH(c);
 405     do {
 406         *--r=*--q;
 407     } while(codePointLimit!=q);
 408     writeCodePoint(q, c);
 409     if(cc&lt;=1) {
 410         reorderStart=r;
 411     }
 412 }
 413 
 414 // Normalizer2Impl --------------------------------------------------------- ***
 415 
 416 struct CanonIterData : public UMemory {
 417     CanonIterData(UErrorCode &amp;errorCode);
 418     ~CanonIterData();
 419     void addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode &amp;errorCode);
<span class="line-modified"> 420     UMutableCPTrie *mutableTrie;</span>
<span class="line-added"> 421     UCPTrie *trie;</span>
 422     UVector canonStartSets;  // contains UnicodeSet *
 423 };
 424 
 425 Normalizer2Impl::~Normalizer2Impl() {
 426     delete fCanonIterData;
 427 }
 428 
 429 void
<span class="line-modified"> 430 Normalizer2Impl::init(const int32_t *inIndexes, const UCPTrie *inTrie,</span>
 431                       const uint16_t *inExtraData, const uint8_t *inSmallFCD) {
<span class="line-modified"> 432     minDecompNoCP = static_cast&lt;UChar&gt;(inIndexes[IX_MIN_DECOMP_NO_CP]);</span>
<span class="line-modified"> 433     minCompNoMaybeCP = static_cast&lt;UChar&gt;(inIndexes[IX_MIN_COMP_NO_MAYBE_CP]);</span>
<span class="line-modified"> 434     minLcccCP = static_cast&lt;UChar&gt;(inIndexes[IX_MIN_LCCC_CP]);</span>
<span class="line-modified"> 435 </span>
<span class="line-modified"> 436     minYesNo = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_YES_NO]);</span>
<span class="line-modified"> 437     minYesNoMappingsOnly = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_YES_NO_MAPPINGS_ONLY]);</span>
<span class="line-modified"> 438     minNoNo = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_NO_NO]);</span>
<span class="line-modified"> 439     minNoNoCompBoundaryBefore = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE]);</span>
<span class="line-modified"> 440     minNoNoCompNoMaybeCC = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_NO_NO_COMP_NO_MAYBE_CC]);</span>
<span class="line-modified"> 441     minNoNoEmpty = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_NO_NO_EMPTY]);</span>
<span class="line-modified"> 442     limitNoNo = static_cast&lt;uint16_t&gt;(inIndexes[IX_LIMIT_NO_NO]);</span>
<span class="line-modified"> 443     minMaybeYes = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_MAYBE_YES]);</span>
<span class="line-modified"> 444     U_ASSERT((minMaybeYes &amp; 7) == 0);  // 8-aligned for noNoDelta bit fields</span>
<span class="line-modified"> 445     centerNoNoDelta = (minMaybeYes &gt;&gt; DELTA_SHIFT) - MAX_DELTA - 1;</span>
 446 
 447     normTrie=inTrie;
 448 
 449     maybeYesCompositions=inExtraData;
 450     extraData=maybeYesCompositions+((MIN_NORMAL_MAYBE_YES-minMaybeYes)&gt;&gt;OFFSET_SHIFT);
 451 
 452     smallFCD=inSmallFCD;
 453 }
 454 































 455 U_CDECL_BEGIN
 456 




































 457 static uint32_t U_CALLCONV
 458 segmentStarterMapper(const void * /*context*/, uint32_t value) {
 459     return value&amp;CANON_NOT_SEGMENT_STARTER;
 460 }
 461 
 462 U_CDECL_END
 463 
 464 void
 465 Normalizer2Impl::addLcccChars(UnicodeSet &amp;set) const {
<span class="line-modified"> 466     UChar32 start = 0, end;</span>
<span class="line-modified"> 467     uint32_t norm16;</span>
<span class="line-added"> 468     while ((end = ucptrie_getRange(normTrie, start, UCPMAP_RANGE_FIXED_LEAD_SURROGATES, INERT,</span>
<span class="line-added"> 469                                    nullptr, nullptr, &amp;norm16)) &gt;= 0) {</span>
<span class="line-added"> 470         if (norm16 &gt; Normalizer2Impl::MIN_NORMAL_MAYBE_YES &amp;&amp;</span>
<span class="line-added"> 471                 norm16 != Normalizer2Impl::JAMO_VT) {</span>
<span class="line-added"> 472             set.add(start, end);</span>
<span class="line-added"> 473         } else if (minNoNoCompNoMaybeCC &lt;= norm16 &amp;&amp; norm16 &lt; limitNoNo) {</span>
<span class="line-added"> 474             uint16_t fcd16 = getFCD16(start);</span>
<span class="line-added"> 475             if (fcd16 &gt; 0xff) { set.add(start, end); }</span>
<span class="line-added"> 476         }</span>
<span class="line-added"> 477         start = end + 1;</span>
<span class="line-added"> 478     }</span>
 479 }
 480 
 481 void
 482 Normalizer2Impl::addPropertyStarts(const USetAdder *sa, UErrorCode &amp; /*errorCode*/) const {
<span class="line-modified"> 483     // Add the start code point of each same-value range of the trie.</span>
<span class="line-modified"> 484     UChar32 start = 0, end;</span>
<span class="line-modified"> 485     uint32_t value;</span>
<span class="line-added"> 486     while ((end = ucptrie_getRange(normTrie, start, UCPMAP_RANGE_FIXED_LEAD_SURROGATES, INERT,</span>
<span class="line-added"> 487                                    nullptr, nullptr, &amp;value)) &gt;= 0) {</span>
<span class="line-added"> 488         sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-added"> 489         if (start != end &amp;&amp; isAlgorithmicNoNo((uint16_t)value) &amp;&amp;</span>
<span class="line-added"> 490                 (value &amp; Normalizer2Impl::DELTA_TCCC_MASK) &gt; Normalizer2Impl::DELTA_TCCC_1) {</span>
<span class="line-added"> 491             // Range of code points with same-norm16-value algorithmic decompositions.</span>
<span class="line-added"> 492             // They might have different non-zero FCD16 values.</span>
<span class="line-added"> 493             uint16_t prevFCD16 = getFCD16(start);</span>
<span class="line-added"> 494             while (++start &lt;= end) {</span>
<span class="line-added"> 495                 uint16_t fcd16 = getFCD16(start);</span>
<span class="line-added"> 496                 if (fcd16 != prevFCD16) {</span>
<span class="line-added"> 497                     sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-added"> 498                     prevFCD16 = fcd16;</span>
<span class="line-added"> 499                 }</span>
<span class="line-added"> 500             }</span>
<span class="line-added"> 501         }</span>
<span class="line-added"> 502         start = end + 1;</span>
<span class="line-added"> 503     }</span>
 504 
 505     /* add Hangul LV syllables and LV+1 because of skippables */
 506     for(UChar c=Hangul::HANGUL_BASE; c&lt;Hangul::HANGUL_LIMIT; c+=Hangul::JAMO_T_COUNT) {
 507         sa-&gt;add(sa-&gt;set, c);
 508         sa-&gt;add(sa-&gt;set, c+1);
 509     }
 510     sa-&gt;add(sa-&gt;set, Hangul::HANGUL_LIMIT); /* add Hangul+1 to continue with other properties */
 511 }
 512 
 513 void
 514 Normalizer2Impl::addCanonIterPropertyStarts(const USetAdder *sa, UErrorCode &amp;errorCode) const {
<span class="line-modified"> 515     // Add the start code point of each same-value range of the canonical iterator data trie.</span>
<span class="line-modified"> 516     if (!ensureCanonIterData(errorCode)) { return; }</span>
<span class="line-modified"> 517     // Currently only used for the SEGMENT_STARTER property.</span>
<span class="line-modified"> 518     UChar32 start = 0, end;</span>
<span class="line-added"> 519     uint32_t value;</span>
<span class="line-added"> 520     while ((end = ucptrie_getRange(fCanonIterData-&gt;trie, start, UCPMAP_RANGE_NORMAL, 0,</span>
<span class="line-added"> 521                                    segmentStarterMapper, nullptr, &amp;value)) &gt;= 0) {</span>
<span class="line-added"> 522         sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-added"> 523         start = end + 1;</span>
 524     }
 525 }
 526 
 527 const UChar *
 528 Normalizer2Impl::copyLowPrefixFromNulTerminated(const UChar *src,
 529                                                 UChar32 minNeedDataCP,
 530                                                 ReorderingBuffer *buffer,
 531                                                 UErrorCode &amp;errorCode) const {
 532     // Make some effort to support NUL-terminated strings reasonably.
 533     // Take the part of the fast quick check loop that does not look up
 534     // data and check the first part of the string.
 535     // After this prefix, determine the string length to simplify the rest
 536     // of the code.
 537     const UChar *prevSrc=src;
 538     UChar c;
 539     while((c=*src++)&lt;minNeedDataCP &amp;&amp; c!=0) {}
 540     // Back out the last character for full processing.
 541     // Copy this prefix.
 542     if(--src!=prevSrc) {
 543         if(buffer!=NULL) {
</pre>
<hr />
<pre>
 590     if(limit==NULL) {
 591         src=copyLowPrefixFromNulTerminated(src, minNoCP, buffer, errorCode);
 592         if(U_FAILURE(errorCode)) {
 593             return src;
 594         }
 595         limit=u_strchr(src, 0);
 596     }
 597 
 598     const UChar *prevSrc;
 599     UChar32 c=0;
 600     uint16_t norm16=0;
 601 
 602     // only for quick check
 603     const UChar *prevBoundary=src;
 604     uint8_t prevCC=0;
 605 
 606     for(;;) {
 607         // count code units below the minimum or with irrelevant data for the quick check
 608         for(prevSrc=src; src!=limit;) {
 609             if( (c=*src)&lt;minNoCP ||
<span class="line-modified"> 610                 isMostDecompYesAndZeroCC(norm16=UCPTRIE_FAST_BMP_GET(normTrie, UCPTRIE_16, c))</span>
 611             ) {
 612                 ++src;
<span class="line-modified"> 613             } else if(!U16_IS_LEAD(c)) {</span>
 614                 break;
 615             } else {
 616                 UChar c2;
<span class="line-modified"> 617                 if((src+1)!=limit &amp;&amp; U16_IS_TRAIL(c2=src[1])) {</span>
<span class="line-modified"> 618                     c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified"> 619                     norm16=UCPTRIE_FAST_SUPP_GET(normTrie, UCPTRIE_16, c);</span>
<span class="line-modified"> 620                     if(isMostDecompYesAndZeroCC(norm16)) {</span>
<span class="line-modified"> 621                         src+=2;</span>
<span class="line-modified"> 622                     } else {</span>
<span class="line-modified"> 623                         break;</span>

 624                     }



 625                 } else {
<span class="line-modified"> 626                     ++src;  // unpaired lead surrogate: inert</span>
 627                 }
 628             }
 629         }
 630         // copy these code units all at once
 631         if(src!=prevSrc) {
 632             if(buffer!=NULL) {
 633                 if(!buffer-&gt;appendZeroCC(prevSrc, src, errorCode)) {
 634                     break;
 635                 }
 636             } else {
 637                 prevCC=0;
 638                 prevBoundary=src;
 639             }
 640         }
 641         if(src==limit) {
 642             break;
 643         }
 644 
 645         // Check one above-minimum, relevant code point.
 646         src+=U16_LENGTH(c);
</pre>
<hr />
<pre>
 666 }
 667 
 668 // Decompose a short piece of text which is likely to contain characters that
 669 // fail the quick check loop and/or where the quick check loop&#39;s overhead
 670 // is unlikely to be amortized.
 671 // Called by the compose() and makeFCD() implementations.
 672 const UChar *
 673 Normalizer2Impl::decomposeShort(const UChar *src, const UChar *limit,
 674                                 UBool stopAtCompBoundary, UBool onlyContiguous,
 675                                 ReorderingBuffer &amp;buffer, UErrorCode &amp;errorCode) const {
 676     if (U_FAILURE(errorCode)) {
 677         return nullptr;
 678     }
 679     while(src&lt;limit) {
 680         if (stopAtCompBoundary &amp;&amp; *src &lt; minCompNoMaybeCP) {
 681             return src;
 682         }
 683         const UChar *prevSrc = src;
 684         UChar32 c;
 685         uint16_t norm16;
<span class="line-modified"> 686         UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, src, limit, c, norm16);</span>
 687         if (stopAtCompBoundary &amp;&amp; norm16HasCompBoundaryBefore(norm16)) {
 688             return prevSrc;
 689         }
 690         if(!decompose(c, norm16, buffer, errorCode)) {
 691             return nullptr;
 692         }
 693         if (stopAtCompBoundary &amp;&amp; norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
 694             return src;
 695         }
 696     }
 697     return src;
 698 }
 699 
 700 UBool Normalizer2Impl::decompose(UChar32 c, uint16_t norm16,
 701                                  ReorderingBuffer &amp;buffer,
 702                                  UErrorCode &amp;errorCode) const {
 703     // get the decomposition and the lead and trail cc&#39;s
 704     if (norm16 &gt;= limitNoNo) {
 705         if (isMaybeOrNonZeroCC(norm16)) {
 706             return buffer.append(c, getCCFromYesOrMaybe(norm16), errorCode);
 707         }
 708         // Maps to an isCompYesAndZeroCC.
 709         c=mapAlgorithmic(c, norm16);
<span class="line-modified"> 710         norm16=getRawNorm16(c);</span>
 711     }
 712     if (norm16 &lt; minYesNo) {
 713         // c does not decompose
 714         return buffer.append(c, 0, errorCode);
 715     } else if(isHangulLV(norm16) || isHangulLVT(norm16)) {
 716         // Hangul syllable: decompose algorithmically
 717         UChar jamos[3];
 718         return buffer.appendZeroCC(jamos, jamos+Hangul::decompose(c, jamos), errorCode);
 719     }
 720     // c decomposes, get everything from the variable-length extra data
 721     const uint16_t *mapping=getMapping(norm16);
 722     uint16_t firstUnit=*mapping;
 723     int32_t length=firstUnit&amp;MAPPING_LENGTH_MASK;
 724     uint8_t leadCC, trailCC;
 725     trailCC=(uint8_t)(firstUnit&gt;&gt;8);
 726     if(firstUnit&amp;MAPPING_HAS_CCC_LCCC_WORD) {
 727         leadCC=(uint8_t)(*(mapping-1)&gt;&gt;8);
 728     } else {
 729         leadCC=0;
 730     }
<span class="line-modified"> 731     return buffer.append((const UChar *)mapping+1, length, TRUE, leadCC, trailCC, errorCode);</span>
 732 }
 733 
 734 const uint8_t *
 735 Normalizer2Impl::decomposeShort(const uint8_t *src, const uint8_t *limit,
 736                                 UBool stopAtCompBoundary, UBool onlyContiguous,
 737                                 ReorderingBuffer &amp;buffer, UErrorCode &amp;errorCode) const {
 738     if (U_FAILURE(errorCode)) {
 739         return nullptr;
 740     }
 741     while (src &lt; limit) {
 742         const uint8_t *prevSrc = src;
 743         uint16_t norm16;
<span class="line-modified"> 744         UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, src, limit, norm16);</span>
 745         // Get the decomposition and the lead and trail cc&#39;s.
 746         UChar32 c = U_SENTINEL;
 747         if (norm16 &gt;= limitNoNo) {
 748             if (isMaybeOrNonZeroCC(norm16)) {
 749                 // No boundaries around this character.
 750                 c = codePointFromValidUTF8(prevSrc, src);
 751                 if (!buffer.append(c, getCCFromYesOrMaybe(norm16), errorCode)) {
 752                     return nullptr;
 753                 }
 754                 continue;
 755             }
 756             // Maps to an isCompYesAndZeroCC.
 757             if (stopAtCompBoundary) {
 758                 return prevSrc;
 759             }
 760             c = codePointFromValidUTF8(prevSrc, src);
 761             c = mapAlgorithmic(c, norm16);
<span class="line-modified"> 762             norm16 = getRawNorm16(c);</span>
 763         } else if (stopAtCompBoundary &amp;&amp; norm16 &lt; minNoNoCompNoMaybeCC) {
 764             return prevSrc;
 765         }
 766         // norm16!=INERT guarantees that [prevSrc, src[ is valid UTF-8.
 767         // We do not see invalid UTF-8 here because
 768         // its norm16==INERT is normalization-inert,
 769         // so it gets copied unchanged in the fast path,
 770         // and we stop the slow path where invalid UTF-8 begins.
 771         U_ASSERT(norm16 != INERT);
 772         if (norm16 &lt; minYesNo) {
 773             if (c &lt; 0) {
 774                 c = codePointFromValidUTF8(prevSrc, src);
 775             }
 776             // does not decompose
 777             if (!buffer.append(c, 0, errorCode)) {
 778                 return nullptr;
 779             }
 780         } else if (isHangulLV(norm16) || isHangulLVT(norm16)) {
 781             // Hangul syllable: decompose algorithmically
 782             if (c &lt; 0) {
 783                 c = codePointFromValidUTF8(prevSrc, src);
 784             }
 785             char16_t jamos[3];
 786             if (!buffer.appendZeroCC(jamos, jamos+Hangul::decompose(c, jamos), errorCode)) {
 787                 return nullptr;
 788             }
 789         } else {
 790             // The character decomposes, get everything from the variable-length extra data.
 791             const uint16_t *mapping = getMapping(norm16);
 792             uint16_t firstUnit = *mapping;
 793             int32_t length = firstUnit &amp; MAPPING_LENGTH_MASK;
 794             uint8_t trailCC = (uint8_t)(firstUnit &gt;&gt; 8);
 795             uint8_t leadCC;
 796             if (firstUnit &amp; MAPPING_HAS_CCC_LCCC_WORD) {
 797                 leadCC = (uint8_t)(*(mapping-1) &gt;&gt; 8);
 798             } else {
 799                 leadCC = 0;
 800             }
<span class="line-modified"> 801             if (!buffer.append((const char16_t *)mapping+1, length, TRUE, leadCC, trailCC, errorCode)) {</span>
 802                 return nullptr;
 803             }
 804         }
 805         if (stopAtCompBoundary &amp;&amp; norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
 806             return src;
 807         }
 808     }
 809     return src;
 810 }
 811 
 812 const UChar *
 813 Normalizer2Impl::getDecomposition(UChar32 c, UChar buffer[4], int32_t &amp;length) const {
 814     uint16_t norm16;
 815     if(c&lt;minDecompNoCP || isMaybeOrNonZeroCC(norm16=getNorm16(c))) {
 816         // c does not decompose
 817         return nullptr;
 818     }
 819     const UChar *decomp = nullptr;
 820     if(isDecompNoAlgorithmic(norm16)) {
 821         // Maps to an isCompYesAndZeroCC.
 822         c=mapAlgorithmic(c, norm16);
 823         decomp=buffer;
 824         length=0;
 825         U16_APPEND_UNSAFE(buffer, length, c);
 826         // The mapping might decompose further.
<span class="line-modified"> 827         norm16 = getRawNorm16(c);</span>
 828     }
 829     if (norm16 &lt; minYesNo) {
 830         return decomp;
 831     } else if(isHangulLV(norm16) || isHangulLVT(norm16)) {
 832         // Hangul syllable: decompose algorithmically
 833         length=Hangul::decompose(c, buffer);
 834         return buffer;
 835     }
 836     // c decomposes, get everything from the variable-length extra data
 837     const uint16_t *mapping=getMapping(norm16);
 838     length=*mapping&amp;MAPPING_LENGTH_MASK;
 839     return (const UChar *)mapping+1;
 840 }
 841 
 842 // The capacity of the buffer must be 30=MAPPING_LENGTH_MASK-1
 843 // so that a raw mapping fits that consists of one unit (&quot;rm0&quot;)
 844 // plus all but the first two code units of the normal mapping.
 845 // The maximum length of a normal mapping is 31=MAPPING_LENGTH_MASK.
 846 const UChar *
 847 Normalizer2Impl::getRawDecomposition(UChar32 c, UChar buffer[30], int32_t &amp;length) const {
</pre>
<hr />
<pre>
 879             length=mLength-1;
 880             return buffer;
 881         }
 882     } else {
 883         length=mLength;
 884         return (const UChar *)mapping+1;
 885     }
 886 }
 887 
 888 void Normalizer2Impl::decomposeAndAppend(const UChar *src, const UChar *limit,
 889                                          UBool doDecompose,
 890                                          UnicodeString &amp;safeMiddle,
 891                                          ReorderingBuffer &amp;buffer,
 892                                          UErrorCode &amp;errorCode) const {
 893     buffer.copyReorderableSuffixTo(safeMiddle);
 894     if(doDecompose) {
 895         decompose(src, limit, &amp;buffer, errorCode);
 896         return;
 897     }
 898     // Just merge the strings at the boundary.
<span class="line-modified"> 899     bool isFirst = true;</span>
<span class="line-modified"> 900     uint8_t firstCC = 0, prevCC = 0, cc;</span>
<span class="line-modified"> 901     const UChar *p = src;</span>
<span class="line-modified"> 902     while (p != limit) {</span>
<span class="line-modified"> 903         const UChar *codePointStart = p;</span>
<span class="line-modified"> 904         UChar32 c;</span>
<span class="line-modified"> 905         uint16_t norm16;</span>
<span class="line-added"> 906         UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);</span>
<span class="line-added"> 907         if ((cc = getCC(norm16)) == 0) {</span>
<span class="line-added"> 908             p = codePointStart;</span>
<span class="line-added"> 909             break;</span>
<span class="line-added"> 910         }</span>
<span class="line-added"> 911         if (isFirst) {</span>
<span class="line-added"> 912             firstCC = cc;</span>
<span class="line-added"> 913             isFirst = false;</span>
<span class="line-added"> 914         }</span>
<span class="line-added"> 915         prevCC = cc;</span>
<span class="line-added"> 916     }</span>
 917     if(limit==NULL) {  // appendZeroCC() needs limit!=NULL
<span class="line-modified"> 918         limit=u_strchr(p, 0);</span>
 919     }
 920 
<span class="line-modified"> 921     if (buffer.append(src, (int32_t)(p - src), FALSE, firstCC, prevCC, errorCode)) {</span>
<span class="line-modified"> 922         buffer.appendZeroCC(p, limit, errorCode);</span>
 923     }
 924 }
 925 
 926 UBool Normalizer2Impl::hasDecompBoundaryBefore(UChar32 c) const {
 927     return c &lt; minLcccCP || (c &lt;= 0xffff &amp;&amp; !singleLeadMightHaveNonZeroFCD16(c)) ||
 928         norm16HasDecompBoundaryBefore(getNorm16(c));
 929 }
 930 
 931 UBool Normalizer2Impl::norm16HasDecompBoundaryBefore(uint16_t norm16) const {
 932     if (norm16 &lt; minNoNoCompNoMaybeCC) {
 933         return TRUE;
 934     }
 935     if (norm16 &gt;= limitNoNo) {
 936         return norm16 &lt;= MIN_NORMAL_MAYBE_YES || norm16 == JAMO_VT;
 937     }
 938     // c decomposes, get everything from the variable-length extra data
 939     const uint16_t *mapping=getMapping(norm16);
 940     uint16_t firstUnit=*mapping;
 941     // TRUE if leadCC==0 (hasFCDBoundaryBefore())
 942     return (firstUnit&amp;MAPPING_HAS_CCC_LCCC_WORD)==0 || (*(mapping-1)&amp;0xff00)==0;
</pre>
<hr />
<pre>
1049 }
1050 
1051 /**
1052   * @param list some character&#39;s compositions list
1053   * @param set recursively receives the composites from these compositions
1054   */
1055 void Normalizer2Impl::addComposites(const uint16_t *list, UnicodeSet &amp;set) const {
1056     uint16_t firstUnit;
1057     int32_t compositeAndFwd;
1058     do {
1059         firstUnit=*list;
1060         if((firstUnit&amp;COMP_1_TRIPLE)==0) {
1061             compositeAndFwd=list[1];
1062             list+=2;
1063         } else {
1064             compositeAndFwd=(((int32_t)list[1]&amp;~COMP_2_TRAIL_MASK)&lt;&lt;16)|list[2];
1065             list+=3;
1066         }
1067         UChar32 composite=compositeAndFwd&gt;&gt;1;
1068         if((compositeAndFwd&amp;1)!=0) {
<span class="line-modified">1069             addComposites(getCompositionsListForComposite(getRawNorm16(composite)), set);</span>
1070         }
1071         set.add(composite);
1072     } while((firstUnit&amp;COMP_1_LAST_TUPLE)==0);
1073 }
1074 
1075 /*
1076  * Recomposes the buffer text starting at recomposeStartIndex
1077  * (which is in NFD - decomposed and canonically ordered),
1078  * and truncates the buffer contents.
1079  *
1080  * Note that recomposition never lengthens the text:
1081  * Any character consists of either one or two code units;
1082  * a composition may contain at most one more code unit than the original starter,
1083  * while the combining mark that is removed has at least one code unit.
1084  */
1085 void Normalizer2Impl::recompose(ReorderingBuffer &amp;buffer, int32_t recomposeStartIndex,
1086                                 UBool onlyContiguous) const {
1087     UChar *p=buffer.getStart()+recomposeStartIndex;
1088     UChar *limit=buffer.getLimit();
1089     if(p==limit) {
1090         return;
1091     }
1092 
1093     UChar *starter, *pRemove, *q, *r;
1094     const uint16_t *compositionsList;
1095     UChar32 c, compositeAndFwd;
1096     uint16_t norm16;
1097     uint8_t cc, prevCC;
1098     UBool starterIsSupplementary;
1099 
1100     // Some of the following variables are not used until we have a forward-combining starter
1101     // and are only initialized now to avoid compiler warnings.
1102     compositionsList=NULL;  // used as indicator for whether we have a forward-combining starter
1103     starter=NULL;
1104     starterIsSupplementary=FALSE;
1105     prevCC=0;
1106 
1107     for(;;) {
<span class="line-modified">1108         UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);</span>
1109         cc=getCCFromYesOrMaybe(norm16);
1110         if( // this character combines backward and
1111             isMaybe(norm16) &amp;&amp;
1112             // we have seen a starter that combines forward and
1113             compositionsList!=NULL &amp;&amp;
1114             // the backward-combining character is not blocked
1115             (prevCC&lt;cc || prevCC==0)
1116         ) {
1117             if(isJamoVT(norm16)) {
1118                 // c is a Jamo V/T, see if we can compose it with the previous character.
1119                 if(c&lt;Hangul::JAMO_T_BASE) {
1120                     // c is a Jamo Vowel, compose with previous Jamo L and following Jamo T.
1121                     UChar prev=(UChar)(*starter-Hangul::JAMO_L_BASE);
1122                     if(prev&lt;Hangul::JAMO_L_COUNT) {
1123                         pRemove=p-1;
1124                         UChar syllable=(UChar)
1125                             (Hangul::HANGUL_BASE+
1126                              (prev*Hangul::JAMO_V_COUNT+(c-Hangul::JAMO_V_BASE))*
1127                              Hangul::JAMO_T_COUNT);
1128                         UChar t;
</pre>
<hr />
<pre>
1193                 }
1194 
1195                 /* remove the combining mark by moving the following text over it */
1196                 if(pRemove&lt;p) {
1197                     q=pRemove;
1198                     r=p;
1199                     while(r&lt;limit) {
1200                         *q++=*r++;
1201                     }
1202                     limit=q;
1203                     p=pRemove;
1204                 }
1205                 // Keep prevCC because we removed the combining mark.
1206 
1207                 if(p==limit) {
1208                     break;
1209                 }
1210                 // Is the composite a starter that combines forward?
1211                 if(compositeAndFwd&amp;1) {
1212                     compositionsList=
<span class="line-modified">1213                         getCompositionsListForComposite(getRawNorm16(composite));</span>
1214                 } else {
1215                     compositionsList=NULL;
1216                 }
1217 
1218                 // We combined; continue with looking for compositions.
1219                 continue;
1220             }
1221         }
1222 
1223         // no combination this time
1224         prevCC=cc;
1225         if(p==limit) {
1226             break;
1227         }
1228 
1229         // If c did not combine, then check if it is a starter.
1230         if(cc==0) {
1231             // Found a new starter.
1232             if((compositionsList=getCompositionsListForDecompYes(norm16))!=NULL) {
1233                 // It may combine with something, prepare for it.
1234                 if(U_IS_BMP(c)) {
1235                     starterIsSupplementary=FALSE;
1236                     starter=p-1;
1237                 } else {
1238                     starterIsSupplementary=TRUE;
1239                     starter=p-2;
1240                 }
1241             }
1242         } else if(onlyContiguous) {
1243             // FCC: no discontiguous compositions; any intervening character blocks.
1244             compositionsList=NULL;
1245         }
1246     }
1247     buffer.setReorderingLimit(limit);
1248 }
1249 
1250 UChar32
1251 Normalizer2Impl::composePair(UChar32 a, UChar32 b) const {
<span class="line-modified">1252     uint16_t norm16=getNorm16(a);  // maps an out-of-range &#39;a&#39; to inert norm16</span>
1253     const uint16_t *list;
1254     if(isInert(norm16)) {
1255         return U_SENTINEL;
1256     } else if(norm16&lt;minYesNoMappingsOnly) {
1257         // a combines forward.
1258         if(isJamoL(norm16)) {
1259             b-=Hangul::JAMO_V_BASE;
1260             if(0&lt;=b &amp;&amp; b&lt;Hangul::JAMO_V_COUNT) {
1261                 return
1262                     (Hangul::HANGUL_BASE+
1263                      ((a-Hangul::JAMO_L_BASE)*Hangul::JAMO_V_COUNT+b)*
1264                      Hangul::JAMO_T_COUNT);
1265             } else {
1266                 return U_SENTINEL;
1267             }
1268         } else if(isHangulLV(norm16)) {
1269             b-=Hangul::JAMO_T_BASE;
1270             if(0&lt;b &amp;&amp; b&lt;Hangul::JAMO_T_COUNT) {  // not b==0!
1271                 return a+b;
1272             } else {
</pre>
<hr />
<pre>
1323                 buffer.removeSuffix(1);
1324                 prevBoundary = --src;
1325             }
1326         }
1327     }
1328 
1329     for (;;) {
1330         // Fast path: Scan over a sequence of characters below the minimum &quot;no or maybe&quot; code point,
1331         // or with (compYes &amp;&amp; ccc==0) properties.
1332         const UChar *prevSrc;
1333         UChar32 c = 0;
1334         uint16_t norm16 = 0;
1335         for (;;) {
1336             if (src == limit) {
1337                 if (prevBoundary != limit &amp;&amp; doCompose) {
1338                     buffer.appendZeroCC(prevBoundary, limit, errorCode);
1339                 }
1340                 return TRUE;
1341             }
1342             if( (c=*src)&lt;minNoMaybeCP ||
<span class="line-modified">1343                 isCompYesAndZeroCC(norm16=UCPTRIE_FAST_BMP_GET(normTrie, UCPTRIE_16, c))</span>
1344             ) {
1345                 ++src;
1346             } else {
1347                 prevSrc = src++;
<span class="line-modified">1348                 if(!U16_IS_LEAD(c)) {</span>
1349                     break;
1350                 } else {
1351                     UChar c2;
<span class="line-modified">1352                     if(src!=limit &amp;&amp; U16_IS_TRAIL(c2=*src)) {</span>
<span class="line-modified">1353                         ++src;</span>
<span class="line-modified">1354                         c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified">1355                         norm16=UCPTRIE_FAST_SUPP_GET(normTrie, UCPTRIE_16, c);</span>
<span class="line-modified">1356                         if(!isCompYesAndZeroCC(norm16)) {</span>
<span class="line-modified">1357                             break;</span>



1358                         }
1359                     }



1360                 }
1361             }
1362         }
1363         // isCompYesAndZeroCC(norm16) is false, that is, norm16&gt;=minNoNo.
1364         // The current character is either a &quot;noNo&quot; (has a mapping)
1365         // or a &quot;maybeYes&quot; (combines backward)
1366         // or a &quot;yesYes&quot; with ccc!=0.
1367         // It is not a Hangul syllable or Jamo L because those have &quot;yes&quot; properties.
1368 
1369         // Medium-fast path: Handle cases that do not require full decomposition and recomposition.
1370         if (!isMaybeOrNonZeroCC(norm16)) {  // minNoNo &lt;= norm16 &lt; minMaybeYes
1371             if (!doCompose) {
1372                 return FALSE;
1373             }
1374             // Fast path for mapping a character that is immediately surrounded by boundaries.
1375             // In this case, we need not decompose around the current character.
1376             if (isDecompNoAlgorithmic(norm16)) {
1377                 // Maps to a single isCompYesAndZeroCC character
1378                 // which also implies hasCompBoundaryBefore.
1379                 if (norm16HasCompBoundaryAfter(norm16, onlyContiguous) ||
</pre>
<hr />
<pre>
1487             uint8_t cc = getCCFromNormalYesOrMaybe(norm16);  // cc!=0
1488             if (onlyContiguous /* FCC */ &amp;&amp; getPreviousTrailCC(prevBoundary, prevSrc) &gt; cc) {
1489                 // Fails FCD test, need to decompose and contiguously recompose.
1490                 if (!doCompose) {
1491                     return FALSE;
1492                 }
1493             } else {
1494                 // If !onlyContiguous (not FCC), then we ignore the tccc of
1495                 // the previous character which passed the quick check &quot;yes &amp;&amp; ccc==0&quot; test.
1496                 const UChar *nextSrc;
1497                 uint16_t n16;
1498                 for (;;) {
1499                     if (src == limit) {
1500                         if (doCompose) {
1501                             buffer.appendZeroCC(prevBoundary, limit, errorCode);
1502                         }
1503                         return TRUE;
1504                     }
1505                     uint8_t prevCC = cc;
1506                     nextSrc = src;
<span class="line-modified">1507                     UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, nextSrc, limit, c, n16);</span>
1508                     if (n16 &gt;= MIN_YES_YES_WITH_CC) {
1509                         cc = getCCFromNormalYesOrMaybe(n16);
1510                         if (prevCC &gt; cc) {
1511                             if (!doCompose) {
1512                                 return FALSE;
1513                             }
1514                             break;
1515                         }
1516                     } else {
1517                         break;
1518                     }
1519                     src = nextSrc;
1520                 }
1521                 // src is after the last in-order combining mark.
1522                 // If there is a boundary here, then we continue with no change.
1523                 if (norm16HasCompBoundaryBefore(n16)) {
1524                     if (isCompYesAndZeroCC(n16)) {
1525                         src = nextSrc;
1526                     }
1527                     continue;
1528                 }
1529                 // Use the slow path. There is no boundary in [prevSrc, src[.
1530             }
1531         }
1532 
1533         // Slow path: Find the nearest boundaries around the current character,
1534         // decompose and recompose.
1535         if (prevBoundary != prevSrc &amp;&amp; !norm16HasCompBoundaryBefore(norm16)) {
1536             const UChar *p = prevSrc;
<span class="line-modified">1537             UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, prevBoundary, p, c, norm16);</span>
1538             if (!norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
1539                 prevSrc = p;
1540             }
1541         }
1542         if (doCompose &amp;&amp; prevBoundary != prevSrc &amp;&amp; !buffer.appendZeroCC(prevBoundary, prevSrc, errorCode)) {
1543             break;
1544         }
1545         int32_t recomposeStartIndex=buffer.length();
1546         // We know there is not a boundary here.
1547         decomposeShort(prevSrc, src, FALSE /* !stopAtCompBoundary */, onlyContiguous,
1548                        buffer, errorCode);
1549         // Decompose until the next boundary.
1550         src = decomposeShort(src, limit, TRUE /* stopAtCompBoundary */, onlyContiguous,
1551                              buffer, errorCode);
1552         if (U_FAILURE(errorCode)) {
1553             break;
1554         }
1555         if ((src - prevSrc) &gt; INT32_MAX) {  // guard before buffer.equals()
1556             errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
1557             return TRUE;
</pre>
<hr />
<pre>
1584         if (prevBoundary != src) {
1585             if (hasCompBoundaryAfter(*(src-1), onlyContiguous)) {
1586                 prevBoundary = src;
1587             } else {
1588                 prevBoundary = --src;
1589             }
1590         }
1591     }
1592 
1593     for(;;) {
1594         // Fast path: Scan over a sequence of characters below the minimum &quot;no or maybe&quot; code point,
1595         // or with (compYes &amp;&amp; ccc==0) properties.
1596         const UChar *prevSrc;
1597         UChar32 c = 0;
1598         uint16_t norm16 = 0;
1599         for (;;) {
1600             if(src==limit) {
1601                 return src;
1602             }
1603             if( (c=*src)&lt;minNoMaybeCP ||
<span class="line-modified">1604                 isCompYesAndZeroCC(norm16=UCPTRIE_FAST_BMP_GET(normTrie, UCPTRIE_16, c))</span>
1605             ) {
1606                 ++src;
1607             } else {
1608                 prevSrc = src++;
<span class="line-modified">1609                 if(!U16_IS_LEAD(c)) {</span>
1610                     break;
1611                 } else {
1612                     UChar c2;
<span class="line-modified">1613                     if(src!=limit &amp;&amp; U16_IS_TRAIL(c2=*src)) {</span>
<span class="line-modified">1614                         ++src;</span>
<span class="line-modified">1615                         c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified">1616                         norm16=UCPTRIE_FAST_SUPP_GET(normTrie, UCPTRIE_16, c);</span>
<span class="line-modified">1617                         if(!isCompYesAndZeroCC(norm16)) {</span>
<span class="line-modified">1618                             break;</span>



1619                         }
1620                     }



1621                 }
1622             }
1623         }
1624         // isCompYesAndZeroCC(norm16) is false, that is, norm16&gt;=minNoNo.
1625         // The current character is either a &quot;noNo&quot; (has a mapping)
1626         // or a &quot;maybeYes&quot; (combines backward)
1627         // or a &quot;yesYes&quot; with ccc!=0.
1628         // It is not a Hangul syllable or Jamo L because those have &quot;yes&quot; properties.
1629 
1630         uint16_t prevNorm16 = INERT;
1631         if (prevBoundary != prevSrc) {
1632             if (norm16HasCompBoundaryBefore(norm16)) {
1633                 prevBoundary = prevSrc;
1634             } else {
1635                 const UChar *p = prevSrc;
1636                 uint16_t n16;
<span class="line-modified">1637                 UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, prevBoundary, p, c, n16);</span>
1638                 if (norm16HasCompBoundaryAfter(n16, onlyContiguous)) {
1639                     prevBoundary = prevSrc;
1640                 } else {
1641                     prevBoundary = p;
1642                     prevNorm16 = n16;
1643                 }
1644             }
1645         }
1646 
1647         if(isMaybeOrNonZeroCC(norm16)) {
1648             uint8_t cc=getCCFromYesOrMaybe(norm16);
1649             if (onlyContiguous /* FCC */ &amp;&amp; cc != 0 &amp;&amp;
1650                     getTrailCCFromCompYesAndZeroCC(prevNorm16) &gt; cc) {
1651                 // The [prevBoundary..prevSrc[ character
1652                 // passed the quick check &quot;yes &amp;&amp; ccc==0&quot; test
1653                 // but is out of canonical order with the current combining mark.
1654             } else {
1655                 // If !onlyContiguous (not FCC), then we ignore the tccc of
1656                 // the previous character which passed the quick check &quot;yes &amp;&amp; ccc==0&quot; test.
1657                 const UChar *nextSrc;
1658                 for (;;) {
1659                     if (norm16 &lt; MIN_YES_YES_WITH_CC) {
1660                         if (pQCResult != nullptr) {
1661                             *pQCResult = UNORM_MAYBE;
1662                         } else {
1663                             return prevBoundary;
1664                         }
1665                     }
1666                     if (src == limit) {
1667                         return src;
1668                     }
1669                     uint8_t prevCC = cc;
1670                     nextSrc = src;
<span class="line-modified">1671                     UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, nextSrc, limit, c, norm16);</span>
1672                     if (isMaybeOrNonZeroCC(norm16)) {
1673                         cc = getCCFromYesOrMaybe(norm16);
1674                         if (!(prevCC &lt;= cc || cc == 0)) {
1675                             break;
1676                         }
1677                     } else {
1678                         break;
1679                     }
1680                     src = nextSrc;
1681                 }
1682                 // src is after the last in-order combining mark.
1683                 if (isCompYesAndZeroCC(norm16)) {
1684                     prevBoundary = src;
1685                     src = nextSrc;
1686                     continue;
1687                 }
1688             }
1689         }
1690         if(pQCResult!=NULL) {
1691             *pQCResult=UNORM_NO;
</pre>
<hr />
<pre>
1738     uint8_t minNoMaybeLead = leadByteForCP(minCompNoMaybeCP);
1739     const uint8_t *prevBoundary = src;
1740 
1741     for (;;) {
1742         // Fast path: Scan over a sequence of characters below the minimum &quot;no or maybe&quot; code point,
1743         // or with (compYes &amp;&amp; ccc==0) properties.
1744         const uint8_t *prevSrc;
1745         uint16_t norm16 = 0;
1746         for (;;) {
1747             if (src == limit) {
1748                 if (prevBoundary != limit &amp;&amp; sink != nullptr) {
1749                     ByteSinkUtil::appendUnchanged(prevBoundary, limit,
1750                                                   *sink, options, edits, errorCode);
1751                 }
1752                 return TRUE;
1753             }
1754             if (*src &lt; minNoMaybeLead) {
1755                 ++src;
1756             } else {
1757                 prevSrc = src;
<span class="line-modified">1758                 UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, src, limit, norm16);</span>
1759                 if (!isCompYesAndZeroCC(norm16)) {
1760                     break;
1761                 }
1762             }
1763         }
1764         // isCompYesAndZeroCC(norm16) is false, that is, norm16&gt;=minNoNo.
1765         // The current character is either a &quot;noNo&quot; (has a mapping)
1766         // or a &quot;maybeYes&quot; (combines backward)
1767         // or a &quot;yesYes&quot; with ccc!=0.
1768         // It is not a Hangul syllable or Jamo L because those have &quot;yes&quot; properties.
1769 
1770         // Medium-fast path: Handle cases that do not require full decomposition and recomposition.
1771         if (!isMaybeOrNonZeroCC(norm16)) {  // minNoNo &lt;= norm16 &lt; minMaybeYes
1772             if (sink == nullptr) {
1773                 return FALSE;
1774             }
1775             // Fast path for mapping a character that is immediately surrounded by boundaries.
1776             // In this case, we need not decompose around the current character.
1777             if (isDecompNoAlgorithmic(norm16)) {
1778                 // Maps to a single isCompYesAndZeroCC character
</pre>
<hr />
<pre>
1897             if (onlyContiguous /* FCC */ &amp;&amp; getPreviousTrailCC(prevBoundary, prevSrc) &gt; cc) {
1898                 // Fails FCD test, need to decompose and contiguously recompose.
1899                 if (sink == nullptr) {
1900                     return FALSE;
1901                 }
1902             } else {
1903                 // If !onlyContiguous (not FCC), then we ignore the tccc of
1904                 // the previous character which passed the quick check &quot;yes &amp;&amp; ccc==0&quot; test.
1905                 const uint8_t *nextSrc;
1906                 uint16_t n16;
1907                 for (;;) {
1908                     if (src == limit) {
1909                         if (sink != nullptr) {
1910                             ByteSinkUtil::appendUnchanged(prevBoundary, limit,
1911                                                           *sink, options, edits, errorCode);
1912                         }
1913                         return TRUE;
1914                     }
1915                     uint8_t prevCC = cc;
1916                     nextSrc = src;
<span class="line-modified">1917                     UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, nextSrc, limit, n16);</span>
1918                     if (n16 &gt;= MIN_YES_YES_WITH_CC) {
1919                         cc = getCCFromNormalYesOrMaybe(n16);
1920                         if (prevCC &gt; cc) {
1921                             if (sink == nullptr) {
1922                                 return FALSE;
1923                             }
1924                             break;
1925                         }
1926                     } else {
1927                         break;
1928                     }
1929                     src = nextSrc;
1930                 }
1931                 // src is after the last in-order combining mark.
1932                 // If there is a boundary here, then we continue with no change.
1933                 if (norm16HasCompBoundaryBefore(n16)) {
1934                     if (isCompYesAndZeroCC(n16)) {
1935                         src = nextSrc;
1936                     }
1937                     continue;
1938                 }
1939                 // Use the slow path. There is no boundary in [prevSrc, src[.
1940             }
1941         }
1942 
1943         // Slow path: Find the nearest boundaries around the current character,
1944         // decompose and recompose.
1945         if (prevBoundary != prevSrc &amp;&amp; !norm16HasCompBoundaryBefore(norm16)) {
1946             const uint8_t *p = prevSrc;
<span class="line-modified">1947             UCPTRIE_FAST_U8_PREV(normTrie, UCPTRIE_16, prevBoundary, p, norm16);</span>
1948             if (!norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
1949                 prevSrc = p;
1950             }
1951         }
1952         ReorderingBuffer buffer(*this, s16, errorCode);
1953         if (U_FAILURE(errorCode)) {
1954             break;
1955         }
1956         // We know there is not a boundary here.
1957         decomposeShort(prevSrc, src, FALSE /* !stopAtCompBoundary */, onlyContiguous,
1958                        buffer, errorCode);
1959         // Decompose until the next boundary.
1960         src = decomposeShort(src, limit, TRUE /* stopAtCompBoundary */, onlyContiguous,
1961                              buffer, errorCode);
1962         if (U_FAILURE(errorCode)) {
1963             break;
1964         }
1965         if ((src - prevSrc) &gt; INT32_MAX) {  // guard before buffer.equals()
1966             errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
1967             return TRUE;
</pre>
<hr />
<pre>
1975                     !ByteSinkUtil::appendUnchanged(prevBoundary, prevSrc,
1976                                                    *sink, options, edits, errorCode)) {
1977                 break;
1978             }
1979             if (!ByteSinkUtil::appendChange(prevSrc, src, buffer.getStart(), buffer.length(),
1980                                             *sink, edits, errorCode)) {
1981                 break;
1982             }
1983             prevBoundary = src;
1984         }
1985     }
1986     return TRUE;
1987 }
1988 
1989 UBool Normalizer2Impl::hasCompBoundaryBefore(const UChar *src, const UChar *limit) const {
1990     if (src == limit || *src &lt; minCompNoMaybeCP) {
1991         return TRUE;
1992     }
1993     UChar32 c;
1994     uint16_t norm16;
<span class="line-modified">1995     UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, src, limit, c, norm16);</span>
1996     return norm16HasCompBoundaryBefore(norm16);
1997 }
1998 
1999 UBool Normalizer2Impl::hasCompBoundaryBefore(const uint8_t *src, const uint8_t *limit) const {
2000     if (src == limit) {
2001         return TRUE;
2002     }
2003     uint16_t norm16;
<span class="line-modified">2004     UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, src, limit, norm16);</span>
2005     return norm16HasCompBoundaryBefore(norm16);
2006 }
2007 
2008 UBool Normalizer2Impl::hasCompBoundaryAfter(const UChar *start, const UChar *p,
2009                                             UBool onlyContiguous) const {
2010     if (start == p) {
2011         return TRUE;
2012     }
2013     UChar32 c;
2014     uint16_t norm16;
<span class="line-modified">2015     UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, start, p, c, norm16);</span>
2016     return norm16HasCompBoundaryAfter(norm16, onlyContiguous);
2017 }
2018 
2019 UBool Normalizer2Impl::hasCompBoundaryAfter(const uint8_t *start, const uint8_t *p,
2020                                             UBool onlyContiguous) const {
2021     if (start == p) {
2022         return TRUE;
2023     }
2024     uint16_t norm16;
<span class="line-modified">2025     UCPTRIE_FAST_U8_PREV(normTrie, UCPTRIE_16, start, p, norm16);</span>
2026     return norm16HasCompBoundaryAfter(norm16, onlyContiguous);
2027 }
2028 
2029 const UChar *Normalizer2Impl::findPreviousCompBoundary(const UChar *start, const UChar *p,
2030                                                        UBool onlyContiguous) const {
<span class="line-modified">2031     while (p != start) {</span>
<span class="line-modified">2032         const UChar *codePointLimit = p;</span>
<span class="line-modified">2033         UChar32 c;</span>
<span class="line-added">2034         uint16_t norm16;</span>
<span class="line-added">2035         UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, start, p, c, norm16);</span>
2036         if (norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
<span class="line-modified">2037             return codePointLimit;</span>
2038         }
<span class="line-modified">2039         if (hasCompBoundaryBefore(c, norm16)) {</span>
<span class="line-modified">2040             return p;</span>
2041         }
2042     }
<span class="line-added">2043     return p;</span>
2044 }
2045 
2046 const UChar *Normalizer2Impl::findNextCompBoundary(const UChar *p, const UChar *limit,
2047                                                    UBool onlyContiguous) const {
<span class="line-modified">2048     while (p != limit) {</span>
<span class="line-modified">2049         const UChar *codePointStart = p;</span>
<span class="line-modified">2050         UChar32 c;</span>
<span class="line-modified">2051         uint16_t norm16;</span>
<span class="line-modified">2052         UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);</span>
<span class="line-added">2053         if (hasCompBoundaryBefore(c, norm16)) {</span>
<span class="line-added">2054             return codePointStart;</span>
2055         }
2056         if (norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
<span class="line-modified">2057             return p;</span>
2058         }
2059     }
<span class="line-added">2060     return p;</span>
2061 }
2062 
2063 uint8_t Normalizer2Impl::getPreviousTrailCC(const UChar *start, const UChar *p) const {
2064     if (start == p) {
2065         return 0;
2066     }
2067     int32_t i = (int32_t)(p - start);
2068     UChar32 c;
2069     U16_PREV(start, 0, i, c);
2070     return (uint8_t)getFCD16(c);
2071 }
2072 
2073 uint8_t Normalizer2Impl::getPreviousTrailCC(const uint8_t *start, const uint8_t *p) const {
2074     if (start == p) {
2075         return 0;
2076     }
2077     int32_t i = (int32_t)(p - start);
2078     UChar32 c;
2079     U8_PREV(start, 0, i, c);
2080     return (uint8_t)getFCD16(c);
</pre>
<hr />
<pre>
2088 // minDecompNoCP etc. and smallFCD[] are intended to help with any loss of performance,
2089 // at least for ASCII &amp; CJK.
2090 
2091 // Gets the FCD value from the regular normalization data.
2092 uint16_t Normalizer2Impl::getFCD16FromNormData(UChar32 c) const {
2093     uint16_t norm16=getNorm16(c);
2094     if (norm16 &gt;= limitNoNo) {
2095         if(norm16&gt;=MIN_NORMAL_MAYBE_YES) {
2096             // combining mark
2097             norm16=getCCFromNormalYesOrMaybe(norm16);
2098             return norm16|(norm16&lt;&lt;8);
2099         } else if(norm16&gt;=minMaybeYes) {
2100             return 0;
2101         } else {  // isDecompNoAlgorithmic(norm16)
2102             uint16_t deltaTrailCC = norm16 &amp; DELTA_TCCC_MASK;
2103             if (deltaTrailCC &lt;= DELTA_TCCC_1) {
2104                 return deltaTrailCC &gt;&gt; OFFSET_SHIFT;
2105             }
2106             // Maps to an isCompYesAndZeroCC.
2107             c=mapAlgorithmic(c, norm16);
<span class="line-modified">2108             norm16=getRawNorm16(c);</span>
2109         }
2110     }
2111     if(norm16&lt;=minYesNo || isHangulLVT(norm16)) {
2112         // no decomposition or Hangul syllable, all zeros
2113         return 0;
2114     }
2115     // c decomposes, get everything from the variable-length extra data
2116     const uint16_t *mapping=getMapping(norm16);
2117     uint16_t firstUnit=*mapping;
2118     norm16=firstUnit&gt;&gt;8;  // tccc
2119     if(firstUnit&amp;MAPPING_HAS_CCC_LCCC_WORD) {
2120         norm16|=*(mapping-1)&amp;0xff00;  // lccc
2121     }
2122     return norm16;
2123 }
2124 
2125 // Dual functionality:
2126 // buffer!=NULL: normalize
2127 // buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes
2128 const UChar *
</pre>
<hr />
<pre>
2153     // Note: In this function we use buffer-&gt;appendZeroCC() because we track
2154     // the lead and trail combining classes here, rather than leaving it to
2155     // the ReorderingBuffer.
2156     // The exception is the call to decomposeShort() which uses the buffer
2157     // in the normal way.
2158 
2159     const UChar *prevSrc;
2160     UChar32 c=0;
2161     uint16_t fcd16=0;
2162 
2163     for(;;) {
2164         // count code units with lccc==0
2165         for(prevSrc=src; src!=limit;) {
2166             if((c=*src)&lt;minLcccCP) {
2167                 prevFCD16=~c;
2168                 ++src;
2169             } else if(!singleLeadMightHaveNonZeroFCD16(c)) {
2170                 prevFCD16=0;
2171                 ++src;
2172             } else {
<span class="line-modified">2173                 if(U16_IS_LEAD(c)) {</span>
2174                     UChar c2;
<span class="line-modified">2175                     if((src+1)!=limit &amp;&amp; U16_IS_TRAIL(c2=src[1])) {</span>
<span class="line-modified">2176                         c=U16_GET_SUPPLEMENTARY(c, c2);</span>







2177                     }
2178                 }
2179                 if((fcd16=getFCD16FromNormData(c))&lt;=0xff) {
2180                     prevFCD16=fcd16;
2181                     src+=U16_LENGTH(c);
2182                 } else {
2183                     break;
2184                 }
2185             }
2186         }
2187         // copy these code units all at once
2188         if(src!=prevSrc) {
2189             if(buffer!=NULL &amp;&amp; !buffer-&gt;appendZeroCC(prevSrc, src, errorCode)) {
2190                 break;
2191             }
2192             if(src==limit) {
2193                 break;
2194             }
2195             prevBoundary=src;
2196             // We know that the previous character&#39;s lccc==0.
</pre>
<hr />
<pre>
2287                 return;
2288             }
2289             src=firstBoundaryInSrc;
2290         }
2291     }
2292     if(doMakeFCD) {
2293         makeFCD(src, limit, &amp;buffer, errorCode);
2294     } else {
2295         if(limit==NULL) {  // appendZeroCC() needs limit!=NULL
2296             limit=u_strchr(src, 0);
2297         }
2298         buffer.appendZeroCC(src, limit, errorCode);
2299     }
2300 }
2301 
2302 const UChar *Normalizer2Impl::findPreviousFCDBoundary(const UChar *start, const UChar *p) const {
2303     while(start&lt;p) {
2304         const UChar *codePointLimit = p;
2305         UChar32 c;
2306         uint16_t norm16;
<span class="line-modified">2307         UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, start, p, c, norm16);</span>
2308         if (c &lt; minDecompNoCP || norm16HasDecompBoundaryAfter(norm16)) {
2309             return codePointLimit;
2310         }
2311         if (norm16HasDecompBoundaryBefore(norm16)) {
2312             return p;
2313         }
2314     }
2315     return p;
2316 }
2317 
2318 const UChar *Normalizer2Impl::findNextFCDBoundary(const UChar *p, const UChar *limit) const {
2319     while(p&lt;limit) {
2320         const UChar *codePointStart=p;
2321         UChar32 c;
2322         uint16_t norm16;
<span class="line-modified">2323         UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);</span>
2324         if (c &lt; minLcccCP || norm16HasDecompBoundaryBefore(norm16)) {
2325             return codePointStart;
2326         }
2327         if (norm16HasDecompBoundaryAfter(norm16)) {
2328             return p;
2329         }
2330     }
2331     return p;
2332 }
2333 
2334 // CanonicalIterator data -------------------------------------------------- ***
2335 
2336 CanonIterData::CanonIterData(UErrorCode &amp;errorCode) :
<span class="line-modified">2337         mutableTrie(umutablecptrie_open(0, 0, &amp;errorCode)), trie(nullptr),</span>
2338         canonStartSets(uprv_deleteUObject, NULL, errorCode) {}
2339 
2340 CanonIterData::~CanonIterData() {
<span class="line-modified">2341     umutablecptrie_close(mutableTrie);</span>
<span class="line-added">2342     ucptrie_close(trie);</span>
2343 }
2344 
2345 void CanonIterData::addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode &amp;errorCode) {
<span class="line-modified">2346     uint32_t canonValue = umutablecptrie_get(mutableTrie, decompLead);</span>
2347     if((canonValue&amp;(CANON_HAS_SET|CANON_VALUE_MASK))==0 &amp;&amp; origin!=0) {
2348         // origin is the first character whose decomposition starts with
2349         // the character for which we are setting the value.
<span class="line-modified">2350         umutablecptrie_set(mutableTrie, decompLead, canonValue|origin, &amp;errorCode);</span>
2351     } else {
2352         // origin is not the first character, or it is U+0000.
2353         UnicodeSet *set;
2354         if((canonValue&amp;CANON_HAS_SET)==0) {
2355             set=new UnicodeSet;
2356             if(set==NULL) {
2357                 errorCode=U_MEMORY_ALLOCATION_ERROR;
2358                 return;
2359             }
2360             UChar32 firstOrigin=(UChar32)(canonValue&amp;CANON_VALUE_MASK);
2361             canonValue=(canonValue&amp;~CANON_VALUE_MASK)|CANON_HAS_SET|(uint32_t)canonStartSets.size();
<span class="line-modified">2362             umutablecptrie_set(mutableTrie, decompLead, canonValue, &amp;errorCode);</span>
2363             canonStartSets.addElement(set, errorCode);
2364             if(firstOrigin!=0) {
2365                 set-&gt;add(firstOrigin);
2366             }
2367         } else {
2368             set=(UnicodeSet *)canonStartSets[(int32_t)(canonValue&amp;CANON_VALUE_MASK)];
2369         }
2370         set-&gt;add(origin);
2371     }
2372 }
2373 
2374 // C++ class for friend access to private Normalizer2Impl members.
2375 class InitCanonIterData {
2376 public:
2377     static void doInit(Normalizer2Impl *impl, UErrorCode &amp;errorCode);

2378 };
2379 
2380 U_CDECL_BEGIN
2381 
2382 // UInitOnce instantiation function for CanonIterData
2383 static void U_CALLCONV
2384 initCanonIterData(Normalizer2Impl *impl, UErrorCode &amp;errorCode) {
2385     InitCanonIterData::doInit(impl, errorCode);
2386 }
2387 












2388 U_CDECL_END
2389 
2390 void InitCanonIterData::doInit(Normalizer2Impl *impl, UErrorCode &amp;errorCode) {
2391     U_ASSERT(impl-&gt;fCanonIterData == NULL);
2392     impl-&gt;fCanonIterData = new CanonIterData(errorCode);
2393     if (impl-&gt;fCanonIterData == NULL) {
2394         errorCode=U_MEMORY_ALLOCATION_ERROR;
2395     }
2396     if (U_SUCCESS(errorCode)) {
<span class="line-modified">2397         UChar32 start = 0, end;</span>
<span class="line-modified">2398         uint32_t value;</span>
<span class="line-added">2399         while ((end = ucptrie_getRange(impl-&gt;normTrie, start,</span>
<span class="line-added">2400                                        UCPMAP_RANGE_FIXED_LEAD_SURROGATES, Normalizer2Impl::INERT,</span>
<span class="line-added">2401                                        nullptr, nullptr, &amp;value)) &gt;= 0) {</span>
<span class="line-added">2402             // Call Normalizer2Impl::makeCanonIterDataFromNorm16() for a range of same-norm16 characters.</span>
<span class="line-added">2403             if (value != Normalizer2Impl::INERT) {</span>
<span class="line-added">2404                 impl-&gt;makeCanonIterDataFromNorm16(start, end, value, *impl-&gt;fCanonIterData, errorCode);</span>
<span class="line-added">2405             }</span>
<span class="line-added">2406             start = end + 1;</span>
<span class="line-added">2407         }</span>
<span class="line-added">2408 #ifdef UCPTRIE_DEBUG</span>
<span class="line-added">2409         umutablecptrie_setName(impl-&gt;fCanonIterData-&gt;mutableTrie, &quot;CanonIterData&quot;);</span>
<span class="line-added">2410 #endif</span>
<span class="line-added">2411         impl-&gt;fCanonIterData-&gt;trie = umutablecptrie_buildImmutable(</span>
<span class="line-added">2412             impl-&gt;fCanonIterData-&gt;mutableTrie, UCPTRIE_TYPE_SMALL, UCPTRIE_VALUE_BITS_32, &amp;errorCode);</span>
<span class="line-added">2413         umutablecptrie_close(impl-&gt;fCanonIterData-&gt;mutableTrie);</span>
<span class="line-added">2414         impl-&gt;fCanonIterData-&gt;mutableTrie = nullptr;</span>
2415     }
2416     if (U_FAILURE(errorCode)) {
2417         delete impl-&gt;fCanonIterData;
2418         impl-&gt;fCanonIterData = NULL;
2419     }
2420 }
2421 





2422 void Normalizer2Impl::makeCanonIterDataFromNorm16(UChar32 start, UChar32 end, const uint16_t norm16,
2423                                                   CanonIterData &amp;newData,
2424                                                   UErrorCode &amp;errorCode) const {
2425     if(isInert(norm16) || (minYesNo&lt;=norm16 &amp;&amp; norm16&lt;minNoNo)) {
2426         // Inert, or 2-way mapping (including Hangul syllable).
2427         // We do not write a canonStartSet for any yesNo character.
2428         // Composites from 2-way mappings are added at runtime from the
2429         // starter&#39;s compositions list, and the other characters in
2430         // 2-way mappings get CANON_NOT_SEGMENT_STARTER set because they are
2431         // &quot;maybe&quot; characters.
2432         return;
2433     }
2434     for(UChar32 c=start; c&lt;=end; ++c) {
<span class="line-modified">2435         uint32_t oldValue = umutablecptrie_get(newData.mutableTrie, c);</span>
2436         uint32_t newValue=oldValue;
2437         if(isMaybeOrNonZeroCC(norm16)) {
2438             // not a segment starter if it occurs in a decomposition or has cc!=0
2439             newValue|=CANON_NOT_SEGMENT_STARTER;
2440             if(norm16&lt;MIN_NORMAL_MAYBE_YES) {
2441                 newValue|=CANON_HAS_COMPOSITIONS;
2442             }
2443         } else if(norm16&lt;minYesNo) {
2444             newValue|=CANON_HAS_COMPOSITIONS;
2445         } else {
2446             // c has a one-way decomposition
2447             UChar32 c2=c;
2448             // Do not modify the whole-range norm16 value.
2449             uint16_t norm16_2=norm16;
2450             if (isDecompNoAlgorithmic(norm16_2)) {
2451                 // Maps to an isCompYesAndZeroCC.
2452                 c2 = mapAlgorithmic(c2, norm16_2);
<span class="line-modified">2453                 norm16_2 = getRawNorm16(c2);</span>
2454                 // No compatibility mappings for the CanonicalIterator.
2455                 U_ASSERT(!(isHangulLV(norm16_2) || isHangulLVT(norm16_2)));
2456             }
2457             if (norm16_2 &gt; minYesNo) {
2458                 // c decomposes, get everything from the variable-length extra data
2459                 const uint16_t *mapping=getMapping(norm16_2);
2460                 uint16_t firstUnit=*mapping;
2461                 int32_t length=firstUnit&amp;MAPPING_LENGTH_MASK;
2462                 if((firstUnit&amp;MAPPING_HAS_CCC_LCCC_WORD)!=0) {
2463                     if(c==c2 &amp;&amp; (*(mapping-1)&amp;0xff)!=0) {
2464                         newValue|=CANON_NOT_SEGMENT_STARTER;  // original c has cc!=0
2465                     }
2466                 }
2467                 // Skip empty mappings (no characters in the decomposition).
2468                 if(length!=0) {
2469                     ++mapping;  // skip over the firstUnit
2470                     // add c to first code point&#39;s start set
2471                     int32_t i=0;
2472                     U16_NEXT_UNSAFE(mapping, i, c2);
2473                     newData.addToStartSet(c, c2, errorCode);
2474                     // Set CANON_NOT_SEGMENT_STARTER for each remaining code point of a
2475                     // one-way mapping. A 2-way mapping is possible here after
2476                     // intermediate algorithmic mapping.
2477                     if(norm16_2&gt;=minNoNo) {
2478                         while(i&lt;length) {
2479                             U16_NEXT_UNSAFE(mapping, i, c2);
<span class="line-modified">2480                             uint32_t c2Value = umutablecptrie_get(newData.mutableTrie, c2);</span>
2481                             if((c2Value&amp;CANON_NOT_SEGMENT_STARTER)==0) {
<span class="line-modified">2482                                 umutablecptrie_set(newData.mutableTrie, c2,</span>
<span class="line-modified">2483                                                    c2Value|CANON_NOT_SEGMENT_STARTER, &amp;errorCode);</span>
2484                             }
2485                         }
2486                     }
2487                 }
2488             } else {
2489                 // c decomposed to c2 algorithmically; c has cc==0
2490                 newData.addToStartSet(c, c2, errorCode);
2491             }
2492         }
2493         if(newValue!=oldValue) {
<span class="line-modified">2494             umutablecptrie_set(newData.mutableTrie, c, newValue, &amp;errorCode);</span>
2495         }
2496     }
2497 }
2498 
2499 UBool Normalizer2Impl::ensureCanonIterData(UErrorCode &amp;errorCode) const {
2500     // Logically const: Synchronized instantiation.
2501     Normalizer2Impl *me=const_cast&lt;Normalizer2Impl *&gt;(this);
2502     umtx_initOnce(me-&gt;fCanonIterDataInitOnce, &amp;initCanonIterData, me, errorCode);
2503     return U_SUCCESS(errorCode);
2504 }
2505 
2506 int32_t Normalizer2Impl::getCanonValue(UChar32 c) const {
<span class="line-modified">2507     return (int32_t)ucptrie_get(fCanonIterData-&gt;trie, c);</span>
2508 }
2509 
2510 const UnicodeSet &amp;Normalizer2Impl::getCanonStartSet(int32_t n) const {
2511     return *(const UnicodeSet *)fCanonIterData-&gt;canonStartSets[n];
2512 }
2513 
2514 UBool Normalizer2Impl::isCanonSegmentStarter(UChar32 c) const {
2515     return getCanonValue(c)&gt;=0;
2516 }
2517 
2518 UBool Normalizer2Impl::getCanonStartSet(UChar32 c, UnicodeSet &amp;set) const {
2519     int32_t canonValue=getCanonValue(c)&amp;~CANON_NOT_SEGMENT_STARTER;
2520     if(canonValue==0) {
2521         return FALSE;
2522     }
2523     set.clear();
2524     int32_t value=canonValue&amp;CANON_VALUE_MASK;
2525     if((canonValue&amp;CANON_HAS_SET)!=0) {
2526         set.addAll(getCanonStartSet(value));
2527     } else if(value!=0) {
2528         set.add(value);
2529     }
2530     if((canonValue&amp;CANON_HAS_COMPOSITIONS)!=0) {
<span class="line-modified">2531         uint16_t norm16=getRawNorm16(c);</span>
2532         if(norm16==JAMO_L) {
2533             UChar32 syllable=
2534                 (UChar32)(Hangul::HANGUL_BASE+(c-Hangul::JAMO_L_BASE)*Hangul::JAMO_VT_COUNT);
2535             set.add(syllable, syllable+Hangul::JAMO_VT_COUNT-1);
2536         } else {
2537             addComposites(getCompositionsList(norm16), set);
2538         }
2539     }
2540     return TRUE;
2541 }
2542 
2543 U_NAMESPACE_END
2544 
2545 // Normalizer2 data swapping ----------------------------------------------- ***
2546 
2547 U_NAMESPACE_USE
2548 
2549 U_CAPI int32_t U_EXPORT2
2550 unorm2_swap(const UDataSwapper *ds,
2551             const void *inData, int32_t length, void *outData,
</pre>
<hr />
<pre>
2558 
2559     const int32_t *inIndexes;
2560     int32_t indexes[Normalizer2Impl::IX_TOTAL_SIZE+1];
2561 
2562     int32_t i, offset, nextOffset, size;
2563 
2564     /* udata_swapDataHeader checks the arguments */
2565     headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
2566     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
2567         return 0;
2568     }
2569 
2570     /* check data format and format version */
2571     pInfo=(const UDataInfo *)((const char *)inData+4);
2572     uint8_t formatVersion0=pInfo-&gt;formatVersion[0];
2573     if(!(
2574         pInfo-&gt;dataFormat[0]==0x4e &amp;&amp;   /* dataFormat=&quot;Nrm2&quot; */
2575         pInfo-&gt;dataFormat[1]==0x72 &amp;&amp;
2576         pInfo-&gt;dataFormat[2]==0x6d &amp;&amp;
2577         pInfo-&gt;dataFormat[3]==0x32 &amp;&amp;
<span class="line-modified">2578         (1&lt;=formatVersion0 &amp;&amp; formatVersion0&lt;=4)</span>
2579     )) {
2580         udata_printError(ds, &quot;unorm2_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as Normalizer2 data\n&quot;,
2581                          pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
2582                          pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
2583                          pInfo-&gt;formatVersion[0]);
2584         *pErrorCode=U_UNSUPPORTED_ERROR;
2585         return 0;
2586     }
2587 
2588     inBytes=(const uint8_t *)inData+headerSize;
2589     outBytes=(uint8_t *)outData+headerSize;
2590 
2591     inIndexes=(const int32_t *)inBytes;
2592     int32_t minIndexesLength;
2593     if(formatVersion0==1) {
2594         minIndexesLength=Normalizer2Impl::IX_MIN_MAYBE_YES+1;
2595     } else if(formatVersion0==2) {
2596         minIndexesLength=Normalizer2Impl::IX_MIN_YES_NO_MAPPINGS_ONLY+1;
2597     } else {
2598         minIndexesLength=Normalizer2Impl::IX_MIN_LCCC_CP+1;
</pre>
<hr />
<pre>
2619     if(length&gt;=0) {
2620         if(length&lt;size) {
2621             udata_printError(ds, &quot;unorm2_swap(): too few bytes (%d after header) for all of Normalizer2 data\n&quot;,
2622                              length);
2623             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
2624             return 0;
2625         }
2626 
2627         /* copy the data for inaccessible bytes */
2628         if(inBytes!=outBytes) {
2629             uprv_memcpy(outBytes, inBytes, size);
2630         }
2631 
2632         offset=0;
2633 
2634         /* swap the int32_t indexes[] */
2635         nextOffset=indexes[Normalizer2Impl::IX_NORM_TRIE_OFFSET];
2636         ds-&gt;swapArray32(ds, inBytes, nextOffset-offset, outBytes, pErrorCode);
2637         offset=nextOffset;
2638 
<span class="line-modified">2639         /* swap the trie */</span>
2640         nextOffset=indexes[Normalizer2Impl::IX_EXTRA_DATA_OFFSET];
<span class="line-modified">2641         utrie_swapAnyVersion(ds, inBytes+offset, nextOffset-offset, outBytes+offset, pErrorCode);</span>
2642         offset=nextOffset;
2643 
2644         /* swap the uint16_t extraData[] */
2645         nextOffset=indexes[Normalizer2Impl::IX_SMALL_FCD_OFFSET];
2646         ds-&gt;swapArray16(ds, inBytes+offset, nextOffset-offset, outBytes+offset, pErrorCode);
2647         offset=nextOffset;
2648 
2649         /* no need to swap the uint8_t smallFCD[] (new in formatVersion 2) */
2650         nextOffset=indexes[Normalizer2Impl::IX_SMALL_FCD_OFFSET+1];
2651         offset=nextOffset;
2652 
2653         U_ASSERT(offset==size);
2654     }
2655 
2656     return headerSize+size;
2657 }
2658 
2659 #endif  // !UCONFIG_NO_NORMALIZATION
</pre>
</td>
</tr>
</table>
<center><a href="normalizer2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="normalizer2impl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>