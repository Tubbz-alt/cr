<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/locid.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="locdspnm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="loclikely.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/locid.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14 *
  15 *   Date        Name        Description
  16 *   02/11/97    aliu        Changed gLocPath to fgDataDirectory and added
  17 *                           methods to get and set it.
  18 *   04/02/97    aliu        Made operator!= inline; fixed return value
  19 *                           of getName().
  20 *   04/15/97    aliu        Cleanup for AIX/Win32.
  21 *   04/24/97    aliu        Numerous changes per code review.
  22 *   08/18/98    stephen     Changed getDisplayName()
  23 *                           Added SIMPLIFIED_CHINESE, TRADITIONAL_CHINESE
  24 *                           Added getISOCountries(), getISOLanguages(),
  25 *                           getLanguagesForCountry()
  26 *   03/16/99    bertrand    rehaul.
  27 *   07/21/99    stephen     Added U_CFUNC setDefault
  28 *   11/09/99    weiv        Added const char * getName() const;
  29 *   04/12/00    srl         removing unicodestring api&#39;s and cached hash code
  30 *   08/10/01    grhoten     Change the static Locales to accessor functions
  31 ******************************************************************************
  32 */
  33 

  34 

  35 #include &quot;unicode/locid.h&quot;
  36 #include &quot;unicode/strenum.h&quot;

  37 #include &quot;unicode/uloc.h&quot;
  38 #include &quot;putilimp.h&quot;
  39 #include &quot;mutex.h&quot;
  40 #include &quot;umutex.h&quot;
  41 #include &quot;uassert.h&quot;
  42 #include &quot;cmemory.h&quot;
  43 #include &quot;cstring.h&quot;
  44 #include &quot;uassert.h&quot;
  45 #include &quot;uhash.h&quot;

  46 #include &quot;ucln_cmn.h&quot;
  47 #include &quot;ustr_imp.h&quot;
  48 #include &quot;charstr.h&quot;

  49 
  50 U_CDECL_BEGIN
  51 static UBool U_CALLCONV locale_cleanup(void);
  52 U_CDECL_END
  53 
  54 U_NAMESPACE_BEGIN
  55 
  56 static Locale   *gLocaleCache = NULL;
  57 static UInitOnce gLocaleCacheInitOnce = U_INITONCE_INITIALIZER;
  58 
  59 // gDefaultLocaleMutex protects all access to gDefaultLocalesHashT and gDefaultLocale.
<span class="line-modified">  60 static UMutex gDefaultLocaleMutex = U_MUTEX_INITIALIZER;</span>



  61 static UHashtable *gDefaultLocalesHashT = NULL;
  62 static Locale *gDefaultLocale = NULL;
  63 
  64 /**
  65  * \def ULOC_STRING_LIMIT
  66  * strings beyond this value crash in CharString
  67  */
  68 #define ULOC_STRING_LIMIT 357913941
  69 
  70 U_NAMESPACE_END
  71 
  72 typedef enum ELocalePos {
  73     eENGLISH,
  74     eFRENCH,
  75     eGERMAN,
  76     eITALIAN,
  77     eJAPANESE,
  78     eKOREAN,
  79     eCHINESE,
  80 
</pre>
<hr />
<pre>
 149     gLocaleCache[eCHINESE]       = Locale(&quot;zh&quot;);
 150     gLocaleCache[eFRANCE]        = Locale(&quot;fr&quot;, &quot;FR&quot;);
 151     gLocaleCache[eGERMANY]       = Locale(&quot;de&quot;, &quot;DE&quot;);
 152     gLocaleCache[eITALY]         = Locale(&quot;it&quot;, &quot;IT&quot;);
 153     gLocaleCache[eJAPAN]         = Locale(&quot;ja&quot;, &quot;JP&quot;);
 154     gLocaleCache[eKOREA]         = Locale(&quot;ko&quot;, &quot;KR&quot;);
 155     gLocaleCache[eCHINA]         = Locale(&quot;zh&quot;, &quot;CN&quot;);
 156     gLocaleCache[eTAIWAN]        = Locale(&quot;zh&quot;, &quot;TW&quot;);
 157     gLocaleCache[eUK]            = Locale(&quot;en&quot;, &quot;GB&quot;);
 158     gLocaleCache[eUS]            = Locale(&quot;en&quot;, &quot;US&quot;);
 159     gLocaleCache[eCANADA]        = Locale(&quot;en&quot;, &quot;CA&quot;);
 160     gLocaleCache[eCANADA_FRENCH] = Locale(&quot;fr&quot;, &quot;CA&quot;);
 161 }
 162 
 163 U_CDECL_END
 164 
 165 U_NAMESPACE_BEGIN
 166 
 167 Locale *locale_set_default_internal(const char *id, UErrorCode&amp; status) {
 168     // Synchronize this entire function.
<span class="line-modified"> 169     Mutex lock(&amp;gDefaultLocaleMutex);</span>
 170 
 171     UBool canonicalize = FALSE;
 172 
 173     // If given a NULL string for the locale id, grab the default
 174     //   name from the system.
 175     //   (Different from most other locale APIs, where a null name means use
 176     //    the current ICU default locale.)
 177     if (id == NULL) {
 178         id = uprv_getDefaultLocaleID();   // This function not thread safe? TODO: verify.
 179         canonicalize = TRUE; // always canonicalize host ID
 180     }
 181 
 182     char localeNameBuf[512];
 183 
 184     if (canonicalize) {
 185         uloc_canonicalize(id, localeNameBuf, sizeof(localeNameBuf)-1, &amp;status);
 186     } else {
 187         uloc_getName(id, localeNameBuf, sizeof(localeNameBuf)-1, &amp;status);
 188     }
 189     localeNameBuf[sizeof(localeNameBuf)-1] = 0;  // Force null termination in event of
</pre>
<hr />
<pre>
 407             togo.append(newKeywords, status);
 408         }
 409 
 410         if (U_FAILURE(status)) {
 411             // Something went wrong with appending, etc.
 412             setToBogus();
 413             return;
 414         }
 415         // Parse it, because for example &#39;language&#39; might really be a complete
 416         // string.
 417         init(togo.data(), FALSE);
 418     }
 419 }
 420 
 421 Locale::Locale(const Locale &amp;other)
 422     : UObject(other), fullName(fullNameBuffer), baseName(NULL)
 423 {
 424     *this = other;
 425 }
 426 
<span class="line-modified"> 427 Locale &amp;Locale::operator=(const Locale &amp;other)</span>
<span class="line-modified"> 428 {</span>




 429     if (this == &amp;other) {
 430         return *this;
 431     }
 432 
<span class="line-modified"> 433     /* Free our current storage */</span>
<span class="line-modified"> 434     if (baseName != fullName) {</span>
<span class="line-modified"> 435         uprv_free(baseName);</span>






 436     }
<span class="line-modified"> 437     baseName = NULL;</span>
<span class="line-modified"> 438     if(fullName != fullNameBuffer) {</span>
<span class="line-modified"> 439         uprv_free(fullName);</span>
<span class="line-modified"> 440         fullName = fullNameBuffer;</span>


 441     }
 442 
<span class="line-modified"> 443     /* Allocate the full name if necessary */</span>
<span class="line-modified"> 444     if(other.fullName != other.fullNameBuffer) {</span>
<span class="line-modified"> 445         fullName = (char *)uprv_malloc(sizeof(char)*(uprv_strlen(other.fullName)+1));</span>
<span class="line-modified"> 446         if (fullName == NULL) {</span>
<span class="line-modified"> 447             return *this;</span>
<span class="line-modified"> 448         }</span>













 449     }
<span class="line-removed"> 450     /* Copy the full name */</span>
<span class="line-removed"> 451     uprv_strcpy(fullName, other.fullName);</span>
 452 
<span class="line-removed"> 453     /* Copy the baseName if it differs from fullName. */</span>
 454     if (other.baseName == other.fullName) {
 455         baseName = fullName;
 456     } else {
<span class="line-modified"> 457         if (other.baseName) {</span>
<span class="line-removed"> 458             baseName = uprv_strdup(other.baseName);</span>
<span class="line-removed"> 459         }</span>
 460     }
 461 
<span class="line-removed"> 462     /* Copy the language and country fields */</span>
 463     uprv_strcpy(language, other.language);
 464     uprv_strcpy(script, other.script);
 465     uprv_strcpy(country, other.country);
 466 
<span class="line-removed"> 467     /* The variantBegin is an offset, just copy it */</span>
 468     variantBegin = other.variantBegin;
 469     fIsBogus = other.fIsBogus;



 470     return *this;
 471 }
 472 
 473 Locale *
 474 Locale::clone() const {
 475     return new Locale(*this);
 476 }
 477 
 478 UBool
 479 Locale::operator==( const   Locale&amp; other) const
 480 {
 481     return (uprv_strcmp(other.fullName, fullName) == 0);
 482 }
 483 
 484 #define ISASCIIALPHA(c) (((c) &gt;= &#39;a&#39; &amp;&amp; (c) &lt;= &#39;z&#39;) || ((c) &gt;= &#39;A&#39; &amp;&amp; (c) &lt;= &#39;Z&#39;))
 485 
 486 /*This function initializes a Locale from a C locale ID*/
 487 Locale&amp; Locale::init(const char* localeID, UBool canonicalize)
 488 {
 489     fIsBogus = FALSE;
</pre>
<hr />
<pre>
 526         if(err == U_BUFFER_OVERFLOW_ERROR || length &gt;= (int32_t)sizeof(fullNameBuffer)) {
 527             /*Go to heap for the fullName if necessary*/
 528             fullName = (char *)uprv_malloc(sizeof(char)*(length + 1));
 529             if(fullName == 0) {
 530                 fullName = fullNameBuffer;
 531                 break; // error: out of memory
 532             }
 533             err = U_ZERO_ERROR;
 534             length = canonicalize ?
 535                 uloc_canonicalize(localeID, fullName, length+1, &amp;err) :
 536                 uloc_getName(localeID, fullName, length+1, &amp;err);
 537         }
 538         if(U_FAILURE(err) || err == U_STRING_NOT_TERMINATED_WARNING) {
 539             /* should never occur */
 540             break;
 541         }
 542 
 543         variantBegin = length;
 544 
 545         /* after uloc_getName/canonicalize() we know that only &#39;_&#39; are separators */

 546         separator = field[0] = fullName;
 547         fieldIdx = 1;
<span class="line-modified"> 548         while ((separator = uprv_strchr(field[fieldIdx-1], SEP_CHAR)) &amp;&amp; fieldIdx &lt; UPRV_LENGTHOF(field)-1) {</span>



 549             field[fieldIdx] = separator + 1;
 550             fieldLen[fieldIdx-1] = (int32_t)(separator - field[fieldIdx-1]);
 551             fieldIdx++;
 552         }
 553         // variant may contain @foo or .foo POSIX cruft; remove it
 554         separator = uprv_strchr(field[fieldIdx-1], &#39;@&#39;);
 555         char* sep2 = uprv_strchr(field[fieldIdx-1], &#39;.&#39;);
 556         if (separator!=NULL || sep2!=NULL) {
 557             if (separator==NULL || (sep2!=NULL &amp;&amp; separator &gt; sep2)) {
 558                 separator = sep2;
 559             }
 560             fieldLen[fieldIdx-1] = (int32_t)(separator - field[fieldIdx-1]);
 561         } else {
 562             fieldLen[fieldIdx-1] = length - (int32_t)(field[fieldIdx-1] - fullName);
 563         }
 564 
 565         if (fieldLen[0] &gt;= (int32_t)(sizeof(language)))
 566         {
 567             break; // error: the language field is too long
 568         }
</pre>
<hr />
<pre>
 635             return;
 636         }
 637         uprv_strncpy(baseName, fullName, baseNameLength);
 638         baseName[baseNameLength] = 0;
 639 
 640         // The original computation of variantBegin leaves it equal to the length
 641         // of fullName if there is no variant.  It should instead be
 642         // the length of the baseName.
 643         if (variantBegin &gt; baseNameLength) {
 644             variantBegin = baseNameLength;
 645         }
 646     } else {
 647         baseName = fullName;
 648     }
 649 }
 650 
 651 
 652 int32_t
 653 Locale::hashCode() const
 654 {
<span class="line-modified"> 655     return ustr_hashCharsN(fullName, uprv_strlen(fullName));</span>
 656 }
 657 
 658 void
 659 Locale::setToBogus() {
 660     /* Free our current storage */
 661     if(baseName != fullName) {
 662         uprv_free(baseName);
 663     }
 664     baseName = NULL;
 665     if(fullName != fullNameBuffer) {
 666         uprv_free(fullName);
 667         fullName = fullNameBuffer;
 668     }
 669     *fullNameBuffer = 0;
 670     *language = 0;
 671     *script = 0;
 672     *country = 0;
 673     fIsBogus = TRUE;
 674     variantBegin = 0;
 675 }
 676 
 677 const Locale&amp; U_EXPORT2
 678 Locale::getDefault()
 679 {
 680     {
<span class="line-modified"> 681         Mutex lock(&amp;gDefaultLocaleMutex);</span>
 682         if (gDefaultLocale != NULL) {
 683             return *gDefaultLocale;
 684         }
 685     }
 686     UErrorCode status = U_ZERO_ERROR;
 687     return *locale_set_default_internal(NULL, status);
 688 }
 689 
 690 
 691 
 692 void U_EXPORT2
 693 Locale::setDefault( const   Locale&amp;     newLocale,
 694                             UErrorCode&amp;  status)
 695 {
 696     if (U_FAILURE(status)) {
 697         return;
 698     }
 699 
 700     /* Set the default from the full name string of the supplied locale.
 701      * This is a convenient way to access the default locale caching mechanisms.










































































































 707 Locale U_EXPORT2
 708 Locale::createFromName (const char *name)
 709 {
 710     if (name) {
 711         Locale l(&quot;&quot;);
 712         l.init(name, FALSE);
 713         return l;
 714     }
 715     else {
 716         return getDefault();
 717     }
 718 }
 719 
 720 Locale U_EXPORT2
 721 Locale::createCanonical(const char* name) {
 722     Locale loc(&quot;&quot;);
 723     loc.init(name, TRUE);
 724     return loc;
 725 }
 726 
</pre>
<hr />
<pre>
 993         return result;
 994     }
 995 
 996     virtual const UnicodeString* snext(UErrorCode&amp; status) {
 997         int32_t resultLength = 0;
 998         const char *s = next(&amp;resultLength, status);
 999         return setChars(s, resultLength, status);
1000     }
1001 
1002     virtual void reset(UErrorCode&amp; /*status*/) {
1003         current = keywords;
1004     }
1005 };
1006 
1007 const char KeywordEnumeration::fgClassID = &#39;\0&#39;;
1008 
1009 KeywordEnumeration::~KeywordEnumeration() {
1010     uprv_free(keywords);
1011 }
1012 




























1013 StringEnumeration *
1014 Locale::createKeywords(UErrorCode &amp;status) const
1015 {
1016     char keywords[256];
<span class="line-modified">1017     int32_t keywordCapacity = 256;</span>
1018     StringEnumeration *result = NULL;
1019 




1020     const char* variantStart = uprv_strchr(fullName, &#39;@&#39;);
1021     const char* assignment = uprv_strchr(fullName, &#39;=&#39;);
1022     if(variantStart) {
1023         if(assignment &gt; variantStart) {
1024             int32_t keyLen = locale_getKeywords(variantStart+1, &#39;@&#39;, keywords, keywordCapacity, NULL, 0, NULL, FALSE, &amp;status);
<span class="line-modified">1025             if(keyLen) {</span>
1026                 result = new KeywordEnumeration(keywords, keyLen, 0, status);
































1027             }
1028         } else {
1029             status = U_INVALID_FORMAT_ERROR;
1030         }
1031     }
1032     return result;
1033 }
1034 
1035 int32_t
1036 Locale::getKeywordValue(const char* keywordName, char *buffer, int32_t bufLen, UErrorCode &amp;status) const
1037 {
1038     return uloc_getKeywordValue(fullName, keywordName, buffer, bufLen, &amp;status);
1039 }
1040 



































































































1041 void
1042 Locale::setKeywordValue(const char* keywordName, const char* keywordValue, UErrorCode &amp;status)
1043 {
1044     uloc_setKeywordValue(keywordName, keywordValue, fullName, ULOC_FULLNAME_CAPACITY, &amp;status);
1045     if (U_SUCCESS(status) &amp;&amp; baseName == fullName) {
1046         // May have added the first keyword, meaning that the fullName is no longer also the baseName.
1047         initBaseName(status);
1048     }
1049 }
1050 












































1051 const char *
1052 Locale::getBaseName() const {
1053     return baseName;
1054 }
1055 
1056 //eof
1057 U_NAMESPACE_END
</pre>
</td>
<td>
<hr />
<pre>
  14 *
  15 *   Date        Name        Description
  16 *   02/11/97    aliu        Changed gLocPath to fgDataDirectory and added
  17 *                           methods to get and set it.
  18 *   04/02/97    aliu        Made operator!= inline; fixed return value
  19 *                           of getName().
  20 *   04/15/97    aliu        Cleanup for AIX/Win32.
  21 *   04/24/97    aliu        Numerous changes per code review.
  22 *   08/18/98    stephen     Changed getDisplayName()
  23 *                           Added SIMPLIFIED_CHINESE, TRADITIONAL_CHINESE
  24 *                           Added getISOCountries(), getISOLanguages(),
  25 *                           getLanguagesForCountry()
  26 *   03/16/99    bertrand    rehaul.
  27 *   07/21/99    stephen     Added U_CFUNC setDefault
  28 *   11/09/99    weiv        Added const char * getName() const;
  29 *   04/12/00    srl         removing unicodestring api&#39;s and cached hash code
  30 *   08/10/01    grhoten     Change the static Locales to accessor functions
  31 ******************************************************************************
  32 */
  33 
<span class="line-added">  34 #include &lt;utility&gt;</span>
  35 
<span class="line-added">  36 #include &quot;unicode/bytestream.h&quot;</span>
  37 #include &quot;unicode/locid.h&quot;
  38 #include &quot;unicode/strenum.h&quot;
<span class="line-added">  39 #include &quot;unicode/stringpiece.h&quot;</span>
  40 #include &quot;unicode/uloc.h&quot;
  41 #include &quot;putilimp.h&quot;
  42 #include &quot;mutex.h&quot;
  43 #include &quot;umutex.h&quot;
  44 #include &quot;uassert.h&quot;
  45 #include &quot;cmemory.h&quot;
  46 #include &quot;cstring.h&quot;
  47 #include &quot;uassert.h&quot;
  48 #include &quot;uhash.h&quot;
<span class="line-added">  49 #include &quot;ulocimp.h&quot;</span>
  50 #include &quot;ucln_cmn.h&quot;
  51 #include &quot;ustr_imp.h&quot;
  52 #include &quot;charstr.h&quot;
<span class="line-added">  53 #include &quot;bytesinkutil.h&quot;</span>
  54 
  55 U_CDECL_BEGIN
  56 static UBool U_CALLCONV locale_cleanup(void);
  57 U_CDECL_END
  58 
  59 U_NAMESPACE_BEGIN
  60 
  61 static Locale   *gLocaleCache = NULL;
  62 static UInitOnce gLocaleCacheInitOnce = U_INITONCE_INITIALIZER;
  63 
  64 // gDefaultLocaleMutex protects all access to gDefaultLocalesHashT and gDefaultLocale.
<span class="line-modified">  65 static UMutex *gDefaultLocaleMutex() {</span>
<span class="line-added">  66     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added">  67     return &amp;m;</span>
<span class="line-added">  68 }</span>
  69 static UHashtable *gDefaultLocalesHashT = NULL;
  70 static Locale *gDefaultLocale = NULL;
  71 
  72 /**
  73  * \def ULOC_STRING_LIMIT
  74  * strings beyond this value crash in CharString
  75  */
  76 #define ULOC_STRING_LIMIT 357913941
  77 
  78 U_NAMESPACE_END
  79 
  80 typedef enum ELocalePos {
  81     eENGLISH,
  82     eFRENCH,
  83     eGERMAN,
  84     eITALIAN,
  85     eJAPANESE,
  86     eKOREAN,
  87     eCHINESE,
  88 
</pre>
<hr />
<pre>
 157     gLocaleCache[eCHINESE]       = Locale(&quot;zh&quot;);
 158     gLocaleCache[eFRANCE]        = Locale(&quot;fr&quot;, &quot;FR&quot;);
 159     gLocaleCache[eGERMANY]       = Locale(&quot;de&quot;, &quot;DE&quot;);
 160     gLocaleCache[eITALY]         = Locale(&quot;it&quot;, &quot;IT&quot;);
 161     gLocaleCache[eJAPAN]         = Locale(&quot;ja&quot;, &quot;JP&quot;);
 162     gLocaleCache[eKOREA]         = Locale(&quot;ko&quot;, &quot;KR&quot;);
 163     gLocaleCache[eCHINA]         = Locale(&quot;zh&quot;, &quot;CN&quot;);
 164     gLocaleCache[eTAIWAN]        = Locale(&quot;zh&quot;, &quot;TW&quot;);
 165     gLocaleCache[eUK]            = Locale(&quot;en&quot;, &quot;GB&quot;);
 166     gLocaleCache[eUS]            = Locale(&quot;en&quot;, &quot;US&quot;);
 167     gLocaleCache[eCANADA]        = Locale(&quot;en&quot;, &quot;CA&quot;);
 168     gLocaleCache[eCANADA_FRENCH] = Locale(&quot;fr&quot;, &quot;CA&quot;);
 169 }
 170 
 171 U_CDECL_END
 172 
 173 U_NAMESPACE_BEGIN
 174 
 175 Locale *locale_set_default_internal(const char *id, UErrorCode&amp; status) {
 176     // Synchronize this entire function.
<span class="line-modified"> 177     Mutex lock(gDefaultLocaleMutex());</span>
 178 
 179     UBool canonicalize = FALSE;
 180 
 181     // If given a NULL string for the locale id, grab the default
 182     //   name from the system.
 183     //   (Different from most other locale APIs, where a null name means use
 184     //    the current ICU default locale.)
 185     if (id == NULL) {
 186         id = uprv_getDefaultLocaleID();   // This function not thread safe? TODO: verify.
 187         canonicalize = TRUE; // always canonicalize host ID
 188     }
 189 
 190     char localeNameBuf[512];
 191 
 192     if (canonicalize) {
 193         uloc_canonicalize(id, localeNameBuf, sizeof(localeNameBuf)-1, &amp;status);
 194     } else {
 195         uloc_getName(id, localeNameBuf, sizeof(localeNameBuf)-1, &amp;status);
 196     }
 197     localeNameBuf[sizeof(localeNameBuf)-1] = 0;  // Force null termination in event of
</pre>
<hr />
<pre>
 415             togo.append(newKeywords, status);
 416         }
 417 
 418         if (U_FAILURE(status)) {
 419             // Something went wrong with appending, etc.
 420             setToBogus();
 421             return;
 422         }
 423         // Parse it, because for example &#39;language&#39; might really be a complete
 424         // string.
 425         init(togo.data(), FALSE);
 426     }
 427 }
 428 
 429 Locale::Locale(const Locale &amp;other)
 430     : UObject(other), fullName(fullNameBuffer), baseName(NULL)
 431 {
 432     *this = other;
 433 }
 434 
<span class="line-modified"> 435 Locale::Locale(Locale&amp;&amp; other) U_NOEXCEPT</span>
<span class="line-modified"> 436     : UObject(other), fullName(fullNameBuffer), baseName(fullName) {</span>
<span class="line-added"> 437   *this = std::move(other);</span>
<span class="line-added"> 438 }</span>
<span class="line-added"> 439 </span>
<span class="line-added"> 440 Locale&amp; Locale::operator=(const Locale&amp; other) {</span>
 441     if (this == &amp;other) {
 442         return *this;
 443     }
 444 
<span class="line-modified"> 445     setToBogus();</span>
<span class="line-modified"> 446 </span>
<span class="line-modified"> 447     if (other.fullName == other.fullNameBuffer) {</span>
<span class="line-added"> 448         uprv_strcpy(fullNameBuffer, other.fullNameBuffer);</span>
<span class="line-added"> 449     } else if (other.fullName == nullptr) {</span>
<span class="line-added"> 450         fullName = nullptr;</span>
<span class="line-added"> 451     } else {</span>
<span class="line-added"> 452         fullName = uprv_strdup(other.fullName);</span>
<span class="line-added"> 453         if (fullName == nullptr) return *this;</span>
 454     }
<span class="line-modified"> 455 </span>
<span class="line-modified"> 456     if (other.baseName == other.fullName) {</span>
<span class="line-modified"> 457         baseName = fullName;</span>
<span class="line-modified"> 458     } else if (other.baseName != nullptr) {</span>
<span class="line-added"> 459         baseName = uprv_strdup(other.baseName);</span>
<span class="line-added"> 460         if (baseName == nullptr) return *this;</span>
 461     }
 462 
<span class="line-modified"> 463     uprv_strcpy(language, other.language);</span>
<span class="line-modified"> 464     uprv_strcpy(script, other.script);</span>
<span class="line-modified"> 465     uprv_strcpy(country, other.country);</span>
<span class="line-modified"> 466 </span>
<span class="line-modified"> 467     variantBegin = other.variantBegin;</span>
<span class="line-modified"> 468     fIsBogus = other.fIsBogus;</span>
<span class="line-added"> 469 </span>
<span class="line-added"> 470     return *this;</span>
<span class="line-added"> 471 }</span>
<span class="line-added"> 472 </span>
<span class="line-added"> 473 Locale&amp; Locale::operator=(Locale&amp;&amp; other) U_NOEXCEPT {</span>
<span class="line-added"> 474     if (baseName != fullName) uprv_free(baseName);</span>
<span class="line-added"> 475     if (fullName != fullNameBuffer) uprv_free(fullName);</span>
<span class="line-added"> 476 </span>
<span class="line-added"> 477     if (other.fullName == other.fullNameBuffer) {</span>
<span class="line-added"> 478         uprv_strcpy(fullNameBuffer, other.fullNameBuffer);</span>
<span class="line-added"> 479         fullName = fullNameBuffer;</span>
<span class="line-added"> 480     } else {</span>
<span class="line-added"> 481         fullName = other.fullName;</span>
 482     }


 483 

 484     if (other.baseName == other.fullName) {
 485         baseName = fullName;
 486     } else {
<span class="line-modified"> 487         baseName = other.baseName;</span>


 488     }
 489 

 490     uprv_strcpy(language, other.language);
 491     uprv_strcpy(script, other.script);
 492     uprv_strcpy(country, other.country);
 493 

 494     variantBegin = other.variantBegin;
 495     fIsBogus = other.fIsBogus;
<span class="line-added"> 496 </span>
<span class="line-added"> 497     other.baseName = other.fullName = other.fullNameBuffer;</span>
<span class="line-added"> 498 </span>
 499     return *this;
 500 }
 501 
 502 Locale *
 503 Locale::clone() const {
 504     return new Locale(*this);
 505 }
 506 
 507 UBool
 508 Locale::operator==( const   Locale&amp; other) const
 509 {
 510     return (uprv_strcmp(other.fullName, fullName) == 0);
 511 }
 512 
 513 #define ISASCIIALPHA(c) (((c) &gt;= &#39;a&#39; &amp;&amp; (c) &lt;= &#39;z&#39;) || ((c) &gt;= &#39;A&#39; &amp;&amp; (c) &lt;= &#39;Z&#39;))
 514 
 515 /*This function initializes a Locale from a C locale ID*/
 516 Locale&amp; Locale::init(const char* localeID, UBool canonicalize)
 517 {
 518     fIsBogus = FALSE;
</pre>
<hr />
<pre>
 555         if(err == U_BUFFER_OVERFLOW_ERROR || length &gt;= (int32_t)sizeof(fullNameBuffer)) {
 556             /*Go to heap for the fullName if necessary*/
 557             fullName = (char *)uprv_malloc(sizeof(char)*(length + 1));
 558             if(fullName == 0) {
 559                 fullName = fullNameBuffer;
 560                 break; // error: out of memory
 561             }
 562             err = U_ZERO_ERROR;
 563             length = canonicalize ?
 564                 uloc_canonicalize(localeID, fullName, length+1, &amp;err) :
 565                 uloc_getName(localeID, fullName, length+1, &amp;err);
 566         }
 567         if(U_FAILURE(err) || err == U_STRING_NOT_TERMINATED_WARNING) {
 568             /* should never occur */
 569             break;
 570         }
 571 
 572         variantBegin = length;
 573 
 574         /* after uloc_getName/canonicalize() we know that only &#39;_&#39; are separators */
<span class="line-added"> 575         /* But _ could also appeared in timezone such as &quot;en@timezone=America/Los_Angeles&quot; */</span>
 576         separator = field[0] = fullName;
 577         fieldIdx = 1;
<span class="line-modified"> 578         char* at = uprv_strchr(fullName, &#39;@&#39;);</span>
<span class="line-added"> 579         while ((separator = uprv_strchr(field[fieldIdx-1], SEP_CHAR)) != 0 &amp;&amp;</span>
<span class="line-added"> 580                fieldIdx &lt; UPRV_LENGTHOF(field)-1 &amp;&amp;</span>
<span class="line-added"> 581                (at == nullptr || separator &lt; at)) {</span>
 582             field[fieldIdx] = separator + 1;
 583             fieldLen[fieldIdx-1] = (int32_t)(separator - field[fieldIdx-1]);
 584             fieldIdx++;
 585         }
 586         // variant may contain @foo or .foo POSIX cruft; remove it
 587         separator = uprv_strchr(field[fieldIdx-1], &#39;@&#39;);
 588         char* sep2 = uprv_strchr(field[fieldIdx-1], &#39;.&#39;);
 589         if (separator!=NULL || sep2!=NULL) {
 590             if (separator==NULL || (sep2!=NULL &amp;&amp; separator &gt; sep2)) {
 591                 separator = sep2;
 592             }
 593             fieldLen[fieldIdx-1] = (int32_t)(separator - field[fieldIdx-1]);
 594         } else {
 595             fieldLen[fieldIdx-1] = length - (int32_t)(field[fieldIdx-1] - fullName);
 596         }
 597 
 598         if (fieldLen[0] &gt;= (int32_t)(sizeof(language)))
 599         {
 600             break; // error: the language field is too long
 601         }
</pre>
<hr />
<pre>
 668             return;
 669         }
 670         uprv_strncpy(baseName, fullName, baseNameLength);
 671         baseName[baseNameLength] = 0;
 672 
 673         // The original computation of variantBegin leaves it equal to the length
 674         // of fullName if there is no variant.  It should instead be
 675         // the length of the baseName.
 676         if (variantBegin &gt; baseNameLength) {
 677             variantBegin = baseNameLength;
 678         }
 679     } else {
 680         baseName = fullName;
 681     }
 682 }
 683 
 684 
 685 int32_t
 686 Locale::hashCode() const
 687 {
<span class="line-modified"> 688     return ustr_hashCharsN(fullName, static_cast&lt;int32_t&gt;(uprv_strlen(fullName)));</span>
 689 }
 690 
 691 void
 692 Locale::setToBogus() {
 693     /* Free our current storage */
 694     if(baseName != fullName) {
 695         uprv_free(baseName);
 696     }
 697     baseName = NULL;
 698     if(fullName != fullNameBuffer) {
 699         uprv_free(fullName);
 700         fullName = fullNameBuffer;
 701     }
 702     *fullNameBuffer = 0;
 703     *language = 0;
 704     *script = 0;
 705     *country = 0;
 706     fIsBogus = TRUE;
 707     variantBegin = 0;
 708 }
 709 
 710 const Locale&amp; U_EXPORT2
 711 Locale::getDefault()
 712 {
 713     {
<span class="line-modified"> 714         Mutex lock(gDefaultLocaleMutex());</span>
 715         if (gDefaultLocale != NULL) {
 716             return *gDefaultLocale;
 717         }
 718     }
 719     UErrorCode status = U_ZERO_ERROR;
 720     return *locale_set_default_internal(NULL, status);
 721 }
 722 
 723 
 724 
 725 void U_EXPORT2
 726 Locale::setDefault( const   Locale&amp;     newLocale,
 727                             UErrorCode&amp;  status)
 728 {
 729     if (U_FAILURE(status)) {
 730         return;
 731     }
 732 
 733     /* Set the default from the full name string of the supplied locale.
 734      * This is a convenient way to access the default locale caching mechanisms.
<span class="line-added"> 740 void</span>
<span class="line-added"> 741 Locale::addLikelySubtags(UErrorCode&amp; status) {</span>
<span class="line-added"> 742     if (U_FAILURE(status)) {</span>
<span class="line-added"> 743         return;</span>
<span class="line-added"> 744     }</span>
<span class="line-added"> 745 </span>
<span class="line-added"> 746     CharString maximizedLocaleID;</span>
<span class="line-added"> 747     {</span>
<span class="line-added"> 748         CharStringByteSink sink(&amp;maximizedLocaleID);</span>
<span class="line-added"> 749         ulocimp_addLikelySubtags(fullName, sink, &amp;status);</span>
<span class="line-added"> 750     }</span>
<span class="line-added"> 751 </span>
<span class="line-added"> 752     if (U_FAILURE(status)) {</span>
<span class="line-added"> 753         return;</span>
<span class="line-added"> 754     }</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756     init(maximizedLocaleID.data(), /*canonicalize=*/FALSE);</span>
<span class="line-added"> 757     if (isBogus()) {</span>
<span class="line-added"> 758         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added"> 759     }</span>
<span class="line-added"> 760 }</span>
<span class="line-added"> 761 </span>
<span class="line-added"> 762 void</span>
<span class="line-added"> 763 Locale::minimizeSubtags(UErrorCode&amp; status) {</span>
<span class="line-added"> 764     if (U_FAILURE(status)) {</span>
<span class="line-added"> 765         return;</span>
<span class="line-added"> 766     }</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768     CharString minimizedLocaleID;</span>
<span class="line-added"> 769     {</span>
<span class="line-added"> 770         CharStringByteSink sink(&amp;minimizedLocaleID);</span>
<span class="line-added"> 771         ulocimp_minimizeSubtags(fullName, sink, &amp;status);</span>
<span class="line-added"> 772     }</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774     if (U_FAILURE(status)) {</span>
<span class="line-added"> 775         return;</span>
<span class="line-added"> 776     }</span>
<span class="line-added"> 777 </span>
<span class="line-added"> 778     init(minimizedLocaleID.data(), /*canonicalize=*/FALSE);</span>
<span class="line-added"> 779     if (isBogus()) {</span>
<span class="line-added"> 780         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added"> 781     }</span>
<span class="line-added"> 782 }</span>
<span class="line-added"> 783 </span>
<span class="line-added"> 784 Locale U_EXPORT2</span>
<span class="line-added"> 785 Locale::forLanguageTag(StringPiece tag, UErrorCode&amp; status)</span>
<span class="line-added"> 786 {</span>
<span class="line-added"> 787     Locale result(Locale::eBOGUS);</span>
<span class="line-added"> 788 </span>
<span class="line-added"> 789     if (U_FAILURE(status)) {</span>
<span class="line-added"> 790         return result;</span>
<span class="line-added"> 791     }</span>
<span class="line-added"> 792 </span>
<span class="line-added"> 793     // If a BCP-47 language tag is passed as the language parameter to the</span>
<span class="line-added"> 794     // normal Locale constructor, it will actually fall back to invoking</span>
<span class="line-added"> 795     // uloc_forLanguageTag() to parse it if it somehow is able to detect that</span>
<span class="line-added"> 796     // the string actually is BCP-47. This works well for things like strings</span>
<span class="line-added"> 797     // using BCP-47 extensions, but it does not at all work for things like</span>
<span class="line-added"> 798     // BCP-47 grandfathered tags (eg. &quot;en-GB-oed&quot;) which are possible to also</span>
<span class="line-added"> 799     // interpret as ICU locale IDs and because of that won&#39;t trigger the BCP-47</span>
<span class="line-added"> 800     // parsing. Therefore the code here explicitly calls uloc_forLanguageTag()</span>
<span class="line-added"> 801     // and then Locale::init(), instead of just calling the normal constructor.</span>
<span class="line-added"> 802 </span>
<span class="line-added"> 803     CharString localeID;</span>
<span class="line-added"> 804     int32_t parsedLength;</span>
<span class="line-added"> 805     {</span>
<span class="line-added"> 806         CharStringByteSink sink(&amp;localeID);</span>
<span class="line-added"> 807         ulocimp_forLanguageTag(</span>
<span class="line-added"> 808                 tag.data(),</span>
<span class="line-added"> 809                 tag.length(),</span>
<span class="line-added"> 810                 sink,</span>
<span class="line-added"> 811                 &amp;parsedLength,</span>
<span class="line-added"> 812                 &amp;status);</span>
<span class="line-added"> 813     }</span>
<span class="line-added"> 814 </span>
<span class="line-added"> 815     if (U_FAILURE(status)) {</span>
<span class="line-added"> 816         return result;</span>
<span class="line-added"> 817     }</span>
<span class="line-added"> 818 </span>
<span class="line-added"> 819     if (parsedLength != tag.size()) {</span>
<span class="line-added"> 820         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added"> 821         return result;</span>
<span class="line-added"> 822     }</span>
<span class="line-added"> 823 </span>
<span class="line-added"> 824     result.init(localeID.data(), /*canonicalize=*/FALSE);</span>
<span class="line-added"> 825     if (result.isBogus()) {</span>
<span class="line-added"> 826         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added"> 827     }</span>
<span class="line-added"> 828     return result;</span>
<span class="line-added"> 829 }</span>
<span class="line-added"> 830 </span>
<span class="line-added"> 831 void</span>
<span class="line-added"> 832 Locale::toLanguageTag(ByteSink&amp; sink, UErrorCode&amp; status) const</span>
<span class="line-added"> 833 {</span>
<span class="line-added"> 834     if (U_FAILURE(status)) {</span>
<span class="line-added"> 835         return;</span>
<span class="line-added"> 836     }</span>
<span class="line-added"> 837 </span>
<span class="line-added"> 838     if (fIsBogus) {</span>
<span class="line-added"> 839         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added"> 840         return;</span>
<span class="line-added"> 841     }</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843     ulocimp_toLanguageTag(fullName, sink, /*strict=*/FALSE, &amp;status);</span>
<span class="line-added"> 844 }</span>
<span class="line-added"> 845 </span>
 846 Locale U_EXPORT2
 847 Locale::createFromName (const char *name)
 848 {
 849     if (name) {
 850         Locale l(&quot;&quot;);
 851         l.init(name, FALSE);
 852         return l;
 853     }
 854     else {
 855         return getDefault();
 856     }
 857 }
 858 
 859 Locale U_EXPORT2
 860 Locale::createCanonical(const char* name) {
 861     Locale loc(&quot;&quot;);
 862     loc.init(name, TRUE);
 863     return loc;
 864 }
 865 
</pre>
<hr />
<pre>
1132         return result;
1133     }
1134 
1135     virtual const UnicodeString* snext(UErrorCode&amp; status) {
1136         int32_t resultLength = 0;
1137         const char *s = next(&amp;resultLength, status);
1138         return setChars(s, resultLength, status);
1139     }
1140 
1141     virtual void reset(UErrorCode&amp; /*status*/) {
1142         current = keywords;
1143     }
1144 };
1145 
1146 const char KeywordEnumeration::fgClassID = &#39;\0&#39;;
1147 
1148 KeywordEnumeration::~KeywordEnumeration() {
1149     uprv_free(keywords);
1150 }
1151 
<span class="line-added">1152 // A wrapper around KeywordEnumeration that calls uloc_toUnicodeLocaleKey() in</span>
<span class="line-added">1153 // the next() method for each keyword before returning it.</span>
<span class="line-added">1154 class UnicodeKeywordEnumeration : public KeywordEnumeration {</span>
<span class="line-added">1155 public:</span>
<span class="line-added">1156     using KeywordEnumeration::KeywordEnumeration;</span>
<span class="line-added">1157     virtual ~UnicodeKeywordEnumeration();</span>
<span class="line-added">1158 </span>
<span class="line-added">1159     virtual const char* next(int32_t* resultLength, UErrorCode&amp; status) {</span>
<span class="line-added">1160         const char* legacy_key = KeywordEnumeration::next(nullptr, status);</span>
<span class="line-added">1161         if (U_SUCCESS(status) &amp;&amp; legacy_key != nullptr) {</span>
<span class="line-added">1162             const char* key = uloc_toUnicodeLocaleKey(legacy_key);</span>
<span class="line-added">1163             if (key == nullptr) {</span>
<span class="line-added">1164                 status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1165             } else {</span>
<span class="line-added">1166                 if (resultLength != nullptr) {</span>
<span class="line-added">1167                     *resultLength = static_cast&lt;int32_t&gt;(uprv_strlen(key));</span>
<span class="line-added">1168                 }</span>
<span class="line-added">1169                 return key;</span>
<span class="line-added">1170             }</span>
<span class="line-added">1171         }</span>
<span class="line-added">1172         if (resultLength != nullptr) *resultLength = 0;</span>
<span class="line-added">1173         return nullptr;</span>
<span class="line-added">1174     }</span>
<span class="line-added">1175 };</span>
<span class="line-added">1176 </span>
<span class="line-added">1177 // Out-of-line virtual destructor to serve as the &quot;key function&quot;.</span>
<span class="line-added">1178 UnicodeKeywordEnumeration::~UnicodeKeywordEnumeration() = default;</span>
<span class="line-added">1179 </span>
1180 StringEnumeration *
1181 Locale::createKeywords(UErrorCode &amp;status) const
1182 {
1183     char keywords[256];
<span class="line-modified">1184     int32_t keywordCapacity = sizeof keywords;</span>
1185     StringEnumeration *result = NULL;
1186 
<span class="line-added">1187     if (U_FAILURE(status)) {</span>
<span class="line-added">1188         return result;</span>
<span class="line-added">1189     }</span>
<span class="line-added">1190 </span>
1191     const char* variantStart = uprv_strchr(fullName, &#39;@&#39;);
1192     const char* assignment = uprv_strchr(fullName, &#39;=&#39;);
1193     if(variantStart) {
1194         if(assignment &gt; variantStart) {
1195             int32_t keyLen = locale_getKeywords(variantStart+1, &#39;@&#39;, keywords, keywordCapacity, NULL, 0, NULL, FALSE, &amp;status);
<span class="line-modified">1196             if(U_SUCCESS(status) &amp;&amp; keyLen) {</span>
1197                 result = new KeywordEnumeration(keywords, keyLen, 0, status);
<span class="line-added">1198                 if (!result) {</span>
<span class="line-added">1199                     status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1200                 }</span>
<span class="line-added">1201             }</span>
<span class="line-added">1202         } else {</span>
<span class="line-added">1203             status = U_INVALID_FORMAT_ERROR;</span>
<span class="line-added">1204         }</span>
<span class="line-added">1205     }</span>
<span class="line-added">1206     return result;</span>
<span class="line-added">1207 }</span>
<span class="line-added">1208 </span>
<span class="line-added">1209 StringEnumeration *</span>
<span class="line-added">1210 Locale::createUnicodeKeywords(UErrorCode &amp;status) const</span>
<span class="line-added">1211 {</span>
<span class="line-added">1212     char keywords[256];</span>
<span class="line-added">1213     int32_t keywordCapacity = sizeof keywords;</span>
<span class="line-added">1214     StringEnumeration *result = NULL;</span>
<span class="line-added">1215 </span>
<span class="line-added">1216     if (U_FAILURE(status)) {</span>
<span class="line-added">1217         return result;</span>
<span class="line-added">1218     }</span>
<span class="line-added">1219 </span>
<span class="line-added">1220     const char* variantStart = uprv_strchr(fullName, &#39;@&#39;);</span>
<span class="line-added">1221     const char* assignment = uprv_strchr(fullName, &#39;=&#39;);</span>
<span class="line-added">1222     if(variantStart) {</span>
<span class="line-added">1223         if(assignment &gt; variantStart) {</span>
<span class="line-added">1224             int32_t keyLen = locale_getKeywords(variantStart+1, &#39;@&#39;, keywords, keywordCapacity, NULL, 0, NULL, FALSE, &amp;status);</span>
<span class="line-added">1225             if(U_SUCCESS(status) &amp;&amp; keyLen) {</span>
<span class="line-added">1226                 result = new UnicodeKeywordEnumeration(keywords, keyLen, 0, status);</span>
<span class="line-added">1227                 if (!result) {</span>
<span class="line-added">1228                     status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1229                 }</span>
1230             }
1231         } else {
1232             status = U_INVALID_FORMAT_ERROR;
1233         }
1234     }
1235     return result;
1236 }
1237 
1238 int32_t
1239 Locale::getKeywordValue(const char* keywordName, char *buffer, int32_t bufLen, UErrorCode &amp;status) const
1240 {
1241     return uloc_getKeywordValue(fullName, keywordName, buffer, bufLen, &amp;status);
1242 }
1243 
<span class="line-added">1244 void</span>
<span class="line-added">1245 Locale::getKeywordValue(StringPiece keywordName, ByteSink&amp; sink, UErrorCode&amp; status) const {</span>
<span class="line-added">1246     if (U_FAILURE(status)) {</span>
<span class="line-added">1247         return;</span>
<span class="line-added">1248     }</span>
<span class="line-added">1249 </span>
<span class="line-added">1250     if (fIsBogus) {</span>
<span class="line-added">1251         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1252         return;</span>
<span class="line-added">1253     }</span>
<span class="line-added">1254 </span>
<span class="line-added">1255     // TODO: Remove the need for a const char* to a NUL terminated buffer.</span>
<span class="line-added">1256     const CharString keywordName_nul(keywordName, status);</span>
<span class="line-added">1257     if (U_FAILURE(status)) {</span>
<span class="line-added">1258         return;</span>
<span class="line-added">1259     }</span>
<span class="line-added">1260 </span>
<span class="line-added">1261     LocalMemory&lt;char&gt; scratch;</span>
<span class="line-added">1262     int32_t scratch_capacity = 16;  // Arbitrarily chosen default size.</span>
<span class="line-added">1263 </span>
<span class="line-added">1264     char* buffer;</span>
<span class="line-added">1265     int32_t result_capacity, reslen;</span>
<span class="line-added">1266 </span>
<span class="line-added">1267     for (;;) {</span>
<span class="line-added">1268         if (scratch.allocateInsteadAndReset(scratch_capacity) == nullptr) {</span>
<span class="line-added">1269             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1270             return;</span>
<span class="line-added">1271         }</span>
<span class="line-added">1272 </span>
<span class="line-added">1273         buffer = sink.GetAppendBuffer(</span>
<span class="line-added">1274                 /*min_capacity=*/scratch_capacity,</span>
<span class="line-added">1275                 /*desired_capacity_hint=*/scratch_capacity,</span>
<span class="line-added">1276                 scratch.getAlias(),</span>
<span class="line-added">1277                 scratch_capacity,</span>
<span class="line-added">1278                 &amp;result_capacity);</span>
<span class="line-added">1279 </span>
<span class="line-added">1280         reslen = uloc_getKeywordValue(</span>
<span class="line-added">1281                 fullName,</span>
<span class="line-added">1282                 keywordName_nul.data(),</span>
<span class="line-added">1283                 buffer,</span>
<span class="line-added">1284                 result_capacity,</span>
<span class="line-added">1285                 &amp;status);</span>
<span class="line-added">1286 </span>
<span class="line-added">1287         if (status != U_BUFFER_OVERFLOW_ERROR) {</span>
<span class="line-added">1288             break;</span>
<span class="line-added">1289         }</span>
<span class="line-added">1290 </span>
<span class="line-added">1291         scratch_capacity = reslen;</span>
<span class="line-added">1292         status = U_ZERO_ERROR;</span>
<span class="line-added">1293     }</span>
<span class="line-added">1294 </span>
<span class="line-added">1295     if (U_FAILURE(status)) {</span>
<span class="line-added">1296         return;</span>
<span class="line-added">1297     }</span>
<span class="line-added">1298 </span>
<span class="line-added">1299     sink.Append(buffer, reslen);</span>
<span class="line-added">1300     if (status == U_STRING_NOT_TERMINATED_WARNING) {</span>
<span class="line-added">1301         status = U_ZERO_ERROR;  // Terminators not used.</span>
<span class="line-added">1302     }</span>
<span class="line-added">1303 }</span>
<span class="line-added">1304 </span>
<span class="line-added">1305 void</span>
<span class="line-added">1306 Locale::getUnicodeKeywordValue(StringPiece keywordName,</span>
<span class="line-added">1307                                ByteSink&amp; sink,</span>
<span class="line-added">1308                                UErrorCode&amp; status) const {</span>
<span class="line-added">1309     // TODO: Remove the need for a const char* to a NUL terminated buffer.</span>
<span class="line-added">1310     const CharString keywordName_nul(keywordName, status);</span>
<span class="line-added">1311     if (U_FAILURE(status)) {</span>
<span class="line-added">1312         return;</span>
<span class="line-added">1313     }</span>
<span class="line-added">1314 </span>
<span class="line-added">1315     const char* legacy_key = uloc_toLegacyKey(keywordName_nul.data());</span>
<span class="line-added">1316 </span>
<span class="line-added">1317     if (legacy_key == nullptr) {</span>
<span class="line-added">1318         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1319         return;</span>
<span class="line-added">1320     }</span>
<span class="line-added">1321 </span>
<span class="line-added">1322     CharString legacy_value;</span>
<span class="line-added">1323     {</span>
<span class="line-added">1324         CharStringByteSink sink(&amp;legacy_value);</span>
<span class="line-added">1325         getKeywordValue(legacy_key, sink, status);</span>
<span class="line-added">1326     }</span>
<span class="line-added">1327 </span>
<span class="line-added">1328     if (U_FAILURE(status)) {</span>
<span class="line-added">1329         return;</span>
<span class="line-added">1330     }</span>
<span class="line-added">1331 </span>
<span class="line-added">1332     const char* unicode_value = uloc_toUnicodeLocaleType(</span>
<span class="line-added">1333             keywordName_nul.data(), legacy_value.data());</span>
<span class="line-added">1334 </span>
<span class="line-added">1335     if (unicode_value == nullptr) {</span>
<span class="line-added">1336         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1337         return;</span>
<span class="line-added">1338     }</span>
<span class="line-added">1339 </span>
<span class="line-added">1340     sink.Append(unicode_value, static_cast&lt;int32_t&gt;(uprv_strlen(unicode_value)));</span>
<span class="line-added">1341 }</span>
<span class="line-added">1342 </span>
1343 void
1344 Locale::setKeywordValue(const char* keywordName, const char* keywordValue, UErrorCode &amp;status)
1345 {
1346     uloc_setKeywordValue(keywordName, keywordValue, fullName, ULOC_FULLNAME_CAPACITY, &amp;status);
1347     if (U_SUCCESS(status) &amp;&amp; baseName == fullName) {
1348         // May have added the first keyword, meaning that the fullName is no longer also the baseName.
1349         initBaseName(status);
1350     }
1351 }
1352 
<span class="line-added">1353 void</span>
<span class="line-added">1354 Locale::setKeywordValue(StringPiece keywordName,</span>
<span class="line-added">1355                         StringPiece keywordValue,</span>
<span class="line-added">1356                         UErrorCode&amp; status) {</span>
<span class="line-added">1357     // TODO: Remove the need for a const char* to a NUL terminated buffer.</span>
<span class="line-added">1358     const CharString keywordName_nul(keywordName, status);</span>
<span class="line-added">1359     const CharString keywordValue_nul(keywordValue, status);</span>
<span class="line-added">1360     setKeywordValue(keywordName_nul.data(), keywordValue_nul.data(), status);</span>
<span class="line-added">1361 }</span>
<span class="line-added">1362 </span>
<span class="line-added">1363 void</span>
<span class="line-added">1364 Locale::setUnicodeKeywordValue(StringPiece keywordName,</span>
<span class="line-added">1365                                StringPiece keywordValue,</span>
<span class="line-added">1366                                UErrorCode&amp; status) {</span>
<span class="line-added">1367     // TODO: Remove the need for a const char* to a NUL terminated buffer.</span>
<span class="line-added">1368     const CharString keywordName_nul(keywordName, status);</span>
<span class="line-added">1369     const CharString keywordValue_nul(keywordValue, status);</span>
<span class="line-added">1370 </span>
<span class="line-added">1371     if (U_FAILURE(status)) {</span>
<span class="line-added">1372         return;</span>
<span class="line-added">1373     }</span>
<span class="line-added">1374 </span>
<span class="line-added">1375     const char* legacy_key = uloc_toLegacyKey(keywordName_nul.data());</span>
<span class="line-added">1376 </span>
<span class="line-added">1377     if (legacy_key == nullptr) {</span>
<span class="line-added">1378         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1379         return;</span>
<span class="line-added">1380     }</span>
<span class="line-added">1381 </span>
<span class="line-added">1382     const char* legacy_value = nullptr;</span>
<span class="line-added">1383 </span>
<span class="line-added">1384     if (!keywordValue_nul.isEmpty()) {</span>
<span class="line-added">1385         legacy_value =</span>
<span class="line-added">1386             uloc_toLegacyType(keywordName_nul.data(), keywordValue_nul.data());</span>
<span class="line-added">1387 </span>
<span class="line-added">1388         if (legacy_value == nullptr) {</span>
<span class="line-added">1389             status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1390             return;</span>
<span class="line-added">1391         }</span>
<span class="line-added">1392     }</span>
<span class="line-added">1393 </span>
<span class="line-added">1394     setKeywordValue(legacy_key, legacy_value, status);</span>
<span class="line-added">1395 }</span>
<span class="line-added">1396 </span>
1397 const char *
1398 Locale::getBaseName() const {
1399     return baseName;
1400 }
1401 
1402 //eof
1403 U_NAMESPACE_END
</pre>
</td>
</tr>
</table>
<center><a href="locdspnm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="loclikely.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>