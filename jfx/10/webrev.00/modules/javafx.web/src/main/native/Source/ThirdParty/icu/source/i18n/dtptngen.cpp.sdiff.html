<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtptngen.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="dtitvinf.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtptngen_impl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtptngen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 2007-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 *******************************************************************************
   8 *
   9 * File DTPTNGEN.CPP
  10 *
  11 *******************************************************************************
  12 */
  13 
  14 #include &quot;unicode/utypes.h&quot;
  15 #if !UCONFIG_NO_FORMATTING
  16 
  17 #include &quot;unicode/datefmt.h&quot;
  18 #include &quot;unicode/decimfmt.h&quot;
  19 #include &quot;unicode/dtfmtsym.h&quot;
  20 #include &quot;unicode/dtptngen.h&quot;

  21 #include &quot;unicode/simpleformatter.h&quot;
  22 #include &quot;unicode/smpdtfmt.h&quot;
  23 #include &quot;unicode/udat.h&quot;
  24 #include &quot;unicode/udatpg.h&quot;
  25 #include &quot;unicode/uniset.h&quot;
  26 #include &quot;unicode/uloc.h&quot;
  27 #include &quot;unicode/ures.h&quot;
  28 #include &quot;unicode/ustring.h&quot;
  29 #include &quot;unicode/rep.h&quot;
  30 #include &quot;cpputils.h&quot;
  31 #include &quot;mutex.h&quot;
  32 #include &quot;umutex.h&quot;
  33 #include &quot;cmemory.h&quot;
  34 #include &quot;cstring.h&quot;
  35 #include &quot;locbased.h&quot;
  36 #include &quot;hash.h&quot;
  37 #include &quot;uhash.h&quot;
  38 #include &quot;uresimp.h&quot;
  39 #include &quot;dtptngen_impl.h&quot;
  40 #include &quot;ucln_in.h&quot;
</pre>
<hr />
<pre>
  71 
  72 U_CDECL_BEGIN
  73 
  74 static int32_t U_CALLCONV
  75 ures_a_codepointSort(const void *context, const void *left, const void *right) {
  76     //CompareContext *cmp=(CompareContext *)context;
  77     return u_strcmp(((const UResAEntry *)left)-&gt;key,
  78                     ((const UResAEntry *)right)-&gt;key);
  79 }
  80 
  81 U_CDECL_END
  82 
  83 static void ures_a_open(UResourceBundleAIterator *aiter, UResourceBundle *bund, UErrorCode *status) {
  84     if(U_FAILURE(*status)) {
  85         return;
  86     }
  87     aiter-&gt;bund = bund;
  88     aiter-&gt;num = ures_getSize(aiter-&gt;bund);
  89     aiter-&gt;cursor = 0;
  90 #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)
<span class="line-modified">  91     aiter-&gt;entries = NULL;</span>
  92 #else
  93     aiter-&gt;entries = (UResAEntry*)uprv_malloc(sizeof(UResAEntry)*aiter-&gt;num);
  94     for(int i=0;i&lt;aiter-&gt;num;i++) {
<span class="line-modified">  95         aiter-&gt;entries[i].item = ures_getByIndex(aiter-&gt;bund, i, NULL, status);</span>
  96         const char *akey = ures_getKey(aiter-&gt;entries[i].item);
  97         int32_t len = uprv_strlen(akey)+1;
  98         aiter-&gt;entries[i].key = (UChar*)uprv_malloc(len*sizeof(UChar));
  99         u_charsToUChars(akey, aiter-&gt;entries[i].key, len);
 100     }
<span class="line-modified"> 101     uprv_sortArray(aiter-&gt;entries, aiter-&gt;num, sizeof(UResAEntry), ures_a_codepointSort, NULL, TRUE, status);</span>
 102 #endif
 103 }
 104 
 105 static void ures_a_close(UResourceBundleAIterator *aiter) {
 106 #if defined(U_SORT_ASCII_BUNDLE_ITERATOR)
 107     for(int i=0;i&lt;aiter-&gt;num;i++) {
 108         uprv_free(aiter-&gt;entries[i].key);
 109         ures_close(aiter-&gt;entries[i].item);
 110     }
 111 #endif
 112 }
 113 
 114 static const UChar *ures_a_getNextString(UResourceBundleAIterator *aiter, int32_t *len, const char **key, UErrorCode *err) {
 115 #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)
 116     return ures_getNextString(aiter-&gt;bund, len, key, err);
 117 #else
<span class="line-modified"> 118     if(U_FAILURE(*err)) return NULL;</span>
 119     UResourceBundle *item = aiter-&gt;entries[aiter-&gt;cursor].item;
 120     const UChar* ret = ures_getString(item, len, err);
 121     *key = ures_getKey(item);
 122     aiter-&gt;cursor++;
 123     return ret;
 124 #endif
 125 }
 126 
 127 
 128 #endif
 129 
 130 
 131 U_NAMESPACE_BEGIN
 132 
 133 // *****************************************************************************
 134 // class DateTimePatternGenerator
 135 // *****************************************************************************
 136 static const UChar Canonical_Items[] = {
 137     // GyQMwWEDFdaHmsSv
 138     CAP_G, LOW_Y, CAP_Q, CAP_M, LOW_W, CAP_W, CAP_E,
</pre>
<hr />
<pre>
 285 static const char DT_DateTimePatternsTag[]=&quot;DateTimePatterns&quot;;
 286 static const char DT_DateTimeCalendarTag[]=&quot;calendar&quot;;
 287 static const char DT_DateTimeGregorianTag[]=&quot;gregorian&quot;;
 288 static const char DT_DateTimeAppendItemsTag[]=&quot;appendItems&quot;;
 289 static const char DT_DateTimeFieldsTag[]=&quot;fields&quot;;
 290 static const char DT_DateTimeAvailableFormatsTag[]=&quot;availableFormats&quot;;
 291 //static const UnicodeString repeatedPattern=UnicodeString(repeatedPatterns);
 292 
 293 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DateTimePatternGenerator)
 294 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DTSkeletonEnumeration)
 295 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DTRedundantEnumeration)
 296 
 297 DateTimePatternGenerator*  U_EXPORT2
 298 DateTimePatternGenerator::createInstance(UErrorCode&amp; status) {
 299     return createInstance(Locale::getDefault(), status);
 300 }
 301 
 302 DateTimePatternGenerator* U_EXPORT2
 303 DateTimePatternGenerator::createInstance(const Locale&amp; locale, UErrorCode&amp; status) {
 304     if (U_FAILURE(status)) {
<span class="line-modified"> 305         return NULL;</span>
 306     }
 307     LocalPointer&lt;DateTimePatternGenerator&gt; result(
 308             new DateTimePatternGenerator(locale, status), status);
<span class="line-modified"> 309     return U_SUCCESS(status) ? result.orphan() : NULL;</span>
 310 }
 311 
 312 DateTimePatternGenerator*  U_EXPORT2
 313 DateTimePatternGenerator::createEmptyInstance(UErrorCode&amp; status) {
<span class="line-removed"> 314     DateTimePatternGenerator *result = new DateTimePatternGenerator(status);</span>
<span class="line-removed"> 315     if (result == NULL) {</span>
<span class="line-removed"> 316         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed"> 317     }</span>
 318     if (U_FAILURE(status)) {
<span class="line-modified"> 319         delete result;</span>
<span class="line-removed"> 320         result = NULL;</span>
 321     }
<span class="line-modified"> 322     return result;</span>


 323 }
 324 
 325 DateTimePatternGenerator::DateTimePatternGenerator(UErrorCode &amp;status) :
<span class="line-modified"> 326     skipMatcher(NULL),</span>
<span class="line-modified"> 327     fAvailableFormatKeyHash(NULL)</span>

 328 {
 329     fp = new FormatParser();
 330     dtMatcher = new DateTimeMatcher();
 331     distanceInfo = new DistanceInfo();
 332     patternMap = new PatternMap();
<span class="line-modified"> 333     if (fp == NULL || dtMatcher == NULL || distanceInfo == NULL || patternMap == NULL) {</span>
<span class="line-modified"> 334         status = U_MEMORY_ALLOCATION_ERROR;</span>
 335     }
 336 }
 337 
 338 DateTimePatternGenerator::DateTimePatternGenerator(const Locale&amp; locale, UErrorCode &amp;status) :
<span class="line-modified"> 339     skipMatcher(NULL),</span>
<span class="line-modified"> 340     fAvailableFormatKeyHash(NULL)</span>

 341 {
 342     fp = new FormatParser();
 343     dtMatcher = new DateTimeMatcher();
 344     distanceInfo = new DistanceInfo();
 345     patternMap = new PatternMap();
<span class="line-modified"> 346     if (fp == NULL || dtMatcher == NULL || distanceInfo == NULL || patternMap == NULL) {</span>
<span class="line-modified"> 347         status = U_MEMORY_ALLOCATION_ERROR;</span>
 348     }
 349     else {
 350         initData(locale, status);
 351     }
 352 }
 353 
 354 DateTimePatternGenerator::DateTimePatternGenerator(const DateTimePatternGenerator&amp; other) :
 355     UObject(),
<span class="line-modified"> 356     skipMatcher(NULL),</span>
<span class="line-modified"> 357     fAvailableFormatKeyHash(NULL)</span>

 358 {
 359     fp = new FormatParser();
 360     dtMatcher = new DateTimeMatcher();
 361     distanceInfo = new DistanceInfo();
 362     patternMap = new PatternMap();



 363     *this=other;
 364 }
 365 
 366 DateTimePatternGenerator&amp;
 367 DateTimePatternGenerator::operator=(const DateTimePatternGenerator&amp; other) {
 368     // reflexive case
 369     if (&amp;other == this) {
 370         return *this;
 371     }

 372     pLocale = other.pLocale;
 373     fDefaultHourFormatChar = other.fDefaultHourFormatChar;
 374     *fp = *(other.fp);
 375     dtMatcher-&gt;copyFrom(other.dtMatcher-&gt;skeleton);
 376     *distanceInfo = *(other.distanceInfo);
 377     dateTimeFormat = other.dateTimeFormat;
 378     decimal = other.decimal;
 379     // NUL-terminate for the C API.
 380     dateTimeFormat.getTerminatedBuffer();
 381     decimal.getTerminatedBuffer();
 382     delete skipMatcher;
<span class="line-modified"> 383     if ( other.skipMatcher == NULL ) {</span>
<span class="line-modified"> 384         skipMatcher = NULL;</span>
 385     }
 386     else {
 387         skipMatcher = new DateTimeMatcher(*other.skipMatcher);





 388     }
 389     for (int32_t i=0; i&lt; UDATPG_FIELD_COUNT; ++i ) {
 390         appendItemFormats[i] = other.appendItemFormats[i];
 391         appendItemFormats[i].getTerminatedBuffer(); // NUL-terminate for the C API.
 392         for (int32_t j=0; j&lt; UDATPG_WIDTH_COUNT; ++j ) {
 393             fieldDisplayNames[i][j] = other.fieldDisplayNames[i][j];
 394             fieldDisplayNames[i][j].getTerminatedBuffer(); // NUL-terminate for the C API.
 395         }
 396     }
<span class="line-modified"> 397     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 398     patternMap-&gt;copyFrom(*other.patternMap, status);</span>
<span class="line-removed"> 399     copyHashtable(other.fAvailableFormatKeyHash, status);</span>
 400     return *this;
 401 }
 402 
 403 
 404 UBool
 405 DateTimePatternGenerator::operator==(const DateTimePatternGenerator&amp; other) const {
 406     if (this == &amp;other) {
 407         return TRUE;
 408     }
 409     if ((pLocale==other.pLocale) &amp;&amp; (patternMap-&gt;equals(*other.patternMap)) &amp;&amp;
 410         (dateTimeFormat==other.dateTimeFormat) &amp;&amp; (decimal==other.decimal)) {
 411         for ( int32_t i=0 ; i&lt;UDATPG_FIELD_COUNT; ++i ) {
 412             if (appendItemFormats[i] != other.appendItemFormats[i]) {
 413                 return FALSE;
 414             }
 415             for (int32_t j=0; j&lt; UDATPG_WIDTH_COUNT; ++j ) {
 416                 if (fieldDisplayNames[i][j] != other.fieldDisplayNames[i][j]) {
 417                     return FALSE;
 418                 }
 419             }
 420         }
 421         return TRUE;
 422     }
 423     else {
 424         return FALSE;
 425     }
 426 }
 427 
 428 UBool
 429 DateTimePatternGenerator::operator!=(const DateTimePatternGenerator&amp; other) const {
 430     return  !operator==(other);
 431 }
 432 
 433 DateTimePatternGenerator::~DateTimePatternGenerator() {
<span class="line-modified"> 434     if (fAvailableFormatKeyHash!=NULL) {</span>
 435         delete fAvailableFormatKeyHash;
 436     }
 437 
<span class="line-modified"> 438     if (fp != NULL) delete fp;</span>
<span class="line-modified"> 439     if (dtMatcher != NULL) delete dtMatcher;</span>
<span class="line-modified"> 440     if (distanceInfo != NULL) delete distanceInfo;</span>
<span class="line-modified"> 441     if (patternMap != NULL) delete patternMap;</span>
<span class="line-modified"> 442     if (skipMatcher != NULL) delete skipMatcher;</span>
 443 }
 444 
 445 namespace {
 446 
 447 UInitOnce initOnce = U_INITONCE_INITIALIZER;
<span class="line-modified"> 448 UHashtable *localeToAllowedHourFormatsMap = NULL;</span>
 449 
 450 // Value deleter for hashmap.
 451 U_CFUNC void U_CALLCONV deleteAllowedHourFormats(void *ptr) {
 452     uprv_free(ptr);
 453 }
 454 
 455 // Close hashmap at cleanup.
 456 U_CFUNC UBool U_CALLCONV allowedHourFormatsCleanup() {
 457     uhash_close(localeToAllowedHourFormatsMap);
 458     return TRUE;
 459 }
 460 
 461 enum AllowedHourFormat{
 462     ALLOWED_HOUR_FORMAT_UNKNOWN = -1,
 463     ALLOWED_HOUR_FORMAT_h,
 464     ALLOWED_HOUR_FORMAT_H,


 465     ALLOWED_HOUR_FORMAT_hb,
<span class="line-removed"> 466     ALLOWED_HOUR_FORMAT_Hb,</span>
 467     ALLOWED_HOUR_FORMAT_hB,




 468     ALLOWED_HOUR_FORMAT_HB
 469 };
 470 
 471 }  // namespace
 472 
 473 void
 474 DateTimePatternGenerator::initData(const Locale&amp; locale, UErrorCode &amp;status) {
 475     //const char *baseLangName = locale.getBaseName(); // unused
 476 
<span class="line-modified"> 477     skipMatcher = NULL;</span>
<span class="line-modified"> 478     fAvailableFormatKeyHash=NULL;</span>
 479     addCanonicalItems(status);
 480     addICUPatterns(locale, status);
 481     addCLDRData(locale, status);
 482     setDateTimeFromCalendar(locale, status);
 483     setDecimalSymbols(locale, status);
 484     umtx_initOnce(initOnce, loadAllowedHourFormatsData, status);
 485     getAllowedHourFormats(locale, status);


 486 } // DateTimePatternGenerator::initData
 487 
 488 namespace {
 489 
 490 struct AllowedHourFormatsSink : public ResourceSink {
 491     // Initialize sub-sinks.
 492     AllowedHourFormatsSink() {}
 493     virtual ~AllowedHourFormatsSink();
 494 
 495     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,
 496                      UErrorCode &amp;errorCode) {
 497         ResourceTable timeData = value.getTable(errorCode);
 498         if (U_FAILURE(errorCode)) { return; }
 499         for (int32_t i = 0; timeData.getKeyAndValue(i, key, value); ++i) {
 500             const char *regionOrLocale = key;
 501             ResourceTable formatList = value.getTable(errorCode);
 502             if (U_FAILURE(errorCode)) { return; }






 503             for (int32_t j = 0; formatList.getKeyAndValue(j, key, value); ++j) {
<span class="line-modified"> 504                 if (uprv_strcmp(key, &quot;allowed&quot;) == 0) {  // Ignore &quot;preferred&quot; list.</span>
<span class="line-removed"> 505                     LocalMemory&lt;int32_t&gt; list;</span>
<span class="line-removed"> 506                     int32_t length;</span>
 507                     if (value.getType() == URES_STRING) {
<span class="line-modified"> 508                         if (list.allocateInsteadAndReset(2) == NULL) {</span>

 509                             errorCode = U_MEMORY_ALLOCATION_ERROR;
 510                             return;
 511                         }
<span class="line-modified"> 512                         list[0] = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));</span>
<span class="line-removed"> 513                         length = 1;</span>
 514                     }
 515                     else {
 516                         ResourceArray allowedFormats = value.getArray(errorCode);
<span class="line-modified"> 517                         length = allowedFormats.getSize();</span>
<span class="line-modified"> 518                         if (list.allocateInsteadAndReset(length + 1) == NULL) {</span>
 519                             errorCode = U_MEMORY_ALLOCATION_ERROR;
 520                             return;
 521                         }
<span class="line-modified"> 522                         for (int32_t k = 0; k &lt; length; ++k) {</span>
<span class="line-modified"> 523                             allowedFormats.getValue(k, value);</span>
 524                             list[k] = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));
 525                         }
 526                     }
<span class="line-modified"> 527                     list[length] = ALLOWED_HOUR_FORMAT_UNKNOWN;</span>
<span class="line-modified"> 528                     uhash_put(localeToAllowedHourFormatsMap,</span>
<span class="line-removed"> 529                               const_cast&lt;char *&gt;(regionOrLocale), list.orphan(), &amp;errorCode);</span>
<span class="line-removed"> 530                     if (U_FAILURE(errorCode)) { return; }</span>
 531                 }
 532             }

















 533         }
 534     }
 535 
 536     AllowedHourFormat getHourFormatFromUnicodeString(const UnicodeString &amp;s) {
 537         if (s.length() == 1) {
 538             if (s[0] == LOW_H) { return ALLOWED_HOUR_FORMAT_h; }
 539             if (s[0] == CAP_H) { return ALLOWED_HOUR_FORMAT_H; }


 540         } else if (s.length() == 2) {
 541             if (s[0] == LOW_H &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_hb; }
<span class="line-removed"> 542             if (s[0] == CAP_H &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_Hb; }</span>
 543             if (s[0] == LOW_H &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_hB; }



 544             if (s[0] == CAP_H &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_HB; }
 545         }
 546 
 547         return ALLOWED_HOUR_FORMAT_UNKNOWN;
 548     }
 549 };
 550 
 551 }  // namespace
 552 
 553 AllowedHourFormatsSink::~AllowedHourFormatsSink() {}
 554 
 555 U_CFUNC void U_CALLCONV DateTimePatternGenerator::loadAllowedHourFormatsData(UErrorCode &amp;status) {
 556     if (U_FAILURE(status)) { return; }
 557     localeToAllowedHourFormatsMap = uhash_open(
<span class="line-modified"> 558         uhash_hashChars, uhash_compareChars, NULL, &amp;status);</span>


 559     uhash_setValueDeleter(localeToAllowedHourFormatsMap, deleteAllowedHourFormats);
<span class="line-modified"> 560     LocalUResourceBundlePointer rb(ures_openDirect(NULL, &quot;supplementalData&quot;, &amp;status));</span>



 561 
 562     AllowedHourFormatsSink sink;
 563     // TODO: Currently in the enumeration each table allocates a new array.
 564     // Try to reduce the number of memory allocations. Consider storing a
 565     // UVector32 with the concatenation of all of the sub-arrays, put the start index
 566     // into the hashmap, store 6 single-value sub-arrays right at the beginning of the
 567     // vector (at index enum*2) for easy data sharing, copy sub-arrays into runtime
 568     // object. Remember to clean up the vector, too.
 569     ures_getAllItemsWithFallback(rb.getAlias(), &quot;timeData&quot;, sink, status);
<span class="line-removed"> 570 </span>
<span class="line-removed"> 571     ucln_i18n_registerCleanup(UCLN_I18N_ALLOWED_HOUR_FORMATS, allowedHourFormatsCleanup);</span>
 572 }
 573 
 574 void DateTimePatternGenerator::getAllowedHourFormats(const Locale &amp;locale, UErrorCode &amp;status) {
 575     if (U_FAILURE(status)) { return; }
<span class="line-modified"> 576     const char *localeID = locale.getName();</span>
<span class="line-modified"> 577     char maxLocaleID[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-removed"> 578     int32_t length = uloc_addLikelySubtags(localeID, maxLocaleID, ULOC_FULLNAME_CAPACITY, &amp;status);</span>
 579     if (U_FAILURE(status)) {
 580         return;
<span class="line-removed"> 581     } else if (length == ULOC_FULLNAME_CAPACITY) {  // no room for NUL</span>
<span class="line-removed"> 582         status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-removed"> 583         return;</span>
 584     }
<span class="line-removed"> 585     Locale maxLocale = Locale(maxLocaleID);</span>
 586 
 587     const char *country = maxLocale.getCountry();
 588     if (*country == &#39;\0&#39;) { country = &quot;001&quot;; }
 589     const char *language = maxLocale.getLanguage();
 590 
 591     CharString langCountry;
<span class="line-modified"> 592     langCountry.append(language, uprv_strlen(language), status);</span>
 593     langCountry.append(&#39;_&#39;, status);
<span class="line-modified"> 594     langCountry.append(country, uprv_strlen(country), status);</span>
 595 
 596     int32_t *allowedFormats;
 597     allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, langCountry.data());
<span class="line-modified"> 598     if (allowedFormats == NULL) {</span>
 599         allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, const_cast&lt;char *&gt;(country));
 600     }
 601 
<span class="line-modified"> 602     if (allowedFormats != NULL) {  // Lookup is successful</span>









 603         for (int32_t i = 0; i &lt; UPRV_LENGTHOF(fAllowedHourFormats); ++i) {
<span class="line-modified"> 604             fAllowedHourFormats[i] = allowedFormats[i];</span>
<span class="line-modified"> 605             if (allowedFormats[i] == ALLOWED_HOUR_FORMAT_UNKNOWN) {</span>
 606                 break;
 607             }
 608         }
 609     } else {  // Lookup failed, twice

 610         fAllowedHourFormats[0] = ALLOWED_HOUR_FORMAT_H;
 611         fAllowedHourFormats[1] = ALLOWED_HOUR_FORMAT_UNKNOWN;
 612     }
 613 }
 614 
 615 UnicodeString
 616 DateTimePatternGenerator::getSkeleton(const UnicodeString&amp; pattern, UErrorCode&amp;
 617 /*status*/) {
<span class="line-modified"> 618     FormatParser fp;</span>
 619     DateTimeMatcher matcher;
 620     PtnSkeleton localSkeleton;
<span class="line-modified"> 621     matcher.set(pattern, &amp;fp, localSkeleton);</span>
 622     return localSkeleton.getSkeleton();
 623 }
 624 
 625 UnicodeString
 626 DateTimePatternGenerator::staticGetSkeleton(
 627         const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
 628     FormatParser fp;
 629     DateTimeMatcher matcher;
 630     PtnSkeleton localSkeleton;
 631     matcher.set(pattern, &amp;fp, localSkeleton);
 632     return localSkeleton.getSkeleton();
 633 }
 634 
 635 UnicodeString
 636 DateTimePatternGenerator::getBaseSkeleton(const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
<span class="line-modified"> 637     FormatParser fp;</span>
 638     DateTimeMatcher matcher;
 639     PtnSkeleton localSkeleton;
<span class="line-modified"> 640     matcher.set(pattern, &amp;fp, localSkeleton);</span>
 641     return localSkeleton.getBaseSkeleton();
 642 }
 643 
 644 UnicodeString
 645 DateTimePatternGenerator::staticGetBaseSkeleton(
 646         const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
 647     FormatParser fp;
 648     DateTimeMatcher matcher;
 649     PtnSkeleton localSkeleton;
 650     matcher.set(pattern, &amp;fp, localSkeleton);
 651     return localSkeleton.getBaseSkeleton();
 652 }
 653 
 654 void
 655 DateTimePatternGenerator::addICUPatterns(const Locale&amp; locale, UErrorCode&amp; status) {
 656     if (U_FAILURE(status)) { return; }
 657     UnicodeString dfPattern;
 658     UnicodeString conflictingString;
 659     DateFormat* df;
 660 
 661     // Load with ICU patterns
 662     for (int32_t i=DateFormat::kFull; i&lt;=DateFormat::kShort; i++) {
 663         DateFormat::EStyle style = (DateFormat::EStyle)i;
 664         df = DateFormat::createDateInstance(style, locale);
 665         SimpleDateFormat* sdf;
<span class="line-modified"> 666         if (df != NULL &amp;&amp; (sdf = dynamic_cast&lt;SimpleDateFormat*&gt;(df)) != NULL) {</span>
 667             sdf-&gt;toPattern(dfPattern);
 668             addPattern(dfPattern, FALSE, conflictingString, status);
 669         }
 670         // TODO Maybe we should return an error when the date format isn&#39;t simple.
 671         delete df;
 672         if (U_FAILURE(status)) { return; }
 673 
 674         df = DateFormat::createTimeInstance(style, locale);
<span class="line-modified"> 675         if (df != NULL &amp;&amp; (sdf = dynamic_cast&lt;SimpleDateFormat*&gt;(df)) != NULL) {</span>
 676             sdf-&gt;toPattern(dfPattern);
 677             addPattern(dfPattern, FALSE, conflictingString, status);
 678 
 679             // TODO: C++ and Java are inconsistent (see #12568).
 680             // C++ uses MEDIUM, but Java uses SHORT.
 681             if ( i==DateFormat::kShort &amp;&amp; !dfPattern.isEmpty() ) {
 682                 consumeShortTimePattern(dfPattern, status);
 683             }
 684         }
 685         // TODO Maybe we should return an error when the date format isn&#39;t simple.
 686         delete df;
 687         if (U_FAILURE(status)) { return; }
 688     }
 689 }
 690 
 691 void
 692 DateTimePatternGenerator::hackTimes(const UnicodeString&amp; hackPattern, UErrorCode&amp; status)  {
 693     UnicodeString conflictingString;
 694 
 695     fp-&gt;set(hackPattern);
</pre>
<hr />
<pre>
 719                         if (!gotMm) {
 720                             break;
 721                         }
 722                         mmss+= field;
 723                         addPattern(mmss, FALSE, conflictingString, status);
 724                         break;
 725                     }
 726                     else {
 727                         if (gotMm || ch==LOW_Z || ch==CAP_Z || ch==LOW_V || ch==CAP_V) {
 728                             break;
 729                         }
 730                     }
 731                 }
 732             }
 733         }
 734     }
 735 }
 736 
 737 #define ULOC_LOCALE_IDENTIFIER_CAPACITY (ULOC_FULLNAME_CAPACITY + 1 + ULOC_KEYWORD_AND_VALUES_CAPACITY)
 738 
<span class="line-removed"> 739 static const UChar hourFormatChars[] = { CAP_H, LOW_H, CAP_K, LOW_K, 0 }; // HhKk, the hour format characters</span>
<span class="line-removed"> 740 </span>
 741 void
 742 DateTimePatternGenerator::getCalendarTypeToUse(const Locale&amp; locale, CharString&amp; destination, UErrorCode&amp; err) {
 743     destination.clear().append(DT_DateTimeGregorianTag, -1, err); // initial default
 744     if ( U_SUCCESS(err) ) {
 745         char localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY];
 746         // obtain a locale that always has the calendar key value that should be used
 747         ures_getFunctionalEquivalent(
 748             localeWithCalendarKey,
 749             ULOC_LOCALE_IDENTIFIER_CAPACITY,
<span class="line-modified"> 750             NULL,</span>
 751             &quot;calendar&quot;,
 752             &quot;calendar&quot;,
 753             locale.getName(),
<span class="line-modified"> 754             NULL,</span>
 755             FALSE,
 756             &amp;err);

 757         localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY-1] = 0; // ensure null termination
 758         // now get the calendar key value from that locale
 759         char calendarType[ULOC_KEYWORDS_CAPACITY];
 760         int32_t calendarTypeLen = uloc_getKeywordValue(
 761             localeWithCalendarKey,
 762             &quot;calendar&quot;,
 763             calendarType,
 764             ULOC_KEYWORDS_CAPACITY,
 765             &amp;err);
<span class="line-modified"> 766         if (U_SUCCESS(err) &amp;&amp; calendarTypeLen &lt; ULOC_KEYWORDS_CAPACITY) {</span>

 767             destination.clear().append(calendarType, -1, err);
 768             if (U_FAILURE(err)) { return; }
 769         }
 770         err = U_ZERO_ERROR;
 771     }
 772 }
 773 
 774 void
 775 DateTimePatternGenerator::consumeShortTimePattern(const UnicodeString&amp; shortTimePattern,
 776         UErrorCode&amp; status) {
<span class="line-modified"> 777 </span>
<span class="line-modified"> 778     // set fDefaultHourFormatChar to the hour format character from this pattern</span>
<span class="line-modified"> 779     int32_t tfIdx, tfLen = shortTimePattern.length();</span>
<span class="line-modified"> 780     UBool ignoreChars = FALSE;</span>
<span class="line-removed"> 781     for (tfIdx = 0; tfIdx &lt; tfLen; tfIdx++) {</span>
<span class="line-removed"> 782         UChar tfChar = shortTimePattern.charAt(tfIdx);</span>
<span class="line-removed"> 783         if ( tfChar == SINGLE_QUOTE ) {</span>
<span class="line-removed"> 784             ignoreChars = !ignoreChars; // toggle (handle quoted literals &amp; &#39;&#39; for single quote)</span>
<span class="line-removed"> 785         } else if ( !ignoreChars &amp;&amp; u_strchr(hourFormatChars, tfChar) != NULL ) {</span>
<span class="line-removed"> 786             fDefaultHourFormatChar = tfChar;</span>
<span class="line-removed"> 787             break;</span>
<span class="line-removed"> 788         }</span>
<span class="line-removed"> 789     }</span>
 790 
 791     // HACK for hh:ss
 792     hackTimes(shortTimePattern, status);
 793 }
 794 
 795 struct DateTimePatternGenerator::AppendItemFormatsSink : public ResourceSink {
 796 
 797     // Destination for data, modified via setters.
 798     DateTimePatternGenerator&amp; dtpg;
 799 
 800     AppendItemFormatsSink(DateTimePatternGenerator&amp; _dtpg) : dtpg(_dtpg) {}
 801     virtual ~AppendItemFormatsSink();
 802 
 803     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,
 804             UErrorCode &amp;errorCode) {
 805         ResourceTable itemsTable = value.getTable(errorCode);
 806         if (U_FAILURE(errorCode)) { return; }
 807         for (int32_t i = 0; itemsTable.getKeyAndValue(i, key, value); ++i) {
 808             UDateTimePatternField field = dtpg.getAppendFormatNumber(key);
 809             if (field == UDATPG_FIELD_COUNT) { continue; }
</pre>
<hr />
<pre>
 855     }
 856 
 857     void fillInMissing() {
 858         for (int32_t i = 0; i &lt; UDATPG_FIELD_COUNT; i++) {
 859             UnicodeString&amp; valueStr = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, UDATPG_WIDE);
 860             if (valueStr.isEmpty()) {
 861                 valueStr = CAP_F;
 862                 U_ASSERT(i &lt; 20);
 863                 if (i &lt; 10) {
 864                     // F0, F1, ..., F9
 865                     valueStr += (UChar)(i+0x30);
 866                 } else {
 867                     // F10, F11, ...
 868                     valueStr += (UChar)0x31;
 869                     valueStr += (UChar)(i-10 + 0x30);
 870                 }
 871                 // NUL-terminate for the C API.
 872                 valueStr.getTerminatedBuffer();
 873             }
 874             for (int32_t j = 1; j &lt; UDATPG_WIDTH_COUNT; j++) {
<span class="line-modified"> 875                 UnicodeString&amp; valueStr = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)j);</span>
<span class="line-modified"> 876                 if (valueStr.isEmpty()) {</span>
<span class="line-modified"> 877                     valueStr = dtpg.getFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)(j-1));</span>
 878                 }
 879             }
 880         }
 881     }
 882 };
 883 
 884 struct DateTimePatternGenerator::AvailableFormatsSink : public ResourceSink {
 885 
 886     // Destination for data, modified via setters.
 887     DateTimePatternGenerator&amp; dtpg;
 888 
 889     // Temporary variable, required for calling addPatternWithSkeleton.
 890     UnicodeString conflictingPattern;
 891 
 892     AvailableFormatsSink(DateTimePatternGenerator&amp; _dtpg) : dtpg(_dtpg) {}
 893     virtual ~AvailableFormatsSink();
 894 
 895     virtual void put(const char *key, ResourceValue &amp;value, UBool isRoot,
 896             UErrorCode &amp;errorCode) {
 897         ResourceTable itemsTable = value.getTable(errorCode);
</pre>
<hr />
<pre>
 904                 // derived from std patterns, but not a previous availableFormats entry:
 905                 const UnicodeString&amp; formatValue = value.getUnicodeString(errorCode);
 906                 conflictingPattern.remove();
 907                 dtpg.addPatternWithSkeleton(formatValue, &amp;formatKey, !isRoot, conflictingPattern, errorCode);
 908             }
 909         }
 910     }
 911 };
 912 
 913 // Virtual destructors must be defined out of line.
 914 DateTimePatternGenerator::AppendItemFormatsSink::~AppendItemFormatsSink() {}
 915 DateTimePatternGenerator::AppendItemNamesSink::~AppendItemNamesSink() {}
 916 DateTimePatternGenerator::AvailableFormatsSink::~AvailableFormatsSink() {}
 917 
 918 void
 919 DateTimePatternGenerator::addCLDRData(const Locale&amp; locale, UErrorCode&amp; errorCode) {
 920     if (U_FAILURE(errorCode)) { return; }
 921     UnicodeString rbPattern, value, field;
 922     CharString path;
 923 
<span class="line-modified"> 924     LocalUResourceBundlePointer rb(ures_open(NULL, locale.getName(), &amp;errorCode));</span>
 925     if (U_FAILURE(errorCode)) { return; }
 926 
 927     CharString calendarTypeToUse; // to be filled in with the type to use, if all goes well
 928     getCalendarTypeToUse(locale, calendarTypeToUse, errorCode);
 929     if (U_FAILURE(errorCode)) { return; }
 930 
 931     // Local err to ignore resource not found exceptions
 932     UErrorCode err = U_ZERO_ERROR;
 933 
 934     // Load append item formats.
 935     AppendItemFormatsSink appendItemFormatsSink(*this);
 936     path.clear()
 937         .append(DT_DateTimeCalendarTag, errorCode)
 938         .append(&#39;/&#39;, errorCode)
 939         .append(calendarTypeToUse, errorCode)
 940         .append(&#39;/&#39;, errorCode)
 941         .append(DT_DateTimeAppendItemsTag, errorCode); // i.e., calendar/xxx/appendItems
 942     if (U_FAILURE(errorCode)) { return; }
 943     ures_getAllItemsWithFallback(rb.getAlias(), path.data(), appendItemFormatsSink, err);
 944     appendItemFormatsSink.fillInMissing();
</pre>
<hr />
<pre>
 949     ures_getAllItemsWithFallback(rb.getAlias(), DT_DateTimeFieldsTag, appendItemNamesSink, err);
 950     appendItemNamesSink.fillInMissing();
 951 
 952     // Load the available formats from CLDR.
 953     err = U_ZERO_ERROR;
 954     initHashtable(errorCode);
 955     if (U_FAILURE(errorCode)) { return; }
 956     AvailableFormatsSink availableFormatsSink(*this);
 957     path.clear()
 958         .append(DT_DateTimeCalendarTag, errorCode)
 959         .append(&#39;/&#39;, errorCode)
 960         .append(calendarTypeToUse, errorCode)
 961         .append(&#39;/&#39;, errorCode)
 962         .append(DT_DateTimeAvailableFormatsTag, errorCode); // i.e., calendar/xxx/availableFormats
 963     if (U_FAILURE(errorCode)) { return; }
 964     ures_getAllItemsWithFallback(rb.getAlias(), path.data(), availableFormatsSink, err);
 965 }
 966 
 967 void
 968 DateTimePatternGenerator::initHashtable(UErrorCode&amp; err) {
<span class="line-modified"> 969     if (fAvailableFormatKeyHash!=NULL) {</span>

 970         return;
 971     }
<span class="line-modified"> 972     if ((fAvailableFormatKeyHash = new Hashtable(FALSE, err))==NULL) {</span>
<span class="line-modified"> 973         err=U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified"> 974         return;</span>
 975     }
 976 }
 977 
 978 void
 979 DateTimePatternGenerator::setAppendItemFormat(UDateTimePatternField field, const UnicodeString&amp; value) {
 980     appendItemFormats[field] = value;
 981     // NUL-terminate for the C API.
 982     appendItemFormats[field].getTerminatedBuffer();
 983 }
 984 
 985 const UnicodeString&amp;
 986 DateTimePatternGenerator::getAppendItemFormat(UDateTimePatternField field) const {
 987     return appendItemFormats[field];
 988 }
 989 
 990 void
 991 DateTimePatternGenerator::setAppendItemName(UDateTimePatternField field, const UnicodeString&amp; value) {
 992     setFieldDisplayName(field, UDATPG_WIDTH_APPENDITEM, value);
 993 }
 994 
</pre>
<hr />
<pre>
1011 
1012 UnicodeString&amp;
1013 DateTimePatternGenerator::getMutableFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width) {
1014     return fieldDisplayNames[field][width];
1015 }
1016 
1017 void
1018 DateTimePatternGenerator::getAppendName(UDateTimePatternField field, UnicodeString&amp; value) {
1019     value = SINGLE_QUOTE;
1020     value += fieldDisplayNames[field][UDATPG_WIDTH_APPENDITEM];
1021     value += SINGLE_QUOTE;
1022 }
1023 
1024 UnicodeString
1025 DateTimePatternGenerator::getBestPattern(const UnicodeString&amp; patternForm, UErrorCode&amp; status) {
1026     return getBestPattern(patternForm, UDATPG_MATCH_NO_OPTIONS, status);
1027 }
1028 
1029 UnicodeString
1030 DateTimePatternGenerator::getBestPattern(const UnicodeString&amp; patternForm, UDateTimePatternMatchOptions options, UErrorCode&amp; status) {
<span class="line-modified">1031     const UnicodeString *bestPattern=NULL;</span>







1032     UnicodeString dtFormat;
1033     UnicodeString resultPattern;
1034     int32_t flags = kDTPGNoFlags;
1035 
1036     int32_t dateMask=(1&lt;&lt;UDATPG_DAYPERIOD_FIELD) - 1;
1037     int32_t timeMask=(1&lt;&lt;UDATPG_FIELD_COUNT) - 1 - dateMask;
1038 
1039     // Replace hour metacharacters &#39;j&#39;, &#39;C&#39; and &#39;J&#39;, set flags as necessary
1040     UnicodeString patternFormMapped = mapSkeletonMetacharacters(patternForm, &amp;flags, status);
1041     if (U_FAILURE(status)) {
1042         return UnicodeString();
1043     }
1044 
1045     resultPattern.remove();
1046     dtMatcher-&gt;set(patternFormMapped, fp);
<span class="line-modified">1047     const PtnSkeleton* specifiedSkeleton=NULL;</span>
<span class="line-modified">1048     bestPattern=getBestRaw(*dtMatcher, -1, distanceInfo, &amp;specifiedSkeleton);</span>




1049     if ( distanceInfo-&gt;missingFieldMask==0 &amp;&amp; distanceInfo-&gt;extraFieldMask==0 ) {
1050         resultPattern = adjustFieldTypes(*bestPattern, specifiedSkeleton, flags, options);
1051 
1052         return resultPattern;
1053     }
1054     int32_t neededFields = dtMatcher-&gt;getFieldMask();
<span class="line-modified">1055     UnicodeString datePattern=getBestAppending(neededFields &amp; dateMask, flags, options);</span>
<span class="line-modified">1056     UnicodeString timePattern=getBestAppending(neededFields &amp; timeMask, flags, options);</span>



1057     if (datePattern.length()==0) {
1058         if (timePattern.length()==0) {
1059             resultPattern.remove();
1060         }
1061         else {
1062             return timePattern;
1063         }
1064     }
1065     if (timePattern.length()==0) {
1066         return datePattern;
1067     }
1068     resultPattern.remove();
1069     status = U_ZERO_ERROR;
1070     dtFormat=getDateTimeFormat();
1071     SimpleFormatter(dtFormat, 2, 2, status).format(timePattern, datePattern, resultPattern, status);
1072     return resultPattern;
1073 }
1074 
1075 /*
1076  * Map a skeleton that may have metacharacters jJC to one without, by replacing
<span class="line-modified">1077  * the metacharacters with locale-appropriate fields of of h/H/k/K and of a/b/B</span>
1078  * (depends on fDefaultHourFormatChar and fAllowedHourFormats being set, which in
1079  * turn depends on initData having been run). This method also updates the flags
1080  * as necessary. Returns the updated skeleton.
1081  */
1082 UnicodeString
1083 DateTimePatternGenerator::mapSkeletonMetacharacters(const UnicodeString&amp; patternForm, int32_t* flags, UErrorCode&amp; status) {
1084     UnicodeString patternFormMapped;
1085     patternFormMapped.remove();
1086     UBool inQuoted = FALSE;
1087     int32_t patPos, patLen = patternForm.length();
1088     for (patPos = 0; patPos &lt; patLen; patPos++) {
1089         UChar patChr = patternForm.charAt(patPos);
1090         if (patChr == SINGLE_QUOTE) {
1091             inQuoted = !inQuoted;
1092         } else if (!inQuoted) {
1093             // Handle special mappings for &#39;j&#39; and &#39;C&#39; in which fields lengths
1094             // 1,3,5 =&gt; hour field length 1
1095             // 2,4,6 =&gt; hour field length 2
1096             // 1,2 =&gt; abbreviated dayPeriod (field length 1..3)
1097             // 3,4 =&gt; long dayPeriod (field length 4)
1098             // 5,6 =&gt; narrow dayPeriod (field length 5)
1099             if (patChr == LOW_J || patChr == CAP_C) {
1100                 int32_t extraLen = 0; // 1 less than total field length
1101                 while (patPos+1 &lt; patLen &amp;&amp; patternForm.charAt(patPos+1)==patChr) {
1102                     extraLen++;
1103                     patPos++;
1104                 }
1105                 int32_t hourLen = 1 + (extraLen &amp; 1);
1106                 int32_t dayPeriodLen = (extraLen &lt; 2)? 1: 3 + (extraLen &gt;&gt; 1);
1107                 UChar hourChar = LOW_H;
1108                 UChar dayPeriodChar = LOW_A;
1109                 if (patChr == LOW_J) {
1110                     hourChar = fDefaultHourFormatChar;
1111                 } else {
<span class="line-modified">1112                     AllowedHourFormat preferred;</span>
1113                     if (fAllowedHourFormats[0] != ALLOWED_HOUR_FORMAT_UNKNOWN) {
<span class="line-modified">1114                         preferred = (AllowedHourFormat)fAllowedHourFormats[0];</span>
1115                     } else {
1116                         status = U_INVALID_FORMAT_ERROR;
1117                         return UnicodeString();
1118                     }
<span class="line-modified">1119                     if (preferred == ALLOWED_HOUR_FORMAT_H || preferred == ALLOWED_HOUR_FORMAT_HB || preferred == ALLOWED_HOUR_FORMAT_Hb) {</span>
1120                         hourChar = CAP_H;




1121                     }
1122                     // in #13183 just add b/B to skeleton, no longer need to set special flags
<span class="line-modified">1123                     if (preferred == ALLOWED_HOUR_FORMAT_HB || preferred == ALLOWED_HOUR_FORMAT_hB) {</span>
1124                         dayPeriodChar = CAP_B;
<span class="line-modified">1125                     } else if (preferred == ALLOWED_HOUR_FORMAT_Hb || preferred == ALLOWED_HOUR_FORMAT_hb) {</span>
1126                         dayPeriodChar = LOW_B;
1127                     }
1128                 }
1129                 if (hourChar==CAP_H || hourChar==LOW_K) {
1130                     dayPeriodLen = 0;
1131                 }
1132                 while (dayPeriodLen-- &gt; 0) {
1133                     patternFormMapped.append(dayPeriodChar);
1134                 }
1135                 while (hourLen-- &gt; 0) {
1136                     patternFormMapped.append(hourChar);
1137                 }
1138             } else if (patChr == CAP_J) {
1139                 // Get pattern for skeleton with H, then replace H or k
1140                 // with fDefaultHourFormatChar (if different)
1141                 patternFormMapped.append(CAP_H);
1142                 *flags |= kDTPGSkeletonUsesCapJ;
1143             } else {
1144                 patternFormMapped.append(patChr);
1145             }
1146         }
1147     }
1148     return patternFormMapped;
1149 }
1150 
1151 UnicodeString
1152 DateTimePatternGenerator::replaceFieldTypes(const UnicodeString&amp; pattern,
1153                                             const UnicodeString&amp; skeleton,
1154                                             UErrorCode&amp; status) {
1155     return replaceFieldTypes(pattern, skeleton, UDATPG_MATCH_NO_OPTIONS, status);
1156 }
1157 
1158 UnicodeString
1159 DateTimePatternGenerator::replaceFieldTypes(const UnicodeString&amp; pattern,
1160                                             const UnicodeString&amp; skeleton,
1161                                             UDateTimePatternMatchOptions options,
<span class="line-modified">1162                                             UErrorCode&amp; /*status*/) {</span>







1163     dtMatcher-&gt;set(skeleton, fp);
<span class="line-modified">1164     UnicodeString result = adjustFieldTypes(pattern, NULL, kDTPGNoFlags, options);</span>
1165     return result;
1166 }
1167 
1168 void
1169 DateTimePatternGenerator::setDecimal(const UnicodeString&amp; newDecimal) {
1170     this-&gt;decimal = newDecimal;
1171     // NUL-terminate for the C API.
1172     this-&gt;decimal.getTerminatedBuffer();
1173 }
1174 
1175 const UnicodeString&amp;
1176 DateTimePatternGenerator::getDecimal() const {
1177     return decimal;
1178 }
1179 
1180 void
1181 DateTimePatternGenerator::addCanonicalItems(UErrorCode&amp; status) {
1182     if (U_FAILURE(status)) { return; }
1183     UnicodeString  conflictingPattern;
1184 
</pre>
<hr />
<pre>
1187             addPattern(UnicodeString(Canonical_Items[i]), FALSE, conflictingPattern, status);
1188         }
1189         if (U_FAILURE(status)) { return; }
1190     }
1191 }
1192 
1193 void
1194 DateTimePatternGenerator::setDateTimeFormat(const UnicodeString&amp; dtFormat) {
1195     dateTimeFormat = dtFormat;
1196     // NUL-terminate for the C API.
1197     dateTimeFormat.getTerminatedBuffer();
1198 }
1199 
1200 const UnicodeString&amp;
1201 DateTimePatternGenerator::getDateTimeFormat() const {
1202     return dateTimeFormat;
1203 }
1204 
1205 void
1206 DateTimePatternGenerator::setDateTimeFromCalendar(const Locale&amp; locale, UErrorCode&amp; status) {


1207     const UChar *resStr;
1208     int32_t resStrLen = 0;
1209 
<span class="line-modified">1210     Calendar* fCalendar = Calendar::createInstance(locale, status);</span>
1211     if (U_FAILURE(status)) { return; }
1212 
<span class="line-modified">1213     LocalUResourceBundlePointer calData(ures_open(NULL, locale.getBaseName(), &amp;status));</span>

1214     ures_getByKey(calData.getAlias(), DT_DateTimeCalendarTag, calData.getAlias(), &amp;status);

1215 
1216     LocalUResourceBundlePointer dateTimePatterns;
<span class="line-modified">1217     if (fCalendar != NULL &amp;&amp; fCalendar-&gt;getType() != NULL &amp;&amp; *fCalendar-&gt;getType() != &#39;\0&#39;</span>
1218             &amp;&amp; uprv_strcmp(fCalendar-&gt;getType(), DT_DateTimeGregorianTag) != 0) {
1219         dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), fCalendar-&gt;getType(),
<span class="line-modified">1220                                                                 NULL, &amp;status));</span>
1221         ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,
1222                                   dateTimePatterns.getAlias(), &amp;status);
1223     }
1224 
1225     if (dateTimePatterns.isNull() || status == U_MISSING_RESOURCE_ERROR) {
1226         status = U_ZERO_ERROR;
1227         dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), DT_DateTimeGregorianTag,
1228                                                                 dateTimePatterns.orphan(), &amp;status));
1229         ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,
1230                                   dateTimePatterns.getAlias(), &amp;status);
1231     }
1232     if (U_FAILURE(status)) { return; }
1233 
1234     if (ures_getSize(dateTimePatterns.getAlias()) &lt;= DateFormat::kDateTime)
1235     {
1236         status = U_INVALID_FORMAT_ERROR;
1237         return;
1238     }
1239     resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), (int32_t)DateFormat::kDateTime, &amp;resStrLen, &amp;status);
1240     setDateTimeFormat(UnicodeString(TRUE, resStr, resStrLen));
<span class="line-removed">1241 </span>
<span class="line-removed">1242     delete fCalendar;</span>
1243 }
1244 
1245 void
1246 DateTimePatternGenerator::setDecimalSymbols(const Locale&amp; locale, UErrorCode&amp; status) {
1247     DecimalFormatSymbols dfs = DecimalFormatSymbols(locale, status);
1248     if(U_SUCCESS(status)) {
1249         decimal = dfs.getSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol);
1250         // NUL-terminate for the C API.
1251         decimal.getTerminatedBuffer();
1252     }
1253 }
1254 
1255 UDateTimePatternConflict
1256 DateTimePatternGenerator::addPattern(
1257     const UnicodeString&amp; pattern,
1258     UBool override,
1259     UnicodeString &amp;conflictingPattern,
1260     UErrorCode&amp; status)
1261 {
<span class="line-modified">1262     return addPatternWithSkeleton(pattern, NULL, override, conflictingPattern, status);</span>





1263 }
1264 
1265 // For DateTimePatternGenerator::addPatternWithSkeleton -
1266 // If skeletonToUse is specified, then an availableFormats entry is being added. In this case:
1267 // 1. We pass that skeleton to matcher.set instead of having it derive a skeleton from the pattern.
1268 // 2. If the new entry&#39;s skeleton or basePattern does match an existing entry but that entry also had a skeleton specified
1269 // (i.e. it was also from availableFormats), then the new entry does not override it regardless of the value of the override
1270 // parameter. This prevents later availableFormats entries from a parent locale overriding earlier ones from the actual
1271 // specified locale. However, availableFormats entries *should* override entries with matching skeleton whose skeleton was
1272 // derived (i.e. entries derived from the standard date/time patters for the specified locale).
1273 // 3. When adding the pattern (patternMap-&gt;add), we set a new boolean to indicate that the added entry had a
1274 // specified skeleton (which sets a new field in the PtnElem in the PatternMap).
1275 UDateTimePatternConflict
1276 DateTimePatternGenerator::addPatternWithSkeleton(
1277     const UnicodeString&amp; pattern,
1278     const UnicodeString* skeletonToUse,
1279     UBool override,
1280     UnicodeString&amp; conflictingPattern,
1281     UErrorCode&amp; status)
1282 {




1283 
1284     UnicodeString basePattern;
1285     PtnSkeleton   skeleton;
1286     UDateTimePatternConflict conflictingStatus = UDATPG_NO_CONFLICT;
1287 
1288     DateTimeMatcher matcher;
<span class="line-modified">1289     if ( skeletonToUse == NULL ) {</span>
1290         matcher.set(pattern, fp, skeleton);
1291         matcher.getBasePattern(basePattern);
1292     } else {
1293         matcher.set(*skeletonToUse, fp, skeleton); // no longer trims skeleton fields to max len 3, per #7930
1294         matcher.getBasePattern(basePattern); // or perhaps instead: basePattern = *skeletonToUse;
1295     }
1296     // We only care about base conflicts - and replacing the pattern associated with a base - if:
1297     // 1. the conflicting previous base pattern did *not* have an explicit skeleton; in that case the previous
1298     // base + pattern combination was derived from either (a) a canonical item, (b) a standard format, or
1299     // (c) a pattern specified programmatically with a previous call to addPattern (which would only happen
1300     // if we are getting here from a subsequent call to addPattern).
1301     // 2. a skeleton is specified for the current pattern, but override=false; in that case we are checking
1302     // availableFormats items from root, which should not override any previous entry with the same base.
1303     UBool entryHadSpecifiedSkeleton;
1304     const UnicodeString *duplicatePattern = patternMap-&gt;getPatternFromBasePattern(basePattern, entryHadSpecifiedSkeleton);
<span class="line-modified">1305     if (duplicatePattern != NULL &amp;&amp; (!entryHadSpecifiedSkeleton || (skeletonToUse != NULL &amp;&amp; !override))) {</span>
1306         conflictingStatus = UDATPG_BASE_CONFLICT;
1307         conflictingPattern = *duplicatePattern;
1308         if (!override) {
1309             return conflictingStatus;
1310         }
1311     }
1312     // The only time we get here with override=true and skeletonToUse!=null is when adding availableFormats
1313     // items from CLDR data. In that case, we don&#39;t want an item from a parent locale to replace an item with
1314     // same skeleton from the specified locale, so skip the current item if skeletonWasSpecified is true for
1315     // the previously-specified conflicting item.
<span class="line-modified">1316     const PtnSkeleton* entrySpecifiedSkeleton = NULL;</span>
1317     duplicatePattern = patternMap-&gt;getPatternFromSkeleton(skeleton, &amp;entrySpecifiedSkeleton);
<span class="line-modified">1318     if (duplicatePattern != NULL ) {</span>
1319         conflictingStatus = UDATPG_CONFLICT;
1320         conflictingPattern = *duplicatePattern;
<span class="line-modified">1321         if (!override || (skeletonToUse != NULL &amp;&amp; entrySpecifiedSkeleton != NULL)) {</span>
1322             return conflictingStatus;
1323         }
1324     }
<span class="line-modified">1325     patternMap-&gt;add(basePattern, skeleton, pattern, skeletonToUse != NULL, status);</span>
1326     if(U_FAILURE(status)) {
1327         return conflictingStatus;
1328     }
1329 
1330     return UDATPG_NO_CONFLICT;
1331 }
1332 
1333 
1334 UDateTimePatternField
1335 DateTimePatternGenerator::getAppendFormatNumber(const char* field) const {
1336     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
1337         if (uprv_strcmp(CLDR_FIELD_APPEND[i], field)==0) {
1338             return (UDateTimePatternField)i;
1339         }
1340     }
1341     return UDATPG_FIELD_COUNT;
1342 }
1343 
1344 UDateTimePatternField
1345 DateTimePatternGenerator::getFieldAndWidthIndices(const char* key, UDateTimePGDisplayWidth* widthP) const {
</pre>
<hr />
<pre>
1352         for (int32_t i=UDATPG_WIDTH_COUNT-1; i&gt;0; --i) {
1353             if (uprv_strcmp(CLDR_FIELD_WIDTH[i], hyphenPtr)==0) {
1354                 *widthP=(UDateTimePGDisplayWidth)i;
1355                 break;
1356             }
1357         }
1358         *hyphenPtr = 0; // now delete width portion of key
1359     }
1360     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
1361         if (uprv_strcmp(CLDR_FIELD_NAME[i],cldrFieldKey)==0) {
1362             return (UDateTimePatternField)i;
1363         }
1364     }
1365     return UDATPG_FIELD_COUNT;
1366 }
1367 
1368 const UnicodeString*
1369 DateTimePatternGenerator::getBestRaw(DateTimeMatcher&amp; source,
1370                                      int32_t includeMask,
1371                                      DistanceInfo* missingFields,

1372                                      const PtnSkeleton** specifiedSkeletonPtr) {
1373     int32_t bestDistance = 0x7fffffff;
1374     DistanceInfo tempInfo;
<span class="line-modified">1375     const UnicodeString *bestPattern=NULL;</span>
<span class="line-modified">1376     const PtnSkeleton* specifiedSkeleton=NULL;</span>



1377 
<span class="line-removed">1378     PatternMapIterator it;</span>
1379     for (it.set(*patternMap); it.hasNext(); ) {
1380         DateTimeMatcher trial = it.next();
1381         if (trial.equals(skipMatcher)) {
1382             continue;
1383         }
1384         int32_t distance=source.getDistance(trial, includeMask, tempInfo);
1385         if (distance&lt;bestDistance) {
1386             bestDistance=distance;
1387             bestPattern=patternMap-&gt;getPatternFromSkeleton(*trial.getSkeletonPtr(), &amp;specifiedSkeleton);
1388             missingFields-&gt;setTo(tempInfo);
1389             if (distance==0) {
1390                 break;
1391             }
1392         }
1393     }
1394 
1395     // If the best raw match had a specified skeleton and that skeleton was requested by the caller,
1396     // then return it too. This generally happens when the caller needs to pass that skeleton
1397     // through to adjustFieldTypes so the latter can do a better job.
1398     if (bestPattern &amp;&amp; specifiedSkeletonPtr) {
</pre>
<hr />
<pre>
1468                          adjFieldLen = field.length();
1469                     } else if (specifiedSkeleton) {
1470                         int32_t skelFieldLen = specifiedSkeleton-&gt;original.getFieldLength(typeValue);
1471                         UBool patFieldIsNumeric = (row-&gt;type &gt; 0);
1472                         UBool skelFieldIsNumeric = (specifiedSkeleton-&gt;type[typeValue] &gt; 0);
1473                         if (skelFieldLen == reqFieldLen || (patFieldIsNumeric &amp;&amp; !skelFieldIsNumeric) || (skelFieldIsNumeric &amp;&amp; !patFieldIsNumeric)) {
1474                             // don&#39;t adjust the field length in the found pattern
1475                             adjFieldLen = field.length();
1476                         }
1477                     }
1478                     UChar c = (typeValue!= UDATPG_HOUR_FIELD
1479                             &amp;&amp; typeValue!= UDATPG_MONTH_FIELD
1480                             &amp;&amp; typeValue!= UDATPG_WEEKDAY_FIELD
1481                             &amp;&amp; (typeValue!= UDATPG_YEAR_FIELD || reqFieldChar==CAP_Y))
1482                             ? reqFieldChar
1483                             : field.charAt(0);
1484                     if (typeValue == UDATPG_HOUR_FIELD &amp;&amp; (flags &amp; kDTPGSkeletonUsesCapJ) != 0) {
1485                         c = fDefaultHourFormatChar;
1486                     }
1487                     field.remove();
<span class="line-modified">1488                     for (int32_t i=adjFieldLen; i&gt;0; --i) {</span>
<span class="line-modified">1489                         field+=c;</span>
1490                     }
1491             }
1492             newPattern+=field;
1493         }
1494     }
1495     return newPattern;
1496 }
1497 
1498 UnicodeString
<span class="line-modified">1499 DateTimePatternGenerator::getBestAppending(int32_t missingFields, int32_t flags, UDateTimePatternMatchOptions options) {</span>



1500     UnicodeString  resultPattern, tempPattern;
<span class="line-modified">1501     UErrorCode err=U_ZERO_ERROR;</span>
1502     int32_t lastMissingFieldMask=0;
1503     if (missingFields!=0) {
1504         resultPattern=UnicodeString();
<span class="line-modified">1505         const PtnSkeleton* specifiedSkeleton=NULL;</span>
<span class="line-modified">1506         tempPattern = *getBestRaw(*dtMatcher, missingFields, distanceInfo, &amp;specifiedSkeleton);</span>




1507         resultPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);
1508         if ( distanceInfo-&gt;missingFieldMask==0 ) {
1509             return resultPattern;
1510         }
1511         while (distanceInfo-&gt;missingFieldMask!=0) { // precondition: EVERY single field must work!
1512             if ( lastMissingFieldMask == distanceInfo-&gt;missingFieldMask ) {
1513                 break;  // cannot find the proper missing field
1514             }
1515             if (((distanceInfo-&gt;missingFieldMask &amp; UDATPG_SECOND_AND_FRACTIONAL_MASK)==UDATPG_FRACTIONAL_MASK) &amp;&amp;
1516                 ((missingFields &amp; UDATPG_SECOND_AND_FRACTIONAL_MASK) == UDATPG_SECOND_AND_FRACTIONAL_MASK)) {
1517                 resultPattern = adjustFieldTypes(resultPattern, specifiedSkeleton, flags | kDTPGFixFractionalSeconds, options);
1518                 distanceInfo-&gt;missingFieldMask &amp;= ~UDATPG_FRACTIONAL_MASK;
1519                 continue;
1520             }
1521             int32_t startingMask = distanceInfo-&gt;missingFieldMask;
<span class="line-modified">1522             tempPattern = *getBestRaw(*dtMatcher, distanceInfo-&gt;missingFieldMask, distanceInfo, &amp;specifiedSkeleton);</span>




1523             tempPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);
1524             int32_t foundMask=startingMask&amp; ~distanceInfo-&gt;missingFieldMask;
1525             int32_t topField=getTopBitNumber(foundMask);
<span class="line-modified">1526             UnicodeString appendName;</span>
<span class="line-modified">1527             getAppendName((UDateTimePatternField)topField, appendName);</span>
<span class="line-modified">1528             const UnicodeString *values[3] = {</span>
<span class="line-modified">1529                 &amp;resultPattern,</span>
<span class="line-modified">1530                 &amp;tempPattern,</span>
<span class="line-modified">1531                 &amp;appendName</span>
<span class="line-modified">1532             };</span>
<span class="line-modified">1533             SimpleFormatter(appendItemFormats[topField], 2, 3, err).</span>
<span class="line-modified">1534                     formatAndReplace(values, 3, resultPattern, NULL, 0, err);</span>



1535             lastMissingFieldMask = distanceInfo-&gt;missingFieldMask;
1536         }
1537     }
1538     return resultPattern;
1539 }
1540 
1541 int32_t
<span class="line-modified">1542 DateTimePatternGenerator::getTopBitNumber(int32_t foundMask) {</span>
1543     if ( foundMask==0 ) {
1544         return 0;
1545     }
1546     int32_t i=0;
1547     while (foundMask!=0) {
1548         foundMask &gt;&gt;=1;
1549         ++i;
1550     }
1551     if (i-1 &gt;UDATPG_ZONE_FIELD) {
1552         return UDATPG_ZONE_FIELD;
1553     }
1554     else
1555         return i-1;
1556 }
1557 
1558 void
1559 DateTimePatternGenerator::setAvailableFormat(const UnicodeString &amp;key, UErrorCode&amp; err)
1560 {
1561     fAvailableFormatKeyHash-&gt;puti(key, 1, err);
1562 }
1563 
1564 UBool
1565 DateTimePatternGenerator::isAvailableFormatSet(const UnicodeString &amp;key) const {
1566     return (UBool)(fAvailableFormatKeyHash-&gt;geti(key) == 1);
1567 }
1568 
1569 void
1570 DateTimePatternGenerator::copyHashtable(Hashtable *other, UErrorCode &amp;status) {
<span class="line-modified">1571 </span>
<span class="line-removed">1572     if (other == NULL) {</span>
1573         return;
1574     }
<span class="line-modified">1575     if (fAvailableFormatKeyHash != NULL) {</span>
1576         delete fAvailableFormatKeyHash;
<span class="line-modified">1577         fAvailableFormatKeyHash = NULL;</span>
1578     }
1579     initHashtable(status);
1580     if(U_FAILURE(status)){
1581         return;
1582     }
1583     int32_t pos = UHASH_FIRST;
<span class="line-modified">1584     const UHashElement* elem = NULL;</span>
1585     // walk through the hash table and create a deep clone
<span class="line-modified">1586     while((elem = other-&gt;nextElement(pos))!= NULL){</span>
1587         const UHashTok otherKeyTok = elem-&gt;key;
1588         UnicodeString* otherKey = (UnicodeString*)otherKeyTok.pointer;
1589         fAvailableFormatKeyHash-&gt;puti(*otherKey, 1, status);
1590         if(U_FAILURE(status)){
1591             return;
1592         }
1593     }
1594 }
1595 
1596 StringEnumeration*
1597 DateTimePatternGenerator::getSkeletons(UErrorCode&amp; status) const {
<span class="line-modified">1598     StringEnumeration* skeletonEnumerator = new DTSkeletonEnumeration(*patternMap, DT_SKELETON, status);</span>
<span class="line-modified">1599     return skeletonEnumerator;</span>









1600 }
1601 
1602 const UnicodeString&amp;
1603 DateTimePatternGenerator::getPatternForSkeleton(const UnicodeString&amp; skeleton) const {
1604     PtnElem *curElem;
1605 
1606     if (skeleton.length() ==0) {
1607         return emptyString;
1608     }
1609     curElem = patternMap-&gt;getHeader(skeleton.charAt(0));
<span class="line-modified">1610     while ( curElem != NULL ) {</span>
1611         if ( curElem-&gt;skeleton-&gt;getSkeleton()==skeleton ) {
1612             return curElem-&gt;pattern;
1613         }
<span class="line-modified">1614         curElem=curElem-&gt;next;</span>
1615     }
1616     return emptyString;
1617 }
1618 
1619 StringEnumeration*
1620 DateTimePatternGenerator::getBaseSkeletons(UErrorCode&amp; status) const {
<span class="line-modified">1621     StringEnumeration* baseSkeletonEnumerator = new DTSkeletonEnumeration(*patternMap, DT_BASESKELETON, status);</span>
<span class="line-modified">1622     return baseSkeletonEnumerator;</span>









1623 }
1624 
1625 StringEnumeration*
1626 DateTimePatternGenerator::getRedundants(UErrorCode&amp; status) {
<span class="line-modified">1627     StringEnumeration* output = new DTRedundantEnumeration();</span>






1628     const UnicodeString *pattern;
<span class="line-modified">1629     PatternMapIterator it;</span>


1630     for (it.set(*patternMap); it.hasNext(); ) {
1631         DateTimeMatcher current = it.next();
1632         pattern = patternMap-&gt;getPatternFromSkeleton(*(it.getSkeleton()));
1633         if ( isCanonicalItem(*pattern) ) {
1634             continue;
1635         }
<span class="line-modified">1636         if ( skipMatcher == NULL ) {</span>
1637             skipMatcher = new DateTimeMatcher(current);




1638         }
1639         else {
1640             *skipMatcher = current;
1641         }
1642         UnicodeString trial = getBestPattern(current.getPattern(), status);

1643         if (trial == *pattern) {
<span class="line-modified">1644             ((DTRedundantEnumeration *)output)-&gt;add(*pattern, status);</span>

1645         }
1646         if (current.equals(skipMatcher)) {
1647             continue;
1648         }
1649     }
<span class="line-modified">1650     return output;</span>
1651 }
1652 
1653 UBool
1654 DateTimePatternGenerator::isCanonicalItem(const UnicodeString&amp; item) const {
1655     if ( item.length() != 1 ) {
1656         return FALSE;
1657     }
1658     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
1659         if (item.charAt(0)==Canonical_Items[i]) {
1660             return TRUE;
1661         }
1662     }
1663     return FALSE;
1664 }
1665 
1666 
1667 DateTimePatternGenerator*
1668 DateTimePatternGenerator::clone() const {
1669     return new DateTimePatternGenerator(*this);
1670 }
1671 
1672 PatternMap::PatternMap() {
1673    for (int32_t i=0; i &lt; MAX_PATTERN_ENTRIES; ++i ) {
<span class="line-modified">1674       boot[i]=NULL;</span>
1675    }
1676    isDupAllowed = TRUE;
1677 }
1678 
1679 void
1680 PatternMap::copyFrom(const PatternMap&amp; other, UErrorCode&amp; status) {



1681     this-&gt;isDupAllowed = other.isDupAllowed;
<span class="line-modified">1682     for (int32_t bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {</span>
<span class="line-modified">1683         PtnElem *curElem, *otherElem, *prevElem=NULL;</span>
1684         otherElem = other.boot[bootIndex];
<span class="line-modified">1685         while (otherElem!=NULL) {</span>
<span class="line-modified">1686             if ((curElem = new PtnElem(otherElem-&gt;basePattern, otherElem-&gt;pattern))==NULL) {</span>
<span class="line-modified">1687                 // out of memory</span>
<span class="line-modified">1688                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">1689                 return;</span>
1690             }
<span class="line-modified">1691             if ( this-&gt;boot[bootIndex]== NULL ) {</span>
<span class="line-modified">1692                 this-&gt;boot[bootIndex] = curElem;</span>

1693             }
<span class="line-modified">1694             if ((curElem-&gt;skeleton=new PtnSkeleton(*(otherElem-&gt;skeleton))) == NULL ) {</span>
<span class="line-modified">1695                 // out of memory</span>
<span class="line-modified">1696                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1697                 return;</span>
<span class="line-modified">1698             }</span>
<span class="line-modified">1699             curElem-&gt;skeletonWasSpecified = otherElem-&gt;skeletonWasSpecified;</span>
<span class="line-modified">1700             if (prevElem!=NULL) {</span>
<span class="line-modified">1701                 prevElem-&gt;next=curElem;</span>







1702             }
<span class="line-removed">1703             curElem-&gt;next=NULL;</span>
1704             prevElem = curElem;
<span class="line-modified">1705             otherElem = otherElem-&gt;next;</span>
1706         }
1707 
1708     }
1709 }
1710 
1711 PtnElem*
<span class="line-modified">1712 PatternMap::getHeader(UChar baseChar) {</span>
1713     PtnElem* curElem;
1714 
1715     if ( (baseChar &gt;= CAP_A) &amp;&amp; (baseChar &lt;= CAP_Z) ) {
1716          curElem = boot[baseChar-CAP_A];
1717     }
1718     else {
1719         if ( (baseChar &gt;=LOW_A) &amp;&amp; (baseChar &lt;= LOW_Z) ) {
1720             curElem = boot[26+baseChar-LOW_A];
1721         }
1722         else {
<span class="line-modified">1723             return NULL;</span>
1724         }
1725     }
1726     return curElem;
1727 }
1728 
1729 PatternMap::~PatternMap() {
1730    for (int32_t i=0; i &lt; MAX_PATTERN_ENTRIES; ++i ) {
<span class="line-modified">1731        if (boot[i]!=NULL ) {</span>
1732            delete boot[i];
<span class="line-modified">1733            boot[i]=NULL;</span>
1734        }
1735    }
1736 }  // PatternMap destructor
1737 
1738 void
1739 PatternMap::add(const UnicodeString&amp; basePattern,
1740                 const PtnSkeleton&amp; skeleton,
1741                 const UnicodeString&amp; value,// mapped pattern value
1742                 UBool skeletonWasSpecified,
1743                 UErrorCode &amp;status) {
1744     UChar baseChar = basePattern.charAt(0);
1745     PtnElem *curElem, *baseElem;
1746     status = U_ZERO_ERROR;
1747 
1748     // the baseChar must be A-Z or a-z
1749     if ((baseChar &gt;= CAP_A) &amp;&amp; (baseChar &lt;= CAP_Z)) {
1750         baseElem = boot[baseChar-CAP_A];
1751     }
1752     else {
1753         if ((baseChar &gt;=LOW_A) &amp;&amp; (baseChar &lt;= LOW_Z)) {
1754             baseElem = boot[26+baseChar-LOW_A];
1755          }
1756          else {
1757              status = U_ILLEGAL_CHARACTER;
1758              return;
1759          }
1760     }
1761 
<span class="line-modified">1762     if (baseElem == NULL) {</span>
<span class="line-modified">1763         if ((curElem = new PtnElem(basePattern, value)) == NULL ) {</span>
<span class="line-modified">1764             // out of memory</span>
<span class="line-modified">1765             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1766             return;</span>



1767         }

1768         if (baseChar &gt;= LOW_A) {
<span class="line-modified">1769             boot[26 + (baseChar-LOW_A)] = curElem;</span>
1770         }
1771         else {
<span class="line-modified">1772             boot[baseChar-CAP_A] = curElem;</span>
1773         }
<span class="line-removed">1774         curElem-&gt;skeleton = new PtnSkeleton(skeleton);</span>
<span class="line-removed">1775         curElem-&gt;skeletonWasSpecified = skeletonWasSpecified;</span>
1776     }
<span class="line-modified">1777     if ( baseElem != NULL ) {</span>
1778         curElem = getDuplicateElem(basePattern, skeleton, baseElem);
1779 
<span class="line-modified">1780         if (curElem == NULL) {</span>
1781             // add new element to the list.
1782             curElem = baseElem;
<span class="line-modified">1783             while( curElem -&gt; next != NULL )</span>
1784             {
<span class="line-modified">1785                 curElem = curElem-&gt;next;</span>
1786             }
<span class="line-modified">1787             if ((curElem-&gt;next = new PtnElem(basePattern, value)) == NULL ) {</span>
<span class="line-modified">1788                 // out of memory</span>
<span class="line-modified">1789                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1790                 return;</span>
1791             }
<span class="line-modified">1792             curElem=curElem-&gt;next;</span>
<span class="line-modified">1793             curElem-&gt;skeleton = new PtnSkeleton(skeleton);</span>
<span class="line-modified">1794             curElem-&gt;skeletonWasSpecified = skeletonWasSpecified;</span>




1795         }
1796         else {
1797             // Pattern exists in the list already.
1798             if ( !isDupAllowed ) {
1799                 return;
1800             }
1801             // Overwrite the value.
1802             curElem-&gt;pattern = value;
1803             // It was a bug that we were not doing the following previously,
1804             // though that bug hid other problems by making things partly work.
1805             curElem-&gt;skeletonWasSpecified = skeletonWasSpecified;
1806         }
1807     }
1808 }  // PatternMap::add
1809 
1810 // Find the pattern from the given basePattern string.
1811 const UnicodeString *
<span class="line-modified">1812 PatternMap::getPatternFromBasePattern(UnicodeString&amp; basePattern, UBool&amp; skeletonWasSpecified) { // key to search for</span>
1813    PtnElem *curElem;
1814 
<span class="line-modified">1815    if ((curElem=getHeader(basePattern.charAt(0)))==NULL) {</span>
<span class="line-modified">1816        return NULL;  // no match</span>
1817    }
1818 
1819    do  {
1820        if ( basePattern.compare(curElem-&gt;basePattern)==0 ) {
1821           skeletonWasSpecified = curElem-&gt;skeletonWasSpecified;
1822           return &amp;(curElem-&gt;pattern);
1823        }
<span class="line-modified">1824        curElem=curElem-&gt;next;</span>
<span class="line-modified">1825    }while (curElem != NULL);</span>
1826 
<span class="line-modified">1827    return NULL;</span>
1828 }  // PatternMap::getFromBasePattern
1829 
1830 
1831 // Find the pattern from the given skeleton.
1832 // At least when this is called from getBestRaw &amp; addPattern (in which case specifiedSkeletonPtr is non-NULL),
1833 // the comparison should be based on skeleton.original (which is unique and tied to the distance measurement in bestRaw)
1834 // and not skeleton.baseOriginal (which is not unique); otherwise we may pick a different skeleton than the one with the
1835 // optimum distance value in getBestRaw. When this is called from public getRedundants (specifiedSkeletonPtr is NULL),
1836 // for now it will continue to compare based on baseOriginal so as not to change the behavior unnecessarily.
1837 const UnicodeString *
<span class="line-modified">1838 PatternMap::getPatternFromSkeleton(PtnSkeleton&amp; skeleton, const PtnSkeleton** specifiedSkeletonPtr) { // key to search for</span>
1839    PtnElem *curElem;
1840 
1841    if (specifiedSkeletonPtr) {
<span class="line-modified">1842        *specifiedSkeletonPtr = NULL;</span>
1843    }
1844 
1845    // find boot entry
1846    UChar baseChar = skeleton.getFirstChar();
<span class="line-modified">1847    if ((curElem=getHeader(baseChar))==NULL) {</span>
<span class="line-modified">1848        return NULL;  // no match</span>
1849    }
1850 
1851    do  {
1852        UBool equal;
<span class="line-modified">1853        if (specifiedSkeletonPtr != NULL) { // called from DateTimePatternGenerator::getBestRaw or addPattern, use original</span>
1854            equal = curElem-&gt;skeleton-&gt;original == skeleton.original;
1855        } else { // called from DateTimePatternGenerator::getRedundants, use baseOriginal
1856            equal = curElem-&gt;skeleton-&gt;baseOriginal == skeleton.baseOriginal;
1857        }
1858        if (equal) {
1859            if (specifiedSkeletonPtr &amp;&amp; curElem-&gt;skeletonWasSpecified) {
<span class="line-modified">1860                *specifiedSkeletonPtr = curElem-&gt;skeleton;</span>
1861            }
1862            return &amp;(curElem-&gt;pattern);
1863        }
<span class="line-modified">1864        curElem=curElem-&gt;next;</span>
<span class="line-modified">1865    }while (curElem != NULL);</span>
1866 
<span class="line-modified">1867    return NULL;</span>
1868 }
1869 
1870 UBool
<span class="line-modified">1871 PatternMap::equals(const PatternMap&amp; other) {</span>
1872     if ( this==&amp;other ) {
1873         return TRUE;
1874     }
<span class="line-modified">1875     for (int32_t bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {</span>
<span class="line-modified">1876         if ( boot[bootIndex]==other.boot[bootIndex] ) {</span>
1877             continue;
1878         }
<span class="line-modified">1879         if ( (boot[bootIndex]==NULL)||(other.boot[bootIndex]==NULL) ) {</span>
1880             return FALSE;
1881         }
1882         PtnElem *otherElem = other.boot[bootIndex];
1883         PtnElem *myElem = boot[bootIndex];
<span class="line-modified">1884         while ((otherElem!=NULL) || (myElem!=NULL)) {</span>
1885             if ( myElem == otherElem ) {
1886                 break;
1887             }
<span class="line-modified">1888             if ((otherElem==NULL) || (myElem==NULL)) {</span>
1889                 return FALSE;
1890             }
1891             if ( (myElem-&gt;basePattern != otherElem-&gt;basePattern) ||
1892                  (myElem-&gt;pattern != otherElem-&gt;pattern) ) {
1893                 return FALSE;
1894             }
<span class="line-modified">1895             if ((myElem-&gt;skeleton!=otherElem-&gt;skeleton)&amp;&amp;</span>
1896                 !myElem-&gt;skeleton-&gt;equals(*(otherElem-&gt;skeleton))) {
1897                 return FALSE;
1898             }
<span class="line-modified">1899             myElem = myElem-&gt;next;</span>
<span class="line-modified">1900             otherElem=otherElem-&gt;next;</span>
1901         }
1902     }
1903     return TRUE;
1904 }
1905 
1906 // find any key existing in the mapping table already.
1907 // return TRUE if there is an existing key, otherwise return FALSE.
1908 PtnElem*
1909 PatternMap::getDuplicateElem(
1910             const UnicodeString &amp;basePattern,
1911             const PtnSkeleton &amp;skeleton,
<span class="line-modified">1912             PtnElem *baseElem)  {</span>
1913    PtnElem *curElem;
1914 
<span class="line-modified">1915    if ( baseElem == (PtnElem *)NULL )  {</span>
<span class="line-modified">1916          return (PtnElem*)NULL;</span>
1917    }
1918    else {
1919          curElem = baseElem;
1920    }
1921    do {
1922      if ( basePattern.compare(curElem-&gt;basePattern)==0 ) {
<span class="line-modified">1923         UBool isEqual=TRUE;</span>
<span class="line-modified">1924         for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {</span>
1925             if (curElem-&gt;skeleton-&gt;type[i] != skeleton.type[i] ) {
<span class="line-modified">1926                 isEqual=FALSE;</span>
1927                 break;
1928             }
1929         }
1930         if (isEqual) {
1931             return curElem;
1932         }
1933      }
<span class="line-modified">1934      curElem = curElem-&gt;next;</span>
<span class="line-modified">1935    } while( curElem != (PtnElem *)NULL );</span>
1936 
1937    // end of the list
<span class="line-modified">1938    return (PtnElem*)NULL;</span>
1939 
1940 }  // PatternMap::getDuplicateElem
1941 
1942 DateTimeMatcher::DateTimeMatcher(void) {
1943 }
1944 
1945 DateTimeMatcher::~DateTimeMatcher() {}
1946 
1947 DateTimeMatcher::DateTimeMatcher(const DateTimeMatcher&amp; other) {
1948     copyFrom(other.skeleton);
1949 }
1950 
1951 
1952 void
1953 DateTimeMatcher::set(const UnicodeString&amp; pattern, FormatParser* fp) {
1954     PtnSkeleton localSkeleton;
1955     return set(pattern, fp, localSkeleton);
1956 }
1957 
1958 void
1959 DateTimeMatcher::set(const UnicodeString&amp; pattern, FormatParser* fp, PtnSkeleton&amp; skeletonResult) {
1960     int32_t i;
1961     for (i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
1962         skeletonResult.type[i] = NONE;
1963     }
1964     skeletonResult.original.clear();
1965     skeletonResult.baseOriginal.clear();
1966     skeletonResult.addedDefaultDayPeriod = FALSE;
1967 
1968     fp-&gt;set(pattern);
1969     for (i=0; i &lt; fp-&gt;itemNumber; i++) {
1970         const UnicodeString&amp; value = fp-&gt;items[i];
1971         // don&#39;t skip &#39;a&#39; anymore, dayPeriod handled specially below
1972 
1973         if ( fp-&gt;isQuoteLiteral(value) ) {
1974             UnicodeString quoteLiteral;
1975             fp-&gt;getQuoteLiteral(quoteLiteral, &amp;i);
1976             continue;
1977         }
1978         int32_t canonicalIndex = fp-&gt;getCanonicalIndex(value);
<span class="line-modified">1979         if (canonicalIndex &lt; 0 ) {</span>
1980             continue;
1981         }
1982         const dtTypeElem *row = &amp;dtTypes[canonicalIndex];
1983         int32_t field = row-&gt;field;
1984         skeletonResult.original.populate(field, value);
1985         UChar repeatChar = row-&gt;patternChar;
1986         int32_t repeatCount = row-&gt;minLen;
1987         skeletonResult.baseOriginal.populate(field, repeatChar, repeatCount);
1988         int16_t subField = row-&gt;type;
<span class="line-modified">1989         if ( row-&gt;type &gt; 0) {</span>
<span class="line-modified">1990             subField += value.length();</span>

1991         }
1992         skeletonResult.type[field] = subField;
1993     }
1994     // #13183, handle special behavior for day period characters (a, b, B)
1995     if (!skeletonResult.original.isFieldEmpty(UDATPG_HOUR_FIELD)) {
1996         if (skeletonResult.original.getFieldChar(UDATPG_HOUR_FIELD)==LOW_H || skeletonResult.original.getFieldChar(UDATPG_HOUR_FIELD)==CAP_K) {
1997             // We have a skeleton with 12-hour-cycle format
1998             if (skeletonResult.original.isFieldEmpty(UDATPG_DAYPERIOD_FIELD)) {
1999                 // But we do not have a day period in the skeleton; add the default DAYPERIOD (currently &quot;a&quot;)
2000                 for (i = 0; dtTypes[i].patternChar != 0; i++) {
2001                     if ( dtTypes[i].field == UDATPG_DAYPERIOD_FIELD ) {
2002                         // first entry for UDATPG_DAYPERIOD_FIELD
2003                         skeletonResult.original.populate(UDATPG_DAYPERIOD_FIELD, dtTypes[i].patternChar, dtTypes[i].minLen);
2004                         skeletonResult.baseOriginal.populate(UDATPG_DAYPERIOD_FIELD, dtTypes[i].patternChar, dtTypes[i].minLen);
2005                         skeletonResult.type[UDATPG_DAYPERIOD_FIELD] = dtTypes[i].type;
2006                         skeletonResult.addedDefaultDayPeriod = TRUE;
2007                         break;
2008                     }
2009                 }
2010             }
</pre>
<hr />
<pre>
2014             skeletonResult.baseOriginal.clearField(UDATPG_DAYPERIOD_FIELD);
2015             skeletonResult.type[UDATPG_DAYPERIOD_FIELD] = NONE;
2016         }
2017     }
2018     copyFrom(skeletonResult);
2019 }
2020 
2021 void
2022 DateTimeMatcher::getBasePattern(UnicodeString &amp;result ) {
2023     result.remove(); // Reset the result first.
2024     skeleton.baseOriginal.appendTo(result);
2025 }
2026 
2027 UnicodeString
2028 DateTimeMatcher::getPattern() {
2029     UnicodeString result;
2030     return skeleton.original.appendTo(result);
2031 }
2032 
2033 int32_t
<span class="line-modified">2034 DateTimeMatcher::getDistance(const DateTimeMatcher&amp; other, int32_t includeMask, DistanceInfo&amp; distanceInfo) {</span>
<span class="line-modified">2035     int32_t result=0;</span>
2036     distanceInfo.clear();
2037     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
2038         int32_t myType = (includeMask&amp;(1&lt;&lt;i))==0 ? 0 : skeleton.type[i];
2039         int32_t otherType = other.skeleton.type[i];
2040         if (myType==otherType) {
2041             continue;
2042         }
2043         if (myType==0) {// and other is not
2044             result += EXTRA_FIELD;
2045             distanceInfo.addExtra(i);
2046         }
2047         else {
2048             if (otherType==0) {
2049                 result += MISSING_FIELD;
2050                 distanceInfo.addMissing(i);
2051             }
2052             else {
2053                 result += abs(myType - otherType);
2054             }
2055         }
2056 
2057     }
2058     return result;
2059 }
2060 
2061 void
2062 DateTimeMatcher::copyFrom(const PtnSkeleton&amp; newSkeleton) {
2063     skeleton.copyFrom(newSkeleton);
2064 }
2065 
2066 void
2067 DateTimeMatcher::copyFrom() {
2068     // same as clear
2069     skeleton.clear();
2070 }
2071 
2072 UBool
2073 DateTimeMatcher::equals(const DateTimeMatcher* other) const {
<span class="line-modified">2074     if (other==NULL) { return FALSE; }</span>
2075     return skeleton.original == other-&gt;skeleton.original;
2076 }
2077 
2078 int32_t
<span class="line-modified">2079 DateTimeMatcher::getFieldMask() {</span>
<span class="line-modified">2080     int32_t result=0;</span>
2081 
2082     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
2083         if (skeleton.type[i]!=0) {
2084             result |= (1&lt;&lt;i);
2085         }
2086     }
2087     return result;
2088 }
2089 
2090 PtnSkeleton*
2091 DateTimeMatcher::getSkeletonPtr() {
2092     return &amp;skeleton;
2093 }
2094 
2095 FormatParser::FormatParser () {
2096     status = START;
<span class="line-modified">2097     itemNumber=0;</span>
2098 }
2099 
2100 
2101 FormatParser::~FormatParser () {
2102 }
2103 
2104 
2105 // Find the next token with the starting position and length
2106 // Note: the startPos may
2107 FormatParser::TokenStatus
2108 FormatParser::setTokens(const UnicodeString&amp; pattern, int32_t startPos, int32_t *len) {
<span class="line-modified">2109     int32_t  curLoc = startPos;</span>
2110     if ( curLoc &gt;= pattern.length()) {
2111         return DONE;
2112     }
2113     // check the current char is between A-Z or a-z
2114     do {
2115         UChar c=pattern.charAt(curLoc);
2116         if ( (c&gt;=CAP_A &amp;&amp; c&lt;=CAP_Z) || (c&gt;=LOW_A &amp;&amp; c&lt;=LOW_Z) ) {
2117            curLoc++;
2118         }
2119         else {
2120                startPos = curLoc;
2121                *len=1;
2122                return ADD_TOKEN;
2123         }
2124 
2125         if ( pattern.charAt(curLoc)!= pattern.charAt(startPos) ) {
2126             break;  // not the same token
2127         }
2128     } while(curLoc &lt;= pattern.length());
2129     *len = curLoc-startPos;
2130     return ADD_TOKEN;
2131 }
2132 
2133 void
2134 FormatParser::set(const UnicodeString&amp; pattern) {
<span class="line-modified">2135     int32_t startPos=0;</span>
<span class="line-modified">2136     TokenStatus result=START;</span>
<span class="line-modified">2137     int32_t len=0;</span>
<span class="line-modified">2138     itemNumber =0;</span>
2139 
2140     do {
2141         result = setTokens( pattern, startPos, &amp;len );
2142         if ( result == ADD_TOKEN )
2143         {
2144             items[itemNumber++] = UnicodeString(pattern, startPos, len );
2145             startPos += len;
2146         }
2147         else {
2148             break;
2149         }
2150     } while (result==ADD_TOKEN &amp;&amp; itemNumber &lt; MAX_DT_TOKEN);
2151 }
2152 
2153 int32_t
2154 FormatParser::getCanonicalIndex(const UnicodeString&amp; s, UBool strict) {
2155     int32_t len = s.length();
2156     if (len == 0) {
2157         return -1;
2158     }
</pre>
<hr />
<pre>
2169     while (dtTypes[i].patternChar != 0x0000) {
2170         if ( dtTypes[i].patternChar != ch ) {
2171             ++i;
2172             continue;
2173         }
2174         bestRow = i;
2175         if (dtTypes[i].patternChar != dtTypes[i+1].patternChar) {
2176             return i;
2177         }
2178         if (dtTypes[i+1].minLen &lt;= len) {
2179             ++i;
2180             continue;
2181         }
2182         return i;
2183     }
2184     return strict ? -1 : bestRow;
2185 }
2186 
2187 UBool
2188 FormatParser::isQuoteLiteral(const UnicodeString&amp; s) {
<span class="line-modified">2189     return (UBool)(s.charAt(0)==SINGLE_QUOTE);</span>
2190 }
2191 
<span class="line-modified">2192 // This function aussumes the current itemIndex points to the quote literal.</span>
2193 // Please call isQuoteLiteral prior to this function.
2194 void
2195 FormatParser::getQuoteLiteral(UnicodeString&amp; quote, int32_t *itemIndex) {
<span class="line-modified">2196     int32_t i=*itemIndex;</span>
2197 
2198     quote.remove();
2199     if (items[i].charAt(0)==SINGLE_QUOTE) {
2200         quote += items[i];
2201         ++i;
2202     }
2203     while ( i &lt; itemNumber ) {
2204         if ( items[i].charAt(0)==SINGLE_QUOTE ) {
2205             if ( (i+1&lt;itemNumber) &amp;&amp; (items[i+1].charAt(0)==SINGLE_QUOTE)) {
2206                 // two single quotes e.g. &#39;o&#39;&#39;clock&#39;
2207                 quote += items[i++];
2208                 quote += items[i++];
2209                 continue;
2210             }
2211             else {
2212                 quote += items[i];
2213                 break;
2214             }
2215         }
2216         else {
2217             quote += items[i];
2218         }
2219         ++i;
2220     }
2221     *itemIndex=i;
2222 }
2223 
2224 UBool
<span class="line-modified">2225 FormatParser::isPatternSeparator(UnicodeString&amp; field) {</span>
2226     for (int32_t i=0; i&lt;field.length(); ++i ) {
2227         UChar c= field.charAt(i);
2228         if ( (c==SINGLE_QUOTE) || (c==BACKSLASH) || (c==SPACE) || (c==COLON) ||
2229              (c==QUOTATION_MARK) || (c==COMMA) || (c==HYPHEN) ||(items[i].charAt(0)==DOT) ) {
2230             continue;
2231         }
2232         else {
2233             return FALSE;
2234         }
2235     }
2236     return TRUE;
2237 }
2238 
2239 DistanceInfo::~DistanceInfo() {}
2240 
2241 void
<span class="line-modified">2242 DistanceInfo::setTo(DistanceInfo &amp;other) {</span>
2243     missingFieldMask = other.missingFieldMask;
2244     extraFieldMask= other.extraFieldMask;
2245 }
2246 
<span class="line-modified">2247 PatternMapIterator::PatternMapIterator() {</span>
<span class="line-modified">2248     bootIndex = 0;</span>
<span class="line-modified">2249     nodePtr = NULL;</span>
<span class="line-modified">2250     patternMap=NULL;</span>
<span class="line-modified">2251     matcher= new DateTimeMatcher();</span>
2252 }
2253 
<span class="line-removed">2254 </span>
2255 PatternMapIterator::~PatternMapIterator() {
<span class="line-removed">2256     delete matcher;</span>
2257 }
2258 
2259 void
2260 PatternMapIterator::set(PatternMap&amp; newPatternMap) {
2261     this-&gt;patternMap=&amp;newPatternMap;
2262 }
2263 
2264 PtnSkeleton*
<span class="line-modified">2265 PatternMapIterator::getSkeleton() {</span>
<span class="line-modified">2266     if ( nodePtr == NULL ) {</span>
<span class="line-modified">2267         return NULL;</span>
2268     }
2269     else {
<span class="line-modified">2270         return nodePtr-&gt;skeleton;</span>
2271     }
2272 }
2273 
2274 UBool
<span class="line-modified">2275 PatternMapIterator::hasNext() {</span>
<span class="line-modified">2276     int32_t headIndex=bootIndex;</span>
<span class="line-modified">2277     PtnElem *curPtr=nodePtr;</span>
2278 
<span class="line-modified">2279     if (patternMap==NULL) {</span>
2280         return FALSE;
2281     }
2282     while ( headIndex &lt; MAX_PATTERN_ENTRIES ) {
<span class="line-modified">2283         if ( curPtr != NULL ) {</span>
<span class="line-modified">2284             if ( curPtr-&gt;next != NULL ) {</span>
2285                 return TRUE;
2286             }
2287             else {
2288                 headIndex++;
<span class="line-modified">2289                 curPtr=NULL;</span>
2290                 continue;
2291             }
2292         }
2293         else {
<span class="line-modified">2294             if ( patternMap-&gt;boot[headIndex] != NULL ) {</span>
2295                 return TRUE;
2296             }
2297             else {
2298                 headIndex++;
2299                 continue;
2300             }
2301         }
<span class="line-removed">2302 </span>
2303     }
2304     return FALSE;
2305 }
2306 
2307 DateTimeMatcher&amp;
2308 PatternMapIterator::next() {
2309     while ( bootIndex &lt; MAX_PATTERN_ENTRIES ) {
<span class="line-modified">2310         if ( nodePtr != NULL ) {</span>
<span class="line-modified">2311             if ( nodePtr-&gt;next != NULL ) {</span>
<span class="line-modified">2312                 nodePtr = nodePtr-&gt;next;</span>
2313                 break;
2314             }
2315             else {
2316                 bootIndex++;
<span class="line-modified">2317                 nodePtr=NULL;</span>
2318                 continue;
2319             }
2320         }
2321         else {
<span class="line-modified">2322             if ( patternMap-&gt;boot[bootIndex] != NULL ) {</span>
2323                 nodePtr = patternMap-&gt;boot[bootIndex];
2324                 break;
2325             }
2326             else {
2327                 bootIndex++;
2328                 continue;
2329             }
2330         }
2331     }
<span class="line-modified">2332     if (nodePtr!=NULL) {</span>
2333         matcher-&gt;copyFrom(*nodePtr-&gt;skeleton);
2334     }
2335     else {
2336         matcher-&gt;copyFrom();
2337     }
2338     return *matcher;
2339 }
2340 
2341 
2342 SkeletonFields::SkeletonFields() {
2343     // Set initial values to zero
2344     clear();
2345 }
2346 
2347 void SkeletonFields::clear() {
2348     uprv_memset(chars, 0, sizeof(chars));
2349     uprv_memset(lengths, 0, sizeof(lengths));
2350 }
2351 
2352 void SkeletonFields::copyFrom(const SkeletonFields&amp; other) {
</pre>
<hr />
<pre>
2451     UnicodeString result;
2452     result = baseOriginal.appendTo(result);
2453     int32_t pos;
2454     if (addedDefaultDayPeriod &amp;&amp; (pos = result.indexOf(LOW_A)) &gt;= 0) {
2455         // for backward compatibility: if DateTimeMatcher.set added a single &#39;a&#39; that
2456         // was not in the provided skeleton, remove it here before returning skeleton.
2457         result.remove(pos, 1);
2458     }
2459     return result;
2460 }
2461 
2462 UChar
2463 PtnSkeleton::getFirstChar() const {
2464     return baseOriginal.getFirstChar();
2465 }
2466 
2467 PtnSkeleton::~PtnSkeleton() {
2468 }
2469 
2470 PtnElem::PtnElem(const UnicodeString &amp;basePat, const UnicodeString &amp;pat) :
<span class="line-modified">2471 basePattern(basePat),</span>
<span class="line-removed">2472 skeleton(NULL),</span>
<span class="line-removed">2473 pattern(pat),</span>
<span class="line-removed">2474 next(NULL)</span>
2475 {
2476 }
2477 
2478 PtnElem::~PtnElem() {
<span class="line-removed">2479 </span>
<span class="line-removed">2480     if (next!=NULL) {</span>
<span class="line-removed">2481         delete next;</span>
<span class="line-removed">2482     }</span>
<span class="line-removed">2483     delete skeleton;</span>
2484 }
2485 
<span class="line-modified">2486 DTSkeletonEnumeration::DTSkeletonEnumeration(PatternMap &amp;patternMap, dtStrEnum type, UErrorCode&amp; status) {</span>
2487     PtnElem  *curElem;
2488     PtnSkeleton *curSkeleton;
2489     UnicodeString s;
2490     int32_t bootIndex;
2491 
2492     pos=0;
<span class="line-modified">2493     fSkeletons = new UVector(status);</span>
2494     if (U_FAILURE(status)) {
<span class="line-removed">2495         delete fSkeletons;</span>
2496         return;
2497     }

2498     for (bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {
2499         curElem = patternMap.boot[bootIndex];
<span class="line-modified">2500         while (curElem!=NULL) {</span>
2501             switch(type) {
2502                 case DT_BASESKELETON:
2503                     s=curElem-&gt;basePattern;
2504                     break;
2505                 case DT_PATTERN:
2506                     s=curElem-&gt;pattern;
2507                     break;
2508                 case DT_SKELETON:
<span class="line-modified">2509                     curSkeleton=curElem-&gt;skeleton;</span>
2510                     s=curSkeleton-&gt;getSkeleton();
2511                     break;
2512             }
2513             if ( !isCanonicalItem(s) ) {
<span class="line-modified">2514                 fSkeletons-&gt;addElement(new UnicodeString(s), status);</span>




2515                 if (U_FAILURE(status)) {
<span class="line-modified">2516                     delete fSkeletons;</span>
<span class="line-removed">2517                     fSkeletons = NULL;</span>
2518                     return;
2519                 }

2520             }
<span class="line-modified">2521             curElem = curElem-&gt;next;</span>
2522         }
2523     }
<span class="line-modified">2524     if ((bootIndex==MAX_PATTERN_ENTRIES) &amp;&amp; (curElem!=NULL) ) {</span>
2525         status = U_BUFFER_OVERFLOW_ERROR;
2526     }
2527 }
2528 
2529 const UnicodeString*
2530 DTSkeletonEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">2531     if (U_SUCCESS(status) &amp;&amp; pos &lt; fSkeletons-&gt;size()) {</span>
2532         return (const UnicodeString*)fSkeletons-&gt;elementAt(pos++);
2533     }
<span class="line-modified">2534     return NULL;</span>
2535 }
2536 
2537 void
2538 DTSkeletonEnumeration::reset(UErrorCode&amp; /*status*/) {
2539     pos=0;
2540 }
2541 
2542 int32_t
2543 DTSkeletonEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">2544    return (fSkeletons==NULL) ? 0 : fSkeletons-&gt;size();</span>
2545 }
2546 
2547 UBool
2548 DTSkeletonEnumeration::isCanonicalItem(const UnicodeString&amp; item) {
2549     if ( item.length() != 1 ) {
2550         return FALSE;
2551     }
2552     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
2553         if (item.charAt(0)==Canonical_Items[i]) {
2554             return TRUE;
2555         }
2556     }
2557     return FALSE;
2558 }
2559 
2560 DTSkeletonEnumeration::~DTSkeletonEnumeration() {
2561     UnicodeString *s;
<span class="line-modified">2562     for (int32_t i=0; i&lt;fSkeletons-&gt;size(); ++i) {</span>
<span class="line-modified">2563         if ((s=(UnicodeString *)fSkeletons-&gt;elementAt(i))!=NULL) {</span>
<span class="line-modified">2564             delete s;</span>


2565         }
2566     }
<span class="line-removed">2567     delete fSkeletons;</span>
2568 }
2569 
<span class="line-modified">2570 DTRedundantEnumeration::DTRedundantEnumeration() {</span>
<span class="line-removed">2571     pos=0;</span>
<span class="line-removed">2572     fPatterns = NULL;</span>
2573 }
2574 
2575 void
2576 DTRedundantEnumeration::add(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
<span class="line-modified">2577     if (U_FAILURE(status)) return;</span>
<span class="line-modified">2578     if (fPatterns == NULL)  {</span>
<span class="line-modified">2579         fPatterns = new UVector(status);</span>
2580         if (U_FAILURE(status)) {
<span class="line-removed">2581             delete fPatterns;</span>
<span class="line-removed">2582             fPatterns = NULL;</span>
2583             return;
2584        }
2585     }
<span class="line-modified">2586     fPatterns-&gt;addElement(new UnicodeString(pattern), status);</span>
2587     if (U_FAILURE(status)) {
<span class="line-removed">2588         delete fPatterns;</span>
<span class="line-removed">2589         fPatterns = NULL;</span>
2590         return;
2591     }






2592 }
2593 
2594 const UnicodeString*
2595 DTRedundantEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">2596     if (U_SUCCESS(status) &amp;&amp; pos &lt; fPatterns-&gt;size()) {</span>
2597         return (const UnicodeString*)fPatterns-&gt;elementAt(pos++);
2598     }
<span class="line-modified">2599     return NULL;</span>
2600 }
2601 
2602 void
2603 DTRedundantEnumeration::reset(UErrorCode&amp; /*status*/) {
2604     pos=0;
2605 }
2606 
2607 int32_t
2608 DTRedundantEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">2609        return (fPatterns==NULL) ? 0 : fPatterns-&gt;size();</span>
2610 }
2611 
2612 UBool
<span class="line-modified">2613 DTRedundantEnumeration::isCanonicalItem(const UnicodeString&amp; item) {</span>
2614     if ( item.length() != 1 ) {
2615         return FALSE;
2616     }
2617     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
2618         if (item.charAt(0)==Canonical_Items[i]) {
2619             return TRUE;
2620         }
2621     }
2622     return FALSE;
2623 }
2624 
2625 DTRedundantEnumeration::~DTRedundantEnumeration() {
2626     UnicodeString *s;
<span class="line-modified">2627     for (int32_t i=0; i&lt;fPatterns-&gt;size(); ++i) {</span>
<span class="line-modified">2628         if ((s=(UnicodeString *)fPatterns-&gt;elementAt(i))!=NULL) {</span>
<span class="line-modified">2629             delete s;</span>


2630         }
2631     }
<span class="line-removed">2632     delete fPatterns;</span>
2633 }
2634 
2635 U_NAMESPACE_END
2636 
2637 
2638 #endif /* #if !UCONFIG_NO_FORMATTING */
2639 
2640 //eof
</pre>
</td>
<td>
<hr />
<pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 2007-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 *******************************************************************************
   8 *
   9 * File DTPTNGEN.CPP
  10 *
  11 *******************************************************************************
  12 */
  13 
  14 #include &quot;unicode/utypes.h&quot;
  15 #if !UCONFIG_NO_FORMATTING
  16 
  17 #include &quot;unicode/datefmt.h&quot;
  18 #include &quot;unicode/decimfmt.h&quot;
  19 #include &quot;unicode/dtfmtsym.h&quot;
  20 #include &quot;unicode/dtptngen.h&quot;
<span class="line-added">  21 #include &quot;unicode/localpointer.h&quot;</span>
  22 #include &quot;unicode/simpleformatter.h&quot;
  23 #include &quot;unicode/smpdtfmt.h&quot;
  24 #include &quot;unicode/udat.h&quot;
  25 #include &quot;unicode/udatpg.h&quot;
  26 #include &quot;unicode/uniset.h&quot;
  27 #include &quot;unicode/uloc.h&quot;
  28 #include &quot;unicode/ures.h&quot;
  29 #include &quot;unicode/ustring.h&quot;
  30 #include &quot;unicode/rep.h&quot;
  31 #include &quot;cpputils.h&quot;
  32 #include &quot;mutex.h&quot;
  33 #include &quot;umutex.h&quot;
  34 #include &quot;cmemory.h&quot;
  35 #include &quot;cstring.h&quot;
  36 #include &quot;locbased.h&quot;
  37 #include &quot;hash.h&quot;
  38 #include &quot;uhash.h&quot;
  39 #include &quot;uresimp.h&quot;
  40 #include &quot;dtptngen_impl.h&quot;
  41 #include &quot;ucln_in.h&quot;
</pre>
<hr />
<pre>
  72 
  73 U_CDECL_BEGIN
  74 
  75 static int32_t U_CALLCONV
  76 ures_a_codepointSort(const void *context, const void *left, const void *right) {
  77     //CompareContext *cmp=(CompareContext *)context;
  78     return u_strcmp(((const UResAEntry *)left)-&gt;key,
  79                     ((const UResAEntry *)right)-&gt;key);
  80 }
  81 
  82 U_CDECL_END
  83 
  84 static void ures_a_open(UResourceBundleAIterator *aiter, UResourceBundle *bund, UErrorCode *status) {
  85     if(U_FAILURE(*status)) {
  86         return;
  87     }
  88     aiter-&gt;bund = bund;
  89     aiter-&gt;num = ures_getSize(aiter-&gt;bund);
  90     aiter-&gt;cursor = 0;
  91 #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)
<span class="line-modified">  92     aiter-&gt;entries = nullptr;</span>
  93 #else
  94     aiter-&gt;entries = (UResAEntry*)uprv_malloc(sizeof(UResAEntry)*aiter-&gt;num);
  95     for(int i=0;i&lt;aiter-&gt;num;i++) {
<span class="line-modified">  96         aiter-&gt;entries[i].item = ures_getByIndex(aiter-&gt;bund, i, nullptr, status);</span>
  97         const char *akey = ures_getKey(aiter-&gt;entries[i].item);
  98         int32_t len = uprv_strlen(akey)+1;
  99         aiter-&gt;entries[i].key = (UChar*)uprv_malloc(len*sizeof(UChar));
 100         u_charsToUChars(akey, aiter-&gt;entries[i].key, len);
 101     }
<span class="line-modified"> 102     uprv_sortArray(aiter-&gt;entries, aiter-&gt;num, sizeof(UResAEntry), ures_a_codepointSort, nullptr, TRUE, status);</span>
 103 #endif
 104 }
 105 
 106 static void ures_a_close(UResourceBundleAIterator *aiter) {
 107 #if defined(U_SORT_ASCII_BUNDLE_ITERATOR)
 108     for(int i=0;i&lt;aiter-&gt;num;i++) {
 109         uprv_free(aiter-&gt;entries[i].key);
 110         ures_close(aiter-&gt;entries[i].item);
 111     }
 112 #endif
 113 }
 114 
 115 static const UChar *ures_a_getNextString(UResourceBundleAIterator *aiter, int32_t *len, const char **key, UErrorCode *err) {
 116 #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)
 117     return ures_getNextString(aiter-&gt;bund, len, key, err);
 118 #else
<span class="line-modified"> 119     if(U_FAILURE(*err)) return nullptr;</span>
 120     UResourceBundle *item = aiter-&gt;entries[aiter-&gt;cursor].item;
 121     const UChar* ret = ures_getString(item, len, err);
 122     *key = ures_getKey(item);
 123     aiter-&gt;cursor++;
 124     return ret;
 125 #endif
 126 }
 127 
 128 
 129 #endif
 130 
 131 
 132 U_NAMESPACE_BEGIN
 133 
 134 // *****************************************************************************
 135 // class DateTimePatternGenerator
 136 // *****************************************************************************
 137 static const UChar Canonical_Items[] = {
 138     // GyQMwWEDFdaHmsSv
 139     CAP_G, LOW_Y, CAP_Q, CAP_M, LOW_W, CAP_W, CAP_E,
</pre>
<hr />
<pre>
 286 static const char DT_DateTimePatternsTag[]=&quot;DateTimePatterns&quot;;
 287 static const char DT_DateTimeCalendarTag[]=&quot;calendar&quot;;
 288 static const char DT_DateTimeGregorianTag[]=&quot;gregorian&quot;;
 289 static const char DT_DateTimeAppendItemsTag[]=&quot;appendItems&quot;;
 290 static const char DT_DateTimeFieldsTag[]=&quot;fields&quot;;
 291 static const char DT_DateTimeAvailableFormatsTag[]=&quot;availableFormats&quot;;
 292 //static const UnicodeString repeatedPattern=UnicodeString(repeatedPatterns);
 293 
 294 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DateTimePatternGenerator)
 295 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DTSkeletonEnumeration)
 296 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DTRedundantEnumeration)
 297 
 298 DateTimePatternGenerator*  U_EXPORT2
 299 DateTimePatternGenerator::createInstance(UErrorCode&amp; status) {
 300     return createInstance(Locale::getDefault(), status);
 301 }
 302 
 303 DateTimePatternGenerator* U_EXPORT2
 304 DateTimePatternGenerator::createInstance(const Locale&amp; locale, UErrorCode&amp; status) {
 305     if (U_FAILURE(status)) {
<span class="line-modified"> 306         return nullptr;</span>
 307     }
 308     LocalPointer&lt;DateTimePatternGenerator&gt; result(
 309             new DateTimePatternGenerator(locale, status), status);
<span class="line-modified"> 310     return U_SUCCESS(status) ? result.orphan() : nullptr;</span>
 311 }
 312 
 313 DateTimePatternGenerator*  U_EXPORT2
 314 DateTimePatternGenerator::createEmptyInstance(UErrorCode&amp; status) {




 315     if (U_FAILURE(status)) {
<span class="line-modified"> 316         return nullptr;</span>

 317     }
<span class="line-modified"> 318     LocalPointer&lt;DateTimePatternGenerator&gt; result(</span>
<span class="line-added"> 319             new DateTimePatternGenerator(status), status);</span>
<span class="line-added"> 320     return U_SUCCESS(status) ? result.orphan() : nullptr;</span>
 321 }
 322 
 323 DateTimePatternGenerator::DateTimePatternGenerator(UErrorCode &amp;status) :
<span class="line-modified"> 324     skipMatcher(nullptr),</span>
<span class="line-modified"> 325     fAvailableFormatKeyHash(nullptr),</span>
<span class="line-added"> 326     internalErrorCode(U_ZERO_ERROR)</span>
 327 {
 328     fp = new FormatParser();
 329     dtMatcher = new DateTimeMatcher();
 330     distanceInfo = new DistanceInfo();
 331     patternMap = new PatternMap();
<span class="line-modified"> 332     if (fp == nullptr || dtMatcher == nullptr || distanceInfo == nullptr || patternMap == nullptr) {</span>
<span class="line-modified"> 333         internalErrorCode = status = U_MEMORY_ALLOCATION_ERROR;</span>
 334     }
 335 }
 336 
 337 DateTimePatternGenerator::DateTimePatternGenerator(const Locale&amp; locale, UErrorCode &amp;status) :
<span class="line-modified"> 338     skipMatcher(nullptr),</span>
<span class="line-modified"> 339     fAvailableFormatKeyHash(nullptr),</span>
<span class="line-added"> 340     internalErrorCode(U_ZERO_ERROR)</span>
 341 {
 342     fp = new FormatParser();
 343     dtMatcher = new DateTimeMatcher();
 344     distanceInfo = new DistanceInfo();
 345     patternMap = new PatternMap();
<span class="line-modified"> 346     if (fp == nullptr || dtMatcher == nullptr || distanceInfo == nullptr || patternMap == nullptr) {</span>
<span class="line-modified"> 347         internalErrorCode = status = U_MEMORY_ALLOCATION_ERROR;</span>
 348     }
 349     else {
 350         initData(locale, status);
 351     }
 352 }
 353 
 354 DateTimePatternGenerator::DateTimePatternGenerator(const DateTimePatternGenerator&amp; other) :
 355     UObject(),
<span class="line-modified"> 356     skipMatcher(nullptr),</span>
<span class="line-modified"> 357     fAvailableFormatKeyHash(nullptr),</span>
<span class="line-added"> 358     internalErrorCode(U_ZERO_ERROR)</span>
 359 {
 360     fp = new FormatParser();
 361     dtMatcher = new DateTimeMatcher();
 362     distanceInfo = new DistanceInfo();
 363     patternMap = new PatternMap();
<span class="line-added"> 364     if (fp == nullptr || dtMatcher == nullptr || distanceInfo == nullptr || patternMap == nullptr) {</span>
<span class="line-added"> 365         internalErrorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 366     }</span>
 367     *this=other;
 368 }
 369 
 370 DateTimePatternGenerator&amp;
 371 DateTimePatternGenerator::operator=(const DateTimePatternGenerator&amp; other) {
 372     // reflexive case
 373     if (&amp;other == this) {
 374         return *this;
 375     }
<span class="line-added"> 376     internalErrorCode = other.internalErrorCode;</span>
 377     pLocale = other.pLocale;
 378     fDefaultHourFormatChar = other.fDefaultHourFormatChar;
 379     *fp = *(other.fp);
 380     dtMatcher-&gt;copyFrom(other.dtMatcher-&gt;skeleton);
 381     *distanceInfo = *(other.distanceInfo);
 382     dateTimeFormat = other.dateTimeFormat;
 383     decimal = other.decimal;
 384     // NUL-terminate for the C API.
 385     dateTimeFormat.getTerminatedBuffer();
 386     decimal.getTerminatedBuffer();
 387     delete skipMatcher;
<span class="line-modified"> 388     if ( other.skipMatcher == nullptr ) {</span>
<span class="line-modified"> 389         skipMatcher = nullptr;</span>
 390     }
 391     else {
 392         skipMatcher = new DateTimeMatcher(*other.skipMatcher);
<span class="line-added"> 393         if (skipMatcher == nullptr)</span>
<span class="line-added"> 394         {</span>
<span class="line-added"> 395             internalErrorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 396             return *this;</span>
<span class="line-added"> 397         }</span>
 398     }
 399     for (int32_t i=0; i&lt; UDATPG_FIELD_COUNT; ++i ) {
 400         appendItemFormats[i] = other.appendItemFormats[i];
 401         appendItemFormats[i].getTerminatedBuffer(); // NUL-terminate for the C API.
 402         for (int32_t j=0; j&lt; UDATPG_WIDTH_COUNT; ++j ) {
 403             fieldDisplayNames[i][j] = other.fieldDisplayNames[i][j];
 404             fieldDisplayNames[i][j].getTerminatedBuffer(); // NUL-terminate for the C API.
 405         }
 406     }
<span class="line-modified"> 407     patternMap-&gt;copyFrom(*other.patternMap, internalErrorCode);</span>
<span class="line-modified"> 408     copyHashtable(other.fAvailableFormatKeyHash, internalErrorCode);</span>

 409     return *this;
 410 }
 411 
 412 
 413 UBool
 414 DateTimePatternGenerator::operator==(const DateTimePatternGenerator&amp; other) const {
 415     if (this == &amp;other) {
 416         return TRUE;
 417     }
 418     if ((pLocale==other.pLocale) &amp;&amp; (patternMap-&gt;equals(*other.patternMap)) &amp;&amp;
 419         (dateTimeFormat==other.dateTimeFormat) &amp;&amp; (decimal==other.decimal)) {
 420         for ( int32_t i=0 ; i&lt;UDATPG_FIELD_COUNT; ++i ) {
 421             if (appendItemFormats[i] != other.appendItemFormats[i]) {
 422                 return FALSE;
 423             }
 424             for (int32_t j=0; j&lt; UDATPG_WIDTH_COUNT; ++j ) {
 425                 if (fieldDisplayNames[i][j] != other.fieldDisplayNames[i][j]) {
 426                     return FALSE;
 427                 }
 428             }
 429         }
 430         return TRUE;
 431     }
 432     else {
 433         return FALSE;
 434     }
 435 }
 436 
 437 UBool
 438 DateTimePatternGenerator::operator!=(const DateTimePatternGenerator&amp; other) const {
 439     return  !operator==(other);
 440 }
 441 
 442 DateTimePatternGenerator::~DateTimePatternGenerator() {
<span class="line-modified"> 443     if (fAvailableFormatKeyHash!=nullptr) {</span>
 444         delete fAvailableFormatKeyHash;
 445     }
 446 
<span class="line-modified"> 447     if (fp != nullptr) delete fp;</span>
<span class="line-modified"> 448     if (dtMatcher != nullptr) delete dtMatcher;</span>
<span class="line-modified"> 449     if (distanceInfo != nullptr) delete distanceInfo;</span>
<span class="line-modified"> 450     if (patternMap != nullptr) delete patternMap;</span>
<span class="line-modified"> 451     if (skipMatcher != nullptr) delete skipMatcher;</span>
 452 }
 453 
 454 namespace {
 455 
 456 UInitOnce initOnce = U_INITONCE_INITIALIZER;
<span class="line-modified"> 457 UHashtable *localeToAllowedHourFormatsMap = nullptr;</span>
 458 
 459 // Value deleter for hashmap.
 460 U_CFUNC void U_CALLCONV deleteAllowedHourFormats(void *ptr) {
 461     uprv_free(ptr);
 462 }
 463 
 464 // Close hashmap at cleanup.
 465 U_CFUNC UBool U_CALLCONV allowedHourFormatsCleanup() {
 466     uhash_close(localeToAllowedHourFormatsMap);
 467     return TRUE;
 468 }
 469 
 470 enum AllowedHourFormat{
 471     ALLOWED_HOUR_FORMAT_UNKNOWN = -1,
 472     ALLOWED_HOUR_FORMAT_h,
 473     ALLOWED_HOUR_FORMAT_H,
<span class="line-added"> 474     ALLOWED_HOUR_FORMAT_K,  // Added ICU-20383, used by JP</span>
<span class="line-added"> 475     ALLOWED_HOUR_FORMAT_k,  // Added ICU-20383, not currently used</span>
 476     ALLOWED_HOUR_FORMAT_hb,

 477     ALLOWED_HOUR_FORMAT_hB,
<span class="line-added"> 478     ALLOWED_HOUR_FORMAT_Kb, // Added ICU-20383, not currently used</span>
<span class="line-added"> 479     ALLOWED_HOUR_FORMAT_KB, // Added ICU-20383, not currently used</span>
<span class="line-added"> 480     // ICU-20383 The following are unlikely and not currently used</span>
<span class="line-added"> 481     ALLOWED_HOUR_FORMAT_Hb,</span>
 482     ALLOWED_HOUR_FORMAT_HB
 483 };
 484 
 485 }  // namespace
 486 
 487 void
 488 DateTimePatternGenerator::initData(const Locale&amp; locale, UErrorCode &amp;status) {
 489     //const char *baseLangName = locale.getBaseName(); // unused
 490 
<span class="line-modified"> 491     skipMatcher = nullptr;</span>
<span class="line-modified"> 492     fAvailableFormatKeyHash=nullptr;</span>
 493     addCanonicalItems(status);
 494     addICUPatterns(locale, status);
 495     addCLDRData(locale, status);
 496     setDateTimeFromCalendar(locale, status);
 497     setDecimalSymbols(locale, status);
 498     umtx_initOnce(initOnce, loadAllowedHourFormatsData, status);
 499     getAllowedHourFormats(locale, status);
<span class="line-added"> 500     // If any of the above methods failed then the object is in an invalid state.</span>
<span class="line-added"> 501     internalErrorCode = status;</span>
 502 } // DateTimePatternGenerator::initData
 503 
 504 namespace {
 505 
 506 struct AllowedHourFormatsSink : public ResourceSink {
 507     // Initialize sub-sinks.
 508     AllowedHourFormatsSink() {}
 509     virtual ~AllowedHourFormatsSink();
 510 
 511     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,
 512                      UErrorCode &amp;errorCode) {
 513         ResourceTable timeData = value.getTable(errorCode);
 514         if (U_FAILURE(errorCode)) { return; }
 515         for (int32_t i = 0; timeData.getKeyAndValue(i, key, value); ++i) {
 516             const char *regionOrLocale = key;
 517             ResourceTable formatList = value.getTable(errorCode);
 518             if (U_FAILURE(errorCode)) { return; }
<span class="line-added"> 519             // below we construct a list[] that has an entry for the &quot;preferred&quot; value at [0],</span>
<span class="line-added"> 520             // followed by 1 or more entries for the &quot;allowed&quot; values, terminated with an</span>
<span class="line-added"> 521             // entry for ALLOWED_HOUR_FORMAT_UNKNOWN (not included in length below)</span>
<span class="line-added"> 522             LocalMemory&lt;int32_t&gt; list;</span>
<span class="line-added"> 523             int32_t length = 0;</span>
<span class="line-added"> 524             int32_t preferredFormat = ALLOWED_HOUR_FORMAT_UNKNOWN;</span>
 525             for (int32_t j = 0; formatList.getKeyAndValue(j, key, value); ++j) {
<span class="line-modified"> 526                 if (uprv_strcmp(key, &quot;allowed&quot;) == 0) {</span>


 527                     if (value.getType() == URES_STRING) {
<span class="line-modified"> 528                         length = 2; // 1 preferred to add later, 1 allowed to add now</span>
<span class="line-added"> 529                         if (list.allocateInsteadAndReset(length + 1) == nullptr) {</span>
 530                             errorCode = U_MEMORY_ALLOCATION_ERROR;
 531                             return;
 532                         }
<span class="line-modified"> 533                         list[1] = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));</span>

 534                     }
 535                     else {
 536                         ResourceArray allowedFormats = value.getArray(errorCode);
<span class="line-modified"> 537                         length = allowedFormats.getSize() + 1; // 1 preferred, getSize allowed</span>
<span class="line-modified"> 538                         if (list.allocateInsteadAndReset(length + 1) == nullptr) {</span>
 539                             errorCode = U_MEMORY_ALLOCATION_ERROR;
 540                             return;
 541                         }
<span class="line-modified"> 542                         for (int32_t k = 1; k &lt; length; ++k) {</span>
<span class="line-modified"> 543                             allowedFormats.getValue(k-1, value);</span>
 544                             list[k] = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));
 545                         }
 546                     }
<span class="line-modified"> 547                 } else if (uprv_strcmp(key, &quot;preferred&quot;) == 0) {</span>
<span class="line-modified"> 548                     preferredFormat = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));</span>


 549                 }
 550             }
<span class="line-added"> 551             if (length &gt; 1) {</span>
<span class="line-added"> 552                 list[0] = (preferredFormat!=ALLOWED_HOUR_FORMAT_UNKNOWN)? preferredFormat: list[1];</span>
<span class="line-added"> 553             } else {</span>
<span class="line-added"> 554                 // fallback handling for missing data</span>
<span class="line-added"> 555                 length = 2; // 1 preferred, 1 allowed</span>
<span class="line-added"> 556                 if (list.allocateInsteadAndReset(length + 1) == nullptr) {</span>
<span class="line-added"> 557                     errorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 558                     return;</span>
<span class="line-added"> 559                 }</span>
<span class="line-added"> 560                 list[0] = (preferredFormat!=ALLOWED_HOUR_FORMAT_UNKNOWN)? preferredFormat: ALLOWED_HOUR_FORMAT_H;</span>
<span class="line-added"> 561                 list[1] = list[0];</span>
<span class="line-added"> 562             }</span>
<span class="line-added"> 563             list[length] = ALLOWED_HOUR_FORMAT_UNKNOWN;</span>
<span class="line-added"> 564             // At this point list[] will have at least two non-ALLOWED_HOUR_FORMAT_UNKNOWN entries,</span>
<span class="line-added"> 565             // followed by ALLOWED_HOUR_FORMAT_UNKNOWN.</span>
<span class="line-added"> 566             uhash_put(localeToAllowedHourFormatsMap, const_cast&lt;char *&gt;(regionOrLocale), list.orphan(), &amp;errorCode);</span>
<span class="line-added"> 567             if (U_FAILURE(errorCode)) { return; }</span>
 568         }
 569     }
 570 
 571     AllowedHourFormat getHourFormatFromUnicodeString(const UnicodeString &amp;s) {
 572         if (s.length() == 1) {
 573             if (s[0] == LOW_H) { return ALLOWED_HOUR_FORMAT_h; }
 574             if (s[0] == CAP_H) { return ALLOWED_HOUR_FORMAT_H; }
<span class="line-added"> 575             if (s[0] == CAP_K) { return ALLOWED_HOUR_FORMAT_K; }</span>
<span class="line-added"> 576             if (s[0] == LOW_K) { return ALLOWED_HOUR_FORMAT_k; }</span>
 577         } else if (s.length() == 2) {
 578             if (s[0] == LOW_H &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_hb; }

 579             if (s[0] == LOW_H &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_hB; }
<span class="line-added"> 580             if (s[0] == CAP_K &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_Kb; }</span>
<span class="line-added"> 581             if (s[0] == CAP_K &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_KB; }</span>
<span class="line-added"> 582             if (s[0] == CAP_H &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_Hb; }</span>
 583             if (s[0] == CAP_H &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_HB; }
 584         }
 585 
 586         return ALLOWED_HOUR_FORMAT_UNKNOWN;
 587     }
 588 };
 589 
 590 }  // namespace
 591 
 592 AllowedHourFormatsSink::~AllowedHourFormatsSink() {}
 593 
 594 U_CFUNC void U_CALLCONV DateTimePatternGenerator::loadAllowedHourFormatsData(UErrorCode &amp;status) {
 595     if (U_FAILURE(status)) { return; }
 596     localeToAllowedHourFormatsMap = uhash_open(
<span class="line-modified"> 597         uhash_hashChars, uhash_compareChars, nullptr, &amp;status);</span>
<span class="line-added"> 598     if (U_FAILURE(status)) { return; }</span>
<span class="line-added"> 599 </span>
 600     uhash_setValueDeleter(localeToAllowedHourFormatsMap, deleteAllowedHourFormats);
<span class="line-modified"> 601     ucln_i18n_registerCleanup(UCLN_I18N_ALLOWED_HOUR_FORMATS, allowedHourFormatsCleanup);</span>
<span class="line-added"> 602 </span>
<span class="line-added"> 603     LocalUResourceBundlePointer rb(ures_openDirect(nullptr, &quot;supplementalData&quot;, &amp;status));</span>
<span class="line-added"> 604     if (U_FAILURE(status)) { return; }</span>
 605 
 606     AllowedHourFormatsSink sink;
 607     // TODO: Currently in the enumeration each table allocates a new array.
 608     // Try to reduce the number of memory allocations. Consider storing a
 609     // UVector32 with the concatenation of all of the sub-arrays, put the start index
 610     // into the hashmap, store 6 single-value sub-arrays right at the beginning of the
 611     // vector (at index enum*2) for easy data sharing, copy sub-arrays into runtime
 612     // object. Remember to clean up the vector, too.
 613     ures_getAllItemsWithFallback(rb.getAlias(), &quot;timeData&quot;, sink, status);


 614 }
 615 
 616 void DateTimePatternGenerator::getAllowedHourFormats(const Locale &amp;locale, UErrorCode &amp;status) {
 617     if (U_FAILURE(status)) { return; }
<span class="line-modified"> 618     Locale maxLocale(locale);</span>
<span class="line-modified"> 619     maxLocale.addLikelySubtags(status);</span>

 620     if (U_FAILURE(status)) {
 621         return;



 622     }

 623 
 624     const char *country = maxLocale.getCountry();
 625     if (*country == &#39;\0&#39;) { country = &quot;001&quot;; }
 626     const char *language = maxLocale.getLanguage();
 627 
 628     CharString langCountry;
<span class="line-modified"> 629     langCountry.append(language, static_cast&lt;int32_t&gt;(uprv_strlen(language)), status);</span>
 630     langCountry.append(&#39;_&#39;, status);
<span class="line-modified"> 631     langCountry.append(country, static_cast&lt;int32_t&gt;(uprv_strlen(country)), status);</span>
 632 
 633     int32_t *allowedFormats;
 634     allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, langCountry.data());
<span class="line-modified"> 635     if (allowedFormats == nullptr) {</span>
 636         allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, const_cast&lt;char *&gt;(country));
 637     }
 638 
<span class="line-modified"> 639     if (allowedFormats != nullptr) {  // Lookup is successful</span>
<span class="line-added"> 640         // Here allowedFormats points to a list consisting of key for preferredFormat,</span>
<span class="line-added"> 641         // followed by one or more keys for allowedFormats, then followed by ALLOWED_HOUR_FORMAT_UNKNOWN.</span>
<span class="line-added"> 642         switch (allowedFormats[0]) {</span>
<span class="line-added"> 643             case ALLOWED_HOUR_FORMAT_h: fDefaultHourFormatChar = LOW_H; break;</span>
<span class="line-added"> 644             case ALLOWED_HOUR_FORMAT_H: fDefaultHourFormatChar = CAP_H; break;</span>
<span class="line-added"> 645             case ALLOWED_HOUR_FORMAT_K: fDefaultHourFormatChar = CAP_K; break;</span>
<span class="line-added"> 646             case ALLOWED_HOUR_FORMAT_k: fDefaultHourFormatChar = LOW_K; break;</span>
<span class="line-added"> 647             default: fDefaultHourFormatChar = CAP_H; break;</span>
<span class="line-added"> 648         }</span>
 649         for (int32_t i = 0; i &lt; UPRV_LENGTHOF(fAllowedHourFormats); ++i) {
<span class="line-modified"> 650             fAllowedHourFormats[i] = allowedFormats[i + 1];</span>
<span class="line-modified"> 651             if (fAllowedHourFormats[i] == ALLOWED_HOUR_FORMAT_UNKNOWN) {</span>
 652                 break;
 653             }
 654         }
 655     } else {  // Lookup failed, twice
<span class="line-added"> 656         fDefaultHourFormatChar = CAP_H;</span>
 657         fAllowedHourFormats[0] = ALLOWED_HOUR_FORMAT_H;
 658         fAllowedHourFormats[1] = ALLOWED_HOUR_FORMAT_UNKNOWN;
 659     }
 660 }
 661 
 662 UnicodeString
 663 DateTimePatternGenerator::getSkeleton(const UnicodeString&amp; pattern, UErrorCode&amp;
 664 /*status*/) {
<span class="line-modified"> 665     FormatParser fp2;</span>
 666     DateTimeMatcher matcher;
 667     PtnSkeleton localSkeleton;
<span class="line-modified"> 668     matcher.set(pattern, &amp;fp2, localSkeleton);</span>
 669     return localSkeleton.getSkeleton();
 670 }
 671 
 672 UnicodeString
 673 DateTimePatternGenerator::staticGetSkeleton(
 674         const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
 675     FormatParser fp;
 676     DateTimeMatcher matcher;
 677     PtnSkeleton localSkeleton;
 678     matcher.set(pattern, &amp;fp, localSkeleton);
 679     return localSkeleton.getSkeleton();
 680 }
 681 
 682 UnicodeString
 683 DateTimePatternGenerator::getBaseSkeleton(const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
<span class="line-modified"> 684     FormatParser fp2;</span>
 685     DateTimeMatcher matcher;
 686     PtnSkeleton localSkeleton;
<span class="line-modified"> 687     matcher.set(pattern, &amp;fp2, localSkeleton);</span>
 688     return localSkeleton.getBaseSkeleton();
 689 }
 690 
 691 UnicodeString
 692 DateTimePatternGenerator::staticGetBaseSkeleton(
 693         const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
 694     FormatParser fp;
 695     DateTimeMatcher matcher;
 696     PtnSkeleton localSkeleton;
 697     matcher.set(pattern, &amp;fp, localSkeleton);
 698     return localSkeleton.getBaseSkeleton();
 699 }
 700 
 701 void
 702 DateTimePatternGenerator::addICUPatterns(const Locale&amp; locale, UErrorCode&amp; status) {
 703     if (U_FAILURE(status)) { return; }
 704     UnicodeString dfPattern;
 705     UnicodeString conflictingString;
 706     DateFormat* df;
 707 
 708     // Load with ICU patterns
 709     for (int32_t i=DateFormat::kFull; i&lt;=DateFormat::kShort; i++) {
 710         DateFormat::EStyle style = (DateFormat::EStyle)i;
 711         df = DateFormat::createDateInstance(style, locale);
 712         SimpleDateFormat* sdf;
<span class="line-modified"> 713         if (df != nullptr &amp;&amp; (sdf = dynamic_cast&lt;SimpleDateFormat*&gt;(df)) != nullptr) {</span>
 714             sdf-&gt;toPattern(dfPattern);
 715             addPattern(dfPattern, FALSE, conflictingString, status);
 716         }
 717         // TODO Maybe we should return an error when the date format isn&#39;t simple.
 718         delete df;
 719         if (U_FAILURE(status)) { return; }
 720 
 721         df = DateFormat::createTimeInstance(style, locale);
<span class="line-modified"> 722         if (df != nullptr &amp;&amp; (sdf = dynamic_cast&lt;SimpleDateFormat*&gt;(df)) != nullptr) {</span>
 723             sdf-&gt;toPattern(dfPattern);
 724             addPattern(dfPattern, FALSE, conflictingString, status);
 725 
 726             // TODO: C++ and Java are inconsistent (see #12568).
 727             // C++ uses MEDIUM, but Java uses SHORT.
 728             if ( i==DateFormat::kShort &amp;&amp; !dfPattern.isEmpty() ) {
 729                 consumeShortTimePattern(dfPattern, status);
 730             }
 731         }
 732         // TODO Maybe we should return an error when the date format isn&#39;t simple.
 733         delete df;
 734         if (U_FAILURE(status)) { return; }
 735     }
 736 }
 737 
 738 void
 739 DateTimePatternGenerator::hackTimes(const UnicodeString&amp; hackPattern, UErrorCode&amp; status)  {
 740     UnicodeString conflictingString;
 741 
 742     fp-&gt;set(hackPattern);
</pre>
<hr />
<pre>
 766                         if (!gotMm) {
 767                             break;
 768                         }
 769                         mmss+= field;
 770                         addPattern(mmss, FALSE, conflictingString, status);
 771                         break;
 772                     }
 773                     else {
 774                         if (gotMm || ch==LOW_Z || ch==CAP_Z || ch==LOW_V || ch==CAP_V) {
 775                             break;
 776                         }
 777                     }
 778                 }
 779             }
 780         }
 781     }
 782 }
 783 
 784 #define ULOC_LOCALE_IDENTIFIER_CAPACITY (ULOC_FULLNAME_CAPACITY + 1 + ULOC_KEYWORD_AND_VALUES_CAPACITY)
 785 


 786 void
 787 DateTimePatternGenerator::getCalendarTypeToUse(const Locale&amp; locale, CharString&amp; destination, UErrorCode&amp; err) {
 788     destination.clear().append(DT_DateTimeGregorianTag, -1, err); // initial default
 789     if ( U_SUCCESS(err) ) {
 790         char localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY];
 791         // obtain a locale that always has the calendar key value that should be used
 792         ures_getFunctionalEquivalent(
 793             localeWithCalendarKey,
 794             ULOC_LOCALE_IDENTIFIER_CAPACITY,
<span class="line-modified"> 795             nullptr,</span>
 796             &quot;calendar&quot;,
 797             &quot;calendar&quot;,
 798             locale.getName(),
<span class="line-modified"> 799             nullptr,</span>
 800             FALSE,
 801             &amp;err);
<span class="line-added"> 802         if (U_FAILURE(err)) { return; }</span>
 803         localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY-1] = 0; // ensure null termination
 804         // now get the calendar key value from that locale
 805         char calendarType[ULOC_KEYWORDS_CAPACITY];
 806         int32_t calendarTypeLen = uloc_getKeywordValue(
 807             localeWithCalendarKey,
 808             &quot;calendar&quot;,
 809             calendarType,
 810             ULOC_KEYWORDS_CAPACITY,
 811             &amp;err);
<span class="line-modified"> 812         if (U_FAILURE(err)) { return; }</span>
<span class="line-added"> 813         if (calendarTypeLen &lt; ULOC_KEYWORDS_CAPACITY) {</span>
 814             destination.clear().append(calendarType, -1, err);
 815             if (U_FAILURE(err)) { return; }
 816         }
 817         err = U_ZERO_ERROR;
 818     }
 819 }
 820 
 821 void
 822 DateTimePatternGenerator::consumeShortTimePattern(const UnicodeString&amp; shortTimePattern,
 823         UErrorCode&amp; status) {
<span class="line-modified"> 824     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified"> 825     // ICU-20383 No longer set fDefaultHourFormatChar to the hour format character from</span>
<span class="line-modified"> 826     // this pattern; instead it is set from localeToAllowedHourFormatsMap which now</span>
<span class="line-modified"> 827     // includes entries for both preferred and allowed formats.</span>









 828 
 829     // HACK for hh:ss
 830     hackTimes(shortTimePattern, status);
 831 }
 832 
 833 struct DateTimePatternGenerator::AppendItemFormatsSink : public ResourceSink {
 834 
 835     // Destination for data, modified via setters.
 836     DateTimePatternGenerator&amp; dtpg;
 837 
 838     AppendItemFormatsSink(DateTimePatternGenerator&amp; _dtpg) : dtpg(_dtpg) {}
 839     virtual ~AppendItemFormatsSink();
 840 
 841     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,
 842             UErrorCode &amp;errorCode) {
 843         ResourceTable itemsTable = value.getTable(errorCode);
 844         if (U_FAILURE(errorCode)) { return; }
 845         for (int32_t i = 0; itemsTable.getKeyAndValue(i, key, value); ++i) {
 846             UDateTimePatternField field = dtpg.getAppendFormatNumber(key);
 847             if (field == UDATPG_FIELD_COUNT) { continue; }
</pre>
<hr />
<pre>
 893     }
 894 
 895     void fillInMissing() {
 896         for (int32_t i = 0; i &lt; UDATPG_FIELD_COUNT; i++) {
 897             UnicodeString&amp; valueStr = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, UDATPG_WIDE);
 898             if (valueStr.isEmpty()) {
 899                 valueStr = CAP_F;
 900                 U_ASSERT(i &lt; 20);
 901                 if (i &lt; 10) {
 902                     // F0, F1, ..., F9
 903                     valueStr += (UChar)(i+0x30);
 904                 } else {
 905                     // F10, F11, ...
 906                     valueStr += (UChar)0x31;
 907                     valueStr += (UChar)(i-10 + 0x30);
 908                 }
 909                 // NUL-terminate for the C API.
 910                 valueStr.getTerminatedBuffer();
 911             }
 912             for (int32_t j = 1; j &lt; UDATPG_WIDTH_COUNT; j++) {
<span class="line-modified"> 913                 UnicodeString&amp; valueStr2 = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)j);</span>
<span class="line-modified"> 914                 if (valueStr2.isEmpty()) {</span>
<span class="line-modified"> 915                     valueStr2 = dtpg.getFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)(j-1));</span>
 916                 }
 917             }
 918         }
 919     }
 920 };
 921 
 922 struct DateTimePatternGenerator::AvailableFormatsSink : public ResourceSink {
 923 
 924     // Destination for data, modified via setters.
 925     DateTimePatternGenerator&amp; dtpg;
 926 
 927     // Temporary variable, required for calling addPatternWithSkeleton.
 928     UnicodeString conflictingPattern;
 929 
 930     AvailableFormatsSink(DateTimePatternGenerator&amp; _dtpg) : dtpg(_dtpg) {}
 931     virtual ~AvailableFormatsSink();
 932 
 933     virtual void put(const char *key, ResourceValue &amp;value, UBool isRoot,
 934             UErrorCode &amp;errorCode) {
 935         ResourceTable itemsTable = value.getTable(errorCode);
</pre>
<hr />
<pre>
 942                 // derived from std patterns, but not a previous availableFormats entry:
 943                 const UnicodeString&amp; formatValue = value.getUnicodeString(errorCode);
 944                 conflictingPattern.remove();
 945                 dtpg.addPatternWithSkeleton(formatValue, &amp;formatKey, !isRoot, conflictingPattern, errorCode);
 946             }
 947         }
 948     }
 949 };
 950 
 951 // Virtual destructors must be defined out of line.
 952 DateTimePatternGenerator::AppendItemFormatsSink::~AppendItemFormatsSink() {}
 953 DateTimePatternGenerator::AppendItemNamesSink::~AppendItemNamesSink() {}
 954 DateTimePatternGenerator::AvailableFormatsSink::~AvailableFormatsSink() {}
 955 
 956 void
 957 DateTimePatternGenerator::addCLDRData(const Locale&amp; locale, UErrorCode&amp; errorCode) {
 958     if (U_FAILURE(errorCode)) { return; }
 959     UnicodeString rbPattern, value, field;
 960     CharString path;
 961 
<span class="line-modified"> 962     LocalUResourceBundlePointer rb(ures_open(nullptr, locale.getName(), &amp;errorCode));</span>
 963     if (U_FAILURE(errorCode)) { return; }
 964 
 965     CharString calendarTypeToUse; // to be filled in with the type to use, if all goes well
 966     getCalendarTypeToUse(locale, calendarTypeToUse, errorCode);
 967     if (U_FAILURE(errorCode)) { return; }
 968 
 969     // Local err to ignore resource not found exceptions
 970     UErrorCode err = U_ZERO_ERROR;
 971 
 972     // Load append item formats.
 973     AppendItemFormatsSink appendItemFormatsSink(*this);
 974     path.clear()
 975         .append(DT_DateTimeCalendarTag, errorCode)
 976         .append(&#39;/&#39;, errorCode)
 977         .append(calendarTypeToUse, errorCode)
 978         .append(&#39;/&#39;, errorCode)
 979         .append(DT_DateTimeAppendItemsTag, errorCode); // i.e., calendar/xxx/appendItems
 980     if (U_FAILURE(errorCode)) { return; }
 981     ures_getAllItemsWithFallback(rb.getAlias(), path.data(), appendItemFormatsSink, err);
 982     appendItemFormatsSink.fillInMissing();
</pre>
<hr />
<pre>
 987     ures_getAllItemsWithFallback(rb.getAlias(), DT_DateTimeFieldsTag, appendItemNamesSink, err);
 988     appendItemNamesSink.fillInMissing();
 989 
 990     // Load the available formats from CLDR.
 991     err = U_ZERO_ERROR;
 992     initHashtable(errorCode);
 993     if (U_FAILURE(errorCode)) { return; }
 994     AvailableFormatsSink availableFormatsSink(*this);
 995     path.clear()
 996         .append(DT_DateTimeCalendarTag, errorCode)
 997         .append(&#39;/&#39;, errorCode)
 998         .append(calendarTypeToUse, errorCode)
 999         .append(&#39;/&#39;, errorCode)
1000         .append(DT_DateTimeAvailableFormatsTag, errorCode); // i.e., calendar/xxx/availableFormats
1001     if (U_FAILURE(errorCode)) { return; }
1002     ures_getAllItemsWithFallback(rb.getAlias(), path.data(), availableFormatsSink, err);
1003 }
1004 
1005 void
1006 DateTimePatternGenerator::initHashtable(UErrorCode&amp; err) {
<span class="line-modified">1007     if (U_FAILURE(err)) { return; }</span>
<span class="line-added">1008     if (fAvailableFormatKeyHash!=nullptr) {</span>
1009         return;
1010     }
<span class="line-modified">1011     LocalPointer&lt;Hashtable&gt; hash(new Hashtable(FALSE, err), err);</span>
<span class="line-modified">1012     if (U_SUCCESS(err)) {</span>
<span class="line-modified">1013         fAvailableFormatKeyHash = hash.orphan();</span>
1014     }
1015 }
1016 
1017 void
1018 DateTimePatternGenerator::setAppendItemFormat(UDateTimePatternField field, const UnicodeString&amp; value) {
1019     appendItemFormats[field] = value;
1020     // NUL-terminate for the C API.
1021     appendItemFormats[field].getTerminatedBuffer();
1022 }
1023 
1024 const UnicodeString&amp;
1025 DateTimePatternGenerator::getAppendItemFormat(UDateTimePatternField field) const {
1026     return appendItemFormats[field];
1027 }
1028 
1029 void
1030 DateTimePatternGenerator::setAppendItemName(UDateTimePatternField field, const UnicodeString&amp; value) {
1031     setFieldDisplayName(field, UDATPG_WIDTH_APPENDITEM, value);
1032 }
1033 
</pre>
<hr />
<pre>
1050 
1051 UnicodeString&amp;
1052 DateTimePatternGenerator::getMutableFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width) {
1053     return fieldDisplayNames[field][width];
1054 }
1055 
1056 void
1057 DateTimePatternGenerator::getAppendName(UDateTimePatternField field, UnicodeString&amp; value) {
1058     value = SINGLE_QUOTE;
1059     value += fieldDisplayNames[field][UDATPG_WIDTH_APPENDITEM];
1060     value += SINGLE_QUOTE;
1061 }
1062 
1063 UnicodeString
1064 DateTimePatternGenerator::getBestPattern(const UnicodeString&amp; patternForm, UErrorCode&amp; status) {
1065     return getBestPattern(patternForm, UDATPG_MATCH_NO_OPTIONS, status);
1066 }
1067 
1068 UnicodeString
1069 DateTimePatternGenerator::getBestPattern(const UnicodeString&amp; patternForm, UDateTimePatternMatchOptions options, UErrorCode&amp; status) {
<span class="line-modified">1070     if (U_FAILURE(status)) {</span>
<span class="line-added">1071         return UnicodeString();</span>
<span class="line-added">1072     }</span>
<span class="line-added">1073     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">1074         status = internalErrorCode;</span>
<span class="line-added">1075         return UnicodeString();</span>
<span class="line-added">1076     }</span>
<span class="line-added">1077     const UnicodeString *bestPattern = nullptr;</span>
1078     UnicodeString dtFormat;
1079     UnicodeString resultPattern;
1080     int32_t flags = kDTPGNoFlags;
1081 
1082     int32_t dateMask=(1&lt;&lt;UDATPG_DAYPERIOD_FIELD) - 1;
1083     int32_t timeMask=(1&lt;&lt;UDATPG_FIELD_COUNT) - 1 - dateMask;
1084 
1085     // Replace hour metacharacters &#39;j&#39;, &#39;C&#39; and &#39;J&#39;, set flags as necessary
1086     UnicodeString patternFormMapped = mapSkeletonMetacharacters(patternForm, &amp;flags, status);
1087     if (U_FAILURE(status)) {
1088         return UnicodeString();
1089     }
1090 
1091     resultPattern.remove();
1092     dtMatcher-&gt;set(patternFormMapped, fp);
<span class="line-modified">1093     const PtnSkeleton* specifiedSkeleton = nullptr;</span>
<span class="line-modified">1094     bestPattern=getBestRaw(*dtMatcher, -1, distanceInfo, status, &amp;specifiedSkeleton);</span>
<span class="line-added">1095     if (U_FAILURE(status)) {</span>
<span class="line-added">1096         return UnicodeString();</span>
<span class="line-added">1097     }</span>
<span class="line-added">1098 </span>
1099     if ( distanceInfo-&gt;missingFieldMask==0 &amp;&amp; distanceInfo-&gt;extraFieldMask==0 ) {
1100         resultPattern = adjustFieldTypes(*bestPattern, specifiedSkeleton, flags, options);
1101 
1102         return resultPattern;
1103     }
1104     int32_t neededFields = dtMatcher-&gt;getFieldMask();
<span class="line-modified">1105     UnicodeString datePattern=getBestAppending(neededFields &amp; dateMask, flags, status, options);</span>
<span class="line-modified">1106     UnicodeString timePattern=getBestAppending(neededFields &amp; timeMask, flags, status, options);</span>
<span class="line-added">1107     if (U_FAILURE(status)) {</span>
<span class="line-added">1108         return UnicodeString();</span>
<span class="line-added">1109     }</span>
1110     if (datePattern.length()==0) {
1111         if (timePattern.length()==0) {
1112             resultPattern.remove();
1113         }
1114         else {
1115             return timePattern;
1116         }
1117     }
1118     if (timePattern.length()==0) {
1119         return datePattern;
1120     }
1121     resultPattern.remove();
1122     status = U_ZERO_ERROR;
1123     dtFormat=getDateTimeFormat();
1124     SimpleFormatter(dtFormat, 2, 2, status).format(timePattern, datePattern, resultPattern, status);
1125     return resultPattern;
1126 }
1127 
1128 /*
1129  * Map a skeleton that may have metacharacters jJC to one without, by replacing
<span class="line-modified">1130  * the metacharacters with locale-appropriate fields of h/H/k/K and of a/b/B</span>
1131  * (depends on fDefaultHourFormatChar and fAllowedHourFormats being set, which in
1132  * turn depends on initData having been run). This method also updates the flags
1133  * as necessary. Returns the updated skeleton.
1134  */
1135 UnicodeString
1136 DateTimePatternGenerator::mapSkeletonMetacharacters(const UnicodeString&amp; patternForm, int32_t* flags, UErrorCode&amp; status) {
1137     UnicodeString patternFormMapped;
1138     patternFormMapped.remove();
1139     UBool inQuoted = FALSE;
1140     int32_t patPos, patLen = patternForm.length();
1141     for (patPos = 0; patPos &lt; patLen; patPos++) {
1142         UChar patChr = patternForm.charAt(patPos);
1143         if (patChr == SINGLE_QUOTE) {
1144             inQuoted = !inQuoted;
1145         } else if (!inQuoted) {
1146             // Handle special mappings for &#39;j&#39; and &#39;C&#39; in which fields lengths
1147             // 1,3,5 =&gt; hour field length 1
1148             // 2,4,6 =&gt; hour field length 2
1149             // 1,2 =&gt; abbreviated dayPeriod (field length 1..3)
1150             // 3,4 =&gt; long dayPeriod (field length 4)
1151             // 5,6 =&gt; narrow dayPeriod (field length 5)
1152             if (patChr == LOW_J || patChr == CAP_C) {
1153                 int32_t extraLen = 0; // 1 less than total field length
1154                 while (patPos+1 &lt; patLen &amp;&amp; patternForm.charAt(patPos+1)==patChr) {
1155                     extraLen++;
1156                     patPos++;
1157                 }
1158                 int32_t hourLen = 1 + (extraLen &amp; 1);
1159                 int32_t dayPeriodLen = (extraLen &lt; 2)? 1: 3 + (extraLen &gt;&gt; 1);
1160                 UChar hourChar = LOW_H;
1161                 UChar dayPeriodChar = LOW_A;
1162                 if (patChr == LOW_J) {
1163                     hourChar = fDefaultHourFormatChar;
1164                 } else {
<span class="line-modified">1165                     AllowedHourFormat bestAllowed;</span>
1166                     if (fAllowedHourFormats[0] != ALLOWED_HOUR_FORMAT_UNKNOWN) {
<span class="line-modified">1167                         bestAllowed = (AllowedHourFormat)fAllowedHourFormats[0];</span>
1168                     } else {
1169                         status = U_INVALID_FORMAT_ERROR;
1170                         return UnicodeString();
1171                     }
<span class="line-modified">1172                     if (bestAllowed == ALLOWED_HOUR_FORMAT_H || bestAllowed == ALLOWED_HOUR_FORMAT_HB || bestAllowed == ALLOWED_HOUR_FORMAT_Hb) {</span>
1173                         hourChar = CAP_H;
<span class="line-added">1174                     } else if (bestAllowed == ALLOWED_HOUR_FORMAT_K || bestAllowed == ALLOWED_HOUR_FORMAT_KB || bestAllowed == ALLOWED_HOUR_FORMAT_Kb) {</span>
<span class="line-added">1175                         hourChar = CAP_K;</span>
<span class="line-added">1176                     } else if (bestAllowed == ALLOWED_HOUR_FORMAT_k) {</span>
<span class="line-added">1177                         hourChar = LOW_K;</span>
1178                     }
1179                     // in #13183 just add b/B to skeleton, no longer need to set special flags
<span class="line-modified">1180                     if (bestAllowed == ALLOWED_HOUR_FORMAT_HB || bestAllowed == ALLOWED_HOUR_FORMAT_hB || bestAllowed == ALLOWED_HOUR_FORMAT_KB) {</span>
1181                         dayPeriodChar = CAP_B;
<span class="line-modified">1182                     } else if (bestAllowed == ALLOWED_HOUR_FORMAT_Hb || bestAllowed == ALLOWED_HOUR_FORMAT_hb || bestAllowed == ALLOWED_HOUR_FORMAT_Kb) {</span>
1183                         dayPeriodChar = LOW_B;
1184                     }
1185                 }
1186                 if (hourChar==CAP_H || hourChar==LOW_K) {
1187                     dayPeriodLen = 0;
1188                 }
1189                 while (dayPeriodLen-- &gt; 0) {
1190                     patternFormMapped.append(dayPeriodChar);
1191                 }
1192                 while (hourLen-- &gt; 0) {
1193                     patternFormMapped.append(hourChar);
1194                 }
1195             } else if (patChr == CAP_J) {
1196                 // Get pattern for skeleton with H, then replace H or k
1197                 // with fDefaultHourFormatChar (if different)
1198                 patternFormMapped.append(CAP_H);
1199                 *flags |= kDTPGSkeletonUsesCapJ;
1200             } else {
1201                 patternFormMapped.append(patChr);
1202             }
1203         }
1204     }
1205     return patternFormMapped;
1206 }
1207 
1208 UnicodeString
1209 DateTimePatternGenerator::replaceFieldTypes(const UnicodeString&amp; pattern,
1210                                             const UnicodeString&amp; skeleton,
1211                                             UErrorCode&amp; status) {
1212     return replaceFieldTypes(pattern, skeleton, UDATPG_MATCH_NO_OPTIONS, status);
1213 }
1214 
1215 UnicodeString
1216 DateTimePatternGenerator::replaceFieldTypes(const UnicodeString&amp; pattern,
1217                                             const UnicodeString&amp; skeleton,
1218                                             UDateTimePatternMatchOptions options,
<span class="line-modified">1219                                             UErrorCode&amp; status) {</span>
<span class="line-added">1220     if (U_FAILURE(status)) {</span>
<span class="line-added">1221         return UnicodeString();</span>
<span class="line-added">1222     }</span>
<span class="line-added">1223     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">1224         status = internalErrorCode;</span>
<span class="line-added">1225         return UnicodeString();</span>
<span class="line-added">1226     }</span>
1227     dtMatcher-&gt;set(skeleton, fp);
<span class="line-modified">1228     UnicodeString result = adjustFieldTypes(pattern, nullptr, kDTPGNoFlags, options);</span>
1229     return result;
1230 }
1231 
1232 void
1233 DateTimePatternGenerator::setDecimal(const UnicodeString&amp; newDecimal) {
1234     this-&gt;decimal = newDecimal;
1235     // NUL-terminate for the C API.
1236     this-&gt;decimal.getTerminatedBuffer();
1237 }
1238 
1239 const UnicodeString&amp;
1240 DateTimePatternGenerator::getDecimal() const {
1241     return decimal;
1242 }
1243 
1244 void
1245 DateTimePatternGenerator::addCanonicalItems(UErrorCode&amp; status) {
1246     if (U_FAILURE(status)) { return; }
1247     UnicodeString  conflictingPattern;
1248 
</pre>
<hr />
<pre>
1251             addPattern(UnicodeString(Canonical_Items[i]), FALSE, conflictingPattern, status);
1252         }
1253         if (U_FAILURE(status)) { return; }
1254     }
1255 }
1256 
1257 void
1258 DateTimePatternGenerator::setDateTimeFormat(const UnicodeString&amp; dtFormat) {
1259     dateTimeFormat = dtFormat;
1260     // NUL-terminate for the C API.
1261     dateTimeFormat.getTerminatedBuffer();
1262 }
1263 
1264 const UnicodeString&amp;
1265 DateTimePatternGenerator::getDateTimeFormat() const {
1266     return dateTimeFormat;
1267 }
1268 
1269 void
1270 DateTimePatternGenerator::setDateTimeFromCalendar(const Locale&amp; locale, UErrorCode&amp; status) {
<span class="line-added">1271     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">1272 </span>
1273     const UChar *resStr;
1274     int32_t resStrLen = 0;
1275 
<span class="line-modified">1276     LocalPointer&lt;Calendar&gt; fCalendar(Calendar::createInstance(locale, status), status);</span>
1277     if (U_FAILURE(status)) { return; }
1278 
<span class="line-modified">1279     LocalUResourceBundlePointer calData(ures_open(nullptr, locale.getBaseName(), &amp;status));</span>
<span class="line-added">1280     if (U_FAILURE(status)) { return; }</span>
1281     ures_getByKey(calData.getAlias(), DT_DateTimeCalendarTag, calData.getAlias(), &amp;status);
<span class="line-added">1282     if (U_FAILURE(status)) { return; }</span>
1283 
1284     LocalUResourceBundlePointer dateTimePatterns;
<span class="line-modified">1285     if (fCalendar-&gt;getType() != nullptr &amp;&amp; *fCalendar-&gt;getType() != &#39;\0&#39;</span>
1286             &amp;&amp; uprv_strcmp(fCalendar-&gt;getType(), DT_DateTimeGregorianTag) != 0) {
1287         dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), fCalendar-&gt;getType(),
<span class="line-modified">1288                                                                 nullptr, &amp;status));</span>
1289         ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,
1290                                   dateTimePatterns.getAlias(), &amp;status);
1291     }
1292 
1293     if (dateTimePatterns.isNull() || status == U_MISSING_RESOURCE_ERROR) {
1294         status = U_ZERO_ERROR;
1295         dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), DT_DateTimeGregorianTag,
1296                                                                 dateTimePatterns.orphan(), &amp;status));
1297         ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,
1298                                   dateTimePatterns.getAlias(), &amp;status);
1299     }
1300     if (U_FAILURE(status)) { return; }
1301 
1302     if (ures_getSize(dateTimePatterns.getAlias()) &lt;= DateFormat::kDateTime)
1303     {
1304         status = U_INVALID_FORMAT_ERROR;
1305         return;
1306     }
1307     resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), (int32_t)DateFormat::kDateTime, &amp;resStrLen, &amp;status);
1308     setDateTimeFormat(UnicodeString(TRUE, resStr, resStrLen));


1309 }
1310 
1311 void
1312 DateTimePatternGenerator::setDecimalSymbols(const Locale&amp; locale, UErrorCode&amp; status) {
1313     DecimalFormatSymbols dfs = DecimalFormatSymbols(locale, status);
1314     if(U_SUCCESS(status)) {
1315         decimal = dfs.getSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol);
1316         // NUL-terminate for the C API.
1317         decimal.getTerminatedBuffer();
1318     }
1319 }
1320 
1321 UDateTimePatternConflict
1322 DateTimePatternGenerator::addPattern(
1323     const UnicodeString&amp; pattern,
1324     UBool override,
1325     UnicodeString &amp;conflictingPattern,
1326     UErrorCode&amp; status)
1327 {
<span class="line-modified">1328     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">1329         status = internalErrorCode;</span>
<span class="line-added">1330         return UDATPG_NO_CONFLICT;</span>
<span class="line-added">1331     }</span>
<span class="line-added">1332 </span>
<span class="line-added">1333     return addPatternWithSkeleton(pattern, nullptr, override, conflictingPattern, status);</span>
1334 }
1335 
1336 // For DateTimePatternGenerator::addPatternWithSkeleton -
1337 // If skeletonToUse is specified, then an availableFormats entry is being added. In this case:
1338 // 1. We pass that skeleton to matcher.set instead of having it derive a skeleton from the pattern.
1339 // 2. If the new entry&#39;s skeleton or basePattern does match an existing entry but that entry also had a skeleton specified
1340 // (i.e. it was also from availableFormats), then the new entry does not override it regardless of the value of the override
1341 // parameter. This prevents later availableFormats entries from a parent locale overriding earlier ones from the actual
1342 // specified locale. However, availableFormats entries *should* override entries with matching skeleton whose skeleton was
1343 // derived (i.e. entries derived from the standard date/time patters for the specified locale).
1344 // 3. When adding the pattern (patternMap-&gt;add), we set a new boolean to indicate that the added entry had a
1345 // specified skeleton (which sets a new field in the PtnElem in the PatternMap).
1346 UDateTimePatternConflict
1347 DateTimePatternGenerator::addPatternWithSkeleton(
1348     const UnicodeString&amp; pattern,
1349     const UnicodeString* skeletonToUse,
1350     UBool override,
1351     UnicodeString&amp; conflictingPattern,
1352     UErrorCode&amp; status)
1353 {
<span class="line-added">1354     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">1355         status = internalErrorCode;</span>
<span class="line-added">1356         return UDATPG_NO_CONFLICT;</span>
<span class="line-added">1357     }</span>
1358 
1359     UnicodeString basePattern;
1360     PtnSkeleton   skeleton;
1361     UDateTimePatternConflict conflictingStatus = UDATPG_NO_CONFLICT;
1362 
1363     DateTimeMatcher matcher;
<span class="line-modified">1364     if ( skeletonToUse == nullptr ) {</span>
1365         matcher.set(pattern, fp, skeleton);
1366         matcher.getBasePattern(basePattern);
1367     } else {
1368         matcher.set(*skeletonToUse, fp, skeleton); // no longer trims skeleton fields to max len 3, per #7930
1369         matcher.getBasePattern(basePattern); // or perhaps instead: basePattern = *skeletonToUse;
1370     }
1371     // We only care about base conflicts - and replacing the pattern associated with a base - if:
1372     // 1. the conflicting previous base pattern did *not* have an explicit skeleton; in that case the previous
1373     // base + pattern combination was derived from either (a) a canonical item, (b) a standard format, or
1374     // (c) a pattern specified programmatically with a previous call to addPattern (which would only happen
1375     // if we are getting here from a subsequent call to addPattern).
1376     // 2. a skeleton is specified for the current pattern, but override=false; in that case we are checking
1377     // availableFormats items from root, which should not override any previous entry with the same base.
1378     UBool entryHadSpecifiedSkeleton;
1379     const UnicodeString *duplicatePattern = patternMap-&gt;getPatternFromBasePattern(basePattern, entryHadSpecifiedSkeleton);
<span class="line-modified">1380     if (duplicatePattern != nullptr &amp;&amp; (!entryHadSpecifiedSkeleton || (skeletonToUse != nullptr &amp;&amp; !override))) {</span>
1381         conflictingStatus = UDATPG_BASE_CONFLICT;
1382         conflictingPattern = *duplicatePattern;
1383         if (!override) {
1384             return conflictingStatus;
1385         }
1386     }
1387     // The only time we get here with override=true and skeletonToUse!=null is when adding availableFormats
1388     // items from CLDR data. In that case, we don&#39;t want an item from a parent locale to replace an item with
1389     // same skeleton from the specified locale, so skip the current item if skeletonWasSpecified is true for
1390     // the previously-specified conflicting item.
<span class="line-modified">1391     const PtnSkeleton* entrySpecifiedSkeleton = nullptr;</span>
1392     duplicatePattern = patternMap-&gt;getPatternFromSkeleton(skeleton, &amp;entrySpecifiedSkeleton);
<span class="line-modified">1393     if (duplicatePattern != nullptr ) {</span>
1394         conflictingStatus = UDATPG_CONFLICT;
1395         conflictingPattern = *duplicatePattern;
<span class="line-modified">1396         if (!override || (skeletonToUse != nullptr &amp;&amp; entrySpecifiedSkeleton != nullptr)) {</span>
1397             return conflictingStatus;
1398         }
1399     }
<span class="line-modified">1400     patternMap-&gt;add(basePattern, skeleton, pattern, skeletonToUse != nullptr, status);</span>
1401     if(U_FAILURE(status)) {
1402         return conflictingStatus;
1403     }
1404 
1405     return UDATPG_NO_CONFLICT;
1406 }
1407 
1408 
1409 UDateTimePatternField
1410 DateTimePatternGenerator::getAppendFormatNumber(const char* field) const {
1411     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
1412         if (uprv_strcmp(CLDR_FIELD_APPEND[i], field)==0) {
1413             return (UDateTimePatternField)i;
1414         }
1415     }
1416     return UDATPG_FIELD_COUNT;
1417 }
1418 
1419 UDateTimePatternField
1420 DateTimePatternGenerator::getFieldAndWidthIndices(const char* key, UDateTimePGDisplayWidth* widthP) const {
</pre>
<hr />
<pre>
1427         for (int32_t i=UDATPG_WIDTH_COUNT-1; i&gt;0; --i) {
1428             if (uprv_strcmp(CLDR_FIELD_WIDTH[i], hyphenPtr)==0) {
1429                 *widthP=(UDateTimePGDisplayWidth)i;
1430                 break;
1431             }
1432         }
1433         *hyphenPtr = 0; // now delete width portion of key
1434     }
1435     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
1436         if (uprv_strcmp(CLDR_FIELD_NAME[i],cldrFieldKey)==0) {
1437             return (UDateTimePatternField)i;
1438         }
1439     }
1440     return UDATPG_FIELD_COUNT;
1441 }
1442 
1443 const UnicodeString*
1444 DateTimePatternGenerator::getBestRaw(DateTimeMatcher&amp; source,
1445                                      int32_t includeMask,
1446                                      DistanceInfo* missingFields,
<span class="line-added">1447                                      UErrorCode &amp;status,</span>
1448                                      const PtnSkeleton** specifiedSkeletonPtr) {
1449     int32_t bestDistance = 0x7fffffff;
1450     DistanceInfo tempInfo;
<span class="line-modified">1451     const UnicodeString *bestPattern=nullptr;</span>
<span class="line-modified">1452     const PtnSkeleton* specifiedSkeleton=nullptr;</span>
<span class="line-added">1453 </span>
<span class="line-added">1454     PatternMapIterator it(status);</span>
<span class="line-added">1455     if (U_FAILURE(status)) { return nullptr; }</span>
1456 

1457     for (it.set(*patternMap); it.hasNext(); ) {
1458         DateTimeMatcher trial = it.next();
1459         if (trial.equals(skipMatcher)) {
1460             continue;
1461         }
1462         int32_t distance=source.getDistance(trial, includeMask, tempInfo);
1463         if (distance&lt;bestDistance) {
1464             bestDistance=distance;
1465             bestPattern=patternMap-&gt;getPatternFromSkeleton(*trial.getSkeletonPtr(), &amp;specifiedSkeleton);
1466             missingFields-&gt;setTo(tempInfo);
1467             if (distance==0) {
1468                 break;
1469             }
1470         }
1471     }
1472 
1473     // If the best raw match had a specified skeleton and that skeleton was requested by the caller,
1474     // then return it too. This generally happens when the caller needs to pass that skeleton
1475     // through to adjustFieldTypes so the latter can do a better job.
1476     if (bestPattern &amp;&amp; specifiedSkeletonPtr) {
</pre>
<hr />
<pre>
1546                          adjFieldLen = field.length();
1547                     } else if (specifiedSkeleton) {
1548                         int32_t skelFieldLen = specifiedSkeleton-&gt;original.getFieldLength(typeValue);
1549                         UBool patFieldIsNumeric = (row-&gt;type &gt; 0);
1550                         UBool skelFieldIsNumeric = (specifiedSkeleton-&gt;type[typeValue] &gt; 0);
1551                         if (skelFieldLen == reqFieldLen || (patFieldIsNumeric &amp;&amp; !skelFieldIsNumeric) || (skelFieldIsNumeric &amp;&amp; !patFieldIsNumeric)) {
1552                             // don&#39;t adjust the field length in the found pattern
1553                             adjFieldLen = field.length();
1554                         }
1555                     }
1556                     UChar c = (typeValue!= UDATPG_HOUR_FIELD
1557                             &amp;&amp; typeValue!= UDATPG_MONTH_FIELD
1558                             &amp;&amp; typeValue!= UDATPG_WEEKDAY_FIELD
1559                             &amp;&amp; (typeValue!= UDATPG_YEAR_FIELD || reqFieldChar==CAP_Y))
1560                             ? reqFieldChar
1561                             : field.charAt(0);
1562                     if (typeValue == UDATPG_HOUR_FIELD &amp;&amp; (flags &amp; kDTPGSkeletonUsesCapJ) != 0) {
1563                         c = fDefaultHourFormatChar;
1564                     }
1565                     field.remove();
<span class="line-modified">1566                     for (int32_t j=adjFieldLen; j&gt;0; --j) {</span>
<span class="line-modified">1567                         field += c;</span>
1568                     }
1569             }
1570             newPattern+=field;
1571         }
1572     }
1573     return newPattern;
1574 }
1575 
1576 UnicodeString
<span class="line-modified">1577 DateTimePatternGenerator::getBestAppending(int32_t missingFields, int32_t flags, UErrorCode &amp;status, UDateTimePatternMatchOptions options) {</span>
<span class="line-added">1578     if (U_FAILURE(status)) {</span>
<span class="line-added">1579         return UnicodeString();</span>
<span class="line-added">1580     }</span>
1581     UnicodeString  resultPattern, tempPattern;
<span class="line-modified">1582     const UnicodeString* tempPatternPtr;</span>
1583     int32_t lastMissingFieldMask=0;
1584     if (missingFields!=0) {
1585         resultPattern=UnicodeString();
<span class="line-modified">1586         const PtnSkeleton* specifiedSkeleton=nullptr;</span>
<span class="line-modified">1587         tempPatternPtr = getBestRaw(*dtMatcher, missingFields, distanceInfo, status, &amp;specifiedSkeleton);</span>
<span class="line-added">1588         if (U_FAILURE(status)) {</span>
<span class="line-added">1589             return UnicodeString();</span>
<span class="line-added">1590         }</span>
<span class="line-added">1591         tempPattern = *tempPatternPtr;</span>
1592         resultPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);
1593         if ( distanceInfo-&gt;missingFieldMask==0 ) {
1594             return resultPattern;
1595         }
1596         while (distanceInfo-&gt;missingFieldMask!=0) { // precondition: EVERY single field must work!
1597             if ( lastMissingFieldMask == distanceInfo-&gt;missingFieldMask ) {
1598                 break;  // cannot find the proper missing field
1599             }
1600             if (((distanceInfo-&gt;missingFieldMask &amp; UDATPG_SECOND_AND_FRACTIONAL_MASK)==UDATPG_FRACTIONAL_MASK) &amp;&amp;
1601                 ((missingFields &amp; UDATPG_SECOND_AND_FRACTIONAL_MASK) == UDATPG_SECOND_AND_FRACTIONAL_MASK)) {
1602                 resultPattern = adjustFieldTypes(resultPattern, specifiedSkeleton, flags | kDTPGFixFractionalSeconds, options);
1603                 distanceInfo-&gt;missingFieldMask &amp;= ~UDATPG_FRACTIONAL_MASK;
1604                 continue;
1605             }
1606             int32_t startingMask = distanceInfo-&gt;missingFieldMask;
<span class="line-modified">1607             tempPatternPtr = getBestRaw(*dtMatcher, distanceInfo-&gt;missingFieldMask, distanceInfo, status, &amp;specifiedSkeleton);</span>
<span class="line-added">1608             if (U_FAILURE(status)) {</span>
<span class="line-added">1609                 return UnicodeString();</span>
<span class="line-added">1610             }</span>
<span class="line-added">1611             tempPattern = *tempPatternPtr;</span>
1612             tempPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);
1613             int32_t foundMask=startingMask&amp; ~distanceInfo-&gt;missingFieldMask;
1614             int32_t topField=getTopBitNumber(foundMask);
<span class="line-modified">1615 </span>
<span class="line-modified">1616             if (appendItemFormats[topField].length() != 0) {</span>
<span class="line-modified">1617                 UnicodeString appendName;</span>
<span class="line-modified">1618                 getAppendName((UDateTimePatternField)topField, appendName);</span>
<span class="line-modified">1619                 const UnicodeString *values[3] = {</span>
<span class="line-modified">1620                     &amp;resultPattern,</span>
<span class="line-modified">1621                     &amp;tempPattern,</span>
<span class="line-modified">1622                     &amp;appendName</span>
<span class="line-modified">1623                 };</span>
<span class="line-added">1624                 SimpleFormatter(appendItemFormats[topField], 2, 3, status).</span>
<span class="line-added">1625                     formatAndReplace(values, 3, resultPattern, nullptr, 0, status);</span>
<span class="line-added">1626             }</span>
1627             lastMissingFieldMask = distanceInfo-&gt;missingFieldMask;
1628         }
1629     }
1630     return resultPattern;
1631 }
1632 
1633 int32_t
<span class="line-modified">1634 DateTimePatternGenerator::getTopBitNumber(int32_t foundMask) const {</span>
1635     if ( foundMask==0 ) {
1636         return 0;
1637     }
1638     int32_t i=0;
1639     while (foundMask!=0) {
1640         foundMask &gt;&gt;=1;
1641         ++i;
1642     }
1643     if (i-1 &gt;UDATPG_ZONE_FIELD) {
1644         return UDATPG_ZONE_FIELD;
1645     }
1646     else
1647         return i-1;
1648 }
1649 
1650 void
1651 DateTimePatternGenerator::setAvailableFormat(const UnicodeString &amp;key, UErrorCode&amp; err)
1652 {
1653     fAvailableFormatKeyHash-&gt;puti(key, 1, err);
1654 }
1655 
1656 UBool
1657 DateTimePatternGenerator::isAvailableFormatSet(const UnicodeString &amp;key) const {
1658     return (UBool)(fAvailableFormatKeyHash-&gt;geti(key) == 1);
1659 }
1660 
1661 void
1662 DateTimePatternGenerator::copyHashtable(Hashtable *other, UErrorCode &amp;status) {
<span class="line-modified">1663     if (other == nullptr || U_FAILURE(status)) {</span>

1664         return;
1665     }
<span class="line-modified">1666     if (fAvailableFormatKeyHash != nullptr) {</span>
1667         delete fAvailableFormatKeyHash;
<span class="line-modified">1668         fAvailableFormatKeyHash = nullptr;</span>
1669     }
1670     initHashtable(status);
1671     if(U_FAILURE(status)){
1672         return;
1673     }
1674     int32_t pos = UHASH_FIRST;
<span class="line-modified">1675     const UHashElement* elem = nullptr;</span>
1676     // walk through the hash table and create a deep clone
<span class="line-modified">1677     while((elem = other-&gt;nextElement(pos))!= nullptr){</span>
1678         const UHashTok otherKeyTok = elem-&gt;key;
1679         UnicodeString* otherKey = (UnicodeString*)otherKeyTok.pointer;
1680         fAvailableFormatKeyHash-&gt;puti(*otherKey, 1, status);
1681         if(U_FAILURE(status)){
1682             return;
1683         }
1684     }
1685 }
1686 
1687 StringEnumeration*
1688 DateTimePatternGenerator::getSkeletons(UErrorCode&amp; status) const {
<span class="line-modified">1689     if (U_FAILURE(status)) {</span>
<span class="line-modified">1690         return nullptr;</span>
<span class="line-added">1691     }</span>
<span class="line-added">1692     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">1693         status = internalErrorCode;</span>
<span class="line-added">1694         return nullptr;</span>
<span class="line-added">1695     }</span>
<span class="line-added">1696     LocalPointer&lt;StringEnumeration&gt; skeletonEnumerator(</span>
<span class="line-added">1697         new DTSkeletonEnumeration(*patternMap, DT_SKELETON, status), status);</span>
<span class="line-added">1698 </span>
<span class="line-added">1699     return U_SUCCESS(status) ? skeletonEnumerator.orphan() : nullptr;</span>
1700 }
1701 
1702 const UnicodeString&amp;
1703 DateTimePatternGenerator::getPatternForSkeleton(const UnicodeString&amp; skeleton) const {
1704     PtnElem *curElem;
1705 
1706     if (skeleton.length() ==0) {
1707         return emptyString;
1708     }
1709     curElem = patternMap-&gt;getHeader(skeleton.charAt(0));
<span class="line-modified">1710     while ( curElem != nullptr ) {</span>
1711         if ( curElem-&gt;skeleton-&gt;getSkeleton()==skeleton ) {
1712             return curElem-&gt;pattern;
1713         }
<span class="line-modified">1714         curElem = curElem-&gt;next.getAlias();</span>
1715     }
1716     return emptyString;
1717 }
1718 
1719 StringEnumeration*
1720 DateTimePatternGenerator::getBaseSkeletons(UErrorCode&amp; status) const {
<span class="line-modified">1721     if (U_FAILURE(status)) {</span>
<span class="line-modified">1722         return nullptr;</span>
<span class="line-added">1723     }</span>
<span class="line-added">1724     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">1725         status = internalErrorCode;</span>
<span class="line-added">1726         return nullptr;</span>
<span class="line-added">1727     }</span>
<span class="line-added">1728     LocalPointer&lt;StringEnumeration&gt; baseSkeletonEnumerator(</span>
<span class="line-added">1729         new DTSkeletonEnumeration(*patternMap, DT_BASESKELETON, status), status);</span>
<span class="line-added">1730 </span>
<span class="line-added">1731     return U_SUCCESS(status) ? baseSkeletonEnumerator.orphan() : nullptr;</span>
1732 }
1733 
1734 StringEnumeration*
1735 DateTimePatternGenerator::getRedundants(UErrorCode&amp; status) {
<span class="line-modified">1736     if (U_FAILURE(status)) { return nullptr; }</span>
<span class="line-added">1737     if (U_FAILURE(internalErrorCode)) {</span>
<span class="line-added">1738         status = internalErrorCode;</span>
<span class="line-added">1739         return nullptr;</span>
<span class="line-added">1740     }</span>
<span class="line-added">1741     LocalPointer&lt;StringEnumeration&gt; output(new DTRedundantEnumeration(), status);</span>
<span class="line-added">1742     if (U_FAILURE(status)) { return nullptr; }</span>
1743     const UnicodeString *pattern;
<span class="line-modified">1744     PatternMapIterator it(status);</span>
<span class="line-added">1745     if (U_FAILURE(status)) { return nullptr; }</span>
<span class="line-added">1746 </span>
1747     for (it.set(*patternMap); it.hasNext(); ) {
1748         DateTimeMatcher current = it.next();
1749         pattern = patternMap-&gt;getPatternFromSkeleton(*(it.getSkeleton()));
1750         if ( isCanonicalItem(*pattern) ) {
1751             continue;
1752         }
<span class="line-modified">1753         if ( skipMatcher == nullptr ) {</span>
1754             skipMatcher = new DateTimeMatcher(current);
<span class="line-added">1755             if (skipMatcher == nullptr) {</span>
<span class="line-added">1756                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1757                 return nullptr;</span>
<span class="line-added">1758             }</span>
1759         }
1760         else {
1761             *skipMatcher = current;
1762         }
1763         UnicodeString trial = getBestPattern(current.getPattern(), status);
<span class="line-added">1764         if (U_FAILURE(status)) { return nullptr; }</span>
1765         if (trial == *pattern) {
<span class="line-modified">1766             ((DTRedundantEnumeration *)output.getAlias())-&gt;add(*pattern, status);</span>
<span class="line-added">1767             if (U_FAILURE(status)) { return nullptr; }</span>
1768         }
1769         if (current.equals(skipMatcher)) {
1770             continue;
1771         }
1772     }
<span class="line-modified">1773     return output.orphan();</span>
1774 }
1775 
1776 UBool
1777 DateTimePatternGenerator::isCanonicalItem(const UnicodeString&amp; item) const {
1778     if ( item.length() != 1 ) {
1779         return FALSE;
1780     }
1781     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
1782         if (item.charAt(0)==Canonical_Items[i]) {
1783             return TRUE;
1784         }
1785     }
1786     return FALSE;
1787 }
1788 
1789 
1790 DateTimePatternGenerator*
1791 DateTimePatternGenerator::clone() const {
1792     return new DateTimePatternGenerator(*this);
1793 }
1794 
1795 PatternMap::PatternMap() {
1796    for (int32_t i=0; i &lt; MAX_PATTERN_ENTRIES; ++i ) {
<span class="line-modified">1797        boot[i] = nullptr;</span>
1798    }
1799    isDupAllowed = TRUE;
1800 }
1801 
1802 void
1803 PatternMap::copyFrom(const PatternMap&amp; other, UErrorCode&amp; status) {
<span class="line-added">1804     if (U_FAILURE(status)) {</span>
<span class="line-added">1805         return;</span>
<span class="line-added">1806     }</span>
1807     this-&gt;isDupAllowed = other.isDupAllowed;
<span class="line-modified">1808     for (int32_t bootIndex = 0; bootIndex &lt; MAX_PATTERN_ENTRIES; ++bootIndex) {</span>
<span class="line-modified">1809         PtnElem *curElem, *otherElem, *prevElem=nullptr;</span>
1810         otherElem = other.boot[bootIndex];
<span class="line-modified">1811         while (otherElem != nullptr) {</span>
<span class="line-modified">1812             LocalPointer&lt;PtnElem&gt; newElem(new PtnElem(otherElem-&gt;basePattern, otherElem-&gt;pattern), status);</span>
<span class="line-modified">1813             if (U_FAILURE(status)) {</span>
<span class="line-modified">1814                 return; // out of memory</span>

1815             }
<span class="line-modified">1816             newElem-&gt;skeleton.adoptInsteadAndCheckErrorCode(new PtnSkeleton(*(otherElem-&gt;skeleton)), status);</span>
<span class="line-modified">1817             if (U_FAILURE(status)) {</span>
<span class="line-added">1818                 return; // out of memory</span>
1819             }
<span class="line-modified">1820             newElem-&gt;skeletonWasSpecified = otherElem-&gt;skeletonWasSpecified;</span>
<span class="line-modified">1821 </span>
<span class="line-modified">1822             // Release ownership from the LocalPointer of the PtnElem object.</span>
<span class="line-modified">1823             // The PtnElem will now be owned by either the boot (for the first entry in the linked-list)</span>
<span class="line-modified">1824             // or owned by the previous PtnElem object in the linked-list.</span>
<span class="line-modified">1825             curElem = newElem.orphan();</span>
<span class="line-modified">1826 </span>
<span class="line-modified">1827             if (this-&gt;boot[bootIndex] == nullptr) {</span>
<span class="line-added">1828                 this-&gt;boot[bootIndex] = curElem;</span>
<span class="line-added">1829             } else {</span>
<span class="line-added">1830                 if (prevElem != nullptr) {</span>
<span class="line-added">1831                     prevElem-&gt;next.adoptInstead(curElem);</span>
<span class="line-added">1832                 } else {</span>
<span class="line-added">1833                     UPRV_UNREACHABLE;</span>
<span class="line-added">1834                 }</span>
1835             }

1836             prevElem = curElem;
<span class="line-modified">1837             otherElem = otherElem-&gt;next.getAlias();</span>
1838         }
1839 
1840     }
1841 }
1842 
1843 PtnElem*
<span class="line-modified">1844 PatternMap::getHeader(UChar baseChar) const {</span>
1845     PtnElem* curElem;
1846 
1847     if ( (baseChar &gt;= CAP_A) &amp;&amp; (baseChar &lt;= CAP_Z) ) {
1848          curElem = boot[baseChar-CAP_A];
1849     }
1850     else {
1851         if ( (baseChar &gt;=LOW_A) &amp;&amp; (baseChar &lt;= LOW_Z) ) {
1852             curElem = boot[26+baseChar-LOW_A];
1853         }
1854         else {
<span class="line-modified">1855             return nullptr;</span>
1856         }
1857     }
1858     return curElem;
1859 }
1860 
1861 PatternMap::~PatternMap() {
1862    for (int32_t i=0; i &lt; MAX_PATTERN_ENTRIES; ++i ) {
<span class="line-modified">1863        if (boot[i] != nullptr ) {</span>
1864            delete boot[i];
<span class="line-modified">1865            boot[i] = nullptr;</span>
1866        }
1867    }
1868 }  // PatternMap destructor
1869 
1870 void
1871 PatternMap::add(const UnicodeString&amp; basePattern,
1872                 const PtnSkeleton&amp; skeleton,
1873                 const UnicodeString&amp; value,// mapped pattern value
1874                 UBool skeletonWasSpecified,
1875                 UErrorCode &amp;status) {
1876     UChar baseChar = basePattern.charAt(0);
1877     PtnElem *curElem, *baseElem;
1878     status = U_ZERO_ERROR;
1879 
1880     // the baseChar must be A-Z or a-z
1881     if ((baseChar &gt;= CAP_A) &amp;&amp; (baseChar &lt;= CAP_Z)) {
1882         baseElem = boot[baseChar-CAP_A];
1883     }
1884     else {
1885         if ((baseChar &gt;=LOW_A) &amp;&amp; (baseChar &lt;= LOW_Z)) {
1886             baseElem = boot[26+baseChar-LOW_A];
1887          }
1888          else {
1889              status = U_ILLEGAL_CHARACTER;
1890              return;
1891          }
1892     }
1893 
<span class="line-modified">1894     if (baseElem == nullptr) {</span>
<span class="line-modified">1895         LocalPointer&lt;PtnElem&gt; newElem(new PtnElem(basePattern, value), status);</span>
<span class="line-modified">1896         if (U_FAILURE(status)) {</span>
<span class="line-modified">1897             return; // out of memory</span>
<span class="line-modified">1898         }</span>
<span class="line-added">1899         newElem-&gt;skeleton.adoptInsteadAndCheckErrorCode(new PtnSkeleton(skeleton), status);</span>
<span class="line-added">1900         if (U_FAILURE(status)) {</span>
<span class="line-added">1901             return; // out of memory</span>
1902         }
<span class="line-added">1903         newElem-&gt;skeletonWasSpecified = skeletonWasSpecified;</span>
1904         if (baseChar &gt;= LOW_A) {
<span class="line-modified">1905             boot[26 + (baseChar - LOW_A)] = newElem.orphan(); // the boot array now owns the PtnElem.</span>
1906         }
1907         else {
<span class="line-modified">1908             boot[baseChar - CAP_A] = newElem.orphan(); // the boot array now owns the PtnElem.</span>
1909         }


1910     }
<span class="line-modified">1911     if ( baseElem != nullptr ) {</span>
1912         curElem = getDuplicateElem(basePattern, skeleton, baseElem);
1913 
<span class="line-modified">1914         if (curElem == nullptr) {</span>
1915             // add new element to the list.
1916             curElem = baseElem;
<span class="line-modified">1917             while( curElem -&gt; next != nullptr )</span>
1918             {
<span class="line-modified">1919                 curElem = curElem-&gt;next.getAlias();</span>
1920             }
<span class="line-modified">1921 </span>
<span class="line-modified">1922             LocalPointer&lt;PtnElem&gt; newElem(new PtnElem(basePattern, value), status);</span>
<span class="line-modified">1923             if (U_FAILURE(status)) {</span>
<span class="line-modified">1924                 return; // out of memory</span>
1925             }
<span class="line-modified">1926             newElem-&gt;skeleton.adoptInsteadAndCheckErrorCode(new PtnSkeleton(skeleton), status);</span>
<span class="line-modified">1927             if (U_FAILURE(status)) {</span>
<span class="line-modified">1928                 return; // out of memory</span>
<span class="line-added">1929             }</span>
<span class="line-added">1930             newElem-&gt;skeletonWasSpecified = skeletonWasSpecified;</span>
<span class="line-added">1931             curElem-&gt;next.adoptInstead(newElem.orphan());</span>
<span class="line-added">1932             curElem = curElem-&gt;next.getAlias();</span>
1933         }
1934         else {
1935             // Pattern exists in the list already.
1936             if ( !isDupAllowed ) {
1937                 return;
1938             }
1939             // Overwrite the value.
1940             curElem-&gt;pattern = value;
1941             // It was a bug that we were not doing the following previously,
1942             // though that bug hid other problems by making things partly work.
1943             curElem-&gt;skeletonWasSpecified = skeletonWasSpecified;
1944         }
1945     }
1946 }  // PatternMap::add
1947 
1948 // Find the pattern from the given basePattern string.
1949 const UnicodeString *
<span class="line-modified">1950 PatternMap::getPatternFromBasePattern(const UnicodeString&amp; basePattern, UBool&amp; skeletonWasSpecified) const { // key to search for</span>
1951    PtnElem *curElem;
1952 
<span class="line-modified">1953    if ((curElem=getHeader(basePattern.charAt(0)))==nullptr) {</span>
<span class="line-modified">1954        return nullptr;  // no match</span>
1955    }
1956 
1957    do  {
1958        if ( basePattern.compare(curElem-&gt;basePattern)==0 ) {
1959           skeletonWasSpecified = curElem-&gt;skeletonWasSpecified;
1960           return &amp;(curElem-&gt;pattern);
1961        }
<span class="line-modified">1962        curElem = curElem-&gt;next.getAlias();</span>
<span class="line-modified">1963    } while (curElem != nullptr);</span>
1964 
<span class="line-modified">1965    return nullptr;</span>
1966 }  // PatternMap::getFromBasePattern
1967 
1968 
1969 // Find the pattern from the given skeleton.
1970 // At least when this is called from getBestRaw &amp; addPattern (in which case specifiedSkeletonPtr is non-NULL),
1971 // the comparison should be based on skeleton.original (which is unique and tied to the distance measurement in bestRaw)
1972 // and not skeleton.baseOriginal (which is not unique); otherwise we may pick a different skeleton than the one with the
1973 // optimum distance value in getBestRaw. When this is called from public getRedundants (specifiedSkeletonPtr is NULL),
1974 // for now it will continue to compare based on baseOriginal so as not to change the behavior unnecessarily.
1975 const UnicodeString *
<span class="line-modified">1976 PatternMap::getPatternFromSkeleton(const PtnSkeleton&amp; skeleton, const PtnSkeleton** specifiedSkeletonPtr) const { // key to search for</span>
1977    PtnElem *curElem;
1978 
1979    if (specifiedSkeletonPtr) {
<span class="line-modified">1980        *specifiedSkeletonPtr = nullptr;</span>
1981    }
1982 
1983    // find boot entry
1984    UChar baseChar = skeleton.getFirstChar();
<span class="line-modified">1985    if ((curElem=getHeader(baseChar))==nullptr) {</span>
<span class="line-modified">1986        return nullptr;  // no match</span>
1987    }
1988 
1989    do  {
1990        UBool equal;
<span class="line-modified">1991        if (specifiedSkeletonPtr != nullptr) { // called from DateTimePatternGenerator::getBestRaw or addPattern, use original</span>
1992            equal = curElem-&gt;skeleton-&gt;original == skeleton.original;
1993        } else { // called from DateTimePatternGenerator::getRedundants, use baseOriginal
1994            equal = curElem-&gt;skeleton-&gt;baseOriginal == skeleton.baseOriginal;
1995        }
1996        if (equal) {
1997            if (specifiedSkeletonPtr &amp;&amp; curElem-&gt;skeletonWasSpecified) {
<span class="line-modified">1998                *specifiedSkeletonPtr = curElem-&gt;skeleton.getAlias();</span>
1999            }
2000            return &amp;(curElem-&gt;pattern);
2001        }
<span class="line-modified">2002        curElem = curElem-&gt;next.getAlias();</span>
<span class="line-modified">2003    } while (curElem != nullptr);</span>
2004 
<span class="line-modified">2005    return nullptr;</span>
2006 }
2007 
2008 UBool
<span class="line-modified">2009 PatternMap::equals(const PatternMap&amp; other) const {</span>
2010     if ( this==&amp;other ) {
2011         return TRUE;
2012     }
<span class="line-modified">2013     for (int32_t bootIndex = 0; bootIndex &lt; MAX_PATTERN_ENTRIES; ++bootIndex) {</span>
<span class="line-modified">2014         if (boot[bootIndex] == other.boot[bootIndex]) {</span>
2015             continue;
2016         }
<span class="line-modified">2017         if ((boot[bootIndex] == nullptr) || (other.boot[bootIndex] == nullptr)) {</span>
2018             return FALSE;
2019         }
2020         PtnElem *otherElem = other.boot[bootIndex];
2021         PtnElem *myElem = boot[bootIndex];
<span class="line-modified">2022         while ((otherElem != nullptr) || (myElem != nullptr)) {</span>
2023             if ( myElem == otherElem ) {
2024                 break;
2025             }
<span class="line-modified">2026             if ((otherElem == nullptr) || (myElem == nullptr)) {</span>
2027                 return FALSE;
2028             }
2029             if ( (myElem-&gt;basePattern != otherElem-&gt;basePattern) ||
2030                  (myElem-&gt;pattern != otherElem-&gt;pattern) ) {
2031                 return FALSE;
2032             }
<span class="line-modified">2033             if ((myElem-&gt;skeleton.getAlias() != otherElem-&gt;skeleton.getAlias()) &amp;&amp;</span>
2034                 !myElem-&gt;skeleton-&gt;equals(*(otherElem-&gt;skeleton))) {
2035                 return FALSE;
2036             }
<span class="line-modified">2037             myElem = myElem-&gt;next.getAlias();</span>
<span class="line-modified">2038             otherElem = otherElem-&gt;next.getAlias();</span>
2039         }
2040     }
2041     return TRUE;
2042 }
2043 
2044 // find any key existing in the mapping table already.
2045 // return TRUE if there is an existing key, otherwise return FALSE.
2046 PtnElem*
2047 PatternMap::getDuplicateElem(
2048             const UnicodeString &amp;basePattern,
2049             const PtnSkeleton &amp;skeleton,
<span class="line-modified">2050             PtnElem *baseElem) {</span>
2051    PtnElem *curElem;
2052 
<span class="line-modified">2053    if ( baseElem == nullptr ) {</span>
<span class="line-modified">2054          return nullptr;</span>
2055    }
2056    else {
2057          curElem = baseElem;
2058    }
2059    do {
2060      if ( basePattern.compare(curElem-&gt;basePattern)==0 ) {
<span class="line-modified">2061          UBool isEqual = TRUE;</span>
<span class="line-modified">2062          for (int32_t i = 0; i &lt; UDATPG_FIELD_COUNT; ++i) {</span>
2063             if (curElem-&gt;skeleton-&gt;type[i] != skeleton.type[i] ) {
<span class="line-modified">2064                 isEqual = FALSE;</span>
2065                 break;
2066             }
2067         }
2068         if (isEqual) {
2069             return curElem;
2070         }
2071      }
<span class="line-modified">2072      curElem = curElem-&gt;next.getAlias();</span>
<span class="line-modified">2073    } while( curElem != nullptr );</span>
2074 
2075    // end of the list
<span class="line-modified">2076    return nullptr;</span>
2077 
2078 }  // PatternMap::getDuplicateElem
2079 
2080 DateTimeMatcher::DateTimeMatcher(void) {
2081 }
2082 
2083 DateTimeMatcher::~DateTimeMatcher() {}
2084 
2085 DateTimeMatcher::DateTimeMatcher(const DateTimeMatcher&amp; other) {
2086     copyFrom(other.skeleton);
2087 }
2088 
2089 
2090 void
2091 DateTimeMatcher::set(const UnicodeString&amp; pattern, FormatParser* fp) {
2092     PtnSkeleton localSkeleton;
2093     return set(pattern, fp, localSkeleton);
2094 }
2095 
2096 void
2097 DateTimeMatcher::set(const UnicodeString&amp; pattern, FormatParser* fp, PtnSkeleton&amp; skeletonResult) {
2098     int32_t i;
2099     for (i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
2100         skeletonResult.type[i] = NONE;
2101     }
2102     skeletonResult.original.clear();
2103     skeletonResult.baseOriginal.clear();
2104     skeletonResult.addedDefaultDayPeriod = FALSE;
2105 
2106     fp-&gt;set(pattern);
2107     for (i=0; i &lt; fp-&gt;itemNumber; i++) {
2108         const UnicodeString&amp; value = fp-&gt;items[i];
2109         // don&#39;t skip &#39;a&#39; anymore, dayPeriod handled specially below
2110 
2111         if ( fp-&gt;isQuoteLiteral(value) ) {
2112             UnicodeString quoteLiteral;
2113             fp-&gt;getQuoteLiteral(quoteLiteral, &amp;i);
2114             continue;
2115         }
2116         int32_t canonicalIndex = fp-&gt;getCanonicalIndex(value);
<span class="line-modified">2117         if (canonicalIndex &lt; 0) {</span>
2118             continue;
2119         }
2120         const dtTypeElem *row = &amp;dtTypes[canonicalIndex];
2121         int32_t field = row-&gt;field;
2122         skeletonResult.original.populate(field, value);
2123         UChar repeatChar = row-&gt;patternChar;
2124         int32_t repeatCount = row-&gt;minLen;
2125         skeletonResult.baseOriginal.populate(field, repeatChar, repeatCount);
2126         int16_t subField = row-&gt;type;
<span class="line-modified">2127         if (row-&gt;type &gt; 0) {</span>
<span class="line-modified">2128             U_ASSERT(value.length() &lt; INT16_MAX);</span>
<span class="line-added">2129             subField += static_cast&lt;int16_t&gt;(value.length());</span>
2130         }
2131         skeletonResult.type[field] = subField;
2132     }
2133     // #13183, handle special behavior for day period characters (a, b, B)
2134     if (!skeletonResult.original.isFieldEmpty(UDATPG_HOUR_FIELD)) {
2135         if (skeletonResult.original.getFieldChar(UDATPG_HOUR_FIELD)==LOW_H || skeletonResult.original.getFieldChar(UDATPG_HOUR_FIELD)==CAP_K) {
2136             // We have a skeleton with 12-hour-cycle format
2137             if (skeletonResult.original.isFieldEmpty(UDATPG_DAYPERIOD_FIELD)) {
2138                 // But we do not have a day period in the skeleton; add the default DAYPERIOD (currently &quot;a&quot;)
2139                 for (i = 0; dtTypes[i].patternChar != 0; i++) {
2140                     if ( dtTypes[i].field == UDATPG_DAYPERIOD_FIELD ) {
2141                         // first entry for UDATPG_DAYPERIOD_FIELD
2142                         skeletonResult.original.populate(UDATPG_DAYPERIOD_FIELD, dtTypes[i].patternChar, dtTypes[i].minLen);
2143                         skeletonResult.baseOriginal.populate(UDATPG_DAYPERIOD_FIELD, dtTypes[i].patternChar, dtTypes[i].minLen);
2144                         skeletonResult.type[UDATPG_DAYPERIOD_FIELD] = dtTypes[i].type;
2145                         skeletonResult.addedDefaultDayPeriod = TRUE;
2146                         break;
2147                     }
2148                 }
2149             }
</pre>
<hr />
<pre>
2153             skeletonResult.baseOriginal.clearField(UDATPG_DAYPERIOD_FIELD);
2154             skeletonResult.type[UDATPG_DAYPERIOD_FIELD] = NONE;
2155         }
2156     }
2157     copyFrom(skeletonResult);
2158 }
2159 
2160 void
2161 DateTimeMatcher::getBasePattern(UnicodeString &amp;result ) {
2162     result.remove(); // Reset the result first.
2163     skeleton.baseOriginal.appendTo(result);
2164 }
2165 
2166 UnicodeString
2167 DateTimeMatcher::getPattern() {
2168     UnicodeString result;
2169     return skeleton.original.appendTo(result);
2170 }
2171 
2172 int32_t
<span class="line-modified">2173 DateTimeMatcher::getDistance(const DateTimeMatcher&amp; other, int32_t includeMask, DistanceInfo&amp; distanceInfo) const {</span>
<span class="line-modified">2174     int32_t result = 0;</span>
2175     distanceInfo.clear();
2176     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
2177         int32_t myType = (includeMask&amp;(1&lt;&lt;i))==0 ? 0 : skeleton.type[i];
2178         int32_t otherType = other.skeleton.type[i];
2179         if (myType==otherType) {
2180             continue;
2181         }
2182         if (myType==0) {// and other is not
2183             result += EXTRA_FIELD;
2184             distanceInfo.addExtra(i);
2185         }
2186         else {
2187             if (otherType==0) {
2188                 result += MISSING_FIELD;
2189                 distanceInfo.addMissing(i);
2190             }
2191             else {
2192                 result += abs(myType - otherType);
2193             }
2194         }
2195 
2196     }
2197     return result;
2198 }
2199 
2200 void
2201 DateTimeMatcher::copyFrom(const PtnSkeleton&amp; newSkeleton) {
2202     skeleton.copyFrom(newSkeleton);
2203 }
2204 
2205 void
2206 DateTimeMatcher::copyFrom() {
2207     // same as clear
2208     skeleton.clear();
2209 }
2210 
2211 UBool
2212 DateTimeMatcher::equals(const DateTimeMatcher* other) const {
<span class="line-modified">2213     if (other==nullptr) { return FALSE; }</span>
2214     return skeleton.original == other-&gt;skeleton.original;
2215 }
2216 
2217 int32_t
<span class="line-modified">2218 DateTimeMatcher::getFieldMask() const {</span>
<span class="line-modified">2219     int32_t result = 0;</span>
2220 
2221     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
2222         if (skeleton.type[i]!=0) {
2223             result |= (1&lt;&lt;i);
2224         }
2225     }
2226     return result;
2227 }
2228 
2229 PtnSkeleton*
2230 DateTimeMatcher::getSkeletonPtr() {
2231     return &amp;skeleton;
2232 }
2233 
2234 FormatParser::FormatParser () {
2235     status = START;
<span class="line-modified">2236     itemNumber = 0;</span>
2237 }
2238 
2239 
2240 FormatParser::~FormatParser () {
2241 }
2242 
2243 
2244 // Find the next token with the starting position and length
2245 // Note: the startPos may
2246 FormatParser::TokenStatus
2247 FormatParser::setTokens(const UnicodeString&amp; pattern, int32_t startPos, int32_t *len) {
<span class="line-modified">2248     int32_t curLoc = startPos;</span>
2249     if ( curLoc &gt;= pattern.length()) {
2250         return DONE;
2251     }
2252     // check the current char is between A-Z or a-z
2253     do {
2254         UChar c=pattern.charAt(curLoc);
2255         if ( (c&gt;=CAP_A &amp;&amp; c&lt;=CAP_Z) || (c&gt;=LOW_A &amp;&amp; c&lt;=LOW_Z) ) {
2256            curLoc++;
2257         }
2258         else {
2259                startPos = curLoc;
2260                *len=1;
2261                return ADD_TOKEN;
2262         }
2263 
2264         if ( pattern.charAt(curLoc)!= pattern.charAt(startPos) ) {
2265             break;  // not the same token
2266         }
2267     } while(curLoc &lt;= pattern.length());
2268     *len = curLoc-startPos;
2269     return ADD_TOKEN;
2270 }
2271 
2272 void
2273 FormatParser::set(const UnicodeString&amp; pattern) {
<span class="line-modified">2274     int32_t startPos = 0;</span>
<span class="line-modified">2275     TokenStatus result = START;</span>
<span class="line-modified">2276     int32_t len = 0;</span>
<span class="line-modified">2277     itemNumber = 0;</span>
2278 
2279     do {
2280         result = setTokens( pattern, startPos, &amp;len );
2281         if ( result == ADD_TOKEN )
2282         {
2283             items[itemNumber++] = UnicodeString(pattern, startPos, len );
2284             startPos += len;
2285         }
2286         else {
2287             break;
2288         }
2289     } while (result==ADD_TOKEN &amp;&amp; itemNumber &lt; MAX_DT_TOKEN);
2290 }
2291 
2292 int32_t
2293 FormatParser::getCanonicalIndex(const UnicodeString&amp; s, UBool strict) {
2294     int32_t len = s.length();
2295     if (len == 0) {
2296         return -1;
2297     }
</pre>
<hr />
<pre>
2308     while (dtTypes[i].patternChar != 0x0000) {
2309         if ( dtTypes[i].patternChar != ch ) {
2310             ++i;
2311             continue;
2312         }
2313         bestRow = i;
2314         if (dtTypes[i].patternChar != dtTypes[i+1].patternChar) {
2315             return i;
2316         }
2317         if (dtTypes[i+1].minLen &lt;= len) {
2318             ++i;
2319             continue;
2320         }
2321         return i;
2322     }
2323     return strict ? -1 : bestRow;
2324 }
2325 
2326 UBool
2327 FormatParser::isQuoteLiteral(const UnicodeString&amp; s) {
<span class="line-modified">2328     return (UBool)(s.charAt(0) == SINGLE_QUOTE);</span>
2329 }
2330 
<span class="line-modified">2331 // This function assumes the current itemIndex points to the quote literal.</span>
2332 // Please call isQuoteLiteral prior to this function.
2333 void
2334 FormatParser::getQuoteLiteral(UnicodeString&amp; quote, int32_t *itemIndex) {
<span class="line-modified">2335     int32_t i = *itemIndex;</span>
2336 
2337     quote.remove();
2338     if (items[i].charAt(0)==SINGLE_QUOTE) {
2339         quote += items[i];
2340         ++i;
2341     }
2342     while ( i &lt; itemNumber ) {
2343         if ( items[i].charAt(0)==SINGLE_QUOTE ) {
2344             if ( (i+1&lt;itemNumber) &amp;&amp; (items[i+1].charAt(0)==SINGLE_QUOTE)) {
2345                 // two single quotes e.g. &#39;o&#39;&#39;clock&#39;
2346                 quote += items[i++];
2347                 quote += items[i++];
2348                 continue;
2349             }
2350             else {
2351                 quote += items[i];
2352                 break;
2353             }
2354         }
2355         else {
2356             quote += items[i];
2357         }
2358         ++i;
2359     }
2360     *itemIndex=i;
2361 }
2362 
2363 UBool
<span class="line-modified">2364 FormatParser::isPatternSeparator(const UnicodeString&amp; field) const {</span>
2365     for (int32_t i=0; i&lt;field.length(); ++i ) {
2366         UChar c= field.charAt(i);
2367         if ( (c==SINGLE_QUOTE) || (c==BACKSLASH) || (c==SPACE) || (c==COLON) ||
2368              (c==QUOTATION_MARK) || (c==COMMA) || (c==HYPHEN) ||(items[i].charAt(0)==DOT) ) {
2369             continue;
2370         }
2371         else {
2372             return FALSE;
2373         }
2374     }
2375     return TRUE;
2376 }
2377 
2378 DistanceInfo::~DistanceInfo() {}
2379 
2380 void
<span class="line-modified">2381 DistanceInfo::setTo(const DistanceInfo&amp; other) {</span>
2382     missingFieldMask = other.missingFieldMask;
2383     extraFieldMask= other.extraFieldMask;
2384 }
2385 
<span class="line-modified">2386 PatternMapIterator::PatternMapIterator(UErrorCode&amp; status) :</span>
<span class="line-modified">2387     bootIndex(0), nodePtr(nullptr), matcher(nullptr), patternMap(nullptr)</span>
<span class="line-modified">2388 {</span>
<span class="line-modified">2389     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">2390     matcher.adoptInsteadAndCheckErrorCode(new DateTimeMatcher(), status);</span>
2391 }
2392 

2393 PatternMapIterator::~PatternMapIterator() {

2394 }
2395 
2396 void
2397 PatternMapIterator::set(PatternMap&amp; newPatternMap) {
2398     this-&gt;patternMap=&amp;newPatternMap;
2399 }
2400 
2401 PtnSkeleton*
<span class="line-modified">2402 PatternMapIterator::getSkeleton() const {</span>
<span class="line-modified">2403     if ( nodePtr == nullptr ) {</span>
<span class="line-modified">2404         return nullptr;</span>
2405     }
2406     else {
<span class="line-modified">2407         return nodePtr-&gt;skeleton.getAlias();</span>
2408     }
2409 }
2410 
2411 UBool
<span class="line-modified">2412 PatternMapIterator::hasNext() const {</span>
<span class="line-modified">2413     int32_t headIndex = bootIndex;</span>
<span class="line-modified">2414     PtnElem *curPtr = nodePtr;</span>
2415 
<span class="line-modified">2416     if (patternMap==nullptr) {</span>
2417         return FALSE;
2418     }
2419     while ( headIndex &lt; MAX_PATTERN_ENTRIES ) {
<span class="line-modified">2420         if ( curPtr != nullptr ) {</span>
<span class="line-modified">2421             if ( curPtr-&gt;next != nullptr ) {</span>
2422                 return TRUE;
2423             }
2424             else {
2425                 headIndex++;
<span class="line-modified">2426                 curPtr=nullptr;</span>
2427                 continue;
2428             }
2429         }
2430         else {
<span class="line-modified">2431             if ( patternMap-&gt;boot[headIndex] != nullptr ) {</span>
2432                 return TRUE;
2433             }
2434             else {
2435                 headIndex++;
2436                 continue;
2437             }
2438         }

2439     }
2440     return FALSE;
2441 }
2442 
2443 DateTimeMatcher&amp;
2444 PatternMapIterator::next() {
2445     while ( bootIndex &lt; MAX_PATTERN_ENTRIES ) {
<span class="line-modified">2446         if ( nodePtr != nullptr ) {</span>
<span class="line-modified">2447             if ( nodePtr-&gt;next != nullptr ) {</span>
<span class="line-modified">2448                 nodePtr = nodePtr-&gt;next.getAlias();</span>
2449                 break;
2450             }
2451             else {
2452                 bootIndex++;
<span class="line-modified">2453                 nodePtr=nullptr;</span>
2454                 continue;
2455             }
2456         }
2457         else {
<span class="line-modified">2458             if ( patternMap-&gt;boot[bootIndex] != nullptr ) {</span>
2459                 nodePtr = patternMap-&gt;boot[bootIndex];
2460                 break;
2461             }
2462             else {
2463                 bootIndex++;
2464                 continue;
2465             }
2466         }
2467     }
<span class="line-modified">2468     if (nodePtr!=nullptr) {</span>
2469         matcher-&gt;copyFrom(*nodePtr-&gt;skeleton);
2470     }
2471     else {
2472         matcher-&gt;copyFrom();
2473     }
2474     return *matcher;
2475 }
2476 
2477 
2478 SkeletonFields::SkeletonFields() {
2479     // Set initial values to zero
2480     clear();
2481 }
2482 
2483 void SkeletonFields::clear() {
2484     uprv_memset(chars, 0, sizeof(chars));
2485     uprv_memset(lengths, 0, sizeof(lengths));
2486 }
2487 
2488 void SkeletonFields::copyFrom(const SkeletonFields&amp; other) {
</pre>
<hr />
<pre>
2587     UnicodeString result;
2588     result = baseOriginal.appendTo(result);
2589     int32_t pos;
2590     if (addedDefaultDayPeriod &amp;&amp; (pos = result.indexOf(LOW_A)) &gt;= 0) {
2591         // for backward compatibility: if DateTimeMatcher.set added a single &#39;a&#39; that
2592         // was not in the provided skeleton, remove it here before returning skeleton.
2593         result.remove(pos, 1);
2594     }
2595     return result;
2596 }
2597 
2598 UChar
2599 PtnSkeleton::getFirstChar() const {
2600     return baseOriginal.getFirstChar();
2601 }
2602 
2603 PtnSkeleton::~PtnSkeleton() {
2604 }
2605 
2606 PtnElem::PtnElem(const UnicodeString &amp;basePat, const UnicodeString &amp;pat) :
<span class="line-modified">2607     basePattern(basePat), skeleton(nullptr), pattern(pat), next(nullptr)</span>



2608 {
2609 }
2610 
2611 PtnElem::~PtnElem() {





2612 }
2613 
<span class="line-modified">2614 DTSkeletonEnumeration::DTSkeletonEnumeration(PatternMap&amp; patternMap, dtStrEnum type, UErrorCode&amp; status) : fSkeletons(nullptr) {</span>
2615     PtnElem  *curElem;
2616     PtnSkeleton *curSkeleton;
2617     UnicodeString s;
2618     int32_t bootIndex;
2619 
2620     pos=0;
<span class="line-modified">2621     fSkeletons.adoptInsteadAndCheckErrorCode(new UVector(status), status);</span>
2622     if (U_FAILURE(status)) {

2623         return;
2624     }
<span class="line-added">2625 </span>
2626     for (bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {
2627         curElem = patternMap.boot[bootIndex];
<span class="line-modified">2628         while (curElem!=nullptr) {</span>
2629             switch(type) {
2630                 case DT_BASESKELETON:
2631                     s=curElem-&gt;basePattern;
2632                     break;
2633                 case DT_PATTERN:
2634                     s=curElem-&gt;pattern;
2635                     break;
2636                 case DT_SKELETON:
<span class="line-modified">2637                     curSkeleton=curElem-&gt;skeleton.getAlias();</span>
2638                     s=curSkeleton-&gt;getSkeleton();
2639                     break;
2640             }
2641             if ( !isCanonicalItem(s) ) {
<span class="line-modified">2642                 LocalPointer&lt;UnicodeString&gt; newElem(new UnicodeString(s), status);</span>
<span class="line-added">2643                 if (U_FAILURE(status)) {</span>
<span class="line-added">2644                     return;</span>
<span class="line-added">2645                 }</span>
<span class="line-added">2646                 fSkeletons-&gt;addElement(newElem.getAlias(), status);</span>
2647                 if (U_FAILURE(status)) {
<span class="line-modified">2648                     fSkeletons.adoptInstead(nullptr);</span>

2649                     return;
2650                 }
<span class="line-added">2651                 newElem.orphan(); // fSkeletons vector now owns the UnicodeString.</span>
2652             }
<span class="line-modified">2653             curElem = curElem-&gt;next.getAlias();</span>
2654         }
2655     }
<span class="line-modified">2656     if ((bootIndex==MAX_PATTERN_ENTRIES) &amp;&amp; (curElem!=nullptr) ) {</span>
2657         status = U_BUFFER_OVERFLOW_ERROR;
2658     }
2659 }
2660 
2661 const UnicodeString*
2662 DTSkeletonEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">2663     if (U_SUCCESS(status) &amp;&amp; fSkeletons.isValid() &amp;&amp; pos &lt; fSkeletons-&gt;size()) {</span>
2664         return (const UnicodeString*)fSkeletons-&gt;elementAt(pos++);
2665     }
<span class="line-modified">2666     return nullptr;</span>
2667 }
2668 
2669 void
2670 DTSkeletonEnumeration::reset(UErrorCode&amp; /*status*/) {
2671     pos=0;
2672 }
2673 
2674 int32_t
2675 DTSkeletonEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">2676    return (fSkeletons.isNull()) ? 0 : fSkeletons-&gt;size();</span>
2677 }
2678 
2679 UBool
2680 DTSkeletonEnumeration::isCanonicalItem(const UnicodeString&amp; item) {
2681     if ( item.length() != 1 ) {
2682         return FALSE;
2683     }
2684     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
2685         if (item.charAt(0)==Canonical_Items[i]) {
2686             return TRUE;
2687         }
2688     }
2689     return FALSE;
2690 }
2691 
2692 DTSkeletonEnumeration::~DTSkeletonEnumeration() {
2693     UnicodeString *s;
<span class="line-modified">2694     if (fSkeletons.isValid()) {</span>
<span class="line-modified">2695         for (int32_t i = 0; i &lt; fSkeletons-&gt;size(); ++i) {</span>
<span class="line-modified">2696             if ((s = (UnicodeString *)fSkeletons-&gt;elementAt(i)) != nullptr) {</span>
<span class="line-added">2697                 delete s;</span>
<span class="line-added">2698             }</span>
2699         }
2700     }

2701 }
2702 
<span class="line-modified">2703 DTRedundantEnumeration::DTRedundantEnumeration() : pos(0), fPatterns(nullptr) {</span>


2704 }
2705 
2706 void
2707 DTRedundantEnumeration::add(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
<span class="line-modified">2708     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">2709     if (fPatterns.isNull())  {</span>
<span class="line-modified">2710         fPatterns.adoptInsteadAndCheckErrorCode(new UVector(status), status);</span>
2711         if (U_FAILURE(status)) {


2712             return;
2713        }
2714     }
<span class="line-modified">2715     LocalPointer&lt;UnicodeString&gt; newElem(new UnicodeString(pattern), status);</span>
2716     if (U_FAILURE(status)) {


2717         return;
2718     }
<span class="line-added">2719     fPatterns-&gt;addElement(newElem.getAlias(), status);</span>
<span class="line-added">2720     if (U_FAILURE(status)) {</span>
<span class="line-added">2721         fPatterns.adoptInstead(nullptr);</span>
<span class="line-added">2722         return;</span>
<span class="line-added">2723     }</span>
<span class="line-added">2724     newElem.orphan(); // fPatterns now owns the string.</span>
2725 }
2726 
2727 const UnicodeString*
2728 DTRedundantEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">2729     if (U_SUCCESS(status) &amp;&amp; fPatterns.isValid() &amp;&amp; pos &lt; fPatterns-&gt;size()) {</span>
2730         return (const UnicodeString*)fPatterns-&gt;elementAt(pos++);
2731     }
<span class="line-modified">2732     return nullptr;</span>
2733 }
2734 
2735 void
2736 DTRedundantEnumeration::reset(UErrorCode&amp; /*status*/) {
2737     pos=0;
2738 }
2739 
2740 int32_t
2741 DTRedundantEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">2742     return (fPatterns.isNull()) ? 0 : fPatterns-&gt;size();</span>
2743 }
2744 
2745 UBool
<span class="line-modified">2746 DTRedundantEnumeration::isCanonicalItem(const UnicodeString&amp; item) const {</span>
2747     if ( item.length() != 1 ) {
2748         return FALSE;
2749     }
2750     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
2751         if (item.charAt(0)==Canonical_Items[i]) {
2752             return TRUE;
2753         }
2754     }
2755     return FALSE;
2756 }
2757 
2758 DTRedundantEnumeration::~DTRedundantEnumeration() {
2759     UnicodeString *s;
<span class="line-modified">2760     if (fPatterns.isValid()) {</span>
<span class="line-modified">2761         for (int32_t i = 0; i &lt; fPatterns-&gt;size(); ++i) {</span>
<span class="line-modified">2762             if ((s = (UnicodeString *)fPatterns-&gt;elementAt(i)) != nullptr) {</span>
<span class="line-added">2763                 delete s;</span>
<span class="line-added">2764             }</span>
2765         }
2766     }

2767 }
2768 
2769 U_NAMESPACE_END
2770 
2771 
2772 #endif /* #if !UCONFIG_NO_FORMATTING */
2773 
2774 //eof
</pre>
</td>
</tr>
</table>
<center><a href="dtitvinf.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtptngen_impl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>