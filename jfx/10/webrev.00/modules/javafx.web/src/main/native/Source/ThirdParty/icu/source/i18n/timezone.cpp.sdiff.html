<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/timezone.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="smpdtfmt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="tmunit.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/timezone.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  98 #define kMAX_CUSTOM_HOUR    23
  99 #define kMAX_CUSTOM_MIN     59
 100 #define kMAX_CUSTOM_SEC     59
 101 #define MINUS 0x002D
 102 #define PLUS 0x002B
 103 #define ZERO_DIGIT 0x0030
 104 #define COLON 0x003A
 105 
 106 // Static data and constants
 107 
 108 static const UChar         WORLD[] = {0x30, 0x30, 0x31, 0x00}; /* &quot;001&quot; */
 109 
 110 static const UChar         GMT_ID[] = {0x47, 0x4D, 0x54, 0x00}; /* &quot;GMT&quot; */
 111 static const UChar         UNKNOWN_ZONE_ID[] = {0x45, 0x74, 0x63, 0x2F, 0x55, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x00}; /* &quot;Etc/Unknown&quot; */
 112 static const int32_t       GMT_ID_LENGTH = 3;
 113 static const int32_t       UNKNOWN_ZONE_ID_LENGTH = 11;
 114 
 115 static icu::TimeZone* DEFAULT_ZONE = NULL;
 116 static icu::UInitOnce gDefaultZoneInitOnce = U_INITONCE_INITIALIZER;
 117 
<span class="line-modified"> 118 static icu::TimeZone* _GMT = NULL;</span>
<span class="line-modified"> 119 static icu::TimeZone* _UNKNOWN_ZONE = NULL;</span>




 120 static icu::UInitOnce gStaticZonesInitOnce = U_INITONCE_INITIALIZER;

 121 
 122 static char TZDATA_VERSION[16];
 123 static icu::UInitOnce gTZDataVersionInitOnce = U_INITONCE_INITIALIZER;
 124 
 125 static int32_t* MAP_SYSTEM_ZONES = NULL;
 126 static int32_t* MAP_CANONICAL_SYSTEM_ZONES = NULL;
 127 static int32_t* MAP_CANONICAL_SYSTEM_LOCATION_ZONES = NULL;
 128 
 129 static int32_t LEN_SYSTEM_ZONES = 0;
 130 static int32_t LEN_CANONICAL_SYSTEM_ZONES = 0;
 131 static int32_t LEN_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
 132 
 133 static icu::UInitOnce gSystemZonesInitOnce = U_INITONCE_INITIALIZER;
 134 static icu::UInitOnce gCanonicalZonesInitOnce = U_INITONCE_INITIALIZER;
 135 static icu::UInitOnce gCanonicalLocationZonesInitOnce = U_INITONCE_INITIALIZER;
 136 
 137 U_CDECL_BEGIN
 138 static UBool U_CALLCONV timeZone_cleanup(void)
 139 {
 140     U_NAMESPACE_USE
 141     delete DEFAULT_ZONE;
 142     DEFAULT_ZONE = NULL;
 143     gDefaultZoneInitOnce.reset();
 144 
<span class="line-modified"> 145     delete _GMT;</span>
<span class="line-modified"> 146     _GMT = NULL;</span>
<span class="line-modified"> 147     delete _UNKNOWN_ZONE;</span>
<span class="line-modified"> 148     _UNKNOWN_ZONE = NULL;</span>
<span class="line-modified"> 149     gStaticZonesInitOnce.reset();</span>

 150 
 151     uprv_memset(TZDATA_VERSION, 0, sizeof(TZDATA_VERSION));
 152     gTZDataVersionInitOnce.reset();
 153 
 154     LEN_SYSTEM_ZONES = 0;
 155     uprv_free(MAP_SYSTEM_ZONES);
 156     MAP_SYSTEM_ZONES = 0;
 157     gSystemZonesInitOnce.reset();
 158 
 159     LEN_CANONICAL_SYSTEM_ZONES = 0;
 160     uprv_free(MAP_CANONICAL_SYSTEM_ZONES);
 161     MAP_CANONICAL_SYSTEM_ZONES = 0;
 162     gCanonicalZonesInitOnce.reset();
 163 
 164     LEN_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
 165     uprv_free(MAP_CANONICAL_SYSTEM_LOCATION_ZONES);
 166     MAP_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
 167     gCanonicalLocationZonesInitOnce.reset();
 168 
 169     return TRUE;
</pre>
<hr />
<pre>
 255     U_DEBUG_TZ_MSG((&quot;loadRule(%s)\n&quot;, key));
 256     UResourceBundle *r = ures_getByKey(top, kRULES, oldbundle, &amp;status);
 257     U_DEBUG_TZ_MSG((&quot;loadRule(%s) -&gt; kRULES [%s]\n&quot;, key, u_errorName(status)));
 258     r = ures_getByKey(r, key, r, &amp;status);
 259     U_DEBUG_TZ_MSG((&quot;loadRule(%s) -&gt; item [%s]\n&quot;, key, u_errorName(status)));
 260     return r;
 261 }
 262 
 263 /**
 264  * Given an ID, open the appropriate resource for the given time zone.
 265  * Dereference aliases if necessary.
 266  * @param id zone id
 267  * @param res resource, which must be ready for use (initialized but not open)
 268  * @param ec input-output error code
 269  * @return top-level resource bundle
 270  */
 271 static UResourceBundle* openOlsonResource(const UnicodeString&amp; id,
 272                                           UResourceBundle&amp; res,
 273                                           UErrorCode&amp; ec)
 274 {
<span class="line-modified"> 275 #if U_DEBUG_TZ</span>
 276     char buf[128];
 277     id.extract(0, sizeof(buf)-1, buf, sizeof(buf), &quot;&quot;);
 278 #endif
 279     UResourceBundle *top = ures_openDirect(0, kZONEINFO, &amp;ec);
 280     U_DEBUG_TZ_MSG((&quot;pre: res sz=%d\n&quot;, ures_getSize(&amp;res)));
 281     /* &amp;res = */ getZoneByName(top, id, &amp;res, ec);
 282     // Dereference if this is an alias.  Docs say result should be 1
 283     // but it is 0 in 2.8 (?).
 284     U_DEBUG_TZ_MSG((&quot;Loading zone &#39;%s&#39; (%s, size %d) - %s\n&quot;, buf, ures_getKey((UResourceBundle*)&amp;res), ures_getSize(&amp;res), u_errorName(ec)));
 285     if (ures_getType(&amp;res) == URES_INT) {
 286         int32_t deref = ures_getInt(&amp;res, &amp;ec) + 0;
 287         U_DEBUG_TZ_MSG((&quot;getInt: %s - type is %d\n&quot;, u_errorName(ec), ures_getType(&amp;res)));
 288         UResourceBundle *ares = ures_getByKey(top, kZONES, NULL, &amp;ec); // dereference Zones section
 289         ures_getByIndex(ares, deref, &amp;res, &amp;ec);
 290         ures_close(ares);
 291         U_DEBUG_TZ_MSG((&quot;alias to #%d (%s) - %s\n&quot;, deref, &quot;??&quot;, u_errorName(ec)));
 292     } else {
 293         U_DEBUG_TZ_MSG((&quot;not an alias - size %d\n&quot;, ures_getSize(&amp;res)));
 294     }
 295     U_DEBUG_TZ_MSG((&quot;%s - final status is %s\n&quot;, buf, u_errorName(ec)));
 296     return top;
 297 }
 298 
 299 // -------------------------------------
 300 
 301 namespace {
 302 
 303 void U_CALLCONV initStaticTimeZones() {
 304     // Initialize _GMT independently of other static data; it should
 305     // be valid even if we can&#39;t load the time zone UDataMemory.
 306     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
<span class="line-modified"> 307     _UNKNOWN_ZONE = new SimpleTimeZone(0, UnicodeString(TRUE, UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH));</span>
<span class="line-modified"> 308     _GMT = new SimpleTimeZone(0, UnicodeString(TRUE, GMT_ID, GMT_ID_LENGTH));</span>




 309 }
 310 
 311 }  // anonymous namespace
 312 
 313 const TimeZone&amp; U_EXPORT2
 314 TimeZone::getUnknown()
 315 {
 316     umtx_initOnce(gStaticZonesInitOnce, &amp;initStaticTimeZones);
<span class="line-modified"> 317     return *_UNKNOWN_ZONE;</span>
 318 }
 319 
 320 const TimeZone* U_EXPORT2
 321 TimeZone::getGMT(void)
 322 {
 323     umtx_initOnce(gStaticZonesInitOnce, &amp;initStaticTimeZones);
<span class="line-modified"> 324     return _GMT;</span>
 325 }
 326 
 327 // *****************************************************************************
 328 // class TimeZone
 329 // *****************************************************************************
 330 
 331 UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(TimeZone)
 332 
 333 TimeZone::TimeZone()
 334     :   UObject(), fID()
 335 {
 336 }
 337 
 338 // -------------------------------------
 339 
 340 TimeZone::TimeZone(const UnicodeString &amp;id)
 341     :   UObject(), fID(id)
 342 {
 343 }
 344 
</pre>
<hr />
<pre>
 365 }
 366 
 367 // -------------------------------------
 368 
 369 UBool
 370 TimeZone::operator==(const TimeZone&amp; that) const
 371 {
 372     return typeid(*this) == typeid(that) &amp;&amp;
 373         fID == that.fID;
 374 }
 375 
 376 // -------------------------------------
 377 
 378 namespace {
 379 TimeZone*
 380 createSystemTimeZone(const UnicodeString&amp; id, UErrorCode&amp; ec) {
 381     if (U_FAILURE(ec)) {
 382         return NULL;
 383     }
 384     TimeZone* z = 0;
<span class="line-modified"> 385     UResourceBundle res;</span>
<span class="line-removed"> 386     ures_initStackObject(&amp;res);</span>
 387     U_DEBUG_TZ_MSG((&quot;pre-err=%s\n&quot;, u_errorName(ec)));
<span class="line-modified"> 388     UResourceBundle *top = openOlsonResource(id, res, ec);</span>
 389     U_DEBUG_TZ_MSG((&quot;post-err=%s\n&quot;, u_errorName(ec)));
 390     if (U_SUCCESS(ec)) {
<span class="line-modified"> 391         z = new OlsonTimeZone(top, &amp;res, id, ec);</span>
 392         if (z == NULL) {
<span class="line-modified"> 393           U_DEBUG_TZ_MSG((&quot;cstz: olson time zone failed to initialize - err %s\n&quot;, u_errorName(ec)));</span>

 394         }
 395     }
<span class="line-removed"> 396     ures_close(&amp;res);</span>
 397     ures_close(top);
 398     if (U_FAILURE(ec)) {
 399         U_DEBUG_TZ_MSG((&quot;cstz: failed to create, err %s\n&quot;, u_errorName(ec)));
 400         delete z;
<span class="line-modified"> 401         z = 0;</span>
 402     }
 403     return z;
 404 }
 405 
 406 /**
 407  * Lookup the given name in our system zone table.  If found,
 408  * instantiate a new zone of that name and return it.  If not
 409  * found, return 0.
 410  */
 411 TimeZone*
 412 createSystemTimeZone(const UnicodeString&amp; id) {
 413     UErrorCode ec = U_ZERO_ERROR;
 414     return createSystemTimeZone(id, ec);
 415 }
 416 
 417 }
 418 
 419 TimeZone* U_EXPORT2
 420 TimeZone::createTimeZone(const UnicodeString&amp; ID)
 421 {
 422     /* We first try to lookup the zone ID in our system list.  If this
 423      * fails, we try to parse it as a custom string GMT[+-]hh:mm.  If
 424      * all else fails, we return GMT, which is probably not what the
 425      * user wants, but at least is a functioning TimeZone object.
 426      *
 427      * We cannot return NULL, because that would break compatibility
 428      * with the JDK.
 429      */
 430     TimeZone* result = createSystemTimeZone(ID);
 431 
 432     if (result == NULL) {
 433         U_DEBUG_TZ_MSG((&quot;failed to load system time zone with id - falling to custom&quot;));
 434         result = createCustomTimeZone(ID);
 435     }
 436     if (result == NULL) {
 437         U_DEBUG_TZ_MSG((&quot;failed to load time zone with id - falling to Etc/Unknown(GMT)&quot;));
 438         const TimeZone&amp; unknown = getUnknown();
<span class="line-modified"> 439         if (_UNKNOWN_ZONE == NULL) {                   // Cannot test (&amp;unknown == NULL) because the</span>
<span class="line-modified"> 440           U_DEBUG_TZ_MSG((&quot;failed to getUnknown()&quot;));  // behavior of NULL references is undefined.</span>
<span class="line-removed"> 441         } else {</span>
<span class="line-removed"> 442           result = unknown.clone();</span>
<span class="line-removed"> 443         }</span>
 444     }
 445     return result;
 446 }
 447 
 448 // -------------------------------------
 449 
 450 TimeZone* U_EXPORT2
 451 TimeZone::detectHostTimeZone()
 452 {
<span class="line-modified"> 453     // We access system timezone data through TPlatformUtilities,</span>
<span class="line-modified"> 454     // including tzset(), timezone, and tzname[].</span>
 455     int32_t rawOffset = 0;
 456     const char *hostID;

 457 
 458     // First, try to create a system timezone, based
 459     // on the string ID in tzname[0].
 460 
 461     uprv_tzset(); // Initialize tz... system data
 462 
 463     uprv_tzname_clear_cache();
 464 
 465     // Get the timezone ID from the host.  This function should do
 466     // any required host-specific remapping; e.g., on Windows this
<span class="line-modified"> 467     // function maps the Date and Time control panel setting to an</span>
<span class="line-removed"> 468     // ICU timezone ID.</span>
 469     hostID = uprv_tzname(0);
 470 
 471     // Invert sign because UNIX semantics are backwards
 472     rawOffset = uprv_timezone() * -U_MILLIS_PER_SECOND;
 473 
 474     TimeZone* hostZone = NULL;
 475 
<span class="line-removed"> 476     /* Make sure that the string is NULL terminated to prevent BoundsChecker/Purify warnings. */</span>
 477     UnicodeString hostStrID(hostID, -1, US_INV);
<span class="line-modified"> 478     hostStrID.append((UChar)0);</span>
<span class="line-modified"> 479     hostStrID.truncate(hostStrID.length()-1);</span>






 480     hostZone = createSystemTimeZone(hostStrID);
 481 
 482 #if U_PLATFORM_USES_ONLY_WIN32_API
 483     // hostID points to a heap-allocated location on Windows.
 484     uprv_free(const_cast&lt;char *&gt;(hostID));
 485 #endif
 486 
 487     int32_t hostIDLen = hostStrID.length();
 488     if (hostZone != NULL &amp;&amp; rawOffset != hostZone-&gt;getRawOffset()
 489         &amp;&amp; (3 &lt;= hostIDLen &amp;&amp; hostIDLen &lt;= 4))
 490     {
 491         // Uh oh. This probably wasn&#39;t a good id.
 492         // It was probably an ambiguous abbreviation
 493         delete hostZone;
 494         hostZone = NULL;
 495     }
 496 
 497     // Construct a fixed standard zone with the host&#39;s ID
 498     // and raw offset.
<span class="line-modified"> 499     if (hostZone == NULL) {</span>
 500         hostZone = new SimpleTimeZone(rawOffset, hostStrID);
 501     }
 502 
<span class="line-modified"> 503     // If we _still_ don&#39;t have a time zone, use GMT.</span>
 504     //
 505     // Note: This is extremely unlikely situation. If
 506     // new SimpleTimeZone(...) above fails, the following
 507     // code may also fail.
 508     if (hostZone == NULL) {
<span class="line-modified"> 509         const TimeZone* temptz = TimeZone::getGMT();</span>
<span class="line-modified"> 510         // If we can&#39;t use GMT, get out.</span>
<span class="line-modified"> 511         if (temptz == NULL) {</span>
<span class="line-removed"> 512             return NULL;</span>
<span class="line-removed"> 513         }</span>
<span class="line-removed"> 514         hostZone = temptz-&gt;clone();</span>
 515     }
 516 
 517     return hostZone;
 518 }
 519 
 520 // -------------------------------------
 521 
 522 /**
 523  * Initialize DEFAULT_ZONE from the system default time zone.
 524  * Upon return, DEFAULT_ZONE will not be NULL, unless operator new()
 525  * returns NULL.
 526  */
 527 static void U_CALLCONV initDefault()
 528 {
 529     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
 530 
 531     // If setDefault() has already been called we can skip getting the
 532     // default zone information from the system.
 533     if (DEFAULT_ZONE != NULL) {
 534         return;
</pre>
<hr />
<pre>
 969 }
 970 
 971 StringEnumeration* U_EXPORT2
 972 TimeZone::createEnumeration(int32_t rawOffset) {
 973     UErrorCode ec = U_ZERO_ERROR;
 974     return TZEnumeration::create(UCAL_ZONE_TYPE_ANY, NULL, &amp;rawOffset, ec);
 975 }
 976 
 977 StringEnumeration* U_EXPORT2
 978 TimeZone::createEnumeration(const char* country) {
 979     UErrorCode ec = U_ZERO_ERROR;
 980     return TZEnumeration::create(UCAL_ZONE_TYPE_ANY, country, NULL, ec);
 981 }
 982 
 983 // ---------------------------------------
 984 
 985 int32_t U_EXPORT2
 986 TimeZone::countEquivalentIDs(const UnicodeString&amp; id) {
 987     int32_t result = 0;
 988     UErrorCode ec = U_ZERO_ERROR;
<span class="line-modified"> 989     UResourceBundle res;</span>
<span class="line-removed"> 990     ures_initStackObject(&amp;res);</span>
 991     U_DEBUG_TZ_MSG((&quot;countEquivalentIDs..\n&quot;));
<span class="line-modified"> 992     UResourceBundle *top = openOlsonResource(id, res, ec);</span>
 993     if (U_SUCCESS(ec)) {
<span class="line-modified"> 994         UResourceBundle r;</span>
<span class="line-modified"> 995         ures_initStackObject(&amp;r);</span>
<span class="line-modified"> 996         ures_getByKey(&amp;res, kLINKS, &amp;r, &amp;ec);</span>
<span class="line-removed"> 997         ures_getIntVector(&amp;r, &amp;result, &amp;ec);</span>
<span class="line-removed"> 998         ures_close(&amp;r);</span>
 999     }
<span class="line-removed">1000     ures_close(&amp;res);</span>
1001     ures_close(top);
1002     return result;
1003 }
1004 
1005 // ---------------------------------------
1006 
1007 const UnicodeString U_EXPORT2
1008 TimeZone::getEquivalentID(const UnicodeString&amp; id, int32_t index) {
1009     U_DEBUG_TZ_MSG((&quot;gEI(%d)\n&quot;, index));
1010     UnicodeString result;
1011     UErrorCode ec = U_ZERO_ERROR;
<span class="line-modified">1012     UResourceBundle res;</span>
<span class="line-modified">1013     ures_initStackObject(&amp;res);</span>
<span class="line-removed">1014     UResourceBundle *top = openOlsonResource(id, res, ec);</span>
1015     int32_t zone = -1;
1016     if (U_SUCCESS(ec)) {
<span class="line-modified">1017         UResourceBundle r;</span>
<span class="line-removed">1018         ures_initStackObject(&amp;r);</span>
1019         int32_t size;
<span class="line-modified">1020         ures_getByKey(&amp;res, kLINKS, &amp;r, &amp;ec);</span>
<span class="line-modified">1021         const int32_t* v = ures_getIntVector(&amp;r, &amp;size, &amp;ec);</span>
1022         if (U_SUCCESS(ec)) {
1023             if (index &gt;= 0 &amp;&amp; index &lt; size) {
1024                 zone = v[index];
1025             }
1026         }
<span class="line-removed">1027         ures_close(&amp;r);</span>
1028     }
<span class="line-removed">1029     ures_close(&amp;res);</span>
1030     if (zone &gt;= 0) {
1031         UResourceBundle *ares = ures_getByKey(top, kNAMES, NULL, &amp;ec); // dereference Zones section
1032         if (U_SUCCESS(ec)) {
1033             int32_t idLen = 0;
<span class="line-modified">1034             const UChar* id = ures_getStringByIndex(ares, zone, &amp;idLen, &amp;ec);</span>
<span class="line-modified">1035             result.fastCopyFrom(UnicodeString(TRUE, id, idLen));</span>
1036             U_DEBUG_TZ_MSG((&quot;gei(%d) -&gt; %d, len%d, %s\n&quot;, index, zone, result.length(), u_errorName(ec)));
1037         }
1038         ures_close(ares);
1039     }
1040     ures_close(top);
1041 #if defined(U_DEBUG_TZ)
1042     if(result.length() ==0) {
1043       U_DEBUG_TZ_MSG((&quot;equiv [__, #%d] -&gt; 0 (%s)\n&quot;, index, u_errorName(ec)));
1044     }
1045 #endif
1046     return result;
1047 }
1048 
1049 // ---------------------------------------
1050 
1051 // These methods are used by ZoneMeta class only.
1052 
1053 const UChar*
1054 TimeZone::findID(const UnicodeString&amp; id) {
1055     const UChar *result = NULL;
</pre>
<hr />
<pre>
1164 
1165     return u_terminateChars(region, capacity, resultLen, &amp;status);
1166 }
1167 
1168 // ---------------------------------------
1169 
1170 
1171 UnicodeString&amp;
1172 TimeZone::getDisplayName(UnicodeString&amp; result) const
1173 {
1174     return getDisplayName(FALSE,LONG,Locale::getDefault(), result);
1175 }
1176 
1177 UnicodeString&amp;
1178 TimeZone::getDisplayName(const Locale&amp; locale, UnicodeString&amp; result) const
1179 {
1180     return getDisplayName(FALSE, LONG, locale, result);
1181 }
1182 
1183 UnicodeString&amp;
<span class="line-modified">1184 TimeZone::getDisplayName(UBool daylight, EDisplayType style, UnicodeString&amp; result)  const</span>
1185 {
<span class="line-modified">1186     return getDisplayName(daylight,style, Locale::getDefault(), result);</span>
1187 }
1188 //--------------------------------------
1189 int32_t
1190 TimeZone::getDSTSavings()const {
1191     if (useDaylightTime()) {
1192         return 3600000;
1193     }
1194     return 0;
1195 }
1196 //---------------------------------------
1197 UnicodeString&amp;
<span class="line-modified">1198 TimeZone::getDisplayName(UBool daylight, EDisplayType style, const Locale&amp; locale, UnicodeString&amp; result) const</span>
1199 {
1200     UErrorCode status = U_ZERO_ERROR;
1201     UDate date = Calendar::getNow();
<span class="line-modified">1202     UTimeZoneFormatTimeType timeType;</span>
1203     int32_t offset;
1204 
1205     if (style == GENERIC_LOCATION || style == LONG_GENERIC || style == SHORT_GENERIC) {
1206         LocalPointer&lt;TimeZoneFormat&gt; tzfmt(TimeZoneFormat::createInstance(locale, status));
1207         if (U_FAILURE(status)) {
1208             result.remove();
1209             return result;
1210         }
1211         // Generic format
1212         switch (style) {
1213         case GENERIC_LOCATION:
1214             tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_LOCATION, *this, date, result, &amp;timeType);
1215             break;
1216         case LONG_GENERIC:
1217             tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_LONG, *this, date, result, &amp;timeType);
1218             break;
1219         case SHORT_GENERIC:
1220             tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_SHORT, *this, date, result, &amp;timeType);
1221             break;
1222         default:
<span class="line-modified">1223             U_ASSERT(FALSE);</span>
1224         }
1225         // Generic format many use Localized GMT as the final fallback.
1226         // When Localized GMT format is used, the result might not be
1227         // appropriate for the requested daylight value.
<span class="line-modified">1228         if ((daylight &amp;&amp; timeType == UTZFMT_TIME_TYPE_STANDARD) || (!daylight &amp;&amp; timeType == UTZFMT_TIME_TYPE_DAYLIGHT)) {</span>
<span class="line-modified">1229             offset = daylight ? getRawOffset() + getDSTSavings() : getRawOffset();</span>
1230             if (style == SHORT_GENERIC) {
1231                 tzfmt-&gt;formatOffsetShortLocalizedGMT(offset, result, status);
1232             } else {
1233                 tzfmt-&gt;formatOffsetLocalizedGMT(offset, result, status);
1234             }
1235         }
1236     } else if (style == LONG_GMT || style == SHORT_GMT) {
1237         LocalPointer&lt;TimeZoneFormat&gt; tzfmt(TimeZoneFormat::createInstance(locale, status));
1238         if (U_FAILURE(status)) {
1239             result.remove();
1240             return result;
1241         }
<span class="line-modified">1242         offset = daylight &amp;&amp; useDaylightTime() ? getRawOffset() + getDSTSavings() : getRawOffset();</span>
1243         switch (style) {
1244         case LONG_GMT:
1245             tzfmt-&gt;formatOffsetLocalizedGMT(offset, result, status);
1246             break;
1247         case SHORT_GMT:
1248             tzfmt-&gt;formatOffsetISO8601Basic(offset, FALSE, FALSE, FALSE, result, status);
1249             break;
1250         default:
<span class="line-modified">1251             U_ASSERT(FALSE);</span>
1252         }
1253 
1254     } else {
1255         U_ASSERT(style == LONG || style == SHORT || style == SHORT_COMMONLY_USED);
1256         UTimeZoneNameType nameType = UTZNM_UNKNOWN;
1257         switch (style) {
1258         case LONG:
<span class="line-modified">1259             nameType = daylight ? UTZNM_LONG_DAYLIGHT : UTZNM_LONG_STANDARD;</span>
1260             break;
1261         case SHORT:
1262         case SHORT_COMMONLY_USED:
<span class="line-modified">1263             nameType = daylight ? UTZNM_SHORT_DAYLIGHT : UTZNM_SHORT_STANDARD;</span>
1264             break;
1265         default:
<span class="line-modified">1266             U_ASSERT(FALSE);</span>
1267         }
1268         LocalPointer&lt;TimeZoneNames&gt; tznames(TimeZoneNames::createInstance(locale, status));
1269         if (U_FAILURE(status)) {
1270             result.remove();
1271             return result;
1272         }
1273         UnicodeString canonicalID(ZoneMeta::getCanonicalCLDRID(*this));
1274         tznames-&gt;getDisplayName(canonicalID, nameType, date, result);
1275         if (result.isEmpty()) {
1276             // Fallback to localized GMT
1277             LocalPointer&lt;TimeZoneFormat&gt; tzfmt(TimeZoneFormat::createInstance(locale, status));
<span class="line-modified">1278             offset = daylight &amp;&amp; useDaylightTime() ? getRawOffset() + getDSTSavings() : getRawOffset();</span>
1279             if (style == LONG) {
1280                 tzfmt-&gt;formatOffsetLocalizedGMT(offset, result, status);
1281             } else {
1282                 tzfmt-&gt;formatOffsetShortLocalizedGMT(offset, result, status);
1283             }
1284         }
1285     }
1286     if (U_FAILURE(status)) {
1287         result.remove();
1288     }
1289     return  result;
1290 }
1291 
1292 /**
1293  * Parse a custom time zone identifier and return a corresponding zone.
1294  * @param id a string of the form GMT[+-]hh:mm, GMT[+-]hhmm, or
1295  * GMT[+-]hh.
1296  * @return a newly created SimpleTimeZone with the given offset and
1297  * no Daylight Savings Time, or null if the id cannot be parsed.
1298 */
</pre>
<hr />
<pre>
1479             } else {
1480                 id += (UChar)(ZERO_DIGIT + sec/10);
1481             }
1482             id += (UChar)(ZERO_DIGIT + sec%10);
1483         }
1484     }
1485     return id;
1486 }
1487 
1488 
1489 UBool
1490 TimeZone::hasSameRules(const TimeZone&amp; other) const
1491 {
1492     return (getRawOffset() == other.getRawOffset() &amp;&amp;
1493             useDaylightTime() == other.useDaylightTime());
1494 }
1495 
1496 static void U_CALLCONV initTZDataVersion(UErrorCode &amp;status) {
1497     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
1498     int32_t len = 0;
<span class="line-modified">1499     UResourceBundle *bundle = ures_openDirect(NULL, kZONEINFO, &amp;status);</span>
<span class="line-modified">1500     const UChar *tzver = ures_getStringByKey(bundle, kTZVERSION, &amp;len, &amp;status);</span>

1501 
1502     if (U_SUCCESS(status)) {
1503         if (len &gt;= (int32_t)sizeof(TZDATA_VERSION)) {
1504             // Ensure that there is always space for a trailing nul in TZDATA_VERSION
1505             len = sizeof(TZDATA_VERSION) - 1;
1506         }
1507         u_UCharsToChars(tzver, TZDATA_VERSION, len);
1508     }
<span class="line-removed">1509     ures_close(bundle);</span>
<span class="line-removed">1510 </span>
1511 }
1512 
1513 const char*
1514 TimeZone::getTZDataVersion(UErrorCode&amp; status)
1515 {
1516     umtx_initOnce(gTZDataVersionInitOnce, &amp;initTZDataVersion, status);
1517     return (const char*)TZDATA_VERSION;
1518 }
1519 
1520 UnicodeString&amp;
1521 TimeZone::getCanonicalID(const UnicodeString&amp; id, UnicodeString&amp; canonicalID, UErrorCode&amp; status)
1522 {
1523     UBool isSystemID = FALSE;
1524     return getCanonicalID(id, canonicalID, isSystemID, status);
1525 }
1526 
1527 UnicodeString&amp;
1528 TimeZone::getCanonicalID(const UnicodeString&amp; id, UnicodeString&amp; canonicalID, UBool&amp; isSystemID,
1529                          UErrorCode&amp; status)
1530 {
</pre>
<hr />
<pre>
1595             if (U_FAILURE(status)) {
1596                 break;
1597             }
1598             if (ures_getType(regionalData) != URES_STRING) {
1599                 continue;
1600             }
1601             int32_t len;
1602             const UChar *tzids = ures_getString(regionalData, &amp;len, &amp;status);
1603             if (U_FAILURE(status)) {
1604                 break;
1605             }
1606 
1607             const UChar *start = tzids;
1608             UBool hasNext = TRUE;
1609             while (hasNext) {
1610                 const UChar *end = u_strchr(start, (UChar)0x20);
1611                 if (end == NULL) {
1612                     end = tzids + len;
1613                     hasNext = FALSE;
1614                 }
<span class="line-modified">1615                 if (canonicalID.compare(start, end - start) == 0) {</span>
1616                     winid = UnicodeString(ures_getKey(winzone), -1 , US_INV);
1617                     found = TRUE;
1618                     break;
1619                 }
1620                 start = end + 1;
1621             }
1622         }
1623         ures_close(regionalData);
1624     }
1625     ures_close(winzone);
1626     ures_close(mapTimezones);
1627 
1628     return winid;
1629 }
1630 
1631 #define MAX_WINDOWS_ID_SIZE 128
1632 
1633 UnicodeString&amp;
1634 TimeZone::getIDForWindowsID(const UnicodeString&amp; winid, const char* region, UnicodeString&amp; id, UErrorCode&amp; status) {
1635     id.remove();
</pre>
<hr />
<pre>
1656 
1657     ures_getByKey(zones, winidKey, zones, &amp;tmperr); // use tmperr, because windows mapping might not
1658                                                     // be avaiable by design
1659     if (U_FAILURE(tmperr)) {
1660         ures_close(zones);
1661         return id;
1662     }
1663 
1664     const UChar *tzid = NULL;
1665     int32_t len = 0;
1666     UBool gotID = FALSE;
1667     if (region) {
1668         const UChar *tzids = ures_getStringByKey(zones, region, &amp;len, &amp;tmperr); // use tmperr, because
1669                                                                                 // regional mapping is optional
1670         if (U_SUCCESS(tmperr)) {
1671             // first ID delimited by space is the defasult one
1672             const UChar *end = u_strchr(tzids, (UChar)0x20);
1673             if (end == NULL) {
1674                 id.setTo(tzids, -1);
1675             } else {
<span class="line-modified">1676                 id.setTo(tzids, end - tzids);</span>
1677             }
1678             gotID = TRUE;
1679         }
1680     }
1681 
1682     if (!gotID) {
1683         tzid = ures_getStringByKey(zones, &quot;001&quot;, &amp;len, &amp;status);    // using status, because &quot;001&quot; must be
1684                                                                 // available at this point
1685         if (U_SUCCESS(status)) {
1686             id.setTo(tzid, len);
1687         }
1688     }
1689 
1690     ures_close(zones);
1691     return id;
1692 }
1693 
1694 
1695 U_NAMESPACE_END
1696 
</pre>
</td>
<td>
<hr />
<pre>
  98 #define kMAX_CUSTOM_HOUR    23
  99 #define kMAX_CUSTOM_MIN     59
 100 #define kMAX_CUSTOM_SEC     59
 101 #define MINUS 0x002D
 102 #define PLUS 0x002B
 103 #define ZERO_DIGIT 0x0030
 104 #define COLON 0x003A
 105 
 106 // Static data and constants
 107 
 108 static const UChar         WORLD[] = {0x30, 0x30, 0x31, 0x00}; /* &quot;001&quot; */
 109 
 110 static const UChar         GMT_ID[] = {0x47, 0x4D, 0x54, 0x00}; /* &quot;GMT&quot; */
 111 static const UChar         UNKNOWN_ZONE_ID[] = {0x45, 0x74, 0x63, 0x2F, 0x55, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x00}; /* &quot;Etc/Unknown&quot; */
 112 static const int32_t       GMT_ID_LENGTH = 3;
 113 static const int32_t       UNKNOWN_ZONE_ID_LENGTH = 11;
 114 
 115 static icu::TimeZone* DEFAULT_ZONE = NULL;
 116 static icu::UInitOnce gDefaultZoneInitOnce = U_INITONCE_INITIALIZER;
 117 
<span class="line-modified"> 118 alignas(icu::SimpleTimeZone)</span>
<span class="line-modified"> 119 static char gRawGMT[sizeof(icu::SimpleTimeZone)];</span>
<span class="line-added"> 120 </span>
<span class="line-added"> 121 alignas(icu::SimpleTimeZone)</span>
<span class="line-added"> 122 static char gRawUNKNOWN[sizeof(icu::SimpleTimeZone)];</span>
<span class="line-added"> 123 </span>
 124 static icu::UInitOnce gStaticZonesInitOnce = U_INITONCE_INITIALIZER;
<span class="line-added"> 125 static UBool gStaticZonesInitialized = FALSE; // Whether the static zones are initialized and ready to use.</span>
 126 
 127 static char TZDATA_VERSION[16];
 128 static icu::UInitOnce gTZDataVersionInitOnce = U_INITONCE_INITIALIZER;
 129 
 130 static int32_t* MAP_SYSTEM_ZONES = NULL;
 131 static int32_t* MAP_CANONICAL_SYSTEM_ZONES = NULL;
 132 static int32_t* MAP_CANONICAL_SYSTEM_LOCATION_ZONES = NULL;
 133 
 134 static int32_t LEN_SYSTEM_ZONES = 0;
 135 static int32_t LEN_CANONICAL_SYSTEM_ZONES = 0;
 136 static int32_t LEN_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
 137 
 138 static icu::UInitOnce gSystemZonesInitOnce = U_INITONCE_INITIALIZER;
 139 static icu::UInitOnce gCanonicalZonesInitOnce = U_INITONCE_INITIALIZER;
 140 static icu::UInitOnce gCanonicalLocationZonesInitOnce = U_INITONCE_INITIALIZER;
 141 
 142 U_CDECL_BEGIN
 143 static UBool U_CALLCONV timeZone_cleanup(void)
 144 {
 145     U_NAMESPACE_USE
 146     delete DEFAULT_ZONE;
 147     DEFAULT_ZONE = NULL;
 148     gDefaultZoneInitOnce.reset();
 149 
<span class="line-modified"> 150     if (gStaticZonesInitialized) {</span>
<span class="line-modified"> 151         reinterpret_cast&lt;SimpleTimeZone*&gt;(gRawGMT)-&gt;~SimpleTimeZone();</span>
<span class="line-modified"> 152         reinterpret_cast&lt;SimpleTimeZone*&gt;(gRawUNKNOWN)-&gt;~SimpleTimeZone();</span>
<span class="line-modified"> 153         gStaticZonesInitialized = FALSE;</span>
<span class="line-modified"> 154         gStaticZonesInitOnce.reset();</span>
<span class="line-added"> 155     }</span>
 156 
 157     uprv_memset(TZDATA_VERSION, 0, sizeof(TZDATA_VERSION));
 158     gTZDataVersionInitOnce.reset();
 159 
 160     LEN_SYSTEM_ZONES = 0;
 161     uprv_free(MAP_SYSTEM_ZONES);
 162     MAP_SYSTEM_ZONES = 0;
 163     gSystemZonesInitOnce.reset();
 164 
 165     LEN_CANONICAL_SYSTEM_ZONES = 0;
 166     uprv_free(MAP_CANONICAL_SYSTEM_ZONES);
 167     MAP_CANONICAL_SYSTEM_ZONES = 0;
 168     gCanonicalZonesInitOnce.reset();
 169 
 170     LEN_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
 171     uprv_free(MAP_CANONICAL_SYSTEM_LOCATION_ZONES);
 172     MAP_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
 173     gCanonicalLocationZonesInitOnce.reset();
 174 
 175     return TRUE;
</pre>
<hr />
<pre>
 261     U_DEBUG_TZ_MSG((&quot;loadRule(%s)\n&quot;, key));
 262     UResourceBundle *r = ures_getByKey(top, kRULES, oldbundle, &amp;status);
 263     U_DEBUG_TZ_MSG((&quot;loadRule(%s) -&gt; kRULES [%s]\n&quot;, key, u_errorName(status)));
 264     r = ures_getByKey(r, key, r, &amp;status);
 265     U_DEBUG_TZ_MSG((&quot;loadRule(%s) -&gt; item [%s]\n&quot;, key, u_errorName(status)));
 266     return r;
 267 }
 268 
 269 /**
 270  * Given an ID, open the appropriate resource for the given time zone.
 271  * Dereference aliases if necessary.
 272  * @param id zone id
 273  * @param res resource, which must be ready for use (initialized but not open)
 274  * @param ec input-output error code
 275  * @return top-level resource bundle
 276  */
 277 static UResourceBundle* openOlsonResource(const UnicodeString&amp; id,
 278                                           UResourceBundle&amp; res,
 279                                           UErrorCode&amp; ec)
 280 {
<span class="line-modified"> 281 #ifdef U_DEBUG_TZ</span>
 282     char buf[128];
 283     id.extract(0, sizeof(buf)-1, buf, sizeof(buf), &quot;&quot;);
 284 #endif
 285     UResourceBundle *top = ures_openDirect(0, kZONEINFO, &amp;ec);
 286     U_DEBUG_TZ_MSG((&quot;pre: res sz=%d\n&quot;, ures_getSize(&amp;res)));
 287     /* &amp;res = */ getZoneByName(top, id, &amp;res, ec);
 288     // Dereference if this is an alias.  Docs say result should be 1
 289     // but it is 0 in 2.8 (?).
 290     U_DEBUG_TZ_MSG((&quot;Loading zone &#39;%s&#39; (%s, size %d) - %s\n&quot;, buf, ures_getKey((UResourceBundle*)&amp;res), ures_getSize(&amp;res), u_errorName(ec)));
 291     if (ures_getType(&amp;res) == URES_INT) {
 292         int32_t deref = ures_getInt(&amp;res, &amp;ec) + 0;
 293         U_DEBUG_TZ_MSG((&quot;getInt: %s - type is %d\n&quot;, u_errorName(ec), ures_getType(&amp;res)));
 294         UResourceBundle *ares = ures_getByKey(top, kZONES, NULL, &amp;ec); // dereference Zones section
 295         ures_getByIndex(ares, deref, &amp;res, &amp;ec);
 296         ures_close(ares);
 297         U_DEBUG_TZ_MSG((&quot;alias to #%d (%s) - %s\n&quot;, deref, &quot;??&quot;, u_errorName(ec)));
 298     } else {
 299         U_DEBUG_TZ_MSG((&quot;not an alias - size %d\n&quot;, ures_getSize(&amp;res)));
 300     }
 301     U_DEBUG_TZ_MSG((&quot;%s - final status is %s\n&quot;, buf, u_errorName(ec)));
 302     return top;
 303 }
 304 
 305 // -------------------------------------
 306 
 307 namespace {
 308 
 309 void U_CALLCONV initStaticTimeZones() {
 310     // Initialize _GMT independently of other static data; it should
 311     // be valid even if we can&#39;t load the time zone UDataMemory.
 312     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
<span class="line-modified"> 313 </span>
<span class="line-modified"> 314     // new can&#39;t fail below, as we use placement new into staticly allocated space.</span>
<span class="line-added"> 315     new(gRawGMT) SimpleTimeZone(0, UnicodeString(TRUE, GMT_ID, GMT_ID_LENGTH));</span>
<span class="line-added"> 316     new(gRawUNKNOWN) SimpleTimeZone(0, UnicodeString(TRUE, UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH));</span>
<span class="line-added"> 317 </span>
<span class="line-added"> 318     gStaticZonesInitialized = TRUE;</span>
 319 }
 320 
 321 }  // anonymous namespace
 322 
 323 const TimeZone&amp; U_EXPORT2
 324 TimeZone::getUnknown()
 325 {
 326     umtx_initOnce(gStaticZonesInitOnce, &amp;initStaticTimeZones);
<span class="line-modified"> 327     return *reinterpret_cast&lt;SimpleTimeZone*&gt;(gRawUNKNOWN);</span>
 328 }
 329 
 330 const TimeZone* U_EXPORT2
 331 TimeZone::getGMT(void)
 332 {
 333     umtx_initOnce(gStaticZonesInitOnce, &amp;initStaticTimeZones);
<span class="line-modified"> 334     return reinterpret_cast&lt;SimpleTimeZone*&gt;(gRawGMT);</span>
 335 }
 336 
 337 // *****************************************************************************
 338 // class TimeZone
 339 // *****************************************************************************
 340 
 341 UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(TimeZone)
 342 
 343 TimeZone::TimeZone()
 344     :   UObject(), fID()
 345 {
 346 }
 347 
 348 // -------------------------------------
 349 
 350 TimeZone::TimeZone(const UnicodeString &amp;id)
 351     :   UObject(), fID(id)
 352 {
 353 }
 354 
</pre>
<hr />
<pre>
 375 }
 376 
 377 // -------------------------------------
 378 
 379 UBool
 380 TimeZone::operator==(const TimeZone&amp; that) const
 381 {
 382     return typeid(*this) == typeid(that) &amp;&amp;
 383         fID == that.fID;
 384 }
 385 
 386 // -------------------------------------
 387 
 388 namespace {
 389 TimeZone*
 390 createSystemTimeZone(const UnicodeString&amp; id, UErrorCode&amp; ec) {
 391     if (U_FAILURE(ec)) {
 392         return NULL;
 393     }
 394     TimeZone* z = 0;
<span class="line-modified"> 395     StackUResourceBundle res;</span>

 396     U_DEBUG_TZ_MSG((&quot;pre-err=%s\n&quot;, u_errorName(ec)));
<span class="line-modified"> 397     UResourceBundle *top = openOlsonResource(id, res.ref(), ec);</span>
 398     U_DEBUG_TZ_MSG((&quot;post-err=%s\n&quot;, u_errorName(ec)));
 399     if (U_SUCCESS(ec)) {
<span class="line-modified"> 400         z = new OlsonTimeZone(top, res.getAlias(), id, ec);</span>
 401         if (z == NULL) {
<span class="line-modified"> 402             ec = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 403             U_DEBUG_TZ_MSG((&quot;cstz: olson time zone failed to initialize - err %s\n&quot;, u_errorName(ec)));</span>
 404         }
 405     }

 406     ures_close(top);
 407     if (U_FAILURE(ec)) {
 408         U_DEBUG_TZ_MSG((&quot;cstz: failed to create, err %s\n&quot;, u_errorName(ec)));
 409         delete z;
<span class="line-modified"> 410         z = NULL;</span>
 411     }
 412     return z;
 413 }
 414 
 415 /**
 416  * Lookup the given name in our system zone table.  If found,
 417  * instantiate a new zone of that name and return it.  If not
 418  * found, return 0.
 419  */
 420 TimeZone*
 421 createSystemTimeZone(const UnicodeString&amp; id) {
 422     UErrorCode ec = U_ZERO_ERROR;
 423     return createSystemTimeZone(id, ec);
 424 }
 425 
 426 }
 427 
 428 TimeZone* U_EXPORT2
 429 TimeZone::createTimeZone(const UnicodeString&amp; ID)
 430 {
 431     /* We first try to lookup the zone ID in our system list.  If this
 432      * fails, we try to parse it as a custom string GMT[+-]hh:mm.  If
 433      * all else fails, we return GMT, which is probably not what the
 434      * user wants, but at least is a functioning TimeZone object.
 435      *
 436      * We cannot return NULL, because that would break compatibility
 437      * with the JDK.
 438      */
 439     TimeZone* result = createSystemTimeZone(ID);
 440 
 441     if (result == NULL) {
 442         U_DEBUG_TZ_MSG((&quot;failed to load system time zone with id - falling to custom&quot;));
 443         result = createCustomTimeZone(ID);
 444     }
 445     if (result == NULL) {
 446         U_DEBUG_TZ_MSG((&quot;failed to load time zone with id - falling to Etc/Unknown(GMT)&quot;));
 447         const TimeZone&amp; unknown = getUnknown();
<span class="line-modified"> 448         // Unknown zone uses staticly allocated memory, so creation of it can never fail due to OOM.</span>
<span class="line-modified"> 449         result = unknown.clone();</span>



 450     }
 451     return result;
 452 }
 453 
 454 // -------------------------------------
 455 
 456 TimeZone* U_EXPORT2
 457 TimeZone::detectHostTimeZone()
 458 {
<span class="line-modified"> 459     // We access system timezone data through uprv_tzset(), uprv_tzname(), and others,</span>
<span class="line-modified"> 460     // which have platform specific implementations in putil.cpp</span>
 461     int32_t rawOffset = 0;
 462     const char *hostID;
<span class="line-added"> 463     UBool hostDetectionSucceeded = TRUE;</span>
 464 
 465     // First, try to create a system timezone, based
 466     // on the string ID in tzname[0].
 467 
 468     uprv_tzset(); // Initialize tz... system data
 469 
 470     uprv_tzname_clear_cache();
 471 
 472     // Get the timezone ID from the host.  This function should do
 473     // any required host-specific remapping; e.g., on Windows this
<span class="line-modified"> 474     // function maps the Windows Time Zone name to an ICU timezone ID.</span>

 475     hostID = uprv_tzname(0);
 476 
 477     // Invert sign because UNIX semantics are backwards
 478     rawOffset = uprv_timezone() * -U_MILLIS_PER_SECOND;
 479 
 480     TimeZone* hostZone = NULL;
 481 

 482     UnicodeString hostStrID(hostID, -1, US_INV);
<span class="line-modified"> 483 </span>
<span class="line-modified"> 484     if (hostStrID.length() == 0) {</span>
<span class="line-added"> 485         // The host time zone detection (or remapping) above has failed and</span>
<span class="line-added"> 486         // we have no name at all. Fallback to using the Unknown zone.</span>
<span class="line-added"> 487         hostStrID = UnicodeString(TRUE, UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH);</span>
<span class="line-added"> 488         hostDetectionSucceeded = FALSE;</span>
<span class="line-added"> 489     }</span>
<span class="line-added"> 490 </span>
 491     hostZone = createSystemTimeZone(hostStrID);
 492 
 493 #if U_PLATFORM_USES_ONLY_WIN32_API
 494     // hostID points to a heap-allocated location on Windows.
 495     uprv_free(const_cast&lt;char *&gt;(hostID));
 496 #endif
 497 
 498     int32_t hostIDLen = hostStrID.length();
 499     if (hostZone != NULL &amp;&amp; rawOffset != hostZone-&gt;getRawOffset()
 500         &amp;&amp; (3 &lt;= hostIDLen &amp;&amp; hostIDLen &lt;= 4))
 501     {
 502         // Uh oh. This probably wasn&#39;t a good id.
 503         // It was probably an ambiguous abbreviation
 504         delete hostZone;
 505         hostZone = NULL;
 506     }
 507 
 508     // Construct a fixed standard zone with the host&#39;s ID
 509     // and raw offset.
<span class="line-modified"> 510     if (hostZone == NULL &amp;&amp; hostDetectionSucceeded) {</span>
 511         hostZone = new SimpleTimeZone(rawOffset, hostStrID);
 512     }
 513 
<span class="line-modified"> 514     // If we _still_ don&#39;t have a time zone, use the Unknown zone.</span>
 515     //
 516     // Note: This is extremely unlikely situation. If
 517     // new SimpleTimeZone(...) above fails, the following
 518     // code may also fail.
 519     if (hostZone == NULL) {
<span class="line-modified"> 520         // Unknown zone uses static allocated memory, so it must always exist.</span>
<span class="line-modified"> 521         // However, clone() allocates memory and can fail.</span>
<span class="line-modified"> 522         hostZone = TimeZone::getUnknown().clone();</span>



 523     }
 524 
 525     return hostZone;
 526 }
 527 
 528 // -------------------------------------
 529 
 530 /**
 531  * Initialize DEFAULT_ZONE from the system default time zone.
 532  * Upon return, DEFAULT_ZONE will not be NULL, unless operator new()
 533  * returns NULL.
 534  */
 535 static void U_CALLCONV initDefault()
 536 {
 537     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
 538 
 539     // If setDefault() has already been called we can skip getting the
 540     // default zone information from the system.
 541     if (DEFAULT_ZONE != NULL) {
 542         return;
</pre>
<hr />
<pre>
 977 }
 978 
 979 StringEnumeration* U_EXPORT2
 980 TimeZone::createEnumeration(int32_t rawOffset) {
 981     UErrorCode ec = U_ZERO_ERROR;
 982     return TZEnumeration::create(UCAL_ZONE_TYPE_ANY, NULL, &amp;rawOffset, ec);
 983 }
 984 
 985 StringEnumeration* U_EXPORT2
 986 TimeZone::createEnumeration(const char* country) {
 987     UErrorCode ec = U_ZERO_ERROR;
 988     return TZEnumeration::create(UCAL_ZONE_TYPE_ANY, country, NULL, ec);
 989 }
 990 
 991 // ---------------------------------------
 992 
 993 int32_t U_EXPORT2
 994 TimeZone::countEquivalentIDs(const UnicodeString&amp; id) {
 995     int32_t result = 0;
 996     UErrorCode ec = U_ZERO_ERROR;
<span class="line-modified"> 997     StackUResourceBundle res;</span>

 998     U_DEBUG_TZ_MSG((&quot;countEquivalentIDs..\n&quot;));
<span class="line-modified"> 999     UResourceBundle *top = openOlsonResource(id, res.ref(), ec);</span>
1000     if (U_SUCCESS(ec)) {
<span class="line-modified">1001         StackUResourceBundle r;</span>
<span class="line-modified">1002         ures_getByKey(res.getAlias(), kLINKS, r.getAlias(), &amp;ec);</span>
<span class="line-modified">1003         ures_getIntVector(r.getAlias(), &amp;result, &amp;ec);</span>


1004     }

1005     ures_close(top);
1006     return result;
1007 }
1008 
1009 // ---------------------------------------
1010 
1011 const UnicodeString U_EXPORT2
1012 TimeZone::getEquivalentID(const UnicodeString&amp; id, int32_t index) {
1013     U_DEBUG_TZ_MSG((&quot;gEI(%d)\n&quot;, index));
1014     UnicodeString result;
1015     UErrorCode ec = U_ZERO_ERROR;
<span class="line-modified">1016     StackUResourceBundle res;</span>
<span class="line-modified">1017     UResourceBundle *top = openOlsonResource(id, res.ref(), ec);</span>

1018     int32_t zone = -1;
1019     if (U_SUCCESS(ec)) {
<span class="line-modified">1020         StackUResourceBundle r;</span>

1021         int32_t size;
<span class="line-modified">1022         ures_getByKey(res.getAlias(), kLINKS, r.getAlias(), &amp;ec);</span>
<span class="line-modified">1023         const int32_t *v = ures_getIntVector(r.getAlias(), &amp;size, &amp;ec);</span>
1024         if (U_SUCCESS(ec)) {
1025             if (index &gt;= 0 &amp;&amp; index &lt; size) {
1026                 zone = v[index];
1027             }
1028         }

1029     }

1030     if (zone &gt;= 0) {
1031         UResourceBundle *ares = ures_getByKey(top, kNAMES, NULL, &amp;ec); // dereference Zones section
1032         if (U_SUCCESS(ec)) {
1033             int32_t idLen = 0;
<span class="line-modified">1034             const UChar* id2 = ures_getStringByIndex(ares, zone, &amp;idLen, &amp;ec);</span>
<span class="line-modified">1035             result.fastCopyFrom(UnicodeString(TRUE, id2, idLen));</span>
1036             U_DEBUG_TZ_MSG((&quot;gei(%d) -&gt; %d, len%d, %s\n&quot;, index, zone, result.length(), u_errorName(ec)));
1037         }
1038         ures_close(ares);
1039     }
1040     ures_close(top);
1041 #if defined(U_DEBUG_TZ)
1042     if(result.length() ==0) {
1043       U_DEBUG_TZ_MSG((&quot;equiv [__, #%d] -&gt; 0 (%s)\n&quot;, index, u_errorName(ec)));
1044     }
1045 #endif
1046     return result;
1047 }
1048 
1049 // ---------------------------------------
1050 
1051 // These methods are used by ZoneMeta class only.
1052 
1053 const UChar*
1054 TimeZone::findID(const UnicodeString&amp; id) {
1055     const UChar *result = NULL;
</pre>
<hr />
<pre>
1164 
1165     return u_terminateChars(region, capacity, resultLen, &amp;status);
1166 }
1167 
1168 // ---------------------------------------
1169 
1170 
1171 UnicodeString&amp;
1172 TimeZone::getDisplayName(UnicodeString&amp; result) const
1173 {
1174     return getDisplayName(FALSE,LONG,Locale::getDefault(), result);
1175 }
1176 
1177 UnicodeString&amp;
1178 TimeZone::getDisplayName(const Locale&amp; locale, UnicodeString&amp; result) const
1179 {
1180     return getDisplayName(FALSE, LONG, locale, result);
1181 }
1182 
1183 UnicodeString&amp;
<span class="line-modified">1184 TimeZone::getDisplayName(UBool inDaylight, EDisplayType style, UnicodeString&amp; result)  const</span>
1185 {
<span class="line-modified">1186     return getDisplayName(inDaylight,style, Locale::getDefault(), result);</span>
1187 }
1188 //--------------------------------------
1189 int32_t
1190 TimeZone::getDSTSavings()const {
1191     if (useDaylightTime()) {
1192         return 3600000;
1193     }
1194     return 0;
1195 }
1196 //---------------------------------------
1197 UnicodeString&amp;
<span class="line-modified">1198 TimeZone::getDisplayName(UBool inDaylight, EDisplayType style, const Locale&amp; locale, UnicodeString&amp; result) const</span>
1199 {
1200     UErrorCode status = U_ZERO_ERROR;
1201     UDate date = Calendar::getNow();
<span class="line-modified">1202     UTimeZoneFormatTimeType timeType = UTZFMT_TIME_TYPE_UNKNOWN;</span>
1203     int32_t offset;
1204 
1205     if (style == GENERIC_LOCATION || style == LONG_GENERIC || style == SHORT_GENERIC) {
1206         LocalPointer&lt;TimeZoneFormat&gt; tzfmt(TimeZoneFormat::createInstance(locale, status));
1207         if (U_FAILURE(status)) {
1208             result.remove();
1209             return result;
1210         }
1211         // Generic format
1212         switch (style) {
1213         case GENERIC_LOCATION:
1214             tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_LOCATION, *this, date, result, &amp;timeType);
1215             break;
1216         case LONG_GENERIC:
1217             tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_LONG, *this, date, result, &amp;timeType);
1218             break;
1219         case SHORT_GENERIC:
1220             tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_SHORT, *this, date, result, &amp;timeType);
1221             break;
1222         default:
<span class="line-modified">1223             UPRV_UNREACHABLE;</span>
1224         }
1225         // Generic format many use Localized GMT as the final fallback.
1226         // When Localized GMT format is used, the result might not be
1227         // appropriate for the requested daylight value.
<span class="line-modified">1228         if ((inDaylight &amp;&amp; timeType == UTZFMT_TIME_TYPE_STANDARD) || (!inDaylight &amp;&amp; timeType == UTZFMT_TIME_TYPE_DAYLIGHT)) {</span>
<span class="line-modified">1229             offset = inDaylight ? getRawOffset() + getDSTSavings() : getRawOffset();</span>
1230             if (style == SHORT_GENERIC) {
1231                 tzfmt-&gt;formatOffsetShortLocalizedGMT(offset, result, status);
1232             } else {
1233                 tzfmt-&gt;formatOffsetLocalizedGMT(offset, result, status);
1234             }
1235         }
1236     } else if (style == LONG_GMT || style == SHORT_GMT) {
1237         LocalPointer&lt;TimeZoneFormat&gt; tzfmt(TimeZoneFormat::createInstance(locale, status));
1238         if (U_FAILURE(status)) {
1239             result.remove();
1240             return result;
1241         }
<span class="line-modified">1242         offset = inDaylight &amp;&amp; useDaylightTime() ? getRawOffset() + getDSTSavings() : getRawOffset();</span>
1243         switch (style) {
1244         case LONG_GMT:
1245             tzfmt-&gt;formatOffsetLocalizedGMT(offset, result, status);
1246             break;
1247         case SHORT_GMT:
1248             tzfmt-&gt;formatOffsetISO8601Basic(offset, FALSE, FALSE, FALSE, result, status);
1249             break;
1250         default:
<span class="line-modified">1251             UPRV_UNREACHABLE;</span>
1252         }
1253 
1254     } else {
1255         U_ASSERT(style == LONG || style == SHORT || style == SHORT_COMMONLY_USED);
1256         UTimeZoneNameType nameType = UTZNM_UNKNOWN;
1257         switch (style) {
1258         case LONG:
<span class="line-modified">1259             nameType = inDaylight ? UTZNM_LONG_DAYLIGHT : UTZNM_LONG_STANDARD;</span>
1260             break;
1261         case SHORT:
1262         case SHORT_COMMONLY_USED:
<span class="line-modified">1263             nameType = inDaylight ? UTZNM_SHORT_DAYLIGHT : UTZNM_SHORT_STANDARD;</span>
1264             break;
1265         default:
<span class="line-modified">1266             UPRV_UNREACHABLE;</span>
1267         }
1268         LocalPointer&lt;TimeZoneNames&gt; tznames(TimeZoneNames::createInstance(locale, status));
1269         if (U_FAILURE(status)) {
1270             result.remove();
1271             return result;
1272         }
1273         UnicodeString canonicalID(ZoneMeta::getCanonicalCLDRID(*this));
1274         tznames-&gt;getDisplayName(canonicalID, nameType, date, result);
1275         if (result.isEmpty()) {
1276             // Fallback to localized GMT
1277             LocalPointer&lt;TimeZoneFormat&gt; tzfmt(TimeZoneFormat::createInstance(locale, status));
<span class="line-modified">1278             offset = inDaylight &amp;&amp; useDaylightTime() ? getRawOffset() + getDSTSavings() : getRawOffset();</span>
1279             if (style == LONG) {
1280                 tzfmt-&gt;formatOffsetLocalizedGMT(offset, result, status);
1281             } else {
1282                 tzfmt-&gt;formatOffsetShortLocalizedGMT(offset, result, status);
1283             }
1284         }
1285     }
1286     if (U_FAILURE(status)) {
1287         result.remove();
1288     }
1289     return  result;
1290 }
1291 
1292 /**
1293  * Parse a custom time zone identifier and return a corresponding zone.
1294  * @param id a string of the form GMT[+-]hh:mm, GMT[+-]hhmm, or
1295  * GMT[+-]hh.
1296  * @return a newly created SimpleTimeZone with the given offset and
1297  * no Daylight Savings Time, or null if the id cannot be parsed.
1298 */
</pre>
<hr />
<pre>
1479             } else {
1480                 id += (UChar)(ZERO_DIGIT + sec/10);
1481             }
1482             id += (UChar)(ZERO_DIGIT + sec%10);
1483         }
1484     }
1485     return id;
1486 }
1487 
1488 
1489 UBool
1490 TimeZone::hasSameRules(const TimeZone&amp; other) const
1491 {
1492     return (getRawOffset() == other.getRawOffset() &amp;&amp;
1493             useDaylightTime() == other.useDaylightTime());
1494 }
1495 
1496 static void U_CALLCONV initTZDataVersion(UErrorCode &amp;status) {
1497     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
1498     int32_t len = 0;
<span class="line-modified">1499     StackUResourceBundle bundle;</span>
<span class="line-modified">1500     ures_openDirectFillIn(bundle.getAlias(), NULL, kZONEINFO, &amp;status);</span>
<span class="line-added">1501     const UChar *tzver = ures_getStringByKey(bundle.getAlias(), kTZVERSION, &amp;len, &amp;status);</span>
1502 
1503     if (U_SUCCESS(status)) {
1504         if (len &gt;= (int32_t)sizeof(TZDATA_VERSION)) {
1505             // Ensure that there is always space for a trailing nul in TZDATA_VERSION
1506             len = sizeof(TZDATA_VERSION) - 1;
1507         }
1508         u_UCharsToChars(tzver, TZDATA_VERSION, len);
1509     }


1510 }
1511 
1512 const char*
1513 TimeZone::getTZDataVersion(UErrorCode&amp; status)
1514 {
1515     umtx_initOnce(gTZDataVersionInitOnce, &amp;initTZDataVersion, status);
1516     return (const char*)TZDATA_VERSION;
1517 }
1518 
1519 UnicodeString&amp;
1520 TimeZone::getCanonicalID(const UnicodeString&amp; id, UnicodeString&amp; canonicalID, UErrorCode&amp; status)
1521 {
1522     UBool isSystemID = FALSE;
1523     return getCanonicalID(id, canonicalID, isSystemID, status);
1524 }
1525 
1526 UnicodeString&amp;
1527 TimeZone::getCanonicalID(const UnicodeString&amp; id, UnicodeString&amp; canonicalID, UBool&amp; isSystemID,
1528                          UErrorCode&amp; status)
1529 {
</pre>
<hr />
<pre>
1594             if (U_FAILURE(status)) {
1595                 break;
1596             }
1597             if (ures_getType(regionalData) != URES_STRING) {
1598                 continue;
1599             }
1600             int32_t len;
1601             const UChar *tzids = ures_getString(regionalData, &amp;len, &amp;status);
1602             if (U_FAILURE(status)) {
1603                 break;
1604             }
1605 
1606             const UChar *start = tzids;
1607             UBool hasNext = TRUE;
1608             while (hasNext) {
1609                 const UChar *end = u_strchr(start, (UChar)0x20);
1610                 if (end == NULL) {
1611                     end = tzids + len;
1612                     hasNext = FALSE;
1613                 }
<span class="line-modified">1614                 if (canonicalID.compare(start, static_cast&lt;int32_t&gt;(end - start)) == 0) {</span>
1615                     winid = UnicodeString(ures_getKey(winzone), -1 , US_INV);
1616                     found = TRUE;
1617                     break;
1618                 }
1619                 start = end + 1;
1620             }
1621         }
1622         ures_close(regionalData);
1623     }
1624     ures_close(winzone);
1625     ures_close(mapTimezones);
1626 
1627     return winid;
1628 }
1629 
1630 #define MAX_WINDOWS_ID_SIZE 128
1631 
1632 UnicodeString&amp;
1633 TimeZone::getIDForWindowsID(const UnicodeString&amp; winid, const char* region, UnicodeString&amp; id, UErrorCode&amp; status) {
1634     id.remove();
</pre>
<hr />
<pre>
1655 
1656     ures_getByKey(zones, winidKey, zones, &amp;tmperr); // use tmperr, because windows mapping might not
1657                                                     // be avaiable by design
1658     if (U_FAILURE(tmperr)) {
1659         ures_close(zones);
1660         return id;
1661     }
1662 
1663     const UChar *tzid = NULL;
1664     int32_t len = 0;
1665     UBool gotID = FALSE;
1666     if (region) {
1667         const UChar *tzids = ures_getStringByKey(zones, region, &amp;len, &amp;tmperr); // use tmperr, because
1668                                                                                 // regional mapping is optional
1669         if (U_SUCCESS(tmperr)) {
1670             // first ID delimited by space is the defasult one
1671             const UChar *end = u_strchr(tzids, (UChar)0x20);
1672             if (end == NULL) {
1673                 id.setTo(tzids, -1);
1674             } else {
<span class="line-modified">1675                 id.setTo(tzids, static_cast&lt;int32_t&gt;(end - tzids));</span>
1676             }
1677             gotID = TRUE;
1678         }
1679     }
1680 
1681     if (!gotID) {
1682         tzid = ures_getStringByKey(zones, &quot;001&quot;, &amp;len, &amp;status);    // using status, because &quot;001&quot; must be
1683                                                                 // available at this point
1684         if (U_SUCCESS(status)) {
1685             id.setTo(tzid, len);
1686         }
1687     }
1688 
1689     ures_close(zones);
1690     return id;
1691 }
1692 
1693 
1694 U_NAMESPACE_END
1695 
</pre>
</td>
</tr>
</table>
<center><a href="smpdtfmt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="tmunit.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>