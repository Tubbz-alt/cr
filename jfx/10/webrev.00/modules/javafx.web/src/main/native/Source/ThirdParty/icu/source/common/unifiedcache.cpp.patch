diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unifiedcache.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unifiedcache.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unifiedcache.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unifiedcache.cpp
@@ -19,12 +19,18 @@
 #include "uhash.h"
 #include "ucln_cmn.h"
 #include "umutex.h"
 
 static icu::UnifiedCache *gCache = NULL;
-static UMutex gCacheMutex = U_MUTEX_INITIALIZER;
-static UConditionVar gInProgressValueAddedCond = U_CONDITION_INITIALIZER;
+static icu::UMutex *gCacheMutex() {
+    static icu::UMutex m = U_MUTEX_INITIALIZER;
+    return &m;
+}
+static icu::UConditionVar *gInProgressValueAddedCond() {
+    static icu::UConditionVar cv = U_CONDITION_INITIALIZER;
+    return &cv;
+}
 static icu::UInitOnce gCacheInitOnce = U_INITONCE_INITIALIZER;
 
 static const int32_t MAX_EVICT_ITERATIONS = 10;
 static const int32_t DEFAULT_MAX_UNUSED = 1000;
 static const int32_t DEFAULT_PERCENTAGE_OF_IN_USE = 100;
@@ -130,41 +136,41 @@
     }
     if (count < 0 || percentageOfInUseItems < 0) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
         return;
     }
-    Mutex lock(&gCacheMutex);
+    Mutex lock(gCacheMutex());
     fMaxUnused = count;
     fMaxPercentageOfInUse = percentageOfInUseItems;
 }
 
 int32_t UnifiedCache::unusedCount() const {
-    Mutex lock(&gCacheMutex);
+    Mutex lock(gCacheMutex());
     return uhash_count(fHashtable) - fNumValuesInUse;
 }
 
 int64_t UnifiedCache::autoEvictedCount() const {
-    Mutex lock(&gCacheMutex);
+    Mutex lock(gCacheMutex());
     return fAutoEvictedCount;
 }
 
 int32_t UnifiedCache::keyCount() const {
-    Mutex lock(&gCacheMutex);
+    Mutex lock(gCacheMutex());
     return uhash_count(fHashtable);
 }
 
 void UnifiedCache::flush() const {
-    Mutex lock(&gCacheMutex);
+    Mutex lock(gCacheMutex());
 
     // Use a loop in case cache items that are flushed held hard references to
     // other cache items making those additional cache items eligible for
     // flushing.
     while (_flush(FALSE));
 }
 
 void UnifiedCache::handleUnreferencedObject() const {
-    Mutex lock(&gCacheMutex);
+    Mutex lock(gCacheMutex());
     --fNumValuesInUse;
     _runEvictionSlice();
 }
 
 #ifdef UNIFIED_CACHE_DEBUG
@@ -179,11 +185,11 @@
     }
     cache->dumpContents();
 }
 
 void UnifiedCache::dumpContents() const {
-    Mutex lock(&gCacheMutex);
+    Mutex lock(gCacheMutex());
     _dumpContents();
 }
 
 // Dumps content of cache.
 // On entry, gCacheMutex must be held.
@@ -219,11 +225,11 @@
     flush();
     {
         // Now all that should be left in the cache are entries that refer to
         // each other and entries with hard references from outside the cache.
         // Nothing we can do about these so proceed to wipe out the cache.
-        Mutex lock(&gCacheMutex);
+        Mutex lock(gCacheMutex());
         _flush(TRUE);
     }
     uhash_close(fHashtable);
     fHashtable = nullptr;
     delete fNoValue;
@@ -249,11 +255,11 @@
             break;
         }
         if (all || _isEvictable(element)) {
             const SharedObject *sharedObject =
                     (const SharedObject *) element->value.pointer;
-            U_ASSERT(sharedObject->cachePtr = this);
+            U_ASSERT(sharedObject->cachePtr == this);
             uhash_removeElement(fHashtable, element);
             removeSoftRef(sharedObject);    // Deletes the sharedObject when softRefCount goes to zero.
             result = TRUE;
         }
     }
@@ -320,11 +326,11 @@
 
 void UnifiedCache::_putIfAbsentAndGet(
         const CacheKeyBase &key,
         const SharedObject *&value,
         UErrorCode &status) const {
-    Mutex lock(&gCacheMutex);
+    Mutex lock(gCacheMutex());
     const UHashElement *element = uhash_find(fHashtable, &key);
     if (element != NULL && !_inProgress(element)) {
         _fetch(element, value, status);
         return;
     }
@@ -345,18 +351,18 @@
         const CacheKeyBase &key,
         const SharedObject *&value,
         UErrorCode &status) const {
     U_ASSERT(value == NULL);
     U_ASSERT(status == U_ZERO_ERROR);
-    Mutex lock(&gCacheMutex);
+    Mutex lock(gCacheMutex());
     const UHashElement *element = uhash_find(fHashtable, &key);
 
     // If the hash table contains an inProgress placeholder entry for this key,
     // this means that another thread is currently constructing the value object.
     // Loop, waiting for that construction to complete.
      while (element != NULL && _inProgress(element)) {
-        umtx_condWait(&gInProgressValueAddedCond, &gCacheMutex);
+        umtx_condWait(gInProgressValueAddedCond(), gCacheMutex());
         element = uhash_find(fHashtable, &key);
     }
 
     // If the hash table contains an entry for the key,
     // fetch out the contents and return them.
@@ -425,11 +431,11 @@
     U_ASSERT(oldValue == fNoValue);
     removeSoftRef(oldValue);
 
     // Tell waiting threads that we replace in-progress status with
     // an error.
-    umtx_condBroadcast(&gInProgressValueAddedCond);
+    umtx_condBroadcast(gInProgressValueAddedCond());
 }
 
 void UnifiedCache::_fetch(
         const UHashElement *element,
         const SharedObject *&value,
