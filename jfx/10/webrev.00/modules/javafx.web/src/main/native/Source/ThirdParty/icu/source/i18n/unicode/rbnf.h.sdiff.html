<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/rbnf.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="plurrule.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="regex.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/rbnf.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 296  *   &lt;tr&gt;
 297  *     &lt;td&gt;x.0:&lt;/td&gt;
 298  *     &lt;td&gt;The rule is a &lt;em&gt;master rule&lt;/em&gt;. If the full stop in
 299  *     the middle of the rule name is replaced with the decimal point
 300  *     that is used in the language or DecimalFormatSymbols, then that rule will
 301  *     have precedence when formatting and parsing this rule. For example, some
 302  *     languages use the comma, and can thus be written as x,0 instead. For example,
 303  *     you can use &quot;x.0: &amp;lt;&amp;lt; point;x,0: &amp;lt;&amp;lt; comma;&quot; to
 304  *     handle the decimal point that matches the language&#39;s natural spelling of
 305  *     the punctuation of either the full stop or comma.&lt;/td&gt;
 306  *   &lt;/tr&gt;
 307  *   &lt;tr&gt;
 308  *     &lt;td&gt;Inf:&lt;/td&gt;
 309  *     &lt;td&gt;The rule for infinity.&lt;/td&gt;
 310  *   &lt;/tr&gt;
 311  *   &lt;tr&gt;
 312  *     &lt;td&gt;NaN:&lt;/td&gt;
 313  *     &lt;td&gt;The rule for an IEEE 754 NaN (not a number).&lt;/td&gt;
 314  *   &lt;/tr&gt;
 315  *   &lt;tr&gt;
<span class="line-removed"> 316  *   &lt;tr&gt;</span>
 317  *     &lt;td&gt;&lt;em&gt;nothing&lt;/em&gt;&lt;/td&gt;
 318  *     &lt;td&gt;If the rule&#39;s rule descriptor is left out, the base value is one plus the
 319  *     preceding rule&#39;s base value (or zero if this is the first rule in the list) in a normal
 320  *     rule set.&amp;nbsp; In a fraction rule set, the base value is the same as the preceding rule&#39;s
 321  *     base value.&lt;/td&gt;
 322  *   &lt;/tr&gt;
 323  * &lt;/table&gt;
 324  *
 325  * &lt;p&gt;A rule set may be either a regular rule set or a &lt;em&gt;fraction rule set,&lt;/em&gt; depending
 326  * on whether it is used to format a number&#39;s integral part (or the whole number) or a
 327  * number&#39;s fractional part. Using a rule set to format a rule&#39;s fractional part makes it a
 328  * fraction rule set.&lt;/p&gt;
 329  *
 330  * &lt;p&gt;Which rule is used to format a number is defined according to one of the following
 331  * algorithms: If the rule set is a regular rule set, do the following:
 332  *
 333  * &lt;ul&gt;
 334  *   &lt;li&gt;If the rule set includes a master rule (and the number was passed in as a &lt;tt&gt;double&lt;/tt&gt;),
 335  *     use the master rule.&amp;nbsp; (If the number being formatted was passed in as a &lt;tt&gt;long&lt;/tt&gt;,
 336  *     the master rule is ignored.)&lt;/li&gt;
</pre>
<hr />
<pre>
 996    * @return the name of the current default rule set
 997    * @stable ICU 3.0
 998    */
 999   virtual UnicodeString getDefaultRuleSetName() const;
1000 
1001   /**
1002    * Set a particular UDisplayContext value in the formatter, such as
1003    * UDISPCTX_CAPITALIZATION_FOR_STANDALONE. Note: For getContext, see
1004    * NumberFormat.
1005    * @param value The UDisplayContext value to set.
1006    * @param status Input/output status. If at entry this indicates a failure
1007    *               status, the function will do nothing; otherwise this will be
1008    *               updated with any new status from the function.
1009    * @stable ICU 53
1010    */
1011   virtual void setContext(UDisplayContext value, UErrorCode&amp; status);
1012 
1013     /**
1014      * Get the rounding mode.
1015      * @return A rounding mode
<span class="line-modified">1016      * @draft ICU 60</span>
1017      */
1018     virtual ERoundingMode getRoundingMode(void) const;
1019 
1020     /**
1021      * Set the rounding mode.
1022      * @param roundingMode A rounding mode
<span class="line-modified">1023      * @draft ICU 60</span>
1024      */
1025     virtual void setRoundingMode(ERoundingMode roundingMode);
1026 
1027 public:
1028     /**
1029      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for this class.
1030      *
1031      * @stable ICU 2.8
1032      */
1033     static UClassID U_EXPORT2 getStaticClassID(void);
1034 
1035     /**
1036      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for the actual class.
1037      *
1038      * @stable ICU 2.8
1039      */
1040     virtual UClassID getDynamicClassID(void) const;
1041 
1042     /**
1043      * Sets the decimal format symbols, which is generally not changed
</pre>
<hr />
<pre>
1078     /* friend access */
1079     friend class NFSubstitution;
1080     friend class NFRule;
1081     friend class NFRuleSet;
1082     friend class FractionalPartSubstitution;
1083 
1084     inline NFRuleSet * getDefaultRuleSet() const;
1085     const RuleBasedCollator * getCollator() const;
1086     DecimalFormatSymbols * initializeDecimalFormatSymbols(UErrorCode &amp;status);
1087     const DecimalFormatSymbols * getDecimalFormatSymbols() const;
1088     NFRule * initializeDefaultInfinityRule(UErrorCode &amp;status);
1089     const NFRule * getDefaultInfinityRule() const;
1090     NFRule * initializeDefaultNaNRule(UErrorCode &amp;status);
1091     const NFRule * getDefaultNaNRule() const;
1092     PluralFormat *createPluralFormat(UPluralType pluralType, const UnicodeString &amp;pattern, UErrorCode&amp; status) const;
1093     UnicodeString&amp; adjustForCapitalizationContext(int32_t startPos, UnicodeString&amp; currentResult, UErrorCode&amp; status) const;
1094     UnicodeString&amp; format(int64_t number, NFRuleSet *ruleSet, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const;
1095     void format(double number, NFRuleSet&amp; rs, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const;
1096 
1097 private:
<span class="line-modified">1098     NFRuleSet **ruleSets;</span>
1099     UnicodeString* ruleSetDescriptions;
1100     int32_t numRuleSets;
1101     NFRuleSet *defaultRuleSet;
1102     Locale locale;
1103     RuleBasedCollator* collator;
1104     DecimalFormatSymbols* decimalFormatSymbols;
1105     NFRule *defaultInfinityRule;
1106     NFRule *defaultNaNRule;
<span class="line-modified">1107     ERoundingMode roundingMode;</span>
1108     UBool lenient;
1109     UnicodeString* lenientParseRules;
1110     LocalizationInfo* localizations;
1111     UnicodeString originalDescription;
1112     UBool capitalizationInfoSet;
1113     UBool capitalizationForUIListMenu;
1114     UBool capitalizationForStandAlone;
1115     BreakIterator* capitalizationBrkIter;
1116 };
1117 
1118 // ---------------
1119 
1120 #if !UCONFIG_NO_COLLATION
1121 
1122 inline UBool
1123 RuleBasedNumberFormat::isLenient(void) const {
1124     return lenient;
1125 }
1126 
1127 #endif
</pre>
</td>
<td>
<hr />
<pre>
 296  *   &lt;tr&gt;
 297  *     &lt;td&gt;x.0:&lt;/td&gt;
 298  *     &lt;td&gt;The rule is a &lt;em&gt;master rule&lt;/em&gt;. If the full stop in
 299  *     the middle of the rule name is replaced with the decimal point
 300  *     that is used in the language or DecimalFormatSymbols, then that rule will
 301  *     have precedence when formatting and parsing this rule. For example, some
 302  *     languages use the comma, and can thus be written as x,0 instead. For example,
 303  *     you can use &quot;x.0: &amp;lt;&amp;lt; point;x,0: &amp;lt;&amp;lt; comma;&quot; to
 304  *     handle the decimal point that matches the language&#39;s natural spelling of
 305  *     the punctuation of either the full stop or comma.&lt;/td&gt;
 306  *   &lt;/tr&gt;
 307  *   &lt;tr&gt;
 308  *     &lt;td&gt;Inf:&lt;/td&gt;
 309  *     &lt;td&gt;The rule for infinity.&lt;/td&gt;
 310  *   &lt;/tr&gt;
 311  *   &lt;tr&gt;
 312  *     &lt;td&gt;NaN:&lt;/td&gt;
 313  *     &lt;td&gt;The rule for an IEEE 754 NaN (not a number).&lt;/td&gt;
 314  *   &lt;/tr&gt;
 315  *   &lt;tr&gt;

 316  *     &lt;td&gt;&lt;em&gt;nothing&lt;/em&gt;&lt;/td&gt;
 317  *     &lt;td&gt;If the rule&#39;s rule descriptor is left out, the base value is one plus the
 318  *     preceding rule&#39;s base value (or zero if this is the first rule in the list) in a normal
 319  *     rule set.&amp;nbsp; In a fraction rule set, the base value is the same as the preceding rule&#39;s
 320  *     base value.&lt;/td&gt;
 321  *   &lt;/tr&gt;
 322  * &lt;/table&gt;
 323  *
 324  * &lt;p&gt;A rule set may be either a regular rule set or a &lt;em&gt;fraction rule set,&lt;/em&gt; depending
 325  * on whether it is used to format a number&#39;s integral part (or the whole number) or a
 326  * number&#39;s fractional part. Using a rule set to format a rule&#39;s fractional part makes it a
 327  * fraction rule set.&lt;/p&gt;
 328  *
 329  * &lt;p&gt;Which rule is used to format a number is defined according to one of the following
 330  * algorithms: If the rule set is a regular rule set, do the following:
 331  *
 332  * &lt;ul&gt;
 333  *   &lt;li&gt;If the rule set includes a master rule (and the number was passed in as a &lt;tt&gt;double&lt;/tt&gt;),
 334  *     use the master rule.&amp;nbsp; (If the number being formatted was passed in as a &lt;tt&gt;long&lt;/tt&gt;,
 335  *     the master rule is ignored.)&lt;/li&gt;
</pre>
<hr />
<pre>
 995    * @return the name of the current default rule set
 996    * @stable ICU 3.0
 997    */
 998   virtual UnicodeString getDefaultRuleSetName() const;
 999 
1000   /**
1001    * Set a particular UDisplayContext value in the formatter, such as
1002    * UDISPCTX_CAPITALIZATION_FOR_STANDALONE. Note: For getContext, see
1003    * NumberFormat.
1004    * @param value The UDisplayContext value to set.
1005    * @param status Input/output status. If at entry this indicates a failure
1006    *               status, the function will do nothing; otherwise this will be
1007    *               updated with any new status from the function.
1008    * @stable ICU 53
1009    */
1010   virtual void setContext(UDisplayContext value, UErrorCode&amp; status);
1011 
1012     /**
1013      * Get the rounding mode.
1014      * @return A rounding mode
<span class="line-modified">1015      * @stable ICU 60</span>
1016      */
1017     virtual ERoundingMode getRoundingMode(void) const;
1018 
1019     /**
1020      * Set the rounding mode.
1021      * @param roundingMode A rounding mode
<span class="line-modified">1022      * @stable ICU 60</span>
1023      */
1024     virtual void setRoundingMode(ERoundingMode roundingMode);
1025 
1026 public:
1027     /**
1028      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for this class.
1029      *
1030      * @stable ICU 2.8
1031      */
1032     static UClassID U_EXPORT2 getStaticClassID(void);
1033 
1034     /**
1035      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for the actual class.
1036      *
1037      * @stable ICU 2.8
1038      */
1039     virtual UClassID getDynamicClassID(void) const;
1040 
1041     /**
1042      * Sets the decimal format symbols, which is generally not changed
</pre>
<hr />
<pre>
1077     /* friend access */
1078     friend class NFSubstitution;
1079     friend class NFRule;
1080     friend class NFRuleSet;
1081     friend class FractionalPartSubstitution;
1082 
1083     inline NFRuleSet * getDefaultRuleSet() const;
1084     const RuleBasedCollator * getCollator() const;
1085     DecimalFormatSymbols * initializeDecimalFormatSymbols(UErrorCode &amp;status);
1086     const DecimalFormatSymbols * getDecimalFormatSymbols() const;
1087     NFRule * initializeDefaultInfinityRule(UErrorCode &amp;status);
1088     const NFRule * getDefaultInfinityRule() const;
1089     NFRule * initializeDefaultNaNRule(UErrorCode &amp;status);
1090     const NFRule * getDefaultNaNRule() const;
1091     PluralFormat *createPluralFormat(UPluralType pluralType, const UnicodeString &amp;pattern, UErrorCode&amp; status) const;
1092     UnicodeString&amp; adjustForCapitalizationContext(int32_t startPos, UnicodeString&amp; currentResult, UErrorCode&amp; status) const;
1093     UnicodeString&amp; format(int64_t number, NFRuleSet *ruleSet, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const;
1094     void format(double number, NFRuleSet&amp; rs, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const;
1095 
1096 private:
<span class="line-modified">1097     NFRuleSet **fRuleSets;</span>
1098     UnicodeString* ruleSetDescriptions;
1099     int32_t numRuleSets;
1100     NFRuleSet *defaultRuleSet;
1101     Locale locale;
1102     RuleBasedCollator* collator;
1103     DecimalFormatSymbols* decimalFormatSymbols;
1104     NFRule *defaultInfinityRule;
1105     NFRule *defaultNaNRule;
<span class="line-modified">1106     ERoundingMode fRoundingMode;</span>
1107     UBool lenient;
1108     UnicodeString* lenientParseRules;
1109     LocalizationInfo* localizations;
1110     UnicodeString originalDescription;
1111     UBool capitalizationInfoSet;
1112     UBool capitalizationForUIListMenu;
1113     UBool capitalizationForStandAlone;
1114     BreakIterator* capitalizationBrkIter;
1115 };
1116 
1117 // ---------------
1118 
1119 #if !UCONFIG_NO_COLLATION
1120 
1121 inline UBool
1122 RuleBasedNumberFormat::isLenient(void) const {
1123     return lenient;
1124 }
1125 
1126 #endif
</pre>
</td>
</tr>
</table>
<center><a href="plurrule.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="regex.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>