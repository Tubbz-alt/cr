<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/nfrule.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="msgfmt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="nfrule.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/nfrule.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22 #include &quot;unicode/localpointer.h&quot;
  23 #include &quot;unicode/rbnf.h&quot;
  24 #include &quot;unicode/tblcoll.h&quot;
  25 #include &quot;unicode/plurfmt.h&quot;
  26 #include &quot;unicode/upluralrules.h&quot;
  27 #include &quot;unicode/coleitr.h&quot;
  28 #include &quot;unicode/uchar.h&quot;
  29 #include &quot;nfrs.h&quot;
  30 #include &quot;nfrlist.h&quot;
  31 #include &quot;nfsubs.h&quot;
  32 #include &quot;patternprops.h&quot;
  33 #include &quot;putilimp.h&quot;
  34 
  35 U_NAMESPACE_BEGIN
  36 
  37 NFRule::NFRule(const RuleBasedNumberFormat* _rbnf, const UnicodeString &amp;_ruleText, UErrorCode &amp;status)
  38   : baseValue((int32_t)0)
  39   , radix(10)
  40   , exponent(0)
  41   , decimalPoint(0)
<span class="line-modified">  42   , ruleText(_ruleText)</span>
  43   , sub1(NULL)
  44   , sub2(NULL)
  45   , formatter(_rbnf)
  46   , rulePatternFormat(NULL)
  47 {
<span class="line-modified">  48     if (!ruleText.isEmpty()) {</span>
<span class="line-modified">  49         parseRuleDescriptor(ruleText, status);</span>
  50     }
  51 }
  52 
  53 NFRule::~NFRule()
  54 {
  55     if (sub1 != sub2) {
  56         delete sub2;
  57         sub2 = NULL;
  58     }
  59     delete sub1;
  60     sub1 = NULL;
  61     delete rulePatternFormat;
  62     rulePatternFormat = NULL;
  63 }
  64 
  65 static const UChar gLeftBracket = 0x005b;
  66 static const UChar gRightBracket = 0x005d;
  67 static const UChar gColon = 0x003a;
  68 static const UChar gZero = 0x0030;
  69 static const UChar gNine = 0x0039;
</pre>
<hr />
<pre>
 105 };
 106 
 107 void
 108 NFRule::makeRules(UnicodeString&amp; description,
 109                   NFRuleSet *owner,
 110                   const NFRule *predecessor,
 111                   const RuleBasedNumberFormat *rbnf,
 112                   NFRuleList&amp; rules,
 113                   UErrorCode&amp; status)
 114 {
 115     // we know we&#39;re making at least one rule, so go ahead and
 116     // new it up and initialize its basevalue and divisor
 117     // (this also strips the rule descriptor, if any, off the
 118     // descripton string)
 119     NFRule* rule1 = new NFRule(rbnf, description, status);
 120     /* test for NULL */
 121     if (rule1 == 0) {
 122         status = U_MEMORY_ALLOCATION_ERROR;
 123         return;
 124     }
<span class="line-modified"> 125     description = rule1-&gt;ruleText;</span>
 126 
 127     // check the description to see whether there&#39;s text enclosed
 128     // in brackets
 129     int32_t brack1 = description.indexOf(gLeftBracket);
 130     int32_t brack2 = brack1 &lt; 0 ? -1 : description.indexOf(gRightBracket);
 131 
 132     // if the description doesn&#39;t contain a matched pair of brackets,
 133     // or if it&#39;s of a type that doesn&#39;t recognize bracketed text,
 134     // then leave the description alone, initialize the rule&#39;s
 135     // rule text and substitutions, and return that rule
 136     if (brack2 &lt; 0 || brack1 &gt; brack2
 137         || rule1-&gt;getType() == kProperFractionRule
 138         || rule1-&gt;getType() == kNegativeNumberRule
 139         || rule1-&gt;getType() == kInfinityRule
 140         || rule1-&gt;getType() == kNaNRule)
 141     {
 142         rule1-&gt;extractSubstitutions(owner, description, predecessor, status);
 143     }
 144     else {
 145         // if the description does contain a matched pair of brackets,
</pre>
<hr />
<pre>
 297                 else if (PatternProps::isWhiteSpace(c) || c == gComma || c == gDot) {
 298                 }
 299                 else {
 300                     // throw new IllegalArgumentException(&quot;Illegal character in rule descriptor&quot;);
 301                     status = U_PARSE_ERROR;
 302                     return;
 303                 }
 304                 ++p;
 305             }
 306 
 307             // we have the base value, so set it
 308             setBaseValue(val, status);
 309 
 310             // if we stopped the previous loop on a slash, we&#39;re
 311             // now parsing the rule&#39;s radix.  Again, accumulate digits
 312             // in tempValue, skip punctuation, stop on a &gt; mark, and
 313             // throw an exception on anything else
 314             if (c == gSlash) {
 315                 val = 0;
 316                 ++p;
<span class="line-modified"> 317                 int64_t ll_10 = 10;</span>
 318                 while (p &lt; descriptorLength) {
 319                     c = descriptor.charAt(p);
 320                     if (c &gt;= gZero &amp;&amp; c &lt;= gNine) {
 321                         val = val * ll_10 + (int32_t)(c - gZero);
 322                     }
 323                     else if (c == gGreaterThan) {
 324                         break;
 325                     }
 326                     else if (PatternProps::isWhiteSpace(c) || c == gComma || c == gDot) {
 327                     }
 328                     else {
 329                         // throw new IllegalArgumentException(&quot;Illegal character is rule descriptor&quot;);
 330                         status = U_PARSE_ERROR;
 331                         return;
 332                     }
 333                     ++p;
 334                 }
 335 
 336                 // tempValue now contain&#39;s the rule&#39;s radix.  Set it
 337                 // accordingly, and recalculate the rule&#39;s exponent
</pre>
<hr />
<pre>
 401     // return description;
 402 }
 403 
 404 /**
 405 * Searches the rule&#39;s rule text for the substitution tokens,
 406 * creates the substitutions, and removes the substitution tokens
 407 * from the rule&#39;s rule text.
 408 * @param owner The rule set containing this rule
 409 * @param predecessor The rule preseding this one in &quot;owners&quot; rule list
 410 * @param ownersOwner The RuleBasedFormat that owns this rule
 411 */
 412 void
 413 NFRule::extractSubstitutions(const NFRuleSet* ruleSet,
 414                              const UnicodeString &amp;ruleText,
 415                              const NFRule* predecessor,
 416                              UErrorCode&amp; status)
 417 {
 418     if (U_FAILURE(status)) {
 419         return;
 420     }
<span class="line-modified"> 421     this-&gt;ruleText = ruleText;</span>
 422     sub1 = extractSubstitution(ruleSet, predecessor, status);
 423     if (sub1 == NULL) {
 424         // Small optimization. There is no need to create a redundant NullSubstitution.
 425         sub2 = NULL;
 426     }
 427     else {
 428         sub2 = extractSubstitution(ruleSet, predecessor, status);
 429     }
<span class="line-modified"> 430     int32_t pluralRuleStart = this-&gt;ruleText.indexOf(gDollarOpenParenthesis, -1, 0);</span>
<span class="line-modified"> 431     int32_t pluralRuleEnd = (pluralRuleStart &gt;= 0 ? this-&gt;ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart) : -1);</span>
 432     if (pluralRuleEnd &gt;= 0) {
<span class="line-modified"> 433         int32_t endType = this-&gt;ruleText.indexOf(gComma, pluralRuleStart);</span>
 434         if (endType &lt; 0) {
 435             status = U_PARSE_ERROR;
 436             return;
 437         }
<span class="line-modified"> 438         UnicodeString type(this-&gt;ruleText.tempSubString(pluralRuleStart + 2, endType - pluralRuleStart - 2));</span>
 439         UPluralType pluralType;
 440         if (type.startsWith(UNICODE_STRING_SIMPLE(&quot;cardinal&quot;))) {
 441             pluralType = UPLURAL_TYPE_CARDINAL;
 442         }
 443         else if (type.startsWith(UNICODE_STRING_SIMPLE(&quot;ordinal&quot;))) {
 444             pluralType = UPLURAL_TYPE_ORDINAL;
 445         }
 446         else {
 447             status = U_ILLEGAL_ARGUMENT_ERROR;
 448             return;
 449         }
 450         rulePatternFormat = formatter-&gt;createPluralFormat(pluralType,
<span class="line-modified"> 451                 this-&gt;ruleText.tempSubString(endType + 1, pluralRuleEnd - endType - 1), status);</span>
 452     }
 453 }
 454 
 455 /**
 456 * Searches the rule&#39;s rule text for the first substitution token,
 457 * creates a substitution based on it, and removes the token from
 458 * the rule&#39;s rule text.
 459 * @param owner The rule set containing this rule
 460 * @param predecessor The rule preceding this one in the rule set&#39;s
 461 * rule list
 462 * @param ownersOwner The RuleBasedNumberFormat that owns this rule
 463 * @return The newly-created substitution.  This is never null; if
 464 * the rule text doesn&#39;t contain any substitution tokens, this will
 465 * be a NullSubstitution.
 466 */
 467 NFSubstitution *
 468 NFRule::extractSubstitution(const NFRuleSet* ruleSet,
 469                             const NFRule* predecessor,
 470                             UErrorCode&amp; status)
 471 {
 472     NFSubstitution* result = NULL;
 473 
 474     // search the rule&#39;s rule text for the first two characters of
 475     // a substitution token
 476     int32_t subStart = indexOfAnyRulePrefix();
 477     int32_t subEnd = subStart;
 478 
 479     // if we didn&#39;t find one, create a null substitution positioned
 480     // at the end of the rule text
 481     if (subStart == -1) {
 482         return NULL;
 483     }
 484 
 485     // special-case the &quot;&gt;&gt;&gt;&quot; token, since searching for the &gt; at the
 486     // end will actually find the &gt; in the middle
<span class="line-modified"> 487     if (ruleText.indexOf(gGreaterGreaterGreater, 3, 0) == subStart) {</span>
 488         subEnd = subStart + 2;
 489 
 490         // otherwise the substitution token ends with the same character
 491         // it began with
 492     } else {
<span class="line-modified"> 493         UChar c = ruleText.charAt(subStart);</span>
<span class="line-modified"> 494         subEnd = ruleText.indexOf(c, subStart + 1);</span>
 495         // special case for &#39;&lt;%foo&lt;&lt;&#39;
<span class="line-modified"> 496         if (c == gLessThan &amp;&amp; subEnd != -1 &amp;&amp; subEnd &lt; ruleText.length() - 1 &amp;&amp; ruleText.charAt(subEnd+1) == c) {</span>
 497             // ordinals use &quot;=#,##0==%abbrev=&quot; as their rule.  Notice that the &#39;==&#39; in the middle
 498             // occurs because of the juxtaposition of two different rules.  The check for &#39;&lt;&#39; is a hack
 499             // to get around this.  Having the duplicate at the front would cause problems with
 500             // rules like &quot;&lt;&lt;%&quot; to format, say, percents...
 501             ++subEnd;
 502         }
 503    }
 504 
 505     // if we don&#39;t find the end of the token (i.e., if we&#39;re on a single,
 506     // unmatched token character), create a null substitution positioned
 507     // at the end of the rule
 508     if (subEnd == -1) {
 509         return NULL;
 510     }
 511 
 512     // if we get here, we have a real substitution token (or at least
 513     // some text bounded by substitution token characters).  Use
 514     // makeSubstitution() to create the right kind of substitution
 515     UnicodeString subToken;
<span class="line-modified"> 516     subToken.setTo(ruleText, subStart, subEnd + 1 - subStart);</span>
 517     result = NFSubstitution::makeSubstitution(subStart, this, predecessor, ruleSet,
 518         this-&gt;formatter, subToken, status);
 519 
 520     // remove the substitution from the rule text
<span class="line-modified"> 521     ruleText.removeBetween(subStart, subEnd+1);</span>
 522 
 523     return result;
 524 }
 525 
 526 /**
 527  * Sets the rule&#39;s base value, and causes the radix and exponent
 528  * to be recalculated.  This is used during construction when we
 529  * don&#39;t know the rule&#39;s base value until after it&#39;s been
 530  * constructed.  It should be used at any other time.
 531  * @param The new base value for the rule.
 532  */
 533 void
 534 NFRule::setBaseValue(int64_t newBaseValue, UErrorCode&amp; status)
 535 {
 536     // set the base value
 537     baseValue = newBaseValue;
 538     radix = 10;
 539 
 540     // if this isn&#39;t a special rule, recalculate the radix and exponent
 541     // (the radix always defaults to 10; if it&#39;s supposed to be something
</pre>
<hr />
<pre>
 584     int16_t tempResult = (int16_t)(uprv_log((double)baseValue) / uprv_log((double)radix));
 585     int64_t temp = util64_pow(radix, tempResult + 1);
 586     if (temp &lt;= baseValue) {
 587         tempResult += 1;
 588     }
 589     return tempResult;
 590 }
 591 
 592 /**
 593  * Searches the rule&#39;s rule text for any of the specified strings.
 594  * @return The index of the first match in the rule&#39;s rule text
 595  * (i.e., the first substring in the rule&#39;s rule text that matches
 596  * _any_ of the strings in &quot;strings&quot;).  If none of the strings in
 597  * &quot;strings&quot; is found in the rule&#39;s rule text, returns -1.
 598  */
 599 int32_t
 600 NFRule::indexOfAnyRulePrefix() const
 601 {
 602     int result = -1;
 603     for (int i = 0; RULE_PREFIXES[i]; i++) {
<span class="line-modified"> 604         int32_t pos = ruleText.indexOf(*RULE_PREFIXES[i]);</span>
 605         if (pos != -1 &amp;&amp; (result == -1 || pos &lt; result)) {
 606             result = pos;
 607         }
 608     }
 609     return result;
 610 }
 611 
 612 //-----------------------------------------------------------------------
 613 // boilerplate
 614 //-----------------------------------------------------------------------
 615 
 616 static UBool
 617 util_equalSubstitutions(const NFSubstitution* sub1, const NFSubstitution* sub2)
 618 {
 619     if (sub1) {
 620         if (sub2) {
 621             return *sub1 == *sub2;
 622         }
 623     } else if (!sub2) {
 624         return TRUE;
 625     }
 626     return FALSE;
 627 }
 628 
 629 /**
 630 * Tests two rules for equality.
 631 * @param that The rule to compare this one against
 632 * @return True is the two rules are functionally equivalent
 633 */
 634 UBool
 635 NFRule::operator==(const NFRule&amp; rhs) const
 636 {
 637     return baseValue == rhs.baseValue
 638         &amp;&amp; radix == rhs.radix
 639         &amp;&amp; exponent == rhs.exponent
<span class="line-modified"> 640         &amp;&amp; ruleText == rhs.ruleText</span>
 641         &amp;&amp; util_equalSubstitutions(sub1, rhs.sub1)
 642         &amp;&amp; util_equalSubstitutions(sub2, rhs.sub2);
 643 }
 644 
 645 /**
 646 * Returns a textual representation of the rule.  This won&#39;t
 647 * necessarily be the same as the description that this rule
 648 * was created with, but it will produce the same result.
 649 * @return A textual description of the rule
 650 */
 651 static void util_append64(UnicodeString&amp; result, int64_t n)
 652 {
 653     UChar buffer[256];
 654     int32_t len = util64_tou(n, buffer, sizeof(buffer));
 655     UnicodeString temp(buffer, len);
 656     result.append(temp);
 657 }
 658 
 659 void
 660 NFRule::_appendRuleText(UnicodeString&amp; result) const
</pre>
<hr />
<pre>
 673         // if isn&#39;t the same as the actual exponent, write an appropriate
 674         // number of &gt; signs.  Finally, terminate the whole thing with
 675         // a colon.
 676         util_append64(result, baseValue);
 677         if (radix != 10) {
 678             result.append(gSlash);
 679             util_append64(result, radix);
 680         }
 681         int numCarets = expectedExponent() - exponent;
 682         for (int i = 0; i &lt; numCarets; i++) {
 683             result.append(gGreaterThan);
 684         }
 685         break;
 686     }
 687     result.append(gColon);
 688     result.append(gSpace);
 689 
 690     // if the rule text begins with a space, write an apostrophe
 691     // (whitespace after the rule descriptor is ignored; the
 692     // apostrophe is used to make the whitespace significant)
<span class="line-modified"> 693     if (ruleText.charAt(0) == gSpace &amp;&amp; (sub1 == NULL || sub1-&gt;getPos() != 0)) {</span>
 694         result.append(gTick);
 695     }
 696 
 697     // now, write the rule&#39;s rule text, inserting appropriate
 698     // substitution tokens in the appropriate places
 699     UnicodeString ruleTextCopy;
<span class="line-modified"> 700     ruleTextCopy.setTo(ruleText);</span>
 701 
 702     UnicodeString temp;
 703     if (sub2 != NULL) {
 704         sub2-&gt;toString(temp);
 705         ruleTextCopy.insert(sub2-&gt;getPos(), temp);
 706     }
 707     if (sub1 != NULL) {
 708         sub1-&gt;toString(temp);
 709         ruleTextCopy.insert(sub1-&gt;getPos(), temp);
 710     }
 711 
 712     result.append(ruleTextCopy);
 713 
 714     // and finally, top the whole thing off with a semicolon and
 715     // return the result
 716     result.append(gSemicolon);
 717 }
 718 
 719 int64_t NFRule::getDivisor() const
 720 {
</pre>
<hr />
<pre>
 726 // formatting
 727 //-----------------------------------------------------------------------
 728 
 729 /**
 730 * Formats the number, and inserts the resulting text into
 731 * toInsertInto.
 732 * @param number The number being formatted
 733 * @param toInsertInto The string where the resultant text should
 734 * be inserted
 735 * @param pos The position in toInsertInto where the resultant text
 736 * should be inserted
 737 */
 738 void
 739 NFRule::doFormat(int64_t number, UnicodeString&amp; toInsertInto, int32_t pos, int32_t recursionCount, UErrorCode&amp; status) const
 740 {
 741     // first, insert the rule&#39;s rule text into toInsertInto at the
 742     // specified position, then insert the results of the substitutions
 743     // into the right places in toInsertInto (notice we do the
 744     // substitutions in reverse order so that the offsets don&#39;t get
 745     // messed up)
<span class="line-modified"> 746     int32_t pluralRuleStart = ruleText.length();</span>
 747     int32_t lengthOffset = 0;
 748     if (!rulePatternFormat) {
<span class="line-modified"> 749         toInsertInto.insert(pos, ruleText);</span>
 750     }
 751     else {
<span class="line-modified"> 752         pluralRuleStart = ruleText.indexOf(gDollarOpenParenthesis, -1, 0);</span>
<span class="line-modified"> 753         int pluralRuleEnd = ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart);</span>
 754         int initialLength = toInsertInto.length();
<span class="line-modified"> 755         if (pluralRuleEnd &lt; ruleText.length() - 1) {</span>
<span class="line-modified"> 756             toInsertInto.insert(pos, ruleText.tempSubString(pluralRuleEnd + 2));</span>
 757         }
 758         toInsertInto.insert(pos,
 759             rulePatternFormat-&gt;format((int32_t)(number/util64_pow(radix, exponent)), status));
 760         if (pluralRuleStart &gt; 0) {
<span class="line-modified"> 761             toInsertInto.insert(pos, ruleText.tempSubString(0, pluralRuleStart));</span>
 762         }
<span class="line-modified"> 763         lengthOffset = ruleText.length() - (toInsertInto.length() - initialLength);</span>
 764     }
 765 
 766     if (sub2 != NULL) {
 767         sub2-&gt;doSubstitution(number, toInsertInto, pos - (sub2-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 768     }
 769     if (sub1 != NULL) {
 770         sub1-&gt;doSubstitution(number, toInsertInto, pos - (sub1-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 771     }
 772 }
 773 
 774 /**
 775 * Formats the number, and inserts the resulting text into
 776 * toInsertInto.
 777 * @param number The number being formatted
 778 * @param toInsertInto The string where the resultant text should
 779 * be inserted
 780 * @param pos The position in toInsertInto where the resultant text
 781 * should be inserted
 782 */
 783 void
 784 NFRule::doFormat(double number, UnicodeString&amp; toInsertInto, int32_t pos, int32_t recursionCount, UErrorCode&amp; status) const
 785 {
 786     // first, insert the rule&#39;s rule text into toInsertInto at the
 787     // specified position, then insert the results of the substitutions
 788     // into the right places in toInsertInto
 789     // [again, we have two copies of this routine that do the same thing
 790     // so that we don&#39;t sacrifice precision in a long by casting it
 791     // to a double]
<span class="line-modified"> 792     int32_t pluralRuleStart = ruleText.length();</span>
 793     int32_t lengthOffset = 0;
 794     if (!rulePatternFormat) {
<span class="line-modified"> 795         toInsertInto.insert(pos, ruleText);</span>
 796     }
 797     else {
<span class="line-modified"> 798         pluralRuleStart = ruleText.indexOf(gDollarOpenParenthesis, -1, 0);</span>
<span class="line-modified"> 799         int pluralRuleEnd = ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart);</span>
 800         int initialLength = toInsertInto.length();
<span class="line-modified"> 801         if (pluralRuleEnd &lt; ruleText.length() - 1) {</span>
<span class="line-modified"> 802             toInsertInto.insert(pos, ruleText.tempSubString(pluralRuleEnd + 2));</span>
 803         }
 804         double pluralVal = number;
 805         if (0 &lt;= pluralVal &amp;&amp; pluralVal &lt; 1) {
 806             // We&#39;re in a fractional rule, and we have to match the NumeratorSubstitution behavior.
 807             // 2.3 can become 0.2999999999999998 for the fraction due to rounding errors.
 808             pluralVal = uprv_round(pluralVal * util64_pow(radix, exponent));
 809         }
 810         else {
 811             pluralVal = pluralVal / util64_pow(radix, exponent);
 812         }
 813         toInsertInto.insert(pos, rulePatternFormat-&gt;format((int32_t)(pluralVal), status));
 814         if (pluralRuleStart &gt; 0) {
<span class="line-modified"> 815             toInsertInto.insert(pos, ruleText.tempSubString(0, pluralRuleStart));</span>
 816         }
<span class="line-modified"> 817         lengthOffset = ruleText.length() - (toInsertInto.length() - initialLength);</span>
 818     }
 819 
 820     if (sub2 != NULL) {
 821         sub2-&gt;doSubstitution(number, toInsertInto, pos - (sub2-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 822     }
 823     if (sub1 != NULL) {
 824         sub1-&gt;doSubstitution(number, toInsertInto, pos - (sub1-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 825     }
 826 }
 827 
 828 /**
 829 * Used by the owning rule set to determine whether to invoke the
 830 * rollback rule (i.e., whether this rule or the one that precedes
 831 * it in the rule set&#39;s list should be used to format the number)
 832 * @param The number being formatted
 833 * @return True if the rule set should use the rule that precedes
 834 * this one in its list; false if it should use this rule
 835 */
 836 UBool
 837 NFRule::shouldRollBack(int64_t number) const
</pre>
<hr />
<pre>
 891       us.extract(0, len, buf);
 892       buf[len] = 0;
 893       fprintf(f, &quot;%s&quot;, buf);
 894       uprv_free(buf); //delete[] buf;
 895   }
 896 }
 897 #endif
 898 UBool
 899 NFRule::doParse(const UnicodeString&amp; text,
 900                 ParsePosition&amp; parsePosition,
 901                 UBool isFractionRule,
 902                 double upperBound,
 903                 uint32_t nonNumericalExecutedRuleMask,
 904                 Formattable&amp; resVal) const
 905 {
 906     // internally we operate on a copy of the string being parsed
 907     // (because we&#39;re going to change it) and use our own ParsePosition
 908     ParsePosition pp;
 909     UnicodeString workText(text);
 910 
<span class="line-modified"> 911     int32_t sub1Pos = sub1 != NULL ? sub1-&gt;getPos() : ruleText.length();</span>
<span class="line-modified"> 912     int32_t sub2Pos = sub2 != NULL ? sub2-&gt;getPos() : ruleText.length();</span>
 913 
 914     // check to see whether the text before the first substitution
 915     // matches the text at the beginning of the string being
 916     // parsed.  If it does, strip that off the front of workText;
 917     // otherwise, dump out with a mismatch
 918     UnicodeString prefix;
<span class="line-modified"> 919     prefix.setTo(ruleText, 0, sub1Pos);</span>
 920 
 921 #ifdef RBNF_DEBUG
 922     fprintf(stderr, &quot;doParse %p &quot;, this);
 923     {
 924         UnicodeString rt;
 925         _appendRuleText(rt);
 926         dumpUS(stderr, rt);
 927     }
 928 
 929     fprintf(stderr, &quot; text: &#39;&quot;);
 930     dumpUS(stderr, text);
 931     fprintf(stderr, &quot;&#39; prefix: &#39;&quot;);
 932     dumpUS(stderr, prefix);
 933 #endif
 934     stripPrefix(workText, prefix, pp);
 935     int32_t prefixLength = text.length() - workText.length();
 936 
 937 #ifdef RBNF_DEBUG
 938     fprintf(stderr, &quot;&#39; pl: %d ppi: %d s1p: %d\n&quot;, prefixLength, pp.getIndex(), sub1Pos);
 939 #endif
</pre>
<hr />
<pre>
 983     // the substitution, we have a successful parse.
 984     //
 985     // Since it&#39;s possible in many cases to find multiple instances
 986     // of each of these pieces of rule text in the input string,
 987     // we need to try all the possible combinations of these
 988     // locations.  This prevents us from prematurely declaring a mismatch,
 989     // and makes sure we match as much input text as we can.
 990     int highWaterMark = 0;
 991     double result = 0;
 992     int start = 0;
 993     double tempBaseValue = (double)(baseValue &lt;= 0 ? 0 : baseValue);
 994 
 995     UnicodeString temp;
 996     do {
 997         // our partial parse result starts out as this rule&#39;s base
 998         // value.  If it finds a successful match, matchToDelimiter()
 999         // will compose this in some way with what it gets back from
1000         // the substitution, giving us a new partial parse result
1001         pp.setIndex(0);
1002 
<span class="line-modified">1003         temp.setTo(ruleText, sub1Pos, sub2Pos - sub1Pos);</span>
1004         double partialResult = matchToDelimiter(workText, start, tempBaseValue,
1005             temp, pp, sub1,
1006             nonNumericalExecutedRuleMask,
1007             upperBound);
1008 
1009         // if we got a successful match (or were trying to match a
1010         // null substitution), pp is now pointing at the first unmatched
1011         // character.  Take note of that, and try matchToDelimiter()
1012         // on the input text again
1013         if (pp.getIndex() != 0 || sub1 == NULL) {
1014             start = pp.getIndex();
1015 
1016             UnicodeString workText2;
1017             workText2.setTo(workText, pp.getIndex(), workText.length() - pp.getIndex());
1018             ParsePosition pp2;
1019 
1020             // the second matchToDelimiter() will compose our previous
1021             // partial result with whatever it gets back from its
1022             // substitution if there&#39;s a successful match, giving us
1023             // a real result
<span class="line-modified">1024             temp.setTo(ruleText, sub2Pos, ruleText.length() - sub2Pos);</span>
1025             partialResult = matchToDelimiter(workText2, 0, partialResult,
1026                 temp, pp2, sub2,
1027                 nonNumericalExecutedRuleMask,
1028                 upperBound);
1029 
1030             // if we got a successful match on this second
1031             // matchToDelimiter() call, update the high-water mark
1032             // and result (if necessary)
1033             if (pp2.getIndex() != 0 || sub2 == NULL) {
1034                 if (prefixLength + pp.getIndex() + pp2.getIndex() &gt; highWaterMark) {
1035                     highWaterMark = prefixLength + pp.getIndex() + pp2.getIndex();
1036                     result = partialResult;
1037                 }
1038             }
1039             else {
1040                 // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1041                 // restored for ICU4C port
<span class="line-modified">1042                 int32_t temp = pp2.getErrorIndex() + sub1Pos + pp.getIndex();</span>
<span class="line-modified">1043                 if (temp&gt; parsePosition.getErrorIndex()) {</span>
<span class="line-modified">1044                     parsePosition.setErrorIndex(temp);</span>
1045                 }
1046             }
1047         }
1048         else {
1049             // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1050             // restored for ICU4C port
<span class="line-modified">1051             int32_t temp = sub1Pos + pp.getErrorIndex();</span>
<span class="line-modified">1052             if (temp &gt; parsePosition.getErrorIndex()) {</span>
<span class="line-modified">1053                 parsePosition.setErrorIndex(temp);</span>
1054             }
1055         }
1056         // keep trying to match things until the outer matchToDelimiter()
1057         // call fails to make a match (each time, it picks up where it
1058         // left off the previous time)
1059     } while (sub1Pos != sub2Pos
1060         &amp;&amp; pp.getIndex() &gt; 0
1061         &amp;&amp; pp.getIndex() &lt; workText.length()
1062         &amp;&amp; pp.getIndex() != start);
1063 
1064     // update the caller&#39;s ParsePosition with our high-water mark
1065     // (i.e., it now points at the first character this function
1066     // didn&#39;t match-- the ParsePosition is therefore unchanged if
1067     // we didn&#39;t match anything)
1068     parsePosition.setIndex(highWaterMark);
1069     // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1070     // restored for ICU4C port
1071     if (highWaterMark &gt; 0) {
1072         parsePosition.setErrorIndex(0);
1073     }
</pre>
<hr />
<pre>
1466 * @param startingAt The index into &quot;str&quot; where the search is to
1467 * begin
1468 * @return A two-element array of ints.  Element 0 is the position
1469 * of the match, or -1 if there was no match.  Element 1 is the
1470 * number of characters in &quot;str&quot; that matched (which isn&#39;t necessarily
1471 * the same as the length of &quot;key&quot;)
1472 */
1473 int32_t
1474 NFRule::findText(const UnicodeString&amp; str,
1475                  const UnicodeString&amp; key,
1476                  int32_t startingAt,
1477                  int32_t* length) const
1478 {
1479     if (rulePatternFormat) {
1480         Formattable result;
1481         FieldPosition position(UNUM_INTEGER_FIELD);
1482         position.setBeginIndex(startingAt);
1483         rulePatternFormat-&gt;parseType(str, this, result, position);
1484         int start = position.getBeginIndex();
1485         if (start &gt;= 0) {
<span class="line-modified">1486             int32_t pluralRuleStart = ruleText.indexOf(gDollarOpenParenthesis, -1, 0);</span>
<span class="line-modified">1487             int32_t pluralRuleSuffix = ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart) + 2;</span>
1488             int32_t matchLen = position.getEndIndex() - start;
<span class="line-modified">1489             UnicodeString prefix(ruleText.tempSubString(0, pluralRuleStart));</span>
<span class="line-modified">1490             UnicodeString suffix(ruleText.tempSubString(pluralRuleSuffix));</span>
1491             if (str.compare(start - prefix.length(), prefix.length(), prefix, 0, prefix.length()) == 0
1492                     &amp;&amp; str.compare(start + matchLen, suffix.length(), suffix, 0, suffix.length()) == 0)
1493             {
1494                 *length = matchLen + prefix.length() + suffix.length();
1495                 return start - prefix.length();
1496             }
1497         }
1498         *length = 0;
1499         return -1;
1500     }
1501     if (!formatter-&gt;isLenient()) {
1502         // if lenient parsing is turned off, this is easy: just call
1503         // String.indexOf() and we&#39;re done
1504         *length = key.length();
1505         return str.indexOf(key, startingAt);
1506     }
1507     else {
1508         // but if lenient parsing is turned ON, we&#39;ve got some work
1509         // ahead of us
1510         return findTextLenient(str, key, startingAt, length);
</pre>
</td>
<td>
<hr />
<pre>
  22 #include &quot;unicode/localpointer.h&quot;
  23 #include &quot;unicode/rbnf.h&quot;
  24 #include &quot;unicode/tblcoll.h&quot;
  25 #include &quot;unicode/plurfmt.h&quot;
  26 #include &quot;unicode/upluralrules.h&quot;
  27 #include &quot;unicode/coleitr.h&quot;
  28 #include &quot;unicode/uchar.h&quot;
  29 #include &quot;nfrs.h&quot;
  30 #include &quot;nfrlist.h&quot;
  31 #include &quot;nfsubs.h&quot;
  32 #include &quot;patternprops.h&quot;
  33 #include &quot;putilimp.h&quot;
  34 
  35 U_NAMESPACE_BEGIN
  36 
  37 NFRule::NFRule(const RuleBasedNumberFormat* _rbnf, const UnicodeString &amp;_ruleText, UErrorCode &amp;status)
  38   : baseValue((int32_t)0)
  39   , radix(10)
  40   , exponent(0)
  41   , decimalPoint(0)
<span class="line-modified">  42   , fRuleText(_ruleText)</span>
  43   , sub1(NULL)
  44   , sub2(NULL)
  45   , formatter(_rbnf)
  46   , rulePatternFormat(NULL)
  47 {
<span class="line-modified">  48     if (!fRuleText.isEmpty()) {</span>
<span class="line-modified">  49         parseRuleDescriptor(fRuleText, status);</span>
  50     }
  51 }
  52 
  53 NFRule::~NFRule()
  54 {
  55     if (sub1 != sub2) {
  56         delete sub2;
  57         sub2 = NULL;
  58     }
  59     delete sub1;
  60     sub1 = NULL;
  61     delete rulePatternFormat;
  62     rulePatternFormat = NULL;
  63 }
  64 
  65 static const UChar gLeftBracket = 0x005b;
  66 static const UChar gRightBracket = 0x005d;
  67 static const UChar gColon = 0x003a;
  68 static const UChar gZero = 0x0030;
  69 static const UChar gNine = 0x0039;
</pre>
<hr />
<pre>
 105 };
 106 
 107 void
 108 NFRule::makeRules(UnicodeString&amp; description,
 109                   NFRuleSet *owner,
 110                   const NFRule *predecessor,
 111                   const RuleBasedNumberFormat *rbnf,
 112                   NFRuleList&amp; rules,
 113                   UErrorCode&amp; status)
 114 {
 115     // we know we&#39;re making at least one rule, so go ahead and
 116     // new it up and initialize its basevalue and divisor
 117     // (this also strips the rule descriptor, if any, off the
 118     // descripton string)
 119     NFRule* rule1 = new NFRule(rbnf, description, status);
 120     /* test for NULL */
 121     if (rule1 == 0) {
 122         status = U_MEMORY_ALLOCATION_ERROR;
 123         return;
 124     }
<span class="line-modified"> 125     description = rule1-&gt;fRuleText;</span>
 126 
 127     // check the description to see whether there&#39;s text enclosed
 128     // in brackets
 129     int32_t brack1 = description.indexOf(gLeftBracket);
 130     int32_t brack2 = brack1 &lt; 0 ? -1 : description.indexOf(gRightBracket);
 131 
 132     // if the description doesn&#39;t contain a matched pair of brackets,
 133     // or if it&#39;s of a type that doesn&#39;t recognize bracketed text,
 134     // then leave the description alone, initialize the rule&#39;s
 135     // rule text and substitutions, and return that rule
 136     if (brack2 &lt; 0 || brack1 &gt; brack2
 137         || rule1-&gt;getType() == kProperFractionRule
 138         || rule1-&gt;getType() == kNegativeNumberRule
 139         || rule1-&gt;getType() == kInfinityRule
 140         || rule1-&gt;getType() == kNaNRule)
 141     {
 142         rule1-&gt;extractSubstitutions(owner, description, predecessor, status);
 143     }
 144     else {
 145         // if the description does contain a matched pair of brackets,
</pre>
<hr />
<pre>
 297                 else if (PatternProps::isWhiteSpace(c) || c == gComma || c == gDot) {
 298                 }
 299                 else {
 300                     // throw new IllegalArgumentException(&quot;Illegal character in rule descriptor&quot;);
 301                     status = U_PARSE_ERROR;
 302                     return;
 303                 }
 304                 ++p;
 305             }
 306 
 307             // we have the base value, so set it
 308             setBaseValue(val, status);
 309 
 310             // if we stopped the previous loop on a slash, we&#39;re
 311             // now parsing the rule&#39;s radix.  Again, accumulate digits
 312             // in tempValue, skip punctuation, stop on a &gt; mark, and
 313             // throw an exception on anything else
 314             if (c == gSlash) {
 315                 val = 0;
 316                 ++p;
<span class="line-modified"> 317                 ll_10 = 10;</span>
 318                 while (p &lt; descriptorLength) {
 319                     c = descriptor.charAt(p);
 320                     if (c &gt;= gZero &amp;&amp; c &lt;= gNine) {
 321                         val = val * ll_10 + (int32_t)(c - gZero);
 322                     }
 323                     else if (c == gGreaterThan) {
 324                         break;
 325                     }
 326                     else if (PatternProps::isWhiteSpace(c) || c == gComma || c == gDot) {
 327                     }
 328                     else {
 329                         // throw new IllegalArgumentException(&quot;Illegal character is rule descriptor&quot;);
 330                         status = U_PARSE_ERROR;
 331                         return;
 332                     }
 333                     ++p;
 334                 }
 335 
 336                 // tempValue now contain&#39;s the rule&#39;s radix.  Set it
 337                 // accordingly, and recalculate the rule&#39;s exponent
</pre>
<hr />
<pre>
 401     // return description;
 402 }
 403 
 404 /**
 405 * Searches the rule&#39;s rule text for the substitution tokens,
 406 * creates the substitutions, and removes the substitution tokens
 407 * from the rule&#39;s rule text.
 408 * @param owner The rule set containing this rule
 409 * @param predecessor The rule preseding this one in &quot;owners&quot; rule list
 410 * @param ownersOwner The RuleBasedFormat that owns this rule
 411 */
 412 void
 413 NFRule::extractSubstitutions(const NFRuleSet* ruleSet,
 414                              const UnicodeString &amp;ruleText,
 415                              const NFRule* predecessor,
 416                              UErrorCode&amp; status)
 417 {
 418     if (U_FAILURE(status)) {
 419         return;
 420     }
<span class="line-modified"> 421     fRuleText = ruleText;</span>
 422     sub1 = extractSubstitution(ruleSet, predecessor, status);
 423     if (sub1 == NULL) {
 424         // Small optimization. There is no need to create a redundant NullSubstitution.
 425         sub2 = NULL;
 426     }
 427     else {
 428         sub2 = extractSubstitution(ruleSet, predecessor, status);
 429     }
<span class="line-modified"> 430     int32_t pluralRuleStart = fRuleText.indexOf(gDollarOpenParenthesis, -1, 0);</span>
<span class="line-modified"> 431     int32_t pluralRuleEnd = (pluralRuleStart &gt;= 0 ? fRuleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart) : -1);</span>
 432     if (pluralRuleEnd &gt;= 0) {
<span class="line-modified"> 433         int32_t endType = fRuleText.indexOf(gComma, pluralRuleStart);</span>
 434         if (endType &lt; 0) {
 435             status = U_PARSE_ERROR;
 436             return;
 437         }
<span class="line-modified"> 438         UnicodeString type(fRuleText.tempSubString(pluralRuleStart + 2, endType - pluralRuleStart - 2));</span>
 439         UPluralType pluralType;
 440         if (type.startsWith(UNICODE_STRING_SIMPLE(&quot;cardinal&quot;))) {
 441             pluralType = UPLURAL_TYPE_CARDINAL;
 442         }
 443         else if (type.startsWith(UNICODE_STRING_SIMPLE(&quot;ordinal&quot;))) {
 444             pluralType = UPLURAL_TYPE_ORDINAL;
 445         }
 446         else {
 447             status = U_ILLEGAL_ARGUMENT_ERROR;
 448             return;
 449         }
 450         rulePatternFormat = formatter-&gt;createPluralFormat(pluralType,
<span class="line-modified"> 451                 fRuleText.tempSubString(endType + 1, pluralRuleEnd - endType - 1), status);</span>
 452     }
 453 }
 454 
 455 /**
 456 * Searches the rule&#39;s rule text for the first substitution token,
 457 * creates a substitution based on it, and removes the token from
 458 * the rule&#39;s rule text.
 459 * @param owner The rule set containing this rule
 460 * @param predecessor The rule preceding this one in the rule set&#39;s
 461 * rule list
 462 * @param ownersOwner The RuleBasedNumberFormat that owns this rule
 463 * @return The newly-created substitution.  This is never null; if
 464 * the rule text doesn&#39;t contain any substitution tokens, this will
 465 * be a NullSubstitution.
 466 */
 467 NFSubstitution *
 468 NFRule::extractSubstitution(const NFRuleSet* ruleSet,
 469                             const NFRule* predecessor,
 470                             UErrorCode&amp; status)
 471 {
 472     NFSubstitution* result = NULL;
 473 
 474     // search the rule&#39;s rule text for the first two characters of
 475     // a substitution token
 476     int32_t subStart = indexOfAnyRulePrefix();
 477     int32_t subEnd = subStart;
 478 
 479     // if we didn&#39;t find one, create a null substitution positioned
 480     // at the end of the rule text
 481     if (subStart == -1) {
 482         return NULL;
 483     }
 484 
 485     // special-case the &quot;&gt;&gt;&gt;&quot; token, since searching for the &gt; at the
 486     // end will actually find the &gt; in the middle
<span class="line-modified"> 487     if (fRuleText.indexOf(gGreaterGreaterGreater, 3, 0) == subStart) {</span>
 488         subEnd = subStart + 2;
 489 
 490         // otherwise the substitution token ends with the same character
 491         // it began with
 492     } else {
<span class="line-modified"> 493         UChar c = fRuleText.charAt(subStart);</span>
<span class="line-modified"> 494         subEnd = fRuleText.indexOf(c, subStart + 1);</span>
 495         // special case for &#39;&lt;%foo&lt;&lt;&#39;
<span class="line-modified"> 496         if (c == gLessThan &amp;&amp; subEnd != -1 &amp;&amp; subEnd &lt; fRuleText.length() - 1 &amp;&amp; fRuleText.charAt(subEnd+1) == c) {</span>
 497             // ordinals use &quot;=#,##0==%abbrev=&quot; as their rule.  Notice that the &#39;==&#39; in the middle
 498             // occurs because of the juxtaposition of two different rules.  The check for &#39;&lt;&#39; is a hack
 499             // to get around this.  Having the duplicate at the front would cause problems with
 500             // rules like &quot;&lt;&lt;%&quot; to format, say, percents...
 501             ++subEnd;
 502         }
 503    }
 504 
 505     // if we don&#39;t find the end of the token (i.e., if we&#39;re on a single,
 506     // unmatched token character), create a null substitution positioned
 507     // at the end of the rule
 508     if (subEnd == -1) {
 509         return NULL;
 510     }
 511 
 512     // if we get here, we have a real substitution token (or at least
 513     // some text bounded by substitution token characters).  Use
 514     // makeSubstitution() to create the right kind of substitution
 515     UnicodeString subToken;
<span class="line-modified"> 516     subToken.setTo(fRuleText, subStart, subEnd + 1 - subStart);</span>
 517     result = NFSubstitution::makeSubstitution(subStart, this, predecessor, ruleSet,
 518         this-&gt;formatter, subToken, status);
 519 
 520     // remove the substitution from the rule text
<span class="line-modified"> 521     fRuleText.removeBetween(subStart, subEnd+1);</span>
 522 
 523     return result;
 524 }
 525 
 526 /**
 527  * Sets the rule&#39;s base value, and causes the radix and exponent
 528  * to be recalculated.  This is used during construction when we
 529  * don&#39;t know the rule&#39;s base value until after it&#39;s been
 530  * constructed.  It should be used at any other time.
 531  * @param The new base value for the rule.
 532  */
 533 void
 534 NFRule::setBaseValue(int64_t newBaseValue, UErrorCode&amp; status)
 535 {
 536     // set the base value
 537     baseValue = newBaseValue;
 538     radix = 10;
 539 
 540     // if this isn&#39;t a special rule, recalculate the radix and exponent
 541     // (the radix always defaults to 10; if it&#39;s supposed to be something
</pre>
<hr />
<pre>
 584     int16_t tempResult = (int16_t)(uprv_log((double)baseValue) / uprv_log((double)radix));
 585     int64_t temp = util64_pow(radix, tempResult + 1);
 586     if (temp &lt;= baseValue) {
 587         tempResult += 1;
 588     }
 589     return tempResult;
 590 }
 591 
 592 /**
 593  * Searches the rule&#39;s rule text for any of the specified strings.
 594  * @return The index of the first match in the rule&#39;s rule text
 595  * (i.e., the first substring in the rule&#39;s rule text that matches
 596  * _any_ of the strings in &quot;strings&quot;).  If none of the strings in
 597  * &quot;strings&quot; is found in the rule&#39;s rule text, returns -1.
 598  */
 599 int32_t
 600 NFRule::indexOfAnyRulePrefix() const
 601 {
 602     int result = -1;
 603     for (int i = 0; RULE_PREFIXES[i]; i++) {
<span class="line-modified"> 604         int32_t pos = fRuleText.indexOf(*RULE_PREFIXES[i]);</span>
 605         if (pos != -1 &amp;&amp; (result == -1 || pos &lt; result)) {
 606             result = pos;
 607         }
 608     }
 609     return result;
 610 }
 611 
 612 //-----------------------------------------------------------------------
 613 // boilerplate
 614 //-----------------------------------------------------------------------
 615 
 616 static UBool
 617 util_equalSubstitutions(const NFSubstitution* sub1, const NFSubstitution* sub2)
 618 {
 619     if (sub1) {
 620         if (sub2) {
 621             return *sub1 == *sub2;
 622         }
 623     } else if (!sub2) {
 624         return TRUE;
 625     }
 626     return FALSE;
 627 }
 628 
 629 /**
 630 * Tests two rules for equality.
 631 * @param that The rule to compare this one against
 632 * @return True is the two rules are functionally equivalent
 633 */
 634 UBool
 635 NFRule::operator==(const NFRule&amp; rhs) const
 636 {
 637     return baseValue == rhs.baseValue
 638         &amp;&amp; radix == rhs.radix
 639         &amp;&amp; exponent == rhs.exponent
<span class="line-modified"> 640         &amp;&amp; fRuleText == rhs.fRuleText</span>
 641         &amp;&amp; util_equalSubstitutions(sub1, rhs.sub1)
 642         &amp;&amp; util_equalSubstitutions(sub2, rhs.sub2);
 643 }
 644 
 645 /**
 646 * Returns a textual representation of the rule.  This won&#39;t
 647 * necessarily be the same as the description that this rule
 648 * was created with, but it will produce the same result.
 649 * @return A textual description of the rule
 650 */
 651 static void util_append64(UnicodeString&amp; result, int64_t n)
 652 {
 653     UChar buffer[256];
 654     int32_t len = util64_tou(n, buffer, sizeof(buffer));
 655     UnicodeString temp(buffer, len);
 656     result.append(temp);
 657 }
 658 
 659 void
 660 NFRule::_appendRuleText(UnicodeString&amp; result) const
</pre>
<hr />
<pre>
 673         // if isn&#39;t the same as the actual exponent, write an appropriate
 674         // number of &gt; signs.  Finally, terminate the whole thing with
 675         // a colon.
 676         util_append64(result, baseValue);
 677         if (radix != 10) {
 678             result.append(gSlash);
 679             util_append64(result, radix);
 680         }
 681         int numCarets = expectedExponent() - exponent;
 682         for (int i = 0; i &lt; numCarets; i++) {
 683             result.append(gGreaterThan);
 684         }
 685         break;
 686     }
 687     result.append(gColon);
 688     result.append(gSpace);
 689 
 690     // if the rule text begins with a space, write an apostrophe
 691     // (whitespace after the rule descriptor is ignored; the
 692     // apostrophe is used to make the whitespace significant)
<span class="line-modified"> 693     if (fRuleText.charAt(0) == gSpace &amp;&amp; (sub1 == NULL || sub1-&gt;getPos() != 0)) {</span>
 694         result.append(gTick);
 695     }
 696 
 697     // now, write the rule&#39;s rule text, inserting appropriate
 698     // substitution tokens in the appropriate places
 699     UnicodeString ruleTextCopy;
<span class="line-modified"> 700     ruleTextCopy.setTo(fRuleText);</span>
 701 
 702     UnicodeString temp;
 703     if (sub2 != NULL) {
 704         sub2-&gt;toString(temp);
 705         ruleTextCopy.insert(sub2-&gt;getPos(), temp);
 706     }
 707     if (sub1 != NULL) {
 708         sub1-&gt;toString(temp);
 709         ruleTextCopy.insert(sub1-&gt;getPos(), temp);
 710     }
 711 
 712     result.append(ruleTextCopy);
 713 
 714     // and finally, top the whole thing off with a semicolon and
 715     // return the result
 716     result.append(gSemicolon);
 717 }
 718 
 719 int64_t NFRule::getDivisor() const
 720 {
</pre>
<hr />
<pre>
 726 // formatting
 727 //-----------------------------------------------------------------------
 728 
 729 /**
 730 * Formats the number, and inserts the resulting text into
 731 * toInsertInto.
 732 * @param number The number being formatted
 733 * @param toInsertInto The string where the resultant text should
 734 * be inserted
 735 * @param pos The position in toInsertInto where the resultant text
 736 * should be inserted
 737 */
 738 void
 739 NFRule::doFormat(int64_t number, UnicodeString&amp; toInsertInto, int32_t pos, int32_t recursionCount, UErrorCode&amp; status) const
 740 {
 741     // first, insert the rule&#39;s rule text into toInsertInto at the
 742     // specified position, then insert the results of the substitutions
 743     // into the right places in toInsertInto (notice we do the
 744     // substitutions in reverse order so that the offsets don&#39;t get
 745     // messed up)
<span class="line-modified"> 746     int32_t pluralRuleStart = fRuleText.length();</span>
 747     int32_t lengthOffset = 0;
 748     if (!rulePatternFormat) {
<span class="line-modified"> 749         toInsertInto.insert(pos, fRuleText);</span>
 750     }
 751     else {
<span class="line-modified"> 752         pluralRuleStart = fRuleText.indexOf(gDollarOpenParenthesis, -1, 0);</span>
<span class="line-modified"> 753         int pluralRuleEnd = fRuleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart);</span>
 754         int initialLength = toInsertInto.length();
<span class="line-modified"> 755         if (pluralRuleEnd &lt; fRuleText.length() - 1) {</span>
<span class="line-modified"> 756             toInsertInto.insert(pos, fRuleText.tempSubString(pluralRuleEnd + 2));</span>
 757         }
 758         toInsertInto.insert(pos,
 759             rulePatternFormat-&gt;format((int32_t)(number/util64_pow(radix, exponent)), status));
 760         if (pluralRuleStart &gt; 0) {
<span class="line-modified"> 761             toInsertInto.insert(pos, fRuleText.tempSubString(0, pluralRuleStart));</span>
 762         }
<span class="line-modified"> 763         lengthOffset = fRuleText.length() - (toInsertInto.length() - initialLength);</span>
 764     }
 765 
 766     if (sub2 != NULL) {
 767         sub2-&gt;doSubstitution(number, toInsertInto, pos - (sub2-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 768     }
 769     if (sub1 != NULL) {
 770         sub1-&gt;doSubstitution(number, toInsertInto, pos - (sub1-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 771     }
 772 }
 773 
 774 /**
 775 * Formats the number, and inserts the resulting text into
 776 * toInsertInto.
 777 * @param number The number being formatted
 778 * @param toInsertInto The string where the resultant text should
 779 * be inserted
 780 * @param pos The position in toInsertInto where the resultant text
 781 * should be inserted
 782 */
 783 void
 784 NFRule::doFormat(double number, UnicodeString&amp; toInsertInto, int32_t pos, int32_t recursionCount, UErrorCode&amp; status) const
 785 {
 786     // first, insert the rule&#39;s rule text into toInsertInto at the
 787     // specified position, then insert the results of the substitutions
 788     // into the right places in toInsertInto
 789     // [again, we have two copies of this routine that do the same thing
 790     // so that we don&#39;t sacrifice precision in a long by casting it
 791     // to a double]
<span class="line-modified"> 792     int32_t pluralRuleStart = fRuleText.length();</span>
 793     int32_t lengthOffset = 0;
 794     if (!rulePatternFormat) {
<span class="line-modified"> 795         toInsertInto.insert(pos, fRuleText);</span>
 796     }
 797     else {
<span class="line-modified"> 798         pluralRuleStart = fRuleText.indexOf(gDollarOpenParenthesis, -1, 0);</span>
<span class="line-modified"> 799         int pluralRuleEnd = fRuleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart);</span>
 800         int initialLength = toInsertInto.length();
<span class="line-modified"> 801         if (pluralRuleEnd &lt; fRuleText.length() - 1) {</span>
<span class="line-modified"> 802             toInsertInto.insert(pos, fRuleText.tempSubString(pluralRuleEnd + 2));</span>
 803         }
 804         double pluralVal = number;
 805         if (0 &lt;= pluralVal &amp;&amp; pluralVal &lt; 1) {
 806             // We&#39;re in a fractional rule, and we have to match the NumeratorSubstitution behavior.
 807             // 2.3 can become 0.2999999999999998 for the fraction due to rounding errors.
 808             pluralVal = uprv_round(pluralVal * util64_pow(radix, exponent));
 809         }
 810         else {
 811             pluralVal = pluralVal / util64_pow(radix, exponent);
 812         }
 813         toInsertInto.insert(pos, rulePatternFormat-&gt;format((int32_t)(pluralVal), status));
 814         if (pluralRuleStart &gt; 0) {
<span class="line-modified"> 815             toInsertInto.insert(pos, fRuleText.tempSubString(0, pluralRuleStart));</span>
 816         }
<span class="line-modified"> 817         lengthOffset = fRuleText.length() - (toInsertInto.length() - initialLength);</span>
 818     }
 819 
 820     if (sub2 != NULL) {
 821         sub2-&gt;doSubstitution(number, toInsertInto, pos - (sub2-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 822     }
 823     if (sub1 != NULL) {
 824         sub1-&gt;doSubstitution(number, toInsertInto, pos - (sub1-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 825     }
 826 }
 827 
 828 /**
 829 * Used by the owning rule set to determine whether to invoke the
 830 * rollback rule (i.e., whether this rule or the one that precedes
 831 * it in the rule set&#39;s list should be used to format the number)
 832 * @param The number being formatted
 833 * @return True if the rule set should use the rule that precedes
 834 * this one in its list; false if it should use this rule
 835 */
 836 UBool
 837 NFRule::shouldRollBack(int64_t number) const
</pre>
<hr />
<pre>
 891       us.extract(0, len, buf);
 892       buf[len] = 0;
 893       fprintf(f, &quot;%s&quot;, buf);
 894       uprv_free(buf); //delete[] buf;
 895   }
 896 }
 897 #endif
 898 UBool
 899 NFRule::doParse(const UnicodeString&amp; text,
 900                 ParsePosition&amp; parsePosition,
 901                 UBool isFractionRule,
 902                 double upperBound,
 903                 uint32_t nonNumericalExecutedRuleMask,
 904                 Formattable&amp; resVal) const
 905 {
 906     // internally we operate on a copy of the string being parsed
 907     // (because we&#39;re going to change it) and use our own ParsePosition
 908     ParsePosition pp;
 909     UnicodeString workText(text);
 910 
<span class="line-modified"> 911     int32_t sub1Pos = sub1 != NULL ? sub1-&gt;getPos() : fRuleText.length();</span>
<span class="line-modified"> 912     int32_t sub2Pos = sub2 != NULL ? sub2-&gt;getPos() : fRuleText.length();</span>
 913 
 914     // check to see whether the text before the first substitution
 915     // matches the text at the beginning of the string being
 916     // parsed.  If it does, strip that off the front of workText;
 917     // otherwise, dump out with a mismatch
 918     UnicodeString prefix;
<span class="line-modified"> 919     prefix.setTo(fRuleText, 0, sub1Pos);</span>
 920 
 921 #ifdef RBNF_DEBUG
 922     fprintf(stderr, &quot;doParse %p &quot;, this);
 923     {
 924         UnicodeString rt;
 925         _appendRuleText(rt);
 926         dumpUS(stderr, rt);
 927     }
 928 
 929     fprintf(stderr, &quot; text: &#39;&quot;);
 930     dumpUS(stderr, text);
 931     fprintf(stderr, &quot;&#39; prefix: &#39;&quot;);
 932     dumpUS(stderr, prefix);
 933 #endif
 934     stripPrefix(workText, prefix, pp);
 935     int32_t prefixLength = text.length() - workText.length();
 936 
 937 #ifdef RBNF_DEBUG
 938     fprintf(stderr, &quot;&#39; pl: %d ppi: %d s1p: %d\n&quot;, prefixLength, pp.getIndex(), sub1Pos);
 939 #endif
</pre>
<hr />
<pre>
 983     // the substitution, we have a successful parse.
 984     //
 985     // Since it&#39;s possible in many cases to find multiple instances
 986     // of each of these pieces of rule text in the input string,
 987     // we need to try all the possible combinations of these
 988     // locations.  This prevents us from prematurely declaring a mismatch,
 989     // and makes sure we match as much input text as we can.
 990     int highWaterMark = 0;
 991     double result = 0;
 992     int start = 0;
 993     double tempBaseValue = (double)(baseValue &lt;= 0 ? 0 : baseValue);
 994 
 995     UnicodeString temp;
 996     do {
 997         // our partial parse result starts out as this rule&#39;s base
 998         // value.  If it finds a successful match, matchToDelimiter()
 999         // will compose this in some way with what it gets back from
1000         // the substitution, giving us a new partial parse result
1001         pp.setIndex(0);
1002 
<span class="line-modified">1003         temp.setTo(fRuleText, sub1Pos, sub2Pos - sub1Pos);</span>
1004         double partialResult = matchToDelimiter(workText, start, tempBaseValue,
1005             temp, pp, sub1,
1006             nonNumericalExecutedRuleMask,
1007             upperBound);
1008 
1009         // if we got a successful match (or were trying to match a
1010         // null substitution), pp is now pointing at the first unmatched
1011         // character.  Take note of that, and try matchToDelimiter()
1012         // on the input text again
1013         if (pp.getIndex() != 0 || sub1 == NULL) {
1014             start = pp.getIndex();
1015 
1016             UnicodeString workText2;
1017             workText2.setTo(workText, pp.getIndex(), workText.length() - pp.getIndex());
1018             ParsePosition pp2;
1019 
1020             // the second matchToDelimiter() will compose our previous
1021             // partial result with whatever it gets back from its
1022             // substitution if there&#39;s a successful match, giving us
1023             // a real result
<span class="line-modified">1024             temp.setTo(fRuleText, sub2Pos, fRuleText.length() - sub2Pos);</span>
1025             partialResult = matchToDelimiter(workText2, 0, partialResult,
1026                 temp, pp2, sub2,
1027                 nonNumericalExecutedRuleMask,
1028                 upperBound);
1029 
1030             // if we got a successful match on this second
1031             // matchToDelimiter() call, update the high-water mark
1032             // and result (if necessary)
1033             if (pp2.getIndex() != 0 || sub2 == NULL) {
1034                 if (prefixLength + pp.getIndex() + pp2.getIndex() &gt; highWaterMark) {
1035                     highWaterMark = prefixLength + pp.getIndex() + pp2.getIndex();
1036                     result = partialResult;
1037                 }
1038             }
1039             else {
1040                 // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1041                 // restored for ICU4C port
<span class="line-modified">1042                 int32_t i_temp = pp2.getErrorIndex() + sub1Pos + pp.getIndex();</span>
<span class="line-modified">1043                 if (i_temp&gt; parsePosition.getErrorIndex()) {</span>
<span class="line-modified">1044                     parsePosition.setErrorIndex(i_temp);</span>
1045                 }
1046             }
1047         }
1048         else {
1049             // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1050             // restored for ICU4C port
<span class="line-modified">1051             int32_t i_temp = sub1Pos + pp.getErrorIndex();</span>
<span class="line-modified">1052             if (i_temp &gt; parsePosition.getErrorIndex()) {</span>
<span class="line-modified">1053                 parsePosition.setErrorIndex(i_temp);</span>
1054             }
1055         }
1056         // keep trying to match things until the outer matchToDelimiter()
1057         // call fails to make a match (each time, it picks up where it
1058         // left off the previous time)
1059     } while (sub1Pos != sub2Pos
1060         &amp;&amp; pp.getIndex() &gt; 0
1061         &amp;&amp; pp.getIndex() &lt; workText.length()
1062         &amp;&amp; pp.getIndex() != start);
1063 
1064     // update the caller&#39;s ParsePosition with our high-water mark
1065     // (i.e., it now points at the first character this function
1066     // didn&#39;t match-- the ParsePosition is therefore unchanged if
1067     // we didn&#39;t match anything)
1068     parsePosition.setIndex(highWaterMark);
1069     // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1070     // restored for ICU4C port
1071     if (highWaterMark &gt; 0) {
1072         parsePosition.setErrorIndex(0);
1073     }
</pre>
<hr />
<pre>
1466 * @param startingAt The index into &quot;str&quot; where the search is to
1467 * begin
1468 * @return A two-element array of ints.  Element 0 is the position
1469 * of the match, or -1 if there was no match.  Element 1 is the
1470 * number of characters in &quot;str&quot; that matched (which isn&#39;t necessarily
1471 * the same as the length of &quot;key&quot;)
1472 */
1473 int32_t
1474 NFRule::findText(const UnicodeString&amp; str,
1475                  const UnicodeString&amp; key,
1476                  int32_t startingAt,
1477                  int32_t* length) const
1478 {
1479     if (rulePatternFormat) {
1480         Formattable result;
1481         FieldPosition position(UNUM_INTEGER_FIELD);
1482         position.setBeginIndex(startingAt);
1483         rulePatternFormat-&gt;parseType(str, this, result, position);
1484         int start = position.getBeginIndex();
1485         if (start &gt;= 0) {
<span class="line-modified">1486             int32_t pluralRuleStart = fRuleText.indexOf(gDollarOpenParenthesis, -1, 0);</span>
<span class="line-modified">1487             int32_t pluralRuleSuffix = fRuleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart) + 2;</span>
1488             int32_t matchLen = position.getEndIndex() - start;
<span class="line-modified">1489             UnicodeString prefix(fRuleText.tempSubString(0, pluralRuleStart));</span>
<span class="line-modified">1490             UnicodeString suffix(fRuleText.tempSubString(pluralRuleSuffix));</span>
1491             if (str.compare(start - prefix.length(), prefix.length(), prefix, 0, prefix.length()) == 0
1492                     &amp;&amp; str.compare(start + matchLen, suffix.length(), suffix, 0, suffix.length()) == 0)
1493             {
1494                 *length = matchLen + prefix.length() + suffix.length();
1495                 return start - prefix.length();
1496             }
1497         }
1498         *length = 0;
1499         return -1;
1500     }
1501     if (!formatter-&gt;isLenient()) {
1502         // if lenient parsing is turned off, this is easy: just call
1503         // String.indexOf() and we&#39;re done
1504         *length = key.length();
1505         return str.indexOf(key, startingAt);
1506     }
1507     else {
1508         // but if lenient parsing is turned ON, we&#39;ve got some work
1509         // ahead of us
1510         return findTextLenient(str, key, startingAt, length);
</pre>
</td>
</tr>
</table>
<center><a href="msgfmt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="nfrule.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>