<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtptngen.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 2007-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 *******************************************************************************
   8 *
   9 * File DTPTNGEN.CPP
  10 *
  11 *******************************************************************************
  12 */
  13 
  14 #include &quot;unicode/utypes.h&quot;
  15 #if !UCONFIG_NO_FORMATTING
  16 
  17 #include &quot;unicode/datefmt.h&quot;
  18 #include &quot;unicode/decimfmt.h&quot;
  19 #include &quot;unicode/dtfmtsym.h&quot;
  20 #include &quot;unicode/dtptngen.h&quot;
  21 #include &quot;unicode/simpleformatter.h&quot;
  22 #include &quot;unicode/smpdtfmt.h&quot;
  23 #include &quot;unicode/udat.h&quot;
  24 #include &quot;unicode/udatpg.h&quot;
  25 #include &quot;unicode/uniset.h&quot;
  26 #include &quot;unicode/uloc.h&quot;
  27 #include &quot;unicode/ures.h&quot;
  28 #include &quot;unicode/ustring.h&quot;
  29 #include &quot;unicode/rep.h&quot;
  30 #include &quot;cpputils.h&quot;
  31 #include &quot;mutex.h&quot;
  32 #include &quot;umutex.h&quot;
  33 #include &quot;cmemory.h&quot;
  34 #include &quot;cstring.h&quot;
  35 #include &quot;locbased.h&quot;
  36 #include &quot;hash.h&quot;
  37 #include &quot;uhash.h&quot;
  38 #include &quot;uresimp.h&quot;
  39 #include &quot;dtptngen_impl.h&quot;
  40 #include &quot;ucln_in.h&quot;
  41 #include &quot;charstr.h&quot;
  42 #include &quot;uassert.h&quot;
  43 
  44 #if U_CHARSET_FAMILY==U_EBCDIC_FAMILY
  45 /**
  46  * If we are on EBCDIC, use an iterator which will
  47  * traverse the bundles in ASCII order.
  48  */
  49 #define U_USE_ASCII_BUNDLE_ITERATOR
  50 #define U_SORT_ASCII_BUNDLE_ITERATOR
  51 #endif
  52 
  53 #if defined(U_USE_ASCII_BUNDLE_ITERATOR)
  54 
  55 #include &quot;unicode/ustring.h&quot;
  56 #include &quot;uarrsort.h&quot;
  57 
  58 struct UResAEntry {
  59     UChar *key;
  60     UResourceBundle *item;
  61 };
  62 
  63 struct UResourceBundleAIterator {
  64     UResourceBundle  *bund;
  65     UResAEntry *entries;
  66     int32_t num;
  67     int32_t cursor;
  68 };
  69 
  70 /* Must be C linkage to pass function pointer to the sort function */
  71 
  72 U_CDECL_BEGIN
  73 
  74 static int32_t U_CALLCONV
  75 ures_a_codepointSort(const void *context, const void *left, const void *right) {
  76     //CompareContext *cmp=(CompareContext *)context;
  77     return u_strcmp(((const UResAEntry *)left)-&gt;key,
  78                     ((const UResAEntry *)right)-&gt;key);
  79 }
  80 
  81 U_CDECL_END
  82 
  83 static void ures_a_open(UResourceBundleAIterator *aiter, UResourceBundle *bund, UErrorCode *status) {
  84     if(U_FAILURE(*status)) {
  85         return;
  86     }
  87     aiter-&gt;bund = bund;
  88     aiter-&gt;num = ures_getSize(aiter-&gt;bund);
  89     aiter-&gt;cursor = 0;
  90 #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)
  91     aiter-&gt;entries = NULL;
  92 #else
  93     aiter-&gt;entries = (UResAEntry*)uprv_malloc(sizeof(UResAEntry)*aiter-&gt;num);
  94     for(int i=0;i&lt;aiter-&gt;num;i++) {
  95         aiter-&gt;entries[i].item = ures_getByIndex(aiter-&gt;bund, i, NULL, status);
  96         const char *akey = ures_getKey(aiter-&gt;entries[i].item);
  97         int32_t len = uprv_strlen(akey)+1;
  98         aiter-&gt;entries[i].key = (UChar*)uprv_malloc(len*sizeof(UChar));
  99         u_charsToUChars(akey, aiter-&gt;entries[i].key, len);
 100     }
 101     uprv_sortArray(aiter-&gt;entries, aiter-&gt;num, sizeof(UResAEntry), ures_a_codepointSort, NULL, TRUE, status);
 102 #endif
 103 }
 104 
 105 static void ures_a_close(UResourceBundleAIterator *aiter) {
 106 #if defined(U_SORT_ASCII_BUNDLE_ITERATOR)
 107     for(int i=0;i&lt;aiter-&gt;num;i++) {
 108         uprv_free(aiter-&gt;entries[i].key);
 109         ures_close(aiter-&gt;entries[i].item);
 110     }
 111 #endif
 112 }
 113 
 114 static const UChar *ures_a_getNextString(UResourceBundleAIterator *aiter, int32_t *len, const char **key, UErrorCode *err) {
 115 #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)
 116     return ures_getNextString(aiter-&gt;bund, len, key, err);
 117 #else
 118     if(U_FAILURE(*err)) return NULL;
 119     UResourceBundle *item = aiter-&gt;entries[aiter-&gt;cursor].item;
 120     const UChar* ret = ures_getString(item, len, err);
 121     *key = ures_getKey(item);
 122     aiter-&gt;cursor++;
 123     return ret;
 124 #endif
 125 }
 126 
 127 
 128 #endif
 129 
 130 
 131 U_NAMESPACE_BEGIN
 132 
 133 // *****************************************************************************
 134 // class DateTimePatternGenerator
 135 // *****************************************************************************
 136 static const UChar Canonical_Items[] = {
 137     // GyQMwWEDFdaHmsSv
 138     CAP_G, LOW_Y, CAP_Q, CAP_M, LOW_W, CAP_W, CAP_E,
 139     CAP_D, CAP_F, LOW_D, LOW_A, // The UDATPG_x_FIELD constants and these fields have a different order than in ICU4J
 140     CAP_H, LOW_M, LOW_S, CAP_S, LOW_V, 0
 141 };
 142 
 143 static const dtTypeElem dtTypes[] = {
 144     // patternChar, field, type, minLen, weight
 145     {CAP_G, UDATPG_ERA_FIELD, DT_SHORT, 1, 3,},
 146     {CAP_G, UDATPG_ERA_FIELD, DT_LONG,  4, 0},
 147     {CAP_G, UDATPG_ERA_FIELD, DT_NARROW, 5, 0},
 148 
 149     {LOW_Y, UDATPG_YEAR_FIELD, DT_NUMERIC, 1, 20},
 150     {CAP_Y, UDATPG_YEAR_FIELD, DT_NUMERIC + DT_DELTA, 1, 20},
 151     {LOW_U, UDATPG_YEAR_FIELD, DT_NUMERIC + 2*DT_DELTA, 1, 20},
 152     {LOW_R, UDATPG_YEAR_FIELD, DT_NUMERIC + 3*DT_DELTA, 1, 20},
 153     {CAP_U, UDATPG_YEAR_FIELD, DT_SHORT, 1, 3},
 154     {CAP_U, UDATPG_YEAR_FIELD, DT_LONG, 4, 0},
 155     {CAP_U, UDATPG_YEAR_FIELD, DT_NARROW, 5, 0},
 156 
 157     {CAP_Q, UDATPG_QUARTER_FIELD, DT_NUMERIC, 1, 2},
 158     {CAP_Q, UDATPG_QUARTER_FIELD, DT_SHORT, 3, 0},
 159     {CAP_Q, UDATPG_QUARTER_FIELD, DT_LONG, 4, 0},
 160     {CAP_Q, UDATPG_QUARTER_FIELD, DT_NARROW, 5, 0},
 161     {LOW_Q, UDATPG_QUARTER_FIELD, DT_NUMERIC + DT_DELTA, 1, 2},
 162     {LOW_Q, UDATPG_QUARTER_FIELD, DT_SHORT - DT_DELTA, 3, 0},
 163     {LOW_Q, UDATPG_QUARTER_FIELD, DT_LONG - DT_DELTA, 4, 0},
 164     {LOW_Q, UDATPG_QUARTER_FIELD, DT_NARROW - DT_DELTA, 5, 0},
 165 
 166     {CAP_M, UDATPG_MONTH_FIELD, DT_NUMERIC, 1, 2},
 167     {CAP_M, UDATPG_MONTH_FIELD, DT_SHORT, 3, 0},
 168     {CAP_M, UDATPG_MONTH_FIELD, DT_LONG, 4, 0},
 169     {CAP_M, UDATPG_MONTH_FIELD, DT_NARROW, 5, 0},
 170     {CAP_L, UDATPG_MONTH_FIELD, DT_NUMERIC + DT_DELTA, 1, 2},
 171     {CAP_L, UDATPG_MONTH_FIELD, DT_SHORT - DT_DELTA, 3, 0},
 172     {CAP_L, UDATPG_MONTH_FIELD, DT_LONG - DT_DELTA, 4, 0},
 173     {CAP_L, UDATPG_MONTH_FIELD, DT_NARROW - DT_DELTA, 5, 0},
 174     {LOW_L, UDATPG_MONTH_FIELD, DT_NUMERIC + DT_DELTA, 1, 1},
 175 
 176     {LOW_W, UDATPG_WEEK_OF_YEAR_FIELD, DT_NUMERIC, 1, 2},
 177 
 178     {CAP_W, UDATPG_WEEK_OF_MONTH_FIELD, DT_NUMERIC, 1, 0},
 179 
 180     {CAP_E, UDATPG_WEEKDAY_FIELD, DT_SHORT, 1, 3},
 181     {CAP_E, UDATPG_WEEKDAY_FIELD, DT_LONG, 4, 0},
 182     {CAP_E, UDATPG_WEEKDAY_FIELD, DT_NARROW, 5, 0},
 183     {CAP_E, UDATPG_WEEKDAY_FIELD, DT_SHORTER, 6, 0},
 184     {LOW_C, UDATPG_WEEKDAY_FIELD, DT_NUMERIC + 2*DT_DELTA, 1, 2},
 185     {LOW_C, UDATPG_WEEKDAY_FIELD, DT_SHORT - 2*DT_DELTA, 3, 0},
 186     {LOW_C, UDATPG_WEEKDAY_FIELD, DT_LONG - 2*DT_DELTA, 4, 0},
 187     {LOW_C, UDATPG_WEEKDAY_FIELD, DT_NARROW - 2*DT_DELTA, 5, 0},
 188     {LOW_C, UDATPG_WEEKDAY_FIELD, DT_SHORTER - 2*DT_DELTA, 6, 0},
 189     {LOW_E, UDATPG_WEEKDAY_FIELD, DT_NUMERIC + DT_DELTA, 1, 2}, // LOW_E is currently not used in CLDR data, should not be canonical
 190     {LOW_E, UDATPG_WEEKDAY_FIELD, DT_SHORT - DT_DELTA, 3, 0},
 191     {LOW_E, UDATPG_WEEKDAY_FIELD, DT_LONG - DT_DELTA, 4, 0},
 192     {LOW_E, UDATPG_WEEKDAY_FIELD, DT_NARROW - DT_DELTA, 5, 0},
 193     {LOW_E, UDATPG_WEEKDAY_FIELD, DT_SHORTER - DT_DELTA, 6, 0},
 194 
 195     {LOW_D, UDATPG_DAY_FIELD, DT_NUMERIC, 1, 2},
 196     {LOW_G, UDATPG_DAY_FIELD, DT_NUMERIC + DT_DELTA, 1, 20}, // really internal use, so we don&#39;t care
 197 
 198     {CAP_D, UDATPG_DAY_OF_YEAR_FIELD, DT_NUMERIC, 1, 3},
 199 
 200     {CAP_F, UDATPG_DAY_OF_WEEK_IN_MONTH_FIELD, DT_NUMERIC, 1, 0},
 201 
 202     {LOW_A, UDATPG_DAYPERIOD_FIELD, DT_SHORT, 1, 3},
 203     {LOW_A, UDATPG_DAYPERIOD_FIELD, DT_LONG, 4, 0},
 204     {LOW_A, UDATPG_DAYPERIOD_FIELD, DT_NARROW, 5, 0},
 205     {LOW_B, UDATPG_DAYPERIOD_FIELD, DT_SHORT - DT_DELTA, 1, 3},
 206     {LOW_B, UDATPG_DAYPERIOD_FIELD, DT_LONG - DT_DELTA, 4, 0},
 207     {LOW_B, UDATPG_DAYPERIOD_FIELD, DT_NARROW - DT_DELTA, 5, 0},
 208     // b needs to be closer to a than to B, so we make this 3*DT_DELTA
 209     {CAP_B, UDATPG_DAYPERIOD_FIELD, DT_SHORT - 3*DT_DELTA, 1, 3},
 210     {CAP_B, UDATPG_DAYPERIOD_FIELD, DT_LONG - 3*DT_DELTA, 4, 0},
 211     {CAP_B, UDATPG_DAYPERIOD_FIELD, DT_NARROW - 3*DT_DELTA, 5, 0},
 212 
 213     {CAP_H, UDATPG_HOUR_FIELD, DT_NUMERIC + 10*DT_DELTA, 1, 2}, // 24 hour
 214     {LOW_K, UDATPG_HOUR_FIELD, DT_NUMERIC + 11*DT_DELTA, 1, 2}, // 24 hour
 215     {LOW_H, UDATPG_HOUR_FIELD, DT_NUMERIC, 1, 2}, // 12 hour
 216     {CAP_K, UDATPG_HOUR_FIELD, DT_NUMERIC + DT_DELTA, 1, 2}, // 12 hour
 217     // The C code has had versions of the following 3, keep &amp; update. Should not need these, but...
 218     // Without these, certain tests using e.g. staticGetSkeleton fail because j/J in patterns
 219     // get skipped instead of mapped to the right hour chars, for example in
 220     //   DateFormatTest::TestPatternFromSkeleton
 221     //   IntlTestDateTimePatternGeneratorAPI:: testStaticGetSkeleton
 222     //   DateIntervalFormatTest::testTicket11985
 223     // Need to investigate better handling of jJC replacement e.g. in staticGetSkeleton.
 224     {CAP_J, UDATPG_HOUR_FIELD, DT_NUMERIC + 5*DT_DELTA, 1, 2}, // 12/24 hour no AM/PM
 225     {LOW_J, UDATPG_HOUR_FIELD, DT_NUMERIC + 6*DT_DELTA, 1, 6}, // 12/24 hour
 226     {CAP_C, UDATPG_HOUR_FIELD, DT_NUMERIC + 7*DT_DELTA, 1, 6}, // 12/24 hour with preferred dayPeriods for 12
 227 
 228     {LOW_M, UDATPG_MINUTE_FIELD, DT_NUMERIC, 1, 2},
 229 
 230     {LOW_S, UDATPG_SECOND_FIELD, DT_NUMERIC, 1, 2},
 231     {CAP_A, UDATPG_SECOND_FIELD, DT_NUMERIC + DT_DELTA, 1, 1000},
 232 
 233     {CAP_S, UDATPG_FRACTIONAL_SECOND_FIELD, DT_NUMERIC, 1, 1000},
 234 
 235     {LOW_V, UDATPG_ZONE_FIELD, DT_SHORT - 2*DT_DELTA, 1, 0},
 236     {LOW_V, UDATPG_ZONE_FIELD, DT_LONG - 2*DT_DELTA, 4, 0},
 237     {LOW_Z, UDATPG_ZONE_FIELD, DT_SHORT, 1, 3},
 238     {LOW_Z, UDATPG_ZONE_FIELD, DT_LONG, 4, 0},
 239     {CAP_Z, UDATPG_ZONE_FIELD, DT_NARROW - DT_DELTA, 1, 3},
 240     {CAP_Z, UDATPG_ZONE_FIELD, DT_LONG - DT_DELTA, 4, 0},
 241     {CAP_Z, UDATPG_ZONE_FIELD, DT_SHORT - DT_DELTA, 5, 0},
 242     {CAP_O, UDATPG_ZONE_FIELD, DT_SHORT - DT_DELTA, 1, 0},
 243     {CAP_O, UDATPG_ZONE_FIELD, DT_LONG - DT_DELTA, 4, 0},
 244     {CAP_V, UDATPG_ZONE_FIELD, DT_SHORT - DT_DELTA, 1, 0},
 245     {CAP_V, UDATPG_ZONE_FIELD, DT_LONG - DT_DELTA, 2, 0},
 246     {CAP_V, UDATPG_ZONE_FIELD, DT_LONG-1 - DT_DELTA, 3, 0},
 247     {CAP_V, UDATPG_ZONE_FIELD, DT_LONG-2 - DT_DELTA, 4, 0},
 248     {CAP_X, UDATPG_ZONE_FIELD, DT_NARROW - DT_DELTA, 1, 0},
 249     {CAP_X, UDATPG_ZONE_FIELD, DT_SHORT - DT_DELTA, 2, 0},
 250     {CAP_X, UDATPG_ZONE_FIELD, DT_LONG - DT_DELTA, 4, 0},
 251     {LOW_X, UDATPG_ZONE_FIELD, DT_NARROW - DT_DELTA, 1, 0},
 252     {LOW_X, UDATPG_ZONE_FIELD, DT_SHORT - DT_DELTA, 2, 0},
 253     {LOW_X, UDATPG_ZONE_FIELD, DT_LONG - DT_DELTA, 4, 0},
 254 
 255     {0, UDATPG_FIELD_COUNT, 0, 0, 0} , // last row of dtTypes[]
 256  };
 257 
 258 static const char* const CLDR_FIELD_APPEND[] = {
 259     &quot;Era&quot;, &quot;Year&quot;, &quot;Quarter&quot;, &quot;Month&quot;, &quot;Week&quot;, &quot;*&quot;, &quot;Day-Of-Week&quot;,
 260     &quot;*&quot;, &quot;*&quot;, &quot;Day&quot;, &quot;*&quot;, // The UDATPG_x_FIELD constants and these fields have a different order than in ICU4J
 261     &quot;Hour&quot;, &quot;Minute&quot;, &quot;Second&quot;, &quot;*&quot;, &quot;Timezone&quot;
 262 };
 263 
 264 static const char* const CLDR_FIELD_NAME[UDATPG_FIELD_COUNT] = {
 265     &quot;era&quot;, &quot;year&quot;, &quot;quarter&quot;, &quot;month&quot;, &quot;week&quot;, &quot;weekOfMonth&quot;, &quot;weekday&quot;,
 266     &quot;dayOfYear&quot;, &quot;weekdayOfMonth&quot;, &quot;day&quot;, &quot;dayperiod&quot;, // The UDATPG_x_FIELD constants and these fields have a different order than in ICU4J
 267     &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;, &quot;*&quot;, &quot;zone&quot;
 268 };
 269 
 270 static const char* const CLDR_FIELD_WIDTH[] = { // [UDATPG_WIDTH_COUNT]
 271     &quot;&quot;, &quot;-short&quot;, &quot;-narrow&quot;
 272 };
 273 
 274 // TODO(ticket:13619): remove when definition uncommented in dtptngen.h.
 275 static const int32_t UDATPG_WIDTH_COUNT = UDATPG_NARROW + 1;
 276 static constexpr UDateTimePGDisplayWidth UDATPG_WIDTH_APPENDITEM = UDATPG_WIDE;
 277 static constexpr int32_t UDATPG_FIELD_KEY_MAX = 24; // max length of CLDR field tag (type + width)
 278 
 279 // For appendItems
 280 static const UChar UDATPG_ItemFormat[]= {0x7B, 0x30, 0x7D, 0x20, 0x251C, 0x7B, 0x32, 0x7D, 0x3A,
 281     0x20, 0x7B, 0x31, 0x7D, 0x2524, 0};  // {0} \u251C{2}: {1}\u2524
 282 
 283 //static const UChar repeatedPatterns[6]={CAP_G, CAP_E, LOW_Z, LOW_V, CAP_Q, 0}; // &quot;GEzvQ&quot;
 284 
 285 static const char DT_DateTimePatternsTag[]=&quot;DateTimePatterns&quot;;
 286 static const char DT_DateTimeCalendarTag[]=&quot;calendar&quot;;
 287 static const char DT_DateTimeGregorianTag[]=&quot;gregorian&quot;;
 288 static const char DT_DateTimeAppendItemsTag[]=&quot;appendItems&quot;;
 289 static const char DT_DateTimeFieldsTag[]=&quot;fields&quot;;
 290 static const char DT_DateTimeAvailableFormatsTag[]=&quot;availableFormats&quot;;
 291 //static const UnicodeString repeatedPattern=UnicodeString(repeatedPatterns);
 292 
 293 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DateTimePatternGenerator)
 294 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DTSkeletonEnumeration)
 295 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DTRedundantEnumeration)
 296 
 297 DateTimePatternGenerator*  U_EXPORT2
 298 DateTimePatternGenerator::createInstance(UErrorCode&amp; status) {
 299     return createInstance(Locale::getDefault(), status);
 300 }
 301 
 302 DateTimePatternGenerator* U_EXPORT2
 303 DateTimePatternGenerator::createInstance(const Locale&amp; locale, UErrorCode&amp; status) {
 304     if (U_FAILURE(status)) {
 305         return NULL;
 306     }
 307     LocalPointer&lt;DateTimePatternGenerator&gt; result(
 308             new DateTimePatternGenerator(locale, status), status);
 309     return U_SUCCESS(status) ? result.orphan() : NULL;
 310 }
 311 
 312 DateTimePatternGenerator*  U_EXPORT2
 313 DateTimePatternGenerator::createEmptyInstance(UErrorCode&amp; status) {
 314     DateTimePatternGenerator *result = new DateTimePatternGenerator(status);
 315     if (result == NULL) {
 316         status = U_MEMORY_ALLOCATION_ERROR;
 317     }
 318     if (U_FAILURE(status)) {
 319         delete result;
 320         result = NULL;
 321     }
 322     return result;
 323 }
 324 
 325 DateTimePatternGenerator::DateTimePatternGenerator(UErrorCode &amp;status) :
 326     skipMatcher(NULL),
 327     fAvailableFormatKeyHash(NULL)
 328 {
 329     fp = new FormatParser();
 330     dtMatcher = new DateTimeMatcher();
 331     distanceInfo = new DistanceInfo();
 332     patternMap = new PatternMap();
 333     if (fp == NULL || dtMatcher == NULL || distanceInfo == NULL || patternMap == NULL) {
 334         status = U_MEMORY_ALLOCATION_ERROR;
 335     }
 336 }
 337 
 338 DateTimePatternGenerator::DateTimePatternGenerator(const Locale&amp; locale, UErrorCode &amp;status) :
 339     skipMatcher(NULL),
 340     fAvailableFormatKeyHash(NULL)
 341 {
 342     fp = new FormatParser();
 343     dtMatcher = new DateTimeMatcher();
 344     distanceInfo = new DistanceInfo();
 345     patternMap = new PatternMap();
 346     if (fp == NULL || dtMatcher == NULL || distanceInfo == NULL || patternMap == NULL) {
 347         status = U_MEMORY_ALLOCATION_ERROR;
 348     }
 349     else {
 350         initData(locale, status);
 351     }
 352 }
 353 
 354 DateTimePatternGenerator::DateTimePatternGenerator(const DateTimePatternGenerator&amp; other) :
 355     UObject(),
 356     skipMatcher(NULL),
 357     fAvailableFormatKeyHash(NULL)
 358 {
 359     fp = new FormatParser();
 360     dtMatcher = new DateTimeMatcher();
 361     distanceInfo = new DistanceInfo();
 362     patternMap = new PatternMap();
 363     *this=other;
 364 }
 365 
 366 DateTimePatternGenerator&amp;
 367 DateTimePatternGenerator::operator=(const DateTimePatternGenerator&amp; other) {
 368     // reflexive case
 369     if (&amp;other == this) {
 370         return *this;
 371     }
 372     pLocale = other.pLocale;
 373     fDefaultHourFormatChar = other.fDefaultHourFormatChar;
 374     *fp = *(other.fp);
 375     dtMatcher-&gt;copyFrom(other.dtMatcher-&gt;skeleton);
 376     *distanceInfo = *(other.distanceInfo);
 377     dateTimeFormat = other.dateTimeFormat;
 378     decimal = other.decimal;
 379     // NUL-terminate for the C API.
 380     dateTimeFormat.getTerminatedBuffer();
 381     decimal.getTerminatedBuffer();
 382     delete skipMatcher;
 383     if ( other.skipMatcher == NULL ) {
 384         skipMatcher = NULL;
 385     }
 386     else {
 387         skipMatcher = new DateTimeMatcher(*other.skipMatcher);
 388     }
 389     for (int32_t i=0; i&lt; UDATPG_FIELD_COUNT; ++i ) {
 390         appendItemFormats[i] = other.appendItemFormats[i];
 391         appendItemFormats[i].getTerminatedBuffer(); // NUL-terminate for the C API.
 392         for (int32_t j=0; j&lt; UDATPG_WIDTH_COUNT; ++j ) {
 393             fieldDisplayNames[i][j] = other.fieldDisplayNames[i][j];
 394             fieldDisplayNames[i][j].getTerminatedBuffer(); // NUL-terminate for the C API.
 395         }
 396     }
 397     UErrorCode status = U_ZERO_ERROR;
 398     patternMap-&gt;copyFrom(*other.patternMap, status);
 399     copyHashtable(other.fAvailableFormatKeyHash, status);
 400     return *this;
 401 }
 402 
 403 
 404 UBool
 405 DateTimePatternGenerator::operator==(const DateTimePatternGenerator&amp; other) const {
 406     if (this == &amp;other) {
 407         return TRUE;
 408     }
 409     if ((pLocale==other.pLocale) &amp;&amp; (patternMap-&gt;equals(*other.patternMap)) &amp;&amp;
 410         (dateTimeFormat==other.dateTimeFormat) &amp;&amp; (decimal==other.decimal)) {
 411         for ( int32_t i=0 ; i&lt;UDATPG_FIELD_COUNT; ++i ) {
 412             if (appendItemFormats[i] != other.appendItemFormats[i]) {
 413                 return FALSE;
 414             }
 415             for (int32_t j=0; j&lt; UDATPG_WIDTH_COUNT; ++j ) {
 416                 if (fieldDisplayNames[i][j] != other.fieldDisplayNames[i][j]) {
 417                     return FALSE;
 418                 }
 419             }
 420         }
 421         return TRUE;
 422     }
 423     else {
 424         return FALSE;
 425     }
 426 }
 427 
 428 UBool
 429 DateTimePatternGenerator::operator!=(const DateTimePatternGenerator&amp; other) const {
 430     return  !operator==(other);
 431 }
 432 
 433 DateTimePatternGenerator::~DateTimePatternGenerator() {
 434     if (fAvailableFormatKeyHash!=NULL) {
 435         delete fAvailableFormatKeyHash;
 436     }
 437 
 438     if (fp != NULL) delete fp;
 439     if (dtMatcher != NULL) delete dtMatcher;
 440     if (distanceInfo != NULL) delete distanceInfo;
 441     if (patternMap != NULL) delete patternMap;
 442     if (skipMatcher != NULL) delete skipMatcher;
 443 }
 444 
 445 namespace {
 446 
 447 UInitOnce initOnce = U_INITONCE_INITIALIZER;
 448 UHashtable *localeToAllowedHourFormatsMap = NULL;
 449 
 450 // Value deleter for hashmap.
 451 U_CFUNC void U_CALLCONV deleteAllowedHourFormats(void *ptr) {
 452     uprv_free(ptr);
 453 }
 454 
 455 // Close hashmap at cleanup.
 456 U_CFUNC UBool U_CALLCONV allowedHourFormatsCleanup() {
 457     uhash_close(localeToAllowedHourFormatsMap);
 458     return TRUE;
 459 }
 460 
 461 enum AllowedHourFormat{
 462     ALLOWED_HOUR_FORMAT_UNKNOWN = -1,
 463     ALLOWED_HOUR_FORMAT_h,
 464     ALLOWED_HOUR_FORMAT_H,
 465     ALLOWED_HOUR_FORMAT_hb,
 466     ALLOWED_HOUR_FORMAT_Hb,
 467     ALLOWED_HOUR_FORMAT_hB,
 468     ALLOWED_HOUR_FORMAT_HB
 469 };
 470 
 471 }  // namespace
 472 
 473 void
 474 DateTimePatternGenerator::initData(const Locale&amp; locale, UErrorCode &amp;status) {
 475     //const char *baseLangName = locale.getBaseName(); // unused
 476 
 477     skipMatcher = NULL;
 478     fAvailableFormatKeyHash=NULL;
 479     addCanonicalItems(status);
 480     addICUPatterns(locale, status);
 481     addCLDRData(locale, status);
 482     setDateTimeFromCalendar(locale, status);
 483     setDecimalSymbols(locale, status);
 484     umtx_initOnce(initOnce, loadAllowedHourFormatsData, status);
 485     getAllowedHourFormats(locale, status);
 486 } // DateTimePatternGenerator::initData
 487 
 488 namespace {
 489 
 490 struct AllowedHourFormatsSink : public ResourceSink {
 491     // Initialize sub-sinks.
 492     AllowedHourFormatsSink() {}
 493     virtual ~AllowedHourFormatsSink();
 494 
 495     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,
 496                      UErrorCode &amp;errorCode) {
 497         ResourceTable timeData = value.getTable(errorCode);
 498         if (U_FAILURE(errorCode)) { return; }
 499         for (int32_t i = 0; timeData.getKeyAndValue(i, key, value); ++i) {
 500             const char *regionOrLocale = key;
 501             ResourceTable formatList = value.getTable(errorCode);
 502             if (U_FAILURE(errorCode)) { return; }
 503             for (int32_t j = 0; formatList.getKeyAndValue(j, key, value); ++j) {
 504                 if (uprv_strcmp(key, &quot;allowed&quot;) == 0) {  // Ignore &quot;preferred&quot; list.
 505                     LocalMemory&lt;int32_t&gt; list;
 506                     int32_t length;
 507                     if (value.getType() == URES_STRING) {
 508                         if (list.allocateInsteadAndReset(2) == NULL) {
 509                             errorCode = U_MEMORY_ALLOCATION_ERROR;
 510                             return;
 511                         }
 512                         list[0] = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));
 513                         length = 1;
 514                     }
 515                     else {
 516                         ResourceArray allowedFormats = value.getArray(errorCode);
 517                         length = allowedFormats.getSize();
 518                         if (list.allocateInsteadAndReset(length + 1) == NULL) {
 519                             errorCode = U_MEMORY_ALLOCATION_ERROR;
 520                             return;
 521                         }
 522                         for (int32_t k = 0; k &lt; length; ++k) {
 523                             allowedFormats.getValue(k, value);
 524                             list[k] = getHourFormatFromUnicodeString(value.getUnicodeString(errorCode));
 525                         }
 526                     }
 527                     list[length] = ALLOWED_HOUR_FORMAT_UNKNOWN;
 528                     uhash_put(localeToAllowedHourFormatsMap,
 529                               const_cast&lt;char *&gt;(regionOrLocale), list.orphan(), &amp;errorCode);
 530                     if (U_FAILURE(errorCode)) { return; }
 531                 }
 532             }
 533         }
 534     }
 535 
 536     AllowedHourFormat getHourFormatFromUnicodeString(const UnicodeString &amp;s) {
 537         if (s.length() == 1) {
 538             if (s[0] == LOW_H) { return ALLOWED_HOUR_FORMAT_h; }
 539             if (s[0] == CAP_H) { return ALLOWED_HOUR_FORMAT_H; }
 540         } else if (s.length() == 2) {
 541             if (s[0] == LOW_H &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_hb; }
 542             if (s[0] == CAP_H &amp;&amp; s[1] == LOW_B) { return ALLOWED_HOUR_FORMAT_Hb; }
 543             if (s[0] == LOW_H &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_hB; }
 544             if (s[0] == CAP_H &amp;&amp; s[1] == CAP_B) { return ALLOWED_HOUR_FORMAT_HB; }
 545         }
 546 
 547         return ALLOWED_HOUR_FORMAT_UNKNOWN;
 548     }
 549 };
 550 
 551 }  // namespace
 552 
 553 AllowedHourFormatsSink::~AllowedHourFormatsSink() {}
 554 
 555 U_CFUNC void U_CALLCONV DateTimePatternGenerator::loadAllowedHourFormatsData(UErrorCode &amp;status) {
 556     if (U_FAILURE(status)) { return; }
 557     localeToAllowedHourFormatsMap = uhash_open(
 558         uhash_hashChars, uhash_compareChars, NULL, &amp;status);
 559     uhash_setValueDeleter(localeToAllowedHourFormatsMap, deleteAllowedHourFormats);
 560     LocalUResourceBundlePointer rb(ures_openDirect(NULL, &quot;supplementalData&quot;, &amp;status));
 561 
 562     AllowedHourFormatsSink sink;
 563     // TODO: Currently in the enumeration each table allocates a new array.
 564     // Try to reduce the number of memory allocations. Consider storing a
 565     // UVector32 with the concatenation of all of the sub-arrays, put the start index
 566     // into the hashmap, store 6 single-value sub-arrays right at the beginning of the
 567     // vector (at index enum*2) for easy data sharing, copy sub-arrays into runtime
 568     // object. Remember to clean up the vector, too.
 569     ures_getAllItemsWithFallback(rb.getAlias(), &quot;timeData&quot;, sink, status);
 570 
 571     ucln_i18n_registerCleanup(UCLN_I18N_ALLOWED_HOUR_FORMATS, allowedHourFormatsCleanup);
 572 }
 573 
 574 void DateTimePatternGenerator::getAllowedHourFormats(const Locale &amp;locale, UErrorCode &amp;status) {
 575     if (U_FAILURE(status)) { return; }
 576     const char *localeID = locale.getName();
 577     char maxLocaleID[ULOC_FULLNAME_CAPACITY];
 578     int32_t length = uloc_addLikelySubtags(localeID, maxLocaleID, ULOC_FULLNAME_CAPACITY, &amp;status);
 579     if (U_FAILURE(status)) {
 580         return;
 581     } else if (length == ULOC_FULLNAME_CAPACITY) {  // no room for NUL
 582         status = U_BUFFER_OVERFLOW_ERROR;
 583         return;
 584     }
 585     Locale maxLocale = Locale(maxLocaleID);
 586 
 587     const char *country = maxLocale.getCountry();
 588     if (*country == &#39;\0&#39;) { country = &quot;001&quot;; }
 589     const char *language = maxLocale.getLanguage();
 590 
 591     CharString langCountry;
 592     langCountry.append(language, uprv_strlen(language), status);
 593     langCountry.append(&#39;_&#39;, status);
 594     langCountry.append(country, uprv_strlen(country), status);
 595 
 596     int32_t *allowedFormats;
 597     allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, langCountry.data());
 598     if (allowedFormats == NULL) {
 599         allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, const_cast&lt;char *&gt;(country));
 600     }
 601 
 602     if (allowedFormats != NULL) {  // Lookup is successful
 603         for (int32_t i = 0; i &lt; UPRV_LENGTHOF(fAllowedHourFormats); ++i) {
 604             fAllowedHourFormats[i] = allowedFormats[i];
 605             if (allowedFormats[i] == ALLOWED_HOUR_FORMAT_UNKNOWN) {
 606                 break;
 607             }
 608         }
 609     } else {  // Lookup failed, twice
 610         fAllowedHourFormats[0] = ALLOWED_HOUR_FORMAT_H;
 611         fAllowedHourFormats[1] = ALLOWED_HOUR_FORMAT_UNKNOWN;
 612     }
 613 }
 614 
 615 UnicodeString
 616 DateTimePatternGenerator::getSkeleton(const UnicodeString&amp; pattern, UErrorCode&amp;
 617 /*status*/) {
 618     FormatParser fp;
 619     DateTimeMatcher matcher;
 620     PtnSkeleton localSkeleton;
 621     matcher.set(pattern, &amp;fp, localSkeleton);
 622     return localSkeleton.getSkeleton();
 623 }
 624 
 625 UnicodeString
 626 DateTimePatternGenerator::staticGetSkeleton(
 627         const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
 628     FormatParser fp;
 629     DateTimeMatcher matcher;
 630     PtnSkeleton localSkeleton;
 631     matcher.set(pattern, &amp;fp, localSkeleton);
 632     return localSkeleton.getSkeleton();
 633 }
 634 
 635 UnicodeString
 636 DateTimePatternGenerator::getBaseSkeleton(const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
 637     FormatParser fp;
 638     DateTimeMatcher matcher;
 639     PtnSkeleton localSkeleton;
 640     matcher.set(pattern, &amp;fp, localSkeleton);
 641     return localSkeleton.getBaseSkeleton();
 642 }
 643 
 644 UnicodeString
 645 DateTimePatternGenerator::staticGetBaseSkeleton(
 646         const UnicodeString&amp; pattern, UErrorCode&amp; /*status*/) {
 647     FormatParser fp;
 648     DateTimeMatcher matcher;
 649     PtnSkeleton localSkeleton;
 650     matcher.set(pattern, &amp;fp, localSkeleton);
 651     return localSkeleton.getBaseSkeleton();
 652 }
 653 
 654 void
 655 DateTimePatternGenerator::addICUPatterns(const Locale&amp; locale, UErrorCode&amp; status) {
 656     if (U_FAILURE(status)) { return; }
 657     UnicodeString dfPattern;
 658     UnicodeString conflictingString;
 659     DateFormat* df;
 660 
 661     // Load with ICU patterns
 662     for (int32_t i=DateFormat::kFull; i&lt;=DateFormat::kShort; i++) {
 663         DateFormat::EStyle style = (DateFormat::EStyle)i;
 664         df = DateFormat::createDateInstance(style, locale);
 665         SimpleDateFormat* sdf;
 666         if (df != NULL &amp;&amp; (sdf = dynamic_cast&lt;SimpleDateFormat*&gt;(df)) != NULL) {
 667             sdf-&gt;toPattern(dfPattern);
 668             addPattern(dfPattern, FALSE, conflictingString, status);
 669         }
 670         // TODO Maybe we should return an error when the date format isn&#39;t simple.
 671         delete df;
 672         if (U_FAILURE(status)) { return; }
 673 
 674         df = DateFormat::createTimeInstance(style, locale);
 675         if (df != NULL &amp;&amp; (sdf = dynamic_cast&lt;SimpleDateFormat*&gt;(df)) != NULL) {
 676             sdf-&gt;toPattern(dfPattern);
 677             addPattern(dfPattern, FALSE, conflictingString, status);
 678 
 679             // TODO: C++ and Java are inconsistent (see #12568).
 680             // C++ uses MEDIUM, but Java uses SHORT.
 681             if ( i==DateFormat::kShort &amp;&amp; !dfPattern.isEmpty() ) {
 682                 consumeShortTimePattern(dfPattern, status);
 683             }
 684         }
 685         // TODO Maybe we should return an error when the date format isn&#39;t simple.
 686         delete df;
 687         if (U_FAILURE(status)) { return; }
 688     }
 689 }
 690 
 691 void
 692 DateTimePatternGenerator::hackTimes(const UnicodeString&amp; hackPattern, UErrorCode&amp; status)  {
 693     UnicodeString conflictingString;
 694 
 695     fp-&gt;set(hackPattern);
 696     UnicodeString mmss;
 697     UBool gotMm=FALSE;
 698     for (int32_t i=0; i&lt;fp-&gt;itemNumber; ++i) {
 699         UnicodeString field = fp-&gt;items[i];
 700         if ( fp-&gt;isQuoteLiteral(field) ) {
 701             if ( gotMm ) {
 702                UnicodeString quoteLiteral;
 703                fp-&gt;getQuoteLiteral(quoteLiteral, &amp;i);
 704                mmss += quoteLiteral;
 705             }
 706         }
 707         else {
 708             if (fp-&gt;isPatternSeparator(field) &amp;&amp; gotMm) {
 709                 mmss+=field;
 710             }
 711             else {
 712                 UChar ch=field.charAt(0);
 713                 if (ch==LOW_M) {
 714                     gotMm=TRUE;
 715                     mmss+=field;
 716                 }
 717                 else {
 718                     if (ch==LOW_S) {
 719                         if (!gotMm) {
 720                             break;
 721                         }
 722                         mmss+= field;
 723                         addPattern(mmss, FALSE, conflictingString, status);
 724                         break;
 725                     }
 726                     else {
 727                         if (gotMm || ch==LOW_Z || ch==CAP_Z || ch==LOW_V || ch==CAP_V) {
 728                             break;
 729                         }
 730                     }
 731                 }
 732             }
 733         }
 734     }
 735 }
 736 
 737 #define ULOC_LOCALE_IDENTIFIER_CAPACITY (ULOC_FULLNAME_CAPACITY + 1 + ULOC_KEYWORD_AND_VALUES_CAPACITY)
 738 
 739 static const UChar hourFormatChars[] = { CAP_H, LOW_H, CAP_K, LOW_K, 0 }; // HhKk, the hour format characters
 740 
 741 void
 742 DateTimePatternGenerator::getCalendarTypeToUse(const Locale&amp; locale, CharString&amp; destination, UErrorCode&amp; err) {
 743     destination.clear().append(DT_DateTimeGregorianTag, -1, err); // initial default
 744     if ( U_SUCCESS(err) ) {
 745         char localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY];
 746         // obtain a locale that always has the calendar key value that should be used
 747         ures_getFunctionalEquivalent(
 748             localeWithCalendarKey,
 749             ULOC_LOCALE_IDENTIFIER_CAPACITY,
 750             NULL,
 751             &quot;calendar&quot;,
 752             &quot;calendar&quot;,
 753             locale.getName(),
 754             NULL,
 755             FALSE,
 756             &amp;err);
 757         localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY-1] = 0; // ensure null termination
 758         // now get the calendar key value from that locale
 759         char calendarType[ULOC_KEYWORDS_CAPACITY];
 760         int32_t calendarTypeLen = uloc_getKeywordValue(
 761             localeWithCalendarKey,
 762             &quot;calendar&quot;,
 763             calendarType,
 764             ULOC_KEYWORDS_CAPACITY,
 765             &amp;err);
 766         if (U_SUCCESS(err) &amp;&amp; calendarTypeLen &lt; ULOC_KEYWORDS_CAPACITY) {
 767             destination.clear().append(calendarType, -1, err);
 768             if (U_FAILURE(err)) { return; }
 769         }
 770         err = U_ZERO_ERROR;
 771     }
 772 }
 773 
 774 void
 775 DateTimePatternGenerator::consumeShortTimePattern(const UnicodeString&amp; shortTimePattern,
 776         UErrorCode&amp; status) {
 777 
 778     // set fDefaultHourFormatChar to the hour format character from this pattern
 779     int32_t tfIdx, tfLen = shortTimePattern.length();
 780     UBool ignoreChars = FALSE;
 781     for (tfIdx = 0; tfIdx &lt; tfLen; tfIdx++) {
 782         UChar tfChar = shortTimePattern.charAt(tfIdx);
 783         if ( tfChar == SINGLE_QUOTE ) {
 784             ignoreChars = !ignoreChars; // toggle (handle quoted literals &amp; &#39;&#39; for single quote)
 785         } else if ( !ignoreChars &amp;&amp; u_strchr(hourFormatChars, tfChar) != NULL ) {
 786             fDefaultHourFormatChar = tfChar;
 787             break;
 788         }
 789     }
 790 
 791     // HACK for hh:ss
 792     hackTimes(shortTimePattern, status);
 793 }
 794 
 795 struct DateTimePatternGenerator::AppendItemFormatsSink : public ResourceSink {
 796 
 797     // Destination for data, modified via setters.
 798     DateTimePatternGenerator&amp; dtpg;
 799 
 800     AppendItemFormatsSink(DateTimePatternGenerator&amp; _dtpg) : dtpg(_dtpg) {}
 801     virtual ~AppendItemFormatsSink();
 802 
 803     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,
 804             UErrorCode &amp;errorCode) {
 805         ResourceTable itemsTable = value.getTable(errorCode);
 806         if (U_FAILURE(errorCode)) { return; }
 807         for (int32_t i = 0; itemsTable.getKeyAndValue(i, key, value); ++i) {
 808             UDateTimePatternField field = dtpg.getAppendFormatNumber(key);
 809             if (field == UDATPG_FIELD_COUNT) { continue; }
 810             const UnicodeString&amp; valueStr = value.getUnicodeString(errorCode);
 811             if (dtpg.getAppendItemFormat(field).isEmpty() &amp;&amp; !valueStr.isEmpty()) {
 812                 dtpg.setAppendItemFormat(field, valueStr);
 813             }
 814         }
 815     }
 816 
 817     void fillInMissing() {
 818         UnicodeString defaultItemFormat(TRUE, UDATPG_ItemFormat, UPRV_LENGTHOF(UDATPG_ItemFormat)-1);  // Read-only alias.
 819         for (int32_t i = 0; i &lt; UDATPG_FIELD_COUNT; i++) {
 820             UDateTimePatternField field = (UDateTimePatternField)i;
 821             if (dtpg.getAppendItemFormat(field).isEmpty()) {
 822                 dtpg.setAppendItemFormat(field, defaultItemFormat);
 823             }
 824         }
 825     }
 826 };
 827 
 828 struct DateTimePatternGenerator::AppendItemNamesSink : public ResourceSink {
 829 
 830     // Destination for data, modified via setters.
 831     DateTimePatternGenerator&amp; dtpg;
 832 
 833     AppendItemNamesSink(DateTimePatternGenerator&amp; _dtpg) : dtpg(_dtpg) {}
 834     virtual ~AppendItemNamesSink();
 835 
 836     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,
 837             UErrorCode &amp;errorCode) {
 838         ResourceTable itemsTable = value.getTable(errorCode);
 839         if (U_FAILURE(errorCode)) { return; }
 840         for (int32_t i = 0; itemsTable.getKeyAndValue(i, key, value); ++i) {
 841             UDateTimePGDisplayWidth width;
 842             UDateTimePatternField field = dtpg.getFieldAndWidthIndices(key, &amp;width);
 843             if (field == UDATPG_FIELD_COUNT) { continue; }
 844             ResourceTable detailsTable = value.getTable(errorCode);
 845             if (U_FAILURE(errorCode)) { return; }
 846             for (int32_t j = 0; detailsTable.getKeyAndValue(j, key, value); ++j) {
 847                 if (uprv_strcmp(key, &quot;dn&quot;) != 0) { continue; }
 848                 const UnicodeString&amp; valueStr = value.getUnicodeString(errorCode);
 849                 if (dtpg.getFieldDisplayName(field,width).isEmpty() &amp;&amp; !valueStr.isEmpty()) {
 850                     dtpg.setFieldDisplayName(field,width,valueStr);
 851                 }
 852                 break;
 853             }
 854         }
 855     }
 856 
 857     void fillInMissing() {
 858         for (int32_t i = 0; i &lt; UDATPG_FIELD_COUNT; i++) {
 859             UnicodeString&amp; valueStr = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, UDATPG_WIDE);
 860             if (valueStr.isEmpty()) {
 861                 valueStr = CAP_F;
 862                 U_ASSERT(i &lt; 20);
 863                 if (i &lt; 10) {
 864                     // F0, F1, ..., F9
 865                     valueStr += (UChar)(i+0x30);
 866                 } else {
 867                     // F10, F11, ...
 868                     valueStr += (UChar)0x31;
 869                     valueStr += (UChar)(i-10 + 0x30);
 870                 }
 871                 // NUL-terminate for the C API.
 872                 valueStr.getTerminatedBuffer();
 873             }
 874             for (int32_t j = 1; j &lt; UDATPG_WIDTH_COUNT; j++) {
 875                 UnicodeString&amp; valueStr = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)j);
 876                 if (valueStr.isEmpty()) {
 877                     valueStr = dtpg.getFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)(j-1));
 878                 }
 879             }
 880         }
 881     }
 882 };
 883 
 884 struct DateTimePatternGenerator::AvailableFormatsSink : public ResourceSink {
 885 
 886     // Destination for data, modified via setters.
 887     DateTimePatternGenerator&amp; dtpg;
 888 
 889     // Temporary variable, required for calling addPatternWithSkeleton.
 890     UnicodeString conflictingPattern;
 891 
 892     AvailableFormatsSink(DateTimePatternGenerator&amp; _dtpg) : dtpg(_dtpg) {}
 893     virtual ~AvailableFormatsSink();
 894 
 895     virtual void put(const char *key, ResourceValue &amp;value, UBool isRoot,
 896             UErrorCode &amp;errorCode) {
 897         ResourceTable itemsTable = value.getTable(errorCode);
 898         if (U_FAILURE(errorCode)) { return; }
 899         for (int32_t i = 0; itemsTable.getKeyAndValue(i, key, value); ++i) {
 900             const UnicodeString formatKey(key, -1, US_INV);
 901             if (!dtpg.isAvailableFormatSet(formatKey) ) {
 902                 dtpg.setAvailableFormat(formatKey, errorCode);
 903                 // Add pattern with its associated skeleton. Override any duplicate
 904                 // derived from std patterns, but not a previous availableFormats entry:
 905                 const UnicodeString&amp; formatValue = value.getUnicodeString(errorCode);
 906                 conflictingPattern.remove();
 907                 dtpg.addPatternWithSkeleton(formatValue, &amp;formatKey, !isRoot, conflictingPattern, errorCode);
 908             }
 909         }
 910     }
 911 };
 912 
 913 // Virtual destructors must be defined out of line.
 914 DateTimePatternGenerator::AppendItemFormatsSink::~AppendItemFormatsSink() {}
 915 DateTimePatternGenerator::AppendItemNamesSink::~AppendItemNamesSink() {}
 916 DateTimePatternGenerator::AvailableFormatsSink::~AvailableFormatsSink() {}
 917 
 918 void
 919 DateTimePatternGenerator::addCLDRData(const Locale&amp; locale, UErrorCode&amp; errorCode) {
 920     if (U_FAILURE(errorCode)) { return; }
 921     UnicodeString rbPattern, value, field;
 922     CharString path;
 923 
 924     LocalUResourceBundlePointer rb(ures_open(NULL, locale.getName(), &amp;errorCode));
 925     if (U_FAILURE(errorCode)) { return; }
 926 
 927     CharString calendarTypeToUse; // to be filled in with the type to use, if all goes well
 928     getCalendarTypeToUse(locale, calendarTypeToUse, errorCode);
 929     if (U_FAILURE(errorCode)) { return; }
 930 
 931     // Local err to ignore resource not found exceptions
 932     UErrorCode err = U_ZERO_ERROR;
 933 
 934     // Load append item formats.
 935     AppendItemFormatsSink appendItemFormatsSink(*this);
 936     path.clear()
 937         .append(DT_DateTimeCalendarTag, errorCode)
 938         .append(&#39;/&#39;, errorCode)
 939         .append(calendarTypeToUse, errorCode)
 940         .append(&#39;/&#39;, errorCode)
 941         .append(DT_DateTimeAppendItemsTag, errorCode); // i.e., calendar/xxx/appendItems
 942     if (U_FAILURE(errorCode)) { return; }
 943     ures_getAllItemsWithFallback(rb.getAlias(), path.data(), appendItemFormatsSink, err);
 944     appendItemFormatsSink.fillInMissing();
 945 
 946     // Load CLDR item names.
 947     err = U_ZERO_ERROR;
 948     AppendItemNamesSink appendItemNamesSink(*this);
 949     ures_getAllItemsWithFallback(rb.getAlias(), DT_DateTimeFieldsTag, appendItemNamesSink, err);
 950     appendItemNamesSink.fillInMissing();
 951 
 952     // Load the available formats from CLDR.
 953     err = U_ZERO_ERROR;
 954     initHashtable(errorCode);
 955     if (U_FAILURE(errorCode)) { return; }
 956     AvailableFormatsSink availableFormatsSink(*this);
 957     path.clear()
 958         .append(DT_DateTimeCalendarTag, errorCode)
 959         .append(&#39;/&#39;, errorCode)
 960         .append(calendarTypeToUse, errorCode)
 961         .append(&#39;/&#39;, errorCode)
 962         .append(DT_DateTimeAvailableFormatsTag, errorCode); // i.e., calendar/xxx/availableFormats
 963     if (U_FAILURE(errorCode)) { return; }
 964     ures_getAllItemsWithFallback(rb.getAlias(), path.data(), availableFormatsSink, err);
 965 }
 966 
 967 void
 968 DateTimePatternGenerator::initHashtable(UErrorCode&amp; err) {
 969     if (fAvailableFormatKeyHash!=NULL) {
 970         return;
 971     }
 972     if ((fAvailableFormatKeyHash = new Hashtable(FALSE, err))==NULL) {
 973         err=U_MEMORY_ALLOCATION_ERROR;
 974         return;
 975     }
 976 }
 977 
 978 void
 979 DateTimePatternGenerator::setAppendItemFormat(UDateTimePatternField field, const UnicodeString&amp; value) {
 980     appendItemFormats[field] = value;
 981     // NUL-terminate for the C API.
 982     appendItemFormats[field].getTerminatedBuffer();
 983 }
 984 
 985 const UnicodeString&amp;
 986 DateTimePatternGenerator::getAppendItemFormat(UDateTimePatternField field) const {
 987     return appendItemFormats[field];
 988 }
 989 
 990 void
 991 DateTimePatternGenerator::setAppendItemName(UDateTimePatternField field, const UnicodeString&amp; value) {
 992     setFieldDisplayName(field, UDATPG_WIDTH_APPENDITEM, value);
 993 }
 994 
 995 const UnicodeString&amp;
 996 DateTimePatternGenerator::getAppendItemName(UDateTimePatternField field) const {
 997     return fieldDisplayNames[field][UDATPG_WIDTH_APPENDITEM];
 998 }
 999 
1000 void
1001 DateTimePatternGenerator::setFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width, const UnicodeString&amp; value) {
1002     fieldDisplayNames[field][width] = value;
1003     // NUL-terminate for the C API.
1004     fieldDisplayNames[field][width].getTerminatedBuffer();
1005 }
1006 
1007 UnicodeString
1008 DateTimePatternGenerator::getFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width) const {
1009     return fieldDisplayNames[field][width];
1010 }
1011 
1012 UnicodeString&amp;
1013 DateTimePatternGenerator::getMutableFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width) {
1014     return fieldDisplayNames[field][width];
1015 }
1016 
1017 void
1018 DateTimePatternGenerator::getAppendName(UDateTimePatternField field, UnicodeString&amp; value) {
1019     value = SINGLE_QUOTE;
1020     value += fieldDisplayNames[field][UDATPG_WIDTH_APPENDITEM];
1021     value += SINGLE_QUOTE;
1022 }
1023 
1024 UnicodeString
1025 DateTimePatternGenerator::getBestPattern(const UnicodeString&amp; patternForm, UErrorCode&amp; status) {
1026     return getBestPattern(patternForm, UDATPG_MATCH_NO_OPTIONS, status);
1027 }
1028 
1029 UnicodeString
1030 DateTimePatternGenerator::getBestPattern(const UnicodeString&amp; patternForm, UDateTimePatternMatchOptions options, UErrorCode&amp; status) {
1031     const UnicodeString *bestPattern=NULL;
1032     UnicodeString dtFormat;
1033     UnicodeString resultPattern;
1034     int32_t flags = kDTPGNoFlags;
1035 
1036     int32_t dateMask=(1&lt;&lt;UDATPG_DAYPERIOD_FIELD) - 1;
1037     int32_t timeMask=(1&lt;&lt;UDATPG_FIELD_COUNT) - 1 - dateMask;
1038 
1039     // Replace hour metacharacters &#39;j&#39;, &#39;C&#39; and &#39;J&#39;, set flags as necessary
1040     UnicodeString patternFormMapped = mapSkeletonMetacharacters(patternForm, &amp;flags, status);
1041     if (U_FAILURE(status)) {
1042         return UnicodeString();
1043     }
1044 
1045     resultPattern.remove();
1046     dtMatcher-&gt;set(patternFormMapped, fp);
1047     const PtnSkeleton* specifiedSkeleton=NULL;
1048     bestPattern=getBestRaw(*dtMatcher, -1, distanceInfo, &amp;specifiedSkeleton);
1049     if ( distanceInfo-&gt;missingFieldMask==0 &amp;&amp; distanceInfo-&gt;extraFieldMask==0 ) {
1050         resultPattern = adjustFieldTypes(*bestPattern, specifiedSkeleton, flags, options);
1051 
1052         return resultPattern;
1053     }
1054     int32_t neededFields = dtMatcher-&gt;getFieldMask();
1055     UnicodeString datePattern=getBestAppending(neededFields &amp; dateMask, flags, options);
1056     UnicodeString timePattern=getBestAppending(neededFields &amp; timeMask, flags, options);
1057     if (datePattern.length()==0) {
1058         if (timePattern.length()==0) {
1059             resultPattern.remove();
1060         }
1061         else {
1062             return timePattern;
1063         }
1064     }
1065     if (timePattern.length()==0) {
1066         return datePattern;
1067     }
1068     resultPattern.remove();
1069     status = U_ZERO_ERROR;
1070     dtFormat=getDateTimeFormat();
1071     SimpleFormatter(dtFormat, 2, 2, status).format(timePattern, datePattern, resultPattern, status);
1072     return resultPattern;
1073 }
1074 
1075 /*
1076  * Map a skeleton that may have metacharacters jJC to one without, by replacing
1077  * the metacharacters with locale-appropriate fields of of h/H/k/K and of a/b/B
1078  * (depends on fDefaultHourFormatChar and fAllowedHourFormats being set, which in
1079  * turn depends on initData having been run). This method also updates the flags
1080  * as necessary. Returns the updated skeleton.
1081  */
1082 UnicodeString
1083 DateTimePatternGenerator::mapSkeletonMetacharacters(const UnicodeString&amp; patternForm, int32_t* flags, UErrorCode&amp; status) {
1084     UnicodeString patternFormMapped;
1085     patternFormMapped.remove();
1086     UBool inQuoted = FALSE;
1087     int32_t patPos, patLen = patternForm.length();
1088     for (patPos = 0; patPos &lt; patLen; patPos++) {
1089         UChar patChr = patternForm.charAt(patPos);
1090         if (patChr == SINGLE_QUOTE) {
1091             inQuoted = !inQuoted;
1092         } else if (!inQuoted) {
1093             // Handle special mappings for &#39;j&#39; and &#39;C&#39; in which fields lengths
1094             // 1,3,5 =&gt; hour field length 1
1095             // 2,4,6 =&gt; hour field length 2
1096             // 1,2 =&gt; abbreviated dayPeriod (field length 1..3)
1097             // 3,4 =&gt; long dayPeriod (field length 4)
1098             // 5,6 =&gt; narrow dayPeriod (field length 5)
1099             if (patChr == LOW_J || patChr == CAP_C) {
1100                 int32_t extraLen = 0; // 1 less than total field length
1101                 while (patPos+1 &lt; patLen &amp;&amp; patternForm.charAt(patPos+1)==patChr) {
1102                     extraLen++;
1103                     patPos++;
1104                 }
1105                 int32_t hourLen = 1 + (extraLen &amp; 1);
1106                 int32_t dayPeriodLen = (extraLen &lt; 2)? 1: 3 + (extraLen &gt;&gt; 1);
1107                 UChar hourChar = LOW_H;
1108                 UChar dayPeriodChar = LOW_A;
1109                 if (patChr == LOW_J) {
1110                     hourChar = fDefaultHourFormatChar;
1111                 } else {
1112                     AllowedHourFormat preferred;
1113                     if (fAllowedHourFormats[0] != ALLOWED_HOUR_FORMAT_UNKNOWN) {
1114                         preferred = (AllowedHourFormat)fAllowedHourFormats[0];
1115                     } else {
1116                         status = U_INVALID_FORMAT_ERROR;
1117                         return UnicodeString();
1118                     }
1119                     if (preferred == ALLOWED_HOUR_FORMAT_H || preferred == ALLOWED_HOUR_FORMAT_HB || preferred == ALLOWED_HOUR_FORMAT_Hb) {
1120                         hourChar = CAP_H;
1121                     }
1122                     // in #13183 just add b/B to skeleton, no longer need to set special flags
1123                     if (preferred == ALLOWED_HOUR_FORMAT_HB || preferred == ALLOWED_HOUR_FORMAT_hB) {
1124                         dayPeriodChar = CAP_B;
1125                     } else if (preferred == ALLOWED_HOUR_FORMAT_Hb || preferred == ALLOWED_HOUR_FORMAT_hb) {
1126                         dayPeriodChar = LOW_B;
1127                     }
1128                 }
1129                 if (hourChar==CAP_H || hourChar==LOW_K) {
1130                     dayPeriodLen = 0;
1131                 }
1132                 while (dayPeriodLen-- &gt; 0) {
1133                     patternFormMapped.append(dayPeriodChar);
1134                 }
1135                 while (hourLen-- &gt; 0) {
1136                     patternFormMapped.append(hourChar);
1137                 }
1138             } else if (patChr == CAP_J) {
1139                 // Get pattern for skeleton with H, then replace H or k
1140                 // with fDefaultHourFormatChar (if different)
1141                 patternFormMapped.append(CAP_H);
1142                 *flags |= kDTPGSkeletonUsesCapJ;
1143             } else {
1144                 patternFormMapped.append(patChr);
1145             }
1146         }
1147     }
1148     return patternFormMapped;
1149 }
1150 
1151 UnicodeString
1152 DateTimePatternGenerator::replaceFieldTypes(const UnicodeString&amp; pattern,
1153                                             const UnicodeString&amp; skeleton,
1154                                             UErrorCode&amp; status) {
1155     return replaceFieldTypes(pattern, skeleton, UDATPG_MATCH_NO_OPTIONS, status);
1156 }
1157 
1158 UnicodeString
1159 DateTimePatternGenerator::replaceFieldTypes(const UnicodeString&amp; pattern,
1160                                             const UnicodeString&amp; skeleton,
1161                                             UDateTimePatternMatchOptions options,
1162                                             UErrorCode&amp; /*status*/) {
1163     dtMatcher-&gt;set(skeleton, fp);
1164     UnicodeString result = adjustFieldTypes(pattern, NULL, kDTPGNoFlags, options);
1165     return result;
1166 }
1167 
1168 void
1169 DateTimePatternGenerator::setDecimal(const UnicodeString&amp; newDecimal) {
1170     this-&gt;decimal = newDecimal;
1171     // NUL-terminate for the C API.
1172     this-&gt;decimal.getTerminatedBuffer();
1173 }
1174 
1175 const UnicodeString&amp;
1176 DateTimePatternGenerator::getDecimal() const {
1177     return decimal;
1178 }
1179 
1180 void
1181 DateTimePatternGenerator::addCanonicalItems(UErrorCode&amp; status) {
1182     if (U_FAILURE(status)) { return; }
1183     UnicodeString  conflictingPattern;
1184 
1185     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; i++) {
1186         if (Canonical_Items[i] &gt; 0) {
1187             addPattern(UnicodeString(Canonical_Items[i]), FALSE, conflictingPattern, status);
1188         }
1189         if (U_FAILURE(status)) { return; }
1190     }
1191 }
1192 
1193 void
1194 DateTimePatternGenerator::setDateTimeFormat(const UnicodeString&amp; dtFormat) {
1195     dateTimeFormat = dtFormat;
1196     // NUL-terminate for the C API.
1197     dateTimeFormat.getTerminatedBuffer();
1198 }
1199 
1200 const UnicodeString&amp;
1201 DateTimePatternGenerator::getDateTimeFormat() const {
1202     return dateTimeFormat;
1203 }
1204 
1205 void
1206 DateTimePatternGenerator::setDateTimeFromCalendar(const Locale&amp; locale, UErrorCode&amp; status) {
1207     const UChar *resStr;
1208     int32_t resStrLen = 0;
1209 
1210     Calendar* fCalendar = Calendar::createInstance(locale, status);
1211     if (U_FAILURE(status)) { return; }
1212 
1213     LocalUResourceBundlePointer calData(ures_open(NULL, locale.getBaseName(), &amp;status));
1214     ures_getByKey(calData.getAlias(), DT_DateTimeCalendarTag, calData.getAlias(), &amp;status);
1215 
1216     LocalUResourceBundlePointer dateTimePatterns;
1217     if (fCalendar != NULL &amp;&amp; fCalendar-&gt;getType() != NULL &amp;&amp; *fCalendar-&gt;getType() != &#39;\0&#39;
1218             &amp;&amp; uprv_strcmp(fCalendar-&gt;getType(), DT_DateTimeGregorianTag) != 0) {
1219         dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), fCalendar-&gt;getType(),
1220                                                                 NULL, &amp;status));
1221         ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,
1222                                   dateTimePatterns.getAlias(), &amp;status);
1223     }
1224 
1225     if (dateTimePatterns.isNull() || status == U_MISSING_RESOURCE_ERROR) {
1226         status = U_ZERO_ERROR;
1227         dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), DT_DateTimeGregorianTag,
1228                                                                 dateTimePatterns.orphan(), &amp;status));
1229         ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,
1230                                   dateTimePatterns.getAlias(), &amp;status);
1231     }
1232     if (U_FAILURE(status)) { return; }
1233 
1234     if (ures_getSize(dateTimePatterns.getAlias()) &lt;= DateFormat::kDateTime)
1235     {
1236         status = U_INVALID_FORMAT_ERROR;
1237         return;
1238     }
1239     resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), (int32_t)DateFormat::kDateTime, &amp;resStrLen, &amp;status);
1240     setDateTimeFormat(UnicodeString(TRUE, resStr, resStrLen));
1241 
1242     delete fCalendar;
1243 }
1244 
1245 void
1246 DateTimePatternGenerator::setDecimalSymbols(const Locale&amp; locale, UErrorCode&amp; status) {
1247     DecimalFormatSymbols dfs = DecimalFormatSymbols(locale, status);
1248     if(U_SUCCESS(status)) {
1249         decimal = dfs.getSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol);
1250         // NUL-terminate for the C API.
1251         decimal.getTerminatedBuffer();
1252     }
1253 }
1254 
1255 UDateTimePatternConflict
1256 DateTimePatternGenerator::addPattern(
1257     const UnicodeString&amp; pattern,
1258     UBool override,
1259     UnicodeString &amp;conflictingPattern,
1260     UErrorCode&amp; status)
1261 {
1262     return addPatternWithSkeleton(pattern, NULL, override, conflictingPattern, status);
1263 }
1264 
1265 // For DateTimePatternGenerator::addPatternWithSkeleton -
1266 // If skeletonToUse is specified, then an availableFormats entry is being added. In this case:
1267 // 1. We pass that skeleton to matcher.set instead of having it derive a skeleton from the pattern.
1268 // 2. If the new entry&#39;s skeleton or basePattern does match an existing entry but that entry also had a skeleton specified
1269 // (i.e. it was also from availableFormats), then the new entry does not override it regardless of the value of the override
1270 // parameter. This prevents later availableFormats entries from a parent locale overriding earlier ones from the actual
1271 // specified locale. However, availableFormats entries *should* override entries with matching skeleton whose skeleton was
1272 // derived (i.e. entries derived from the standard date/time patters for the specified locale).
1273 // 3. When adding the pattern (patternMap-&gt;add), we set a new boolean to indicate that the added entry had a
1274 // specified skeleton (which sets a new field in the PtnElem in the PatternMap).
1275 UDateTimePatternConflict
1276 DateTimePatternGenerator::addPatternWithSkeleton(
1277     const UnicodeString&amp; pattern,
1278     const UnicodeString* skeletonToUse,
1279     UBool override,
1280     UnicodeString&amp; conflictingPattern,
1281     UErrorCode&amp; status)
1282 {
1283 
1284     UnicodeString basePattern;
1285     PtnSkeleton   skeleton;
1286     UDateTimePatternConflict conflictingStatus = UDATPG_NO_CONFLICT;
1287 
1288     DateTimeMatcher matcher;
1289     if ( skeletonToUse == NULL ) {
1290         matcher.set(pattern, fp, skeleton);
1291         matcher.getBasePattern(basePattern);
1292     } else {
1293         matcher.set(*skeletonToUse, fp, skeleton); // no longer trims skeleton fields to max len 3, per #7930
1294         matcher.getBasePattern(basePattern); // or perhaps instead: basePattern = *skeletonToUse;
1295     }
1296     // We only care about base conflicts - and replacing the pattern associated with a base - if:
1297     // 1. the conflicting previous base pattern did *not* have an explicit skeleton; in that case the previous
1298     // base + pattern combination was derived from either (a) a canonical item, (b) a standard format, or
1299     // (c) a pattern specified programmatically with a previous call to addPattern (which would only happen
1300     // if we are getting here from a subsequent call to addPattern).
1301     // 2. a skeleton is specified for the current pattern, but override=false; in that case we are checking
1302     // availableFormats items from root, which should not override any previous entry with the same base.
1303     UBool entryHadSpecifiedSkeleton;
1304     const UnicodeString *duplicatePattern = patternMap-&gt;getPatternFromBasePattern(basePattern, entryHadSpecifiedSkeleton);
1305     if (duplicatePattern != NULL &amp;&amp; (!entryHadSpecifiedSkeleton || (skeletonToUse != NULL &amp;&amp; !override))) {
1306         conflictingStatus = UDATPG_BASE_CONFLICT;
1307         conflictingPattern = *duplicatePattern;
1308         if (!override) {
1309             return conflictingStatus;
1310         }
1311     }
1312     // The only time we get here with override=true and skeletonToUse!=null is when adding availableFormats
1313     // items from CLDR data. In that case, we don&#39;t want an item from a parent locale to replace an item with
1314     // same skeleton from the specified locale, so skip the current item if skeletonWasSpecified is true for
1315     // the previously-specified conflicting item.
1316     const PtnSkeleton* entrySpecifiedSkeleton = NULL;
1317     duplicatePattern = patternMap-&gt;getPatternFromSkeleton(skeleton, &amp;entrySpecifiedSkeleton);
1318     if (duplicatePattern != NULL ) {
1319         conflictingStatus = UDATPG_CONFLICT;
1320         conflictingPattern = *duplicatePattern;
1321         if (!override || (skeletonToUse != NULL &amp;&amp; entrySpecifiedSkeleton != NULL)) {
1322             return conflictingStatus;
1323         }
1324     }
1325     patternMap-&gt;add(basePattern, skeleton, pattern, skeletonToUse != NULL, status);
1326     if(U_FAILURE(status)) {
1327         return conflictingStatus;
1328     }
1329 
1330     return UDATPG_NO_CONFLICT;
1331 }
1332 
1333 
1334 UDateTimePatternField
1335 DateTimePatternGenerator::getAppendFormatNumber(const char* field) const {
1336     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
1337         if (uprv_strcmp(CLDR_FIELD_APPEND[i], field)==0) {
1338             return (UDateTimePatternField)i;
1339         }
1340     }
1341     return UDATPG_FIELD_COUNT;
1342 }
1343 
1344 UDateTimePatternField
1345 DateTimePatternGenerator::getFieldAndWidthIndices(const char* key, UDateTimePGDisplayWidth* widthP) const {
1346     char cldrFieldKey[UDATPG_FIELD_KEY_MAX + 1];
1347     uprv_strncpy(cldrFieldKey, key, UDATPG_FIELD_KEY_MAX);
1348     cldrFieldKey[UDATPG_FIELD_KEY_MAX]=0; // ensure termination
1349     *widthP = UDATPG_WIDE;
1350     char* hyphenPtr = uprv_strchr(cldrFieldKey, &#39;-&#39;);
1351     if (hyphenPtr) {
1352         for (int32_t i=UDATPG_WIDTH_COUNT-1; i&gt;0; --i) {
1353             if (uprv_strcmp(CLDR_FIELD_WIDTH[i], hyphenPtr)==0) {
1354                 *widthP=(UDateTimePGDisplayWidth)i;
1355                 break;
1356             }
1357         }
1358         *hyphenPtr = 0; // now delete width portion of key
1359     }
1360     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
1361         if (uprv_strcmp(CLDR_FIELD_NAME[i],cldrFieldKey)==0) {
1362             return (UDateTimePatternField)i;
1363         }
1364     }
1365     return UDATPG_FIELD_COUNT;
1366 }
1367 
1368 const UnicodeString*
1369 DateTimePatternGenerator::getBestRaw(DateTimeMatcher&amp; source,
1370                                      int32_t includeMask,
1371                                      DistanceInfo* missingFields,
1372                                      const PtnSkeleton** specifiedSkeletonPtr) {
1373     int32_t bestDistance = 0x7fffffff;
1374     DistanceInfo tempInfo;
1375     const UnicodeString *bestPattern=NULL;
1376     const PtnSkeleton* specifiedSkeleton=NULL;
1377 
1378     PatternMapIterator it;
1379     for (it.set(*patternMap); it.hasNext(); ) {
1380         DateTimeMatcher trial = it.next();
1381         if (trial.equals(skipMatcher)) {
1382             continue;
1383         }
1384         int32_t distance=source.getDistance(trial, includeMask, tempInfo);
1385         if (distance&lt;bestDistance) {
1386             bestDistance=distance;
1387             bestPattern=patternMap-&gt;getPatternFromSkeleton(*trial.getSkeletonPtr(), &amp;specifiedSkeleton);
1388             missingFields-&gt;setTo(tempInfo);
1389             if (distance==0) {
1390                 break;
1391             }
1392         }
1393     }
1394 
1395     // If the best raw match had a specified skeleton and that skeleton was requested by the caller,
1396     // then return it too. This generally happens when the caller needs to pass that skeleton
1397     // through to adjustFieldTypes so the latter can do a better job.
1398     if (bestPattern &amp;&amp; specifiedSkeletonPtr) {
1399         *specifiedSkeletonPtr = specifiedSkeleton;
1400     }
1401     return bestPattern;
1402 }
1403 
1404 UnicodeString
1405 DateTimePatternGenerator::adjustFieldTypes(const UnicodeString&amp; pattern,
1406                                            const PtnSkeleton* specifiedSkeleton,
1407                                            int32_t flags,
1408                                            UDateTimePatternMatchOptions options) {
1409     UnicodeString newPattern;
1410     fp-&gt;set(pattern);
1411     for (int32_t i=0; i &lt; fp-&gt;itemNumber; i++) {
1412         UnicodeString field = fp-&gt;items[i];
1413         if ( fp-&gt;isQuoteLiteral(field) ) {
1414 
1415             UnicodeString quoteLiteral;
1416             fp-&gt;getQuoteLiteral(quoteLiteral, &amp;i);
1417             newPattern += quoteLiteral;
1418         }
1419         else {
1420             if (fp-&gt;isPatternSeparator(field)) {
1421                 newPattern+=field;
1422                 continue;
1423             }
1424             int32_t canonicalIndex = fp-&gt;getCanonicalIndex(field);
1425             if (canonicalIndex &lt; 0) {
1426                 newPattern+=field;
1427                 continue;  // don&#39;t adjust
1428             }
1429             const dtTypeElem *row = &amp;dtTypes[canonicalIndex];
1430             int32_t typeValue = row-&gt;field;
1431 
1432             // handle day periods - with #13183, no longer need special handling here, integrated with normal types
1433 
1434             if ((flags &amp; kDTPGFixFractionalSeconds) != 0 &amp;&amp; typeValue == UDATPG_SECOND_FIELD) {
1435                 field += decimal;
1436                 dtMatcher-&gt;skeleton.original.appendFieldTo(UDATPG_FRACTIONAL_SECOND_FIELD, field);
1437             } else if (dtMatcher-&gt;skeleton.type[typeValue]!=0) {
1438                     // Here:
1439                     // - &quot;reqField&quot; is the field from the originally requested skeleton, with length
1440                     // &quot;reqFieldLen&quot;.
1441                     // - &quot;field&quot; is the field from the found pattern.
1442                     //
1443                     // The adjusted field should consist of characters from the originally requested
1444                     // skeleton, except in the case of UDATPG_HOUR_FIELD or UDATPG_MONTH_FIELD or
1445                     // UDATPG_WEEKDAY_FIELD or UDATPG_YEAR_FIELD, in which case it should consist
1446                     // of characters from the  found pattern.
1447                     //
1448                     // The length of the adjusted field (adjFieldLen) should match that in the originally
1449                     // requested skeleton, except that in the following cases the length of the adjusted field
1450                     // should match that in the found pattern (i.e. the length of this pattern field should
1451                     // not be adjusted):
1452                     // 1. typeValue is UDATPG_HOUR_FIELD/MINUTE/SECOND and the corresponding bit in options is
1453                     //    not set (ticket #7180). Note, we may want to implement a similar change for other
1454                     //    numeric fields (MM, dd, etc.) so the default behavior is to get locale preference for
1455                     //    field length, but options bits can be used to override this.
1456                     // 2. There is a specified skeleton for the found pattern and one of the following is true:
1457                     //    a) The length of the field in the skeleton (skelFieldLen) is equal to reqFieldLen.
1458                     //    b) The pattern field is numeric and the skeleton field is not, or vice versa.
1459 
1460                     UChar reqFieldChar = dtMatcher-&gt;skeleton.original.getFieldChar(typeValue);
1461                     int32_t reqFieldLen = dtMatcher-&gt;skeleton.original.getFieldLength(typeValue);
1462                     if (reqFieldChar == CAP_E &amp;&amp; reqFieldLen &lt; 3)
1463                         reqFieldLen = 3; // 1-3 for E are equivalent to 3 for c,e
1464                     int32_t adjFieldLen = reqFieldLen;
1465                     if ( (typeValue==UDATPG_HOUR_FIELD &amp;&amp; (options &amp; UDATPG_MATCH_HOUR_FIELD_LENGTH)==0) ||
1466                          (typeValue==UDATPG_MINUTE_FIELD &amp;&amp; (options &amp; UDATPG_MATCH_MINUTE_FIELD_LENGTH)==0) ||
1467                          (typeValue==UDATPG_SECOND_FIELD &amp;&amp; (options &amp; UDATPG_MATCH_SECOND_FIELD_LENGTH)==0) ) {
1468                          adjFieldLen = field.length();
1469                     } else if (specifiedSkeleton) {
1470                         int32_t skelFieldLen = specifiedSkeleton-&gt;original.getFieldLength(typeValue);
1471                         UBool patFieldIsNumeric = (row-&gt;type &gt; 0);
1472                         UBool skelFieldIsNumeric = (specifiedSkeleton-&gt;type[typeValue] &gt; 0);
1473                         if (skelFieldLen == reqFieldLen || (patFieldIsNumeric &amp;&amp; !skelFieldIsNumeric) || (skelFieldIsNumeric &amp;&amp; !patFieldIsNumeric)) {
1474                             // don&#39;t adjust the field length in the found pattern
1475                             adjFieldLen = field.length();
1476                         }
1477                     }
1478                     UChar c = (typeValue!= UDATPG_HOUR_FIELD
1479                             &amp;&amp; typeValue!= UDATPG_MONTH_FIELD
1480                             &amp;&amp; typeValue!= UDATPG_WEEKDAY_FIELD
1481                             &amp;&amp; (typeValue!= UDATPG_YEAR_FIELD || reqFieldChar==CAP_Y))
1482                             ? reqFieldChar
1483                             : field.charAt(0);
1484                     if (typeValue == UDATPG_HOUR_FIELD &amp;&amp; (flags &amp; kDTPGSkeletonUsesCapJ) != 0) {
1485                         c = fDefaultHourFormatChar;
1486                     }
1487                     field.remove();
1488                     for (int32_t i=adjFieldLen; i&gt;0; --i) {
1489                         field+=c;
1490                     }
1491             }
1492             newPattern+=field;
1493         }
1494     }
1495     return newPattern;
1496 }
1497 
1498 UnicodeString
1499 DateTimePatternGenerator::getBestAppending(int32_t missingFields, int32_t flags, UDateTimePatternMatchOptions options) {
1500     UnicodeString  resultPattern, tempPattern;
1501     UErrorCode err=U_ZERO_ERROR;
1502     int32_t lastMissingFieldMask=0;
1503     if (missingFields!=0) {
1504         resultPattern=UnicodeString();
1505         const PtnSkeleton* specifiedSkeleton=NULL;
1506         tempPattern = *getBestRaw(*dtMatcher, missingFields, distanceInfo, &amp;specifiedSkeleton);
1507         resultPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);
1508         if ( distanceInfo-&gt;missingFieldMask==0 ) {
1509             return resultPattern;
1510         }
1511         while (distanceInfo-&gt;missingFieldMask!=0) { // precondition: EVERY single field must work!
1512             if ( lastMissingFieldMask == distanceInfo-&gt;missingFieldMask ) {
1513                 break;  // cannot find the proper missing field
1514             }
1515             if (((distanceInfo-&gt;missingFieldMask &amp; UDATPG_SECOND_AND_FRACTIONAL_MASK)==UDATPG_FRACTIONAL_MASK) &amp;&amp;
1516                 ((missingFields &amp; UDATPG_SECOND_AND_FRACTIONAL_MASK) == UDATPG_SECOND_AND_FRACTIONAL_MASK)) {
1517                 resultPattern = adjustFieldTypes(resultPattern, specifiedSkeleton, flags | kDTPGFixFractionalSeconds, options);
1518                 distanceInfo-&gt;missingFieldMask &amp;= ~UDATPG_FRACTIONAL_MASK;
1519                 continue;
1520             }
1521             int32_t startingMask = distanceInfo-&gt;missingFieldMask;
1522             tempPattern = *getBestRaw(*dtMatcher, distanceInfo-&gt;missingFieldMask, distanceInfo, &amp;specifiedSkeleton);
1523             tempPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);
1524             int32_t foundMask=startingMask&amp; ~distanceInfo-&gt;missingFieldMask;
1525             int32_t topField=getTopBitNumber(foundMask);
1526             UnicodeString appendName;
1527             getAppendName((UDateTimePatternField)topField, appendName);
1528             const UnicodeString *values[3] = {
1529                 &amp;resultPattern,
1530                 &amp;tempPattern,
1531                 &amp;appendName
1532             };
1533             SimpleFormatter(appendItemFormats[topField], 2, 3, err).
1534                     formatAndReplace(values, 3, resultPattern, NULL, 0, err);
1535             lastMissingFieldMask = distanceInfo-&gt;missingFieldMask;
1536         }
1537     }
1538     return resultPattern;
1539 }
1540 
1541 int32_t
1542 DateTimePatternGenerator::getTopBitNumber(int32_t foundMask) {
1543     if ( foundMask==0 ) {
1544         return 0;
1545     }
1546     int32_t i=0;
1547     while (foundMask!=0) {
1548         foundMask &gt;&gt;=1;
1549         ++i;
1550     }
1551     if (i-1 &gt;UDATPG_ZONE_FIELD) {
1552         return UDATPG_ZONE_FIELD;
1553     }
1554     else
1555         return i-1;
1556 }
1557 
1558 void
1559 DateTimePatternGenerator::setAvailableFormat(const UnicodeString &amp;key, UErrorCode&amp; err)
1560 {
1561     fAvailableFormatKeyHash-&gt;puti(key, 1, err);
1562 }
1563 
1564 UBool
1565 DateTimePatternGenerator::isAvailableFormatSet(const UnicodeString &amp;key) const {
1566     return (UBool)(fAvailableFormatKeyHash-&gt;geti(key) == 1);
1567 }
1568 
1569 void
1570 DateTimePatternGenerator::copyHashtable(Hashtable *other, UErrorCode &amp;status) {
1571 
1572     if (other == NULL) {
1573         return;
1574     }
1575     if (fAvailableFormatKeyHash != NULL) {
1576         delete fAvailableFormatKeyHash;
1577         fAvailableFormatKeyHash = NULL;
1578     }
1579     initHashtable(status);
1580     if(U_FAILURE(status)){
1581         return;
1582     }
1583     int32_t pos = UHASH_FIRST;
1584     const UHashElement* elem = NULL;
1585     // walk through the hash table and create a deep clone
1586     while((elem = other-&gt;nextElement(pos))!= NULL){
1587         const UHashTok otherKeyTok = elem-&gt;key;
1588         UnicodeString* otherKey = (UnicodeString*)otherKeyTok.pointer;
1589         fAvailableFormatKeyHash-&gt;puti(*otherKey, 1, status);
1590         if(U_FAILURE(status)){
1591             return;
1592         }
1593     }
1594 }
1595 
1596 StringEnumeration*
1597 DateTimePatternGenerator::getSkeletons(UErrorCode&amp; status) const {
1598     StringEnumeration* skeletonEnumerator = new DTSkeletonEnumeration(*patternMap, DT_SKELETON, status);
1599     return skeletonEnumerator;
1600 }
1601 
1602 const UnicodeString&amp;
1603 DateTimePatternGenerator::getPatternForSkeleton(const UnicodeString&amp; skeleton) const {
1604     PtnElem *curElem;
1605 
1606     if (skeleton.length() ==0) {
1607         return emptyString;
1608     }
1609     curElem = patternMap-&gt;getHeader(skeleton.charAt(0));
1610     while ( curElem != NULL ) {
1611         if ( curElem-&gt;skeleton-&gt;getSkeleton()==skeleton ) {
1612             return curElem-&gt;pattern;
1613         }
1614         curElem=curElem-&gt;next;
1615     }
1616     return emptyString;
1617 }
1618 
1619 StringEnumeration*
1620 DateTimePatternGenerator::getBaseSkeletons(UErrorCode&amp; status) const {
1621     StringEnumeration* baseSkeletonEnumerator = new DTSkeletonEnumeration(*patternMap, DT_BASESKELETON, status);
1622     return baseSkeletonEnumerator;
1623 }
1624 
1625 StringEnumeration*
1626 DateTimePatternGenerator::getRedundants(UErrorCode&amp; status) {
1627     StringEnumeration* output = new DTRedundantEnumeration();
1628     const UnicodeString *pattern;
1629     PatternMapIterator it;
1630     for (it.set(*patternMap); it.hasNext(); ) {
1631         DateTimeMatcher current = it.next();
1632         pattern = patternMap-&gt;getPatternFromSkeleton(*(it.getSkeleton()));
1633         if ( isCanonicalItem(*pattern) ) {
1634             continue;
1635         }
1636         if ( skipMatcher == NULL ) {
1637             skipMatcher = new DateTimeMatcher(current);
1638         }
1639         else {
1640             *skipMatcher = current;
1641         }
1642         UnicodeString trial = getBestPattern(current.getPattern(), status);
1643         if (trial == *pattern) {
1644             ((DTRedundantEnumeration *)output)-&gt;add(*pattern, status);
1645         }
1646         if (current.equals(skipMatcher)) {
1647             continue;
1648         }
1649     }
1650     return output;
1651 }
1652 
1653 UBool
1654 DateTimePatternGenerator::isCanonicalItem(const UnicodeString&amp; item) const {
1655     if ( item.length() != 1 ) {
1656         return FALSE;
1657     }
1658     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
1659         if (item.charAt(0)==Canonical_Items[i]) {
1660             return TRUE;
1661         }
1662     }
1663     return FALSE;
1664 }
1665 
1666 
1667 DateTimePatternGenerator*
1668 DateTimePatternGenerator::clone() const {
1669     return new DateTimePatternGenerator(*this);
1670 }
1671 
1672 PatternMap::PatternMap() {
1673    for (int32_t i=0; i &lt; MAX_PATTERN_ENTRIES; ++i ) {
1674       boot[i]=NULL;
1675    }
1676    isDupAllowed = TRUE;
1677 }
1678 
1679 void
1680 PatternMap::copyFrom(const PatternMap&amp; other, UErrorCode&amp; status) {
1681     this-&gt;isDupAllowed = other.isDupAllowed;
1682     for (int32_t bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {
1683         PtnElem *curElem, *otherElem, *prevElem=NULL;
1684         otherElem = other.boot[bootIndex];
1685         while (otherElem!=NULL) {
1686             if ((curElem = new PtnElem(otherElem-&gt;basePattern, otherElem-&gt;pattern))==NULL) {
1687                 // out of memory
1688                 status = U_MEMORY_ALLOCATION_ERROR;
1689                 return;
1690             }
1691             if ( this-&gt;boot[bootIndex]== NULL ) {
1692                 this-&gt;boot[bootIndex] = curElem;
1693             }
1694             if ((curElem-&gt;skeleton=new PtnSkeleton(*(otherElem-&gt;skeleton))) == NULL ) {
1695                 // out of memory
1696                 status = U_MEMORY_ALLOCATION_ERROR;
1697                 return;
1698             }
1699             curElem-&gt;skeletonWasSpecified = otherElem-&gt;skeletonWasSpecified;
1700             if (prevElem!=NULL) {
1701                 prevElem-&gt;next=curElem;
1702             }
1703             curElem-&gt;next=NULL;
1704             prevElem = curElem;
1705             otherElem = otherElem-&gt;next;
1706         }
1707 
1708     }
1709 }
1710 
1711 PtnElem*
1712 PatternMap::getHeader(UChar baseChar) {
1713     PtnElem* curElem;
1714 
1715     if ( (baseChar &gt;= CAP_A) &amp;&amp; (baseChar &lt;= CAP_Z) ) {
1716          curElem = boot[baseChar-CAP_A];
1717     }
1718     else {
1719         if ( (baseChar &gt;=LOW_A) &amp;&amp; (baseChar &lt;= LOW_Z) ) {
1720             curElem = boot[26+baseChar-LOW_A];
1721         }
1722         else {
1723             return NULL;
1724         }
1725     }
1726     return curElem;
1727 }
1728 
1729 PatternMap::~PatternMap() {
1730    for (int32_t i=0; i &lt; MAX_PATTERN_ENTRIES; ++i ) {
1731        if (boot[i]!=NULL ) {
1732            delete boot[i];
1733            boot[i]=NULL;
1734        }
1735    }
1736 }  // PatternMap destructor
1737 
1738 void
1739 PatternMap::add(const UnicodeString&amp; basePattern,
1740                 const PtnSkeleton&amp; skeleton,
1741                 const UnicodeString&amp; value,// mapped pattern value
1742                 UBool skeletonWasSpecified,
1743                 UErrorCode &amp;status) {
1744     UChar baseChar = basePattern.charAt(0);
1745     PtnElem *curElem, *baseElem;
1746     status = U_ZERO_ERROR;
1747 
1748     // the baseChar must be A-Z or a-z
1749     if ((baseChar &gt;= CAP_A) &amp;&amp; (baseChar &lt;= CAP_Z)) {
1750         baseElem = boot[baseChar-CAP_A];
1751     }
1752     else {
1753         if ((baseChar &gt;=LOW_A) &amp;&amp; (baseChar &lt;= LOW_Z)) {
1754             baseElem = boot[26+baseChar-LOW_A];
1755          }
1756          else {
1757              status = U_ILLEGAL_CHARACTER;
1758              return;
1759          }
1760     }
1761 
1762     if (baseElem == NULL) {
1763         if ((curElem = new PtnElem(basePattern, value)) == NULL ) {
1764             // out of memory
1765             status = U_MEMORY_ALLOCATION_ERROR;
1766             return;
1767         }
1768         if (baseChar &gt;= LOW_A) {
1769             boot[26 + (baseChar-LOW_A)] = curElem;
1770         }
1771         else {
1772             boot[baseChar-CAP_A] = curElem;
1773         }
1774         curElem-&gt;skeleton = new PtnSkeleton(skeleton);
1775         curElem-&gt;skeletonWasSpecified = skeletonWasSpecified;
1776     }
1777     if ( baseElem != NULL ) {
1778         curElem = getDuplicateElem(basePattern, skeleton, baseElem);
1779 
1780         if (curElem == NULL) {
1781             // add new element to the list.
1782             curElem = baseElem;
1783             while( curElem -&gt; next != NULL )
1784             {
1785                 curElem = curElem-&gt;next;
1786             }
1787             if ((curElem-&gt;next = new PtnElem(basePattern, value)) == NULL ) {
1788                 // out of memory
1789                 status = U_MEMORY_ALLOCATION_ERROR;
1790                 return;
1791             }
1792             curElem=curElem-&gt;next;
1793             curElem-&gt;skeleton = new PtnSkeleton(skeleton);
1794             curElem-&gt;skeletonWasSpecified = skeletonWasSpecified;
1795         }
1796         else {
1797             // Pattern exists in the list already.
1798             if ( !isDupAllowed ) {
1799                 return;
1800             }
1801             // Overwrite the value.
1802             curElem-&gt;pattern = value;
1803             // It was a bug that we were not doing the following previously,
1804             // though that bug hid other problems by making things partly work.
1805             curElem-&gt;skeletonWasSpecified = skeletonWasSpecified;
1806         }
1807     }
1808 }  // PatternMap::add
1809 
1810 // Find the pattern from the given basePattern string.
1811 const UnicodeString *
1812 PatternMap::getPatternFromBasePattern(UnicodeString&amp; basePattern, UBool&amp; skeletonWasSpecified) { // key to search for
1813    PtnElem *curElem;
1814 
1815    if ((curElem=getHeader(basePattern.charAt(0)))==NULL) {
1816        return NULL;  // no match
1817    }
1818 
1819    do  {
1820        if ( basePattern.compare(curElem-&gt;basePattern)==0 ) {
1821           skeletonWasSpecified = curElem-&gt;skeletonWasSpecified;
1822           return &amp;(curElem-&gt;pattern);
1823        }
1824        curElem=curElem-&gt;next;
1825    }while (curElem != NULL);
1826 
1827    return NULL;
1828 }  // PatternMap::getFromBasePattern
1829 
1830 
1831 // Find the pattern from the given skeleton.
1832 // At least when this is called from getBestRaw &amp; addPattern (in which case specifiedSkeletonPtr is non-NULL),
1833 // the comparison should be based on skeleton.original (which is unique and tied to the distance measurement in bestRaw)
1834 // and not skeleton.baseOriginal (which is not unique); otherwise we may pick a different skeleton than the one with the
1835 // optimum distance value in getBestRaw. When this is called from public getRedundants (specifiedSkeletonPtr is NULL),
1836 // for now it will continue to compare based on baseOriginal so as not to change the behavior unnecessarily.
1837 const UnicodeString *
1838 PatternMap::getPatternFromSkeleton(PtnSkeleton&amp; skeleton, const PtnSkeleton** specifiedSkeletonPtr) { // key to search for
1839    PtnElem *curElem;
1840 
1841    if (specifiedSkeletonPtr) {
1842        *specifiedSkeletonPtr = NULL;
1843    }
1844 
1845    // find boot entry
1846    UChar baseChar = skeleton.getFirstChar();
1847    if ((curElem=getHeader(baseChar))==NULL) {
1848        return NULL;  // no match
1849    }
1850 
1851    do  {
1852        UBool equal;
1853        if (specifiedSkeletonPtr != NULL) { // called from DateTimePatternGenerator::getBestRaw or addPattern, use original
1854            equal = curElem-&gt;skeleton-&gt;original == skeleton.original;
1855        } else { // called from DateTimePatternGenerator::getRedundants, use baseOriginal
1856            equal = curElem-&gt;skeleton-&gt;baseOriginal == skeleton.baseOriginal;
1857        }
1858        if (equal) {
1859            if (specifiedSkeletonPtr &amp;&amp; curElem-&gt;skeletonWasSpecified) {
1860                *specifiedSkeletonPtr = curElem-&gt;skeleton;
1861            }
1862            return &amp;(curElem-&gt;pattern);
1863        }
1864        curElem=curElem-&gt;next;
1865    }while (curElem != NULL);
1866 
1867    return NULL;
1868 }
1869 
1870 UBool
1871 PatternMap::equals(const PatternMap&amp; other) {
1872     if ( this==&amp;other ) {
1873         return TRUE;
1874     }
1875     for (int32_t bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {
1876         if ( boot[bootIndex]==other.boot[bootIndex] ) {
1877             continue;
1878         }
1879         if ( (boot[bootIndex]==NULL)||(other.boot[bootIndex]==NULL) ) {
1880             return FALSE;
1881         }
1882         PtnElem *otherElem = other.boot[bootIndex];
1883         PtnElem *myElem = boot[bootIndex];
1884         while ((otherElem!=NULL) || (myElem!=NULL)) {
1885             if ( myElem == otherElem ) {
1886                 break;
1887             }
1888             if ((otherElem==NULL) || (myElem==NULL)) {
1889                 return FALSE;
1890             }
1891             if ( (myElem-&gt;basePattern != otherElem-&gt;basePattern) ||
1892                  (myElem-&gt;pattern != otherElem-&gt;pattern) ) {
1893                 return FALSE;
1894             }
1895             if ((myElem-&gt;skeleton!=otherElem-&gt;skeleton)&amp;&amp;
1896                 !myElem-&gt;skeleton-&gt;equals(*(otherElem-&gt;skeleton))) {
1897                 return FALSE;
1898             }
1899             myElem = myElem-&gt;next;
1900             otherElem=otherElem-&gt;next;
1901         }
1902     }
1903     return TRUE;
1904 }
1905 
1906 // find any key existing in the mapping table already.
1907 // return TRUE if there is an existing key, otherwise return FALSE.
1908 PtnElem*
1909 PatternMap::getDuplicateElem(
1910             const UnicodeString &amp;basePattern,
1911             const PtnSkeleton &amp;skeleton,
1912             PtnElem *baseElem)  {
1913    PtnElem *curElem;
1914 
1915    if ( baseElem == (PtnElem *)NULL )  {
1916          return (PtnElem*)NULL;
1917    }
1918    else {
1919          curElem = baseElem;
1920    }
1921    do {
1922      if ( basePattern.compare(curElem-&gt;basePattern)==0 ) {
1923         UBool isEqual=TRUE;
1924         for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
1925             if (curElem-&gt;skeleton-&gt;type[i] != skeleton.type[i] ) {
1926                 isEqual=FALSE;
1927                 break;
1928             }
1929         }
1930         if (isEqual) {
1931             return curElem;
1932         }
1933      }
1934      curElem = curElem-&gt;next;
1935    } while( curElem != (PtnElem *)NULL );
1936 
1937    // end of the list
1938    return (PtnElem*)NULL;
1939 
1940 }  // PatternMap::getDuplicateElem
1941 
1942 DateTimeMatcher::DateTimeMatcher(void) {
1943 }
1944 
1945 DateTimeMatcher::~DateTimeMatcher() {}
1946 
1947 DateTimeMatcher::DateTimeMatcher(const DateTimeMatcher&amp; other) {
1948     copyFrom(other.skeleton);
1949 }
1950 
1951 
1952 void
1953 DateTimeMatcher::set(const UnicodeString&amp; pattern, FormatParser* fp) {
1954     PtnSkeleton localSkeleton;
1955     return set(pattern, fp, localSkeleton);
1956 }
1957 
1958 void
1959 DateTimeMatcher::set(const UnicodeString&amp; pattern, FormatParser* fp, PtnSkeleton&amp; skeletonResult) {
1960     int32_t i;
1961     for (i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
1962         skeletonResult.type[i] = NONE;
1963     }
1964     skeletonResult.original.clear();
1965     skeletonResult.baseOriginal.clear();
1966     skeletonResult.addedDefaultDayPeriod = FALSE;
1967 
1968     fp-&gt;set(pattern);
1969     for (i=0; i &lt; fp-&gt;itemNumber; i++) {
1970         const UnicodeString&amp; value = fp-&gt;items[i];
1971         // don&#39;t skip &#39;a&#39; anymore, dayPeriod handled specially below
1972 
1973         if ( fp-&gt;isQuoteLiteral(value) ) {
1974             UnicodeString quoteLiteral;
1975             fp-&gt;getQuoteLiteral(quoteLiteral, &amp;i);
1976             continue;
1977         }
1978         int32_t canonicalIndex = fp-&gt;getCanonicalIndex(value);
1979         if (canonicalIndex &lt; 0 ) {
1980             continue;
1981         }
1982         const dtTypeElem *row = &amp;dtTypes[canonicalIndex];
1983         int32_t field = row-&gt;field;
1984         skeletonResult.original.populate(field, value);
1985         UChar repeatChar = row-&gt;patternChar;
1986         int32_t repeatCount = row-&gt;minLen;
1987         skeletonResult.baseOriginal.populate(field, repeatChar, repeatCount);
1988         int16_t subField = row-&gt;type;
1989         if ( row-&gt;type &gt; 0) {
1990             subField += value.length();
1991         }
1992         skeletonResult.type[field] = subField;
1993     }
1994     // #13183, handle special behavior for day period characters (a, b, B)
1995     if (!skeletonResult.original.isFieldEmpty(UDATPG_HOUR_FIELD)) {
1996         if (skeletonResult.original.getFieldChar(UDATPG_HOUR_FIELD)==LOW_H || skeletonResult.original.getFieldChar(UDATPG_HOUR_FIELD)==CAP_K) {
1997             // We have a skeleton with 12-hour-cycle format
1998             if (skeletonResult.original.isFieldEmpty(UDATPG_DAYPERIOD_FIELD)) {
1999                 // But we do not have a day period in the skeleton; add the default DAYPERIOD (currently &quot;a&quot;)
2000                 for (i = 0; dtTypes[i].patternChar != 0; i++) {
2001                     if ( dtTypes[i].field == UDATPG_DAYPERIOD_FIELD ) {
2002                         // first entry for UDATPG_DAYPERIOD_FIELD
2003                         skeletonResult.original.populate(UDATPG_DAYPERIOD_FIELD, dtTypes[i].patternChar, dtTypes[i].minLen);
2004                         skeletonResult.baseOriginal.populate(UDATPG_DAYPERIOD_FIELD, dtTypes[i].patternChar, dtTypes[i].minLen);
2005                         skeletonResult.type[UDATPG_DAYPERIOD_FIELD] = dtTypes[i].type;
2006                         skeletonResult.addedDefaultDayPeriod = TRUE;
2007                         break;
2008                     }
2009                 }
2010             }
2011         } else {
2012             // Skeleton has 24-hour-cycle hour format and has dayPeriod, delete dayPeriod (i.e. ignore it)
2013             skeletonResult.original.clearField(UDATPG_DAYPERIOD_FIELD);
2014             skeletonResult.baseOriginal.clearField(UDATPG_DAYPERIOD_FIELD);
2015             skeletonResult.type[UDATPG_DAYPERIOD_FIELD] = NONE;
2016         }
2017     }
2018     copyFrom(skeletonResult);
2019 }
2020 
2021 void
2022 DateTimeMatcher::getBasePattern(UnicodeString &amp;result ) {
2023     result.remove(); // Reset the result first.
2024     skeleton.baseOriginal.appendTo(result);
2025 }
2026 
2027 UnicodeString
2028 DateTimeMatcher::getPattern() {
2029     UnicodeString result;
2030     return skeleton.original.appendTo(result);
2031 }
2032 
2033 int32_t
2034 DateTimeMatcher::getDistance(const DateTimeMatcher&amp; other, int32_t includeMask, DistanceInfo&amp; distanceInfo) {
2035     int32_t result=0;
2036     distanceInfo.clear();
2037     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i ) {
2038         int32_t myType = (includeMask&amp;(1&lt;&lt;i))==0 ? 0 : skeleton.type[i];
2039         int32_t otherType = other.skeleton.type[i];
2040         if (myType==otherType) {
2041             continue;
2042         }
2043         if (myType==0) {// and other is not
2044             result += EXTRA_FIELD;
2045             distanceInfo.addExtra(i);
2046         }
2047         else {
2048             if (otherType==0) {
2049                 result += MISSING_FIELD;
2050                 distanceInfo.addMissing(i);
2051             }
2052             else {
2053                 result += abs(myType - otherType);
2054             }
2055         }
2056 
2057     }
2058     return result;
2059 }
2060 
2061 void
2062 DateTimeMatcher::copyFrom(const PtnSkeleton&amp; newSkeleton) {
2063     skeleton.copyFrom(newSkeleton);
2064 }
2065 
2066 void
2067 DateTimeMatcher::copyFrom() {
2068     // same as clear
2069     skeleton.clear();
2070 }
2071 
2072 UBool
2073 DateTimeMatcher::equals(const DateTimeMatcher* other) const {
2074     if (other==NULL) { return FALSE; }
2075     return skeleton.original == other-&gt;skeleton.original;
2076 }
2077 
2078 int32_t
2079 DateTimeMatcher::getFieldMask() {
2080     int32_t result=0;
2081 
2082     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
2083         if (skeleton.type[i]!=0) {
2084             result |= (1&lt;&lt;i);
2085         }
2086     }
2087     return result;
2088 }
2089 
2090 PtnSkeleton*
2091 DateTimeMatcher::getSkeletonPtr() {
2092     return &amp;skeleton;
2093 }
2094 
2095 FormatParser::FormatParser () {
2096     status = START;
2097     itemNumber=0;
2098 }
2099 
2100 
2101 FormatParser::~FormatParser () {
2102 }
2103 
2104 
2105 // Find the next token with the starting position and length
2106 // Note: the startPos may
2107 FormatParser::TokenStatus
2108 FormatParser::setTokens(const UnicodeString&amp; pattern, int32_t startPos, int32_t *len) {
2109     int32_t  curLoc = startPos;
2110     if ( curLoc &gt;= pattern.length()) {
2111         return DONE;
2112     }
2113     // check the current char is between A-Z or a-z
2114     do {
2115         UChar c=pattern.charAt(curLoc);
2116         if ( (c&gt;=CAP_A &amp;&amp; c&lt;=CAP_Z) || (c&gt;=LOW_A &amp;&amp; c&lt;=LOW_Z) ) {
2117            curLoc++;
2118         }
2119         else {
2120                startPos = curLoc;
2121                *len=1;
2122                return ADD_TOKEN;
2123         }
2124 
2125         if ( pattern.charAt(curLoc)!= pattern.charAt(startPos) ) {
2126             break;  // not the same token
2127         }
2128     } while(curLoc &lt;= pattern.length());
2129     *len = curLoc-startPos;
2130     return ADD_TOKEN;
2131 }
2132 
2133 void
2134 FormatParser::set(const UnicodeString&amp; pattern) {
2135     int32_t startPos=0;
2136     TokenStatus result=START;
2137     int32_t len=0;
2138     itemNumber =0;
2139 
2140     do {
2141         result = setTokens( pattern, startPos, &amp;len );
2142         if ( result == ADD_TOKEN )
2143         {
2144             items[itemNumber++] = UnicodeString(pattern, startPos, len );
2145             startPos += len;
2146         }
2147         else {
2148             break;
2149         }
2150     } while (result==ADD_TOKEN &amp;&amp; itemNumber &lt; MAX_DT_TOKEN);
2151 }
2152 
2153 int32_t
2154 FormatParser::getCanonicalIndex(const UnicodeString&amp; s, UBool strict) {
2155     int32_t len = s.length();
2156     if (len == 0) {
2157         return -1;
2158     }
2159     UChar ch = s.charAt(0);
2160 
2161     // Verify that all are the same character.
2162     for (int32_t l = 1; l &lt; len; l++) {
2163         if (ch != s.charAt(l)) {
2164             return -1;
2165         }
2166     }
2167     int32_t i = 0;
2168     int32_t bestRow = -1;
2169     while (dtTypes[i].patternChar != 0x0000) {
2170         if ( dtTypes[i].patternChar != ch ) {
2171             ++i;
2172             continue;
2173         }
2174         bestRow = i;
2175         if (dtTypes[i].patternChar != dtTypes[i+1].patternChar) {
2176             return i;
2177         }
2178         if (dtTypes[i+1].minLen &lt;= len) {
2179             ++i;
2180             continue;
2181         }
2182         return i;
2183     }
2184     return strict ? -1 : bestRow;
2185 }
2186 
2187 UBool
2188 FormatParser::isQuoteLiteral(const UnicodeString&amp; s) {
2189     return (UBool)(s.charAt(0)==SINGLE_QUOTE);
2190 }
2191 
2192 // This function aussumes the current itemIndex points to the quote literal.
2193 // Please call isQuoteLiteral prior to this function.
2194 void
2195 FormatParser::getQuoteLiteral(UnicodeString&amp; quote, int32_t *itemIndex) {
2196     int32_t i=*itemIndex;
2197 
2198     quote.remove();
2199     if (items[i].charAt(0)==SINGLE_QUOTE) {
2200         quote += items[i];
2201         ++i;
2202     }
2203     while ( i &lt; itemNumber ) {
2204         if ( items[i].charAt(0)==SINGLE_QUOTE ) {
2205             if ( (i+1&lt;itemNumber) &amp;&amp; (items[i+1].charAt(0)==SINGLE_QUOTE)) {
2206                 // two single quotes e.g. &#39;o&#39;&#39;clock&#39;
2207                 quote += items[i++];
2208                 quote += items[i++];
2209                 continue;
2210             }
2211             else {
2212                 quote += items[i];
2213                 break;
2214             }
2215         }
2216         else {
2217             quote += items[i];
2218         }
2219         ++i;
2220     }
2221     *itemIndex=i;
2222 }
2223 
2224 UBool
2225 FormatParser::isPatternSeparator(UnicodeString&amp; field) {
2226     for (int32_t i=0; i&lt;field.length(); ++i ) {
2227         UChar c= field.charAt(i);
2228         if ( (c==SINGLE_QUOTE) || (c==BACKSLASH) || (c==SPACE) || (c==COLON) ||
2229              (c==QUOTATION_MARK) || (c==COMMA) || (c==HYPHEN) ||(items[i].charAt(0)==DOT) ) {
2230             continue;
2231         }
2232         else {
2233             return FALSE;
2234         }
2235     }
2236     return TRUE;
2237 }
2238 
2239 DistanceInfo::~DistanceInfo() {}
2240 
2241 void
2242 DistanceInfo::setTo(DistanceInfo &amp;other) {
2243     missingFieldMask = other.missingFieldMask;
2244     extraFieldMask= other.extraFieldMask;
2245 }
2246 
2247 PatternMapIterator::PatternMapIterator() {
2248     bootIndex = 0;
2249     nodePtr = NULL;
2250     patternMap=NULL;
2251     matcher= new DateTimeMatcher();
2252 }
2253 
2254 
2255 PatternMapIterator::~PatternMapIterator() {
2256     delete matcher;
2257 }
2258 
2259 void
2260 PatternMapIterator::set(PatternMap&amp; newPatternMap) {
2261     this-&gt;patternMap=&amp;newPatternMap;
2262 }
2263 
2264 PtnSkeleton*
2265 PatternMapIterator::getSkeleton() {
2266     if ( nodePtr == NULL ) {
2267         return NULL;
2268     }
2269     else {
2270         return nodePtr-&gt;skeleton;
2271     }
2272 }
2273 
2274 UBool
2275 PatternMapIterator::hasNext() {
2276     int32_t headIndex=bootIndex;
2277     PtnElem *curPtr=nodePtr;
2278 
2279     if (patternMap==NULL) {
2280         return FALSE;
2281     }
2282     while ( headIndex &lt; MAX_PATTERN_ENTRIES ) {
2283         if ( curPtr != NULL ) {
2284             if ( curPtr-&gt;next != NULL ) {
2285                 return TRUE;
2286             }
2287             else {
2288                 headIndex++;
2289                 curPtr=NULL;
2290                 continue;
2291             }
2292         }
2293         else {
2294             if ( patternMap-&gt;boot[headIndex] != NULL ) {
2295                 return TRUE;
2296             }
2297             else {
2298                 headIndex++;
2299                 continue;
2300             }
2301         }
2302 
2303     }
2304     return FALSE;
2305 }
2306 
2307 DateTimeMatcher&amp;
2308 PatternMapIterator::next() {
2309     while ( bootIndex &lt; MAX_PATTERN_ENTRIES ) {
2310         if ( nodePtr != NULL ) {
2311             if ( nodePtr-&gt;next != NULL ) {
2312                 nodePtr = nodePtr-&gt;next;
2313                 break;
2314             }
2315             else {
2316                 bootIndex++;
2317                 nodePtr=NULL;
2318                 continue;
2319             }
2320         }
2321         else {
2322             if ( patternMap-&gt;boot[bootIndex] != NULL ) {
2323                 nodePtr = patternMap-&gt;boot[bootIndex];
2324                 break;
2325             }
2326             else {
2327                 bootIndex++;
2328                 continue;
2329             }
2330         }
2331     }
2332     if (nodePtr!=NULL) {
2333         matcher-&gt;copyFrom(*nodePtr-&gt;skeleton);
2334     }
2335     else {
2336         matcher-&gt;copyFrom();
2337     }
2338     return *matcher;
2339 }
2340 
2341 
2342 SkeletonFields::SkeletonFields() {
2343     // Set initial values to zero
2344     clear();
2345 }
2346 
2347 void SkeletonFields::clear() {
2348     uprv_memset(chars, 0, sizeof(chars));
2349     uprv_memset(lengths, 0, sizeof(lengths));
2350 }
2351 
2352 void SkeletonFields::copyFrom(const SkeletonFields&amp; other) {
2353     uprv_memcpy(chars, other.chars, sizeof(chars));
2354     uprv_memcpy(lengths, other.lengths, sizeof(lengths));
2355 }
2356 
2357 void SkeletonFields::clearField(int32_t field) {
2358     chars[field] = 0;
2359     lengths[field] = 0;
2360 }
2361 
2362 UChar SkeletonFields::getFieldChar(int32_t field) const {
2363     return chars[field];
2364 }
2365 
2366 int32_t SkeletonFields::getFieldLength(int32_t field) const {
2367     return lengths[field];
2368 }
2369 
2370 void SkeletonFields::populate(int32_t field, const UnicodeString&amp; value) {
2371     populate(field, value.charAt(0), value.length());
2372 }
2373 
2374 void SkeletonFields::populate(int32_t field, UChar ch, int32_t length) {
2375     chars[field] = (int8_t) ch;
2376     lengths[field] = (int8_t) length;
2377 }
2378 
2379 UBool SkeletonFields::isFieldEmpty(int32_t field) const {
2380     return lengths[field] == 0;
2381 }
2382 
2383 UnicodeString&amp; SkeletonFields::appendTo(UnicodeString&amp; string) const {
2384     for (int32_t i = 0; i &lt; UDATPG_FIELD_COUNT; ++i) {
2385         appendFieldTo(i, string);
2386     }
2387     return string;
2388 }
2389 
2390 UnicodeString&amp; SkeletonFields::appendFieldTo(int32_t field, UnicodeString&amp; string) const {
2391     UChar ch(chars[field]);
2392     int32_t length = (int32_t) lengths[field];
2393 
2394     for (int32_t i=0; i&lt;length; i++) {
2395         string += ch;
2396     }
2397     return string;
2398 }
2399 
2400 UChar SkeletonFields::getFirstChar() const {
2401     for (int32_t i = 0; i &lt; UDATPG_FIELD_COUNT; ++i) {
2402         if (lengths[i] != 0) {
2403             return chars[i];
2404         }
2405     }
2406     return &#39;\0&#39;;
2407 }
2408 
2409 
2410 PtnSkeleton::PtnSkeleton() {
2411 }
2412 
2413 PtnSkeleton::PtnSkeleton(const PtnSkeleton&amp; other) {
2414     copyFrom(other);
2415 }
2416 
2417 void PtnSkeleton::copyFrom(const PtnSkeleton&amp; other) {
2418     uprv_memcpy(type, other.type, sizeof(type));
2419     original.copyFrom(other.original);
2420     baseOriginal.copyFrom(other.baseOriginal);
2421 }
2422 
2423 void PtnSkeleton::clear() {
2424     uprv_memset(type, 0, sizeof(type));
2425     original.clear();
2426     baseOriginal.clear();
2427 }
2428 
2429 UBool
2430 PtnSkeleton::equals(const PtnSkeleton&amp; other) const  {
2431     return (original == other.original)
2432         &amp;&amp; (baseOriginal == other.baseOriginal)
2433         &amp;&amp; (uprv_memcmp(type, other.type, sizeof(type)) == 0);
2434 }
2435 
2436 UnicodeString
2437 PtnSkeleton::getSkeleton() const {
2438     UnicodeString result;
2439     result = original.appendTo(result);
2440     int32_t pos;
2441     if (addedDefaultDayPeriod &amp;&amp; (pos = result.indexOf(LOW_A)) &gt;= 0) {
2442         // for backward compatibility: if DateTimeMatcher.set added a single &#39;a&#39; that
2443         // was not in the provided skeleton, remove it here before returning skeleton.
2444         result.remove(pos, 1);
2445     }
2446     return result;
2447 }
2448 
2449 UnicodeString
2450 PtnSkeleton::getBaseSkeleton() const {
2451     UnicodeString result;
2452     result = baseOriginal.appendTo(result);
2453     int32_t pos;
2454     if (addedDefaultDayPeriod &amp;&amp; (pos = result.indexOf(LOW_A)) &gt;= 0) {
2455         // for backward compatibility: if DateTimeMatcher.set added a single &#39;a&#39; that
2456         // was not in the provided skeleton, remove it here before returning skeleton.
2457         result.remove(pos, 1);
2458     }
2459     return result;
2460 }
2461 
2462 UChar
2463 PtnSkeleton::getFirstChar() const {
2464     return baseOriginal.getFirstChar();
2465 }
2466 
2467 PtnSkeleton::~PtnSkeleton() {
2468 }
2469 
2470 PtnElem::PtnElem(const UnicodeString &amp;basePat, const UnicodeString &amp;pat) :
2471 basePattern(basePat),
2472 skeleton(NULL),
2473 pattern(pat),
2474 next(NULL)
2475 {
2476 }
2477 
2478 PtnElem::~PtnElem() {
2479 
2480     if (next!=NULL) {
2481         delete next;
2482     }
2483     delete skeleton;
2484 }
2485 
2486 DTSkeletonEnumeration::DTSkeletonEnumeration(PatternMap &amp;patternMap, dtStrEnum type, UErrorCode&amp; status) {
2487     PtnElem  *curElem;
2488     PtnSkeleton *curSkeleton;
2489     UnicodeString s;
2490     int32_t bootIndex;
2491 
2492     pos=0;
2493     fSkeletons = new UVector(status);
2494     if (U_FAILURE(status)) {
2495         delete fSkeletons;
2496         return;
2497     }
2498     for (bootIndex=0; bootIndex&lt;MAX_PATTERN_ENTRIES; ++bootIndex ) {
2499         curElem = patternMap.boot[bootIndex];
2500         while (curElem!=NULL) {
2501             switch(type) {
2502                 case DT_BASESKELETON:
2503                     s=curElem-&gt;basePattern;
2504                     break;
2505                 case DT_PATTERN:
2506                     s=curElem-&gt;pattern;
2507                     break;
2508                 case DT_SKELETON:
2509                     curSkeleton=curElem-&gt;skeleton;
2510                     s=curSkeleton-&gt;getSkeleton();
2511                     break;
2512             }
2513             if ( !isCanonicalItem(s) ) {
2514                 fSkeletons-&gt;addElement(new UnicodeString(s), status);
2515                 if (U_FAILURE(status)) {
2516                     delete fSkeletons;
2517                     fSkeletons = NULL;
2518                     return;
2519                 }
2520             }
2521             curElem = curElem-&gt;next;
2522         }
2523     }
2524     if ((bootIndex==MAX_PATTERN_ENTRIES) &amp;&amp; (curElem!=NULL) ) {
2525         status = U_BUFFER_OVERFLOW_ERROR;
2526     }
2527 }
2528 
2529 const UnicodeString*
2530 DTSkeletonEnumeration::snext(UErrorCode&amp; status) {
2531     if (U_SUCCESS(status) &amp;&amp; pos &lt; fSkeletons-&gt;size()) {
2532         return (const UnicodeString*)fSkeletons-&gt;elementAt(pos++);
2533     }
2534     return NULL;
2535 }
2536 
2537 void
2538 DTSkeletonEnumeration::reset(UErrorCode&amp; /*status*/) {
2539     pos=0;
2540 }
2541 
2542 int32_t
2543 DTSkeletonEnumeration::count(UErrorCode&amp; /*status*/) const {
2544    return (fSkeletons==NULL) ? 0 : fSkeletons-&gt;size();
2545 }
2546 
2547 UBool
2548 DTSkeletonEnumeration::isCanonicalItem(const UnicodeString&amp; item) {
2549     if ( item.length() != 1 ) {
2550         return FALSE;
2551     }
2552     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
2553         if (item.charAt(0)==Canonical_Items[i]) {
2554             return TRUE;
2555         }
2556     }
2557     return FALSE;
2558 }
2559 
2560 DTSkeletonEnumeration::~DTSkeletonEnumeration() {
2561     UnicodeString *s;
2562     for (int32_t i=0; i&lt;fSkeletons-&gt;size(); ++i) {
2563         if ((s=(UnicodeString *)fSkeletons-&gt;elementAt(i))!=NULL) {
2564             delete s;
2565         }
2566     }
2567     delete fSkeletons;
2568 }
2569 
2570 DTRedundantEnumeration::DTRedundantEnumeration() {
2571     pos=0;
2572     fPatterns = NULL;
2573 }
2574 
2575 void
2576 DTRedundantEnumeration::add(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
2577     if (U_FAILURE(status)) return;
2578     if (fPatterns == NULL)  {
2579         fPatterns = new UVector(status);
2580         if (U_FAILURE(status)) {
2581             delete fPatterns;
2582             fPatterns = NULL;
2583             return;
2584        }
2585     }
2586     fPatterns-&gt;addElement(new UnicodeString(pattern), status);
2587     if (U_FAILURE(status)) {
2588         delete fPatterns;
2589         fPatterns = NULL;
2590         return;
2591     }
2592 }
2593 
2594 const UnicodeString*
2595 DTRedundantEnumeration::snext(UErrorCode&amp; status) {
2596     if (U_SUCCESS(status) &amp;&amp; pos &lt; fPatterns-&gt;size()) {
2597         return (const UnicodeString*)fPatterns-&gt;elementAt(pos++);
2598     }
2599     return NULL;
2600 }
2601 
2602 void
2603 DTRedundantEnumeration::reset(UErrorCode&amp; /*status*/) {
2604     pos=0;
2605 }
2606 
2607 int32_t
2608 DTRedundantEnumeration::count(UErrorCode&amp; /*status*/) const {
2609        return (fPatterns==NULL) ? 0 : fPatterns-&gt;size();
2610 }
2611 
2612 UBool
2613 DTRedundantEnumeration::isCanonicalItem(const UnicodeString&amp; item) {
2614     if ( item.length() != 1 ) {
2615         return FALSE;
2616     }
2617     for (int32_t i=0; i&lt;UDATPG_FIELD_COUNT; ++i) {
2618         if (item.charAt(0)==Canonical_Items[i]) {
2619             return TRUE;
2620         }
2621     }
2622     return FALSE;
2623 }
2624 
2625 DTRedundantEnumeration::~DTRedundantEnumeration() {
2626     UnicodeString *s;
2627     for (int32_t i=0; i&lt;fPatterns-&gt;size(); ++i) {
2628         if ((s=(UnicodeString *)fPatterns-&gt;elementAt(i))!=NULL) {
2629             delete s;
2630         }
2631     }
2632     delete fPatterns;
2633 }
2634 
2635 U_NAMESPACE_END
2636 
2637 
2638 #endif /* #if !UCONFIG_NO_FORMATTING */
2639 
2640 //eof
    </pre>
  </body>
</html>