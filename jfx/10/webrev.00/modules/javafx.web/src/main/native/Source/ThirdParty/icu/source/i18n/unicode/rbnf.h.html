<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/rbnf.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 1997-2015, International Business Machines Corporation and others.
   6 * All Rights Reserved.
   7 *******************************************************************************
   8 */
   9 
  10 #ifndef RBNF_H
  11 #define RBNF_H
  12 
  13 #include &quot;unicode/utypes.h&quot;
  14 
  15 /**
  16  * \file
  17  * \brief C++ API: Rule Based Number Format
  18  */
  19 
  20 /**
  21  * \def U_HAVE_RBNF
  22  * This will be 0 if RBNF support is not included in ICU
  23  * and 1 if it is.
  24  *
  25  * @stable ICU 2.4
  26  */
  27 #if UCONFIG_NO_FORMATTING
  28 #define U_HAVE_RBNF 0
  29 #else
  30 #define U_HAVE_RBNF 1
  31 
  32 #include &quot;unicode/dcfmtsym.h&quot;
  33 #include &quot;unicode/fmtable.h&quot;
  34 #include &quot;unicode/locid.h&quot;
  35 #include &quot;unicode/numfmt.h&quot;
  36 #include &quot;unicode/unistr.h&quot;
  37 #include &quot;unicode/strenum.h&quot;
  38 #include &quot;unicode/brkiter.h&quot;
  39 #include &quot;unicode/upluralrules.h&quot;
  40 
  41 U_NAMESPACE_BEGIN
  42 
  43 class NFRule;
  44 class NFRuleSet;
  45 class LocalizationInfo;
  46 class PluralFormat;
  47 class RuleBasedCollator;
  48 
  49 /**
  50  * Tags for the predefined rulesets.
  51  *
  52  * @stable ICU 2.2
  53  */
  54 enum URBNFRuleSetTag {
  55     URBNF_SPELLOUT,
  56     URBNF_ORDINAL,
  57     URBNF_DURATION,
  58     URBNF_NUMBERING_SYSTEM,
  59 #ifndef U_HIDE_DEPRECATED_API
  60     /**
  61      * One more than the highest normal URBNFRuleSetTag value.
  62      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
  63      */
  64     URBNF_COUNT
  65 #endif  // U_HIDE_DEPRECATED_API
  66 };
  67 
  68 /**
  69  * The RuleBasedNumberFormat class formats numbers according to a set of rules. This number formatter is
  70  * typically used for spelling out numeric values in words (e.g., 25,3476 as
  71  * &amp;quot;twenty-five thousand three hundred seventy-six&amp;quot; or &amp;quot;vingt-cinq mille trois
  72  * cents soixante-seize&amp;quot; or
  73  * &amp;quot;f&amp;uuml;nfundzwanzigtausenddreihundertsechsundsiebzig&amp;quot;), but can also be used for
  74  * other complicated formatting tasks, such as formatting a number of seconds as hours,
  75  * minutes and seconds (e.g., 3,730 as &amp;quot;1:02:10&amp;quot;).
  76  *
  77  * &lt;p&gt;The resources contain three predefined formatters for each locale: spellout, which
  78  * spells out a value in words (123 is &amp;quot;one hundred twenty-three&amp;quot;); ordinal, which
  79  * appends an ordinal suffix to the end of a numeral (123 is &amp;quot;123rd&amp;quot;); and
  80  * duration, which shows a duration in seconds as hours, minutes, and seconds (123 is
  81  * &amp;quot;2:03&amp;quot;).&amp;nbsp; The client can also define more specialized &lt;tt&gt;RuleBasedNumberFormat&lt;/tt&gt;s
  82  * by supplying programmer-defined rule sets.&lt;/p&gt;
  83  *
  84  * &lt;p&gt;The behavior of a &lt;tt&gt;RuleBasedNumberFormat&lt;/tt&gt; is specified by a textual description
  85  * that is either passed to the constructor as a &lt;tt&gt;String&lt;/tt&gt; or loaded from a resource
  86  * bundle. In its simplest form, the description consists of a semicolon-delimited list of &lt;em&gt;rules.&lt;/em&gt;
  87  * Each rule has a string of output text and a value or range of values it is applicable to.
  88  * In a typical spellout rule set, the first twenty rules are the words for the numbers from
  89  * 0 to 19:&lt;/p&gt;
  90  *
  91  * &lt;pre&gt;zero; one; two; three; four; five; six; seven; eight; nine;
  92  * ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen; seventeen; eighteen; nineteen;&lt;/pre&gt;
  93  *
  94  * &lt;p&gt;For larger numbers, we can use the preceding set of rules to format the ones place, and
  95  * we only have to supply the words for the multiples of 10:&lt;/p&gt;
  96  *
  97  * &lt;pre&gt; 20: twenty[-&amp;gt;&amp;gt;];
  98  * 30: thirty[-&amp;gt;&amp;gt;];
  99  * 40: forty[-&amp;gt;&amp;gt;];
 100  * 50: fifty[-&amp;gt;&amp;gt;];
 101  * 60: sixty[-&amp;gt;&amp;gt;];
 102  * 70: seventy[-&amp;gt;&amp;gt;];
 103  * 80: eighty[-&amp;gt;&amp;gt;];
 104  * 90: ninety[-&amp;gt;&amp;gt;];&lt;/pre&gt;
 105  *
 106  * &lt;p&gt;In these rules, the &lt;em&gt;base value&lt;/em&gt; is spelled out explicitly and set off from the
 107  * rule&#39;s output text with a colon. The rules are in a sorted list, and a rule is applicable
 108  * to all numbers from its own base value to one less than the next rule&#39;s base value. The
 109  * &amp;quot;&amp;gt;&amp;gt;&amp;quot; token is called a &lt;em&gt;substitution&lt;/em&gt; and tells the fomatter to
 110  * isolate the number&#39;s ones digit, format it using this same set of rules, and place the
 111  * result at the position of the &amp;quot;&amp;gt;&amp;gt;&amp;quot; token. Text in brackets is omitted if
 112  * the number being formatted is an even multiple of 10 (the hyphen is a literal hyphen; 24
 113  * is &amp;quot;twenty-four,&amp;quot; not &amp;quot;twenty four&amp;quot;).&lt;/p&gt;
 114  *
 115  * &lt;p&gt;For even larger numbers, we can actually look up several parts of the number in the
 116  * list:&lt;/p&gt;
 117  *
 118  * &lt;pre&gt;100: &amp;lt;&amp;lt; hundred[ &amp;gt;&amp;gt;];&lt;/pre&gt;
 119  *
 120  * &lt;p&gt;The &amp;quot;&amp;lt;&amp;lt;&amp;quot; represents a new kind of substitution. The &amp;lt;&amp;lt; isolates
 121  * the hundreds digit (and any digits to its left), formats it using this same rule set, and
 122  * places the result where the &amp;quot;&amp;lt;&amp;lt;&amp;quot; was. Notice also that the meaning of
 123  * &amp;gt;&amp;gt; has changed: it now refers to both the tens and the ones digits. The meaning of
 124  * both substitutions depends on the rule&#39;s base value. The base value determines the rule&#39;s &lt;em&gt;divisor,&lt;/em&gt;
 125  * which is the highest power of 10 that is less than or equal to the base value (the user
 126  * can change this). To fill in the substitutions, the formatter divides the number being
 127  * formatted by the divisor. The integral quotient is used to fill in the &amp;lt;&amp;lt;
 128  * substitution, and the remainder is used to fill in the &amp;gt;&amp;gt; substitution. The meaning
 129  * of the brackets changes similarly: text in brackets is omitted if the value being
 130  * formatted is an even multiple of the rule&#39;s divisor. The rules are applied recursively, so
 131  * if a substitution is filled in with text that includes another substitution, that
 132  * substitution is also filled in.&lt;/p&gt;
 133  *
 134  * &lt;p&gt;This rule covers values up to 999, at which point we add another rule:&lt;/p&gt;
 135  *
 136  * &lt;pre&gt;1000: &amp;lt;&amp;lt; thousand[ &amp;gt;&amp;gt;];&lt;/pre&gt;
 137  *
 138  * &lt;p&gt;Again, the meanings of the brackets and substitution tokens shift because the rule&#39;s
 139  * base value is a higher power of 10, changing the rule&#39;s divisor. This rule can actually be
 140  * used all the way up to 999,999. This allows us to finish out the rules as follows:&lt;/p&gt;
 141  *
 142  * &lt;pre&gt; 1,000,000: &amp;lt;&amp;lt; million[ &amp;gt;&amp;gt;];
 143  * 1,000,000,000: &amp;lt;&amp;lt; billion[ &amp;gt;&amp;gt;];
 144  * 1,000,000,000,000: &amp;lt;&amp;lt; trillion[ &amp;gt;&amp;gt;];
 145  * 1,000,000,000,000,000: OUT OF RANGE!;&lt;/pre&gt;
 146  *
 147  * &lt;p&gt;Commas, periods, and spaces can be used in the base values to improve legibility and
 148  * are ignored by the rule parser. The last rule in the list is customarily treated as an
 149  * &amp;quot;overflow rule,&amp;quot; applying to everything from its base value on up, and often (as
 150  * in this example) being used to print out an error message or default representation.
 151  * Notice also that the size of the major groupings in large numbers is controlled by the
 152  * spacing of the rules: because in English we group numbers by thousand, the higher rules
 153  * are separated from each other by a factor of 1,000.&lt;/p&gt;
 154  *
 155  * &lt;p&gt;To see how these rules actually work in practice, consider the following example:
 156  * Formatting 25,430 with this rule set would work like this:&lt;/p&gt;
 157  *
 158  * &lt;table border=&quot;0&quot; width=&quot;100%&quot;&gt;
 159  *   &lt;tr&gt;
 160  *     &lt;td&gt;&lt;strong&gt;&amp;lt;&amp;lt; thousand &amp;gt;&amp;gt;&lt;/strong&gt;&lt;/td&gt;
 161  *     &lt;td&gt;[the rule whose base value is 1,000 is applicable to 25,340]&lt;/td&gt;
 162  *   &lt;/tr&gt;
 163  *   &lt;tr&gt;
 164  *     &lt;td&gt;&lt;strong&gt;twenty-&amp;gt;&amp;gt;&lt;/strong&gt; thousand &amp;gt;&amp;gt;&lt;/td&gt;
 165  *     &lt;td&gt;[25,340 over 1,000 is 25. The rule for 20 applies.]&lt;/td&gt;
 166  *   &lt;/tr&gt;
 167  *   &lt;tr&gt;
 168  *     &lt;td&gt;twenty-&lt;strong&gt;five&lt;/strong&gt; thousand &amp;gt;&amp;gt;&lt;/td&gt;
 169  *     &lt;td&gt;[25 mod 10 is 5. The rule for 5 is &amp;quot;five.&amp;quot;&lt;/td&gt;
 170  *   &lt;/tr&gt;
 171  *   &lt;tr&gt;
 172  *     &lt;td&gt;twenty-five thousand &lt;strong&gt;&amp;lt;&amp;lt; hundred &amp;gt;&amp;gt;&lt;/strong&gt;&lt;/td&gt;
 173  *     &lt;td&gt;[25,340 mod 1,000 is 340. The rule for 100 applies.]&lt;/td&gt;
 174  *   &lt;/tr&gt;
 175  *   &lt;tr&gt;
 176  *     &lt;td&gt;twenty-five thousand &lt;strong&gt;three&lt;/strong&gt; hundred &amp;gt;&amp;gt;&lt;/td&gt;
 177  *     &lt;td&gt;[340 over 100 is 3. The rule for 3 is &amp;quot;three.&amp;quot;]&lt;/td&gt;
 178  *   &lt;/tr&gt;
 179  *   &lt;tr&gt;
 180  *     &lt;td&gt;twenty-five thousand three hundred &lt;strong&gt;forty&lt;/strong&gt;&lt;/td&gt;
 181  *     &lt;td&gt;[340 mod 100 is 40. The rule for 40 applies. Since 40 divides
 182  *     evenly by 10, the hyphen and substitution in the brackets are omitted.]&lt;/td&gt;
 183  *   &lt;/tr&gt;
 184  * &lt;/table&gt;
 185  *
 186  * &lt;p&gt;The above syntax suffices only to format positive integers. To format negative numbers,
 187  * we add a special rule:&lt;/p&gt;
 188  *
 189  * &lt;pre&gt;-x: minus &amp;gt;&amp;gt;;&lt;/pre&gt;
 190  *
 191  * &lt;p&gt;This is called a &lt;em&gt;negative-number rule,&lt;/em&gt; and is identified by &amp;quot;-x&amp;quot;
 192  * where the base value would be. This rule is used to format all negative numbers. the
 193  * &amp;gt;&amp;gt; token here means &amp;quot;find the number&#39;s absolute value, format it with these
 194  * rules, and put the result here.&amp;quot;&lt;/p&gt;
 195  *
 196  * &lt;p&gt;We also add a special rule called a &lt;em&gt;fraction rule &lt;/em&gt;for numbers with fractional
 197  * parts:&lt;/p&gt;
 198  *
 199  * &lt;pre&gt;x.x: &amp;lt;&amp;lt; point &amp;gt;&amp;gt;;&lt;/pre&gt;
 200  *
 201  * &lt;p&gt;This rule is used for all positive non-integers (negative non-integers pass through the
 202  * negative-number rule first and then through this rule). Here, the &amp;lt;&amp;lt; token refers to
 203  * the number&#39;s integral part, and the &amp;gt;&amp;gt; to the number&#39;s fractional part. The
 204  * fractional part is formatted as a series of single-digit numbers (e.g., 123.456 would be
 205  * formatted as &amp;quot;one hundred twenty-three point four five six&amp;quot;).&lt;/p&gt;
 206  *
 207  * &lt;p&gt;To see how this rule syntax is applied to various languages, examine the resource data.&lt;/p&gt;
 208  *
 209  * &lt;p&gt;There is actually much more flexibility built into the rule language than the
 210  * description above shows. A formatter may own multiple rule sets, which can be selected by
 211  * the caller, and which can use each other to fill in their substitutions. Substitutions can
 212  * also be filled in with digits, using a DecimalFormat object. There is syntax that can be
 213  * used to alter a rule&#39;s divisor in various ways. And there is provision for much more
 214  * flexible fraction handling. A complete description of the rule syntax follows:&lt;/p&gt;
 215  *
 216  * &lt;hr&gt;
 217  *
 218  * &lt;p&gt;The description of a &lt;tt&gt;RuleBasedNumberFormat&lt;/tt&gt;&#39;s behavior consists of one or more &lt;em&gt;rule
 219  * sets.&lt;/em&gt; Each rule set consists of a name, a colon, and a list of &lt;em&gt;rules.&lt;/em&gt; A rule
 220  * set name must begin with a % sign. Rule sets with names that begin with a single % sign
 221  * are &lt;em&gt;public:&lt;/em&gt; the caller can specify that they be used to format and parse numbers.
 222  * Rule sets with names that begin with %% are &lt;em&gt;private:&lt;/em&gt; they exist only for the use
 223  * of other rule sets. If a formatter only has one rule set, the name may be omitted.&lt;/p&gt;
 224  *
 225  * &lt;p&gt;The user can also specify a special &amp;quot;rule set&amp;quot; named &lt;tt&gt;%%lenient-parse&lt;/tt&gt;.
 226  * The body of &lt;tt&gt;%%lenient-parse&lt;/tt&gt; isn&#39;t a set of number-formatting rules, but a &lt;tt&gt;RuleBasedCollator&lt;/tt&gt;
 227  * description which is used to define equivalences for lenient parsing. For more information
 228  * on the syntax, see &lt;tt&gt;RuleBasedCollator&lt;/tt&gt;. For more information on lenient parsing,
 229  * see &lt;tt&gt;setLenientParse()&lt;/tt&gt;.  &lt;em&gt;Note:&lt;/em&gt; symbols that have syntactic meaning
 230  * in collation rules, such as &#39;&amp;amp;&#39;, have no particular meaning when appearing outside
 231  * of the &lt;tt&gt;lenient-parse&lt;/tt&gt; rule set.&lt;/p&gt;
 232  *
 233  * &lt;p&gt;The body of a rule set consists of an ordered, semicolon-delimited list of &lt;em&gt;rules.&lt;/em&gt;
 234  * Internally, every rule has a base value, a divisor, rule text, and zero, one, or two &lt;em&gt;substitutions.&lt;/em&gt;
 235  * These parameters are controlled by the description syntax, which consists of a &lt;em&gt;rule
 236  * descriptor,&lt;/em&gt; a colon, and a &lt;em&gt;rule body.&lt;/em&gt;&lt;/p&gt;
 237  *
 238  * &lt;p&gt;A rule descriptor can take one of the following forms (text in &lt;em&gt;italics&lt;/em&gt; is the
 239  * name of a token):&lt;/p&gt;
 240  *
 241  * &lt;table border=&quot;0&quot; width=&quot;100%&quot;&gt;
 242  *   &lt;tr&gt;
 243  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt;:&lt;/td&gt;
 244  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt; specifies the rule&#39;s base value. &lt;em&gt;bv&lt;/em&gt; is a decimal
 245  *     number expressed using ASCII digits. &lt;em&gt;bv&lt;/em&gt; may contain spaces, period, and commas,
 246  *     which are ignored. The rule&#39;s divisor is the highest power of 10 less than or equal to
 247  *     the base value.&lt;/td&gt;
 248  *   &lt;/tr&gt;
 249  *   &lt;tr&gt;
 250  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt;/&lt;em&gt;rad&lt;/em&gt;:&lt;/td&gt;
 251  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt; specifies the rule&#39;s base value. The rule&#39;s divisor is the
 252  *     highest power of &lt;em&gt;rad&lt;/em&gt; less than or equal to the base value.&lt;/td&gt;
 253  *   &lt;/tr&gt;
 254  *   &lt;tr&gt;
 255  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt;&amp;gt;:&lt;/td&gt;
 256  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt; specifies the rule&#39;s base value. To calculate the divisor,
 257  *     let the radix be 10, and the exponent be the highest exponent of the radix that yields a
 258  *     result less than or equal to the base value. Every &amp;gt; character after the base value
 259  *     decreases the exponent by 1. If the exponent is positive or 0, the divisor is the radix
 260  *     raised to the power of the exponent; otherwise, the divisor is 1.&lt;/td&gt;
 261  *   &lt;/tr&gt;
 262  *   &lt;tr&gt;
 263  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt;/&lt;em&gt;rad&lt;/em&gt;&amp;gt;:&lt;/td&gt;
 264  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt; specifies the rule&#39;s base value. To calculate the divisor,
 265  *     let the radix be &lt;em&gt;rad&lt;/em&gt;, and the exponent be the highest exponent of the radix that
 266  *     yields a result less than or equal to the base value. Every &amp;gt; character after the radix
 267  *     decreases the exponent by 1. If the exponent is positive or 0, the divisor is the radix
 268  *     raised to the power of the exponent; otherwise, the divisor is 1.&lt;/td&gt;
 269  *   &lt;/tr&gt;
 270  *   &lt;tr&gt;
 271  *     &lt;td&gt;-x:&lt;/td&gt;
 272  *     &lt;td&gt;The rule is a negative-number rule.&lt;/td&gt;
 273  *   &lt;/tr&gt;
 274  *   &lt;tr&gt;
 275  *     &lt;td&gt;x.x:&lt;/td&gt;
 276  *     &lt;td&gt;The rule is an &lt;em&gt;improper fraction rule&lt;/em&gt;. If the full stop in
 277  *     the middle of the rule name is replaced with the decimal point
 278  *     that is used in the language or DecimalFormatSymbols, then that rule will
 279  *     have precedence when formatting and parsing this rule. For example, some
 280  *     languages use the comma, and can thus be written as x,x instead. For example,
 281  *     you can use &quot;x.x: &amp;lt;&amp;lt; point &amp;gt;&amp;gt;;x,x: &amp;lt;&amp;lt; comma &amp;gt;&amp;gt;;&quot; to
 282  *     handle the decimal point that matches the language&#39;s natural spelling of
 283  *     the punctuation of either the full stop or comma.&lt;/td&gt;
 284  *   &lt;/tr&gt;
 285  *   &lt;tr&gt;
 286  *     &lt;td&gt;0.x:&lt;/td&gt;
 287  *     &lt;td&gt;The rule is a &lt;em&gt;proper fraction rule&lt;/em&gt;. If the full stop in
 288  *     the middle of the rule name is replaced with the decimal point
 289  *     that is used in the language or DecimalFormatSymbols, then that rule will
 290  *     have precedence when formatting and parsing this rule. For example, some
 291  *     languages use the comma, and can thus be written as 0,x instead. For example,
 292  *     you can use &quot;0.x: point &amp;gt;&amp;gt;;0,x: comma &amp;gt;&amp;gt;;&quot; to
 293  *     handle the decimal point that matches the language&#39;s natural spelling of
 294  *     the punctuation of either the full stop or comma.&lt;/td&gt;
 295  *   &lt;/tr&gt;
 296  *   &lt;tr&gt;
 297  *     &lt;td&gt;x.0:&lt;/td&gt;
 298  *     &lt;td&gt;The rule is a &lt;em&gt;master rule&lt;/em&gt;. If the full stop in
 299  *     the middle of the rule name is replaced with the decimal point
 300  *     that is used in the language or DecimalFormatSymbols, then that rule will
 301  *     have precedence when formatting and parsing this rule. For example, some
 302  *     languages use the comma, and can thus be written as x,0 instead. For example,
 303  *     you can use &quot;x.0: &amp;lt;&amp;lt; point;x,0: &amp;lt;&amp;lt; comma;&quot; to
 304  *     handle the decimal point that matches the language&#39;s natural spelling of
 305  *     the punctuation of either the full stop or comma.&lt;/td&gt;
 306  *   &lt;/tr&gt;
 307  *   &lt;tr&gt;
 308  *     &lt;td&gt;Inf:&lt;/td&gt;
 309  *     &lt;td&gt;The rule for infinity.&lt;/td&gt;
 310  *   &lt;/tr&gt;
 311  *   &lt;tr&gt;
 312  *     &lt;td&gt;NaN:&lt;/td&gt;
 313  *     &lt;td&gt;The rule for an IEEE 754 NaN (not a number).&lt;/td&gt;
 314  *   &lt;/tr&gt;
 315  *   &lt;tr&gt;
 316  *     &lt;td&gt;&lt;em&gt;nothing&lt;/em&gt;&lt;/td&gt;
 317  *     &lt;td&gt;If the rule&#39;s rule descriptor is left out, the base value is one plus the
 318  *     preceding rule&#39;s base value (or zero if this is the first rule in the list) in a normal
 319  *     rule set.&amp;nbsp; In a fraction rule set, the base value is the same as the preceding rule&#39;s
 320  *     base value.&lt;/td&gt;
 321  *   &lt;/tr&gt;
 322  * &lt;/table&gt;
 323  *
 324  * &lt;p&gt;A rule set may be either a regular rule set or a &lt;em&gt;fraction rule set,&lt;/em&gt; depending
 325  * on whether it is used to format a number&#39;s integral part (or the whole number) or a
 326  * number&#39;s fractional part. Using a rule set to format a rule&#39;s fractional part makes it a
 327  * fraction rule set.&lt;/p&gt;
 328  *
 329  * &lt;p&gt;Which rule is used to format a number is defined according to one of the following
 330  * algorithms: If the rule set is a regular rule set, do the following:
 331  *
 332  * &lt;ul&gt;
 333  *   &lt;li&gt;If the rule set includes a master rule (and the number was passed in as a &lt;tt&gt;double&lt;/tt&gt;),
 334  *     use the master rule.&amp;nbsp; (If the number being formatted was passed in as a &lt;tt&gt;long&lt;/tt&gt;,
 335  *     the master rule is ignored.)&lt;/li&gt;
 336  *   &lt;li&gt;If the number is negative, use the negative-number rule.&lt;/li&gt;
 337  *   &lt;li&gt;If the number has a fractional part and is greater than 1, use the improper fraction
 338  *     rule.&lt;/li&gt;
 339  *   &lt;li&gt;If the number has a fractional part and is between 0 and 1, use the proper fraction
 340  *     rule.&lt;/li&gt;
 341  *   &lt;li&gt;Binary-search the rule list for the rule with the highest base value less than or equal
 342  *     to the number. If that rule has two substitutions, its base value is not an even multiple
 343  *     of its divisor, and the number &lt;em&gt;is&lt;/em&gt; an even multiple of the rule&#39;s divisor, use the
 344  *     rule that precedes it in the rule list. Otherwise, use the rule itself.&lt;/li&gt;
 345  * &lt;/ul&gt;
 346  *
 347  * &lt;p&gt;If the rule set is a fraction rule set, do the following:
 348  *
 349  * &lt;ul&gt;
 350  *   &lt;li&gt;Ignore negative-number and fraction rules.&lt;/li&gt;
 351  *   &lt;li&gt;For each rule in the list, multiply the number being formatted (which will always be
 352  *     between 0 and 1) by the rule&#39;s base value. Keep track of the distance between the result
 353  *     the nearest integer.&lt;/li&gt;
 354  *   &lt;li&gt;Use the rule that produced the result closest to zero in the above calculation. In the
 355  *     event of a tie or a direct hit, use the first matching rule encountered. (The idea here is
 356  *     to try each rule&#39;s base value as a possible denominator of a fraction. Whichever
 357  *     denominator produces the fraction closest in value to the number being formatted wins.) If
 358  *     the rule following the matching rule has the same base value, use it if the numerator of
 359  *     the fraction is anything other than 1; if the numerator is 1, use the original matching
 360  *     rule. (This is to allow singular and plural forms of the rule text without a lot of extra
 361  *     hassle.)&lt;/li&gt;
 362  * &lt;/ul&gt;
 363  *
 364  * &lt;p&gt;A rule&#39;s body consists of a string of characters terminated by a semicolon. The rule
 365  * may include zero, one, or two &lt;em&gt;substitution tokens,&lt;/em&gt; and a range of text in
 366  * brackets. The brackets denote optional text (and may also include one or both
 367  * substitutions). The exact meanings of the substitution tokens, and under what conditions
 368  * optional text is omitted, depend on the syntax of the substitution token and the context.
 369  * The rest of the text in a rule body is literal text that is output when the rule matches
 370  * the number being formatted.&lt;/p&gt;
 371  *
 372  * &lt;p&gt;A substitution token begins and ends with a &lt;em&gt;token character.&lt;/em&gt; The token
 373  * character and the context together specify a mathematical operation to be performed on the
 374  * number being formatted. An optional &lt;em&gt;substitution descriptor &lt;/em&gt;specifies how the
 375  * value resulting from that operation is used to fill in the substitution. The position of
 376  * the substitution token in the rule body specifies the location of the resultant text in
 377  * the original rule text.&lt;/p&gt;
 378  *
 379  * &lt;p&gt;The meanings of the substitution token characters are as follows:&lt;/p&gt;
 380  *
 381  * &lt;table border=&quot;0&quot; width=&quot;100%&quot;&gt;
 382  *   &lt;tr&gt;
 383  *     &lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
 384  *     &lt;td&gt;in normal rule&lt;/td&gt;
 385  *     &lt;td&gt;Divide the number by the rule&#39;s divisor and format the remainder&lt;/td&gt;
 386  *   &lt;/tr&gt;
 387  *   &lt;tr&gt;
 388  *     &lt;td&gt;&lt;/td&gt;
 389  *     &lt;td&gt;in negative-number rule&lt;/td&gt;
 390  *     &lt;td&gt;Find the absolute value of the number and format the result&lt;/td&gt;
 391  *   &lt;/tr&gt;
 392  *   &lt;tr&gt;
 393  *     &lt;td&gt;&lt;/td&gt;
 394  *     &lt;td&gt;in fraction or master rule&lt;/td&gt;
 395  *     &lt;td&gt;Isolate the number&#39;s fractional part and format it.&lt;/td&gt;
 396  *   &lt;/tr&gt;
 397  *   &lt;tr&gt;
 398  *     &lt;td&gt;&lt;/td&gt;
 399  *     &lt;td&gt;in rule in fraction rule set&lt;/td&gt;
 400  *     &lt;td&gt;Not allowed.&lt;/td&gt;
 401  *   &lt;/tr&gt;
 402  *   &lt;tr&gt;
 403  *     &lt;td&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/td&gt;
 404  *     &lt;td&gt;in normal rule&lt;/td&gt;
 405  *     &lt;td&gt;Divide the number by the rule&#39;s divisor and format the remainder,
 406  *       but bypass the normal rule-selection process and just use the
 407  *       rule that precedes this one in this rule list.&lt;/td&gt;
 408  *   &lt;/tr&gt;
 409  *   &lt;tr&gt;
 410  *     &lt;td&gt;&lt;/td&gt;
 411  *     &lt;td&gt;in all other rules&lt;/td&gt;
 412  *     &lt;td&gt;Not allowed.&lt;/td&gt;
 413  *   &lt;/tr&gt;
 414  *   &lt;tr&gt;
 415  *     &lt;td&gt;&amp;lt;&amp;lt;&lt;/td&gt;
 416  *     &lt;td&gt;in normal rule&lt;/td&gt;
 417  *     &lt;td&gt;Divide the number by the rule&#39;s divisor and format the quotient&lt;/td&gt;
 418  *   &lt;/tr&gt;
 419  *   &lt;tr&gt;
 420  *     &lt;td&gt;&lt;/td&gt;
 421  *     &lt;td&gt;in negative-number rule&lt;/td&gt;
 422  *     &lt;td&gt;Not allowed.&lt;/td&gt;
 423  *   &lt;/tr&gt;
 424  *   &lt;tr&gt;
 425  *     &lt;td&gt;&lt;/td&gt;
 426  *     &lt;td&gt;in fraction or master rule&lt;/td&gt;
 427  *     &lt;td&gt;Isolate the number&#39;s integral part and format it.&lt;/td&gt;
 428  *   &lt;/tr&gt;
 429  *   &lt;tr&gt;
 430  *     &lt;td&gt;&lt;/td&gt;
 431  *     &lt;td&gt;in rule in fraction rule set&lt;/td&gt;
 432  *     &lt;td&gt;Multiply the number by the rule&#39;s base value and format the result.&lt;/td&gt;
 433  *   &lt;/tr&gt;
 434  *   &lt;tr&gt;
 435  *     &lt;td&gt;==&lt;/td&gt;
 436  *     &lt;td&gt;in all rule sets&lt;/td&gt;
 437  *     &lt;td&gt;Format the number unchanged&lt;/td&gt;
 438  *   &lt;/tr&gt;
 439  *   &lt;tr&gt;
 440  *     &lt;td&gt;[]&lt;/td&gt;
 441  *     &lt;td&gt;in normal rule&lt;/td&gt;
 442  *     &lt;td&gt;Omit the optional text if the number is an even multiple of the rule&#39;s divisor&lt;/td&gt;
 443  *   &lt;/tr&gt;
 444  *   &lt;tr&gt;
 445  *     &lt;td&gt;&lt;/td&gt;
 446  *     &lt;td&gt;in negative-number rule&lt;/td&gt;
 447  *     &lt;td&gt;Not allowed.&lt;/td&gt;
 448  *   &lt;/tr&gt;
 449  *   &lt;tr&gt;
 450  *     &lt;td&gt;&lt;/td&gt;
 451  *     &lt;td&gt;in improper-fraction rule&lt;/td&gt;
 452  *     &lt;td&gt;Omit the optional text if the number is between 0 and 1 (same as specifying both an
 453  *     x.x rule and a 0.x rule)&lt;/td&gt;
 454  *   &lt;/tr&gt;
 455  *   &lt;tr&gt;
 456  *     &lt;td&gt;&lt;/td&gt;
 457  *     &lt;td&gt;in master rule&lt;/td&gt;
 458  *     &lt;td&gt;Omit the optional text if the number is an integer (same as specifying both an x.x
 459  *     rule and an x.0 rule)&lt;/td&gt;
 460  *   &lt;/tr&gt;
 461  *   &lt;tr&gt;
 462  *     &lt;td&gt;&lt;/td&gt;
 463  *     &lt;td&gt;in proper-fraction rule&lt;/td&gt;
 464  *     &lt;td&gt;Not allowed.&lt;/td&gt;
 465  *   &lt;/tr&gt;
 466  *   &lt;tr&gt;
 467  *     &lt;td&gt;&lt;/td&gt;
 468  *     &lt;td&gt;in rule in fraction rule set&lt;/td&gt;
 469  *     &lt;td&gt;Omit the optional text if multiplying the number by the rule&#39;s base value yields 1.&lt;/td&gt;
 470  *   &lt;/tr&gt;
 471  *   &lt;tr&gt;
 472  *     &lt;td width=&quot;37&quot;&gt;$(cardinal,&lt;i&gt;plural syntax&lt;/i&gt;)$&lt;/td&gt;
 473  *     &lt;td width=&quot;23&quot;&gt;&lt;/td&gt;
 474  *     &lt;td width=&quot;165&quot; valign=&quot;top&quot;&gt;in all rule sets&lt;/td&gt;
 475  *     &lt;td&gt;This provides the ability to choose a word based on the number divided by the radix to the power of the
 476  *     exponent of the base value for the specified locale, which is normally equivalent to the &amp;lt;&amp;lt; value.
 477  *     This uses the cardinal plural rules from PluralFormat. All strings used in the plural format are treated
 478  *     as the same base value for parsing.&lt;/td&gt;
 479  *   &lt;/tr&gt;
 480  *   &lt;tr&gt;
 481  *     &lt;td width=&quot;37&quot;&gt;$(ordinal,&lt;i&gt;plural syntax&lt;/i&gt;)$&lt;/td&gt;
 482  *     &lt;td width=&quot;23&quot;&gt;&lt;/td&gt;
 483  *     &lt;td width=&quot;165&quot; valign=&quot;top&quot;&gt;in all rule sets&lt;/td&gt;
 484  *     &lt;td&gt;This provides the ability to choose a word based on the number divided by the radix to the power of the
 485  *     exponent of the base value for the specified locale, which is normally equivalent to the &amp;lt;&amp;lt; value.
 486  *     This uses the ordinal plural rules from PluralFormat. All strings used in the plural format are treated
 487  *     as the same base value for parsing.&lt;/td&gt;
 488  *   &lt;/tr&gt;
 489  * &lt;/table&gt;
 490  *
 491  * &lt;p&gt;The substitution descriptor (i.e., the text between the token characters) may take one
 492  * of three forms:&lt;/p&gt;
 493  *
 494  * &lt;table border=&quot;0&quot; width=&quot;100%&quot;&gt;
 495  *   &lt;tr&gt;
 496  *     &lt;td&gt;a rule set name&lt;/td&gt;
 497  *     &lt;td&gt;Perform the mathematical operation on the number, and format the result using the
 498  *     named rule set.&lt;/td&gt;
 499  *   &lt;/tr&gt;
 500  *   &lt;tr&gt;
 501  *     &lt;td&gt;a DecimalFormat pattern&lt;/td&gt;
 502  *     &lt;td&gt;Perform the mathematical operation on the number, and format the result using a
 503  *     DecimalFormat with the specified pattern.&amp;nbsp; The pattern must begin with 0 or #.&lt;/td&gt;
 504  *   &lt;/tr&gt;
 505  *   &lt;tr&gt;
 506  *     &lt;td&gt;nothing&lt;/td&gt;
 507  *     &lt;td&gt;Perform the mathematical operation on the number, and format the result using the rule
 508  *     set containing the current rule, except:
 509  *     &lt;ul&gt;
 510  *       &lt;li&gt;You can&#39;t have an empty substitution descriptor with a == substitution.&lt;/li&gt;
 511  *       &lt;li&gt;If you omit the substitution descriptor in a &amp;gt;&amp;gt; substitution in a fraction rule,
 512  *         format the result one digit at a time using the rule set containing the current rule.&lt;/li&gt;
 513  *       &lt;li&gt;If you omit the substitution descriptor in a &amp;lt;&amp;lt; substitution in a rule in a
 514  *         fraction rule set, format the result using the default rule set for this formatter.&lt;/li&gt;
 515  *     &lt;/ul&gt;
 516  *     &lt;/td&gt;
 517  *   &lt;/tr&gt;
 518  * &lt;/table&gt;
 519  *
 520  * &lt;p&gt;Whitespace is ignored between a rule set name and a rule set body, between a rule
 521  * descriptor and a rule body, or between rules. If a rule body begins with an apostrophe,
 522  * the apostrophe is ignored, but all text after it becomes significant (this is how you can
 523  * have a rule&#39;s rule text begin with whitespace). There is no escape function: the semicolon
 524  * is not allowed in rule set names or in rule text, and the colon is not allowed in rule set
 525  * names. The characters beginning a substitution token are always treated as the beginning
 526  * of a substitution token.&lt;/p&gt;
 527  *
 528  * &lt;p&gt;See the resource data and the demo program for annotated examples of real rule sets
 529  * using these features.&lt;/p&gt;
 530  *
 531  * &lt;p&gt;&lt;em&gt;User subclasses are not supported.&lt;/em&gt; While clients may write
 532  * subclasses, such code will not necessarily work and will not be
 533  * guaranteed to work stably from release to release.
 534  *
 535  * &lt;p&gt;&lt;b&gt;Localizations&lt;/b&gt;&lt;/p&gt;
 536  * &lt;p&gt;Constructors are available that allow the specification of localizations for the
 537  * public rule sets (and also allow more control over what public rule sets are available).
 538  * Localization data is represented as a textual description.  The description represents
 539  * an array of arrays of string.  The first element is an array of the public rule set names,
 540  * each of these must be one of the public rule set names that appear in the rules.  Only
 541  * names in this array will be treated as public rule set names by the API.  Each subsequent
 542  * element is an array of localizations of these names.  The first element of one of these
 543  * subarrays is the locale name, and the remaining elements are localizations of the
 544  * public rule set names, in the same order as they were listed in the first arrray.&lt;/p&gt;
 545  * &lt;p&gt;In the syntax, angle brackets &#39;&lt;&#39;, &#39;&gt;&#39; are used to delimit the arrays, and comma &#39;,&#39; is used
 546  * to separate elements of an array.  Whitespace is ignored, unless quoted.&lt;/p&gt;
 547  * &lt;p&gt;For example:&lt;pre&gt;
 548  * &lt; &lt; %foo, %bar, %baz &gt;,
 549  *   &lt; en, Foo, Bar, Baz &gt;,
 550  *   &lt; fr, &#39;le Foo&#39;, &#39;le Bar&#39;, &#39;le Baz&#39; &gt;
 551  *   &lt; zh, \\u7532, \\u4e59, \\u4e19 &gt; &gt;
 552  * &lt;/pre&gt;&lt;/p&gt;
 553  * @author Richard Gillam
 554  * @see NumberFormat
 555  * @see DecimalFormat
 556  * @see PluralFormat
 557  * @see PluralRules
 558  * @stable ICU 2.0
 559  */
 560 class U_I18N_API RuleBasedNumberFormat : public NumberFormat {
 561 public:
 562 
 563   //-----------------------------------------------------------------------
 564   // constructors
 565   //-----------------------------------------------------------------------
 566 
 567     /**
 568      * Creates a RuleBasedNumberFormat that behaves according to the description
 569      * passed in.  The formatter uses the default locale.
 570      * @param rules A description of the formatter&#39;s desired behavior.
 571      * See the class documentation for a complete explanation of the description
 572      * syntax.
 573      * @param perror The parse error if an error was encountered.
 574      * @param status The status indicating whether the constructor succeeded.
 575      * @stable ICU 3.2
 576      */
 577     RuleBasedNumberFormat(const UnicodeString&amp; rules, UParseError&amp; perror, UErrorCode&amp; status);
 578 
 579     /**
 580      * Creates a RuleBasedNumberFormat that behaves according to the description
 581      * passed in.  The formatter uses the default locale.
 582      * &lt;p&gt;
 583      * The localizations data provides information about the public
 584      * rule sets and their localized display names for different
 585      * locales. The first element in the list is an array of the names
 586      * of the public rule sets.  The first element in this array is
 587      * the initial default ruleset.  The remaining elements in the
 588      * list are arrays of localizations of the names of the public
 589      * rule sets.  Each of these is one longer than the initial array,
 590      * with the first String being the ULocale ID, and the remaining
 591      * Strings being the localizations of the rule set names, in the
 592      * same order as the initial array.  Arrays are NULL-terminated.
 593      * @param rules A description of the formatter&#39;s desired behavior.
 594      * See the class documentation for a complete explanation of the description
 595      * syntax.
 596      * @param localizations the localization information.
 597      * names in the description.  These will be copied by the constructor.
 598      * @param perror The parse error if an error was encountered.
 599      * @param status The status indicating whether the constructor succeeded.
 600      * @stable ICU 3.2
 601      */
 602     RuleBasedNumberFormat(const UnicodeString&amp; rules, const UnicodeString&amp; localizations,
 603                         UParseError&amp; perror, UErrorCode&amp; status);
 604 
 605   /**
 606    * Creates a RuleBasedNumberFormat that behaves according to the rules
 607    * passed in.  The formatter uses the specified locale to determine the
 608    * characters to use when formatting numerals, and to define equivalences
 609    * for lenient parsing.
 610    * @param rules The formatter rules.
 611    * See the class documentation for a complete explanation of the rule
 612    * syntax.
 613    * @param locale A locale that governs which characters are used for
 614    * formatting values in numerals and which characters are equivalent in
 615    * lenient parsing.
 616    * @param perror The parse error if an error was encountered.
 617    * @param status The status indicating whether the constructor succeeded.
 618    * @stable ICU 2.0
 619    */
 620   RuleBasedNumberFormat(const UnicodeString&amp; rules, const Locale&amp; locale,
 621                         UParseError&amp; perror, UErrorCode&amp; status);
 622 
 623     /**
 624      * Creates a RuleBasedNumberFormat that behaves according to the description
 625      * passed in.  The formatter uses the default locale.
 626      * &lt;p&gt;
 627      * The localizations data provides information about the public
 628      * rule sets and their localized display names for different
 629      * locales. The first element in the list is an array of the names
 630      * of the public rule sets.  The first element in this array is
 631      * the initial default ruleset.  The remaining elements in the
 632      * list are arrays of localizations of the names of the public
 633      * rule sets.  Each of these is one longer than the initial array,
 634      * with the first String being the ULocale ID, and the remaining
 635      * Strings being the localizations of the rule set names, in the
 636      * same order as the initial array.  Arrays are NULL-terminated.
 637      * @param rules A description of the formatter&#39;s desired behavior.
 638      * See the class documentation for a complete explanation of the description
 639      * syntax.
 640      * @param localizations a list of localizations for the rule set
 641      * names in the description.  These will be copied by the constructor.
 642      * @param locale A locale that governs which characters are used for
 643      * formatting values in numerals and which characters are equivalent in
 644      * lenient parsing.
 645      * @param perror The parse error if an error was encountered.
 646      * @param status The status indicating whether the constructor succeeded.
 647      * @stable ICU 3.2
 648      */
 649     RuleBasedNumberFormat(const UnicodeString&amp; rules, const UnicodeString&amp; localizations,
 650                         const Locale&amp; locale, UParseError&amp; perror, UErrorCode&amp; status);
 651 
 652   /**
 653    * Creates a RuleBasedNumberFormat from a predefined ruleset.  The selector
 654    * code choosed among three possible predefined formats: spellout, ordinal,
 655    * and duration.
 656    * @param tag A selector code specifying which kind of formatter to create for that
 657    * locale.  There are four legal values: URBNF_SPELLOUT, which creates a formatter that
 658    * spells out a value in words in the desired language, URBNF_ORDINAL, which attaches
 659    * an ordinal suffix from the desired language to the end of a number (e.g. &quot;123rd&quot;),
 660    * URBNF_DURATION, which formats a duration in seconds as hours, minutes, and seconds always rounding down,
 661    * and URBNF_NUMBERING_SYSTEM, which is used to invoke rules for alternate numbering
 662    * systems such as the Hebrew numbering system, or for Roman Numerals, etc.
 663    * @param locale The locale for the formatter.
 664    * @param status The status indicating whether the constructor succeeded.
 665    * @stable ICU 2.0
 666    */
 667   RuleBasedNumberFormat(URBNFRuleSetTag tag, const Locale&amp; locale, UErrorCode&amp; status);
 668 
 669   //-----------------------------------------------------------------------
 670   // boilerplate
 671   //-----------------------------------------------------------------------
 672 
 673   /**
 674    * Copy constructor
 675    * @param rhs    the object to be copied from.
 676    * @stable ICU 2.6
 677    */
 678   RuleBasedNumberFormat(const RuleBasedNumberFormat&amp; rhs);
 679 
 680   /**
 681    * Assignment operator
 682    * @param rhs    the object to be copied from.
 683    * @stable ICU 2.6
 684    */
 685   RuleBasedNumberFormat&amp; operator=(const RuleBasedNumberFormat&amp; rhs);
 686 
 687   /**
 688    * Release memory allocated for a RuleBasedNumberFormat when you are finished with it.
 689    * @stable ICU 2.6
 690    */
 691   virtual ~RuleBasedNumberFormat();
 692 
 693   /**
 694    * Clone this object polymorphically.  The caller is responsible
 695    * for deleting the result when done.
 696    * @return  A copy of the object.
 697    * @stable ICU 2.6
 698    */
 699   virtual Format* clone(void) const;
 700 
 701   /**
 702    * Return true if the given Format objects are semantically equal.
 703    * Objects of different subclasses are considered unequal.
 704    * @param other    the object to be compared with.
 705    * @return        true if the given Format objects are semantically equal.
 706    * @stable ICU 2.6
 707    */
 708   virtual UBool operator==(const Format&amp; other) const;
 709 
 710 //-----------------------------------------------------------------------
 711 // public API functions
 712 //-----------------------------------------------------------------------
 713 
 714   /**
 715    * return the rules that were provided to the RuleBasedNumberFormat.
 716    * @return the result String that was passed in
 717    * @stable ICU 2.0
 718    */
 719   virtual UnicodeString getRules() const;
 720 
 721   /**
 722    * Return the number of public rule set names.
 723    * @return the number of public rule set names.
 724    * @stable ICU 2.0
 725    */
 726   virtual int32_t getNumberOfRuleSetNames() const;
 727 
 728   /**
 729    * Return the name of the index&#39;th public ruleSet.  If index is not valid,
 730    * the function returns null.
 731    * @param index the index of the ruleset
 732    * @return the name of the index&#39;th public ruleSet.
 733    * @stable ICU 2.0
 734    */
 735   virtual UnicodeString getRuleSetName(int32_t index) const;
 736 
 737   /**
 738    * Return the number of locales for which we have localized rule set display names.
 739    * @return the number of locales for which we have localized rule set display names.
 740    * @stable ICU 3.2
 741    */
 742   virtual int32_t getNumberOfRuleSetDisplayNameLocales(void) const;
 743 
 744   /**
 745    * Return the index&#39;th display name locale.
 746    * @param index the index of the locale
 747    * @param status set to a failure code when this function fails
 748    * @return the locale
 749    * @see #getNumberOfRuleSetDisplayNameLocales
 750    * @stable ICU 3.2
 751    */
 752   virtual Locale getRuleSetDisplayNameLocale(int32_t index, UErrorCode&amp; status) const;
 753 
 754     /**
 755      * Return the rule set display names for the provided locale.  These are in the same order
 756      * as those returned by getRuleSetName.  The locale is matched against the locales for
 757      * which there is display name data, using normal fallback rules.  If no locale matches,
 758      * the default display names are returned.  (These are the internal rule set names minus
 759      * the leading &#39;%&#39;.)
 760      * @param index the index of the rule set
 761      * @param locale the locale (returned by getRuleSetDisplayNameLocales) for which the localized
 762      * display name is desired
 763      * @return the display name for the given index, which might be bogus if there is an error
 764      * @see #getRuleSetName
 765      * @stable ICU 3.2
 766      */
 767   virtual UnicodeString getRuleSetDisplayName(int32_t index,
 768                           const Locale&amp; locale = Locale::getDefault());
 769 
 770     /**
 771      * Return the rule set display name for the provided rule set and locale.
 772      * The locale is matched against the locales for which there is display name data, using
 773      * normal fallback rules.  If no locale matches, the default display name is returned.
 774      * @return the display name for the rule set
 775      * @stable ICU 3.2
 776      * @see #getRuleSetDisplayName
 777      */
 778   virtual UnicodeString getRuleSetDisplayName(const UnicodeString&amp; ruleSetName,
 779                           const Locale&amp; locale = Locale::getDefault());
 780 
 781 
 782   using NumberFormat::format;
 783 
 784   /**
 785    * Formats the specified 32-bit number using the default ruleset.
 786    * @param number The number to format.
 787    * @param toAppendTo the string that will hold the (appended) result
 788    * @param pos the fieldposition
 789    * @return A textual representation of the number.
 790    * @stable ICU 2.0
 791    */
 792   virtual UnicodeString&amp; format(int32_t number,
 793                                 UnicodeString&amp; toAppendTo,
 794                                 FieldPosition&amp; pos) const;
 795 
 796   /**
 797    * Formats the specified 64-bit number using the default ruleset.
 798    * @param number The number to format.
 799    * @param toAppendTo the string that will hold the (appended) result
 800    * @param pos the fieldposition
 801    * @return A textual representation of the number.
 802    * @stable ICU 2.1
 803    */
 804   virtual UnicodeString&amp; format(int64_t number,
 805                                 UnicodeString&amp; toAppendTo,
 806                                 FieldPosition&amp; pos) const;
 807   /**
 808    * Formats the specified number using the default ruleset.
 809    * @param number The number to format.
 810    * @param toAppendTo the string that will hold the (appended) result
 811    * @param pos the fieldposition
 812    * @return A textual representation of the number.
 813    * @stable ICU 2.0
 814    */
 815   virtual UnicodeString&amp; format(double number,
 816                                 UnicodeString&amp; toAppendTo,
 817                                 FieldPosition&amp; pos) const;
 818 
 819   /**
 820    * Formats the specified number using the named ruleset.
 821    * @param number The number to format.
 822    * @param ruleSetName The name of the rule set to format the number with.
 823    * This must be the name of a valid public rule set for this formatter.
 824    * @param toAppendTo the string that will hold the (appended) result
 825    * @param pos the fieldposition
 826    * @param status the status
 827    * @return A textual representation of the number.
 828    * @stable ICU 2.0
 829    */
 830   virtual UnicodeString&amp; format(int32_t number,
 831                                 const UnicodeString&amp; ruleSetName,
 832                                 UnicodeString&amp; toAppendTo,
 833                                 FieldPosition&amp; pos,
 834                                 UErrorCode&amp; status) const;
 835   /**
 836    * Formats the specified 64-bit number using the named ruleset.
 837    * @param number The number to format.
 838    * @param ruleSetName The name of the rule set to format the number with.
 839    * This must be the name of a valid public rule set for this formatter.
 840    * @param toAppendTo the string that will hold the (appended) result
 841    * @param pos the fieldposition
 842    * @param status the status
 843    * @return A textual representation of the number.
 844    * @stable ICU 2.1
 845    */
 846   virtual UnicodeString&amp; format(int64_t number,
 847                                 const UnicodeString&amp; ruleSetName,
 848                                 UnicodeString&amp; toAppendTo,
 849                                 FieldPosition&amp; pos,
 850                                 UErrorCode&amp; status) const;
 851   /**
 852    * Formats the specified number using the named ruleset.
 853    * @param number The number to format.
 854    * @param ruleSetName The name of the rule set to format the number with.
 855    * This must be the name of a valid public rule set for this formatter.
 856    * @param toAppendTo the string that will hold the (appended) result
 857    * @param pos the fieldposition
 858    * @param status the status
 859    * @return A textual representation of the number.
 860    * @stable ICU 2.0
 861    */
 862   virtual UnicodeString&amp; format(double number,
 863                                 const UnicodeString&amp; ruleSetName,
 864                                 UnicodeString&amp; toAppendTo,
 865                                 FieldPosition&amp; pos,
 866                                 UErrorCode&amp; status) const;
 867 
 868 protected:
 869     /**
 870      * Format a decimal number.
 871      * The number is a DigitList wrapper onto a floating point decimal number.
 872      * The default implementation in NumberFormat converts the decimal number
 873      * to a double and formats that.  Subclasses of NumberFormat that want
 874      * to specifically handle big decimal numbers must override this method.
 875      * class DecimalFormat does so.
 876      *
 877      * @param number    The number, a DigitList format Decimal Floating Point.
 878      * @param appendTo  Output parameter to receive result.
 879      *                  Result is appended to existing contents.
 880      * @param posIter   On return, can be used to iterate over positions
 881      *                  of fields generated by this format call.
 882      * @param status    Output param filled with success/failure status.
 883      * @return          Reference to &#39;appendTo&#39; parameter.
 884      * @internal
 885      */
 886     virtual UnicodeString&amp; format(const number::impl::DecimalQuantity &amp;number,
 887                                   UnicodeString&amp; appendTo,
 888                                   FieldPositionIterator* posIter,
 889                                   UErrorCode&amp; status) const;
 890 
 891     /**
 892      * Format a decimal number.
 893      * The number is a DigitList wrapper onto a floating point decimal number.
 894      * The default implementation in NumberFormat converts the decimal number
 895      * to a double and formats that.  Subclasses of NumberFormat that want
 896      * to specifically handle big decimal numbers must override this method.
 897      * class DecimalFormat does so.
 898      *
 899      * @param number    The number, a DigitList format Decimal Floating Point.
 900      * @param appendTo  Output parameter to receive result.
 901      *                  Result is appended to existing contents.
 902      * @param pos       On input: an alignment field, if desired.
 903      *                  On output: the offsets of the alignment field.
 904      * @param status    Output param filled with success/failure status.
 905      * @return          Reference to &#39;appendTo&#39; parameter.
 906      * @internal
 907      */
 908     virtual UnicodeString&amp; format(const number::impl::DecimalQuantity &amp;number,
 909                                   UnicodeString&amp; appendTo,
 910                                   FieldPosition&amp; pos,
 911                                   UErrorCode&amp; status) const;
 912 public:
 913 
 914   using NumberFormat::parse;
 915 
 916   /**
 917    * Parses the specfied string, beginning at the specified position, according
 918    * to this formatter&#39;s rules.  This will match the string against all of the
 919    * formatter&#39;s public rule sets and return the value corresponding to the longest
 920    * parseable substring.  This function&#39;s behavior is affected by the lenient
 921    * parse mode.
 922    * @param text The string to parse
 923    * @param result the result of the parse, either a double or a long.
 924    * @param parsePosition On entry, contains the position of the first character
 925    * in &quot;text&quot; to examine.  On exit, has been updated to contain the position
 926    * of the first character in &quot;text&quot; that wasn&#39;t consumed by the parse.
 927    * @see #setLenient
 928    * @stable ICU 2.0
 929    */
 930   virtual void parse(const UnicodeString&amp; text,
 931                      Formattable&amp; result,
 932                      ParsePosition&amp; parsePosition) const;
 933 
 934 #if !UCONFIG_NO_COLLATION
 935 
 936   /**
 937    * Turns lenient parse mode on and off.
 938    *
 939    * When in lenient parse mode, the formatter uses a Collator for parsing the text.
 940    * Only primary differences are treated as significant.  This means that case
 941    * differences, accent differences, alternate spellings of the same letter
 942    * (e.g., ae and a-umlaut in German), ignorable characters, etc. are ignored in
 943    * matching the text.  In many cases, numerals will be accepted in place of words
 944    * or phrases as well.
 945    *
 946    * For example, all of the following will correctly parse as 255 in English in
 947    * lenient-parse mode:
 948    * &lt;br&gt;&quot;two hundred fifty-five&quot;
 949    * &lt;br&gt;&quot;two hundred fifty five&quot;
 950    * &lt;br&gt;&quot;TWO HUNDRED FIFTY-FIVE&quot;
 951    * &lt;br&gt;&quot;twohundredfiftyfive&quot;
 952    * &lt;br&gt;&quot;2 hundred fifty-5&quot;
 953    *
 954    * The Collator used is determined by the locale that was
 955    * passed to this object on construction.  The description passed to this object
 956    * on construction may supply additional collation rules that are appended to the
 957    * end of the default collator for the locale, enabling additional equivalences
 958    * (such as adding more ignorable characters or permitting spelled-out version of
 959    * symbols; see the demo program for examples).
 960    *
 961    * It&#39;s important to emphasize that even strict parsing is relatively lenient: it
 962    * will accept some text that it won&#39;t produce as output.  In English, for example,
 963    * it will correctly parse &quot;two hundred zero&quot; and &quot;fifteen hundred&quot;.
 964    *
 965    * @param enabled If true, turns lenient-parse mode on; if false, turns it off.
 966    * @see RuleBasedCollator
 967    * @stable ICU 2.0
 968    */
 969   virtual void setLenient(UBool enabled);
 970 
 971   /**
 972    * Returns true if lenient-parse mode is turned on.  Lenient parsing is off
 973    * by default.
 974    * @return true if lenient-parse mode is turned on.
 975    * @see #setLenient
 976    * @stable ICU 2.0
 977    */
 978   virtual inline UBool isLenient(void) const;
 979 
 980 #endif
 981 
 982   /**
 983    * Override the default rule set to use.  If ruleSetName is null, reset
 984    * to the initial default rule set.  If the rule set is not a public rule set name,
 985    * U_ILLEGAL_ARGUMENT_ERROR is returned in status.
 986    * @param ruleSetName the name of the rule set, or null to reset the initial default.
 987    * @param status set to failure code when a problem occurs.
 988    * @stable ICU 2.6
 989    */
 990   virtual void setDefaultRuleSet(const UnicodeString&amp; ruleSetName, UErrorCode&amp; status);
 991 
 992   /**
 993    * Return the name of the current default rule set.  If the current rule set is
 994    * not public, returns a bogus (and empty) UnicodeString.
 995    * @return the name of the current default rule set
 996    * @stable ICU 3.0
 997    */
 998   virtual UnicodeString getDefaultRuleSetName() const;
 999 
1000   /**
1001    * Set a particular UDisplayContext value in the formatter, such as
1002    * UDISPCTX_CAPITALIZATION_FOR_STANDALONE. Note: For getContext, see
1003    * NumberFormat.
1004    * @param value The UDisplayContext value to set.
1005    * @param status Input/output status. If at entry this indicates a failure
1006    *               status, the function will do nothing; otherwise this will be
1007    *               updated with any new status from the function.
1008    * @stable ICU 53
1009    */
1010   virtual void setContext(UDisplayContext value, UErrorCode&amp; status);
1011 
1012     /**
1013      * Get the rounding mode.
1014      * @return A rounding mode
1015      * @stable ICU 60
1016      */
1017     virtual ERoundingMode getRoundingMode(void) const;
1018 
1019     /**
1020      * Set the rounding mode.
1021      * @param roundingMode A rounding mode
1022      * @stable ICU 60
1023      */
1024     virtual void setRoundingMode(ERoundingMode roundingMode);
1025 
1026 public:
1027     /**
1028      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for this class.
1029      *
1030      * @stable ICU 2.8
1031      */
1032     static UClassID U_EXPORT2 getStaticClassID(void);
1033 
1034     /**
1035      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for the actual class.
1036      *
1037      * @stable ICU 2.8
1038      */
1039     virtual UClassID getDynamicClassID(void) const;
1040 
1041     /**
1042      * Sets the decimal format symbols, which is generally not changed
1043      * by the programmer or user. The formatter takes ownership of
1044      * symbolsToAdopt; the client must not delete it.
1045      *
1046      * @param symbolsToAdopt DecimalFormatSymbols to be adopted.
1047      * @stable ICU 49
1048      */
1049     virtual void adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt);
1050 
1051     /**
1052      * Sets the decimal format symbols, which is generally not changed
1053      * by the programmer or user. A clone of the symbols is created and
1054      * the symbols is _not_ adopted; the client is still responsible for
1055      * deleting it.
1056      *
1057      * @param symbols DecimalFormatSymbols.
1058      * @stable ICU 49
1059      */
1060     virtual void setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols);
1061 
1062 private:
1063     RuleBasedNumberFormat(); // default constructor not implemented
1064 
1065     // this will ref the localizations if they are not NULL
1066     // caller must deref to get adoption
1067     RuleBasedNumberFormat(const UnicodeString&amp; description, LocalizationInfo* localizations,
1068               const Locale&amp; locale, UParseError&amp; perror, UErrorCode&amp; status);
1069 
1070     void init(const UnicodeString&amp; rules, LocalizationInfo* localizations, UParseError&amp; perror, UErrorCode&amp; status);
1071     void initCapitalizationContextInfo(const Locale&amp; thelocale);
1072     void dispose();
1073     void stripWhitespace(UnicodeString&amp; src);
1074     void initDefaultRuleSet();
1075     NFRuleSet* findRuleSet(const UnicodeString&amp; name, UErrorCode&amp; status) const;
1076 
1077     /* friend access */
1078     friend class NFSubstitution;
1079     friend class NFRule;
1080     friend class NFRuleSet;
1081     friend class FractionalPartSubstitution;
1082 
1083     inline NFRuleSet * getDefaultRuleSet() const;
1084     const RuleBasedCollator * getCollator() const;
1085     DecimalFormatSymbols * initializeDecimalFormatSymbols(UErrorCode &amp;status);
1086     const DecimalFormatSymbols * getDecimalFormatSymbols() const;
1087     NFRule * initializeDefaultInfinityRule(UErrorCode &amp;status);
1088     const NFRule * getDefaultInfinityRule() const;
1089     NFRule * initializeDefaultNaNRule(UErrorCode &amp;status);
1090     const NFRule * getDefaultNaNRule() const;
1091     PluralFormat *createPluralFormat(UPluralType pluralType, const UnicodeString &amp;pattern, UErrorCode&amp; status) const;
1092     UnicodeString&amp; adjustForCapitalizationContext(int32_t startPos, UnicodeString&amp; currentResult, UErrorCode&amp; status) const;
1093     UnicodeString&amp; format(int64_t number, NFRuleSet *ruleSet, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const;
1094     void format(double number, NFRuleSet&amp; rs, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const;
1095 
1096 private:
1097     NFRuleSet **fRuleSets;
1098     UnicodeString* ruleSetDescriptions;
1099     int32_t numRuleSets;
1100     NFRuleSet *defaultRuleSet;
1101     Locale locale;
1102     RuleBasedCollator* collator;
1103     DecimalFormatSymbols* decimalFormatSymbols;
1104     NFRule *defaultInfinityRule;
1105     NFRule *defaultNaNRule;
1106     ERoundingMode fRoundingMode;
1107     UBool lenient;
1108     UnicodeString* lenientParseRules;
1109     LocalizationInfo* localizations;
1110     UnicodeString originalDescription;
1111     UBool capitalizationInfoSet;
1112     UBool capitalizationForUIListMenu;
1113     UBool capitalizationForStandAlone;
1114     BreakIterator* capitalizationBrkIter;
1115 };
1116 
1117 // ---------------
1118 
1119 #if !UCONFIG_NO_COLLATION
1120 
1121 inline UBool
1122 RuleBasedNumberFormat::isLenient(void) const {
1123     return lenient;
1124 }
1125 
1126 #endif
1127 
1128 inline NFRuleSet*
1129 RuleBasedNumberFormat::getDefaultRuleSet() const {
1130     return defaultRuleSet;
1131 }
1132 
1133 U_NAMESPACE_END
1134 
1135 /* U_HAVE_RBNF */
1136 #endif
1137 
1138 /* RBNF_H */
1139 #endif
    </pre>
  </body>
</html>