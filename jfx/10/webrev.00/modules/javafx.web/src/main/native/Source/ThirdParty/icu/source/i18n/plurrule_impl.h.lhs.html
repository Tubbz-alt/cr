<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/plurrule_impl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 * Copyright (C) 2007-2016, International Business Machines Corporation and
  6 * others. All Rights Reserved.
  7 *******************************************************************************
  8 *
  9 * File PLURRULE_IMPL.H
 10 *
 11 *******************************************************************************
 12 */
 13 
 14 
 15 #ifndef PLURRULE_IMPL
 16 #define PLURRULE_IMPL
 17 
 18 // Internal definitions for the PluralRules implementation.
 19 
 20 #include &quot;unicode/utypes.h&quot;
 21 
 22 #if !UCONFIG_NO_FORMATTING
 23 
 24 #include &quot;unicode/format.h&quot;
 25 #include &quot;unicode/locid.h&quot;
 26 #include &quot;unicode/parseerr.h&quot;
 27 #include &quot;unicode/strenum.h&quot;
 28 #include &quot;unicode/ures.h&quot;
 29 #include &quot;uvector.h&quot;
 30 #include &quot;hash.h&quot;
 31 #include &quot;uassert.h&quot;
 32 
 33 class PluralRulesTest;
 34 
 35 U_NAMESPACE_BEGIN
 36 
 37 class AndConstraint;
 38 class RuleChain;
 39 class DigitInterval;
 40 class PluralRules;
 41 class VisibleDigits;
 42 
 43 namespace pluralimpl {
 44 
 45 // TODO: Remove this and replace with u&quot;&quot; literals. Was for EBCDIC compatibility.
 46 
 47 static const UChar DOT = ((UChar) 0x002E);
 48 static const UChar SINGLE_QUOTE = ((UChar) 0x0027);
 49 static const UChar SLASH = ((UChar) 0x002F);
 50 static const UChar BACKSLASH = ((UChar) 0x005C);
 51 static const UChar SPACE = ((UChar) 0x0020);
 52 static const UChar EXCLAMATION = ((UChar) 0x0021);
 53 static const UChar QUOTATION_MARK = ((UChar) 0x0022);
 54 static const UChar NUMBER_SIGN = ((UChar) 0x0023);
 55 static const UChar PERCENT_SIGN = ((UChar) 0x0025);
 56 static const UChar ASTERISK = ((UChar) 0x002A);
 57 static const UChar COMMA = ((UChar) 0x002C);
 58 static const UChar HYPHEN = ((UChar) 0x002D);
 59 static const UChar U_ZERO = ((UChar) 0x0030);
 60 static const UChar U_ONE = ((UChar) 0x0031);
 61 static const UChar U_TWO = ((UChar) 0x0032);
 62 static const UChar U_THREE = ((UChar) 0x0033);
 63 static const UChar U_FOUR = ((UChar) 0x0034);
 64 static const UChar U_FIVE = ((UChar) 0x0035);
 65 static const UChar U_SIX = ((UChar) 0x0036);
 66 static const UChar U_SEVEN = ((UChar) 0x0037);
 67 static const UChar U_EIGHT = ((UChar) 0x0038);
 68 static const UChar U_NINE = ((UChar) 0x0039);
 69 static const UChar COLON = ((UChar) 0x003A);
 70 static const UChar SEMI_COLON = ((UChar) 0x003B);
 71 static const UChar EQUALS = ((UChar) 0x003D);
 72 static const UChar AT = ((UChar) 0x0040);
 73 static const UChar CAP_A = ((UChar) 0x0041);
 74 static const UChar CAP_B = ((UChar) 0x0042);
 75 static const UChar CAP_R = ((UChar) 0x0052);
 76 static const UChar CAP_Z = ((UChar) 0x005A);
 77 static const UChar LOWLINE = ((UChar) 0x005F);
 78 static const UChar LEFTBRACE = ((UChar) 0x007B);
 79 static const UChar RIGHTBRACE = ((UChar) 0x007D);
 80 static const UChar TILDE = ((UChar) 0x007E);
 81 static const UChar ELLIPSIS = ((UChar) 0x2026);
 82 
 83 static const UChar LOW_A = ((UChar) 0x0061);
 84 static const UChar LOW_B = ((UChar) 0x0062);
 85 static const UChar LOW_C = ((UChar) 0x0063);
 86 static const UChar LOW_D = ((UChar) 0x0064);
 87 static const UChar LOW_E = ((UChar) 0x0065);
 88 static const UChar LOW_F = ((UChar) 0x0066);
 89 static const UChar LOW_G = ((UChar) 0x0067);
 90 static const UChar LOW_H = ((UChar) 0x0068);
 91 static const UChar LOW_I = ((UChar) 0x0069);
 92 static const UChar LOW_J = ((UChar) 0x006a);
 93 static const UChar LOW_K = ((UChar) 0x006B);
 94 static const UChar LOW_L = ((UChar) 0x006C);
 95 static const UChar LOW_M = ((UChar) 0x006D);
 96 static const UChar LOW_N = ((UChar) 0x006E);
 97 static const UChar LOW_O = ((UChar) 0x006F);
 98 static const UChar LOW_P = ((UChar) 0x0070);
 99 static const UChar LOW_Q = ((UChar) 0x0071);
100 static const UChar LOW_R = ((UChar) 0x0072);
101 static const UChar LOW_S = ((UChar) 0x0073);
102 static const UChar LOW_T = ((UChar) 0x0074);
103 static const UChar LOW_U = ((UChar) 0x0075);
104 static const UChar LOW_V = ((UChar) 0x0076);
105 static const UChar LOW_W = ((UChar) 0x0077);
106 static const UChar LOW_Y = ((UChar) 0x0079);
107 static const UChar LOW_Z = ((UChar) 0x007A);
108 
109 }
110 
111 
112 static const int32_t PLURAL_RANGE_HIGH = 0x7fffffff;
113 
114 enum tokenType {
115   none,
116   tNumber,
117   tComma,
118   tSemiColon,
119   tSpace,
120   tColon,
121   tAt,           // &#39;@&#39;
122   tDot,
123   tDot2,
124   tEllipsis,
125   tKeyword,
126   tAnd,
127   tOr,
128   tMod,          // &#39;mod&#39; or &#39;%&#39;
129   tNot,          //  &#39;not&#39; only.
130   tIn,           //  &#39;in&#39;  only.
131   tEqual,        //  &#39;=&#39;   only.
132   tNotEqual,     //  &#39;!=&#39;
133   tTilde,
134   tWithin,
135   tIs,
136   tVariableN,
137   tVariableI,
138   tVariableF,
139   tVariableV,
140   tVariableT,
141   tDecimal,
142   tInteger,
143   tEOF
144 };
145 
146 
147 class PluralRuleParser: public UMemory {
148 public:
149     PluralRuleParser();
150     virtual ~PluralRuleParser();
151 
152     void parse(const UnicodeString &amp;rules, PluralRules *dest, UErrorCode &amp;status);
153     void getNextToken(UErrorCode &amp;status);
154     void checkSyntax(UErrorCode &amp;status);
155     static int32_t getNumberValue(const UnicodeString &amp;token);
156 
157 private:
158     static tokenType getKeyType(const UnicodeString&amp; token, tokenType type);
159     static tokenType charType(UChar ch);
160     static UBool isValidKeyword(const UnicodeString&amp; token);
161 
162     const UnicodeString  *ruleSrc;  // The rules string.
163     int32_t        ruleIndex;       // String index in the input rules, the current parse position.
164     UnicodeString  token;           // Token most recently scanned.
165     tokenType      type;
166     tokenType      prevType;
167 
168                                     // The items currently being parsed &amp; built.
169                                     // Note: currentChain may not be the last RuleChain in the
170                                     //       list because the &quot;other&quot; chain is forced to the end.
171     AndConstraint *curAndConstraint;
172     RuleChain     *currentChain;
173 
174     int32_t        rangeLowIdx;     // Indices in the UVector of ranges of the
175     int32_t        rangeHiIdx;      //    low and hi values currently being parsed.
176 
177     enum EParseState {
178        kKeyword,
179        kExpr,
180        kValue,
181        kRangeList,
182        kSamples
183     };
<a name="1" id="anc1"></a><span class="line-removed">184 </span>
185 };
186 
187 enum PluralOperand {
188     /**
189     * The double value of the entire number.
190     */
191     PLURAL_OPERAND_N,
192 
193     /**
194      * The integer value, with the fraction digits truncated off.
195      */
196     PLURAL_OPERAND_I,
197 
198     /**
199      * All visible fraction digits as an integer, including trailing zeros.
200      */
201     PLURAL_OPERAND_F,
202 
203     /**
204      * Visible fraction digits as an integer, not including trailing zeros.
205      */
206     PLURAL_OPERAND_T,
207 
208     /**
209      * Number of visible fraction digits.
210      */
211     PLURAL_OPERAND_V,
212 
213     /**
214      * Number of visible fraction digits, not including trailing zeros.
215      */
216     PLURAL_OPERAND_W,
217 
218     /**
219      * THIS OPERAND IS DEPRECATED AND HAS BEEN REMOVED FROM THE SPEC.
220      *
221      * &lt;p&gt;Returns the integer value, but will fail if the number has fraction digits.
222      * That is, using &quot;j&quot; instead of &quot;i&quot; is like implicitly adding &quot;v is 0&quot;.
223      *
224      * &lt;p&gt;For example, &quot;j is 3&quot; is equivalent to &quot;i is 3 and v is 0&quot;: it matches
225      * &quot;3&quot; but not &quot;3.1&quot; or &quot;3.0&quot;.
226      */
227     PLURAL_OPERAND_J
228 };
229 
230 /**
231  * Converts from the tokenType enum to PluralOperand. Asserts that the given
232  * tokenType can be mapped to a PluralOperand.
233  */
234 PluralOperand tokenTypeToPluralOperand(tokenType tt);
235 
236 /**
237  * An interface to FixedDecimal, allowing for other implementations.
238  * @internal
239  */
240 class U_I18N_API IFixedDecimal {
241   public:
242     virtual ~IFixedDecimal();
243 
244     /**
245      * Returns the value corresponding to the specified operand (n, i, f, t, v, or w).
246      * If the operand is &#39;n&#39;, returns a double; otherwise, returns an integer.
247      */
248     virtual double getPluralOperand(PluralOperand operand) const = 0;
249 
250     virtual bool isNaN() const = 0;
251 
252     virtual bool isInfinite() const = 0;
253 
254     /** Whether the number has no nonzero fraction digits. */
255     virtual bool hasIntegerValue() const = 0;
256 };
257 
258 /**
259  * class FixedDecimal serves to communicate the properties
260  * of a formatted number from a decimal formatter to PluralRules::select()
261  *
262  * see DecimalFormat::getFixedDecimal()
263  * @internal
264  */
265 class U_I18N_API FixedDecimal: public IFixedDecimal, public UObject {
266   public:
267     /**
268       * @param n   the number, e.g. 12.345
269       * @param v   The number of visible fraction digits, e.g. 3
270       * @param f   The fraction digits, e.g. 345
271       */
272     FixedDecimal(double  n, int32_t v, int64_t f);
273     FixedDecimal(double n, int32_t);
274     explicit FixedDecimal(double n);
275     FixedDecimal();
276     ~FixedDecimal() U_OVERRIDE;
277     FixedDecimal(const UnicodeString &amp;s, UErrorCode &amp;ec);
278     FixedDecimal(const FixedDecimal &amp;other);
279 
280     double getPluralOperand(PluralOperand operand) const U_OVERRIDE;
281     bool isNaN() const U_OVERRIDE;
282     bool isInfinite() const U_OVERRIDE;
283     bool hasIntegerValue() const U_OVERRIDE;
284 
285     bool isNanOrInfinity() const;  // used in decimfmtimpl.cpp
286 
287     int32_t getVisibleFractionDigitCount() const;
288 
289     void init(double n, int32_t v, int64_t f);
290     void init(double n);
291     UBool quickInit(double n);  // Try a fast-path only initialization,
292                                 //    return TRUE if successful.
293     void adjustForMinFractionDigits(int32_t min);
294     static int64_t getFractionalDigits(double n, int32_t v);
295     static int32_t decimals(double n);
296 
297     double      source;
298     int32_t     visibleDecimalDigitCount;
299     int64_t     decimalDigits;
300     int64_t     decimalDigitsWithoutTrailingZeros;
301     int64_t     intValue;
302     UBool       _hasIntegerValue;
303     UBool       isNegative;
304     UBool       _isNaN;
305     UBool       _isInfinite;
306 };
307 
308 class AndConstraint : public UMemory  {
309 public:
310     typedef enum RuleOp {
311         NONE,
312         MOD
313     } RuleOp;
<a name="2" id="anc2"></a><span class="line-modified">314     RuleOp  op;</span>
<span class="line-modified">315     int32_t opNum;           // for mod expressions, the right operand of the mod.</span>
<span class="line-modified">316     int32_t     value;       // valid for &#39;is&#39; rules only.</span>
<span class="line-modified">317     UVector32   *rangeList;  // for &#39;in&#39;, &#39;within&#39; rules. Null otherwise.</span>
<span class="line-modified">318     UBool   negated;           // TRUE for negated rules.</span>
<span class="line-modified">319     UBool   integerOnly;     // TRUE for &#39;within&#39; rules.</span>
<span class="line-modified">320     tokenType digitsType;    // n | i | v | f constraint.</span>
<span class="line-modified">321     AndConstraint *next;</span>
<span class="line-modified">322 </span>
<span class="line-modified">323     AndConstraint();</span>


324     AndConstraint(const AndConstraint&amp; other);
325     virtual ~AndConstraint();
<a name="3" id="anc3"></a><span class="line-modified">326     AndConstraint* add();</span>
327     // UBool isFulfilled(double number);
328     UBool isFulfilled(const IFixedDecimal &amp;number);
329 };
330 
331 class OrConstraint : public UMemory  {
332 public:
<a name="4" id="anc4"></a><span class="line-modified">333     AndConstraint *childNode;</span>
<span class="line-modified">334     OrConstraint *next;</span>
<span class="line-modified">335     OrConstraint();</span>

336 
<a name="5" id="anc5"></a>
337     OrConstraint(const OrConstraint&amp; other);
338     virtual ~OrConstraint();
<a name="6" id="anc6"></a><span class="line-modified">339     AndConstraint* add();</span>
340     // UBool isFulfilled(double number);
341     UBool isFulfilled(const IFixedDecimal &amp;number);
342 };
343 
344 class RuleChain : public UMemory  {
345 public:
346     UnicodeString   fKeyword;
<a name="7" id="anc7"></a><span class="line-modified">347     RuleChain      *fNext;</span>
<span class="line-modified">348     OrConstraint   *ruleHeader;</span>
349     UnicodeString   fDecimalSamples;  // Samples strings from rule source
350     UnicodeString   fIntegerSamples;  //   without @decimal or @integer, otherwise unprocessed.
<a name="8" id="anc8"></a><span class="line-modified">351     UBool           fDecimalSamplesUnbounded;</span>
<span class="line-modified">352     UBool           fIntegerSamplesUnbounded;</span>
<span class="line-modified">353 </span>

354 
<a name="9" id="anc9"></a><span class="line-modified">355     RuleChain();</span>
356     RuleChain(const RuleChain&amp; other);
357     virtual ~RuleChain();
358 
359     UnicodeString select(const IFixedDecimal &amp;number) const;
360     void          dumpRules(UnicodeString&amp; result);
361     UErrorCode    getKeywords(int32_t maxArraySize, UnicodeString *keywords, int32_t&amp; arraySize) const;
362     UBool         isKeyword(const UnicodeString&amp; keyword) const;
363 };
364 
365 class PluralKeywordEnumeration : public StringEnumeration {
366 public:
367     PluralKeywordEnumeration(RuleChain *header, UErrorCode&amp; status);
368     virtual ~PluralKeywordEnumeration();
369     static UClassID U_EXPORT2 getStaticClassID(void);
370     virtual UClassID getDynamicClassID(void) const;
371     virtual const UnicodeString* snext(UErrorCode&amp; status);
372     virtual void reset(UErrorCode&amp; status);
373     virtual int32_t count(UErrorCode&amp; status) const;
374 private:
375     int32_t         pos;
376     UVector         fKeywordNames;
377 };
378 
379 
380 class U_I18N_API PluralAvailableLocalesEnumeration: public StringEnumeration {
381   public:
382     PluralAvailableLocalesEnumeration(UErrorCode &amp;status);
383     virtual ~PluralAvailableLocalesEnumeration();
384     virtual const char* next(int32_t *resultLength, UErrorCode&amp; status);
385     virtual void reset(UErrorCode&amp; status);
386     virtual int32_t count(UErrorCode&amp; status) const;
387   private:
388     UErrorCode      fOpenStatus;
<a name="10" id="anc10"></a><span class="line-modified">389     UResourceBundle *fLocales;</span>
<span class="line-modified">390     UResourceBundle *fRes;</span>
391 };
392 
393 U_NAMESPACE_END
394 
395 #endif /* #if !UCONFIG_NO_FORMATTING */
396 
397 #endif // _PLURRULE_IMPL
398 //eof
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>