<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/normalizer2impl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="normalizer2.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="normalizer2impl.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/normalizer2impl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 14,30 ***</span>
  *
  *   created on: 2009nov22
  *   created by: Markus W. Scherer
  */
  
  #include &quot;unicode/utypes.h&quot;
  
  #if !UCONFIG_NO_NORMALIZATION
  
  #include &quot;unicode/bytestream.h&quot;
  #include &quot;unicode/edits.h&quot;
  #include &quot;unicode/normalizer2.h&quot;
  #include &quot;unicode/stringoptions.h&quot;
  #include &quot;unicode/udata.h&quot;
  #include &quot;unicode/ustring.h&quot;
  #include &quot;unicode/utf16.h&quot;
  #include &quot;unicode/utf8.h&quot;
  #include &quot;bytesinkutil.h&quot;
  #include &quot;cmemory.h&quot;
  #include &quot;mutex.h&quot;
  #include &quot;normalizer2impl.h&quot;
  #include &quot;putilimp.h&quot;
  #include &quot;uassert.h&quot;
  #include &quot;uset_imp.h&quot;
<span class="line-removed">- #include &quot;utrie2.h&quot;</span>
  #include &quot;uvector.h&quot;
  
  U_NAMESPACE_BEGIN
  
  namespace {
<span class="line-new-header">--- 14,34 ---</span>
  *
  *   created on: 2009nov22
  *   created by: Markus W. Scherer
  */
  
<span class="line-added">+ // #define UCPTRIE_DEBUG</span>
<span class="line-added">+ </span>
  #include &quot;unicode/utypes.h&quot;
  
  #if !UCONFIG_NO_NORMALIZATION
  
  #include &quot;unicode/bytestream.h&quot;
  #include &quot;unicode/edits.h&quot;
  #include &quot;unicode/normalizer2.h&quot;
  #include &quot;unicode/stringoptions.h&quot;
<span class="line-added">+ #include &quot;unicode/ucptrie.h&quot;</span>
  #include &quot;unicode/udata.h&quot;
<span class="line-added">+ #include &quot;unicode/umutablecptrie.h&quot;</span>
  #include &quot;unicode/ustring.h&quot;
  #include &quot;unicode/utf16.h&quot;
  #include &quot;unicode/utf8.h&quot;
  #include &quot;bytesinkutil.h&quot;
  #include &quot;cmemory.h&quot;
  #include &quot;mutex.h&quot;
  #include &quot;normalizer2impl.h&quot;
  #include &quot;putilimp.h&quot;
  #include &quot;uassert.h&quot;
<span class="line-added">+ #include &quot;ucptrie_impl.h&quot;</span>
  #include &quot;uset_imp.h&quot;
  #include &quot;uvector.h&quot;
  
  U_NAMESPACE_BEGIN
  
  namespace {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,11 ***</span>
  
  /**
   * Returns the code point from one single well-formed UTF-8 byte sequence
   * between cpStart and cpLimit.
   *
<span class="line-modified">!  * UTrie2 UTF-8 macros do not assemble whole code points (for efficiency).</span>
   * When we do need the code point, we call this function.
   * We should not need it for normalization-inert data (norm16==0).
   * Illegal sequences yield the error value norm16==0 just like real normalization-inert code points.
   */
  UChar32 codePointFromValidUTF8(const uint8_t *cpStart, const uint8_t *cpLimit) {
<span class="line-new-header">--- 64,11 ---</span>
  
  /**
   * Returns the code point from one single well-formed UTF-8 byte sequence
   * between cpStart and cpLimit.
   *
<span class="line-modified">!  * Trie UTF-8 macros do not assemble whole code points (for efficiency).</span>
   * When we do need the code point, we call this function.
   * We should not need it for normalization-inert data (norm16==0).
   * Illegal sequences yield the error value norm16==0 just like real normalization-inert code points.
   */
  UChar32 codePointFromValidUTF8(const uint8_t *cpStart, const uint8_t *cpLimit) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,12 ***</span>
          // no need for (c&amp;0xf) because the upper bits are truncated after &lt;&lt;12 in the cast to (UChar)
          return (UChar)((c&lt;&lt;12) | ((cpStart[1]&amp;0x3f)&lt;&lt;6) | (cpStart[2]&amp;0x3f));
      case 4:
          return ((c&amp;7)&lt;&lt;18) | ((cpStart[1]&amp;0x3f)&lt;&lt;12) | ((cpStart[2]&amp;0x3f)&lt;&lt;6) | (cpStart[3]&amp;0x3f);
      default:
<span class="line-modified">!         U_ASSERT(FALSE);  // Should not occur.</span>
<span class="line-removed">-         return U_SENTINEL;</span>
      }
  }
  
  /**
   * Returns the last code point in [start, p[ if it is valid and in U+1000..U+D7FF.
<span class="line-new-header">--- 84,11 ---</span>
          // no need for (c&amp;0xf) because the upper bits are truncated after &lt;&lt;12 in the cast to (UChar)
          return (UChar)((c&lt;&lt;12) | ((cpStart[1]&amp;0x3f)&lt;&lt;6) | (cpStart[2]&amp;0x3f));
      case 4:
          return ((c&amp;7)&lt;&lt;18) | ((cpStart[1]&amp;0x3f)&lt;&lt;12) | ((cpStart[2]&amp;0x3f)&lt;&lt;6) | (cpStart[3]&amp;0x3f);
      default:
<span class="line-modified">!         UPRV_UNREACHABLE;  // Should not occur.</span>
      }
  }
  
  /**
   * Returns the last code point in [start, p[ if it is valid and in U+1000..U+D7FF.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 120,11 ***</span>
              if (0xa8 &lt;= t &amp;&amp; t &lt;= 0xbf) {
                  return t - 0xa7;
              }
          } else if (src[1] == 0x87) {
              uint8_t t = src[2];
<span class="line-modified">!             if ((int8_t)t &lt;= (int8_t)0x82) {</span>
                  return t - (0xa7 - 0x40);
              }
          }
      }
      return -1;
<span class="line-new-header">--- 123,11 ---</span>
              if (0xa8 &lt;= t &amp;&amp; t &lt;= 0xbf) {
                  return t - 0xa7;
              }
          } else if (src[1] == 0x87) {
              uint8_t t = src[2];
<span class="line-modified">!             if ((int8_t)t &lt;= (int8_t)0x82u) {</span>
                  return t - (0xa7 - 0x40);
              }
          }
      }
      return -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 251,11 ***</span>
      }
      remainingCapacity-=2;
      return TRUE;
  }
  
<span class="line-modified">! UBool ReorderingBuffer::append(const UChar *s, int32_t length,</span>
                                 uint8_t leadCC, uint8_t trailCC,
                                 UErrorCode &amp;errorCode) {
      if(length==0) {
          return TRUE;
      }
<span class="line-new-header">--- 254,11 ---</span>
      }
      remainingCapacity-=2;
      return TRUE;
  }
  
<span class="line-modified">! UBool ReorderingBuffer::append(const UChar *s, int32_t length, UBool isNFD,</span>
                                 uint8_t leadCC, uint8_t trailCC,
                                 UErrorCode &amp;errorCode) {
      if(length==0) {
          return TRUE;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 278,12 ***</span>
          U16_NEXT(s, i, length, c);
          insert(c, leadCC);  // insert first code point
          while(i&lt;length) {
              U16_NEXT(s, i, length, c);
              if(i&lt;length) {
<span class="line-modified">!                 // s must be in NFD, otherwise we need to use getCC().</span>
<span class="line-modified">!                 leadCC=Normalizer2Impl::getCCFromYesOrMaybe(impl.getNorm16(c));</span>
              } else {
                  leadCC=trailCC;
              }
              append(c, leadCC, errorCode);
          }
<span class="line-new-header">--- 281,15 ---</span>
          U16_NEXT(s, i, length, c);
          insert(c, leadCC);  // insert first code point
          while(i&lt;length) {
              U16_NEXT(s, i, length, c);
              if(i&lt;length) {
<span class="line-modified">!                 if (isNFD) {</span>
<span class="line-modified">!                     leadCC = Normalizer2Impl::getCCFromYesOrMaybe(impl.getRawNorm16(c));</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     leadCC = impl.getCC(impl.getNorm16(c));</span>
<span class="line-added">+                 }</span>
              } else {
                  leadCC=trailCC;
              }
              append(c, leadCC, errorCode);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 409,131 ***</span>
  
  struct CanonIterData : public UMemory {
      CanonIterData(UErrorCode &amp;errorCode);
      ~CanonIterData();
      void addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode &amp;errorCode);
<span class="line-modified">!     UTrie2 *trie;</span>
      UVector canonStartSets;  // contains UnicodeSet *
  };
  
  Normalizer2Impl::~Normalizer2Impl() {
      delete fCanonIterData;
  }
  
  void
<span class="line-modified">! Normalizer2Impl::init(const int32_t *inIndexes, const UTrie2 *inTrie,</span>
                        const uint16_t *inExtraData, const uint8_t *inSmallFCD) {
<span class="line-modified">!     minDecompNoCP=inIndexes[IX_MIN_DECOMP_NO_CP];</span>
<span class="line-modified">!     minCompNoMaybeCP=inIndexes[IX_MIN_COMP_NO_MAYBE_CP];</span>
<span class="line-modified">!     minLcccCP=inIndexes[IX_MIN_LCCC_CP];</span>
<span class="line-modified">! </span>
<span class="line-modified">!     minYesNo=inIndexes[IX_MIN_YES_NO];</span>
<span class="line-modified">!     minYesNoMappingsOnly=inIndexes[IX_MIN_YES_NO_MAPPINGS_ONLY];</span>
<span class="line-modified">!     minNoNo=inIndexes[IX_MIN_NO_NO];</span>
<span class="line-modified">!     minNoNoCompBoundaryBefore=inIndexes[IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE];</span>
<span class="line-modified">!     minNoNoCompNoMaybeCC=inIndexes[IX_MIN_NO_NO_COMP_NO_MAYBE_CC];</span>
<span class="line-modified">!     minNoNoEmpty=inIndexes[IX_MIN_NO_NO_EMPTY];</span>
<span class="line-modified">!     limitNoNo=inIndexes[IX_LIMIT_NO_NO];</span>
<span class="line-modified">!     minMaybeYes=inIndexes[IX_MIN_MAYBE_YES];</span>
<span class="line-modified">!     U_ASSERT((minMaybeYes&amp;7)==0);  // 8-aligned for noNoDelta bit fields</span>
<span class="line-modified">!     centerNoNoDelta=(minMaybeYes&gt;&gt;DELTA_SHIFT)-MAX_DELTA-1;</span>
  
      normTrie=inTrie;
  
      maybeYesCompositions=inExtraData;
      extraData=maybeYesCompositions+((MIN_NORMAL_MAYBE_YES-minMaybeYes)&gt;&gt;OFFSET_SHIFT);
  
      smallFCD=inSmallFCD;
  }
  
<span class="line-removed">- class LcccContext {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     LcccContext(const Normalizer2Impl &amp;ni, UnicodeSet &amp;s) : impl(ni), set(s) {}</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void handleRange(UChar32 start, UChar32 end, uint16_t norm16) {</span>
<span class="line-removed">-         if (norm16 &gt; Normalizer2Impl::MIN_NORMAL_MAYBE_YES &amp;&amp;</span>
<span class="line-removed">-                 norm16 != Normalizer2Impl::JAMO_VT) {</span>
<span class="line-removed">-             set.add(start, end);</span>
<span class="line-removed">-         } else if (impl.minNoNoCompNoMaybeCC &lt;= norm16 &amp;&amp; norm16 &lt; impl.limitNoNo) {</span>
<span class="line-removed">-             uint16_t fcd16=impl.getFCD16(start);</span>
<span class="line-removed">-             if(fcd16&gt;0xff) { set.add(start, end); }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     const Normalizer2Impl &amp;impl;</span>
<span class="line-removed">-     UnicodeSet &amp;set;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- namespace {</span>
<span class="line-removed">- </span>
<span class="line-removed">- struct PropertyStartsContext {</span>
<span class="line-removed">-     PropertyStartsContext(const Normalizer2Impl &amp;ni, const USetAdder *adder)</span>
<span class="line-removed">-             : impl(ni), sa(adder) {}</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const Normalizer2Impl &amp;impl;</span>
<span class="line-removed">-     const USetAdder *sa;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- }  // namespace</span>
<span class="line-removed">- </span>
  U_CDECL_BEGIN
  
<span class="line-removed">- static UBool U_CALLCONV</span>
<span class="line-removed">- enumLcccRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {</span>
<span class="line-removed">-     ((LcccContext *)context)-&gt;handleRange(start, end, (uint16_t)value);</span>
<span class="line-removed">-     return TRUE;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static UBool U_CALLCONV</span>
<span class="line-removed">- enumNorm16PropertyStartsRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {</span>
<span class="line-removed">-     /* add the start code point to the USet */</span>
<span class="line-removed">-     const PropertyStartsContext *ctx=(const PropertyStartsContext *)context;</span>
<span class="line-removed">-     const USetAdder *sa=ctx-&gt;sa;</span>
<span class="line-removed">-     sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-removed">-     if (start != end &amp;&amp; ctx-&gt;impl.isAlgorithmicNoNo((uint16_t)value) &amp;&amp;</span>
<span class="line-removed">-             (value &amp; Normalizer2Impl::DELTA_TCCC_MASK) &gt; Normalizer2Impl::DELTA_TCCC_1) {</span>
<span class="line-removed">-         // Range of code points with same-norm16-value algorithmic decompositions.</span>
<span class="line-removed">-         // They might have different non-zero FCD16 values.</span>
<span class="line-removed">-         uint16_t prevFCD16=ctx-&gt;impl.getFCD16(start);</span>
<span class="line-removed">-         while(++start&lt;=end) {</span>
<span class="line-removed">-             uint16_t fcd16=ctx-&gt;impl.getFCD16(start);</span>
<span class="line-removed">-             if(fcd16!=prevFCD16) {</span>
<span class="line-removed">-                 sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-removed">-                 prevFCD16=fcd16;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return TRUE;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static UBool U_CALLCONV</span>
<span class="line-removed">- enumPropertyStartsRange(const void *context, UChar32 start, UChar32 /*end*/, uint32_t /*value*/) {</span>
<span class="line-removed">-     /* add the start code point to the USet */</span>
<span class="line-removed">-     const USetAdder *sa=(const USetAdder *)context;</span>
<span class="line-removed">-     sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-removed">-     return TRUE;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static uint32_t U_CALLCONV
  segmentStarterMapper(const void * /*context*/, uint32_t value) {
      return value&amp;CANON_NOT_SEGMENT_STARTER;
  }
  
  U_CDECL_END
  
  void
  Normalizer2Impl::addLcccChars(UnicodeSet &amp;set) const {
<span class="line-modified">!     LcccContext context(*this, set);</span>
<span class="line-modified">!     utrie2_enum(normTrie, NULL, enumLcccRange, &amp;context);</span>
  }
  
  void
  Normalizer2Impl::addPropertyStarts(const USetAdder *sa, UErrorCode &amp; /*errorCode*/) const {
<span class="line-modified">!     /* add the start code point of each same-value range of each trie */</span>
<span class="line-modified">!     PropertyStartsContext context(*this, sa);</span>
<span class="line-modified">!     utrie2_enum(normTrie, NULL, enumNorm16PropertyStartsRange, &amp;context);</span>
  
      /* add Hangul LV syllables and LV+1 because of skippables */
      for(UChar c=Hangul::HANGUL_BASE; c&lt;Hangul::HANGUL_LIMIT; c+=Hangul::JAMO_T_COUNT) {
          sa-&gt;add(sa-&gt;set, c);
          sa-&gt;add(sa-&gt;set, c+1);
<span class="line-new-header">--- 415,94 ---</span>
  
  struct CanonIterData : public UMemory {
      CanonIterData(UErrorCode &amp;errorCode);
      ~CanonIterData();
      void addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode &amp;errorCode);
<span class="line-modified">!     UMutableCPTrie *mutableTrie;</span>
<span class="line-added">+     UCPTrie *trie;</span>
      UVector canonStartSets;  // contains UnicodeSet *
  };
  
  Normalizer2Impl::~Normalizer2Impl() {
      delete fCanonIterData;
  }
  
  void
<span class="line-modified">! Normalizer2Impl::init(const int32_t *inIndexes, const UCPTrie *inTrie,</span>
                        const uint16_t *inExtraData, const uint8_t *inSmallFCD) {
<span class="line-modified">!     minDecompNoCP = static_cast&lt;UChar&gt;(inIndexes[IX_MIN_DECOMP_NO_CP]);</span>
<span class="line-modified">!     minCompNoMaybeCP = static_cast&lt;UChar&gt;(inIndexes[IX_MIN_COMP_NO_MAYBE_CP]);</span>
<span class="line-modified">!     minLcccCP = static_cast&lt;UChar&gt;(inIndexes[IX_MIN_LCCC_CP]);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     minYesNo = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_YES_NO]);</span>
<span class="line-modified">!     minYesNoMappingsOnly = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_YES_NO_MAPPINGS_ONLY]);</span>
<span class="line-modified">!     minNoNo = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_NO_NO]);</span>
<span class="line-modified">!     minNoNoCompBoundaryBefore = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE]);</span>
<span class="line-modified">!     minNoNoCompNoMaybeCC = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_NO_NO_COMP_NO_MAYBE_CC]);</span>
<span class="line-modified">!     minNoNoEmpty = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_NO_NO_EMPTY]);</span>
<span class="line-modified">!     limitNoNo = static_cast&lt;uint16_t&gt;(inIndexes[IX_LIMIT_NO_NO]);</span>
<span class="line-modified">!     minMaybeYes = static_cast&lt;uint16_t&gt;(inIndexes[IX_MIN_MAYBE_YES]);</span>
<span class="line-modified">!     U_ASSERT((minMaybeYes &amp; 7) == 0);  // 8-aligned for noNoDelta bit fields</span>
<span class="line-modified">!     centerNoNoDelta = (minMaybeYes &gt;&gt; DELTA_SHIFT) - MAX_DELTA - 1;</span>
  
      normTrie=inTrie;
  
      maybeYesCompositions=inExtraData;
      extraData=maybeYesCompositions+((MIN_NORMAL_MAYBE_YES-minMaybeYes)&gt;&gt;OFFSET_SHIFT);
  
      smallFCD=inSmallFCD;
  }
  
  U_CDECL_BEGIN
  
  static uint32_t U_CALLCONV
  segmentStarterMapper(const void * /*context*/, uint32_t value) {
      return value&amp;CANON_NOT_SEGMENT_STARTER;
  }
  
  U_CDECL_END
  
  void
  Normalizer2Impl::addLcccChars(UnicodeSet &amp;set) const {
<span class="line-modified">!     UChar32 start = 0, end;</span>
<span class="line-modified">!     uint32_t norm16;</span>
<span class="line-added">+     while ((end = ucptrie_getRange(normTrie, start, UCPMAP_RANGE_FIXED_LEAD_SURROGATES, INERT,</span>
<span class="line-added">+                                    nullptr, nullptr, &amp;norm16)) &gt;= 0) {</span>
<span class="line-added">+         if (norm16 &gt; Normalizer2Impl::MIN_NORMAL_MAYBE_YES &amp;&amp;</span>
<span class="line-added">+                 norm16 != Normalizer2Impl::JAMO_VT) {</span>
<span class="line-added">+             set.add(start, end);</span>
<span class="line-added">+         } else if (minNoNoCompNoMaybeCC &lt;= norm16 &amp;&amp; norm16 &lt; limitNoNo) {</span>
<span class="line-added">+             uint16_t fcd16 = getFCD16(start);</span>
<span class="line-added">+             if (fcd16 &gt; 0xff) { set.add(start, end); }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         start = end + 1;</span>
<span class="line-added">+     }</span>
  }
  
  void
  Normalizer2Impl::addPropertyStarts(const USetAdder *sa, UErrorCode &amp; /*errorCode*/) const {
<span class="line-modified">!     // Add the start code point of each same-value range of the trie.</span>
<span class="line-modified">!     UChar32 start = 0, end;</span>
<span class="line-modified">!     uint32_t value;</span>
<span class="line-added">+     while ((end = ucptrie_getRange(normTrie, start, UCPMAP_RANGE_FIXED_LEAD_SURROGATES, INERT,</span>
<span class="line-added">+                                    nullptr, nullptr, &amp;value)) &gt;= 0) {</span>
<span class="line-added">+         sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-added">+         if (start != end &amp;&amp; isAlgorithmicNoNo((uint16_t)value) &amp;&amp;</span>
<span class="line-added">+                 (value &amp; Normalizer2Impl::DELTA_TCCC_MASK) &gt; Normalizer2Impl::DELTA_TCCC_1) {</span>
<span class="line-added">+             // Range of code points with same-norm16-value algorithmic decompositions.</span>
<span class="line-added">+             // They might have different non-zero FCD16 values.</span>
<span class="line-added">+             uint16_t prevFCD16 = getFCD16(start);</span>
<span class="line-added">+             while (++start &lt;= end) {</span>
<span class="line-added">+                 uint16_t fcd16 = getFCD16(start);</span>
<span class="line-added">+                 if (fcd16 != prevFCD16) {</span>
<span class="line-added">+                     sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-added">+                     prevFCD16 = fcd16;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         start = end + 1;</span>
<span class="line-added">+     }</span>
  
      /* add Hangul LV syllables and LV+1 because of skippables */
      for(UChar c=Hangul::HANGUL_BASE; c&lt;Hangul::HANGUL_LIMIT; c+=Hangul::JAMO_T_COUNT) {
          sa-&gt;add(sa-&gt;set, c);
          sa-&gt;add(sa-&gt;set, c+1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 541,14 ***</span>
      sa-&gt;add(sa-&gt;set, Hangul::HANGUL_LIMIT); /* add Hangul+1 to continue with other properties */
  }
  
  void
  Normalizer2Impl::addCanonIterPropertyStarts(const USetAdder *sa, UErrorCode &amp;errorCode) const {
<span class="line-modified">!     /* add the start code point of each same-value range of the canonical iterator data trie */</span>
<span class="line-modified">!     if(ensureCanonIterData(errorCode)) {</span>
<span class="line-modified">!         // currently only used for the SEGMENT_STARTER property</span>
<span class="line-modified">!         utrie2_enum(fCanonIterData-&gt;trie, segmentStarterMapper, enumPropertyStartsRange, sa);</span>
      }
  }
  
  const UChar *
  Normalizer2Impl::copyLowPrefixFromNulTerminated(const UChar *src,
<span class="line-new-header">--- 510,19 ---</span>
      sa-&gt;add(sa-&gt;set, Hangul::HANGUL_LIMIT); /* add Hangul+1 to continue with other properties */
  }
  
  void
  Normalizer2Impl::addCanonIterPropertyStarts(const USetAdder *sa, UErrorCode &amp;errorCode) const {
<span class="line-modified">!     // Add the start code point of each same-value range of the canonical iterator data trie.</span>
<span class="line-modified">!     if (!ensureCanonIterData(errorCode)) { return; }</span>
<span class="line-modified">!     // Currently only used for the SEGMENT_STARTER property.</span>
<span class="line-modified">!     UChar32 start = 0, end;</span>
<span class="line-added">+     uint32_t value;</span>
<span class="line-added">+     while ((end = ucptrie_getRange(fCanonIterData-&gt;trie, start, UCPMAP_RANGE_NORMAL, 0,</span>
<span class="line-added">+                                    segmentStarterMapper, nullptr, &amp;value)) &gt;= 0) {</span>
<span class="line-added">+         sa-&gt;add(sa-&gt;set, start);</span>
<span class="line-added">+         start = end + 1;</span>
      }
  }
  
  const UChar *
  Normalizer2Impl::copyLowPrefixFromNulTerminated(const UChar *src,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 631,31 ***</span>
  
      for(;;) {
          // count code units below the minimum or with irrelevant data for the quick check
          for(prevSrc=src; src!=limit;) {
              if( (c=*src)&lt;minNoCP ||
<span class="line-modified">!                 isMostDecompYesAndZeroCC(norm16=UTRIE2_GET16_FROM_U16_SINGLE_LEAD(normTrie, c))</span>
              ) {
                  ++src;
<span class="line-modified">!             } else if(!U16_IS_SURROGATE(c)) {</span>
                  break;
              } else {
                  UChar c2;
<span class="line-modified">!                 if(U16_IS_SURROGATE_LEAD(c)) {</span>
<span class="line-modified">!                     if((src+1)!=limit &amp;&amp; U16_IS_TRAIL(c2=src[1])) {</span>
<span class="line-modified">!                         c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 } else /* trail surrogate */ {</span>
<span class="line-modified">!                     if(prevSrc&lt;src &amp;&amp; U16_IS_LEAD(c2=*(src-1))) {</span>
<span class="line-modified">!                         --src;</span>
<span class="line-removed">-                         c=U16_GET_SUPPLEMENTARY(c2, c);</span>
                      }
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if(isMostDecompYesAndZeroCC(norm16=getNorm16(c))) {</span>
<span class="line-removed">-                     src+=U16_LENGTH(c);</span>
                  } else {
<span class="line-modified">!                     break;</span>
                  }
              }
          }
          // copy these code units all at once
          if(src!=prevSrc) {
<span class="line-new-header">--- 605,27 ---</span>
  
      for(;;) {
          // count code units below the minimum or with irrelevant data for the quick check
          for(prevSrc=src; src!=limit;) {
              if( (c=*src)&lt;minNoCP ||
<span class="line-modified">!                 isMostDecompYesAndZeroCC(norm16=UCPTRIE_FAST_BMP_GET(normTrie, UCPTRIE_16, c))</span>
              ) {
                  ++src;
<span class="line-modified">!             } else if(!U16_IS_LEAD(c)) {</span>
                  break;
              } else {
                  UChar c2;
<span class="line-modified">!                 if((src+1)!=limit &amp;&amp; U16_IS_TRAIL(c2=src[1])) {</span>
<span class="line-modified">!                     c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified">!                     norm16=UCPTRIE_FAST_SUPP_GET(normTrie, UCPTRIE_16, c);</span>
<span class="line-modified">!                     if(isMostDecompYesAndZeroCC(norm16)) {</span>
<span class="line-modified">!                         src+=2;</span>
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         break;</span>
                      }
                  } else {
<span class="line-modified">!                     ++src;  // unpaired lead surrogate: inert</span>
                  }
              }
          }
          // copy these code units all at once
          if(src!=prevSrc) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 711,11 ***</span>
              return src;
          }
          const UChar *prevSrc = src;
          UChar32 c;
          uint16_t norm16;
<span class="line-modified">!         UTRIE2_U16_NEXT16(normTrie, src, limit, c, norm16);</span>
          if (stopAtCompBoundary &amp;&amp; norm16HasCompBoundaryBefore(norm16)) {
              return prevSrc;
          }
          if(!decompose(c, norm16, buffer, errorCode)) {
              return nullptr;
<span class="line-new-header">--- 681,11 ---</span>
              return src;
          }
          const UChar *prevSrc = src;
          UChar32 c;
          uint16_t norm16;
<span class="line-modified">!         UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, src, limit, c, norm16);</span>
          if (stopAtCompBoundary &amp;&amp; norm16HasCompBoundaryBefore(norm16)) {
              return prevSrc;
          }
          if(!decompose(c, norm16, buffer, errorCode)) {
              return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,11 ***</span>
          if (isMaybeOrNonZeroCC(norm16)) {
              return buffer.append(c, getCCFromYesOrMaybe(norm16), errorCode);
          }
          // Maps to an isCompYesAndZeroCC.
          c=mapAlgorithmic(c, norm16);
<span class="line-modified">!         norm16=getNorm16(c);</span>
      }
      if (norm16 &lt; minYesNo) {
          // c does not decompose
          return buffer.append(c, 0, errorCode);
      } else if(isHangulLV(norm16) || isHangulLVT(norm16)) {
<span class="line-new-header">--- 705,11 ---</span>
          if (isMaybeOrNonZeroCC(norm16)) {
              return buffer.append(c, getCCFromYesOrMaybe(norm16), errorCode);
          }
          // Maps to an isCompYesAndZeroCC.
          c=mapAlgorithmic(c, norm16);
<span class="line-modified">!         norm16=getRawNorm16(c);</span>
      }
      if (norm16 &lt; minYesNo) {
          // c does not decompose
          return buffer.append(c, 0, errorCode);
      } else if(isHangulLV(norm16) || isHangulLVT(norm16)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 756,11 ***</span>
      if(firstUnit&amp;MAPPING_HAS_CCC_LCCC_WORD) {
          leadCC=(uint8_t)(*(mapping-1)&gt;&gt;8);
      } else {
          leadCC=0;
      }
<span class="line-modified">!     return buffer.append((const UChar *)mapping+1, length, leadCC, trailCC, errorCode);</span>
  }
  
  const uint8_t *
  Normalizer2Impl::decomposeShort(const uint8_t *src, const uint8_t *limit,
                                  UBool stopAtCompBoundary, UBool onlyContiguous,
<span class="line-new-header">--- 726,11 ---</span>
      if(firstUnit&amp;MAPPING_HAS_CCC_LCCC_WORD) {
          leadCC=(uint8_t)(*(mapping-1)&gt;&gt;8);
      } else {
          leadCC=0;
      }
<span class="line-modified">!     return buffer.append((const UChar *)mapping+1, length, TRUE, leadCC, trailCC, errorCode);</span>
  }
  
  const uint8_t *
  Normalizer2Impl::decomposeShort(const uint8_t *src, const uint8_t *limit,
                                  UBool stopAtCompBoundary, UBool onlyContiguous,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 769,11 ***</span>
          return nullptr;
      }
      while (src &lt; limit) {
          const uint8_t *prevSrc = src;
          uint16_t norm16;
<span class="line-modified">!         UTRIE2_U8_NEXT16(normTrie, src, limit, norm16);</span>
          // Get the decomposition and the lead and trail cc&#39;s.
          UChar32 c = U_SENTINEL;
          if (norm16 &gt;= limitNoNo) {
              if (isMaybeOrNonZeroCC(norm16)) {
                  // No boundaries around this character.
<span class="line-new-header">--- 739,11 ---</span>
          return nullptr;
      }
      while (src &lt; limit) {
          const uint8_t *prevSrc = src;
          uint16_t norm16;
<span class="line-modified">!         UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, src, limit, norm16);</span>
          // Get the decomposition and the lead and trail cc&#39;s.
          UChar32 c = U_SENTINEL;
          if (norm16 &gt;= limitNoNo) {
              if (isMaybeOrNonZeroCC(norm16)) {
                  // No boundaries around this character.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 787,11 ***</span>
              if (stopAtCompBoundary) {
                  return prevSrc;
              }
              c = codePointFromValidUTF8(prevSrc, src);
              c = mapAlgorithmic(c, norm16);
<span class="line-modified">!             norm16 = getNorm16(c);</span>
          } else if (stopAtCompBoundary &amp;&amp; norm16 &lt; minNoNoCompNoMaybeCC) {
              return prevSrc;
          }
          // norm16!=INERT guarantees that [prevSrc, src[ is valid UTF-8.
          // We do not see invalid UTF-8 here because
<span class="line-new-header">--- 757,11 ---</span>
              if (stopAtCompBoundary) {
                  return prevSrc;
              }
              c = codePointFromValidUTF8(prevSrc, src);
              c = mapAlgorithmic(c, norm16);
<span class="line-modified">!             norm16 = getRawNorm16(c);</span>
          } else if (stopAtCompBoundary &amp;&amp; norm16 &lt; minNoNoCompNoMaybeCC) {
              return prevSrc;
          }
          // norm16!=INERT guarantees that [prevSrc, src[ is valid UTF-8.
          // We do not see invalid UTF-8 here because
</pre>
<hr />
<pre>
<span class="line-old-header">*** 826,11 ***</span>
              if (firstUnit &amp; MAPPING_HAS_CCC_LCCC_WORD) {
                  leadCC = (uint8_t)(*(mapping-1) &gt;&gt; 8);
              } else {
                  leadCC = 0;
              }
<span class="line-modified">!             if (!buffer.append((const char16_t *)mapping+1, length, leadCC, trailCC, errorCode)) {</span>
                  return nullptr;
              }
          }
          if (stopAtCompBoundary &amp;&amp; norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
              return src;
<span class="line-new-header">--- 796,11 ---</span>
              if (firstUnit &amp; MAPPING_HAS_CCC_LCCC_WORD) {
                  leadCC = (uint8_t)(*(mapping-1) &gt;&gt; 8);
              } else {
                  leadCC = 0;
              }
<span class="line-modified">!             if (!buffer.append((const char16_t *)mapping+1, length, TRUE, leadCC, trailCC, errorCode)) {</span>
                  return nullptr;
              }
          }
          if (stopAtCompBoundary &amp;&amp; norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
              return src;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 852,11 ***</span>
          c=mapAlgorithmic(c, norm16);
          decomp=buffer;
          length=0;
          U16_APPEND_UNSAFE(buffer, length, c);
          // The mapping might decompose further.
<span class="line-modified">!         norm16 = getNorm16(c);</span>
      }
      if (norm16 &lt; minYesNo) {
          return decomp;
      } else if(isHangulLV(norm16) || isHangulLVT(norm16)) {
          // Hangul syllable: decompose algorithmically
<span class="line-new-header">--- 822,11 ---</span>
          c=mapAlgorithmic(c, norm16);
          decomp=buffer;
          length=0;
          U16_APPEND_UNSAFE(buffer, length, c);
          // The mapping might decompose further.
<span class="line-modified">!         norm16 = getRawNorm16(c);</span>
      }
      if (norm16 &lt; minYesNo) {
          return decomp;
      } else if(isHangulLV(norm16) || isHangulLVT(norm16)) {
          // Hangul syllable: decompose algorithmically
</pre>
<hr />
<pre>
<span class="line-old-header">*** 924,23 ***</span>
      if(doDecompose) {
          decompose(src, limit, &amp;buffer, errorCode);
          return;
      }
      // Just merge the strings at the boundary.
<span class="line-modified">!     ForwardUTrie2StringIterator iter(normTrie, src, limit);</span>
<span class="line-modified">!     uint8_t firstCC, prevCC, cc;</span>
<span class="line-modified">!     firstCC=prevCC=cc=getCC(iter.next16());</span>
<span class="line-modified">!     while(cc!=0) {</span>
<span class="line-modified">!         prevCC=cc;</span>
<span class="line-modified">!         cc=getCC(iter.next16());</span>
<span class="line-modified">!     };</span>
      if(limit==NULL) {  // appendZeroCC() needs limit!=NULL
<span class="line-modified">!         limit=u_strchr(iter.codePointStart, 0);</span>
      }
  
<span class="line-modified">!     if (buffer.append(src, (int32_t)(iter.codePointStart-src), firstCC, prevCC, errorCode)) {</span>
<span class="line-modified">!         buffer.appendZeroCC(iter.codePointStart, limit, errorCode);</span>
      }
  }
  
  UBool Normalizer2Impl::hasDecompBoundaryBefore(UChar32 c) const {
      return c &lt; minLcccCP || (c &lt;= 0xffff &amp;&amp; !singleLeadMightHaveNonZeroFCD16(c)) ||
<span class="line-new-header">--- 894,34 ---</span>
      if(doDecompose) {
          decompose(src, limit, &amp;buffer, errorCode);
          return;
      }
      // Just merge the strings at the boundary.
<span class="line-modified">!     bool isFirst = true;</span>
<span class="line-modified">!     uint8_t firstCC = 0, prevCC = 0, cc;</span>
<span class="line-modified">!     const UChar *p = src;</span>
<span class="line-modified">!     while (p != limit) {</span>
<span class="line-modified">!         const UChar *codePointStart = p;</span>
<span class="line-modified">!         UChar32 c;</span>
<span class="line-modified">!         uint16_t norm16;</span>
<span class="line-added">+         UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);</span>
<span class="line-added">+         if ((cc = getCC(norm16)) == 0) {</span>
<span class="line-added">+             p = codePointStart;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (isFirst) {</span>
<span class="line-added">+             firstCC = cc;</span>
<span class="line-added">+             isFirst = false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         prevCC = cc;</span>
<span class="line-added">+     }</span>
      if(limit==NULL) {  // appendZeroCC() needs limit!=NULL
<span class="line-modified">!         limit=u_strchr(p, 0);</span>
      }
  
<span class="line-modified">!     if (buffer.append(src, (int32_t)(p - src), FALSE, firstCC, prevCC, errorCode)) {</span>
<span class="line-modified">!         buffer.appendZeroCC(p, limit, errorCode);</span>
      }
  }
  
  UBool Normalizer2Impl::hasDecompBoundaryBefore(UChar32 c) const {
      return c &lt; minLcccCP || (c &lt;= 0xffff &amp;&amp; !singleLeadMightHaveNonZeroFCD16(c)) ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1083,11 ***</span>
              compositeAndFwd=(((int32_t)list[1]&amp;~COMP_2_TRAIL_MASK)&lt;&lt;16)|list[2];
              list+=3;
          }
          UChar32 composite=compositeAndFwd&gt;&gt;1;
          if((compositeAndFwd&amp;1)!=0) {
<span class="line-modified">!             addComposites(getCompositionsListForComposite(getNorm16(composite)), set);</span>
          }
          set.add(composite);
      } while((firstUnit&amp;COMP_1_LAST_TUPLE)==0);
  }
  
<span class="line-new-header">--- 1064,11 ---</span>
              compositeAndFwd=(((int32_t)list[1]&amp;~COMP_2_TRAIL_MASK)&lt;&lt;16)|list[2];
              list+=3;
          }
          UChar32 composite=compositeAndFwd&gt;&gt;1;
          if((compositeAndFwd&amp;1)!=0) {
<span class="line-modified">!             addComposites(getCompositionsListForComposite(getRawNorm16(composite)), set);</span>
          }
          set.add(composite);
      } while((firstUnit&amp;COMP_1_LAST_TUPLE)==0);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1122,11 ***</span>
      starter=NULL;
      starterIsSupplementary=FALSE;
      prevCC=0;
  
      for(;;) {
<span class="line-modified">!         UTRIE2_U16_NEXT16(normTrie, p, limit, c, norm16);</span>
          cc=getCCFromYesOrMaybe(norm16);
          if( // this character combines backward and
              isMaybe(norm16) &amp;&amp;
              // we have seen a starter that combines forward and
              compositionsList!=NULL &amp;&amp;
<span class="line-new-header">--- 1103,11 ---</span>
      starter=NULL;
      starterIsSupplementary=FALSE;
      prevCC=0;
  
      for(;;) {
<span class="line-modified">!         UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);</span>
          cc=getCCFromYesOrMaybe(norm16);
          if( // this character combines backward and
              isMaybe(norm16) &amp;&amp;
              // we have seen a starter that combines forward and
              compositionsList!=NULL &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1227,11 ***</span>
                      break;
                  }
                  // Is the composite a starter that combines forward?
                  if(compositeAndFwd&amp;1) {
                      compositionsList=
<span class="line-modified">!                         getCompositionsListForComposite(getNorm16(composite));</span>
                  } else {
                      compositionsList=NULL;
                  }
  
                  // We combined; continue with looking for compositions.
<span class="line-new-header">--- 1208,11 ---</span>
                      break;
                  }
                  // Is the composite a starter that combines forward?
                  if(compositeAndFwd&amp;1) {
                      compositionsList=
<span class="line-modified">!                         getCompositionsListForComposite(getRawNorm16(composite));</span>
                  } else {
                      compositionsList=NULL;
                  }
  
                  // We combined; continue with looking for compositions.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1266,11 ***</span>
      buffer.setReorderingLimit(limit);
  }
  
  UChar32
  Normalizer2Impl::composePair(UChar32 a, UChar32 b) const {
<span class="line-modified">!     uint16_t norm16=getNorm16(a);  // maps an out-of-range &#39;a&#39; to inert norm16=0</span>
      const uint16_t *list;
      if(isInert(norm16)) {
          return U_SENTINEL;
      } else if(norm16&lt;minYesNoMappingsOnly) {
          // a combines forward.
<span class="line-new-header">--- 1247,11 ---</span>
      buffer.setReorderingLimit(limit);
  }
  
  UChar32
  Normalizer2Impl::composePair(UChar32 a, UChar32 b) const {
<span class="line-modified">!     uint16_t norm16=getNorm16(a);  // maps an out-of-range &#39;a&#39; to inert norm16</span>
      const uint16_t *list;
      if(isInert(norm16)) {
          return U_SENTINEL;
      } else if(norm16&lt;minYesNoMappingsOnly) {
          // a combines forward.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1357,33 ***</span>
                      buffer.appendZeroCC(prevBoundary, limit, errorCode);
                  }
                  return TRUE;
              }
              if( (c=*src)&lt;minNoMaybeCP ||
<span class="line-modified">!                 isCompYesAndZeroCC(norm16=UTRIE2_GET16_FROM_U16_SINGLE_LEAD(normTrie, c))</span>
              ) {
                  ++src;
              } else {
                  prevSrc = src++;
<span class="line-modified">!                 if(!U16_IS_SURROGATE(c)) {</span>
                      break;
                  } else {
                      UChar c2;
<span class="line-modified">!                     if(U16_IS_SURROGATE_LEAD(c)) {</span>
<span class="line-modified">!                         if(src!=limit &amp;&amp; U16_IS_TRAIL(c2=*src)) {</span>
<span class="line-modified">!                             ++src;</span>
<span class="line-modified">!                             c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">!                     } else /* trail surrogate */ {</span>
<span class="line-removed">-                         if(prevBoundary&lt;prevSrc &amp;&amp; U16_IS_LEAD(c2=*(prevSrc-1))) {</span>
<span class="line-removed">-                             --prevSrc;</span>
<span class="line-removed">-                             c=U16_GET_SUPPLEMENTARY(c2, c);</span>
                          }
                      }
<span class="line-removed">-                     if(!isCompYesAndZeroCC(norm16=getNorm16(c))) {</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     }</span>
                  }
              }
          }
          // isCompYesAndZeroCC(norm16) is false, that is, norm16&gt;=minNoNo.
          // The current character is either a &quot;noNo&quot; (has a mapping)
<span class="line-new-header">--- 1338,27 ---</span>
                      buffer.appendZeroCC(prevBoundary, limit, errorCode);
                  }
                  return TRUE;
              }
              if( (c=*src)&lt;minNoMaybeCP ||
<span class="line-modified">!                 isCompYesAndZeroCC(norm16=UCPTRIE_FAST_BMP_GET(normTrie, UCPTRIE_16, c))</span>
              ) {
                  ++src;
              } else {
                  prevSrc = src++;
<span class="line-modified">!                 if(!U16_IS_LEAD(c)) {</span>
                      break;
                  } else {
                      UChar c2;
<span class="line-modified">!                     if(src!=limit &amp;&amp; U16_IS_TRAIL(c2=*src)) {</span>
<span class="line-modified">!                         ++src;</span>
<span class="line-modified">!                         c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified">!                         norm16=UCPTRIE_FAST_SUPP_GET(normTrie, UCPTRIE_16, c);</span>
<span class="line-modified">!                         if(!isCompYesAndZeroCC(norm16)) {</span>
<span class="line-modified">!                             break;</span>
                          }
                      }
                  }
              }
          }
          // isCompYesAndZeroCC(norm16) is false, that is, norm16&gt;=minNoNo.
          // The current character is either a &quot;noNo&quot; (has a mapping)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1527,11 ***</span>
                          }
                          return TRUE;
                      }
                      uint8_t prevCC = cc;
                      nextSrc = src;
<span class="line-modified">!                     UTRIE2_U16_NEXT16(normTrie, nextSrc, limit, c, n16);</span>
                      if (n16 &gt;= MIN_YES_YES_WITH_CC) {
                          cc = getCCFromNormalYesOrMaybe(n16);
                          if (prevCC &gt; cc) {
                              if (!doCompose) {
                                  return FALSE;
<span class="line-new-header">--- 1502,11 ---</span>
                          }
                          return TRUE;
                      }
                      uint8_t prevCC = cc;
                      nextSrc = src;
<span class="line-modified">!                     UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, nextSrc, limit, c, n16);</span>
                      if (n16 &gt;= MIN_YES_YES_WITH_CC) {
                          cc = getCCFromNormalYesOrMaybe(n16);
                          if (prevCC &gt; cc) {
                              if (!doCompose) {
                                  return FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1557,11 ***</span>
  
          // Slow path: Find the nearest boundaries around the current character,
          // decompose and recompose.
          if (prevBoundary != prevSrc &amp;&amp; !norm16HasCompBoundaryBefore(norm16)) {
              const UChar *p = prevSrc;
<span class="line-modified">!             UTRIE2_U16_PREV16(normTrie, prevBoundary, p, c, norm16);</span>
              if (!norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
                  prevSrc = p;
              }
          }
          if (doCompose &amp;&amp; prevBoundary != prevSrc &amp;&amp; !buffer.appendZeroCC(prevBoundary, prevSrc, errorCode)) {
<span class="line-new-header">--- 1532,11 ---</span>
  
          // Slow path: Find the nearest boundaries around the current character,
          // decompose and recompose.
          if (prevBoundary != prevSrc &amp;&amp; !norm16HasCompBoundaryBefore(norm16)) {
              const UChar *p = prevSrc;
<span class="line-modified">!             UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, prevBoundary, p, c, norm16);</span>
              if (!norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
                  prevSrc = p;
              }
          }
          if (doCompose &amp;&amp; prevBoundary != prevSrc &amp;&amp; !buffer.appendZeroCC(prevBoundary, prevSrc, errorCode)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1624,33 ***</span>
          for (;;) {
              if(src==limit) {
                  return src;
              }
              if( (c=*src)&lt;minNoMaybeCP ||
<span class="line-modified">!                 isCompYesAndZeroCC(norm16=UTRIE2_GET16_FROM_U16_SINGLE_LEAD(normTrie, c))</span>
              ) {
                  ++src;
              } else {
                  prevSrc = src++;
<span class="line-modified">!                 if(!U16_IS_SURROGATE(c)) {</span>
                      break;
                  } else {
                      UChar c2;
<span class="line-modified">!                     if(U16_IS_SURROGATE_LEAD(c)) {</span>
<span class="line-modified">!                         if(src!=limit &amp;&amp; U16_IS_TRAIL(c2=*src)) {</span>
<span class="line-modified">!                             ++src;</span>
<span class="line-modified">!                             c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">!                     } else /* trail surrogate */ {</span>
<span class="line-removed">-                         if(prevBoundary&lt;prevSrc &amp;&amp; U16_IS_LEAD(c2=*(prevSrc-1))) {</span>
<span class="line-removed">-                             --prevSrc;</span>
<span class="line-removed">-                             c=U16_GET_SUPPLEMENTARY(c2, c);</span>
                          }
                      }
<span class="line-removed">-                     if(!isCompYesAndZeroCC(norm16=getNorm16(c))) {</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     }</span>
                  }
              }
          }
          // isCompYesAndZeroCC(norm16) is false, that is, norm16&gt;=minNoNo.
          // The current character is either a &quot;noNo&quot; (has a mapping)
<span class="line-new-header">--- 1599,27 ---</span>
          for (;;) {
              if(src==limit) {
                  return src;
              }
              if( (c=*src)&lt;minNoMaybeCP ||
<span class="line-modified">!                 isCompYesAndZeroCC(norm16=UCPTRIE_FAST_BMP_GET(normTrie, UCPTRIE_16, c))</span>
              ) {
                  ++src;
              } else {
                  prevSrc = src++;
<span class="line-modified">!                 if(!U16_IS_LEAD(c)) {</span>
                      break;
                  } else {
                      UChar c2;
<span class="line-modified">!                     if(src!=limit &amp;&amp; U16_IS_TRAIL(c2=*src)) {</span>
<span class="line-modified">!                         ++src;</span>
<span class="line-modified">!                         c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-modified">!                         norm16=UCPTRIE_FAST_SUPP_GET(normTrie, UCPTRIE_16, c);</span>
<span class="line-modified">!                         if(!isCompYesAndZeroCC(norm16)) {</span>
<span class="line-modified">!                             break;</span>
                          }
                      }
                  }
              }
          }
          // isCompYesAndZeroCC(norm16) is false, that is, norm16&gt;=minNoNo.
          // The current character is either a &quot;noNo&quot; (has a mapping)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1663,11 ***</span>
              if (norm16HasCompBoundaryBefore(norm16)) {
                  prevBoundary = prevSrc;
              } else {
                  const UChar *p = prevSrc;
                  uint16_t n16;
<span class="line-modified">!                 UTRIE2_U16_PREV16(normTrie, prevBoundary, p, c, n16);</span>
                  if (norm16HasCompBoundaryAfter(n16, onlyContiguous)) {
                      prevBoundary = prevSrc;
                  } else {
                      prevBoundary = p;
                      prevNorm16 = n16;
<span class="line-new-header">--- 1632,11 ---</span>
              if (norm16HasCompBoundaryBefore(norm16)) {
                  prevBoundary = prevSrc;
              } else {
                  const UChar *p = prevSrc;
                  uint16_t n16;
<span class="line-modified">!                 UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, prevBoundary, p, c, n16);</span>
                  if (norm16HasCompBoundaryAfter(n16, onlyContiguous)) {
                      prevBoundary = prevSrc;
                  } else {
                      prevBoundary = p;
                      prevNorm16 = n16;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1697,11 ***</span>
                      if (src == limit) {
                          return src;
                      }
                      uint8_t prevCC = cc;
                      nextSrc = src;
<span class="line-modified">!                     UTRIE2_U16_NEXT16(normTrie, nextSrc, limit, c, norm16);</span>
                      if (isMaybeOrNonZeroCC(norm16)) {
                          cc = getCCFromYesOrMaybe(norm16);
                          if (!(prevCC &lt;= cc || cc == 0)) {
                              break;
                          }
<span class="line-new-header">--- 1666,11 ---</span>
                      if (src == limit) {
                          return src;
                      }
                      uint8_t prevCC = cc;
                      nextSrc = src;
<span class="line-modified">!                     UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, nextSrc, limit, c, norm16);</span>
                      if (isMaybeOrNonZeroCC(norm16)) {
                          cc = getCCFromYesOrMaybe(norm16);
                          if (!(prevCC &lt;= cc || cc == 0)) {
                              break;
                          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1784,11 ***</span>
              }
              if (*src &lt; minNoMaybeLead) {
                  ++src;
              } else {
                  prevSrc = src;
<span class="line-modified">!                 UTRIE2_U8_NEXT16(normTrie, src, limit, norm16);</span>
                  if (!isCompYesAndZeroCC(norm16)) {
                      break;
                  }
              }
          }
<span class="line-new-header">--- 1753,11 ---</span>
              }
              if (*src &lt; minNoMaybeLead) {
                  ++src;
              } else {
                  prevSrc = src;
<span class="line-modified">!                 UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, src, limit, norm16);</span>
                  if (!isCompYesAndZeroCC(norm16)) {
                      break;
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1943,11 ***</span>
                          }
                          return TRUE;
                      }
                      uint8_t prevCC = cc;
                      nextSrc = src;
<span class="line-modified">!                     UTRIE2_U8_NEXT16(normTrie, nextSrc, limit, n16);</span>
                      if (n16 &gt;= MIN_YES_YES_WITH_CC) {
                          cc = getCCFromNormalYesOrMaybe(n16);
                          if (prevCC &gt; cc) {
                              if (sink == nullptr) {
                                  return FALSE;
<span class="line-new-header">--- 1912,11 ---</span>
                          }
                          return TRUE;
                      }
                      uint8_t prevCC = cc;
                      nextSrc = src;
<span class="line-modified">!                     UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, nextSrc, limit, n16);</span>
                      if (n16 &gt;= MIN_YES_YES_WITH_CC) {
                          cc = getCCFromNormalYesOrMaybe(n16);
                          if (prevCC &gt; cc) {
                              if (sink == nullptr) {
                                  return FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1973,11 ***</span>
  
          // Slow path: Find the nearest boundaries around the current character,
          // decompose and recompose.
          if (prevBoundary != prevSrc &amp;&amp; !norm16HasCompBoundaryBefore(norm16)) {
              const uint8_t *p = prevSrc;
<span class="line-modified">!             UTRIE2_U8_PREV16(normTrie, prevBoundary, p, norm16);</span>
              if (!norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
                  prevSrc = p;
              }
          }
          ReorderingBuffer buffer(*this, s16, errorCode);
<span class="line-new-header">--- 1942,11 ---</span>
  
          // Slow path: Find the nearest boundaries around the current character,
          // decompose and recompose.
          if (prevBoundary != prevSrc &amp;&amp; !norm16HasCompBoundaryBefore(norm16)) {
              const uint8_t *p = prevSrc;
<span class="line-modified">!             UCPTRIE_FAST_U8_PREV(normTrie, UCPTRIE_16, prevBoundary, p, norm16);</span>
              if (!norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
                  prevSrc = p;
              }
          }
          ReorderingBuffer buffer(*this, s16, errorCode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2021,70 ***</span>
      if (src == limit || *src &lt; minCompNoMaybeCP) {
          return TRUE;
      }
      UChar32 c;
      uint16_t norm16;
<span class="line-modified">!     UTRIE2_U16_NEXT16(normTrie, src, limit, c, norm16);</span>
      return norm16HasCompBoundaryBefore(norm16);
  }
  
  UBool Normalizer2Impl::hasCompBoundaryBefore(const uint8_t *src, const uint8_t *limit) const {
      if (src == limit) {
          return TRUE;
      }
      uint16_t norm16;
<span class="line-modified">!     UTRIE2_U8_NEXT16(normTrie, src, limit, norm16);</span>
      return norm16HasCompBoundaryBefore(norm16);
  }
  
  UBool Normalizer2Impl::hasCompBoundaryAfter(const UChar *start, const UChar *p,
                                              UBool onlyContiguous) const {
      if (start == p) {
          return TRUE;
      }
      UChar32 c;
      uint16_t norm16;
<span class="line-modified">!     UTRIE2_U16_PREV16(normTrie, start, p, c, norm16);</span>
      return norm16HasCompBoundaryAfter(norm16, onlyContiguous);
  }
  
  UBool Normalizer2Impl::hasCompBoundaryAfter(const uint8_t *start, const uint8_t *p,
                                              UBool onlyContiguous) const {
      if (start == p) {
          return TRUE;
      }
      uint16_t norm16;
<span class="line-modified">!     UTRIE2_U8_PREV16(normTrie, start, p, norm16);</span>
      return norm16HasCompBoundaryAfter(norm16, onlyContiguous);
  }
  
  const UChar *Normalizer2Impl::findPreviousCompBoundary(const UChar *start, const UChar *p,
                                                         UBool onlyContiguous) const {
<span class="line-modified">!     BackwardUTrie2StringIterator iter(normTrie, start, p);</span>
<span class="line-modified">!     for(;;) {</span>
<span class="line-modified">!         uint16_t norm16=iter.previous16();</span>
          if (norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
<span class="line-modified">!             return iter.codePointLimit;</span>
          }
<span class="line-modified">!         if (hasCompBoundaryBefore(iter.codePoint, norm16)) {</span>
<span class="line-modified">!             return iter.codePointStart;</span>
          }
      }
  }
  
  const UChar *Normalizer2Impl::findNextCompBoundary(const UChar *p, const UChar *limit,
                                                     UBool onlyContiguous) const {
<span class="line-modified">!     ForwardUTrie2StringIterator iter(normTrie, p, limit);</span>
<span class="line-modified">!     for(;;) {</span>
<span class="line-modified">!         uint16_t norm16=iter.next16();</span>
<span class="line-modified">!         if (hasCompBoundaryBefore(iter.codePoint, norm16)) {</span>
<span class="line-modified">!             return iter.codePointStart;</span>
          }
          if (norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
<span class="line-modified">!             return iter.codePointLimit;</span>
          }
      }
  }
  
  uint8_t Normalizer2Impl::getPreviousTrailCC(const UChar *start, const UChar *p) const {
      if (start == p) {
          return 0;
<span class="line-new-header">--- 1990,76 ---</span>
      if (src == limit || *src &lt; minCompNoMaybeCP) {
          return TRUE;
      }
      UChar32 c;
      uint16_t norm16;
<span class="line-modified">!     UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, src, limit, c, norm16);</span>
      return norm16HasCompBoundaryBefore(norm16);
  }
  
  UBool Normalizer2Impl::hasCompBoundaryBefore(const uint8_t *src, const uint8_t *limit) const {
      if (src == limit) {
          return TRUE;
      }
      uint16_t norm16;
<span class="line-modified">!     UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, src, limit, norm16);</span>
      return norm16HasCompBoundaryBefore(norm16);
  }
  
  UBool Normalizer2Impl::hasCompBoundaryAfter(const UChar *start, const UChar *p,
                                              UBool onlyContiguous) const {
      if (start == p) {
          return TRUE;
      }
      UChar32 c;
      uint16_t norm16;
<span class="line-modified">!     UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, start, p, c, norm16);</span>
      return norm16HasCompBoundaryAfter(norm16, onlyContiguous);
  }
  
  UBool Normalizer2Impl::hasCompBoundaryAfter(const uint8_t *start, const uint8_t *p,
                                              UBool onlyContiguous) const {
      if (start == p) {
          return TRUE;
      }
      uint16_t norm16;
<span class="line-modified">!     UCPTRIE_FAST_U8_PREV(normTrie, UCPTRIE_16, start, p, norm16);</span>
      return norm16HasCompBoundaryAfter(norm16, onlyContiguous);
  }
  
  const UChar *Normalizer2Impl::findPreviousCompBoundary(const UChar *start, const UChar *p,
                                                         UBool onlyContiguous) const {
<span class="line-modified">!     while (p != start) {</span>
<span class="line-modified">!         const UChar *codePointLimit = p;</span>
<span class="line-modified">!         UChar32 c;</span>
<span class="line-added">+         uint16_t norm16;</span>
<span class="line-added">+         UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, start, p, c, norm16);</span>
          if (norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
<span class="line-modified">!             return codePointLimit;</span>
          }
<span class="line-modified">!         if (hasCompBoundaryBefore(c, norm16)) {</span>
<span class="line-modified">!             return p;</span>
          }
      }
<span class="line-added">+     return p;</span>
  }
  
  const UChar *Normalizer2Impl::findNextCompBoundary(const UChar *p, const UChar *limit,
                                                     UBool onlyContiguous) const {
<span class="line-modified">!     while (p != limit) {</span>
<span class="line-modified">!         const UChar *codePointStart = p;</span>
<span class="line-modified">!         UChar32 c;</span>
<span class="line-modified">!         uint16_t norm16;</span>
<span class="line-modified">!         UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);</span>
<span class="line-added">+         if (hasCompBoundaryBefore(c, norm16)) {</span>
<span class="line-added">+             return codePointStart;</span>
          }
          if (norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {
<span class="line-modified">!             return p;</span>
          }
      }
<span class="line-added">+     return p;</span>
  }
  
  uint8_t Normalizer2Impl::getPreviousTrailCC(const UChar *start, const UChar *p) const {
      if (start == p) {
          return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2128,11 ***</span>
              if (deltaTrailCC &lt;= DELTA_TCCC_1) {
                  return deltaTrailCC &gt;&gt; OFFSET_SHIFT;
              }
              // Maps to an isCompYesAndZeroCC.
              c=mapAlgorithmic(c, norm16);
<span class="line-modified">!             norm16=getNorm16(c);</span>
          }
      }
      if(norm16&lt;=minYesNo || isHangulLVT(norm16)) {
          // no decomposition or Hangul syllable, all zeros
          return 0;
<span class="line-new-header">--- 2103,11 ---</span>
              if (deltaTrailCC &lt;= DELTA_TCCC_1) {
                  return deltaTrailCC &gt;&gt; OFFSET_SHIFT;
              }
              // Maps to an isCompYesAndZeroCC.
              c=mapAlgorithmic(c, norm16);
<span class="line-modified">!             norm16=getRawNorm16(c);</span>
          }
      }
      if(norm16&lt;=minYesNo || isHangulLVT(norm16)) {
          // no decomposition or Hangul syllable, all zeros
          return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2193,21 ***</span>
                  ++src;
              } else if(!singleLeadMightHaveNonZeroFCD16(c)) {
                  prevFCD16=0;
                  ++src;
              } else {
<span class="line-modified">!                 if(U16_IS_SURROGATE(c)) {</span>
                      UChar c2;
<span class="line-modified">!                     if(U16_IS_SURROGATE_LEAD(c)) {</span>
<span class="line-modified">!                         if((src+1)!=limit &amp;&amp; U16_IS_TRAIL(c2=src[1])) {</span>
<span class="line-removed">-                             c=U16_GET_SUPPLEMENTARY(c, c2);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     } else /* trail surrogate */ {</span>
<span class="line-removed">-                         if(prevSrc&lt;src &amp;&amp; U16_IS_LEAD(c2=*(src-1))) {</span>
<span class="line-removed">-                             --src;</span>
<span class="line-removed">-                             c=U16_GET_SUPPLEMENTARY(c2, c);</span>
<span class="line-removed">-                         }</span>
                      }
                  }
                  if((fcd16=getFCD16FromNormData(c))&lt;=0xff) {
                      prevFCD16=fcd16;
                      src+=U16_LENGTH(c);
<span class="line-new-header">--- 2168,14 ---</span>
                  ++src;
              } else if(!singleLeadMightHaveNonZeroFCD16(c)) {
                  prevFCD16=0;
                  ++src;
              } else {
<span class="line-modified">!                 if(U16_IS_LEAD(c)) {</span>
                      UChar c2;
<span class="line-modified">!                     if((src+1)!=limit &amp;&amp; U16_IS_TRAIL(c2=src[1])) {</span>
<span class="line-modified">!                         c=U16_GET_SUPPLEMENTARY(c, c2);</span>
                      }
                  }
                  if((fcd16=getFCD16FromNormData(c))&lt;=0xff) {
                      prevFCD16=fcd16;
                      src+=U16_LENGTH(c);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2334,11 ***</span>
  const UChar *Normalizer2Impl::findPreviousFCDBoundary(const UChar *start, const UChar *p) const {
      while(start&lt;p) {
          const UChar *codePointLimit = p;
          UChar32 c;
          uint16_t norm16;
<span class="line-modified">!         UTRIE2_U16_PREV16(normTrie, start, p, c, norm16);</span>
          if (c &lt; minDecompNoCP || norm16HasDecompBoundaryAfter(norm16)) {
              return codePointLimit;
          }
          if (norm16HasDecompBoundaryBefore(norm16)) {
              return p;
<span class="line-new-header">--- 2302,11 ---</span>
  const UChar *Normalizer2Impl::findPreviousFCDBoundary(const UChar *start, const UChar *p) const {
      while(start&lt;p) {
          const UChar *codePointLimit = p;
          UChar32 c;
          uint16_t norm16;
<span class="line-modified">!         UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, start, p, c, norm16);</span>
          if (c &lt; minDecompNoCP || norm16HasDecompBoundaryAfter(norm16)) {
              return codePointLimit;
          }
          if (norm16HasDecompBoundaryBefore(norm16)) {
              return p;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2350,11 ***</span>
  const UChar *Normalizer2Impl::findNextFCDBoundary(const UChar *p, const UChar *limit) const {
      while(p&lt;limit) {
          const UChar *codePointStart=p;
          UChar32 c;
          uint16_t norm16;
<span class="line-modified">!         UTRIE2_U16_NEXT16(normTrie, p, limit, c, norm16);</span>
          if (c &lt; minLcccCP || norm16HasDecompBoundaryBefore(norm16)) {
              return codePointStart;
          }
          if (norm16HasDecompBoundaryAfter(norm16)) {
              return p;
<span class="line-new-header">--- 2318,11 ---</span>
  const UChar *Normalizer2Impl::findNextFCDBoundary(const UChar *p, const UChar *limit) const {
      while(p&lt;limit) {
          const UChar *codePointStart=p;
          UChar32 c;
          uint16_t norm16;
<span class="line-modified">!         UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);</span>
          if (c &lt; minLcccCP || norm16HasDecompBoundaryBefore(norm16)) {
              return codePointStart;
          }
          if (norm16HasDecompBoundaryAfter(norm16)) {
              return p;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2364,23 ***</span>
  }
  
  // CanonicalIterator data -------------------------------------------------- ***
  
  CanonIterData::CanonIterData(UErrorCode &amp;errorCode) :
<span class="line-modified">!         trie(utrie2_open(0, 0, &amp;errorCode)),</span>
          canonStartSets(uprv_deleteUObject, NULL, errorCode) {}
  
  CanonIterData::~CanonIterData() {
<span class="line-modified">!     utrie2_close(trie);</span>
  }
  
  void CanonIterData::addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode &amp;errorCode) {
<span class="line-modified">!     uint32_t canonValue=utrie2_get32(trie, decompLead);</span>
      if((canonValue&amp;(CANON_HAS_SET|CANON_VALUE_MASK))==0 &amp;&amp; origin!=0) {
          // origin is the first character whose decomposition starts with
          // the character for which we are setting the value.
<span class="line-modified">!         utrie2_set32(trie, decompLead, canonValue|origin, &amp;errorCode);</span>
      } else {
          // origin is not the first character, or it is U+0000.
          UnicodeSet *set;
          if((canonValue&amp;CANON_HAS_SET)==0) {
              set=new UnicodeSet;
<span class="line-new-header">--- 2332,24 ---</span>
  }
  
  // CanonicalIterator data -------------------------------------------------- ***
  
  CanonIterData::CanonIterData(UErrorCode &amp;errorCode) :
<span class="line-modified">!         mutableTrie(umutablecptrie_open(0, 0, &amp;errorCode)), trie(nullptr),</span>
          canonStartSets(uprv_deleteUObject, NULL, errorCode) {}
  
  CanonIterData::~CanonIterData() {
<span class="line-modified">!     umutablecptrie_close(mutableTrie);</span>
<span class="line-added">+     ucptrie_close(trie);</span>
  }
  
  void CanonIterData::addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode &amp;errorCode) {
<span class="line-modified">!     uint32_t canonValue = umutablecptrie_get(mutableTrie, decompLead);</span>
      if((canonValue&amp;(CANON_HAS_SET|CANON_VALUE_MASK))==0 &amp;&amp; origin!=0) {
          // origin is the first character whose decomposition starts with
          // the character for which we are setting the value.
<span class="line-modified">!         umutablecptrie_set(mutableTrie, decompLead, canonValue|origin, &amp;errorCode);</span>
      } else {
          // origin is not the first character, or it is U+0000.
          UnicodeSet *set;
          if((canonValue&amp;CANON_HAS_SET)==0) {
              set=new UnicodeSet;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2388,11 ***</span>
                  errorCode=U_MEMORY_ALLOCATION_ERROR;
                  return;
              }
              UChar32 firstOrigin=(UChar32)(canonValue&amp;CANON_VALUE_MASK);
              canonValue=(canonValue&amp;~CANON_VALUE_MASK)|CANON_HAS_SET|(uint32_t)canonStartSets.size();
<span class="line-modified">!             utrie2_set32(trie, decompLead, canonValue, &amp;errorCode);</span>
              canonStartSets.addElement(set, errorCode);
              if(firstOrigin!=0) {
                  set-&gt;add(firstOrigin);
              }
          } else {
<span class="line-new-header">--- 2357,11 ---</span>
                  errorCode=U_MEMORY_ALLOCATION_ERROR;
                  return;
              }
              UChar32 firstOrigin=(UChar32)(canonValue&amp;CANON_VALUE_MASK);
              canonValue=(canonValue&amp;~CANON_VALUE_MASK)|CANON_HAS_SET|(uint32_t)canonStartSets.size();
<span class="line-modified">!             umutablecptrie_set(mutableTrie, decompLead, canonValue, &amp;errorCode);</span>
              canonStartSets.addElement(set, errorCode);
              if(firstOrigin!=0) {
                  set-&gt;add(firstOrigin);
              }
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2404,56 ***</span>
  
  // C++ class for friend access to private Normalizer2Impl members.
  class InitCanonIterData {
  public:
      static void doInit(Normalizer2Impl *impl, UErrorCode &amp;errorCode);
<span class="line-removed">-     static void handleRange(Normalizer2Impl *impl, UChar32 start, UChar32 end, uint16_t value, UErrorCode &amp;errorCode);</span>
  };
  
  U_CDECL_BEGIN
  
  // UInitOnce instantiation function for CanonIterData
  static void U_CALLCONV
  initCanonIterData(Normalizer2Impl *impl, UErrorCode &amp;errorCode) {
      InitCanonIterData::doInit(impl, errorCode);
  }
  
<span class="line-removed">- // Call Normalizer2Impl::makeCanonIterDataFromNorm16() for a range of same-norm16 characters.</span>
<span class="line-removed">- //     context: the Normalizer2Impl</span>
<span class="line-removed">- static UBool U_CALLCONV</span>
<span class="line-removed">- enumCIDRangeHandler(const void *context, UChar32 start, UChar32 end, uint32_t value) {</span>
<span class="line-removed">-     UErrorCode errorCode = U_ZERO_ERROR;</span>
<span class="line-removed">-     if (value != Normalizer2Impl::INERT) {</span>
<span class="line-removed">-         Normalizer2Impl *impl = (Normalizer2Impl *)context;</span>
<span class="line-removed">-         InitCanonIterData::handleRange(impl, start, end, (uint16_t)value, errorCode);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return U_SUCCESS(errorCode);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  U_CDECL_END
  
  void InitCanonIterData::doInit(Normalizer2Impl *impl, UErrorCode &amp;errorCode) {
      U_ASSERT(impl-&gt;fCanonIterData == NULL);
      impl-&gt;fCanonIterData = new CanonIterData(errorCode);
      if (impl-&gt;fCanonIterData == NULL) {
          errorCode=U_MEMORY_ALLOCATION_ERROR;
      }
      if (U_SUCCESS(errorCode)) {
<span class="line-modified">!         utrie2_enum(impl-&gt;normTrie, NULL, enumCIDRangeHandler, impl);</span>
<span class="line-modified">!         utrie2_freeze(impl-&gt;fCanonIterData-&gt;trie, UTRIE2_32_VALUE_BITS, &amp;errorCode);</span>
      }
      if (U_FAILURE(errorCode)) {
          delete impl-&gt;fCanonIterData;
          impl-&gt;fCanonIterData = NULL;
      }
<span class="line-removed">- void InitCanonIterData::handleRange(</span>
<span class="line-removed">-         Normalizer2Impl *impl, UChar32 start, UChar32 end, uint16_t value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed">-     impl-&gt;makeCanonIterDataFromNorm16(start, end, value, *impl-&gt;fCanonIterData, errorCode);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Normalizer2Impl::makeCanonIterDataFromNorm16(UChar32 start, UChar32 end, const uint16_t norm16,
                                                    CanonIterData &amp;newData,
                                                    UErrorCode &amp;errorCode) const {
      if(isInert(norm16) || (minYesNo&lt;=norm16 &amp;&amp; norm16&lt;minNoNo)) {
          // Inert, or 2-way mapping (including Hangul syllable).
<span class="line-new-header">--- 2373,54 ---</span>
  
  // C++ class for friend access to private Normalizer2Impl members.
  class InitCanonIterData {
  public:
      static void doInit(Normalizer2Impl *impl, UErrorCode &amp;errorCode);
  };
  
  U_CDECL_BEGIN
  
  // UInitOnce instantiation function for CanonIterData
  static void U_CALLCONV
  initCanonIterData(Normalizer2Impl *impl, UErrorCode &amp;errorCode) {
      InitCanonIterData::doInit(impl, errorCode);
  }
  
  U_CDECL_END
  
  void InitCanonIterData::doInit(Normalizer2Impl *impl, UErrorCode &amp;errorCode) {
      U_ASSERT(impl-&gt;fCanonIterData == NULL);
      impl-&gt;fCanonIterData = new CanonIterData(errorCode);
      if (impl-&gt;fCanonIterData == NULL) {
          errorCode=U_MEMORY_ALLOCATION_ERROR;
      }
      if (U_SUCCESS(errorCode)) {
<span class="line-modified">!         UChar32 start = 0, end;</span>
<span class="line-modified">!         uint32_t value;</span>
<span class="line-added">+         while ((end = ucptrie_getRange(impl-&gt;normTrie, start,</span>
<span class="line-added">+                                        UCPMAP_RANGE_FIXED_LEAD_SURROGATES, Normalizer2Impl::INERT,</span>
<span class="line-added">+                                        nullptr, nullptr, &amp;value)) &gt;= 0) {</span>
<span class="line-added">+             // Call Normalizer2Impl::makeCanonIterDataFromNorm16() for a range of same-norm16 characters.</span>
<span class="line-added">+             if (value != Normalizer2Impl::INERT) {</span>
<span class="line-added">+                 impl-&gt;makeCanonIterDataFromNorm16(start, end, value, *impl-&gt;fCanonIterData, errorCode);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             start = end + 1;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #ifdef UCPTRIE_DEBUG</span>
<span class="line-added">+         umutablecptrie_setName(impl-&gt;fCanonIterData-&gt;mutableTrie, &quot;CanonIterData&quot;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         impl-&gt;fCanonIterData-&gt;trie = umutablecptrie_buildImmutable(</span>
<span class="line-added">+             impl-&gt;fCanonIterData-&gt;mutableTrie, UCPTRIE_TYPE_SMALL, UCPTRIE_VALUE_BITS_32, &amp;errorCode);</span>
<span class="line-added">+         umutablecptrie_close(impl-&gt;fCanonIterData-&gt;mutableTrie);</span>
<span class="line-added">+         impl-&gt;fCanonIterData-&gt;mutableTrie = nullptr;</span>
      }
      if (U_FAILURE(errorCode)) {
          delete impl-&gt;fCanonIterData;
          impl-&gt;fCanonIterData = NULL;
      }
  void Normalizer2Impl::makeCanonIterDataFromNorm16(UChar32 start, UChar32 end, const uint16_t norm16,
                                                    CanonIterData &amp;newData,
                                                    UErrorCode &amp;errorCode) const {
      if(isInert(norm16) || (minYesNo&lt;=norm16 &amp;&amp; norm16&lt;minNoNo)) {
          // Inert, or 2-way mapping (including Hangul syllable).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2463,11 ***</span>
          // 2-way mappings get CANON_NOT_SEGMENT_STARTER set because they are
          // &quot;maybe&quot; characters.
          return;
      }
      for(UChar32 c=start; c&lt;=end; ++c) {
<span class="line-modified">!         uint32_t oldValue=utrie2_get32(newData.trie, c);</span>
          uint32_t newValue=oldValue;
          if(isMaybeOrNonZeroCC(norm16)) {
              // not a segment starter if it occurs in a decomposition or has cc!=0
              newValue|=CANON_NOT_SEGMENT_STARTER;
              if(norm16&lt;MIN_NORMAL_MAYBE_YES) {
<span class="line-new-header">--- 2430,11 ---</span>
          // 2-way mappings get CANON_NOT_SEGMENT_STARTER set because they are
          // &quot;maybe&quot; characters.
          return;
      }
      for(UChar32 c=start; c&lt;=end; ++c) {
<span class="line-modified">!         uint32_t oldValue = umutablecptrie_get(newData.mutableTrie, c);</span>
          uint32_t newValue=oldValue;
          if(isMaybeOrNonZeroCC(norm16)) {
              // not a segment starter if it occurs in a decomposition or has cc!=0
              newValue|=CANON_NOT_SEGMENT_STARTER;
              if(norm16&lt;MIN_NORMAL_MAYBE_YES) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2481,11 ***</span>
              // Do not modify the whole-range norm16 value.
              uint16_t norm16_2=norm16;
              if (isDecompNoAlgorithmic(norm16_2)) {
                  // Maps to an isCompYesAndZeroCC.
                  c2 = mapAlgorithmic(c2, norm16_2);
<span class="line-modified">!                 norm16_2 = getNorm16(c2);</span>
                  // No compatibility mappings for the CanonicalIterator.
                  U_ASSERT(!(isHangulLV(norm16_2) || isHangulLVT(norm16_2)));
              }
              if (norm16_2 &gt; minYesNo) {
                  // c decomposes, get everything from the variable-length extra data
<span class="line-new-header">--- 2448,11 ---</span>
              // Do not modify the whole-range norm16 value.
              uint16_t norm16_2=norm16;
              if (isDecompNoAlgorithmic(norm16_2)) {
                  // Maps to an isCompYesAndZeroCC.
                  c2 = mapAlgorithmic(c2, norm16_2);
<span class="line-modified">!                 norm16_2 = getRawNorm16(c2);</span>
                  // No compatibility mappings for the CanonicalIterator.
                  U_ASSERT(!(isHangulLV(norm16_2) || isHangulLVT(norm16_2)));
              }
              if (norm16_2 &gt; minYesNo) {
                  // c decomposes, get everything from the variable-length extra data
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2508,25 ***</span>
                      // one-way mapping. A 2-way mapping is possible here after
                      // intermediate algorithmic mapping.
                      if(norm16_2&gt;=minNoNo) {
                          while(i&lt;length) {
                              U16_NEXT_UNSAFE(mapping, i, c2);
<span class="line-modified">!                             uint32_t c2Value=utrie2_get32(newData.trie, c2);</span>
                              if((c2Value&amp;CANON_NOT_SEGMENT_STARTER)==0) {
<span class="line-modified">!                                 utrie2_set32(newData.trie, c2, c2Value|CANON_NOT_SEGMENT_STARTER,</span>
<span class="line-modified">!                                              &amp;errorCode);</span>
                              }
                          }
                      }
                  }
              } else {
                  // c decomposed to c2 algorithmically; c has cc==0
                  newData.addToStartSet(c, c2, errorCode);
              }
          }
          if(newValue!=oldValue) {
<span class="line-modified">!             utrie2_set32(newData.trie, c, newValue, &amp;errorCode);</span>
          }
      }
  }
  
  UBool Normalizer2Impl::ensureCanonIterData(UErrorCode &amp;errorCode) const {
<span class="line-new-header">--- 2475,25 ---</span>
                      // one-way mapping. A 2-way mapping is possible here after
                      // intermediate algorithmic mapping.
                      if(norm16_2&gt;=minNoNo) {
                          while(i&lt;length) {
                              U16_NEXT_UNSAFE(mapping, i, c2);
<span class="line-modified">!                             uint32_t c2Value = umutablecptrie_get(newData.mutableTrie, c2);</span>
                              if((c2Value&amp;CANON_NOT_SEGMENT_STARTER)==0) {
<span class="line-modified">!                                 umutablecptrie_set(newData.mutableTrie, c2,</span>
<span class="line-modified">!                                                    c2Value|CANON_NOT_SEGMENT_STARTER, &amp;errorCode);</span>
                              }
                          }
                      }
                  }
              } else {
                  // c decomposed to c2 algorithmically; c has cc==0
                  newData.addToStartSet(c, c2, errorCode);
              }
          }
          if(newValue!=oldValue) {
<span class="line-modified">!             umutablecptrie_set(newData.mutableTrie, c, newValue, &amp;errorCode);</span>
          }
      }
  }
  
  UBool Normalizer2Impl::ensureCanonIterData(UErrorCode &amp;errorCode) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2535,11 ***</span>
      umtx_initOnce(me-&gt;fCanonIterDataInitOnce, &amp;initCanonIterData, me, errorCode);
      return U_SUCCESS(errorCode);
  }
  
  int32_t Normalizer2Impl::getCanonValue(UChar32 c) const {
<span class="line-modified">!     return (int32_t)utrie2_get32(fCanonIterData-&gt;trie, c);</span>
  }
  
  const UnicodeSet &amp;Normalizer2Impl::getCanonStartSet(int32_t n) const {
      return *(const UnicodeSet *)fCanonIterData-&gt;canonStartSets[n];
  }
<span class="line-new-header">--- 2502,11 ---</span>
      umtx_initOnce(me-&gt;fCanonIterDataInitOnce, &amp;initCanonIterData, me, errorCode);
      return U_SUCCESS(errorCode);
  }
  
  int32_t Normalizer2Impl::getCanonValue(UChar32 c) const {
<span class="line-modified">!     return (int32_t)ucptrie_get(fCanonIterData-&gt;trie, c);</span>
  }
  
  const UnicodeSet &amp;Normalizer2Impl::getCanonStartSet(int32_t n) const {
      return *(const UnicodeSet *)fCanonIterData-&gt;canonStartSets[n];
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2559,11 ***</span>
          set.addAll(getCanonStartSet(value));
      } else if(value!=0) {
          set.add(value);
      }
      if((canonValue&amp;CANON_HAS_COMPOSITIONS)!=0) {
<span class="line-modified">!         uint16_t norm16=getNorm16(c);</span>
          if(norm16==JAMO_L) {
              UChar32 syllable=
                  (UChar32)(Hangul::HANGUL_BASE+(c-Hangul::JAMO_L_BASE)*Hangul::JAMO_VT_COUNT);
              set.add(syllable, syllable+Hangul::JAMO_VT_COUNT-1);
          } else {
<span class="line-new-header">--- 2526,11 ---</span>
          set.addAll(getCanonStartSet(value));
      } else if(value!=0) {
          set.add(value);
      }
      if((canonValue&amp;CANON_HAS_COMPOSITIONS)!=0) {
<span class="line-modified">!         uint16_t norm16=getRawNorm16(c);</span>
          if(norm16==JAMO_L) {
              UChar32 syllable=
                  (UChar32)(Hangul::HANGUL_BASE+(c-Hangul::JAMO_L_BASE)*Hangul::JAMO_VT_COUNT);
              set.add(syllable, syllable+Hangul::JAMO_VT_COUNT-1);
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2606,11 ***</span>
      if(!(
          pInfo-&gt;dataFormat[0]==0x4e &amp;&amp;   /* dataFormat=&quot;Nrm2&quot; */
          pInfo-&gt;dataFormat[1]==0x72 &amp;&amp;
          pInfo-&gt;dataFormat[2]==0x6d &amp;&amp;
          pInfo-&gt;dataFormat[3]==0x32 &amp;&amp;
<span class="line-modified">!         (1&lt;=formatVersion0 &amp;&amp; formatVersion0&lt;=3)</span>
      )) {
          udata_printError(ds, &quot;unorm2_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as Normalizer2 data\n&quot;,
                           pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
                           pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
                           pInfo-&gt;formatVersion[0]);
<span class="line-new-header">--- 2573,11 ---</span>
      if(!(
          pInfo-&gt;dataFormat[0]==0x4e &amp;&amp;   /* dataFormat=&quot;Nrm2&quot; */
          pInfo-&gt;dataFormat[1]==0x72 &amp;&amp;
          pInfo-&gt;dataFormat[2]==0x6d &amp;&amp;
          pInfo-&gt;dataFormat[3]==0x32 &amp;&amp;
<span class="line-modified">!         (1&lt;=formatVersion0 &amp;&amp; formatVersion0&lt;=4)</span>
      )) {
          udata_printError(ds, &quot;unorm2_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as Normalizer2 data\n&quot;,
                           pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
                           pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
                           pInfo-&gt;formatVersion[0]);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2667,13 ***</span>
          /* swap the int32_t indexes[] */
          nextOffset=indexes[Normalizer2Impl::IX_NORM_TRIE_OFFSET];
          ds-&gt;swapArray32(ds, inBytes, nextOffset-offset, outBytes, pErrorCode);
          offset=nextOffset;
  
<span class="line-modified">!         /* swap the UTrie2 */</span>
          nextOffset=indexes[Normalizer2Impl::IX_EXTRA_DATA_OFFSET];
<span class="line-modified">!         utrie2_swap(ds, inBytes+offset, nextOffset-offset, outBytes+offset, pErrorCode);</span>
          offset=nextOffset;
  
          /* swap the uint16_t extraData[] */
          nextOffset=indexes[Normalizer2Impl::IX_SMALL_FCD_OFFSET];
          ds-&gt;swapArray16(ds, inBytes+offset, nextOffset-offset, outBytes+offset, pErrorCode);
<span class="line-new-header">--- 2634,13 ---</span>
          /* swap the int32_t indexes[] */
          nextOffset=indexes[Normalizer2Impl::IX_NORM_TRIE_OFFSET];
          ds-&gt;swapArray32(ds, inBytes, nextOffset-offset, outBytes, pErrorCode);
          offset=nextOffset;
  
<span class="line-modified">!         /* swap the trie */</span>
          nextOffset=indexes[Normalizer2Impl::IX_EXTRA_DATA_OFFSET];
<span class="line-modified">!         utrie_swapAnyVersion(ds, inBytes+offset, nextOffset-offset, outBytes+offset, pErrorCode);</span>
          offset=nextOffset;
  
          /* swap the uint16_t extraData[] */
          nextOffset=indexes[Normalizer2Impl::IX_SMALL_FCD_OFFSET];
          ds-&gt;swapArray16(ds, inBytes+offset, nextOffset-offset, outBytes+offset, pErrorCode);
</pre>
<center><a href="normalizer2.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="normalizer2impl.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>