<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ucnv_u32.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ucnv_u16.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ucnv_u8.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ucnv_u32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 211 
 212 static void U_CALLCONV
 213 T_UConverter_fromUnicode_UTF32_BE(UConverterFromUnicodeArgs * args,
 214                                   UErrorCode * err)
 215 {
 216     const UChar *mySource = args-&gt;source;
 217     unsigned char *myTarget;
 218     const UChar *sourceLimit = args-&gt;sourceLimit;
 219     const unsigned char *targetLimit = (unsigned char *) args-&gt;targetLimit;
 220     UChar32 ch, ch2;
 221     unsigned int indexToWrite;
 222     unsigned char temp[sizeof(uint32_t)];
 223 
 224     if(mySource &gt;= sourceLimit) {
 225         /* no input, nothing to do */
 226         return;
 227     }
 228 
 229     /* write the BOM if necessary */
 230     if(args-&gt;converter-&gt;fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {
<span class="line-modified"> 231         static const char bom[]={ 0, 0, (char)0xfe, (char)0xff };</span>
 232         ucnv_fromUWriteBytes(args-&gt;converter,
 233                              bom, 4,
 234                              &amp;args-&gt;target, args-&gt;targetLimit,
 235                              &amp;args-&gt;offsets, -1,
 236                              err);
 237         args-&gt;converter-&gt;fromUnicodeStatus=0;
 238     }
 239 
 240     myTarget = (unsigned char *) args-&gt;target;
 241     temp[0] = 0;
 242 
 243     if (args-&gt;converter-&gt;fromUChar32) {
 244         ch = args-&gt;converter-&gt;fromUChar32;
 245         args-&gt;converter-&gt;fromUChar32 = 0;
 246         goto lowsurogate;
 247     }
 248 
 249     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit) {
 250         ch = *(mySource++);
 251 
</pre>
<hr />
<pre>
 314 T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC(UConverterFromUnicodeArgs * args,
 315                                                UErrorCode * err)
 316 {
 317     const UChar *mySource = args-&gt;source;
 318     unsigned char *myTarget;
 319     int32_t *myOffsets;
 320     const UChar *sourceLimit = args-&gt;sourceLimit;
 321     const unsigned char *targetLimit = (unsigned char *) args-&gt;targetLimit;
 322     UChar32 ch, ch2;
 323     int32_t offsetNum = 0;
 324     unsigned int indexToWrite;
 325     unsigned char temp[sizeof(uint32_t)];
 326 
 327     if(mySource &gt;= sourceLimit) {
 328         /* no input, nothing to do */
 329         return;
 330     }
 331 
 332     /* write the BOM if necessary */
 333     if(args-&gt;converter-&gt;fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {
<span class="line-modified"> 334         static const char bom[]={ 0, 0, (char)0xfe, (char)0xff };</span>
 335         ucnv_fromUWriteBytes(args-&gt;converter,
 336                              bom, 4,
 337                              &amp;args-&gt;target, args-&gt;targetLimit,
 338                              &amp;args-&gt;offsets, -1,
 339                              err);
 340         args-&gt;converter-&gt;fromUnicodeStatus=0;
 341     }
 342 
 343     myTarget = (unsigned char *) args-&gt;target;
 344     myOffsets = args-&gt;offsets;
 345     temp[0] = 0;
 346 
 347     if (args-&gt;converter-&gt;fromUChar32) {
 348         ch = args-&gt;converter-&gt;fromUChar32;
 349         args-&gt;converter-&gt;fromUChar32 = 0;
 350         goto lowsurogate;
 351     }
 352 
 353     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit) {
 354         ch = *(mySource++);
</pre>
<hr />
<pre>
 689 
 690 static void U_CALLCONV
 691 T_UConverter_fromUnicode_UTF32_LE(UConverterFromUnicodeArgs * args,
 692                                   UErrorCode * err)
 693 {
 694     const UChar *mySource = args-&gt;source;
 695     unsigned char *myTarget;
 696     const UChar *sourceLimit = args-&gt;sourceLimit;
 697     const unsigned char *targetLimit = (unsigned char *) args-&gt;targetLimit;
 698     UChar32 ch, ch2;
 699     unsigned int indexToWrite;
 700     unsigned char temp[sizeof(uint32_t)];
 701 
 702     if(mySource &gt;= sourceLimit) {
 703         /* no input, nothing to do */
 704         return;
 705     }
 706 
 707     /* write the BOM if necessary */
 708     if(args-&gt;converter-&gt;fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {
<span class="line-modified"> 709         static const char bom[]={ (char)0xff, (char)0xfe, 0, 0 };</span>
 710         ucnv_fromUWriteBytes(args-&gt;converter,
 711                              bom, 4,
 712                              &amp;args-&gt;target, args-&gt;targetLimit,
 713                              &amp;args-&gt;offsets, -1,
 714                              err);
 715         args-&gt;converter-&gt;fromUnicodeStatus=0;
 716     }
 717 
 718     myTarget = (unsigned char *) args-&gt;target;
 719     temp[3] = 0;
 720 
 721     if (args-&gt;converter-&gt;fromUChar32)
 722     {
 723         ch = args-&gt;converter-&gt;fromUChar32;
 724         args-&gt;converter-&gt;fromUChar32 = 0;
 725         goto lowsurogate;
 726     }
 727 
 728     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
 729     {
</pre>
<hr />
<pre>
 800 T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC(UConverterFromUnicodeArgs * args,
 801                                                UErrorCode * err)
 802 {
 803     const UChar *mySource = args-&gt;source;
 804     unsigned char *myTarget;
 805     int32_t *myOffsets;
 806     const UChar *sourceLimit = args-&gt;sourceLimit;
 807     const unsigned char *targetLimit = (unsigned char *) args-&gt;targetLimit;
 808     UChar32 ch, ch2;
 809     unsigned int indexToWrite;
 810     unsigned char temp[sizeof(uint32_t)];
 811     int32_t offsetNum = 0;
 812 
 813     if(mySource &gt;= sourceLimit) {
 814         /* no input, nothing to do */
 815         return;
 816     }
 817 
 818     /* write the BOM if necessary */
 819     if(args-&gt;converter-&gt;fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {
<span class="line-modified"> 820         static const char bom[]={ (char)0xff, (char)0xfe, 0, 0 };</span>
 821         ucnv_fromUWriteBytes(args-&gt;converter,
 822                              bom, 4,
 823                              &amp;args-&gt;target, args-&gt;targetLimit,
 824                              &amp;args-&gt;offsets, -1,
 825                              err);
 826         args-&gt;converter-&gt;fromUnicodeStatus=0;
 827     }
 828 
 829     myTarget = (unsigned char *) args-&gt;target;
 830     myOffsets = args-&gt;offsets;
 831     temp[3] = 0;
 832 
 833     if (args-&gt;converter-&gt;fromUChar32)
 834     {
 835         ch = args-&gt;converter-&gt;fromUChar32;
 836         args-&gt;converter-&gt;fromUChar32 = 0;
 837         goto lowsurogate;
 838     }
 839 
 840     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
</pre>
<hr />
<pre>
1026 _UTF32Reset(UConverter *cnv, UConverterResetChoice choice) {
1027     if(choice&lt;=UCNV_RESET_TO_UNICODE) {
1028         /* reset toUnicode: state=0 */
1029         cnv-&gt;mode=0;
1030     }
1031     if(choice!=UCNV_RESET_TO_UNICODE) {
1032         /* reset fromUnicode: prepare to output the UTF-32PE BOM */
1033         cnv-&gt;fromUnicodeStatus=UCNV_NEED_TO_WRITE_BOM;
1034     }
1035 }
1036 
1037 static void U_CALLCONV
1038 _UTF32Open(UConverter *cnv,
1039            UConverterLoadArgs *pArgs,
1040            UErrorCode *pErrorCode) {
1041     (void)pArgs;
1042     (void)pErrorCode;
1043     _UTF32Reset(cnv, UCNV_RESET_BOTH);
1044 }
1045 
<span class="line-modified">1046 static const char utf32BOM[8]={ 0, 0, (char)0xfe, (char)0xff,    (char)0xff, (char)0xfe, 0, 0 };</span>
1047 
1048 static void U_CALLCONV
1049 _UTF32ToUnicodeWithOffsets(UConverterToUnicodeArgs *pArgs,
1050                            UErrorCode *pErrorCode) {
1051     UConverter *cnv=pArgs-&gt;converter;
1052     const char *source=pArgs-&gt;source;
1053     const char *sourceLimit=pArgs-&gt;sourceLimit;
1054     int32_t *offsets=pArgs-&gt;offsets;
1055 
1056     int32_t state, offsetDelta;
1057     char b;
1058 
1059     state=cnv-&gt;mode;
1060 
1061     /*
1062      * If we detect a BOM in this buffer, then we must add the BOM size to the
1063      * offsets because the actual converter function will not see and count the BOM.
1064      * offsetDelta will have the number of the BOM bytes that are in the current buffer.
1065      */
1066     offsetDelta=0;
1067 
1068     while(source&lt;sourceLimit &amp;&amp; U_SUCCESS(*pErrorCode)) {
1069         switch(state) {
1070         case 0:
1071             b=*source;
1072             if(b==0) {
1073                 state=1; /* could be 00 00 FE FF */
<span class="line-modified">1074             } else if(b==(char)0xff) {</span>
1075                 state=5; /* could be FF FE 00 00 */
1076             } else {
1077                 state=8; /* default to UTF-32BE */
1078                 continue;
1079             }
1080             ++source;
1081             break;
1082         case 1:
1083         case 2:
1084         case 3:
1085         case 5:
1086         case 6:
1087         case 7:
1088             if(*source==utf32BOM[state]) {
1089                 ++state;
1090                 ++source;
1091                 if(state==4) {
1092                     state=8; /* detect UTF-32BE */
1093                     offsetDelta=(int32_t)(source-pArgs-&gt;source);
1094                 } else if(state==8) {
</pre>
</td>
<td>
<hr />
<pre>
 211 
 212 static void U_CALLCONV
 213 T_UConverter_fromUnicode_UTF32_BE(UConverterFromUnicodeArgs * args,
 214                                   UErrorCode * err)
 215 {
 216     const UChar *mySource = args-&gt;source;
 217     unsigned char *myTarget;
 218     const UChar *sourceLimit = args-&gt;sourceLimit;
 219     const unsigned char *targetLimit = (unsigned char *) args-&gt;targetLimit;
 220     UChar32 ch, ch2;
 221     unsigned int indexToWrite;
 222     unsigned char temp[sizeof(uint32_t)];
 223 
 224     if(mySource &gt;= sourceLimit) {
 225         /* no input, nothing to do */
 226         return;
 227     }
 228 
 229     /* write the BOM if necessary */
 230     if(args-&gt;converter-&gt;fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {
<span class="line-modified"> 231         static const char bom[]={ 0, 0, (char)0xfeu, (char)0xffu };</span>
 232         ucnv_fromUWriteBytes(args-&gt;converter,
 233                              bom, 4,
 234                              &amp;args-&gt;target, args-&gt;targetLimit,
 235                              &amp;args-&gt;offsets, -1,
 236                              err);
 237         args-&gt;converter-&gt;fromUnicodeStatus=0;
 238     }
 239 
 240     myTarget = (unsigned char *) args-&gt;target;
 241     temp[0] = 0;
 242 
 243     if (args-&gt;converter-&gt;fromUChar32) {
 244         ch = args-&gt;converter-&gt;fromUChar32;
 245         args-&gt;converter-&gt;fromUChar32 = 0;
 246         goto lowsurogate;
 247     }
 248 
 249     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit) {
 250         ch = *(mySource++);
 251 
</pre>
<hr />
<pre>
 314 T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC(UConverterFromUnicodeArgs * args,
 315                                                UErrorCode * err)
 316 {
 317     const UChar *mySource = args-&gt;source;
 318     unsigned char *myTarget;
 319     int32_t *myOffsets;
 320     const UChar *sourceLimit = args-&gt;sourceLimit;
 321     const unsigned char *targetLimit = (unsigned char *) args-&gt;targetLimit;
 322     UChar32 ch, ch2;
 323     int32_t offsetNum = 0;
 324     unsigned int indexToWrite;
 325     unsigned char temp[sizeof(uint32_t)];
 326 
 327     if(mySource &gt;= sourceLimit) {
 328         /* no input, nothing to do */
 329         return;
 330     }
 331 
 332     /* write the BOM if necessary */
 333     if(args-&gt;converter-&gt;fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {
<span class="line-modified"> 334         static const char bom[]={ 0, 0, (char)0xfeu, (char)0xffu };</span>
 335         ucnv_fromUWriteBytes(args-&gt;converter,
 336                              bom, 4,
 337                              &amp;args-&gt;target, args-&gt;targetLimit,
 338                              &amp;args-&gt;offsets, -1,
 339                              err);
 340         args-&gt;converter-&gt;fromUnicodeStatus=0;
 341     }
 342 
 343     myTarget = (unsigned char *) args-&gt;target;
 344     myOffsets = args-&gt;offsets;
 345     temp[0] = 0;
 346 
 347     if (args-&gt;converter-&gt;fromUChar32) {
 348         ch = args-&gt;converter-&gt;fromUChar32;
 349         args-&gt;converter-&gt;fromUChar32 = 0;
 350         goto lowsurogate;
 351     }
 352 
 353     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit) {
 354         ch = *(mySource++);
</pre>
<hr />
<pre>
 689 
 690 static void U_CALLCONV
 691 T_UConverter_fromUnicode_UTF32_LE(UConverterFromUnicodeArgs * args,
 692                                   UErrorCode * err)
 693 {
 694     const UChar *mySource = args-&gt;source;
 695     unsigned char *myTarget;
 696     const UChar *sourceLimit = args-&gt;sourceLimit;
 697     const unsigned char *targetLimit = (unsigned char *) args-&gt;targetLimit;
 698     UChar32 ch, ch2;
 699     unsigned int indexToWrite;
 700     unsigned char temp[sizeof(uint32_t)];
 701 
 702     if(mySource &gt;= sourceLimit) {
 703         /* no input, nothing to do */
 704         return;
 705     }
 706 
 707     /* write the BOM if necessary */
 708     if(args-&gt;converter-&gt;fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {
<span class="line-modified"> 709         static const char bom[]={ (char)0xffu, (char)0xfeu, 0, 0 };</span>
 710         ucnv_fromUWriteBytes(args-&gt;converter,
 711                              bom, 4,
 712                              &amp;args-&gt;target, args-&gt;targetLimit,
 713                              &amp;args-&gt;offsets, -1,
 714                              err);
 715         args-&gt;converter-&gt;fromUnicodeStatus=0;
 716     }
 717 
 718     myTarget = (unsigned char *) args-&gt;target;
 719     temp[3] = 0;
 720 
 721     if (args-&gt;converter-&gt;fromUChar32)
 722     {
 723         ch = args-&gt;converter-&gt;fromUChar32;
 724         args-&gt;converter-&gt;fromUChar32 = 0;
 725         goto lowsurogate;
 726     }
 727 
 728     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
 729     {
</pre>
<hr />
<pre>
 800 T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC(UConverterFromUnicodeArgs * args,
 801                                                UErrorCode * err)
 802 {
 803     const UChar *mySource = args-&gt;source;
 804     unsigned char *myTarget;
 805     int32_t *myOffsets;
 806     const UChar *sourceLimit = args-&gt;sourceLimit;
 807     const unsigned char *targetLimit = (unsigned char *) args-&gt;targetLimit;
 808     UChar32 ch, ch2;
 809     unsigned int indexToWrite;
 810     unsigned char temp[sizeof(uint32_t)];
 811     int32_t offsetNum = 0;
 812 
 813     if(mySource &gt;= sourceLimit) {
 814         /* no input, nothing to do */
 815         return;
 816     }
 817 
 818     /* write the BOM if necessary */
 819     if(args-&gt;converter-&gt;fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {
<span class="line-modified"> 820         static const char bom[]={ (char)0xffu, (char)0xfeu, 0, 0 };</span>
 821         ucnv_fromUWriteBytes(args-&gt;converter,
 822                              bom, 4,
 823                              &amp;args-&gt;target, args-&gt;targetLimit,
 824                              &amp;args-&gt;offsets, -1,
 825                              err);
 826         args-&gt;converter-&gt;fromUnicodeStatus=0;
 827     }
 828 
 829     myTarget = (unsigned char *) args-&gt;target;
 830     myOffsets = args-&gt;offsets;
 831     temp[3] = 0;
 832 
 833     if (args-&gt;converter-&gt;fromUChar32)
 834     {
 835         ch = args-&gt;converter-&gt;fromUChar32;
 836         args-&gt;converter-&gt;fromUChar32 = 0;
 837         goto lowsurogate;
 838     }
 839 
 840     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
</pre>
<hr />
<pre>
1026 _UTF32Reset(UConverter *cnv, UConverterResetChoice choice) {
1027     if(choice&lt;=UCNV_RESET_TO_UNICODE) {
1028         /* reset toUnicode: state=0 */
1029         cnv-&gt;mode=0;
1030     }
1031     if(choice!=UCNV_RESET_TO_UNICODE) {
1032         /* reset fromUnicode: prepare to output the UTF-32PE BOM */
1033         cnv-&gt;fromUnicodeStatus=UCNV_NEED_TO_WRITE_BOM;
1034     }
1035 }
1036 
1037 static void U_CALLCONV
1038 _UTF32Open(UConverter *cnv,
1039            UConverterLoadArgs *pArgs,
1040            UErrorCode *pErrorCode) {
1041     (void)pArgs;
1042     (void)pErrorCode;
1043     _UTF32Reset(cnv, UCNV_RESET_BOTH);
1044 }
1045 
<span class="line-modified">1046 static const char utf32BOM[8]={ 0, 0, (char)0xfeu, (char)0xffu, (char)0xffu, (char)0xfeu, 0, 0 };</span>
1047 
1048 static void U_CALLCONV
1049 _UTF32ToUnicodeWithOffsets(UConverterToUnicodeArgs *pArgs,
1050                            UErrorCode *pErrorCode) {
1051     UConverter *cnv=pArgs-&gt;converter;
1052     const char *source=pArgs-&gt;source;
1053     const char *sourceLimit=pArgs-&gt;sourceLimit;
1054     int32_t *offsets=pArgs-&gt;offsets;
1055 
1056     int32_t state, offsetDelta;
1057     char b;
1058 
1059     state=cnv-&gt;mode;
1060 
1061     /*
1062      * If we detect a BOM in this buffer, then we must add the BOM size to the
1063      * offsets because the actual converter function will not see and count the BOM.
1064      * offsetDelta will have the number of the BOM bytes that are in the current buffer.
1065      */
1066     offsetDelta=0;
1067 
1068     while(source&lt;sourceLimit &amp;&amp; U_SUCCESS(*pErrorCode)) {
1069         switch(state) {
1070         case 0:
1071             b=*source;
1072             if(b==0) {
1073                 state=1; /* could be 00 00 FE FF */
<span class="line-modified">1074             } else if(b==(char)0xffu) {</span>
1075                 state=5; /* could be FF FE 00 00 */
1076             } else {
1077                 state=8; /* default to UTF-32BE */
1078                 continue;
1079             }
1080             ++source;
1081             break;
1082         case 1:
1083         case 2:
1084         case 3:
1085         case 5:
1086         case 6:
1087         case 7:
1088             if(*source==utf32BOM[state]) {
1089                 ++state;
1090                 ++source;
1091                 if(state==4) {
1092                     state=8; /* detect UTF-32BE */
1093                     offsetDelta=(int32_t)(source-pArgs-&gt;source);
1094                 } else if(state==8) {
</pre>
</td>
</tr>
</table>
<center><a href="ucnv_u16.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ucnv_u8.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>