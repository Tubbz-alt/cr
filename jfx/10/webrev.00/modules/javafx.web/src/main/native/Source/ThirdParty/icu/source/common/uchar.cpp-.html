<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uchar.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 ********************************************************************************
  5 *   Copyright (C) 1996-2016, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 ********************************************************************************
  8 *
  9 * File UCHAR.C
 10 *
 11 * Modification History:
 12 *
 13 *   Date        Name        Description
 14 *   04/02/97    aliu        Creation.
 15 *   4/15/99     Madhu       Updated all the function definitions for C Implementation
 16 *   5/20/99     Madhu       Added the function u_getVersion()
 17 *   8/19/1999   srl         Upgraded scripts to Unicode3.0
 18 *   11/11/1999  weiv        added u_isalnum(), cleaned comments
 19 *   01/11/2000  helena      Renamed u_getVersion to u_getUnicodeVersion.
 20 *   06/20/2000  helena      OS/400 port changes; mostly typecast.
 21 ******************************************************************************
 22 */
 23 
 24 #include &quot;unicode/utypes.h&quot;
 25 #include &quot;unicode/uchar.h&quot;
 26 #include &quot;unicode/uscript.h&quot;
 27 #include &quot;unicode/udata.h&quot;
 28 #include &quot;uassert.h&quot;
 29 #include &quot;cmemory.h&quot;
 30 #include &quot;ucln_cmn.h&quot;
 31 #include &quot;utrie2.h&quot;
 32 #include &quot;udataswp.h&quot;
 33 #include &quot;uprops.h&quot;
 34 #include &quot;ustr_imp.h&quot;
 35 
 36 /* uchar_props_data.h is machine-generated by genprops --csource */
 37 #define INCLUDED_FROM_UCHAR_C
 38 #include &quot;uchar_props_data.h&quot;
 39 
 40 /* constants and macros for access to the data ------------------------------ */
 41 
 42 /* getting a uint32_t properties word from the data */
 43 #define GET_PROPS(c, result) ((result)=UTRIE2_GET16(&amp;propsTrie, c));
 44 
 45 /* API functions ------------------------------------------------------------ */
 46 
 47 /* Gets the Unicode character&#39;s general category.*/
 48 U_CAPI int8_t U_EXPORT2
 49 u_charType(UChar32 c) {
 50     uint32_t props;
 51     GET_PROPS(c, props);
 52     return (int8_t)GET_CATEGORY(props);
 53 }
 54 
 55 /* Enumerate all code points with their general categories. */
 56 struct _EnumTypeCallback {
 57     UCharEnumTypeRange *enumRange;
 58     const void *context;
 59 };
 60 
 61 static uint32_t U_CALLCONV
 62 _enumTypeValue(const void *context, uint32_t value) {
 63     (void)context;
 64     return GET_CATEGORY(value);
 65 }
 66 
 67 static UBool U_CALLCONV
 68 _enumTypeRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {
 69     /* just cast the value to UCharCategory */
 70     return ((struct _EnumTypeCallback *)context)-&gt;
 71         enumRange(((struct _EnumTypeCallback *)context)-&gt;context,
 72                   start, end+1, (UCharCategory)value);
 73 }
 74 
 75 U_CAPI void U_EXPORT2
 76 u_enumCharTypes(UCharEnumTypeRange *enumRange, const void *context) {
 77     struct _EnumTypeCallback callback;
 78 
 79     if(enumRange==NULL) {
 80         return;
 81     }
 82 
 83     callback.enumRange=enumRange;
 84     callback.context=context;
 85     utrie2_enum(&amp;propsTrie, _enumTypeValue, _enumTypeRange, &amp;callback);
 86 }
 87 
 88 /* Checks if ch is a lower case letter.*/
 89 U_CAPI UBool U_EXPORT2
 90 u_islower(UChar32 c) {
 91     uint32_t props;
 92     GET_PROPS(c, props);
 93     return (UBool)(GET_CATEGORY(props)==U_LOWERCASE_LETTER);
 94 }
 95 
 96 /* Checks if ch is an upper case letter.*/
 97 U_CAPI UBool U_EXPORT2
 98 u_isupper(UChar32 c) {
 99     uint32_t props;
100     GET_PROPS(c, props);
101     return (UBool)(GET_CATEGORY(props)==U_UPPERCASE_LETTER);
102 }
103 
104 /* Checks if ch is a title case letter; usually upper case letters.*/
105 U_CAPI UBool U_EXPORT2
106 u_istitle(UChar32 c) {
107     uint32_t props;
108     GET_PROPS(c, props);
109     return (UBool)(GET_CATEGORY(props)==U_TITLECASE_LETTER);
110 }
111 
112 /* Checks if ch is a decimal digit. */
113 U_CAPI UBool U_EXPORT2
114 u_isdigit(UChar32 c) {
115     uint32_t props;
116     GET_PROPS(c, props);
117     return (UBool)(GET_CATEGORY(props)==U_DECIMAL_DIGIT_NUMBER);
118 }
119 
120 U_CAPI UBool U_EXPORT2
121 u_isxdigit(UChar32 c) {
122     uint32_t props;
123 
124     /* check ASCII and Fullwidth ASCII a-fA-F */
125     if(
126         (c&lt;=0x66 &amp;&amp; c&gt;=0x41 &amp;&amp; (c&lt;=0x46 || c&gt;=0x61)) ||
127         (c&gt;=0xff21 &amp;&amp; c&lt;=0xff46 &amp;&amp; (c&lt;=0xff26 || c&gt;=0xff41))
128     ) {
129         return TRUE;
130     }
131 
132     GET_PROPS(c, props);
133     return (UBool)(GET_CATEGORY(props)==U_DECIMAL_DIGIT_NUMBER);
134 }
135 
136 /* Checks if the Unicode character is a letter.*/
137 U_CAPI UBool U_EXPORT2
138 u_isalpha(UChar32 c) {
139     uint32_t props;
140     GET_PROPS(c, props);
141     return (UBool)((CAT_MASK(props)&amp;U_GC_L_MASK)!=0);
142 }
143 
144 U_CAPI UBool U_EXPORT2
145 u_isUAlphabetic(UChar32 c) {
146     return (u_getUnicodeProperties(c, 1)&amp;U_MASK(UPROPS_ALPHABETIC))!=0;
147 }
148 
149 /* Checks if c is a letter or a decimal digit */
150 U_CAPI UBool U_EXPORT2
151 u_isalnum(UChar32 c) {
152     uint32_t props;
153     GET_PROPS(c, props);
154     return (UBool)((CAT_MASK(props)&amp;(U_GC_L_MASK|U_GC_ND_MASK))!=0);
155 }
156 
157 /**
158  * Checks if c is alphabetic, or a decimal digit; implements UCHAR_POSIX_ALNUM.
159  * @internal
160  */
161 U_CFUNC UBool
162 u_isalnumPOSIX(UChar32 c) {
163     return (UBool)(u_isUAlphabetic(c) || u_isdigit(c));
164 }
165 
166 /* Checks if ch is a unicode character with assigned character type.*/
167 U_CAPI UBool U_EXPORT2
168 u_isdefined(UChar32 c) {
169     uint32_t props;
170     GET_PROPS(c, props);
171     return (UBool)(GET_CATEGORY(props)!=0);
172 }
173 
174 /* Checks if the Unicode character is a base form character that can take a diacritic.*/
175 U_CAPI UBool U_EXPORT2
176 u_isbase(UChar32 c) {
177     uint32_t props;
178     GET_PROPS(c, props);
179     return (UBool)((CAT_MASK(props)&amp;(U_GC_L_MASK|U_GC_N_MASK|U_GC_MC_MASK|U_GC_ME_MASK))!=0);
180 }
181 
182 /* Checks if the Unicode character is a control character.*/
183 U_CAPI UBool U_EXPORT2
184 u_iscntrl(UChar32 c) {
185     uint32_t props;
186     GET_PROPS(c, props);
187     return (UBool)((CAT_MASK(props)&amp;(U_GC_CC_MASK|U_GC_CF_MASK|U_GC_ZL_MASK|U_GC_ZP_MASK))!=0);
188 }
189 
190 U_CAPI UBool U_EXPORT2
191 u_isISOControl(UChar32 c) {
192     return (uint32_t)c&lt;=0x9f &amp;&amp; (c&lt;=0x1f || c&gt;=0x7f);
193 }
194 
195 /* Some control characters that are used as space. */
196 #define IS_THAT_CONTROL_SPACE(c) \
197     (c&lt;=0x9f &amp;&amp; ((c&gt;=TAB &amp;&amp; c&lt;=CR) || (c&gt;=0x1c &amp;&amp; c &lt;=0x1f) || c==NL))
198 
199 /* Java has decided that U+0085 New Line is not whitespace any more. */
200 #define IS_THAT_ASCII_CONTROL_SPACE(c) \
201     (c&lt;=0x1f &amp;&amp; c&gt;=TAB &amp;&amp; (c&lt;=CR || c&gt;=0x1c))
202 
203 /* Checks if the Unicode character is a space character.*/
204 U_CAPI UBool U_EXPORT2
205 u_isspace(UChar32 c) {
206     uint32_t props;
207     GET_PROPS(c, props);
208     return (UBool)((CAT_MASK(props)&amp;U_GC_Z_MASK)!=0 || IS_THAT_CONTROL_SPACE(c));
209 }
210 
211 U_CAPI UBool U_EXPORT2
212 u_isJavaSpaceChar(UChar32 c) {
213     uint32_t props;
214     GET_PROPS(c, props);
215     return (UBool)((CAT_MASK(props)&amp;U_GC_Z_MASK)!=0);
216 }
217 
218 /* Checks if the Unicode character is a whitespace character.*/
219 U_CAPI UBool U_EXPORT2
220 u_isWhitespace(UChar32 c) {
221     uint32_t props;
222     GET_PROPS(c, props);
223     return (UBool)(
224                 ((CAT_MASK(props)&amp;U_GC_Z_MASK)!=0 &amp;&amp;
225                     c!=NBSP &amp;&amp; c!=FIGURESP &amp;&amp; c!=NNBSP) || /* exclude no-break spaces */
226                 IS_THAT_ASCII_CONTROL_SPACE(c)
227            );
228 }
229 
230 U_CAPI UBool U_EXPORT2
231 u_isblank(UChar32 c) {
232     if((uint32_t)c&lt;=0x9f) {
233         return c==9 || c==0x20; /* TAB or SPACE */
234     } else {
235         /* Zs */
236         uint32_t props;
237         GET_PROPS(c, props);
238         return (UBool)(GET_CATEGORY(props)==U_SPACE_SEPARATOR);
239     }
240 }
241 
242 U_CAPI UBool U_EXPORT2
243 u_isUWhiteSpace(UChar32 c) {
244     return (u_getUnicodeProperties(c, 1)&amp;U_MASK(UPROPS_WHITE_SPACE))!=0;
245 }
246 
247 /* Checks if the Unicode character is printable.*/
248 U_CAPI UBool U_EXPORT2
249 u_isprint(UChar32 c) {
250     uint32_t props;
251     GET_PROPS(c, props);
252     /* comparing ==0 returns FALSE for the categories mentioned */
253     return (UBool)((CAT_MASK(props)&amp;U_GC_C_MASK)==0);
254 }
255 
256 /**
257  * Checks if c is in \p{graph}\p{blank} - \p{cntrl}.
258  * Implements UCHAR_POSIX_PRINT.
259  * @internal
260  */
261 U_CFUNC UBool
262 u_isprintPOSIX(UChar32 c) {
263     uint32_t props;
264     GET_PROPS(c, props);
265     /*
266      * The only cntrl character in graph+blank is TAB (in blank).
267      * Here we implement (blank-TAB)=Zs instead of calling u_isblank().
268      */
269     return (UBool)((GET_CATEGORY(props)==U_SPACE_SEPARATOR) || u_isgraphPOSIX(c));
270 }
271 
272 U_CAPI UBool U_EXPORT2
273 u_isgraph(UChar32 c) {
274     uint32_t props;
275     GET_PROPS(c, props);
276     /* comparing ==0 returns FALSE for the categories mentioned */
277     return (UBool)((CAT_MASK(props)&amp;
278                     (U_GC_CC_MASK|U_GC_CF_MASK|U_GC_CS_MASK|U_GC_CN_MASK|U_GC_Z_MASK))
279                    ==0);
280 }
281 
282 /**
283  * Checks if c is in
284  * [^\p{space}\p{gc=Control}\p{gc=Surrogate}\p{gc=Unassigned}]
285  * with space=\p{Whitespace} and Control=Cc.
286  * Implements UCHAR_POSIX_GRAPH.
287  * @internal
288  */
289 U_CFUNC UBool
290 u_isgraphPOSIX(UChar32 c) {
291     uint32_t props;
292     GET_PROPS(c, props);
293     /* \p{space}\p{gc=Control} == \p{gc=Z}\p{Control} */
294     /* comparing ==0 returns FALSE for the categories mentioned */
295     return (UBool)((CAT_MASK(props)&amp;
296                     (U_GC_CC_MASK|U_GC_CS_MASK|U_GC_CN_MASK|U_GC_Z_MASK))
297                    ==0);
298 }
299 
300 U_CAPI UBool U_EXPORT2
301 u_ispunct(UChar32 c) {
302     uint32_t props;
303     GET_PROPS(c, props);
304     return (UBool)((CAT_MASK(props)&amp;U_GC_P_MASK)!=0);
305 }
306 
307 /* Checks if the Unicode character can start a Unicode identifier.*/
308 U_CAPI UBool U_EXPORT2
309 u_isIDStart(UChar32 c) {
310     /* same as u_isalpha() */
311     uint32_t props;
312     GET_PROPS(c, props);
313     return (UBool)((CAT_MASK(props)&amp;(U_GC_L_MASK|U_GC_NL_MASK))!=0);
314 }
315 
316 /* Checks if the Unicode character can be a Unicode identifier part other than starting the
317  identifier.*/
318 U_CAPI UBool U_EXPORT2
319 u_isIDPart(UChar32 c) {
320     uint32_t props;
321     GET_PROPS(c, props);
322     return (UBool)(
323            (CAT_MASK(props)&amp;
324             (U_GC_ND_MASK|U_GC_NL_MASK|
325              U_GC_L_MASK|
326              U_GC_PC_MASK|U_GC_MC_MASK|U_GC_MN_MASK)
327            )!=0 ||
328            u_isIDIgnorable(c));
329 }
330 
331 /*Checks if the Unicode character can be ignorable in a Java or Unicode identifier.*/
332 U_CAPI UBool U_EXPORT2
333 u_isIDIgnorable(UChar32 c) {
334     if(c&lt;=0x9f) {
335         return u_isISOControl(c) &amp;&amp; !IS_THAT_ASCII_CONTROL_SPACE(c);
336     } else {
337         uint32_t props;
338         GET_PROPS(c, props);
339         return (UBool)(GET_CATEGORY(props)==U_FORMAT_CHAR);
340     }
341 }
342 
343 /*Checks if the Unicode character can start a Java identifier.*/
344 U_CAPI UBool U_EXPORT2
345 u_isJavaIDStart(UChar32 c) {
346     uint32_t props;
347     GET_PROPS(c, props);
348     return (UBool)((CAT_MASK(props)&amp;(U_GC_L_MASK|U_GC_SC_MASK|U_GC_PC_MASK))!=0);
349 }
350 
351 /*Checks if the Unicode character can be a Java identifier part other than starting the
352  * identifier.
353  */
354 U_CAPI UBool U_EXPORT2
355 u_isJavaIDPart(UChar32 c) {
356     uint32_t props;
357     GET_PROPS(c, props);
358     return (UBool)(
359            (CAT_MASK(props)&amp;
360             (U_GC_ND_MASK|U_GC_NL_MASK|
361              U_GC_L_MASK|
362              U_GC_SC_MASK|U_GC_PC_MASK|
363              U_GC_MC_MASK|U_GC_MN_MASK)
364            )!=0 ||
365            u_isIDIgnorable(c));
366 }
367 
368 U_CAPI int32_t U_EXPORT2
369 u_charDigitValue(UChar32 c) {
370     uint32_t props;
371     int32_t value;
372     GET_PROPS(c, props);
373     value=(int32_t)GET_NUMERIC_TYPE_VALUE(props)-UPROPS_NTV_DECIMAL_START;
374     if(value&lt;=9) {
375         return value;
376     } else {
377         return -1;
378     }
379 }
380 
381 U_CAPI double U_EXPORT2
382 u_getNumericValue(UChar32 c) {
383     uint32_t props;
384     int32_t ntv;
385     GET_PROPS(c, props);
386     ntv=(int32_t)GET_NUMERIC_TYPE_VALUE(props);
387 
388     if(ntv==UPROPS_NTV_NONE) {
389         return U_NO_NUMERIC_VALUE;
390     } else if(ntv&lt;UPROPS_NTV_DIGIT_START) {
391         /* decimal digit */
392         return ntv-UPROPS_NTV_DECIMAL_START;
393     } else if(ntv&lt;UPROPS_NTV_NUMERIC_START) {
394         /* other digit */
395         return ntv-UPROPS_NTV_DIGIT_START;
396     } else if(ntv&lt;UPROPS_NTV_FRACTION_START) {
397         /* small integer */
398         return ntv-UPROPS_NTV_NUMERIC_START;
399     } else if(ntv&lt;UPROPS_NTV_LARGE_START) {
400         /* fraction */
401         int32_t numerator=(ntv&gt;&gt;4)-12;
402         int32_t denominator=(ntv&amp;0xf)+1;
403         return (double)numerator/denominator;
404     } else if(ntv&lt;UPROPS_NTV_BASE60_START) {
405         /* large, single-significant-digit integer */
406         double numValue;
407         int32_t mant=(ntv&gt;&gt;5)-14;
408         int32_t exp=(ntv&amp;0x1f)+2;
409         numValue=mant;
410 
411         /* multiply by 10^exp without math.h */
412         while(exp&gt;=4) {
413             numValue*=10000.;
414             exp-=4;
415         }
416         switch(exp) {
417         case 3:
418             numValue*=1000.;
419             break;
420         case 2:
421             numValue*=100.;
422             break;
423         case 1:
424             numValue*=10.;
425             break;
426         case 0:
427         default:
428             break;
429         }
430 
431         return numValue;
432     } else if(ntv&lt;UPROPS_NTV_FRACTION20_START) {
433         /* sexagesimal (base 60) integer */
434         int32_t numValue=(ntv&gt;&gt;2)-0xbf;
435         int32_t exp=(ntv&amp;3)+1;
436 
437         switch(exp) {
438         case 4:
439             numValue*=60*60*60*60;
440             break;
441         case 3:
442             numValue*=60*60*60;
443             break;
444         case 2:
445             numValue*=60*60;
446             break;
447         case 1:
448             numValue*=60;
449             break;
450         case 0:
451         default:
452             break;
453         }
454 
455         return numValue;
456     } else if(ntv&lt;UPROPS_NTV_RESERVED_START) {
457         // fraction-20 e.g. 3/80
458         int32_t frac20=ntv-UPROPS_NTV_FRACTION20_START;  // 0..0x17
459         int32_t numerator=2*(frac20&amp;3)+1;
460         int32_t denominator=20&lt;&lt;(frac20&gt;&gt;2);
461         return (double)numerator/denominator;
462     } else {
463         /* reserved */
464         return U_NO_NUMERIC_VALUE;
465     }
466 }
467 
468 U_CAPI int32_t U_EXPORT2
469 u_digit(UChar32 ch, int8_t radix) {
470     int8_t value;
471     if((uint8_t)(radix-2)&lt;=(36-2)) {
472         value=(int8_t)u_charDigitValue(ch);
473         if(value&lt;0) {
474             /* ch is not a decimal digit, try latin letters */
475             if(ch&gt;=0x61 &amp;&amp; ch&lt;=0x7A) {
476                 value=(int8_t)(ch-0x57);  /* ch - &#39;a&#39; + 10 */
477             } else if(ch&gt;=0x41 &amp;&amp; ch&lt;=0x5A) {
478                 value=(int8_t)(ch-0x37);  /* ch - &#39;A&#39; + 10 */
479             } else if(ch&gt;=0xFF41 &amp;&amp; ch&lt;=0xFF5A) {
480                 value=(int8_t)(ch-0xFF37);  /* fullwidth ASCII a-z */
481             } else if(ch&gt;=0xFF21 &amp;&amp; ch&lt;=0xFF3A) {
482                 value=(int8_t)(ch-0xFF17);  /* fullwidth ASCII A-Z */
483             }
484         }
485     } else {
486         value=-1;   /* invalid radix */
487     }
488     return (int8_t)((value&lt;radix) ? value : -1);
489 }
490 
491 U_CAPI UChar32 U_EXPORT2
492 u_forDigit(int32_t digit, int8_t radix) {
493     if((uint8_t)(radix-2)&gt;(36-2) || (uint32_t)digit&gt;=(uint32_t)radix) {
494         return 0;
495     } else if(digit&lt;10) {
496         return (UChar32)(0x30+digit);
497     } else {
498         return (UChar32)((0x61-10)+digit);
499     }
500 }
501 
502 /* miscellaneous, and support for uprops.cpp -------------------------------- */
503 
504 U_CAPI void U_EXPORT2
505 u_getUnicodeVersion(UVersionInfo versionArray) {
506     if(versionArray!=NULL) {
507         uprv_memcpy(versionArray, dataVersion, U_MAX_VERSION_LENGTH);
508     }
509 }
510 
511 U_CFUNC uint32_t
512 u_getMainProperties(UChar32 c) {
513     uint32_t props;
514     GET_PROPS(c, props);
515     return props;
516 }
517 
518 U_CFUNC uint32_t
519 u_getUnicodeProperties(UChar32 c, int32_t column) {
520     U_ASSERT(column&gt;=0);
521     if(column&gt;=propsVectorsColumns) {
522         return 0;
523     } else {
524         uint16_t vecIndex=UTRIE2_GET16(&amp;propsVectorsTrie, c);
525         return propsVectors[vecIndex+column];
526     }
527 }
528 
529 U_CFUNC int32_t
530 uprv_getMaxValues(int32_t column) {
531     switch(column) {
532     case 0:
533         return indexes[UPROPS_MAX_VALUES_INDEX];
534     case 2:
535         return indexes[UPROPS_MAX_VALUES_2_INDEX];
536     default:
537         return 0;
538     }
539 }
540 
541 U_CAPI void U_EXPORT2
542 u_charAge(UChar32 c, UVersionInfo versionArray) {
543     if(versionArray!=NULL) {
544         uint32_t version=u_getUnicodeProperties(c, 0)&gt;&gt;UPROPS_AGE_SHIFT;
545         versionArray[0]=(uint8_t)(version&gt;&gt;4);
546         versionArray[1]=(uint8_t)(version&amp;0xf);
547         versionArray[2]=versionArray[3]=0;
548     }
549 }
550 
551 U_CAPI UScriptCode U_EXPORT2
552 uscript_getScript(UChar32 c, UErrorCode *pErrorCode) {
553     uint32_t scriptX;
554     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
555         return USCRIPT_INVALID_CODE;
556     }
557     if((uint32_t)c&gt;0x10ffff) {
558         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
559         return USCRIPT_INVALID_CODE;
560     }
561     scriptX=u_getUnicodeProperties(c, 0)&amp;UPROPS_SCRIPT_X_MASK;
562     if(scriptX&lt;UPROPS_SCRIPT_X_WITH_COMMON) {
563         return (UScriptCode)scriptX;
564     } else if(scriptX&lt;UPROPS_SCRIPT_X_WITH_INHERITED) {
565         return USCRIPT_COMMON;
566     } else if(scriptX&lt;UPROPS_SCRIPT_X_WITH_OTHER) {
567         return USCRIPT_INHERITED;
568     } else {
569         return (UScriptCode)scriptExtensions[scriptX&amp;UPROPS_SCRIPT_MASK];
570     }
571 }
572 
573 U_CAPI UBool U_EXPORT2
574 uscript_hasScript(UChar32 c, UScriptCode sc) {
575     const uint16_t *scx;
576     uint32_t scriptX=u_getUnicodeProperties(c, 0)&amp;UPROPS_SCRIPT_X_MASK;
577     if(scriptX&lt;UPROPS_SCRIPT_X_WITH_COMMON) {
578         return sc==(UScriptCode)scriptX;
579     }
580 
581     scx=scriptExtensions+(scriptX&amp;UPROPS_SCRIPT_MASK);
582     if(scriptX&gt;=UPROPS_SCRIPT_X_WITH_OTHER) {
583         scx=scriptExtensions+scx[1];
584     }
585     if(sc&gt;=USCRIPT_CODE_LIMIT) {
586         /* Guard against bogus input that would make us go past the Script_Extensions terminator. */
587         return FALSE;
588     }
589     while(sc&gt;*scx) {
590         ++scx;
591     }
592     return sc==(*scx&amp;0x7fff);
593 }
594 
595 U_CAPI int32_t U_EXPORT2
596 uscript_getScriptExtensions(UChar32 c,
597                             UScriptCode *scripts, int32_t capacity,
598                             UErrorCode *pErrorCode) {
599     uint32_t scriptX;
600     int32_t length;
601     const uint16_t *scx;
602     uint16_t sx;
603     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
604         return 0;
605     }
606     if(capacity&lt;0 || (capacity&gt;0 &amp;&amp; scripts==NULL)) {
607         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
608         return 0;
609     }
610     scriptX=u_getUnicodeProperties(c, 0)&amp;UPROPS_SCRIPT_X_MASK;
611     if(scriptX&lt;UPROPS_SCRIPT_X_WITH_COMMON) {
612         if(capacity==0) {
613             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
614         } else {
615             scripts[0]=(UScriptCode)scriptX;
616         }
617         return 1;
618     }
619 
620     scx=scriptExtensions+(scriptX&amp;UPROPS_SCRIPT_MASK);
621     if(scriptX&gt;=UPROPS_SCRIPT_X_WITH_OTHER) {
622         scx=scriptExtensions+scx[1];
623     }
624     length=0;
625     do {
626         sx=*scx++;
627         if(length&lt;capacity) {
628             scripts[length]=(UScriptCode)(sx&amp;0x7fff);
629         }
630         ++length;
631     } while(sx&lt;0x8000);
632     if(length&gt;capacity) {
633         *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
634     }
635     return length;
636 }
637 
638 U_CAPI UBlockCode U_EXPORT2
639 ublock_getCode(UChar32 c) {
640     return (UBlockCode)((u_getUnicodeProperties(c, 0)&amp;UPROPS_BLOCK_MASK)&gt;&gt;UPROPS_BLOCK_SHIFT);
641 }
642 
643 /* property starts for UnicodeSet ------------------------------------------- */
644 
645 static UBool U_CALLCONV
646 _enumPropertyStartsRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {
647     /* add the start code point to the USet */
648     const USetAdder *sa=(const USetAdder *)context;
649     sa-&gt;add(sa-&gt;set, start);
650     (void)end;
651     (void)value;
652     return TRUE;
653 }
654 
655 #define USET_ADD_CP_AND_NEXT(sa, cp) sa-&gt;add(sa-&gt;set, cp); sa-&gt;add(sa-&gt;set, cp+1)
656 
657 U_CFUNC void U_EXPORT2
658 uchar_addPropertyStarts(const USetAdder *sa, UErrorCode *pErrorCode) {
659     if(U_FAILURE(*pErrorCode)) {
660         return;
661     }
662 
663     /* add the start code point of each same-value range of the main trie */
664     utrie2_enum(&amp;propsTrie, NULL, _enumPropertyStartsRange, sa);
665 
666     /* add code points with hardcoded properties, plus the ones following them */
667 
668     /* add for u_isblank() */
669     USET_ADD_CP_AND_NEXT(sa, TAB);
670 
671     /* add for IS_THAT_CONTROL_SPACE() */
672     sa-&gt;add(sa-&gt;set, CR+1); /* range TAB..CR */
673     sa-&gt;add(sa-&gt;set, 0x1c);
674     sa-&gt;add(sa-&gt;set, 0x1f+1);
675     USET_ADD_CP_AND_NEXT(sa, NL);
676 
677     /* add for u_isIDIgnorable() what was not added above */
678     sa-&gt;add(sa-&gt;set, DEL); /* range DEL..NBSP-1, NBSP added below */
679     sa-&gt;add(sa-&gt;set, HAIRSP);
680     sa-&gt;add(sa-&gt;set, RLM+1);
681     sa-&gt;add(sa-&gt;set, INHSWAP);
682     sa-&gt;add(sa-&gt;set, NOMDIG+1);
683     USET_ADD_CP_AND_NEXT(sa, ZWNBSP);
684 
685     /* add no-break spaces for u_isWhitespace() what was not added above */
686     USET_ADD_CP_AND_NEXT(sa, NBSP);
687     USET_ADD_CP_AND_NEXT(sa, FIGURESP);
688     USET_ADD_CP_AND_NEXT(sa, NNBSP);
689 
690     /* add for u_digit() */
691     sa-&gt;add(sa-&gt;set, U_a);
692     sa-&gt;add(sa-&gt;set, U_z+1);
693     sa-&gt;add(sa-&gt;set, U_A);
694     sa-&gt;add(sa-&gt;set, U_Z+1);
695     sa-&gt;add(sa-&gt;set, U_FW_a);
696     sa-&gt;add(sa-&gt;set, U_FW_z+1);
697     sa-&gt;add(sa-&gt;set, U_FW_A);
698     sa-&gt;add(sa-&gt;set, U_FW_Z+1);
699 
700     /* add for u_isxdigit() */
701     sa-&gt;add(sa-&gt;set, U_f+1);
702     sa-&gt;add(sa-&gt;set, U_F+1);
703     sa-&gt;add(sa-&gt;set, U_FW_f+1);
704     sa-&gt;add(sa-&gt;set, U_FW_F+1);
705 
706     /* add for UCHAR_DEFAULT_IGNORABLE_CODE_POINT what was not added above */
707     sa-&gt;add(sa-&gt;set, WJ); /* range WJ..NOMDIG */
708     sa-&gt;add(sa-&gt;set, 0xfff0);
709     sa-&gt;add(sa-&gt;set, 0xfffb+1);
710     sa-&gt;add(sa-&gt;set, 0xe0000);
711     sa-&gt;add(sa-&gt;set, 0xe0fff+1);
712 
713     /* add for UCHAR_GRAPHEME_BASE and others */
714     USET_ADD_CP_AND_NEXT(sa, CGJ);
715 }
716 
717 U_CFUNC void U_EXPORT2
718 upropsvec_addPropertyStarts(const USetAdder *sa, UErrorCode *pErrorCode) {
719     if(U_FAILURE(*pErrorCode)) {
720         return;
721     }
722 
723     /* add the start code point of each same-value range of the properties vectors trie */
724     utrie2_enum(&amp;propsVectorsTrie, NULL, _enumPropertyStartsRange, sa);
725 }
    </pre>
  </body>
</html>