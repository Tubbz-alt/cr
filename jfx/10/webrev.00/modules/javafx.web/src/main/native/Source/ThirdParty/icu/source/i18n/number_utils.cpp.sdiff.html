<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_utils.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_types.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_utils.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_utils.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 53                                           UErrorCode&amp; status) {
 54     const char* patternKey;
 55     switch (style) {
 56         case CLDR_PATTERN_STYLE_DECIMAL:
 57             patternKey = &quot;decimalFormat&quot;;
 58             break;
 59         case CLDR_PATTERN_STYLE_CURRENCY:
 60             patternKey = &quot;currencyFormat&quot;;
 61             break;
 62         case CLDR_PATTERN_STYLE_ACCOUNTING:
 63             patternKey = &quot;accountingFormat&quot;;
 64             break;
 65         case CLDR_PATTERN_STYLE_PERCENT:
 66             patternKey = &quot;percentFormat&quot;;
 67             break;
 68         case CLDR_PATTERN_STYLE_SCIENTIFIC:
 69             patternKey = &quot;scientificFormat&quot;;
 70             break;
 71         default:
 72             patternKey = &quot;decimalFormat&quot;; // silence compiler error
<span class="line-modified"> 73             U_ASSERT(false);</span>
 74     }
 75     LocalUResourceBundlePointer res(ures_open(nullptr, locale.getName(), &amp;status));
 76     if (U_FAILURE(status)) { return u&quot;&quot;; }
 77 
 78     // Attempt to get the pattern with the native numbering system.
 79     UErrorCode localStatus = U_ZERO_ERROR;
 80     const char16_t* pattern;
 81     pattern = doGetPattern(res.getAlias(), nsName, patternKey, status, localStatus);
 82     if (U_FAILURE(status)) { return u&quot;&quot;; }
 83 
 84     // Fall back to latn if native numbering system does not have the right pattern
 85     if (U_FAILURE(localStatus) &amp;&amp; uprv_strcmp(&quot;latn&quot;, nsName) != 0) {
 86         localStatus = U_ZERO_ERROR;
 87         pattern = doGetPattern(res.getAlias(), &quot;latn&quot;, patternKey, status, localStatus);
 88         if (U_FAILURE(status)) { return u&quot;&quot;; }
 89     }
 90 
 91     return pattern;
 92 }
 93 
</pre>
<hr />
<pre>
220     uprv_decNumberSetBCD(fData, bcd, static_cast&lt;uint32_t&gt;(length));
221     if (fContext.status != 0) {
222         // Some error occurred while constructing the decNumber.
223         status = U_INTERNAL_PROGRAM_ERROR;
224     }
225 }
226 
227 void DecNum::normalize() {
228     uprv_decNumberReduce(fData, fData, &amp;fContext);
229 }
230 
231 void DecNum::multiplyBy(const DecNum&amp; rhs, UErrorCode&amp; status) {
232     uprv_decNumberMultiply(fData, fData, rhs.fData, &amp;fContext);
233     if (fContext.status != 0) {
234         status = U_INTERNAL_PROGRAM_ERROR;
235     }
236 }
237 
238 void DecNum::divideBy(const DecNum&amp; rhs, UErrorCode&amp; status) {
239     uprv_decNumberDivide(fData, fData, rhs.fData, &amp;fContext);
<span class="line-modified">240     if (fContext.status != 0) {</span>


241         status = U_INTERNAL_PROGRAM_ERROR;
242     }
243 }
244 
245 bool DecNum::isNegative() const {
246     return decNumberIsNegative(fData.getAlias());
247 }
248 
249 bool DecNum::isZero() const {
250     return decNumberIsZero(fData.getAlias());
251 }
252 
253 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
<td>
<hr />
<pre>
 53                                           UErrorCode&amp; status) {
 54     const char* patternKey;
 55     switch (style) {
 56         case CLDR_PATTERN_STYLE_DECIMAL:
 57             patternKey = &quot;decimalFormat&quot;;
 58             break;
 59         case CLDR_PATTERN_STYLE_CURRENCY:
 60             patternKey = &quot;currencyFormat&quot;;
 61             break;
 62         case CLDR_PATTERN_STYLE_ACCOUNTING:
 63             patternKey = &quot;accountingFormat&quot;;
 64             break;
 65         case CLDR_PATTERN_STYLE_PERCENT:
 66             patternKey = &quot;percentFormat&quot;;
 67             break;
 68         case CLDR_PATTERN_STYLE_SCIENTIFIC:
 69             patternKey = &quot;scientificFormat&quot;;
 70             break;
 71         default:
 72             patternKey = &quot;decimalFormat&quot;; // silence compiler error
<span class="line-modified"> 73             UPRV_UNREACHABLE;</span>
 74     }
 75     LocalUResourceBundlePointer res(ures_open(nullptr, locale.getName(), &amp;status));
 76     if (U_FAILURE(status)) { return u&quot;&quot;; }
 77 
 78     // Attempt to get the pattern with the native numbering system.
 79     UErrorCode localStatus = U_ZERO_ERROR;
 80     const char16_t* pattern;
 81     pattern = doGetPattern(res.getAlias(), nsName, patternKey, status, localStatus);
 82     if (U_FAILURE(status)) { return u&quot;&quot;; }
 83 
 84     // Fall back to latn if native numbering system does not have the right pattern
 85     if (U_FAILURE(localStatus) &amp;&amp; uprv_strcmp(&quot;latn&quot;, nsName) != 0) {
 86         localStatus = U_ZERO_ERROR;
 87         pattern = doGetPattern(res.getAlias(), &quot;latn&quot;, patternKey, status, localStatus);
 88         if (U_FAILURE(status)) { return u&quot;&quot;; }
 89     }
 90 
 91     return pattern;
 92 }
 93 
</pre>
<hr />
<pre>
220     uprv_decNumberSetBCD(fData, bcd, static_cast&lt;uint32_t&gt;(length));
221     if (fContext.status != 0) {
222         // Some error occurred while constructing the decNumber.
223         status = U_INTERNAL_PROGRAM_ERROR;
224     }
225 }
226 
227 void DecNum::normalize() {
228     uprv_decNumberReduce(fData, fData, &amp;fContext);
229 }
230 
231 void DecNum::multiplyBy(const DecNum&amp; rhs, UErrorCode&amp; status) {
232     uprv_decNumberMultiply(fData, fData, rhs.fData, &amp;fContext);
233     if (fContext.status != 0) {
234         status = U_INTERNAL_PROGRAM_ERROR;
235     }
236 }
237 
238 void DecNum::divideBy(const DecNum&amp; rhs, UErrorCode&amp; status) {
239     uprv_decNumberDivide(fData, fData, rhs.fData, &amp;fContext);
<span class="line-modified">240     if ((fContext.status &amp; DEC_Inexact) != 0) {</span>
<span class="line-added">241         // Ignore.</span>
<span class="line-added">242     } else if (fContext.status != 0) {</span>
243         status = U_INTERNAL_PROGRAM_ERROR;
244     }
245 }
246 
247 bool DecNum::isNegative() const {
248     return decNumberIsNegative(fData.getAlias());
249 }
250 
251 bool DecNum::isZero() const {
252     return decNumberIsZero(fData.getAlias());
253 }
254 
255 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
</tr>
</table>
<center><a href="number_types.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_utils.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>