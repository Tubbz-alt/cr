<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/putil.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="propname_data.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="putilimp.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/putil.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 100,23 ***</span>
  #   define NOSERVICE
  #   define NOIME
  #   define NOMCX
  #   include &lt;windows.h&gt;
  #   include &quot;unicode/uloc.h&quot;
<span class="line-removed">- #if U_PLATFORM_HAS_WINUWP_API == 0</span>
  #   include &quot;wintz.h&quot;
<span class="line-removed">- #else // U_PLATFORM_HAS_WINUWP_API</span>
<span class="line-removed">- typedef PVOID LPMSG; // TODO: figure out how to get rid of this typedef</span>
<span class="line-removed">- #include &lt;Windows.Globalization.h&gt;</span>
<span class="line-removed">- #include &lt;windows.system.userprofile.h&gt;</span>
<span class="line-removed">- #include &lt;wrl/wrappers/corewrappers.h&gt;</span>
<span class="line-removed">- #include &lt;wrl/client.h&gt;</span>
<span class="line-removed">- </span>
<span class="line-removed">- using namespace ABI::Windows::Foundation;</span>
<span class="line-removed">- using namespace Microsoft::WRL;</span>
<span class="line-removed">- using namespace Microsoft::WRL::Wrappers;</span>
<span class="line-removed">- #endif</span>
  #elif U_PLATFORM == U_PF_OS400
  #   include &lt;float.h&gt;
  #   include &lt;qusec.h&gt;       /* error code structure */
  #   include &lt;qusrjobi.h&gt;
  #   include &lt;qliept.h&gt;      /* EPT_CALL macro  - this include must be after all other &quot;QSYSINCs&quot; */
<span class="line-new-header">--- 100,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 251,19 ***</span>
   * Assumes POSIX gettimeofday() will function
   */
  UDate fakeClock_t0 = 0; /** Time to start the clock from **/
  UDate fakeClock_dt = 0; /** Offset (fake time - real time) **/
  UBool fakeClock_set = FALSE; /** True if fake clock has spun up **/
<span class="line-removed">- static UMutex fakeClockMutex = U_MUTEX_INTIALIZER;</span>
  
  static UDate getUTCtime_real() {
      struct timeval posixTime;
      gettimeofday(&amp;posixTime, NULL);
      return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));
      umtx_lock(&amp;fakeClockMutex);
      if(!fakeClock_set) {
          UDate real = getUTCtime_real();
          const char *fake_start = getenv(&quot;U_FAKETIME_START&quot;);
          if((fake_start!=NULL) &amp;&amp; (fake_start[0]!=0)) {
<span class="line-new-header">--- 239,19 ---</span>
   * Assumes POSIX gettimeofday() will function
   */
  UDate fakeClock_t0 = 0; /** Time to start the clock from **/
  UDate fakeClock_dt = 0; /** Offset (fake time - real time) **/
  UBool fakeClock_set = FALSE; /** True if fake clock has spun up **/
  
  static UDate getUTCtime_real() {
      struct timeval posixTime;
      gettimeofday(&amp;posixTime, NULL);
      return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));
<span class="line-added">+     static UMutex fakeClockMutex = U_MUTEX_INTIALIZER;</span>
      umtx_lock(&amp;fakeClockMutex);
      if(!fakeClock_set) {
          UDate real = getUTCtime_real();
          const char *fake_start = getenv(&quot;U_FAKETIME_START&quot;);
          if((fake_start!=NULL) &amp;&amp; (fake_start[0]!=0)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 996,11 ***</span>
      }
  
      /* Check each entry in the directory. */
      while((dirEntry = readdir(dirp)) != NULL) {
          const char* dirName = dirEntry-&gt;d_name;
<span class="line-modified">!         if (uprv_strcmp(dirName, SKIP1) != 0 &amp;&amp; uprv_strcmp(dirName, SKIP2) != 0) {</span>
              /* Create a newpath with the new entry to test each entry in the directory. */
              CharString newpath(curpath, status);
              newpath.append(dirName, -1, status);
              if (U_FAILURE(status)) {
                  break;
<span class="line-new-header">--- 984,12 ---</span>
      }
  
      /* Check each entry in the directory. */
      while((dirEntry = readdir(dirp)) != NULL) {
          const char* dirName = dirEntry-&gt;d_name;
<span class="line-modified">!         if (uprv_strcmp(dirName, SKIP1) != 0 &amp;&amp; uprv_strcmp(dirName, SKIP2) != 0</span>
<span class="line-added">+             &amp;&amp; uprv_strcmp(TZFILE_SKIP, dirName) != 0 &amp;&amp; uprv_strcmp(TZFILE_SKIP2, dirName) != 0) {</span>
              /* Create a newpath with the new entry to test each entry in the directory. */
              CharString newpath(curpath, status);
              newpath.append(dirName, -1, status);
              if (U_FAILURE(status)) {
                  break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1023,11 ***</span>
                   It worked without this in most cases because we have a fallback of calling
                   localtime_r to figure out the default timezone.
                  */
                  if (result != NULL)
                      break;
<span class="line-modified">!             } else if (uprv_strcmp(TZFILE_SKIP, dirName) != 0 &amp;&amp; uprv_strcmp(TZFILE_SKIP2, dirName) != 0) {</span>
                  if(compareBinaryFiles(TZDEFAULT, newpath.data(), tzInfo)) {
                      int32_t amountToSkip = sizeof(TZZONEINFO) - 1;
                      if (amountToSkip &gt; newpath.length()) {
                          amountToSkip = newpath.length();
                      }
<span class="line-new-header">--- 1012,11 ---</span>
                   It worked without this in most cases because we have a fallback of calling
                   localtime_r to figure out the default timezone.
                  */
                  if (result != NULL)
                      break;
<span class="line-modified">!             } else {</span>
                  if(compareBinaryFiles(TZDEFAULT, newpath.data(), tzInfo)) {
                      int32_t amountToSkip = sizeof(TZZONEINFO) - 1;
                      if (amountToSkip &gt; newpath.length()) {
                          amountToSkip = newpath.length();
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1060,68 ***</span>
  #if defined(CHECK_LOCALTIME_LINK) &amp;&amp; !defined(DEBUG_SKIP_LOCALTIME_LINK)
      gTimeZoneBufferPtr = NULL;
  #endif
  }
  
<span class="line-removed">- // With the Universal Windows Platform we can just ask Windows for the name</span>
<span class="line-removed">- #if U_PLATFORM_HAS_WINUWP_API</span>
<span class="line-removed">- U_CAPI const char* U_EXPORT2</span>
<span class="line-removed">- uprv_getWindowsTimeZone()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Get default Windows timezone.</span>
<span class="line-removed">-     ComPtr&lt;IInspectable&gt; calendar;</span>
<span class="line-removed">-     HRESULT hr = RoActivateInstance(</span>
<span class="line-removed">-         HStringReference(RuntimeClass_Windows_Globalization_Calendar).Get(),</span>
<span class="line-removed">-         &amp;calendar);</span>
<span class="line-removed">-     if (SUCCEEDED(hr))</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         ComPtr&lt;ABI::Windows::Globalization::ITimeZoneOnCalendar&gt; timezone;</span>
<span class="line-removed">-         hr = calendar.As(&amp;timezone);</span>
<span class="line-removed">-         if (SUCCEEDED(hr))</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             HString timezoneString;</span>
<span class="line-removed">-             hr = timezone-&gt;GetTimeZone(timezoneString.GetAddressOf());</span>
<span class="line-removed">-             if (SUCCEEDED(hr))</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 int32_t length = static_cast&lt;int32_t&gt;(wcslen(timezoneString.GetRawBuffer(NULL)));</span>
<span class="line-removed">-                 char* asciiId = (char*)uprv_calloc(length + 1, sizeof(char));</span>
<span class="line-removed">-                 if (asciiId != nullptr)</span>
<span class="line-removed">-                 {</span>
<span class="line-removed">-                     u_UCharsToChars((UChar*)timezoneString.GetRawBuffer(NULL), asciiId, length);</span>
<span class="line-removed">-                     return asciiId;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Failed</span>
<span class="line-removed">-     return nullptr;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  U_CAPI const char* U_EXPORT2
  uprv_tzname(int n)
  {
      (void)n; // Avoid unreferenced parameter warning.
      const char *tzid = NULL;
  #if U_PLATFORM_USES_ONLY_WIN32_API
<span class="line-removed">- #if U_PLATFORM_HAS_WINUWP_API &gt; 0</span>
<span class="line-removed">-     tzid = uprv_getWindowsTimeZone();</span>
<span class="line-removed">- #else</span>
      tzid = uprv_detectWindowsTimeZone();
<span class="line-removed">- #endif</span>
  
      if (tzid != NULL) {
          return tzid;
      }
  
  #ifndef U_TZNAME
      // The return value is free&#39;d in timezone.cpp on Windows because
      // the other code path returns a pointer to a heap location.
      // If we don&#39;t have a name already, then tzname wouldn&#39;t be any
      // better, so just fall back.
<span class="line-modified">!     return uprv_strdup(&quot;Etc/UTC&quot;);</span>
  #endif // !U_TZNAME
  
  #else
  
  /*#if U_PLATFORM_IS_DARWIN_BASED
<span class="line-new-header">--- 1049,28 ---</span>
  #if defined(CHECK_LOCALTIME_LINK) &amp;&amp; !defined(DEBUG_SKIP_LOCALTIME_LINK)
      gTimeZoneBufferPtr = NULL;
  #endif
  }
  
  U_CAPI const char* U_EXPORT2
  uprv_tzname(int n)
  {
      (void)n; // Avoid unreferenced parameter warning.
      const char *tzid = NULL;
  #if U_PLATFORM_USES_ONLY_WIN32_API
      tzid = uprv_detectWindowsTimeZone();
  
      if (tzid != NULL) {
          return tzid;
      }
  
  #ifndef U_TZNAME
      // The return value is free&#39;d in timezone.cpp on Windows because
      // the other code path returns a pointer to a heap location.
      // If we don&#39;t have a name already, then tzname wouldn&#39;t be any
      // better, so just fall back.
<span class="line-modified">!     return uprv_strdup(&quot;&quot;);</span>
  #endif // !U_TZNAME
  
  #else
  
  /*#if U_PLATFORM_IS_DARWIN_BASED
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1356,18 ***</span>
  #endif
  
    return FALSE;
  }
  
<span class="line-modified">! /* Temporary backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR</span>
<span class="line-modified">!    until some client wrapper makefiles are updated */</span>
<span class="line-modified">! #if U_PLATFORM_IS_DARWIN_BASED &amp;&amp; TARGET_IPHONE_SIMULATOR</span>
  # if !defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
  #  define ICU_DATA_DIR_PREFIX_ENV_VAR &quot;IPHONE_SIMULATOR_ROOT&quot;
  # endif
  #endif
  
  static void U_CALLCONV dataDirectoryInitFn() {
      /* If we already have the directory, then return immediately. Will happen if user called
       * u_setDataDirectory().
       */
      if (gDataDirectory) {
<span class="line-new-header">--- 1305,55 ---</span>
  #endif
  
    return FALSE;
  }
  
<span class="line-modified">! /* Backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR</span>
<span class="line-modified">!    (needed for some Darwin ICU build environments) */</span>
<span class="line-modified">! #if U_PLATFORM_IS_DARWIN_BASED &amp;&amp; TARGET_OS_SIMULATOR</span>
  # if !defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
  #  define ICU_DATA_DIR_PREFIX_ENV_VAR &quot;IPHONE_SIMULATOR_ROOT&quot;
  # endif
  #endif
  
<span class="line-added">+ #if U_PLATFORM_HAS_WINUWP_API != 0</span>
<span class="line-added">+ // Helper function to get the ICU Data Directory under the Windows directory location.</span>
<span class="line-added">+ static BOOL U_CALLCONV getIcuDataDirectoryUnderWindowsDirectory(char* directoryBuffer, UINT bufferLength)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if defined(ICU_DATA_DIR_WINDOWS)</span>
<span class="line-added">+     wchar_t windowsPath[MAX_PATH];</span>
<span class="line-added">+     char windowsPathUtf8[MAX_PATH];</span>
<span class="line-added">+ </span>
<span class="line-added">+     UINT length = GetSystemWindowsDirectoryW(windowsPath, UPRV_LENGTHOF(windowsPath));</span>
<span class="line-added">+     if ((length &gt; 0) &amp;&amp; (length &lt; (UPRV_LENGTHOF(windowsPath) - 1))) {</span>
<span class="line-added">+         // Convert UTF-16 to a UTF-8 string.</span>
<span class="line-added">+         UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added">+         int32_t windowsPathUtf8Len = 0;</span>
<span class="line-added">+         u_strToUTF8(windowsPathUtf8, static_cast&lt;int32_t&gt;(UPRV_LENGTHOF(windowsPathUtf8)),</span>
<span class="line-added">+             &amp;windowsPathUtf8Len, reinterpret_cast&lt;const UChar*&gt;(windowsPath), -1, &amp;status);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (U_SUCCESS(status) &amp;&amp; (status != U_STRING_NOT_TERMINATED_WARNING) &amp;&amp;</span>
<span class="line-added">+             (windowsPathUtf8Len &lt; (UPRV_LENGTHOF(windowsPathUtf8) - 1))) {</span>
<span class="line-added">+             // Ensure it always has a separator, so we can append the ICU data path.</span>
<span class="line-added">+             if (windowsPathUtf8[windowsPathUtf8Len - 1] != U_FILE_SEP_CHAR) {</span>
<span class="line-added">+                 windowsPathUtf8[windowsPathUtf8Len++] = U_FILE_SEP_CHAR;</span>
<span class="line-added">+                 windowsPathUtf8[windowsPathUtf8Len] = &#39;\0&#39;;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // Check if the concatenated string will fit.</span>
<span class="line-added">+             if ((windowsPathUtf8Len + UPRV_LENGTHOF(ICU_DATA_DIR_WINDOWS)) &lt; bufferLength) {</span>
<span class="line-added">+                 uprv_strcpy(directoryBuffer, windowsPathUtf8);</span>
<span class="line-added">+                 uprv_strcat(directoryBuffer, ICU_DATA_DIR_WINDOWS);</span>
<span class="line-added">+                 return TRUE;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FALSE;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  static void U_CALLCONV dataDirectoryInitFn() {
      /* If we already have the directory, then return immediately. Will happen if user called
       * u_setDataDirectory().
       */
      if (gDataDirectory) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1423,39 ***</span>
          }
  # endif
      }
  #endif
  
<span class="line-modified">! #if defined(ICU_DATA_DIR_WINDOWS) &amp;&amp; U_PLATFORM_HAS_WINUWP_API != 0</span>
<span class="line-removed">-     // Use data from the %windir%\globalization\icu directory</span>
<span class="line-removed">-     // This is only available if ICU is built as a system component</span>
      char datadir_path_buffer[MAX_PATH];
<span class="line-modified">!     UINT length = GetWindowsDirectoryA(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer));</span>
<span class="line-modified">!     if (length &gt; 0 &amp;&amp; length &lt; (UPRV_LENGTHOF(datadir_path_buffer) - sizeof(ICU_DATA_DIR_WINDOWS) - 1))</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (datadir_path_buffer[length - 1] != &#39;\\&#39;)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             datadir_path_buffer[length++] = &#39;\\&#39;;</span>
<span class="line-removed">-             datadir_path_buffer[length] = &#39;\0&#39;;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if ((length + 1 + sizeof(ICU_DATA_DIR_WINDOWS)) &lt; UPRV_LENGTHOF(datadir_path_buffer))</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             uprv_strcat(datadir_path_buffer, ICU_DATA_DIR_WINDOWS);</span>
<span class="line-removed">-             path = datadir_path_buffer;</span>
<span class="line-removed">-         }</span>
      }
  #endif
  
      if(path==NULL) {
          /* It looks really bad, set it to something. */
<span class="line-removed">- #if U_PLATFORM_HAS_WIN32_API</span>
<span class="line-removed">-         // Windows UWP will require icudtl.dat file in same directory as icuuc.dll</span>
<span class="line-removed">-         path = &quot;.\\&quot;;</span>
<span class="line-removed">- #else</span>
          path = &quot;&quot;;
<span class="line-removed">- #endif</span>
      }
  
      u_setDataDirectory(path);
      return;
  }
<span class="line-new-header">--- 1409,20 ---</span>
          }
  # endif
      }
  #endif
  
<span class="line-modified">! #if U_PLATFORM_HAS_WINUWP_API != 0  &amp;&amp; defined(ICU_DATA_DIR_WINDOWS)</span>
      char datadir_path_buffer[MAX_PATH];
<span class="line-modified">!     if (getIcuDataDirectoryUnderWindowsDirectory(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer))) {</span>
<span class="line-modified">!         path = datadir_path_buffer;</span>
      }
  #endif
  
      if(path==NULL) {
          /* It looks really bad, set it to something. */
          path = &quot;&quot;;
      }
  
      u_setDataDirectory(path);
      return;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1489,24 ***</span>
      gTimeZoneFilesDirectory = new CharString();
      if (gTimeZoneFilesDirectory == NULL) {
          status = U_MEMORY_ALLOCATION_ERROR;
          return;
      }
<span class="line-modified">! #if U_PLATFORM_HAS_WINUWP_API == 0</span>
<span class="line-removed">-     const char *dir = getenv(&quot;ICU_TIMEZONE_FILES_DIR&quot;);</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     // TODO: UWP does not support alternate timezone data directories at this time</span>
      const char *dir = &quot;&quot;;
  #endif // U_PLATFORM_HAS_WINUWP_API
  #if defined(U_TIMEZONE_FILES_DIR)
      if (dir == NULL) {
          dir = TO_STRING(U_TIMEZONE_FILES_DIR);
      }
  #endif
      if (dir == NULL) {
          dir = &quot;&quot;;
      }
      setTimeZoneFilesDir(dir, status);
  }
  
  
  U_CAPI const char * U_EXPORT2
<span class="line-new-header">--- 1456,34 ---</span>
      gTimeZoneFilesDirectory = new CharString();
      if (gTimeZoneFilesDirectory == NULL) {
          status = U_MEMORY_ALLOCATION_ERROR;
          return;
      }
<span class="line-modified">! </span>
      const char *dir = &quot;&quot;;
<span class="line-added">+ </span>
<span class="line-added">+ #if U_PLATFORM_HAS_WINUWP_API != 0</span>
<span class="line-added">+     // The UWP version does not support the environment variable setting, but can possibly pick them up from the Windows directory.</span>
<span class="line-added">+     char datadir_path_buffer[MAX_PATH];</span>
<span class="line-added">+     if (getIcuDataDirectoryUnderWindowsDirectory(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer))) {</span>
<span class="line-added">+         dir = datadir_path_buffer;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     dir = getenv(&quot;ICU_TIMEZONE_FILES_DIR&quot;);</span>
  #endif // U_PLATFORM_HAS_WINUWP_API
<span class="line-added">+ </span>
  #if defined(U_TIMEZONE_FILES_DIR)
      if (dir == NULL) {
<span class="line-added">+         // Build time configuration setting.</span>
          dir = TO_STRING(U_TIMEZONE_FILES_DIR);
      }
  #endif
<span class="line-added">+ </span>
      if (dir == NULL) {
          dir = &quot;&quot;;
      }
<span class="line-added">+ </span>
      setTimeZoneFilesDir(dir, status);
  }
  
  
  U_CAPI const char * U_EXPORT2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1639,71 ***</span>
  
  The variant cannot have dots in it.
  The &#39;rightmost&#39; variant (@xxx) wins.
  The leftmost codepage (.xxx) wins.
  */
<span class="line-removed">-     char *correctedPOSIXLocale = 0;</span>
      const char* posixID = uprv_getPOSIXIDForDefaultLocale();
<span class="line-removed">-     const char *p;</span>
<span class="line-removed">-     const char *q;</span>
<span class="line-removed">-     int32_t len;</span>
  
      /* Format: (no spaces)
      ll [ _CC ] [ . MM ] [ @ VV]
  
        l = lang, C = ctry, M = charmap, V = variant
      */
  
<span class="line-modified">!     if (gCorrectedPOSIXLocale != NULL) {</span>
          return gCorrectedPOSIXLocale;
      }
  
<span class="line-modified">!     if ((p = uprv_strchr(posixID, &#39;.&#39;)) != NULL) {</span>
<span class="line-modified">!         /* assume new locale can&#39;t be larger than old one? */</span>
<span class="line-modified">!         correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(uprv_strlen(posixID)+1));</span>
<span class="line-modified">!         /* Exit on memory allocation error. */</span>
<span class="line-modified">!         if (correctedPOSIXLocale == NULL) {</span>
<span class="line-modified">!             return NULL;</span>
<span class="line-modified">!         }</span>
<span class="line-removed">-         uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);</span>
<span class="line-removed">-         correctedPOSIXLocale[p-posixID] = 0;</span>
  
<span class="line-modified">!         /* do not copy after the @ */</span>
<span class="line-modified">!         if ((p = uprv_strchr(correctedPOSIXLocale, &#39;@&#39;)) != NULL) {</span>
<span class="line-modified">!             correctedPOSIXLocale[p-correctedPOSIXLocale] = 0;</span>
          }
      }
  
      /* Note that we scan the *uncorrected* ID. */
<span class="line-modified">!     if ((p = uprv_strrchr(posixID, &#39;@&#39;)) != NULL) {</span>
<span class="line-modified">!         if (correctedPOSIXLocale == NULL) {</span>
<span class="line-removed">-             correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(uprv_strlen(posixID)+1));</span>
<span class="line-removed">-             /* Exit on memory allocation error. */</span>
<span class="line-removed">-             if (correctedPOSIXLocale == NULL) {</span>
<span class="line-removed">-                 return NULL;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);</span>
<span class="line-removed">-             correctedPOSIXLocale[p-posixID] = 0;</span>
<span class="line-removed">-         }</span>
          p++;
  
          /* Take care of any special cases here.. */
          if (!uprv_strcmp(p, &quot;nynorsk&quot;)) {
              p = &quot;NY&quot;;
              /* Don&#39;t worry about no__NY. In practice, it won&#39;t appear. */
          }
  
<span class="line-modified">!         if (uprv_strchr(correctedPOSIXLocale,&#39;_&#39;) == NULL) {</span>
<span class="line-modified">!             uprv_strcat(correctedPOSIXLocale, &quot;__&quot;); /* aa@b -&gt; aa__b */</span>
          }
          else {
              uprv_strcat(correctedPOSIXLocale, &quot;_&quot;); /* aa_CC@b -&gt; aa_CC_b */
          }
  
<span class="line-modified">!         if ((q = uprv_strchr(p, &#39;.&#39;)) != NULL) {</span>
              /* How big will the resulting string be? */
<span class="line-modified">!             len = (int32_t)(uprv_strlen(correctedPOSIXLocale) + (q-p));</span>
              uprv_strncat(correctedPOSIXLocale, p, q-p);
              correctedPOSIXLocale[len] = 0;
          }
          else {
              /* Anything following the @ sign */
<span class="line-new-header">--- 1616,60 ---</span>
  
  The variant cannot have dots in it.
  The &#39;rightmost&#39; variant (@xxx) wins.
  The leftmost codepage (.xxx) wins.
  */
      const char* posixID = uprv_getPOSIXIDForDefaultLocale();
  
      /* Format: (no spaces)
      ll [ _CC ] [ . MM ] [ @ VV]
  
        l = lang, C = ctry, M = charmap, V = variant
      */
  
<span class="line-modified">!     if (gCorrectedPOSIXLocale != nullptr) {</span>
          return gCorrectedPOSIXLocale;
      }
  
<span class="line-modified">!     // Copy the ID into owned memory.</span>
<span class="line-modified">!     // Over-allocate in case we replace &quot;@&quot; with &quot;__&quot;.</span>
<span class="line-modified">!     char *correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(uprv_strlen(posixID) + 1 + 1));</span>
<span class="line-modified">!     if (correctedPOSIXLocale == nullptr) {</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     uprv_strcpy(correctedPOSIXLocale, posixID);</span>
  
<span class="line-modified">!     char *limit;</span>
<span class="line-modified">!     if ((limit = uprv_strchr(correctedPOSIXLocale, &#39;.&#39;)) != nullptr) {</span>
<span class="line-modified">!         *limit = 0;</span>
<span class="line-added">+         if ((limit = uprv_strchr(correctedPOSIXLocale, &#39;@&#39;)) != nullptr) {</span>
<span class="line-added">+             *limit = 0;</span>
          }
      }
  
      /* Note that we scan the *uncorrected* ID. */
<span class="line-modified">!     const char *p;</span>
<span class="line-modified">!     if ((p = uprv_strrchr(posixID, &#39;@&#39;)) != nullptr) {</span>
          p++;
  
          /* Take care of any special cases here.. */
          if (!uprv_strcmp(p, &quot;nynorsk&quot;)) {
              p = &quot;NY&quot;;
              /* Don&#39;t worry about no__NY. In practice, it won&#39;t appear. */
          }
  
<span class="line-modified">!         if (uprv_strchr(correctedPOSIXLocale,&#39;_&#39;) == nullptr) {</span>
<span class="line-modified">!             uprv_strcat(correctedPOSIXLocale, &quot;__&quot;); /* aa@b -&gt; aa__b (note this can make the new locale 1 char longer) */</span>
          }
          else {
              uprv_strcat(correctedPOSIXLocale, &quot;_&quot;); /* aa_CC@b -&gt; aa_CC_b */
          }
  
<span class="line-modified">!         const char *q;</span>
<span class="line-added">+         if ((q = uprv_strchr(p, &#39;.&#39;)) != nullptr) {</span>
              /* How big will the resulting string be? */
<span class="line-modified">!             int32_t len = (int32_t)(uprv_strlen(correctedPOSIXLocale) + (q-p));</span>
              uprv_strncat(correctedPOSIXLocale, p, q-p);
              correctedPOSIXLocale[len] = 0;
          }
          else {
              /* Anything following the @ sign */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1715,104 ***</span>
           * Many of the other locales using ISO codes will be handled by the
           * canonicalization functions in uloc_getDefault.
           */
      }
  
<span class="line-modified">!     /* Was a correction made? */</span>
<span class="line-removed">-     if (correctedPOSIXLocale != NULL) {</span>
<span class="line-removed">-         posixID = correctedPOSIXLocale;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     else {</span>
<span class="line-removed">-         /* copy it, just in case the original pointer goes away.  See j2395 */</span>
<span class="line-removed">-         correctedPOSIXLocale = (char *)uprv_malloc(uprv_strlen(posixID) + 1);</span>
<span class="line-removed">-         /* Exit on memory allocation error. */</span>
<span class="line-removed">-         if (correctedPOSIXLocale == NULL) {</span>
<span class="line-removed">-             return NULL;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         posixID = uprv_strcpy(correctedPOSIXLocale, posixID);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (gCorrectedPOSIXLocale == NULL) {</span>
          gCorrectedPOSIXLocale = correctedPOSIXLocale;
          gCorrectedPOSIXLocaleHeapAllocated = true;
          ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
<span class="line-modified">!         correctedPOSIXLocale = NULL;</span>
      }
  
<span class="line-modified">!     if (correctedPOSIXLocale != NULL) {  /* Was already set - clean up. */</span>
          uprv_free(correctedPOSIXLocale);
      }
  
      return posixID;
  
  #elif U_PLATFORM_USES_ONLY_WIN32_API
  #define POSIX_LOCALE_CAPACITY 64
      UErrorCode status = U_ZERO_ERROR;
<span class="line-modified">!     char *correctedPOSIXLocale = 0;</span>
  
      // If we have already figured this out just use the cached value
<span class="line-modified">!     if (gCorrectedPOSIXLocale != NULL) {</span>
          return gCorrectedPOSIXLocale;
      }
  
      // No cached value, need to determine the current value
<span class="line-modified">!     static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH];</span>
<span class="line-modified">! #if U_PLATFORM_HAS_WINUWP_API == 0</span>
<span class="line-removed">-     // If not a Universal Windows App, we&#39;ll need user default language.</span>
<span class="line-removed">-     // Vista and above should use Locale Names instead of LCIDs</span>
<span class="line-removed">-     int length = GetUserDefaultLocaleName(windowsLocale, UPRV_LENGTHOF(windowsLocale));</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     // In a UWP app, we want the top language that the application and user agreed upon</span>
<span class="line-removed">-     ComPtr&lt;ABI::Windows::Foundation::Collections::IVectorView&lt;HSTRING&gt;&gt; languageList;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ComPtr&lt;ABI::Windows::Globalization::IApplicationLanguagesStatics&gt; applicationLanguagesStatics;</span>
<span class="line-removed">-     HRESULT hr = GetActivationFactory(</span>
<span class="line-removed">-         HStringReference(RuntimeClass_Windows_Globalization_ApplicationLanguages).Get(),</span>
<span class="line-removed">-         &amp;applicationLanguagesStatics);</span>
<span class="line-removed">-     if (SUCCEEDED(hr))</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         hr = applicationLanguagesStatics-&gt;get_Languages(&amp;languageList);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (FAILED(hr))</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         // If there is no application context, then use the top language from the user language profile</span>
<span class="line-removed">-         ComPtr&lt;ABI::Windows::System::UserProfile::IGlobalizationPreferencesStatics&gt; globalizationPreferencesStatics;</span>
<span class="line-removed">-         hr = GetActivationFactory(</span>
<span class="line-removed">-             HStringReference(RuntimeClass_Windows_System_UserProfile_GlobalizationPreferences).Get(),</span>
<span class="line-removed">-             &amp;globalizationPreferencesStatics);</span>
<span class="line-removed">-         if (SUCCEEDED(hr))</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             hr = globalizationPreferencesStatics-&gt;get_Languages(&amp;languageList);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We have a list of languages, ICU knows one, so use the top one for our locale</span>
<span class="line-removed">-     HString topLanguage;</span>
<span class="line-removed">-     if (SUCCEEDED(hr))</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         hr = languageList-&gt;GetAt(0, topLanguage.GetAddressOf());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (FAILED(hr))</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         // Unexpected, use en-US by default</span>
<span class="line-removed">-         if (gCorrectedPOSIXLocale == NULL) {</span>
<span class="line-removed">-             gCorrectedPOSIXLocale = &quot;en_US&quot;;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         return gCorrectedPOSIXLocale;</span>
<span class="line-modified">!     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // ResolveLocaleName will get a likely subtags form consistent with Windows behavior.</span>
<span class="line-removed">-     int length = ResolveLocaleName(topLanguage.GetRawBuffer(NULL), windowsLocale, UPRV_LENGTHOF(windowsLocale));</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     // Now we should have a Windows locale name that needs converted to the POSIX style,</span>
<span class="line-removed">-     if (length &gt; 0)</span>
      {
          // First we need to go from UTF-16 to char (and also convert from _ to - while we&#39;re at it.)
<span class="line-modified">!         char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH];</span>
  
          int32_t i;
          for (i = 0; i &lt; UPRV_LENGTHOF(modifiedWindowsLocale); i++)
          {
              if (windowsLocale[i] == &#39;_&#39;)
<span class="line-new-header">--- 1681,43 ---</span>
           * Many of the other locales using ISO codes will be handled by the
           * canonicalization functions in uloc_getDefault.
           */
      }
  
<span class="line-modified">!     if (gCorrectedPOSIXLocale == nullptr) {</span>
          gCorrectedPOSIXLocale = correctedPOSIXLocale;
          gCorrectedPOSIXLocaleHeapAllocated = true;
          ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
<span class="line-modified">!         correctedPOSIXLocale = nullptr;</span>
      }
<span class="line-added">+     posixID = gCorrectedPOSIXLocale;</span>
  
<span class="line-modified">!     if (correctedPOSIXLocale != nullptr) {  /* Was already set - clean up. */</span>
          uprv_free(correctedPOSIXLocale);
      }
  
      return posixID;
  
  #elif U_PLATFORM_USES_ONLY_WIN32_API
  #define POSIX_LOCALE_CAPACITY 64
      UErrorCode status = U_ZERO_ERROR;
<span class="line-modified">!     char *correctedPOSIXLocale = nullptr;</span>
  
      // If we have already figured this out just use the cached value
<span class="line-modified">!     if (gCorrectedPOSIXLocale != nullptr) {</span>
          return gCorrectedPOSIXLocale;
      }
  
      // No cached value, need to determine the current value
<span class="line-modified">!     static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH] = {};</span>
<span class="line-modified">!     int length = GetLocaleInfoEx(LOCALE_NAME_USER_DEFAULT, LOCALE_SNAME, windowsLocale, LOCALE_NAME_MAX_LENGTH);</span>
  
<span class="line-modified">!     // Now we should have a Windows locale name that needs converted to the POSIX style.</span>
<span class="line-modified">!     if (length &gt; 0) // If length is 0, then the GetLocaleInfoEx failed.</span>
      {
          // First we need to go from UTF-16 to char (and also convert from _ to - while we&#39;re at it.)
<span class="line-modified">!         char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH] = {};</span>
  
          int32_t i;
          for (i = 0; i &lt; UPRV_LENGTHOF(modifiedWindowsLocale); i++)
          {
              if (windowsLocale[i] == &#39;_&#39;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1856,11 ***</span>
              }
          }
      }
  
      // If unable to find a locale we can agree upon, use en-US by default
<span class="line-modified">!     if (gCorrectedPOSIXLocale == NULL) {</span>
          gCorrectedPOSIXLocale = &quot;en_US&quot;;
      }
      return gCorrectedPOSIXLocale;
  
  #elif U_PLATFORM == U_PF_OS400
<span class="line-new-header">--- 1761,11 ---</span>
              }
          }
      }
  
      // If unable to find a locale we can agree upon, use en-US by default
<span class="line-modified">!     if (gCorrectedPOSIXLocale == nullptr) {</span>
          gCorrectedPOSIXLocale = &quot;en_US&quot;;
      }
      return gCorrectedPOSIXLocale;
  
  #elif U_PLATFORM == U_PF_OS400
</pre>
<center><a href="propname_data.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="putilimp.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>