<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/decimfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="decNumberLocal.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion-bignum-dtoa.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/decimfmt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,11 ***</span>
  using namespace icu::numparse;
  using namespace icu::numparse::impl;
  using ERoundingMode = icu::DecimalFormat::ERoundingMode;
  using EPadPosition = icu::DecimalFormat::EPadPosition;
  
<span class="line-modified">! // MSVC warns C4805 when comparing bool with UBool</span>
  // TODO: Move this macro into a better place?
  #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN
  #define UBOOL_TO_BOOL(b) static_cast&lt;bool&gt;(b)
  #else
  #define UBOOL_TO_BOOL(b) b
<span class="line-new-header">--- 29,11 ---</span>
  using namespace icu::numparse;
  using namespace icu::numparse::impl;
  using ERoundingMode = icu::DecimalFormat::ERoundingMode;
  using EPadPosition = icu::DecimalFormat::EPadPosition;
  
<span class="line-modified">! // MSVC VS2015 warns C4805 when comparing bool with UBool, VS2017 no longer emits this warning.</span>
  // TODO: Move this macro into a better place?
  #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN
  #define UBOOL_TO_BOOL(b) static_cast&lt;bool&gt;(b)
  #else
  #define UBOOL_TO_BOOL(b) b
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,10 ***</span>
<span class="line-new-header">--- 43,11 ---</span>
  UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DecimalFormat)
  
  
  DecimalFormat::DecimalFormat(UErrorCode&amp; status)
          : DecimalFormat(nullptr, status) {
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
      // Use the default locale and decimal pattern.
      const char* localeName = Locale::getDefault().getName();
      LocalPointer&lt;NumberingSystem&gt; ns(NumberingSystem::createInstance(status));
      UnicodeString patternString = utils::getPatternForStyle(
              localeName,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,26 ***</span>
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, UErrorCode&amp; status)
          : DecimalFormat(nullptr, status) {
      setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
                               UErrorCode&amp; status)
          : DecimalFormat(symbolsToAdopt, status) {
      setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
                               UNumberFormatStyle style, UErrorCode&amp; status)
          : DecimalFormat(symbolsToAdopt, status) {
      // If choice is a currency type, ignore the rounding information.
<span class="line-modified">!     if (style == UNumberFormatStyle::UNUM_CURRENCY || style == UNumberFormatStyle::UNUM_CURRENCY_ISO ||</span>
          style == UNumberFormatStyle::UNUM_CURRENCY_ACCOUNTING ||
          style == UNumberFormatStyle::UNUM_CASH_CURRENCY ||
          style == UNumberFormatStyle::UNUM_CURRENCY_STANDARD ||
          style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {
          setPropertiesFromPattern(pattern, IGNORE_ROUNDING_ALWAYS, status);
<span class="line-new-header">--- 58,30 ---</span>
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, UErrorCode&amp; status)
          : DecimalFormat(nullptr, status) {
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
      setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
                               UErrorCode&amp; status)
          : DecimalFormat(symbolsToAdopt, status) {
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
      setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
                               UNumberFormatStyle style, UErrorCode&amp; status)
          : DecimalFormat(symbolsToAdopt, status) {
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
      // If choice is a currency type, ignore the rounding information.
<span class="line-modified">!     if (style == UNumberFormatStyle::UNUM_CURRENCY ||</span>
<span class="line-added">+         style == UNumberFormatStyle::UNUM_CURRENCY_ISO ||</span>
          style == UNumberFormatStyle::UNUM_CURRENCY_ACCOUNTING ||
          style == UNumberFormatStyle::UNUM_CASH_CURRENCY ||
          style == UNumberFormatStyle::UNUM_CURRENCY_STANDARD ||
          style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {
          setPropertiesFromPattern(pattern, IGNORE_ROUNDING_ALWAYS, status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,41 ***</span>
      }
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status) {
      LocalPointer&lt;const DecimalFormatSymbols&gt; adoptedSymbols(symbolsToAdopt);
<span class="line-removed">-     fields = new DecimalFormatFields();</span>
      if (U_FAILURE(status)) {
          return;
      }
      if (fields == nullptr) {
          status = U_MEMORY_ALLOCATION_ERROR;
          return;
      }
      fields-&gt;properties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
      fields-&gt;exportedProperties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
      if (adoptedSymbols.isNull()) {
          fields-&gt;symbols.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(status), status);
      } else {
  }
  
  #if UCONFIG_HAVE_PARSEALLINPUT
  
  void DecimalFormat::setParseAllInput(UNumberFormatAttributeValue value) {
      if (value == fields-&gt;properties-&gt;parseAllInput) { return; }
      fields-&gt;properties-&gt;parseAllInput = value;
  }
  
  #endif
      switch (attr) {
          case UNUM_LENIENT_PARSE:
              setLenient(newValue != 0);
              break;
  
<span class="line-new-header">--- 99,58 ---</span>
      }
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status) {
<span class="line-added">+     // we must take ownership of symbolsToAdopt, even in a failure case.</span>
      LocalPointer&lt;const DecimalFormatSymbols&gt; adoptedSymbols(symbolsToAdopt);
      if (U_FAILURE(status)) {
          return;
      }
<span class="line-added">+     fields = new DecimalFormatFields();</span>
      if (fields == nullptr) {
          status = U_MEMORY_ALLOCATION_ERROR;
          return;
      }
<span class="line-added">+     fields-&gt;formatter.adoptInsteadAndCheckErrorCode(new LocalizedNumberFormatter(), status);</span>
      fields-&gt;properties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
      fields-&gt;exportedProperties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
      if (adoptedSymbols.isNull()) {
          fields-&gt;symbols.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(status), status);
      } else {
<span class="line-added">+     // In order to simplify error handling logic in the various getters/setters/etc, we do not allow</span>
<span class="line-added">+     // any partially populated DecimalFormatFields object. We must have a fully complete fields object</span>
<span class="line-added">+     // or else we set it to nullptr.</span>
<span class="line-added">+     if (fields-&gt;formatter.isNull() || fields-&gt;properties.isNull() || fields-&gt;exportedProperties.isNull() || fields-&gt;symbols.isNull()) {</span>
<span class="line-added">+         delete fields;</span>
<span class="line-added">+         fields = nullptr;</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+     }</span>
  }
  
  #if UCONFIG_HAVE_PARSEALLINPUT
  
  void DecimalFormat::setParseAllInput(UNumberFormatAttributeValue value) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (value == fields-&gt;properties-&gt;parseAllInput) { return; }
      fields-&gt;properties-&gt;parseAllInput = value;
  }
  
  #endif
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return *this;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      switch (attr) {
          case UNUM_LENIENT_PARSE:
              setLenient(newValue != 0);
              break;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,10 ***</span>
<span class="line-new-header">--- 274,17 ---</span>
      return *this;
  }
  
  int32_t DecimalFormat::getAttribute(UNumberFormatAttribute attr, UErrorCode&amp; status) const {
      if (U_FAILURE(status)) { return -1; }
<span class="line-added">+ </span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      switch (attr) {
          case UNUM_LENIENT_PARSE:
              return isLenient();
  
          case UNUM_PARSE_INT_ONLY:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,123 ***</span>
  
      return -1; /* undefined */
  }
  
  void DecimalFormat::setGroupingUsed(UBool enabled) {
      if (UBOOL_TO_BOOL(enabled) == fields-&gt;properties-&gt;groupingUsed) { return; }
      NumberFormat::setGroupingUsed(enabled); // to set field for compatibility
      fields-&gt;properties-&gt;groupingUsed = enabled;
      touchNoError();
  }
  
  void DecimalFormat::setParseIntegerOnly(UBool value) {
      if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseIntegerOnly) { return; }
      NumberFormat::setParseIntegerOnly(value); // to set field for compatibility
      fields-&gt;properties-&gt;parseIntegerOnly = value;
      touchNoError();
  }
  
  void DecimalFormat::setLenient(UBool enable) {
      ParseMode mode = enable ? PARSE_MODE_LENIENT : PARSE_MODE_STRICT;
      if (!fields-&gt;properties-&gt;parseMode.isNull() &amp;&amp; mode == fields-&gt;properties-&gt;parseMode.getNoError()) { return; }
      NumberFormat::setLenient(enable); // to set field for compatibility
      fields-&gt;properties-&gt;parseMode = mode;
      touchNoError();
  }
  
  DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
                               UParseError&amp;, UErrorCode&amp; status)
          : DecimalFormat(symbolsToAdopt, status) {
      // TODO: What is parseError for?
      setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, const DecimalFormatSymbols&amp; symbols,
                               UErrorCode&amp; status)
<span class="line-modified">!         : DecimalFormat(new DecimalFormatSymbols(symbols), status) {</span>
      setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const DecimalFormat&amp; source) : NumberFormat(source) {
      // Note: it is not safe to copy fields-&gt;formatter or fWarehouse directly because fields-&gt;formatter might have
      // dangling pointers to fields inside fWarehouse. The safe thing is to re-construct fields-&gt;formatter from
      // the property bag, despite being somewhat slower.
      fields = new DecimalFormatFields();
      if (fields == nullptr) {
<span class="line-modified">!         return;</span>
      }
<span class="line-modified">!     fields-&gt;properties.adoptInstead(new DecimalFormatProperties(*source.fields-&gt;properties));</span>
<span class="line-modified">!     fields-&gt;symbols.adoptInstead(new DecimalFormatSymbols(*source.fields-&gt;symbols));</span>
<span class="line-modified">!     fields-&gt;exportedProperties.adoptInstead(new DecimalFormatProperties());</span>
<span class="line-modified">!     if (fields-&gt;properties == nullptr || fields-&gt;symbols == nullptr || fields-&gt;exportedProperties == nullptr) {</span>
          return;
      }
<span class="line-modified">!     touchNoError();</span>
  }
  
  DecimalFormat&amp; DecimalFormat::operator=(const DecimalFormat&amp; rhs) {
      *fields-&gt;properties = *rhs.fields-&gt;properties;
      fields-&gt;exportedProperties-&gt;clear();
<span class="line-modified">!     fields-&gt;symbols.adoptInstead(new DecimalFormatSymbols(*rhs.fields-&gt;symbols));</span>
<span class="line-modified">!     touchNoError();</span>
      return *this;
  }
  
  DecimalFormat::~DecimalFormat() {
      delete fields-&gt;atomicParser.exchange(nullptr);
      delete fields-&gt;atomicCurrencyParser.exchange(nullptr);
      delete fields;
  }
  
  Format* DecimalFormat::clone() const {
<span class="line-modified">!     return new DecimalFormat(*this);</span>
  }
  
  UBool DecimalFormat::operator==(const Format&amp; other) const {
      auto* otherDF = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;other);
      if (otherDF == nullptr) {
          return false;
      }
      return *fields-&gt;properties == *otherDF-&gt;fields-&gt;properties &amp;&amp; *fields-&gt;symbols == *otherDF-&gt;fields-&gt;symbols;
  }
  
  UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
      if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
          return appendTo;
      }
      UErrorCode localStatus = U_ZERO_ERROR;
      FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, localStatus);
      fieldPositionHelper(output, pos, appendTo.length(), localStatus);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable);</span>
      return appendTo;
  }
  
  UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
                                       UErrorCode&amp; status) const {
      if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
          return appendTo;
      }
      FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
      fieldPositionHelper(output, pos, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable);</span>
      return appendTo;
  }
  
  UnicodeString&amp;
  DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
                        UErrorCode&amp; status) const {
      if (posIter == nullptr &amp;&amp; fastFormatDouble(number, appendTo)) {
          return appendTo;
      }
      FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
      fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable);</span>
      return appendTo;
  }
  
  UnicodeString&amp; DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
      return format(static_cast&lt;int64_t&gt; (number), appendTo, pos);
<span class="line-new-header">--- 374,210 ---</span>
  
      return -1; /* undefined */
  }
  
  void DecimalFormat::setGroupingUsed(UBool enabled) {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (UBOOL_TO_BOOL(enabled) == fields-&gt;properties-&gt;groupingUsed) { return; }
      NumberFormat::setGroupingUsed(enabled); // to set field for compatibility
      fields-&gt;properties-&gt;groupingUsed = enabled;
      touchNoError();
  }
  
  void DecimalFormat::setParseIntegerOnly(UBool value) {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseIntegerOnly) { return; }
      NumberFormat::setParseIntegerOnly(value); // to set field for compatibility
      fields-&gt;properties-&gt;parseIntegerOnly = value;
      touchNoError();
  }
  
  void DecimalFormat::setLenient(UBool enable) {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      ParseMode mode = enable ? PARSE_MODE_LENIENT : PARSE_MODE_STRICT;
      if (!fields-&gt;properties-&gt;parseMode.isNull() &amp;&amp; mode == fields-&gt;properties-&gt;parseMode.getNoError()) { return; }
      NumberFormat::setLenient(enable); // to set field for compatibility
      fields-&gt;properties-&gt;parseMode = mode;
      touchNoError();
  }
  
  DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
                               UParseError&amp;, UErrorCode&amp; status)
          : DecimalFormat(symbolsToAdopt, status) {
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
      // TODO: What is parseError for?
      setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, const DecimalFormatSymbols&amp; symbols,
                               UErrorCode&amp; status)
<span class="line-modified">!         : DecimalFormat(nullptr, status) {</span>
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">+     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(new DecimalFormatSymbols(symbols), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         // If we failed to allocate DecimalFormatSymbols, then release fields and its members.</span>
<span class="line-added">+         // We must have a fully complete fields object, we cannot have partially populated members.</span>
<span class="line-added">+         delete fields;</span>
<span class="line-added">+         fields = nullptr;</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
      setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
      touch(status);
  }
  
  DecimalFormat::DecimalFormat(const DecimalFormat&amp; source) : NumberFormat(source) {
<span class="line-added">+     // If the object that we are copying from is invalid, no point in going further.</span>
<span class="line-added">+     if (source.fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      // Note: it is not safe to copy fields-&gt;formatter or fWarehouse directly because fields-&gt;formatter might have
      // dangling pointers to fields inside fWarehouse. The safe thing is to re-construct fields-&gt;formatter from
      // the property bag, despite being somewhat slower.
      fields = new DecimalFormatFields();
      if (fields == nullptr) {
<span class="line-modified">!         return; // no way to report an error.</span>
      }
<span class="line-modified">!     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified">!     fields-&gt;formatter.adoptInsteadAndCheckErrorCode(new LocalizedNumberFormatter(), status);</span>
<span class="line-modified">!     fields-&gt;properties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(*source.fields-&gt;properties), status);</span>
<span class="line-modified">!     fields-&gt;symbols.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(*source.fields-&gt;symbols), status);</span>
<span class="line-added">+     fields-&gt;exportedProperties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);</span>
<span class="line-added">+     // In order to simplify error handling logic in the various getters/setters/etc, we do not allow</span>
<span class="line-added">+     // any partially populated DecimalFormatFields object. We must have a fully complete fields object</span>
<span class="line-added">+     // or else we set it to nullptr.</span>
<span class="line-added">+     if (fields-&gt;formatter.isNull() || fields-&gt;properties.isNull() || fields-&gt;exportedProperties.isNull() || fields-&gt;symbols.isNull()) {</span>
<span class="line-added">+         delete fields;</span>
<span class="line-added">+         fields = nullptr;</span>
          return;
      }
<span class="line-modified">!     touch(status);</span>
  }
  
  DecimalFormat&amp; DecimalFormat::operator=(const DecimalFormat&amp; rhs) {
<span class="line-added">+     // guard against self-assignment</span>
<span class="line-added">+     if (this == &amp;rhs) {</span>
<span class="line-added">+         return *this;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Make sure both objects are valid.</span>
<span class="line-added">+     if (fields == nullptr || rhs.fields == nullptr) {</span>
<span class="line-added">+         return *this; // unfortunately, no way to report an error.</span>
<span class="line-added">+     }</span>
      *fields-&gt;properties = *rhs.fields-&gt;properties;
      fields-&gt;exportedProperties-&gt;clear();
<span class="line-modified">!     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified">!     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(new DecimalFormatSymbols(*rhs.fields-&gt;symbols), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         // We failed to allocate DecimalFormatSymbols, release fields and its members.</span>
<span class="line-added">+         // We must have a fully complete fields object, we cannot have partially populated members.</span>
<span class="line-added">+         delete fields;</span>
<span class="line-added">+         fields = nullptr;</span>
<span class="line-added">+         return *this;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
<span class="line-added">+     touch(status);</span>
<span class="line-added">+ </span>
      return *this;
  }
  
  DecimalFormat::~DecimalFormat() {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
<span class="line-added">+ </span>
      delete fields-&gt;atomicParser.exchange(nullptr);
      delete fields-&gt;atomicCurrencyParser.exchange(nullptr);
      delete fields;
  }
  
  Format* DecimalFormat::clone() const {
<span class="line-modified">!     // can only clone valid objects.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     LocalPointer&lt;DecimalFormat&gt; df(new DecimalFormat(*this));</span>
<span class="line-added">+     if (df.isValid() &amp;&amp; df-&gt;fields != nullptr) {</span>
<span class="line-added">+         return df.orphan();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return nullptr;</span>
  }
  
  UBool DecimalFormat::operator==(const Format&amp; other) const {
      auto* otherDF = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;other);
      if (otherDF == nullptr) {
          return false;
      }
<span class="line-added">+     // If either object is in an invalid state, prevent dereferencing nullptr below.</span>
<span class="line-added">+     // Additionally, invalid objects should not be considered equal to anything.</span>
<span class="line-added">+     if (fields == nullptr || otherDF-&gt;fields == nullptr) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
      return *fields-&gt;properties == *otherDF-&gt;fields-&gt;properties &amp;&amp; *fields-&gt;symbols == *otherDF-&gt;fields-&gt;symbols;
  }
  
  UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         appendTo.setToBogus();</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
      if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
          return appendTo;
      }
      UErrorCode localStatus = U_ZERO_ERROR;
      FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, localStatus);
      fieldPositionHelper(output, pos, appendTo.length(), localStatus);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable, localStatus);</span>
      return appendTo;
  }
  
  UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
                                       UErrorCode&amp; status) const {
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         appendTo.setToBogus();</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
      if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
          return appendTo;
      }
      FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
      fieldPositionHelper(output, pos, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable, status);</span>
      return appendTo;
  }
  
  UnicodeString&amp;
  DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
                        UErrorCode&amp; status) const {
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         appendTo.setToBogus();</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
      if (posIter == nullptr &amp;&amp; fastFormatDouble(number, appendTo)) {
          return appendTo;
      }
      FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
      fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable, status);</span>
      return appendTo;
  }
  
  UnicodeString&amp; DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
      return format(static_cast&lt;int64_t&gt; (number), appendTo, pos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 477,227 ***</span>
                        UErrorCode&amp; status) const {
      return format(static_cast&lt;int64_t&gt; (number), appendTo, posIter, status);
  }
  
  UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
      if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
          return appendTo;
      }
      UErrorCode localStatus = U_ZERO_ERROR;
      FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, localStatus);
      fieldPositionHelper(output, pos, appendTo.length(), localStatus);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable);</span>
      return appendTo;
  }
  
  UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
                                       UErrorCode&amp; status) const {
      if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
          return appendTo;
      }
      FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
      fieldPositionHelper(output, pos, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable);</span>
      return appendTo;
  }
  
  UnicodeString&amp;
  DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
                        UErrorCode&amp; status) const {
      if (posIter == nullptr &amp;&amp; fastFormatInt64(number, appendTo)) {
          return appendTo;
      }
      FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
      fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable);</span>
      return appendTo;
  }
  
  UnicodeString&amp;
  DecimalFormat::format(StringPiece number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
                        UErrorCode&amp; status) const {
      FormattedNumber output = fields-&gt;formatter-&gt;formatDecimal(number, status);
      fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable);</span>
      return appendTo;
  }
  
  UnicodeString&amp; DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo,
                                       FieldPositionIterator* posIter, UErrorCode&amp; status) const {
      FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
      fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable);</span>
      return appendTo;
  }
  
  UnicodeString&amp;
  DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
                        UErrorCode&amp; status) const {
      FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
      fieldPositionHelper(output, pos, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable);</span>
      return appendTo;
  }
  
  void DecimalFormat::parse(const UnicodeString&amp; text, Formattable&amp; output,
                            ParsePosition&amp; parsePosition) const {
      if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
          return;
      }
  
      ErrorCode status;
      ParsedNumber result;
      // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
      // parseCurrency method (backwards compatibility)
      int32_t startIndex = parsePosition.getIndex();
      const NumberParserImpl* parser = getParser(status);
<span class="line-modified">!     if (U_FAILURE(status)) { return; }</span>
      parser-&gt;parse(text, startIndex, true, result, status);
      // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
      if (result.success()) {
          parsePosition.setIndex(result.charEnd);
          result.populateFormattable(output, parser-&gt;getParseFlags());
      } else {
          parsePosition.setErrorIndex(startIndex + result.charEnd);
      }
  }
  
  CurrencyAmount* DecimalFormat::parseCurrency(const UnicodeString&amp; text, ParsePosition&amp; parsePosition) const {
      if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
          return nullptr;
      }
  
      ErrorCode status;
      ParsedNumber result;
      // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
      // parseCurrency method (backwards compatibility)
      int32_t startIndex = parsePosition.getIndex();
      const NumberParserImpl* parser = getCurrencyParser(status);
<span class="line-modified">!     if (U_FAILURE(status)) { return nullptr; }</span>
      parser-&gt;parse(text, startIndex, true, result, status);
      // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
      if (result.success()) {
          parsePosition.setIndex(result.charEnd);
          Formattable formattable;
          result.populateFormattable(formattable, parser-&gt;getParseFlags());
<span class="line-modified">!         return new CurrencyAmount(formattable, result.currencyCode, status);</span>
      } else {
          parsePosition.setErrorIndex(startIndex + result.charEnd);
          return nullptr;
      }
  }
  
  const DecimalFormatSymbols* DecimalFormat::getDecimalFormatSymbols(void) const {
      return fields-&gt;symbols.getAlias();
  }
  
  void DecimalFormat::adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt) {
      if (symbolsToAdopt == nullptr) {
          return; // do not allow caller to set fields-&gt;symbols to NULL
      }
<span class="line-modified">!     fields-&gt;symbols.adoptInstead(symbolsToAdopt);</span>
      touchNoError();
  }
  
  void DecimalFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols) {
<span class="line-modified">!     fields-&gt;symbols.adoptInstead(new DecimalFormatSymbols(symbols));</span>
      touchNoError();
  }
  
  const CurrencyPluralInfo* DecimalFormat::getCurrencyPluralInfo(void) const {
      return fields-&gt;properties-&gt;currencyPluralInfo.fPtr.getAlias();
  }
  
  void DecimalFormat::adoptCurrencyPluralInfo(CurrencyPluralInfo* toAdopt) {
<span class="line-modified">!     fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(toAdopt);</span>
      touchNoError();
  }
  
  void DecimalFormat::setCurrencyPluralInfo(const CurrencyPluralInfo&amp; info) {
      if (fields-&gt;properties-&gt;currencyPluralInfo.fPtr.isNull()) {
          fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(info.clone());
      } else {
          *fields-&gt;properties-&gt;currencyPluralInfo.fPtr = info; // copy-assignment operator
      }
      touchNoError();
  }
  
  UnicodeString&amp; DecimalFormat::getPositivePrefix(UnicodeString&amp; result) const {
<span class="line-modified">!     ErrorCode localStatus;</span>
<span class="line-modified">!     fields-&gt;formatter-&gt;getAffixImpl(true, false, result, localStatus);</span>
      return result;
  }
  
  void DecimalFormat::setPositivePrefix(const UnicodeString&amp; newValue) {
      if (newValue == fields-&gt;properties-&gt;positivePrefix) { return; }
      fields-&gt;properties-&gt;positivePrefix = newValue;
      touchNoError();
  }
  
  UnicodeString&amp; DecimalFormat::getNegativePrefix(UnicodeString&amp; result) const {
<span class="line-modified">!     ErrorCode localStatus;</span>
<span class="line-modified">!     fields-&gt;formatter-&gt;getAffixImpl(true, true, result, localStatus);</span>
      return result;
  }
  
  void DecimalFormat::setNegativePrefix(const UnicodeString&amp; newValue) {
      if (newValue == fields-&gt;properties-&gt;negativePrefix) { return; }
      fields-&gt;properties-&gt;negativePrefix = newValue;
      touchNoError();
  }
  
  UnicodeString&amp; DecimalFormat::getPositiveSuffix(UnicodeString&amp; result) const {
<span class="line-modified">!     ErrorCode localStatus;</span>
<span class="line-modified">!     fields-&gt;formatter-&gt;getAffixImpl(false, false, result, localStatus);</span>
      return result;
  }
  
  void DecimalFormat::setPositiveSuffix(const UnicodeString&amp; newValue) {
      if (newValue == fields-&gt;properties-&gt;positiveSuffix) { return; }
      fields-&gt;properties-&gt;positiveSuffix = newValue;
      touchNoError();
  }
  
  UnicodeString&amp; DecimalFormat::getNegativeSuffix(UnicodeString&amp; result) const {
<span class="line-modified">!     ErrorCode localStatus;</span>
<span class="line-modified">!     fields-&gt;formatter-&gt;getAffixImpl(false, true, result, localStatus);</span>
      return result;
  }
  
  void DecimalFormat::setNegativeSuffix(const UnicodeString&amp; newValue) {
      if (newValue == fields-&gt;properties-&gt;negativeSuffix) { return; }
      fields-&gt;properties-&gt;negativeSuffix = newValue;
      touchNoError();
  }
  
  UBool DecimalFormat::isSignAlwaysShown() const {
      return fields-&gt;properties-&gt;signAlwaysShown;
  }
  
  void DecimalFormat::setSignAlwaysShown(UBool value) {
      if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;signAlwaysShown) { return; }
      fields-&gt;properties-&gt;signAlwaysShown = value;
      touchNoError();
  }
  
  int32_t DecimalFormat::getMultiplier(void) const {
<span class="line-modified">!     if (fields-&gt;properties-&gt;multiplier != 1) {</span>
<span class="line-modified">!         return fields-&gt;properties-&gt;multiplier;</span>
<span class="line-modified">!     } else if (fields-&gt;properties-&gt;magnitudeMultiplier != 0) {</span>
<span class="line-modified">!         return static_cast&lt;int32_t&gt;(uprv_pow10(fields-&gt;properties-&gt;magnitudeMultiplier));</span>
      } else {
          return 1;
      }
  }
  
      if (multiplier == 0) {
          multiplier = 1;     // one being the benign default value for a multiplier.
      }
  
      // Try to convert to a magnitude multiplier first
<span class="line-new-header">--- 593,382 ---</span>
                        UErrorCode&amp; status) const {
      return format(static_cast&lt;int64_t&gt; (number), appendTo, posIter, status);
  }
  
  UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         appendTo.setToBogus();</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
      if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
          return appendTo;
      }
      UErrorCode localStatus = U_ZERO_ERROR;
      FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, localStatus);
      fieldPositionHelper(output, pos, appendTo.length(), localStatus);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable, localStatus);</span>
      return appendTo;
  }
  
  UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
                                       UErrorCode&amp; status) const {
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         appendTo.setToBogus();</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
      if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
          return appendTo;
      }
      FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
      fieldPositionHelper(output, pos, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable, status);</span>
      return appendTo;
  }
  
  UnicodeString&amp;
  DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
                        UErrorCode&amp; status) const {
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         appendTo.setToBogus();</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
      if (posIter == nullptr &amp;&amp; fastFormatInt64(number, appendTo)) {
          return appendTo;
      }
      FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
      fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable, status);</span>
      return appendTo;
  }
  
  UnicodeString&amp;
  DecimalFormat::format(StringPiece number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
                        UErrorCode&amp; status) const {
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         appendTo.setToBogus();</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
      FormattedNumber output = fields-&gt;formatter-&gt;formatDecimal(number, status);
      fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable, status);</span>
      return appendTo;
  }
  
  UnicodeString&amp; DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo,
                                       FieldPositionIterator* posIter, UErrorCode&amp; status) const {
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         appendTo.setToBogus();</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
      FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
      fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable, status);</span>
      return appendTo;
  }
  
  UnicodeString&amp;
  DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
                        UErrorCode&amp; status) const {
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         appendTo.setToBogus();</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
      FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
      fieldPositionHelper(output, pos, appendTo.length(), status);
      auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified">!     output.appendTo(appendable, status);</span>
      return appendTo;
  }
  
  void DecimalFormat::parse(const UnicodeString&amp; text, Formattable&amp; output,
                            ParsePosition&amp; parsePosition) const {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
<span class="line-added">+         if (parsePosition.getIndex() == text.length()) {</span>
<span class="line-added">+             // If there is nothing to parse, it is an error</span>
<span class="line-added">+             parsePosition.setErrorIndex(parsePosition.getIndex());</span>
<span class="line-added">+         }</span>
          return;
      }
  
      ErrorCode status;
      ParsedNumber result;
      // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
      // parseCurrency method (backwards compatibility)
      int32_t startIndex = parsePosition.getIndex();
      const NumberParserImpl* parser = getParser(status);
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return; // unfortunately no way to report back the error.</span>
<span class="line-added">+     }</span>
      parser-&gt;parse(text, startIndex, true, result, status);
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return; // unfortunately no way to report back the error.</span>
<span class="line-added">+     }</span>
      // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
      if (result.success()) {
          parsePosition.setIndex(result.charEnd);
          result.populateFormattable(output, parser-&gt;getParseFlags());
      } else {
          parsePosition.setErrorIndex(startIndex + result.charEnd);
      }
  }
  
  CurrencyAmount* DecimalFormat::parseCurrency(const UnicodeString&amp; text, ParsePosition&amp; parsePosition) const {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
          return nullptr;
      }
  
      ErrorCode status;
      ParsedNumber result;
      // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
      // parseCurrency method (backwards compatibility)
      int32_t startIndex = parsePosition.getIndex();
      const NumberParserImpl* parser = getCurrencyParser(status);
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      parser-&gt;parse(text, startIndex, true, result, status);
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
      if (result.success()) {
          parsePosition.setIndex(result.charEnd);
          Formattable formattable;
          result.populateFormattable(formattable, parser-&gt;getParseFlags());
<span class="line-modified">!         LocalPointer&lt;CurrencyAmount&gt; currencyAmount(</span>
<span class="line-added">+             new CurrencyAmount(formattable, result.currencyCode, status), status);</span>
<span class="line-added">+         if (U_FAILURE(status)) {</span>
<span class="line-added">+             return nullptr;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return currencyAmount.orphan();</span>
      } else {
          parsePosition.setErrorIndex(startIndex + result.charEnd);
          return nullptr;
      }
  }
  
  const DecimalFormatSymbols* DecimalFormat::getDecimalFormatSymbols(void) const {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      return fields-&gt;symbols.getAlias();
  }
  
  void DecimalFormat::adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt) {
      if (symbolsToAdopt == nullptr) {
          return; // do not allow caller to set fields-&gt;symbols to NULL
      }
<span class="line-modified">!     // we must take ownership of symbolsToAdopt, even in a failure case.</span>
<span class="line-added">+     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(symbolsToAdopt);</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
      touchNoError();
  }
  
  void DecimalFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols) {
<span class="line-modified">!     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added">+     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(new DecimalFormatSymbols(symbols), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         // We failed to allocate DecimalFormatSymbols, release fields and its members.</span>
<span class="line-added">+         // We must have a fully complete fields object, we cannot have partially populated members.</span>
<span class="line-added">+         delete fields;</span>
<span class="line-added">+         fields = nullptr;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
      touchNoError();
  }
  
  const CurrencyPluralInfo* DecimalFormat::getCurrencyPluralInfo(void) const {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;currencyPluralInfo.fPtr.getAlias();
  }
  
  void DecimalFormat::adoptCurrencyPluralInfo(CurrencyPluralInfo* toAdopt) {
<span class="line-modified">!     // TODO: should we guard against nullptr input, like in adoptDecimalFormatSymbols?</span>
<span class="line-added">+     // we must take ownership of toAdopt, even in a failure case.</span>
<span class="line-added">+     LocalPointer&lt;CurrencyPluralInfo&gt; cpi(toAdopt);</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(cpi.orphan());</span>
      touchNoError();
  }
  
  void DecimalFormat::setCurrencyPluralInfo(const CurrencyPluralInfo&amp; info) {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (fields-&gt;properties-&gt;currencyPluralInfo.fPtr.isNull()) {
<span class="line-added">+         // Note: clone() can fail with OOM error, but we have no way to report it. :(</span>
          fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(info.clone());
      } else {
          *fields-&gt;properties-&gt;currencyPluralInfo.fPtr = info; // copy-assignment operator
      }
      touchNoError();
  }
  
  UnicodeString&amp; DecimalFormat::getPositivePrefix(UnicodeString&amp; result) const {
<span class="line-modified">!     if (fields == nullptr) {</span>
<span class="line-modified">!         result.setToBogus();</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added">+     fields-&gt;formatter-&gt;getAffixImpl(true, false, result, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { result.setToBogus(); }</span>
      return result;
  }
  
  void DecimalFormat::setPositivePrefix(const UnicodeString&amp; newValue) {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (newValue == fields-&gt;properties-&gt;positivePrefix) { return; }
      fields-&gt;properties-&gt;positivePrefix = newValue;
      touchNoError();
  }
  
  UnicodeString&amp; DecimalFormat::getNegativePrefix(UnicodeString&amp; result) const {
<span class="line-modified">!     if (fields == nullptr) {</span>
<span class="line-modified">!         result.setToBogus();</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added">+     fields-&gt;formatter-&gt;getAffixImpl(true, true, result, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { result.setToBogus(); }</span>
      return result;
  }
  
  void DecimalFormat::setNegativePrefix(const UnicodeString&amp; newValue) {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (newValue == fields-&gt;properties-&gt;negativePrefix) { return; }
      fields-&gt;properties-&gt;negativePrefix = newValue;
      touchNoError();
  }
  
  UnicodeString&amp; DecimalFormat::getPositiveSuffix(UnicodeString&amp; result) const {
<span class="line-modified">!     if (fields == nullptr) {</span>
<span class="line-modified">!         result.setToBogus();</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added">+     fields-&gt;formatter-&gt;getAffixImpl(false, false, result, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { result.setToBogus(); }</span>
      return result;
  }
  
  void DecimalFormat::setPositiveSuffix(const UnicodeString&amp; newValue) {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (newValue == fields-&gt;properties-&gt;positiveSuffix) { return; }
      fields-&gt;properties-&gt;positiveSuffix = newValue;
      touchNoError();
  }
  
  UnicodeString&amp; DecimalFormat::getNegativeSuffix(UnicodeString&amp; result) const {
<span class="line-modified">!     if (fields == nullptr) {</span>
<span class="line-modified">!         result.setToBogus();</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added">+     fields-&gt;formatter-&gt;getAffixImpl(false, true, result, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) { result.setToBogus(); }</span>
      return result;
  }
  
  void DecimalFormat::setNegativeSuffix(const UnicodeString&amp; newValue) {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (newValue == fields-&gt;properties-&gt;negativeSuffix) { return; }
      fields-&gt;properties-&gt;negativeSuffix = newValue;
      touchNoError();
  }
  
  UBool DecimalFormat::isSignAlwaysShown() const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().signAlwaysShown;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;signAlwaysShown;
  }
  
  void DecimalFormat::setSignAlwaysShown(UBool value) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;signAlwaysShown) { return; }
      fields-&gt;properties-&gt;signAlwaysShown = value;
      touchNoError();
  }
  
  int32_t DecimalFormat::getMultiplier(void) const {
<span class="line-modified">!     const DecimalFormatProperties *dfp;</span>
<span class="line-modified">!     // Not much we can do to report an error.</span>
<span class="line-modified">!     if (fields == nullptr) {</span>
<span class="line-modified">!         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         dfp = &amp;(DecimalFormatProperties::getDefault());</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         dfp = fields-&gt;properties.getAlias();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (dfp-&gt;multiplier != 1) {</span>
<span class="line-added">+         return dfp-&gt;multiplier;</span>
<span class="line-added">+     } else if (dfp-&gt;magnitudeMultiplier != 0) {</span>
<span class="line-added">+         return static_cast&lt;int32_t&gt;(uprv_pow10(dfp-&gt;magnitudeMultiplier));</span>
      } else {
          return 1;
      }
  }
  
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+          return;</span>
<span class="line-added">+     }</span>
      if (multiplier == 0) {
          multiplier = 1;     // one being the benign default value for a multiplier.
      }
  
      // Try to convert to a magnitude multiplier first
</pre>
<hr />
<pre>
<span class="line-old-header">*** 721,96 ***</span>
      }
      touchNoError();
  }
  
  int32_t DecimalFormat::getMultiplierScale() const {
      return fields-&gt;properties-&gt;multiplierScale;
  }
  
  void DecimalFormat::setMultiplierScale(int32_t newValue) {
      if (newValue == fields-&gt;properties-&gt;multiplierScale) { return; }
      fields-&gt;properties-&gt;multiplierScale = newValue;
      touchNoError();
  }
  
  double DecimalFormat::getRoundingIncrement(void) const {
      return fields-&gt;exportedProperties-&gt;roundingIncrement;
  }
  
  void DecimalFormat::setRoundingIncrement(double newValue) {
      if (newValue == fields-&gt;properties-&gt;roundingIncrement) { return; }
      fields-&gt;properties-&gt;roundingIncrement = newValue;
      touchNoError();
  }
  
  ERoundingMode DecimalFormat::getRoundingMode(void) const {
      // UNumberFormatRoundingMode and ERoundingMode have the same values.
      return static_cast&lt;ERoundingMode&gt;(fields-&gt;exportedProperties-&gt;roundingMode.getNoError());
  }
  
  void DecimalFormat::setRoundingMode(ERoundingMode roundingMode) {
      auto uRoundingMode = static_cast&lt;UNumberFormatRoundingMode&gt;(roundingMode);
      if (!fields-&gt;properties-&gt;roundingMode.isNull() &amp;&amp; uRoundingMode == fields-&gt;properties-&gt;roundingMode.getNoError()) {
          return;
      }
      NumberFormat::setMaximumIntegerDigits(roundingMode); // to set field for compatibility
      fields-&gt;properties-&gt;roundingMode = uRoundingMode;
      touchNoError();
  }
  
  int32_t DecimalFormat::getFormatWidth(void) const {
      return fields-&gt;properties-&gt;formatWidth;
  }
  
  void DecimalFormat::setFormatWidth(int32_t width) {
      if (width == fields-&gt;properties-&gt;formatWidth) { return; }
      fields-&gt;properties-&gt;formatWidth = width;
      touchNoError();
  }
  
  UnicodeString DecimalFormat::getPadCharacterString() const {
<span class="line-modified">!     if (fields-&gt;properties-&gt;padString.isBogus()) {</span>
          // Readonly-alias the static string kFallbackPaddingString
          return {TRUE, kFallbackPaddingString, -1};
      } else {
          return fields-&gt;properties-&gt;padString;
      }
  }
  
  void DecimalFormat::setPadCharacter(const UnicodeString&amp; padChar) {
      if (padChar == fields-&gt;properties-&gt;padString) { return; }
      if (padChar.length() &gt; 0) {
          fields-&gt;properties-&gt;padString = UnicodeString(padChar.char32At(0));
      } else {
          fields-&gt;properties-&gt;padString.setToBogus();
      }
      touchNoError();
  }
  
  EPadPosition DecimalFormat::getPadPosition(void) const {
<span class="line-modified">!     if (fields-&gt;properties-&gt;padPosition.isNull()) {</span>
          return EPadPosition::kPadBeforePrefix;
      } else {
          // UNumberFormatPadPosition and EPadPosition have the same values.
          return static_cast&lt;EPadPosition&gt;(fields-&gt;properties-&gt;padPosition.getNoError());
      }
  }
  
  void DecimalFormat::setPadPosition(EPadPosition padPos) {
      auto uPadPos = static_cast&lt;UNumberFormatPadPosition&gt;(padPos);
      if (!fields-&gt;properties-&gt;padPosition.isNull() &amp;&amp; uPadPos == fields-&gt;properties-&gt;padPosition.getNoError()) {
          return;
      }
      fields-&gt;properties-&gt;padPosition = uPadPos;
      touchNoError();
  }
  
  UBool DecimalFormat::isScientificNotation(void) const {
<span class="line-modified">!     return fields-&gt;properties-&gt;minimumExponentDigits != -1;</span>
  }
  
  void DecimalFormat::setScientificNotation(UBool useScientific) {
      int32_t minExp = useScientific ? 1 : -1;
      if (fields-&gt;properties-&gt;minimumExponentDigits == minExp) { return; }
      if (useScientific) {
          fields-&gt;properties-&gt;minimumExponentDigits = 1;
      } else {
<span class="line-new-header">--- 992,128 ---</span>
      }
      touchNoError();
  }
  
  int32_t DecimalFormat::getMultiplierScale() const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().multiplierScale;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;multiplierScale;
  }
  
  void DecimalFormat::setMultiplierScale(int32_t newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (newValue == fields-&gt;properties-&gt;multiplierScale) { return; }
      fields-&gt;properties-&gt;multiplierScale = newValue;
      touchNoError();
  }
  
  double DecimalFormat::getRoundingIncrement(void) const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().roundingIncrement;</span>
<span class="line-added">+     }</span>
      return fields-&gt;exportedProperties-&gt;roundingIncrement;
  }
  
  void DecimalFormat::setRoundingIncrement(double newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (newValue == fields-&gt;properties-&gt;roundingIncrement) { return; }
      fields-&gt;properties-&gt;roundingIncrement = newValue;
      touchNoError();
  }
  
  ERoundingMode DecimalFormat::getRoundingMode(void) const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return static_cast&lt;ERoundingMode&gt;(DecimalFormatProperties::getDefault().roundingMode.getNoError());</span>
<span class="line-added">+     }</span>
      // UNumberFormatRoundingMode and ERoundingMode have the same values.
      return static_cast&lt;ERoundingMode&gt;(fields-&gt;exportedProperties-&gt;roundingMode.getNoError());
  }
  
  void DecimalFormat::setRoundingMode(ERoundingMode roundingMode) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      auto uRoundingMode = static_cast&lt;UNumberFormatRoundingMode&gt;(roundingMode);
      if (!fields-&gt;properties-&gt;roundingMode.isNull() &amp;&amp; uRoundingMode == fields-&gt;properties-&gt;roundingMode.getNoError()) {
          return;
      }
      NumberFormat::setMaximumIntegerDigits(roundingMode); // to set field for compatibility
      fields-&gt;properties-&gt;roundingMode = uRoundingMode;
      touchNoError();
  }
  
  int32_t DecimalFormat::getFormatWidth(void) const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().formatWidth;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;formatWidth;
  }
  
  void DecimalFormat::setFormatWidth(int32_t width) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (width == fields-&gt;properties-&gt;formatWidth) { return; }
      fields-&gt;properties-&gt;formatWidth = width;
      touchNoError();
  }
  
  UnicodeString DecimalFormat::getPadCharacterString() const {
<span class="line-modified">!     if (fields == nullptr || fields-&gt;properties-&gt;padString.isBogus()) {</span>
          // Readonly-alias the static string kFallbackPaddingString
          return {TRUE, kFallbackPaddingString, -1};
      } else {
          return fields-&gt;properties-&gt;padString;
      }
  }
  
  void DecimalFormat::setPadCharacter(const UnicodeString&amp; padChar) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (padChar == fields-&gt;properties-&gt;padString) { return; }
      if (padChar.length() &gt; 0) {
          fields-&gt;properties-&gt;padString = UnicodeString(padChar.char32At(0));
      } else {
          fields-&gt;properties-&gt;padString.setToBogus();
      }
      touchNoError();
  }
  
  EPadPosition DecimalFormat::getPadPosition(void) const {
<span class="line-modified">!     if (fields == nullptr || fields-&gt;properties-&gt;padPosition.isNull()) {</span>
          return EPadPosition::kPadBeforePrefix;
      } else {
          // UNumberFormatPadPosition and EPadPosition have the same values.
          return static_cast&lt;EPadPosition&gt;(fields-&gt;properties-&gt;padPosition.getNoError());
      }
  }
  
  void DecimalFormat::setPadPosition(EPadPosition padPos) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      auto uPadPos = static_cast&lt;UNumberFormatPadPosition&gt;(padPos);
      if (!fields-&gt;properties-&gt;padPosition.isNull() &amp;&amp; uPadPos == fields-&gt;properties-&gt;padPosition.getNoError()) {
          return;
      }
      fields-&gt;properties-&gt;padPosition = uPadPos;
      touchNoError();
  }
  
  UBool DecimalFormat::isScientificNotation(void) const {
<span class="line-modified">!     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return (DecimalFormatProperties::getDefault().minimumExponentDigits != -1);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return (fields-&gt;properties-&gt;minimumExponentDigits != -1);</span>
  }
  
  void DecimalFormat::setScientificNotation(UBool useScientific) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      int32_t minExp = useScientific ? 1 : -1;
      if (fields-&gt;properties-&gt;minimumExponentDigits == minExp) { return; }
      if (useScientific) {
          fields-&gt;properties-&gt;minimumExponentDigits = 1;
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 818,139 ***</span>
      }
      touchNoError();
  }
  
  int8_t DecimalFormat::getMinimumExponentDigits(void) const {
      return static_cast&lt;int8_t&gt;(fields-&gt;properties-&gt;minimumExponentDigits);
  }
  
  void DecimalFormat::setMinimumExponentDigits(int8_t minExpDig) {
      if (minExpDig == fields-&gt;properties-&gt;minimumExponentDigits) { return; }
      fields-&gt;properties-&gt;minimumExponentDigits = minExpDig;
      touchNoError();
  }
  
  UBool DecimalFormat::isExponentSignAlwaysShown(void) const {
      return fields-&gt;properties-&gt;exponentSignAlwaysShown;
  }
  
  void DecimalFormat::setExponentSignAlwaysShown(UBool expSignAlways) {
      if (UBOOL_TO_BOOL(expSignAlways) == fields-&gt;properties-&gt;exponentSignAlwaysShown) { return; }
      fields-&gt;properties-&gt;exponentSignAlwaysShown = expSignAlways;
      touchNoError();
  }
  
  int32_t DecimalFormat::getGroupingSize(void) const {
<span class="line-modified">!     if (fields-&gt;properties-&gt;groupingSize &lt; 0) {</span>
          return 0;
      }
<span class="line-modified">!     return fields-&gt;properties-&gt;groupingSize;</span>
  }
  
  void DecimalFormat::setGroupingSize(int32_t newValue) {
      if (newValue == fields-&gt;properties-&gt;groupingSize) { return; }
      fields-&gt;properties-&gt;groupingSize = newValue;
      touchNoError();
  }
  
  int32_t DecimalFormat::getSecondaryGroupingSize(void) const {
<span class="line-modified">!     int grouping2 = fields-&gt;properties-&gt;secondaryGroupingSize;</span>
      if (grouping2 &lt; 0) {
          return 0;
      }
      return grouping2;
  }
  
  void DecimalFormat::setSecondaryGroupingSize(int32_t newValue) {
      if (newValue == fields-&gt;properties-&gt;secondaryGroupingSize) { return; }
      fields-&gt;properties-&gt;secondaryGroupingSize = newValue;
      touchNoError();
  }
  
  int32_t DecimalFormat::getMinimumGroupingDigits() const {
      return fields-&gt;properties-&gt;minimumGroupingDigits;
  }
  
  void DecimalFormat::setMinimumGroupingDigits(int32_t newValue) {
      if (newValue == fields-&gt;properties-&gt;minimumGroupingDigits) { return; }
      fields-&gt;properties-&gt;minimumGroupingDigits = newValue;
      touchNoError();
  }
  
  UBool DecimalFormat::isDecimalSeparatorAlwaysShown(void) const {
      return fields-&gt;properties-&gt;decimalSeparatorAlwaysShown;
  }
  
  void DecimalFormat::setDecimalSeparatorAlwaysShown(UBool newValue) {
      if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalSeparatorAlwaysShown) { return; }
      fields-&gt;properties-&gt;decimalSeparatorAlwaysShown = newValue;
      touchNoError();
  }
  
  UBool DecimalFormat::isDecimalPatternMatchRequired(void) const {
      return fields-&gt;properties-&gt;decimalPatternMatchRequired;
  }
  
  void DecimalFormat::setDecimalPatternMatchRequired(UBool newValue) {
      if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalPatternMatchRequired) { return; }
      fields-&gt;properties-&gt;decimalPatternMatchRequired = newValue;
      touchNoError();
  }
  
  UBool DecimalFormat::isParseNoExponent() const {
      return fields-&gt;properties-&gt;parseNoExponent;
  }
  
  void DecimalFormat::setParseNoExponent(UBool value) {
      if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseNoExponent) { return; }
      fields-&gt;properties-&gt;parseNoExponent = value;
      touchNoError();
  }
  
  UBool DecimalFormat::isParseCaseSensitive() const {
      return fields-&gt;properties-&gt;parseCaseSensitive;
  }
  
  void DecimalFormat::setParseCaseSensitive(UBool value) {
      if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseCaseSensitive) { return; }
      fields-&gt;properties-&gt;parseCaseSensitive = value;
      touchNoError();
  }
  
  UBool DecimalFormat::isFormatFailIfMoreThanMaxDigits() const {
      return fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits;
  }
  
  void DecimalFormat::setFormatFailIfMoreThanMaxDigits(UBool value) {
      if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits) { return; }
      fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits = value;
      touchNoError();
  }
  
  UnicodeString&amp; DecimalFormat::toPattern(UnicodeString&amp; result) const {
      // Pull some properties from exportedProperties and others from properties
      // to keep affix patterns intact.  In particular, pull rounding properties
      // so that CurrencyUsage is reflected properly.
      // TODO: Consider putting this logic in number_patternstring.cpp instead.
      ErrorCode localStatus;
      DecimalFormatProperties tprops(*fields-&gt;properties);
<span class="line-modified">!     bool useCurrency = ((!tprops.currency.isNull()) || !tprops.currencyPluralInfo.fPtr.isNull() ||</span>
<span class="line-modified">!                         !tprops.currencyUsage.isNull() || AffixUtils::hasCurrencySymbols(</span>
<span class="line-modified">!             tprops.positivePrefixPattern, localStatus) || AffixUtils::hasCurrencySymbols(</span>
<span class="line-modified">!             tprops.positiveSuffixPattern, localStatus) || AffixUtils::hasCurrencySymbols(</span>
<span class="line-modified">!             tprops.negativePrefixPattern, localStatus) || AffixUtils::hasCurrencySymbols(</span>
<span class="line-modified">!             tprops.negativeSuffixPattern, localStatus));</span>
      if (useCurrency) {
          tprops.minimumFractionDigits = fields-&gt;exportedProperties-&gt;minimumFractionDigits;
          tprops.maximumFractionDigits = fields-&gt;exportedProperties-&gt;maximumFractionDigits;
          tprops.roundingIncrement = fields-&gt;exportedProperties-&gt;roundingIncrement;
      }
      ErrorCode localStatus;
      result = toPattern(result);
      result = PatternStringUtils::convertLocalized(result, *fields-&gt;symbols, true, localStatus);
      return result;
  }
<span class="line-new-header">--- 1121,216 ---</span>
      }
      touchNoError();
  }
  
  int8_t DecimalFormat::getMinimumExponentDigits(void) const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return static_cast&lt;int8_t&gt;(DecimalFormatProperties::getDefault().minimumExponentDigits);</span>
<span class="line-added">+     }</span>
      return static_cast&lt;int8_t&gt;(fields-&gt;properties-&gt;minimumExponentDigits);
  }
  
  void DecimalFormat::setMinimumExponentDigits(int8_t minExpDig) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (minExpDig == fields-&gt;properties-&gt;minimumExponentDigits) { return; }
      fields-&gt;properties-&gt;minimumExponentDigits = minExpDig;
      touchNoError();
  }
  
  UBool DecimalFormat::isExponentSignAlwaysShown(void) const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().exponentSignAlwaysShown;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;exponentSignAlwaysShown;
  }
  
  void DecimalFormat::setExponentSignAlwaysShown(UBool expSignAlways) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (UBOOL_TO_BOOL(expSignAlways) == fields-&gt;properties-&gt;exponentSignAlwaysShown) { return; }
      fields-&gt;properties-&gt;exponentSignAlwaysShown = expSignAlways;
      touchNoError();
  }
  
  int32_t DecimalFormat::getGroupingSize(void) const {
<span class="line-modified">!     int32_t groupingSize;</span>
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         groupingSize = DecimalFormatProperties::getDefault().groupingSize;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         groupingSize = fields-&gt;properties-&gt;groupingSize;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (groupingSize &lt; 0) {</span>
          return 0;
      }
<span class="line-modified">!     return groupingSize;</span>
  }
  
  void DecimalFormat::setGroupingSize(int32_t newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (newValue == fields-&gt;properties-&gt;groupingSize) { return; }
      fields-&gt;properties-&gt;groupingSize = newValue;
      touchNoError();
  }
  
  int32_t DecimalFormat::getSecondaryGroupingSize(void) const {
<span class="line-modified">!     int32_t grouping2;</span>
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         grouping2 = DecimalFormatProperties::getDefault().secondaryGroupingSize;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         grouping2 = fields-&gt;properties-&gt;secondaryGroupingSize;</span>
<span class="line-added">+     }</span>
      if (grouping2 &lt; 0) {
          return 0;
      }
      return grouping2;
  }
  
  void DecimalFormat::setSecondaryGroupingSize(int32_t newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (newValue == fields-&gt;properties-&gt;secondaryGroupingSize) { return; }
      fields-&gt;properties-&gt;secondaryGroupingSize = newValue;
      touchNoError();
  }
  
  int32_t DecimalFormat::getMinimumGroupingDigits() const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().minimumGroupingDigits;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;minimumGroupingDigits;
  }
  
  void DecimalFormat::setMinimumGroupingDigits(int32_t newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (newValue == fields-&gt;properties-&gt;minimumGroupingDigits) { return; }
      fields-&gt;properties-&gt;minimumGroupingDigits = newValue;
      touchNoError();
  }
  
  UBool DecimalFormat::isDecimalSeparatorAlwaysShown(void) const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().decimalSeparatorAlwaysShown;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;decimalSeparatorAlwaysShown;
  }
  
  void DecimalFormat::setDecimalSeparatorAlwaysShown(UBool newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalSeparatorAlwaysShown) { return; }
      fields-&gt;properties-&gt;decimalSeparatorAlwaysShown = newValue;
      touchNoError();
  }
  
  UBool DecimalFormat::isDecimalPatternMatchRequired(void) const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().decimalPatternMatchRequired;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;decimalPatternMatchRequired;
  }
  
  void DecimalFormat::setDecimalPatternMatchRequired(UBool newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalPatternMatchRequired) { return; }
      fields-&gt;properties-&gt;decimalPatternMatchRequired = newValue;
      touchNoError();
  }
  
  UBool DecimalFormat::isParseNoExponent() const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().parseNoExponent;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;parseNoExponent;
  }
  
  void DecimalFormat::setParseNoExponent(UBool value) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseNoExponent) { return; }
      fields-&gt;properties-&gt;parseNoExponent = value;
      touchNoError();
  }
  
  UBool DecimalFormat::isParseCaseSensitive() const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().parseCaseSensitive;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;parseCaseSensitive;
  }
  
  void DecimalFormat::setParseCaseSensitive(UBool value) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseCaseSensitive) { return; }
      fields-&gt;properties-&gt;parseCaseSensitive = value;
      touchNoError();
  }
  
  UBool DecimalFormat::isFormatFailIfMoreThanMaxDigits() const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().formatFailIfMoreThanMaxDigits;</span>
<span class="line-added">+     }</span>
      return fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits;
  }
  
  void DecimalFormat::setFormatFailIfMoreThanMaxDigits(UBool value) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits) { return; }
      fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits = value;
      touchNoError();
  }
  
  UnicodeString&amp; DecimalFormat::toPattern(UnicodeString&amp; result) const {
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         result.setToBogus();</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
      // Pull some properties from exportedProperties and others from properties
      // to keep affix patterns intact.  In particular, pull rounding properties
      // so that CurrencyUsage is reflected properly.
      // TODO: Consider putting this logic in number_patternstring.cpp instead.
      ErrorCode localStatus;
      DecimalFormatProperties tprops(*fields-&gt;properties);
<span class="line-modified">!     bool useCurrency = (</span>
<span class="line-modified">!         !tprops.currency.isNull() ||</span>
<span class="line-modified">!         !tprops.currencyPluralInfo.fPtr.isNull() ||</span>
<span class="line-modified">!         !tprops.currencyUsage.isNull() ||</span>
<span class="line-modified">!         AffixUtils::hasCurrencySymbols(tprops.positivePrefixPattern, localStatus) ||</span>
<span class="line-modified">!         AffixUtils::hasCurrencySymbols(tprops.positiveSuffixPattern, localStatus) ||</span>
<span class="line-added">+         AffixUtils::hasCurrencySymbols(tprops.negativePrefixPattern, localStatus) ||</span>
<span class="line-added">+         AffixUtils::hasCurrencySymbols(tprops.negativeSuffixPattern, localStatus));</span>
      if (useCurrency) {
          tprops.minimumFractionDigits = fields-&gt;exportedProperties-&gt;minimumFractionDigits;
          tprops.maximumFractionDigits = fields-&gt;exportedProperties-&gt;maximumFractionDigits;
          tprops.roundingIncrement = fields-&gt;exportedProperties-&gt;roundingIncrement;
      }
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         result.setToBogus();</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
      ErrorCode localStatus;
      result = toPattern(result);
      result = PatternStringUtils::convertLocalized(result, *fields-&gt;symbols, true, localStatus);
      return result;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 959,10 ***</span>
<span class="line-new-header">--- 1339,17 ---</span>
      // TODO: What is parseError for?
      applyPattern(pattern, status);
  }
  
  void DecimalFormat::applyPattern(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
<span class="line-added">+     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      setPropertiesFromPattern(pattern, IGNORE_ROUNDING_NEVER, status);
      touch(status);
  }
  
  void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UParseError&amp;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 970,18 ***</span>
      // TODO: What is parseError for?
      applyLocalizedPattern(localizedPattern, status);
  }
  
  void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UErrorCode&amp; status) {
<span class="line-modified">!     if (U_SUCCESS(status)) {</span>
<span class="line-modified">!         UnicodeString pattern = PatternStringUtils::convertLocalized(</span>
<span class="line-modified">!                 localizedPattern, *fields-&gt;symbols, false, status);</span>
<span class="line-modified">!         applyPattern(pattern, status);</span>
      }
  }
  
  void DecimalFormat::setMaximumIntegerDigits(int32_t newValue) {
      if (newValue == fields-&gt;properties-&gt;maximumIntegerDigits) { return; }
      // For backwards compatibility, conflicting min/max need to keep the most recent setting.
      int32_t min = fields-&gt;properties-&gt;minimumIntegerDigits;
      if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
          fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
<span class="line-new-header">--- 1357,24 ---</span>
      // TODO: What is parseError for?
      applyLocalizedPattern(localizedPattern, status);
  }
  
  void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UErrorCode&amp; status) {
<span class="line-modified">!     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-modified">!     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">!     if (fields == nullptr) {</span>
<span class="line-modified">!         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return;</span>
      }
<span class="line-added">+     UnicodeString pattern = PatternStringUtils::convertLocalized(</span>
<span class="line-added">+             localizedPattern, *fields-&gt;symbols, false, status);</span>
<span class="line-added">+     applyPattern(pattern, status);</span>
  }
  
  void DecimalFormat::setMaximumIntegerDigits(int32_t newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (newValue == fields-&gt;properties-&gt;maximumIntegerDigits) { return; }
      // For backwards compatibility, conflicting min/max need to keep the most recent setting.
      int32_t min = fields-&gt;properties-&gt;minimumIntegerDigits;
      if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
          fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 989,10 ***</span>
<span class="line-new-header">--- 1382,11 ---</span>
      fields-&gt;properties-&gt;maximumIntegerDigits = newValue;
      touchNoError();
  }
  
  void DecimalFormat::setMinimumIntegerDigits(int32_t newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (newValue == fields-&gt;properties-&gt;minimumIntegerDigits) { return; }
      // For backwards compatibility, conflicting min/max need to keep the most recent setting.
      int32_t max = fields-&gt;properties-&gt;maximumIntegerDigits;
      if (max &gt;= 0 &amp;&amp; max &lt; newValue) {
          fields-&gt;properties-&gt;maximumIntegerDigits = newValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1000,10 ***</span>
<span class="line-new-header">--- 1394,11 ---</span>
      fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
      touchNoError();
  }
  
  void DecimalFormat::setMaximumFractionDigits(int32_t newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (newValue == fields-&gt;properties-&gt;maximumFractionDigits) { return; }
      // For backwards compatibility, conflicting min/max need to keep the most recent setting.
      int32_t min = fields-&gt;properties-&gt;minimumFractionDigits;
      if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
          fields-&gt;properties-&gt;minimumFractionDigits = newValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1011,10 ***</span>
<span class="line-new-header">--- 1406,11 ---</span>
      fields-&gt;properties-&gt;maximumFractionDigits = newValue;
      touchNoError();
  }
  
  void DecimalFormat::setMinimumFractionDigits(int32_t newValue) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (newValue == fields-&gt;properties-&gt;minimumFractionDigits) { return; }
      // For backwards compatibility, conflicting min/max need to keep the most recent setting.
      int32_t max = fields-&gt;properties-&gt;maximumFractionDigits;
      if (max &gt;= 0 &amp;&amp; max &lt; newValue) {
          fields-&gt;properties-&gt;maximumFractionDigits = newValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1022,55 ***</span>
      fields-&gt;properties-&gt;minimumFractionDigits = newValue;
      touchNoError();
  }
  
  int32_t DecimalFormat::getMinimumSignificantDigits() const {
      return fields-&gt;exportedProperties-&gt;minimumSignificantDigits;
  }
  
  int32_t DecimalFormat::getMaximumSignificantDigits() const {
      return fields-&gt;exportedProperties-&gt;maximumSignificantDigits;
  }
  
  void DecimalFormat::setMinimumSignificantDigits(int32_t value) {
      if (value == fields-&gt;properties-&gt;minimumSignificantDigits) { return; }
      int32_t max = fields-&gt;properties-&gt;maximumSignificantDigits;
      if (max &gt;= 0 &amp;&amp; max &lt; value) {
          fields-&gt;properties-&gt;maximumSignificantDigits = value;
      }
      fields-&gt;properties-&gt;minimumSignificantDigits = value;
      touchNoError();
  }
  
  void DecimalFormat::setMaximumSignificantDigits(int32_t value) {
      if (value == fields-&gt;properties-&gt;maximumSignificantDigits) { return; }
      int32_t min = fields-&gt;properties-&gt;minimumSignificantDigits;
      if (min &gt;= 0 &amp;&amp; min &gt; value) {
          fields-&gt;properties-&gt;minimumSignificantDigits = value;
      }
      fields-&gt;properties-&gt;maximumSignificantDigits = value;
      touchNoError();
  }
  
  UBool DecimalFormat::areSignificantDigitsUsed() const {
<span class="line-modified">!     return fields-&gt;properties-&gt;minimumSignificantDigits != -1 || fields-&gt;properties-&gt;maximumSignificantDigits != -1;</span>
  }
  
  void DecimalFormat::setSignificantDigitsUsed(UBool useSignificantDigits) {
      // These are the default values from the old implementation.
      int32_t minSig = useSignificantDigits ? 1 : -1;
      int32_t maxSig = useSignificantDigits ? 6 : -1;
<span class="line-removed">-     if (fields-&gt;properties-&gt;minimumSignificantDigits == minSig &amp;&amp;</span>
<span class="line-removed">-         fields-&gt;properties-&gt;maximumSignificantDigits == maxSig) {</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
      fields-&gt;properties-&gt;minimumSignificantDigits = minSig;
      fields-&gt;properties-&gt;maximumSignificantDigits = maxSig;
      touchNoError();
  }
  
      CurrencyUnit currencyUnit(theCurrency, ec);
      if (U_FAILURE(ec)) { return; }
      if (!fields-&gt;properties-&gt;currency.isNull() &amp;&amp; fields-&gt;properties-&gt;currency.getNoError() == currencyUnit) {
          return;
      }
<span class="line-new-header">--- 1418,91 ---</span>
      fields-&gt;properties-&gt;minimumFractionDigits = newValue;
      touchNoError();
  }
  
  int32_t DecimalFormat::getMinimumSignificantDigits() const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().minimumSignificantDigits;</span>
<span class="line-added">+     }</span>
      return fields-&gt;exportedProperties-&gt;minimumSignificantDigits;
  }
  
  int32_t DecimalFormat::getMaximumSignificantDigits() const {
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         return DecimalFormatProperties::getDefault().maximumSignificantDigits;</span>
<span class="line-added">+     }</span>
      return fields-&gt;exportedProperties-&gt;maximumSignificantDigits;
  }
  
  void DecimalFormat::setMinimumSignificantDigits(int32_t value) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (value == fields-&gt;properties-&gt;minimumSignificantDigits) { return; }
      int32_t max = fields-&gt;properties-&gt;maximumSignificantDigits;
      if (max &gt;= 0 &amp;&amp; max &lt; value) {
          fields-&gt;properties-&gt;maximumSignificantDigits = value;
      }
      fields-&gt;properties-&gt;minimumSignificantDigits = value;
      touchNoError();
  }
  
  void DecimalFormat::setMaximumSignificantDigits(int32_t value) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
      if (value == fields-&gt;properties-&gt;maximumSignificantDigits) { return; }
      int32_t min = fields-&gt;properties-&gt;minimumSignificantDigits;
      if (min &gt;= 0 &amp;&amp; min &gt; value) {
          fields-&gt;properties-&gt;minimumSignificantDigits = value;
      }
      fields-&gt;properties-&gt;maximumSignificantDigits = value;
      touchNoError();
  }
  
  UBool DecimalFormat::areSignificantDigitsUsed() const {
<span class="line-modified">!     const DecimalFormatProperties* dfp;</span>
<span class="line-added">+     // Not much we can do to report an error.</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">+         dfp = &amp;(DecimalFormatProperties::getDefault());</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         dfp = fields-&gt;properties.getAlias();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return dfp-&gt;minimumSignificantDigits != -1 || dfp-&gt;maximumSignificantDigits != -1;</span>
  }
  
  void DecimalFormat::setSignificantDigitsUsed(UBool useSignificantDigits) {
<span class="line-added">+     if (fields == nullptr) { return; }</span>
<span class="line-added">+ </span>
      // These are the default values from the old implementation.
<span class="line-added">+     if (useSignificantDigits) {</span>
<span class="line-added">+         if (fields-&gt;properties-&gt;minimumSignificantDigits != -1 ||</span>
<span class="line-added">+             fields-&gt;properties-&gt;maximumSignificantDigits != -1) {</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         if (fields-&gt;properties-&gt;minimumSignificantDigits == -1 &amp;&amp;</span>
<span class="line-added">+             fields-&gt;properties-&gt;maximumSignificantDigits == -1) {</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
      int32_t minSig = useSignificantDigits ? 1 : -1;
      int32_t maxSig = useSignificantDigits ? 6 : -1;
      fields-&gt;properties-&gt;minimumSignificantDigits = minSig;
      fields-&gt;properties-&gt;maximumSignificantDigits = maxSig;
      touchNoError();
  }
  
<span class="line-added">+     // don&#39;t overwrite ec if it&#39;s already a failure.</span>
<span class="line-added">+     if (U_FAILURE(ec)) { return; }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         ec = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      CurrencyUnit currencyUnit(theCurrency, ec);
      if (U_FAILURE(ec)) { return; }
      if (!fields-&gt;properties-&gt;currency.isNull() &amp;&amp; fields-&gt;properties-&gt;currency.getNoError() == currencyUnit) {
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1084,11 ***</span>
      ErrorCode localStatus;
      setCurrency(theCurrency, localStatus);
  }
  
  void DecimalFormat::setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec) {
<span class="line-modified">!     if (U_FAILURE(*ec)) {</span>
          return;
      }
      if (!fields-&gt;properties-&gt;currencyUsage.isNull() &amp;&amp; newUsage == fields-&gt;properties-&gt;currencyUsage.getNoError()) {
          return;
      }
<span class="line-new-header">--- 1516,15 ---</span>
      ErrorCode localStatus;
      setCurrency(theCurrency, localStatus);
  }
  
  void DecimalFormat::setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec) {
<span class="line-modified">!     // don&#39;t overwrite ec if it&#39;s already a failure.</span>
<span class="line-added">+     if (U_FAILURE(*ec)) { return; }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         *ec = U_MEMORY_ALLOCATION_ERROR;</span>
          return;
      }
      if (!fields-&gt;properties-&gt;currencyUsage.isNull() &amp;&amp; newUsage == fields-&gt;properties-&gt;currencyUsage.getNoError()) {
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1097,53 ***</span>
  }
  
  UCurrencyUsage DecimalFormat::getCurrencyUsage() const {
      // CurrencyUsage is not exported, so we have to get it from the input property bag.
      // TODO: Should we export CurrencyUsage instead?
<span class="line-modified">!     if (fields-&gt;properties-&gt;currencyUsage.isNull()) {</span>
          return UCURR_USAGE_STANDARD;
      }
      return fields-&gt;properties-&gt;currencyUsage.getNoError();
  }
  
  void
  DecimalFormat::formatToDecimalQuantity(double number, DecimalQuantity&amp; output, UErrorCode&amp; status) const {
      fields-&gt;formatter-&gt;formatDouble(number, status).getDecimalQuantity(output, status);
  }
  
  void DecimalFormat::formatToDecimalQuantity(const Formattable&amp; number, DecimalQuantity&amp; output,
                                              UErrorCode&amp; status) const {
      UFormattedNumberData obj;
      number.populateDecimalQuantity(obj.quantity, status);
      fields-&gt;formatter-&gt;formatImpl(&amp;obj, status);
      output = std::move(obj.quantity);
  }
  
  const number::LocalizedNumberFormatter&amp; DecimalFormat::toNumberFormatter() const {
<span class="line-modified">!     return *fields-&gt;formatter;</span>
  }
  
  /** Rebuilds the formatter object from the property bag. */
  void DecimalFormat::touch(UErrorCode&amp; status) {
<span class="line-modified">!     if (fields-&gt;exportedProperties == nullptr) {</span>
<span class="line-modified">!         // fields-&gt;exportedProperties is null only when the formatter is not ready yet.</span>
<span class="line-modified">!         // The only time when this happens is during legacy deserialization.</span>
          return;
      }
  
      // In C++, fields-&gt;symbols is the source of truth for the locale.
      Locale locale = fields-&gt;symbols-&gt;getLocale();
  
      // Note: The formatter is relatively cheap to create, and we need it to populate fields-&gt;exportedProperties,
<span class="line-modified">!     // so automatically compute it here. The parser is a bit more expensive and is not needed until the</span>
      // parse method is called, so defer that until needed.
      // TODO: Only update the pieces that changed instead of re-computing the whole formatter?
<span class="line-modified">!     fields-&gt;formatter.adoptInstead(</span>
<span class="line-modified">!             new LocalizedNumberFormatter(</span>
<span class="line-modified">!                     NumberPropertyMapper::create(</span>
<span class="line-modified">!                             *fields-&gt;properties, *fields-&gt;symbols, fields-&gt;warehouse, *fields-&gt;exportedProperties, status).locale(</span>
<span class="line-modified">!                             locale)));</span>
  
      // Do this after fields-&gt;exportedProperties are set up
      setupFastFormat();
  
      // Delete the parsers if they were made previously
<span class="line-new-header">--- 1533,86 ---</span>
  }
  
  UCurrencyUsage DecimalFormat::getCurrencyUsage() const {
      // CurrencyUsage is not exported, so we have to get it from the input property bag.
      // TODO: Should we export CurrencyUsage instead?
<span class="line-modified">!     if (fields == nullptr || fields-&gt;properties-&gt;currencyUsage.isNull()) {</span>
          return UCURR_USAGE_STANDARD;
      }
      return fields-&gt;properties-&gt;currencyUsage.getNoError();
  }
  
  void
  DecimalFormat::formatToDecimalQuantity(double number, DecimalQuantity&amp; output, UErrorCode&amp; status) const {
<span class="line-added">+     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      fields-&gt;formatter-&gt;formatDouble(number, status).getDecimalQuantity(output, status);
  }
  
  void DecimalFormat::formatToDecimalQuantity(const Formattable&amp; number, DecimalQuantity&amp; output,
                                              UErrorCode&amp; status) const {
<span class="line-added">+     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      UFormattedNumberData obj;
      number.populateDecimalQuantity(obj.quantity, status);
      fields-&gt;formatter-&gt;formatImpl(&amp;obj, status);
      output = std::move(obj.quantity);
  }
  
<span class="line-added">+ const number::LocalizedNumberFormatter* DecimalFormat::toNumberFormatter(UErrorCode&amp; status) const {</span>
<span class="line-added">+     // We sometimes need to return nullptr here (see ICU-20380)</span>
<span class="line-added">+     if (U_FAILURE(status)) { return nullptr; }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return &amp;*fields-&gt;formatter;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  const number::LocalizedNumberFormatter&amp; DecimalFormat::toNumberFormatter() const {
<span class="line-modified">!     UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="line-added">+     return *toNumberFormatter(localStatus);</span>
  }
  
  /** Rebuilds the formatter object from the property bag. */
  void DecimalFormat::touch(UErrorCode&amp; status) {
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+     if (fields == nullptr) {</span>
<span class="line-added">+         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">+         // For regular construction, the caller should have checked the status variable for errors.</span>
<span class="line-added">+         // For copy construction, there is unfortunately nothing to report the error, so we need to guard against</span>
<span class="line-added">+         // this possible bad state here and set the status to an error.</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
          return;
      }
  
      // In C++, fields-&gt;symbols is the source of truth for the locale.
      Locale locale = fields-&gt;symbols-&gt;getLocale();
  
      // Note: The formatter is relatively cheap to create, and we need it to populate fields-&gt;exportedProperties,
<span class="line-modified">!     // so automatically recompute it here. The parser is a bit more expensive and is not needed until the</span>
      // parse method is called, so defer that until needed.
      // TODO: Only update the pieces that changed instead of re-computing the whole formatter?
<span class="line-modified">! </span>
<span class="line-modified">!     // Since memory has already been allocated for the formatter, we can move assign a stack-allocated object</span>
<span class="line-modified">!     // and don&#39;t need to call new. (Which is slower and could possibly fail).</span>
<span class="line-modified">!     *fields-&gt;formatter = NumberPropertyMapper::create(</span>
<span class="line-modified">!         *fields-&gt;properties, *fields-&gt;symbols, fields-&gt;warehouse, *fields-&gt;exportedProperties, status).locale(</span>
<span class="line-added">+             locale);</span>
  
      // Do this after fields-&gt;exportedProperties are set up
      setupFastFormat();
  
      // Delete the parsers if they were made previously
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1173,27 ***</span>
          PatternParser::parseToExistingProperties(pattern, *fields-&gt;properties,  actualIgnoreRounding, status);
      }
  }
  
  const numparse::impl::NumberParserImpl* DecimalFormat::getParser(UErrorCode&amp; status) const {
<span class="line-modified">!     if (U_FAILURE(status)) { return nullptr; }</span>
  
      // First try to get the pre-computed parser
      auto* ptr = fields-&gt;atomicParser.load();
      if (ptr != nullptr) {
          return ptr;
      }
  
      // Try computing the parser on our own
      auto* temp = NumberParserImpl::createParserFromProperties(*fields-&gt;properties, *fields-&gt;symbols, false, status);
      if (temp == nullptr) {
          status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">!         // although we may still dereference, call sites should be guarded</span>
      }
  
<span class="line-modified">!     // Note: ptr starts as nullptr; during compare_exchange, it is set to what is actually stored in the</span>
<span class="line-modified">!     // atomic if another thread beat us to computing the parser object.</span>
      auto* nonConstThis = const_cast&lt;DecimalFormat*&gt;(this);
      if (!nonConstThis-&gt;fields-&gt;atomicParser.compare_exchange_strong(ptr, temp)) {
          // Another thread beat us to computing the parser
          delete temp;
          return ptr;
<span class="line-new-header">--- 1642,36 ---</span>
          PatternParser::parseToExistingProperties(pattern, *fields-&gt;properties,  actualIgnoreRounding, status);
      }
  }
  
  const numparse::impl::NumberParserImpl* DecimalFormat::getParser(UErrorCode&amp; status) const {
<span class="line-modified">!     // TODO: Move this into umutex.h? (similar logic also in numrange_fluent.cpp)</span>
<span class="line-added">+     // See ICU-20146</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
  
      // First try to get the pre-computed parser
      auto* ptr = fields-&gt;atomicParser.load();
      if (ptr != nullptr) {
          return ptr;
      }
  
      // Try computing the parser on our own
      auto* temp = NumberParserImpl::createParserFromProperties(*fields-&gt;properties, *fields-&gt;symbols, false, status);
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      if (temp == nullptr) {
          status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">!         return nullptr;</span>
      }
  
<span class="line-modified">!     // Note: ptr starts as nullptr; during compare_exchange,</span>
<span class="line-modified">!     // it is set to what is actually stored in the atomic</span>
<span class="line-added">+     // if another thread beat us to computing the parser object.</span>
      auto* nonConstThis = const_cast&lt;DecimalFormat*&gt;(this);
      if (!nonConstThis-&gt;fields-&gt;atomicParser.compare_exchange_strong(ptr, temp)) {
          // Another thread beat us to computing the parser
          delete temp;
          return ptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1233,10 ***</span>
<span class="line-new-header">--- 1711,11 ---</span>
  }
  
  void
  DecimalFormat::fieldPositionHelper(const number::FormattedNumber&amp; formatted, FieldPosition&amp; fieldPosition,
                                     int32_t offset, UErrorCode&amp; status) {
<span class="line-added">+     if (U_FAILURE(status)) { return; }</span>
      // always return first occurrence:
      fieldPosition.setBeginIndex(0);
      fieldPosition.setEndIndex(0);
      bool found = formatted.nextFieldPosition(fieldPosition, status);
      if (found &amp;&amp; offset != 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1246,11 ***</span>
  }
  
  void
  DecimalFormat::fieldPositionIteratorHelper(const number::FormattedNumber&amp; formatted, FieldPositionIterator* fpi,
                                             int32_t offset, UErrorCode&amp; status) {
<span class="line-modified">!     if (fpi != nullptr) {</span>
          FieldPositionIteratorHandler fpih(fpi, status);
          fpih.setShift(offset);
          formatted.getAllFieldPositionsImpl(fpih, status);
      }
  }
<span class="line-new-header">--- 1725,11 ---</span>
  }
  
  void
  DecimalFormat::fieldPositionIteratorHelper(const number::FormattedNumber&amp; formatted, FieldPositionIterator* fpi,
                                             int32_t offset, UErrorCode&amp; status) {
<span class="line-modified">!     if (U_SUCCESS(status) &amp;&amp; (fpi != nullptr)) {</span>
          FieldPositionIteratorHandler fpih(fpi, status);
          fpih.setShift(offset);
          formatted.getAllFieldPositionsImpl(fpih, status);
      }
  }
</pre>
<center><a href="decNumberLocal.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion-bignum-dtoa.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>