<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_tag.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 2009-2015, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 */
   9 
<a name="1" id="anc1"></a><span class="line-added">  10 #include &quot;unicode/bytestream.h&quot;</span>
  11 #include &quot;unicode/utypes.h&quot;
  12 #include &quot;unicode/ures.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  13 #include &quot;unicode/localpointer.h&quot;</span>
  14 #include &quot;unicode/putil.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  15 #include &quot;unicode/uenum.h&quot;</span>
  16 #include &quot;unicode/uloc.h&quot;
  17 #include &quot;ustr_imp.h&quot;
<a name="4" id="anc4"></a><span class="line-added">  18 #include &quot;charstr.h&quot;</span>
  19 #include &quot;cmemory.h&quot;
  20 #include &quot;cstring.h&quot;
  21 #include &quot;putilimp.h&quot;
  22 #include &quot;uinvchar.h&quot;
  23 #include &quot;ulocimp.h&quot;
  24 #include &quot;uassert.h&quot;
  25 
  26 
  27 /* struct holding a single variant */
  28 typedef struct VariantListEntry {
  29     const char              *variant;
  30     struct VariantListEntry *next;
  31 } VariantListEntry;
  32 
  33 /* struct holding a single attribute value */
<a name="5" id="anc5"></a><span class="line-modified">  34 struct AttributeListEntry : public icu::UMemory {</span>
  35     const char              *attribute;
  36     struct AttributeListEntry *next;
<a name="6" id="anc6"></a><span class="line-modified">  37 };</span>
  38 
  39 /* struct holding a single extension */
<a name="7" id="anc7"></a><span class="line-modified">  40 struct ExtensionListEntry : public icu::UMemory {</span>
  41     const char                  *key;
  42     const char                  *value;
  43     struct ExtensionListEntry   *next;
<a name="8" id="anc8"></a><span class="line-modified">  44 };</span>
  45 
  46 #define MAXEXTLANG 3
  47 typedef struct ULanguageTag {
  48     char                *buf;   /* holding parsed subtags */
  49     const char          *language;
  50     const char          *extlang[MAXEXTLANG];
  51     const char          *script;
  52     const char          *region;
  53     VariantListEntry    *variants;
  54     ExtensionListEntry  *extensions;
  55     const char          *privateuse;
  56     const char          *grandfathered;
  57 } ULanguageTag;
  58 
  59 #define MINLEN 2
  60 #define SEP &#39;-&#39;
  61 #define PRIVATEUSE &#39;x&#39;
  62 #define LDMLEXT &#39;u&#39;
  63 
  64 #define LOCALE_SEP &#39;_&#39;
  65 #define LOCALE_EXT_SEP &#39;@&#39;
  66 #define LOCALE_KEYWORD_SEP &#39;;&#39;
  67 #define LOCALE_KEY_TYPE_SEP &#39;=&#39;
  68 
  69 #define ISALPHA(c) uprv_isASCIILetter(c)
  70 #define ISNUMERIC(c) ((c)&gt;=&#39;0&#39; &amp;&amp; (c)&lt;=&#39;9&#39;)
  71 
  72 static const char EMPTY[] = &quot;&quot;;
  73 static const char LANG_UND[] = &quot;und&quot;;
  74 static const char PRIVATEUSE_KEY[] = &quot;x&quot;;
  75 static const char _POSIX[] = &quot;_POSIX&quot;;
  76 static const char POSIX_KEY[] = &quot;va&quot;;
  77 static const char POSIX_VALUE[] = &quot;posix&quot;;
  78 static const char LOCALE_ATTRIBUTE_KEY[] = &quot;attribute&quot;;
  79 static const char PRIVUSE_VARIANT_PREFIX[] = &quot;lvariant&quot;;
  80 static const char LOCALE_TYPE_YES[] = &quot;yes&quot;;
  81 
  82 #define LANG_UND_LEN 3
  83 
<a name="9" id="anc9"></a><span class="line-added">  84 /*</span>
<span class="line-added">  85  Updated on 2018-09-12 from</span>
<span class="line-added">  86  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .</span>
<span class="line-added">  87 </span>
<span class="line-added">  88  This table has 2 parts. The parts for Grandfathered tags is generated by the</span>
<span class="line-added">  89  following scripts from the IANA language tag registry.</span>
<span class="line-added">  90 </span>
<span class="line-added">  91  curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry |\</span>
<span class="line-added">  92  egrep -A 7 &#39;Type: grandfathered&#39; | \</span>
<span class="line-added">  93  egrep &#39;Tag|Prefe&#39; | grep -B1 &#39;Preferred&#39; | grep -v &#39;^--&#39; | \</span>
<span class="line-added">  94  awk -n &#39;/Tag/ {printf(&quot;    \&quot;%s\&quot;, &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39; |\</span>
<span class="line-added">  95  tr &#39;A-Z&#39; &#39;a-z&#39;</span>
<span class="line-added">  96 </span>
<span class="line-added">  97 </span>
<span class="line-added">  98  The 2nd part is made of five ICU-specific entries. They&#39;re kept for</span>
<span class="line-added">  99  the backward compatibility for now, even though there are no preferred</span>
<span class="line-added"> 100  values. They may have to be removed for the strict BCP 47 compliance.</span>
<span class="line-added"> 101 </span>
<span class="line-added"> 102 */</span>
 103 static const char* const GRANDFATHERED[] = {
 104 /*  grandfathered   preferred */
 105     &quot;art-lojban&quot;,   &quot;jbo&quot;,
<a name="10" id="anc10"></a><span class="line-modified"> 106     &quot;en-gb-oed&quot;,    &quot;en-gb-oxendict&quot;,</span>

 107     &quot;i-ami&quot;,        &quot;ami&quot;,
 108     &quot;i-bnn&quot;,        &quot;bnn&quot;,
<a name="11" id="anc11"></a>

 109     &quot;i-hak&quot;,        &quot;hak&quot;,
 110     &quot;i-klingon&quot;,    &quot;tlh&quot;,
 111     &quot;i-lux&quot;,        &quot;lb&quot;,
<a name="12" id="anc12"></a>
 112     &quot;i-navajo&quot;,     &quot;nv&quot;,
 113     &quot;i-pwn&quot;,        &quot;pwn&quot;,
 114     &quot;i-tao&quot;,        &quot;tao&quot;,
 115     &quot;i-tay&quot;,        &quot;tay&quot;,
 116     &quot;i-tsu&quot;,        &quot;tsu&quot;,
 117     &quot;no-bok&quot;,       &quot;nb&quot;,
 118     &quot;no-nyn&quot;,       &quot;nn&quot;,
 119     &quot;sgn-be-fr&quot;,    &quot;sfb&quot;,
 120     &quot;sgn-be-nl&quot;,    &quot;vgt&quot;,
 121     &quot;sgn-ch-de&quot;,    &quot;sgg&quot;,
 122     &quot;zh-guoyu&quot;,     &quot;cmn&quot;,
 123     &quot;zh-hakka&quot;,     &quot;hak&quot;,
<a name="13" id="anc13"></a>
 124     &quot;zh-min-nan&quot;,   &quot;nan&quot;,
 125     &quot;zh-xiang&quot;,     &quot;hsn&quot;,
<a name="14" id="anc14"></a><span class="line-modified"> 126 </span>
<span class="line-added"> 127     // Grandfathered tags with no preferred value in the IANA</span>
<span class="line-added"> 128     // registry. Kept for now for the backward compatibility</span>
<span class="line-added"> 129     // because ICU has mapped them this way.</span>
<span class="line-added"> 130     &quot;cel-gaulish&quot;,  &quot;xtg-x-cel-gaulish&quot;,</span>
<span class="line-added"> 131     &quot;i-default&quot;,    &quot;en-x-i-default&quot;,</span>
<span class="line-added"> 132     &quot;i-enochian&quot;,   &quot;und-x-i-enochian&quot;,</span>
<span class="line-added"> 133     &quot;i-mingo&quot;,      &quot;see-x-i-mingo&quot;,</span>
<span class="line-added"> 134     &quot;zh-min&quot;,       &quot;nan-x-zh-min&quot;,</span>
<span class="line-added"> 135 };</span>
<span class="line-added"> 136 </span>
<span class="line-added"> 137 /*</span>
<span class="line-added"> 138  Updated on 2018-09-12 from</span>
<span class="line-added"> 139  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .</span>
<span class="line-added"> 140 </span>
<span class="line-added"> 141  The table lists redundant tags with preferred value in the IANA languate tag registry.</span>
<span class="line-added"> 142  It&#39;s generated with the following command:</span>
<span class="line-added"> 143 </span>
<span class="line-added"> 144  curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry |\</span>
<span class="line-added"> 145  grep &#39;Type: redundant&#39; -A 5 | egrep &#39;^(Tag:|Prefer)&#39; | grep -B1 &#39;Preferred&#39; | \</span>
<span class="line-added"> 146  awk -n &#39;/Tag/ {printf(&quot;    \&quot;%s\&quot;,       &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39; | \</span>
<span class="line-added"> 147  tr &#39;A-Z&#39; &#39;a-z&#39;</span>
<span class="line-added"> 148 </span>
<span class="line-added"> 149  In addition, ja-latn-hepburn-heploc is mapped to ja-latn-alalc97 because</span>
<span class="line-added"> 150  a variant tag &#39;hepburn-heploc&#39; has the preferred subtag, &#39;alaic97&#39;.</span>
<span class="line-added"> 151 */</span>
<span class="line-added"> 152 </span>
<span class="line-added"> 153 static const char* const REDUNDANT[] = {</span>
<span class="line-added"> 154 //  redundant       preferred</span>
<span class="line-added"> 155     &quot;sgn-br&quot;,       &quot;bzs&quot;,</span>
<span class="line-added"> 156     &quot;sgn-co&quot;,       &quot;csn&quot;,</span>
<span class="line-added"> 157     &quot;sgn-de&quot;,       &quot;gsg&quot;,</span>
<span class="line-added"> 158     &quot;sgn-dk&quot;,       &quot;dsl&quot;,</span>
<span class="line-added"> 159     &quot;sgn-es&quot;,       &quot;ssp&quot;,</span>
<span class="line-added"> 160     &quot;sgn-fr&quot;,       &quot;fsl&quot;,</span>
<span class="line-added"> 161     &quot;sgn-gb&quot;,       &quot;bfi&quot;,</span>
<span class="line-added"> 162     &quot;sgn-gr&quot;,       &quot;gss&quot;,</span>
<span class="line-added"> 163     &quot;sgn-ie&quot;,       &quot;isg&quot;,</span>
<span class="line-added"> 164     &quot;sgn-it&quot;,       &quot;ise&quot;,</span>
<span class="line-added"> 165     &quot;sgn-jp&quot;,       &quot;jsl&quot;,</span>
<span class="line-added"> 166     &quot;sgn-mx&quot;,       &quot;mfs&quot;,</span>
<span class="line-added"> 167     &quot;sgn-ni&quot;,       &quot;ncs&quot;,</span>
<span class="line-added"> 168     &quot;sgn-nl&quot;,       &quot;dse&quot;,</span>
<span class="line-added"> 169     &quot;sgn-no&quot;,       &quot;nsl&quot;,</span>
<span class="line-added"> 170     &quot;sgn-pt&quot;,       &quot;psr&quot;,</span>
<span class="line-added"> 171     &quot;sgn-se&quot;,       &quot;swl&quot;,</span>
<span class="line-added"> 172     &quot;sgn-us&quot;,       &quot;ase&quot;,</span>
<span class="line-added"> 173     &quot;sgn-za&quot;,       &quot;sfs&quot;,</span>
<span class="line-added"> 174     &quot;zh-cmn&quot;,       &quot;cmn&quot;,</span>
<span class="line-added"> 175     &quot;zh-cmn-hans&quot;,  &quot;cmn-hans&quot;,</span>
<span class="line-added"> 176     &quot;zh-cmn-hant&quot;,  &quot;cmn-hant&quot;,</span>
<span class="line-added"> 177     &quot;zh-gan&quot;,       &quot;gan&quot;,</span>
<span class="line-added"> 178     &quot;zh-wuu&quot;,       &quot;wuu&quot;,</span>
<span class="line-added"> 179     &quot;zh-yue&quot;,       &quot;yue&quot;,</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181     // variant tag with preferred value</span>
<span class="line-added"> 182     &quot;ja-latn-hepburn-heploc&quot;, &quot;ja-latn-alalc97&quot;,</span>
 183 };
 184 
<a name="15" id="anc15"></a><span class="line-added"> 185 /*</span>
<span class="line-added"> 186   Updated on 2018-09-12 from</span>
<span class="line-added"> 187   https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .</span>
<span class="line-added"> 188 </span>
<span class="line-added"> 189   grep &#39;Type: language&#39; -A 7 language-subtag-registry  | egrep &#39;Subtag|Prefe&#39; | \</span>
<span class="line-added"> 190   grep -B1 &#39;Preferred&#39; | grep -v &#39;^--&#39; | \</span>
<span class="line-added"> 191   awk -n &#39;/Subtag/ {printf(&quot;    \&quot;%s\&quot;,       &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39;</span>
<span class="line-added"> 192 </span>
<span class="line-added"> 193   Make sure that 2-letter language subtags come before 3-letter subtags.</span>
<span class="line-added"> 194 */</span>
 195 static const char DEPRECATEDLANGS[][4] = {
 196 /*  deprecated  new */
<a name="16" id="anc16"></a><span class="line-added"> 197     &quot;in&quot;,       &quot;id&quot;,</span>
 198     &quot;iw&quot;,       &quot;he&quot;,
 199     &quot;ji&quot;,       &quot;yi&quot;,
<a name="17" id="anc17"></a><span class="line-modified"> 200     &quot;jw&quot;,       &quot;jv&quot;,</span>
<span class="line-added"> 201     &quot;mo&quot;,       &quot;ro&quot;,</span>
<span class="line-added"> 202     &quot;aam&quot;,       &quot;aas&quot;,</span>
<span class="line-added"> 203     &quot;adp&quot;,       &quot;dz&quot;,</span>
<span class="line-added"> 204     &quot;aue&quot;,       &quot;ktz&quot;,</span>
<span class="line-added"> 205     &quot;ayx&quot;,       &quot;nun&quot;,</span>
<span class="line-added"> 206     &quot;bgm&quot;,       &quot;bcg&quot;,</span>
<span class="line-added"> 207     &quot;bjd&quot;,       &quot;drl&quot;,</span>
<span class="line-added"> 208     &quot;ccq&quot;,       &quot;rki&quot;,</span>
<span class="line-added"> 209     &quot;cjr&quot;,       &quot;mom&quot;,</span>
<span class="line-added"> 210     &quot;cka&quot;,       &quot;cmr&quot;,</span>
<span class="line-added"> 211     &quot;cmk&quot;,       &quot;xch&quot;,</span>
<span class="line-added"> 212     &quot;coy&quot;,       &quot;pij&quot;,</span>
<span class="line-added"> 213     &quot;cqu&quot;,       &quot;quh&quot;,</span>
<span class="line-added"> 214     &quot;drh&quot;,       &quot;khk&quot;,</span>
<span class="line-added"> 215     &quot;drw&quot;,       &quot;prs&quot;,</span>
<span class="line-added"> 216     &quot;gav&quot;,       &quot;dev&quot;,</span>
<span class="line-added"> 217     &quot;gfx&quot;,       &quot;vaj&quot;,</span>
<span class="line-added"> 218     &quot;ggn&quot;,       &quot;gvr&quot;,</span>
<span class="line-added"> 219     &quot;gti&quot;,       &quot;nyc&quot;,</span>
<span class="line-added"> 220     &quot;guv&quot;,       &quot;duz&quot;,</span>
<span class="line-added"> 221     &quot;hrr&quot;,       &quot;jal&quot;,</span>
<span class="line-added"> 222     &quot;ibi&quot;,       &quot;opa&quot;,</span>
<span class="line-added"> 223     &quot;ilw&quot;,       &quot;gal&quot;,</span>
<span class="line-added"> 224     &quot;jeg&quot;,       &quot;oyb&quot;,</span>
<span class="line-added"> 225     &quot;kgc&quot;,       &quot;tdf&quot;,</span>
<span class="line-added"> 226     &quot;kgh&quot;,       &quot;kml&quot;,</span>
<span class="line-added"> 227     &quot;koj&quot;,       &quot;kwv&quot;,</span>
<span class="line-added"> 228     &quot;krm&quot;,       &quot;bmf&quot;,</span>
<span class="line-added"> 229     &quot;ktr&quot;,       &quot;dtp&quot;,</span>
<span class="line-added"> 230     &quot;kvs&quot;,       &quot;gdj&quot;,</span>
<span class="line-added"> 231     &quot;kwq&quot;,       &quot;yam&quot;,</span>
<span class="line-added"> 232     &quot;kxe&quot;,       &quot;tvd&quot;,</span>
<span class="line-added"> 233     &quot;kzj&quot;,       &quot;dtp&quot;,</span>
<span class="line-added"> 234     &quot;kzt&quot;,       &quot;dtp&quot;,</span>
<span class="line-added"> 235     &quot;lii&quot;,       &quot;raq&quot;,</span>
<span class="line-added"> 236     &quot;lmm&quot;,       &quot;rmx&quot;,</span>
<span class="line-added"> 237     &quot;meg&quot;,       &quot;cir&quot;,</span>
<span class="line-added"> 238     &quot;mst&quot;,       &quot;mry&quot;,</span>
<span class="line-added"> 239     &quot;mwj&quot;,       &quot;vaj&quot;,</span>
<span class="line-added"> 240     &quot;myt&quot;,       &quot;mry&quot;,</span>
<span class="line-added"> 241     &quot;nad&quot;,       &quot;xny&quot;,</span>
<span class="line-added"> 242     &quot;ncp&quot;,       &quot;kdz&quot;,</span>
<span class="line-added"> 243     &quot;nnx&quot;,       &quot;ngv&quot;,</span>
<span class="line-added"> 244     &quot;nts&quot;,       &quot;pij&quot;,</span>
<span class="line-added"> 245     &quot;oun&quot;,       &quot;vaj&quot;,</span>
<span class="line-added"> 246     &quot;pcr&quot;,       &quot;adx&quot;,</span>
<span class="line-added"> 247     &quot;pmc&quot;,       &quot;huw&quot;,</span>
<span class="line-added"> 248     &quot;pmu&quot;,       &quot;phr&quot;,</span>
<span class="line-added"> 249     &quot;ppa&quot;,       &quot;bfy&quot;,</span>
<span class="line-added"> 250     &quot;ppr&quot;,       &quot;lcq&quot;,</span>
<span class="line-added"> 251     &quot;pry&quot;,       &quot;prt&quot;,</span>
<span class="line-added"> 252     &quot;puz&quot;,       &quot;pub&quot;,</span>
<span class="line-added"> 253     &quot;sca&quot;,       &quot;hle&quot;,</span>
<span class="line-added"> 254     &quot;skk&quot;,       &quot;oyb&quot;,</span>
<span class="line-added"> 255     &quot;tdu&quot;,       &quot;dtp&quot;,</span>
<span class="line-added"> 256     &quot;thc&quot;,       &quot;tpo&quot;,</span>
<span class="line-added"> 257     &quot;thx&quot;,       &quot;oyb&quot;,</span>
<span class="line-added"> 258     &quot;tie&quot;,       &quot;ras&quot;,</span>
<span class="line-added"> 259     &quot;tkk&quot;,       &quot;twm&quot;,</span>
<span class="line-added"> 260     &quot;tlw&quot;,       &quot;weo&quot;,</span>
<span class="line-added"> 261     &quot;tmp&quot;,       &quot;tyj&quot;,</span>
<span class="line-added"> 262     &quot;tne&quot;,       &quot;kak&quot;,</span>
<span class="line-added"> 263     &quot;tnf&quot;,       &quot;prs&quot;,</span>
<span class="line-added"> 264     &quot;tsf&quot;,       &quot;taj&quot;,</span>
<span class="line-added"> 265     &quot;uok&quot;,       &quot;ema&quot;,</span>
<span class="line-added"> 266     &quot;xba&quot;,       &quot;cax&quot;,</span>
<span class="line-added"> 267     &quot;xia&quot;,       &quot;acn&quot;,</span>
<span class="line-added"> 268     &quot;xkh&quot;,       &quot;waw&quot;,</span>
<span class="line-added"> 269     &quot;xsj&quot;,       &quot;suj&quot;,</span>
<span class="line-added"> 270     &quot;ybd&quot;,       &quot;rki&quot;,</span>
<span class="line-added"> 271     &quot;yma&quot;,       &quot;lrr&quot;,</span>
<span class="line-added"> 272     &quot;ymt&quot;,       &quot;mtm&quot;,</span>
<span class="line-added"> 273     &quot;yos&quot;,       &quot;zom&quot;,</span>
<span class="line-added"> 274     &quot;yuu&quot;,       &quot;yug&quot;,</span>
<span class="line-added"> 275 };</span>
<span class="line-added"> 276 </span>
<span class="line-added"> 277 /*</span>
<span class="line-added"> 278   Updated on 2018-04-24 from</span>
<span class="line-added"> 279 </span>
<span class="line-added"> 280   curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry | \</span>
<span class="line-added"> 281   grep &#39;Type: region&#39; -A 7 | egrep &#39;Subtag|Prefe&#39; | \</span>
<span class="line-added"> 282   grep -B1 &#39;Preferred&#39; | \</span>
<span class="line-added"> 283   awk -n &#39;/Subtag/ {printf(&quot;    \&quot;%s\&quot;,       &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39;</span>
<span class="line-added"> 284 */</span>
<span class="line-added"> 285 static const char DEPRECATEDREGIONS[][3] = {</span>
<span class="line-added"> 286 /*  deprecated  new */</span>
<span class="line-added"> 287     &quot;BU&quot;,       &quot;MM&quot;,</span>
<span class="line-added"> 288     &quot;DD&quot;,       &quot;DE&quot;,</span>
<span class="line-added"> 289     &quot;FX&quot;,       &quot;FR&quot;,</span>
<span class="line-added"> 290     &quot;TP&quot;,       &quot;TL&quot;,</span>
<span class="line-added"> 291     &quot;YD&quot;,       &quot;YE&quot;,</span>
<span class="line-added"> 292     &quot;ZR&quot;,       &quot;CD&quot;,</span>
 293 };
 294 
 295 /*
 296 * -------------------------------------------------
 297 *
 298 * These ultag_ functions may be exposed as APIs later
 299 *
 300 * -------------------------------------------------
 301 */
 302 
 303 static ULanguageTag*
 304 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status);
 305 
 306 static void
 307 ultag_close(ULanguageTag* langtag);
 308 
 309 static const char*
 310 ultag_getLanguage(const ULanguageTag* langtag);
 311 
 312 #if 0
 313 static const char*
 314 ultag_getJDKLanguage(const ULanguageTag* langtag);
 315 #endif
 316 
 317 static const char*
 318 ultag_getExtlang(const ULanguageTag* langtag, int32_t idx);
 319 
 320 static int32_t
 321 ultag_getExtlangSize(const ULanguageTag* langtag);
 322 
 323 static const char*
 324 ultag_getScript(const ULanguageTag* langtag);
 325 
 326 static const char*
 327 ultag_getRegion(const ULanguageTag* langtag);
 328 
 329 static const char*
 330 ultag_getVariant(const ULanguageTag* langtag, int32_t idx);
 331 
 332 static int32_t
 333 ultag_getVariantsSize(const ULanguageTag* langtag);
 334 
 335 static const char*
 336 ultag_getExtensionKey(const ULanguageTag* langtag, int32_t idx);
 337 
 338 static const char*
 339 ultag_getExtensionValue(const ULanguageTag* langtag, int32_t idx);
 340 
 341 static int32_t
 342 ultag_getExtensionsSize(const ULanguageTag* langtag);
 343 
 344 static const char*
 345 ultag_getPrivateUse(const ULanguageTag* langtag);
 346 
 347 #if 0
 348 static const char*
 349 ultag_getGrandfathered(const ULanguageTag* langtag);
 350 #endif
 351 
<a name="18" id="anc18"></a><span class="line-added"> 352 U_NAMESPACE_BEGIN</span>
<span class="line-added"> 353 </span>
<span class="line-added"> 354 /**</span>
<span class="line-added"> 355  * \class LocalULanguageTagPointer</span>
<span class="line-added"> 356  * &quot;Smart pointer&quot; class, closes a ULanguageTag via ultag_close().</span>
<span class="line-added"> 357  * For most methods see the LocalPointerBase base class.</span>
<span class="line-added"> 358  *</span>
<span class="line-added"> 359  * @see LocalPointerBase</span>
<span class="line-added"> 360  * @see LocalPointer</span>
<span class="line-added"> 361  * @internal</span>
<span class="line-added"> 362  */</span>
<span class="line-added"> 363 U_DEFINE_LOCAL_OPEN_POINTER(LocalULanguageTagPointer, ULanguageTag, ultag_close);</span>
<span class="line-added"> 364 </span>
<span class="line-added"> 365 U_NAMESPACE_END</span>
<span class="line-added"> 366 </span>
 367 /*
 368 * -------------------------------------------------
 369 *
 370 * Language subtag syntax validation functions
 371 *
 372 * -------------------------------------------------
 373 */
 374 
 375 static UBool
 376 _isAlphaString(const char* s, int32_t len) {
 377     int32_t i;
 378     for (i = 0; i &lt; len; i++) {
 379         if (!ISALPHA(*(s + i))) {
 380             return FALSE;
 381         }
 382     }
 383     return TRUE;
 384 }
 385 
 386 static UBool
 387 _isNumericString(const char* s, int32_t len) {
 388     int32_t i;
 389     for (i = 0; i &lt; len; i++) {
 390         if (!ISNUMERIC(*(s + i))) {
 391             return FALSE;
 392         }
 393     }
 394     return TRUE;
 395 }
 396 
 397 static UBool
 398 _isAlphaNumericString(const char* s, int32_t len) {
 399     int32_t i;
 400     for (i = 0; i &lt; len; i++) {
 401         if (!ISALPHA(*(s + i)) &amp;&amp; !ISNUMERIC(*(s + i))) {
 402             return FALSE;
 403         }
 404     }
 405     return TRUE;
 406 }
 407 
 408 static UBool
<a name="19" id="anc19"></a><span class="line-modified"> 409 _isAlphaNumericStringLimitedLength(const char* s, int32_t len, int32_t min, int32_t max) {</span>
<span class="line-added"> 410     if (len &lt; 0) {</span>
<span class="line-added"> 411         len = (int32_t)uprv_strlen(s);</span>
<span class="line-added"> 412     }</span>
<span class="line-added"> 413     if (len &gt;= min &amp;&amp; len &lt;= max &amp;&amp; _isAlphaNumericString(s, len)) {</span>
<span class="line-added"> 414         return TRUE;</span>
<span class="line-added"> 415     }</span>
<span class="line-added"> 416     return FALSE;</span>
<span class="line-added"> 417 }</span>
<span class="line-added"> 418 </span>
<span class="line-added"> 419 U_CFUNC UBool</span>
<span class="line-added"> 420 ultag_isLanguageSubtag(const char* s, int32_t len) {</span>
 421     /*
<a name="20" id="anc20"></a><span class="line-modified"> 422      * unicode_language_subtag = alpha{2,3} | alpha{5,8};</span>
<span class="line-modified"> 423      * NOTE: Per ICUTC 2019/01/23- accepting alpha 4</span>
<span class="line-modified"> 424      * See ICU-20372</span>


 425      */
 426     if (len &lt; 0) {
 427         len = (int32_t)uprv_strlen(s);
 428     }
 429     if (len &gt;= 2 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaString(s, len)) {
 430         return TRUE;
 431     }
 432     return FALSE;
 433 }
 434 
 435 static UBool
 436 _isExtlangSubtag(const char* s, int32_t len) {
 437     /*
 438      * extlang       = 3ALPHA              ; selected ISO 639 codes
 439      *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 440      */
 441     if (len &lt; 0) {
 442         len = (int32_t)uprv_strlen(s);
 443     }
 444     if (len == 3 &amp;&amp; _isAlphaString(s, len)) {
 445         return TRUE;
 446     }
 447     return FALSE;
 448 }
 449 
<a name="21" id="anc21"></a><span class="line-modified"> 450 U_CFUNC UBool</span>
<span class="line-modified"> 451 ultag_isScriptSubtag(const char* s, int32_t len) {</span>
 452     /*
 453      * script        = 4ALPHA              ; ISO 15924 code
 454      */
 455     if (len &lt; 0) {
 456         len = (int32_t)uprv_strlen(s);
 457     }
 458     if (len == 4 &amp;&amp; _isAlphaString(s, len)) {
 459         return TRUE;
 460     }
 461     return FALSE;
 462 }
 463 
<a name="22" id="anc22"></a><span class="line-modified"> 464 U_CFUNC UBool</span>
<span class="line-modified"> 465 ultag_isRegionSubtag(const char* s, int32_t len) {</span>
 466     /*
 467      * region        = 2ALPHA              ; ISO 3166-1 code
 468      *               / 3DIGIT              ; UN M.49 code
 469      */
 470     if (len &lt; 0) {
 471         len = (int32_t)uprv_strlen(s);
 472     }
 473     if (len == 2 &amp;&amp; _isAlphaString(s, len)) {
 474         return TRUE;
 475     }
 476     if (len == 3 &amp;&amp; _isNumericString(s, len)) {
 477         return TRUE;
 478     }
 479     return FALSE;
 480 }
 481 
 482 static UBool
 483 _isVariantSubtag(const char* s, int32_t len) {
 484     /*
 485      * variant       = 5*8alphanum         ; registered variants
 486      *               / (DIGIT 3alphanum)
 487      */
 488     if (len &lt; 0) {
 489         len = (int32_t)uprv_strlen(s);
 490     }
<a name="23" id="anc23"></a><span class="line-modified"> 491     if (_isAlphaNumericStringLimitedLength(s, len, 5, 8)) {</span>
 492         return TRUE;
 493     }
 494     if (len == 4 &amp;&amp; ISNUMERIC(*s) &amp;&amp; _isAlphaNumericString(s + 1, 3)) {
 495         return TRUE;
 496     }
 497     return FALSE;
 498 }
 499 
<a name="24" id="anc24"></a><span class="line-added"> 500 static UBool</span>
<span class="line-added"> 501 _isSepListOf(UBool (*test)(const char*, int32_t), const char* s, int32_t len) {</span>
<span class="line-added"> 502     const char *p = s;</span>
<span class="line-added"> 503     const char *pSubtag = NULL;</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505     if (len &lt; 0) {</span>
<span class="line-added"> 506         len = (int32_t)uprv_strlen(s);</span>
<span class="line-added"> 507     }</span>
<span class="line-added"> 508 </span>
<span class="line-added"> 509     while ((p - s) &lt; len) {</span>
<span class="line-added"> 510         if (*p == SEP) {</span>
<span class="line-added"> 511             if (pSubtag == NULL) {</span>
<span class="line-added"> 512                 return FALSE;</span>
<span class="line-added"> 513             }</span>
<span class="line-added"> 514             if (!test(pSubtag, (int32_t)(p - pSubtag))) {</span>
<span class="line-added"> 515                 return FALSE;</span>
<span class="line-added"> 516             }</span>
<span class="line-added"> 517             pSubtag = NULL;</span>
<span class="line-added"> 518         } else if (pSubtag == NULL) {</span>
<span class="line-added"> 519             pSubtag = p;</span>
<span class="line-added"> 520         }</span>
<span class="line-added"> 521         p++;</span>
<span class="line-added"> 522     }</span>
<span class="line-added"> 523     if (pSubtag == NULL) {</span>
<span class="line-added"> 524         return FALSE;</span>
<span class="line-added"> 525     }</span>
<span class="line-added"> 526     return test(pSubtag, (int32_t)(p - pSubtag));</span>
<span class="line-added"> 527 }</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529 U_CFUNC UBool</span>
<span class="line-added"> 530 ultag_isVariantSubtags(const char* s, int32_t len) {</span>
<span class="line-added"> 531     return _isSepListOf(&amp;_isVariantSubtag, s, len);</span>
<span class="line-added"> 532 }</span>
<span class="line-added"> 533 </span>
<span class="line-added"> 534 // This is for the ICU-specific &quot;lvariant&quot; handling.</span>
 535 static UBool
 536 _isPrivateuseVariantSubtag(const char* s, int32_t len) {
 537     /*
 538      * variant       = 1*8alphanum         ; registered variants
 539      *               / (DIGIT 3alphanum)
 540      */
<a name="25" id="anc25"></a><span class="line-modified"> 541     return _isAlphaNumericStringLimitedLength(s, len , 1, 8);</span>






 542 }
 543 
 544 static UBool
 545 _isExtensionSingleton(const char* s, int32_t len) {
 546     /*
 547      * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
<a name="26" id="anc26"></a><span class="line-added"> 548      *</span>
<span class="line-added"> 549      * singleton     = DIGIT               ; 0 - 9</span>
<span class="line-added"> 550      *               / %x41-57             ; A - W</span>
<span class="line-added"> 551      *               / %x59-5A             ; Y - Z</span>
<span class="line-added"> 552      *               / %x61-77             ; a - w</span>
<span class="line-added"> 553      *               / %x79-7A             ; y - z</span>
 554      */
 555     if (len &lt; 0) {
 556         len = (int32_t)uprv_strlen(s);
 557     }
<a name="27" id="anc27"></a><span class="line-modified"> 558     if (len == 1 &amp;&amp; (ISALPHA(*s) || ISNUMERIC(*s)) &amp;&amp; (uprv_tolower(*s) != PRIVATEUSE)) {</span>
 559         return TRUE;
 560     }
 561     return FALSE;
 562 }
 563 
 564 static UBool
 565 _isExtensionSubtag(const char* s, int32_t len) {
 566     /*
 567      * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
 568      */
<a name="28" id="anc28"></a><span class="line-added"> 569     return _isAlphaNumericStringLimitedLength(s, len, 2, 8);</span>
<span class="line-added"> 570 }</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572 U_CFUNC UBool</span>
<span class="line-added"> 573 ultag_isExtensionSubtags(const char* s, int32_t len) {</span>
<span class="line-added"> 574     return _isSepListOf(&amp;_isExtensionSubtag, s, len);</span>
<span class="line-added"> 575 }</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577 static UBool</span>
<span class="line-added"> 578 _isPrivateuseValueSubtag(const char* s, int32_t len) {</span>
<span class="line-added"> 579     /*</span>
<span class="line-added"> 580      * privateuse    = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))</span>
<span class="line-added"> 581      */</span>
<span class="line-added"> 582     return _isAlphaNumericStringLimitedLength(s, len, 1, 8);</span>
<span class="line-added"> 583 }</span>
<span class="line-added"> 584 </span>
<span class="line-added"> 585 U_CFUNC UBool</span>
<span class="line-added"> 586 ultag_isPrivateuseValueSubtags(const char* s, int32_t len) {</span>
<span class="line-added"> 587     return _isSepListOf(&amp;_isPrivateuseValueSubtag, s, len);</span>
<span class="line-added"> 588 }</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590 U_CFUNC UBool</span>
<span class="line-added"> 591 ultag_isUnicodeLocaleAttribute(const char* s, int32_t len) {</span>
<span class="line-added"> 592     /*</span>
<span class="line-added"> 593      * attribute = alphanum{3,8} ;</span>
<span class="line-added"> 594      */</span>
<span class="line-added"> 595     return _isAlphaNumericStringLimitedLength(s, len , 3, 8);</span>
<span class="line-added"> 596 }</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598 U_CFUNC UBool</span>
<span class="line-added"> 599 ultag_isUnicodeLocaleAttributes(const char* s, int32_t len) {</span>
<span class="line-added"> 600     return _isSepListOf(&amp;ultag_isUnicodeLocaleAttribute, s, len);</span>
<span class="line-added"> 601 }</span>
<span class="line-added"> 602 </span>
<span class="line-added"> 603 U_CFUNC UBool</span>
<span class="line-added"> 604 ultag_isUnicodeLocaleKey(const char* s, int32_t len) {</span>
<span class="line-added"> 605     /*</span>
<span class="line-added"> 606      * key = alphanum alpha ;</span>
<span class="line-added"> 607      */</span>
 608     if (len &lt; 0) {
 609         len = (int32_t)uprv_strlen(s);
 610     }
<a name="29" id="anc29"></a><span class="line-modified"> 611     if (len == 2 &amp;&amp; (ISALPHA(*s) || ISNUMERIC(*s)) &amp;&amp; ISALPHA(s[1])) {</span>
 612         return TRUE;
 613     }
 614     return FALSE;
 615 }
 616 
<a name="30" id="anc30"></a><span class="line-modified"> 617 U_CFUNC UBool</span>
<span class="line-modified"> 618 _isUnicodeLocaleTypeSubtag(const char*s, int32_t len) {</span>
<span class="line-modified"> 619     /*</span>
<span class="line-modified"> 620      * alphanum{3,8}</span>
<span class="line-modified"> 621      */</span>
<span class="line-modified"> 622     return _isAlphaNumericStringLimitedLength(s, len , 3, 8);</span>
<span class="line-modified"> 623 }</span>

 624 
<a name="31" id="anc31"></a><span class="line-modified"> 625 U_CFUNC UBool</span>
<span class="line-modified"> 626 ultag_isUnicodeLocaleType(const char*s, int32_t len) {</span>
<span class="line-modified"> 627     /*</span>
<span class="line-modified"> 628      * type = alphanum{3,8} (sep alphanum{3,8})* ;</span>
<span class="line-modified"> 629      */</span>
<span class="line-modified"> 630     return _isSepListOf(&amp;_isUnicodeLocaleTypeSubtag, s, len);</span>












 631 }
 632 
 633 static UBool
<a name="32" id="anc32"></a><span class="line-modified"> 634 _isTKey(const char* s, int32_t len)</span>
<span class="line-added"> 635 {</span>
 636     /*
<a name="33" id="anc33"></a><span class="line-modified"> 637      * tkey = alpha digit ;</span>
 638      */
 639     if (len &lt; 0) {
 640         len = (int32_t)uprv_strlen(s);
 641     }
<a name="34" id="anc34"></a><span class="line-modified"> 642     if (len == 2 &amp;&amp; ISALPHA(*s) &amp;&amp; ISNUMERIC(*(s + 1))) {</span>
 643         return TRUE;
 644     }
 645     return FALSE;
 646 }
 647 
 648 static UBool
<a name="35" id="anc35"></a><span class="line-modified"> 649 _isTValue(const char* s, int32_t len)</span>
<span class="line-modified"> 650 {</span>
<span class="line-modified"> 651     /*</span>
<span class="line-modified"> 652      * tvalue = (sep alphanum{3,8})+ ;</span>
<span class="line-modified"> 653      */</span>
<span class="line-modified"> 654     return _isAlphaNumericStringLimitedLength(s, len , 3, 8);</span>
<span class="line-modified"> 655 }</span>
 656 
<a name="36" id="anc36"></a><span class="line-modified"> 657 static UBool</span>
<span class="line-modified"> 658 _isTransformedExtensionSubtag(int32_t&amp; state, const char* s, int32_t len)</span>
<span class="line-modified"> 659 {</span>
<span class="line-modified"> 660     const int32_t kStart = 0;       // Start, wait for unicode_language_subtag, tkey or end</span>
<span class="line-added"> 661     const int32_t kGotLanguage = 1; // Got unicode_language_subtag, wait for unicode_script_subtag,</span>
<span class="line-added"> 662                                     // unicode_region_subtag, unicode_variant_subtag, tkey or end</span>
<span class="line-added"> 663     const int32_t kGotScript = 2;   // Got unicode_script_subtag, wait for unicode_region_subtag,</span>
<span class="line-added"> 664                                     // unicode_variant_subtag, tkey, or end</span>
<span class="line-added"> 665     const int32_t kGotRegion = 3;   // Got unicode_region_subtag, wait for unicode_variant_subtag,</span>
<span class="line-added"> 666                                     // tkey, or end.</span>
<span class="line-added"> 667     const int32_t kGotVariant = 4;  // Got unicode_variant_subtag, wait for unicode_variant_subtag</span>
<span class="line-added"> 668                                     // tkey or end.</span>
<span class="line-added"> 669     const int32_t kGotTKey = -1;    // Got tkey, wait for tvalue. ERROR if stop here.</span>
<span class="line-added"> 670     const int32_t kGotTValue = 6;   // Got tvalue, wait for tkey, tvalue or end</span>
<span class="line-added"> 671 </span>
<span class="line-added"> 672     switch (state) {</span>
<span class="line-added"> 673         case kStart:</span>
<span class="line-added"> 674             if (ultag_isLanguageSubtag(s, len)) {</span>
<span class="line-added"> 675                 state = kGotLanguage;</span>
<span class="line-added"> 676                 return TRUE;</span>
<span class="line-added"> 677             }</span>
<span class="line-added"> 678             if (_isTKey(s, len)) {</span>
<span class="line-added"> 679                 state = kGotTKey;</span>
<span class="line-added"> 680                 return TRUE;</span>
 681             }
<a name="37" id="anc37"></a><span class="line-modified"> 682             return FALSE;</span>
<span class="line-modified"> 683         case kGotLanguage:</span>
<span class="line-added"> 684             if (ultag_isScriptSubtag(s, len)) {</span>
<span class="line-added"> 685                 state = kGotScript;</span>
<span class="line-added"> 686                 return TRUE;</span>
<span class="line-added"> 687             }</span>
<span class="line-added"> 688             U_FALLTHROUGH;</span>
<span class="line-added"> 689         case kGotScript:</span>
<span class="line-added"> 690             if (ultag_isRegionSubtag(s, len)) {</span>
<span class="line-added"> 691                 state = kGotRegion;</span>
<span class="line-added"> 692                 return TRUE;</span>
<span class="line-added"> 693             }</span>
<span class="line-added"> 694             U_FALLTHROUGH;</span>
<span class="line-added"> 695         case kGotRegion:</span>
<span class="line-added"> 696             U_FALLTHROUGH;</span>
<span class="line-added"> 697         case kGotVariant:</span>
<span class="line-added"> 698             if (_isVariantSubtag(s, len)) {</span>
<span class="line-added"> 699                 state = kGotVariant;</span>
<span class="line-added"> 700                 return TRUE;</span>
<span class="line-added"> 701             }</span>
<span class="line-added"> 702             if (_isTKey(s, len)) {</span>
<span class="line-added"> 703                 state = kGotTKey;</span>
<span class="line-added"> 704                 return TRUE;</span>
 705             }
<a name="38" id="anc38"></a><span class="line-modified"> 706             return FALSE;</span>
<span class="line-modified"> 707         case kGotTKey:</span>
<span class="line-modified"> 708             if (_isTValue(s, len)) {</span>
<span class="line-modified"> 709                 state = kGotTValue;</span>
<span class="line-modified"> 710                 return TRUE;</span>
<span class="line-modified"> 711             }</span>
<span class="line-modified"> 712             return FALSE;</span>
<span class="line-modified"> 713         case kGotTValue:</span>
<span class="line-added"> 714             if (_isTKey(s, len)) {</span>
<span class="line-added"> 715                 state = kGotTKey;</span>
<span class="line-added"> 716                 return TRUE;</span>
<span class="line-added"> 717             }</span>
<span class="line-added"> 718             if (_isTValue(s, len)) {</span>
<span class="line-added"> 719                 return TRUE;</span>
<span class="line-added"> 720             }</span>
<span class="line-added"> 721             return FALSE;</span>
 722     }
<a name="39" id="anc39"></a><span class="line-modified"> 723     return FALSE;</span>
 724 }
 725 
<a name="40" id="anc40"></a><span class="line-modified"> 726 static UBool</span>
<span class="line-modified"> 727 _isUnicodeExtensionSubtag(int32_t&amp; state, const char* s, int32_t len)</span>
<span class="line-modified"> 728 {</span>
<span class="line-modified"> 729     const int32_t kStart = 0;         // Start, wait for a key or attribute or end</span>
<span class="line-modified"> 730     const int32_t kGotKey = 1;        // Got a key, wait for type or key or end</span>
<span class="line-modified"> 731     const int32_t kGotType = 2;       // Got a type, wait for key or end</span>
<span class="line-modified"> 732 </span>
<span class="line-added"> 733     switch (state) {</span>
<span class="line-added"> 734         case kStart:</span>
<span class="line-added"> 735             if (ultag_isUnicodeLocaleKey(s, len)) {</span>
<span class="line-added"> 736                 state = kGotKey;</span>
<span class="line-added"> 737                 return TRUE;</span>
<span class="line-added"> 738             }</span>
<span class="line-added"> 739             if (ultag_isUnicodeLocaleAttribute(s, len)) {</span>
<span class="line-added"> 740                 return TRUE;</span>
<span class="line-added"> 741             }</span>
<span class="line-added"> 742             return FALSE;</span>
<span class="line-added"> 743         case kGotKey:</span>
<span class="line-added"> 744             if (ultag_isUnicodeLocaleKey(s, len)) {</span>
<span class="line-added"> 745                 return TRUE;</span>
<span class="line-added"> 746             }</span>
<span class="line-added"> 747             if (_isUnicodeLocaleTypeSubtag(s, len)) {</span>
<span class="line-added"> 748                 state = kGotType;</span>
<span class="line-added"> 749                 return TRUE;</span>
<span class="line-added"> 750             }</span>
<span class="line-added"> 751             return FALSE;</span>
<span class="line-added"> 752         case kGotType:</span>
<span class="line-added"> 753             if (ultag_isUnicodeLocaleKey(s, len)) {</span>
<span class="line-added"> 754                 state = kGotKey;</span>
<span class="line-added"> 755                 return TRUE;</span>
<span class="line-added"> 756             }</span>
<span class="line-added"> 757             if (_isUnicodeLocaleTypeSubtag(s, len)) {</span>
<span class="line-added"> 758                 return TRUE;</span>
<span class="line-added"> 759             }</span>
<span class="line-added"> 760             return FALSE;</span>
 761     }
 762     return FALSE;
 763 }
 764 
<a name="41" id="anc41"></a><span class="line-modified"> 765 static UBool</span>
<span class="line-modified"> 766 _isStatefulSepListOf(UBool (*test)(int32_t&amp;, const char*, int32_t), const char* s, int32_t len)</span>
<span class="line-added"> 767 {</span>
<span class="line-added"> 768     int32_t state = 0;</span>
 769     const char* p;
<a name="42" id="anc42"></a><span class="line-added"> 770     const char* start = s;</span>
 771     int32_t subtagLen = 0;
 772 
 773     if (len &lt; 0) {
 774         len = (int32_t)uprv_strlen(s);
 775     }
 776 
 777     for (p = s; len &gt; 0; p++, len--) {
 778         if (*p == SEP) {
<a name="43" id="anc43"></a><span class="line-modified"> 779             if (!test(state, start, subtagLen)) {</span>
 780                 return FALSE;
 781             }
 782             subtagLen = 0;
<a name="44" id="anc44"></a><span class="line-modified"> 783             start = p + 1;</span>




 784         } else {
<a name="45" id="anc45"></a><span class="line-modified"> 785             subtagLen++;</span>
 786         }
 787     }
 788 
<a name="46" id="anc46"></a><span class="line-modified"> 789     if (test(state, start, subtagLen) &amp;&amp; state &gt;= 0) {</span>
<span class="line-added"> 790         return TRUE;</span>
<span class="line-added"> 791     }</span>
<span class="line-added"> 792     return FALSE;</span>
<span class="line-added"> 793 }</span>
<span class="line-added"> 794 </span>
<span class="line-added"> 795 U_CFUNC UBool</span>
<span class="line-added"> 796 ultag_isTransformedExtensionSubtags(const char* s, int32_t len)</span>
<span class="line-added"> 797 {</span>
<span class="line-added"> 798     return _isStatefulSepListOf(&amp;_isTransformedExtensionSubtag, s, len);</span>
<span class="line-added"> 799 }</span>
<span class="line-added"> 800 </span>
<span class="line-added"> 801 U_CFUNC UBool</span>
<span class="line-added"> 802 ultag_isUnicodeExtensionSubtags(const char* s, int32_t len) {</span>
<span class="line-added"> 803     return _isStatefulSepListOf(&amp;_isUnicodeExtensionSubtag, s, len);</span>
 804 }
<a name="47" id="anc47"></a><span class="line-added"> 805 </span>
<span class="line-added"> 806 </span>
 807 /*
 808 * -------------------------------------------------
 809 *
 810 * Helper functions
 811 *
 812 * -------------------------------------------------
 813 */
 814 
 815 static UBool
 816 _addVariantToList(VariantListEntry **first, VariantListEntry *var) {
 817     UBool bAdded = TRUE;
 818 
 819     if (*first == NULL) {
 820         var-&gt;next = NULL;
 821         *first = var;
 822     } else {
 823         VariantListEntry *prev, *cur;
 824         int32_t cmp;
 825 
 826         /* variants order should be preserved */
 827         prev = NULL;
 828         cur = *first;
 829         while (TRUE) {
 830             if (cur == NULL) {
 831                 prev-&gt;next = var;
 832                 var-&gt;next = NULL;
 833                 break;
 834             }
 835 
 836             /* Checking for duplicate variant */
 837             cmp = uprv_compareInvCharsAsAscii(var-&gt;variant, cur-&gt;variant);
 838             if (cmp == 0) {
 839                 /* duplicated variant */
 840                 bAdded = FALSE;
 841                 break;
 842             }
 843             prev = cur;
 844             cur = cur-&gt;next;
 845         }
 846     }
 847 
 848     return bAdded;
 849 }
 850 
 851 static UBool
 852 _addAttributeToList(AttributeListEntry **first, AttributeListEntry *attr) {
 853     UBool bAdded = TRUE;
 854 
 855     if (*first == NULL) {
 856         attr-&gt;next = NULL;
 857         *first = attr;
 858     } else {
 859         AttributeListEntry *prev, *cur;
 860         int32_t cmp;
 861 
 862         /* reorder variants in alphabetical order */
 863         prev = NULL;
 864         cur = *first;
 865         while (TRUE) {
 866             if (cur == NULL) {
 867                 prev-&gt;next = attr;
 868                 attr-&gt;next = NULL;
 869                 break;
 870             }
 871             cmp = uprv_compareInvCharsAsAscii(attr-&gt;attribute, cur-&gt;attribute);
 872             if (cmp &lt; 0) {
 873                 if (prev == NULL) {
 874                     *first = attr;
 875                 } else {
 876                     prev-&gt;next = attr;
 877                 }
 878                 attr-&gt;next = cur;
 879                 break;
 880             }
 881             if (cmp == 0) {
 882                 /* duplicated variant */
 883                 bAdded = FALSE;
 884                 break;
 885             }
 886             prev = cur;
 887             cur = cur-&gt;next;
 888         }
 889     }
 890 
 891     return bAdded;
 892 }
 893 
 894 
 895 static UBool
 896 _addExtensionToList(ExtensionListEntry **first, ExtensionListEntry *ext, UBool localeToBCP) {
 897     UBool bAdded = TRUE;
 898 
 899     if (*first == NULL) {
 900         ext-&gt;next = NULL;
 901         *first = ext;
 902     } else {
 903         ExtensionListEntry *prev, *cur;
 904         int32_t cmp;
 905 
 906         /* reorder variants in alphabetical order */
 907         prev = NULL;
 908         cur = *first;
 909         while (TRUE) {
 910             if (cur == NULL) {
 911                 prev-&gt;next = ext;
 912                 ext-&gt;next = NULL;
 913                 break;
 914             }
 915             if (localeToBCP) {
 916                 /* special handling for locale to bcp conversion */
 917                 int32_t len, curlen;
 918 
 919                 len = (int32_t)uprv_strlen(ext-&gt;key);
 920                 curlen = (int32_t)uprv_strlen(cur-&gt;key);
 921 
 922                 if (len == 1 &amp;&amp; curlen == 1) {
 923                     if (*(ext-&gt;key) == *(cur-&gt;key)) {
 924                         cmp = 0;
 925                     } else if (*(ext-&gt;key) == PRIVATEUSE) {
 926                         cmp = 1;
 927                     } else if (*(cur-&gt;key) == PRIVATEUSE) {
 928                         cmp = -1;
 929                     } else {
 930                         cmp = *(ext-&gt;key) - *(cur-&gt;key);
 931                     }
 932                 } else if (len == 1) {
 933                     cmp = *(ext-&gt;key) - LDMLEXT;
 934                 } else if (curlen == 1) {
 935                     cmp = LDMLEXT - *(cur-&gt;key);
 936                 } else {
 937                     cmp = uprv_compareInvCharsAsAscii(ext-&gt;key, cur-&gt;key);
 938                     /* Both are u extension keys - we need special handling for &#39;attribute&#39; */
 939                     if (cmp != 0) {
 940                         if (uprv_strcmp(cur-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
 941                             cmp = 1;
 942                         } else if (uprv_strcmp(ext-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
 943                             cmp = -1;
 944                         }
 945                     }
 946                 }
 947             } else {
 948                 cmp = uprv_compareInvCharsAsAscii(ext-&gt;key, cur-&gt;key);
 949             }
 950             if (cmp &lt; 0) {
 951                 if (prev == NULL) {
 952                     *first = ext;
 953                 } else {
 954                     prev-&gt;next = ext;
 955                 }
 956                 ext-&gt;next = cur;
 957                 break;
 958             }
 959             if (cmp == 0) {
 960                 /* duplicated extension key */
 961                 bAdded = FALSE;
 962                 break;
 963             }
 964             prev = cur;
 965             cur = cur-&gt;next;
 966         }
 967     }
 968 
 969     return bAdded;
 970 }
 971 
 972 static void
 973 _initializeULanguageTag(ULanguageTag* langtag) {
 974     int32_t i;
 975 
 976     langtag-&gt;buf = NULL;
 977 
 978     langtag-&gt;language = EMPTY;
 979     for (i = 0; i &lt; MAXEXTLANG; i++) {
 980         langtag-&gt;extlang[i] = NULL;
 981     }
 982 
 983     langtag-&gt;script = EMPTY;
 984     langtag-&gt;region = EMPTY;
 985 
 986     langtag-&gt;variants = NULL;
 987     langtag-&gt;extensions = NULL;
 988 
 989     langtag-&gt;grandfathered = EMPTY;
 990     langtag-&gt;privateuse = EMPTY;
 991 }
 992 
<a name="48" id="anc48"></a><span class="line-modified"> 993 static void</span>
<span class="line-modified"> 994 _appendLanguageToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UErrorCode* status) {</span>
 995     char buf[ULOC_LANG_CAPACITY];
 996     UErrorCode tmpStatus = U_ZERO_ERROR;
 997     int32_t len, i;
<a name="49" id="anc49"></a>
 998 
 999     if (U_FAILURE(*status)) {
<a name="50" id="anc50"></a><span class="line-modified">1000         return;</span>
1001     }
1002 
1003     len = uloc_getLanguage(localeID, buf, sizeof(buf), &amp;tmpStatus);
1004     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1005         if (strict) {
1006             *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="51" id="anc51"></a><span class="line-modified">1007             return;</span>
1008         }
1009         len = 0;
1010     }
1011 
1012     /* Note: returned language code is in lower case letters */
1013 
1014     if (len == 0) {
<a name="52" id="anc52"></a><span class="line-modified">1015         sink.Append(LANG_UND, LANG_UND_LEN);</span>
<span class="line-modified">1016     } else if (!ultag_isLanguageSubtag(buf, len)) {</span>



1017             /* invalid language code */
1018         if (strict) {
1019             *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="53" id="anc53"></a><span class="line-modified">1020             return;</span>



1021         }
<a name="54" id="anc54"></a><span class="line-modified">1022         sink.Append(LANG_UND, LANG_UND_LEN);</span>
1023     } else {
1024         /* resolve deprecated */
1025         for (i = 0; i &lt; UPRV_LENGTHOF(DEPRECATEDLANGS); i += 2) {
<a name="55" id="anc55"></a><span class="line-added">1026             // 2-letter deprecated subtags are listede before 3-letter</span>
<span class="line-added">1027             // ones in DEPRECATEDLANGS[]. Get out of loop on coming</span>
<span class="line-added">1028             // across the 1st 3-letter subtag, if the input is a 2-letter code.</span>
<span class="line-added">1029             // to avoid continuing to try when there&#39;s no match.</span>
<span class="line-added">1030             if (uprv_strlen(buf) &lt; uprv_strlen(DEPRECATEDLANGS[i])) break;</span>
1031             if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDLANGS[i]) == 0) {
1032                 uprv_strcpy(buf, DEPRECATEDLANGS[i + 1]);
1033                 len = (int32_t)uprv_strlen(buf);
1034                 break;
1035             }
1036         }
<a name="56" id="anc56"></a><span class="line-modified">1037         sink.Append(buf, len);</span>



1038     }
<a name="57" id="anc57"></a>

1039 }
1040 
<a name="58" id="anc58"></a><span class="line-modified">1041 static void</span>
<span class="line-modified">1042 _appendScriptToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UErrorCode* status) {</span>
1043     char buf[ULOC_SCRIPT_CAPACITY];
1044     UErrorCode tmpStatus = U_ZERO_ERROR;
1045     int32_t len;
<a name="59" id="anc59"></a>
1046 
1047     if (U_FAILURE(*status)) {
<a name="60" id="anc60"></a><span class="line-modified">1048         return;</span>
1049     }
1050 
1051     len = uloc_getScript(localeID, buf, sizeof(buf), &amp;tmpStatus);
1052     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1053         if (strict) {
1054             *status = U_ILLEGAL_ARGUMENT_ERROR;
1055         }
<a name="61" id="anc61"></a><span class="line-modified">1056         return;</span>
1057     }
1058 
1059     if (len &gt; 0) {
<a name="62" id="anc62"></a><span class="line-modified">1060         if (!ultag_isScriptSubtag(buf, len)) {</span>
1061             /* invalid script code */
1062             if (strict) {
1063                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1064             }
<a name="63" id="anc63"></a><span class="line-modified">1065             return;</span>
1066         } else {
<a name="64" id="anc64"></a><span class="line-modified">1067             sink.Append(&quot;-&quot;, 1);</span>
<span class="line-modified">1068             sink.Append(buf, len);</span>







1069         }
1070     }
<a name="65" id="anc65"></a>

1071 }
1072 
<a name="66" id="anc66"></a><span class="line-modified">1073 static void</span>
<span class="line-modified">1074 _appendRegionToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UErrorCode* status) {</span>
1075     char buf[ULOC_COUNTRY_CAPACITY];
1076     UErrorCode tmpStatus = U_ZERO_ERROR;
1077     int32_t len;
<a name="67" id="anc67"></a>
1078 
1079     if (U_FAILURE(*status)) {
<a name="68" id="anc68"></a><span class="line-modified">1080         return;</span>
1081     }
1082 
1083     len = uloc_getCountry(localeID, buf, sizeof(buf), &amp;tmpStatus);
1084     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1085         if (strict) {
1086             *status = U_ILLEGAL_ARGUMENT_ERROR;
1087         }
<a name="69" id="anc69"></a><span class="line-modified">1088         return;</span>
1089     }
1090 
1091     if (len &gt; 0) {
<a name="70" id="anc70"></a><span class="line-modified">1092         if (!ultag_isRegionSubtag(buf, len)) {</span>
1093             /* invalid region code */
1094             if (strict) {
1095                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1096             }
<a name="71" id="anc71"></a><span class="line-modified">1097             return;</span>
1098         } else {
<a name="72" id="anc72"></a><span class="line-modified">1099             sink.Append(&quot;-&quot;, 1);</span>
<span class="line-modified">1100             /* resolve deprecated */</span>
<span class="line-modified">1101             for (int i = 0; i &lt; UPRV_LENGTHOF(DEPRECATEDREGIONS); i += 2) {</span>
<span class="line-modified">1102                 if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDREGIONS[i]) == 0) {</span>
<span class="line-modified">1103                     uprv_strcpy(buf, DEPRECATEDREGIONS[i + 1]);</span>
<span class="line-modified">1104                     len = (int32_t)uprv_strlen(buf);</span>
<span class="line-modified">1105                     break;</span>
<span class="line-added">1106                 }</span>
1107             }
<a name="73" id="anc73"></a><span class="line-modified">1108             sink.Append(buf, len);</span>
1109         }
1110     }
<a name="74" id="anc74"></a>

1111 }
1112 
<a name="75" id="anc75"></a><span class="line-modified">1113 static void</span>
<span class="line-modified">1114 _appendVariantsToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UBool *hadPosix, UErrorCode* status) {</span>
1115     char buf[ULOC_FULLNAME_CAPACITY];
1116     UErrorCode tmpStatus = U_ZERO_ERROR;
1117     int32_t len, i;
<a name="76" id="anc76"></a>
1118 
1119     if (U_FAILURE(*status)) {
<a name="77" id="anc77"></a><span class="line-modified">1120         return;</span>
1121     }
1122 
1123     len = uloc_getVariant(localeID, buf, sizeof(buf), &amp;tmpStatus);
1124     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1125         if (strict) {
1126             *status = U_ILLEGAL_ARGUMENT_ERROR;
1127         }
<a name="78" id="anc78"></a><span class="line-modified">1128         return;</span>
1129     }
1130 
1131     if (len &gt; 0) {
1132         char *p, *pVar;
1133         UBool bNext = TRUE;
1134         VariantListEntry *var;
1135         VariantListEntry *varFirst = NULL;
1136 
1137         pVar = NULL;
1138         p = buf;
1139         while (bNext) {
1140             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
1141                 if (*p == 0) {
1142                     bNext = FALSE;
1143                 } else {
1144                     *p = 0; /* terminate */
1145                 }
1146                 if (pVar == NULL) {
1147                     if (strict) {
1148                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1149                         break;
1150                     }
1151                     /* ignore empty variant */
1152                 } else {
1153                     /* ICU uses upper case letters for variants, but
1154                        the canonical format is lowercase in BCP47 */
1155                     for (i = 0; *(pVar + i) != 0; i++) {
1156                         *(pVar + i) = uprv_tolower(*(pVar + i));
1157                     }
1158 
1159                     /* validate */
1160                     if (_isVariantSubtag(pVar, -1)) {
1161                         if (uprv_strcmp(pVar,POSIX_VALUE) || len != (int32_t)uprv_strlen(POSIX_VALUE)) {
1162                             /* emit the variant to the list */
1163                             var = (VariantListEntry*)uprv_malloc(sizeof(VariantListEntry));
1164                             if (var == NULL) {
1165                                 *status = U_MEMORY_ALLOCATION_ERROR;
1166                                 break;
1167                             }
1168                             var-&gt;variant = pVar;
1169                             if (!_addVariantToList(&amp;varFirst, var)) {
1170                                 /* duplicated variant */
1171                                 uprv_free(var);
1172                                 if (strict) {
1173                                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1174                                     break;
1175                                 }
1176                             }
1177                         } else {
1178                             /* Special handling for POSIX variant, need to remember that we had it and then */
1179                             /* treat it like an extension later. */
1180                             *hadPosix = TRUE;
1181                         }
1182                     } else if (strict) {
1183                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1184                         break;
1185                     } else if (_isPrivateuseValueSubtag(pVar, -1)) {
1186                         /* Handle private use subtags separately */
1187                         break;
1188                     }
1189                 }
1190                 /* reset variant starting position */
1191                 pVar = NULL;
1192             } else if (pVar == NULL) {
1193                 pVar = p;
1194             }
1195             p++;
1196         }
1197 
1198         if (U_SUCCESS(*status)) {
1199             if (varFirst != NULL) {
1200                 int32_t varLen;
1201 
1202                 /* write out validated/normalized variants to the target */
1203                 var = varFirst;
1204                 while (var != NULL) {
<a name="79" id="anc79"></a><span class="line-modified">1205                     sink.Append(&quot;-&quot;, 1);</span>



1206                     varLen = (int32_t)uprv_strlen(var-&gt;variant);
<a name="80" id="anc80"></a><span class="line-modified">1207                     sink.Append(var-&gt;variant, varLen);</span>



1208                     var = var-&gt;next;
1209                 }
1210             }
1211         }
1212 
1213         /* clean up */
1214         var = varFirst;
1215         while (var != NULL) {
1216             VariantListEntry *tmpVar = var-&gt;next;
1217             uprv_free(var);
1218             var = tmpVar;
1219         }
1220 
1221         if (U_FAILURE(*status)) {
<a name="81" id="anc81"></a><span class="line-modified">1222             return;</span>
1223         }
1224     }
<a name="82" id="anc82"></a>


1225 }
1226 
<a name="83" id="anc83"></a><span class="line-modified">1227 static void</span>
<span class="line-modified">1228 _appendKeywordsToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UBool hadPosix, UErrorCode* status) {</span>

1229     char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY] = { 0 };
1230     int32_t attrBufLength = 0;
<a name="84" id="anc84"></a>

1231 
<a name="85" id="anc85"></a><span class="line-modified">1232     icu::MemoryPool&lt;AttributeListEntry&gt; attrPool;</span>
<span class="line-added">1233     icu::MemoryPool&lt;ExtensionListEntry&gt; extPool;</span>
<span class="line-added">1234     icu::MemoryPool&lt;icu::CharString&gt; strPool;</span>
<span class="line-added">1235 </span>
<span class="line-added">1236     icu::LocalUEnumerationPointer keywordEnum(uloc_openKeywords(localeID, status));</span>
1237     if (U_FAILURE(*status) &amp;&amp; !hadPosix) {
<a name="86" id="anc86"></a><span class="line-modified">1238         return;</span>

1239     }
<a name="87" id="anc87"></a><span class="line-modified">1240     if (keywordEnum.isValid() || hadPosix) {</span>
1241         /* reorder extensions */
1242         int32_t len;
1243         const char *key;
1244         ExtensionListEntry *firstExt = NULL;
1245         ExtensionListEntry *ext;
1246         AttributeListEntry *firstAttr = NULL;
1247         AttributeListEntry *attr;
<a name="88" id="anc88"></a><span class="line-modified">1248         icu::MemoryPool&lt;icu::CharString&gt; extBufPool;</span>



1249         const char *bcpKey=nullptr, *bcpValue=nullptr;
1250         UErrorCode tmpStatus = U_ZERO_ERROR;
1251         int32_t keylen;
1252         UBool isBcpUExt;
1253 
1254         while (TRUE) {
<a name="89" id="anc89"></a><span class="line-modified">1255             icu::CharString buf;</span>
<span class="line-added">1256             key = uenum_next(keywordEnum.getAlias(), NULL, status);</span>
1257             if (key == NULL) {
1258                 break;
1259             }
<a name="90" id="anc90"></a><span class="line-modified">1260             char* buffer;</span>
<span class="line-modified">1261             int32_t resultCapacity = ULOC_KEYWORD_AND_VALUES_CAPACITY;</span>
<span class="line-modified">1262 </span>
<span class="line-added">1263             for (;;) {</span>
<span class="line-added">1264                 buffer = buf.getAppendBuffer(</span>
<span class="line-added">1265                         /*minCapacity=*/resultCapacity,</span>
<span class="line-added">1266                         /*desiredCapacityHint=*/resultCapacity,</span>
<span class="line-added">1267                         resultCapacity,</span>
<span class="line-added">1268                         tmpStatus);</span>
<span class="line-added">1269 </span>
<span class="line-added">1270                 if (U_FAILURE(tmpStatus)) {</span>
<span class="line-added">1271                     break;</span>
<span class="line-added">1272                 }</span>
<span class="line-added">1273 </span>
<span class="line-added">1274                 len = uloc_getKeywordValue(</span>
<span class="line-added">1275                         localeID, key, buffer, resultCapacity, &amp;tmpStatus);</span>
<span class="line-added">1276 </span>
<span class="line-added">1277                 if (tmpStatus != U_BUFFER_OVERFLOW_ERROR) {</span>
<span class="line-added">1278                     break;</span>
<span class="line-added">1279                 }</span>
<span class="line-added">1280 </span>
<span class="line-added">1281                 resultCapacity = len;</span>
<span class="line-added">1282                 tmpStatus = U_ZERO_ERROR;</span>
<span class="line-added">1283             }</span>
<span class="line-added">1284 </span>
<span class="line-added">1285             if (U_FAILURE(tmpStatus)) {</span>
<span class="line-added">1286                 if (tmpStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">1287                     *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1288                     break;</span>
<span class="line-added">1289                 }</span>
1290                 if (strict) {
1291                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1292                     break;
1293                 }
1294                 /* ignore this keyword */
1295                 tmpStatus = U_ZERO_ERROR;
1296                 continue;
1297             }
1298 
<a name="91" id="anc91"></a><span class="line-added">1299             buf.append(buffer, len, tmpStatus);</span>
<span class="line-added">1300             if (tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {</span>
<span class="line-added">1301                 tmpStatus = U_ZERO_ERROR;  // Terminators provided by CharString.</span>
<span class="line-added">1302             }</span>
<span class="line-added">1303 </span>
1304             keylen = (int32_t)uprv_strlen(key);
1305             isBcpUExt = (keylen &gt; 1);
1306 
1307             /* special keyword used for representing Unicode locale attributes */
1308             if (uprv_strcmp(key, LOCALE_ATTRIBUTE_KEY) == 0) {
1309                 if (len &gt; 0) {
1310                     int32_t i = 0;
1311                     while (TRUE) {
1312                         attrBufLength = 0;
1313                         for (; i &lt; len; i++) {
1314                             if (buf[i] != &#39;-&#39;) {
1315                                 attrBuf[attrBufLength++] = buf[i];
1316                             } else {
1317                                 i++;
1318                                 break;
1319                             }
1320                         }
1321                         if (attrBufLength &gt; 0) {
1322                             attrBuf[attrBufLength] = 0;
1323 
1324                         } else if (i &gt;= len){
1325                             break;
1326                         }
1327 
1328                         /* create AttributeListEntry */
<a name="92" id="anc92"></a><span class="line-modified">1329                         attr = attrPool.create();</span>
1330                         if (attr == NULL) {
1331                             *status = U_MEMORY_ALLOCATION_ERROR;
1332                             break;
1333                         }
<a name="93" id="anc93"></a><span class="line-modified">1334                         icu::CharString* attrValue =</span>
<span class="line-added">1335                                 strPool.create(attrBuf, attrBufLength, *status);</span>
1336                         if (attrValue == NULL) {
1337                             *status = U_MEMORY_ALLOCATION_ERROR;
1338                             break;
1339                         }
<a name="94" id="anc94"></a><span class="line-modified">1340                         if (U_FAILURE(*status)) {</span>
<span class="line-modified">1341                             break;</span>
<span class="line-added">1342                         }</span>
<span class="line-added">1343                         attr-&gt;attribute = attrValue-&gt;data();</span>
1344 
1345                         if (!_addAttributeToList(&amp;firstAttr, attr)) {
<a name="95" id="anc95"></a>

1346                             if (strict) {
1347                                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1348                                 break;
1349                             }
1350                         }
1351                     }
1352                     /* for a place holder ExtensionListEntry */
1353                     bcpKey = LOCALE_ATTRIBUTE_KEY;
1354                     bcpValue = NULL;
1355                 }
1356             } else if (isBcpUExt) {
1357                 bcpKey = uloc_toUnicodeLocaleKey(key);
1358                 if (bcpKey == NULL) {
1359                     if (strict) {
1360                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1361                         break;
1362                     }
1363                     continue;
1364                 }
1365 
1366                 /* we&#39;ve checked buf is null-terminated above */
<a name="96" id="anc96"></a><span class="line-modified">1367                 bcpValue = uloc_toUnicodeLocaleType(key, buf.data());</span>
1368                 if (bcpValue == NULL) {
1369                     if (strict) {
1370                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1371                         break;
1372                     }
1373                     continue;
1374                 }
<a name="97" id="anc97"></a><span class="line-modified">1375                 if (bcpValue == buf.data()) {</span>
1376                     /*
1377                     When uloc_toUnicodeLocaleType(key, buf) returns the
1378                     input value as is, the value is well-formed, but has
1379                     no known mapping. This implementation normalizes the
<a name="98" id="anc98"></a><span class="line-modified">1380                     value to lower case</span>
1381                     */
<a name="99" id="anc99"></a><span class="line-added">1382                     icu::CharString* extBuf = extBufPool.create();</span>
<span class="line-added">1383                     if (extBuf == nullptr) {</span>
<span class="line-added">1384                         *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1385                         break;</span>
<span class="line-added">1386                     }</span>
1387                     int32_t bcpValueLen = static_cast&lt;int32_t&gt;(uprv_strlen(bcpValue));
<a name="100" id="anc100"></a><span class="line-modified">1388                     int32_t resultCapacity;</span>
<span class="line-modified">1389                     char* pExtBuf = extBuf-&gt;getAppendBuffer(</span>
<span class="line-modified">1390                             /*minCapacity=*/bcpValueLen,</span>
<span class="line-added">1391                             /*desiredCapacityHint=*/bcpValueLen,</span>
<span class="line-added">1392                             resultCapacity,</span>
<span class="line-added">1393                             tmpStatus);</span>
<span class="line-added">1394                     if (U_FAILURE(tmpStatus)) {</span>
<span class="line-added">1395                         *status = tmpStatus;</span>
<span class="line-added">1396                         break;</span>
<span class="line-added">1397                     }</span>
1398 
<a name="101" id="anc101"></a><span class="line-modified">1399                     uprv_strcpy(pExtBuf, bcpValue);</span>
<span class="line-added">1400                     T_CString_toLowerCase(pExtBuf);</span>
1401 
<a name="102" id="anc102"></a><span class="line-modified">1402                     extBuf-&gt;append(pExtBuf, bcpValueLen, tmpStatus);</span>
<span class="line-modified">1403                     if (U_FAILURE(tmpStatus)) {</span>
<span class="line-modified">1404                         *status = tmpStatus;</span>
<span class="line-modified">1405                         break;</span>




1406                     }
<a name="103" id="anc103"></a><span class="line-added">1407 </span>
<span class="line-added">1408                     bcpValue = extBuf-&gt;data();</span>
1409                 }
1410             } else {
1411                 if (*key == PRIVATEUSE) {
<a name="104" id="anc104"></a><span class="line-modified">1412                     if (!ultag_isPrivateuseValueSubtags(buf.data(), len)) {</span>
1413                         if (strict) {
1414                             *status = U_ILLEGAL_ARGUMENT_ERROR;
1415                             break;
1416                         }
1417                         continue;
1418                     }
1419                 } else {
<a name="105" id="anc105"></a><span class="line-modified">1420                     if (!_isExtensionSingleton(key, keylen) || !ultag_isExtensionSubtags(buf.data(), len)) {</span>
1421                         if (strict) {
1422                             *status = U_ILLEGAL_ARGUMENT_ERROR;
1423                             break;
1424                         }
1425                         continue;
1426                     }
1427                 }
1428                 bcpKey = key;
<a name="106" id="anc106"></a><span class="line-modified">1429                 icu::CharString* extBuf =</span>
<span class="line-modified">1430                     extBufPool.create(buf.data(), len, tmpStatus);</span>
<span class="line-modified">1431                 if (extBuf == nullptr) {</span>
<span class="line-modified">1432                     *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1433                     break;</span>
<span class="line-modified">1434                 }</span>
<span class="line-modified">1435                 if (U_FAILURE(tmpStatus)) {</span>
<span class="line-modified">1436                     *status = tmpStatus;</span>




1437                     break;
1438                 }
<a name="107" id="anc107"></a><span class="line-added">1439                 bcpValue = extBuf-&gt;data();</span>
1440             }
1441 
1442             /* create ExtensionListEntry */
<a name="108" id="anc108"></a><span class="line-modified">1443             ext = extPool.create();</span>
1444             if (ext == NULL) {
1445                 *status = U_MEMORY_ALLOCATION_ERROR;
1446                 break;
1447             }
1448             ext-&gt;key = bcpKey;
1449             ext-&gt;value = bcpValue;
1450 
1451             if (!_addExtensionToList(&amp;firstExt, ext, TRUE)) {
<a name="109" id="anc109"></a>
1452                 if (strict) {
1453                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1454                     break;
1455                 }
1456             }
1457         }
1458 
1459         /* Special handling for POSIX variant - add the keywords for POSIX */
1460         if (hadPosix) {
1461             /* create ExtensionListEntry for POSIX */
<a name="110" id="anc110"></a><span class="line-modified">1462             ext = extPool.create();</span>
1463             if (ext == NULL) {
1464                 *status = U_MEMORY_ALLOCATION_ERROR;
<a name="111" id="anc111"></a><span class="line-modified">1465                 return;</span>
1466             }
1467             ext-&gt;key = POSIX_KEY;
1468             ext-&gt;value = POSIX_VALUE;
1469 
1470             if (!_addExtensionToList(&amp;firstExt, ext, TRUE)) {
<a name="112" id="anc112"></a><span class="line-modified">1471                 // Silently ignore errors.</span>
1472             }
1473         }
1474 
1475         if (U_SUCCESS(*status) &amp;&amp; (firstExt != NULL || firstAttr != NULL)) {
1476             UBool startLDMLExtension = FALSE;
1477             for (ext = firstExt; ext; ext = ext-&gt;next) {
1478                 if (!startLDMLExtension &amp;&amp; uprv_strlen(ext-&gt;key) &gt; 1) {
1479                     /* first LDML u singlton extension */
<a name="113" id="anc113"></a><span class="line-modified">1480                    sink.Append(&quot;-u&quot;, 2);</span>








1481                    startLDMLExtension = TRUE;
1482                 }
1483 
1484                 /* write out the sorted BCP47 attributes, extensions and private use */
1485                 if (uprv_strcmp(ext-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
1486                     /* write the value for the attributes */
1487                     for (attr = firstAttr; attr; attr = attr-&gt;next) {
<a name="114" id="anc114"></a><span class="line-modified">1488                         sink.Append(&quot;-&quot;, 1);</span>
<span class="line-modified">1489                         sink.Append(</span>
<span class="line-modified">1490                                 attr-&gt;attribute, static_cast&lt;int32_t&gt;(uprv_strlen(attr-&gt;attribute)));</span>






1491                     }
1492                 } else {
<a name="115" id="anc115"></a><span class="line-modified">1493                     sink.Append(&quot;-&quot;, 1);</span>
<span class="line-modified">1494                     sink.Append(ext-&gt;key, static_cast&lt;int32_t&gt;(uprv_strlen(ext-&gt;key)));</span>
<span class="line-modified">1495                     sink.Append(&quot;-&quot;, 1);</span>
<span class="line-modified">1496                     sink.Append(ext-&gt;value, static_cast&lt;int32_t&gt;(uprv_strlen(ext-&gt;value)));</span>














1497                 }
1498             }
1499         }
<a name="116" id="anc116"></a>






















1500     }
<a name="117" id="anc117"></a>

1501 }
1502 
1503 /**
1504  * Append keywords parsed from LDML extension value
1505  * e.g. &quot;u-ca-gregory-co-trad&quot; -&gt; {calendar = gregorian} {collation = traditional}
1506  * Note: char* buf is used for storing keywords
1507  */
1508 static void
<a name="118" id="anc118"></a><span class="line-modified">1509 _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendTo, icu::MemoryPool&lt;ExtensionListEntry&gt;&amp; extPool, icu::MemoryPool&lt;icu::CharString&gt;&amp; kwdBuf, UBool *posixVariant, UErrorCode *status) {</span>
1510     const char *pTag;   /* beginning of current subtag */
1511     const char *pKwds;  /* beginning of key-type pairs */
1512     UBool variantExists = *posixVariant;
1513 
1514     ExtensionListEntry *kwdFirst = NULL;    /* first LDML keyword */
1515     ExtensionListEntry *kwd, *nextKwd;
1516 
<a name="119" id="anc119"></a>


1517     int32_t len;
<a name="120" id="anc120"></a>



1518 
1519     /* Reset the posixVariant value */
1520     *posixVariant = FALSE;
1521 
1522     pTag = ldmlext;
1523     pKwds = NULL;
1524 
<a name="121" id="anc121"></a><span class="line-modified">1525     {</span>
<span class="line-modified">1526         AttributeListEntry *attrFirst = NULL;   /* first attribute */</span>
<span class="line-modified">1527         AttributeListEntry *attr, *nextAttr;</span>

1528 
<a name="122" id="anc122"></a><span class="line-modified">1529         char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];</span>
<span class="line-modified">1530         int32_t attrBufIdx = 0;</span>


1531 
<a name="123" id="anc123"></a><span class="line-modified">1532         icu::MemoryPool&lt;AttributeListEntry&gt; attrPool;</span>





1533 
<a name="124" id="anc124"></a><span class="line-modified">1534         /* Iterate through u extension attributes */</span>
<span class="line-modified">1535         while (*pTag) {</span>
<span class="line-modified">1536             /* locate next separator char */</span>
<span class="line-modified">1537             for (len = 0; *(pTag + len) &amp;&amp; *(pTag + len) != SEP; len++);</span>





1538 
<a name="125" id="anc125"></a><span class="line-modified">1539             if (ultag_isUnicodeLocaleKey(pTag, len)) {</span>
<span class="line-modified">1540                 pKwds = pTag;</span>
<span class="line-modified">1541                 break;</span>
<span class="line-modified">1542             }</span>

1543 
<a name="126" id="anc126"></a><span class="line-modified">1544             /* add this attribute to the list */</span>
<span class="line-modified">1545             attr = attrPool.create();</span>
<span class="line-modified">1546             if (attr == NULL) {</span>
<span class="line-modified">1547                 *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1548                 return;</span>
<span class="line-modified">1549             }</span>

1550 
<a name="127" id="anc127"></a><span class="line-modified">1551             if (len &lt; (int32_t)sizeof(attrBuf) - attrBufIdx) {</span>
<span class="line-modified">1552                 uprv_memcpy(&amp;attrBuf[attrBufIdx], pTag, len);</span>
<span class="line-added">1553                 attrBuf[attrBufIdx + len] = 0;</span>
<span class="line-added">1554                 attr-&gt;attribute = &amp;attrBuf[attrBufIdx];</span>
<span class="line-added">1555                 attrBufIdx += (len + 1);</span>
<span class="line-added">1556             } else {</span>
<span class="line-added">1557                 *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1558                 return;</span>
<span class="line-added">1559             }</span>
1560 
<a name="128" id="anc128"></a><span class="line-modified">1561             if (!_addAttributeToList(&amp;attrFirst, attr)) {</span>
<span class="line-modified">1562                 *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">1563                 return;</span>
<span class="line-modified">1564             }</span>

1565 
<a name="129" id="anc129"></a><span class="line-modified">1566             /* next tag */</span>
<span class="line-modified">1567             pTag += len;</span>
<span class="line-modified">1568             if (*pTag) {</span>
<span class="line-modified">1569                 /* next to the separator */</span>
<span class="line-added">1570                 pTag++;</span>
<span class="line-added">1571             }</span>
1572         }
1573 
<a name="130" id="anc130"></a><span class="line-modified">1574         if (attrFirst) {</span>
<span class="line-modified">1575             /* emit attributes as an LDML keyword, e.g. attribute=attr1-attr2 */</span>
1576 
<a name="131" id="anc131"></a><span class="line-modified">1577             kwd = extPool.create();</span>
<span class="line-modified">1578             if (kwd == NULL) {</span>
<span class="line-modified">1579                 *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1580                 return;</span>





1581             }
1582 
<a name="132" id="anc132"></a><span class="line-modified">1583             icu::CharString* value = kwdBuf.create();</span>
<span class="line-modified">1584             if (value == NULL) {</span>
<span class="line-modified">1585                 *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1586                 return;</span>
<span class="line-added">1587             }</span>
1588 
<a name="133" id="anc133"></a><span class="line-modified">1589             /* attribute subtags sorted in alphabetical order as type */</span>
<span class="line-modified">1590             attr = attrFirst;</span>
<span class="line-modified">1591             while (attr != NULL) {</span>
<span class="line-modified">1592                 nextAttr = attr-&gt;next;</span>
<span class="line-added">1593                 if (attr != attrFirst) {</span>
<span class="line-added">1594                     value-&gt;append(&#39;-&#39;, *status);</span>
<span class="line-added">1595                 }</span>
<span class="line-added">1596                 value-&gt;append(attr-&gt;attribute, *status);</span>
<span class="line-added">1597                 attr = nextAttr;</span>
<span class="line-added">1598             }</span>
<span class="line-added">1599             if (U_FAILURE(*status)) {</span>
<span class="line-added">1600                 return;</span>
<span class="line-added">1601             }</span>
1602 
<a name="134" id="anc134"></a><span class="line-modified">1603             kwd-&gt;key = LOCALE_ATTRIBUTE_KEY;</span>
<span class="line-modified">1604             kwd-&gt;value = value-&gt;data();</span>



1605 
<a name="135" id="anc135"></a><span class="line-modified">1606             if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {</span>
<span class="line-modified">1607                 *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">1608                 return;</span>
<span class="line-modified">1609             }</span>


1610         }
<a name="136" id="anc136"></a>
1611     }
1612 
1613     if (pKwds) {
1614         const char *pBcpKey = NULL;     /* u extenstion key subtag */
1615         const char *pBcpType = NULL;    /* beginning of u extension type subtag(s) */
1616         int32_t bcpKeyLen = 0;
1617         int32_t bcpTypeLen = 0;
1618         UBool isDone = FALSE;
1619 
1620         pTag = pKwds;
1621         /* BCP47 representation of LDML key/type pairs */
1622         while (!isDone) {
1623             const char *pNextBcpKey = NULL;
1624             int32_t nextBcpKeyLen = 0;
1625             UBool emitKeyword = FALSE;
1626 
1627             if (*pTag) {
1628                 /* locate next separator char */
1629                 for (len = 0; *(pTag + len) &amp;&amp; *(pTag + len) != SEP; len++);
1630 
1631                 if (ultag_isUnicodeLocaleKey(pTag, len)) {
1632                     if (pBcpKey) {
1633                         emitKeyword = TRUE;
1634                         pNextBcpKey = pTag;
1635                         nextBcpKeyLen = len;
1636                     } else {
1637                         pBcpKey = pTag;
1638                         bcpKeyLen = len;
1639                     }
1640                 } else {
1641                     U_ASSERT(pBcpKey != NULL);
1642                     /* within LDML type subtags */
1643                     if (pBcpType) {
1644                         bcpTypeLen += (len + 1);
1645                     } else {
1646                         pBcpType = pTag;
1647                         bcpTypeLen = len;
1648                     }
1649                 }
1650 
1651                 /* next tag */
1652                 pTag += len;
1653                 if (*pTag) {
1654                     /* next to the separator */
1655                     pTag++;
1656                 }
1657             } else {
1658                 /* processing last one */
1659                 emitKeyword = TRUE;
1660                 isDone = TRUE;
1661             }
1662 
1663             if (emitKeyword) {
1664                 const char *pKey = NULL;    /* LDML key */
1665                 const char *pType = NULL;   /* LDML type */
1666 
1667                 char bcpKeyBuf[9];          /* BCP key length is always 2 for now */
1668 
1669                 U_ASSERT(pBcpKey != NULL);
1670 
1671                 if (bcpKeyLen &gt;= (int32_t)sizeof(bcpKeyBuf)) {
1672                     /* the BCP key is invalid */
1673                     *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="137" id="anc137"></a><span class="line-modified">1674                     return;</span>
1675                 }
1676 
1677                 uprv_strncpy(bcpKeyBuf, pBcpKey, bcpKeyLen);
1678                 bcpKeyBuf[bcpKeyLen] = 0;
1679 
1680                 /* u extension key to LDML key */
1681                 pKey = uloc_toLegacyKey(bcpKeyBuf);
1682                 if (pKey == NULL) {
1683                     *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="138" id="anc138"></a><span class="line-modified">1684                     return;</span>
1685                 }
1686                 if (pKey == bcpKeyBuf) {
1687                     /*
1688                     The key returned by toLegacyKey points to the input buffer.
1689                     We normalize the result key to lower case.
1690                     */
1691                     T_CString_toLowerCase(bcpKeyBuf);
<a name="139" id="anc139"></a><span class="line-modified">1692                     icu::CharString* key = kwdBuf.create(bcpKeyBuf, bcpKeyLen, *status);</span>
<span class="line-modified">1693                     if (key == NULL) {</span>
<span class="line-modified">1694                         *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1695                         return;</span>
<span class="line-modified">1696                     }</span>
<span class="line-modified">1697                     if (U_FAILURE(*status)) {</span>
<span class="line-modified">1698                         return;</span>


1699                     }
<a name="140" id="anc140"></a><span class="line-added">1700                     pKey = key-&gt;data();</span>
1701                 }
1702 
1703                 if (pBcpType) {
1704                     char bcpTypeBuf[128];       /* practically long enough even considering multiple subtag type */
1705                     if (bcpTypeLen &gt;= (int32_t)sizeof(bcpTypeBuf)) {
1706                         /* the BCP type is too long */
1707                         *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="141" id="anc141"></a><span class="line-modified">1708                         return;</span>
1709                     }
1710 
1711                     uprv_strncpy(bcpTypeBuf, pBcpType, bcpTypeLen);
1712                     bcpTypeBuf[bcpTypeLen] = 0;
1713 
1714                     /* BCP type to locale type */
1715                     pType = uloc_toLegacyType(pKey, bcpTypeBuf);
1716                     if (pType == NULL) {
1717                         *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="142" id="anc142"></a><span class="line-modified">1718                         return;</span>
1719                     }
1720                     if (pType == bcpTypeBuf) {
1721                         /*
1722                         The type returned by toLegacyType points to the input buffer.
1723                         We normalize the result type to lower case.
1724                         */
1725                         /* normalize to lower case */
1726                         T_CString_toLowerCase(bcpTypeBuf);
<a name="143" id="anc143"></a><span class="line-modified">1727                         icu::CharString* type = kwdBuf.create(bcpTypeBuf, bcpTypeLen, *status);</span>
<span class="line-modified">1728                         if (type == NULL) {</span>
<span class="line-modified">1729                             *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1730                             return;</span>





1731                         }
<a name="144" id="anc144"></a><span class="line-added">1732                         if (U_FAILURE(*status)) {</span>
<span class="line-added">1733                             return;</span>
<span class="line-added">1734                         }</span>
<span class="line-added">1735                         pType = type-&gt;data();</span>
1736                     }
1737                 } else {
1738                     /* typeless - default type value is &quot;yes&quot; */
1739                     pType = LOCALE_TYPE_YES;
1740                 }
1741 
1742                 /* Special handling for u-va-posix, since we want to treat this as a variant,
1743                    not as a keyword */
1744                 if (!variantExists &amp;&amp; !uprv_strcmp(pKey, POSIX_KEY) &amp;&amp; !uprv_strcmp(pType, POSIX_VALUE) ) {
1745                     *posixVariant = TRUE;
1746                 } else {
1747                     /* create an ExtensionListEntry for this keyword */
<a name="145" id="anc145"></a><span class="line-modified">1748                     kwd = extPool.create();</span>
1749                     if (kwd == NULL) {
1750                         *status = U_MEMORY_ALLOCATION_ERROR;
<a name="146" id="anc146"></a><span class="line-modified">1751                         return;</span>
1752                     }
1753 
1754                     kwd-&gt;key = pKey;
1755                     kwd-&gt;value = pType;
1756 
1757                     if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
<a name="147" id="anc147"></a><span class="line-modified">1758                         // duplicate keyword is allowed, Only the first</span>
<span class="line-modified">1759                         // is honored.</span>

1760                     }
1761                 }
1762 
1763                 pBcpKey = pNextBcpKey;
1764                 bcpKeyLen = pNextBcpKey != NULL ? nextBcpKeyLen : 0;
1765                 pBcpType = NULL;
1766                 bcpTypeLen = 0;
1767             }
1768         }
1769     }
1770 
1771     kwd = kwdFirst;
1772     while (kwd != NULL) {
1773         nextKwd = kwd-&gt;next;
1774         _addExtensionToList(appendTo, kwd, FALSE);
1775         kwd = nextKwd;
1776     }
<a name="148" id="anc148"></a>
















1777 }
1778 
1779 
<a name="149" id="anc149"></a><span class="line-modified">1780 static void</span>
<span class="line-modified">1781 _appendKeywords(ULanguageTag* langtag, icu::ByteSink&amp; sink, UErrorCode* status) {</span>

1782     int32_t i, n;
1783     int32_t len;
1784     ExtensionListEntry *kwdFirst = NULL;
1785     ExtensionListEntry *kwd;
1786     const char *key, *type;
<a name="150" id="anc150"></a><span class="line-modified">1787     icu::MemoryPool&lt;ExtensionListEntry&gt; extPool;</span>
<span class="line-modified">1788     icu::MemoryPool&lt;icu::CharString&gt; kwdBuf;</span>
1789     UBool posixVariant = FALSE;
1790 
1791     if (U_FAILURE(*status)) {
<a name="151" id="anc151"></a><span class="line-modified">1792         return;</span>






1793     }
1794 
1795     /* Determine if variants already exists */
1796     if (ultag_getVariantsSize(langtag)) {
1797         posixVariant = TRUE;
1798     }
1799 
1800     n = ultag_getExtensionsSize(langtag);
1801 
1802     /* resolve locale keywords and reordering keys */
1803     for (i = 0; i &lt; n; i++) {
1804         key = ultag_getExtensionKey(langtag, i);
1805         type = ultag_getExtensionValue(langtag, i);
1806         if (*key == LDMLEXT) {
<a name="152" id="anc152"></a><span class="line-modified">1807             _appendLDMLExtensionAsKeywords(type, &amp;kwdFirst, extPool, kwdBuf, &amp;posixVariant, status);</span>
1808             if (U_FAILURE(*status)) {
1809                 break;
1810             }
1811         } else {
<a name="153" id="anc153"></a><span class="line-modified">1812             kwd = extPool.create();</span>
1813             if (kwd == NULL) {
1814                 *status = U_MEMORY_ALLOCATION_ERROR;
1815                 break;
1816             }
1817             kwd-&gt;key = key;
1818             kwd-&gt;value = type;
1819             if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
<a name="154" id="anc154"></a>
1820                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1821                 break;
1822             }
1823         }
1824     }
1825 
1826     if (U_SUCCESS(*status)) {
1827         type = ultag_getPrivateUse(langtag);
1828         if ((int32_t)uprv_strlen(type) &gt; 0) {
1829             /* add private use as a keyword */
<a name="155" id="anc155"></a><span class="line-modified">1830             kwd = extPool.create();</span>
1831             if (kwd == NULL) {
1832                 *status = U_MEMORY_ALLOCATION_ERROR;
1833             } else {
1834                 kwd-&gt;key = PRIVATEUSE_KEY;
1835                 kwd-&gt;value = type;
1836                 if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
<a name="156" id="anc156"></a>
1837                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1838                 }
1839             }
1840         }
1841     }
1842 
1843     /* If a POSIX variant was in the extensions, write it out before writing the keywords. */
1844 
1845     if (U_SUCCESS(*status) &amp;&amp; posixVariant) {
1846         len = (int32_t) uprv_strlen(_POSIX);
<a name="157" id="anc157"></a><span class="line-modified">1847         sink.Append(_POSIX, len);</span>



1848     }
1849 
1850     if (U_SUCCESS(*status) &amp;&amp; kwdFirst != NULL) {
1851         /* write out the sorted keywords */
1852         UBool firstValue = TRUE;
1853         kwd = kwdFirst;
1854         do {
<a name="158" id="anc158"></a><span class="line-modified">1855             if (firstValue) {</span>
<span class="line-modified">1856                 sink.Append(&quot;@&quot;, 1);</span>
<span class="line-modified">1857                 firstValue = FALSE;</span>
<span class="line-modified">1858             } else {</span>
<span class="line-modified">1859                 sink.Append(&quot;;&quot;, 1);</span>




1860             }
<a name="159" id="anc159"></a>
1861 
1862             /* key */
1863             len = (int32_t)uprv_strlen(kwd-&gt;key);
<a name="160" id="anc160"></a><span class="line-modified">1864             sink.Append(kwd-&gt;key, len);</span>
<span class="line-modified">1865             sink.Append(&quot;=&quot;, 1);</span>








1866 
1867             /* type */
1868             len = (int32_t)uprv_strlen(kwd-&gt;value);
<a name="161" id="anc161"></a><span class="line-modified">1869             sink.Append(kwd-&gt;value, len);</span>



1870 
1871             kwd = kwd-&gt;next;
1872         } while (kwd);
1873     }
<a name="162" id="anc162"></a>















1874 }
1875 
<a name="163" id="anc163"></a><span class="line-modified">1876 static void</span>
<span class="line-modified">1877 _appendPrivateuseToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UBool hadPosix, UErrorCode* status) {</span>
1878     (void)hadPosix;
1879     char buf[ULOC_FULLNAME_CAPACITY];
1880     char tmpAppend[ULOC_FULLNAME_CAPACITY];
1881     UErrorCode tmpStatus = U_ZERO_ERROR;
1882     int32_t len, i;
1883     int32_t reslen = 0;
<a name="164" id="anc164"></a><span class="line-added">1884     int32_t capacity = sizeof tmpAppend;</span>
1885 
1886     if (U_FAILURE(*status)) {
<a name="165" id="anc165"></a><span class="line-modified">1887         return;</span>
1888     }
1889 
1890     len = uloc_getVariant(localeID, buf, sizeof(buf), &amp;tmpStatus);
1891     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1892         if (strict) {
1893             *status = U_ILLEGAL_ARGUMENT_ERROR;
1894         }
<a name="166" id="anc166"></a><span class="line-modified">1895         return;</span>
1896     }
1897 
1898     if (len &gt; 0) {
1899         char *p, *pPriv;
1900         UBool bNext = TRUE;
1901         UBool firstValue = TRUE;
1902         UBool writeValue;
1903 
1904         pPriv = NULL;
1905         p = buf;
1906         while (bNext) {
1907             writeValue = FALSE;
1908             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
1909                 if (*p == 0) {
1910                     bNext = FALSE;
1911                 } else {
1912                     *p = 0; /* terminate */
1913                 }
1914                 if (pPriv != NULL) {
1915                     /* Private use in the canonical format is lowercase in BCP47 */
1916                     for (i = 0; *(pPriv + i) != 0; i++) {
1917                         *(pPriv + i) = uprv_tolower(*(pPriv + i));
1918                     }
1919 
1920                     /* validate */
1921                     if (_isPrivateuseValueSubtag(pPriv, -1)) {
1922                         if (firstValue) {
1923                             if (!_isVariantSubtag(pPriv, -1)) {
1924                                 writeValue = TRUE;
1925                             }
1926                         } else {
1927                             writeValue = TRUE;
1928                         }
1929                     } else if (strict) {
1930                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1931                         break;
1932                     } else {
1933                         break;
1934                     }
1935 
1936                     if (writeValue) {
1937                         if (reslen &lt; capacity) {
1938                             tmpAppend[reslen++] = SEP;
1939                         }
1940 
1941                         if (firstValue) {
1942                             if (reslen &lt; capacity) {
1943                                 tmpAppend[reslen++] = *PRIVATEUSE_KEY;
1944                             }
1945 
1946                             if (reslen &lt; capacity) {
1947                                 tmpAppend[reslen++] = SEP;
1948                             }
1949 
1950                             len = (int32_t)uprv_strlen(PRIVUSE_VARIANT_PREFIX);
1951                             if (reslen &lt; capacity) {
1952                                 uprv_memcpy(tmpAppend + reslen, PRIVUSE_VARIANT_PREFIX, uprv_min(len, capacity - reslen));
1953                             }
1954                             reslen += len;
1955 
1956                             if (reslen &lt; capacity) {
1957                                 tmpAppend[reslen++] = SEP;
1958                             }
1959 
1960                             firstValue = FALSE;
1961                         }
1962 
1963                         len = (int32_t)uprv_strlen(pPriv);
1964                         if (reslen &lt; capacity) {
1965                             uprv_memcpy(tmpAppend + reslen, pPriv, uprv_min(len, capacity - reslen));
1966                         }
1967                         reslen += len;
1968                     }
1969                 }
1970                 /* reset private use starting position */
1971                 pPriv = NULL;
1972             } else if (pPriv == NULL) {
1973                 pPriv = p;
1974             }
1975             p++;
1976         }
1977 
1978         if (U_FAILURE(*status)) {
<a name="167" id="anc167"></a><span class="line-modified">1979             return;</span>
1980         }
1981     }
1982 
1983     if (U_SUCCESS(*status)) {
1984         len = reslen;
<a name="168" id="anc168"></a><span class="line-modified">1985         sink.Append(tmpAppend, len);</span>


1986     }
<a name="169" id="anc169"></a>



1987 }
1988 
1989 /*
1990 * -------------------------------------------------
1991 *
1992 * ultag_ functions
1993 *
1994 * -------------------------------------------------
1995 */
1996 
1997 /* Bit flags used by the parser */
1998 #define LANG 0x0001
1999 #define EXTL 0x0002
2000 #define SCRT 0x0004
2001 #define REGN 0x0008
2002 #define VART 0x0010
2003 #define EXTS 0x0020
2004 #define EXTV 0x0040
2005 #define PRIV 0x0080
2006 
2007 /**
2008  * Ticket #12705 - Visual Studio 2015 Update 3 contains a new code optimizer which has problems optimizing
2009  * this function. (See https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/ )
2010  * As a workaround, we will turn off optimization just for this function on VS2015 Update 3 and above.
2011  */
2012 #if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 190024210))
2013 #pragma optimize( &quot;&quot;, off )
2014 #endif
2015 
2016 static ULanguageTag*
2017 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status) {
<a name="170" id="anc170"></a>
2018     char *tagBuf;
2019     int16_t next;
2020     char *pSubtag, *pNext, *pLastGoodPosition;
2021     int32_t subtagLen;
2022     int32_t extlangIdx;
2023     ExtensionListEntry *pExtension;
2024     char *pExtValueSubtag, *pExtValueSubtagEnd;
2025     int32_t i;
2026     UBool privateuseVar = FALSE;
2027     int32_t grandfatheredLen = 0;
2028 
2029     if (parsedLen != NULL) {
2030         *parsedLen = 0;
2031     }
2032 
2033     if (U_FAILURE(*status)) {
2034         return NULL;
2035     }
2036 
2037     if (tagLen &lt; 0) {
2038         tagLen = (int32_t)uprv_strlen(tag);
2039     }
2040 
2041     /* copy the entire string */
2042     tagBuf = (char*)uprv_malloc(tagLen + 1);
2043     if (tagBuf == NULL) {
2044         *status = U_MEMORY_ALLOCATION_ERROR;
2045         return NULL;
2046     }
2047     uprv_memcpy(tagBuf, tag, tagLen);
2048     *(tagBuf + tagLen) = 0;
2049 
2050     /* create a ULanguageTag */
<a name="171" id="anc171"></a><span class="line-modified">2051     icu::LocalULanguageTagPointer t(</span>
<span class="line-modified">2052             (ULanguageTag*)uprv_malloc(sizeof(ULanguageTag)));</span>
<span class="line-added">2053     if (t.isNull()) {</span>
2054         uprv_free(tagBuf);
2055         *status = U_MEMORY_ALLOCATION_ERROR;
2056         return NULL;
2057     }
<a name="172" id="anc172"></a><span class="line-modified">2058     _initializeULanguageTag(t.getAlias());</span>
2059     t-&gt;buf = tagBuf;
2060 
2061     if (tagLen &lt; MINLEN) {
2062         /* the input tag is too short - return empty ULanguageTag */
<a name="173" id="anc173"></a><span class="line-modified">2063         return t.orphan();</span>
2064     }
2065 
<a name="174" id="anc174"></a><span class="line-added">2066     size_t parsedLenDelta = 0;</span>
<span class="line-added">2067     // Grandfathered tag will be consider together. Grandfathered tag with intervening</span>
<span class="line-added">2068     // script and region such as art-DE-lojban or art-Latn-lojban won&#39;t be</span>
<span class="line-added">2069     // matched.</span>
2070     /* check if the tag is grandfathered */
<a name="175" id="anc175"></a><span class="line-modified">2071     for (i = 0; i &lt; UPRV_LENGTHOF(GRANDFATHERED); i += 2) {</span>
<span class="line-modified">2072         int32_t checkGrandfatheredLen = static_cast&lt;int32_t&gt;(uprv_strlen(GRANDFATHERED[i]));</span>
<span class="line-added">2073         if (tagLen &lt; checkGrandfatheredLen) {</span>
<span class="line-added">2074             continue;</span>
<span class="line-added">2075         }</span>
<span class="line-added">2076         if (tagLen &gt; checkGrandfatheredLen &amp;&amp; tagBuf[checkGrandfatheredLen] != &#39;-&#39;) {</span>
<span class="line-added">2077             // make sure next char is &#39;-&#39;.</span>
<span class="line-added">2078             continue;</span>
<span class="line-added">2079         }</span>
<span class="line-added">2080         if (uprv_strnicmp(GRANDFATHERED[i], tagBuf, checkGrandfatheredLen) == 0) {</span>
2081             int32_t newTagLength;
2082 
<a name="176" id="anc176"></a><span class="line-modified">2083             grandfatheredLen = checkGrandfatheredLen;  /* back up for output parsedLen */</span>
<span class="line-modified">2084             int32_t replacementLen = static_cast&lt;int32_t&gt;(uprv_strlen(GRANDFATHERED[i+1]));</span>
<span class="line-added">2085             newTagLength = replacementLen + tagLen - checkGrandfatheredLen;</span>
2086             if (tagLen &lt; newTagLength) {
2087                 uprv_free(tagBuf);
2088                 tagBuf = (char*)uprv_malloc(newTagLength + 1);
2089                 if (tagBuf == NULL) {
2090                     *status = U_MEMORY_ALLOCATION_ERROR;
<a name="177" id="anc177"></a>
2091                     return NULL;
2092                 }
2093                 t-&gt;buf = tagBuf;
2094                 tagLen = newTagLength;
2095             }
<a name="178" id="anc178"></a><span class="line-added">2096             parsedLenDelta = checkGrandfatheredLen - replacementLen;</span>
2097             uprv_strcpy(t-&gt;buf, GRANDFATHERED[i + 1]);
<a name="179" id="anc179"></a><span class="line-added">2098             if (checkGrandfatheredLen != tagLen) {</span>
<span class="line-added">2099                 uprv_strcpy(t-&gt;buf + replacementLen, tag + checkGrandfatheredLen);</span>
<span class="line-added">2100             }</span>
2101             break;
2102         }
2103     }
2104 
<a name="180" id="anc180"></a><span class="line-added">2105     if (grandfatheredLen == 0) {</span>
<span class="line-added">2106         for (i = 0; i &lt; UPRV_LENGTHOF(REDUNDANT); i += 2) {</span>
<span class="line-added">2107             const char* redundantTag = REDUNDANT[i];</span>
<span class="line-added">2108             size_t redundantTagLen = uprv_strlen(redundantTag);</span>
<span class="line-added">2109             // The preferred tag for a redundant tag is always shorter than redundant</span>
<span class="line-added">2110             // tag. A redundant tag may or may not be followed by other subtags.</span>
<span class="line-added">2111             // (i.e. &quot;zh-yue&quot; or &quot;zh-yue-u-co-pinyin&quot;).</span>
<span class="line-added">2112             if (uprv_strnicmp(redundantTag, tagBuf, static_cast&lt;uint32_t&gt;(redundantTagLen)) == 0) {</span>
<span class="line-added">2113                 const char* redundantTagEnd = tagBuf + redundantTagLen;</span>
<span class="line-added">2114                 if (*redundantTagEnd  == &#39;\0&#39; || *redundantTagEnd == SEP) {</span>
<span class="line-added">2115                     const char* preferredTag = REDUNDANT[i + 1];</span>
<span class="line-added">2116                     size_t preferredTagLen = uprv_strlen(preferredTag);</span>
<span class="line-added">2117                     uprv_strncpy(t-&gt;buf, preferredTag, preferredTagLen);</span>
<span class="line-added">2118                     if (*redundantTagEnd == SEP) {</span>
<span class="line-added">2119                         uprv_memmove(tagBuf + preferredTagLen,</span>
<span class="line-added">2120                                      redundantTagEnd,</span>
<span class="line-added">2121                                      tagLen - redundantTagLen + 1);</span>
<span class="line-added">2122                     } else {</span>
<span class="line-added">2123                         tagBuf[preferredTagLen] = &#39;\0&#39;;</span>
<span class="line-added">2124                     }</span>
<span class="line-added">2125                     // parsedLen should be the length of the input</span>
<span class="line-added">2126                     // before redundantTag is replaced by preferredTag.</span>
<span class="line-added">2127                     // Save the delta to add it back later.</span>
<span class="line-added">2128                     parsedLenDelta = redundantTagLen - preferredTagLen;</span>
<span class="line-added">2129                     break;</span>
<span class="line-added">2130                 }</span>
<span class="line-added">2131             }</span>
<span class="line-added">2132         }</span>
<span class="line-added">2133     }</span>
<span class="line-added">2134 </span>
2135     /*
2136      * langtag      =   language
2137      *                  [&quot;-&quot; script]
2138      *                  [&quot;-&quot; region]
2139      *                  *(&quot;-&quot; variant)
2140      *                  *(&quot;-&quot; extension)
2141      *                  [&quot;-&quot; privateuse]
2142      */
2143 
2144     next = LANG | PRIV;
2145     pNext = pLastGoodPosition = tagBuf;
2146     extlangIdx = 0;
2147     pExtension = NULL;
2148     pExtValueSubtag = NULL;
2149     pExtValueSubtagEnd = NULL;
2150 
2151     while (pNext) {
2152         char *pSep;
2153 
2154         pSubtag = pNext;
2155 
2156         /* locate next separator char */
2157         pSep = pSubtag;
2158         while (*pSep) {
2159             if (*pSep == SEP) {
2160                 break;
2161             }
2162             pSep++;
2163         }
2164         if (*pSep == 0) {
2165             /* last subtag */
2166             pNext = NULL;
2167         } else {
2168             pNext = pSep + 1;
2169         }
2170         subtagLen = (int32_t)(pSep - pSubtag);
2171 
2172         if (next &amp; LANG) {
<a name="181" id="anc181"></a><span class="line-modified">2173             if (ultag_isLanguageSubtag(pSubtag, subtagLen)) {</span>
2174                 *pSep = 0;  /* terminate */
<a name="182" id="anc182"></a><span class="line-added">2175                 // TODO: move deprecated language code handling here.</span>
2176                 t-&gt;language = T_CString_toLowerCase(pSubtag);
2177 
2178                 pLastGoodPosition = pSep;
<a name="183" id="anc183"></a><span class="line-modified">2179                 next = SCRT | REGN | VART | EXTS | PRIV;</span>
<span class="line-added">2180                 if (subtagLen &lt;= 3)</span>
<span class="line-added">2181                   next |= EXTL;</span>
2182                 continue;
2183             }
2184         }
2185         if (next &amp; EXTL) {
2186             if (_isExtlangSubtag(pSubtag, subtagLen)) {
2187                 *pSep = 0;
2188                 t-&gt;extlang[extlangIdx++] = T_CString_toLowerCase(pSubtag);
2189 
2190                 pLastGoodPosition = pSep;
2191                 if (extlangIdx &lt; 3) {
2192                     next = EXTL | SCRT | REGN | VART | EXTS | PRIV;
2193                 } else {
2194                     next = SCRT | REGN | VART | EXTS | PRIV;
2195                 }
2196                 continue;
2197             }
2198         }
2199         if (next &amp; SCRT) {
<a name="184" id="anc184"></a><span class="line-modified">2200             if (ultag_isScriptSubtag(pSubtag, subtagLen)) {</span>
2201                 char *p = pSubtag;
2202 
2203                 *pSep = 0;
2204 
2205                 /* to title case */
2206                 *p = uprv_toupper(*p);
2207                 p++;
2208                 for (; *p; p++) {
2209                     *p = uprv_tolower(*p);
2210                 }
2211 
2212                 t-&gt;script = pSubtag;
2213 
2214                 pLastGoodPosition = pSep;
2215                 next = REGN | VART | EXTS | PRIV;
2216                 continue;
2217             }
2218         }
2219         if (next &amp; REGN) {
<a name="185" id="anc185"></a><span class="line-modified">2220             if (ultag_isRegionSubtag(pSubtag, subtagLen)) {</span>
2221                 *pSep = 0;
<a name="186" id="anc186"></a><span class="line-added">2222                 // TODO: move deprecated region code handling here.</span>
2223                 t-&gt;region = T_CString_toUpperCase(pSubtag);
2224 
2225                 pLastGoodPosition = pSep;
2226                 next = VART | EXTS | PRIV;
2227                 continue;
2228             }
2229         }
2230         if (next &amp; VART) {
2231             if (_isVariantSubtag(pSubtag, subtagLen) ||
2232                (privateuseVar &amp;&amp; _isPrivateuseVariantSubtag(pSubtag, subtagLen))) {
2233                 VariantListEntry *var;
2234                 UBool isAdded;
2235 
2236                 var = (VariantListEntry*)uprv_malloc(sizeof(VariantListEntry));
2237                 if (var == NULL) {
2238                     *status = U_MEMORY_ALLOCATION_ERROR;
<a name="187" id="anc187"></a><span class="line-modified">2239                     return NULL;</span>
2240                 }
2241                 *pSep = 0;
2242                 var-&gt;variant = T_CString_toUpperCase(pSubtag);
2243                 isAdded = _addVariantToList(&amp;(t-&gt;variants), var);
2244                 if (!isAdded) {
2245                     /* duplicated variant entry */
2246                     uprv_free(var);
2247                     break;
2248                 }
2249                 pLastGoodPosition = pSep;
2250                 next = VART | EXTS | PRIV;
2251                 continue;
2252             }
2253         }
2254         if (next &amp; EXTS) {
2255             if (_isExtensionSingleton(pSubtag, subtagLen)) {
2256                 if (pExtension != NULL) {
2257                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2258                         /* the previous extension is incomplete */
2259                         uprv_free(pExtension);
2260                         pExtension = NULL;
2261                         break;
2262                     }
2263 
2264                     /* terminate the previous extension value */
2265                     *pExtValueSubtagEnd = 0;
2266                     pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2267 
2268                     /* insert the extension to the list */
2269                     if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2270                         pLastGoodPosition = pExtValueSubtagEnd;
2271                     } else {
2272                         /* stop parsing here */
2273                         uprv_free(pExtension);
2274                         pExtension = NULL;
2275                         break;
2276                     }
2277                 }
2278 
2279                 /* create a new extension */
2280                 pExtension = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
2281                 if (pExtension == NULL) {
2282                     *status = U_MEMORY_ALLOCATION_ERROR;
<a name="188" id="anc188"></a><span class="line-modified">2283                     return NULL;</span>
2284                 }
2285                 *pSep = 0;
2286                 pExtension-&gt;key = T_CString_toLowerCase(pSubtag);
2287                 pExtension-&gt;value = NULL;   /* will be set later */
2288 
2289                 /*
2290                  * reset the start and the end location of extension value
2291                  * subtags for this extension
2292                  */
2293                 pExtValueSubtag = NULL;
2294                 pExtValueSubtagEnd = NULL;
2295 
2296                 next = EXTV;
2297                 continue;
2298             }
2299         }
2300         if (next &amp; EXTV) {
2301             if (_isExtensionSubtag(pSubtag, subtagLen)) {
2302                 if (pExtValueSubtag == NULL) {
2303                     /* if the start postion of this extension&#39;s value is not yet,
2304                         this one is the first value subtag */
2305                     pExtValueSubtag = pSubtag;
2306                 }
2307 
2308                 /* Mark the end of this subtag */
2309                 pExtValueSubtagEnd = pSep;
2310                 next = EXTS | EXTV | PRIV;
2311 
2312                 continue;
2313             }
2314         }
2315         if (next &amp; PRIV) {
<a name="189" id="anc189"></a><span class="line-modified">2316             if (uprv_tolower(*pSubtag) == PRIVATEUSE &amp;&amp; subtagLen == 1) {</span>
2317                 char *pPrivuseVal;
2318 
2319                 if (pExtension != NULL) {
2320                     /* Process the last extension */
2321                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2322                         /* the previous extension is incomplete */
2323                         uprv_free(pExtension);
2324                         pExtension = NULL;
2325                         break;
2326                     } else {
2327                         /* terminate the previous extension value */
2328                         *pExtValueSubtagEnd = 0;
2329                         pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2330 
2331                         /* insert the extension to the list */
2332                         if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2333                             pLastGoodPosition = pExtValueSubtagEnd;
2334                             pExtension = NULL;
2335                         } else {
2336                         /* stop parsing here */
2337                             uprv_free(pExtension);
2338                             pExtension = NULL;
2339                             break;
2340                         }
2341                     }
2342                 }
2343 
2344                 /* The rest of part will be private use value subtags */
2345                 if (pNext == NULL) {
2346                     /* empty private use subtag */
2347                     break;
2348                 }
2349                 /* back up the private use value start position */
2350                 pPrivuseVal = pNext;
2351 
2352                 /* validate private use value subtags */
2353                 while (pNext) {
2354                     pSubtag = pNext;
2355                     pSep = pSubtag;
2356                     while (*pSep) {
2357                         if (*pSep == SEP) {
2358                             break;
2359                         }
2360                         pSep++;
2361                     }
2362                     if (*pSep == 0) {
2363                         /* last subtag */
2364                         pNext = NULL;
2365                     } else {
2366                         pNext = pSep + 1;
2367                     }
2368                     subtagLen = (int32_t)(pSep - pSubtag);
2369 
2370                     if (uprv_strncmp(pSubtag, PRIVUSE_VARIANT_PREFIX, uprv_strlen(PRIVUSE_VARIANT_PREFIX)) == 0) {
2371                         *pSep = 0;
2372                         next = VART;
2373                         privateuseVar = TRUE;
2374                         break;
2375                     } else if (_isPrivateuseValueSubtag(pSubtag, subtagLen)) {
2376                         pLastGoodPosition = pSep;
2377                     } else {
2378                         break;
2379                     }
2380                 }
2381 
2382                 if (next == VART) {
2383                     continue;
2384                 }
2385 
2386                 if (pLastGoodPosition - pPrivuseVal &gt; 0) {
2387                     *pLastGoodPosition = 0;
2388                     t-&gt;privateuse = T_CString_toLowerCase(pPrivuseVal);
2389                 }
2390                 /* No more subtags, exiting the parse loop */
2391                 break;
2392             }
2393             break;
2394         }
2395 
2396         /* If we fell through here, it means this subtag is illegal - quit parsing */
2397         break;
2398     }
2399 
2400     if (pExtension != NULL) {
2401         /* Process the last extension */
2402         if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2403             /* the previous extension is incomplete */
2404             uprv_free(pExtension);
2405         } else {
2406             /* terminate the previous extension value */
2407             *pExtValueSubtagEnd = 0;
2408             pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2409             /* insert the extension to the list */
2410             if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2411                 pLastGoodPosition = pExtValueSubtagEnd;
2412             } else {
2413                 uprv_free(pExtension);
2414             }
2415         }
2416     }
2417 
2418     if (parsedLen != NULL) {
<a name="190" id="anc190"></a><span class="line-modified">2419         *parsedLen = (int32_t)(pLastGoodPosition - t-&gt;buf + parsedLenDelta);</span>
2420     }
2421 
<a name="191" id="anc191"></a><span class="line-modified">2422     return t.orphan();</span>




2423 }
2424 
2425 /**
2426 * Ticket #12705 - Turn optimization back on.
2427 */
2428 #if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 190024210))
2429 #pragma optimize( &quot;&quot;, on )
2430 #endif
2431 
2432 static void
2433 ultag_close(ULanguageTag* langtag) {
2434 
2435     if (langtag == NULL) {
2436         return;
2437     }
2438 
2439     uprv_free(langtag-&gt;buf);
2440 
2441     if (langtag-&gt;variants) {
2442         VariantListEntry *curVar = langtag-&gt;variants;
2443         while (curVar) {
2444             VariantListEntry *nextVar = curVar-&gt;next;
2445             uprv_free(curVar);
2446             curVar = nextVar;
2447         }
2448     }
2449 
2450     if (langtag-&gt;extensions) {
2451         ExtensionListEntry *curExt = langtag-&gt;extensions;
2452         while (curExt) {
2453             ExtensionListEntry *nextExt = curExt-&gt;next;
2454             uprv_free(curExt);
2455             curExt = nextExt;
2456         }
2457     }
2458 
2459     uprv_free(langtag);
2460 }
2461 
2462 static const char*
2463 ultag_getLanguage(const ULanguageTag* langtag) {
2464     return langtag-&gt;language;
2465 }
2466 
2467 #if 0
2468 static const char*
2469 ultag_getJDKLanguage(const ULanguageTag* langtag) {
2470     int32_t i;
2471     for (i = 0; DEPRECATEDLANGS[i] != NULL; i += 2) {
2472         if (uprv_compareInvCharsAsAscii(DEPRECATEDLANGS[i], langtag-&gt;language) == 0) {
2473             return DEPRECATEDLANGS[i + 1];
2474         }
2475     }
2476     return langtag-&gt;language;
2477 }
2478 #endif
2479 
2480 static const char*
2481 ultag_getExtlang(const ULanguageTag* langtag, int32_t idx) {
2482     if (idx &gt;= 0 &amp;&amp; idx &lt; MAXEXTLANG) {
2483         return langtag-&gt;extlang[idx];
2484     }
2485     return NULL;
2486 }
2487 
2488 static int32_t
2489 ultag_getExtlangSize(const ULanguageTag* langtag) {
2490     int32_t size = 0;
2491     int32_t i;
2492     for (i = 0; i &lt; MAXEXTLANG; i++) {
2493         if (langtag-&gt;extlang[i]) {
2494             size++;
2495         }
2496     }
2497     return size;
2498 }
2499 
2500 static const char*
2501 ultag_getScript(const ULanguageTag* langtag) {
2502     return langtag-&gt;script;
2503 }
2504 
2505 static const char*
2506 ultag_getRegion(const ULanguageTag* langtag) {
2507     return langtag-&gt;region;
2508 }
2509 
2510 static const char*
2511 ultag_getVariant(const ULanguageTag* langtag, int32_t idx) {
2512     const char *var = NULL;
2513     VariantListEntry *cur = langtag-&gt;variants;
2514     int32_t i = 0;
2515     while (cur) {
2516         if (i == idx) {
2517             var = cur-&gt;variant;
2518             break;
2519         }
2520         cur = cur-&gt;next;
2521         i++;
2522     }
2523     return var;
2524 }
2525 
2526 static int32_t
2527 ultag_getVariantsSize(const ULanguageTag* langtag) {
2528     int32_t size = 0;
2529     VariantListEntry *cur = langtag-&gt;variants;
2530     while (TRUE) {
2531         if (cur == NULL) {
2532             break;
2533         }
2534         size++;
2535         cur = cur-&gt;next;
2536     }
2537     return size;
2538 }
2539 
2540 static const char*
2541 ultag_getExtensionKey(const ULanguageTag* langtag, int32_t idx) {
2542     const char *key = NULL;
2543     ExtensionListEntry *cur = langtag-&gt;extensions;
2544     int32_t i = 0;
2545     while (cur) {
2546         if (i == idx) {
2547             key = cur-&gt;key;
2548             break;
2549         }
2550         cur = cur-&gt;next;
2551         i++;
2552     }
2553     return key;
2554 }
2555 
2556 static const char*
2557 ultag_getExtensionValue(const ULanguageTag* langtag, int32_t idx) {
2558     const char *val = NULL;
2559     ExtensionListEntry *cur = langtag-&gt;extensions;
2560     int32_t i = 0;
2561     while (cur) {
2562         if (i == idx) {
2563             val = cur-&gt;value;
2564             break;
2565         }
2566         cur = cur-&gt;next;
2567         i++;
2568     }
2569     return val;
2570 }
2571 
2572 static int32_t
2573 ultag_getExtensionsSize(const ULanguageTag* langtag) {
2574     int32_t size = 0;
2575     ExtensionListEntry *cur = langtag-&gt;extensions;
2576     while (TRUE) {
2577         if (cur == NULL) {
2578             break;
2579         }
2580         size++;
2581         cur = cur-&gt;next;
2582     }
2583     return size;
2584 }
2585 
2586 static const char*
2587 ultag_getPrivateUse(const ULanguageTag* langtag) {
2588     return langtag-&gt;privateuse;
2589 }
2590 
2591 #if 0
2592 static const char*
2593 ultag_getGrandfathered(const ULanguageTag* langtag) {
2594     return langtag-&gt;grandfathered;
2595 }
2596 #endif
2597 
2598 
2599 /*
2600 * -------------------------------------------------
2601 *
2602 * Locale/BCP47 conversion APIs, exposed as uloc_*
2603 *
2604 * -------------------------------------------------
2605 */
2606 U_CAPI int32_t U_EXPORT2
2607 uloc_toLanguageTag(const char* localeID,
2608                    char* langtag,
2609                    int32_t langtagCapacity,
2610                    UBool strict,
2611                    UErrorCode* status) {
<a name="192" id="anc192"></a><span class="line-modified">2612     if (U_FAILURE(*status)) {</span>
<span class="line-modified">2613         return 0;</span>
<span class="line-modified">2614     }</span>
<span class="line-added">2615 </span>
<span class="line-added">2616     icu::CheckedArrayByteSink sink(langtag, langtagCapacity);</span>
<span class="line-added">2617     ulocimp_toLanguageTag(localeID, sink, strict, status);</span>
<span class="line-added">2618 </span>
<span class="line-added">2619     int32_t reslen = sink.NumberOfBytesAppended();</span>
<span class="line-added">2620 </span>
<span class="line-added">2621     if (U_FAILURE(*status)) {</span>
<span class="line-added">2622         return reslen;</span>
<span class="line-added">2623     }</span>
<span class="line-added">2624 </span>
<span class="line-added">2625     if (sink.Overflowed()) {</span>
<span class="line-added">2626         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-added">2627     } else {</span>
<span class="line-added">2628         u_terminateChars(langtag, langtagCapacity, reslen, status);</span>
<span class="line-added">2629     }</span>
<span class="line-added">2630 </span>
<span class="line-added">2631     return reslen;</span>
<span class="line-added">2632 }</span>
<span class="line-added">2633 </span>
<span class="line-added">2634 </span>
<span class="line-added">2635 U_CAPI void U_EXPORT2</span>
<span class="line-added">2636 ulocimp_toLanguageTag(const char* localeID,</span>
<span class="line-added">2637                       icu::ByteSink&amp; sink,</span>
<span class="line-added">2638                       UBool strict,</span>
<span class="line-added">2639                       UErrorCode* status) {</span>
<span class="line-added">2640     icu::CharString canonical;</span>
<span class="line-added">2641     int32_t reslen;</span>
2642     UErrorCode tmpStatus = U_ZERO_ERROR;
2643     UBool hadPosix = FALSE;
2644     const char* pKeywordStart;
2645 
2646     /* Note: uloc_canonicalize returns &quot;en_US_POSIX&quot; for input locale ID &quot;&quot;.  See #6835 */
<a name="193" id="anc193"></a><span class="line-modified">2647     int32_t resultCapacity = static_cast&lt;int32_t&gt;(uprv_strlen(localeID));</span>
<span class="line-modified">2648     if (resultCapacity &gt; 0) {</span>
<span class="line-modified">2649         char* buffer;</span>
<span class="line-modified">2650 </span>
<span class="line-added">2651         for (;;) {</span>
<span class="line-added">2652             buffer = canonical.getAppendBuffer(</span>
<span class="line-added">2653                     /*minCapacity=*/resultCapacity,</span>
<span class="line-added">2654                     /*desiredCapacityHint=*/resultCapacity,</span>
<span class="line-added">2655                     resultCapacity,</span>
<span class="line-added">2656                     tmpStatus);</span>
<span class="line-added">2657 </span>
<span class="line-added">2658             if (U_FAILURE(tmpStatus)) {</span>
<span class="line-added">2659                 *status = tmpStatus;</span>
<span class="line-added">2660                 return;</span>
<span class="line-added">2661             }</span>
<span class="line-added">2662 </span>
<span class="line-added">2663             reslen =</span>
<span class="line-added">2664                 uloc_canonicalize(localeID, buffer, resultCapacity, &amp;tmpStatus);</span>
<span class="line-added">2665 </span>
<span class="line-added">2666             if (tmpStatus != U_BUFFER_OVERFLOW_ERROR) {</span>
<span class="line-added">2667                 break;</span>
<span class="line-added">2668             }</span>
<span class="line-added">2669 </span>
<span class="line-added">2670             resultCapacity = reslen;</span>
<span class="line-added">2671             tmpStatus = U_ZERO_ERROR;</span>
<span class="line-added">2672         }</span>
<span class="line-added">2673 </span>
<span class="line-added">2674         if (U_FAILURE(tmpStatus)) {</span>
2675             *status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="194" id="anc194"></a><span class="line-modified">2676             return;</span>
<span class="line-added">2677         }</span>
<span class="line-added">2678 </span>
<span class="line-added">2679         canonical.append(buffer, reslen, tmpStatus);</span>
<span class="line-added">2680         if (tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {</span>
<span class="line-added">2681             tmpStatus = U_ZERO_ERROR;  // Terminators provided by CharString.</span>
<span class="line-added">2682         }</span>
<span class="line-added">2683 </span>
<span class="line-added">2684         if (U_FAILURE(tmpStatus)) {</span>
<span class="line-added">2685             *status = tmpStatus;</span>
<span class="line-added">2686             return;</span>
2687         }
2688     }
2689 
2690     /* For handling special case - private use only tag */
<a name="195" id="anc195"></a><span class="line-modified">2691     pKeywordStart = locale_getKeywordsStart(canonical.data());</span>
<span class="line-modified">2692     if (pKeywordStart == canonical.data()) {</span>

2693         int kwdCnt = 0;
2694         UBool done = FALSE;
2695 
<a name="196" id="anc196"></a><span class="line-modified">2696         icu::LocalUEnumerationPointer kwdEnum(uloc_openKeywords(canonical.data(), &amp;tmpStatus));</span>
<span class="line-modified">2697         if (U_SUCCESS(tmpStatus)) {</span>
<span class="line-modified">2698             kwdCnt = uenum_count(kwdEnum.getAlias(), &amp;tmpStatus);</span>
2699             if (kwdCnt == 1) {
2700                 const char *key;
2701                 int32_t len = 0;
2702 
<a name="197" id="anc197"></a><span class="line-modified">2703                 key = uenum_next(kwdEnum.getAlias(), &amp;len, &amp;tmpStatus);</span>
2704                 if (len == 1 &amp;&amp; *key == PRIVATEUSE) {
2705                     char buf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
2706                     buf[0] = PRIVATEUSE;
2707                     buf[1] = SEP;
2708                     len = uloc_getKeywordValue(localeID, key, &amp;buf[2], sizeof(buf) - 2, &amp;tmpStatus);
2709                     if (U_SUCCESS(tmpStatus)) {
<a name="198" id="anc198"></a><span class="line-modified">2710                         if (ultag_isPrivateuseValueSubtags(&amp;buf[2], len)) {</span>
2711                             /* return private use only tag */
<a name="199" id="anc199"></a><span class="line-modified">2712                             sink.Append(buf, len + 2);</span>


2713                             done = TRUE;
2714                         } else if (strict) {
2715                             *status = U_ILLEGAL_ARGUMENT_ERROR;
2716                             done = TRUE;
2717                         }
2718                         /* if not strict mode, then &quot;und&quot; will be returned */
2719                     } else {
2720                         *status = U_ILLEGAL_ARGUMENT_ERROR;
2721                         done = TRUE;
2722                     }
2723                 }
2724             }
<a name="200" id="anc200"></a>
2725             if (done) {
<a name="201" id="anc201"></a><span class="line-modified">2726                 return;</span>
2727             }
2728         }
2729     }
2730 
<a name="202" id="anc202"></a><span class="line-modified">2731     _appendLanguageToLanguageTag(canonical.data(), sink, strict, status);</span>
<span class="line-modified">2732     _appendScriptToLanguageTag(canonical.data(), sink, strict, status);</span>
<span class="line-modified">2733     _appendRegionToLanguageTag(canonical.data(), sink, strict, status);</span>
<span class="line-modified">2734     _appendVariantsToLanguageTag(canonical.data(), sink, strict, &amp;hadPosix, status);</span>
<span class="line-modified">2735     _appendKeywordsToLanguageTag(canonical.data(), sink, strict, hadPosix, status);</span>
<span class="line-modified">2736     _appendPrivateuseToLanguageTag(canonical.data(), sink, strict, hadPosix, status);</span>


2737 }
2738 
2739 
2740 U_CAPI int32_t U_EXPORT2
2741 uloc_forLanguageTag(const char* langtag,
2742                     char* localeID,
2743                     int32_t localeIDCapacity,
2744                     int32_t* parsedLength,
2745                     UErrorCode* status) {
<a name="203" id="anc203"></a><span class="line-modified">2746     if (U_FAILURE(*status)) {</span>
<span class="line-modified">2747         return 0;</span>
<span class="line-added">2748     }</span>
<span class="line-added">2749 </span>
<span class="line-added">2750     icu::CheckedArrayByteSink sink(localeID, localeIDCapacity);</span>
<span class="line-added">2751     ulocimp_forLanguageTag(langtag, -1, sink, parsedLength, status);</span>
<span class="line-added">2752 </span>
<span class="line-added">2753     int32_t reslen = sink.NumberOfBytesAppended();</span>
<span class="line-added">2754 </span>
<span class="line-added">2755     if (U_FAILURE(*status)) {</span>
<span class="line-added">2756         return reslen;</span>
<span class="line-added">2757     }</span>
<span class="line-added">2758 </span>
<span class="line-added">2759     if (sink.Overflowed()) {</span>
<span class="line-added">2760         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-added">2761     } else {</span>
<span class="line-added">2762         u_terminateChars(localeID, localeIDCapacity, reslen, status);</span>
<span class="line-added">2763     }</span>
<span class="line-added">2764 </span>
<span class="line-added">2765     return reslen;</span>
<span class="line-added">2766 }</span>
<span class="line-added">2767 </span>
<span class="line-added">2768 </span>
<span class="line-added">2769 U_CAPI void U_EXPORT2</span>
<span class="line-added">2770 ulocimp_forLanguageTag(const char* langtag,</span>
<span class="line-added">2771                        int32_t tagLen,</span>
<span class="line-added">2772                        icu::ByteSink&amp; sink,</span>
<span class="line-added">2773                        int32_t* parsedLength,</span>
<span class="line-added">2774                        UErrorCode* status) {</span>
<span class="line-added">2775     UBool isEmpty = TRUE;</span>
2776     const char *subtag, *p;
2777     int32_t len;
2778     int32_t i, n;
2779     UBool noRegion = TRUE;
2780 
<a name="204" id="anc204"></a><span class="line-modified">2781     icu::LocalULanguageTagPointer lt(ultag_parse(langtag, tagLen, parsedLength, status));</span>
2782     if (U_FAILURE(*status)) {
<a name="205" id="anc205"></a><span class="line-modified">2783         return;</span>
2784     }
2785 
2786     /* language */
<a name="206" id="anc206"></a><span class="line-modified">2787     subtag = ultag_getExtlangSize(lt.getAlias()) &gt; 0 ? ultag_getExtlang(lt.getAlias(), 0) : ultag_getLanguage(lt.getAlias());</span>
2788     if (uprv_compareInvCharsAsAscii(subtag, LANG_UND) != 0) {
2789         len = (int32_t)uprv_strlen(subtag);
2790         if (len &gt; 0) {
<a name="207" id="anc207"></a><span class="line-modified">2791             sink.Append(subtag, len);</span>
<span class="line-modified">2792             isEmpty = FALSE;</span>


2793         }
2794     }
2795 
2796     /* script */
<a name="208" id="anc208"></a><span class="line-modified">2797     subtag = ultag_getScript(lt.getAlias());</span>
2798     len = (int32_t)uprv_strlen(subtag);
2799     if (len &gt; 0) {
<a name="209" id="anc209"></a><span class="line-modified">2800         sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified">2801         isEmpty = FALSE;</span>


2802 
2803         /* write out the script in title case */
<a name="210" id="anc210"></a><span class="line-modified">2804         char c = uprv_toupper(*subtag);</span>
<span class="line-modified">2805         sink.Append(&amp;c, 1);</span>
<span class="line-modified">2806         sink.Append(subtag + 1, len - 1);</span>









2807     }
2808 
2809     /* region */
<a name="211" id="anc211"></a><span class="line-modified">2810     subtag = ultag_getRegion(lt.getAlias());</span>
2811     len = (int32_t)uprv_strlen(subtag);
2812     if (len &gt; 0) {
<a name="212" id="anc212"></a><span class="line-modified">2813         sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified">2814         isEmpty = FALSE;</span>
<span class="line-modified">2815 </span>
<span class="line-modified">2816         /* write out the region in upper case */</span>

2817         p = subtag;
2818         while (*p) {
<a name="213" id="anc213"></a><span class="line-modified">2819             char c = uprv_toupper(*p);</span>
<span class="line-modified">2820             sink.Append(&amp;c, 1);</span>


2821             p++;
2822         }
2823         noRegion = FALSE;
2824     }
2825 
2826     /* variants */
<a name="214" id="anc214"></a><span class="line-modified">2827     n = ultag_getVariantsSize(lt.getAlias());</span>
2828     if (n &gt; 0) {
2829         if (noRegion) {
<a name="215" id="anc215"></a><span class="line-modified">2830             sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified">2831             isEmpty = FALSE;</span>


2832         }
2833 
2834         for (i = 0; i &lt; n; i++) {
<a name="216" id="anc216"></a><span class="line-modified">2835             subtag = ultag_getVariant(lt.getAlias(), i);</span>
<span class="line-modified">2836             sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified">2837 </span>


2838             /* write out the variant in upper case */
2839             p = subtag;
2840             while (*p) {
<a name="217" id="anc217"></a><span class="line-modified">2841                 char c = uprv_toupper(*p);</span>
<span class="line-modified">2842                 sink.Append(&amp;c, 1);</span>


2843                 p++;
2844             }
2845         }
2846     }
2847 
2848     /* keywords */
<a name="218" id="anc218"></a><span class="line-modified">2849     n = ultag_getExtensionsSize(lt.getAlias());</span>
<span class="line-modified">2850     subtag = ultag_getPrivateUse(lt.getAlias());</span>
2851     if (n &gt; 0 || uprv_strlen(subtag) &gt; 0) {
<a name="219" id="anc219"></a><span class="line-modified">2852         if (isEmpty &amp;&amp; n &gt; 0) {</span>
2853             /* need a language */
<a name="220" id="anc220"></a><span class="line-modified">2854             sink.Append(LANG_UND, LANG_UND_LEN);</span>



2855         }
<a name="221" id="anc221"></a><span class="line-modified">2856         _appendKeywords(lt.getAlias(), sink, status);</span>

2857     }
<a name="222" id="anc222"></a>


2858 }
<a name="223" id="anc223"></a>

<a name="224" id="anc224"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="224" type="hidden" />
</body>
</html>