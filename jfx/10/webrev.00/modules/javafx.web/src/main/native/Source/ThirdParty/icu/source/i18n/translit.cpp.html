<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/translit.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4  **********************************************************************
   5  *   Copyright (C) 1999-2016, International Business Machines
   6  *   Corporation and others.  All Rights Reserved.
   7  **********************************************************************
   8  *   Date        Name        Description
   9  *   11/17/99    aliu        Creation.
  10  **********************************************************************
  11  */
  12 
  13 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  14 
  15 #include &quot;unicode/utypes.h&quot;
  16 
  17 #if !UCONFIG_NO_TRANSLITERATION
  18 
  19 #include &quot;unicode/putil.h&quot;
  20 #include &quot;unicode/translit.h&quot;
  21 #include &quot;unicode/locid.h&quot;
  22 #include &quot;unicode/msgfmt.h&quot;
  23 #include &quot;unicode/rep.h&quot;
  24 #include &quot;unicode/resbund.h&quot;
  25 #include &quot;unicode/unifilt.h&quot;
  26 #include &quot;unicode/uniset.h&quot;
  27 #include &quot;unicode/uscript.h&quot;
  28 #include &quot;unicode/strenum.h&quot;
  29 #include &quot;unicode/utf16.h&quot;
  30 #include &quot;cpdtrans.h&quot;
  31 #include &quot;nultrans.h&quot;
  32 #include &quot;rbt_data.h&quot;
  33 #include &quot;rbt_pars.h&quot;
  34 #include &quot;rbt.h&quot;
  35 #include &quot;transreg.h&quot;
  36 #include &quot;name2uni.h&quot;
  37 #include &quot;nortrans.h&quot;
  38 #include &quot;remtrans.h&quot;
  39 #include &quot;titletrn.h&quot;
  40 #include &quot;tolowtrn.h&quot;
  41 #include &quot;toupptrn.h&quot;
  42 #include &quot;uni2name.h&quot;
  43 #include &quot;brktrans.h&quot;
  44 #include &quot;esctrn.h&quot;
  45 #include &quot;unesctrn.h&quot;
  46 #include &quot;tridpars.h&quot;
  47 #include &quot;anytrans.h&quot;
  48 #include &quot;util.h&quot;
  49 #include &quot;hash.h&quot;
  50 #include &quot;mutex.h&quot;
  51 #include &quot;ucln_in.h&quot;
  52 #include &quot;uassert.h&quot;
  53 #include &quot;cmemory.h&quot;
  54 #include &quot;cstring.h&quot;
  55 #include &quot;uinvchar.h&quot;
  56 
  57 static const UChar TARGET_SEP  = 0x002D; /*-*/
  58 static const UChar ID_DELIM    = 0x003B; /*;*/
  59 static const UChar VARIANT_SEP = 0x002F; // &#39;/&#39;
  60 
  61 /**
  62  * Prefix for resource bundle key for the display name for a
  63  * transliterator.  The ID is appended to this to form the key.
  64  * The resource bundle value should be a String.
  65  */
  66 static const char RB_DISPLAY_NAME_PREFIX[] = &quot;%Translit%%&quot;;
  67 
  68 /**
  69  * Prefix for resource bundle key for the display name for a
  70  * transliterator SCRIPT.  The ID is appended to this to form the key.
  71  * The resource bundle value should be a String.
  72  */
  73 static const char RB_SCRIPT_DISPLAY_NAME_PREFIX[] = &quot;%Translit%&quot;;
  74 
  75 /**
  76  * Resource bundle key for display name pattern.
  77  * The resource bundle value should be a String forming a
  78  * MessageFormat pattern, e.g.:
  79  * &quot;{0,choice,0#|1#{1} Transliterator|2#{1} to {2} Transliterator}&quot;.
  80  */
  81 static const char RB_DISPLAY_NAME_PATTERN[] = &quot;TransliteratorNamePattern&quot;;
  82 
  83 /**
  84  * Resource bundle key for the list of RuleBasedTransliterator IDs.
  85  * The resource bundle value should be a String[] with each element
  86  * being a valid ID.  The ID will be appended to RB_RULE_BASED_PREFIX
  87  * to obtain the class name in which the RB_RULE key will be sought.
  88  */
  89 static const char RB_RULE_BASED_IDS[] = &quot;RuleBasedTransliteratorIDs&quot;;
  90 
  91 /**
  92  * The mutex controlling access to registry object.
  93  */
  94 static icu::UMutex *registryMutex() {
  95     static icu::UMutex m = U_MUTEX_INITIALIZER;
  96     return &amp;m;
  97 }
  98 
  99 /**
 100  * System transliterator registry; non-null when initialized.
 101  */
 102 static icu::TransliteratorRegistry* registry = 0;
 103 
 104 // Macro to check/initialize the registry. ONLY USE WITHIN
 105 // MUTEX. Avoids function call when registry is initialized.
 106 #define HAVE_REGISTRY(status) (registry!=0 || initializeRegistry(status))
 107 
 108 U_NAMESPACE_BEGIN
 109 
 110 UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(Transliterator)
 111 
 112 /**
 113  * Return TRUE if the given UTransPosition is valid for text of
 114  * the given length.
 115  */
 116 static inline UBool positionIsValid(UTransPosition&amp; index, int32_t len) {
 117     return !(index.contextStart &lt; 0 ||
 118              index.start &lt; index.contextStart ||
 119              index.limit &lt; index.start ||
 120              index.contextLimit &lt; index.limit ||
 121              len &lt; index.contextLimit);
 122 }
 123 
 124 /**
 125  * Default constructor.
 126  * @param theID the string identifier for this transliterator
 127  * @param theFilter the filter.  Any character for which
 128  * &lt;tt&gt;filter.contains()&lt;/tt&gt; returns &lt;tt&gt;FALSE&lt;/tt&gt; will not be
 129  * altered by this transliterator.  If &lt;tt&gt;filter&lt;/tt&gt; is
 130  * &lt;tt&gt;null&lt;/tt&gt; then no filtering is applied.
 131  */
 132 Transliterator::Transliterator(const UnicodeString&amp; theID,
 133                                UnicodeFilter* adoptedFilter) :
 134     UObject(), ID(theID), filter(adoptedFilter),
 135     maximumContextLength(0)
 136 {
 137     // NUL-terminate the ID string, which is a non-aliased copy.
 138     ID.append((UChar)0);
 139     ID.truncate(ID.length()-1);
 140 }
 141 
 142 /**
 143  * Destructor.
 144  */
 145 Transliterator::~Transliterator() {
 146     if (filter) {
 147         delete filter;
 148     }
 149 }
 150 
 151 /**
 152  * Copy constructor.
 153  */
 154 Transliterator::Transliterator(const Transliterator&amp; other) :
 155     UObject(other), ID(other.ID), filter(0),
 156     maximumContextLength(other.maximumContextLength)
 157 {
 158     // NUL-terminate the ID string, which is a non-aliased copy.
 159     ID.append((UChar)0);
 160     ID.truncate(ID.length()-1);
 161 
 162     if (other.filter != 0) {
 163         // We own the filter, so we must have our own copy
 164         filter = (UnicodeFilter*) other.filter-&gt;clone();
 165     }
 166 }
 167 
 168 Transliterator* Transliterator::clone() const {
 169     return NULL;
 170 }
 171 
 172 /**
 173  * Assignment operator.
 174  */
 175 Transliterator&amp; Transliterator::operator=(const Transliterator&amp; other) {
 176     ID = other.ID;
 177     // NUL-terminate the ID string
 178     ID.getTerminatedBuffer();
 179 
 180     maximumContextLength = other.maximumContextLength;
 181     adoptFilter((other.filter == 0) ? 0 : (UnicodeFilter*) other.filter-&gt;clone());
 182     return *this;
 183 }
 184 
 185 /**
 186  * Transliterates a segment of a string.  &lt;code&gt;Transliterator&lt;/code&gt; API.
 187  * @param text the string to be transliterated
 188  * @param start the beginning index, inclusive; &lt;code&gt;0 &lt;= start
 189  * &lt;= limit&lt;/code&gt;.
 190  * @param limit the ending index, exclusive; &lt;code&gt;start &lt;= limit
 191  * &lt;= text.length()&lt;/code&gt;.
 192  * @return the new limit index, or -1
 193  */
 194 int32_t Transliterator::transliterate(Replaceable&amp; text,
 195                                       int32_t start, int32_t limit) const {
 196     if (start &lt; 0 ||
 197         limit &lt; start ||
 198         text.length() &lt; limit) {
 199         return -1;
 200     }
 201 
 202     UTransPosition offsets;
 203     offsets.contextStart= start;
 204     offsets.contextLimit = limit;
 205     offsets.start = start;
 206     offsets.limit = limit;
 207     filteredTransliterate(text, offsets, FALSE, TRUE);
 208     return offsets.limit;
 209 }
 210 
 211 /**
 212  * Transliterates an entire string in place. Convenience method.
 213  * @param text the string to be transliterated
 214  */
 215 void Transliterator::transliterate(Replaceable&amp; text) const {
 216     transliterate(text, 0, text.length());
 217 }
 218 
 219 /**
 220  * Transliterates the portion of the text buffer that can be
 221  * transliterated unambiguosly after new text has been inserted,
 222  * typically as a result of a keyboard event.  The new text in
 223  * &lt;code&gt;insertion&lt;/code&gt; will be inserted into &lt;code&gt;text&lt;/code&gt;
 224  * at &lt;code&gt;index.contextLimit&lt;/code&gt;, advancing
 225  * &lt;code&gt;index.contextLimit&lt;/code&gt; by &lt;code&gt;insertion.length()&lt;/code&gt;.
 226  * Then the transliterator will try to transliterate characters of
 227  * &lt;code&gt;text&lt;/code&gt; between &lt;code&gt;index.start&lt;/code&gt; and
 228  * &lt;code&gt;index.contextLimit&lt;/code&gt;.  Characters before
 229  * &lt;code&gt;index.start&lt;/code&gt; will not be changed.
 230  *
 231  * &lt;p&gt;Upon return, values in &lt;code&gt;index&lt;/code&gt; will be updated.
 232  * &lt;code&gt;index.contextStart&lt;/code&gt; will be advanced to the first
 233  * character that future calls to this method will read.
 234  * &lt;code&gt;index.start&lt;/code&gt; and &lt;code&gt;index.contextLimit&lt;/code&gt; will
 235  * be adjusted to delimit the range of text that future calls to
 236  * this method may change.
 237  *
 238  * &lt;p&gt;Typical usage of this method begins with an initial call
 239  * with &lt;code&gt;index.contextStart&lt;/code&gt; and &lt;code&gt;index.contextLimit&lt;/code&gt;
 240  * set to indicate the portion of &lt;code&gt;text&lt;/code&gt; to be
 241  * transliterated, and &lt;code&gt;index.start == index.contextStart&lt;/code&gt;.
 242  * Thereafter, &lt;code&gt;index&lt;/code&gt; can be used without
 243  * modification in future calls, provided that all changes to
 244  * &lt;code&gt;text&lt;/code&gt; are made via this method.
 245  *
 246  * &lt;p&gt;This method assumes that future calls may be made that will
 247  * insert new text into the buffer.  As a result, it only performs
 248  * unambiguous transliterations.  After the last call to this
 249  * method, there may be untransliterated text that is waiting for
 250  * more input to resolve an ambiguity.  In order to perform these
 251  * pending transliterations, clients should call {@link
 252  * #finishKeyboardTransliteration} after the last call to this
 253  * method has been made.
 254  *
 255  * @param text the buffer holding transliterated and untransliterated text
 256  * @param index an array of three integers.
 257  *
 258  * &lt;ul&gt;&lt;li&gt;&lt;code&gt;index.contextStart&lt;/code&gt;: the beginning index,
 259  * inclusive; &lt;code&gt;0 &lt;= index.contextStart &lt;= index.contextLimit&lt;/code&gt;.
 260  *
 261  * &lt;li&gt;&lt;code&gt;index.contextLimit&lt;/code&gt;: the ending index, exclusive;
 262  * &lt;code&gt;index.contextStart &lt;= index.contextLimit &lt;= text.length()&lt;/code&gt;.
 263  * &lt;code&gt;insertion&lt;/code&gt; is inserted at
 264  * &lt;code&gt;index.contextLimit&lt;/code&gt;.
 265  *
 266  * &lt;li&gt;&lt;code&gt;index.start&lt;/code&gt;: the next character to be
 267  * considered for transliteration; &lt;code&gt;index.contextStart &lt;=
 268  * index.start &lt;= index.contextLimit&lt;/code&gt;.  Characters before
 269  * &lt;code&gt;index.start&lt;/code&gt; will not be changed by future calls
 270  * to this method.&lt;/ul&gt;
 271  *
 272  * @param insertion text to be inserted and possibly
 273  * transliterated into the translation buffer at
 274  * &lt;code&gt;index.contextLimit&lt;/code&gt;.  If &lt;code&gt;null&lt;/code&gt; then no text
 275  * is inserted.
 276  * @see #START
 277  * @see #LIMIT
 278  * @see #CURSOR
 279  * @see #handleTransliterate
 280  * @exception IllegalArgumentException if &lt;code&gt;index&lt;/code&gt;
 281  * is invalid
 282  */
 283 void Transliterator::transliterate(Replaceable&amp; text,
 284                                    UTransPosition&amp; index,
 285                                    const UnicodeString&amp; insertion,
 286                                    UErrorCode &amp;status) const {
 287     _transliterate(text, index, &amp;insertion, status);
 288 }
 289 
 290 /**
 291  * Transliterates the portion of the text buffer that can be
 292  * transliterated unambiguosly after a new character has been
 293  * inserted, typically as a result of a keyboard event.  This is a
 294  * convenience method; see {@link
 295  * #transliterate(Replaceable, int[], String)} for details.
 296  * @param text the buffer holding transliterated and
 297  * untransliterated text
 298  * @param index an array of three integers.  See {@link
 299  * #transliterate(Replaceable, int[], String)}.
 300  * @param insertion text to be inserted and possibly
 301  * transliterated into the translation buffer at
 302  * &lt;code&gt;index.contextLimit&lt;/code&gt;.
 303  * @see #transliterate(Replaceable, int[], String)
 304  */
 305 void Transliterator::transliterate(Replaceable&amp; text,
 306                                    UTransPosition&amp; index,
 307                                    UChar32 insertion,
 308                                    UErrorCode&amp; status) const {
 309     UnicodeString str(insertion);
 310     _transliterate(text, index, &amp;str, status);
 311 }
 312 
 313 /**
 314  * Transliterates the portion of the text buffer that can be
 315  * transliterated unambiguosly.  This is a convenience method; see
 316  * {@link #transliterate(Replaceable, int[], String)} for
 317  * details.
 318  * @param text the buffer holding transliterated and
 319  * untransliterated text
 320  * @param index an array of three integers.  See {@link
 321  * #transliterate(Replaceable, int[], String)}.
 322  * @see #transliterate(Replaceable, int[], String)
 323  */
 324 void Transliterator::transliterate(Replaceable&amp; text,
 325                                    UTransPosition&amp; index,
 326                                    UErrorCode&amp; status) const {
 327     _transliterate(text, index, 0, status);
 328 }
 329 
 330 /**
 331  * Finishes any pending transliterations that were waiting for
 332  * more characters.  Clients should call this method as the last
 333  * call after a sequence of one or more calls to
 334  * &lt;code&gt;transliterate()&lt;/code&gt;.
 335  * @param text the buffer holding transliterated and
 336  * untransliterated text.
 337  * @param index the array of indices previously passed to {@link
 338  * #transliterate}
 339  */
 340 void Transliterator::finishTransliteration(Replaceable&amp; text,
 341                                            UTransPosition&amp; index) const {
 342     if (!positionIsValid(index, text.length())) {
 343         return;
 344     }
 345 
 346     filteredTransliterate(text, index, FALSE, TRUE);
 347 }
 348 
 349 /**
 350  * This internal method does keyboard transliteration.  If the
 351  * &#39;insertion&#39; is non-null then we append it to &#39;text&#39; before
 352  * proceeding.  This method calls through to the pure virtual
 353  * framework method handleTransliterate() to do the actual
 354  * work.
 355  */
 356 void Transliterator::_transliterate(Replaceable&amp; text,
 357                                     UTransPosition&amp; index,
 358                                     const UnicodeString* insertion,
 359                                     UErrorCode &amp;status) const {
 360     if (U_FAILURE(status)) {
 361         return;
 362     }
 363 
 364     if (!positionIsValid(index, text.length())) {
 365         status = U_ILLEGAL_ARGUMENT_ERROR;
 366         return;
 367     }
 368 
 369 //    int32_t originalStart = index.contextStart;
 370     if (insertion != 0) {
 371         text.handleReplaceBetween(index.limit, index.limit, *insertion);
 372         index.limit += insertion-&gt;length();
 373         index.contextLimit += insertion-&gt;length();
 374     }
 375 
 376     if (index.limit &gt; 0 &amp;&amp;
 377         U16_IS_LEAD(text.charAt(index.limit - 1))) {
 378         // Oops, there is a dangling lead surrogate in the buffer.
 379         // This will break most transliterators, since they will
 380         // assume it is part of a pair.  Don&#39;t transliterate until
 381         // more text comes in.
 382         return;
 383     }
 384 
 385     filteredTransliterate(text, index, TRUE, TRUE);
 386 
 387 #if 0
 388     // TODO
 389     // I CAN&#39;T DO what I&#39;m attempting below now that the Kleene star
 390     // operator is supported.  For example, in the rule
 391 
 392     //   ([:Lu:]+) { x } &gt; $1;
 393 
 394     // what is the maximum context length?  getMaximumContextLength()
 395     // will return 1, but this is just the length of the ante context
 396     // part of the pattern string -- 1 character, which is a standin
 397     // for a Quantifier, which contains a StringMatcher, which
 398     // contains a UnicodeSet.
 399 
 400     // There is a complicated way to make this work again, and that&#39;s
 401     // to add a &quot;maximum left context&quot; protocol into the
 402     // UnicodeMatcher hierarchy.  At present I&#39;m not convinced this is
 403     // worth it.
 404 
 405     // ---
 406 
 407     // The purpose of the code below is to keep the context small
 408     // while doing incremental transliteration.  When part of the left
 409     // context (between contextStart and start) is no longer needed,
 410     // we try to advance contextStart past that portion.  We use the
 411     // maximum context length to do so.
 412     int32_t newCS = index.start;
 413     int32_t n = getMaximumContextLength();
 414     while (newCS &gt; originalStart &amp;&amp; n-- &gt; 0) {
 415         --newCS;
 416         newCS -= U16_LENGTH(text.char32At(newCS)) - 1;
 417     }
 418     index.contextStart = uprv_max(newCS, originalStart);
 419 #endif
 420 }
 421 
 422 /**
 423  * This method breaks up the input text into runs of unfiltered
 424  * characters.  It passes each such run to
 425  * &lt;subclass&gt;.handleTransliterate().  Subclasses that can handle the
 426  * filter logic more efficiently themselves may override this method.
 427  *
 428  * All transliteration calls in this class go through this method.
 429  */
 430 void Transliterator::filteredTransliterate(Replaceable&amp; text,
 431                                            UTransPosition&amp; index,
 432                                            UBool incremental,
 433                                            UBool rollback) const {
 434     // Short circuit path for transliterators with no filter in
 435     // non-incremental mode.
 436     if (filter == 0 &amp;&amp; !rollback) {
 437         handleTransliterate(text, index, incremental);
 438         return;
 439     }
 440 
 441     //----------------------------------------------------------------------
 442     // This method processes text in two groupings:
 443     //
 444     // RUNS -- A run is a contiguous group of characters which are contained
 445     // in the filter for this transliterator (filter.contains(ch) == TRUE).
 446     // Text outside of runs may appear as context but it is not modified.
 447     // The start and limit Position values are narrowed to each run.
 448     //
 449     // PASSES (incremental only) -- To make incremental mode work correctly,
 450     // each run is broken up into n passes, where n is the length (in code
 451     // points) of the run.  Each pass contains the first n characters.  If a
 452     // pass is completely transliterated, it is committed, and further passes
 453     // include characters after the committed text.  If a pass is blocked,
 454     // and does not transliterate completely, then this method rolls back
 455     // the changes made during the pass, extends the pass by one code point,
 456     // and tries again.
 457     //----------------------------------------------------------------------
 458 
 459     // globalLimit is the limit value for the entire operation.  We
 460     // set index.limit to the end of each unfiltered run before
 461     // calling handleTransliterate(), so we need to maintain the real
 462     // value of index.limit here.  After each transliteration, we
 463     // update globalLimit for insertions or deletions that have
 464     // happened.
 465     int32_t globalLimit = index.limit;
 466 
 467     // If there is a non-null filter, then break the input text up.  Say the
 468     // input text has the form:
 469     //   xxxabcxxdefxx
 470     // where &#39;x&#39; represents a filtered character (filter.contains(&#39;x&#39;) ==
 471     // false).  Then we break this up into:
 472     //   xxxabc xxdef xx
 473     // Each pass through the loop consumes a run of filtered
 474     // characters (which are ignored) and a subsequent run of
 475     // unfiltered characters (which are transliterated).
 476 
 477     for (;;) {
 478 
 479         if (filter != NULL) {
 480             // Narrow the range to be transliterated to the first segment
 481             // of unfiltered characters at or after index.start.
 482 
 483             // Advance past filtered chars
 484             UChar32 c;
 485             while (index.start &lt; globalLimit &amp;&amp;
 486                    !filter-&gt;contains(c=text.char32At(index.start))) {
 487                 index.start += U16_LENGTH(c);
 488             }
 489 
 490             // Find the end of this run of unfiltered chars
 491             index.limit = index.start;
 492             while (index.limit &lt; globalLimit &amp;&amp;
 493                    filter-&gt;contains(c=text.char32At(index.limit))) {
 494                 index.limit += U16_LENGTH(c);
 495             }
 496         }
 497 
 498         // Check to see if the unfiltered run is empty.  This only
 499         // happens at the end of the string when all the remaining
 500         // characters are filtered.
 501         if (index.limit == index.start) {
 502             // assert(index.start == globalLimit);
 503             break;
 504         }
 505 
 506         // Is this run incremental?  If there is additional
 507         // filtered text (if limit &lt; globalLimit) then we pass in
 508         // an incremental value of FALSE to force the subclass to
 509         // complete the transliteration for this run.
 510         UBool isIncrementalRun =
 511             (index.limit &lt; globalLimit ? FALSE : incremental);
 512 
 513         int32_t delta;
 514 
 515         // Implement rollback.  To understand the need for rollback,
 516         // consider the following transliterator:
 517         //
 518         //  &quot;t&quot; is &quot;a &gt; A;&quot;
 519         //  &quot;u&quot; is &quot;A &gt; b;&quot;
 520         //  &quot;v&quot; is a compound of &quot;t; NFD; u&quot; with a filter [:Ll:]
 521         //
 522         // Now apply &quot;c&quot; to the input text &quot;a&quot;.  The result is &quot;b&quot;.  But if
 523         // the transliteration is done incrementally, then the NFD holds
 524         // things up after &quot;t&quot; has already transformed &quot;a&quot; to &quot;A&quot;.  When
 525         // finishTransliterate() is called, &quot;A&quot; is _not_ processed because
 526         // it gets excluded by the [:Ll:] filter, and the end result is &quot;A&quot;
 527         // -- incorrect.  The problem is that the filter is applied to a
 528         // partially-transliterated result, when we only want it to apply to
 529         // input text.  Although this example hinges on a compound
 530         // transliterator containing NFD and a specific filter, it can
 531         // actually happen with any transliterator which may do a partial
 532         // transformation in incremental mode into characters outside its
 533         // filter.
 534         //
 535         // To handle this, when in incremental mode we supply characters to
 536         // handleTransliterate() in several passes.  Each pass adds one more
 537         // input character to the input text.  That is, for input &quot;ABCD&quot;, we
 538         // first try &quot;A&quot;, then &quot;AB&quot;, then &quot;ABC&quot;, and finally &quot;ABCD&quot;.  If at
 539         // any point we block (upon return, start &lt; limit) then we roll
 540         // back.  If at any point we complete the run (upon return start ==
 541         // limit) then we commit that run.
 542 
 543         if (rollback &amp;&amp; isIncrementalRun) {
 544 
 545             int32_t runStart = index.start;
 546             int32_t runLimit = index.limit;
 547             int32_t runLength =  runLimit - runStart;
 548 
 549             // Make a rollback copy at the end of the string
 550             int32_t rollbackOrigin = text.length();
 551             text.copy(runStart, runLimit, rollbackOrigin);
 552 
 553             // Variables reflecting the commitment of completely
 554             // transliterated text.  passStart is the runStart, advanced
 555             // past committed text.  rollbackStart is the rollbackOrigin,
 556             // advanced past rollback text that corresponds to committed
 557             // text.
 558             int32_t passStart = runStart;
 559             int32_t rollbackStart = rollbackOrigin;
 560 
 561             // The limit for each pass; we advance by one code point with
 562             // each iteration.
 563             int32_t passLimit = index.start;
 564 
 565             // Total length, in 16-bit code units, of uncommitted text.
 566             // This is the length to be rolled back.
 567             int32_t uncommittedLength = 0;
 568 
 569             // Total delta (change in length) for all passes
 570             int32_t totalDelta = 0;
 571 
 572             // PASS MAIN LOOP -- Start with a single character, and extend
 573             // the text by one character at a time.  Roll back partial
 574             // transliterations and commit complete transliterations.
 575             for (;;) {
 576                 // Length of additional code point, either one or two
 577                 int32_t charLength = U16_LENGTH(text.char32At(passLimit));
 578                 passLimit += charLength;
 579                 if (passLimit &gt; runLimit) {
 580                     break;
 581                 }
 582                 uncommittedLength += charLength;
 583 
 584                 index.limit = passLimit;
 585 
 586                 // Delegate to subclass for actual transliteration.  Upon
 587                 // return, start will be updated to point after the
 588                 // transliterated text, and limit and contextLimit will be
 589                 // adjusted for length changes.
 590                 handleTransliterate(text, index, TRUE);
 591 
 592                 delta = index.limit - passLimit; // change in length
 593 
 594                 // We failed to completely transliterate this pass.
 595                 // Roll back the text.  Indices remain unchanged; reset
 596                 // them where necessary.
 597                 if (index.start != index.limit) {
 598                     // Find the rollbackStart, adjusted for length changes
 599                     // and the deletion of partially transliterated text.
 600                     int32_t rs = rollbackStart + delta - (index.limit - passStart);
 601 
 602                     // Delete the partially transliterated text
 603                     text.handleReplaceBetween(passStart, index.limit, UnicodeString());
 604 
 605                     // Copy the rollback text back
 606                     text.copy(rs, rs + uncommittedLength, passStart);
 607 
 608                     // Restore indices to their original values
 609                     index.start = passStart;
 610                     index.limit = passLimit;
 611                     index.contextLimit -= delta;
 612                 }
 613 
 614                 // We did completely transliterate this pass.  Update the
 615                 // commit indices to record how far we got.  Adjust indices
 616                 // for length change.
 617                 else {
 618                     // Move the pass indices past the committed text.
 619                     passStart = passLimit = index.start;
 620 
 621                     // Adjust the rollbackStart for length changes and move
 622                     // it past the committed text.  All characters we&#39;ve
 623                     // processed to this point are committed now, so zero
 624                     // out the uncommittedLength.
 625                     rollbackStart += delta + uncommittedLength;
 626                     uncommittedLength = 0;
 627 
 628                     // Adjust indices for length changes.
 629                     runLimit += delta;
 630                     totalDelta += delta;
 631                 }
 632             }
 633 
 634             // Adjust overall limit and rollbackOrigin for insertions and
 635             // deletions.  Don&#39;t need to worry about contextLimit because
 636             // handleTransliterate() maintains that.
 637             rollbackOrigin += totalDelta;
 638             globalLimit += totalDelta;
 639 
 640             // Delete the rollback copy
 641             text.handleReplaceBetween(rollbackOrigin, rollbackOrigin + runLength, UnicodeString());
 642 
 643             // Move start past committed text
 644             index.start = passStart;
 645         }
 646 
 647         else {
 648             // Delegate to subclass for actual transliteration.
 649             int32_t limit = index.limit;
 650             handleTransliterate(text, index, isIncrementalRun);
 651             delta = index.limit - limit; // change in length
 652 
 653             // In a properly written transliterator, start == limit after
 654             // handleTransliterate() returns when incremental is false.
 655             // Catch cases where the subclass doesn&#39;t do this, and throw
 656             // an exception.  (Just pinning start to limit is a bad idea,
 657             // because what&#39;s probably happening is that the subclass
 658             // isn&#39;t transliterating all the way to the end, and it should
 659             // in non-incremental mode.)
 660             if (!incremental &amp;&amp; index.start != index.limit) {
 661                 // We can&#39;t throw an exception, so just fudge things
 662                 index.start = index.limit;
 663             }
 664 
 665             // Adjust overall limit for insertions/deletions.  Don&#39;t need
 666             // to worry about contextLimit because handleTransliterate()
 667             // maintains that.
 668             globalLimit += delta;
 669         }
 670 
 671         if (filter == NULL || isIncrementalRun) {
 672             break;
 673         }
 674 
 675         // If we did completely transliterate this
 676         // run, then repeat with the next unfiltered run.
 677     }
 678 
 679     // Start is valid where it is.  Limit needs to be put back where
 680     // it was, modulo adjustments for deletions/insertions.
 681     index.limit = globalLimit;
 682 }
 683 
 684 void Transliterator::filteredTransliterate(Replaceable&amp; text,
 685                                            UTransPosition&amp; index,
 686                                            UBool incremental) const {
 687     filteredTransliterate(text, index, incremental, FALSE);
 688 }
 689 
 690 /**
 691  * Method for subclasses to use to set the maximum context length.
 692  * @see #getMaximumContextLength
 693  */
 694 void Transliterator::setMaximumContextLength(int32_t maxContextLength) {
 695     maximumContextLength = maxContextLength;
 696 }
 697 
 698 /**
 699  * Returns a programmatic identifier for this transliterator.
 700  * If this identifier is passed to &lt;code&gt;getInstance()&lt;/code&gt;, it
 701  * will return this object, if it has been registered.
 702  * @see #registerInstance
 703  * @see #getAvailableIDs
 704  */
 705 const UnicodeString&amp; Transliterator::getID(void) const {
 706     return ID;
 707 }
 708 
 709 /**
 710  * Returns a name for this transliterator that is appropriate for
 711  * display to the user in the default locale.  See {@link
 712  * #getDisplayName(Locale)} for details.
 713  */
 714 UnicodeString&amp; U_EXPORT2 Transliterator::getDisplayName(const UnicodeString&amp; ID,
 715                                               UnicodeString&amp; result) {
 716     return getDisplayName(ID, Locale::getDefault(), result);
 717 }
 718 
 719 /**
 720  * Returns a name for this transliterator that is appropriate for
 721  * display to the user in the given locale.  This name is taken
 722  * from the locale resource data in the standard manner of the
 723  * &lt;code&gt;java.text&lt;/code&gt; package.
 724  *
 725  * &lt;p&gt;If no localized names exist in the system resource bundles,
 726  * a name is synthesized using a localized
 727  * &lt;code&gt;MessageFormat&lt;/code&gt; pattern from the resource data.  The
 728  * arguments to this pattern are an integer followed by one or two
 729  * strings.  The integer is the number of strings, either 1 or 2.
 730  * The strings are formed by splitting the ID for this
 731  * transliterator at the first TARGET_SEP.  If there is no TARGET_SEP, then the
 732  * entire ID forms the only string.
 733  * @param inLocale the Locale in which the display name should be
 734  * localized.
 735  * @see java.text.MessageFormat
 736  */
 737 UnicodeString&amp; U_EXPORT2 Transliterator::getDisplayName(const UnicodeString&amp; id,
 738                                               const Locale&amp; inLocale,
 739                                               UnicodeString&amp; result) {
 740     UErrorCode status = U_ZERO_ERROR;
 741 
 742     ResourceBundle bundle(U_ICUDATA_TRANSLIT, inLocale, status);
 743 
 744     // Suspend checking status until later...
 745 
 746     result.truncate(0);
 747 
 748     // Normalize the ID
 749     UnicodeString source, target, variant;
 750     UBool sawSource;
 751     TransliteratorIDParser::IDtoSTV(id, source, target, variant, sawSource);
 752     if (target.length() &lt; 1) {
 753         // No target; malformed id
 754         return result;
 755     }
 756     if (variant.length() &gt; 0) { // Change &quot;Foo&quot; to &quot;/Foo&quot;
 757         variant.insert(0, VARIANT_SEP);
 758     }
 759     UnicodeString ID(source);
 760     ID.append(TARGET_SEP).append(target).append(variant);
 761 
 762     // build the char* key
 763     if (uprv_isInvariantUString(ID.getBuffer(), ID.length())) {
 764         char key[200];
 765         uprv_strcpy(key, RB_DISPLAY_NAME_PREFIX);
 766         int32_t length=(int32_t)uprv_strlen(RB_DISPLAY_NAME_PREFIX);
 767         ID.extract(0, (int32_t)(sizeof(key)-length), key+length, (int32_t)(sizeof(key)-length), US_INV);
 768 
 769         // Try to retrieve a UnicodeString from the bundle.
 770         UnicodeString resString = bundle.getStringEx(key, status);
 771 
 772         if (U_SUCCESS(status) &amp;&amp; resString.length() != 0) {
 773             return result = resString; // [sic] assign &amp; return
 774         }
 775 
 776 #if !UCONFIG_NO_FORMATTING
 777         // We have failed to get a name from the locale data.  This is
 778         // typical, since most transliterators will not have localized
 779         // name data.  The next step is to retrieve the MessageFormat
 780         // pattern from the locale data and to use it to synthesize the
 781         // name from the ID.
 782 
 783         status = U_ZERO_ERROR;
 784         resString = bundle.getStringEx(RB_DISPLAY_NAME_PATTERN, status);
 785 
 786         if (U_SUCCESS(status) &amp;&amp; resString.length() != 0) {
 787             MessageFormat msg(resString, inLocale, status);
 788             // Suspend checking status until later...
 789 
 790             // We pass either 2 or 3 Formattable objects to msg.
 791             Formattable args[3];
 792             int32_t nargs;
 793             args[0].setLong(2); // # of args to follow
 794             args[1].setString(source);
 795             args[2].setString(target);
 796             nargs = 3;
 797 
 798             // Use display names for the scripts, if they exist
 799             UnicodeString s;
 800             length=(int32_t)uprv_strlen(RB_SCRIPT_DISPLAY_NAME_PREFIX);
 801             for (int j=1; j&lt;=2; ++j) {
 802                 status = U_ZERO_ERROR;
 803                 uprv_strcpy(key, RB_SCRIPT_DISPLAY_NAME_PREFIX);
 804                 args[j].getString(s);
 805                 if (uprv_isInvariantUString(s.getBuffer(), s.length())) {
 806                     s.extract(0, sizeof(key)-length-1, key+length, (int32_t)sizeof(key)-length-1, US_INV);
 807 
 808                     resString = bundle.getStringEx(key, status);
 809 
 810                     if (U_SUCCESS(status)) {
 811                         args[j] = resString;
 812                     }
 813                 }
 814             }
 815 
 816             status = U_ZERO_ERROR;
 817             FieldPosition pos; // ignored by msg
 818             msg.format(args, nargs, result, pos, status);
 819             if (U_SUCCESS(status)) {
 820                 result.append(variant);
 821                 return result;
 822             }
 823         }
 824 #endif
 825     }
 826 
 827     // We should not reach this point unless there is something
 828     // wrong with the build or the RB_DISPLAY_NAME_PATTERN has
 829     // been deleted from the root RB_LOCALE_ELEMENTS resource.
 830     result = ID;
 831     return result;
 832 }
 833 
 834 /**
 835  * Returns the filter used by this transliterator, or &lt;tt&gt;null&lt;/tt&gt;
 836  * if this transliterator uses no filter.  Caller musn&#39;t delete
 837  * the result!
 838  */
 839 const UnicodeFilter* Transliterator::getFilter(void) const {
 840     return filter;
 841 }
 842 
 843 /**
 844  * Returns the filter used by this transliterator, or
 845  * &lt;tt&gt;NULL&lt;/tt&gt; if this transliterator uses no filter.  The
 846  * caller must eventually delete the result.  After this call,
 847  * this transliterator&#39;s filter is set to &lt;tt&gt;NULL&lt;/tt&gt;.
 848  */
 849 UnicodeFilter* Transliterator::orphanFilter(void) {
 850     UnicodeFilter *result = filter;
 851     filter = NULL;
 852     return result;
 853 }
 854 
 855 /**
 856  * Changes the filter used by this transliterator.  If the filter
 857  * is set to &lt;tt&gt;null&lt;/tt&gt; then no filtering will occur.
 858  *
 859  * &lt;p&gt;Callers must take care if a transliterator is in use by
 860  * multiple threads.  The filter should not be changed by one
 861  * thread while another thread may be transliterating.
 862  */
 863 void Transliterator::adoptFilter(UnicodeFilter* filterToAdopt) {
 864     delete filter;
 865     filter = filterToAdopt;
 866 }
 867 
 868 /**
 869  * Returns this transliterator&#39;s inverse.  See the class
 870  * documentation for details.  This implementation simply inverts
 871  * the two entities in the ID and attempts to retrieve the
 872  * resulting transliterator.  That is, if &lt;code&gt;getID()&lt;/code&gt;
 873  * returns &quot;A-B&quot;, then this method will return the result of
 874  * &lt;code&gt;getInstance(&quot;B-A&quot;)&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if that
 875  * call fails.
 876  *
 877  * &lt;p&gt;This method does not take filtering into account.  The
 878  * returned transliterator will have no filter.
 879  *
 880  * &lt;p&gt;Subclasses with knowledge of their inverse may wish to
 881  * override this method.
 882  *
 883  * @return a transliterator that is an inverse, not necessarily
 884  * exact, of this transliterator, or &lt;code&gt;null&lt;/code&gt; if no such
 885  * transliterator is registered.
 886  * @see #registerInstance
 887  */
 888 Transliterator* Transliterator::createInverse(UErrorCode&amp; status) const {
 889     UParseError parseError;
 890     return Transliterator::createInstance(ID, UTRANS_REVERSE,parseError,status);
 891 }
 892 
 893 Transliterator* U_EXPORT2
 894 Transliterator::createInstance(const UnicodeString&amp; ID,
 895                                 UTransDirection dir,
 896                                 UErrorCode&amp; status)
 897 {
 898     UParseError parseError;
 899     return createInstance(ID, dir, parseError, status);
 900 }
 901 
 902 /**
 903  * Returns a &lt;code&gt;Transliterator&lt;/code&gt; object given its ID.
 904  * The ID must be either a system transliterator ID or a ID registered
 905  * using &lt;code&gt;registerInstance()&lt;/code&gt;.
 906  *
 907  * @param ID a valid ID, as enumerated by &lt;code&gt;getAvailableIDs()&lt;/code&gt;
 908  * @return A &lt;code&gt;Transliterator&lt;/code&gt; object with the given ID
 909  * @see #registerInstance
 910  * @see #getAvailableIDs
 911  * @see #getID
 912  */
 913 Transliterator* U_EXPORT2
 914 Transliterator::createInstance(const UnicodeString&amp; ID,
 915                                 UTransDirection dir,
 916                                 UParseError&amp; parseError,
 917                                 UErrorCode&amp; status)
 918 {
 919     if (U_FAILURE(status)) {
 920         return 0;
 921     }
 922 
 923     UnicodeString canonID;
 924     UVector list(status);
 925     if (U_FAILURE(status)) {
 926         return NULL;
 927     }
 928 
 929     UnicodeSet* globalFilter;
 930     // TODO add code for parseError...currently unused, but
 931     // later may be used by parsing code...
 932     if (!TransliteratorIDParser::parseCompoundID(ID, dir, canonID, list, globalFilter)) {
 933         status = U_INVALID_ID;
 934         return NULL;
 935     }
 936 
 937     TransliteratorIDParser::instantiateList(list, status);
 938     if (U_FAILURE(status)) {
 939         return NULL;
 940     }
 941 
 942     U_ASSERT(list.size() &gt; 0);
 943     Transliterator* t = NULL;
 944 
 945     if (list.size() &gt; 1 || canonID.indexOf(ID_DELIM) &gt;= 0) {
 946         // [NOTE: If it&#39;s a compoundID, we instantiate a CompoundTransliterator even if it only
 947         // has one child transliterator.  This is so that toRules() will return the right thing
 948         // (without any inactive ID), but our main ID still comes out correct.  That is, if we
 949         // instantiate &quot;(Lower);Latin-Greek;&quot;, we want the rules to come out as &quot;::Latin-Greek;&quot;
 950         // even though the ID is &quot;(Lower);Latin-Greek;&quot;.
 951         t = new CompoundTransliterator(list, parseError, status);
 952     }
 953     else {
 954         t = (Transliterator*)list.elementAt(0);
 955     }
 956     // Check null pointer
 957     if (t != NULL) {
 958         t-&gt;setID(canonID);
 959         if (globalFilter != NULL) {
 960             t-&gt;adoptFilter(globalFilter);
 961         }
 962     }
 963     else if (U_SUCCESS(status)) {
 964         status = U_MEMORY_ALLOCATION_ERROR;
 965     }
 966     return t;
 967 }
 968 
 969 /**
 970  * Create a transliterator from a basic ID.  This is an ID
 971  * containing only the forward direction source, target, and
 972  * variant.
 973  * @param id a basic ID of the form S-T or S-T/V.
 974  * @return a newly created Transliterator or null if the ID is
 975  * invalid.
 976  */
 977 Transliterator* Transliterator::createBasicInstance(const UnicodeString&amp; id,
 978                                                     const UnicodeString* canon) {
 979     UParseError pe;
 980     UErrorCode ec = U_ZERO_ERROR;
 981     TransliteratorAlias* alias = 0;
 982     Transliterator* t = 0;
 983 
 984     umtx_lock(registryMutex());
 985     if (HAVE_REGISTRY(ec)) {
 986         t = registry-&gt;get(id, alias, ec);
 987     }
 988     umtx_unlock(registryMutex());
 989 
 990     if (U_FAILURE(ec)) {
 991         delete t;
 992         delete alias;
 993         return 0;
 994     }
 995 
 996     // We may have not gotten a transliterator:  Because we can&#39;t
 997     // instantiate a transliterator from inside TransliteratorRegistry::
 998     // get() (that would deadlock), we sometimes pass back an alias.  This
 999     // contains the data we need to finish the instantiation outside the
1000     // registry mutex.  The alias may, in turn, generate another alias, so
1001     // we handle aliases in a loop.  The max times through the loop is two.
1002     // [alan]
1003     while (alias != 0) {
1004         U_ASSERT(t==0);
1005         // Rule-based aliases are handled with TransliteratorAlias::
1006         // parse(), followed by TransliteratorRegistry::reget().
1007         // Other aliases are handled with TransliteratorAlias::create().
1008         if (alias-&gt;isRuleBased()) {
1009             // Step 1. parse
1010             TransliteratorParser parser(ec);
1011             alias-&gt;parse(parser, pe, ec);
1012             delete alias;
1013             alias = 0;
1014 
1015             // Step 2. reget
1016             umtx_lock(registryMutex());
1017             if (HAVE_REGISTRY(ec)) {
1018                 t = registry-&gt;reget(id, parser, alias, ec);
1019             }
1020             umtx_unlock(registryMutex());
1021 
1022             // Step 3. Loop back around!
1023         } else {
1024             t = alias-&gt;create(pe, ec);
1025             delete alias;
1026             alias = 0;
1027             break;
1028         }
1029         if (U_FAILURE(ec)) {
1030             delete t;
1031             delete alias;
1032             t = NULL;
1033             break;
1034         }
1035     }
1036 
1037     if (t != NULL &amp;&amp; canon != NULL) {
1038         t-&gt;setID(*canon);
1039     }
1040 
1041     return t;
1042 }
1043 
1044 /**
1045  * Returns a &lt;code&gt;Transliterator&lt;/code&gt; object constructed from
1046  * the given rule string.  This will be a RuleBasedTransliterator,
1047  * if the rule string contains only rules, or a
1048  * CompoundTransliterator, if it contains ID blocks, or a
1049  * NullTransliterator, if it contains ID blocks which parse as
1050  * empty for the given direction.
1051  */
1052 Transliterator* U_EXPORT2
1053 Transliterator::createFromRules(const UnicodeString&amp; ID,
1054                                 const UnicodeString&amp; rules,
1055                                 UTransDirection dir,
1056                                 UParseError&amp; parseError,
1057                                 UErrorCode&amp; status)
1058 {
1059     Transliterator* t = NULL;
1060 
1061     TransliteratorParser parser(status);
1062     parser.parse(rules, dir, parseError, status);
1063 
1064     if (U_FAILURE(status)) {
1065         return 0;
1066     }
1067 
1068     // NOTE: The logic here matches that in TransliteratorRegistry.
1069     if (parser.idBlockVector.size() == 0 &amp;&amp; parser.dataVector.size() == 0) {
1070         t = new NullTransliterator();
1071     }
1072     else if (parser.idBlockVector.size() == 0 &amp;&amp; parser.dataVector.size() == 1) {
1073         t = new RuleBasedTransliterator(ID, (TransliterationRuleData*)parser.dataVector.orphanElementAt(0), TRUE);
1074     }
1075     else if (parser.idBlockVector.size() == 1 &amp;&amp; parser.dataVector.size() == 0) {
1076         // idBlock, no data -- this is an alias.  The ID has
1077         // been munged from reverse into forward mode, if
1078         // necessary, so instantiate the ID in the forward
1079         // direction.
1080         if (parser.compoundFilter != NULL) {
1081             UnicodeString filterPattern;
1082             parser.compoundFilter-&gt;toPattern(filterPattern, FALSE);
1083             t = createInstance(filterPattern + UnicodeString(ID_DELIM)
1084                     + *((UnicodeString*)parser.idBlockVector.elementAt(0)), UTRANS_FORWARD, parseError, status);
1085         }
1086         else
1087             t = createInstance(*((UnicodeString*)parser.idBlockVector.elementAt(0)), UTRANS_FORWARD, parseError, status);
1088 
1089 
1090         if (t != NULL) {
1091             t-&gt;setID(ID);
1092         }
1093     }
1094     else {
1095         UVector transliterators(status);
1096         int32_t passNumber = 1;
1097 
1098         int32_t limit = parser.idBlockVector.size();
1099         if (parser.dataVector.size() &gt; limit)
1100             limit = parser.dataVector.size();
1101 
1102         for (int32_t i = 0; i &lt; limit; i++) {
1103             if (i &lt; parser.idBlockVector.size()) {
1104                 UnicodeString* idBlock = (UnicodeString*)parser.idBlockVector.elementAt(i);
1105                 if (!idBlock-&gt;isEmpty()) {
1106                     Transliterator* temp = createInstance(*idBlock, UTRANS_FORWARD, parseError, status);
1107                     if (temp != NULL &amp;&amp; typeid(*temp) != typeid(NullTransliterator))
1108                         transliterators.addElement(temp, status);
1109                     else
1110                         delete temp;
1111                 }
1112             }
1113             if (!parser.dataVector.isEmpty()) {
1114                 TransliterationRuleData* data = (TransliterationRuleData*)parser.dataVector.orphanElementAt(0);
1115                 // TODO: Should passNumber be turned into a decimal-string representation (1 -&gt; &quot;1&quot;)?
1116                 RuleBasedTransliterator* temprbt = new RuleBasedTransliterator(UnicodeString(CompoundTransliterator::PASS_STRING) + UnicodeString(passNumber++),
1117                         data, TRUE);
1118                 // Check if NULL before adding it to transliterators to avoid future usage of NULL pointer.
1119                 if (temprbt == NULL) {
1120                     status = U_MEMORY_ALLOCATION_ERROR;
1121                     return t;
1122                 }
1123                 transliterators.addElement(temprbt, status);
1124             }
1125         }
1126 
1127         t = new CompoundTransliterator(transliterators, passNumber - 1, parseError, status);
1128         // Null pointer check
1129         if (t != NULL) {
1130             t-&gt;setID(ID);
1131             t-&gt;adoptFilter(parser.orphanCompoundFilter());
1132         }
1133     }
1134     if (U_SUCCESS(status) &amp;&amp; t == NULL) {
1135         status = U_MEMORY_ALLOCATION_ERROR;
1136     }
1137     return t;
1138 }
1139 
1140 UnicodeString&amp; Transliterator::toRules(UnicodeString&amp; rulesSource,
1141                                        UBool escapeUnprintable) const {
1142     // The base class implementation of toRules munges the ID into
1143     // the correct format.  That is: foo =&gt; ::foo
1144     if (escapeUnprintable) {
1145         rulesSource.truncate(0);
1146         UnicodeString id = getID();
1147         for (int32_t i=0; i&lt;id.length();) {
1148             UChar32 c = id.char32At(i);
1149             if (!ICU_Utility::escapeUnprintable(rulesSource, c)) {
1150                 rulesSource.append(c);
1151             }
1152             i += U16_LENGTH(c);
1153         }
1154     } else {
1155         rulesSource = getID();
1156     }
1157     // KEEP in sync with rbt_pars
1158     rulesSource.insert(0, UNICODE_STRING_SIMPLE(&quot;::&quot;));
1159     rulesSource.append(ID_DELIM);
1160     return rulesSource;
1161 }
1162 
1163 int32_t Transliterator::countElements() const {
1164     const CompoundTransliterator* ct = dynamic_cast&lt;const CompoundTransliterator*&gt;(this);
1165     return ct != NULL ? ct-&gt;getCount() : 0;
1166 }
1167 
1168 const Transliterator&amp; Transliterator::getElement(int32_t index, UErrorCode&amp; ec) const {
1169     if (U_FAILURE(ec)) {
1170         return *this;
1171     }
1172     const CompoundTransliterator* cpd = dynamic_cast&lt;const CompoundTransliterator*&gt;(this);
1173     int32_t n = (cpd == NULL) ? 1 : cpd-&gt;getCount();
1174     if (index &lt; 0 || index &gt;= n) {
1175         ec = U_INDEX_OUTOFBOUNDS_ERROR;
1176         return *this;
1177     } else {
1178         return (n == 1) ? *this : cpd-&gt;getTransliterator(index);
1179     }
1180 }
1181 
1182 UnicodeSet&amp; Transliterator::getSourceSet(UnicodeSet&amp; result) const {
1183     handleGetSourceSet(result);
1184     if (filter != NULL) {
1185         UnicodeSet* filterSet = dynamic_cast&lt;UnicodeSet*&gt;(filter);
1186         UBool deleteFilterSet = FALSE;
1187         // Most, but not all filters will be UnicodeSets.  Optimize for
1188         // the high-runner case.
1189         if (filterSet == NULL) {
1190             filterSet = new UnicodeSet();
1191             // Check null pointer
1192             if (filterSet == NULL) {
1193                 return result;
1194             }
1195             deleteFilterSet = TRUE;
1196             filter-&gt;addMatchSetTo(*filterSet);
1197         }
1198         result.retainAll(*filterSet);
1199         if (deleteFilterSet) {
1200             delete filterSet;
1201         }
1202     }
1203     return result;
1204 }
1205 
1206 void Transliterator::handleGetSourceSet(UnicodeSet&amp; result) const {
1207     result.clear();
1208 }
1209 
1210 UnicodeSet&amp; Transliterator::getTargetSet(UnicodeSet&amp; result) const {
1211     return result.clear();
1212 }
1213 
1214 // For public consumption
1215 void U_EXPORT2 Transliterator::registerFactory(const UnicodeString&amp; id,
1216                                      Transliterator::Factory factory,
1217                                      Transliterator::Token context) {
1218     Mutex lock(registryMutex());
1219     UErrorCode ec = U_ZERO_ERROR;
1220     if (HAVE_REGISTRY(ec)) {
1221         _registerFactory(id, factory, context);
1222     }
1223 }
1224 
1225 // To be called only by Transliterator subclasses that are called
1226 // to register themselves by initializeRegistry().
1227 void Transliterator::_registerFactory(const UnicodeString&amp; id,
1228                                       Transliterator::Factory factory,
1229                                       Transliterator::Token context) {
1230     UErrorCode ec = U_ZERO_ERROR;
1231     registry-&gt;put(id, factory, context, TRUE, ec);
1232 }
1233 
1234 // To be called only by Transliterator subclasses that are called
1235 // to register themselves by initializeRegistry().
1236 void Transliterator::_registerSpecialInverse(const UnicodeString&amp; target,
1237                                              const UnicodeString&amp; inverseTarget,
1238                                              UBool bidirectional) {
1239     UErrorCode status = U_ZERO_ERROR;
1240     TransliteratorIDParser::registerSpecialInverse(target, inverseTarget, bidirectional, status);
1241 }
1242 
1243 /**
1244  * Registers a instance &lt;tt&gt;obj&lt;/tt&gt; of a subclass of
1245  * &lt;code&gt;Transliterator&lt;/code&gt; with the system.  This object must
1246  * implement the &lt;tt&gt;clone()&lt;/tt&gt; method.  When
1247  * &lt;tt&gt;getInstance()&lt;/tt&gt; is called with an ID string that is
1248  * equal to &lt;tt&gt;obj.getID()&lt;/tt&gt;, then &lt;tt&gt;obj.clone()&lt;/tt&gt; is
1249  * returned.
1250  *
1251  * @param obj an instance of subclass of
1252  * &lt;code&gt;Transliterator&lt;/code&gt; that defines &lt;tt&gt;clone()&lt;/tt&gt;
1253  * @see #getInstance
1254  * @see #unregister
1255  */
1256 void U_EXPORT2 Transliterator::registerInstance(Transliterator* adoptedPrototype) {
1257     Mutex lock(registryMutex());
1258     UErrorCode ec = U_ZERO_ERROR;
1259     if (HAVE_REGISTRY(ec)) {
1260         _registerInstance(adoptedPrototype);
1261     }
1262 }
1263 
1264 void Transliterator::_registerInstance(Transliterator* adoptedPrototype) {
1265     UErrorCode ec = U_ZERO_ERROR;
1266     registry-&gt;put(adoptedPrototype, TRUE, ec);
1267 }
1268 
1269 void U_EXPORT2 Transliterator::registerAlias(const UnicodeString&amp; aliasID,
1270                                              const UnicodeString&amp; realID) {
1271     Mutex lock(registryMutex());
1272     UErrorCode ec = U_ZERO_ERROR;
1273     if (HAVE_REGISTRY(ec)) {
1274         _registerAlias(aliasID, realID);
1275     }
1276 }
1277 
1278 void Transliterator::_registerAlias(const UnicodeString&amp; aliasID,
1279                                     const UnicodeString&amp; realID) {
1280     UErrorCode ec = U_ZERO_ERROR;
1281     registry-&gt;put(aliasID, realID, FALSE, TRUE, ec);
1282 }
1283 
1284 /**
1285  * Unregisters a transliterator or class.  This may be either
1286  * a system transliterator or a user transliterator or class.
1287  *
1288  * @param ID the ID of the transliterator or class
1289  * @see #registerInstance
1290 
1291  */
1292 void U_EXPORT2 Transliterator::unregister(const UnicodeString&amp; ID) {
1293     Mutex lock(registryMutex());
1294     UErrorCode ec = U_ZERO_ERROR;
1295     if (HAVE_REGISTRY(ec)) {
1296         registry-&gt;remove(ID);
1297     }
1298 }
1299 
1300 /**
1301  * == OBSOLETE - remove in ICU 3.4 ==
1302  * Return the number of IDs currently registered with the system.
1303  * To retrieve the actual IDs, call getAvailableID(i) with
1304  * i from 0 to countAvailableIDs() - 1.
1305  */
1306 int32_t U_EXPORT2 Transliterator::countAvailableIDs(void) {
1307     int32_t retVal = 0;
1308     Mutex lock(registryMutex());
1309     UErrorCode ec = U_ZERO_ERROR;
1310     if (HAVE_REGISTRY(ec)) {
1311         retVal = registry-&gt;countAvailableIDs();
1312     }
1313     return retVal;
1314 }
1315 
1316 /**
1317  * == OBSOLETE - remove in ICU 3.4 ==
1318  * Return the index-th available ID.  index must be between 0
1319  * and countAvailableIDs() - 1, inclusive.  If index is out of
1320  * range, the result of getAvailableID(0) is returned.
1321  */
1322 const UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableID(int32_t index) {
1323     const UnicodeString* result = NULL;
1324     umtx_lock(registryMutex());
1325     UErrorCode ec = U_ZERO_ERROR;
1326     if (HAVE_REGISTRY(ec)) {
1327         result = &amp;registry-&gt;getAvailableID(index);
1328     }
1329     umtx_unlock(registryMutex());
1330     U_ASSERT(result != NULL); // fail if no registry
1331     return *result;
1332 }
1333 
1334 StringEnumeration* U_EXPORT2 Transliterator::getAvailableIDs(UErrorCode&amp; ec) {
1335     if (U_FAILURE(ec)) return NULL;
1336     StringEnumeration* result = NULL;
1337     umtx_lock(registryMutex());
1338     if (HAVE_REGISTRY(ec)) {
1339         result = registry-&gt;getAvailableIDs();
1340     }
1341     umtx_unlock(registryMutex());
1342     if (result == NULL) {
1343         ec = U_INTERNAL_TRANSLITERATOR_ERROR;
1344     }
1345     return result;
1346 }
1347 
1348 int32_t U_EXPORT2 Transliterator::countAvailableSources(void) {
1349     Mutex lock(registryMutex());
1350     UErrorCode ec = U_ZERO_ERROR;
1351     return HAVE_REGISTRY(ec) ? _countAvailableSources() : 0;
1352 }
1353 
1354 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableSource(int32_t index,
1355                                                   UnicodeString&amp; result) {
1356     Mutex lock(registryMutex());
1357     UErrorCode ec = U_ZERO_ERROR;
1358     if (HAVE_REGISTRY(ec)) {
1359         _getAvailableSource(index, result);
1360     }
1361     return result;
1362 }
1363 
1364 int32_t U_EXPORT2 Transliterator::countAvailableTargets(const UnicodeString&amp; source) {
1365     Mutex lock(registryMutex());
1366     UErrorCode ec = U_ZERO_ERROR;
1367     return HAVE_REGISTRY(ec) ? _countAvailableTargets(source) : 0;
1368 }
1369 
1370 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableTarget(int32_t index,
1371                                                   const UnicodeString&amp; source,
1372                                                   UnicodeString&amp; result) {
1373     Mutex lock(registryMutex());
1374     UErrorCode ec = U_ZERO_ERROR;
1375     if (HAVE_REGISTRY(ec)) {
1376         _getAvailableTarget(index, source, result);
1377     }
1378     return result;
1379 }
1380 
1381 int32_t U_EXPORT2 Transliterator::countAvailableVariants(const UnicodeString&amp; source,
1382                                                const UnicodeString&amp; target) {
1383     Mutex lock(registryMutex());
1384     UErrorCode ec = U_ZERO_ERROR;
1385     return HAVE_REGISTRY(ec) ? _countAvailableVariants(source, target) : 0;
1386 }
1387 
1388 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableVariant(int32_t index,
1389                                                    const UnicodeString&amp; source,
1390                                                    const UnicodeString&amp; target,
1391                                                    UnicodeString&amp; result) {
1392     Mutex lock(registryMutex());
1393     UErrorCode ec = U_ZERO_ERROR;
1394     if (HAVE_REGISTRY(ec)) {
1395         _getAvailableVariant(index, source, target, result);
1396     }
1397     return result;
1398 }
1399 
1400 int32_t Transliterator::_countAvailableSources(void) {
1401     return registry-&gt;countAvailableSources();
1402 }
1403 
1404 UnicodeString&amp; Transliterator::_getAvailableSource(int32_t index,
1405                                                   UnicodeString&amp; result) {
1406     return registry-&gt;getAvailableSource(index, result);
1407 }
1408 
1409 int32_t Transliterator::_countAvailableTargets(const UnicodeString&amp; source) {
1410     return registry-&gt;countAvailableTargets(source);
1411 }
1412 
1413 UnicodeString&amp; Transliterator::_getAvailableTarget(int32_t index,
1414                                                   const UnicodeString&amp; source,
1415                                                   UnicodeString&amp; result) {
1416     return registry-&gt;getAvailableTarget(index, source, result);
1417 }
1418 
1419 int32_t Transliterator::_countAvailableVariants(const UnicodeString&amp; source,
1420                                                const UnicodeString&amp; target) {
1421     return registry-&gt;countAvailableVariants(source, target);
1422 }
1423 
1424 UnicodeString&amp; Transliterator::_getAvailableVariant(int32_t index,
1425                                                    const UnicodeString&amp; source,
1426                                                    const UnicodeString&amp; target,
1427                                                    UnicodeString&amp; result) {
1428     return registry-&gt;getAvailableVariant(index, source, target, result);
1429 }
1430 
1431 #ifdef U_USE_DEPRECATED_TRANSLITERATOR_API
1432 
1433 /**
1434  * Method for subclasses to use to obtain a character in the given
1435  * string, with filtering.
1436  * @deprecated the new architecture provides filtering at the top
1437  * level.  This method will be removed Dec 31 2001.
1438  */
1439 UChar Transliterator::filteredCharAt(const Replaceable&amp; text, int32_t i) const {
1440     UChar c;
1441     const UnicodeFilter* localFilter = getFilter();
1442     return (localFilter == 0) ? text.charAt(i) :
1443         (localFilter-&gt;contains(c = text.charAt(i)) ? c : (UChar)0xFFFE);
1444 }
1445 
1446 #endif
1447 
1448 /**
1449  * If the registry is initialized, return TRUE.  If not, initialize it
1450  * and return TRUE.  If the registry cannot be initialized, return
1451  * FALSE (rare).
1452  *
1453  * IMPORTANT: Upon entry, registryMutex must be LOCKED.  The entire
1454  * initialization is done with the lock held.  There is NO REASON to
1455  * unlock, since no other thread that is waiting on the registryMutex
1456  * cannot itself proceed until the registry is initialized.
1457  */
1458 UBool Transliterator::initializeRegistry(UErrorCode &amp;status) {
1459     if (registry != 0) {
1460         return TRUE;
1461     }
1462 
1463     registry = new TransliteratorRegistry(status);
1464     if (registry == 0 || U_FAILURE(status)) {
1465         delete registry;
1466         registry = 0;
1467         return FALSE; // can&#39;t create registry, no recovery
1468     }
1469 
1470     /* The following code parses the index table located in
1471      * icu/data/translit/root.txt.  The index is an n x 4 table
1472      * that follows this format:
1473      *  &lt;id&gt;{
1474      *      file{
1475      *          resource{&quot;&lt;resource&gt;&quot;}
1476      *          direction{&quot;&lt;direction&gt;&quot;}
1477      *      }
1478      *  }
1479      *  &lt;id&gt;{
1480      *      internal{
1481      *          resource{&quot;&lt;resource&gt;&quot;}
1482      *          direction{&quot;&lt;direction&quot;}
1483      *       }
1484      *  }
1485      *  &lt;id&gt;{
1486      *      alias{&quot;&lt;getInstanceArg&quot;}
1487      *  }
1488      * &lt;id&gt; is the ID of the system transliterator being defined.  These
1489      * are public IDs enumerated by Transliterator.getAvailableIDs(),
1490      * unless the second field is &quot;internal&quot;.
1491      *
1492      * &lt;resource&gt; is a ResourceReader resource name.  Currently these refer
1493      * to file names under com/ibm/text/resources.  This string is passed
1494      * directly to ResourceReader, together with &lt;encoding&gt;.
1495      *
1496      * &lt;direction&gt; is either &quot;FORWARD&quot; or &quot;REVERSE&quot;.
1497      *
1498      * &lt;getInstanceArg&gt; is a string to be passed directly to
1499      * Transliterator.getInstance().  The returned Transliterator object
1500      * then has its ID changed to &lt;id&gt; and is returned.
1501      *
1502      * The extra blank field on &quot;alias&quot; lines is to make the array square.
1503      */
1504     //static const char translit_index[] = &quot;translit_index&quot;;
1505 
1506     UResourceBundle *bundle, *transIDs, *colBund;
1507     bundle = ures_open(U_ICUDATA_TRANSLIT, NULL/*open default locale*/, &amp;status);
1508     transIDs = ures_getByKey(bundle, RB_RULE_BASED_IDS, 0, &amp;status);
1509     const UnicodeString T_PART = UNICODE_STRING_SIMPLE(&quot;-t-&quot;);
1510 
1511     int32_t row, maxRows;
1512     if (U_SUCCESS(status)) {
1513         maxRows = ures_getSize(transIDs);
1514         for (row = 0; row &lt; maxRows; row++) {
1515             colBund = ures_getByIndex(transIDs, row, 0, &amp;status);
1516             if (U_SUCCESS(status)) {
1517                 UnicodeString id(ures_getKey(colBund), -1, US_INV);
1518                 if(id.indexOf(T_PART) != -1) {
1519                     ures_close(colBund);
1520                     continue;
1521                 }
1522                 UResourceBundle* res = ures_getNextResource(colBund, NULL, &amp;status);
1523                 const char* typeStr = ures_getKey(res);
1524                 UChar type;
1525                 u_charsToUChars(typeStr, &amp;type, 1);
1526 
1527                 if (U_SUCCESS(status)) {
1528                     int32_t len = 0;
1529                     const UChar *resString;
1530                     switch (type) {
1531                     case 0x66: // &#39;f&#39;
1532                     case 0x69: // &#39;i&#39;
1533                         // &#39;file&#39; or &#39;internal&#39;;
1534                         // row[2]=resource, row[3]=direction
1535                         {
1536 
1537                             resString = ures_getStringByKey(res, &quot;resource&quot;, &amp;len, &amp;status);
1538                             UBool visible = (type == 0x0066 /*f*/);
1539                             UTransDirection dir =
1540                                 (ures_getUnicodeStringByKey(res, &quot;direction&quot;, &amp;status).charAt(0) ==
1541                                  0x0046 /*F*/) ?
1542                                 UTRANS_FORWARD : UTRANS_REVERSE;
1543                             registry-&gt;put(id, UnicodeString(TRUE, resString, len), dir, TRUE, visible, status);
1544                         }
1545                         break;
1546                     case 0x61: // &#39;a&#39;
1547                         // &#39;alias&#39;; row[2]=createInstance argument
1548                         resString = ures_getString(res, &amp;len, &amp;status);
1549                         registry-&gt;put(id, UnicodeString(TRUE, resString, len), TRUE, TRUE, status);
1550                         break;
1551                     }
1552                 }
1553                 ures_close(res);
1554             }
1555             ures_close(colBund);
1556         }
1557     }
1558 
1559     ures_close(transIDs);
1560     ures_close(bundle);
1561 
1562     // Manually add prototypes that the system knows about to the
1563     // cache.  This is how new non-rule-based transliterators are
1564     // added to the system.
1565 
1566     // This is to allow for null pointer check
1567     NullTransliterator* tempNullTranslit = new NullTransliterator();
1568     LowercaseTransliterator* tempLowercaseTranslit = new LowercaseTransliterator();
1569     UppercaseTransliterator* tempUppercaseTranslit = new UppercaseTransliterator();
1570     TitlecaseTransliterator* tempTitlecaseTranslit = new TitlecaseTransliterator();
1571     UnicodeNameTransliterator* tempUnicodeTranslit = new UnicodeNameTransliterator();
1572     NameUnicodeTransliterator* tempNameUnicodeTranslit = new NameUnicodeTransliterator();
1573 #if !UCONFIG_NO_BREAK_ITERATION
1574      // TODO: could or should these transliterators be referenced polymorphically once constructed?
1575      BreakTransliterator* tempBreakTranslit         = new BreakTransliterator();
1576 #endif
1577     // Check for null pointers
1578     if (tempNullTranslit == NULL || tempLowercaseTranslit == NULL || tempUppercaseTranslit == NULL ||
1579         tempTitlecaseTranslit == NULL || tempUnicodeTranslit == NULL ||
1580 #if !UCONFIG_NO_BREAK_ITERATION
1581         tempBreakTranslit == NULL ||
1582 #endif
1583         tempNameUnicodeTranslit == NULL )
1584     {
1585         delete tempNullTranslit;
1586         delete tempLowercaseTranslit;
1587         delete tempUppercaseTranslit;
1588         delete tempTitlecaseTranslit;
1589         delete tempUnicodeTranslit;
1590         delete tempNameUnicodeTranslit;
1591 #if !UCONFIG_NO_BREAK_ITERATION
1592         delete tempBreakTranslit;
1593 #endif
1594         // Since there was an error, remove registry
1595         delete registry;
1596         registry = NULL;
1597 
1598         status = U_MEMORY_ALLOCATION_ERROR;
1599         return 0;
1600     }
1601 
1602     registry-&gt;put(tempNullTranslit, TRUE, status);
1603     registry-&gt;put(tempLowercaseTranslit, TRUE, status);
1604     registry-&gt;put(tempUppercaseTranslit, TRUE, status);
1605     registry-&gt;put(tempTitlecaseTranslit, TRUE, status);
1606     registry-&gt;put(tempUnicodeTranslit, TRUE, status);
1607     registry-&gt;put(tempNameUnicodeTranslit, TRUE, status);
1608 #if !UCONFIG_NO_BREAK_ITERATION
1609     registry-&gt;put(tempBreakTranslit, FALSE, status);   // FALSE means invisible.
1610 #endif
1611 
1612     RemoveTransliterator::registerIDs(); // Must be within mutex
1613     EscapeTransliterator::registerIDs();
1614     UnescapeTransliterator::registerIDs();
1615     NormalizationTransliterator::registerIDs();
1616     AnyTransliterator::registerIDs();
1617 
1618     _registerSpecialInverse(UNICODE_STRING_SIMPLE(&quot;Null&quot;),
1619                             UNICODE_STRING_SIMPLE(&quot;Null&quot;), FALSE);
1620     _registerSpecialInverse(UNICODE_STRING_SIMPLE(&quot;Upper&quot;),
1621                             UNICODE_STRING_SIMPLE(&quot;Lower&quot;), TRUE);
1622     _registerSpecialInverse(UNICODE_STRING_SIMPLE(&quot;Title&quot;),
1623                             UNICODE_STRING_SIMPLE(&quot;Lower&quot;), FALSE);
1624 
1625     ucln_i18n_registerCleanup(UCLN_I18N_TRANSLITERATOR, utrans_transliterator_cleanup);
1626 
1627     return TRUE;
1628 }
1629 
1630 U_NAMESPACE_END
1631 
1632 // Defined in transreg.h:
1633 
1634 /**
1635  * Release all static memory held by transliterator.  This will
1636  * necessarily invalidate any rule-based transliterators held by the
1637  * user, because RBTs hold pointers to common data objects.
1638  */
1639 U_CFUNC UBool utrans_transliterator_cleanup(void) {
1640     U_NAMESPACE_USE
1641     TransliteratorIDParser::cleanup();
1642     if (registry) {
1643         delete registry;
1644         registry = NULL;
1645     }
1646     return TRUE;
1647 }
1648 
1649 #endif /* #if !UCONFIG_NO_TRANSLITERATION */
1650 
1651 //eof
    </pre>
  </body>
</html>