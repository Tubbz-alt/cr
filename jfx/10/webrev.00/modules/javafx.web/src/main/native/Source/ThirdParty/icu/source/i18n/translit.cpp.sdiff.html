<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/translit.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="tmutfmt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="transreg.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/translit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  74 
  75 /**
  76  * Resource bundle key for display name pattern.
  77  * The resource bundle value should be a String forming a
  78  * MessageFormat pattern, e.g.:
  79  * &quot;{0,choice,0#|1#{1} Transliterator|2#{1} to {2} Transliterator}&quot;.
  80  */
  81 static const char RB_DISPLAY_NAME_PATTERN[] = &quot;TransliteratorNamePattern&quot;;
  82 
  83 /**
  84  * Resource bundle key for the list of RuleBasedTransliterator IDs.
  85  * The resource bundle value should be a String[] with each element
  86  * being a valid ID.  The ID will be appended to RB_RULE_BASED_PREFIX
  87  * to obtain the class name in which the RB_RULE key will be sought.
  88  */
  89 static const char RB_RULE_BASED_IDS[] = &quot;RuleBasedTransliteratorIDs&quot;;
  90 
  91 /**
  92  * The mutex controlling access to registry object.
  93  */
<span class="line-modified">  94 static UMutex registryMutex = U_MUTEX_INITIALIZER;</span>



  95 
  96 /**
  97  * System transliterator registry; non-null when initialized.
  98  */
  99 static icu::TransliteratorRegistry* registry = 0;
 100 
 101 // Macro to check/initialize the registry. ONLY USE WITHIN
 102 // MUTEX. Avoids function call when registry is initialized.
 103 #define HAVE_REGISTRY(status) (registry!=0 || initializeRegistry(status))
 104 
 105 U_NAMESPACE_BEGIN
 106 
 107 UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(Transliterator)
 108 
 109 /**
 110  * Return TRUE if the given UTransPosition is valid for text of
 111  * the given length.
 112  */
 113 static inline UBool positionIsValid(UTransPosition&amp; index, int32_t len) {
 114     return !(index.contextStart &lt; 0 ||
</pre>
<hr />
<pre>
 961         status = U_MEMORY_ALLOCATION_ERROR;
 962     }
 963     return t;
 964 }
 965 
 966 /**
 967  * Create a transliterator from a basic ID.  This is an ID
 968  * containing only the forward direction source, target, and
 969  * variant.
 970  * @param id a basic ID of the form S-T or S-T/V.
 971  * @return a newly created Transliterator or null if the ID is
 972  * invalid.
 973  */
 974 Transliterator* Transliterator::createBasicInstance(const UnicodeString&amp; id,
 975                                                     const UnicodeString* canon) {
 976     UParseError pe;
 977     UErrorCode ec = U_ZERO_ERROR;
 978     TransliteratorAlias* alias = 0;
 979     Transliterator* t = 0;
 980 
<span class="line-modified"> 981     umtx_lock(&amp;registryMutex);</span>
 982     if (HAVE_REGISTRY(ec)) {
 983         t = registry-&gt;get(id, alias, ec);
 984     }
<span class="line-modified"> 985     umtx_unlock(&amp;registryMutex);</span>
 986 
 987     if (U_FAILURE(ec)) {
 988         delete t;
 989         delete alias;
 990         return 0;
 991     }
 992 
 993     // We may have not gotten a transliterator:  Because we can&#39;t
 994     // instantiate a transliterator from inside TransliteratorRegistry::
 995     // get() (that would deadlock), we sometimes pass back an alias.  This
 996     // contains the data we need to finish the instantiation outside the
 997     // registry mutex.  The alias may, in turn, generate another alias, so
 998     // we handle aliases in a loop.  The max times through the loop is two.
 999     // [alan]
1000     while (alias != 0) {
1001         U_ASSERT(t==0);
1002         // Rule-based aliases are handled with TransliteratorAlias::
1003         // parse(), followed by TransliteratorRegistry::reget().
1004         // Other aliases are handled with TransliteratorAlias::create().
1005         if (alias-&gt;isRuleBased()) {
1006             // Step 1. parse
1007             TransliteratorParser parser(ec);
1008             alias-&gt;parse(parser, pe, ec);
1009             delete alias;
1010             alias = 0;
1011 
1012             // Step 2. reget
<span class="line-modified">1013             umtx_lock(&amp;registryMutex);</span>
1014             if (HAVE_REGISTRY(ec)) {
1015                 t = registry-&gt;reget(id, parser, alias, ec);
1016             }
<span class="line-modified">1017             umtx_unlock(&amp;registryMutex);</span>
1018 
1019             // Step 3. Loop back around!
1020         } else {
1021             t = alias-&gt;create(pe, ec);
1022             delete alias;
1023             alias = 0;
1024             break;
1025         }
1026         if (U_FAILURE(ec)) {
1027             delete t;
1028             delete alias;
1029             t = NULL;
1030             break;
1031         }
1032     }
1033 
1034     if (t != NULL &amp;&amp; canon != NULL) {
1035         t-&gt;setID(*canon);
1036     }
1037 
</pre>
<hr />
<pre>
1195         result.retainAll(*filterSet);
1196         if (deleteFilterSet) {
1197             delete filterSet;
1198         }
1199     }
1200     return result;
1201 }
1202 
1203 void Transliterator::handleGetSourceSet(UnicodeSet&amp; result) const {
1204     result.clear();
1205 }
1206 
1207 UnicodeSet&amp; Transliterator::getTargetSet(UnicodeSet&amp; result) const {
1208     return result.clear();
1209 }
1210 
1211 // For public consumption
1212 void U_EXPORT2 Transliterator::registerFactory(const UnicodeString&amp; id,
1213                                      Transliterator::Factory factory,
1214                                      Transliterator::Token context) {
<span class="line-modified">1215     Mutex lock(&amp;registryMutex);</span>
1216     UErrorCode ec = U_ZERO_ERROR;
1217     if (HAVE_REGISTRY(ec)) {
1218         _registerFactory(id, factory, context);
1219     }
1220 }
1221 
1222 // To be called only by Transliterator subclasses that are called
1223 // to register themselves by initializeRegistry().
1224 void Transliterator::_registerFactory(const UnicodeString&amp; id,
1225                                       Transliterator::Factory factory,
1226                                       Transliterator::Token context) {
1227     UErrorCode ec = U_ZERO_ERROR;
1228     registry-&gt;put(id, factory, context, TRUE, ec);
1229 }
1230 
1231 // To be called only by Transliterator subclasses that are called
1232 // to register themselves by initializeRegistry().
1233 void Transliterator::_registerSpecialInverse(const UnicodeString&amp; target,
1234                                              const UnicodeString&amp; inverseTarget,
1235                                              UBool bidirectional) {
1236     UErrorCode status = U_ZERO_ERROR;
1237     TransliteratorIDParser::registerSpecialInverse(target, inverseTarget, bidirectional, status);
1238 }
1239 
1240 /**
1241  * Registers a instance &lt;tt&gt;obj&lt;/tt&gt; of a subclass of
1242  * &lt;code&gt;Transliterator&lt;/code&gt; with the system.  This object must
1243  * implement the &lt;tt&gt;clone()&lt;/tt&gt; method.  When
1244  * &lt;tt&gt;getInstance()&lt;/tt&gt; is called with an ID string that is
1245  * equal to &lt;tt&gt;obj.getID()&lt;/tt&gt;, then &lt;tt&gt;obj.clone()&lt;/tt&gt; is
1246  * returned.
1247  *
1248  * @param obj an instance of subclass of
1249  * &lt;code&gt;Transliterator&lt;/code&gt; that defines &lt;tt&gt;clone()&lt;/tt&gt;
1250  * @see #getInstance
1251  * @see #unregister
1252  */
1253 void U_EXPORT2 Transliterator::registerInstance(Transliterator* adoptedPrototype) {
<span class="line-modified">1254     Mutex lock(&amp;registryMutex);</span>
1255     UErrorCode ec = U_ZERO_ERROR;
1256     if (HAVE_REGISTRY(ec)) {
1257         _registerInstance(adoptedPrototype);
1258     }
1259 }
1260 
1261 void Transliterator::_registerInstance(Transliterator* adoptedPrototype) {
1262     UErrorCode ec = U_ZERO_ERROR;
1263     registry-&gt;put(adoptedPrototype, TRUE, ec);
1264 }
1265 
1266 void U_EXPORT2 Transliterator::registerAlias(const UnicodeString&amp; aliasID,
1267                                              const UnicodeString&amp; realID) {
<span class="line-modified">1268     Mutex lock(&amp;registryMutex);</span>
1269     UErrorCode ec = U_ZERO_ERROR;
1270     if (HAVE_REGISTRY(ec)) {
1271         _registerAlias(aliasID, realID);
1272     }
1273 }
1274 
1275 void Transliterator::_registerAlias(const UnicodeString&amp; aliasID,
1276                                     const UnicodeString&amp; realID) {
1277     UErrorCode ec = U_ZERO_ERROR;
1278     registry-&gt;put(aliasID, realID, FALSE, TRUE, ec);
1279 }
1280 
1281 /**
1282  * Unregisters a transliterator or class.  This may be either
1283  * a system transliterator or a user transliterator or class.
1284  *
1285  * @param ID the ID of the transliterator or class
1286  * @see #registerInstance
1287 
1288  */
1289 void U_EXPORT2 Transliterator::unregister(const UnicodeString&amp; ID) {
<span class="line-modified">1290     Mutex lock(&amp;registryMutex);</span>
1291     UErrorCode ec = U_ZERO_ERROR;
1292     if (HAVE_REGISTRY(ec)) {
1293         registry-&gt;remove(ID);
1294     }
1295 }
1296 
1297 /**
1298  * == OBSOLETE - remove in ICU 3.4 ==
1299  * Return the number of IDs currently registered with the system.
1300  * To retrieve the actual IDs, call getAvailableID(i) with
1301  * i from 0 to countAvailableIDs() - 1.
1302  */
1303 int32_t U_EXPORT2 Transliterator::countAvailableIDs(void) {
1304     int32_t retVal = 0;
<span class="line-modified">1305     Mutex lock(&amp;registryMutex);</span>
1306     UErrorCode ec = U_ZERO_ERROR;
1307     if (HAVE_REGISTRY(ec)) {
1308         retVal = registry-&gt;countAvailableIDs();
1309     }
1310     return retVal;
1311 }
1312 
1313 /**
1314  * == OBSOLETE - remove in ICU 3.4 ==
1315  * Return the index-th available ID.  index must be between 0
1316  * and countAvailableIDs() - 1, inclusive.  If index is out of
1317  * range, the result of getAvailableID(0) is returned.
1318  */
1319 const UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableID(int32_t index) {
1320     const UnicodeString* result = NULL;
<span class="line-modified">1321     umtx_lock(&amp;registryMutex);</span>
1322     UErrorCode ec = U_ZERO_ERROR;
1323     if (HAVE_REGISTRY(ec)) {
1324         result = &amp;registry-&gt;getAvailableID(index);
1325     }
<span class="line-modified">1326     umtx_unlock(&amp;registryMutex);</span>
1327     U_ASSERT(result != NULL); // fail if no registry
1328     return *result;
1329 }
1330 
1331 StringEnumeration* U_EXPORT2 Transliterator::getAvailableIDs(UErrorCode&amp; ec) {
1332     if (U_FAILURE(ec)) return NULL;
1333     StringEnumeration* result = NULL;
<span class="line-modified">1334     umtx_lock(&amp;registryMutex);</span>
1335     if (HAVE_REGISTRY(ec)) {
1336         result = registry-&gt;getAvailableIDs();
1337     }
<span class="line-modified">1338     umtx_unlock(&amp;registryMutex);</span>
1339     if (result == NULL) {
1340         ec = U_INTERNAL_TRANSLITERATOR_ERROR;
1341     }
1342     return result;
1343 }
1344 
1345 int32_t U_EXPORT2 Transliterator::countAvailableSources(void) {
<span class="line-modified">1346     Mutex lock(&amp;registryMutex);</span>
1347     UErrorCode ec = U_ZERO_ERROR;
1348     return HAVE_REGISTRY(ec) ? _countAvailableSources() : 0;
1349 }
1350 
1351 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableSource(int32_t index,
1352                                                   UnicodeString&amp; result) {
<span class="line-modified">1353     Mutex lock(&amp;registryMutex);</span>
1354     UErrorCode ec = U_ZERO_ERROR;
1355     if (HAVE_REGISTRY(ec)) {
1356         _getAvailableSource(index, result);
1357     }
1358     return result;
1359 }
1360 
1361 int32_t U_EXPORT2 Transliterator::countAvailableTargets(const UnicodeString&amp; source) {
<span class="line-modified">1362     Mutex lock(&amp;registryMutex);</span>
1363     UErrorCode ec = U_ZERO_ERROR;
1364     return HAVE_REGISTRY(ec) ? _countAvailableTargets(source) : 0;
1365 }
1366 
1367 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableTarget(int32_t index,
1368                                                   const UnicodeString&amp; source,
1369                                                   UnicodeString&amp; result) {
<span class="line-modified">1370     Mutex lock(&amp;registryMutex);</span>
1371     UErrorCode ec = U_ZERO_ERROR;
1372     if (HAVE_REGISTRY(ec)) {
1373         _getAvailableTarget(index, source, result);
1374     }
1375     return result;
1376 }
1377 
1378 int32_t U_EXPORT2 Transliterator::countAvailableVariants(const UnicodeString&amp; source,
1379                                                const UnicodeString&amp; target) {
<span class="line-modified">1380     Mutex lock(&amp;registryMutex);</span>
1381     UErrorCode ec = U_ZERO_ERROR;
1382     return HAVE_REGISTRY(ec) ? _countAvailableVariants(source, target) : 0;
1383 }
1384 
1385 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableVariant(int32_t index,
1386                                                    const UnicodeString&amp; source,
1387                                                    const UnicodeString&amp; target,
1388                                                    UnicodeString&amp; result) {
<span class="line-modified">1389     Mutex lock(&amp;registryMutex);</span>
1390     UErrorCode ec = U_ZERO_ERROR;
1391     if (HAVE_REGISTRY(ec)) {
1392         _getAvailableVariant(index, source, target, result);
1393     }
1394     return result;
1395 }
1396 
1397 int32_t Transliterator::_countAvailableSources(void) {
1398     return registry-&gt;countAvailableSources();
1399 }
1400 
1401 UnicodeString&amp; Transliterator::_getAvailableSource(int32_t index,
1402                                                   UnicodeString&amp; result) {
1403     return registry-&gt;getAvailableSource(index, result);
1404 }
1405 
1406 int32_t Transliterator::_countAvailableTargets(const UnicodeString&amp; source) {
1407     return registry-&gt;countAvailableTargets(source);
1408 }
1409 
</pre>
</td>
<td>
<hr />
<pre>
  74 
  75 /**
  76  * Resource bundle key for display name pattern.
  77  * The resource bundle value should be a String forming a
  78  * MessageFormat pattern, e.g.:
  79  * &quot;{0,choice,0#|1#{1} Transliterator|2#{1} to {2} Transliterator}&quot;.
  80  */
  81 static const char RB_DISPLAY_NAME_PATTERN[] = &quot;TransliteratorNamePattern&quot;;
  82 
  83 /**
  84  * Resource bundle key for the list of RuleBasedTransliterator IDs.
  85  * The resource bundle value should be a String[] with each element
  86  * being a valid ID.  The ID will be appended to RB_RULE_BASED_PREFIX
  87  * to obtain the class name in which the RB_RULE key will be sought.
  88  */
  89 static const char RB_RULE_BASED_IDS[] = &quot;RuleBasedTransliteratorIDs&quot;;
  90 
  91 /**
  92  * The mutex controlling access to registry object.
  93  */
<span class="line-modified">  94 static icu::UMutex *registryMutex() {</span>
<span class="line-added">  95     static icu::UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added">  96     return &amp;m;</span>
<span class="line-added">  97 }</span>
  98 
  99 /**
 100  * System transliterator registry; non-null when initialized.
 101  */
 102 static icu::TransliteratorRegistry* registry = 0;
 103 
 104 // Macro to check/initialize the registry. ONLY USE WITHIN
 105 // MUTEX. Avoids function call when registry is initialized.
 106 #define HAVE_REGISTRY(status) (registry!=0 || initializeRegistry(status))
 107 
 108 U_NAMESPACE_BEGIN
 109 
 110 UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(Transliterator)
 111 
 112 /**
 113  * Return TRUE if the given UTransPosition is valid for text of
 114  * the given length.
 115  */
 116 static inline UBool positionIsValid(UTransPosition&amp; index, int32_t len) {
 117     return !(index.contextStart &lt; 0 ||
</pre>
<hr />
<pre>
 964         status = U_MEMORY_ALLOCATION_ERROR;
 965     }
 966     return t;
 967 }
 968 
 969 /**
 970  * Create a transliterator from a basic ID.  This is an ID
 971  * containing only the forward direction source, target, and
 972  * variant.
 973  * @param id a basic ID of the form S-T or S-T/V.
 974  * @return a newly created Transliterator or null if the ID is
 975  * invalid.
 976  */
 977 Transliterator* Transliterator::createBasicInstance(const UnicodeString&amp; id,
 978                                                     const UnicodeString* canon) {
 979     UParseError pe;
 980     UErrorCode ec = U_ZERO_ERROR;
 981     TransliteratorAlias* alias = 0;
 982     Transliterator* t = 0;
 983 
<span class="line-modified"> 984     umtx_lock(registryMutex());</span>
 985     if (HAVE_REGISTRY(ec)) {
 986         t = registry-&gt;get(id, alias, ec);
 987     }
<span class="line-modified"> 988     umtx_unlock(registryMutex());</span>
 989 
 990     if (U_FAILURE(ec)) {
 991         delete t;
 992         delete alias;
 993         return 0;
 994     }
 995 
 996     // We may have not gotten a transliterator:  Because we can&#39;t
 997     // instantiate a transliterator from inside TransliteratorRegistry::
 998     // get() (that would deadlock), we sometimes pass back an alias.  This
 999     // contains the data we need to finish the instantiation outside the
1000     // registry mutex.  The alias may, in turn, generate another alias, so
1001     // we handle aliases in a loop.  The max times through the loop is two.
1002     // [alan]
1003     while (alias != 0) {
1004         U_ASSERT(t==0);
1005         // Rule-based aliases are handled with TransliteratorAlias::
1006         // parse(), followed by TransliteratorRegistry::reget().
1007         // Other aliases are handled with TransliteratorAlias::create().
1008         if (alias-&gt;isRuleBased()) {
1009             // Step 1. parse
1010             TransliteratorParser parser(ec);
1011             alias-&gt;parse(parser, pe, ec);
1012             delete alias;
1013             alias = 0;
1014 
1015             // Step 2. reget
<span class="line-modified">1016             umtx_lock(registryMutex());</span>
1017             if (HAVE_REGISTRY(ec)) {
1018                 t = registry-&gt;reget(id, parser, alias, ec);
1019             }
<span class="line-modified">1020             umtx_unlock(registryMutex());</span>
1021 
1022             // Step 3. Loop back around!
1023         } else {
1024             t = alias-&gt;create(pe, ec);
1025             delete alias;
1026             alias = 0;
1027             break;
1028         }
1029         if (U_FAILURE(ec)) {
1030             delete t;
1031             delete alias;
1032             t = NULL;
1033             break;
1034         }
1035     }
1036 
1037     if (t != NULL &amp;&amp; canon != NULL) {
1038         t-&gt;setID(*canon);
1039     }
1040 
</pre>
<hr />
<pre>
1198         result.retainAll(*filterSet);
1199         if (deleteFilterSet) {
1200             delete filterSet;
1201         }
1202     }
1203     return result;
1204 }
1205 
1206 void Transliterator::handleGetSourceSet(UnicodeSet&amp; result) const {
1207     result.clear();
1208 }
1209 
1210 UnicodeSet&amp; Transliterator::getTargetSet(UnicodeSet&amp; result) const {
1211     return result.clear();
1212 }
1213 
1214 // For public consumption
1215 void U_EXPORT2 Transliterator::registerFactory(const UnicodeString&amp; id,
1216                                      Transliterator::Factory factory,
1217                                      Transliterator::Token context) {
<span class="line-modified">1218     Mutex lock(registryMutex());</span>
1219     UErrorCode ec = U_ZERO_ERROR;
1220     if (HAVE_REGISTRY(ec)) {
1221         _registerFactory(id, factory, context);
1222     }
1223 }
1224 
1225 // To be called only by Transliterator subclasses that are called
1226 // to register themselves by initializeRegistry().
1227 void Transliterator::_registerFactory(const UnicodeString&amp; id,
1228                                       Transliterator::Factory factory,
1229                                       Transliterator::Token context) {
1230     UErrorCode ec = U_ZERO_ERROR;
1231     registry-&gt;put(id, factory, context, TRUE, ec);
1232 }
1233 
1234 // To be called only by Transliterator subclasses that are called
1235 // to register themselves by initializeRegistry().
1236 void Transliterator::_registerSpecialInverse(const UnicodeString&amp; target,
1237                                              const UnicodeString&amp; inverseTarget,
1238                                              UBool bidirectional) {
1239     UErrorCode status = U_ZERO_ERROR;
1240     TransliteratorIDParser::registerSpecialInverse(target, inverseTarget, bidirectional, status);
1241 }
1242 
1243 /**
1244  * Registers a instance &lt;tt&gt;obj&lt;/tt&gt; of a subclass of
1245  * &lt;code&gt;Transliterator&lt;/code&gt; with the system.  This object must
1246  * implement the &lt;tt&gt;clone()&lt;/tt&gt; method.  When
1247  * &lt;tt&gt;getInstance()&lt;/tt&gt; is called with an ID string that is
1248  * equal to &lt;tt&gt;obj.getID()&lt;/tt&gt;, then &lt;tt&gt;obj.clone()&lt;/tt&gt; is
1249  * returned.
1250  *
1251  * @param obj an instance of subclass of
1252  * &lt;code&gt;Transliterator&lt;/code&gt; that defines &lt;tt&gt;clone()&lt;/tt&gt;
1253  * @see #getInstance
1254  * @see #unregister
1255  */
1256 void U_EXPORT2 Transliterator::registerInstance(Transliterator* adoptedPrototype) {
<span class="line-modified">1257     Mutex lock(registryMutex());</span>
1258     UErrorCode ec = U_ZERO_ERROR;
1259     if (HAVE_REGISTRY(ec)) {
1260         _registerInstance(adoptedPrototype);
1261     }
1262 }
1263 
1264 void Transliterator::_registerInstance(Transliterator* adoptedPrototype) {
1265     UErrorCode ec = U_ZERO_ERROR;
1266     registry-&gt;put(adoptedPrototype, TRUE, ec);
1267 }
1268 
1269 void U_EXPORT2 Transliterator::registerAlias(const UnicodeString&amp; aliasID,
1270                                              const UnicodeString&amp; realID) {
<span class="line-modified">1271     Mutex lock(registryMutex());</span>
1272     UErrorCode ec = U_ZERO_ERROR;
1273     if (HAVE_REGISTRY(ec)) {
1274         _registerAlias(aliasID, realID);
1275     }
1276 }
1277 
1278 void Transliterator::_registerAlias(const UnicodeString&amp; aliasID,
1279                                     const UnicodeString&amp; realID) {
1280     UErrorCode ec = U_ZERO_ERROR;
1281     registry-&gt;put(aliasID, realID, FALSE, TRUE, ec);
1282 }
1283 
1284 /**
1285  * Unregisters a transliterator or class.  This may be either
1286  * a system transliterator or a user transliterator or class.
1287  *
1288  * @param ID the ID of the transliterator or class
1289  * @see #registerInstance
1290 
1291  */
1292 void U_EXPORT2 Transliterator::unregister(const UnicodeString&amp; ID) {
<span class="line-modified">1293     Mutex lock(registryMutex());</span>
1294     UErrorCode ec = U_ZERO_ERROR;
1295     if (HAVE_REGISTRY(ec)) {
1296         registry-&gt;remove(ID);
1297     }
1298 }
1299 
1300 /**
1301  * == OBSOLETE - remove in ICU 3.4 ==
1302  * Return the number of IDs currently registered with the system.
1303  * To retrieve the actual IDs, call getAvailableID(i) with
1304  * i from 0 to countAvailableIDs() - 1.
1305  */
1306 int32_t U_EXPORT2 Transliterator::countAvailableIDs(void) {
1307     int32_t retVal = 0;
<span class="line-modified">1308     Mutex lock(registryMutex());</span>
1309     UErrorCode ec = U_ZERO_ERROR;
1310     if (HAVE_REGISTRY(ec)) {
1311         retVal = registry-&gt;countAvailableIDs();
1312     }
1313     return retVal;
1314 }
1315 
1316 /**
1317  * == OBSOLETE - remove in ICU 3.4 ==
1318  * Return the index-th available ID.  index must be between 0
1319  * and countAvailableIDs() - 1, inclusive.  If index is out of
1320  * range, the result of getAvailableID(0) is returned.
1321  */
1322 const UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableID(int32_t index) {
1323     const UnicodeString* result = NULL;
<span class="line-modified">1324     umtx_lock(registryMutex());</span>
1325     UErrorCode ec = U_ZERO_ERROR;
1326     if (HAVE_REGISTRY(ec)) {
1327         result = &amp;registry-&gt;getAvailableID(index);
1328     }
<span class="line-modified">1329     umtx_unlock(registryMutex());</span>
1330     U_ASSERT(result != NULL); // fail if no registry
1331     return *result;
1332 }
1333 
1334 StringEnumeration* U_EXPORT2 Transliterator::getAvailableIDs(UErrorCode&amp; ec) {
1335     if (U_FAILURE(ec)) return NULL;
1336     StringEnumeration* result = NULL;
<span class="line-modified">1337     umtx_lock(registryMutex());</span>
1338     if (HAVE_REGISTRY(ec)) {
1339         result = registry-&gt;getAvailableIDs();
1340     }
<span class="line-modified">1341     umtx_unlock(registryMutex());</span>
1342     if (result == NULL) {
1343         ec = U_INTERNAL_TRANSLITERATOR_ERROR;
1344     }
1345     return result;
1346 }
1347 
1348 int32_t U_EXPORT2 Transliterator::countAvailableSources(void) {
<span class="line-modified">1349     Mutex lock(registryMutex());</span>
1350     UErrorCode ec = U_ZERO_ERROR;
1351     return HAVE_REGISTRY(ec) ? _countAvailableSources() : 0;
1352 }
1353 
1354 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableSource(int32_t index,
1355                                                   UnicodeString&amp; result) {
<span class="line-modified">1356     Mutex lock(registryMutex());</span>
1357     UErrorCode ec = U_ZERO_ERROR;
1358     if (HAVE_REGISTRY(ec)) {
1359         _getAvailableSource(index, result);
1360     }
1361     return result;
1362 }
1363 
1364 int32_t U_EXPORT2 Transliterator::countAvailableTargets(const UnicodeString&amp; source) {
<span class="line-modified">1365     Mutex lock(registryMutex());</span>
1366     UErrorCode ec = U_ZERO_ERROR;
1367     return HAVE_REGISTRY(ec) ? _countAvailableTargets(source) : 0;
1368 }
1369 
1370 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableTarget(int32_t index,
1371                                                   const UnicodeString&amp; source,
1372                                                   UnicodeString&amp; result) {
<span class="line-modified">1373     Mutex lock(registryMutex());</span>
1374     UErrorCode ec = U_ZERO_ERROR;
1375     if (HAVE_REGISTRY(ec)) {
1376         _getAvailableTarget(index, source, result);
1377     }
1378     return result;
1379 }
1380 
1381 int32_t U_EXPORT2 Transliterator::countAvailableVariants(const UnicodeString&amp; source,
1382                                                const UnicodeString&amp; target) {
<span class="line-modified">1383     Mutex lock(registryMutex());</span>
1384     UErrorCode ec = U_ZERO_ERROR;
1385     return HAVE_REGISTRY(ec) ? _countAvailableVariants(source, target) : 0;
1386 }
1387 
1388 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableVariant(int32_t index,
1389                                                    const UnicodeString&amp; source,
1390                                                    const UnicodeString&amp; target,
1391                                                    UnicodeString&amp; result) {
<span class="line-modified">1392     Mutex lock(registryMutex());</span>
1393     UErrorCode ec = U_ZERO_ERROR;
1394     if (HAVE_REGISTRY(ec)) {
1395         _getAvailableVariant(index, source, target, result);
1396     }
1397     return result;
1398 }
1399 
1400 int32_t Transliterator::_countAvailableSources(void) {
1401     return registry-&gt;countAvailableSources();
1402 }
1403 
1404 UnicodeString&amp; Transliterator::_getAvailableSource(int32_t index,
1405                                                   UnicodeString&amp; result) {
1406     return registry-&gt;getAvailableSource(index, result);
1407 }
1408 
1409 int32_t Transliterator::_countAvailableTargets(const UnicodeString&amp; source) {
1410     return registry-&gt;countAvailableTargets(source);
1411 }
1412 
</pre>
</td>
</tr>
</table>
<center><a href="tmutfmt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="transreg.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>