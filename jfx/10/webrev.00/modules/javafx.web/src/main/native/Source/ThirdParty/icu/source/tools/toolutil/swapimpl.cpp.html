<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/swapimpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 *
  6 *   Copyright (C) 2005-2014, International Business Machines
  7 *   Corporation and others.  All Rights Reserved.
  8 *
  9 *******************************************************************************
 10 *   file name:  swapimpl.cpp
 11 *   encoding:   UTF-8
 12 *   tab size:   8 (not used)
 13 *   indentation:4
 14 *
 15 *   created on: 2005may05
 16 *   created by: Markus W. Scherer
 17 *
 18 *   Data file swapping functions moved here from the common library
 19 *   because some data is hardcoded in ICU4C and needs not be swapped any more.
 20 *   Moving the functions here simplifies testing (for code coverage) because
 21 *   we need not jump through hoops (like adding snapshots of these files
 22 *   to testdata).
 23 *
 24 *   The declarations for these functions remain in the internal header files
 25 *   in icu/source/common/
 26 */
 27 
 28 #include &quot;unicode/utypes.h&quot;
 29 #include &quot;unicode/putil.h&quot;
 30 #include &quot;unicode/udata.h&quot;
 31 
 32 /* Explicit include statement for std_string.h is needed
 33  * for compilation on certain platforms. (e.g. AIX/VACPP)
 34  */
 35 #include &quot;unicode/std_string.h&quot;
 36 
 37 #include &quot;cmemory.h&quot;
 38 #include &quot;cstring.h&quot;
 39 #include &quot;uinvchar.h&quot;
 40 #include &quot;uassert.h&quot;
 41 #include &quot;uarrsort.h&quot;
 42 #include &quot;ucmndata.h&quot;
 43 #include &quot;udataswp.h&quot;
 44 #include &quot;ulayout_props.h&quot;
 45 
 46 /* swapping implementations in common */
 47 
 48 #include &quot;uresdata.h&quot;
 49 #include &quot;ucnv_io.h&quot;
 50 #include &quot;uprops.h&quot;
 51 #include &quot;ucase.h&quot;
 52 #include &quot;ubidi_props.h&quot;
 53 #include &quot;ucol_swp.h&quot;
 54 #include &quot;ucnv_bld.h&quot;
 55 #include &quot;unormimp.h&quot;
 56 #include &quot;normalizer2impl.h&quot;
 57 #include &quot;sprpimpl.h&quot;
 58 #include &quot;propname.h&quot;
 59 #include &quot;rbbidata.h&quot;
 60 #include &quot;utrie.h&quot;
 61 #include &quot;utrie2.h&quot;
 62 #include &quot;dictionarydata.h&quot;
 63 
 64 /* swapping implementations in i18n */
 65 
 66 #if !UCONFIG_NO_NORMALIZATION
 67 #include &quot;uspoof_impl.h&quot;
 68 #endif
 69 
 70 U_NAMESPACE_USE
 71 
 72 /* definitions */
 73 
 74 /* Unicode property (value) aliases data swapping --------------------------- */
 75 
 76 static int32_t U_CALLCONV
 77 upname_swap(const UDataSwapper *ds,
 78             const void *inData, int32_t length, void *outData,
 79             UErrorCode *pErrorCode) {
 80     /* udata_swapDataHeader checks the arguments */
 81     int32_t headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
 82     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
 83         return 0;
 84     }
 85 
 86     /* check data format and format version */
 87     const UDataInfo *pInfo=
 88         reinterpret_cast&lt;const UDataInfo *&gt;(
 89             static_cast&lt;const char *&gt;(inData)+4);
 90     if(!(
 91         pInfo-&gt;dataFormat[0]==0x70 &amp;&amp;   /* dataFormat=&quot;pnam&quot; */
 92         pInfo-&gt;dataFormat[1]==0x6e &amp;&amp;
 93         pInfo-&gt;dataFormat[2]==0x61 &amp;&amp;
 94         pInfo-&gt;dataFormat[3]==0x6d &amp;&amp;
 95         pInfo-&gt;formatVersion[0]==2
 96     )) {
 97         udata_printError(ds, &quot;upname_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as pnames.icu\n&quot;,
 98                          pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
 99                          pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
100                          pInfo-&gt;formatVersion[0]);
101         *pErrorCode=U_UNSUPPORTED_ERROR;
102         return 0;
103     }
104 
105     const uint8_t *inBytes=static_cast&lt;const uint8_t *&gt;(inData)+headerSize;
106     uint8_t *outBytes=static_cast&lt;uint8_t *&gt;(outData)+headerSize;
107 
108     if(length&gt;=0) {
109         length-=headerSize;
110         // formatVersion 2 initially has indexes[8], 32 bytes.
111         if(length&lt;32) {
112             udata_printError(ds, &quot;upname_swap(): too few bytes (%d after header) for pnames.icu\n&quot;,
113                              (int)length);
114             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
115             return 0;
116         }
117     }
118 
119     const int32_t *inIndexes=reinterpret_cast&lt;const int32_t *&gt;(inBytes);
120     int32_t totalSize=udata_readInt32(ds, inIndexes[PropNameData::IX_TOTAL_SIZE]);
121     if(length&gt;=0) {
122         if(length&lt;totalSize) {
123             udata_printError(ds, &quot;upname_swap(): too few bytes (%d after header, should be %d) &quot;
124                              &quot;for pnames.icu\n&quot;,
125                              (int)length, (int)totalSize);
126             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
127             return 0;
128         }
129 
130         int32_t numBytesIndexesAndValueMaps=
131             udata_readInt32(ds, inIndexes[PropNameData::IX_BYTE_TRIES_OFFSET]);
132 
133         // Swap the indexes[] and the valueMaps[].
134         ds-&gt;swapArray32(ds, inBytes, numBytesIndexesAndValueMaps, outBytes, pErrorCode);
135 
136         // Copy the rest of the data.
137         if(inBytes!=outBytes) {
138             uprv_memcpy(outBytes+numBytesIndexesAndValueMaps,
139                         inBytes+numBytesIndexesAndValueMaps,
140                         totalSize-numBytesIndexesAndValueMaps);
141         }
142 
143         // We need not swap anything else:
144         //
145         // The ByteTries are already byte-serialized, and are fixed on ASCII.
146         // (On an EBCDIC machine, the input string is converted to lowercase ASCII
147         // while matching.)
148         //
149         // The name groups are mostly invariant characters, but since we only
150         // generate, and keep in subversion, ASCII versions of pnames.icu,
151         // and since only ICU4J uses the pnames.icu data file
152         // (the data is hardcoded in ICU4C) and ICU4J uses ASCII data files,
153         // we just copy those bytes too.
154     }
155 
156     return headerSize+totalSize;
157 }
158 
159 /* Unicode properties data swapping ----------------------------------------- */
160 
161 static int32_t U_CALLCONV
162 uprops_swap(const UDataSwapper *ds,
163             const void *inData, int32_t length, void *outData,
164             UErrorCode *pErrorCode) {
165     const UDataInfo *pInfo;
166     int32_t headerSize, i;
167 
168     int32_t dataIndexes[UPROPS_INDEX_COUNT];
169     const int32_t *inData32;
170 
171     /* udata_swapDataHeader checks the arguments */
172     headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
173     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
174         return 0;
175     }
176 
177     /* check data format and format version */
178     pInfo=(const UDataInfo *)((const char *)inData+4);
179     if(!(
180         pInfo-&gt;dataFormat[0]==0x55 &amp;&amp;   /* dataFormat=&quot;UPro&quot; */
181         pInfo-&gt;dataFormat[1]==0x50 &amp;&amp;
182         pInfo-&gt;dataFormat[2]==0x72 &amp;&amp;
183         pInfo-&gt;dataFormat[3]==0x6f &amp;&amp;
184         (3&lt;=pInfo-&gt;formatVersion[0] &amp;&amp; pInfo-&gt;formatVersion[0]&lt;=7) &amp;&amp;
185         (pInfo-&gt;formatVersion[0]&gt;=7 ||
186             (pInfo-&gt;formatVersion[2]==UTRIE_SHIFT &amp;&amp;
187              pInfo-&gt;formatVersion[3]==UTRIE_INDEX_SHIFT))
188     )) {
189         udata_printError(ds, &quot;uprops_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not a Unicode properties file\n&quot;,
190                          pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
191                          pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
192                          pInfo-&gt;formatVersion[0]);
193         *pErrorCode=U_UNSUPPORTED_ERROR;
194         return 0;
195     }
196 
197     /* the properties file must contain at least the indexes array */
198     if(length&gt;=0 &amp;&amp; (length-headerSize)&lt;(int32_t)sizeof(dataIndexes)) {
199         udata_printError(ds, &quot;uprops_swap(): too few bytes (%d after header) for a Unicode properties file\n&quot;,
200                          length-headerSize);
201         *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
202         return 0;
203     }
204 
205     /* read the indexes */
206     inData32=(const int32_t *)((const char *)inData+headerSize);
207     for(i=0; i&lt;UPROPS_INDEX_COUNT; ++i) {
208         dataIndexes[i]=udata_readInt32(ds, inData32[i]);
209     }
210 
211     /*
212      * comments are copied from the data format description in genprops/store.c
213      * indexes[] constants are in uprops.h
214      */
215     int32_t dataTop;
216     if(length&gt;=0) {
217         int32_t *outData32;
218 
219         /*
220          * In formatVersion 7, UPROPS_DATA_TOP_INDEX has the post-header data size.
221          * In earlier formatVersions, it is 0 and a lower dataIndexes entry
222          * has the top of the last item.
223          */
224         for(i=UPROPS_DATA_TOP_INDEX; i&gt;0 &amp;&amp; (dataTop=dataIndexes[i])==0; --i) {}
225 
226         if((length-headerSize)&lt;(4*dataTop)) {
227             udata_printError(ds, &quot;uprops_swap(): too few bytes (%d after header) for a Unicode properties file\n&quot;,
228                              length-headerSize);
229             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
230             return 0;
231         }
232 
233         outData32=(int32_t *)((char *)outData+headerSize);
234 
235         /* copy everything for inaccessible data (padding) */
236         if(inData32!=outData32) {
237             uprv_memcpy(outData32, inData32, 4*(size_t)dataTop);
238         }
239 
240         /* swap the indexes[16] */
241         ds-&gt;swapArray32(ds, inData32, 4*UPROPS_INDEX_COUNT, outData32, pErrorCode);
242 
243         /*
244          * swap the main properties UTrie
245          * PT serialized properties trie, see utrie.h (byte size: 4*(i0-16))
246          */
247         utrie_swapAnyVersion(ds,
248             inData32+UPROPS_INDEX_COUNT,
249             4*(dataIndexes[UPROPS_PROPS32_INDEX]-UPROPS_INDEX_COUNT),
250             outData32+UPROPS_INDEX_COUNT,
251             pErrorCode);
252 
253         /*
254          * swap the properties and exceptions words
255          * P  const uint32_t props32[i1-i0];
256          * E  const uint32_t exceptions[i2-i1];
257          */
258         ds-&gt;swapArray32(ds,
259             inData32+dataIndexes[UPROPS_PROPS32_INDEX],
260             4*(dataIndexes[UPROPS_EXCEPTIONS_TOP_INDEX]-dataIndexes[UPROPS_PROPS32_INDEX]),
261             outData32+dataIndexes[UPROPS_PROPS32_INDEX],
262             pErrorCode);
263 
264         /*
265          * swap the UChars
266          * U  const UChar uchars[2*(i3-i2)];
267          */
268         ds-&gt;swapArray16(ds,
269             inData32+dataIndexes[UPROPS_EXCEPTIONS_TOP_INDEX],
270             4*(dataIndexes[UPROPS_ADDITIONAL_TRIE_INDEX]-dataIndexes[UPROPS_EXCEPTIONS_TOP_INDEX]),
271             outData32+dataIndexes[UPROPS_EXCEPTIONS_TOP_INDEX],
272             pErrorCode);
273 
274         /*
275          * swap the additional UTrie
276          * i3 additionalTrieIndex; -- 32-bit unit index to the additional trie for more properties
277          */
278         utrie_swapAnyVersion(ds,
279             inData32+dataIndexes[UPROPS_ADDITIONAL_TRIE_INDEX],
280             4*(dataIndexes[UPROPS_ADDITIONAL_VECTORS_INDEX]-dataIndexes[UPROPS_ADDITIONAL_TRIE_INDEX]),
281             outData32+dataIndexes[UPROPS_ADDITIONAL_TRIE_INDEX],
282             pErrorCode);
283 
284         /*
285          * swap the properties vectors
286          * PV const uint32_t propsVectors[(i6-i4)/i5][i5]==uint32_t propsVectors[i6-i4];
287          */
288         ds-&gt;swapArray32(ds,
289             inData32+dataIndexes[UPROPS_ADDITIONAL_VECTORS_INDEX],
290             4*(dataIndexes[UPROPS_SCRIPT_EXTENSIONS_INDEX]-dataIndexes[UPROPS_ADDITIONAL_VECTORS_INDEX]),
291             outData32+dataIndexes[UPROPS_ADDITIONAL_VECTORS_INDEX],
292             pErrorCode);
293 
294         // swap the Script_Extensions data
295         // SCX const uint16_t scriptExtensions[2*(i7-i6)];
296         ds-&gt;swapArray16(ds,
297             inData32+dataIndexes[UPROPS_SCRIPT_EXTENSIONS_INDEX],
298             4*(dataIndexes[UPROPS_RESERVED_INDEX_7]-dataIndexes[UPROPS_SCRIPT_EXTENSIONS_INDEX]),
299             outData32+dataIndexes[UPROPS_SCRIPT_EXTENSIONS_INDEX],
300             pErrorCode);
301     }
302 
303     /* i7 reservedIndex7; -- 32-bit unit index to the top of the Script_Extensions data */
304     return headerSize+4*dataIndexes[UPROPS_RESERVED_INDEX_7];
305 }
306 
307 /* Unicode case mapping data swapping --------------------------------------- */
308 
309 static int32_t U_CALLCONV
310 ucase_swap(const UDataSwapper *ds,
311            const void *inData, int32_t length, void *outData,
312            UErrorCode *pErrorCode) {
313     const UDataInfo *pInfo;
314     int32_t headerSize;
315 
316     const uint8_t *inBytes;
317     uint8_t *outBytes;
318 
319     const int32_t *inIndexes;
320     int32_t indexes[16];
321 
322     int32_t i, offset, count, size;
323 
324     /* udata_swapDataHeader checks the arguments */
325     headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
326     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
327         return 0;
328     }
329 
330     /* check data format and format version */
331     pInfo=(const UDataInfo *)((const char *)inData+4);
332     if(!(
333         pInfo-&gt;dataFormat[0]==UCASE_FMT_0 &amp;&amp;    /* dataFormat=&quot;cAsE&quot; */
334         pInfo-&gt;dataFormat[1]==UCASE_FMT_1 &amp;&amp;
335         pInfo-&gt;dataFormat[2]==UCASE_FMT_2 &amp;&amp;
336         pInfo-&gt;dataFormat[3]==UCASE_FMT_3 &amp;&amp;
337         ((pInfo-&gt;formatVersion[0]==1 &amp;&amp;
338           pInfo-&gt;formatVersion[2]==UTRIE_SHIFT &amp;&amp;
339           pInfo-&gt;formatVersion[3]==UTRIE_INDEX_SHIFT) ||
340          (2&lt;=pInfo-&gt;formatVersion[0] &amp;&amp; pInfo-&gt;formatVersion[0]&lt;=4))
341     )) {
342         udata_printError(ds, &quot;ucase_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as case mapping data\n&quot;,
343                          pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
344                          pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
345                          pInfo-&gt;formatVersion[0]);
346         *pErrorCode=U_UNSUPPORTED_ERROR;
347         return 0;
348     }
349 
350     inBytes=(const uint8_t *)inData+headerSize;
351     outBytes=(uint8_t *)outData+headerSize;
352 
353     inIndexes=(const int32_t *)inBytes;
354 
355     if(length&gt;=0) {
356         length-=headerSize;
357         if(length&lt;16*4) {
358             udata_printError(ds, &quot;ucase_swap(): too few bytes (%d after header) for case mapping data\n&quot;,
359                              length);
360             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
361             return 0;
362         }
363     }
364 
365     /* read the first 16 indexes (ICU 3.2/format version 1: UCASE_IX_TOP==16, might grow) */
366     for(i=0; i&lt;16; ++i) {
367         indexes[i]=udata_readInt32(ds, inIndexes[i]);
368     }
369 
370     /* get the total length of the data */
371     size=indexes[UCASE_IX_LENGTH];
372 
373     if(length&gt;=0) {
374         if(length&lt;size) {
375             udata_printError(ds, &quot;ucase_swap(): too few bytes (%d after header) for all of case mapping data\n&quot;,
376                              length);
377             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
378             return 0;
379         }
380 
381         /* copy the data for inaccessible bytes */
382         if(inBytes!=outBytes) {
383             uprv_memcpy(outBytes, inBytes, size);
384         }
385 
386         offset=0;
387 
388         /* swap the int32_t indexes[] */
389         count=indexes[UCASE_IX_INDEX_TOP]*4;
390         ds-&gt;swapArray32(ds, inBytes, count, outBytes, pErrorCode);
391         offset+=count;
392 
393         /* swap the UTrie */
394         count=indexes[UCASE_IX_TRIE_SIZE];
395         utrie_swapAnyVersion(ds, inBytes+offset, count, outBytes+offset, pErrorCode);
396         offset+=count;
397 
398         /* swap the uint16_t exceptions[] and unfold[] */
399         count=(indexes[UCASE_IX_EXC_LENGTH]+indexes[UCASE_IX_UNFOLD_LENGTH])*2;
400         ds-&gt;swapArray16(ds, inBytes+offset, count, outBytes+offset, pErrorCode);
401         offset+=count;
402 
403         U_ASSERT(offset==size);
404     }
405 
406     return headerSize+size;
407 }
408 
409 /* Unicode bidi/shaping data swapping --------------------------------------- */
410 
411 static int32_t U_CALLCONV
412 ubidi_swap(const UDataSwapper *ds,
413            const void *inData, int32_t length, void *outData,
414            UErrorCode *pErrorCode) {
415     const UDataInfo *pInfo;
416     int32_t headerSize;
417 
418     const uint8_t *inBytes;
419     uint8_t *outBytes;
420 
421     const int32_t *inIndexes;
422     int32_t indexes[16];
423 
424     int32_t i, offset, count, size;
425 
426     /* udata_swapDataHeader checks the arguments */
427     headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
428     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
429         return 0;
430     }
431 
432     /* check data format and format version */
433     pInfo=(const UDataInfo *)((const char *)inData+4);
434     if(!(
435         pInfo-&gt;dataFormat[0]==UBIDI_FMT_0 &amp;&amp;    /* dataFormat=&quot;BiDi&quot; */
436         pInfo-&gt;dataFormat[1]==UBIDI_FMT_1 &amp;&amp;
437         pInfo-&gt;dataFormat[2]==UBIDI_FMT_2 &amp;&amp;
438         pInfo-&gt;dataFormat[3]==UBIDI_FMT_3 &amp;&amp;
439         ((pInfo-&gt;formatVersion[0]==1 &amp;&amp;
440           pInfo-&gt;formatVersion[2]==UTRIE_SHIFT &amp;&amp;
441           pInfo-&gt;formatVersion[3]==UTRIE_INDEX_SHIFT) ||
442          pInfo-&gt;formatVersion[0]==2)
443     )) {
444         udata_printError(ds, &quot;ubidi_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as bidi/shaping data\n&quot;,
445                          pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
446                          pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
447                          pInfo-&gt;formatVersion[0]);
448         *pErrorCode=U_UNSUPPORTED_ERROR;
449         return 0;
450     }
451 
452     inBytes=(const uint8_t *)inData+headerSize;
453     outBytes=(uint8_t *)outData+headerSize;
454 
455     inIndexes=(const int32_t *)inBytes;
456 
457     if(length&gt;=0) {
458         length-=headerSize;
459         if(length&lt;16*4) {
460             udata_printError(ds, &quot;ubidi_swap(): too few bytes (%d after header) for bidi/shaping data\n&quot;,
461                              length);
462             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
463             return 0;
464         }
465     }
466 
467     /* read the first 16 indexes (ICU 3.4/format version 1: UBIDI_IX_TOP==16, might grow) */
468     for(i=0; i&lt;16; ++i) {
469         indexes[i]=udata_readInt32(ds, inIndexes[i]);
470     }
471 
472     /* get the total length of the data */
473     size=indexes[UBIDI_IX_LENGTH];
474 
475     if(length&gt;=0) {
476         if(length&lt;size) {
477             udata_printError(ds, &quot;ubidi_swap(): too few bytes (%d after header) for all of bidi/shaping data\n&quot;,
478                              length);
479             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
480             return 0;
481         }
482 
483         /* copy the data for inaccessible bytes */
484         if(inBytes!=outBytes) {
485             uprv_memcpy(outBytes, inBytes, size);
486         }
487 
488         offset=0;
489 
490         /* swap the int32_t indexes[] */
491         count=indexes[UBIDI_IX_INDEX_TOP]*4;
492         ds-&gt;swapArray32(ds, inBytes, count, outBytes, pErrorCode);
493         offset+=count;
494 
495         /* swap the UTrie */
496         count=indexes[UBIDI_IX_TRIE_SIZE];
497         utrie_swapAnyVersion(ds, inBytes+offset, count, outBytes+offset, pErrorCode);
498         offset+=count;
499 
500         /* swap the uint32_t mirrors[] */
501         count=indexes[UBIDI_IX_MIRROR_LENGTH]*4;
502         ds-&gt;swapArray32(ds, inBytes+offset, count, outBytes+offset, pErrorCode);
503         offset+=count;
504 
505         /* just skip the uint8_t jgArray[] and jgArray2[] */
506         count=indexes[UBIDI_IX_JG_LIMIT]-indexes[UBIDI_IX_JG_START];
507         offset+=count;
508         count=indexes[UBIDI_IX_JG_LIMIT2]-indexes[UBIDI_IX_JG_START2];
509         offset+=count;
510 
511         U_ASSERT(offset==size);
512     }
513 
514     return headerSize+size;
515 }
516 
517 /* Unicode normalization data swapping -------------------------------------- */
518 
519 #if !UCONFIG_NO_NORMALIZATION
520 
521 static int32_t U_CALLCONV
522 unorm_swap(const UDataSwapper *ds,
523            const void *inData, int32_t length, void *outData,
524            UErrorCode *pErrorCode) {
525     const UDataInfo *pInfo;
526     int32_t headerSize;
527 
528     const uint8_t *inBytes;
529     uint8_t *outBytes;
530 
531     const int32_t *inIndexes;
532     int32_t indexes[32];
533 
534     int32_t i, offset, count, size;
535 
536     /* udata_swapDataHeader checks the arguments */
537     headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
538     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
539         return 0;
540     }
541 
542     /* check data format and format version */
543     pInfo=(const UDataInfo *)((const char *)inData+4);
544     if(!(
545         pInfo-&gt;dataFormat[0]==0x4e &amp;&amp;   /* dataFormat=&quot;Norm&quot; */
546         pInfo-&gt;dataFormat[1]==0x6f &amp;&amp;
547         pInfo-&gt;dataFormat[2]==0x72 &amp;&amp;
548         pInfo-&gt;dataFormat[3]==0x6d &amp;&amp;
549         pInfo-&gt;formatVersion[0]==2
550     )) {
551         udata_printError(ds, &quot;unorm_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as unorm.icu\n&quot;,
552                          pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
553                          pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
554                          pInfo-&gt;formatVersion[0]);
555         *pErrorCode=U_UNSUPPORTED_ERROR;
556         return 0;
557     }
558 
559     inBytes=(const uint8_t *)inData+headerSize;
560     outBytes=(uint8_t *)outData+headerSize;
561 
562     inIndexes=(const int32_t *)inBytes;
563 
564     if(length&gt;=0) {
565         length-=headerSize;
566         if(length&lt;32*4) {
567             udata_printError(ds, &quot;unorm_swap(): too few bytes (%d after header) for unorm.icu\n&quot;,
568                              length);
569             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
570             return 0;
571         }
572     }
573 
574     /* read the first 32 indexes (ICU 2.8/format version 2.2: _NORM_INDEX_TOP==32, might grow) */
575     for(i=0; i&lt;32; ++i) {
576         indexes[i]=udata_readInt32(ds, inIndexes[i]);
577     }
578 
579     /* calculate the total length of the data */
580     size=
581         32*4+ /* size of indexes[] */
582         indexes[_NORM_INDEX_TRIE_SIZE]+
583         indexes[_NORM_INDEX_UCHAR_COUNT]*2+
584         indexes[_NORM_INDEX_COMBINE_DATA_COUNT]*2+
585         indexes[_NORM_INDEX_FCD_TRIE_SIZE]+
586         indexes[_NORM_INDEX_AUX_TRIE_SIZE]+
587         indexes[_NORM_INDEX_CANON_SET_COUNT]*2;
588 
589     if(length&gt;=0) {
590         if(length&lt;size) {
591             udata_printError(ds, &quot;unorm_swap(): too few bytes (%d after header) for all of unorm.icu\n&quot;,
592                              length);
593             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
594             return 0;
595         }
596 
597         /* copy the data for inaccessible bytes */
598         if(inBytes!=outBytes) {
599             uprv_memcpy(outBytes, inBytes, size);
600         }
601 
602         offset=0;
603 
604         /* swap the indexes[] */
605         count=32*4;
606         ds-&gt;swapArray32(ds, inBytes, count, outBytes, pErrorCode);
607         offset+=count;
608 
609         /* swap the main UTrie */
610         count=indexes[_NORM_INDEX_TRIE_SIZE];
611         utrie_swap(ds, inBytes+offset, count, outBytes+offset, pErrorCode);
612         offset+=count;
613 
614         /* swap the uint16_t extraData[] and the uint16_t combiningTable[] */
615         count=(indexes[_NORM_INDEX_UCHAR_COUNT]+indexes[_NORM_INDEX_COMBINE_DATA_COUNT])*2;
616         ds-&gt;swapArray16(ds, inBytes+offset, count, outBytes+offset, pErrorCode);
617         offset+=count;
618 
619         /* swap the FCD UTrie */
620         count=indexes[_NORM_INDEX_FCD_TRIE_SIZE];
621         if(count!=0) {
622             utrie_swap(ds, inBytes+offset, count, outBytes+offset, pErrorCode);
623             offset+=count;
624         }
625 
626         /* swap the aux UTrie */
627         count=indexes[_NORM_INDEX_AUX_TRIE_SIZE];
628         if(count!=0) {
629             utrie_swap(ds, inBytes+offset, count, outBytes+offset, pErrorCode);
630             offset+=count;
631         }
632 
633         /* swap the uint16_t combiningTable[] */
634         count=indexes[_NORM_INDEX_CANON_SET_COUNT]*2;
635         ds-&gt;swapArray16(ds, inBytes+offset, count, outBytes+offset, pErrorCode);
636         offset+=count;
637     }
638 
639     return headerSize+size;
640 }
641 
642 #endif
643 
644 // Unicode text layout properties data swapping --------------------------------
645 
646 static int32_t U_CALLCONV
647 ulayout_swap(const UDataSwapper *ds,
648              const void *inData, int32_t length, void *outData,
649              UErrorCode *pErrorCode) {
650     // udata_swapDataHeader checks the arguments.
651     int32_t headerSize = udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
652     if (pErrorCode == nullptr || U_FAILURE(*pErrorCode)) {
653         return 0;
654     }
655 
656     // Check data format and format version.
657     const UDataInfo *pInfo = (const UDataInfo *)((const char *)inData + 4);
658     if (!(
659             pInfo-&gt;dataFormat[0] == ULAYOUT_FMT_0 &amp;&amp;    // dataFormat=&quot;Layo&quot;
660             pInfo-&gt;dataFormat[1] == ULAYOUT_FMT_1 &amp;&amp;
661             pInfo-&gt;dataFormat[2] == ULAYOUT_FMT_2 &amp;&amp;
662             pInfo-&gt;dataFormat[3] == ULAYOUT_FMT_3 &amp;&amp;
663             pInfo-&gt;formatVersion[0] == 1)) {
664         udata_printError(ds,
665             &quot;ulayout_swap(): data format %02x.%02x.%02x.%02x (format version %02x) &quot;
666             &quot;is not recognized as text layout properties data\n&quot;,
667             pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
668             pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
669             pInfo-&gt;formatVersion[0]);
670         *pErrorCode = U_UNSUPPORTED_ERROR;
671         return 0;
672     }
673 
674     const uint8_t *inBytes = (const uint8_t *)inData + headerSize;
675     uint8_t *outBytes = (uint8_t *)outData + headerSize;
676 
677     const int32_t *inIndexes = (const int32_t *)inBytes;
678 
679     if (length &gt;= 0) {
680         length -= headerSize;
681         if (length &lt; 12 * 4) {
682             udata_printError(ds,
683                 &quot;ulayout_swap(): too few bytes (%d after header) for text layout properties data\n&quot;,
684                 length);
685             *pErrorCode = U_INDEX_OUTOFBOUNDS_ERROR;
686             return 0;
687         }
688     }
689 
690     int32_t indexesLength = udata_readInt32(ds, inIndexes[ULAYOUT_IX_INDEXES_LENGTH]);
691     if (indexesLength &lt; 12) {
692         udata_printError(ds,
693             &quot;ulayout_swap(): too few indexes (%d) for text layout properties data\n&quot;,
694             indexesLength);
695         *pErrorCode = U_INDEX_OUTOFBOUNDS_ERROR;
696         return 0;
697     }
698 
699     // Read the data offsets before swapping anything.
700     int32_t indexes[ULAYOUT_IX_TRIES_TOP + 1];
701     for (int32_t i = ULAYOUT_IX_INPC_TRIE_TOP; i &lt;= ULAYOUT_IX_TRIES_TOP; ++i) {
702         indexes[i] = udata_readInt32(ds, inIndexes[i]);
703     }
704     int32_t size = indexes[ULAYOUT_IX_TRIES_TOP];
705 
706     if (length &gt;= 0) {
707         if (length &lt; size) {
708             udata_printError(ds,
709                 &quot;ulayout_swap(): too few bytes (%d after header) &quot;
710                 &quot;for all of text layout properties data\n&quot;,
711                 length);
712             *pErrorCode = U_INDEX_OUTOFBOUNDS_ERROR;
713             return 0;
714         }
715 
716         // Copy the data for inaccessible bytes.
717         if (inBytes != outBytes) {
718             uprv_memcpy(outBytes, inBytes, size);
719         }
720 
721         // Swap the int32_t indexes[].
722         int32_t offset = 0;
723         int32_t count = indexesLength * 4;
724         ds-&gt;swapArray32(ds, inBytes, count, outBytes, pErrorCode);
725         offset += count;
726 
727         // Swap each trie.
728         for (int32_t i = ULAYOUT_IX_INPC_TRIE_TOP; i &lt;= ULAYOUT_IX_TRIES_TOP; ++i) {
729             int32_t top = indexes[i];
730             count = top - offset;
731             U_ASSERT(count &gt;= 0);
732             if (count &gt;= 16) {
733                 utrie_swapAnyVersion(ds, inBytes + offset, count, outBytes + offset, pErrorCode);
734             }
735             offset = top;
736         }
737 
738         U_ASSERT(offset == size);
739     }
740 
741     return headerSize + size;
742 }
743 
744 /* Swap &#39;Test&#39; data from gentest */
745 static int32_t U_CALLCONV
746 test_swap(const UDataSwapper *ds,
747            const void *inData, int32_t length, void *outData,
748            UErrorCode *pErrorCode) {
749     const UDataInfo *pInfo;
750     int32_t headerSize;
751 
752     const uint8_t *inBytes;
753     uint8_t *outBytes;
754 
755     int32_t offset;
756 
757     /* udata_swapDataHeader checks the arguments */
758     headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
759     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
760         udata_printError(ds, &quot;test_swap(): data header swap failed %s\n&quot;, pErrorCode != NULL ? u_errorName(*pErrorCode) : &quot;pErrorCode is NULL&quot;);
761         return 0;
762     }
763 
764     /* check data format and format version */
765     pInfo=(const UDataInfo *)((const char *)inData+4);
766     if(!(
767         pInfo-&gt;dataFormat[0]==0x54 &amp;&amp;   /* dataFormat=&quot;Norm&quot; */
768         pInfo-&gt;dataFormat[1]==0x65 &amp;&amp;
769         pInfo-&gt;dataFormat[2]==0x73 &amp;&amp;
770         pInfo-&gt;dataFormat[3]==0x74 &amp;&amp;
771         pInfo-&gt;formatVersion[0]==1
772     )) {
773         udata_printError(ds, &quot;test_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as testdata\n&quot;,
774                          pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
775                          pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
776                          pInfo-&gt;formatVersion[0]);
777         *pErrorCode=U_UNSUPPORTED_ERROR;
778         return 0;
779     }
780 
781     inBytes=(const uint8_t *)inData+headerSize;
782     outBytes=(uint8_t *)outData+headerSize;
783 
784     int32_t size16 = 2; // 16bit plus padding
785     int32_t sizeStr = 5; // 4 char inv-str plus null
786     int32_t size = size16 + sizeStr;
787 
788     if(length&gt;=0) {
789         if(length&lt;size) {
790             udata_printError(ds, &quot;test_swap(): too few bytes (%d after header, wanted %d) for all of testdata\n&quot;,
791                              length, size);
792             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
793             return 0;
794         }
795 
796     offset =0;
797     /* swap a 1 entry array */
798         ds-&gt;swapArray16(ds, inBytes+offset, size16, outBytes+offset, pErrorCode);
799     offset+=size16;
800     ds-&gt;swapInvChars(ds, inBytes+offset, sizeStr, outBytes+offset, pErrorCode);
801     }
802 
803     return headerSize+size;
804 }
805 
806 /* swap any data (except a .dat package) ------------------------------------ */
807 
808 static const struct {
809     uint8_t dataFormat[4];
810     UDataSwapFn *swapFn;
811 } swapFns[]={
812     { { 0x52, 0x65, 0x73, 0x42 }, ures_swap },          /* dataFormat=&quot;ResB&quot; */
813 #if !UCONFIG_NO_LEGACY_CONVERSION
814     { { 0x63, 0x6e, 0x76, 0x74 }, ucnv_swap },          /* dataFormat=&quot;cnvt&quot; */
815 #endif
816 #if !UCONFIG_NO_CONVERSION
817     { { 0x43, 0x76, 0x41, 0x6c }, ucnv_swapAliases },   /* dataFormat=&quot;CvAl&quot; */
818 #endif
819 #if !UCONFIG_NO_IDNA
820     { { 0x53, 0x50, 0x52, 0x50 }, usprep_swap },        /* dataFormat=&quot;SPRP&quot; */
821 #endif
822     /* insert data formats here, descending by expected frequency of occurrence */
823     { { 0x55, 0x50, 0x72, 0x6f }, uprops_swap },        /* dataFormat=&quot;UPro&quot; */
824 
825     { { UCASE_FMT_0, UCASE_FMT_1, UCASE_FMT_2, UCASE_FMT_3 },
826                                   ucase_swap },         /* dataFormat=&quot;cAsE&quot; */
827 
828     { { UBIDI_FMT_0, UBIDI_FMT_1, UBIDI_FMT_2, UBIDI_FMT_3 },
829                                   ubidi_swap },         /* dataFormat=&quot;BiDi&quot; */
830 
831 #if !UCONFIG_NO_NORMALIZATION
832     { { 0x4e, 0x6f, 0x72, 0x6d }, unorm_swap },         /* dataFormat=&quot;Norm&quot; */
833     { { 0x4e, 0x72, 0x6d, 0x32 }, unorm2_swap },        /* dataFormat=&quot;Nrm2&quot; */
834 #endif
835 
836     { { ULAYOUT_FMT_0, ULAYOUT_FMT_1, ULAYOUT_FMT_2, ULAYOUT_FMT_3 },
837                                   ulayout_swap },       // dataFormat=&quot;Layo&quot;
838 
839 #if !UCONFIG_NO_COLLATION
840     { { 0x55, 0x43, 0x6f, 0x6c }, ucol_swap },          /* dataFormat=&quot;UCol&quot; */
841     { { 0x49, 0x6e, 0x76, 0x43 }, ucol_swapInverseUCA },/* dataFormat=&quot;InvC&quot; */
842 #endif
843 #if !UCONFIG_NO_BREAK_ITERATION
844     { { 0x42, 0x72, 0x6b, 0x20 }, ubrk_swap },          /* dataFormat=&quot;Brk &quot; */
845     { { 0x44, 0x69, 0x63, 0x74 }, udict_swap },         /* dataFormat=&quot;Dict&quot; */
846 #endif
847     { { 0x70, 0x6e, 0x61, 0x6d }, upname_swap },        /* dataFormat=&quot;pnam&quot; */
848     { { 0x75, 0x6e, 0x61, 0x6d }, uchar_swapNames },    /* dataFormat=&quot;unam&quot; */
849 #if !UCONFIG_NO_NORMALIZATION
850     { { 0x43, 0x66, 0x75, 0x20 }, uspoof_swap },         /* dataFormat=&quot;Cfu &quot; */
851 #endif
852     { { 0x54, 0x65, 0x73, 0x74 }, test_swap }            /* dataFormat=&quot;Test&quot; */
853 };
854 
855 U_CAPI int32_t U_EXPORT2
856 udata_swap(const UDataSwapper *ds,
857            const void *inData, int32_t length, void *outData,
858            UErrorCode *pErrorCode) {
859     char dataFormatChars[4];
860     const UDataInfo *pInfo;
861     int32_t i, swappedLength;
862 
863     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
864         return 0;
865     }
866 
867     /*
868      * Preflight the header first; checks for illegal arguments, too.
869      * Do not swap the header right away because the format-specific swapper
870      * will swap it, get the headerSize again, and also use the header
871      * information. Otherwise we would have to pass some of the information
872      * and not be able to use the UDataSwapFn signature.
873      */
874     udata_swapDataHeader(ds, inData, -1, NULL, pErrorCode);
875 
876     /*
877      * If we wanted udata_swap() to also handle non-loadable data like a UTrie,
878      * then we could check here for further known magic values and structures.
879      */
880     if(U_FAILURE(*pErrorCode)) {
881         return 0; /* the data format was not recognized */
882     }
883 
884     pInfo=(const UDataInfo *)((const char *)inData+4);
885 
886     {
887         /* convert the data format from ASCII to Unicode to the system charset */
888         UChar u[4]={
889              pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
890              pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3]
891         };
892 
893         if(uprv_isInvariantUString(u, 4)) {
894             u_UCharsToChars(u, dataFormatChars, 4);
895         } else {
896             dataFormatChars[0]=dataFormatChars[1]=dataFormatChars[2]=dataFormatChars[3]=&#39;?&#39;;
897         }
898     }
899 
900     /* dispatch to the swap function for the dataFormat */
901     for(i=0; i&lt;UPRV_LENGTHOF(swapFns); ++i) {
902         if(0==memcmp(swapFns[i].dataFormat, pInfo-&gt;dataFormat, 4)) {
903             swappedLength=swapFns[i].swapFn(ds, inData, length, outData, pErrorCode);
904 
905             if(U_FAILURE(*pErrorCode)) {
906                 udata_printError(ds, &quot;udata_swap(): failure swapping data format %02x.%02x.%02x.%02x (\&quot;%c%c%c%c\&quot;) - %s\n&quot;,
907                                  pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
908                                  pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
909                                  dataFormatChars[0], dataFormatChars[1],
910                                  dataFormatChars[2], dataFormatChars[3],
911                                  u_errorName(*pErrorCode));
912             } else if(swappedLength&lt;(length-15)) {
913                 /* swapped less than expected */
914                 udata_printError(ds, &quot;udata_swap() warning: swapped only %d out of %d bytes - data format %02x.%02x.%02x.%02x (\&quot;%c%c%c%c\&quot;)\n&quot;,
915                                  swappedLength, length,
916                                  pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
917                                  pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
918                                  dataFormatChars[0], dataFormatChars[1],
919                                  dataFormatChars[2], dataFormatChars[3],
920                                  u_errorName(*pErrorCode));
921             }
922 
923             return swappedLength;
924         }
925     }
926 
927     /* the dataFormat was not recognized */
928     udata_printError(ds, &quot;udata_swap(): unknown data format %02x.%02x.%02x.%02x (\&quot;%c%c%c%c\&quot;)\n&quot;,
929                      pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],
930                      pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],
931                      dataFormatChars[0], dataFormatChars[1],
932                      dataFormatChars[2], dataFormatChars[3]);
933 
934     *pErrorCode=U_UNSUPPORTED_ERROR;
935     return 0;
936 }
    </pre>
  </body>
</html>