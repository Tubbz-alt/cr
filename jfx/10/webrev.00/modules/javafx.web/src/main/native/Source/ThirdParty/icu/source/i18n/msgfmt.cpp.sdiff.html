<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/msgfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="measunit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="nfrule.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/msgfmt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 793             Format* new_format = newFormat.clone();
 794             if (new_format == NULL) {
 795                 status = U_MEMORY_ALLOCATION_ERROR;
 796                 return;
 797             }
 798             setCustomArgStartFormat(partIndex, new_format, status);
 799         }
 800     }
 801 }
 802 
 803 // -------------------------------------
 804 // Gets the format array.
 805 const Format**
 806 MessageFormat::getFormats(int32_t&amp; cnt) const
 807 {
 808     // This old API returns an array (which we hold) of Format*
 809     // pointers.  The array is valid up to the next call to any
 810     // method on this object.  We construct and resize an array
 811     // on demand that contains aliases to the subformats[i].format
 812     // pointers.





 813     MessageFormat* t = const_cast&lt;MessageFormat*&gt; (this);
 814     cnt = 0;
<span class="line-modified"> 815     if (formatAliases == NULL) {</span>
<span class="line-modified"> 816         t-&gt;formatAliasesCapacity = (argTypeCount&lt;10) ? 10 : argTypeCount;</span>
 817         Format** a = (Format**)
 818             uprv_malloc(sizeof(Format*) * formatAliasesCapacity);
<span class="line-modified"> 819         if (a == NULL) {</span>
 820             t-&gt;formatAliasesCapacity = 0;
<span class="line-modified"> 821             return NULL;</span>
 822         }
 823         t-&gt;formatAliases = a;
<span class="line-modified"> 824     } else if (argTypeCount &gt; formatAliasesCapacity) {</span>
 825         Format** a = (Format**)
<span class="line-modified"> 826             uprv_realloc(formatAliases, sizeof(Format*) * argTypeCount);</span>
<span class="line-modified"> 827         if (a == NULL) {</span>
 828             t-&gt;formatAliasesCapacity = 0;
<span class="line-modified"> 829             return NULL;</span>
 830         }
 831         t-&gt;formatAliases = a;
<span class="line-modified"> 832         t-&gt;formatAliasesCapacity = argTypeCount;</span>
 833     }
 834 
 835     for (int32_t partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0;) {
 836         t-&gt;formatAliases[cnt++] = getCachedFormatter(partIndex);
 837     }
 838 
 839     return (const Format**)formatAliases;
 840 }
 841 
 842 
 843 UnicodeString MessageFormat::getArgName(int32_t partIndex) {
 844     const MessagePattern::Part&amp; part = msgPattern.getPart(partIndex);
 845     return msgPattern.getSubstring(part);
 846 }
 847 
 848 StringEnumeration*
 849 MessageFormat::getFormatNames(UErrorCode&amp; status) {
 850     if (U_FAILURE(status))  return NULL;
 851 
 852     UVector *fFormatNames = new UVector(status);
</pre>
<hr />
<pre>
1061         int32_t prevDestLength = appendTo.length();
1062         const Format* formatter = NULL;
1063         if (noArg) {
1064             appendTo.append(
1065                 UnicodeString(LEFT_CURLY_BRACE).append(argName).append(RIGHT_CURLY_BRACE));
1066         } else if (arg == NULL) {
1067             appendTo.append(NULL_STRING, 4);
1068         } else if(plNumber!=NULL &amp;&amp;
1069                 static_cast&lt;const PluralSelectorContext *&gt;(plNumber)-&gt;numberArgIndex==(i-2)) {
1070             const PluralSelectorContext &amp;pluralNumber =
1071                 *static_cast&lt;const PluralSelectorContext *&gt;(plNumber);
1072             if(pluralNumber.offset == 0) {
1073                 // The number was already formatted with this formatter.
1074                 appendTo.formatAndAppend(pluralNumber.formatter, pluralNumber.number,
1075                                          pluralNumber.numberString, success);
1076             } else {
1077                 // Do not use the formatted (number-offset) string for a named argument
1078                 // that formats the number without subtracting the offset.
1079                 appendTo.formatAndAppend(pluralNumber.formatter, *arg, success);
1080             }
<span class="line-modified">1081         } else if ((formatter = getCachedFormatter(i -2))) {</span>
1082             // Handles all ArgType.SIMPLE, and formatters from setFormat() and its siblings.
1083             if (dynamic_cast&lt;const ChoiceFormat*&gt;(formatter) ||
1084                 dynamic_cast&lt;const PluralFormat*&gt;(formatter) ||
1085                 dynamic_cast&lt;const SelectFormat*&gt;(formatter)) {
1086                 // We only handle nested formats here if they were provided via
1087                 // setFormat() or its siblings. Otherwise they are not cached and instead
1088                 // handled below according to argType.
1089                 UnicodeString subMsgString;
1090                 formatter-&gt;format(*arg, subMsgString, success);
1091                 if (subMsgString.indexOf(LEFT_CURLY_BRACE) &gt;= 0 ||
1092                     (subMsgString.indexOf(SINGLE_QUOTE) &gt;= 0 &amp;&amp; !MessageImpl::jdkAposMode(msgPattern))
1093                 ) {
1094                     MessageFormat subMsgFormat(subMsgString, fLocale, success);
1095                     subMsgFormat.format(0, NULL, arguments, argumentNames, cnt, appendTo, ignore, success);
1096                 } else {
1097                     appendTo.append(subMsgString);
1098                 }
1099             } else {
1100                 appendTo.formatAndAppend(formatter, *arg, success);
1101             }
</pre>
<hr />
<pre>
1656         case UMSGPAT_ARG_TYPE_SELECTORDINAL:
1657             formattableType = Formattable::kDouble;
1658             break;
1659         case UMSGPAT_ARG_TYPE_SELECT:
1660             formattableType = Formattable::kString;
1661             break;
1662         default:
1663             status = U_INTERNAL_PROGRAM_ERROR;  // Should be unreachable.
1664             formattableType = Formattable::kString;
1665             break;
1666         }
1667         if (argNumber != -1) {
1668             if (argTypes[argNumber] != Formattable::kObject &amp;&amp; argTypes[argNumber] != formattableType) {
1669                 hasArgTypeConflicts = TRUE;
1670             }
1671             argTypes[argNumber] = formattableType;
1672         }
1673     }
1674 }
1675 
<span class="line-removed">1676 </span>
1677 Format* MessageFormat::createAppropriateFormat(UnicodeString&amp; type, UnicodeString&amp; style,
1678                                                Formattable::Type&amp; formattableType, UParseError&amp; parseError,
1679                                                UErrorCode&amp; ec) {
1680     if (U_FAILURE(ec)) {
1681         return NULL;
1682     }
1683     Format* fmt = NULL;
1684     int32_t typeID, styleID;
1685     DateFormat::EStyle date_style;

1686 
1687     switch (typeID = findKeyword(type, TYPE_IDS)) {
1688     case 0: // number
1689         formattableType = Formattable::kDouble;
1690         switch (findKeyword(style, NUMBER_STYLE_IDS)) {
1691         case 0: // default
1692             fmt = NumberFormat::createInstance(fLocale, ec);
1693             break;
1694         case 1: // currency
1695             fmt = NumberFormat::createCurrencyInstance(fLocale, ec);
1696             break;
1697         case 2: // percent
1698             fmt = NumberFormat::createPercentInstance(fLocale, ec);
1699             break;
1700         case 3: // integer
1701             formattableType = Formattable::kLong;
1702             fmt = createIntegerFormat(fLocale, ec);
1703             break;
1704         default: // pattern or skeleton
<span class="line-modified">1705             int32_t i = 0;</span>
<span class="line-modified">1706             for (; PatternProps::isWhiteSpace(style.charAt(i)); i++);</span>
<span class="line-removed">1707             if (style.compare(i, 2, u&quot;::&quot;, 0, 2) == 0) {</span>
1708                 // Skeleton
<span class="line-modified">1709                 UnicodeString skeleton = style.tempSubString(i + 2);</span>
1710                 fmt = number::NumberFormatter::forSkeleton(skeleton, ec).locale(fLocale).toFormat(ec);
1711             } else {
1712                 // Pattern
1713                 fmt = NumberFormat::createInstance(fLocale, ec);
1714                 if (fmt) {
1715                     auto* decfmt = dynamic_cast&lt;DecimalFormat*&gt;(fmt);
1716                     if (decfmt != nullptr) {
1717                         decfmt-&gt;applyPattern(style, parseError, ec);
1718                     }
1719                 }
1720             }
1721             break;
1722         }
1723         break;
1724 
1725     case 1: // date
1726     case 2: // time
1727         formattableType = Formattable::kDate;
<span class="line-modified">1728         styleID = findKeyword(style, DATE_STYLE_IDS);</span>
<span class="line-modified">1729         date_style = (styleID &gt;= 0) ? DATE_STYLES[styleID] : DateFormat::kDefault;</span>
<span class="line-modified">1730 </span>
<span class="line-modified">1731         if (typeID == 1) {</span>
<span class="line-modified">1732             fmt = DateFormat::createDateInstance(date_style, fLocale);</span>
1733         } else {
<span class="line-modified">1734             fmt = DateFormat::createTimeInstance(date_style, fLocale);</span>
<span class="line-modified">1735         }</span>

1736 
<span class="line-modified">1737         if (styleID &lt; 0 &amp;&amp; fmt != NULL) {</span>
<span class="line-modified">1738             SimpleDateFormat* sdtfmt = dynamic_cast&lt;SimpleDateFormat*&gt;(fmt);</span>
<span class="line-modified">1739             if (sdtfmt != NULL) {</span>
<span class="line-modified">1740                 sdtfmt-&gt;applyPattern(style);</span>







1741             }
1742         }
1743         break;
1744 
1745     case 3: // spellout
1746         formattableType = Formattable::kDouble;
1747         fmt = makeRBNF(URBNF_SPELLOUT, fLocale, style, ec);
1748         break;
1749     case 4: // ordinal
1750         formattableType = Formattable::kDouble;
1751         fmt = makeRBNF(URBNF_ORDINAL, fLocale, style, ec);
1752         break;
1753     case 5: // duration
1754         formattableType = Formattable::kDouble;
1755         fmt = makeRBNF(URBNF_DURATION, fLocale, style, ec);
1756         break;
1757     default:
1758         formattableType = Formattable::kString;
1759         ec = U_ILLEGAL_ARGUMENT_ERROR;
1760         break;
</pre>
</td>
<td>
<hr />
<pre>
 793             Format* new_format = newFormat.clone();
 794             if (new_format == NULL) {
 795                 status = U_MEMORY_ALLOCATION_ERROR;
 796                 return;
 797             }
 798             setCustomArgStartFormat(partIndex, new_format, status);
 799         }
 800     }
 801 }
 802 
 803 // -------------------------------------
 804 // Gets the format array.
 805 const Format**
 806 MessageFormat::getFormats(int32_t&amp; cnt) const
 807 {
 808     // This old API returns an array (which we hold) of Format*
 809     // pointers.  The array is valid up to the next call to any
 810     // method on this object.  We construct and resize an array
 811     // on demand that contains aliases to the subformats[i].format
 812     // pointers.
<span class="line-added"> 813 </span>
<span class="line-added"> 814     // Get total required capacity first (it&#39;s refreshed on each call).</span>
<span class="line-added"> 815     int32_t totalCapacity = 0;</span>
<span class="line-added"> 816     for (int32_t partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0; ++totalCapacity) {};</span>
<span class="line-added"> 817 </span>
 818     MessageFormat* t = const_cast&lt;MessageFormat*&gt; (this);
 819     cnt = 0;
<span class="line-modified"> 820     if (formatAliases == nullptr) {</span>
<span class="line-modified"> 821         t-&gt;formatAliasesCapacity = totalCapacity;</span>
 822         Format** a = (Format**)
 823             uprv_malloc(sizeof(Format*) * formatAliasesCapacity);
<span class="line-modified"> 824         if (a == nullptr) {</span>
 825             t-&gt;formatAliasesCapacity = 0;
<span class="line-modified"> 826             return nullptr;</span>
 827         }
 828         t-&gt;formatAliases = a;
<span class="line-modified"> 829     } else if (totalCapacity &gt; formatAliasesCapacity) {</span>
 830         Format** a = (Format**)
<span class="line-modified"> 831             uprv_realloc(formatAliases, sizeof(Format*) * totalCapacity);</span>
<span class="line-modified"> 832         if (a == nullptr) {</span>
 833             t-&gt;formatAliasesCapacity = 0;
<span class="line-modified"> 834             return nullptr;</span>
 835         }
 836         t-&gt;formatAliases = a;
<span class="line-modified"> 837         t-&gt;formatAliasesCapacity = totalCapacity;</span>
 838     }
 839 
 840     for (int32_t partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0;) {
 841         t-&gt;formatAliases[cnt++] = getCachedFormatter(partIndex);
 842     }
 843 
 844     return (const Format**)formatAliases;
 845 }
 846 
 847 
 848 UnicodeString MessageFormat::getArgName(int32_t partIndex) {
 849     const MessagePattern::Part&amp; part = msgPattern.getPart(partIndex);
 850     return msgPattern.getSubstring(part);
 851 }
 852 
 853 StringEnumeration*
 854 MessageFormat::getFormatNames(UErrorCode&amp; status) {
 855     if (U_FAILURE(status))  return NULL;
 856 
 857     UVector *fFormatNames = new UVector(status);
</pre>
<hr />
<pre>
1066         int32_t prevDestLength = appendTo.length();
1067         const Format* formatter = NULL;
1068         if (noArg) {
1069             appendTo.append(
1070                 UnicodeString(LEFT_CURLY_BRACE).append(argName).append(RIGHT_CURLY_BRACE));
1071         } else if (arg == NULL) {
1072             appendTo.append(NULL_STRING, 4);
1073         } else if(plNumber!=NULL &amp;&amp;
1074                 static_cast&lt;const PluralSelectorContext *&gt;(plNumber)-&gt;numberArgIndex==(i-2)) {
1075             const PluralSelectorContext &amp;pluralNumber =
1076                 *static_cast&lt;const PluralSelectorContext *&gt;(plNumber);
1077             if(pluralNumber.offset == 0) {
1078                 // The number was already formatted with this formatter.
1079                 appendTo.formatAndAppend(pluralNumber.formatter, pluralNumber.number,
1080                                          pluralNumber.numberString, success);
1081             } else {
1082                 // Do not use the formatted (number-offset) string for a named argument
1083                 // that formats the number without subtracting the offset.
1084                 appendTo.formatAndAppend(pluralNumber.formatter, *arg, success);
1085             }
<span class="line-modified">1086         } else if ((formatter = getCachedFormatter(i -2)) != 0) {</span>
1087             // Handles all ArgType.SIMPLE, and formatters from setFormat() and its siblings.
1088             if (dynamic_cast&lt;const ChoiceFormat*&gt;(formatter) ||
1089                 dynamic_cast&lt;const PluralFormat*&gt;(formatter) ||
1090                 dynamic_cast&lt;const SelectFormat*&gt;(formatter)) {
1091                 // We only handle nested formats here if they were provided via
1092                 // setFormat() or its siblings. Otherwise they are not cached and instead
1093                 // handled below according to argType.
1094                 UnicodeString subMsgString;
1095                 formatter-&gt;format(*arg, subMsgString, success);
1096                 if (subMsgString.indexOf(LEFT_CURLY_BRACE) &gt;= 0 ||
1097                     (subMsgString.indexOf(SINGLE_QUOTE) &gt;= 0 &amp;&amp; !MessageImpl::jdkAposMode(msgPattern))
1098                 ) {
1099                     MessageFormat subMsgFormat(subMsgString, fLocale, success);
1100                     subMsgFormat.format(0, NULL, arguments, argumentNames, cnt, appendTo, ignore, success);
1101                 } else {
1102                     appendTo.append(subMsgString);
1103                 }
1104             } else {
1105                 appendTo.formatAndAppend(formatter, *arg, success);
1106             }
</pre>
<hr />
<pre>
1661         case UMSGPAT_ARG_TYPE_SELECTORDINAL:
1662             formattableType = Formattable::kDouble;
1663             break;
1664         case UMSGPAT_ARG_TYPE_SELECT:
1665             formattableType = Formattable::kString;
1666             break;
1667         default:
1668             status = U_INTERNAL_PROGRAM_ERROR;  // Should be unreachable.
1669             formattableType = Formattable::kString;
1670             break;
1671         }
1672         if (argNumber != -1) {
1673             if (argTypes[argNumber] != Formattable::kObject &amp;&amp; argTypes[argNumber] != formattableType) {
1674                 hasArgTypeConflicts = TRUE;
1675             }
1676             argTypes[argNumber] = formattableType;
1677         }
1678     }
1679 }
1680 

1681 Format* MessageFormat::createAppropriateFormat(UnicodeString&amp; type, UnicodeString&amp; style,
1682                                                Formattable::Type&amp; formattableType, UParseError&amp; parseError,
1683                                                UErrorCode&amp; ec) {
1684     if (U_FAILURE(ec)) {
1685         return NULL;
1686     }
1687     Format* fmt = NULL;
1688     int32_t typeID, styleID;
1689     DateFormat::EStyle date_style;
<span class="line-added">1690     int32_t firstNonSpace;</span>
1691 
1692     switch (typeID = findKeyword(type, TYPE_IDS)) {
1693     case 0: // number
1694         formattableType = Formattable::kDouble;
1695         switch (findKeyword(style, NUMBER_STYLE_IDS)) {
1696         case 0: // default
1697             fmt = NumberFormat::createInstance(fLocale, ec);
1698             break;
1699         case 1: // currency
1700             fmt = NumberFormat::createCurrencyInstance(fLocale, ec);
1701             break;
1702         case 2: // percent
1703             fmt = NumberFormat::createPercentInstance(fLocale, ec);
1704             break;
1705         case 3: // integer
1706             formattableType = Formattable::kLong;
1707             fmt = createIntegerFormat(fLocale, ec);
1708             break;
1709         default: // pattern or skeleton
<span class="line-modified">1710             firstNonSpace = PatternProps::skipWhiteSpace(style, 0);</span>
<span class="line-modified">1711             if (style.compare(firstNonSpace, 2, u&quot;::&quot;, 0, 2) == 0) {</span>

1712                 // Skeleton
<span class="line-modified">1713                 UnicodeString skeleton = style.tempSubString(firstNonSpace + 2);</span>
1714                 fmt = number::NumberFormatter::forSkeleton(skeleton, ec).locale(fLocale).toFormat(ec);
1715             } else {
1716                 // Pattern
1717                 fmt = NumberFormat::createInstance(fLocale, ec);
1718                 if (fmt) {
1719                     auto* decfmt = dynamic_cast&lt;DecimalFormat*&gt;(fmt);
1720                     if (decfmt != nullptr) {
1721                         decfmt-&gt;applyPattern(style, parseError, ec);
1722                     }
1723                 }
1724             }
1725             break;
1726         }
1727         break;
1728 
1729     case 1: // date
1730     case 2: // time
1731         formattableType = Formattable::kDate;
<span class="line-modified">1732         firstNonSpace = PatternProps::skipWhiteSpace(style, 0);</span>
<span class="line-modified">1733         if (style.compare(firstNonSpace, 2, u&quot;::&quot;, 0, 2) == 0) {</span>
<span class="line-modified">1734             // Skeleton</span>
<span class="line-modified">1735             UnicodeString skeleton = style.tempSubString(firstNonSpace + 2);</span>
<span class="line-modified">1736             fmt = DateFormat::createInstanceForSkeleton(skeleton, fLocale, ec);</span>
1737         } else {
<span class="line-modified">1738             // Pattern</span>
<span class="line-modified">1739             styleID = findKeyword(style, DATE_STYLE_IDS);</span>
<span class="line-added">1740             date_style = (styleID &gt;= 0) ? DATE_STYLES[styleID] : DateFormat::kDefault;</span>
1741 
<span class="line-modified">1742             if (typeID == 1) {</span>
<span class="line-modified">1743                 fmt = DateFormat::createDateInstance(date_style, fLocale);</span>
<span class="line-modified">1744             } else {</span>
<span class="line-modified">1745                 fmt = DateFormat::createTimeInstance(date_style, fLocale);</span>
<span class="line-added">1746             }</span>
<span class="line-added">1747 </span>
<span class="line-added">1748             if (styleID &lt; 0 &amp;&amp; fmt != NULL) {</span>
<span class="line-added">1749                 SimpleDateFormat* sdtfmt = dynamic_cast&lt;SimpleDateFormat*&gt;(fmt);</span>
<span class="line-added">1750                 if (sdtfmt != NULL) {</span>
<span class="line-added">1751                     sdtfmt-&gt;applyPattern(style);</span>
<span class="line-added">1752                 }</span>
1753             }
1754         }
1755         break;
1756 
1757     case 3: // spellout
1758         formattableType = Formattable::kDouble;
1759         fmt = makeRBNF(URBNF_SPELLOUT, fLocale, style, ec);
1760         break;
1761     case 4: // ordinal
1762         formattableType = Formattable::kDouble;
1763         fmt = makeRBNF(URBNF_ORDINAL, fLocale, style, ec);
1764         break;
1765     case 5: // duration
1766         formattableType = Formattable::kDouble;
1767         fmt = makeRBNF(URBNF_DURATION, fLocale, style, ec);
1768         break;
1769     default:
1770         formattableType = Formattable::kString;
1771         ec = U_ILLEGAL_ARGUMENT_ERROR;
1772         break;
</pre>
</td>
</tr>
</table>
<center><a href="measunit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="nfrule.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>