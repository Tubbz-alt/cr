<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/measfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="japancal.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="measunit.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/measfmt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,22 ***</span>
  #include &quot;unicode/listformatter.h&quot;
  #include &quot;charstr.h&quot;
  #include &quot;unicode/putil.h&quot;
  #include &quot;unicode/smpdtfmt.h&quot;
  #include &quot;uassert.h&quot;
  
  #include &quot;sharednumberformat.h&quot;
  #include &quot;sharedpluralrules.h&quot;
  #include &quot;standardplural.h&quot;
  #include &quot;unifiedcache.h&quot;
<span class="line-removed">- static constexpr int32_t PER_UNIT_INDEX = StandardPlural::COUNT;</span>
<span class="line-removed">- static constexpr int32_t PATTERN_COUNT = PER_UNIT_INDEX + 1;</span>
<span class="line-removed">- static constexpr int32_t MEAS_UNIT_COUNT = 138;  // see assertion in MeasureFormatCacheData constructor</span>
  static constexpr int32_t WIDTH_INDEX_COUNT = UMEASFMT_WIDTH_NARROW + 1;
  
  UOBJECT_DEFINE_RTTI_IMPLEMENTATION(MeasureFormat)
  
  // Used to format durations like 5:47 or 21:35:42.
<span class="line-new-header">--- 34,21 ---</span>
  #include &quot;unicode/listformatter.h&quot;
  #include &quot;charstr.h&quot;
  #include &quot;unicode/putil.h&quot;
  #include &quot;unicode/smpdtfmt.h&quot;
  #include &quot;uassert.h&quot;
<span class="line-added">+ #include &quot;unicode/numberformatter.h&quot;</span>
<span class="line-added">+ #include &quot;number_longnames.h&quot;</span>
  
  #include &quot;sharednumberformat.h&quot;
  #include &quot;sharedpluralrules.h&quot;
  #include &quot;standardplural.h&quot;
  #include &quot;unifiedcache.h&quot;
  static constexpr int32_t WIDTH_INDEX_COUNT = UMEASFMT_WIDTH_NARROW + 1;
  
  UOBJECT_DEFINE_RTTI_IMPLEMENTATION(MeasureFormat)
  
  // Used to format durations like 5:47 or 21:35:42.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,10 ***</span>
<span class="line-new-header">--- 88,23 ---</span>
          return UMEASFMT_WIDTH_NARROW;
      }
      return width;
  }
  
<span class="line-added">+ static UNumberUnitWidth getUnitWidth(UMeasureFormatWidth width) {</span>
<span class="line-added">+     switch (width) {</span>
<span class="line-added">+     case UMEASFMT_WIDTH_WIDE:</span>
<span class="line-added">+         return UNUM_UNIT_WIDTH_FULL_NAME;</span>
<span class="line-added">+     case UMEASFMT_WIDTH_NARROW:</span>
<span class="line-added">+     case UMEASFMT_WIDTH_NUMERIC:</span>
<span class="line-added">+         return UNUM_UNIT_WIDTH_NARROW;</span>
<span class="line-added">+     case UMEASFMT_WIDTH_SHORT:</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         return UNUM_UNIT_WIDTH_SHORT;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /**
   * Instances contain all MeasureFormat specific data for a particular locale.
   * This data is cached. It is never copied, but is shared via shared pointers.
   *
   * Note: We might change the cache data to have an array[WIDTH_INDEX_COUNT] of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,24 ***</span>
       * Redirection data from root-bundle, top-level sideways aliases.
       * - UMEASFMT_WIDTH_COUNT: initial value, just fall back to root
       * - UMEASFMT_WIDTH_WIDE/SHORT/NARROW: sideways alias for missing data
       */
      UMeasureFormatWidth widthFallback[WIDTH_INDEX_COUNT];
<span class="line-removed">-     /** Measure unit -&gt; format width -&gt; array of patterns (&quot;{0} meters&quot;) (plurals + PER_UNIT_INDEX) */</span>
<span class="line-removed">-     SimpleFormatter* patterns[MEAS_UNIT_COUNT][WIDTH_INDEX_COUNT][PATTERN_COUNT];</span>
<span class="line-removed">-     const UChar* dnams[MEAS_UNIT_COUNT][WIDTH_INDEX_COUNT];</span>
<span class="line-removed">-     SimpleFormatter perFormatters[WIDTH_INDEX_COUNT];</span>
  
      MeasureFormatCacheData();
      virtual ~MeasureFormatCacheData();
  
<span class="line-removed">-     UBool hasPerFormatter(int32_t width) const {</span>
<span class="line-removed">-         // TODO: Create a more obvious way to test if the per-formatter has been set?</span>
<span class="line-removed">-         // Use pointers, check for NULL? Or add an isValid() method?</span>
<span class="line-removed">-         return perFormatters[width].getArgumentLimit() == 2;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      void adoptCurrencyFormat(int32_t widthIndex, NumberFormat *nfToAdopt) {
          delete currencyFormats[widthIndex];
          currencyFormats[widthIndex] = nfToAdopt;
      }
      const NumberFormat *getCurrencyFormat(UMeasureFormatWidth width) const {
<span class="line-new-header">--- 120,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,32 ***</span>
      MeasureFormatCacheData &amp;operator=(const MeasureFormatCacheData &amp;other);
  };
  
  MeasureFormatCacheData::MeasureFormatCacheData()
          : integerFormat(nullptr), numericDateFormatters(nullptr) {
<span class="line-removed">-     // Please update MEAS_UNIT_COUNT if it gets out of sync with the true count!</span>
<span class="line-removed">-     U_ASSERT(MEAS_UNIT_COUNT == MeasureUnit::getIndexCount());</span>
<span class="line-removed">- </span>
      for (int32_t i = 0; i &lt; WIDTH_INDEX_COUNT; ++i) {
          widthFallback[i] = UMEASFMT_WIDTH_COUNT;
      }
<span class="line-removed">-     memset(&amp;patterns[0][0][0], 0, sizeof(patterns));</span>
<span class="line-removed">-     memset(&amp;dnams[0][0], 0, sizeof(dnams));</span>
      memset(currencyFormats, 0, sizeof(currencyFormats));
  }
  
  MeasureFormatCacheData::~MeasureFormatCacheData() {
      for (int32_t i = 0; i &lt; UPRV_LENGTHOF(currencyFormats); ++i) {
<span class="line-removed">-     for (int32_t i = 0; i &lt; MEAS_UNIT_COUNT; ++i) {</span>
<span class="line-removed">-         for (int32_t j = 0; j &lt; WIDTH_INDEX_COUNT; ++j) {</span>
<span class="line-removed">-             for (int32_t k = 0; k &lt; PATTERN_COUNT; ++k) {</span>
<span class="line-removed">-                 delete patterns[i][j][k];</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
      // Note: the contents of &#39;dnams&#39; are pointers into the resource bundle
      delete integerFormat;
      delete numericDateFormatters;
  }
  
<span class="line-new-header">--- 157,20 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,254 ***</span>
      }
      result.setTo(TRUE, resStr, len);
      return TRUE;
  }
  
<span class="line-removed">- namespace {</span>
<span class="line-removed">- </span>
<span class="line-removed">- static const UChar g_LOCALE_units[] = {</span>
<span class="line-removed">-     0x2F, 0x4C, 0x4F, 0x43, 0x41, 0x4C, 0x45, 0x2F,</span>
<span class="line-removed">-     0x75, 0x6E, 0x69, 0x74, 0x73</span>
<span class="line-removed">- };</span>
<span class="line-removed">- static const UChar gShort[] = { 0x53, 0x68, 0x6F, 0x72, 0x74 };</span>
<span class="line-removed">- static const UChar gNarrow[] = { 0x4E, 0x61, 0x72, 0x72, 0x6F, 0x77 };</span>
<span class="line-removed">- </span>
<span class="line-removed">- /**</span>
<span class="line-removed">-  * Sink for enumerating all of the measurement unit display names.</span>
<span class="line-removed">-  * Contains inner sink classes, each one corresponding to a type of resource table.</span>
<span class="line-removed">-  * The outer sink handles the top-level units, unitsNarrow, and unitsShort tables.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * More specific bundles (en_GB) are enumerated before their parents (en_001, en, root):</span>
<span class="line-removed">-  * Only store a value if it is still missing, that is, it has not been overridden.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * C++: Each inner sink class has a reference to the main outer sink.</span>
<span class="line-removed">-  * Java: Use non-static inner classes instead.</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- struct UnitDataSink : public ResourceSink {</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Output data.</span>
<span class="line-removed">-     MeasureFormatCacheData &amp;cacheData;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Path to current data.</span>
<span class="line-removed">-     UMeasureFormatWidth width;</span>
<span class="line-removed">-     const char *type;</span>
<span class="line-removed">-     int32_t unitIndex;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     UnitDataSink(MeasureFormatCacheData &amp;outputData)</span>
<span class="line-removed">-             : cacheData(outputData),</span>
<span class="line-removed">-               width(UMEASFMT_WIDTH_COUNT), type(NULL), unitIndex(0) {}</span>
<span class="line-removed">-     ~UnitDataSink();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void setFormatterIfAbsent(int32_t index, const ResourceValue &amp;value,</span>
<span class="line-removed">-                                 int32_t minPlaceholders, UErrorCode &amp;errorCode) {</span>
<span class="line-removed">-         U_ASSERT(unitIndex &lt; MEAS_UNIT_COUNT);</span>
<span class="line-removed">-         U_ASSERT(width &lt; WIDTH_INDEX_COUNT);</span>
<span class="line-removed">-         U_ASSERT(index &lt; PATTERN_COUNT);</span>
<span class="line-removed">-         SimpleFormatter **patterns = &amp;cacheData.patterns[unitIndex][width][0];</span>
<span class="line-removed">-         if (U_SUCCESS(errorCode) &amp;&amp; patterns[index] == NULL) {</span>
<span class="line-removed">-             if (minPlaceholders &gt;= 0) {</span>
<span class="line-removed">-                 patterns[index] = new SimpleFormatter(</span>
<span class="line-removed">-                         value.getUnicodeString(errorCode), minPlaceholders, 1, errorCode);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (U_SUCCESS(errorCode) &amp;&amp; patterns[index] == NULL) {</span>
<span class="line-removed">-                 errorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void setDnamIfAbsent(const ResourceValue &amp;value, UErrorCode&amp; errorCode) {</span>
<span class="line-removed">-         U_ASSERT(unitIndex &lt; MEAS_UNIT_COUNT);</span>
<span class="line-removed">-         U_ASSERT(width &lt; WIDTH_INDEX_COUNT);</span>
<span class="line-removed">-         if (cacheData.dnams[unitIndex][width] == NULL) {</span>
<span class="line-removed">-             int32_t length;</span>
<span class="line-removed">-             cacheData.dnams[unitIndex][width] = value.getString(length, errorCode);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Consume a display pattern. For example,</span>
<span class="line-removed">-      * unitsShort/duration/hour contains other{&quot;{0} hrs&quot;}.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     void consumePattern(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed">-         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed">-         if (uprv_strcmp(key, &quot;dnam&quot;) == 0) {</span>
<span class="line-removed">-             // The display name for the unit in the current width.</span>
<span class="line-removed">-             setDnamIfAbsent(value, errorCode);</span>
<span class="line-removed">-         } else if (uprv_strcmp(key, &quot;per&quot;) == 0) {</span>
<span class="line-removed">-             // For example, &quot;{0}/h&quot;.</span>
<span class="line-removed">-             setFormatterIfAbsent(PER_UNIT_INDEX, value, 1, errorCode);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             // The key must be one of the plural form strings. For example:</span>
<span class="line-removed">-             // one{&quot;{0} hr&quot;}</span>
<span class="line-removed">-             // other{&quot;{0} hrs&quot;}</span>
<span class="line-removed">-             setFormatterIfAbsent(StandardPlural::indexFromString(key, errorCode), value, 0,</span>
<span class="line-removed">-                                     errorCode);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Consume a table of per-unit tables. For example,</span>
<span class="line-removed">-      * unitsShort/duration contains tables for duration-unit subtypes day &amp; hour.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     void consumeSubtypeTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed">-         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed">-         unitIndex = MeasureUnit::internalGetIndexForTypeAndSubtype(type, key);</span>
<span class="line-removed">-         if (unitIndex &lt; 0) {</span>
<span class="line-removed">-             // TODO: How to handle unexpected data?</span>
<span class="line-removed">-             // See http://bugs.icu-project.org/trac/ticket/12597</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // We no longer handle units like &quot;coordinate&quot; here (which do not have plural variants)</span>
<span class="line-removed">-         if (value.getType() == URES_TABLE) {</span>
<span class="line-removed">-             // Units that have plural variants</span>
<span class="line-removed">-             ResourceTable patternTableTable = value.getTable(errorCode);</span>
<span class="line-removed">-             if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed">-             for (int i = 0; patternTableTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed">-                 consumePattern(key, value, errorCode);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             // TODO: How to handle unexpected data?</span>
<span class="line-removed">-             // See http://bugs.icu-project.org/trac/ticket/12597</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Consume compound x-per-y display pattern. For example,</span>
<span class="line-removed">-      * unitsShort/compound/per may be &quot;{0}/{1}&quot;.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     void consumeCompoundPattern(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed">-         if (U_SUCCESS(errorCode) &amp;&amp; uprv_strcmp(key, &quot;per&quot;) == 0) {</span>
<span class="line-removed">-             cacheData.perFormatters[width].</span>
<span class="line-removed">-                     applyPatternMinMaxArguments(value.getUnicodeString(errorCode), 2, 2, errorCode);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Consume a table of unit type tables. For example,</span>
<span class="line-removed">-      * unitsShort contains tables for area &amp; duration.</span>
<span class="line-removed">-      * It also contains a table for the compound/per pattern.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     void consumeUnitTypesTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed">-         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed">-         if (uprv_strcmp(key, &quot;currency&quot;) == 0) {</span>
<span class="line-removed">-             // Skip.</span>
<span class="line-removed">-         } else if (uprv_strcmp(key, &quot;compound&quot;) == 0) {</span>
<span class="line-removed">-             if (!cacheData.hasPerFormatter(width)) {</span>
<span class="line-removed">-                 ResourceTable compoundTable = value.getTable(errorCode);</span>
<span class="line-removed">-                 if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed">-                 for (int i = 0; compoundTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed">-                     consumeCompoundPattern(key, value, errorCode);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else if (uprv_strcmp(key, &quot;coordinate&quot;) == 0) {</span>
<span class="line-removed">-             // special handling but we need to determine what that is</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             type = key;</span>
<span class="line-removed">-             ResourceTable subtypeTable = value.getTable(errorCode);</span>
<span class="line-removed">-             if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed">-             for (int i = 0; subtypeTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed">-                 consumeSubtypeTable(key, value, errorCode);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void consumeAlias(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed">-         // Handle aliases like</span>
<span class="line-removed">-         // units:alias{&quot;/LOCALE/unitsShort&quot;}</span>
<span class="line-removed">-         // which should only occur in the root bundle.</span>
<span class="line-removed">-         UMeasureFormatWidth sourceWidth = widthFromKey(key);</span>
<span class="line-removed">-         if (sourceWidth == UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed">-             // Alias from something we don&#39;t care about.</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         UMeasureFormatWidth targetWidth = widthFromAlias(value, errorCode);</span>
<span class="line-removed">-         if (targetWidth == UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed">-             // We do not recognize what to fall back to.</span>
<span class="line-removed">-             errorCode = U_INVALID_FORMAT_ERROR;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // Check that we do not fall back to another fallback.</span>
<span class="line-removed">-         if (cacheData.widthFallback[targetWidth] != UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed">-             errorCode = U_INVALID_FORMAT_ERROR;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         cacheData.widthFallback[sourceWidth] = targetWidth;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void consumeTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed">-         if (U_SUCCESS(errorCode) &amp;&amp; (width = widthFromKey(key)) != UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed">-             ResourceTable unitTypesTable = value.getTable(errorCode);</span>
<span class="line-removed">-             if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed">-             for (int i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed">-                 consumeUnitTypesTable(key, value, errorCode);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static UMeasureFormatWidth widthFromKey(const char *key) {</span>
<span class="line-removed">-         if (uprv_strncmp(key, &quot;units&quot;, 5) == 0) {</span>
<span class="line-removed">-             key += 5;</span>
<span class="line-removed">-             if (*key == 0) {</span>
<span class="line-removed">-                 return UMEASFMT_WIDTH_WIDE;</span>
<span class="line-removed">-             } else if (uprv_strcmp(key, &quot;Short&quot;) == 0) {</span>
<span class="line-removed">-                 return UMEASFMT_WIDTH_SHORT;</span>
<span class="line-removed">-             } else if (uprv_strcmp(key, &quot;Narrow&quot;) == 0) {</span>
<span class="line-removed">-                 return UMEASFMT_WIDTH_NARROW;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return UMEASFMT_WIDTH_COUNT;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static UMeasureFormatWidth widthFromAlias(const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed">-         int32_t length;</span>
<span class="line-removed">-         const UChar *s = value.getAliasString(length, errorCode);</span>
<span class="line-removed">-         // For example: &quot;/LOCALE/unitsShort&quot;</span>
<span class="line-removed">-         if (U_SUCCESS(errorCode) &amp;&amp; length &gt;= 13 &amp;&amp; u_memcmp(s, g_LOCALE_units, 13) == 0) {</span>
<span class="line-removed">-             s += 13;</span>
<span class="line-removed">-             length -= 13;</span>
<span class="line-removed">-             if (*s == 0) {</span>
<span class="line-removed">-                 return UMEASFMT_WIDTH_WIDE;</span>
<span class="line-removed">-             } else if (u_strCompare(s, length, gShort, 5, FALSE) == 0) {</span>
<span class="line-removed">-                 return UMEASFMT_WIDTH_SHORT;</span>
<span class="line-removed">-             } else if (u_strCompare(s, length, gNarrow, 6, FALSE) == 0) {</span>
<span class="line-removed">-                 return UMEASFMT_WIDTH_NARROW;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return UMEASFMT_WIDTH_COUNT;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,</span>
<span class="line-removed">-             UErrorCode &amp;errorCode) {</span>
<span class="line-removed">-         // Main entry point to sink</span>
<span class="line-removed">-         ResourceTable widthsTable = value.getTable(errorCode);</span>
<span class="line-removed">-         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed">-         for (int i = 0; widthsTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed">-             if (value.getType() == URES_ALIAS) {</span>
<span class="line-removed">-                 consumeAlias(key, value, errorCode);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 consumeTable(key, value, errorCode);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Virtual destructors must be defined out of line.</span>
<span class="line-removed">- UnitDataSink::~UnitDataSink() {}</span>
<span class="line-removed">- </span>
<span class="line-removed">- }  // namespace</span>
<span class="line-removed">- </span>
<span class="line-removed">- static UBool loadMeasureUnitData(</span>
<span class="line-removed">-         const UResourceBundle *resource,</span>
<span class="line-removed">-         MeasureFormatCacheData &amp;cacheData,</span>
<span class="line-removed">-         UErrorCode &amp;status) {</span>
<span class="line-removed">-     UnitDataSink sink(cacheData);</span>
<span class="line-removed">-     ures_getAllItemsWithFallback(resource, &quot;&quot;, sink, status);</span>
<span class="line-removed">-     return U_SUCCESS(status);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static UnicodeString loadNumericDateFormatterPattern(
          const UResourceBundle *resource,
          const char *pattern,
          UErrorCode &amp;status) {
      UnicodeString result;
<span class="line-new-header">--- 189,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 505,16 ***</span>
              UNUM_CURRENCY_PLURAL, UNUM_CURRENCY_ISO, UNUM_CURRENCY};
      LocalPointer&lt;MeasureFormatCacheData&gt; result(new MeasureFormatCacheData(), status);
      if (U_FAILURE(status)) {
          return NULL;
      }
<span class="line-removed">-     if (!loadMeasureUnitData(</span>
<span class="line-removed">-             unitsBundle.getAlias(),</span>
<span class="line-removed">-             *result,</span>
<span class="line-removed">-             status)) {</span>
<span class="line-removed">-         return NULL;</span>
<span class="line-removed">-     }</span>
      result-&gt;adoptNumericDateFormatters(loadNumericDateFormatters(
              unitsBundle.getAlias(), status));
      if (U_FAILURE(status)) {
          return NULL;
      }
<span class="line-new-header">--- 251,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 616,11 ***</span>
  MeasureFormat::MeasureFormat(
          const Locale &amp;locale, UMeasureFormatWidth w, UErrorCode &amp;status)
          : cache(NULL),
            numberFormat(NULL),
            pluralRules(NULL),
<span class="line-modified">!           width(w),</span>
            listFormatter(NULL) {
      initMeasureFormat(locale, w, NULL, status);
  }
  
  MeasureFormat::MeasureFormat(
<span class="line-new-header">--- 356,11 ---</span>
  MeasureFormat::MeasureFormat(
          const Locale &amp;locale, UMeasureFormatWidth w, UErrorCode &amp;status)
          : cache(NULL),
            numberFormat(NULL),
            pluralRules(NULL),
<span class="line-modified">!           fWidth(w),</span>
            listFormatter(NULL) {
      initMeasureFormat(locale, w, NULL, status);
  }
  
  MeasureFormat::MeasureFormat(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 629,21 ***</span>
          NumberFormat *nfToAdopt,
          UErrorCode &amp;status)
          : cache(NULL),
            numberFormat(NULL),
            pluralRules(NULL),
<span class="line-modified">!           width(w),</span>
            listFormatter(NULL) {
      initMeasureFormat(locale, w, nfToAdopt, status);
  }
  
  MeasureFormat::MeasureFormat(const MeasureFormat &amp;other) :
          Format(other),
          cache(other.cache),
          numberFormat(other.numberFormat),
          pluralRules(other.pluralRules),
<span class="line-modified">!         width(other.width),</span>
          listFormatter(NULL) {
      cache-&gt;addRef();
      numberFormat-&gt;addRef();
      pluralRules-&gt;addRef();
      if (other.listFormatter != NULL) {
<span class="line-new-header">--- 369,21 ---</span>
          NumberFormat *nfToAdopt,
          UErrorCode &amp;status)
          : cache(NULL),
            numberFormat(NULL),
            pluralRules(NULL),
<span class="line-modified">!           fWidth(w),</span>
            listFormatter(NULL) {
      initMeasureFormat(locale, w, nfToAdopt, status);
  }
  
  MeasureFormat::MeasureFormat(const MeasureFormat &amp;other) :
          Format(other),
          cache(other.cache),
          numberFormat(other.numberFormat),
          pluralRules(other.pluralRules),
<span class="line-modified">!         fWidth(other.fWidth),</span>
          listFormatter(NULL) {
      cache-&gt;addRef();
      numberFormat-&gt;addRef();
      pluralRules-&gt;addRef();
      if (other.listFormatter != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 657,11 ***</span>
      }
      Format::operator=(other);
      SharedObject::copyPtr(other.cache, cache);
      SharedObject::copyPtr(other.numberFormat, numberFormat);
      SharedObject::copyPtr(other.pluralRules, pluralRules);
<span class="line-modified">!     width = other.width;</span>
      delete listFormatter;
      if (other.listFormatter != NULL) {
          listFormatter = new ListFormatter(*other.listFormatter);
      } else {
          listFormatter = NULL;
<span class="line-new-header">--- 397,11 ---</span>
      }
      Format::operator=(other);
      SharedObject::copyPtr(other.cache, cache);
      SharedObject::copyPtr(other.numberFormat, numberFormat);
      SharedObject::copyPtr(other.pluralRules, pluralRules);
<span class="line-modified">!     fWidth = other.fWidth;</span>
      delete listFormatter;
      if (other.listFormatter != NULL) {
          listFormatter = new ListFormatter(*other.listFormatter);
      } else {
          listFormatter = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 671,11 ***</span>
  
  MeasureFormat::MeasureFormat() :
          cache(NULL),
          numberFormat(NULL),
          pluralRules(NULL),
<span class="line-modified">!         width(UMEASFMT_WIDTH_SHORT),</span>
          listFormatter(NULL) {
  }
  
  MeasureFormat::~MeasureFormat() {
      if (cache != NULL) {
<span class="line-new-header">--- 411,11 ---</span>
  
  MeasureFormat::MeasureFormat() :
          cache(NULL),
          numberFormat(NULL),
          pluralRules(NULL),
<span class="line-modified">!         fWidth(UMEASFMT_WIDTH_SHORT),</span>
          listFormatter(NULL) {
  }
  
  MeasureFormat::~MeasureFormat() {
      if (cache != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 701,11 ***</span>
  
      // Note: Since the ListFormatter depends only on Locale and width, we
      // don&#39;t have to check it here.
  
      // differing widths aren&#39;t equivalent
<span class="line-modified">!     if (width != rhs.width) {</span>
          return FALSE;
      }
      // Width the same check locales.
      // We don&#39;t need to check locales if both objects have same cache.
      if (cache != rhs.cache) {
<span class="line-new-header">--- 441,11 ---</span>
  
      // Note: Since the ListFormatter depends only on Locale and width, we
      // don&#39;t have to check it here.
  
      // differing widths aren&#39;t equivalent
<span class="line-modified">!     if (fWidth != rhs.fWidth) {</span>
          return FALSE;
      }
      // Width the same check locales.
      // We don&#39;t need to check locales if both objects have same cache.
      if (cache != rhs.cache) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,33 ***</span>
          FieldPosition &amp;pos,
          UErrorCode &amp;status) const {
      if (U_FAILURE(status)) {
          return appendTo;
      }
<span class="line-modified">!     bool isResolved = false;</span>
<span class="line-modified">!     MeasureUnit resolvedUnit =</span>
<span class="line-modified">!         MeasureUnit::resolveUnitPerUnit(measure.getUnit(), perUnit, &amp;isResolved);</span>
<span class="line-modified">!     if (isResolved) {</span>
<span class="line-removed">-         Measure newMeasure(measure.getNumber(), new MeasureUnit(resolvedUnit), status);</span>
<span class="line-removed">-         return formatMeasure(</span>
<span class="line-removed">-                 newMeasure, **numberFormat, appendTo, pos, status);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     FieldPosition fpos(pos.getField());</span>
<span class="line-removed">-     UnicodeString result;</span>
<span class="line-removed">-     int32_t offset = withPerUnitAndAppend(</span>
<span class="line-removed">-             formatMeasure(</span>
<span class="line-removed">-                     measure, **numberFormat, result, fpos, status),</span>
<span class="line-removed">-             perUnit,</span>
<span class="line-removed">-             appendTo,</span>
<span class="line-removed">-             status);</span>
<span class="line-removed">-     if (U_FAILURE(status)) {</span>
          return appendTo;
      }
<span class="line-modified">!     if (fpos.getBeginIndex() != 0 || fpos.getEndIndex() != 0) {</span>
<span class="line-modified">!         pos.setBeginIndex(fpos.getBeginIndex() + offset);</span>
<span class="line-modified">!         pos.setEndIndex(fpos.getEndIndex() + offset);</span>
      }
      return appendTo;
  }
  
  UnicodeString &amp;MeasureFormat::formatMeasures(
          const Measure *measures,
<span class="line-new-header">--- 502,25 ---</span>
          FieldPosition &amp;pos,
          UErrorCode &amp;status) const {
      if (U_FAILURE(status)) {
          return appendTo;
      }
<span class="line-modified">!     auto* df = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;getNumberFormatInternal());</span>
<span class="line-modified">!     if (df == nullptr) {</span>
<span class="line-modified">!         // Don&#39;t know how to handle other types of NumberFormat</span>
<span class="line-modified">!         status = U_UNSUPPORTED_ERROR;</span>
          return appendTo;
      }
<span class="line-modified">!     number::FormattedNumber result;</span>
<span class="line-modified">!     if (auto* lnf = df-&gt;toNumberFormatter(status)) {</span>
<span class="line-modified">!         result = lnf-&gt;unit(measure.getUnit())</span>
<span class="line-added">+             .perUnit(perUnit)</span>
<span class="line-added">+             .unitWidth(getUnitWidth(fWidth))</span>
<span class="line-added">+             .formatDouble(measure.getNumber().getDouble(status), status);</span>
      }
<span class="line-added">+     DecimalFormat::fieldPositionHelper(result, pos, appendTo.length(), status);</span>
<span class="line-added">+     appendTo.append(result.toTempString(status));</span>
      return appendTo;
  }
  
  UnicodeString &amp;MeasureFormat::formatMeasures(
          const Measure *measures,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 803,11 ***</span>
          return appendTo;
      }
      if (measureCount == 1) {
          return formatMeasure(measures[0], **numberFormat, appendTo, pos, status);
      }
<span class="line-modified">!     if (width == UMEASFMT_WIDTH_NUMERIC) {</span>
          Formattable hms[3];
          int32_t bitMap = toHMS(measures, measureCount, hms, status);
          if (bitMap &gt; 0) {
              return formatNumeric(hms, bitMap, appendTo, status);
          }
<span class="line-new-header">--- 535,11 ---</span>
          return appendTo;
      }
      if (measureCount == 1) {
          return formatMeasure(measures[0], **numberFormat, appendTo, pos, status);
      }
<span class="line-modified">!     if (fWidth == UMEASFMT_WIDTH_NUMERIC) {</span>
          Formattable hms[3];
          int32_t bitMap = toHMS(measures, measureCount, hms, status);
          if (bitMap &gt; 0) {
              return formatNumeric(hms, bitMap, appendTo, status);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 836,26 ***</span>
      listFormatter-&gt;format(results, measureCount, appendTo, status);
      delete [] results;
      return appendTo;
  }
  
<span class="line-modified">! UnicodeString MeasureFormat::getUnitDisplayName(const MeasureUnit&amp; unit, UErrorCode&amp; /*status*/) const {</span>
<span class="line-modified">!     UMeasureFormatWidth width = getRegularWidth(this-&gt;width);</span>
<span class="line-modified">!     const UChar* const* styleToDnam = cache-&gt;dnams[unit.getIndex()];</span>
<span class="line-modified">!     const UChar* dnam = styleToDnam[width];</span>
<span class="line-modified">!     if (dnam == NULL) {</span>
<span class="line-modified">!         int32_t fallbackWidth = cache-&gt;widthFallback[width];</span>
<span class="line-removed">-         dnam = styleToDnam[fallbackWidth];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     UnicodeString result;</span>
<span class="line-removed">-     if (dnam == NULL) {</span>
<span class="line-removed">-         result.setToBogus();</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         result.setTo(dnam, -1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return result;</span>
  }
  
  void MeasureFormat::initMeasureFormat(
          const Locale &amp;locale,
          UMeasureFormatWidth w,
<span class="line-new-header">--- 568,16 ---</span>
      listFormatter-&gt;format(results, measureCount, appendTo, status);
      delete [] results;
      return appendTo;
  }
  
<span class="line-modified">! UnicodeString MeasureFormat::getUnitDisplayName(const MeasureUnit&amp; unit, UErrorCode&amp; status) const {</span>
<span class="line-modified">!     return number::impl::LongNameHandler::getUnitDisplayName(</span>
<span class="line-modified">!         getLocale(status),</span>
<span class="line-modified">!         unit,</span>
<span class="line-modified">!         getUnitWidth(fWidth),</span>
<span class="line-modified">!         status);</span>
  }
  
  void MeasureFormat::initMeasureFormat(
          const Locale &amp;locale,
          UMeasureFormatWidth w,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 880,10 ***</span>
<span class="line-new-header">--- 602,11 ---</span>
          return;
      }
      SharedObject::copyPtr(pr, pluralRules);
      pr-&gt;removeRef();
      if (nf.isNull()) {
<span class="line-added">+         // TODO: Clean this up</span>
          const SharedNumberFormat *shared = NumberFormat::createSharedInstance(
                  locale, UNUM_DECIMAL, status);
          if (U_FAILURE(status)) {
              return;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 893,15 ***</span>
          adoptNumberFormat(nf.orphan(), status);
          if (U_FAILURE(status)) {
              return;
          }
      }
<span class="line-modified">!     width = w;</span>
      delete listFormatter;
      listFormatter = ListFormatter::createInstance(
              locale,
<span class="line-modified">!             listStyles[getRegularWidth(width)],</span>
              status);
  }
  
  void MeasureFormat::adoptNumberFormat(
          NumberFormat *nfToAdopt, UErrorCode &amp;status) {
<span class="line-new-header">--- 616,15 ---</span>
          adoptNumberFormat(nf.orphan(), status);
          if (U_FAILURE(status)) {
              return;
          }
      }
<span class="line-modified">!     fWidth = w;</span>
      delete listFormatter;
      listFormatter = ListFormatter::createInstance(
              locale,
<span class="line-modified">!             listStyles[getRegularWidth(fWidth)],</span>
              status);
  }
  
  void MeasureFormat::adoptNumberFormat(
          NumberFormat *nfToAdopt, UErrorCode &amp;status) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 920,18 ***</span>
  
  UBool MeasureFormat::setMeasureFormatLocale(const Locale &amp;locale, UErrorCode &amp;status) {
      if (U_FAILURE(status) || locale == getLocale(status)) {
          return FALSE;
      }
<span class="line-modified">!     initMeasureFormat(locale, width, NULL, status);</span>
      return U_SUCCESS(status);
  }
  
<span class="line-modified">! const NumberFormat &amp;MeasureFormat::getNumberFormat() const {</span>
      return **numberFormat;
  }
  
  const PluralRules &amp;MeasureFormat::getPluralRules() const {
      return **pluralRules;
  }
  
  Locale MeasureFormat::getLocale(UErrorCode &amp;status) const {
<span class="line-new-header">--- 643,22 ---</span>
  
  UBool MeasureFormat::setMeasureFormatLocale(const Locale &amp;locale, UErrorCode &amp;status) {
      if (U_FAILURE(status) || locale == getLocale(status)) {
          return FALSE;
      }
<span class="line-modified">!     initMeasureFormat(locale, fWidth, NULL, status);</span>
      return U_SUCCESS(status);
  }
  
<span class="line-modified">! const NumberFormat &amp;MeasureFormat::getNumberFormatInternal() const {</span>
      return **numberFormat;
  }
  
<span class="line-added">+ const NumberFormat &amp;MeasureFormat::getCurrencyFormatInternal() const {</span>
<span class="line-added">+     return *cache-&gt;getCurrencyFormat(UMEASFMT_WIDTH_NARROW);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  const PluralRules &amp;MeasureFormat::getPluralRules() const {
      return **pluralRules;
  }
  
  Locale MeasureFormat::getLocale(UErrorCode &amp;status) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 954,21 ***</span>
      const Formattable&amp; amtNumber = measure.getNumber();
      const MeasureUnit&amp; amtUnit = measure.getUnit();
      if (isCurrency(amtUnit)) {
          UChar isoCode[4];
          u_charsToUChars(amtUnit.getSubtype(), isoCode, 4);
<span class="line-modified">!         return cache-&gt;getCurrencyFormat(width)-&gt;format(</span>
                  new CurrencyAmount(amtNumber, isoCode, status),
                  appendTo,
                  pos,
                  status);
      }
<span class="line-modified">!     UnicodeString formattedNumber;</span>
<span class="line-modified">!     StandardPlural::Form pluralForm = QuantityFormatter::selectPlural(</span>
<span class="line-modified">!             amtNumber, nf, **pluralRules, formattedNumber, pos, status);</span>
<span class="line-modified">!     const SimpleFormatter *formatter = getPluralFormatter(amtUnit, width, pluralForm, status);</span>
<span class="line-modified">!     return QuantityFormatter::format(*formatter, formattedNumber, appendTo, pos, status);</span>
  }
  
  // Formats hours-minutes-seconds as 5:37:23 or similar.
  UnicodeString &amp;MeasureFormat::formatNumeric(
          const Formattable *hms,  // always length 3
<span class="line-new-header">--- 681,31 ---</span>
      const Formattable&amp; amtNumber = measure.getNumber();
      const MeasureUnit&amp; amtUnit = measure.getUnit();
      if (isCurrency(amtUnit)) {
          UChar isoCode[4];
          u_charsToUChars(amtUnit.getSubtype(), isoCode, 4);
<span class="line-modified">!         return cache-&gt;getCurrencyFormat(fWidth)-&gt;format(</span>
                  new CurrencyAmount(amtNumber, isoCode, status),
                  appendTo,
                  pos,
                  status);
      }
<span class="line-modified">!     auto* df = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;nf);</span>
<span class="line-modified">!     if (df == nullptr) {</span>
<span class="line-modified">!         // Don&#39;t know how to handle other types of NumberFormat</span>
<span class="line-modified">!         status = U_UNSUPPORTED_ERROR;</span>
<span class="line-modified">!         return appendTo;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     number::FormattedNumber result;</span>
<span class="line-added">+     if (auto* lnf = df-&gt;toNumberFormatter(status)) {</span>
<span class="line-added">+         result = lnf-&gt;unit(amtUnit)</span>
<span class="line-added">+             .unitWidth(getUnitWidth(fWidth))</span>
<span class="line-added">+             .formatDouble(amtNumber.getDouble(status), status);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     DecimalFormat::fieldPositionHelper(result, pos, appendTo.length(), status);</span>
<span class="line-added">+     appendTo.append(result.toTempString(status));</span>
<span class="line-added">+     return appendTo;</span>
  }
  
  // Formats hours-minutes-seconds as 5:37:23 or similar.
  UnicodeString &amp;MeasureFormat::formatNumeric(
          const Formattable *hms,  // always length 3
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1014,11 ***</span>
      default:
          status = U_INTERNAL_PROGRAM_ERROR;
          return appendTo;
          break;
      }
<span class="line-removed">-     return appendTo;</span>
  }
  
  static void appendRange(
          const UnicodeString &amp;src,
          int32_t start,
<span class="line-new-header">--- 751,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1100,112 ***</span>
          appendTo.append(draft);
      }
      return appendTo;
  }
  
<span class="line-removed">- const SimpleFormatter *MeasureFormat::getFormatterOrNull(</span>
<span class="line-removed">-         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index) const {</span>
<span class="line-removed">-     width = getRegularWidth(width);</span>
<span class="line-removed">-     SimpleFormatter *const (*unitPatterns)[PATTERN_COUNT] = &amp;cache-&gt;patterns[unit.getIndex()][0];</span>
<span class="line-removed">-     if (unitPatterns[width][index] != NULL) {</span>
<span class="line-removed">-         return unitPatterns[width][index];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     int32_t fallbackWidth = cache-&gt;widthFallback[width];</span>
<span class="line-removed">-     if (fallbackWidth != UMEASFMT_WIDTH_COUNT &amp;&amp; unitPatterns[fallbackWidth][index] != NULL) {</span>
<span class="line-removed">-         return unitPatterns[fallbackWidth][index];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const SimpleFormatter *MeasureFormat::getFormatter(</span>
<span class="line-removed">-         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index,</span>
<span class="line-removed">-         UErrorCode &amp;errorCode) const {</span>
<span class="line-removed">-     if (U_FAILURE(errorCode)) {</span>
<span class="line-removed">-         return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     const SimpleFormatter *pattern = getFormatterOrNull(unit, width, index);</span>
<span class="line-removed">-     if (pattern == NULL) {</span>
<span class="line-removed">-         errorCode = U_MISSING_RESOURCE_ERROR;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return pattern;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const SimpleFormatter *MeasureFormat::getPluralFormatter(</span>
<span class="line-removed">-         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index,</span>
<span class="line-removed">-         UErrorCode &amp;errorCode) const {</span>
<span class="line-removed">-     if (U_FAILURE(errorCode)) {</span>
<span class="line-removed">-         return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (index != StandardPlural::OTHER) {</span>
<span class="line-removed">-         const SimpleFormatter *pattern = getFormatterOrNull(unit, width, index);</span>
<span class="line-removed">-         if (pattern != NULL) {</span>
<span class="line-removed">-             return pattern;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return getFormatter(unit, width, StandardPlural::OTHER, errorCode);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const SimpleFormatter *MeasureFormat::getPerFormatter(</span>
<span class="line-removed">-         UMeasureFormatWidth width,</span>
<span class="line-removed">-         UErrorCode &amp;status) const {</span>
<span class="line-removed">-     if (U_FAILURE(status)) {</span>
<span class="line-removed">-         return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     width = getRegularWidth(width);</span>
<span class="line-removed">-     const SimpleFormatter * perFormatters = cache-&gt;perFormatters;</span>
<span class="line-removed">-     if (perFormatters[width].getArgumentLimit() == 2) {</span>
<span class="line-removed">-         return &amp;perFormatters[width];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     int32_t fallbackWidth = cache-&gt;widthFallback[width];</span>
<span class="line-removed">-     if (fallbackWidth != UMEASFMT_WIDTH_COUNT &amp;&amp;</span>
<span class="line-removed">-             perFormatters[fallbackWidth].getArgumentLimit() == 2) {</span>
<span class="line-removed">-         return &amp;perFormatters[fallbackWidth];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     status = U_MISSING_RESOURCE_ERROR;</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int32_t MeasureFormat::withPerUnitAndAppend(</span>
<span class="line-removed">-         const UnicodeString &amp;formatted,</span>
<span class="line-removed">-         const MeasureUnit &amp;perUnit,</span>
<span class="line-removed">-         UnicodeString &amp;appendTo,</span>
<span class="line-removed">-         UErrorCode &amp;status) const {</span>
<span class="line-removed">-     int32_t offset = -1;</span>
<span class="line-removed">-     if (U_FAILURE(status)) {</span>
<span class="line-removed">-         return offset;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     const SimpleFormatter *perUnitFormatter = getFormatterOrNull(perUnit, width, PER_UNIT_INDEX);</span>
<span class="line-removed">-     if (perUnitFormatter != NULL) {</span>
<span class="line-removed">-         const UnicodeString *params[] = {&amp;formatted};</span>
<span class="line-removed">-         perUnitFormatter-&gt;formatAndAppend(</span>
<span class="line-removed">-                 params,</span>
<span class="line-removed">-                 UPRV_LENGTHOF(params),</span>
<span class="line-removed">-                 appendTo,</span>
<span class="line-removed">-                 &amp;offset,</span>
<span class="line-removed">-                 1,</span>
<span class="line-removed">-                 status);</span>
<span class="line-removed">-         return offset;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     const SimpleFormatter *perFormatter = getPerFormatter(width, status);</span>
<span class="line-removed">-     const SimpleFormatter *pattern =</span>
<span class="line-removed">-             getPluralFormatter(perUnit, width, StandardPlural::ONE, status);</span>
<span class="line-removed">-     if (U_FAILURE(status)) {</span>
<span class="line-removed">-         return offset;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     UnicodeString perUnitString = pattern-&gt;getTextWithNoArguments();</span>
<span class="line-removed">-     perUnitString.trim();</span>
<span class="line-removed">-     const UnicodeString *params[] = {&amp;formatted, &amp;perUnitString};</span>
<span class="line-removed">-     perFormatter-&gt;formatAndAppend(</span>
<span class="line-removed">-             params,</span>
<span class="line-removed">-             UPRV_LENGTHOF(params),</span>
<span class="line-removed">-             appendTo,</span>
<span class="line-removed">-             &amp;offset,</span>
<span class="line-removed">-             1,</span>
<span class="line-removed">-             status);</span>
<span class="line-removed">-     return offset;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  UnicodeString &amp;MeasureFormat::formatMeasuresSlowTrack(
          const Measure *measures,
          int32_t measureCount,
          UnicodeString&amp; appendTo,
          FieldPosition&amp; pos,
<span class="line-new-header">--- 836,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1213,21 ***</span>
      if (U_FAILURE(status)) {
          return appendTo;
      }
      FieldPosition dontCare(FieldPosition::DONT_CARE);
      FieldPosition fpos(pos.getField());
<span class="line-modified">!     UnicodeString *results = new UnicodeString[measureCount];</span>
      int32_t fieldPositionFoundIndex = -1;
      for (int32_t i = 0; i &lt; measureCount; ++i) {
          const NumberFormat *nf = cache-&gt;getIntegerFormat();
          if (i == measureCount - 1) {
              nf = numberFormat-&gt;get();
<span class="line-removed">-                 delete [] results;</span>
                  return appendTo;
              }
              if (fpos.getBeginIndex() != 0 || fpos.getEndIndex() != 0) {
                  fieldPositionFoundIndex = i;
              }
<span class="line-new-header">--- 847,20 ---</span>
      if (U_FAILURE(status)) {
          return appendTo;
      }
      FieldPosition dontCare(FieldPosition::DONT_CARE);
      FieldPosition fpos(pos.getField());
<span class="line-modified">!     LocalArray&lt;UnicodeString&gt; results(new UnicodeString[measureCount], status);</span>
      int32_t fieldPositionFoundIndex = -1;
      for (int32_t i = 0; i &lt; measureCount; ++i) {
          const NumberFormat *nf = cache-&gt;getIntegerFormat();
          if (i == measureCount - 1) {
              nf = numberFormat-&gt;get();
                  return appendTo;
              }
              if (fpos.getBeginIndex() != 0 || fpos.getEndIndex() != 0) {
                  fieldPositionFoundIndex = i;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1235,44 ***</span>
              formatMeasure(measures[i], *nf, results[i], dontCare, status);
          }
      }
      int32_t offset;
      listFormatter-&gt;format(
<span class="line-modified">!             results,</span>
              measureCount,
              appendTo,
              fieldPositionFoundIndex,
              offset,
              status);
      if (U_FAILURE(status)) {
<span class="line-removed">-         delete [] results;</span>
          return appendTo;
      }
      if (offset != -1) {
          pos.setBeginIndex(fpos.getBeginIndex() + offset);
          pos.setEndIndex(fpos.getEndIndex() + offset);
      }
<span class="line-removed">-     delete [] results;</span>
      return appendTo;
  }
  
  MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(const Locale&amp; locale,
                                                     UErrorCode&amp; ec) {
<span class="line-modified">!     CurrencyFormat* fmt = NULL;</span>
<span class="line-modified">!     if (U_SUCCESS(ec)) {</span>
<span class="line-removed">-         fmt = new CurrencyFormat(locale, ec);</span>
<span class="line-removed">-         if (U_FAILURE(ec)) {</span>
<span class="line-removed">-             delete fmt;</span>
<span class="line-removed">-             fmt = NULL;</span>
<span class="line-removed">-         }</span>
      }
<span class="line-modified">!     return fmt;</span>
  }
  
  MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(UErrorCode&amp; ec) {
      if (U_FAILURE(ec)) {
<span class="line-modified">!         return NULL;</span>
      }
      return MeasureFormat::createCurrencyFormat(Locale::getDefault(), ec);
  }
  
  U_NAMESPACE_END
<span class="line-new-header">--- 868,39 ---</span>
              formatMeasure(measures[i], *nf, results[i], dontCare, status);
          }
      }
      int32_t offset;
      listFormatter-&gt;format(
<span class="line-modified">!             results.getAlias(),</span>
              measureCount,
              appendTo,
              fieldPositionFoundIndex,
              offset,
              status);
      if (U_FAILURE(status)) {
          return appendTo;
      }
<span class="line-added">+     // Fix up FieldPosition indexes if our field is found.</span>
      if (offset != -1) {
          pos.setBeginIndex(fpos.getBeginIndex() + offset);
          pos.setEndIndex(fpos.getEndIndex() + offset);
      }
      return appendTo;
  }
  
  MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(const Locale&amp; locale,
                                                     UErrorCode&amp; ec) {
<span class="line-modified">!     if (U_FAILURE(ec)) {</span>
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-modified">!     LocalPointer&lt;CurrencyFormat&gt; fmt(new CurrencyFormat(locale, ec), ec);</span>
<span class="line-added">+     return fmt.orphan();</span>
  }
  
  MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(UErrorCode&amp; ec) {
      if (U_FAILURE(ec)) {
<span class="line-modified">!         return nullptr;</span>
      }
      return MeasureFormat::createCurrencyFormat(Locale::getDefault(), ec);
  }
  
  U_NAMESPACE_END
</pre>
<center><a href="japancal.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="measunit.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>