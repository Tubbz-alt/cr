<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/numberformatter.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // © 2017 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 
   4 #include &quot;unicode/utypes.h&quot;
   5 
   6 #if !UCONFIG_NO_FORMATTING
   7 #ifndef __NUMBERFORMATTER_H__
   8 #define __NUMBERFORMATTER_H__
   9 
  10 #include &quot;unicode/appendable.h&quot;
  11 #include &quot;unicode/dcfmtsym.h&quot;
  12 #include &quot;unicode/currunit.h&quot;
  13 #include &quot;unicode/fieldpos.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  14 #include &quot;unicode/formattedvalue.h&quot;</span>
  15 #include &quot;unicode/fpositer.h&quot;
  16 #include &quot;unicode/measunit.h&quot;
  17 #include &quot;unicode/nounit.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  18 #include &quot;unicode/parseerr.h&quot;</span>
  19 #include &quot;unicode/plurrule.h&quot;
  20 #include &quot;unicode/ucurr.h&quot;
  21 #include &quot;unicode/unum.h&quot;
  22 #include &quot;unicode/unumberformatter.h&quot;
  23 #include &quot;unicode/uobject.h&quot;
  24 
  25 #ifndef U_HIDE_DRAFT_API
  26 
  27 /**
  28  * \file
  29  * \brief C++ API: Library for localized number formatting introduced in ICU 60.
  30  *
  31  * This library was introduced in ICU 60 to simplify the process of formatting localized number strings.
  32  * Basic usage examples:
  33  *
  34  * &lt;pre&gt;
  35  * // Most basic usage:
  36  * NumberFormatter::withLocale(...).format(123).toString();  // 1,234 in en-US
  37  *
  38  * // Custom notation, unit, and rounding precision:
  39  * NumberFormatter::with()
  40  *     .notation(Notation::compactShort())
  41  *     .unit(CurrencyUnit(&quot;EUR&quot;, status))
  42  *     .precision(Precision::maxDigits(2))
  43  *     .locale(...)
  44  *     .format(1234)
  45  *     .toString();  // €1.2K in en-US
  46  *
<a name="3" id="anc3"></a><span class="line-modified">  47  * // Create a formatter in a singleton by value for use later:</span>
  48  * static const LocalizedNumberFormatter formatter = NumberFormatter::withLocale(...)
  49  *     .unit(NoUnit::percent())
  50  *     .precision(Precision::fixedFraction(3));
  51  * formatter.format(5.9831).toString();  // 5.983% in en-US
  52  *
<a name="4" id="anc4"></a><span class="line-modified">  53  * // Create a &quot;template&quot; in a singleton unique_ptr but without setting a locale until the call site:</span>
<span class="line-modified">  54  * std::unique_ptr&lt;UnlocalizedNumberFormatter&gt; template = NumberFormatter::with()</span>
  55  *     .sign(UNumberSignDisplay::UNUM_SIGN_ALWAYS)
<a name="5" id="anc5"></a><span class="line-modified">  56  *     .unit(MeasureUnit::getMeter())</span>
<span class="line-modified">  57  *     .unitWidth(UNumberUnitWidth::UNUM_UNIT_WIDTH_FULL_NAME)</span>
<span class="line-modified">  58  *     .clone();</span>
<span class="line-added">  59  * template-&gt;locale(...).format(1234).toString();  // +1,234 meters in en-US</span>
  60  * &lt;/pre&gt;
  61  *
  62  * &lt;p&gt;
  63  * This API offers more features than DecimalFormat and is geared toward new users of ICU.
  64  *
  65  * &lt;p&gt;
<a name="6" id="anc6"></a><span class="line-modified">  66  * NumberFormatter instances (i.e., LocalizedNumberFormatter and UnlocalizedNumberFormatter)</span>
<span class="line-added">  67  * are immutable and thread safe. This means that invoking a configuration method has no</span>
  68  * effect on the receiving instance; you must store and use the new number formatter instance it returns instead.
  69  *
  70  * &lt;pre&gt;
  71  * UnlocalizedNumberFormatter formatter = UnlocalizedNumberFormatter::with().notation(Notation::scientific());
  72  * formatter.precision(Precision.maxFraction(2)); // does nothing!
  73  * formatter.locale(Locale.getEnglish()).format(9.8765).toString(); // prints &quot;9.8765E0&quot;, not &quot;9.88E0&quot;
  74  * &lt;/pre&gt;
  75  *
  76  * &lt;p&gt;
  77  * This API is based on the &lt;em&gt;fluent&lt;/em&gt; design pattern popularized by libraries such as Google&#39;s Guava. For
  78  * extensive details on the design of this API, read &lt;a href=&quot;https://goo.gl/szi5VB&quot;&gt;the design doc&lt;/a&gt;.
  79  *
  80  * @author Shane Carr
  81  */
  82 
  83 U_NAMESPACE_BEGIN
  84 
  85 // Forward declarations:
  86 class IFixedDecimal;
  87 class FieldPositionIteratorHandler;
  88 
  89 namespace numparse {
  90 namespace impl {
  91 
  92 // Forward declarations:
  93 class NumberParserImpl;
  94 class MultiplierParseHandler;
  95 
  96 }
  97 }
  98 
  99 namespace number {  // icu::number
 100 
 101 // Forward declarations:
 102 class UnlocalizedNumberFormatter;
 103 class LocalizedNumberFormatter;
 104 class FormattedNumber;
 105 class Notation;
 106 class ScientificNotation;
 107 class Precision;
 108 class FractionPrecision;
 109 class CurrencyPrecision;
 110 class IncrementPrecision;
 111 class IntegerWidth;
 112 
 113 namespace impl {
 114 
<a name="7" id="anc7"></a><span class="line-added"> 115 // can&#39;t be #ifndef U_HIDE_INTERNAL_API; referenced throughout this file in public classes</span>
 116 /**
 117  * Datatype for minimum/maximum fraction digits. Must be able to hold kMaxIntFracSig.
 118  *
 119  * @internal
 120  */
 121 typedef int16_t digits_t;
 122 
<a name="8" id="anc8"></a><span class="line-added"> 123 // can&#39;t be #ifndef U_HIDE_INTERNAL_API; needed for struct initialization</span>
 124 /**
 125  * Use a default threshold of 3. This means that the third time .format() is called, the data structures get built
 126  * using the &quot;safe&quot; code path. The first two calls to .format() will trigger the unsafe code path.
 127  *
 128  * @internal
 129  */
<a name="9" id="anc9"></a><span class="line-modified"> 130 static constexpr int32_t kInternalDefaultThreshold = 3;</span>
 131 
 132 // Forward declarations:
 133 class Padder;
 134 struct MacroProps;
 135 struct MicroProps;
 136 class DecimalQuantity;
<a name="10" id="anc10"></a><span class="line-modified"> 137 class UFormattedNumberData;</span>
 138 class NumberFormatterImpl;
 139 struct ParsedPatternInfo;
 140 class ScientificModifier;
 141 class MultiplierProducer;
 142 class RoundingImpl;
 143 class ScientificHandler;
 144 class Modifier;
 145 class NumberStringBuilder;
 146 class AffixPatternProvider;
 147 class NumberPropertyMapper;
 148 struct DecimalFormatProperties;
 149 class MultiplierFormatHandler;
 150 class CurrencySymbols;
 151 class GeneratorHelpers;
 152 class DecNum;
<a name="11" id="anc11"></a><span class="line-added"> 153 class NumberRangeFormatterImpl;</span>
<span class="line-added"> 154 struct RangeMacroProps;</span>
<span class="line-added"> 155 struct UFormattedNumberImpl;</span>
<span class="line-added"> 156 </span>
<span class="line-added"> 157 /**</span>
<span class="line-added"> 158  * Used for NumberRangeFormatter and implemented in numrange_fluent.cpp.</span>
<span class="line-added"> 159  * Declared here so it can be friended.</span>
<span class="line-added"> 160  *</span>
<span class="line-added"> 161  * @internal</span>
<span class="line-added"> 162  */</span>
<span class="line-added"> 163 void touchRangeLocales(impl::RangeMacroProps&amp; macros);</span>
 164 
 165 } // namespace impl
 166 
<a name="12" id="anc12"></a><span class="line-modified"> 167 /**</span>
<span class="line-added"> 168  * Extra name reserved in case it is needed in the future.</span>
<span class="line-added"> 169  *</span>
<span class="line-added"> 170  * @draft ICU 63</span>
<span class="line-added"> 171  */</span>
 172 typedef Notation CompactNotation;
<a name="13" id="anc13"></a><span class="line-added"> 173 </span>
<span class="line-added"> 174 /**</span>
<span class="line-added"> 175  * Extra name reserved in case it is needed in the future.</span>
<span class="line-added"> 176  *</span>
<span class="line-added"> 177  * @draft ICU 63</span>
<span class="line-added"> 178  */</span>
 179 typedef Notation SimpleNotation;
 180 
 181 /**
 182  * A class that defines the notation style to be used when formatting numbers in NumberFormatter.
 183  *
 184  * @draft ICU 60
 185  */
 186 class U_I18N_API Notation : public UMemory {
 187   public:
 188     /**
 189      * Print the number using scientific notation (also known as scientific form, standard index form, or standard form
 190      * in the UK). The format for scientific notation varies by locale; for example, many Western locales display the
 191      * number in the form &quot;#E0&quot;, where the number is displayed with one digit before the decimal separator, zero or more
 192      * digits after the decimal separator, and the corresponding power of 10 displayed after the &quot;E&quot;.
 193      *
 194      * &lt;p&gt;
 195      * Example outputs in &lt;em&gt;en-US&lt;/em&gt; when printing 8.765E4 through 8.765E-3:
 196      *
 197      * &lt;pre&gt;
 198      * 8.765E4
 199      * 8.765E3
 200      * 8.765E2
 201      * 8.765E1
 202      * 8.765E0
 203      * 8.765E-1
 204      * 8.765E-2
 205      * 8.765E-3
 206      * 0E0
 207      * &lt;/pre&gt;
 208      *
 209      * @return A ScientificNotation for chaining or passing to the NumberFormatter notation() setter.
 210      * @draft ICU 60
 211      */
 212     static ScientificNotation scientific();
 213 
 214     /**
 215      * Print the number using engineering notation, a variant of scientific notation in which the exponent must be
 216      * divisible by 3.
 217      *
 218      * &lt;p&gt;
 219      * Example outputs in &lt;em&gt;en-US&lt;/em&gt; when printing 8.765E4 through 8.765E-3:
 220      *
 221      * &lt;pre&gt;
 222      * 87.65E3
 223      * 8.765E3
 224      * 876.5E0
 225      * 87.65E0
 226      * 8.765E0
 227      * 876.5E-3
 228      * 87.65E-3
 229      * 8.765E-3
 230      * 0E0
 231      * &lt;/pre&gt;
 232      *
 233      * @return A ScientificNotation for chaining or passing to the NumberFormatter notation() setter.
 234      * @draft ICU 60
 235      */
 236     static ScientificNotation engineering();
 237 
 238     /**
 239      * Print the number using short-form compact notation.
 240      *
 241      * &lt;p&gt;
 242      * &lt;em&gt;Compact notation&lt;/em&gt;, defined in Unicode Technical Standard #35 Part 3 Section 2.4.1, prints numbers with
 243      * localized prefixes or suffixes corresponding to different powers of ten. Compact notation is similar to
 244      * engineering notation in how it scales numbers.
 245      *
 246      * &lt;p&gt;
 247      * Compact notation is ideal for displaying large numbers (over ~1000) to humans while at the same time minimizing
 248      * screen real estate.
 249      *
 250      * &lt;p&gt;
 251      * In short form, the powers of ten are abbreviated. In &lt;em&gt;en-US&lt;/em&gt;, the abbreviations are &quot;K&quot; for thousands, &quot;M&quot;
 252      * for millions, &quot;B&quot; for billions, and &quot;T&quot; for trillions. Example outputs in &lt;em&gt;en-US&lt;/em&gt; when printing 8.765E7
 253      * through 8.765E0:
 254      *
 255      * &lt;pre&gt;
 256      * 88M
 257      * 8.8M
 258      * 876K
 259      * 88K
 260      * 8.8K
 261      * 876
 262      * 88
 263      * 8.8
 264      * &lt;/pre&gt;
 265      *
 266      * &lt;p&gt;
 267      * When compact notation is specified without an explicit rounding precision, numbers are rounded off to the closest
 268      * integer after scaling the number by the corresponding power of 10, but with a digit shown after the decimal
 269      * separator if there is only one digit before the decimal separator. The default compact notation rounding precision
 270      * is equivalent to:
 271      *
 272      * &lt;pre&gt;
 273      * Precision::integer().withMinDigits(2)
 274      * &lt;/pre&gt;
 275      *
 276      * @return A CompactNotation for passing to the NumberFormatter notation() setter.
 277      * @draft ICU 60
 278      */
 279     static CompactNotation compactShort();
 280 
 281     /**
 282      * Print the number using long-form compact notation. For more information on compact notation, see
 283      * {@link #compactShort}.
 284      *
 285      * &lt;p&gt;
 286      * In long form, the powers of ten are spelled out fully. Example outputs in &lt;em&gt;en-US&lt;/em&gt; when printing 8.765E7
 287      * through 8.765E0:
 288      *
 289      * &lt;pre&gt;
 290      * 88 million
 291      * 8.8 million
 292      * 876 thousand
 293      * 88 thousand
 294      * 8.8 thousand
 295      * 876
 296      * 88
 297      * 8.8
 298      * &lt;/pre&gt;
 299      *
 300      * @return A CompactNotation for passing to the NumberFormatter notation() setter.
 301      * @draft ICU 60
 302      */
 303     static CompactNotation compactLong();
 304 
 305     /**
 306      * Print the number using simple notation without any scaling by powers of ten. This is the default behavior.
 307      *
 308      * &lt;p&gt;
 309      * Since this is the default behavior, this method needs to be called only when it is necessary to override a
 310      * previous setting.
 311      *
 312      * &lt;p&gt;
 313      * Example outputs in &lt;em&gt;en-US&lt;/em&gt; when printing 8.765E7 through 8.765E0:
 314      *
 315      * &lt;pre&gt;
 316      * 87,650,000
 317      * 8,765,000
 318      * 876,500
 319      * 87,650
 320      * 8,765
 321      * 876.5
 322      * 87.65
 323      * 8.765
 324      * &lt;/pre&gt;
 325      *
 326      * @return A SimpleNotation for passing to the NumberFormatter notation() setter.
 327      * @draft ICU 60
 328      */
 329     static SimpleNotation simple();
 330 
 331   private:
 332     enum NotationType {
 333         NTN_SCIENTIFIC, NTN_COMPACT, NTN_SIMPLE, NTN_ERROR
 334     } fType;
 335 
 336     union NotationUnion {
 337         // For NTN_SCIENTIFIC
<a name="14" id="anc14"></a><span class="line-added"> 338         /** @internal */</span>
 339         struct ScientificSettings {
<a name="15" id="anc15"></a><span class="line-added"> 340             /** @internal */</span>
 341             int8_t fEngineeringInterval;
<a name="16" id="anc16"></a><span class="line-added"> 342             /** @internal */</span>
 343             bool fRequireMinInt;
<a name="17" id="anc17"></a><span class="line-added"> 344             /** @internal */</span>
 345             impl::digits_t fMinExponentDigits;
<a name="18" id="anc18"></a><span class="line-added"> 346             /** @internal */</span>
 347             UNumberSignDisplay fExponentSignDisplay;
 348         } scientific;
 349 
 350         // For NTN_COMPACT
 351         UNumberCompactStyle compactStyle;
 352 
 353         // For NTN_ERROR
 354         UErrorCode errorCode;
 355     } fUnion;
 356 
 357     typedef NotationUnion::ScientificSettings ScientificSettings;
 358 
 359     Notation(const NotationType &amp;type, const NotationUnion &amp;union_) : fType(type), fUnion(union_) {}
 360 
 361     Notation(UErrorCode errorCode) : fType(NTN_ERROR) {
 362         fUnion.errorCode = errorCode;
 363     }
 364 
 365     Notation() : fType(NTN_SIMPLE), fUnion() {}
 366 
 367     UBool copyErrorTo(UErrorCode &amp;status) const {
 368         if (fType == NTN_ERROR) {
 369             status = fUnion.errorCode;
 370             return TRUE;
 371         }
 372         return FALSE;
 373     }
 374 
 375     // To allow MacroProps to initialize empty instances:
 376     friend struct impl::MacroProps;
 377     friend class ScientificNotation;
 378 
 379     // To allow implementation to access internal types:
 380     friend class impl::NumberFormatterImpl;
 381     friend class impl::ScientificModifier;
 382     friend class impl::ScientificHandler;
 383 
 384     // To allow access to the skeleton generation code:
 385     friend class impl::GeneratorHelpers;
 386 };
 387 
 388 /**
 389  * A class that defines the scientific notation style to be used when formatting numbers in NumberFormatter.
 390  *
 391  * &lt;p&gt;
 392  * To create a ScientificNotation, use one of the factory methods in {@link Notation}.
 393  *
 394  * @draft ICU 60
 395  */
 396 class U_I18N_API ScientificNotation : public Notation {
 397   public:
 398     /**
 399      * Sets the minimum number of digits to show in the exponent of scientific notation, padding with zeros if
 400      * necessary. Useful for fixed-width display.
 401      *
 402      * &lt;p&gt;
 403      * For example, with minExponentDigits=2, the number 123 will be printed as &quot;1.23E02&quot; in &lt;em&gt;en-US&lt;/em&gt; instead of
 404      * the default &quot;1.23E2&quot;.
 405      *
 406      * @param minExponentDigits
 407      *            The minimum number of digits to show in the exponent.
 408      * @return A ScientificNotation, for chaining.
 409      * @draft ICU 60
 410      */
 411     ScientificNotation withMinExponentDigits(int32_t minExponentDigits) const;
 412 
 413     /**
 414      * Sets whether to show the sign on positive and negative exponents in scientific notation. The default is AUTO,
 415      * showing the minus sign but not the plus sign.
 416      *
 417      * &lt;p&gt;
 418      * For example, with exponentSignDisplay=ALWAYS, the number 123 will be printed as &quot;1.23E+2&quot; in &lt;em&gt;en-US&lt;/em&gt;
 419      * instead of the default &quot;1.23E2&quot;.
 420      *
 421      * @param exponentSignDisplay
 422      *            The strategy for displaying the sign in the exponent.
 423      * @return A ScientificNotation, for chaining.
 424      * @draft ICU 60
 425      */
 426     ScientificNotation withExponentSignDisplay(UNumberSignDisplay exponentSignDisplay) const;
 427 
 428   private:
 429     // Inherit constructor
 430     using Notation::Notation;
 431 
 432     // Raw constructor for NumberPropertyMapper
 433     ScientificNotation(int8_t fEngineeringInterval, bool fRequireMinInt, impl::digits_t fMinExponentDigits,
 434                        UNumberSignDisplay fExponentSignDisplay);
 435 
 436     friend class Notation;
 437 
 438     // So that NumberPropertyMapper can create instances
 439     friend class impl::NumberPropertyMapper;
 440 };
 441 
<a name="19" id="anc19"></a><span class="line-modified"> 442 /**</span>
<span class="line-added"> 443  * Extra name reserved in case it is needed in the future.</span>
<span class="line-added"> 444  *</span>
<span class="line-added"> 445  * @draft ICU 63</span>
<span class="line-added"> 446  */</span>
 447 typedef Precision SignificantDigitsPrecision;
 448 
<a name="20" id="anc20"></a>







 449 /**
 450  * A class that defines the rounding precision to be used when formatting numbers in NumberFormatter.
 451  *
 452  * &lt;p&gt;
 453  * To create a Precision, use one of the factory methods.
 454  *
 455  * @draft ICU 60
 456  */
 457 class U_I18N_API Precision : public UMemory {
 458 
 459   public:
 460     /**
 461      * Show all available digits to full precision.
 462      *
 463      * &lt;p&gt;
 464      * &lt;strong&gt;NOTE:&lt;/strong&gt; When formatting a &lt;em&gt;double&lt;/em&gt;, this method, along with {@link #minFraction} and
<a name="21" id="anc21"></a><span class="line-modified"> 465      * {@link #minSignificantDigits}, will trigger complex algorithm similar to &lt;em&gt;Dragon4&lt;/em&gt; to determine the</span>
<span class="line-modified"> 466      * low-order digits and the number of digits to display based on the value of the double.</span>
<span class="line-modified"> 467      * If the number of fraction places or significant digits can be bounded, consider using {@link #maxFraction}</span>
<span class="line-modified"> 468      * or {@link #maxSignificantDigits} instead to maximize performance.</span>
<span class="line-added"> 469      * For more information, read the following blog post.</span>
 470      *
 471      * &lt;p&gt;
 472      * http://www.serpentine.com/blog/2011/06/29/here-be-dragons-advances-in-problems-you-didnt-even-know-you-had/
 473      *
 474      * @return A Precision for chaining or passing to the NumberFormatter precision() setter.
 475      * @draft ICU 60
 476      */
 477     static Precision unlimited();
 478 
 479     /**
 480      * Show numbers rounded if necessary to the nearest integer.
 481      *
 482      * @return A FractionPrecision for chaining or passing to the NumberFormatter precision() setter.
 483      * @draft ICU 60
 484      */
 485     static FractionPrecision integer();
 486 
 487     /**
 488      * Show numbers rounded if necessary to a certain number of fraction places (numerals after the decimal separator).
 489      * Additionally, pad with zeros to ensure that this number of places are always shown.
 490      *
 491      * &lt;p&gt;
 492      * Example output with minMaxFractionPlaces = 3:
 493      *
 494      * &lt;p&gt;
 495      * 87,650.000&lt;br&gt;
 496      * 8,765.000&lt;br&gt;
 497      * 876.500&lt;br&gt;
 498      * 87.650&lt;br&gt;
 499      * 8.765&lt;br&gt;
 500      * 0.876&lt;br&gt;
 501      * 0.088&lt;br&gt;
 502      * 0.009&lt;br&gt;
 503      * 0.000 (zero)
 504      *
 505      * &lt;p&gt;
 506      * This method is equivalent to {@link #minMaxFraction} with both arguments equal.
 507      *
 508      * @param minMaxFractionPlaces
 509      *            The minimum and maximum number of numerals to display after the decimal separator (rounding if too
 510      *            long or padding with zeros if too short).
 511      * @return A FractionPrecision for chaining or passing to the NumberFormatter precision() setter.
 512      * @draft ICU 60
 513      */
 514     static FractionPrecision fixedFraction(int32_t minMaxFractionPlaces);
 515 
 516     /**
 517      * Always show at least a certain number of fraction places after the decimal separator, padding with zeros if
 518      * necessary. Do not perform rounding (display numbers to their full precision).
 519      *
 520      * &lt;p&gt;
 521      * &lt;strong&gt;NOTE:&lt;/strong&gt; If you are formatting &lt;em&gt;doubles&lt;/em&gt;, see the performance note in {@link #unlimited}.
 522      *
 523      * @param minFractionPlaces
 524      *            The minimum number of numerals to display after the decimal separator (padding with zeros if
 525      *            necessary).
 526      * @return A FractionPrecision for chaining or passing to the NumberFormatter precision() setter.
 527      * @draft ICU 60
 528      */
 529     static FractionPrecision minFraction(int32_t minFractionPlaces);
 530 
 531     /**
 532      * Show numbers rounded if necessary to a certain number of fraction places (numerals after the decimal separator).
 533      * Unlike the other fraction rounding strategies, this strategy does &lt;em&gt;not&lt;/em&gt; pad zeros to the end of the
 534      * number.
 535      *
 536      * @param maxFractionPlaces
 537      *            The maximum number of numerals to display after the decimal mark (rounding if necessary).
 538      * @return A FractionPrecision for chaining or passing to the NumberFormatter precision() setter.
 539      * @draft ICU 60
 540      */
 541     static FractionPrecision maxFraction(int32_t maxFractionPlaces);
 542 
 543     /**
 544      * Show numbers rounded if necessary to a certain number of fraction places (numerals after the decimal separator);
 545      * in addition, always show at least a certain number of places after the decimal separator, padding with zeros if
 546      * necessary.
 547      *
 548      * @param minFractionPlaces
 549      *            The minimum number of numerals to display after the decimal separator (padding with zeros if
 550      *            necessary).
 551      * @param maxFractionPlaces
 552      *            The maximum number of numerals to display after the decimal separator (rounding if necessary).
 553      * @return A FractionPrecision for chaining or passing to the NumberFormatter precision() setter.
 554      * @draft ICU 60
 555      */
 556     static FractionPrecision minMaxFraction(int32_t minFractionPlaces, int32_t maxFractionPlaces);
 557 
 558     /**
 559      * Show numbers rounded if necessary to a certain number of significant digits or significant figures. Additionally,
 560      * pad with zeros to ensure that this number of significant digits/figures are always shown.
 561      *
 562      * &lt;p&gt;
<a name="22" id="anc22"></a><span class="line-modified"> 563      * This method is equivalent to {@link #minMaxSignificantDigits} with both arguments equal.</span>
 564      *
 565      * @param minMaxSignificantDigits
 566      *            The minimum and maximum number of significant digits to display (rounding if too long or padding with
 567      *            zeros if too short).
 568      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 569      * @draft ICU 62
 570      */
 571     static SignificantDigitsPrecision fixedSignificantDigits(int32_t minMaxSignificantDigits);
 572 
 573     /**
 574      * Always show at least a certain number of significant digits/figures, padding with zeros if necessary. Do not
 575      * perform rounding (display numbers to their full precision).
 576      *
 577      * &lt;p&gt;
 578      * &lt;strong&gt;NOTE:&lt;/strong&gt; If you are formatting &lt;em&gt;doubles&lt;/em&gt;, see the performance note in {@link #unlimited}.
 579      *
 580      * @param minSignificantDigits
 581      *            The minimum number of significant digits to display (padding with zeros if too short).
 582      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 583      * @draft ICU 62
 584      */
 585     static SignificantDigitsPrecision minSignificantDigits(int32_t minSignificantDigits);
 586 
 587     /**
 588      * Show numbers rounded if necessary to a certain number of significant digits/figures.
 589      *
 590      * @param maxSignificantDigits
 591      *            The maximum number of significant digits to display (rounding if too long).
 592      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 593      * @draft ICU 62
 594      */
 595     static SignificantDigitsPrecision maxSignificantDigits(int32_t maxSignificantDigits);
 596 
 597     /**
 598      * Show numbers rounded if necessary to a certain number of significant digits/figures; in addition, always show at
 599      * least a certain number of significant digits, padding with zeros if necessary.
 600      *
 601      * @param minSignificantDigits
 602      *            The minimum number of significant digits to display (padding with zeros if necessary).
 603      * @param maxSignificantDigits
 604      *            The maximum number of significant digits to display (rounding if necessary).
 605      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 606      * @draft ICU 62
 607      */
 608     static SignificantDigitsPrecision minMaxSignificantDigits(int32_t minSignificantDigits,
 609                                                               int32_t maxSignificantDigits);
 610 
<a name="23" id="anc23"></a>
























 611     /**
 612      * Show numbers rounded if necessary to the closest multiple of a certain rounding increment. For example, if the
 613      * rounding increment is 0.5, then round 1.2 to 1 and round 1.3 to 1.5.
 614      *
 615      * &lt;p&gt;
 616      * In order to ensure that numbers are padded to the appropriate number of fraction places, call
 617      * withMinFraction() on the return value of this method.
 618      * For example, to round to the nearest 0.5 and always display 2 numerals after the
 619      * decimal separator (to display 1.2 as &quot;1.00&quot; and 1.3 as &quot;1.50&quot;), you can run:
 620      *
 621      * &lt;pre&gt;
 622      * Precision::increment(0.5).withMinFraction(2)
 623      * &lt;/pre&gt;
 624      *
 625      * @param roundingIncrement
 626      *            The increment to which to round numbers.
 627      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 628      * @draft ICU 60
 629      */
 630     static IncrementPrecision increment(double roundingIncrement);
 631 
 632     /**
 633      * Show numbers rounded and padded according to the rules for the currency unit. The most common
 634      * rounding precision settings for currencies include &lt;code&gt;Precision::fixedFraction(2)&lt;/code&gt;,
 635      * &lt;code&gt;Precision::integer()&lt;/code&gt;, and &lt;code&gt;Precision::increment(0.05)&lt;/code&gt; for cash transactions
 636      * (&quot;nickel rounding&quot;).
 637      *
 638      * &lt;p&gt;
 639      * The exact rounding details will be resolved at runtime based on the currency unit specified in the
 640      * NumberFormatter chain. To round according to the rules for one currency while displaying the symbol for another
 641      * currency, the withCurrency() method can be called on the return value of this method.
 642      *
 643      * @param currencyUsage
 644      *            Either STANDARD (for digital transactions) or CASH (for transactions where the rounding increment may
 645      *            be limited by the available denominations of cash or coins).
 646      * @return A CurrencyPrecision for chaining or passing to the NumberFormatter precision() setter.
 647      * @draft ICU 60
 648      */
 649     static CurrencyPrecision currency(UCurrencyUsage currencyUsage);
 650 
<a name="24" id="anc24"></a>














 651   private:
 652     enum PrecisionType {
 653         RND_BOGUS,
 654         RND_NONE,
 655         RND_FRACTION,
 656         RND_SIGNIFICANT,
 657         RND_FRACTION_SIGNIFICANT,
<a name="25" id="anc25"></a><span class="line-added"> 658 </span>
<span class="line-added"> 659         // Used for strange increments like 3.14.</span>
 660         RND_INCREMENT,
<a name="26" id="anc26"></a><span class="line-added"> 661 </span>
<span class="line-added"> 662         // Used for increments with 1 as the only digit. This is different than fraction</span>
<span class="line-added"> 663         // rounding because it supports having additional trailing zeros. For example, this</span>
<span class="line-added"> 664         // class is used to round with the increment 0.010.</span>
<span class="line-added"> 665         RND_INCREMENT_ONE,</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667         // Used for increments with 5 as the only digit (nickel rounding).</span>
<span class="line-added"> 668         RND_INCREMENT_FIVE,</span>
<span class="line-added"> 669 </span>
 670         RND_CURRENCY,
 671         RND_ERROR
 672     } fType;
 673 
 674     union PrecisionUnion {
<a name="27" id="anc27"></a><span class="line-added"> 675         /** @internal */</span>
 676         struct FractionSignificantSettings {
 677             // For RND_FRACTION, RND_SIGNIFICANT, and RND_FRACTION_SIGNIFICANT
<a name="28" id="anc28"></a><span class="line-added"> 678             /** @internal */</span>
 679             impl::digits_t fMinFrac;
<a name="29" id="anc29"></a><span class="line-added"> 680             /** @internal */</span>
 681             impl::digits_t fMaxFrac;
<a name="30" id="anc30"></a><span class="line-added"> 682             /** @internal */</span>
 683             impl::digits_t fMinSig;
<a name="31" id="anc31"></a><span class="line-added"> 684             /** @internal */</span>
 685             impl::digits_t fMaxSig;
 686         } fracSig;
<a name="32" id="anc32"></a><span class="line-added"> 687         /** @internal */</span>
 688         struct IncrementSettings {
<a name="33" id="anc33"></a><span class="line-added"> 689             // For RND_INCREMENT, RND_INCREMENT_ONE, and RND_INCREMENT_FIVE</span>
<span class="line-added"> 690             /** @internal */</span>
 691             double fIncrement;
<a name="34" id="anc34"></a><span class="line-added"> 692             /** @internal */</span>
 693             impl::digits_t fMinFrac;
<a name="35" id="anc35"></a><span class="line-added"> 694             /** @internal */</span>
 695             impl::digits_t fMaxFrac;
<a name="36" id="anc36"></a><span class="line-modified"> 696         } increment;</span>
 697         UCurrencyUsage currencyUsage; // For RND_CURRENCY
 698         UErrorCode errorCode; // For RND_ERROR
 699     } fUnion;
 700 
 701     typedef PrecisionUnion::FractionSignificantSettings FractionSignificantSettings;
 702     typedef PrecisionUnion::IncrementSettings IncrementSettings;
 703 
 704     /** The Precision encapsulates the RoundingMode when used within the implementation. */
 705     UNumberFormatRoundingMode fRoundingMode;
 706 
 707     Precision(const PrecisionType&amp; type, const PrecisionUnion&amp; union_,
 708               UNumberFormatRoundingMode roundingMode)
 709             : fType(type), fUnion(union_), fRoundingMode(roundingMode) {}
 710 
 711     Precision(UErrorCode errorCode) : fType(RND_ERROR) {
 712         fUnion.errorCode = errorCode;
 713     }
 714 
 715     Precision() : fType(RND_BOGUS) {}
 716 
 717     bool isBogus() const {
 718         return fType == RND_BOGUS;
 719     }
 720 
 721     UBool copyErrorTo(UErrorCode &amp;status) const {
 722         if (fType == RND_ERROR) {
 723             status = fUnion.errorCode;
 724             return TRUE;
 725         }
 726         return FALSE;
 727     }
 728 
 729     // On the parent type so that this method can be called internally on Precision instances.
 730     Precision withCurrency(const CurrencyUnit &amp;currency, UErrorCode &amp;status) const;
 731 
 732     static FractionPrecision constructFraction(int32_t minFrac, int32_t maxFrac);
 733 
 734     static Precision constructSignificant(int32_t minSig, int32_t maxSig);
 735 
 736     static Precision
 737     constructFractionSignificant(const FractionPrecision &amp;base, int32_t minSig, int32_t maxSig);
 738 
 739     static IncrementPrecision constructIncrement(double increment, int32_t minFrac);
 740 
 741     static CurrencyPrecision constructCurrency(UCurrencyUsage usage);
 742 
 743     static Precision constructPassThrough();
 744 
 745     // To allow MacroProps/MicroProps to initialize bogus instances:
 746     friend struct impl::MacroProps;
 747     friend struct impl::MicroProps;
 748 
 749     // To allow NumberFormatterImpl to access isBogus() and other internal methods:
 750     friend class impl::NumberFormatterImpl;
 751 
 752     // To allow NumberPropertyMapper to create instances from DecimalFormatProperties:
 753     friend class impl::NumberPropertyMapper;
 754 
 755     // To allow access to the main implementation class:
 756     friend class impl::RoundingImpl;
 757 
 758     // To allow child classes to call private methods:
 759     friend class FractionPrecision;
 760     friend class CurrencyPrecision;
 761     friend class IncrementPrecision;
 762 
 763     // To allow access to the skeleton generation code:
 764     friend class impl::GeneratorHelpers;
 765 };
 766 
 767 /**
 768  * A class that defines a rounding precision based on a number of fraction places and optionally significant digits to be
 769  * used when formatting numbers in NumberFormatter.
 770  *
 771  * &lt;p&gt;
 772  * To create a FractionPrecision, use one of the factory methods on Precision.
 773  *
 774  * @draft ICU 60
 775  */
 776 class U_I18N_API FractionPrecision : public Precision {
 777   public:
 778     /**
 779      * Ensure that no less than this number of significant digits are retained when rounding according to fraction
 780      * rules.
 781      *
 782      * &lt;p&gt;
 783      * For example, with integer rounding, the number 3.141 becomes &quot;3&quot;. However, with minimum figures set to 2, 3.141
 784      * becomes &quot;3.1&quot; instead.
 785      *
 786      * &lt;p&gt;
 787      * This setting does not affect the number of trailing zeros. For example, 3.01 would print as &quot;3&quot;, not &quot;3.0&quot;.
 788      *
 789      * @param minSignificantDigits
 790      *            The number of significant figures to guarantee.
 791      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 792      * @draft ICU 60
 793      */
 794     Precision withMinDigits(int32_t minSignificantDigits) const;
 795 
 796     /**
 797      * Ensure that no more than this number of significant digits are retained when rounding according to fraction
 798      * rules.
 799      *
 800      * &lt;p&gt;
 801      * For example, with integer rounding, the number 123.4 becomes &quot;123&quot;. However, with maximum figures set to 2, 123.4
 802      * becomes &quot;120&quot; instead.
 803      *
 804      * &lt;p&gt;
 805      * This setting does not affect the number of trailing zeros. For example, with fixed fraction of 2, 123.4 would
 806      * become &quot;120.00&quot;.
 807      *
 808      * @param maxSignificantDigits
 809      *            Round the number to no more than this number of significant figures.
 810      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 811      * @draft ICU 60
 812      */
 813     Precision withMaxDigits(int32_t maxSignificantDigits) const;
 814 
 815   private:
 816     // Inherit constructor
 817     using Precision::Precision;
 818 
 819     // To allow parent class to call this class&#39;s constructor:
 820     friend class Precision;
 821 };
 822 
 823 /**
 824  * A class that defines a rounding precision parameterized by a currency to be used when formatting numbers in
 825  * NumberFormatter.
 826  *
 827  * &lt;p&gt;
 828  * To create a CurrencyPrecision, use one of the factory methods on Precision.
 829  *
 830  * @draft ICU 60
 831  */
 832 class U_I18N_API CurrencyPrecision : public Precision {
 833   public:
 834     /**
 835       * Associates a currency with this rounding precision.
 836       *
 837       * &lt;p&gt;
 838       * &lt;strong&gt;Calling this method is &lt;em&gt;not required&lt;/em&gt;&lt;/strong&gt;, because the currency specified in unit()
 839       * is automatically applied to currency rounding precisions. However,
 840       * this method enables you to override that automatic association.
 841       *
 842       * &lt;p&gt;
 843       * This method also enables numbers to be formatted using currency rounding rules without explicitly using a
 844       * currency format.
 845       *
 846       * @param currency
 847       *            The currency to associate with this rounding precision.
 848       * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 849       * @draft ICU 60
 850       */
 851     Precision withCurrency(const CurrencyUnit &amp;currency) const;
 852 
 853   private:
 854     // Inherit constructor
 855     using Precision::Precision;
 856 
 857     // To allow parent class to call this class&#39;s constructor:
 858     friend class Precision;
 859 };
 860 
 861 /**
 862  * A class that defines a rounding precision parameterized by a rounding increment to be used when formatting numbers in
 863  * NumberFormatter.
 864  *
 865  * &lt;p&gt;
 866  * To create an IncrementPrecision, use one of the factory methods on Precision.
 867  *
 868  * @draft ICU 60
 869  */
 870 class U_I18N_API IncrementPrecision : public Precision {
 871   public:
 872     /**
 873      * Specifies the minimum number of fraction digits to render after the decimal separator, padding with zeros if
 874      * necessary.  By default, no trailing zeros are added.
 875      *
 876      * &lt;p&gt;
 877      * For example, if the rounding increment is 0.5 and minFrac is 2, then the resulting strings include &quot;0.00&quot;,
 878      * &quot;0.50&quot;, &quot;1.00&quot;, and &quot;1.50&quot;.
 879      *
 880      * &lt;p&gt;
 881      * Note: In ICU4J, this functionality is accomplished via the scale of the BigDecimal rounding increment.
 882      *
 883      * @param minFrac The minimum number of digits after the decimal separator.
 884      * @return A precision for chaining or passing to the NumberFormatter precision() setter.
 885      * @draft ICU 60
 886      */
 887     Precision withMinFraction(int32_t minFrac) const;
 888 
 889   private:
 890     // Inherit constructor
 891     using Precision::Precision;
 892 
 893     // To allow parent class to call this class&#39;s constructor:
 894     friend class Precision;
 895 };
 896 
 897 /**
 898  * A class that defines the strategy for padding and truncating integers before the decimal separator.
 899  *
 900  * &lt;p&gt;
 901  * To create an IntegerWidth, use one of the factory methods.
 902  *
 903  * @draft ICU 60
 904  * @see NumberFormatter
 905  */
 906 class U_I18N_API IntegerWidth : public UMemory {
 907   public:
 908     /**
 909      * Pad numbers at the beginning with zeros to guarantee a certain number of numerals before the decimal separator.
 910      *
 911      * &lt;p&gt;
 912      * For example, with minInt=3, the number 55 will get printed as &quot;055&quot;.
 913      *
 914      * @param minInt
 915      *            The minimum number of places before the decimal separator.
 916      * @return An IntegerWidth for chaining or passing to the NumberFormatter integerWidth() setter.
 917      * @draft ICU 60
 918      */
 919     static IntegerWidth zeroFillTo(int32_t minInt);
 920 
 921     /**
 922      * Truncate numbers exceeding a certain number of numerals before the decimal separator.
 923      *
 924      * For example, with maxInt=3, the number 1234 will get printed as &quot;234&quot;.
 925      *
 926      * @param maxInt
 927      *            The maximum number of places before the decimal separator. maxInt == -1 means no
 928      *            truncation.
 929      * @return An IntegerWidth for passing to the NumberFormatter integerWidth() setter.
 930      * @draft ICU 60
 931      */
 932     IntegerWidth truncateAt(int32_t maxInt);
 933 
 934   private:
 935     union {
 936         struct {
 937             impl::digits_t fMinInt;
 938             impl::digits_t fMaxInt;
 939             bool fFormatFailIfMoreThanMaxDigits;
 940         } minMaxInt;
 941         UErrorCode errorCode;
 942     } fUnion;
 943     bool fHasError = false;
 944 
 945     IntegerWidth(impl::digits_t minInt, impl::digits_t maxInt, bool formatFailIfMoreThanMaxDigits);
 946 
 947     IntegerWidth(UErrorCode errorCode) { // NOLINT
 948         fUnion.errorCode = errorCode;
 949         fHasError = true;
 950     }
 951 
 952     IntegerWidth() { // NOLINT
 953         fUnion.minMaxInt.fMinInt = -1;
 954     }
 955 
 956     /** Returns the default instance. */
 957     static IntegerWidth standard() {
 958         return IntegerWidth::zeroFillTo(1);
 959     }
 960 
 961     bool isBogus() const {
 962         return !fHasError &amp;&amp; fUnion.minMaxInt.fMinInt == -1;
 963     }
 964 
 965     UBool copyErrorTo(UErrorCode &amp;status) const {
 966         if (fHasError) {
 967             status = fUnion.errorCode;
 968             return TRUE;
 969         }
 970         return FALSE;
 971     }
 972 
 973     void apply(impl::DecimalQuantity &amp;quantity, UErrorCode &amp;status) const;
 974 
 975     bool operator==(const IntegerWidth&amp; other) const;
 976 
 977     // To allow MacroProps/MicroProps to initialize empty instances:
 978     friend struct impl::MacroProps;
 979     friend struct impl::MicroProps;
 980 
 981     // To allow NumberFormatterImpl to access isBogus() and perform other operations:
 982     friend class impl::NumberFormatterImpl;
 983 
 984     // So that NumberPropertyMapper can create instances
 985     friend class impl::NumberPropertyMapper;
 986 
 987     // To allow access to the skeleton generation code:
 988     friend class impl::GeneratorHelpers;
 989 };
 990 
 991 /**
 992  * A class that defines a quantity by which a number should be multiplied when formatting.
 993  *
 994  * &lt;p&gt;
 995  * To create a Scale, use one of the factory methods.
 996  *
 997  * @draft ICU 62
 998  */
 999 class U_I18N_API Scale : public UMemory {
1000   public:
1001     /**
1002      * Do not change the value of numbers when formatting or parsing.
1003      *
1004      * @return A Scale to prevent any multiplication.
1005      * @draft ICU 62
1006      */
1007     static Scale none();
1008 
1009     /**
1010      * Multiply numbers by a power of ten before formatting. Useful for combining with a percent unit:
1011      *
1012      * &lt;pre&gt;
1013      * NumberFormatter::with().unit(NoUnit::percent()).multiplier(Scale::powerOfTen(2))
1014      * &lt;/pre&gt;
1015      *
1016      * @return A Scale for passing to the setter in NumberFormatter.
1017      * @draft ICU 62
1018      */
1019     static Scale powerOfTen(int32_t power);
1020 
1021     /**
1022      * Multiply numbers by an arbitrary value before formatting. Useful for unit conversions.
1023      *
1024      * This method takes a string in a decimal number format with syntax
1025      * as defined in the Decimal Arithmetic Specification, available at
1026      * http://speleotrove.com/decimal
1027      *
1028      * Also see the version of this method that takes a double.
1029      *
1030      * @return A Scale for passing to the setter in NumberFormatter.
1031      * @draft ICU 62
1032      */
1033     static Scale byDecimal(StringPiece multiplicand);
1034 
1035     /**
1036      * Multiply numbers by an arbitrary value before formatting. Useful for unit conversions.
1037      *
1038      * This method takes a double; also see the version of this method that takes an exact decimal.
1039      *
1040      * @return A Scale for passing to the setter in NumberFormatter.
1041      * @draft ICU 62
1042      */
1043     static Scale byDouble(double multiplicand);
1044 
1045     /**
1046      * Multiply a number by both a power of ten and by an arbitrary double value.
1047      *
1048      * @return A Scale for passing to the setter in NumberFormatter.
1049      * @draft ICU 62
1050      */
1051     static Scale byDoubleAndPowerOfTen(double multiplicand, int32_t power);
1052 
1053     // We need a custom destructor for the DecNum, which means we need to declare
1054     // the copy/move constructor/assignment quartet.
1055 
1056     /** @draft ICU 62 */
1057     Scale(const Scale&amp; other);
1058 
1059     /** @draft ICU 62 */
1060     Scale&amp; operator=(const Scale&amp; other);
1061 
1062     /** @draft ICU 62 */
1063     Scale(Scale&amp;&amp; src) U_NOEXCEPT;
1064 
1065     /** @draft ICU 62 */
1066     Scale&amp; operator=(Scale&amp;&amp; src) U_NOEXCEPT;
1067 
1068     /** @draft ICU 62 */
1069     ~Scale();
1070 
1071 #ifndef U_HIDE_INTERNAL_API
1072     /** @internal */
1073     Scale(int32_t magnitude, impl::DecNum* arbitraryToAdopt);
1074 #endif  /* U_HIDE_INTERNAL_API */
1075 
1076   private:
1077     int32_t fMagnitude;
1078     impl::DecNum* fArbitrary;
1079     UErrorCode fError;
1080 
1081     Scale(UErrorCode error) : fMagnitude(0), fArbitrary(nullptr), fError(error) {}
1082 
1083     Scale() : fMagnitude(0), fArbitrary(nullptr), fError(U_ZERO_ERROR) {}
1084 
1085     bool isValid() const {
1086         return fMagnitude != 0 || fArbitrary != nullptr;
1087     }
1088 
1089     UBool copyErrorTo(UErrorCode &amp;status) const {
1090         if (fError != U_ZERO_ERROR) {
1091             status = fError;
1092             return TRUE;
1093         }
1094         return FALSE;
1095     }
1096 
1097     void applyTo(impl::DecimalQuantity&amp; quantity) const;
1098 
1099     void applyReciprocalTo(impl::DecimalQuantity&amp; quantity) const;
1100 
1101     // To allow MacroProps/MicroProps to initialize empty instances:
1102     friend struct impl::MacroProps;
1103     friend struct impl::MicroProps;
1104 
1105     // To allow NumberFormatterImpl to access isBogus() and perform other operations:
1106     friend class impl::NumberFormatterImpl;
1107 
1108     // To allow the helper class MultiplierFormatHandler access to private fields:
1109     friend class impl::MultiplierFormatHandler;
1110 
1111     // To allow access to the skeleton generation code:
1112     friend class impl::GeneratorHelpers;
1113 
1114     // To allow access to parsing code:
1115     friend class ::icu::numparse::impl::NumberParserImpl;
1116     friend class ::icu::numparse::impl::MultiplierParseHandler;
1117 };
1118 
1119 namespace impl {
1120 
1121 // Do not enclose entire SymbolsWrapper with #ifndef U_HIDE_INTERNAL_API, needed for a protected field
1122 /** @internal */
1123 class U_I18N_API SymbolsWrapper : public UMemory {
1124   public:
1125     /** @internal */
1126     SymbolsWrapper() : fType(SYMPTR_NONE), fPtr{nullptr} {}
1127 
1128     /** @internal */
1129     SymbolsWrapper(const SymbolsWrapper &amp;other);
1130 
1131     /** @internal */
1132     SymbolsWrapper &amp;operator=(const SymbolsWrapper &amp;other);
1133 
1134     /** @internal */
1135     SymbolsWrapper(SymbolsWrapper&amp;&amp; src) U_NOEXCEPT;
1136 
1137     /** @internal */
1138     SymbolsWrapper &amp;operator=(SymbolsWrapper&amp;&amp; src) U_NOEXCEPT;
1139 
1140     /** @internal */
1141     ~SymbolsWrapper();
1142 
1143 #ifndef U_HIDE_INTERNAL_API
1144 
1145     /**
1146      * The provided object is copied, but we do not adopt it.
1147      * @internal
1148      */
1149     void setTo(const DecimalFormatSymbols &amp;dfs);
1150 
1151     /**
1152      * Adopt the provided object.
1153      * @internal
1154      */
1155     void setTo(const NumberingSystem *ns);
1156 
1157     /**
1158      * Whether the object is currently holding a DecimalFormatSymbols.
1159      * @internal
1160      */
1161     bool isDecimalFormatSymbols() const;
1162 
1163     /**
1164      * Whether the object is currently holding a NumberingSystem.
1165      * @internal
1166      */
1167     bool isNumberingSystem() const;
1168 
1169     /**
1170      * Get the DecimalFormatSymbols pointer. No ownership change.
1171      * @internal
1172      */
1173     const DecimalFormatSymbols *getDecimalFormatSymbols() const;
1174 
1175     /**
1176      * Get the NumberingSystem pointer. No ownership change.
1177      * @internal
1178      */
1179     const NumberingSystem *getNumberingSystem() const;
1180 
1181 #endif  // U_HIDE_INTERNAL_API
1182 
1183     /** @internal */
1184     UBool copyErrorTo(UErrorCode &amp;status) const {
1185         if (fType == SYMPTR_DFS &amp;&amp; fPtr.dfs == nullptr) {
1186             status = U_MEMORY_ALLOCATION_ERROR;
1187             return TRUE;
1188         } else if (fType == SYMPTR_NS &amp;&amp; fPtr.ns == nullptr) {
1189             status = U_MEMORY_ALLOCATION_ERROR;
1190             return TRUE;
1191         }
1192         return FALSE;
1193     }
1194 
1195   private:
1196     enum SymbolsPointerType {
1197         SYMPTR_NONE, SYMPTR_DFS, SYMPTR_NS
1198     } fType;
1199 
1200     union {
1201         const DecimalFormatSymbols *dfs;
1202         const NumberingSystem *ns;
1203     } fPtr;
1204 
1205     void doCopyFrom(const SymbolsWrapper &amp;other);
1206 
1207     void doMoveFrom(SymbolsWrapper&amp;&amp; src);
1208 
1209     void doCleanup();
1210 };
1211 
1212 // Do not enclose entire Grouper with #ifndef U_HIDE_INTERNAL_API, needed for a protected field
1213 /** @internal */
1214 class U_I18N_API Grouper : public UMemory {
1215   public:
1216 #ifndef U_HIDE_INTERNAL_API
1217     /** @internal */
<a name="37" id="anc37"></a><span class="line-modified">1218     static Grouper forStrategy(UNumberGroupingStrategy grouping);</span>
1219 
1220     /**
1221      * Resolve the values in Properties to a Grouper object.
1222      * @internal
1223      */
1224     static Grouper forProperties(const DecimalFormatProperties&amp; properties);
1225 
1226     // Future: static Grouper forProperties(DecimalFormatProperties&amp; properties);
1227 
1228     /** @internal */
<a name="38" id="anc38"></a><span class="line-modified">1229     Grouper(int16_t grouping1, int16_t grouping2, int16_t minGrouping, UNumberGroupingStrategy strategy)</span>
1230             : fGrouping1(grouping1),
1231               fGrouping2(grouping2),
1232               fMinGrouping(minGrouping),
1233               fStrategy(strategy) {}
1234 #endif  // U_HIDE_INTERNAL_API
1235 
1236     /** @internal */
1237     int16_t getPrimary() const;
1238 
1239     /** @internal */
1240     int16_t getSecondary() const;
1241 
1242   private:
1243     /**
1244      * The grouping sizes, with the following special values:
1245      * &lt;ul&gt;
1246      * &lt;li&gt;-1 = no grouping
1247      * &lt;li&gt;-2 = needs locale data
1248      * &lt;li&gt;-4 = fall back to Western grouping if not in locale
1249      * &lt;/ul&gt;
1250      */
1251     int16_t fGrouping1;
1252     int16_t fGrouping2;
1253 
1254     /**
1255      * The minimum grouping size, with the following special values:
1256      * &lt;ul&gt;
1257      * &lt;li&gt;-2 = needs locale data
1258      * &lt;li&gt;-3 = no less than 2
1259      * &lt;/ul&gt;
1260      */
1261     int16_t fMinGrouping;
1262 
1263     /**
<a name="39" id="anc39"></a><span class="line-modified">1264      * The UNumberGroupingStrategy that was used to create this Grouper, or UNUM_GROUPING_COUNT if this</span>
<span class="line-modified">1265      * was not created from a UNumberGroupingStrategy.</span>
1266      */
<a name="40" id="anc40"></a><span class="line-modified">1267     UNumberGroupingStrategy fStrategy;</span>
1268 
<a name="41" id="anc41"></a><span class="line-modified">1269     Grouper() : fGrouping1(-3) {}</span>
1270 
1271     bool isBogus() const {
1272         return fGrouping1 == -3;
1273     }
1274 
1275     /** NON-CONST: mutates the current instance. */
1276     void setLocaleData(const impl::ParsedPatternInfo &amp;patternInfo, const Locale&amp; locale);
1277 
1278     bool groupAtPosition(int32_t position, const impl::DecimalQuantity &amp;value) const;
1279 
1280     // To allow MacroProps/MicroProps to initialize empty instances:
1281     friend struct MacroProps;
1282     friend struct MicroProps;
1283 
1284     // To allow NumberFormatterImpl to access isBogus() and perform other operations:
1285     friend class NumberFormatterImpl;
1286 
1287     // To allow NumberParserImpl to perform setLocaleData():
1288     friend class ::icu::numparse::impl::NumberParserImpl;
1289 
1290     // To allow access to the skeleton generation code:
1291     friend class impl::GeneratorHelpers;
1292 };
1293 
1294 // Do not enclose entire Padder with #ifndef U_HIDE_INTERNAL_API, needed for a protected field
1295 /** @internal */
1296 class U_I18N_API Padder : public UMemory {
1297   public:
1298 #ifndef U_HIDE_INTERNAL_API
1299     /** @internal */
1300     static Padder none();
1301 
1302     /** @internal */
1303     static Padder codePoints(UChar32 cp, int32_t targetWidth, UNumberFormatPadPosition position);
1304 #endif  // U_HIDE_INTERNAL_API
1305 
1306     /** @internal */
1307     static Padder forProperties(const DecimalFormatProperties&amp; properties);
1308 
1309   private:
1310     UChar32 fWidth;  // -3 = error; -2 = bogus; -1 = no padding
1311     union {
1312         struct {
1313             int32_t fCp;
1314             UNumberFormatPadPosition fPosition;
1315         } padding;
1316         UErrorCode errorCode;
1317     } fUnion;
1318 
1319     Padder(UChar32 cp, int32_t width, UNumberFormatPadPosition position);
1320 
1321     Padder(int32_t width);
1322 
1323     Padder(UErrorCode errorCode) : fWidth(-3) { // NOLINT
1324         fUnion.errorCode = errorCode;
1325     }
1326 
1327     Padder() : fWidth(-2) {} // NOLINT
1328 
1329     bool isBogus() const {
1330         return fWidth == -2;
1331     }
1332 
1333     UBool copyErrorTo(UErrorCode &amp;status) const {
1334         if (fWidth == -3) {
1335             status = fUnion.errorCode;
1336             return TRUE;
1337         }
1338         return FALSE;
1339     }
1340 
1341     bool isValid() const {
1342         return fWidth &gt; 0;
1343     }
1344 
1345     int32_t padAndApply(const impl::Modifier &amp;mod1, const impl::Modifier &amp;mod2,
1346                         impl::NumberStringBuilder &amp;string, int32_t leftIndex, int32_t rightIndex,
1347                         UErrorCode &amp;status) const;
1348 
1349     // To allow MacroProps/MicroProps to initialize empty instances:
1350     friend struct MacroProps;
1351     friend struct MicroProps;
1352 
1353     // To allow NumberFormatterImpl to access isBogus() and perform other operations:
1354     friend class impl::NumberFormatterImpl;
1355 
1356     // To allow access to the skeleton generation code:
1357     friend class impl::GeneratorHelpers;
1358 };
1359 
1360 // Do not enclose entire MacroProps with #ifndef U_HIDE_INTERNAL_API, needed for a protected field
1361 /** @internal */
1362 struct U_I18N_API MacroProps : public UMemory {
1363     /** @internal */
1364     Notation notation;
1365 
1366     /** @internal */
1367     MeasureUnit unit; // = NoUnit::base();
1368 
1369     /** @internal */
1370     MeasureUnit perUnit; // = NoUnit::base();
1371 
1372     /** @internal */
1373     Precision precision;  // = Precision();  (bogus)
1374 
1375     /** @internal */
1376     UNumberFormatRoundingMode roundingMode = UNUM_ROUND_HALFEVEN;
1377 
1378     /** @internal */
1379     Grouper grouper;  // = Grouper();  (bogus)
1380 
1381     /** @internal */
1382     Padder padder;    // = Padder();   (bogus)
1383 
1384     /** @internal */
1385     IntegerWidth integerWidth; // = IntegerWidth(); (bogus)
1386 
1387     /** @internal */
1388     SymbolsWrapper symbols;
1389 
1390     // UNUM_XYZ_COUNT denotes null (bogus) values.
1391 
1392     /** @internal */
1393     UNumberUnitWidth unitWidth = UNUM_UNIT_WIDTH_COUNT;
1394 
1395     /** @internal */
1396     UNumberSignDisplay sign = UNUM_SIGN_COUNT;
1397 
1398     /** @internal */
1399     UNumberDecimalSeparatorDisplay decimal = UNUM_DECIMAL_SEPARATOR_COUNT;
1400 
1401     /** @internal */
1402     Scale scale;  // = Scale();  (benign value)
1403 
1404     /** @internal */
1405     const AffixPatternProvider* affixProvider = nullptr;  // no ownership
1406 
1407     /** @internal */
1408     const PluralRules* rules = nullptr;  // no ownership
1409 
1410     /** @internal */
1411     const CurrencySymbols* currencySymbols = nullptr;  // no ownership
1412 
1413     /** @internal */
<a name="42" id="anc42"></a><span class="line-modified">1414     int32_t threshold = kInternalDefaultThreshold;</span>
1415 
1416     /** @internal */
1417     Locale locale;
1418 
1419     // NOTE: Uses default copy and move constructors.
1420 
1421     /**
1422      * Check all members for errors.
1423      * @internal
1424      */
1425     bool copyErrorTo(UErrorCode &amp;status) const {
1426         return notation.copyErrorTo(status) || precision.copyErrorTo(status) ||
1427                padder.copyErrorTo(status) || integerWidth.copyErrorTo(status) ||
1428                symbols.copyErrorTo(status) || scale.copyErrorTo(status);
1429     }
1430 };
1431 
1432 } // namespace impl
1433 
1434 /**
1435  * An abstract base class for specifying settings related to number formatting. This class is implemented by
<a name="43" id="anc43"></a><span class="line-modified">1436  * {@link UnlocalizedNumberFormatter} and {@link LocalizedNumberFormatter}. This class is not intended for</span>
<span class="line-added">1437  * public subclassing.</span>
1438  */
1439 template&lt;typename Derived&gt;
1440 class U_I18N_API NumberFormatterSettings {
1441   public:
1442     /**
1443      * Specifies the notation style (simple, scientific, or compact) for rendering numbers.
1444      *
1445      * &lt;ul&gt;
1446      * &lt;li&gt;Simple notation: &quot;12,300&quot;
1447      * &lt;li&gt;Scientific notation: &quot;1.23E4&quot;
1448      * &lt;li&gt;Compact notation: &quot;12K&quot;
1449      * &lt;/ul&gt;
1450      *
1451      * &lt;p&gt;
1452      * All notation styles will be properly localized with locale data, and all notation styles are compatible with
1453      * units, rounding precisions, and other number formatter settings.
1454      *
1455      * &lt;p&gt;
1456      * Pass this method the return value of a {@link Notation} factory method. For example:
1457      *
1458      * &lt;pre&gt;
1459      * NumberFormatter::with().notation(Notation::compactShort())
1460      * &lt;/pre&gt;
1461      *
1462      * The default is to use simple notation.
1463      *
1464      * @param notation
1465      *            The notation strategy to use.
1466      * @return The fluent chain.
1467      * @see Notation
1468      * @draft ICU 60
1469      */
1470     Derived notation(const Notation &amp;notation) const &amp;;
1471 
1472     /**
1473      * Overload of notation() for use on an rvalue reference.
1474      *
1475      * @param notation
1476      *            The notation strategy to use.
1477      * @return The fluent chain.
1478      * @see #notation
1479      * @draft ICU 62
1480      */
1481     Derived notation(const Notation &amp;notation) &amp;&amp;;
1482 
1483     /**
1484      * Specifies the unit (unit of measure, currency, or percent) to associate with rendered numbers.
1485      *
1486      * &lt;ul&gt;
1487      * &lt;li&gt;Unit of measure: &quot;12.3 meters&quot;
1488      * &lt;li&gt;Currency: &quot;$12.30&quot;
1489      * &lt;li&gt;Percent: &quot;12.3%&quot;
1490      * &lt;/ul&gt;
1491      *
1492      * All units will be properly localized with locale data, and all units are compatible with notation styles,
1493      * rounding precisions, and other number formatter settings.
1494      *
<a name="44" id="anc44"></a><span class="line-modified">1495      * Pass this method any instance of {@link MeasureUnit}. For units of measure:</span>

1496      *
1497      * &lt;pre&gt;
<a name="45" id="anc45"></a><span class="line-modified">1498      * NumberFormatter::with().unit(MeasureUnit::getMeter())</span>
1499      * &lt;/pre&gt;
1500      *
1501      * Currency:
1502      *
1503      * &lt;pre&gt;
1504      * NumberFormatter::with().unit(CurrencyUnit(u&quot;USD&quot;, status))
1505      * &lt;/pre&gt;
1506      *
1507      * Percent:
1508      *
1509      * &lt;pre&gt;
1510      * NumberFormatter::with().unit(NoUnit.percent())
1511      * &lt;/pre&gt;
1512      *
1513      * See {@link #perUnit} for information on how to format strings like &quot;5 meters per second&quot;.
1514      *
1515      * The default is to render without units (equivalent to NoUnit.base()).
1516      *
1517      * @param unit
1518      *            The unit to render.
1519      * @return The fluent chain.
1520      * @see MeasureUnit
1521      * @see Currency
1522      * @see NoUnit
1523      * @see #perUnit
1524      * @draft ICU 60
1525      */
1526     Derived unit(const icu::MeasureUnit &amp;unit) const &amp;;
1527 
1528     /**
1529      * Overload of unit() for use on an rvalue reference.
1530      *
1531      * @param unit
1532      *            The unit to render.
1533      * @return The fluent chain.
1534      * @see #unit
1535      * @draft ICU 62
1536      */
1537     Derived unit(const icu::MeasureUnit &amp;unit) &amp;&amp;;
1538 
1539     /**
1540      * Like unit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory
<a name="46" id="anc46"></a><span class="line-modified">1541      * methods that return pointers that need ownership.</span>
1542      *
<a name="47" id="anc47"></a><span class="line-modified">1543      * Note: consider using the MeasureFormat factory methods that return by value.</span>


1544      *
1545      * @param unit
1546      *            The unit to render.
1547      * @return The fluent chain.
1548      * @see #unit
1549      * @see MeasureUnit
1550      * @draft ICU 60
1551      */
1552     Derived adoptUnit(icu::MeasureUnit *unit) const &amp;;
1553 
1554     /**
1555      * Overload of adoptUnit() for use on an rvalue reference.
1556      *
1557      * @param unit
1558      *            The unit to render.
1559      * @return The fluent chain.
1560      * @see #adoptUnit
1561      * @draft ICU 62
1562      */
1563     Derived adoptUnit(icu::MeasureUnit *unit) &amp;&amp;;
1564 
1565     /**
1566      * Sets a unit to be used in the denominator. For example, to format &quot;3 m/s&quot;, pass METER to the unit and SECOND to
1567      * the perUnit.
1568      *
<a name="48" id="anc48"></a><span class="line-modified">1569      * Pass this method any instance of {@link MeasureUnit}. Example:</span>
<span class="line-modified">1570      *</span>
<span class="line-added">1571      * &lt;pre&gt;</span>
<span class="line-added">1572      * NumberFormatter::with()</span>
<span class="line-added">1573      *      .unit(MeasureUnit::getMeter())</span>
<span class="line-added">1574      *      .perUnit(MeasureUnit::getSecond())</span>
<span class="line-added">1575      * &lt;/pre&gt;</span>
1576      *
1577      * The default is not to display any unit in the denominator.
1578      *
1579      * If a per-unit is specified without a primary unit via {@link #unit}, the behavior is undefined.
1580      *
1581      * @param perUnit
1582      *            The unit to render in the denominator.
1583      * @return The fluent chain
1584      * @see #unit
1585      * @draft ICU 61
1586      */
1587     Derived perUnit(const icu::MeasureUnit &amp;perUnit) const &amp;;
1588 
1589     /**
1590      * Overload of perUnit() for use on an rvalue reference.
1591      *
1592      * @param perUnit
1593      *            The unit to render in the denominator.
1594      * @return The fluent chain.
1595      * @see #perUnit
1596      * @draft ICU 62
1597      */
1598     Derived perUnit(const icu::MeasureUnit &amp;perUnit) &amp;&amp;;
1599 
1600     /**
1601      * Like perUnit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory
<a name="49" id="anc49"></a><span class="line-modified">1602      * methods that return pointers that need ownership.</span>
1603      *
<a name="50" id="anc50"></a><span class="line-modified">1604      * Note: consider using the MeasureFormat factory methods that return by value.</span>




1605      *
1606      * @param perUnit
1607      *            The unit to render in the denominator.
1608      * @return The fluent chain.
1609      * @see #perUnit
1610      * @see MeasureUnit
1611      * @draft ICU 61
1612      */
1613     Derived adoptPerUnit(icu::MeasureUnit *perUnit) const &amp;;
1614 
1615     /**
1616      * Overload of adoptPerUnit() for use on an rvalue reference.
1617      *
1618      * @param perUnit
1619      *            The unit to render in the denominator.
1620      * @return The fluent chain.
1621      * @see #adoptPerUnit
1622      * @draft ICU 62
1623      */
1624     Derived adoptPerUnit(icu::MeasureUnit *perUnit) &amp;&amp;;
1625 
1626     /**
1627      * Specifies the rounding precision to use when formatting numbers.
1628      *
1629      * &lt;ul&gt;
1630      * &lt;li&gt;Round to 3 decimal places: &quot;3.142&quot;
1631      * &lt;li&gt;Round to 3 significant figures: &quot;3.14&quot;
1632      * &lt;li&gt;Round to the closest nickel: &quot;3.15&quot;
1633      * &lt;li&gt;Do not perform rounding: &quot;3.1415926...&quot;
1634      * &lt;/ul&gt;
1635      *
1636      * &lt;p&gt;
1637      * Pass this method the return value of one of the factory methods on {@link Precision}. For example:
1638      *
1639      * &lt;pre&gt;
1640      * NumberFormatter::with().precision(Precision::fixedFraction(2))
1641      * &lt;/pre&gt;
1642      *
1643      * &lt;p&gt;
1644      * In most cases, the default rounding strategy is to round to 6 fraction places; i.e.,
1645      * &lt;code&gt;Precision.maxFraction(6)&lt;/code&gt;. The exceptions are if compact notation is being used, then the compact
1646      * notation rounding strategy is used (see {@link Notation#compactShort} for details), or if the unit is a currency,
1647      * then standard currency rounding is used, which varies from currency to currency (see {@link Precision#currency} for
1648      * details).
1649      *
1650      * @param precision
1651      *            The rounding precision to use.
1652      * @return The fluent chain.
1653      * @see Precision
1654      * @draft ICU 62
1655      */
1656     Derived precision(const Precision&amp; precision) const &amp;;
1657 
1658     /**
1659      * Overload of precision() for use on an rvalue reference.
1660      *
1661      * @param precision
1662      *            The rounding precision to use.
1663      * @return The fluent chain.
1664      * @see #precision
1665      * @draft ICU 62
1666      */
1667     Derived precision(const Precision&amp; precision) &amp;&amp;;
1668 
<a name="51" id="anc51"></a>









1669     /**
1670      * Specifies how to determine the direction to round a number when it has more digits than fit in the
1671      * desired precision.  When formatting 1.235:
1672      *
1673      * &lt;ul&gt;
1674      * &lt;li&gt;Ceiling rounding mode with integer precision: &quot;2&quot;
1675      * &lt;li&gt;Half-down rounding mode with 2 fixed fraction digits: &quot;1.23&quot;
1676      * &lt;li&gt;Half-up rounding mode with 2 fixed fraction digits: &quot;1.24&quot;
1677      * &lt;/ul&gt;
1678      *
1679      * The default is HALF_EVEN. For more information on rounding mode, see the ICU userguide here:
1680      *
1681      * http://userguide.icu-project.org/formatparse/numbers/rounding-modes
1682      *
1683      * @param roundingMode The rounding mode to use.
1684      * @return The fluent chain.
1685      * @draft ICU 62
1686      */
1687     Derived roundingMode(UNumberFormatRoundingMode roundingMode) const &amp;;
1688 
1689     /**
1690      * Overload of roundingMode() for use on an rvalue reference.
1691      *
1692      * @param roundingMode The rounding mode to use.
1693      * @return The fluent chain.
1694      * @see #roundingMode
1695      * @draft ICU 62
1696      */
1697     Derived roundingMode(UNumberFormatRoundingMode roundingMode) &amp;&amp;;
1698 
1699     /**
1700      * Specifies the grouping strategy to use when formatting numbers.
1701      *
1702      * &lt;ul&gt;
1703      * &lt;li&gt;Default grouping: &quot;12,300&quot; and &quot;1,230&quot;
1704      * &lt;li&gt;Grouping with at least 2 digits: &quot;12,300&quot; and &quot;1230&quot;
1705      * &lt;li&gt;No grouping: &quot;12300&quot; and &quot;1230&quot;
1706      * &lt;/ul&gt;
1707      *
1708      * &lt;p&gt;
1709      * The exact grouping widths will be chosen based on the locale.
1710      *
1711      * &lt;p&gt;
<a name="52" id="anc52"></a><span class="line-modified">1712      * Pass this method an element from the {@link UNumberGroupingStrategy} enum. For example:</span>
1713      *
1714      * &lt;pre&gt;
1715      * NumberFormatter::with().grouping(UNUM_GROUPING_MIN2)
1716      * &lt;/pre&gt;
1717      *
1718      * The default is to perform grouping according to locale data; most locales, but not all locales,
1719      * enable it by default.
1720      *
1721      * @param strategy
1722      *            The grouping strategy to use.
1723      * @return The fluent chain.
1724      * @draft ICU 61
1725      */
<a name="53" id="anc53"></a><span class="line-modified">1726     Derived grouping(UNumberGroupingStrategy strategy) const &amp;;</span>
1727 
1728     /**
1729      * Overload of grouping() for use on an rvalue reference.
1730      *
1731      * @param strategy
1732      *            The grouping strategy to use.
1733      * @return The fluent chain.
1734      * @see #grouping
<a name="54" id="anc54"></a>
1735      * @draft ICU 62
1736      */
<a name="55" id="anc55"></a><span class="line-modified">1737     Derived grouping(UNumberGroupingStrategy strategy) &amp;&amp;;</span>
1738 
1739     /**
1740      * Specifies the minimum and maximum number of digits to render before the decimal mark.
1741      *
1742      * &lt;ul&gt;
1743      * &lt;li&gt;Zero minimum integer digits: &quot;.08&quot;
1744      * &lt;li&gt;One minimum integer digit: &quot;0.08&quot;
1745      * &lt;li&gt;Two minimum integer digits: &quot;00.08&quot;
1746      * &lt;/ul&gt;
1747      *
1748      * &lt;p&gt;
<a name="56" id="anc56"></a><span class="line-modified">1749      * Pass this method the return value of {@link IntegerWidth#zeroFillTo}. For example:</span>
1750      *
1751      * &lt;pre&gt;
1752      * NumberFormatter::with().integerWidth(IntegerWidth::zeroFillTo(2))
1753      * &lt;/pre&gt;
1754      *
1755      * The default is to have one minimum integer digit.
1756      *
1757      * @param style
1758      *            The integer width to use.
1759      * @return The fluent chain.
1760      * @see IntegerWidth
1761      * @draft ICU 60
1762      */
1763     Derived integerWidth(const IntegerWidth &amp;style) const &amp;;
1764 
1765     /**
1766      * Overload of integerWidth() for use on an rvalue reference.
1767      *
1768      * @param style
1769      *            The integer width to use.
1770      * @return The fluent chain.
1771      * @see #integerWidth
1772      * @draft ICU 62
1773      */
1774     Derived integerWidth(const IntegerWidth &amp;style) &amp;&amp;;
1775 
1776     /**
1777      * Specifies the symbols (decimal separator, grouping separator, percent sign, numerals, etc.) to use when rendering
1778      * numbers.
1779      *
1780      * &lt;ul&gt;
1781      * &lt;li&gt;&lt;em&gt;en_US&lt;/em&gt; symbols: &quot;12,345.67&quot;
1782      * &lt;li&gt;&lt;em&gt;fr_FR&lt;/em&gt; symbols: &quot;12&amp;nbsp;345,67&quot;
1783      * &lt;li&gt;&lt;em&gt;de_CH&lt;/em&gt; symbols: &quot;12’345.67&quot;
1784      * &lt;li&gt;&lt;em&gt;my_MY&lt;/em&gt; symbols: &quot;၁၂,၃၄၅.၆၇&quot;
1785      * &lt;/ul&gt;
1786      *
1787      * &lt;p&gt;
1788      * Pass this method an instance of {@link DecimalFormatSymbols}. For example:
1789      *
1790      * &lt;pre&gt;
1791      * NumberFormatter::with().symbols(DecimalFormatSymbols(Locale(&quot;de_CH&quot;), status))
1792      * &lt;/pre&gt;
1793      *
1794      * &lt;p&gt;
1795      * &lt;strong&gt;Note:&lt;/strong&gt; DecimalFormatSymbols automatically chooses the best numbering system based on the locale.
1796      * In the examples above, the first three are using the Latin numbering system, and the fourth is using the Myanmar
1797      * numbering system.
1798      *
1799      * &lt;p&gt;
1800      * &lt;strong&gt;Note:&lt;/strong&gt; The instance of DecimalFormatSymbols will be copied: changes made to the symbols object
1801      * after passing it into the fluent chain will not be seen.
1802      *
1803      * &lt;p&gt;
1804      * &lt;strong&gt;Note:&lt;/strong&gt; Calling this method will override any previously specified DecimalFormatSymbols
1805      * or NumberingSystem.
1806      *
1807      * &lt;p&gt;
1808      * The default is to choose the symbols based on the locale specified in the fluent chain.
1809      *
1810      * @param symbols
1811      *            The DecimalFormatSymbols to use.
1812      * @return The fluent chain.
1813      * @see DecimalFormatSymbols
1814      * @draft ICU 60
1815      */
1816     Derived symbols(const DecimalFormatSymbols &amp;symbols) const &amp;;
1817 
1818     /**
1819      * Overload of symbols() for use on an rvalue reference.
1820      *
1821      * @param symbols
1822      *            The DecimalFormatSymbols to use.
1823      * @return The fluent chain.
1824      * @see #symbols
1825      * @draft ICU 62
1826      */
1827     Derived symbols(const DecimalFormatSymbols &amp;symbols) &amp;&amp;;
1828 
1829     /**
1830      * Specifies that the given numbering system should be used when fetching symbols.
1831      *
1832      * &lt;ul&gt;
1833      * &lt;li&gt;Latin numbering system: &quot;12,345&quot;
1834      * &lt;li&gt;Myanmar numbering system: &quot;၁၂,၃၄၅&quot;
1835      * &lt;li&gt;Math Sans Bold numbering system: &quot;𝟭𝟮,𝟯𝟰𝟱&quot;
1836      * &lt;/ul&gt;
1837      *
1838      * &lt;p&gt;
1839      * Pass this method an instance of {@link NumberingSystem}. For example, to force the locale to always use the Latin
1840      * alphabet numbering system (ASCII digits):
1841      *
1842      * &lt;pre&gt;
1843      * NumberFormatter::with().adoptSymbols(NumberingSystem::createInstanceByName(&quot;latn&quot;, status))
1844      * &lt;/pre&gt;
1845      *
1846      * &lt;p&gt;
1847      * &lt;strong&gt;Note:&lt;/strong&gt; Calling this method will override any previously specified DecimalFormatSymbols
1848      * or NumberingSystem.
1849      *
1850      * &lt;p&gt;
1851      * The default is to choose the best numbering system for the locale.
1852      *
1853      * &lt;p&gt;
1854      * This method takes ownership of a pointer in order to work nicely with the NumberingSystem factory methods.
1855      *
1856      * @param symbols
1857      *            The NumberingSystem to use.
1858      * @return The fluent chain.
1859      * @see NumberingSystem
1860      * @draft ICU 60
1861      */
1862     Derived adoptSymbols(NumberingSystem *symbols) const &amp;;
1863 
1864     /**
1865      * Overload of adoptSymbols() for use on an rvalue reference.
1866      *
1867      * @param symbols
1868      *            The NumberingSystem to use.
1869      * @return The fluent chain.
1870      * @see #adoptSymbols
1871      * @draft ICU 62
1872      */
1873     Derived adoptSymbols(NumberingSystem *symbols) &amp;&amp;;
1874 
1875     /**
1876      * Sets the width of the unit (measure unit or currency).  Most common values:
1877      *
1878      * &lt;ul&gt;
1879      * &lt;li&gt;Short: &quot;$12.00&quot;, &quot;12 m&quot;
1880      * &lt;li&gt;ISO Code: &quot;USD 12.00&quot;
1881      * &lt;li&gt;Full name: &quot;12.00 US dollars&quot;, &quot;12 meters&quot;
1882      * &lt;/ul&gt;
1883      *
1884      * &lt;p&gt;
1885      * Pass an element from the {@link UNumberUnitWidth} enum to this setter. For example:
1886      *
1887      * &lt;pre&gt;
1888      * NumberFormatter::with().unitWidth(UNumberUnitWidth::UNUM_UNIT_WIDTH_FULL_NAME)
1889      * &lt;/pre&gt;
1890      *
1891      * &lt;p&gt;
1892      * The default is the SHORT width.
1893      *
1894      * @param width
1895      *            The width to use when rendering numbers.
1896      * @return The fluent chain
1897      * @see UNumberUnitWidth
1898      * @draft ICU 60
1899      */
1900     Derived unitWidth(UNumberUnitWidth width) const &amp;;
1901 
1902     /**
1903      * Overload of unitWidth() for use on an rvalue reference.
1904      *
1905      * @param width
1906      *            The width to use when rendering numbers.
1907      * @return The fluent chain.
1908      * @see #unitWidth
1909      * @draft ICU 62
1910      */
1911     Derived unitWidth(UNumberUnitWidth width) &amp;&amp;;
1912 
1913     /**
1914      * Sets the plus/minus sign display strategy. Most common values:
1915      *
1916      * &lt;ul&gt;
1917      * &lt;li&gt;Auto: &quot;123&quot;, &quot;-123&quot;
1918      * &lt;li&gt;Always: &quot;+123&quot;, &quot;-123&quot;
1919      * &lt;li&gt;Accounting: &quot;$123&quot;, &quot;($123)&quot;
1920      * &lt;/ul&gt;
1921      *
1922      * &lt;p&gt;
1923      * Pass an element from the {@link UNumberSignDisplay} enum to this setter. For example:
1924      *
1925      * &lt;pre&gt;
1926      * NumberFormatter::with().sign(UNumberSignDisplay::UNUM_SIGN_ALWAYS)
1927      * &lt;/pre&gt;
1928      *
1929      * &lt;p&gt;
1930      * The default is AUTO sign display.
1931      *
1932      * @param style
1933      *            The sign display strategy to use when rendering numbers.
1934      * @return The fluent chain
1935      * @see UNumberSignDisplay
1936      * @draft ICU 60
1937      */
1938     Derived sign(UNumberSignDisplay style) const &amp;;
1939 
1940     /**
1941      * Overload of sign() for use on an rvalue reference.
1942      *
1943      * @param style
1944      *            The sign display strategy to use when rendering numbers.
1945      * @return The fluent chain.
1946      * @see #sign
1947      * @draft ICU 62
1948      */
1949     Derived sign(UNumberSignDisplay style) &amp;&amp;;
1950 
1951     /**
1952      * Sets the decimal separator display strategy. This affects integer numbers with no fraction part. Most common
1953      * values:
1954      *
1955      * &lt;ul&gt;
1956      * &lt;li&gt;Auto: &quot;1&quot;
1957      * &lt;li&gt;Always: &quot;1.&quot;
1958      * &lt;/ul&gt;
1959      *
1960      * &lt;p&gt;
1961      * Pass an element from the {@link UNumberDecimalSeparatorDisplay} enum to this setter. For example:
1962      *
1963      * &lt;pre&gt;
1964      * NumberFormatter::with().decimal(UNumberDecimalSeparatorDisplay::UNUM_DECIMAL_SEPARATOR_ALWAYS)
1965      * &lt;/pre&gt;
1966      *
1967      * &lt;p&gt;
1968      * The default is AUTO decimal separator display.
1969      *
1970      * @param style
1971      *            The decimal separator display strategy to use when rendering numbers.
1972      * @return The fluent chain
1973      * @see UNumberDecimalSeparatorDisplay
1974      * @draft ICU 60
1975      */
1976     Derived decimal(UNumberDecimalSeparatorDisplay style) const &amp;;
1977 
1978     /**
1979      * Overload of decimal() for use on an rvalue reference.
1980      *
1981      * @param style
1982      *            The decimal separator display strategy to use when rendering numbers.
1983      * @return The fluent chain.
1984      * @see #decimal
1985      * @draft ICU 62
1986      */
1987     Derived decimal(UNumberDecimalSeparatorDisplay style) &amp;&amp;;
1988 
1989     /**
1990      * Sets a scale (multiplier) to be used to scale the number by an arbitrary amount before formatting.
1991      * Most common values:
1992      *
1993      * &lt;ul&gt;
1994      * &lt;li&gt;Multiply by 100: useful for percentages.
1995      * &lt;li&gt;Multiply by an arbitrary value: useful for unit conversions.
1996      * &lt;/ul&gt;
1997      *
1998      * &lt;p&gt;
1999      * Pass an element from a {@link Scale} factory method to this setter. For example:
2000      *
2001      * &lt;pre&gt;
2002      * NumberFormatter::with().scale(Scale::powerOfTen(2))
2003      * &lt;/pre&gt;
2004      *
2005      * &lt;p&gt;
2006      * The default is to not apply any multiplier.
2007      *
2008      * @param scale
2009      *            The scale to apply when rendering numbers.
2010      * @return The fluent chain
2011      * @draft ICU 62
2012      */
2013     Derived scale(const Scale &amp;scale) const &amp;;
2014 
2015     /**
2016      * Overload of scale() for use on an rvalue reference.
2017      *
2018      * @param scale
2019      *            The scale to apply when rendering numbers.
2020      * @return The fluent chain.
2021      * @see #scale
2022      * @draft ICU 62
2023      */
2024     Derived scale(const Scale &amp;scale) &amp;&amp;;
2025 
2026 #ifndef U_HIDE_INTERNAL_API
2027 
2028     /**
2029      * Set the padding strategy. May be added in the future; see #13338.
2030      *
2031      * @internal ICU 60: This API is ICU internal only.
2032      */
2033     Derived padding(const impl::Padder &amp;padder) const &amp;;
2034 
2035     /** @internal */
2036     Derived padding(const impl::Padder &amp;padder) &amp;&amp;;
2037 
2038     /**
2039      * Internal fluent setter to support a custom regulation threshold. A threshold of 1 causes the data structures to
2040      * be built right away. A threshold of 0 prevents the data structures from being built.
2041      *
2042      * @internal ICU 60: This API is ICU internal only.
2043      */
2044     Derived threshold(int32_t threshold) const &amp;;
2045 
2046     /** @internal */
2047     Derived threshold(int32_t threshold) &amp;&amp;;
2048 
2049     /**
2050      * Internal fluent setter to overwrite the entire macros object.
2051      *
2052      * @internal ICU 60: This API is ICU internal only.
2053      */
2054     Derived macros(const impl::MacroProps&amp; macros) const &amp;;
2055 
2056     /** @internal */
2057     Derived macros(const impl::MacroProps&amp; macros) &amp;&amp;;
2058 
2059     /** @internal */
2060     Derived macros(impl::MacroProps&amp;&amp; macros) const &amp;;
2061 
2062     /** @internal */
2063     Derived macros(impl::MacroProps&amp;&amp; macros) &amp;&amp;;
2064 
2065 #endif  /* U_HIDE_INTERNAL_API */
2066 
2067     /**
2068      * Creates a skeleton string representation of this number formatter. A skeleton string is a
2069      * locale-agnostic serialized form of a number formatter.
2070      *
2071      * Not all options are capable of being represented in the skeleton string; for example, a
2072      * DecimalFormatSymbols object. If any such option is encountered, the error code is set to
2073      * U_UNSUPPORTED_ERROR.
2074      *
2075      * The returned skeleton is in normalized form, such that two number formatters with equivalent
2076      * behavior should produce the same skeleton.
2077      *
2078      * @return A number skeleton string with behavior corresponding to this number formatter.
2079      * @draft ICU 62
2080      */
2081     UnicodeString toSkeleton(UErrorCode&amp; status) const;
2082 
<a name="57" id="anc57"></a><span class="line-added">2083     /**</span>
<span class="line-added">2084      * Returns the current (Un)LocalizedNumberFormatter as a LocalPointer</span>
<span class="line-added">2085      * wrapping a heap-allocated copy of the current object.</span>
<span class="line-added">2086      *</span>
<span class="line-added">2087      * This is equivalent to new-ing the move constructor with a value object</span>
<span class="line-added">2088      * as the argument.</span>
<span class="line-added">2089      *</span>
<span class="line-added">2090      * @return A wrapped (Un)LocalizedNumberFormatter pointer, or a wrapped</span>
<span class="line-added">2091      *         nullptr on failure.</span>
<span class="line-added">2092      * @draft ICU 64</span>
<span class="line-added">2093      */</span>
<span class="line-added">2094     LocalPointer&lt;Derived&gt; clone() const &amp;;</span>
<span class="line-added">2095 </span>
<span class="line-added">2096     /**</span>
<span class="line-added">2097      * Overload of clone for use on an rvalue reference.</span>
<span class="line-added">2098      *</span>
<span class="line-added">2099      * @return A wrapped (Un)LocalizedNumberFormatter pointer, or a wrapped</span>
<span class="line-added">2100      *         nullptr on failure.</span>
<span class="line-added">2101      * @draft ICU 64</span>
<span class="line-added">2102      */</span>
<span class="line-added">2103     LocalPointer&lt;Derived&gt; clone() &amp;&amp;;</span>
<span class="line-added">2104 </span>
2105     /**
2106      * Sets the UErrorCode if an error occurred in the fluent chain.
2107      * Preserves older error codes in the outErrorCode.
2108      * @return TRUE if U_FAILURE(outErrorCode)
2109      * @draft ICU 60
2110      */
2111     UBool copyErrorTo(UErrorCode &amp;outErrorCode) const {
2112         if (U_FAILURE(outErrorCode)) {
2113             // Do not overwrite the older error code
2114             return TRUE;
2115         }
2116         fMacros.copyErrorTo(outErrorCode);
2117         return U_FAILURE(outErrorCode);
<a name="58" id="anc58"></a><span class="line-modified">2118     }</span>
2119 
2120     // NOTE: Uses default copy and move constructors.
2121 
<a name="59" id="anc59"></a><span class="line-modified">2122   private:</span>
2123     impl::MacroProps fMacros;
2124 
<a name="60" id="anc60"></a>
2125     // Don&#39;t construct me directly!  Use (Un)LocalizedNumberFormatter.
2126     NumberFormatterSettings() = default;
2127 
2128     friend class LocalizedNumberFormatter;
2129     friend class UnlocalizedNumberFormatter;
<a name="61" id="anc61"></a><span class="line-added">2130 </span>
<span class="line-added">2131     // Give NumberRangeFormatter access to the MacroProps</span>
<span class="line-added">2132     friend void impl::touchRangeLocales(impl::RangeMacroProps&amp; macros);</span>
<span class="line-added">2133     friend class impl::NumberRangeFormatterImpl;</span>
2134 };
2135 
2136 /**
2137  * A NumberFormatter that does not yet have a locale. In order to format numbers, a locale must be specified.
2138  *
<a name="62" id="anc62"></a><span class="line-added">2139  * Instances of this class are immutable and thread-safe.</span>
<span class="line-added">2140  *</span>
2141  * @see NumberFormatter
2142  * @draft ICU 60
2143  */
2144 class U_I18N_API UnlocalizedNumberFormatter
2145         : public NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;, public UMemory {
2146 
2147   public:
2148     /**
2149      * Associate the given locale with the number formatter. The locale is used for picking the appropriate symbols,
2150      * formats, and other data for number display.
2151      *
<a name="63" id="anc63"></a>






2152      * @param locale
2153      *            The locale to use when loading data for number formatting.
2154      * @return The fluent chain.
2155      * @draft ICU 60
2156      */
2157     LocalizedNumberFormatter locale(const icu::Locale &amp;locale) const &amp;;
2158 
2159     /**
2160      * Overload of locale() for use on an rvalue reference.
2161      *
2162      * @param locale
2163      *            The locale to use when loading data for number formatting.
2164      * @return The fluent chain.
2165      * @see #locale
2166      * @draft ICU 62
2167      */
2168     LocalizedNumberFormatter locale(const icu::Locale &amp;locale) &amp;&amp;;
2169 
2170     /**
2171      * Default constructor: puts the formatter into a valid but undefined state.
2172      *
2173      * @draft ICU 62
2174      */
2175     UnlocalizedNumberFormatter() = default;
2176 
<a name="64" id="anc64"></a>
2177     /**
2178      * Returns a copy of this UnlocalizedNumberFormatter.
2179      * @draft ICU 60
2180      */
2181     UnlocalizedNumberFormatter(const UnlocalizedNumberFormatter &amp;other);
2182 
2183     /**
2184      * Move constructor:
2185      * The source UnlocalizedNumberFormatter will be left in a valid but undefined state.
2186      * @draft ICU 62
2187      */
2188     UnlocalizedNumberFormatter(UnlocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2189 
2190     /**
2191      * Copy assignment operator.
2192      * @draft ICU 62
2193      */
2194     UnlocalizedNumberFormatter&amp; operator=(const UnlocalizedNumberFormatter&amp; other);
2195 
2196     /**
2197      * Move assignment operator:
2198      * The source UnlocalizedNumberFormatter will be left in a valid but undefined state.
2199      * @draft ICU 62
2200      */
2201     UnlocalizedNumberFormatter&amp; operator=(UnlocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2202 
2203   private:
2204     explicit UnlocalizedNumberFormatter(const NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;&amp; other);
2205 
2206     explicit UnlocalizedNumberFormatter(
2207             NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;&amp;&amp; src) U_NOEXCEPT;
2208 
2209     // To give the fluent setters access to this class&#39;s constructor:
2210     friend class NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;;
2211 
2212     // To give NumberFormatter::with() access to this class&#39;s constructor:
2213     friend class NumberFormatter;
2214 };
2215 
2216 /**
2217  * A NumberFormatter that has a locale associated with it; this means .format() methods are available.
2218  *
<a name="65" id="anc65"></a><span class="line-added">2219  * Instances of this class are immutable and thread-safe.</span>
<span class="line-added">2220  *</span>
2221  * @see NumberFormatter
2222  * @draft ICU 60
2223  */
2224 class U_I18N_API LocalizedNumberFormatter
2225         : public NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;, public UMemory {
2226   public:
2227     /**
2228      * Format the given integer number to a string using the settings specified in the NumberFormatter fluent
2229      * setting chain.
2230      *
2231      * @param value
2232      *            The number to format.
2233      * @param status
2234      *            Set to an ErrorCode if one occurred in the setter chain or during formatting.
2235      * @return A FormattedNumber object; call .toString() to get the string.
2236      * @draft ICU 60
2237      */
2238     FormattedNumber formatInt(int64_t value, UErrorCode &amp;status) const;
2239 
2240     /**
2241      * Format the given float or double to a string using the settings specified in the NumberFormatter fluent setting
2242      * chain.
2243      *
2244      * @param value
2245      *            The number to format.
2246      * @param status
2247      *            Set to an ErrorCode if one occurred in the setter chain or during formatting.
2248      * @return A FormattedNumber object; call .toString() to get the string.
2249      * @draft ICU 60
2250      */
2251     FormattedNumber formatDouble(double value, UErrorCode &amp;status) const;
2252 
2253     /**
2254      * Format the given decimal number to a string using the settings
2255      * specified in the NumberFormatter fluent setting chain.
2256      * The syntax of the unformatted number is a &quot;numeric string&quot;
2257      * as defined in the Decimal Arithmetic Specification, available at
2258      * http://speleotrove.com/decimal
2259      *
2260      * @param value
2261      *            The number to format.
2262      * @param status
2263      *            Set to an ErrorCode if one occurred in the setter chain or during formatting.
2264      * @return A FormattedNumber object; call .toString() to get the string.
2265      * @draft ICU 60
2266      */
2267     FormattedNumber formatDecimal(StringPiece value, UErrorCode&amp; status) const;
2268 
2269 #ifndef U_HIDE_INTERNAL_API
2270 
2271     /** Internal method.
2272      * @internal
2273      */
2274     FormattedNumber formatDecimalQuantity(const impl::DecimalQuantity&amp; dq, UErrorCode&amp; status) const;
2275 
2276     /** Internal method for DecimalFormat compatibility.
2277      * @internal
2278      */
2279     void getAffixImpl(bool isPrefix, bool isNegative, UnicodeString&amp; result, UErrorCode&amp; status) const;
2280 
2281     /**
2282      * Internal method for testing.
2283      * @internal
2284      */
2285     const impl::NumberFormatterImpl* getCompiled() const;
2286 
2287     /**
2288      * Internal method for testing.
2289      * @internal
2290      */
2291     int32_t getCallCount() const;
2292 
<a name="66" id="anc66"></a><span class="line-modified">2293 #endif  /* U_HIDE_INTERNAL_API */</span>
2294 
2295     /**
2296      * Creates a representation of this LocalizedNumberFormat as an icu::Format, enabling the use
2297      * of this number formatter with APIs that need an object of that type, such as MessageFormat.
2298      *
2299      * This API is not intended to be used other than for enabling API compatibility. The formatDouble,
2300      * formatInt, and formatDecimal methods should normally be used when formatting numbers, not the Format
2301      * object returned by this method.
2302      *
2303      * The caller owns the returned object and must delete it when finished.
2304      *
2305      * @return A Format wrapping this LocalizedNumberFormatter.
2306      * @draft ICU 62
2307      */
2308     Format* toFormat(UErrorCode&amp; status) const;
2309 
2310     /**
2311      * Default constructor: puts the formatter into a valid but undefined state.
2312      *
2313      * @draft ICU 62
2314      */
2315     LocalizedNumberFormatter() = default;
2316 
<a name="67" id="anc67"></a>
2317     /**
2318      * Returns a copy of this LocalizedNumberFormatter.
2319      * @draft ICU 60
2320      */
2321     LocalizedNumberFormatter(const LocalizedNumberFormatter &amp;other);
2322 
2323     /**
2324      * Move constructor:
2325      * The source LocalizedNumberFormatter will be left in a valid but undefined state.
2326      * @draft ICU 62
2327      */
2328     LocalizedNumberFormatter(LocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2329 
2330     /**
2331      * Copy assignment operator.
2332      * @draft ICU 62
2333      */
2334     LocalizedNumberFormatter&amp; operator=(const LocalizedNumberFormatter&amp; other);
2335 
2336     /**
2337      * Move assignment operator:
2338      * The source LocalizedNumberFormatter will be left in a valid but undefined state.
2339      * @draft ICU 62
2340      */
2341     LocalizedNumberFormatter&amp; operator=(LocalizedNumberFormatter&amp;&amp; src) U_NOEXCEPT;
2342 
2343 #ifndef U_HIDE_INTERNAL_API
2344 
2345     /**
2346      * This is the core entrypoint to the number formatting pipeline. It performs self-regulation: a static code path
2347      * for the first few calls, and compiling a more efficient data structure if called repeatedly.
2348      *
2349      * &lt;p&gt;
2350      * This function is very hot, being called in every call to the number formatting pipeline.
2351      *
2352      * @param results
2353      *            The results object. This method will mutate it to save the results.
<a name="68" id="anc68"></a><span class="line-added">2354      * @param status</span>
2355      * @internal
2356      */
2357     void formatImpl(impl::UFormattedNumberData *results, UErrorCode &amp;status) const;
2358 
<a name="69" id="anc69"></a><span class="line-modified">2359 #endif  /* U_HIDE_INTERNAL_API */</span>
2360 
2361     /**
2362      * Destruct this LocalizedNumberFormatter, cleaning up any memory it might own.
2363      * @draft ICU 60
2364      */
2365     ~LocalizedNumberFormatter();
2366 
2367   private:
2368     // Note: fCompiled can&#39;t be a LocalPointer because impl::NumberFormatterImpl is defined in an internal
2369     // header, and LocalPointer needs the full class definition in order to delete the instance.
2370     const impl::NumberFormatterImpl* fCompiled {nullptr};
2371     char fUnsafeCallCount[8] {};  // internally cast to u_atomic_int32_t
2372 
2373     explicit LocalizedNumberFormatter(const NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;&amp; other);
2374 
2375     explicit LocalizedNumberFormatter(NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;&amp;&amp; src) U_NOEXCEPT;
2376 
2377     LocalizedNumberFormatter(const impl::MacroProps &amp;macros, const Locale &amp;locale);
2378 
2379     LocalizedNumberFormatter(impl::MacroProps &amp;&amp;macros, const Locale &amp;locale);
2380 
<a name="70" id="anc70"></a><span class="line-added">2381     void clear();</span>
<span class="line-added">2382 </span>
2383     void lnfMoveHelper(LocalizedNumberFormatter&amp;&amp; src);
2384 
2385     /**
2386      * @return true if the compiled formatter is available.
2387      */
2388     bool computeCompiled(UErrorCode&amp; status) const;
2389 
2390     // To give the fluent setters access to this class&#39;s constructor:
2391     friend class NumberFormatterSettings&lt;UnlocalizedNumberFormatter&gt;;
2392     friend class NumberFormatterSettings&lt;LocalizedNumberFormatter&gt;;
2393 
2394     // To give UnlocalizedNumberFormatter::locale() access to this class&#39;s constructor:
2395     friend class UnlocalizedNumberFormatter;
2396 };
2397 
2398 /**
2399  * The result of a number formatting operation. This class allows the result to be exported in several data types,
2400  * including a UnicodeString and a FieldPositionIterator.
2401  *
<a name="71" id="anc71"></a><span class="line-added">2402  * Instances of this class are immutable and thread-safe.</span>
<span class="line-added">2403  *</span>
2404  * @draft ICU 60
2405  */
<a name="72" id="anc72"></a><span class="line-modified">2406 class U_I18N_API FormattedNumber : public UMemory, public FormattedValue {</span>
2407   public:
<a name="73" id="anc73"></a><span class="line-modified">2408 </span>
2409     /**
<a name="74" id="anc74"></a><span class="line-modified">2410      * Default constructor; makes an empty FormattedNumber.</span>
<span class="line-modified">2411      * @draft ICU 64</span>




2412      */
<a name="75" id="anc75"></a><span class="line-modified">2413     FormattedNumber()</span>
<span class="line-modified">2414         : fData(nullptr), fErrorCode(U_INVALID_STATE_ERROR) {}</span>
2415 
2416     /**
<a name="76" id="anc76"></a><span class="line-modified">2417      * Move constructor: Leaves the source FormattedNumber in an undefined state.</span>




2418      * @draft ICU 62
2419      */
<a name="77" id="anc77"></a><span class="line-modified">2420     FormattedNumber(FormattedNumber&amp;&amp; src) U_NOEXCEPT;</span>
<span class="line-added">2421 </span>
<span class="line-added">2422     /**</span>
<span class="line-added">2423      * Destruct an instance of FormattedNumber.</span>
<span class="line-added">2424      * @draft ICU 60</span>
<span class="line-added">2425      */</span>
<span class="line-added">2426     virtual ~FormattedNumber() U_OVERRIDE;</span>
<span class="line-added">2427 </span>
<span class="line-added">2428     /** Copying not supported; use move constructor instead. */</span>
<span class="line-added">2429     FormattedNumber(const FormattedNumber&amp;) = delete;</span>
<span class="line-added">2430 </span>
<span class="line-added">2431     /** Copying not supported; use move assignment instead. */</span>
<span class="line-added">2432     FormattedNumber&amp; operator=(const FormattedNumber&amp;) = delete;</span>
2433 
<a name="78" id="anc78"></a>
2434     /**
<a name="79" id="anc79"></a><span class="line-modified">2435      * Move assignment: Leaves the source FormattedNumber in an undefined state.</span>
<span class="line-modified">2436      * @draft ICU 62</span>







2437      */
<a name="80" id="anc80"></a><span class="line-modified">2438     FormattedNumber&amp; operator=(FormattedNumber&amp;&amp; src) U_NOEXCEPT;</span>

2439 
<a name="81" id="anc81"></a><span class="line-added">2440     // Copybrief: this method is older than the parent method</span>
2441     /**
<a name="82" id="anc82"></a><span class="line-modified">2442      * @copybrief FormattedValue::toString()</span>
<span class="line-added">2443      *</span>
<span class="line-added">2444      * For more information, see FormattedValue::toString()</span>
2445      *
<a name="83" id="anc83"></a>




2446      * @draft ICU 62
<a name="84" id="anc84"></a>
2447      */
<a name="85" id="anc85"></a><span class="line-modified">2448     UnicodeString toString(UErrorCode&amp; status) const U_OVERRIDE;</span>
2449 
<a name="86" id="anc86"></a><span class="line-modified">2450     // Copydoc: this method is new in ICU 64</span>
<span class="line-added">2451     /** @copydoc FormattedValue::toTempString() */</span>
<span class="line-added">2452     UnicodeString toTempString(UErrorCode&amp; status) const U_OVERRIDE;</span>
<span class="line-added">2453 </span>
<span class="line-added">2454     // Copybrief: this method is older than the parent method</span>
2455     /**
<a name="87" id="anc87"></a><span class="line-modified">2456      * @copybrief FormattedValue::appendTo()</span>

2457      *
<a name="88" id="anc88"></a><span class="line-modified">2458      * For more information, see FormattedValue::appendTo()</span>


2459      *
<a name="89" id="anc89"></a><span class="line-modified">2460      * @draft ICU 62</span>










2461      */
<a name="90" id="anc90"></a><span class="line-modified">2462     Appendable &amp;appendTo(Appendable&amp; appendable, UErrorCode&amp; status) const U_OVERRIDE;</span>
<span class="line-modified">2463 </span>
<span class="line-added">2464     // Copydoc: this method is new in ICU 64</span>
<span class="line-added">2465     /** @copydoc FormattedValue::nextPosition() */</span>
<span class="line-added">2466     UBool nextPosition(ConstrainedFieldPosition&amp; cfpos, UErrorCode&amp; status) const U_OVERRIDE;</span>
2467 
2468     /**
<a name="91" id="anc91"></a><span class="line-modified">2469      * Determines the start (inclusive) and end (exclusive) indices of the next occurrence of the given</span>
<span class="line-modified">2470      * &lt;em&gt;field&lt;/em&gt; in the output string. This allows you to determine the locations of, for example,</span>
<span class="line-modified">2471      * the integer part, fraction part, or symbols.</span>
<span class="line-added">2472      *</span>
<span class="line-added">2473      * This is a simpler but less powerful alternative to {@link #nextPosition}.</span>
2474      *
2475      * If a field occurs just once, calling this method will find that occurrence and return it. If a
2476      * field occurs multiple times, this method may be called repeatedly with the following pattern:
2477      *
2478      * &lt;pre&gt;
2479      * FieldPosition fpos(UNUM_GROUPING_SEPARATOR_FIELD);
2480      * while (formattedNumber.nextFieldPosition(fpos, status)) {
2481      *   // do something with fpos.
2482      * }
2483      * &lt;/pre&gt;
2484      *
2485      * This method is useful if you know which field to query. If you want all available field position
<a name="92" id="anc92"></a><span class="line-modified">2486      * information, use {@link #nextPosition} or {@link #getAllFieldPositions}.</span>
2487      *
2488      * @param fieldPosition
2489      *            Input+output variable. On input, the &quot;field&quot; property determines which field to look
2490      *            up, and the &quot;beginIndex&quot; and &quot;endIndex&quot; properties determine where to begin the search.
2491      *            On output, the &quot;beginIndex&quot; is set to the beginning of the first occurrence of the
<a name="93" id="anc93"></a><span class="line-modified">2492      *            field with either begin or end indices after the input indices; &quot;endIndex&quot; is set to</span>
2493      *            the end of that occurrence of the field (exclusive index). If a field position is not
2494      *            found, the method returns FALSE and the FieldPosition may or may not be changed.
2495      * @param status
2496      *            Set if an error occurs while populating the FieldPosition.
2497      * @return TRUE if a new occurrence of the field was found; FALSE otherwise.
2498      * @draft ICU 62
2499      * @see UNumberFormatFields
2500      */
2501     UBool nextFieldPosition(FieldPosition&amp; fieldPosition, UErrorCode&amp; status) const;
2502 
<a name="94" id="anc94"></a>
2503     /**
2504      * Export the formatted number to a FieldPositionIterator. This allows you to determine which characters in
2505      * the output string correspond to which &lt;em&gt;fields&lt;/em&gt;, such as the integer part, fraction part, and sign.
2506      *
<a name="95" id="anc95"></a><span class="line-modified">2507      * This is an alternative to the more powerful #nextPosition() API.</span>
















2508      *
<a name="96" id="anc96"></a><span class="line-modified">2509      * If information on only one field is needed, use #nextPosition() or #nextFieldPosition() instead.</span>
2510      *
2511      * @param iterator
2512      *            The FieldPositionIterator to populate with all of the fields present in the formatted number.
2513      * @param status
2514      *            Set if an error occurs while populating the FieldPositionIterator.
2515      * @draft ICU 62
2516      * @see UNumberFormatFields
2517      */
2518     void getAllFieldPositions(FieldPositionIterator &amp;iterator, UErrorCode &amp;status) const;
2519 
2520 #ifndef U_HIDE_INTERNAL_API
2521 
2522     /**
2523      *  Gets the raw DecimalQuantity for plural rule selection.
2524      *  @internal
2525      */
2526     void getDecimalQuantity(impl::DecimalQuantity&amp; output, UErrorCode&amp; status) const;
2527 
2528     /**
2529      * Populates the mutable builder type FieldPositionIteratorHandler.
2530      * @internal
2531      */
2532     void getAllFieldPositionsImpl(FieldPositionIteratorHandler&amp; fpih, UErrorCode&amp; status) const;
2533 
<a name="97" id="anc97"></a><span class="line-modified">2534 #endif  /* U_HIDE_INTERNAL_API */</span>






























2535 
2536   private:
2537     // Can&#39;t use LocalPointer because UFormattedNumberData is forward-declared
<a name="98" id="anc98"></a><span class="line-modified">2538     const impl::UFormattedNumberData *fData;</span>
2539 
2540     // Error code for the terminal methods
2541     UErrorCode fErrorCode;
2542 
2543     /**
2544      * Internal constructor from data type. Adopts the data pointer.
2545      * @internal
2546      */
2547     explicit FormattedNumber(impl::UFormattedNumberData *results)
<a name="99" id="anc99"></a><span class="line-modified">2548         : fData(results), fErrorCode(U_ZERO_ERROR) {}</span>
2549 
2550     explicit FormattedNumber(UErrorCode errorCode)
<a name="100" id="anc100"></a><span class="line-modified">2551         : fData(nullptr), fErrorCode(errorCode) {}</span>
2552 
2553     // To give LocalizedNumberFormatter format methods access to this class&#39;s constructor:
2554     friend class LocalizedNumberFormatter;
<a name="101" id="anc101"></a><span class="line-added">2555 </span>
<span class="line-added">2556     // To give C API access to internals</span>
<span class="line-added">2557     friend struct impl::UFormattedNumberImpl;</span>
2558 };
2559 
2560 /**
2561  * See the main description in numberformatter.h for documentation and examples.
2562  *
2563  * @draft ICU 60
2564  */
2565 class U_I18N_API NumberFormatter final {
2566   public:
2567     /**
2568      * Call this method at the beginning of a NumberFormatter fluent chain in which the locale is not currently known at
2569      * the call site.
2570      *
2571      * @return An {@link UnlocalizedNumberFormatter}, to be used for chaining.
2572      * @draft ICU 60
2573      */
2574     static UnlocalizedNumberFormatter with();
2575 
2576     /**
2577      * Call this method at the beginning of a NumberFormatter fluent chain in which the locale is known at the call
2578      * site.
2579      *
2580      * @param locale
2581      *            The locale from which to load formats and symbols for number formatting.
2582      * @return A {@link LocalizedNumberFormatter}, to be used for chaining.
2583      * @draft ICU 60
2584      */
2585     static LocalizedNumberFormatter withLocale(const Locale &amp;locale);
2586 
2587     /**
2588      * Call this method at the beginning of a NumberFormatter fluent chain to create an instance based
2589      * on a given number skeleton string.
2590      *
<a name="102" id="anc102"></a><span class="line-added">2591      * It is possible for an error to occur while parsing. See the overload of this method if you are</span>
<span class="line-added">2592      * interested in the location of a possible parse error.</span>
<span class="line-added">2593      *</span>
2594      * @param skeleton
2595      *            The skeleton string off of which to base this NumberFormatter.
2596      * @param status
2597      *            Set to U_NUMBER_SKELETON_SYNTAX_ERROR if the skeleton was invalid.
2598      * @return An UnlocalizedNumberFormatter, to be used for chaining.
2599      * @draft ICU 62
2600      */
2601     static UnlocalizedNumberFormatter forSkeleton(const UnicodeString&amp; skeleton, UErrorCode&amp; status);
2602 
<a name="103" id="anc103"></a><span class="line-added">2603     /**</span>
<span class="line-added">2604      * Call this method at the beginning of a NumberFormatter fluent chain to create an instance based</span>
<span class="line-added">2605      * on a given number skeleton string.</span>
<span class="line-added">2606      *</span>
<span class="line-added">2607      * If an error occurs while parsing the skeleton string, the offset into the skeleton string at</span>
<span class="line-added">2608      * which the error occurred will be saved into the UParseError, if provided.</span>
<span class="line-added">2609      *</span>
<span class="line-added">2610      * @param skeleton</span>
<span class="line-added">2611      *            The skeleton string off of which to base this NumberFormatter.</span>
<span class="line-added">2612      * @param perror</span>
<span class="line-added">2613      *            A parse error struct populated if an error occurs when parsing.</span>
<span class="line-added">2614  *                If no error occurs, perror.offset will be set to -1.</span>
<span class="line-added">2615      * @param status</span>
<span class="line-added">2616      *            Set to U_NUMBER_SKELETON_SYNTAX_ERROR if the skeleton was invalid.</span>
<span class="line-added">2617      * @return An UnlocalizedNumberFormatter, to be used for chaining.</span>
<span class="line-added">2618      * @draft ICU 64</span>
<span class="line-added">2619      */</span>
<span class="line-added">2620     static UnlocalizedNumberFormatter forSkeleton(const UnicodeString&amp; skeleton,</span>
<span class="line-added">2621                                                   UParseError&amp; perror, UErrorCode&amp; status);</span>
<span class="line-added">2622 </span>
2623     /**
2624      * Use factory methods instead of the constructor to create a NumberFormatter.
2625      */
2626     NumberFormatter() = delete;
2627 };
2628 
2629 }  // namespace number
2630 U_NAMESPACE_END
2631 
2632 #endif  // U_HIDE_DRAFT_API
2633 
2634 #endif // __NUMBERFORMATTER_H__
2635 
2636 #endif /* #if !UCONFIG_NO_FORMATTING */
<a name="104" id="anc104"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="104" type="hidden" />
</body>
</html>